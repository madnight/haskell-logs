00:00:00 <dons> goltrpoat: good thing multicore/smp is going to be popular soon...
00:00:13 <goltrpoat> dons:  yep, precisely
00:00:25 <dons> which will help distinguish haskell and erlang, from ocaml (and everyone else)
00:00:39 <eviltwin_b> perl was not always entrenched.  many ways it was not even CPAN tat launched it; arguably it was the original cgi-lib that did that
00:01:02 <lispy> eviltwin_b: interesting
00:01:17 <dons> goltrpoat: also, high assurance work is a niche too (haskell for verified kernels and so on). that's a growing (but obviously much smaller) domain
00:01:19 <eviltwin_b> so, much like the case with python, but it expanded from there
00:01:28 <sieni> dons: hmm... maybe I'll take a look at that
00:01:51 <eviltwin_b> quite possibly, then, it's a single "killer app" that is needed to bootstrap.
00:02:04 <dons> i'm sure there's some market differentiating features we can take advantage of
00:02:13 <goltrpoat> dons:  yeah, although, ada lends itself to high assurance, and who uses ada outside of darpa
00:02:18 <sreeram> is it possible in haskell to write a function which is functional from the outside, but which is internally implemented in a imperative style?
00:02:21 <dons> goltrpoat: right.
00:02:26 <dons> sreeram: yep
00:02:29 <dons> that's what monads do
00:02:43 <dons> for example, here's some imperative state encapsulate to appear pure from the outside:
00:02:51 <dons> :t Control.Monad.State.runState
00:02:53 <lambdabot> forall s a. State s a -> s -> (a, s)
00:03:04 <sreeram> dons, thanks
00:03:09 <dons> > flip runState 0 $ do x <- get ; put (x+1) ; return "yay"
00:03:10 <lambdabot>  ("yay",1)
00:03:16 <zeeeeee> whatever happened to hIDE?
00:03:21 <dons> the code to the right of the $, is effectively imperative
00:03:23 <sjanssen> sreeram: Control.Monad.ST gives you state, complete with references and mutable arrays
00:03:26 <zeeeeee> all this talk about tools and no mention thereof
00:03:26 <goltrpoat> zeee:  no idea, it sounded good on paper
00:03:35 <dons> zeeeeee: not enough devs :)
00:03:43 <dmead> emacs is fine
00:03:47 <sjanssen> sreeram: I'd suggest waiting to tackle ST until you've had some practice in Haskell though
00:03:48 <dmead> or vim if your stooopid
00:03:49 <dons> emacs and vim were fine in the end
00:04:01 <dons> windows guys (or mac guys) who care about uis/ides, need to take up the banner
00:04:06 <sieni> Yi! ;-)
00:04:10 <sreeram> sjanssen, i knew that you could use monads for state, my question was whether it is possible to escape from the monads, and encapsulate that into a functional interface
00:04:21 <sreeram> apparently its possible
00:04:26 <dons> sreeram: escape?
00:04:45 <dons> ah, you mean, run a monad, so its interface appears not to be monadic at all
00:04:51 <zeeeeee> do i get on-the-fly build errors ('squiggly red lines') with emacs?
00:04:53 <goltrpoat> ive used emacs a fair bit.  ran assorted linux and bsd boxed for a few years while in high school.  i honestly have no idea why someone would do that to themselves when there are modern tools available
00:04:58 <sreeram> for instance when using the IO monad, your function signature states that it does IO
00:05:02 <dons> > let (result, state) = flip runState 0 $ do x <- get ; put (x+1) ; return "yay" in return state + 3 -- for example
00:05:03 <lambdabot>  add an instance declaration for (Num (m s))
00:05:06 <sjanssen> sreeram: yes, that's the cool feature of ST.  It uses the type system to make sure that no mutation leaks outside of "runST", the function that returns the result of a stateful action
00:05:16 <dons> > let (result, state) = flip runState 0 $ do x <- get ; put (x+1) ; return "yay" in state + 3 -- for example
00:05:17 <lambdabot>  4
00:05:20 <sreeram> and it is not possible to encapsulate that into a function which is pure functional
00:05:27 <goltrpoat> boxed=boxes
00:05:30 <dons> sreeram: its only the IO monad that can't be escaped from
00:05:32 <lispy> goltrpoat: what do you prefer?
00:05:36 <sreeram> dons, ok
00:06:01 <sjanssen> sreeram: and the examples that dons is showing you are in the State monad, which is actually implemented with pure functions, no black magic
00:06:02 <goltrpoat> lispy:  honestly, i can find very few things wrong with visual studio.  i hear codeblocks is nice for c++, been meaning to check that out.
00:06:03 <dons> (and even then it can, using unsafePerformIO -- but you have to provide your own proof that the imperative code is indeed referentially transparent on the outside)
00:06:04 <lispy> goltrpoat: i'm quite happing with developing with linux and emacs, i prefer it over VS that i have to use at work
00:06:05 <zeeeeee> heck, i can't even get a program to indent haskell
00:06:15 <opqdonut> zeeeeee: emacs or vim
00:06:16 <dons> ?wiki Indent
00:06:16 <lambdabot> http://www.haskell.org/haskellwiki/Indent
00:06:17 <dons> zeeeeee: ^^
00:06:35 <zeeeeee> opqdonut, dons: i know, i'm using the haskell emacs package, but it's very manual
00:06:49 <zeeeeee> it doesn't actually know how to indent the code on its own
00:07:03 <dons> zeeeeee: remember this: "06.07.02:14:19:38 <zeeeee> hi all, anybody know if/how i can get vim to auto indent my haskell files?"
00:07:21 <dons> "06.07.06:14:23:54 <zeeeee> hi all, is there an editor/ide/ide mode that can properly indent haskell?"
00:07:24 <dons> :)
00:07:26 <sreeram> sjanssen, thanks
00:07:31 <zeeeeee> dons: yeah, haskell made me switch to emacs
00:07:36 <zeeeeee> believe it or not
00:07:42 <goltrpoat> lispy:  there are a few cosmetic things that i dislike about vs, and a few bugs in 2005 (eg, broken intellisense)
00:07:43 <sjanssen> I waste too much time indenting Haskell code
00:08:00 <zeeeeee> but way to avoid the real question :)
00:08:29 <dons> zeeeeee: did you realise you always introduce youself with: "<zeeeee> hi all, i .."
00:08:41 <zeeeeee> dons: haha yeah :)
00:08:55 <lispy> goltrpoat: my favorite bug today in VS is when we had an app in VB and it silently cloned the event hanlder method a few times...we didn't notice until later when a bunch of event handling changes didn't seem to work on some machines
00:09:00 <sjanssen> typical Haskell style (lining up -> | =) means lots of fumbling with spaces
00:09:02 <lispy> s/today/to date/
00:09:30 <goltrpoat> better than this guy i knew.  he'd introduce himself by entering the room and yelling "BAAAALLLLSS!!"
00:09:36 <dons> "<zeeeee> hi all, if i have a string like this | <zeeeee> hi all, i hear a lot about how great haskell is for parsing | hi all, can i get hugs/ghc to import from additional dirs | <zeeeee> hi all, this page describes a drawback of fp | <zeeeeee> hi all, are there any libraries with common string routines | <zeeeeee> hi all, i'm looking for critiques of my program | <zeeeeee> hi all, is currying just a special case of partial function applicat
00:09:40 <goltrpoat> we never quite figured out if it was a commentary style statement, or a request
00:09:44 <dons> ok that's just scary!
00:09:54 <dons> zeeeeee: are you a haskell bot? :)
00:10:05 <mbishop> hi all, do you think it's creepy that I say hi all all the time?
00:10:06 <goltrpoat> lispy:  oh, ive never touched VB, can't comment on that
00:10:29 <zeeeeee> hi all, i am not a haskell bot
00:10:32 <sreeram> :)
00:10:35 <opqdonut> :)
00:10:38 <mbishop> :)
00:10:42 <zeeeeee> :)
00:10:46 <lispy> :)
00:10:48 * eviltwin_b rolls his eyes
00:10:50 <mbishop> heh
00:10:52 <zeeeeee> nooo
00:10:52 <dons> zeeeeee: ok, this is just weird: http://www.cse.unsw.edu.au/~dons/tmp/zeeeee.txt
00:10:54 <zeeeeee> you killed it
00:11:01 <goltrpoat> hahaha
00:11:20 <zeeeeee> what's wrong with that!
00:12:05 <zeeeeee> that's what i thought
00:12:15 <dons> in general, its a bad sign if you stereotype youself such that people ask if you're a bot ...
00:12:45 <dons> zeeeeee: are you making progress with your .hs hacking? I guess so?
00:13:15 <zeeeeee> dons: .hs hacking?
00:13:31 <dons> ok. lesson one: haskell files have the .hs extension
00:13:36 <dons> ;)
00:13:46 <zeeeeee> dons: .lhs ftw!!!!
00:13:51 <dons> heh ok
00:14:50 <dons> heya _lygaret
00:14:56 <dons> back for another round?
00:15:05 <_lygaret> heya dons; more or less
00:15:09 <zeeeeee> dons: sure. i like haskell a lot. it (partially) made me switch from vim to emacs, start reading LTU, and start (re-)learning scheme and lisp.
00:15:19 <dons> cool
00:15:25 <lispy> dons: hm...i had 56 patches to pull and it's still pulling
00:15:31 <dons> lispy: lambdabot?
00:15:36 <lispy> (I started back when you gave me ideas how to implement this, yeah lambdabot )
00:15:37 <_lygaret> I've been trying to get this into a state monad, but I can't really figure out what I'm supposed to be threading
00:15:48 <dons> lispy: hmm. probably state conflicts?
00:15:52 <_lygaret> zeeeeee, you can use vim for haskell ;)
00:15:53 <dons> try a --partial from scratch?
00:15:53 <lispy> oh
00:16:11 <dons> _lygaret: ok, so the machine state that has to be updated would go in the monad
00:16:15 <lispy>  8531 dagit     25   0  108m  82m  29m R 99.8  8.3  14:42.27 darcs
00:16:18 <dons> i.e the current position of the tape, and so on
00:16:19 <zeeeeee> _lygaret: yeah, but it's not as slick as the emacs + haskell package
00:16:37 <_lygaret> so, I get that
00:16:48 <dons> so for example
00:16:49 <_lygaret> but then what does the execute function do?
00:16:52 <zeeeeee> _lygaret: plus it inspired me to learn langs like elisp
00:17:16 <dons> > flip runState 0{-initial state -} $ do let eval = do x <- get ; put (x+1) in eval
00:17:17 <lambdabot>  ((),1)
00:17:34 <dons> _lygaret: so then your execute function doesn't have to thread those state arguments manually
00:17:41 <dons> you use get/put to read and write them instead
00:17:49 <_lygaret> :t flip
00:17:51 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
00:18:04 <dons> > runState ( do let eval = do x <- get ; put (x+1) in eval ) 0 -- other way around
00:18:06 <lambdabot>  ((),1)
00:18:07 <goltrpoat> that whole discussion on haskell-cafe yesterday, about reifying (a -> [b]) -> [a -> b] ..  isn't any function a -> [b] going to equal \x -> [] ?
00:18:14 <_lygaret> ok
00:18:40 <lispy> dons: recorded everything i cared about, reverted everything else and now trying gain
00:19:30 <_lygaret> hmm - what would the type of the execute function be then? does runstate just spit out the contents of the state after the fact?
00:19:42 <dons> _lygaret: right
00:19:55 <dons> so eval would be something like:  eval :: State Machine
00:19:59 <_lygaret> execute :: State (MachineState) -> State (MachineState)?
00:19:59 <dons> where Machine is the state type
00:20:05 <_lygaret> this is what's screwing me u
00:20:20 <dons> nope, it doesn't take a state monad argument
00:20:24 <dons> runState does that
00:20:25 <lispy> dons: this time it finished
00:20:29 <_lygaret> ohhhhh
00:20:29 <goltrpoat> im fairly sure i'm missing something, since no one else has piped in, but i can't find a counterexample
00:20:42 <dons> :t Control.Monad.State.runState
00:20:43 <lambdabot> forall s a. State s a -> s -> (a, s)
00:20:54 <_lygaret> runstate is a function which takes a state monad, executes it (though it's not really a function) and returns the state
00:21:04 <dons> _lygaret: so it takes a chunk of code in the state monad (your execute function), and an initial state
00:21:12 <dons> and then executes that code with that state, returning a result, and the final state
00:22:02 * dons home
00:22:10 <_lygaret> ok, i think i get that
00:22:22 <_lygaret> give me 10 minutes and I'll pipe up again :D
00:22:22 <_lygaret> thanks
00:22:30 <goltrpoat> (this is forall a b obviously)
00:26:48 <goltrpoat> so if f has the type (a -> [b]) -> [a -> b], and we know that f g = f (\_ -> []), then we're asking to pull [a -> b] out of a hat, and that gets us f = const []
00:27:06 <_lygaret> dons - if the exec is going to be recursive, should I just be putting the new state in the monad and then return do exec?
00:27:39 <_lygaret> instead of trying to return something explicit
00:28:33 <JohnMeacham> hello.
00:28:42 <goltrpoat> obviously you can come up with any number of things with that signature, but the second we find an argument to apply it to, we wind up with const []
00:29:18 <goltrpoat> anyway, i gotta be missing something here.
00:30:50 <lispy> goltrpoat: yeah, which makes me wonder why the 'a' in (a -> [b]) is even there, why not just use id on the [b]
00:31:10 <lispy> goltrpoat: or better yet...just use the [b] :)
00:33:26 <goltrpoat> ok, so i'm not on crack then
00:33:31 <_lygaret> how does the state monad know what is going to be returned?
00:33:32 <goltrpoat> why this long discussion about it then? :)
00:33:35 <_lygaret> how does the state monad know what is going to be returned?
00:33:44 <_lygaret> whoops.
00:33:47 <goltrpoat> however you reify it, you can't apply it to anything non-trivial
00:34:11 <_lygaret> If the type is just State a
00:34:11 <_lygaret> ?
00:36:43 <goltrpoat> @djinn f ? a -> [b]
00:36:44 <lambdabot> Cannot parse command
00:36:48 <goltrpoat> @djinn a -> [b]
00:36:48 <lambdabot> -- f cannot be realized.
00:36:58 <goltrpoat> eh?
00:37:00 <goltrpoat> sure it can
00:37:35 <goltrpoat> @type \_ -> []
00:37:36 <lambdabot> forall a t. t -> [a]
00:37:45 <goltrpoat> odd.
00:38:14 <goltrpoat> oh well.  just got confused by the whole discussion being a day old, having 7 posts in it, and no one pointing this out
00:38:27 <_lygaret> :t do let eval = do x <- get ; put (x+1) in eval
00:38:28 <lambdabot> forall s (m :: * -> *). (Num s, MonadState s m) => m ()
00:41:03 <goltrpoat> :t get >>= put . (+1)
00:41:05 <lambdabot> forall s (m :: * -> *). (MonadState s m, Num s) => m ()
00:41:47 <goltrpoat> (more readable, if you squint just right)
00:43:52 <lispy> dons: i'm gonna have to save this plugin for later
00:44:06 <_lygaret> really fast, anyone, if I have a state monad holding a state type called MachineState, and the whole thing should spit out a type called Tape at the end, what would the type of the function be?
00:44:11 <lispy> dons: it won't be long when written but it's going to take me a bit to figure it out, and i'm short on time today :(
00:44:22 <_lygaret> I have runMachine :: State Machine
00:44:31 <lispy> dons: thanks for your/pointers though
00:44:36 <_lygaret> but it complains that State is applied to too few arguments
00:44:50 <_lygaret> but runMachine :: State Machine Tape seems not to be right either
00:45:08 <_lygaret> :t State
00:45:09 <lambdabot> forall a s. (s -> (a, s)) -> State s a
00:45:33 <_lygaret> where s is the state type and a is the result?
00:45:35 <_lygaret> hmm.
00:46:54 <_lygaret> @paste
00:46:54 <lambdabot> http://paste.lisp.org/new/haskell
00:47:07 <_lygaret> @rafb
00:47:08 <lambdabot> Unknown command, try @list
00:47:10 <_lygaret> @list
00:47:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:47:27 <goltrpoat> rafb if raphie's site (efnet c++)
00:48:16 <goltrpoat> http://rafb.net/paste/ , although i'm not sure if i'd recommend pasting haskell code in there
00:48:37 <_lygaret> except, paste.lisp.org is done
00:48:37 <_lygaret> down
00:48:43 <_lygaret> different?
00:49:32 <goltrpoat> there's lisp.pastebin.com
00:49:44 <goltrpoat> paste.lisp.org needs to stop going down though.  that's the one with the haskell mode, right
00:51:45 <_lygaret> gah
00:51:50 <_lygaret> pastebin has a db error?
00:52:06 <_lygaret> rafb it is!
00:52:20 <_lygaret> or just 2html.vim
00:56:16 <_lygaret> does anyone mind looking at this: http://jon.crazybaglok.com/haskell/TuringState.hs.html and telling me what I'm doing wrong?
00:56:17 <lambdabot> Title: ~\Desktop\turing\TuringState.hs.html
00:56:30 <_lygaret> It'll be quick work for someone familiar
00:56:42 <_lygaret> there's three lines (commented) which I think are wrong
00:57:06 <_lygaret> two are recursive invocations of a state monad function, and one is the runState invocation
01:03:17 <_lygaret> > runState ( do let eval = do <- get ; put (x+1) in eval ) 4
01:03:18 <lambdabot>  Parse error
01:03:27 <_lygaret> > runState ( do let eval = do x <- get ; put (x+1) in eval ) 4
01:03:28 <lambdabot>  ((),5)
01:03:35 <_lygaret> :t runState ( do let eval = do x <- get ; put (x+1) in eval ) 4
01:03:36 <lambdabot> forall s. (Num s) => ((), s)
01:03:52 <_lygaret> :t do let eval = do x <- get ; put (x+1) in eval
01:03:54 <lambdabot> forall s (m :: * -> *). (Num s, MonadState s m) => m ()
01:04:08 <goltrpoat> your state is (stuff, [list], [list], morestuff)... and then you have an irrefutable pattern on the second [list] that looks like rtape@(rsym,_)
01:04:14 <goltrpoat> which is (a,b), not [a]
01:04:25 <goltrpoat> so that's a start
01:05:03 <_lygaret> it should be (rsym:_) right?
01:05:06 <_lygaret> yeah - ok
01:05:19 <goltrpoat> if you want rsym to match the head, sure
01:05:30 <_lygaret> yeah
01:06:10 <goltrpoat> but then you're returning runMachine, which is State Machine Tape
01:06:12 <goltrpoat> you want to return a Tape
01:06:24 <goltrpoat> (or at least that's what the type signature is saying)
01:06:29 <_lygaret> do I have to runState again?
01:06:33 <_lygaret> and it's the truth
01:06:40 <_lygaret> I think
01:06:43 <_lygaret> ;)
01:08:30 <_lygaret> basically, how do you do a recursive monad?
01:08:44 <_lygaret> on return, how do you get it to call the function again?
01:09:09 <_lygaret> because, as far as I can tell, it takes no arguments
01:09:14 <goltrpoat> instead of return runMachine.. why not runMachine?
01:09:22 <goltrpoat> and return your tape when you're done with the state
01:09:32 <goltrpoat> (to break the recursion i mean)
01:11:06 <goltrpoat> so MoveHalt is fine, execute is fine
01:11:12 <goltrpoat> change return runMachine to runMachine
01:11:24 <goltrpoat> and you got one last issue at the end of the where block in the MoveLeft case
01:11:25 <_lygaret> alright - let me play with that
01:11:26 <_lygaret> thanks
01:11:38 <_lygaret> just parens?
01:12:59 <goltrpoat> doesn't look like it
01:13:09 <goltrpoat> i need a cigarette though, so brb.
01:13:17 <_lygaret> alright - thanks
01:20:12 <goltrpoat> the whole runState :: SomethingWithEncapsulatedState -> SomeType with runState = do { case whatDoIDoNow of keepGoing -> runState; ... stopNow -> return valueOfSomeType } thing seems to be a common pattern btw
01:20:39 <goltrpoat> err.  SomethingWithEncapsulatedState SomeType, rather
01:21:29 <_lygaret> I think I got it
01:21:59 <_lygaret> you'll have to say that again lol
01:22:25 <goltrpoat> hehe sorry, i realized about halfway through that the verbose names weren't really helping
01:22:38 <_lygaret> whoo! It works
01:22:39 <goltrpoat> main = main {- infinite loop -}
01:22:57 <_lygaret> now I just have to figure out why...
01:23:19 <goltrpoat> main = getLine >>= \s -> case s of "quit" -> return (); otherwise -> main   {- loop until the user types "quit" -}
01:23:36 <_lygaret> oooh
01:23:40 <_lygaret> I get it
01:23:41 <_lygaret> I think
01:24:02 <goltrpoat> main = do { s <- getLine; case s of "quit" -> return (); otherwise -> main }  {- same thing, with do notation -}
01:24:11 <_lygaret> you type faster than I do ;)
01:24:27 <goltrpoat> hehe
01:24:37 <_lygaret> awesome, thanks goltrpoat
01:24:39 <goltrpoat> np
01:28:30 <goltrpoat> there really should be a list of common micro-patterns like that somewhere, especially for monad code.  so people don't keep reinventing, eg, mapM and friends
01:29:27 <_lygaret> You know, things like that would go well in a book that's more practical than the intro to haskell for a PL class type book
01:29:37 * goltrpoat pokes dons
01:29:53 <goltrpoat> we want a book.
01:30:10 <_lygaret> dons, you're writing it?
01:30:21 <_lygaret> I'll order a couple. When's it done ;)
01:30:24 <goltrpoat> don't think so, but he should be.
01:30:29 <goltrpoat> i think that's been brought up before
01:30:37 <sieni> quite, eh?
01:30:47 <_lygaret> engineering with haskell
01:30:54 <sieni> oops, my bad :-)
01:31:51 <_lygaret> having just graduated from uni, I can tell you something that I could show my manager that would convince him all the uni stuff I learned is useful would be awesome.
01:31:59 <_lygaret> I'd buy one for every manager at my company
01:32:38 <_lygaret> plus two: one for me and me later when it's finally been destroyed by years of thumbing ;)
01:34:07 <_lygaret> anyhow - 2:30am time for sleeping
01:34:15 <_lygaret> thanks goltrpoat, a lot!
01:34:24 <goltrpoat> heh, i was just trying to figure out where that'd actually work.  the best case scenario i could come up with is the manager has an engineering background, and you're working at a place that actually needs to create new tech to make money
01:34:34 <goltrpoat> no problem
01:34:41 <_lygaret> well, not Sun, I'll tell you what
01:34:50 <_lygaret> though I could probably try and give it to all the java guys
01:34:53 <_lygaret> and see what happens
01:36:34 <_lygaret> anyhow, night y'all
01:36:35 <_lygaret> thanks again
01:37:06 <_lygaret> dons if you're around thanks! I'll ask you about something else when I see you :D
01:37:22 <dons> hey back
01:37:33 <_lygaret> hey, thanks again dons
01:37:37 <dcoutts__> @yarr!
01:37:38 <lambdabot> Drink up, me 'earties
01:37:43 * dcoutts__ is in Stockholm again
01:38:42 <dons> hey dcoutts__
01:38:51 <dcoutts__> hia dons
01:39:21 <goltrpoat> goddammit, what is it with cs phds and their cosmopolitan lifestyles.  every time i read about someone doing language work, they're blogging from andalusia on a donkey-powered VAC
01:39:24 <goltrpoat> i need that kind of life.
01:39:43 <dons> goltrpoat: hehe
01:40:00 <dons> dcoutts__: so we got the hotel in france booked?
01:40:23 <dcoutts__> dons: I've not heard it confirmed but I believe so
01:40:34 * dcoutts__ checks his email
01:40:35 <goltrpoat> i was doing so well, and then typoed on the last letter.
01:41:06 <dons> dcoutts__: ok great. off to france! cosmopolitan-style
01:41:36 <dons> dcoutts__: also, is it likely to be very cold in oxford? i.e. snowing?
01:41:38 <dcoutts__> dons: cosmo-style ?
01:41:47 <dcoutts__> dons: hah hah, snow!? No.
01:41:56 <dons> really? ok :)
01:42:13 <_lygaret> night y'all
01:42:31 <dcoutts__> dons: we normally get one day of snow a year, and it lasts on the groud for a couple days before melting. It's always very disapointing.
01:42:45 <dons> ah ok.
01:42:50 <dcoutts__> dons: there's not even snow in Stockholm yet
01:43:13 <dcoutts__> sieni: y'ok. :-)
01:43:13 <therp> vienna, no snow. unusual for december.
01:43:24 <therp> oh hello georg-vienna.
01:43:29 <georg-vienna> hello :)
01:43:44 <georg-vienna> is this the haskell programming language channel ?
01:43:45 <therp> georg I suppose you are from wien?
01:43:51 <therp> georg: positive
01:43:58 <georg-vienna> so it is
01:44:03 <georg-vienna> ;)
01:44:20 <dcoutts__> sieni: Fawzi is certianly still here, I don't know most of the other admin folks.
01:44:33 <therp> I never did any nationality scan here.. I haven't seen anyone from Austria around here.. but hm
01:44:50 <goltrpoat> i lived in germany for a couple of years, does that count
01:45:09 <therp> goltrpoat: we are not part of germany :) at least not at the moment.
01:45:13 <dcoutts__> sieni: I can't pm you.
01:45:16 <goltrpoat> geez.
01:45:19 <sieni> dcoutts__: ahh, ok :-)
01:45:23 <goltrpoat> i know austria is not part of germany.
01:45:39 <goltrpoat> yet.
01:45:44 <goltrpoat> (mwahaha)
01:45:57 <georg-vienna> i have some problem with a small hugs program maybe someone of you can help me with this
01:46:04 <georg-vienna> is there some place to paste code ?
01:46:09 <therp> @paste
01:46:09 <lambdabot> http://paste.lisp.org/new/haskell
01:46:28 <robreim> When importing a module which exports all symbols from a second module, is there a way to hide the second module?
01:46:34 <goltrpoat> therp:  we just established it was down
01:46:39 <georg-vienna> i got a proxy error :(
01:46:50 <therp> goltrpoat: oh, I missed that
01:47:04 <goltrpoat> we seriously need a second site, paste.lisp.org has all the up time of.. uh.
01:47:12 <goltrpoat> i'm not sure how to finish that sentence without being rather obscene
01:47:30 <goltrpoat> er.  second paste site, rather
01:48:21 <goltrpoat> http://rafb.net/paste/ is up
01:48:26 <goltrpoat> no haskell mode there though.
01:48:43 <goltrpoat> and there's lisp.pastebin.net
01:48:47 <goltrpoat> and there's lisp.pastebin.com
01:48:52 <goltrpoat> (rather)
01:49:07 <robreim> dcoutts__: I just noticed the modules ListStoreNew and TreeStoreNew. I take it the old ones are deprecated? Got any suggestion on how to import Graphics.UI.Gtk and ListStoreNew at the same time?
01:49:31 <goltrpoat> the latter is useful if you want to see how well eiffel syntax highlighting works with haskell code.
01:49:54 <dcoutts__> robreim: the old ones will be included in the upcomming release and the new ones are a 'preview' / 'experimental'.
01:50:36 <dcoutts__> robreim: so we encourage people to try them out so we can settle on a final api. You can import them directly and use qualified to prevent name clashes.
01:50:51 <robreim> *nods* ok, thanks
01:50:53 <goltrpoat> dons:  did you see my micro-patterns comment from earlier btw?
01:51:29 <robreim> btw dcoutts__, did you get my emails about treeModelIterNext?
01:51:50 <dcoutts__> robreim: still going through my email, I'll tell you if I don't find it.
01:51:57 <georg-vienna> ok i pasted it as cleartext
01:51:57 <georg-vienna> http://rafb.net/paste/results/Eq2W9t94.html
01:52:01 <robreim> ok, cool.
01:52:17 <georg-vienna> when i run Main> fib 2
01:52:25 <georg-vienna> i got following error
01:52:31 <georg-vienna> Program error: pattern match failure: fib_v1966 2
01:52:31 <georg-vienna> [divAndConquer_v1952 fib_v1965 fib_v1966 fib_v1964 fib_v1963 (fib (2
01:52:31 <georg-vienna> - 1)),divAndConquer_v1952 fib_v1965 fib_v1966 fib_v1964 fib_v1963
01:52:31 <georg-vienna> (fib (2 - 2))] ++ map_v810 (divAndConquer_v1952 fib_v1965 fib_v1966
01:52:31 <georg-vienna> fib_v1964 fib_v1963) []
01:52:47 <georg-vienna> the same with quicksort
01:53:06 <dons> goltrpoat: micro patterns?
01:53:18 <dons> georg-vienna: do you happen to have ghc installed?
01:53:25 <dons> (instead of hugs?)
01:53:33 <dons> (you'll get much nicer error msgs)
01:53:41 <goltrpoat> dons:  about a page or two up, if you have the backlog
01:54:31 <dons> ok. just gotta cook dinner first :)
01:54:43 <therp> has anyone read the Practical foundations of Programming Languages book? from the ToC I should really read it
01:54:59 <goltrpoat> dons:  lygaret was having some trouble with recursing in monad code, and i realized that the correct solution has been done thousands of times, for all kinds of problems
01:55:30 <dons> hehe. looks like gizmo on reddit is now reading the HWN, and posting articles that are linked to there...
01:55:41 <dons> go	ah ok.
01:55:44 <dons> goltrpoat: ok
01:55:47 <goltrpoat> and there's a number of other things like that that don't quite qualify as architectural patterns, but they're useful enough that having a place to either refer people to, or a place for people to look at, would help a lot
01:56:02 <DebolazX> If I were to judge by the attendance and activity in this channel then Haskell would be a fairly popular language. Yet I rarely see any real life applications written in Haskell, the only ones I can think of that have crossed my path are darcs and pugs. Why is that?
01:56:37 <dons> most of the big apps are for research projects, or compilers you've not heard of
01:56:51 <goltrpoat> georg-vienne:  your combine function doesn't handle all the cases
01:56:51 <dons> DebolazX: check the 'libraries and applications' page of haskell.org, for a fairly complete list
01:56:56 <therp> georg: don't you miss a base case for combine?
01:56:59 <araujo> morning!
01:56:59 <goltrpoat> er.  vienna, rather
01:57:22 <goltrpoat> wien.  himmeldonnerwetter.  druecken und dings.
01:57:57 <georg-vienna> sorry what do you mean with a "base case" ?
01:58:00 <therp> herrschaftszeiten nocheinmal! :)
01:58:06 <georg-vienna> ^^
01:58:10 <therp> georg-vienna: combine _ [] for instance
01:58:21 <georg-vienna> you mean the guards
01:58:28 <georg-vienna> ok
01:58:36 <goltrpoat> what compiler gave you that message anyway?
01:58:39 <therp> georg-vienna: but it seems like concat p s = concat s
01:59:24 <therp> georg-vienna: I guess s is a list of results you want to combine right? I think you just have a superficial [] around both s's
02:01:27 <roconnor> where does dons find all those blog posts about haskell?
02:01:43 <Olishna> hi 2 all
02:02:17 <goltrpoat> roconnor:  haskell sequence and google
02:02:25 <goltrpoat> sigfpe's blog is just pure beauty though.
02:02:40 <goltrpoat> i spent two days in a row reading through the back entries, fucking excellent.
02:02:55 <goltrpoat> (http://sigfpe.blogspot.com/)
02:02:57 <lambdabot> Title: A Neighborhood of Infinity
02:03:59 <georg-vienna> therp: do you mean s looks like this: [[s]] [[s]]?
02:04:12 <goltrpoat> he means you're pattern matching against a singleton list
02:04:32 <therp> georg-vienna: no remove the singleton match. replace it with combine p s = sum s, in the instance of fib.
02:05:00 <therp> georg-vienna: but this does not give correct results for some reason I don't know yet :)
02:05:43 <goltrpoat> the base case for fib should be <= 2, not <= 1, no?
02:05:59 <georg-vienna> oh yes
02:06:04 <georg-vienna> thats right ;)
02:06:26 <goltrpoat> cept now we get a nice infinite loop on fib 5.
02:07:18 <goltrpoat> that's a cool abstraction though.
02:07:19 <kzm> Was there a tool to automatically run all QC properties in a source file?
02:07:51 <goltrpoat> never wouldve thought of that.
02:09:47 <dcoutts__> robreim: ah yes, you're quite right.
02:10:12 <dons> kzm, yeah, Lemmih's cabal-test
02:10:23 <kzm> OK, thx.
02:10:30 <dons> kzm, you could also write your own using the new parallel QC in a couple of lines
02:10:40 <kzm> :-)
02:10:52 <kzm> I'm waiting for a 4x dual-core server :-)
02:11:27 <dons> oh, I'm waiting for an 8x dual-core :)
02:11:39 <kzm> All I got now is 'hyper-threading', which isn't so hot.
02:11:43 <dons> yeah
02:11:45 <therp> georg: http://rafb.net/paste/results/qrseRB69.html
02:12:03 * kzm wonders if STM could be extended to distributed systems.
02:12:09 <therp> georg: also I would remove p as argument to combine. I don't see a reason why you would need it.
02:12:27 <kzm> clusters seem to be all the rage, not because it is what we want, but because it is what we can afford. :-)
02:12:58 <dons> yeah
02:13:03 <dons> bring on the 16 core machine, I say
02:13:10 <goltrpoat> they're interesting in part because of the core explosion
02:13:31 <goltrpoat> i.e. how can we generalize hardware threads to running stuff over the wire
02:13:44 <hrym> hi
02:13:52 <goltrpoat> and since there's a lot of research in the former, for the obvious reasons, some of it spills over into the latter
02:14:02 <goltrpoat> or.. that's what it's looking like, anyway.
02:14:28 <flux__> kzm, I imagine that would require two-stage transactions, which would also be nice for integrating filesystem/database-related transactions with STM
02:15:02 <goltrpoat> exactly.  i think STM is going to more or less replace pessimistic concurrency as a result
02:15:48 <goltrpoat> it's as good as your transaction manager, but taking out a mutex over the wire is an unpleasant idea once you realize what the alternatives are
02:17:05 <goltrpoat> (each mutex is suddenly a roundtrip, so if two threads are in lockstep, they are suddenly bottlenecked by the throughput)
02:18:03 <goltrpoat> good god should i be working right now.
02:18:12 <goltrpoat> oh well.
02:19:26 <kzm> dons: do you happen to know which FilePath I need (for cabal-test)?
02:19:32 <goltrpoat> kzm:  you might enjoy this:  http://lucacardelli.name/Papers/Obliq.pdf
02:20:28 <goltrpoat> he does use pessimistic concurrency in the paper, but it sort of forces you to try and figure out how STM can be applied
02:20:38 <goltrpoat> the core idea is very very cool though.
02:22:14 <Excedrin> anyone interested in a snippet of functional python? advice for stuff to add, or stuff to implement differently.. apparently it's either impossible or nearly impossible to define a set_ function..
02:23:14 <Olishna> smb help me
02:24:10 * Botje waves his arms around frantically
02:24:14 <Botje> Olishna: you have been helped.
02:24:36 * goltrpoat performs a kooky drumroll.
02:25:01 <goltrpoat> botje:  our job here is done.
02:26:52 <Botje> goltrpoat: yay. where to next?
02:27:12 <goltrpoat> fighting crime.
02:29:07 <Botje> it's been done
02:29:07 <dcoutts__> robreim: ping
02:29:19 <dcoutts__> robreim: if I push another fix can you test it ?
02:31:14 <goltrpoat> botje:  i suppose we ask batman how to deal with this existential crisis, then.
02:31:17 <goltrpoat> batman No such nick/channel
02:31:19 <goltrpoat> dammit!
02:31:55 <goltrpoat> olishna:  see what you've done?
02:32:27 <dons> ?where FilePath
02:32:28 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
02:32:30 <dons> kzm: ^^
02:33:13 <kzm> Ah, right.
02:33:33 <kzm> You should have lambdabot cough once in a while so I don't forget it.
02:33:52 <kzm> (Anyway, I just wrote a replacement function for the imported functionality :-/ )
02:33:53 <wolverian> @where goa
02:33:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
02:34:48 <Olishna> goltrpoat what?
02:35:10 <goltrpoat> ok, that's going on bash.org.
02:39:02 <georg-vienna> therp: thx for help, now it runs, there was an error in the divide line, no element was taken away, so it looped
02:39:14 <georg-vienna> bye
02:39:14 <kzm> Hmm cabal-test doesn't do what I want at this stage, I really wanted quickCheck (the script).  Can't seem to get it to work as is, though.  Is there an updated version?
02:39:19 <kzm> @where quickCheck
02:39:20 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
02:39:29 <kzm> (yes, that's the one I have)
02:40:19 <dons> kzm, you could perhaps find it in QC2?
02:40:29 <dons> (check last week's hwn for the link)
02:45:56 <robreim> dcoutts__: Sure, I can test it
02:45:57 <ikegami--> I've read the recent Haskell Weekly News and knows about QC2 and concurrent QC
02:46:15 <dcoutts__> robreim: ok, just making sure it compiles, I'll push it in a sec
02:46:21 <ikegami--> interesting
02:49:13 <kzm> QC2 doesn't seem to have a quickCheck script... but the error I get is: <command line>:
02:49:13 <kzm>     Could not find module `/home/ketil/bin/quickCheck':
02:49:13 <kzm>       Use -v to see a list of the files searched for.
02:49:22 <kzm> Any idea?
02:50:11 <kzm> Oh, it needs to be called quickCheck.hs (with the suffix)!
02:50:17 <dcoutts__> robreim: sent/pushed
02:50:54 <robreim> tah, I'll try it out
02:52:15 <kzm> (Isn't that an bug?  If I runghc something, shouldn't it open the file named 'something' rather than 'something.hs'?)
02:53:37 <lray80de> maybe a stupid question: how can I fill a array with a number of the same characters, let's say 5 times a "#" ... enumerate doesn't seem to do it, and to write ["#","#","#","#","#"] by hand isn't real fun... at least when it get's more then 5.
02:54:04 <goltrpoat> > replicate 5 '#'
02:54:06 <lambdabot>  "#####"
02:54:15 <lray80de> great, thnx
02:57:58 <kzm> > take 5 (repeat '#') -- a bit less succint
02:58:00 <lambdabot>  "#####"
02:59:11 <goltrpoat> > foldr (\_ > (:) '#') [1..5] -- even less succint
02:59:12 <lambdabot>  Parse error
02:59:18 <kzm> > unfoldr (\x -> case x of 5 -> Nothing; _ -> Just ('#',x+1)) 0
02:59:20 <lambdabot>  "#####"
02:59:23 <goltrpoat> > foldr (\_ -> (:) '#') [1..5] -- even less succint, too
02:59:24 <lambdabot>  add an instance declaration for (Num Char)
02:59:24 <lambdabot>   In an arithmetic sequence: [...
02:59:28 <goltrpoat> oy.
02:59:39 <goltrpoat> > foldr (\_ -> (:) '#') [] [1..5] -- even less succint, take 3
02:59:40 <lray80de> no prob, the "replicate" works pretty perfect. Didn't find it yesterday evening on zvon. Is there a possibility to take the time, a function needs to perform? I was experimenting around with "getClockTime", but get a problem when trying to call the function within the IO-do...
02:59:41 <lambdabot>  "#####"
03:00:07 <dons> lray80de: zvon's pretty obsolete. try reading the haddocks
03:00:11 <dons> ?docs Data.List
03:00:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
03:00:14 <kzm> what you need is a 'take' defined on IRC replies :-)
03:00:24 <kzm> ..to limit the number of responses.
03:00:28 <goltrpoat> http://www.haskell.org/hawiki/LibraryDocumentation/CPUTime#v%3AgetCPUTime
03:00:31 <lambdabot> Title: LibraryDocumentation/CPUTime - The Haskell Wiki, http://tinyurl.com/y3y4vg
03:00:42 <kzm> Too bad zvon is ranked pretty high with Google...
03:01:04 <goltrpoat> i was using zvon left and right when i was starting out
03:01:15 <goltrpoat> it's incomplete and the documentation is terrible, but it had its perks
03:01:26 <kzm> By the way - code search doesn't index bare files (as in darcs archives)?
03:01:47 <lray80de> kzm_: :-)
03:02:19 <kzm> Wasn't there a 'bot plugin to generate functions from a signature, btw?  djinn?
03:02:28 <goltrpoat> sure
03:02:40 <goltrpoat> ?djinn (a -> b) -> [a] -> [b]
03:02:41 <lambdabot> -- f cannot be realized.
03:02:48 <goltrpoat> dude.  what am i doing wrong there
03:02:49 <goltrpoat> hehe
03:02:49 <Cale> an interesting conjecture from one of Shallit's papers: By deleting some of the decimal digits of any power of two, one may obtain at least one of {1,2,4,8,65536}
03:03:05 <goltrpoat> ?djinn f :: (a -> b) -> [a] -> [b]
03:03:06 <lambdabot> Cannot parse command
03:03:11 <goltrpoat> ok, that's clearly not it.
03:03:22 <kzm> @djinn [a] -> [a]
03:03:23 <lambdabot> f a = a
03:03:36 <kzm> @djinn (a->b) -> [a] -> [b]
03:03:37 <lambdabot> -- f cannot be realized.
03:03:48 <goltrpoat> ok, that's map (f . somePermutation)
03:03:52 <kzm> ten buck says it can!
03:03:54 <goltrpoat> oh.  maybe it's the somePermutation bit.
03:04:21 <kzm> I think it is supposed to choose 'id' for that (as in the [a] -> [a] example)
03:05:06 <goltrpoat> cale:  that breaks my head.  how was that arrived at?
03:06:27 <Cale> There's an actually proven theorem here which says that by deleting some of the base-10 digits of any prime number, one may obtain {2,3,5,7,11,19,41,61,89,409,449,499,881,991,6469,6949,9001,9049,9649,9949,60649,666649,946669,60000049,66000049,66600049}
03:06:33 <Cale> (one of those)
03:06:50 <Cale> http://www.cs.uwaterloo.ca/~shallit/Papers/minimal5.ps
03:06:50 <goltrpoat> *just* one of those?
03:06:57 <Cale> at least one of those
03:07:03 <goltrpoat> no 6666000049?
03:07:16 <Cale> no
03:08:05 <kzm> Anyway: I patched the quickCheck script slightly to work with ghc etc, and put it (under darcs) at http://www.ii.uib.no/~ketil/quickCheck/
03:08:07 <lambdabot> Title: Index of /~ketil/quickCheck
03:08:49 <goltrpoat> ok, repunits sound familiar, i remember doing that
03:09:22 <goltrpoat> ok, the first paragraph basically sums up about 5% of putnam
03:09:23 <goltrpoat> haha
03:09:27 <Cale> Of course, the proof is just a horrible case analysis :)
03:09:37 <goltrpoat> yeah, i was thinking that can't be pretty
03:11:51 <roconnor> djinn doesn't do recursive data types such as lists
03:12:09 <dblhelix> dons: ping?
03:14:51 <dons> this guy's seeking advice: http://jpmoresmau.blogspot.com/2006/12/adventures-in-haskell-parsing-game.html
03:14:54 <lambdabot> Title: JP Moresmau's Programming Blog: Adventures in Haskell: parsing the game world, http://tinyurl.com/szyzn
03:14:55 <dons> dblhelix: yeah?
03:15:19 <dblhelix> dons: I was thinking about the wiki article on How to Write a Haskell Program...
03:15:28 <dons> yeah?
03:15:55 <dblhelix> dons: particularly about adding the quickcheck tests to darcs
03:16:17 <dblhelix> dons: doesn't darcs now always accept the patch even if it does not pass the tests
03:16:21 <dblhelix> ?
03:16:28 <dons> hmm?
03:16:32 <dons> maybe... actually
03:16:39 <dons> i noticed something simlar recently too
03:16:43 <dons> but didn't follow it up
03:17:22 <dblhelix> runhaskell Test.hs always exits with code 0
03:18:45 <dblhelix> it gets quite hairy to work around it though... i.e., per Test.QuickCheck.Batch
03:20:50 <dons> dblhelix: ah interesting
03:21:02 <robreim> dcoutts__: looks good against my tests! Thanks :)
03:21:04 <dons> dblhelix: so that really should be ExitFailure 1
03:21:11 <dcoutts__> robreim: great
03:21:18 <dblhelix> dons: yes, I guess so
03:21:59 <dblhelix> dons: afik, that's the only way to get darcs to reject patches based on running tests
03:22:48 <dblhelix> /s/afik/afaik
03:23:00 * dblhelix is off for lunch now...
03:44:17 <goltrpoat> one rather unfortunate result of my exposure to haskell is that i have giant chunks of production c++ code that look like such a kludge it's not funny, and i try to refactor it and realize that it's the language's fault, not mine
03:44:29 <lray80de> when I try to use a non-IO-Operation in the do-section of an IO-Part, I get the error "Couldn't match `IO' against `[]'" I read the notes under http://www.haskell.org/hawiki/ThatAnnoyingIoType, but don't understand it.
03:44:31 <lambdabot> Title: ThatAnnoyingIoType - The Haskell Wiki
03:45:25 <lray80de> How can I convert a normal String-Result into an IO-String-Result?
03:45:45 <Cale> lray80de: http://haskell.org/haskellwiki/Introduction_to_IO
03:45:46 <lambdabot> Title: Introduction to IO - HaskellWiki
03:46:04 <Cale> lray80de: that's what return does
03:48:46 <lray80de> Cale:works, thnx. Am not deep in to Haskell, but it seems to be a challenge.
03:49:03 <dons> :)
03:49:57 <Cale> Don't worry, IO in Haskell is something you get used to, and eventually you come to prefer it over the way it's done in a lot of other languages.
03:50:48 <Cale> The important thing to remember is that a value of type  IO String  is not a String at all, it's an action (with possibly real-world side effects) that produces a String when it runs.
03:51:06 <Cale> Evaluation doesn't cause these actions to run.
03:51:49 <Masklinn> hello everyone
03:51:58 <Cale> The only ways they get run are by being the  main  action of the program, or by you typing an action into GHCi/Hugs which will cause it to be evaluated and then run.
03:52:08 <Cale> hello Masklinn
03:52:55 <lray80de> Cale: okay, can't believe right now, that I'll prefer it one day.... but you never know. Thanks a lot for the help, it's interesting to get a view inside haskell.
03:53:55 <Cale> lray80de: well, one nice thing about it is that since you're working with these actions and you have these functions for combining them, you can write functions which act as control structures, and effectively add any control structure you want to Haskell.
03:54:37 <Cale> control structures are just functions which turn actions into different actions by chaining them up in some interesting way
03:54:53 <Cale> One basic building block which is often handy to know about is sequence
03:55:15 <Cale> sequence turns a list of actions into a single action which runs each in turn, computing a list of results.
03:56:38 <Cale> Closely related to that is mapM. You pass a function from values to actions to mapM, and a list of values, and it computes the actions to run and runs them all in sequence -- it's a loop.
03:56:52 <Cale> You might try  mapM print [1..10]
03:57:40 <lray80de> back in a sec.
03:58:29 <notsmack> Cale: enlightening; thanks.
03:59:16 <Cale> notsmack: no problem
04:01:43 <goltrpoat> we should start a cult.
04:01:59 <goltrpoat> use the tax breaks to fund research.
04:02:10 <goltrpoat> it'll be fantabulous.
04:06:12 <dons> goltrpoat: the Cult of the Bound Variable
04:06:58 <dons> ?users
04:06:59 <lambdabot> Maximum users seen in #haskell: 276, currently: 243 (88.0%), active: 27 (11.1%)
04:11:54 <Masklinn> @quote dons
04:11:55 <lambdabot>  [When asked what qualifications Guido van Rossum has...] a chip on his shoulder?
04:12:00 <Masklinn> @quote dons
04:12:00 <lambdabot>  my feeling is that the Java programmers will welcome us as liberators
04:12:10 <Masklinn> @quote dons
04:12:11 <lambdabot>  I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
04:13:10 <Masklinn> @quote dons
04:13:10 <lambdabot>   its like you can really see the guy's brain melting
04:13:14 <Masklinn> @quote dons
04:13:14 <lambdabot>  Java's type system is unsuitable for young children, the elderly or infirm of constitution
04:13:14 <norpan> @quote
04:13:15 <lambdabot> SimonRC says:  if performance was that important, people would be using perl, python, or the JVM
04:13:32 <Masklinn> @quote
04:13:33 <lambdabot> Entropy says: I agree; we need to remove Emacs' ridiculous dependency on a kernel being present
04:14:07 <Saizan> <lambdabot> SimonRC says:  if performance was that important, people would be using perl, python, or the JVM <-- why this nonsense?:D
04:14:27 * psnl hits SimonRC 
04:14:42 <psnl> if people cared, they would be using C, damnit
04:15:08 <Saizan> micro-optimized assembly!
04:15:13 <dons> maybe its a joke?
04:15:17 <norpan> @quote norpan
04:15:18 <lambdabot>  the comonad of the No monad is the Yes monad?
04:15:34 <psnl> dons: I know SimonRC's sense of humor
04:15:35 <norpan> hmmm
04:15:45 <norpan> who enters these quotes anyway
04:15:50 <dons> anyone
04:15:54 <dons> ?help remember
04:15:55 <lambdabot> quote <nick>
04:15:55 <lambdabot> remember <nick> <quote>
04:15:55 <lambdabot> Quote somebody, a random person, or save a memorable quote
04:16:25 <norpan> can you get a quote containing a specified word?
04:16:53 <dons> not yet.
04:17:04 <dons> that would be a useful, and easy patch to add though..
04:17:06 <dons> ?source
04:17:07 <lambdabot>  not available
04:17:14 <dons> ?versi
04:17:14 <lambdabot> lambdabot 4p296, GHC 6.5 (OpenBSD i386)
04:17:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:17:19 <dons> open up Plugin/Quote.hs
04:20:26 <Masklinn> dons > quotes are stored as a list of bytestrings right?
04:20:41 <dons> yep
04:20:58 <dons> type Quotes = M.Map P.ByteString [P.ByteString]
04:21:05 <dons> map of nick to a list of quotes by that person
04:21:12 <dons> which can be serialised directly to disk
04:21:55 <Masklinn> yeah but the nicks aren't used when doing a search on the list of quotes
04:22:15 <dons> right, you won't need that
04:22:25 <Masklinn> well you need them to print them
04:22:29 <dons> you can just get the elems of the quote list, and find all those that match
04:22:34 <dons> then return a random element of that list
04:22:45 <Masklinn> why not returning all of them?
04:22:48 <dons> so, for example @quote /foo/
04:22:53 <Saizan> flooding channel?
04:22:56 <Masklinn> not handled by lambdabot?
04:22:58 <dons> would return 1 (so as not to be spammy) from the list
04:23:03 <Masklinn> mm yeah good point Saizan
04:23:31 <Masklinn> that or return the number of matches, and ask for precision (either an index or more substrings to filter on) till only one match left?
04:23:34 <dons> and you can just use Text.Regex , to walk the list (or the bytestring regex interface)
04:23:48 <dons> nah, don't want to make it too tricky in the interface
04:23:53 <Masklinn> Well we don't have to use regex, simple substring search would already be neat
04:23:56 <dons> i'd either have a random elem, or cycle through the list
04:24:02 <dons> yep
04:24:08 <dons> so you can just use filter (==)
04:24:37 <Masklinn> ==? or ByteString's findSubstring?
04:24:45 <dons> that'd do too
04:24:59 <dons> findSubstring makes more sense :)
04:26:44 <Masklinn> could even compose findSubstring filters, to allow searches on multiple substrings
04:27:41 <paolino> hi, is this the syntax for a constrain on the subtype ?
04:27:42 <therp> small opinion poll: how is the Trends in Functional Programming Languages symposium? I just recognized it collides with ILC07 which is April 1-4, while TFP is April 2-4 :( .. now I have to decise which conference to got to/send papers to
04:27:42 <paolino> data Cell value => (Averageable value) = Cell {
04:28:39 <Masklinn> @ghc
04:28:40 <lambdabot>  internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
04:28:45 <Masklinn> @ghc
04:28:45 <lambdabot>  Simplifier reached fixed point
04:28:46 <dons> paolino: you want the 'value's to be Averagabe?
04:28:54 <paolino> yes
04:28:54 <Masklinn> @keal
04:28:55 <lambdabot> are there full body recognition files for sorting art?
04:29:07 <Masklinn> @b52s
04:29:08 <lambdabot> Hot pants explosion at the factory!
04:29:08 <dons> data (Averageable value) => Cell value = Cell ....
04:29:25 <dons> i.e. Averageable value implies Cell value
04:29:28 <Masklinn> @v
04:29:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
04:29:43 <Masklinn> @yhjulwwiefzojcbxybbruweejw
04:29:44 <lambdabot> Just 'J'
04:30:04 <Masklinn> damn, that quote module is full of retarded stuff, I like that
04:30:51 <dons> we had a funny lambdabot bug that printed that kind of stuff, if you crafted just the right expressoin :)
04:31:06 <dons> so it got preserved for all time, since we found it funny at the time
04:31:23 <dons> > take 20 $ fix show
04:31:24 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
04:35:33 <Masklinn> is there any script to build lambdabot on windows platforms (yeah I'm running windows at work, sue me)
04:35:47 <Masklinn> ?
04:37:44 <paolino> dons is also ?
04:37:45 <paolino> class (Monad M) => StateKeeper where
04:37:59 <Masklinn> what? Dons is a monad?
04:38:23 <dons> its been done, let me find the blog post, Masklinn
04:38:36 <Masklinn> well I don't claim it's original
04:38:46 <dons> paolino:  class (Monad m) => StateKeeper m where
04:39:10 <dons> Masklinn: really, the cabal build system should just work on windows too
04:39:16 <dons> (look in ./build for the commands)
04:39:23 <dons> this guy got it working, http://www.alpheccar.org/en/posts/show/59
04:39:24 <lambdabot> Title: Colorized lambdabot for Windows
04:39:37 <Masklinn> yeah I just noticed that there were cabal build files (not enough coffee yet)
04:39:45 <paolino> ok, sorry for my instinctive translations
04:39:49 <paolino> :P
04:41:27 <dons> that guy should really send me a patch, for colorised, win32 lambdabot...
04:46:45 <dons> so what's up with lisp paste? do we know what's going on?
04:46:50 <dons> ?paste
04:46:51 <lambdabot> http://paste.lisp.org/new/haskell
04:46:55 <Sam__> dons: it is still down?
04:47:16 <dons> it was down a couple of hour ago
04:47:23 <SamB> it was down on sunday too
04:47:24 <dons> which by my reckoning means several days now?
04:47:46 <dons> yep still down
04:47:59 <dons> lisppaste2: url?
04:47:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
04:48:04 <dons> nope
04:48:49 * SamB is asking in #lisp
04:49:40 <dons> cheers
04:50:22 <paolino> http://rafb.net/paste/results/fAJxxt86.html
04:50:23 <paolino> can I force b to be the same in all bethods ?
04:51:44 * paolino dresses up asbestos
04:52:17 <SamB> nobody answers
04:52:26 <SamB> but it is in the TOPIC there now that I look
04:52:57 <dons> yikes: "reddit broke (sorry)"
04:53:04 <dons> "you've done enough damage, please don't hit reload"
04:53:11 <dons> they should have stuck to lisp
04:53:23 <dons> SamB: what's in the topci?
04:54:07 <SamB> "lisppaste temporarily dead."
04:54:32 <SamB> curse x-chat for not letting me select something in one channel's topic, switch to another channel, and paste it into the input box!
04:54:56 <SamB> oh, cool, an answer
04:54:59 <SamB> <jsnell> the web interface of lisppaste is suffering from some kind of a bug that makes it loop infinitely, and has been taken down until the bug can be fixed
04:56:51 <paolino> dons , I go to work, I will ask better tonight, thanks
04:58:48 <dons> SamB: yikes
04:59:14 <dons> SamB: 1 more week and i'm writing lambdapaste
05:18:54 <lray80de> How can I find out, how long a function needs to be calculated?
05:18:54 <lray80de> doTest = do t1 <- getCPUTime
05:18:54 <lray80de>                     t2 <- do return (mySpecialTest)
05:18:54 <lray80de>                     t3 <- getCPUTime
05:18:54 <lray80de>                     print t1
05:18:54 <lray80de>                     print t2
05:18:56 <lray80de>                     return ("anything")
05:18:59 <lray80de> gives me the identical cpuTime twice. Cale told me about IO-Operations being actions done when they are evaluated. Is it the same here, and if so, how to manage it?
05:19:56 <dons> lray80de: its a lazy language, you've not evaluated the result of mySpecialTest there
05:20:22 <dons> lray80de: http://www.haskell.org/haskellwiki/Timing_computations
05:20:23 <lambdabot> Title: Timing computations - HaskellWiki
05:20:36 <dons> i.e. use `seq` to force the result of mySpecialTest to be evaluated
05:20:58 <dons> as it is, you don't use t2 till after the second getCPUTime, so it won't be evaluated till print t2 is run
05:21:46 <lray80de> dons: thnx, perfect!
05:31:46 <ndm> @seen Philippa
05:31:46 <lambdabot> Philippa is in #scannedinavian, #oasis, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 12h 6m 23s ago.
05:36:53 <Philippa> 'lo
05:37:18 <lray80de> dons: works fine, thanks again.
05:45:01 <ndm> @paste
05:45:01 <lambdabot> http://paste.lisp.org/new/haskell
05:45:49 <roconnor> @type evaluate
05:45:50 <lambdabot> Not in scope: `evaluate'
06:29:10 <therp> sorry for repeating that but small opinion poll: how is the Trends in Functional Programming Languages symposium? I just recognized it collides with ILC07 which is April 1-4, while TFP is April 2-4 :( .. now I have to decise which conference to got to/send papers to
06:46:08 <ndm> therp: i have been to TFP before
06:46:26 <therp> ndm: any comments? like gorgeous? or hmm.. not bad..  :)
06:46:32 <ndm> it was fun, lots of dependant type stuff, and the quality of the presentations weren't the highest - some were just slide after slide of type theory
06:46:43 <psnl> morning ndm
06:46:52 <ndm> afternoon psnl
06:47:01 <therp> ah, well I expected a lot of type theory, judging from the publications of the last year
06:47:35 <ndm> therp: it was fun, not bad, not great though - i definately preferred ICFP and HW to TFP, and also BCTCS as well
06:47:47 <ndm> its not one i'd definately go back to
06:48:30 <therp> hm ICFP October 2007..
06:48:39 <ndm> yep, i want to go to that
06:48:46 <ndm> although i preferred HW to ICFP when i went in 2005
06:49:27 <therp> freiburg,  nice, a friend lives in Basel. free accommodation yeah
06:49:29 <psnl> ndm: at some stage you were plotting a better parser generator for haskell. did you do it?
06:49:44 <therp> ndm: HW=Haskell Workshop?
06:49:45 <ndm> psnl: not yet, its still a plot though
06:49:49 <ndm> therp: yep
06:51:48 <therp> http://www.cs.nott.ac.uk/~gmh/icfp07-workshops.html ?! a deadline 11 month before the actual conference?
06:51:50 <lambdabot> Title: ICFP 2007 - Call for Workshop Proposals
06:52:28 <ndm> therp: thats for proposing workshops to be held with ICFP, not something many people do!
06:57:17 <therp> ndm: ICFP sounds nice judging from the last years'  programs
06:57:55 <ndm> therp: i liked it, i just prefered HW - some of the things in ICFP when i went were a bit weird (assembly code?) or a bit type theory heavy
07:01:08 <therp> ndm: HW happens when next year?
07:01:14 <therp> I haven't been able to google that
07:01:46 <ndm> therp: same time as ICFP, in the same place, either a few days before or after
07:02:03 <therp> ah ok, neato. :)
07:29:14 <fasta> hi
07:41:54 <matley> my hugs gives error if i import Control.Monad.List, but ghc compiles and runs well the same src. Why? (and btw why the emacs-mode use hugs as interpreter and not ghci?)
07:45:08 <eviltwin_b> are you running hugs in haskell98 mode?  it uses a flat namespace in that case
07:45:25 <eviltwin_b> as for the emacs mode, it's an arbitrary default, you can change it
07:46:27 <eviltwin_b> (setq haskell-program-name "ghci")
07:47:03 <Igloo> hugs will use hierarchial modules in H98 mode, but it won't load Control.Monad.List as it uses other extensions
07:47:26 <Igloo> Starting it with "hugs -98" will work
07:52:01 <Masklinn> @quote
07:52:02 <lambdabot> mathewm says: I am playing with (.)
07:53:16 <norpan> ah, the tit operator
07:54:51 <Botje> good ole tit.
08:15:23 <sjanssen> ndm: in http://neilmitchell.blogspot.com/2006/12/generalised-haskell.html how does the system decide between using the existing binding of id and shadowing with a new binding?
08:15:24 <lambdabot> Title: Neil Mitchell's Haskell Blog: Generalised Haskell
08:16:35 <sjanssen> also, is the system typed?
08:20:14 <mauke> @join #math
08:20:15 <lambdabot> Not enough privileges
08:20:26 <mauke> :(
08:38:17 <Masklinn> @quote
08:38:17 <lambdabot> madpickle says: Stuff costs more than it used to.
08:38:22 <Masklinn> @quote
08:38:23 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
08:41:27 <glguy> Currying, it's what separates us from the animals! http://programming.reddit.com/info/to4g/comments
08:41:29 <lambdabot> Title: Typing like a Functional Programmer (reddit.com)
08:42:39 <glguy> on curried functions: Sorry, but this is not helpful. Just what integer does it return? How do I write a unit test? :-)
08:42:55 <glguy> ... Since the function is named "add", passing it one argument is non-sensical.
08:43:23 <glguy> I'm sharing to allow my face to relax from the huge grin I've got on it
08:44:58 <osfameron> it's certainly odd if you don't understand it
08:45:06 <osfameron> and it's hard to explain
08:45:14 <Masklinn> there were almost the same comments on the Artima thread itself though
08:45:25 <dcoutts__> Lemmih: I was greatly cheered yesterday on the train going through Denmark by passing a town called "Middelfart". :-)
08:45:26 <Masklinn> had they just read the comments, they'd have seen the explanations
08:45:48 <glguy> I just enjoy the responses from people who assume that these new concepts must be stupid since they don't udnerstand them
08:45:56 <Masklinn> wait, he was quoting the artima comments...
08:46:02 * Masklinn fails again
08:46:20 <dcoutts__> Lemmih: sadly I was only in Copenhagen for 10 minutes, changing trains.
08:47:51 <Lemmih> dcoutts__: (:
08:47:53 <osfameron> glguy: yeah, that's a bit weak
08:52:13 <glguy> ?fptools Control.Monad.Cont
08:52:13 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Cont.hs
09:01:49 <cjeris> @quote cypherx
09:01:50 <lambdabot>  Oh god, C++ is like a lamprey in my urethra.
09:15:29 <Nafai> I figure a lot of people here use Darcs and Emacs...is there an Emacs mode of choice for Darcs?
09:18:45 <emu> darcsum perhaps
09:26:08 <lisppaste2> glguy pasted "Learning Cont" at http://paste.lisp.org/display/31261
09:26:17 <glguy> Does this use of Cont look "correct"?
09:27:31 <esap> why do you need nested 'where'?
09:28:10 <glguy> it's just there to show that aux is f's auxillary function
09:28:20 <ski> hiya esap
09:28:27 <esap> ski: hi
09:29:40 <glguy> esap: and that allows skip to be in scope for aux
09:29:52 <esap> glguy: right ok
09:30:19 <glguy> if there is a cleaner mechanism for expressing this, I'm all ears though
09:30:40 <glguy> I'm just translating some of the Scheme examples from "The Seasoned Schemer" to Haskell
09:30:53 <glguy> to give myself some sense of continuations in Haskell
09:31:58 <lisppaste2> glguy annotated #31261 with "Scheme version" at http://paste.lisp.org/display/31261#1
09:32:08 <esap> apart from style, I can't see anything wrong with your code. The code is pretty hard to understand though.
09:32:53 <glguy> esap: you mean because of the not using do-notation?
09:34:13 <esap> glguy: well the odd direction of =<<, combined with liftM, (x:) and callCC is not very simple
09:34:25 <esap> glguy: hard to determine what's the type of your variables
09:34:36 <lisppaste2> glguy annotated #31261 with "clearer?" at http://paste.lisp.org/display/31261#2
09:35:44 <esap> that's easier to understand
09:36:10 <alexj__> shapr: sup?
09:38:39 <Masklinn> @quote
09:38:39 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
09:39:17 <shapr> alexj__: y0
09:44:28 <lisppaste2> ski annotated #31261 with "using '($)'" at http://paste.lisp.org/display/31261#3
09:45:10 <PaulAJ> Hi
09:45:27 <shapr> hiya PaulAJ! How's code?
09:45:31 <ski> glguy : you can use '($)' like that insteada, to get the local name 'skip'
09:45:48 <PaulAJ> OK.  I did release a new version of Ranged Sets last week.
09:45:54 <esap> ski: what does your use of let mean?
09:46:18 <PaulAJ> And when I can get the effort up I'm working on a re-implementation of that simulation code I showed at Cambridge.
09:46:54 <PaulAJ> Whats the difference between Oleg and a nail salesman?
09:47:20 <ski> arg, s/where//
09:47:51 * edwinb eagerly awaits the punchline...
09:47:53 <PaulAJ> One of them hacks types, the other hypes tacks!
09:48:00 * edwinb claps
09:48:15 <lisppaste2> ski annotated #31261 with "oops, no 'where'" at http://paste.lisp.org/display/31261#4
09:49:02 <glguy>  | otherwise = runKleisli (Kleisli aux >>> arr (x:)) xs
09:49:05 <glguy> too much?
09:49:05 * ski doesn't think using '(=<<)' and '(x:) `liftM` is very odd, but the 'do' variant works too
09:49:08 <PaulAJ> Obsethrylene does sound like some kind of plastic.
09:49:33 <glguy> =D
09:49:56 <esap> ski: Those are what you get when you over-think your code (and optimize for number of characters...)
09:49:59 <PaulAJ> I've always thought it very ironic that point free mode as so many decimal points in it.
09:50:24 <PaulAJ> s/mode/form
09:50:28 <glguy> esap: those are what you get when you think of Monads in terms of them
09:50:36 <ski> esap : or try to get close correspondance with original code ..
09:50:50 <glguy> esap: I ddin't write it first in do-notation, and then try for fewer characters
09:51:16 <ski> (monadic reflection might be nice here, though)
09:51:51 <shapr> Does ghci work on intel mac?
09:51:57 <glguy> and the reason that I didn't include type signatures on the inside was that I couldn't get them to work without violating some rigid variable
09:52:46 <esap> I used to write code by first writing a 'normal' version, then thinking I could optimize it, and wound up with lots of point-free code and all kinds of partially applied functions... It's really nice until after some time when you need to understand it for a second time. Then you need to do all the thinking again....
09:53:15 <ski> glguy : right, the type signature of 'aux' shares a tyvar with 'remberuptolast', so you need to make sure it can refer to that outer tyvar
09:54:08 <glguy> when I see two line do-notation blocks that could have been written with (>>=) or (fmap) or (ap) I find that it slows me down (personally)
09:55:32 <glguy> do { x <- [1..10]; return (x + 1) } -- is harder for me to glance at than: fmap (+ 1) [1..10]
09:55:49 <Nafai> Hey shapr!
09:55:59 <shapr> hiya Nafai
09:56:03 <shapr> Where's the ghc bug tracker?
09:56:09 <esap> glguy: for lists that's true for me as well. But for more general monads, the do notation is better
09:56:18 <glguy> ...for you :)
09:56:24 <shapr> aha, I found it.
09:57:24 <Masklinn>  <shapr> Does ghci work on intel mac?
09:57:29 <Masklinn>  > yeah no problem
09:57:32 <glguy> ski: can you explain why the ($) is needed in your version?
09:57:38 <glguy> I know that it gives an error without
09:57:46 <glguy> but what is GHC trying to do when the $ isn't there?
09:58:05 <Masklinn> shapr > you can install it either via the mac binaries or through DarwinPorts
09:58:13 <Masklinn> the darwinports install takes some time though
09:58:23 <Masklinn> (since it recompiles everything from source)
09:58:32 <shapr> Masklinn: So there aren't any known ways to crash ghci on intel mac?
09:58:40 <Masklinn> I haven't experienced any yet
09:58:51 <Masklinn> I have much less issues on my mac than on my Windows PC
09:58:59 <Masklinn> whose shell often crashes when I try to exit GHCI
09:59:19 <Masklinn> now there may be some ways to crash ghci on Intel Mac, but I haven't seen them
09:59:30 <Masklinn> do you have anything you want me to try?
10:00:03 <ski> glguy : it is needed to pass the lambda as last arg, without needing to wrapping it in parens
10:00:10 <shapr> Not off the top of my head. If I end up with distilled crash code I'll ask you about it.
10:00:15 * ski needs to leave
10:00:23 <shapr> Masklinn: thanks for the info
10:00:27 <SyntaxNinja> y0
10:00:31 <Masklinn> shapr > want my mail@?
10:01:16 <shapr> sure!
10:01:17 <pejo> shapr, having trouble with darwin-x86 and ghc 6.6?
10:01:26 <shapr> pejo: ghci crashes
10:01:33 <shapr> With certain code
10:01:45 <shapr> y0 SyntaxNinja
10:02:28 <pejo> shapr, ouch. I haven't had that problem, but I haven't used it that much.
10:02:32 * Syzygy- tries to download all he needs to work offline with haskell.... Is there decent amount of documentation available for download as well?
10:02:57 <Masklinn> spider the whole haskell.org website via wget?
10:03:53 <Syzygy-> Masklinn: Hmmmm.... Nice idea. May be a bit annoying to wait for though.
10:04:16 <Masklinn> other than that, there are archives of the Report
10:04:26 <pejo> Syz, erm, http://www.haskell.org/ghc/docs/6.6/ has tarballs.
10:04:27 <lambdabot> Title: Index of /ghc/docs/6.6
10:04:28 <jlouis> Syzygy-, the base library documentation
10:04:59 <glguy> this might be considered better than my continuations version:
10:05:01 <glguy> rutl a xs = aux xs xs where  aux [    ] ys = ys aux (x:xs) ys = aux xs (if x == a then xs else ys)
10:05:31 <Syzygy-> pejo: Thanks!!
10:05:36 <shapr> Syzygy-: I can offer several hundred megabytes of my research paper collection.
10:09:18 <Masklinn> @quote
10:09:18 <lambdabot> newsham says: irc bots executing external programs..  always a good idea! what could possibly go wrong?
10:09:52 <lisppaste2> glguy annotated #31261 with "final versions (for own benefit)" at http://paste.lisp.org/display/31261#5
10:14:36 <paolino>  I'm trying to generalize a data so that I can change the monad used to thread the state at implementation level. Now it's implemented via IORefs, but I'd like to change to MVars later, without breaking the data type .Is this possible ?
10:16:05 <esap> paolino: make a type class that provides operations that you need
10:16:48 <digitalice> Probando Radio MVDShuffle.com
10:16:48 <digitalice> http://digitalice.bounceme.net:8000/listen.pls
10:16:48 <digitalice> (Compatible con winamp, xmms, real y ms)
10:17:03 --- mode: ChanServ set +o shapr
10:17:09 <shapr> Man, I hate spam
10:18:07 <shapr> Even worse, that guy appears to be registered with nickserv.
10:18:08 <shapr> sheesh.
10:18:11 --- mode: shapr set -o shapr
10:18:11 <notsmack> I just get depressed that there's a segment of society that makes it profitable
10:19:32 <paolino> esap ,I have done it, but I'm not sure I'm on the right track for that
10:19:32 <paolino> http://rafb.net/paste/results/r7ac9m87.html
10:22:00 <shapr> and the spammer calls me nasty names in privmsg when I tell him not to spam..
10:22:42 <esap> paolino: I've used the following class, which is used with arrows:   class (ArrowChoice arr, ArrowApply arr) => OOArrow arr ref | ref -> arr where { new_ref :: arr a (ref a) ; with_state :: arr a a -> arr (ref a) (ref a) ; deref :: arr (ref a) a }. That's probably not quite the same what you are looking for [since it's for arrows, and not for monads], but should be close.
10:22:49 <jlouis> shapr, who is it?
10:23:57 <chessguy> i forget, what's the easiest way to get all the subsets of a list?
10:23:59 <SyntaxNinja> shapr: I wouldn't worry about hwat a spammer thinks of you :)
10:24:04 <pejo> shapr, heh, telling you about freedom of speech?
10:24:27 <pejo> (But I agree with SN).
10:24:56 <SyntaxNinja> the funny thing about spammers is that there is a subset of them who really think that people want their spam!
10:25:05 <shapr> jlouis: digitalice
10:25:12 <paolino> esap, I'm too young for that :P thanks anyway
10:25:50 <jlouis> Yeah, I really want another ad on how to buy steroids, followed by another ad on how to buy viagra
10:26:23 <eviltwin_b> I ought have another 60 or so messages in INBOX.sieve by now :>
10:26:58 <esap> paolino: I think your class is almost right, probably you'd want a functional dependency from b to m [Because IORef depends on IO]
10:27:27 <esap> paolino: And you have to separate 'debug' to a separate class, because it doesn't depend on b.
10:29:21 <esap> paolino: Though I'm not sure what's the use of generalizing on the type of unsafePerformIO [you don't really want to use it anyway...]
10:35:59 <astrolabe> >msg lambdabot 3
10:36:02 <astrolabe> er
10:36:07 <astrolabe> > msg lambdabot 3
10:36:08 <lambdabot>  Not in scope: `lambdabot'
10:36:26 <astrolabe> long day
10:38:36 <astrolabe> > let {subs [] = [[]];subs (a:as) = subs as ++ map (a:) (subs as)} in subs [1..5]
10:38:38 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
10:39:09 <eviltwin_b> *shrug* you're getting answers already, how important is it?
10:39:11 <eviltwin_b> mix
10:47:40 <chessguy> astrolabe, ltanks
10:47:47 <chessguy> *thanks, even
10:47:52 <lisppaste2> Saizan pasted "getting elements past a substring" at http://paste.lisp.org/display/31268
10:47:53 <chessguy> long day for me too :)
10:48:00 <twanvl> > filterM (const [False,True]) [1..5]
10:48:01 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
10:48:40 <Excedrin> are there implementations of concurrency (in general, not just Haskell) that exploit SMP without using OS threads?
10:48:41 <Saizan> is there a better way to write that function?
10:49:00 <w-ber> Suitable QOTD: "And in computing, the excessive preoccupation with speed is, of course, a little bit vulgar." -- E. Dijkstra
10:49:15 <w-ber> The last sentence of EWD1166, if anyone is interested.
10:49:17 <notsmack> Excedrin: like forking processes?
10:50:06 <Excedrin> notsmack: I suppose so.. is that the only other way to do it?
10:51:02 <esap> Excedrin: You can write your own kernel module to implement your own models of concurrency :-)
10:51:10 <araujo> hello!
10:51:25 <Vq^> araujo: hi there
10:51:36 <araujo> hola Vq^ :-)
10:51:57 <notsmack> protothreads...
10:52:19 <esap> Excedrin: Generally, processes and threads should be enough. There are some implementations of light-weight threads, but most of those do not support SMP.
10:52:39 <notsmack> oh, SMP, nevermind
10:53:21 <esap> Excedrin: And I'm not sure how they could.
10:53:56 <notsmack> Excedrin: trying to avoid OS threads?
10:57:04 <Excedrin> no, just curious if lightweight threads and processes were the only options... how does Erlang do it, one thread per CPU, then lightweight threads on top?
10:58:35 <notsmack> "In the SMP version of the Erlang VM, there can be many such schedulers running in separate OS threads. As default there will be as many schedulers as there are processors or processor cores on the system."
10:59:42 <Excedrin> I guess the advantage of using a thread is writable shared memory
11:00:13 <Masklinn> yeah, erlang has its own processes (not threads because thread implies shared memory and erlang processes don't share memory), and since OTPr11 the platform maps the erlang processes over physical (OS) threads
11:00:57 <Masklinn> before r11, you had to create at least an Erlang node for each core (erlang nodes are OS processes, but you can link several nodes together and Erlang will map its own processes over the nodes)
11:01:34 <chessguy> > unGroup [[1,2],[3,4]
11:01:35 <lambdabot>  Parse error
11:01:38 <chessguy> > unGroup [[1,2],[3,4]]
11:01:39 <lambdabot>  Not in scope: `unGroup'
11:01:42 <Masklinn> So r11 just made SMP simpler (because you only need to start one node per machine instead of one node per core)
11:02:19 <esap> Excedrin: Usually you'd try to avoid memory shared between threads [because then you'd need locking which inhibits parallel execution]
11:02:41 <chessguy> @pl foldr (++) []
11:02:42 <lambdabot> foldr (++) []
11:03:05 <chessguy> is there a shorter way to do this?
11:03:13 <glguy> join
11:03:34 <chessguy> > join [[1,2],[3,4],[5,6]]
11:03:36 <lambdabot>  [1,2,3,4,5,6]
11:03:41 <chessguy> cool
11:04:10 <chessguy> > join [[1,[2]],[3,[4]],[5,[6]]]
11:04:11 <lambdabot>  add an instance declaration for (Num [a])
11:04:12 <lambdabot>   In the list element: 5
11:04:12 <lambdabot>   In...
11:04:36 <chessguy> > join [[[1],[2]],[[3],[4]],[[5],[6]]]
11:04:38 <lambdabot>  [[1],[2],[3],[4],[5],[6]]
11:05:06 <glguy> concat is the list-specific version of join
11:05:20 <glguy> :t join
11:05:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:05:23 <glguy> :t concat
11:05:24 <lambdabot> forall a. [[a]] -> [a]
11:05:36 <glguy> :t mappend
11:05:37 <lambdabot> Not in scope: `mappend'
11:06:41 <glguy> :t msum
11:06:42 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
11:07:20 <glguy> :t Data.Monoid.mconcat
11:07:22 <lambdabot> forall a. (Data.Monoid.Monoid a) => [a] -> a
11:08:13 <glguy> > sequence [concat, join, msum, mconcat] [[1],[2],[3,4]]
11:08:15 <lambdabot>  [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
11:08:33 <Excedrin> esap: it seems like memory sharing would be useful for implementing stuff like MVars and Channels, I'd also think that lack of mutable state might make concurrency with shared memory simpler, but I suppose that things aren't always immutable at the machine level
11:08:35 <earthy> hoedje van, hoedje van.
11:09:21 <Saizan> Excedrin, message passing?
11:09:52 <alexj__> anyone know how to get ghc from darwin ports?
11:09:55 <esap> Excedrin: True. The queues needed in message passing will need some level of sharing, but those are usually invisible to the programmer.
11:12:32 <esap> Excedrin: another thing to note is that allocating memory in a thread usually requires the implementation of the allocation function to take a mutex
11:12:36 <eviltwin_b> alexj__: "port install ghc" but last I checked it was still 6.4.2, no 6.6 in dports yet
11:12:52 <fasta> What is a legal use of downNova (from HCAR)?
11:12:57 <Igloo> 6.6 is in MacPorts, I'm told
11:13:04 <int-e> @users #haskell
11:13:04 <lambdabot> Maximum users seen in #haskell: 276, currently: 265 (96.0%), active: 41 (15.5%)
11:13:45 * glguy has installed 6.6 from MacPorts
11:25:22 <earthy> whee
11:25:28 <earthy> some of the stuff in the hwn is *great*
11:30:14 <glguy> is there a name for this: foldl f g (tails xs)
11:31:00 <glguy> Maybe I'm thinking of CommonLisp and functions like mapl
11:31:43 <earthy> looks a bit like a paramorphism
11:32:46 <glguy> (CL function seems to be maplist)
11:33:00 <glguy> for mapping
11:33:44 <glguy> oh well
11:34:30 <earthy> but what is wrong with just writing foldl f g (tails xs) ? :)
11:34:36 <glguy> not a thing
11:34:45 <glguy> I just wondered if thre alraedy existed something like that
11:34:52 <earthy> ah
11:34:53 <earthy> right
11:35:16 <Saizan> ?type \f g xs -> foldl f g (tails xs)
11:35:17 <lambdabot> forall a a1. (a -> [a1] -> a) -> a -> [a1] -> a
11:35:28 <Saizan> ?hoogle (a -> [a1] -> a) -> a -> [a1] -> a
11:35:29 <lambdabot> Did you mean: (a -> [A1] -> a) -> a -> [A1] -> a
11:35:39 <glguy> i think it woudl prefer b to a1
11:35:44 <Saizan> ?hoogle (a -> [b] -> a) -> a -> [b] -> a
11:35:45 <lambdabot> No matches, try a more general search
11:36:01 <glguy> ?pl \f g xs -> foldl f g (tails xs)
11:36:02 <lambdabot> flip flip tails . ((.) .) . foldl
11:36:17 <glguy> There's definitely no rewrite rule in ?pl for that :)
11:36:40 <earthy> it's almost scanl
11:55:01 * SamB wonders what being pre-approved for a credit card (when you have never had one) has to do with financial success...
11:55:39 <lisppaste2> metaperl pasted "I want to group contiguous elements into a list" at http://paste.lisp.org/display/31276
11:57:18 <glguy> > groupBy (\x y -> y - x == 1) [3,5,6,7,9,10]
11:57:19 <lambdabot>  [[3],[5,6],[7],[9,10]]
11:57:28 <glguy> ahh
11:57:39 <glguy> yeah, groupBy keeps comparing to the first element in the group
11:58:06 <SamB> @doc Data.List
11:58:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
12:00:16 <SamB> glguy: the documentation should make it clear that groupBy takes an equivalence predicate
12:00:47 <glguy> this is metaperl's question
12:01:16 <metaperl> yeah  , I think he is commenting on your attempted solution
12:01:25 <glguy> that was *your* attempted solution
12:01:25 <jlouis> it must have a simple foldl form
12:01:33 <metaperl> oh yeah
12:02:11 <jlouis> ah, not so simple
12:06:20 <emu> > length [1..] > 5
12:06:24 <lambdabot> Terminated
12:07:35 <kpreid> @let breakBy f (x:y:s) | f x y = [x]:breakBy f (y:s) | otherwise = let xs:yss = breakBy f (y:s) in (x:xs):yss; breakBy _ xs = [xs]
12:07:36 <lambdabot> Defined.
12:07:36 <dmead> i like your comment on that silly article glguy
12:07:43 <glguy> = D
12:07:45 <kpreid> > L.breakBy (\x y -> x /= y - 1) [3,5,6,7,9,10]
12:07:46 <dmead> =ppp
12:07:46 <lambdabot>  [[3],[5,6,7],[9,10]]
12:07:56 <metaperl> kpreid - impressive
12:08:21 <kpreid> it could use some better variable names and avoiding splitting up the answer of the recursive call
12:08:31 <jlouis> kpreid, that is a nice one
12:14:17 <lisppaste2> glguy pasted "My less graceful than kpreid's attempt =D" at http://paste.lisp.org/display/31280
12:17:25 <metaperl> time to learn unfoldr
12:19:59 <fasta> http://hackage.haskell.org/ModHackage/Hackage.hs?action=home <- is broken
12:22:19 <lisppaste2> jlouis annotated #31280 with "My even worse attempt" at http://paste.lisp.org/display/31280#1
12:22:56 <jlouis> far too many special cases
12:22:59 <metaperl> thanks for the contrib jlouis :)
12:23:09 <metaperl> maybe you an tutor me in unfoldr
12:23:19 <metaperl> google is not being friendly
12:23:31 <jlouis> unfoldr you say?
12:23:36 <metaperl> aye
12:23:53 <int-e> > unfoldr (\x -> guard (x>=0) >> return (x, x-1)) 10
12:23:54 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
12:24:13 <metaperl> ummm. I am _not_ to monads yet :)
12:24:16 <int-e> unfoldr is best used with monads to confuse newbies ;)
12:24:23 <jlouis> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Aunfoldr
12:24:25 <lambdabot> http://tinyurl.com/yhrw65
12:24:41 <glguy> > unfoldr (liftM2(>>)(guard.not.null)(return.splitAt 2)) [1..10]
12:24:43 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
12:24:50 <metaperl> oh, oh thanks. i get it :)
12:25:10 <int-e> > unfoldr (liftM2 (>>) (guard . (>= 0)) (return . (id &&& (-1+))) 10
12:25:10 <lambdabot>  Parse error
12:25:33 <int-e> > unfoldr (liftM2 (>>) (guard . (>= 0)) (return . (id &&& (-1+)))) 10
12:25:33 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
12:25:43 <glguy> (id &&& f) -> ap (,) f
12:25:52 <metaperl> how why isn't shapr's blog entry complete: http://www.scannedinavian.com/~shae/blog/2004-10-25.html
12:25:54 <lambdabot> Title: Mon, 25 Oct 2004 00:00:00 UT
12:25:56 <int-e> there, unfoldr, an arrowand two different monads ;)
12:26:04 * glguy checks
12:26:08 <int-e> glguy: I already had that monad ;)
12:26:12 <glguy> oh
12:26:14 <glguy> ok
12:26:17 <glguy> fair enough ;)
12:26:23 <int-e> glguy: but yes, that seems correct
12:26:35 <glguy> so you wanted "Maybe" "((->)r)" and "Arrow"?
12:26:42 <int-e> yes!
12:26:42 <paolino> how I change Data.Set.map to operate on (a ->m b) functions ?
12:26:48 <int-e> Arrow (->)
12:26:58 <opqdonut> paolino: liftM?
12:27:26 <opqdonut> paolino: or there even might be a mapM for set
12:27:30 <opqdonut> ?hoogle mapM
12:27:30 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
12:27:33 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
12:27:35 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:27:52 <paolino> @type (liftM Data.Set.map)
12:27:54 <lambdabot> forall a b (m :: * -> *). (Monad m, Ord b, Ord a) => m (a -> b) -> m (Data.Set.Set a -> Data.Set.Set b)
12:27:58 <glguy> metaperl: unfoldr calls a function on a value, if that function returns Just (nextListElement, nextIterationValue)
12:28:11 <glguy> then unfoldr adds that nextListElement to the list that it is building and continues
12:28:13 <paolino> looks wrong
12:28:18 <glguy> to call the function on the nextIterationVlaue
12:28:31 <mbishop> What are the reasons to declare types for a variable or function? simply to help out in terms of efficiency...or to make it clear to the reader what it takes...or?
12:28:31 <glguy> metaperl: if that function returns: Nothing, then unfoldr stops building the ilst
12:28:49 <opqdonut> paolino: what do you want to do?
12:28:57 <opqdonut> ?type Data.Set.map
12:28:58 <lambdabot> forall b a. (Ord b, Ord a) => (a -> b) -> Data.Set.Set a -> Data.Set.Set b
12:29:02 <int-e> mbishop: get better error messages and document the function better
12:29:08 <jlouis> metaperl, unfoldr produces elements to the list as long as Just (element, nextval) is returned. It loops itself with nextval, beginning from startval.
12:29:19 <glguy> some code's type is undecidable w/o explicit type signatures
12:29:20 <paolino> operate on (a-> m b) function
12:29:26 <metaperl> hmm
12:29:40 <opqdonut> paolino: you can do that, but then you'll have a set of m b values
12:29:44 <int-e> mbishop: (the thing about the error messages is that if you make a mistake, you usually get a type error somewhere, but often not where you made it. type signatures help a lot here)
12:30:02 <Saizan> i think it wants a: m Set b
12:30:15 <paolino> @type mapM
12:30:17 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:30:20 <Saizan> s/it/he/
12:30:30 <metaperl> here's a good simple example of unfoldr - http://sequence.complete.org/node/94
12:30:31 <lambdabot> Title: dealing out 5 hands of cards, each containing 5 cards | The Haskell Sequence
12:30:36 <int-e> mbishop: a third reason is to get around the monomorphism restriction
12:30:39 <opqdonut> paolino: sequence will help you to get [m b] -> m [b]
12:30:57 <opqdonut> paolino: you can probably use that with setToList (or whatever its called)
12:31:01 <mbishop> int-e: the wha?
12:31:02 <paolino> that but I work on sets
12:31:05 <paolino> uh
12:32:16 <int-e> mbishop: it forces a toplevel constants like   a = 4  to be monomorphic, i.e. the type of  a  here will be some Num instance (Int, most likely) but not  Num a => a
12:32:49 <paolino> opqdonut: that is not acceptable for efficence , I suppose
12:33:13 <jlouis> ?paste
12:33:13 <lambdabot> http://paste.lisp.org/new/haskell
12:33:31 <opqdonut> paolino: what exactly are you trying to do
12:33:39 <opqdonut> paolino: what monad, what sort of set etc
12:34:25 <paolino> IO
12:34:42 <opqdonut> paolino: so you are outputting the set or what?
12:34:48 <paolino> no
12:34:54 <paolino> using IORef
12:35:00 <paolino> for states
12:35:25 <opqdonut> and using a non-monadic pure type won't do?
12:36:04 <paolino> my closures on states are all of type (a -> m b)
12:36:45 <opqdonut> paolino: the to list and from list are O(n), so is map
12:36:55 <opqdonut> so there shouldn't be aproblem with efficiency
12:38:39 <int-e> mbishop: and of course type signatures help when the compiler makes a function polymorphic but you want it to have a more specific type (and in that case, they can help performance)
12:39:14 <jlouis> @source unfoldr
12:39:14 <lambdabot> unfoldr not available
12:39:19 <jlouis> @source Data.List
12:39:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:40:54 <paolino> @type sequence
12:40:56 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:42:11 <opqdonut> ?djinn (a -> a) -> a
12:42:12 <lambdabot> -- f cannot be realized.
12:42:30 <opqdonut> ?djinn (a -> a) -> (a -> b) -> a -> b
12:42:31 <lambdabot> f _ a b = a b
12:42:33 <glguy> ?type fix
12:42:34 <lambdabot> forall a. (a -> a) -> a
12:42:40 <opqdonut> glguy: yeah i know
12:43:07 <opqdonut> ?djinn (a -> a) -> (a -> b)
12:43:07 <lambdabot> -- f cannot be realized.
12:43:27 <opqdonut> ?type (return .)
12:43:29 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b) -> a -> m b
12:52:24 <glguy> could someone explain where (`runCont` id) is necessary to run a continuation (specifically the id part)
12:53:30 <Cale> @type (`runCont` id)
12:53:32 <lambdabot> Not in scope: `runCont'
12:53:41 <int-e> Cont a a -> a
12:53:44 <Cale> @type (`Control.Monad.Cont.runCont` id)
12:53:46 <lambdabot> forall a. Control.Monad.Cont.Cont a a -> a
12:54:17 <glguy> right, but why does runCont take a function that it will then apply to the result?
12:54:27 <glguy> when you could just do that yourself?
12:54:47 <Cale> because it's the field selector for the Cont newtype
12:55:13 <glguy> so there isn't an evalState for Cont?
12:55:26 <glguy> to compliment runState?
12:55:44 <glguy> or rather t ocompliment runCont
12:57:03 <glguy> I just wondered if there was some reason for that behavior like it was trying to preserve the spirit of continuations or something
12:57:50 <Cale> well, sort of -- you run a computation in the Cont monad byy passing it a continuation
12:57:53 <Cale> by*
12:58:05 <glguy> and when you are done that continuation is just id?
12:58:09 <Cale> yeah
12:58:59 <glguy> what is withCont and mapCont for?
12:59:06 <glguy> are*
12:59:31 <glguy> I'm looking at the definitions now
12:59:41 <glguy> but I'm trying to figure out when you might use them
12:59:42 <mwc> continuations work like a chain
13:00:02 <mwc> (a -> r) -> r. The monad has the value a. You pass it a functoin that turns it into the r value.
13:00:03 <Cale> Well, you can think of a value of type (Cont r a) as a sort of black box which you can ask questions with answers of type r about values of type a
13:00:23 <Cale> For example, consider r = Bool
13:00:24 <mwc> Cale as usually is a better teacher than I
13:00:51 <Cale> then it's (a -> Bool) -> Bool -- it takes a yes or no question about a value of type a and answers it.
13:02:03 <glguy> ok
13:02:21 <Cale> mapCont :: (r -> r) -> Cont r a -> Cont r a can really only do one sensible thing, and that's to censor the answer you get back, modifying it in some way.
13:02:57 <Cale> withCont :: ((b -> r) -> (a -> r)) -> Cont r a -> Cont r b
13:03:09 <int-e> mapCont (const "[[[REDACTED]]]")
13:03:21 <Cale> you pass it a function which translates questions about values of type b into questions about values of type a
13:03:46 <Cale> and it wraps the (Cont r a) up with that in order to get a box which you can ask questions of type b
13:04:15 <glguy> alright, makes sense enough
13:04:24 <int-e> runCont (mapCont (const "[[[REDACTED]]]") (return 2)) show ==> "[[[REDACTED]]]"
13:04:51 <int-e> (it returns "2" without the mapCont)
13:05:53 <cjeris> int-e: but the 'answers' 2 and "[[[REDACTED]]]" don't have the same type?
13:05:56 <glguy> so mapCont returns a new Cont whose answers will have a function applied to them before they are returned
13:06:01 <Cale> right
13:06:04 <int-e> cjeris: both are strings
13:06:09 <glguy> but fmap
13:06:37 <int-e> cjeris: note the "", also note that  show  returns a String.
13:06:41 <Cale> fmap is different
13:06:45 <glguy> modifies the value that questions are asked about?
13:06:58 <Cale> well, sort of :)
13:07:21 <int-e> runCont (fmap (+1) (return 2)) show ==> "3"
13:07:49 <Cale> in that sense right there, it does
13:09:16 <int-e> @djinn (a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
13:09:17 <lambdabot> Cannot parse command
13:09:37 <glguy> missing one '('
13:09:56 <ski> evalCont :: Cont r r -> r
13:09:59 <Cale> @djinn (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
13:10:00 <lambdabot> f a b c = b (\ d -> c (a d))
13:10:00 <int-e> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
13:10:01 <lambdabot> f a b = a (\ c _ -> b c) b
13:10:08 <ski> evalCont = (`runCont` id)
13:10:28 <glguy> yeah, that's what I have been using
13:10:30 <glguy> evalCont = flip runCont id
13:10:31 <ski> wouldn't that be nice to have in Control.Monad.Cont ?
13:10:39 <Cale> yeah, it would
13:10:53 <Cale> also, evalContT = (`runContT` return)
13:11:02 <ski> yes
13:11:45 <Cale> I suspect there's a good reason that the Cont monad is hard to use -- in particular, almost nobody really uses it.
13:12:13 * ski used it in a laboration recently
13:12:26 <glguy> I'm trying to use it to write the Scheme examples in The Seasoned Schemer as I read through
13:12:38 <ski> (for controlling cooperative threads)
13:13:08 <glguy> seeing them in Haskell makes them look less magical than seeing them in Scheme
13:13:23 <ski> Cale : well, control effects are somewhat harder to grasp than e.g. state or nondeterminism
13:14:10 <Cale> glguy: that's because, at least with Cont, you have no side effects
13:14:25 <ski> so, i think it's partly because of less familiarity, and not knowing when it could be applied to good effect
13:14:40 <ski> Cale : huh ?
13:14:44 <int-e> callCC is an awful interface :)
13:15:20 <ski> int-e : would you prefer 'shift' and 'reset' ? or some other ?
13:15:30 <Cale> Most of the real confusion about continuations is in how they interact with sideeffects
13:15:41 <fasta> I find call/cc in Scheme more "natural" now than callCC in Haskell.
13:15:56 <glguy> could ContT around IO be a closer approximation of Scheme?
13:16:00 <Cale> yeah
13:16:24 <Cale> Something like ContT Void IO
13:16:28 <ski> there should be a "monad transformer cookbook" that explains common combinations of monad transformers, in various stack orders .. and states what each particular combination gives you
13:17:03 <Cale> (well, that's somewhat unmanageable, so you probably want ContT () IO)
13:17:32 <ski> forall o. ContT () IO a
13:17:33 <ski> maybe ?
13:17:36 <ski> er
13:17:40 <ski> forall o. ContT o IO a
13:17:51 <cjeris> ski: also a monad transformer taxonomy, classifying them into monad autobots and monad decepticons
13:18:00 <ski> hehe
13:18:50 <ski> (hm, this reminds me .. i might have stumbled on a new primitive monad transformer :)
13:19:46 <lrrr> hi there
13:20:00 <lrrr> can anybody help me with arrays?
13:20:39 <Cale> sure
13:20:49 <lrrr> i wonder how to convert a MArray to DiffArray?
13:21:06 <Excedrin> is there another term for partial application?
13:21:32 <jlouis> insn't all MArrays DiffArrays ?
13:22:05 <Cale> jlouis: hm?
13:22:12 <lrrr> hmm.. are they?
13:22:18 <Cale> no
13:22:37 <Cale> DiffArrays aren't even in the MArray class
13:23:07 <jlouis> nope
13:23:11 <jlouis> I am wrong
13:23:13 <Cale> I think the best you're going to be able to do is just construct an entirely new array
13:23:22 <jlouis> ?type newDiffArray
13:23:23 <lambdabot> Not in scope: `newDiffArray'
13:23:25 <int-e> ski: I don't know. Expressing continuations sequentially seems artificial.
13:23:37 <jlouis> ?type Data.Array.Diff.newDiffArray
13:23:38 <lambdabot> forall e i (a :: * -> * -> *). (Ix i, Data.Array.Base.MArray a e IO) => (i, i) -> [(Int, e)] -> IO (Data.Array.Diff.IOToDiffArray a i e)
13:23:40 <Cale> use getBounds and getAssocs on the MArray
13:23:47 <ski> int-e : how do you mean ?
13:23:47 <Cale> no, don't use newDiffArray
13:24:06 <Cale> er
13:24:10 <int-e> ski: I probably wouldn't want it to be a monad at all.
13:24:19 <Cale> hmm, actually might be possible
13:24:24 <ski> int-e : but it is a monad
13:24:30 <lrrr> actually i don't need MArrays, i need an efficient way to construct a new big DiffArray intialized to zeros
13:24:32 <jlouis> newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
13:24:34 <jlouis> is probably better
13:24:41 <int-e> ski: shift + reset seem just as bad as call/cc. *g*
13:24:53 <ski> int-e : thay are higher-level
13:25:07 <lrrr> MArrays have newArray function that does it
13:25:10 <Cale> lrrr: DiffArrays implement the IArray interface
13:25:24 <Cale> so you can just do
13:25:36 <Cale> listArray (min,max) [0,0..]
13:26:15 <Cale> @type \min max -> listArray (min,max) [0,0..]
13:26:17 <lambdabot> forall i e. (Ix i, Num e, Enum e) => i -> i -> Array i e
13:26:23 <ski> int-e : compare the two implementations of 'for-each->stream-maker' at http://community.schemewiki.org/?composable-continuations-tutorial
13:26:26 <Cale> hmm, not quite the type I wanted
13:26:29 <lrrr> hmm i worry about efficiency
13:26:30 <lambdabot> http://tinyurl.com/yy2eux
13:26:42 <Cale> Why would efficiency be a problem there?
13:26:44 <ski> int-e : which one would you prefer ?
13:27:03 <Cale> Generating the elements of [0,0..] is not slow :)
13:27:18 <Cale> (nor does it consume very much memory)
13:27:27 <lrrr> oh yeah, laziness magic :)
13:27:31 <ski> repeat 0
13:27:35 <Cale> right
13:28:17 <Cale> repeat 0 is actually probably considerably more efficient, they're all the same 0 that way
13:28:17 <lrrr> ok thanks :)
13:28:24 <ski> int-e : btw, i'm not sure how one would expression continuations non-sequentially (but it may be possible ..)
13:28:37 <Cale> Though it does bring up a good point
13:28:52 <ski> and it's the same cons scell
13:29:17 <metaperl> glguy - you used an arrow in your solution??
13:29:24 <glguy> huh?
13:29:25 <Cale> There should be a function  (IArray a e, Ix i) => (i -> e) -> (i,i) -> a i e
13:29:36 <lrrr> actually the reason why i asked about DiffArrays is the phrase in documentation for diff arrays "An arbitrary MArray type living in the IO monad can be converted to a diff array."
13:29:48 <Cale> (of course it's easy to write one, but there ought to be one in the library)
13:30:10 <Cale> Yeah, there's that IOToDiffArray type
13:30:43 <metaperl> could someone help me understand first
13:30:52 <lrrr> and how to use it? i tried several ways but i stuck with all those type constructors..
13:30:54 <Cale> but you only really use that if you're concerned with the details of the low-level interface -- you'd have to write your own IArray instances if you want anything that's not already implemented
13:31:09 <Cale> metaperl: first?
13:31:14 <Cale> @type first
13:31:16 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
13:31:17 <glguy> OH
13:31:32 <metaperl> glguy - you're a sneaky devil :)
13:31:45 <Cale> (b ~> c) -> ((b, d) ~> (c, d))
13:31:48 <glguy> metaperl: you can replace that code with: let (a,b) = aux y ys in (x:a,b)
13:31:52 <Cale> might be a clearer way to write it
13:32:14 <Cale> Where in the trivial case, ~> = ->
13:32:15 <metaperl> ~> is beyond me as well
13:32:23 <chr1s> hey everyone!
13:32:29 <Cale> well, I'm using ~> as an infix type variable
13:32:33 <glguy> ~> is less straight-forward than -> ;)
13:32:50 <glguy> pun intended!
13:32:58 <Cale> Arrows are like generalisations of ->
13:33:15 <chr1s> I was thinking of the IO Monad
13:33:20 <kpreid> metaperl: for purposes of distinguishing variables from constructors, ~> is "lowercase"
13:33:27 <ski> chr1s : yes ?
13:33:30 <chr1s> So, suppose I have a main :: IO String
13:33:30 <metaperl> "Send the first component of the input through the argument arrow, and copy the rest unchanged to the output." --- that's what the ghc docs say
13:33:42 <metaperl> but I dont get it
13:33:48 <chr1s> I'm doing some fancy IO stuff there, like reading a file
13:34:19 <metaperl> there's no d in the input to first, yet there is in the type signature
13:34:29 <metaperl> oh, there is above
13:34:31 <Cale> metaperl: well, consider how you'd write a function of type (b -> c) -> (b,d) -> (c,d)
13:34:51 <ski> @djinn (b -> c) -> (b,d) -> (c,d)
13:34:52 <lambdabot> f a (b, c) = (a b, c)
13:34:52 <metaperl> ok
13:35:09 <metaperl> I would do fst
13:35:19 <metaperl> on the 2nd argument
13:35:24 <metaperl> oh wait
13:35:27 <chr1s> oh nevermind, I was just thinking wrongly
13:35:28 <metaperl> oh yes
13:35:40 <Cale> chr1s: er, okay :)
13:35:41 <ski> chr1s : ok
13:36:04 <chr1s> It's still a bit fuzzy, but I think I finally get Monads
13:36:39 <lisppaste2> metaperl annotated #31280 with "here's how I'd write it" at http://paste.lisp.org/display/31280#2
13:36:43 <chr1s> They're quite nice!
13:36:50 <Cale> haha, the top item for me under 'new' on programming reddit now is #22
13:37:01 <Cale> and after that #34
13:37:08 <PaulAJ> Have you tried stacking monad transformers yet?
13:37:11 <glguy> Cale: does that mean you've been downvoting a lot of stuff?
13:37:17 <Cale> glguy: precisely
13:37:23 <PaulAJ> Only then can you write your Monad Tutorial.
13:37:40 <Cale> I've been downvoting almost everything.
13:37:40 <glguy> Cale: did you down-vote "Currying for heathens"?
13:37:48 <metaperl> Oh wise Cale, I seek thine assistance in understanding first. Here is my solution to your proposed function: http://paste.lisp.org/display/31280#2
13:37:57 <Cale> glguy: I haven't seen it there
13:38:12 <Cale> metaperl: why not pattern match?
13:38:17 <chr1s> PaulAJ: what's that?
13:38:23 <glguy> Cale: that title is my commentary on the article ;)
13:38:28 <metaperl> oh I get it!
13:38:39 <Cale> (but that is right)
13:38:40 <chr1s> I,m not intending on writing a tutorial (yet)
13:39:06 <metaperl> That actually is very simple... I dont know why they call that arrows. I was intimidated
13:39:20 <PaulAJ> It's become a sort of rite of passage for Haskellers.  Grok monads, and then write a tutorial to help the rest of the world grok them.
13:39:28 <metaperl> Cale - my answer is correct though, right?
13:39:32 <Cale> metaperl: well, your implementation is just for the trivial arrow
13:39:40 <glguy> I thought that writing a compiler was the Haskell "rite of passage"
13:39:42 <metaperl> but it is first right?
13:39:45 <Cale> yeah
13:39:54 <Cale> for the Arrow (->)
13:39:59 <glguy> lol
13:40:12 <newsham> i'm starting to think that monad tutorials are silly.  my current thinking is that someone should write one tutorial on how to use IO, another tutorial on how ot use Reader and State,  another tutorial on how to use Maybe and List.
13:40:17 <PaulAJ> glguy: thats the second rite of passage.  Then you are a Black Belt Haskeller
13:40:27 <chr1s> well, for me it was Parser Combinators
13:40:40 <newsham> after those the reader should be able to generalize themselves
13:40:42 <Cale> glguy: do you mean currying (in Ruby) from 13 days ago?
13:40:51 <emu> fold monadTutorial wadler restOfWorld
13:40:58 <newsham> also i think they should start of teaching them how to use do notation.
13:41:01 <newsham> the can figure out bind later.
13:41:05 <glguy> Cale: no... http://programming.reddit.com/info/to4g/comments
13:41:06 <Cale> I don't think I saw that one, I hadn't modded it either way
13:41:07 <lambdabot> Title: Typing like a Functional Programmer (reddit.com)
13:41:21 <newsham> using IO with "do" is really easy.  all these tutorials convince people otherwise
13:41:27 <Cale> glguy: ah, that one is modded up :)
13:41:34 <chr1s> newsham: I don't agree, the do notation was really confusing me
13:41:57 <PaulAJ> Tutorials should start with "do", but its only when you understand the syntactic transform that you grok what is happening.
13:41:58 <newsham> if the truth can be explained so as to be understood, it will be believed
13:42:04 <chr1s> because it just looks like as if you can perform a list of commands
13:42:29 <newsham> paulaj: my thesis is that you dont need to understand what is happening.  people dont need to understand monads to program IO, state, maybe, lists.
13:42:31 <PaulAJ> I kept on trying to write "lines $ readFile "stuff.txt" and similar things.
13:42:34 <metaperl> @type first
13:42:35 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
13:42:44 <Cale> If you start with 'do', and try to pretend it's just like imperative programming, people get confused about why return in the middle of a block of code does nothing
13:42:46 <chr1s> what worked for me was http://www.nomaware.com/monads/html/index.html
13:42:47 <lambdabot> Title: All About Monads
13:42:50 <newsham> and once you know all those things, explaining monads is really easy
13:42:58 <PaulAJ> newsham: I disagree.
13:43:08 <newsham> cale: thats because of the choice of name "return".
13:43:10 <PaulAJ> chr1s: that is what also did it for me.
13:43:12 <emu> yea, return is poorly named
13:43:20 <Cale> It's not poorly named
13:43:28 <glguy> nruter = return -- use that
13:43:29 <chr1s> well, to be honest, it didn't do it for me the first time
13:43:29 <Cale> It's just that you need to understand what's going on
13:43:42 <emu> it's poorly named because it's conflated with notions of control flow
13:43:50 <chr1s> but it took me a couple of times of trying before I finally understood monads
13:43:56 <newsham> i'm convinced I could teach a friend how to program haskell much faster without explaining to them anything about monads.
13:44:02 <Cale> well, yeah, you have to be aware that it's not doing any control
13:44:11 <PaulAJ> Agreed.  Something like "wrap" would have seemed more intuitive.  I groked that it wasn't control flow, but my eyes took some convincing.
13:44:18 <metaperl> So all first does is apply a function to the first argument of a tuple and make that result the first element of the output tuple. Then the second element of the tuple goes thru untouched.
13:44:18 <emu> "return" will always mean control-flow to a programmer
13:44:21 <Cale> But it (return x) certainly does give you the action which returns x
13:44:21 <dylan> implementing monads in languages where return is a reserved word helped me understand monads, as it's called 'wrap'
13:44:30 <jlouis> I like to think of return as "inject"
13:45:06 <Cale> I like to think of it as eta
13:45:10 <dylan> it doesn't help that return is frequently the last action in a monadic thingy
13:45:11 <Cale> hehe
13:45:18 <jlouis> Cale, from eta-conversion?
13:45:27 <chr1s> wrap would actually be a lot better
13:45:31 <Cale> no, from : 1 -> T
13:45:35 <PaulAJ> Anyone know *why* it was called "return"?
13:45:41 <glguy> it would seem that there usually isn't a good reason to include return in the middle of a do-block
13:45:45 <emu> it "returns" to the monad
13:45:48 <ski> (from 'eta' natural transformation .. and from 'eta' the unit in an adjunction)
13:45:50 <jlouis> Cale, thats cat-theory, right?
13:45:57 <Cale> Which is the notation for the natural transformation in the mathematical definition of monad
13:46:03 <glguy> it creates an action, that when performed, returns the specified value
13:46:04 <chr1s> but the do-notation should only be explained after you really get monads
13:46:06 <Cale> (well, that one of them)
13:46:19 <newsham> maybe some day I'll write a non-monad tutorial
13:46:24 <Cale> chr1s: What do you think of my "Introduction to IO"?
13:46:31 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
13:46:33 <lambdabot> Title: Introduction to IO - HaskellWiki
13:46:42 <Cale> http://haskell.org/haskellwiki/Monads_as_containers
13:46:44 <lambdabot> Title: Monads as containers - HaskellWiki
13:46:54 <Cale> Those are my monad articles :)
13:47:28 <chr1s> cool :), I'm reading them now
13:47:30 <Cale> Introduction to IO, I just wrote in order to explain to people who don't completely understand monads yet how IO is actually done in Haskell.
13:47:41 <Cale> (Without too much lying)
13:48:17 <jlouis> hehe
13:48:35 <newsham> "when using IO, each action in the do statement happens in turn with the results from the earlier actions.  to use "normal" values use a "let", to use a value from an action, use "<-""
13:48:45 <PaulAJ> I think that the do notation has to be taught in parallel with bind.  Without "do" it looks too strange and is hard to read, but without bind you can't understand what is going on.
13:49:00 <chr1s> The Introduction to IO is really good
13:49:00 <newsham> "when using list, each action in the do statement happens for each of the values from earlier statements..."
13:49:11 <newsham> the rules arent that complex.
13:49:22 <chr1s> but I'm really wondering if it's possible to understand it the first time
13:49:53 <chr1s> and that's not so much your tutorial, but more the complexity of Monads
13:50:11 <Cale> monads aren't really all that complex, they're just abstract
13:50:18 <PaulAJ> Monads are not complex, just strange.  It takes a while to get your head around them.
13:50:24 <chr1s> agreed.
13:50:25 <dylan> it's easy to understand monads if you implement them.
13:50:34 <PsySine> how is haskell compared to scheme? is there a reason to look at both?
13:50:38 <newsham> yah.. and everyone tries to get peole to understand the abstractions before they have a good grasp of the concrete instances
13:50:45 <PaulAJ> chr1s: ever done any Prolog?
13:50:54 <chr1s> PaulAJ: yes, actually
13:51:04 <chr1s> I even built an adventure game in it.... ;)
13:51:18 <chr1s> text-based, that is
13:51:26 <newsham> you can write lots of useful programs before you get to the point where you are ready to understand monads.
13:51:32 <PaulAJ> Ahh.  Then think of this: every language except Haskell has a single monad built into its architecture.
13:51:32 <dylan> PsySine: scheme is dynamically typed with strict evaluation. Haskell is statically typed with lazy evaluation.
13:51:50 <newsham> but there arent many docs that teach people how to program without discussing the monads.
13:51:52 <PaulAJ> Most languages have IO built in.  But Prolog has a backtracking monad built in.
13:51:57 <Cale> Yeah, when I was teaching my friend Haskell, because she didn't want me to just sit there and describe it to her, I basically broke most of the language down into digestible exercises, and got her to implement the Maybe, List, and Reader monads from the types.
13:52:35 <chr1s> yes
13:52:38 <vegai> PsySine: scheme has a rather clever and minimal syntax
13:52:45 <Nafai> Cale: Cool.  I'd like something like that to learn :)
13:52:47 <vegai> PsySine: haskell has a rather clever ... syntax
13:52:48 <newsham> what syntax? ;-)
13:52:56 <PaulAJ> Haskell doesn't have a single monad built into its foundations.  Instead you get to choose.  If you want backtracking, you can have it.
13:52:56 <newsham> scheme has syntax? ;-)
13:53:01 <vegai> newsham: indeed
13:53:08 <Cale> PaulAJ: well, it does have IO ;)
13:53:10 <PsySine> vegai: :)
13:53:34 <shankys> Does anyone here have experience debugging CGI in Haskell?
13:53:39 <SimonRC> @quote SimonRC
13:53:41 <lambdabot>   if performance was that important, people would be using perl, python, or the JVM
13:53:43 <SimonRC> @quote SimonRC
13:53:44 <PaulAJ> Yes, IO is built in in the same way that arrays and integers are built in: in theory they are just library constructs, but in practice the compiler has to know about them
13:53:49 <lambdabot>   if performance was that important, people would be using perl, python, or the JVM
13:53:49 <PsySine> does haskell have mutable data?
13:53:59 <SimonRC> When the heck did I say *that*?
13:54:01 <PaulAJ> PsySine: yes, if you want it.
13:54:04 <Masklinn> hello again
13:54:06 <newsham> simon: s/would/wouldnt/?
13:54:15 <SimonRC> newsham: indeed
13:54:23 <PaulAJ> @hoogle IORef
13:54:23 <lambdabot> Data.IORef :: module
13:54:23 <lambdabot> Data.IORef.IORef :: data IORef a
13:54:23 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:54:24 <SimonRC> PsySine: You almost certainly don't need it.
13:54:31 <PaulAJ> @hoogle STRef
13:54:32 <lambdabot> Data.STRef :: module
13:54:32 <lambdabot> Data.STRef.STRef :: data STRef s a
13:54:32 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
13:54:34 <SimonRC> PaulAJ: nonono
13:54:42 <SimonRC> PaulAJ: yesyesyes
13:54:43 <metaperl> vegai - do I know you from EFNet #perlhelp?
13:54:49 <metaperl> or is it #scheme
13:54:53 <Cale> Well, you really can't implement the IO monad yourself because you need access to lower-level stuff. (unless the compiler hands you some other way to do IO)
13:55:13 <vegai> metaperl: no.
13:55:15 <Cale> You might be able to write an explicit IO-simulator
13:55:32 <vegai> metaperl: Unless I have a secret life I don't know about
13:55:33 <SimonRC> @help quote
13:55:34 <lambdabot> quote <nick>
13:55:34 <lambdabot> remember <nick> <quote>
13:55:34 <lambdabot> Quote somebody, a random person, or save a memorable quote
13:55:34 <newsham> cale: you can write an IO interpretter
13:55:59 <SimonRC> It would be nice if there was a way to forget a quote.
13:55:59 <Cale> You could simulate a console and filesystem, etc.
13:56:12 <SimonRC> especially when it is backwards
13:56:16 <chr1s> So, what other things should I read about to become a better haskeller?
13:56:32 <SimonRC> chr1s: arrows
13:56:36 <Cale> hmm
13:56:44 <PaulAJ> I was wondering about saying that, but I wouldn't just yet.
13:56:54 <shankys> I'm writing a web application using Haskell's Network.CGI library and am wondering if there's an easy way to debug things in the interpreter? Could someone with experience using Haskell's CGI library possibly point me in the right direction?
13:56:55 <SimonRC> assuming you have written a monad, or at least used monad transformers
13:56:55 <chr1s> I'm doing a course on grammars and parsing, that's something I find very interesting
13:56:56 <metaperl> vegai - :)
13:57:10 <Cale> chr1s: I take it you've seen Parsec?
13:57:15 <chr1s> SimonRC: I have used them, not yet written one
13:57:15 <PaulAJ> I'd recommend understanding the ST monad, and then writing something involving multiple monads.
13:57:21 <SimonRC> chr1s: there is an arrow-based parsing librayr
13:57:31 <metaperl> shankys - if you used Bjorn Bringer's NewCGI, he could help you
13:57:32 <SimonRC> chr1s: or...
13:57:39 <chr1s> Cale: I was about to read the documentation on Parsec
13:57:57 <shankys> metaperl: how is NewCGI different than the one in the standard library?
13:58:00 <Cale> cool, I recommend that. I also recommend my tutorials on monads :)
13:58:09 <metaperl> shankys - I really dont know
13:58:16 <jlouis> ?pt \o msg -> atomically $ writeTChan o msg
13:58:16 <lambdabot> Maybe you meant: ft pl
13:58:18 <PaulAJ> I had fun with a Parsec parser that returned structures that contained IO actions which got executed later in the program.
13:58:18 <Lemmih> shankys: Are you using ghc-6.6?
13:58:20 <SimonRC> chr1s: You could make a simple interpreter.  That would give you an excuse to learn about using monad transformers and maybe writing a monad of your own.
13:58:26 <jlouis> ?pl \o msg -> atomically $ writeTChan o msg
13:58:26 <shankys> lemmih: yes
13:58:26 <lambdabot> (atomically .) . writeTChan
13:58:50 <Lemmih> shankys: Then you're already using NewCGI.
13:58:57 <Cale> PaulAJ: another cool thing to do is to write a parser which builds itself up using the initial parts of the input.
13:59:09 <SimonRC> chr1s: and of course you would get some parser-writing practice
13:59:09 <chr1s> Yes, that sounds like a good idea
13:59:12 <PaulAJ> http://www.defmacro.org/ramblings/lisp-in-haskell.html
13:59:15 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
13:59:30 <PaulAJ> Cale: yeah, that would be cool.
13:59:51 <LoganCapaldo> Where's Writing a Haskell interpreter in Lisp? That seems like it would be more interesting
14:00:05 <PaulAJ> Why would anyone want to do that?
14:00:15 <shankys> metaperl: Alright, so I'm already using NewCGI. Do you know how I might be able to get Bjorn Bringer's assistance?
14:00:38 <PaulAJ> You could write a Prolog interpreter.
14:00:39 <chr1s> I did read writing a lisp interpreter in lisp by Paul Graham, also very interesting
14:00:58 <Cale> PaulAJ: I had a parser in a program I wrote for my dad which used parsec to parse musical chord names (like C# minor ninth), and it took its vocabulary from a configuration file
14:00:59 <Lemmih> shankys: Have you found a bug in Network.CGI or do you want general Haskell help?
14:01:01 <newsham> now write a paul graham emulator
14:01:10 <shapr> shankys: you could ask bringert_
14:01:15 <PaulAJ> Yeah.  PG is trying to re-invent Lisp or something, which I think is a bit sad.
14:01:18 <LoganCapaldo> PaulAJ: Why would writing a lisp interpreter in haskell be more desireable?
14:01:22 <shankys> lemmih: no bug, I just want some general haskell help
14:01:31 <Masklinn> By the way, I wondered, is there any Haskell packaging/repository system akin to Ruby's Gems or apt-get?
14:01:32 <LoganCapaldo> Than Haskell in Lisp?
14:01:33 <metaperl> shankys - here is his email - bjorn@bringert.net  --- I suppose he is the one to contact
14:01:43 <shankys> metaperl: ok, thanks a lot
14:01:44 <bringert_> shankys: you called?
14:01:48 <Lemmih> shankys: Then you should ask the channel.
14:01:53 <metaperl> Masklinn - I think hackage and cabal is for that
14:02:10 <jlouis> Masklinn, cabal comes close when its about packaging source. There are IIRC no autodownload system
14:02:14 <PaulAJ> Its simpler to do, you get to do it in Haskell, and you can use the Lisp interpreter as a macro language for some application, like Emacs did.
14:02:24 <jlouis> but I might be wrong... I just picked Haskell up again a couple of weeks ago
14:02:28 <shankys> I want to know if it's possible to interactively debug Haskell CGI stuff in the interpretter
14:02:34 <chr1s> PaulAJ: It was quite some time ago when I last did prolog...
14:02:38 <PaulAJ> I believe cabal-get is in the works.
14:02:39 <shankys> sort of like you might do with console in Ruby on Rails
14:03:02 <Masklinn> metaperl & jlouis > Well I'd understood about Cabal as a packaging system, but I was wondering if someone had build an autodownload tool on top of it
14:03:10 <bringert_> shankys: hmm, good question. how does it work in RoR?
14:03:19 <chr1s> shankys: what kind of stuff do you want to do?
14:03:32 <jlouis> shankys, there you have Bjoern Bringert ;)
14:03:37 <chr1s> most of the things I did in console weren't really CGI related..
14:03:43 <PaulAJ> chr1s: And the unification stuff would probably be a bit tricky too.  OK, I wasn't too serious.  But do read that Lisp one.  Hmm.  A while ago David Brin lamented the lack of a simple Basic interpreter.
14:03:44 <shankys> I'm wanting to use Haskell to write our startup's web application
14:04:15 <bringert_> shankys: you can do debugging in ghci in principle, though I haven't thought specifically about that in the library
14:04:19 <jlouis> shankys, if you can grok haskell stuff a little bit hairier, then happs.org
14:04:32 <shankys> yeah, I looked at happs
14:04:35 <Cale> http://happs.org/HAppS/README.html
14:04:37 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.4 )
14:04:38 <Cale> yeah
14:04:39 <Cale> hehe
14:04:40 <chr1s> PaulAJ: hehe. Well, maybe I'm going to write a simple calculator first
14:04:47 <shankys> I really didn't like that it took 20 lines of code to write hello, world
14:04:48 <chr1s> but thanks a lot for the tips everyone
14:04:49 <jlouis> ?where happs
14:04:49 <lambdabot> http://happs.org
14:05:06 <bringert_> shankys: if you need a consultant, let me know :-)
14:05:14 <shankys> bringert: hehe
14:05:34 <bringert_> shankys: I don't see any problems with writing a small wrapper for interactive debugging
14:05:38 <shapr> shankys: HAppS has some nice advantages.
14:05:49 <LoganCapaldo> It's not how many lines of code it takes to write hello world, its how many addtitional lines it takes to turn hello world into something useful :)
14:05:49 <shankys> bringert: do you know where I might find largish examples of Haskell CGI use?
14:05:55 <shapr> I like the idea of an explicit state and an explicit state transformer.
14:06:08 <shapr> shankys: I can show you the wiki I wrote with happs.
14:06:18 <chr1s> s/tips/hints
14:06:20 <bringert_> shankys: http://darcs.bringert.net/hope/
14:06:23 <lambdabot> Title: Index of /~bringert/darcs/hope
14:06:29 <shapr> Yeah, Hope is way cool.
14:06:31 <shankys> shapr: I looked at happs, and it looked like it had a lot of advanced features, but I want something minimalistic
14:06:33 <shapr> I use Hope for my blog!
14:06:57 <ski> (isn't hope a language, too ?)
14:07:02 <bringert_> shankys: that's the largest Network.CGI app I know of, but there may be others
14:07:03 <bringert_> ski: yes
14:07:10 <shapr> Yeah, but bringert's framework isn't that language.
14:07:15 <shankys> bringert: ok, thanks
14:07:25 <shankys> bringert: I'll definitely be sure to take a look at that
14:07:32 <Cale> http://hope.bringert.net/about
14:07:44 <Excedrin> shankys: it's pretty easy to write simple apps in HAppS, I have a small example (probably not the best code, I'm new to Haskell) if you're interested
14:07:58 <bringert_> shankys: I started writing a tutorial: http://www.cs.chalmers.se/~bringert/darcs/hs-web-tut/
14:08:24 <Cale> It's sad that two of the "other web sites using hope" don't seem to be running
14:08:27 <shankys> excedrin: I'm interested. There doesn't seem to be a lot of examples of web programming online in the Haskell community :(
14:09:01 <metaperl> @type first
14:09:02 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
14:09:03 <Cale> shankys: yeah, there's something about having to operate on HTML which makes many Haskell programmers cringe
14:09:04 <Excedrin> shankys: http://harlan.lerp.com:9990/
14:09:13 <bringert_> Cale: yeah
14:09:49 <Cale> For one thing, it's one of the world's most complicated and sloppy data structures.
14:10:14 <metaperl> glguy - in your code here http://paste.lisp.org/display/31280#2 ... i'm confused about why first is only taking 2 args instead of 3
14:10:16 <Cale> and we're usually not content just to treat it as strings
14:10:53 <lisppaste2> Cale annotated #31280 with "first" at http://paste.lisp.org/display/31280#3
14:11:30 <metaperl> Cale - i dont understand the type signature for first
14:11:33 <metaperl> @type first
14:11:35 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
14:11:42 <metaperl> @type head
14:11:44 <lambdabot> forall a. [a] -> a
14:11:50 <kpreid> first has nothing to do with head
14:11:59 <Cale> metaperl: right, that's because it's a vast generalisation of the first which we've been writing
14:12:00 <metaperl> kpreid - yes I know
14:12:13 <metaperl> first takes 3 args
14:12:15 <Cale> metaperl: we've been writing an implementation of first for one particular Arrow
14:12:25 <Cale> no it doesn't
14:12:38 <Cale> in fact, it only takes one
14:12:46 <Cale> it takes an arrow from b to c
14:12:47 <metaperl> a b c -> a (b, d) (c, d)
14:12:53 <ski> first :: Arrow (~>) => (a0 ~> a1) -> ((a0,b) ~> (a1,b))
14:12:55 <Cale> and produces an arrow from (b,d) to (c,d)
14:13:37 <metaperl> oh so I'm reading the type signature incorrectly
14:13:42 <Cale> yeah
14:15:03 <SimonRC> The "forall" is universally qualifying the type variables a, b, c, and d.
14:17:27 <metaperl> should we have a wiki page tabulating all the Simons in the Haskell community?
14:17:51 <metaperl> Simon PJ, Simon JT, Simon (Jaffacake), SimonRC
14:17:57 <psnl> Marlow
14:18:07 <metaperl> what is jaffacakes last name? marlowe?
14:18:08 <pejo> metaperl, and all the Jones!
14:18:50 <metaperl> is Jaffacake Simon Marlowe?
14:18:54 <dons> morning
14:18:57 <dons> metaperl: yep
14:19:00 <dons> s/ee/
14:19:00 <metaperl> dons - morning
14:19:13 <metaperl> we were tabulating all the simons in the haskell community
14:19:19 <psnl> isn't it Marlow?
14:19:26 <dons> yea
14:19:29 <ski> yes
14:20:19 <glguy> cale?
14:20:31 <Cale> yeah?
14:20:40 <glguy> Havey ou seen the movie Primer?
14:20:44 <Cale> no
14:20:47 <glguy> hmm
14:21:03 <glguy> anyone here seen the movie Primer, and understand continuations?
14:21:26 <HeJor> How can i do this more efficient so it counts elements until n:  atMost n xs = length xs <= n
14:22:01 <glguy> atMost 0 _ = True; atMost (n+1) (_:xs) = atMost n xs
14:22:11 <glguy> atMost _ [] = False
14:22:33 <glguy> oh, that isn't atMost
14:22:37 <glguy> that's atLest
14:22:46 <ski> (n+k ..)
14:23:05 <glguy> but you get the idea?
14:23:11 <ski> glguy : what is the movie about ?
14:23:25 <glguy> ski: I don't know how to explain it without ruining it
14:23:33 <ski> ok
14:23:34 <notsmack> glguy: love primer, don't understand continuations
14:23:47 <notsmack> (Everybody go watch Primer, you'll all like it.)
14:24:03 <glguy> But it is my notion that Primer is what would happen if you had continuations that worked "in real life"
14:25:21 <glguy> I haven't managed to find anyone that understands both the movie, and the topic to bounce this off of though...
14:25:39 <svref> When implementing toEnum in an Enum instance, what are you supposed to do when your user passes you an Int too big for you to map it?
14:25:59 <glguy> > toEnum 7 :: Bool
14:26:00 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
14:26:04 <glguy> > toEnum 1 :: Bool
14:26:05 <lambdabot>  True
14:26:33 <svref> so: call error.  Thanks.  Got it.
14:26:41 <ski> universe :: ContT Void (StateT RealWorld Quantum) ()  -- or something, eh ?
14:27:42 <xerox> eeek.
14:29:37 <metaperl> glguy - thanks again for that unfoldr. I finally got it. I learned a lot - unfoldr as well as first!
14:29:49 * metaperl packs up and shuts down
14:31:10 <monochrom> haha
14:33:16 <jlouis> oy monochrom
14:34:25 <glguy> ?yow
14:34:25 <lambdabot> NANCY!!  Why is everything RED?!
14:34:57 <LoganCapaldo> woah
14:35:47 <chessguy> hmmm. who's nancy?
14:35:57 <jlouis> ?yow
14:35:57 <lambdabot> I didn't order any WOO-WOO ... Maybe a YUBBA ... But no WOO-WOO!
14:35:57 <dons> ?users
14:35:58 <lambdabot> Maximum users seen in #haskell: 276, currently: 261 (94.6%), active: 51 (19.5%)
14:36:02 <dons> chessguy: Reagan?
14:36:10 <dons> seems to be a lot of Reagan jokes in @yow
14:36:43 <jlouis> ?help fortune
14:36:43 <lambdabot> fortune. Provide a random fortune
14:37:04 <jlouis> I vaguely remember hacking on those modules for lambdabot, heh
14:37:33 <HeJor> is there somekind of replace function ? need to replace \n to \r\n in string
14:38:18 <dons> > lines "abc\ndef\n"
14:38:20 <lambdabot>  ["abc","def"]
14:38:32 <monochrom> If you venture into Text.Regex you can do fairly general replacements.
14:38:33 <dons> > intersperse "\r\n" . lines $ "abc\ndef\n"
14:38:34 <lambdabot>  ["abc","\r\n","def"]
14:38:37 <dons> > concat . intersperse "\r\n" . lines $ "abc\ndef\n"
14:38:38 <lambdabot>  "abc\r\ndef"
14:39:39 <LoganCapaldo> ?fortune
14:39:39 <lambdabot> I feel ... JUGULAR ...
14:39:51 <LoganCapaldo> well take your hand off my throat then
14:40:07 <monochrom> There is /msg lambdabot for your pleasure.
14:41:04 <glguy> ?all-dicts intercalate
14:41:05 <lambdabot> *** "Intercalate" gcide "The Collaborative International Dictionary of English v.0.48"
14:41:06 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
14:41:06 <lambdabot>   {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
14:41:06 <lambdabot>   intercalatus, p. p. of intercalare to intercalate to
14:41:07 <lambdabot>   intercalate; inter between + calare to call, proclaim. See
14:41:09 <lambdabot> [18 @more lines]
14:41:46 <LoganCapaldo> Naw, I only use /msg when I want to evaluate some code. When its some random entertaining thing I always make sure the whole room can see it ;)
14:42:37 <monochrom> Thanks, make sure it doesn't get out of hand.
14:42:49 <chr1s> I'm trying to catch a pure-language exception
14:43:02 <chr1s> my main has type IO ()
14:43:20 <monochrom> perhaps catch in main.
14:43:23 <HeJor> dons. not working, if \n\n
14:43:30 <chr1s> but there is a pretty good chance that somewhere in my do an exception is thrown
14:44:01 <shankys> shapr: I found a link to your wiki that you wrote in HAppS, but it's currently down. Do you have another link to your wiki that works?
14:44:07 <chr1s> but it looks as if catch only catches IOException, whereas I want to catch Exception
14:44:15 <monochrom> Can still catch in main.  main = (do ...) `catch` (\e -> do ...)
14:44:34 <chr1s> yes, that's exactly what I'm doing
14:44:51 <monochrom> Look into Control.Exception
14:45:19 <monochrom> In short, hide away the "catch" from Prelude, and import the "catch" from Control.Exception
14:46:26 <chr1s> ah, thanks
14:46:43 <chr1s> but... how do I hide a function?
14:46:58 * SamB wonders what a good way to find *natural* solutions to linear equations is
14:47:04 <HeJor> dons. if \n\n are in the end
14:47:10 <glguy> let hiddenfunction = 1 in hiddenfunction
14:47:22 <monochrom> import Prelude hiding (catch)
14:48:01 <glguy> ah, that kind of hiding (I need to read more of the channel)
14:48:13 <chr1s> hm, that doesn't seem to work
14:48:23 <chr1s> oh wait
14:48:24 <monochrom> I may be wrong about the exact syntax.
14:48:24 <chr1s> nm
14:49:08 <Saizan> or you can import Control.Exception qualified
14:49:11 <chr1s> :r
14:49:26 <chr1s> damn, that doesn't work on irc :(
14:49:57 <monochrom> Hell.  import Prelude as ItIsBetterToExplicitlyQualifyNames qualified  :)
14:50:45 <LoganCapaldo> import Musical.Interlude
14:51:03 <Sam__> LoganCapaldo: but, how do you play it then?
14:51:25 <glguy> Some people are like slinkies....not worth much but they bring a smile to your face when you push them down the stairs.
14:51:32 <chr1s> import IO hiding (catch)\nimport Prelude hiding (catch)
14:52:01 <monochrom> Ah, interesting.
15:04:01 * Cale plays around with logo ideas for hope :)
15:04:42 <Lavareef> Hello, people!
15:04:48 <Cale> Lavareef: hello!
15:05:07 <kosmikus> Cale: hope the programming language ??
15:05:19 <Cale> kosmikus: the CMS
15:05:45 <kosmikus> oh. name clash.
15:05:46 <Lavareef> I'm here because I have a haskell assignment, I'm afraid, but I try to be polite and friendly instead of barking questions :)
15:06:06 <kosmikus> go ahead
15:06:39 <psnl> Lavareef: quick question: where do you go to uni?
15:06:53 <Lavareef> Staffordshire.
15:07:05 <psnl> fire away then
15:07:27 <Lavareef> I was googling a generic haskell error message, and about the fourth result was a log from here circa 2004, with someone asking something similar :)
15:08:05 <monochrom> Nice.
15:08:42 <sorear> what's the error?
15:09:15 <Lavareef> I have a function named makeIndex which does various things to a string. It takes a string (as a Doc), and when I use it within hugs by typing "makeIndex blah" it works fine.
15:09:30 <Lavareef> However if I try to use file handling to read the contents of a file into "theInput", then have a line in a monad which says "makeIndex theInput", I get the errpr "Type error in generator"
15:09:44 <sorear> ?hoogle Doc
15:09:45 <lambdabot> Text.PrettyPrint.HughesPJ.Doc :: data Doc
15:09:46 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
15:09:46 <lambdabot> Language.Haskell.TH.PprLib.to_HPJ_Doc :: Doc -> Doc
15:09:52 <monochrom> print (makeIndex theInput)
15:10:10 <PaulAJ> What is the type of makeIndex?
15:10:24 <jlouis> ?type makeIndex
15:10:25 <lambdabot> Not in scope: `makeIndex'
15:10:35 <HeJor> how to concat lists in turn [1,2,3] [4,5,6] =>[1,4,2,5,3,6]
15:10:36 <Lavareef> monochrom's suggestion has worked perfectly :O
15:10:43 <jlouis> ahr, it needs a module prefix
15:10:53 <PaulAJ> IIUC makeINdex is Lavareef's function.
15:11:10 <sorear> haskell doesn't have full imperative support, and you have to assign actions to variables inorder to use them... e.g do x <- getLine ; putStr x instead of putStr getLine.
15:11:11 <jlouis> oh, sorry
15:11:15 <jlouis> Didn't see that
15:11:20 <monochrom> A line in a monad needs type "IO whatever".  "makeIndex theInput" has some other type.
15:11:25 <Sam__> sorear: hahaha
15:11:29 <Cale> HeJor: (++)
15:11:35 <Cale> > [1,2,3] ++ [4,5,6]
15:11:36 <lambdabot>  [1,2,3,4,5,6]
15:11:42 <Lavareef> Thanks a lot, monochrom.
15:11:50 <monochrom> But "print blahblah" has the right type and the side effect of outputting stuff.
15:11:52 <Cale> > concat [[1,2],[3,4],[5,6]]
15:11:53 <HeJor> Cale, i know, but [1,4,2,5,3,6]
15:11:53 <Sam__> doesn't have full imperative support -- thats a laugh ;-)
15:11:54 <lambdabot>  [1,2,3,4,5,6]
15:12:02 <Cale> ah, okay
15:12:05 <sorear> HeJor: concat . transpose
15:12:13 <PaulAJ> You probably want something like "let foo = makeIndex theInput" and then do other stuff with foo.
15:12:16 <Cale> > concat . transpose $ [[1,2,3],[4,5,6]]
15:12:18 <lambdabot>  [1,4,2,5,3,6]
15:12:24 <Lavareef> I must admit, I'm entirely new to haskell's way of thinking. I feel like I've been turned on my head :)
15:12:27 <Cale> sorear beat me to it :)
15:12:27 <HeJor> Nice
15:12:29 <monochrom> Hugs implicitly does a "print" on things you enter at the prompt.
15:12:38 <PaulAJ> Note how "let" operates inside "do".  It brackets a bunch of pure functional stuff.
15:12:42 <Sam__> jlouis: oh, hi!
15:12:55 <jlouis> Sam__, EHLO!
15:13:13 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
15:13:14 <lambdabot> Title: Introduction to IO - HaskellWiki
15:13:17 <SamB_XP> jlouis: EHLO? what manner of error is this?
15:13:27 <Cale> Lavareef: you might be interested in reading that link :)
15:13:37 <jlouis> SamB, Extended HELO on an SMTP server.
15:13:38 <sorear> EHLO is the new smtp handshake command
15:13:41 <jlouis> ;)
15:13:45 <sorear> the old one was HELO
15:13:45 <Taral> hello!
15:13:49 <sorear> note single L
15:13:50 <SamB_XP> jlouis: oh, I don't speak ESMTP
15:13:53 <monochrom> I am not a mail server!
15:13:56 <PaulAJ> Lavareef: I always felt like my brain was getting turned inside out.  Don't worry: after a while you find you like it.
15:14:00 <Lavareef> Thanks Cale, I'll read it right now.
15:14:05 <PaulAJ> Bye.
15:14:24 <Taral> does anyone know of a module to automatically turn a cabal package into a debian one?
15:14:30 <sorear> yes.
15:14:39 <Lavareef> That said, with that one niggle fixed I think the entire IO part of the program is finished. Now I can move onto other fun stuff.
15:14:52 <Taral> where can I get it?
15:14:55 <sorear> (i know, not helpful)
15:15:25 <SamB_XP> Haskell just helps you get your brain the right way out again
15:15:26 <sorear> libghc6-cabal-dev:
15:15:27 <paolino> will haskell do class inference ?
15:15:38 <sorear> ... or to Debianize those packages.
15:15:38 <Taral> yay
15:15:44 <SamB_XP> I don't think non-programmers find this process so difficult
15:15:47 <Taral> no!
15:15:50 <Taral>   libghc6-cabal-dev: Depends: ghc6 (< 6.4.2) but 6.6-3 is installed.
15:15:52 <monochrom> Yeah I don't like other languages unifying IO Int and Int.
15:16:00 <sorear> The *only* thing I miss about X is cut/paste.
15:16:02 <Cale> paolino: what do you mean by that?
15:16:05 <HeJor> @paste
15:16:06 <lambdabot> http://paste.lisp.org/new/haskell
15:16:06 <SamB_XP> since probably their brains are still the right way out
15:16:24 <Cale> paolino: it will infer general types for things, constraining type variables with classes as needed
15:16:55 <sorear> Taral: look at haskell-devscripts
15:17:05 <paolino> I mean infere that saying a constraint which implies others should be enough for that ...
15:17:06 <Taral> yay
15:17:14 <sorear> Taral: apt-cache too, that's how I answered you so quickly :)
15:17:18 * lispy grumbles a lot about scala
15:17:21 <Lavareef> Right, back to the grindstone. I'll no doubt pop up later. Thanks again!
15:17:24 <Taral> heh
15:17:27 <kosmikus> lispy: why?
15:17:31 <Taral> apt-cache put a lot of output... didn't want to search it
15:17:46 <lispy> kosmikus: just getting sick of dealing with the way things are done :)
15:17:56 <sorear> apt-cache search cabal only gave 5 hits... and I'm using sid
15:18:01 <SamB_XP> > (26+26+10)^12
15:18:02 <lispy> kosmikus: whenever you want to interact with the system you need to use the java libraries
15:18:02 <lambdabot>  3226266762397899821056
15:18:09 <lispy> kosmikus: so creating files and streams is a pain
15:18:26 <Cale> Lavareef: cool
15:18:29 <kosmikus> lispy: they don't have their own libraries? or at least wrappers?
15:18:36 <paolino> Cale , I made a dummy class to simplify constraint writing, but the compiler doesn't infere  I did it for that
15:18:53 <lispy> kosmikus: also, they have these neat things called traits, which are basically interfaces, but you can't pass them values when you use them so they end up being useless 99% of the time
15:19:02 <monochrom> If you mix Hindley-Milner type system with assignment statements, you get an inconsistency or you need a monomorphism restriction.  This is a surprise.  It is more surprising than time/space behaviour of lazy evaluation.  The imperative programming conspiracy tries to exaggerate the surprise of lazy evaluation and downplays the surprise of the need for monomorphism.
15:19:12 <lispy> kosmikus: near as i can tell, they have very little in their libraries
15:19:25 <SamB_XP> @type (26+26+10)^12
15:19:27 <lambdabot> forall a. (Num a) => a
15:19:32 <SamB_XP> > (26+26+10)^12 :: Integer
15:19:33 <lambdabot>  3226266762397899821056
15:19:38 <lispy> kosmikus: http://scala.epfl.ch/docu/files/api/index.html
15:19:39 <kosmikus> lispy: I see. I'm interested because I considered Scala as a possible teaching language.
15:19:40 <lambdabot> Title: Scala Library Documentation
15:19:58 <sorear> what are the conventions for /msg #haskell vs. /msg lambdabot?
15:20:05 <lispy> kosmikus: okay, well if the student knows haskell already scala will be quite confusing.  At least in my experence
15:20:12 <Cale> sorear: they're the same
15:20:43 <SamB_XP> sorear: you /msg lambdabot when people complain of the noise in #haskell
15:20:46 <kosmikus> lispy: no, that would be as a first language, I guess
15:20:49 <sorear> er, I meant, how should people (esp. newbies) decide which one to use?
15:21:25 <lispy> kosmikus: one really perplexing thing to me is the difference between creating a function with arity 0 vs. a function which takes only the empty tuple as a parameter.  You get into some odd cases there that I have yet to fully investigate/understand
15:21:29 <monochrom> If you have something worth the time of the public, say it in public.
15:21:43 <monochrom> If you just play with yourself, play in private.
15:22:04 <monochrom> I think these are very general and sensible principles.
15:22:32 <lispy> kosmikus: if your function has arity 0, it seems that naming the function calls it, but if it takes an empty tuple as a parameter then just naming it does not call it because it's not saturated...but then that doesn't seem to always be true either
15:22:46 <kosmikus> lispy: sounds like two different things to me
15:23:33 <lispy> kosmikus: also, due to the speed at which the language is changing, every tutorial and example i've looked at seems to have some issue :(
15:23:45 <dons> sorear: if you're truly exploring, and don't know what result is expeced, then /msg lambdabot is better
15:23:52 <monochrom> This is a difficulty arising from eager evaluation.
15:24:02 <dons> otherwise you can ask lambdabot in channel, but if you get it wrong too many times, people might ask you to /msg lambdabot :)
15:24:02 <lispy> kosmikus: also, the type inference seems to be wrong at times
15:24:19 <kosmikus> lispy: uh oh, that sounds bad
15:24:23 <lispy> kosmikus: so i end up always giving my type signatures
15:24:48 <kosmikus> I should just look at it again.
15:24:58 <dons> ?unpl (f .) . annotate
15:24:59 <lambdabot> (\ d h -> f (annotate d h))
15:24:59 <jlouis> ok, this requires a paper and pencil ;)
15:25:07 <lispy> kosmikus: are you familiar with the traits?
15:25:08 <jlouis> ?help unpl
15:25:08 <lambdabot> pointful <expr>. Make code pointier.
15:25:26 <jlouis> oh, its the inverse.
15:25:28 <jlouis> Neat.
15:25:28 <kosmikus> lispy: a bit
15:25:29 <lispy> kosmikus: they are classes and in terms of java they are partially implemented interfaces
15:25:34 <dons> ?unpl decorate     = annotate . f
15:25:35 <lambdabot> decorate c = annotate (f c)
15:25:56 <lispy> kosmikus: they are a really nice idea, except two severe problems i've encountered with them but not figured out how to solve
15:25:58 <sorear> mostly the inverse - some things like eta-conversion aren't easily invertable.
15:26:11 <jlouis> ah, ok
15:26:20 <sorear> (and of course variable names are lost :)
15:26:28 <kosmikus> lispy: it's not a new idea in scala though, is it?
15:26:55 <lispy> kosmikus: the first is that if you create a heirarchy of traits where the children are different but have some data fields in common (stored in the parent) and you use both of the children in a class they will literally share the data in their common parent.
15:27:28 <kosmikus> lispy, dons: btw, our version control paper got rejected pretty badly, so if you have suggestions, we're probably going to discuss what to do with it sometime soon
15:27:41 <lispy> kosmikus: i was trying to create a bunch of data collecting traits and then use them in one class, my StatCollector, but they were sharing their counters and such when i implemented it via traits
15:28:06 <monochrom> That is very poor.
15:28:15 <lispy> kosmikus: the other problem with traits is that they cannot have constructors...I have no idea what to do about that.
15:28:20 <lispy> kosmikus: ah, i'm sorry to hear that :(
15:28:22 <HeJor> id this concat efficient or should i put it somewhere else ? duplicate (x:xs) = concat [replicate x x | x<-x:xs]
15:28:26 <lispy> kosmikus: seemed like a good paper to me
15:28:35 <lispy> kosmikus: solidly written and important
15:28:45 * kosmikus never got as bad reviews as for that one
15:28:50 <Excedrin> kosmikus: what was it about Scala that you liked for teaching purposes?
15:28:57 <Igloo> kosmikus: Where was it submitted again?
15:29:03 <kosmikus> FASE
15:29:15 <monochrom> I think it's ok, HeJor.
15:29:30 <lispy> Excedrin: there are lots of things that seem great about scala for teaching...it does type inference, pattern matching, generics and tons of things
15:29:32 <kosmikus> Excedrin: the fact that it is a multi-paradigm language. I'd probably choose between Scala or Ocaml.
15:29:42 <Lavareef> I'm trying to figure out how to use writeFile correctly. I have tried "writeFile "d:\\aplc\\output.txt" makeIndex str" but it returns a "type error in application".
15:29:46 <Lavareef> specifically *** Expression     : writeFile "d:\\aplc\\output.txt" makeIndex str
15:29:54 <Lavareef> *** Type           : FilePath -> String -> IO ()
15:29:57 <Lavareef> *** Does not match : a -> b -> c -> d
15:30:07 <lispy> kosmikus: my intuition is that scala just need time to mature but would be better, once matured, than ocaml
15:30:12 <monochrom> writeFile "d:\\aplc\\output.txt" (makeIndex str)
15:30:28 <LoganCapaldo> Lavareef: function aplication has the highest precendence
15:30:28 <dons> HeJor: looks ok. note: [replicate x x | x<-x:xs]  ==  map (\c -> replicate c c) xs
15:30:33 <kosmikus> lispy: yes, I believe that
15:30:44 <LoganCapaldo> so its treating makeIndex and str as arguments to writeFile
15:30:58 <monochrom> Also, left to right.
15:31:25 <Igloo> Hmm, can't see a list of accepted papers, but then I couldn't for the one that already happened either...
15:31:36 <lispy> kosmikus: also, fwiw, i had a painful time with the osx installer.  I ended up doing a lot of the installation steps manually for some reason
15:31:59 <LoganCapaldo> You can use a $ instead of parens also if you want: writeFile "d:\\aplc\\output.txt" $ makeIndex str
15:32:09 <Lavareef> I am trying to make the output of makeIndex be the thing that writeLine is writing to a file, is that wrong?
15:32:29 <kosmikus> Igloo: just got the notification today, while the deadline was the 8th. give them a couple of days ;)
15:32:31 <monochrom> is "makeIndex str" going to be a String?
15:32:39 <Excedrin> kosmikus: I have no experience teaching; therefore, I always thought Alice ML (or Oz) would be good.
15:32:50 <Lavareef> Yes, but it is currently this
15:32:51 <Lavareef> makeIndex :: Doc -> [([Int],Word)]
15:33:31 <monochrom> "show whatever" turns whatever into a String.
15:33:32 <Igloo> Oh, 2006 does have a programme, they just hide it well
15:33:54 <lispy> kosmikus: it would be interesting to hear some of the feedback you were given.  I know that's really personal, but just general summaries.  If nothing else it will be good for me to know about when I go to write a paper about darcs :)
15:33:58 <monochrom> writeFile "filename" (show (makeIndex str))   will do something
15:34:05 <kosmikus> Excedrin: those might be good languages as well, but I don't know them much
15:34:44 <lispy> kosmikus: possible, one reason i'm having a bad experience with scala is that i needed to play with it more before starting a real program
15:35:03 <Lavareef> I'll leave this section for now, I'll probably be changing makeIndex later. Thanks :)
15:36:12 <dons> today's paper (trying to scare off the boring redditors ;)  --> http://programming.reddit.com/info/trj2/details
15:36:14 <lambdabot> Title: System F with type equality coercions: the new GHC Haskell core (reddit.com)
15:36:40 <monochrom> How new is new?
15:36:56 <dons> mm, last couple of months
15:37:03 <dons> still in active dev
15:37:05 <monochrom> I mean, is the GHC core used by GHC 6.6?
15:37:11 <dons> nope
15:37:14 <dons> only in the head
15:37:17 <monochrom> Wow, krad.
15:37:25 <monochrom> Is it planned for 6.8?
15:37:28 <dons> yeah
15:37:34 <monochrom> Scary.
15:37:45 <monochrom> Why are they changing the core every half a year?
15:37:54 <dons> they're not?
15:38:10 <monochrom> OK, maybe once a year.
15:38:13 <dons> its been pretty much static for years now
15:38:18 <dons> what are you thinking of?
15:38:21 <dons> the recent backend rewrite?
15:38:24 <Excedrin> what's the TR vs conference versions?
15:38:36 <dons> (i.e. the layer under Core was changed from Stix to Cmm)
15:38:46 <monochrom> Oh yeah, that one. Sorry.
15:38:48 <dons> Excedrin: common practice when page limits kick in
15:39:58 <monochrom> Stix and Cmm are executors, right?
15:40:13 <dons> they're imperative languages, close to C and asm
15:40:21 <dons> data types
15:41:00 <monochrom> There was some change from "push something" to "shift reset something" or the other way round.  What was it again?
15:41:11 <dons> that was in the runtime
15:41:17 <dons> the eval/apply paper
15:41:37 <monochrom> Thanks.  That was what I was thinking of.
15:41:37 <dons> back in 04, I think
15:41:59 <monochrom> I am growing old.
15:42:08 <monochrom> Everything seems like yesterday.
15:42:32 <HeJor> why doesn't this continue splittiks list as it supposed to do it. first, third, fith .. elements to first list. second, fourth, sixth elements to second list. split2 (x:x':xs) = ([a|a<-(x:xs)], [b|b<-(x':xs)])
15:43:14 <monochrom> Because the same xs is given to both.
15:43:46 <int-e> HeJor: because you told it to take everything from xs. btw, [a| a <- xs] equals xs.
15:44:01 <monochrom> split2 ([1,2,3,4]) = ([a|a<-[1,3,4], [b|b<-[2,3,4]).  The rest is history.
15:46:08 <monochrom> To get the correct solution, I recommend formally deriving the solution from a formal specification.
15:46:26 <monochrom> Of course I just mean a correct solution, not the.
15:47:38 <HeJor> Think it's bad
15:47:39 <HeJor> split2 (x:x':x'':xs) = ([x|x<-(x:x'':xs)], [x'|x'<-(x':xs)])
15:48:31 <lrrr> another question regarding arrays.. how to write a DiffArray to file? there's nice function hPutArray for MArrays, but i have no idea how to apply it to diffarray..
15:48:41 <HeJor> Well, at least ei got second elemnt right :P
15:49:54 <monochrom> If you know Template Haskell you can write a template to generate all the patterns along that line to cover all lists of all lengths.
15:50:36 <kosmikus> good night
15:50:47 <monochrom> Perhaps there is a O(1) way of coercing diffarray to marray.
15:50:54 <SamB_XP> HeJor: perhaps you meant to call split2 again?
15:51:00 <SamB_XP> monochrom: of course not!
15:51:10 <SamB_XP> you need to collapse all the diffy things
15:51:14 <sorear> unsafeThaw?
15:51:22 <monochrom> Ah, perhaps not O(1).
15:51:36 <SamB_XP> also, you probably want to copy it first?
15:51:57 <lrrr> unsafeThaw looks like O(n)..
15:52:17 <SamB_XP> lrrr: it depends
15:52:35 <SamB_XP> there are RULES that specialize it to O(1)
15:52:54 <SamB_XP> for certain pairs of types...
15:53:05 <monochrom> Hmm it's a diffarray, with persistence for old values.
15:53:12 <sorear> readDiffArray may do what you want
15:53:26 <monochrom> Anyway I recommend reading the docs.
15:54:00 <lrrr> library documentation isn't very verbose :)
15:54:33 <sorear> The real lib docs are hidden behind the leftmost link on the top line :)
15:54:41 <HeJor> hmm ? split2 (x:x':xs) = ([x] ++ split2 xs, [x'] ++ split2 xs)
15:55:10 <sorear> (note that some haddocks seem to have a bug, such that you must remove the 'raw-' to fix a 404)
15:56:02 <lrrr> :) err those docs are much harder to read to unexperienced haskell programmer like me.. :)
15:56:24 <lrrr> anyway i'll give it a try, thanks :)
15:56:59 <monochrom> I guess I expect too much of other people.
16:00:13 <lrrr> err the real problem that I understand how most of things work in haskell world, but looks like I need some time to sort all this stuff out properly in my head..  :)
16:01:17 <SamB_XP> sorear: yeah, thats quite true
16:01:47 <Pseudonym> Has anyone here looked at quantum annealing?
16:02:38 <SamB_XP> will it help me find natural solutions to systems of linear equations that have too many variables?
16:03:27 <Pseudonym> SamB: You're probably better off with a gradient-like algorithm.
16:04:11 <SamB> not that by "natural", I mean "non-negative integer"
16:04:14 <sorear> SamB: variables or equations?
16:04:30 <sorear> SamB: not or note?
16:04:32 <Pseudonym> SamB: Have you looked at the Levenberg-Marquardt algorithm?
16:04:36 <SamB> er. note.
16:04:54 <SamB> @google Levenberg-Marquardt
16:04:57 <lambdabot> http://en.wikipedia.org/wiki/Levenberg-Marquardt_algorithm
16:05:01 <Pseudonym> There you go.
16:05:17 <Pseudonym> I had a lot of success fitting gaussians to data using that algorithm.
16:05:37 * SamB is still trying to solve the black-knot puzzles from ICFP contest 2006
16:05:57 <sorear> given a fast enough processor and a patient enough user, I recommend using a list monad :)  (perhaps olegs fair list)
16:06:26 --- topic: '["Haskell - the language of ICFP winners 3 years running", "Distribute your cognition", "Logs: http://tunes.org/~nef/logs/haskell/"]'
16:06:26 --- topic: set by ChanServ on [Sat Nov 25 22:42:48 2006]
16:06:33 <dons> craapy freenode
16:07:21 <psnl> lets move to oftc! </flame>
16:07:49 <sorear> how 'bout USENET?  ever heard of a usenetsplit?
16:08:53 <SamB> monochrom: hmm, I'm not trying to optimize anything!
16:08:53 <dons> ?paste
16:08:53 <lambdabot> http://paste.lisp.org/new/haskell
16:09:12 <dons> yay, its back up
16:09:21 <Pseudonym> Usenet, thankfully, isn't real-time.
16:09:45 <monochrom> Don't optimize anything.
16:09:47 <lisppaste2> dons pasted "decorators in python are just function composition!" at http://paste.lisp.org/display/31317
16:09:50 <SamB> sorear: usenet is usually split
16:09:56 <SamB> nobody cares
16:10:09 <mbishop> heh
16:10:12 <SamB> at least, I assume it is
16:10:37 <SamB> it seems like it would be inefficient to have persistant connections between usenet servers...
16:10:41 <dons> SamB: so looks like the lisppaste guys sorted out their error?
16:11:02 <SamB> I guess so, if you aren't gettin 4xx _|_
16:11:22 <monochrom> usenet?
16:11:36 <SamB> oh, sorry.
16:11:47 <SamB> Pseudonym: hmm, I'm not trying to optimize anything!
16:12:09 * monochrom scratches his head
16:12:46 <Excedrin> dons: is there any more context? why were you thinking about decorators?
16:12:47 <sorear> SamB: who said anything about optimizing? (I said if-not-optimizing)
16:13:05 <Pseudonym> SamB: What exactly are you trying to do, then?
16:13:10 <Pseudonym> Mathematically speaking.
16:13:25 <Pseudonym> (I'm trying to optimise stuff, that's why I'm curious about quantum annealing.)
16:13:40 <Pseudonym> I have a problem which would seem to benefit from a kinetic component.
16:13:41 <sorear> solve diophantine systems?
16:14:18 <dons> Excedrin: oh, there's a post by metaperl on why haskell doesn't need decorators
16:14:19 <SamB> well, say I have some equations: [5 = e2[8,0] + e2[1,0] + e2[2,0],4 = e2[8,1] + e2[1,0],4 = e2[8,2] + e2[2,0],3 = e2[8,3] + e2[5,3] + e2[4,3] + e2[7,3],5 = \
16:14:19 <SamB> e2[8,4] + e2[5,4] + e2[4,3],2 = e2[8,5] + e2[5,4] + e2[5,3],4 = e2[8,6] + e2[7,6] + e2[9,6],2 = e2[8,7] + e2[7,3] + e2[7,6],2 = e\
16:14:19 <SamB> 2[8,1] + e2[8,2] + e2[8,0] + e2[8,5] + e2[8,4] + e2[8,7] + e2[8,3] + e2[8,6],5 = e2[9,6]]
16:14:24 <dons> Excedrin: so I was trying to understand them
16:14:42 <metaperl> yes, that was an interesting thing to explore Excedrin
16:14:46 <SamB> hmm. maybe pasting from Emacs isn't the best way to do that...
16:14:57 <dons> Excedrin: so I think: you compose a function with another that modifies the arguments. the resulting function is bound to the name of the original function, and the original is gone forever
16:15:01 <Pseudonym> SamB: OK, some linear equations.
16:15:02 <dons> sounds highly 'agile' ;)
16:15:09 <sorear> SamB: use C-SPC M-W
16:15:13 <SamB> and say I need all of my e2[i,j]s to be non-negative integers
16:15:18 * mbishop stopped using emacs
16:15:19 <dons> and they have special syntax for doing just this in python -- which sounds insane, imo
16:15:22 <SamB> sorear: its running in screen
16:15:27 <Pseudonym> SamB: With you so far.
16:15:38 * metaperl stopped using Emacs too... he uses XEmacs!
16:15:42 <SamB> Pseudonym: well, I don't know how to find some that work!
16:15:50 <Pseudonym> Ah.
16:15:53 * mbishop stop using all emacsen
16:15:54 <mbishop> :P
16:15:58 <mbishop> stopped*
16:16:15 <dons> metaperl, is this a reasonable encoding of decorators as function composition: http://paste.lisp.org/display/31317
16:16:16 * sorear stopped using all vi-en
16:16:23 * metaperl looks
16:16:27 <dons> metaperl: modulo that I didn't rebind 'f'
16:16:30 <monochrom> In OOP, you can write a wrapper class to wrap another class.  The wrapper class may add features.  This is called decoration.  Without state, this is function composition.  With state, this is monad transformer.
16:16:30 <SamB> notice that I have way more variables than I have equations
16:16:32 <dons> and that the result type isn't 'arbitrary' ;)
16:17:16 <sorear> This is a diophantine equation, and solving them is NP-hard
16:17:37 * eviltwin_b uses both (n)vi and (x)emacs, and thinks life is too short to argue over editors
16:17:48 <monochrom> You can transform this problem into type inference, then use a type inference engine.
16:17:57 * mbishop just uses kate now
16:18:00 * monochrom snickers
16:18:01 <Pseudonym> So it sounds like you do need optimisation.
16:18:21 <monochrom> Of course, Python needs special syntax for everything.
16:18:29 <SamB> Pseudonym: oh? that is optimization?
16:18:53 <Pseudonym> Most NP-hard problems are best expressed as an optimisation problem.
16:18:56 <Pseudonym> http://citeseer.ist.psu.edu/374822.html
16:18:58 <lambdabot> Title: Solving Linear Diophantine Equations - Tom'as, Filgueiras (ResearchIndex)
16:19:10 <dons> kfish++ hogg! http://www.haskell.org/pipermail/haskell-cafe/2006-December/020071.html
16:19:13 <lambdabot> Title: [Haskell-cafe] HOgg 0.2.0 Released, http://tinyurl.com/vfvoj
16:19:41 <monochrom> Godawful.  I mean awesome.
16:19:56 <eviltwin_b> (also eclipse, subethaedit, kate, kdevelop, and gedit, among others)
16:20:00 <SamB> Pseudonym: this is NP-hard?
16:20:21 <Pseudonym> Looks like it.
16:20:27 <Pseudonym> Certainly finding the minimal solution is NP-hard.
16:20:39 <SamB> thats okay than
16:20:47 <SamB> I just want a solution
16:20:48 <sorear> well wikipedia says (finding ONE solution) is
16:21:08 <dons> kfish: what's the motivation behind CC'ing lwn?
16:21:16 <dons> kfish: do they take general release announcements?
16:21:23 <SamB> I don't care whether it is minimal or not, so if minimal is easiest to find, I'll take it -- and if it isn't, I'll take what is!
16:23:38 <dons> mods please ;) http://programming.reddit.com/info/trp8/comments
16:23:39 <lambdabot> Title: HOgg: Ogg parsing and manipulation in Haskell (reddit.com)
16:24:25 <mbishop> heh
16:25:14 <mbishop> damn dons, you have more karma than me :P
16:26:08 <dons> heh
16:26:41 <lispy> that's dons for you
16:26:49 <lispy> even here he has a ridiculous amount of karma :)
16:26:54 <sorear> he's even got more than ME
16:27:14 <lisppaste2> HeJor pasted "optimizing" at http://paste.lisp.org/display/31319
16:27:16 <lispy> ?karma-list
16:27:16 <lambdabot> Unknown command, try @list
16:27:22 <sorear> ?karma
16:27:23 <lambdabot> You have a karma of 2
16:27:25 <lispy> ?karma-all
16:27:25 <lambdabot>  dons                   93
16:27:25 <lambdabot>  audreyt                39
16:27:25 <lambdabot>  dcoutts                38
16:27:25 <lambdabot>  Cale                   31
16:27:25 <lambdabot>  lambdabot              31
16:27:27 <lambdabot> [462 @more lines]
16:27:38 <lispy> i have about 20 and so I don't even make it on the list :)
16:27:38 <mbishop> ?karma
16:27:41 <lambdabot> You have a karma of 1
16:27:46 <HeJor> Can anyone optimize my code ?  http://paste.lisp.org/display/31319
16:27:47 <mbishop> yay
16:28:04 <LoganCapaldo> ?karma
16:28:04 <lambdabot> You have a karma of 1
16:28:09 <LoganCapaldo> Java++
16:28:40 <Pseudonym> ?karma
16:28:41 <lambdabot> You have a karma of 7
16:28:59 <HeJor> ?karma
16:29:00 <lambdabot> You have a karma of 0
16:29:00 <sorear> so, you want to take every element until the first duplicate?
16:29:12 <HeJor> sorear, jooh
16:30:10 <dav> ?karma
16:30:11 <lambdabot> You have a karma of 0
16:30:13 <HeJor> is my code sensible ?
16:30:15 <monochrom> It is indeed very complicated.
16:30:51 <sorear> ap (zipWith (==)) nub $ [1,2,3,4,5,2,3]
16:30:52 <sorear> > ap (zipWith (==)) nub $ [1,2,3,4,5,2,3]
16:30:54 <lambdabot>  [True,True,True,True,True]
16:30:56 <monochrom> I must admit that I didn't realize that logically a newbie writes more complicated programs. :)
16:31:01 <sorear> > ap (zipWith (==)) nub $ [1,2,3,4,5,2,7]
16:31:03 <lambdabot>  [True,True,True,True,True,False]
16:31:20 <lispy> monochrom: interesting isn't?
16:31:22 <sorear> > length . filter id . ap (zipWith (==)) nub $ [1,2,3,4,5,2,7]
16:31:24 <lambdabot>  5
16:31:41 <lispy> monochrom: there is a story about that...let me see if i can find it
16:31:53 <sorear> > (\x -> zipWith const x . filter id . ap (zipWith (==)) nub x)
16:31:54 <lambdabot>    Expecting a function type, but found `[c]'
16:31:54 <lambdabot>    Expected type: [a1] -> ...
16:32:07 <sorear> > (\x -> zipWith const x . filter id . ap (zipWith (==)) nub $ x)
16:32:08 <lambdabot>  Add a type signature
16:32:19 <sorear> > (\x -> zipWith const x . filter id . ap (zipWith (==)) nub $ x) :: Eq a => [a] -> [a]
16:32:20 <lambdabot>  Add a type signature
16:32:40 <Cale> > foldr (\x xs -> case xs of [] -> [x]; (y:ys) -> if x == y then [x] else x:y:ys) [] [1,2,3,4,4,5,6,7]
16:32:42 <lambdabot>  [1,2,3,4]
16:32:45 <sorear> ?let takeUntilRep x = zipWith const x . filter id . ap (zipWith (==)) nub $ x
16:32:47 <lambdabot> Defined.
16:33:21 <Excedrin> dons: I had fun yesterday trying to wrap Python statements into functions so they could be used inside lambdas, it's very ugly and I think it's nearly impossible (and definitely difficult) to code in Python in a functional style: http://www.rafb.net/paste/results/OlQ0gB72.html
16:33:42 <Cale> ah, but that's not what it does :)
16:34:21 <dav> is there a way to ask lambdabot to print me the definition of a standard function?
16:34:43 <dons> dav, nope. but you can read the src as follows:
16:34:44 <sorear> ?hoogle map
16:34:45 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
16:34:45 <dons> ?hoogle unfoldr
16:34:46 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
16:34:46 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
16:34:46 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
16:34:47 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
16:34:54 <dons> ?source Data.List
16:34:54 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:34:59 <dons> ^^ there
16:35:00 <dav> cool
16:35:05 <dav> thx
16:35:11 <dons> ?index unfoldr
16:35:12 <lambdabot> Data.List
16:35:16 <dons> ?. source index unfoldr
16:35:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:35:20 <dons> like that :)
16:35:26 <dons> Excedrin: ah mm.
16:35:34 <sorear> oooh, coool...
16:35:36 <sorear> ?help .
16:35:37 <lambdabot> . <cmd1> <cmd2> [args].
16:35:37 <lambdabot> . [or compose] is the composition of two plugins
16:35:37 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
16:35:38 <Cale> > last . filter (ap (==) nub) . inits $ [1,2,3,4,2,6,7]
16:35:40 <lambdabot>  [1,2,3,4]
16:35:52 <dons> sorear: its a *lambdabot*, it has to have compositoin
16:36:36 <dons> Excedrin: nice work
16:36:43 <mgsloan> hmm, will/does ghc use something like system F for an intermediate step? (that thing on reddit, don't really want to read it :P )
16:36:54 <dons> mgsloan: it does, yes
16:36:57 <dons> and now it uses System Fc
16:37:11 <kyevan> Er, hi.
16:37:18 <dons> if you use -ddump-simpl, you get the System F (c) representation of your code
16:37:28 <dons> hey kyevan. welcome.
16:37:37 <dons> Excedrin: so what are the limitations?
16:37:47 <kyevan> I think haskell looks interesting (and a tiny bit scary, but doesn't everything new?) but I don't know where to start learning. Could you possibly point me in the right direction?
16:37:47 <dons> it seems you worked out (.) properly.
16:37:59 <mgsloan> huh
16:38:04 <dons> kyevan: ok, first visit http://haskell.org and start looking at the tutorials
16:38:06 <lambdabot> Title: Haskell - HaskellWiki
16:38:06 <dons> and read:
16:38:08 <dons> ?where yaht
16:38:08 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:38:12 <dons> ^^ this guy
16:38:19 <dons> kyevan: also, I'd get ghc installed
16:38:27 <dons> kyevan: then, come back here and ask questions! :)
16:39:06 <mgsloan> I'm surprised that they go low level, since it seems like you'd be able to do further optimizations based on some of the high level stuff.  I suppose using it as an intermediary does allow more compiler reliability
16:39:07 <dons> mgsloan: you're supposed to read the paper for all the great symbols in there :)
16:39:29 <kyevan> Thanks :)
16:39:33 <dav> thx
16:39:33 <dons> mgsloan: exactly, and we have an existing formalisation for reasoning about new language features :: what's their translation into System F?
16:39:43 <dons> and if you can get it into System F, then you don't need to hack very hard
16:40:19 <Taral> is there a standard "once and once only" construct in Haskell IO?
16:40:25 <mgsloan> yeah, compiler flexibility, reliability, and elegance, but sacrificing a little speed
16:41:14 <lispy> monochrom: bleh, i can't find it :(
16:41:18 <sorear> unless you use unsafePerformIO, *all* IO actions are executed once and only once (i'm misunderstanding you, right ?)
16:41:34 <Taral> yes, you're misunderstanding.
16:41:40 <Taral> a = onceAndOnceOnly $ ...
16:41:52 <Taral> main = a >> a >> a >> a
16:42:10 <dons> mgsloan: speed?
16:42:15 <lispy> monochrom: i think this is a reference to it, but i can't find the actual story http://www.cincomsmalltalk.com/userblogs/arden/blogView?showComments=true&entry=3336037083
16:42:18 <lambdabot> Title: A tale of two developers, http://tinyurl.com/ym4ur4
16:42:34 <newsham> static int done=0; if(!done) { done=1; do_stuff(); }   ??
16:42:42 <bd_> Taral: onceAndOnceOnly, as a function, would have to return the same result if called twice with the same value
16:42:46 <bd_> thus you could have:
16:42:47 <newsham> IORef with a flag that tells if you did it yet?
16:42:48 <Cale> Exactly once
16:42:50 <bd_> a = onceAndOnceOnly $ return ()
16:42:52 <bd_> b = onceAndOnceOnly $ return ()
16:42:58 <bd_> main = a >> b -- runs it only once?
16:43:05 <Taral> bd_: No, this is the IO monad we're talking about.
16:43:07 <bd_> or an output function instead of return ()
16:43:15 <Taral> It doesn't have to return the same value.
16:43:16 <bd_> Taral: onceAndOnceOnly itself is a function however
16:43:23 <bd_> of type IO a -> IO a
16:43:26 <Taral> yeah.
16:43:38 <bd_> therefore, a = onceAndOnceOnly $ putStrLn "foo" must be functional
16:43:41 <bd_> er, pure
16:44:03 * Taral points to his original question.
16:44:14 <Taral> "construct". My example had a function.
16:44:17 <newsham> done = unsafePerformIO $ newIORef False;   onceAndOnceOnly act = do isDone <- readIORef done; when not isDone (do act; writeIORef done True}     ?
16:44:37 * Taral wants constructor syntax :(
16:44:52 <bd_> Taral: it's not possible as a function. Theoretically you could do it by altering the compiler's semantics, but ew. :P
16:44:58 <Taral> bd_: Not ew.
16:45:01 <Taral> Quite a common request.
16:45:15 <bd_> hmm
16:45:17 <Taral> Especially when interfacing with C.
16:45:31 <Taral> Right now, I have a library which wants me to call an initialization function.
16:45:35 <newsham> what about a State monad wrapped around an IO monad with a state of "done" ?
16:45:36 <bd_> I don't know if this is guarenteed to be safe: x = unsafePerformIO $ someAction; main = do stuff with x
16:45:46 <Taral> Since I'm just a module, I'd have to export this init function and have the caller call it.
16:45:51 <Taral> I'd much rather have it called on demand.
16:45:55 <bd_> is someAction guarenteed to be evaluated only once?
16:45:59 <Taral> bd_ in ghc.
16:46:00 <sorear> nothing is guaranteed about unsafePerformIO
16:46:17 <sorear> wrt nr of executions
16:46:19 <Taral> lookew like newsham has the best answer so far.
16:46:25 <Taral> *looks*
16:46:30 <bd_> sorear: Not even in the specific case of using it to initialize a global?
16:46:54 <bd_> If unsafePerformIO has semantics that loose, even newsham's example might be unsafe...
16:47:05 <Taral> bd_: In ghc it's safe.
16:47:06 <sorear> in the FFI docs I believe it says "The actions may occur zero, one, or more times and in any order with respect to the main IO thread."
16:47:13 <Taral> unsafePerformIO is not defined in Haskell98.
16:47:19 <Taral> So every compiler has its own semantics if it includes it.
16:47:23 <bd_> ic
16:47:26 <Taral> Most of them have once-and-only-once semantics.
16:47:31 <newsham> StateT Bool IO a ?
16:47:40 <Taral> sorear: Oh, right.
16:47:44 <Taral> Due to inlining.
16:47:44 <sorear> If you set +r in ghci then someAction will be executed many times
16:47:55 <Taral> Bah.
16:47:59 <Cale> once :: IO a -> IO (IO a)
16:48:08 <sorear> Cale: would works
16:48:10 <Taral> I'll just export the init function and make it the caller's problem.
16:48:17 <Cale> lisppaste2: url
16:48:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
16:48:18 <Taral> Cale: Huh?
16:48:18 <bd_> Taral: If you're interfacing with C, can you institute a wrapper library which contains a flag? It's ugly and depends on whether your platform will reuse library loads if you load the same library more than once, but it'd work...
16:48:44 <lisppaste2> Cale pasted "once" at http://paste.lisp.org/display/31320
16:48:49 <Taral> I wish someone would add a static constructor syntax to Haskell.
16:49:02 <Taral> something like the NOINLINE+unsafePerformIO, but defined to have the right semantics.
16:49:06 <sorear> bd_: every platform I know of (w98, wnt, linux) uses per-process data segments by default.
16:49:15 <newsham> runJustOnce :: IO a -> ST Bool IO a ;  runJustOnce act = do { done <- get; when (not done) (do { act; put True } ) }
16:49:20 <Cale> Taral: I certainly hope they don't :)
16:49:23 <monochrom> lispy: On that vein, when Dijkstra said against using LOC as a measure of productivity, he added: even let's say we go with it, it's on the wrong side of the ledger: it should be LOC saved, not LOC spent!
16:49:27 <chessguy> @paste
16:49:28 <lambdabot> http://paste.lisp.org/new/haskell
16:49:30 <newsham> (is that "liftIO atct" ?)
16:49:44 <lispy> monochrom: nice
16:50:07 <Cale> imo, there is no right semantics for this sort of thing.
16:50:16 <monochrom> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1036.html  is the full rant, and it's on many many things :)
16:50:18 <lambdabot> Title: E.W. Dijkstra Archive: On the cruelty of really teaching computing science (EWD  ..., http://tinyurl.com/mbvym
16:50:18 <lisppaste2> chessguy pasted "Monte Carlo simulator" at http://paste.lisp.org/display/31321
16:50:25 <Taral> Cale: Sure there is.
16:50:42 <Cale> (I'm vehemently opposed to singletons)
16:50:47 <newsham> oh, he just wants to ensur ethat some C code only runs once?
16:50:53 <newsham> just put a static var in the C code!
16:50:56 <chessguy> ok, so i'm constructing a population according to a particular probability distribution
16:51:00 <Taral> It's not my C code, newsham.
16:51:02 <Taral> It's a library.
16:51:07 <newsham> you can write C though, right?
16:51:11 <Taral> Don't want to.
16:51:15 <Taral> I'm trying to avoid writing C.
16:51:39 <Taral> Cale: What's wrong with adding the ability for a module to specify "run this IO action before main"?
16:51:46 <chessguy> specifically, i'm deciding how many people arrive for each of n minutes
16:51:55 <newsham> how about just one C file that has a large number of "char flag = 0;" type decls?
16:51:58 <Cale> Well, what you're dealing with is a design flaw in the C library. You really ought to fix the problem there.
16:52:09 <newsham> and then from haskell you check flag, and if not true, run C code and update flag?
16:52:11 <kfish> dons: yes, lwn take fairly broad announces -- i always announced liboggz etc. there
16:52:25 <chessguy> hmm, perhaps i should wait until the crossfire has died down
16:52:27 <newsham> (not very different from a bunch of IORefs with unsafePerformIO to initialize them)
16:52:30 <Taral> Cale: Hardly. I'm just trying to use Haskell's laziness to make the initialization lazy.
16:52:37 <Taral> The library's design is perfectly reasonable.
16:53:00 <newsham> or require an initialization action (IO ()) be called before using the lib, and set up the IORefs in that?
16:53:03 <Cale> Libraries with global state are evil :)
16:53:13 <monochrom> An interesting note.  In that article, he spoke how programming is a new thing and how mapping it to analogies must fail, even to the point of denouncing analogies altogether.  Meanwhile, in other articles (and probably even this one), he used analogies himself, such as "no one talks of knife science and telecope science". :)
16:53:30 <Taral> Cale: immutable global state is perfectly reasonable. It's called "static data".
16:53:30 <Cale> I'm already upset enough by the fact that we have things like getStdGen
16:53:33 <kfish> dons: though i tried to word that release as "this is a general tool for anyone to use", not "this is some wierdass haskell thing"
16:53:36 <SamB> hmm, maybe I should have just went with the list monad!
16:53:41 <eviltwin_b> arguably this is the kind of thing normally solved with e.g. withLibraryDo $ ...
16:53:47 <bd_> One possibly less-horrible way of doing things would be to add to the IO monad a primitive to return a value keyed on a String and its type. Your module could have a non-exported newtype of boolean, and store using this primitive a flag indicating whether the library was initialized. By ensuring the type does not escape your module, there's no danger of name collision.
16:53:56 <newsham> cale: you're easily upsettable :)
16:53:58 <Cale> Taral: If it's really static, then you shouldn't need to do any IO to make it happen.
16:54:00 <mwc> Woot, I just managed to use Okasaki's book as a reference for a final paper for a C++ course
16:54:15 <Taral> Cale: Sure you can. Large static data that may or may not be required?
16:54:17 <monochrom> Nice.
16:54:19 <SamB> then again, my diophantine equations aren't that arbitrary...
16:54:30 <Taral> I have to say "I'm going to need this, so please load/prepare it now."
16:54:33 <Cale> Taral: if you don't evaluate something, it's not evaluated :)
16:54:48 <Taral> Cale: This is C we're talking about.
16:55:04 <Cale> Well, in C, you have to resort to other tactics, sure.
16:55:17 <Taral> There are performance reasons for constructed immutable global state.
16:55:17 <newsham> i'd just use the ioref..  its easy and only just a little ugly in some code interfacing with C.
16:55:19 <newsham> who cares.
16:55:20 <monochrom> When is "now"?
16:55:38 <newsham> how soon is now?
16:55:39 <Taral> newsham: I'm checking the code to see if they already can handle multiple calls to the init function.
16:55:48 <bd_> Cale: Taral is writing Haskell -> C interfacing code...
16:55:59 <monochrom> But a toplevel "x = unsafePerformIO ..." works usually.
16:56:26 <newsham> yah, just unsafePerformIO the initialization code.
16:56:45 <Cale> If the C library has an initialisation function, why not just expose that explicitly from Haskell?
16:56:46 <sorear> usually.  It'll break when someone says :set +r, or if a clever GC tries to un-evaluate a big object.
16:56:58 <Cale> Make people call it from Main
16:57:03 <bd_> sorear: What if the unsafePerformIO is in a different module?
16:57:05 <monochrom> Hmm a C module has a global variable.  How to use it in Haskell?  That is a good question.
16:57:11 <newsham> "so I said "doc, it hurts when I do this." and he says "dont do that!""
16:57:12 <bd_> can it be inlined through the .hi?
16:57:13 <sorear> I agree, libraries with mutable global state is evil.
16:57:21 <Taral> Cale: That's what I'm doing right now. It's not as nice, though.
16:57:29 <pzpz> > let 2 + 2 = 5 in 2 + 2
16:57:30 <monochrom> The first question is who initializes it.
16:57:31 <lambdabot>  5
16:57:36 <Cale> You have to do it in C
16:57:38 <pzpz> advantages of this? hehe
16:57:51 <Taral> Yeah, well, C doesn't have laziness and on-demand computation.
16:58:06 <newsham> i thought you can read variables through the FFI by using Ptrs.
16:58:19 <SamB> newsham: if you can get pointers to them
16:58:21 <int-e> > let 42 = 23 in 42
16:58:22 <Cale> Laziness and side-effects don't mix
16:58:22 <lambdabot>  42
16:58:30 <monochrom> Suppose the C module goes like "int x = f(10);".  Who calls f with 10?  Where is the call site?
16:58:31 <Cale> (without something like the IO monad)
16:58:34 <Taral> ?!#)*($&#
16:58:34 <lambdabot> Unknown command, try @list
16:58:36 <sorear> We shouldn't place too many restrictions on what the GC may do.  That way lies performance problems.  (cf. B)
16:58:41 <newsham> samb: isnt that what the FFI import gets you?  pointers to globals and functions?
16:58:42 <Taral> what part of "cache" did you not get, Cale?
16:58:56 <pzpz> > let 2 + 2 = 5 in 2 + 3
16:58:58 <lambdabot>  Non-exhaustive patterns in function +
16:59:04 <Taral> caches are side-effecting *and* referentially transparent.
16:59:15 <Taral> they involve mutable global state, and they're very useful.
16:59:23 <int-e> monochrom: there are initializers for that. I think the libc takes care of that, before calling main. (could be the dynamic loader, too)
16:59:36 <monochrom> Yeah, I'm thinking of that.
16:59:46 <Cale> Well, go ahead and use unsafePerformIO then, if you know that it's safe.
16:59:58 <Taral> And now we're back to the original bit.
17:00:00 <int-e> monochrom: the compiler just notes a function to be called in a section in the executable. (windows might be different, I don't know)
17:00:16 <Taral> Where I said I wanted constructor syntax, something equivalent to NOINLINE+unsafePerformIO, but with pre-specified semantics.
17:00:43 <Cale> Wouldn't it be too open to abuse?
17:00:53 <Taral> Sure.
17:01:07 <Cale> I suppose that unsafePerformIO is already open to abuse
17:01:13 <Taral> Yup.
17:01:19 <monochrom> So, the .o file stores the init code.  The C linker links in crt0.o.  It is crt0.o's responsibility to iterate through the init code of every other .o's.
17:01:32 <int-e> @type "aaaaa"#
17:01:34 <lambdabot> GHC.Prim.Addr#
17:01:49 <Cale> but I'd call it less a part of Haskell, and more of a hook into the compiler
17:02:01 <Taral> Cale: Sure. I don't care if it's compiler-specific, even.
17:02:07 <int-e> literal arrays would be useful
17:02:11 <Taral> But I don't like using a pragma hack.
17:02:12 <newsham> mono: dont think plain old normal C has "init code"
17:02:30 <newsham> there's preinitialized data in the BSS and Data segments that come from the filesystem and the loader (zero pages)
17:02:34 <Taral> pragmas aren't supposed to be important to the proper functioning of the code.
17:02:36 <dons> Cale: its a good day when you visit reddit and see: " 5.  	
17:02:37 <dons> 	System F with type equality coercions"
17:02:38 <Cale> What's wrong with using a pragma to ensure that the inliner doesn't inline your code?
17:02:56 <int-e> that it doesn't get inlined ...
17:03:00 <Cale> dons: and for me, that's the topmost article at the moment
17:03:00 <monochrom> newsham: suppose at the top level "int x = f(10);".  How is it done?
17:03:10 <newsham> mono: is that legal C?
17:03:11 <int-e> i.e. it'll never get optimized to a literal Addr# in ghc
17:03:11 <bd_> monochrom: that's not allowed in C :)
17:03:28 <Taral> You can do something like it in C++
17:03:28 <monochrom> OH!  OK, nice, I have no more questions.
17:03:33 <eviltwin_b> yeh, it's illegal, except possibly in GNU C which has extensions for global initializers
17:03:39 <dons> Cale: how do you filter that?
17:03:42 <newsham> I think some dynamic loaders allow for load-time initialization of libs
17:03:42 <Cale> Taral: but you're doing something which is fundamentally breaking the assumptions with which expressions are evaluated
17:03:48 <eviltwin_b> C++ supports it but C++ supports global initializers/constructors
17:03:49 <newsham> but thats outside of the scope of C.
17:03:53 <Cale> dons: by modding almost everything down
17:03:55 <int-e> bd_: is that true for C99, too?
17:03:58 <dons> heh
17:04:04 <Taral> Cale: Hence why I decided it was better to define it instead as "run this before main".
17:04:07 <bd_> int-e: I'm almost sure it's forbidden in C99
17:04:16 <bd_> int-e: it'd make freestanding implementations ... a bit weird
17:04:18 <Taral> That way we're not trying to pretend any kind of referential transparency that's not there.
17:04:28 <Cale> dons: on the 'new' page, I have a jump from #16 to #38
17:05:16 <dons> why do I have a sense of forboding when I see: oleg@pobox.com       [Haskell] Re: GHC Error question
17:05:19 <Cale> Taral: I really don't care too much for the idea that importing a module is going to silently alter main.
17:05:19 <dons> in my inbox?
17:05:30 <lispy> dons: haha
17:05:37 <monochrom> Alright, so we have "int x;" in C.  Initialization is not a problem.  How do we read and write it in Haskell?  If we can do that we're done.
17:05:57 <Taral> Cale: Well, it's just a suggestion.
17:06:06 <bd_> monochrom: Only if the library has a convenient global variable for us to frob.
17:06:19 <Cale> Taral: I suppose it may help with FFI stuff
17:06:31 <Taral> That's almost the only place I need it.
17:06:32 <Cale> Taral: It might be worth adding something to the FFI notation
17:06:36 * lispy dances
17:06:40 <lispy> i'm finally off the hurd list
17:06:45 <SamB> hahaha
17:06:45 <lispy> only took me 3 years to unsub
17:06:46 <Taral> If you're trying to do it elsewhere, you're probably doing something wrong.
17:06:54 <Cale> Like a  foreign import initial ...
17:06:56 <SamB> what were you on *there* for?
17:07:03 <Taral> This isn't the first library that wants me to call something before using it.
17:07:10 <Cale> UNSUBSCIRBE
17:07:30 <Taral> Unknown command: UNSUBSCIRBE
17:07:38 <lispy> SamB: way back when i was still an undergrad i was playing with exotic OSs...so i installed debian GNU/Hurd and got on the list for a while...and never could get back off for some reason
17:07:38 <SamB> Taral: @help
17:07:52 <Taral> Unknown command: @help
17:08:08 <SamB> lispy: I installed it a little over 3 years ago, too
17:08:15 <SamB> it might or might not still be installed
17:08:16 <Taral> grr
17:08:22 <Taral> how do I build an out-of-memory ioerror?
17:08:25 <SamB> I forget if I installed plan9 on top of it or not
17:08:44 <newsham> can you do    foreign import ccal "var" var :: Ptr CChar   ?
17:08:44 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html#using-own-main  may be of interest
17:08:47 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/ylojgn
17:08:52 <Cale> Hello, I would like to unsuscribe to this mailing list. I have tried many times to unsubscirbe, and it never works!
17:08:58 <int-e> 'foreign import ccall "&" bar :: Ptr CInt'
17:08:58 <monochrom> "Using your own main()".
17:09:03 <lispy> SamB: i was going to try plan9 but on the website you had to register to download it so i never made it past that page :(
17:09:11 <SamB> lispy: what?
17:09:14 <SamB> you can't register?
17:09:25 <newsham> int-e:  the "&" means to get the address of bar?
17:09:33 <lispy> SamB: i probably could have, but i _hate_ registering for crap
17:09:37 <int-e> newsham: apparently (it's straight from the FFI spec)
17:09:40 <chessguy> Cale, tell him he has to send a message with the word 'unsbscsricsrbie' in it.
17:09:48 <monochrom> I should play with FFI some time.
17:09:50 <lispy> SamB: that is, when it's required...if it's optional i often don't mind
17:09:52 <SamB> lispy: I didn't particularly like that either
17:09:55 <int-e> newsham: that looks quite usable actually.
17:10:31 <lispy> SamB: i think the difference is that once you've invested a bit and see if registration is worth it, you're more willing to do it.  But if you can't even get a look because you have to register first, it's bye-bye time
17:10:55 <monochrom> Darn you Australians, who own the FFI doc and make me wait forever for it to be served from the other side of the Globe, plus a slow link between your continent and the centre of the universe!
17:11:33 <lispy> and curse them for having summer this time of year, that's just not proper
17:11:39 <monochrom> Hell, s/continent/tiny island/  # Hahaha!!!
17:11:49 <lispy> it's been 30-40 degs F, here lately
17:11:54 <Pseudonym> Didn't you know, Australia is the arse end of the world.
17:11:56 <monochrom> Oh, summer is ok, they're entitled to it.
17:12:08 <Pseudonym> Believe it or not, it was a prime minister who said that.
17:12:38 <lispy> oh, and we don't use made up words like "arse"
17:12:56 <lispy> seriously, you guys should use american english ;)
17:13:03 <Pseudonym> You wouldn't know the difference between a donkey and your posterior.
17:13:24 <Pseudonym> And we didn't make it up.  I think the Irish did.
17:13:44 <lispy> i didn't realiZe
17:13:48 <ihope> Did somebody say Toronto was the center of the universe?
17:13:56 * mgsloan speaks american english and use "arse"
17:14:03 <Pseudonym> lispy: I concede the s vs z thing, at least for Greek words.
17:14:07 <monochrom> Who says Toronto is the centre of the universe?
17:14:14 <ihope> You, supposedly.
17:14:15 <mwc> The problem with Australia is that it's in violation of continental drip theory
17:14:17 <int-e> which universe?
17:14:19 <mwc> damn them!
17:14:21 <monochrom> *I* am the centre of the universe!
17:14:22 <Pseudonym> For French words, "s" is more correct.
17:14:23 <kyevan> ihope: What are you doing here?
17:14:36 <kyevan> Get back to sinewaves#lobby!
17:14:42 <ihope> Asking if somebody said Toronto was the center of the universe.
17:14:49 <ihope> Hey, you get back there :-P
17:15:01 <kyevan> ihope: I have an excuse to be here!
17:15:06 <dylan> oh my. I think I'm infecting people with haskell.
17:15:06 <kyevan> Wait... no, I don't,
17:15:10 <kyevan> Never mind.
17:15:15 <dylan> first nornagon, now kyevan...
17:15:28 <monochrom> May I be infected too?
17:15:32 <kyevan> dylan: Hey, to be fair, bd_ helped you, too.
17:15:43 <dylan> I'm like an outbreak monkey for hsakell.
17:15:48 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- oh, more haskell infections
17:15:49 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:15:49 <dons> dylan: hehe cool
17:15:50 <dylan> bd_ is an outbreak monkey too. he infected me
17:15:55 <dons> dylan: you're carrier 0 eh?
17:16:02 <dylan> I'm carrier 1
17:16:05 <bd_> I think I may have got a music major started down the path of purity >.>
17:16:07 <dylan> bd_ is carrier 0
17:16:13 <bd_> Do I get a prize or something?
17:17:38 <dylan> dons: I'm having trouble building lambdabot on ghcc 6.6
17:17:52 <dylan> Could not find module `Data.ByteString.Char8': it was found in multiple packages: fps-0.7 base
17:18:00 <dons> dylan: are you using the lambdabot.cabal-6.6 file?
17:18:05 <bd_> dylan: what's the debian package for fps btw?
17:18:10 <dons> if not , mv lambdabot.cabal-6.6 lambdabot.cabal and rebuild
17:18:19 <leather_> dylan: Did you try to install fps-0.7?
17:18:19 <dylan> bd_: fps is in base I think
17:18:22 <dons> yep
17:18:23 <monochrom> Does anything support FFI to Java, i.e., the "jvm" keyword?
17:18:25 <int-e> dylan: you shouldn't install fps on 6.6
17:18:27 <leather_> I had that problem,t oo.
17:18:27 <dylan> leather_: yes, I did.
17:18:28 <bd_> hmm
17:18:33 <kyevan> Oh, right. I was going to ask something when I noticed ihope. Now what was it that I was going to ask....
17:18:33 <dylan> int-e: oops
17:18:37 <leather_> dylan: You should unregister it.
17:19:04 <bd_> Setup.hs: cannot satisfy dependency fps>=0.7
17:19:04 <leather_> Or do something like ghc -hide-packet fps-0.7
17:19:08 <int-e> dylan: it's has Data.Bytestring and the other fps stuff in the base package (as the error message indicates)
17:19:10 <kyevan> Oh, right
17:19:19 <leather_> ERrr -hide-package
17:19:26 <bd_> with ghc-6.6
17:19:27 <int-e> dylan: you have to edit lambdabot's cabal file I think
17:19:32 <int-e> bd_: same ;)
17:19:36 <dons> dylan: use the lambdabot.cabal.6.6 file :)
17:19:37 <bd_> oh
17:19:40 <dons> problem solved
17:19:52 <Cale> > fix $ (0 :) . (1 :) . ap (zipWith (+)) tail
17:19:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:19:55 <dylan> ah, worked
17:19:56 <kyevan> Is there a tool for haskell that gives a reasonable interaction system on windows?
17:20:03 <dylan> dons, int-e, leather_: thanks
17:20:03 <dons> WinHugs ?
17:20:08 <kyevan> (eg, not in a command line)
17:20:09 <dons> ?where winhugs
17:20:09 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/winhugs.php
17:20:14 <ihope> I came to Haskell from the Wikipedia article on Turing machines, I think. Turing machines -> Turing-complete things -> Brainfuck -> Esolang wiki -> Unlambda and/or Lazy K -> WikiWikiWeb or some such -> Haskell.
17:20:18 <dons> kyevan: or perhaps Visual Haskell now
17:20:20 <int-e> > fix ((0:) . scanl (+) 1)
17:20:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:20:24 <dons> kyevan: (see http://haskell.org )
17:20:25 <Cale> What's wrong with a command line? :)
17:20:26 <lambdabot> Title: Haskell - HaskellWiki
17:20:35 <ihope> Yeah, command lines are... um...
17:20:37 <kyevan> Cale: Nothing
17:20:54 <kyevan> The wrong-ness is in the windows command line box thing :P
17:20:56 <Cale> Well, I've always been annoyed by the terminal emulation on windows.
17:21:01 <Cale> yeah
17:21:10 <leather_> dylan: Yeah, listen to dons. My problem was with something that didn't have a cabal file.
17:21:20 <ihope> Get a different terminal emulator? :-)
17:21:21 <Cale> You can do a little better using emacs as your "terminal emulator"
17:21:27 <kyevan> I could just boot to Linux, but flash is unstable there, and I need to be working on something that uses it, and... >_<
17:21:30 <int-e> :k Monad
17:21:31 <lambdabot> Class `Monad' used as a type
17:21:31 <bd_> kyevan: ask fuzzie for a shell on twinsen and use it there with PuTTY? >.>
17:21:48 <kyevan> bd_: Eh, I could do that
17:21:52 <lisppaste2> chessguy pasted "Why doesn't this work?" at http://paste.lisp.org/display/31327
17:21:53 <dylan> kyevan: you can have a shell on odin or loki if you want.
17:21:54 <int-e> :k Maybe
17:21:56 <lambdabot> * -> *
17:22:05 <ihope> No, set up your own TCP server and PuTTY to yourself.
17:22:11 <Cale> I think emacs is probably the closest thing to a decent terminal emulator on windows. Oh, and putty isn't bad, but I don't think you can use it for local commands.
17:22:29 <dylan> Cale: with cygwin + sshd you can
17:22:33 <chessguy> i'm getting an error on the line rn <- (head $ myRands 1);
17:22:45 <leather_> I've concluded that there is no good terminal for Windows
17:22:49 <kyevan> Cale: Well, with cygwin/x you can use most of the *nix terminal emulators :P
17:22:56 <ihope> chessguy: syntax error?
17:23:02 <Cale> Well, at that point, you can just run a decent X terminal emulator.
17:23:08 <Cale> yeah
17:23:10 <chessguy> yes: Couldn't match `[a]' against `IO [Int]'
17:23:10 <chessguy>   Expected type: [a]
17:23:10 <chessguy>   Inferred type: IO [Int]
17:23:10 <kyevan> Cale: Right
17:23:28 <bd_> chessguy: you need to lift head into the IO monad. use rn <- liftM head $ myRands 1
17:23:35 <bd_> liftM being in Control.Monad
17:23:59 <ihope> Or just do rn <- myRands 1 and take the head of rn.
17:24:14 <chessguy> i thought it was in the IO monad. isn't that why myRands has type IO [Int] ?
17:24:23 <leather_> The basic cygwin terminal sucks. Almost any term in Cyginn/X is slow, except for rxvt and xterm.
17:24:24 <bd_> chessguy: yes, but the 'head' function isn't
17:24:24 <ihope> head x isn't in the IO monad for any x.
17:24:34 <bd_> chessguy: head is [a] -> a, and liftM is (a -> b) -> (IO a -> IO b), so (liftM head) is IO [a] -> IO a :)
17:24:46 <kyevan> leather_: and what's wrong with rxvt and screen?
17:25:02 * kyevan normaly uses konsole with tabs turned off and screen when he's on linux...
17:25:03 <leather_> kyevan: I want my konsole! :(
17:25:10 <leather_> EXACTLY!
17:25:15 <kyevan> Ah, you know what, to heck with it.
17:25:17 <leather_> Except I like tabs.
17:25:36 <monochrom> foreign import ccall "&" bar :: Ptr CInt   -- so this provides access to a global int variable from the C side.  Then one can dereference and read/write it in Haskell.
17:25:38 <kyevan> I'll deal with flash oddness. It's better than friggin notepad crashing >_<
17:25:49 <bd_> XD
17:25:53 <Cale> flash oddness?
17:25:58 <bd_> kyevan: vim has a windows port ;)
17:26:12 <kyevan> bd_: I know
17:26:21 <chessguy> ok, i think it's working now.
17:26:32 <kyevan> but many programs who want to show a text file, just do notepad <file>
17:26:44 <bd_> kyevan: so replace notepad.exe :D
17:26:46 <kyevan> and besides, xchat's getting on my nerves
17:26:53 <kyevan> I want irssi and amarok and such :P
17:27:24 <ihope> Why is Flash so important, again?
17:27:37 <ihope> Oh, and PuTTYtel raw to an IRC server is decent.
17:27:37 <bd_> ihope: he's got some school project or something using it, I dunnop
17:27:45 <sorear> Flash works very well under linux (it usually shows up as a SCSI disk)
17:27:54 <ihope> D'oh.
17:28:12 <bd_> sorear: Flash :: (Program p) => p
17:28:19 <lispy> ah, nice SimonM is investigating darcs-win32 issues
17:28:41 <lispy> what is his nick? I want to ++ it, but idon't remember how to spellit
17:29:00 <SamB> JaffaCake
17:29:05 <SamB> isn't that it?
17:29:09 <monochrom> I should play with FFI and cause a Haskell program to crash.
17:29:13 <LoganCapaldo> It's LoganCapaldo ;)
17:29:17 <lispy> JaffaCake++
17:29:23 <dmead> lispy: whats the emacs command to switch between open buffers?
17:29:28 <SamB> @karma JaffaCake
17:29:29 <lambdabot> JaffaCake has a karma of 9
17:29:34 <monochrom> C-x b
17:29:38 <lispy> dmead: C-x b
17:29:40 <SamB> I guess I got it right ;-)
17:29:48 <dmead> err
17:29:49 <dmead> not that
17:29:52 <sorear> C-x o
17:29:59 <monochrom> C-x C-b
17:30:00 <lispy> dmead: and if you don't already use, i recommend iswitchb mode
17:30:04 * sorear just *typed* C-x o at first
17:30:13 <dmead> err
17:30:16 <dmead> not all buffers
17:30:22 <dmead> just the ones i have open in split windows
17:30:26 <sorear> C-x o
17:30:28 <dmead> o
17:30:35 <dmead> hmm
17:30:37 <dmead> not workin ;/
17:30:38 <sorear> o is self-insert-command :)
17:30:39 <SamB> sorear: hahaha
17:30:42 <monochrom> C-x 2
17:30:49 <SamB> but, are you in Emacs?
17:31:01 <sorear> No, ircii.
17:31:06 <SamB> I keep trying to C-x o from terminal windows back to emacs ;-)
17:31:10 <monochrom> Oh, yeah, C-x o  "other window"
17:31:11 <sorear> Emacs is on vconsole 2
17:31:21 <dmead> hmm
17:31:32 <dmead> i guess i don't have the correct binds loaded
17:31:47 <sorear> > liftM2 (:) ['a'..'d'] ("":map show [1..])
17:31:49 <lambdabot>  ["a","a1","a2","a3","a4","a5","a6","a7","a8","a9","a10","a11","a12","a13","a...
17:31:55 <lispy> dmead: M-x other-window
17:32:05 <dmead> ahhh
17:32:07 <dmead> there we go ;o
17:32:11 <lispy> dmead: then it should tell you what the binding is
17:32:16 <sorear> > liftM2 (flip (:)) ("":map show [1..]) ['a'..'d']
17:32:17 <lambdabot>  ["a","b","c","d","a1","b1","c1","d1","a2","b2","c2","d2","a3","b3","c3","d3"...
17:32:21 <sorear> C-h w other-window
17:33:45 <dmead> i need to spend a day working out emacs all pretty
17:34:03 <monochrom> Buy a book on Emacs.  That's how I did it.
17:34:12 <dmead> yea i was supposed to
17:34:18 <dmead> but i never bothered and just winged it
17:34:19 <monochrom> Then I lent it to a friend, and it never returneth since.
17:34:20 <dmead> =p
17:34:28 <sorear> pretend you've deleted vim.  That's how I did it.
17:34:39 <lispy> dmead: http://projects.codersbase.com/repos/dotemacs/
17:34:40 <lambdabot> Title: Index of /repos/dotemacs
17:34:45 <monochrom> So I guess I should advise you to borrow it rather than buy it and lose it.
17:34:46 <SamB> pretended, or deleted?
17:34:55 <dmead> oh i hate vim
17:34:57 <sorear> pretended :(
17:35:03 <SamB> yeah, borrow it from monochrom's friend!
17:35:06 <monochrom> It's better to have your friend lose it to you than to have you lose it to a friend :)
17:35:26 <dmead> indeed
17:35:50 <lispy> dmead: if you use that assortment of elisp i recommend you just read through it and take what you need
17:35:58 <monochrom> apt-get remove vim
17:36:00 <lispy> dmead: it's messy but it has some handy things
17:36:03 <monochrom> That will do wonder.
17:36:20 <monochrom> And after you're done, you can revive it with apt-get install vim
17:36:42 * kyevan hugs konsole
17:36:54 * monochrom is hungry
17:37:09 <dmead> ahh
17:37:09 <dmead> kk
17:37:22 <kyevan> Oh look. I already have ghci installed here ^_^
17:37:22 <Monster> Anyone up for being devoured by me?
17:37:36 <dmead> o0
17:37:44 <jlouis> ?paste
17:37:44 <lambdabot> http://paste.lisp.org/new/haskell
17:38:01 * Monster m where devour :: a -> m a   {- aka return -}
17:38:48 <lisppaste2> jlouis pasted "Is there a nicer form for this?" at http://paste.lisp.org/display/31328
17:38:50 * sorear wields (undefined :: c a -> a)!
17:39:07 <Monster> Someone is out to get me!
17:39:21 <sorear> wrap *IS* fmap.
17:39:40 <jlouis> ok, wrap done
17:39:44 <jlouis> ;)
17:39:53 <jlouis> ah, of course
17:40:01 <sorear> adjoin = fmap . flip (,)
17:40:28 <sorear> ?unpl fmap . flip (,)
17:40:29 <lambdabot> (\ f -> fmap (\ c -> (,) c f))
17:40:49 <sorear> should ?unpl know about (,)'s magic?
17:40:51 <dons> kpreid++ unpl is so cool
17:40:59 <bd_> ?unpl join
17:40:59 <lambdabot> (\ b -> b >>= \ a -> a)
17:41:09 <bd_> huh. that's a new interpretation
17:41:14 <jlouis> sorear, ah, nice
17:41:27 <bd_> nice symmetry there
17:42:15 <jlouis> @source Prelude
17:42:15 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:42:23 <kyevan> AH!
17:42:29 <bd_> kyevan: ?
17:42:31 <kyevan> How do I quit ghci?
17:42:34 <bd_> kyevan: :q
17:42:37 <bd_> or Ctrl-D
17:42:46 <kyevan> oh.
17:42:52 <Monster> adjoin doesn't ring a bell. I guess you can leave it alone.
17:42:55 * kyevan blushthanks
17:42:57 <kpreid> sorear: that seems a reasonable addition
17:43:15 <Monster> On Monad matters, always listen to the Monster!
17:43:40 <kpreid> in fact, I think just adding (,) = \a b -> (a, b) to the combinator table would do it
17:43:50 <kpreid> er, except that doesn't generalize
17:44:21 <bd_> @pl \f g a b -> f (g a b)
17:44:21 <lambdabot> (.) . (.)
17:44:36 <lispy> ?pl (.) . (.)
17:44:37 <lambdabot> (.) . (.)
17:44:45 <lispy> ?unpl (.) . (.)
17:44:45 <lambdabot> (\ i b c f -> i (b c f))
17:44:51 <dons> @tell kzm i've added a bioinf category, if you want to put your tools in there.
17:44:51 <lambdabot> Consider it noted.
17:45:16 <bd_> ?pl \f -> (uncurry f) `(.) . (.)` (,)
17:45:17 <lambdabot> (line 1, column 19):
17:45:17 <lambdabot> unexpected "`"
17:45:17 <lambdabot> expecting variable, "(", operator or end of input
17:45:20 <bd_> hm.
17:45:32 <bd_> ?pl \f -> (.) . (.) (uncurry f) (,)
17:45:32 <lambdabot> ((.) .) . (. (,)) . uncurry
17:45:35 <bd_> :t \f -> (.) . (.) (uncurry f) (,)
17:45:36 <lambdabot>   Expecting a function type, but found `b'
17:45:36 <lambdabot>    Expected type: a -> (a1, b)
17:45:42 <sorear> bd_: haskell can only use symbols as infixes
17:46:00 <bd_> hmm, is that a GHC extension then?
17:46:23 <lisppaste2> chessguy pasted "claims randomTrials doesn't return IO [a] like it should" at http://paste.lisp.org/display/31331
17:46:51 <bd_> ?pl \f -> ((.) . (.)) (uncurry f) (,)
17:46:51 <lambdabot> (. (,)) . (.) . uncurry
17:46:58 <dons> nope . not an extension
17:46:59 <kpreid> `` can't even be extrended to allow infix, without making it whitespace-sensitive, because it's not left/right balanced
17:47:17 <dons> > (,) 1 2
17:47:18 <bd_> oic
17:47:18 <lambdabot>  (1,2)
17:47:24 <bd_> :t (. (,)) . (.) . uncurry
17:47:25 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
17:47:27 <bd_> whee
17:47:27 <kpreid> is `a`b`... `a `b` ... or `a` b ...?
17:47:36 <lispy> > (+1) `fmap` [1..10]
17:47:37 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:47:43 <dons> > (`map` [1..10]) show
17:47:45 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
17:47:49 <lispy> > (`fmap`) (+1)  [1..10]
17:47:50 <lambdabot>  Parse error
17:48:43 <lispy> i don't quite get why that one is a parse error, but dons example is not
17:49:04 <dons> sections don't work like that?
17:51:14 <lispy> :t `fmap`
17:51:15 <lambdabot> parse error on input ``'
17:51:22 <lispy> :t (+)
17:51:23 <lambdabot> forall a. (Num a) => a -> a -> a
17:51:33 <lispy> BTW, i'm really digging :t
17:51:42 <newsham> what would you want `fmap` to be?  fmap?
17:51:53 <lispy> newsham: yeah
17:52:12 <jlouis> how should one think of (.) when the right hand side can take more than one value, eg in fmap . flip (,)? I can see that the function flip (,) "eats" some value, 6 say and then produces something :: a-> (a, Int). But then what happens when we do (. flip (,) 6)) ?
17:52:14 <lispy> newsham: obviously it's not worth much, but given the way other things behave i sort of expect it to work
17:52:37 <bd_> jlouis: (. (flip (,) 6)) I think?
17:52:47 <bd_> :t (. (flip (,) 6))
17:52:49 <lambdabot> forall a b c. (Num b) => ((a, b) -> c) -> a -> c
17:52:50 <bd_> :t (. flip (,) 6)
17:52:51 <lambdabot> forall a b c. (Num b) => ((a, b) -> c) -> a -> c
17:53:35 <jlouis> Yeah, it needs to be fed something of type (a, b) -> c
17:53:45 <lispy> in terms of precedence it's fmap . flip (,) == (fmap .) flip (,) == ((fmap .) flip) (,), right?
17:54:08 <newsham> jlouis: a function of multiple args can be thought of as a function with one argument returning a function
17:54:29 <jlouis> newsham, yes, that is the currying "principle"
17:54:41 <dylan> hmm, my lambdabot can't eval haskell code.
17:55:12 <newsham> jlouis: so that answers your (.) question.
17:55:13 <lispy> dylan: how did you build it?
17:55:14 <SamB_XP> dylan: do you have hs-plugins?
17:55:52 <jlouis> newsham, hmmm, maybe it does. I might just be thinking too hard on this, heh
17:56:12 <dylan> hmm, ah. that package isn't installed
17:56:27 <dylan> I wish there was a debian virtual package that installed everything haskell/ghc related
17:56:38 <lispy> dylan: this is all explained in one of the readmes or build files in the lambdabot distro
17:56:50 <newsham> (f . g) x = f g x; lets say g takes three args (g a b c) then  (f g x) will take two more args.  x will provide the first argument
17:56:54 <dylan> yeah, I know. it's not the first time I've asked the question either.
17:57:07 <newsham> so (f g x) b c will return a value
17:57:11 <dylan> my last lambdabot install got wiped when my amd64 box broke
17:57:25 <newsham> and f will have to be a function that takes a function as an arg
17:58:21 <bd_> GOA installation fails with: Saving old package config file... ghc-pkg.bin: /usr/lib/ghc-6.6/package.conf: renameFile: permission denied (Permission denied)
17:58:28 <bd_> even though my prefix is $HOME
17:58:37 <bd_> how can I make it use a per-user prefix?
17:58:39 <bd_> [can I?]
17:58:44 <dons> you need to install as user
17:58:51 <dons> since you don't want to update the global package database
17:58:59 <bd_> dons: yes, I am
17:59:08 <bd_> I'll paste a transcript
17:59:21 <dons> did you pass the --user flag to Setup.hs configure ?
17:59:22 <jlouis> newsham, hmmm. I'll think a bit more about it. Seems to be my brain that needs a rewiring
17:59:23 <chessguy> ohmigoodness, my code compiled
17:59:31 <dons> i.e. runhaskell Setup.hs configure --prefix=$HOME --user
17:59:32 <dmead> o hot
17:59:36 <bd_> oh, nope
17:59:39 <bd_> wasn't in the README :)
17:59:40 <dmead> chessguy: whatchu working on?
17:59:41 <chessguy> stuff me with gizzards and call me a turkey
17:59:52 <bd_> there we go
17:59:56 <dons> bd_, right, otherwise it will install into $PREFIX, but update the global package db
17:59:59 <newsham> jlouis: walk through it step by step replacing definitions (ie.  (f . g) x = f (g x))
17:59:59 <chessguy> dmead, a monte carlo simulation of two queuing situations
18:00:04 <dmead> ah
18:00:08 <dons> you want to install into $PREFIX, and update your local package db
18:00:10 <dmead> sounds neaet
18:00:12 <dmead> ;o
18:00:20 <bd_> hmm
18:00:22 <chessguy> it should be easy, but i'm having a hard time with the do notation and random variables
18:00:37 <bd_> ./Setup.hs install seemed to work
18:00:37 <bd_> but
18:00:38 <bd_> module main:GOA is not loaded
18:00:40 <bd_> says ghci
18:00:58 <jlouis> newsham, ah, if g :: a -> a -> a in that thing, then f (g x) = (f . g) x will have f :: (a -> a) -> b
18:01:05 <chessguy> i think i finally got this part working though
18:02:38 <newsham> so lets use  (+) :: Int -> Int -> Int (approximately) and (\f -> f 3 + 2) :: (Int -> Int) -> Int
18:02:44 <dmead> i'm not too confortable with io in haskell yet
18:02:50 <dmead> *comfortable
18:02:50 <chessguy> :t (<-)
18:02:52 <lambdabot> parse error on input `<-'
18:03:09 <chessguy> what is this <- thing that takes stuff out of IO a
18:03:14 <newsham> > (\f -> f 3 + 2) . (+)
18:03:15 <dmead> arrow class
18:03:15 <lambdabot>  Add a type signature
18:03:18 <bd_> @paste
18:03:18 <lambdabot> http://paste.lisp.org/new/haskell
18:03:24 <newsham> ?type (\f -> f 3 + 2) . (+)
18:03:26 <lambdabot> forall a. (Num a) => a -> a
18:03:38 <newsham> > ((\f -> f 3 + 2) . (+)) 5
18:03:39 <chessguy> @hoogle IO a -> a
18:03:40 <lambdabot>  10
18:03:40 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
18:03:40 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
18:03:40 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
18:03:54 <jlouis> newsham, ah yes
18:03:57 <lisppaste2> bd_ pasted "goa breakage" at http://paste.lisp.org/display/31335
18:07:02 <sorear> <- is syntax sugar
18:07:17 <sorear> you say do { a <- getLine ; putStr a }
18:07:32 <sorear> what happens is getLine >>= \a -> putStr a
18:07:37 <sorear> ?type (>>=)
18:07:39 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
18:08:17 <glguy_> So what's this business about GHC getting a System Fc core?
18:08:22 <jlouis> newsham, thank, I get it new
18:08:25 <jlouis> now
18:08:33 <glguy_> is that something that happens in 6.8 or later?
18:09:08 <jlouis> but getting it screwed up my typing module in the brain
18:09:26 <dylan> how would I merge lambdabot.cabal.plugins and lambdabot.cabal.ghc6.6?
18:09:37 <dons> ?where+ HsSyck http://svn.openfoundry.org/pugs/third-party/HsSyck/
18:09:37 <lambdabot> Done.
18:09:50 <dons> dylan: what's the point? there's no hs-plugins for ghc 6.6 yet
18:10:04 <dylan> there isn't?
18:10:09 <dons> nope
18:10:22 <dylan> interesting. then why is ghc 6.6? and where is the previous version of ghc?
18:10:46 * dylan glares at his package manager
18:11:59 <dylan> where's the ghc 6.4 debian package? :(
18:12:05 <dmead> =/
18:12:10 <dmead> wheres the 6.6 gentoo package
18:12:13 <dmead> :<
18:12:54 <mbishop> probably in gentoo-really-unstable-no-really-we-mean-it-this-time-unstable
18:13:30 <dylan> cool. no ghc6.4 in sid.
18:13:43 <kyevan> dylan: There's, um, ghc5
18:13:45 <kyevan> maybe
18:13:56 <kyevan> It's in Sarge, I knoq...
18:14:18 <kyevan> nope, guess it's not in sid
18:14:29 <mbishop> sid has ghc6 and ghc-cvs
18:14:52 <dylan> ghc6 is ghc 6.6
18:14:55 <sorear> in sid, several packages depend on ghc (<=6.4.2) && ghc (>=6.6) !!
18:15:19 <mbishop> hmm
18:15:24 <mbishop> well for a while they had 2 packages I believe
18:15:27 <kyevan> sorear: Well, this IS sid we are talking about :P
18:15:27 <sorear> e.g. Gtk2Hs
18:15:43 <kyevan> Sid doesn't have to make sense :P
18:15:43 <mbishop> you'd do apt-get ghc6 and it'd ask "ghc6 or ghc-6.6" or something like that
18:15:45 <dylan> let's see how well I can break things by downgrading
18:15:54 <sorear> yeah.  Fortunately I could install gtk2hs using cabal
18:16:20 <sorear> Unfortunately ghc6.7 crashed when I tried to use the ghc6.6 binary libs :(
18:16:41 <sorear> (yes I know it's in the FAQ)
18:19:30 <dmead> mbishop: yea seriously
18:20:51 <dylan> so, etch has ghc 6.6 too, and no 6.4
18:21:13 <sorear> ?pl \x -> x >>= flip when x
18:21:14 <lambdabot> ap (>>=) (flip when)
18:23:07 <Taral> grr!
18:23:07 <Taral> Hash.hsc:42:13: parse error on input `#-}'
18:23:12 <Taral> hsc2hs doesn't understand pragmas?
18:23:22 <Taral> or is my pragma wrong?
18:23:34 <Taral> ah, pragma wrong
18:32:58 <mbishop> Oh, some of you smart guys should submit more snippets to http://pleac.sourceforge.net/pleac_haskell/index.html
18:35:39 <lispy> when i looked at pleac i was horrified and mystified
18:36:24 <lispy> the author has defined/redefined many things in a quite unusual way :)
18:36:34 <sorear> wow that's not even h98!!
18:37:27 <pitecus> Is there some standard command-line parsing library?
18:37:34 <lispy> and some things are just wrong
18:37:35 <dons> yeah, getoptoins
18:37:38 <dons> ?hoogle options
18:37:39 <lambdabot> Distribution.PackageDescription.options :: BuildInfo -> [(CompilerFlavor, [String])]
18:37:39 <lambdabot> Distribution.InstalledPackageInfo.ccOptions :: InstalledPackageInfo -> [Opt]
18:37:39 <lambdabot> Distribution.InstalledPackageInfo.hugsOptions :: InstalledPackageInfo -> [Opt]
18:37:40 <lispy> - no multiline, you can emulate it with ++ and \n, or unlines
18:37:41 <dons> nah
18:37:46 <dons> ?hoogle GetOpt
18:37:46 <lispy> actually haskell has multiline strings
18:37:46 <lambdabot> Distribution.GetOpt :: module
18:37:47 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
18:37:47 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
18:37:52 <dons> its in System.*
18:38:14 <pitecus> Cool thanks
18:38:31 <lispy> > [1..10] !! (-1)
18:38:32 <lambdabot>  Exception: Prelude.(!!): negative index
18:39:13 <lispy> if i were programming with someone that used pleac style coding i'd slap them a few times :)
18:41:42 <lispy> an example, is what they did with (!!)
18:41:47 <lispy> they should have just made a new function
18:41:52 <lispy> not redefine (!!)
18:41:54 * kyevan boggles at purely functional
18:42:04 <kyevan> I'm already getting a headache >_<
18:42:37 <dons> its a simplication -- turn off mutability-by-default, turn off side-effects by default
18:42:49 <dons> so less things to worry about: functions take args and return them that's it
18:43:06 <kyevan> dons: I know that on some level.
18:43:16 <kyevan> I could have told you that, but it doesn't make sense..
18:43:20 <lispy> kyevan: great, you're set then :)
18:43:25 <kyevan> Not that what I just said made any sense
18:43:47 <lispy> kyevan: is there a particular thing boggling you that we could help explain?
18:43:52 <sorear> To misquote Feynman (?) : If you understand Haskell, you don't know it.
18:44:40 <lispy> sorear: does the real quote involve physics?
18:44:43 <SamB_XP> sorear: know what?
18:44:49 <sorear> quantum mechanics
18:45:12 <kyevan> lispy: I'm just having trouble grasping that things will never do things other than pass back something
18:45:34 <SamB_XP> so quantum mechanics don't know quantum mechanics?
18:45:36 <kyevan> I'll get it eventually. I already can tell you what happens, so I guess I'm halfway there :)
18:45:47 <lispy> kyevan: yup
18:45:56 <dons> kyevan: but that's what functions normally do... everywhere. except when you're being evil and mutating globals on the sly
18:46:15 <dons> (which is really just taking in the global state as and ard, and returning it modified, with special adhoc syntax ;)
18:46:21 <lispy> kyevan: haskell doesn't really get exciting until you learn monads and get good at laziness :)
18:46:25 <dons> s/as an arg/
18:46:34 <kyevan> dons: Well, I'm comeing from a horribly-butchered scheme, so...
18:46:38 <SamB_XP> dons: ad-hoc semantics too!
18:46:39 <dons> heh
18:46:43 <dons> SamB_XP: right!
18:46:51 <SamB_XP> dons: if any!
18:47:22 * mbishop is good at laziness...but don't know a thing about haskell :)
18:47:39 <lispy> i don't understand all this push for semantics.  I just need to deliver my software on time and meet my customer's needs
18:48:02 <lispy> what does type safety have to do with that! </sarcasm>
18:48:03 <kyevan> Laziness makes more sense than being pure.
18:48:05 <SamB_XP> lispy: you wouldn't believe how useful semantics are for the latter!
18:48:27 <SamB_XP> kyevan: bein pure is just the only sane way to deal with having laziness
18:48:31 <sorear> (Wikiq says Niels Bohr, "Anyone who is not shocked by quantum theory has not understood a single word.")
18:49:15 <kyevan> sorear: Oh, I understood a word or two of quantum theory. I then realised there was a snowball's chance in hell of me understanding the rest, and moved on :P
18:49:20 <dons> kyevan: yeah? I think purity is really a lot more obvious than laziness
18:49:22 <mbishop> "I'm shocked, SHOCKED...well, not that shocked." - Philip J. Fry
18:49:27 * araujo kind of hate with this "M$ shell" stealing google searches with the word "monad" on it.
18:49:35 <dons> kyevan: since then you can reason about what a piece of codedoes using only: its type, its arguments and its result
18:49:44 <SamB_XP> araujo: they renamed it though!
18:49:49 <dons> and you can say, paralellise it, or test it in isolation, without fear
18:50:00 <mgsloan> yeah, purity is more obvious, i reinvented it in optimizing a pet lang - function flag that determined that a function depends soly on its parameters
18:50:03 <araujo> SamB_XP, that's nice ... now we have to wait .......
18:50:11 <araujo> what is called now?
18:50:13 <mgsloan> lezy, now that i hadn't even thought of
18:50:20 <mbishop> "Powershell"
18:50:26 <dons> the C programmers advice: don't overuse globals, is just a way of saying: stay pure
18:51:00 <mgsloan> well, its along those lines at least.  if they were really going pure they'd say avoid side effecting functions ;p
18:51:01 <araujo> mbishop, i thought it was "Monad , the M$ Power Shell"
18:51:02 <araujo> :-P
18:51:06 <kyevan> So.. you could think of pure functions like boxes witha tube that comes in, and a tube that goes out. If you put something into the in tube, you always get the same thing out of the out tube, and nothing happens other than pushing the thing out of the out tube....
18:51:10 <kyevan> Right?
18:51:12 <lispy> yeah, most of programming language features are just there to help humans manage the complexity and deal with the tedium of talking to the machine
18:51:16 <mbishop> heh maybe, but now it's just "Powershell"
18:51:20 <dons> kyevan: yeah
18:51:21 <mbishop> and they released 1.0 a while back
18:51:26 <dons> kyevan: exactly
18:51:58 <lispy> kyevan: sine function is a good example
18:52:09 <kyevan> I guess it's true what they say : when confused, go to what you know. the tried-and-true tube metaphor :P
18:52:18 <lispy> kyevan: in math, you can't look at the value at tell how many times people have done story problems involving sine
18:52:39 <kyevan> Right... that makes sense.
18:52:59 <lispy> although,in haskell if  you turn on the profiler you can tell! ;)
18:53:42 <SamB_XP> lispy: depending on CSE!
18:53:46 * lispy wonders if the universe has a profiler and in some other parallel version of our universe the profiler is engaged and keep statitics on things like sine
18:54:10 <lispy> better yet, where is it logging to?
18:55:08 <kyevan> lispy: heaven.com/~YHWH/the-world/
18:55:10 <sorear> lispy: how does the universe tell our sine is the real sign? (No Eq for Real -> Real)
18:55:17 <bd_> lispy: only problem is the world's implemented about ten billion sine instances >.>
18:55:27 <bd_> or rather copies of the sine function :p
18:55:45 <newsham> i've never seen a sine in the world.
18:56:09 <sorear> Rice's Theorum : I forgot the details but I know it implies no Eq on general functions
18:56:10 <araujo> SamB_XP, monad was the 'code name' apparently.
18:56:11 <kyevan> ... That joke would be just too easy, Kyevan... Just too easy
18:56:35 <kyevan> sorear: So, have you ever heard of outside? They have lots of signs!
18:57:14 <kyevan> Yep, it was too easy :P
18:57:31 <kyevan> Hmm... so sine is a pure function, the human digestive system isn't,
18:57:47 <kyevan> Well, that's a horrid example./
18:58:03 <kyevan> But poop jokes are a natural way to frame things!
19:00:12 <kyevan> Mreh, all these Haskell intros on haskell.org seem to be approching it from the comeing-from-an-imperitive-language angle.
19:00:32 <Cale> Try the Gentle intro
19:00:38 <kyevan> I need one from the comeing-from-a-butcherd-almost-functional-language intro....
19:01:08 <Cale> http://www.haskell.org/tutorial/
19:01:08 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
19:04:29 <LoganCapaldo> kyevan: What butchered-almost-functional-language if you don
19:04:33 <LoganCapaldo> 't mind my asking
19:04:39 <LoganCapaldo> ack my enter key is too large
19:06:59 * sorear sympathizes with LoganCapaldo
19:07:19 * sorear has quite a few * sorear curses Enter in the logs
19:07:21 <Cale> Though usually I just recommend YAHT, though you might find that slow if you're coming from something really close like ML.
19:07:36 <bd_> LoganCapaldo: his scheme class has him on HtDP Beginner
19:07:51 <LoganCapaldo> aha
19:07:51 <mbishop> -_-
19:08:00 <mbishop> they must have been too cheap to get sicp :)
19:08:13 <bd_> (cons 'wow (cons 'look (cons 'isnt (cons 'this (cons 'fun? empty)))))
19:08:43 <kyevan> bd_: Hey, we have list!
19:08:45 <LoganCapaldo> (list 'wow 'look 'isnt 'this 'fun?)
19:08:55 <kyevan> And, that does reinforce the definition of a list
19:09:30 <bd_> yes, but implementing map reinforces it better
19:09:45 <kyevan> (A list is either empty, or (cons <an element> <a list>), where <a list> is either empty, or (cons <an element> <a list>) where <a list is either>...)
19:10:05 <bd_> map f [] = []
19:10:05 <kyevan> I will be able to recite that in my sleep for the rest of my life
19:10:13 <bd_> map f (h:t) = (f h):(map f t)
19:10:18 <bd_> mmm
19:10:18 <kyevan> Infact, I want that on my tombstone
19:10:41 <LoganCapaldo> data List a = Cons a (List a) | Empty
19:11:14 <SamB_XP> kyevan: I hope your tombstone is lazily evaluated!
19:11:16 <bd_> data List a = (:) a (List a) | []
19:11:17 <bd_> >.>
19:11:24 <bd_> not actually legal but it'd be fun if it was :D
19:11:24 <kyevan> SamB_XP: Nope
19:11:31 <Cale> foldr cons nil [] = nil; foldr cons nil (x:xs) = cons x (foldr cons nil xs)
19:12:26 <newsham> here lies bob, cdr of bob, Left Right of mary
19:12:40 <LoganCapaldo> struct node { int value; struct node* next; };
19:12:52 <newsham> i like my next pointers first.
19:13:05 <newsham> for(t = head; t; t = t->next) {
19:13:21 <kyevan> SamB_XP: I hope it's laxily evaluated and never required :P
19:13:33 <SamB_XP> kyevan: I would not hope such a fate on you!
19:13:44 <SamB_XP> I do not have that much faith in medicine
19:13:49 <kyevan> SamB_XP: I wanna be immortal!
19:13:54 <sorear> how about: type List a = Either () (a,List)
19:13:54 <newsham> i wouldnt wish immortality on anyone
19:13:56 <SamB_XP> that I can believe that they would actually make that tolerable
19:14:03 <kyevan> Though it might get boring, eventually.
19:14:13 <SamB_XP> also, this world sucks
19:14:23 <kyevan> How about this: I'll never die, until I damn well want to die.
19:14:36 <kyevan> (Wether that be age 100 or age 10000000)
19:14:41 <SamB_XP> that reminds me of Ever After...
19:14:49 <sorear> "I will live forever or die trying."
19:15:06 <LoganCapaldo> type Bool = Either () ()
19:15:07 <SamB_XP> where the king says "I'll simply deny him the throne, and ... Live Forever!"
19:15:31 <kyevan> hmm
19:15:37 <bd_> type List a = Maybe (a, List a)
19:15:44 * kyevan beats up plucker. Again
19:15:50 <kyevan> SUPPORT PDF ALREADY!
19:15:52 <newsham> type List a = [a]
19:15:57 <mgsloan> yeah, something that just ruins the coolness of lisp is cdr and car
19:16:19 <SamB_XP> kyevan: you don't seriously think you can READ pdfs on those tiny palm pilot screens do you?
19:16:21 <mgsloan> most rediculous names for such an abstract concept.  It comes from freaking assembly language....
19:16:24 <LoganCapaldo> newsham: How does that error message go? Something about infinite types? :)
19:16:54 * sorear has a infinite type inference algorithm
19:16:59 <kyevan> mgsloan: Well, beginner uses first and rest :P
19:17:16 <sorear> my suggestion was a lead-in for introducing it :)
19:17:17 <SamB_XP> kyevan: in what language?
19:17:18 <newsham> ?type iterate (\x -> [x])
19:17:18 <kyevan> (As do all the PLT varients)
19:17:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:17:20 <lambdabot>    Expected type: a
19:17:51 <sorear> My system doesn't yet support lists or lambda.
19:18:05 <sorear> Just combinatory logic (S, K, application)
19:18:27 <SamB_XP> no I?
19:18:29 <mgsloan> kyevan - heh, true. still, they should just forget the archaism
19:18:33 <sorear> I = SKK
19:18:46 <sorear> makes a good test case :)
19:20:00 <sorear> Expr> s(skk)(skk)
19:20:06 <sorear> (fix a . (a -> b))
19:20:06 <kyevan> So, wait.
19:20:07 <Adamant> car and cdr are used because they look better when composing
19:20:18 <kyevan> What would "let a = a" do
19:20:19 <Korollary> There's got to be frfrist
19:20:20 <kyevan> ?
19:20:24 <mgsloan> composing?
19:20:25 <glguy_> I like car and cdr because they are short :)
19:20:30 <glguy_> cadaar
19:20:34 <Adamant> right
19:20:34 <kyevan> mgsloan: caaadadddadaddadr
19:20:38 <mgsloan> yeah, the shortness is nice
19:20:45 <mgsloan> oh christ, they do that?
19:20:49 <Korollary> up to 5 I think
19:20:50 <glguy_> the composed cdr and cars only go out to 4 deep, right?
19:20:51 <sorear> tsk,tsk. Scheme only guarantees four
19:21:00 <kyevan> mgsloan: No, most only go to 4 or so :P
19:21:10 <dgriffi3> doesn't CL do 5?
19:21:29 <kyevan> On the other hand, Scheme has one awsome thing Haskell can't yet match : Lists and Lists
19:21:33 <kyevan> I mean, seriously
19:21:49 * Korollary doesnt follow
19:21:55 <lispy>  yeah, huh?
19:21:56 <glguy_> no, he's serious
19:21:58 <kyevan> It's implimentend (well, a small subset, anyway) on the Z Machine
19:21:58 * sorear doesn't either
19:22:08 <SamB_XP> kyevan: it isn't scheme though!
19:22:16 <mgsloan> maybe he means the thing where everything is a list?
19:22:19 * sorear didn't know the Z-machine was programmable
19:22:19 <CosmicRay> kyevan: by Z machine, are you referring to the interactive fiction machine?
19:22:20 <SamB_XP> it is awesome, however!
19:22:22 <Pseudonym> If you only have to implement a small subset on the Z machine, I reckon I could do that with Haskell.
19:22:25 <SamB_XP> CosmicRay: quite
19:22:28 <kyevan> CosmicRay: Yes.
19:22:40 <lispy> what is the feature?
19:22:44 <SamB_XP> Pseudonym: do it!
19:22:45 <lispy> Lists and Lists?
19:22:48 <lispy> i don't getit
19:22:55 <SamB_XP> lispy: its the title of the "game"
19:22:55 <Pseudonym> SamB: I get to pick how small a subset, right?
19:22:56 <sorear> I thought by Z, you were referring to the sandia-labs nuclear fusion machine.
19:23:03 <kyevan> lispy: Search the IF Archive
19:23:05 <SamB_XP> Pseudonym: I suppose
19:23:16 <Pseudonym> Fine.  I choose the type ().
19:23:23 * CosmicRay is proud to get a language reference that someone else didn't for once ;-)
19:23:28 <SamB_XP> but it ought to be a big enough one that it looks reasonably like Haskell...
19:23:39 <dmead> how do you find execution time in ghci
19:23:39 <SamB_XP> and you should be able to code up some puzzles
19:23:41 <dmead> ?
19:23:43 <Pseudonym> Hey, the deal was "a small subset".
19:23:55 <lispy> SamB_XP: you're assignment for next weekend is to write a Z-machine in Haskell
19:23:56 <SamB_XP> involving a genie or other mythological being
19:24:01 <Pseudonym> dmead: :set +s
19:24:03 <kyevan> Pseudonym: The subset is small, but not THAT small
19:24:03 <SamB_XP> lispy: I did that already
19:24:07 <sorear> programmable nuclear fusion, fun...
19:24:07 <dmead> thanks
19:24:10 <SamB_XP> it just needs a decent UI
19:24:17 <lispy> SamB_XP: ah, well make it play Lists and Lists
19:24:22 <kyevan> (It fails at (define (foo bar) (* bar 2)) in two spots.
19:24:23 <Pseudonym> This reminds me of the story from "The Psychology of Computer Programming".
19:24:42 <Pseudonym> The programming team who boasted about how fast their non-working program was.
19:24:54 <Pseudonym> "If I'm allowed to write a program that doesn't work, I can write one that's even faster!"
19:24:55 <kyevan> Firstm it doesn't let you do the normal function define, you HAVE to use Lambda, and second, * doesn't work >_<
19:25:24 <dmead> hmm
19:25:36 <kyevan> http://wurb.com/if/game/128
19:25:38 <lambdabot> Title: Lists and Lists
19:25:41 <dmead> i got 1/10 of a second to run my prover on 25 test variables
19:25:41 <SamB> * doesn't work?
19:25:45 <dmead> is that good?
19:25:45 <SamB> that has to be easy to fix!
19:25:57 <SamB> a lot easier than the conditionals!
19:26:07 <kyevan> SamB: Keep in mind, you're working on an IF system :P
19:26:11 <SamB> oh, btw, I think Haskell is allowed to need Glulx
19:26:16 <SamB> ;-P
19:26:20 <lispy> dmead: insufficient information to answer :)
19:26:26 <dmead> hehe
19:26:34 <dmead> want to take a look?
19:26:46 <kyevan> And it runs on Frobnitz, even!
19:26:50 <dons> hey guys, i've partioned the 'libraries' page on haskell.org under each category to distinguish applications from libraries, any comments -- or missing apps? -- http://haskell.org/haskellwiki/Libraries_and_tools
19:26:52 <lambdabot> Title: Libraries and tools - HaskellWiki
19:26:58 <SamB> kyevan: I've seen the code
19:27:00 <kyevan> but anyway, done now :P
19:27:17 <SamB> I tried to add "and" and "or", I think...
19:27:17 <lispy> actually, i think i need to disconnect again
19:27:19 <lispy> ttyl
19:27:36 <shapr> bye lispy!
19:27:44 <SamB> but iirc those aren't real functions and that gave me grief
19:28:04 <bd_> kyevan: You know, writing a scheme interpreter in haskell is a nice exercise :)
19:28:20 <dons> ?where flippi
19:28:20 <lambdabot> http://www.flippac.org/projects/flippi/
19:28:31 <SamB> or you could write a Glulx-targetting compiler in Haskell that compiles Haskell!
19:28:39 <kyevan> bd_: I don't even get types.
19:28:45 <kyevan> So, not quite that far, yet :P
19:28:47 <bd_> kyevan: heh
19:28:55 <JohnnyL> seen humasect
19:29:14 * SamB remembers that his ZMachine emulator doesn't have a Main module
19:29:24 <kyevan> Istill need a way to print without paper >_<
19:29:38 <dmead> whats a zmachine ;o
19:29:49 <mbishop> z machine was a VM
19:30:02 <kyevan> dmead: Interactive fiction VM, first used for the Infocom release of Zork
19:30:10 <mbishop> it's what infocom used as a platform for their text adventure games (because there were so many different platforms at the time)
19:30:11 <dmead> ah
19:30:22 <dmead> ah
19:30:24 <dmead> hmm
19:30:30 <dmead> lispy still here?
19:30:43 <kyevan> mbishop: There still are, and it still runs on 99 % of them :P
19:30:50 <mbishop> kyevan: indeed
19:31:12 <kyevan> Includeing Palm Pilots :P
19:31:15 <SamB> well, lets try to play this with no working status line!
19:31:32 <kyevan> anyyway...
19:31:40 * kyevan beats his head against a wall
19:32:01 <kyevan> think man, think!
19:32:16 <kyevan> How can you get YAHT on your Palm....
19:32:32 <bd_> does hugs fit on a palm, I wonder? >.>
19:32:58 <kyevan> bd_: You're welcome to try :P
19:33:07 <SamB> oooooh
19:33:14 <SamB> I just crashed my interpreter!
19:33:21 <kyevan> if you get it working, I'll install it next to lispme :P
19:33:27 <dons> SamB: you should add your Zmachine emulator..
19:33:32 <Korollary> YHC may run on PalmOS.
19:33:41 <dmead> o rly...
19:33:42 <SamB> dons: to what?
19:33:53 <dons> to the 'hardware emulators' subsection ?
19:34:00 <SamB> ... would someone make the UI work if I did this?
19:34:05 <dons> under the systems category?
19:34:07 <dons> yes! i'm 100% sure
19:35:24 <kyevan> dons: Well, there's no hardware zmachine, afaik.
19:35:43 <bd_> Pinky, are you thinking what I'm thinking? >.>
19:36:12 <kyevan> bd_: I think so, Brain, but where are we going to get rubber pants at this time of night?
19:36:15 <newsham> yes but where will be find a co monad and three simons at this hour?
19:36:37 <bd_> The Cabal will provide.
19:36:47 <LoganCapaldo> fjord
19:37:00 <Adamant> !pinky
19:37:05 <Adamant> !brain
19:37:13 <kyevan> LoganCapaldo: Those were made by, um... shoot, what was his name, again?
19:37:17 <dons> ?brain
19:37:17 <lambdabot> I think so, Brain, but we're already naked.
19:37:18 * kyevan fails at HHGG fandom
19:37:20 <SamB> oh, lovely, it uses the ERASE_WINDOW opcode
19:37:24 <LoganCapaldo> Slarbartifast
19:37:35 <LoganCapaldo> I almost certainly misspelled it
19:37:45 <LoganCapaldo> But he did say his name wasn't important
19:37:46 <sorear> slartibartfast
19:37:48 <kyevan> He got an award for them, you know.
19:37:49 <shapr> :brain
19:37:52 <kyevan> LoganCapaldo: That's true
19:37:57 <shapr> :t map
19:37:58 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:38:33 <dmead> sup guys ;o
19:38:34 <dmead> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
19:40:20 <dons> dmead: did you add it to the provers page of haskell.org yet?
19:40:32 <dmead> no, can i just edit the wiki myself?
19:40:36 <dmead> or do i have to get approval
19:40:41 <CosmicRay> that is the idea of wikis
19:40:43 <dons> you can edit it yourself, please do.
19:40:44 <dmead> =p
19:40:49 <dmead> alright
19:41:00 <dmead> whats a catchy name?
19:41:45 <dons> "dmeads mega cool autobot prover"
19:41:46 <dmead> hmm
19:41:50 <dmead> lol
19:41:59 <dons> aka DMCAP
19:42:05 <dmead> loool
19:42:15 <bd_> Hoover?
19:42:19 <sorear> ~/comment http://members.cox.net/stefanor/Unifier.hs
19:42:33 * sorear curses ncurses
19:42:40 <kyevan> bd_: Too close to that other project. I'd lose what litle mind I have left
19:42:42 <sorear> http://members.cox.net/stefanor/Unifier.hs
19:42:56 <kyevan> Name it CAINE
19:43:01 <kyevan> (ENIAC backwards)
19:43:03 <dmead> caine?
19:43:05 <dmead> hmm
19:43:08 <kyevan> Wait, don't. I want that name :P
19:43:11 <sorear> should this go on the wiki?  (Note: not you optimized for elegance)
19:43:13 <dmead> too late
19:43:14 <dmead> dibs!
19:43:20 <kyevan> :(
19:43:26 <dons> sorear: all projects should. cabalise it first, if you can
19:43:45 * kyevan wants to laziely print YAHT :P
19:43:46 <dons> just cabalise it, pick the right category, add it, and announce on the mailing list
19:43:51 <dmead> hmm
19:43:56 <dmead> i don't have a cabal script
19:43:58 <dmead> =/
19:44:04 <sorear> but it's soo small... 150 lines, 1 file
19:44:05 <kyevan> So I only waste paper as I read pages.
19:44:35 <CosmicRay> is it insane to post screenshots of a terminal program using my ProgressMeter library? ;-)  https://software.complete.org/hpodder/attachment/wiki/ScreenShots/hpodder-2.png
19:44:36 <lambdabot> http://tinyurl.com/yeemdo
19:44:47 <CosmicRay> err, without the https.  http://software.complete.org/hpodder/attachment/wiki/ScreenShots/hpodder-2.png
19:44:49 <lambdabot> Title: ScreenShots: hpodder-2.png - hpodder, http://tinyurl.com/y68ppn
19:44:53 <CosmicRay> thanks lambdabot
19:44:54 <dons> mmm, was someone trying this for haskell, http://www.foldr.org/~michaelw/emacs/color-box.png ?
19:45:06 <shapr> CosmicRay: spiffy!
19:45:06 <dons> CosmicRay: yay, finally! screenshots
19:45:15 <CosmicRay> hehe
19:45:26 <LoganCapaldo> CosmicRay: It's only insane since you used .png instead of .txt ;)
19:45:32 <CosmicRay> haha
19:46:09 <Korollary> need better fonts, dude.
19:46:21 <dmead> @paste
19:46:22 <lambdabot> http://paste.lisp.org/new/haskell
19:46:23 <dons> shapr: do you remember who was looking at 2d boxes coloriing in emacs for haskell?
19:46:34 <CosmicRay> Korollary: hothing better than 10x20 for me, man
19:46:36 <CosmicRay> or whatever that is
19:46:38 <sorear> dons: is "yet another unifier, written to demo a cool type system extension" useful enough to warrant the full announce process?
19:46:38 <dons> http://www.foldr.org/~michaelw/emacs/color-box.png <-- like this
19:46:56 <mbishop> heh, that's a thumbnail :P
19:47:03 <dons> sorear: probably not. but stick the link up under the 'compilre construction' page
19:47:04 <lisppaste2> dmead pasted "whats wrong here?" at http://paste.lisp.org/display/31340
19:47:09 <dons> sorear: though its been done before
19:47:13 <dons> (releasing small libs)
19:47:21 <dons> (via a full announce)
19:47:35 <sorear> by anyone other than stefanor@cox.net?
19:48:17 <dons> seafood released a small type checker last year this way
19:48:19 <CosmicRay> dmead: whas is line 13 of Prover.hs?
19:48:29 <dmead> import InfixLogic
19:48:38 <dmead> o0
19:48:53 <CosmicRay> dmead: perhaps you want ghc --make -o prover Prover.hs
19:49:02 <dmead> ahh
19:49:04 <shapr> dons: Not off the top of my head, no.
19:49:26 <CosmicRay> shapr
19:49:42 <kyevan> Is YAHT typeset using LaTeX?
19:49:46 <CosmicRay> dmead: ghc won't chase modules unless you use --make
19:50:00 <SamB> oh, huh
19:50:01 <CosmicRay> shapr: http://software.complete.org/ for some trac goodness!
19:50:01 <kyevan> (I ask because it looks like LaTeX style :P)
19:50:03 <lambdabot> Title: Available Projects
19:50:06 <dmead> ahhh
19:50:16 <SamB> apparantly I'm using threads to keep my UI state out of the interpreter proper ;-)
19:50:49 <dylan> kyevan: probably.
19:51:16 <shapr> CosmicRay: cool!
19:51:21 <kyevan> Huh, indeed it is.
19:52:09 <sorear> Where should I set the tradeoff between releasing-unusably-unpolished and releasing-never?
19:52:31 <SamB> dons: does that sound like a good strategy to you?
19:52:44 <LoganCapaldo> Always on the side of unpolished
19:53:02 <SamB> sorear: polish it so you can actually hope to be able to read it yourself, but not to the point where you are proud of it
19:53:12 <SamB> unless somehow you accidentally reach that point
19:54:02 <newsham> "i accidentally overpolished this code so I guess I have to release it"
19:54:11 <CosmicRay> newsham: I hate it what that happens
19:54:31 <CosmicRay> newsham: that's how I wound up releasing offlineimap and hpodder ;-)
19:54:54 <newsham> my bar is at "typechecks"  sometimes not even that
19:55:22 <dmead> for setup.lhs
19:55:24 <dons> SamB: threads are good
19:55:31 <dmead> defaultmain is the main that i've written yea?
19:56:20 <kyevan> Aww
19:56:38 <kyevan> YAHT doesn't appear to get along with latex2html :(
19:57:46 * sorear finds googling for cabal difficult :)
19:58:00 <SamB> dons: it keeps my ZM type nice and monomorphic
19:58:07 <SamB> that is really my main motivation for it!
19:58:16 <CosmicRay> is there a new url for yaht?
19:58:28 <CosmicRay> http://www.isi.edu/%7Ehdaume/htut/ is 404
19:58:31 <shapr> sorear: I like to release to a public repo at the end of every hacking session.
19:58:43 <shapr> CosmicRay: kowey got the source, it's GFDL now.
19:58:54 <CosmicRay> OH!
19:58:59 <CosmicRay> darcsify it man!
19:59:02 <shapr> I think it is...
19:59:03 <newsham> haskell-cafe doesnt like my questions
19:59:05 <Nafai> shapr: Did you put a link to my blog entry in the Haskell Weekly News?
19:59:14 <shapr> Not me
19:59:21 <Nafai> Someone else must have found it :)
19:59:27 <shapr> Probably google's blog search.
19:59:45 <sorear> shapr: I don't want to flood haskell-cafe@.  what subset of "release" should I use for minor/unpolished changes?
19:59:47 <CosmicRay> oh, it's in darcs already.
20:00:42 <shapr> sorear: I'd suggest announcing a project once on -cafe with an url to the project page, and then pushing changes and making sure the project page shows one of dons' darcs-graphs so that people will see changes.
20:01:04 <kyevan> CosmicRay: darcs get http://darcs.haskell.org/yaht
20:01:07 <lambdabot> Title: Index of /yaht
20:01:31 <dons> CosmicRay: i just added a 'Incoming news' feed that pulls reddit's haskell items
20:01:34 <dons> whaddya think?
20:01:37 <kyevan> lambdabot: Shush, you. You're worse than Ami's responding to every ).
20:02:35 <CosmicRay> dons: slick
20:03:12 <SamB> dons: oh, also my threaded architecture is intended to allow multiple frontends for my ZMachine interpreter ;-)
20:03:44 <SamB> unfortunately it is very lacking in IO support at the moment
20:04:11 <SamB> though I would vastly appreciate if someone would do something as simple as making the scrollbars scroll
20:04:22 <SamB> when text is added
20:04:40 <CosmicRay> well, time to disappear
20:07:37 <dmead> dons: poke poke
20:08:17 <kyevan> Um, I think I mighta done that wrong.
20:08:23 <dons> dmead: yes?
20:08:38 <dmead> im following your page on how to write a haskell program
20:08:46 <kyevan> I tried to make a local copy of the copy of YAHT in the haskell wikibook... I failed, I think >_<
20:08:56 <dmead> and when i do runhaskell Setup.lhs build
20:09:02 <dmead> it can't find the parsec files
20:09:04 <kyevan> I think I muight have told it to go a little too deap.
20:09:07 <dmead> when ghc can on it's own
20:09:09 <kyevan> Like, all of the internet.
20:09:47 <dmead> how does the depends keyword in a .cabal work
20:09:50 <dmead> just list them?
20:09:54 <dmead> base Parsec?
20:10:47 <dons> dmead: so you need to add parsec to the build-depends: field
20:11:04 <dons> e.g Build-Depends:       base, unix, network, parsec, mtl
20:11:28 <dmead> ah
20:12:31 <sorear> How do I tell cabal which GHC to use?
20:12:57 <sorear> I have devel and 6.6 installed, my prog needs MTL, but I only have MTL for 6.6
20:13:04 <dons> --with-compiler=/my/ghc
20:13:17 <dons> you'll probably need flags for ghc-pkg too
20:13:22 <LoganCapaldo> Is sudo a Monad?
20:13:35 <SamB> heh
20:13:37 <dons> yeah, I reckon :)
20:13:51 <dons> at least, I'd use a monad to model privledge sep in a haskell program
20:13:56 <LoganCapaldo> Haskell is evil. Its making me see Monads everywhere
20:14:09 <SamB> no, Haskell is like a hammer!
20:14:38 <dgriffi3> perhaps it is an evil hammer
20:14:38 <LoganCapaldo> That's what it is! When the only tool you have is Haskell, every thing looks like a Monad
20:14:38 <SamB> except it doesn't cause so much damage when you run around hitting things with it!
20:17:27 <kyevan> Haskell is like a hammer that likes homeing in on my head
20:17:31 <kyevan> anyway, me sleep now
20:17:32 <kyevan> 'night
20:18:33 <dons> ?users
20:18:33 <lambdabot> Maximum users seen in #haskell: 276, currently: 245 (88.8%), active: 31 (12.7%)
20:24:29 <augustss> ?users
20:24:30 <lambdabot> Maximum users seen in #haskell: 276, currently: 243 (88.0%), active: 32 (13.2%)
20:24:55 <dmead> http://taz.cs.wcupa.edu/~dmead/code/prover/
20:25:01 <dmead> darcs get http://taz.cs.wcupa.edu/~dmead/code/prover/
20:25:09 <dmead> can someone try that real quick?
20:25:20 <dons> all behold the new improved Haskell Sequence, http://sequence.complete.org/, now first with haskell news!
20:25:21 <lambdabot> Title: The Haskell Sequence | News about Haskell
20:25:25 <dmead> it works for me, just want to make sure before i wiki it
20:25:34 <dons> (it pulls from more useful feeds now)
20:25:38 <dons> dmead: checking
20:25:59 <dons> Copying patch 1 of 1... done!
20:25:59 <dons> Applying patch 1 of 1... done.
20:25:59 <dons> Finished getting.
20:26:14 <dmead> runhaskell Setup.lhs configure
20:26:16 <dmead> runhaskell Setup.lhs build
20:26:17 <dmead> etc
20:26:20 <dons> yep
20:26:24 <dmead> k cool
20:26:28 <dons> (I would complain if it wasn't that;)
20:26:35 <dmead> k
20:26:51 <dons> ok great, it builds:
20:26:52 <dons> $ /usr/obj/cabal/proverApp/proverApp --help
20:26:53 <dons> proverApp: (line 1, column 1):
20:26:53 <dons> unexpected "-"
20:26:53 <dons> expecting expression
20:26:57 <dons> maybe add some GetOpts ;)
20:29:23 <LoganCapaldo> Is there a Parsec manual? Something more referency than a tutorial, but less referency than a Haddock listing?
20:29:44 <SamB> LoganCapaldo: the source!
20:29:55 <LoganCapaldo> lol
20:30:07 <SamB> I'm at least 60% serious!
20:30:07 <LoganCapaldo> I think that's even more referency than the api listing :)
20:30:19 <SamB> it is more readable much of the time!
20:30:20 <LoganCapaldo> It's that nice huh?
20:30:31 <dons> LoganCapaldo: the parsec home page
20:30:32 <dons> ?where parsec
20:30:33 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
20:30:34 <SamB> well, for the combinators and stuff it is nice to know what it does
20:30:40 <LoganCapaldo> I'll go check it out then
20:30:43 <SamB> dons: isn't that the tutorial to which he refers?
20:30:49 <SamB> or is there another one somewhere?
20:31:03 <dons> maybe
20:31:48 <LoganCapaldo> dons: well thanks
20:32:56 <dmead> http://haskell.org/haskellwiki/Libraries_and_tools/Theorem_provers
20:32:59 <dmead> added my prover
20:32:59 <lambdabot> Title: Libraries and tools/Theorem provers - HaskellWiki, http://tinyurl.com/kfmhl
20:33:29 <dmead> is it kosher to call it dan's sexy time prover?
20:33:31 <dmead> =p
20:34:04 <dons> dmead++
20:34:12 <LoganCapaldo> By tutorial I was actually using scheme in 48 hours
20:34:44 <dons> this guy's looking for advice: http://jpmoresmau.blogspot.com/2006/12/adventures-in-haskell-parsing-game.html
20:34:46 <lambdabot> Title: JP Moresmau's Programming Blog: Adventures in Haskell: parsing the game world, http://tinyurl.com/szyzn
20:36:52 <hyrax42> take the 30 mins to learn some parsec... I think that's decent advice
20:37:16 <dmead> what the hell
20:37:19 <dmead> i posted there
20:37:25 <dmead> and it calls me dan..
20:37:35 <dmead> i don't remember registering there...
20:37:35 <hyrax42> everyone related to hasekll is called don
20:37:41 <monochrom> On the haddock doc of Parsec, there is a link to some other web page early on.
20:38:02 <monochrom> Follow that link. It will bring you to the home page of Parsec proper.
20:38:03 <SamB> dons: okay, so I added my ZMachine interpreter. and I pushed another patch to the repo, but I think Lists and Lists still crashes
20:38:12 <monochrom> The home page of Parsec has the proper manual.
20:38:22 <dmead> it's very dated
20:38:50 <SamB> hyrax42: you mean Simon?
20:39:27 <lispy> dmead: nope
20:39:34 <lispy> dmead: what did you need? ;)
20:39:39 <dmead> sup?
20:39:46 * LoganCapaldo is reading
20:40:00 <lispy> dmead: just running out of time for my term project  :)
20:40:14 <dmead> me too ;o
20:40:32 <monochrom> setTitle("it's prover time!!");  hahahaha
20:40:46 <dmead> =p
20:40:51 <lispy> dmead: but i'm happy because i just got the gnuplot feature working
20:41:05 <dmead> eh?
20:41:38 <lispy> dmead: my project runs darcs, imitates a user and then creates a chart with data like how much memory darcs is using
20:41:40 <dmead> sorry i forget what your working on
20:41:44 <dmead> ahh
20:42:19 <lispy> it's been at least a year since i used gnuplot so i'm having to learn it all over again
20:42:26 <dmead> monochrom: you can find test variables in Cnf.hs
20:42:29 <dmead> ah
20:43:13 <lispy> ah, cool png is a supported terminal type
20:43:18 <lispy> that should work well for this
20:43:41 <monochrom> I advise you to take a look at Prufrock.  The main idea I want to point out is its use of Haskell type classes for logics, i.e., axioms and primitive inference rules are methods of a type class.  So you can do two things: (a) different instances of the same type class correspond to different logics that share the same essence; (b) logic transformer anyone?
20:44:21 <dmead> hmm
20:44:48 <dmead> i've got something similar
20:44:58 <dmead> err
20:45:00 <dmead> sorta
20:45:01 <dmead> ;o
20:45:43 <lispy> aquaterm only seems to do one graph at a time :(
20:45:54 <dmead> ;/
20:45:59 <dmead> thread it!
20:46:26 <lispy> oh, i can just number the terminals
20:50:09 <sorear> I've got my recursive ftp-upload script working, and i've sucessfully uploaded my entire darcs-repo for the unifier:  darcs get http://members.cox.net/fixtypes
20:50:16 <sorear> I've got my recursive ftp-upload script working, and i've sucessfully uploaded my entire darcs-repo for the unifier:  darcs get http://members.cox.net/stefanor/fixtypes
20:50:26 <sorear> bit of a difference ;)
20:51:06 <sorear> so, where else to announce, and how soon?
20:53:06 <dons> just drop a note on haskell-cafe@haskell.org then
20:53:45 <sorear> what kind of note ?
20:53:54 <dmead> how do you subsribe to that
20:53:59 <dmead> is there  page or some junk?
20:54:05 <sorear> (I get the feeling I completely botched the RIO announce)
20:54:20 <sorear> haskell.org/listinfo/haskell-cafe IIRC
20:55:17 <dons> sorear: nah, it wasn't too bad.
20:55:28 <dons> ?where mailinglist
20:55:28 <lambdabot> http://haskell.org/haskellwiki/Mailing_lists
20:55:29 <lispy> RIO announce?
20:55:35 <lispy> man, i really need to get on haskell@
20:55:39 <dons> uh hu
20:55:51 <lispy> dons: hush you! ;)
20:56:06 <dons> you miss out on my personally addressed HWN items, delivered to your door
20:56:08 <sorear> RIO is an IO monad with extensible restrictions.  It subsumes ST
20:56:14 <dmead> http://haskell.org/mailman/listinfo/haskell-cafe
20:56:15 <lambdabot> Title: Haskell-Cafe Info Page
20:56:43 <dons> sorear: note http://programming.reddit.com/info/tn1f/comments
20:56:44 <lambdabot> Title: Haskell Weekly News: Visual Haskell, the community report and a restricted IO mo ...
20:58:19 <sorear> http://members.cox.net/stefanor/RIO-0.1-haddock
20:58:28 * sorear feels a little better
20:59:46 * mgsloan hates that Visual (insert lang name here) means OOP
21:00:25 <Pseudonym> Most people who use terms like "OOP" have never used Smalltalk or Erlang.
21:00:28 <Pseudonym> Or even Eiffel.
21:00:31 <mgsloan> not that this means that, just thats what the name brought up
21:00:33 <mgsloan> heh, yeah
21:00:51 <mgsloan> my fav 3d modeller is implemented in erlang
21:01:00 <Pseudonym> Mine isn't.
21:01:06 <lispy> hmm...does mailman have a nice way to sign up with more than one email address?
21:01:28 <lispy> i have two that i want to register with, but the way i do it now is to sign up twice and set one to not deliver
21:01:58 <lispy> the only reason i ask is because mail man only sent me an email for one of my requests to sign up not both
21:02:26 <mgsloan> Pseudonym: what's yours then?
21:02:35 <mgsloan> actually, nevermind
21:02:38 <Pseudonym> Maya.
21:02:41 <mgsloan> my fav modeller is sketchup now
21:02:42 <Pseudonym> I like Maya.
21:02:43 <mgsloan> ah
21:02:51 <Pseudonym> I once got paid to write plugins for it.
21:02:57 <mgsloan> nice
21:02:57 <Pseudonym> It's very, very nice.
21:03:05 <mgsloan> i've never used most of the $$$ ones
21:05:57 <lispy> hmm...should be all fixed up now
21:06:05 <lispy> guess i was just impatient
21:06:20 <dmead> hmm
21:06:26 * dmead needs a cool name for his prover
21:09:05 <dons> ?freshname
21:09:05 <lambdabot> Habm
21:09:09 <dons> how's that?
21:09:13 <dons> or maybe
21:09:16 <dons> ?freshname
21:09:17 <lambdabot> Habn
21:09:19 <dons> ooh nice!
21:09:23 <dons> ?freshname
21:09:23 <lambdabot> Habo
21:09:26 <dons> also great!
21:09:27 <dmead> lol
21:09:27 <chessguy> lol
21:09:40 <dmead> ?freshname
21:09:40 <lambdabot> Habp
21:09:45 <dmead> ?freshname
21:09:45 <lambdabot> Habq
21:09:45 <chessguy> what is that for?
21:09:50 <dmead> ?freshname
21:09:51 <lambdabot> Habr
21:09:54 <dons> naming haskell projects
21:09:59 <chessguy> oh, lol
21:10:00 <dmead> that is lol
21:10:12 <Pseudonym> ?. elite freshname
21:10:13 <lambdabot> HabT
21:10:16 <Pseudonym> ?. elite freshname
21:10:16 <lambdabot> |-|aBU
21:10:18 <dons> ah cool
21:10:23 <dons> Pseudonym++ nice idea
21:10:36 <Pseudonym> They all start with H, right?
21:10:43 <dons> with Ha, I think
21:10:51 <dmead> ?. elite freshname
21:10:52 <lambdabot> H4b\/
21:10:53 <bd_> dons: Will it go to Hb after 26^2 automagically?
21:11:08 <Pseudonym> Only one way to find out.
21:11:11 <bd_> XD
21:11:15 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Fresh.hs
21:11:24 <Pseudonym> Yup, look at the source.
21:12:05 <dmead> ?. elite freshname
21:12:05 <lambdabot> |-|ABW
21:12:07 <dmead> ?. elite freshname
21:12:07 <lambdabot> HABx
21:12:18 <bd_> ic
21:12:48 <dmead> ?. elite freshname
21:12:49 <chessguy> ?. freshname freshname
21:12:49 <lambdabot> |-|a8y
21:12:49 <lambdabot> Haca
21:12:51 <dmead> ?. elite freshname
21:12:51 <lambdabot> |-|4(8
21:13:32 <dmead> ?. elite freshname
21:13:33 <lambdabot> hacc
21:13:42 <dmead> ?. elite freshname
21:13:42 <lambdabot> HA(D
21:13:47 <dmead> ?. elite freshname
21:13:47 <lambdabot> h4(3
21:14:01 <dmead> ?. elite freshname
21:14:02 <lambdabot> H4CF
21:14:03 <dmead> ?. elite freshname
21:14:03 <lambdabot> |-|4c9
21:14:05 <dmead> ?. elite freshname
21:14:05 <lambdabot> |-|ACh
21:14:07 <dmead> ?. elite freshname
21:14:07 <lambdabot> hAcI
21:14:07 <dons> at some point /me waves /msg lambdabot @freshname at dmead...
21:14:26 <dmead> hehehe
21:14:31 <sorear> Shouldn't freshname just use markov chains to eliminate the duds?
21:14:37 <dmead> yea
21:14:43 <dons> sorear: nice idea. submit a patch!
21:14:58 <Pseudonym> Actually, building a statistical model of existing Haskell project names isn't a dumb idea.
21:15:06 <dons> yeah
21:15:08 <chessguy> duds?
21:15:13 <Pseudonym> !./
21:15:16 <dmead> yea
21:15:18 <Pseudonym> Errr...
21:15:35 <sorear> would you name a program |-|4c9?
21:15:45 <chessguy> oh
21:15:49 <Pseudonym> WHENHECAREFROMTHEENROUPOULTEDMANORAISEDTHEINEDTHESEBOBCRATCHITHADPJACKCHILDALREADMEANTOFBERANHISGLOVETHOUGHTANDHELADSWHENTHISISTCOATLONELSBUTLUGOANDBENEZERFULLYSOMEGROUNDTHEISATISFACETMADEWHATHASGMEHE
21:15:52 <sorear> sounds too much like _|_ for me
21:16:02 <Pseudonym> That's kind of a long name for a project, though.
21:16:13 <Pseudonym> It's automatically generated from "A Christmas Carol".
21:16:21 <dmead> hey
21:16:25 <dmead> how about just
21:16:25 <sorear> don't name your askell program _|_
21:16:26 <dmead> Halp
21:16:31 <dmead> haskell logic prover
21:16:40 <Pseudonym> Hence you can see "BOBCRATCH" and "BENEZER".
21:18:45 <lispy> hehe
21:18:52 <lispy> Pseudonym: did you write the program that did the generating?
21:18:58 <Pseudonym> Yup.
21:18:58 <lispy> sounds like something you'd do
21:19:14 <Pseudonym> I'm not using it to generate travesties of literature, fun though that is.
21:19:18 <lispy> that's pretty cool, so it was markov based generation?
21:19:38 <Pseudonym> Yes.  It's an arbitrary order Markov model.
21:19:40 <lispy> i'd like to get a handle on that at some point
21:19:55 <sorear> on dons' suggestion, I've announced to haskell-cafe@
21:20:10 <Pseudonym> Great idea.
21:20:16 <lispy> okay, i'm still trying to learn how best to make use of traits in scala and i just found a very cool use
21:20:19 * sorear once implemented a PPM compressor in haskell
21:20:22 * mgsloan is still looking for a haskell data structure to store decent order markov chains compactly and load them fast, etc, for a lambdabot ai plugin
21:20:37 <Pseudonym> Anyway, it's like a finite automaton.
21:20:44 <mgsloan> and, be able to feed it the full logs
21:20:56 <Pseudonym> Only the transitions have frequency counts.
21:20:58 <sorear> it took an hour to write, was one fourth as effective as gzip, and (compiled +O) ran at TWO BITS PER SECONDD.
21:21:00 <lispy> i have this GnuPlot class which runs gnuplot and it has to generate a script file to feed to gnuplot.  I use traits to control the output type.  So you do something like, val gp = new GnuPlot with AquaTerm
21:21:02 <mgsloan> probably trim the infrequent things
21:21:09 <lispy> of if you want postscript you just do new GnuPlot with PostScriptTerm
21:21:12 <dons> mgsloan: surely there are known structures for that?
21:21:15 <dons> sorear: scary
21:21:23 <sorear> the speed?
21:21:25 <lispy> adding new terms just means writing a 4 line class
21:21:28 <mgsloan> dons - probably
21:21:34 <dons> sorear: was it implemented in the type system? ;)
21:21:52 <sorear> Nope.  nested list processing.
21:22:17 <sorear> That and a variable order model which forced it to look at every character of every match.
21:22:38 <sorear> on the plus side, it was reversible
21:22:48 <sorear> unzip . zip = id
21:22:57 <sorear> always a plus with compressors :)
21:24:07 <mgsloan> i haven't really been working on it that much though
21:24:19 <newsham> ?pl \x xs -> xs ++ [x]
21:24:20 <lambdabot> flip (++) . return
21:25:38 <dons> ?unpl flip (++) . return
21:25:39 <lambdabot> (\ f c -> c ++ (return f))
21:25:40 <dons> too hard
21:25:46 <dons> ah, not too bad actually
21:26:38 <mgsloan> my next haskell project is probably going to be a simple 2d geometry library (nothing insane math people would want to do - my matrices are 3x2, my vectors have 2 elements).  That'll lead into a sort of haskell canvas system using cairo/the cairo wrapper for rendering, and finally, a graphical programming language
21:27:31 <mgsloan> though there is lots of pretty intense math to do with 2d cartesian geometry, once you add curves
21:27:47 <sorear> There is a huge need for a standard computational geometry library in haskell.
21:28:12 <mgsloan> (s-basis representation, using clothoids segments to construct paths)
21:28:33 <mgsloan> yeah, seems like it
21:29:25 <mgsloan> you can just ignore the last thing in that parenthesization, i think that might be someone's phd thesis
21:31:09 <mgsloan> the problem with standard libs is that unless you narrow the scope sufficiently its hard to do things nicely.  You can do things in very general fashion, but unless executed very cleverly, it'll be ok for lots of things, but not nice for anyone
21:31:36 <mgsloan> or maybe that's just in C++ :P
21:31:52 <SamB_XP> mgsloan: I'm sure it isn't just C++
21:31:56 <sorear> General is better than nothing.  Try programming using no prelude functions.
21:32:12 <mgsloan> of course
21:32:26 <mgsloan> that's why i said the general lib can be ok for lots of things, but its not fantastic
21:32:43 <sorear> Also try writing a Data.List.sort, from scratch, without reading the libs, as good as the standard one.
21:32:44 <mgsloan> still, at least standard vectors and matrices and such would be cool
21:32:52 <sorear> yes.
21:32:59 <mgsloan> hah, well, certainly not as fast
21:33:01 <SamB_XP> well, [] is way more convenient than anything custom will be for *most* things
21:33:11 <mgsloan> ye
21:33:25 <sorear> Unfortunately we need value parameterized types for a decent vector lib.
21:33:29 <mgsloan> but there's lots of functions, operators associated with the math versions
21:33:32 <sorear> Vector Two - ?!
21:33:39 <mgsloan> heh
21:34:07 <mgsloan> yeah, that's one of the reasons i was really interested in dependant types a week or two ago
21:34:10 <SamB_XP> someone was working on a more-practical-than-most type arithmatic library...
21:34:11 <sorear> I've got a chunk of computational-geometry lib sitting on my hard drive
21:34:14 <mgsloan> it's really nice for geom libs
21:34:33 <mgsloan> sorear - sweet
21:34:34 <sorear> I can't find a decent typeclass abstraction for regions
21:35:13 <mgsloan> within Point -> Bool not good enough for yah? :)
21:35:16 <sorear> rectangles, polygons, convex polygons, statically restricted polygons, closed splines -- they're all lattices
21:35:29 <mgsloan> I mean within Region -> Point -> Bool
21:35:40 <lispy> there was that one representation where a region is a function
21:35:47 <lispy> a member ship function
21:35:50 <lispy> that one was pretty cool
21:35:52 <SamB_XP> oooh!
21:35:53 <SamB_XP> ships!
21:35:53 <lispy> hard to find the bounds though :(
21:35:58 <SamB_XP> we could play battleship!
21:36:04 <sieni> a member ship?
21:36:05 <lispy> er...membership ;)
21:36:15 <lispy> i have a funny thing which splitting compound words up
21:36:20 <lispy> er with
21:36:39 <sorear> statically-restricted polygons are fun.  Take a polygon and make the angles of the edges statically fixed.  E.g. axis aligned rectangles.
21:36:55 <mgsloan> ah yeah
21:37:06 <sorear> SRP's can, just like rectangles, be very efficiently intersected.
21:37:07 <mgsloan> nice for optimization for sure
21:37:19 <sorear> they are my (re)invention
21:37:24 <mgsloan> heh
21:37:33 <sorear> but to implement them I'll need type level reals
21:37:43 <sorear> now *that* will be fun...
21:37:48 <mgsloan> hehe
21:38:08 <sorear> (I'm very good at reinventing things, dunno why...)
21:38:46 <SamB_XP> that sounds like overdoing it!
21:38:59 <mgsloan> I was working on a Real type that just accumalated a list of operations and performed optimizations on it
21:39:17 <mgsloan> minimized the operation tree
21:39:56 <SamB_XP> *someone* apparantly figured out how to turn functions into data with TH -- even compiled ones!
21:40:30 <mgsloan> then when you convert it to a different type, it gets it as close as the type can go.  Problem is I'm not sure if infinite strings can be easily produced by this
21:40:42 <mgsloan> Samb_Xp - olego meter rising
21:40:53 * sorear encourages people to check out the infinite-type unifier
21:41:15 * SamB_XP discourages people to check in ...
21:41:39 <SamB_XP> ...the finite-type dissenter
21:41:45 * Botje encourages people to check under the mattress
21:41:53 * SamB_XP goes to bed
21:42:28 * mgsloan also wants an instance of Num, Fractional, etc which stores range.  Its probably been done.  Oh, and units.  Like :t 5m / 10s === Speed
21:43:09 <sorear> such a type exists, dunno if it can reasonably be made a Num though
21:43:36 <sorear> Length and Time must be the same to allow (*) but different to forbid (+)
21:43:56 <mgsloan> well, its like storing 10+-5 - a range.  any range over rationals can be expressed like that
21:43:57 <lispy> someone had an instance of Num which supported ranges
21:44:23 <lispy> and i had an instance of Num which were really excel formulas
21:44:24 <mgsloan> so, multiplying by two would yield 20+-10
21:45:23 <mgsloan> yeah, best stored as a center point and +/- value(s)
21:46:03 <mgsloan> gets a bit tricky with some ops, you'll start having to use some Unions of ranges
21:46:40 <mgsloan> so really, just a num instance that handles precision management
21:54:56 <ptolomy> I get a perverse pleasure from permutation sorting short lists... "That's right fan... spin.. spin!"
21:58:48 <ptolomy> "head . filter pred" should have the same performance as "head . dropWhile pred" thanks to laziness, yes?
21:59:01 <monochrom> Someone did interval arithmetic.  You can look up the algorithms and cook a Num instance etc.
21:59:16 <mgsloan> yep
21:59:21 <sorear> ptolomy: no, those are different actions..
21:59:48 <sorear> head . filter pred  vs.  head . dropWhile (not pred)   should be the same however
21:59:55 <ptolomy> sorear: Oh yeah. I meant the 'not'.
22:00:06 <ptolomy> Cool.
22:00:09 * ptolomy loves laziness.
22:00:36 <sorear> laziness is cool
22:05:01 <sorear> good night.
22:46:20 <lispy> mgsloan: a type class or Num instances that did scientific notation (managing the sig digs) would be really cool
22:46:34 <lispy> mgsloan: i could see that being nice for certain types of scientific computations
22:48:31 <dons> mm. 'looking for functional programmers' (Portland) http://seeker.dice.com/jobsearch/servlet/JobSearch?op=101&dockey=xml/5/e/5e36b457ce16106c02ced0981fb6878f@endecaindex&source=18
22:48:34 <lambdabot> Title: Find Software Developer jobs at Dice.com, http://tinyurl.com/cza2x
22:48:45 <dons> We're looking for more developers, especially ones with functional
22:48:46 <dons>                           or dynamic object-oriented development experience"
22:48:55 * lispy reads up
22:48:57 <dons> ... "Haskell, Ruby, Unlambda"
22:48:59 <dons> !!
22:49:00 <lispy> that's in my neighborhood
22:49:17 <lispy> hm...bad tinyurl
22:49:25 <dons> yeah, weird
22:49:50 <lispy> they use funky url chars probably...that regexp in the tinyurl module is known to be busted
22:49:58 <dons> ah
22:50:32 <leather> That sounds like a list of known languages thrown together.
22:50:42 <leather> I doubt they actually write anything in Haskell.
22:50:51 <dons> yeah
22:50:58 <dons> (known edge languages?)
22:51:02 <dons> the unambda is just weird..
22:51:18 <leather> Yeah... I was thinking that, too.
22:51:36 <lispy> i thnk the unlambda was a joke
22:51:51 <dons> yeah :) someone with a bit of lisp experience making a secret joke ?
22:52:02 <lispy> because now if someone send in their resume and says, "I have 4 years unlambda experience" they will likely filter that out
22:52:32 <lispy> i'd say their thing was at least drafted by a technical person
22:52:34 <leather> Ha! :)
22:52:39 <mgsloan> lispy - yeah, I'm thinking haskell could be good for science/engineering, if the stuff was there
22:52:50 <lispy> mgsloan: ask droundy!
22:53:09 <mgsloan> then again, i'm not really involved in either field
22:53:12 <lispy> only computation physicist i've met that wants to scrap his C++ for Haskell
22:53:23 <mgsloan> heh
22:53:36 <leather> "We keep our source code base well factored, and filled with unit tests."
22:53:40 <leather> Hmm...
22:53:46 <mgsloan> yeah, these people shouldn't have to wrestle with C++ to get their stuff working
22:53:51 <leather> They must not be selling anything, then.
22:53:51 <sieni> computational that uses c++ instead of fortran iv?!?!
22:54:20 <lispy> dons: anyway, it sounds like a nice place to work...if i were done with my masters it would be on my list right below Galois
22:54:49 <leather> I bookmarked another place not too long ago...
22:55:02 <lispy> sieni: yeah, think he sometimes has to use fortran too
22:55:36 <lispy> sieni: but i get the impression he prefers Haskel followed by C++ when the evil is necessary
22:55:45 <leather> Ah, yes: http://www.bluespec.com/
22:55:46 <lambdabot> Title: Bluespec
22:56:20 <leather> Apparently, they write their software in Haskell.
22:56:28 <lispy> cool
22:56:34 <lispy> but who wants to live in MA?
22:56:36 <leather> Though their website doesn't go into that.
22:56:39 <leather> ???
22:56:51 <leather> What's wrong with Massachusetts?
22:57:05 <emu> i wouldn't mind living in Boston
22:57:06 <sieni> It's in the States?
22:57:08 * sieni ducks
22:57:11 <mgsloan> heh, filled with unit tests
22:57:12 <mgsloan> hah
22:57:16 <leather> emu: Exactly. :)
22:57:19 <lispy> leather: to be fair, i've never been their
22:57:21 <lispy> er there8
22:57:50 <leather> Boston is a very cool city, methinks.
22:58:16 <leather> I like the atmosphere from to the overabudance of universities.
22:58:42 <leather> Plus it has culture, since it's been around for so long.
22:58:55 <leather> There aren't many American cities you can say that about.
22:59:18 <lispy> very true
22:59:30 <leather> Err, "from the overabundance"
23:00:21 <lispy> i would guess that Corvallis is one of the oldest cities in oregon and it's founded in 1857 http://en.wikipedia.org/wiki/Corvallis,_Oregon
23:01:49 <lispy> it's a neat, but small, town
23:01:53 <leather> Cool. I'd like to go to Oregon sometime. I've heard good things.
23:02:11 <lispy> yeah, the west side of oregon is a love it or hate it place
23:02:19 <lispy> and the people that live here tend to love it
23:02:54 <lispy> but if i get any more OT i'll have to move to #haskell-blah :)
23:03:02 <dmead> =p
23:18:41 <dons> ?yow
23:18:41 <lambdabot> So this is what it feels like to be potato salad
23:20:27 <mgsloan> lol
23:23:14 <dmead> ?yow
23:23:14 <lambdabot> Now I am depressed ...
23:23:17 <dmead> ?yow
23:23:18 <lambdabot> Barbie says, Take quaaludes in gin and go to a disco right away!
23:23:18 <lambdabot> But Ken says, WOO-WOO!!  No credit at "Mr. Liquor"!!
23:23:22 <dmead> ?yow
23:23:22 <lambdabot> Yow!  Are you the self-frying president?
23:23:26 <dmead> :>
23:23:33 <Korollary> Man, I've never done "dynamic" object oriented programming.
23:23:51 <dmead> so you've never used c++?
23:23:51 <dmead> o0
23:24:00 <Korollary> What's so "dynamic" about that?
23:24:16 <dmead> polymorphism and coersion
23:24:19 <dmead> o0
23:24:31 <Korollary> Nah. I don't think that's what they mean.
23:24:38 <Korollary> It's *dynamic* dude.
23:24:44 <dmead> o right
23:24:48 <dmead> *dynamic*
23:25:24 <Korollary> I mean, in this sense: http://lambda-the-ultimate.org/node/1562#comment-18623
23:25:26 <lambdabot> Title: HLVM - High Level Virtual Machine toolkit for dynamic languages | Lambda the Ult ...
23:26:45 <dmead> http://en.wikipedia.org/wiki/Dynamic_programming
23:26:46 <lambdabot> Title: Dynamic programming - Wikipedia, the free encyclopedia
23:33:04 <mgsloan> oh, man, neverrealized that ambiguity
23:33:22 <dmead> :o
23:33:31 <mgsloan> (with dynamic typing)
23:33:42 <dmead> yea
23:33:54 <dmead> dynamic programming and dynamic typing are rly different
23:33:59 <mgsloan> yeah, very
23:34:19 <dmead> and i still don't know what the difference is between strict strong weak and dynamic typing
23:34:20 <dmead> ;o
23:34:23 <dmead> well
23:34:26 <dmead> strict and strong
23:34:28 <dmead> mostly
23:34:58 <mgsloan> i used to know the distinction, but i forgot
23:37:15 <mgsloan> err, those aren't really comparable.  Its strong<->weak, static<->dynamic, safe<->unsafe. dunno what strict is
23:37:25 <mgsloan> maybe its that they don't change types
23:38:14 <dmead> yea
23:38:26 <dmead> i think it has to do with automatic coersion
23:38:38 <dmead> and weather it's allowed at all
23:38:40 <mgsloan> oh yeah that
23:39:07 <dmead> man, there is some stupid questions being asked in #java
23:39:09 <mgsloan> I think its a substitute for more allowing type constraints on functions
23:39:25 <mgsloan> so, i think its good when your type system sucks :)
23:39:34 <mgsloan> bad when your type system rox
23:39:40 <dmead> hmm
23:39:41 <dmead> ehh
23:39:42 <dmead> yea
23:39:43 <dmead> i guess
23:39:58 <dmead> seems that strong typing like in java or haskell lets you get stuff done faster
23:40:00 <mgsloan> good, mostly in the one coersion of number -> string
23:40:04 <mgsloan> other wise its mostly nasty
23:40:15 <mgsloan> hah, java
23:40:27 <dmead> java just needs to go away though
23:40:31 <dmead> so does C#
23:40:37 <mgsloan> haskell, certainly, it has a nice type system
23:40:55 <mgsloan> java, you don't get things done faster because of the no coercion thing
23:41:17 <mgsloan> C# is ok, as far as mainstream langs
23:41:43 <dmead> isn't C# nearly the same as java?
23:45:24 <Korollary> no
23:47:59 <lispy> someone just released HOgg, i really hope he/she wrote a script to call ?freshname all those times...
23:48:21 <dmead> haha
23:53:06 <lispy> ?freshname
23:53:07 <lambdabot> Hadi
23:53:39 <lispy> > foldl1 (+) . map ord "Hadi"
23:53:40 <lambdabot>    Expecting a function type, but found `[b]'
23:53:40 <lambdabot>    Expected type: a1 -> [a...
23:53:46 <lispy> > foldl1 (+) (map ord "Hadi")
23:53:47 <lambdabot>  374
23:54:25 <zptao> ?freshname
23:54:25 <lambdabot> Hadj
23:55:03 <lispy> > (ord 'o') - (ord 'a')
23:55:04 <lambdabot>  14
