00:01:33 <greentea> i know this is a stupid question, but "AttValue [Either String Reference]	" means that an AttValue is a list of items of either type String or Reference, right?
00:02:10 <dons> yeah
00:02:36 <dons> :t Just [Right 1, Left "foo", Right 8] -- a bit like this
00:02:37 <greentea> Hmm.
00:02:38 <lambdabot> forall b. (Num b) => Maybe [Either [Char] b]
00:02:52 <dons> :t Just [Right 1, Left "foo", Right (8::Int)]
00:02:53 <lambdabot> Maybe [Either [Char] Int]
00:05:07 <greentea> Yeah.
00:06:50 <greentea> GHCi is telling me that it can't match 'AttrValue' against '[a]'.
00:08:07 <dons> AttValue or AttrValue? and are you missing the constructor AttrValue in front of the list?
00:08:34 <greentea> Er, AttValue.
00:08:37 <greentea> And yes.
00:08:50 <greentea> :-|
00:09:36 <dons> ?paste then?
00:09:37 <lambdabot> http://paste.lisp.org/new/haskell
00:10:22 <greentea> Getting a 502.
00:12:59 <dons> ?where rafb-paste
00:13:00 <lambdabot> I know nothing about rafb-paste.
00:13:11 <dons> ?where paste-rafb
00:13:11 <lambdabot> http://rafb.net/paste
00:13:13 <kep> 1/0
00:13:18 <dons> > 1/0
00:13:20 <lambdabot>  Infinity
00:13:29 <kep> >(1/0 )/(1/0)
00:13:30 <kep> :)
00:13:38 <kep> > (1/0 )/(1/0)
00:13:39 <lambdabot>  NaN
00:13:51 <mgsloan> methinks lambdabot could do with a similarity matcher for ?where s
00:14:06 <dons> mgsloan: a spell matcher? good idea
00:14:31 <mgsloan> yeah, i think we have something similar for the actual commands
00:14:41 <mgsloan> ?vixe foo
00:14:42 <lambdabot> Maybe you meant: vixen vixen-off vixen-on
00:14:47 <mgsloan> yep
00:15:02 <greentea> http://rafb.net/paste/results/zVZmAw20.html
00:18:59 <dons> greentea: missing Right or Left constructors in the list arg ? ["http://etherx.jabberx.org/streams"]
00:19:18 <dons> if thta's really an [Either .. ...] then that string needs a Right or a Left
00:19:43 <greentea> AttValue :: [Either String Reference] -> AttValue
00:20:03 <greentea> So i need to use a Left constructor in front of the string?
00:20:34 <dons> yep
00:20:45 <greentea> Ah, thanks! Crikey.
00:20:45 <dons> :t "foo"
00:20:46 <lambdabot> [Char]
00:20:48 <dons> :t Right "foo"
00:20:49 <lambdabot> forall a. Either a [Char]
00:21:04 <greentea> Oh, now i see what you were getting at before.
00:21:48 <greentea> But this does seem an overly complicated way of creating an XML element . . . .
00:21:56 <dons> it does, doesn't it.
00:22:05 <dons> i guess they're trying to be thorough in the error handling?
00:22:07 <greentea> But then, XML revels in being overly complicated. :-)
00:22:19 <mgsloan> yes, it does...
00:22:27 <greentea> Hm, perhaps.
00:23:01 <mgsloan> even has an API standard I believe, i wonder if haskell implemented it.  It's pretty crappy to work with
00:24:03 <greentea> msgloan: You mean the DOM?
00:28:34 <mgsloan> yeah
00:30:05 <mgsloan> only upside is that once you learn it you know basically how to use all the conforming xml libs
00:30:58 <greentea> Well, not knowing how to actually /write/ Haskell is far more of a barrier for me at this point. :-)
00:31:24 <greentea> i'm at the stage where code makes sense to me, but i struggle to write it off the top of my head.
00:32:50 <greentea> Although on the plus side, at least i'm not as bothered by "This is how i'd do this in Perl" as i used to be. :-)
00:34:49 <mgsloan> ah, yeah, I'm about at that stage
00:34:54 <mgsloan> 100 lines takes 6 hours :P
00:35:10 <mgsloan> but its a beautiful 100 lines, imho
00:35:13 <greentea> Heh, i'm more like at /10/ lines takes 6 hours. :-)
00:35:28 <greentea> Oh yes, it's often beautiful.
00:36:06 <greentea> Although there was an interesting study in contrasts on haskell-cafe@ recently.
00:36:10 <mgsloan> most of the reason it takes me that long is I'm trying very hard to express things concisely, clearly, and correctly
00:37:26 <greentea> When oleg produced a beautiful way of getting a sublist that was (imho) far more elegant and understandable than the other proposed solution.
00:37:53 <greentea> Heh, yes, i must say, i'm a bit afraid of doing things the wrong (translation: overly-imperative) way. :-)
00:38:48 <greentea> Another question:
00:39:21 <mgsloan> yeah, the overly-imperative thing is something i have to strive against
00:39:45 <greentea> Since the recvFrom function returns IO String, will i need to lift the HaXml function that converts strings to an XML structure into the IO monad?
00:39:46 <mgsloan> another thing is to use prelude functions more - sometimes i'll accidently inline prelude functions manualy
00:39:54 <greentea> *nod*
00:40:12 <eviltwin_b> yay, sunrise-sunset calculator works, at least as well as it did in perl. unfortunately that proves the 2-3 minute discrepancies weren't perl'
00:40:13 <mgsloan> yeah, you'll need to lift it
00:40:15 <eviltwin_b> s fault...
00:40:27 <dons> greentea: you've got all the tuts / docs/ books you need?
00:40:36 <dons> is anything missing that would help, do you think?
00:41:05 <lispy> dons: is the phrase molly dooker still used where you're from?
00:41:10 * mgsloan needs to sign up for the haskell mailinglist(S)
00:42:32 <dons> lispy: strewth, sounds a bit archaic. "left handed" yeah?
00:43:17 <greentea> dons: Heh, is that a trick/rhetorical question?
00:43:21 <lispy> dons: well, technically it means woman handed, but yeah this book i'm reading says it refers to lefties
00:43:56 <leather> http://www.phrases.org.uk/bulletin_board/12/messages/405.html
00:43:59 <lambdabot> Title: Re: mollyduker, http://tinyurl.com/ugaq6
00:44:12 <lispy> dons: it's an oldish book...looks like 1977 was the original publish date
00:44:22 <mgsloan> maybe someone named "Molly Duker" was left handed
00:45:07 <lispy> leather: interesting, i see the spelling isn't standardized
00:45:24 <greentea> mgsloan: Thanks. :-)
00:45:42 <dons> "molly" has a meaning along the lines of effeminate or some such, like molly-coddle and so on. i'm sure its either sexist or homophobic, and obsolete.
00:46:01 <leather> lispy: Apparently not.
00:46:22 <leather> dons: Heard the song "Good Golly, Miss Molly"?
00:46:33 <lispy> dons: coddle?
00:46:42 <dons> don't mollycoddle me!
00:47:00 <dons> ?web1913 coddle
00:47:01 <lambdabot> *** "Coddle" web1913 "Webster's Revised Unabridged Dictionary (1913)"
00:47:01 <lambdabot> Coddle \Cod"dle\ (k[o^]d"d'l), v. t. [imp. & p. p. {Coddled}
00:47:01 <lambdabot>   (-d'ld); p. pr. & vb. n. {Coddling} (-dl[i^]ng).] [Cf.
00:47:01 <lambdabot>   {Prov}. E. caddle to coax, spoil, fondle, and {Cade}, a. & v.
00:47:02 <lambdabot>   t.] [Written also {codle}.]
00:47:04 <lambdabot> [11 @more lines]
00:47:09 <lispy> ah, i see
00:47:11 <dons> ?web1913 molly
00:47:13 <lispy> so don't "baby me"?
00:47:13 <lambdabot> *** "Molly" web1913 "Webster's Revised Unabridged Dictionary (1913)"
00:47:14 <lambdabot> Molly \Mol"ly\, n. (Zo["o]l.)
00:47:14 <lambdabot>   Same as {Mollemoke}.
00:47:14 <lambdabot>  
00:47:16 <lambdabot> *** "Molly" web1913 "Webster's Revised Unabridged Dictionary (1913)"
00:47:18 <dons> lispy: right.
00:47:18 <lambdabot> [18 @more lines]
00:47:24 <dons> ?more
00:47:24 <lambdabot> Molly \Mol"ly\, n.
00:47:26 <lambdabot>   A pet or colloquial name for Mary.
00:47:28 <lambdabot>  
00:47:30 <lambdabot>   {Molly cottontail}. (Zo["o]l.) See {Cottontail}.
00:47:32 <lambdabot>  
00:47:34 <lambdabot> [13 @more lines]
00:47:40 <dons> bah
00:48:52 <lispy> this chapter is talking about the roots of the word left
00:49:04 <leather> Sounds sinister...
00:49:13 <lispy> in almost all of the author's examples, left is a bad thing :)
00:49:17 <lispy> leather: exactly
00:49:21 <dons> "molly, used contemptuously from 1754 for "a milksop, an effeminate man""
00:49:37 <lispy> a fancy lad
00:52:53 <dons> its interesting that 'Haskell' isn't mentioned anywhere on darcs.net now.
00:53:27 <dons> nor about building with GHC. I guess that's a good thing.
00:53:50 <leather> I knew I'd heard this story about Good Golly Miss Molly, and I found a comment that agrees with me. See http://www.songmeanings.net/lyric.php?lid=44004 (last one).
00:53:58 <lambdabot> http://tinyurl.com/ybpgq9
00:55:17 <lispy> dons: there have been discussions on darcs-devel about what should and shouldn't be on the main darcs page
00:55:28 <lispy> dons: iirc, quantum mechanics is straight out
00:55:48 <dons> I think its quite reasonable to ditch quantum mechanics and haskell, and thus to 'normalise' darcs
00:55:51 <lispy> dons: but, i don't remember hearing people discussing the issue of mentioning haskell/ghc
00:56:17 <lispy> right and most users just don't need that level of information
00:56:40 <lispy> i mean, svn doesn't advertise that it's in C does it? (or maybe it's C++ i really don't know)
00:56:43 <dons> yep. its just an rcs, stupid. use it!   (and not some research project, or some physics thing, or ...)
00:57:29 <dons> since mentioning haskell is just a distraction
00:57:34 <dons> they're there to find out about darcs
00:57:42 <lispy> yup yup
00:58:05 <dons> i'll be happy when we don't even notice a project is written in haskell ...
00:58:31 <lispy> heh, i've heard similar things about race/gender
00:58:40 <leather> You mean, we won't have any h<name>-d projects?
00:58:58 <dons> ?freshname
00:58:58 <lambdabot> Habj
00:59:04 <dons> no, we have to have those :)
00:59:11 <dons> ?freshname -- this is your new project!
00:59:11 <lambdabot> Habk
00:59:12 <leather> D'oh!
00:59:41 <mgsloan> ?freshname
00:59:41 <lambdabot> Habl
00:59:57 <mgsloan> wow, that's been used alot
01:00:02 <leather> On a different note, I have a question about Data.ByteString...
01:00:12 <dons> do tell?
01:00:23 <leather> Why would one want to use [Word8] instead of [Char]?
01:00:39 <leather> i.e. Straight Data.ByteString instead of Data.ByteString.Char8.
01:00:48 <leather> Or vice versa.
01:00:54 <dons> ah, size. 1 byte v 4, combined with C interopability
01:01:05 <dons> a .Char version is in the works though
01:01:21 <mgsloan> 2 byte Char right?
01:01:33 <dons> > maxBound :: Char
01:01:34 <lambdabot>  '\1114111'
01:01:38 <leather> Char8 is 4 bytes?
01:01:42 <dons> > ord $ maxBound :: Char
01:01:43 <lambdabot>  Couldn't match `Char' against `Int'
01:01:52 <dons> > chr $ maxBound :: Char
01:01:53 <lambdabot>  Exception: Prelude.chr: bad argument
01:02:03 <mgsloan> it's ord
01:02:04 <dons> leather: nope, char8 is an 8 bit character
01:02:09 <dons> i.e. Word8
01:02:34 <dons> this was chosen for Data.ByteString for hysterical reasons, and makes a lot of things easier. of course, we need a Word32 version as well, for unicode
01:02:37 <dons> and utf8 and ...
01:02:45 <leather> Yes, yes. :)
01:02:59 * lispy just referred to himself as lispy in a conversation outside of irc without realizing it....
01:03:16 <dons> better than saying "/me" is real life
01:03:27 <lispy> dons: only marginally :)
01:03:42 <leather> So, if I want to have string constants, do I have to use Data.ByteString.Char8?
01:03:51 <lispy> dons: i'm just glad this person knows me from irc so understood
01:03:57 <leather> I mean, string literals in my code.
01:04:26 <dons> yep, pack "mystring"
01:04:43 <dons> ?type Data.ByteString.Char8.pck
01:04:44 <lambdabot> Not in scope: `Data.ByteString.Char8.pck'
01:04:48 <dons> :t Data.ByteString.Char8.pack
01:04:50 <lambdabot> String -> Data.ByteString.Base.ByteString
01:05:22 <lispy> any word from lennart lately about making that more transparent to the programmer?
01:06:06 <dons> he's submitted a patch to ghc
01:06:24 <leather> So, I guess my original question was incorrect.
01:06:34 <leather> If we generally use string literals in code at some point, why use Data.ByteString?
01:06:48 <dons> they're much faster. much much faster
01:07:07 <dons> Data.ByteString and Data.ByteString.Char8 are the same type underneath
01:07:11 <leather> So, I should convert a literal to [Word8] and then use it?
01:07:11 <w-ber> Haha. I have an algorithm here that's polynomial on average but potentially O(2^(2^n)). For most data, the run time is around a second. Last night I fed in different kind of data and it didn't finish until eight hours later.
01:07:24 <w-ber> CPU bound.
01:07:29 <dons> leather: nope, you'd use Data.ByteString.Char8 if you're dealing with Char-like data
01:07:42 <dons> for binary IO and so on, you'd use the Word8 interfacces, i.e Data.ByteString
01:07:54 <Heffalump> morning
01:08:21 <w-ber> dons: Char8? What about Unicode?
01:08:30 <dons> what about it?
01:08:43 <dons> faq ;)
01:08:44 <leather> That's what I thought. Being new to the library, I would probably prefer having Data.ByteString.Word8 to be more explicit.
01:08:59 <dons> leather: ah that's interesting
01:09:04 <leather> Heffalump: Morning!
01:10:53 <joelr1> good morning
01:11:09 <dons> heya joelr1. how's code?
01:11:31 <joelr1> dons: same old, sam eold
01:12:02 <joelr1> what's the latest trend in binary network protocols? bulat's streams?
01:12:07 <leather> dons: Thanks for the help.
01:12:30 <leather> For me, it's goodnight. Err... 3am is night enough.
01:12:33 <dons> joelr1: there's that, there's Data.ByteString (in ghc now), and there's a new erlang-style bit syntax lib
01:13:18 <dons> streams is rather imperative in style. bytestring is a list-like interface to unboxed byte arrays, the bit syntax stuff is layered over bytestring ,iirc
01:13:37 <joelr1> dons: wow, erlang-style bit syntax. where's that?
01:13:45 <dons> I'd use Data.ByteString for Word8 arrays, with a newBinary parser on top, myself.
01:13:49 <dons> let me see..
01:14:26 <dons> ?where+ bitsyntax http://www.imperialviolet.org/binary/bitsyntax/
01:14:27 <lambdabot> Done.
01:14:47 <joelr1> dons: looking, thanks
01:15:12 <dons> similar to NewBinary, but with more bytestring support
01:15:42 <dons> joelr1: also, you might want to ping musasabi, he's put all the binary network stuff for HAppS in, using bytestrings
01:15:54 <joelr1> dons: cool
01:17:07 <joelr1> dons: who's the guy behind bit syntax? i can't find a darcs repo
01:17:50 <joelr1> adam langley
01:17:57 <joelr1> i meant his irc nick
01:18:17 <dons> not sure if he's here. let me see..
01:20:14 <dons> he seems to be either agl or alangley
01:20:19 <dons> but i don't think i've seen him here
01:20:45 <joelr1> ok
01:44:17 <Excedrin> http://rafb.net/paste/results/WUnz7D74.html PiMonad compilation error, help please?
01:46:05 <Excedrin> oh, -fallow-undecidable-instances fixes that one
01:47:16 <Excedrin> http://rafb.net/paste/results/NLW1g767.html next error
01:49:00 <dons> oh, nice error.
01:49:28 <Excedrin> is that one fixed by the stuff spj recently changed?
01:49:42 <dons> yeah, I think so. or else broken by it ;)
01:49:52 <dons> try putting the pattern annotation somewherrr eelse
01:50:03 <dons> or ask on glasgow-haskell-users@
02:06:10 <chr1s> hey everyone!
02:06:40 <chr1s> I'm doing some haskell for fun again, and trying to override show behavior for a specific datatype
02:07:17 <chr1s> what I did was: data MyData = A | B deriving Show
02:07:50 <chr1s> and now I want to display an 'x' when A is shown and '0' when B is shown
02:08:38 <chr1s> is it possible to override that? I can ofcourse make a function printMyData but that's lame...
02:09:51 <Syzygy-> chr1s: you'll want to drop the deriving Show, and instead have
02:09:59 <Syzygy-> instance Show MyData where
02:10:05 <Syzygy->   show A = "x"
02:10:09 <Syzygy->   show B = "0"
02:10:16 <Syzygy-> ?type show
02:10:18 <lambdabot> forall a. (Show a) => a -> String
02:15:43 <Saizan> by the way, is there any way to know the type of something at runtime aside from pattern matching?
02:16:31 <chr1s> ah ok!
02:16:34 <chr1s> thanx
02:18:19 <Syzygy-> Saizan: How do you mean?
02:18:34 <Lemmih> @seen dcoutts
02:18:35 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
02:19:17 <Saizan> mmh like a function isInt or isInteger etc..
02:20:03 <Saizan> I know that generally one should avoid to need to know this, but..
02:20:20 <Syzygy-> Why would you even want to do that?
02:20:30 <Lemmih> > L.t (10::Int)
02:20:32 <lambdabot>  "Int"
02:20:32 <Lemmih> > L.t (10::Integer)
02:20:34 <lambdabot>  "Integer"
02:20:44 <Saizan> :O
02:20:57 <Syzygy-> > L.t (Right (Maybe (3::Integer)))
02:20:58 <lambdabot>  Not in scope: data constructor `Maybe'
02:21:08 <Syzygy-> > L.t (Right (Just (3::Integer)))
02:21:09 <lambdabot>  Add a type signature
02:21:23 <Syzygy-> Didn't I give enough info?
02:21:32 <Syzygy-> > L.t (Just (3::Integer))
02:21:34 <Lemmih> > L.t (undefined :: Either () (Maybe Integer))
02:21:34 <lambdabot>  "Maybe Integer"
02:21:35 <lambdabot>  "Either () (Maybe Integer)"
02:21:44 <Syzygy-> Ah.
02:22:03 <Syzygy-> It didn't know the left type, thus complaining.
02:22:04 <Lemmih> Saizan: See 'Typeable', 'typeOf' and 'cast'.
02:22:15 <Syzygy-> > typeOf (3::Integer)
02:22:16 <lambdabot>  Integer
02:22:35 <Saizan> Syzygy-: well the other day i wanted a function toFrac :: (Fractional a, Num b) => b -> a
02:22:36 <Lemmih> Saizan: But you probably don't wanna use them.
02:22:54 <Syzygy-> Saizan: Instead of the fromIntegral that's already there?
02:23:18 <Saizan> what if what i give to fromIntegral is yet a Frac?
02:23:33 <Syzygy-> Hmmm..
02:27:49 <w-ber> > L.ackermann 4 3
02:27:53 <lambdabot> Terminated
02:27:55 <w-ber> Tee hee.
02:28:35 <Syzygy-> > L.ackermann 1 1
02:28:37 <lambdabot>  3
02:28:41 <Syzygy-> Kewl.
02:30:27 <Saizan> there's also Data.Generics, i was thinking parametric polymorphism IS generics, but maybe here Generics means something different..
02:37:57 <dons> Saizan: yeah, in most languages parametric polymorphism is generics, i.e. in java
02:38:14 <dons> but parametric polymorphism is kinda boring in haskell ... ;) so we save 'generics' for the fun higher kinded stuff
02:39:24 <Saizan> always one step further :D
02:40:16 <dons> ?type Data.Generics.everywhere
02:40:17 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
02:40:25 <dons> things with totally wacky types :)
02:40:39 <dons> :t Data.Generics.gmapT
02:40:41 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall b. (Data.Generics.Basics.Data b) => b -> b) -> a -> a
02:41:09 <Saizan> nested forall :O
02:41:36 <w-ber> How is it possible that whenever I browse a page containing some interesting Haskell material, the name Simon Peyton Jones appears on the page? :)
02:41:38 <greentea> Hm, why would GHCi tell me that 'Just' isn't in scope, even though Data.Maybe is in scope?
02:42:03 <dons> :t Data.Generics.gfoldlAccum
02:42:05 <lambdabot> forall d (c :: * -> *) a. (Data.Generics.Basics.Data d) => (forall d1 r. (Data.Generics.Basics.Data d1) => a -> c (d1 -> r) -> d1 -> (a, c r)) -> (forall g. a -> g -> (a, c g)) -> a -> d -> (a, c d)
02:42:08 <dons> heh
02:42:28 <dons> greentea: hmm. did you use it as a type ?
02:42:40 <greentea> Trying to use it as a constructor.
02:42:49 <greentea> Oh, no, as a type, sorry.
02:43:20 <dons> > undefined :: Just -- I'm guessing?
02:43:21 <lambdabot>  Not in scope: type constructor or class `Just'
02:43:34 <greentea> Yes, something like that.
02:44:23 <greentea> The function in question has a return type of (Maybe a, [Content]).
02:44:42 <dons> > (Just (), ["foo"])
02:44:44 <lambdabot>  (Just (),["foo"])
02:44:47 <dons> :t (Just (), ["foo"])
02:44:48 <lambdabot> (Maybe (), [[Char]])
02:45:09 <dons> so values of Just a and Nothing :: Maybe a
02:45:14 <dons> > Nothing :: Maybe Char
02:45:15 <lambdabot>  Nothing
02:45:27 <dons> :t Just 'x'
02:45:28 <lambdabot> Maybe Char
02:45:55 <greentea> So i need to actually use Maybe, not Just, in the type signature?
02:46:14 <Saizan> yes
02:46:15 <greentea> Apparently so. :-)
02:46:26 <greentea> i see now. Thanks, again. :-)
02:46:52 <dons> :t [Nothing, Just 'x', Just 'y', undefined, Just undefined, Nothing]
02:46:53 <lambdabot> [Maybe Char]
02:52:28 <greentea> i must say that i'm enjoying the fact that typing automatically provides good documentation. :-)
02:54:32 <Saizan> ah, dons, how would it be hard to port lambdabot to windows to use it in GOA?
02:58:35 <dons> nice comment at the end of this blog, http://triple.aeoth.net/2006/11/24/ocaml-first-impressions/
02:58:39 <lambdabot> Title: Luke&#8217;s Blog » OCaml - First Impressions, http://tinyurl.com/y3rhzm
02:58:41 <dons> Saizan: i think its been done
02:59:02 <dons> greentea: yes, exactly.. good in the sense of "the machine can even check it for you" documentatoin :)
02:59:04 <Saizan> uh, i'll search
02:59:36 <greentea> dons: Heh. :-)
03:01:00 <dmead> bonk
03:01:58 <greentea> It's a nice change from reading "documentation" that says "This function/sub does X, taking parameters Y and Z", but doesn't specify what form those parameters need to take. So i end up having to dig into the implementation to find out what it's expecting. :-P
03:04:38 <greentea> e.g. a Perl binding to a C library: "You want a pointer? Here, let me pretend that a reference is a pointer and pass you that." :-P
03:06:28 <dmead> :-P
03:06:39 <dmead> anyone heard of haskell running on embbeded devices ?
03:10:17 <therp> Why isn't there functional "going out with girls"? Side-effects should really be abolished! Especially, the ones from cocktails on the next day.
03:10:40 <therp> Oh wait. If that night would be side-effect free, the state of my mobile phone contact list would not have changed into one that contains hot girls' numbers.
03:11:30 <dons> dmead: yeah, nhc was designed for embedded devices
03:11:46 <dons> so has, e.g. compressed bytecode, heap profiling magic, ..
03:12:37 <dmead> dons: literally embedded? as in hardware right?
03:13:56 <dons> not in hardware, that i know of, on small hardware.
03:14:10 <dons> like arm-based boards
03:14:23 <dmead> ah
03:14:30 <dons> i've seen nhc-built binaries controlling a solar car accelerator/braking mechanism :)
03:14:38 <dmead> devices that do have an operating system?
03:14:42 <dmead> neat
03:14:44 <dons> yeah.
03:14:49 <dmead> oh
03:14:50 <dmead> hmm
03:14:54 <dons> you can run ghc's rts on bare metal
03:15:01 <dons> but i don't know of other work in that area
03:15:08 <dmead> i'm getting involved with a first robotics team
03:15:16 <dons> doesn't everything come with a linux kernel these days?
03:15:27 <dmead> and their using some ridiculous subset of C++ on an embedded processor
03:15:31 <dons> dmead: cool. you looked a tthe robot control work in haskell?
03:15:31 <dmead> ha
03:15:52 <dmead> yea i've read about some of yampa
03:16:07 <dons> language design isn't the robot builder's strong suit, from my experience
03:16:24 <dmead> but i'd like to figure out if it's possible to use haskell on such a bare bones system
03:16:29 <dons> http://haskell.org/haskellwiki/Research_papers/Functional_reactive_programming
03:16:32 <lambdabot> Title: Research papers/Functional reactive programming - HaskellWiki, http://tinyurl.com/jsfmb
03:16:42 <dons> dmead: so you have some simple OS?
03:16:42 <dmead> hmm
03:16:55 <dons> what kind of system is it/
03:16:57 <dmead> dons: i don't know
03:17:11 <dmead> from what i've seen so far theres a simple ide
03:17:25 <dmead> where you can write in c++ and it produces a rom thats loaded onto the system board
03:17:44 <dons> ok. and you just compile it with g++ ?
03:17:49 <dmead> so i'm assuming theres no operating system
03:17:57 <dmead> don't know yet
03:18:26 <dmead> i think they mentioned that the machine "has no memory"
03:18:33 <dmead> but i don't know really what that actually entails
03:18:50 <dmead> (it's mentoring with high school kids)
03:18:58 <dons> ok
03:19:13 <dons> making them program in a C++ dialect is a bit nasty
03:19:33 * dons thinkgs there should be a lego edsl for haskell
03:19:50 <dmead> hehe
03:20:03 <dmead> i actually judged a lego competition today ;o
03:20:06 <dmead> and they do have a dsl
03:20:24 <dmead> it's a graphical representation of basic
03:20:58 <dmead> pretty simple, but it teaches little kids programming language concepts
03:21:59 <dons> a dsl in haskell?
03:22:09 <dons> i know there's a few dsls / languages for lego around
03:22:19 <dons> but a nice purely functional one would probably help the kiddies out
03:22:32 <dons> ah, I see.
03:24:31 <dmead> hmm
03:25:14 <astrolabe> an argument for basic http://www.salon.com/tech/feature/2006/09/14/basic/index.html
03:25:17 <lambdabot> http://tinyurl.com/fshya
03:25:48 <dons> hmm, anyone here responsible for: http://programming.reddit.com/goto?id=tfqp
03:25:51 <lambdabot> Title: dpaste: #3412: Haskellisp, by Nick
03:26:32 <dons> who was working on the real lisp-in-haskell embedding?
03:26:44 <dmead> lispy maybe?
03:26:47 <nornagon> ... lisp in haskell?!
03:26:48 <dmead> it was definatly someone in here
03:26:52 <nornagon> why?!
03:27:01 <dons> nah, not lispy.
03:27:05 <dmead> theres also haskell on the jvm
03:27:27 <dmead> hmm
03:27:34 <dmead> so nhc binarys only need to use the C runtime?
03:27:38 <dons> ah, therp.
03:28:03 <gour> dons: what should 'setLambdabotHome' in goa point at?
03:28:51 <therp> dons: yes me
03:29:09 <dons> gour: the path to the top of the lambdabot dir, e.g.
03:29:15 <dons> setLambdabotHome "/home/dons/lambdabot"
03:29:21 <dons> therp: how's that embedding coming along?
03:29:56 <dons> oh, this link to it doesn't seem to work anymore? http://clemens.endorphin.org/LskVsLisp.html http://clemens.endorphin.org/Ls
03:29:58 <gour> dons: and if i want to install lambdabot via ebuild, then no luck?
03:30:00 <dons> kVsHs.html
03:30:00 <lambdabot> Title: Liskell versus Lisp
03:30:06 <dons> gour: use the darcs repo
03:30:09 <therp> dons: quite ok, I'm focusing on writing a paper for ILC07, International Lisp Conference in Cambridge. I would love to do more hacking, but deadline for paper submission is approaching
03:30:19 <dons> fair enough :)
03:30:36 <dons> ah my fault, my url had a space ;)
04:08:37 <fasta> When I walk down a tree, and then up again, would the advised way to go is to store all the trees in a list(since there are no "back-pointers" in Haskell?
04:12:14 <Lemmih> How about not going up again or keeping a pointer to the parent?
04:15:21 <apfelmus> fasta: i don't know what you want to do, but there is a small paper by Okasaki about labeling the nodes of a tree in breath first numbering. he basically suggests to use a queue and notes that everybody thinks in a level-wise fashion.
04:15:28 <astrolabe> maybe you could let the calling function deal with the tree at the next level up
04:16:23 <der_eq_> perhaps http://haskell.org/haskellwiki/Zipper could be helpful?
04:16:24 <lambdabot> Title: Zipper - HaskellWiki
04:16:29 <fasta> Would my data type look something like this then? data TreeWithParentPointer a = Node {value::a, leftChild::(TreeWithParentPointer a), rightChild::(TreeWidthParentPointer a), parentPointer::(TreeWidthParentPointer a)}?
04:16:49 <fasta> I only would need to have a case for the root and leaves then.
04:18:00 <apfelmus> fasta: it looks like you want a zipper. it looks a bit different, though.
04:18:26 <fasta> But what I wrote above is the equivalent of parent pointers, right?
04:19:22 * greentea struggles with lifting.
04:19:24 <apfelmus> yes. but the parentPointer is actually shared. if you change a child, the parent does not get updated.
04:21:21 <greentea> i've used openFile to get an IO Handle. But a function i want to use has type Handle -> a  -> IO(). So i believe if need to use liftM2 here - is that correct?
04:21:59 <fasta> apfelmus: what do you mean?
04:22:23 <apfelmus> greentea: ? openFile "foo.bar" >>= \handle -> doething handle a
04:23:38 <apfelmus> fasta: let x = Node 2 Leaf Leaf y; y = Node 1 x Leaf Nothing. y is the root node and x one of his children.
04:25:21 <greentea> apfelmus: Er, okay, i'll have a play around with that - thanks.
04:26:46 <apfelmus> greentea: you can use do-notation:
04:26:46 <apfelmus> do
04:26:46 <apfelmus>    h <- openFile "foo.bar"
04:26:46 <apfelmus>    dothing h a
04:27:08 <fasta> apfelmus: replacing x with z has the effect that z's parent is y, but y's child is still x, right?
04:28:07 <greentea> Ah, i think i get it now. Thanks. :-)
04:29:05 <fasta> apfelmus: never mind that.
04:29:29 <fasta> apfelmus: I don't see the problem.
04:30:00 <apfelmus> fasta: mh, not really. there is no such thing as to replace x by z. you may construct y' = Node 1 z ... with z = x { value = 3 }. then, the parent of z is still y but it should be y'.
04:31:11 <fasta> apfelmus: but you can do y' = Node 1 z with z = x{value=3,parentPointer=y'}?
04:32:48 <apfelmus> fasta: yes. but you may get serious headache if you are doing things inside a map or fold. try to write map :: Tree a -> Tree b that respects the sharing.
04:33:16 <fasta> apfelmus: I can imagine.
04:33:22 <fasta> apfelmus: good point
04:34:14 <fasta> apfelmus: so the solution is to use that "zipper" or implement pointer data structures in the ST monad?
04:36:44 <apfelmus> fasta: maybe. if you only lookup things, the tree with sharing can be very useful. otherwise a zipper is likely the way to go. ah, and considering pointers & ST, please don't succumb so easily to the vile forces of darkness...
04:40:31 <fasta> apfelmus: can every pointer(no pointer arithmetic, though) data structure be implemented with zippers as efficiently as in C?
04:42:12 <apfelmus> fasta: i don't know, but i think so. what do you want to do?
04:43:23 <fasta> apfelmus: I was trying to implement the splay operation of a splay tree, but for that I needed some kind of parent pointer.
04:45:03 <fasta> It appears that http://okmij.org/ftp/Haskell/Zipper1.lhs assumes knowledge of delimited continuations :(
04:46:30 <apfelmus> fasta: i don't know anything about splay trees, but i as far as i know, they are eschewed in favor of other tree types in Haskell. it's difficult to make them persistent, though it may be possible. perhaps someone already did functional things with splay trees.
04:47:08 <apfelmus> fasta: for the zipper, i think reading huets original paper is better.
04:47:26 <astrolabe> I don't know about splay trees, but I have done some quite complicated tree stuff in haskell, and found that it is possible to do it functionally.  The trick is to do it all in one go, and not to worry about the order of operation.
04:47:33 <fasta> apfelmus: In a paper I read they rely on that data structure.
04:47:48 <fasta> apfelmus: it's optimal for a specific access sequence.
04:48:45 <apfelmus> fasta: so you don't need splay trees :) which access sequence?
04:52:47 <fasta> apfelmus: how do you conclude I don't need splay trees?
04:53:38 <apfelmus> fasta: i just guess there is a functional replacement :)
04:53:57 <w-ber> Hm. Why does the Shootout still have the old version of the Fasta program?
04:54:51 <w-ber> http://shootout.alioth.debian.org/gp4/benchmark.php?test=fasta&lang=ghc
04:54:54 <lambdabot> Title: fasta Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer L ..., http://tinyurl.com/yl9x3m
04:55:38 <fasta> apfelmus: I got the original paper and it appears I made up that specific access sequence. :)
04:55:53 <w-ber> Oh, right. A new entry was submitted only two weeks ago.
05:06:32 <jlouis> The problem with a splay tree is that on _lookups_ they alter the tree structure. Thus, you lookup function must be of type lookup :: Tree k v -> k -> Maybe (v, Tree k v) (or (Tree k v, Maybe v) depending on mood)
05:07:51 <fasta> jlouis: I had that right already
05:09:01 <jlouis> you _do_ have Chris Okasaki's 'Purely Functional Data Structures' right? If not, take a look inside the edison library. I am sure there is a splay tree there used for a heap
05:09:25 <fasta> jlouis: There's a "splay heap"
05:09:32 <fasta> jlouis: But I don't know that that is.
05:09:33 <jlouis> ... which is a splay tree
05:09:42 <Axioplase> Hi
05:09:44 <fasta> jlouis: then why doesn't he name it in that way?
05:10:16 <jlouis> fasta, because he uses them as heaps. The FIND-MIN and FIND-MAX operations is just going leftmost or rightmost in the tree
05:10:46 <fasta> jlouis: but does Edison export the full splay tree API?
05:10:55 <jlouis> with O(lg n) lookup time. Its always possible to make this into a O(1) by storing the least/largest element away from the tree
05:11:06 <jlouis> fasta, I frankly dunno
05:11:16 <fasta> jlouis: Ok, thanks
05:16:35 <greentea> Is anyone here familiar with HaXml?
05:33:48 <erider> good morning
05:37:45 <RemiTurk> good morning
05:47:55 <MarcWeber> Hase anyone of you tried to use/ compile fudgets library recently? I don't know exactly where to get hbcmake which seems to belong to hbc (haskell compiler 1993 ..) ?
05:48:55 <basti_> i tried to compile it once, but i didnt succeed
05:49:38 <MarcWeber> basti How far did you get? Do you remember where you got stuck?
05:49:55 * basti_ shakes his head
06:02:57 <Lemmih> Those guys at JanetsCapital seem quite interested in Haskell hackers.
06:03:49 <Heffalump> DYM "Jane St"?
06:04:18 <pejo> MarcWeber, isn't hbcmake somewhere on chalmers.se?
06:06:07 <Lemmih> Heffalump: Eh, right.
06:22:48 <MarcWebe1> pejo: Right But the link I've found using google was down
06:22:49 <metaperl> hey, I tried to do something with a list comp but it aint workin... help please: http://rafb.net/paste/results/U1XIq989.html
06:22:54 <metaperl> paste.lisp.org is down
06:23:03 <metaperl> Lemmih - but they arent switching to Haskell though are they?
06:23:20 <metaperl> Lemmih - their slides say that 2 of their groups use OCaml.... doubt they will switch
06:24:11 <Botje> metaperl: where is b defined?
06:24:24 <metaperl> b?
06:24:39 <metaperl> the problem is w/the function q
06:24:44 <Botje> oh, there
06:25:05 <metaperl> Botje it works but it is cluttered
06:25:55 <metaperl> figured it out, but it is cluttered : http://rafb.net/paste/results/A7W6cq13.html
06:27:27 <Botje> you could abuse fold, i think
06:29:41 <pejo> MarcWeber, does http://www.cs.chalmers.se/pub/users/hallgren/Alfa/Haskell/hbc/hbcmake-970521.tar.gz  work for you?
06:29:43 <lambdabot> http://tinyurl.com/yegrjb
06:30:58 <pejo> MarcWeber, (or is http://www.cse.ogi.edu/~hallgren/untested/Source_code/ what you're really looking for?)
06:31:00 <lambdabot> Title: Source code, http://tinyurl.com/yjjk4p
06:31:50 <Botje> metaperl: [snd g | g <- grouping] is better written as map snd grouping :)
06:34:07 <metaperl> Botje - you are very right. For some reason, I woke up thinking I should've used List comprehensions to rewrite newsham's solution to this. But I agree with you
06:34:17 <metaperl> http://Sequence.Complete.Org looks sharp doesnt it?
06:34:22 <lambdabot> Title: The Haskell Sequence | News about Haskell
06:35:21 <Lemmih> metaperl: Still, O'caml is cool.
06:35:42 <Botje> metaperl: great, now I have another entry in my RSS aggregator :]
06:35:44 <metaperl> Ok, Botje i implemented your suggestion <http://rafb.net/paste/results/yE6F1i76.html> thanks again
06:36:26 <metaperl> Lemmih - I think OCaml has its strong points. But overall I prefer Haskell and trust it more when I need something airtight
06:41:47 <fasta>  When I test this in the ocaml interpreter: type tree = Item of
06:41:47 <fasta>                item|Section of tree list;; I get that item is unbound. This is
06:41:47 <fasta>                copied straight from an article in The Journal Of Functional
06:41:48 <fasta>                Programming.
06:43:53 <Lemmih> type tree item = Item of item ?
06:44:51 <fasta> Lemmih: I tried that.
06:45:20 <fasta> I get the great error message: "syntax error" :)
06:45:34 <_matthew-> mmm. anyone here have a solid grasp of barycentric coordinates? (I realise somewhat OT)
06:45:40 <Lemmih> type tree 'item = Item of 'item ?
06:46:42 <fasta> Ocaml also doesn't have readline support => rlwrap
06:46:48 <pitecus> Why isn't Data.Set an instance of Functor?
06:47:11 <Heffalump> because of the Eq constraint?
06:47:14 <Heffalump> IM Ord
06:49:11 <pitecus> So you'd need to constrain all instances of Functor in order to include Set?
06:50:15 <pitecus> That's  a bit lame
06:51:49 * RemiTurk thinks it's the lamest thing about monads/functors in haskell
07:02:02 <jlouis> ?type ThreadId -> IO Bool
07:02:10 <lambdabot> not an expression: `ThreadId -> IO Bool'
07:02:21 <jlouis> ?hoogle ThreadId -> IO Bool
07:02:22 <lambdabot> No matches, try a more general search
07:02:25 <jlouis> blah
07:03:01 <jlouis> any idea of how to watch a thread and see if it dies?
07:04:06 <w-ber> Timing out? http://haskell.org/haskellwiki/Timing_out_computations
07:04:08 <lambdabot> Title: Timing out computations - HaskellWiki, http://tinyurl.com/ybwtnx
07:05:54 <yuten> hello
07:06:26 <jlouis> w-ber, not exactly that. I thought I could get a function from a ThreadId to whether it is running or not, ie isAlive :: ThreadId -> IO Bool
07:06:27 <yuten> how can i export data with all its constructor
07:06:42 <jlouis> yuten, module Foo(BazData(..))
07:06:44 <jlouis> where
07:06:55 <jlouis> yuten, then the constructors are exported as well
07:07:10 <w-ber> jlouis: Sorry, I don't know much about threads in Haskell.
07:07:13 <yuten> thanks jlouis :)
07:07:24 <jlouis> w-ber, neither do I, hehe.
07:12:21 <pitecus> One thing I still don't get: why does the Ord constraint prevent Set from being a Functor, but not from being a Monoid?
07:20:24 <dmhouse> Is there a dual to getContents?
07:21:15 <dmhouse> writeFile is what I need.
07:21:31 <dmhouse> (I really meant a dual to readFile, I got the names confused for a minute.)
07:23:33 <Saizan> ?hoogle writeFile
07:23:34 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
07:23:34 <lambdabot> System.Win32.File.c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
07:23:34 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
07:25:09 <Saizan> (i want GOA even more.. maybe this is the time to switch definitively to linux)
07:34:05 <jlouis> GOA?
07:34:58 <jlouis> HAppS is nice
07:35:21 <jlouis> I am playing a bit around with it and hitting the type-checker barrier all the time, but it goes in the right direction, slowly
07:37:36 <Saizan> HAppS?
07:38:00 <jlouis> ?where happs
07:38:00 <lambdabot> http://happs.org
07:38:07 <Saizan> GOA is GHCi on Acid, basically a lambdabot that lives in ghci
07:38:25 <jlouis> Haskell Application Server
07:38:32 <jlouis> ah, so GOA is the child of Dons?
07:38:38 <jlouis> its a cool idea
07:38:50 <Saizan> uhm yes, i think so
07:39:33 <jlouis> lambdabot is cool to learn from by the way. There is some really hairy code in it written by Thomas Jaeger IIRC
07:39:41 <Saizan> very cool it seems, but i can't try it.. i've found a patch to build it on windows but it doesn't seem to work
07:39:54 <jlouis> aha, whats the problem?
07:41:02 <Saizan> well after excluding the irc-related plugins Main.hs still gives a lot of "undefined" error
07:41:59 <Masklinn> hello everybody
07:43:59 <jlouis> Saizan, argh. Too bad I have no Win32 boxen here
07:44:39 <Saizan> well maybe i just have to keep adding import statements :D
07:53:03 <Saizan> no, it has stopped to typecheck..
08:01:53 <Heffalump> RemiTurk/pitecus: apparently the type checking changes in the development branch of GHC will sort that out - hopefully they'll make it into Haskell' too
08:02:39 <pitecus> cool
08:12:26 <RemiTurk> Heffalump: are you talking about the fact that (when defining an ADT using GADT syntax) the dictionary is stored in the datatype? Because IIRC that would solve the problem for fmap and (>>=), but not for return..
08:40:35 <jlouis> ?hoogle HTML -> String
08:40:36 <lambdabot> No matches, try a more general search
08:40:37 <pitecus> how do i find the range of Int?
08:40:47 <jlouis> ?Hoogle Text.Html -> String
08:40:48 <lambdabot> Maybe you meant: google hoogle
08:40:57 <jlouis> ?hoogle Text.Html -> String
08:40:58 <lambdabot> No matches, try a more general search
08:41:03 <jlouis> I need to learn this
08:42:43 <jlouis> pitecus, Int is a member of the Bounded class. Therefore, it has minBound and maxBound
08:42:46 <jlouis> ?t minBound
08:42:46 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:42:52 <jlouis> ?type minBound
08:42:54 <lambdabot> forall a. (Bounded a) => a
08:44:14 <pitecus> thanks
08:52:18 <Axioplase> hum, I might have written badly my monade.. I always have to write "foo >>= bar >>= quux"... How can I chnage the functions defs so that I can write "foo;bar;quux" ? lifting \x f-> f x ?
08:53:50 <astrolabe> Axioplase: do you know about the 'do' notation?
08:54:06 <Axioplase> astrolabe: hum.. yes..
08:54:14 <Axioplase> (not enough it seems)
08:54:16 <Masklinn> Axioplase > you can't, but you can use the do notation which is a shortcut for what you're writing now
08:54:53 <Axioplase> Masklinn: well, all those >>= are inside a "do"
08:55:32 <Masklinn> they shoudn't be needed if they're inside a do expression, from what I understood not having to write them is part of "do" expression's point
08:55:38 <Axioplase> so, roughly, my question was "in order to remove those >>=, should I lambda abstract or apply those functions ?"
08:55:43 <Masklinn> I may have misuderstood, but...
08:56:04 <astrolabe> in a do, you can write that as '{f<-foo; b<-bar f; quux b}
08:57:01 <Axioplase> astrolabe: I don't want to use any "<-". But maybe I'm wrong too, with want I wish I could do.
08:57:19 <Axioplase> I hoped that ";" could work the same way as ">>=" does.
08:57:38 <Axioplase> (modulo some tweaking on foo and bar functions)
08:58:58 <Axioplase> If I'm not clear, I'm writing a StateMonad that passes the environment through the ">>=" operator. But I wish I could just use ";" so that it's easier to write
08:59:53 <Heffalump> remiturk: ah. good point.
08:59:53 <Masklinn> you can't
09:00:01 <Masklinn> I think
09:00:12 <Axioplase> rightnow, I have to write 'do initState >>= set "x" 3 >>= set "aa" 42' and I widh I could simply write 'do initState; set "x" 3; set "aa" 42'
09:00:14 <astrolabe> I agree
09:00:17 <Masklinn> you either have to use do and <-, or >>=
09:00:59 <Masklinn> I don't think impossible, you have to pass your state from a statement to another, and that's done either with >>= or with <-
09:01:23 <Axioplase> ok. I'll do that way then. thanks
09:01:35 <RemiTurk> Heffalump: I wish it wasn't ;)
09:03:53 <Saizan> being able to write foo;bar;asd; would need sequencing and strict evaluation i think, so would turn haskell in imperative
09:05:13 <Masklinn> that's also how I understand it
09:11:09 <Heffalump> RemiTurk: no, wait, I don't see the problem. return :: a -> m a, and it's a that would have the dictionary wrapped up with it, isn't it?
09:12:47 <Botje> astrolabe: perhaps you should look at the part of YAHT that explains how do notation works
09:13:02 <Botje> do is purely syntactic sugar for >>= and friends
09:13:17 <astrolabe> Botje: that was my point
09:13:23 <Botje> ehh
09:13:28 <Botje> s/astrolabe/Axioplase/ :)
09:13:35 <Botje> damn autocompletion :(
09:13:43 <astrolabe> :)
09:14:32 <Axioplase> Botje: that's why I asked whether the >>= could be made "do"
09:14:33 <RemiTurk> Heffalump: I think it would have to be in the 'm'... There is some discussion of it at http://www.haskell.org/pipermail/glasgow-haskell-users/2006-November/011530.html
09:14:38 <lambdabot> Title: Major type-class overhaul, http://tinyurl.com/y6yzjb
09:14:57 <astrolabe> Axioplase: what is the type of 'set "aa" 42'?
09:15:26 <Axioplase> astrolabe: SM (\x->((Maybe Int),x))
09:16:27 <astrolabe> that seems a bit odd with your >= set "x" 3 >= ...
09:16:59 <astrolabe> @type >=
09:17:01 <lambdabot> parse error on input `>='
09:17:16 <astrolabe> @type (>>=)
09:17:17 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
09:17:18 <Axioplase> astrolabe: exactly, it is set "aa" 42 :: Maybe Int -> State [(String, Int)] (Maybe Int)
09:17:41 <Axioplase> where State is the SM kind i showed you.
09:18:46 <Heffalump> RemiTurk: ah, yes, you're right. Hmph.
09:20:29 <astrolabe> Axioplase: I'm afraid I don't follow you.
09:21:59 <Axioplase> astrolabe: forget it.. I'm okay with what I have now..
09:22:50 <Axioplase> Still, I have another question... I'm in the Foo monad. How can I print a value from this monad ? (whatever I do, I always end up with a Foo can't be unified with IO)
09:23:23 <jajs> Axioplase, use a monad transformer ?
09:23:38 <orbitz> i can't wait for the transformers movie
09:23:43 <emu> with a state monad you should be writing something like: do state <- get; put (modifyfoo state)
09:24:11 <emu> what you wrote doesn't make sense
09:24:26 <emu> unless set is a function of a -> b -> State
09:25:46 <Axioplase> emu: what I wrote when ?
09:26:08 <Axioplase> if it's 18'11 (local time), the yes, I had forgotten an arrow in the type.
09:26:21 <Axioplase> Otherwise, I'm not worng for it works !
09:26:57 <emu> what is the type pf '
09:27:01 <emu> what is the type of 'set'?
09:27:56 <Axioplase> emu: set is set :: String -> Int -> Maybe Int -> State [(String, Int)] (Maybe Int)
09:28:30 <Saizan> Axioplase, you have to make Monad composition with IO to print and do other IO () stuff
09:28:38 <emu> Axioplase: why aren't you using the State monad?
09:28:48 <emu> or better yet, StateT
09:29:19 <Axioplase> emu: because I'm writing it to teach myslef monads
09:29:57 <emu> well you would be best off examining an implementation of it.  it's not very long.
09:31:05 <Axioplase> mine ain't long either.. though now, I still want to be able to print the return value of my state.. so, I'm reading about monad transformers..
09:32:31 <Saizan> to learn monads by building them: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html#links
09:32:34 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
09:33:54 <Saizan> same blog on monad transoformers: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
09:33:57 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
09:50:48 <chr1s> hey guys!
09:51:00 <basti_> hi chr1s
09:51:18 <chr1s> Is it possible to define an instance of Show for a type?
09:51:38 <chr1s> I've got my type Block = [[BlockPart]]
09:51:49 <basti_> sure
09:52:00 <chr1s> and when I do this in GHC: unlines $ map (concat . map show) testBlock
09:52:06 <basti_> "instance" is the key
09:52:10 <chr1s> it perfectly runs
09:52:13 <chr1s> but when I do a
09:52:26 <chr1s> instance Show Block where
09:52:26 <chr1s>   show x = unlines $ map (concat . map show) x
09:52:30 <Heffalump> chr1s: no, it's not
09:52:35 <Heffalump> you need to use newtype instead of type
09:52:36 <chr1s> it doesn't work
09:52:42 <sjanssen> chris: you won't be able to write a show instance for [[BlockPart]], because it overlaps with the usual list instance
09:52:46 <basti_> oh it's a type
09:52:50 <basti_> >_<
09:52:50 <basti_> sorry
09:52:51 <sjanssen> and instances aren't allowed to overlap
09:53:21 <chr1s> Heffalump: thanx, I'll dive in to that
09:55:09 <Masklinn> he just needs to make his BlockPart an instance of Show doesn't he?
09:55:33 <chr1s> Masklinn: I already did that
09:55:57 <sjanssen> I imagine chris wants special formatting
09:56:07 <chr1s> sjanssen: yes
09:58:46 <chr1s> Heffalump: I do want to be able to do pattern-matching on my list
09:59:12 <chr1s> s/list/newtype
09:59:39 <Heffalump> chr1s: that's fine, you just have to add another constructor when you do the pattern-match
10:00:16 <chr1s> Heffalump: well, I want to do list pattern matching
10:00:21 <chr1s> like (x:xs)
10:01:18 <Saizan> you'll have to write somethign like Block (x:xs) i think
10:01:57 <chr1s> that would match a block as first parameter and a list as second.
10:08:11 <Heffalump> (Block (x:xs))
10:08:52 <chr1s> ok, that's cool
10:17:07 <enkrav_> Hello, I have written this list that computes the primes as follows:
10:17:13 <enkrav_> isprime x = not (elem 0 (map (mod x) [2..(x-1)]))
10:17:13 <enkrav_> primes = 2:[x | x <- [3..], isprime x]
10:17:21 <enkrav_> but would like to optimize
10:17:55 <enkrav_> by substituting [2..(x-1)]   by the "previous" of the primes that I have just computed
10:18:13 <enkrav_> can you give me a hint?
10:19:04 <basti_> hmm
10:19:09 <apfelmus> enkrav_: just do what you said? (and add a filter (\p -> p^2 < x))
10:19:20 <basti_> you could simply write "primes" there, under certain conditions...
10:19:58 <astrolabe> you only need to up to floor (sqrt x) rather than x-1
10:20:20 <astrolabe> ah, I'm repeating apfelmus
10:20:20 <enkrav_> astrolabe, of course
10:20:37 <basti_> ah yes.
10:20:39 <basti_> you need to abort
10:22:02 <basti_> but, this is not possible with "filter"
10:22:22 <basti_> since you'd have to end the list when you reach the maximum (it is monotonous)
10:22:40 <astrolabe> primes = sieve [2..]
10:22:40 <astrolabe>     where sieve (p:rest) = p : sieve [n | n <- rest, mod n p /= 0]
10:22:46 <astrolabe> (found on the internet)
10:23:49 <enkrav_> hmm
10:24:39 <apfelmus> > isprime x = not . elem 0 . map (x `mod`) . takeWhile (\p -> p*p < x) $ primes
10:24:39 <apfelmus> > primes = 2:[x | x <- [3..], isprime x]
10:24:40 <lambdabot>  Parse error
10:24:40 <lambdabot>  Parse error
10:25:06 <basti_> uhm, yea, takeWhile might help
10:25:12 <apfelmus> > let isprime x = not . elem 0 . map (x `mod`) . takeWhile (\p -> p*p < x) $ primes; primes = 2:[x | x <- [3..], isprime x] in primes
10:25:16 <lambdabot>  [2,3,4,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,...
10:25:20 <int-e> note the bug :)
10:25:29 <basti_> :P
10:25:32 <int-e> it doesn't eliminate prime squares
10:25:45 <basti_> <= then
10:25:46 <apfelmus> > let isprime x = not . elem 0 . map (x `mod`) . takeWhile (\p -> p*p <= x) $ primes; primes = 2:[x | x <- [3..], isprime x] in primes
10:25:48 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:26:18 <apfelmus> ... (ahem) ...
10:26:30 <basti_> hmm?
10:27:36 <enkrav_> hmm? thank you all!
10:27:45 <int-e> isprime x = and [x `mod` p /= 0 | p <- takeWhile (\p -> p*p <= x) primes]
10:27:48 <int-e> hmm :)
10:27:52 <int-e> I prefer list comprehensions here.
10:29:01 <apfelmus> ?pl \x -> and [x `mod` p /= 0 | p <- takeWhile (\p -> p*p <= x) primes]
10:29:02 <lambdabot> and . return . liftM2 (/=) (`mod` p) (((0 | p) <-) . flip takeWhile primes . flip ((<=) . join (*)))
10:29:30 <apfelmus> indeed, list comprehension is to be preferred :)
10:29:59 <int-e> wow, how did it manage to parse that :) (ouch)
10:30:51 <int-e> all ((0 /=) . (x `mod`)) $ takeWhile ...    could also be nice.
10:31:18 <kpreid> apfelmus: @pl doesn't understand | and thinks it's just an infix operator
10:31:26 <int-e> kpreid: yes
10:31:51 <newsham> is it cheaper to compute the square of each prime or compute the square root of the query value just once?
10:32:23 <newsham> (takWhile \p -> p*p<=x)
10:32:49 <int-e> the square root is probably cheaper for large numbers but you get into some numerical trouble.
10:33:18 <newsham> how do you get into numerical trouble?  surely sqrt is accurate enough to determine if its less than a given integer
10:33:34 <int-e> you have to get perfect squares right.
10:33:41 <apfelmus> kpreid: ah, and the [] is just return. no comma, no error
10:34:44 <newsham> even so, wouldnt it be cheaper to do sqrt once and do one extra comparison ((sqrt x) + 1) ?
10:35:07 <int-e> yes.
10:35:12 <apfelmus> > 1e40+1
10:35:14 <lambdabot>  1.0e40
10:35:42 <int-e> > (1e40+1) > (1e40)
10:35:43 <lambdabot>  False
10:35:52 <int-e> > (1e40+1) > (1e40 :: Double)
10:35:54 <lambdabot>  False
10:36:02 <kpreid> > 1e40+1 :: Rational
10:36:03 <lambdabot>  10000000000000000000000000000000000000001%1
10:36:10 <fasta> What exactly is a "younger sibling" in the context of the zipper data structure?
10:36:13 <int-e> apfelmus: but I'd argue you don't want to wait that long :)
10:36:38 <newsham> apfelmus: are you planning on running the seive 10^40 times?
10:37:36 <apfelmus> int-e: ehm, yes yes, asymptotically. asymptotically, indeed :)
10:38:12 <int-e> 2^48 is the critical point if you use double arithmetic. So numbers below 2^90 should work just fine with sqrt x+1
10:40:02 <apfelmus> > sqrt(15381)<sqrt(15382)
10:40:04 <lambdabot>  True
10:40:17 <apfelmus> > 10*0.1 == 1
10:40:19 <lambdabot>  True
10:40:57 <apfelmus> o.O that was False some time ago
10:41:15 <apfelmus> > 10 * 0.1 :: Float == 1.0
10:41:15 <lambdabot>  Parse error
10:41:18 <newsham> instead of floor sqrt + 1, wouldnt round  sqrt be a good approx?
10:41:30 <apfelmus> > 10 * (0.1 :: Float) == 1.0
10:41:31 <lambdabot>  True
10:41:42 <int-e> oh, it's 2^52.
10:41:46 <basti_> people got killed because of 0.1 not being displayable in IEEE Floating Point arithmetic
10:41:50 <int-e> let x= (2^52 :: Double) in (x == x+1, x == x+1/2)
10:41:54 <int-e> > let x= (2^52 :: Double) in (x == x+1, x == x+1/2)
10:41:56 <lambdabot>  (False,True)
10:43:57 <sreeram> newsham,int-e: + 1 shouldn't be needed in sqrt(x)+1, because you only need to check upto sqrt(x)-1, so just sqrt(x) should be fine as long as the error is less < 1
10:44:20 <int-e> sreeram: then you miss the perfect prime squares like apfelmus originally did
10:45:23 <sreeram> oops my bad, sorry
10:50:43 <Axioplase> damn.. I'm inside a Maybe monad.. How can I print its value ?
10:51:55 <basti_> uhm... rather hard, if you want to do it clean
10:52:17 <fasta> What exactly is a "younger sibling" in the context of trees?
10:53:12 <Axioplase> basti_: hard ? dammit.. Is there a magical keyword to search the way to do it ? (and if I don't do it cleanly, what would it look like?)
10:53:18 <jajs> Axioplase, using Debug.Trace, but it's _very_ dirty (and intended for debugging only)
10:53:29 <basti_> Axioplase: dirty is as jajs says.
10:53:35 <CrewdenX> fasta: i guess the sibling that follows the current node.
10:53:40 <Axioplase> jajs: well, not that dirty then...
10:53:41 <basti_> Axioplase: the clean way has something to do with commuting monads...
10:54:02 <basti_> there's a way to lift stuff inside a monad so that it works on the monad surrounding it
10:54:09 <basti_> i'm not sure if "commuting" is the right term
10:54:29 <jajs> Axioplase, the clean way would be to use monad transformers, i suppose
10:54:33 <fasta> CrewdenX: I think so, too, but nobody defines it.
10:54:53 <CrewdenX> fasta: where are you reading this?
10:55:15 <basti_> monad transformers might be a good keyword yes
10:55:20 <fasta> CrewdenX: "The Zipper", Huet
10:55:35 <CrewdenX> fasta: i have no idea what that means.
10:55:57 <fasta> CrewdenX: it's the name of an article you can find via scholar.google.com
11:11:48 <apfelmus> fasta: how did you get the full contents? i'm rather stuck
11:12:10 <fasta> apfelmus: I have an ssh proxy to my university
11:12:24 <sreeram> apfelmus, looks like the paper is not free.. but there is a good explanation here: http://www.haskell.org/haskellwiki/Zipper
11:12:25 <lambdabot> Title: Zipper - HaskellWiki
11:12:27 <fasta> apfelmus: I don't like using such articles, though.
11:13:27 <apfelmus> ah, the wiki site has a pointer to it :)
11:13:59 <sreeram> didn't notice that! :)
11:14:52 <apfelmus> fasta: ok. so what was your problem? can it be redeemed by reading the wiki page instead?
11:15:24 <fasta> apfelmus: I wanted to know what "younger siblings" were, but that's already solved. So, I have no problem.
11:15:41 <apfelmus> ok, fine then :)
11:16:22 <fasta> The definition does make sense, when you consider the concepts of sibling and ancestor.
11:16:31 <int-e> fasta: so what are they? are they left siblings or really newer?
11:16:43 <fasta> int-e: right siblings, I think.
11:16:55 <fasta> int-e: I didn't find an explicit definition.
11:17:01 <int-e> sorry, yes I meant right.
11:17:19 * fasta wonders what int-e meant by "really newer"
11:17:39 <int-e> well, a zipper represents a mutable data structure and as such has a history.
11:19:08 <fasta> What kind of history?
11:20:51 <sreeram> int-e is probably referring to the fact that a 'modify' operation is supported which lets you replace a subtree while retaining the original tree
11:22:04 <int-e> fasta: previous version of that data structure
11:22:07 <fasta> Yes, all data structures in Haskell have that property.
11:22:17 <fasta> aka persistent
11:22:59 <int-e> fasta: but that's more than I meant.
11:23:21 <sreeram> true, but in a zipper, the new tree and the old tree share all the data except the replaced subtree
11:23:22 <jacobian_> What emacs inferior package do people recommend?
11:27:38 <fasta> All the applications I have seen of zippers are tree structures, although the idea of context can be extended to arbitrary structures, I guess.
11:28:03 <int-e> fasta: The kind of history that I meant is tied to mutability. I.e. you have an identified object that changes over time, and the history consists of the previous values. An immutable value has no history in that sense. Now while all the data the zipper uses is immutable in itself, it feels more like a mutable data structure which has a history. Persistence means that you can actually keep the previous versions around.
11:28:33 <int-e> Hmm, it's hard to imagine a zipper for graphs.
11:28:38 <fasta> int-e: ok
11:29:44 <jacobian_> It isn't terribly hard
11:31:26 <fasta> jacobian_: what packages are you thinking of? I am satisfied with my Emacs Haskell setup, but I don't know of more "inferior" packages.
11:32:02 <Axioplase> err.. what should I import to use the StateT monad ?
11:32:08 <SamB> how about ilisp? that is an inferior package!
11:32:19 <SamB> Axioplase: Control.Monad.State
11:32:30 <Axioplase> thanks
11:32:40 <fasta> @hoogle StateT
11:32:41 <lambdabot> Control.Monad.State.StateT :: (s -> m (a, s)) -> StateT s m a
11:32:41 <lambdabot> Control.Monad.State.StateT :: newtype StateT s m a
11:32:41 <lambdabot> Control.Monad.State.evalStateT :: Monad m => StateT s m a -> s -> m a
11:32:52 <SamB> that works too ;-)
11:32:54 <fasta> (That with /msg also works. )
11:33:00 <SamB> also:
11:33:03 <SamB> @where hoogle
11:33:04 <lambdabot> http://www.haskell.org/hoogle
11:33:19 <SamB> which returns more results and directly links to documentation
11:33:33 <fasta> You can also subscribe to an RSS feed... oh wait.. you can't :P
11:33:45 <SamB> RSS feed of library functions?
11:33:47 <SamB> that would be silly
11:33:55 <SamB> sometimes they remove them!
11:34:13 <newsham> when you have complex mutable state (ie a record with a map of records that have maps of ints) how do people generally code the updators?
11:34:15 <fasta> An RSS feed for API breakage would be nice.
11:34:22 <SamB> hmm, true
11:34:34 <SamB> well, actually it probably ought to be an Atom feed ;-)
11:34:36 <fasta> But it was intended as non-sense.
11:35:36 <SamB> hmm...
11:36:18 * SamB thinks of the rhyme about parsers
11:47:01 <newsham> can I deriving(Num) ?
11:49:04 <mgsloan> newsham - I don't see how
11:49:28 <newsham> data Foo = Foo { myval :: Integer } deriving(Num)
11:50:37 <eviltwin_b> no, it's not derivable, you need to instance Num Foo where ...
11:50:53 <Lemmih> newsham: If you make it a newtype, yes.
11:51:08 <eviltwin_b> yeh, newtype is a different story
11:51:41 <newsham> I cant make a separate instance Show Foo  for a newtype can I?
11:52:09 <mgsloan>  /me was imagining something like data Nat = zero | succ Nat deriving (Num) ;p
11:52:43 <newsham> msg: i can understand how in the general case it wouldnt work.
11:52:55 <newsham> i guess there would only be a few cases that would actually work
11:53:35 <mgsloan> you can make an instance for a newtype.
11:53:49 <mgsloan> that's one of its main purposes - like a type syn but you can make instances for it
11:54:52 <newsham> it said "duplicate instance declaration" when I tried.
11:55:08 <newsham> type Dollars = Integer; instance Show Dollars where show v = ...
11:55:19 <newsham> instance Show Dollars vs. Instance Show Integer
11:55:23 <mgsloan> that's a type not a newtype
11:55:45 <newsham> newtype is like type?
11:56:29 <mgsloan> sorta, in that its kinda an alias of that one field of the one constructor.  Rather than just standing for the other type, it wraps it
11:56:34 <int-e> newtype Dollars = Dollars Integer; instance Show Dollars where showsPrec _ (Dollars n) = shows n . showString "$"
11:56:51 <int-e> (oh I guess you'd rather put the $ in front)
11:57:00 <newsham> I see.  so its sort of like "data" but sort of like "type"?
11:57:05 <mgsloan> yep
12:00:43 <RemiTurk> newsham: It's sort of like a limited data: you can only use one when you could've used a type (that is, no sum- and product types) Except for some strictness properties
12:03:00 <mgsloan> oh yeah i forgot about the strictness part
12:04:33 <DRMacIver> Stupid question. What exactly does 'combinator' mean in Haskell? I keep seeing the term but no one seems to actually define it.
12:05:13 <mgsloan> From its useage I think it just means a thing that combines things :)
12:06:16 <fasta> DRMacIver: a higher order function that takes two values of some type and returns a new function, I guess.
12:06:28 <jlouis> DRMacIver, some function that combines stuff. Usually an infix function.
12:06:59 <jlouis> It doesn't have a strict definition IIRC
12:07:36 <DRMacIver> ok
12:07:39 <DRMacIver> Thanks
12:07:50 <fasta> "Note that the context is actually written by giving the path from the subtree to the root (rather than the other way round)." <- Why is it written in this way and not the other way around?
12:07:56 <fasta> http://haskell.org/haskellwiki/Zipper
12:07:58 <lambdabot> Title: Zipper - HaskellWiki
12:08:13 <fasta> I would guess it doesn't matter.
12:08:37 <fasta> If it doesn't matter it's a bit an insane way of presentation, though.
12:12:15 <sreeram> fasta, it is from the subtree to the root, so that the traversal functions are simpler
12:12:47 <fasta> sreeram: simpler, or also more efficient in big oh terms?
12:13:08 <sreeram> to implement 'up' for instance, you only need to traverse one level in the context to get to the first element
12:13:51 <sreeram> up is O(1) when it is from the subtree to the root, and it is O(h) when it is from the root to the subtree
12:15:23 <sreeram> so yes, it is more efficient to have the context represent the path from the subtree to the root
12:16:37 <fasta> sreeram: ok, that's the "glove" and "inside out" then in the paper.
12:16:51 <fasta> sreeram: I didn't understand that until I read the wiki page.
12:17:16 <sreeram> i've only read the wiki page :)
12:21:04 <paolino> how do I repeat an action n times an obtain a list of the results ?
12:21:41 <RemiTurk> @hoogle repeatM
12:21:41 <lambdabot> No matches found
12:21:51 <Lemmih> @type replicateM
12:21:52 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
12:22:04 <paolino> ok
12:22:04 * RemiTurk should print a lambdabot HOWTO
12:22:39 * RemiTurk should also think more before giving stupid answers
12:34:09 <paolino> lemmih , the action get called n times ?
12:35:04 <Lemmih> paolino: Yes.
12:36:50 <Lemmih> @seen Smerdyakov
12:36:50 <lambdabot> I haven't seen Smerdyakov.
12:45:46 <moonlite> is it possible with the help of haskells type system to ensure that an array passed to a function has a certain length?
12:46:20 <sorear> Yes.
12:46:32 <moonlite> sorear: neat, any hints?
12:46:38 <sorear> coincidentally, that is what I am working on right now.
12:46:48 <moonlite> how lucky :)
12:47:24 <Saizan> buildin' a new type ArrayWithSize?
12:47:57 <moonlite> sorear: will you post about it on haskell-libs/cafe when done?
12:47:58 <sorear> just uploaded work-in-progress file: http://members.cox.net/stefanor/Tuple.hs
12:48:05 <sorear> Yes.
12:48:10 <jlouis> sorear, is it the trick of using a phantom type as binary counters?
12:48:44 <sorear> Yes, except I'm currently at Peano.
12:49:22 <jlouis> I saw that ;)
12:49:29 <jlouis> Peano is fine.
12:49:34 <sorear> I'm using it for a computational-geometry package (to distinguish 2D and 3D vectors), and my numbers are to small for decimal to be worth it.
12:49:48 <jlouis> you can go for binary later if you need it
12:51:18 <sorear> Also my current impl uses lists (how high is the overhead for small UArrays?)
12:52:45 <sorear> (if you actually use it, use -fglasgow-exts for scoped tyvars, I gave up on the undefined :: a -> c a trick...)
13:14:17 * jlouis achieves level 2
13:14:49 <jlouis> type Combinator a = a -> a -> a ; (+/+) :: Combinator FilePath ; (+/+) a b = a ++ "/" ++ b
13:16:26 <sorear> (you trying to use ?type / ?hoogle ?)
13:16:55 <jlouis> nah, not really
13:17:01 <mauke> heh, I called it Combine
13:17:48 <sorear> Note that (FilePath, (+/+)) is a monoid
13:18:01 <GueNz> @type words
13:18:01 <sorear> ergo, +/+ should be called mappend.
13:18:02 <lambdabot> String -> [String]
13:18:54 <jlouis> sorear, the Monoid feat is only available to you upon reaching level 5 ;)
13:20:17 <Cale> What is this, the church of scientology?
13:20:19 <jlouis> sorear, ah yes. Of course. Its a group without the presence of inverses.
13:20:43 <jlouis> Cale, You've never played Dungeons and Dragons I presume
13:20:45 <newsham> aliens created monads?
13:20:51 <Cale> Actually, I have
13:21:08 <sorear> ?help remember
13:21:09 <wli> A monad is a semigroup with an identity IIRC.
13:21:09 <lambdabot> quote <nick>
13:21:09 <lambdabot> remember <nick> <quote>
13:21:09 <lambdabot> Quote somebody, a random person, or save a memorable quote
13:21:15 <Cale> back when I was in highschool
13:21:17 <jlouis> Cale, I can see the similarities, though
13:22:40 <sorear> oh, oops, no identity...
13:22:45 <Cale> hm
13:22:54 <sorear> FilePath, +/+ is merely a semigroup
13:23:05 <Cale> A monoid is a set with an associative binary operation and a unit element
13:23:07 <sorear> but there's no typeclass for that :(
13:23:13 <jlouis> the empty string wont help?
13:23:15 <sorear> +/+ is associative
13:23:35 <sorear> "X" +/+ "X" = "X/X" ; "X" +/+ "" = "X/"
13:23:53 <Cale> Yeah, it's really too bad that  "x" and "x/" aren't considered equivalent, for many reasons :)
13:24:21 <Cale> It would be really nice if every file could be treated as if it were a directory.
13:24:22 <sorear> actually, my math structures book cites concat-with-separator as a canonical example of a semigroup
13:24:53 <jlouis> interesting
13:24:55 <basti_> reiser4 is said to be able to do this - although it won't be developed anymore
13:24:56 <sorear> Cale: "" +/+ "bin" = "/bin".  Very different, even on intelligent systems
13:25:24 <Cale> sorear: well, right
13:25:34 <basti_> actually, "bin" is "./bin"
13:25:50 <Cale> So there's a left unit and a right unit and they're not the same :)
13:25:54 <Cale> (in that case)
13:26:14 <kfish> sorear: the intercalate semigroup?
13:26:34 <Cale> well, actually, .//bin is just invalid, so that won't work :)
13:26:37 <sorear> never heard that name, sorry...
13:26:52 <Cale> (or else it's equivalent to ./bin, in which case that's still not the same as /bin)
13:26:57 <sorear> Actually .//bin is valid IIRC - POSIX systems ignore redundant slashes
13:27:04 <Cale> So things aren't so nice on the left
13:27:14 <kfish> sorear, ah, from a thread back in october ...
13:27:37 <sorear> type Name = String
13:27:51 <sorear> data Path = Rel [Name] | Abs [Name]
13:28:03 <sorear> instance Monoid Path where
13:28:10 <sorear> mzero = Rel []
13:28:21 <sorear> mappend _ x@(Abs _) = x
13:28:41 <sorear> mappend (Abs foo) (Rel bar) = Abs (foo ++ bar)
13:28:52 <sorear> mappend (Rel foo) (Rel bar) = Rel (foo ++ bar)
13:28:55 <sorear> how's that?
13:29:18 <Saizan> and the slash?
13:29:23 <Cale> Interesting.
13:29:24 <sorear> Structured strings are evil.
13:29:39 <sorear> We can add the slashes in the already-evil os ffi code.
13:30:27 <sorear> (note that my paths are *lists* of strings - each string a component.)
13:31:45 <Saizan> nice
13:32:58 * mgsloan just heard about the darcs poison patch prob
13:33:11 * sorear is now working on a fuller example, to be posted
13:33:13 <sorear> the what??
13:33:38 <mgsloan> Are there plans to fix it?  Imho, the most important thing for a vcs, especially a haskell one would be to prove that it can't get into a unrecovereable state
13:34:33 <mgsloan> apparently its where a set of patches are 'unsolveable'
13:44:03 <chessguy> hi guys. i'm working on doing a monte carlo simulation of two queueing situations
13:44:03 <chessguy> http://cpp.sourceforge.net/?show=25742
13:44:04 <lambdabot> Title: #C++ Pastebin
13:44:49 <chessguy> i think what i want is something like a clockTick :: SingleLineState -> SingleLineState which simulates the passing of a unit of time
13:44:52 <chessguy> does this make sense?
13:45:36 <chessguy> i've really never done typeclasses in haskell before
13:46:07 <Cale> hmm
13:48:22 <Cale> are you going to run them both in parallel or something?
13:48:33 <Cale> I think this isn't quite the right abstraction...
13:49:07 <chessguy> oh, well i guess waht i want is maybe clockTick :: (SingleLineState, ThreeLineState) -> (SingleLineState, ThreeLineState)
13:49:33 <Cale> What exactly are you simulating?
13:49:45 <eviltwin_b> hm.  the idea was to write a simulation engine that didn't depend on the implementation so they could be tested side by side
13:49:49 <chessguy> people coming to get serviced, like at a bank or grocery store
13:50:18 <Cale> People come in and queue up in some way, and you're looking at how long it takes for an individual to get through at various loads?
13:50:47 <chessguy> one place has a single line, and three registers/tellers/whatever, and as a teller becomes available, a person from the general line comes to him.
13:50:55 <chessguy> the other place has a line for each register/teller/whatever
13:51:07 <Cale> Generalise more, and I think it will make the code more elegant.
13:51:35 <chessguy> i agree, but i'm not sure how
13:51:40 <Cale> You shouldn't be able to see the floor plan of the shop from outside
13:52:05 <Cale> The customers come in at certain times, the service station tells you when they come out.
13:52:52 <chessguy> well, i need to collect statistics like, for example, average time in a line, total average time in the system, etc.
13:53:53 <Cale> Okay, then you might need to report two things: time until serviced, and time spent being serviced?
13:54:10 <chessguy> well, those are just examples
13:54:40 <Cale> Well, you want to figure out a nice abstract way to describe what you're measuring without referencing the floor layouts.
13:55:37 <chessguy> i agree. i'd like to be able to use this simulator beyond this single problem
13:55:39 <Cale> For example, if you really only cared about total time statistics, you could just model it as a function [(CustomerID, Time)] -> [(CustomerID, Time)]
13:56:02 <Cale> mapping customers and entry times to customers and exit times
13:56:30 <Cale> (maybe it needs to take a random generator, or be in the Random monad as well)
13:57:04 <chessguy> well, i also need the average number of people in the building at a time
13:57:18 <Cale> You can compute that from there
13:57:29 <chessguy> an a couple other things which aren't coming to mind at the moment
13:57:43 <Cale> because if you have those two lists, you can work out how many people are in the building at each given time
13:58:40 <sorear> CustomerID just doesn't seem right to me...
13:58:49 <chessguy> but i won't know how much time they spent in line and how much being serviced
13:59:20 <Cale> CustomerID will just be an Integer which is incremented to mark each customer uniquely in the simulation.
14:00:36 <Cale> right, you won't, so you might want to add that to the model
14:00:40 <chessguy> ok, i need Expected number of people in the building, expected number of people waiting in line, expected total time in system, expected total time in line, and P0, P1, ..., P5, where Pi is the probability that the number of people in the building right now is i.
14:00:46 <Saizan> maybe instrad of Time you can have a Map with the data you need
14:01:33 <sorear> by creating those numbers you are preventing yourself from seeing alternatives to lines...
14:01:40 <Cale> You really want these to be streams -- laziness will keep memory consumption down if you do this right :)
14:01:43 <chessguy> it looks like i can get all of that except expected number of people waiting in line and expected time in line from the model you suggested
14:02:28 <Cale> Right, so you just need to also have the customers report the time at which they start being served
14:02:49 <chessguy> so maybe it needs to be [(CustomerID, Time, Time)] -> [(CustomerID, Time, Time)]
14:02:57 <Cale> not quite
14:03:13 <Cale> [(CustomerID, EntryTime)] -> [(CustomerID, ServeTime, ExitTime)]
14:03:20 <Cale> perhaps
14:03:28 <newsham> is there something like Data.Map that behaves like a state monad?
14:03:56 <Cale> newsham: State (Map k e) ?
14:04:39 <Cale> It's possible that you could do this quite elegantly with an appropriate monad
14:04:51 <chessguy> so then i would build up a list of customers, then send it to an instance of ServiceStation (which will need to be rewritten), and get another list back?
14:04:56 <newsham> you can also State (Arr ...)  but there's also a MArray
14:05:14 <Cale> chessguy: right
14:05:40 <Cale> If your store isn't broken, then you can even make the input list infinite, and get as much output as you'd like.
14:06:05 <Cale> Because chances are that every customer will eventually be served :)
14:06:20 <chessguy> hmm, but then wouldn't each instance of the ServiceStation just be a single function?
14:06:29 <Cale> indeed it would
14:06:37 <Cale> So you don't even need a class
14:06:57 <chessguy> that seems rather inelegant
14:07:01 <Cale> why?
14:07:06 <newsham> if I have an aggregate T that has constituents T1 and T2, and I have a State T1 a,  how can I use that State T1 a in the State T b ?
14:07:14 <chessguy> well, every instance is going to have a lot in common
14:07:27 <chessguy> but it will have parts that i'll want to vary, too
14:07:28 <Cale> Sure, and they can share what's in common
14:07:40 <Cale> You can even write functions which construct them
14:08:22 <chessguy> construct what?
14:08:24 <Cale> I would recommend separating out the bit which maps (CustomerID, ServeTime) pairs to (CustomerID, ExitTime) pairs.
14:08:33 <Cale> Construct shops of various shapes.
14:09:31 <Cale> Really, all the interesting part likely happens in the queuing, and the time for service is a bit of random noise.
14:10:15 <chessguy> there's also the matter of scheduling algorithms
14:10:22 <Cale> actually, we could generalise this even further
14:10:49 <Cale> and model a customer as  data Customer = C Integer [Event]
14:11:27 <Cale> and have an Event type which has time-labelled events which may happen to each customer at various points in the simulation.
14:12:05 <chessguy> so an event would be like getting in line, getting serviced, finishing being serviced, etc.?
14:12:06 <Cale> Then we'd just have  newtype Shop = S ([Customer] -> [Customer])
14:12:09 <Cale> yes
14:12:57 <Cale> also, at various points, you're going to want to merge lists of Customers
14:13:12 <Cale> (most likely)
14:13:23 <thief_grr> any comments on R. Bird's book?
14:13:29 <chessguy> hmm, i'm not sure what you mean by that
14:14:34 <newsham> monad state question (how to modify state of constituents): http://www.thenewsh.com/~newsham/x/quest.txt
14:14:35 <Cale> So you'll need a function  merge :: [Customer] -> [Customer] -> [Customer], which merges two streams of customers so that the first event in their list of events (which was the last to occur to them) goes in increasing order of time.
14:15:03 <chessguy> i'm not sure why i would need that
14:15:46 <Cale> well, in your two cases there, you don't
14:16:25 <newsham> is what I want "mapStateT" ?
14:16:26 <Cale> er, actually, no, you do
14:16:40 <Cale> Because people will be operated on by any one of three servers
14:17:01 <Cale> and then you'll have to re-merge the streams of people coming out of each as they leave the shop.
14:17:07 <jlouis> newsham, nah, you don't have a State Transformer in play
14:17:17 <chessguy> well, i'm not really doing that in true parallel though
14:17:39 <Cale> sure, buy you're going to want to abstract a server
14:17:54 <Saizan> adjDistance n = modify (\(Foo f1 f2) -> Foo f1 f2+n) wouldn't work?
14:18:11 <Cale> but*
14:18:24 <Saizan> s/f2+n/(f2+n)/
14:18:37 <newsham> saizan: sure, but the example isnt the question.
14:18:40 <chessguy> hmm
14:18:51 <chessguy> maybe that part will make more sense to me when i get there
14:18:53 <newsham> the question is how to use state monads for a constituent of a larger state
14:18:57 <jlouis> newsham, in your world, withField2 :: State Int a -> State Foo a has to invent some Foo
14:19:05 <Cale> newsham: modify (execState adjDistance 5) ?
14:19:10 <jlouis> since the Foo is not given to it
14:19:12 <Cale> er
14:19:19 <Cale> modify (execState (adjDistance 5))
14:19:24 <jlouis> (maybe I am just rambling)
14:19:36 <newsham> cale: so in general:   modify $ execState x ?
14:19:46 <Cale> I suppose
14:19:50 <jlouis> ?type execState
14:19:51 <lambdabot> forall s a. State s a -> s -> s
14:19:51 <Cale> er
14:19:57 <Cale> modify . execState x
14:20:06 <Cale> $ obviously won't work there
14:20:52 <newsham> modify takes a function,  (execState s)  is a function no?
14:20:55 <newsham> ?type modify
14:20:57 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
14:20:59 <Cale> well, actually, you'll have to add some additional machinery to make it act on just that field
14:21:51 <sorear> done (paths with ..)
14:22:13 <sorear> http://members.cox.net/stefanor/Path.hs
14:22:37 <sorear> same basic principle should work on DOS paths, URLS...
14:22:47 * sorear smells an abstraction opportunity
14:23:02 <newsham> modify $ (\s -> s {field= execState x (field s)})   ?
14:24:35 <chessguy> ohhhh, i get it
14:25:01 <chessguy> Cale, you're saying that not only should the ServiceStation be a stream, but each server should be a stream
14:25:20 <Cale> yeah
14:25:28 <Cale> stream transformer
14:25:28 <chessguy> a very simple stream
14:26:03 <chessguy> so pretty much the way i have it set up now is rubbish
14:26:28 <sorear> make the service station a monadic computation, which sits in an infinite loop fetching people and sending people
14:26:29 <Cale> Well, I don't know, I'm just saying how I'd do it :)
14:26:53 <jlouis> sorear, nice
14:27:04 <chessguy> sorear, right, with a list of servers, which do the same thing.
14:27:20 <sorear> data RWTree a b = RWTree [b] (a -> RWTree a b)
14:27:36 <chessguy> Cale, what i meant was, to do it this way, i need to throw out what i have so far (the pastebin)
14:27:40 <jlouis> sorear, by introducing a Rel 0 [] you got your identity ;)
14:27:44 <sorear> data RWMonad a b = (RWTree a b -> RWTree a b)
14:28:11 <chessguy> sorear, are you still talking to me or did you switch conversations?
14:28:34 <Cale> chessguy: yeah
14:28:36 <jlouis> chessguy, he is still talking to you
14:28:49 <sorear> Now i'm on generic read/write monads
14:28:55 <chessguy> what's this about a tree?
14:29:11 <sorear> RWMonad (PersonID,Time) (PersonID,Time)...
14:29:30 <sorear> a tree of possibilities, the explored part is always linear
14:29:49 <sorear> streams were abandoned for I/O long ago, too hard to program using
14:30:13 <chessguy> does anyone have a clue what sorear is talking about? :)
14:30:26 <dmead> nope =S
14:30:32 <basti_> lol
14:32:08 <chessguy> ok, so since i'm still a n00b at monads, maybe someone could help me write a simple abstraction for a server which is in an infinite loop taking people and sending them? then hopefully i could figure out the serviceStation part myself
14:32:54 <chessguy> i have data Customer = C Integer [Event], so i need something like server :: Customer -> Customer
14:33:03 <chessguy> maybe?
14:33:09 <jlouis> server = id
14:33:14 <jlouis> ;P
14:33:26 <chessguy> hm?
14:33:50 <jlouis> I am sorry I did not follow from the beginning. So I do not know the semantics you want
14:35:07 <chessguy> jlouis, what i'm doing right now is writing something to simulate, say, a cashier. all it's going to do is take a stream of customers and, for each one, pick a random amount of service time, add that to the customer's Event list, and send them on their way
14:37:36 <chessguy> anyone still with me?
14:38:02 <jlouis> so your problem is that the Rng lives inside IO?
14:38:22 <chessguy> the problem is, i don't have a clue what i'm doing :)
14:39:21 <jlouis> we could easily create a function cashier :: [Customer] -> IO [Customer] that does what you want
14:39:50 <chessguy> [17:22] <sorear> make the service station a monadic computation, which sits in an infinite loop fetching people and sending people
14:40:05 <chessguy> this is what i'm trying to do, except with the servers (first) instead of the service stations
14:41:08 <sorear> I think I'm just generalizing too much.
14:41:21 <chessguy> sorear, no, i like your idea
14:41:56 <jlouis> sorear, so let me get your idea straight. You would let the customers be an inifinite list?
14:41:59 <chessguy> it's a great way for me to learn about monads
14:42:14 <chessguy> while pretending to do my homework :_
14:42:15 <chessguy> :)
14:42:37 <sorear> I want a monad with operations that fetch a customer, and send a customer.
14:43:17 <sorear> Externally, of course, it uses infinite lists (or something equivalent like continuations), but internally it is a simple loop
14:43:35 <sorear> serviceStation = repeatM $ do customer <- admit
14:44:07 <sorear>                                 customer' = service customer
14:44:19 <sorear>                               send customer
14:44:26 <chessguy> what's admit?
14:44:48 <sorear> it would be an abstract action that lets one customer in
14:45:05 <sorear> "this ticket admits one" definition
14:45:28 <sorear> internally it would remove and return one (CustomerID,Time)
14:46:23 <chessguy> hmm
14:46:32 <chessguy> i assume you mean send customer'
14:46:40 <jlouis> yup
14:46:45 <sorear> Yeah :)
14:46:46 <chessguy> @type repeatM
14:46:48 <lambdabot> Not in scope: `repeatM'
14:46:59 <chessguy> @hoogle repeatM
14:46:59 <lambdabot> No matches found
14:47:06 <jlouis> you have to define that one yourself
14:47:06 <sorear> Oh, right, that's a proposed extention
14:47:20 <sorear> repeatM is (sequence_ . repeat)
14:47:27 <sorear> ?type (sequence_ . repeat)
14:47:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
14:47:58 <dons> moin
14:47:58 <sorear> It takes an action and returns an action that infinitely repeats the argument
14:48:08 <sorear> moin?
14:48:11 <Nafai> Hello dons
14:48:24 <jlouis> sorear, german for "hi" or something like that
14:48:39 <chessguy> hi dons
14:49:43 <chessguy> so don't you need braces around those three actions?
14:50:03 <jlouis> not if they align properly
14:50:14 <jlouis> then the indentation specifies the scope
14:51:25 <sorear> except, I messed up the indentation (thanks ircII)
14:51:32 <chessguy> so what's the type of serviceStation?
14:51:45 <sorear> ServiceMonad ()
14:52:35 <chessguy> so in main, i'd do sm <- ServiceStation; sm >>= listOfCustomers
14:52:38 <chessguy> like that?
14:53:45 <sorear> ServiceMonad is not IO, so you'd need a converter of some sort
14:54:02 <sorear> runServices :: ServiceMonad () -> [Customer] -> [Customer]
14:54:08 <chessguy> oy, this is getting to be way over my head
14:54:10 <sorear> now *those* are lazy lists
14:54:27 <Nafai> chessguy: I'm feeling like that about Haskell in general :)  It hasn't yet clicked for me.
14:55:19 <chessguy> so i'd do sm <- ServiceStation; listOfCustomers' <- sm listOfCustomers
14:55:20 <chessguy> ?
14:55:29 <chessguy> err
14:55:32 <chessguy> that's not right
14:57:24 <chessguy> am i close?
14:58:13 <sorear> yes
14:58:16 <newsham> ok, I worked through and solved my "withField2" question.  I want to know if this could be made simpler or if I'm duplicating anything in the std libs:  http://www.thenewsh.com/~newsham/x/quest.txt
14:58:28 <twobitsprite> ghci doesn't let you define types?
14:58:41 <newsham> it was a bit more complicated than I thought, but cale's runState suggestion helped a bit
14:58:42 <sorear> No
14:59:05 <twobitsprite> does hugs?
14:59:30 <chessguy> listOfCustomers' = runServices sm listOfCustomers
14:59:35 <chessguy> ?
14:59:48 <sorear> that is correct
15:00:13 <lrrrr> hi there
15:00:27 <chessguy> and then i need to something similar for the servers?
15:01:12 <lrrrr> does anybody know why there's no function for modifying a single element in Data.ByteString ?
15:01:45 <sorear> newsham: looks /quit
15:02:28 <chessguy> oh, so ServiceMonad needs to be defined with admit, service, and send?
15:02:37 <emu> lrrrr: modifying?
15:02:42 <jlouis> chessguy, yes
15:02:54 <newsham> my code killed sorear?
15:02:58 <lrrrr> emu: yeah, like (//) for arrays
15:03:15 <chessguy> is that all i need to define for it?
15:03:47 <jlouis> chessguy, I think sorears solution, while general, is overkill
15:04:00 <audreyt> lrrrr: you may have to define oe yourself with take/drop/concat
15:04:26 <chessguy> jlouis, maybe so, but it's a great opportunity to 1.) learn about monads, and 2.) write a general monte carlo simulator that can be used outside this particular problem
15:04:27 <jlouis> lrrrr, and then you must beware that it may become very slow.
15:04:51 <emu> splitAt and concat probably best.  what are you trying to accomplish?
15:05:29 <audreyt> splitAt will need another "tail" call
15:05:37 <jlouis> chessguy, yes. For ServiceMonad to be a monad, you must define its Monad instance. In particular return and (>>=) and you must check that it obeys the monad laws
15:05:54 <audreyt> not sure if it's faster than take/drop; different probably negligible
15:06:26 <lrrrr> well ii need a very efficient implementation..
15:06:42 <chessguy> oh, so it neads to be an instance of the Monad class
15:06:47 <lrrrr> i thought about doing something with ForeighPtr underneath ByteString
15:06:49 <jlouis> lrrrr, what is it going to be used for?
15:06:52 <Cale> What's this monad you're discussing?
15:07:08 <chessguy> Cale, we're talking about writing the service station as a monad
15:07:18 <lrrrr> well i have an iterative algorithm.. while it runs it uses a mutable array
15:07:32 <lrrrr> i.e. array is modified on each iteration
15:07:45 <astrolabe> lrrr: could you hold the data in a diffArray and then write it out to a ByteString when you're done?
15:07:48 <Cale> what does  return x  do?
15:08:08 <chessguy> with functions admit, service, and send which, respectively, let a customer into the station, service them, and send them out of the station
15:08:29 <Cale> hmm
15:08:30 <chessguy> Cale, i'm guessing that's where your merge thing comes in
15:09:02 <Cale> I might see how this is an arrow, but I don't quite get what it would be as a monad.
15:09:13 <chessguy> oh
15:09:17 <chessguy> well, don't ask me
15:09:18 <chessguy> [17:58] <chessguy> oh, so ServiceMonad needs to be defined with admit, service, and send?
15:09:18 <chessguy> [17:58] <emu> lrrrr: modifying?
15:09:18 <chessguy> [17:58] <jlouis> chessguy, yes
15:09:18 <chessguy> [17:58] <newsham> my code killed sorear?
15:09:18 <chessguy> [17:58] <lrrrr> emu: yeah, like (//) for arrays
15:09:21 <chessguy> whoops
15:09:27 <lrrrr> hmm diffArray looks like the right thing here..
15:09:52 <chessguy> i'm trying to follow this suggestion: <sorear> make the service station a monadic computation, which sits in an infinite loop fetching people and sending people
15:10:32 <chessguy> you don't think this is a good idea?
15:11:00 <Cale> I'm not sure that it's really monadic, I'd have to think about it.
15:11:34 <Cale> An Arrow would certainly be appropriate -- we're working with stream transformers. Yampa etc. do almost exactly this sort of thing.
15:11:45 <chessguy> you're saying you don't think it satisfies the monad laws?
15:12:02 <lrrrr> astrolabe: but how can I apply diffArray to ByteString? Looks like ByteString has to be an instance of MArray to do this..
15:12:08 <Cale> I just don't see what bind and return are going to do.
15:12:29 <Cale> I would recommend the use of a monad for generating random values.
15:12:49 <chessguy> bind (i think) is what would take the customer, make sure they wait in the appropriate line, get serviced, handle their event-stamping, and merge them into a list at the end
15:12:53 <Cale> But I don't think [Customer] -> [Customer] is a monad -- in particular, there's no return value.
15:13:11 <Cale> anyway, I have dinner :)
15:13:18 <chessguy> augh
15:13:21 <newsham> eats coast?
15:14:02 <chessguy> jlouis, did you understand what sorear was saying?
15:14:16 <jlouis> chessguy, parts of it
15:14:19 <jlouis> not the whole thing
15:14:29 <chessguy> do you think it's monadic?
15:14:33 <jlouis> in particular, I am wondering about return and (>>=) as well
15:16:30 <jlouis> So its hard to say if it is monadic, unless you come up with a specific return and bind
15:16:40 <chessguy> can't the return type just be [Customer]?
15:17:28 <eviltwin_b> well, technicallyy it already is a monad (list monad to be specific) but I don't *think* that's what he meant
15:18:48 <ihope> Monads have to be type constructors.
15:19:00 <ihope> [Customer] -> [Customer] is not a constructor.
15:20:28 <ihope> (In expression-space, it would be valid as part of a "do" block, but isn't, for the odd reason that Customer is not a list.)
15:20:46 <RemiTurk> 'night
15:20:50 * eviltwin_b thought that was the type of the operation, not of its result.  he hasn't been paying very close attention
15:21:26 <chessguy> to simplify, let's deal with servers
15:21:33 <chessguy> can a cashier be modelled as a monad
15:22:05 <astrolabe> Is a cahier like a container?
15:22:07 <chessguy> we have data Customer = C Integer [Event]
15:22:32 <chessguy> i want the cashier to take a stream of Customers, and for each one, add an event to its list
15:23:01 <astrolabe> Why do think it might be a monad?
15:23:18 <chessguy> i don't know, it was suggested by someone else
15:23:47 <chessguy> <sorear> make the cashier a monadic computation, which sits in an infinite loop fetching people and sending people
15:23:56 <jlouis> Well, I usually tend to start small and then build up
15:24:01 <astrolabe> I guess you could use a state monad to hold the customers
15:24:08 <sjanssen> for a Customer to be a monad, it must have kind * -> *, ie it must take a type variable
15:24:20 <chessguy> i'm not talking about the Customer being a monad
15:24:52 <astrolabe> for a Cashier to be a monad, it must have kind * -> *, ie it must take a type variable
15:25:01 <astrolabe> :)
15:25:28 <chessguy> can it use Customer or [Customer] as the type variable?
15:25:44 <astrolabe> it has to be able to use any type I think
15:25:45 <chessguy> i really don't know what i'm doing with monads, just trying to figure out the best model for this situation
15:26:05 <chessguy> oh
15:26:15 <sjanssen> chessguy: no, it must be something like "data Customer a = Customer ... stuff with a ...
15:26:24 <astrolabe> chessguy: your idea is expressed quite statefully.  Monads are often helpful for that.
15:26:49 <chessguy> what if the cashier returns the time that it finishes servicing the customer
15:27:41 <astrolabe> Cashier doesn't seem like a monad to me, but I don't know what you are thinking.
15:28:00 <chessguy> maybe not, i don't know
15:28:01 <sjanssen> chessguy: I think you want a Store monad
15:28:13 <chessguy> sjanssen, how so?
15:29:01 <jlouis> or an RW
15:29:23 <jlouis> maybe a Reader/Writer could be what sorear was hinting for
15:29:28 <astrolabe> I think you should either learn more about monads before you decide, or code it without monads.
15:30:41 <chessguy> well, i was hoping to do this as an exercise in learning monads
15:31:07 <chessguy> but i guess not if it's a good fit for it
15:31:24 <chessguy> err, not if it's NOT a good fit
15:32:09 <chessguy> but then i'm back to asking what IS a good way to model this
15:32:12 <LoganCapaldo> Is State a monad or a monad transformer?
15:32:24 <jlouis> If you can avoid using a monad, you probably have a purely functional program.
15:32:32 <jlouis> State is a Monad
15:32:34 <sjanssen> LoganCapaldo: State is a monad, StateT is a monad transformer
15:32:39 <LoganCapaldo> ok
15:32:44 <LoganCapaldo> then I don't get it :)
15:33:09 <chessguy> LoganCapaldo, join the crowd
15:33:16 <jlouis> A Monad Transformer lets you have monads inside monads and gives you the tools to manipulate either the outer or the inner monad
15:35:14 <LoganCapaldo> Is there a version of this: http://www.nomaware.com/monads/html/statemonad.html that dumbs it down more?
15:35:16 <lambdabot> Title: The State monad, http://tinyurl.com/yldt3d
15:37:05 <sjanssen> LoganCapaldo: I haven't seen such a document, perhaps #haskell can clear things up?
15:37:57 <greentea> Hi all.
15:38:24 <dons> morning greentea
15:38:25 <LoganCapaldo> sjanssen: Perhaps. I'm not really sure what questions to ask. I get it on the level of you just carry around an extra parameter, but beyond that I'm confused by the impl, especially the code for >>=
15:38:32 <dons> ?users
15:38:32 <lambdabot> Maximum users seen in #haskell: 276, currently: 252 (91.3%), active: 30 (11.9%)
15:38:56 <newsham> dons: is there an easier way to do this?  am I duplicating any std libs?  http://www.thenewsh.com/~newsham/x/quest.txt
15:39:26 * dons inspects
15:39:35 <newsham> (in particular the "withField" stuff)
15:40:27 <dons> so you could common up some of that into:
15:40:28 <dons> withState :: (s -> s) -> State s a -> State s a
15:40:28 <dons> withState f m = State $ runState m . f
15:40:48 <dons> maybe?
15:40:53 <dons> but otherwise, looks ok
15:41:03 <dons> Cale: any suggestions for newsham ?
15:41:31 <newsham> bu withState runs from State s to State s and I want State a to State b (?)
15:41:40 <newsham> (I'm not understanding somethign probably)
15:42:01 <newsham> oh, i think i get it.
15:42:21 <dons> ah right
15:42:36 <dons> so that's close to:
15:42:37 <dons> mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
15:42:37 <dons> mapState f m = State $ f . runState m
15:42:56 <newsham> mapState also uses the same state for both.
15:43:05 <newsham> i'm going from an inner state to an encapsulating state
15:43:11 <dons> ah ok.
15:43:14 <dons> well you're on your own :)
15:43:22 <newsham> fair enough
15:43:31 <newsham> xiexie
15:44:21 <chessguy> hey dons, do you want to give a shot at suggesting a way of modelling my problem?
15:44:52 <dons> let me get some coffee...
15:44:59 <chessguy> lol, ok
15:46:04 <chessguy> @localtime dons
15:46:09 <lambdabot> Local time for dons is Mon Dec  4 10:42:35 2006
15:46:28 <chessguy> goodness, no wonder he needs coffee
15:46:41 <chessguy> at that ungodly hour of the morning
15:47:18 <chessguy> and a monday, no less!
15:50:27 <zptao> whats the name of the haskell thing that allows for using multiple cores/processors easily and scalably?
15:50:44 <jlouis> STM?
15:50:54 <zptao> dons was talking about it a lot
15:51:03 <jlouis> Software Transactional Memory?
15:51:07 <TomMD> no
15:51:28 <jlouis> Referential Transparency?
15:51:29 <dons> zptao: the smp runtime?
15:51:38 <zptao> no the other thing
15:51:41 <zptao> something parallel
15:51:46 <dons> dph?
15:52:33 <dons> ?where+ dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
15:52:33 <lambdabot> Done.
15:53:16 <dons> ?where+ smp http://www.haskell.org/ghc/dist/current/docs/users_guide/sec-using-smp.html
15:53:16 <lambdabot> Done.
15:53:27 <dons> ?where+ stm http://haskell.org/haskellwiki/Software_transactional_memory
15:53:28 <lambdabot> Done.
15:54:55 <chessguy> ok dons, you ready for this?
15:55:40 <dons> not yet...
15:55:44 <dons> but post, and i'll look soon
15:56:09 <chessguy> the basic problem is to do a monte carlo simulation which compares two banks/stores/whatever. each of them has 3 tellers/registers/whatever. one has a single common queue. the other has a queue for each teller/register/etc.
15:57:01 <chessguy> what i'd like to do is model this as flexibly as possible, so that i can use it to compare a lot of different things, like number of registers, number of queues, scheduling algorithms, etc.
15:57:34 <chessguy> Cale's idea was to have something like:
15:57:34 <chessguy> data Customer = C Integer [Event]
15:57:35 <chessguy> data Event = E (String, Int)
15:57:47 <chessguy> where the Int is a "timestamp" for when the event occurred.
15:58:05 <Cale> lisppaste2: url
15:58:05 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
15:58:10 <chessguy> and each event is something like "entered the store", "got in line", etc.
15:58:18 <Cale> erm
15:58:50 <chessguy> i think lisppaste is down
15:59:08 <jcreigh> rafb.net/paste
16:00:55 <Cale> http://rafb.net/paste/results/YCpJsG22.html
16:00:59 <Cale> something like that
16:01:28 <dons> Cale: you're getting quoted in blog space now, http://monad.carnalreason.org/wordpress/?p=19
16:01:30 <lambdabot> Title: A kick in the monads » foldr, foldl
16:02:44 <Cale> hehe
16:03:46 <chessguy> hmm
16:04:47 <chessguy> so a shop takes a list of customers, with their attached lists, and returns a RNG with a new list of customers?
16:05:21 <Oejet> Where did the mmap function go?
16:06:33 <greentea> Do you mean MapM?
16:06:33 <Cale> chessguy: Well, a value of type (Rand StdGen a) is like a random variable with type a
16:06:49 <Cale> (using StdGen's to generate the random numbers)
16:07:02 <Cale> I should really update the haskell wiki with a new MonadRandom
16:07:06 <dons> Oejet: mmap?
16:07:16 <dons> you mean like Data.ByteString.mmap?
16:07:33 <chessguy> i don't see why it doesn't just return [Customer e]
16:07:38 <dons> Cale: you should package them up and get them into mtl ....
16:07:53 * dons encourages Cale to write non-wiki based software
16:08:41 <Cale> It's always my hope that someone else will deal with the bureaucracy of popularising my software :)
16:08:52 <dons> thta's what 'mkcabal' is for ...
16:09:05 <dons> of course. having a source file would be good too
16:10:12 <dons> ok, now everyone can suspend their disbelief:
16:10:13 <dons>   PowerShell is based on objects called cmdlets, otherwise known as monads for those of you more
16:10:16 <dons>   familiar with Haskell and functional languages, ... The scripting capabilities are beyond that of
16:10:19 <dons>   any scripting language I've ever used
16:10:51 <Cale> That sounds like a misuse of the 'monad', because I can't imagine any way in which 'cmdlet' could mean the same thing.
16:10:58 <Cale> of the word
16:11:02 <Excedrin> powershell aka monad shell
16:11:29 <dons> sounds like someone really did google 'monad' and get confused. that's the first written case I've found
16:11:53 <Cale> Can cmdlets be considered functors?
16:12:18 <dons> monomorphically-typed expression maybe..
16:12:28 <Cale> I really dislike the way that people confuse 'monad' with 'monadically typed value'
16:12:41 <Excedrin> why monomorphically-typed?
16:13:18 <dons> i doubt that the shell provides for parametrically polymorphism, just guess though
16:13:21 <Saulzar> What is a monadically typed value?
16:13:25 <dons> (i.e. it'd be al String -> String)
16:13:25 <chessguy> ok, time to get out of here for a while. thanks for the help, guys. i'll be back in a couple hours
16:13:34 <Cale> Saulzar: a value of type 'm a' for some monad m
16:13:41 <Saulzar> Ah..
16:13:43 <dons> > return 'x' :: Maybe Char
16:13:44 <lambdabot>  Just 'x'
16:14:02 <Cale> Maybe, List, IO, Either String, etc. are monads
16:14:09 <Cale> They take types to other types.
16:14:12 <Saulzar> I see what you mean :)
16:16:30 <Oejet> dons: Yes, but I do not see it in Data.ByteString.mmap on http://haskell.org/ghc/docs/latest/html/libraries/.
16:16:32 <lambdabot> http://tinyurl.com/hxrk7
16:17:28 <Oejet> Do you really think this tinyurl from lambdabot is worth it?
16:17:49 <dons> Oejet: it was removed, to improve portability. mmap is currently available in the win32 package, and i'll add it to the unix package too
16:17:50 * jcreigh finds it kind of annoying
16:17:56 <Cale> Why doesn't it report the title there?
16:17:58 <LoganCapaldo> Ooooooooooo
16:18:03 <dons> but the code is commented out in Data.byteString, so you can steal it if you want
16:18:15 <LoganCapaldo> runState <code> initialState yes?
16:18:24 <Cale> LoganCapaldo: yes
16:18:26 <LoganCapaldo> this is what was throwing me off
16:18:31 <dons> :t Control.Monad.State.runState
16:18:33 <lambdabot> forall s a. State s a -> s -> (a, s)
16:18:39 <dons> (personaly I think its the wrong way around...)
16:18:41 <LoganCapaldo> I missed that initial state bit
16:18:49 <Cale> > runState (do { x <- get; put (x + x); return x } ) 10
16:18:50 <lambdabot>  (10,20)
16:18:54 <dons> since the initial state is almost always smaller than the code fragment
16:19:07 <LoganCapaldo> I couldn't figure out how it was ever supposed to actually evaluate the values
16:19:07 <eviltwin_b> <Cale> Why doesn't it report the title there?
16:19:12 <eviltwin_b> the trailing dot confused it?
16:19:20 <dons> > (`runState` 10) $ do x <- get; put (x + x); return x
16:19:21 <lambdabot>  (10,20)
16:19:28 <Cale> eviltwin_b: hmm
16:19:36 <LoganCapaldo> Hence my lack of understanding of the state monad
16:19:36 <Cale> http://haskell.org/ghc/docs/latest/html/libraries/
16:19:38 <lambdabot> http://tinyurl.com/hxrk7
16:19:42 <Cale> nope
16:19:43 <dons> jcreigh: ok. i'll increase the length cutoff for enabling tiny-urls
16:19:47 <eviltwin_b> huh
16:19:50 <dons> to say, 60 or 80 chars
16:20:03 <Cale> dons: do you get why it's not getting the page title there?
16:20:24 <dons> possibly the title isn't inside the first 256 bytes?
16:22:42 <jcreigh> dons: the open tag is, but the close tag is not.
16:23:39 <Cale> Maybe get 1k of the file?
16:24:34 <Cale> The tinyurl reporting is much more irritating when there's no title reported.
16:29:14 <dufflebunk> Are basic statistical functions like average and standard deviation defined in any of the standard libraries?
16:29:26 <Cale> no
16:29:51 <dufflebunk> Ok, thanks. That would explain why I couldn't find them.
16:30:16 <dons> do we have any statistics packages?
16:30:54 <Oejet> dons: Thank you.
16:31:03 <Saulzar> Does the ndp stuff work on ghc 6.6? (When it mentions "current development version"?) It looks pretty exciting to me.
16:31:14 <dons> Saulzar: needs ghc head, iirc
16:31:31 <dons> its very exciting :) running array programs transparenty on 40 cores is nice
16:31:57 <dons> should kick the nbody shootout benchmark along .... ;)
16:32:40 <dons> and is ocaml really not going to support smp?
16:32:58 <dons> (blog rumours might not be trusted here, I guess)
16:33:14 <Saulzar> Not last I checked
16:33:38 <dons> i know it doesn't currently, but i see rumours saying they don't plan on adding it either
16:33:49 <dons> which seems kind of  .. um ... fatal..
16:33:56 <Saulzar> 40 core machines aren't exactly commonplace just yet, I might see if I can get one with 2 for my next machine though :)
16:34:10 <dons> 2 cores are common though
16:34:16 <dons> and you can buy 16 core mips boxes for 3k
16:34:25 <dons> or 16 core amd64's for 30 k
16:34:55 <dons> so by 2010 I'd imagine 8 core machines will be fairly widespread
16:36:13 <jcreigh> Doesn't the PS3 have something like eight cores?
16:36:21 <jlouis> 1 core
16:36:32 <jlouis> jcreigh, the PS3 is too special in this regard
16:36:44 <jlouis> you need to apply another kind of thought to make that go through
16:37:23 <mgsloan> it's like 1 general purpose core and a bunch of special purpose cores that are really good at math
16:37:34 <jcreigh> ah
16:37:54 <dons> mgsloan: like one of those 512 core fpu's  I read about last week?
16:38:10 <dons> ?bot
16:38:38 <lambdabot> :)
16:38:47 <dons> http://haskell.org/ghc/docs/latest/html/libraries/ test
16:38:58 <dons> http://haskell.org
16:38:59 <lambdabot> Title: Haskell - HaskellWiki
16:39:07 <dons> ok. that'll do.
16:39:08 <mgsloan> heh, maybe.  If it's like an fpga except where each cell is a very minimal core, then they jacked my idea i had about 4 years ago
16:39:14 <dons> the tiny-url threshold is 65 chars now
16:39:29 <mgsloan> nice
16:39:38 <jcreigh> dons: thanks
16:40:08 <jlouis> jcreigh, its a single in-order 3.2 ghz core and 6 SIMD Vector cores able to work in a pipeline structure. 1 Vector core is disabled (to increase yield) and 1 is for security apparently
16:41:13 <jcreigh> jlouis: what does "yield" mean in this context, and how does disabling a core increase it?
16:42:02 <jlouis> when you press a wafer with chips on, some are going to be defect. If you allow up to one vector core to be defect the yield (% of chips you get from the wafer that works) increases)
16:42:27 <jlouis> press is wrong here. But "create"
16:42:46 <jlouis> so it is a question of economy
16:44:24 <jcreigh> jlouis: that's really interesting. I had not realized that making cores was hit-and-miss enough to make that optimization worthwhile.
16:44:34 <jlouis> it is
16:44:48 <jlouis> though yields are a secret nobody will disclose
16:45:07 <jcreigh> well, I hope they have a good test suite. :)
16:45:18 <jlouis> its the same with ghz speeds. If a chip fails at 3.2 but works at 2.4, its sold as a 2.4
16:47:41 <Cale> The case with Celerons was interesting. Many of the Celeron processors worked at much higher speeds but were marked down because Intel wasn't producing enough low-quality chips to compete in the lower-end market.
16:48:33 <dons> ah, that's called something .... umm.. in advertising.
16:48:46 <jlouis> differentiated sales
16:48:56 <dons> its like how nestle sells the same instant coffee in high end and ugly jars, to appeal to different markets
16:49:03 <dons> you have to make the low end unattractive
16:49:05 <dons> jcreigh: ah yes
16:49:32 <kfish> http://blog.kfish.org/bullshit/instant-skim-latte.html
16:49:33 <lambdabot> Title: Conrad Parker
16:49:42 <jlouis> yeah, the instant-coffee is the same
16:49:57 <jlouis> but the canister is apparently very differently priced, hehe
16:50:04 <dons> interesting kfish
16:50:04 <emu> it's called segmentation
16:51:51 <jlouis> since GHC6.6 is unicode, I guess you can't use the ParserCombinators to parse binary files anymore
16:52:11 <dons> not sure about that jlouis
16:52:32 <dons> haven't heard anyone complain yet..
16:52:38 <jlouis> I am thinking about rolling my own type Parser a :: [Word8] -> Maybe (a, [Word8])
16:52:48 <dons> why not use the bytestring parsec?
16:52:53 <dons> it'll double your pleasure
16:52:55 <kfish> doesn't 6.6 just support utf-8 source, but library support for unicode is a different matter?
16:53:02 <dons> ?where bytestring-parsec
16:53:02 <lambdabot> I know nothing about bytestring-parsec.
16:53:04 <dons> kfish: yeah
16:53:13 <dons> ?where bytestring-parser
16:53:14 <lambdabot> I know nothing about bytestring-parser.
16:53:20 <jlouis> oh, that is interesting
16:53:28 * jlouis spanks lambdabot 
16:53:37 <dons> ?where bytestringparser
16:53:38 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
16:53:46 <jlouis> WROOOM
16:54:08 <emu> is there a mode you can run ghci to support really-fast compilation speed
16:54:12 <jlouis> that must be darcs get-able
16:54:21 <Cale> http://www.dangermouse.net/esoteric/intelligentdesignsort.html
16:54:23 <Cale> haha
16:54:23 <lambdabot> Title: DM's Esoteric Programming Languages - Intelligent Design Sort
16:54:37 <dons> emu, fast ghci interpretation?
16:54:49 <dons> emu, more details please...
16:55:12 <emu> well, i'm just getting a bit impatient at ghci :load times
16:55:28 <dons> emu, how many modules are you loading?
16:55:43 <dons> you can compile them once with ghc, and then load just the bits that change, that should be faster turnaround
16:55:46 <emu> lately been getting like 3-4 at a time when i :load, it seems
16:56:05 <emu> hmm, so it will be faster if i run a ghc --make every so often?
16:57:25 <jlouis> echo "Add .cabal to ByteStringParser" >> TODO
16:57:28 <emu> ah, cool
16:57:46 <emu> I see. I never really noticed this before, because when I did batch compiles it was with Cabal.
16:57:50 <jlouis> dons, it looks cool. Thanks!
16:58:23 <dons> ok, today's big story: http://programming.reddit.com/info/thv9/comments
16:58:24 <lambdabot> Title: Halfs: a new filesystem for Linux (written in Haskell) (reddit.com)
16:59:28 <jlouis> Cale, that is _too_ cool
17:01:40 <jlouis> ok, Isaac... That is too insane
17:01:50 <Axioplase> err.. having a small typing error.. I'm trying to write down fact using StateT... I quite don't get where it actually fails... http://rafb.net/paste/results/PTXo4342.html
17:02:16 <dons> jlouis: but its a commercial tool, as well. that just rocks, don't you think?
17:02:44 <dons> ?where+ rafb http://rafb.net/paste
17:02:44 <lambdabot> Done.
17:03:13 <jlouis> dons, I sure think it rocks
17:04:22 <dons> Axioplase: so you know that you're not applying 'a' to the initial state?
17:05:13 <dons> Axioplase: also, you don't mean to use the Maybe monad in there, do you...
17:05:18 <Axioplase> dons: why should I apply "a" ?
17:05:57 <Axioplase> dons: yes I do mean to use the Maybe monad here... he who does more, does less..(at least, I figured out it'd be a good training)
17:06:11 <dons> ok :)
17:06:43 <Excedrin> this halfs page could use a little more detail about the filesystem part, is there anything interesting about it?
17:06:46 <dons> f (return (r-1)) -- wrong
17:06:56 <dons> Excedrin: the implementation is there
17:07:25 <Excedrin> I'd rather not read that to find out that sort of thing
17:07:28 <Saulzar> r <- k  is trying to use the maybe monad (since k is of type Maybe Int)
17:07:30 <dons> I think the interesting thing is that its supposed to be a simple implementation and easy to reason about
17:07:34 <dons> but check the haskell workshop slides
17:07:39 <dons> (they're linked to on the wiki page)
17:07:42 <Axioplase> if I got it well, that liftIO takes an IO () and says *hop* it's now ok to use as a Maybe a (well, as the StateT, not Maybe)..
17:07:43 <Saulzar> But then put (x*r) is trying to use the StateT monad..
17:07:43 <Excedrin> I looked at those already
17:08:19 <Axioplase> Saulzar: ha... yes...
17:14:52 <Excedrin> dons: it's cool that it's small; I wonder what OS they're targetting
17:15:34 <dons> I think they have their own in house system (and webserver, and ...)
17:15:45 <dons> a hardended linux maybe?
17:17:19 <Excedrin> "The core is an assured platform consisting of the Haskell environment running on a real-time separation kernel."
17:17:24 <Cale> Axioplase: liftIO takes an IO a and turns it into an m a where m is some stack of monad transformers over IO.
17:17:30 <Excedrin> sounds like interesting work
17:17:47 <Cale> @type Control.Monad.Trans.liftIO
17:17:49 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
17:18:01 <Cale> Maybe is not a MonadIO
17:18:12 <sorear> MaybeT is
17:18:20 <Cale> MaybeT IO is
17:32:54 <dons> oh, new Mark Chu-Carroll story, http://scienceblogs.com/goodmath/2006/12/building_datatypes_in_haskell_1.php
17:32:56 <lambdabot> Title: Good Math, Bad Math : Building Datatypes in Haskell (part 1), http://tinyurl.com/yez2c9
17:33:38 <dmead> are there any completed implementations that run on the jvm?
17:33:45 <dons> of haskell?
17:33:56 <dons> there have been in the past, but nothing running atm, that I know of
17:33:57 <dmead> yea
17:34:01 <dmead> k
17:34:05 <dons> though yhc might almost be there
17:34:08 <dmead> hmm
17:34:08 <dons> it runs on .Net, iirc
17:34:23 <dmead> ah
17:35:49 <Axioplase> Humm.. How am I supposed to compile with ghc a file using System and Control.Monad.State ?
17:36:05 <Axioplase> ghc -o foo foo.hs doesn't seem enough...
17:36:08 <dons> --make
17:36:39 <Axioplase> great ! thanks
17:37:02 <dons> (its adding a -package mtl and -package haskell98 for you, I think)
17:43:29 <dons> mmm, http://programming.reddit.com/info/thzy/details
17:43:31 <lambdabot> Title: Monads in Ruby (reddit.com)
17:43:57 <LoganCapaldo> woah
17:44:23 <LoganCapaldo> thats not supposed to be known of yet
17:44:26 <LoganCapaldo> lol
17:45:42 <dons> LoganCapaldo: ah its you :) oops!
17:45:46 <dons> it just turned up in my rss
17:46:07 <dons> sorry if I preempted that.
17:46:12 <LoganCapaldo> That's some hard core rss you got there
17:46:18 <LoganCapaldo> No its ok
17:46:25 <LoganCapaldo> I was hoping to live in obscurity ;)
17:46:30 <dons> heh
17:46:35 <Cale> LoganCapaldo: hmm, how are you going to disambiguate the different available monads?
17:46:46 <dons> oh, you posted it like 15 minutes ago?
17:46:50 <LoganCapaldo> yeah
17:47:01 <dons> hehe. hardcore rss for sure, it seems
17:47:29 <LoganCapaldo> Cale: By doing ridiculously ugly things like SomeModuleNamedAfterAMonad.bind(...
17:47:45 <Cale> hrm
17:48:04 <Cale> Yeah, I've been rather unhappy with the implementations of monads I've seen in OO languages so far.
17:48:31 <dons> Cale: about the best non-haskell impl. so far is ocaml. but that needs preprocessor support
17:48:42 <dons> do we know of anything better?
17:48:44 <Axioplase> LoganCapaldo: you wrote that ruby/monad ?
17:48:46 <dons> oh, Clean's is rather good
17:49:08 <Cale> Well, I'm sure you can do a good job in any language with typeclasses.
17:49:09 <LoganCapaldo> Axioplase: ruby/monad?
17:49:14 <mgsloan> yes, I'd say it has a rather clean implementation (du dun tish)
17:49:31 <Axioplase> LoganCapaldo: Monads in Ruby.. that article..
17:49:37 <LoganCapaldo> yes
17:49:55 <LoganCapaldo> if you mean the one dons just posted
17:50:02 <dons> Cale: yeah, so that means haskell, clean and mercury, I suppose
17:50:04 <dons> :)
17:50:25 <LoganCapaldo> There's another one floating ptut ehre that I link to
17:50:44 <Cale> It feels like you should be able to do a better job in OO languages with an abstract base class or an interface though.
17:51:11 <Axioplase> my mistake. I thought it was http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html (though I'll read yours too)
17:51:14 <lambdabot> Title: Monads in Ruby, Part 1: Introduction - Moonbase, http://tinyurl.com/d725u
17:51:35 <dons> ?wiki Monad
17:51:36 <lambdabot> http://www.haskell.org/haskellwiki/Monad
17:51:36 <Cale> Does Ruby have parametric polymorphism yet?
17:51:39 <dons> has the most complete list I know of
17:52:01 <LoganCapaldo> OTOH, I did do this: http://moonbase.rydia.net/mental/blog/programming/ml-style-qualified-unions-for-ruby
17:52:27 <lambdabot> Title: ML-Style Qualified Unions for Ruby - Moonbase, http://tinyurl.com/vclox
17:52:31 <Cale> hmm
17:52:52 <LoganCapaldo> which has to be the greatest abuse of syntax I've ever perpatrated on Ruby
17:53:38 <Cale> I wonder if there would be a way to use Ruby's metaprogramming stuff to implement a decent type system
17:54:38 <LoganCapaldo> Purely within the language? i don't think so. Metaprogramming is too easy to break with other metaprogramming (in ruby at least)
17:54:43 <dons> yeah, i always get scared when adding say, monads, to a language requires implementing a type system as a library...
17:55:03 <dons> which seems to be suggested more often that you'd think
17:55:30 <Cale> Well, I wouldn't mind so much if it could be done properly.
17:55:57 <Cale> It really doesn't feel like what most people are doing to implement Maybe, etc. in Ruby is really monadic though
17:56:01 <Cale> Where is the functor?
17:56:19 <dons> Cale: we need a 'monad benchmark'
17:56:25 <Cale> You're not mapping types to types
17:56:34 <dons> a suite of programs that must be implemented, in order to satisfy 'this is a monad implementation'
17:56:53 <dons> like poplmark, i call it 'monadmark'
17:57:11 <dons> i.e. if you can't do this, its not a certified monad
17:57:14 <Cale> Maybe being able to implement monad transformers?
17:57:22 <Cale> That would be one thing, I think.
17:57:34 <Cale> hmm
17:57:38 <dons> yeah. and having a) Maybe, b) List c) Identity , ..
17:57:47 <Cale> State
17:57:49 <dons> and a State/Reader impl
17:57:49 <LoganCapaldo> the biggest problem I had when doing these was realizing when I made a mistake because there was no type checking
17:57:59 <dons> LoganCapaldo: interesting
17:58:13 <LoganCapaldo> Reader is next on my list ;)
17:59:13 <dons> Cale: it would make a good shootout benchmark ;)
17:59:15 <LoganCapaldo> I'd think I'd have to a) understand monad transformers and b) you'd probably would have to graft a type system onto ruby to really do them
17:59:38 <dons> implement blah using monads (i.e. like the others using threads, arrays, recursion, ..)
17:59:54 <Cale> Does Ruby allow one to store a class in a variable?
17:59:58 <sorear> Cale : if Ruby is dynamically typed all types are () and so Monads are () -> x which is x.  There is probably a much clearer way to say this.
17:59:59 <LoganCapaldo> yeah
18:00:09 <LoganCapaldo> you can write "Classtors" I guess
18:00:22 <dons> you should be able to translate the typeclass dictoinary to an extra argument at least
18:00:30 <Cale> Well, the Identity monad should take a class as a parameter
18:00:34 <LoganCapaldo> k = Class.new(Array) # k is an anonymous class that inherits from array
18:00:36 <sorear> Or, functors are types in statically untyped languages
18:01:08 <sorear> (Map String) is a functor, and a type in most dyn. typed languages
18:01:15 <Cale> hmm
18:02:00 <Cale> bind :: (Monad m) => m a -> (a -> m b) -> m b -- can we enforce all of those constraints?
18:02:18 <Cale> Ruby has enough reflection that perhaps we can
18:02:36 <LoganCapaldo> Ruby has so much reflection that we can't IMO :)
18:02:44 <Cale> hehe
18:03:09 <Cale> hmm
18:03:11 <dons> Oleg should really have a blog
18:03:29 <Excedrin> Step 1. implement a Haskell interpreter in Ruby...
18:03:50 <LoganCapaldo> heh
18:04:09 <dons> http://www.haskell.org/pipermail/haskell/2006-December/018817.html
18:04:12 <lambdabot> Title: [Haskell] Jones-optimal, typed, symbolic differentiation of (compiled) functions, http://tinyurl.com/t47ks
18:04:22 <glguy> are you guys discussing Monads in Ruby because of the reddit article that implements the Identity Monad in Ruby?
18:04:25 <dons> not Peyton-Jones optimal
18:04:34 <Cale> glguy: guess who wrote that article?
18:04:35 <dons> glguy: yes, by our very own LoganCapaldo
18:04:41 <dons> LoganCapaldo++
18:04:42 <sorear> How about porting MMIX? IIRC gcc has a port :)
18:04:44 <LoganCapaldo> lol
18:04:47 <glguy> posted by Logan Capaldo
18:05:02 <Cale> oleg doesn't need a blog. The Haskell mailing list is his blog :)
18:05:12 <Korollary> he has rss
18:05:43 <eviltwin_b> <Cale> Does Ruby allow one to store a class in a variable?
18:05:45 <dons> he does?
18:05:48 <dons> Korollary: url?
18:06:03 <Korollary> http://okmij.org/ftp/rss.xml
18:06:05 <eviltwin_b> a class name is a constant like any other, I can assign it to a variable and use that as if it were a class, yes
18:06:15 <Cale> eviltwin_b: yeah
18:06:43 <eviltwin_b> on the other hand, IIRC a class constant isn't quite a class as you'd think of it in other OO languages
18:06:45 <Cale> eviltwin_b: So I'm thinking we perhaps can do some equality testing to check that when x >>= f is carried out, the result is the correct type.
18:07:13 <Cale> You can't enforce it statically, which sucks, but at least you can fail immediately.
18:07:18 <eviltwin_b> yeh
18:07:30 <eviltwin_b> (on the gripping hand, it's not a string like in Perl :)
18:07:58 <Cale> Also, it really feels like Identity as implemented isn't a monad there, because it's not getting applied to a type at any point.
18:08:11 <dons> mmm. yes
18:08:16 <Cale> Monads are functions which take types to other types.
18:08:30 <Cale> So it should take a class and build a new class from it.
18:08:31 <dons> you must be able to instantiate it to different 'element' types
18:09:00 <Cale> In the case of Identity, that class should be isomorphic to the original one, with perhaps a layer of wrapping.
18:09:21 <fizbin> What is the name for the thing that takes a type to another type, of which Monad is an example?
18:09:28 <LoganCapaldo> Functor
18:09:44 <Korollary> type constructor?
18:09:49 <Cale> Type constructor
18:10:02 <LoganCapaldo> Random Wrong Answer
18:10:07 <Cale> To be a Functor, you also have to take functions between types to functions between where those types are sent
18:10:10 <dons> :k Maybe -- for example
18:10:11 <lambdabot> * -> *
18:10:16 <Cale> that is, a -> b gets sent to f a -> f b
18:10:18 <dons> something of kind * -> *
18:10:29 <Cale> Which in Haskell is carried out by fmap
18:10:54 <dons> well, Monad isn't a type constructor. but things that are in Monad are...
18:11:21 <dons> i.e. 'container' types
18:13:12 <glguy> :k Monad -- colon works now?
18:13:12 <lambdabot> Class `Monad' used as a type
18:13:18 <glguy> :t True
18:13:19 <lambdabot> Bool
18:13:25 <glguy> when did that happen?
18:13:59 <Cale> that's excellent :)
18:14:10 <dons> yesterday
18:14:23 <glguy> :yow
18:14:28 <dons> only for :t and :k
18:14:31 <mgsloan> sweet!
18:14:32 <glguy> ah, ok
18:14:33 <glguy> cool
18:14:34 <Cale> Can function application be overloaded in Ruby?
18:14:37 <dons> (I'm open to suggestions though)
18:15:03 <mgsloan> :k Maybe Either
18:15:05 <lambdabot>   `Either' is not applied to enough type arguments
18:15:05 <lambdabot>   Expected kind `*', but `Either' has kind `* -> * -> *'
18:15:47 <mgsloan> :k Maybe . Either
18:15:48 <lambdabot> parse error on input `.'
18:15:52 <dons> heh
18:15:56 <dons> its not epigram!
18:16:01 <mgsloan> :)
18:16:25 <dons> :k Maybe Int -> Either
18:16:27 <lambdabot>   `Either' is not applied to enough type arguments
18:16:27 <lambdabot>   Expected kind `?', but `Either' has kind `* -> * -> *'
18:16:34 <dons> :k (->)
18:16:35 <lambdabot> ?? -> ? -> *
18:16:46 <sorear> what is ??, ? ?
18:16:48 <mgsloan> hmm
18:17:02 <mgsloan> polymorphic id's i suspect
18:17:10 <dons> kinds of types that can be in # or *
18:17:11 <Korollary> possibly a kind that includes unboxed types?
18:17:19 <mgsloan> ah
18:17:31 <dons> :k GHC.Base.Int# -> Bool
18:17:32 <mgsloan> # is value?
18:17:32 <lambdabot> *
18:17:42 <dons> :k GHC.Base.Int#
18:17:43 <lambdabot> #
18:17:45 <Korollary> haskell98 would have * -> * -> 8
18:18:24 <sorear> then... what is ??
18:18:46 <mgsloan> sorear - same thing, but different identifier, to indicate that the two need not be the same
18:18:52 * mgsloan guesses
18:19:27 <dons>          ?
18:19:27 <dons>         / \
18:19:27 <dons>            /   \
18:19:27 <dons>           ??   (#)
18:19:27 <dons>          /  \
18:19:29 <dons>             *   #
18:19:32 <dons> where   *    [LiftedTypeKind]   means boxed type
18:19:34 <dons>     #    [UnliftedTypeKind] means unboxed type
18:19:37 <dons>     (#)  [UbxTupleKind]     means unboxed tuple
18:19:39 <dons>     ??   [ArgTypeKind]      is the lub of *,#
18:19:42 <dons>     ?    [OpenTypeKind] means any type at all
18:20:05 <sorear> cool
18:20:06 <dons> (\(x::t) -> ...)    Here t::?? (i.e. not unboxed tuple)
18:20:07 <mgsloan> oh, interesting
18:20:39 * Debolaz is starting to get the distinct feeling that the tutorials he's reading makes monads seem much more complex than they really are.
18:20:40 * sorear had no idea the universe of kinds was this interesting
18:20:49 <dons> :k (# Int, Bool #) -> Int
18:20:51 <lambdabot>   Kind mis-match
18:20:51 <lambdabot>   Expected kind `??', but `(# Int, Bool #)' has kind `(#)'
18:20:53 <dons> yeah
18:20:58 <dons> :k (->) -- says so
18:21:00 <lambdabot> ?? -> ? -> *
18:21:14 <dons> :k Int -> (# Int, Bool #) -> Int -- should be ok?
18:21:15 <lambdabot>   Kind mis-match
18:21:16 <lambdabot>   Expected kind `??', but `(# Int, Bool #)' has kind `(#)'
18:21:27 <dons> that open kind should be fine there, shouldn't it?
18:21:35 <mgsloan> So unboxed types can't be args then
18:21:36 <sorear> :k (Int -> (# Int, Bool #)) -> Int
18:21:38 <lambdabot> *
18:21:47 <dons> mgsloan: unboxed tuples
18:21:49 <dons> sorear: ah right
18:21:56 <mgsloan> ohh
18:22:15 <dons> :k Int -> GHC.Base.Int# -> Int -- fine
18:22:16 <lambdabot> *
18:22:25 <sorear> :k Int -> (# Int, Char #)
18:22:27 <lambdabot> *
18:22:29 <dons> unboxed tuples are a bit magic, since they correspond to low level stack poking
18:22:47 <sorear> :k (Int, (# Int, Int #))
18:22:47 <dons> :k (->) Int (# Int, Char #) -- of course
18:22:49 <lambdabot> *
18:22:50 <lambdabot>   Kind mis-match
18:22:50 <lambdabot>   Expected kind `*', but `(# Int, Int #)' has kind `(#)'
18:22:55 <Korollary> woo kings score
18:22:56 <dons> :k (,)
18:22:57 <lambdabot> * -> * -> *
18:23:02 <mgsloan> huh, interesting shtuff
18:23:08 <glguy> :t (,)
18:23:09 <dons> :k (,) Int
18:23:10 <lambdabot> forall b a. a -> b -> (a, b)
18:23:10 <lambdabot> * -> *
18:23:16 <sorear> :k (#,#)
18:23:18 <lambdabot> parse error on input `,'
18:23:23 <dons> too magic
18:23:36 <mgsloan> :k (# , #)
18:23:37 <lambdabot> parse error on input `,'
18:23:43 <dons> :k (# Int , Bool #)
18:23:45 <lambdabot> (#)
18:23:47 <sorear> :k (##)
18:23:49 <lambdabot> Not in scope: type variable `##'
18:23:50 <sorear> :k (# #)
18:23:52 <lambdabot> parse error on input `#)'
18:24:00 <dons> I'm not sure it can be done
18:24:05 <sorear> :k forall a. a
18:24:07 <lambdabot> *
18:24:11 <dons> in the future though..
18:24:19 <dons> kind polymorphism, ATs, ....
18:24:20 <mgsloan> wouldn't make sense to have an unboxed tuple of nothing though, would it
18:24:44 <dons> well, its () but unboxed, no?
18:25:03 <mgsloan> heh i guess
18:25:07 <sorear> no point in (# #) -only one value
18:25:12 <dons> since as soon as you know the type, you know the value, maybe its not that useful (since () would be fine)
18:25:19 <sorear> () has two values - () and bottom
18:25:26 <dons> other than perhaps for something expecting only unboxed args
18:25:49 <dons> ok. yes, a strict () would be useful I think
18:25:58 <sorear> Jaskell is pure, so () is useless as a return type - the only place our (# #) could appear
18:26:00 <dons> at least, its has unique behaviour
18:26:10 * mgsloan can't wait till there's * -> Int -> * ;)
18:26:14 <sorear> OTOH, see "orthogonality"
18:26:18 <dons> would make an interesting realWorld# token
18:26:34 <dons> mgsloan: how about * -> Int 7 -> *
18:26:37 * sorear wants a pure type system
18:26:54 * dons wants to write working code
18:27:08 <dons> without Pi's on the value level ;)
18:27:14 * mgsloan wants referentially transparent type constructors
18:27:23 <mgsloan> actually not really, that could get pretty crappy
18:27:43 <dons> I think they are referentially transparent ... ;)
18:27:59 <dons> at least, instantiating Maybe doesn't tend to produce different types each time ... ;)
18:28:16 <mgsloan> ah, I'm probably using the wrong term
18:28:29 <mgsloan> I mean like where you can substitute in the definition where the name is used
18:28:33 <dons> you want side effecting type constructors?
18:28:57 <dons> hmm?
18:29:07 <sorear> and why is haskell's type system strict and dynamically typed?
18:29:19 <dons> i.e. Maybe Int -> Bool  ==>   (Just Int | Nothing) -> (True | FAlse)  ?
18:29:20 <mgsloan> sorear - it's strict and inferenced
18:29:33 <mgsloan> afaik
18:29:45 <dons> sorear: there's sstill static kind inference. but it could at least have some polymorphism in there..
18:29:46 <mgsloan> dons - something like that
18:29:55 <sorear> function types are inferred, but value types are dynamic
18:30:03 <dons> on the type level?
18:30:14 <sorear> function kinds then.
18:30:16 <LoganCapaldo> Cale, dons, anyone else interested: I've put up an alternate  implementation of of the Identity monad in ruby: http://meta-meta.blogspot.com/2006/12/monads-in-ruby-part-15-identity.html
18:30:17 * dons ponders what sorear means by 'dynamic' here
18:30:19 <lambdabot> Title: Meta-Meta: Monads In Ruby Part 1.5: Identity, http://tinyurl.com/y3dgbc
18:30:58 <mgsloan> the problem is obviously the structural vs err, subtyped? equality
18:31:47 <Cale> LoganCapaldo: aha, that's roughly what I was trying to do before I ran into the small problem that ruby doesn't seem to like class declarations inside method bodies.
18:34:40 <Cale> actually, why doesn't it let you do that? Wouldn't that be saner than the way it appears to currently be forcing you to do that?
18:35:56 <LoganCapaldo> even if it did, class introduces a new lexical scope
18:36:03 <LoganCapaldo> so I'd still have to do it this way
18:36:14 <LoganCapaldo> to get at the parameter
18:36:23 <dons> Cale: you should write a 'Purely functional monads' book, like Okasaki's data structures book, to go along with the complete NewMonads package... want to get famous?
18:36:25 <LoganCapaldo> w/o using class variables or similar
18:36:25 <mgsloan> > let foo :: (Just Int | Nothing) -> (True | False); foo (Just _) = True; foo (Nothing) = False in foo Just 5
18:36:26 <lambdabot>  Parse error
18:36:39 <mgsloan> suspected as much, ohwell
18:36:49 <mgsloan> once again, isn't epigram :)
18:36:51 <dons> just use the type to stand for its inhabitants ;)
18:37:20 <Cale> LoganCapaldo: I'd want it to behave like lambda and extend the environment of the method in which it was defined.
18:37:45 <Cale> After all, you can define classes at the top level, and they have access to all the globally defined variables so far.
18:37:49 <LoganCapaldo> Well that's what the Class.new { ... } form is for
18:38:03 <LoganCapaldo> yeah, but the only globals are $variables
18:38:11 <LoganCapaldo> a = 1; class B; a; end # error
18:38:43 * LoganCapaldo feels self drifting away to offtopic land
18:39:36 <Cale> hmm
18:40:22 <LoganCapaldo> a = 1; class B; end; B.class_eval { a } # ok though
18:41:14 <Cale> lisppaste2: url
18:41:14 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
18:42:09 <Cale> LoganCapaldo: It would be nice if you could do something like this: http://ruby.paste-bin.com/1711
18:42:14 <greentea> Heh, the "Intelligent Design Sort" - sweet. :-)
18:42:44 <newsham> re
18:42:45 <LoganCapaldo> Cale: Yeah. Like I said though, the scope doesn't work out
18:42:56 <Cale> They should work on that :)
18:42:58 <LoganCapaldo> It's because ruby has no "let" keyword
18:43:01 <LoganCapaldo> basically
18:43:17 <Cale> hmm
18:43:26 <LoganCapaldo> Instead we get two ways of doing everything, one thats a closure and one that's not
18:44:12 <Cale> Why bother with the one that's not?
18:44:47 <Cale> Is there any point to it, or can it just be considered a language design wart?
18:45:32 <LoganCapaldo> well since we have no way of saying "this is a local variable", a = 5; .... hundrreds of lines of code later; def f(x); a = 7 # oops stomped on the "global" a when I really wanted a local variable
18:45:54 <LoganCapaldo> So that's why there is two ways of doing it
18:46:14 <Cale> Oh, I'd just want that to shadow a locally.
18:46:29 <Cale> Of course, I'm insane :)
18:46:39 <LoganCapaldo> Us ruby people like our mutable state unfortunately :)
18:47:14 <glguy> Does look like that's all that's wrong with those Ruby people, either ;)
18:47:25 <Cale> actually, hmm
18:48:09 <Cale> I wonder whether it would be worthwhile for ruby just to separate it into two syntaxes:
18:48:23 <Cale> a = 5 would create a new definition for a
18:48:35 <Cale> a <- 5 would assign 5 to the currently visible a
18:48:45 <LoganCapaldo> Yeah that's what Io does
18:50:22 <LoganCapaldo> I'd settle for my a or var a or similar
18:51:05 <Cale> Actually, I think it would be sane to make definitions like a = 5 cause a to be immutable as well.
18:51:30 <Cale> Perhaps I should design a proper OO language ;)
18:51:38 <LoganCapaldo> Heh
18:51:52 <Korollary> that's why lisp/scheme has setq to modify vars
18:52:17 <LoganCapaldo> I thought about that for a little bit. Then I came across Moby and saw it had every good idea I had already implemented, so I gave up on that one :)
18:52:28 <Cale> It would be nice if mutable variables had to be declared and had to be set differently from immutable ones.
18:52:39 <LoganCapaldo> a = ref 0 ;)
18:52:47 <Cale> That'd do.
18:53:25 <Cale> Why is everyone using Ruby if there are such obvious scoping problems?
18:53:26 <Cale> :)
18:53:46 <Korollary> most people dont know, nor would they care.
18:53:48 <Cale> Then again, some people still argue for dynamically scoped lisp
18:54:49 <LoganCapaldo> Perl has better scoping but its just so nasty :) Haskell is both betterly scoped and unnasty but my brain hurts whilst learning it. Ergo, ruby is the language of the now :)
18:55:24 <dons> think how far perl got without scoping
18:55:54 <LoganCapaldo> Oh yeah I guess I should say "Perl has better scoping, now" :)
18:56:25 <Nafai>  I just don't understand why Ruby is so popular
18:56:38 <dons> 5999950000 people on this planet don't care about scoping ;)
18:56:41 <Korollary> different syntax. it's gotta be good.
18:56:53 <chessguy> howdy
18:57:11 <dons> hey chessguy
18:57:40 <chessguy> ok, so who wrote my monte carlo simulator while i was at church? :)
18:58:16 <sorear> the aformentioned monad was WriterT [Customer] (StateT [Customer])
18:58:24 <sorear> the aformentioned monad was WriterT [Customer] (State [Customer])
18:58:46 <chessguy> so what's the return type?
18:59:06 <sorear> admit = do p <- get ; put (tail p) ; return (head p)
18:59:19 <sorear> send = tell . (:[])
18:59:35 <dons> I like using 'return' for (:[]) these days
18:59:44 <dons> but there should be box in Data.List for this
18:59:54 <chessguy> what's tell?
19:00:07 <glguy> tell is a MonadWriter function
19:00:26 <glguy> :t tell
19:00:27 <lambdabot> Not in scope: `tell'
19:00:28 <dons> :t Control.Monad.Writer.tell
19:00:30 <lambdabot> forall (m :: * -> *) w. (Control.Monad.Writer.MonadWriter w m) => w -> m ()
19:00:54 <sorear> service x ppl = snd (evalState (runWriter x) ppl)
19:01:24 <sorear> :t \x ppl -> snd (Control.Monad.State.evalState (Control.Monad.Writer.runWriter x) ppl)
19:01:25 <lambdabot>   Couldn't match `State s (a, b)' against `(a1, w)'
19:01:26 <lambdabot>    Expected type: State s (a, b)
19:02:57 <chessguy> man, those error messages really ought to be improved. that's awful
19:03:33 <dons> `State s (a, b)' against `(a1, w)' seems ok?
19:03:54 <chessguy> what the heck is (a1, w)?
19:03:57 <dons> :t \x ppl -> (Control.Monad.State.evalState (Control.Monad.Writer.runWriter x) >>= return . snd
19:03:59 <lambdabot> parse error (possibly incorrect indentation)
19:04:06 <dons> :t \x ppl -> (Control.Monad.State.evalState (Control.Monad.Writer.runWriter x)) >>= return . snd
19:04:07 <lambdabot>   Couldn't match `State s a' against `(a1, w)'
19:04:08 <lambdabot>    Expected type: State s a
19:04:08 <newsham> chess: whats wrong with the error msg?
19:04:12 <dons> bad me :)
19:04:17 <sorear> :t \x ppl -> snd (Control.Monad.State.evalState (Control.Monad.Writer.runWriterT x) ppl)
19:04:19 <lambdabot> forall s a w. Control.Monad.Writer.WriterT w (State s) a -> s -> w
19:04:27 <dons> ah
19:04:33 <chessguy> looks incomprehensible to me
19:04:58 <newsham> sorear: you were gonna say something and then you quit (a few hrs ago)
19:05:00 <sorear> the type is a bit more genereal than we need
19:05:25 <sorear> yes, the state lifter looked great
19:06:29 <newsham> one question I had.. when I use it to read a value, it sets a field back to its original value.
19:06:39 <newsham> is the compiler able to optimize that away?
19:06:46 <newsham> or does it end up consing a lot?
19:07:24 <newsham> ie "withField1 get"
19:07:32 <sorear> It'll probably end up consing a lot
19:07:46 <newsham> is there any way to avoid that?
19:08:04 <newsham> i have some larger code (posted to -cafe) in which I'm using lots and lots of "withXXX"
19:08:05 <sorear> ST (overkill, I know)
19:09:03 <newsham> not too familiar with ST yet..  will read up.
19:09:35 <sorear> basically ST is IO but with a guarantee that no actual IO will occur
19:09:53 <newsham> so that updates can be done in-place?
19:10:07 <sorear> ST supports IORefs (called STRefs), STArrays, etc, but not putStr etc
19:10:24 <sorear> because of this, there is a function runST
19:10:35 <sorear> runST is unsafePerformIO, just safer
19:11:28 <chessguy> is WriterT a monad transformer
19:11:28 <ozone> safePerformIO = Control.Monad.State.runST
19:11:29 <sorear> however ST has the machinery for dynamic reference allocation, which your (first) example didn't need
19:11:38 <sorear> chessguy: yes
19:11:49 <newsham> what do people normally do when they have complex nested state that needs manipulation?
19:12:14 <chessguy> bleah, i think this method is going to be over my head then. i have a hard enough time with a regular monad, much less a monad transformer
19:12:30 <LoganCapaldo> write a tiny interpreter for a language with state and embed it in Haskell for those parts. (kidding!)
19:12:31 <newsham> chess: did you see the paper on using monad transformers?
19:12:37 <dons> newsham: avoid nested state?
19:12:51 <newsham> dons: some complex problems have complex state.
19:12:56 <chessguy> newsham, i think i need to grok monads before i take on transformers :)
19:12:58 <glguy> nested state? is that like a Reader using 'local'?
19:13:01 <dons> I usually stick everything in a 1 or 2-deep nested State type, and run in StateT
19:13:02 <sorear> WriterT x is a monad transformer, but WriterT x (StateT x) is a plain old monad
19:13:04 <dons> for maximum flexibility
19:13:14 <newsham> i would love suggestions for simplifying my state, but truth be told, my current code is a simplified version of what I have to eventually implement
19:13:14 <dons> then maybe something like ReaderT for particular scoping issues
19:13:22 <dons> yeah, its not too bad, I think
19:13:57 <sorear> ST does state, but you'll have to thread the references yourself
19:14:02 <newsham> chess: the tutorial is suprisingly approachable, but it does assume at least some level of monad familiarity.
19:14:25 <newsham> glguy: i would imagine its something like that :)
19:14:49 <chessguy> well, monads haven't quite clicked with me yet
19:15:03 <Cale> chessguy: did you read my article?
19:15:11 <dons> they don't click, they bind
19:15:12 <chessguy> Cale, several times
19:15:14 <Cale> ah, okay
19:15:28 <newsham> click = (>>=)
19:15:32 <newsham> now they click :)
19:15:52 <chessguy> Cale, did you see what sorear was just saying about modelling a shop as a monad?
19:15:59 <Korollary> I liked the monster analogy for monads.
19:16:36 <Cale> hmm
19:16:59 <chessguy> to recap:
19:17:00 <chessguy> [21:54] <sorear> the aformentioned monad was WriterT [Customer] (State [Customer])
19:17:00 <chessguy> [21:55] <sorear> admit = do p <- get ; put (tail p) ; return (head p)
19:17:00 <chessguy> [21:55] <sorear> send = tell . (:[])
19:17:00 <chessguy> [21:56] <sorear> service x ppl = snd (Control.Monad.State.evalState (Control.Monad.Writer.runWriterT x) ppl)
19:17:02 <sorear> I see the monadic code as being the shopkeeper, who performs a sequence of actions
19:17:25 <sorear> the shop itself is a stream processor
19:17:41 <Cale> hmm
19:18:08 <Cale> That's probably not quite how I'd want to do it.
19:18:21 <Cale> I wonder if there's a particularly elegant Arrow solution
19:19:04 <Cale> or maybe something comonadic :)
19:20:02 <newsham> when you have a hammer everything looks like a nail
19:20:45 <chessguy> newsham, hm? who are you talking about?
19:20:49 <Cale> Without that sort of thing, I'd probably write the shopkeeper as a function [Customer] -> Rand [Customer], where the Rand monad would be used to handle generating the intervals.
19:21:05 <newsham> carpenters?
19:22:06 <sorear> When all you have is application and lambda, every problem looks like a function.
19:22:29 <chessguy> except IO :)
19:22:41 <newsham> world -> (world', val) ?
19:22:50 <dons> including IO.
19:23:20 <sorear> [Request] -> [Response] . Once upon a time that was main's type...
19:23:33 <dons> main world = let (v, world') = getChar in let world'' = putChar v world' in world''
19:24:42 <sorear> main [GetStrResp name] = [PutStr "name? ", GetStr, PutStr ("Hello " ++ name) ] or somesuch.
19:25:45 <newsham> if you see miranda, tell her i said hi
19:26:18 * eviltwin_b will remember tha next time he gets annoyed at the IO monad --- clearly things could be worse...
19:26:30 <Pseudonym> I haven't seen Miranda in years.  Turner has moved on to other things.
19:27:07 <dons> yeah, what's Turner doing these days?
19:27:35 <dons> and when will all the Clean hackers submit?  ;)
19:28:18 <Pseudonym> http://www.cs.kent.ac.uk/people/staff/dat/
19:28:20 <lambdabot> Title: Computer Science: Prof DA Turner
19:28:27 <Pseudonym> Except he's moved on since then.
19:28:46 <chessguy> Last modified Mon Oct 15 01:33:50 GMT 2001
19:29:21 <Pseudonym> Looks like he's working on trying to find a large subclass of functional programs that terminate.
19:31:13 <Pseudonym> Woo!  You can get Miranda for free now.
19:31:21 <dons> random haskell blog quote of the day: "If you have not discovered this amazing programming language (or, if you have), check out the
19:31:24 <dons> article from the always-excellent defmacro on Writing a Lisp Interpreter in Haskell."
19:32:12 <Pseudonym> http://bignum.sourceforge.net/BigFloat3.hs
19:32:16 <Pseudonym> Anyone had a look at that?
19:32:30 <dons> mmm
19:33:33 <chessguy> the "WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!" is enough to scare me away
19:33:58 <newsham> who was talking about the primes/sqrt stuff yesterday?
19:34:01 <Pseudonym> Big Float support sounds damn useful.
19:34:08 <sorear> why'd lambdabot stop generating tinyurls?
19:34:28 <chessguy> mmm, it still does it sometimes i think
19:34:37 <Korollary> it depends on length
19:34:44 <chessguy> @tinyurl http://bignum.sourceforge.net/BigFloat3.hs
19:34:45 <lambdabot> http://tinyurl.com/wo2m8
19:35:06 <dons> this is kind of funny, http://secretgeek.net/lisp_truth.asp
19:35:08 <lambdabot> Title: The Truth About Lisp
19:35:29 <dons> (scroll down to the time travel is built in to haskell bit)
19:37:02 <chessguy> lol, i like the part about paul graham
19:37:03 <newsham> When you become a lisper, you will laugh at jokes that no one else thinks are funny.
19:37:18 <dons> heh
19:38:25 <chessguy> hehe, that's good stuff
19:38:46 * eviltwin_b seems to have outsmarted himself
19:38:50 <dons> he got the technical details wrong though. time travel isn't built into haskell, its a library
19:39:00 * chessguy gasps
19:39:09 <newsham> they forgot to mention unwarranted feeling of superiority
19:40:28 <Korollary> if you are a vi user, lisp may just as well never have existed for you.
19:40:53 <fizbin> How does one get documentation on what lambdabot responds to?
19:40:57 <eviltwin_b> ah, kids.  :set lisp has been forgotten
19:40:58 <chessguy> @help
19:40:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:41:06 <chessguy> oops
19:41:08 <chessguy> > list
19:41:10 <lambdabot>  Not in scope: `list'
19:41:11 <eviltwin_b> heh
19:41:14 * chessguy sighs
19:41:18 <eviltwin_b> @list
19:41:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:41:20 <newsham> vim does paren matching
19:41:25 <chessguy> it's been a long day
19:41:39 <eviltwin_b> any vi worth its bits has :set showmatch
19:42:01 <newsham> tell me about it.. i wrote the same code several times today
19:42:02 <dons> yeah..
19:42:13 <eviltwin_b> :set lisp changed the paragraph / sentence / block commands to operate on various levels of s-expressions
19:42:30 <eviltwin_b> supposedly it's not fully implemented in the free vis (vim, nvi)
19:42:42 <chessguy> i beat around the bush all day without actually writing any code
19:42:58 <newsham> and the code is in this bush?
19:43:21 <chessguy> i don't know, the bush got the better of me
19:43:23 <dons> does :set lisp work on haskell blocks?
19:43:29 <dons> or it really needs parens
19:43:31 * eviltwin_b was quite productive but now finds himself needing to un-pl and un-undo some highfalutin' code because it's about to become too complex for his little mind
19:43:38 <dons> heh
19:43:45 <eviltwin_b> it needed parens
19:44:35 <eviltwin_b> and the default mode works in terms of blank lines, periods, and troff requests, so it's even less useful for coding
19:45:39 <eviltwin_b> (how many people actually use the ), ]] and }} commands in vi?  raise your hand)
19:46:02 <eviltwin_b> actually there is a way to configure them but it's rather ugly
19:46:34 <eviltwin_b> hm, except they're still in terms of troff requests
19:52:27 <sorear> the what commands in vi? (rhetorical)
19:54:15 <monochrom> <-
19:54:31 <glguy_> Having read *The Little Schemer* and now reading *The Seasoned Schemer* my curiosity at why people would teach Scheme as a first language has melted away to why you would teach programming in any other language
19:54:47 <chessguy> so i'm trying to decide what books i want to buy with christmas money. i'm a couple months into haskell, starting to get the hang of the syntax, but still don't really "get" monads or anything more complicated. even type classes are still pretty tough for me. suggestions?
19:54:55 <dons> glguy_: no types? ;)
19:55:15 <fizbin> Hey, could someone explain to me how this expression manages to work?
19:55:27 <fizbin> @run ap (++) show "some string"
19:55:29 <lambdabot>  "some string\"some string\""
19:55:32 <robreim> @seen dcoutts
19:55:33 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
19:55:40 <glguy_> dons: scheme has types, just not static typing
19:55:40 <dons> chessguy: how about, Types and Programming Languages
19:55:41 <dons>     Benjamin C. Pierce. 645 pages, The MIT Press, (February 1, 2002)
19:55:46 <monochrom> haha glguy_
19:55:51 <glguy_> no?
19:55:53 <newsham> > ap (*) 3
19:55:54 <lambdabot>  add an instance declaration for (Num (a -> a))
19:55:56 <fizbin> Specifically, how is (++) the right type for the first argument to ap?
19:55:57 <glguy_> what are they called then
19:56:02 <dons> ?type ap
19:56:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
19:56:10 <fizbin> ?type (++)
19:56:12 <lambdabot> forall a. [a] -> [a] -> [a]
19:56:20 <glguy_> > (+ 1 '())
19:56:21 <glguy_> +: expects type <number> as 2nd argument, given: empty; other arguments were: 1
19:56:21 <lambdabot>  Improperly terminated character constant
19:56:31 <newsham> instance Monad ((->) r)   ?
19:56:35 <chessguy> dons, lemme look
19:56:44 <chessguy> http://www.amazon.com/Types-Programming-Languages-Benjamin-Pierce/dp/0262162091/sr=8-1/qid=1165204365/ref=pd_bbs_sr_1/102-7446580-9180946?ie=UTF8&s=books if anyone's curious
19:56:48 <lambdabot> http://tinyurl.com/y3hmzr
19:56:53 * monochrom also believes that the medium for learning programming should be quite distinct from the medium for applying programming.
19:56:57 <dons> fizbin, so ap (++) show "some string" is in the (-> a) monad
19:57:21 <dons> now we have:
19:57:22 <dons> instance Monad ((->) r) where
19:57:22 <dons>     return = const
19:57:22 <dons>     f >>= k = \ r -> k (f r) r
19:57:27 * fizbin was not aware (-> a) was a monad.
19:57:40 <dons> and, ap                =  liftM2 id
19:57:49 <dons> liftM2 f m1 m2          = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:58:06 <mgsloan> haha, even function types are monads!
19:58:11 <dons> ap (++) show "some string"
19:58:15 <chessguy> dons, does that talk about monads?
19:58:20 <dons> liftM2 id (++) show "some string"
19:58:50 <dons> do { x1 <- (++) ; x2 <- show ; return (id x1 x2) }
19:58:54 <sorear> (a -> ) is the pre-Reader name for the Reader monad.
19:58:56 <dons> ?undo do { x1 <- (++) ; x2 <- show ; return (id x1 x2) }
19:58:56 <lambdabot> (++) >>= \ x1 -> show >>= \ x2 -> return (id x1 x2)
19:58:57 <kpreid> fizbin: it isn't
19:58:59 <dons> thus
19:59:10 <kpreid> fizbin: ((->) r) == (r ->) except the latter isn't allowed syntax
19:59:21 <kpreid> (iirc)
19:59:27 <dons> (++) `\ r -> k (f r) r` \ x1 -> show `\ r -> k (f r) r` \ x2 -> const (id x1 x2)
19:59:30 <monochrom> do { x1 <- (++) ; x2 <- show ; return (id x1 x2) } makes baby jesus cry
19:59:30 <newsham> "functions taking an r"
19:59:33 <kpreid> @type undefined :: (Int ->)
19:59:34 <lambdabot> parse error on input `)'
19:59:38 <dons> so finally:
20:00:10 <sorear> The (->) x monad converts your code into pointfree style
20:01:08 <dons> well, finally, you inline and reduce that lambda expr, and you're back to (++) and show lifted over the string
20:01:13 <sorear> (aka abstraction elimination - note return is K and liftM2 is S)
20:01:20 <dons> (the manual inlining got a bit tricky in there;)
20:01:26 <dons> ?pl (++) >>= \ x1 -> show >>= \ x2 -> return (id x1 x2)
20:01:27 <lambdabot> (show >>=) . (return .) =<< (++)
20:01:37 <dons> > (show >>=) . (return .) =<< (++) $ "some string"
20:01:38 <lambdabot>  "some string\"some string\""
20:01:51 <dons> ah, look, that's squish
20:02:04 <dons> sqush show (++) "some string"
20:02:04 <nornagon> > join (++) "some string"
20:02:06 <lambdabot>  "some stringsome string"
20:02:17 <newsham> > ap (*) (+ 3) 4
20:02:19 <lambdabot>  28
20:02:34 <newsham> > (*) (4 + 3) 4
20:02:36 <lambdabot>  28
20:03:02 <augustss> > join (*) 5
20:03:04 <lambdabot>  25
20:03:33 <chessguy> dons, does that book talk about monads?
20:03:49 <newsham> > (liftM2 (*) (+ 1) (+ 2)) 3
20:03:51 <lambdabot>  20
20:03:54 <fizbin> newsham: I get what ap is doing here; I just couldn't reconcile the apparent effect of ap (that is, ap f g = \x -> x `f` g x) with the Monad signature given on zvon
20:03:57 <newsham> > (*) (3 + 1) (3 + 2)
20:03:59 <lambdabot>  20
20:04:02 <glguy_> Isn't there a new Haskell book coming out this month?
20:04:09 <augustss> :t join (.)
20:04:10 <lambdabot> forall c. (c -> c) -> c -> c
20:04:18 <augustss> @type join (.)
20:04:19 <lambdabot> forall c. (c -> c) -> c -> c
20:04:30 <kpreid> fizbin: ap f g = \x -> (f x) (g x)
20:04:37 <sorear> > join ("foo"++) "bar"
20:04:38 <lambdabot>  Couldn't match `[Char] -> a' against `[Char]'
20:04:44 <kpreid> fizbin: removing the infix makes it clearer, i think
20:04:51 <augustss> > join (.) (+1) 0
20:04:53 <lambdabot>  2
20:05:03 <sorear> kpreid : ap == S
20:05:17 <kpreid> fizbin: 'run' the two arguments (by supplying the reader environment) and then apply the results
20:05:32 <sorear> ?pl \ f x = f (f x)
20:05:33 <lambdabot> (line 1, column 7):
20:05:33 <lambdabot> unexpected "="
20:05:33 <lambdabot> expecting pattern or "->"
20:05:38 <sorear> ?pl \ f x -> f (f x)
20:05:39 <lambdabot> join (.)
20:05:58 <sorear> hmm - join (.) is Church two
20:06:05 <sorear> Church numeral two
20:06:07 <augustss> often called twice
20:06:19 <kpreid> @pl \ f x -> f (f (f x))
20:06:19 <lambdabot> ap (.) (join (.))
20:06:23 <newsham> > join (+) 2
20:06:25 <lambdabot>  4
20:06:27 <newsham> > join (*) 2
20:06:28 <lambdabot>  4
20:06:31 <newsham> > join (^) 2
20:06:33 <lambdabot>  4
20:06:42 <kpreid> @unpl (join . join) ((.) . (.))
20:06:43 <lambdabot> (((\ p b c f -> p (b c f)) >>= \ l -> l) >>= \ j -> j)
20:06:43 <sorear> join (^) 10
20:06:46 <kpreid> er
20:06:50 <newsham> > join (join (^)) 2
20:06:51 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
20:06:52 <lambdabot>    Expe...
20:07:08 <dons> glguy_: yeah , gmh's book is coming out
20:07:19 <dons> check the pdfs on the textbooks page of haskell.org
20:07:22 <glguy_> dons: do you know if it's worth putting on my Christmas list?
20:08:08 <dons> not sure. check the drafts (they're online)
20:08:39 <dons> there's the new russian haskell textbook coming out too..
20:08:51 <dons> all listed here, http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
20:08:52 <lambdabot> Title: Books and tutorials - HaskellWiki
20:09:14 <dons> including,     Haskell.
20:09:24 <dons> (well, there's some russian in there somewhere..)
20:10:25 <chessguy> good link. thanks
20:11:01 <dons> I don't think we have any book covering monad transformers yet, do we?
20:11:06 <fizbin> > ap (++) show "> ap (++) show"
20:11:08 <lambdabot>  "> ap (++) show\"> ap (++) show\""
20:11:37 <eviltwin_b> going for the quine?
20:11:38 <chessguy> i just wonder if Types and Programming Languages would be too abstract for me
20:11:46 <monochrom> Bird's Haskell book has monad transformers.
20:11:50 <sorear> > ap (++) show"> ap (++) show"
20:11:52 <lambdabot>  "> ap (++) show\"> ap (++) show\""
20:12:53 <kpreid> @. read run ap (++) show "@. read run ap (++) show "
20:12:54 <chessguy> monochrom, this one? http://vig.prenhall.com/catalog/academic/product/0,1144,0134843460.html,00.html
20:12:54 <lambdabot>  @. read run ap (++) show "@. read run ap (++) show "
20:12:57 <lambdabot> Title: Introduction Functional Programming, 2/E - Prentice Hall Catalog, http://tinyurl.com/y6szdm
20:13:05 <sorear> main = putStrLn $ ap (++) show"main = putStrLn $ ap (++) show"
20:13:17 <monochrom> Yah
20:13:45 <chessguy> wow, that's a pricey one
20:15:58 <falconair> i just saw the slides for "How to build an adaptable interpreter in one day" on haskell.org, but I can't find the actual paper (nothing on google) ... anyone know if it is available on the web?
20:16:44 * sorear is sending fizbin's quine to the Quine Page, the shortest they have is 3 lines and much uglier
20:17:01 <fizbin> It's not really mine.
20:17:21 <fizbin> Though I'll admit that what they have is way too long.
20:18:00 <fizbin> For shorter, see e.g. http://www.cs.chalmers.se/~bringert/quines/q.hs
20:19:19 <dons> falconair: perhaps check the log for that page?
20:19:27 <dons> you could contact the author, i have his address
20:19:37 <dons> fizbin: nice!
20:20:14 <sorear> > ap(++)show"ap(++)show"
20:20:16 <lambdabot>  "ap(++)show\"ap(++)show\""
20:20:32 <dons> cool, the halfs link is on the front page :)
20:20:40 <dons> http://programming.reddit.com/info/thv9/details
20:20:42 <lambdabot> Title: Halfs: a new filesystem for Linux (written in Haskell) (reddit.com)
20:21:05 <sorear> Ah, my quine is 4 characters shorter than bringert :)
20:21:06 <dons> take that all your dynamically typed pretenders!   ;)
20:21:37 <dons> we really should have a page on haskell.org/haskellwiki/Quine
20:21:40 <dons> anyone like to create that?
20:24:15 <chessguy> hey that's pretty cool, a haskell file system
20:24:52 <Pseudonym> Haskell quines?
20:24:59 <Pseudonym> Sounds like my sort of thing.
20:25:07 <Pseudonym> Where is my tic-tac-toe player?
20:26:17 <chessguy> some day i'm going to be good at haskell, or die trying
20:26:24 <monochrom> I wrote one in BASIC
20:26:58 <fizbin> monochrom: A file system or a quine?
20:27:08 <monochrom> a tic-tac-toe program :)
20:27:49 <Pseudonym> With all due respect to mgoetze, every time I type his name I feel like I might see an image that I don't want to.
20:28:06 <newsham> hmm..  haskell code can be translated down to lambda expressions right?
20:28:15 <Pseudonym> newsham: Kind of.
20:28:20 <newsham> would be amusing to write a lambda evaluator in BASIC and run some haskell code on it
20:28:32 <newsham> haskell for the c64?
20:28:43 <chessguy> newsham, sure, if you're the masochistic type
20:29:27 <Pseudonym> All the extra stuff in Haskell, like I/O and sockets, are hard to translate to lambda calculus.
20:29:30 <Pseudonym> As are IEEE floats.
20:29:37 <Pseudonym> http://iohcc.mgoetze.net/Pseudonym.hs
20:29:38 <Pseudonym> There it is.
20:30:49 <eshrgrgfe> is it possible to make this: a . b 3  parsed as (a . b) 3 ?
20:30:56 <Pseudonym> No.
20:31:00 <eshrgrgfe> oh :(
20:31:01 <Pseudonym> But you can write this:
20:31:03 <Pseudonym> a . b $ 3
20:31:10 <eshrgrgfe> ok, thanks...
20:31:22 <Pseudonym> There's also a $ b $ 3, but I advise against that.
20:31:27 <Pseudonym> I think . is nicer.
20:32:04 <falconair> dons: i wasn't able to find any info on Popa Dan (How to build an adaptable interpreter in one day!) ... do you have any idea how I can contact him and request the paper?
20:35:40 <eshrgrgfe> Pseudonym: my . is redefined... it has another meaning...
20:35:53 <Pseudonym> What does it mean?
20:36:05 <eshrgrgfe> it doesn't matter :)
20:38:15 <sjanssen> eshrgrgfe: please don't tell us that "x . f = f x" ;)
20:38:25 <sjanssen> because you might get a flogging
20:40:13 <fizbin> @type (\f g x -> f x >> g x)
20:40:15 <lambdabot> forall (m :: * -> *) a b t. (Monad m) => (t -> m a) -> (t -> m b) -> t -> m b
20:41:42 * fizbin wonders if there's a builtin that means that.
20:41:44 <sjanssen> @type liftM2 (>>)
20:41:46 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m a) -> m1 (m b) -> m1 (m b)
20:42:11 <sjanssen> fizbin: that code will work if you have the right imports (Control.Monad.Instances or Control.Monad.Reader)
20:44:32 <dancor> what do ppl use to access sql dbs from haskell
20:44:54 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (return.splitAt 2)) [1..10]
20:44:55 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
20:45:32 <fizbin> > liftM2 (>>) putStr (putStr.show) $ "asdf"
20:45:34 <lambdabot>  <IO ()>
20:45:51 <fizbin> Hrm.  Hugs didn't like that expression.
20:45:54 <glguy> You don't need the $ in this case
20:47:11 * glguy shuts up and goes to bed
20:47:15 <fizbin> I suspect I don't have the library loaded that makes ((->) r) a Monad.
20:47:29 <sjanssen> fizbin: right, Control.Monad.Instances or .Reader
20:47:54 <sjanssen> depending on how recent your Hugs is
20:50:17 <dancor> where can i download a description of all the standard fcns like liftM2
20:50:38 <dancor> i'm tired of googling when i could just locally index the right document
20:51:50 <monochrom> like http://www.haskell.org/ghc/docs/latest/html/libraries/index.html ?
20:52:05 <Cale> dancor: it should come with ghc
20:52:15 <fizbin> No dice; when in Control.Monad.Instances it complains that "liftM2" is an undefined variable, and when switching back with ":load Monad" or ":load Control.Monad" it says it can't infer the instance Monad ((->) [Char])
20:52:34 <Cale> :also ?
20:52:38 <sjanssen> fizbin: you'll want both Control.Monad and Control.Monad.Instances
20:53:05 <fizbin> And I'm saying that loading them both doesn't help.
20:53:36 <monochrom> :module +Control.Monad
20:53:43 <monochrom> :module +Control.Monad.Instances
20:54:51 <monochrom> For more detail see http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
20:54:52 <fizbin> Hugs says: ERROR - Cannot find module "+Control.Monad"
20:54:53 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.6, http://tinyurl.com/y4o7nt
20:55:05 <monochrom> Hugs?  OK sorry.
20:55:08 <Cale> fizbin: use :also ModuleName
20:57:19 * fizbin restarts hugs, since using "also" caused hugs to spit out error messages and do nothing else but repeat the error that Control.Monad.Instances was already loaded.
20:58:33 <fizbin> And now, it works, sort of.
20:59:07 <Cale> Hugs is strange about loading modules
20:59:32 <Cale> Probably the easiest way to be sure that you've got what you want is just to load a file which imports all the modules you want.
21:25:45 <mgsloan> http://subtextual.org/demo1.html <- wierd ass combination of interpreting/writing/debugging all in one.  the guy is very smart, but criticizes monads/functional programming. indeed, its about the opposite of haskell. interesting from a stretch-your-conception-of-programming kinda way though.
21:25:46 <lambdabot> Title: Subtext demo
21:28:12 <niarium> was ECP an opposite of monads/FP?!
21:28:47 <mgsloan> well, its not really opposite.  It's like prototype programming taken to an extreme, involving functions as well
21:28:56 <mgsloan> it shares laziness with haskell though
21:32:52 <newsham> hmm.. this thing is getting stuck after 42 seconds
21:35:32 <mgsloan> hmm
21:35:52 <newsham> have you watched it all the way through?
21:35:59 <mgsloan> could read his blog post which is mostly offensive towards haskellers http://alarmingdevelopment.org/index.php?p=5
21:36:01 <lambdabot> Title: Alarming Development » Blog Archive » Manifesto of the Programmer Liberation F ...
21:36:16 <mgsloan> yeah, then it went on to the next one which talks about IO and mutable state
21:36:19 <newsham> i dont mind offense
21:36:55 <newsham> if it makes me think
21:37:46 <mgsloan> yeah.  He criticizes monads, but it looks like his IO is basically monadic
21:38:50 <mgsloan> definitely makes you think. the screencast is a bit slow, but you need the time to really get it
21:40:23 <newsham> Programming is stuck in an evolutionary dead-end: the use of character strings to encode programs. Every other computer-mediated form of expression has evolved beyond text into sophisticated WYSIWYG interfaces to complex data structures.
21:40:30 <newsham> i guess he hasnt heard about logic design.
21:40:49 <newsham> which has migrated from grpahical wysiwyg interfaces into textual specifications
21:41:07 <mgsloan> heh. has it?  I thought it was the normal textual -> graphical
21:42:08 <newsham> eg. vhdl
21:42:22 <mgsloan> yeah, i've seen em
21:43:26 <mgsloan> if you do get the screencast to work, apparently he's working on a new interface, as he admits this one is a bit unclear and complicated
21:45:18 <newsham> "concrete examples ground abstractions" .. i like that.
21:45:46 <mgsloan> me too
21:46:00 <newsham> (mostly cause I say it a lot ;-)
21:46:08 <dancor> i don't like how slow the demo goes
21:46:09 <jcreigh> @type (1-) . product . map (1-)
21:46:11 <lambdabot> forall a. (Num a) => [a] -> a
21:46:16 <mgsloan> but his implementation seems pretty clunky.  not elegant enough to warrant the Buddha
21:46:17 <dancor> it needs a speed abstraction
21:46:46 <mgsloan> dancor - yeah, it is a bit slow, I don't see a much better way to get a good look at the lang though
21:47:10 <newsham> i'd be much more interested in computer-assisted-programming than grpahical programming.
21:47:24 <Nafai> newsham: What do you mean by computer-assisted-programming?
21:47:34 <jcreigh> hmm...I have "probOneOf = (1-) . product . map (1-)" but GHC gives it a type of [Integer] -> Integer unless I give it a type signature. Why?
21:47:36 <mgsloan> it's not really that graphical
21:47:48 <newsham> i mean i kinda direct my computer to write bits of my programs.  when it needs more help it asks me.
21:47:52 <newsham> like working with an intern
21:47:57 <eviltwin_b> jcreigh: monomorphism restriction
21:48:08 <mgsloan> hmm, that could be cool
21:48:40 <newsham> and it performs program transforms as needed  "instead of using an assoclist lets try using a hash table"
21:48:53 <jcreigh> eviltwin_b: Okay, thanks, I'll google that term and see what the deal is.
21:49:17 <eviltwin_b> basically, haskell98 artificially restricted type inference to avoid some difficult situations
21:49:27 <dancor> i find it hard to believe collapsable tabs to find functions are really going to speed up or improve programming for me
21:50:00 <eviltwin_b> with ghc you can compile with (IIRC) -fno-monomorphism-restriction to avoid it, as it's got a smarter inference engine than assumed by haskell98
21:50:29 * eviltwin_b generally just types stuff appropriately, it helps with diagnosing problems
21:50:36 <mgsloan> dancor - heh, yeah, it seems really slow.  Takes him ages to get a factorial off the ground
21:51:02 <eviltwin_b> (otherwise you could find your type unexpectedly restricted by a typo somewhere where it's used)
21:52:05 <dancor> i think the idea of getting nontextual is interesting but i'm not moved by the collapsable tabs
21:52:54 <newsham> so he has these rules for propogating/not-propogating changes...  but what about merging divergent copies?
21:53:19 <jcreigh> hmm, but "prob2 lst = (1-) . product $ map (1-) lst" would work. and the wiki has some helpful info. So I guess the lesson for today is "just write type signatures". (I should anyway, because it seems like GHC is able to give better error messages when it has some clue what you were expecting.)
21:53:32 <eviltwin_b> exactly
21:55:54 <mgsloan> dancor - most of the emphasis isn't really on the collabseable tabs business.  That seems to be more of a 'this is how it is for now'
21:55:59 <newsham> its interesting that there are no syntax errors in the graphical function editing
21:56:36 <eviltwin_b> for example, I initially avoided adding type signatures to the stuff I was working on today because I wasn't quite sure what type I wanted, but that came back to haunt me because I kept forgeting that truncate returns an Integral type
21:56:42 <_lygaret> hey, can I ask a favor of someone with some time? I have a program (my first non-tutorial haskell program actually) that I would love to have someone look at and let me know what I could do to make it better. It works, but there are things that I am pretty sure aren't really 'haskell-isms' all over it.
21:57:05 <sorear> would this graphical editor force me to use a mouse?
21:57:14 <eviltwin_b> so things kept reverting to Integer on me until I sat down and worked out what I really wanted (in terms of typeclasses, actually, not types) and then ghc told me where the real problem was
21:57:21 <eviltwin_b> @paste
21:57:22 <lambdabot> http://paste.lisp.org/new/haskell
21:57:23 <sorear> sure, _lygaret
21:58:39 <_lygaret> getting a proxy error?
21:59:05 <_lygaret> can I post a url? I had 2html.vim spit out an html file for me
21:59:25 <sorear> sure
21:59:33 <_lygaret> cool - http://jon.crazybaglok.com/haskell/Turing.hs.html
21:59:35 <lambdabot> Title: ~\Desktop\turing\Turing.hs.html
22:00:16 <rc-1> is there a reason to write formal declarations other than to enhance readability?
22:00:22 <_lygaret> just a turing machine, but it's my first program written without stepwise instructions in haskell
22:00:35 <eviltwin_b> you mea type signatures?
22:00:49 <eviltwin_b> (1) avoids the dreaded monomorphism restriction
22:01:12 <dancor> _lygaret: you don't need if () then True else False
22:01:15 <eviltwin_b> (2) avoids a thinko in using a function causing haskell to unexpectedly limit its type
22:01:34 <dancor> _lygaret: you can just have the () part
22:01:53 <_lygaret> ahh, duh - it just returns a Bool, thanks :D
22:02:34 <eviltwin_b> (3) helps haskell tell you what's *really* wrong (especially in context of #2)
22:02:38 <sorear> Usually it is better to represent a turing machine as a reversed list of items left of the head and a list ... right of the head
22:03:09 <_lygaret> so pop from one to the other, instead of splitting and concating the lists?
22:03:10 <sorear> much faster & much less memory (O(1) vs. O(n) per step), plus no size limits
22:03:13 <sorear> yea
22:03:50 <rc-1> ahok thanks
22:04:08 <Cale> mgsloan: It's sort of the smalltalk of functional languages, isn't it? :)
22:04:11 <sorear> The standard libraries have a Data.Map type, don't roll your own alist
22:04:44 <_lygaret> the transition list?
22:04:56 <_lygaret> map from a tuple to a triple :P alright yeah :D
22:04:57 <_lygaret> thanks
22:05:08 * eviltwin_b spent much of the day fighting with ghc telling him his functions were using Integral types because of a thinko in one place where they were invoked, until he retrofitted proper type signatures
22:06:11 <mgsloan> Cale - the subtext thing?  Yeah, kinda similar with the sorta image approach
22:06:17 <_lygaret> alright - back in 40 minutes :D thanks dancor, sorear :D
22:06:20 <sorear> These days I see projection functions (t_curstate et alia) as a bad sign in my code, though it is not always easy to see what the right approach it
22:06:21 <Cale> yeah
22:06:22 <mgsloan> (image as in the environment is the program)
22:06:55 <_lygaret> I couldn't find anything definitive: is there a record type in haskell?
22:07:12 <_lygaret> that would solve the issue I think, though it would just move the projection into the language.
22:07:44 <rc-1> have no clue what a thinko is though!
22:08:05 <dancor> so when can i start using haskell-prime
22:08:15 <_lygaret> typo = error in typing, thinko = error in thinking?
22:08:26 <rc-1> lol :)
22:08:34 <_lygaret> i think?
22:08:41 <_lygaret> unless that's a complete thinko ;)
22:08:41 <rc-1> would be thino then!
22:08:47 <_lygaret> hah
22:13:09 <newsham> one thing i like about this is that it incorporates programming histories into the debugger (which in this case is the editor/interpretter/interface)
22:15:24 <eviltwin_b> _lygaret: exactly
22:15:48 <newsham> typogrpahical error
22:15:51 <newsham> thinkogrpahical?
22:17:24 <lispy> topographical?
22:17:42 <eviltwin_b> well, it was certainly both a thinking error and a logical error :>
22:18:03 <eviltwin_b> i.e. thinkological error instead of typographical
22:18:53 <_lygaret> logico?
22:19:03 <_lygaret> logio
22:19:15 <_lygaret> logigo <- I like that one best :D
22:20:10 <mgsloan> newsham - yeah, would be interesting if this could be collaborative
22:20:27 <mgsloan> well, I know it can be.  Would be interesting to see it in action though ;p
22:20:46 <mgsloan> actually this model might lend itself very well to colab...
22:22:06 <Itkovian> http://headrush.typepad.com/creating_passionate_users/2006/12/how_to_build_a_.html
22:22:08 <lambdabot> Title: Creating Passionate Users: How to Build a User Community, Part 1, http://tinyurl.com/y2jvu5
22:22:18 <Itkovian> I think #haskell is doing quite well in this regard, eh :-)
22:22:41 <jcreigh> I blame lambdabot :)
22:23:15 <_lygaret> do multiple bindings in a let statement work?
22:23:33 <newsham> > let x = 3; y = 2 in x + y
22:23:33 <_lygaret> so let (x, y, z) = someTriple in
22:23:34 <lambdabot>  5
22:23:45 <newsham> > let (x,y) = (3,2) in x + y
22:23:46 <lambdabot>  5
22:24:04 <_lygaret> aha, killer, thanks
22:28:42 <_lygaret> > length [1, 2, 3]
22:28:43 <lambdabot>  3
22:41:00 <leather> Can somebody give me a monadic no-op expression?
22:41:17 <newsham> like "return" ?
22:41:27 <leather> @type return
22:41:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
22:41:47 <newsham> > [1,2) >>= return
22:41:48 <lambdabot>  Parse error
22:42:11 <newsham> > [1,2] >>= return
22:42:13 <lambdabot>  [1,2]
22:42:19 <newsham> > Maybe 3 >>= return
22:42:21 <lambdabot>  Not in scope: data constructor `Maybe'
22:42:28 <newsham> > Just 3 >>= return
22:42:29 <lambdabot>  Just 3
22:42:44 <newsham> > Nothing >>= return
22:42:45 <lambdabot>  Add a type signature
22:43:41 <kaol> > (Nothing :: Maybe ()) >>= return
22:43:42 <lambdabot>  Nothing
22:43:43 <leather> I'm not using Maybe.
22:44:31 <eviltwin_b> so?
22:44:41 <eviltwin_b> what exactly are you looking for?
22:44:44 <leather> I don't think return is what I want. I think I need 'id' or something.
22:45:25 <dons> ?type id
22:45:26 <lambdabot> forall a. a -> a
22:45:28 <newsham> ?pl \x -> x >>= return
22:45:29 <lambdabot> id
22:45:33 <dons> ?type \x -> return (id x)
22:45:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
22:46:19 <newsham> ?type (>>= return)
22:46:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
22:46:22 <leather> I'm doing a recursive 'for' function that performs N IO a expresions.
22:47:03 <leather> So, I have "for 0 _ = ..." and "for n exp = ..."
22:47:29 <newsham> mapM_ [1..5] (print "hi")
22:47:47 <newsham> do you need to propagate state between iterations?
22:47:52 <leather> Nope.
22:48:28 <newsham> so something like  "repeatN n act = mapM_ act [1..n]"  ?
22:49:44 <leather> Something like that. mapM_ is not working though.
22:49:57 <newsham> mapM_ (\_ -> act) [1..n}  ?
22:50:05 <leather> @type mapM_
22:50:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
22:51:02 <zptao> :(
22:51:15 <newsham> Prelude> let repeatM_ n act = mapM_ (const act) [1..n]
22:51:15 <newsham> Prelude> repeatM_ 3 (print "hi")
22:51:16 <newsham> "hi"
22:51:17 <newsham> ...
22:52:24 <leather> @type const
22:52:26 <lambdabot> forall a b. a -> b -> a
22:52:34 <leather> What's const?
22:52:53 <newsham> ?type (const 3)
22:52:55 <sieni> > const 2 5
22:52:55 <lambdabot> forall a b. (Num a) => b -> a
22:52:57 <lambdabot>  2
22:52:57 <newsham> > (const 3) 25
22:52:59 <lambdabot>  3
22:53:21 <sieni> > const "java sucks" [4,5]
22:53:22 <lambdabot>  "java sucks"
22:53:45 <newsham> ?type Control.Monad.replicateM_
22:53:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
22:53:53 <newsham> looks like someone already made one.
22:54:01 <leather> Ha! :)
22:54:18 <_lygaret> is there a way to throw print statements in for debugging?
22:54:31 <leather> So, const takes two args and throws away the second?
22:54:44 <newsham> replicateM_ 3 (print "hi")   works
22:54:54 <newsham> ?type Trace
22:54:56 <lambdabot> Not in scope: data constructor `Trace'
22:55:03 <newsham> ?hoogle Debug.Trace
22:55:04 <lambdabot> No matches, try a more general search
22:55:08 <newsham> ?hoogle Trace
22:55:09 <lambdabot> Debug.Trace :: module
22:55:10 <lambdabot> Debug.Trace.trace :: String -> a -> a
22:55:10 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
22:55:10 <leather> Yeah, your mapM_ solution worked, too, once I added the const.
22:56:48 <newsham> trace "foo" 5 results in 5 while printint "foo"
22:57:05 <leather> newsham: replicateM_ looks like what I want. Thanks!
22:57:27 <leather> That's one problem I'm constantly running into: trying to figure out what's available and how it works.
22:57:34 <newsham> the various mapM/mapM_ forM, foldM, etc..  do a lot of the types of loops you might want to do
22:58:07 <dons> _lygaret: using 'trace', or something similar, yeah
22:58:10 <newsham> do you know about hoogle and the docs for the heirarical libs?
22:58:30 <_lygaret> hah, newsham and leather just figured it out for me without even knowing it :D
22:58:32 <leather> I do. But Hoogle requires you to know what you want.
22:58:32 <_lygaret> thanks dons
22:58:49 <dons> leather: well, you can guess on the name or the type
22:58:50 <leather> And the docs require you to understand each function from its name. ;)
22:59:00 <dons> ?hoogle Int -> [a] -> a
22:59:01 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
22:59:09 <dons> ?hoogle index
22:59:09 <lambdabot> Ix.index :: Ix a => (a, a) -> a -> Int
22:59:10 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
22:59:10 <lambdabot> Data.Generics.Basics.indexConstr :: DataType -> ConIndex -> Constr
22:59:12 <newsham> leather: sure, but sometimes you can guess pretty well, like "I want something that uses an integer and an action and runs the action that many times"
22:59:23 <newsham> might get you guessing to hoogle for  Int -> m () -> m()
22:59:36 <leather> True. I could've done that.
22:59:39 <dons> ?hoogle Monad m => Int -> m a -> m ()
22:59:40 <lambdabot> No matches, try a more general search
22:59:40 <newsham> or perhaps m () -> Int -> m ()
22:59:48 <dons> ?hoogle Int -> m a -> m a
22:59:49 <lambdabot> No matches, try a more general search
22:59:59 <dons> ?hoogle Monad m => Int -> m a -> m [a]
23:00:00 <lambdabot> No matches, try a more general search
23:00:02 <dons> bah
23:00:05 <newsham> ?hoogle (Monad m) => Int -> m () -> m ()
23:00:06 <dons> ?type replicateM_
23:00:06 <lambdabot> No matches, try a more general search
23:00:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
23:00:13 <dons> ?hoogle (Monad m) => Int -> m a -> m ()
23:00:14 <lambdabot> No matches, try a more general search
23:00:17 <dons> ah!
23:00:21 <dons> ndm, whyfore? ^^
23:00:24 <leather> ?type Control.Monad.replicateM_
23:00:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
23:00:42 <newsham> ?hoogle (Monad m) => Int -> m a -> m a
23:00:43 <lambdabot> No matches, try a more general search
23:00:50 <dons> ?hoogle rep
23:00:51 <lambdabot> Prelude.repeat :: a -> [a]
23:00:51 <newsham> ?hoogle (Monad m) => Int -> m a -> m [a]
23:00:51 <lambdabot> Prelude.replicate :: Int -> a -> [a]
23:00:51 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
23:00:52 <lambdabot> No matches, try a more general search
23:01:03 <dons> probably a buglet fixed in the new hoogle
23:01:07 <dons> i should update ambdabot's version
23:02:08 <leather> I was playing with the code here: http://haskell-web.blogspot.com/2006/11/transactional-cache-for-haskell.html
23:02:10 <lambdabot> Title: Haskell and Web: Haskell Transactional Cache, http://tinyurl.com/sj4hk
23:02:16 <leather> And he has a 'for' in main.
23:02:27 <leather> It wasn't compiling...
23:02:36 <leather> So, I thought I'd try to figure it out myself. :P
23:03:01 <dons> ah, forM_ ?
23:03:13 <dons> ?let forM_ = flip mapM_
23:03:14 <lambdabot> <local>:19:13:     Ambiguous type variable `m' in the constraint:       `Mona...
23:03:23 <dons> > L.forM_ [1..10] print
23:03:24 <lambdabot>  Not in scope: `L.forM_'
23:03:25 <leather> Well, that code has a plain "for".
23:03:36 <dons> ?undefine
23:03:37 <lambdabot> Undefined.
23:03:42 <dons> ?let for = flip mapM_
23:03:43 <lambdabot> <local>:1:11:     Ambiguous type variable `m' in the constraint:       `Monad...
23:03:57 <newsham> dons: in this code they're not using the arg, so more like repeatM_ than forM_
23:03:57 <dons> ?undefine
23:03:58 <lambdabot> Undefined.
23:04:02 <dons> ah ok
23:04:11 <leather> newsham: Yep.
23:13:44 <_lygaret> anyone mind looking at my second version?
23:14:00 <_lygaret> dancor?
23:14:14 <_lygaret> http://jon.crazybaglok.com/haskell/Turing2.hs.html
23:14:16 <lambdabot> Title: ~\Desktop\turing\Turing2.hs.html
23:17:15 <dons> looking...
23:17:22 <_lygaret> :) thanks
23:18:05 <dons> I'd stick the TransitionMap -> Tape -> [Symbol] in a State monad
23:18:13 <dons> but that's probably an exercise for the reader :)
23:18:24 <dons> no need to use multiple lets in a row
23:18:26 <dons> let new_ltape = wsym : ltape in
23:18:26 <dons> 22                      let new_rtape = tail rtape in
23:18:36 <dons> is the same as: let a = b ; d = e in ...
23:18:41 <dons> where the ';' is a newline
23:18:48 <_lygaret> ok, killer
23:19:44 <newsham> too much computer today.. sleep.. g'nite.
23:20:10 <_lygaret> dons, can you explain what you mean about the state monad?
23:20:22 <_lygaret> the state being the tapes?
23:21:45 <dons> _lygaret: http://www.cse.unsw.edu.au/~dons/tmp/x.hs
23:21:49 <dons> that's a quick refactor
23:21:59 <dons> yeah, everything you need to pass around you could stick in the machine 'state'
23:22:06 <dons> let me see if I can whip that up ...
23:23:11 <_lygaret> thanks dons - you don't have to if you don't have the time, I appriciate even this much, a lot.
23:24:31 <dons> what's : type State         = String
23:24:32 <dons> ?
23:24:43 <_lygaret> The current machine state
23:24:50 <dons> stored as a string?
23:25:16 <dons> ah I see: "s" et al ?
23:25:17 <_lygaret> yeah
23:25:22 <_lygaret> yep
23:25:29 <dons> why not use a data type for that?
23:25:37 <dons> data State = S | B ?
23:25:51 <_lygaret> because that's only valid for this particular test
23:25:54 <dons> ah ok
23:26:17 <_lygaret> there is probably a better way to do it, but I can't determine what states should be available beforehand
23:27:43 <_lygaret> is there a reason to put the triple projection in a where instead of a let, or is it aesthetics and convention?
23:32:14 <ibid> _lygaret: there are situations where you can only use let or only use where, but they are special cases that one doesn't usually encounter. in all normal cases, it's just a matter of style
23:33:22 <_lygaret> *nod*, alright thanks ibid
23:43:15 <Cale> The difference between let and where is that let is part of expression syntax, while where is part of declaration syntax, and scopes over guards.
23:44:58 <_lygaret> does that mean that let x = 10 in print "hi" | x < 5 wouldn't work?
23:45:03 <_lygaret> or something like that
23:45:59 <_lygaret> wait, nm, that was stupid -
23:46:22 <falconair> i've been compiling GHC 6.6 for over an hour now, does it really take so long?
23:46:54 <dons> you can build it in 9mins 44secs (that's my record ;)
23:47:26 <falconair> crap, so there might be a problem then?  i'm using OSX's port system
23:47:30 <_lygaret> > let min = 10 in fac 0 = 1 ; fac n | n < min = n * fac (n - 1)
23:47:30 <lambdabot>  Parse error
23:47:49 <_lygaret> :P that's helpful lol
23:49:02 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/03#build_ghc_fast
23:49:03 <lambdabot> Title: Haskell, hacking and other stuff
23:49:19 <dons> > let min = 10 ; fac 0 = 1 ; fac n | n < min = n * fac (n - 1) in fac 3
23:49:21 <lambdabot>  6
23:49:53 <_velco> > let max = 10 ; fac 0 = 1 ; fac n | n < max = n * fac (n - 1) in fac 3
23:49:54 <lambdabot>  6
23:50:05 <_lygaret> so let does scope through a guard?
23:50:16 <_lygaret> hmm
23:50:17 <_lygaret> alright
23:50:30 <dons> > let f | True = 1 in f
23:50:31 <lambdabot>  1
23:50:39 <dons> > let f | False = 1 in f
23:50:40 <lambdabot>  Non-exhaustive patterns in function f
23:50:43 <dons> :)
23:52:20 <_lygaret> > let f = True ; b | f = 1 in b
23:52:21 <lambdabot>  1
23:53:13 <_lygaret> does let <stmt> ; <stmt> ; <stmt> in mean the same as let <stmt> in ; let <stmt> in ; let <stmt> in?
23:53:22 <dons> yep
23:53:25 <dons> sort of...
23:53:27 <_lygaret> lol
23:53:40 <dons> (they can be mutually recursive when run together with ;
23:54:10 <_lygaret> alright, cool
23:54:24 <dons> > let x = 1 : y ; y = 1 : x in x
23:54:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:54:42 <dons> > let x = 1 : y in let y = 1 : x in x -- see for example
23:54:43 <lambdabot>  Not in scope: `y'
23:55:19 <_lygaret> oh, and that would make sense too, since the single let with multiple statements are all in the same scope.
23:55:20 <dons> so there's mutually recursive bindings that you can't write using let .. in let .. in
23:55:24 <dons> yeah
23:55:32 <_lygaret> hey, killer
23:56:06 <_lygaret> 100% more knowlegdable than I was this afternoon :D
23:56:16 <_lygaret> granted, it's from 1 to 2, on a scale of 100
23:56:21 <_lygaret> but whatev :D
23:56:28 <dons> interesting, http://www.quetzal.com/sambangu/2006/12/polynomials-as-numbers
23:56:32 <dons> _lygaret: great!
23:56:56 <_lygaret> thanks for your help guys; I have to get some sleep before work tomorrow
23:57:44 <_lygaret> I appriciate the refactor dons
23:57:58 <dons> cool
23:58:12 <dons> i've partially done the state monad versoin, but need to eat dinner first :)
23:58:33 <_lygaret> :D can I PM you my email address?
23:58:38 <dons> sure
23:59:04 <mbishop> He'll tell you he's gonna write, but he never will, that creep!
23:59:05 <mbishop> :P
23:59:23 <_lygaret> sounds of a bishop scored?
23:59:28 <_lygaret> scorned even :P
23:59:29 <mbishop> heh
23:59:45 <dons> hey mbishop
23:59:52 <mbishop> hello dons
