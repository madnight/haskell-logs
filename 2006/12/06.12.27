00:01:26 <dancor> a <- bracket () () ()   doesn't seem to cut it
00:02:24 <dancor> but it seems like it should..
00:05:49 <sorear> ?type bracket
00:05:50 <lambdabot> Not in scope: `bracket'
00:05:57 <sorear> ?hoogle bracket
00:05:57 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
00:05:57 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
00:05:57 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
00:06:58 <sorear> ?type IO.bracket (return ()) (\_ -> return 17) (\_ -> return ())
00:07:00 <lambdabot> IO ()
00:07:20 <sorear> must you use bracket?
00:07:26 <sorear> ?hoogle catch
00:07:27 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
00:07:27 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
00:07:27 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
00:07:55 <sorear> ?type Control.Exception.catch (return 42) (\_ -> return 0)
00:07:56 <lambdabot> forall a. (Num a) => IO a
00:08:38 <sorear> oh, wait
00:09:05 <sorear> bracket returns a value regardless of whether the inner computation returned
00:09:14 <sorear> (as opposed to being interrupted)
00:09:28 <sorear> so it cannot in general give a value.
00:11:50 <mgsloan> ClaudiusMaximus: well, the author of pd is behind DesireData, so I wouldn't consider it too much of a branch.  more like a subsuming-rewrite :)
00:13:26 <mgsloan> maybe not rewrite.
00:14:20 <ClaudiusMaximus> mgsloan: the main author of Pd is Miller Puckette, the main author of DesireData is Mathieu Bouchard, where'd you get the idea that they were the same person?
00:15:09 <mgsloan> not that they were the same person, just the matju is in #desiredata :)
00:17:53 <Excedrin> what are pd and desiredata? is it something that can show pictorially what it is?
00:18:54 <mgsloan> visual data flow language
00:19:03 <mgsloan> mainly multimedia applications
00:46:58 <mgsloan> is it possible to diff graphs?
00:51:26 <ClaudiusMaximus> mgsloan: this link tells me "probably yes" >> http://www.w3.org/DesignIssues/Diff
00:51:27 <lambdabot> Title: RDF Diff, Patch, Update, and Sync -- Design Issues
00:51:49 <mgsloan> ah, interesting
00:51:55 <pierre-> hello
01:34:18 <dons> ?uptime
01:34:19 <lambdabot> uptime: 5d 8h 53m 4s, longest uptime: 9d 2h 23m 6s
01:34:21 <dons> ?users
01:34:22 <lambdabot> Maximum users seen in #haskell: 309, currently: 259 (83.8%), active: 15 (5.8%)
02:13:55 <dons> ?yow
02:13:56 <lambdabot> All of a sudden, I want to THROW OVER my promising ACTING CAREER, grow
02:13:56 <lambdabot> a LONG BLACK BEARD and wear a BASEBALL HAT!! ...  Although I don't know
02:13:56 <lambdabot> WHY!!
02:14:06 <dons> mmm. yes, that's good advice
03:17:34 <augustss> @quote dons
03:17:35 <lambdabot>  who was it who said (shapr?) that they welcome their competitors using languages other than haskell? it's a bad sign if your enemies start coding in haskell!
03:22:52 <[d-_-b]> i want to save a value to a 3º line of a file... how can i do this?
03:23:26 <augustss> from Haskell?
03:23:46 <[d-_-b]> ya...
03:23:48 <[d-_-b]> { x <- openFile "dat2.dat" ReadMode;
03:23:49 <[d-_-b]> 		contents <- readFile "dat2.dat";
03:23:49 <[d-_-b]> 		fmap (( !! 2) . lines) (hGetContents x)
03:23:49 <[d-_-b]> 		}
03:24:06 <[d-_-b]> this function read the 3º line of a file
03:24:17 <[d-_-b]> but i want write not read
03:24:49 <[d-_-b]> i change ReadMode to WriteMode and readFile to writeFile but won't works :(
03:25:08 <augustss> why is the line 'contents <- ...' there?
03:25:39 <[d-_-b]> humm ...
03:25:49 <augustss> anyway, what you need to do is real the file, replace the 3rd line, and write it back
03:26:03 <[d-_-b]> ya
03:26:10 <[d-_-b]> thats it
03:28:43 <[d-_-b]> in fact your are rigth! "contents <- readFile "dat2.dat" it is useless
03:48:06 <[d-_-b]2> anyone answer my question??
03:48:32 <[d-_-b]2> the power turns off ... i don't see
03:48:49 <[d-_-b]2> augustss
03:49:10 <JohnMeacham> you don't need both openFile and readFile. you only need the readFile or writeFile most likely.
03:49:37 <[d-_-b]2> um ok
03:49:54 <[d-_-b]2> but how can i save a value on a 3º line of a file?
03:49:57 <[d-_-b]2> do you know?
03:50:41 <JohnMeacham> you want to replace the third line of an existing file? or print two blank lines then a line?
03:51:02 <[d-_-b]2> replace the third line of an existing file
03:51:24 <JohnMeacham> ah, then you should read the old file, write out a new file to a temporary name, and move it over the original file.
03:52:04 <petter_> is the temporary file needed?
03:52:33 <earthy> petter_: for atomicity, yes
03:52:54 <JohnMeacham> yes. at least, it is better to use it. because then you benefit from lazy evaluation (it can process the file as a stream) and if your program messes up partyway through, it won't clobber your input file.
03:53:08 <[d-_-b]2> my file has 2 fixed values on first and second lines. and i want only replace the third line
03:53:25 <petter_> ah, otherwise you have to keep the enrire file in memory
03:53:28 <earthy> much more importantly: another program won't mess your stuff up while you're doing work
03:54:53 <JohnMeacham> indeed. I had lots of fun exploring the boundries of what can be acomplished with just fs atomicity when writing vsdb. it turns out, a lot can. http://repetae.net/john/computer/vsdb/
03:54:57 <lambdabot> Title: VSDB
03:58:45 <mq_mattr> hi folks
04:00:30 <petter_> JohnMeacham: interesting
04:03:15 <petter_> JohnMeacham: what are the atomicity requirements mentioned?
04:20:55 <benja_> hum, is there a good reason that gtk2hs cairo matrices don't implement (+)?
04:29:15 <JohnMeacham> petter_ just what nfs provides. which are weaker than what unix provides
04:51:08 <dmhouse> Morning everyone.
04:59:21 <mwc> benja_, I'm not sure why you'd want to add matrices that represent affine transformations. It's effectively like splitting a src vector into two dst vectors, which isn't something you generally do with projective geometry
05:12:54 <ibid> mwc: benja_ wants to calculate (1-k)A + kB for two matrices A and B, and this for each frame in an animation (the goal is to animate from the start frame specified by A to the end frame specified by B)
05:13:02 <ibid> i gather
05:23:47 <fasta> When I import qualified Foo as F, how can I refer to operator (!) in module F? F.(!) nor F.! seems to work on the REPL.
05:25:27 <zeuxis> fasta: try (F.!), the qualifier belong to the name
05:26:05 <fasta> zeuxis: that's a really dark spot of Haskell or rather GHC syntax.
05:28:27 <dylan> Screw division, modules should use / for namespace seperation. ;)
05:28:58 <dmhouse> dylan: if only. How often is division used? Yet it gets one of the coveted one-symbol operator names.
05:30:27 <fasta> dmhouse: I wouldn't mind if (.) was dropped for composition and replaced with some "weird character"(Unicode).
05:30:48 <dmhouse> fasta: I would, because a) it's hard to type and b) editor support is dodgy.
05:31:38 <fasta> dmhouse: I wanted to add:"if they add a small script for a number of popular editors of how to insert the symbols".
05:31:47 <fasta> dmhouse: In Emacs it would be pretty easy.
05:32:22 <dmhouse> fasta: not as easy as hitting '.'.
05:32:25 <dylan> it's still not as easy to type as '.'
05:32:25 <fasta> dmhouse: (Starting from Emacs 22)
05:33:10 <dmhouse> fasta: I dislike the idea of a language that has to tell beginners how to user their editor in weird and wonderful ways in order to produce the most simple of programs.
05:33:35 <fasta> dmhouse: I think language and programming environment should not be separated.
05:34:14 <dylan> I think programming environment is as personal as one's office space.
05:34:15 <dmhouse> What I wouldn't object to is a 'Unicode mode' for compilers where actual lambdas were allowed to replace backslashes, some Unicode char replaces . for composition and so on.
05:34:23 <dcoutts__> benja_: what would it mean ?
05:34:25 <dcoutts__> (+) :: Matrix -> Matrix -> Matrix  ??
05:34:27 <dcoutts__> pointwise addition?
05:34:35 <dmhouse> How many seconds in a year?
05:34:39 <dcoutts__> ibid: (1-k)A + kB, so that's pointwise addition is it?
05:34:40 <dmhouse> > 86400 * 365
05:34:41 <lambdabot>  31536000
05:34:45 <dcoutts__> benja_: we're just about to do a new release of gtk2hs+cairo so if you want a change send in your patch and justification asap
05:34:55 * dmhouse sighs. What a wonderful interface cookies are.
05:35:32 <dcoutts__> dmhouse: ghc does accept unicode lambdas
05:35:39 <dcoutts__> as of ghc-6.6
05:35:49 <dmhouse> dcoutts__: that's cool. :)
05:36:00 <dmhouse> What else would be nice?
05:36:07 <dmhouse> \rarrow instead of '->'.
05:36:22 <ibid> dcoutts__: yes, matrix addition is pointwise
05:36:28 <dcoutts__> I think there's a few similar symbols that it accepts too, not sure how comprehensive it is
05:36:33 <dylan> dmhouse: about 31536000?
05:36:39 <fasta> dcoutts__: GHC accepts them, ghci doesn't, right?
05:36:42 <dcoutts__> ibid: so you think we should change that then?
05:36:51 <dcoutts__> fasta: ghci doesn't grok utf8
05:36:57 <dmhouse> dylan: thanks :P Check the next line after I asked that question.
05:37:04 <fasta> dcoutts__: And since a lot of development is done interactively, it's pointless.
05:37:04 <dylan> ah, right.
05:37:24 <fasta> dcoutts__: or do crank out a program and have it working the first time?
05:37:32 <dmhouse> Right, I'm off keyboard shopping.
05:37:35 <dmhouse> Bye all.
05:37:38 <fasta> bye
05:37:41 <ibid> dcoutts__: i don't know if there are any negatively affecting issues there, but yes, matrices ought to support addittion (when they have the same dimensions)
05:37:54 <dcoutts__> fasta: it can't be that hard to fix, has anyone filed a bug for ghci and utf8? there are some issues with terminals and character modes etc
05:38:01 <dcoutts__> ibid: ok
05:38:08 <fasta> dcoutts__: it should be fixed in 6.8
05:38:09 <ibid> dcoutts__: also multiplication by scalar, and vector multiplication, but i suppose those are already covered
05:38:34 <dcoutts__> fasta: oh, not in 6.6.1 ?
05:38:51 <dcoutts__> ibid: oh, apparently (+) and (-) are indeed already defined pointwise
05:38:56 <ibid> dcoutts__: and, of course, subtraction has the usual semantics A - B = A + (-1)B
05:39:01 <fasta> dcoutts__: The last time I looked in Trac it said 6.8
05:39:07 <dcoutts__>   (+) = pointwise2 (+)
05:39:07 <dcoutts__>   (-) = pointwise2 (-)
05:39:10 <ibid> dcoutts__: nice. benja_ seemed to find it otherwise
05:39:21 <dcoutts__> ibid: probably wasn't there in the last release
05:39:35 <benja_> that's probably it
05:39:38 <ibid> dcoutts__: ah, it's in the darcs version only? that explains it
05:39:39 <benja_> nice! :)
05:39:40 <ibid> dcoutts__: thanks
05:39:57 <ibid> benja_: you might want to try the release candidate or whatever it was
05:40:05 * benja_ thanks too :)
05:40:15 <dcoutts__> ibid, benja_: try http://haskell.org/gtk2hs/gtk2hs-0.9.10.3.tar.gz
05:40:33 <benja_> should probably do that when I get back to a place where I have network, yes :)
05:40:40 <ibid> dcoutts__: the trouble is that we who do "production" software try to avoid non-releases of dependencies :)
05:41:01 <ibid> benja_: there are networks around here somewhere, right?
05:41:29 <benja_> "production". ibid must be poking fun at me. ;)
05:41:42 <ibid> not at all. why do you think that?
05:41:44 <dcoutts__> ibid: sure, that's just the pre-release testing version of 0.9.11, I don't expect you to use it in production, jsut test it and report issues
05:41:48 <benja_> ibid, I could try to get wlan configured, yeah...
05:41:53 <ibid> dcoutts__: yeah, yeah :)
05:41:54 <dcoutts__> so that your next production version will work! :-)
05:41:58 <ibid> heh
05:42:03 <ibid> benja's actually
05:42:08 <ibid> i'm currently writing something in java
05:42:13 <benja_> can't use wired because I haven't informed the admins about my changed mac adcdr
05:42:16 * dcoutts__ runs away
05:42:20 <ibid> (a simulator for a RISC-style virtual machine)
05:42:30 <ibid> benja_: go and do that?
05:42:48 <dcoutts__> ibid: heh, at oxford we run practical on something similar where the sim is written in Haskell :-)
05:42:53 <benja_> ibid, ok :)
05:43:14 <dcoutts__> ibid: not that I defend that as a brilliant idea or anything
05:43:35 <ibid> dcoutts__: well, i don't expect my students to have taken the fp course, and i want them to have *something* that's familiar
05:43:59 <ibid> dcoutts__: last time we did this course the simulator was in C, and we wrote assembly to files from the compilers
05:44:01 <dcoutts__> ibid: sure sure, yeah it's only because fp is a compulsory intro course that we can get away with that
05:44:38 <benja_> ibid, write it in haskell and use finnish function names, then they have something familiar :)
05:44:49 <dcoutts__> heh
05:45:29 <ibid> (the course is principles of programming languages, but i want to use small compilers for demonstrating the implementation of constructs)
05:45:38 <ibid> (did that last time)
05:45:48 <ibid> benja_: bah!
05:45:48 <dcoutts__> benja_: would you mind taking a look at the current darcs version of that matrix module and telling me if it's got everything you need/expect ? http://darcs.haskell.org/gtk2hs/cairo/Graphics/Rendering/Cairo/Matrix.chs
05:45:51 <lambdabot> http://tinyurl.com/yxbpjc
05:47:06 <dcoutts__> ibid: I helped demonstrate a coure like that, we used the TAPL book a lot, it's quite good. It has plenty of exercises that one can use for practicals and it comes with code.
05:47:23 <ibid> hrm
05:47:52 <ibid> dcoutts__: a problem might come from the constant 0/1 elements of the matrices
05:48:04 <ibid> dcoutts__: but then again, scalar multiplication would too have that problem
05:48:14 <dcoutts__> ibid: you mean (fromIntegral 0 :: Matrix) ?
05:49:20 <ibid> dcoutts__: no, i mean that the matrices are 3x3 with constant elements. an element of value 1 would map to k if the matrix is scaled by k
05:49:25 <ibid> dcoutts__: how is that handled?
05:49:54 <dcoutts__> ibid: fromIntegral 1 = identity
05:49:58 <ibid> dcoutts__: remind me, TAPL?
05:50:04 <dylan> "And way-hey-hey, it's just an ordinal day..."
05:50:07 <ibid> dcoutts__: that's not what i'm talking about
05:50:22 <dcoutts__> ibid: ok, try explaining again, I'm clearly confused
05:50:40 <dcoutts__> ibid: "Types And Programming Languages"
05:50:47 <dcoutts__> @google Types And Programming Languages book
05:50:51 <ibid> dcoutts__: ah. but that uses interpreters?
05:50:51 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
05:50:51 <lambdabot> Title: Types and Programming Languages
05:50:54 <ibid> dcoutts__: yes, i know that book
05:51:28 <dcoutts__> ok, it's mostly not about code generation and more about compiler front ends and language semantics
05:51:53 <ibid> dcoutts__: i'm referring to the "The 'Matrix' type actually represents as 3x3 matrix [...]" comment at the top
05:52:27 <dcoutts__> ibid: yes, it's a 3x3 with 2 constant elements as it only represents 2d affine transforms
05:52:43 <dcoutts__> ie no perspective transforms
05:53:01 <ibid> dcoutts__: yes, and there comes the problem with addition and scalar multiplication (maybe even matrix multiplication, not sure)
05:53:27 <ibid> dcoutts__: in matrix algebra, kA multiplies every element of A by k, so the 0 0 1 row transforms to 0 0 k
05:53:35 <ibid> column, not row
05:53:39 <dcoutts__> ibid: ah, so we can't do that
05:54:15 <ibid> dcoutts__: yeah, and A + B will result in 0 0 2 in the result matrix :)
05:54:16 <dcoutts__> ibid: (*) is ok for matricies that are already only affine
05:54:34 <ibid> benja_: see above ^^
05:55:24 <ibid> dcoutts__: it'd work if the matrix was simply 2x2 or 2x3 (or is it 3x2, i never remember how this goes)
05:55:41 <ski> @where TaPL
05:55:41 <lambdabot> I know nothing about tapl.
05:55:53 <ski> @where+ TaPL http://www.cis.upenn.edu/~bcpierce/tapl/
05:55:53 <lambdabot> Done.
05:56:33 <ibid> dcoutts__: hm, three constant elements, not two, surely? (in the comment)
05:56:42 <dcoutts__> ibid: yeah, so we probably need to rethink just what ops are available, it should only be those that are total on affine
05:57:11 <ibid> dcoutts__: benja's (1-k) A + k B ought to be valid, though
05:57:18 <ski> hm, is the other 'AtiTaPL' or 'AtTaPL' ?
05:57:37 <ibid> dcoutts__: but it probably needs to be implemented directly in your library, to avoid exposing plain addition
05:57:46 <dcoutts__> ibid: hmm
05:57:59 <ski> @where+ ATTaPL http://www.cis.upenn.edu/~bcpierce/attapl/
05:57:59 <lambdabot> Done.
05:58:07 <dcoutts__> ibid: so '(1-k) A + k B'  is scalar multiplication and pointwise + right ?
05:58:18 <ibid> dcoutts__: yeah
05:58:36 <ibid> dcoutts__: result_ij = (1-k) a_ij + k b_ij
05:59:53 <ibid> dcoutts__: (1-k) 1 + k 1 = 1 - k + k = 1, and (1-k) 0 + k 0 = 0 + 0, so it is safe
06:00:02 <dcoutts__> I see
06:00:09 <dcoutts__> what's that function called ?
06:00:37 <ibid> dcoutts__: no idea for an official name, but benja and i are calling it interpolation :)
06:00:50 <dcoutts__> ibid: so scalar multiplication is ok, but pointwise +/- is not, right ?
06:01:03 <ibid> dcoutts__: scalar multiplication has the same problem as addition
06:01:23 <ibid> dcoutts__: because it's pointwise multiplication, and thus scales the constant 1
06:01:24 <dcoutts__> ibid: oh because one of the constants is 1
06:01:27 <dcoutts__> yep
06:01:41 <ibid> dcoutts__: if all the constants were 0, addition would not have a problem either
06:01:48 <dcoutts__> yeah
06:02:02 <ibid> this actually is rather icky
06:02:42 <dcoutts__> but the perspective transforms make no sense, we really are restricted to affine
06:03:06 <ibid> yeah. why pretend that there are the constant entries?
06:03:20 <ibid> just have a 2x2 matrix
06:03:31 <ibid> (of course that restricts us to a linear transformation)
06:03:55 <ibid> but a 2x3 matrix ought to work
06:04:29 <ibid> oh, i see
06:04:47 <ndm> @seen lambdabot
06:04:47 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah, #haskell, #Haskell and #
06:04:47 <lambdabot> ScannedInAvian
06:04:52 <ibid> i wonder how these things have been traditionally solved
06:06:08 <maskd>  /list #scannedinavian
06:06:09 <ibid> agh!
06:07:56 <AStorm> Hello again.
06:08:23 <AStorm> Is there some nice type/datatype/etc/class/kind tutorial?
06:09:12 <benja_> thanks for the discussion, both  of you :)
06:09:21 <ibid> benja_, dcoutts__: i rechecked.  the interpolation function works even with this affine interpretation of the matrices
06:10:36 <AStorm> YAHT leaps a bit too far for me. I'd like something complete but less steep.
06:11:09 <ibid> dcoutts__: scalar multiplication and addition/subtraction do not make sense, as we suspected
06:11:14 <metaperl> YAHT is probably as good as it gets INHO
06:11:16 <metaperl> IMHO
06:11:29 <metaperl> the "algorithms" book is not bad either
06:11:29 <uccus> there should be a grant unification project for Haskell tutorials
06:11:54 <kowey> uccus: the wikibook attempts to remix heavily
06:11:56 <uccus> *grand [blushes]
06:12:29 <kowey> we've got yaht, write yourself a scheme, jeff newbern's stuff, some original content, all mashed up and duct-taped together
06:12:30 <ndm> what i would like is a meta-tutorial
06:12:42 <ndm> a list of questions about haskell, what does this do, do you understand this etc
06:12:53 <ndm> and if you say no, it points you at a tutorial which explains it
06:12:56 <uccus> well, mashed up and duct-taped is not good
06:13:09 <ndm> is there a tutorial on pattern matching, for instance?
06:13:12 <uccus> aah. yes. I agree with ndm
06:13:15 <kowey> we could use some heavy editing
06:13:16 <ndm> which covers ~, !, @ etc
06:13:40 <kowey> right, me too... it's like the malcolm gladwell stuff
06:13:44 <uccus> the wikibook can do that
06:13:59 <kowey> many "right" flavours of coffee, pepsi; extra-chunky tomato sauce, etc
06:14:07 <uccus> it's divided into sections... they can contain links to complete tutorials
06:14:26 <uccus> everyone has a different style of tutoring you know...
06:14:33 <kowey> i agree
06:14:35 <cptn> good morning
06:14:44 <kowey> the wikibook right now is newbie-oriented
06:14:47 <ibid> dcoutts__: but scalar multiplication can be "simulated" as multiplication by (k,k,1)^T
06:14:56 <kowey> but we could steer it towards choose-your-own-adventureness
06:15:10 <uccus> kowey: the wikibook right now has different steams for newbie/advanced(?)
06:15:14 <kowey> comments on the discussion page on how we could implement this would be quite welcome
06:15:23 <kowey> we have two tracks, newbie and advanced
06:15:44 <kowey> although the advanced track assumes you've basically just gotten through the newbie track... it tries to be a friendly "advanced"
06:15:47 <uccus> yes, but shouldn't there be more?
06:16:01 <cptn> im having some trouble with gtk2hs and glade3
06:16:07 <uccus> tracks?
06:16:09 <kowey> well, it's got two tracks in terms of material, one track in terms of style
06:16:32 <kowey> what ndm is talking about is having multiple tracks in terms of style (well... style, level)
06:16:38 <uccus> I mean, the grand Haskell wikibook should contain things that are really advanced
06:16:53 <uccus> like tutes for gtk2hs...
06:17:05 <ndm> kowey: i more meant accepting there will be loads of tutorials, but trying to point people at those which will teach them something new
06:17:10 <uccus> *that* should be called advanced
06:17:12 <kowey> i tend to suspect that's more the Haskell wiki's job
06:17:19 <cptn> the code compiles and links
06:17:28 <cptn> but when it runs no windows appear
06:17:41 <kowey> although there is http://en.wikibooks.org/wiki/Haskell/GUI
06:17:50 <ndm> cptn: does it give a crash message on teh console?
06:18:15 <cptn> nope
06:18:17 <cptn> just hangs
06:18:34 <uccus> aaah. thanks kowey. that's enough I think.
06:18:52 <ndm> cptn: can you paste the code?
06:18:53 <ndm> @paste
06:18:54 <lambdabot> http://paste.lisp.org/new/haskell
06:19:01 <kowey> ndm: i think we're saying the same thing, although i'm speaking horribly imprecisely
06:19:02 <cptn> sure
06:19:21 <pejo> Without having read much - is it possible to get a coherent presentation when having multiple authors writing on a wiki?
06:19:23 <cptn> proxy error for that site
06:19:48 <pejo> Since the discussion somewhat seems to be relating to writing a book now.
06:19:49 <ndm> cptn: i get through fine...
06:19:49 <kowey> it can work, but you need enough "editor-minded" people to do it
06:20:01 <lisppaste2> cptn pasted "example code" at http://paste.lisp.org/display/33477
06:20:05 <uccus> pejo: I agree. the most significant problem about the wikibook is the licnece
06:20:09 <uccus> *license
06:20:22 <AStorm> GFDL is too bad for you? :P
06:20:29 <metaperl> ndm - thank you very much for writing Hoogle. it is an indispensable tool
06:20:30 <ndm> cptn: i see a black hole :)
06:20:30 <kowey> many cooks = rapid generation of content; but out of these cooks emerges a small handful that are willing to cut things out
06:20:39 <cptn> where!
06:21:07 <metaperl> ndm - thing is though. Google doesnt exactly rock with some of their business ethics these days
06:21:08 <uccus> AStorm: yes, I get no credit for what I do :(
06:21:08 <ndm> cptn: lohaXml is used several times in one expression, i suspect its refering to the wrong one at least once
06:21:16 <AStorm> uccus, how selfish ;-)
06:21:21 <ndm> metaperl: i wrote that statement a while ago :)
06:21:36 <ndm> metaperl: hopefully hoogle 4 will make it even more useful ;)
06:21:42 <metaperl> wow
06:21:49 <uccus> AStorm: sometimes, you see, like most monad tutorial writers, you do something and take pride in that :)
06:22:05 <AStorm> That's why they're too hard?
06:22:05 <AStorm> :P
06:22:14 <uccus> AStorm: exactly ;)
06:22:16 <ndm> AStorm: Monads as Containers
06:22:22 <cptn> noope
06:22:34 <AStorm> Monads as Arrows
06:23:04 <ndm> cptn: try adding putStrLn "here" statements after each lnie, with a number, so you can see where it gets to
06:23:27 <AStorm> These Arrows seem like electric parts.
06:23:30 <_alex_br_> let lohaXml = case lohaXmlM of
06:23:30 <_alex_br_>                   (Just lohaXml) -> lohaXml
06:23:36 <_alex_br_> maybe this is a loop?
06:23:40 <pejo> uccus, isn't it all about greater good, and not personal gain? :-)
06:23:42 <uccus> ndm: yeah, I would like to take this opportunity to congratulate you once again (along with metaperl) for Hoogle
06:23:49 <cptn> ok
06:23:57 <benc__> is it generally safe to use unsafePerformIO around a regcomp,regexp do block?
06:24:01 * benc__ thinks it is
06:24:08 <ndm> uccus: thanks :) - its good to see that something i wrote is being used/useful
06:24:19 <uccus> pejo: of course. but please explain the existance of so many Monad tutorials in blogs. :)
06:24:46 <kowey> http://www.haskell.org/haskellwiki/MetaTutorial
06:24:47 <lambdabot> Title: MetaTutorial - HaskellWiki
06:24:56 <uccus> ndm: c'mon. hoogle is the most useful Haskell *tool* (except lambdabot ;))
06:25:03 <AStorm> benc__, not in a thread, but otherwise...
06:25:16 <AStorm> lambdabot contains hoogle technology :>
06:25:28 <AStorm> The guy who wrote Haddock should get extra praise.
06:25:34 <pejo> uccus, um, blogs aren't exactly known for their general high quality content. Anyone is free to write whatever crap they want. I would guess the majority of blogs are about sex or someone walking their dog today though, not monad tutorials
06:25:58 <ndm> uccus: and impressively has never had a final release in over 2 years ;)
06:26:08 <benc__> AStorm: ok.this is all single threaded
06:26:21 <ndm> i am actually aiming to leave beta with hoogle 4, but not for at least 6 months...
06:26:35 <pejo> uccus, I'm not saying people aren't allowed to write blogs, I'm just saying it puts more responsibility on the reader to judge whether the content is good or bad. (And a reason many prefer a book instead).
06:26:52 <cptn> ndm i tried it in ghci
06:26:57 <uccus> pejo: the point I was trying to make was the hunger for immortality
06:26:58 <cptn> and i still get the error
06:27:06 <ndm> cptn: try it in GHC
06:27:13 <ndm> cptn: do you get any printed messages?
06:27:21 <metaperl> is there a way to use named fields with this data definition? data Graph v e = Graph [(Int,v)] [(Int,Int,e)]
06:27:38 <cptn> yes
06:27:41 <ndm> metaperl: no, you cannot add named fields afterwards
06:27:49 <cptn> all the way till mainGUI
06:27:51 <ndm> cptn: which line does it stop at
06:27:57 <metaperl> ndm - but could it be rewritten to use named fields? if so, how?
06:28:09 <cptn> no messages could happen after that
06:28:23 <dylan> data Graph v e = Graph { foo :: [(Int,v)], bar :: [(Int,Int,e)] }
06:28:27 <cptn> after mainGUI it hangs
06:28:28 <ndm> data Graph v e = Graph {nodes :: [(Int,v)], edges ..
06:28:41 <metaperl> oh nice
06:28:53 <dylan> it has the same structure like that, btw.
06:28:58 <uccus> metaperl: you can do this (with existing Graph declaration)
06:29:00 <ndm> @seen dcoutts__
06:29:01 <lambdabot> I saw dcoutts__ leaving #gentoo-haskell and #haskell 7m 36s ago, and .
06:29:14 <uccus> foo (Graph x _) = x
06:29:28 <ndm> cptn: in the glade file is the window set to visible=true?
06:29:29 <uccus> nodes (Graph x _) = x
06:29:36 <uccus> edges (Graph _ x) = x
06:29:48 <uccus> and treat them as named fields from then on!
06:29:53 <ndm> uccus: you can't, graph{edges = ...} is only supported with the records
06:30:04 <cptn> no
06:30:09 <metaperl> uccus - yes, until you have a large set of values and you dont want to write out a bunch of pattern matches
06:30:13 <ndm> cptn: try that
06:30:29 <cptn> it works!
06:30:32 <cptn> thanks ndm
06:30:32 <ndm> uccus: you also don't get f Graph{nodes=[]} = ... pattern matching
06:30:45 <ndm> cptn: no problem :)
06:31:13 <uccus> ndm: okay. understood.
06:31:23 <ndm> records are sadly not very generic...
06:31:32 <cptn> ndm you use emacs?
06:31:40 <ndm> cptn: textpad on windows
06:31:43 <cptn> ok
06:33:07 <uccus> ndm: can you point me to any Haskell source that uses records heavily?
06:34:24 <ndm> uccus: not really, can't think of any of teh top of my head...
06:34:34 <ndm> this has some record stuff: http://darcs.haskell.org/yhc/src/compiler98/Flags.hs
06:34:39 <uccus> ndm: thanks anyways
06:34:47 <ndm> but can't think i've ever written a record pattern match
06:35:33 <ndm> it also shows some of the weakness of records
06:35:53 <hyrax42> what did MonadZero do?
06:36:01 <ndm> \x -> y{fieldname=x} is the best you can get for a record setter, no higher order record setter
06:36:06 <hyrax42> mzero without mplus?
06:37:00 <uccus> well, -- isOpt (Opt{}) = True -- seems to be a fine example of an idiom
06:37:09 <AStorm> @type MonadZero
06:37:15 <lambdabot> Not in scope: data constructor `MonadZero'
06:37:23 <AStorm> Whoops, it's a typeclass :P
06:37:31 <hyrax42> AStorm: it doesn't exist, afaik
06:37:34 <hyrax42> used to
06:37:35 <hyrax42> but doesn't
06:37:36 <int-e> hyrax42: yes. and as far as I understood it, there was no 'fail'.
06:37:42 <uccus> it doesn't work on ADTs, does it?
06:38:00 <hyrax42> hmmm
06:38:18 <hyrax42> fail is useful though, or can be
06:40:10 <int-e> hyrax42: it's usually unobstrusive. the one point where it bugs me is the Either e  monad instance.
06:40:50 <hyrax42> > fail "blah" :: Either String String
06:40:55 <lambdabot>  Left "blah"
06:41:06 <hyrax42> > fail "blah" :: Either Int Int
06:41:07 <lambdabot>  add an instance declaration for (Error Int)
06:41:07 <lambdabot>   In the expression: fail "bl...
06:41:12 <int-e> exactly.
06:41:41 <hyrax42> hm
06:41:42 <int-e> I'd prefer a non-local return implementation of instance Monad (Either a)
06:41:47 <AStorm> > fail :: Either () ()
06:41:48 <lambdabot>    Expecting a function type, but found `Either () ()'
06:41:48 <lambdabot>    Expected type:...
06:41:51 <int-e> instead of an error catching one.
06:41:56 <AStorm> > fail
06:41:57 <lambdabot>  Add a type signature
06:42:03 <AStorm> > fail 123
06:42:03 <hyrax42> > fail "blah" :: Either () ()
06:42:04 <lambdabot>  add an instance declaration for (Show (m a))
06:42:04 <lambdabot>  add an instance declaration for (Error ())
06:42:05 <lambdabot>   In the expression: fail "bla...
06:42:20 <hyrax42> AStorm:
06:42:23 <hyrax42> ?type fail
06:42:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
06:42:37 <int-e> Oh, and arguably all these instances that implement  fail = error  are a bad thing.
06:42:42 <hyrax42> takes a string :)
06:42:46 <AStorm> Hmm. Funny. generates a failed monad :P
06:43:03 <hyrax42> hmmm
06:43:05 <AStorm> (and an error)
06:43:07 <int-e> But I guess that's a matter of taste.
06:43:16 <hyrax42> with overlapping instances, fail could be taken  out of Monad
06:43:22 <hyrax42> into something like MonadFail
06:43:53 <int-e> why do you need overlapping instances for that?
06:43:54 <hyrax42> with instance MonadZero m => MonadFail m where fail = mzero
06:43:59 <int-e> ah
06:44:13 <hyrax42> and then let people specify if they want other behaviour
06:44:27 <hyrax42> * fail = const mzero
06:48:58 <metaperl> what would the datatype of v and e be in this definition: data Graph v e = Graph [(Int,v)] [(Int,Int,e)]
06:49:53 <metaperl> v clearly is just whatever data is stored at each node in the graph
06:50:00 <metaperl> but what is the purpose of e?
06:50:34 <twanvl> data stored in the edges
06:50:42 <metaperl> oh
06:50:43 <jlouis> Think about a weight
06:50:48 <metaperl> oh yes, thanks
06:50:53 <metaperl> cool
06:50:57 <jlouis> ie, a "distance" between vertices
06:51:50 <uccus> should the tute contain (in relevant sections) answers to stupid(?) questions? like, "how do I check if two values are identical?"
06:53:08 <jlouis> In Haskell, that is not a stupid question
06:55:01 <uccus> so, should the tute contain Q&A's like these?
06:55:14 <cptn> what is the best way to write functions with optional arguments in haskell?
06:55:28 <uccus> [by the way, jlouis, what's the answer to my stupid question anyway?]
06:55:52 <uccus> cptn: it cannot be done. optional arguments are absent in Haskell
06:56:30 <jlouis> cptn, try to avoid it. If you _Must_, then take a parameter of type (Maybe Foo) and case on it.
06:57:40 <SamB_XP> if you want varargs, you can use some type-hackery to do it...
06:57:41 <jlouis> uccus, the answer is that to check values for equality (Which may be slightly different from identity), the values must be of the same type a and be an instance of the Type Class Eq.
06:58:03 <jlouis> If that is the case (==) and (/
06:58:12 <jlouis> (/=) are defined on the type
06:58:37 <jlouis> And if this is to make any sense, it must be an equivalence relation
06:58:39 <cptn> i know i cant make a function type check with optionals
06:58:43 <uccus> jlouis: I understand that. as far as I understand, *identity* cannot be checked in Haskell. right?
06:59:49 <jlouis> uccus, If you mean "Does this pointer point to the same thing" identity, then I'd say that either its a no, or the functionality is rarely used. I have never seen it used.
07:00:13 <uccus> yes, that's precisely what I mean
07:00:35 <uccus> can anyone confirm jlouis' guess?
07:00:38 <int-e> it's also inherently impure.
07:01:24 <SamB_XP> it can be done, but not without unsafeCoerce#
07:01:40 <AStorm> cptn, you can also provide some variants by multiple definitions (but not always)
07:01:45 <SamB_XP> did I mention it probably only works in GHC?
07:01:49 <uccus> cptn: I think the best possible advice on the issue of optional parameters is, forget it, try a different thing
07:01:55 <int-e> SamB_XP: how does that work? coerce to Addr#?
07:02:06 <AStorm> cptn, yes, you don't need or want them :>
07:02:11 <SamB_XP> int-e: I think something like that
07:02:25 <cptn> multiple definitions?
07:02:58 <uccus> hehe. the next question of course is, should a gentle tute mention Addr#
07:03:06 <SamB_XP> uccus: heck no
07:03:07 <jlouis> cptn, make a generalized version and specialize into the multiple definitions you want
07:03:16 <cptn> ah ok
07:03:17 <SamB_XP> that isn't even really part of Haskell
07:04:01 <jlouis> pointer equality checks are irritating. Trust me on that one.
07:04:08 <cptn> jlouis, can i make use of the currying feature and Either Or
07:04:25 <SamB_XP> did I mention that the answer would be fairly useless?
07:04:40 <jlouis> cptn, I tend to curry
07:04:46 <SamB_XP> you can, however, compare IORefs for being the same IORef
07:05:40 <jlouis> cptn, try to avoid Maybe and Either if you can. They are going to haunt you in the code because you'll end up with either a monad or with a case-tree in many circumstances
07:06:17 <cptn> ok
07:06:32 <cptn> how will i end up with a monad if you dont mind me askinng
07:06:47 <AStorm> Hehe, with Maybe monad.
07:06:54 <cptn> d
07:06:55 <SamB_XP> or the Either e monad
07:07:06 <cptn> d'oh
07:07:24 <jlouis> not that Maybe or Either are bad, but you may want to be vary of code with case-mazes
07:07:40 <jlouis> exactly, Either and Maybe are both Monad instances
07:08:57 <AStorm> Most of the time you need them, you don't. Just build your own datatypes.
07:09:30 <SamB_XP> be vary! I vill suck your blood!
07:09:54 <AStorm> and you'll become a vampire!
07:10:11 <int-e> . o O ( the wampire strikes back? )
07:11:13 <uccus> bloody Hell!
07:11:19 <MarcWeber> Do you know an example of when/ how to use listen from WriterMonad?
07:11:40 <uccus> does anyone know how I can restrict my wikibook searches to Haskell?
07:12:36 <edi> MarcWeber - You use it when you want to run a sub-computation and "listen" to its log.
07:13:05 <jlouis> uccus, lack of pointer identity checks have some rather good compilation consequences
07:13:30 <uccus> jlouis: such as?
07:14:31 <AStorm> uccus, you mean this? http://en.wikibooks.org/wiki/Haskell
07:14:56 <uccus> AStorm: yes. how do I restrict my searches to this wikibooks only?
07:15:03 <jlouis> uccus, one is Common Subexpression Elimination for records
07:15:04 <kowey> probably adding "Haskell" as a keyword would do the job
07:15:18 <uccus> jlouis: never mind, I understand, purity
07:15:23 <SamB_XP> @google site:http://en.wikibooks.org/wiki/Haskell function
07:15:24 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Write_Yourself_a_Scheme_in_48_Hours/Defining_Scheme_Functions
07:15:26 <jlouis> uccus, indeed
07:15:45 <SamB_XP> uccus: does that look useful?
07:15:50 <AStorm> http://en.wikibooks.org/wiki/Wikibooks:Searching
07:16:26 <uccus> samb_XP: :D yes very much. thank you. I was expecting some MediaWiki feature though
07:16:43 <SamB_XP> uccus: mediawiki search sucks anyway doesn't it?
07:16:50 <uccus> yeah
07:17:17 <AStorm> They do have it
07:17:22 <AStorm> It's called "namespaces"
07:17:29 <SamB_XP> it is basically good when you know the name of an article but not how to capitalize it
07:17:35 <uccus> I stumbled upon the page AStorm mentions a couple of minutes back and discovered that quoting a phrase doesn't work
07:18:14 <AStorm> Yes, it doesn't.
07:18:15 <uccus> AStorm: I thought namespaces meant "Main" or "Talk" or "Image"
07:18:41 <AStorm> Unfortunately, because Wiki dummies can't think "Haskell" can be a namespace :P
07:19:03 <SamB_XP> is it like Windows, where you have drive:path/file?
07:19:27 <SamB_XP> nevermind that windows doesn't let you have reasonable drive names like Amiga does
07:19:33 <AStorm> It is case insensitive.
07:19:35 <uccus> but in the wikibook context, they should provide a search facility within the book I guess
07:19:42 <AStorm> Yes, they should.
07:19:46 <AStorm> Go bug them :d
07:19:52 <uccus> :)
07:20:18 <SamB_XP> maybe on the Talk page for Wikibooks:Searching (if there is such a thing?)
07:21:13 <SamB_XP> can you set up a url-bar-thingy that lets you search the Haskell wikibook?
07:21:17 * SamB_XP ponders aloud
07:21:43 <kowey> it would make a useful link or template from the wikibook
07:21:46 <kowey> "search this book"
07:22:11 <uccus> yes
07:23:20 * SamB_XP reads about bookmarklets
07:24:35 <lokojones> hi
07:25:00 <lokojones> Can I ask some Haskell doubts at this channel?
07:25:33 <Saizan> it's the norm :)
07:25:51 <MarcWeber> lokojones: I think so. If you don't get enough answers try haskelcafe mailinglist ;)
07:26:14 <lokojones> Im just trying to figure out a simple way to generate 100 random floats from -1.0 to 1.0 using Random
07:26:58 <lokojones> im reading about the Random library, but im not getting anything clear about it...
07:27:03 <lokojones> just a newbie with haskell :(
07:27:50 <yaxu> lokojones: have you got to grips with IO generally yet?
07:28:23 * SamB_XP decides he doesn't want a bookmarklet
07:28:31 <edi> ?docs System.Random
07:28:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
07:28:38 <srle> hi all
07:28:59 <srle> How can I read TVar without adding TVar in the read set of the current transaction?
07:29:35 <lokojones> yaxu: no, I guess not
07:29:50 <lokojones> edi: thanks, ill start reading that, and then come back :)
07:29:52 <edi> :t newStdGen >>= randomRs (1,100) -- lok
07:29:54 <lambdabot>   Couldn't match `IO' against `[]'
07:29:54 <lambdabot>    Expected type: StdGen -> IO b
07:30:03 <lokojones> (if I need it)
07:30:12 <edi> :t randomRs (1,100) `fmap` newStdGen
07:30:14 <lambdabot> forall a. (Random a, Num a) => IO [a]
07:30:17 <edi> ta-da.
07:31:10 <yaxu> lokojones: well you have to treat getting a random number as IO, ie getting a character from the keyboard
07:31:19 <SamB_XP> @paste
07:31:19 <lambdabot> http://paste.lisp.org/new/haskell
07:31:54 <Syzygy-> Though this generates integers between 1 and 100 if you don't do anything.
07:31:54 <lokojones> umh, ok
07:32:15 <edi> ah, I can't read.
07:32:34 <edi> :t (randomRs (-1,1) `fmap` newStdGen) :: IO [Float]
07:32:36 <lambdabot> IO [Float] :: IO [Float]
07:32:40 <edi> ta-da (2).
07:32:50 <lokojones> oh, nice :)
07:33:13 <edi> \bot's output is crazy anyway.
07:33:22 <Syzygy-> Prelude System.Random> let rg = randomRs (-1,1) `fmap` newStdGen :: IO [Float]
07:33:22 <Syzygy-> Prelude System.Random> do x <- rg; return $ take 5 x
07:33:22 <Syzygy-> [2.5641192e-2,-0.6160145,0.7118549,0.4676061,0.49212667]
07:33:25 <Syzygy-> In use. :)
07:33:47 <SamB_XP> you at least need to do IO if you want to seed the RNG
07:34:03 <yaxu> wow, those are my five most favourite numbers!
07:34:19 <lokojones> I need time to understand all that stuff :P
07:34:30 <SamB_XP> @hoogle random
07:34:30 <Syzygy-> yaxu: now that's a coincidence!
07:34:30 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
07:34:30 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
07:34:30 <lambdabot> Random :: module
07:34:46 <SamB_XP> @doc System.Random
07:34:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
07:35:50 * SamB_XP wants a lighter version of notepad
07:36:29 <Syzygy-> ed?
07:36:44 <edi> Syzygy-: actually  do { x <- amb; return (f x) }  =  amb >>= \x -> return (f x)  =  amb >>= return . f  =  fmap f amb
07:36:47 <lokojones> yaxu: what you meant is that to do any other thing with those random numbers apart from showing them, I need to use IO?
07:36:52 <SamB_XP> ah, actually, it isn't notepad's fault this time...
07:37:35 <Syzygy-> edi: So it's enough with fmap (take 5) rg in my code?
07:37:43 <edi> yes.
07:37:46 <Syzygy-> Ooooooh! Neat!
07:37:50 * earthy hugs haskell
07:37:51 <edi> take 5 `fmap` rg
07:38:10 <edi> take 5 `fmap` randomRs (-1,1) `fmap` newStdGen
07:38:35 <earthy> let compoundinterest = \ x y -> x + (y/100) * x in scanl compoundinterest amount interestpercentages
07:38:46 <edi> ?pl \f xs -> xs >>= return . f
07:38:47 <lambdabot> fmap
07:38:57 <Syzygy->     No instance for (Functor ((->) StdGen))
07:38:59 <kowey> lokojones: (hope i'm not getting in the way) the trick is to "invert" your way of attacking the problem
07:39:08 <Syzygy-> edi: Something's badwith that line....
07:39:10 <edi> Oh-uhm.
07:39:12 <MarcWeber> lokojones: Try starting here: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html , goto haskell.org -> wiki and go on reading ;)
07:39:14 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
07:39:18 <kowey> lokojones: the idea is that you can write a pure function and does stuff with numbers (not IO)
07:39:34 <kowey> and then show the result of that stuff
07:39:39 <lokojones> yep
07:40:15 <lokojones> actually, what I really want
07:40:26 <edi> :t take 5 `fmap` randomRs (-1,1) `fmap` newStdGen
07:40:27 <lokojones> (I have still one month to solve this)
07:40:28 <lambdabot> forall a. (Random a, Num a) => IO [a]
07:40:32 <edi> I think it should work.
07:41:08 <kowey> (well, if new to haskell, maybe fmap and liftM aren't the best things to start with)
07:41:14 <lokojones> is to generate a "population" of 100 numbers, to work with a "genetic algorithm" (really dont know If im using the correct word in english)
07:41:15 <MarcWeber> edi: So way to use listen is eg (value, log) <- listen $ computation; trace (show log) return value ? Thanks Got it *smile*
07:41:20 <Syzygy-> My GHCi tells me that it doesn't have a Functor instance for StdGen
07:41:30 <Syzygy-> Hrm. ((->) StdGen)
07:41:39 <yaxu> lokojones:  actually i was wrong and SamB_XP was right, generating random numbers isn't IO, but seeding that generator is, apologies for the confusion
07:41:57 <Syzygy-> yaxu: If you give aseed, you cando it purely...
07:42:22 <lokojones> umh
07:42:27 <yaxu> i guess so, if you don't mind the same results each time
07:42:56 <lokojones> oh, ok, i get it
07:43:38 <kowey> argh... IRC more interesting than work
07:43:39 <lokojones> but whats is exactly "seeding" the generator?
07:43:43 <Syzygy-> yaxu: Or at least the same sequence.
07:44:02 <Syzygy-> lokojones: You give explicitly a starting parameter forthe pseudorandom sequence.
07:44:03 <yaxu> Syzygy-: true
07:44:17 <edi> > take 5 `fmap` randomRs (-1,1::Float) `fmap` return (mkStdGen 31337)
07:44:18 <lambdabot>  add an instance declaration for (Show (m [Float]))
07:44:53 <yaxu> lokojones: a genetic algorithm in haskell sounds like a fun project
07:45:13 <lokojones> yep, it sounded fun for me too :P
07:45:24 <lokojones> and it surely is
07:45:29 <edi> Syzygy-: gotcha.  Add parens.
07:45:37 <edi> Prelude System.Random> take 5 `fmap` (randomRs (-1,1::Float) `fmap` newStdGen)
07:45:37 <edi> [-0.6473673,-0.4052123,-0.36509714,-0.7216961,0.95634425]
07:45:39 <lokojones> but its a bit hard when you have never seen a functional language :P
07:45:51 <Syzygy-> Yeah, that works.
07:45:55 <lokojones> its my second year at Computer Science
07:46:02 <edi> MarcWeber: good (:
07:46:06 <lokojones> (stuying i mean)
07:46:21 * shapr throws a function at lokojones
07:46:34 <edi> That line shows something like `IO as container'.
07:46:46 * Syzygy- piles up a couple of exceptions as ammo....
07:46:48 <edi> > (^2) `fmap` (Just 5)
07:46:49 <lambdabot>  Just 25
07:47:07 <Syzygy-> > (/2) `fmap` (Just 2.0)
07:47:07 <yaxu> lokojones: yep getting it done in a month seems a challenge in that case, i'd spend a good portion of that just learning the haskell basics
07:47:08 <lambdabot>  Just 1.0
07:47:10 <lokojones> Im a bit lost :(
07:47:10 <edi> Like this, but with IO wrapping the world up, instead of Just wrapping 5 up.
07:47:18 <lokojones> whats all that 'fmap' stuff?
07:47:29 <Syzygy-> lokojones: How to get a function applied to the inside of a container.
07:48:09 <Syzygy-> > (*2) `fmap` [2,4,3]
07:48:10 <lambdabot>  [4,8,6]
07:48:17 <lokojones> oh, yep
07:48:23 <lokojones> I see
07:49:14 <lokojones> so (randomRs (-1,1::Float) `fmap` newStdGen)
07:49:36 <Syzygy-> gives you an infinite list of random numbers.
07:49:37 <yaxu> > (*2) `map` [2,4,3]
07:49:39 <lambdabot>  [4,8,6]
07:49:43 <lokojones> generates a list with (how many?) random floats between -1 and 1 (shouldnt it be -1.0 and 1.0?)
07:49:45 <Syzygy-> Wrapped inside the IO container.
07:50:06 <lokojones> and take 5 just makes fmap only take the first 5?
07:50:06 <Syzygy-> Since both the -1 and 1 has to be the same type, the ::Float tells Haskell what you expect them to be.
07:50:22 <Syzygy-> > take 5 [1..15]
07:50:23 <lambdabot>  [1,2,3,4,5]
07:50:34 <Syzygy-> > take 5 [-5..12]
07:50:36 <lambdabot>  [-5,-4,-3,-2,-1]
07:50:46 <lokojones> yep, I see that
07:50:52 <edi> > (^2) `fmap` unfoldTree (\x -> if x < 3 then (x+1,[x+1]) else (x+1,[])) 0
07:50:54 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 4, subForest = [Node {ro...
07:50:56 <Syzygy-> take 5 when applied to a list takes the first 5. And so with fmap, you get it past the IO container.
07:50:58 <edi> ^_^
07:51:08 <dylan> :t take
07:51:09 <lambdabot> forall a. Int -> [a] -> [a]
07:52:25 <lokojones> ok
07:52:29 <lokojones> I think I got it
07:52:55 <edi> > drawTree $ (show . (^2)) `fmap` unfoldTree (\x -> if x < 3 then (x,[x+1,x+1]) else (x+1,[])) 0
07:52:56 <lambdabot>  "0\n|\n+- 1\n|  |\n|  +- 4\n|  |  |\n|  |  +- 16\n|  |  |\n|  |  `- 16\n|  |...
07:53:02 <lokojones> im going to experiment a bit
07:53:19 <dylan> @hoogle drawTree
07:53:20 <lambdabot> Data.Tree.drawTree :: Tree String -> String
07:53:26 <lokojones> thank you guys :)
07:53:31 <edi> You're welcome!
07:54:09 <edi> dylan: use :m + Data.Tree and add "putStrLn $" in front of that expression if you want to see it in GHCi.
07:56:38 <dylan> edi: already have
07:57:12 <dionoea_work> howdy
07:57:39 <dionoea_work> I was wondering if it was possible to print a number in binary using a "show" like function
07:57:58 <dionoea_work> show_binary 2 would output "10"
07:59:01 <edi> ?type Numeric.showBase
07:59:03 <lambdabot> Not in scope: `Numeric.showBase'
07:59:07 <edi> ?hoogle show
07:59:08 <lambdabot> Prelude.show :: Show a => a -> String
07:59:08 <lambdabot> Text.Show :: module
07:59:08 <lambdabot> Prelude.Show :: class Show a
07:59:11 <edi> ?hoogle+
07:59:12 <lambdabot> Char.showLitChar :: Char -> ShowS
07:59:12 <lambdabot> Numeric.showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
07:59:12 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
07:59:15 <dionoea_work> i'll look for showbase :)
07:59:16 <edi> ?hoogle+
07:59:19 <lambdabot> Numeric.showFloat :: RealFloat a => a -> ShowS
07:59:20 <lambdabot> Numeric.showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
07:59:23 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
07:59:26 <edi> we'll find it :)
07:59:27 <edi> ?hoogle+
07:59:28 <lambdabot> Numeric.showInt :: Integral a => a -> ShowS
07:59:28 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
07:59:30 <lambdabot> Numeric.showOct :: Integral a => a -> ShowS
07:59:31 <edi> Ah.
07:59:55 <edi> > Numeric.showIntAtBase 31337 chr 2
07:59:57 <lambdabot>  <[Char] -> [Char]>
08:00:00 <edi> > Numeric.showIntAtBase 31337 chr 2 ""
08:00:02 <lambdabot>  "\STX"
08:00:07 <edi> err :)
08:00:14 <dionoea_work> hehe :)
08:00:27 <edi> > Numeric.showIntAtBase 2 chr 31337 ""
08:00:29 <lambdabot>  "\SOH\SOH\SOH\SOH\NUL\SOH\NUL\NUL\SOH\SOH\NUL\SOH\NUL\NUL\SOH"
08:00:31 <edi> bah.
08:00:41 <yaxu> Prelude> let rand n = (r : rand r) where r = n * 6364136223846793005 + 1 :: IntPrelude> take 5 $ rand 32
08:00:41 <yaxu> [-1833966175,2123054158,-1832236105,-1901979604,-1642589251]
08:00:47 <yaxu> oops
08:01:51 <dionoea_work> > Numeric.showIntAtBase 2 (\x -> chr (x+ord '0')) 10
08:01:53 <lambdabot>  <[Char] -> [Char]>
08:03:54 <edi> ShowS =~= String -> String
08:04:07 <dionoea_work> why doesn't Numeric.showIntAtBase 2 (\x->Char.chr (x+Char.ord '0')) 10 work ?
08:04:12 <edi> :t > Numeric.showIntAtBase 2 (\x -> chr (x+ord '0')) 10
08:04:14 <lambdabot> parse error on input `>'
08:04:15 <edi> :t Numeric.showIntAtBase 2 (\x -> chr (x+ord '0')) 10
08:04:16 <lambdabot> ShowS
08:04:19 <edi> :t Numeric.showIntAtBase 2 (\x -> chr (x+ord '0')) 10 ""
08:04:21 <lambdabot> String
08:04:24 <dionoea_work> oh ok
08:04:32 <dionoea_work> thanks :)
08:04:36 <edi> > Numeric.showIntAtBase 2 (\x -> chr (x+ord '0')) 10 ""
08:04:38 <lambdabot>  "1010"
08:06:05 <shapr> @seen SyntaxNinja
08:06:06 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 3d 8h 39m 45s ago, and .
08:06:06 <LordBrain> hmm
08:06:10 <shapr> aww
08:38:06 <Templar2> hi
08:39:35 <lisppaste2> Templar2 pasted "Palindrom" at http://paste.lisp.org/display/33479
08:39:54 <Vq^> hello Templar2
08:41:55 * dylan queues up I Palindrom I.
08:42:00 <_matthew_> or putStr (show $ aoeu == reverse aoeu)
08:42:20 * _matthew_ celebrates with They Might Be Giants
08:43:38 <dylan> I wish there were more math-inspired songs... like the Mandelbrot Set one by Jonathon Coulton.
08:44:09 <dylan> or something like TMBG's Mammal song...
08:44:10 <edi> _matthew_: print = putStrLn . show
08:44:34 <_matthew_> also by They Might Be Giants is "Why does the sun shine" which, apparently, is the text of some US government science leaflet
08:44:47 <_matthew_> edi: ahh, that makes that a bit easier then ;)
08:44:55 <dylan> yeah! The sun is hot / the sun is not / a place where we could live...
08:45:34 <dylan> And the Pi song by hard and phirm.
08:45:43 <_matthew_> Frankly, I think there's enough evidence to drop the Might from TMBG
08:45:59 <_matthew_> they are, in fact, Giants.
08:46:51 <cptn> hey how do i insert elements into this HashTable
08:47:07 <cptn> it gives me a type of IO (HashTable ..)
08:47:18 <cptn> but all the functions want a type of HashTable ..
08:48:57 <uccus> cptn: perhaps you want to use the (>>=) operator?
08:49:01 <dylan> _matthew_: heard Les Horribles CERNettes? "You only love your collider!"
08:49:10 <fasta> cptn: You should read a monad tutorial.
08:49:23 <cptn> why must all things use monads
08:49:36 <dylan> Why must all numbers use addition?
08:49:45 <cptn> dylan, i agree
08:50:18 <fasta> cptn: In Haskell 98 you have to.
08:50:35 <fasta> cptn: In GHC Haskell you don't have to.
08:50:52 <dylan> if you want a hashtable-like thing outside of IO, use Data.Map
08:51:02 <fasta> dylan: don't recommend that
08:51:19 <dylan> fasta: why not? it's not too terribly slow
08:51:25 <fasta> A hash table is a certain data structure with certain complexity guarantees.
08:51:30 <cptn> what is the difference between the two
08:51:34 <fasta> It's completely different from a tree.
08:51:44 <cptn> map is a btree underneath
08:51:45 <wchogg> I think Data.Map is based off of some kind of balanced tree.
08:51:51 <cptn> a hashtable is a hashtable
08:52:30 <dylan> yes. And a hashtable requires an underlying array, which is why all Hashtable operations are in IO.
08:52:39 <fasta> dylan: wrong
08:52:48 * dylan . o ( DiffArray based hashtable? )
08:52:56 <fasta> dylan: right
08:53:17 <dylan> fasta: correction: the hashtable in question requires a mutable array under IO. :P
08:53:50 <dylan> cptn: what are you using the hashtable for?
08:53:59 <cptn> just playing around
08:54:07 <cptn> getting a feel for the language
08:54:09 <uccus> cptn: do you need O(1) operations?
08:54:14 <fasta> dylan: the DiffArray is a purely functional data structure, just as a list.
08:54:22 <dylan> fasta: yes, I know.
08:54:29 <fasta> dylan: ok, then we agree
08:54:48 <cptn> ah i see
08:54:57 <cptn> hashtable using mutable data
08:55:07 <cptn> hence it MUST be in a monad
08:55:21 <uccus> fasta, dylan: I have no idea what you are talking about. where can I read about DiffArray and DiffArray based Hashtables?
08:55:42 <uccus> ?where DiffArray
08:55:43 <lambdabot> I know nothing about diffarray.
08:55:59 <fasta> cptn: dylan and I just discussed that that assertion is false.
08:56:12 <cptn> oh im sorry
08:56:32 <uccus> cptn: don't worry about it. you are mostly right.
08:56:34 <fasta> cptn: if I were you I would just prototype your application first, and switch data structures later on.
08:56:45 <dylan> cptn: Data.HashTable is in IO because of the underlying implementation of arrays it uses are mutable and thus under IO.
08:56:58 <cptn> well how do i use it
08:57:14 <cptn> so when  i run into other IO monads goodies ill be ready
08:57:18 <dylan> cptn: You don't usually use hashtables as much in haskell as you would in a scripting language.
08:57:21 <uccus> use the (>>=) operator! sheesh! #haskell can go haywire sometimes
08:57:38 <fasta> Yes, I detected a cycle too.
08:57:40 <cptn> <interactive>:1:30:
08:57:40 <cptn>     No instance for (Num (Data.HashTable.HashTable key
08:57:40 <cptn>                                                    (Data.HashTable.HashTable Int val)))
08:57:40 <cptn>       arising from the literal `2' at <interactive>:1:30
08:57:40 <cptn>     Probable fix:
08:57:40 <cptn>       add an instance declaration for (Num (Data.HashTable.HashTable key
08:57:42 <cptn>                                                                      (Data.HashTable.HashTable Int val)))
08:57:47 <cptn>     In the first argument of `Data.HashTable.insert', namely `2'
08:57:49 <cptn>     In the second argument of `(>>=)', namely `Data.HashTable.insert 2 4'
08:57:51 <cptn>     In the definition of `it': it = sam >>= (Data.HashTable.insert 2 4)
08:57:53 <cptn> crap that was larger than i thought!
08:57:57 <edi> ?paste
08:57:58 <fasta> cptn: do not paste here.
08:58:09 <lambdabot> http://paste.lisp.org/new/haskell
08:59:17 <edi> ?type insert
08:59:20 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
08:59:21 <lisppaste2> cptn pasted "tinkering" at http://paste.lisp.org/display/33480
08:59:23 <edi> ?type Data.HashTable.insert
08:59:25 <lambdabot> forall val key. Data.HashTable.HashTable key val -> key -> val -> IO ()
09:00:20 <edi> ?type let hs = undefined :: Data.HashTable.HashTable Int String in Data.HashTable.insert 1 "cptn" `fmap` hs
09:00:22 <lambdabot>   No instance for (Num (Data.HashTable.HashTable [Char] String))
09:00:22 <lambdabot>    arising from the literal `1' at <interactive>:1:83
09:00:35 <fasta> @book
09:00:36 <lambdabot> Unknown command, try @list
09:00:41 <fasta> @where book
09:00:41 <lambdabot> I know nothing about book.
09:00:59 <edi> ?type let hs = undefined :: Data.HashTable.HashTable Int String in hs >>= \hashtable -> Data.HashTable.insert hashtable 1 "cptn"
09:01:01 <lambdabot>   Couldn't match `Data.HashTable.HashTable Int' against `IO'
09:01:01 <lambdabot>    Expected type: Data.HashTable.HashTable Int b
09:01:04 <edi> Blech
09:02:38 <cptn> dang
09:02:47 * shapr boings
09:03:15 <cptn> boing!
09:03:36 <shapr> privet cptn
09:03:39 <Nanar> hum question (again) :)
09:03:53 <Nanar> how I start a process and read it output ?
09:04:19 <Nanar> how do
09:05:24 <uccus> cptn: any progress?
09:05:38 <cptn> privet shapr, kak dela
09:05:50 <cptn> uccus, very confused
09:06:07 <uccus> what have you done so far? (use the paste service)
09:06:14 <cptn> pretty much
09:06:26 <lisppaste2> fasta annotated #33480 with "Hash-table" at http://paste.lisp.org/display/33480#1
09:07:00 <fasta> cptn: I made an example where I insert one key and then look it up again.
09:07:17 <cptn> thats fasta!
09:08:26 <cptn> now to convert to >>= and >> so i can test in prelude
09:08:38 <uccus> :|
09:08:54 <cptn> ???
09:09:13 <uccus> cptn: go ahead. I consider myself to be a mathematician. it's enough for me to know a solution exists. ;)
09:09:27 <cptn> i know its a solution
09:10:10 <uccus> looks clean, too!
09:11:29 <lisppaste2> fasta annotated #33480 with "Look this works too" at http://paste.lisp.org/display/33480#2
09:11:45 <fasta> cptn: this time I didn't care for layout.
09:12:48 <cptn> pretty!
09:13:06 <cptn> i was going to do the translation myself but thanks!
09:13:49 <lisppaste2> Templar2 pasted "getline putstr" at http://paste.lisp.org/display/33481
09:14:03 <fasta> My experience is that once you get the >>= function natively in your head, it doesn't really matter whether you use do notation or not.
09:14:04 <edi> â§ monochrom
09:15:09 <monochrom> Aâ¤ haskell
09:15:30 <Templar2> anyone who can help? ^^
09:15:52 <monochrom> what is "add two lines"?
09:16:15 <Templar2> takes input from a line then goess to next line and takes next ionput
09:16:22 <monochrom> what is "add two lines"?
09:16:26 <Templar2> and adds them
09:16:31 <monochrom> what is "add two lines"?
09:16:47 <Templar2> input from line1+input from line2
09:17:00 <fasta> Templar2: try ++ instead of +
09:17:04 <Jaak> a and b are strings not numbers
09:17:13 <fasta> Templar2: also remove show
09:17:18 <Templar2> can we parse then to int?
09:17:38 <fasta> > read "5"::Int
09:17:39 <lambdabot>  5
09:17:45 <Jaak> ((read a) :: Int) + ((read b) :: Int) or something similar might work
09:17:46 <fasta> Oh, look we can!
09:18:07 <monochrom> Have you been brainwashed by perl?
09:18:54 <Templar2> is read a same as a <- getline?
09:19:00 <monochrom> No.
09:19:10 <edi> :t liftM2 (+) readLn readLn
09:19:12 <lambdabot> forall a. (Num a, Read a) => IO a
09:19:38 <Templar2> but it reads a lin e?
09:19:41 <Jaak> nice
09:19:43 <monochrom> No.
09:19:49 <fasta> @where rafb
09:19:50 <lambdabot> Read A F*cking Book. This entry was inspired by ##c++
09:20:22 <Templar2> how does read get input?
09:20:29 <monochrom> It doesn't.
09:20:56 <edi> :t return (+) `ap` readLn `ap` readLn
09:20:58 <lambdabot> forall a. (Num a, Read a) => IO a
09:21:07 <edi> Applicative-like.
09:21:13 <Templar2> but i want to give input to my program. and then i want the program to add the inputs. i have to use getline then?
09:21:23 <monochrom> Yes.
09:21:41 <monochrom> getLine is input.  read is parse.
09:21:47 <Templar2> aha
09:21:56 <edi> :t liftA2 (+) readLn readLn
09:21:58 <lambdabot> Not in scope: `liftA2'
09:21:59 <edi> Applicative.
09:22:11 <Templar2> so i have to use bouth =)
09:22:35 <monochrom> Welcome to Legoland.
09:22:41 <araujo> good day
09:23:03 <edi> pure (+) <*> readLn <*> readLn -- Control.Applicative.
09:34:19 <lisppaste2> Templar2 pasted "getline putstr" at http://paste.lisp.org/display/33482
09:35:12 <lisppaste2> Templar2 pasted "IO add numbers" at http://paste.lisp.org/display/33483
09:35:31 <Templar2> sry . . .
09:36:19 <Templar2> omly wanted to paste http://paste.lisp.org/display/33483"IO add numbers
09:36:31 <allbery_b> Templar2: parentheses
09:36:42 <Templar2> where?
09:36:52 <allbery_b> return ((read a ::: Int) + (read b :: Int))
09:37:18 <allbery_b> if you look at the parse it gave of the statement, it parsed yours as (return (read a :: Int)) + (read b :: Int)
09:37:20 <_alex_br_> return $ (read a::Int)+(read b::Int)
09:37:20 <Templar2> thx
09:37:26 <paolino> hi, which is the icon for haskell code ?
09:37:45 <allbery_b> (see the line "Term:")
09:38:39 <Templar2> paolino lamda?
09:39:17 <paolino> sure, I grab it from the site then
09:41:32 <Templar2> dont I get any output with "return"?
09:42:05 <monochrom> No.
09:42:12 <Templar2> =(
09:42:40 <Templar2> can I put show or putStr before to get an output?
09:42:53 <monochrom> Yes.
09:43:00 <Templar2> aha, nice =)
09:43:36 <Madhadron> Anyone have thoughts on loading 16 bit tiffs into UArrays?
09:43:50 <edi> :t liftM2 (+) readLn readLn >>= print
09:43:51 <lambdabot> IO ()
09:44:39 <Templar2> did not work with this: putStr (show(return ((read a::Int)+(read b::Int)) ))
09:45:12 <Templar2> any ideas?
09:45:29 <monochrom> putStr (show ((read a::Int)+(read b::Int)))
09:45:32 <allbery_b> let r = (read a :: Int) + (read b :: Int); putStrLn (show r); return r
09:45:45 <monochrom> allbery_b's is better
09:45:47 <Madhadron> You don't need return.  show doesn't take a monadic argument
09:45:55 <Madhadron> :t show
09:45:56 <lambdabot> forall a. (Show a) => a -> String
09:46:18 <_alex_br_> return is for the function type: IO Int
09:48:07 <Templar2> thx
09:55:31 <mwc> Does anybody prove the monad laws for their instances
09:55:50 <mwc> like return x >>= f == f x
09:56:36 <mwc> It occurred to me as something I should do at some point, like inductive proofs for list algos and the like.
09:56:50 <mwc> curious as to if anybody bothers
09:57:22 <Madhadron> mwc, Well, in order to figure out what I should be writing, yes.
10:03:37 <Templar2> is there now while loop in haskell?
10:03:43 <Templar2> *no
10:03:49 <dylan> :t until
10:03:51 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:03:56 <Templar2> ok =)
10:04:01 <SyntaxNinja> w00t
10:04:02 <lambdabot> SyntaxNinja: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:05:22 <dylan> > until (== 4) (+1) 1
10:05:23 <lambdabot>  4
10:08:32 <allbery_b> I'm tempted to say "if you need while loops, you're doing it wrong"... except I have a case where it was necessary :)
10:09:30 <allbery_b> (iterative algorithm to find sunrise/sunset (+/- offset in degrees))
10:21:49 <int-e> > until (== 1) (+1/3) 0
10:21:51 <lambdabot>  1.0
10:22:15 <int-e> > until (== 1) (+1/7) 0
10:22:19 <lambdabot> Terminated
10:25:45 <Saizan> > until (== 1.0) (+0.1) 0.0
10:25:49 <lambdabot> Terminated
10:27:48 <integral> > until ((<0.01) . abs . (-1.0)) (+0.1) 0.0
10:27:49 <lambdabot>  add an instance declaration for (Fractional (a -> b))
10:28:15 <integral> > until ((<0.01) . abs . (\x->x-1.0)) (+0.1) 0.0
10:28:16 <lambdabot>  0.9999999999999999
10:29:54 <int-e> > last [0,0.1..1]
10:29:55 <lambdabot>  0.9999999999999999
10:33:34 <lisppaste2> Templar2 pasted "How to Until" at http://paste.lisp.org/display/33486
10:33:39 <AStorm> That "binary representation" problem, huh? :P
10:33:55 <AStorm> Either introduce some epsilon, or use Rational
10:34:44 <kowey> anybody play around with permutation parsers?
10:34:54 <allbery_b> until takes a function as a parameter
10:35:46 <edi> ?index until
10:35:46 <lambdabot> Prelude
10:35:47 <allbery_b> until (condition) (operation) (initial)
10:35:53 <mbishop> allbery_b: think any more about selling one of those wireless cards? :)
10:36:04 <edi> Crazy, I've never heard of it before.
10:36:49 <shapr> whee
10:36:55 <kowey> if i understand correctly, permutation parsers let me parse stuff like 'abc' and 'bca' alike; and likewise 'aaabc' and 'bcaaa'; what about 'aaabc' and 'abaca'?
10:37:26 <allbery_b> mbishop: it's sitting here unused, the question last I heard was that shipping costs more than the card :)
10:37:36 <int-e> @index untilM
10:37:37 <lambdabot> bzzt
10:38:10 <allbery_b> there's forM though
10:39:45 <int-e> @type let loop "" = return (); loop s = putStr s >> getLine >>= loop in getLine >>= loop
10:39:47 <lambdabot> IO ()
10:40:51 <allbery_b> templar2: better not to use until there.
10:41:13 <Botje> Templar2: prov can call it self. use when ?
10:42:47 <allbery_b> hm, paste.lisp.org gives me a proxy error when I try to annotate :(
10:43:51 <Botje> prov = do { a<- getLine; when (not $ null a) (putStrLn $ show $ a == (reverse a) >> prov) }
10:43:54 <Botje> or somesuch :)
10:44:08 * allbery_b used a case, but same idea
10:45:48 <koe> what would i use as the haskell equivalent to perl's pack? (packing binary data in various formats, 16-bit signed integer, etc.)
10:47:42 <wolverian> (perldoc -f pack)
10:48:41 <allbery_b> possibly something from Foreign.Marshal?
10:48:53 <allbery_b> (or the Foreign hierarchy in general)
10:50:11 <mbishop> allbery_b: well I'm willing to pay the shipping...
11:00:23 <koe> well.. what i really want to do is create a function to change a list of Nums to a String of the packed (16 bit signed big endian) output of that list of numbers
11:03:00 <Excedrin> koe: look at Data.ByteString
11:24:59 <monochrom> any more questions?
11:25:57 <Botje> we've run out of questions! haskell is doomed!
11:26:28 <monochrom> everyone understands haskell. victory.
11:26:36 <lokadin> hmmm
11:26:44 <sieni> whatever the question, perl is not the answer
11:27:25 <metaperl> Python is a better answer. Haskell is the answer for the few who can think
11:27:57 <sieni> @quote sieni
11:27:58 <lambdabot>  C provides people with the expressiveness of fortran combined with the portability of assembler
11:28:00 <sieni> @quote sieni
11:28:01 <lambdabot>  the advantage of haskell is that it doesn't suck
11:28:04 <sieni> @quote sieni
11:28:05 <lambdabot>  the advantage of haskell is that it doesn't suck
11:28:06 <sieni> @quote sieni
11:28:07 <lambdabot>  python, like php, is just training wheels without the bike
11:28:11 <sieni> there
11:28:31 <edi> unicycle?
11:28:47 <monochrom> static unicycle :)
11:30:05 <metaperl> any Coq users here? http://pauillac.inria.fr/cdrom/www/coq/doc/node.x.1.html
11:30:07 <lambdabot> Title: Credits
11:30:41 <metaperl> Coq seems to be a part of Gallina - http://pauillac.inria.fr/cdrom/www/coq/doc/toc.html
11:30:44 <lambdabot> Title: Table of contents
11:30:46 <monochrom> I wonder what the "cdrom" there is doing
11:30:55 <integral> there's a #coq.
11:31:11 <edi> @dice 3d6
11:31:12 <lambdabot> 3d6 => 18
11:31:13 <kowey> metaperl: http://pauillac.inria.fr/cdrom/
11:31:14 <lambdabot> Title: CD-ROM Logiciels de l'INRIA
11:31:16 <integral> gallina's an input language for coq
11:31:17 * edi hits the coq
11:31:21 <kowey> it's INRIA's free software collection
11:31:31 <int-e> @dice 1000d2
11:31:31 <lambdabot> 1000d2 => 1522
11:31:42 <monochrom> I'm glad I still remember that logiciels means software :)
11:36:10 <glguy> Hmm, in minesweeper for XP I couldn't beat advanced because I'd always end on an unsolvable guess between 2 squares
11:36:17 <glguy> Vista minesweeper just crashes
11:36:24 <glguy> so you don't have ot worry about getting to that point
11:36:52 <kowey> monochrom: you should come to #haskell.fr and soak up more words like "monades"
11:37:07 <kowey> and (guessing) "combinateurs"
11:37:12 <monochrom> You need luck.  You just keep creating new games until you hit one you can solve.
11:37:13 <int-e> glguy: and you always got unlucky?
11:37:30 <glguy> int-e: after a couple unlucky games, you lose your drive to play anymore :)
11:37:57 <monochrom> monades in lemonades ought to be delicious
11:38:16 <monochrom> heh heh heh le monades!
11:38:55 <monochrom> You need addiction, glguy.
11:39:07 <int-e> glguy: hmm. guessing is part of the game I'm afraid. clicking all corners first helps a bit.
11:40:35 <dylan> "What did the depressed masochist say?"
11:40:48 <int-e> please don't kill me?
11:40:49 <dylan> "I can't get no sadist-faction."
11:41:13 <metaperl> someone muzzle dylan please
11:41:24 <kowey> you two would fit right in... francophones seem to really like puns for some reason
11:41:28 <metaperl> you're a disgrace to Floridians everywhere
11:42:15 <dylan> I usually emit one pun per day
11:44:04 <dylan> I've used puns to distrupt flame wars before, too. it's a great power.
11:44:11 <dylan> *disrupt.
11:45:03 <dylan> Only more successful way to stop a flame war is start arguing *both* sides of it, with yourself.
11:45:25 <dylan> And being very very rude and belligerent (sp?) to yourself.
11:46:01 <monochrom> c++ > haskell
11:46:16 <monochrom> (I want to see a demonstration :) )
11:46:28 <int-e> lines of code?
11:46:42 <metaperl> data Lang = C++ | Haskell deriving (Ord)
11:46:47 <metaperl> so there
11:46:48 <metaperl> take that
11:46:48 <dylan> No, I've had my fill of flame-destroying this weekend.
11:47:16 <monochrom> you are unable to appreciate c++ because you are too stupid!
11:47:42 <glguy> ?spell belligerent
11:47:43 <lambdabot> belligerent
11:47:44 <dylan> someone on a mailing list compared Mark Shuttleworth (Ubuntu person) with former US senator McCarthy, the famous communist hunter...
11:48:37 <int-e> @quote int-e
11:48:38 <lambdabot>  What, unsafeCoerce# is kind-preserving? how boring :/
11:48:45 <int-e> :/
11:48:50 <dylan> so I made a really complicated chain of fallacies to associate fedora with nazis.
11:49:01 <dylan> and nobody's responded to that, so I think it worked.
11:49:44 <Codex_> usually argument is lost when you have to refer to nazis.
11:49:51 <dylan> yes.
11:49:57 <dylan> This was a thread I wasn't part of.
11:50:13 <dylan> I just wanted it to stop filling my inbox. XD
11:50:36 <monochrom> dylan is showing to the other people that the flame war and the analogies are pointless.
11:50:57 <monochrom> All comparisons are meaningless.
11:52:13 <gvdm_other> once you start using monads you can't stop!
11:52:35 <monochrom> You are enlightened.
11:52:59 <int-e> monochrom: do you have a C++ template implementation of monads? :)
11:53:01 <dylan> my favorite responce to a flame war, though, was a picture... http://hardison.net/venn.png
11:53:42 <monochrom> hmm, why is some theft not crime?
11:53:58 <dylan> Well, that wasn't suppose to be the implication
11:54:19 <dylan> I only wanted to use two spheres.
11:54:20 <metaperl> [(1,2,'a'),(1,3,'b'),(3,4,'c'),(3,5,'d'),(4,7,'e'),(5,7,'f'),(2,6,'g'),(6,8,'h'),(7,9,'i'),(8,9,'j'),(9,10,'k')]
11:54:21 <metaperl>  -- I want to use a let expression to concatenate a list of the first elements in each tuple with  a list of the second elements of each tuple
11:54:21 <norpan> the whole yellow is crime and the stuff outside the blue is theft
11:54:24 <norpan> Ã²r?
11:55:34 <dylan> the argument that was for was "copyright infrinment is theft because theft is a crime and copyright infringement is crime"
11:56:48 <monochrom> That is sad.  That is just sad.  (Why do you hang out with so many uneducated people? :) )
11:57:11 <dylan> Even educated people will make stupid arguments
11:57:29 <dylan> it takes a lot of effort to stop caring what other people think.
11:59:04 <emu> are let-bound pattern matches always "lazy" matches?
11:59:09 <lisppaste2> metaperl pasted "how would you have implemented the function vertices?" at http://paste.lisp.org/display/33490
11:59:28 <emu> ie. is there a difference between "let ~(a,b) ..." and "let (a,b) ..."?
11:59:45 <Botje> at least one char :]
12:00:00 <emu> clever one
12:00:28 <monochrom> metaperl: I don't think you need let.  how about map (\(x,y,z)->x) xs ++ map (\(x,y,z)->y) xs ?
12:00:28 * metaperl clears his throat and motions at his paste: http://paste.lisp.org/display/33490
12:00:30 <allbery_b> let-bound are always lazy, is my understnding
12:00:45 <metaperl> a fold example would be neat
12:00:49 <emu> it would make sense, i think
12:00:51 <shapr> unlike where bindings...
12:00:52 * allbery_b should be taking a shower and going shopping, darn it
12:01:02 <emu> shopping?!
12:01:04 <metaperl> you could just nub a fold I think
12:01:16 <allbery_b> groceries
12:01:22 <metaperl> > groceries
12:01:23 <lambdabot>  Not in scope: `groceries'
12:01:32 <allbery_b> precisely :>
12:01:44 <metaperl> who needs food when you have Haskell?
12:01:46 <emu> ah yes.. i took care of that this past weekend, before things closed down
12:01:58 <monochrom> who needs shower when you have haskell?
12:02:10 <metaperl> can't you eat snow up there in Pittsburgh allbery_b?
12:02:13 <shapr> Smelly lambdas!
12:02:18 * allbery_b spent most of last week (and, for that matter, this week) too sick to go out :(
12:02:19 <emu> monochrom: don't encourage that! ;)
12:02:52 <dylan> class Eat food where eat :: food -> IO ()
12:02:54 <allbery_b> and, snow?  there were a few flurries last night, that's about it
12:04:02 <Botje> metaperl:
12:04:10 <Botje> vertices = nub $ foldr (\(a,b,_) l -> a:b:l) [] edges
12:04:12 <metaperl> you rang sire?
12:04:18 <monochrom> metaperl: to eliminate redundancy, I may use a set or an intset.
12:04:21 <metaperl> yes, sweet. I like that
12:04:33 <emu> > fix (\(_,a) -> (a,1))
12:04:35 <metaperl> @seen Botje
12:04:35 <lambdabot>  Exception: <<loop>>
12:04:35 <lambdabot> Botje is in #haskell. I last heard Botje speak 24s ago.
12:04:38 <emu> > fix (\~(_,a) -> (a,1))
12:04:39 <lambdabot>  Parse error
12:04:55 <metaperl> fix is broken
12:05:04 <metaperl> try using broken. that should fix it
12:05:25 <Botje> :)
12:05:37 <Botje> metaperl: what's with the labels on your edges?
12:05:56 <monochrom> we love labels
12:06:01 <metaperl> they are arbitrary
12:06:25 <metaperl> shapr - you were in FL and did not come to worship me and dylan? shame on thou!
12:07:10 <monochrom> we don't worship python gods
12:07:39 <dylan> worship?
12:08:19 <nmessenger> question: is [a]'s fmap equivalent to map?
12:08:28 <metaperl> worship. nothing less is acceptable
12:08:32 <dylan> yes, fmap for [a] is map
12:08:48 <emu> > fix (\ ~(_,a) -> (a,1))
12:08:50 <lambdabot>  (1,1)
12:09:14 <nmessenger> in that case, why have a special case at all?  Couldn't map be nixed and fmap renamed to map?
12:09:21 <vegai> http://www.nyu.edu/classes/siva/archives/caffeinegraph.jpg
12:09:33 <dylan> nmessenger: it's some historical reason
12:09:48 <monochrom> historical reason. many of us move it unify them.
12:09:52 <monochrom> s/it/to/
12:10:08 <dylan> "we like to move it move it" :)
12:10:13 <nmessenger> righty-o
12:12:16 <monochrom> some of us go as far as to unifying . and map and fmap
12:12:41 <dylan> you can unify . and map?
12:12:46 <nmessenger> (.)?  Really?  How does that work?
12:13:03 <monochrom> > (succ `fmap` succ) 10
12:13:04 <lambdabot>  12
12:13:12 <nmessenger> evil!
12:14:01 <monochrom> Using "(->) r" as an instance of Monad (in fact MonadReader), fmap turns out to be (.)
12:14:38 <nmessenger> It'd be neat if the syntax supported type sections (r ->)
12:14:52 <emu> heh, the strictness was the problem after all.  i was forcing too much of the pattern match and it was forcing it into divergence when it only needed part of the result.
12:15:03 <monochrom> their proposal is to use (.) as the standardized name.  Henceforth you write succ.succ as well as f.[1,2,3] (that's f `map` [1,2,3])
12:15:38 <nmessenger> hmm, really cool, but I wonder how confusing it'd be.
12:16:05 <monochrom> It will rock the hell out of all perlers and pythoners alike
12:16:14 <Iulus> I imagine I'd continue to use 'map' for lists
12:16:36 <Iulus> but I guess maybe just until the "(.) is only function composition" mindset wore off
12:17:18 <nmessenger> ?type map
12:17:19 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
12:17:22 <nmessenger> ?type fmap
12:17:24 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:17:26 <nmessenger> I suppose the special case of map makes types not as scary to newbies
12:18:11 <monochrom> (+) already scares the hell out of newbies.
12:18:18 <vegai> I knew it! The ultimate goal is to confuse everyone else!
12:18:29 <nmessenger> heh, true
12:18:30 <vegai> aaaaaaa aaa aaaaa!
12:18:50 <Iulus> but on the surface, many things don't change
12:18:58 <Iulus> map f [1,2,3,4,5] still works
12:19:03 <vegai> is there some sort of super-clean syntax that is only for the inner circle?
12:19:08 <monochrom> I myself am not ready to unify (.) with the other fmaps yet.
12:19:17 <Iulus> just that 'map' is a general instead of a specific
12:19:22 <allbery_b>  @pl ? }:>
12:19:28 <Iulus> I agree that (.) == fmap is a little far
12:19:28 <edi> I would like that!
12:19:30 <Cale> I'm almost ready to do so :)
12:19:47 <Iulus> for my mind
12:19:56 <edi> :t take 5 . randomRs (-1,1::Float) . newStdGen
12:19:58 <lambdabot>   Expecting a function type, but found `IO StdGen'
12:19:58 <lambdabot>    Expected type: a -> b
12:20:08 <monochrom> "Core" is the super-clean syntax that is only for the inner circle.
12:20:16 <edi> :t take 5 `fmap` randomRs (-1,1::Float) `fmap` newStdGen
12:20:17 <Cale> All that's required is the right explanation for beginners. I don't think it's impossible to handle.
12:20:18 <lambdabot> IO [Float]
12:20:43 <edi> isn't the former much nicer?
12:20:56 <nmessenger> (.) = fmap such that ((->) c) substitutes f, map = fmap such that [] substitutes f
12:21:13 <nmessenger> ?type fmap
12:21:14 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
12:21:28 <Cale> I'd keep both notations
12:21:34 <Cale> but I'd rename fmap to map
12:22:02 <monochrom> Naming is tricky.  Just earlier today a beginner was confused because he expected "read" implies doing the necessary I/O in addition to parsing.
12:22:28 <nmessenger> Ah, I had the same problem when I first encountered read
12:22:29 <Cale> This is just something which needs to be handled with careful wording.
12:22:39 <Cale> (in tutorials and such)
12:22:43 <nmessenger> Names *are* tricky
12:22:57 <Cale> Not just names, but the explanations of those names.
12:23:09 <nmessenger> I mean _nub_?!  C'mon now!
12:23:15 <nmessenger> ;P
12:23:20 <monochrom> So, you can unify all you want, but you have to be careful with the names.
12:23:35 <Cale> 'nub' doesn't seem too inappropriate. At least it's fairly meaningless to start with.
12:23:36 <edi> Essence
12:23:51 <nmessenger> ?web1913 nub
12:23:53 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:23:53 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
12:23:53 <lambdabot>   To push; to nudge; also, to beckon. [Prov. Eng.]
12:23:53 <lambdabot>  
12:23:53 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
12:23:55 <lambdabot> [3 @more lines]
12:24:00 <Cale> (there's a good explanation, but it's one which could apply to lots of other operations as well)
12:24:01 <nmessenger> @more
12:24:01 <lambdabot> Nub \Nub\, n.
12:24:01 <lambdabot>   A jag, or snag; a knob; a protuberance; also, the point or
12:24:03 <lambdabot>   gist, as of a story. [Colloq.]
12:24:16 <Cale> yes, that one
12:24:22 <nmessenger> it's not the first definition, though
12:24:30 <monochrom> You could alternatively go the Dijkstra route.
12:24:30 <Cale> 'gist' would perhaps be an even better choice
12:24:37 <dylan> gist would be good
12:24:49 <dylan> for english-speakers, anyway.
12:24:50 <nmessenger> I vote for good ol' uniq
12:24:52 <Cale> uniquify
12:25:05 <edi> ?pl ap (const (ap id)) (ap (const const) id)
12:25:06 <lambdabot> ap id . const
12:25:13 * dylan wrote a uniq function once and called it unicorn. . . XD
12:25:17 <Cale> hehe
12:25:26 <dylan> it's in production somewhere, too.
12:25:27 <LoganCapaldo> runOfElementsToSingleElement
12:25:59 <monochrom> The Dijkstra route: to hell with names.  Use meaningless names.  Write down the complete axioms for your operators.  (Thus the axioms are the true meaning.)  Derive programs algebraically from the axioms.  You just can't go wrong.
12:26:06 <Cale> When I first saw 'nub', I don't think I was able to make any assumptions about what it did, which at least is better than making the wrong assumptions.
12:26:27 <LoganCapaldo> Yeah, I'm glad its not called uniq
12:26:39 <monochrom> "nub" exemplifies the Dijkstra route :)
12:26:45 <Cale> It's true that names which are suggestive of things help with learning and remembering them though.
12:26:57 <norpan> nub is very suggestive :)
12:27:19 <yaxu> nub nub nub
12:27:23 <nmessenger> LoganCapaldo: runOfElementsToSingleElement = map head . group
12:27:25 <monochrom> You use the shapes of the operator symbols to remind yourself some of the axioms it satisfies.
12:27:51 <dylan> yaxu: that makes me think nub = hump
12:28:14 <nmessenger> sorta reminds me of 'nibble'
12:28:23 <Cale> map head . group . sort  ought to have a name.
12:28:24 <LoganCapaldo> doh
12:28:39 <LoganCapaldo> I thought that's what nub did (map head . group)
12:28:43 <Cale> no
12:28:48 <LoganCapaldo> silly me
12:28:50 <monochrom> For example, "â§" is a good choice for a commutative operator because it's symmetric along the suitable axis, cf aâ§b=bâ§a.  "&" is a poor choice because it is assymmetric.
12:28:54 <Cale> > map head . group $ [1,1,1,2,2,1,1,2,3,4,2,1,2,1]
12:28:55 <nmessenger> Cale: isn't that nub, with the sort?
12:28:56 <lambdabot>  [1,2,1,2,3,4,2,1,2,1]
12:28:57 <LoganCapaldo> change it's name to uniq ;)
12:29:02 <Cale> > nub $ [1,1,1,2,2,1,1,2,3,4,2,1,2,1]
12:29:03 <lambdabot>  [1,2,3,4]
12:29:10 <Cale> > nub $ [3,1,1,1,2,2,1,1,2,3,4,2,1,2,1]
12:29:12 <lambdabot>  [3,1,2,4]
12:29:19 <Cale> > map head . group . sort $ [3,1,1,1,2,2,1,1,2,3,4,2,1,2,1]
12:29:21 <lambdabot>  [1,2,3,4]
12:29:32 <Cale> map head . group . sort is more efficient than nub
12:29:38 <Cale> and additionally sorts the list
12:29:51 <dylan> > nub [1 | _ <- [1..100] ]
12:29:53 <lambdabot>  [1]
12:29:53 <monochrom> "â¨" is a good choice for the dual of "â§" because each is the upside down of the other.  "|" is a poor choice because it is not the upside down of "&".
12:29:54 <nmessenger> ah
12:29:57 <Cale> the downside is that it requires an Ord instance
12:30:11 <dylan> :t nub
12:30:11 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:30:17 <LoganCapaldo> woah, I didn't think that would work
12:30:22 <nmessenger> maybe sortnub?
12:30:35 <dylan> hump! let's call it hump!
12:30:37 <norpan> snub!
12:30:40 <LoganCapaldo> wait nvm
12:30:45 <lisppaste2> metaperl annotated #33490 with "is YAHT saying the right thing here?" at http://paste.lisp.org/display/33490#1
12:30:50 <dylan> > let hump = map head . group . sort
12:30:50 <lambdabot>  Parse error
12:30:52 <Cale> Perhaps that would be a better thing to call uniq
12:30:56 <monochrom> Thus you choose names and shapes to suggest the axioms they satisfy, not a particular interpretation or analogy.
12:30:59 <dylan> @let hump = map head . group . sort
12:31:00 <lambdabot> <local>:3:26:     Ambiguous type variable `a' in the constraint:       `Ord a...
12:31:00 <shapr> whee
12:31:12 <shapr> metaperl: Nah, I haven't been to florida yet.
12:31:20 <shapr> metaperl: I'll visit you and dylan when I am.
12:31:22 <metaperl> oic
12:31:29 <metaperl> ah, wonderful!
12:31:39 <metaperl> my cell # is 818-359-0893
12:31:51 * shapr puts that into his Nokia 770
12:31:54 <norpan> many cells in your prison apparently
12:31:56 <shapr> My cell # is 205-515-1921
12:32:09 <Cale> metaperl: that's an example of awkward wording in YAHT
12:32:12 <metaperl> lol @ norpan
12:32:25 <metaperl> here are some recent photos so you can find me in a crowd: http://www.flickr.com/photos/76239050@N00/
12:32:26 <lambdabot> Title: Flickr: Photos from princepawn
12:32:36 <metaperl> Cale - how so
12:32:41 <Cale> metaperl: the 'a b' there is meant to be the English word "a" followed by the symbol 'b'
12:32:42 <Iulus> what's the advantage of calling it 'uniq' over 'unique'? Two letters?
12:32:49 <shapr> metaperl: I'm jealous, I can't grow a beard to save my life.
12:32:50 <monochrom> yes
12:32:55 <metaperl> lol
12:33:00 <nmessenger> lulus: uniq is a unix tool
12:33:11 <shapr> metaperl: You know what I look like?
12:33:13 <nmessenger> lulus: familiarity
12:33:19 <monochrom> unix naming is a Huffman code.
12:33:19 <Cale> metaperl: but even with that knowledge it's awkward
12:33:21 <metaperl> shapr - no what do you look like?
12:33:22 <Iulus> I know that it's a unix tool
12:33:42 <shapr> metaperl: http://www.scannedinavian.com/hope/tag/shae
12:33:51 <Cale> metaperl: It's trying to say that it gives a computation which would return a value of type b if it were ever run.
12:34:02 <Cale> That is, a value of type 'c b'
12:34:18 <monochrom> You see I avoid "a" for variables.
12:34:24 <metaperl> shapr - I know what you look like. I thought you were going to compare yourself to a famous supermodel or something :)
12:34:41 <nmessenger> To avoid that problem, I usually enclose types and expression in parens when I write about code.
12:34:41 <metaperl> yes, that is what I thought Cale
12:34:42 <monochrom> To write down the type of (.) I use the type variables b,c,d.
12:34:44 <Iulus> but I don't think losing two letters from unique makes it better... why not just spell the whole work to make it completely understandable
12:34:45 <allbery_b> lulus: most old unix commands are short because you had to type them on a creaky old KSR33
12:34:48 <Cale> It would be much clearer if we could use Greek letters for type variables :)
12:34:53 <Cale> Î± vs. a
12:35:01 <Iulus> haha
12:35:11 <Cale> Iulus: I agree
12:35:15 <shapr> metaperl: oh, haha
12:35:25 <Iulus> also funny: some of you must have fonts that render capital i and l the same
12:35:33 <monochrom> tab-completion was not available 30 years ago.
12:35:36 <Cale> Iulus: however, 'unique' isn't how I'd spell it :)
12:35:40 <nmessenger> Cale: unfortunately, many can't type Unicode very conveniently, which is too bad
12:35:43 <Cale> I'd call it uniquify
12:35:57 <Cale> Yeah, people should install SCIM :)
12:36:02 <nmessenger> Cale: so you'd call map, 'mapify'?
12:36:08 <Cale> nmessenger: no
12:36:08 <dylan> shapr, metaperl: This is a somewhat recent picture of me. I'm not hard to spot in a crowd, usually: http://hardison.net/slug/event/sfd-2006/IMG_0237.JPG
12:36:13 <monochrom> haskellify
12:36:16 <Cale> nmessenger: map is a verb :)
12:36:21 <Cale> unique isn't a verb
12:36:32 <monochrom> just use Latin dammit
12:36:34 <iulus> that's a good point
12:36:54 <LoganCapaldo> It has to be a verb?
12:37:05 <LoganCapaldo> uniqueElementsOf xs ;)
12:37:07 <iulus> yes, then learning Haskell will be an exercise in FP, Category Theory, and Latin
12:37:14 <iulus> we'd have a pack of well-rounded individuals
12:37:34 <nmessenger> There's merit in using nouns.  It makes the code read more declaritively.
12:37:58 <dylan> dedupe :)
12:38:06 <nmessenger> undupe
12:38:10 <LoganCapaldo> unique xs works if you read it aloud (unique ex es)
12:38:49 <monochrom> I have an advantage because my first language is Chinese.
12:38:57 <nmessenger> monochrom: oh?
12:38:59 <monochrom> ok, I mean not English.
12:39:13 <nmessenger> Chinese /= not English
12:39:16 <metaperl> monochrom - I taught English in Taiwan
12:39:22 <shapr> dylan, metaperl: I'll be the only beardless geek in the gathering...
12:39:28 <monochrom> So sometimes I can just avoid reading too much into the wording of the program code.
12:39:30 <nmessenger> They are not mutually exclusive
12:40:03 <nmessenger> er, wait, I don't think that analogy applies, nvm
12:40:09 <monochrom> When I read the name "read", I can pretend it's a meaningless name.
12:40:23 * edi nods
12:40:28 <Cale> http://cale.yi.org/autoshare/Thinking.jpeg -- here's a funny picture of me that my dad took with his new camera yesterday.
12:40:28 <monochrom> I can resume my English ability when I read the doc.
12:40:43 <shapr> dylan, metaperl: Where in FL are you? Maybe we can find some nearby place to meet up?
12:40:56 <shapr> Cale: scary!
12:40:56 <metaperl> I'm in Tampa, he's in St. Petersburg
12:41:06 <Cale> hehe
12:41:07 <dylan> Tampa would be a good place to meet.
12:41:38 <dylan> Orlando is doable, though.
12:41:47 <metaperl> how about we hold a 2600 gathering and meet at it
12:42:14 <shapr> Hm, seems to be a 9 hour drive from B'ham to Tampa.
12:42:15 <dylan> or I could just have there be a local LUG meeting.
12:42:48 <dylan> Oh, wait. I thought you were going to be in Orlando?
12:42:49 <shapr> Orlanda is about the same for me.
12:42:55 <shapr> Orlando*
12:43:01 <shapr> Arlanda is the Stockholm airport...
12:43:07 <glguy> ?all-dicts syntax
12:43:08 <lambdabot> *** "Syntax" gcide "The Collaborative International Dictionary of English v.0.48"
12:43:09 <lambdabot> Syntax \Syn"tax\, n. [L. syntaxis, Gr. ?, fr. ? to put together
12:43:09 <lambdabot>   in order; sy`n with + ? to put in order; cf. F. syntaxe. See
12:43:09 <lambdabot>   {Syn-}, and {Tactics}.]
12:43:09 <lambdabot>   1. Connected system or order; union of things; a number of
12:43:10 <lambdabot> [55 @more lines]
12:43:33 <glguy> I'm trying to understand why people say that "Lisp has no syntax"
12:44:07 <shapr> Because prefix notation works as an AST syntax also.
12:44:10 <SamB> glguy: slight exaggeration of the simplictiy of s-expressions
12:44:11 <LoganCapaldo> glguy: I think they might just be confused and / or wrong
12:44:21 * metaperl goes on break
12:44:36 <glguy> requiring you to use sexps isn't "syntax"
12:44:37 <glguy> ?
12:44:59 <SamB> it is just about the only syntax that gets parsed...
12:45:23 <SamB> or, at least, any other syntax is very muddled
12:45:30 <SamB> due to the presence of macros
12:45:50 <dylan> shapr: I visit the pan-handle of FL about yearly.... hmm
12:46:00 <monochrom> I think only a lisper can explain "Lisp has no syntax"
12:46:44 <nmessenger> "Lisp has no syntax" is strictly false, but does reflect the simplicity of the syntax there
12:47:01 <monochrom> I think it's along the line of "I have no money", "I have no ethics", "I have no clue".
12:47:13 <edi> haha
12:47:36 <nmessenger> monochrom: except in this case we're talking about programming languages and muddy language is not a good thing
12:47:41 * edi meditates in silence
12:47:52 <monochrom> I hear no sound.
12:48:01 <iulus> I liked the uniformity of lisp (scheme) syntax when I used it
12:48:03 <SamB> monochrom: well, the lispers never seem to be the ones who say that
12:48:07 <SamB> usually it is me ;-)
12:48:07 * nmessenger watches edi closely, hoping to annoy him
12:48:14 <iulus> but it was Haskell's pattern matching that won me over
12:48:22 <dylan> "I ain't got no wife, ain't got no dog, ain't got no syntax. I'm a lisp-writin' cowboy..."
12:48:23 <monochrom> (Of course my computer is making sound in front of me, but I neglect it.)
12:48:24 <iulus> (and since then, it's the other stuff that keeps me)
12:49:02 <therp> just to add to data items to the simple syntax discussion :) "cat ghc/compiler/parser/(Lexer.x|Parser.y) | wc -l" -> 3540. cat ghc/compiler/liskell/(LexLiskell.x|ParseLiskell.y) | wc -l -> 167
12:49:20 <therp> s/to/two/
12:49:59 <monochrom> Don't forget that exceptions are pervasive.  "___ no ___" means "___ no ___ except ___ but that doesn't count".
12:50:21 <monochrom> Recall that lispers have macros.  They have defined their "no" macro to expand to that.
12:50:46 <therp> monochrom: I have never seen a no macro
12:51:06 <monochrom> I am joking.
12:51:14 <therp> ah, I didn't get that
12:51:31 <velco> is there bitwise ops in haskell ?
12:51:46 <edi> ?docs Data.Bits
12:51:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
12:51:47 <glguy> yes there are
12:51:47 <monochrom> Data.Bits
12:52:03 <nmessenger> velco: (Data.Bits..|.), (Data.Bits..&.), etc
12:52:15 <velco> thanks, found it.
12:53:27 <nmessenger> speaking of lisp, it's amazing how 'lispy' you can get haskell source to look.  Of course, since the source is not *actually* made of runtime-inspectable lists, there is precisely zero benefit in doing so.
12:53:37 <nmessenger> ?paste
12:53:38 <lambdabot> http://paste.lisp.org/new/haskell
12:54:22 <glguy> I've heard Coq come up a few times... does it relate at all to Prolog?
12:54:34 <lisppaste2> nmessenger pasted "lispy!" at http://paste.lisp.org/display/33494
12:55:17 <Cale> http://en.wikipedia.org/wiki/Coq
12:55:48 <Cale> It's a mathematical proof checker/assistant.
12:56:14 <monochrom> No, not related.
12:56:28 <monochrom> (except ____ but that doesn't count)
12:56:44 <monochrom> Hahaha, this notwithstanding macro is great!
12:58:20 <glguy> I had never seen something like this at the toplevel: (nil, cons, cat, elt) = ([], (:), (++), flip (!!))
12:59:10 <monochrom> If you can do it under "let" or "where", you can do it at the top level.  (there may be exceptions)
12:59:19 <Cale> It's just an ordinary pattern binding of course
12:59:23 <glguy> right
12:59:33 <glguy> it just didn't occur to me that you could
12:59:33 <nmessenger> glguy: it's cool, but you have to watch out for the 'dreaded monomorphism restriction'.  I was getting the strangest errors that I couldn't understand
12:59:56 <glguy> I've only seen: name = value  at the toplevel
13:00:00 <nmessenger> I had (>>=) in the bound tuple as well, that made bad stuff happen.
13:00:05 <monochrom> As an example you can also write "1=2" almost everywhere.
13:00:29 * edi scribbles "1=2" on the wall
13:00:47 <monochrom> yeah, few people use the general "pattern = rhs" at the top level.  But it exists.
13:01:09 <Cale> there's no reason to disallow it
13:01:33 <nmessenger> ?pl \x y z -> x ++ y ++ z
13:01:34 <lambdabot> (. (++)) . (.) . (++)
13:01:40 <nmessenger> yuck
13:01:53 <dylan> morse code, hehe
13:02:07 <glguy> ?pl \x y z -> concat [x,y,z]
13:02:09 <lambdabot> ((join .) .) . (. ((. return) . (:))) . (.) . (:)
13:02:12 * monochrom comes along looking at the wall after edi has left
13:02:18 * nmessenger is horrified
13:02:24 <monochrom> "Oh no!  1=2!  The writing is in the wall!"
13:02:32 <dylan> #haskell makes writing horrible code at my day job less painful. :)
13:02:35 <monochrom> (perhaps "on the wall"?)
13:02:43 <edi> ?type let (.:) = (.) . (.) in (++) .: (++)
13:02:44 <lambdabot> forall a. [a] -> [a] -> [a] -> [a]
13:02:55 <edi> Better.
13:03:12 <nmessenger> yay!
13:03:13 <sjanssen> @let 1 = 2
13:03:14 <lambdabot> Defined.
13:03:24 <nmessenger> > (+4) 1
13:03:25 <lambdabot>  5
13:03:39 <glguy> that would at least need: L.1 :)
13:03:44 <nmessenger> > (+4) L.1
13:03:45 <lambdabot>  Not in scope: data constructor `L'
13:03:57 <Cale> haha, the latest xkcd is great
13:04:18 <edi> @let the dogs = out
13:04:19 <lambdabot> <local>:5:0:     Warning: Pattern match(es) are overlapped              In th...
13:04:42 <edi> Cale: the right hand rule?
13:04:55 <Cale> edi: YouTube video comments
13:04:59 <glguy> I pray GunPistolMan never learns the word 'sheeple'
13:05:15 <edi> Silly rss reader.
13:05:17 <Cale> edi: you've missed a few
13:05:30 <nmessenger> hahaha xkcd is always great
13:05:44 <glguy> reading xkcd makes me "not a firefox user"
13:06:18 <nmessenger> glguy: hmm?
13:06:21 <dylan> glguy: hmm?
13:06:37 <nmessenger> dylan: hmm?
13:06:40 <glguy> firefox has broken hover tooltips
13:06:47 <dylan> nmessenger: jinx. :P
13:06:49 <nmessenger> ah yes
13:07:05 <dylan> firefox's tooltip behavior is technically correct.
13:07:18 <dylan> alt="" isn't supposed to be used for that, title="" is.
13:07:22 <dylan> (IIRC)
13:07:47 <nmessenger> dylan: firefox's title cuts off after so many characters
13:07:58 <nmessenger> with an elipsis
13:07:59 <dylan> Ah.
13:08:16 <nmessenger> alt for title is evil, but is not xkcd's sin
13:08:52 <nmessenger> ?google Firefox title text extension
13:08:57 <lambdabot> http://www.menjatallarins.com/extensions/
13:08:57 <lambdabot> Title: My Firefox extensions
13:09:09 <wolverian> epiphany++
13:09:20 <monochrom> You can write "1=2" but it will do nothing due to lazy evaluation.
13:09:43 <nmessenger> blah
13:09:58 <norpan> > let 1=2 in 1
13:09:59 <lambdabot>  1
13:10:02 <norpan> bah
13:10:34 <dylan> > let 'c' = 1 in 'c'
13:10:34 <lambdabot>  add an instance declaration for (Num Char)
13:10:34 <lambdabot>   In a pattern binding: 'c' = ...
13:10:34 <nmessenger> > let 1 = 'a' in 1
13:10:35 <lambdabot>  add an instance declaration for (Num Char)
13:10:35 <lambdabot>   When checking the pattern: 1...
13:10:42 <nmessenger> dylan: jinx!
13:10:46 <nmessenger> :P
13:10:49 <dylan> nmessenger: stay out of my mind!
13:11:01 <nmessenger> dylan: no! it's fun here!
13:12:42 <mbishop> I hate strings so much :/
13:12:55 <nmessenger> I heart strings
13:13:54 <nmessenger> mbishop: what prompts this malcontent?
13:14:28 <nmessenger> 20K - https://addons.mozilla.org/firefox/1715/
13:15:13 <nmessenger> (lambdabot? title?! ...sigh)  Long Title firefox extension
13:15:25 <mbishop> nmessenger: well they just have lots of problems...different encodings, different formats (a delimiter can be just about anything), and to do anything useful with them, you typically have to change them into another data type
13:16:16 <nmessenger> mbishop: ah, so you're in escaping and encoding hell?
13:17:00 <mbishop> you're always in that hell when dealing with strings :\
13:17:03 * nmessenger hugs mbishop
13:18:53 <nmessenger> glguy: did you see that extension?
13:20:24 * nmessenger restarts his firefox to install the Long Titles extension
13:29:36 <nmessenger> is there any reason naming rules couldn't be extended so that after the first char of an operator name, alphanumerics would be acceptable?
13:30:21 <nmessenger> ditto ordinary name, operator symbols?
13:30:50 <wilx`> Huh?
13:30:52 <wilx`> Like...what?
13:31:02 <nmessenger> let .2 = (.) . (.)
13:31:03 <wilx`> +foo as a single operator name?
13:31:10 <nmessenger> sure
13:31:15 <nmessenger> oh
13:31:20 <wilx`> I think that would be hard to read and such.
13:31:33 <dylan> `+foo`?
13:31:35 <wilx`> Not to mention the difficulty of parsing.
13:31:39 <nmessenger> that would introduce a lexical ambiguity
13:32:38 <dylan> let a `+b` b = a + b in 10 +b 20
13:32:43 <dylan> err
13:32:46 <dylan> > let a `+b` b = a + b in 10 `+b` 20
13:32:47 <lambdabot>  Parse error
13:32:51 <dylan> hm.
13:32:56 <glguy> > let a +b b = a + b in 1 +b 2
13:32:57 <lambdabot>  Parse error in pattern
13:33:08 <nmessenger> dylan: you cannot mix operator symbols with ordinary name symbols
13:33:25 <dylan> you can't use `` to operator-quote symbols?
13:33:33 <dylan> > 1 `+` 2
13:33:39 <lambdabot>  Parse error
13:33:49 <nmessenger> that wouldn't make sense, operators are already infix
13:34:05 <nmessenger> > let plus = (+) in 1 `plus` 2
13:34:06 <lambdabot>  3
13:35:12 <nmessenger> prefix: name, (!);  infix: `name`, !
13:35:43 <allbery_b> let's say we define +b as an operator.  how do you parse a+b when said definition is in scope, vs. out of scope?
13:36:03 <allbery_b> that strikes me as an especially evil kind of ambiguity
13:36:18 <allbery_b> (ghc does support postfix ops...)
13:36:20 <nmessenger> allbery_b that's why I mentioned the ambiguity.  Suggestion withdrawn
13:36:40 <nmessenger> postfix? how?
13:36:58 <allbery_b> couldn't tell you that; just saw it mentioned in the docs
13:37:17 <liyang> operators needn't take 2 arguments.
13:37:37 <dylan> postfix type constructors would be useful in one limited case...
13:37:45 <wy> I wonder if there is a way to find the definition of every built-in function from the interpreter ?
13:37:50 <nmessenger> > let x % = x + 1 in 5 %
13:37:50 <lambdabot>  Parse error
13:37:51 <dylan> (units of measure)
13:38:06 <nmessenger> wy: :browse Prelude
13:38:18 <lisppaste2> metaperl pasted "what does const do?" at http://paste.lisp.org/display/33495
13:38:19 <nmessenger> wy: their types, anyway
13:38:31 <nmessenger> > const 1 2
13:38:32 <lambdabot>  1
13:38:35 <monochrom> No, the interpreter doesn't spit out definitions
13:38:40 <nmessenger> > const "foo" "bar"
13:38:42 <lambdabot>  "foo"
13:38:47 <wy> How can I see the source code?
13:38:49 <nmessenger> > const "foo" 'c'
13:38:53 <lambdabot>  "foo"
13:38:54 <dylan> const a _ = a
13:38:57 <liyang> > let (%) x = x / 100 in (50%)
13:38:59 <lambdabot>  add an instance declaration for (Fractional (t -> t1))
13:39:00 <allbery_b> const ignores its second argument.  it's a way to eat an argument without processing it
13:39:01 <lambdabot>   In the definitio...
13:39:09 <edi> ?index const -- wy, first step
13:39:09 <lambdabot> bzzt
13:39:10 <allbery_b> wy:
13:39:11 <nmessenger> ?where goa
13:39:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:39:13 <allbery_b> ?source Prelude
13:39:15 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
13:39:15 <liyang> > let (%) x = x +1 in (50%)
13:39:17 <lambdabot>  add an instance declaration for (Num (t -> t1))
13:39:19 <lambdabot>   In the definition of `s...
13:39:25 <metaperl> oh I see
13:39:32 <nmessenger> wy: have you heard of goa?
13:39:33 <metaperl> @type const
13:39:35 <lambdabot> forall a b. a -> b -> a
13:39:41 <nmessenger> wy: ghci + lambdabot
13:39:42 <wy> nmessenger: No. I'm pretty new
13:39:57 <allbery_b> you can't see sources in unmodified ghci.  (you could define a function to look it up for you, like the code to hook lambdabot into ghci)
13:40:00 <nmessenger> wy: I've not used it yet myself, but I plan to.
13:40:12 <edi> :)
13:40:58 <wy> nmessenger: I've seem lambdabot as a wonderful source. But I wonder it will be annoying if I do everything in this channel. Is it easy to install?
13:41:16 <dylan> wy: you can private message lambdabot
13:41:19 <nmessenger> wy: you could /msg
13:41:20 <allbery_b> you can also /msg lambdabot (assuming you're registered with freenode)
13:41:26 <wy> Good idea :-)
13:41:29 <allbery_b> or use the web page
13:41:29 <nmessenger> 3-way jinx
13:41:47 <edi> Does hs-plugin work with 6.6 yet?
13:41:47 <wy> What's goa?
13:41:56 <nmessenger> GHCi on Acia
13:42:04 <nmessenger> s/Acia/Acid/
13:42:32 <nmessenger> *groan*
13:42:40 <wy> nmessenger: What's that?
13:43:00 <edi> It gives you the ability to perform lambdabot queries like in channel, directly from ghci's prompt.
13:43:13 <nmessenger> wy: it just means 'enhanced ghci'.
13:43:17 <edi> Like :index, :pl, :source ...
13:43:39 <allbery_b> edi: not yet from what I've heard
13:43:40 <nmessenger> I want to use it just for :hoogle
13:45:35 <edi> allbery_b - Why?
13:46:49 * nmessenger7 grumbles at his ISP
13:49:52 <Z4rd0Z> is <- used instead of = only when doing IO?
13:50:23 <dylan> only when messing with monads.
13:50:45 <monochrom> <- is part of a syntactic sugar for >>=
13:50:49 <nmessenger7> Z4rd0Z and since IO is a monad, yes
13:51:20 <monochrom> do { v <- xxx; yyy } is really xxx >>= (\v -> yyy)
13:51:41 <monochrom> But I guess as a first approximation, I can say yes to your question.
13:52:15 <Z4rd0Z> thanks, that clarifies things a bit
13:52:42 <Z4rd0Z> although I still don't have monads down quite yet
13:53:27 <dylan> Don't try to understand monads. Try to understand the operators >>=, >>, and the function 'return'.
13:54:01 <allbery_b> @go you could have invented monads
13:54:02 <nmessenger7> Z4rd0Z: I don't have Monads "down" either, but I've learned that the important Monady bit is in the definition of (>>=).  I've learned just by using some Monads, IO and Parsec.
13:54:02 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
13:54:02 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
13:54:33 <Z4rd0Z> I will take all of your advice
13:54:45 <dons> ?undo c <- getChar ; d <- getChar ; putChar c ; return d
13:54:46 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
13:54:50 <dons> ?undo do c <- getChar ; d <- getChar ; putChar c ; return d
13:54:51 <lambdabot> getChar >>= \ c -> getChar >>= \ d -> putChar c >> return d
13:55:05 <nmessenger7>  ?undo and ?redo are your friends
13:55:18 <newsham> use "<-" for binding in do-blocks and "=" for bindig in "let" and function defs
13:55:26 <dons> ?redo getChar >>= putChar
13:55:27 <lambdabot> do { a <- getChar; putChar a}
13:55:55 <newsham> http://www.haskell.org/haskellwiki/IOIntro_Actions talks a bit about using do-blocks.
13:55:56 <lambdabot> Title: IOIntro Actions - HaskellWiki
13:56:03 <dons> ?uptime
13:56:04 <lambdabot> uptime: 5d 21h 14m 40s, longest uptime: 9d 2h 23m 6s
13:56:14 <Botje> ?undo do {when (1<2) (putStrLn "LIES"); ()}
13:56:14 <lambdabot> when (1 < 2) (putStrLn "LIES") >> ()
13:56:45 <nmessenger7> > when (1 < 2) (putStrLn "LIES") >> ()
13:56:45 <dons> well, it doesn't inline monadic combinators, like when :)
13:56:45 <newsham> ()?
13:56:46 <lambdabot>  Couldn't match `IO b' against `()'
13:56:53 <newsham> IO isnt an IO :)
13:56:55 <nmessenger7> I thought that was a type error
13:56:57 <newsham> err () isnt an IO
13:57:18 <nmessenger7> > when (1 < 2) (putStrLn "LIES") >> return ()
13:57:19 <newsham> putStrLn already results in a ()
13:57:20 <lambdabot>  <IO ()>
13:57:29 <nmessenger7> > when (1 < 2) (putStrLn "LIES")
13:57:30 <lambdabot>  <IO ()>
13:57:34 <newsham> ?type when
13:57:35 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:57:36 <newsham> as does when
13:57:43 <liyang> more importantly when already results in an IO ()...
13:57:47 <pstickne> in the things abouve, what does the \ in, such as \v, mean?
13:57:51 <pstickne> *above
13:58:00 <nmessenger7> \ = lambda
13:58:01 <newsham> pstickne: its a lambda.
13:58:06 <newsham> its missing a leg :)
13:58:14 <nmessenger7> ?google Lambda Calculus
13:58:16 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
13:58:16 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
13:58:23 <newsham> > (\x -> x + 1) 3
13:58:24 <lambdabot>  4
13:58:30 <nmessenger7> That article's a bit heady, though
13:59:08 <pstickne> > (\x y -> x * y) 2 3
13:59:09 <lambdabot>  6
13:59:25 <newsham> ?pl (\x y -> x * y)
13:59:25 <lambdabot> (*)
13:59:38 <pstickne> what is ?pl ?
13:59:43 <nmessenger7> pointless
13:59:47 <allbery_b> basically, a lambda expression is a temporary anonymous function.
13:59:51 <newsham> > (*) 2 3
13:59:52 <lambdabot>  6
13:59:53 <nmessenger7> or point-free,
14:00:19 <pstickne> can all lambdas be ?pl'ed?
14:00:43 <allbery_b> yes, but sometimes the result is much uglier than the original
14:00:58 <nmessenger7> ?pl \x y z -> x ++ y ++ z
14:00:58 <lambdabot> (. (++)) . (.) . (++)
14:01:27 <allbery_b> @pl \l -> \(s,v) -> (s, l ++ [v]) -- example of one I tried the other day
14:01:30 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . (. return) . (++)
14:01:36 <nmessenger7> neat!
14:01:37 <newsham> ?pl \x y z -> x + 2*y*z + x*y*z
14:01:40 <lambdabot> ap (ap . (liftM2 (+) .) . (. ((*) . (2 *))) . (.) . (+)) (((*) .) . (*))
14:01:41 <lambdabot> optimization suspended, use @pl-resume to continue.
14:01:51 <dons> also there is @unpl
14:02:30 <newsham> ?pl-resume
14:02:32 <lambdabot> ap (ap . (liftM2 (+) .) . (. ((*) . (2 *))) . (.) . (+)) (((*) .) . (*))
14:02:41 <nmessenger7> ?list pl
14:02:42 <lambdabot> pl provides: pointless pl-resume pl
14:02:44 <nmessenger7> ?list pointful
14:02:45 <lambdabot> pointful provides: pointful pointy repoint unpointless unpl unpf
14:03:11 <dylan> @unpl a . b
14:03:12 <lambdabot> (\ e -> a (b e))
14:03:33 <dylan> @unpl ap (ap . (liftM2 (+) .) . (. ((*) . (2 *))) . (.) . (+)) (((*) .) . (*))
14:03:34 <lambdabot> ((\ u ai -> (\ at e -> (\ k -> u + ((2 * at) * k)) >>= \ b -> e >>= \ a -> return (b + a)) >>= \ af -> ai >>= \ ae -> return (af ae)) >>= \ n -> (\ aq az -> (*) (aq * az)) >>= \ m -> return (n m))
14:03:45 <newsham> ?unpl (+ 3) . (* 2) . read
14:03:45 <lambdabot> (\ e -> ((read e) * 2) + 3)
14:03:45 <nmessenger> yikes!
14:04:08 <dylan> hmm, pl . unpl is an obsufucation machine!
14:04:28 <dylan> @. pl unpl \f x -> f x
14:04:28 <lambdabot> id
14:04:35 <nmessenger> sometimes
14:04:49 <allbery_b> @. unpl pl \f x -> f x
14:04:50 <lambdabot> (\ a -> a)
14:04:51 <dylan> @. pl unpl (\x y -> x * y)
14:04:52 <lambdabot> (*)
14:04:57 <monochrom> ?pl \x -> let y = f x in y
14:04:57 <lambdabot> f
14:05:14 <newsham> ?. pl unpl \a b c -> b*b - sqrt(b - 4*a*c)/2*a
14:05:14 <monochrom> you see point-free is usually simpler and more direct
14:05:19 <lambdabot> join (flip . ((flip . ((*) .)) .) . flip flip 2 . (flip .) . (((/) .) .) . ap ((.) . (-) . join (*)) . ((sqrt .) .) . ((*) .) . flip ((*) . subtract 4))
14:05:19 <lambdabot> optimization suspended, use @pl-resume to continue.
14:05:42 <nmessenger> ?. unpl pl \a b c -> b*b - sqrt(b - 4*a*c)/2*a
14:05:46 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}: Parse error
14:05:52 <nmessenger> parse error!
14:05:56 <monochrom> Wow that's cool
14:05:56 <newsham> why is there no obfuscated-haskell programming contest?
14:06:09 <nmessenger> isn't there?
14:06:10 <monochrom> because no one is interested
14:06:17 <SamB_XP> eh, there is one
14:06:19 <nmessenger> ?google Obfuscated Haskell
14:06:21 <lambdabot> http://iohcc.mgoetze.net/winners.html
14:06:22 <lambdabot> Title: International Obfuscated Haskell Code Contest
14:06:30 <monochrom> It's pretty dead.
14:06:36 <SamB_XP> maybe it hasn't happened lately, but then has anyone wanted to enter?
14:06:51 <newsham> lambdabot would always win!
14:07:21 * esap once wrote some code for that contest... Nothing very spectacular though
14:07:22 <SamB_XP> maybe
14:07:43 <nmessenger> I dunno, I saw a powerful ugly dons creation
14:09:26 <newsham> > (\a b c -> b*b - sqrt(b - 4*a*c)/2*a) 1 2 1
14:09:27 <lambdabot>  NaN
14:09:47 <edi> ?paste
14:09:47 <lambdabot> http://paste.lisp.org/new/haskell
14:09:48 <nmessenger> > sqrt (-1)
14:09:49 <newsham> > (\a b c -> b*b - sqrt(b - 4*a*c)/2*a) 1 8 1
14:09:49 <lambdabot>  NaN
14:09:50 <lambdabot>  63.0
14:10:05 <monochrom> x/y*z is parsed as (x/y)*z
14:10:21 <newsham> > (\a b c -> b*b - sqrt(b - 4*a*c)/(2*a)) 1 8 1
14:10:23 <lambdabot>  63.0
14:10:42 <monochrom> Not to mention that x-y/z is parsed as x-(y/z)
14:10:54 <pstickne> are there any desktop applications written in Haskell?
14:10:56 <monochrom> Don't you hate precedence rules? :)
14:11:10 <nmessenger> shouldnt that be s/b*b/(-b)/ and s/sqrt(b/sqrt(b*b/ ?
14:11:12 <lisppaste2> edi pasted "allbery_b, goa works." at http://paste.lisp.org/display/33498
14:11:12 <monochrom> I use ghci on my desktop all the time
14:11:15 <newsham> desktop== gui?
14:11:26 <pstickne> newsham, yeah
14:11:50 <newsham> there are a few gui widget bindings for haskell so i'm sure there are programs which use them
14:12:03 <pstickne> hmm.
14:12:07 <newsham> http://www.haskell.org/~petersen/haskell/hsclock/  for example
14:12:08 <lambdabot> Title: HsClock
14:12:18 <dons> there's a really nice gtk clock on haskell.org's gtk2hs page
14:12:29 <monochrom> the quadratic formula is really -b +/- sqrt(b*b - 4*a*c)/(2*a)
14:13:01 <newsham> mono: i didnt wanna go list-monad on you
14:13:24 <newsham> oh, i got the b*b part wrong. heh..
14:13:40 <monochrom> You just don't want to comprehend me.
14:13:41 <newsham> here's some more gui apps:  http://wxhaskell.sourceforge.net/applications.html
14:13:42 <nmessenger> ?let quadratic a b c = let det = b*b - 4*a*c in (-b + det / (2*a), -b - det / (2*a)
14:13:42 <lambdabot> Title: wxHaskell
14:13:42 <lambdabot>  Parse error
14:13:51 <dons> ?where gtk2hs
14:13:52 <lambdabot> http://haskell.org/gtk2hs/
14:13:54 <nmessenger> ?let quadratic a b c = let det = b*b - 4*a*c in (-b + det / (2*a), -b - det / (2*a))
14:13:55 <lambdabot> Defined.
14:14:03 <dons> gtk2hs and wxHaskell are the two main gui options
14:14:07 <edi> nmessenger: I had to make a little modification to dot-ghci to use GOA, if you want to try it out.
14:14:08 <newsham> nmess: please make it a list and not a tuple.
14:14:10 <dons> and their web pages should point to some nice examples
14:14:34 <nmessenger> ?let quadratic a b c = let det = b*b - 4*a*c in [-b + det / (2*a), -b - det / (2*a)]
14:14:34 <lambdabot> Couldn't match `(a, a)' against `[a1]'
14:14:38 <pejo> pstickne, Alfa is written in Haskell.
14:14:46 <nmessenger> ?undefined quadratic
14:14:47 <lambdabot> Undefined.
14:14:51 <nmessenger> ?let quadratic a b c = let det = b*b - 4*a*c in [-b + det / (2*a), -b - det / (2*a)]
14:14:52 <lambdabot> Defined.
14:15:13 <nmessenger> ?let quadratic a b c = let det = b*b - 4*a*c in [(-b + det) / (2*a), (-b - det) / (2*a)]
14:15:13 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
14:15:20 <nmessenger> dammit
14:15:25 <nmessenger> ?undefine quadratic
14:15:26 <lambdabot> Undefined.
14:15:32 <nmessenger> ?let quadratic a b c = let det = b*b - 4*a*c in [(-b + det) / (2*a), (-b - det) / (2*a)]
14:15:32 <newsham> > L.quadratic 1 8 1 >>= (* 3) . (+ 2)
14:15:33 <lambdabot>  Not in scope: `L.quadratic'
14:15:33 <lambdabot> Defined.
14:15:48 <newsham> > L.quadratic 1 8 1 >>= (* 3) . (+ 2)
14:15:49 <lambdabot>  add an instance declaration for (Fractional [b])
14:16:02 <edi> err.
14:16:22 <edi> > ((*3) . (+2)) `fmap` L.quadratic 1 8 1
14:16:23 <lambdabot>  [84.0,-96.0]
14:16:33 <newsham> > do { x <- quadratic 1 8 1; return (x * 3 + 2) }
14:16:33 <lambdabot>  Not in scope: `quadratic'
14:16:40 <newsham> > do { x <- L.quadratic 1 8 1; return (x * 3 + 2) }
14:16:42 <lambdabot>  [80.0,-100.0]
14:17:04 <edi> @. pl undo \f amb -> do { x <- amb; return (f amb) } -- newsham
14:17:05 <lambdabot> ap (>>=) . ((const . return) .)
14:17:08 <edi> argh!
14:17:13 <edi> @. pl undo \f amb -> do { x <- amb; return (f x) }
14:17:14 <lambdabot> fmap
14:17:48 <nornagon> :t fmap
14:17:49 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
14:18:24 <nmessenger> :check (\xs f -> concatMap f xs == fmap f xs)
14:18:37 <nmessenger> ?check (\xs f -> concatMap f xs == fmap f xs)
14:18:38 <edi> False
14:18:38 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b]       Expected...
14:18:42 <pstickne> in the forall... what does the "." mean?
14:18:51 <monochrom> punctuation
14:18:56 <newsham> end of forall.
14:19:06 <newsham> no?
14:19:15 <nmessenger> ?check (\xs f -> concatMap f xs == fmap f xs) :: [Int] -> (Int -> Int) -> Bool
14:19:16 <lambdabot>  Couldn't match `[b]' against `Int'
14:19:21 <monochrom> end of the variable list, but not the end of the whole statement.
14:20:03 <ptolomy> Do any of you ever find a good use for syntactical abstraction in haskell?
14:20:12 <nmessenger> ?check (\xs f -> concatMap f xs == (>>=) f xs) :: [Int] -> (Int -> Int) -> Bool
14:20:13 <lambdabot>  Couldn't match `[b]' against `Int'
14:20:26 <nmessenger> someone please unstupid me
14:20:43 <newsham> me first
14:20:48 <edi> ?check \xs f -> concatMap f (xs :: [Int]) == f >>= xs
14:20:49 <lambdabot>  Couldn't match `[b]' against `Int -> [b]'
14:21:19 <dons> ptolomy: you mean defining new syntax?
14:21:36 <monochrom> xs >>= f
14:21:45 <nmessenger> ?check (\xs f -> concatMap f xs == (>>=) xs f) :: [Int] -> (Int -> Int) -> Bool
14:21:46 <lambdabot>  Couldn't match `[b]' against `Int'
14:21:51 <ptolomy> dons: Yeah, similar to lisp macros. I've never found it necessary, as haskell tends to be flexible and concise enough as it is.
14:21:56 <dons> ptolomy: in which case, /sometimes/. particualrly when defining a new language 'feature' or writing an embedded language. but the haskell syntax is flexible enough that new syntax isnt' really needed
14:21:57 * edi >>= fix away
14:22:09 <dons> yeah, with laziness and higher order functions, a lot of the use for macros is gone
14:22:20 <dons> e.g. forever a = a >> forever a -- no need for syntax
14:22:35 <ptolomy> And if you use the natural flexibility of the language, it remains consistent.
14:22:48 <dons> yep
14:22:51 <nmessenger> dons: *most* uses, but there is still some boilerplate that could be abstracted away
14:22:59 <dons> definitely
14:23:06 <ptolomy> The main use I can think of would be for code generation.
14:23:07 <dons> and TH helps a little, but its not lisp :)
14:23:07 <emu> and operations on declarations
14:23:14 <emu> like "deriving" magic
14:23:19 <dons> TH is designed for code generation, ptolomy
14:23:30 <nmessenger> data T = T deriving (magic)
14:23:33 * ptolomy hits the wiki.
14:23:40 <dons> its just heavier than lisp macros, since  the haskell syntax is larger. it is used for deriving new classes, for example
14:23:41 <monochrom> 90% of lisp/scheme macros are just to obtain call-by-name.
14:23:43 <emu> class Magic a where?
14:23:46 <nmessenger> s/m/M/
14:24:11 <newsham> also TH doesnt have access to as much stuff :(
14:24:29 <emu> how about type meta-classes?
14:24:32 <nmessenger> there will always be trade-offs
14:24:39 <dons> yeah. its just on the edge of complexity and rare-usedness, that not many people use it :)
14:25:12 <newsham> like referencing generated stuff from within a TH macro :(
14:26:05 <ptolomy> I bet someone could come up with a snarky corollary to Greenspun's 10th Rule about how every language feature implemented with a macro is a less-featured bug-ridden version of what already exists in a more modern language..
14:26:58 <nmessenger> Aha! I have been unstupided!
14:27:07 <nmessenger> ?check (\xs f -> concatMap f xs == (>>=) xs f) :: [Int] -> (Int -> [Int]) -> Bool
14:27:13 <lambdabot> Terminated
14:27:25 <monochrom> I was about to say that about f.
14:28:29 <dons> ?scheck (\xs f -> concatMap f xs == (>>=) xs f) :: [Int] -> (Int -> [Int]) -> Bool
14:28:36 <lambdabot> Terminated
14:28:39 <nmessenger> ?help scheck
14:28:39 <lambdabot> scheck <expr>
14:28:39 <lambdabot> You have SmallCheck and 3 seconds. Test something.
14:28:39 <dons> too hard :)
14:28:46 <dons> ?scheck False
14:28:48 <lambdabot>   Failed test no. 1. Test values follow.:
14:28:49 <dons> ?check False
14:28:50 <lambdabot>  Falsifiable, after 0 tests:
14:28:54 <dons> ?check True
14:28:56 <lambdabot>  OK, passed 500 tests.
14:28:57 <dons> ?scheck True
14:28:58 <lambdabot>   Completed 1 test(s) without failure.
14:29:08 <dons> scheck is smarter, and uses induction to produces test cases
14:29:58 <nmessenger> Is there a way to reduce the test runs so it won't get Terminated?
14:30:40 <nmessenger> (and by the way, it should make random Schwarzenegger quotes when it does that)
14:30:50 <sjanssen> alternatively, could scheck report the number of tests passed so far when it runs out of time?
14:31:08 <dons> sjanssen: yeah, we'd have to add the timeout to scheck itself though
14:31:10 <dons> rather than a wrapper
14:31:20 <dons> nmessenger: could be done.
14:31:23 <nmessenger> sjanssen: I know nothing of the code, but that sounds like a biggish rewrite
14:31:36 <dons> something like : @check-set n=100
14:32:03 <SamB_XP> oooh, random Scharzenegger quotes...
14:32:07 <SamB_XP> good idea ;-)
14:32:16 <dons> it'd require writing test cases into an MVar, running scheck in a separate thread, then taking whatever was put in the MVar after a timeout
14:33:03 <nmessenger> ?spell Schwarzenegger
14:33:03 <lambdabot> Schwarzenegger
14:33:22 <nmessenger> (just checking)
14:38:17 <nmessenger> If SmallCheck is smarter, are there any advantages to using QuickCheck?
14:39:14 <gvdm_other> is it quicker?
14:39:28 <nmessenger> (that would be my intuition)
14:40:05 <nmessenger> though speed is not a terrible concern in testing
14:40:06 <monochrom> More people know Quickcheck.
14:40:41 <emu> are the tests written similarly?
14:40:48 <emu> and the Arbitrary instance
14:40:52 <monochrom> Fewer people are ready to believe that computer is smart.
14:40:58 <nmessenger> in other words, are the APIs similar?
14:41:46 <nmessenger> monochrom: hmm?  Computers are dumb rocks.  Algorithms vary in effectiveness.
14:41:59 <monochrom> QED
14:43:10 <monochrom> Perhaps I see what you mean.  Let me rephrase.  I use "computer" to include programs.
14:43:20 <monochrom> Fewer people are ready to believe that algorithms can be smart.
14:44:06 <nmessenger> well 'smart' is an imprecise word in this context, better suited would be to say that algorithms carry different tradeoffs
14:45:04 <nmessenger> I think that's rather well-known among programmers
14:45:22 <monochrom> Perhaps I am not a programmer.
14:45:51 <nmessenger> Really?  You come off as intelligent and well-versed.
14:46:08 <monochrom> That's because I am a database and an inference engine.
14:46:28 * nmessenger curses: "Damn bots!"
14:46:34 <monochrom> haha
14:47:14 <monochrom> Is there a corner case to make SmartCheck take too long?
14:48:28 <nmessenger> s/SmartCheck/SmallCheck/ ?
14:48:42 <monochrom> Damn.  Yes, SmallCheck.
14:49:32 <nmessenger> ?where SmallCheck
14:49:32 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
14:49:33 <dmhouse> Anyone used the Cookie interface in HAppS?
14:51:56 <nmessenger> monochrom: is it not a philosophic question that we could all perhaps be "a database and an inference engine" at the core?
14:52:39 <monochrom> Yeah.
14:53:35 * nmessenger zones out and says "Woah dude" a lot
15:01:16 <Keith_Adams> Greetings!
15:02:54 <velco> how can I create an unboxed array of a type like ``data T = F Int | G''
15:02:55 <velco> ?
15:04:06 <AStorm> nmessenger, that inference engine infers what?
15:04:13 <AStorm> reality? :P
15:04:29 <nmessenger> AStorm: define 'reality' :P
15:04:53 <AStorm> Can't. That's why the engine is buggy :P
15:05:08 <dons> did people see: http://programming.reddit.com/info/w73z/comments
15:05:10 <lambdabot> Title: Tying the knot with circular data structures in Haskell (reddit.com)
15:05:46 <monochrom> velco: no unboxed array for that.
15:06:24 <monochrom> the inference engine completes the database.
15:06:27 <AStorm> velco, impossible
15:06:33 <velco> ok
15:07:01 <AStorm> monochrom, what would you do with all that body stuff then?
15:07:08 <AStorm> ;-)
15:07:09 <dons> AStorm: not impossible though
15:07:23 <dons> you could define a Storable instance that maps the type T onto an unboxed value
15:07:25 <AStorm> dons, yeah, two lists
15:07:30 <monochrom> The body is an interface to RealWorld#
15:07:33 <dons> e.g. a Word64 or something :)
15:07:47 <AStorm> or a special container
15:08:00 <dons> basically you just have to pack it into a type that is unboxable
15:08:14 <monochrom> Specifically, the body writes to and reads from #haskell
15:08:31 <dons> if you knew you always fit inside 2^31, you could use a Word32 + a tag bit for the G constructor ;)
15:08:35 <emu> dons: whatever happened to the old wiki page
15:08:41 <dons> ?oldwiki
15:08:41 <lambdabot> http://www.haskell.org/hawiki/
15:08:44 <dons> that one?
15:08:45 <dmhouse> dons: why didn't you just point us to the article itself? Was there something on the reddit page we were meant to read?
15:08:48 <emu> ah its still there
15:08:56 <dons> dmhouse: sorry, just had that link handy
15:09:08 <monochrom> dons like you to vote up the reddit page too
15:09:13 <nmessenger> but isn't RealWorld# just a hack?  Couldn't it be equivalent to ()?
15:09:37 <monochrom> That is an undecidable philosophical question. :D
15:09:39 <dons> nmessenger: but we could forge our own ()
15:09:48 <dons> it needs to be an unforgable state token
15:10:00 <dons> otherwise you could spawn your own runIO's
15:10:04 <dons> that weren't connected to main
15:10:15 <nmessenger> Oh goodness, many world theory!
15:10:19 <emu> i use that kind of trick to build a directly up/down linked tree
15:10:35 <nmessenger> s/world/worlds/
15:10:53 <monochrom> I think there is a real world because I enjoy the presence of all of you.
15:10:57 <dons> > runState (do return "yes" ; return "no" ; return "yes") ()
15:10:58 <lambdabot>  ("yes",())
15:11:12 <dons> there we faked our own RealWorld# as () ;)
15:11:33 <zeuxis> Does someone know why one can't export the (#) operator? [GHC 6.6: parse error on input `(#' ]
15:11:34 <esap> The programmer should be able to define his own world.
15:11:49 <xpika> what is the # operator?
15:11:54 <mauke> zeuxis: no, but does ( # ) work?
15:11:57 <dons> zeuxis: mmm. does -fglasgow-exts help or hinder?
15:11:59 <nmessenger> ?type (#)
15:12:00 <lambdabot> parse error on input `)'
15:12:12 <dons> > let f # y = f y in toUpper # 'y'
15:12:14 <lambdabot>  'Y'
15:12:26 <nmessenger> ?
15:12:30 <dons> module M ((#)) where ... -- shoudl work
15:12:55 <monochrom> GHC has special syntax (# 1, True #) for stuff.
15:13:05 <edi> dons: that loeb thing is sweet.
15:13:16 <dons> monochrom: but the unboxed tuple syntax shouldn't interfere
15:13:21 <dons> esp. if not using -fglasgow-exts
15:13:26 <syntaxfree> who is lisa loeb, by the way?
15:13:46 <zeuxis> dons: of course with -fglasgow-exts. :-)
15:14:10 <zeuxis> mauke: thx, ( # ) works
15:14:19 <dons> mm.. almost bug report worthy then
15:14:23 <monochrom> the lexer looks at (# and thinks you're going to do (#1,True#).  Then it sees ) and thinks you're nuts.
15:14:25 <zeuxis> Any reason for this?
15:14:48 <dons> (sounds like a lexing bug with the interaction between unboxed tuples , or maybe # as an extended identifier char, in -fglasgow-exts lexer)
15:14:51 <mauke> (# is a single token
15:14:52 <monochrom> I know because I'm a computer too.
15:15:11 <mauke> this is a lot like (*) in OCaml
15:15:19 <monochrom> Heh
15:16:02 <monochrom> You need a lot of lookahead to disambiguate.
15:16:03 <zeuxis> There are too few specials on the keyboard... (and in ASCII)
15:16:37 <pstickne> zeuxis, indeed.
15:16:51 <pstickne> there need to be at least one more set of bracket-things O.o
15:17:02 <monochrom> But if you do a lot of lookahead to disambiguate, someone is going to complain that "compiling a million lines of code takes two days, this is ridiculous"
15:17:48 <mauke> () [] {} <> Â«Â»
15:18:01 <emu> infinite-lookahead ftw!
15:18:05 <nmessenger> bananabrackets!  (| |)
15:18:13 * emu hugs parsec
15:18:16 <nmessenger> bananabrackets!  ([ ])
15:18:19 <reppie> ring ring ring ring bananaphone
15:18:28 <monochrom> I know what you're thinking.  You're thinking: who puts a million lines of code in one single file?  that's ridiculous.
15:18:35 <nmessenger> ([ ]) {( )}  {< >} ({ })
15:18:43 <fnord123> hello? banana residence
15:18:56 <monochrom> And I agree with you.  But one time someone on comp.lang.functional actually made that complaint about ghc.
15:19:16 <monochrom> (And of course I ridiculed him on your behalf.)
15:19:19 <emu> a million line haskell program? what was it doing? Real Artificial Intelligence?
15:19:35 * nmessenger is reminded of Real Ultimate Power
15:19:48 <emu> ghc totally flips out sometimes
15:20:09 <nmessenger> does it kill people?
15:20:11 <mauke> @ghc
15:20:11 <lambdabot>  Use -fallow-incoherent-instances
15:20:14 <zeuxis> thats easy: just write a program producing this monster ba dumping data....
15:20:18 <fnord123> parsers take a lot of code... if you want to handle a lot of different datafeeds, you will end up with lots of code quickly
15:20:19 <emu> it kills my CPU
15:20:35 <zeuxis> @ghc
15:20:35 <lambdabot>  There must be at least one non-type-variable in the instance head
15:20:37 <emu> seriously, i can't figure out why, but one of my machines goes nuts every so often while running a haskell program.
15:20:40 <edi> @slap reppie
15:20:41 * lambdabot smacks reppie about with a large trout
15:20:53 <emu> starts spitting out kernel register dumps and crap
15:20:58 <reppie> D:
15:21:09 <dons> emu: what kind of machine?
15:21:16 <dons> i've seen a panic on linux+ia64 once
15:21:19 <emu> dual-core xeon
15:21:34 <monochrom> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/e81793b08c0ff04c/9e9c9a552a7d28f6?lnk=st&q=&rnum=1#9e9c9a552a7d28f6  is how I ridiculed him.
15:21:39 <nmessenger> dons: emu was joking about Real Ultimate Power, I'd wager
15:21:39 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/yhh6j8
15:21:39 <emu> especially when running with multiple threads
15:22:00 <emu> i think one of my cores is going bad, thats all
15:22:12 <emu> or maybe its just linux being dumb
15:22:28 * nmessenger loses his wager
15:24:01 <emu> of course when i try to reproduce it, it performs beautifully
15:26:21 <Saizan> maybe it's a subtle concurrency bug
15:26:52 <emu> i'd say so, but it only happens on one machine
15:27:43 <sjanssen> getting a kernel panic means it's an OS bug, right?
15:27:57 <emu> well it isn't a "panic", it's just a series of very alarming messages.
15:28:05 <sjanssen> oh
15:29:23 <nmessenger> ?google linux kernel panic
15:29:26 <lambdabot> http://en.wikipedia.org/wiki/Linux_kernel
15:29:26 <lambdabot> Title: Linux kernel - Wikipedia, the free encyclopedia
15:29:35 <reppie> sjanssen yes, usually
15:29:49 <emu> ?url
15:29:50 <lambdabot>  @where <key>, return element associated with key
15:29:54 <emu> lisppaste2: url
15:29:54 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:30:11 <reppie> sjanssen it could also indicate hardware problems
15:30:18 <glguy> ?where wrong
15:30:18 <lambdabot> http://adrinael.net/wrong.jpg
15:30:20 <lisppaste2> emu pasted "ghc flipping out" at http://paste.lisp.org/display/33504
15:31:51 <ndm> emu: are those all errors given from GHC with the same program?
15:34:00 <shapr> SHAZAM!
15:34:33 * reppie is surprised dons has seen a ia64 machine
15:35:24 * shapr hugs dons
15:35:26 <nmessenger> *shapr turn nmessenger into a toad*
15:35:29 * sjanssen wonders whether shapr has just become Captain Marvel or Billy Batson
15:35:45 <shapr> Captain LAMBDA!
15:36:00 <nmessenger> Ribbit!
15:38:06 <fnord123> \hark.who.goes.there
15:38:34 <nmessenger> ribbit?
15:38:53 <wy> Any suggestions for a source for understanding monads?
15:40:24 <ndm> wy: monads as containers?
15:40:37 <nmessenger> ribbit.
15:40:42 <nmessenger> ?google Monad Tutorial
15:40:46 <lambdabot> http://www.nomaware.com/monads/
15:40:46 <lambdabot> Title: Nomaware | Monads
15:40:49 <wy> ndm: No idea at all. Just point me to the essentials
15:41:12 <ndm> @google haskell monads as containers
15:41:15 <lambdabot> http://swik.net/Haskell/del.icio.us+tag%2Fhaskell/Monads+as+containers+-+HaskellWiki/ry55
15:41:15 <lambdabot> Title: Haskell : del.icio.us tag/haskell : Monads as containers - HaskellWiki - SWiK
15:41:41 <reppie> si ho capito
15:41:53 <reppie> oops
15:42:02 <nmessenger> ?google You Could Have Invented Monads
15:42:04 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
15:42:04 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
15:42:08 <ndm> @google haskell monads as containers site:haskell.org
15:42:09 <lambdabot> http://haskell.org/hawiki/MonadsAsContainers
15:42:09 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
15:42:17 <edi> haha
15:42:19 <edi> hai capito?
15:44:33 <fnord123> did anyone see a post on programming.reddit.com today about using the yahoo search service in factor? something like 20 lines of code... I can't find it now.
15:52:02 <Saizan> ?source Data.Map
15:52:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
15:53:31 <Botje> ?source Windows
15:53:32 <lambdabot> Windows not available
15:53:37 <Botje> dammit :(
15:53:45 <newsham> windows closed.  come back later.
15:56:33 <Saizan> @hoogle map
15:56:34 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
15:56:34 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
15:56:34 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
15:56:49 <Saizan> @hoogle+
15:56:50 <lambdabot> Data.Map.map :: (a -> b) -> Map k a -> Map k b
15:56:50 <lambdabot> Data.Set.map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
15:56:50 <lambdabot> Data.Map :: module
15:56:55 <AStorm> Later it will be broken.
15:56:57 <AStorm> Saizan, /msg lambdabot
15:57:02 <Saizan> k
15:57:11 <dibblego> ?where exception
15:57:12 <lambdabot> I know nothing about exception.
15:57:14 <dibblego> ?where exceptions
15:57:14 <lambdabot> I know nothing about exceptions.
15:57:26 <AStorm> ?where Exception
15:57:27 <lambdabot> I know nothing about exception.
15:57:28 <Saizan> i just can't find the definition of Data.Map.map..
15:57:41 <AStorm> <lambdabot> Data.Map.map :: (a -> b) -> Map k a -> Map k b
15:58:11 <Saizan> that's the type :P well equally explanatory i presume
15:58:32 <dibblego> ?docs Data.Map.map
15:58:32 <lambdabot> Data.Map.map not available
15:59:03 <fnord123> @type main
15:59:04 <lambdabot> Not in scope: `main'
16:00:50 <mauke> @type fmap fix
16:00:52 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (a -> a) -> f a
16:02:01 <edi> nearly loeb
16:02:26 <monochrom> what is loeb?
16:02:44 <mauke> @pl loeb x = fmap (\a -> a (loeb x)) x
16:02:45 <lambdabot> loeb = fix (fmap . flip id =<<)
16:04:02 <mauke> @pl loeb x = let r = fmap (flip id r) x in r
16:04:02 <lambdabot> loeb = fix . flip (fmap . flip id)
16:04:23 <edi> I was trying to deduce it, yarr.
16:05:28 <edi> monochrom: check out sigfpe's blog. This last entry is pretty nice. #haskell told me double-linked lists were a silly thing to do in Haskell, last time I asked, sigh.
16:05:42 <newsham> > const (Just 1) fix
16:05:45 <lambdabot>  Just 1
16:06:09 <mauke> well, as long as you don't need to change them
16:06:48 <edi> Yo, yaxu.
16:06:57 <yaxu> hey edi
16:07:11 <nmessenger> Ribbit.
16:08:33 <newsham> > Just 1 `liftM2 (+)` Just 2
16:08:33 <lambdabot>  Parse error
16:08:43 <mauke> yeah, you can't do that in haskell
16:08:52 <hyrax42> ?type Data.Map.lookup
16:08:53 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
16:09:11 <hyrax42> ?type Data.Map.insert
16:09:12 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
16:10:15 <newsham> > let (+) = liftM2 (+) in Just 1 + Just 2
16:10:16 <lambdabot>    Occurs check: cannot construct the infinite type: a1 = m a1
16:10:16 <lambdabot>    Expect...
16:10:28 <MarcWeber> Any idea whats going on here?
16:10:41 <mauke> recursion
16:10:44 <edi> Where?
16:10:45 <nmessenger> let plus = (+) in let (+) = liftM2 plus in Just 1 + Just 2
16:10:52 <MarcWeber> $ ghc -o setup --make -package Cabal-0.1.7 setup.hs
16:10:52 <MarcWeber> Linking setup ... \n ghc-6.5.20060917: unknown package: Cabal-1.1.7
16:10:58 <nmessenger> >let plus = (+) in let (+) = liftM2 plus in Just 1 + Just 2
16:11:13 <nmessenger> > let plus = (+) in let (+) = liftM2 plus in Just 1 + Just 2
16:11:15 <lambdabot>  Just 3
16:11:24 <MarcWeber> edi: I'm requesting 0.1.7 and ghc complains about 1.1.7 ...
16:11:32 <nmessenger> Haskell's let is ML's letrec
16:11:49 <edi> MarcWeber: does it work without --make?
16:12:19 <MarcWeber> edi: Then I'm getting many undefined references when linking
16:12:27 <monochrom> Cool, loeb is a general fix.
16:12:44 <nmessenger> loeb looks brain-breaky
16:13:08 <edi> MarcWeber: undefined references to?
16:13:24 * shapr boings cheerfully
16:13:39 <reppie> ops
16:13:45 * nmessenger realizes that he is still a toad.
16:13:48 <MarcWeber> edi: http://rafb.net/p/xANECJ55.html
16:13:49 <lambdabot> Title: Nopaste - No description
16:13:54 * shapr turns nmessenger into CAPTAIN LAMBDA
16:14:18 <nmessenger> To ETA REDUCE wrongs and BETA SUBSTITUTE injustice!
16:14:21 <newsham> hi shapr
16:14:22 <shapr> yes!
16:14:26 <shapr> hiya newsham, how's code?
16:14:27 <edi> MarcWeber: ouhm.
16:14:41 <newsham> no code.. been on vacation goofing off...
16:14:47 <shapr> Yeah, me too.
16:14:50 <shapr> I bought unicycle goodies.
16:15:13 <newsham> got some good surf yesterday but hurt my hand
16:15:16 <MarcWeber> edi: I'm working on running multiple preprocessors. That's why I've taken the latest cabal version and given it 0.1.7 instead of 1.1.7 to not let my experimental version be used on different projects..
16:15:17 <newsham> mostly been watching movies.
16:15:36 <shapr> I hung out with my family. They all think it's freaky to ride a unicycle.
16:15:53 <newsham> i learned to ride one a little when i was younger..  fun
16:16:05 <shapr> You should try my 26" wheel with the 3.7" tire.
16:16:08 <newsham> but always banged my ankles up against the pedal bars.
16:16:13 <MarcWeber> edi: But I can't see why --make forces ghc to look for 1.1.7. ghc describe Cabal shows 0.1.7. It's the only Cabal package beeing registered
16:16:26 <newsham> where i grew up we wore slippers and barefeet :)
16:16:32 <shapr> wow
16:16:36 <edi> MarcWeber: I'm not sure, maybe you can tell the linker to use the other version with some other option
16:16:38 <shapr> Where did you grow up?
16:16:43 <newsham> unicycle probably not meant for bare feet :)
16:16:49 <MarcWeber> edi: There is no other version.
16:17:01 <shapr> newsham: Move this to #haskell-blah?
16:17:03 <edi> MarcWeber: try asking the mailing lists
16:17:04 <fnord123> @type map
16:17:05 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
16:17:07 <fnord123> @type foldl
16:17:08 <newsham> http://www.google.com/maps?f=q&hl=en&q=96717&ie=UTF8&z=13&om=1&iwloc=addr
16:17:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:17:10 <lambdabot> Title: Google Maps, http://tinyurl.com/ylgelr
16:17:10 <MarcWeber> edi: I will. Thanks
16:17:22 <edi> Sorry. I don't know what's going on.
16:17:37 <fnord123> why are map and foldl transposes wrt a and b?
16:18:34 <hyrax42> fnord123: how do you mean?
16:19:21 <monochrom> map and foldl are not related
16:19:34 <hyrax42> ?type foldr
16:19:35 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
16:20:56 <glguy> fnord123: because foldl carries the accumulator across from the left
16:21:02 <glguy> and foldr carries it from the right
16:21:14 <Lrrr> Is there a way to make Haskell mode indent if/then in a smarter way?
16:21:16 <hyrax42> glguy: he wasn't asking about foldr/foldl though
16:21:27 <monochrom> Lrrr: not really
16:21:29 <glguy> hyrax42: well, that's why foldl is the way it is
16:21:36 <glguy> hyrax42: not because it has anything to do with map
16:21:44 <hyrax42> yea
16:22:18 <fnord123> it's related in the sense that it's a higher order traversal function (at least my mental model calls it 'traversal')
16:22:36 <hyrax42> yes, but different
16:22:45 <TSC> Lrrr: use case ... of (:
16:22:49 <hyrax42> foldr is more general than map
16:23:06 <Lrrr> TSC: I'll consider that
16:23:13 <Lrrr> Next question.
16:23:28 <Lrrr> what's Prelude.readIO: no parse?
16:23:37 <monochrom> I love and hate associative memory.
16:23:47 <newsham> > read "3" :: String
16:23:48 <lambdabot>  Exception: Prelude.read: no parse
16:23:54 <yaxu> shapr: i did a 200km overnight cycle ride last summer, there were people doing that on unicycles...  they managed about half before giving up i think
16:23:57 <newsham> when you "read" something that isnt the right format string...
16:24:00 <newsham> you get "no parse"
16:24:03 <shapr> yaxu: Cool, which ride?
16:24:18 <yaxu> shapr: dunwich dynamo
16:24:25 <Lrrr> okay, so, for example, in what format does something has to be to be read correctly by readLn?
16:24:40 <glguy> > read "\"3\"" :: String
16:24:42 <lambdabot>  "3"
16:24:53 <glguy> > read "3" :: Int
16:24:55 <lambdabot>  3
16:24:56 <hyrax42> fnord123: map f = foldr ((:).f) []
16:24:56 <Lrrr> ah
16:25:05 <nmessenger> Lrrr: it depends on what type it's used for.  e.g.:
16:25:07 <nmessenger> > read "1" + 5
16:25:07 <glguy> Lrrr: if you just want a String, use getLine
16:25:08 <lambdabot>  6
16:25:12 <glguy> > getLine
16:25:14 <lambdabot>  <IO [Char]>
16:25:31 <Lrrr> aaah
16:25:33 <Lrrr> yeah I see now
16:25:39 <hyrax42> ?pl foldr ((:).f) []
16:25:39 <lambdabot> foldr ((:) . f) []
16:25:52 <glguy> readLn = readIO =<< getLine
16:25:52 <hyrax42> ?pl \f -> foldr ((:).f) []
16:25:53 <lambdabot> flip foldr [] . ((:) .)
16:26:19 <yaxu> shapr: a nice ride from london to the east coast
16:27:34 <shapr> yaxu: rec.sports.unicycling has a nice report on that - http://www.unicyclist.com/forums/showthread.php?t=51006&highlight=dunwich
16:27:36 <lambdabot> http://tinyurl.com/y2al6s
16:29:00 <nmessenger> question: is there some function like withArgs and withProgName that allow you to specify a stream for stdin?
16:29:33 <glguy> like interact?
16:29:41 <glguy> or getContents?
16:29:42 <nmessenger> like, (withStdin "foo" (getLine)) == IO "foo"
16:29:51 <nmessenger> ?type interact
16:29:53 <lambdabot> (String -> String) -> IO ()
16:29:58 <glguy> OH
16:30:02 <glguy> i see
16:30:49 <yaxu> shapr: 80 miles on a unicycle at night isn't bad
16:30:49 <LoganCapaldo> ?type withArgs
16:30:51 <lambdabot> Not in scope: `withArgs'
16:31:01 <nmessenger> ?index withArgs
16:31:01 <lambdabot> System.Environment
16:31:13 <nmessenger> ?type System.Environment.withArgs
16:31:14 <lambdabot> forall a. [String] -> IO a -> IO a
16:31:22 <Saizan> is possible to open Stdin in write mode?
16:31:40 <nmessenger> Saizan: sounds like a blasphemous sin
16:32:01 <Saizan> but it's what you are asking for, isn't it?
16:32:05 <allbery_b> you'd be surprised.  but, well, I'd want to have a good reason
16:32:41 <nmessenger> not exactly, I'm asking for a way to redirect stdin to some blob of pure stuff
16:34:04 <shapr> yaxu: I bought myself a trial size packet of chamois butt'r, I've never been able to ride more than four hours without serious pain.
16:34:12 <nmessenger> my goal was to find a way to demonstrate IO stuff using LB
16:34:41 <nmessenger> reasonably safely
16:35:31 <shapr> I'd like to do long rides, but my body shape is more like a linebacker and less like a triathlete.
16:36:40 <LoganCapaldo> A good way to do that I think would be to have a SIO (Simulated IO) type and reimplement getLine, etc. in terms of that
16:37:13 <LoganCapaldo> (withStdin "foo" (getLine)) :: SIO String
16:37:29 <nmessenger> RWST?
16:37:43 <Saizan> or spawn a child process which writes to your stdin
16:37:51 <glguy> ew
16:38:26 * nmessenger has not used any state monads yet
16:38:49 <nmessenger> (besides IO, obviously)
16:39:19 <hyrax42> ?docs System.Environment
16:39:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
16:40:23 <nmessenger> I've used (withArgs ["foo", "bar"] main) before.  'Tis nice
16:40:48 <hyrax42> what purpose
16:40:55 <nmessenger> ghci testing
16:41:05 <hyrax42> hm
16:41:19 <hyrax42> interesting
16:41:23 <hyrax42> well off I go
16:41:24 <nmessenger> rather, testing my program via ghci
16:41:41 <hyrax42> ohhh I see it now
16:41:46 <hyrax42> at ghci prompt
16:42:01 <hyrax42> withArgs [..] MyProg.main
16:42:03 <hyrax42> ?
16:42:03 * nmessenger hearts ghci
16:45:31 <ndm> use :main instead
16:45:33 <ndm> much much easier
16:45:40 <ndm> i added this to Hugs for that very reason!
16:46:01 <ndm> and i think it was in for GHC 6.6
16:46:46 <nmessenger> yeah, I forgot about :main
16:49:36 <nmessenger> does :main do backslash-escaping?
16:51:42 <nmessenger> It seems naive. I tried ':main ..\\false\\rev.f' but it seemed to parse the \r as a return.  I used slashes and it worked.
16:51:54 <ndm> no idea, i think the Hugs one does
16:53:34 * nmessenger 's full name is Nick D. Messenger.  The same initials as ndm!
16:54:01 * ndm 's full name is Neil David Mitchell
16:54:20 * nmessenger 's middle name is Deo, a nonce word.
16:54:51 <nmessenger> My mom musta been crazy
16:55:01 <LPhas> darcs get http://phas.altervista.org/hid3 <- library for reading id3 tags :D
16:56:29 <nmessenger> irc should have a /my which translates to nickname's
16:56:58 <AStorm>  /me is CTCP ACTION
16:57:59 * nmessenger is an IRC noob
16:58:37 <LPhas> http://phas.altervista.org/hid-0.8.tar.gz <- tgz version :D
17:04:30 <fnord123> ?case
17:04:30 <lambdabot> Maybe you meant: ask paste
17:09:24 <fnord123> @type catA
17:09:25 <lambdabot> Not in scope: `catA'
17:11:53 <nmessenger> ?index catA
17:11:53 <lambdabot> bzzt
17:12:13 <edi> Text.XML.HXT.ArrowList.catA I think
17:12:16 <monochrom> catA is in the HXT package.
17:12:52 <monochrom> Control.Arrow.ArrowList
17:13:48 <nmessenger> ?type Control.Arrow.ArrowList.catA
17:13:50 <lambdabot> Couldn't find qualified module.
17:14:16 <monochrom> catA = foldl (<+>) zeroArrow
17:14:23 <monochrom> hope that helps
17:14:50 <monochrom> lambdabot doesn't know stuff from the hxt package
17:14:51 <fnord123> yea
17:15:49 <monochrom> but foldl (<+>) zeroArrow uses things from ghc, so I it helps.  example: catA [x,y,z] = x <+> y <+> z
17:16:10 <nmessenger> ?type foldl (<+>) zeroArrow
17:16:12 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => [a b c] -> a b c
17:17:30 <nmessenger> ?type (<+>)
17:17:31 <lambdabot> forall (a :: * -> * -> *) c b. (ArrowPlus a) => a b c -> a b c -> a b c
17:18:18 <nmessenger> > (negate <+> (+1)) 5
17:18:18 <lambdabot>  add an instance declaration for (ArrowPlus (->))
17:18:19 <lambdabot>   In the definition of `...
17:19:39 <monochrom> That doesn't fly.
17:19:50 <nmessenger> lambdabot already told me that
17:20:07 <monochrom> Please don't shoot the message copier. :)
17:20:14 <edi> *bang*
17:20:19 * nmessenger shoots monochrom
17:21:16 * nmessenger misses, monochrom is still alive
17:22:29 <nmessenger> ?instances ArrowPlus
17:22:30 <lambdabot> Kleisli m
17:23:37 <monochrom> There is a way to embed "a -> [b]" as an arrow.  The resulting type is "Kleisli [] a b" if I get the syntax right.  To convert it back to "a -> [b]" you can use the runKleisli function.  To lift "negate" and "(+1)" to the level of this arrow, you can use "pure negate" and "pure (+1)"
17:24:01 <LPhas> ?seen dons
17:24:02 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 2m 45s ago.
17:24:05 <LPhas> uh?
17:24:13 <LPhas> ?karma me
17:24:14 <lambdabot> me has a karma of 0
17:24:21 <LPhas> ?slap edi
17:24:22 * lambdabot smacks edi about with a large trout
17:24:23 <monochrom> > runKleisli (pure negate <+> pure (+1)) 5 :: [Int]
17:24:24 <lambdabot>  [-5,6]
17:24:28 <LPhas> ehi, are you alive?
17:24:42 <edi> ye?
17:24:43 <nmessenger> ?type pure
17:24:44 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
17:24:46 <edi> @localtime reppie
17:24:48 <lambdabot> Local time for reppie is Wed Dec 27 17:19:11 2006
17:25:06 <monochrom> "a->b" can be made an arrow, but not arrowplus, so <+> doesn't fly.
17:25:31 <nmessenger> what, is dumb-person terms, does <+> do?
17:25:35 <LPhas> @localtime LPhas
17:25:37 <lambdabot> Local time for LPhas is 2006-12-28 02:19:58 +0100
17:25:58 <monochrom> Do you already know monadplus?
17:26:07 <nmessenger> Vaguely
17:26:22 <fnord123> <+> is confusing the absolute hell out of me
17:26:54 <monochrom> <+> for arrows is like mplus for monads
17:27:06 <nmessenger> ?type mplus
17:27:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:27:22 <monochrom> if m is [] there, mplus is ++
17:27:27 <nmessenger> > mplus [1] [2]
17:27:28 <lambdabot>  [1,2]
17:27:32 <nmessenger> > mplus [1] [2,3,4]
17:27:34 <lambdabot>  [1,2,3,4]
17:27:48 <nmessenger> > mplus (Just 1) (Just 2)
17:27:49 <lambdabot>  Just 1
17:28:16 <nmessenger> > mzero :: Maybe Int
17:28:16 <monochrom> So <+> for "a->[b]" is just an arrow way for saying "I want to ++ the return values"
17:28:17 <lambdabot>  Nothing
17:28:18 <fnord123> >mplus 1 2
17:28:23 <fnord123> > mplus 1 2
17:28:23 <lambdabot>  add an instance declaration for (Num (m a))
17:28:51 <fnord123> how can i ask what types are declared for MonadPlus?
17:29:01 <mauke> @instances MonadPlus
17:29:02 <nmessenger> ?instances MonadPlus
17:29:02 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:29:03 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:29:10 <monochrom> You have seen runKleisli (pure negate <+> pure (+1)) 5 :: [Int].  You should also try runKleisli (pure negate <+> pure (+1)) 5 :: Maybe Int.  You get the same behaviour as mplus for Maybe.
17:29:11 <nmessenger> monochrom: kind sorta like join?
17:29:19 <monochrom> No, not like join.
17:30:07 <nmessenger> join [[1,2],[3]]
17:30:12 <nmessenger> > join [[1,2],[3]]
17:30:14 <lambdabot>  [1,2,3]
17:30:49 <AStorm> Hmm, designing electric appliances using Arrows sounds like fun :>
17:31:15 <nmessenger> > runKleisli (pure negate <+> pure (+1)) 5 :: Maybe Int
17:31:16 <lambdabot>  Just (-5)
17:31:21 <monochrom> arrows are a dataflow language.  electric appliances are also dataflow thingies.  Yes.
17:31:24 <fnord123> > foldl join [1, 2, 3, 4] ","
17:31:25 <lambdabot>    Occurs check: cannot construct the infinite type: a = b -> b -> a
17:31:25 <lambdabot>    ...
17:32:00 <nmessenger> fnord: parens? I'm not quite sure what you're doing there.
17:32:34 <AStorm> Uh? intersperse maybe?
17:32:40 <AStorm> ?type intersperse
17:32:42 <mauke> > join (intersperse "," (map show [1..4]))
17:32:42 <lambdabot> forall a. a -> [a] -> [a]
17:32:43 <lambdabot>  "1,2,3,4"
17:32:45 <fnord123> foldl ++ ["1", "2", "3", "4"] ","
17:32:57 <fnord123> yeah, that.
17:33:11 <fnord123> > foldl ++ ["1", "2", "3", "4"] ","
17:33:11 <lambdabot>    Expecting a function type, but found `[a]'
17:33:11 <lambdabot>    Expected type: [a]
17:33:11 <lambdabot>   ...
17:33:17 <nmessenger> (++)
17:33:26 <fnord123> > foldl (++) ["1", "2", "3", "4"] ","
17:33:27 <lambdabot>  Couldn't match `[[Char]]' against `Char'
17:33:28 <monochrom> (+_+)   :D
17:33:39 <AStorm> ?type (+_+)
17:33:41 <lambdabot> parse error on input `)'
17:33:46 <mauke> > foldl (++) "," ["1","2","3","4"]
17:33:47 <lambdabot>  ",1234"
17:33:50 <AStorm> No operator for you ;-)
17:33:50 <nmessenger> yay!  ascii face operators!
17:34:24 <monochrom> Haskell is a smiley language
17:34:34 <nmessenger> "," is the first thingie, and the rest of the list is catted (++) together
17:34:40 <AStorm> ((.)$(.)) ;-)
17:34:52 <monochrom> let p=[1,2,3] in (:p) 0
17:34:52 <nmessenger> bow-chicka-wow wow
17:34:55 <fnord123> @lib join
17:34:55 <lambdabot> Maybe you meant: id let list
17:35:02 <fnord123> @where join
17:35:02 <lambdabot> I know nothing about join.
17:35:08 <AStorm> @docs join
17:35:09 <lambdabot> join not available
17:35:14 <nmessenger>  ?index maybe?
17:35:15 <AStorm> Uh?
17:35:15 <nornagon> ?hoogle join
17:35:16 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
17:35:16 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
17:35:16 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
17:35:20 <fnord123> where is join defined? ghci doesn't like it
17:35:20 <mauke> @. pl . djinn type ((.)$(.))
17:35:22 <lambdabot> f = ((.) .)
17:35:28 <allbery_b> /\*/\ :)
17:35:33 <mauke> Control.Monad.something
17:35:33 <monochrom> perl is a poison to the mind.  you can't learn perl and then bring the vocabulary over to haskell.
17:35:40 <allbery_b> ?index join
17:35:40 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:35:52 <nmessenger> ?let (^.^) = 1 / 0
17:35:53 <lambdabot> Defined.
17:36:06 <AStorm> ;-)
17:36:11 <AStorm> Actually, undefined.
17:36:35 <monochrom> In particular you are looking for intersperse, not join.  But AStorm said that already.
17:37:01 <nmessenger> @pl \sep -> concat . intersperse sep
17:37:01 <AStorm> Well, intersperse is not all that nice, it's per character.
17:37:02 <lambdabot> (join .) . intersperse
17:37:21 <AStorm> He's probably looking for something like ','.join() in Python
17:37:47 <mauke> > (join .) . intersperse $ ", " ["foo","bar","baz"]
17:37:48 <lambdabot>    The function `", "' is applied to one arguments,
17:37:48 <lambdabot>   but its type `[Char...
17:37:57 <mauke> yeah, right
17:38:08 <nmessenger> ?
17:38:15 <monochrom> $ is evil
17:38:22 <mauke> > ((join .) . intersperse) ", " ["foo","bar","baz"]
17:38:24 <lambdabot>  "foo, bar, baz"
17:38:25 <monochrom> $ is the root of all evil
17:38:30 <AStorm> $ is nice when used correctly. :>
17:38:33 <fnord123> hm, so how do i get ghci to import Control.Monad? I'm trying :add and it says it's a package module... doesn't suggest why that's wrong/ :(
17:38:40 <AStorm> I still miss the â¬
17:38:42 * nmessenger laughs at monochrom's joke
17:38:45 <AStorm> Stupid ; taking its place :P
17:38:47 <monochrom> :module +Control.Monad
17:38:53 <nornagon> :t intersperse
17:38:54 <lambdabot> forall a. a -> [a] -> [a]
17:39:22 <nornagon> > intersperse "," ["1", "2"]
17:39:23 <fnord123> @index intersperse
17:39:24 <lambdabot>  ["1",",","2"]
17:39:24 <lambdabot> Data.List
17:39:43 <AStorm> Fun, eh?
17:39:44 <monochrom> The strategy here is to go first from ["foo","bar","baz"] to ["foo",",","bar",",","baz"], and then concat.
17:39:54 <AStorm> Add some toString also :>
17:40:11 <nmessenger> also, but less sexy, (init . unlines)
17:40:11 <AStorm> I meant show
17:40:25 <nmessenger> (er, for sep == "\n")
17:40:32 * monochrom beats up AStorm for toString
17:40:41 <nmessenger> (and lines maybe?)
17:40:59 <mauke> > join (++) "ha"
17:41:01 <lambdabot>  "haha"
17:41:11 <nmessenger> cycle "ha"
17:41:11 <AStorm> Damned Pascal caught up with me :p
17:41:14 <nmessenger> > cycle "ha"
17:41:15 <lambdabot>  "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
17:41:38 <mauke> > bicycle "h" "a"
17:41:39 <lambdabot>  Not in scope: `bicycle'
17:42:09 <nmessenger> ?let bicycle xs ys = cycle (xs ++ ys)
17:42:10 <lambdabot> Defined.
17:42:20 <allbery_b> unicycle? :)
17:42:31 <nmessenger> ?let unicycle = cycle
17:42:32 <lambdabot> Defined.
17:42:33 <AStorm> > ((join .) . (intersperse ", ") . show) [1, 2, 3]
17:42:34 <lambdabot>  Couldn't match `[Char]' against `Char'
17:42:39 <AStorm> Hmm.
17:42:46 <edi> You are always playing.
17:43:23 <nmessenger> > (^.^)
17:43:24 <lambdabot>  Not in scope: `^.^'
17:43:28 <nmessenger> > (L.^.^)
17:43:29 <lambdabot>  Infinity
17:43:37 <nmessenger> not as awesome
17:43:52 <AStorm> (|^.^|) is a nicer operator :P
17:44:02 <nmessenger> ?undefine (^.^)
17:44:03 <lambdabot> Undefined.
17:44:17 <mauke> ?redefine (^.^)
17:44:18 <lambdabot> Maybe you meant: define undefine
17:44:53 <nmessenger> ?reundefine (^.^)
17:44:54 <lambdabot> Undefined.
17:45:16 <monochrom> reununreunrereundefine
17:45:22 <edi> @ L.oL
17:45:35 <monochrom> that's smart!
17:45:47 <nmessenger> ?let oL = 1 / 0
17:45:47 <lambdabot> <local>:2:0:     Multiple declarations of `L.oL'     Declared at: <local>:1:0...
17:45:55 <nmessenger> already there?
17:46:03 <monochrom> > L.oL
17:46:04 <lambdabot>  "lol"
17:46:25 <monochrom> someone was there before us!
17:46:29 <nmessenger> ?definitions
17:46:29 <lambdabot> ["Arrow"]
17:46:29 <lambdabot> ["B","Branch"]
17:46:29 <lambdabot> ["C","Cons"]
17:46:29 <lambdabot> ["False","Forall"]
17:46:29 <lambdabot> ["I"]
17:46:31 <lambdabot> [36 @more lines]
17:47:13 <nmessenger> ?let OL = 1 / 0
17:47:17 <lambdabot> <local>:2:0: Not in scope: data constructor `OL'
17:47:26 <nmessenger> darn syntax!
17:47:47 <mauke> > let 1 / 0 = "lol" in 1 / 0
17:47:55 <lambdabot>  "lol"
17:47:58 <nmessenger> lol
17:48:20 <nmessenger> ?let x / 0 = "lol"
17:48:21 <lambdabot> Defined.
17:48:38 <nmessenger> > 294723948723 L./ 0
17:48:39 <lambdabot>  "lol"
17:48:49 <edi> > iterate (++"ol") "lol"
17:48:55 <lambdabot>  ["lol","lolol","lololol","lolololol","lololololol","lolololololol","lolololo...
17:49:07 <dibblego> ?where filepath
17:49:08 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
17:49:08 * nmessenger laughs aloud
17:49:32 <nmessenger> > 'l' : cycle "ol"
17:49:34 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
17:49:52 <edi> > 0 L./ 0
17:49:54 <lambdabot>  "Nullity!!111"
17:49:58 * edi ducks
17:50:03 <AStorm> > ((join .) . (intersperse ",") . (map show)) [1, 2, 3]
17:50:04 <lambdabot>  Couldn't match `a1 -> m (m a)' against `[[Char]]'
17:50:05 * nmessenger swings
17:50:09 <AStorm> How does one fix that? :P
17:50:16 <fnord123> @seen Cale
17:50:16 <lambdabot> Cale is in #ghc, #haskell and #oasis. I last heard Cale speak 4h 44m 55s ago.
17:50:29 <mauke> > (join . intersperse "," . map show) [1,2,3]
17:50:31 <lambdabot>  "1,2,3"
17:50:32 <edi> > (join . (intersperse ",") . map show
17:50:33 <lambdabot>  Parse error
17:50:35 <edi> grr.
17:50:39 <AStorm> Blah me :P
17:50:54 <AStorm> Too many points.
17:51:01 <fnord123> monochrom: you seemed to recognize catA was from HXT. Are you familiar with the library? I'm trying to debug something
17:51:14 <monochrom> I am familiar with hxt.
17:51:18 <mauke> no, it's totally pointless
17:51:36 <AStorm> pointfree you mean
17:51:45 <monochrom> he's saying (join .) has a spurrious .
17:51:55 <mauke> that too
17:52:01 <AStorm> @unpl (join . intersperse "," . map show)
17:52:01 <fnord123> I saw this: http://useless-factor.blogspot.com/2006/12/on-second-thought.html and was reworking Cale's RSS aggregator to handle yahoo searches.
17:52:03 <lambdabot> Title: Useless Factor: On second thought...
17:52:03 <lambdabot> (\ c -> (intersperse "," (map show c)) >>= \ g -> g)
17:52:15 <fnord123> im getting an exception raised. I'll paste it
17:52:17 <fnord123> @paste
17:52:17 <lambdabot> http://paste.lisp.org/new/haskell
17:52:20 <mauke> hahaha
17:52:52 <mauke> turning join into >>= id, nice
17:53:03 <lisppaste2> fnord123 pasted "Exception raised" at http://paste.lisp.org/display/33507
17:54:06 <edi> hehe
17:55:14 <AStorm> How does one move that "," in pointless style? :P
17:55:20 <LPhas> ?seen dons
17:55:20 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 34m 4s ago.
17:55:47 <AStorm> f x y = (join . intersperse x . map show) y
17:55:59 <mauke> @pl f x y = (join . intersperse x . map show) y
17:56:00 <lambdabot> f = (join .) . (. map show) . intersperse
17:56:13 * fnord123 wonders if someone has a tool to dump raw xml from a http request
17:56:17 <AStorm> Hmm..... Let me ponder that for a while :P
17:56:29 <nmessenger> OMG! I THINK I UNDERSTAND IT!
17:56:48 <mgsloan> http://kawagner.blogspot.com/2006/12/my-haskell-experience.html
17:56:48 <nmessenger> see intersperse takes a seperator and produces a function...
17:56:50 <lambdabot> Title: Karsten Wagner's Blog: My Haskell experiences
17:56:53 <AStorm> Changed the order so that intersperse's attr comes first ;P
17:57:01 <AStorm> Yes.
17:57:07 <mgsloan> I mostly agree with this take on haskell
17:57:11 <nmessenger> that function has other functions composed before and after it
17:57:30 <Cale> hello fnord123
17:57:57 <fnord123> hi Cale.
17:58:49 <Cale> what's up? Looking for me?
17:59:06 <nmessenger> It's not so terribly complex, but I don't think I could come up with it.
17:59:30 <fnord123> I mentioned you since I was extending your RSS example to do Yahoo searches and print the results.
18:00:04 <Cale> ah, cool
18:00:41 <AStorm> I wonder why Haskeleers tend to use such non-descriptive variable names :P
18:00:52 <AStorm> f w x y z a b c d e g ...
18:01:05 <Cale> Because often there's no better name which could be given.
18:01:11 <mgsloan> math influence
18:01:16 <nmessenger> well, if it truly could be *anything*, then there *is* no better name
18:01:19 <Cale> and yes, mathematical influence
18:01:30 <tautologico> @quote help
18:01:31 <lambdabot> help hasn't said anything memorable
18:01:35 <mauke> f like whatever dude = ...
18:01:46 <nornagon> heh
18:01:51 <nmessenger> hah hah
18:01:54 <dons> if you've got lots of local scope, even functions can have simple names :)
18:02:04 <AStorm> I mean some take that math influence much too far.
18:02:09 <nmessenger> ?quote @quote
18:02:10 <lambdabot>  @quote hasn't said anything memorable
18:02:11 <Cale> pair x y = (x,y) or makePair firstElement secondElement (firstElement, secondElement) ?
18:02:13 <nmessenger> ?quote quote
18:02:13 <lambdabot> quote hasn't said anything memorable
18:02:18 <Cale> er
18:02:19 <ray> ?quote ray
18:02:20 <lambdabot> ray hasn't said anything memorable
18:02:23 <Cale> pair x y = (x,y) or makePair firstElement secondElement = (firstElement, secondElement)
18:02:25 <ray> damn right i haven't!
18:02:26 <Philippa> yeah. I should probably at least comment what the 1 letter names mean when they're mnemonic
18:02:27 <tautologico> @quote lambdabot
18:02:27 <lambdabot>  i 4M THe cooLES+ bo+ e\/eR
18:02:30 <nmessenger> ?remember quote quote hasn't said anything memorable
18:02:56 <Philippa> I do find they're useful for encouraging the reader to read structure though - the identifiers aren't so much more prominent than the parens and so forth that way
18:02:59 <AStorm> nmessenger likes infinite recursion too much
18:02:59 <mgsloan> well, in my opinion, ideally parameters would be anonymous
18:03:11 <AStorm> mgsloan, that's pointless ;P
18:03:12 <Cale> 1 letter names are clearer when you're looking at structural transformation, and you haven't attached particular interpretations to the variables apart from their structural significance.
18:03:14 <monochrom> fnord123: does yahoo reply in xml?
18:03:24 <fnord123> monochrom: yes
18:03:25 <nmessenger> AStorm: I prefer paradox based on use-mention
18:03:29 <mgsloan> AStorm - nah, not when you're working on a visual language :)
18:03:43 <nmessenger> ?quote quote
18:03:44 <AStorm> I was talking like @pl
18:03:44 <lambdabot>  quote hasn't said anything memorable
18:03:48 <mauke> pair = (,)
18:03:53 <mgsloan> oh, good point
18:04:27 <mgsloan> yeah, i think pl form is a result of wanting anonymous parameters
18:04:43 <nmessenger> mgsloan: annonymous params = point-free style
18:04:56 <nmessenger> oops didn't see that there
18:05:43 <mgsloan> alot of times you will want to name a variable the same as its type as well
18:06:10 <nmessenger> MGSLOAN HAS COMMITED THE SIN OF 'ALOT'!  BURN HIM/HER!
18:06:16 <edi> mgsloan - You are indeed right. The reason why @pl is possible is because somebody found that every lambda-term can be translated in the composition of the SKI calculus combinators.
18:06:22 <mgsloan> lol
18:06:23 <AStorm> Haskell enforces a weird naming scheme.
18:06:31 <AStorm> IHateCamelCase :>
18:06:31 <mauke> .oO( hungarian notation: listList, numNum )
18:06:40 <nmessenger> then_use_snake_case
18:07:04 <AStorm> (doesn't work with datatypes)
18:07:08 <tautologico> @keal
18:07:09 <lambdabot> proofs are no longer sound
18:07:24 <AStorm> Typeshavetobeupcased
18:07:31 <mauke> Yeah_so_what
18:07:36 <Philippa> no, they don't
18:07:39 <Philippa> type *constructors* do
18:07:44 <Philippa> same rule as for terms :-)
18:07:44 <AStorm> Right.
18:08:06 <nmessenger> i_am_a_type_variable
18:08:15 <mgsloan> one reason I think that people don't use longer variables (I'm talking concrete not polymorphic funcs) is that it makes the function less concise - many times the function will be one line, but will have to be spread to multiple lines (or just continued for hundreds of columns) if you make the names longer
18:08:35 <nmessenger> where clause FTW
18:08:42 <AStorm> Yep.
18:08:48 <AStorm> I was going to say that.
18:08:55 <mgsloan> even then
18:09:09 <mgsloan> where clause creates even more long identifiers to keep track of
18:09:10 <Philippa> mgsloan: right, and just using a smaller font doesn't really fix it either
18:09:14 <mauke> ?queue
18:09:15 <lambdabot> hongos_malos says: Esta ingestión provoca una enfermedad mortal llamada ergotismo, que en la Edad Media era conocida como fuego de San Antonio.
18:09:17 <Philippa> conciseness = ability to hold it all in your head
18:09:24 <AStorm> f blahuseless = do something with x; where x = blahuseless :P
18:09:29 <AStorm> Something for IOHCC
18:09:54 <Philippa> using short symbols rather than fully meaningful names means getting to ignore the meaning until you choose to dereference it, I guess. Which means not having to cram as much in your head at once
18:10:15 <nmessenger> good names:
18:10:20 <nmessenger> sumBitVals bits = sum (zipWith intify (reverse bits) powersOfTwo)
18:10:30 <mauke> just use a a' a'' a''' a''''
18:10:30 <nmessenger>   where powersOfTwo = map (2^) [0..]
18:10:37 <nmessenger>         intify bit value = if bit then value else 0
18:11:04 <AStorm> Uh, too much
18:11:13 <mgsloan> yeah, that's a bit ugg
18:11:17 <AStorm> intify is just and
18:11:31 <AStorm> Ah, noes
18:11:34 <AStorm> xor
18:11:39 <AStorm> Or even or
18:11:43 <AStorm> :
18:11:48 <monochrom> fnord123: For the moment I would say I suspect the HTTP package has a problem.
18:12:07 <AStorm> ?type (or)
18:12:08 <lambdabot> [Bool] -> Bool
18:12:12 <fnord123> are you able to repro my error?
18:12:19 <AStorm> Hm.
18:12:23 <mgsloan> I'd name the func bitsToInt anyway
18:12:24 <AStorm> ?type (||)
18:12:25 <lambdabot> Bool -> Bool -> Bool
18:12:40 <mgsloan> and probably make it do general base conversions
18:12:48 <nmessenger> mgsloan: the function name comes from http://praisecurseandrecurse.blogspot.com/2006/12/from-bits-to-cells-simple-cellular.html
18:12:50 <lambdabot> Title: Praise, Curse, and Recurse: From Bits to Cells: Simple Cellular Automata in Hask ..., http://tinyurl.com/y4zydv
18:12:51 <mgsloan> nbaseToInt :)
18:13:21 <AStorm> All your base are belong to Int.
18:13:32 <monochrom> fnord123: Yes.  But mine says 155 instead of 14c.
18:13:49 <nmessenger> inify bit value = fromEnum bit * value
18:14:02 <nmessenger> ?pl \bit value -> fromEnum bit * value
18:14:02 <lambdabot> (*) . fromEnum
18:14:10 <monochrom> Oh, it various with search terms.
18:14:18 <allbery_b> ?index (.|.)
18:14:18 <lambdabot> Data.Bits, Foreign
18:14:26 <nmessenger> ((*) . fromEnum) True 8
18:14:31 <nmessenger> > ((*) . fromEnum) True 8
18:14:33 <lambdabot>  8
18:14:41 <nmessenger> > ((*) . fromEnum) False 8
18:14:42 <lambdabot>  0
18:15:32 <AStorm> @pl f x y = if x then y else 0
18:15:33 <lambdabot> f = flip flip 0 . if'
18:15:43 <nmessenger> ?type if'
18:15:45 <lambdabot> Not in scope: `if''
18:15:54 <Lrrr> can someone direct me to the best (very) introductory source on lambda calculus?
18:16:12 <lisppaste2> fnord123 annotated #33507 with "tool for debugging HTTP requests" at http://paste.lisp.org/display/33507#1
18:16:15 <mauke> sub sum_bit_vals { oct "0b" . reverse join '', map { 0 + !!$_ } @_ }
18:16:54 <AStorm> ?type (if')
18:16:56 <lambdabot> Not in scope: `if''
18:17:00 <nmessenger> Lrrr: try google "Lambda Calculus", wikipedia's is rather technical but there are others
18:17:12 <allbery_b> ?index if'
18:17:12 <lambdabot> bzzt
18:17:15 <fnord123> the http request seems to complete fine. I've annotated the post with a getter.
18:17:48 <Lrrr> nmessenger: I can find a lot of tutorials, I'd like to know if there is one that is considered a must.
18:17:57 <shapr> integral: Hey, can you set the topic of ##haskell to "try #haskell" ?
18:18:47 <tautologico> some days ago someone mentioned a paper about the relationship of java interfaces to haskell type classes... does anyone know which one is this?
18:18:51 <AStorm> > if'
18:18:52 <lambdabot>  Not in scope: `if''
18:19:04 <AStorm> Hmm, @pl generates nonexistent code :P
18:19:15 <mauke> yeah, so?
18:19:16 <AStorm> ?hoogle if
18:19:17 <lambdabot> Prelude.if :: keyword
18:19:17 <lambdabot> Foreign.C.Error.throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
18:19:17 <lambdabot> Foreign.Marshal.Error.throwIf :: (a -> Bool) -> (a -> String) -> IO a -> IO a
18:19:22 <olliej> tautologico: nope, but it fairly self explanatory
18:19:31 <AStorm> mauke, nothing at all
18:20:42 <AStorm> Well, that intify is an arrow
18:20:43 <olliej> tautologico: class Foo a where x :: a->a ; y :: a->(a,a)
18:21:40 <nmessenger> ?check (\b v -> let if' p t f = if p then t else f; f x y = if x then y else 0 in f b v == (flip flip 0 . if'))
18:21:41 <lambdabot>  add an instance declaration for (Num (Bool -> b -> b))
18:21:56 <olliej> can be represented as class Foo<a> { abstract a Dict0(a); abstract Tuple<a,a> Dict1(a); }
18:22:17 <olliej> tautologico: ^^^
18:22:33 <mgsloan> http://haskell.org/haskellwiki/OOP_vs_type_classes this compares general OOP with type classes
18:22:34 <lambdabot> Title: OOP vs type classes - HaskellWiki
18:22:53 <tautologico> olliej: yes, thanks, but I guess there was some paper
18:23:18 <olliej> tautologico: or at the extreme my thesis :D
18:23:18 <LoganCapaldo> @where ((->) e)
18:23:18 <lambdabot> I know nothing about ((->).
18:23:20 <tautologico> mgsloan: thanks
18:23:25 <nmessenger> ?check (\b v -> let if' t f p = if p then t else f; f x y = if' x y 0 in f b v == (flip flip 0 . if'))
18:23:25 <lambdabot>  add an instance declaration for (Num Bool)
18:23:31 <tautologico> olliej: what's your thesis? :)
18:23:44 <olliej> tautologico: somthing awfully long winded :D
18:24:00 <LoganCapaldo> Is there a site with some examples of ((->) e)? My googling has failed me
18:24:26 <olliej> tautologico: "implementation of functional languages on a statically typed object oriented virtual machine"
18:24:31 <olliej> tautologico: or something similar :D
18:24:32 <mauke> LoganCapaldo: huh? ((->) e) is just half a function type
18:24:41 <nmessenger> ((->) e) is a type constructor, give a type a and it results in (e -> a)
18:24:43 <tautologico> olliej: cool, do you have a link for it? :)
18:25:32 <LoganCapaldo> No I mean of using it as a monad
18:25:43 <LoganCapaldo> The other day people showed me some cool tricks with it
18:25:51 <nmessenger> me too :)
18:26:10 <olliej> tautologico: alas no -- isn't published till markers finish with it
18:26:19 <olliej> and one of the markers has dropped off the face of the planet
18:26:24 <nmessenger> Logan's looking for a site that has examples of using the ((->) e) Monad
18:26:27 <olliej> can send it to you or something...
18:26:46 <olliej> hmmm, actually i think i have a test page on google pages or something
18:27:01 <olliej> which i might be able to drop in on
18:27:04 * olliej looks
18:27:19 <olliej> ah ha
18:27:20 <olliej> build fixed
18:28:49 <olliej> oops ww
18:29:26 <nmessenger> ?check (\b v -> let if' t f p = if p then t else f; f b v = if' v 0 b in f b v == (flip flip 0 . if'))
18:29:27 <lambdabot>  add an instance declaration for (Num Bool)
18:30:44 <olliej> tautologico: http://oliverhunt.googlepages.com/thesis.pdf
18:30:53 <tautologico> olliej: so, did you focus on any extant vm like the jvm?
18:30:55 <tautologico> olliej: hey, thanks
18:31:00 <olliej> tautologico: .net :D
18:31:06 <tautologico> cool
18:31:22 <olliej> tautologico: couldn't see much point trying to enforce static type safety with generics on a vm that didn't have them :-/
18:32:01 <tautologico> yep, erasure sucks
18:32:08 <nmessenger> I can't figure out this if'
18:32:33 <olliej> tautologico: i can support *all* of haskell
18:33:06 <tautologico> I was actually thinking about exploring this possibility of implementing a graph reducer in the .net clr
18:33:15 <olliej> higher kinded types are the only place i can't get static type safety
18:34:04 <nmessenger> olliej: dude, are you writing a Haskell.NET?!
18:34:35 <olliej> nmessenger: it mostly goes, just nowhere nears clean enough to be usable in industry
18:34:47 <olliej> but everything is there should people actually have time/inclination to do so
18:35:01 * nmessenger bows down in reverence
18:35:23 <olliej> nmessenger: psh, my compiler pulls out Core from GHC
18:35:32 <olliej> so i don't need to do type inference :D
18:35:57 <nmessenger> I see.  Still... *reverence*
18:36:26 <tautologico> a basic H-M type inferencer isn't hard :)
18:37:51 <nmessenger> ?spell inferer
18:37:51 <lambdabot> inferior inferred Onfre unfairer infer
18:38:06 * nmessenger thinks 'inferer' sounds better
18:38:18 <olliej> nmessenger: hehee
18:38:27 <olliej> tautologico: it's more places for bugs
18:38:45 <tautologico> of course
18:38:58 <olliej> tautologico: most/all the bugs in my piss poor excuse for a compiler are in the arity matching :-/
18:39:22 <tautologico> I wrote a type checker once but it covered only the basic Hindley-Milner types
18:39:32 <olliej> tautologico: anyhoo, i think one of the early chapters discusses thingy
18:39:34 <tautologico> type system
18:39:41 <olliej> data types, type classes and instances
18:39:59 <geckosenator> how do i do virtual type operations?
18:40:10 <tautologico> olliej: how did you implement non-strict evaluation?
18:40:32 <olliej> tautologico: i believe there's a chapter on it -- it's one of the "impoortant" bits of the thesis
18:40:42 <nmessenger> geckosenator: virtual as in select a method based on actual type?
18:40:47 <geckosenator> nmessenger: yeah
18:40:57 <tautologico> olliej: I know, I just wanted an executive summary :)
18:41:00 <nmessenger> geckosenator: do you know typeclasses?
18:41:00 <geckosenator> wait, it already does that right?
18:41:03 <olliej> tautologico: take standard data type mapping
18:41:07 <geckosenator> nmessenger: not well
18:41:23 <olliej> tautologico: data Bool = True | False
18:41:33 <nmessenger> ?google Haskell Typeclass Tutorial
18:41:35 <lambdabot> http://sequence.complete.org/hwn/20061128
18:41:35 <lambdabot> Title: Haskell Weekly News: November 28, 2006 | The Haskell Sequence
18:41:56 <olliej> you end up with class Bool, class True : Bool, class False : Bool, and class Thunk : Bool
18:42:09 <geckosenator> thunk?
18:42:27 <olliej> geckosenator: talking to tautologico so you're safe :D
18:43:19 <tautologico> olliej: well, I will read the chapter :) thanks
18:43:27 <olliej> tautologico: True/False subclasses represent the evaluated cases, Thunk basically wraps a continuation and caches the result once evaluated
18:43:35 * nmessenger 's browser crashed, he might not have heard the last few messages
18:43:46 <olliej> (a la proxy pattern of OO-fu)
18:43:55 <tautologico> ok, I get it
18:44:05 <olliej> tautologico: there are caveats unfortunately :(
18:44:34 <olliej> namely you end up having the do the "cast" by calling "asTrue/asFalse" methods
18:45:18 <olliej> tautologico: but on the plus side it works in the general case
18:45:27 <dons> heya geckosenator
18:45:51 <geckosenator> hi
18:46:01 <dons> > printf "%d" (7 :: Int) :: String -- dispatch based on return type
18:46:03 <lambdabot>  "7"
18:46:06 <dons> > printf "%d" (7 :: Int) :: IO String -- dispatch based on return type
18:46:08 <lambdabot>  <IO [Char]>
18:46:21 <fnord123> is there a haskell stepping debugger?
18:46:22 <olliej> tautologico: i smaller paper should be published in the next 12 months that summarises the excessdively overwritten thing that is my thesis :D
18:46:23 <nmessenger> geckosenator: have you worked through "Yet Another Haskell Tutorial"
18:46:25 <dons> geckosenator: i.e. use type classes to pick a function based on its type
18:46:31 <geckosenator> nmessenger: not all of it
18:46:36 <dons> fnord123: yeah, a couple. hat seems to be the most well known
18:46:46 <dons> fnord123: check haskell.org's apps and libs page, under 'Program development'
18:47:02 <nmessenger> read "3" :: Int
18:47:06 <nmessenger> > read "3" :: Int
18:47:08 <lambdabot>  3
18:47:09 <tautologico> olliej: ok, I'll take a look at the points that interest me most
18:47:14 <nmessenger> > read "'3'" :: Char
18:47:15 <lambdabot>  '3'
18:47:26 <nmessenger> > read "\"3\"" :: String
18:47:27 <lambdabot>  "3"
18:47:42 <nmessenger> ?instances Read
18:47:43 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
18:47:50 <olliej> tautologico: :D
18:48:18 <olliej> tautologico: don't point out any errors or inconsistencies, they'll only induce stress :D
18:48:20 <nmessenger> dons: is there a ?methods Class ?
18:49:09 <tautologico> olliej: :)
18:50:06 <nmessenger> > read "\"this is not an Int\"" :: Int
18:50:07 <lambdabot>  Exception: Prelude.read: no parse
18:52:13 <tautologico> olliej: did you finish it recently?
18:53:30 <nmessenger> geckosenator: basically (and probably not precisely) a typeclass is like an interface.  It defines a bunch of functions.  Any type that wants to be an instance of that class must define those functions.
18:54:54 <olliej> tautologico: submitted at the end of june
18:55:23 <nmessenger> data ABorC = A | B | C; instance Eq ABorC where {A == A = True; B == B = True; C == C = True; _ == _ = False}
18:55:48 <olliej> tautologico: there is a saga that meant i didn't have examiners till a month or two after submission
18:56:26 <nmessenger> here, Eq is a class that contains all types whose members can be checked for equality
18:56:28 <olliej> tautologico: and my primary supervisor can't be an examiner because he was no longer employed by my uni by the time i submitted :-/
18:56:42 <tautologico> olliej: I know how it is
18:56:42 <mauke> data ABorC = A | B | C deriving (Eq)
18:56:43 <olliej> so have no clue whether it has passed
18:57:04 <nmessenger> mauke: (well yeah, but I wanted to make it explicit for teaching)
18:57:27 <tautologico> olliej: don't you have to present the thesis or something?
18:57:32 <olliej> tautologico: i can't remember who the hell the aussie that's marking it is
18:57:43 <fnord123> aha!!! I remember this bug in erlang's http module. \r\n is part of a chunked response in a http response. some crummy http libs use regex to rip out the \r\n as field delimiters, but in a chunked response, one of the newlines is doubled.
18:57:46 <fnord123> hurrrrr
18:57:48 <olliej> tautologico: masters thesis so i don't need to do a defence (at least not for nz unis)
18:57:58 <nmessenger> geckosenator: Eq contains two methods: (==) and (/=).  If you don't specify both, one is defined in terms of the other.
18:58:09 <geckosenator> right, I read about that
18:58:11 <tautologico> olliej: oh, ok. here in brazil we have to
18:58:29 <olliej> tautologico: the uk examiner got his marks back a month or so ago
18:58:39 <olliej> but i can't be told what he said till they have both
18:58:43 * olliej grumbles
18:58:58 <nmessenger> geckosenator: class Eq where {x == y = not (x /= y); x /= y = not (x == y)}
18:59:56 <tautologico> olliej: yeah, sucks... I finished my masters thesis not long ago too
19:00:26 <olliej> tautologico: which uni?
19:00:30 <nmessenger> geckosenator: you still here?
19:00:39 <geckosenator> yeah
19:01:00 <tautologico> olliej: Universidade Federal de Pernambuco, it's here in Brazil
19:01:09 <olliej> :D
19:01:38 <olliej> tautologico: i figured it was probably in brazil :D what was yours on?
19:01:45 <araujo> hola!
19:01:46 <araujo> hola!
19:01:47 <nmessenger> geckosenator: If you have a bunch of types that do similar things, you can abstract those things into a class and make each type an instance of that class
19:01:51 <olliej> yo araujo
19:01:58 <geckosenator> ok
19:02:00 <araujo> heya olliej
19:02:12 <tautologico> olliej: concurrent garbage collection for multicore processors, something like it
19:02:18 <olliej> ow
19:02:19 <araujo> what's interesting on lambda land today?
19:02:20 <olliej> the pain :D
19:02:31 <nmessenger> geckosenator: I'm still a newbie myself, so I haven't written any interesting classes yet.  They're not too hard to use, though, with practice.
19:02:38 <olliej> tautologico: moving gc?
19:03:00 <geckosenator> nmessenger: yeah, I'm learning slowly
19:03:07 <tautologico> olliej: no, I mostly worked with reference counting
19:03:26 <olliej> tautologico: ow -- fairly chunky overhead there
19:03:54 <nmessenger> geckosenator: In one thing I was writing, I found it useful to be able to add and subtract pairs of numbers as if they were numbers themselves, so I wrote this:
19:04:23 <tautologico> yep... I didn't have the time to experiment with other possible designs, so I concentrated on the communication and synchronization
19:04:35 <nmessenger> geckosenator: instance (Num a, Num b) => Num (a, b) where {(a, c) + (b, d) = (a + b, c + d); etc...}
19:05:44 <nmessenger> geckosenator: this says the following: "Given two types a and b, which are members of the Num typeclass, define the pair of a's and b's (a,b) to be an instance of Num"
19:06:41 <tautologico> olliej: I think I will change the theme for the doctorate :)
19:06:52 <olliej> hehe
19:07:11 <olliej> tautologico: i have left uni and nz now :D
19:07:39 <olliej> hurrah for earning money :D
19:07:40 <tautologico> olliej: going for a phd somewhere else?
19:07:47 <tautologico> oh, industry :)
19:07:47 <nmessenger> geckosenator: and then the implementation of all the methods of Num follow in the where clause
19:08:00 <olliej> tautologico: i'm sick of being poor for a while
19:08:12 <tautologico> olliej: yeah, it sucks
19:08:21 <olliej> tautologico: and have a great job so am happy :D
19:08:27 <tautologico> I worked for 2 years after graduation, then came back for the masters
19:08:32 <olliej> ah
19:08:41 <olliej> i did 6 years of uni straight with no breaks :D
19:08:45 <tautologico> olliej: working where?
19:08:48 <olliej> apple :D
19:08:54 <tautologico> cool :)
19:09:41 <nmessenger> geckosenator: one interesting method is fromInteger, so given 'fromInteger a = (fromInteger a, fromInteger a)' in Num (a,b)'s where clause, I could say something like (fromInteger 1 :: (Int, Int)) and it'd produce (1,1)
19:10:01 <olliej> tautologico: on the other hand that means i no longer have time to work on my compiler :-/
19:10:22 <tautologico> olliej: yeah, tradeoffs...
19:10:23 <olliej> tautologico: on the plus side that also means i've escaped some of the most horrific code ever written
19:10:32 <tautologico> olliej: lol
19:11:07 <nmessenger> geckosenator: indeed, if I use a 1 in the context of an (Int,Int) pair, it'll automatically coerce.
19:11:11 <tautologico> olliej: I wrote a compiler too, a far simpler one though, but I don't want to get near the codegen module anytime soon
19:11:45 <geckosenator> nmessenger: cool, I have to work on something completely different right now though
19:11:49 <nmessenger> geckosenator: so (5, 4) + 3 == (8, 7)
19:11:59 <nmessenger> geckosenator: okie doke
19:12:20 <olliej> tautologico: i cheated, just built a tree in CodeDOM and told .net to gen c#+compile it for me :D
19:12:40 <olliej> tautologico: once again created some costs :-/
19:15:14 <mgsloan> On the topic of classes with cyclic functions which was raised yesterday, I think Eq should have a default only for /=.
19:15:27 <olliej> tautologico: maybe i shouild put the compiler up on google code
19:15:42 <olliej> tautologico: will need to go through and put licensing stuff in it though :-/
19:15:50 <olliej> tautologico: and that seems like effort atm :D
19:15:57 <tautologico> olliej: :)
19:15:59 <nmessenger> mgsloan: but what about all the other cyclicly defined class methods?
19:16:28 <tautologico> olliej: the compiler was written in haskell, no?
19:16:33 <nmessenger> mgsloan: but what about all the other cyclicly defined class methods?
19:16:38 <nmessenger> (oops)
19:16:44 <mgsloan> well, those have to be evaluated case by case.  Most of the time I think there is a primary function which is usually the one defined
19:17:16 <olliej> tautologico: wrong :O
19:17:23 <monochrom> fnord123: there was a time I read the HTTP source code carefully and found that its chunk handling is robust...
19:17:30 <tautologico> olliej: C# ?
19:17:39 <olliej> tautologico: when i'm not especially good aat haskell, but now i wish i had wrtten it all in haskell
19:17:41 <olliej> *sigh*
19:17:45 <olliej> tautologico: yup
19:17:50 <olliej> tautologico: go C#!
19:17:51 <olliej> :D
19:17:51 <nmessenger> mgsloan: I'm hesitant to go that route, instance definition should be as free to define which and how much as they want, provided a complete definition can be derived
19:17:54 <fnord123> well ive pasted the xml im returned into a local file and loaded it from disk to my program and it works fine....
19:18:04 <monochrom> yes, me too.
19:18:16 <tautologico> olliej: lol :) I guess when you started F# wasn't quite usable, I don't know
19:18:38 <tautologico> olliej: I wrote my compiler in Haskell, was mostly a breeze except for the codegen
19:19:07 <olliej> tautologico: nope, mostly that i suck at haskell itself
19:19:18 <nmessenger> mgsloan: consider Eq [Int].  (/=) could bail out after the first mismatch.  (==) would have to evaluate each element
19:19:21 <mgsloan> nmessenger - yeah, that's probably best as far as purity ogoes
19:19:32 <olliej> tautologico: i'm still mostly useless at it -- my primary desire was to be able to use haskell trivially from other languages
19:19:33 <tautologico> olliej: I'm quite happy with F# for now... pretty similar to OCaml but on .net
19:20:04 <dibblego> tautologico, do you use F# on non-Microsoft platform?
19:20:07 <nmessenger> er wait, nvm
19:20:17 <monochrom> fnord123:  moreover, if I use HTTP myself to read the stuff (using your 33507#1 for example) and then pass the string to hxt, it works fine too.
19:20:45 <mgsloan> Eq [] can do that.  good point.
19:20:47 <tautologico> dibblego: I haven't tried it, but I do know that there are people who use it primarily on mono
19:20:48 <nmessenger> mgsloan: but some datatype could have such conditions, that (/=) is cheaper than (==)
19:20:55 <mgsloan> yeah
19:21:12 <fnord123> monochrom: http://www.erlang.org/pipermail/erlang-questions/2006-September/022697.html
19:21:15 <lambdabot> Title: [erlang-questions] Parsing RSS, http://tinyurl.com/yy437k
19:21:20 <dibblego> tautologico, I have considered giving it a good go, but I don't have Microsoft Windows or VS handy, so I figure I'll be off to a false start
19:22:01 <fnord123> better starting point: http://www.erlang.org/pipermail/erlang-questions/2006-September/022602.html
19:22:03 <nmessenger> mgsloan: removing the cyclic definitions and forcing would not be ideal.  I can conjure an example, but my gut tells me it could break some abstractions.
19:22:03 <lambdabot> Title: Parsing RSS, http://tinyurl.com/yxxkkr
19:22:15 <nmessenger> s/can/can't/
19:22:20 <mgsloan> yeah, probably
19:22:31 <tautologico> dibblego: I guess you have to jump some hoops, but it works... tuareg-mode (which is an emacs mode for ocaml, in case you don't know) has been adapted to F# by some people too
19:22:34 <fnord123> monochrom: The error I'm looking at looks like a byteorder mark in the middle of my xml response when it should be in the header. I don't see why HXT is picking it up for parsing
19:23:03 <tautologico> *through some hoope
19:23:05 <tautologico> hoops
19:23:19 <dibblego> tautologico, is there a free limited version of VS that can be used with F#?
19:24:13 <GsD_CeleborN> ghc-pkg.exe: dependency gtk-0.9.10.3 doesn't exist (use --force to override)
19:24:14 <GsD_CeleborN> make[2]: *** [install-data-hook] Error 1
19:24:17 <tautologico> tautologico: I don't think so... afaik, the express versions of VS don't work with it... but somehow the XBox XNA that comes with a VS Express version seems to work, so maybe you could use that
19:24:21 <tautologico> oops
19:24:25 <GsD_CeleborN> what is it
19:24:27 <tautologico> I meant dibblego
19:24:31 <dibblego> tautologico, thanks
19:25:03 <LoganCapaldo> @paste
19:25:03 <lambdabot> http://paste.lisp.org/new/haskell
19:25:53 <tautologico> dibblego: http://blogs.msdn.com/dsyme/archive/2006/12/12/writing-xbox-360-games-with-f-and-xna-game-studio-express-courtesy-of-jack-palevich.aspx
19:25:54 <nmessenger> (tautologico talks to him/herself.  *snicker*)
19:25:55 <lambdabot> Title: Don Syme's WebLog on F# and Other Research Projects : Writing XBox 360 games wit ..., http://tinyurl.com/ydstp4
19:26:02 <GsD_CeleborN> anyonde know
19:26:04 <GsD_CeleborN> ghc-pkg.exe: dependency gtk-0.9.10.3 doesn't exist (use --force to override)
19:26:04 <GsD_CeleborN> make[2]: *** [install-data-hook] Error 1
19:26:06 <dibblego> tautologico, ta
19:26:34 <lisppaste2> LoganCapaldo pasted "Neat, or pointless?" at http://paste.lisp.org/display/33512
19:27:04 <nmessenger> Logan: need 'neat' and 'pointless' be mutually exclusive?
19:27:13 <fnord123> s/byte order mark/incorrectly parsed HTTP/1.1 chunked
19:27:13 <fnord123> encoding response/
19:27:55 <nmessenger> though I suppose that could've been an inclusive 'or'
19:27:57 <tautologico> dibblego: and http://www.strangelights.com/fsharp/Wiki/default.aspx/FSharpWiki.MonoLinux :)
19:28:01 <lambdabot> Title: MonoLinux, http://tinyurl.com/y3p5r7
19:28:21 <dibblego> tautologico, excellent thanks
19:29:30 <dibblego> I seriously cannot work with a fish tank on my desk - it stinks
19:29:43 <dibblego> oops wrong channel
19:29:46 <tautologico> the F# people from MSR have been quite responsive to user questions and requests
19:30:14 <dibblego> tautologico, on a mailing list?
19:30:27 <tautologico> yep
19:30:51 <tautologico> I complained about some functions from Haskell not existing in F#'s standard libs, and they were added
19:31:09 <dibblego> F# is very similar to Scala in concept right?
19:31:36 <dibblego> all the functional language goodies, nice type system, with a "I'm too chicken to use monads" imperative cop-out
19:31:37 <tautologico> F# is very similar to OCaml
19:31:43 <mgsloan> it's very similar to O'Caml in appearance
19:31:44 <tautologico> yep
19:31:45 <Korollary> its ocaml on dotnet
19:31:58 <tautologico> if you ever used some ml language, especially ocaml, it's very much like it
19:32:17 <olliej> dibblego: monads in general end up requiring higher kinded types, which aren't supported on .net
19:32:31 <nmessenger> LoganCapaldo: since Cons isn't recursive, there's no way to way arbitrary length lists
19:32:42 <nmessenger> s/way to way/way to have/
19:32:42 <dibblego> olliej, they are supported in Scala (I think) which runs on the JVM
19:33:03 <mgsloan> monads in general require vast code changes going from pure to add a tiny imperative smidge
19:33:15 <tautologico> nope, in Scala you can define specific monads, like in Java, but you can't define a general Monad
19:33:22 <dibblego> oh didn't know that
19:33:33 <dibblego> was going to try it too - thanks for saving me time :)
19:33:38 <tautologico> because Scala doesn't have higher-order types
19:34:23 <nmessenger> tautologico: higher-order types are like type constructors?
19:34:35 <nmessenger> tautologico: or kinds?
19:35:45 <tautologico> higher kinded types
19:35:56 <LoganCapaldo> nmessenger: Aha, I see you are correct
19:36:17 <dons> mmm. Jaffa Cakes
19:37:05 <LoganCapaldo> I've just invented the tuple
19:37:09 <LoganCapaldo> heh
19:37:21 <nmessenger> LoganCapaldo: You can have arbitrary-length *values*, but not *types*; i.e. functions that accept arbitrary-length lists
19:37:38 <LoganCapaldo> yep
19:37:41 <LoganCapaldo> got it
19:38:03 <nmessenger> LoganCapaldo: Well I'm pretty sure *all* multiple-parameter single-constructor datatypes are analogous to tuples.
19:47:59 <fnord123> monochrom: according to HTTP.hs in the http module, the MIME & entity studd is a "todo". The "entity stuff" refers to the entity body in section 7.2 of the http 1.1 spec. readTillEmpty1 and readTillEmpty2 do exactly what I suggested: seek for a crlf pair and demark that as the header.
19:48:46 <monochrom> ok
19:49:24 <monochrom> dons, fnord123 has caught another hole in HTTP :)
19:50:44 <fnord123> is there a bugzilla or trac page I can submit a bug to? :) apart from http://homepages.paradise.net.nz/warrickg/haskell/http/#bugs
19:50:46 <lambdabot> Title: Haskell HTTP Implementation
19:51:06 <monochrom> No, but dons is collecting todo's for HTTP.
19:51:23 <fnord123> oh ok
19:51:36 <fnord123> @seen dons
19:51:36 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 15m 19s ago.
19:52:05 <monochrom> He seems to be eating Jeff Cakes now...
19:52:19 <fnord123> Jaffa Cakes?
19:54:23 * qwr found sometime a bug in HTTP that ignored most content sent by weblogic in chunked encoding
19:59:03 <qwr> shall debug, if i'm sober enough and nothing is at fire in the do-it-right-now mode ;)
20:07:38 <glguy> are there any existing Haskell editing environments where you can call a function to automatically add an explicit type definition to a function?
20:10:26 <monochrom> No. But everyone wants one.
20:11:16 <monochrom> Err actually someone has done one.  It calls ghci to load your module, then sends lots of :type queries and inserts the results to your file.
20:11:43 <monochrom> It seems to be implemented on vim.
20:12:27 <dibblego> ?paste
20:12:27 <lambdabot> http://paste.lisp.org/new/haskell
20:13:06 <dons> fnord123: yeah, i'll be taking over maintainership next week I think :)
20:13:17 <dibblego> paste seems broken
20:13:33 <fnord123> are you collecting todos for the hackathon?
20:13:38 <dons> yeah
20:13:51 <iulus> I just got here... what are you hacking?
20:14:27 <monochrom> yeah intermittently "proxy error"
20:14:46 <dibblego> http://rafb.net/p/5uFugZ38.html how do I close a file as well as keep my list around?
20:14:47 <lambdabot> Title: Nopaste - No description
20:15:41 <iulus> GHC?
20:15:47 <dons> dibblego: you need to use a strict hGetContents
20:16:01 <dons> or use readFile
20:16:07 <wy> I'm studying monads and am wondering what is IO? Isn't it a type constructor?
20:16:08 <dons> which will close automatically once it is all ready
20:16:14 <dons> wy, its a newtype, yep
20:16:21 <dons> iulus: yeah, and various libraries
20:16:22 <dibblego> I can't use readFile since I am actually doing an initial seek
20:16:30 <dons> dibblego: ok. so force eval of 'c'
20:16:38 <dons> for example, length c `seq` return ()
20:16:40 <dibblego> dons, how is that done exactly?
20:16:52 <dibblego> hm ok
20:16:58 <wy> dons: but let IO a = getChar in a doesn't work
20:17:06 <monochrom> IO is a type constructor, syntactically speaking.
20:17:15 <monochrom> It is not a data constructor.
20:17:48 <monochrom> You can write "undefined :: IO (IO (IO (Int -> [Bool])))"
20:18:15 <monochrom> How does that Snow White dwarf song go?  IO, IO, .... ?
20:18:24 <LoganCapaldo> wy: consider: data IO a = HappyGoLucky a
20:18:37 <iulus> ... it's off to bind we go ...
20:18:44 <monochrom> hahahahah!
20:18:53 <dons> dibblego: http://rafb.net/p/7l9Q6N87.html
20:18:54 <lambdabot> Title: Nopaste - readFile&#039;
20:19:02 <dons> wy, the IO type constructor is hidden
20:19:03 <dibblego> thanks dons
20:19:13 <dibblego> ?type seq
20:19:14 <lambdabot> forall b a. a -> b -> b
20:19:22 <monochrom> @remember iulus IO, IO, it's off to bind we go ...
20:19:32 <wy> dons: Can I get it out?
20:19:47 <dons> you sure you want to?
20:19:56 <dons> i.e. why not use:   x <- getChar ...
20:19:57 <wy> dons: I'm just playing with it
20:20:04 <dons> ok. its in GHC.IOBase :)
20:20:07 <dons> you have been warned ;)
20:20:25 <monochrom> what is "get it out"?
20:20:33 <wy> dons: I know what it means by hidden it. I just try once to see it's not so forced
20:20:52 <dons> for example:
20:20:55 <dons> Prelude> :m + GHC.IOBase
20:20:57 <dons> Prelude GHC.IOBase> :k IO
20:21:00 <dons> IO :: * -> *
20:21:02 <dons> Prelude GHC.IOBase> let IO c = getChar
20:21:05 <dons> Prelude GHC.IOBase> :t c
20:21:07 <dons> c :: GHC.Prim.State# GHC.Prim.RealWorld
20:21:10 <dons> -> (# GHC.Prim.State# GHC.Prim.RealWorld, Char #)
20:21:13 <dons> you still need to give  it a RealWorld# to get the value out though
20:21:34 <monochrom> May I surmise on this?
20:22:05 <monochrom> the type "Char" or even "() -> Char" means it is the same character all the time in a pure functional language.
20:22:35 <monochrom> Therefore getChar cannot take on such a type, since it is going to be a different character every time.
20:23:05 <monochrom> So the type is kind of forced to be something else.  We settled on the name "IO" for that.  So you have getChar :: IO Char.
20:23:22 <monochrom> Next you certainly want to use the characters obtained.
20:23:24 <dons> or consider:
20:23:25 <dons> Prelude GHC.IOBase> IO $ \s -> let IO f = getChar in case f s of (# t, c #) -> (# t, c #)
20:23:42 <dons> which will be handed the non-forgable RealWorld# by ghci
20:23:47 <dons> meaning it can be run
20:24:05 <LoganCapaldo> Non-forgable? Bah.
20:24:16 <dons> otherwise you'd have a runIO
20:24:19 * LoganCapaldo starts a crime syndicate to forge RealWorld#
20:24:48 <dons> so the only way you can use these IO things is in a sequential manner, since you have to thread RealWorld# tokens around
20:25:02 <monochrom> The wrong way is to ask "is there stripIO :: IO Char -> Char"?  If there were such a function, we'd be back to the problem I've just described.  getChar gives a different char everytime, but stripIO is converting it to somethat that gives the same char everytime.  Contradiction.
20:25:06 <dons> thus it can be as impure as you like, since the ordering is preserved (and the compiler knowsn it)
20:25:32 <LoganCapaldo> @hoogle IO a -> a
20:25:33 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:25:33 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
20:25:33 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
20:25:56 <monochrom> The right way is to ask: is there a way I can pass on the char to a second IO thingie so the second thingie can use it?
20:26:15 <monochrom> (A moment of thought reveals that this is all you will ever, ever need.)
20:26:33 <monochrom> And that is availed by either >>= or the do-notation.
20:27:24 <wy> So I get a (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, Char #))... What's it?
20:27:43 <dons> that's a function that when given a sequencing token (a RealWorld value)
20:27:55 <dons> returns a new sequencing token, and a result Char, in a (unboxed) tuple
20:28:16 <dons> the only way to run this thing is to get a sequencing token from somewhere, and apply it to your function
20:28:29 <monochrom> The above sermon is recorded at http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Imperative_Programming
20:28:32 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
20:28:33 <iulus> dons: even I'm confused, and I've been doing IO for a while now
20:28:51 <dons> its not so magic. IO is just sequences of:
20:29:05 <wy> But why isn't it a Char. Because I have getChar :: IO Char. And let IO a = get Char in a shoud give me Char.
20:29:07 <dons> main token = code token
20:29:20 <LoganCapaldo> wy: No it shouldn't
20:29:21 <dons> code t = case getChar t of (t', c) -> (t', c)
20:29:27 <LoganCapaldo> data Bool = True | False
20:29:35 <LoganCapaldo> let Bool a = True
20:29:39 <monochrom> As I said, that would imply the same Char everytime, which is absurd.
20:29:49 <dons> LoganCapaldo: hmm. that's not right. since Bool is a type constructor
20:29:54 <dons> IO is both a type and value constructor
20:30:10 <LoganCapaldo> Oh You can actually say IO "Hello" ?
20:30:14 <dons> that is:   IO (\tok -> (tok, ()) :: IO ()
20:30:18 <LoganCapaldo> nvm then :)
20:31:07 <dons> no, you can't say IO "hello", you could say:  IO (\t -> let IO r = putStrLn "hello" in case r t of t' -> ( t' , () ) -- :-)
20:31:15 <monochrom> My understanding of dons's is that even if you are allowed to deconstruct IO, you should get a function that depends on system state, not a fixed value.
20:31:20 <dons> yay for monadic plumbing
20:31:23 <tautologico> I suspect wy's doubt is far more basic than the innards of IO implementation in ghc
20:31:29 <dons> monochrom: exactly
20:31:42 <dons> wy, so do you just want to do:
20:31:49 <dons> main = do x <- getChar ; putChar x -- ?
20:32:05 <dons> which is how we do monadic IO. the <- syntax takes apart the IO, giving you a result in 'x'
20:32:05 <monochrom> I think my sermon is clear and convincing enough for all logical ladies and gentlemen alike.
20:32:35 <wy> dons: No. I know I can do it. I just want to verify this thing is theoretically correct
20:32:42 <dons> ok good :)
20:32:55 <dons> does the threaded state token stuff make sense?
20:33:20 <wy> Not yet. It's not Char..
20:33:26 <glguy> is there a way to detect undefined?
20:33:32 <monochrom> No.
20:33:38 <tautologico> halting problem?
20:33:43 <tautologico> ask turing :)
20:33:44 <glguy> or to catch (error "")?
20:33:47 <dons> roughly:  main t = let IO reallyGetChar in case reallyGetChar t of (t', c) -> (t', c)
20:33:54 <monochrom> catch (error "") yes.
20:34:10 <wy> Why does IO take a (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, Char #)), but getChar is of type IO Char?
20:34:11 <monochrom> Damn, I should know to distinguish undefined from _|_.
20:34:20 <fnord123> hey dons, maybe I've misunderstood this http 1.1 thing and perhaps you can help. :)
20:34:52 <dons> wy, because newtype IO = IO (State# Tok -> (# State# Tok, Char #)
20:34:58 <wy> Does that mean (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, Char #)) can be unified with Char?
20:35:04 <glguy> I was just thinking of functions like: let f x = if x == () then something else undefined `catch` \_ -> exceptionalCase
20:35:23 <glguy> with  f () doing one thing, and f (error "whatever reason") doing another
20:35:24 <fnord123> I think http requests can be in one go, or chunked. When they are chunked, they have crlfs in weird places which mean you can't split the header and body on the double crlf... I'm rereading rfc 2616 and can't figure out why I thought this..
20:35:25 <dons> that is, IO is a new type, represented as a series of functions in the State# monad, threading a RealWorld# state around
20:35:41 <monochrom> I think http://www.haskell.org/haskellwiki/IO_inside  has detailed innard information
20:35:42 <lambdabot> Title: IO inside - HaskellWiki
20:35:58 <dons> wy, nope. they're not the same type.
20:36:02 <kpreid> dons: shouldn't that be newtype IO a = IO (State# Tok -> (# State# Tok, a #))?
20:36:15 <tautologico> IO is a monad
20:36:19 <dons> ah yes
20:37:01 <monochrom> glguy: yes, it's ok to catch exceptions and errors inside IO.
20:37:41 <monochrom> glguy: and if you want to also do that in pure functions, you'll need stripIO. :)
20:38:44 <wy> dons: I guess I can resolve this later when I read more. Thanks
20:40:14 <dons> ultimately, the IO monad is just sugar for nested case statements, which give the right ordering.
20:40:32 <dons> case getChar of c -> case putChar (toUpper c) of () -> ()
20:40:49 <dons> now, thread a state token through that, so you can't just fake ordering-- the type system will stop you
20:41:19 <dons> \t -> case getChar t of (t', c) -> case putChar (toUpper c) t' of (t'', ()) -> (t'', ())
20:41:59 <dons> ?undo do c <- getChar ; putChar (toUpper c) ; return ()
20:42:00 <lambdabot> getChar >>= \ c -> putChar (toUpper c) >> return ()
20:42:16 <dons> and now you can see how >>= is implemented as a case in the IO monad instance
20:42:32 <dons> hiding all the state threading in the background
20:42:42 <dons> so you just write:  do x <- getChar ; putChar x
20:43:57 <wy> dons: Uhh. you overestimated me. I just noticed that getChar is not a function...
20:45:22 <reppie> getChar is not a function?
20:45:23 <iulus> :t getChar
20:45:25 <lambdabot> IO Char
20:46:03 <olliej> iulus: IO a is a function
20:46:03 <Cale> right, it's just an action
20:46:08 <Cale> olliej: nope
20:46:13 <monochrom> the question "is IO Char a function" is a philosophical question :)
20:46:18 <Cale> It's not :)
20:46:22 <iulus> olliej: I didn't say either way ;)
20:46:32 <Cale> A function is a value of type t -> u for some types t and u
20:46:45 <monochrom> To boot, "1 :: Int" is a function too.
20:46:55 <Cale> (not by my definition)
20:46:59 <monochrom> hehe
20:47:09 <reppie> monochrom i agree
20:47:12 <Cale> If you want, you can allow "0-ary functions", but then every value is a function.
20:47:22 <monochrom> Yes, I do that.
20:47:34 <Cale> So the word "function" is meaningless then
20:47:36 <tautologico> yes
20:47:44 <reppie> Cale why is it meaningless?
20:47:47 <audreyt> 1# :: Int# -- is this a function?
20:47:48 <monochrom> that is why the question is philosophical
20:47:51 <iulus> it makes a bit more sense in imperative languages where x = 7 and x = func () { return 7; } are quite different
20:48:18 <wy> I see. The problem is that IO can only produce values of type IO Char, but it doesn't accept Char as input. So I can't take the Char out by pattern matching.
20:48:48 <araujo> wy, IO a , is a one way monad
20:48:56 <araujo> You can't take values out of it.
20:49:13 <mgsloan> well, in functional programming so much is a function, the distinction is already useless.  It's better for overall uniformity if 1 :: Int is a function as well
20:49:18 * mgsloan casts lots with mono ;)
20:49:34 <wy> araujo: I know. I was just trying to figure out what does one-way mean.
20:49:40 <olliej> Cale: ah yes, my bad, IO a = IO (State -> (state, a)) or some such
20:49:43 <araujo> wy, only that.
20:50:12 <wy> araujo: And how one-way-ness is enforced
20:50:19 <dons> well, getChar :: IO a
20:50:19 <monochrom> It is a philosophical question because you could take a million different stands.
20:50:25 <dons> which we know now really is a function:
20:50:35 <dons> getChar :: RealWorld -> (Prelude GHC.IOBase> IO $ \s -> let IO f = getChar in case f s of (# t, c #) -> (# t, c #)RealWorld, Char)
20:50:39 <dons> urg
20:50:42 <dons> windoows
20:50:49 <mgsloan> yeh (Realworld -> (Realworld, a))
20:50:50 <dons> getChar :: World -> (World, Char)
20:51:09 <olliej> dons: wow, that looks so familiar
20:51:11 <dons> all your imperative belong to us
20:51:17 <olliej> dons: hehe
20:51:42 <olliej> dons: i believe ghc strips out the world in final code gen?
20:51:55 <monochrom> @remember dons all your imperative are belong to us
20:51:57 <LoganCapaldo> details details details
20:52:01 <olliej> dons: my compiler doesn't :D
20:52:12 <dons> yep. its a strict type with a single inhabitant
20:52:33 <dons> so it can never be bottom, and the compiler can remove it statically
20:52:48 * dons notes it would be useful to define our own strict types sometimes
20:52:56 <olliej> dons: or in my case just pass in null at the very beginning
20:52:58 <araujo> wy,In the case of IO, through a State transformer
20:53:00 <olliej> and hope for the best :D
20:53:09 <dons> data !T
20:53:30 <monochrom> Is there (# #) ?
20:53:40 <reppie> what is # ?
20:53:42 <dons> don't think so
20:53:43 <olliej> monochrom: yes, it's strict tuple
20:53:48 <olliej> dons: internally at least
20:53:50 <olliej> oh
20:53:50 <dons> its just syntax for a strict pair, (# a , b #)
20:53:52 <olliej> strict ovid?
20:53:58 <dons> or (# a, (# b , c #) #)
20:54:16 <dons> which ghc knows it can stick in registers or on the stack, too.
20:54:18 <olliej> monochrom: do you mean is there a strict ()?
20:54:30 <olliej> dons: essentially value type
20:54:43 <dons> when it see: case f of (# t, z #) -> case g z t of (# ...
20:54:57 <dons> olliej: yeah, with no bottom element
20:55:02 <monochrom> right, strict ().  nothing between (# and #)
20:55:09 <dons> monochrom: yeah
20:55:16 <olliej> monochrom: not that i'm aware of
20:55:26 <dons> it would be a synonym for RealWorld#
20:55:56 <fnord123> ?paste
20:55:57 <lambdabot> http://paste.lisp.org/new/haskell
20:56:33 <fnord123> proxy error on the pastebin
20:56:55 <fnord123> nevermind; its working now
20:57:17 <monochrom> It is proxy error once in a while.  I have seen it too.
20:58:24 <fnord123> dons, j00 got mailz
20:59:02 <wy> data KO a = KO (Int->String)
20:59:11 <wy> f1 :: Int->String
20:59:11 <wy> f1 i = show i
20:59:26 <wy> f2 :: KO Char
20:59:26 <wy> f2 = KO f1
21:00:07 <wy> type of f2 is KO Char. But there is no way to take it out. Is that the same with IO ?
21:02:23 <Cale> olliej: that's sort of a lie though. even though it sort of looks that way in the implementation
21:02:44 <Cale> (that IO a is the same as  RealWorld -> (RealWorld, a))
21:03:27 <dons> fnord123: thanks. i'll look into this
21:03:39 <dons> i wonder if i can steal the http stuff out of HAppS or HaskellNet
21:03:41 <fnord123> thanks for that
21:03:51 <Cale> I don't really care for that model, because for one, it doesn't really get across the need to use RealWorld values linearly, and for two, there's no practical appropriate set of actual values for RealWorld to consist of.
21:04:28 <fnord123> the erlang www_tools used almost the same algorithm for http ripping as haskell http module. I wonder if there's a common source for this algo
21:04:46 <dons> mm. interesting
21:05:27 <fnord123> so i wouldn't be suprised if other clients were infected as well. I mean, it works find for http 1.0 since transfer-encodings aren't a part of that spec afaik
21:05:40 <Cale> It doesn't appropriately model other programs modifying the contents of the disk, or the contents of other computers across the internet, for instance.
21:06:00 <monochrom> I agree with someone when he said (on haskell-cafe or something) IO is a process calculus.
21:06:05 <Cale> yes
21:06:29 <fnord123> perhaps people just upgraded the request type without realizing that servers can return chunked responses regardless of you asking with one.
21:06:32 <mgsloan> yeah, IO does rather shimmy around those issues
21:07:09 <Cale> It's much better to think of a value of type (IO t) as an imperative program which when exectued may have a variety of side effects and rely on a variety of external sources of data before resulting in a value of type t.
21:07:15 <mgsloan> I think in between the end of the function and the return, world is passed off to the actual real world updater
21:07:15 <dibblego> ?hoogle catMaybes
21:07:16 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
21:07:16 <mgsloan> sorta
21:07:36 <dibblego> ?hoogle liftM
21:07:36 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
21:07:36 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
21:07:36 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
21:07:51 <Cale> and x >>= f  replaces the conceptual "return v" at the end of x with "f v"
21:08:06 <mgsloan> yeah, you had that diagram
21:08:23 <Cale> Which is a call from execution back into the Haskell evaluator to compute a continuation based on v.
21:08:37 <Cale> right
21:08:55 <Cale> http://cale.yi.org/autoshare/evalexec.png -- this one
21:11:15 <dibblego> ?hoogle (Monad m) => m [a] -> (a -> m (Maybe b)) -> m [b]
21:11:16 <lambdabot> No matches, try a more general search
21:11:46 <LoganCapaldo> Cale: I thought i understood what you just said. In fact I was like "Uh huh, that makes sense.". Then I clicked on the link to that diagram. Now I am completely confused. I hope you are happy :)
21:12:11 <Cale> hehe
21:12:35 <Cale> the "pages" are values of type (IO t)
21:12:55 <Cale> the little blue and green lines are just lines of code which we don't care much about
21:14:04 <Cale> for example, the blue page might be   do { u <- getLine; let { v = reverse u }; return v }
21:14:24 <Cale> and so we start off with something like  do { u <- getLine; let { v = reverse u }; return v } >>= f
21:14:29 <Cale> which evaluates to:
21:14:35 <Cale> do { u <- getLine; let { v = reverse u }; f v }
21:15:54 <Cale> then, supposing that this is the final program, and it begins executing, the code pointer goes along, and actions are carried out, until we come to the f v at the end, which causes evaluation to happen
21:16:03 <Cale> and f v evaluates to some action
21:16:29 <Cale> and control returns to execution where that action is carried out until it returns its result
21:17:10 <Cale> The vertical ellipses in the diagram represent many steps, which may involve lots of calls back into the Haskell evaluator.
21:17:53 <LoganCapaldo> This just proves that while a picture might be worth a thousand words, must of the time I don't know what those words are ;) Thanks for the verbal explanation
21:18:00 <Cale> no problem :)
21:18:07 <Cale> The picture was meant to go with the words :)
21:18:47 * SamB_XP makes a note that IRC logs should include copies of all referenced illustrations
21:19:51 <Cale> also, that first arrow to the right should probably be marked "user" or something
21:19:58 <Cale> because it doesn't happen automatically
21:20:16 <Cale> and that's really very important
21:21:26 * LoganCapaldo nods sagely
21:28:11 <shankys> ?paste
21:28:11 <lambdabot> http://paste.lisp.org/new/haskell
21:31:32 <shankys> I have some code using Database.HDBC and the Reader monad that isn't quite working out the way I want it to. If you look at my paste, things work out without the commented out disconnect. However, if you uncomment out the disconnect, the two lines after it don't seem to work right (it returns [] for any SqlQuery). Does anyone have any ideas?
21:31:34 <lisppaste2> shankys pasted "Database Reader Monad Problem" at http://paste.lisp.org/display/33518
21:32:17 <Cale> http://cale.yi.org/autoshare/evalexec.png -- this version is possibly more comprehensible (?)
21:32:31 <rongenre> Bleah -- does anyone know how to use seq or $! to force strict evaluation of a list?
21:32:56 <Cale> rongenre:  "foldr seq () xs" ?
21:33:44 <Cale> strictList xs = foldr seq xs xs
21:34:01 <Cale> hehe
21:34:24 <Cale> shankys: hmm, I'm not too familiar with HDBC, but I'll have a quick look.
21:34:27 <LoganCapaldo> Cale: Awesome!
21:34:37 <shankys> Cale: Alright, thanks.
21:34:58 <Cale> shankys: iirc, HDBC does lazy IO.
21:35:19 <kpreid> > G.everywhere id ['a','b',undefined]
21:35:21 <lambdabot>  Undefined
21:35:41 <Cale> therefore, disconnecting before actually using the values retrieved from the database for output, or forcing them explicitly is dangerous
21:35:48 <kpreid> I wonder whether that's accidental
21:36:16 <Cale> kpreid: your result there, or are you referring to the lazy IO in HDBC?
21:36:38 <kpreid> my result. actually I now see it can't be, because without knowing that the function is id it can't not force everything
21:36:43 <LoganCapaldo> ?type G.everywhere
21:36:45 <lambdabot> Couldn't find qualified module.
21:36:54 <kpreid> ?type Data.Generics.everywhere
21:36:55 <Cale> also
21:36:55 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
21:36:59 <Cale> > ['a','b',undefined]
21:37:00 <lambdabot>  Undefined
21:37:10 <kpreid> oop
21:37:17 <kpreid> > length $ G.everywhere id ['a','b',undefined]
21:37:19 <lambdabot>  3
21:37:26 <Cale> :)
21:37:28 <kpreid> doh
21:37:37 <kpreid> okay, it would have to force all the non-leaves
21:37:42 <kpreid> er..
21:37:45 <Cale> Prelude> :m + Data.Generics
21:37:45 <Cale> Prelude Data.Generics> everywhere id ['a','b',undefined]
21:37:45 <Cale> "ab*** Exception: Prelude.undefined
21:37:46 * kpreid stops
21:37:52 <benja_> everywhere, the built-in deepSeq?
21:38:03 <Cale> no, it's lazy :)
21:38:05 <shankys> Cale: The problem is that I'm getting these idle transactions, and under heavy load there get to be enough of them that PostgreSQL starts complaining. I don't want to explicitly have to call dbconnect, disconnect in every function. Is there some nice way to do that?
21:38:23 <Cale> however, you can use it to form a deepSeq, which performs unfortunately quite poorly :/
21:38:32 <benja_> damn :)
21:39:09 <Cale> er, I think it was everything, not everywhere
21:39:11 <Cale> yeah
21:39:16 <Cale> rnf' x = everything (\x y -> x `seq` y) (\x -> x `seq` ()) x
21:39:32 <Cale> deepSeq x y = rnf' x `seq` y
21:39:34 <LoganCapaldo> > G.everywhere (\x->"Is this some sort of generic map?") [1,2,3]
21:39:35 <lambdabot>  a1
21:39:36 <lambdabot>    Inferred type: [Char]
21:39:36 <lambdabot>   In a lambda abstraction: \ x -> "Is this...
21:39:51 <Cale> hmm, that's interesting :)
21:39:55 <LoganCapaldo> guess not :)
21:40:04 <kpreid> LoganCapaldo: has to be of the same type
21:40:28 <kpreid> LoganCapaldo: try mkT, though...
21:40:31 <LoganCapaldo> > G.everywhere (\x->"aha") ["a","b","c"]
21:40:33 <lambdabot>  a1
21:40:33 <lambdabot>    Inferred type: [Char]
21:40:33 <lambdabot>   In a lambda abstraction: \ x -> "aha"
21:40:40 <Cale> it's that the type of x is underdetermined, I think
21:40:49 <kpreid> > G.everywhere (mkT (\x -> "aha")) ('a', 2, "c")
21:40:50 <lambdabot>  Not in scope: `mkT'
21:40:50 <Cale> > G.everywhere (\(x::Int)->"Is this some sort of generic map?") [1,2,3]
21:40:51 <lambdabot>  Parse error in pattern
21:40:56 <Cale> bah
21:40:56 <kpreid> > G.everywhere (G.mkT (\x -> "aha")) ('a', 2, "c")
21:40:57 <lambdabot>  Add a type signature
21:41:14 <kpreid> > G.everywhere (G.mkT (\x -> "aha")) ('a', 2::Int, "c") :: (Char, Int, String)
21:41:16 <lambdabot>  ('a',2,"aha")
21:41:19 <kpreid> there we go
21:41:29 <kpreid> @type Data.Generics.mkT
21:41:31 <lambdabot> forall a b. (Typeable b, Typeable a) => (b -> b) -> a -> a
21:41:35 <LoganCapaldo> Wooooooah
21:41:52 <kpreid> mkT is just id if the types don't match
21:42:01 <kpreid> otherwise it applies the function
21:42:13 <kpreid> > (mkT (++"hi")) "abc"
21:42:14 <lambdabot>  Not in scope: `mkT'
21:42:17 <kpreid> > (G.mkT (++"hi")) "abc"
21:42:19 <lambdabot>  "abchi"
21:42:23 <Cale> > G.everywhere (\x->"Is this some sort of generic map?") ["Hello", "there", "world!"]
21:42:24 <lambdabot>  a1
21:42:25 <lambdabot>    Inferred type: [Char]
21:42:25 <lambdabot>   In a lambda abstraction: \ x -> "Is this...
21:42:26 <kpreid> > (G.mkT (++"hi")) [1,2,3]
21:42:27 <lambdabot>  Add a type signature
21:42:31 <kpreid> > (G.mkT (++"hi")) [1::Int,2,3]
21:42:33 <lambdabot>  [1,2,3]
21:42:35 <Cale> > G.everywhere (mkT (\x->"Is this some sort of generic map?")) ["Hello", "there", "world!"]
21:42:36 <lambdabot>  Not in scope: `mkT'
21:42:41 <Cale> > G.everywhere (G.mkT (\x->"Is this some sort of generic map?")) ["Hello", "there", "world!"]
21:42:43 <lambdabot>  ["Is this some sort of generic map?","Is this some sort of generic map?","Is...
21:43:03 <nmessenger> fun with namespaces!
21:43:12 <kpreid> > G.everywhere (mkT (show :: String -> String)) "abc"
21:43:13 <lambdabot>  Not in scope: `mkT'
21:43:14 <nmessenger> I'd say it might be
21:43:16 <kpreid> > G.everywhere (G.mkT (show :: String -> String)) "abc"
21:43:18 <lambdabot>  "\"a\\\"b\\\\\\\"c\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
21:43:25 <kpreid> > G.everywhere' (G.mkT (show :: String -> String)) "abc"
21:43:27 <lambdabot>  "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\...
21:43:44 <Cale> > G.everywhere (G.mkT (\x->x+1 :: Int)) [(1::Int)..3]
21:43:46 <lambdabot>  [2,3,4]
21:43:52 <nmessenger> ooooooooooooohhhh, heh heh
21:43:57 <Cale> > G.everywhere (G.mkT (\x->x+1 :: Int)) [Just 1, Just 5, Nothing, Just 7]
21:43:58 <lambdabot>  Add a type signature
21:44:05 <Cale> > G.everywhere (G.mkT (\x->x+1 :: Int)) [Just (1 :: Int), Just 5, Nothing, Just 7]
21:44:08 <lambdabot>  [Just 2,Just 6,Nothing,Just 8]
21:44:13 <kpreid> > G.gshow $ G.everywhere (G.mkT succ) (1::Int, 'a')
21:44:14 <lambdabot>  Add a type signature
21:44:41 <Cale> I think this is good evidence that Data.Generics is a total pain to use on the commandline.
21:44:50 <kpreid> what do you call that mkT succ can't work?
21:44:58 <Cale> It's not so bad in real programs because you have more type constraints.
21:45:12 <Cale> It's really easy to have underdetermined types.
21:45:27 <Cale> > G.gshow $ G.everywhere (G.mkT (succ :: Int -> Int) ) (1::Int, 'a')
21:45:29 <lambdabot>  "((,) (2) (a))"
21:45:53 <Jessehk> Any suggestion/critique for a newbie? :) http://paste.lisp.org/display/33520
21:46:01 <nmessenger> why (,) x y ?
21:46:15 <kpreid> nmessenger: because gshow has its own peculiar rules
21:46:17 <Cale> because gshow isn't extremely clever
21:46:47 <LoganCapaldo> It's pretty clever that it figured it out IMO
21:47:00 <LoganCapaldo> but maybe I'm easily impressed :)
21:47:36 <Cale> Jessehk: I might use Maybe in place of Spot, though there are advantages to both.
21:47:38 <nmessenger> Jessehk: do you have errors anywhere or are you fishing for improvements?
21:47:57 <Cale> newUnknownWord n = replicate n Unfilled
21:48:02 <mgsloan> probably fishing for style :)
21:48:07 <Jessehk> nmessenger : Fishing, though you make it sound like a bad thing
21:48:10 <Jessehk> ;)
21:48:14 <Cale> It's not bad
21:48:17 <mgsloan> yeah, not a bad thing
21:48:20 <nmessenger> Jessehk: totally not intended
21:48:24 <Cale> oh, also,  [x] ++ y = x : y
21:48:35 <nmessenger> Jessehk: I do it myself :P
21:48:46 <Cale> stringFromUnknown (x : xs) = charForm x : stringFromUnknown xs
21:48:53 <Cale> and then you look at that hard :)
21:49:08 <Jessehk> Cale : Thanks for the tips. I'll be using them. :)
21:49:11 <Cale> and you notice that  stringFromUnknown = map charForm
21:49:39 <Jessehk> Cale: ooo, that's a good one
21:50:06 <mgsloan> ?. pl undo \filename -> do wordList <- readFile filename; return $ List.words wordList
21:50:06 <lambdabot> (((List .) . words) `fmap`) . readFile
21:50:09 <Cale> if you were using the Maybe type, then  charForm = maybe '_' id
21:50:12 <mgsloan> hmm, maybe not :P
21:50:29 <Cale> so  stringFromUnknown = map (maybe '_' id)
21:50:37 <mgsloan> yeah, pl is misinterpreting namespaces it looks like
21:50:46 <mgsloan> ?undo \filename -> do wordList <- readFile filename; return $ List.words wordList
21:50:47 <lambdabot> \ filename -> readFile filename >>= \ wordList -> return $ List.words wordList
21:50:54 <Cale> oh yeah
21:50:57 <dibblego> ?hoogle (Monad m) => m [a] -> (a -> m b) -> m [b]
21:50:58 <lambdabot> No matches, try a more general search
21:51:11 <Cale> possibleWordList = fmap words (readFile filename)
21:51:15 <nmessenger> ?. pl undo \filename -> do wordList <- readFile filename; return $ List_words wordList
21:51:16 <lambdabot> (List_words `fmap`) . readFile
21:52:14 <Jessehk> Too...many...improvements...
21:52:16 <Jessehk> :p
21:52:42 <nmessenger> a completely personal style choice, but I'd write isSolved as a section: isSolved = (Unfilled `notElem`)
21:53:05 <mgsloan> mm, nice
21:53:37 <nmessenger> Also, doesn't randomWordFromList have an off-by-one error?
21:53:46 <Cale> http://paste.lisp.org/display/33520#1
21:53:55 <Cale> oh, and yes, it does
21:53:56 <nmessenger> randomRIO ranges are inclusive IIRC
21:54:11 <Cale> that should be  length wordList - 1
21:54:53 <mgsloan> that function could actually be a generic list item random-selector
21:55:00 <Cale> map (maybe '_' id) [Just 'C', Nothing, Nothing, Just 'e']
21:55:03 <Cale> > map (maybe '_' id) [Just 'C', Nothing, Nothing, Just 'e']
21:55:04 <lambdabot>  "C__e"
21:55:05 <mgsloan> polymorphic is perhaps the more exact term
21:55:29 <Cale> yes it could :)
21:56:02 <Cale> these are all style things which just come with knowing the Prelude rather well
21:56:29 <Cale> The polymorphism one is something else though. :)
21:56:55 <mgsloan> yeah, that's more like ideology :)
21:57:19 <Cale> How much to make things polymorphic is always a bit of a contentious question.
21:58:03 <Cale> I tend to use the rule that libraries should be as polymorphic as possible, and applications should be as monomorphic as possible. The line between application and library is somewhat blurry though.
21:58:57 <Cale> There are also exceptions -- polymorphism is a useful tool when you know or suspect that the implementation of some data structure is going to change.
21:59:24 <Cale> You can stick a class in the way, and always access the data through it.
22:00:16 <mgsloan> yeah, the line between app and lib is super blurry.  app is basically the main func, and the rest is very application specific lib :)
22:00:24 <nmessenger> Cale: I usually write simple monomorphic stuff at first.  If I want to re-use for more types, I'll try to abstract
22:00:50 <Jessehk> Cale : Thanks for the annotations. :)
22:01:48 <Cale> Jessehk: note that bug that was mentioned above -- I didn't correct it in my annotation
22:02:04 <Jessehk> Cale: Yup, the off-by-one error
22:02:07 <Cale> yeah
22:02:54 * nmessenger adds another annotation
22:03:16 <mgsloan> http://paste.lisp.org/display/33520#2
22:03:19 * mgsloan does too :)
22:03:47 <mgsloan> perhaps at that point undoing is obfusication
22:04:08 <Cale> It's a good question. Actually, that doesn't look too bad to me.
22:05:46 <Cale> It does make a good case for fmap = (.) though. I think  (wordList !!) . randomRIO (0, length wordList - 1)  and  words . readFile filename  would look rather pretty.
22:06:40 <mgsloan> yes
22:06:53 <GsD_CeleborN> anybody build gtk2hs 0.9.10.3 on winXP ?
22:07:14 <Cale> Jessehk: My above comment is referring to hypothetical changes to the prelude and can safely be ignored :)
22:07:16 <nmessenger> Cale: not to mention magical
22:07:31 <Cale> nmessenger: somewhat :)
22:07:32 <mgsloan> ah, i forgot to polymorphasize it
22:07:32 <Jessehk> Cale : I figured as much ;)
22:08:15 * nmessenger misspelled his name in the annotation
22:08:53 <mgsloan> yeah, that's the ahrnoldization of your name
22:09:12 <Cale> Functor application and function composition are arguably the two most fundamental operations in functional programming. There's something rather satisfying about unifying them.
22:09:57 <Cale> However, that's also perhaps a reason against it :)
22:10:18 <mgsloan> It'd be nice to bring $ into the mix, but perhaps that's overdoing it
22:10:19 <nmessenger> well, they are 'unified' in the sense that composition is a special case of fmap, but I get what you're saying
22:10:29 <Cale> righ
22:10:30 <Cale> t
22:10:51 <Cale> That requires the instance of Functor for ((->) e) though, which at present isn't even in the Prelude.
22:11:00 <Cale> First of all, we need to get that change made :)
22:11:05 <mgsloan> (+1) . [1,2,3]
22:11:07 <mgsloan> :O
22:11:12 <Cale> yes, that would be nice :)
22:11:19 <nmessenger> Is (IO a)'s some sort of liftM?  I've not used any fmaps.
22:11:26 <mgsloan> howsabout rename fmap to map as well
22:11:32 <Cale> liftM is another name for fmap
22:11:33 <mgsloan> err, nevermind
22:11:38 <nmessenger> s/'s some/'s fmap some/
22:11:40 <Cale> with its type specialised
22:11:46 <Cale> @type liftM
22:11:47 <nmessenger> gotcha
22:11:48 <Cale> @type fmap
22:11:49 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
22:11:50 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
22:11:51 <mgsloan> just eliminate all of the words and use '.' instead
22:12:22 <Cale> I think I'd want to have map and (.), and have those both be general functor application.
22:12:26 <mgsloan> yeah, I think the 'new prelude' thing may also create a class hierarchy for monad/funcors as well
22:12:41 <Cale> There are cases where you really want to write 'map' and cases where it's nicer to use the infix '.'
22:12:55 <mgsloan> oh, yes.  Hadn't thought about that
22:13:03 <Cale> (.) f . (.) g = (.) (f . g)
22:13:04 <mgsloan> wow, that could be really elegant
22:13:07 <nmessenger> so map = (.) = fmap, but defined as fmap is now
22:13:14 <Cale> right
22:13:22 <Cale> and we'd just drop fmap altogether after a while
22:13:45 <Cale> liftM is questionable too
22:14:04 <Cale> I don't think there's really much of a place for it, but there is that nice progression with liftM2, etc.
22:14:35 <mgsloan> http://www.haskell.org/haskellwiki/The_Other_Prelude
22:14:36 <lambdabot> Title: The Other Prelude - HaskellWiki
22:14:39 <mgsloan> could stick this stuff here
22:14:46 <nmessenger> speaking of liftM, I had a fleeting thought the other day that return could be renamed liftM0, since return is so overloaded with imperative overtones
22:14:50 <Cale> also, it gives a nice quick way to get an instance of Functor given an instance of Monad
22:15:06 <Cale> well, yes, it could, but that's hideous :)
22:15:08 <Cale> hehe
22:15:16 <Cale> I rather like 'return' actually.
22:15:37 <mgsloan> oh, this stuff is already on that page
22:15:37 <Cale> If I was going to rename it, I'd probably pick the name 'unit'
22:15:44 <nmessenger> hideous, shmideous.  return was confusing for me
22:15:47 <Cale> yeah, I added it a little while ago
22:15:55 <Cale> nmessenger: blame your teacher :)
22:16:14 <Cale> nmessenger: It possibly wouldn't have been had you started with my tutorial :)
22:16:34 <nmessenger> Monads as Containers?
22:16:38 <Cale> yeah
22:16:44 <Cale> and/or Introduction to IO
22:17:38 <Cale> The only problem with those is that I don't really cover the full breadth of ways to think about monads
22:17:51 <nmessenger> anyone: How do *you* pronounce ()? and (a -> b)?
22:18:12 <Cale> nmessenger: () is the unit type or the empty tuple
22:18:22 <Cale> (a -> b) is "functions from a to b"
22:18:45 <nmessenger> I know *what* it is, I was just wondering how *you*, specifically, read it when reading code.
22:18:46 <Cale> I'd probably read "f :: a -> b" as "f is a function from a to b"
22:19:03 <nmessenger> I read that as "f has type a to b"
22:19:03 <uccus> I simply say f from a to b
22:19:19 <nmessenger> and () as "unit"
22:20:32 <nmessenger> I just find it easier to read through code if there some reasonable pronunciation to guide my thoughts forward.
22:21:32 <nmessenger> (>>=) as "bind", (.) as "dot", = usually "is defined as"
22:22:05 <Cale> I usually read (.) as "following", at least, when it's composition :)
22:23:47 <nmessenger> if I come across a new operator I don't know how to pronounce, I stumble a little
22:25:07 <Cale> I suppose the best thing to do in that case is to prioritise reading the code for infix operators which you don't know yet.
22:25:24 <nmessenger> that's why I dislike operator overuse* (*for sufficiently subjective values of 'overuse')
22:25:28 <Cale> Things which are given infix operator names are usually pretty important.
22:26:07 * LoganCapaldo reads (.) as of
22:26:18 <Cale> Giving a minor, rarely used function an infix operator is usually a bad idea.
22:26:35 <LoganCapaldo> This of course totally confuses me me when its in the prefix position
22:27:22 <nmessenger> concat . map show = "concat of map show"
22:27:51 <nmessenger> "concat following map show" is very good
22:28:40 <nmessenger> ?let following = (.)
22:28:40 <Cale> reading something like (concat .) . map  aloud is a little tricky :)
22:28:41 <lambdabot> Defined.
22:29:07 <nmessenger> 'concat following (pause) following map'
22:29:59 <LoganCapaldo> I can't deal with (concat .) . map, etc.
22:30:27 <LoganCapaldo> I start using names then
22:31:10 <LoganCapaldo> @unpl (concat .) . map
22:31:10 <lambdabot> (\ d g -> concat (map d g))
22:31:14 <nmessenger> hmm, map gets a thing and returns a function.  (concat .) is applied to that returned function.  When it gets an argument, its results are concatted
22:31:26 <Cale> of course, in this particular case, you can read it as "bind" or "concatMap"
22:31:43 <Cale> well, flip bind, anyway
22:31:58 <Cale> :t concatMap
22:31:59 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
22:32:01 <LoganCapaldo> <<=?
22:32:06 <Cale> =<<
22:32:10 <nmessenger> :t (=<<)
22:32:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
22:32:21 <nmessenger> looks right
22:33:02 <Cale> :t (concat .) . map
22:33:03 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
22:33:28 <Cale> (f .) . g = \x -> f . g x
22:33:36 <nmessenger> I use (=<<) all the time in point-free expressions.  It allows to for right-to-left reading like ordinary functions.
22:34:20 <Cale> It's especially effective notation when combined with the <- in do-notation.
22:34:27 <nmessenger> aye
22:35:27 <nmessenger> (foo >>= bar =<< baz) howis/is this parsed?
22:37:40 <nmessenger> > undefined >>= undefined =<< undefined
22:37:40 <lambdabot>    precedence parsing error
22:37:40 <lambdabot>     cannot mix `(>>=)' [infixl 1] and `(=<<...
22:38:08 <nmessenger> > undefined =<< undefined >>= undefined
22:38:09 <lambdabot>    precedence parsing error
22:38:09 <lambdabot>     cannot mix `(=<<)' [infixr 1] and `(>>=...
22:38:28 <LoganCapaldo> whichever way it picked to do first it couldn't would right?
22:38:31 * fnord123 's brain explodes trying to figure out this http error
22:38:38 <LoganCapaldo> *work
22:38:59 <LoganCapaldo> foo >>= bar :: m c
22:39:20 <nmessenger> LoganCapaldo: it *could*, but there's not enough information for it to pick a grouping
22:39:28 <LoganCapaldo> baz >>= (val :: m c) is not gonna work afaik
22:40:23 <nmessenger> LoganCapaldo: hmm? That's a type error.  (>>=) expects an (a -> m b) as its second argument.
22:40:32 <LoganCapaldo> that's my point
22:41:12 <nmessenger> LoganCapaldo: undefined is nice because it assumes whatever type would please the checker
22:41:29 <Cale> =<< and >>= have the same precedence and opposite associativity, so it doesn't parse
22:41:55 <nmessenger> > (undefined >>= undefined) =<< undefined
22:41:56 <lambdabot>  add an instance declaration for (Show (m b))
22:41:58 <Cale> Consecutive unparenthesized operators with the same precedence must both be either left or right associative to avoid a syntax error.
22:42:04 <LoganCapaldo> I don't think you can define a bar for which that would work
22:43:02 <LoganCapaldo> ?type (undefined >>= undefined) =<< undefined
22:43:02 <Cale> @type (undefined >>= undefined) =<< undefined
22:43:04 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
22:43:04 <nmessenger> > Logan: why not? ((foo >>= bar) =<< baz) is just (bar =<< foo =<< baz)
22:43:05 <lambdabot>  Not in scope: `baz'
22:43:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
22:43:17 <Cale> It requires the function/reader monad though
22:43:24 <nmessenger> oops
22:46:21 <nmessenger> > 0 L./ 0
22:46:22 <lambdabot>  "Nullity!!111"
22:46:34 <Cale> hah
22:46:38 <LoganCapaldo> > ([1] >>= return (return . id)) =<< [2]
22:46:39 <lambdabot>    Expecting a function type, but found `a'
22:46:39 <lambdabot>    Expected type: [b]
22:46:39 <lambdabot>    ...
22:46:49 <LoganCapaldo> mmm
22:46:52 <monochrom> We were horrified to find that out today.
22:47:03 <nmessenger> > 2307320987472093 L./ 0
22:47:05 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
22:47:46 <Cale> > 2 L./ 3
22:47:47 <lambdabot>  Exception: <local>:1:0-47: Non-exhaustive patterns in function /
22:47:52 <Cale> haha
22:48:53 <nmessenger> ?undefine /
22:48:53 <lambdabot> Undefined.
22:48:57 <nmessenger> ?let 0 / 0 = "Nullity!!111"; _ / 0 = 'l' : cycle "ol"; x / y = x Prelude./ y
22:48:58 <lambdabot> <local>:1:60:     No instance for (Fractional [Char])       arising from use ...
22:49:05 <nmessenger> crud
22:49:24 <nmessenger> ?let 0 / 0 = "Nullity!!111"; _ / 0 = 'l' : cycle "ol"; x / y = show (x Prelude./ y)
22:49:25 <lambdabot> Defined.
22:50:05 <nmessenger> > 2 L./ 3
22:50:06 <lambdabot>  "0.6666666666666666"
22:50:10 <nmessenger> not ideal
22:50:28 <monochrom> heheheh
22:50:41 <LoganCapaldo> @type (undefined >>= undefined) =<< undefined
22:50:43 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
22:51:03 <LoganCapaldo> @djinn (Monad m) => m b
22:51:03 <lambdabot> Cannot parse command
22:51:57 <nmessenger> (return "Nullity!!111") perhaps?
22:53:13 <nmessenger> > (undefined >>= undefined) =<< undefined
22:53:14 <lambdabot>  add an instance declaration for (Show (m b))
22:53:24 <nmessenger> > (undefined >>= undefined) =<< undefined :: Maybe Int
22:53:26 <lambdabot>  Undefined
22:53:30 <nmessenger> :D
22:58:33 <nmessenger> > 'l' : L.unicycle "ol"
22:58:34 <lambdabot>  Not in scope: `L.unicycle'
22:58:40 <nmessenger> :(
22:58:47 <dibblego> http://rafb.net/p/LBsxrE97.html  can this be written without using let?
22:58:48 <lambdabot> Title: Nopaste - No description
22:59:30 <nmessenger> replace (return x) with (return (x's value))
22:59:48 <dibblego> wtf?
23:00:22 <nmessenger> return (do r' <- r; return $ h r')
23:00:34 <mgsloan> anything can be written without lets...
23:00:53 <dibblego> oh, I forgot the parentheses when I attempted
23:01:01 <monochrom> How about: return (r >>= return . f)
23:01:09 <monochrom> ouch
23:01:15 <nmessenger> if you prefer ($): return $ do r' <- r; return $ h r'
23:01:18 <monochrom> How about: return (r >>= return . h)   -- this replaces return x
23:01:49 <monochrom> I think return . h = liftM h
23:02:02 <monochrom> I'll look for a Maybe-specific way too.
23:02:17 <nmessenger> ?type return . (f :: Int -> Int)
23:02:19 <lambdabot> Not in scope: `f'
23:02:28 <nmessenger> ?type return . negate
23:02:30 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m a
23:02:33 <sieni> dibblego: Can't you just write let x = foo in bar as (\x -> bar) foo?
23:02:34 <nmessenger> ?type liftM negate
23:02:36 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m a1
23:03:18 <nmessenger> monochrom: not quite the same
23:03:19 <monochrom> I must be mistaken about return . h = liftM h
23:03:36 <nmessenger> ?type fmap negate
23:03:38 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f a -> f a
23:03:57 <nmessenger> oh right, liftM is a case of fmap
23:04:29 <monochrom> return (liftM f r) is more like it :)
23:04:41 <monochrom> also return (fmap f r)
23:04:56 <monochrom> darn, everytime I write f I should write h.
23:05:55 <monochrom> there is a Maybe-specific way but it's more redundant.
23:07:08 <dibblego> "more redundant"? :)
23:07:22 <nmessenger> I'm guessing "less general"
23:07:33 <nmessenger> oh wait, joke, right
23:08:30 <dfranke> nmessenger, if it's maybe-specific then it's also maybe-general.
23:09:04 <nmessenger> dfranke, but if it's Maybe-specific it's definately not general
23:09:19 <dfranke> well, maybe it's not.
23:09:29 <dfranke> but you don't really know.
23:09:36 <nmessenger> maybe I do?
23:09:50 <nmessenger> ;P
23:09:54 <dfranke> no, do is general for all monads.
23:10:25 <dfranke> (this is starting to read like Who's On First)
23:10:30 <nmessenger> but what's the definition of 'general'?  What's its type?
23:10:34 <LoganCapaldo> third bas
23:11:11 <dfranke> no, What's on second.
23:11:25 <nmessenger> I don't know the name of the guy on third.
23:11:40 <dfranke> ?type second
23:11:41 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
23:11:47 <monochrom> For example you could use "maybe Nothing (Just . h)" but that is more redundant.
23:12:41 <monochrom> if the default value is Nothing, and the other value is going to be a Just, that specializes to fmap/liftM.
23:13:34 <nmessenger> But I Just wanted to make a joke with dfranke, your comment contributes Nothing ;P
23:14:06 <nmessenger> maybe...
23:14:34 <monochrom> just don't get too philosophical, lest your brain explodes and there is nothing left.
23:14:49 <nmessenger> I'm used to brain-splodey by now
23:15:02 <dfranke> monochrom, well that's not Right Either.
23:15:07 <monochrom> haha
23:15:18 <monochrom> ok, just don't make a mess, leave nothing on the floor.
23:15:28 <dfranke> ?type floor
23:15:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
23:15:30 <monochrom> haha this is just great
23:16:01 <nmessenger> If Nothing Left, then I don't know what do.
23:17:35 <nmessenger> > floor Nothing
23:17:35 <lambdabot>  add an instance declaration for (RealFrac (Maybe a))
23:17:35 <lambdabot>   In the definition ...
23:17:43 <dons> if Left Nothing then not (do return True) else do Nothing -- ?
23:17:53 <nmessenger> gah!
23:18:15 <LoganCapaldo> I'd join in but I'm kind of in a bind right now, so maybe I'll play when I return
23:18:15 <dons> you can't floor a Nothing
23:18:18 <dons> :t Nothing
23:18:20 <dons> :t floor
23:18:27 <lambdabot> forall a. Maybe a
23:18:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
23:18:31 <dons> LoganCapaldo: hehe
23:18:49 <nmessenger> s/play/interact/
23:18:55 <dons> :t floor . maybe 0 id
23:18:56 <lambdabot> forall b a. (Integral b, RealFrac a) => Maybe a -> b
23:19:03 <dons> :t maybe 0 floor
23:19:04 <lambdabot> forall a b. (RealFrac a, Integral b) => Maybe a -> b
23:19:11 <dons> :t maybe (error "Nothing") floor
23:19:13 <lambdabot> forall a b. (RealFrac a, Integral b) => Maybe a -> b
23:19:21 <dons> > maybe (error "Nothing") floor (Just pi)
23:19:22 <lambdabot>  3
23:19:39 <dons> > maybe pi floor Nothing
23:19:41 <lambdabot>  Add a type signature
23:19:50 <dons> > maybe pi floor (Nothing :: Maybe Double)
23:19:51 <lambdabot>  Add a type signature
23:19:54 <Excedrin> this metatutorial was a good idea
23:20:05 <dons> yeah, needs filling out a bit more. but off to a good start
23:20:09 <nmessenger> pi on the floor!
23:20:28 <nmessenger> ?type maybe pi floor Nothing
23:20:30 <lambdabot> forall b. (Floating b, Integral b) => b
23:20:43 <nmessenger> > maybe pi floor Nothing :: Float
23:20:43 <lambdabot>  add an instance declaration for (Integral Float)
23:21:17 <nmessenger> is there a (Floating b, Integral b) => b?
23:21:32 <GsD_CeleborN> anyone use gtk2hs here ?
23:21:44 <nmessenger> a floating-point integral number.  It boggles the mind.
23:21:56 <LoganCapaldo> floating integrals sound liek a nightmare from calculus
23:22:06 <dfranke> GsD_CeleborN, I'm pretty sure dcoutts does... :-)
23:22:32 <GsD_CeleborN> [dcoutts__]: hello
23:22:46 <nmessenger> "Oooh, they are floating!  Ghosts, I say!"
23:23:12 <nmessenger> *twilight-zone theme*
23:24:05 <GsD_CeleborN> [dfranke]: I have a problem n built gtk2hs on mingw
23:24:10 <GsD_CeleborN> make[2]: *** [install-data-hook] Error 1
23:24:16 <nmessenger> ?seen dcoutts__
23:24:17 <lambdabot> dcoutts__ is in #gentoo-haskell and #haskell. I don't know when dcoutts__ last spoke.
23:24:21 <nmessenger> ?seen dcoutts_
23:24:22 <lambdabot> dcoutts_ is in #ghc, #haskell-overflow, #gentoo-haskell, #haskell and #haskell.hac07. I don't know when dcoutts_ last spoke.
23:24:35 <dfranke> GsD_CeleborN, paste the last 20 lines of output from make to paste.lisp.org.
23:24:49 <LoganCapaldo> ?seen the future
23:24:50 <lambdabot> I haven't seen the.
23:25:02 <nmessenger> ?seen the_future
23:25:03 <lambdabot> I haven't seen the_future.
23:25:16 <GsD_CeleborN> ok
23:25:18 <nmessenger> ?seen my_eyeglasses
23:25:18 <lambdabot> I haven't seen my_eyeglasses.
23:25:34 <LoganCapaldo> ?seen anything
23:25:35 <lambdabot> I haven't seen anything.
23:25:51 <sieni> ?seen nudity
23:25:52 <lambdabot> I haven't seen nudity.
23:26:03 <anything> lambdabot: hello
23:26:13 <sieni> ?seen anything
23:26:14 <lambdabot> anything has changed nick to logancapaldo.
23:26:14 <lambdabot> logancapaldo is in #haskell. I last heard logancapaldo speak 10s ago.
23:26:21 <LoganCapaldo> woah
23:26:32 <LoganCapaldo> lambdabot is too clever for me
23:26:32 <pr0n> lambdabot: hi
23:26:42 <sieni> ?seen pr0n
23:26:42 <lambdabot> pr0n has changed nick to nmessenger.
23:26:42 <lambdabot> nmessenger is in #haskell. I last heard nmessenger speak 9s ago.
23:26:49 <nmessenger> darn
23:28:14 <nmessenger> ?remember LoganCapaldo lambdabot is too clever for me
23:29:03 <nmessenger> ?bot
23:29:04 <lambdabot> :)
23:29:43 * nmessenger pats LB on the head
23:30:39 <the_future> Scrooge, come with me, I am showing you your future!
23:30:47 <the_future> ?seen the_future
23:30:47 <lambdabot> You are in #haskell. I last heard you speak just now.
23:30:51 * we all must reward lambdabot
23:31:11 <the_future> I need someone else to ?seen the_future
23:31:18 <we> ?seen the_futue
23:31:19 <lambdabot> I haven't seen the_futue.
23:31:20 <we> ?seen the_future
23:31:21 <lambdabot> the_future is in #haskell. I last heard the_future speak 10s ago.
23:31:27 <we> lol
23:31:31 * the_future speaks in the past!!!!
23:31:50 * we are borg. Resistance is futile.
23:31:58 <LoganCapaldo> @remember lambdabot the_future is in #haskell.
23:32:06 <the_future> hahahaha
23:32:18 <allbery_b> @botsnack -- :)
23:32:18 <lambdabot> :)
23:32:22 * the_future is yours!
23:32:39 * we do not appreciate Captian Planet quotes
23:35:03 <nmessenger> ?quote lambdabot
23:35:04 <lambdabot>  lambdabot hasn't said anything memorable
23:35:28 <sieni> @help remember
23:35:28 <nmessenger> ?quote lambdabot
23:35:29 <lambdabot>  tERmIN473d
23:35:29 <lambdabot> quote <nick>
23:35:29 <lambdabot> remember <nick> <quote>
23:35:29 <lambdabot> Quote somebody, a random person, or save a memorable quote
23:35:40 <nmessenger> I think that's an actual quote
23:35:45 <sieni> @remember lambdabot lambdabot hasn't said anything memorable
23:35:55 <nmessenger> no! it's already there!
23:36:02 <nmessenger> ?quote quote
23:36:02 <lambdabot>  quote hasn't said anything memorable
23:36:11 <nmessenger> ?list quote
23:36:12 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
23:36:17 <sieni> @quote lambdabot
23:36:18 <lambdabot>  i 4M THe cooLES+ bo+ e\/eR
23:36:26 <sieni> @quote lambdabot
23:36:27 <lambdabot>  Of course i'm female
23:36:31 <nmessenger> ?protontorpedo
23:36:31 <lambdabot> can I build a sales database with it?
23:36:34 <sieni> ?quote lambdabot
23:36:35 <lambdabot>  donde alojan este bot, nerdos.com??
23:37:14 <dfranke> ?yhjulwwiefzojcbxybbruweejw
23:37:14 <lambdabot> Just 'J'
23:37:41 <nmessenger> ?help yhjulwwiefzojcbxybbruweejw
23:37:42 <lambdabot> V RETURNS!
23:37:47 <nmessenger> O RLY NOW?
23:38:03 <nmessenger> ?v
23:38:03 <lambdabot> Exception: <<loop>>
23:38:14 * nmessenger snickers
23:38:32 <LoganCapaldo> > isSane lambdabot
23:38:33 <lambdabot>  Not in scope: `lambdabot'
23:38:43 <nmessenger> ?type isSane
23:38:44 <lambdabot> Not in scope: `isSane'
23:38:59 <LoganCapaldo> Bot -> Bool
23:39:22 <nmessenger> const False?
23:39:51 <LoganCapaldo> unsafePerformSanity
23:39:59 <allbery_b> there's some history behind v / yhjulwwiefzojcbxybbruweejw --- involving playing games with early implementations of lambdabot
23:40:25 <Excedrin> ?yhjulwwiefzojcbxybbruweejw
23:40:26 <lambdabot> Exception: <<loop>>
23:40:29 <nmessenger> ?google yhjulwwiefzojcbxybbruweejw
23:40:30 <lambdabot> http://tunes.org/~nef/logs/haskell/06.07.20
23:40:33 <allbery_b> (that "> expr" thing used to use a temp variable called "v".  it got abused.  so it got renamed.  so someone discovered the new name...)
23:42:34 <nmessenger> industious little sprats
23:42:44 <nmessenger> s/ti/tri/
23:45:31 <fnord123> @type trace
23:45:32 <lambdabot> Not in scope: `trace'
23:45:43 <fnord123> @type Debug.Trace.trace
23:45:45 <lambdabot> forall a. String -> a -> a
23:45:46 <LoganCapaldo> > v
23:45:47 <lambdabot>  Not in scope: `v'
23:46:03 <nmessenger> > L.yhjulwwiefzojcbxybbruweejw
23:46:04 <lambdabot>  Not in scope: `L.yhjulwwiefzojcbxybbruweejw'
23:46:19 <nmessenger> > L.v
23:46:20 <lambdabot>  Not in scope: `L.v'
23:46:26 <fnord123> > import Debug.Trace
23:46:26 <lambdabot>  Parse error
23:46:41 <fnord123> :module +Debug.Trace
23:46:54 <nmessenger> ?m
23:46:54 <lambdabot> Maybe you meant: map messages messages? more msg . v
23:46:55 <fnord123> > :module +Debug.Trace
23:46:55 <lambdabot>  Parse error
23:47:58 <nmessenger> ?massages
23:47:59 <lambdabot> You don't have any new messages.
23:48:08 <nmessenger> But I want a massage!
23:48:48 <fnord123> when I try to trace something, I get an error saying the type im using doesn't satisfy IO t; i imagine it's trying to tell me that I dont have an instance of show on the the second param I'm giving it... am I reading the error properly?
23:49:18 <allbery_b> @paste -- send your code here
23:49:19 <lambdabot> http://paste.lisp.org/new/haskell
23:49:49 <LoganCapaldo> fnord123: just a guess, but it wants an IO t and you are giving it a t (e.g. a String instead of an IO String)
23:50:12 <fnord123> how might i convert a string to io string?
23:50:29 <lisppaste2> fnord123 annotated #33507 with "tracing troubles" at http://paste.lisp.org/display/33507#2
23:50:29 <nmessenger> return
23:50:48 <allbery_b> more generally you lift it into something already in IO
23:51:37 <allbery_b> let _ = trace ...
23:52:05 * fnord123 boggles
23:52:16 <allbery_b> since you're woking "inside" a monad, it's expecting a monadic expression.  use let to run pure code
23:52:28 <the_future> trace "hello" xxx   does not print the value of xxx.
23:52:33 <allbery_b> (in this case, it's expecting something in IO)
23:52:38 <LoganCapaldo> mmm paste.lisp.org matches parens (etc) and high lights them when you mouse over the innards. so cool
23:52:52 <the_future> trace "hello" xxx   evaluates to xxx after the side effect of printing out "hello".
23:52:59 <fnord123> i see now. it makes sense how you explain that but as far as interface to a library, it's very bizarre to me
23:53:23 <allbery_b> trace is intended for pure code.  when you;re already in IO, jusr use putStrLn
23:53:26 <nmessenger> trace ("response: " ++ resp) (return ())
23:53:28 <allbery_b> *just
23:54:29 <nmessenger> or, yeah: putStrLn ("response: " ++ resp)
23:55:02 <allbery_b> basicaly trace is a backdoor way to print trace information in a pure expression, you don't need it when already in the IO monad
23:55:05 <nmessenger> er, what is resp's type?
23:55:11 <emu> > let f x = (a,1) where ~(_,a) = x in fix f
23:55:12 <lambdabot>  (1,1)
23:55:37 <nmessenger> is it in Show?
23:55:55 <fnord123> hurrr, "print resp" works.
23:56:16 <nmessenger> then it is in Show.
23:56:33 <allbery_b> yeh, that too
23:56:51 <fnord123> sorry i was just reading a reddit article about someone having trouble trying to debug his code.. and dons responsed to it suggesting debug.trace... so i tried it out
23:58:01 <allbery_b> the problem is that you can only call e.g. print when you're already in the IO monad.  if you're not, you need something like Debug.Trace... or unsafePerformIO, but it's called "unsafe" for good reason.  best to use Debug.Trace instead
23:58:12 <emu> i usually use "trace foo $ return ()" if in a non-IO monad
23:58:58 <emu> if you isolate unsafePerformIO and understand the consequencse of using it, it's not so bad; debug.trace is basically that
23:59:16 <fnord123> thanks
23:59:18 <nmessenger> ($) is teh evil
23:59:34 <Cale> You should be aware though, that trace itself can introduce bugs into your code if you use it to print values from your computation.
23:59:34 <fnord123> why is it the evil?
