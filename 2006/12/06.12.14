00:00:26 <dons> 'it' ?
00:00:41 <dons> ambiguous variable: it. add a type signature
00:01:02 <kfish> ghci
00:01:21 <kfish> ie. if you were to write a program that wraps ghci so that, i dunno, you could use it over irc or something
00:01:50 <astrolabe> I guess if you do that 'evaluate this expression' call to ghc, it forgets state between calls?
00:01:51 <dons> ah right. so it reads with readline
00:01:58 <dons> and you can dump text in, and suck stdout back
00:02:10 <dons> whether this would mess with tab completion, line editing and so on
00:02:19 <dons> astrolabe: you'd have to fork it once, and then talk over a pipe
00:02:25 <dons> (i.e. like lamdbaWeb or goa)
00:02:41 <dons> since it should be identical to ghci, but coloured
00:02:53 <astrolabe> dons: right
00:03:45 <kfish> it would be nice to have the same color scheme i get in vim
00:03:59 <kfish> though yesterday when i was editing code, and the show-brackets cursor was following me around
00:04:03 <kfish> i felt like i was playing nethack
00:04:06 <dons> heh
00:04:25 <dons> what's the show-brackets :cmd gain?
00:04:25 <dons> again?
00:04:36 <dons> set showmatch
00:04:36 <astrolabe> Are you talking about deducing the colors from the ghci output text alone?
00:04:38 <dons> or something else?
00:04:44 <dons> astrolabe: that'd do, yes
00:04:48 <dons> (nad HsColour can do that)
00:06:31 <mwc> what's putStr.colour?
00:08:05 <astrolabe> programatica seems to have something
00:09:21 <astrolabe> at least they mention syntax highlighting here http://www.cse.ogi.edu/~hallgren/Programatica/
00:09:22 <lambdabot> Title: Haskell Tools from the Programatica Project
00:09:22 <dons> mwc, my proposed ansi-coloured printing routine :)
00:09:48 <dons> hehe "when was the last time you looked under the hood at the ruby interpreter? Have you been wondering what that strange smell was? Well its not the stink of justice if thats what youve been thinking."
00:10:28 <mwc> Last I heard Ruby just interpreted from AST
00:10:34 <mwc> not even a bytecode layer like Python
00:11:12 <kfish> gadz, if we don't have a ruby-on-rails killer by summer-of-code time, we'd better by the end of it
00:14:20 <dons> ah much better. adding "72.5.28.218   reddit.com
00:14:24 <dons> "makes reddit happy again
00:19:23 <mwc> we should brainstorm on how to extend HAppS with some automagical functionality
00:19:28 <mwc> that's all RoR is.
00:20:46 <dons> mm. I think shapr would be greatful for any help
00:20:52 <dons> and alexj
00:21:17 <mwc> I'm not a web guy so I have no idea what needs to be done
00:24:31 <kfish> dons: which projects do shapr and alexj work on?
00:24:37 <kfish> (web-related)
00:24:51 <mwc> that being said, I thought HAppS had some sort of magic that made a database appear as a Data.Set
00:25:17 <dons> shapr is employed to work on HAppS. so is musasabi, but he has been quite ill the last couple of months
00:25:25 <dons> alexj is the HAppS boss
00:25:46 <dons> ?where happs
00:25:46 <lambdabot> http://happs.org
00:25:50 <kfish> cheers
00:26:02 <kzm> @pl concat
00:26:03 <mwc> Oh man, what happened to musasabi?
00:26:03 <lambdabot> join
00:26:11 * kzm just had to try that.
00:26:13 <dons> now, with a couple of web people, we could actually turn HAppS into RoR
00:26:49 <mwc> I know they have some demo projects, there's a sort of password/user registration system
00:27:49 <sjanssen> there is a wiki example too
00:27:58 <dons> we should have someone working on HAppS at the hackathon
00:28:05 <dons> or someone should ask alexj for a job..
00:28:08 <sjanssen> http://www.scannedinavian.com/~shae/happswiki
00:28:10 <lambdabot> Title: Index of /~shae/happswiki
00:28:31 <sjanssen> that example helped me get the gist of HAppS programming
00:29:24 <Excedrin> after adding hSetBuffering stdout NoBuffering, sh -c 'ghci | HsColour -tty' almost works... there's a delay before hsColour decides something matches and then outputs
00:29:25 <mwc> wow, is that complete?!
00:29:45 <mwc> It's so small!
00:30:05 <kzm> It's not the size that counts, it's the functionality.
00:30:27 <sjanssen> mwc: all the markup parsing/formatting is handled by another module, so that helps the size
00:30:39 <mwc> kzm, if you want to compete with RoR in terms of the perception that it's easy to get your app off the ground, it does
00:30:50 <kzm> :-)
00:31:06 <mwc> that being said, "It's not the size of the army, but the fury of it's onslaught."
00:31:12 <mwc> *its
00:31:32 <dons> Excedrin: mmm. nice!
00:31:47 <kzm> Did you look at 'Links', btw?  The demos were convincing - I just wish I had a web application that needed writing.
00:31:51 <dons> Excedrin: we can tweak the lexer for lookahead too
00:32:28 <Excedrin> dons: I think it needs to output the characters I'm typing, then emit "move cursor back, emit color and string" or something
00:32:56 <Excedrin> unless it can decide without lookahead
00:32:59 <kzm> There was some talk (SoC project?) about HAppS and Ajax-type/client side stuff - what is the state of that?
00:33:14 <dons> Excedrin: ah yes
00:33:30 <dons> kzm, was completed. the Ajax generated for HSP
00:33:33 <kfish> kzm: HSP.ClientSide
00:33:38 <dons> but so far not used. needs tutorials and so on
00:33:47 <kzm> The usual problem :-)
00:33:51 <kfish> it's very nifty though, i had a quick play with it last week
00:33:56 <dons> since we're all marketers now, http://headrush.typepad.com/creating_passionate_users/2005/08/you_are_a_marke.html
00:33:58 <lambdabot> Title: Creating Passionate Users: You ARE a marketer. Deal with it., http://tinyurl.com/bz9oo
00:34:23 * dons is reading a lot about building open source communities :}
00:34:41 <kzm> Hmm.. Perhaps I should market my alignment code?  I looked at a java implementation, it's about the same size.
00:34:57 <dons> i particuarlly like: he who out-teaches, wins
00:35:11 <kzm> But that was one implementation of one algorithm, I have 2-3 implementations of a handful of algorithms.
00:36:15 <kzm> Of course, it's easy to compete against Java like: public static bool foo (x) { if (bar(x)==True) { return True; } else { return False; }}
00:36:54 <Excedrin> I don't know Java, but isn't that if equivalent to return bar(x)?
00:37:14 <kzm> In Haskell, you'd write:  foo = bar
00:37:29 <kzm> If anything at all, that is. :-)
00:38:22 <dons> kzm: hehe :)
00:38:43 <Excedrin> foo = bar isn't allowed in Java?
00:39:03 <Excedrin> (maybe 'public static bool foo = bar' since there's no type inference)
00:39:20 <mwc> dons, I can't imagine that haskell's community needs any work
00:39:24 <kzm> Not for functions.  You have to at least add some curly brackets, parentheses, and the three magic words: "public static <type>"
00:39:28 <mwc> We have the best community
00:39:51 <dons> hehe. good to know :)
00:39:56 <dons> release some more libraries! :)
00:40:15 <kzm> Java keeps the engineers busy, so they don't have time to develop opinions or have ideas, or anything.
00:40:27 <kzm> No wonder it's so popular with management.
00:40:41 <dons> its promising, haskell, I agree. the ruby guys are stalling on greenthreads, continutations. but haskell's not technologically limited, as far as I can see
00:40:58 <dons> we just need more libraries, and infrastructure. and not even much more
00:41:22 <kzm> It is improving *a lot*, I think.
00:41:57 <dons> ie. we know how to compile to native code (unlike ruby, perl, ...), we have abstractions that are 10 years away in other languages (parallel arrays, stm ,monads!). so all the technology is there.
00:42:02 <dons> now we just need libraries
00:42:09 <kzm> It's hard to notice the speed when you are conscious of your position, but imagine going back to ghc-4.something or old Hugs.
00:42:22 <dons> mmm. interesting idea!
00:43:29 <dons> huh, someone submitted my shower-time syntax thought to reddit...
00:43:35 <dons> blogs are fun !
00:44:04 <dons> so, the chicks should start calling soon, right?
00:44:37 * kzm thinks people dislike marketeers because they don't understand anything (well, at least from a technological perspective), and they still make a lot more money.
00:44:38 <TSC> Better get yourself a stick
00:44:43 <kzm> Feels unfair, somehow.
00:45:43 <Excedrin> the first one should have used fib instead of generate_fibonacci_sequence as the function name...
00:46:38 <dons> yeah, its not really supposed to be a comment on the names (though they're real world samples -- i didn't write them :)
00:46:51 <dons> more on the use of sigils/types/parens/clutter
00:47:02 <dons> things that aren't important to the human
00:48:12 <Excedrin> the perl one is a bit odd since it's possible to write it in the usual way..
00:50:16 <tibbe> morning
00:50:50 <kfish> hi tibbe
00:52:52 <mwc> Monads are the feature I most miss in other languages.
00:52:58 <mwc> Haven't had the chance to use much STM
00:53:02 <mwc> and what's a parallel array?
00:53:06 <dons> ?where dph
00:53:07 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
00:53:10 <dons> very new.
00:53:14 <dons> but possibly killer feature
00:53:20 <dons> not yet in a stable ghc
00:53:27 <mwc> I thought parallel haskell was moribund
00:53:51 <dons> pH was (but thankfully they did all the research for parallel ghc)
00:54:04 <dons> and now that $MS is paying for parallel arrays to be added, things are moooving
00:54:35 <dons> then expect DPH arrays to be stolen and added to LINQ or something ;)
00:54:40 <mwc> wow, that's really cool
00:55:20 <mwc> GHC is one of those things that I don't think MS really understands what they have.
00:56:33 <dons> yeah, possibly. though at least someone at MS research knows: they hired all the STM guys and the lead Haskell devs. so they're up to something..
00:57:10 <dons> adding monad comprehensions to LINQ/C# might be a hint as to what they're up to
00:57:17 <mwc> Still, it seems like Win32 benefits the least.
00:57:21 <mwc> Monad comprehensions?
00:57:36 <dons> yeah, linq is a monad language. check google :)
00:59:33 <mwc> lol
00:59:34 <mwc> so I just started spouting off about triangles and whatnot, waiting for their eyes to glaze over. That gave me the time to put together a plan. It?s just a skill I have I guess, my competitive side showing through. When everything came around again with LINQ I knew the geometry play would not be enough, so I tossed ?Monads? at them like a stun grenade. You should have been there.
01:00:43 <Svrog> i dont know whether its a good thing or a bad thing that they'll be adding all that stuff to .net..
01:01:16 <Svrog> cause what will happen is that existing c# developers will just go "why should i use something else when c# can do it?"
01:02:04 <dons> luckily they crippled their monads
01:02:10 <dons> no typeclasses ;)
01:02:31 <Svrog> yeah but there's still gonna be the same problem
01:02:49 <Svrog> in fact it will be even harder to explain the difference
01:03:25 <Svrog> and even though they added that stuff to c# i suspect most c# programmers will avoid it for the most part
01:04:22 <kfish> Svrog, if a future version of C# did everything haskell does, ie. if the two were isomorphic, then we win
01:04:27 <kfish> and if it doesn't, then we win anyway
01:04:45 <Svrog> nah c# will never be haskell
01:05:03 <mwc> C# is just java with hindsight
01:05:16 <Svrog> c# is imo even worse than java in heaps of ways
01:05:57 <Svrog> java had far less syntax - c# is full of redundancy and the standard library is often more brain damaged than the java one
01:06:06 <Svrog> not that i like java
01:06:22 <Svrog> but c# to me seems like a step side-ways and then half a step backward
01:06:52 <goltrpoat> hmm.. i hate java, but don't particularly mind c#
01:11:58 <vincenz> dons: ping
01:13:47 <dons> yeah
01:13:57 <vincenz> dons: does that script work for multiline definitions?
01:14:08 <dons> HsColour?
01:14:11 <vincenz> like if you have a few alternatives
01:14:11 <Svrog> i hate the approach to programming language design where features are tacked onto a base language derived from mainstream languages - what you end up with is either a language with the same limitations as the mainstream languages it was based on or a big mess - often both
01:14:15 <vincenz> no the type-adding one
01:14:25 <dons> yeah
01:14:47 <dons> it just loads your module in ghci, and asks for the type of the top level decl on the current line
01:14:56 <dons> inserting the type on the line above
01:15:02 <vincenz> right
01:15:04 <vincenz> but if you run this on a file
01:15:07 <vincenz> and have two lines:
01:15:09 <vincenz> foo 0 = ..
01:15:11 <vincenz> foo 1 = ..
01:15:17 <vincenz> won't you get two type-defs?
01:15:20 <dons> it'll ask ghci for the type of 'foo'
01:15:32 <dons> getting back a string, which will be inserted above the line your cursor is on
01:15:48 <vincenz> oh
01:15:51 <vincenz> it's not for full-file at once
01:15:56 <dons> no
01:16:00 * vincenz misread that bit
01:16:12 <vincenz> okies
01:16:21 * sjanssen would like to see a script that does that
01:16:38 <vincenz> sjanssen: prolly some awking
01:16:38 <dons> yeah, seems doable
01:16:51 <dons> parse the file, grab al top level decls. infer the types, splice them bac
01:17:05 <dons> typ som mor char
01:17:32 <sjanssen> might be simple with GHC API, but I've never used it
01:17:36 <dons> sjanssen: any thoughts on colour ghci
01:18:02 <mwc> dons, sounds like a job for yi
01:18:37 <dons> actualy, Lemmih might now. he's already written the parser/quickcheck thingy that uses ghc-api
01:18:40 <dons> s/know/
01:27:08 <dons> whoa, cool, http://64.233.179.104/translate_c?hl=fr&sl=en&u=http://www.haskell.org/haskellwiki/Haskell&prev=/search%3Fq%3Dwww.haskell.org%26hl%3Dfr%26lr%3D%26sa%3DG
01:27:11 <lambdabot> Title: Haskell - HaskellWiki, http://tinyurl.com/ykcrm6
01:29:29 <Lemmih> Woot, I'll be attending HUMIDITÉ, yay.
01:30:52 <dons> hehe me too!
01:31:55 <dons> ?users
01:31:56 <lambdabot> Maximum users seen in #haskell: 288, currently: 259 (89.9%), active: 27 (10.4%)
01:35:00 <roconnor> TFP is in New York?
01:35:31 <dancor> has anyone written a shell in haskell
01:35:36 <dancor> bashlike
01:35:56 <dancor> hash
01:35:59 <dons> dancor: yeah, a couple
01:36:10 <dons> check haskell.org's libraries page, under 'operating systems'
01:36:14 <dons> they're all toys though (afaik)
01:36:32 * kfish is still waiting for his copy of "Advanced Haskell Programming in the UNIX Environment" to arrive
01:37:08 <dons> mmm :)
01:37:30 <dons> I remember reading an old old copy of 'Advanced String Programming in C' as an undergrad, sitting in the unsw library..
01:37:39 <dancor> hm i see haskell-ls and h4sh
01:37:40 <dons> i wonder if there's a book there.. oh wait, no. its about 20 lines of code
01:37:51 <dancor> oh i see more
01:38:00 <Binkley> kfish: hmm, maybe that's a good title :-)
01:38:18 <dons> Advanced Parallel Programming in Haskell
01:38:35 <dons> Higher-kinded types for dummies
01:38:43 <Binkley> dons: you're really going for a broad audience there
01:38:45 <dons> heh
01:39:10 <dons> Teach yourself applicative functors in 24 hours
01:39:27 <dons> Type inference for GADTs in a nutshell
01:39:31 <dons> it's all good!
01:39:34 <mwc> What Kernighan didn't teach you and Ritchie didn't know
01:39:35 <Binkley> rated NC-17: you must have at least 17 PhDs to read this book
01:39:48 <dons> heh
01:39:57 <Binkley> Then again, who am I to be talking
01:40:02 <Binkley> Simon Peyton Jones just called me "superhuman"
01:40:29 <mwc> Binkley, that makes you a metasuperhuman?
01:40:37 <Binkley> mwc: I never metasuperhuman I didn't like
01:40:56 <dons> heh
01:41:00 * mwc smacks Binkley with the trout of bad pun
01:41:04 <vincenz> @remember Binkley I never metasuperhuman I didn't like
01:41:27 <Binkley> I can get a *lot* worse than that
01:44:31 <seba> > [1..10]
01:44:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:46:47 <dons> hey seba. learning haskell?
01:48:40 <Masklinn> hello everybody
01:49:58 <Lemmih> Hiya Masklinn.
01:50:48 <kfish> dons: does hmp3 work with ogg123?
01:51:48 <kfish> ?where hmp3
01:51:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
01:52:33 <dons> nah, it doesn't have a remote control mode (last time I checked)
01:52:46 <kfish> dons: what would be required?
01:52:57 <kfish> i've kind of ended up maintaining vorbis-tools recently ...
01:53:27 <dons> the remote control mode to mpg{123,321} is a short of shell. you feed it keystrokes for skipping to frames, play, pause and so on
01:53:32 <dons> and it feeds back frame numbers
01:53:43 <dons> now, multiple backends probably wouldn't be too hard
01:53:55 <dons>  i.e. you could plug in library backends and so on
01:54:09 <dons> but if og123 had a remote control mode, it'd be like a 5 line hack to add hmp3 support
01:57:32 <kfish> cheers
01:57:34 <kfish> https://trac.xiph.org/ticket/1109
01:57:43 <vincenz> dons: I guess the future syntax will be haskell with more latexy symbols
02:00:07 <dons> kfish: nice. let me know if you need more info
02:00:17 <kfish> dons: i will :-)
02:00:28 <dons> i'd like to switch over to ogg, but don't have quite enough motivation to hack hmp3's backend completely
02:01:19 <kfish> sure, i imagine it should be fairly straightforward to add to ogg123, and useful for apps other than hmp3 also
02:01:49 <kfish> s/be fairly straightforward/take an entire weekend of C hacking/
02:03:58 <dons> yeah. I think so.
02:04:28 <dons> remote.c is 230 lines of C in mpg321
02:04:57 <dons> kfish: http://www.cse.unsw.edu.au/~dons/tmp/remote.c
02:07:15 <kfish> dons: ta :-)
02:08:32 <dons> kfish: here's the 'spec' I followed from mpg321 to implement the binding, ttp://www.cse.unsw.edu.au/~dons/tmp/remote.txt
02:08:41 <dons> (its not bad for a text interface, actually)
02:10:37 <kfish> dons: ok thanks, i've attached those two files to the ticket
02:11:21 <kfish> and re-assigned to myself lol
02:12:28 <dons> messages you don't like to see in /var/log/ :  Dec 14 20:35:57 habanero /bsd: pppoe (data): unknown version/type packet: 0xb1
02:15:34 <kfish> dons: looking at the @O and @I stuff, i assume it doesn't make any other output (ie. the normal UI is suppressed)?
02:19:28 * kfish plays with mpg123 ...
02:22:31 <vincenz> Is this a good book: "Haskell Road to Logic, Maths and Programming"
02:26:58 <kfish> dons: the README for hmp3 does not mention running ./configure, but if I don't then I get errors in building Regex.hsc (regex_t not found, because HAVE_REGEX_H is not defined)
02:27:31 <seba> can anyone help me understand monads?
02:28:03 <seba> i have a question about an example in the "tackling the awkward squad" tutorial
02:28:06 <kfish> dons: though once I've run ./configure once by hand, after that "./Setup.hs configure" runs it automatically
02:28:19 <kfish> seba, shoot, we're happy to help
02:28:44 <kfish> shoot == please ask :-)
02:29:31 <profmakx> let shoot = please ask in seba, shoot, we`re happy to help
02:29:31 <profmakx> ?
02:29:40 <seba> ok, I'm trying to understand how a value is extracted from a monad and passed on to a function.
02:29:43 <seba> for example,
02:30:09 <seba> in syntaxfree's blog there is this example
02:30:10 <seba> http://syntaxfree.wordpress.com/
02:30:13 <lambdabot> Title: Data.Syntaxfree
02:30:23 <seba> shout = getLine >>= (putStr . map toUpper)
02:30:49 <earthy> seba: that's the trick. The value *isn't* extracted
02:31:06 <seba> but it is passed to toUpper at some point, no?
02:31:17 <earthy> yah
02:31:33 <seba> I'm trying to understand what happens to the types of things
02:31:34 <earthy> but map toUpper is encapsulated inside the monad
02:31:53 <earthy> that's what >>= does
02:32:18 <earthy> it 'encapsulates; the action
02:32:28 <seba> let me see if I get this. the >>= gets toUpper and encapsulates it inside the monad, ok?
02:32:35 <earthy> almost
02:32:57 <earthy> the >>= gets (putStr . map toUpper) and encapsulates that in its entirety inside the monad
02:33:31 <dons> kfish: ./Setup.hs configure should run ./configure -- if its executable
02:33:34 <seba> nope, didn't get it :)
02:33:40 <dons> newer cabals do this by hand
02:33:48 <seba> i'm not sure i understand what "encapsulate" means
02:34:04 <earthy> seba: shout = getLine >>= (return . map toUpper) >>= putStr
02:35:08 <seba> almost rings a bell
02:35:10 <earthy> do you understand how return . map toUpper has type  String -> m String  ?
02:35:21 <seba> yes
02:35:39 <seba> returns gets a type and encapsulates it in the monad, right?
02:35:42 <Saulzar> The (putStr . map toUpper) bit as a whole is a function String -> IO b  --  the >>= is plumbing passing the string, it is restricted to functions which encapsulate the result in the monad again. (thus the type IO b)
02:35:56 <earthy> return gets a *value* and encapsulates it in the monad
02:36:16 <seba> ok
02:36:37 <kfish> dons: ah ok, that's it then -- d'oh
02:36:44 <earthy> now, >>= takes a *function* and encapsulates its action in the monad
02:37:03 <Saulzar> Hmm. What would be the most normal way to pass a C++ string to Haskell? Allocate a char * then free the CString on the Haskell side?
02:37:11 <earthy> to allow it to do so, the result type of the function should already be in the monad
02:37:37 <earthy> the monad then specifies how the encapsulated functions are applied, if at all
02:38:08 <earthy> in the case of IO, the >>= can be read as a sequencing operator
02:38:34 <earthy> does this help at all, seba?
02:38:46 <seba> yup
02:40:32 <earthy> anyway, time to attend a talk on functional guis. :)
02:40:59 <seba> things are a little clearer now
02:44:14 <seba> earthy, how should I think of this plumbing in terms of types?
02:48:17 <roconnor> How do I get ls to tell me the total size of all my *.vo files in the directory?
02:50:10 <ms_> let a=0; for t in $(ls -l *.vo | awk '{print $9}'); do let a=$a+$t; done; echo $a
02:50:27 <ms_> but check that the size is the 9th column in your ls -l output
02:50:40 <ms_> ahh, it's fifth for me here
02:51:04 <ms_> or du -s *.vo
02:51:09 <ms_> which is a bit shorter
02:51:39 <kfish> du -sc *.vo
02:51:52 <kfish> -c for the total
02:51:59 <roconnor> thanks
02:52:20 <ms_> and h for human output
02:52:35 <seba> > :t getLine
02:52:36 <lambdabot>  Parse error
02:52:38 <roconnor> du -sch *.vo is also good
02:53:09 <kfish> > kill all humans
02:53:11 <lambdabot>  Not in scope: `humans'
02:53:57 <goltrpoat> get a better scope then
02:54:51 <goltrpoat> k, that sounded a lot funnier in my head.
02:55:25 <Masklinn> well i've heard much worse
02:55:32 <Masklinn> made me smile, so don't feel too bad
02:59:02 <swiert> does anyone know if hSetBuffering is supposed to work under Hugs?
02:59:13 <swiert> It doesn't seem to change anything.
02:59:25 <vincenz> Heh
02:59:31 <vincenz> French television made the Belgians revolt
02:59:44 <vincenz> And the US took the fiction item as fact
03:00:09 <vincenz> They faked a documentary where it stated that belgian split in two
03:00:21 <vincenz> with interviews of belgian politicians pulled out of context
03:00:28 <vincenz> belgium even
03:00:59 <vincenz> Only after the first half hour was there a small disclaimer stating it was fiction (cause they interrupted the news for their "special bulletin")
03:20:01 <araujo> morning!
03:25:12 <vininim> Okay, I did Nim. Next game? please?
03:25:26 <vininim> *made
03:26:43 <dons> vininim: do you want to stick the code up on the wiki?
03:26:45 <dons> say,
03:26:50 <dons> ?wiki Nim
03:26:51 <lambdabot> http://www.haskell.org/haskellwiki/Nim
03:27:03 <dons> would be a pretty cool contribution
03:27:06 <seba> > [1..]
03:27:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:44:04 <vininim> dons:  it's ugly and uses IORef :/ (but I could after some cleaning up)
03:45:52 <dons> I'd stick it on the wiki still.
03:45:58 <dons> you'll at the worst get a clean up
03:59:41 <dons> Pupeno++ http://pupeno.com/blog-en/the-lambda-revolution-episode-v-the-deb-strikes-back
03:59:45 <lambdabot> Title: The lambda revolution, Episode V, the deb strikes back &mdash; Pupeno's web site, http://tinyurl.com/wo6yp
03:59:50 <dons> (turning a .cabal package into .deb)
04:00:07 <dons> ?users
04:00:08 <lambdabot> Maximum users seen in #haskell: 288, currently: 260 (90.3%), active: 22 (8.5%)
04:01:15 <Pupeno> :)
04:03:41 <Pupeno> lambdabot should interpret the &mdash; and show them as mdashes
04:03:52 <dons> ah, yes, it should
04:04:12 <Pupeno> or, well, all the HTML entities...
04:04:57 * Pupeno goes to fetch lambdabot sources
04:05:56 <dons> yeah, there's some stub code in there, but it obviously doesn't work very well
04:06:06 <dons> look at urlPageTitle in Lib/Url.hs
04:06:16 <dons> looks easy to fix
04:10:38 <therp> I have an outdated GHC tree with a lot of modifications. are there any benefits from recording my patches before darcs pulling?
04:17:18 <kfish> therp: i'd imagine that your patchset would be more simple now than if you recorded after pulling (but I'm not too familiar with how darcs actually works)
04:18:27 <therp> kfish: well, it shouldn't change much except for conflicts/API changes. I was just wondering whether there is a benefit for pulling
04:20:22 <JaffaCake> kzm: http://www.haskell.org/pipermail/cvs-ghc/2006-December/033164.html
04:20:25 <lambdabot> Title: patch applied (ghc): Rework the block allocator, http://tinyurl.com/yxhd4l
04:20:34 <JaffaCake> I think this should fix your bug #743
04:20:41 <JaffaCake> any chance you could test it?
04:20:59 <JaffaCake> the patch pulls into a 6.6 tree without any dependencies
04:29:21 <dons> JaffaCake: would would you think if I hacked up a --colour flag to ghci, to ansi highlight  output, a la http://haskell.org/haskellwiki/GHCi_in_colour ?
04:29:21 <edwinb> How can I get cabal to not delete intermediate files? I'm trying to work out why haddock is failing on a .lhs file...
04:29:25 <lambdabot> Title: GHCi in colour - HaskellWiki
04:29:38 <dons> basically, the putStr's in InteractiveUI.hs become putStr.colour if --colour is set
04:29:54 <earthy> cool! Dazzle *finally* has given me a result!
04:31:34 <vincenz> dons: How does that work exactly with live input?
04:31:54 <edwinb> oh, never mind, I've fixed it by arbitrarily changing things
04:32:04 <dons> i'm not sure it would highlight iput, only output
04:32:16 <vincenz> ah right, was looking at the wiki page :)
04:33:55 <earthy> now, to bring the calculation for the full set down from 5000 hours to something reasonable.
04:39:02 <JaffaCake> dons: re: colorising GHCi output, sure - I've had random thoughts about that in the past, one problem is the pretty printer which is pretty hardwired to fixed-width fonts, so it would have to be told about invisible control characters
04:39:46 <JaffaCake> I suppose you could post-process the output of the pretty printer though, maybe that's what you had in mind
04:39:56 <earthy> can't it be told that certain characters have width zero?
04:40:10 <earthy> I presume certain blocks in the pretty printer have width zero...
04:40:21 <JaffaCake> earthy: probably yes, but I don't think anyone actually understands how the pretty printer works any more :)
04:40:22 <roconnor> @google 1 kilobyte in bytes
04:40:24 <lambdabot> 1 kilobyte = 1,024 bytes
04:40:28 <roconnor> hmmm
04:40:29 <earthy> 'ah' ;)
04:40:34 <roconnor> the IEEE wouldn't agree
04:40:35 <earthy> time for a rewrite using combinators, then. :)
04:40:57 <roconnor> @google 1 kibibyte in bytes
04:40:58 <lambdabot> 1 kibibyte = 1,024 bytes
04:41:02 <JaffaCake> well it does use combinators...
04:41:03 <Masklinn> lol
04:41:05 <earthy> that's an SI standard, rather than IEEE
04:41:12 <earthy> jaffacake: but the combinators are stale
04:41:19 <earthy> ?
04:41:24 <JaffaCake> they do smell a bit funny, that's true
04:41:35 <roconnor>  IEEE 1541-2002 (Prefixes for Binary Multiples)
04:41:41 <earthy> wow
04:42:01 <earthy> and they don't have backwards compatibility?
04:44:48 <roconnor> I wish google calculator accepted other units like pages, dots, or cows.
04:45:23 <Pupeno> dons: I supouse http://www.cse.unsw.edu.au/~dons/lambdabot is the unstable/development branch, right ? is it stable enough to work on it ?
04:45:24 <lambdabot> Title: Index of /~dons/lambdabot
05:02:06 <earthy>  2405 dazzle       0.3%  9:56:38   3   109  1086   200M  16.9M   207M  1.03G
05:02:30 <earthy> anyone telling me haskell can not be used in the real world is crazy. :)
05:05:32 <ventonegro> > msum [(Just 5), Nothing, (Just 10)]
05:05:34 <lambdabot>  Just 5
05:06:37 <ventonegro> > msum [[0..5], [], [0..10]]
05:06:38 <lambdabot>  [0,1,2,3,4,5,0,1,2,3,4,5,6,7,8,9,10]
05:06:56 <Syzygy-> > msum [(Just 5), (Just 10), Nothing, Just 5]
05:06:58 <lambdabot>  Just 5
05:07:11 <Syzygy-> > msum [(Just 5), (Just 10), Nothing]
05:07:13 <lambdabot>  Just 5
05:07:31 <Syzygy-> Wha? So msum doesn't sum up to the first Nothing?
05:08:11 <ventonegro> i guess it ignores mzeros and go on
05:09:10 <Syzygy-> But then I should have gotten Just 15, shouldn't I?
05:09:21 <Syzygy-> msum [Just 10, Just 5, Nothing]
05:09:24 <Syzygy-> > msum [Just 10, Just 5, Nothing]
05:09:26 <lambdabot>  Just 10
05:09:32 <Syzygy-> It seems to work like head...
05:09:37 <Syzygy-> > msum [Just 10, Just 5, Just 2]
05:09:38 <lambdabot>  Just 10
05:09:42 <Syzygy-> Oh....
05:09:45 <ventonegro> the Maybe MonadPlus instance does not sum the datatypes
05:09:49 <Syzygy-> Right.
05:10:01 <ventonegro> what if it's not a number?
05:10:53 <ventonegro> > msum [Nothing, Nothing, Just 2]
05:10:55 <lambdabot>  Just 2
05:12:43 <ventonegro> > msum ["al", "", "ex"]
05:12:44 <lambdabot>  "alex"
05:13:13 <ventonegro> much better than concat $ filter (not.null) :-)
05:14:03 <Syzygy-> > join [Nothing, Just 2, Nothing, Just 5
05:14:04 <lambdabot>  Parse error
05:14:06 <Syzygy-> > join [Nothing, Just 2, Nothing, Just 5]
05:14:07 <lambdabot>  Couldn't match `[a]' against `Maybe a1'
05:14:33 <ventonegro> > join Just (Nothing)
05:14:34 <lambdabot>  Couldn't match `a1 -> a' against `Maybe a1'
05:15:30 <ventonegro> > join Just (Just 5)
05:15:31 <lambdabot>  Couldn't match `a1 -> a' against `Maybe a1'
05:15:48 <ventonegro> @type join
05:15:49 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
05:16:06 <ventonegro> > join $ Just (Just 5)
05:16:07 <lambdabot>  Just 5
05:16:14 <ventonegro> > join $ Just (Nothing)
05:16:15 <lambdabot>  Add a type signature
05:16:24 <ventonegro> > join $ Just (Nothing) :: Maybe Int
05:16:25 <lambdabot>  Nothing
05:27:04 <kzm> @seen JaffaCake
05:27:05 <lambdabot> JaffaCake is in #ghc and #haskell. I last heard JaffaCake speak 45m 42s ago.
05:33:10 <dons> ?users
05:33:11 <lambdabot> Maximum users seen in #haskell: 288, currently: 270 (93.8%), active: 23 (8.5%)
05:33:26 <kzm> @tell JaffaCake Sorry about the delay, I've been a bit swamped today.  Building ghc now.
05:33:27 <lambdabot> Consider it noted.
05:33:57 <dons> mm, the 99 exercises are almsot done!
05:34:04 <dons> http://haskell.org/haskellwiki/99_Haskell_exercises
05:34:05 <lambdabot> Title: 99 Haskell exercises - HaskellWiki
05:34:56 <dons> anyone looking for something to hack on today, could look at the missing ones...
05:35:10 <dons> the ones after 50 look fun..
05:41:49 <roconnor> what happend to problem 38?
05:42:39 <dblhelix> roconnor: great title for a detective story!
05:43:41 <dons> P38. 'Use the solutions of problems P34 and P37 to compare the algorithms'
05:43:50 <dons> not a programming puzzle I guess
05:51:30 <huschi> `fromDouble' is not a (visible) method of class `Fractional'
05:51:41 <huschi> can anybody explain this?
05:53:09 <integral> afaik that means you haven't imported "fromDouble"
05:53:20 <mauke> what's fromDouble?
05:54:02 <huschi> integral: but it is exported from the prelude.
05:54:10 <mauke> whoa, since when?
05:54:17 <integral> huschi: But did you import it?
05:54:21 <mauke> it doesn't exist in ghci or hoogle
05:54:39 <huschi> integral: yes, i did.
05:54:41 <integral> (You can put something in the export list, but then not import it)
05:55:32 <huschi> Numeric/Diff.hs:4:16: Module `Prelude' does not export `Fractional(fromDouble)'
05:55:50 <huschi> and also
05:55:51 <huschi> Numeric/Diff.hs:4:16: Module `Prelude' does not export `fromDouble'
05:56:06 * integral wonders what fromDouble is anyway
05:56:07 <huschi> is it possible that this function is obsolete?
06:00:44 <Masklinn> hello again
06:02:48 <Nick1> hi everyone
06:03:22 <dons> hi Nick1
06:03:29 <dons> learning haskell?
06:03:42 <Nick1> yes
06:03:54 <Nick1> im very new to algebra programming
06:04:08 <dons> you've seen http://haskell.org ?
06:04:09 <lambdabot> Title: Haskell - HaskellWiki
06:04:15 <dons> (a good place to start your adventure!)
06:04:35 <dons> > fix ( (1:) . scanl (+) 1 ) -- and introducing lambdabot
06:04:37 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
06:04:50 <dons> :t map -- who can help you out
06:04:51 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
06:04:53 <dons> ?docs Data.List
06:04:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:04:57 <dons> find things for you.
06:05:01 <dons> ?source Data.List
06:05:01 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:05:03 <dons> and more :)
06:05:10 <ventonegro> Nick1, don't start with the "tutorial" in haskell.org
06:05:26 <Nick1> yes, but the thing is my problem is not actually related to programming in haskell
06:05:36 <Nick1> its more about math i think
06:05:37 <ventonegro> start with "write yourself a scheme interpreter in 48hrs" or "yet another haskell tutorial"
06:05:39 <dons> ok :)
06:05:51 <dons> ventonegro: you mean haskell.org/tutorial ?
06:05:59 <ventonegro> dons, yep
06:06:13 <dons> is that even findable from the main haskell.org page now?
06:06:20 <ventonegro> dons, that tutorial was the reason i gave up haskell for a couple of months
06:06:23 <dons> I think we're pretty clear on stearing towards yaht these days
06:06:45 <dons> oh, hehe. the 'gentle intro' is not so gentle, everyone says
06:07:09 <dons> ventonegro: but if you start at http://haskell.org, do you end up at the right tutorials?
06:07:10 <lambdabot> Title: Haskell - HaskellWiki
06:07:17 <dons> (just have a look now, and let me know)
06:07:35 <dons> Nick1: ok, haskell's quite good for playing with math
06:07:49 <dons> we even have a sub-community of mathematicians working in haskell
06:07:57 <ventonegro> haskell.org > getting started > books and tutoriais > gentle introduction
06:08:06 <profmakx> sub-category ^^
06:08:07 <Nick1> oh thats really nice
06:08:27 <Nick1> where can i get help from that community ?
06:08:28 <dons> these guys, http://haskell.org/haskellwiki/Haskell_and_mathematics
06:08:29 <lambdabot> Title: Haskell and mathematics - HaskellWiki
06:08:48 <ventonegro> this path can lead newbies to think that if they can't understand a gentle tutorial, they must be stupid :-)
06:08:55 <dons> mmm
06:09:04 <dons> ah ok.
06:09:13 * dons twaks that a bit
06:09:28 <dons> ?google write yourself a scheme interpreter in 48
06:09:30 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
06:09:31 <lambdabot> Title: Write Yourself a Scheme in 48 hours
06:09:59 <Nick1> thank you
06:10:11 <Syzygy-> dons: What was the tweakneedy?
06:10:19 <Syzygy-> Nick1: You could always poke me... :)
06:10:25 <kzm> Hmm alex doesn't compile.  LALR.lhs:626:34: Not in scope: `bounds'
06:10:29 <kzm> Any suggestions?
06:10:45 * Syzygy- wrote ... 4 of the linked blog posts, and at least one of the top-page quotes. :P
06:10:46 <kzm> happy, I mean.
06:10:51 <kzm> s/alex/happy.
06:10:52 <Nick1> does anyone know about algebraic methods for optimization problem ?
06:11:02 <Syzygy-> Oh, optimization. Then you won't want to ask me.
06:12:31 <dons> kzm, you need the darcs/snapshot version of happy
06:12:42 <dons> Syzygy-++ ;)
06:12:55 <dons> ventonegro: how's this: http://haskell.org/haskellwiki/Books_and_tutorials#Introductions_to_Haskell
06:12:59 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
06:13:03 <dons> they're the recommended texts these days, no?
06:13:20 <kzm> Okay.  Any clue where it can be obtained?  AFAICS, there is no mention of darcs on the happy web pages...
06:13:47 <dons> darcs.haskell.org/happy -- I think
06:13:59 <ventonegro> dons, much better!
06:14:10 <dino-> Still trying to build gtk2hs. I'm now getting 'ghc-6.6: unknown package: mtl (dependency of cairo-0.9.10.2)' from make, but I have libghc6-mtl-dev installed. :/
06:14:38 <Nick1> does anyone understand this ? http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/acmmpc-optimization.pdf
06:14:41 <lambdabot> http://tinyurl.com/y7thr7
06:15:07 <Nick1> i am kinda desperate now  lol
06:15:32 <Nick1> i hv been reading that paper for a few days now and still dont understand any of it
06:15:50 <dons> probably some people do understand the entire paper. but you'll have to ask a specific question. so you're studying the algebra of programming?
06:16:08 <kzm> dons++ thanks.
06:16:11 <dons> actually, for this kind of thing, it might even be better to ask on haskell-cafe@haskell.org
06:16:25 <Nick1> i see
06:16:33 <dons> Nick1: since you're looking for an extended answer regarding details of the paper?
06:16:35 <ventonegro> @karma dons
06:16:36 <lambdabot> dons has a karma of 98
06:17:07 <Nick1> i see
06:17:08 <ventonegro> dons++
06:18:03 <Nick1> like can anyone explain whats greedy theorem and thinning theorem ?
06:18:33 <therp> dons: what's the time please :) ?
06:19:32 <dons> ?time therp
06:19:33 <lambdabot> Local time for therp is Thu Dec 14 15:13:40
06:19:38 <therp> dons++
06:19:40 <dons> ?yow!
06:19:41 <lambdabot> GOOD-NIGHT, everybody ... Now I have to go administer FIRST-AID to my
06:19:41 <lambdabot> pet LEISURE SUIT!!
06:19:45 <dons> this is very exciting
06:20:03 <therp> @karma dons
06:20:04 <lambdabot> dons has a karma of 100
06:20:13 <dons> oh my. how embarrasing :}
06:20:25 <dons> what have I done with my life!?
06:20:29 <kzm> @time kzm
06:20:30 <lambdabot> Local time for kzm is Thu Dec 14 15:14:39
06:20:39 <therp> @karma therp
06:20:41 <lambdabot> You have a karma of 1
06:20:41 <dons> edit the wiki, apparently ;)
06:20:44 <therp> dons: more than me :)
06:21:03 <kzm> To edit the trac wiki, guest/guest doesn't seem to work?
06:21:06 <dino-> Is there more to installing the mtl stuff than libghc6-mtl-dev?
06:21:18 <dons> dino-: shouldn't be
06:21:22 <kzm> The building ghc guide needs repair, it seems.
06:21:23 <dons> are you using --make to build it?
06:21:28 <dons> dino-: check the:  ghc-pkg list
06:21:31 <dons> output, that it include mtl
06:21:39 <dons> kzm, oh?
06:21:50 <dons> (should just be: autoreconf ; ./configure ; make)
06:22:28 <dino-> dons: mm, it includes: mtl-1.0
06:22:46 <dino-> I've got 1.0-3 installed.
06:22:49 <kzm> Well, that didn't work so well.  I had to get alex and happy - happy from darcs, to which there are no pointers.  Also, make hinted at "sh darcs-get all", which isn't mentioned anywhere else, it seems.
06:22:51 <dons> hmm. rerun the configure step then?
06:23:04 <dons> kzm ah yes. so things have changed just a little
06:23:11 <dons> once happy is released again that goes away
06:23:18 <dons> the darcs-get stuff is on the ghc wiki
06:23:23 <dons> but maybe not in the building guide?
06:24:28 <kzm> Well - I'm too lazy to read the whole wiki, so I just read the quick thingy, which basically says what you did.
06:25:04 <kzm> It's okay when there are people on IRC to ask, but a bit frustrating otherwise.
06:25:14 <kzm> I'd fix it, but can't seem to log in.
06:26:10 <kzm> make[1]: *** [stage1/main/ErrUtils.o] Floating point exception
06:26:15 <kzm> Whooh.
06:26:22 * kzm slaps forehead.
06:26:55 * kzm gets what he deserves for compiling with a dev. snapshot compiler.
06:28:24 <kzm> Anyway - no more time.  Back tomorrow!
06:39:38 <dino-> Eh, I'm a dork. All I had to do was clean, reconf and build again from scratch.
06:40:00 <opqdonut> "have you tried turning it on and off again?" ;)
06:40:11 <dino-> Probably things missing at autoconf time dorked it.
06:40:34 <dons> yeah
06:40:52 <dons> that's why I said: 01:17  dons> hmm. rerun the configure step then?   ;)
06:41:21 <dino-> dons: Sorry, missed that or perhaps assumed it as directed at someone else.
06:41:22 <dons> dino-: so it builds now?
06:41:31 <dino-> dons: It built successfully, yes.
06:41:33 <dons> great!
06:41:51 * dons hands around the celebration lambda candies
06:42:18 <dino-> I'm relieved. Working on a small puzzle game that absolutely has to have graphics.
06:42:26 <dons> no, not these ones: http://www.cse.unsw.edu.au/~pls/images/pls-small.png !
06:42:30 <dons> dino-: cool
06:42:36 <glguy> ?docs Text.XHtml
06:42:36 <lambdabot> Text.XHtml not available
06:42:36 <dons> using gtk2hs?
06:42:50 <glguy> ?fptools Text.XHtml
06:42:51 <lambdabot> Text.XHtml not available
06:43:00 <glguy> What am I missing here?
06:43:14 <dons> glguy: its in what, HAXML?
06:43:17 <dons> or some other library?
06:43:31 <dons> (I don't know of an XHtml module in the base libs)
06:43:37 <glguy> I don't know, there is an xhtml library in visual haskell
06:43:47 <dons> dino-: if you're writing games, have you seen: http://haskell.org/haskellwiki/Libraries_and_tools/Games
06:43:48 <lambdabot> Title: Libraries and tools/Games - HaskellWiki
06:43:51 <dons> glguy: ah, its in xhtml then!
06:43:53 <dons> ?where xhtml
06:43:54 <lambdabot> I know nothing about xhtml.
06:43:57 <glguy> heh
06:44:03 <dons> (its on bjorn's page)
06:44:07 <dons> ?google bringert xhtml
06:44:11 <lambdabot> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml/doc/
06:44:16 <dons> gotcha!
06:44:25 <dons> ?where+ xhtml http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml
06:44:26 <lambdabot> Done.
06:46:54 <ms_> @paste
06:46:55 <lambdabot> http://paste.lisp.org/new/haskell
06:47:21 <xinming> If we have 2 lists, one is [1, 7, 8, 4] another is [1..9] How can I get the list which lacks in list [1, 7, 8, 4] please?
06:47:21 <dons> I have this in my shell, alias paste="w3m http://paste.lisp.org/new/haskell"
06:47:27 <xinming> In haskell,
06:47:35 <xinming> I wonder if there is a function
06:47:41 <dons> > [1..9] \\ [1, 7, 8, 4]
06:47:49 <lambdabot>  [2,3,5,6,9]
06:47:54 <xinming> Thanks. :-)
06:47:59 <dons> :)
06:48:12 <dons> you could find that based on the type, I think:
06:48:17 <dons> ?hoogle [a] -> [a] -> [a]
06:48:18 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
06:48:18 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:48:18 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:48:20 <dons> ?hoogle+
06:48:21 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:48:21 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:48:21 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
06:48:26 <dons> there ^^
06:49:15 <lisppaste2> ToRA pasted "Greatest compile error ever." at http://paste.lisp.org/display/32393
06:49:15 <opqdonut> ?hoogle (^^)
06:49:16 <lambdabot> Did you mean: (^^)
06:49:16 <lambdabot> Prelude.undefined :: a
06:49:16 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
06:49:27 <opqdonut> :)
06:50:22 <dons> ToRA++ you've reached level 5
06:50:39 <ToRA> \o/
06:50:48 <dons> when you make ghc's brain explode. now you only have to get past the gorgon and you'll win the princess of the lambda tower!
06:50:56 <dons> ?ghc
06:50:56 <lambdabot>  Can't splice the polymorphic local variable
06:51:29 <glguy> Does anyone have any examples of how to actually use Text.XHtml?
06:51:34 <glguy> google doesn't seem helpful
06:51:38 <glguy> and the docs aren't either
06:51:40 <ventonegro> data ... where... ?
06:52:04 * SamB_XP thinks haddock does
06:52:07 <dons> glguy: I guess bringert has used it in his hope wiki
06:52:17 <SamB_XP> except that it has its own copy
06:52:23 <ventonegro> another brain is about to explode
06:55:37 <ms_> ?dons level
06:55:38 <lambdabot> level not available
06:56:51 <chessguy> 'morning haskellers
06:57:55 <dino-> dons: re- game libs  Ah, I hadn't seen that. Thank you.
07:03:12 <dons> ?users
07:03:13 <lambdabot> Maximum users seen in #haskell: 288, currently: 270 (93.8%), active: 31 (11.5%)
07:03:17 <dons> night all!
07:03:38 <earthy> sleep well dons
07:03:42 * dons `map` (cycle "zzz")
07:03:47 <beelsebob> o.O
07:03:53 <ToRA> nn
07:03:54 <beelsebob> dons is sleeying?
07:03:57 <beelsebob> sleeping too
07:04:30 <Masklinn> I don't know, maybe his sleeping function hasn't been evaluated yet
07:05:02 <psnl> sleeping is an action, HTH, HAND
07:05:08 <Masklinn> ah true that
07:05:57 <Masklinn> but does dons force strict evaluation of his sleeping action?
07:07:14 <ms_> and does ghc unbox it?
07:07:42 <Masklinn> I don't think duns runs ghc
07:07:49 <Masklinn> his brain is a hMachine
07:07:58 <Masklinn> it's got haskell implemented in the hardware
07:08:17 <ms_> l33t
07:09:32 <Masklinn> by the way, be careful with doors guys, breaking a finger hurts
07:09:58 <Masklinn> especially when it's your own
07:11:25 <glguy> is there a better way to do this?
07:11:26 <glguy>         << table ! [border 2]
07:11:26 <glguy>            << (foldr (+++) noHtml $ map theCell [1..count])
07:11:42 * glguy just found toHtmlFromList
07:14:08 <chessguy> > zip [1,2,3] [3,2,1]
07:14:09 <lambdabot>  [(1,3),(2,2),(3,1)]
07:14:17 <bringert> glguy: just use toHtml
07:14:17 <chessguy> > zip [1,2,3] [3,2,1,4]
07:14:19 <lambdabot>  [(1,3),(2,2),(3,1)]
07:14:24 <bringert> or not even that
07:14:39 <chessguy> @hoogle zip
07:14:40 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
07:14:40 <lambdabot> List.zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
07:14:40 <lambdabot> List.zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
07:14:43 <bringert> ...   << map theCell [1..count]
07:14:53 <chessguy> ?doc Prelude.zip
07:14:54 <lambdabot> Prelude.zip not available
07:14:54 <bringert> glguy: yeah, they docs aren't that great
07:15:01 <glguy> bringert: but the library is cool :)
07:15:04 <chessguy> where do i find the source code for zip?
07:15:56 <glguy> http://programming.reddit.com/info/uqo3/comments/cuqxz
07:16:10 <glguy> bringert: does that look like I'm using the library as intended?
07:16:22 <dino-> chessguy: As in from the Prelude: dons has this here: http://www.cse.unsw.edu.au/~dons/data/Prelude.html
07:16:23 <lambdabot> Title: Haskell 98 Prelude
07:17:28 <dino-> Or, to fly in from outside: haskell.org > 3 Documentation, Example Code > A Haskell 98 Prelude.hs
07:18:02 <chessguy> thanks
07:21:03 <huschi_> i've got an off topic question. i want to verify the results i evaluated with haskell with maxima. has anybody here ever worked with it?
07:25:02 <glguy> bringert: You there?
07:27:59 * SamB_XP wonders what is a good way to write a curses UI
07:28:56 * SamB_XP shouldn't try to do it now, though, he has finals tomorrow...
07:29:48 <dino-> SamB_XP: I recall sometime in the recent past dons telling somebody to take a peek at his curses mp3 player thingy.
07:29:56 <ms_> odd time of the year for finals no?
07:30:07 <SamB_XP> dino-: don't think I haven't already done that ;-)
07:30:13 <dino-> heh
07:30:33 <SamB_XP> I still don't quite get how it works, and I'm not really sure it is quite right.
07:30:43 * SamB_XP would really like to see a general framework
07:35:07 <huschi_> is there some work on evaluating the values of diffentiated functions in haskell?
07:35:37 <nominolo> Pupeno: what do these error messages mean below your blog entry?
07:39:51 <SamB_XP> huschi_: pshhh
07:39:54 <SamB_XP> thats easy
07:40:00 <SamB_XP> the hard part is getting those functions ;-)
07:40:19 <SamB_XP> there was some work on *that*, though ;-)
07:40:39 <SamB_XP> Oleg and Simon Peyton-Jones, iirc, did a paper on that (was it recently?)
07:40:55 <huschi_> i've just implemented a very easy solution to get the f'(x) for a given x.
07:41:08 <Pupeno> nominolo: where ?
07:41:18 <Pupeno> nominolo: in my site or in planet ?
07:41:26 <nominolo> your site
07:41:28 <SamB_XP> what about for a given f?
07:41:44 * Pupeno checks.
07:41:56 <Pupeno> they might be rst errors.
07:42:31 <huschi_> SamB_XP: if you give me an function f : Floating a => a -> a i can evaluate the derivation for any x.
07:42:44 <SamB_XP> huschi_: without using TH?
07:42:48 <huschi_> yes.
07:43:32 * SamB_XP wonders if that is harder or easier than with TH
07:43:42 <SamB_XP> http://www.mail-archive.com/haskell@haskell.org/msg19544.html
07:43:43 <lambdabot> Title: [Haskell] Jones-optimal, typed, symbolic differentiation of (compiled) f
07:44:32 <Pupeno> nominolo: thank you for mention it, I missed it. The blog post is written in ReStructured Text and is latter converted to HTML. During the convertion there were errors regarding cross-reference/linking, just a typo. It is now fixed. Thank you.
07:45:04 <nominolo> Pupeno: i first thought it were comments ;)
07:45:44 <huschi_> boah, that looks very complicated.
07:45:46 <SamB_XP> oh, wait, there is no paper?
07:45:56 <SamB_XP> just an email?
07:46:02 <Pupeno> nominolo: unfortunately, I can't accep comments right now, but I am working on it.
07:46:30 <SamB_XP> huschi_: how do you do it?
07:46:56 <huschi_> well, it's quite simple, i've learned it at university today.
07:47:02 <SamB_XP> anyway, your code should not look like Oleg's code ;-)
07:47:26 <SamB_XP> if it did, how would you understand it?
07:47:48 <SamB_XP> well, I suppose you could ask Oleg...
07:47:51 <huschi_> i made a type data Diff a = { x :: a, dx :: a }
07:48:21 <huschi_> and afterwards i made this type an instance of Num, Fractional and Floating.
07:48:41 <SamB_XP> how interesting!
07:49:00 <huschi_> for example: (Diff f f') * (Diff g g') = Diff (f*g) (f*'g+f'*g)
07:49:10 <SamB_XP> Oleg's actually makes *code*
07:50:15 <huschi_> i implemted for all methods of Num, Fractional and Floating these diffentiation rules and this way i can evaluate the values of the derivatives.
07:51:12 <SamB_XP> cool
07:53:17 <SamB_XP> I'd like to see them benchmarked head-to-head, with a partial evaluator thrown in for yours ;-)
07:53:25 <bringert> glguy: can’t find the server “programming.reddit.com”.
07:53:48 <SamB_XP> since yesterday
07:54:08 <SamB_XP> or the day before...
07:54:14 <glguy> bringert: they are having dns issues (I have the hostname hardcoded in my hosts file) (pasting)
07:54:16 <huschi_> SamB_XP: have you ever tested olegs code?
07:54:24 <SamB_XP> huschi_: no.
07:54:43 <lisppaste2> glguy pasted "bringert : does this look "correct"" at http://paste.lisp.org/display/32395
07:54:44 <SamB_XP> and that last bit was about reddit, btw...
07:54:54 <huschi_> do you know how it works?
07:55:16 <glguy> cat >> /etc/hosts
07:55:17 <glguy> 72.5.28.218 www.reddit.com
07:55:17 <glguy> 72.5.28.218 reddit.com
07:55:18 <glguy> 72.5.28.218 programming.reddit.com
07:55:23 <glguy> (=
07:55:31 <bringert> glguy: that looks good
07:55:34 <huschi_> it looks like he can differentiate a function in a symbolic manner without knowing it formula.
07:55:50 <bringert> glguy: feel free to submit patches for the text.xhtml haddock
07:55:55 <SamB_XP> no -- it can find its formula ;-)
07:56:04 <ski> huschi_ : is that like in Jerzy Karczmarczuk's papers on automatic differentiation http://users.info.unicaen.fr/~karczma/arpap/ ?
07:56:08 <lambdabot> Title: Some papers (Karczmarczuk)
07:56:11 <glguy> bringert: someone was saying "oh sure, Haskell can make fibs look pretty, but can it write HTML like this lisp expresssion
07:56:28 <glguy> bringert: so I wanted to demonstrate that Haskell made lisp look silly when used to gnerate html
07:56:46 <Syzygy-> huschi_: sigfpe wrote about that...
07:57:36 <SamB_XP> apparantly Baughn wants a turing-complete schema language
07:57:54 <bringert> glguy: did it work?
07:57:54 <huschi_> it looks like if i have taken the same approach as Jerzy Karczmarczuk
08:00:05 <ski> the approach is known as "automatic differentiation" .. it is not a kind of symbolic differentiation
08:01:01 <SamB_XP> ski: oh? it is at least semi-symbolic!
08:01:25 <ski> why do you say so ?
08:01:38 <huschi_> ski: yes i know. i've heard about it today in university.
08:01:48 <SamB_XP> well, anything that involves writing a Floating instance to peek at the expressions is!
08:02:16 <[d-_-b]> about the lib System.Random, i want to creat a random number between 3-18. so, i use: " take 1 (randomRs (3,18) (mkStdGen 8)) " but this will creat always the same number :(
08:02:33 <huschi_> now it works only for the first derivation and i was asking if it will work for the other derivations, too.
08:02:54 <huschi_> maybe the paper you gave me link to, will show me how it is done.
08:02:54 <SamB_XP> huschi_: what happens if you try to differentiate twice?
08:03:00 <mauke> don't make a new random generator
08:03:06 <dino-> I'm not 100% certain but is that (mkStdGen 8) making one with the same seed each time?
08:03:11 <mauke> yes
08:03:15 <[d-_-b]> ya
08:03:26 <dino-> Maybe newStdGen instead.
08:03:28 <huschi_> SamB_XP: i can't differentiate twice.
08:03:31 <ski> SamB_XP : in this case, it doesn't "peek" at the expressions at all ..
08:03:37 <SamB_XP> huschi_: why not?
08:03:57 <ski> you need another part to differentiate twice
08:04:13 <SamB> @paste
08:04:13 <lambdabot> http://paste.lisp.org/new/haskell
08:04:14 <huschi_> if i have a function like f : Floating a => a -> a i have to call "f (var 1.0)"
08:04:23 <ski> generally you need a stream of values to take arbitrary derivatives
08:04:28 <dino-> Splits the global rng.
08:04:31 <huschi_> and i will obtain the values for f(1.0) and f'(1.0)
08:04:33 <mauke> you should use randomIO or something like that
08:04:47 <ski> SamB_XP : read the papers :)
08:04:48 <[d-_-b]> humm
08:05:03 <huschi_> ski: you mean a lazy list with stream?
08:05:06 <[d-_-b]> but i want a random Int, not a random IO Int
08:05:10 <dino-> ya, what mauke said, you could skip the dickering with generators yourself.
08:05:11 <ski> huschi_ : yes
08:05:22 <Syzygy-> [d-_-b]: But the input that gives you different seeds is an IO operation.
08:05:30 <SamB> huschi_: oh...
08:05:33 <SamB> ick.
08:05:35 <huschi_> maybe i will try it, but first i will read a bit in the paper.
08:06:00 <Syzygy-> [d-_-b]: You can either give the random generator a seed, then it stays outside the IO monad. Or you can get an IO Int, and do all your calculations inside the monad.
08:06:12 <Syzygy-> Which isn't really that much of a problem.
08:06:59 <[d-_-b]> I will try :) thanks
08:11:30 <shapr> @yarr !
08:11:30 <lambdabot> I'll keel haul ya fer that!
08:11:38 <shapr> Good morning #haskell!
08:11:41 <jgrimes> @arr
08:11:42 <lambdabot> Yeh scurvy dog...
08:11:52 <jgrimes> morning
08:11:52 <jgrimes> :)
08:12:28 <shapr> How's code treatin everybody?
08:13:20 <earthy> hm. hasktags sucks. badly.
08:13:41 * Nafai is avoiding Java
08:13:46 <shapr> earthy: It works for me, but I use hasktags **/*.hs~_darcs*
08:13:57 <earthy> shapr: and do you use vim?
08:14:02 <earthy> and mac os x? :)
08:14:06 <shapr> neither :-)
08:14:13 * earthy expected that. ;)
08:14:27 <earthy> issue 1: hasktags assumes case-sensitive filesystems
08:14:34 <earthy> i.e.: it generates both tags and TAGS files
08:14:47 <earthy> however, mac os x's hfs+ is case insensitive but case-preserving
08:14:50 <shapr> I thought HFS+ went out long ago?
08:14:51 <shapr> oh.
08:15:04 <earthy> resulting in just a tags file, with the contents of the TAGS file...
08:15:28 <earthy> issue 2: vim expects tags files to be sorted. hasktags gives the tags in file order.
08:20:30 <emu> heh, did u see the src to hasktags? ;)
08:20:39 <emu> tried :ctags in ghci?
08:23:03 <Cale> It's very easy to modify hasktags so it produces just one of the tags files.
08:23:06 <earthy> never tried :ctags in ghci
08:23:15 <earthy> anyway, I'm going to hack up hasktags and send in a patch
08:23:37 <earthy> Cale: it's just the default that breaks on mac os x
08:23:55 <Cale> right
08:23:59 <Cale> I remember having that problem
08:24:00 <earthy> so that's a trivial change
08:24:12 <earthy> but the sorting for ctags files is fundamental
08:24:17 <earthy> http://ctags.sourceforge.net/FORMAT
08:24:18 <Cale> You can also configure your filesystem to be case sensitive on OS X.
08:24:36 <earthy> you can?
08:24:48 <earthy> and add this to an existing fs?!
08:24:54 <emu> hasktags has options for output to diff formats
08:25:05 <Cale> yeah, I'm not sure how safe it is, because some programs out there probably assume that it's insensitive
08:25:12 <dino-> I have to say I find it kind of creepy that it has the capability to NOT be case-sensitive on a system based on BSD. :o
08:25:32 <emu> darcs isnt happy about files of the same spelling but different cases
08:25:40 <earthy> dino: it is case preserving.
08:26:54 <nominolo> any comments on this are appreciated: http://nominolo.blogspot.com/2006/12/syntax.html
08:26:56 <lambdabot> Title: nominolo's Blog: Syntax
08:28:51 * SamB_XP wonders how hard it is to write a decent MOO client
08:30:02 <SamB_XP> dino-: darcs is case-sensitive
08:30:13 <earthy> nominolo: do you know about http://www.cs.uu.nl/people/arthurb/macros.html ?
08:30:15 <pejo> dino, shrug, it's not UFS, which probably is a good thing.
08:30:16 <lambdabot> Title: Syntax Macros
08:30:24 <SamB_XP> it just doesn't want you to mess the repo up for windows users, thats all
08:31:19 <nominolo> pejo: no .. i'll take a look
08:31:43 <pejo> nomi, that was earthy you meant, I hope.
08:32:00 <Trevion> SamB_XP: text or graphical?
08:32:01 <malebria> Hello.
08:32:10 <SamB_XP> Trevion: graphical
08:32:21 <earthy> Arthur, Doaitse and Atze have been working on extending this so it could be embedded in Haskell
08:32:34 <SamB_XP> I'd actually want it to have MacMOOSE support or better
08:32:47 <ski> nominolo : s/?e .../?e; .../ ?
08:34:42 <nominolo> ski: actually i'm not sure .. the form "?e:expr ; ... " matches expressions separated by ";", while in the expansion, "?e ..." expands everything that ?e matched
08:35:00 <nominolo> ski: but, true, symmetry here would be nice
08:35:35 <ski> anyway, i take '...' would work similarly as in 'syntax-rules' ?
08:35:47 <SamB_XP> and I'd want a decent object browser
08:35:51 <nominolo> ski: not completely
08:35:51 <earthy> hm. ghci 6.6's :ctags actually *does* generate ctags in sorted order.
08:36:33 <ski> nominolo : elaborate ?
08:37:56 <Trevion> SamB_XP: hmm, you'd need a Telnet library.  I suspect that would be the easy part though
08:38:36 <SamB_XP> the hard part being?
08:38:45 <nominolo> ski: if "..." is followed by ";" or "," it is assumed to be used as a seperator of the forms  preceding the ";" or ","
08:38:59 <SamB_XP> I suppose the object browser would be the main thing, huh?
08:39:04 <nominolo> s/followed/preceded/
08:40:18 <ski> m
08:40:47 <nominolo> ski: ie. "?e:expr ; ..." matches a semicolo-separated sequence of expressions
08:41:22 <SamB_XP> Basically I want something a bit more on the level of Squeak or Self ;-P
08:42:52 <glguy> Does anyone know what actually happened to Reddit's DNS?
08:43:28 <ski> nominolo : yes
08:44:19 <ski> nominolo : hm .. though, actually we want it to match a semi-colon separated sequence of 'do'-commands, right ?
08:45:16 <nominolo> ski: you're right.  Ok, I should have used: "?rest:*"
08:45:17 <earthy> glguy: botched transfer
08:45:32 <nominolo> ski: whitch matches anything
08:45:43 <nominolo> i'll change this, thanks
08:46:44 <Trevion> SamB_XP, honestly, for me I think the interface stuff might be the hardest
08:46:59 <SamB_XP> might be tricky for me too
08:47:07 <Trevion> only because I haven't used it before.  Most of what I've seen of MOO clients (and I haven't used MacMOOSE) is pretty straight forward
08:47:25 <SamB_XP> oh, well, I've been using tkMOO light
08:47:46 <SamB_XP> which supports the MacMOOSE protocol
08:48:06 <glguy> What's all of this MOO business?
08:48:42 <SamB_XP> oh, I don't like my MOO IDE
08:53:07 <shapr> Oh, I had a crazy realization recently about why debuggers are against the spirit of Haskell.
08:53:16 * shapr tries to remember...
08:53:44 <Botje> debuggers imply sequential execution?
08:53:50 <Botje> and state?
08:54:22 <shapr> More that debuggers are run-time specific, and the Haskell approach is to push error checking to compile time as much as possible.
08:54:26 <shapr> But there something else.
08:54:33 <psnl> shapr: keep going?
08:55:20 <nominolo> ski: changed it
08:55:45 <shapr> psnl: I had a really interesting realization that followed those lines, but I don't remember what it was.
08:57:48 <SamB_XP> shapr: the logical conclusion being type debuggers!
08:57:51 <Philippa> shapr: slight problem - you still need to debug IO
08:58:01 <shapr> It all boils down to analysis, I think.
08:58:03 <Philippa> and yeah, type debuggers'd be good :-)
08:58:34 <shapr> The suggested approach in the Haskell world is for everything to be a value that you can analyze.
09:00:09 <shapr> I do remember one thing, encoding invariants in the type system follows the the ubiquitous automation principle in tPP.
09:00:48 <[d-_-b]> someone could me explain this function? randomRIO :: (a, a) -> IO a
09:00:50 <shapr> You could say that debuggers fix the symptom, and that the real cure is to have the computer check a particular invariant automatically, yeah?
09:02:08 <Philippa> not applicable in all cases with IO
09:02:28 <Philippa> IO is the big magic fuck-your-analyses-the-substrate-might-misbehave-too hole
09:02:45 <emu> flowerpots are monads!
09:02:46 <Philippa> no analysis stops the user kicking their computer :-)
09:03:02 <pejo> shapr, care needs to be taken so you get a sufficiently strong invariant though. (Compare with that tricolor invariant that should be true for garbage collectors).
09:03:35 <psnl> shapr: thanks anyway
09:03:35 <Philippa> mmm, metanalysis. Can we stick our heads up our fixpoints? ;-)
09:03:45 <shapr> psnl: What do you think about that?
09:04:50 <psnl> its correct
09:05:08 <shapr> I think debugger use is a symptom of not understanding the code.
09:05:29 <earthy> shapr: sometimes
09:05:30 <paolino> [d-_-b]: the tuple represents lower and upper bounds
09:05:38 <shapr> earthy: When isn't it?
09:05:41 <Philippa> sure. Sometimes you can't understand it without looking at how it behaves in the real world though
09:06:05 <[d-_-b]> randomRIO (3,18)
09:06:30 <shapr> Philippa: Wouldn't it make more sense to express the invariants that you believe are true in an executable and repeatable fashion?
09:06:35 <psnl> shapr: debuggers have three uses: 1) finding bugs 2) reverse engineering 3) teaching, you nly seem to be addressing the first
09:07:12 <shapr> psnl: I'd say I'm not addressing the second point, and that it is a valid point.
09:07:23 <shapr> And that I've never done any reverse engineering, so I hadn't thought of that :-)
09:07:24 <SamB_XP> shapr: how do you do this with IORefs? Ptrs? Mvars? Chans? TVars? Threads, even!
09:07:26 <[d-_-b]> paolino, ya, I know, but can you give a function that give me a random nunber?
09:07:33 <shapr> SamB_XP: quickcheck?
09:07:48 <Philippa> shapr: we call that an assertion, no?
09:07:50 <SamB_XP> shapr: threads can't help you with dynamic properties!
09:07:52 <SamB_XP> er.
09:07:56 <SamB_XP> quickcheck.
09:08:02 * SamB_XP blahs
09:08:09 <emu> quackchcek
09:08:15 <Masklinn> shapr > do you realize that you're *gasp* agreeing with Linus here?
09:08:15 <shapr> Philippa: what?
09:08:23 <paolino> [d-_-b]: it's giving a random number but as an IO action
09:08:27 <shapr> Masklinn: Is that surprising?
09:08:31 <SamB_XP> only adressing the first point?
09:08:33 <Masklinn> No :D
09:09:02 <Masklinn> Was a joke, it's just that some people can't bear thinking the same thing as Linus
09:09:09 <SamB_XP> hahaha
09:09:32 <Philippa> <shapr> Philippa: Wouldn't it make more sense to express the invariants that you believe are true in an executable and repeatable fashion? <- that's an assertion, you assert that the invariant's still holding...
09:09:35 <SamB_XP> even if they picked an idiot, they would share certain beliefs with the idiot!
09:09:38 <pejo> Masklinn, what Linus doesn't care about is that the debugger is useful for observing the hardware.
09:09:57 <Philippa> ...and then you use the debugger to work out WTF happened to make it fail
09:10:11 <Philippa> because it's quicker than having to rerun every time you think of a new piece of info you want
09:10:17 <allbery_b> well, that and his position would make more sense if he wrote in Haskell instead of C
09:10:28 <psnl> shapr: I would also point out that there is a race between language people to develop better lanugages and programmers to build bigger systems. So while better language remove whole classes of bugs, new classes of bugs are developed.
09:10:32 <shapr> I'd think it makes more sense to express these assertions in QuickCheck, and then figure out what inputs fail those assertions.
09:10:53 <pejo> allbery_b, the hardware will still misbehave though, regardless of implementation language on top of it.
09:11:34 <SamB_XP> how do you assert that "no other thread will [do x]"?
09:11:59 <Philippa> shapr: what isn't good enough, why matters
09:12:14 <SamB_XP> pejo: so basically you say we need not *kernel* debuggers but *hardware* debuggers? to find bugs in hardware?
09:12:19 <Philippa> sometimes you only understand why by being able to execute the code, and if it's IO code you can't do that by manually evaluating it on paper
09:12:26 <shapr> Philippa: Do you think a debugger will show more of why than quickcheck?
09:12:35 <SamB_XP> shapr: duh
09:12:41 <paolino> [d-_-b]: the random generator is threading a state  so you need to use these values in a sequence of actions, in haskell functions are values and you can't have a function which returns different values with the same arguments
09:12:43 <Philippa> yes. I end up using variants of printf debugging pretty damn often as it is
09:12:50 <SamB_XP> quickcheck won't show you anything
09:12:52 <pejo> SamB, I hapepn to believe the kernel debugger is useful, but people still need to understand the code they are fixing.
09:12:59 <Philippa> knowing the input alone doesn't get me the relevant info
09:13:04 <shapr> SamB_XP: Hm, I've had good experiences with it.
09:13:43 <shapr> For me, I compare the inputs that passed the test(s) and the input that failed, and then I almost always understand the failure.
09:14:12 <SamB_XP> how does that help if you are writing a BitTorrent client?
09:14:46 <shapr> I'd use the QuickCheckM stuff, where fragments should be equal.
09:15:09 <Philippa> shapr: almost always != always. Perhaps I'm writing trickier and/or stupider code than you?
09:15:12 <SamB_XP> um.
09:15:32 <SamB_XP> QuickCheckM simulates a swarm?
09:16:32 <shapr> Philippa: I don't know. The few times I've used debuggers I didn't get much useful info out of them. So it's also possible that my lack of debugger use is why I don't see the need.
09:16:54 <shapr> SamB_XP: Yeah, QuickCheck can simulate anything if you want :-)
09:17:37 <SamB_XP> what if your bug only shows up a long way in... and you have no idea what causes it?
09:18:00 <Philippa> or turns out to be something that stumped researchers for a good decade the first time round?
09:19:13 <shapr> SamB_XP: Could you add more specific tests in that case?
09:19:19 <shapr> Philippa: ?
09:19:54 <SamB_XP> how do you add tests when you have no clue what the hell is up?
09:21:00 <notsmack> SamB: what do you look at with a debugger when you have no clue what the hell is up?
09:21:27 <Philippa> any and everything, because at least it gives you more evidence
09:21:28 <SamB_XP> probably the same things you would trace...
09:21:29 <allbery_b> I generally add checking of every invariant and condition I can think of before the place were it errors out, and use the result of that to add mroe checking elsewhere
09:21:44 <SamB_XP> obviously a usefull debugger should support going back in time ;-)
09:21:49 <Philippa> start with the dodgy result, check immediate inputs-and-states noting what's unexpected, work backwards...
09:21:50 <SamB_XP> at least looking back in time
09:21:53 <Philippa> right
09:22:03 <allbery_b> don't laugh, I seem to recall there being some research debuggers that do that
09:22:14 <Philippa> in C code usually you start at that by crawling up the stack and deciding which bits of state you're bothered by
09:22:19 <SamB_XP> allbery_b: I won't
09:22:25 <SamB_XP> there are some real debuggers that do it too
09:22:34 <SamB_XP> for ASM, even
09:22:36 <Philippa> allbery_b: this is a chan where people're used to the idea of passing the state of the universe about :-)
09:22:44 <Philippa> don't assume jokes aren't also serious
09:22:45 <SamB_XP> of course, I don't think they keep track of memory contents...
09:22:57 <Philippa> ...it's possible to do that in diff form
09:23:00 <SamB_XP> well, some probably do.
09:23:10 <SamB_XP> but the one of which I am thinking does not
09:23:12 <Philippa> makes a *lot* of sense if you're actually emulating a much smaller system
09:23:41 <allbery_b> the one I recall does, so it can "reverse-execute" code to restore prior state
09:25:02 <SamB_XP> well, you can't quite do that for network programs
09:25:08 <SamB_XP> you can't unsend packets!
09:28:26 <allbery_b> no, but you could record state of the network connection and replay it, if you really wanted to
09:31:02 <notsmack> or simulate the network locally
09:38:31 <[d-_-b]>  i only want a function that creat creat a random nunber between (3,18) to always that i open my program it creats diferent numbers
09:38:31 <[d-_-b]> <[d-_-b]> could you help me?
09:38:31 <[d-_-b]> <[d-_-b]> like this:
09:38:31 <[d-_-b]> <[d-_-b]> gera :: (Int,Int) -> Int -> [Int]
09:38:31 <[d-_-b]> <[d-_-b]> gera (x,y) c = take 1 (randomRs (x,y) (mkStdGen c))
09:38:32 <[d-_-b]> <[d-_-b]> but this functions creats always the same number
09:38:34 <[d-_-b]> <[d-_-b]> because mkStdGen
09:38:44 <[d-_-b]> sorry my english :p
09:39:39 <ski> you need 'gera' to be in the IO monad
09:39:47 <ski> gera :: (Int,Int) -> Int -> IO [Int]
09:40:30 <apfelmus> ski: ah, a winter sport necromancer. ice zombies. brrrh
09:40:50 <ski> apfelmus : i don't ski, no
09:41:32 <ski> [d-_-b] : have you heard about 'do'-notation ?
09:41:54 <apfelmus> ski: then, dark overlord, what does ski stand for?
09:42:35 <[d-_-b]> yap i know do notation but  I don't understand monads
09:43:22 <allbery_b> [d-_-b]: if I understand your question, the problem is that mkStdGen supplies a fixed initial seed, so of course you get the sme stream.  use getStdGen to get a StdGen with a pseudorandom seed.
09:43:32 <ski> apfelmus : why http://en.wikipedia.org/wiki/SKI_combinator_calculus of course
09:43:46 <ventonegro> @type randomRs
09:43:48 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
09:44:01 <Syzygy-> @type getStdGen
09:44:03 <lambdabot> IO StdGen
09:44:06 <[d-_-b]> ya ! is it! [d-_-b]: if I understand your question, the problem is that mkStdGen supplies a fixed initial seed, so of course you get the sme stream
09:44:28 <ski> @type randomR
09:44:29 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:44:34 <ski> @type randomRIO
09:44:35 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:44:45 <ski> [d-_-b] : can't you use 'randomIO' ?
09:44:58 <ski> main = do
09:45:01 <ventonegro> > randomRIO (1, 10)
09:45:02 <lambdabot>  Add a type signature
09:45:02 <apfelmus> [d-_-b]: i'd parametrise gera on the random generator
09:45:03 <apfelmus>  gera ::RandomGen g => (Int,Int) -> g -> [Int]
09:45:03 <apfelmus>  gera (x,y) gen = take 1 (randomRs (x,y) gen)
09:45:03 <apfelmus> and get a generator from the main function
09:45:08 <ventonegro> > randomRIO (1, 10) :: IO Int
09:45:09 <lambdabot>  <IO Int>
09:45:26 <allbery_b> lambdabot doesn't execute any IO actions
09:45:27 <ski> main = do
09:45:27 <ski>   n <- randomIO (3,18)
09:45:30 <ski>   ..n..
09:45:30 <ventonegro> > liftIO show . randomRIO (1, 10)
09:45:31 <lambdabot>    Expecting a function type, but found `IO a'
09:45:31 <lambdabot>    Expected type: IO a
09:45:31 <lambdabot>  ...
09:45:57 <ventonegro> >  randomRIO (1, 10) >>= (liftIO show)
09:45:58 <lambdabot>    Expecting a function type, but found `IO a'
09:45:58 <lambdabot>    Expected type: IO (IO ...
09:46:36 <ventonegro> allbery_b, oh
09:47:08 <apfelmus> ski: ah, the combinators didn't come to my mind :)
09:47:17 <ski> (:
09:47:17 <Syzygy-> [d-_-b]: Prelude System.Random> let test x y = do g' <- newStdGen; return $ take 5 $ randomRs (x,y) g'
09:47:20 <Syzygy-> Prelude System.Random> test 2 4
09:47:23 <Syzygy-> [2,4,2,3,3]
09:47:25 <Syzygy-> Prelude System.Random> test 2 4
09:47:28 <Syzygy-> [4,2,2,2,2]
09:47:31 <[d-_-b]> yaaaaaaaaa
09:47:33 <[d-_-b]> =)
09:47:37 <LordBrain> I'm studying the stanamically ballanced binary tree code at http://www.haskell.org/pipermail/haskell/2003-April/011621.html
09:47:39 <lambdabot> Title: Polymorphic stanamically balanced binary trees
09:48:09 <LordBrain> I'd like to understand each of the extensions being used.
09:48:16 <LordBrain> one of them is
09:48:25 <Syzygy-> @hoogle IO StdGen
09:48:25 <lambdabot> Random.getStdGen :: IO StdGen
09:48:26 <lambdabot> Random.newStdGen :: IO StdGen
09:48:36 <LordBrain> umake n = case (umake (n-1)) of (BU (x::z)) -> BU $ (undefined::(Succ z))
09:48:42 <LordBrain> this type annotation
09:49:15 <LordBrain> it works fine in ghci, but if there is a way to do it in hugs.. I'd like to know
09:49:27 <cjeris> LordBrain: clearly instance Crackhead Oleg where ... -- :)
09:49:42 <LordBrain> lol
09:52:40 <LordBrain> z there is an unspecified type presumably... a member of the UNUM type class.
09:53:17 <LordBrain> x wasnt even used, so i guess he should be able to put an _ there instead.
09:54:02 <LordBrain> all the information is in the type, the values are just bottom anyway
09:56:04 <ski> LordBrain : have you tried giving '-98' command line arg to hugs ?
09:56:13 <LordBrain> ski, yeah
10:01:23 <LordBrain> ERROR "Jim.hs":29 - Type annotation uses variable z where a more specific type _27 was inferred
10:02:19 <ski> oh
10:02:24 <sjanssen> oh, right, _27
10:02:36 <ski> LordBrain :t umake
10:02:40 <emu> i have a simple queue implemented using Data.Sequence.  it's taking over half my time and space according to prof.  any suggestions on a replacement?
10:02:43 <LordBrain> i guess hugs reports an error, because the type variable z is not necessarily in the UNUM class? Where ghci just assumes i meant it to be
10:03:05 <sjanssen> emu: there are some simpler queues in Edison
10:03:33 <LordBrain> umake :: forall a. (Num a) => a -> BU
10:04:33 <LordBrain> thats in ghci
10:04:38 <ski> and how's 'BU' defined ?
10:05:12 <LordBrain> data BU = forall u. (UNUM u) => BU u
10:05:32 <LordBrain> it's an envelope to hold the type information at runtime
10:05:43 <LordBrain> if i understand correctly
10:05:49 <LordBrain> this all works fine in ghci
10:07:12 <LordBrain> @paste
10:07:13 <lambdabot> http://paste.lisp.org/new/haskell
10:09:21 <lisppaste2> LordBrain pasted "Jim's Undefined Arithmetics,..." at http://paste.lisp.org/display/32408
10:11:32 <LordBrain> So what is the name of the particular extension which allows this kinda ::z in patterns funny business?
10:13:42 <emu> now i remember why it's taking so much time -- it checks to see if the elem is in the queue first
10:17:11 <sjanssen> that'll be slow ;)
10:17:29 <emu> ta da
10:19:24 <huschi_> SamB_XP: no it works for any derivation.
10:20:37 <SamB_XP> what happens if you write...
10:20:50 <SamB_XP> var (f (var 1)) ?
10:21:47 <SamB_XP> or
10:21:54 <huschi_> it seems that i get something 2 dimensional.
10:22:00 <SamB_XP> f (var (var 1))
10:22:23 <huschi_> it looks like the same results.
10:22:30 <SamB_XP> oh really?
10:22:42 <huschi_> yes.
10:22:50 <SamB_XP> is that from types or from values?
10:23:02 <huschi_> what do you mean?
10:23:39 <SamB_XP> also, what function are you using?
10:24:22 <huschi_> now, a function f :: Diff a -> Diff a evaluates to a list of its values at all the derivations, the zeroth being the function itsself
10:24:34 <huschi_> i was using cosine.
10:24:43 <SamB_XP> oh, you updated it now ;-)
10:24:58 <huschi_> yeah.
10:25:10 <huschi_> because i wanted all derivations.
10:25:25 * SamB_XP really suspects the simple one could have done the job...
10:25:31 <huschi_> afterwards i looked in olegs paper, he did it the same way.
10:26:18 <huschi_> i think this application of automatic differentiation is only possible in lazy functional languages.
10:26:27 <huschi_> another reason to love haskell!
10:28:15 <kzm_> Is there a pre-packaged binary ghc distribution that includes everything necessary to build ghc?
10:28:41 <kzm_> And is anybody able to log into the trac wiki with guest/guest?
10:28:59 <ski> huschi_ : 'this' being ?
10:30:47 <huschi_> ski: what do you mean? (i'm no native english speaker)
10:31:15 <ski> which application of AD do you think is only possible in lazy functional languages ?
10:31:44 <huschi_> the one i've just implemented.
10:32:06 <ski> which aspect of it ?
10:32:20 <ski> doing differentiation at all with this method ?
10:32:24 <huschi_> i can get all derivations of a function at a given x.
10:32:34 <lisppaste2> dfrey pasted "Beginner Haskell problem" at http://paste.lisp.org/display/32410
10:32:35 <Taral> get all what of a function?
10:32:48 <huschi_> derivatives.
10:33:01 <SamB_XP> ski: I think he means the lazy-list-of-derivatives approach to computing derivatives at a point
10:33:02 <kzm_> huschi_, did you look at Jerzy Karcmarczuk's (sp) stuff?
10:33:09 <huschi_> to get them all in one list you need lazy evaluation.
10:33:18 <huschi_> yes i did.
10:33:28 <ski> you can build streams explicitely in a strict language
10:33:50 <shapr> Even if it's purely strict?
10:33:52 <huschi_> i looks like i've chosen the same way like him.
10:34:05 <Taral> huschi_: Sorry, but it's been proven that lazy and strict languages are equally expressive.
10:34:40 <ski> dfrey : 'putStrLn ("The sum is " ++ show (foldr (+) 0 input))'
10:35:10 <huschi_> Taral: but you would have to emulate something like lazy evaluation in a strict language.
10:35:38 <Taral> huschi_: It's possible, but not necessary unless dealing with an infinite object.
10:35:42 <lisppaste2> dfrey annotated #32410 with "correction" at http://paste.lisp.org/display/32410#1
10:36:13 <huschi_> i have to leave you now.
10:36:17 <huschi_> see you soon.
10:36:27 <Taral> lol
10:36:32 <Taral> "lazy evaluation is required"
10:37:04 <ski> dfrey : same fix
10:37:53 <Saizan> well assembly is strict, so.. :D
10:38:29 <dfrey> ski: ahh, ok I didn't see your first comment before making the correction
10:40:24 <emu> hmm. what do you guys use as a logging library?
10:40:26 <dfrey> ski: Is "show" required in order to convert the integer to a string?
10:40:38 <ski> yes
10:40:54 <emu> i tried to concoct my own "thread-safe" logging library but i'm having some trouble
10:40:56 <dfrey> ski: That makes sense.  Thanks
10:41:00 <astrolabe> taral: equally expressive in what sense?
10:41:07 <ski> @type show
10:41:08 <lambdabot> forall a. (Show a) => a -> String
10:41:10 * mbishop wakes up
10:41:29 <Taral> astrolabe: As in programs written in one can be converted to the other.
10:42:01 <astrolabe> Ah, both turing complete I guess, yes.
10:42:06 <Taral> pretty much
10:42:20 <Taral> he was trying to claim that lazy evaluation was "required"... it's patently not.
10:42:40 <astrolabe> But I think in other ways non-strict semantics can be more expressive.  You get the same answers, but you can pose the questions in more ways.
10:44:15 <astrolabe> I guess he was talking about the infinite list of different order derivatives of a function.
10:44:39 <lisppaste2> emu pasted ""logging process" with STM (broken)" at http://paste.lisp.org/display/32411
10:44:47 <Taral> that's a cofixpoint, and requires a CPS or other lazy-like transform.
10:45:06 <Taral> still doable in strict languages, just not as pretty :)
10:45:41 <SamB_XP> it makes your brain explode though
10:49:48 <Taral> yay!
10:49:49 <cjeris> way to go SML: give foldl the backwards type ((a -> b -> b) -> b -> [a] -> b instead of (b -> a -> b)) and then NOT make any of the useful functions that you want to fold conform to that assumption.
10:51:20 <Taral> cjeris: use Haskell, obviously.
10:51:49 <SamB_XP> cjeris: like what functions?
10:51:56 <tom__> is there some function to check wether something is from a certain data type?
10:52:03 <SamB_XP> :t foldl
10:52:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:52:09 <cjeris> SamB_XP: the most common offender is Fifo.enqueue at the moment
10:52:36 <cjeris> Taral: can't.  so i'm reduced to writing very Haskell-looking, purely functional, monadic, curried SML. :)
10:52:51 <Taral> :<
10:53:13 <shapr> You could always ahem, "prototype" in Haskell and then rewrite in SML.
10:53:24 <SamB_XP> you do realize that that has been proved less efficient than Haskell, in terms of computational complexity?
10:53:28 <cjeris> i'm sure when i string piles of monadic crap together the resulting code is actually pretty horrible since SML is strict :)
10:54:27 <cjeris> it's just that it's vastly easier to understand my code when it's pure
10:55:39 <kyevan> Hmm. Question: How can you do return codes in haskell? (When a program terminates on most OSes, it returns a number (usually 0, iirc))
10:58:33 <shapr> kyevan: http://www.haskell.org/hawiki/HaskellMode
10:58:34 <lambdabot> Title: HaskellMode - The Haskell Wiki
10:58:42 <shapr> Look at the bottom of that page.
10:59:18 <Excedrin> kyevan: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
10:59:21 <lambdabot> http://tinyurl.com/yyce5n
11:02:33 <LordBrain> exitWith 0
11:02:42 <LordBrain> @hoogle exitWith
11:02:42 <lambdabot> System.exitWith :: ExitCode -> IO a
11:02:58 <LordBrain> something like that
11:03:49 <tom__> mm why cant i do a -> Bool and make a function with a specific datatype as parameter?
11:04:39 <glguy> tom__: what do you want to do?
11:05:09 <tom__> check if something is from a certain datatype
11:05:13 <glguy> right, but why
11:05:18 <tom__> but wondering now if i need it ;/
11:05:22 <tom__> i need a function
11:05:30 <tom__> which checks if a datatype is recursive
11:06:06 <glguy> I don't think you will be able to do that
11:06:31 <glguy> (there might be an extension or something I don't know about)
11:07:53 <tom__> mm
11:08:04 <glguy> why do you want to determine that
11:08:11 <SamB_XP> hmm, you will know GUIs have gotten out of hand when organists use a GUI instead of the console...
11:08:46 <glguy> SamB_XP: organists as in "similar to pianists"?
11:09:08 <SamB_XP> well. pianists have a lame console.
11:09:15 <SamB_XP> they just call it a piano
11:09:31 <SamB_XP> or maybe they call it the keyboard
11:09:47 <mbishop> http://research.microsoft.com/Users/simonpj/Papers/slpj-book-1987/
11:09:49 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/yd9dvl
11:10:01 <glguy> are you reading a link I should be reading to know wtf you are talking about? (=
11:10:15 <SamB_XP> yeah, I'm talking about the musical instrument
11:10:25 <SamB_XP> the stuff about GUIs was just silly
11:11:16 <glguy> ah
11:12:21 <SamB_XP> though I suppose users of MIDI keyboards who use certain software could be considered to be organists who use a GUI ;-)
11:18:50 <Cale> SamB_XP: isn't that kind of like a theremin?
11:19:07 <SamB_XP> what?
11:19:29 <SamB_XP> I don't think you can call it an organ if it doesn't have a keyboard.
11:20:45 <Excedrin> regarding http://www.haskell.org/pipermail/haskell-cafe/2005-January/008839.html , SML/Mlton is only slightly faster than GHC-6.6 at calculating fib 10^8-1
11:20:47 <lambdabot> Title: [Haskell-cafe] fastest Fibonacci numbers in the West, http://tinyurl.com/y2at95
11:22:53 * psnl boggles
11:22:55 <Excedrin> no more 6:1 speed difference
11:23:03 <psnl> can I write a C version?
11:25:19 <Excedrin> psnl: sure, but you'll probably be linking to GMP anyway... it probably won't be much faster
11:29:04 <Grey-z> Hi all
11:29:28 <wilx> Hm.
11:29:41 <Grey-z> I wrote following function splitBy :: (a -> Bool) -> [a] -> ([a],[a]) using filter
11:29:50 <wilx> How does the non-recursive formula compare to the recursive approach?
11:30:18 <Grey-z> and then started wondering how this could be implemented with single list review
11:30:44 <Grey-z> (filter p xs, filter (not . p) xs)
11:31:47 <astrolabe> Grey-z, maybe you are talking about partition rather than splitBy
11:33:07 <Saizan> foldl (\(ps,nps) x -> if p x then (x:ps,nps) else (ps,x:nps)) ([],[]) xs
11:33:26 <tom__> mm how can i concat a list of booleans?
11:33:31 <tom__> i tried zipWith (||)
11:34:02 <Saizan> you need foldr or foldl too i think
11:34:18 <tom__> foldr (||) False list ?
11:34:28 <Saizan> yes
11:34:36 <tom__> that didnt work
11:34:46 <Grey-z> thanks Saizan :)
11:35:16 <Saizan> list is of type [Bool]?
11:35:20 <tom__> ye
11:35:30 <tom__> like [False,True]
11:35:37 <tom__> i made that with a map function
11:35:51 <Saizan> > foldr (||) False [False,True]
11:35:52 <lambdabot>  True
11:35:58 <tom__> mmm
11:36:59 <tom__> then my map doesnt work correctly
11:37:50 <tom__> oh wait
11:37:51 <tom__> damn my fault
11:37:58 <tom__> thanks saizan for the help anyway
11:38:06 <Saizan> no problem ^^
11:40:09 <reppie> http://www.collectionsetc.com/Item16262.aspx
11:40:11 <lambdabot> Title: Boyfriend Pillow and gifts. Items as low as $9.99, nothin' over $20 at Collectio ...
11:40:43 <kyevan> I don't get do.
11:40:55 <kyevan> It seems to magicaly make Haskell imperitive
11:41:03 <kyevan> And sorta-strict
11:41:25 <Saizan> well, try to understand >>= before
11:41:48 <CosmicRay> kyevan: no strictness is involved
11:42:08 <CosmicRay> it is a shorthand notation, used to stringing the result from one computation through to others,
11:42:19 <kyevan> Saizan: >>=?
11:42:20 <CosmicRay> exiting out of the entire process if there is an error along the way.
11:42:22 <kyevan> Wazat?
11:42:31 <CosmicRay> kyevan: you might want to read up on monads
11:42:36 <allbery_b> @undo do { a <- x; b <- y; return $ a + b}
11:42:36 <lambdabot> x >>= \ a -> y >>= \ b -> return $ a + b
11:42:41 <Saizan> exactly
11:42:50 <kyevan> CosmicRay: I'm just following YAHT in order...
11:43:08 <Saizan> err, you can't understand do by that time
11:43:19 <kyevan> I'm into chapter 5 on IO...
11:43:48 <kyevan> I've already skipped a couple things and said "come back later".
11:44:04 <kyevan> (Well, one thing. CPS. Made no sense to me, really)
11:44:05 <Saizan> was monads one of those?
11:44:11 <mbishop> did they listen when you told them to come back later? :)
11:44:28 <kyevan> Saizan: No, only CPS.
11:45:03 <kyevan> It looks like monads are chapter 9
11:45:06 <kyevan> I'm in chapter 5.
11:45:10 <Saizan> well, maybe it talks first about IO using do notation to let you write interactive programs
11:45:38 * mbishop goes read SOE with the cat
11:45:54 <Saizan> but do notation is really just syntactic sugar for monads
11:45:59 <kyevan> But, uh, if Do makes no sense, it's not very useful....
11:46:55 <Saizan> well it's a little like passing around the state implicitly
11:47:10 <allbery_b> don't worry about it too much just yet; but it's not really do that's weird, it's the IO monad.  (more precisely, the interaction between a purely functional language and actions with side effects --- the latter being the domain of IO)
11:47:57 <kyevan> Saizan: Oh, it's like thier "RealWorld" example, with RealWorld being implicitly passed around and changed in order?
11:48:15 <Saizan> yeah a bit like that
11:49:25 <Saizan> if it appears like magic is just that the mechanism is based on monads
11:49:58 <kyevan> Saizan: It seems like a magic trick, yeh, but I was never a fan of magic shows.
11:50:05 <kyevan> I try too hard to understand things :P
11:50:43 <Saizan> well, so you have to read something on monads :P
11:51:19 <kyevan> Aren't monads supposed to be one of haskell's RBRSTs?
11:51:29 <kyevan> (Really Big Really Scary Things)
11:51:49 <Saizan> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html <-- this post aims exactly at taking away the shadow of magic
11:51:52 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
11:52:50 <newsham> "do" is syntactic sugar, but it neednt be.  The system could be written in terms of rules for   "do {v <- act1; act2}" (analogous to "let v = func1 in func2").  larger do's can be built by nesting two-action dos.
11:54:19 <newsham> (just as larger let's can be built up by nesting lets)
11:55:03 <Cale> hm?
11:55:18 <newsham> act1 >>= (\v -> act2)
11:55:27 <Saizan> newsham, why do that if monads can be expressed simply by functions?
11:55:29 <Cale> Well, you don't *need* to use do, sure
11:55:39 <Cale> That's the whole point of calling it syntactic sugar
11:55:46 <newsham> similar in spirit to    (\v -> func2) (func1)
11:56:25 <Cale> er, actually let can't be replaced by lambda binding
11:56:33 <newsham> not in the general case. but often.
11:56:51 <cjeris> kyevan: I found that the easiest way to understand monads was to construct one in a language that doesn't have them -- say, ML.  you want to do a computation that normally would operate by mutating a persistent data structure.  you have to do it purely.  this leads naturally to the State monad: 'a monad = state -> 'a * state.
11:57:03 <Saizan> (i think however that the distinction that YAHT remarks between functions and actions is rather misleading)
11:57:06 <newsham> also "do" desugaring is slightly more complex than just using >>=
11:57:06 <Cale> Well, whenever you don't need polymorphism or recursion you could replace it
11:57:33 * allbery_b is not sure that introducing ML type syntax helps the issue :)
11:57:34 <Cale> Well, there are some stupidities in the present do-desugaring too
11:57:53 <newsham> reguardless, I think the analogy is enlightening and helps form intuition.
11:58:20 <Cale> Well, yeah, definitely we should show how exactly do is sugar.
11:58:44 <Cale> and start off with return, (>>=), fmap, join, etc.
11:59:05 <Cale> actually, I rather like teaching them in parallel
11:59:16 <newsham> my opinion is do notation should be taught as a blind-faith rule, teach people who to write useable programs with it, teach them how to use several of the monads with it, then later tell them how a two-action do maps to bind.
11:59:34 <Cale> hmmm
11:59:49 <Cale> I think that leads to confusion about what monads are about.
11:59:52 <encryptio> some people (such as myself) have a big mental block with "blind faith"
12:00:02 <Saizan> no, they will take the imperative analogy along with the other monads
12:00:11 <newsham> cale: that doesnt matter.  you dont need to know what a monad is to start programming.
12:00:15 <Cale> I've seen lots of people who think that monads are for simulating imperative programming.
12:00:20 <newsham> thats the point.  people are being force fed monads when they dont need it yet
12:00:28 <Cale> Which is IMO far too narrow a viewpoint.
12:00:59 <Saizan> I think it's the opposite, they are fed IO when they don't need it yet :D
12:01:27 <Saizan> YAHT starts with it!
12:01:57 <newsham> saizan: teaching someone how to program in haskell without letting them do IO is a sure way to drive away people who know how to program in other languages.
12:02:06 <newsham> and IO isnt hard..  its actually really easy.
12:02:12 <Cale> Avoid popularity at all costs :)
12:02:54 <Saizan> interpreters are there
12:02:55 <newsham> cale: there's definitely something to that.  on the other hand, my life would have been a lot easier if i had an easier road to learning haskell.  and so i feel obliged to make it easier for others
12:03:04 <Cale> okay, that's true
12:03:13 <Cale> Some people are going to want to do IO right away
12:03:50 <Cale> Personally, I was more than satisfied with using GHCi for IO.
12:04:26 <newsham> there's no reason a beginner cant understand   do { as <- getArgs; print (unwords as) }
12:04:28 <Cale> but there are some for whom that's just not really enough :)
12:04:37 <Cale> Okay
12:04:42 <newsham> you dont need to know anything about (>>=) to undersatnd that.
12:04:54 <Saizan> in this sense haskell is a little like java, you need to know a lot of the language to do IO :)
12:04:55 <Cale> but people will be confused by aspects of the do-notation if you don't tell them what it means
12:05:10 <newsham> you only need a shallow understanding of "return" to write slightly more complex code (mostly that "return" is NOT control flow)
12:05:22 <Cale> that's a big one
12:05:51 <Cale> also, to do anything nontrivial without horrid pain, you need to know at least mapM
12:06:24 <newsham> you can explain mapM and liftM fairly easily by example and by showing the do-notation equivalent.
12:06:47 <newsham> do { x <- act1; return (f x) }    is not hard to understand.
12:06:48 <Saizan> the problem is not understanding IO, it's understanding monads after you have taken do-notation as magic
12:07:15 <Cale> Here's the way that I explain IO to those who want it early on: http://haskell.org/haskellwiki/Introduction_to_IO
12:07:17 <lambdabot> Title: Introduction to IO - HaskellWiki
12:07:21 <newsham> saizan: I disagree.      do { x <- act1; act2 } maps directly to  act1 >>= (\x -> act2)
12:07:42 <Cale> It's very important that they understand the difference between an action and the value that it computes.
12:07:43 <newsham> a healthy intuitive understanding of do notation leads directly to abstraction of bind and monads.
12:07:52 <newsham> cale: yes.  i agree.
12:07:57 <Saizan> newsham: but you have formed a lot of prejudices that are not true
12:08:01 <newsham> and thats probably the first thing they should learn.
12:08:11 <newsham> saizan: possibly, but obviously i disagree.
12:08:22 <Cale> I don't really necessarily disagree with starting with IO early, but it's not the way I'd teach Haskell myself.
12:08:34 <Saizan> okok, it's just what i've experienced
12:08:55 <Cale> Personally, I've found that it's very successful to start with lots of stuff about types and values and a little about typeclasses.
12:09:05 <dylan> I don't find do-notation any more magic than any other syntax sugar.
12:09:15 <encryptio> i had trouble understanding the laziness of the do notation. now that i know it as a series of functions, possibly changing state, but that must be done in a certain order, it's much easier to understand the laziness of do { x <- getContents; putStr x }
12:09:17 <newsham> imo, abstractions should always be taught after the concrete.  this is how humans learn.  we learn many concrete instances and only later do we observe the similarities between them and generalize.
12:09:18 <Cale> In particular, typeclasses should be mentioned somehow in the first lecture.
12:09:43 <Cale> The reason is that there are lots of typeclasses around, and in order to understand error messages, you need to know about them.
12:10:00 <dylan> newsham: really? I tend to think of generalities before I even know how something works.
12:10:01 <newsham> just as I think people should learn a new spoken language by immersion and not grammar lessons.
12:10:26 <dylan> I don't see that as orthogonal. :-/
12:10:34 <Cale> newsham: what do you think about my introduction to IO?
12:10:55 <Cale> I think it's actually best to start somewhere in the middle and work outwards in both directions in some sense.
12:10:55 <dylan> learning grammar would be the concrete underlying system, while immersion is the generic.
12:11:38 <newsham> cale; its been a while, let me refresh my memory
12:11:39 <encryptio> dylan: grammar would be general rules - immersion would be multiple discrete examples.
12:11:45 <Cale> For example, if I was going to be teaching some people about the real numbers, I'd start with the axioms for the real numbers, and worry about general rings and fields, and the explicit construction of a model for the reals later.
12:11:47 <newsham> oh, hmm. .haskell.org down for maint
12:11:54 <Cale> oh, that's odd.
12:12:03 <Cale> It was just up a second ago
12:12:06 <allbery_b> it was announced earlier today
12:12:17 <allbery_b> (or last night?  hm.  brainfuzz)
12:12:19 <dylan> encryptio: yes. Exactly how I got do-notation. I wrote using it, and later figured out how it corresponded to the funny operators.
12:12:24 <Cale> How long is the maintenance break?
12:12:34 <int-e> 10 minutes?
12:12:47 <Cale> I think I didn't understand IO properly in Haskell until I understood Parsec.
12:12:48 <int-e> that's what the announcement said.
12:13:10 <Cale> okay
12:13:18 <encryptio> i didn't understand do notation at all (in the sense of what it is) until i really understood the binding operators. ("funny operators")
12:13:23 <Cale> yeah
12:13:26 <newsham> cale: most of the intros i read so far (and I think the IO intro too, but as I say its been a while) seemed decent to me, but i think didnt spend enough time working through little details for beginners.  also I think most of them have a tendency to slip up and use a few advanced concepts in the middle of discussing beginners topics.
12:13:34 <dylan> I wonder if it helps that I implemented a language with lazy semantics back before I ever heard of haskell. XD
12:14:05 <newsham> so my opinion on most has been that they are ok for someone who is already semi-proficient and haskell but looking to get better
12:14:12 <newsham> s/ok/good/
12:14:12 <dylan> (there was one built-in function which forced evaluation of the expression tree. it wasn't useful at all, but I could do some trivial things in it)
12:14:15 <Cale> newsham: I basically introduce IO actions as these inert values which represent actions, and then introduce (>>), (>>=) and return, in that order.
12:14:36 <Cale> and do-notation along the way
12:14:45 <Cale> er, no, just after that
12:14:59 <newsham> here's something that really confused me when I first read some intros using >>=.    act1 >>= (\x -> act2 >>= (\y -> act3))   was really confusing to me.
12:15:18 <Cale> yes, which is why you shouldn't use such an abstract looking program
12:15:19 <newsham> since I'm not from a functional background, the lambdas werent at all clear to me.
12:15:26 <Cale> main = putStrLn "Hello, what is your name?"
12:15:26 <Cale>       >> getLine
12:15:26 <Cale>       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
12:15:46 <newsham> but if someone said "the lambdas just bind results to variable names", that i have good intuition for
12:15:51 <encryptio> Cale: indeed.
12:15:52 <twanvl> I think it is also important to make sure lambdas are *properly* introduced first
12:16:06 <Cale> yes, you really need lambda first
12:16:53 <newsham> thats one reason I want to see analogies made with 'let'.  i think most programmers understand the concept of binding results to variables but may not necessarily understand how that relates to (\x -> expr)
12:16:55 <Cale> I think that you need to understand types, simple values, typeclasses (using, not creating), lambda, and how to declare functions and values before attempting IO.
12:17:03 <Cale> let is a good one too.
12:17:06 <Cale> let/where
12:17:48 <Cale> Personally, I'm fairly confident that I could teach monads before IO with no problems.
12:17:54 <Saizan> aren't lambdas simpler if you think them as anonymous function?
12:18:14 <Cale> Well, that's what they are.
12:18:26 <Saizan> exactly.
12:18:40 <twanvl> Maybe (applicative) functors should be thought before monads
12:18:49 <dylan> I explain pattern-matching as variable assignment done backwards. :)
12:18:49 <Cale> Functors at least
12:19:39 <Cale> I think applicative functors are in a bit of an awkward position there.
12:19:55 <Cale> But functors definitely.
12:20:27 <Saizan> an example of functor?
12:20:32 <Cale> That's a good way to introduce monads as containers.
12:21:12 <Cale> As far as Haskell is concerned, a functor is just a datatype for which mapping a function over the elements makes sense.
12:21:27 <Cale> class Functor f where
12:21:38 <Cale>   fmap :: (a -> b) -> (f a -> f b)
12:21:49 <kyevan> Oh, foo.
12:22:09 <kyevan> Another tutorial looses me completely. in something unrelated to the subject matter.
12:22:14 <Cale> For example, lists, binary trees, Maybe, any monad.
12:22:16 <kyevan> This time, it brings up complex numbers.
12:22:23 <Cale> kyevan: what's up?
12:22:40 <dylan> complex numbers are just a hack. ;)
12:22:42 <Cale> Need help understanding complex numbers?
12:22:42 <Saizan> so istance Functor [] where fmap = map ?
12:22:48 <Cale> Saizan: exactly
12:23:00 <newsham> > (+ 1) `fmap` Just 3
12:23:02 <lambdabot>  Just 4
12:23:03 <Cale> Saizan: I consider it a mistake that fmap and map are separate
12:23:20 <kyevan> Cale: Reading http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html at the recomendation of Saizan, after complaining about Do making no sense because I have the tendency to try to understand everything instead of just smile and nod.
12:23:23 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
12:23:24 <newsham> > (+ 1) `fmap` [1,2,3]
12:23:25 <lambdabot>  [2,3,4]
12:23:35 <bd_> Cale: Isn't the justification 'optimization' or something equally pointless given static analysis?
12:23:58 <Cale> bd_: yeah, and confusing beginners, but I really think it shouldn't be a problem
12:24:05 <bd_> *nod*
12:24:12 <Cale> Functor would be one of the first classes you introduce people to.
12:24:20 <Cale> and you explain it just as I have here
12:24:27 <bd_> yeah, and go on to the monads-as-containers paradigm from there?
12:24:49 <Cale> yeah, I'm thinking maybe a little later on, but it leads in very nicely
12:25:21 <Cale> In fact, when I was teaching Haskell to one of my friends, we started out with lots of discussion with types.
12:25:51 <Cale> and by the time we got to monads, she could define the instances of Monad for most of the common monads without any help.
12:26:03 <Saizan> kyevan: you can just skip that paragraph, or just think complex numbers as an ordered pair of real with their own operations
12:26:10 <Cale> Because there's usually only one nonidiotic way to make the types match.
12:26:32 <newsham> do you generally teach haskell to math-type and fp-type people, or do you teach a lot of non-programmers or imperative-programmers?
12:26:59 * kyevan wishes someone was teaching him Haskell, instead of throwing him In a pit with a bunch of people who know it (who I will admit are very helpful most of the time ^_^ ) and a book.
12:27:28 * glguy does even remember how he first discovered Haskell
12:27:32 <glguy> doesn't*
12:27:32 <newsham> kyevan: how much $ do you have? ;-)
12:27:49 * encryptio remembers - through pugs being written in haskell.
12:27:49 <Cale> Well, in that case she's a mathy, and a python programmer. I've also taught a bit of Haskell to my friend Adeel who is another mathy, but knew very very little about programming (and hated what he'd learned)
12:28:00 <kyevan> newsham: Around 95 cents, at last check.
12:28:00 <Cale> But I've also taught monads to 11 year old kids
12:28:05 <Cale> with good success there as well
12:28:16 <glguy> I wonder if there are IRC logs back a year and a half that I could see if I announce how I started
12:28:20 <newsham> i remember very clearly, because the code was so beautiful.  it was McIlroy's "the music of streams" http://citeseer.ist.psu.edu/mcilroy00music.html
12:28:22 <lambdabot> Title: The Music of Streams (ResearchIndex)
12:28:42 <jgrimes_> are there any tutorials online to approach haskell as a math oriented person with no programming background?
12:28:55 <Cale> jgrimes_: Less than I'd want
12:29:16 <newsham> (after reading rob pike's slide deck on a similar topic, where he used one of his custom languages)
12:29:22 <Cale> I have a rather long tutorial that's been brewing in the back of my mind for a year or so.
12:29:37 <Cale> Eventually I'll write it up :)
12:29:43 <jgrimes_> :)
12:30:26 <Cale> If you teach a few basic things, it's also quite possible to teach haskell as a coordinated sequence of very small exercises.
12:30:56 <kyevan> I think there's a shortage of tutorials that teach people who aren't bad at math, just, haven't been exposed to a lot of the more complex stuff.
12:30:56 <Cale> The friend I mentioned above basically wouldn't have it any other way :)
12:31:26 <kyevan> Like, uh, me.
12:31:28 <Cale> She didn't want to sit there and listen to me prattle on about it, I was forced to quickly break everything into exercises.
12:31:44 <glguy> sjanssen: you there?
12:31:52 <Cale> and it worked fairly well
12:32:06 <kyevan> I can handle algebra, but have NO experience with anything more complex than that.
12:32:28 <encryptio> i'm a strange person. i like calculus.
12:32:46 <kyevan> encryptio: I dunno if I like it, I haven't really been exposed to it.
12:32:56 <Cale> I believe she's used Haskell for some of her study into q-symmetric polynomials
12:33:32 <Cale> The audience for Haskell is so broad :)
12:33:52 <newsham> there are people who would prefer to represent everything in terms of lambda abstractions.  there are many more who can get a lot out of haskell who dont think like that.
12:34:03 <Cale> One thing which my other friend told me was that he found programming in Haskell far more natural than programming in C++ or Java.
12:34:12 <Cale> (Right off the bat)
12:34:39 <Cale> One of the things which he pointed out is that people don't naturally think in terms of loops, but in terms of higher order functions.
12:34:43 <kyevan> Cale: To that, I have to say, I can actually do something other than copy code in Haskell.
12:35:11 <kyevan> I spent more time with Java and C++, and never got to that point.
12:36:12 <kyevan> I used to be able to do a little in Ruby, but that's because I read WpGTR a few times through, :P
12:36:22 <Cale> When you go to wash the dishes, what you're doing is a lot less like numbering the dishes and setting a variable to 0 and then incrementing it and washing the kth dish, and a lot more like map wash dishes.
12:36:40 <Cale> (that's something which he pointed out)
12:38:26 * glguy notices that he's achieved 17th most active nick
12:38:32 <kyevan> Cale: To me, washing dishes is like lazyness, too.
12:38:33 <glguy> I don't know if that's good or bad, but hurray!
12:38:39 <kyevan> I don't do it until I absolutely have to :P
12:38:47 <encryptio> lol.
12:38:53 <dylan> I do lazy evaluation with numbers all the time.
12:39:23 <dylan> "How much money do you have on you?"
12:39:39 <dylan> "I have 7 + 5 dollars in my wallet"
12:40:12 <encryptio> i count my money with an accumulator.
12:40:33 <kyevan> I count my money with a hole.
12:40:37 <newsham> cale:  for dish in dishes <- no integers involved.
12:40:48 <kyevan> However much dirt is in the hole, is how much money I have.
12:40:58 <bitshifter> foldl (+) 0 wallet
12:41:16 <newsham> (I'm not disagreeing with you, but i'm not sure I agree 100%.  i think there might be a little of both..)
12:41:23 <dylan> also... does anyone else write numbers right-to-left?
12:41:31 <twanvl> you fold your wallet and hope money comes out?
12:41:39 <kyevan> dylan: Hmm?
12:41:44 <newsham> does your wallet foldr or foldl?
12:41:45 <emu> dylan: when doing operations on them
12:41:47 <kyevan> When I'm copying one, yeh..
12:41:54 <kyevan> Or doing operations on one
12:41:59 <encryptio> dylan: sometimes i find it useful to do that, but mostly i don't.
12:42:08 <dylan> It's how I read them too.
12:42:24 <kyevan> Actually, when doing anything OTHER than straight copying, I do r-t-l
12:42:28 <dylan> my math teachers used to be annoyed by it, when I'd be reading the problem back...
12:42:31 <svref> I have a problem.  I've got an (expensive) way to look up the lattitude&longitude of a street intersection.  The same intersection is being looked up 100s of times.  The Common Lisp solution would be to make a global hash table to cache results.  How would I do something like this in Haskell?  Global hash tables seem non-possible.
12:42:42 <newsham> in soviet russia, you dont operate on function, function operates on you!
12:42:57 <kyevan> dylan: I read it back pretty much normal
12:43:14 <emu> svref: laziness
12:43:16 <kpreid> svref: the lookup presumably involves IO: wrap up the hash table with the IO source
12:43:26 <kyevan> but for "123", I would write the three, move left, write the two, move left, write the one.
12:43:34 <kyevan> It's just... more natural to do it that way.
12:43:34 <dylan> err, well, I mean when I'd point out what I was doing. In speech it would be the proper way
12:43:53 <dylan> kyevan: yes, exactly.
12:44:04 <dylan> and if you're putting commas in there, much easier still.
12:44:14 <kyevan> dylan: I don't see why that would annoy a teacher.
12:44:15 <encryptio> indeed. i never use commas in my numbers.
12:44:23 <emu> basically the idea is to return a mapping of all intersections => lat/long but only compute the ones you use
12:44:35 <svref> specifically, I can't figure out how to make a global hash table, and then strip the IOness from it so I can, say, do an "insert" on it.
12:44:45 <kyevan> Hmmm
12:44:51 <kyevan> I should bike to school.
12:45:05 <kyevan> For compclub and to finish desoldering that damn switch
12:45:19 <svref> kyevan: are you from KY?
12:45:24 <bd_> svref: Try using Data.Map. You can't use the hash table directly, because it's a mutable object.
12:45:25 <encryptio> svref: look up how to memoize a function, that's what you want to do. don't try to put lisp in haskell, and more generally, don't force specific ideas on your programming.
12:45:45 <bd_> svref: Alternately you could use immutable arrays (Data.Array) or Data.Array.Diff to construct your own pure hash table.
12:45:50 <kyevan> encryptio: I don't do lisp in haskell. Well, not always.
12:45:57 <bd_> (Which imo should be in the base libraries...)
12:46:05 <kyevan> When dealing with numbers, it's basicly lisp though :P
12:46:24 <kyevan> (Includeing parenths all over to make order of operations make sense)
12:46:56 <encryptio> i hate prefix notation. postfix i can handle, and infix is fairly natural. but prefix for some reason i can't do
12:47:05 <svref> googling of "haskell memoize" failed
12:47:35 <svref> encryptio: so you don't understand "add [1..10]"?
12:47:36 <kyevan> encryptio: I use infix in haskell, yeh.
12:47:50 <encryptio> svref: that's not what i'm talking about
12:47:57 <bd_> ? memoize
12:47:57 <newsham> > [1..10]
12:47:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:48:02 <bd_> ?where memoize
12:48:02 <lambdabot> I know nothing about memoize.
12:48:03 <glguy> (< 3 10)
12:48:07 <bd_> blah
12:48:18 <kyevan> (There are a few things where I prefer prefix, though)
12:48:32 <glguy> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
12:48:34 <dylan> @hoogle memoize
12:48:35 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/u45vz
12:48:35 <newsham> > (<) 3 10
12:48:36 <lambdabot> No matches found
12:48:37 <lambdabot>  True
12:48:38 <kyevan> For example I always use prefix when copying resistor settings to my shorthand.
12:49:26 <svref> I've programmed in LISP for years, and I agree that "<" etc are senseless in prefix
12:49:38 <glguy> People asking about memoizing, check out that mail thread
12:51:23 <lightstep> why does phooey use arrows? aren't monads flexible enough?
12:51:34 <newsham> "less than three?" 10
12:51:37 <SamB_XP> lightstep: maybe they are too flexible!
12:51:42 <emu> svref: just think of it as indicating the slope of the numbers to come
12:51:48 <newsham> err.. thats backwards.
12:51:48 <kyevan> svref: KY? No, I'm not.
12:51:59 <SamB_XP> newsham: come now!
12:52:05 <svref> glguy: you mean this "mail thread"? http://tinyurl.com/u45vz
12:52:06 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:52:06 <kyevan> ^ Took me a while to figure that out... I'm insane.
12:52:07 <newsham> sorry me being dumb
12:52:20 <glguy> svref: if that's the one with dp and tabulate, sure
12:52:55 <lightstep> SamB_XP, i can imagine "mdo {low <- islider (constant 0, high); high <- islider (low, constant 0); runDialog [low,high]"
12:53:16 <SamB_XP> oh wait.
12:53:27 <SamB_XP> newsham: forget I said "come now!"
12:53:38 <encryptio> f x = g (h x)   is the same as    f = g . h    right?
12:53:46 <glguy> yeah
12:53:52 <SamB_XP> lightstep: well, if monads let you do things you don't want to do, isn't that bad?
12:53:53 <glguy> ?pl \x = g (h x)
12:53:54 <lambdabot> (line 1, column 4):
12:53:54 <lambdabot> unexpected "="
12:53:54 <lambdabot> expecting operator, pattern or "->"
12:53:59 <glguy> ?pl \x -> g (h x)
12:53:59 <lambdabot> g . h
12:54:07 <lightstep> encryptio, the typechecking is different if you use higher-ranked types
12:59:33 <svref> How do I make this work? type Ftype = (Ftype -> Int -> IO Bool)
13:01:51 <Lemmih> svref: newtype Ftype = Ftype (Ftype -> Int -> IO Bool)
13:03:41 <svref> how do I shadow Prelude.lookup so that Data.HashTable.lookup takes precedence?
13:03:50 <glguy> import Prelude hiding (lookup)
13:04:42 <zeeeee> are there any plans to consolidate the various general utility libraries (MissingH/GenUtil/Futility/etc) into a extended-standard library (a la boost for c++)? i think that would be a great thing for haskell.
13:06:12 * Lemmih usually look at C++ and hope Haskell will go the opposite way.
13:07:08 <norpan> consolidation is not necessarily a good thing
13:07:47 <bitshifter> svref: Usualy you do something like import Data.HashTable as HT
13:08:01 <bitshifter> and then type HT.lookup when you want that
13:08:02 <zeeeee> norpan: i don't mean to suggest that everything + kitchen sink should go in there, just a lot of the very general-purpose elements
13:08:07 <svref> bitshifter: ah!
13:08:34 <lightstep> zeeeee, i think that MissingH was that library before the current rearrangement
13:08:42 <zeeeee> norpan: i do believe in eventually having something like cpan where you can easily resolve dependencies
13:08:52 <lightstep> cabal-get!
13:09:17 <ArtemGr> In Haskell there is a set of "base" libraries (those shipped with Compiler) that, unlike C++, are not set in stone, so general things go there.
13:09:18 <zeeeee> lightstep: i was told before here that that was under development
13:09:32 <lightstep> yes, it is
13:09:40 <Lemmih> So is GHC (:
13:10:24 <norpan> well haskell and related techniques need to mature some more i think
13:10:31 <zeeeee> ArtemGr: ah, so things can be more easily/liberally included...i think that's an excellent thing, will missingh/genutil be assimilated?
13:11:21 <ArtemGr> missingh was recently reorganized (see the discussion in the cafe mailing list) and some things from it are going to make it into the base, i hope
13:11:44 <SamB_XP> with cabal-get, it shouldn't make as much difference anyway...
13:12:04 <zeeeee> SamB_XP: ...once it's ready
13:12:27 <ArtemGr> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/16819/focus=16819
13:12:30 <lambdabot> Title: Gmane Loom, http://tinyurl.com/y5lfnn
13:12:34 <zeeeee> ArtemGr: yeah, i'm aware of the reorg
13:12:53 <SamB_XP> though, of course, it helps if your libraries use the same libraries (as eachother and as your program) ;-)
13:13:57 <SamB_XP> fortunately Haskell has not become popular before the internet
13:14:26 <ArtemGr> zeeeee: separation of "base" from the GHC was recently discussed too, and from what i heard it seems already possible to fetch and compile the current "base" separately from the compiler.
13:15:49 <zeeeee> ArtemGr: well, as long as things don't end up like scheme, where everyone rolls their own OO system/etc
13:17:04 <ArtemGr> zeeeee: on the contrary, it seems like "base" is already going to be like "mini-boost"
13:17:33 <ArtemGr> zeeeee: or even like "boost"; "mini-boost" doesn't include threading, and "base" does
13:18:58 <ArtemGr> zeeeee: and all those things, arrows, threading, STM - all these are relatively recent additions too...
13:26:44 <ArtemGr> SamB_XP: Boost libraries too, but they still have a different mindset, it seems. if most of it weren't header-only...
13:28:01 <SamB_XP> ArtemGr: they are header-only because that is the only way to write polymorphic code in C++
13:28:12 <zeeeee> header-only?
13:28:21 <SamB_XP> zeeeee: no .cpp file
13:28:34 <SamB_XP> just include files
13:28:47 <zeeeee> <neo>whoa</neo>
13:29:26 <SamB_XP> like, you were expecting closures to be implemented some other way?
13:29:44 <SamB_XP> zeeeee: note that C++
13:30:04 <SamB_XP> 's template language is accidentally turing-complete, and rather like a functional language at that
13:30:10 <Excedrin> in C++ terms, polymorphic has nothing to do with the template based generic programming stuff in Boost
13:30:16 <mauke> boost.preprocessor is awesome in a horrible way
13:30:20 <proj_> could anyone help out with this: http://paste.lisp.org/display/32426 ? can't seem to find a way to check whether i am reapplying it to an empty list.
13:30:28 <SamB_XP> Excedrin: well, I was using Haskell terms
13:30:34 <zeeeee> SamB_XP: never used closures
13:31:02 <Excedrin> it's turing complete for N smaller than 30 :)
13:31:10 <SamB_XP> Excedrin: how now?
13:31:12 <SamB_XP> what N?
13:31:12 <Excedrin> Haskell "polymorphic" is close to C++ "generic"
13:31:39 <SamB_XP> just think how generic Haskell "Generic" must be
13:31:41 <lightstep> proj_, you can make the patters exhaustive, and use a smart "error" statement to show you the real error
13:31:47 <cjeris> Excedrin: except without all the typing. and suck.
13:31:48 <Excedrin> all N
13:32:00 <Excedrin> cjeris: yes, clearly
13:32:24 <SamB_XP> Haskell generic is so generic it is just plain confusing!
13:32:42 <proj_> lightstep: i've tried to make it exhaustive, but i can't come up with a way that doesn't either overlap an existing pattern, or cause a different error.
13:33:02 <SamB_XP> proj_: overlapping is fine
13:33:05 <lightstep> proj_, you can overlap
13:33:15 <SamB_XP> my spellin is not
13:33:24 <SamB_XP> and my g key is even worse
13:33:43 <Excedrin> in some ways, Haskell's Dynamic stuff is closer to C++ polymorphic, except that Dynamic doesn't carry the type information around
13:33:47 <lightstep> proj_, the simplest thing would be to add a clause "nextseg xs = error (show xs)"
13:33:48 <proj_> hmph, so i should add some sort of checking if xs is null?
13:34:22 <lightstep> which would tell you exactly what the list was
13:34:59 <nomeata> Hi. Is there a type-safe interface to SQL in haskell? (Probably after you created defintions of the tables as data types, similar to what HaXML does)?
13:35:20 <proj_> well, from what i see, it tries to go past the end of the list. So the only thing i need to do is to make it stop processing at the end of the list
13:36:13 <mauke> proj_: nextseg [] = []
13:36:45 <SamB_XP> nomeata: yes, of course ;-)
13:37:06 <proj_> mauke: that does not change anything.
13:37:19 <nomeata> Can a function f of type [a] -> [a] have any other value for f [] than []?
13:37:22 * nomeata guesses no.
13:37:23 <Saizan> mauke: that wouldn't work, nextseg [x] = x resolves
13:37:33 <nomeata> SamB_XP: Where can I find it?
13:37:35 <mauke> hmm, then use lightstep's idea
13:38:01 <SamB_XP> hmm, now if only I could remember the name!
13:38:05 <SamB_XP> @where hsql
13:38:05 <lambdabot> http://htoolkit.sourceforge.net
13:38:17 * nomeata looks at that.
13:38:23 <chessguy> @bot
13:38:24 <lambdabot> :)
13:38:30 <Saizan> the problem is when you apply nextseg to [3] and it has no y to compare, but if you have only and element you can put it in the precedent list
13:39:02 <Excedrin> http://haskelldb.sourceforge.net/
13:39:04 <lambdabot> Title: HaskellDB
13:39:10 <lightstep> nomeata, in HM it can't, in Haskell it can be _|_, in a polytypic calculus is can have many values
13:40:16 <lightstep> but i don't know the math to prove this
13:40:27 <nomeata> lightstep: ok, so a strict function of type [a] -> [a] in haskell has always f [] == []?
13:40:41 <SamB_XP> if it is complete!
13:41:10 * nomeata tries to remember what complete and what strict means.
13:41:23 <lightstep> even a complete non-strict function would have f [] == []
13:41:24 <nomeata> strict means, it is defined for all inputs, isn’t it?
13:41:25 <norpan> does it matter if it's strict?
13:41:28 <SamB_XP> but, strictness has little to do with it...
13:41:37 <SamB_XP> nomeata: no, that is complete
13:41:38 <TSC> Complete as in, "not a partial function"
13:41:55 <norpan> as in never evaluating to bottom
13:42:02 * lightstep dislikes python: it doesn't have mdo
13:42:10 <SamB_XP> strict means it demands input before giving output
13:42:28 <twanvl> It can also be f [] = [_|_]
13:42:47 <Excedrin> what happens here:
13:42:48 <Excedrin> > fromDyn (toDyn (1 :: Int)) 0 :: Float
13:42:49 <lambdabot>  0.0
13:43:12 <lightstep> an int isn't a float
13:43:16 <norpan> Excedrin: 1 :: Int is not a float so it takes the default argument
13:43:18 <nomeata> so is strict = eager?
13:43:23 <lightstep> yes
13:43:31 <proj_> lightstep: using your method i get uhm, [[1,2,3,4,5],[1,2,3*** Exception: [4]
13:43:32 <SamB_XP> something like that
13:43:33 <nomeata> ok, thx
13:43:47 <Excedrin> ok, but an Int is an Integer?
13:43:52 <norpan> no
13:43:59 <lightstep> proj_, that means nextseg is called with [4]
13:44:00 <norpan> Int is 32 or 64 bits
13:44:02 <SamB_XP> > fromDyn (toDyn (1 :: Int)) 0 :: Integer
13:44:02 <Excedrin> > fromDyn (toDyn (1 :: Int)) 0 :: Integer
13:44:03 <lambdabot>  0
13:44:04 <lambdabot>  0
13:44:13 <norpan> Integer is arbitrary number of bits
13:44:22 * SamB_XP accidentally helps demonstrate referential transparency ;-)
13:44:46 <proj_> lightstep: yep, and the list for nextseg needs to be at least two in length for it to finish
13:45:04 <Excedrin> oh, I was misreading something that confused me
13:45:32 <chessguy> arbitrary number of bits? but it has a maxbound
13:45:33 <lightstep> proj_, well, do you want to allow or disallow segments of length 1?
13:45:34 <SamB_XP> norpan: sometimesInt is 30 bits
13:45:38 <SamB_XP> it could be 31 bits
13:45:41 <chessguy> ?maxbound::Integer
13:45:41 <lambdabot> Unknown command, try @list
13:45:44 <chessguy> ?maxBound
13:45:45 <lambdabot> Unknown command, try @list
13:45:49 <SamB_XP> sometimes it might be 63 or 62 or 60 bits!
13:45:49 <lightstep> @info Integer
13:45:50 <lambdabot> Integer
13:45:50 <Excedrin> Typeable is really neat
13:45:57 <norpan> > maxBound :: Integer
13:45:57 <lambdabot>  add an instance declaration for (Bounded Integer)
13:45:58 <lambdabot>   In the expression: ma...
13:46:03 <norpan> chessguy: no it hasn't
13:46:10 <chessguy> hmm
13:46:17 <chessguy> > maxBound :: Int
13:46:19 <lambdabot>  2147483647
13:46:27 <proj_> lightstep: segments of length 1 are fine, i just need to add something so that it stops invoking itself after the list has ended
13:46:29 <chessguy> but Integer doesn't?
13:46:35 <norpan> SamB_XP: sometimes?
13:46:44 <chessguy> > 2^100
13:46:46 <lambdabot>  1267650600228229401496703205376
13:46:53 <SamB_XP> norpan: depends on the compiler
13:46:54 <chessguy> > 2^1000
13:46:56 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
13:47:01 <norpan> SamB_XP: well, certainly
13:47:03 <SamB_XP> the standard only says it must be at least 30 bits
13:47:05 <chessguy> > 2^10000
13:47:07 <lambdabot>  1995063116880758384883742162683585083823496831886192454852008949852943883022...
13:47:11 <lightstep> proj_, you need both, so that nextseg won't crash, and walker won't loop
13:47:17 <chessguy> > 2^100000
13:47:20 <lambdabot>  9990020930143845079440327643300335909804291390541816917715292738631458324642...
13:47:21 <SamB_XP> I believe yhc uses 30
13:47:22 <chessguy> wow
13:47:25 <proj_> lightstep: yep
13:47:30 <norpan> chessguy: impressive, eh
13:47:34 * chessguy ceases playing with the bot
13:47:35 <SamB_XP> at least, on 32-bit machines
13:47:56 <chessguy> ok, one more
13:48:05 <chessguy> > 2^(2^10000)
13:48:09 <lambdabot> Terminated
13:48:14 <chessguy> haha!
13:48:21 <SamB_XP> > 2^(2^100)
13:48:23 <Saizan> proj_: http://paste.lisp.org/display/32426#1
13:48:24 <lambdabot> Terminated
13:48:26 <chessguy> that breaks ghc too
13:48:48 <SamB_XP> well, yours was bigger than googolplex, I'm 99% sure!
13:49:15 <SamB_XP> > 2^(2^(2^2))
13:49:17 <lambdabot>  65536
13:49:31 <proj_> Saizan: ah, i totally forgot about walker =/
13:49:42 <chessguy> > 2^(2^(2^(2^2)))
13:49:44 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
13:49:47 <Saizan> it ccrashed my ghci too :D
13:50:02 <proj_> ty lightstep, Saizan
13:50:40 <huschi> has anybody read the "The Haskell School of Expressions" and can recommend it?
13:50:56 <chessguy> oh, i wondered what HSoE was. now i know
13:51:04 <Saizan> np
13:51:23 <huschi> it'sbook :)
13:51:30 <nomeata> chessguy: why, were you wondering whether you should apply, or whether the tuition is too much?
13:51:45 <nomeata> chessguy: and maybe you though in what concurrency you have to pay the tuition :-)
13:52:19 <nomeata> I heared that the school has only one fraternity, lambda.
13:52:23 <chessguy> no, i mean i was wondering what the acronym meant
13:52:27 <huschi> my parents asked what they can present me x-mas.
13:52:55 <lightstep> how can i get gtk2hs and ghc6.6 on ubuntu?
13:52:56 <huschi> and now i want to know if this book is good.
13:52:58 <SamB_XP> nomeata: how about STM concurrency?
13:53:12 <nomeata> lightstep: you can’t get it anywhere at the moment, unfortunately
13:53:15 <chessguy> yeah, i think i'm gonna spend some Christmas and/or graduation money on a/some haskell book(s)
13:53:21 <SamB_XP> what? no tau-epsilon-chi fraternity?
13:53:26 <fasta> What exactly makes a type an "associated type"?
13:53:36 <nomeata> lightstep: at least not with a released version of gtk2hs :-(
13:53:39 <lightstep> nomeata, it'd not ported yet?
13:53:43 <SamB_XP> fasta: if it is associated to something
13:53:46 <nomeata> they are working on it
13:53:48 <SamB_XP> in particular, a class
13:54:40 <SamB_XP> nomeata: they still haven't gotten gtk2hs working with -threaded?
13:55:24 <fasta> SamB_XP: Do you also know a somewhat longer answer?
13:55:24 <nomeata> not sure what the problem is
13:56:37 <SamB_XP> class Foo a where data Bar a :: *
13:57:13 <SamB_XP> of course, that example is useless because you can't do anything with it...
13:58:09 <fasta> SamB_XP: associated types are not implemented in any Haskell implementation, right?
13:58:17 <SamB_XP> fasta: wrong!
13:58:32 <SamB_XP> that kind is implemented in 6.7 at least
13:58:44 <fasta> SamB_XP: I tried an example from a paper, and that didn't compile (in 6.6).
13:58:54 <SamB_XP> soon we should get associated type synonyms, too, and then I can translate the MTL ;-)
13:59:18 <fasta> SamB_XP: MTL?
13:59:29 <SamB_XP> monad thingy library
13:59:35 <twanvl> transformer
13:59:36 <fasta> SamB_XP: I thought you meant that
13:59:45 <fasta> SamB_XP: but what's to translate about that?
13:59:54 <glguy> it uses fundeps now
14:00:07 <SamB_XP> well, you can rewrite it to use associated type synonyms
14:00:28 <fasta> SamB_XP: what's the syntax for those associated type synonyms?
14:00:41 <fasta> SamB_XP: is it documented somewhere already?
14:01:02 <SamB_XP> hmm. I don't know. but GHC 6.7 will parse it!
14:01:07 <SamB_XP> it won't typecheck though
14:01:29 <SamB_XP> (for some reason ChilliX added all the syntax at once)
14:01:41 <fasta> Who's ChilliX?
14:01:43 <lightstep> if the syntax of mtl will change, doesn't it make sense to also add some missing featues from monadLib and make the naming convention more concise?
14:02:24 <lightstep> like that function Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
14:02:26 <SamB_XP> naming convention?
14:03:04 <SamB_XP> and, sure, why not?
14:03:38 <glguy> lightstep: >=> ?
14:03:51 <SamB_XP> glguy: I can only assume that is what he menat
14:03:57 <lightstep> MonadState instead of StateM. and State being the non-transformer version (which is less useful)
14:04:27 <SamB_XP> well, MonadState goes with MonadPlus and MonadZero
14:04:44 <SamB_XP> nevermind that MonadZero doesn't exist at the moment
14:04:56 <lightstep> why does MonadPlus make sense when we have Monoid?
14:05:10 <SamB_XP> @kind MonadPlus
14:05:11 <lambdabot> Class `MonadPlus' used as a type
14:05:12 <glguy> MonadPlus is a container
14:05:15 <glguy> Moniod isn't
14:05:33 <SamB_XP> anyway, if :kind worked on classes, that would help show why ;-)
14:05:39 <SamB_XP> @instances Monoid
14:05:40 <bd_> MonadPlus and MonadZero? I think you mean mplus and mzero :)
14:05:40 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
14:05:44 <lightstep> well, usually we have MonadPlus c iff forall a. Monoid (c a)
14:05:46 <SamB_XP> @instances MonadPlus
14:05:48 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:06:04 <glguy> bd_: MonadPlus and MonadZero woudl be the classes that define things that have those two functions
14:06:08 <SamB_XP> lightstep: except people don't bother to implement Monoid usully
14:06:17 <bd_> glguy: What use would mplus be without mzero?
14:06:20 <sjanssen> lightstep: but can you actually write a type signature like that?
14:06:26 <bd_> or vice versa...
14:06:47 <SamB_XP> bd_: well, I think MonadZero also had the fail function
14:06:53 <bd_> hmm
14:07:12 <SamB_XP> and, well, you can see how that is usefull without MonadPlus, right? ;-)
14:07:26 <glguy> MonadZero was a MonadPlus in addition to mzero
14:07:30 <sjanssen> the hierarchy should probably be Monad m => MonadZero m => MonadPlus m
14:07:30 <bd_> fail is implemented in a number of monads without mzero though :) Though I suppose you could say mzero = fail "mzero"
14:07:35 <SamB_XP> glguy: uh
14:07:36 <glguy> MonadPlus would just be something with only mplus
14:07:38 <lightstep> sjanssen, we could have an empty class MonadPlus
14:07:43 <cjeris> SamB_XP: failing is always useful :D
14:07:49 <SamB_XP> glguy: seriously?
14:08:07 <sjanssen> lightstep: hmm, that might work
14:08:20 <glguy> SamB_XP: well, I thought that the intent was to have things that did have mplus and didn't have mzero
14:08:28 <lightstep> SamB_XP, i see that as a problem
14:08:28 <glguy> SamB_XP: not to have mzero wihtout mplus
14:08:44 <SamB_XP> I was thinking like sjanssen, but then I don't think about it much
14:08:53 <SamB_XP> so maybe you are right
14:09:33 <glguy> it's very likely that I misunderstood
14:10:03 <glguy> I think Cale argued that Monad should nto have fail, and that that should be a part of MonadZero
14:10:14 <glguy> so then it would make sense to have MonadZero and not MonadPlus
14:10:59 <lightstep> glguy, i'd prefer that the hierarchy be: Monad; IdentityElement => Monoid
14:11:13 <lightstep> maybe Monad => MonadFail
14:11:15 <SamB_XP> lightstep: I don't think you can do that conveniently
14:11:48 <twanvl> The problem with taking fail out of Monad is pattern matching in do notation
14:12:10 <sjanssen> right, it still could be done
14:12:11 <glguy> twanvl: why is that a problem? if there is no MonadFail instance... it's an error
14:12:25 <SamB_XP> glguy: only if the pattern is incomplete
14:12:34 <glguy> SamB_XP: exactly
14:12:39 <SamB_XP> i.e., only if the type has multiple constructors
14:12:43 <sjanssen> we'd just have weird things like changing an irrefutable pattern to a refutable one changes the class contexts of a function
14:12:50 <SamB_XP> heh
14:13:01 <norpan> normal values don't have fail and you can still pattern match in for instance let expressions
14:13:20 <SamB_XP> well. true.
14:13:22 <glguy> > let f 0 = 1 in f 2
14:13:24 <lambdabot>  Non-exhaustive patterns in function f
14:13:32 <SamB_XP> fail does have a default implementation doesn't it?
14:13:40 <sjanssen> norpan: but we want the magic fail effects when pattern matching in do
14:13:42 <glguy> fail = error
14:13:55 <kpreid> > runState (fail "ding") 0
14:13:56 <lambdabot>  Add a type signature
14:14:00 <kpreid> > runState (fail "ding") "a"
14:14:01 <lambdabot>  Add a type signature
14:14:12 <glguy> fail = error -- default
14:14:13 <kpreid> > runState (fail "ding" :: State String Int) "a"
14:14:15 <lambdabot>  Exception: ding
14:14:32 <norpan> sjanssen: maybe we do, maybe we don't :)
14:14:35 <glguy> > error "does this say exception?" :: ()
14:14:36 <lambdabot>  Exception: does this say exception?
14:14:40 <glguy> yeah, like that
14:15:20 <lightstep> why do we want magic effects on pattern match failure? it's a bug, and haskell usually crashes with such bugs
14:15:33 <twanvl> it's a feature!
14:15:39 <sjanssen> lightstep: it's very convenient
14:15:53 <glguy> > [a | (Just a) <- [Nothing,Just 1]]
14:15:55 <lambdabot>  [1]
14:16:10 <lightstep> twanvl, the non-exhaustive pattern is a bug
14:16:33 <sjanssen> lightstep: no, it's an intentional feature in the Haskell standard
14:16:45 <kpreid> non-exhaustive is a concept which applies best to multiple patterns
14:18:26 <lightstep> still, you shouldn't rely on the side effects of a bad pattern match
14:19:09 <sjanssen> lightstep: why not?  the behavior is well specified, and quite useful in many monads like [], Maybe, IO, etc.
14:19:26 <sjanssen> well, not quite as useful in IO
14:19:41 <lightstep> using it in list comprehensions is one thing - it's like pattern guards
14:19:47 <sjanssen> you should use real error messages rather than "pattern match failure at xxx"
14:20:12 <lightstep> when binging in a do block, you shouldn't leave a pattern that might not be fulfilled. it seems bad
14:20:38 <sjanssen> lightsteps: list comprehensions and do blocks are practically the same thing
14:21:19 <lightstep> it seems that the authors said "wow, we have a syntax that requires the user to implement a class. let also hang on it something to beautify pattern match failure"
14:22:06 <sjanssen> the idea is to cut out boilerplate
14:22:10 <lightstep> > fail "a" :: Just Int
14:22:11 <lambdabot>  Not in scope: type constructor or class `Just'
14:22:17 <lightstep> > fail "a" :: Maybe Int
14:22:19 <lambdabot>  Nothing
14:22:47 <lightstep> > do {Just x <- fail "a"; return x;} :: Maybe Int
14:22:49 <lambdabot>  Nothing
14:22:50 <sjanssen> writing "do x <- m; case x of { pat -> dostuff; _ -> fail "blast!"};" is stupid extra work
14:23:26 <nomeata> [a | (Right a) <- [ Left "foo", Left "bar", Right "baz", Right "blah" ]]
14:23:33 <nomeata> > [a | (Right a) <- [ Left "foo", Left "bar", Right "baz", Right "blah" ]]
14:23:34 <lambdabot>  ["baz","blah"]
14:23:45 <lightstep> the list comprehension isn't similar to a do block in this sense
14:23:56 <lightstep> it's more like pattern guards
14:24:21 <sjanssen> lightstep: list comprehensions are exactly the same as do in the list monad
14:24:43 <dylan> > do { (Right a) <- [ Left "foo", Left "bar", Right "baz", Right "blah" ]; return a }
14:24:45 <lambdabot>  ["baz","blah"]
14:24:53 <sjanssen> with extra sugar for boolean conditions
14:24:59 <glguy> except that they only work on do-notation code that ends with a return (=
14:25:40 <nomeata> are they defined via the list monad, or does it just happen to have the same semantics?
14:25:50 <chessguy> 'll take a list monad with extra sugar, please. and can i get the effects on the side?
14:26:24 <lightstep> > do {(Left x) <- Right 2; return x}
14:26:25 <lambdabot>  add an instance declaration for (Num (Either a b))
14:26:27 <sjanssen> nomeata: originally, Haskell had general monad comprehensions, so the roots of the syntax are monadic
14:26:32 <lightstep> > do {(Left x) <- Right 'a'; return x}
14:26:33 <lambdabot>  Couldn't match `Char' against `Either a b'
14:26:34 <fasta> SamB_XP: So, the idea of associated types is that certain types only exist in the context of another type. In Haskell this "other" type is a type class.
14:26:44 <int-e> chessguy: no can do, we're out of effects for today
14:26:45 <nomeata> > Maybe (a | a <- Just 1, a /= 1)
14:26:45 <lambdabot>  Parse error
14:26:51 <SamB_XP> fasta: eh. not quite.
14:26:57 <nomeata> That would be a maybe comprehension, which you may or may not comprehend.
14:27:15 <chessguy> int-e, aww. can i just get a couple of lambda applications then?
14:27:29 <sjanssen> a class with an associated type is a type level function
14:27:37 <nomeata> sjanssen: general monad comprehens, what syntax did they have?
14:27:53 <lispy> is it possible to use godel's incompleteness to argue that the H98 type system needs things like unsafeCoerce?
14:27:59 <lightstep> like list comprehensions, iirc
14:28:00 <SamB_XP> nomeata: [a | a <- Just 1, a /= 1]
14:28:06 <sjanssen> nomeata: same syntax, I think.  Of course, I was something like 10 years old when they were still in Haskell
14:28:10 <dylan> lightstep:
14:28:12 <dylan> > do { (Right a) <- [ Left "foo" ]; return a }
14:28:13 <lambdabot>  Add a type signature
14:28:20 <dylan> d'oh.
14:28:24 <SamB_XP> sjanssen: how old are you now?
14:28:41 <sjanssen> SamB_XP: 21, I probably didn't get the numbers exactly right
14:28:44 <nomeata> sjanssen: and don’t answer in the list or maybe monad
14:29:02 <emu> what is it called when i do something like: "instance (Foo m) => Monad m where" and then define a translation of some sort between things of class Foo and Monads? its some extension required
14:29:03 <sjanssen> I was likely even younger than 10
14:29:42 <SamB_XP> emu: overlapping instances
14:29:44 <lightstep> > do {4 <- Right 3; Right 4}
14:29:44 <lambdabot>  Add a type signature
14:29:46 <sjanssen> emu: you'll need at least overlapping instances
14:29:53 <lightstep> > do {4 <- Right 3; Right 4} :: Either Int Int
14:29:54 <emu> it also said i needed undecidable ones
14:29:54 <lambdabot>  add an instance declaration for (Error Int)
14:29:55 <lambdabot>   In a 'do' expression: 4 <- ...
14:30:08 <lightstep> > do {4 <- Right 3; Right 4} :: Either String Int
14:30:10 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:4"
14:30:17 <SamB_XP> emu: the compiler is generally right about these things
14:32:07 <emu> i'm trying to view a portion of my program as a monad
14:32:13 <emu> essentially it's a state machine
14:32:25 <emu> well, a class of state machines
14:32:29 <lightstep> sjanssen, it may help some programs that the error is wrapped nicely in some Left or Nothing, but is may also hide bugs (especially in the Nothing case). but it's a very specific mechanism that makes the same syntax in different parts of the language do different things
14:32:47 <fasta> SamB_XP: then what is it?
14:33:42 <SamB_XP> fasta: well, an associated type is actually a family of types
14:33:57 <SamB_XP> it is indexed by one or more of the parameters to the typeclass
14:37:40 <fasta> SamB_XP: Hmm, thanks for your answer, but I think I will just need to find some good C++ book that explains it somewhat more elaborate.
14:38:06 <SamB_XP> what? you are talking about C++?
14:39:00 <sjanssen> fasta: oh, you know C++?  Are you familiar with "traits templates", or typedefs that are members of a template?
14:39:15 <sjanssen> because they're quite close to ATs
14:39:15 <fasta> SamB_XP: well, associated types came from Smalltalk, then went to C++ and apparently GHC wants them too.
14:39:24 <SamB_XP> Here is MonadError using ATs: http://www.cse.unsw.edu.au/~pls/repos/phrac/tests/examples/MonadError.phc
14:39:25 <lambdabot> http://tinyurl.com/y3buxb
14:39:35 <SamB_XP> fasta: ... smalltalk has types?
14:39:48 <fasta> SamB_XP: traits
14:39:56 <SamB_XP> ... traits?
14:40:02 <SamB_XP> what does that have to do with anything?
14:40:31 <sjanssen> SamB_XP: ATs and trait templates are very similar mechanisms
14:40:31 <SamB_XP> aren't traits objects just explicit vtables?
14:41:04 * SamB_XP only really knows about traits from Self/Slate...
14:41:12 <fasta> I am not a Smalltalk expert, but that's what some C++ experts said in some books.
14:41:38 <twanvl> They are more like local typedefs, like something::iterator
14:41:41 <mwc> I thought C++ took it's OO and type cues from Simula
14:41:43 <fasta> SamB_XP: phc is Parallel ...?
14:41:48 <SamB_XP> fasta: no
14:41:50 <sjanssen> fasta: have you read the various papers on ATs by Chakravarty and company?
14:41:59 <fasta> sjanssen: no
14:42:09 <SamB_XP> http://www.cse.unsw.edu.au/~chak/papers/CKP05.html
14:42:10 <lambdabot> Title: Research Papers of Manuel Chakravarty
14:42:34 <mwc> so AT's are type associated with a type class?
14:42:56 <SamB_XP> they are basically methods of the typeclass, yes
14:43:40 <mwc> type MError m; that means that types m of the MonadError class each have an associated type MError that embeds an m?
14:44:46 <SamB_XP> mwc: an associated MError m type
14:45:02 <mwc> huh, so MError is parameterized over the m or what?
14:45:10 <SamB_XP> it need not embed m, but nothing prevents it
14:45:14 <mwc> as in Set a or whatever?
14:45:25 <sjanssen> mwc: m is a parameter of the MError type for syntactic and type inference reasons
14:45:32 <SamB_XP> well actually I think it can't
14:45:37 <SamB_XP> hmm.
14:45:44 * SamB_XP thinks.
14:45:51 <SamB_XP> no, no, it can ;-).
14:46:26 <lightstep> for each MonadError, you have the associated error type. like IOError for IO
14:46:32 <lightstep> so MError IO = IOError
14:46:55 <SamB_XP> though maybe Exception would be better?
14:47:35 <lightstep> perhaps - i don't understand this awkward squad at all
14:47:52 <SamB_XP> @hoogle catch
14:47:53 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
14:47:53 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
14:47:53 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
14:48:14 <mwc> Oh I see hwo this works
14:48:17 <SamB_XP> I must say I tend to use Control.Exception more than the IOError
14:48:53 <fasta> type MError m; seems to be an associated type, but I don't see how this ever could be a "method".
14:49:17 <mwc> I was thinking the associated type would be more functionlike, so type MError m; looks like a function call on a type: MError Foo
14:49:40 <mwc> @seen musasabi
14:49:41 <lambdabot> I saw musasabi leaving #ghc, #haskell-overflow, #haskell-blah, #haskell and #Haskell 17d 8h 1m 17s ago, and .
14:49:55 <lightstep> can you define a default for an associated type?
14:50:04 <fasta> It was described as type-level overloading, IIRC.
14:50:43 <SamB_XP> lightstep: I think so
14:50:59 <SamB_XP> it certainly shouldn't be a problem with the associated type synonyms
14:52:05 <SamB_XP> mwc: well, in this file, MError (Either e) = e
14:52:45 <mwc> so do AT's exist anywhere yet?
14:53:05 <SamB_XP> GHC 6.7 has the non-synonym associated types
14:53:13 <SamB_XP> (that is, the darcs version)
14:54:20 <joene_> hi
15:07:08 <Cale> GHC 6.7 has lots of awesome stuff :)
15:07:28 <audreyt> 'cept it doesn't compile on MacIntel at the moment with -split-obj :)
15:08:37 <liquidengineer> there's a new GHC out?
15:08:40 <glguy> > let half (_:_:n) = ():half n; half _ = [] in half [(),(),(),(),(),()]
15:08:42 <lambdabot>  [(),(),()]
15:09:40 <liquidengineer> Is it for mass consumption, or a development version?
15:09:51 <glguy> 6.odd is dev version
15:11:07 <liquidengineer> ah
15:11:23 <araujo> hi hi
15:11:24 <liquidengineer> any big changes between this and 6.6?
15:11:27 <liquidengineer> Or bugfix?
15:12:00 <glguy> it's got a new internal type representation system to unify all of the type system extensions, I believe
15:12:22 <liquidengineer> Hmm
15:12:34 <liquidengineer> What does that mean for coding?
15:12:42 <liquidengineer> or is it an under the hood thing?
15:13:33 <sorear> head vs. 6.6: Associated types, for a start
15:21:07 <dons> moin
15:22:36 <kfish> moin dons
15:31:21 <dons> http://programming.reddit.com/info/utz4/details
15:31:30 <dons> lambdabot?
15:31:53 <dons> ?users
15:31:53 <lambdabot> Maximum users seen in #haskell: 291, currently: 277 (95.2%), active: 41 (14.8%)
15:31:56 <dons> oh!
15:32:39 <sorear> ?list tinyurl
15:32:40 <lambdabot> No module "tinyurl" loaded
15:33:11 <dons> wow. maybe we will reach 300 by xmas
15:33:51 <sorear> ?list url
15:33:52 <lambdabot> url provides: url-title tiny-url
15:35:12 <lightstep> lambdabot, what is an active user?
15:35:25 <sorear> any clue why the -cafe@ traffic quintupled this week ?
15:35:45 <lambdabot> lightstep, a person who's spoken in the last 4 hours
15:35:50 <sorear> I've had to start checking the subjects!
15:35:51 <dons> sorear: hmm the new textbook discussion?
15:36:03 <dons> sorear: or an influx of new programmerS?
15:36:47 <lightstep> wow, lambdabot is intelligent
15:37:11 <liquidengineer> what's an associated type?
15:37:27 <emu> lambdabot, what is a monad?
15:37:45 <emu> i think i blew it's mind
15:37:53 <newsham> ?where programming
15:37:53 <lambdabot> I know nothing about programming.
15:38:21 <dons> sorear: its growing, but not sure its 4x this week:)  http://gmane.org/plot-rate.php?group=gmane.comp.lang.haskell.cafe
15:38:27 <sorear> ?where monads
15:38:27 <lambdabot> http://www.nomaware.com/monads/html/index.html
15:38:28 <yip> hey guys
15:38:36 <sorear> aww :)
15:38:53 <yip> i have a question about ghc and multithreading
15:39:23 <dons> yep. ask away
15:39:57 <yip> if i run with +RTS -N 2, then the program will be run on 2 threads?
15:40:07 <lightstep> liquidengineer, a function from types to types whose domain is a type class
15:40:20 <dons> +RTS -N2
15:40:21 <dons> yeah
15:40:23 <dons> (with ghc 6.6)
15:40:27 <bd_> yip: Only if you program it to use multiple threads. +RTS -N 2 sets the size of the OS thread pool, haskell threads will be assigned to OS threads out of that pool
15:40:30 <dons> 2 OS threads, on 2 processors
15:40:38 <bd_> so forkIO or `par` will use multiple OS threads if you do that
15:41:05 <newsham> does ghc ever try to insert par's where they arent specified?
15:41:12 <yip> hm... well i'm trying to understand why gtk2hs won't work with a threaded rts, while hopengl will work
15:41:28 <dons> newsham: not yet...
15:43:58 <sorear> if I read the docs correctly a while ago, Gtk needs to be told that you are going to use threads...  dunno if ...2Hs does the telling.
15:44:23 <Excedrin> therp: how's your Liskell paper coming?
15:49:02 <emu> yip: don't forget to compile with -threaded
15:49:23 <yip> emu: gtk2hs doesn't support that compile option
15:51:13 <astrolabe> hey dons is no 2! http://programming.reddit.com/
15:51:40 <reppie> wanna hold a brick on your dick?
15:51:43 <reppie> err
15:51:46 <segosa> hello. i'm learning haskell, and it feels like i've gone back in time to when I was learning how to code in procedural languages. anyway, I'm testing various things and I can't get this work: http://rafb.net/paste/results/vK9gym72.html
15:51:51 <reppie> stupid spam
15:51:54 <glguy> http://www.microsoft.com/athome/security/children/leetspeak.mspx
15:51:56 <lambdabot> Title: A parent's primer to computer slang
15:51:57 <glguy> this is good to know
15:52:07 <emu> segosa: keep going back in time, revert procedural thinking ;)
15:52:16 <segosa> heh, exactly
15:52:24 <segosa> i'm not used to this, i'm having to relearn how to code :(
15:52:47 <emu> er, you dont need to indent everything
15:53:11 <dibblego> learning haskell is very self-confrontational - as you learn that your value system around "computer programming" does not necessarily hold
15:53:22 <lightstep> what do you type to get that error?
15:53:27 <segosa> "main"
15:53:42 <lightstep> if you call runhaskell on that file, it should work
15:53:46 <therp> excedrin: fine thanks. tomorrow I'm going to submit it to the conference committee
15:54:11 <lightstep> i'm not sure how to invoke main from hugs' prompt
15:54:26 <segosa> hm :/
15:54:39 <emu> hugs prompt is a bit different from ghci is all i know
15:55:11 <segosa> well you see
15:55:15 <segosa>         main = do
15:55:15 <segosa>                 putStrLn "Hello there"
15:55:22 <segosa> if I have that, and I type "main" in hugs, it works
15:55:26 <segosa> Main> main
15:55:26 <segosa> Hello there
15:55:32 <emu> add: main :: IO () perhaps
15:55:36 <LordBrain> What's a total langauge vs a partial language?
15:55:57 <emu> maybe hugs can't figure that out for some reason
15:55:58 <segosa> that worked, emu
15:56:11 <emu> because your function is really IO _|_
15:56:16 <segosa> o.o
15:56:20 <segosa> _|_ ?
15:56:23 <emu> bottom
15:56:29 <emu> ie. never halts
15:56:39 <segosa> oh.
15:56:45 <segosa> well, yeah, i know, that was just for testing purposes
15:56:46 <lightstep> hmm, hugs shouldn't care about that
15:56:54 <segosa> i mean, the infinite loop thing
15:56:57 <emu> yea but it's type-checker might not be able to infer the type
15:56:58 <segosa> hm
15:57:00 <segosa> ah
15:57:11 <emu> and for some reason, it cares that main is IO ().  I think ghc is more permissive.
15:57:30 <emu> if you ask ghci for the type of such a function, it will give you "IO t" also
15:57:50 <lightstep> i have trouble compiling gtk2hs: System.Glib imports System.Glib.UTFString, but somehow it's not in the module path. is there some configure option that is relevant?
15:58:13 <yip> how is a haskell program supposed to return a value? main :: IO Int?
15:58:26 <emu> yip: import System.Exit; exitWith ...
15:58:35 <yip> thanks!
15:58:49 <emu> i believe it expects some particular data type
15:58:52 <emu> @type exitWith
15:58:54 <lambdabot> Not in scope: `exitWith'
15:58:57 <liyang> segosa: add another line, return (), to the end of your main function.
15:58:57 <emu> @hoogle exitWith
15:58:58 <lambdabot> System.exitWith :: ExitCode -> IO a
15:59:26 <emu> segosa: that would allow it to derive IO () from the function
15:59:41 <segosa> uh
15:59:52 <emu> @type return ()
15:59:54 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
16:00:11 <dons> ?hoogle ExitWith
16:00:12 <lambdabot> System.exitWith :: ExitCode -> IO a
16:01:18 <segosa>  <emu> segosa: that would allow it to derive IO () from the function << yeah, but how do i use it?
16:01:37 <segosa> liyang: okay
16:01:50 <emu> already using monads in IRC chat? (<<)
16:02:04 <segosa> o.o
16:02:10 <dons> hehe, someone posted it to digg, http://digg.com/programming/Haskell_code_is_smarter_than_C
16:02:11 <lambdabot> Title: digg - Haskell code is smarter than C++
16:02:15 <dons>      
16:02:44 <emu> segosa: well, i had you add an explicit type annotation because it couldn't figure out that main was IO ().  but if you added "return ()" to the end, then it would be able to figure that out for itself.
16:02:57 <segosa> oh, I see
16:03:07 <segosa> I wasn't sure if yuo were referring to what liyang said or not, heh
16:03:31 <emu> dons: i say we take it a step further and write code with a type setting engine
16:04:04 <emu> ASCII-ified math notation drives me bonkers anyhow
16:04:20 <allbery_b> hate to tell you, but TeX has been done already :)
16:04:30 <emu> i don't mean that
16:04:35 <dons> yeah, and now that ghc 6.6 supports unicode identifiers
16:04:50 <dons> emu, but you want Frege's notation for your inductive definitions?   :)
16:05:03 <emu> i mean a combination of .. er .. texmacs with ghci
16:05:14 <emu> i think mathematica kinda does it
16:05:50 <emu> you can write a Frege frontend for it!
16:06:00 <allbery_b> suddenly I'm imagining ghci on an HP48 using its algebraic input method
16:06:46 <SamB_XP> allbery_b: I think they are talking about a version of TeXmacs that isn't written in C++ and doesn't crash
16:06:50 <dons> have you seen ProofGeneral's interface? to ML/Isabelle
16:06:53 <sorear> there is already a texmacs/maxima frontend...
16:06:57 <dons> that does nice markup with unicode syms
16:07:10 <dons> (but not texx-style)
16:07:21 <emu> hmm, no i haven't
16:07:30 <SamB_XP> oh, and maybe one with a decent UI
16:08:01 <dons> jcreigh++ http://praisecurseandrecurse.blogspot.com/2006/12/revised-dot-matrix-printhead.html
16:08:04 <lambdabot> Title: Praise, Curse, and Recurse: The Revised Dot-Matrix Printhead, http://tinyurl.com/ym7hpg
16:08:05 <emu> texmacs/literatehs
16:08:15 <JoeKarma> What is the connection between Haskell and cognitive dissonance?
16:08:16 <sorear> hmmm .. Yi?
16:08:28 <SamB_XP> does Yi support rich text?
16:08:33 <dons> JoeKarma: It causes it in imperative programmers :)
16:08:38 <dons> (little joke)
16:08:54 <dons> ?users
16:08:54 <lambdabot> Maximum users seen in #haskell: 291, currently: 272 (93.5%), active: 43 (15.8%)
16:09:06 <sorear> SamB: If yi is to replace emacs completely it will have to implement some kind of enriched-mode.
16:09:18 <JoeKarma> Ah, that explains it then.  Thanks.
16:09:27 <SamB_XP> sorear: yeah.
16:09:49 <SamB_XP> does Yi support splitscreen yet?
16:10:14 <LordBrain> yeah
16:10:26 <LordBrain> its supported that for a long time...
16:10:47 <LordBrain> in vim mode
16:11:13 <SamB_XP> does it support applications?
16:11:15 <emu> how many people are using Yi, here, for serious coding now?
16:11:51 * SamB_XP is wondering if he could use it as a frontend for his Z-machine interpreter
16:11:55 <dons> emu, none that I know of.
16:12:03 <ray> i was going to say yes, but i misread Yi as Vi
16:12:04 <LordBrain> i hacked on it a while back, but i never considered it ready to use as my main editor
16:12:06 * allbery_b has it installed but still uses xemacs as his primary coding editor
16:12:22 <dons> its a good vim clone, imo. and useful for someone who really wants to write an editor :)
16:12:35 <dons> but i'd stick with vim or emacs
16:12:49 <sorear> is it usable as an emacs-clone?
16:13:00 <dons> as a minimal emacs, I beleive so, yes.
16:13:06 <dons> i.e. like the mg editor
16:13:16 <emu> is it integrated with a haskell compiler?
16:13:21 <emu> (as an IDE)
16:13:22 <dons> nope
16:13:34 * sorear just greatly reduced his typo rade by switching from emacs+vim to emacs+mg
16:13:37 <dons> its just a standalone editor like vi, written in haskell
16:13:43 <dons> so	oh?
16:13:53 <ray> sorear: couldn't have been by that much
16:13:56 <dons> sorear: how so?
16:13:56 <LordBrain> what's a typo rade?
16:14:01 <sorear> nothing like ^X^S to confuse vim...
16:14:02 <emu> lol
16:14:04 <LordBrain> :)
16:14:04 <sorear> typo rate
16:14:12 * emu marks down one on the rate
16:14:21 <emu> what's mg?
16:14:47 <sorear> one of the small emacs-like editors, notable only in having a Debian package.
16:14:59 <dons> mg is a micro emacs developed on the openbsd os, its bsd licensed
16:15:10 <Excedrin> emacs-like in terms of keybindings
16:15:14 <dons> notable in that its used as the pet project of the openbsd kernel hackers...
16:15:22 <sorear> so ^X^S doesn't confuse it :)
16:15:42 <emu> gosh, is it written and extensible in asm?
16:15:49 <int-e> does that include Theo?
16:16:00 <SamB_XP> emu: probably it is secure or something
16:17:43 <LordBrain> what is written and extensible in asm? mg?
16:18:59 <Excedrin> yi doesn't seem to react to key presses in some circumstances, if I type "itest<esc>0ifoo" I get "testfoo"
16:19:35 <sorear> Excedrin: you using a VT100 or emulation thereof?
16:19:48 <emu> hm while i'm sittin here, i had this weird function i concocted earlier, was wondering if anyone had seen anything of this kind:
16:20:00 <Excedrin> rxvt
16:20:01 <lisppaste2> emu pasted "a curious sorting function" at http://paste.lisp.org/display/32439
16:20:46 <LordBrain> Excedrin: pause a bit on the esc key
16:20:52 <emu> it's based on quicksort
16:21:20 <SamB_XP> emu: hmm.
16:21:22 <bd_> could that be more efficiently be done by performing a regular sort then finding permutations of equal elements?
16:21:39 <LordBrain> Excedrin: that might help... if it does, its actually due to the use of ncurses.. not especially yi's fault... vi does a work around.
16:22:10 <emu> maybe. i kinda wrote it on the fly
16:22:20 <SamB_XP> it must be a big fly
16:22:38 <LordBrain> there has to be a pause for the terminal to recognize esc is not the beginning of an escape sequence... ncurses just requires a pause that's a bit on the long side.
16:22:41 <emu> somehow it flies
16:22:55 <emu> i actually use it to lazily generate permutations of a sorted list
16:22:59 <Excedrin> how long is "a bit"?
16:23:04 <LordBrain> i forogt
16:23:06 <LordBrain> forgot
16:23:15 <LordBrain> pause a good second
16:23:43 <emu> the problem was that i had a set of things with (lower,upper) bounds and if items overlapped, they might occur in either order in the final choice
16:23:46 <LordBrain> i think in vi you can get by with a half second, which seems to be good enough that we dont notice.. but yi requires a full second.
16:24:02 <LordBrain> if i recall correctly
16:24:05 <sorear> Ncurses has a severe flickering problem...
16:24:17 <Excedrin> LordBrain: it doesn't seem to change the behavior, also, nvi doesn't have the issue
16:24:45 <LordBrain> nvi uses its own input function...
16:25:08 <LordBrain> nvi you have to pause for a half second or so
16:25:25 <Excedrin> if I press escape about 4 times, it seems like that gets it back into command mode
16:25:27 <LordBrain> same with vim i think, but i've never noticed it was even necessary until i used yi.
16:26:16 <LordBrain> it really makes me wonder why the esc key was chosen in the first place...
16:26:28 <emu> i usually hit C-[ in vim now
16:26:49 <LordBrain> that'll still require the pause to be correctly recognized tho
16:27:11 <emu> yea. maybe they figured ppl would take so much time after hitting ESC to reposition the hands, it wouldn't be noticed ?
16:27:25 <LordBrain> unless you're using the windows or dos version of vim.. or gtk
16:28:07 <LordBrain> emu... but if they used another key, they wouldnt have the pause problem at all
16:28:51 <Excedrin> I can load nv, go to insert mode, exit insert mode and exit the file in 0.957 seconds... it really doesn't feel like there's a 0.5 second delay after hitting esc
16:29:27 <dons> mmm. haskell.org's getting a memory upgrade? or already did?
16:29:29 <sorear> If you set vim's ttimeout to 0 ms, vi will have no pause at all
16:29:46 <dons> 1500 EST's come and gone, hasn't it.
16:29:58 <allbery_b> yep
16:30:02 <sorear> the arrow keys on linux-console / xterm still work, because the whole sequence arrives in one read(2).
16:30:05 <allbery_b> sopmeone noticed it down around 15:08
16:30:17 <LordBrain> Excedrin: yes, well it may be shorter then in nvi, my memory could be wrong, there has to be a delay of some sort tho, in any terminal which understands escape codes.
16:30:17 <allbery_b> s presumably it's done, one way or the other
16:30:22 <emu> oh this MonadNonDet looks cool
16:30:35 <dons> yep. looks like it. the load on the old servr was just getting too much these days
16:30:39 <sorear> it'll probably break on a real terminal, but they are a mostly-ignorable minority.
16:31:53 <dons> wow, ross really took this 99 questions thing on
16:32:24 <lightstep> ?hoogle Int -> Double
16:32:25 <lambdabot> No matches, try a more general search
16:32:32 <dons> fromIntegral
16:32:37 <Excedrin> "historically" occurs 136 times in nvi sources
16:32:39 <lightstep> thx
16:33:11 <SimonRC> LordBrain: IIRC the esc key used to be just left of the 1.
16:33:33 * SimonRC goes
16:33:38 <dons> > fromIntegral (1 :: Int) / (pi :: Double)
16:33:40 <lambdabot>  0.3183098861837907
16:34:20 <Excedrin> it looks like if ttimeout isn't set in vim, then it doesn't wait
16:35:33 <LordBrain> Excedrin: go to insert mode, press a bunch a characters, and then hit ESC, take note of the amount of time that passes before the cursor jumps back.
16:35:54 <emu> er, deriving Monad,MonadPlus,and Functor is glasgow-ext?
16:36:24 <Excedrin> in vim and nvi there's no noticable delay (my vim has no timeout or ttimeout by default)
16:36:25 <LordBrain> if it were any other key, that could be instantaneous....
16:36:47 <sorear> well, with a terminal emulator you don't need to wail
16:37:00 <sorear> s/wail/wait/
16:38:07 <LordBrain> i set ttimeout to off, and it still seems less than instantaneous to me.
16:38:45 <LordBrain> It's satisfactory tho
16:38:48 <Excedrin> I'm not sure what the difference is, but yi still waits infinity..
16:39:14 <LordBrain> yi waits longer yes
16:40:25 <hyrax42> dons: re your post, a nifty environment for haskell would do that for you, perhaps?
16:40:35 <dons> ah, the follow up to the silver bullet's article, http://programming.reddit.com/info/uu7k/comments
16:40:40 <dons> hyrax42: which post?
16:40:43 <LordBrain> thats because unlike vim and nvi, yi uses the ncurses input function.. getchar or getch or getc... I've forgotten the name now. The other editors by pass ncurses and do their own input handling, and have decided the length of time used by ncurses is longer than necessary...
16:41:03 <sorear> IMLE curses sucks, compared to termcap.  The abstraction level is so high you have to discard most of it, the keyboard interface has annoying warts, and there is a severe flicker problem (run nethack and angband side by side, and guess which one uses curses)
16:41:10 <dons> yep. don't use ncurses :)
16:41:14 <dons> but termcap is too low
16:41:21 <dons> so is curses in fact
16:41:38 <hyrax42> dons: "hacking haskell" and splicing inferred type signatures
16:41:40 <sorear> We/I should write an ultra-curses in haskell...
16:41:43 <dons> actually, don't use curses for editors. its plenty fine for other things
16:41:59 <dons> hyrax42: i suppose, yes, an environment could dod that :)
16:42:13 <hyrax42> though I like to write them before writing the function
16:42:21 <hyrax42> sort of a reminder of what the hell I'm trying to do
16:42:32 <sorear> I already have a limited curses-replacement library (rewritten in haskell for hsLife), I just need to add support for termcap and window resizing...
16:42:56 <hyrax42> sorear: as in, not a binding to ncurses?
16:43:58 <sorear> correct.
16:44:23 <sorear> actually it is a port of a C library I wrote when curses flickering made my roguelike unusable
16:44:35 <LordBrain> we could implement an interface like that old borland conio.h
16:44:59 <sorear> I know it was curses's fault because I didn't have to change any game logic, just replace the terminal interface, to fix the flickering
16:45:40 <LordBrain> sorear: did you print to the bottom right hand corner of the screen?
16:46:08 <sorear> no, I used curser motion commands
16:46:28 <LordBrain> hmm
16:46:30 <sorear> (are you talking about the lower-right-glitch? )
16:46:34 <LordBrain> yeah
16:46:43 <LordBrain> i think i am
16:46:45 <sorear> (my stats line wasn't that long
16:46:45 <LordBrain> :)
16:48:52 <sorear> http://members.cox.net/stefanor/hslife/UI/ANSI/Vty.hs
16:49:01 <LordBrain> i think conio was simpler to use than ncurses anyway...it assumes a dos-like keyboard buffer but compensating for that wouldnt be a problem in haskell..
16:49:21 <sorear> needs massive cleanup + support for resizing
16:49:33 <sorear> (is terminal independence still valuable?)
16:50:01 <sorear> you have any docs on the conio interface?  I never did DOS C programming.
16:50:20 <LordBrain> hmmm... i am sure its online somewhere
16:51:21 <LordBrain> looks like Digital Mars has a conio too
16:53:16 <LordBrain> conio didnt have anything fancy like windows.. but it had the essentials... something like key_waiting, readkey, gotoXY, putc
16:54:22 <LordBrain> ncurses suffers from being too huge
16:54:25 <LordBrain> hehe
16:54:39 <LordBrain> people care less and less tho... as our media grows
16:54:40 <sorear> Vty works at a higher level but it is still very simple
16:54:52 <sorear> 150 lines of C, I forget how much haskell
16:55:22 <sorear> ncurses is too big.  bigger than my brain big.
16:55:30 <LordBrain> yeah
16:55:44 <LordBrain> that makes it more difficult to learn too i think.
16:56:01 <dons> hehe. sign of the times, Paul Potts is dumped from Planet Scheme, and joins Planet Haskell the same day...
16:56:11 <dons> http://praisecurseandrecurse.blogspot.com/2006/12/revised-dot-matrix-printhead.html <-- this one
16:56:14 <lambdabot> Title: Praise, Curse, and Recurse: The Revised Dot-Matrix Printhead, http://tinyurl.com/ym7hpg
16:56:15 <sorear> Vty uses a not-very-CPU-friendly algorithm for update compression - probably a good thing...
16:56:36 <sorear> (not like processing 2000 chars can take long on a modern PC)
16:57:36 <SamB_XP> sorear: you can have much larger terminals than that
16:57:38 <SamB_XP> trust me
16:57:40 <SamB_XP> I have!
16:58:20 <sorear> my terminal is 128x48 (my monitor is sufficiently out of focus that it can't be usefully set higher)
16:58:38 <sorear> I use 2000 because 80x25 is currently hardcoded in vty :(
16:58:47 <SamB_XP> eeeeeeeek
16:58:49 <sorear> that is the *big* thing I need to fix
16:59:14 <SamB_XP> many of my terminals are 80x24
16:59:24 <SamB_XP> but some of them are a good deal bigger
16:59:39 <sorear> my only terminal is sisfb+fbcon :(
17:00:23 <sorear> btw, SamB: is the hsLife terminal emulator at all useful for the Z-machine?
17:01:00 <SamB_XP> sorear: I don't think so :-(
17:01:04 <LordBrain> dons: do you have a blog?
17:01:27 <SamB_XP> maybe I will steal code once you port to GTK
17:01:33 <SamB_XP> then again maybe not
17:01:43 <sorear> ?google multi-core STM now
17:01:46 <lambdabot> http://www.acmqueue.com/modules.php?name=Content&pa=showpage&pid=444&page=4
17:01:47 <lambdabot> Title: ACM Queue - Unlocking Concurrency - Multicore programming with transactional mem ...
17:01:54 <SamB_XP> personally, curses is looking more and more appealing
17:01:56 <dons> LordBrain: yeah, http://www.cse.unsw.edu.au/~dons/blog
17:01:57 <lambdabot> Title: Haskell hacking
17:02:37 <mwc> What's Zmachine? To me that's a giant pinch generator at Sandia
17:02:39 <sorear> yes... you know you are a successfull computer scientist when your blog is a publication of the ACM :)
17:02:55 <SamB_XP> hahahah
17:02:55 <dons> heh
17:02:57 <sorear> that's what I said :)
17:03:09 <SamB_XP> I don't want ACM to charge for *my* blog
17:03:15 <sorear> (^^^ to mwc)
17:03:17 <dons> oh sorry, my blog: http://www.cse.unsw.edu.au/~dons/papers.html
17:03:18 <lambdabot> Title: publications
17:03:20 <dons> :P
17:03:32 <dons> doesn't get updated much though
17:03:38 <mwc> http://www.getitconnected.net/zmachine.jpg I think this zmachine is way cooler
17:03:40 <dons> i should try some new blogging software
17:03:59 <SamB_XP> mwc: can you play Zork on it?
17:04:34 <SamB_XP> yeah, sure, it has nice looking arcs going everywhere, but...
17:05:10 <SamB_XP> (Though admittedly my Z-machine interpreter will only run the Solid Gold editions or whatever they are called...)
17:08:18 <sjanssen> @keal!
17:08:18 <lambdabot> and yes that was with zero formal training in all realms
17:08:31 <SamB_XP> ... and boy, doesn't it show?
17:08:49 <lightstep> how can i make ghc-pkg create a legal, empty package.conf file?
17:09:02 <sjanssen> @keal -- what do you have to say to SamB?
17:09:02 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
17:09:48 <sjanssen> T ... I've heard something about that language
17:09:56 <sjanssen> didn't it break the confines of visual basic?
17:10:07 <Trevion> @keal
17:10:08 <lambdabot> perhaps i just genius and never tested
17:10:55 <vincenz> @protontorpedo
17:10:56 <lambdabot> what echniques can be used to scael application in haskell?
17:11:04 <dons> lightstep: echo [] > foo.package.conf
17:11:11 <dons> ?users
17:11:12 <lambdabot> Maximum users seen in #haskell: 291, currently: 265 (91.1%), active: 40 (15.1%)
17:11:32 <lightstep> cool. it should probably create this if the file doesn't exist
17:14:24 <vincenz> @protontorpedo
17:14:24 <sjanssen> does Paul Potts hang out here?
17:14:25 <lambdabot> hey guys can haskeel be used to produce fast webapps?
17:14:49 <kfish> dons: does the 300th person to join #haskell get a special prize?
17:15:39 <sjanssen> lambdabot should be programmed to do something special when #300 shows up
17:15:55 <pbx> Wait, y0ur channel bot does comedy?
17:16:30 <mbishop> @palomer
17:16:31 <lambdabot> Hrmph, looks like I killed the channel
17:16:47 <vincenz> @keal
17:16:48 <lambdabot> the fractal is 5 irrationals
17:16:54 <mbishop> @quote
17:16:58 <lambdabot> ConorMcBride says: So, taking Void to be the colour of the empty bikeshed ...
17:17:03 <vincenz> @quote vincenz
17:17:04 <lambdabot>  Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
17:17:06 <sjanssen> lol
17:17:52 <vincenz> i
17:18:05 <sorear> I've finished genericserialize-0.0, and sent it off to haskell@
17:18:09 <vincenz> @quote sorear
17:18:12 <lambdabot>  Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease* in LOC, and
17:18:16 <lambdabot> helped man #haskell all at the same time. This'd take me a week in C, no doubt.
17:18:28 <vincenz> :D
17:18:43 <vincenz> sorear: what are you workin on
17:18:45 <sorear> I think the last term comprised much of the time :)
17:19:19 <dons> kfish: nice idea!
17:19:21 <sorear> last two hours: release-polishing genericserialize-0.0
17:19:27 <vincenz> sorear: in general
17:20:17 <sorear> mostly things that make me go "Oh wait, that actually sounds possible..."
17:20:29 <vincenz> :P
17:20:33 <vincenz> Does that pay?
17:21:04 <sorear> pay me? no.  but if computer programming didn't exist, I would pay to not be bored.
17:21:41 <sorear> (I'm a highschool student - not a particularly high income age bracket)
17:21:49 * vincenz nods
17:21:53 <vincenz> Aight
17:22:04 <vincenz> Anyways, me >>= fix sleep
17:22:34 <sjanssen> s/fix/mfix
17:22:39 <sorear> do you mean: sequence_ (repeat sleep) ?
17:23:05 <vincenz> nah, that'd be boring
17:23:07 <vincenz> officially it was
17:23:17 <sorear> :t sequence_ . repeat . (undefined :: a -> m a)
17:23:17 <vincenz> fix (>>= sleep >>= wake >>= work)
17:23:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m ()
17:23:33 <vincenz> :t fix (>>= sleep >>= wake >>= work)
17:23:34 <lambdabot>   The operator `>>=' [infixl 1] of a section
17:23:35 <lambdabot>     must have lower precedence than the operand `(>>=)' [infixl 1]
17:23:36 <sjanssen> vincenz: parse error
17:23:40 <vincenz> no slices
17:23:45 <vincenz> :t fix (\x x >>= sleep >>= wake >>= work)
17:23:47 <lambdabot> parse error on input `>>='
17:23:52 <sorear> ->\
17:23:54 <vincenz> :t fix (\x -> x >>= sleep >>= wake >>= work)
17:23:55 <lambdabot> Not in scope: `sleep'
17:23:56 <lambdabot>  
17:23:56 <lambdabot> <interactive>:1:27: Not in scope: `wake'
17:24:10 <vincenz> anyways, that should type just fine
17:24:19 <vincenz> even without infinite types ;)
17:24:23 <sorear> typed undefined makes a good value standin
17:24:52 <vincenz> :t fix (\x -> let a = undefined in x >>= a >>= a >>= a)
17:24:54 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
17:24:55 <vincenz> yay for monomorphism
17:25:39 <vincenz> monomorphic undefineds are great :D
17:26:10 <augustss> now and the MR is handy
17:26:19 <augustss> mostly, it's painful
17:26:25 <vincenz> yeah
17:26:45 <vincenz> but this was a pleasant surprise (well not surprise, I used let cause I knew it'd be MR, but mostly the surprise of finding a use for MR)
17:26:57 <sorear> when I want monomorphic, i usually do (\id -> doSomething (id thing) (id thing2)) id
17:26:57 <vincenz> :t fix (\x -> let a = undefined in x >>= a >>= a >>= undefined )
17:26:59 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
17:27:07 <vincenz> :t fix (\x -> let a = undefined in x >>= a >>= undefined >>= undefined )
17:27:09 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
17:27:10 <vincenz> hmm
17:27:15 <vincenz> seems unncessary *cough*
17:27:28 <sorear> :t fix (\x -> let a :: a ; a = undefined in x >>= a >>= a >>= undefined )
17:27:29 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
17:27:39 <chessguy> hey, i managed to reply to a poste on haskell-cafe without starting a new thread by accident
17:27:51 <vincenz> anywho, me the above fix
17:27:52 <sorear> hurray for sane mailers!
17:28:36 <chessguy> @type fix
17:28:38 <lambdabot> forall a. (a -> a) -> a
17:29:10 <chessguy> > fix (+2)
17:29:11 <lambdabot>  Exception: <<loop>>
17:29:44 <chessguy> > fix (*2)
17:29:45 <lambdabot>  Exception: <<loop>>
17:29:46 <sorear> Sorry, but haskell supports infinite types poorly.
17:29:59 <mwc> how is that an infinite type?
17:30:00 <dibblego> can a module export to only specified other modules?
17:30:08 <sorear> If we use Peano numbers in the [()] imbedding...
17:30:13 <chessguy> hmmm. fix must not mean what i think it means
17:30:16 <sorear> s/types/numbers/
17:30:22 <sorear> > fix (():)
17:30:23 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
17:30:28 <sorear> Infinity.
17:30:43 <chessguy> what does fix actually do?
17:30:43 <sorear> (():) is (1+) in peano-lists
17:30:47 <mwc> data List a = Empty : Cons a (List a) is an empty type to me
17:31:00 <mwc> chessguy, it feeds the function i's eventual output
17:31:07 <mwc> let fix f = let x = f x in x
17:31:11 <sorear> 1 is [()], 2 is [(),()], etc
17:31:23 <sorear> > fix ("fix! "++)
17:31:24 <lambdabot>  "fix! fix! fix! fix! fix! fix! fix! fix! fix! fix! fix! fix! fix! fix! fix! ...
17:31:38 <mwc> > fix (\fib -> 1 : 1 : zipWith (+) fib (tail fib)
17:31:38 <lambdabot>  Parse error
17:31:41 <mwc> > fix (\fib -> 1 : 1 : zipWith (+) fib (tail fib))
17:31:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:31:51 <sorear> > fix (ap (scanl (+)) tail . (1:))
17:31:52 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
17:31:52 <lambdabot>    Expected...
17:31:58 <sorear> > fix (ap tail (scanl (+)). (1:))
17:31:59 <lambdabot>  Couldn't match `a -> b' against `[a1]'
17:31:59 <chessguy> oh, so it t repeats the application of the function
17:32:04 <mwc> chessguy, not really
17:32:20 <int-e> > fix (scanl (+) 1) . (1:))
17:32:20 <lambdabot>  Parse error
17:32:23 <mwc> it's only makes sense with lazyness, it sort of "ties the knot" of a cycle of computation
17:32:27 <sorear> > 1 (`div` 2)
17:32:27 <int-e> > fix (scanl (+) 1 . (1:))
17:32:28 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a1))
17:32:28 <lambdabot>   In the definitio...
17:32:29 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
17:32:42 <sorear> > 1 `div` 2
17:32:43 <lambdabot>  0
17:32:48 <sorear> fix (`div` 2)
17:32:55 <sorear> > fix (`div` 2)
17:32:56 <lambdabot>  Exception: <<loop>>
17:32:59 <sorear> fix will error
17:33:11 <chessguy> why is it erroring
17:33:12 <int-e> > fix ((1:) . scanl (+) 1)
17:33:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:33:20 <sorear> if fix iterated, (`div` 2) is strongly convergent to 0
17:33:29 <sorear> but fix doesn't iterate
17:33:41 <chessguy> hmmmm. i don't get it.
17:33:50 <int-e> chessguy: fix finds the least fixed point, in a somewhat strange order where undefined is the smallest value
17:34:09 <int-e> chessguy: err. bottom. indeed what you get back is one of ghc's values for bottom.
17:34:17 <mwc> chessguy, take a look at my fibonacchi example.
17:34:18 <chessguy> the fixed point being the input that causes the output to be the same as the input, right?
17:34:25 <chessguy> i don't know scanl
17:34:31 <int-e> (bottom is a fixed point here because _|_ `div` 2 = _|_)
17:34:41 <lisppaste2> ptolomy pasted "k-nucleotide shootout entry using bytestring.. fast and simple." at http://paste.lisp.org/display/32453
17:34:51 <augustss> int-e: the order is not unnatural.  it's information contents
17:35:21 <int-e> augustss: I said strange. I was trying to avoid having to explain it ;)
17:35:36 <dons> sorear++ new serialisation library
17:35:41 <mwc> chessguy, the function \fib -> 1 : 1 : zipWith (+) fib (tail fib) produces a list right? so the first two elements are 1 and 1. The rest of the list is computed by adding the elements of some list to successive values. The one one kind of gets it started
17:35:42 <dons> ptolomy: cool!
17:35:47 <augustss> yeah, it's a little unusual
17:35:50 <dons> ptolomy: can you add it to the shootout wiki page?
17:36:04 <mwc> you can see how it works by this definition: let fix f = let x = f x in x
17:36:07 <dons> and submit it to the shootout guys, via their web interface?
17:36:15 <mwc> I'm pretty sure that has the full semantics of the haskell fix
17:36:19 <chessguy> mwc, i understand how fib works, but i don't get what fix has to do with it
17:36:27 <dons> ptolomy: also, you can leave out module Main (main) where
17:36:32 <mwc> look at the definition of my fix.
17:36:48 <int-e> chessguy: operationally, fix is an abstraction of recursion.
17:36:52 <chessguy> mwc, isn't that just what i said?
17:37:00 <ptolomy> dons: Hm, not right now. I am on my way out the door. When I get back I can try to remember my wiki login..
17:37:00 <chessguy> [20:28] <chessguy> the fixed point being the input that causes the output to be the same as the input, right?
17:37:01 <mwc> takes a function, then it defines a value x that it gets by applying f to that value.
17:37:07 <ptolomy> dons: Main where no longer needed?
17:37:16 <mwc> chessguy, right
17:37:20 <int-e> chessguy: well, the input often isn't unique
17:37:24 * ptolomy thought that it allowed GHC to make optimization assumptions.
17:37:32 <int-e> chessguy: where it is unique, it does that.
17:37:33 <dons> its not needed for the main module
17:37:40 <ptolomy> Ah.
17:37:41 <ptolomy> makes sense.
17:37:44 <chessguy> ok, i think i understand
17:37:54 <dons> (controlling the export list is a good idea for library code though)
17:37:54 <sjanssen> ptolomy: are the ByteStrings printed in showFun very long?
17:37:59 <chessguy> so why don't i get a fixed point of 0 when i do fix (*2)
17:38:07 <int-e> chessguy: (1:) has only one fixed point. (`div` 2) has two, 0 and bottom.
17:38:12 <sorear> fix isn't smart enough
17:38:22 <mwc> chessguy,  I'm trying to clarify that it's not like we're evaluating an input that happens to produce identical output. It's more like we're tying a knot so that we have a function that operates on its own output
17:38:27 <Pseudonym> fix gives you the least fixed point.
17:38:32 <Pseudonym> That's least in a domain-theoretic sense.
17:38:59 <sorear> fix f = let x = f x in x
17:39:15 <sorear> fix (*2) = let x = x * 2 in x
17:39:18 <sjanssen> ptolomy: consider "showFun (k, f) = do B.putStr k; printf " %.3f\n" f", perhaps?
17:39:33 <chessguy> sorear, so doesn't 0 satisfy that?
17:39:38 <sorear> fix (*2) = let x = <BLACKHOLE> in x * 2
17:39:40 <int-e> chessguy: bottom does, too.
17:39:44 <sorear> fix (*2) = let x = <BLACKHOLE> in <BLACKHOLE>
17:39:46 <int-e> chessguy: so bottom is what you get
17:39:49 <sorear> fix (*2) = <BLACKHOLE>
17:39:55 <chessguy> int-e, no, it didn't give bottom
17:40:00 <augustss> chessguy: yes, 0 satisfies that.  but it's not the smallest thing that does
17:40:00 <chessguy> > fix (*2)
17:40:02 <lambdabot>  Exception: <<loop>>
17:40:02 <int-e> chessguy: yes it did.
17:40:10 <chessguy> that's bottom?
17:40:11 <sorear> by contrast: fix (1:) = let x = 1 : x in x
17:40:19 <sorear> fix (1:) = let x = 1 : x in x
17:40:30 <allbery_b> one form of it, yes
17:40:34 <sorear> fix (1:) = let x = BLACKHOLE in 1 : x
17:40:48 <sorear> (done because of laziness, so blackhole ends
17:41:09 <augustss> bottom can look different when view from the outside of the language
17:41:10 <chessguy> i guess i don't see the usefulness of it
17:41:22 <sorear> fix (1:) = (object 0 -> 1 : (object 0)) , a circular data structure
17:41:31 <ptolomy> sjanssen: Trying now.
17:41:56 <dons> ?users
17:41:56 <lambdabot> Maximum users seen in #haskell: 291, currently: 263 (90.4%), active: 41 (15.6%)
17:41:57 <ptolomy> sjanssen: Cleaner, but a wee bit slower.
17:42:04 <augustss> chessguy: fix has no real use in Haskell since Haskell already has recursion built in
17:42:10 <int-e> chessguy: fix encodes recursion. it does not solve equations.
17:42:27 <sjanssen> ptolomy: really?  it should be faster
17:42:31 <chessguy> oh, ok. so it's not something i'd use
17:42:33 <int-e> chessguy: and it can always be replaced by a recursive let binding.
17:42:41 <chessguy> ok
17:42:42 <sjanssen> ptolomy: unless the ByteStrings tend to be smallish
17:42:47 <int-e> chessguy: but that doesn't make it useless ;)
17:42:59 <augustss> chessguy: no, I've hardly ever used fix
17:43:03 <chessguy> but it's not needed
17:43:19 <int-e> chessguy: the same can be said for repeat, foldl, foldr, map, mapM, etc.
17:43:44 <ptolomy> sjanssen: Quite small.
17:43:54 <mutjida> :t fix
17:43:55 <lambdabot> forall a. (a -> a) -> a
17:43:56 <chessguy> ok, but each of those can simplify code greatly. what's a situation in which fix would simplify code?
17:44:00 <sjanssen> oh, nevermind then ;)
17:44:46 <int-e> chessguy: ok, take  id  then.  you could always write \x -> x  instead
17:45:30 <chessguy> int-e, i don't see your point
17:45:31 <augustss> chessguy: but on the whole you are right.  there are very few occasions when fix simplifies the code
17:45:42 <sorear> repeat = fix . (:)
17:45:43 <ptolomy> dons:  WIki page is updated.
17:46:00 <int-e> chessguy: using fix is on the same level of simplification as that. (at least in my view)
17:46:16 <int-e> chessguy: and indeed, I don't use id very often either.
17:46:17 <chessguy> ok
17:46:24 <sorear> ?pl (\x -> let l = x : l in l)
17:46:25 <lambdabot> fix . (:)
17:46:38 * sorear is suprised lambdabot could handle let
17:47:15 <int-e> you can desugar let into calls of fix :)
17:47:30 <sorear> ?pl (let repeat x = x : repeat x in repeat)
17:47:31 <lambdabot> fix (ap (:))
17:47:51 <sorear> that's vaguely interesting
17:47:57 <sorear> :t ap (:)
17:47:58 <lambdabot> forall a. (a -> [a]) -> a -> [a]
17:48:07 <int-e> (recursive) let a=xxx; b=yyy ---> (non-recursive) let (a, b) = fix (\(a, b) -> (xxx, yyy))
17:49:05 <mutjida> fix can let you pass nameless recursive functions
17:49:57 <int-e> So if you provide  fix  as a primitive, you don't need to implement recursive lets. At least from a theoretical point of view that's very interesting.
17:50:47 <dons> ptolomy++ thanks
17:50:51 <chessguy> dons, seen the 99-problems page lately?
17:50:57 <dons> yeah... :)
17:51:00 <dons> kinda almost done, no?
17:51:08 <chessguy> ~75/99
17:51:54 <mutjida> anyone here know about the details of typeclass constraint simplification?
17:51:59 <dons> very nice
17:52:28 <chessguy> i'd say the gauntlet has been thrown down to the lisp community
17:53:01 <mwc> chessguy, how so?
17:53:08 <dons> I think so.
17:53:12 <dons> http://haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
17:53:13 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
17:53:29 <chessguy> they only have like 25 solutions
17:53:58 <mwc> Wow, when did that happen?
17:54:11 <chessguy> went up on haskell-cafe last week
17:54:16 <dons> yesterday :)
17:54:39 <chessguy> i don't remember what day it went up. whatever day i was up until like 4 in the morning :)
17:58:13 <dons> it was on tuesday, just before the HWN came out
17:58:16 <dons> so 3 days ago
17:58:27 <chessguy> this week?
17:58:38 <chessguy> man, this has been a long week
17:58:54 <Excedrin> I'd like to try jhc, but make libs fails with mModule not found : System.IO.Error ~~.
17:58:57 <Excedrin> ~.
17:59:18 <jcreigh> @pl map (\x -> (length x, head x)) . group
17:59:19 <lambdabot> map (liftM2 (,) length head) . group
17:59:21 <dons> a week in haskell is a long time
17:59:47 <Excedrin> ack, ignore those ~.
17:59:50 <chessguy> right now, a week in my life is a long time :)
18:05:31 <mutjida> ?users
18:05:32 <lambdabot> Maximum users seen in #haskell: 291, currently: 260 (89.3%), active: 41 (15.8%)
18:11:01 <mutjida> ?users
18:11:02 <lambdabot> Maximum users seen in #haskell: 291, currently: 258 (88.7%), active: 40 (15.5%)
18:11:42 <jcreigh> we could get this over with right now if 9 of us opened another instance of our respective IRC clients. :)
18:11:58 <jcreigh> oh, wait, current is 258
18:12:12 <jcreigh> so another 42.
18:12:23 <jcreigh> still, there's 40 active, so no big deal. :)
18:18:52 <mutjida> hello. anybody here know a lot about type classes?
18:20:05 <SamB_XP> whats to know?
18:20:32 <mutjida> i'm trying to understand how constraints get solved.
18:21:34 <dons> mutjida: the best way to find out would be via the research papers on the topic
18:21:51 <dons> here, http://haskell.org/haskellwiki/Research_papers/Type_systems#Type_classes
18:21:53 <lambdabot> Title: Research papers/Type systems - HaskellWiki, http://tinyurl.com/yan24w
18:21:55 <mutjida> the research papers don't address my question.
18:22:15 <dons> one of them must describe the constraint resolution process, surely?
18:22:16 <mutjida> i'm trying to figure out what happens when a constraint gets duplicated.
18:22:27 <dons> ah ok.
18:22:33 <mutjida> really, none of them (that i've seen) cover this.
18:23:08 <dons> you might want to provide an example of code that behaves this way, and then ask someone like simon peyton jones, or ross paterson, what happens
18:23:11 <mutjida> specifically, when a constraint with an uninstantiated type variable gets duplicated..
18:23:23 <dons> yes, I saw this question. on the mailing list
18:23:34 <mutjida> no one replied... so i thought i'd poke around here.
18:23:43 <mutjida> do you have any idea?
18:24:09 <dons> but without a code example, i found it difficult to follow. I think you might have better luck asking on glasgow-haskell-users@haskell.org, CC'ing SPJ, and providing a fragment of code that illustrates the problem
18:25:11 <mutjida> consider: (\x -> (f TC1 x, f TC2 x)) where f has a constraint involving the types of both arguments.
18:25:38 <mutjida> TC is a type constructor.. could just be an empty data declaration.
18:26:11 <mutjida> i guess i'll try the glasgow list...
18:26:57 <dons> and provide more information about what you think is happening, and what should happpen and so on. the more info you provide , the more likely someone will understand what you're trying to find out :)
18:27:27 <SamB_XP> do you know type logics?
18:28:14 <mutjida> what do you mean type logics?
18:28:56 <dons> I guess SamB means the type theory behind Haskell's type system
18:29:02 <SamB_XP> the notation they always use in papers to talk about type inference
18:29:02 <mutjida> yes
18:29:03 <dons> such as used in the papers that describe the type class  system
18:29:14 <SamB_XP> and about types period
18:29:34 <SamB_XP> *all* type-system-extension papers seem to use it
18:29:51 <mutjida> i'm comfortable with haskell's type system.
18:30:02 <SamB_XP> this isn't about the type system itself
18:30:25 <SamB_XP> this is about the formal notation used to talk *about* the type system
18:30:31 <dons> mutjida: I think the reason you didn't get a response was that the question was a bit unclear
18:30:37 <SamB_XP> I myself do not understand the notation
18:30:37 <dons> SamB_XP: I think he gets it.
18:31:10 <SamB_XP> but I can only assume that what you are wondering about is answered by one of those cryptic things with bars
18:31:34 <mutjida> it's more about the implementation of the constraint solver.
18:31:46 <dons> mutjida: so I suggest:   "I'm trying to understand X. here's some code that should have type T, but it has type Q instead. According to Z this should be the inference steps involved ....  What's going on ? "
18:32:48 <dons> mutjida: but the solver implementation is really described in the various papers.
18:32:55 <dons> let me find you some specifics...
18:34:49 <dons> http://www.cse.ogi.edu/~mpj/pubs/pldi93.html, "Implementing Type Classes"
18:34:51 <lambdabot> Title: Redirect: Web resource has moved
18:35:01 <dons> http://www.cs.chalmers.se/pub/cs-reports/papers/overload-fpca-93.ps.Z " Implementing Haskell overloading"
18:35:03 <lambdabot> http://tinyurl.com/ts2wt
18:35:37 <dons> http://www.comp.nus.edu.sg/~sulzmann/publications/ghc-mptc-inf.ps, "Type Inference for Multi-Parameter Type Classes"
18:35:53 <dons> for example. that's the best way to find out what's going on inside.
18:35:57 <dons> all at, http://haskell.org/haskellwiki/Research_papers/Type_systems#Type_classes
18:35:59 <lambdabot> Title: Research papers/Type systems - HaskellWiki, http://tinyurl.com/yan24w
18:37:43 <jcreigh> hey, do-notation works in ghci!
18:38:00 <mutjida> thanks for the pointers. i had mostly focussed on papers describing applications of type classes
18:38:48 <dylan> dons: do you use blosxom?
18:39:02 <dylan> (or does anyone else use blosxom + darcs?)
18:39:56 <chessguy> what in the world
18:40:06 * chessguy just ran across a funny wiki page
18:40:11 <SamB_XP> @wtf blosxom
18:40:11 <lambdabot> Maybe you meant: bf ft wn
18:40:12 <chessguy> http://www.haskell.org/haskellwiki/Code_for_Bob
18:40:14 <lambdabot> Title: Code for Bob - HaskellWiki
18:40:52 <kfish> dylan, i use pyblosxom and i used to bother using it with bzr ... what's the issue?
18:41:10 <dylan> kfish: I'm wondering if it's a good idea to keep generated files in darcs.
18:41:51 <dylan> (the obvious advantage being darcs push == simple way of uploading the journal)
18:42:03 <kfish> right
18:42:07 <dylan> I seem to remember dons keeps all sorts of weird things in darcs, like log files, etc.
18:42:20 <kfish> i guess the other option is to have a post-commit hook that regenerates the files
18:42:28 <kfish> or a cronjob
18:42:28 <dylan> Yup.
18:42:46 <dylan> post-commit hook would be fairly easy.
18:43:56 <dylan> [I'm not actually using blosxom, but something similar. but it's not relevant -- only darcs usage and rationality of keeping generated files under version control is]
18:45:43 <dons> dylan: yeah, I use blosxom + darcs
18:45:56 <dons> blosxom runs on the server. i write in a darcs repo, and darcs push to publish
18:46:16 <dons> and yeah, i've got log files, my home, dir, my blog , all in darcs :}
18:46:29 <jcreigh> log files?
18:46:30 <jcreigh> why?
18:46:32 <chessguy> > map toUpper "hello"
18:46:34 <lambdabot>  "HELLO"
18:46:38 <dylan> I *sort* of have my home in darcs.
18:46:52 <chessguy> > head "hello"
18:46:53 <jcreigh> > map (chr . (+1) . ord) "hello"
18:46:54 <lambdabot>  'h'
18:46:55 <lambdabot>  "ifmmp"
18:47:12 <dons> hmm. should I bother writing a response to the (kind of OT discussion) that ended up on reddit, about the 'on syntax'article?
18:47:34 <jcreigh> ^^ that's the encryption algorithm used for passwords and credit card information in an e-commerce system we use my job, BTW.
18:48:03 <dons> the article was really about what syntax should look like, in a dream world. but of course, the reddit crowd read it as an attack on lisp :/
18:48:15 <dons> ah well
18:48:38 <Excedrin> dons: I told you that people would focus on your choices of example code...
18:48:59 <dons> yeah . you were 100% right Excedrin
18:49:15 <chessguy> @type getContents
18:49:16 <lambdabot> IO String
18:49:54 <jcreigh> I think most schemers would probably shave off one line with "(define (fibo x) ...)" (unless they're in "look, everything's a lambda! Lisp is so cool!" example-code mode.)
18:49:58 <jcreigh> ...but still.
18:51:33 <SamB_XP> dons: just mod it all down
18:51:48 <SamB_XP> including your contributions
18:53:18 <sorear> > a >>= b . c >> d
18:53:19 <lambdabot>  Not in scope: `d'
18:53:38 <LordBrain> hmmm dons, where can i see the reddit crowd's reaction?
18:53:58 <dons> unfortunately, blosxom is partially to blame it combined my other articles that day (on haskell), into a single long page
18:54:11 <dons> so that the non-language specific plea for better syntax, ended up reading like a haskell advocacy argument.
18:54:19 <dons> http://programming.reddit.com/info/uqo3/comments?opt_cstyle=nested
18:54:21 <lambdabot> http://tinyurl.com/u2rp4
18:55:25 <chessguy> newsham, around?
18:55:32 <Excedrin> it still made #2
18:55:41 <Excedrin> and some of the comments were interesting
18:55:42 <dons> however, outside of reddit the main point seems to have made it. over on digg, a guy linked to it with a title about "programming language should look like pseudocode", and this guys really got it, http://nominolo.blogspot.com/2006/12/syntax.html
18:55:43 <lambdabot> Title: nominolo's Blog: Syntax
18:56:26 <dons> Excedrin, however the main point: the syntax of the future should be simpler, didn't really get a run on reddit.
18:56:32 <jcreigh> right, because pseudocode is what we use to explain ideas to other people, which is what programming should be about.
18:56:47 <dons> at least, not in the comments
18:57:13 <dons> the commenters spend a lot of time describing the a) inefficiencies of the implementations b) you can do it in lisp with macros
18:57:24 <dons> but none the less people kept voting up the main article. hmm.
18:57:37 <chessguy> @type const
18:57:39 <lambdabot> forall a b. a -> b -> a
18:57:55 <Excedrin> what's the difference between minimal syntax and simpler syntax?
18:58:44 <dons> my argument is for avoiding clutter that only serves to help the machine, not the human
18:59:04 <Excedrin> so maybe something like Lojban is ideal syntax? :)
18:59:19 <dons> so keywords, like "define", missing infix operators, { ; } , and types/sigils, only exist to make parsers simpler
18:59:34 <dons> anything you ditch when writing pseudocode shoudl be ditched from the language itself
18:59:38 <chessguy> > const 3 5
18:59:39 <lambdabot>  3
18:59:57 <emu> dons: nominolo hangs out here
19:00:06 <dons> emu, yeah I know :)
19:00:45 <chessguy> what exactly does const do?
19:00:50 <emu> \_ -> ...
19:01:06 <chessguy> so it's just a constant function?
19:02:12 <dylan> it returns a constant function when passed one argument.
19:02:13 <int-e> chessguy: yes. hence the name.
19:02:22 <emu> constantly in CL
19:02:56 <chessguy> hmm
19:05:20 <chessguy> @seen newsham
19:05:20 <lambdabot> newsham is in #haskell-blah and #haskell. I last heard newsham speak 1h 12m 24s ago.
19:05:33 <ray> > 3 5
19:05:33 <lambdabot>  add an instance declaration for (Num (t -> a))
19:05:34 <lambdabot>   In the definition of `nr...
19:05:46 <ray> fascinating
19:15:39 <sorear> > inits "haskell"
19:15:41 <lambdabot>  ["","h","ha","has","hask","haske","haskel","haskell"]
19:16:09 <sorear> > init $ inits "haskell"
19:16:11 <lambdabot>  ["","h","ha","has","hask","haske","haskel"]
19:19:06 <SamB_XP> how... inefficient!
19:20:34 <LordBrain> hmm, i fell in love with haskell syntax upon first sight.
19:20:55 <syntaxfree> what is init?
19:21:15 <LordBrain> @hoogle init
19:21:16 <lambdabot> Prelude.init :: [a] -> [a]
19:21:16 <lambdabot> List.inits :: [a] -> [[a]]
19:21:16 <lambdabot> System.Console.Readline.initialize :: IO ()
19:21:19 <SamB_XP> I had a bit of trouble with "data" declarations
19:21:21 <int-e> init drops the last element of a list.
19:21:49 <int-e> so it's a counterpart to tail (but less efficient)
19:21:57 <chessguy> wow, someone took on and defeated some of the really tough ninety-nine problems
19:22:00 <syntaxfree> init = reverse . tail . reverse ?
19:22:06 * sorear is currently writing a parser for VT-100 / ANSI keyboard escape sequences
19:22:07 <sorear> yes.
19:22:25 <int-e> > init $ repeat ()
19:22:26 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
19:22:32 <int-e> not quite :)
19:22:38 <SamB_XP> sorear: again?
19:22:57 <SamB_XP> oh, keyboard you say.
19:23:02 <int-e> > reverse . tail . reverse $ repeat ()
19:23:06 <lambdabot> Terminated
19:23:31 <syntaxfree> ?
19:23:38 <syntaxfree> what's the proper recursive definition of init, then?
19:23:41 <sorear> more of rewriting, the old one was just too evil
19:23:49 <sorear> oh that is correct
19:23:54 <int-e> syntaxfree: init [] = error; init [x] = []; init (x:xs) = x:init xs
19:23:56 <syntaxfree> ohhh. trivial.
19:23:56 <syntaxfree> nevermind.
19:24:02 <LordBrain> what are the ninety-nine problems?
19:24:06 <sorear> your defn works for all finite lists
19:24:27 <sorear> reverse . tail . reverse $ "Hello"
19:24:30 <sorear> > reverse . tail . reverse $ "Hello"
19:24:31 <lambdabot>  "Hell"
19:24:40 <SamB_XP> > init []
19:24:41 <lambdabot>  Add a type signature
19:24:46 <syntaxfree> except the definition with two reverses is a lot more expensive than a simple recursive one.
19:24:47 <SamB_XP> > init [] :: String
19:24:48 <lambdabot>  Exception: Prelude.init: empty list
19:25:04 <SamB_XP> int-e: your code
19:25:08 <SamB_XP> it doesn't typecheck!
19:25:19 <int-e> SamB_XP: I left out the error message from error
19:25:33 <int-e> I probably should have used  undefined  instead.
19:26:12 <SamB_XP> mmm
19:26:14 <int-e> but anyway it was meant as pseudocode really, even if it looked like Haskell ;)
19:26:17 <SamB_XP> yes, I noticed that
19:26:30 <SamB_XP> I didn't actually run your code through a compiler or anything ;-P
19:26:44 <SamB_XP> or, well, I noticed that you omitted the error message
19:29:38 <chessguy> @type $!
19:29:39 <lambdabot> parse error on input `$!'
19:30:03 <sorear> what's the idiom for this:
19:30:04 <int-e> > ["substr"] >>= tail . inits >>= init . tails
19:30:05 <lambdabot>  ["s","su","u","sub","ub","b","subs","ubs","bs","s","subst","ubst","bst","st"...
19:30:35 <SamB_XP> neato
19:30:36 <sorear> liftM2 map (flip splitAt) length "Haskell"
19:30:49 <SamB_XP> integral: how do you do subsets?
19:30:51 <SamB_XP> er.
19:30:53 <SamB_XP> int-e:
19:30:54 <SamB_XP> sorry
19:30:58 <sorear> > liftM2 map (flip splitAt) length "Haskell"
19:30:59 <lambdabot>  Couldn't match `[Int]' against `Int'
19:31:13 <chessguy> found this code on the wiki:
19:31:15 <chessguy> f 0 = return []
19:31:15 <chessguy> f n = do v  <- getLine
19:31:15 <chessguy>          vs <- f (n-1)
19:31:15 <chessguy>          return $! v : vs
19:31:25 <sorear> > liftM2 map (flip splitAt) (enumFromTo 0 . length) "Haskell"
19:31:25 <chessguy> what's the $! in the return?
19:31:27 <lambdabot>  [("","Haskell"),("H","askell"),("Ha","skell"),("Has","kell"),("Hask","ell"),...
19:31:33 <sorear> > liftM2 map (flip splitAt) (enumFromTo 0 . length) "abc"
19:31:34 <lambdabot>  [("","abc"),("a","bc"),("ab","c"),("abc","")]
19:31:37 <SamB_XP> chessguy: strict application
19:31:51 <chessguy> strict how?
19:32:17 <sorear> is there an idiom for find-all-"dedekind-cuts"?
19:33:29 <int-e> > foldM (\xs x -> [xs, x:xs]) [] [1,2,3]
19:33:30 <lambdabot>  [[],[3],[2],[3,2],[1],[3,1],[2,1],[3,2,1]]
19:33:39 <glguy__> chessguy: it means (in this case) actually perform the (:) operation to each thunk (v and vs) before calling return
19:33:49 <int-e> SamB_XP: probably something like this (add an reverse to make it prettier)
19:33:58 <glguy__> > filterM (const [False,True]) [1,2,3]
19:34:00 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
19:34:22 <int-e> glguy__: interesting
19:34:30 <SamB_XP> > filterM (const [False,True]) [1..]
19:34:32 <lambdabot>  Exception: stack overflow
19:34:41 <SamB_XP> > foldM (\xs x -> [xs, x:xs]) [] [1..]
19:34:46 <lambdabot> Terminated
19:34:52 <SamB_XP> oooh
19:35:39 * SamB_XP bets there is a version that works on [1..]
19:36:16 <int-e> > let subsets xs = [x:xs'' | (x:xs') <- tails xs, xs'' <- subsets xs'] in subsets [1..3]
19:36:17 <lambdabot>  []
19:36:32 <int-e> oops.
19:36:36 <glguy_> you need a [] : or something
19:36:45 <sorear> foo = const $ concatMap (\x -> map ((,) x) [1..x]) [1..]
19:37:13 <sorear> foo = const $ map (uncurry enumFromTo) concatMap (\x -> map ((,) x) [1..x]) [1..]
19:37:22 <sorear> that should work on [1..]
19:37:30 <glguy_> > let f xs = [] : [x:xs'' | (x:xs') <- tails xs, xs'' <- f xs'] in f [1..3]
19:37:32 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
19:37:38 <glguy_> > let f xs = [] : [x:xs'' | (x:xs') <- tails xs, xs'' <- f xs'] in f [1..]
19:37:39 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
19:38:02 <int-e> hehe. at least it returns *something*
19:38:21 <SamB_XP> well, for infinite lists it is the same as inits ;-)
19:38:28 <SamB_XP> but that is something at least
19:39:01 <SamB_XP> hmm...
19:39:04 <sorear> use oleg's uberlistmonad
19:39:09 <SamB_XP> ah.
19:39:11 <SamB_XP> I know.
19:39:16 <int-e> > scanl (flip (:)) [] [1..] >>= foldM (\xs x -> [xs, x:xs]) []
19:39:18 <lambdabot>  [[],[],[1],[],[1],[2],[1,2],[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[],[1],...
19:39:32 <SamB_XP> start with inits...
19:39:36 <int-e> well, getting closer.
19:40:09 <SamB_XP> > scanl (flip (:)) [] [1..]
19:40:11 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[8...
19:40:23 <SamB_XP> thats just map reverse . inits!
19:40:31 <glguy_> > let f xs = [] : [x:xs'' | (x:xs') <- inits xs, xs'' <- f xs'] in f [1..3]
19:40:34 <glguy_> > let f xs = [] : [x:xs'' | (x:xs') <- inits xs, xs'' <- f xs'] in f [1..]
19:40:34 <lambdabot>  [[],[1],[1],[1,2],[1],[1,2],[1,2],[1,2,3]]
19:40:37 <lambdabot>  [[],[1],[1],[1,2],[1],[1,2],[1,2],[1,2,3],[1],[1,2],[1,2],[1,2,3],[1,2],[1,2...
19:40:46 <SamB_XP> not quite
19:41:05 <glguy_> you don't get a new first element with inits (forgot)
19:42:06 <glguy_> oh!
19:42:27 <int-e> > [] : (tail (scanl (flip (:)) [] [1..]) >>= \(x:xs) -> foldM (\xs x -> [xs, x:xs]) [x] xs)
19:42:28 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3...
19:42:44 <glguy_> > let f xs = [] : [x:xs'' | y <- tail (tails xs), let x = last y, let xs' = init y, xs'' <- f xs'] in f [1..3]
19:42:45 <SamB_XP> oooh
19:42:45 <lambdabot>  Exception: Prelude.last: empty list
19:42:53 <SamB_XP> that looks right to me
19:43:05 <SamB_XP> I mean, int-e's does
19:43:20 <glguy_> > let f xs = [] : [x:xs'' | y@(_:_) <- tail (tails xs), let x = last y, let xs' = init y, xs'' <- f xs'] in f [1..3]
19:43:22 <lambdabot>  [[],[3],[3]]
19:43:42 <SamB_XP> > [] : (tail (scanl (flip (:)) [] [1..3]) >>= \(x:xs) -> foldM (\xs x -> [xs, x:xs]) [x] xs)
19:43:44 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
19:43:46 <int-e> scanl (flip (:)) []   is a function I'd like to have in Data.List - it's  inits, but with the result lists reversed. It's O(n) instead of O(n^2).
19:44:32 <SamB_XP> and I guess map reverse . inits is... O(n^2) too?
19:44:36 <int-e> yes.
19:45:00 <SamB_XP> at first I was thinking it would be O(n^3) ;-)
19:48:42 <Cale> grr, all these blogger blogs which I can't post comments on at all, because the post-a-comment page reloads once every second.
19:49:26 <glguy_> why would they do that?
19:49:42 <int-e> they only want comments from spam bots.
19:49:48 <int-e> probably ;)
19:50:18 <goltrpoat> that, and the authors can't handle more than 30 second latency between comment posts
19:50:43 <goltrpoat> otherwise they have to refresh the page over and over and over and over.
19:50:55 <glguy_> I saw a neat idea for an anti general spam bot system where there are extra form fields that are hidden with CSS. if you put text in those fields, the program assumes you are a bot
19:52:12 <glguy_> that would obviously only be effective on the small scale
19:54:35 <dibblego> can I have a data type that is the same as another data type, except one less parameter to its only constructor, be used as if it were the other type?
19:56:42 <sorear> you mean like:
19:56:51 <sorear> data Foo = Foo Int Int Double
19:57:10 <glguy_> anyone have a unicode < on-hand?
19:57:31 <int-e> what's wrong with < ?
19:57:36 <glguy_> reddit sucks
19:57:36 <shobadobs> here: <
19:58:12 <shobadobs> I remember somebody mentioning indenting four spaces for code
19:58:20 <glguy_> that doesn't fix the < bug
19:58:23 <sorear> > fromEnum '<'
19:58:23 <shobadobs> ok
19:58:25 <lambdabot>  60
19:58:38 <sorear> 60 is a unicode <
19:59:35 <int-e> ≤ ≮ ;-)
19:59:55 <jcreigh> rats, I didn't quite figure out Golomb's proof on my own. (Rubyquiz #33)
19:59:57 <int-e> actually ≺ might look fine. ≻
20:00:11 <shobadobs> somebody used those on reddit recently
20:00:25 <glguy_> int-e: ≺ worked great, thanks
20:00:36 <glguy_> what's the <- unicode arrow?
20:00:43 <int-e> ←
20:00:52 <int-e> ⇐
20:00:57 <glguy_> how do you get that so fast??
20:01:07 <int-e> scim + latex table.
20:01:16 <glguy_> ah
20:02:13 <int-e> and gucharmap when I don't know what I'm looking for. (I did that for ≺ and ≻)
20:02:54 <glguy_> ←☚➳➜➠➟
20:03:05 <glguy_> arrows for everyone!
20:03:16 <glguy_> ↭
20:03:19 <int-e> they have a complete chess set in unicode :/
20:04:13 <geckosenator> cool
20:04:19 <geckosenator> so we can have chess on the console
20:04:30 <glguy_> Your console supports unicode?
20:04:33 <goltrpoat> speaking of blogs, can anyone think of an entry-sized interesting problem i can talk about?  i'm working on a polymorphic kohonen map implementation in haskell for the next one, and i guess my AD thing went over relatively well
20:04:36 <geckosenator> glguy_: no
20:04:47 <geckosenator> well it might, it isn't turned on
20:04:47 <dibblego> sorear, I think I'm just going to write a conversion function
20:04:54 <int-e> my xterm does.
20:04:55 <goltrpoat> ooh.  maybe a minimal chess engine.
20:05:02 <glguy_> My xterm does
20:05:04 <glguy_> but my console doesn't
20:05:10 <geckosenator> doesn't unicode have support for every pixel combination in the character? so you can actually do graphics?
20:05:14 <dibblego> is there a Chess.hs somewhere?
20:05:16 <goltrpoat> wonder how small i could make that, with no optimizations.
20:05:24 <geckosenator> glguy_: I think my console can do it, but it isn't in that mode
20:05:32 <chessguy> hmmm?
20:05:34 <glguy_> uxterm ftw
20:05:47 <dibblego> I'd imagine many people have written chess in haskell
20:05:52 <Cale> Hehe, I just recommended a language other than Haskell to someone. Of course, it was obvious that they already knew Haskell, since they were implementing the Maybe type in Java.
20:05:58 <geckosenator> an ai engine for chess?
20:06:05 <glguy_> "it would be fun" ⧺ "to use stuff like this in code"
20:06:06 <goltrpoat> dibblego:  i remember looking for implementations a while back.. i came across exactly one
20:06:14 <goltrpoat> and it was very much a trivial proof of concept type deal
20:06:20 <dibblego> Cale, how were they doing it exactly?
20:06:21 <Cale> (http://programming.reddit.com/info/uusl/comments)
20:06:36 <goltrpoat> chess programming is difficult in haskell due to the amount of low-level optimizations that are typically required
20:06:44 <dibblego> good ol' Ricky
20:06:48 <dibblego> him and I debate all the time
20:06:52 <goltrpoat> or rather.. competitive chess programming
20:06:56 <Cale> dibblego: Visitor pattern
20:07:13 <dibblego> Cale, yes, he commented on my Maybe in Java as well - he does not know Haskell very well
20:07:28 <Cale> I recommended Scala to him
20:07:46 <Cale> (not on his blog, because posting on his blog is broken for me)
20:07:56 <goltrpoat> cale:  you know there's a type sum in boost, right..  might be a back-asswards way of implementing Maybe, though
20:08:13 <dibblego> I'd rather someone just write a Haskell -> VM compiler and we can use Data.Maybe
20:08:51 <Cale> If you really have your heart set on interfacing with Java programs directly, you can use Scala, where you have case classes and pattern matching
20:09:12 <dibblego> yeah, but it's not Haskell :) where is the controlled side-effects?
20:09:20 <chessguy> for the record, not everyone believes that low-level optimizations are the key to chess
20:09:25 <Cale> Well, it's still very imperative
20:09:30 <Cale> But Scala's designer is someone who actually knows what they're doing.
20:09:30 <LordBrain> occasionally i've posted long comments on blogs... then i reflect and wonder if that's poor ediquette
20:09:42 <chessguy> not that i know anything about chess :)
20:09:53 <dibblego> LordBrain, I can be a rant nut sometimes - bugger 'em I say :)
20:10:37 <dibblego> I played chess a lot as a kid in competitions
20:10:48 <chessguy> i do have most of a bitboard representation for chess written in haskell
20:10:57 <glguy_> http://programming.reddit.com/info/uqo3/comments/cuqxz
20:11:00 <dibblego> I have an Array2D data type!
20:11:05 <chessguy> bah
20:11:10 <glguy_> How is "heh. And suddenly haskell is not so elegant after all." getting +1 mods?
20:11:13 <goltrpoat> dibblego:  yah same here..  played tournament chess until i was 16 or so
20:11:15 <dibblego> with memoized width and height
20:11:16 <LordBrain> i seem to do pretty good at chess when playing locals, but not so hot on the internet.
20:11:18 <dibblego> data Array2D a = Array2D (Map Coord a) Width Height
20:11:27 <chessguy> 2d arrays are bad implementations
20:11:40 <Cale> dibblego: e.g. check this out, it's nearly tolerable http://scala.epfl.ch/examples/files/patterns.html
20:11:43 <lambdabot> Title: sources/examples/files/patterns.scala
20:12:02 <chessguy> unless you're doing 0x88, which i highly doubt
20:12:55 <dibblego> Cale, that does look tidy
20:13:05 <dibblego> chessguy, what's a bad implementation?
20:13:24 <chessguy> slow
20:13:29 <Cale> and you can see the use of None/Some which are the constructors for Scala's equivalent to Maybe
20:13:30 <chessguy> using loops
20:13:53 <goltrpoat> bitboards are still pretty popular
20:14:04 <dibblego> Cale, nice
20:14:05 <goltrpoat> 0x88/mailbox pops up here and there
20:14:08 <chessguy> goltrpoat, yes, and there's a lot of variants now
20:14:19 <goltrpoat> but bitboards are hard to beat, especially with sse
20:14:21 <chessguy> don't see mailbox much
20:14:27 <jcreigh> chessguy: a "bitboard"? Is there were you use a 64-bit array to represent, say, white pawns? and * 12 for the whole board?
20:14:31 <xpika> > let f n xs = xs  \\ [0,n..(length xs)] in f 3 [1,2,3,4]
20:14:32 <lambdabot>  [1,2,4]
20:14:39 <goltrpoat> jc:  that's the one
20:14:45 <chessguy> jcreigh, a 64-bit number, not an array
20:15:03 <Cale> This is why even if you're going to design a Java-like language, you should know about all the programming language research that's gone on. The results are so much better.
20:15:04 <goltrpoat> there's a difference? :)
20:15:07 <dibblego> chessguy, wtf is slow?
20:15:14 <sorear> :t 0 == 0 && 1 == 1
20:15:15 <lambdabot> Bool
20:15:38 <chessguy> goltrpoat, sure. it's called O(1) random access
20:15:49 <jcreigh> chessguy: right. I was thinking "64-bit number" = "array of 64 bits"
20:15:52 <dibblego> Cale, Haskell can be a Java-like language! it need only compile to the JVM without recursion
20:16:06 <chessguy> well, an array has that, but anyway, a single 64-bit number is more compact
20:16:09 <goltrpoat> dibblego:  common queries are greatly accelerated with bitboards.  eg:  how do you query for "what are the rook captures from this square" using an array of float
20:16:13 <Cale> I mean from the programmer perspective, not just compiling to JVM
20:16:29 <goltrpoat> er
20:16:34 <chessguy> using bitboards, you can generate legal moves without ANY loops at all. that's impressive
20:16:38 <goltrpoat> array of float..  sorry, having two conversations at the same time
20:16:44 <dibblego> I can write code without loops; I do it every day
20:16:44 <sorear> [ (x,y) | x <- [0..3], y <- [0..3] ]
20:16:46 <goltrpoat> an array of squares.
20:16:51 <sorear> > [ (x,y) | x <- [0..3], y <- [0..3] ]
20:16:53 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
20:16:56 <int-e> glguy_: I don't know. I don't see much difference between the Haskell and the Lisp versions of that code. Haskell has some more operators, Lisp has more parentheses ;)
20:17:39 <glguy_> I'm curious what he thinks an "elegant" solution to that problem would be
20:18:01 <int-e> glguy_: one that looks like Lisp.
20:18:07 <LordBrain> hehehe
20:18:08 <dibblego> what is a bitboard?
20:18:28 <dibblego> goltrpoat, why can't I answer that question with a Map (Int, Int) Position ?
20:18:30 <chessguy> a bitboard is a 64-bit number that tells which squares contain a particular kind of piece
20:18:41 <goltrpoat> dibblego:  you can.  you just can't answer it in constant time.
20:19:12 <dibblego> how can I do that with a 64-bit number?
20:19:38 <int-e> dibblego: you restrict yourself to one kind of pieces; each board position gets one bit.
20:19:43 <chessguy> for that, you need to read Bob Hyatt's board representation article
20:19:51 <goltrpoat> dibblego:  rows and columns can index into lookup tables
20:19:55 <dibblego> chessguy, link?
20:20:10 <chessguy> http://www.cis.uab.edu/info/faculty/hyatt/pubs.html
20:20:13 <goltrpoat> dibblego:  bitboards for opponent's pieces can be or'd into a single 64 bit value to get all pieces for the opponent
20:20:14 <lambdabot> Title: Online Publications
20:20:16 <chessguy> the first two articles there are relevant
20:21:09 <goltrpoat> http://wannabe.guru.org/scott/hobbies/chess/ is a decent introduction too
20:21:29 <goltrpoat> rob hyatt is a very very smart guy though.  wish he'd publish a bit more
20:21:32 <chessguy> wow, a chess programming page i haven't seen before
20:21:41 <chessguy> goltrpoat, who the heck are you?
20:21:51 <goltrpoat> ? :)
20:22:00 <chessguy> have you written an engine?
20:22:02 <sieni> aaaaaargh
20:22:10 * sieni is in a hurry
20:22:17 <goltrpoat> chessguy:  a couple, nothing major though
20:22:23 <sieni> in fact still naked and in a hurry
20:22:23 <sieni> ->
20:22:42 <chessguy> do you read at CCC ?
20:22:56 <goltrpoat> occasionally.. ive posted a few things here and there
20:23:21 <chessguy> oh, i think i have read this page before
20:23:24 <goltrpoat> probably as 'vlad andreev'
20:23:25 <chessguy> it's just been a while
20:23:38 <chessguy> hmm, don't think i know you
20:24:32 <goltrpoat> makes sense, i think ive only posted 3-4 times
20:24:46 <chessguy> it's unusual for me to meet someone that knows as much about computer chess as me :)
20:25:42 <goltrpoat> yeah, it's a pretty small community, it seems.  edwardk here has done some checkers programming
20:26:31 <chessguy> ah yes, i've talked to him
20:26:45 <chessguy> we've had some very interesting conversations, actually
20:26:57 <chessguy> about some of my ideas for chess AI
20:27:29 <goltrpoat> -nod-
20:27:49 <geckosenator> could a neural network work?
20:27:59 <chessguy> it's been tried
20:28:17 <goltrpoat> there were several proof of concept "learning" engines
20:28:50 <chessguy> there's an article on hyatt's site about learning, too. same like as the one i pasted earlier
20:29:02 <int-e> it's hard to teach tactical variations, so you need a tactical search anyway. and 'deep but mostly stupid' seems to go a long way in chess.
20:29:04 <goltrpoat> i think the general consensus is that it's a bad direction to go in
20:29:42 <goltrpoat> although, deep thought did train its static evaluation function
20:30:04 <chessguy> yes, a lot of work has been done on learning coefficients for static eval
20:30:06 <geckosenator> you could have the computer play itself to train
20:30:13 <chessguy> which i think is a bunch of hooey
20:30:18 <goltrpoat> http://supertech.lcs.mit.edu/~heinz/dt/ has some stuff on that
20:30:20 <lambdabot> Title: WWW Pages of "DarkThought"
20:30:21 <geckosenator> or would the network need so many billions of neurons to work?
20:31:29 <goltrpoat> as far as training static evaluation, training board gradients, etc.. i think there's some future in that
20:31:37 <chessguy> well, i don't really know much about ANNs
20:31:41 <goltrpoat> as far as training the engine itself..  that's completely impractical
20:32:09 <geckosenator> didn't they already make a computer chess program that can beat any human?
20:32:18 <geckosenator> why would you need to make anything better than what exists?
20:32:30 <int-e> geckosenator: to beat other computer programs
20:32:35 <chessguy> humans are a poor standard to compare to
20:32:46 <geckosenator> won't it just be a stalemate?
20:32:47 <chessguy> kramnik showed that in the recent man-machine match
20:32:55 <goltrpoat> we have programs that are very competitive, when run on decent hardware.  it's a very interesting problem in and out of itself, though
20:33:02 <Excedrin> it's funny that chess programs can beat grandmasters, but only if they have a good opening book
20:33:05 <chessguy> this guy who can see 15, 20 moves ahead missed a simple mate in 1
20:33:15 <Excedrin> chess programs are horrible at Fischer Random Chess
20:33:34 <geckosenator> what about atomic chess?
20:33:39 <int-e> chessguy: I really wonder if he'd have made the same mistake, in the same position, against a human.
20:34:29 <chessguy> int-e, hard to say. he claims he wasn't tired, felt fine, etc. he just flat-out missed it. was pressing too hard for the win
20:35:28 <chessguy> geckosenator, i don't know anyone that takes atomic chess very seriously
20:35:38 <Excedrin> I don't know anything about atomic chess... off to wikipedia
20:35:49 <int-e> geckosenator: atomic chess games are much shorter and more tactical IIRC.
20:35:56 <Excedrin> ya, that sounds kinda silly
20:35:58 <int-e> geckosenator: so I'd expect computers to shine.
20:36:33 <Excedrin> it doesn't do anything to make search more difficult, so programs probably work very well
20:36:55 <geckosenator> i take it seriously
20:36:59 <geckosenator> it's the only kind of chess I play
20:37:18 <geckosenator> Excedrin: it's sweet, you should try it
20:37:47 <geckosenator> i guess the computer would do better since the search space is smaller
20:38:22 <Excedrin> the only chess variant I've played much is bughouse
20:38:32 <dons> Excedrin: ok, I've tried to refocus things :) http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/15#on-syntax-again
20:38:33 <lambdabot> Title: Haskell hacking
20:38:36 <chessguy> variants are ugly compared to chess
20:38:40 <dons> atleast, to add more emphasis
20:39:25 <goltrpoat> chessguy:  i was thinking it'd be somewhat interesting to see if the common constructs in chess engines have elegant functional counterparts -- infinite game trees, memoization instead of transposition tables, zippers for repetition testing, etc
20:39:36 <geckosenator> do they have computers that play bughouse?
20:39:41 <goltrpoat> gecko:  yeah
20:39:44 <dons> on another topic, I think this is quite a nice article, but i'm not sure why its getting modded down, http://programming.reddit.com/info/uu7k/details
20:39:50 <dons> seems to be quite general in scope
20:41:15 <Excedrin> dons: neat, did you see the "fastest fib in the west" link that I replied to the "zipWith vs fib_iter" posts?
20:41:20 <dons> Excedrin: yeah!
20:41:23 <dons> i'd not seen that
20:41:24 <goltrpoat> bughouse is fun in person..  i haven't really played chess in person in about 10 years though, and it's not nearly the same experience online
20:41:35 <dons> mmm. all thse fibs should be collated on the wiki...
20:41:49 <Excedrin> dons: it's wli's fib from Jan 2005, which is now only very slightly slower than the MLton/SML version
20:41:58 <geckosenator> in bughouse people always stall
20:42:09 <dons> dibblego: http://rickyclarkson.blogspot.com/2006/09/using-strong-typing-to-eliminate.html
20:42:11 <Excedrin> I think it's very cool that GHC has improved that much (from 6:1 to 1.2:1 or something)
20:42:12 <lambdabot> Title: rickyclarkson: Preventing NullPointerExceptions, Maybe, http://tinyurl.com/wxpr4
20:42:39 <dibblego> dons, yes I saw that - Ricky commented on mine as well
20:42:41 <dons> Excedrin: yeah. and there's some big improvements in the head, rt. 6.6 stable. (stuff that we needed for the parallel arrays work)
20:42:46 <dons> wrt.
20:43:23 <chessguy> well, time to call it a day. 'night all
20:43:30 <jcreigh> 'night
20:43:54 <Excedrin> geckosenator: I think there's a few programs that play bughouse
20:45:06 <dons> here you go guys, http://programming.reddit.com/info/uuzg/comments   More on syntax :)
20:45:53 <goltrpoat> gecko:  i can't think of any of the "big" engines that play bughouse
20:45:59 <goltrpoat> but there are certainly tons of programs floating around
20:47:00 <geckosenator> well i know nothing about writing a chess ai
20:47:41 <geckosenator> would it be very hard to modify it to do bughouse?
20:47:46 <Excedrin> http://www.sjeng.org/indexold.html
20:47:47 <lambdabot> Title: Sjeng : a chess-and-variants playing program
20:47:52 <Excedrin> that one plays on FICS afaik
20:48:19 <geckosenator> I guess it's tricky because the computer might want to wait for it's partner to take a piece
20:48:32 <geckosenator> but if it has a clock..
20:48:38 <lisppaste2> dibblego pasted "How can I use a function with the same name from each module?" at http://paste.lisp.org/display/32468
20:48:38 <goltrpoat> pretty easy if it's playing both sides
20:48:45 <geckosenator> that would help
20:48:59 <goltrpoat> i mean.. both boards
20:49:05 <geckosenator> right
20:49:22 <geckosenator> well what if one of its opponents is stalling for a piece?
20:49:27 <Excedrin> aka Crazyhouse
20:50:13 <dons> dibblego: import qualified as P?
20:51:01 <dibblego> dons, do you mean, if I get rid of the parentheses?
20:52:51 <dons> ah sorry. I see. you hvae mutually recursive modules
20:52:59 <dons> which means you need a .hs-boot file to break the module loop
20:53:14 <dibblego> what a pain
20:53:28 <dibblego> I'll just rename my functions
20:53:35 <dons> dibblego: lookup 4.6.9. How to compile mutually recursive modules
20:53:39 <dons> in the ghc user's guide
20:53:43 <dibblego> ok thanks
20:56:28 <dcnstrct> hi guys, I'm new to haskell and have a question.   Do haskell programmers sometimes create internal domain specific languages to express configuration code or is this hard to do in haskell ? I've been programming in this style lately with Ruby and Lisp.  I've found that both of those languages have syntaxes that tend to allow a great deal of flexibility when it comes to constructing these little mini-languages inside of the host lang
20:56:58 <SamB_XP> dcnstrct: configuration code?
20:57:00 <Excedrin> dcnstrct: you got cut off at "host lang..."
20:57:06 <dcnstrct> ugh
20:57:06 <dons> yeah, that's pretty common. (DSEL)
20:57:16 <dons> but what do you mean by 'configuratoin code'
20:57:58 <dibblego> a Java properties file succeeds in compiling under GHC :)
20:57:59 <dcnstrct> http://www.rafb.net/paste/results/fwVL4Q60.html
20:58:12 <dibblego> besides comment
20:58:13 <dibblego> s
20:58:25 <Excedrin> dcnstrct: http://software.complete.org/configfile
20:58:27 <lambdabot> Title: ConfigFile
20:59:59 <sorear> I need to handle SIGWINCH.  Obviously the only useful thing I can do is set a variable.
21:00:28 <sorear> My question is, can a IORef be volatile? or do I need an MVar for that?
21:01:23 <Excedrin> dcnstrct: some programs also simply define some Config type (typically a record), then use compiled in values
21:01:38 <dibblego> dons, is this right - a module cannot call a function defined in another module, if that other module calls a function in this module, without using a .hs-boot file
21:01:45 <dons> yes
21:01:46 <dons> in ghc
21:01:56 <dibblego> ok
21:01:58 <dons> I think jhc can handle mutually recursive modules properly
21:02:28 <goltrpoat> is there any particular reason why binding groups can't cross module boundaries like that in ghc?
21:02:32 <Excedrin> jhc has other issues
21:02:56 <dons> indeed :)
21:03:05 <dcnstrct> ok thanks for the help guys
21:08:01 * dibblego wonders if it is import {-# SOURCE #-} qualified or import qualified {-# SOURCE #-}
21:08:17 <dons> the former, I believe
21:09:29 <sorear> Can an IORef be safely written to from a signal handler?
21:09:49 <dons> I think so... use atomicModify*
21:09:51 <dons> or use an MVar I would)
21:09:54 <sorear> (i.e. can they be read as if they were c 'volatiles')
21:10:02 <mbishop> way to start a flamewar on reddit dons :P
21:10:28 <dons> mbishop: :} I didn't mean it to be! I blame blosxom for cat'ing all my haskell articles yesterday on the same page
21:10:33 <goltrpoat> yeah, the populace appears displeased.
21:10:58 <dons> lesson: don't ever cite any other programming language
21:11:07 <dons> esp. not lisp
21:11:40 <goltrpoat> and then "Fib function is nice, but anything non-trivial looks bizarre in Haskell." gets modded up to 11 somehow
21:11:47 <goltrpoat> nuts.
21:11:53 <jcreigh> Lisp: The programming language everybody loves to love.
21:11:58 <dons> mm. way to cite sources there, eh? ;)
21:12:03 <dons> jcreigh: heh
21:12:25 <goltrpoat> dons:  unless it's java.
21:12:25 <dons> i was almsot going to change the title of my reply to "Oh, but you can do that with macros!"
21:12:31 <dibblego> which reddit thread is it?
21:12:48 <dons> goltrpoat: yeah, java is ok
21:12:54 <sorear> what should I use for $siz = `stty size`; ?
21:13:08 <dons> sorear: in haskell?
21:13:16 <sorear> yes
21:13:27 <dons> so you want to get back, what , a string?
21:13:27 <dons> $ stty size
21:13:28 <dons> 37 101
21:13:30 <dons> containing that?
21:13:32 <sorear> yes
21:13:35 <jcreigh> The problem with example code is that "Hello, world!" is trivial in any language. You can't get a feel for a language in three lines of code.
21:13:41 <dons> popen/System.Process*
21:14:28 <dons> ?docs System.Prcoess
21:14:28 <lambdabot> System.Prcoess not available
21:14:46 <dons> sorear: a nice wrapper to the run* stuff in System.Process is being discussed atm
21:14:52 <dons> (its strongly needed in the base libs, imo)
21:15:05 <mbishop> language zealotry is silly to me
21:15:35 <mbishop> I used to be like that, then I realised all languages are pretty nice, and even if they aren't, some people still think they are :P
21:15:40 <dons> hehe
21:15:51 <goltrpoat> i used to think all languages were pretty nice
21:16:05 <sorear> Which would be easier: shelling out to stty size | using the FFI and ioctl(TCGWINSZ)
21:16:07 <dons> i'm still not sure php is nice
21:16:13 <goltrpoat> that was a much easier time.
21:16:23 <mbishop> I don't like php, or java, or perl, but I'm sure they have their uses
21:16:29 <mbishop> thank god I don't have to use them though :P
21:16:30 <dons> sorear: hmm. the ioctl might be better in the long run?
21:16:40 <dons> but the popen call is stil only 5 lines of code (4 too many, I know)
21:17:06 <dibblego> dons, you were right - it is the former (import {-# SOURCE #-} qualified ...)
21:17:17 <sorear> there is no popen in my System.Process.
21:19:38 <dons> sorear: I know :) try this wrapper: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Process.hs
21:19:38 <lisppaste2> wy pasted "Why is eval2 better?" at http://paste.lisp.org/display/32470
21:19:45 <dons> something along these lines I'm trying to get into base
21:21:16 <goltrpoat> better?
21:21:39 <dons> Excedrin, Cale, http://haskell.org/haskellwiki/The_Fibonacci_sequence
21:21:41 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
21:21:42 <goltrpoat> (genuinely curious, they seem equivalent and about equally readable)
21:22:07 <wy> I'm doing the exercise of a book. I can't see why the second is better as claimed by the book
21:22:10 <goltrpoat> oh wait, they're not equivalent
21:24:07 <Excedrin> dons: #2 there seems broken...
21:24:11 <dons> mmm http://reddit.com/blog/theft
21:24:39 <goltrpoat> eval2 does nothing worth mentioning if only the head is evaluated
21:25:11 <goltrpoat> eval1 needs to evaluate tiFinal state every time
21:25:20 <dons> Excedrin: which link?
21:25:22 <goltrpoat> i.. think..
21:25:49 <Excedrin> the fibs page
21:27:35 <lisppaste2> metaperl pasted "lifting types question" at http://paste.lisp.org/display/32473
21:27:44 <dons> Excedrin: oh, you mean, fib = zipWith (+) fib (tail fib)
21:27:44 <wy> goltrpoat: but eval2 also has to tiFinal state
21:27:53 <dons> > let fib = zipWith (+) fib (tail fib) in take 10 fib
21:27:55 <lambdabot>  Exception: <<loop>>
21:28:09 <dons> > let fib = zipWith (+) (tail fib) fib in take 10 fib
21:28:11 <lambdabot>  Exception: <<loop>>
21:28:22 <Excedrin> needs some 1:1:
21:28:39 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:28:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:28:41 <dons> :)
21:28:49 <Eidolos> > let fib = 1 : zipWith (+) (tail fib) fib in take 10 fib
21:28:50 <lambdabot>  Exception: <<loop>>
21:29:04 <Eidolos> (didn't expect that to work, what with tail fib and all)
21:29:29 <dons> > fix $ \fib -> 1 : 1 : zipWith (+) fib (tail fib)
21:29:30 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:29:32 <int-e> metaperl: "instance Movable a => Movable (Name a)" --> given an instance of Movable, a, we can construct an instance of Movable, Name a, with the following operations:
21:30:36 <metaperl> int-e - so we can read the => as implies?
21:30:39 <int-e> metaperl: and 'lift' really just means what mapName does - take an operation on a type  a -> b -> ... -> z  and get an operation of type  Name a -> Name b -> ... -> Name z  back.
21:30:48 <Eidolos> lambdabot should try to break off an infinite sequence of numbers after a comma :)
21:31:18 <int-e> metaperl: if you regard type classes as predicates, yes.
21:31:26 <metaperl> int-e - it looks like lift is a monad-ish type thing. The container stays the same, but the contents changes?
21:31:55 <goltrpoat> wy:  i think the point is that when eval2 is applied, since only the head is evaluated until you ask for the rest of the list, you basically do nothing.  when eval1 is applied, it has to evaluate tiFinal state and then branch
21:32:27 <goltrpoat> hopefully someone will correct me if i'm on crack.
21:32:36 <metaperl> lol
21:32:46 <metaperl> what if you're on heroine?
21:33:27 <goltrpoat> in that case, the heroine might choose to correct me as well.
21:33:38 <metaperl> heh
21:34:28 <int-e> metaperl: hmm. Just a functor in your case (Monads are special functors); a functor F comes with a map operation,   fmap :: (a -> b) -> F a -> F b  that satisfies a few laws.
21:34:30 <goltrpoat> wy:  is that from SPJ's compiler paper?
21:35:02 <metaperl> int-e - I see
21:35:10 <int-e> metaperl: (fmap id = id [note: the two 'id' have different types]  and   fmap (g . f) = fmap g . fmap f)
21:35:42 <int-e> metaperl: an example are lists, where   fmap = map
21:36:00 <int-e> @type map
21:36:02 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
21:36:11 <metaperl> int-e - what do you mean the two 'id' have different types?
21:36:35 <int-e> metaperl: the left 'id' has type  a -> a, the right one has type F a -> F a
21:37:50 <wy> goltrpoat: Yes. It's from "Implementing Functional Languages: a Tutorial"
21:39:22 <int-e> metaperl: anyway, Functors give you a limited 'lift'. Monads extend that to constants (return :: a -> F a) and functions with more than one argument (via liftM2, liftM3, etc.). (In fact Applicative is enough for that but I don't really want to explain that now.)
21:39:33 <wy> goltrpoat: sorry you need to change the recursive "eval" to "eval1" or "eval2" in the two definitions
21:39:41 <goltrpoat> oh
21:39:54 <goltrpoat> oh right.  same thing
21:40:19 <metaperl> int-e - ok. thanks. that makes things a lot clearer
21:40:32 <int-e> metaperl: note that when you have a Functor instance and a Monad instance for the same thing, they should have  liftM = fmap  (of course there's no way to enforce that)
21:41:12 <wy> goltrpoat: But I think eval1 is also lazy. If it's not tiFinal, the rest of the list won't be evaluated
21:41:20 <jcreigh> @hoogle [a -> m a] -> a -> m a
21:41:21 <lambdabot> No matches, try a more general search
21:41:37 <jcreigh> Is this a standard function? ordered fs x = foldl (>>=) (return x) fs
21:42:24 <dons> ?pl fs x = foldl (>>=) (return x) fs
21:42:25 <lambdabot> fs = fix (flip (foldl (>>=) . return))
21:42:26 <goltrpoat> wy:  there seems to be more work involved in evaluating eval1
21:42:32 <dons> is that foldM ?
21:43:06 <dons> :t Control.Monad.foldM
21:43:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:43:09 <jcreigh> @pl ordered fs x = foldl (>>=) (return x) fs
21:43:09 <lambdabot> ordered = flip (foldl (>>=) . return)
21:43:20 <wy> goltrpoat: I guess it is more work, but I have to see it
21:43:44 <wy> Is there a way to count the reduction steps in Haskell?
21:44:15 <goltrpoat> hugs shows you the number of reduction steps
21:45:10 <dons> oh, I quite like this comment " An analogy to be made is english language. Sure, some people like Shakespeare used english to write masterpieces, but imagine what would happen to society if at the starbucks you asked for a coffee and the clerk refused to serve you unless you spoke in sonnet."
21:45:17 <goltrpoat> let's take some tiState s though, and say that tiFinal s.  then eval2 s simply constructs the list s:(thunk), whereas eval1 s a) evaluates tiFinal s, which evalutes to true, b) constructs the list [s]
21:45:31 <dons> wy, :set +s ?
21:46:14 <dons> wy, its not quite what you want, i.e. it'll print:
21:46:15 <dons> (0.05 secs, 3357916 bytes)
21:46:26 <dons> but, to really see the reductions (in graph machine style), you'd use hat
21:46:35 <dons> the haskell tracer
21:46:51 <int-e> dons: in hugs, you see something like (162 reductions, 309 cells)
21:48:42 <dons> int-e++
21:48:44 <dons> Hugs.Base> take 10 (let f = 1 : 1 : zipWith (+) f (tail f) in f)
21:48:44 <dons> [1,1,2,3,5,8,13,21,34,55]
21:48:44 <dons> (305 reductions, 522 cells)
21:48:49 <wy> dons: Could you look at my problem? http://paste.lisp.org/display/32470. I've done evaluations with :set +s.
21:48:52 <dons> mm, I wouldn't mind hooking into this for lambdabot
21:49:03 <goltrpoat> dons:  how *does* one place a starbucks order in 14 lines?
21:49:26 <wy> dons: But I can't see any big difference
21:49:33 <int-e> goltrpoat: just stand in one of them?
21:49:44 <int-e> goltrpoat: and wait until it's your turn ;)
21:49:51 <dons> wy, eval2 is a bit simpler
21:49:59 <dons> since you don't have special handling for the last-but-1 case
21:50:09 <dons> you just base it instead on the induction on lists
21:50:12 <dons> i.e. [] and (x:xS)
21:50:46 <goltrpoat> int-e:  nice
21:50:53 <sorear> Yay! my FFI code works!  (for fetching window size)
21:50:58 <dons> cool
21:51:03 <jcreigh> Ironically, Starbucks's names for drink sizes aren't English...
21:51:08 <dons> sorear: stick it up somewhere. i'd like to use it in hmp3 ....
21:51:17 <wy> dons: But can you find why eval1 is inferior as clained by the book?
21:51:34 <dons> for the reason I said :)
21:51:48 <dons> its inferior (slightly) because its not derived from the inductive structure of the list type
21:52:25 <sorear> dons: do you want my windowsize fetcher (6 lines of C and 3 of Haskell+FFI) or the whole curses clone?
21:52:29 <goltrpoat> am i correct in saying that the second one is more efficient with lazy evaluation?
21:52:31 <wy> dons: There must be some practical difference, I guess.
21:52:35 <dons> sorear: ok, i'll wait for the cone
21:52:42 <dons> s/clone/
21:52:53 <dons> wy, yeah, maybe. what does hugs :set +s say?
21:53:05 <wy> dons: I'm using ghci
21:53:21 <dons> try hugs :set +s :)
21:53:31 <dons> (or -prof ;)
21:54:01 <wy> dons: Oh. I have no hugs. Must I use hugs? ghci also has :set +s
21:55:44 <dons> I'd use -prof -O in ghc
21:55:46 <dons> to really check the difference
21:57:38 <emu> jcreigh: i just ask for small,med,large anyway
21:58:05 <wy> eval2: (93170 reductions, 182968 cells)
21:58:19 <wy> eval1: (92845 reductions, 182111 cells)
21:58:45 <wy> eval1 has less reductions.
21:59:18 <goltrpoat> just got the same thing here.  65 vs 64 with stubbed out doAdmin/step/tiFinal
21:59:28 <goltrpoat> so much for that theory :)
22:13:19 <wy> Thanks. OK. Let it be. I'll go on reading tomorrow. Good night all!
22:17:09 <mbishop> heh
22:17:21 <mbishop> even more silly responses to your second post dons :)
22:17:38 <mbishop> that one guy seems to confuse type inference with dynamic typing
22:18:55 <dons> mbishop: ah well :}
22:19:09 <dons> maybe i hope for too much from reddit
22:19:14 <mbishop> and who knows what that other guy means
22:19:18 <mbishop> "it's all about the libraries"
22:19:25 <mbishop> what the hell does that have to do with anything? heh
22:20:18 <dons> yeah, reading comprehension skills aren't required to operate reddit, unfortunately
22:20:34 <dons> the anonymous up modders seem to like it though
22:20:52 <notsmack> (yo.)
22:21:09 <trh> I was just readon aaronsw' latest blog entry--is that what you're talking about?
22:21:13 <mbishop> seems the only good "social bookmarking" sites are those without comments (like del.icio.us
22:21:40 <dons> trh, http://programming.reddit.com/info/uuzg/comments
22:21:48 <trh> oh...
22:22:02 <mbishop> )
22:22:07 <mbishop> gotta close my parens :)
22:22:08 <trh> I made a couple of comments on reddit once... ONCE.
22:22:50 <seba> can anyone recommend me a good editor for haskell in linux?
22:23:02 <trh> (I was reading your last blog entry too Don :))
22:23:25 <trh> : probably linked from reddit...
22:23:52 <dons> seba, emacs or vim?
22:24:43 <trh> I use vim with an indentation plugin I downloaded but can't remember where from though.
22:25:03 <mbishop> Yi?
22:25:13 <dons> ;
22:25:19 <dons> )
22:25:23 <seba> How do I run code directly from emacs?
22:25:59 <trh> Geez, those reddit commenters don't quite get it.  Hrmm.
22:26:34 <Excedrin> what does "Mathematics does not have type inference" mean?
22:26:56 <seba> thanks, I'll give Yi a try too
22:27:00 * mbishop shrugs
22:27:38 <dons> seba, as the author of yi, i don't reccomed it for everyda programming. its just a vi clone :)
22:27:46 <dmead> seba: emacs is really the fastest to learn
22:27:55 <Excedrin> if someone says "for any X in the Reals, X+1 > X" and follows it with a proof, I don't remember seeing something that says, "+ :: Real -> Real; 1 :: Real"
22:28:05 <trh> Damn dons.  Are you officially the most prolific Haskell hacker in town?
22:28:17 <dmead> dons is EPIC
22:28:29 <trh> And how much time do you actually spend in #haskell daily?
22:28:32 <dons> nah, don't think so. try John Goerzon
22:28:41 <lisppaste2> metaperl annotated #32473 with "trying to follow the implications of an aggregate typeclass -- help needed" at http://paste.lisp.org/display/32473#1
22:28:45 <int-e> Excedrin: what about (+) : R x R -> R, 1 in R ...
22:28:46 <dmead> who actually runs the ghc project?
22:28:48 <dmead> dcoutts?
22:29:26 <Excedrin> int-e: I don't know.. I'm just saying, is it typical to verbosely declare the types of everything in math?
22:29:30 <int-e> Excedrin: you'll see that when definining groups, rings and so on.
22:29:35 <goltrpoat> this is the third or fourth time ive seen haskell syntax referred to as "bizarre" on reddit in the past few days
22:29:39 <goltrpoat> which.. confuses me
22:29:41 <int-e> Excedrin: they're often implied. It depends on the context.
22:29:54 <goltrpoat> since if you can read ml, you can probably follow haskell
22:30:00 <trh> I think it's mostly Lispers making that comment.
22:30:14 <trh> No syntax == elegance.
22:30:16 <lisppaste2> metaperl annotated #32473 with "mapName" at http://paste.lisp.org/display/32473#2
22:30:23 <int-e> Excedrin: but when you introduce the basic definitions to work with, in group theory, you have them.
22:30:41 <int-e> Excedrin: that's comparable to some extend with declaring a type class.
22:31:03 <dons> dmead, ghc? the cambridge haskell crew: spj and simonm
22:31:22 <trh> SPJ is turning into a personal hero of mine.
22:31:23 <int-e> @spell extent
22:31:24 <lambdabot> extent
22:31:29 <dmead> ahh
22:32:02 <trh> I've been studying his '87 book and watched him on Channel 9 the other week.
22:33:11 <trh> dons: that little script on your blog doesn't work for me... typeof.sh... I haven't given it a proper look though.
22:33:46 <trh> It's pulling in filenames from the current directory into the expression passed to ghci...
22:34:09 <dons> goltrpoat: yeah, its weird, since its:
22:34:10 <dons> (f)= ((\(x)-> (Just) ((++)
22:34:10 <dons>         (x)
22:34:14 <dons>         ((++)
22:34:14 <dons>             (" is a lisp")
22:34:14 <dons>             (", though!")))))
22:34:20 <dons> ;)
22:34:43 <goltrpoat> hah
22:34:47 <int-e> > let (x) = 42 in x
22:34:48 <lambdabot>  42
22:35:02 <dons> trh, hmm. interesting. probably the string escaping issues. i'm writing a small haskell implementation now to do things "properly"
22:35:08 <dons> since i got some feedback along those lines
22:35:50 <trh> That's exactly it, of course.  If a * is in your expression then sh sucks it up...
22:35:55 <goltrpoat> it's weird how few informed top-level responses there were to that post
22:36:02 <goltrpoat> although maybe it's just that it provoked the wrong kind of people
22:36:03 <dons> seba, you were asking earlier about haskell/emacs http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
22:36:04 <goltrpoat> -shrug-
22:36:05 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
22:36:11 <dons> trh, yes. exactly
22:36:19 <dons> or some other meta chars
22:37:04 <trh> Is there a better way to send the line to ghci?  You're doing it that way just to use sed, no?
22:37:15 <dons> yeah.
22:37:36 <trh> vim can probably do it itself, though I've never tried serious vim hacking...
22:37:39 <dons> better to actually extract the top level identifer properly (i.e. a lexer), then feed it over a pipe to ghci, not through the shell
22:37:45 <dons> trh, hmm. yes. quite possibly
22:38:06 <seba> thanks dons! I installed it and wrote a short program, works well
22:38:33 <dons> though with a 3rd party unix tool, we could bind from emacs and so on as well
22:42:17 <metaperl> how would instance Named a => instance Named (Name a)  differ from instance Named (Name a)
22:42:53 <metaperl> I'm referring to fact 1 here: http://paste.lisp.org/display/32473#1
22:43:05 <sjanssen> metaperl: in the first instance, a must be an instance of Named for (Name a) to be an instance of Named
22:43:45 <sjanssen> the second says (Name a) is an instance of Named, regardless of the status of a
22:47:31 <metaperl> sjanssen - thanks. that makes sense. would you mind answering my question about the implications of the aggregate type at the bottom of this paste: http://paste.lisp.org/display/32473#1
22:50:02 <metaperl> could someone please help with this aggregate type class question - http://paste.lisp.org/display/32473#1
22:50:33 <goltrpoat> the last instance?
22:50:44 <sjanssen> metaperl: what do you mean by "obeys the signature"?
22:50:49 <metaperl> goltrpoat - yes  - instance Movable a => NamedMovable (Name a)
22:50:51 <sjanssen> do you mean "is an instance of"?
22:51:12 <metaperl> sjanssen  - yes. an instance of a typeclass obeys the signature for that class
22:52:34 <goltrpoat> translates to:  given some type that's Movable, call it a, we're going to say that all types 'Name a' are instances of NamedMovable.  Name is polymorphic in one parameter
22:53:15 <sjanssen> metaperl: it is the case because the instance and your English statement are equivalent
22:53:22 <metaperl> goltrpoat - but must it be so? I understand that it says that
22:54:01 <metaperl> SJT says it can be established by showing that the two constraints of (3) hold when
22:54:01 <metaperl> b is replaced by Name a, but this is exactly what (1) and (2) say given the constraint
22:54:01 <metaperl> Movable a.
22:54:15 <metaperl> I dont get what he is saying
22:54:51 <metaperl> In other words, he seems to say it is provable
22:54:58 <sjanssen> yeah, it is
22:55:08 <metaperl> Are we just promising to implement the signature or can we prove it? I dont follow his argument
22:55:54 <sjanssen> we know that forall a. (Name a) is an instance of Named (fact 1)
22:56:13 <metaperl> just because something is Movable does not imply that it is NamedMovable ... because being Movable does not guarantee that the Named signature will be fulfilled
22:56:26 <metaperl> sjanssen - yes I agree with that (fact 1)
22:56:33 <sjanssen> forall a. Movable a implies Movable (Name a) (fact 2)
22:56:48 <metaperl> yes
22:56:50 <dons> hey, typeOf users, would you like to try:
22:56:51 <dons> darcs get http://www.cse.unsw.edu.au/~dons/code/typeof
22:56:52 <lambdabot> Title: Index of /~dons/code/typeof
22:57:02 <dons> same interface (though change your .vimrc from 'typeOf' to 'typeof'
22:57:08 <dons> and should fix the shell-expansion issues
22:57:26 <dons> sjanssen: i'm looking at you :)
22:57:42 <dons> trh, want to have a look too?
22:57:49 <sjanssen> dons: sure, I'll try it
22:58:03 <metaperl> sjanssen - I understand your first 2 assertions
22:58:08 <metaperl> but now what?
22:59:02 <sjanssen> dons: I removed the -fglasgow-exts flag in the original typeof script, because I hate those explicit foralls, might be something you want to think about
22:59:20 <sjanssen> metaperl: now we put the facts together
22:59:31 <dons> sjanssen: good idea
22:59:36 <goltrpoat> going back to front, Movable a => NamedMovable (Name a) unifies with (Movable b, Named b) => NamedMovable b if we replace b with (Name a).  we now have (Movable (Name a), Named (Name a)) => NamedMovable (Name a).  the first assertion can be derived from Movable a => Movable (Name a)..  so (Movable a, Named (Name a)) => NamedMovable (Name a)
22:59:51 <goltrpoat> so far so good?
23:00:08 <metaperl> goltrpoat - i'm reading... hold on :)
23:00:19 <metaperl> i'm reading your back to front... need some time
23:00:24 <dancor> what do you guys use when you need a relational database
23:00:41 <dons> sjanssen: patched.
23:00:57 <metaperl> ok. first sentence digested :)
23:01:00 <metaperl> still going
23:01:03 <dons> dancor, something from haskell.org > libraries > databases ?
23:01:04 <Excedrin> dancor: a relational database...
23:01:05 <dons> takusen?
23:01:08 <trh> dons: kapow!  works well!
23:01:09 <dmead> dancor: emerge mysql
23:01:18 <dons> trh great.
23:01:35 <Excedrin> dmead: did you mistype postgresql? ;)
23:01:41 <dmead> nope =p
23:01:43 <goltrpoat> k, so, any Name a is a Named (by Fact 1), so Named (Name a) as an assumption is a tautology.  Movable a => NamedMovable (Name a) it is then.
23:02:02 <goltrpoat> whoa wait.  went the wrong way, sorry :)
23:02:04 <notsmack> dancor: hdbc is pretty nice
23:02:44 <dons> dancor: did you find the databases page on haskell.org's libraries page?
23:02:58 <sjanssen> dons: works for me
23:03:16 <trh> the foralls are a bit ugly though...
23:03:26 <metaperl> i'm still reading the first torrent of information... second sentence digested
23:04:04 <dons> trh, just pushed a patch for that
23:04:06 <dons> repull
23:05:06 <metaperl> goltrpoat - Re: "the first assertion can be derived from Movable a => Movable (Name a)..  so (Movable a, Named (Name a)) => NamedMovable (Name a)"  --- what is the first assertion, exactly?
23:05:13 <trh> whew, ok...
23:05:21 <goltrpoat> Movable (Name a)
23:06:41 <trh> Cool.
23:06:47 <dons> fixed?
23:08:03 <metaperl> goltrpoat - you wrote "the first assertion, namely Movable (Name a),  can be derived from Movable a => Movable (Name a)..  so (Movable a, Named (Name a)) => NamedMovable (Name a)" ... but is it really the case that (Movable a, Named (Name a)) => NamedMovable (Name a)
23:08:31 <metaperl> oh!!!
23:08:32 <metaperl> neverm ind
23:08:47 <metaperl> instance Movable a => instance Movable (Name a) -- that's why
23:09:17 <goltrpoat> any Name a is Movable, for any Movable a.  any any Name a is Named, for any a
23:09:32 <goltrpoat> so, any Name a is Movable *and* Named, for any Movable a
23:09:45 <goltrpoat> and fact 3 puts those together into NamedMovable
23:09:52 <trh> dons: Yar.  I'm trying it on some hairier stuff than just toy tests and ghci is just saying 'Not in scope ...'
23:10:32 <dons> so it won't see anything you wouldn't be able to see in ghci
23:10:39 <metaperl> goltrpoat - why is it that any Name a is Movable, for any Movable a?
23:10:42 <dons> so, with compiled code, it won't see non-exported things
23:10:53 <goltrpoat> metaperl:  fact 2
23:10:55 <trh> It must be struggling to load the file... I see from the typeof source... almost direct translation of the sh. :)
23:10:56 <dons> and it might have trouble with code in other directories
23:11:22 <trh> Ahh, of course.  I usually use hugs for interactive gear.
23:11:28 <goltrpoat> metaperl:  that was badly phrased, maybe.. given a Movable a, we can infer that Name a is Movable as well
23:12:53 <dancor> dons: yes i did
23:13:00 <goltrpoat> similarly, given an a for which Name a exists, we can infer that Name a is Named (by fact 1)
23:14:24 <goltrpoat> the conjunction of those two facts is that if we have a Movable a, and Name a makes sense for it (the reason i keep saying that is that Name might have other quantifiers on it), then we know that a) Named a, b) Movable a
23:15:40 <goltrpoat> and fact 3 just says that given things that are Named and Movable, we have things that are NamedMovable..  so Movable a => NamedMovable (Name a)
23:19:23 <goltrpoat> did that make sense?
23:22:51 <trh> Does anyone know how to change your password with NickServ?  I stuffed it up when registering...
23:24:34 <trh> Ahh, there's a help command...
23:28:02 <lisppaste2> metaperl annotated #32473 with "goltrpoat - I follow your reverse argument to here... I dont get your other comments at at" at http://paste.lisp.org/display/32473#3
23:29:05 <goltrpoat> any Name a is Named from fact 1
23:30:33 <metaperl> agreed
23:30:55 <treitter> is some part of the expression  'let pi = 3.14' specific to ghci (vs. hugs)?
23:30:57 <goltrpoat> so if you come up with an a such that Movable a, then Name a is both Movable and Named
23:32:05 <sjanssen> treitter: ghci and hugs expect syntax that is slightly different.  hugs is expressions only, where ghci is a modified "do" context
23:32:47 <treitter> sjanssen: ah. Which would you recommend to someone new to Haskell?
23:33:10 <dons> ghci :)
23:33:18 <dons> since it comes with ghc, which is a rather nice compiler
23:33:19 <goltrpoat> in other words.. we have some set of assertions that have to be satisfied in order for Name a to be Movable.  we have some (trivial) set of assertions that have to be satisfied in order for Name a to be Named.  in order for something to be both Movable *and* Named, we need to satisfy both sets of assertions, right
23:33:30 <sjanssen> treitter: both are fine.  I recommend typing your definitions into a file and then loading that from your interpreter
23:33:33 <dons> for when you want to rewrite all your apps in hskell ;)
23:33:50 <goltrpoat> in the first case, it's Movable a.  in the second case, it's nothing.  so, Movable a gives Named (Name a) and Movable (Name a)
23:33:57 <treitter> sjanssen: yup. That's what I'm doing now
23:34:25 <treitter> sjanssen: ..partly because hugs seems to only handle one-liners
23:34:35 <metaperl> almost there
23:34:57 <sjanssen> treitter: you have to use ; instead of newlines
23:35:04 <sjanssen> and { } instead of indenting
23:35:24 <treitter> sjanssen: ah. Gotcha
23:35:30 <metaperl> ah, yes
23:36:17 <sjanssen> treitter: but hugs and ghci aren't intended for entering full fledged code, they're more oriented towards inspecting how your code (written elsewhere) works
23:36:33 <treitter> sjanssen: yeah :)
23:37:01 <sjanssen> and don't feel bad, this is the biggest Haskell FAQ
23:40:26 <dons> I wonder what we can do to explain this better
23:40:34 <goltrpoat> metaperl:  so another way to look at it is to pick a Name a for some Movable a.  we know that Name a is Named, by fact 1.  we know it's Movable, by fact 2.
23:41:01 <dons> actualy start an FAQ page?
23:41:34 <metaperl> goltrpoat - I think you are reading fact 2 in reverse
23:41:59 <sjanssen> dons: I don't know.  Haskell seems to fit in a weird gray area.  You'd never expect any sort of interpreter for C, but any other language with an interpreter lets you dump any sort of code in it
23:42:01 <metaperl> Movable a implies Moveable (Name a) not vice versa as you just said
23:42:08 <goltrpoat> given an a such that Movable a, then Movable (Name a)
23:42:18 <metaperl> right
23:42:20 <goltrpoat> i think you're reading what i said in reverse :)
23:42:22 <dons> sjanssen: mmm. good point.
23:42:23 <sjanssen> dons: it is in the GHC FAQ IIRC
23:42:37 <metaperl> oh, yes
23:42:39 <metaperl> fine.
23:42:48 <treitter> sjanssen: ah, well, I know a bit of Python, so the idea that the interpretter is not an IDE was already pretty clear :)
23:43:04 <goltrpoat> sorry, should probably have been more clear about what i meant by "it" -- the last sentence should read "we know Name a is Movable, by fact 2"
23:43:32 <sjanssen> treitter: you can enter any source code into the python interpreter, right?
23:44:41 <treitter> I feel really dumb for asking this, but .. how do I convert from an Int -> String?        "putStrLn (5 -> String)" doesn't work as I'd expect (and several tutorials I've looked at only seem to mention type conversion from user input with reads
23:44:54 <trh> use hosw
23:44:56 <trh> use show
23:44:57 <trh> :)
23:45:01 <sjanssen> > show 5 -- like this treitter
23:45:03 <lambdabot>  "5"
23:45:11 <treitter> sjanssen: yeah. though the difference is that it doesn't require ; for new lines
23:45:16 <sjanssen> > read "5" -- and back again
23:45:17 <lambdabot>  Add a type signature
23:45:29 <treitter> sjanssen, trh: right :) Thanks
23:45:41 <trh> Ok, time to go.  After trying to get into IRC for 10 years and failing, this channel is the first time I've wanted to hang around.  See ya, chaps.
23:45:42 <metaperl> oh yeah, it's crystal clear now... given Movable a ... we know Movable (Name a) by Fact 2.
23:45:51 <goltrpoat> right
23:45:52 <Excedrin> cya trh
23:46:24 <sjanssen> treitter: there are additional restrictions with Haskell systems.  No data declarations, classes, instances, ...
23:46:24 <goltrpoat> and we always have Named (Name a)
23:46:28 <dons> > show 5.0
23:46:29 <lambdabot>  "5.0"
23:46:34 <dons> > read "5.0" :: Float
23:46:36 <lambdabot>  5.0
23:47:58 <goltrpoat> so..  now let b = Name a.  by fact 3, given any b that is both Movable and Named, we have NamedMovable b
23:48:03 <treitter> sjanssen: well.. there are classes. They just have a different meaning :)
23:48:29 <sjanssen> treitter: I meant that one can't define them at the interpreter
23:48:45 <treitter> sjanssen: ah. didn't know that
23:48:45 <goltrpoat> since we just set Name a, we have NamedMovable (Name a).  the only hypothesis we had was Movable a -- everything else was either trivially true, liked Named (Name a), or it was derived from Movable a, like Movable (Name a)
23:48:58 <goltrpoat> er.. liked=like
23:49:10 <goltrpoat> so, Movable a proves NamedMovable (Name a)
23:51:02 <metaperl> yes, asolutely. I got it by substitution
23:51:12 <metaperl> I'll write it up
23:51:14 <goltrpoat> coolness
23:53:50 <treitter> In a module, I have       let pi = 3.141592653589793\nlet r = 5      and ghci gives me "possibly incorrect indentation"
23:53:58 <treitter> do I need to do something at the end of a let line?
23:54:13 <sjanssen> treitter: omit let, probably
23:54:38 <sjanssen> you don't need it for top level declarations
23:54:55 <treitter> sjanssen: ah. Only within functions?
23:55:07 <ski> 'let' without 'in' is used in GHCi toplevel (and in 'do'-notation), not at toplevel of modules
23:55:09 <treitter> same reason you need "do" for multi-line functions?
23:55:13 <treitter> (or {})
23:55:19 <sjanssen> treitter: yes.  let ... in ... is an expression
23:55:34 <dancor> why doesn't ghci have more copy-and-paste compatability
23:55:37 <sjanssen> treitter: "do" is monadic syntax only
23:55:56 <treitter> sjanssen: not necessary for regular functions?
23:56:02 <dancor> i'm not a fan of having to define functions with let in ghci
23:56:16 <sjanssen> treitter: in general, never for regular functions
23:56:23 <treitter> sjanssen: cool
23:56:37 <sjanssen> dancor: Haskell's syntax is tricky with a line oriented interpreter
23:56:44 <Excedrin> "do" is never necessary...
23:57:03 <dancor> sjanssen: tricky, or impossible?  :)
23:57:33 <dancor> if it's just tricky, it must be done
23:57:42 <sjanssen> dancor: you'd probably need some special sigil to indicate the beginning and ending of a decl.
23:58:17 <kzm> @seen
23:58:17 <lambdabot> Lately, I have seen dancor, dons, excedrin, goltrpoat, kzm, metaperl, sjanssen, ski and treitter.
23:58:41 <treitter> also, I have        "putStrLn $ show pi", but the interpreter is complaining about line 10 (my code is only 9 lines long)
23:59:01 <ski> main = putStrLn $ show pi
23:59:09 <sjanssen> dancor: say :startedit\n f x = 10\n :endedit
23:59:10 <Excedrin> @paste
23:59:10 <lambdabot> http://paste.lisp.org/new/haskell
23:59:13 <treitter> ah. Right. Main :)
23:59:16 <kzm> treitter, incomplete structure? missing closing parenthesis or something like that?
23:59:54 <sjanssen> dancor: which really isn't an improvement over firing up your text editor and writing the code there
23:59:56 <Excedrin> is :startedit an alias for :edit ?
