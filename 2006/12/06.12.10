00:23:36 <zptao> dons is a nigger
00:25:02 * lispy wonders why that comment was made
00:25:28 * mathewm guesses someone stepped away from the keyboard with the wrong kind of people near by
00:25:54 <lispy> mathewm: i'm in an "ascribe to malice" mood :)
00:27:34 <sorear> IIRC zptao was banned recently.
00:29:07 --- mode: ChanServ set +o dons
00:29:08 --- mode: ChanServ set -o dons
00:29:16 --- mode: ChanServ set +o dons
00:29:21 --- mode: dons set +b *!*i=fififi@*.dsl.pltn13.pacbell.net
00:29:21 --- kick: zptao was kicked by dons (dons)
00:30:06 <sorear> it's crazy.  do these people actually think they are offensive?
00:31:11 <dons> yeah, its bizarre
00:31:14 --- mode: ChanServ set -o dons
00:36:14 --- mode: ChanServ set +o dons
00:36:18 --- mode: dons set -b *!*i=fififi@*.dsl.pltn13.pacbell.net
00:36:29 <dons> (use ChanServ instead)
00:36:31 --- mode: ChanServ set -o dons
00:36:46 <sorear> data Tuple k v where
00:37:00 <sorear>   TCons :: v -> Tuple k v -> Tuple (Succ k) v
00:37:10 <sorear>   TNull :: Tuple Zero v
00:37:25 <sorear> how do I write a replicate :: v -> Tuple k v ?
00:38:39 <bd_> that's not a valid data definition
00:39:02 <bd_> data Tuple k v where TCons v (Tuple k v) | TNull ? If so, where does k go?
00:39:04 <dons> looks like a GADT to me
00:39:17 <bd_> ?
00:39:34 <dons> data Tuple k v where ... is generalised algebraic data type syntax
00:39:47 <lispy> dons: yes, but i think bd_ may have a point still
00:40:03 <lispy> a type variable is missing from the last line?
00:40:03 <dons> yeah, it could still be invalid :)
00:41:13 <sorear> GHCi says it is valid, and yes I am taking advantage of GADT features (notice that the Peano numeral argument is the length of the tuple)
00:41:43 <bd_> *reads wikibooks/GADT*
00:41:48 <sorear> my problem is I cannot figure out how to write pure (for Applicative instance)
00:43:10 <sorear> I suspect part of the issue is e.g (pure :: Int -> Tuple Int Int). Int is not a peano-number, so no combination of constructors can build a Tuple Int Int, thus I cannot have a parametrically polymorphic replicate.
00:43:48 <sorear> I can see doing this with associated data types, but GADTs are much more mainstream and seem like they should be able to do the job.
00:52:21 <dons> GADTs are only a couple of years old in ghc though :) if that
00:52:34 <dons> (I've never seen GADTs referred to as mainstream before :)
00:52:37 <dons> its great!
00:59:50 <vincenz> Hi
01:00:14 <sorear> pong.
01:00:53 <tessier_> ping.
01:06:01 <Eidolos> slime_mold: NetHack fan eh? :)
01:06:23 <slime_mold> yes :)
01:06:45 <Eidolos> You should join #nethack
01:07:04 <slime_mold> alright
01:07:55 <sorear> It is suprising the level of overlap between these massively disparate communities.  As a formerly active member of the NetHack-wikia (Stefanor), I did a minor double-take with <Eidolos>.
01:08:11 <Eidolos> :)
01:09:55 <dons> hehe
01:10:00 <dons> that's cool
01:10:14 <dons> a bit like the weird unicycle/haskell and lojban/haskell overlap
01:11:08 <lispy> i would expect "slime_mold" to be angband
01:11:48 <sorear> slime_mold is Rogue.  Rogue begot Moria and Hack.  Hack begot NetHack.  Moria begot Angband.
01:11:52 <Eidolos> "My, that was a yummy slime mold!" is straight out of NetHack.
01:12:08 <Eidolos> (I suppose other roguelikes use that wording as well, but I'm most familiar with NH)
01:12:28 <sorear> (of course, the Debian folks have changed the defaults: My, that was a yummy potato!)
01:12:43 <Eidolos> Yuck :)
01:12:54 <Eidolos> WeaselHack
01:13:58 <vincenz> dons: got my message?
01:14:49 <dons> vincenz: about solar cells?
01:14:58 <dons> did you mean the unsw solar cell researchers?
01:15:03 <vincenz> Indeed :)
01:15:06 <vincenz> you're at unsw no?
01:15:17 <dons> yep. just across from the photovoltaic lab :)
01:15:31 <dons> we have little monuments to photovoltaic cells around the campus, in fact :)
01:15:34 <vincenz> There was an article on SA and until recently UNSW had been best
01:15:45 <vincenz> dons: they must know our company then, we do solar cells too
01:15:58 <dons> actually, that probably explains the solar car the cse guys program
01:16:06 <dons> oh, nice
01:18:23 <vincenz> nice article btw :)
01:22:42 <sorear> I've got the associated-types homogeneous tuples working:
01:22:54 <sorear> http://members.cox.net/stefanor/Tuple.hs
01:29:40 <vincenz> sorear: explain it?
01:29:47 <vincenz> data Tuple :: * -> *
01:31:21 <sorear> that, in a class, is an 'associated data type declaration'.  It is a new feature in GHC-development.  Documented on the:
01:31:28 <sorear> ?wiki GHC/Indexed_types
01:31:29 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Indexed_types
01:32:13 <vincenz> what advantage over MPTC?
01:33:57 <dons> they're an alternative to functional dependencies
01:34:06 <vincenz> ah I see
01:34:24 <dons> and I guess they might make for a replacement for MPTCs (where you want to hide a local state?) -- but you'd need FDs there anyway
01:34:28 <vincenz> they seem to span the same possibilities
01:34:55 <vincenz> sorear: so specifically your tuples are a) same-sized (hence tuples) and b) homogeneous
01:34:57 <dons> yeah, but a bit easier to understand than FDs (since they're not prolog programming ;)
01:35:02 <vincenz> sorear: or i.o.w fixed-size lists
01:35:21 <vincenz> correct me if I'm wrong :)
01:36:02 <sorear> vincenz: Yes. exactly.
01:36:30 <sorear> vincenz: I need fixed sized lists for vectors.
01:36:50 <paolino> morning, can you  explain me why the name runState for the State accessor ?
01:37:27 <vincenz> sorear: what about using a hidden data-constructor "Tuple Int [a]"
01:38:04 <sorear> It's a dirty hack: runState is what you would call a function for running a state-action, so they arrange things such that run-state is actually the constructor. Ideally this would be hidden, and runState would appear as just another function.
01:38:33 <vincenz> sorear: agreed :)
01:38:41 <sorear> vincenz: That would work (infact it is what I did first), but it has a couple of drawbacks.
01:39:24 <sorear> You can't specialize a Tuple Int [a] for the common cases of 2- or 3-vectors.
01:39:35 <sorear> You can
01:39:37 <vincenz> Well sure, you have less-type-level-certainty, but once your lib is designed you're guaranteed correctness by interface
01:39:40 <vincenz> Ah I see
01:40:02 <vincenz> sorear: Nor can you in your case unless you use overlapping
01:40:04 <sorear> 't have the compiler unroll loops, because the compiler can't know the relationship
01:41:34 * vincenz nods
01:58:38 <vincenz> Wow
01:58:41 <vincenz> a hosting site with haskell support
02:00:23 <chr1s> vincenz: what do they exactly support?
02:00:30 <vincenz> 6.4.2
02:01:27 <vincenz> the only thing I don't like about it is that you pay per GB bandwidth
02:01:33 <vincenz> so if someone decides to spam you, you're f*cked
02:02:40 <kosmikus> dufflebunk, dons: I should finally re-release lhs2TeX. Removing -package lang should work though.
02:03:46 <dons> sorear: hehe I wrote the same code.
02:03:52 <dons> kosmikus: ah good (it did, I think)
02:04:54 <sorear> dons: assoc type tuples?
02:05:34 <dons> sorear: the mailing list guy
02:05:38 <dons> (about cat)
02:07:34 <vincenz> chr1s: https://www.nearlyfreespeech.net/services/hosting.php#pricing
02:07:45 <vincenz> http://example.nfshost.com/versions.php even
02:07:51 <lambdabot> Title: Versions of CGI Languages
02:08:16 <dons> hehe. 4th person who's posted that today :)
02:08:21 <dons> pretty cool stuff
02:08:59 <vincenz> the only downpart: 1$/GB
02:09:17 <vincenz> in fact, the bandwidth is the major cost-factor
02:09:23 <vincenz> which is rather dangerous
02:10:40 <mq_mattr> am I seeing a market for haskell cgi hosting?
02:10:57 <mq_mattr> for less than $1/GB I guess
02:11:06 <mq_mattr> How much does this stuff normally go for?
02:11:42 <vincenz> normally it's not bandwidth
02:12:02 <mq_mattr> they call it "only pay for what you use" pricing, but surely it is "pay so other people can use" pricing
02:12:05 <mq_mattr> ?
02:12:57 <vincenz> pay for what we spam in accesses :P
02:13:03 <sorear> My ISP offers 10MB of space, for free.
02:13:14 <vincenz> my ISP gives unlimited space
02:13:18 <vincenz> 15 euro/month
02:13:22 <vincenz> well not my ISP
02:13:26 <vincenz> the provider I use for a website
02:13:32 <sorear> Don't expect posted URL's from my to stay valid very long :)
02:13:51 <mq_mattr> these guys are web hosts, not isps right?
02:13:55 <vincenz> yes
02:14:00 <vincenz> I meant my webhost, not my isp
02:14:08 <vincenz> isps tends to suckfor this
02:14:18 <mq_mattr> agreed
02:14:38 <vincenz> well I use uni, but that's sort of the same as isp (except at least I have shell login), no CGI or anything dynamic whatsoever
02:15:03 <mq_mattr> yeah - the uni does all my hosting duties for me as well
02:15:14 <mq_mattr> but I need an ISP at home
02:15:18 <vincenz> the webhost I used was 15 euro/year, unlimited storage, cgi etc. But: only ftp access (so hard to install something) and rather slow link
02:15:30 <vincenz> mq_mattr: likewise
02:15:38 <vincenz> i just don't use the space
02:16:02 <mq_mattr> other ausssies will know my pain - no ADSL, only cable, $75 per month :(
02:16:24 <vincenz> cable is good here
02:16:25 * vincenz has cable
02:16:30 <vincenz> I can download at 1MB/s
02:16:32 <vincenz> not the big B
02:16:36 <vincenz> note even
02:16:54 <mq_mattr> I get 256K, or 512 maybe
02:17:12 <vincenz> and this new one I have, no bandwidth limitation afaict
02:17:13 <sorear> On a good day, I have 5 Mbits/s
02:17:22 <vincenz> (even when I download like 20 movies in a week)
02:17:30 <mq_mattr> cable is the best, but I don't even have the option of anything else and they charge like wounded bulls for it.
02:17:32 <vincenz> grr, firefox
02:19:09 <vincenz> ah, here it is: downstream: 10Mbps, upstream 512kbps, 40GB/month, 45.86 euro/month
02:20:22 <bpt> hcoop.net (a hosting cooperative) supports Haskell too (I just wrote my first Haskell program on the server :))
02:22:23 <vincenz> a lambdabot-like system for web-hosting would be great
02:22:29 <vincenz> to limit cpu
02:34:46 <mq_mattr> vincenz: see, we just get shafted over here
02:34:58 <mq_mattr> we must have the worst broadband in the developed world.
02:36:30 <mq_mattr_> I should point out that I am in Sydney, the biggest city in the country and I can't get better than 512k in my home.  What you are describing would be hundreds of dollars per month, *if* it were available
02:38:47 <vincenz> :/
02:39:01 <mq_mattr_> indeed, 'tis quiet
02:41:44 <dons> ?yow!
02:41:45 <lambdabot> over in west Philadelphia a puppy is vomiting ...
02:41:58 <mq_mattr_> what the?
02:42:08 <mq_mattr_> how do you get him to do that?
02:42:10 <dons> mq_mattr_: don't we have 8M broadband now (I'm sure I saw telstra adds to that effect)
02:42:27 <dons> (though I've got 512k wireless to my house ... :/ ) ah well
02:42:28 <mq_mattr_> serious?
02:42:35 <mq_mattr_> II will ket me some of that
02:42:39 <mq_mattr_> get
02:42:50 <dons> pretty sure, this new dslam broadband 2 thingy :)
02:43:03 * dons hunts for clues
02:43:29 <dons> mq_mattr_: http://whirlpool.net.au/
02:43:30 <lambdabot> Title: Whirlpool - Australian Broadband News
02:43:53 <mq_mattr_> ahh, whirlpool.  While I wait for bigpond site to load
02:44:14 <mq_mattr_> up to 20Mbps
02:44:37 <dons> sweet
02:45:08 <mq_mattr_> the site is terrible
02:45:54 <mq_mattr_> hmm, how can I test what speeds I am actually getting?
02:46:27 <dons> here, http://www.ozspeedtest.com/tools_speed.shtml
02:46:28 <lambdabot> Title: Oz Broadband Speed Test
02:47:29 <dons> so i'm currently getting kbps: 242.61 over unwired :| (it usually around 400 kbps, but the weather's bad this weekend for some reason)
02:47:53 <mq_mattr_> ohh, I think I have been unfair to old telstra
02:48:05 <mq_mattr_> 2389.74kbps
02:48:12 <xerox> dons, how does exactly work the data deriving
02:48:19 <mq_mattr_> I just checked my contract (a few years old) and it says 256
02:48:31 <xerox> like data Foo a = Foo { bar :: a, baz :: (a,a) }
02:48:32 <mq_mattr_> I guess they have upgraded me :)
02:48:37 <xerox> deriving (Show, Eq)
02:48:40 <mq_mattr_> telstra is my new best friend
02:49:07 <xerox> the compiler actually makes assumptions on how to show a record, and how to equate it, right?
02:49:15 <mq_mattr_> yep
02:49:29 <mq_mattr_> types in Haskell follow a simple pattern
02:49:43 <mq_mattr_> so the compiler can always equate them with a simple scheme
02:49:50 <xerox> and what about show?
02:50:00 <mq_mattr_> it can also show them with a similarly simple scheme
02:50:15 <xerox> I also think it makes assumptions, but I couldn't find the code....
02:50:28 <mq_mattr_> it only works because the *same code* can work to equate and show *all* data types.
02:50:29 <kosmikus> xerox: what do you mean, assumptions?
02:51:04 <mq_mattr_> this is built into the compiler because you can not express it in Haskell, but you can in Generic Haskell
02:51:11 <xerox> kosmikus: where he gets "{" ++ show a ++ ", " ++ show b ++ ", " ++ ... ++ " }" from
02:51:15 <mq_mattr_> or any other data type generic approach
02:51:54 <kosmikus> xerox: yeah, there's an informal specification in the report, and the actual functionality is hard-coded in the compiler
02:52:10 <kosmikus> xerox: if you want real definitions, you need generic programming, just as mq_mattr_ said
02:52:13 <xerox> paolino: -^
02:52:18 <xerox> danke.
02:52:48 <mq_mattr_> warning: datatype generics is not trivial
02:52:54 <mq_mattr_> it is not super hard either
02:53:07 <mq_mattr_> like most advanced haskell things I s'pose :)
02:53:15 <xerox> (:
02:53:45 <mq_mattr_> if you are trying to do your own "deriving" clause
02:53:49 <mq_mattr_> don't bother
02:53:59 <mq_mattr_> unless you have a really good reason
02:55:00 <xerox> alright
02:55:40 * paolino gets back his rants
02:58:48 <vincenz> xerox == paolino
02:58:52 <vincenz> > True
02:58:53 <lambdabot>  True
02:59:22 <mq_mattr_> > sequence [putStrLn "done"]
02:59:23 <lambdabot>  <IO [()]>
02:59:41 <astrolabe> xerox's first name is paolino, but I've seen him talking to paolino here
02:59:52 <Syzygy-> Oooooooh. Someone made lambdabot not insult users on IO!
02:59:53 <lambdabot> Syzygy-: You have 1 new message. '/msg lambdabot @messages' to read it.
03:00:41 <mq_mattr_> syzygy: huh?
03:00:53 <xerox> > "xerox" /= "paolino"
03:00:55 <lambdabot>  True
03:01:13 <xerox> mq_mattr_: it used to barf some insult, that is, "No IO allowed!"
03:01:27 <mq_mattr_> ah
03:01:33 <Heffalump> > const "someone" "xerox" == const "someone" "paolino"
03:01:34 <lambdabot>  True
03:01:38 <mq_mattr_> I was just seeing what it did for IO
03:01:44 <xerox> that's mean :/
03:01:48 <mq_mattr_> that is actually my first lambdabot interacation
03:02:16 <xerox> ShowQ.hs madness I believe
03:04:13 <paolino> > "xerox" > "paolino"
03:04:14 <lambdabot>  True
03:04:35 <astrolabe> > ("xerox" ==) == ("paolino" ==)
03:04:36 <dons> mq_mattr_: yeah, I tend to not feel too comfortable about allowing unrestricted IO on my desktop :}
03:04:37 <lambdabot>  add an instance declaration for (Eq ([Char] -> Bool))
03:04:37 <lambdabot>   In the definition...
03:04:39 <xerox> AH.
03:04:46 <astrolabe> even lambdabot doesn't know
03:04:49 <dons> > readFile "/etc/passwd"
03:04:51 <lambdabot>  <IO [Char]>
03:05:06 <dons> hooray for static typing, and monads
03:05:19 <mq_mattr_> too right
03:05:23 <xerox> > let p = readFile "/etc/passwd" in seq p p
03:05:25 <lambdabot>  <IO [Char]>
03:05:59 <Syzygy-> Hey... This looks neat.
03:06:03 <Syzygy-> @hoogle deleteFile
03:06:04 <mq_mattr_> how can we use dependent types to get the contents of /etc/passwd into the tye info returned?
03:06:04 <lambdabot> System.Win32.File.deleteFile :: String -> IO ()
03:06:04 <lambdabot> System.Win32.File.c_DeleteFile :: LPCTSTR -> IO Bool
03:06:11 <Syzygy-> @hoogle removeFile
03:06:12 <dons> heh
03:06:12 <lambdabot> Directory.removeFile :: FilePath -> IO ()
03:06:14 <Syzygy-> Ah.
03:06:21 <Syzygy-> > removeFile "/etc/passwd"
03:06:22 <lambdabot>  Not in scope: `removeFile'
03:06:26 <Syzygy-> Oh bugger. :)
03:06:38 <Syzygy-> > Directory.removeFile "/etc/passwd"
03:06:40 <lambdabot>  Not in scope: `Directory.removeFile'
03:06:44 <Syzygy-> Ok. I'll stop now.
03:06:45 <xerox> Harakiri?
03:06:57 <Syzygy-> xerox: Nono... This is all on dons desktop. Not on mine. ;)
03:07:06 <psnl> writeFile is the way to do it
03:07:15 <xerox> I thought you wanted to have lambdabot erase herself!
03:07:25 <Syzygy-> That's also a neat idea.
03:08:16 <paolino> static typing + monads -> sandbox ?
03:08:22 <mq_mattr_> dons' a braver man than I letting us play like this :)
03:08:41 <mq_mattr_> or perhaps just has greater faith in the gods of static typing
03:08:58 <paolino> mmhh or he jailed the lambdabot
03:09:09 <paolino> via OS
03:09:36 <psnl> > writeFile "hello" "/tmp/testing"
03:09:38 <lambdabot>  <IO ()>
03:10:05 <mq_mattr_> psnl: problem is, we can't tell what happened
03:10:24 <psnl> yeah, he could just be dumping out the right types
03:11:02 <wilx> > do writeFile "hello" "/tmp/testing"
03:11:03 <lambdabot>  <IO ()>
03:11:13 <vincenz> o.O
03:11:30 <dons> its not evaluating it :)
03:11:30 <vincenz> > readFile "/tmp/testing"
03:11:32 <lambdabot>  <IO [Char]>
03:11:42 <mq_mattr_> @destroyThySelf
03:11:43 <lambdabot> Unknown command, try @list
03:11:55 <vincenz> @format dons's hd -rf
03:11:56 <lambdabot> Unknown command, try @list
03:12:13 <mq_mattr_> now this is getting silly :)
03:12:22 <psnl> dons: aww, I was just trying to remember how to do network commands ;-)
03:12:27 <dons> what happens in the end is the (unevaluated) IO action is passed to show, and the instance is invoked:
03:12:30 <dons> instance Typeable a => Show (IO a) where
03:12:33 <dons>     show e = '<' : (show . typeOf) e ++ ">
03:12:53 <vincenz> yes ok, but it's in the main-path
03:13:02 <vincenz> so hwo come it does not get evaluated
03:13:10 <mq_mattr_> ?Typeable
03:13:11 <lambdabot> Unknown command, try @list
03:13:15 <mq_mattr_> @list
03:13:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:14:00 <mq_mattr_> what the heck is at the other end of that link?
03:14:16 <Syzygy-> mq_mattr_: A list of the commands that lambdabot accepts.
03:14:18 <mq_mattr_> I could have guessed that bf provides bf :)
03:14:22 <Syzygy-> It's a pure textfile.
03:14:34 <dons> vincenz: its not demanded. the Typeable dictionary is inspected again
03:14:43 <dons> you may as well pass in (undefined :: IO ())
03:14:48 <dons> > undefined :: IO ()
03:14:49 <lambdabot>  <IO ()>
03:14:53 <dons> not evaluated :)
03:14:53 <Syzygy-> > (undefined :: IO Integer)
03:14:55 <lambdabot>  <IO Integer>
03:15:00 <mq_mattr_> what is this Typeable dictionary?
03:15:03 <Syzygy-> > (undefined :: IO (IO Integer))
03:15:05 <lambdabot>  <IO (IO Integer)>
03:15:08 <Syzygy-> o.O
03:15:13 <dons> mq_mattr_: used in the show instance to print that string
03:15:34 <mq_mattr_> it looks like reflection
03:15:39 <psnl> uh, does happy build with ghc6.6?
03:15:44 <mq_mattr_> something I thought I had to live without in Haskell
03:16:07 <dons> mq_mattr_: yep :)
03:16:28 <mq_mattr_> sweet - how do you make that work then?
03:16:38 <mq_mattr_> you can't derive Typeable ?
03:17:09 <dons> the only things we show specially are functions and IO
03:17:31 <Syzygy-> > (+)
03:17:33 <lambdabot>  Add a type signature
03:17:34 <dons> so if you try something that doesn't derive Typeable, and is a function, or is the result of IO, you'll just get a 'no such method' error
03:17:36 <mq_mattr_> functions because you have to and IO because you short-circut its evaluation right?
03:17:39 <dons> > ord
03:17:40 <lambdabot>  <Char -> Int>
03:17:44 <dons> functions because its fun
03:17:46 <Syzygy-> > (+) :: Integer -> Integer -> Integer
03:17:48 <lambdabot>  <Integer -> Integer -> Integer>
03:18:10 <Syzygy-> Hey.... This means lambdabot can show me type signatures quickly. Neat!
03:18:15 <Syzygy-> > (+3::Integer)
03:18:16 <lambdabot>  Parse error
03:18:21 <Syzygy-> > (+(3::Integer))
03:18:21 <dons> yeah, we used to just not have a show method for IO at all, so whenever tried to use IO instead yo ugot "no such method: Show IO" errors instead
03:18:23 <lambdabot>  <Integer -> Integer>
03:18:44 <Syzygy-> I remember the time when you'd get called a pervert instead.
03:18:49 <dons> now we have a dummy instance instead, that just prints the type. same effect though: do something other than evaluate the IO
03:18:56 <mq_mattr_> dons: can't say I understand  - how does a function get into the Typeable class?
03:18:58 <vincenz> > 1
03:18:59 <lambdabot>  1
03:19:01 <vincenz> > undefined
03:19:02 <lambdabot>  Add a type signature
03:19:04 <vincenz> > undefined :: IO ()
03:19:06 <lambdabot>  <IO ()>
03:19:10 <vincenz> > undefined :: Int
03:19:12 <lambdabot>  Undefined
03:19:17 <dons> mq_mattr_: like so:
03:19:18 <dons> instance (Typeable a, Typeable b) => Show (a -> b) where
03:19:18 <dons>     show e = '<' : (show . typeOf) e ++ ">"
03:19:32 <Syzygy-> > typeOf (undefined :: Int)
03:19:33 <lambdabot>  Int
03:19:40 <Syzygy-> > typeOf (undefined :: Maybe Either Int Int)
03:19:41 <lambdabot>    Kind error: `Maybe' is applied to too many type arguments
03:19:41 <lambdabot>   In the typ...
03:19:45 <mq_mattr_> ahhh  of course, but how do all the other types get into Typeable?
03:19:46 <astrolabe> Are arrows actually harder to understand than monads? or just less familiar?
03:19:47 <Syzygy-> > typeOf (undefined :: Maybe (Either Int Int))
03:19:49 <lambdabot>  Maybe (Either Int Int)
03:20:03 <Syzygy-> astrolabe: I find arrows obvious and neat. They're just categorical morphisms.
03:20:07 <mq_mattr_> astrolable: less familiar
03:20:18 <astrolabe> thanks
03:20:21 <mq_mattr_> syzygy: funny
03:20:35 <paolino> where monads are familiar ?
03:20:36 <dons> mq_mattr_: ah they're derived in the standard libs
03:20:46 <dons> (you can derive Typeable these days)
03:20:55 <mq_mattr_> cool - thanks for that
03:21:05 <mq_mattr_> my type system has been enriched tonight
03:21:10 <dons> heh
03:22:25 <paolino> will arrow get their special syntax ?
03:22:38 <mq_mattr_> paolino: it already has one
03:22:46 <mq_mattr_> I think it is something like
03:22:47 <kosmikus> I think arrows are harder to understand because there are fewer obvious examples of their usefulness in Haskell.
03:23:01 <mq_mattr_> blah <- something -< else
03:23:12 <mq_mattr_> kosmikus: agreed
03:23:28 <paolino> under the do notation ?
03:23:43 <mq_mattr_> i think they have a different keyword
03:23:47 <mq_mattr_> but it is similar
03:23:48 <kosmikus> proc
03:24:19 <mq_mattr_> http://web.mit.edu/ghc/www/users_guide/arrow-notation.html
03:24:20 <lambdabot> Title: 7.7. Arrow notation
03:25:11 <Syzygy-> mq_mattr_: I didn't say it as a joke. I said it because I meant it.
03:25:37 <Syzygy-> Arrows are, really, just a Haskell syntax put on top of the categorical concept of a morphism; which is one I know and am comfortable with.
03:25:53 <mq_mattr_> categorical morphisms are obvious ?
03:26:03 <Syzygy-> Well, yeah.
03:26:18 <kosmikus> arrow notation will most likely not be in Haskell', though
03:26:21 <mq_mattr_> goodness me, you have a better brain than I
03:27:13 <mq_mattr_> I got about 20 pages through Pierce's category theory for computer scientists before I completely filled up my brain :0
03:27:15 <Pupeno> Good morning.
03:27:15 <mq_mattr_> :)
03:27:19 <paolino> kosmikus I find ghc and huges incompatilble most of the times
03:27:41 <vincenz> mq_mattr_: likewise
03:27:46 <mq_mattr_> Well, not fill it up, put there is only so much abstraction I can take and I don't have the required maths background
03:27:59 <mq_mattr_> thank goodness for those who do though
03:28:18 <xerox> paolino: ask newsham for his arrow-syntax tutorial
03:28:38 <astrolabe> I'm sure arrows are actually harder than categorical morphisms.  morphisms have no internal structure, and just obey a couple of composition rules.
03:29:16 <integral> arrows appear to need product categories for a start
03:29:18 <mq_mattr_> astrolabe: see, that is what is so frustrating, the rules are so simple in category theory, but the consequences are mind bending
03:30:12 <kosmikus> I think that "idioms" are more useful than arrows for Haskell.
03:31:01 <mq_mattr_> kosmikus: arrows have not taken over the world, but I think they have a role in allowing simple notation for some dsls that can't fit in a monad
03:33:07 <kosmikus> possibly, but most applications of arrows I could think of in the past have turned out to be idioms
03:33:37 <mq_mattr_> yeah, you are probably right
03:33:52 <vincenz> mq_mattr_: what do you do
03:33:54 <mq_mattr_> on that, what exactly do you mean by idiom?
03:34:24 <kosmikus> mq_mattr_: Control.Applicative
03:34:30 <mq_mattr_> phd in programming languages, lecturer in computing and IT, Macquarie University
03:34:40 <vincenz> mq_mattr_: what's your subject on
03:34:46 <vincenz> specifically
03:34:55 <mq_mattr_> efficient implementation of the pattern calculus
03:35:02 <kosmikus> mq_mattr_: the "applicative functors" have originally been named "idioms" by Conor McBride. I still use the old name, sorry.
03:35:18 <kosmikus> mq_mattr_: Barry Jay's pattern calculus?
03:35:28 <mq_mattr_> kosmikus: yep
03:35:31 <dons> the 'idioms' name is a bit unintuitive, I think, though.
03:35:39 <kosmikus> dons: I like it.
03:35:54 <mq_mattr_> it's meaning is overloaded
03:35:56 <dons> i guess 'monad' is even worse :}
03:36:06 <mq_mattr_> and you can't tell from context which one you are using
03:36:14 <kosmikus> mq_mattr_: cool. I'd like to talk to you in more detail sooner or later.
03:36:17 <mq_mattr_> it needs a type class
03:36:21 <vincenz> mq_mattr_: tell me a bout pattern calculus?
03:36:29 <mq_mattr_> kosmikus: anytime, I love talking about this stuff
03:36:34 * vincenz isn't a CS-grad
03:36:40 <vincenz> EE :)
03:36:55 <kosmikus> mq_mattr_: ok. right now I have to go. see you around ...
03:36:56 <mq_mattr_> vincenz: it is like the lambda calc, but it lifts data and patterns to first class citizens
03:37:04 <mq_mattr_> kosmikus: see ya
03:37:20 <vincenz> mq_mattr_: oic
03:37:27 <vincenz> is that typeable?
03:37:42 <mq_mattr_> vincenz: this has good consequences in terms of opening up the space for generic programming and programming hetrogenous data
03:37:53 <mq_mattr_> vincenz: yep - in a system-f like way
03:38:24 <mq_mattr_> there is a paper describing the type system somewhere
03:38:34 <vincenz> I'd be interested to take a look, just to broaden my horizon
03:38:49 <ex0r> if I have a list of tuples, whats the syntax to match fst x to the fst of one of the tuples, and extract the second part of the tuple?
03:38:56 <ex0r> its confusing me for some reason
03:39:35 <vincenz> foo ((a,b):xs)
03:39:59 <mq_mattr_> vincenz:  I am afriad there is no easy reading on the pattern calc, but Barry has many papers at http://www-staff.it.uts.edu.au/~cbj/
03:40:11 * vincenz nods
03:40:19 <mq_mattr_> go for the later ones as the calculus is still a moving (improving) target
03:40:48 <vincenz> I found that site on google earlier, but it seems to be ... hanging
03:41:09 <pzpz> ex0r: or, just (x:xs)
03:41:23 <hmich> why doesn't System.Cmd.system return output of the program?
03:41:25 <mq_mattr_> curious
03:41:39 <mq_mattr_> hmich: because it is not stdout
03:41:41 <ex0r> ok thanks
03:41:57 <pzpz> ex0r: findsnd n (x:xs) | fst x == n = snd x | otherwise = fp n xs
03:42:05 <hmich> mq_mattr_: can you please explain?
03:42:27 <mq_mattr_> running a program will just "put it in motion"
03:42:27 <arcatan> hey, how do I round doubles?
03:42:45 <mq_mattr_> it is then up to the program to "do its thing" outputting whatever and wherever it wants
03:42:52 <hmich> so to get it's output one needs to create a temp file?
03:42:53 <arcatan> oh wait, I don't want to round them
03:42:54 <mq_mattr_> typically this output goes to stdout
03:43:03 <mq_mattr_> so to get it, you need to tap stdout and read it.
03:43:17 <vincenz> probably buffering
03:43:18 <mq_mattr_> I normally just send it to a temp file as you suggest
03:43:21 <mq_mattr_> but
03:43:30 <mq_mattr_> beware the temp file and lazy IO !
03:43:33 <vincenz> mq_mattr_: that site times out
03:44:00 <xerox> hmich: use runCommand or what is called...
03:44:02 <mq_mattr_> vincenz: strange, it works for me.  I will give you a link in to a more specific page, hang on.
03:44:03 <xerox> ?hoogle runCommand
03:44:04 <lambdabot> System.Process.runCommand :: String -> IO ProcessHandle
03:44:09 <pzpz> I have a data constructor, ie. data MyData = MyData { foo :: Foo, ... }
03:44:21 <xerox> ?docs System.Process
03:44:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
03:44:23 <xerox> see there
03:44:31 <pzpz> and later on, I try to construct a MyData, yet  it says the constructor MyData is not in scope.
03:44:59 <mq_mattr_> and now it is timing out
03:45:08 <mq_mattr_> looks like UTS is having some issues
03:45:11 <pzpz> which is a little hard to beleive, since it's directly above my statement.
03:45:12 <hmich> mq_mattr_: what do you mean by tapping stdout?
03:45:28 * vincenz nods
03:45:45 <mq_mattr_> well, I don't really know how to do it, but i mean getting access to whatever stdout is getting
03:45:56 <hmich> ah thanks
03:45:59 <mq_mattr_> as I say, I just dump to a temp file normally
03:46:00 <hmich> System.Process does the thing
03:47:44 <dons> use System.Process.run*Process
03:47:55 <dons> ?hoogle runInter
03:47:55 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
03:47:55 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
03:48:15 <dons> (there's some nice wrappers for this floating around, they should get merged in)
03:52:48 <mq_mattr_> hey peeps: any podcast suggestions
03:53:04 <mq_mattr_> I had some fun listening to some ITConverstions, but I have run out of them
03:53:12 <mq_mattr_> damn my spelling is tops
03:53:30 <pzpz> You've lost _all_ credibility.
03:53:44 <mq_mattr_> pzpz: I had credibility?
03:54:00 <mq_mattr_> I did say *some* and I did say *fun*
03:54:09 <xerox> mq_mattr_: science podcast, the scientific american one, nasacast video, scienze @ nasa
03:54:13 <astrolabe> xerox gave me a load yesterday, but they are more about science/maths.  Interested?
03:54:18 <pzpz> Those are totally good words.
03:54:20 <xerox> yeah (:
03:54:23 <astrolabe> Ah.  Bad timing :)
03:54:41 <xerox> go on, I missed some
03:54:52 <mq_mattr_> guido van whatshisname was fun, particularly his comments on "self."
03:55:01 <mq_mattr_> astrolabe: yay
03:55:02 <vincenz> rossum
03:55:05 <psnl> mq_mattr_: good/bad?
03:55:06 <astrolabe> xerox: http://www.bbc.co.uk/radio4/inourtime/
03:55:06 <astrolabe> [14:12] xerox: http://www.nasa.gov/rss/NASAcast_vodcast.rss
03:55:06 <astrolabe> [14:12] xerox: http://broadband.wgbh.org/nova/rss/nova-podcast-it.xml
03:55:06 <astrolabe> [14:13] xerox: http://science.nasa.gov/podcast.xml
03:55:06 <astrolabe> [14:13] xerox: http://www.sciencemag.org/rss/podcast.xml
03:55:06 <astrolabe> [14:13] xerox: http://www.sciam.com/podcast/sciam_podcast_i.xml
03:55:09 <lambdabot> Title: BBC - Radio 4 In Our Time - Home Page
03:55:14 <mq_mattr_> rossum - that's the one
03:55:24 <xerox> the first one is awesome
03:55:32 <psnl> mq_mattr_: I find self. to be very annoying, so I'm wondering what he thinks
03:55:35 <astrolabe> I listen to that sometimes
03:55:44 <vincenz> mq_mattr_: where
03:55:48 <xerox> check out the issues on te speed of light, on poincare' onjecture, and on anarchism....
03:55:50 <mq_mattr_> psnl: you mean the guido podcast? it was bad, in that the guy doens't have a clue, but good in that it was enoightening to his pov
03:55:52 <xerox> *the
03:56:07 <mq_mattr_> thankyou astrolabe
03:56:26 <astrolabe> It is presented by a humanities type.  He tries to follow the technical subjects, but I think he doesn't stand a chance.
03:57:19 <xerox> oh, and the one un altruism is very interesting
03:57:41 <mq_mattr_> http://www.itconversations.com/shows/detail545.html
03:57:43 <lambdabot> Title: IT Conversations: Guido van Rossum (part 1)
03:57:46 <mq_mattr_> I think that is the one
03:57:52 <astrolabe> That doesn't really interfere with the experts statements though
03:58:02 <mq_mattr_> though I think his comments on "self." were in part two
03:58:08 <xerox> the egoist DNA
03:58:11 <psnl> thnaks
03:58:16 <xerox> ..theory
03:58:22 <mq_mattr_> in short, when someone asked about it, he said he had never noticed it as a problem
03:58:23 <astrolabe> Is self.  about reflection?
03:58:41 <mq_mattr_> astrolabe: nope, in python
03:58:41 <xerox> lunch! laters...
03:58:59 <mq_mattr_> if you just call a variable and it does not exist
03:58:59 <mq_mattr_> it is created
03:59:15 <mq_mattr_> to access globals, you need to say self.variableName
03:59:42 <mq_mattr_> otherwise a new variable in the inner scope is created and you are not working with the global as you thougt
04:00:04 <mq_mattr_> so, whenever people program classes, they always forget to self. for any class properties
04:00:09 <mq_mattr_> and code never works ever
04:00:12 <astrolabe> mq_mattr_: should I say 'yuk' at this point?
04:00:20 <psnl> its a pita, since a method looks like def hello(self, name)
04:00:24 <mq_mattr_> astrolabe: too right
04:00:31 <paolino> my view of monads (wrong probably) is  "metaprogramming the function composition" .Are arrows anyway similar ?
04:00:32 <wilx> Heh, this is one of the parts of Python I hate.
04:00:40 <psnl> but is called with object.hello('bob")
04:01:29 <mq_mattr_> paolino: yeah, where Monads represent computation, Arrow represent something else (like computation, but I can't quite recall what)
04:01:53 <mq_mattr_> everyone hates self-dot and somehow, guido had no idea it was a problem
04:02:08 <mq_mattr_> that is why I found that talk enlightening
04:02:39 <mq_mattr_> it made me realise that languages built under a benevolent dictator are probably not desirable
04:02:47 <mq_mattr_> despite the recent success they have been having.
04:02:54 <astrolabe> It is quite impressive that a lot of languages seem to be essentially designed by one person.
04:03:00 <paolino> mq_mattr_: I never use that name, and everyone is no understanding my python code, blah
04:03:13 <mq_mattr_> astrolabe: in some ways it is necessary
04:03:28 <astrolabe> how so?
04:03:39 <mq_mattr_> it is not often a group like the original haskellers get together
04:03:47 <mq_mattr_> design by comittee is normally a quick death
04:03:52 <mq_mattr_> we just got lucky I guess
04:03:55 <mq_mattr_> :)
04:04:04 <mq_mattr_> Now we have to make the most of it
04:04:33 <mq_mattr_> My own guess is that a lanuage needs *one direction*
04:04:43 <paolino> mmhh learning python is for fun , not for knowledge
04:04:57 <mq_mattr_> and if it has more than one *owner* there is a very strong chance it will be pulled in more than one direction
04:05:19 <mq_mattr_> paolino: python is quite nice, just don't write your own classes
04:05:23 <astrolabe> yeah
04:05:29 <mq_mattr_> or at least test the buggery out of them
04:05:32 <Stinger__> too many cooks spoil the broth eh?
04:05:45 <pzpz> Hmm, I'm trying to figure out the optimal way of sending sequences of types to a server (part of a protocol). The protocol often calls for sequences of Word32s, Strings, etc -- What's the best method for doing such? I was thinking of marshalling arrays, yet I don't know if it's possible to marshall the data types I define to represent the message structures.
04:05:45 <mq_mattr_> stinger__: almost always
04:06:02 <xerox> paolino: knowledge is fun
04:06:20 <astrolabe> The odd thing is that extra language features can make a language worse.  Like a class interface.
04:06:34 <paolino> xerox, in the end
04:06:40 <mq_mattr_> astrolabe: I have been struggling with this question
04:06:51 <paolino> the opposite only at the beginning
04:06:54 <mq_mattr_> I teach Java and many of the new features are terrible
04:07:04 <mq_mattr_> but I can mostly ignore them
04:07:15 <mq_mattr_> the ones I can't, are actually quite good (like generics)
04:07:33 <astrolabe> pzpz: define a datatype and send a list of them?
04:07:40 <mq_mattr_> so I am undecided about new features *necessarily* being bad, but in practice, they often are
04:08:26 <mq_mattr_> I will be watching the transition to obj-c 2.0 with some interest
04:09:00 <astrolabe> I find computer languages a bit depressing.
04:09:44 <pzpz> astrolabe: your'e saying if I had a datatype PairOfWord32s, I could just send that and it'd be what I'd want, 64 bits?
04:09:50 <astrolabe> I can't help feeling that if they had been designed by God, or nature or whatever, that they would be so much nicer.
04:10:32 <mq_mattr_> astrolabe: it is the human aspect of computer languages that is always the bit that lets you down
04:10:57 <astrolabe> pzpz: ah, do actually care about the bits that are sent, or just that you can interperate them at the other end?
04:11:13 <pzpz> astrolabe: they need to conform :) I'm not writing the server end.
04:11:36 <astrolabe> pzpz: I'm sorry, I don't know enough to help you then.
04:11:55 * paolino hates java, with no real reason. At least he hates windows  for some reasons.Then he discovers MS pais for haskell development and get depressed by haskell also 
04:12:30 <Pastorn> @paste
04:12:31 <lambdabot> http://paste.lisp.org/new/haskell
04:12:32 <astrolabe> paolino: I see the last point as a reason for hope
04:12:34 <mq_mattr_> paolino: MS is one of the major contributors to programming languages these days
04:12:51 <mq_mattr_> they do some really good stuff
04:12:59 <mq_mattr_> I like .NET CLR
04:13:07 <mq_mattr_> I like MS research at cambridge
04:13:13 <mq_mattr_> I like F#
04:13:25 <mq_mattr_> and I don't use a singe piece of MS software
04:13:27 <mq_mattr_> :)
04:13:36 <pzpz> mq_mattr_: wan't to explain to me why a CLR is restricted to a single operating system? :)
04:13:39 <astrolabe> It means they have realised that they can't dictate language development, and that if they want to understand it, they need to help fund it.
04:14:24 <mq_mattr_> pzpz: MS is doing good stuff, but it needs to make money.  I prefer OSS of course, but I won't diminish the work of the researchers because their work is only beer-free
04:14:44 <mq_mattr_> :)
04:15:06 <paolino> I know I should lighten my mind about dictatorship
04:15:21 <pzpz> mq_mattr_: I'm still not understanding how introducing a official *nix CLR wouldn't be a good-move
04:15:25 <paolino> after I understand arrows maybe
04:16:00 <mq_mattr_> pzpz: you may be right, but at the very least there is the question of resources.
04:16:18 <astrolabe> MS are annoying, but the fact that they feel they have to fund research is a good thing I feel.
04:16:25 <pzpz> mq_mattr_: they have a bajillion people :)
04:16:49 <paolino> they have a region of India
04:16:56 <mq_mattr_> I saw a talk on channel nine on F# (can't remember the name of that guy) and it was clear that they were deep into visual studio.  Making it work outside that environment would be twice as much work again
04:17:32 <mq_mattr_> astroable: bottom line is that they publish it for us to see anyway, so who can complain
04:17:55 <Stinger__> pzpz : good move for who?
04:17:59 <mq_mattr_> they are keeping SLPJ, Ralph Lammel, etc fed and with a roof over their head
04:18:05 <astrolabe> mq_mattr_: right, and I suspect if they didn't, their best people would leave :)
04:18:07 <mq_mattr_> and that is good for all of us :)
04:18:35 <mq_mattr_> although I am sure they would not have trouble finding work :)
04:19:03 <pzpz> Stinger__: Themselves. There's an undeniable market of linux users that would enjoy having Visual Studio.
04:19:03 <vincenz> wow
04:19:07 * vincenz found another great torll
04:19:08 <vincenz> troll
04:19:16 <pzpz> Stinger__: or any other app that runs on the CLR.
04:19:20 <mq_mattr_> vincenz: who?
04:19:32 <vincenz> kt
04:19:37 <vincenz> in cll
04:19:47 <paolino> mq_mattr_: now it's really too late to complain, the power gap from them to the rest is not complainable any more.
04:19:49 <pzpz> Time to sleep! peace.
04:20:22 <Stinger__> pzpz : you think letting linux people run a lot of apps currently exclusive to windows would be a good move for ms? :)
04:20:49 <mq_mattr_> paolino: well, it depends on what area you are looking at.  There are other big research houses out there.
04:21:43 <paolino> I can't see them from italy.I suppose it's the same from many other places
04:21:55 <beelsebob> Stinger__: absolutely - it would mean that you would get a whole load of linux people contributing to those apps
04:22:34 <astrolabe> I could understand a microsoft policy that said not to do anything to improve Linux
04:23:46 <astrolabe> It would be better if MS operating systems was split off from the applications (as companies).
04:24:03 <beelsebob> well, in a way it is
04:24:09 <beelsebob> the MacBU is sepperate
04:24:58 <beelsebob> I think MS would produce things for linux if they saw a profit in it
04:25:18 <beelsebob> but what they see is 1% of the market, 99% of which wouldn't touch an MS product if it hit them in the face
04:26:19 <astrolabe> heh
04:32:07 <vincenz> dons: still here
04:32:08 <vincenz> ?
04:32:38 <vincenz> @localtime dons
04:32:41 <lambdabot> Local time for dons is Sun Dec 10 23:25:05 2006
04:33:00 <vincenz> @tell dons Not sure if I agree with your point on "alternative results" with Either.  That is not supported, monadically speaking.
04:33:00 <lambdabot> Consider it noted.
04:33:30 <mq_mattr_> vincenz: yep, it is bedtime here in oz
04:33:39 <mq_mattr_> think I might head off myself
04:33:53 <Pupeno> Are these http://darcs.haskell.org/~lemmih/hsSDL/ the main (only ones) SDL bindings ?
04:33:55 <lambdabot> Title: Index of /~lemmih/hsSDL
04:34:08 <vincenz> alright, take care :)
05:09:41 <xerox> vincenz: "Left something instead of Nothing" suits better, probably
05:10:26 <chr1s> I'm working with Parsec, and trying to parse (predefined) operators, and it's almost working perfectly
05:10:38 <vincenz> roconnor: ping
05:11:04 <chr1s> the only thing is, I don't want to have space between my operators, and Parsec seems to require that
05:11:11 <chr1s> is there a way around that?
05:11:28 <dons> vincenz: hmm?
05:11:28 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
05:12:05 <dons> > do x <- Right "good" ; y <- Right (reverse x) ; Left "it went wrong!" ; return y
05:12:07 <lambdabot>  Left "it went wrong!"
05:12:32 <vincenz> dons: that only works for strings
05:12:37 <vincenz> dons: which is the same as fail in Maybe
05:12:51 <vincenz> it's an optional answer with a more informative error message
05:12:55 <xerox> > fail "it went wrong!" :: Maybe ()
05:12:56 <lambdabot>  Nothing
05:13:48 <dons> what did I say about Either, vincenz? I don't remember saying anything about it...
05:13:51 <vincenz> @tell roconnor About your problem of storing data on paper, recently there was an article on slashdot about encoding MUCH more data on a page using differently sized figures
05:13:52 <lambdabot> Consider it noted.
05:13:52 <xerox> vincenz: hmm, no wait, it's really just a sum type
05:13:55 <vincenz> dons: your blog
05:14:25 <dons> ah right. have a look at the Error monad
05:14:34 <dons> instance (Error e) => Monad (Either e) where
05:14:34 <dons>     return        = Right
05:14:34 <dons>     Left  l >>= _ = Left l
05:14:34 <dons>     Right r >>= k = k r
05:14:34 <dons>     fail msg      = Left (strMsg msg)
05:14:43 <vincenz> I know, my point is, you can't return alternative messages
05:14:45 <vincenz> erm, data
05:14:50 <vincenz> you either have data, or you have failure
05:14:57 <vincenz> which imho is just a more informative "optional answer"
05:15:07 <haskellNoob> I have a problem with GHCI 6.6
05:15:14 <haskellNoob> Loading package base ... linking ... done.
05:15:18 <haskellNoob> Prelude> succ x = x + 1
05:15:22 <haskellNoob> <interactive>:1:7: parse error on input `='
05:15:26 <haskellNoob> Prelude>
05:15:28 <haskellNoob> any idea?
05:15:39 <dons> haskellNoob: let succ x = x + 1
05:15:51 <haskellNoob> thanks!
05:15:52 <roconnor> > exp(1)
05:15:54 <lambdabot>  2.718281828459045
05:15:54 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
05:16:09 <xerox> > exp 1
05:16:10 <lambdabot>  2.718281828459045
05:17:18 <dons> vincenz: ah, right. I should have written "error handling", not "optional results" (which is really just the definition of the Either type)
05:18:04 <vincenz> yeah :)
05:18:05 <beelsebob> haskellNoob: better yet "data Nat = Succ Nat | Zero"
05:18:54 <dons> beelsebob: is that helpful? ;)
05:19:09 <dons> > succ 1
05:19:11 <lambdabot>  2
05:19:20 <chr1s> hey guys, anyone with operator parsing experience in Parsec?
05:19:21 <beelsebob> dons: well it really depends what he's trying to implement
05:19:41 <dons> beelsebob: I think he's trying to write functions :)
05:20:05 <haskellNoob> I'm trying to solve some exercises from a tutorial
05:20:07 <beelsebob> dons: I could equally argue that it looks like he's trying to implement church numerals
05:20:25 <vincenz> beelsebob: KISS
05:20:53 <beelsebob> vincenz: I don't know how noob noob means -- implementing CNs was a very early exercise for me
05:20:59 <dons> heh
05:21:22 <vincenz> Yeah but by the context of his message, one can assume his issue is with ghc, not what algorithm it is, aka, technical issues
05:21:31 <beelsebob> true
05:21:41 <beelsebob> but that answer had already been given
05:21:45 <vincenz> right :)
05:21:47 <beelsebob> I wanted to prod an alternative
05:21:49 <vincenz> Now the next Q will be
05:21:59 <vincenz> "why does data Nat = Succ Nat | Zero" not work in ghci
05:22:03 <beelsebob> hehe
05:22:20 <dons> oh you meant: data Succ a ; data Zero ; instance Add ...
05:22:21 * beelsebob waits
05:22:57 <beelsebob> speaking of which...
05:23:15 <beelsebob> why *does* "data Nat = Succ Nat | Zero" not work in ghci?
05:23:27 <beelsebob> does it break previous typechecking?
05:23:35 <dons> yeah
05:23:38 <vincenz> I assume that basically ghci puts you in an endless do-block
05:23:41 <Syzygy-> beelsebob: Because ghci only accepts statements and not type defintions..
05:23:41 <vincenz> hence
05:23:43 <vincenz> let x = ...
05:23:51 <vincenz> Syzygy-: you mean expressions
05:23:58 <Syzygy-> vincenz: Yeah. One of those things.
05:24:04 <beelsebob> Syzygy-: yes - my question was *why* is that limitation there... I knew the limitation was
05:24:11 <Syzygy-> Ah, ok.
05:24:18 <dons> let x = Zero ; data Nat = Zero Int ; case x of Zero y -> ... boom
05:24:28 <vincenz> beelsebob: as soon as we have scoped data-decls...
05:24:38 <beelsebob> dons: ah yes, that works
05:25:14 <SamB_XP> "local data type definition escapes!"
05:25:21 <haskellNoob> do you mean that in a .hs file I don't have to use let?
05:25:21 <beelsebob> so... it would work if it cleared all previous bindings as well as defining the type
05:25:27 <vincenz> haskellNoob: no
05:25:28 <dons> haskellNoob: that's right
05:25:36 <vincenz> as in, no, you're right
05:25:42 <dons> in a .hs file your top level declarations don't need to be prefixed with 'let'
05:25:47 <dons> its an artifact of the REPL
05:25:56 <vincenz> dons: I honestly have a suspicion that a repl is basically an infinitely long do-block
05:26:00 <vincenz> hence the let without in
05:26:02 <dons> it is
05:26:07 <dons> that's *exactly* what it is
05:26:11 <roconnor> vincenz: http://www.techworld.com/storage/news/index.cfm?newsid=7432
05:26:14 <lambdabot> Title: Techworld.com - Storage News - Can you get 256GB on an A4 sheet? No way!
05:26:24 <beelsebob> not quite... it's an infitely long *strict* do-block
05:26:25 <SamB_XP> only with some implicit "print"s
05:26:39 <dons> and an 'it'
05:26:55 <vincenz> roconnor: yeah, I read on later seems you don't believe in it
05:27:36 <dons> beelsebob: would it be possible to use hat as a lambdabot plugin to print reductions of an expression?
05:27:53 <beelsebob> dons: interesting idea...
05:27:54 <beelsebob> I guess...
05:27:55 <vincenz> beelsebob: correct
05:27:59 <dons> i.e. @reduce foldl (+) 1 [1..10] ...
05:28:12 <beelsebob> you would have to accept the expression
05:28:20 <beelsebob> run it through hat-trans (hoping not to hit defaulting problems)
05:28:23 <dons> and you could @next to step through, or say get 2 or 3 reductions at a time
05:28:25 <beelsebob> compile that
05:28:37 <dons> yeah
05:28:37 <beelsebob> run it
05:28:47 <dons> that would reuse the existing @run infrastructure
05:28:48 <beelsebob> find the main closure
05:28:51 <beelsebob> and run hat-anim on it
05:29:03 <beelsebob> but a modified version
05:29:22 <dons> do you remember what freja does?
05:29:27 <dons> didn't it have a cmd line interface?
05:29:37 * vincenz has an idea of doing
05:29:37 <beelsebob> yes - it's an algorithmic debugger
05:29:38 <vincenz> @last dons
05:29:38 <dons> (it only needs to support h98 expressions, basically)
05:29:39 <lambdabot> No module "dons" loaded
05:29:53 <beelsebob> it doesn't print reductions in sequence
05:29:55 <beelsebob> it needs interaction
05:29:56 <SamB_XP> is that pronounced "freya"?
05:29:56 <dons> ah right
05:30:00 <dons> yup
05:30:06 <vincenz> flemish or dutch I take it?
05:30:10 <dons> beelsebob: but hat can print reductions?
05:30:13 <dons> vincenz: spanish?
05:30:17 <vincenz> freja?
05:30:21 <beelsebob> dons: yes, hat-anim can, but it's a bit broken at the moment
05:30:24 <vincenz> then it is not pronounced as "freya"
05:30:26 <beelsebob> I can go fix it if you want me to
05:30:26 <vincenz> but "freha"
05:30:43 <dons> right
05:31:01 <beelsebob> dons: it's Henrik Nilsson's I thought it was scandinavian of some sort
05:31:06 <beelsebob> (and hence Freya)
05:31:12 <dons> ah right :)
05:31:28 <vincenz> And if you want in pure anglophonic syntax: "fray-yah"
05:31:32 <vincenz> without a pause
05:31:33 <dons> beelsebob: know of any other tool that could print h98 reductions?
05:31:45 <beelsebob> dons: Hood does... in a way
05:31:53 <beelsebob> but it then needs specific code modifications
05:32:09 <dons> oh?
05:32:21 <psnl> dons: if you can't find anything, then writing one as a frontend to hat is easy
05:32:24 <beelsebob> well - it needs you to insert the observe function
05:32:32 <psnl> dons: I'ld be willing to smash it out
05:32:32 <dons> psnl: yeah, that's what I'm thinking
05:32:45 <beelsebob> it'll be easy enough for me to go tweak hat-anim to present a library
05:32:49 <beelsebob> ... and you know... actually work
05:33:15 <dons> so basically the idea is: given a pure h98 expressoin, (fairly short), reduce it, printing the AST at each point
05:33:19 <dons> as ascii
05:33:22 <dons> seems doable?
05:33:32 <vincenz> spamful too
05:33:41 <dons> vincenz: maybe.. but we can deal with that
05:33:41 <beelsebob> yep
05:33:43 <beelsebob> that's easy to do
05:33:50 <beelsebob> that's basically what hat-anim does at the moment
05:33:50 <vincenz> dons: so you think so you think :P
05:33:59 <beelsebob> but it doesn't present a nice library for you to link to
05:34:10 <dons> beelsebob: ah ok.
05:34:15 <dons> psnl: you know much hat internals?
05:34:17 <vincenz> @type \f a b c d e f g -> f `ap` b `ap` return c `ap` d e `ap` g f
05:34:19 <lambdabot>   Conflicting definitions for `f'
05:34:19 <lambdabot>   In a lambda abstraction
05:34:20 <SamB_XP> not presently, you mean?
05:34:27 <vincenz> @type \a b c d e f g -> f `ap` b `ap` return c `ap` d e `ap` g
05:34:29 <lambdabot> forall a (m :: * -> *) a1 a2 t a3 b t1. (Monad m) => t1 -> m a -> a1 -> (t -> m a2) -> t -> m (a -> a1 -> a2 -> a3 -> b) -> m a3 -> m b
05:34:33 <dons> vincenz: please :)
05:34:43 <psnl> dons: yeah
05:34:47 <dons> vincenz: i'm aware that some things are not as concise as they could be, and I accept patches
05:35:04 * beelsebob wonders who psnl is... obviously a name I haven't connected to a face
05:35:05 <vincenz> I was just teasing :)
05:35:25 <dons> psnl: oh, you thinking of coming to the hackathon?
05:35:39 <dons> beelsebob: and you?
05:35:42 <psnl> dons: yeah, I need to send you/igloo mail
05:35:53 <dons> psnl: yeah, please do. dons.hac07@cse...
05:36:02 <dons> (since dcoutts needs to set up the firewall)
05:36:03 <beelsebob> dons: er... mayhaps... it mostly depends on my monetary state
05:36:14 <psnl> beelsebob: were you at aglohaskell?
05:36:17 <dons> ?where hac07
05:36:17 <lambdabot> http://haskell.org/haskellwiki/Hac_2007
05:36:20 <beelsebob> psnl: nope
05:36:58 <dons> ok. so what do we need to do do make this @reduce thing happen. i think it would be the next obvious lambdabot plugin
05:37:25 <dons> psnl: you think you could write an ascii/cmd line frontend in a few lines?
05:38:08 <dons> what i need is a function to call: String -> IO String, basically. that goes through hat
05:38:26 <dons> (could call an external process, and we do have access to a safe evaluator)
05:38:27 <psnl> dons: you would have you link against hat
05:38:35 <psnl> s/you/to/
05:38:37 <dons> that's ok I think (it could be bundled)
05:38:54 <beelsebob> dons: I guess something else interesting would be "@observe <pattern> in <expression>"
05:39:15 <psnl> it wouldn't be a few lines as well
05:39:15 <beelsebob> (running hat-observe and asking about the pattern)
05:39:43 <dons> psnl: oh? its a bit of work to hook into hat?
05:39:57 <beelsebob> dons: your String -> IO String function... it takes an expression and gives the trace, yes?
05:40:02 <dons> yep
05:40:08 <beelsebob> yeh, that would be a bit of work
05:40:17 <dons> say, String -> IO [String], each reduction in a list
05:40:22 <beelsebob> kk
05:40:32 <beelsebob> dons: I can get a decent way there today
05:40:34 <psnl> dons: define few ;-), I'm thinking about 20-50
05:40:45 <psnl> dons: do you want wireless mac addresses too?
05:40:55 <dons> so I feed it an expr, we run it through a modifed runplugs (which checks for IO and so on, and compiles in any hat libs)
05:41:01 <dons> then run that thing, get the resulting reductoin bac
05:41:05 <dons> psnl: 50 is short
05:41:11 <dons> psnl: yeah, if you want wifi access
05:42:49 <beelsebob> dons: if you/psnl get the "build for hat and produce a trace" working, then i'll get the "produce a sequence of steps" working
05:42:57 <dons> ok. sounds good.
05:43:14 <dons> i think i can hack up a modified runplugs that compiles the code to a hat-annotated object
05:43:52 * beelsebob runs off to uni... see you in half an hour or so
05:43:55 <Pastorn> @logs
05:43:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
05:44:04 <Pastorn> @log
05:44:04 <lambdabot> Maybe you meant: bug let msg yow
05:44:16 <dons> ?where logs
05:44:17 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
05:44:22 <Pastorn> thanks =)
05:47:35 <dons> mmm, interesting. a newbie's view of common lisp infrastructure: how much do we suffer from the same kind of issues? http://groups.google.com/group/comp.lang.lisp/browse_frm/thread/ea994085b54de92d
05:47:37 <lambdabot> Title: Google Groups : comp.lang.lisp, http://tinyurl.com/y6drds
05:47:52 <dons> (at least people know which compiler to use, and how to create an executable, right?)
05:48:42 <vincenz> dons: yeah, reading down that list, cll suffers from some serious elitary trolls
05:48:45 <vincenz> (read kt)
05:48:55 <dons> mmm. i wonder if the disorganised lisp community is damaging to FP... i wonder how many people give up on FP assuming it is lisp and the lisp community
05:50:15 <haskellNoob> as a FP noob I can tell that I make a clear distinction between Haskell and Lisp
05:50:23 <dons> ah good :)
05:50:40 <vincenz> haskellNoob++
05:50:43 <dons> (why is lisp still so prevalent in the US, is another thing I wonder)
05:50:51 <vincenz> dons: NIH
05:51:04 <dons> NIH?
05:51:17 <vincenz> not-invented-here syndrome
05:51:22 <dons> ah
05:51:32 <dons> fancy euro-trash haskell, ocaml and erlang ;)
05:51:40 <Syzygy-> Hehe... "What if I'm a vi (vim) user?" "You must be a masochist."
05:51:48 <Syzygy-> Good way to expand the flamewars.
05:52:01 <vincenz> kt is a serious flamer/troll on cll
05:52:19 <Syzygy-> That wasn't kt. That was pascal bourguignon
05:52:29 <vincenz> oh
05:52:32 * vincenz coughs
05:52:33 <dons> promise me, everyone, we'll never end up like that
05:52:37 <dons> bitter and twisted
05:52:39 <vincenz> yeah
05:52:49 <vincenz> Not to mention, closing doors to newbs cause they're not choosing haskell as religion
05:52:51 <dons> shiny happy lambdas forever!
05:53:30 * roconnor munches on a sugared lambda
05:53:40 * vincenz throws around some bananas
05:54:16 <psnl> I'm aready bitter and twisted, should I leave?
05:54:31 <vincenz> psnl: use more syntax-sugar
05:54:33 * roconnor throws around some lenses
05:54:45 * vincenz throws around some barbed-wire, oh...wait
05:54:49 <dons> hehe
05:54:51 <psnl> youch
05:54:53 <therp> yes, the cl community is pretty unfriendly. on the first few weeks on #lisp,  I was kickbanned because I argued in favour of FFI.
05:54:54 <dons> arrows and barbed wire!
05:55:11 <dons> therp: that is so bizarre and self defeating.
05:55:19 <dons> how did it end up like that?
05:55:23 <dons> how can we avoid this?
05:55:44 <vincenz> don't become self-important, learn to be able to relativate
05:55:52 <vincenz> or keep that ability
05:56:34 <therp> dons: don't worry, I don't see the haskell community moving there :) in fact, I'm more often surprised how friendly the climate is in here than I'm worried about unfriendliness
05:56:48 <dons> that's good to know.
05:57:15 <Saizan> (mmh, maybe even haskell needs a tutorial on the most useful libraries)
05:57:18 <vincenz> yeah, and no elitary high-browing, even though we have some seriously smart people in this channel :)
05:57:22 <pejo> dons, someone pointed out the ohter day that there are a lot of academics in the community, I think that helps.
05:57:26 <dons> the future still feels bright and hopefull for haskell, imo. maybe that helps keep things positive
05:57:35 <dons> after all our hopes and dreams are defeated, then we can be bitter
05:57:51 <SamB_XP> that would do it
05:57:53 <dons> pejo: yeah. and professional tutors. i agree with that
05:58:04 <SamB_XP> Haskell is still young, after all!
05:58:14 <vincenz> heh, typical statement "The only people turned back by your experience are tire kickers, not
05:58:18 <Syzygy-> #haskell (and the haskell community) manages surprisingly well to have blindingly brilliant people hanging around without becoming exclusive in the prevalent attitudes.
05:58:18 <vincenz> people really looking for A Better Way"
05:58:25 <xerox> he's starting to accumulate pages of history... :)
05:58:30 <dons> long live the multicore disruption! may it be disruptive and long lived!
05:59:08 <dons> Syzygy-: mm. interesting.
05:59:11 <jlouis> another thing is that haskell is easier to learn than Common Lisp
05:59:16 <roconnor> is Haskell actually useful for multicore?
05:59:29 <haskellNoob> as in CPU multicore?
05:59:30 <dons> roconnor: grab that smp runtime and get cracking!
05:59:30 <SamB_XP> roconnor: duh, yeah
05:59:35 <roconnor> I mean, I see potential, but are there implementaitons?
05:59:41 <dons> roconnor: ghc 6.6!
05:59:53 <roconnor> dons: are we talking small scale parallelism?
06:00:07 <roconnor> each processor munching on a different redex?
06:00:32 <roconnor> or large scale, as in programmer writing STM?
06:00:35 <dons> we're talking forkIO for explicit multicore threads, and `par` for implicit ones. and the new data parallel arrays for transparently smp arrays
06:00:44 <dons> (tested on up to 40 cores so far)
06:00:48 <SamB_XP> roconnor: STM is not exactly the only way
06:00:50 <dons> so yeah, its here, its ready. use it!
06:01:29 <roconnor> SamB_XP: sure, but you sort of understand the difference that I am getting at between small and large scale parallelism?
06:01:41 <dons> roconnor: you want something like true pH
06:01:46 <dons> the paralell graph reduction runtime?
06:01:51 <vincenz> Q for thought: are greenthreads ever useful in data-dominated (and thus not IO-dominated) apps?
06:01:54 <dons> (in which case no, its not that)
06:02:15 <roconnor> dons: I just want to know how Haskell programers are expected to deal with multicore?
06:02:22 <SamB_XP> vincenz: why not?
06:02:28 <dons> roconnor: currently, throught the use of `par` , or forkIO
06:02:37 <dons> array programs can use DPH arrays
06:02:44 <vincenz> SamB_XP: I can't see any use to them
06:02:54 <vincenz> SamB_XP: And without a validating reason, you haven't given me a positive reply yet
06:03:03 <SamB_XP> vincenz: well it can't hurt for them to be green!
06:03:12 <SamB_XP> you would prefer blue or red?
06:03:16 <vincenz> ...
06:03:26 <dons> roconnor: yeah?
06:03:39 <roconnor> sounds reasonable
06:03:45 * vincenz was hoping for a serious reply
06:03:53 <dons> roconnor: http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
06:03:56 <lambdabot> Title: 7.15. Concurrent and Parallel Haskell, http://tinyurl.com/zqwkf
06:03:56 <SamB_XP> anyway, they could be useful for clarity!
06:04:19 <vincenz> possibly, though hard to argue
06:04:41 <SamB_XP> or seperation of concerns, even
06:04:45 <dons> SamB_XP: abotu libraries. I agree. we've started a guide on the libraries page
06:04:50 <dons> Saizan: ^^ sorry
06:04:51 <vincenz> it feels like single-processor-threads are useless unless you have IO going on
06:05:08 <dons> vincenz: they're a useful structuring mechanism though
06:05:14 <roconnor> although any language that supports reasonable threading seems like it will do fine on multi-core ... and I guess that is just Haskell and E
06:05:16 <dons> when plugged together with Chans
06:05:21 <Pupeno> Any thoughts regarding hsSDL vs HSDL ?
06:05:30 <vincenz> dons: possibly, though then you can wonder why you don't just couple the two loops
06:05:47 <Saizan> dons: huh? tab mistake?
06:05:47 <dons> and then you just add -RTS -N4 when you're new machine arrives, and , in a puff of smoke, you've got a parallel program
06:05:48 <SamB_XP> I use them to keep my monad clean in ZMachine. granted, I do use them for IO, but I figure you could have other things that would be nicer to keep in their own thread...
06:06:01 <vincenz> dons: the premise is single processor
06:06:29 <dons> vincenz: on a single processor, I still use them to structure long running coroutine stuff (occasionally)
06:06:40 <dons> i think its a fairly well established design
06:06:56 <vincenz> dons: any specific example?
06:06:59 <dons> with lazy lists connecting the threads
06:07:00 <vincenz> trying to map it onto my application domain
06:07:30 <dons> dont' have an example off hand
06:07:55 * vincenz nods
06:08:06 <vincenz> not code, just examples, but yeah lazy lists would be one
06:13:58 * psnl hasn't gotten around to trying the parallel RTS thing on this yet
06:15:07 * dons suggests throwing around some forkIOs and `par`s with +RTS -N2 (or more :)
06:15:15 <dons> you can run your quickchecks smp style now
06:15:19 <dons> ?where pqc
06:15:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/pqc.html
06:18:04 <jlouis> There is a ken tiltons best somewhere out there
06:27:49 <vincenz> jlouis: :D
06:31:34 <Pastorn> @seen xinming
06:31:34 <lambdabot> xinming is in #perl6 and #haskell. I last heard xinming speak 9h 14m 23s ago.
06:34:36 <jlouis> ah, got it: http://bc.tech.coop/blog/061005.html
06:34:39 <lambdabot> Title: Bill Clementson's Blog: The Kenny Tilton CLL fortune file
06:34:55 <jlouis> oh, joy. We need a ?ken
06:37:47 <vincenz> Do you put reviewed-papers on your resume?
06:38:24 <Syzygy-> vincenz: Papers you published or papers you reviewed?
06:38:46 <vincenz> reviewed
06:39:13 <Syzygy-> I wouldn't
06:39:27 <vincenz> Syzygy-: you're a phd-student?
06:39:30 <roconnor> vincenz: aren't reviewer supposed to be anonymous?
06:39:31 <dons> its useful to know which conferences you've reviewed papers for
06:39:37 <vincenz> roconnor: Yes but we get put on the TPC
06:39:38 <dons> not which papers.
06:39:50 <vincenz> erm, not TPC, the reviewers list
06:39:51 * vincenz coughs
06:41:27 <Syzygy-> vincenz: Ayup.
06:43:17 <dons> ?pl reverseWords xs = (concat (intersperse " " (reverse (words xs))))
06:43:18 <lambdabot> reverseWords = join . intersperse " " . reverse . words
06:43:43 <vincenz> o.O
06:43:56 <vincenz> @type join . intersperse " " . reverse . words
06:43:57 <beelsebob> dons: why not unwords?
06:44:01 <lambdabot> String -> [Char]
06:44:05 <dons> doesn't have that tactic in it
06:44:05 <vincenz> @type join
06:44:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
06:44:07 <vincenz> @type concat
06:44:08 <dons> (should add it)
06:44:09 <lambdabot> forall a. [[a]] -> [a]
06:44:11 <vincenz> hmm
06:44:27 <vincenz> dons: he's probably asking why you did not choose for unwords :)
06:44:34 <dons> not my code
06:44:44 <xerox> > unwords . reverse . words $ "foo bar baz"
06:44:45 <dons> i'm seeing how well @pl did with the question asked on the mailing list
06:44:49 <lambdabot>  "baz bar foo"
06:44:53 <dons> which ndm got a rather good result from DrHaskellwith
06:44:57 <xerox> > unwords . map reverse . words $ "foo bar baz"
06:44:59 <lambdabot>  "oof rab zab"
06:45:26 <psnl> cool, a new way to get varible names
06:45:39 <Syzygy-> > unwords . reverse . words $ "foo bar baz"
06:45:41 <lambdabot>  "baz bar foo"
06:46:13 <dons> did people see this gem from Claus Reinke? http://programming.reddit.com/info/uaqq/comments
06:46:15 <lambdabot> Title: Haskell mailing list gem: variables are not mutable boxes! (reddit.com)
06:47:08 <jlouis> gem? That page is far too big to be a gem ;)
06:47:29 <dons> 100 carats
06:47:40 <jlouis> I must admit I became tired reading around 1 page down and skipped the rest
06:49:53 <psi> would it be correct to say the existing solutions for, say, traveling salesman and knapsack, are not much better than doing exhaustive searches?
06:51:30 <psi> I assume there are smarter ways, but if we speak very broadly.
06:51:45 <Pastorn> when should i use cases and when should i use guards?
06:53:36 <jlouis> psi, there are various tricks to make algorithms be far far better than exhaustive search
06:53:50 <pejo> psi, "rather" large instances of tsp has been solved in reasonable time.
06:53:54 <dons> Pastorn: cases when you need to take apart structures, guards are for booleans
06:54:18 <pejo> psi, Hkan happens to know that kind of stuff, I think.
06:54:57 <Pastorn> dons: thanks =)
06:56:40 <psi> hm, okay. I'm doing an exercise in writing popular science articles, and I'm trying to express how difficult the problems are.
06:57:14 <psi> so I was thinking about the number of possible solutions you might have to look at.
06:57:39 <TomMD> Is there a portable call like scheduleAlarm?  Perhaps one that has ms accuracy as well?
06:58:14 <psi> but if the best solution are much better than looking at all possible solutions, that might be deceiving.
07:03:36 <dons> TomMD: threadDelay?
07:03:46 <dons> ?hoogle threadDelay
07:03:47 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
07:03:52 <dons> ?docs Control.Concurrent
07:03:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
07:04:10 <dons> have it sleep for the n ms, then toss out an exception, or print a msg or something
07:05:37 <TomMD> dons: Uglier, but it will do the trick.  Thanks
07:09:38 <TomMD> dons: On a similar note, will Haskell likely standardize a non-cooperative preemption for Haskell threads?  Or is everyone leaning toward cooperative yeilding?
07:14:09 <dons> I think cooperative yielding is out
07:14:46 <dons> check with Igloo, he's on the concurrency team
07:16:38 <dons> (there's been some progress this week in fact on sorting out the preemptive concurrency details, I think)
07:17:04 * dons `ap` sleep
07:17:54 <Igloo> Pre-emptive is the plan, yes
07:18:30 <sorear> Why are precedence and associativity not allowed in pattern matching?
07:18:38 <sorear> ?let foo x:y:_ = y
07:18:39 <lambdabot>  Parse error in pattern
07:19:21 <Igloo> You need parens around the x:y:_
07:19:41 <TomMD> Thanks Igloo, that makes planning lasting code easier :-)
07:26:35 <chr1s> is it possible to declare an instance of a class for a type ?
07:27:11 <sorear> ?let foo (x:y:_) = y
07:27:13 <lambdabot> Defined.
07:27:25 <sorear> ?undef foo
07:27:26 <lambdabot> Undefined.
07:27:51 <sorear> chr1s: what do you mean?  (All instances of classes are types)
07:28:23 <chr1s> I've got a "type PropertyName = Either Primitive Identifier"
07:28:54 <chr1s> and I want to do something like "instance Compile PropertyName where"
07:28:55 <Igloo> To do it in Haskell98 you have to use newtype
07:29:01 <sorear> you cannot, in haskell98, instantiate a class at a "Type synonym"
07:29:02 <chr1s> ah, ok
07:29:13 <Igloo> ghc and hugs, I think, will allow you to do it with extensions enabled, though
07:29:15 <sorear> GHC allows it as an extension, however
07:29:42 <sorear> ?users
07:29:43 <lambdabot> Maximum users seen in #haskell: 278, currently: 270 (97.1%), active: 31 (11.5%)
07:29:45 <chr1s> what should I google for?
07:30:17 <roconnor> class isntances on type synonyms. ... that's crazy
07:31:07 <chr1s> roconnor: why?
07:31:11 <sorear> not very, GHC interprets "instance Compile PropertyName" as "instance Compile (Either Primitive Identifier)", just like every other use of type synonyms
07:31:49 <roconnor> because what if you instantiate one class in two different ways?
07:32:10 <beelsebob> dons: if you could show me the specific container you would wrap an expression in to make it run within hat, I can strip out all the container stuff
07:32:20 <sorear> that's called overlapping-instances
07:33:07 <augustss> roconnor: do you mean have the same type be an instance of the same class in two different ways?
07:33:36 <dons> beelsebob: I'd call a binary something like we do for hoogle, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Hoogle.hs
07:33:53 <augustss> roconnor: using type synonyms for that would make no sense.  type synonyms are always equal to the original type
07:34:00 <beelsebob> well yes... what I mean, is that you will get an expression ...
07:34:09 <dons> since we have to compile the code, it will need something like RunPlugs, http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/RunPlugs.hs
07:34:10 <beelsebob> presumably you'd wrap the expression in a container...
07:34:10 <lambdabot> http://tinyurl.com/z7nbx
07:34:32 <dons> to actually run it in a particular environment
07:34:51 <dons> beelsebob: so something like the expressoin wrapper in that file
07:34:52 <beelsebob> hmmm
07:35:22 <beelsebob> I think you'll have trouble doing that
07:35:34 <beelsebob> because traced code does not interact well with non-traced code
07:36:07 <dons> ok. but that's the basic idea right, we take the expression, embed it in a module, and run the thing
07:36:13 <beelsebob> yeh
07:36:15 <beelsebob> so...
07:36:19 <beelsebob> such a module might look like...
07:36:37 <beelsebob> module Main where
07:36:38 <beelsebob> main = print $ exp
07:36:45 <beelsebob> so that exp gets strictly evaluated
07:37:04 <beelsebob> if I just run hat-anim on that
07:37:14 <beelsebob> the output will contain stuff to do with print
07:37:24 <beelsebob> (that the user never wants to see because they never said anything about print)
07:37:40 <beelsebob> so I need to know how to recognise the start of the computation of the user's input
07:38:18 <dons> yeah, so a module like that, yes.
07:38:27 <dons> now, 'how to recognise' means what?
07:38:33 <dons> a particular variable name?
07:38:41 <dons> i.e. main = print user_code
07:38:42 <beelsebob> well - when the program is traced
07:38:47 <dons> user_code = <expr>
07:38:49 <beelsebob> the trace will contain a reduction of main
07:38:53 <beelsebob> to an application of pint
07:38:55 <beelsebob> print
07:39:02 <dons> yep, so you want to filter that stuff out
07:39:03 <beelsebob> which was trusted
07:39:05 <beelsebob> yes
07:39:10 <beelsebob> I need to know what that stuff is
07:39:22 <dons> how about a distinguished top level name then for the user expr?
07:39:23 <beelsebob> I need to know where the computation of user_code is in the trace
07:39:23 <dons> just pick one :)
07:40:01 <beelsebob> oh, so it would become:
07:40:01 <beelsebob> Module Main where
07:40:01 <beelsebob> main = jibble user_expression
07:40:01 <beelsebob> user_expression = <users code here>
07:40:02 <beelsebob> yeh?
07:40:07 <dons> yep.
07:40:13 <dons> works for me.
07:40:16 <beelsebob> okay - user_expression it is then for the moment
07:40:23 <beelsebob> I'll just spot the reduction of that constant
07:40:27 <dons> just choose whatever you like, and I can work with that
07:40:43 <Pastorn> @info undefined
07:40:43 <lambdabot> undefined
07:40:46 <Pastorn> aight!
07:41:02 <dons> info?
07:41:08 <dons> ?hoogle undefined
07:41:08 <lambdabot> Prelude.undefined :: a
07:41:08 <lambdabot> Control.Exception.UndefinedElement :: String -> ArrayException
07:41:12 <dons> ?docs Prelude
07:41:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
07:41:15 <dons> ?source Prelude
07:41:15 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
07:41:15 <Pastorn> oh... =)
07:41:24 <chr1s> but... how do I define a type as instance of a class? Which extension should I use?
07:41:32 <dons> -fglasgow-exts
07:46:22 <paolino> @hoogle fglasgow-exts
07:46:22 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-exts'
07:46:51 <SlowByte> @djinn Monad m => m (x -> y) -> x -> m y
07:46:51 <lambdabot> Cannot parse command
07:47:44 <SlowByte> hmm :\
07:48:43 <vincenz> @djinn (Monad m) => m (x -> y) -> x -> m y
07:48:44 <lambdabot> Cannot parse command
07:48:50 <vincenz> @djinn m (x -> y) -> x -> m y
07:48:51 <lambdabot> -- f cannot be realized.
07:52:30 <shapr> Oh, nice topic.
07:54:30 <shapr> I notice that #haskell is reaching #perl for amount of traffic.
07:54:45 <augustss> wow, scary!
07:55:07 <shapr> I'm looking at the numbers on http://www.ircbrowse.com/index.html
07:55:10 <lambdabot> Title: IRC Browse Channels
07:56:01 <jlouis> I've made STRONG coffee, for my LAZY self. I'll become ecSTATIC in a couple of minutes
07:56:27 <shapr> Also, I have a question about the Template Haskell accessors in HAppS, I'm trying hard to wrap my head around them..
07:57:26 <shapr> I can see how they're used in the examples, but that doesn't tell me how to make it work for my own custom state type.
07:57:55 <SlowByte> bah, can't find a witness for that Monad m => m (x -> y) -> x -> m y, it's like ap, except x is not in a monad
07:58:33 * SlowByte tries harder
07:58:43 * shapr tries harder too
07:58:46 <vincenz> SlowByte: easy
07:58:59 <vincenz> @pl \f x -> f `ap` (return x)
07:59:00 <lambdabot> (. return) . ap
07:59:07 <vincenz> @type \f x -> f `ap` (return x)
07:59:09 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> a -> m b
07:59:42 <SlowByte> haha, right
07:59:57 * SlowByte slaps forehead
08:00:11 <vincenz> or
08:00:18 <vincenz> @type \f x -> liftM ($ x) f
08:00:19 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> a -> m b
08:00:29 <vincenz> that one is nasty :P
08:00:40 <augustss> or nice!
08:00:54 <vincenz> thx
08:01:05 <vincenz> slicing on $ is always curios
08:01:07 <vincenz> +u
08:02:18 <augustss> zipWith ($) fs xs
08:02:35 <augustss> something I showed a coworker the other day :)
08:03:22 <vincenz> what'd he say?
08:04:36 <shapr> Unless he's an experienced Haskeller, probably ARGH!
08:04:41 <arcatan> what would freud say?
08:04:52 <shapr> Freud would talk about tobacco...
08:04:53 <vincenz> arcatan: something involving your moter
08:04:55 <vincenz> +h
08:05:09 <arcatan> yeah
08:05:27 <vincenz> (funny how one can say that statement without it being an insult for a change)
08:06:17 <augustss> he's not an experience Haskeller, so he said "nice!"
08:06:35 <shapr> @quote ozone
08:06:35 <lambdabot>  joelr1: our C++ guru at work is getting a bit sick of me saying "ah, so that's like <x> in haskell, but not quite as elegant..."
08:06:57 <vincenz> @quote shapr
08:06:58 <lambdabot>  I've toked on so many lambdas I'm getting dependent types
08:07:03 <vincenz> @quote augustss
08:07:04 <lambdabot>  hbc still has some unique features, like views.  that i've never used..
08:07:31 <augustss> @quote vincenz
08:07:31 <lambdabot>  I wish meta had a letter. like eta
08:07:44 <vincenz> that's probably my lamest quote
08:07:45 <vincenz> @quote vincenz
08:07:46 <lambdabot>  Geek is Chique.
08:07:49 <vincenz> no, that one is it
08:07:56 <vincenz> I have better ones too :)
08:08:10 <Lemmih> @keal
08:08:11 <shapr> I've discovered that IBM uses FP commercially. And if everything works out, they'll present it at CUFP 2007.
08:08:11 <lambdabot> its because the timeline diverges and past events themselves unhappen
08:08:18 <arcatan> how to get right this? map (- 1) [1,2,3]
08:08:37 <arcatan> ghci seems to think that - 1 is same as -1
08:08:40 <Lemmih> > map (subtract 1) [1,2,3]
08:08:42 <lambdabot>  [0,1,2]
08:08:43 <vincenz> @quote vincenz
08:08:44 <lambdabot>  Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
08:08:50 <arcatan> hokay, thanks
08:09:07 <augustss> prefix minus is magic
08:09:09 * vincenz wishes that the behaviour w.r.t (- x) where improved
08:09:11 <augustss> :(
08:09:12 <allbery_b> haskell syntax has that peculiarity
08:09:14 <vincenz> augustss: sadly
08:09:27 <augustss> yes, it is a wart
08:09:48 <vincenz> augustss: you're doing slices [(+x), (*x), (/x), and tadatada(subtract x)]
08:10:14 <shapr> Hm, is there a way to do the tetration hierarchy with that approach?
08:10:16 <augustss> I know.  I was against using - as the negation operator
08:10:33 <vincenz> augustss: of course, as soon as you drop unary minus, people will complain and bitch
08:10:42 <augustss> SML uses ~
08:11:10 <shapr> Can tetration be iterative somehow?
08:11:29 <augustss> shapr, what does that question mean?
08:11:56 <augustss> it cannot be written as bounded loop unless you use higher order functions
08:12:00 <shapr> I mean, is there some sequence of operations that can be done stepwise to generate http://en.wikipedia.org/wiki/Tetration ?
08:12:25 <vincenz> shapr: sure
08:12:37 <shapr> I'm not sure I understood that, can you show me a snippet of code?
08:12:38 <jlouis> that applicative paper by McBride and Paterson will take a little more time to sink in
08:12:54 <augustss> Tetration is the same as Ackermann's function (except Ackermann has 2 args)
08:12:59 <Saizan> > map ((-) 1) [1..3] -- nicer than subtract?
08:13:00 <lambdabot>  [0,-1,-2]
08:13:12 <Saizan> mmh with flip..
08:13:21 <vincenz> let mul x n = foldr (+) 0 $ replicate n x
08:13:27 <augustss> > map (+ (-1)) [1..3]
08:13:28 <lambdabot>  [0,1,2]
08:13:29 <vincenz> let exp x n = foldr (*) 1 $ replicate n x
08:13:30 <astrolabe> shapr: Cool.  I invented that when I was at school.  I should be famous!
08:13:43 <vincenz> let tetr x n = foldr (exp) 1 $ replicate n x
08:13:48 <vincenz> or some such
08:13:52 <shapr> vincenz: Ah, I see!
08:13:55 <shapr> thanks!
08:13:58 <dons> ?users
08:13:58 <lambdabot> Maximum users seen in #haskell: 278, currently: 272 (97.8%), active: 33 (12.1%)
08:14:18 <augustss> oh, i didn't mean teration, but the generalization when one of the arguments determenis if you get +, *, ^, ...
08:14:31 <augustss> I can't spell today
08:14:41 <shapr> Is there a fifth or further operation in that series?
08:14:43 <vincenz> augustss: sure, it means how often you repeat repeating a procedure
08:15:02 <shapr> +, *, ^, ack, ptui ?
08:15:06 <augustss> shapr: just keep repeating
08:15:16 <shapr> oh yeah, of course..
08:15:24 <augustss> so ack is that whole sequence of functions
08:15:39 <shapr> and my made up name ptui is the whole sequence before it.
08:15:52 <vincenz> shapr: don't forget hte last
08:15:55 <vincenz> ack, ptui, TING!
08:15:59 <vincenz> (the spitpot in the bar)
08:16:10 <shapr> heh
08:16:22 <shapr> I was thinking about Bill the Cat actually, I think he said "ack ptui" regularly.
08:16:54 <jlouis> shapr, do you know of Grahams number?
08:17:06 <shapr> I think I've read about it, but I don't remember.
08:17:20 <jlouis> its supposed to be the largest number ever used in a proof: http://en.wikipedia.org/wiki/Grahams_Number
08:17:30 <dons> mmm. #haskell is now the 14th largest channel on freenode
08:17:37 <dons> we've made the front page http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode&D=plain&P=1
08:17:38 <shapr> Oh, is this from the page "Who can name the largest number?"
08:17:39 <lambdabot> Title: Search IRC, displaying all channels on freenode, http://tinyurl.com/y6hym9
08:17:44 <jlouis> Its built on the natural generalization of addition/multiplication/exponentiation/tetration/...
08:17:58 <vincenz> dons: \o/
08:18:02 <vincenz> dons: let me spam some more!
08:18:14 <shapr> We're beating out #python?!
08:18:23 <shapr> Impressive!
08:18:42 <arcatan> hmm, reviews for channels...
08:19:07 <vincenz> hmm, seems freenode-social is moderated
08:19:37 <astrolabe> We should all go an make #asterisk intolerable
08:19:41 <shapr> augustss: This brings up an interesting question... are there operations *below* that series?
08:19:52 <astrolabe> shapr increment
08:20:04 <shapr> augustss: For example, what's the operation 'below' addition?
08:20:14 <vincenz> shapr: what astrolabe said :)
08:20:20 <vincenz> and increment is prolly the baseline
08:20:27 <astrolabe> incr a b = a + 1
08:20:47 <astrolabe> yeah
08:20:50 <xerox> that is, successor
08:20:54 <shapr> let add x n = foldr (increment) 0 $ replicate n x
08:21:00 <dons> shapr: know why the network started calling us #Haskell after the last reboot?
08:21:01 <vincenz> nono
08:21:03 <xerox> succ(x) = x U {x}
08:21:06 <shapr> dons: no? why?
08:21:13 <dons> I don't know.
08:21:19 <dons> we had to patch lambdabot in fact
08:21:25 <shapr> oh, weird.
08:21:28 <shapr> We could ask, I guess.
08:21:44 <astrolabe> what were you before #haskell?
08:21:51 <augustss> well, if you extend the argument that picks the operation to be in R you can probably make it continuous
08:21:56 <jlouis> dons, there is a Ken Tilton fortune out there. I wonder how much hackery it would take to make ?ken a command in LambdaBot ;P
08:21:56 <shapr> astrolabe: It's the capital letter that brings up the question.
08:22:23 <jlouis> mayhaps the idea is not that good
08:22:26 <ToRA|3> @paste
08:22:26 <lambdabot> http://paste.lisp.org/new/haskell
08:22:28 <astrolabe> The definitions get a bit funny low down I think
08:22:45 <kyevan> .....
08:22:46 <SlowByte> @hoogle x -> y -> (x, y)
08:22:46 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
08:22:47 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
08:22:53 <shapr> augustss: This reminds me of the time I asked about a "base prime" number system.. That would be fun because you'd be unable to irrational numbers in that system.
08:22:56 * kyevan hits his code with a hammer
08:23:01 <kyevan> And/or Hummer
08:23:21 <shapr> I wish I'd know math could be this much fun when I was still in school.
08:23:25 <lisppaste2> ToRA|3 pasted "class syntax question..." at http://paste.lisp.org/display/31891
08:23:26 <astrolabe> it should actually be   add x n = foldr incr x (replicate n x)
08:23:41 <twanvl> ?type (,)
08:23:43 <lambdabot> forall b a. a -> b -> (a, b)
08:23:44 <ToRA|3> quick q guys: can some1 point me at the page to read to explain how to do what i want in that paste?
08:24:07 <jlouis> shapr, Cale seems to be one of the lords of the rings
08:24:13 <shapr> jlouis: haha, yes!
08:24:29 <shapr> He's quite knowledgeable about group theory.
08:24:32 <dons> Poor ##c has to put "Please be civil." in their topic :/
08:24:44 <ToRA|3> (how/can i get Tickable to be quantified for all m's?)
08:24:45 <SlowByte> twanvl: oh, haha, thanks
08:24:47 <astrolabe> That might be us soon
08:24:52 <shapr> astrolabe: I doubt it.
08:24:55 <jlouis> shapr, I can my group theory. But Ring theory eludes me for some odd reason
08:25:10 <shapr> jlouis: It's the same thing, like the tetration series, isn't it?
08:25:21 <augustss> ToRA|3: Are you sure you have the inheritance the right way around?
08:25:22 <dons> ToRA|3: looks like your alignment for tickM x = return (tick x) is wrong?
08:25:30 <astrolabe> shapr: if haskell becomes less of a hobby, and more something people need to know.
08:25:33 <dons> ah and that too
08:25:34 <shapr> All that magma, group, ring, etc stuff is just a few simple properties composed.
08:26:02 <jlouis> shapr, not really. A Ring contains a (commutative) group naturally, but what you can say for a group and for a ring differs quite much
08:26:11 <jlouis> of course they share a lot of properties
08:26:26 <shapr> astrolabe: Here's the puzzle, can you write one function that can generate the series from increment up to tetration and beyond from a single argument?
08:26:31 <astrolabe> Why do they call a groupoid a magma?
08:26:38 <shapr> astrolabe: melts your brain ;-)
08:26:57 <astrolabe> shapr: I tried it when I was an undergraduate, and couldn't.
08:26:58 <augustss> shapr: yes
08:27:41 <shapr> Ya know, I failed math oh so miserably in both high school and college. I couldn't make it through calculus even. I wish they'd told me it has these beautifully simple properties instead of trying to force me to memorize its results.
08:28:00 <augustss> shapr: they didn't know
08:28:11 <jlouis> that is a good reason
08:28:33 <astrolabe> The interesting bits are less useful for most people
08:28:34 <shapr> In that case, I wish I'd know you guys then!
08:28:55 <astrolabe> (haskellers excluded)
08:29:47 <shapr> Once I can decompose something into combinators, then it's easy to understand.
08:31:02 <astrolabe> shapr: That's an unusual opinion.
08:31:44 <shapr> That's what intuitive means to me at least.
08:32:06 <shapr> It means "give me a list of ingredients and ways to combine those ingredients, and then I will understand the implications."
08:32:21 <dons> ?users
08:32:22 <lambdabot> Maximum users seen in #haskell: 278, currently: 273 (98.2%), active: 38 (13.9%)
08:32:26 <shapr> And that is why Haskell is much more intuitive than Python for me.
08:32:31 <dons> mmm. could we break the record...?
08:32:36 <dons> ?users
08:32:36 <lambdabot> Maximum users seen in #haskell: 278, currently: 274 (98.6%), active: 38 (13.9%)
08:32:51 <ToRA|3> dons / augustss: [sorry for slow reply - thx for your replies] the inheritance is the right way round, its just that something that is Tickable (i.e. has a "pure" tick) can be called without the context of any monad, and so can be put into any monad with the return.  Something that is TickableM needs the monad and therefore can't necessarily be called without the context.  The complaint out of ghc i'm getting is my m variable 
08:33:10 <astrolabe> Judging by the last couple of years, there is a big spike in the new year.
08:33:31 <dons> astrolabe: you mean in january?
08:33:35 <astrolabe> dons: yeah
08:33:36 <dons> or later?
08:33:49 <astrolabe> I've lost the graph, but I got it from you
08:33:59 <dons> oh, hehe. ok.
08:34:00 <allbery_b> ToRA|3: you hit the 512-char limit
08:34:05 <ToRA|3> lol great
08:34:09 <allbery_b> (server enforced by truncation)
08:34:22 <vincenz> How do you get + on freenode-social
08:34:24 <allbery_b> "ghc i'm getting is my m variable"
08:34:25 <jlouis> dons, we are quite close, I'd think
08:34:37 <ToRA|3> ... i'm getting is my m variable doesn't exist is there a way to univerally quantifiy it?
08:35:08 <ToRA|3> allbery_b: cheers
08:37:17 <augustss> ToRA|3: so you want to define tickM that belongs to the superclass in the subclass?  no-can-do :(
08:38:04 <ToRA|3> augustss: so i can't do the tickM x = return (tick x) line?
08:38:14 <augustss> no
08:38:15 <vincenz> lift tick
08:38:23 <vincenz> lift $ tick x
08:38:42 <shapr> augustss: Ok, how? I'm trying to do "let series = func succ 0 $ replicate n x : func (tail series) 1 $ replicate n x " modelled on fib = 0 : 1 : zipWith (+) fib (tail fib) but I can't figure out how to make it work.
08:39:07 <ToRA|3> @type lift
08:39:08 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
08:39:17 <shapr> where func op base x n = foldr op base (replicate n x)
08:39:52 <augustss> shapr: You can always encode multiple arguments as one argument.  E.g., by zipping the bits for the args.  I didn't say it was going to be pretty.
08:40:00 <shapr> heh, ok
08:40:17 <dons> huh. that's pretty cool
08:40:18 <shapr> ooh, html dons!
08:40:35 <dons> you can click on the title on that stats page, and it launches a little irc java client
08:40:44 <dons> for the channel you're interested in
08:41:02 <dons-in-browser> testing....
08:41:32 <shapr> Is there some cute or generative way to figure out the unit value for each item in this series?
08:42:47 * shapr discovers a thread about this same subject that involves Tim Sweeney
08:43:10 <pejo> shapr, group theory, or did I miss a part of the discussion?
08:43:27 * shapr discovers it in dons' home directory!
08:43:28 <vincenz> Hmm, how often do they voice on freenode-social
08:43:30 <vincenz> I'm still unvoiced
08:43:34 <lisppaste2> augustss annotated #31891 with "A variation" at http://paste.lisp.org/display/31891#1
08:44:34 <vincenz> why not make a tickT?
08:44:38 <vincenz> TickT even
08:44:44 <vincenz> or implementing lifting
08:45:05 <ToRA|3> augustss: yeah, thats exactly what i wanted
08:45:05 <augustss> Sure, I just wanted to make the minimum change
08:45:34 <ToRA|3> augustss: cheers
08:46:15 <ToRA|3> vincenz: what do you mean? (point me at stuff to read if its simpler...i'm wanting to learn this kinda stuff)
08:46:20 <augustss> But why not make Tickable a superclass of TickableM?
08:47:00 <shapr> Interesting thread - http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg07547.html
08:47:00 <lambdabot> Title: Re: Tetration operator in functional programming
08:47:10 <lisppaste2> augustss annotated #31891 with "Another variation" at http://paste.lisp.org/display/31891#2
08:48:28 <ToRA|3> because not everything can be ticked outside of a monad context
08:48:41 <sorear> what can't?
08:48:55 <ToRA|3> so i have some things that read/write to IORefs in the code i've got
08:48:57 <sorear> a generic monad could be identity
08:49:29 <sorear> (sorry, misread the MPTC defn - I thought m was univ. quantified)
08:49:50 <ToRA|3> sorear: i wanted it to be univ quantified, but ghc was complaining that m was undefined
08:49:56 <augustss> ToRA|3: Yeah, but can't the thing inside the IORef be ticked?
08:50:25 <ToRA|3> not necessarily
08:50:50 <tobbes> greetings
08:51:04 <augustss> Wll, my first version isn't going to help you much either, unless you go for overlapping instances (which I dislike very much)
08:51:17 <tobbes> I know this is a stupid question before I even ask it, but has anyone here had any experience with hoar-logic?
08:51:29 <sorear> wWhat did the tickM look like back when GHC was compaining?
08:51:38 <sorear> tickM :: Monad m => a -> m a
08:51:41 <sorear> ??
08:52:03 <ToRA|3> sorear - the first item in the paste
08:52:46 <ToRA|3> ghc -fglasgow-exts ... Classes.hs:6:17: Not in scope: type variable `m' ... Classes.hs:9:2: `tickM' is not a (visible) method of class `Tickable'
08:53:48 <sorear> if it should work for any monad, why would the monad be referenced in the class header?
08:54:03 <sorear> class TickableM a where  tickM :: Monad m => a -> m a
08:54:11 <ToRA|3> no
08:54:15 <ToRA|3> it shouldn't
08:54:30 <ToRA|3> something can be an instance of TickableM for a specific monad
08:54:41 <ToRA|3> but if something is an instance of Tickable, then it is an instance of TickableM for any monad
08:55:05 <ToRA|3> (well at least that is the relationship i want i may be modelling it very badly)
08:56:35 <augustss> ToRA|3: try the one I sent first, it might do what you want
08:56:49 <ToRA|3> augustss: yeah i agree
08:57:00 <ToRA|3> augustss: cheers :)
08:58:00 <sachu> hi. I have a list of nodes of an undirected graph, like [a,b,c,d], and would like to generate the list of the edges of the graph, in lexicographic order, like [[a,b],[a,c],[a,d],[b,c],[b,d][c,d]] . What would be a simple way to do this in Haskell?
08:59:25 <augustss> sachu: is this a fully connected graph or do you have a list of edges too?
09:00:00 <sachu> augustss: this is a complete graph : i want to generate all the possible edges, in that order.
09:00:07 <sorear> sort $ filter (uncurry (<)) $ liftM2 (,) list list
09:00:36 <sorear> > (sort . filter (uncurry (<)) . join (liftM2 (,))) ["a","b","c","d"]
09:00:37 <lambdabot>  [("a","b"),("a","c"),("a","d"),("b","c"),("b","d"),("c","d")]
09:01:17 <sachu> sorear: thanks, although i don't understand a bit of what is happening. I will try to figure that out.
09:01:23 <augustss> [(x,y)|(x:xs)<-tails l, y<-xs]
09:01:37 <vincenz> Anyone know if it is possible to train short term memory?
09:01:42 <sachu> augustss: that is something i can hope to understand :-)
09:02:18 <augustss> I'm assuming your original list is sorted the way you want
09:02:37 <pejo> vincenz, you can use tricks to get it "connected", or simply learn "a lot" of patterns (like chessmasters).
09:02:57 <jlouis> audreyt, nice solution!
09:03:09 <jlouis> augustss, even
09:03:14 <augustss> :)
09:04:23 <emu> there's a "Transactional Memory" link posted on programming reddit, from "ACM Queue"
09:04:57 <sachu> augustss: thanks, and my original list (of vertices) is sorted in the way i want, but my hugs says "undefined variable 'tails'"
09:05:17 <jlouis> ?hoogle tails
09:05:18 <lambdabot> List.tails :: [a] -> [[a]]
09:05:18 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
09:05:26 <jlouis> its in List/Data.List
09:05:35 <sachu> jlouis: Thanks
09:06:24 <sachu> augustss, jlouis: thanks, it works after i loaded Data.List
09:06:43 <jlouis> the credit goes to augustss for coming up with that List comprehension
09:06:53 <vincenz> pejo: the problem is that I forget a LOT of stuff people tell me
09:06:59 <vincenz> pejo: it is a nuissance
09:07:22 <augustss> vincenz: sounds like you need better long term memory too :)
09:07:24 <jlouis> vincenz, the problem is that i remember a LOT of the stuff people tell me
09:07:32 <pejo> vincenz, my google fu is fialing me. I read an article about it a wihle ago, but can't remember the author.
09:07:35 <jlouis> ... but not the relevant stuff
09:07:49 <sorear> same here...
09:09:45 <vincenz> yeah well I forget pretty much everything people tell me
09:09:47 <vincenz> and then ask them again
09:09:50 <vincenz> looking like a dork
09:10:07 <emu> i usually forget people's names within the first 2 minutes of being introduced
09:10:11 <vincenz> augustss: for instance, I prolly asked you already, what do you do?
09:10:12 <xerox> you'd like a google search box on the upper right of every person eh
09:10:20 <vincenz> xerox: definitely
09:10:34 <vincenz> I'm good with faces, very good in fact
09:10:38 <augustss> vincenz: but since my memory is equally bad, I don't remember if you have :)
09:10:40 <vincenz> it's just the trivia they tell me that I forget
09:10:55 <augustss> vincenz: (I work at Credit Suisse, in case that was a real question)
09:10:58 <vincenz> (which is rather annoying as sometimes I forget what has been said in past meetings with my phd-advisor too)
09:11:10 <emu> bad memory has its upsides.  i can re-read my favorite books and enjoy them again.
09:11:10 <vincenz> augustss: oh right, where Heffalump will be starting (which I now know after having asked him a second time)
09:11:35 <augustss> yep
09:11:37 <vincenz> augustss: in haskell (which country, london as well?)
09:11:47 <vincenz> Do they do dev in Switzerland too?
09:12:28 <augustss> vincenz: I'm in NYC now, but I'll be in London next year
09:12:30 <rongenre> augustss: I read the piece about csfb using haskell as a wrapper for its C++ stuff
09:12:34 <vincenz> augustss: phd-grad?
09:12:52 <augustss> vincenz: Our group is in NYC, London, Hong Kong, Tokyo, and Sao Paolo
09:13:03 <vincenz> Ah I see
09:13:04 * vincenz hmms
09:13:12 <vincenz> NYC would be a nice change of venue
09:13:13 <glauber_sp> augustss, so paulo =)
09:13:27 <augustss> rongenre: if you read John Hughes summary, it's grossly inaccurate
09:13:50 <rongenre> augustss: this was from icfp, i think.. hosted at galois
09:13:54 <augustss> glauber_sp: Sorry.  I do know how to spell it :)
09:14:18 <glauber_sp> augustss, no problem. If it's in Brazil, it's So Paulo =)
09:14:22 <augustss> rongenre: yeah, that's the one, CUFP.  somewhat too optimistic report
09:14:25 <vincenz> augustss: phd-grad?
09:14:35 <glauber_sp> augustss, by the way, do you develop haskell stuff here?
09:14:39 <augustss> vincenz: Am I?  yes
09:14:56 <augustss> glauber_sp: of course, otherwise I would not be working there
09:15:09 * vincenz nods
09:15:13 <glauber_sp> augustss, really? where?? =D eheh
09:15:17 * vincenz repeats to himself in mantra-like fashion
09:15:27 <rongenre> augustss: ah.. can you say how so?
09:15:28 <glauber_sp> augustss, I thought there were no dev here in Brazil
09:15:41 <astrolabe> augustss: where do you work geographically?
09:15:49 <astrolabe> Ah sorry.
09:15:51 <augustss> glauber_sp: the GMAG group I belong to has a few people there
09:15:54 * astrolabe reads down
09:15:55 <augustss> I'm In New York
09:16:07 <astrolabe> augustss: do you know Tom Wilde?
09:16:31 <augustss> rongenre: the summary claimed that we are using Haskell in production for this and that.  But we don't, it's just the long term plan
09:16:43 <augustss> astrolabe: no, I don't think so
09:16:52 <glauber_sp> augustss, inside an university?
09:17:08 <astrolabe> Ah :( he works in credit risk or something, but nevermind :)
09:17:15 <augustss> glauber_sp: No, at the bank
09:17:59 <augustss> glauber_sp: GMAG is a weird group, not part of IT.  it works closely with the traders
09:18:09 <pejo> vincenz, http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?cmd=Retrieve&db=PubMed&list_uids=9677761&dopt=Abstract
09:18:12 <lambdabot> Title: Entrez PubMed, http://tinyurl.com/vnsdp
09:18:20 <pejo> vincenz, upper right corner you have "full text article".
09:18:28 <pejo> Interesting explaination, imho.
09:18:39 <pejo> (I'm in no way qualified to judge the scientific content of the article).
09:18:40 <vincenz> pejo: but does that work for social contexts?
09:18:40 <glauber_sp> augustss, hum, interesting. any website about it?
09:19:13 <augustss> glauber_sp: dunno, use google :)
09:19:23 <pejo> vincenz, that article is more of an explaination I think. The "courses" that teach how to remember stuff probably use that though ("chunk stuff").
09:19:25 <Igloo> A bit off-topic, but does anyone know if I can find out what memory a C FILE* thinks it has available (for buffering or whatever)?
09:19:30 <vincenz> me nods
09:19:53 <vincenz> Igloo: function-static, most likely?
09:20:13 <augustss> glauber_sp: GMAG has about 80 people around the globe.  70 or so has a PhD in physics or math
09:20:22 <Igloo> vincenz: Huh?
09:20:27 <vincenz> nm
09:20:53 <Cale> shapr: there's a fairly large qualitative difference between group and ring theory. Rings have two operations: addition (which is an Abelian group and usually easy to deal with on its own), and multiplication (which is a monoid and usually more subtle, but maybe not so bad) and they interact via distrubutivity.
09:21:02 <glauber_sp> augustss, what does GMAG mean?
09:21:17 <vincenz> Cale: disturbitivity?
09:21:28 <Cale> I can't type
09:21:32 <Cale> I just woke up :)
09:21:33 <augustss> glauber_sp: Global Modelling and Analytics Group
09:21:37 <Cale> distributivity
09:21:45 <glauber_sp> augustss, I'm just leaving graduation and entering my master course next year
09:21:51 <vincenz> Cale: I prefer my spell-check
09:21:53 <astrolabe> Cale: but to a non-mathematician, they have a lot in common.
09:22:13 <vincenz> astrolabe: sure, just like C and haskell do to a non-programmer
09:22:19 <Cale> Yeah, there's a lot in common there up until you start trying to prove things about them
09:22:43 <emu> is there a better option to ask for existential type support than -fglasgow-exts?
09:22:43 <astrolabe> I think your analogy exagerates the difference
09:22:50 <vincenz> astrolabe: most likely
09:22:56 <vincenz> humor :/
09:23:55 <glauber_sp> augustss, is it at UNICAMP university?
09:24:03 <liyang> shapr: from August -- http://cs.nott.ac.uk/~lyh/shae.jpeg
09:24:24 <augustss> glauber_sp: I have no idea.  I doubt it.  It's probably at the trading floor.
09:24:43 <glauber_sp> Credit Suisse ?
09:25:02 <augustss> yes
09:25:45 <vincenz> augustss: what specifically do you develop in haskell, or are you not at liberty to say?/
09:25:54 <augustss> emu: ghc has far too much lumped into -fglasgow-exts.  I want one flag per extension, because I don't want all the junk extensions.
09:26:04 <emu> augustss: i agree.
09:26:33 <augustss> vincenz: Right now I'm working on a DSEL that will generate Excel from a high level description.
09:26:58 <vincenz> Excel is an openformat?
09:27:10 <emu> for the sake of understanding the semantics fully, H98 + existential types, vs H98 + tons of stuff...
09:27:13 <augustss> The XML format is
09:27:16 <vincenz> ah right
09:27:20 <vincenz> That's new then
09:27:21 <vincenz> ?
09:27:26 <vincenz> (part of ODF?)
09:27:43 <augustss> the XML format is available in Excel 2003
09:27:57 <vincenz> Goes to show how often I use windows, alright thanks :)
09:28:22 <augustss> emu: I've had it happen that I added -fglasgow-exts and my program became syntactically incorrect. :(
09:28:29 <integral> (but it's not ODF, sadly)
09:28:36 <augustss> emu: Just because I wanted something very simple
09:28:49 <emu> yikes
09:35:10 <augustss> hmmm, I can feel my caffeine deficiency syndrome...
09:35:39 <pejo> Someone give him a proper cup of coffee, hurry!
09:35:57 <wy> Anyone has read "Modern Compiler Implementation in ML" and "Implementing Functional Languages"? I found the former quite conventional and not sure if it's worth reading if I have read the latter.
09:36:01 <pejo> Or won't that help?
09:36:07 * eamelink passes augustss a nice hot of tripple espresso
09:36:10 <eamelink> hot cup
09:36:11 <vincenz> pejo: intravenously!
09:36:12 <eamelink> that is
09:37:18 <augustss> wy: much of what they cover are different things, even if there's an overlap.
09:37:37 <augustss> But the Appel book has nothing to do with ML, except as an implementation language
09:37:39 <emu> wy: i did read the first (Appel)
09:38:03 <emu> frankly, i wasn't too impressed with the presentation of the material.  it was ok.
09:38:04 <wy> emu: How do you feel. I'm only starting
09:38:44 <vincenz> wy: the former is how to make compilers in general, it covers more than just FPLs, it is "Modern Compiler Implementations *IN* ML" not *OF* ML
09:38:46 <emu> i remember implementing the "graph coloring" register allocator, but not really getting a good understanding of it from the book
09:38:57 <emu> and what vincenz says, for sure
09:39:34 <emu> i think there was a chapter or two on techniques used to implement functional languages, but not much
09:44:40 <augustss> I like "Implementing Functional Languages", of course.  How could I not. :)
09:44:54 <pejo> Heh.
09:44:54 <emu> Appel has a book called "Compiling with Continuations"
09:45:01 <emu> that may be worth a loko
09:45:37 <shapr> liyang: thanks! That's the tower of london, right?
09:45:49 <augustss> Simon saved Thomas&me a lot of work by writing a book about what we had done. :)
09:47:04 <shapr> @yow !
09:47:04 <lambdabot> Those aren't WINOS -- that's my JUGGLER, my AERIALIST, my SWORD
09:47:05 <lambdabot> SWALLOWER, and my LATEX NOVELTY SUPPLIER!!
09:48:12 <SamB> emu: a crazy? you think it is worth a crazy?
09:49:07 <pejo> augustss, don't feel like it's time to brush it up for a second edition? :P
09:49:18 <shapr> Yeah! that would rock!
09:50:04 <augustss> that would be cool.  and so you suggest that this time I write a book on Simon's work? :)
09:50:29 <shapr> yeah!
09:50:37 <shapr> For example, the eval/apply stuff...
09:51:00 <arcatan> hmm, I could juggle
09:51:18 <Philippa> I'm fairly sure I "get" eval/apply, it's not too difficult
09:51:25 <shapr> arcatan: But can you typecheck juggling with Hudak's Labonotation DSEL?
09:51:30 <Philippa> but it's worth a newbie-oriented explanation
09:51:47 <vincenz> eval/apply
09:51:50 <vincenz> augustss: what had you done?
09:52:28 <vincenz> hmm, I meant to ask "What is eval/apply about"? with my first statement.  And of course I'm still curious to the independent question regarding augustss' work
09:52:34 <liyang> shapr: not a very towering tower, but that's what we call it. :)
09:52:39 <shapr> btw, does anyone know what Thomas Hallgren is doing these days?
09:52:59 <shapr> liyang: spiffy, thanks for extracting the picture
09:53:46 <shapr> I know the US ejected Hallgren much like Sweden ejected me... we discussed temporarily trading citizenship..
09:53:47 <augustss> vincenz: Thomas Johnsson and I did the LML compiler, which is the bulk of the stuff Simon's book is about?
09:53:47 <arcatan> Labonotation sounds funky
09:53:53 <vincenz> augustss: oh right
09:54:03 <vincenz> Lazy ML I presume?
09:54:25 <liyang> shapr: Sweden ejected you? When did that happen?!
09:54:29 <SamB_XP> shapr: he wasn't earning enouh wage taxes?
09:55:19 <shapr> liyang: Yeah, I wasn't paying enough taxes.
09:55:27 <shapr> liyang: I've been living in the US for months now.
09:55:27 <augustss> vincenz: yes, Lazy ML
09:55:42 <liyang> Ungrateful Swedes.
09:55:53 <shapr> Though I shall try to legally infiltrate again in a year or so.
09:57:10 <pejo> shapr, Hallgren is back in Sweden.
09:57:22 <shapr> I thought so, but where, and any idea what he's doing?
09:57:28 <shapr> I was wondering if he'd up for more House work...
09:58:01 <shapr> pejo: Do you know if his ogi email still works?
09:58:26 <pejo> shapr, oh, no idea about that. Doesn't he have his email adress on his "personal" homepage?
09:58:36 * shapr looks
10:00:48 <shapr> btw, did you guys ever convince beelsebob that monads aren't all about imperative programming?
10:02:31 <SamB_XP> shapr: the ones that aren't are somewhat silly
10:03:25 <Philippa> no? I think parsing monads are sensible
10:03:34 <Philippa> I don't think error handling's about imperative programming per se, either
10:03:40 <SamB_XP> hmm.
10:03:53 <shapr> I don't think any of them are silly. It's all about abstracting a traversal pattern.
10:04:04 <SamB_XP> I thought those were imperative!
10:04:34 <Philippa> parsing can be read imperatively, sort of, but really it's just the sequencing inherant in the grammar
10:04:36 <shapr> Is parser backtracking imperative?
10:05:14 <vincenz> imperative is badly defined
10:05:16 <SamB_XP> its like... (parse this *or* parse that)
10:05:44 <SamB_XP> doesn't that sound like the imperative to you?
10:06:01 <Philippa> it's equivalent to a straightforward description of the grammar, which sounds thoroughly declarative to me
10:06:02 <allbery_b> hrm.  the cvs haskell-mode interacts badly with emacs-desktop
10:06:16 <kosmikus> SamB_XP: map this, then map that ... :)
10:06:26 <allbery_b> I get an error from keymapp, apparently because something isn't fully initialized yet at that point
10:06:26 <SamB_XP> wave-particles!
10:07:29 <Cale> I really hope that beelsebob was joking, for his sake :)
10:07:46 <Philippa> once upon a time he definitely wasn't. We had a couple of big arguments
10:07:59 <SamB_XP> wave-particles!
10:08:02 <Philippa> in one of them, he had a go at monadic parsing entirely because he wanted a CST->AST transformation stage
10:08:31 <wy> augustss: http://en.wikipedia.org/wiki/Lennart_Augustsson. Is that you?
10:08:34 <Philippa> I pointed out that involves major code duplication in the traversals, which is every bit as big if not worse a no-no than mixing up grammar and the corresponding AST
10:10:11 <SlowByte> anyone need a JavaScript parser in Haskell? :)
10:10:13 <augustss> wy: that's me
10:10:42 <wy> augustss: Wow. You win the IOCCC three times!
10:10:48 <shapr> I didn't know you wrote the front end of pH
10:11:02 <augustss> wy: i'm bad at C programming ;)
10:11:06 <shapr> I also didn't know you did parts of lpmud.
10:11:45 <augustss> I was Lars Pensj's Master thesis advisor
10:11:54 <wy> augustss: Never thought I can meet a winner of IOCCC here!
10:12:06 <shapr> I knew about Bluespec.
10:12:15 <pejo> Heh, Of all the stuff listed you pick the winner of IOCCC as first thing to notice? :P
10:12:52 <shapr> augustss: If I run another IOHCC, will you submit an entry? :-)
10:15:01 <wy> Uhh... Because I awe things I can't understand, at least when I was an undergrad
10:15:35 <augustss> shapr: obfuscating Haskell is too easy ;)
10:15:47 <astrolabe> Do the judges need to understand the code?
10:15:58 <augustss> astrolabe: no
10:16:08 <shapr> augustss: prove it! :-)
10:16:30 <pejo> shapr, I thought the fp book was a better idea!
10:16:47 <wy> augustss: I guess the fp way will help writing obfuscating C code?
10:16:49 <shapr> pejo: Yeah, that's true.
10:16:58 <arcatan> IOCCC is lot more fun than implementing some theoretical programming languages, like, (ugh) Haskell
10:16:58 <Philippa> astrolabe: presumably it's better if they /don't/
10:17:00 <shapr> IOHCC is fun, but an FP book would be more useful.
10:17:07 <augustss> I spent more than a man-month on my last IOCCC entry.
10:17:10 <shapr> arcatan: no way dude
10:17:21 <shapr> arcatan: implementing Haskell is easy
10:17:27 <astrolabe> Somewhere on the web there are descriptions of maximally efficient turing machines, in the sense of finishing with the longest possible string of 1s for the number of states in the machine.  I found them really impossible to understand.
10:17:28 <Philippa> shapr: you've done it from scratch?
10:17:39 <augustss> shapr: easy, huh?
10:17:41 <Philippa> there's enough of it to be rather hard work...
10:17:42 <shapr> Philippa: No, but I watched Derek Elkins do most of it with the lambdabot plugin.
10:17:56 <Philippa> does it typecheck, do modules, etc etc?
10:17:58 <shapr> augustss: It's easy to implement but the naive result isn't that usable =)
10:18:07 <Philippa> the runtime bits going slowly isn't too hard, sure...
10:18:09 <shapr> It does typecheck, but doesn't do modules.
10:18:11 <Philippa> ...just tedious
10:18:18 <shapr> yeah, the result isn't very fast.
10:18:20 <augustss> shapr: it's the front end stuff that is time consuming.
10:18:23 <Philippa> using a pre-existing typechecker, by any chance? :-)
10:18:34 <Philippa> oh yeah. Especially if you want error messages that say more than "there was an error"
10:18:34 <shapr> hm, I think so.
10:18:39 <augustss> back end can be very easy, I agree
10:18:56 <shapr> Yeah, the polite user stuff is hard.
10:19:10 <augustss> but Haskell is a large language.  it takes a lot of work to handle all of it
10:19:14 <wy> I found that the code in "Modern Compiler Implementation in Java" is quite like those of "A Little Java, A Few Patterns". Are real Java programs like that?
10:19:30 <astrolabe> I thought haskell was quite small
10:19:38 <pejo> astrolabe, is that the busy beaver problem?
10:19:48 <Philippa> compared to lambda calculus + let + maybe case? No, no it's not
10:19:49 * SamB_XP would just write a turing machine that goes on to the right and makes 1s, never bothering to halt ;-)
10:19:49 <arcatan> ah, beavers
10:19:51 <astrolabe> depends what you're comparing to I s'pose
10:19:56 <shapr> I'd say that Haskell is a small language with a lot of syntactic sugar.
10:20:04 <astrolabe> pejo: yes.  thanks.  That's the name
10:20:22 <augustss> shapr: yes, and that sugar needs processing when you write a compiler.
10:20:27 <shapr> Yeah, it does.
10:20:38 <Philippa> it's worth noting that if you desugar sufficiently, you get more complication in the type-related declarations than the actual functions
10:20:48 <augustss> shapr: only someone who has actually written a haskell compiler from scratch is allowed to say it's easy. ;)
10:20:51 <Philippa> however, sugar's a PITA
10:20:57 <jlouis> I'd not call Haskell easy to implement
10:21:07 <Philippa> I think a complete interpreter's probably fair game too
10:21:08 <shapr> Even so, I was amazed when Derek Elkins whipped up a minimal Haskell-clone on top of a lambda calculus interpreter in less than a month.
10:21:08 <pejo> astrolabe, heh, the best reference of hte problem is a master thesis written in german.
10:21:21 <pejo> I wonder why people write their master thesis in german, it makes it horribly hard to read for hte rest of us. :-)
10:21:23 <shapr> Before that, I hadn't realized just how low level Haskell really is...
10:21:25 <augustss> compiler/interpreter it's the same to me
10:21:43 <Philippa> I dunno, one needs staging annotations :-)
10:21:47 <shapr> augustss: fair enough, I retract my statement that a haskell implementation is easy =)
10:22:09 <wy> augustss: Really? I thought compiler is a "translator", while interpreter is a machine
10:22:19 <augustss> shapr: you can make something Haskell-like on to of lambda-calculus easily
10:22:25 <jlouis> Monads are pretty low-level too as I see them
10:22:34 <shapr> jlouis: Yeah, I think so.
10:22:45 * Philippa hands shapr and jlouis a bunch of wires
10:22:45 <astrolabe> But someone who has implemented one from scratch is not going to minimalise his achievement by saying it's easy.
10:22:46 <shapr> augustss: I'd love to see a tutorial that builds such a thing up step by step.
10:22:51 <Philippa> /that's/ low-level
10:23:10 <augustss> wy: yes, but when someone says "a Haskell interpreter" they usually mean some kind of compiler to a lower level representation + an interprteter for that
10:23:12 <jlouis> Philippa, oh, thas to retro!
10:23:25 <Philippa> high-level is the new low-level?
10:23:33 <kosmikus> pejo: please, write letters to the German universities telling them so. there are still people in administration who're actually making it *difficult* for students who want to write their thesis in English ...
10:24:24 <augustss> kosmikus: I find it sad
10:24:24 <wy> augustss: I see. That's why I have been confused for a long time ;-)
10:24:47 <pejo> kosmikus, heh, I bet they'd toss it if I wrote it in english!
10:25:20 <Philippa> I got into an argument with a linux kid about what "object code" means that was finally settled when I clarified how the terminology applies in a "compile to smaller language, interpret" scenario
10:25:26 <kosmikus> pejo: possible, but hard to know.
10:26:47 <Philippa> I want to see a compilers book that covers techniques for desugaring and reporting errors that were detected in desugared code accurately in terms of the original source
10:26:50 <dylan> darn linux people.
10:27:02 <augustss> wy: and if you want to get confused even more you should look at the Futamura projections :)
10:27:06 <Philippa> dylan: he thought it meant "the stuff that goes in .o files"
10:27:33 <dylan> linux (the kernel) is really making me unhappy today.
10:27:49 <gour> anyone knows if it is true that (code) cancer cannot be cured as stated in http://www.haskell.org/pipermail/haskell-cafe/2006-December/020179.html ?
10:27:51 <lambdabot> Title: [Haskell-cafe] Re: Reversing a string of words: C# v Perl V Ruby v Haskell, http://tinyurl.com/y6eyx2
10:28:09 <allbery_b> FP chemo? :)
10:28:31 <augustss> http://en.wikipedia.org/wiki/Futamura_projection
10:28:55 <dylan> unwords . reverse . words?
10:29:01 <jlouis> mmmm, Futamura projections!
10:29:06 * allbery_b thinks it's more like alcoholism:  the recovering alcoholic must avoid all forms of alcohol, the recovering code "cancer" patient must avoid java and c++
10:29:22 <jlouis> Program Specialization!
10:29:37 <jlouis> I actually think of doing my Bachelors Degree on Program Inversion
10:29:46 <augustss> jlouis: I find myself writing partial evaluators at every job I have. :)
10:30:02 <augustss> some kind of...
10:30:06 <jlouis> which is quite closely related. It would make me able to hack Haskell code and write stuff
10:30:07 <pejo> augustss, traditional ones?
10:30:30 <augustss> pejo: not self-applicable ones
10:30:52 <pejo> augustss, but you do BTA, etc?
10:31:29 <augustss> No, all the ones I have done have been online PEs.
10:33:13 <augustss> But I guess it's no surprise.  I do compiler-like programs, and compilers are just a form of residualizer.
10:33:58 <wy> augustss: It looks like turn a program and a machine into a specialized machine only run this code.
10:34:20 <augustss> wy: that's right
10:34:56 <wy> augustss: When I was studying EDA, one of my colleagues is doing things about System C. I guess that's the kind?
10:34:56 <augustss> and if you specialize the specializers with an interpreter as input you get a compiler
10:35:14 <vincenz> oh, that's that lemma, isn't it
10:35:17 <vincenz> is that really true?
10:35:20 <augustss> yes
10:35:23 <jlouis> vincenz, yes
10:35:28 <jlouis> it works that way
10:35:46 <augustss> but it takes very careful crafting to do in practise
10:35:47 <jlouis> and if you layer a specializer on top of it, you get a compiler generator
10:36:38 <wy> augustss: very revealing observations. It makes me less confused ;-)
10:36:50 <augustss> jlouis: the whole thing is truly amazing.  i couldn't believe it when Neil Jones had just been able to do it the first time
10:37:29 <vincenz> what about that one page
10:37:35 <vincenz> where they specialize the specialized specializer
10:37:39 <vincenz> is that bs, or true
10:37:43 <augustss> true
10:37:56 <vincenz> but where is the part about the actual semantics encoded then?
10:38:15 <augustss> semantics about what?
10:38:17 <vincenz> not to mention the abstract syntax
10:38:21 <vincenz> of the language you're building a compiler for
10:38:44 <Philippa> the bit where you have to feed in an interpreter still, presumably
10:38:47 <jlouis> Neil Jones has some skills in that subject. I remember reading a subject on logic. Neil had made some papers which was a resume of the first 4 chapters. In 4 pages, he covered everything succintly and precisely.
10:39:28 <jlouis> I've actually had him lecturing a simple prog.lang. course. I did not show up though, because the stuff was too easy
10:39:40 <augustss> vincenz: to be able to do all these self applications you have to use the same language in many places.  that doesn't mean what the program does is trivial
10:40:00 <wy> augustss: specializers::Program+interpreter::Machine -> a. What's the type of a ?
10:40:44 <augustss> wy: you have to be very careful here, since you work on "program text", not programs
10:40:57 <vincenz> augustss: *nods*
10:41:30 <augustss> wy: I don't have the stamina to explain it here.  (how's that for a cop-out?)
10:41:51 <augustss> i'm sure you can find some good papers
10:42:04 <wy> augustss: confused again. What does interpreter mean here? Are they of type Machine or (Compiler,Machine) ?
10:42:23 <paolin1> why this derivation is illegal?
10:42:24 <paolin1> newtype TravelTree a = TT { runTT :: State (Loc a) a } deriving (Functor)
10:42:28 <pejo> wy, Sestoft (?) and others have a book from the mid 90's online somewhere, it's all about partial evaluation.
10:43:23 <paolin1> Can't make a derived instance of `Functor TravelTree'
10:43:24 <paolin1>     (even with cunning newtype deriving:
10:43:40 <augustss> wy: an interpreter has a type like AbstractSyntaxOfL -> Value
10:43:53 <wy> http://www.dina.dk/~sestoft/pebook/pebook.html
10:43:54 <augustss> wy: but this is not what you feed the PE
10:43:55 <lambdabot> Title: Jones, Gomard, Sestoft: Partial Evaluation
10:44:28 <monochrom> <3 #haskell
10:44:52 <augustss> wy: if the interpreter is written in M you need to feed the PE i::AbstractSyntaxOfM, where i is the expression for the interpreter
10:45:38 <augustss> wy: but most of the (early) PE work was done with LISP where you confuse all these things
10:46:32 <jlouis> Lisp or Scheme
10:46:37 <wy> pejo: I got the book! thanks. It seems more general than ordinary compiler books
10:46:52 <jlouis> I think Scheme was the first place to make such stuff
10:47:05 <jlouis> Can't remember if anybody ever got a ML-PE finished
10:47:11 <pejo> wy, oh, it's only about partial evaluation basically, not much compiler construction in the traditional sense.
10:47:13 <jlouis> it quickly gets very hairy
10:47:40 <augustss> jlouis: i'm not sure there's a self-applicable ML-PE
10:47:59 <wy> pejo: I'm just looking for a general way to interpret all the things about compilers and languages. I think more general ones can cover all the traditional ones.
10:48:25 <jlouis> augustss, there has been some attempts, I know. But unfortunately, people have not published papers no why they never finished.
10:48:32 <augustss> wy: you might like the first chapters of that book then.  if i remember right it covers the generals
10:49:35 <wy> augustss: Thanks a lot!
10:49:52 <xerox> Anybody has a precise idea of what is the eta-rule broken with that instance paolino can't do?
10:50:21 <sorear> the eta rule : f <==> \x -> f x
10:50:29 <augustss> jlouis: no, reporting failures is not popular
10:50:47 <xerox> vincenz: around?
10:51:03 <vincenz> pong
10:51:07 <shapr> augustss: That bothers me about academia
10:51:15 <xerox> sorear: so I can't hide the s parameter of State in a fixed monad type?
10:51:23 <shapr> Failures teach as much (and sometimes more) than successes.
10:51:27 <xerox> vincez, see top, it's the top! http://darcs.haskell.org/~paolo/darcs/tao/ZipNtree.hs
10:51:41 <augustss> shapr: true, but they are not as much fun to talk about
10:51:43 * xerox happily bounces because for the nice fixpoint he wrote
10:51:52 <xerox> s/because of/
10:51:57 <pejo> jlouis, didn't someone at diku do BTA for Standard ML as a master thesis or similar?
10:52:02 <vincenz> xerox: you sick sick bastard
10:52:05 <vincenz> :P
10:52:08 * xerox bounces MORE
10:52:12 * shapr grins
10:52:20 <xerox> do you like that shapr?
10:52:27 <shapr> I like bouncing....
10:52:35 <shapr> I'm afraid to look at the code because I'm hacking on HAppS...
10:52:40 <xerox> please do!
10:52:46 <shapr> Anything that causes that much bouncing will probably distract me.
10:53:14 <shapr> augustss: Seems silly to me. A failure teaches lessans that can be applied to just as much profit as a success.
10:53:17 <shapr> lessons*
10:53:24 <xerox> hacking HAppS sounds more useful than my zipper
10:53:32 <shapr> oj, min engelska suger :-P
10:54:12 <xerox> grokking fix is awesome
10:54:17 <shapr> teach me!
10:54:22 <xerox> why the hell I'm studying maths!
10:54:22 <shapr> I think I understand, but I'm never quite sure.
10:54:34 <shapr> fix point is quine?
10:54:44 * xerox disappears in a puff of logic
10:54:45 <Botje> w
10:54:47 <shapr> an input that produces itself as an output?
10:55:06 <wy> augustss: So is it the same things as Kleene's recursive function theory?
10:55:06 <augustss> shapr: but not quoted
10:55:13 <allbery_b> mrf.  and I kill emacs-desktop and get an error from define-derived-mode for literate-haskell-mode, about make-char-table having too many arguments.  feh.
10:55:20 <sorear> > (fix .) (:) 'x'
10:55:21 <xerox> f(f(f(f(..f(x)..)))) = y
10:55:22 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
10:55:27 <shapr> augustss: not quoted?
10:55:27 <Nafai> Hey all
10:55:28 <sorear> > (fix .) (++) 'Fix'
10:55:29 <lambdabot>  Improperly terminated character constant
10:55:30 * xerox applauds
10:55:32 <sorear> > (fix .) (++) "Fix"
10:55:33 <lambdabot>  "FixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFixFix...
10:55:39 <shapr> jag forstr inte. Vad betyder det?
10:56:00 <sorear> > (fix .) (tail) "Fixpoint"
10:56:01 <lambdabot>    Expecting a function type, but found `[a]'
10:56:02 <lambdabot>    Expected type: [a1] -> ...
10:56:13 <augustss> wy: well, yes and no.  if you look at it abstractly PE is trivial (currying).  but the reason for doing it is that you want real speedups, that's what makes it non-trivial
10:56:29 <shapr> augustss: r det lttare att tala svenska eller engelska fr dig?
10:56:33 <sorear> fix x = foldr (.) id (repeat x)
10:56:40 <shapr> I know, I should really take any swedish conversation to #haskell.se ...
10:57:01 <shapr> I wish I could find some Swedish speakers here in Birmingham, Alabama.
10:57:23 <augustss> shapr: oh, they both work pretty well.  there are situations where I can't find quite the right word in one language, but I know one in the other.  but it goes both ways
10:58:14 <xerox> sorear: can you fix tail?
10:58:21 <sorear> cycle = (fix . (++))  repeat = (fix . (:))  forever = (fix . (>>))
10:58:34 <shapr> My Swedish vocab is pretty small compared to my English vocab. And I'm really slow at reading Swedish.
10:58:39 <augustss> all functions of type T->T is a fixpoint
10:58:46 <augustss> s/is/has/
10:58:58 <shapr> ok
10:59:03 <sorear> ... but for most the least fixpoint is _|_
10:59:06 <augustss> yep
10:59:06 <shapr> And the fixpoint is where the value in is the value out?
10:59:13 <sorear> yep
10:59:29 <shapr> Can a function have multiple fixpoints?
10:59:34 <sorear> yes
10:59:42 <augustss> but there is a unique smallest one
10:59:42 <vincenz> but only one least fixed point, afaict
10:59:45 <sorear> id :: Int -> Int has at least 2^31
10:59:48 <augustss> in a particular ordering
10:59:49 <shapr> How is least fixpoint usually measured?
10:59:51 <shapr> ah, ok
10:59:51 <sorear> s/2^29/
10:59:55 <shapr> "in a particular ordering"
10:59:58 <road_> Hello
11:00:05 <shapr> hi road_, learning Haskell?
11:00:06 <astrolabe> hi
11:00:12 <augustss> yes, the ordering in the domain
11:00:23 <augustss> where _|_ is smallest
11:00:26 <road_> shapr: yes
11:00:34 <shapr> road_: Have any questions?
11:00:47 <sorear> in Haskell, I sense (proof will take longer) that functions with multiple fixpoints are always strict and thus have _|_ as leastfixpoint.
11:00:55 <road_> shapr: loosing the fight against it might be a better description
11:00:57 <shapr> So, what is a fixpoint usually used for?
11:01:14 <shapr> road_: Easy answer, stop fighting and hang out on #haskell!
11:01:15 <road_> shapr: :-)
11:01:27 <augustss> shapr: when T in T-->T is a function type it gets interesting
11:01:29 <shapr> road_: How far have you gotten so far?
11:01:37 <Philippa_> also, they're useful for knowing when to stop iterating
11:01:42 <wy> "partial evaluation of an interpreter with respect to a source program yields a target program"
11:01:46 <astrolabe> road_: it can be difficult.
11:01:55 <glguy_> fix is useful for writing anonymous recursive functions
11:02:03 <road_> sharpr: I'm wondering why this is not a valid function: test :: [IO String] -> [IO ()] ; test xs = xs >>= print
11:02:04 <shapr> augustss: I can understand that.
11:02:12 <shapr> road_: It's shapr, short for shaper
11:02:17 <xerox> Philippa_: very true, about iteration
11:02:39 <road_> shapr: sorry
11:02:42 <shapr> no worries
11:02:45 <xerox> Philippa_: if you want take a look at top http://darcs.haskell.org/~paolo/darcs/tao/ZipNtree.hs
11:02:53 <astrolabe> shapr: trying to put your card sharp days behind you?
11:02:54 <glguy_> road_: the type of: text xs = xs >>= print  -- would be Show a => IO a -> IO ()
11:03:05 <shapr> astrolabe: I've never been any good at cards :-P
11:03:11 <astrolabe> :)
11:03:17 <Philippa_> wy: trivial but fun example: write an interpreter in haskell, then use TH to stage-annotate it to achieve (trivial) partial evaluation
11:03:21 <shapr> Though Set is quite fun.
11:03:22 <road_> glguy_: that's what hugs is telling me, but why?
11:03:24 <Philippa_> bingo, you have a compiler
11:03:47 <astrolabe> @type print
11:03:49 <lambdabot> forall a. (Show a) => a -> IO ()
11:03:52 <sorear> ?let test = map (>>= print)
11:03:52 <shapr> @type fix
11:03:53 <glguy_> road_: Because print is in the IO Monad, and your code sugars to:
11:03:53 <lambdabot> <local>:1:16:     Ambiguous type variable `a' in the constraint:       `Show ...
11:03:54 <lambdabot> forall a. (a -> a) -> a
11:04:00 <glguy_> do { a <- xs; print a }
11:04:12 <sorear> ?let test :: Show a => [IO a] -> [IO ()] ; test = map (>>= print)
11:04:14 <lambdabot> Defined.
11:04:19 * xerox crunches butter cookies
11:04:26 <sorear> ^^ that has the type you want
11:04:45 <shapr> augustss: I think I read that Epigram 2 is planned to be strongly normalizing with fix added for 'production' use. Does that imply that fix is something that cannot be strongly normalizing?
11:04:45 <Philippa_> shapr: remember how I was hoping to get the Chairman's Game running at AngloHaskell?
11:04:48 <augustss> shapr: btw, a good way to think of the ordering used by fix is information content.  the less information, the smaller it is.
11:04:51 <glguy_> but unless you actually want a list of IO actions
11:04:54 <Philippa_> shapr: yes
11:04:58 <glguy_> road_: consider: mapM_ print xs
11:04:58 <Philippa_> fix gives you general recursion
11:05:14 <sorear> general recursion gives _|_
11:05:15 <augustss> shapr: general fix is not strongly normalizing
11:05:20 <wy> augustss: Are there any real products of PE?
11:05:37 <road_> glguy_: thanks, I will look that up
11:05:48 <augustss> wy: I wrote a PE for a peculiar language in 1996 that was in production for 10 years
11:05:55 <shapr> wow
11:06:02 <augustss> wy: for aircraft crew planning
11:06:05 <glguy_> ?type \xs -> mapM_ print xs
11:06:07 <lambdabot> forall a. (Show a) => [a] -> IO ()
11:06:10 <shapr> Hm, I read about that somewhere...
11:06:37 * shapr can't remember his mental entry for augustsson & aircraft crew planning
11:07:06 <shapr> augustss: Can you explain the information content idea in a different way?
11:07:12 <wy> augustss: That's good! Are you a professor?
11:07:16 <shapr> oh oh, I get it!
11:07:18 * shapr boings!
11:07:21 <Philippa_> shapr: (1, _|_) has less content than (1,2)
11:07:28 <shapr> yes yes, now I see!
11:07:36 <augustss> :)
11:07:53 <augustss> wy: I used to be
11:08:01 <shapr> So what's the least fixpoint usually used for?
11:08:17 <Philippa_> getting general recursion
11:08:22 <monochrom> for defining the meaning of recursion
11:08:25 <Philippa_> in the lambda calculus, in type systems, etc etc
11:08:27 <psnl> Philippa_: I would say that _|_as infinate information, all of it wrong ;-)
11:08:36 <shapr> http://en.wikipedia.org/wiki/Least_fixpoint says "Least fixed points often have desirable properties that arbitrary fixed points do not."
11:08:45 <glguy_> > fix ( (1:) . scanl (+) 1 ) -- fix is for generating fibs!
11:08:46 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:08:58 <monochrom> One such desirable properties is induction.
11:08:58 <Botje> glguy_: that's scary. :[
11:09:04 <shapr> monochrom: how so?
11:09:17 <augustss> shapr: of course, in Haskell you never really need fix since every let has a fix built in
11:09:23 <shapr> what?
11:09:37 <augustss> shapr: all let expressions are recursive
11:09:40 <glguy_> > let fibs = 1:scanl1 (+) 1 fibs in fibs
11:09:40 <sorear> fix f = let x = f x in x
11:09:41 <lambdabot>    The function `scanl1' is applied to three arguments,
11:09:41 <lambdabot>   but its type `(...
11:09:43 <Cale> You can write fix with let
11:09:58 <sorear> ?let fix f = let x = f x in x
11:09:59 <lambdabot> Defined.
11:10:01 <shapr> ohh, it's letrec
11:10:07 <wy> augustss: I never thought there will be professors on irc channels ;-)
11:10:08 <Cale> > let fix f = f (fix f) in fix ((0:) . scanl (+) 1)
11:10:08 <monochrom> the set of all natural numbers is the least fixed point of this equation: N = {0} U {succ x | x in N}
11:10:09 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:10:20 <augustss> wy: you'd be wrong ;)
11:10:28 <shapr> wy: Even so, I think #haskell is unusual.
11:10:51 <Philippa_> I could use a translation scheme for letrec sometime, I've been playing with some ideas that're "like let/letrec only not" and need to be able to implement the things sometime
11:10:51 <sorear> unfortunately, haskell does not support type Natural = fix n. Either () n
11:10:54 <glguy_> oops
11:10:54 <glguy_> > let fibs = 1 : scanl (+) 1 fibs in fibs
11:10:54 <glguy_> ?version
11:10:54 <glguy_> Am I disconnected, or is lambdabot busy?
11:10:56 <wy> augustss: you are the first professor here ;-)
11:10:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:10:56 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
11:10:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:11:06 <Cale> glguy_: you appear lagged
11:11:08 <fasta> Is there an alternative to let loop 0 = <do little stuff>;loop index; <handle index>;loop <some high-index>?
11:11:08 <shapr> So if Haskell had let that was not letrec, fix could not be defined in terms of that, right?
11:11:19 <Philippa_> right
11:11:21 <augustss> right
11:11:31 <monochrom> Only for the "least" guarantee, you have induction.
11:11:44 <sorear> fix x = (\a -> a a) (\a -> x (a a))
11:11:46 <augustss> if you have recursion nowhere and Haskell's type system you can't define fix
11:11:50 <wy> augustss: I guess I should read the book about PE first. Then try to cast the ideas onto other compiler books?
11:11:57 <sorear> except Haskell doesn't support fixtypes.
11:12:01 <monochrom> I highly recommend those papers by Roland Backhouse on this.
11:12:42 <augustss> wy: it's not really knowledge that helps you write a compiler.  but it helps you understand the bigger picture
11:13:00 <shapr> sorear: That's a modified omega?
11:13:19 <augustss> yeah, kinda
11:13:20 <Philippa_> shapr: Y is, yes
11:13:26 <wy> augustss: That's really big. A kind of philosophy I was looking for
11:13:30 <augustss> but there's an infinite number of definitions that work
11:13:57 <Philippa_> is Y the "least", for some value of least?
11:14:04 <shapr> so, the Y combinator is fix?
11:14:09 <shapr> Hm, that makes sense.
11:14:10 <Philippa_> is one implementation thereof, yes
11:14:24 <augustss> Philippa_: yes, i think it is, in the number of expression size
11:14:42 <augustss> (I could make sentences once)
11:14:52 <Philippa_> 'sok, I can still read it
11:15:10 <monochrom> Depends on which book you read.  Some books do not require (and do not need) Y to be least.  Some other books do.  Depends on how much the book proves about Y.
11:15:31 <Philippa_> ...does H98 have reserved words per se, or just names it'd be daft to use for identifiers?
11:15:37 <shapr> monochrom: I didn't really understand your comment about natural numbers as least fixpoint, but I'll put that in my notes and get back to it sometime.
11:15:40 <Philippa_> (guess who's writing a parser for a language with a let statement?)
11:15:49 <sorear> infix{r,l,}
11:15:50 <augustss> Philippa_: they are reserved
11:15:53 <glguy_> > let let = 1 in let -- reserved?
11:15:53 <lambdabot>  Parse error
11:16:00 <Philippa_> augustss: annoying right now, but *good*
11:16:17 <augustss> non-reserved keywords is a parsing disaster
11:16:31 <augustss> at least when something goes wrong
11:16:47 <sorear> newtype F a = F (F a -> a) ; omega k (F f) = k (f (F f)) ; fix k = omega id (F (omega k))
11:16:54 <Philippa_> :-) Yeah, though I think for an otherwise tame grammar parsec'll produce sane error messages still
11:17:02 <Philippa_> user-ambiguity, OTOH...
11:17:04 <augustss> PL/1 had no reserved word.  The motivation was that there were too many keywords for people to remember
11:17:10 <Philippa_> heh
11:17:14 <sorear> there - no code recursion, no inferred fixtypes, fix.
11:17:24 <augustss> sorear: but a recursive type
11:18:47 <sorear> This was posted on -cafe@ a while back, I am not the inventor.
11:18:53 <pejo> wy, you might be interested in some papers by Turchin on supercompilation too.
11:19:17 <augustss> sorear: it's a well-known trick.  it can also make ghc loop :)
11:21:14 <shapr> wow - http://en.wikipedia.org/wiki/Category:Fixed_points
11:21:16 <lambdabot> Title: Category:Fixed points - Wikipedia, the free encyclopedia
11:21:18 <monochrom> Sample PL/I code.  if if=then then then=else else else=if.  My favourite.  some of those if, then, else there are variables, the others the syntax for if-then-else.
11:21:20 <wy> pejo: I can't find his homepage. can you give me a pointer?
11:21:46 <augustss> @yow
11:21:47 <lambdabot> Hmmm ... A hash-singer and a cross-eyed guy were SLEEPING on a deserted
11:21:47 <lambdabot> island, when ...
11:21:48 <pejo> wy, don't think he has a homepage. The PE book briefly talks about supercompilation and gives some references.
11:22:35 <paolin1> xerox, what about the newtype ?
11:23:04 <xerox> I have fix implemented in lojban...
11:24:27 <psnl> dons: I meant to ask, do you do hac registation  automaticly?
11:25:02 <xerox> > fix (\f n -> case n of 0 -> 1; 1 -> 1; n -> f (n-1) + f(n-2)) 10 -- fasta
11:25:04 <lambdabot>  89
11:25:20 <wy> pejo: I'm wondering what's the distribution of guys doing those things. It seems most PL professors here are doings trivial things on Java
11:25:29 <xerox> fasta: that was exactly my enlightenment before :)
11:25:58 <fasta> xerox: ?
11:26:17 <pejo> wy, http://tunes.org/wiki/Supercompilation contains some refernces to the articles I was thinking about.
11:26:19 <lambdabot> Title: Supercompilation - TunesWiki
11:26:20 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 10
11:26:22 <lambdabot>  3628800
11:26:28 <paolino> xerox shoud I reinstantiate all the classes  for the TravelTree ?
11:26:38 <xerox> 19:03 < fasta> Is there an alternative to let loop 0 = <do little stuff>;loop index; <handle index>;loop <some high-index>?
11:26:56 <xerox> paolino: what classes?
11:26:59 <fasta> xerox: ok, I didn't see your reply (-- fasta)
11:27:08 <SlowByte> there was some paper that generalized different types of PE... from ordinary PE to "generalized partial computation(?)"
11:27:16 <fasta> xerox: the same works with mfix?
11:27:17 <paolino> Functor , Monad, MonadState .....
11:27:34 <xerox> fasta: for mfix ring the bell of mr. monochrom
11:28:13 <sorear> > mfix (x -> [x,' ',x])
11:28:14 <lambdabot>  Parse error
11:28:17 <sorear> > mfix (\x -> [x,' ',x])
11:28:18 <lambdabot>  Exception: <<loop>>
11:28:46 <pejo> wy, ftp://ftp.diku.dk/pub/diku/users/jpsecher/perfectscp.ps.gz is a bit more verbose and contains lots of information too.
11:28:47 <sorear> > mfix (\x -> [' ',x])
11:28:49 <lambdabot>  Exception: <<loop>>
11:29:25 <pejo> wy, I didn't understand your question about distribution though.
11:29:59 <wy> pejo: It seems they are mostly in Europe ?
11:31:08 <monochrom> loop = fix (\lo n -> do { little; lo (n+?); ?; lo (n+??) })
11:31:21 <monochrom> You don't need general mfix yet.
11:32:20 <monochrom> general mfix is when you want along the line of do { ... x <- f x; ... }
11:34:25 <paolino> :t fix
11:34:26 <lambdabot> forall a. (a -> a) -> a
11:39:00 <SlowByte> meant that: http://citeseer.ist.psu.edu/uck96roadmap.html
11:39:01 <lambdabot> Title: A Roadmap to Metacomputation by Supercompilation - uck, rensen (ResearchIndex)
11:39:12 <wy> pejo: So is supercompiling more general?
11:39:27 <int-e> @users
11:39:27 <lambdabot> Maximum users seen in #haskell: 282, currently: 282 (100.0%), active: 42 (14.9%)
11:39:48 <jlouis_> boom!
11:40:00 <pejo> wy, the original papers weren't written in english, and the mid 80's ones (english) probably use non-standard notation.
11:40:06 <int-e> 282?!
11:41:24 <pejo> wy, I haven't read any of them. People at DIKU investigated the difference in the mid 90's though.
11:41:31 <augustss> @users
11:41:32 <lambdabot> Maximum users seen in #haskell: 282, currently: 281 (99.6%), active: 41 (14.6%)
11:41:43 <augustss> hey, new record :)
11:41:55 <int-e> but it sees 2 too many ... sigh.
11:42:07 <int-e> I think.
11:42:23 <Cale> http://haskell.org/haskellwiki/Image:Nick-activity.png
11:42:24 <lambdabot> Title: Image:Nick-activity.png - HaskellWiki
11:42:30 <sieni> I think I think, therefore I think I am. I think.
11:43:10 <psnl> sieni: deep insight there, but you need one less recursion
11:43:41 <augustss> there must be something monadic in that statement
11:43:48 <augustss> the, I think-monad
11:44:30 <SlowByte> wy: did you check out that paper? eg. page 13... don't know if it is useful, but it was insightful to me a long time ago :)
11:44:35 <sieni> I think I think I think, therefore I think I think I am. I think I think. I think.
11:45:16 <xerox> > fix ((. next) . uncurry . ((. (:)) . flip (.))) `fmap` newStdGen
11:45:18 <lambdabot>  <IO [Int]>
11:45:18 <monochrom> You want a modal logic.
11:45:22 <xerox> ^_^
11:46:00 <augustss> monochrom: but some modality axioms correspond to monadic ones
11:46:08 <xerox> hand-written points-free doesn't-make much-sense.
11:46:53 <augustss> xerox: nor-do machine-written
11:46:57 <xerox> but that is a list of random numbers which is nice
11:47:02 <monochrom> they overlap somewhat.
11:48:02 <wy> SlowByte: I got that paper. not read yet
11:49:01 <augustss> xerox: is there something wrong with the randoms function?
11:49:11 <xerox> duh.
11:49:12 <Philippa_> argh, the haddock docs for Parsec don't include instances. So I don't know if it's an instance of Functor or not
11:49:27 <xerox> augustss: is "its implementation" a sufficient.. erhm.
11:49:54 <Botje>  tw
11:49:57 <Botje> argh
11:50:02 <Botje> damn laggy window manager
11:50:52 <Philippa_> (it is, thankfully)
11:51:15 <Philippa_> though I can't help wanting a nice operator for `fmap`
11:51:25 <augustss> (.)
11:51:26 <augustss> ?
11:51:31 <Philippa_> would be nice, yeah :-)
11:52:06 <augustss> well, why roll your own Prelude then? :)
11:52:26 <Philippa_> sure, lemme just write an interpreter for the language in question first :-)
11:52:28 <augustss> rename fmap to (.)
11:53:24 <Philippa_> yeah, except then you want an instance for the identity functor and it all falls over
11:53:44 <augustss> yeah, that's a bit sucky
11:54:02 <augustss> but no worse than what we have today
11:54:57 <Philippa_> I dunno, I suspect it'd still be the majority use case if it magically worked
11:55:09 <Philippa_> guess I wait for my text editor to do better unicode support and use another char
11:55:39 <Cale> One problem with writing your own prelude is that if you replace classes, then using libraries becomes a pain.
11:56:16 <augustss> I guess you need special version of those too
11:56:28 <Philippa_> `fmap` will have to do for now
11:56:52 <Philippa_> much as I'd love to eg use * and ditch it for multiplication :-)
11:57:05 <Philippa_> bloody numbers, nobody actually uses them...
11:57:07 <Cale> You can set (.) = fmap and things work just fine
11:57:18 <Cale> so long as you have the reader instance
11:57:20 <liyang> There's <$> in Control.Applicative
11:57:49 <Philippa_> liyang: cool, thanks. But a bit risky in the middle of a pile of Parsec code where all the Parsec operations are <something>
11:57:58 <Cale> > let (.) = fmap in (+1) . (*3) . [1,2,3]
11:57:59 <lambdabot>  Couldn't match `(->) a' against `[]'
11:58:33 <augustss> It would be interesting to make a new Prelude design.  And get some things right.
11:58:33 <Cale> > let (.) :: (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in (+1) . (*3) . [1,2,3]
11:58:34 <Philippa_> I guess nobody's using .. :-)
11:58:35 <lambdabot>  [4,7,10]
11:58:42 <Cale> bloody MR
11:58:43 <liyang> > [1..]
11:58:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:58:51 <Philippa_> augustss: is that meant to sound quite as damning as it does? :-)
11:58:59 <Cale> augustss: I'm considering forking fptools
11:59:03 <Philippa_> liyang: D'oh
11:59:12 <augustss> Philippa_: yes, it was
11:59:30 <augustss> well, maybe not, now when i read it again
11:59:30 <Cale> There were too many people who hated polymorphism on the Haskell 98 committee.
11:59:53 <augustss> Philippa_: I should have said "and get some different things right" :)
12:00:17 <Philippa_> mmm. The best cynic is also a metacynic, no?
12:00:22 <augustss> I'm actually full of admiration for the Prelude.  It was written a long time ago, and still works ok
12:00:25 <Cale> I'd settle for getting as much right as the Haskell 1.4 prelude did
12:01:13 <augustss> But as DSEL user I wish for some things to be different
12:01:25 <augustss> or DSEL implementor, for that matter
12:01:26 <Ogedei> does lambdabot have a special way of printing lists that stops at some point, or did it solve the halting problem?
12:01:38 <Philippa_> Ogedei: haskell's a lazy language, it doesn't have to
12:01:54 <Philippa_> it just has to take the first n characters
12:02:04 <astrolabe> hey.  I use numbers!
12:02:22 <Philippa_> augustss: do you have a list of the things you'd like changed somewhere? One you keep reasonably up-to-date, preferably? :-)
12:02:35 <xerox> one shall note that those two possibilities have got euivalent probabilities, yuck.
12:02:37 <augustss> No, I should keep one.
12:02:38 <Ogedei> Philippa_: ahh, so it works for other data types too? what if you give it an infinitely recursive program that doesn't print?
12:02:40 <xerox> *equivalent
12:02:50 <Philippa_> Ogedei: then it'll time out
12:03:12 <xerox> > let (.) :: (Functor f) => (a -> b) -> (f a -> f b); (.) = fmap in (+1) . (*3) . [1..]
12:03:14 <lambdabot>  [4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,79...
12:04:13 <pejo> Philippa_, heh, I asked a related question just a week ago. :P
12:04:25 <augustss> Philippa_: some of my pet peeves are the gratutious superclasses in the prelude.  and i'd like overloaded booleans.  and overloaded list syntax.
12:04:56 <augustss> (I already implemented overloaded string literals)
12:05:37 <augustss> > show []
12:05:38 <lambdabot>  Add a type signature
12:05:52 <astrolabe> augustss: overloaded (:) how?  streams?
12:06:19 <augustss> astrolabe: I just want to be able to use the [x,y,,z,..] syntax for non-lists
12:07:00 <Philippa_> I might have finally found a good use for views that isn't solved by transformational patterns...
12:07:11 <augustss> you can say that '[x,y,z,...]' desugars to 'fromList (x:y:z:...)'
12:07:13 <Philippa_> ...except I probably haven't, because thinking about it it's GADT-related and the unification'll all drop out
12:07:51 <Philippa_> ("pattern-match on this view of the value to figure out one of the type variables, then use the original value with the more accurate type")
12:08:24 <augustss> Philippa_: sounds intriguing
12:09:04 <augustss> @users
12:09:05 <lambdabot> Maximum users seen in #haskell: 282, currently: 282 (100.0%), active: 39 (13.8%)
12:09:26 <Philippa_> augustss: amazingly it was Achilleas' fault I thought that one up
12:09:57 <augustss> Philippa_: because if his whining? :)
12:10:08 <wy> SlowByte: I have read parts of the paper. It seems also have something to do with loop detection?
12:10:16 <Philippa_> everyone panicking about control paths using linear types plus a GADT-like solution to ensure various invariants, as if our type systems can't go "oh look, unify here and it needs some polymorphism, d'oh"
12:10:59 <Philippa_> so, one example'd be matching on whether a file handle (with a phantom type covering the same info) is open or closed
12:11:02 <augustss> Philippa_: you need to write this down so we can read
12:11:20 <Cale> Ogedei: Haskell only ever does as much work as necessary to compute what it needs to display. Strings are generally displayed one character at a time, or at least in manageable chunks, so demand for the result of a computation doesn't happen all at once.
12:11:31 <Philippa_> augustss: meh, I keep failing to find a good scratchboard for ten-liners
12:11:37 <Philippa_> one-liners just go in chan...
12:11:47 <Cale> lisppaste2: url
12:11:48 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:12:03 <augustss> a wiki page perhaps?
12:12:19 <augustss> i'd love to see a place that collects clever 10-liners
12:13:38 <lispy> Philippa_: i need to read up on GADTs are there any must read papers you recommend?
12:13:45 <Philippa_> okay. Suppose we have a type Handle state, where state's one of OpenState or ClosedState. And a (HandleState state) type that's Open | Closed. Finally, a function handleState :: Handle handlestate -> HandleState handlestate...
12:13:53 <Philippa_> lispy: what do you need to know?
12:14:03 <Philippa_> just how to use? The GHC docs probably contain most of what you need to know
12:14:27 <lispy> Philippa_: well, i need to understand them pretty throughly
12:15:00 <Philippa_> Open always :: HandleState OpenState, Closed always :: HandleState ClosedState (surprise surprise)...
12:15:21 <augustss> lispy: Tim Sheard has some nice examples using Omega
12:15:25 <Philippa_> anyway, if you pattern-match on (handleState someHandle), you refine the phantom type attached to someHandle
12:15:34 <Daveman> We meet again, Mr. Cale.
12:15:40 <Philippa_> because it unifies with the one in the result
12:15:42 <shapr> I do wish Achilleas would read my response to his sincere comment.
12:15:53 <shapr> Especially since I can't login to blogger to post it :-(
12:16:11 <lispy> Philippa_: this section of the ghc manual? http://web.mit.edu/ghc/www/users_guide/gadt.html
12:16:12 <lambdabot> Title: 7.5. Generalised Algebraic Data Types
12:16:13 <Philippa_> this is /almost/ the standard GADT usage, just with a projection func in the middle
12:16:38 <Philippa_> lispy: yeah. That's pretty much everything you need to know
12:16:49 <Philippa_> augustss: that making sense?
12:16:49 * Daveman waves to xerox
12:16:50 <lispy> Philippa_: thanks
12:17:01 * shapr particles to Daveman 
12:17:12 <Philippa_> (obDisclaimer: I've not coded it yet)
12:17:12 <lispy> Philippa_: i'm also looking at the wikibook and i'll check out Tim Sheard as augustss mentions
12:17:13 <augustss> Philippa_: hmmm, yes, i think so.
12:17:43 <lispy> but i don't know omega so i don't know if i'll get much from that
12:18:02 <augustss> lispy: is much like Haskell
12:18:04 <Philippa_> now, if you /also/ have linear types so the handle's always got the current state attached, that's rather useful. OK, so then you have to mess about with the projection a bit more unless you can convince the type system that this "isn't really a use"
12:18:12 <lispy> oh, right i tihnk i read that paper once, the putting curry-howard to work
12:18:26 <augustss> lispy: yes
12:18:35 <Philippa_> but that's linear types for you, and not my problem :-)
12:18:42 <Philippa_> anyway, people were freaking about this being too hard for the compiler on LtU
12:18:50 <augustss> Philippa_: yeah, i'd like to play with linear types some time
12:19:25 <shapr> I wish edwarkk would throw down some code for his linear/unique substructural type system.
12:19:26 <Philippa_> I'm wondering whether I managed to shut atbusbook up with my response to the "rope" posts or the response just got censored, btw :-)
12:19:27 <augustss> Many LtU readers don't know what modern type systems can do.
12:19:50 <pejo> augustss, maybe you should become an editor? ;)
12:19:59 <augustss> I thought atbusbook got censored?
12:20:01 <Philippa_> that, and you get the handwavers who don't understand why I'd want both linear types /and/ monads...
12:20:05 <shapr> David Teller has written some papers and LtU posts about type systems for resource control.
12:20:23 <Philippa_> yeah, but in a "we have to approve posts" way rather than a "your posts > /dev/null" way
12:21:05 <augustss> yes
12:21:54 <Philippa_> (for those not reading: I pointed out that good rope can also be used for self-restraint)
12:22:12 <Philippa_> (in response to the usual "you want enough rope to hang yourself with" stuff)
12:23:22 <integral> To hang yourself you don't *just* need rope, but somewhere convenient to hang it from.
12:23:24 <lispy> yes and humans can weave rope out of pretty much anything if they really want to
12:23:29 <astrolabe> Philippa_:    How out of character :)
12:23:45 * shapr grins
12:23:46 <vincenz> all we need now is binkley
12:24:19 <int-e> hmm. is programming like building a tower out of rope?
12:24:49 <lispy> int-e: i've never tired the tower building to test the metaphore
12:26:06 <int-e> "you see it works fine here on the floor, now all we have to do is to prop it up."
12:26:53 <lispy> heh
12:30:36 <newsham> morn'n
12:34:50 <newsham> i've been rewriting a smallish web app from python to haskell.   i'm not done yet and its somewhat larger than the python version :(
12:35:25 <newsham> in terms of line count its about on par, but in terms of character counts its a bit larger
12:37:19 <LoganCapaldo_> newsham, use shorter variable names, <g>
12:37:58 <newsham> shorter than "m", "a" and "o"?
12:38:06 <Philippa_> newsham: this doesn't surprise me much
12:38:07 <newsham> does haskell support fractional character var names?
12:38:17 <Philippa_> is it easier to follow the code in Haskell?
12:38:29 <newsham> philippa: in some ways yes in some ways no.
12:38:33 <Philippa_> and how close's the rewriting been - had time to look at refactorings that're saner in Haskell yet?
12:38:55 <newsham> i'm still writing so not a lot of time rewriting yet.. but i have rewritten some parts a few times
12:39:10 <newsham> hopefully part of it is due ot me not being an experienced haskell coder.
12:39:16 <Philippa_> mmm. What's the total linecount likely to look like?
12:39:21 <Philippa_> yeah, experience helps
12:39:28 <newsham> 1630 lines, 9011 words, 58780 chars.
12:40:07 <newsham> python is 1758/5621/48179 (including presentation templates, which in haskell i've done in haskell code)
12:40:12 <Philippa_> if you're using Text.Xhtml I'd thoroughly advise looking for patterns you can factor out, btw
12:40:37 <Philippa_> the templates I did for Flippi were... tedious
12:40:39 <newsham> presentation is definitely a good chunk, but its not that bad:    604  3684 24699 Templs.hs
12:40:52 <Philippa_> the factoring helps readability too :-)
12:41:23 <newsham> the presentation is already pretty well factored (i had decent templates in python and replicated some of that)
12:42:13 <newsham> things like "for" iteration, "if" conditionals, several layers of template nesting (page uses several components which in turn use several components)
12:42:18 <Philippa_> hrmm, wish the GHC docs came with the Parsec manual as opposed to just the haddock
12:42:35 <Philippa_> cool
12:42:53 <newsham> (i'm pretty happy with using haskell as an HTML templating library.. that parts been fairly nice)
12:44:17 <Philippa_> which bits feel messy?
12:44:30 <newsham> the part I feel the least comfortable with so far is state management.
12:44:56 <Philippa_> ah
12:44:59 <Philippa_> that figures
12:47:41 <augustss> @users
12:47:41 <lambdabot> Maximum users seen in #haskell: 284, currently: 282 (99.3%), active: 39 (13.8%)
12:48:28 <Philippa_> what's your current approach?
12:49:01 <Philippa_> and I assume we're talking about state between CGI requests rather than mid-execution? Otherwise I'll just tell you to pick a monad :-)
12:51:51 <astrolabe> How do I write a binary file in haskell?
12:52:29 <Philippa_> "with great difficulty"
12:52:39 <Philippa_> what things do you need to put in it?
12:52:45 <astrolabe> Philippa_: I hope you are kidding.
12:52:53 <Philippa_> there're IO operations on one of the unboxed array types...
12:53:20 <Philippa_> some, rather than great
12:53:20 <astrolabe> At the moment I just want something that takes less space than text, and stores Doubles
12:53:28 <Philippa_> that's probably not too bad then
12:54:05 <astrolabe> How does ghc output an executable if binary is so difficult?
12:54:16 <augustss> it doesn't
12:54:25 <newsham> phil: i'm using HAppS, it provides a monad with application state.
12:54:26 <augustss> it generates assembly code
12:54:27 <Philippa_> scratch that, word8 only
12:54:50 <Philippa_> newsham: 'k. I don't know HAppS. Btw, I'd appreciate it if you don't shorten my nick in ways that change my gender :-)
12:55:14 <newsham> my apologies ph.
12:55:55 <astrolabe> Hmmm. That's a bit restrictive, but thanks anyway.
12:56:11 <augustss> astrolabe: there are various libraries for binary files
12:56:33 <astrolabe> augustss: That's good, I was going to ask if that would be hard to write.
12:56:46 <astrolabe> Do you have any names?
12:57:44 <augustss> i've not used any of them
12:58:00 <astrolabe> I can hunt in the communities report
12:58:17 <astrolabe> I've got an interesting problem
12:58:45 <augustss> http://hackage.haskell.org/trac/haskell-prime/wiki/BinaryIO
12:58:48 <lambdabot> Title: BinaryIO - Haskell Prime - Trac
12:58:57 <astrolabe> I've got a large dataset that I want to put into a tree structure (something like a binary tree).
12:58:59 <vincenz> +spb> because monads are a nasty hack to get around a language deficiency
12:59:11 <vincenz> @remember spb [in ##freenode-social] because monads are a nasty hack to get around a language deficiency
12:59:33 <augustss> heh
12:59:36 <newsham> happs handles most protocol processing, runs an action (Ev SomeState Request Response) with the parsed path.  the response has the resulting page and any cookies, the Request is state that has access to all the request details (cookies, headers, etc)
12:59:42 <astrolabe> But it is too big to fit in RAM, so I want the tree to be stored in files, which are read in to /out of, as needed.
12:59:52 <astrolabe> augustss: thanks
12:59:57 <newsham> and handles atomicity and persistence of the application state
13:00:05 <newsham> pretty decent framework
13:00:48 <astrolabe> But I'm wondering what a search through the tree would like
13:01:13 <augustss> vincenz: poor monads... misunderstood
13:01:19 * vincenz nods and sighs
13:01:20 <astrolabe> I'd like to write it as a pure function, and somehow have the tree take care of the IO.
13:01:43 <newsham> ?where newbinary
13:01:44 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
13:02:05 <augustss> astrolabe: well, you can't do what you want without unsafePerformIO
13:02:35 <sorear> Is your dataset < or > than 3GB?
13:02:38 <astrolabe> But I'd need quite a lot of control over exection order to make sure that each file is cleaned out of RAM before the next one is read in.
13:02:48 <sorear> Do you have a 32-bit processor?
13:03:00 <astrolabe> augustss: Is there a way to see why not?
13:03:29 <augustss> you want a pure function, but you want to do iO in it.  it's just not possible
13:03:45 <astrolabe> augustss: let me say what I meant a bit more clearly
13:04:14 <astrolabe> I want to write a function   search :: Query -> Tree -> Result
13:04:48 <astrolabe> and then use an IO Tree to take care of the IO
13:04:53 <savanni> very quick, random question...
13:05:14 <SamB_XP> astrolabe: unsafeInterleaveIO?
13:05:17 <sorear> how big is this Tree?
13:05:31 <savanni> If I want to use the "read" function in the REPL, how do I tell it that the target var is a ClockTime?
13:05:45 <astrolabe> do {tree <- myTree;res <- search q tree; return res}
13:06:04 <augustss> astrolabe: ok, that sounds fine
13:06:09 <sorear> astrolabe: about how large is your tree, in GBs?
13:06:16 <astrolabe> sorear: I don't know yet, but I'm thinking of it as a library function.
13:06:41 <kzm_> savanni: let x = read y :: ClockTime
13:07:06 <savanni> Ah, thank you!
13:07:09 <astrolabe> For my test case, the data is ~1G, but it will be much larger in a tree for various reasons.
13:07:13 <sorear> astrolabe: if it is less than 3gb, or if you have a 64-bit processor, mmap(2) is probably what you want
13:07:40 <astrolabe> sorear: I don't have one, but thanks for the tip, I'll look that up.
13:07:46 <newsham> if your tree traversal is done in IO actions, you can load data from the file as needed.
13:08:04 <augustss> yes, that could be a big win
13:08:19 <sorear> astrolabe: When you use mmap(2) to load a file into memory, it isn't loaded all at once.  Instead the OS kernel dynamically loads pages *as needed*, and discards them when unused.
13:08:55 <newsham> with enough effort you should be able to simulate mmap performance by reading fixed size chunks from the file and caching them
13:08:58 <sorear> astrolabe: However the file has to fit into address space, which is a constant 3GB on linux/x86.
13:09:06 <newsham> if address space size is a factor
13:09:12 <astrolabe> I think I need to control the reads and writes explicitly.  I suspect and automatic algorithm won't be efficient enough.
13:09:24 <sorear> application level caches are evil because they interact badly with kernel caches.
13:09:48 <newsham> you dont need a alrge cache.. you're just trying to avoid a few kernel/user boundaries
13:10:48 <astrolabe> sorear: yeah, I can believe that, but nevertheless, I don't think the OS understands enough about the problem.  But if I encode my memorty management as file IO, maybe I'll get the best of both worlds.
13:11:00 <sorear> All else equal, mmap is *faster* than user level caching because the cache lookup is done in hardware.
13:11:10 <sorear> The OS is only involved on misses.
13:11:16 <SlowByte> wy: loop detection (by which I assume you mean detecting that partially evaluating a loop is pointless since it won't terminate "soon") is part of abstract interpretation
13:11:59 <SlowByte> or at least I've seen it done in that context ;)
13:12:50 <astrolabe> In particular, I want to write a function that will open a file, read its contents and close it again as an atomic operation (ie, that won't get hung on a thunk half way through).
13:13:38 <SlowByte> basically when you've gone through the loop n times with concrete values, you replace the concrete value with some more abstract value from the lattice
13:13:39 <astrolabe> Is there a better way than a seq (last contents)?
13:14:03 <SamB_XP> @type Data.ByteString.readFile
13:14:04 <lambdabot> FilePath -> IO Data.ByteString.Base.ByteString
13:14:15 <SamB_XP> try that yet?
13:14:25 <astrolabe> SamB_XP: no.  Thanks very much
13:14:26 <lisppaste2> kyevan pasted "Bad BTrees!" at http://paste.lisp.org/display/31937
13:14:52 <kyevan> Could someone please help me out? Why doesn't elements ever seem to work?
13:15:09 <kyevan> (I've tried about a doezen other ways to express myself with that, too...
13:15:27 <Botje> kyevan: you could use concat.
13:15:36 <Botje> concat (elements left) [x] (elements right)
13:15:43 <Botje> errr
13:15:45 <SamB_XP> heh
13:15:46 <Botje> blah
13:15:51 <ToRA|3> (elements left) ++ (x:(elements right))
13:15:57 <Botje> make that (elements left) ++ [x] ++ (elements right)
13:16:05 <SamB_XP> I like Botje's better
13:16:13 <lisppaste2> augustss annotated #31937 with "fix" at http://paste.lisp.org/display/31937#1
13:16:24 <SamB_XP> except with parens, of course
13:16:28 <kyevan> ++ works vaugely like UNIX cat, only with two elements, right?
13:16:37 <sorear> yes
13:16:39 <kyevan> er, not elements
13:16:40 <kyevan> inputs
13:16:49 <Botje> ?type (:)
13:16:51 <lambdabot> forall a. a -> [a] -> [a]
13:16:52 <sorear> see also concat
13:16:53 <Botje> ?type (++)
13:16:54 <lambdabot> forall a. [a] -> [a] -> [a]
13:16:56 <sorear> :t concat
13:16:58 <lambdabot> forall a. [[a]] -> [a]
13:17:03 <astrolabe> augustss: why only the FIRST :?
13:17:27 <Botje> a:(elements right) generates a list
13:17:29 <augustss> otherwise it would be wrong again :)
13:17:37 <Botje> and ++ takes two lists
13:17:58 <astrolabe> Ah, I see
13:18:21 <kyevan> Oh, that works.
13:18:30 <kyevan> Now for me to figure out why mine wasn't working...
13:18:36 <astrolabe> heh
13:18:37 <kyevan> Oh... wait...
13:18:46 <augustss> the : operator is not symmetric
13:18:57 <shankys> ?paste
13:18:58 <lambdabot> http://paste.lisp.org/new/haskell
13:18:59 <augustss> the left operand is an element, the right is a list
13:19:11 <kyevan> if ++ takes two lists... then I was trying to do < a list of a > : < a list of a >
13:19:24 <astrolabe> and after you've figured that out, work out how you could have deduced it from the compiler error :)
13:19:25 <kyevan> which would try to make [[a],a], which isn't a vaild list
13:19:26 <kyevan> right?
13:19:33 <sjanssen> kyevan: exactly
13:19:39 <augustss> right
13:19:53 <kyevan> astrolabe: Well, ghci errors aren't exactly newbie-friendly
13:20:04 <dmead> bonk
13:20:14 <kyevan> I knew that at SOME point it was getting a list where it expected not a list
13:20:19 <sorear> ghci errors aren't exactly expert friendly, either.
13:20:26 <astrolabe> kyevan: true, but it's good practise
13:20:32 <kyevan> But I had no clue WHERE.
13:20:38 <augustss> kyevan: they look much better if you've used c++ for a while ;)
13:21:01 <astrolabe> Are they different from the ghc errors then?
13:21:07 <sorear> no
13:21:08 <augustss> no
13:21:42 <kyevan> Is hugs any more friendly with errors? (eg, gives you the right line number once in a while?)
13:22:15 <astrolabe> kyevan: I don't think so
13:22:17 <shankys> Could someone possibly look at some Haskell CGI code that I wrote? I'm getting something wrong with monad typing, and I can't quite figure it out after wrestling with it for quite a while now. The error is in the sess_id <- liftIO getSessionId line.
13:22:20 <lisppaste2> shankys pasted "CGI Monad Difficulties" at http://paste.lisp.org/display/31940
13:22:20 <SamB_XP> ghc will do that if you can help it narrow down where you disagree about types ;-)
13:22:34 <bd_> kyevan: Be fair now, it gives the right line :)
13:22:43 <kyevan> bd_: Ok, sometimes it does
13:22:47 <dmead> aye
13:22:48 <dmead> people
13:22:52 <dmead> how do you define member
13:22:54 <bd_> But only because you gave it type signatures :)
13:22:56 <dmead> member = uncurry elem?
13:23:16 <augustss> kyevan: but for your example ghci points you exactly at the problem spot
13:23:17 <SamB_XP> no compiler is smart enough to figure out which line you wrote wrong to get a type error!
13:23:20 <vincenz> @type meber
13:23:21 <lambdabot> Not in scope: `meber'
13:23:22 <vincenz> @type member
13:23:24 <lambdabot> Not in scope: `member'
13:23:27 <bd_> @hoogle member
13:23:28 <lambdabot> Data.IntMap.member :: Key -> IntMap a -> Bool
13:23:28 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
13:23:28 <lambdabot> Data.Map.member :: Ord k => k -> Map k a -> Bool
13:23:53 <dmead> hmm
13:23:57 <dmead> i mean lisp style member
13:23:59 <dmead> it's just elem
13:24:03 <dmead> :>
13:24:33 <astrolabe> I wonder if you could have some kind of bayesian type inferrence algorithm which was good at guessing what your type error was?
13:24:40 <allbery_b> ooooooookay.  finally got the xemacs thing mostly figured out (thing I always forget:  there's an emacs in my path, it got used for the byte-compile, and .elc files *still* have no versioning/sanity checking)
13:24:59 <allbery_b> ...but now xemacs cores on startup unless run from a tty.  sheesh
13:25:26 <chessguy> ?doc intersperse
13:25:26 <lambdabot> intersperse not available
13:25:36 <chessguy> @hoogle intersperse
13:25:37 <lambdabot> List.intersperse :: a -> [a] -> [a]
13:25:40 <dmead> ?doc elem
13:25:41 <lambdabot> elem not available
13:25:44 <chessguy> ?doc List.intersperse
13:25:45 <dmead> ?doc `elem`
13:25:45 <lambdabot> List.intersperse not available
13:25:45 <lambdabot> `elem` not available
13:25:47 <dmead> e;rkg;laker
13:25:53 <dmead> ?hoogle elem
13:25:54 <chessguy> phbbththbhbht
13:25:54 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
13:25:54 <bd_> ?doc head
13:25:54 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
13:25:54 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
13:25:54 <lambdabot> head not available
13:25:56 <bd_> heh
13:26:08 <augustss> dmead: there's no haskell function that corresponds to CL member
13:26:20 <allbery_b> (oh, and I added a missing (interactive) to turn-on-haskell-doc-mode, which is documented as being interactively callable
13:26:32 <dmead> someone told me you can define it with uncurry elem
13:26:37 <LoganCapaldo_> what does member do?
13:26:44 <dmead> same as elem
13:26:49 <augustss> nonono
13:26:50 <dmead> i just like the CL syntax
13:27:02 <dmead> o0
13:27:03 <augustss> member returns the rest of the list starting from the matching element
13:27:21 <dmead> uhh
13:27:26 <astrolabe> easy to define
13:27:32 <augustss> sure
13:27:35 <dmead> yea yea
13:27:37 <sjanssen> @type \x -> dropWhile (/= x)
13:27:39 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
13:27:46 <dmead> but i wanna use some built in stuff
13:27:51 <jcreigh> every Monad is a Functor, correct?
13:27:51 <dmead> just for awesomeness's sake
13:27:55 <Cale> jcreigh: yes
13:28:04 <Cale> jcreigh: with fmap = liftM
13:28:08 <augustss> dmead: most uses of CL member is probably like haskell's elem
13:28:16 <dmead> yea
13:28:20 <astrolabe> @pl \x -> dropWhile (/= x)
13:28:21 <lambdabot> dropWhile . (/=)
13:28:29 <sjanssen> jcreigh: yes, but Haskell doesn't enforce that every Monad instance has a corresponding Functor instance
13:28:41 <Cale> (but that's probably a mistake)
13:28:42 <jcreigh> sjanssen: ah, that was going to be my next question.
13:28:45 <augustss> sjanssen: sadly :(
13:28:56 <Cale> It could, and it would be easy, with few downsides.
13:29:16 <astrolabe> Maybe we need a haskell rebel alliance
13:29:20 <SamB_XP> would be nicer with class aliases
13:29:22 <sjanssen> the only "downside" is one line of boiler plate
13:29:22 <augustss> also, Functor used to be a superclass of Monad some versions ago
13:29:32 <Cale> right
13:29:40 <aFlag> hello, is there a function for replacing the firs ocurrence of a item on a list?
13:29:48 <Cale> The Haskell 1.4 prelude was far nicer than the Haskell 98 one.
13:29:57 <dmead> ah ah
13:29:58 <dmead> yea
13:30:14 <dmead> member(a,b) = a `elem` b
13:30:15 <astrolabe> Cale: that's odd.  What went wrong?
13:30:18 <sjanssen> SamB_XP: I think you've just pointed out the reason Functor isn't a superclass of Monad.  Every time this comes up, somebody turns the argument into discussion of class alias extensions
13:30:50 <SamB_XP> sjanssen: I think that is a good sign that we would *like* one ;-)
13:30:52 <astrolabe> aFlag: I don't think so.
13:30:59 <Cale> astrolabe: There seemed to be a lot of people in the Haskell 98 committee (or maybe a vocal few) who disliked polymorphism.
13:31:25 <astrolabe> Cale: because of efficiency?
13:31:34 <augustss> mostly because they wanted the language to be friendlier for teaching.
13:31:37 <Cale> yeah, and the claim that it confuses beginners
13:31:44 <sjanssen> SamB_XP: it might be nice for other reasons, but the Functor/Monad isn't a good argument for it.  It's so easy to write the necessary boilerplate
13:31:47 <augustss> but i think dumbing it down is the wrong way
13:31:54 <Philippa_> *lack* of polymorphism confuses beginners
13:31:57 <Cale> Yeah, become better teachers
13:32:05 <Philippa_> OK, class constraints will for a short while too...
13:32:11 <jmorrison> Hi all. I'm trying to figure out how to nest a Reader monad inside a Writer monad. Surely it has to be pretty simple in use but the docs are /ouch/.
13:32:12 <SamB_XP> sjanssen: yes, but if we want it for an *easy* thing, how much more do we want it for *hard* things?
13:32:19 <Heffalump> having to put a type signature on everything is quite annoying
13:32:20 <astrolabe> Yeah, I agree.  It would be ok to have ghc -noob
13:32:20 <jcreigh> gah, I just used the > lambdabot notation in ghci. :)
13:32:22 <SamB_XP> come on here, are we lazy or are we lazy?
13:32:25 <Cale> I'm sorry, but types and class constraints are basically the first thing you have to teach.
13:32:26 <augustss> oh, you could just give beginners a simpler Prelude if you want to dumb it down  little
13:32:50 <Cale> Heffalump: yeah, I hate the MR too
13:32:55 <SamB_XP> like import Prelude (); import FoolsPrelude -- ?
13:32:56 <Cale> :)
13:33:15 <augustss> SamB: yep, that's what I use at work :)
13:33:23 <jcreigh> so, is the "necessary boilerplate" just "instance Functor Foo where fmap = liftM"? (where Foo is a Monad)
13:33:26 <astrolabe> SamB_XP: fools is a bit strong though
13:33:33 <Cale> jcreigh: yes
13:33:35 <SamB_XP> augustss: is that the name you use at work
13:33:37 <SamB_XP> ?
13:33:39 <fasta> How are multi-graphs generally implemented efficiently?
13:33:40 <allbery_b> hm, ghci --literate ? :)
13:33:53 <augustss> SamB_XP: No, it's Gmag.Prelude
13:34:07 <augustss> But it's in fact more polymorphic than the usual one
13:34:19 <astrolabe> Maybe we could try to standardise a more sophisticated Prelude?
13:34:24 <SamB_XP> that one should be called NicePrelude, then ;-)
13:34:58 <aFlag> I don't know if polymorphism confuse beginers. Python has a lot of polymorphism and it's a begginer-friendly language
13:35:01 <Cale> The problem with creating your own prelude is that if you change the definitions of things like Monad, then all your libraries no longer work without recompiling them
13:35:12 <Cale> So it's a pain to do on a practical level with GHC.
13:35:12 <SamB_XP> aFlag: it also doesn't have static type errors
13:35:25 <astrolabe> Cale: yeah, sounds like a big effort :(
13:35:26 <Cale> (unless you just recompile GHC around your changes)
13:35:32 <aFlag> so you think polymorphism with stati type check is what is confusing?
13:35:52 <SamB_XP> aFlag: that is what these people claim to be confusing
13:35:52 <Cale> Personally, I want to remove fail from Monad, add join to it
13:36:01 <aFlag> oh, i see
13:36:03 <augustss> yes!
13:36:10 <SamB_XP> in particular, they say that the type errors are confusing
13:36:19 <augustss> fail in Monad is an abomination
13:36:23 <Cale> Indeed
13:36:30 <SamB_XP> its such a useful one though
13:36:39 <Cale> We should probably fight to have it removed in Haskell'
13:36:41 <astrolabe> I don't remember a fail in category theory :)
13:36:46 <SamB_XP> pattern match failures are nice to know the locations of!
13:36:51 <augustss> I wouldn't know if it's useful.  I never use it
13:36:55 <Cale> It's not all that useful as long as you have a MonadZero class
13:36:59 <Cale> they removed that too
13:37:12 <Cale> I never use or rely on fail
13:37:18 <SamB_XP> Cale: it is great if the compiler may use it indiscriminantly!
13:37:18 <Philippa_> when you say you never use it, presumably you mean the call on pattern-match failure? Though it's pretty useless in most other cases too
13:37:22 <aFlag> type errors in ghc are kinda confusing, but it's more of a implementation decision than really a problem with static type check and polymorphism, isn't it?
13:37:35 <int-e> there's one reason why I really dislike fail in Monad, and that's the weird destriction on the Either a  monad.
13:37:39 <Cale> SamB: refutable pattern matches should cause a MonadZero constraint
13:37:42 <augustss> Philippa_: well, pattern match failure worked fine when we had MonadZero
13:38:03 <SamB_XP> Cale: hmm.
13:38:07 <SamB_XP> you have a point there.
13:38:32 <Cale> We have all these monads with absolutely ridiculous implementations of fail
13:38:33 <augustss> Cale: we just want Haskell 1.4 back. :)
13:38:40 <Cale> augustss: mostly, yes
13:38:47 <Cale> There are some things which I'd do differently
13:38:53 <SamB_XP> is it too late to ask the Haskell' people to give us back Haskell 1.4?
13:38:57 <chessguy> hey, the video lectures linked at http://lambda-the-ultimate.org/node/1303 are up!
13:38:58 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
13:38:58 <Cale> Let's put Traversable, Applicative, etc. into the prelude
13:39:06 <augustss> yes
13:39:07 <Cale> They're great
13:39:15 <SamB_XP> or maybe Haskell 1.5
13:39:16 <Cale> I'd also seriously consider (.) = fmap
13:39:24 <Cale> 98 = 1.5
13:39:25 <pejo> aFlag, it's not trivial to give good error messages, but you could get quite far with tweaking the implementation, I imagine.
13:39:39 <SamB_XP> Cale: show me the version info fields!
13:39:43 <Cale> hehe
13:39:45 <astrolabe> Would it be possible to mostly automate the process of converting a library based on the H98 prelude to one based on a new prelude?
13:39:46 <aFlag> I'm sure it's not trivial
13:40:04 <SamB_XP> they exist for win95, win98 et. all, what about H98?
13:40:23 <sorear> What we need, is a language designed for bigoted arch-hackers with no concerns for newbies.
13:40:41 <augustss> i thought we already did. ;)
13:40:43 <astrolabe> sorear: right.  roll on the revolution!
13:40:49 <Cale> astrolabe: we might not even need that -- most of the changes we want to make are generalisations
13:40:53 <SamB_XP> Cale: actually, I think the type errors from (.) = fmap would confuse *me*
13:40:54 <kzm_> aFlag, if you think the error messages are bad now, you should try old versions.
13:41:05 <Cale> SamB_XP: really? :)
13:41:15 <Cale> I tried it for a while and found it quite nice
13:41:18 <SamB_XP> I really do.
13:41:20 <chessguy> wow, they're big honking files though
13:41:23 <aFlag> ghc 6.2.2 was the first version I've tried
13:41:25 <SamB_XP> I could be wrong, though.
13:41:37 <chessguy> 500 meg per video
13:41:47 <Cale> Functions are just another kind of container :)
13:42:13 <astrolabe> Cale: do you think everything is a container?  ;)
13:42:28 <Cale> Functions from the type e are containers indexed by values of type e
13:42:53 <astrolabe> containers that contain only one thing?
13:42:57 <Cale> astrolabe: all functors can be thought of as container-types to some extent
13:43:00 <Cale> no
13:43:09 <Cale> containers that contain one thing for each value of type e
13:43:16 <astrolabe> Cale: right
13:43:22 <Cale> applying the function does a "lookup"
13:43:32 <SamB_XP> @scheck (\f x -> f x :: Bool)
13:43:33 <jcreigh> Cale: so, (+2) :: Integer "contains" every integer?
13:43:34 <lambdabot>  Add a type signature
13:43:40 <Cale> jcreigh: yes
13:43:43 <SamB_XP> @scheck (\f x -> f (x :: Bool) :: Bool)
13:43:44 <lambdabot>   Failed test no. 4. Test values follow.: {True->True;False->False}, False
13:43:46 <Cale> :: Integer -> Integer
13:44:21 <Cale> > fmap (+1) (+2) 0
13:44:22 <lambdabot>  3
13:44:24 <astrolabe> Cale: I could imagine a container around everything, but I don't see what it gets me.
13:44:31 <SamB_XP> look, see, that function there contains True and False ;-)
13:44:34 <Cale> astrolabe: "around"?
13:44:57 <astrolabe> Cale: around == containing
13:45:06 <augustss> the continuation monad is the one where i have trouble seeing the container.  but i bet you can
13:45:09 <astrolabe> everything == each thing
13:45:11 <kyevan> Um, does anyone even understand what YAHT exercise 4.10 means?
13:45:40 <Cale> astrolabe: You're thinking of the function (f :: a -> b) itself as a container -- think of it as a giant box divided up into cells, and each cell is labelled with a value of type a, and inside the cell is a value of type b
13:45:55 <SamB_XP> @scheck (\f x -> f (x :: Bool) :: Bool)
13:45:57 <lambdabot>   Failed test no. 4. Test values follow.: {True->True;False->False}, False
13:46:07 <chessguy> an infinite box, in fact, depending on the type of a
13:46:18 <astrolabe> Cale: I think I got that
13:46:26 <SamB_XP> @scheck (\f x -> f (x :: [Bool]) :: Bool)
13:46:28 <lambdabot>   Failed test no. 3. Test values follow.: []->
13:46:28 <lambdabot>  False
13:46:28 <lambdabot> [True]->
13:46:28 <lambdabot>  True
13:46:28 <lambdabot> [True...
13:46:38 <mwolak> @pl (\x -> elem x [1,2,3])
13:46:38 <lambdabot> flip elem [1, 2, 3]
13:46:54 <Cale> augustss: You could think of a value of type Cont r a as a sort of black box which allows you to ask questions about values of type a with responses of type r
13:47:13 <jcreigh> > map (`elem` [1,2,3]) [-5..5]
13:47:14 <lambdabot>  [False,False,False,False,False,False,True,True,True,False,False]
13:47:19 <Cale> and it answers them as if it held a value of type a, but it may not actually do so directly
13:48:01 <augustss> Cale: hmmmmm, i'll have to ponder that
13:48:34 <jcreigh> mwolak: err, filter might be a better example, but you can see how to use to infix notation to avoid having to flip something.
13:48:39 <chessguy> Cale, what's the benefit of thinking that way?
13:48:50 <Cale> In particular, (return x) gives you the black box which answers questions by applying them to x
13:49:15 <mwolak> jcreigh: thanks, I almost never even consider infixing stuff
13:49:18 <kyevan> "Write a fold function for /BinaryTree/s and rewrite /elemenets/ in terms of it (call the new one /elements2/)."
13:49:22 <vincenz> Cale: seems like delimited continuations
13:49:26 <kyevan> ^What is ment by that, in YAHT?
13:49:40 <ToRA|3> random ghc question: is it possible to have a module definition span multiple files?
13:49:46 <astrolabe> kyevan: I guess if you think of a fold as something that combines all the elements of a list together using a binary 'combining function', then fold for trees...
13:49:47 <Cale> vincenz: that's sort of what they are -- delimited by runCont
13:50:01 <chessguy> wait, are you talking about functions or monads?
13:50:02 <vincenz> yeap
13:50:04 <jlouis_> ?hoogle (b -> a -> m b) -> b -> [a] -> m b
13:50:05 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
13:50:05 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
13:50:15 <jcreigh> mwolak: well, obviously, only do it when it "makes sense". for some reason, I find x `elem` [1,2,3] a little easier on the eyes than elem x [1,2,3]
13:50:16 <jlouis_> uargh, no lambdabot ?
13:50:24 <scsibug> Could someone give me a pointer on getting the md5 hash of a file?  I've got a naive function using Data.Hash.MD5, but it takes an obscene amount of memory to complete.
13:50:26 <astrolabe> @bot
13:50:27 <lambdabot> :)
13:50:29 <SamB_XP> jlouis_:
13:50:33 <SamB_XP> um
13:50:40 <shoffsta> shanky: were you able to solve your problem?
13:50:44 <SamB_XP> did you put her on /ignore by mistake?
13:51:05 <jcreigh> "her"?
13:51:20 <astrolabe> yes her
13:51:22 <jlouis_> ?paste
13:51:23 <lambdabot> http://paste.lisp.org/new/haskell
13:51:23 <SamB_XP> lambdabot is female -- you hadn't heard?
13:51:24 <kyevan> jcreigh: Bots are always her. Unless they aren't.
13:51:41 <astrolabe> @vixen
13:51:42 <lambdabot> enough of this!
13:51:47 <astrolabe> you see
13:51:49 <jcreigh> no, I guess I missed that.
13:52:02 <int-e> @vixen asl
13:52:03 <lambdabot> 19/f/California
13:52:06 <SamB_XP> @Version
13:52:06 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
13:52:07 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:52:13 <SamB_XP> @about
13:52:14 <lambdabot> Unknown command, try @list
13:52:22 <lisppaste2> jlouis pasted "did I just derive foldM?" at http://paste.lisp.org/display/31944
13:52:26 <SamB_XP> well, lambdabot doesn't exactly advertise it...
13:52:32 <SamB_XP> @vixen do you like lambdas
13:52:33 <lambdabot> yah, i like
13:53:34 <SamB_XP> @vixen do you like monads
13:53:35 <lambdabot> sure, i definitely don't hate
13:53:40 <SamB_XP> @vixen do you like java
13:53:43 <lambdabot> sure, i definitely don't hate
13:53:46 <mgsloan> @vixen somethingyoudon'trecognize
13:53:46 <lambdabot> People think I'm weird...   do you?
13:54:01 <SamB_XP> gots to work on that last one... doesn't hate indeed!
13:54:32 <mgsloan> @vixen somethingyoudontrecognize
13:54:32 <lambdabot> Wouldn't it be funny if I really was a super model?
13:54:32 <chessguy2> Cale, so if a function is a container, then a monad is a container of containers?
13:57:08 <SlowByte> well, monads don't usually contain functions, but arrows do
13:59:42 <lisppaste2> scsibug pasted "md5, with terrible performance" at http://paste.lisp.org/display/31947
14:01:55 <emu> what MD5 package is that?
14:01:59 <scsibug> MissingH
14:02:02 <SlowByte> @hoogle md5s
14:02:03 <lambdabot> No matches found
14:02:08 <scsibug> latest version
14:03:02 <jlouis_> Program Inversion seems majorly fun
14:03:51 <jlouis_> I am fooling around with implementing a program inverter from a paper and there are some rather fun ideas in there
14:03:53 <emu> looks like its based on Ian's
14:04:05 <scsibug> yes, it is his
14:05:07 <emu> well i mean, it's gotta read in the file presumably
14:05:39 <scsibug> yes, but I'm talking hundreds of megabytes of memory to checksum a 5 meg file...
14:05:53 <jlouis_> laziness has hit you then
14:06:19 <lisppaste2> emu annotated #31947 with "implementation" at http://paste.lisp.org/display/31947#1
14:07:11 <emu> looks pretty consy
14:07:32 <scsibug> what is the general approach to take with these sorts of blowups?
14:07:49 <emu> perhaps an implementation based on STUArrays would be better
14:07:49 <jlouis> hint the stcritness analyzer
14:08:00 <jlouis> strictness analyser even
14:08:11 <jlouis> or change implementation structure as emu suggests
14:08:35 <emu> could such pure code be taken and transformed to be space-efficient by ghc? I do not know its capabilities in that regard.
14:09:12 <Ithika> hello folks
14:10:35 <Ithika> can anyone tell me a function to update a record with the contents of another one?
14:10:54 <Ithika> I want to fold a whole bunch of records together
14:11:14 <emu> generally it's: var { field1 = value, field2 = value }.  you'd have to extract value from the other record.
14:11:47 <emu> as far as I can tell, things like record-fields must be determined statically.
14:12:33 <Ithika> so there's no easy way of doing foldr f defaultrecord [record1, record2, record3] ?
14:12:43 <Ithika> for some value of f
14:13:22 <emu> how much work do you want f to do? =)
14:13:35 <Ithika> hehe, yes, that is the question...
14:14:00 <Ithika> I had hoped there would be something simple that I was missing, a const or a (.) or a ($) or whatever
14:14:00 <emu> i mean, it seems like it would work to define: f a b = b { field1 = (field1 a) ... }
14:14:17 <emu> with some combining logic i guess
14:14:55 <Ithika> okay, thanks for your help. I just wanted to be sure I wasn't missing anything! :-)
14:15:13 <emu> and of course pattern matching on records
14:17:47 <newsham> print $ (Foo 1 2) {f1=2} {f1=3, f2=1}
14:18:18 <int-e> emu: hmm. the strictness analyzer could maybe optimize the md5 loop, but I'd rather help it with an explicit strictness annotation.  md5_main looks like it accumulates a huge expression in its abcd argument.
14:19:35 <emu> yes putting a !abcd might be interesting there
14:20:59 <int-e> emu: more like !abcd@(ABCD !(!_, !_, !_, !_)) (or something abysmal like that)
14:21:29 <int-e> emu: a newtyped tuple is awful :/
14:21:47 <notsmack> the "Haskell Bowling" article kinda sucks
14:22:02 <emu> he defined Num ABCD?
14:22:17 <emu> yikes, indeed
14:22:26 <notsmack> 'and the "ten-ness" of the game is not represented in the recursive solutions at all.'
14:22:29 <int-e> emu: data ABCD = ABCD !Word32 !Word32 !Word32 !Word32  would be more pleasant to strictify.
14:22:30 <emu> well perhaps the annotations can go there
14:22:57 <newsham> md5 impl url?
14:23:04 <emu> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/haskell-md5-0.2.7/MD5.lhs
14:23:07 <lambdabot> http://tinyurl.com/y8td23
14:23:07 <road_> Hi
14:23:20 <newsham> was wondering what that would look like.. md5 seems like a good example of something that works really well in imperative code
14:23:36 <int-e> also http://darcs.complete.org/missingh/src/Data/Hash/MD5.lhs
14:24:04 <int-e> which is more current?
14:25:03 <newsham> oh.. i'm confused.. i meant rc4.
14:25:15 <emu> 0.2.7 is 5 years old
14:25:31 <Korollary> that's got to be ByteStringified
14:25:38 <emu> yea
14:27:23 <vincenz> aloha zamez
14:27:26 <vincenz> hmm
14:27:30 <vincenz> wrong person, the one I tabbed for left
14:27:50 <Korollary> you dont need to apologize. We all know about you and zamez.
14:29:19 * vincenz hangs his head in shae
14:30:00 <vincenz> IT all started on a korollary
14:30:28 <pzpz> I'm trying to think of methods for marshalling my own data class -- but O'm clueless :)
14:30:57 <road_> Is anyone using hslogger? Building with "runhaskell Setup.hs configure build" fails with the error message: "Setup.hs: hslogger.cabal:23: Parse of field 'extensions' failed".
14:31:10 <vincenz> damn
14:31:12 <vincenz> this is pretty sad
14:31:33 <vincenz> in ##freenode-social
14:31:33 <vincenz> 23:19 <+klined> he pm'ed me (h3tl3r4life) I want to get voiced so I can preech
14:31:33 <vincenz>                 hitler
14:31:33 <vincenz> 23:20 -!- judenschwein88 [i=shaun@gateway/tor/x-90914793d51879c5] has joined
14:31:33 <vincenz>           #freenode-social
14:31:50 * vincenz shakes his head sadly
14:32:03 <vincenz> You'd think that in this day and age, people would be a bit less ignorant
14:32:11 <pzpz> is preech anything like screech?
14:32:34 <mwc> vincenz, it's kids looking for attention
14:32:54 <vincenz> mwc: eh, still, even kids know there's limits
14:33:10 <vincenz> Besides, I doubt kids use TOR
14:33:20 <mwc> vincenz, teenagers then
14:33:31 <vincenz> idem
14:34:52 <pzpz> I suppose I could build a list of all of the type's elements, and then marshall that, yet I'd hope there be a more direct approach ^_^
14:34:54 <mgsloan> limits? not on the net.  Why do you think there are so many people who act badly?
14:35:56 <sjanssen> pzpz: marshal in what way?  will deriving Read/Show work for you?
14:36:19 <pzpz> haha, people will always be ignorant. It's a fact of human nature. Look at the gaede twins. It's really sad :(
14:36:54 <mwc> this is a topic for #haskell-blah
14:37:15 <emu> cant' seem to get an improvement with bang-patterns
14:37:34 <pzpz> sjanssen: hmm, would deriving those types esentially result in teh list of types?
14:37:36 <mwc> ! are strict, # are unboxed?
14:37:52 <Vq^> emu: what improvement are you supposed to get?
14:37:52 <vincenz> correct
14:38:28 <mwc> what do unboxed values give us that strict doesn't?
14:38:46 <emu> Vq^: space
14:39:01 <mwc> I know they're stored more efficiently, but in principle couldn't every strict value be unboxed?
14:39:49 <emu> majority of allocation happens in md5_inner_function (33%)
14:40:03 <emu> then string_to_word32s (28.5%)
14:40:28 <emu> and some in md5_round which calls _inner_function
14:41:22 <sjanssen> emu: I suggest that you replace newtype ABCD with data ABCD = ABCD !Word32 !Word32 ...
14:41:31 <sjanssen> emu: and then compile with -funbox-strict-fields
14:43:13 <emu> what is needed to allow that syntax for strct data fields?
14:43:43 <sjanssen> emu: strict data fields are Haskell '98
14:44:41 <sorear> unboxing is GHC extension, but it is semantically the same as strict...
14:45:11 <emu> ah nvm i made a typo. anyway i just converted it so lets see.
14:45:40 <sorear> For C programmers: lazy : int (*thunk)();   strict : int *field;   unboxed : int field;
14:49:22 <emu> its thrashing the GC a bit. increasing the -A space lowered the time.
14:49:33 <Excedrin_> how does GHC determine which kind of list a particular list is?
14:49:51 <sjanssen> emu: my suggestion made things worse?
14:50:06 <sjanssen> Excedrin_: what do you mean?
14:50:52 <Excedrin> does [1,2,3] get treated as an unboxed list? whereas [1..] is lazy, etc?
14:51:08 <emu> sjanssen: no
14:51:11 <Lemmih> Excedrin: We don't have unboxed lists.
14:51:11 <emu> didn't really change
14:51:31 <emu> unboxed is for values which can be represented in a machine word
14:52:11 <Excedrin> hum, why not? I thought that one wasn't a particularly difficult optimization
14:52:44 <SlowByte> are list heads unboxed (sometimes)?
14:53:27 <kzm_> emu I think GHC can unbox larger structures as well.
14:53:45 <kzm_> But the whole (or at least half) point of lists is that they are lazy.
14:54:03 <sjanssen> SlowByte: lists are always stored boxed
14:54:41 <emu> string_to_word32s is the major user of space and time now
14:54:46 <kzm_> Wasn't there something about [Char] being stored more efficiently for c when ord c < 256?
14:54:53 <kzm_> emu: ByteString?
14:55:06 <emu> yea, this whole thing should be rewritten to use fps
14:55:57 <emu> might suffice just to supply an instance of MD5 for a newtype BStr and implement it with fps
14:56:03 <kzm_> sjanssen, emu: I tend to use -funbox-strict-fields, but I think the Correct Solution (tm) is to use unpack pragmas.
14:56:05 <sjanssen> kzm_: the first 256 chars are preallocated in GHC
14:56:10 <dylan> bobcob's setup.exe still fails to run
14:56:14 <kzm_> Right.
14:56:19 <dylan> err, wrong window
14:56:21 <sjanssen> kzm_: yes, you're right
14:56:39 <kzm_> And - I thought they'd work for newtype as well as data .. !
14:56:44 <sjanssen> emu: is your current attempt online somewhere?
14:56:54 <_matthew-> mmm. some people have told me to use unbox pragmas and some ppl just say -funbox-strict-fields
14:56:55 <SlowByte> so data constructors that are declared lazy are always lazy? eg. a : [a] never gets internally converted to !a : [a] or Tree a b to Tree !a !b?
14:57:36 <sjanssen> SlowByte: that is correct.  Unboxing usually happens at the call site
14:58:04 <kzm_> I think the point is that unpack is (can be) more selective.
14:58:18 <emu> sjanssen: i can put my darcs somewhere i guess
14:58:52 <sjanssen> emu: I'd like to take a crack at making this fast, and I'd rather not duplicate your work
14:58:58 <emu> ok one sec
14:59:10 <vincenz> @dict de en beseitigen
14:59:11 <sjanssen> emu: you could even drop it on lisppaste, if that's easier
14:59:11 <lambdabot> Supported dictionary-lookup commands:
14:59:11 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
14:59:11 <lambdabot> Use "dict-help [cmd...]" for more.
14:59:57 <mauke> @babel de en beseitigen
14:59:58 <lambdabot>  eliminate
15:00:28 <vininim> @eval
15:01:07 <emu> darcs pull http://mapcar.org/haskell/missingh, should suffice
15:01:12 <lambdabot> Title: Index of /haskell/missingh
15:01:49 <sjanssen> emu: how have you been testing it?
15:01:55 <emu> notably, adding some strictness to _inner_function seems to have helped
15:02:02 <emu> sjanssen: uh, a little stub program.
15:02:04 <Botje> good news everyone! arrows have succeeded in blowing my mind again!
15:02:14 <sorear> BTW: which is preferred: using web-hosting | using lisppaste  (both would be easy for me, I've been using my webhosting until now)
15:02:33 <lisppaste2> emu annotated #31947 with "stub program" at http://paste.lisp.org/display/31947#2
15:02:41 <augustss> Botje: and that's good because you like to have your brain scattered? :)
15:02:50 <SamB_XP> lisppaste has paren matching and syntax highlighting ;-)
15:02:57 <sjanssen> sorear: lisppaste is neat because of the contextual messages
15:03:13 <SamB_XP> also, annotations
15:03:22 <Botje> augustss: in true darwninian fashion it kills off the portions of brain that don't get back together with the rest :P
15:03:48 <emu> sjanssen: gonna try ByteString
15:05:16 <SamB_XP> web hosting is good for darcs, though ;-)
15:06:41 <mgsloan> sorear - speaking of that, could you put up your partial geom stuff?
15:07:19 <SlowByte> $ ghc parse.hs
15:07:19 <SlowByte> compilation IS NOT required
15:07:19 <SlowByte> parse.o: In function `s4O6_info':
15:07:22 <SlowByte> (.text+0xa5): undefined reference to `parseczm2zi0_TextziParserCombinatorsziParsecziPrim_zdf2_closure'
15:07:36 <SlowByte> hmph?
15:08:21 <psi> try --make
15:08:58 <sjanssen> or -package parsec
15:09:02 <SlowByte> oh, worked, thanks
15:12:24 <SlowByte> ohboy, GCC took 300M while compiling :) the magical world of optimization...
15:13:26 <sorear> G *C* C?
15:13:31 <SlowByte> yep
15:13:49 <sorear> *jaw drops*
15:14:02 <augustss> gcc can be a real resource hog
15:14:04 <mauke> that's nothing
15:14:09 <newsham> gnu software is usualy so lean and efficient
15:14:16 <newsham> hahah
15:14:20 <mauke> I've seen ld eat all my memory and die :(
15:14:21 <SamB_XP> yeah!
15:14:28 <SlowByte> GHC was around 100M
15:15:03 <augustss> there's usually little point in going via C
15:15:59 <LoganCapaldo_> You know I've never compiled GCC
15:16:29 <emu> well i've cut GC down to almost nothing
15:16:52 <LoganCapaldo_> I have compiled ghc, but not on purpose. I think fink decided it wanted to build it from source
15:17:03 <LoganCapaldo_> and I was like wait ! no what are you doing!!
15:17:17 <SamB_XP> hahahaha
15:17:38 <emu> correction: i've cut the gc usage down a lot, but its still significant with the default space sizes
15:19:25 <SlowByte> -fasm was quite a lot better indeed... and the result was about as fast as before
15:22:32 <emu> i think that if i can find a way to efficient convert a 64-byte ByteString into 16 Word32s, it'll be a lot faster. it seems i've pushed most of the trouble into that function.
15:23:05 <sjanssen> emu: I've had some success with replacing the foldr/splitAt with a hand written expression
15:23:23 <emu> cool, i'll record my version
15:24:11 <emu> unpackList? hmm
15:25:37 <mathewm> can you catch the Exception from a fromJust?
15:25:50 <sjanssen> matthewm: only inside the IO monad
15:25:56 <SamB_XP> @hoogle catch
15:25:58 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
15:25:58 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
15:25:58 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
15:26:05 <emu> unpackList helps significantly
15:26:11 <mathewm> hmm
15:26:14 <SamB_XP> Control.Exception.catch
15:26:24 <sjanssen> matthewm: fromJust doesn't throw an exception, it yields a bottom
15:26:39 <mathewm> OK
15:26:41 <sjanssen> you aren't supposed to be able to detect bottoms
15:26:45 <mathewm> it says "*** Exception"
15:26:46 <emu> it still could do better though
15:27:04 <mathewm> but my attempt to catch doesn't work
15:27:16 <mathewm> so I believe the bottom story
15:28:08 <sorear> have you tried forcing evaluation with Control.Exception.evaluate ?
15:28:42 <sorear> bottoms in pure code need to be undetectable, but in IO all bottoms are nontermination or exceptions
15:29:31 <lisppaste2> emu annotated #31947 with "bstring_to_word32s" at http://paste.lisp.org/display/31947#3
15:29:46 <emu> ack bad paste
15:30:03 <sjanssen> right, there is some way to detect the error within the IO monad
15:30:17 <lisppaste2> emu annotated #31947 with "take 2" at http://paste.lisp.org/display/31947#4
15:30:45 <dons> ?users #haskell
15:30:46 <lambdabot> Maximum users seen in #haskell: 288, currently: 268 (93.1%), active: 56 (20.9%)
15:30:49 <dons> heh cool
15:31:16 <sorear> I've figured out how to write pure for GADT tuples; note the bizarre type fold : http://members.cox.net/stefanor/GADTTup.hs
15:31:27 <sjanssen> @users dons
15:31:28 <lambdabot> Maximum users seen in dons: 1, currently: 0 (0.0%), active: 0 (NaN%)
15:31:51 <emu> hi dons; sjanssen and I are trying to speed up missingh's MD5 with ByteString
15:32:08 <dons> yeah I see.
15:32:12 <dons> i'll have a look after breakfast
15:32:22 <emu> thanks
15:36:41 <dons> astrolabe: did you get an answer to generating binary data?
15:36:47 <dons> its pretty easy, use NewBinary or ByteString
15:37:15 <dons> astrolabe: when <Philippa_> "with great difficulty", I don't agree with that. we have libraries that make it easy
15:37:24 <augustss> can ByteString easily pack, e.g., Double?
15:38:02 <dons> not easily. but you could use the Storable a => Vector a bytestring type
15:38:23 <augustss> ah
15:45:33 <MarcWebe1> Whats a typical voltage difference in a quarz oscillator signal used as clock for  microccontrollers running with VCC 5V ? I can't program it so I have to do some troubleshouting..
15:46:01 <sorear> This is not an electronics channel, sorry.
15:46:17 <Pseudonym> You might like to ask on #avr.
15:46:23 <Pseudonym> They know answers to questions liek that there.
15:46:42 <augustss> You mean the clock out?
15:46:42 <newsham> isnt avr internally clocked?
15:46:47 <Pseudonym> Nope.
15:46:53 <Pseudonym> At least, not most of the AVRs.
15:47:07 <newsham> i have a board w/ an avr on it with no xtals
15:47:16 <Pseudonym> Must be a small AVR.
15:47:21 <Pseudonym> My board has two crystals.
15:47:27 <newsham> its an ATiny
15:47:34 <Pseudonym> There you go.
15:47:37 <Pseudonym> What MCU is it?
15:47:52 <Pseudonym> On the microcontroller board that you're having a problem with.
15:48:08 <Pseudonym> There's probably a channel here for it.
15:48:09 <newsham> atiny2313
15:48:18 <newsham> oh.. him :)
15:48:29 <jlouis> what line do you put in the top of a file to get -fglasgow-exts?
15:48:30 <Pseudonym> Yes. :-)
15:48:36 <Pseudonym> My board is an ATmega.
15:48:49 <Pseudonym> I'm guessing the tiny ones are internally clocked and the mega ones are.
15:48:52 <Pseudonym> aren't
15:48:52 <sjanssen> jlous: {-# OPTIONS_GHC -fglasgow-exts #-}
15:48:57 <jlouis> sjanssen, oh thanks
15:49:06 <jlouis> forgot # OPTIONS_GHC and #
15:49:07 <Pseudonym> At any rate, questions like this can go to the appropriate mcu channel, not #haskell.
15:49:17 <Pseudonym> Functional programmers do care about fanout, but only because of laziness.
15:49:56 <augustss> we care about all things, from electrons and up :)
15:50:22 <newsham> apathy all the way down
15:50:35 <vincenz> to the down-quark
15:52:58 * augustss hacks away on his quantum MacBook
15:53:18 <jlouis> If I want to drag a name-supply around in some tree-walking code given on inductive definitions, then what is the easiest way? I could use a State monad with a counter in and increase, but is there a better way (Reader mayhaps)
15:53:44 <vincenz> jlouis: say that again
15:53:49 <vincenz> Reader only works scopefully
15:53:58 <dons> jlouis: there's some Unique supply monads already on the wiki
15:54:08 <dons> look for NewMonad
15:54:16 <jlouis> dons, oh cool
15:54:23 <vincenz> dons: SupplyMonad :)
15:54:36 <vincenz> and then use [1..] as input
15:54:50 <augustss> dons: do you know if that Unique monad uses something extra clever to avoid the state dragging overhead?
15:55:00 <Pseudonym> augustss: What makes you think we don't care about things smaller than electrons?
15:55:18 <Pseudonym> jlouis: There's another technique which is very cool.
15:55:26 <Korollary> Pseudonym: who is we?
15:55:33 <vincenz> Korollary: him
15:55:40 <augustss> Pseudonym: well, I care about smaller things, but they are not (yet) relevant for computers
15:55:43 <dons> augustss: don't know
15:55:43 <vininim> damn it, ghci takes too long to calculate alckermann's A(4,1) :/
15:55:46 <vincenz> augustss: so you think
15:55:48 <dons> here's the code actually, http://haskell.org/haskellwiki/New_monads/MonadUnique
15:55:50 <lambdabot> Title: New monads/MonadUnique - HaskellWiki
15:55:59 <newsham> augustss: what about quantum computing and the list monad?
15:56:07 <Pseudonym> jlouis: If you don't care about your unique names being strings, you can make a splittable name supply.
15:56:09 <vincenz> dons: tbh, supplymonad is better than uniquemonad
15:56:16 <augustss> newsham: I repeat my previous statement
15:56:19 <vincenz> dons: supplymonad ....(what is the word).... the newmonad
15:56:21 <dons> ?wiki New_monads/MonadSupply
15:56:22 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
15:56:28 <augustss> *yet* was they keyword there
15:56:42 <jlouis> Pseudonym, oh, whats the trick? Build the string as you walk the tree?
15:56:45 <vincenz> dons: how do you call it if a more generic thing .... a simpler thing
15:56:50 <vincenz> (like can handle the same things)
15:56:51 <augustss> Bah, boring Unique monads!
15:56:52 <jlouis> persistently?
15:57:18 <newsham> http://www.cs.nott.ac.uk/~txa/talks/ottawa-03.pdf
15:57:26 <augustss> I should put up our old NameSupply monad.
15:57:26 <Pseudonym> jlouis: http://research.microsoft.com/~simonpj/papers/slpj-book-1987/PAGES/175.HTM
15:57:28 <sorear> if we are using arithmetic progressions, it could be optimized significantly.
15:57:29 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/y8kcuh
15:57:39 <vincenz> Anyone?
15:57:55 <vincenz> xxx ... yyy if xxx is more generic than can yyy and can handle yyy fully
15:58:02 <sjanssen> vincenz: "general"
15:58:05 <vincenz> no it's a verb
15:58:21 * vincenz hates it when words rest on the tip of his tongue
15:58:22 <sjanssen> subsumes?
15:58:27 <vincenz> thanks!
15:58:37 <lisppaste2> sorear pasted "cheaply splittable arithmetic progressions" at http://paste.lisp.org/display/31954
15:58:52 <jlouis> Pseudonym, oh, I have that book somewhere. Thanks ;)
15:59:16 <vincenz> Pseudonym: I have a neat impl for that
15:59:38 <vincenz> supplymonad with as list:
16:00:44 <vincenz> > make_supply inits tails = let vars = inits ++ (map concat . sequence $ [vars, tails]) in vars in make_supply (map return ['a'..'z']) (map return ['a'..'z'])
16:00:44 <lambdabot>  Parse error
16:00:49 <vincenz> > let make_supply inits tails = let vars = inits ++ (map concat . sequence $ [vars, tails]) in vars in make_supply (map return ['a'..'z']) (map return ['a'..'z'])
16:00:51 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
16:00:57 <vincenz> > drop 1000 $ let make_supply inits tails = let vars = inits ++ (map concat . sequence $ [vars, tails]) in vars in make_supply (map return ['a'..'z']) (map return ['a'..'z'])
16:01:00 <lambdabot>  ["alm","aln","alo","alp","alq","alr","als","alt","alu","alv","alw","alx","al...
16:01:43 <vincenz> you can of course fix that
16:02:01 <jlouis> Pseudonym, thats complete simonic + wadleric
16:02:15 <jlouis> but damn, the trick is cool
16:02:16 <astrolabe> maybe [a,b,c..] should evaluate to the quadratic sequence starting with these three values, [a,b,c,d..] should be the cubic sequence etc.
16:02:31 <jlouis> its a bit like the idea I had, but cleverer
16:03:26 <twanvl> > [1,2,4,8,..]
16:03:27 <lambdabot>  Parse error
16:03:51 <augustss> but with a little unsafeXXX you can make the name supply stuff very efficient.  (and it's perfectly safe)
16:04:24 <vincenz> unsafe sex?
16:04:38 <augustss> just to the naked eye
16:04:52 <vincenz> that's why we should get condoms, huh?
16:04:54 * vincenz rubs his eye
16:05:20 <resiak> brings a whole new meaning to unsafePerformIO...
16:05:40 <vincenz> augustss: so it's mostly haskell, or other fpls as well?
16:06:07 <augustss> vincenz: what is?
16:06:14 <vincenz> augustss: at your job at CS
16:06:21 <augustss> haskell only
16:06:43 <vincenz> augustss: how many people work in haskell?
16:07:15 <augustss> well, two implementors, and we have just started some trial usage with 3 users
16:07:31 * vincenz is interested
16:07:40 <vincenz> I'm planning to finish my phd in 2008 :)
16:08:02 <augustss> so you should apply for a job then :)
16:08:18 <vincenz> I definitely will
16:08:27 <augustss> at that time haskell might be a success, or totally gone
16:08:31 <vincenz> My phd has nothing to do with fpls, however, most of that specific knowledge is self-schooled..
16:09:07 <augustss> i think that doesn't matter much
16:09:24 * vincenz nods
16:09:29 <astrolabe> I can't imagine haskell gone by 2008.  Too many people use it.
16:10:06 <vincenz> I take it you guys use those combinators for economics, forgot the tittle of the paper from a while back
16:11:03 <augustss> astrolabe: gone from Credit Suisse, I meant
16:11:37 <vincenz> "Composing contracts"
16:11:39 <augustss> vincenz: no, this has nothing to do with Simon's and Jean-Marc's contract combinators
16:11:46 * vincenz nods
16:12:06 <newsham> is there an intro to the notation they use for denotational semantics equations online somewhere?
16:12:07 <augustss> Oh, and Julian was in on that paper too.  Sorry, Julian
16:12:24 <newsham> where they have one equation written above a horizontal line and another beneath it
16:12:35 <vincenz> newsham: try harper's book
16:12:38 <vincenz> the unfinished one
16:12:57 <astrolabe> augustss: sorry, I should have followed that.
16:13:03 <newsham> url? title?
16:13:11 <vincenz> newsham: just a sec
16:13:39 <vincenz> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
16:13:48 <newsham> thank you sir
16:13:58 <dons> ?where plbook
16:13:58 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
16:14:05 <vincenz> it's amazing how many papers I've read on the fpl world, given how my research lies in a different field
16:14:11 <jlouis> augustss, I am doing program inversion now. Its fun to be coding in haskell and taking all the stuff that would be gritty to write in SML out with monads, hehe
16:15:02 <jlouis> when this is finished, I will be able to invert fib, haha
16:18:01 <vincenz> @quote knuth
16:18:02 <lambdabot>  We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters, might become
16:18:02 <lambdabot> feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
16:18:54 <jlouis> and to counterbalance that:
16:18:57 <jlouis> @yow
16:18:58 <lambdabot> Youth of today!  Join me in a mass rally for traditional mental
16:18:58 <lambdabot> attitudes!
16:19:24 <vincenz> What's the quote about "programming is as much about computer as ..."
16:20:18 <sorear> Computer science is a misnomer.
16:20:51 <sorear> CS is the study of computers in the same way as astronomy is the study of telescopes.
16:20:56 <vincenz> thx
16:20:57 <atsampson> Dijkstra, "Computer science is..."
16:20:58 <sorear> Edsgar K. Dijkistra
16:21:00 <atsampson> yes, that one
16:21:25 <sorear> (spelling and phrasing are guaranteed corrupted)
16:22:16 <astrolabe> "Computer science is as much about computers as
16:22:16 <astrolabe>         astronomy is about telescopes" -- Edsger Dijkstra
16:22:35 <vincenz> gracias senors
16:24:03 <mbishop> in SICP they say "...as geography is about plotting equipment"
16:24:16 <vincenz> hmm
16:24:26 <vincenz> on /. it'd prolly be "...as sex is about porn"
16:24:39 <vincenz> tho that might confuse many
16:27:45 <SlowByte> ooh, Knuth advocates syntactically significant whitespace
16:28:05 <vincenz> yeps
16:29:41 <dons> hey guys, I'm thinking of creating a "Libraries wanted" page
16:29:52 <dons> where people can suggest libraries they have wanted, but could find.
16:29:58 <Pseudonym> More like as geography is about maps.
16:30:16 <sorear> I second that suggestion.
16:30:41 <sorear> oh wait - s/could/couldn't/ ?
16:30:57 <dons> couldn't :)
16:31:15 <dons> I have a standard Binary based on bytestrings, and a popen :: String -> IO String
16:31:18 <dons> on the top of my list
16:31:24 <dons> but I guess people have other things they want/need
16:31:29 <vincenz> holy cow
16:31:30 <dons> if we know, then we can write them !
16:31:32 <vincenz> this is valid c++
16:31:34 <vincenz> rule letter = range(a', z) | range(A', Z);
16:31:34 <vincenz> rule digit = range(0, 9);
16:31:34 <vincenz> rule alphanumeric = digit | letter;
16:31:34 <vincenz> rule id = *letter << *alphanumeric;
16:31:36 <vincenz> rule num = +digit;
16:31:39 <vincenz> rule cmdLine = *('-' << (id | num));
16:31:45 <mauke> boost.spirit?
16:31:45 <vincenz> talk about hacking operator-overloading
16:31:48 <vincenz> mauke: yah
16:32:07 <mauke> half of your quotes are borked, though :-)
16:32:08 <SlowByte> boost makes me cry
16:32:18 <vincenz> mauke: copy paste from a website
16:32:36 <SlowByte> so much intelligence wasted on C++ :)
16:32:41 <vincenz> yeah
16:32:43 <vincenz> make things hard
16:32:58 <mauke> vincenz: http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
16:32:59 <vincenz> then make "Really Cool Things"(TM) by being able to do simple complicated things
16:33:16 <vincenz> (and for those that do not know, complex != complicated, read up on the blogosphere)
16:33:39 <vincenz> mauke: woo
16:33:46 <vincenz> mauke: he's in #oasis btw
16:34:08 <mauke> who? eelis?
16:34:11 <vincenz> yah
16:35:26 <vincenz> mauke: the | vs ! usage aint' clear for 3d tho
16:36:01 <mauke> | for the first one, ! for the rest
16:36:13 <mauke> wait
16:36:18 <sjanssen> dons: perhaps work on a djinn-module would be nicer than a wiki page? ;)
16:36:28 <mauke> yeah, you have to actually know what you're doing :/
16:36:56 <dons> sjanssen: heh
16:39:13 <vincenz> mbishop: welcome to idle there ;)
16:39:44 <augustss> vincenz: I see your boost paste scrolling off my screen :)
16:39:52 <vincenz> augustss: sorry for spam
16:39:55 <vincenz> not even mine
16:40:08 <aFlag> I think C++ may be a reasonable alternative sometimes
16:40:14 <augustss> i think it's very cool, actually
16:40:22 <vincenz> augustss: it has some downsides
16:40:30 <augustss> c++ with templates is very powerful
16:40:34 <vincenz> augustss: like things not being -quite- there yet
16:40:45 * vincenz has struggled with some cornercases with c++
16:41:08 <augustss> what disturbs me most is the lack of types on the template level
16:41:13 <aFlag> yes, c++ is full of cornercases, and it might be hard to write portable code
16:41:15 <mgsloan> yeah, c++ templates can do some things that the haskell type system can't do nicely
16:41:28 <aFlag> as there's lots of implemententations of c++ that misses some of its features
16:41:37 <vincenz> augustss: Well one thing that sadly was not possible was operator. overloading, which would've been great for my paper on profiling
16:41:38 <aFlag> mgsloan: like what?
16:41:38 <mgsloan> but it isn't very fun to do so, and hard to do it properly
16:41:48 <vincenz> augustss: ducktyping
16:41:52 <vincenz> erm, aFlag even
16:42:06 <mgsloan> dependant typing, as in where the template parameters are things like integers
16:42:20 <vincenz> augustss: additionally, if you have two template wrappers, that both have operator T() overloaded, it won't do a double convert
16:42:29 <augustss> mgsloan: yes, that's ver awkward in haskell
16:42:29 <vincenz> augustss: even if it's the only possible path (and not doing it leadsd to a compiler error)
16:42:32 <aFlag> vincenz: doesn't Data.Dynamic handles that?
16:42:52 <vincenz> aFlag: dunno, that's one of the few areas of haskell I'm less famiiliar with
16:43:31 <augustss> it seems that all the rage about c++ these days is the templates.  which is a pure functional language. :)
16:43:40 <aFlag> I've never used that, actually, but it seems to introduce some kind of duck typing into haskell
16:43:42 <augustss> by accident, of course
16:44:02 <augustss> just like haskell has an untyped logic language on the type level by accident
16:44:11 <vincenz> augustss: try compiling 140-level deep templates :P
16:44:26 <vincenz> serious code-bloat
16:44:32 <augustss> vincenz: just an implementation problem ;)
16:44:46 <vincenz> Coolest thing I ever did in templates is automatic currying of functors
16:44:48 <aFlag> i'm not sure it's an implementation *problem*
16:44:54 <augustss> and c++ makes haskell error messages look very good
16:45:10 <mgsloan> hah, yeah
16:45:19 <Pseudonym> http://andrew.bromage.org/darcs/supply/
16:45:20 <lambdabot> Title: Index of /darcs/supply
16:45:21 <vincenz> augustss: http://homes.esat.kuleuven.be/~cpoucet/papers/icme2006.pdf
16:45:25 <Pseudonym> My quick hack at a name supply monad.
16:45:31 <aFlag> they have a reason to create new versions of the almost same code whey you use templates
16:45:37 <aFlag> and the reason seems to be efficiency
16:45:38 <Pseudonym> It's times like this you really need associated types.
16:45:56 <Pseudonym> But the nice part about this one is that you can't mix names from different monads.
16:45:58 <Pseudonym> Much like ST.
16:46:01 <vincenz> Pseudonym: woah, spammy
16:46:16 <Excedrin> how do you limit quickcheck to positive integers?
16:46:42 <Pseudonym> At least in the default NameSupply.
16:46:49 <augustss> Excedrin: write a custom generator
16:46:50 <Pseudonym> It's typeclassed, so you can define your own names.
16:47:06 <vincenz> Pseudonym: still
16:47:12 <vincenz> Pseudonym: a simple monad supply with as starting parameter a list
16:47:14 <augustss> Excedrin: forall positive $ \ i -> ...
16:47:17 <vincenz> Pseudonym: and then the fix-able function I gave before
16:47:38 <Pseudonym> I think that the ability not to mix names is important.
16:47:42 <mbishop> vincenz: I've been idling here quite a while :P
16:47:52 <vincenz> mbishop: hmm?
16:48:03 <augustss> mbishop: relax, no need to speak ;)
16:48:07 <vincenz> non-sequitur?
16:48:10 <Pseudonym> In fact, I'm pretty sure that names can't "escape" this monad.
16:48:30 <vincenz> mbishop: where did that come from?
16:48:50 <mbishop> vincenz: what you mentioned before...I was eating heh, but you said feel free to idle here
16:49:00 <augustss> mmmmm, food
16:49:11 <vincenz> mbishop: oh, must've been long ago?
16:49:28 <mbishop> [18:31] <vincenz> mbishop: welcome to idle there ;)
16:49:36 <mbishop> 10 minutes :P
16:49:55 <augustss> I love watching "Sunrise Earth" in the background on Discovery HD.  wish I had a bigger screen, though
16:50:19 <Pseudonym> vincenz: In this version, runSupplyNS supply == runSupplyNS supply won't type check.
16:50:20 <xerox> augustss: video stream?
16:50:33 <Pseudonym> But runSupplyNS (do x <- supply; y <- supply, return (x == y)) will.
16:50:35 <augustss> just one of the HD cable channels
16:50:56 <Pseudonym> Well, when you turn the , into a ;
16:50:57 <vincenz> Pseudonym: seems counterintuitive
16:51:01 <augustss> when I got the TV i thought 50" was big.  now it looks small
16:51:02 <Pseudonym> Why?
16:51:07 <vincenz> Pseudonym: I'd expect the opposite
16:51:10 <newsham> 50" is small?
16:51:13 <vincenz> Pseudonym: x /= y
16:51:18 <mbishop> my monitor is almost as big as my tv :/
16:51:19 <vincenz> supplied elements should be unique
16:51:20 <Pseudonym> Yes, it returns False.
16:51:22 <Pseudonym> But it type checks.
16:51:27 <vincenz> oh
16:51:28 <augustss> newsham: it's subjective
16:51:34 <Pseudonym> The former doesn't even type check correctly.
16:51:43 <augustss> I want the whole wall covered!
16:51:59 <Pseudonym> vincenz: You see the advantage?
16:52:18 <vincenz> Pseudonym: Not quite
16:52:26 <Pseudonym> Every time you call runSupplyNS, it creates a new name supply, and names from one aren't even the same type as names from another.
16:52:35 <vincenz> ah, i see
16:52:39 <Pseudonym> That way, you can't accidentally end up with non-unique names from different supplies.
16:52:40 <vincenz> That is useful indeed
16:52:51 <vincenz> hackish, I bet
16:52:57 <Pseudonym> No more than RUNST.
16:52:59 <Pseudonym> runST
16:53:08 <vincenz> ah, but what if you're out of ST?
16:53:21 <augustss> runST is a beautiful hack :)
16:53:28 <Pseudonym> Outside of ST, refs are useless.
16:53:35 <augustss> hack in the best sense of the word
16:53:39 <Pseudonym> In my Supply, they're still useful.
16:53:50 <Pseudonym> In the sense that they're still members of Ord.
16:53:55 <Pseudonym> And Show.
16:53:58 <mathewm> are/can record updates be made strict?
16:54:29 <Pseudonym> The one problem that I have is that two distinct calls to runSupplyNS will make names which are show-equivalent.
16:54:33 <Pseudonym> Even if they're not of the same type.
16:54:43 <Pseudonym> But you can't Read them, so I think that's okay.
16:54:56 <augustss> Ord and Show....  that's dodgy :)
16:55:53 <Pseudonym> You need Ord because you need to be able to put names in a Data.Map.
16:56:18 <Pseudonym> Incidentally, a prize to anyone who works out why a Supply transformer makes no sense.
16:56:48 <augustss> Yeah.  I wish there was a way to have them ordered without revealing the actual order.  I mean, just so that Data.Map works
16:57:37 <vincenz> Pseudonym: Supply is already based o the lower monad
16:57:45 <vincenz> wait
16:57:48 * vincenz shuts up
16:58:03 <Pseudonym> It's actually splitNameSupply that makes no sense.
16:58:25 <vincenz> sure that makes sense to you :)
16:58:25 <Pseudonym> Because the "underneath" monad serialises the computation.
16:58:28 * augustss marvels at what some extra saturation does to the colors on Sunrise Earth. :)
16:58:33 <vincenz> anyways, how do you forego that it won't typecheck?
16:58:33 <Cale> What kind of supply?
16:58:45 <Pseudonym> Cale: http://andrew.bromage.org/darcs/supply/Supply.hs
16:59:09 <Pseudonym> Type-safe name supply monad.
16:59:15 <Pseudonym> The type-safe bit is the cool part.
16:59:32 <augustss> So I want to implement it like this: http://www.dcs.gla.ac.uk/jfp/bibliography/References/augustssonrs1994:117.html
16:59:35 <lambdabot> Title: Journal of Functional Programming Bibliography, http://tinyurl.com/y4xbdr
16:59:36 <vincenz> how does it work
17:00:02 <Pseudonym> First off, the type of the monad is Supply ns n a
17:00:13 <Pseudonym> Where ns is the type of a name supply, and n is the type of a name.
17:00:23 <Pseudonym> I need to clean that up a bit.  This is just a proof of concept.
17:00:25 <Excedrin> heh, using 'positive = choose (0, maxBound :: Int)' is not a great idea when it's used as list length...
17:00:39 <Pseudonym> So when you supply a name, you get a "n".
17:00:49 <Pseudonym> newtype Name s = Name Integer
17:00:52 <Pseudonym> Note the phantom type.
17:01:11 <Pseudonym> We guarantee that it's different for each run of the monad using an existential type:
17:01:17 <Pseudonym> runSupplyNS :: forall a. (forall s. Supply (NS s) (Name s) a) -> a
17:01:27 <vincenz> ah
17:01:31 <Pseudonym> And GHC does the rest.
17:02:22 <Pseudonym> OK, names definitely can't escape the monad.
17:02:30 <Pseudonym> let (x,y) = runSupplyNS (do x <- supply; y <- supply; return (x,y)) in x == y
17:02:33 <Pseudonym> That doesn't type check.
17:03:01 <Pseudonym> runSupplyNS (do x <- supply; y <- supply; return $ x == y)
17:03:08 <Pseudonym> That does, and it returns False.
17:03:28 <Pseudonym> I wonder if you could get names to escape the monad, so the former makes sense.
17:05:20 <vincenz> make them undependent of the ghost variable?
17:05:29 <dons> kfish: sounds like someone hid their base library by accident?
17:09:12 <shapr> I read too much scifi.
17:09:44 <Pseudonym> shapr: My alien abductors think I do too.
17:10:01 <shapr> I'm keeping it down to one book a day at least.
17:10:18 <kfish> dons: ie. the user accidentally typed "ghc-pkg hide base"?
17:11:35 <jlouis> oy shapr, hows code?
17:11:58 <dons> kfish: or some how mangled their system (something hid base?)
17:12:11 <kfish> dons: anything's possible ... the user's never used haskell before though
17:12:18 <dons> kfish: so ghc-pkg expose base maybe?
17:12:25 <dons> kfish: so I gather. well done!
17:12:32 <kfish> dons: heh
17:12:35 <dons> kfish++ pushing the boundaries
17:12:41 <dons> ?users
17:12:41 <lambdabot> Maximum users seen in #haskell: 288, currently: 262 (91.0%), active: 50 (19.1%)
17:13:04 <shapr> jlouis: I've been thinking about my Manifesto
17:13:05 <dons> we hit a new chan high score last night, and are (still?) bigger than #python
17:13:08 <jlouis> dons, we are nasty high up in the count now
17:13:11 <shapr> dons: wow
17:13:14 <dons> jlouis: damn straith
17:13:21 <kfish> dons: i'll ask him to try exposing it. It'd be a bit broken if the FC6 package came like that by default :-/
17:13:24 <dons> shapr: I think we briefy hit #12 , ahead of #asterix
17:13:31 <shapr> impressive!
17:13:36 <jlouis> #asterisk
17:13:39 <dons> kfish: yes. get a full ghc-pkg list
17:13:44 <jlouis> Oh don't get me started on that crap
17:13:44 <vincenz> newsham: that book any help?
17:13:50 <mathewm> move over Java, here comes Haskell!
17:13:54 <dons> oh, I thought it was a channel for talking about Asterix, jlouis :}
17:13:57 <jlouis> We are debugging * at work.
17:14:00 <Pseudonym> You have a manifesto?
17:14:07 <mbishop> heh
17:14:12 <mbishop> I know a guy who works for digium
17:14:23 <jlouis> And we have currently learned one thing: Their thread model is crap.
17:14:25 <shapr> Yeah, basically that the goal of computers is to find representations of problems that allow humans to solve problems without requiring computers.
17:14:44 <dons> shapr: I see you got on to the CUFP committee. well done!
17:15:00 <shapr> dons: Yeah, and I've already got an interesting hit or two.
17:15:01 <dons> shapr++ community recognition :)
17:15:04 <shapr> :-)
17:15:11 <jlouis> dons, how many people are there in #Obelix?
17:15:30 <vincenz> jlouis: they're all ini #idefix
17:15:30 <shapr> But I'm always looking for more ideas on who to invite to CUFP2007, so if anybody has suggestions, tell me!
17:16:42 <dibblego> is there a library function that keeps a memoised list length?
17:16:53 <dibblego> or type, I should say
17:17:11 <Heffalump> you want to pass around a tuple of length + the actual list?
17:17:45 <dibblego> data MList = MList [a] Int -- I was thinking something like that
17:17:59 <shapr> HaskellDB has BoundedList and some other tricks to typecheck varchar(N) SQL types.
17:18:44 <Heffalump> dibblego: what would you do with infinite lists?
17:19:02 <dibblego> I wouldn't
17:19:08 <beelsebob> hehe
17:19:58 <augustss> shapr: i think you should try and find some Common Lisp users
17:20:13 <dons> shapr: do you follow reddit?
17:20:33 <sjanssen> dibblego: there is Data.Sequence, which is an entirely different data structure, but has O(1) length
17:20:36 <dibblego> calling the type constructor MList would never complete
17:20:42 <dibblego> sjanssen, ok thanks
17:21:40 <sjanssen> dibblego: plus logarithmic index and concatenation
17:21:49 <dons> shapr: see the comments on CUFP here: http://programming.reddit.com/info/u3p2/comments
17:21:50 <lambdabot> Title: search Ask Reddit: Which is the most USABLE functional language, right now? (red ...
17:21:52 <Excedrin> how can I go from (Gen Int, Gen Int) to Gen (Int, Int) ?
17:21:56 <dons> there's some of the lisp projects mentoined
17:22:07 <dibblego> sjanssen, nice, the downside?
17:22:07 <dons> and I wonder if there are any commerical F# users now... ?
17:22:24 <dibblego> dons, I'll bet there will be soon if not; a bit worrying
17:23:25 <mgsloan> there probably are already some, just kinda to the same extent as commercial haskell users - mostly internal tools
17:24:04 * beelsebob wonders around poking those of you who happen to be lecturers for advice
17:24:23 <dons> is F# really a rebadged Ocaml?
17:24:29 <dons> (anyone with some experience with it?)
17:24:44 <dons> beelsebob: did you get anywhere with the hat plugin?
17:24:54 <sjanssen> dibblego: operations like head and tail are still O(1), but slower in practice compared to lists
17:25:50 <beelsebob> dons: yes and no - it's now separated, ready to be libraryised
17:25:54 <beelsebob> but it's still buggy
17:26:16 <dons> beelsebob: ok.
17:26:19 <sjanssen> @type uncurry (liftM2 (,)) -- something like this, Excedrin?
17:26:20 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => (m a1, m a2) -> m (a1, a2)
17:26:31 <dons> send me the code and the use instructions when you're done, and I can write the lambdabot glue
17:27:17 <shapr> dons: Thanks, I'll read that.
17:27:28 <shapr> augustss: Any specific CL users?
17:27:41 <dibblego> is it standard practice to explicitly import each used function rather than an entire module?
17:27:43 <beelsebob> dons: when it's done I'll push to hat darcs
17:27:44 <beelsebob> and tell you
17:27:57 <dons> beelsebob: great
17:28:02 <augustss> shapr: no, but i know that CL is used in anger out there
17:29:23 <Baughn> dibblego: That, or a qualified import, yes. More predictable like that.
17:29:47 <shapr> augustss: Thanks for the suggestion.
17:35:28 <dons> augustss: in the US there still seems to be quite a bit of lisp integration
17:35:36 <dons> its still quite high on that jobs index page
17:35:48 <dons> (and I see haskell's risen about 5 spots in job vacancy rates!)
17:36:24 <dons> we're now ahead of ocaml and erlang for the first time, I think
17:36:24 <Pseudonym> Where are all these job vacancies?!
17:37:06 <Igloo> Are those real Haskell posts? The site I saw a while ago with lots of vacancies had lots of random jobs in Haskell, <I forget which state>, USA
17:37:32 <dons> here: http://www.tiobe.com/tpci.htm
17:37:34 <lambdabot> Title: TPCI - TIOBE Programming Community Index
17:37:37 <dons> I think this one is a bit more thorough
17:37:49 <mgsloan> dons - F# is pretty much the same as OCaml, just targeted towards .net.  Not sure what they've done as far as OCaml libs though
17:37:55 <dons> (and just a couple of weeks ago someone was blogging about "waiting for haskell to go about 0.1% :)
17:38:11 <dons> mgsloan: so its an ML in all but name?
17:38:32 <mgsloan> pretty much.  The F stands for functional
17:38:42 <sjanssen> dibblego: the GHC team has recently switched from using explicit imports to implicit
17:38:45 <dibblego> I heard C# 3.0 will also do the same
17:38:57 <dibblego> sjanssen, what's an implicit import?
17:39:03 <Korollary> screw those indices
17:39:30 <mgsloan> I guess they decided that ML is the most known functional language, while still working well within their system (which haskell wouldn't, without changing quite a bit)
17:39:32 <sjanssen> dibblego: I mean they've switched from "import Foo (bar, baz)" to "import Foo"
17:39:34 <dibblego> as in, import the entire module?
17:39:39 <dibblego> oh, why?
17:40:19 <dons> so lisp/scheme are sitting at #17, which frankly I find a bit scary
17:40:23 <aFlag> sjanssen: what are implicit imports?
17:40:39 <dons> this might relfect the bias towards lisp-ish things in the US jobs market?
17:40:40 <dibblego> dons, where is the table you are looking at?
17:40:43 <aFlag> if you use a function that's not on some module imported then it will be automatically imported?
17:40:45 <dons> we need to get big in the US :)
17:40:51 <dons> dibblego: http://www.tiobe.com/tpci.htm
17:40:51 <lambdabot> Title: TPCI - TIOBE Programming Community Index
17:41:38 <newsham> british imports dont generally do well in america.  except maybe the beatles
17:41:47 <dibblego> I question the ranking method
17:41:48 <Pseudonym> And Elton John.
17:42:10 <dons> the rolling stones?
17:42:11 <Pseudonym> I want to know where these job adverts actually are.
17:42:17 <newsham> rolling stones?
17:42:17 <dibblego> module US where import GHC.Base
17:42:25 <Pseudonym> They never tell you that on this index page.
17:42:37 <mgsloan> black sabbath ;P
17:42:47 <newsham> thats the band with nick jaggor right?
17:42:51 <sjanssen> aFlag: "implicit import" is me inventing confusing terminology.  I really mean importing an entire module rather than select functions from that module
17:43:05 <aFlag> oh
17:43:11 <dons> newsham: right
17:43:14 <mgsloan> newsham - mick jagger
17:43:39 <dons> is haskell radiohead or blur then?
17:43:47 <dibblego> I find Ruby's position scarier than Lisp/Scheme
17:43:48 <dons> mm. maybe haskell is radiohead
17:43:58 <Pseudonym> Scheme is Oasis.
17:44:09 <dons> hehe
17:44:10 <aFlag> who's britney spears?
17:44:10 <Pseudonym> And Paul Graham is Noel Gallagher.
17:44:28 <Pseudonym> aFlag: VBA keeps showing its lack of undies.
17:44:30 <dons> who's Pulp then? OCaml?
17:45:20 <shapr> Visual Basic 4 and lower are Vanilla Ice.
17:45:45 <dons> interesting that lisp is trending downward -0.13%, while haskell jumped about 0.05 or so
17:46:08 <Pseudonym> dons: Proportions can be misleading.
17:46:12 <shapr> I am only surprised the number is that small.
17:46:15 <Pseudonym> If the total number of jobs went up...
17:47:37 * mgsloan finds some 'blur' - i think I like it better than radiohead at least...
17:48:24 <shapr> Speaking of which, does anyone else here use last.fm ?
17:48:35 <Korollary> shapr: you know I do
17:48:59 <shapr> yeah, I have you on my friends list :-) and liyang and binkely, and a few others.
17:49:14 <Korollary> I havent used it much lately tho
17:56:03 <dons> http://programming.reddit.com/info/udq0/comments  :)
17:56:05 <lambdabot> Title: Why wait? Multicore programming with transactional memory ... now! (reddit.com)
17:56:23 <dons> in response to a scary/tedious article about waiting for STM in Java..
17:59:53 * Philippa_ reads up and wonders who's the Prodigy - except that they only really made it in the US after all the fun stuff
18:00:26 <dons> hehe
18:01:10 <dons> Philippa_: you said earlier that binary IO was hard?
18:01:40 <dons> have you tried NewBinary? I think the whole get/put interface (modelled on read/show) is pretty easy to use
18:01:48 <dons> (but should be in an extralib with ghc...)
18:01:53 <Philippa_> *nod*
18:02:07 <Philippa_> I haven't tried it, and I should remember to if/when I have cause to do any non-trivial binary IO
18:02:18 <dons> yeah, its pretty simple to use
18:02:24 <dons> would be better if we could deriving Binary
18:02:26 <dons> then things would take off
18:02:29 <Philippa_> (last time I was doing any, blocks of word8 were plenty sufficient because I was just deinterleaving a file)
18:02:43 <dons> i hope to get a Binary that has: a -> ByteString ; ByteString -> a
18:02:46 <dons> done for the hackathon
18:02:47 <Philippa_> yeah. Oh well, it's not as if I'm not used to writing parsers and pretty-printers
18:02:54 <Philippa_> cool
18:03:30 <Philippa_> has anyone put much thought into a readable solution for pretty-printing bytefields or other formats that aren't at least byte-aligned?
18:03:51 <Philippa_> I mean, I can put up with "just build it into bytes the hard way"...
18:03:59 <Philippa_> ...but shifting's so C :-)
18:04:10 <shapr> Have you seen BitSyntax from imperialviolet.org?
18:04:12 <dons> hmm. there's the bitsyntax library
18:08:07 <dons> Pseudonym: oh nice.
18:08:15 <dons> Haskell:  Stanley Kubrick famously once said that he doesn't make the sort of
18:08:15 <dons> movies that he thinks other people want to see, he makes the sort of
18:08:16 <dons> movies that HE wants to see.
18:10:23 <beelsebob> dons: you know I was talking to you about my gf?
18:11:05 <dons> yeah
18:11:14 <beelsebob> she's not my gf any more
18:11:23 <beelsebob> she's my fianc :DD
18:11:28 <dons> hey!!
18:11:33 <dons> CONGRATULATIONS!
18:11:59 <beelsebob> thank you :)
18:12:05 * beelsebob is grinning like a badger
18:12:05 <lambdabot> Congratulations beelsebob!
18:12:13 <beelsebob> thank you lambdabot
18:12:15 <lambdabot> my heart is broken..
18:12:19 <beelsebob> @vixen did you really mean that?
18:12:20 <lambdabot> i'm really real
18:15:19 <Pseudonym> Woo!  Congrats!
18:15:28 * Pseudonym is slow on the uptaek
18:15:32 <Pseudonym> uptake
18:15:49 <Philippa_> beelsebob: 'grats
18:15:59 <beelsebob> thanks Philippa_
18:16:41 <robreim> beelsebob: Congratulations
18:16:46 <beelsebob> thanks Pseudonym
18:16:53 <beelsebob> :DD thanksies whole channel
18:19:02 <liquidengineer> Hello
18:19:19 <liquidengineer> fromIntegral converts ints to Floats, right?
18:19:33 <beelsebob> no
18:19:40 <liquidengineer> okay then
18:19:42 <beelsebob> it converts an integral type to any numeric type
18:19:50 <liquidengineer> Oh
18:19:51 <beelsebob> @type fromInteger
18:19:52 <lambdabot> forall a. (Num a) => Integer -> a
18:19:58 <beelsebob> oh... okay no
18:20:01 <liquidengineer> So...let's say I've got a number sum
18:20:02 <shoffsta> Congrats, beelsebob!
18:20:03 <beelsebob> it converts Integers
18:20:07 <beelsebob> to any numeric type
18:20:07 <liquidengineer> and I need to square it
18:20:09 <beelsebob> thanks shoffsta
18:20:13 <beelsebob> okay
18:20:15 <liquidengineer> er...sqrt it
18:20:18 <beelsebob> okay
18:20:23 <beelsebob> @type sqrt
18:20:25 <liquidengineer> and I need to preserve floating point information
18:20:25 <lambdabot> forall a. (Floating a) => a -> a
18:20:42 <beelsebob> @type sqrt . fromInteger
18:20:44 <lambdabot> forall a. (Floating a) => Integer -> a
18:20:48 <beelsebob> :)
18:20:51 <beelsebob> that do you?
18:20:58 <sorear> :t fromIntegral
18:21:00 <lambdabot> forall b a. (Num b, Integral a) => a -> b
18:21:01 <liquidengineer> Hmmm....
18:21:28 <liquidengineer> so....the sum is turned into a Float and then sqrted?
18:21:36 <liquidengineer> I don't use composition hardly ever
18:21:42 <dons> you should :)
18:21:45 <beelsebob> liquidengineer: yes, that's right
18:21:56 <liquidengineer> dons: Yeah, I know
18:22:10 <liquidengineer> dons: I caught myself trying to take the head of the tail of a list the other day
18:22:13 <liquidengineer> Scheme messed me up
18:22:17 <dons> hehe
18:22:20 <dons> it does that
18:22:23 <sjanssen> liquidengineer: it is converted into a Double, to be exact
18:22:34 <beelsebob> sjanssen: not necessarily
18:22:40 <liquidengineer> I'm running 6.6
18:22:41 <beelsebob> it's converted to a Double under defaulting
18:22:44 <liquidengineer> I use fromIntegral right?
18:22:50 <dons> remember: it ain't functional unless its Haskell     ;)
18:22:56 <beelsebob> but if there's an aditional type constraint it may be converted to any floating point type
18:23:53 * beelsebob goes to snuggle his fianc
18:24:40 <liquidengineer> wierd
18:25:10 <liquidengineer> This gives me a massive error
18:25:11 <liquidengineer> sqrt . fromIntegral 33
18:25:22 <sjanssen> sqrt . fromIntegral $ 33
18:25:34 <liquidengineer> What's the dollar sign do?
18:25:38 <sjanssen> or sqrt (fromIntegral 33)
18:25:46 <sjanssen> liquidengineer: it's a precedence trick
18:26:28 <sjanssen> in this case, you could write (sqrt . fromIntegral) 33 instead
18:27:48 <liquidengineer> I don't mind just using parentheses
18:27:52 <liquidengineer> :)
18:27:57 <dons> just for fun, http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11#interpreters-with-reader-monads
18:27:58 <liquidengineer> Another quick question
18:28:00 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/y7wvnq
18:28:08 <liquidengineer> I have a list of pairs of Ints
18:28:25 <liquidengineer> I want to use Data.Set to remove the duplicates from the list
18:28:55 * beelsebob suggests Data.Set.toList
18:29:00 <dons> nub?
18:29:03 <beelsebob> fromList even
18:29:10 <liquidengineer> okay
18:29:12 <beelsebob> dons: nub won't work
18:29:20 <liquidengineer> so I don't have to do anything because I'm using a wierd type?
18:29:23 <beelsebob> or will
18:29:25 <liquidengineer> I'm used to using IntSet
18:29:25 <dmead> nub
18:29:25 <dmead> hehe
18:29:27 <beelsebob> depending on the semantics needed
18:29:41 <liquidengineer> I just wanted to make sure my type wouldn't cause me problems.
18:29:52 <sjanssen> liquidengineer: as long as the type is an instance of Ord, then Data.Set will work fine
18:29:59 <dons> > let s = [1,1,1,2,4,3,2] in M.elems (M.fromList (zip s s))
18:30:01 <lambdabot>  [1,2,3,4]
18:30:15 <dons> (just reminded me of my perl days with %{} )
18:30:16 <sjanssen> and (Int, Int) is an instance of Ord
18:30:28 <allbery_b> "and reimplementing the rest of Ruby" heh
18:30:45 <dons> allbery_b: thanks :)
18:31:22 <sjanssen> dons: what is your plan for serialization with ByteString?
18:31:28 * allbery_b adds feed
18:31:47 <dons> sjanssen: I think a basic a -> ByteString and back will be most flexible in the long run
18:31:58 <dons> now, musabi made significant progress on this, iirc
18:32:06 <dons> which i'd like to use to turn into the *real thing*
18:32:13 <dons> and get into extra-libs
18:32:25 <dons> keep it simple, then look at deriving Binary
18:32:26 <sjanssen> ah, so not based on anything like NewBinary?
18:32:31 <dons> similar idea
18:32:39 <dons> but ditch all the ugly low level gunk
18:32:50 <dons> and rely on bytestrings being fast instead
18:33:54 <newsham> > ((map (read.return)).(filter isDigit).show.exp) 1 :: [Int]
18:33:56 <lambdabot>  [2,7,1,8,2,8,1,8,2,8,4,5,9,0,4,5]
18:34:01 <sorear> idea: extend SYB to assign numbers/names to constructors, then implement serialization using that in several different formats.
18:34:19 <Lemmih> Kick ass. I just downloaded a 1GB movie with conjure. yay.
18:34:27 <dons> Lemmih: excellent!
18:34:27 <sorear> (XML, sexp, binary, binary-with-pointers-and-lazy-loading, etc)
18:34:41 <dons> lazy bytestrings being sucked down, Lemmih ?
18:34:43 <sjanssen> I find that NewBinary has IO in all the operations quite distasteful
18:34:50 <dons> sjanssen: agreed
18:34:55 <newsham> > ((map (read.return)).(filter isDigit).show.(4 *).atan) 1 :: [Int]
18:34:57 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3]
18:35:06 <dons> a proper , acceptable , binary lib should be more like dcoutts gzip bindings
18:35:10 <dons> pure transformations
18:35:19 <dons> much more flexible in that regard
18:35:22 <Lemmih> dons: Lazy bytestrings doesn't really work well with the block based protocol.
18:35:28 <dons> ah right
18:35:32 <sjanssen> dons: you wouldn't happen to have a link to musasabi's hackings?
18:35:46 <dons> sjanssen: only that they were talking about it in here a month or two ago
18:35:51 <dons> dcoutts: would have some more details
18:36:51 <sorear> How hard would it be to create a class Data a => NData a with operations to add names/numbers to constructors, with deriving support?
18:36:56 <dons> man i hate the jvm
18:37:05 * dons disables java from firefox once and for all
18:37:22 <dons> but it won't die!
18:37:23 <dons> urgh!
18:37:28 <dons> pkill -KILL java
18:37:28 <allbery_b> par
18:37:38 <allbery_b> hm, embedded haskell?
18:37:45 <dons> 192M 89.26% java_vm
18:37:53 <dons> die die die!
18:38:06 <dons> ah, finnally, $ pkill -KILL java
18:39:30 <dmead> i find that doing pkill as root is more effective than a normal user
18:42:29 <dons> allbery_b: did you get any insights from that blog post? any feedback?
18:42:40 <sorear> what do people think of keeping constructor data around at runtime?
18:42:55 <dons> sorear: i'm sure it would be useful
18:43:03 <dons> for special cases
18:43:10 <dons> i wouldn't want to keep it around for everything :)
18:50:05 <liquidengineer> how do I append a single item to a list?
18:50:13 <liquidengineer> ++ connects two lists
18:50:18 <dons> to the end?
18:50:21 <liquidengineer> yeah
18:50:38 <dons> ?let snoc xs x = xs ++ [x]
18:50:39 <lambdabot> Defined.
18:50:46 <dons> > L.snoc "haskell" '!'
18:50:47 <lambdabot>  "haskell!"
18:51:04 <liquidengineer> what does that mean?
18:51:07 <dons> if you're doing a lot of this, DLists or some other efficient (O(1)) append might be better
18:51:13 <dons> liquidengineer: what does what mean?
18:51:21 <liquidengineer> that L.snoc thing
18:51:27 <dons> ?pl snoc xs x = xs ++ [x]
18:51:28 <lambdabot> snoc = (. return) . (++)
18:51:35 <dons> oh, that's just a (Local) snoc
18:51:39 <liquidengineer> ah
18:51:46 <dons> I defined : snoc xs x = xs ++ [x]
18:51:47 <liquidengineer> so snoc isn't part of the prelude
18:51:52 <dons> and can refer to it with the L. prefix
18:51:57 <dons> (in lambdabot)
18:52:00 <liquidengineer> ah
18:52:02 <liquidengineer> cool
18:52:03 <dons> right, its not part of the prelude
18:52:11 <Stinger_> he just defined snoc above
18:52:13 <liquidengineer> so really there's no way to do it short of making my item into a singleton list?
18:52:23 <dons> that's how yo udo it, yes.
18:52:27 <aFlag> > L.snoc "a" 'b'
18:52:29 <lambdabot>  "ab"
18:52:29 <liquidengineer> ]okay
18:52:32 <liquidengineer> that's what I was gonna do
18:52:36 <liquidengineer> I wanted to check first, though
18:52:50 <aFlag> when you define something on lambda bot it's forever defined?
18:53:06 <dons> nope
18:53:08 <dons> ?undefine
18:53:09 <lambdabot> Undefined.
18:53:11 <dons> bye bye!
18:53:59 <slime_mold> can DList be infinite?
18:54:19 <dons> yeah, here:
18:54:20 <dons> type DList a = [a] -> [a]
18:54:25 <dons> zeroDL  = id
18:54:31 <dons> snocDL      :: DList a -> a -> DList a
18:54:31 <dons> snocDL dl x  = \l -> dl (x:l)
18:54:37 <dons> closeDL :: DList a -> [a]
18:54:38 <dons> closeDL  = ($[])
18:54:47 <dons> (I should package this up into a tiny cabal package...)
18:55:01 * dons does so
18:57:07 * dons blogs while creating this cabal repo...
18:58:12 <sorear> ?help set lastlog
18:58:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:02:54 <liquidengineer> oh
19:02:56 <liquidengineer> brilliant
19:03:18 <liquidengineer> I don't suppose there's a command to break out of a currently running task in ghci
19:03:24 <liquidengineer> like, the infinite list it's spewing
19:03:38 <allbery_b> hrm.  blosxom doesn't play nicely with NNW :/
19:03:43 <liquidengineer> I could wait for a stack overflow, but i've got a lot of RAM
19:04:21 <allbery_b> control-C doesn't work?
19:04:21 <sorear> Ctrl-C *usually* does the trick.
19:04:39 <Stinger_> liquidengineer are you under windows?
19:04:41 <liquidengineer> Oy
19:04:45 <liquidengineer> I was hitting command
19:04:50 <allbery_b> heh
19:04:52 <Stinger_> guess not
19:04:54 <liquidengineer> I think that means I've been coding too long
19:07:38 --- mode: ChanServ set +b zptao!*@*
19:07:49 <chessguy> 'evening
19:08:04 <beelsebob> evening chessguy
19:09:06 <chessguy> what's up?
19:10:11 <beelsebob> well - I'm engaged
19:10:34 <chessguy> hey, congrats
19:10:37 <liquidengineer> Actually, I'm using nedit
19:10:41 <chessguy> when did that happen?
19:10:51 <liquidengineer> I love it, but it's in Xwindows, so ctrl is the modifer key
19:10:51 <chessguy> liquidengineer, i like nedit, myself
19:10:56 <liquidengineer> it drives me nuts
19:11:12 <liquidengineer> chessguy: you using a Haskell syntax colorer?
19:11:32 <chessguy> well, i actually don't use nedit for haskell
19:12:12 <beelsebob> liquidengineer: I'd suggest using SubEthaEdit for your Haskell coding needs on a Mac
19:12:30 <chessguy> i never got around to seeing if i could get ghc to run through cygwin
19:12:42 <chessguy> i just saw somewhere though, there's a haskell configuration file for nedit
19:12:57 <liquidengineer> beelsebob: I do Literate Haskell.  I haven't been able to find a syntax coloring config file for SubEthaEdit
19:13:01 <liquidengineer> much to my chargin
19:13:09 <beelsebob> liquidengineer: ah, I see
19:13:15 <beelsebob> hmm... *considers*
19:13:23 <liquidengineer> chessguy: Aye.  I'm using it.  It's Literate mode isn't as nice as its normal haskell mode
19:13:23 <beelsebob> I'm not sure how to write one immediately
19:13:32 <beelsebob> I wrote the non-literate version
19:13:44 <mgsloan> sorear - ah, i think I'm going to go 2d only - n diminsionality is cool, but complicates things way too much for my uses :)
19:15:21 <sorear> How is it too-complicated? - my goal is to make it easy to use for any fixed nD.
19:15:45 <aFlag> hum, nedit looks nice, but I'll stick to vim :)
19:16:17 <chessguy> nedit's default parenthesis-matching is pretty much good enough for me
19:16:21 <Cale> liquidengineer: if you have to add lots of elements to the end of a list, it will be faster to reverse the list beforehand, make all the adds and reverse it after.
19:16:27 <mgsloan> It's good for a general Geometry lib - Data.Geometry should indeed be n-diminsional
19:16:37 <chessguy> or really, i should say, delimiter-matching
19:19:21 <chessguy> well, that was a conversation-killer
19:19:28 <mgsloan> I mean, adding things gets complicated - rotations in n-diminsions gets pretty intense mathematically, ircc.  In 2d it's pretty simple, in 3d it gets complicated - have to convert to quaternions and back for linear interpolation
19:20:05 <liquidengineer> Cale: I'm only adding one at a time, and then only at random intervals
19:20:13 <mgsloan> Perhaps 4d is just a higher level quat or something, I don't know - I'm not a mathemagician
19:20:25 <sorear> You shoudn't *have* to make it n-dimensional.  rotateAroundOrigin :: a -> Vector Two a -> Vector Two a  should work
19:20:47 <sorear> nD is something that can be added in small doses.
19:22:58 <mgsloan> ah
19:23:41 <liquidengineer> I gotta go
19:23:43 <liquidengineer> bye
19:23:43 <liquidengineer> :D
19:23:48 <liquidengineer> Thanks for the help
19:24:28 <lisppaste2> sorear pasted "Generic serialisation" at http://paste.lisp.org/display/31972
19:25:44 <sorear> Suprisingly SYB already has almost all the methods needed for generic serialize and deserialize - all that would be needed for deserialize is instance Read Constr.
19:26:59 <Cale> mgsloan: How complicated it is depends on your level of abstraction. You can get rotations in any number of dimensions in a very similar way that you get them in 2 dimensions, by rotating successively around each of the axes.
19:28:04 <Cale> Or if you'd like, you can treat rotations as matrices such that A A^t = I and det(A) = 1
19:28:33 <Cale> (the first condition implies that det(A) is +-1
19:28:35 <Cale> )
19:31:25 <mgsloan> sure, you can us matrices to represent and apply rotations, however, doing useful operations upon the rotations is difficult
19:32:57 <Cale> Well, you can still compose them
19:33:14 <mgsloan> yeah, mat mult
19:33:18 <Cale> Interpolation is harder
19:33:35 <mgsloan> yeah. very very hard
19:34:29 <mgsloan> I suppose that illustrates something, though - we can have n-diminsional rotations, and just have a lerp for 2d/3d
19:40:57 <trh> @version
19:40:58 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
19:40:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:41:39 <brad__> hello
19:42:38 <dons> heya brad__
19:42:49 <brad__> interesting thread on haskell-cafe...
19:42:53 <brad__> "aim of haskell"
19:42:53 <dons> which one?
19:42:56 <dons> oh :/
19:43:02 * dons thinks its not so interesting...
19:43:07 <brad__> i admit there are some kernels of truth for me
19:43:17 <brad__> i have been trying to do some web programming with haskell
19:43:25 <dons> using HAppS?
19:43:31 <brad__> why doesn't the http library provide a simple 'get' function?
19:43:43 <brad__> or a simple 'head'?
19:43:51 <dons> we don't have an http library maintainer at the moment, I think is the problem
19:44:03 <brad__> and the http lib does not cross the t's and dot the i's
19:44:09 <dons> (though with 100 committers for darcs, it shouldn't be hard to find someone qualified..)
19:44:18 <brad__> its hard to envision using this in place of perl's LWP module
19:44:30 <brad__> which dot all i's and crosses all t's
19:44:34 <dons> I agree. Better, simpler web libraries are needed
19:44:48 <dons> people who do web programming need to step up and help out!
19:45:06 <brad__> i was going to mention something like this on the list, but since i actually did contact the http maintainer (bjorns), i would feel bad "piling on" in a list
19:45:16 <dons> brad__: can you add this http issue to the new 'wanted libraries' page?
19:45:24 <dons> since it shouldn't be too hard to munge http into shape
19:45:26 <brad__> i am trying to add simple redirect support (also missing) from the http lib
19:45:42 <dons> yeah, lambdabot's got that added to a private copy of http
19:45:51 <brad__> dons - i will add to the page, which i say you mention on haskell-cafe
19:46:06 <chessguy> hey dons, what do you think about adding a request for an evolutionary computation module to the missing modules list?
19:46:17 <dons> brad__: here, add any notes on improving http, http://haskell.org/haskellwiki/Recommendations
19:46:19 <lambdabot> Title: Wanted libraries - HaskellWiki
19:46:20 <brad__> to me, modern libraries i need support for are http, xml, and something like perl's dbi
19:46:23 <dons> chessguy: well, its a bit obsucre ?
19:46:37 <chessguy> genetic algorithms?
19:46:47 <dons> brad__: right. so we have some rather good xml libs (imo), http can be polished (and should be). dbi i'm not familiar with
19:47:01 <chessguy> i didn't know they were considered obscure
19:47:15 <dons> well, i've never needed them :) i've needed better http support though :)
19:47:26 <mgsloan> doesn't seem obscure to me, but it'd be hard to make into a lib...
19:47:26 <brad__> dbi is just a way of abstracting database connectivity
19:47:26 <dons> you can add it, but it may be you who'll end up writing it ;)
19:47:43 <dons> ah ok. feel free to add that then
19:48:13 <chessguy> mgsloan, well, just the engine of it wouldn't be hard to make into a library
19:48:41 <mgsloan> hmm, the bit other than the interpreter/program format?  I suppose, but that's rather trivial anyway
19:48:54 <brad__> also of course regex's...not sure what the state of that is
19:49:02 <brad__> i know missingh had something like that (?)
19:49:50 <dons> my opinion on that thread is that its easy to complain, and only a little bit harder to do something about it. :) so people should do something about it
19:50:11 <dons> especially since for just about all common problems there's already a library there, or one that needs some polishing
19:50:13 <sjanssen> chessguy: "This page provides a list of missing and found libraries for solving common real world programmer tasks."  I'd argue that genetic programming is not common, and probably more academic than pragmatic
19:50:28 <brad__> the problem with "doing something about it" is that the quality of haskell from a beginner really is dramatically lower than that of a expert
19:50:33 <dons> (i guess it didn't help that the original poster was quite incoherant, and then Bulat follows up with more inaccuracies, sigh)
19:50:39 <brad__> more so than with other languages
19:50:49 <dons> I guess CPAN is full of junk too
19:50:55 <brad__> i would not feel comfortable writing libraries
19:51:00 <dons> really?
19:51:17 <dons> is pretty simple. i'm just finishing off a new lib today for a list type supporting O(1) append
19:51:18 <brad__> no, i would be afraid to show my garbage haskell to people with brains
19:51:25 <dons> hmm. interesting
19:51:43 <dons> but people aren't scared of showing off garbage when its in perl?
19:51:54 <mgsloan> yep, I'll agree with that sentiment
19:51:55 <trh> Heh. :)
19:52:06 <brad__> well, since cpan has a long history, most of the corners have been "shaken out" and there is quality code
19:52:11 <dons> that's interesting though: you think ther's a cultural issue that scares off beginners from writing libs?
19:52:25 <brad__> well let me say this - the haskell culture is excellent
19:52:29 <dons> since they feel they need to understand transaction memory functions in the (-> a) monad first?
19:52:33 <brad__> the lists are very helpful
19:52:35 <dons> s/functors/ ;)
19:52:41 <brad__> this channel is very helpful
19:52:44 <brad__> and very welcoming
19:52:53 <dons> great!
19:52:58 <brad__> but if you look at some quality libraries....well, i cannot write that yet
19:53:05 <chessguy> maybe a more general AI library would be considered useful, which would contain different methods of AI, including genetic stuff and neural networks, etc.?
19:53:06 <dons> we do need to lower the barrier for contributing libraries though.
19:53:15 <brad__> we need HPAN!
19:53:17 <dons> we've been working hard on this (you've seen the 'writing a haskell program' page?)
19:53:25 <geckosen1tor> dons: how do you append in O(1)?
19:53:27 <Pseudonym> CHAN
19:53:27 <dons> brad__: yes. its called hackage. should be in palce by the end of january
19:53:30 <Pseudonym> Surely?
19:53:33 <geckosen1tor> dons: do you keep tail pointers?
19:53:38 <dylan> > (liftM2 (,) head tail) [1,2,3,4]
19:53:39 <lambdabot>  (1,[2,3,4])
19:53:44 <mgsloan> yeah, I think there is an issue with libs - may be more than cultural - the language itself.  May not be such a horrible thing though - libs are what need to be quality
19:53:44 <Pseudonym> CTAN -> CPAN -> CHAN
19:53:45 <brad__> then the "missingh" problem goes away, since they are just more packages in hackage
19:53:50 <dons> geckosen1tor: gimme a second to finish writing the testsuite, and you can download it..
19:53:55 <dons> brad__: exactly
19:54:04 <geckosen1tor> dons: er.. that's ok, I don't really know haskell yet
19:54:39 <brad__> hackage will also lower the barrier to USING libraries- i DO NOT currently use libraries that i cannot get through apt-get
19:54:56 <mgsloan> (not that haskell makes writing libs hard - it's that the language allows you to write nice libs, yet to know how to do that you have to be experienced)
19:54:57 <brad__> i hope the hackage developers play a lot with cpan!
19:54:58 <Philippa_> ow, my ears...
19:55:23 <Philippa_> mgsloan: in fairness, the typical value of "nice" in haskell is extremely high :-)
19:55:32 <mgsloan> yep
19:55:48 <sorear> brad__ : one of my earlier ideas was a apt-get <--> hackage proxy server
19:56:00 <bpt> > pl \n -> f 2 where f i = map (*(n/i)) [1,3..i-1] ++ f (i*2)
19:56:01 <lambdabot>  Parse error
19:56:03 <brad__> cool sorear!
19:56:03 <dylan> I hope hackage makes it easy to produce .debs from haskell libs
19:56:18 <brad__> that would be awesome, i like to stay "in" apt
19:56:23 <dons> dylan: yeah, there's already a scrtip for cabal -> deb I think
19:56:26 <sorear> cabal was designed with producing .deb's as a goal
19:56:35 <dylan> dons: Nice.
19:57:46 <brad__> i hope hackage has an interactive interface like perl -MCPAN -e shell...
19:59:58 <wy> Are Integer and Int different types ? I got a match error!
20:00:09 <LoganCapaldo_> Yes
20:00:33 <LoganCapaldo_> Int is a machine integer, Integer is a "bignum"
20:01:17 <brad__> are there equivalents to short? char? i.e. smaller numbers
20:01:32 <LoganCapaldo_> brad__ I don't know about short
20:01:47 <LoganCapaldo_> there's Char but it can't afaik be using like a small integer
20:01:50 <brad__> i guess i am showing some systems programming bias that may be inappropriate
20:02:01 <sjanssen> brad__: check out the types in Data.Int
20:02:12 <brad__> thanks sjanssen!
20:02:28 <sjanssen> and Data.Word for the unsigned equivalents
20:02:36 <brad__> will do!
20:03:23 <wy> LoganCapaldo:  Why does haskell infer Integer? So I must declare the types
20:03:38 <brad__> by the way - is there a good library for building a DOM from a xml/xhtml document?
20:03:58 <brad__> in the sense of supporting standard DOM functionality?
20:04:05 <LoganCapaldo_> I dunno why it infers integer :) It probably invovles the types of the functions you are using
20:04:09 <mgsloan> I believe you could use the data types intended for interfacing with
20:04:11 <mgsloan> C
20:04:19 <brad__> for better or for worse, the DOM api is important
20:05:24 <sjanssen> wy: you're probably experiencing the monomorphism restriction+defaulting
20:07:47 <wy> sjanssen: The problem is that I didn't use any "Integer" in my program. How can I find this bug?
20:09:16 <sjanssen> wy: adding "default(Int)" might help
20:09:33 <wy> sjanssen: add to where?
20:10:01 <sjanssen> wy: on a line by itself in your module
20:10:57 <wy> sjanssen: It's OK now. But this is really weird
20:11:52 <sjanssen> wy: are you aware that numeric literals are polymorphic in Haskell?
20:12:14 <dons> geckosen1tor: http://www.cse.unsw.edu.au/~dons/dlist.html
20:12:14 <lambdabot> Title: DList : Difference Lists
20:12:25 <dons> ?where+ dlist http://www.cse.unsw.edu.au/~dons/dlist.html
20:12:26 <lambdabot> Done.
20:12:32 <sjanssen> @type 3
20:12:33 <lambdabot> forall t. (Num t) => t
20:12:38 <dons> now, that talk all of 30 minutes to write the library, write the test suite, add a build system and release it
20:12:44 <dons> so what are you all waiting for!
20:12:59 <dons> the lambda revolution isn't going to happen without YOUR CODE!
20:13:03 <dons> :D
20:13:10 * dons livelys up
20:13:20 <sjanssen> @remember dons the lambda revolution isn't going to happen without YOUR CODE!
20:13:22 <brad__> actually dons, its all on you
20:13:29 <dylan> "You better lively up your code / and don't be no drag..."
20:13:51 <wy> sjanssen: So what should I take care of if it is so?
20:14:30 <wy> sjanssen: I don't like declare types. But it seems this is normal practice in Haskell?
20:14:46 <sjanssen> wy: there is a certain rule, called the "monomorphism restriction".  It says that declarations that look a certain way must be monomorphic
20:14:57 <brad__> well thanks for all the answers and good cheer, take care!
20:15:33 <sjanssen> wy: yes, writing type signatures is the normal thing to do
20:16:10 <wy> sjanssen: But I think forgetting to write one should not cause a compiling error
20:16:30 <sjanssen> usually, when this restriction comes into play, the Haskell compiler bails out with a message like "add some type sigs, dufus"
20:17:22 <LoganCapaldo_> if you are using ghc you can say -fno-monomorphism-restriction
20:18:49 <sjanssen> but, there is a special system called "defaulting", such that whenever a type with a Num constraint hits the monomorphism restriction, Haskell gives it a default type instead of failing to compile
20:19:34 <sjanssen> wy: usually, failing to write a type signature is no problem, but the MR is sneaky
20:22:18 <wy> what's MR?
20:22:39 <wy> sjanssen: I found the problem!
20:22:42 <wy> type Heap a = (Int, [Int], [(Int, a)])
20:22:47 <sorear> monomorphism restriction
20:22:52 <wy> hInitial                             = (0,      [1..],  [])
20:23:00 <cptn> hey, there any library to allow ghc to give me more helpful error messages
20:23:01 <mathewm> What is the deepest Monad-Transformer chain you have ever seen used for real?
20:23:32 <wy> I didn't declare hInitial :: Heap a, so it defaults to (Integer, [Integer], [a])
20:23:42 <chessguy> hey dons, i like your blog about monads on planethaskell
20:24:23 <wy> That's why it fails to match
20:25:12 <int-e> wy: heh. that wouldn't have happened with   data Heap a = (Int, [Int], [(Int, a)])  (but I suppose the MR does something awful to the 'a' in that)
20:25:29 <int-e> wy: sorry. data Heap a = Heap Int [Int] [(Int, a)]
20:26:06 <sjanssen> wy: I think your solution won't have any trouble with the MR
20:28:13 <wy> sjanssen: I have. Because my other functions will return type Heap.  But Heap is (Int, [Int], [(Int,a)]) and not the Integer version. So hInitial can't match the result of this function.
20:28:39 <sjanssen> wy: oh, sorry.  Meant to address int-e
20:29:20 <sorear> I spoke too soon [an hour ago]: there is enough library support for generic deserialization.
20:29:22 <lisppaste2> sorear annotated #31972 with "with deserialization" at http://paste.lisp.org/display/31972#1
20:29:43 <wy> data Heap a = (Int, [Int], [(Int, a)]) is parse error
20:29:59 <sjanssen> look at int-e's second suggestion
20:30:00 <wy> int-e: I see.
20:30:43 <wy> sjanssen: Hmmm... But I'm basically copying the code from the book. Actually I don't like this kind of type definition.
20:31:07 <sjanssen> wy: using a data declaration is the right way to do it
20:31:27 <wy> sjanssen: Do you think labeled datatypes is better than this kind of type aliasing?
20:31:53 <sjanssen> especially if you're writing code you want others to use.  The representation should be hidden from the users of your library
20:32:46 <wy> sjanssen: Yes. But to change it I have to rewrite a lot of code. So maybe Peyton's book is not a good example.
20:33:21 <sjanssen> wy: it depends.  Writing something like a heap data structure, you probably want to use a data decl. rather than a type alias
20:33:37 <wy> He also wrote something like this: type TiState = (TiStack, TiDump, TiHeap, TiGlobals, TiStats)
20:33:55 <sjanssen> wy: the author is probably trying to keep things simple, for learning purposes
20:34:07 <wy> After that it will be hard to extract the elements of the tuple I guess.
20:35:40 <wy> OK. Whatever, it works now. Is there a good way to detect this kind of error. I was not able to find the location. If it's possible to know where this Integer is infered from, it would be better.
20:35:51 <mgsloan> could write accessors, but at that point its just better to do a proper data
20:37:29 <sjanssen> wy: http://www.haskell.org/ghc/dist/current/docs/users_guide/options-sanity.html especially -fwarn-type-defaults
20:37:32 <lambdabot> Title: 4.7. Warnings and sanity-checking, http://tinyurl.com/ubvvh
20:38:35 <wy> sjanssen: I guess this is not available to ghci?
20:39:32 <sorear> it should be
20:39:39 <sorear> :set -fwarn-type-defaults
20:39:43 <sjanssen> wy: works for me
20:40:10 <wy> sjanssen: I tried. You are right! Thanks a lot!
20:45:40 <wy> Thanks to all and good night!
20:46:04 <cptn> so is there any library to allow ghc to give me more helpful error messages
20:46:19 <augustss> haha :)
20:46:45 <Pseudonym> No, but there are ways to make the messages a bit better, depending on the error.
20:46:46 <Pseudonym> ?paste
20:46:47 <dibblego> cptn, there is Chameleon
20:46:47 <lambdabot> http://paste.lisp.org/new/haskell
20:46:52 <dibblego> ?where chameleon
20:46:53 <lambdabot> I know nothing about chameleon.
20:46:57 <Pseudonym> Care to paste the error message?
20:46:58 <sjanssen> cptn: perhaps your local library has some Haskell books? ;)
20:47:18 <augustss> cptn: all you need is to learn the language of the error messages
20:47:20 <cptn> mostly i have resorted to type synonyms
20:47:36 <Pseudonym> Type synonyms are usually a good idea.
20:47:55 <augustss> cptn: type synonyms are not the best for error messages, though
20:48:50 <Pseudonym> I think that reading Haskell error messages are an acquired skill, much like programming.
20:48:58 <dibblego> @let chameleon = "http://www.comp.nus.edu.sg/~sulzmann/chameleon/download/haskell.html"
20:48:59 <lambdabot> Defined.
20:49:08 <dibblego> > L.chameleon
20:49:10 <lambdabot>  "http://www.comp.nus.edu.sg/~sulzmann/chameleon/download/haskell.html"
20:49:14 <augustss> Pseudonym: as I said, it's a new language :)
20:49:29 <Pseudonym> But C++ STL error messages are even worse.
20:50:26 <twobitsprite> What's the name for the haskell type system again?
20:50:52 <Pseudonym> There's no specific name for it.
20:50:57 <cptn> augustss, so should i just get better with haskell and those type inferred messages will make more sense?
20:50:58 <dibblego> the haskell type system?
20:50:58 <Pseudonym> But it's a descendent of Hindley-Milner.
20:51:12 <augustss> Hindley-Milner with type classes
20:51:15 <twobitsprite> Pseudonym: that's what I was looking for, thanks
20:51:38 <augustss> cptn: after a while they start making sense :)
20:52:41 <sjanssen> cptn: do you write type signatures for your top level functions?  that can really help
20:52:52 * chessguy sighs.
20:53:08 <cptn> sjanssen, i should start
20:53:15 <chessguy> do all people who "get" monads have a lightning-flash moment, or do monads just grow on some people
20:53:35 <dibblego> chessguy, the first mistake is to think they are something
20:53:53 <dibblego> chessguy, have you looked at the type signature for bind?
20:53:59 <augustss> chessguy: i "got" them early on, but it took me 5 years to like them :)
20:54:03 <chessguy> they're basically an interface
20:54:19 <dibblego> chessguy, as an exercise with a 3-day old Haskeller, we rewrote the Maybe type, then instance Monad for it - that worked very well
20:54:42 <dibblego> yes bind is an interface (but not reproducible in Java or C# because of the type system)
20:54:47 <chessguy> i've been studying haskell for months, have tried tackling monads several times, and still don't quite get it
20:55:05 <geckosen1tor> I just found out about monads 10 minutes ago
20:55:21 <dibblego> chessguy, write the Maybe data type: data MyMaybe a = MyJust a | MyNothing -- now try to write bind for it
20:55:22 <augustss> chessguy: don't worry.  monads provide little in themselves to "get"
20:55:51 <dibblego> or first, write the unit function of type a -> Monad a
20:55:58 <dibblego> which is easy for
20:55:59 <dibblego> Maybe
20:56:09 <dibblego> s/unit/return
20:56:13 <augustss> chessguy: but as as a computational abstraction they are amazingly useful
20:56:22 <chessguy> isn't it like bind (Just a) f = f a, and bind (Nothing a) f = Nothing a
20:56:36 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11#release-a-library-today  :D
20:56:38 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/y7wvnq
20:56:38 <dibblego> almost
20:57:03 <nuncanada> Nothing a?
20:57:09 <chessguy> err
20:57:18 <chessguy> bind (Nothing _) = Nothing
20:57:32 <augustss> dons: don't you ever sleep?
20:57:39 <Heffalump> chessguy: you don't want those brackets
20:57:55 <chessguy> ok
20:58:08 <nuncanada> monads is just a way to keep state around... As haskell is a 'pure' functional language, it needs something like it to abstract IO
20:58:12 <dons> augustss: about 6 hours a day :)
20:58:27 <augustss> dons: you could have fooled me
20:58:28 <chessguy> so bind (Just a) f = f a, and bind Nothing _ = Nothing
20:58:36 <dibblego> monads are much more than that
20:58:51 <augustss> nuncanada: if monads were just good for state they would be much less amazing
20:58:52 <dibblego> chessguy, almost (syntax)
20:59:23 <nuncanada> going to read the math description... i am a newbie to haskell too
20:59:42 <augustss> nuncanada: the math description is rather unhelpful
20:59:55 <Olishna> hi 2 all
20:59:57 <mathewm> Don't read the category theory first
21:00:02 <mathewm> it makes it harder, IMO
21:00:07 <chessguy> what am i missing?
21:00:08 <mathewm> save that for a little later
21:00:28 <augustss> but thinking of monads as state containers is an all right first approximation
21:00:36 <mathewm> 'bind (Just a) f = f a' ?
21:01:10 <chessguy> ...
21:01:21 <dibblego> dons, does a difference list keep a delta as it appends?
21:02:27 <chessguy> Just (f a) ?
21:02:43 <dibblego> pass it to the compiler for type checking
21:02:59 <dons> dibblego: check the src. it uses (.) for composition (i.e. like showsPrec et al)
21:03:40 <dibblego> trying to find the source
21:04:20 <dons> ?where dlist
21:04:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
21:04:29 <dibblego> oh just got the email :)
21:04:52 <augustss> dons: we got a new all-time-high on users while you were napping :)
21:04:54 <mathewm> chessguy: what you had looks good to me...
21:05:01 <dons> cool :)
21:05:03 <dons> ?users #haskell
21:05:04 <lambdabot> Maximum users seen in #haskell: 288, currently: 257 (89.2%), active: 44 (17.1%)
21:05:07 <dons> ah, well and truly
21:05:27 <dons> huh, and on a Sunday night
21:05:28 <dons> how interesting
21:05:37 <augustss> nothing else to do
21:05:53 <int-e> still off by one .. strange.
21:06:16 <dons> sjanssen: guess where the joke is in here: http://www.cse.unsw.edu.au/~dons/code/dlist/Data/DList.hs
21:07:50 <augustss> snoc        = (. (:)) . (.)
21:07:58 <augustss> not exactly a joke
21:08:04 <dons> augustss wins a prize! :)
21:08:10 <Korollary> We gotta have an online monad quiz so that people who study them can confirm that they "get" them.
21:08:22 <chessguy> @paste
21:08:22 <lambdabot> http://paste.lisp.org/new/haskell
21:08:23 <dons> Korollary: some kind of cerifcation? :)
21:08:24 <mgsloan> good idea
21:08:37 <dons> ?unpl (. (:)) . (.)
21:08:38 <lambdabot> (\ g j d -> g (((:)) j d))
21:08:44 <int-e> @pl (. (:)) . (.)
21:08:45 <lambdabot> (. (:)) . (.)
21:08:46 <lisppaste2> chessguy pasted "monad quiz" at http://paste.lisp.org/display/31982
21:08:48 <mgsloan> I think i know what they basically are, but it's such an abstract thingamambob yah never know
21:08:52 <augustss> dons: it's good enough to scare newbies off ;)
21:08:54 <int-e> @pl \a b -> b : a
21:08:54 <lambdabot> flip (:)
21:08:56 <dons> hehe
21:08:59 <chessguy> so why doesn't this compile?
21:09:15 <mathewm> perhaps if you can work with this in your sleep: type NDS a = WriterT [String] (StateT NQueensProblem []) a
21:10:33 <int-e> chessguy: wrong type here:    (>>) x _ = x
21:11:35 <int-e> chessguy: and your >> is weird.
21:11:52 <mathewm> isn't that one in the same ;)
21:13:07 <mwolak> If I import ByteString as B an ByteString.Char8 as B2, is it safe to mix ByteString functions with ByteString.Char8 ones?
21:13:13 <chessguy> int-e, how so?
21:13:25 <dons> mwolak: yep
21:13:33 <dons> same data type underneath, just a different interface
21:13:35 <mwolak> dons: sweet, thanks
21:13:55 <int-e> chessguy: a >> b and a >>= (const b) will mean different things if you define      (>>) MyNothing y = y
21:14:54 <chessguy> so it should be MyNothing y = const y ?
21:15:10 <mathewm> you can always leave (>>) off, Monad has a default for it
21:15:19 <augustss> hey!  discovery is showing the cattle station in oz where i watched the eclipse :)
21:15:22 <mathewm> it is defined in terms of >>=
21:15:37 <chessguy> mathewm, Maybe also already exists, too..
21:15:45 <dibblego> augustss, Ceduna?
21:15:51 <int-e> chessguy: no, a >> b should be the same as a >>= (const b). it's probably just in the monad dictionary to allow optimizations in a few cases.
21:16:01 <dibblego> chessguy, write bind, then sequence will be simple
21:16:03 <augustss> dibblego: Dulcamina (sp?)
21:16:04 <mathewm> well, in the Prelude, I don't think Maybe's instance defined (>>)
21:16:30 <dibblego> augustss, dunno
21:16:34 <augustss> ceduna was to uncertain.  we opted for a second less with better weather conditions
21:16:36 <chessguy> int-e, i don't get it, how does my code need to change?
21:16:58 <mathewm> m >> k = m >>= \_ -> k
21:17:14 <dibblego> augustss, I'm 3000km away by road :)
21:17:19 <chessguy> dibblego, bind is written
21:17:32 <dibblego> chessguy, then sequence is easy - it is written in terms of bind
21:17:37 <augustss> dibblego: it felt like along ride ;)
21:17:40 <dibblego> chessguy, what mathewm said
21:17:45 <int-e> chessguy: best leave out the >> completely
21:18:14 <int-e> chessguy: if you want to define it anyway, define Nothing >> _ = Nothing; Just _ >> x = x
21:18:31 <mathewm> (>>) m k = m >>= (\_ -> k)
21:18:45 <int-e> chessguy: if you don't worry about semantics, the line (>>) x _ = x has to be changed to make it type check.
21:18:59 <dibblego> I still think it would be better to call it bind and unit, just for learning
21:19:23 <mathewm> unit?
21:19:28 <int-e> return.
21:19:28 <dibblego> so that you don't have the confusion of infix functions
21:19:42 <mathewm> 'then' and 'bind' would be my vote
21:19:42 <chessguy> ok, well if i leave it off, it compiles
21:19:45 <dibblego> er, I meant bind and sequence anyway
21:19:58 <int-e> chessguy: it would be more natural to write those definitions infix :)
21:20:04 <augustss> return is a cute name, but very confusing
21:20:09 <int-e> chessguy: and haskell allows it.
21:20:34 <mathewm> chessguy: It compiles if you swap your args
21:20:45 <int-e> the default implementation of >> is:    m >> k      = m >>= \_ -> k
21:20:51 <mathewm> but it doesn't seem quite right
21:20:58 <chessguy> mathewm, it compiles now
21:21:00 <chessguy> let me paste
21:21:30 <lisppaste2> chessguy annotated #31982 with "working" at http://paste.lisp.org/display/31982#1
21:21:45 <dibblego> working, compiling, same thing :) this is haskell y'know
21:21:57 <mathewm> I wish that was always the same
21:22:16 <chessguy> this doesn't seem to have been particularly instructive for me
21:22:17 <dibblego> sure, just shift your definition of working!
21:22:21 <mathewm> dibblego: often when it compiles and still doesn't work, haskell makes it harder to go the last mile :(
21:22:31 <dibblego> chessguy, why not?
21:22:37 <mathewm> chessguy: have your read any monad tutorial?
21:22:42 <lisppaste2> int-e annotated #31982 with "you could also write ..." at http://paste.lisp.org/display/31982#2
21:22:58 <dons> heya greentea
21:23:05 <dibblego> chessguy, have you ever wanted to call 2 or more functions that return Maybe and if any of them return Nothing, the function itself returns Nothing?
21:23:40 <chessguy> mathewm, several of them, several times each
21:23:46 <chessguy> dibblego, not that i can think of
21:23:52 <greentea> Hi dons, how's things?
21:23:58 <dibblego> chessguy, unfortunate, imagine it then
21:23:58 <mathewm> chessguy: me too, but I am picking up more and more each time
21:24:05 <dibblego> chessguy, it is unwieldly right?
21:24:25 <dibblego> chessguy, I suggest that as the next exercise (we did this too)
21:24:41 <dibblego> chessguy, use the bind operation explicitly to do it
21:24:49 <dibblego> then convert it to do notation and feel the bliss
21:24:51 <int-e> map (\x -> guard (x/=0) >> return (1/x)) [-2..2]
21:24:55 <int-e> > map (\x -> guard (x/=0) >> return (1/x)) [-2..2]
21:24:56 <lambdabot>  add an instance declaration for (Show (m a))
21:25:13 <chessguy> hmm, can you give an example?
21:25:26 <dibblego> I think int-e is trying :)
21:25:30 <int-e> > map (\x -> guard (x/=0) >> return (1/x)) [-2..2] :: [Maybe Double]
21:25:31 <lambdabot>  [Just (-0.5),Just (-1.0),Nothing,Just 1.0,Just 0.5]
21:26:02 <int-e> explanation: in the Maybe monad, guard True returns Just (); guard False returns Nothing
21:26:24 <mathewm> perhaps you should implement the list monad next
21:26:40 <int-e> return x is Just x. >> takes the second argument unless the first is Nothing ...
21:27:01 <sorear> > liftM2 (+) (Just 3) (Just 5)
21:27:02 <lambdabot>  Just 8
21:27:04 <sorear> > liftM2 (+) (Just 3) Nothign
21:27:05 <lambdabot>  Not in scope: data constructor `Nothign'
21:27:05 <sorear> > liftM2 (+) (Just 3) Nothing
21:27:07 <lambdabot>  Nothing
21:27:40 <int-e> in that small example this seems artificial but it's really rather powerful.
21:27:42 <chessguy> i need an example of "calling 2 or more functions that return Maybe and if any of them return Nothing, the function itself returns Nothing"
21:28:04 <int-e> > do x <- [-2..2]; guard (x /= 0); return x
21:28:05 <lambdabot>  [-2,-1,1,2]
21:28:35 <int-e> > map (\x -> guard (x/=0) >> return (1/x)) [-2..2] :: [[Double]]
21:28:37 <lambdabot>  [[-0.5],[-1.0],[],[1.0],[0.5]]
21:28:39 <int-e> fun :)
21:28:40 <mgsloan> :t guard
21:28:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:28:46 <dibblego> chessguy, they are all around you - ever used the throws keyword in Java?
21:28:59 <chessguy> dibblego, sure
21:29:32 <dibblego> f() throws IOException { open(); read(); close();} // if any of open, read or close throw an IOException, the entire function throws an IOException
21:29:57 <dibblego> where an exception means Nothing
21:30:04 <chessguy> so how would that look in haskell?
21:30:35 <dibblego> well, f() is not complete
21:30:40 <dibblego> call it Y f(X) instead
21:30:49 <dibblego> in Haskell, X -> Maybe Y
21:31:06 <chessguy> ok
21:31:18 <dibblego> f :: X -> Maybe Y -- I should say
21:31:23 <LoganCapaldo_> f = do { x <- open; read x; close x } where open is Maybe File or something
21:31:54 <dibblego> @redo f = do { x <- open; read x; close x }
21:31:55 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
21:32:06 <LoganCapaldo_> I think you mean @undo
21:32:07 <dibblego> @redo do { x <- open; read x; close x }
21:32:08 <lambdabot> do { x <- open; read x; close x}
21:32:08 <mathewm> of course, you cannot actually do file IO from within Maybe
21:32:09 <mathewm> :)
21:32:13 <dibblego> maybe I do
21:32:16 <dibblego> @undo do { x <- open; read x; close x }
21:32:17 <lambdabot> open >>= \ x -> read x >> close x
21:32:47 <dibblego> chessguy, see the bind function being called? it's nothing more than that
21:32:56 <chessguy> interesting
21:32:59 <int-e> > do (_:_) <- return ""; return "" :: Either String String
21:33:01 <lambdabot>  Left "Pattern match failure in do expression at <irc>:1:3-7"
21:33:16 <chessguy> i need a good concrete example i can work through myself and completely beat the snot out of
21:33:36 <dibblego> just write two functions, one of type Int -> Maybe String and one of type String -> Maybe Int
21:35:16 <dibblego> or MyMaybe for your case
21:36:12 <chessguy> ok, done
21:37:14 <dons> hehe, audreyt , http://www.cafepress.com/pugscode.28684662
21:37:18 <dibblego> now write a function of type Int -> Int that will just call your first function nass pass the result to the second function
21:37:26 <dibblego> s/nass/and
21:37:28 <dons> "Powered by Ph.D" Sticker, $3.99
21:37:36 <nuncanada> http://www.nomaware.com/monads/html/index.html
21:37:38 <lambdabot> Title: All About Monads
21:37:39 <nuncanada> is quite good
21:37:59 <chessguy> hmm. so Int -> Maybe Int
21:38:05 <dibblego> no, Int -> Int
21:38:13 <chessguy> oh, right
21:38:23 <sorear> dons: the mkcabal repository is missing an email-address
21:38:25 <dons> omg, http://www.cafepress.com/pugscode.28778050
21:38:29 <dons> sorear: ah thanks
21:38:32 <dibblego> call only bind
21:38:33 <dons> sorear++
21:38:50 <chessguy> mmm
21:39:01 <dons> sorear: fixed
21:39:12 <nuncanada> good nite fellows
21:40:25 <dons> thanks sorear
21:43:32 <chessguy> dang
21:43:35 <chessguy> i thought i was getting it
21:44:21 <lisppaste2> chessguy annotated #31982 with "doesn't quite work yet" at http://paste.lisp.org/display/31982#3
21:44:30 <dibblego> you probably are
21:46:26 <chessguy> i get     Couldn't match `Int' against `MyMaybe Int'
21:46:36 <chessguy> but it doesn't really say where in the expression
21:47:01 <sjanssen> chessguy: your definition of >> is incorrect
21:47:32 <chessguy> huh?
21:47:36 <chessguy> i'm not even defining >>
21:47:37 <sjanssen> oh, sorry, not looking at the correct paste
21:48:19 <sjanssen> chessguy: foo :: Int -> MyMaybe Int
21:49:27 <chessguy> hmm, dibblego said he wanted a function of type Int -> Int
21:51:06 <chessguy> dibblego, still here?
21:51:08 <dibblego> gah sorry
21:51:24 <chessguy> it works if i make it Int -> Maybe Int
21:51:30 <dibblego> yes you want the whole function to return Nothing if either of the othrs return Nothing
21:51:38 <chessguy> ok
21:51:38 <dibblego> yes, I deeply apologise
21:51:42 <chessguy> then my code works
21:51:50 <dibblego> ok cool, sorry
21:52:09 <dibblego> have you written it again but with do notation?
21:52:38 <chessguy> no, let me do that quick
21:57:04 <lisppaste2> chessguy annotated #31982 with "Working..." at http://paste.lisp.org/display/31982#4
21:58:21 <chessguy> this is kinda cool. what's the next step?
21:59:04 <dibblego> so foo 3 will return 3 and foo _ will return Nothing
21:59:09 <chessguy> right
21:59:14 <dibblego> that's it
21:59:29 <dibblego> notice you didn't have to get the a out of Just a each time
21:59:45 <dibblego> instead, you took advantage of the instance Monad and used do notation and just sequenced it along
22:00:07 <dibblego> that's all there is to it
22:00:08 <chessguy> hmm. i didn't have to "get it out", because i was "in" the MyMaybe monad?
22:00:15 <dibblego> you might consider the list monad as well - it is almost as simple
22:00:34 <dibblego> yes, the do notation expanded to use >>=
22:01:01 <chessguy> so, if i were going to write the list monad from scratch
22:01:18 <dibblego> newtype MyList a = MyList [a]
22:01:20 <sjanssen> @undo do { x <- isThree y; is3 x; }
22:01:20 <chessguy> i'd need to define the three main functions for it
22:01:20 <lambdabot> isThree y >>= \ x -> is3 x
22:01:28 <dibblego> instance Monad (MyList a)
22:01:42 <dibblego> those functions are only to demonstrate the purpose of the MyMaybe monad
22:01:51 <dibblego> the foo function implementation specifically
22:02:02 <dibblego> they are clients of the monad
22:03:05 <chessguy> why do i need instance Monad (MyList a)
22:03:09 <chessguy> before, i just did instance Monad MyMaybe where
22:03:26 <dibblego> to move on from the Maybe monad to the list monad
22:03:38 <dibblego> to repeat the exercise for a different monad
22:03:43 <dibblego> until you internalise it
22:04:11 <chessguy> but i'm saying, why does my instance declaration for List need to be parameterized
22:04:16 <chessguy> when it wasn't for MyMaybe
22:04:25 <dibblego> oh, maybe I got it wrong
22:04:29 <dibblego> I do that sometimes
22:04:30 <sjanssen> chessguy: dibblego made a mistake, you should skip the 'a' part
22:04:37 <chessguy> ok
22:06:46 <Cale> The monad in each case is Maybe or List, the type constructor, and not Maybe a, which is a particular type
22:07:38 <Pseudonym> It's like you want to talk about stacks or queues independent of the values that they store.
22:07:48 <Pseudonym> Similarly, you want to talk about monads independent of the values that they return.
22:08:20 <chessguy> ok, i don't have a clue how to write the list monad
22:08:28 <Pseudonym> []
22:08:34 <Pseudonym> ?kind []
22:08:36 <lambdabot> * -> *
22:09:08 <aFlag> what's kind?
22:09:14 <Pseudonym> kind is the type of a type.
22:09:16 <chessguy> return = (:)  ?
22:09:26 <Pseudonym> Take (Int,Float), for example.
22:09:41 <Pseudonym> You can think of the pair type as something that needs two "arguments" to make a 100% type.
22:09:50 <Pseudonym> "Pair" on its own doesn't make sense.
22:09:55 <Pseudonym> ?kind (,)
22:09:57 <lambdabot> * -> * -> *
22:10:02 <Pseudonym> * is the kind of a type.
22:10:08 <Pseudonym> So (,) takes two types and returns a type.
22:10:13 <Pseudonym> ?kind IO
22:10:15 <lambdabot> * -> *
22:10:15 <mgsloan> :k (Int,)
22:10:17 <lambdabot> parse error on input `)'
22:10:23 <Pseudonym> :k (,) Int
22:10:24 <mgsloan> heh, toobad
22:10:25 <lambdabot> * -> *
22:10:30 <aFlag> hum
22:10:31 <Pseudonym> Currying!
22:10:31 <aFlag> I see
22:10:53 <chessguy> guess i bored dibblego
22:10:59 <mgsloan> ah, i guess you can't do kind constructor operator sections
22:11:14 <Pseudonym> Right.
22:11:20 <Pseudonym> Though it would be cool if you could.
22:11:26 <Pseudonym> ?kind (->)
22:11:27 <lambdabot> ?? -> ? -> *
22:11:33 <mgsloan> noidea why not
22:11:39 <Pseudonym> Those things are special kinds.  Ignore them.
22:11:44 <Pseudonym> Just think of them as *.
22:11:46 <mgsloan> breaks the... uh... continuity?
22:11:59 <Pseudonym> mgsloan: Because it would require special syntax which you rarely use.
22:12:21 <mgsloan> not really, if you made them just like normal operators
22:12:45 <LoganCapaldo_> ?kind Maybe
22:12:47 <lambdabot> * -> *
22:12:58 <dibblego> chessguy, sequencing a list just concats
22:13:00 <LoganCapaldo_> ?kind [a]
22:13:02 <lambdabot> Not in scope: type variable `a'
22:13:06 <Pseudonym> Yeah, but they're not just like normal operators.
22:13:21 <sorear> ?kind []
22:13:22 <lambdabot> * -> *
22:13:33 <chessguy> but i'm not on sequencing yet
22:13:34 <mgsloan> :k (,)
22:13:35 <lambdabot> * -> * -> *
22:13:37 <LoganCapaldo_> That's an empty list! ;)
22:13:40 <mgsloan> looks like an operator to me :)
22:13:42 <dibblego> chessguy, I mean for bind
22:13:47 <sorear> :k (,,,,,,,)
22:13:49 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> *
22:13:55 <mgsloan> (emph on looks, i realize the semantic issue)
22:13:56 <chessguy> i'm still figuring out return
22:13:56 <dibblego> chessguy, fail is an empty list
22:14:06 <mgsloan> ah, perhaps that's why there's no sections
22:14:07 <chessguy> so return = (:) ?
22:14:16 <dibblego> return x = [x]
22:14:21 <dibblego> er
22:14:26 <dibblego> return x = MyList [x]
22:14:36 <sorear> :k Control.Monad.State.StateT
22:14:38 <lambdabot> * -> (* -> *) -> * -> *
22:14:54 <mgsloan> ooh
22:15:20 <chessguy> hmm
22:15:21 <chessguy> ok
22:15:35 <int-e> :k (->)
22:15:37 <lambdabot> ?? -> ? -> *
22:15:47 <sorear> :k (->) True
22:15:49 <lambdabot> Not in scope: type constructor or class `True'
22:15:54 <sorear> :k (->) Bool
22:15:55 <lambdabot> ? -> *
22:15:59 <sorear> :k (->) Int#
22:16:01 <lambdabot> Not in scope: type constructor or class `Int#'
22:16:09 <sorear> :k (->) GHC.Prim.Int#
22:16:10 <lambdabot> ? -> *
22:16:55 <mgsloan> :k (->->) GHC.Prim Int#
22:16:57 <lambdabot> Couldn't find qualified module.
22:17:19 <mgsloan> :k (->->) GHC.Prim.Int#
22:17:20 <lambdabot> Not in scope: type variable `->->'
22:17:35 <sorear> :k (->) (# GHC.Prim.Int# , GHC.Prim.Int# #)
22:17:36 <lambdabot>   Kind mis-match
22:17:36 <lambdabot>   Expected kind `??', but `(# GHC.Prim.Int#, GHC.Prim.Int# #)' has kind `(#)'
22:17:38 <mgsloan> :k (-> ->) GHC.Prim.Int#
22:17:40 <lambdabot> parse error on input `->'
22:17:51 <Pseudonym> :k Control.Monad.RWS.RWST
22:17:53 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
22:17:53 <int-e> :k (->) Bool (# GHC.Prim.Int#, GHC.Prim.Int# #)
22:17:55 <lambdabot> *
22:17:59 <mgsloan> :k (->) ((->) GHC.Prim.Int#)
22:18:01 <lambdabot>   `(->) GHC.Prim.Int#' is not applied to enough type arguments
22:18:01 <lambdabot>   Expected kind `??', but `(->) GHC.Prim.Int#' has kind `? -> *'
22:18:04 <chessguy> oy. i'm too tired to do this tonight, and the channel's filling with too much crap
22:18:10 <chessguy> i'll pick it up another time
22:18:15 <mgsloan> heh, sorry
22:18:18 <chessguy> thanks for the help dibblego
22:18:18 <Pseudonym> OK, people, take it to /msg.
22:18:28 <dibblego> chessguy, no problem, hope it helped
22:18:54 <int-e> mgsloan: ?? does not include unboxed tuples, ? does.
22:19:07 <chessguy> yeah, i think it's just going to be a slow process for me instead of a blinding flash of light like it is for some
22:19:24 <mgsloan> ah
22:20:18 <mgsloan> I figured from the (,,,) thing that i could write (->->), but i guess not
22:20:38 <chessguy> 'night all
22:20:39 <mathewm> gnight all
22:21:22 * mgsloan doesn't like inconsistent syntax patterns
22:31:19 <allbery_b> hm?  it's consistent, (,...) is the tuple constructor
22:42:34 <mq_mattr> quiet
22:43:03 <dons> ?yow!
22:43:04 <lambdabot> I want to dress you up as TALLULAH BANKHEAD and cover you with VASELINE
22:43:04 <lambdabot> and WHEAT THINS ...
22:43:33 * glguy__ just read the chapter in The Seasoned Schemer about defining cons, car, and cdr with lambda
22:44:07 <jcreigh> hmm...
22:45:49 <jcreigh> (define (cons thecar thecdr) (lambda (what) (cond ((eq? what 'car) thecar) ((eq? what 'cdr) thecdr))))
22:45:56 <jcreigh> (untested) Something like that?
22:46:22 <glguy_> (define (cons a d) (lambda (selector) (selector a d)))
22:46:47 <glguy_> (define (car c) (c (lambda (a d) a)))
22:46:48 <jcreigh> oh, much better than mine.
22:48:52 <dons> sjanssen: does the exported stuff work for Control.Concurrent.MVar?
22:49:02 <dons> (if so, what's the difference in the two modules?)
22:49:07 <mq_mattr> ?yow!
22:49:08 <lambdabot> Could I have a drug overdose?
22:49:16 <mq_mattr> sure
22:50:25 <glguy_> > let cons a d f = f a d; car c = c const; cdr c = c (flip const) in car (cons 1 2)
22:50:26 <lambdabot>  1
22:51:35 <glguy_> > let cons a d f = f a d; nul f = f undefined undefined car c = c const; cdr c = c (flip const) in car (cons 1 (cons 2 nul))
22:51:36 <lambdabot>  Parse error
22:51:48 <glguy_> > let cons a d f = f a d; nul f = f undefined undefined; car c = c const; cdr c = c (flip const) in car (cons 1 (cons 2 nul))
22:51:50 <lambdabot>  1
22:52:09 <glguy_> > let cons a d f = f a d; nul f = f undefined undefined; car c = c const; cdr c = c (flip const) in car $ cdr (cons 1 (cons 2 nul))
22:52:11 <lambdabot>  2
22:52:25 <glguy_> > let cons a d f = f a d; nul f = f undefined undefined; car c = c const; cdr c = c (flip const) in car $ cdr $ cdr (cons 1 (cons 2 nul))
22:52:26 <lambdabot>  Add a type signature
22:52:36 <sjanssen> dons: apparently it does work in MVar, not sure what the difference is
22:53:00 <glguy_> ?type let cons a d f = f a d; nul f = f undefined undefined; car c = c const; cdr c = c (flip const) in cons 1 (cons 2 nul)
22:53:02 <lambdabot> forall t t1 t2 a a1 t3 t4. (Num t, Num t1) => (t -> ((t1 -> ((a -> a1 -> t3) -> t3) -> t2) -> t2) -> t4) -> t4
22:53:05 <sjanssen> dons: the STM stuff is in a separate package, perhaps that is the problem?
22:53:10 <dons> hmm. could be
22:55:06 <glguy_> > let cons a d f = f a d; nul f = f undefined undefined; car = ($ const); cdr = ($ flip const) in car $ cdr (cons 1 (cons 2 nul))
22:55:07 <lambdabot>  2
22:55:18 <glguy_> ?pl \f -> f undefined undefined
22:55:18 <lambdabot> flip ($ undefined) undefined
22:55:30 <glguy_> ?pl \f -> f a d
22:55:31 <lambdabot> flip ($ a) d
22:58:04 * allbery_b is confused by the dangling f-s
22:58:53 <glguy_> > let cons = flip . flip id; nul = flip ($ undefined) undefined; car = ($ const); cdr = ($ flip const) in car $ cdr (cons 1 (cons 2 nul)) -- linked lists defined without any actual variables
22:58:54 <lambdabot>  2
22:59:54 <glguy_> Does anyone else find that to be particularly cool? or am I the only one who hasn't considered this?
23:00:25 <dons> its cute :)
23:00:30 <bd_> :t flip . flip id
23:00:31 <lambdabot> forall b c a. a -> b -> (a -> b -> c) -> c
23:02:06 <glguy_> if you want to be able to dectect the end of list:
23:02:13 <bd_> ?unpl flip ($ undefined)
23:02:14 <lambdabot> (\ b c -> c undefined b)
23:02:19 <glguy_> cons a d f = f a d False
23:02:33 <glguy_> car c = c (\a _ _ -> a)
23:02:34 <jcreigh> hmm...you can't foldr cons nil [1,2,3] (is that because each "list" using this method will have a different type?)
23:02:51 <glguy_> cdr c = c (\_ d _ -> d)
23:03:03 <glguy_> null? c = c (\ _ _ b -> b)
23:03:29 <bd_> hmm, I'm not quite understanding nul there, but then again it is 1:55 am... I thought the type of elements was of the form (a -> b -> c) -> c ...?
23:03:48 <glguy_> nul has an undefined head
23:03:52 <glguy_> and an undefined tail
23:04:12 <bd_> but
23:04:12 <bd_> 01:54 < bd_> ?unpl flip ($ undefined)
23:04:12 <bd_> 01:54 < lambdabot> (\ b c -> c undefined b)
23:04:20 <bd_> it's a function of two variables?
23:04:39 <glguy_> but : nul = flip ($ undefined ) undefined
23:04:48 <bd_> oh
23:04:50 <bd_> oh!
23:04:52 <glguy_> ?unpl flip ($ undefined) undefined
23:04:53 <lambdabot> (\ c -> c undefined undefined)
23:04:53 <bd_> missed the other undefined XD
23:05:00 <sjanssen> dons: yeah, looks like docs aren't exported across packages.  I don't see an easy fix (to Haddock) either, because each package is processed separately
23:05:03 <bd_> okay, that makes sense now :)
23:05:04 <bd_> neat
23:05:20 <glguy_> yeah, this implementation of cons doesn't work well in haskell's type system
23:05:26 <sjanssen> maybe the implementations for STM could have big #ifdef __HADDOCK___ sections
23:05:32 <bd_> glguy_: recursive type restriction?
23:05:35 <dons> sjanssen: hmm. the docs should be copied across then.
23:05:56 <glguy_> bd_: it's like defining linked lists in terms of tuples
23:06:05 <dons> sjanssen: I wonder if this affects other libraries
23:06:08 <glguy_> the type is dependent on the length
23:06:16 <bd_> yeah, so you'll need recursive types to get an arbitrary-length thing
23:06:21 <glguy_> yeah
23:06:40 <glguy_> either way, it's neat to see lists defined in terms of lambda (to me)
23:07:18 <dons> glguy_: you should get a copy of Barendreght's weighty tome on the lambda calculus
23:07:36 <glguy_> i might have to
23:07:57 <dons> its the real world programmer's bible
23:08:03 <jcreigh> ...or you could just say data List a = Nil | Cons a (List a) :P
23:08:24 <bd_> jcreigh: Where's the challenge?
23:08:31 <jcreigh> dons: hmm, how so? or is that sarcasm?
23:08:33 <Excedrin> why not data List a = Nil a | Cons a (List a) ?
23:08:52 <Excedrin> for non-empty lists
23:08:57 <bd_> Excedrin: You can't construct a truly empty list in that case
23:09:03 <dons> jcreigh: sorry -- small joke :)
23:09:05 <Excedrin> exactly
23:09:40 <bd_> Excedrin: It also creates two different constructors which hold data pointers, which seems a bit odd to me >.> but it'd work I guess if you wanted to enforce non-empty lists
23:09:45 <bd_> ofc one could always do Nil undefind
23:09:47 <bd_> undefined*
23:10:14 <dons> jcreigh: http://www.amazon.com/Lambda-Calculus-Semantics-Foundations-Mathematics/dp/0444867481/sr=8-1/qid=1165820512/ref=sr_1_1/102-1166968-6052933?ie=UTF8&s=books
23:10:18 <lambdabot> http://tinyurl.com/yyynak
23:10:30 <dons> hehe,  Customers who bought this item also bought
23:10:30 <dons>     *
23:10:30 <dons>     * Basic Category Theory for Computer Scientists (Foundations of Computing) by Benjamin C. Pierce Types and Programming Languages by Benjamin C. Pierce
23:11:12 <jcreigh> "Amazon.com Sales Rank: #2,693,266 in Books"
23:11:39 <bd_> jcreigh: The edition that's actually on sale has rank #562,931 :)
23:11:43 <bd_> http://www.amazon.com/Lambda-Calculus-Studies-Foundations-Mathematics/dp/0444875085/ref=ed_oe_p/104-3556609-6875103
23:11:46 <lambdabot> http://tinyurl.com/tdh6n
23:11:50 <dons> It's a classic though (but its not been onsale for years, afaik)
23:12:05 <dons> mmm "This is a great book. A must buy for all graduate students in computer science."
23:12:09 <dons> hehe
23:12:19 <bd_> dons: on sale in the tdh6n link :)
23:12:30 <dons> oh man "I accidently bought this book thinking I was buying a traditional calculus book in order to prepare for a standardized test I had to take. After a few chapters I realized this was no ordinary Calculus book"
23:12:34 <bd_> XD
23:12:36 <mbishop> amazon reviews are hilarious
23:12:40 <mbishop> check the rviews for SICP
23:12:49 <dons> and that's how Bulat became a Haskell hacker
23:13:38 * jcreigh needs to finish reading SICP.
23:13:56 <dons> "I accidentally downloaded GHC thinking I was getting the traditional GCC, in order to segfault some programs on my computer. After a few programs I realized this was no ordinary compiler"
23:14:25 <mbishop> haah
23:14:41 <mbishop> "in order to segfault some programs on my computer." I laughed :\
23:15:17 <dons> :D
23:15:17 <LoganCapaldo_> that's impressive accidently buying the wrong textbook
23:15:32 <dons> I wonder how the standardised test went.
23:16:12 <LoganCapaldo_> oh rather buying a textbook on the wrong subject accidently
23:16:42 <LoganCapaldo_> wasn't even the wrong calc book
23:16:58 <LoganCapaldo_> it was the (wrong calc) book
23:21:29 <shankys> I have a question about how Data.Map.lookup works. If I do Data.Map.lookup "foo" (Data.Map.singleton "bar" "baz"), how do I check to see that this fails in code before getting a runtime error?
23:22:22 <bd_> :t Data.Map.lookup "foo" (Data.Map.singleton "bar" "baz")
23:22:23 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
23:22:30 <bd_> You can run it as a maybe monad
23:22:40 <bd_> > (Data.Map.lookup "foo" (Data.Map.singleton "bar" "baz")) :: Maybe String
23:22:41 <lambdabot>  Not in scope: `Data.Map.singleton'
23:22:45 <bd_> heh
23:22:56 <bd_> or if your monad has appropriate 'fail' semantics that works as well
23:23:08 <bd_> Prelude> (Data.Map.lookup "foo" (Data.Map.singleton "bar" "baz")) :: Maybe String
23:23:11 <bd_> Nothing
23:23:36 <bd_> so with that you can just pattern match (in which case the type declaration isn't needed)
23:23:42 <kosmikus> > (M.lookup "foo" (M.singleton "bar" "baz")) :: Maybe String
23:23:43 <lambdabot>  Nothing
23:24:16 <bd_> oh
23:24:23 <LoganCapaldo> > (M.lookup "bar" (M.singleton "bar" "baz")) :: Maybe String
23:24:24 <lambdabot>  Just "baz"
23:24:29 <bd_> > (M.lookup "foo" (M.singleton "bar" "baz"))
23:24:30 <lambdabot>  add an instance declaration for (Show (m [Char]))
23:24:41 <bd_> > (M.lookup "foo" (M.singleton "bar" "baz")) :: List String
23:24:42 <lambdabot>  Not in scope: type constructor or class `List'
23:24:45 <bd_> bah
23:24:52 <LoganCapaldo> Just to point out what happens when it is there
23:25:02 <LoganCapaldo> > (M.lookup "foo" (M.singleton "bar" "baz")) :: [String]
23:25:02 <dons> > (M.lookup "foo" (M.singleton "bar" "baz") :: [String]
23:25:04 <lambdabot>  []
23:25:04 <lambdabot>  Parse error
23:25:16 <dons> > (M.lookup "foo" (M.singleton "bar" "baz") :: IO String
23:25:16 <lambdabot>  Parse error
23:25:17 <LoganCapaldo> wooo
23:25:27 <kosmikus> dons: why not allow "Data.Map" *and* "M" ?
23:25:32 <LoganCapaldo> I can match parens better than dons ;)
23:25:41 <dons> kosmikus: ah good idea!
23:26:57 <shankys> ?paste
23:26:58 <lambdabot> http://paste.lisp.org/new/haskell
23:27:28 <lisppaste2> shankys pasted "Monad Type Error" at http://paste.lisp.org/display/31993
23:27:41 <shankys> I tried the Maybe String idea
23:27:52 <shankys> but now I'm getting some monad typing errors
23:28:12 <LoganCapaldo> shankys: You don't check for Nothing
23:28:21 <LoganCapaldo> it will make the whole thing Nothing
23:28:27 <LoganCapaldo> if its Nothing
23:28:38 <bd_> shankys: use let, not <-, since you're not using your outer monad anyway
23:28:41 <bd_> anymore*
23:28:43 <LoganCapaldo> notice_title will be a String
23:28:50 <LoganCapaldo> not a Maybe String
23:28:57 <LoganCapaldo> it's the whole point of using <-
23:29:19 <shankys> I thought I couldn't use let because of Data.Map.lookup's type
23:29:30 <shankys> I'll give it a shot
23:29:56 <shankys> If I have notice_title be just a String, how will I be able to tell if lookup fails?
23:30:02 <lisppaste2> bd_ annotated #31993 with "matching using case for Maybe" at http://paste.lisp.org/display/31993#1
23:30:19 <bd_> shankys: see annotation :)
23:30:28 <bd_> Maybe's just a datatype here
23:30:32 <shankys> Ooooohhhh...
23:30:40 <shankys> Wow, I get it. Thanks!
23:30:43 <bd_> :)
23:30:46 <bd_> and now, I go to sleep
23:42:49 <niarium> Hi everyone
23:43:55 <Cale> hello
23:47:19 <arcatan> hullo
23:48:15 <Cale> Hi fnord123, any luck getting things to work?
23:48:51 <fnord123> no ive been afk the rest of the weekend. my computer just came up from 'sleep' mode
23:54:26 <fnord123> thanks though. time for work
23:57:31 <ivanm> Heffalump: I found an IRC chat log saying that you did some research on critical sets of Latin Squares at one point.  I was just wondering what exactly you did with them?
23:57:42 <dons> sjanssen++ that's what I'm talking about :)
23:59:56 <dons> agile out the ears
