00:00:06 <uccus> but that in general tells me that the function was imported from some other module
00:00:14 <metaperl> > [(*2),(+3)] `ap` [0,1,2]
00:00:15 <lambdabot>  [0,2,4,3,4,5]
00:00:22 <metaperl> could someone explain that? :)
00:00:23 <uccus> cannot this traversal be automated?
00:00:52 <allbery_b> probably could, but someone has to sit down and write it
00:01:08 <allbery_b> (feel free :)
00:01:08 <metaperl> > (*2) $ 2
00:01:10 <lambdabot>  4
00:01:16 <allbery_b> you don't need the $ there
00:01:21 <uccus> metaperl: it says, concat the lists made by map (*2) and map (+3) applied to [0,1,2]
00:01:34 <metaperl> uccus - but how does ap do that?
00:01:36 <metaperl> @type ap
00:01:37 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
00:01:51 <metaperl> so it takes a container of functions as the first arg
00:01:57 <uccus> m is []
00:01:59 <uccus> right?
00:02:00 <metaperl> and a container of data as the second arg
00:02:03 <metaperl> uccus - yes
00:02:11 <allbery_b> metaperl: because it's using the list monad, and >>= is defined as concatMap in the list monad
00:02:19 <uccus> so [(*2), (+3)] is [a -> b]
00:02:39 <metaperl> oh I have to go back to the def of liftM2 againt
00:02:47 <metaperl> I need that pasted to my forehead
00:02:49 <uccus> ap [list of functions] [list] should do exactly what it does
00:03:04 <uccus> is applies the list of functions to the list
00:04:31 <uccus> IMHO ap is easier to understand than liftM2
00:05:23 <uccus> and how do I find the instance declarations?
00:05:44 <uccus> I want to see how instance Monad [] was implemented
00:05:49 <uccus> how do I do that?
00:09:55 <mgsloan> looks like he got frustrated with trying to find the source :)
01:04:13 <roconnor> @when hackathon
01:04:13 <lambdabot> Maybe you meant: seen what where wn
01:15:44 <tibbe> hmm, I'm just reading the Data Paralell Haskell paper, I somewhat dislike all the namespacing going on (in general) in function names, all the M, S, P suffixes and various prefixes
01:18:29 <Templar> script
01:18:30 <Templar> paste
01:18:38 <Templar> link any1?
01:24:01 <Templar> paste link anyone?
01:25:03 <tibbe> Templar, link for what? :)
01:26:23 <Templar> that page where I can paste my code for help =)
01:27:30 <Templar> or has the bot quit? ^^
01:28:50 <tibbe> paste
01:28:53 <tibbe> @paste
01:28:54 <lambdabot> http://paste.lisp.org/new/haskell
01:28:59 <Templar> thanks
01:29:01 <tibbe> Templar, there
01:29:08 <Templar> :)
01:29:48 <dufflebunk> Yay! Fruit cake!
01:30:12 <dufflebunk> and the wrong channel apparently
01:31:03 <tibbe> dufflebunk, I'm sure me and the other hasklers wouldn't mind some fruit cake
01:31:16 <lisppaste2> Templar pasted "Patern Matching" at http://paste.lisp.org/display/33375
01:31:31 <dufflebunk> I'm sorry, destructive updates to the fruit cake aren't allowed in functional channels
01:32:50 <tibbe> Templar, what's the problem? :)
01:32:58 <Templar> I´m getting paten matching failure
01:33:03 <Templar> when I type:
01:33:12 <Templar> barcodes codeIndex
01:33:27 <tibbe> oki
01:33:38 <Templar> I whant to just write the "barCode" and get out the rest in the end
01:33:54 <tibbe> when you have [(a,b,c)] it means that you are trying to match a list with a single element
01:34:33 <Templar> aha, ok
01:34:38 <tibbe> try: barcodes xs = map (\(_,b,c) -> (b,c)) xs
01:34:44 <Templar> ok
01:35:24 <tibbe> > map (\(_,b,c) -> (b,c)) xs $ [(1,2,3), (4,5,6)]
01:35:25 <lambdabot>  Not in scope: `xs'
01:35:41 <tibbe> > let barcodes xs = map (\(_,b,c) -> (b,c)) xs in barcodes [(1,2,3), (4,5,6)]
01:35:42 <lambdabot>  [(2,3),(5,6)]
01:36:05 <tibbe> so [x] matches a singleton (one element) list :)
01:38:40 <Templar> thanks a lot =)
01:39:55 <tibbe> you're welcome
01:51:13 <Templar> but what dose "\" mean?
01:52:03 <Templar> seems like it makes "->" possibel somehow? or?
01:53:37 <tibbe> Templar, oh I'm sorry \x -> x + 1 would for example mean an anonymous function that takes one argument, x, and returns x + 1
01:53:53 <tibbe> so \... -> ... is a function
01:54:06 <tibbe> map takes that function and applies it to all elements in your list
01:54:40 <tibbe> > let myFunction = \x -> x + 1 in myFunction 2
01:54:42 <lambdabot>  3
01:55:23 <tibbe> for example: defining a new function: add x y = x + y would be equivalent of writing: add = \x y -> x + y
01:56:37 <Templar> aha, thanks, Think I understand then
02:05:37 <tibbe> the _ in (_,b,c) simply means that we don't care about the first argument and thus we don't give it a name, I could have written (a,b,c) instead
02:20:49 <Templar> yea, wildcard =)
02:23:00 <lisppaste2> Templar pasted "Find Database" at http://paste.lisp.org/display/33376
02:38:33 <Lemmih> > lookup 0xbeef [(0xbabe, ("Fish fingers", 121)), (0xbeef, ("a",12))]
02:38:35 <lambdabot>  Just ("a",12)
02:38:59 <Lemmih> > lookup 0xbabe [(0xbabe, ("Fish fingers", 121)), (0xbeef, ("a",12))]
02:39:01 <lambdabot>  Just ("Fish fingers",121)
02:55:19 <Templar> Getting:  TillType -> Maybe ([Char],a)   Does not match : TillType -> BillType
02:55:29 <Templar> any ideas?
02:57:53 <Templar> Lemmih are you there?
03:02:51 <Lemmih> Templar: What should happen when you search for an article that isn't there?
03:04:39 <Templar> return empty list
03:04:41 <Templar> ?
03:05:04 <PaulAJ> Lambda Revolution tee shirts now available.
03:05:25 <PaulAJ> I've uploaded designs to CafePress at http://www.cafepress.com/l_revolution
03:05:47 <PaulAJ> so you can see them.  But I'm happy to email the files to anyone who wants to use a more local provider.
03:06:00 <PaulAJ> At the moment I'm soliciting opinions on the design.
03:06:34 <Lemmih> Templar: Ah try, makeBill xs = [ (name, price) | (barcode, name, price) <- codeIndex, barcode `elem` xs ]
03:06:56 <shankys> I'm writing a Haskell web framework, and am wondering how I might go about getting one global database connection. I want to connect to a database once and then have that be available to the rest of the framework. I'm using Database.HDBC and PostgreSQL. I've looked at Bjorn Bringert's Hope, but he uses HaskellDB. I also looked at John Goerzen's (HDBC's maintainer) gopherbot, but that doesn't quite do what I'm looking for. Anyone have a
03:07:32 <Lemmih> shankys: Use a Reader monad?
03:07:44 <shankys> Lemmih: How would that work?
03:08:12 <PaulAJ> Or is this a place for the dreaded unsafePerformIO?
03:08:43 <PaulAJ> Something like globalConnection = unsafePerformIO openDatabaseConnection
03:08:48 <Lemmih> > runReader (do s <- ask; return (s*2)) 10
03:08:49 <lambdabot>  20
03:09:30 <shankys> Ok, thanks. I'll look into both of those.
03:09:37 <Templar> dame, thanks a lot man
03:12:26 <augustss> Merry Christmas!
03:12:44 <sieni> Laeta Saturnalia!
03:20:55 <roconnor> PaulAJ: I think that the hand ought to be in a more fist like position.
03:28:30 <PaulAJ> roconnor: Hmm.  So the Lambda would be tilted more clockwise?
03:28:38 <PaulAJ> (as you look at it)
03:29:09 <PaulAJ> I admit I copied the fist part from an old soviet poster: it was holding a hammer in the original
03:29:44 <roconnor> Oh
03:30:06 <roconnor> Well, I was thinking of grasping the large handel of the lambda
03:30:25 <roconnor> So that the tilt would be about the same
03:30:32 <roconnor> but I'm not sure how it would look.
03:31:09 <PaulAJ> It would certainly work.  Whether it would be better than the current version I'm not sure.  I'll have to try it out.
03:31:19 <roconnor> I'm not sure either
03:31:34 <PaulAJ> Also, check out the design on the back.  I wasn't sure whether to have the fist in that as well.
03:32:29 <roconnor> I don't see a design on the back
03:32:47 <roconnor> oh I see
03:32:47 <PaulAJ> Which one are you looking at?  Thats a bug.  I need to fix it.
03:32:48 <roconnor> heh
03:33:03 <roconnor> I was looking at the first shirt
03:33:09 <roconnor> the second shirt has a design on the back
03:33:18 * PaulAJ goes to add the design to the back of the first shirt.
03:37:00 <PaulAJ> Strange (and annoying): there doesn't seem to be a way for you to see the back of the shirt in the shop web area.
03:38:25 <PaulAJ> It has a red lambda with no fist and the caption "The Revolution will be Declared"
03:38:52 <roconnor> Yes, I saw it on the second shirt
03:41:34 <PaulAJ> Gotta go now.  Thanks for the suggestions.
03:51:32 <dons> mmm tshirts!
03:52:50 <dons> PaulAJ++
03:53:26 <MarcWebe1> Does anybody know what the boolean argument in the runTests hook of cabal is used for? (runTests :: Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ExitCode) When beeing invoked by  ./setup test FALSE is passed by default
03:53:46 <dons> verbosity perhaps?
03:55:53 <MarcWebe1> dons: Ah. That might be the meaning. But why is verbosity a Int when looking at preprocessors?
03:56:10 <dons> hmm. i'm not sure. i'm just guessing :)
03:56:14 <dons> have a look in the src,
03:56:28 <dons> darcs.haskell.org/packages/Cabal -- maybe
03:56:49 <PaulAJ> Hello dons
03:57:43 <PaulAJ> dons: Thanks for the inspiration for the tee shirts.
03:58:05 <MarcWebe1> dons: You might be right, really. verbosity is contained in ConfigFlags which isn't passed to the test function. Thanks.
03:58:05 <dons> PaulAJ: thanks for doing the shirts!
03:58:27 <dons> PaulAJ: I'm thinking these might be nice for the upcoming haskell hackathon
03:58:44 <PaulAJ> I'd be honoured.  Would you like the source files?
03:59:30 <PaulAJ> Ahh, email me.  paul@cogito.org.uk.  Gotta go.  Bye.  Happy Christmas.
03:59:31 <dons> PaulAJ: yes, I think that would be good, if i try to get them printed locally to give to the hackathon-ers
03:59:39 <PaulAJ> dons: will do.  Bye.
03:59:42 <dons> merry christmas :)
03:59:45 <roconnor> @when hackathon
03:59:46 <lambdabot> Maybe you meant: seen what where wn
03:59:55 <dons> Jan 10-12
03:59:58 <dons> ?where hac07
03:59:58 <lambdabot> http://haskell.org/haskellwiki/Hac_2007
04:00:21 <dons> night all
04:00:28 * dons threadDelays
04:01:17 <roconnor> Hmm, that's right in the middle of the MAP workshop
04:36:35 <joelr1> hohoho! merry christmas to y'all!
04:47:38 <lisppaste2> metaperl annotated #33327 with "how does liftM2 know what monad to lift to?" at http://paste.lisp.org/display/33327#11
04:47:56 <metaperl> happy holidays haskell
04:49:02 <_roconnor> metaperl: is that a question?
04:49:21 <metaperl> _roconnor - re: liftM2 yes, he: happy holidays haskell, no :)
04:49:46 <roconnor> @type foldl
04:49:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:49:58 <metaperl> roconnor - brb
04:50:22 <roconnor> well (liftM2 fn) has to be an a -> b -> a
04:51:08 <roconnor> and a has to be a list
04:51:14 <roconnor> @type liftM2
04:51:16 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:51:31 <roconnor> so m must be the list monad
04:59:19 <metaperl> @type liftM2
04:59:21 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:59:58 <metaperl> roconnor - why doesnt the type signature specify List then?
05:00:19 <roconnor> List is an instance of the Monad typeclass
05:00:52 <roconnor> liftM2 works for all monads using haskell's class mechinism
05:02:00 <jf> @map (+1) [1..10]
05:02:00 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
05:02:26 <metaperl> > map (+2) [1..10]
05:02:28 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
05:03:28 <metaperl> are you saying that haskell figured out to lift to the list monad for this function but could lift to something else for another function?
05:03:54 <jf> @1
05:03:54 <lambdabot> Maybe you meant: . v
05:04:12 <jf> @ map (+1) [1..10]
05:04:42 <metaperl> jf: use >
05:04:44 <roconnor> Haskell figured out that it needed to lift using the list monad, but the definition of liftM2 and the functions defined in the List Monad instance tells Haskell how to do it.
05:04:50 <jf> Ta
05:04:51 <opqdonut> > take 10 $ liftM2 (+) [1..] [1..]
05:04:52 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:05:04 <jf> > map (+1) [1..10]
05:05:06 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:06:25 <metaperl> > length $ liftM2 (+) [1..10] [1..10]
05:06:28 <lambdabot>  100
05:06:41 <jf> @help djinn
05:06:41 <lambdabot> djinn <type>.
05:06:41 <lambdabot> Generates Haskell code from a type.
05:06:41 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
05:07:19 <jf> @djinn forall t . t->t
05:07:20 <lambdabot> f a = a
05:08:08 <jf> @djinn forall a b . (a -> b) -> [a] -> [b]
05:08:08 <lambdabot> -- f cannot be realized.
05:08:27 <jf> @djinn (a -> b) -> [a] -> [b]
05:08:27 <lambdabot> -- f cannot be realized.
05:08:29 <roconnor> jf: djinn doesn't know how to deal with list types
05:08:44 <roconnor> or recursive types in general
05:09:04 <jf> roconnor, OK, I was hoping for more magic...
05:09:05 <roconnor> @djinn (((a->b)->a)->a)
05:09:06 <lambdabot> -- f cannot be realized.
05:09:17 <roconnor> @djinn ((((a->b)->a)->a)->b)->b
05:09:18 <lambdabot> f a = a (\ b -> b (\ c -> a (\ _ -> c)))
05:12:01 <metaperl> I think the nomaware tutorial does not make it clear how >>= comes into play with do notation. For example, how does >>= relate to this liftM2 f = \a b -> do { a' <- a; b' <- b; return (f a' b') }
05:12:22 <metaperl> each call to return is creating [x]
05:12:39 <metaperl> or rather [x] where x = f a' b'
05:12:51 <augustss> @djinn Not (((a->b)->a)->a)
05:12:52 <lambdabot> -- f cannot be realized.
05:12:58 <twanvl> @undo \a b -> do { a' <- a; b' <- b; return (f a' b') }
05:12:58 <lambdabot> \ a b -> a >>= \ a' -> b >>= \ b' -> return (f a' b')
05:13:16 <augustss> @djinn Not(Not (((a->b)->a)->a))
05:13:17 <lambdabot> f a =
05:13:17 <lambdabot>   void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
05:13:21 <roconnor> lambdabot: that could use more brackets
05:13:28 <metaperl> twanvl - thanks. what is the best and most clear introduction to monads?
05:13:48 <twanvl> I don't know
05:13:55 <augustss> I like sigfpe's best
05:14:02 <metaperl> augustss - url?
05:14:09 <metaperl> maybe Cale's monads as containers
05:14:44 <augustss> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
05:14:46 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
05:16:00 <augustss> but then I'm not really the person to ask about what the introduction is :)
05:22:02 <metaperl> I like this sigfpe tutorial. I like how he's motivating bind in order to be able to compose the wrappers to pure functions f and g. thanks for the recc augustss
05:22:16 <metaperl> isnt he a person in this channel sometimes? sigfpe I mean
05:22:24 <augustss> yep
05:25:35 <araujo> morning!!
05:27:41 <metaperl> araujo - morning
05:54:17 <benja_> what's this Not type constructor?
05:59:48 <roconnor> Not a = a -> Void
06:00:05 <nornagon> do you mean ::?
06:00:08 <nornagon> ?type Not
06:00:10 <lambdabot> Not in scope: data constructor `Not'
06:00:21 <roconnor> Not is only defined for Djinn
06:00:29 <benja_> ok...
06:00:40 <roconnor> but it could almost be defined in Haskell
06:00:50 <roconnor> type Not a = a -> Void
06:02:06 <augustss> what do you mean, almost? :)
06:02:15 <benja_> I saw some wiki article about comonads talk about ~(a+b) = (~a * ~b), where + is disjoint sum and * cartesian product, and I didn't know what ~ was
06:02:23 <augustss> It's just Void is is a bit dodgy in Haskell
06:02:28 <benja_> so I was wondering if this was related :)
06:02:34 <augustss> it is
06:02:46 <augustss> ~ is Not
06:02:58 <augustss> probably
06:03:02 <benja_> ok :)
06:04:18 <benja_> isn't (Not a) equivalent to Void, though? both would seem to have bottom as their only member
06:05:12 <benja_> or no -- haskell has lazy semantics, so (const bottom /= bottom)
06:05:48 <benja_> sorry if I'm betraying great ignorance =)
06:07:53 <augustss> you have to ignore bottom for this to make sense
06:07:53 <augustss> so Void is the empty type, and it is really empty, no bottom
06:08:04 <roconnor> (Not Void) has the identity function as a member
06:08:11 <roconnor> @djinn (Not Void)
06:08:13 <lambdabot> f a = a
06:09:09 <roconnor> @djinn (Not (forall a. a))
06:09:09 <lambdabot> -- f cannot be realized.
06:09:14 <roconnor> oh well
06:11:04 <benja_> so Not a is empty iff a isn't -- I see
06:11:25 <roconnor> that approximately correct. ... not quite an iff.
06:11:59 <roconnor> and of course there are all sorts of non-terminating programs in Not a.
06:12:10 <roconnor> but these are all bottom.
06:12:27 <benja_> but augustss said ignore those =)
06:13:35 <roconnor> (((a->b)->a)->a) has no member, but neither does Not (((a->b)->a)->a)
06:15:14 <benja_> hmm, I'm getting the idea that I mustn't think of types as sets to make sense of thiswhy's it not iff, though, presuming we ignore...
06:15:50 <benja_> oops, two lines in one :)
06:16:23 <roconnor> benja_: it's the polymorphism that makes it not behave like sets ... I think.
06:18:17 <benja_> roconnor: no, it's that you must think of Void as not necessarily empty
06:19:00 <benja_> @google friedman realizability interpretation
06:19:02 <lambdabot> http://www.andrew.cmu.edu/user/avigad/Talks/realizability.pdf
06:19:15 <roconnor> benja_: I don't buy that
06:19:35 <benja_> roconnor: I'm not explaining it well :)
06:20:21 <benja_> if you think of types as sets, and 'falsehood' as the empty set, then (a -> falsehood) is classical negation
06:20:32 <benja_> you want intuitionistic negation
06:20:40 <roconnor> ignoring bottoms, Void is really empty.
06:20:58 <roconnor> but a -> Void is arguably not the classical negation.
06:21:18 <uccus> but is it unique?
06:22:23 <roconnor> because a ranges over non-classical things, like intuistionic disjunction.
06:22:32 <benja_> what you do is that you consider assignments (basic types union {bottom} -> sets of natural numbers) in the metalogic
06:23:47 <benja_> there are terms that inhabit 'bottom' for some of these assignments, but none that inhabit it for all assignments
06:25:04 <benja_> or s/terms/numbers/
06:26:13 <lisppaste2> metaperl pasted "can I use where when returning a constructed function or must I use let?" at http://paste.lisp.org/display/33383
06:26:52 <metaperl> the question starts on line 77
06:28:28 <twanvl> where should work here as well
06:29:15 <metaperl> twanvl - i had probs getting things in scope
06:29:19 <lisppaste2> roconnor annotated #33383 with "using where" at http://paste.lisp.org/display/33383#1
06:30:17 <metaperl> roconnor - thanks
06:31:18 <benja_> roconnor: http://www.math.ohio-state.edu/~friedman/pdf/CompltIntuiLogic3%5B1%5D.20.00.pdf may or may not be clearer .)
06:31:21 <lambdabot> http://tinyurl.com/yb2ug8
06:32:54 <benja_> at least if we want to think of functions in the extensional mathematical way, which I was but perhaps didn't say
06:33:47 <benja_> if we think of types as sets of simply typable *lambda terms* then void is certainly empty, that being the point =)
06:34:43 <roconnor> well, I suppose there is a lot of interpetations of constructive logic.  That's what makes it so widely useful.
06:35:58 <benja_> =)
07:14:57 <metaperl> @type (>>=)
07:15:03 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
07:15:50 <metaperl> hey, I think sigfpe has a wrong type signature for bind here: http://rafb.net/p/WDGl5986.html
07:15:52 <lambdabot> Title: Nopaste - No description
07:16:35 <metaperl> his parentheses are in the wrong place. It should be  (Complex Double -> [Complex Double]) -> [Complex Double] -> [Complex Double]
07:17:05 <metaperl> I'm quoting from his post: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
07:17:09 <metaperl> (assuming it's a he)
07:17:11 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
07:19:50 <allbery_b> well, strictly speaking, it's correct because -> is right-associative :)
07:20:08 <metaperl> bind takes how many arguments?
07:20:12 <metaperl> 2 right?
07:20:31 <metaperl> the output of the previous function and a function which cannot digest this output without some massaging
07:20:58 <metaperl> allbery_b - i dont understand what you mean by right associative and why what he wrote is OK
07:22:07 <allbery_b> in Haskell his type signature is the same as the standard one.  think currying and partial application.  (but yes, I suspect that is a typo)
07:22:26 <metaperl> I'm lost man
07:23:33 <allbery_b> don't worry about it.  it just means that if he tested his code, it would have typechecked and worked, so he wouldn't have caught the typo
07:24:01 <allbery_b> (at least not that way)
07:26:55 <Saizan> metaperl, just load the post in ghci, it typechecks :) however those parentheses are more consistent with his way of describing monads, and are perfectly equivalent with the form without them
07:27:05 <allbery_b> right associative:  a -> a -> a is parsed as (a -> (a -> a)) (as opposed to ((a -> a) -> a) )
07:27:35 <metaperl> a -> a -> a to me means take 2 args and return a 3rd arg
07:27:48 <metaperl> oh I see
07:28:02 <Saizan> a function that take 2 args is a function that take 1 arg and return a function which takes 1
07:28:04 <allbery_b> this is what makes currying work, because you can peel off one argument
07:28:11 <metaperl> yes!
07:28:15 <metaperl> well put Saizan
07:28:46 <metaperl> yes, it binds 1 arg throughout the funciton body and returns that function for the other arg to finish with
07:28:47 <metaperl> I see
07:29:26 <ski_> but 'extend :: '(a -> M b) -> (M a -> M b)' *does* take one function, which returns a monadic action, and extends it to a function which now accepts a monadic action as argument, as well
07:32:04 <ski_> (in category theory, the first and third arrow there will be a morphism/arrow/map in a category, while the second one still is a function)
07:42:55 <Saizan> (what's the difference?)
07:43:20 <Saizan> (well, i'll study categoty theor first.. *me reads)
08:04:08 <metaperl> I need some help proving the single property of a functor: fmap (f. g) = fmap f  . fmap g : http://rafb.net/p/deYvjg44.html
08:04:09 <lambdabot> Title: Nopaste - No description
08:06:44 <Saizan> what's  the problem?
08:07:08 <metaperl> Saizan - the paste has two sets of question marks... see them?
08:07:16 <Saizan> ok
08:07:40 <twanvl> I don't think you can prove this without knowing more about fmap
08:07:41 <Saizan> on line 10, that's correct if the f in the type signature is the functor and not the function f
08:07:45 <metaperl> oh wait
08:08:04 <metaperl> yes on line 10, f. g is passed to fmap so the real signature is fmap (f.g) = f a -> f c
08:08:25 <Saizan> yes
08:09:16 <Saizan> on line 14 you get f a -> f c too as you get a -> c from f.g
08:10:43 <metaperl> ok good. I'm cool with functors per Hudaks gentle intro to haskell. now onto monads... all the touchy feely tutorials were missing things I think... I'm going hardcore on this one
08:11:27 <Saizan> twanvl: i think you should at least know that fmap doesn't change the "structure" of the functor
08:11:50 <metaperl> Saizan - you mean metaperl :)
08:11:58 <metaperl> oh sorry
08:12:01 <metaperl> maybe you did mean him
08:12:02 <Saizan> both :)
08:12:05 <allbery_b> heh
08:13:36 <metaperl> I do not understand Hudak's next sentence <quote> These laws ensure that the container shape is unchanged by fmap and that the contents of the container are not re-arranged by the mapping operation.</quote>
08:15:37 <Saizan> is like what i just said
08:15:54 <Saizan> (which laws?)
08:15:56 <Saizan> > let fmap f = reverse . map f in fmap (+1) . fmap (+2) $ [1..3]
08:15:58 <lambdabot>  [4,5,6]
08:16:01 <metaperl> I think map is a special case of fmap which preserves the order (order) of a list and returns a list (structure)
08:16:05 <Saizan> > let fmap f = reverse . map f in fmap ((+1) . (+2)) $ [1..3]
08:16:06 <lambdabot>  [6,5,4]
08:17:00 <fasta> foo bar baz size+1 compiles just as foo bar baz (size+1) does. The former is incorrect, the latter correct. Hard to spot...
08:17:01 <Saizan> yes, and having map f . map g == map f.g guarantees that
08:17:07 <metaperl> >  fmap (+1) . fmap (+2) $ [1..3]
08:17:09 <lambdabot>  [4,5,6]
08:17:28 <metaperl> > fmap ((+1) . (+2)) $ [1..3]
08:17:29 <lambdabot>  [4,5,6]
08:21:09 <metaperl> fmap show [1..3]
08:21:15 <metaperl> > fmap show [1..3]
08:21:17 <lambdabot>  ["1","2","3"]
08:21:32 <metaperl> container and order preserved
08:21:54 <metaperl> contents vary because (a -> b) -> f a -> f b
08:22:06 <metaperl> a was Num , b is String, (a -> b) = show
08:22:09 <metaperl> simple
08:22:16 <metaperl> yet very cool :)
08:23:05 <metaperl> let us continue past Functors on into Hudak's description of Monads. wish me well mates
08:23:25 <Saizan> what are you reading?
08:23:51 <_matthew_> "A Christmas Tale"
08:24:15 <Saizan> link?
08:25:03 <_matthew_> themonadicdeity.org ;)
08:30:36 <metaperl> Saizan - http://www.haskell.org/tutorial/monads.html
08:30:41 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
08:35:59 <metaperl> I do not agree with this <quote>The bind operations, >> and >>=, combine two monadic values</quote> a bind operation actually combines a monadic value with a function that produces a monadic value
08:37:09 <_matthew_> but a monad is a function and functions are values
08:38:13 <metaperl> a monad relates a type to a monad class
08:38:34 <_matthew_> oh yes, sorry. I always think of IO by mistake.
08:41:33 <opqdonut> heh IO is a surprisingly bad example of a monad :)
08:42:09 <ToRA> @type (>>)
08:42:10 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
08:43:17 <ToRA> does >> have a name? (>>= is bind)
08:44:10 <allbery_b> no, it's just a convenience function as a special case of >>=
08:44:19 <_matthew_> if >>= is bind then what's <- ?
08:44:43 <allbery_b> syntactic sugar on top of >>=
08:44:44 <ToRA> <- isn't a function
08:44:54 <_matthew_> ?type (<-)
08:44:56 <lambdabot> parse error on input `<-'
08:45:08 <_matthew_> fairdos
08:45:25 <opqdonut> i think of <- as get
08:45:29 <opqdonut> or assign
08:46:02 <Saizan> <- is the -> in >>= \x ->
08:46:10 <opqdonut> yeah :)
08:46:23 <_matthew_> yes indeed
08:46:49 <opqdonut> ?type (->)
08:46:52 <lambdabot> parse error on input `->'
08:46:55 <opqdonut> :)
08:46:59 <_matthew_> ?kind (->)
08:47:00 <lambdabot> ?? -> ? -> *
08:47:11 <opqdonut> ah
08:47:11 <_matthew_> what on earth does that mean?!
08:47:53 <Saizan> maybe ? can be either a type or a *
08:48:17 <_matthew_> then what's ?? ?
08:48:45 <Saizan> like when you have a1 a2, but i'm just speculating
08:51:21 <Saizan> ?kind ((->) Int)
08:51:22 <lambdabot> ? -> *
08:51:38 <Saizan> ?kind ((->) ((->) Int Int))
08:51:39 <lambdabot> ? -> *
08:51:54 <_matthew_> ?kind ((->) Int Int)
08:51:55 <lambdabot> *
09:09:40 <uccus> hi all
09:09:51 <uccus> I have an ugly function
09:10:15 <araujo> :-(
09:10:34 <uccus> > let mapmap [] x = []; mapmap (f:fs) x = (f x): mapmap fs x in mapmap
09:10:34 <lambdabot>  Add a type signature
09:11:07 <roconnor> aww, that's a cute function
09:11:25 <roconnor> @type sequence
09:11:26 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
09:11:29 <uccus> > let mapmap [] x = []; mapmap (f:fs) x = (f x): mapmap fs x in mapmap [filter (== 'l')] "alpha"
09:11:30 <lambdabot>  ["l"]
09:11:39 <roconnor> hmm
09:11:53 <roconnor> yep, it's called sequence
09:11:55 <roconnor> I think
09:11:58 <uccus> roconnor: do you mean to say sequence is mapmap?
09:12:02 <roconnor> If you import Control.Monad.Reader
09:12:13 <roconnor> yes
09:12:25 <roconnor> I think
09:12:30 <uccus> let me try it
09:12:30 <ToRA> > sequence [filter (== 'l')] "alpha"
09:12:32 <lambdabot>  ["l"]
09:12:35 <roconnor> :)
09:12:39 <uccus> yeah
09:12:42 <uccus> thanks :)
09:13:03 <dylan> > sequence [(*2), (+3)] [1,2,3,4]
09:13:04 <lambdabot>  add an instance declaration for (Num [a])
09:13:20 <twanvl> > map ($10) (+1,*2,-3)
09:13:20 <lambdabot>  Parse error
09:13:39 <twanvl> > map ($10) ((+1),(*2),(+3))
09:13:40 <lambdabot>  Couldn't match `[a -> b]' against `(a1, b1, c)'
09:13:47 <Shimei> So, apparently I got a copy of SICP from Santa. ;)
09:13:51 <twanvl> > map ($10) [(+1),(*2),(+3)]
09:13:52 <lambdabot>  [11,20,13]
09:14:12 <ToRA> > sequence [(*2), (+3)] 1
09:14:13 <lambdabot>  [2,4]
09:14:14 * Shimei shares in #haskell off-topically, but there's probably no #scheme
09:14:26 <Shimei> Nevermind, it has 106 users. :o
09:14:45 <allbery_b> this is freenode, if you think it, it probably exists :)
09:15:22 <uccus> can someone give me a pointer on how I can use @pl on a recursive function definition?
09:15:39 <Shimei> allbery_b: There's no #opera. :P
09:15:49 <Shimei> Oh wait, it's ##opera.
09:15:51 <kpreid> @pl let f x = f (1:x) in f
09:15:52 <lambdabot> fix (. (1 :))
09:15:52 <Shimei> I have been disproven.
09:16:00 <kpreid> uccus: ike that
09:16:23 <uccus> thanks
09:16:29 <uccus> tried that
09:27:01 <tibbe> @users
09:27:01 <lambdabot> Maximum users seen in #haskell: 309, currently: 254 (82.2%), active: 19 (7.5%)
09:27:30 <benja_> @lusers
09:27:31 <lambdabot> Maximum users seen in #haskell: 309, currently: 255 (82.5%), active: 19 (7.5%)
09:31:16 <LPhas> hi
09:31:38 <LPhas> i saw some times ago a page on haskell.org about how to release "something"
09:31:46 <LPhas> but i cannot manage to find it again ...
09:33:09 <allbery_b> @google how to write a haskell program -- that?
09:33:11 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
09:33:11 <lambdabot> Title: How to write a Haskell program - HaskellWiki
09:34:44 <LPhas> sigh, thx
09:38:57 <tibbe> i need an editor for some causal haskell programming (i.e. when i'm not booted into linux where i use emacs)
09:39:47 <pejo> tibbe, how about emacs? :-)
09:39:49 <Philippa> tibbe: under windows?
09:39:52 <Philippa> TextPad's not bad
09:39:53 <allbery_b> @where yi -- only half serious
09:39:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
09:40:06 <tibbe> ah, yes, under windows :)
09:40:15 <Philippa> (by which I mean that I use TextPad for almost all my coding)
09:40:39 <tibbe> Philippa, thanks, that'll do, i just have a programming itch and can't be bothered to reboot
09:41:09 <Philippa> there's a syntax definition file available for it that covers Haskell, worth grabbing
09:41:20 <benja_> I'm with pejo, why not install emacs for windows if that's what you're using under linux too? :-)
09:41:35 <tibbe> Philippa, on the web page?
09:41:53 <tibbe> benja_, I'm too lazy to set it up for a couple of hours of programming ;)
09:42:07 <benja_> ok :)
09:42:35 <Philippa> tibbe: I think it's linked to from somewhere under there, yeah
09:42:39 <tibbe> ok
09:43:07 <tibbe> Philippa, there are two, one written by dons, which one do you use?
09:43:13 <Philippa> it does have one irritation, it misparses characters which means that having two identifiers like foo' on the same line is a PITA
09:43:28 <Philippa> ah. Probably not dons's one, but I should try it in a couple of days when I'm on a windows machine again
09:43:56 <Philippa> it's been a long time since I first set things up :-)
09:44:17 <tibbe> :)
09:44:36 <allbery_b> or pssh to a machine with emacs installed :)
09:47:59 <tibbe> :)
09:51:49 <LPhas> anyone knows how to preprocess a .hsc file with hsc2hs with Cabal? Doc isn't very clear...
09:54:58 <tibbe> argh, how do I write file paths on windows?
09:55:27 <jyp> LPhas: extensions:     CPP, ForeignFunctionInterface
09:55:32 <jyp> afaict.
09:55:35 <benja_> C:\foo\bar\baz.hs ?
09:55:59 <tibbe> doesn't work with ghci's :cd
09:56:09 <benja_> :(
09:56:31 <tibbe> or perhaps it's just me
09:56:43 <jyp> pwd
09:56:47 <jyp> arg.
09:57:02 <LPhas> jyp: it's not a matter of extension, i need to say to cabal to preprocess a single file .hsc before compiling
09:57:28 <jyp> LPhas: it should "just work".
09:58:34 <LPhas> jyp: seems not
09:58:37 <jyp> You can check what's done in the yi repository for example.
09:58:51 <Saizan> tibbe, use forward slashes, or \\
09:58:54 <jyp> works for me :p
09:59:13 <tibbe> works for me too now :)
09:59:16 <LPhas> you mean that if i have a module called Foo
09:59:22 <LPhas> in a Foo.hsc file
09:59:25 <tibbe> btw, Console2 is a nice cmd.exe shell
09:59:41 <LPhas> when i build something that require Foo with cabal
09:59:54 <LPhas> cabal preprocess the hsc e build against the output?
10:00:05 <jyp> yes.
10:00:47 <jyp> LPhas: this is ghc 6.6 btw.
10:01:06 <jyp> dunno how it behaves with previous versions.
10:01:07 <tibbe> @where bug
10:01:07 <lambdabot> I know nothing about bug.
10:01:10 <tibbe> @where bugs
10:01:10 <lambdabot> I know nothing about bugs.
10:01:13 <tibbe> @where bugtracking
10:01:14 <lambdabot> I know nothing about bugtracking.
10:01:31 <jyp> @where trac
10:01:31 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:01:36 <opqdonut> :)
10:01:45 <jyp> bingo.
10:02:01 <opqdonut> lambdabot: bugs is at http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:02:07 <opqdonut> :/
10:02:17 <opqdonut> ?remember
10:02:17 <lambdabot> Incorrect arguments to quote
10:02:27 <opqdonut> nvm
10:02:38 <jyp> @where+ bugs http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:02:38 <lambdabot> Done.
10:02:39 <allbery_b> @bug
10:02:40 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:02:48 <opqdonut> ahh, ok
10:03:12 <jyp> np.
10:04:22 <LPhas> jyp: now works, i forgot to mention the module in "other modules". thx a lot.
10:05:45 <jyp> LPhas: I didn't spot that. Thanks for the clarification.
10:07:22 <LPhas> jyp: it's a bit strange. if i need to compile modules against some .hs, work witouth mentioning it in "other modules", but if needs preprocessing, doesn't work
10:08:25 <newsham> > unfoldr (\n -> let (a,b) = n `divMod` 127 in if a == b && a == 0 then Nothing else Just (toEnum $ fromIntegral b, a)) 32873833960620269464048505864227 :: [Char]
10:08:26 <lambdabot>  "Merry Christmas"
10:08:54 <tibbe> and the same to you
10:10:53 <LPhas> :)
10:16:31 <joelr1> hohoho
11:05:09 <mbishop> http://programming.reddit.com/info/vzw8/comments
11:05:10 <lambdabot> Title: Ask Reddit: What&#39;s your language of choice, and why? (reddit.com)
11:05:21 <mbishop> merry christmas, war yourself by the flamewar
11:05:22 <mbishop> :P
11:05:27 <mbishop> warm*
11:05:29 <riczho> Hah.
11:05:40 <wy> Merry Christmas!
11:08:31 <wy> I want to gather some ideas about Ruby's "Duck typing" according to a Haskell programmer's view
11:08:54 <metaperl> wy - Pythonistas duck type as well
11:12:33 <allbery_b> "duck typing" == "Duck!" typing
11:14:21 <metaperl> I need some help understanding these equivalence laws of monads
11:14:22 <metaperl> http://rafb.net/p/9zMXWj74.html
11:14:24 <lambdabot> Title: Nopaste - The laws which govern >>= and return
11:14:59 <mbishop> Why does haskell still not have a newsgroup?
11:15:49 <metaperl> mbishop - you can read haskell and haskell-cafe via GMANE
11:26:08 <lisppaste2> metaperl pasted "return (x /= y) does not seem to obey return :: a -> m a" at http://paste.lisp.org/display/33395
11:29:43 <benja_> metaperl: how so? works for me
11:29:46 <allbery_b> hm?  sure it does, with a == Bool for that operation
11:30:13 <metaperl> but return puts a container on something
11:30:24 <benja_> metaperl: sure, a list container
11:30:27 <metaperl> Bool -> m Bool  should have been prouced
11:30:29 <allbery_b> sure.  it wraps in a list and is immediaterlyunwrapped by <-
11:30:38 <benja_> metaperl: yes, Bool -> [Bool] is produced
11:30:42 <metaperl> oh
11:30:46 <allbery_b> (actually by (>>=))
11:30:47 <metaperl> thanks :)
11:31:01 <metaperl> there is no (>>=) here allbery_b
11:31:03 <benja_> (the list is of length one)
11:31:14 <metaperl> yes, because return is defined that way
11:31:14 <benja_> metaperl: 'do' produces >>=
11:31:17 <metaperl> got it
11:31:19 <allbery_b> it's there behind the scafolding of the do notation
11:31:42 <allbery_b> y <- x  ==  x >>= \y ->
11:33:26 <ihope> Is there a class for values with finite numbers of values?
11:34:23 <benja_> allbery_b: not quite, I think, and metaperl's example shows it =-)
11:34:26 <allbery_b> range subtyping is problematic in Haskell because it can't be staically checked, except for enum types
11:34:27 <metaperl> arent those called algebraic data types? data Weather = Spring | Summer | Fall | Winter
11:34:43 <metaperl> deriving Ordered, Eq, Show
11:34:58 <metaperl> ihope - is that what you mean?
11:35:18 <benja_> y <- x; ...   ==   x >>= \y' -> case y' of y -> ...; otherwise -> fail "blah"
11:36:22 <ihope> metaperl: enumerated data types.
11:36:33 <kpreid> ihope: Bounded
11:36:50 <ihope> kpreid: Bounded and Enum?
11:36:50 <kpreid> ihope: usually together with Enum
11:37:05 <ihope> That'd work.
11:37:35 <kpreid> you can derive them from algebraic types containing only Bounded/Enum components
11:38:23 <ihope> So here's a function that must be used: hayQue f = any f [minBound..maxBound]
11:40:09 <bedwetfun> haskillz
11:40:31 <metaperl> lol
11:40:41 <wy> metaperl: So how is your observations about that kind of typing?
11:41:02 <metaperl> wy - i really never could figure out what is was
11:41:07 <ihope> Haskillz and a Spanish pun to go with them.
11:41:26 <metaperl> wy - have you seen Construct for python? It's pretty cool... prolly not on topic for what you are talking about
11:42:10 <sieni> something cool in python o.O
11:43:25 <wy> I think it's too bad that it added the syntax "for key in d" where d is a dictionary. This makes it like Perl.
11:44:02 <allbery_b> awk, actually :)
11:44:04 <wy> This leads me to think that Python is not theorectically robust
11:44:19 <metaperl> wy - that never stopped PHP
11:45:30 <wy> metaperl: I really want to know if "duck typing" has something good. It looks somewhat like CLOS.
11:45:44 <metaperl> wy - where is a good description of it
11:47:07 <mbishop> wikipedia? :P
11:48:08 <metaperl> where is the "Monads as Computation" wiki page? Cale ?
12:08:19 * allbery_b finally has a working wxhaskell, after way too much yak shaving over compiler versions and broken vendor-provided libs
12:15:40 <metaperl> It's been awhile since I've seen the brackets on a type constructor... what do they do: newtype Lover a = Lover { loverDiary :: (Name,a) }
12:16:02 <integral> it's a "record".
12:16:23 <integral> You get to use record syntaxes for creation and update, and the names of the fields become projections from the record type
12:16:23 <metaperl> integral - thanks
12:17:01 <kermhermit> Is there a way to iterate an IO action through a list?
12:17:08 <kermhermit> Or do you have to roll your own?
12:17:28 <integral> @type mapM
12:17:30 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:17:41 <integral> @type sequence
12:17:43 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:18:15 <integral> kermhermit: Do either of those help?
12:18:26 <integral> there's also mapM_ and sequence_ when the result doesn't matter
12:18:48 <kermhermit> integral, yes, thanks.
12:18:49 <augustss> and foldM
12:19:01 <integral> @type foldM
12:19:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:19:09 <integral> oh, handy.
12:19:48 <lightstep> foldM is confusing when you don't need it
12:20:42 <metaperl> I'm trying to find an example of record syntax online... any pointers?
12:21:36 <Saizan> there's a paragraph on them in YAHT
12:21:41 <lightstep> there was a wiki page with code samples, to show to newbies
12:23:56 <lightstep> http://www.haskell.org/hawiki/HaskellDemo
12:23:58 <lambdabot> Title: HaskellDemo - The Haskell Wiki
12:26:23 <metaperl> lightstep thanks
12:30:00 <ToRA> >  sequence [(*2), (+3)] 1
12:30:01 <lambdabot>  [2,4]
12:30:19 <ToRA> when i try that under ghci i get a No instance for (Monad (->) a)) error
12:30:30 <mauke> :m +Control.Monad.Reader
12:30:42 <ToRA> aaaah
12:31:24 <mauke> > sequence ["foo", "bar"]
12:31:26 <lambdabot>  ["fb","fa","fr","ob","oa","or","ob","oa","or"]
12:32:22 <Saizan> ?type sequence
12:32:23 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:32:58 <Saizan> ?type sequence [(+1)]
12:33:00 <lambdabot> forall a. (Num a) => a -> [a]
12:33:10 <Saizan> ?type sequence ["asd"]
12:33:11 <lambdabot> [[Char]]
12:33:39 <ToRA> mauke: is there anything in the ghc docs that specifies that's where the instance for Monad (->) a comes from?
12:33:52 <kolmodin> dons: hia
12:34:12 <Azmo> if parsing a file with the parser in Language.Haskell.Parser, is there something one can import to do the type inference too?
12:34:41 <mauke> ToRA: IIRC it's Control.Monad.Instances in ghc 6.6
12:35:11 <ToRA> ah gotcha
12:36:07 <ToRA> yup 'tis, cheers
12:36:26 <augustss> Azmo: the first question to ask is if you can get it to do operator parsing properly :)
12:38:38 <ToRA> > ((*2) >>= const.id) 4
12:38:39 <lambdabot>  8
12:39:32 <Azmo> i do not understand.. what i need is the abstract syntax of haskell source files, including the types. is there anything in the standard libraries to do this? i don't really have the time to implement my own :]
12:40:27 <zeeeee> ghc -v MyApp.hs fails with "Could not find module ..." even though i think i installed the lib. how do i check what's installed?
12:40:53 <integral> Azmo: there's always the API for embedding GHC itself :-/
12:40:59 <mauke> no idea, try --make
12:41:16 <zeeeee> mauke: was that to me
12:41:18 <integral> oh, I know!, Azmo YHC has an Haskell API to it's core format which iirc is type annotated.
12:42:41 <Azmo> hm.. what do you mean with "API for embedding GHC itself" ?
12:43:07 <Azmo> i mean.. there should be a type checker in GHC somewhere, isn't it avaialble ?
12:45:16 <allbery_b> zeeeee: yes.  try --make, or see if you can spot it in the output of ghc-pkg list and then use -package whatever on the ghc command line
12:47:12 <zeeeee> hmm, weird - i see it in parens, in my homedir: (hscurses-1.0)
12:48:13 <Saizan> is correct to say that in the ((->) e) monad join = id >>= ?
12:48:36 <edi> ?type (>>= id)
12:48:38 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:48:59 <mauke> Saizan: yeah, I think so
12:49:00 <edi> Saizan: join = (>>= id) is actully the definition in the Prelude
12:49:02 <Saizan> ?type (id >>=)
12:49:03 <lambdabot> forall a b. (a -> a -> b) -> a -> b
12:49:09 <allbery_b> that indicates it's been "hidden".  ghc-pkg expose hscurses-1.0
12:51:07 <metaperl> I've been struck with a monomorphism restriction: ex35 = foldl1 max
12:51:15 <metaperl> that little piece of code did me in
12:51:43 <allbery_b> -fno-monomorphism-restriction, or give it a type signature
12:51:48 <mauke> or use more arguments
12:51:53 <metaperl> yeah, but what did I do?
12:52:04 <metaperl> I created some sort of problem somehow
12:52:09 <allbery_b> if you don't provide any arguments, haskell98 requires inference of a restricted type
12:52:15 <metaperl> i'm just trying to understand it, not sweep it under the rug
12:52:21 <allbery_b> that's the monomorphism restriction
12:52:29 <HnH> www.oldp.net/?l=Prorok (Please click on link)
12:53:14 <metaperl> I dont know what a restricted type is, but probably dont have any right asking either :)
12:53:17 <metaperl> so I will add an arg
12:53:35 <Lemmih> type error -> provide compelling arguments to GHC?
12:54:12 <metaperl> wow that's all it took to fix it: ex35 l = foldl1 max l
12:54:21 <allbery_b> basically, the Haskell98 standard requires that functions declared without arguments not be made fully polymorphic.  so it's artificially restricting the type on you, nd if it can't deduce a suitably restricted single type it'll complain
12:54:35 <metaperl> oh I see
12:54:39 <allbery_b> there's a section in the ghc documentation explaining it
12:55:41 <sorear> like "foo = 0"; foo's most general type is Num a => a (which includes Int, Integer, Double, Rational, etc), but with the monomorphism restriction it will pick *one* of those types, and if you try and use it at two or more it'll fail.  (this is a very controversial feature)
12:56:16 <allbery_b> the problem is that in some cses, giving such a function the fully polymorphic type it "wants" can cause exponential type inference, or something like that.  it's more likely in the stock haskell98 type inference rules; ghc uses a more sophisticated typechecker which is more likely to do the right thing, so you can pass -fno-monomorphism-restriction and take the risk that it might still hit a corner case
12:56:50 <jcreigh> or you can just give it a type signature, which is probably a good idea anyway.
12:57:15 <allbery_b> ...or declare an argument explicitly
12:59:52 <augustss> allbery_b: the problem is that in some cases the runtime can get exponentially worse with polymorhpic non-functions
13:00:10 <augustss> type checking is exponential anyway :)
13:04:42 <aes2> How can I build the documentation for the extra-libraries after ./darcs-all pull -a?
13:13:49 <zeeeee> thanks, now after exposin,g ghc can find the module
13:14:19 <lisppaste2> metaperl pasted "The <- notation.. how to think about it in this case?" at http://paste.lisp.org/display/33399
13:14:53 <mauke> recursive call
13:14:59 <mauke> assign result to rest
13:15:04 <metaperl> yeah, but it's so hard to think of rest in that way
13:15:04 <allbery_b> that's just recursion done in a monad
13:15:14 <mauke> metaperl: why?
13:15:17 <integral> sub alien { ...; my $earthling = &alien }
13:15:18 <emu> it's just a function call
13:15:34 <bedwetfun> newbie question: I have an instance of show for a
13:16:03 <emu> you can think of it as threading the IO state
13:16:11 <mauke> sub ask_for_words { print "Please enter a word:\n"; chomp(my $word = <STDIN>); if ($word eq "") { return (); } else { my @rest = ask_for_words(); return ($word, @rest); } }
13:16:19 <lisppaste2> zeeeee pasted "build error when importing hscurses" at http://paste.lisp.org/display/33400
13:17:19 * metaperl tries maukes code
13:18:27 <mbishop> eww perl
13:18:27 <allbery_b> zeeeee: looks to me like HsCurses requires you to include a library of some kind
13:18:42 <aes2> Where do you get your local documentation from?
13:18:53 <jyp> zeeeee: use --make ?
13:19:00 <allbery_b> I'm not real familiar with it so couldn't tell you what library but it's probably to be found wherever you installed hscurses
13:19:44 <metaperl> mauke - it returns immediately - http://rafb.net/p/dzIiag15.html
13:19:44 <lambdabot> Title: Nopaste - No description
13:20:11 <mauke> how did you test it?
13:20:16 <metaperl> "I can think of it as threading the IO state" --- if I could think that deeply I could :)
13:20:26 <metaperl> mauke - yes
13:20:38 <mauke> EINVAL
13:21:26 <lisppaste2> zeeeee annotated #33400 with "now using ghc -v --make " at http://paste.lisp.org/display/33400#1
13:22:04 <dons> morning all
13:22:04 <metaperl> ah - well - rest takes on all possible values of ask_for_works simultaneously and in order
13:22:20 <riczho> Salve!
13:22:29 <zeeeee> allbery_b: that might be possible...i have no idea how to use hscurses, there's only api documentation
13:22:52 <jcreigh> metaperl: no, not "all possible values". The ones that are actually entered.
13:23:02 <dons> ?users
13:23:03 <lambdabot> Maximum users seen in #haskell: 309, currently: 266 (86.1%), active: 34 (12.8%)
13:23:09 <dons> ?uptime
13:23:10 <lambdabot> uptime: 3d 20h 42m 20s, longest uptime: 9d 2h 23m 6s
13:24:16 <mbishop> http://groups.google.com/group/news.announce.newgroups/browse_thread/thread/ddae92869ff5205f/b6a9cccb0aa8a3d8?lnk=st&q=haskell&rnum=5#b6a9cccb0aa8a3d8
13:24:18 <lambdabot> Title: Google Groups: news.announce.newgroups, http://tinyurl.com/yjvwju
13:24:19 <mbishop> did this ever go through?
13:24:27 <metaperl> yes, so it's kind of like foldr --- return [] then return last_word : [] then return next_to_last : [last_word] , etc, etc
13:25:18 <mauke> it's called "recursion" :-)
13:25:36 * allbery_b doesn't appear to have hscurses installed so can't tell you much more
13:25:50 <metaperl> its kind of like yield in Python or Ruby
13:26:01 <mauke> no, it's like call/return
13:26:05 <metaperl> it's recursion but odd recursion
13:26:11 <zeeeee> mbishop: i hope not... there's already the mailing lists
13:26:24 <mbishop> usenet > mailing lists :P
13:26:42 <jcreigh> metaperl: no, it's recursion. :)
13:26:53 <emu> ask_for_words >>= \input ->
13:26:58 <jcreigh> what's "odd" about it?
13:27:06 <zeeeee> mbishop: you'd need to make them sync both ways though
13:27:26 <metaperl> emu can you write a working version using (>>=) ?
13:28:08 <metaperl> yeah I get it... its like I said... its like foldr
13:28:36 <mauke> yes, that's what recursion is
13:28:46 <augustss> metaperl: where is this odd recursion?
13:28:53 <metaperl> return last_word : [] then return next_to_last: [last_word] then first_word:[next_to_last, last_word]
13:28:58 <mauke> foldr is a specific recursion pattern
13:29:16 <metaperl> augustss - you are one of the original designers of haskell? it's right here - http://paste.lisp.org/display/33399
13:29:37 <metaperl> it's just it threw me for a loop (no pun intended)
13:29:40 <metaperl> lol
13:29:43 <metaperl> I have it down now :)
13:30:14 <augustss> actually, thomas johnsson and I flipped a coin on who was going to be on the original haskell committee.  he lost, so he was on it. :)
13:30:28 <augustss> but i've been on the haskell committee after that
13:30:55 <augustss> metaperl: what's odd about that recursion?  looks like recursion to me :)
13:31:06 <lisppaste2> jcreigh annotated #33399 with "with >>=" at http://paste.lisp.org/display/33399#1
13:31:07 <dons> augustss: hehe. nice fact :)
13:31:31 <jyp> hey dons
13:31:47 <metaperl> nothing. it's I was over-analysing things... how do I read an integer into haskell from stdin?
13:31:52 <jcreigh> do-notation was invented to prevent having to use tons of >>=s and nested lambdas.
13:32:05 <mauke> metaperl: getLine + read, or readLn
13:32:05 <augustss> metaperl: but i did make the first haskell implementation :)
13:32:07 <integral> :t readLn :: IO Int
13:32:08 <lambdabot> IO Int :: IO Int
13:33:31 <jyp> dons: may I ask what's the current state of affairs with Yi?
13:34:30 <dons> jyp: its maintained only. not under active development
13:34:38 <dons> jyp, but if someone would like to take it under their wing...
13:35:06 <jyp> dons: I've played a bit with it
13:35:20 <dons> yeah, I know :)
13:35:24 <jyp> dons: I'm kind of half way in a gtk port.
13:36:20 <dons> ok. good. you've got the yi+gtk branch?
13:36:28 <jyp> I've seen it...
13:36:38 <jyp> but it seemed to me a bit outdated
13:36:47 <dons> it woudl be
13:37:13 <jyp> I might re-use some of the stuff in there, yup.
13:37:18 <dons> yep
13:37:32 <jyp> But before that...
13:37:45 <jyp> I think I will attempt a port to use the vty library
13:37:52 <jyp> instead of curses
13:38:02 <dons> yeah, that would be useful
13:38:05 <jyp> The simple reason: it supports my terminal properly ;)
13:38:08 <dons> right.
13:38:12 <dons> no more curses issues
13:38:26 <jyp> Ok then.
13:38:26 <dons> there's a good reason, I now know, why no editors are written in curses :)
13:38:34 <jyp> I'll try that tomorrow
13:38:48 <metaperl> jcreigh - thanks for the annotation
13:39:22 <aes2> Has anyone experience with building all(including the extra libraries) of the documentation of GHC?
13:39:43 <jyp> aes2: make html doesn't do the trick?
13:39:48 <lisppaste2> Saizan annotated #33399 with "pl" at http://paste.lisp.org/display/33399#2
13:40:34 <aes2> jyp, it only builds some of it. Not the stuff under libraries
13:40:36 <mauke> a.k.a. liftM (word :) ask_for_words
13:40:54 <dons> ?unpl liftM (word :) ask_for_words
13:40:54 <lambdabot> liftM (\ a -> word : a) ask_for_words
13:41:19 <jyp> aes2: make -C libraries html then :)
13:41:24 <dons> mmm. not enough haskell news this week
13:41:29 <dons> we need more bloggers!
13:42:33 <metaperl> > sum [1,2,3,]
13:42:33 <lambdabot>  Parse error
13:44:26 <aes2> jyp, ok, and what about the out of memory exception I get when I try to build the pdf documentation?
13:44:44 <jyp> aes2: I'm out of help there, sorry.
13:44:55 <jyp> never built pdf.
13:45:08 <lisppaste2> metaperl annotated #33399 with "(phrase, fn) <- stats is not working" at http://paste.lisp.org/display/33399#3
13:46:01 <lisppaste2> jcreigh pasted "Simple regex engine" at http://paste.lisp.org/display/33401
13:46:11 <zeeeee> how do i write a haskell program that updates the fields of a data structure? i.e. as i read/parse input lines, i want to (conditionally) set his name and other attributes. preferably using static fields (i.e. not a hashtable)
13:46:22 <allbery_b> stats isn't an IO value, so you don't use <- with it.
13:46:51 <jcreigh> okay, right now I have "type Matcher = Match -> [Match]" but I'd like to be able to write "type Matcher = MonadPlus m => Match -> m Match", which is appearently not valid Haskell 98 but is accepted in GHC with -fglasgow-exts
13:47:16 <allbery_b> (that line would work in the List monad, but not in IO)
13:48:40 <metaperl> allbery_b - but I need to use both monads... what can I do?
13:48:56 <aes2> jyp: how to build the html user guide?
13:49:01 <zeeeee> say the input lines are either Name\nAge or Age. if the first line is "32" then i want to create a Person with no name and age 32. otherwise create a Person with the given name and age. but i have a bunch more such arbitrary parsing rules.
13:49:42 <jyp> aes2: I only built the libraries doc, sorry.
13:49:44 <mauke> :t forM_
13:49:45 <jcreigh> Is there some way to get a polymorphic type synonym in Haskell 98? Or should I even care, since I don't know of any other instance of MonadPlus that will work with my code other than the list Monad...
13:49:46 <lambdabot> Not in scope: `forM_'
13:49:58 <TSC> :t mapM_
13:49:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
13:50:00 <allbery_b> you don't really *need* to use it as a monad.  mapM_ is your friend here
13:50:22 * metaperl researches mapM_
13:50:54 <allbery_b> maps a monadic function (in your case putStrLn) over an arbitrary list
13:51:39 <allbery_b> and discards the result (which would be IO [()] in this case, which is fairly useless :)
13:52:32 <jcreigh> metaperl: mapM_ f = sequence_ . map f
13:53:09 <jcreigh> BTW, http://haskell.org/ghc/docs/latest/html/libraries/ is a great resource for looking up standard functions.
13:53:47 <mauke> flip mapM_ stats $ \(phrase, fn) -> putStrLn (phrase ++ " " ++ show (fn nums))
13:54:25 <jcreigh> isn't forM = flip mapM?
13:54:29 <mauke> yeah
13:56:44 <dmhouse> ?hoogle forM
13:56:44 <lambdabot> Text.Html.form :: Html -> Html
13:56:44 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
13:56:44 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
13:56:53 <dmhouse> Doesn't seem recent enough.
13:56:58 <dmhouse> ?type forM
13:57:00 <lambdabot> Not in scope: `forM'
13:57:03 <wolverian> hrm, where's that new vim haskell indent file?
13:57:50 <wolverian> ah, tokyoenvious. found it by guessing what the file contains and googling for it :)
13:59:47 <allbery_b> forM requires 6.6, doesn't it?
13:59:49 <allbery_b> ?version
13:59:50 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
13:59:50 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:00:15 <allbery_b> of course the hoogle db might be for 6.6...
14:02:20 <aes2> jyp: Your -C option also works for the other documentation.
14:03:22 <jyp> aes2: -C only changes directory before running make.
14:08:43 <aes2> jyp: I know. I don't just take every command and run it of IRC. I read the manual first.
14:09:39 <jyp> aes2: Sorry for implying something rude.
14:09:42 <dons> zeeeee: did you get an answer on your conditional update problem?
14:09:52 <dons> zeeeee: (I'd use record update functions)
14:09:55 <jyp> aes2: not my intention.
14:10:12 <lisppaste2> Botje pasted "Solution for H99 #63, any comments before I post it?" at http://paste.lisp.org/display/33402
14:10:16 <dons> i.e. deflt = T { a = 0 , b = 0 } ; .... ; parse n = deflt { a = n }
14:11:16 <dons> Cale: sounds like a job for HXT: http://useless-factor.blogspot.com/2006/12/on-second-thought.html
14:11:18 <lambdabot> Title: Useless Factor: On second thought...
14:11:59 <jcreigh> hmm, maybe I just don't understand type synonyms. If I have "type Foo = Bar -> Baz", and "f :: Foo -> Foo", f has type "(Bar -> Baz) -> Bar -> Baz", right? (not "Bar -> Baz -> Bar -> Baz")
14:12:46 <dons> :k Shows
14:12:47 <lambdabot> Not in scope: type constructor or class `Shows'
14:13:38 <dons> :k ShowS
14:13:40 <lambdabot> *
14:14:13 <dons> > let f :: ShowS -> Shows ; f _ = undefined in f
14:14:14 <lambdabot>  Not in scope: type constructor or class `Shows'
14:14:21 <dons> > let f :: ShowS -> ShowS ; f _ = undefined in f
14:14:23 <lambdabot>  <([Char] -> [Char]) -> [Char] -> [Char]>
14:14:30 <dons> jcreigh: there you go
14:14:36 <dmhouse> Is there a monad I can use that's basically Maybe with better error reporting?
14:14:41 <dons> type ShowS = String -> String
14:14:47 <dons> dmhouse: Error?
14:14:56 <dons> ?docs Control.Monad.Error
14:14:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
14:15:01 <dmhouse> I'm thinking I want a do-block where at each stage I compute something that might fail, and if it fails there I want the whole do-block to fail with an error message.
14:15:10 <dmhouse> _But_ I want said message to relate to the step where it failed.
14:15:15 <dons> dmhouse: since it provides exactly that :)
14:15:19 <jcreigh> dons: okay, thanks.
14:15:19 <dons> Right foo -- good
14:15:25 <dons> Left "something went wrong" -- failure
14:15:33 <allbery_b> Either String, which is a simple case of Control.Monad.Error
14:15:38 <dons> or fail "something went wrong" :: Either String Good
14:16:23 <jcreigh> am I the only one who thinks it's strange that Either's constructor's names suggest symmetry, but aren't?
14:16:29 <dons> > do x <- Right 1 ; y <- Right 2 ; fail "this was bad" ; fail "so was this" ; return (x+y) :: Either String Integer
14:16:31 <lambdabot>  Left "this was bad"
14:16:49 <allbery_b> Either can be used symmetrically, it just happens that one of the more common uses is asymmetric
14:17:05 <dmhouse> I'm just trying to work through how that applies in this instance.
14:17:32 <dons> > do x <- return 1 ; y <- return 2 ; if y > x then fail "this was bad" else return (x+y) :: Either String Integer
14:17:34 <lambdabot>  Left "this was bad"
14:17:39 <zeeeee> dons: no actually i just went ahead and wrote it in python...though i really want to know how to do this in haskell
14:17:50 <lisppaste2> zeeeee pasted "how to update data structures like so?" at http://paste.lisp.org/display/33404
14:18:10 * dmhouse has a cool idea
14:18:13 * dons has a look
14:18:50 <dmhouse> I have my failable functions which are in generic monads, mostly; however, they are out of my control and the fail message they give is likely useless.
14:19:16 <dmhouse> However, I could write a function (<||>) :: Maybe a -> String -> Either String a
14:19:29 <dmhouse> ... which is indeed just a special case of maybeToEither
14:19:56 <dmhouse> And then write the lines of the do-block like x <- mightFail <||> "friendly message"
14:20:12 <dmhouse> That's the kind of annotation structure I was reaching for in my mind, I guess.
14:20:20 <lisppaste2> zeeeee annotated #33404 with "some dummy data" at http://paste.lisp.org/display/33404#1
14:20:31 <jcreigh> oh, wait, even with -fglasgow-exts, type Matcher = MonadPlus m => Match -> m Match "doesn't work".
14:20:59 <dmhouse> jcreigh: why not?
14:21:23 * allbery_b found out yesterday that class restrictions on type declarations do strange things
14:21:31 <dmhouse> I thought anything was allowed in synonyms with -fglasgow-exts. They're like macros at the type level.
14:21:54 <jcreigh> GHC blows up with a couple of "Couldn't match expected type `Match -> m b' against inferred type `Matcher'" messages. (with this code: http://paste.lisp.org/display/33401)
14:22:03 <allbery_b> they're allowed, yes, but it starts doing things with fundeps that will drive you mad trying to comprehend them
14:22:17 <allbery_b> and that kind of thing (which I think is the same thing)
14:22:25 <dmhouse> jcreigh: what line?
14:23:33 * allbery_b was advised to drop the class annotation on his, and it all magically started working --- but he didn't have a monad in the annotation
14:24:29 <jcreigh> line 38 is the first error
14:24:47 <dmhouse> Which one's that? Lisppaste lacks line numbering.
14:24:56 <jcreigh> alt :: [Matcher] -> Matcher
14:24:56 <jcreigh> alt fs x = msum $ map ((return x) >>=) fs
14:25:04 <jcreigh> (sorry for the paste)
14:25:29 <dmhouse> That's all right, you won't annoy anyone with two lines' worth.
14:26:17 <dmhouse> (return x >>= ) === (`fmap` x)
14:27:09 <lisppaste2> dons annotated #33404 with "for zeeeee" at http://paste.lisp.org/display/33404#2
14:27:18 <dons> zeeeee: ^^
14:27:41 <dmhouse> jcreigh: but I don't see why you're using fmap (or return and >>=) at all
14:27:42 <dons> zeeeee: so it uses record labels to do the structure updates
14:27:49 <dmhouse> Isn't it just map ($ x) fs?
14:27:53 <dons> zeeeee: and read/show to write/read the data structure to disk
14:28:13 <dons> zeeeee: or you could roll your own fault-tolerant parser if you like, as you do in the python example
14:28:41 <allbery_b> parsec!
14:28:54 <lisppaste2> metaperl annotated #33395 with "need help creating data type" at http://paste.lisp.org/display/33395#1
14:29:33 <dmhouse> jcreigh: try alt fs x = msum $ map ($ x) fs
14:29:43 <dons> zeeeee: i'm interested as to how/why you knew how to do this in python, but not in haskell? do we need a tutorial?
14:30:15 <dons> any opportunty where a solution is fairly simple in haskell, but people don't know how to proceed, means we need more docs for that area, I suspect
14:30:30 <metaperl> YAHT is turning out t obe a great book... people need to read that I think
14:30:42 <dons> mmm. a couple of tuts on disk serialisation would be useful..
14:30:49 <dons> read/show versus the binary libs
14:31:05 <zeeeee> dons: hmm..let me read through it, and then i might better understand what the blocking issue for me was
14:31:08 <dons> grr. the wost think about xmas vacation: bad coffee for a week
14:31:19 <metaperl> can someone help me with this data def... data Tuple (a,b,c,d) = One a | Two (a,b) | Three (a,b,c) | Four (a,b,c,d)
14:31:20 <dmhouse> jcreigh: am I talking to myself here or are you just busy for a minute? :)
14:31:22 <dons> zeeeee: ok great :) let me know if i slipped in any magicks there
14:31:33 <jcreigh> dmhouse: hang on a sec
14:31:35 <dons> metaperl: why duplicate the tuple in your custom type?
14:31:39 <allbery_b> metaperl: fst and snd won't work there.  (a) you're not passing them actual tuples, but your wrapped tuples; (b) they only work on 2-tuples
14:31:50 <dons> why not: data T a b c d = A a | B a b | C a b c | D a b c d
14:32:22 <allbery_b> the right way to do it is pattern matching, but you'll need a case for each constructor
14:32:23 <lisppaste2> jcreigh annotated #33401 with "GHC errors (with polymorhpic type synonym)" at http://paste.lisp.org/display/33401#1
14:34:18 <jcreigh> dmhouse: I get almost exactly the same error message with "alt fs x msum $ map ($ x) fs". (I don't *quite* see how the two are equivilent, let me think about that for a bit.)
14:34:42 <dmhouse> jcreigh: they're not equivalent, one involves lifting the function, one doesn't.
14:34:49 <zeeeee> dons: ok, i think the problem is that the updates i'm interested in is part of the parsing, which the last annotation doesn't do...the update syntax also seems fairly verbose, though i can probably live with that
14:34:59 <dmhouse> map (`fmap` x) fs is equivalent to what you wrote, though.
14:35:31 * Botje restarts his wrestling with the State monad
14:35:34 <Botje> here goes nothing ..
14:35:40 <dmhouse> \fs x -> map (`fmap` x) fs :: [a -> b] -> m a -> [m b]
14:35:54 <dmhouse> \fs x -> map ($ x) fs :: [a -> b] -> a -> [b]
14:36:04 <dmhouse> fmap is like monadic application, if you like.
14:36:14 <zeeeee> dons: i still have very little idea how to write the parsing piece. i guess the problem is not so much in updating the data structure (as i mistakenly thought) as it is just how to maintain state in the parser.
14:36:23 <lisppaste2> metaperl annotated #33395 with "trying to make a function pattern-match on different type constructors" at http://paste.lisp.org/display/33395#2
14:36:41 <zeeeee> dons: e.g., how the parser treats future lines depends a great deal on what it has already seen
14:36:45 <mauke> metaperl: use more parens
14:37:04 <metaperl>     Equations for `tuple1' have different numbers of arguments
14:37:08 <metaperl> dont matter
14:37:33 <allbery_b> right, you need parens to tell it it's all one argument:  tuple1 (A a), tuple1 (B a _), ...
14:37:47 <metaperl> oh
14:37:51 <allbery_b> because it's a single argument which you're peeking inside of
14:38:17 <allbery_b> otherwise you're telling it to look for a type constructor parameter followed by some values
14:38:17 <jcreigh> hmm...
14:39:06 <zeeeee> dons: so i was confusing the 2 issues; as for updating data structures, that seems straightforward enough - i imagine that anything fancier would need MVars
14:39:30 <zeeeee> (i should say 'more concise' instead of 'fancier')
14:39:54 <dmhouse> jcreigh: you have your list of matcher functions and a match. You apply that match to all the matcher functions (map ($ x) fs), giving you [m Match], then combine them using msum.
14:40:48 <dmhouse> jcreigh: but can I see this new error message you get using my version/
14:41:01 <jcreigh> "can" or "can't"?
14:41:16 <dmhouse> 'can I', and the slash was meant to be a '?'.
14:41:31 <allbery_b> 'would you please show it to him'
14:41:34 <jcreigh> ah.
14:42:40 <lisppaste2> jcreigh annotated #33401 with "errors with dmhouse's version" at http://paste.lisp.org/display/33401#2
14:42:55 <jcreigh> I don't think it's related to your code...
14:43:58 <dmhouse> ?hoogle msum
14:43:59 <lambdabot> Monad.msum :: MonadPlus a => [a b] -> a b
14:43:59 <lambdabot> Control.Monad.msum :: MonadPlus m => [m a] -> m a
14:44:42 <jcreigh> It's looking more and more like the answer is "just restrict it to the List monad and be happy" (as everything works fine with type Matcher = Match -> [Match])
14:45:02 <dmhouse> Oh, I think I might know what's going on.
14:45:12 <jcreigh> oh?
14:45:37 <dmhouse> The expanded type of your function is [MonadPlus m => Match -> m Match] -> (MonadPlus m => Match -> m Match)
14:45:57 <dmhouse> Which is in fact more general than your implementation, which has the two
14:45:57 <dmhouse> ms unifying.
14:46:42 <dmhouse> In other words, you've written a function with type MonadPlus m => [Match -> m Match] -> Match -> m Match, but that doesn't seem expressable using your synonym.
14:47:18 <dons> zeeeee: if you really wanted a mutable, threadsafe update?
14:47:25 <dmhouse> I might be wrong here, so try putting the type signature as that last one and don't use the synonyms, and see where that gets you.
14:49:48 <jcreigh> yeah, that seems to work for "alt" (there's still other errors, but I suspect they could be fixed in a similar manner)
14:49:59 <jcreigh> dmhouse++ Thanks so much for all your help
14:50:25 <jcreigh> I think I'll just restrict it to the list monad after all.
14:50:45 <dmhouse> jcreigh: do you understand the error? It's quite esoteric.
14:51:53 <lisppaste2> metaperl annotated #33395 with "Either can return Left or Right, but I need Up and Down also! Dont say I didn't try" at http://paste.lisp.org/display/33395#3
14:52:01 <jcreigh> I think so...the probably is I'm trying to take a list of functions that act on one instance of MonadPlus, and return a function and acts on one instance of MonadPlus, but *not nessesarily the same one*
14:52:12 <jcreigh> when in fact they have to be the same one. (I think)
14:52:19 <jcreigh> *"the problem"
14:52:29 <dmhouse> With your previous synonym, [MonadPlus m => Match -> m Match] -> (MonadPlus m => Match -> m Match), you were basically promising 'Give me a list of functions that take a Match and return a Match in a MonadPlus, and I'll give you a function that takes a Match and returns a Match in any MonadPlus you like.
14:52:42 <dmhouse> Whereas the way you wrote the function means they actually have to be the same one.
14:52:51 <dmhouse> I.e. the problem is that the two ms don't share scope in the signature.
14:53:20 <jcreigh> right... if I had "type Matcher m = Match -> m Match" and then "alt :: MonadPlus m [Matcher m] -> Matcher m", I think it would work.
14:53:39 <jcreigh> dmhouse: anyway, I've got to run now, but thanks again for all your help.
14:53:40 <dmhouse> Yep.
14:53:45 <dmhouse> Sure, no problem.
14:54:44 <metaperl> Please help . I'm trying to write a function which has to return 1 of 4 different types: http://paste.lisp.org/display/33395#3
14:54:50 <metaperl> it's in YAHT
14:55:10 <zeeeee> dons: well, it's just that i've used concurrent haskell before so that's the only way to mutate state that i know of
14:55:58 <dmhouse> metaperl: you've got the Either bit right.
14:56:19 <dmhouse> Is the rtn function going to be this function described in the comment?
14:56:29 <dmhouse> For starters, its type signature doesn't make sense.
14:56:31 <metaperl> dmhouse - yes
14:56:32 <allbery_b> metaperl: nested Eithers
14:56:37 <Saizan> metaperl: rtn :: T -> (Either a (Either (a,b) (Either (a,b,c) (a,b,c,d))))
14:57:06 <metaperl> dmhouse and allbery_b - I just found out YAHT has answers online. Thanks also Saizan
14:57:29 <dmhouse> Saizan: or you could do it metaperl's way, rtn :: T -> (Either (Either a (a, b)) (Either (a, b, c) (a, b, c, d)))
14:57:51 <dmhouse> It's the difference between a + (b + (c + d)) and (a + b) + (c + d).
14:58:12 <dmhouse> I.e. they're isomorphic, the only difference would be how you construct the values (constructor order).
14:58:34 * dmhouse wishes Either was called (+)
14:58:36 <dons> zeeeee: but you don't necessarily want to really mutate state, in this problem, do you?
14:58:41 <Saizan> oh yes, i just skipped the data definitions :)
14:59:11 <dons> a non-destructive update works fine
14:59:15 <zeeeee> dons: no, just want to know how to write the stateful parser
14:59:37 <dons> ah right. running in a State monad might be good then.
14:59:52 <dmhouse> > do (a, b) <- Just (5, 6); return (a + b) :: Maybe Int
14:59:53 <dons> so you want to parse based on the already-read state?
14:59:53 <lambdabot>  Just 11
15:00:02 <zeeeee> dons: yeah
15:00:03 <dmhouse> > do (a, b) | a < 10 <- Just (5, 6); return (a + b) :: Maybe Int
15:00:04 <lambdabot>  Parse error
15:00:16 <dmhouse> Why doesn't that work? I thought you were allowed guards anywhere you were allowed patterns.
15:00:25 <dons> yeah, so you need to carry around your parse state, either via a threaded state value, or a monadic state
15:00:39 <dons> using true destructive updates is overkill, and puts you in IO
15:01:02 <zeeeee> dons: is this like "get/put (all,my,state,vars)"?
15:01:10 <dons> yeah
15:01:49 <dons> > flip runState 0 $ do let v = read "5" ; n <- get ; if n == 0 then put v else put (v+n) ; return "done parsing"
15:01:49 <lambdabot>  Parse error
15:02:04 <dons> > flip runState 0 $ do let v = read "5" in do n <- get ; if n == 0 then put v else put (v+n) ; return "done parsing"
15:02:06 <lambdabot>  ("done parsing",5)
15:02:08 <zeeeee> dons: i'm wondering if there's something similar to the state monad, but which explicitly holds >1 value, and uses (static) names to specify which value (similar to a hash table, but not dynamic names)
15:02:39 <dons> can you give an example?
15:02:40 <zeeeee> and not necessarily in IO
15:03:01 <dons> sounds like your describing a type to use in the State monad
15:03:15 <zeeeee> put name "Joe"; put age 32
15:03:33 <dons> data T = T { name :: String, age :: Int } ?
15:03:43 <allbery_b> sounds like Control.Monad.Reader to me
15:03:55 <zeeeee> but then that requires me to re-specify everything when i want to update a single value, right?
15:04:01 <dons> zeeeee: nope
15:04:09 <dons> and example:
15:04:40 <dons> runState (T "none" 0) $ do let v = read "5" ; modify $ \s -> s { age = v }
15:04:55 <dons> so that just updates the age field of the state
15:05:11 <dons> this is what I meant earlier about using records to update individual fields
15:05:36 <dons> given a value 'v' of type T, you can update a field:   v { fieldname = 7 }
15:05:41 <zeeeee> holy cow
15:05:53 <zeeeee> i didn't know about this (very handy) syntactic sugar
15:06:11 <dons> yeah, it sounds like exactly what you need, I think
15:06:15 <allbery_b> of course, if you want to look at it, you still need to get the whole thing
15:06:22 <dons> allbery_b: ?
15:06:32 <dons> you could look at individual fields,   age v
15:06:36 <allbery_b> (well, sorta:  (T _ s) <- get
15:06:39 <dmhouse> gets is your friend :)
15:06:42 <dmhouse> ?hoogle gets
15:06:43 <lambdabot> Control.Monad.State.gets :: MonadState s m => (s -> a) -> m a
15:06:43 <lambdabot> Random.getStdGen :: IO StdGen
15:06:43 <lambdabot> Random.getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
15:06:46 <dons>  s <- gets age
15:06:56 <allbery_b> ah.  missed that looking through State
15:07:10 <dmhouse> There's an asks in Reader too.
15:07:12 <dons> yeah, using record selects as arguments to gets is a useful trick
15:07:22 <allbery_b> asks I knew about
15:07:23 <dons> s/selectors/
15:07:30 <dmhouse> dons: I believe that's how they were defined, the 's' stands for 'selector', I guess.
15:07:34 <zeeeee> this is like when i discovered the @ the other month
15:07:40 <dons> hehe
15:07:45 <zeeeee> x@(y:z)
15:07:52 <dmhouse> Good, isn't it :)
15:08:11 <dons> zeeeee: yeah, destructively updated fields in python == state monad + records
15:08:26 <dmhouse> I need a function (a -> Bool) -> Maybe a -> Maybe a.
15:08:38 <dmhouse> That ensures the condition is met on the value in the Maybe.
15:09:15 <dmhouse> It sounds a bit like \f m -> m >>= guard . f, but guard returns Maybe ().
15:09:33 <dons> guard p m | Just n <- m && p n = m | otherwise = Nothing -- ?
15:10:04 <dons> that's using pattern guards to take apart the Just value
15:10:09 <zeeeee> dons: is there a shorthand to modify $ \s -> s { age = v }
15:10:11 <dmhouse> Sure.
15:10:16 <dmhouse> zeeeee: sadly not.
15:10:20 <dons> zeeeee: nope, a pity though
15:10:29 <dons> since it would be nice to have some kind of first class labels:
15:10:43 <dons> modify { age => v } or some such
15:10:57 <dons> the record system could be improved :)
15:11:16 <dmhouse> The record system sucks.
15:11:18 <dons> i suppose you coudl write:
15:11:28 <dons> modify (setAge v)
15:11:33 <zeeeee> dons: what's this record system you keep referring to? i thought  you meant the "Records" in my app
15:11:34 <dons> where setAge v s = s { age = v }
15:11:46 <dons> zeeeee: ah, haskell 'records'
15:11:50 <dons> i.e. data types with field names
15:11:50 <dmhouse> But there's no clear replacement. Everyone has their favourite record system.
15:11:57 <zeeeee> dons: aren't those just functions?
15:11:58 <dons> and the associated update/selector/label syntax
15:12:14 <dmhouse> zeeeee: they're more than just functions, as you can use them in patterns, too.
15:12:15 <dons> zeeeee: yeah, and the special update synatx: s { f = x }
15:12:23 <dmhouse> dons: and patterns.
15:12:28 <dons> and the labels are selector functions, and so on
15:12:32 <zeeeee> ok, gotcha
15:12:39 <dmhouse> f (R { a = x }) = x + 1
15:12:40 <allbery_b> but the update syntax isn't first class, darn it
15:12:52 <dons> yeah, labels aren't first class
15:12:58 <Saizan> define and use this modify' sel v = \s -> s { sel =v}  won't work?
15:13:14 <dmhouse> Saizan: no, the labels aren't first class.
15:13:22 <dmhouse> (First class means you can pass them around.)
15:13:37 <zeeeee> dmhouse: thanks for that clarification :)
15:13:56 <Saizan> ooh, so they are syntactic..
15:13:58 <dmhouse> The functions are, sure, but you're using it on the LHS of an 'a = b', which means you're using it as a label, not a selector function, in this instance.
15:16:33 <zeeeee> is this something that O'Haskell addresses?
15:16:47 <dmhouse> Like I said, everyone has their pet favourite record system.
15:16:51 <zeeeee> (or makes irrelevant)
15:16:58 <dmhouse> Probably O'Haskell has a way of dealing with this kind of problem, yeah.
15:17:40 <dmhouse> Another problem is that record labels have to be program-wide unique, there's no namespacing, which means you get ad-hoc namespacing in the form of hungarian notation like pstContents and cnvTitle.
15:18:25 <dmhouse> Or it might just be module-wide, can't remember.
15:18:27 <zeeeee> dmhouse: yeah i was frustrated a bit by that at some point
15:19:15 <allbery_b> module-wide ulness you export the tagged constructor
15:19:56 <allbery_b> (and even then you could presumably import qualified --- but you'd have to know to do so)
15:20:38 <dmhouse> ?hoogle boolToMaybe
15:20:39 <lambdabot> No matches found
15:20:51 <dmhouse> Grr.
15:21:19 <dons> there's a couple of good improved records proposals around, but no clear winner
15:21:34 <dons> and its a huge design space, so gaining consensus is hard
15:22:06 <dmhouse> We really could do with a better system for Haskell', but I doubt we'll have it.
15:22:08 <dons> probably if Daan wanted to champion his proposal, it could have got up. but there's no record system champion in h'
15:23:42 <dmhouse> ?hoogle ap
15:23:43 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
15:23:43 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
15:23:43 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
15:24:15 <dmhouse> How does it work in Reader again?
15:24:30 <dmhouse> Sxy = Sx(yx), yeah?
15:24:48 <dmhouse> Err, that was nonsensical.
15:24:54 <dmhouse> Sxyz = xz(yz)
15:34:47 <zeeeee> btw, is the parser i was trying to write something that parsec would be able to help with?
15:35:31 <deadbeef> http://www.geogreeting.com/view.html?zbaGycjw+iK3U2O*+cOQU.j3+Ka
15:35:33 <lambdabot> Title: You have received a geoGreeting!
15:35:43 <Martus> quit
15:37:42 <dons> deadbeef: please don't dump spammy links like that. you've been asked a couple of times before not to do that.
15:38:05 <deadbeef> it's not spammy
15:38:07 <deadbeef> it's a greeting
15:38:08 <dmhouse> > succ '9'
15:38:09 <lambdabot>  ':'
15:38:16 <dmhouse> > prec '0'
15:38:16 <lambdabot>  Not in scope: `prec'
15:38:21 <dmhouse> > pred '0'
15:38:22 <lambdabot>  '/'
15:38:33 <dmhouse> Wonderful, why aren't the numbers next to the letters?
15:38:51 <bd_> > map (take 5) $ map (\n -> [n..]) ['a'..]
15:38:53 <lambdabot>  ["abcde","bcdef","cdefg","defgh","efghi","fghij","ghijk","hijkl","ijklm","jk...
15:38:56 <dmhouse> > (ord '0', ord 'Z', ord 'z')
15:38:57 <lambdabot>  (48,90,122)
15:39:17 <allbery_b> because it's based (ultimately) on the ASCII collating sequence.  if you think that's bad, try EBCDIC somtime
15:39:31 <dmhouse> allbery_b: yeah, I meant in ASCII
15:39:40 <dmhouse> > ord '9'
15:39:41 <lambdabot>  57
15:39:44 <dmhouse> > ord 'a'
15:39:45 <Philippa> deadbeef: the two aren't mutually exclusive
15:39:45 <lambdabot>  97
15:40:02 <Philippa> be glad IRC doesn't do the <blink> or <marquee> tags...
15:40:21 <allbery_b> (in EBCDIC not onlay are the numbers not next to the letters, but the letters are in 3 disjoint blocks IIRC.  6 if you include lowercase)
15:40:22 <sorear> dmhouse: IMO it's very nice, look at it in hex - 3 is 33, 6 is 36...
15:40:34 <dmhouse> bd_: you can unify the two maps.
15:40:48 <dmhouse> > map (take 5 . enumFrom) ['a'..]
15:40:49 <lambdabot>  ["abcde","bcdef","cdefg","defgh","efghi","fghij","ghijk","hijkl","ijklm","jk...
15:40:53 <bd_> dmhouse: true, it was just sort of an afterthought :)
15:41:47 <dmhouse> > map (\n -> take 5 $ iterate succ n) ['a'..]
15:41:48 <lambdabot>  ["abcde","bcdef","cdefg","defgh","efghi","fghij","ghijk","hijkl","ijklm","jk...
15:42:05 <dmhouse> enumFrom = iterate succ, nice.
15:42:57 <dmhouse> It's a lovely example of Haskell's function definitions being the totally natural ones. "To enumerate from a value, you iterate taking successors starting from that value"
15:44:54 <bd_> @pl let f l = l:f (tail l) in f
15:44:55 <lambdabot> fix (ap (:) . (. tail))
15:45:11 <bd_> > take 5 $ map (take 5) . fix (ap (:) . (. tail)) [1..]
15:45:12 <lambdabot>  Couldn't match `[[a]]' against `a2 -> [[a1]]'
15:45:17 <bd_> > take 5 $ map (take 5) $ fix (ap (:) . (. tail)) [1..]
15:45:18 <lambdabot>  [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]]
15:49:26 <bd_> @pl let f [] = []; f l = l:f (tail l) in f
15:49:27 <lambdabot> (line 1, column 7):
15:49:27 <lambdabot> unexpected "["
15:49:27 <lambdabot> expecting pattern or "="
15:54:48 <zeeeee> something i haven't seen but which would help 'advanced beginners' learn a language (not just haskell) is a piece about what you *can't* do 'nicely' in the language (non-contrived problems that another language does better). this would help us understand the limitations and open design areas.
15:56:27 <zeeeee> something else which would be nice is a list of 'non-problems' - things which may appear to be unpleasant to do in haskell, but - as it turns out - you're just thinking of the problem at the wrong level, need to take a step back, and approach it this other way, which would presumably be much cleaner/etc.
15:57:37 <Saizan> a use guide/design patterns?
15:58:14 <zeeeee> Saizan: but with design patterns, you know exactly how to think of the problem, whereas this provides you with a different 'frame of thought'
16:02:14 <dmhouse> Any Markdown implementations in Haskell?
16:02:22 <dmhouse> I specifically need Markdown -> HTML.
16:03:17 <dons> dmhouse: yeah, there is
16:03:27 <dons> check the libraries/xml page, I think. on haskell.org
16:03:38 <dons> there's a lib for converting xml/html/markdown/...
16:03:49 <dmhouse> pandoc?
16:04:34 <dmhouse> That looks like it'll do LaTeX maths as well, which is a great bonus,
16:04:36 <dons> yeah, that's the one
16:04:37 <dons> http://sophos.berkeley.edu/macfarlane/pandoc/
16:04:39 <lambdabot> Title: Pandoc - Pandoc
16:04:42 <dons> ?where+ pandoc http://sophos.berkeley.edu/macfarlane/pandoc/
16:04:43 <lambdabot> Done.
16:08:13 <allbery_b> > let ck p msg v = liftM p v >>= \r -> if r then v else fail msg in ck (== 7) "assert: v == 7" (Just 8)
16:08:14 <lambdabot>  Nothing
16:08:49 <allbery_b> > let ck p msg v = liftM p v >>= \r -> if r then v else fail msg in ck (== 7) "assert: v == 7" (Right 8)
16:08:50 <lambdabot>  Add a type signature
16:08:54 <bd_> > (let ck p msg v = liftM p v >>= \r -> if r then v else fail msg in ck (== 7) "assert: v == 7" (Just 8)) :: Either String Int)
16:08:55 <lambdabot>  Parse error
16:08:59 <bd_> > (let ck p msg v = liftM p v >>= \r -> if r then v else fail msg in ck (== 7) "assert: v == 7" (Just 8)) :: Either String Int
16:09:00 <lambdabot>  Couldn't match `Either String' against `Maybe'
16:09:04 <bd_> oh, Just
16:09:27 <allbery_b> > let ck p msg v = liftM p v >>= \r -> if r then v else fail msg in ck (== 7) "assert: v == 7" (Right 8 :: Either String Int)
16:09:28 <lambdabot>  Left "assert: v == 7"
16:13:00 <zeeeee> dmhouse: pandoc!
16:13:12 <dmhouse> zeeeee?
16:13:13 <zeeeee> oh wait...i need to scroll down
16:13:17 <dmhouse> :)
16:16:21 <dons> "putty.exe has experienced an error. we are sorry for the inconvenience" ah, holiday net access
16:16:40 <dons> "send a report of the error to microsoft?" "don't send"
16:16:44 * dons pines for openbsd
16:16:53 <mbishop> Hmm, this "Curry" language looks familiar heh
16:17:11 <dons> yeah, the muenster curry compiler's even written in haskell :)
16:19:20 <jlouis> dons, openbsd rocks
16:19:30 <jlouis> dons, though I feel Ubuntu is easier to work with
16:20:17 <wolverian> I am unclear why there are christmas carols playing in my apartment at 2am.
16:21:06 * dmhouse is going to buy himself a new keyboard in the sales, yay :)
16:25:36 <sorear> 16:52:25 <allbery_b> huh.  thanks sorear++
16:26:14 <sorear> ^^^ I wonder if there is a usable compromise on the beginning-of-line-check
16:38:49 <allbery_b> hm.  most of the karmabots I know of accept it anywhere in a line, as long as it's distinct
16:38:55 <allbery_b> sad
16:39:05 <allbery_b> sorear++
16:42:28 <sorear> distinct?
16:42:39 <dons> well, its a 1 line patch....
16:42:45 <dons> if anyone cares enough :)
16:42:46 <sorear> We also have the problem of (++) being catenation
16:43:10 <sorear> It is *so* easy to fix I naively assumed it was broken for a reason.
16:43:18 <dons> yeah, most channels don't have so much code in channel, let alone ++
16:43:37 <dons> sorear: yeah, if you want to submit a patch, go for it
16:46:32 <allbery_b> well, the "distinct" proviso amounts to it being a problem only if you're in the habbit of writing concatenation as "x++ y"
16:46:43 <allbery_b> ^bb^b
17:21:50 <sorear> 'main = interact $ unlines . Prelude.concatMap tails $ lines'  <-- was a much slower 6 line perl script
17:24:06 <Saizan> ?type interact $ unlines . Prelude.concatMap tails $ lines
17:24:07 <lambdabot>   Expecting a function type, but found `a'
17:24:07 <lambdabot>    Expected type: [[Char]]
17:25:06 <sorear> I wonder what I mis-entered - GHC --make -O2 liked it
17:25:41 <dons> sorear: is it better with Data.ByteString.interact, I wonder?
17:25:45 <sorear> (prelude was imported ((.), ($), concatMap), everything else was in scope from Data.ByteString.Lazy.Char8)
17:25:49 <dons> ah ok
17:26:03 <sorear> well, it's shorter
17:26:21 <dons> the .Lazy version often has better space usage
17:26:34 <sorear> curiously, even though the input is 200MB of irc logs, my hdd light is only flashing
17:27:12 <sorear> My disk has sustained 100MB/s throughput in the past - *only 50 times slower than RAM*
17:28:10 <sorear> (hey, I've 70GB of free space... let's see how GNU sort likes largefiles)
17:28:44 <sorear> Yes, I *am* making a suffix array from the #haskell logs.
17:29:21 <augustss> sorear: wow, sounds like it'll take up some disk space
17:29:49 <sorear> sort -u should shrink it a good deal
17:30:13 <dons> :)
17:30:28 <dons> I'd be interested in any analysis of the lazy bytestring performance
17:30:28 <augustss> true.  can sort handle files larger than memory?
17:30:46 <dons> we've tuned it fairly well, I think, for >gigabyte data streams
17:30:51 <sorear> yes
17:30:59 <dons> so if you could get reasonable results from that, it'd be nice to see
17:31:05 <sorear> GNU sort uses tempfiles and external merge sort
17:31:19 <sorear> well, said script is at 85% CPU
17:31:29 <sorear> oooh, finished...
17:31:36 <sorear> 9.4GB output
17:31:39 <augustss> just like good ole unix sort
17:32:35 <augustss> i wonder how that sort would perform if written in haskell with lazy bytestrings
17:33:04 <sorear> This hdd has *extremely* good bulk throughput - 100Mbytes/s with dd if=/dev/zero
17:33:30 <sorear> For comparison, memtest86+ reports 5000MBytes/s for my main memory
17:33:44 <sorear> (and something like 500000MBytes/s for L2)
17:34:00 <augustss> but sorting doesn't do sequential disk access
17:34:20 <augustss> 100 MB/s is pretty good
17:36:47 <sorear> If apples-and-oranges is your thing, I've read GNU's sort.c and it suffers from an impressive lack of specialization.
17:37:31 <sorear> Have you ever heard of the -k option?  I learned about it from seeing that sort parses every line, even when comparing whole lines would do.
17:45:46 <dons> shankys_: so you're doing commercial web dev in haskell?
17:46:03 <shankys_> dons: Yup
17:46:12 <shankys_> dons: Probably the only one...
17:46:20 <dons> shankys_: would you like to add any details to the 'Haskell in Industry' page?
17:46:31 <dons> http://www.haskell.org/haskellwiki/Haskell_in_industry
17:46:33 <lambdabot> Title: Haskell in industry - HaskellWiki
17:46:43 <shankys_> dons: Not yet, I want to actually launch first
17:46:49 <dons> shankys_: there's a startup in San Francisco doing web dev in WASH too
17:46:57 <dons> one of their devs was here a few days ago
17:46:58 <shankys_> dons: Really? Who?
17:49:17 <dons> http://braintreehemp.com.au <-- was their demo site
17:50:03 <dons> it was abz64 talking about it , on the 19th , a few days ago
17:50:14 <dons> they're looking to add ajax support to wash as well
17:50:27 <shankys_> dons: Interesting...
17:50:49 <shankys_> dons: We're not using WASH actually. We opted to build our own framework.
17:50:58 <dons> right, so I see. very interesting
17:51:02 <dons> based on any existing model?
17:51:17 <shankys_> dons: Network.FastCGI, Text.XHtml, Database.HDBC
17:51:18 <dons> see the 'WASHsubmit' buttons on that site, btw? :)
17:51:24 <dons> shankys_: ah sounds good
17:51:29 <dons> any HXT or other xml stuff?
17:51:30 <shankys_> dons: We took that as our starting point
17:51:38 <shankys_> dons: HXT?
17:52:00 <dons> oh, xml toolkit for haskell, maybe its not relevant to what you're doing
17:52:42 <shankys_> dons: Yeah, I haven't heard of that before. For AJAX, we're mostly writing wrappers for Prototype and Scriptaculous which Ruby on Rails uses.
17:53:00 <jethr0> hi dons, do you have any idea why the arbitrary/dynamic precision reals aren't in the std libraries?
17:53:20 <sorear> dons: what do I need to be aware of to build a hs-plugins lambdabot?  I've installed 6.4.2 + hs-plugins, compiled a non-plugins lb in the same dir, copied BotPP into ., replaced the cabal-file, reconfigured, rebuild (without errors), ran, and got a dynamic linker error.
17:53:38 <jethr0> would be so nice to be able to use them as i do "Integer" w/o external libraries...
17:53:41 <dons> jethr0: I don't know why they're not there, other than that they might be hard. check with lennart/augustss , he did a lot of the numerics stuff
17:53:52 <jethr0> i will, thx
17:53:58 <dons> sorear: you need 6.4.2 + hs-plugins. use the std cabal file and build fresh
17:54:07 <dons> no need for all the weirdness, afaik
17:54:15 <dons> (try a local darcs get into a new dir, for an easy clean)
17:54:20 <augustss> well, they don't fit so great into the numerical classes, but i don't think that's why
17:54:36 <dons> shankys_: there's a few existing ajax libs, too. their's the ajax stuff from chalmers, for one.
17:54:44 <augustss> i think it's simply that no one has put in the effort
17:54:46 <dons> shankys_: check the 'libraries and apps' page on haskell.org
17:55:56 <augustss> jethr0: do you have some particular library you'd like to see added?
17:56:06 <jethr0> augustss: well, as i'm reading about dynamic vs abitrary and after having thought about it myself a bit, there are some trade-offs to be made...
17:56:42 <augustss> jethr0: I have some modules for real numbers
17:56:48 <jethr0> but some kind of standard would be nice that could even switch transparently between IEEE fp, rationals and arbitrary/dynamic precision
17:57:05 <augustss> based on David Lester's work
17:57:08 <jethr0> augustss: i'm reading about the available libraries on the wiki right now.
17:57:14 <sorear> so, I *shouldn't* use the .plugins cabalfile?
17:57:28 <dons> sorear: ah yes. maybe... been a while since I checked
17:57:43 <dons> sorear: so yes, you'll need the .plugins file, but ported back to 6.4.2 (I think)
17:57:45 <jethr0> just wondering, no urgent need, but "doubles" can be so ugly in their finity sometimes
17:57:56 <augustss> http://www.augustsson.net/Darcs/CReal/
17:58:00 <jethr0> thx
17:58:01 <lambdabot> Title: Index of /Darcs/CReal
17:58:06 <augustss> all fp is ugly
17:58:26 <dons> augustss: mmm. is that linked from haskell.org anywhere? or is it a top secret underground lennart-dev project?
17:58:29 <SamB_XP> yeah, obviously you should use an infinite-precision representation
17:58:39 <jethr0> i was wondering how (1/(1/3)) would be evaluated with dynamic precision and if it would ever return 3.0 :)
17:58:42 <augustss> ummmm, i've not added any links
17:59:02 <dons> maybe it should be findable from the 'numerics' library category?
17:59:03 <augustss> jethr0: that depends on what representation you pick
17:59:16 <augustss> dons: yes, it should
17:59:24 <jethr0> augustss: that's what i feared. so there's no one-fits-all solution then
17:59:42 <augustss> jethr0: what do you mean by it returning 3, btw?
17:59:54 <augustss> (1/(1/3)) does return 3
18:00:05 <SamB_XP> > 1/(1/3)
18:00:06 <lambdabot>  3.0
18:00:15 <SamB_XP> hmm.
18:00:20 * SamB_XP is suspicious
18:00:28 <augustss> but since equality is not decidable for real numbers you can't necessarily test if it returns 3
18:00:57 <SamB_XP> which also makes comparison tricky!
18:01:01 <augustss> yep
18:01:06 <Saizan> it gets printed as 3, but i don't think it's a 3.0 inside there..
18:01:08 <jethr0> maybe i picked a stupid example, but there certainly are cases where you need infinite (and not just mere arbitrary/dynamic) precision to get the correct result
18:01:14 <SamB_XP> because you never know if it is safe to compare two numbers!
18:01:18 <sorear> comparison of *unequal* numbers is decidable in reals
18:01:30 <SamB_XP> sorear: yes ;-)
18:01:32 <sorear> comparison of *equal* numbers will never terminate
18:01:35 <SamB_XP> yeah
18:01:38 <augustss> sorear: yes.  but how do you know? :)
18:01:38 <SamB_XP> thats the problem
18:01:47 <SamB_XP> you can't know whether it is safe to attempt!
18:01:51 <jethr0> sorear: that doesn't really help :)
18:01:52 <augustss> sorear: might not terminate
18:02:04 <sorear> unless the system does something clever like symbolic manipulation
18:02:09 <SamB_XP> augustss: if you are using streams, it won't terminate!
18:02:15 <sorear> and even then you get a yes/no/maybe
18:02:32 <sorear> streams won't tell you exactly equal
18:02:35 <jethr0> well, you can always compare (x==y) and (x==y+1) in parallel and wait for one of them to terminate :)
18:02:37 <SamB_XP> that is better than True/False _|_
18:03:00 <sorear> but, they can (decidable, both ways) tell you approximate equality for all nonzero epsilon
18:03:01 <SamB_XP> jethr0: that helps how?
18:03:08 <augustss> SamB_XP: that's why i said might
18:03:09 <jethr0> not at all
18:03:47 <sorear> ?hoogle mergeIO
18:03:48 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
18:03:48 <lambdabot> Control.Concurrent.nmergeIO :: [[a]] -> IO [a]
18:03:54 <SamB_XP> augustss: if you are using a potentially-finite representation, sometimes you might be able to get a True result...
18:03:59 <augustss> well, it just show that you should not make control decisions based on real numbers.  and the same is true of floating point
18:04:29 <SamB_XP> yeah
18:04:36 <SamB_XP> unless you are okay with fuzzy answers
18:04:54 <jethr0> augustss: is there an alternative? at least inequality comparisons seems like a necessary evil at times
18:05:04 <augustss> and if you have discontinuities you can be arbitrarily far off
18:05:17 <SamB_XP> well, you have to be willing to have a "gray zone"
18:05:26 <sorear> most of the time: fp and reals are accurate.  sometimes: fp is silently wrong, reals give no answer at all
18:06:10 <jethr0> sorear: i don't quite believe in your "most of the time" statement. not even 1/10 is representable losslessly in IEEE fps
18:06:20 <augustss> i agree
18:06:26 <SamB_XP> mmm.
18:07:31 <sorear> yes/no is more often correct... esp. since you can't compare real and fp on 'exact answer'
18:08:54 <Saizan> i=0.0; while (i!=1) { i +=0.1 } == <loop>
18:09:02 <SamB_XP> you will never write a raytracer without making control decisions based on comparison of what are supposed to represent real numbers...
18:09:29 <jethr0> right
18:10:12 <sorear> raytracers don't have to be right.  They have to be good enough to fool the eye.
18:10:17 <jethr0> neither many kinds of simulations and algebraic libraries
18:10:24 <SamB_XP> but, the results on "equal" numbers often have to be arbitrary anyway...
18:11:04 <sorear> usually, floating point computations are judged by or relative to fuzzier analog equipment.
18:11:13 <SamB_XP> mmm.
18:12:01 <shankys_> dons: HXT looks pretty good. I'm not really finding much in the way of useful Haskell AJAX stuff though. Are there any Haskell AJAX libraries you would recommend?
18:12:02 <jethr0> often you are willing to pay some processing time for fewer evil rounding errors
18:12:11 <SamB_XP> so, anyway, sometimes you *do* need to make control decisions based on comparison of reals or what would be reals...
18:13:21 <SamB_XP> but always you can do *something* sensible when the difference between two numbers is suspiciously small...
18:13:57 <SamB_XP> (or maybe not *sensible* exactly, but at least appropriate)
18:14:13 <sorear> dons: When I skip the 'weirdness':  ghc-6.4.2: could not execute: ./BotPP
18:14:24 <SamB_XP> too bad Eq/Ord doesn't support anything like that
18:14:42 <jethr0> if (diff a b < epsilon) error "sorry, you only have a finite state machine"
18:14:49 <jethr0> ups, forgot parens
18:15:14 <SamB_XP> actually in Haskell you can say "if blah then blah blah else blah blah blah"
18:15:14 <jethr0> must be pseudo-code anyways
18:15:50 <jethr0> > if True then True else True True True
18:15:51 <lambdabot>    The function `True' is applied to two arguments,
18:15:51 <lambdabot>   but its type `Bool'...
18:16:03 <sorear> > if True then 5 else 2
18:16:05 <lambdabot>  5
18:16:14 <sorear> > [] -- I wonder
18:16:15 <lambdabot>  Add a type signature
18:16:27 <jethr0> hehe
18:16:37 <sorear> if True then 5 else 2  requires defaulting
18:16:43 <sorear> > default() ; if True then 5 else 2
18:16:44 <lambdabot>  Parse error
18:16:45 <jethr0> > [] asTypeOf [1]
18:16:47 <lambdabot>    The function `[]' is applied to two arguments,
18:16:47 <lambdabot>   but its type `[a]' ha...
18:16:53 <jethr0> > [] `asTypeOf` [1]
18:16:54 <lambdabot>  []
18:17:14 <sorear> [1] has an ambiguous type too
18:17:19 <jethr0> ^_^
18:17:24 <sorear> just not ambiguous enough
18:20:03 <dons> shankys_: looks like some things were missing, I added http://darcs.haskell.org/SoC/hsp.clientside
18:20:05 <lambdabot> Title: Index of /SoC/hsp.clientside
18:20:13 <dons> the ajax-generating library
18:20:22 <dons> sorear: check that BotPP is in the `pwd` ?
18:20:27 <dons> or should it be dist/build/...
18:20:50 <sorear> it should be
18:21:04 <sorear> but the build also fails to use hsc2hs
18:21:13 <sorear> (also easily worked-around)
18:21:34 <dons> weird. works for me fine
18:22:09 <sorear> I'm trying a different approach now.
18:22:29 <sorear> I got two trees, tree A is a static 6.4, tree B is a dynamic 6.4
18:22:46 <sorear> files are copied from A to B only as needed.
18:23:18 <sorear> (the old approach risked .hi-contamination, which may have been the cause of the dynamic linker failure)
18:24:24 <dons> yes
18:24:37 <dons> but it should *just work*, given the right .cabal file :)
18:25:31 <sorear> well, the .plugins file has a circular dependency
18:25:34 <dfranke> Woot!  Greetings from my brand-spankin-new Slackware laptop.
18:25:41 <sorear> Yippee!
18:26:03 <sorear> It fails to compile dist/build/BotPP/BotPP because ./BotPP doesn't exist.
18:26:09 <dfranke> Now it looks like I get to experience the joy of compiling ghc on a distro that doesn't come with any haskell binaries.
18:26:30 <sorear> *-unknown-linux.tar.bz2
18:27:01 <sorear> ^^^ that is statically linked and will run on any ELF-based i386 computer with Linux-compatible system calls.
18:27:06 <dons> sorear: hmm....
18:27:13 <sorear> hopefully.
18:27:22 <dons> sorear: the BotPP dep should appear later in the file though..
18:27:34 <dons> that's why BotPP doesn't use a preprocessor, and is built first
18:27:46 <sorear> in the .plugins file, -pgmF ./BotPP is in the global options
18:27:59 <dons> ah that's a bit wrong then
18:28:08 <sorear> Once you have the binary 6.6, HEAD is very easy to install from source.
18:28:09 <dons> dfranke: yeah, grab a binary from haskell.org/ghc
18:28:17 <dfranke> dons: in progress.
18:28:30 <sorear> (It only takes 90 mins to compile on a 2Ghz P4 desktop)
18:28:36 <sorear> ./configure && make
18:28:52 <sorear> getting the sources is actually harder
18:29:00 <dfranke> it only took a half hour on my AMD64 box.
18:29:08 <dons> sounds good
18:30:14 <sorear> even with the isolated build:
18:30:15 <sorear> stefan@stefans:/tmp/lb64plugs$ ./dist/build/lambdabot-dynamic/lambdabot-dynamic
18:30:15 <sorear> lambdabot-dynamic: user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: symbol __librt_multiple_threads,
18:30:15 <sorear> version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
18:30:34 <dons> ah right. I see what you're doing.
18:30:42 <dons> sorry, i thought you just wanted the runplugs tuff
18:30:47 <dons> stuff. but you want a full plugin build
18:30:54 <dons> which i haven't attempted since switching to cabal
18:30:54 <dfranke> (I'm setting up ghc before X.  That should give you an idea of my priorities :-)
18:31:00 <dons> now, SamB submitted a patch for this,
18:31:07 <dons> so it should work with a little bit of effort
18:31:17 <sorear> I don't want a full plugin build.  I want to make sure I haven't broken the full plugin build.
18:31:41 <sorear> (tho I doubt that simplifies anything)
18:32:01 <sorear> dfranke: I used to use X.  now I use it about 5mins a week.
18:32:03 <SamB_XP> it looks like something is wrong with the GHC libraries to *me*
18:32:34 <SamB_XP> (what *else* would be referring to those symbols?)
18:32:55 <sorear> I named my splitter prog X.hs & had a small double take at "... 99.6% .. X" in the top(1) :)
18:32:57 <SamB_XP> at least, *something* doesn't like your libc version...
18:33:18 <dfranke> sorear: if people still took the time to design lynx-friendly websites I might be the same.
18:33:54 <sorear> I don't visit graphical websites.
18:34:00 <SamB_XP> links is better!
18:34:09 <sorear> (I also use elinks, which is marginally better)
18:34:23 <sorear> I also use sisfb+fbcon.
18:34:25 <dfranke> actually I like w3m the best of any of those.
18:34:39 <sorear> 128x48 consoles are far superior to 80x25.
18:35:01 <sorear> (I'd go higher, but my 4+-year-old-monitor is too out of focus)
18:35:47 <dfranke> sorear: but you must have a nice cozy alcove in the ivory tower if you can get away with that :-)
18:35:48 <sorear> All I use X for is gv, which in turn is almost exclusively used for SPJ's papers.
18:36:06 <sorear> get away with what?
18:36:12 <dfranke> not visiting graphical websites.
18:36:45 <sorear> I am 16 years old, I get hand-me-downs from my must-have-bleeding-edge father.
18:37:04 <sorear> Everything I get is around three years old.
18:37:15 <sorear> Even the 5yr MTBF harddrives.
18:37:16 <dfranke> ah, ok.  I probably could have gotten away with that in high school too.
18:37:44 <SamB_XP> hmm. what kind of CPU do you have?
18:37:58 <sorear> (my corrent one [HDD] is brand new, because the old one failed at a moment when my house was too disorganized to find the others)
18:38:09 <sorear> 2Ghz P4, first stepping.
18:38:16 <SamB_XP> ooh, fast
18:38:32 <sorear> yes... you know you are in trouble when:
18:38:42 * SamB_XP 's best is a 600 MHz PIII wasted on windows
18:38:46 <sorear> "cannot find /lib/libc.so.2.3.2: I/O error"
18:39:00 <SamB_XP> hmm, yeah
18:39:04 <sorear> ^^^ ever see THAT!
18:39:10 <SamB_XP> no indeed
18:39:26 <SamB_XP> that sounds similar to what my mom's computer ran into not so long ago...
18:39:31 <SamB_XP> only that was with Windows 98
18:39:41 <sorear> I've had a filesystem eaten by bad ram
18:39:57 <sorear> Ever had GCC report a syntax error in /usr/include?
18:40:08 <SamB_XP> I bet bad RAM is worse than a drive with faults!
18:40:20 <SamB_XP> hmm. dunno!
18:40:28 <sorear> the in-memory version of /usr/include/wxwidgets.h had an 'a' swapped for an 'e'
18:40:42 <sorear> IMO a single bit change is a dead giveaway,
18:41:15 <SamB_XP> a dead giveaway that you should have got 33-bit RAM?
18:41:25 <sorear> and when rebooting causes the apparent contents of files to CHANGE... (queue "Twilight Zone" theme song)
18:42:00 <sorear> I wish I had a system supporting that :(
18:42:23 <SamB_XP> well, I'm making it up but I mean ram with parity checks of some kind
18:42:46 <rahikkala> sorear: Well, technically, I *have* had gcc report syntax errors in /usr/include... it's a simple matter of doing something to confuse the parser before an #include directive ;)
18:43:23 <sorear> I'd like full ECC ram.  Soft Errors? I needn't care!
18:43:26 <Saizan> the standard one doesn't have any parity check?
18:43:35 <sorear> no :)
18:43:44 <Saizan> :O
18:43:49 <sorear> "Non parity is faster and cheaper."
18:44:14 <sorear> Besides, computer software is so buggy you'd never notice the differnce.
18:44:18 <dylan> hmm, is there a way to make a monad that forces all computations to be in the same thread?
18:44:29 <sorear> (I made the last one up)
18:44:47 <sorear> dylan: Are you looking for runInBoundThread?
18:44:54 <dons> dylan: mmm
18:44:59 <dylan> sorear: not really.
18:45:01 <dons> a monad that prevents the use of forkIO ?
18:45:18 <dylan> well, a partial solution is a TChan (IO ())
18:45:34 <sorear> dylan: go up one metalevel.  What do you want?
18:45:53 <dylan> I can't go up. I have a C library of unknown threadsafeness
18:46:08 <bd_> dylan: Are you referring to SLang?
18:46:11 <dylan> Safest assumption is all calls to it must be in the same thread.
18:46:15 <dylan> bd_: yes. :)
18:46:27 <bd_> dylan: queue actions in a TChan (IO ()), execute it in a forkOS'd thread
18:46:34 <bd_> execute them*
18:46:36 <dylan> that works fine except when I want return values
18:46:41 <sorear> dylan: what you want is runInBoundThread, probably.
18:46:49 <bd_> dylan: You can pass the values back in a MVar or TVar
18:47:11 <dylan> bd_: yes, I'm doing that. After the third TVar it gets annoying
18:47:14 <sorear> that (or forkOS) runs a lightweight Haskell thread, and arranges that all foreign calls are made in the same OS thread.
18:47:19 <bd_> dylan: write a combinator!
18:47:20 <bd_> :)(
18:47:38 <bd_> runWithReturn m = do
18:47:41 <sorear> write a server!
18:47:43 <bd_> hm, I'll paste it
18:47:44 <bd_> @paste
18:47:45 <lambdabot> http://paste.lisp.org/new/haskell
18:47:55 <sorear> RPC is trivial in Haskell.
18:48:02 <dylan> I'd actually like to hide this so it looks like I'm just passing opaque things to a runSlang or something function.
18:48:21 <dylan> and have them block using e.g. a readTChan
18:48:33 <dylan> e.g.
18:48:45 <dylan> redraw :: Action ()
18:49:00 <dylan> err
18:49:09 <sorear> data RpcThread = Chan (IO ())
18:49:10 <dylan> better example
18:49:13 <lisppaste2> bd_ pasted "dylan: something like this?" at http://paste.lisp.org/display/33411
18:49:40 <dylan> readKey :: Action Key
18:49:54 <dylan> run :: Action a -> IO a
18:50:06 <sorear> dylan: bd_ beat me to my idea.
18:50:09 <dylan> and Action is a newtype of IO, for instance.
18:50:12 <bd_> dylan: You can hide the actual queue itself, and only expose higher-level functions
18:50:14 <sorear> just throw in a ReaderT
18:50:50 <dylan> hmm, something like:
18:51:30 <dylan> data Action a = Action (TChan a) (IO a)
18:51:32 <sorear> I haven't done enough playing with it, but Wehr's "reactive objects" might also be what you want.
18:51:45 <bd_> dylan: Why does the action carry a tchan?
18:51:54 <sorear> dylan: hide the actions in ReaderT
18:51:57 <dylan> well, IO TChan
18:51:58 <bd_> I'd think it'd be more like newtype Action a = Action (IO a)
18:52:18 <bd_> or newtype Action a = Action (ReaderT SomeType IO a)
18:52:22 <dylan> because for various transformer reasons, I'd like to have this be at IO level
18:52:40 <bd_> dylan: so hide the type of the channel where higher-level stuff can't get at it :)
18:52:57 <dylan> hmm, actually, perhaps WriterT?
18:53:12 <bd_> why WriterT?
18:53:16 <sorear> dylan: what are these 'transformer reasons'
18:53:28 <dylan> sorear: I'm already using a ReaderT later on. :)
18:53:41 <sorear> why does that matter?
18:53:51 <dylan> I'm trying to define an API that acts as if there are no threads being used. :)
18:53:54 <sorear> LB uses two StateT's in the same stack
18:54:53 <bd_> dylan: So, Just use the basic queueActionWithReturn thing and don't export anything that lets other modules get at the TChan
18:54:58 <bd_> directly anyway
18:55:05 <dylan> Why are you using an MVar for that?
18:55:12 <bd_> dylan: No need for a TVar?
18:55:15 <sorear> why not?
18:55:24 <bd_> MVar is the right abstraction, imo
18:55:35 <bd_> otherwise I need to make a TVar (Maybe a) which acts like a MVar a
18:55:37 <bd_> which is ugly :p
18:56:07 <SamB_XP> well, if you were going to need to use it atomically, you'd need to do that
18:56:07 <sorear> or a TMVar, which is like an MVar but forces you to pollute your code with atomiclys
18:56:17 <bd_> heh
18:56:28 * SamB_XP wonders how long until MVars *are* TMVars or whatever
18:56:32 <bd_> SamB_XP: true, but here we just have two threads using it to communicate
18:56:59 <dons> dylan: so don't we have the 'unsafe'/'safe' ffi attributes for controlling this stuff?
18:57:37 <dons> so you get guaranteed single-OS-threaded calls into foreign libs for broken^h^h^h legacy libraries that need them
18:57:59 <dylan> I thought unsafe/safe only controlled callbacks
18:58:00 <bd_> dons: That doesn't guarentee that only one call will be made into a given library at a given time though, I thought?
18:58:02 <sorear> dons: ^W is easier
18:58:10 <sorear> Locks!
18:58:12 <sorear> MVar ()
18:58:35 <dons> bd_: no right. so a lock on the ffi binding would be another option, I guess
19:00:06 <dons> all slang* calls take a withMVar first
19:00:20 <dons> on a global , hidden lock not visible outside the library
19:00:50 <dons> slangFoo = withMVar slanglock $ c_slang_foo
19:01:11 <dons> slanglock = unsafePerformIO $ newMVar () {-# NOINLINE ... #-}
19:01:18 <dylan> and then I could pretend it's thread safe.
19:01:21 <bd_> @hoogle withMVar
19:01:22 <lambdabot> Control.Concurrent.MVar.withMVar :: MVar a -> (a -> IO b) -> IO b
19:01:39 <dons> singlethreaded f = withMVar slanglock f
19:01:47 <dons> slangFoo = singlethreaded c_slang_Foo
19:02:14 <dons> dylan: well you could guarantee only one call is made from haskell into slang at any point
19:03:08 <dons> still, i wonder what the unsafe/safe attributes are for, if not for handling legacy libraries that can't do thread local state
19:03:20 <dons> oh, specifically for ones that requrie os threads
19:03:27 * dons remembers now
19:03:30 <bd_> dons: doesn't unsafe mean that the call isn't expected to block, or something?
19:03:43 <dons> bd_: mmm. yes.
19:03:58 <dons> and the forkOS stuff is for the libraries that need a real thread to allocate in
19:04:08 <bd_> oh, unsafe must not call back into haskell
19:04:12 <dons> and looks like 'unknown thread safety' is another issue altogether
19:04:31 <dons> one where we must enforce single threadedness in the ffi calls to a particular lib
19:04:39 <dons> dylan: any idea if curses is similar?
19:04:50 <dons> i wonder if this explains a couple of curses wibbles i've noticed...
19:04:59 * dons should try locking up the curses bindign..
19:06:15 <dylan> dons: I dunno if slang is even non-thread-safe
19:07:45 <dylan> eventually, slang could be rewritten in haskell.
19:08:19 <dylan> it's a pretty straight-forward abstraction of termcap...
19:08:42 <dylan> heh, "ihug". hehehe
19:08:46 <sorear> dylan: so slang is a terminal interface?
19:08:57 <sorear> dylan: you may wish to look at vty
19:09:14 <dylan> sorear: No thank you. it's taken enough time to understand slang, and it's very simple.
19:09:22 <dylan> and enough time to write the bindings...
19:32:56 <dons> dylan: yeah, and getting a nice hslang lib out of your work would be a very nice result
19:36:27 <wolverian> is there something like the 99 Lisp Problems for Haskell?
19:36:32 <wolverian> (http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html)
19:36:36 <lambdabot> Title: L-99: Ninety-Nine Lisp Problems, http://tinyurl.com/tt9e7
19:38:12 <sorear> ?wiki H99
19:38:12 <lambdabot> http://www.haskell.org/haskellwiki/H99
19:38:24 <wolverian> heh. thanks
19:38:26 <sorear> They've already been ported.
19:38:31 <wolverian> where?
19:38:35 <wolverian> (the page is empty)
19:38:42 <sorear> Try H-99?
19:39:03 <wolverian> http://haskell.org/haskellwiki/99_Haskell_exercises
19:39:05 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
19:39:06 <sorear>            http://haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
19:39:07 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
19:39:09 <wolverian> heh
19:39:13 <wolverian> @where H99
19:39:13 <lambdabot> I know nothing about h99.
19:39:18 <wolverian> @where h-99
19:39:18 <lambdabot> I know nothing about h-99.
19:39:28 <wolverian> @where+ h99 http://haskell.org/haskellwiki/99_Haskell_exercises
19:39:29 <lambdabot> Done.
19:39:34 <wolverian> sorear, thanks.
19:39:41 <sorear> yw
19:39:59 <wolverian> augh. it has the answers inline with the problems!
19:40:43 <sorear> you can fix it
19:40:51 <wolverian> true. :)
19:41:19 <dons> wolverian: :)
19:41:25 <sorear> Oh joy, I'm think I'm starting to sound like dons :)
19:41:30 <dons> bonus points if you can complete the last 5 or 6 that aren't done
19:41:53 <sorear> Oh, GNU sort has finished the first phase after 2 hrs
19:41:54 <dons> sorear: that's a good thing, isn't it ? :)
19:41:56 <dons> hehe
19:44:24 <bd_> hmm, what's the correct way to import EpochTime from HAppS? http://happs.org/auto/apidoc-0.8.4/HAppS-MACID.html#v%3AgetTime does not provide a link to the documentation, and the module that ghc points to (HAppS.MACID.Types) is 'hidden'
19:47:21 <sorear> and sort has passed 100 mins on top!
19:47:53 <bd_> ... looks like there is no usable way to import it. huh.
20:11:06 <cptn> shankys_!
20:11:28 <shankys_> cptn: Yes?
20:11:48 <cptn> i saw on reddit that you have a hs web framework
20:11:58 <cptn> howd you pull that off?
20:12:02 <shankys_> cptn: Yup, that's true.
20:12:27 <shankys_> cptn: I spent like 16 hours a day doing a LOT of hacking :)
20:12:52 <cptn> that would do it
20:13:13 <shankys_> cptn: Helps that I have other people helping me too (also working ridiculous hours)
20:13:35 <cptn> thats the startup spirit
20:13:42 <cptn> powered by equity
20:15:58 <syntaxfree> http://programming.reddit.com/info/vzw8/comments
20:16:00 <lambdabot> Title: Ask Reddit: What&#39;s your language of choice, and why? (reddit.com)
20:16:59 <dons> cptn: hi. there's a couple of other frameworks though, HAppS and WASH in particular
20:17:43 <syntaxfree> WebFunctions, too.
20:17:49 <syntaxfree> Though it's built upon wash I think.
20:18:07 <dons> ah yes
20:18:13 <dons> mm. i hope these are all documented.
20:18:21 <dons> i should try them out in the new year
20:18:29 <dons> and maybe we can get some tutorials set up
20:18:57 <sorear> 2nd phase complete...
20:19:38 <syntaxfree> WebFunctions looks bl oody cool, but all the documentation available is a PhD thesis.
20:19:53 * syntaxfree should have a macro for that phrase.
20:19:57 <dons> right. he who documents wins.
20:20:10 <dons> we're getting there, but we're not the best documentation community yet
20:20:17 <syntaxfree> [insert Haskell thing here]  looks bloody cool, but all the documentation available is a PhD thesis.
20:20:34 <dons> i think that culture is slowly changing though
20:20:41 <syntaxfree> Explicit type models cut documentation work in half.
20:20:45 <ctkrohn> I was looking at the webfunctions thesis today... it's actually not too dense
20:20:48 <dons> people understand more and more that they're research can be used immediately, if they document it
20:20:59 <syntaxfree> I often find that with Haddock documentation I can just explore the type model and get a hang for this.
20:21:00 <ctkrohn> its written more like a short book for normal readers than the masters thesis that it is
20:21:22 <syntaxfree> ctkrohn: it left me with a lot of gaps. Maybe I'm just stupid.
20:21:27 <dfranke> syntaxfree: explicit type models cut documentation work in zero most of the time.
20:21:28 * ctkrohn <- shanky's partner in crime for the new framework
20:21:32 <dfranke> zeroeths?
20:21:52 <ctkrohn> syntaxfree: hm, I didn't look at it too closely, I'm sure it's not perfect
20:22:10 <syntaxfree> Maybe it's just that I don't know exactly what to expect from a web framework.
20:22:13 <ctkrohn> syntaxfree: I was just saying, the writing style didn't seem too dense and academic, like so many other papers on useful things like, say, GUIs in haskell
20:22:19 <syntaxfree> I don't know Rails, or Django, or anything like that.
20:22:34 <syntaxfree> ctkrohn: Oh, I can grok academic. I love bananas-era Erik Meijer, for example.
20:22:44 <syntaxfree> It's just that often I don't know what to look for.
20:23:03 <syntaxfree> That was a big problem when I started out with Parsec. I didn't know what to expect from a parsing librart.
20:23:08 <syntaxfree> er, library.
20:23:11 <sorear> I love academic.  PhD and source code are usually enough...
20:23:45 <sorear> finally, CPU usage < 75% ! (sorting a 10GB file)
20:24:06 <syntaxfree> someone on reddit saying Common Lisp's "purity" is awesome.
20:24:30 <syntaxfree> There's someone who will cream their pants when monads dawn upon them.
20:24:31 <dfranke> syntaxfree: whom?
20:24:53 <syntaxfree> dfranke: http://programming.reddit.com/info/vzw8/comments/cw070
20:24:54 <lambdabot> Title: Ask Reddit: What&#39;s your language of choice, and why? (reddit.com)
20:25:34 <dfranke> syntaxfree: I'm not web-capable ATM.  Just wanted to know the name of the poster.
20:25:42 <syntaxfree> " jesusphreak"
20:25:51 <dfranke> alright.
20:26:07 <syntaxfree> I don't  know any reddit people by nickname.
20:26:18 <syntaxfree> Except for #haskell people.
20:26:48 <syntaxfree> http://programming.reddit.com/info/w0co/comments
20:26:49 <lambdabot> Title: PHP is making me sad, where do I go? (reddit.com)
20:26:56 <syntaxfree> it is the dawning of the age of aquarius.
20:27:42 <cptn> i am not completely sold on monads yet
20:27:53 <dfranke> I get most of my Haskell news by reading http://reddit.com/user/dons
20:27:55 <lambdabot> Title: overview by dons (on reddit.com)
20:28:28 <dons> dfranke: hehe :)
20:28:29 <syntaxfree> ah. I read planet haskell and hwn.
20:28:40 <syntaxfree> reddit is a time-killer.
20:28:44 <sorear> I subscribe to -cafe@.
20:28:52 <cptn> i read ltu
20:28:58 <sorear> ... and #haskell isn't a worse timesink?
20:29:41 <syntaxfree> reddit can be brainless-er.
20:29:54 <syntaxfree> lotsa blogs kvetching about metaphor mismatch.
20:30:07 * syntaxfree 's blog kvetches about metaphor mismatch in do-notation all the time.
20:30:15 * syntaxfree subscribes to -cafe as well.
20:30:18 <SamB_XP> also you generally only look at what people said in #haskell *recently*
20:30:28 <dfranke> Reddit might be nicer if we just locked hopeseekr, pica, and jesusphreak in a room together for a few hours and handed them knives.
20:30:29 <syntaxfree> I read ltu once in a while. It's often too heavy for light reading.
20:30:39 <dons> dfranke: :) yeah
20:30:47 <syntaxfree> oh. jesusphreak is notorious.
20:30:55 <newsham> hi.
20:30:59 * syntaxfree wonders what people talk about me behind my back ;)
20:31:06 <newsham> <cptn> i am not completely sold on monads yet
20:31:10 <newsham> heh
20:31:49 <sorear> I don't really get the concept of 'light reading.'
20:32:12 <cptn> did syntaxfree leave when i said that?
20:32:23 <dons> cptn: nope
20:32:50 <dons> cptn: i guess you know they're used for all sorts of interesting things?
20:32:52 <dons> ?wiki Monad
20:32:53 <lambdabot> http://www.haskell.org/haskellwiki/Monad
20:32:53 <dons> has a few.
20:32:59 <syntaxfree> sorear: oh. Background info: My gf dumped me a week ago and I'm having a lot of free time I didn't use to.
20:33:03 <sorear> Ok, it's been 3 hrs, sort is almost done
20:33:05 <dons> i guess knowing when, as a new haskell programmer, you actually need a monad, is the hard part
20:33:09 <syntaxfree> So I read programming blogs to get away from myself.
20:33:19 <dons> syntaxfree: you should write some code!
20:33:33 <syntaxfree> Well, I had code-writing time in my usual routine.
20:33:43 <SamB_XP> dons: you never need a monad unless you have to do IO
20:33:55 <syntaxfree> I'm often depressed enough that I can't think for beans, though.
20:34:00 <sorear> SamB_XP: read the 1.2 prelude!
20:34:08 <syntaxfree> So instead of watching TV, I read the brainless programming blogs at reddit.
20:34:10 <dons> SamB_XP: ok thanks for that info. :P
20:34:12 <newsham> syntax: sorry to hear.  you'll get by though.
20:34:17 <SamB_XP> sorear: there is *always* another option!
20:34:50 <araujo> syntaxfree, the idea of not watching tv is doing something more productive instead
20:34:55 <araujo> :-)
20:35:24 <syntaxfree> After a week of brainless programming blogs, I've learned a lot of *bad* software engineering practices.
20:35:47 <dons> cptn: a nice particular application is the use of the Reader monad when writing an interpreter, to implement lexical scope for free, http://www.cse.unsw.edu.au/~dons/blog/2006/12/11#interpreters-with-reader-monad
20:35:48 <syntaxfree> That people find the concept of "refactoring" nontrivial amazes me.
20:35:49 <SamB_XP> it would be better to, like, read a book or something!
20:35:49 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y82979
20:35:52 <newsham> probably more fruitful to read code than to read blogs about code.
20:35:57 <SamB_XP> even to *play videogames*
20:36:01 <SamB_XP> than to read mindless things
20:36:02 <syntaxfree> fruitful, yes. Easy on the mind, no.
20:36:17 <newsham> general rant: programmers expect to be good writers without having become good readers.
20:36:23 <SamB_XP> by "book" I mean *fiction*
20:36:39 <araujo> SamB_XP, that's what ive been doing snce i got a wii :-}
20:36:42 <syntaxfree> Again, I'm often depressed enough that I can't think for beans.
20:36:48 <syntaxfree> ah, yes. But I'm used to reading fiction as well.
20:36:54 <SamB_XP> escapism is the answer!
20:37:06 <syntaxfree> All that stuff was already factored into my routine.
20:37:09 <SamB_XP> ah
20:37:14 <syntaxfree> Most of the depressed time is time I'd be spending with the girlfriend.
20:37:24 * sorear is impressed at the amount of punctuation in tnhe haskell-logs.
20:37:28 <SamB_XP> hrmm. you could take a walk?
20:37:35 <syntaxfree> I swim.
20:37:46 * syntaxfree lives in a nice condo with swimming pools.
20:37:47 <SamB_XP> sorear: how much of it was in the output of @pl?
20:37:51 <dylan> I spend some down-time reading science fiction
20:38:07 <SamB_XP> dylan: there is another kind?
20:38:08 <sorear> I see stuff like: !!!!!!!!!!!!!!!!!! {repeat ~300 times}
20:38:22 <sorear> Samb: yes! topology texts!
20:38:23 <syntaxfree> reading reddit isn't *that much* of a waste of time.
20:38:24 <dylan> SamB_XP: There's historical fiction and fantasy, yes
20:38:32 <SamB_XP> sorear: those are fiction?
20:38:40 <dylan> SamB_XP: of course, I don't like fantasy much and most good historical fiction is also science fiction...
20:38:43 <sorear> misparsed statement, sorry.
20:38:44 * syntaxfree is reading an exterior algebra text, among other things.
20:38:51 <SamB_XP> dylan: how do you tell the difference between fantasy and science fiction?
20:39:22 <dylan> SamB_XP: science fiction is something with a higher level of suspension of disbelieve
20:39:25 <dylan> *disbelief.
20:39:32 <dylan> e.g. david brin's Uplift series.
20:39:45 <SamB_XP> "higher level"?
20:39:47 <dylan> Fantasy often has dragons, orges, and such.
20:39:55 <sorear> ogres?
20:40:03 <dylan> Ogres. :P
20:40:08 <syntaxfree> I stopped liking fantasy at about age 8.
20:40:18 <dylan> I find it harder to believe in dragons and such then to believe in FTL spaceships
20:40:25 <syntaxfree> as a wee tot, sure, bring on the dragons.
20:40:51 <dfranke> I'd say the difference is that scifi attempts to justify its "sufficiently advanced technology" in terms of existing laws of nature, whereas fantasy just modifies them overtly.
20:41:46 <syntaxfree> some sci-fi tries to be somewhat scientific/nerdy.
20:41:58 <dylan> things by Stephen Baxter and Arthur C. Clark are often entirely plausible
20:42:05 <sorear> I forgot to set LANG=C for my 3-hour sort :(
20:42:07 <SamB_XP> oh, okay, so star wars is fantasy then?
20:42:15 <syntaxfree> then there's "Independence Day"-level sci-fi.
20:42:17 <dylan> yes, Star Wars is fantasy
20:42:26 <syntaxfree> Star Wars is fantasy.
20:42:28 <dylan> There exists very few good SciFi movies and TV shows
20:42:41 <syntaxfree> but ID4 or Jurassic Park are sci-fi, albeit very boorish.
20:43:01 <dylan> I refuse to read anything by Michael Creton
20:43:10 <SamB_XP> heh
20:43:14 <SamB_XP> michael creton?
20:43:19 <t35t0r> chricton
20:43:21 <t35t0r> crichton
20:43:22 <sorear> ?spell cretan
20:43:24 <lambdabot> Cretan cretin Cretans Gretna creating
20:43:24 <dylan> Good stories, perhaps, but the science usually breaks the suspension of disbelief.
20:43:26 <sorear> ?spell creton
20:43:26 <lambdabot> cretin Cretan cretonne Creon crouton
20:43:30 <SamB_XP> I think he meant cretan
20:43:32 <SamB_XP> er.
20:43:34 <SamB_XP> cretin?
20:43:37 <dylan> Cretin
20:43:40 <SamB_XP> @all-dict cretin
20:43:40 <t35t0r> michael crichton
20:43:42 <sorear> ?web1913 Cretan
20:43:42 <lambdabot> *** "Cretin" gcide "The Collaborative International Dictionary of English v.0.48"
20:43:42 <lambdabot> Cretin \Cre"tin\ (kr[=e]"t[i^]n), n. [F. cr['e]tin; of uncertain
20:43:42 <lambdabot>   origin.]
20:43:42 <lambdabot>   One afflicted with cretinism.
20:43:43 <lambdabot>   [1913 Webster]
20:43:45 <lambdabot> [20 @more lines]
20:43:47 <lambdabot> *** "Cretan" web1913 "Webster's Revised Unabridged Dictionary (1913)"
20:43:49 <lambdabot> Cretan \Cre"tan\ (kr[=e]"tan), a.
20:43:51 <lambdabot>   Pertaining to Crete, or Candia. -- n. A native or inhabitant
20:43:53 <lambdabot>   of Crete or Candia.
20:44:02 <syntaxfree> I once read something about Michael Crichton that made me think he was a jerk. I forget what, though.
20:44:06 <sorear> oooh, LB hit flood controll...
20:44:25 <t35t0r> ?google test
20:44:28 <lambdabot> http://test.com/
20:44:28 <lambdabot> Title: Test Central Home
20:44:31 <t35t0r> :>
20:44:37 <dylan> Michael Chirchton's book Prey includes some lines of BASIC (sort of) that are the 'heart' of a super-secret AI program. :P
20:44:48 <SamB_XP> heh
20:44:49 <t35t0r> dylan, hah
20:44:52 <syntaxfree> hahahah
20:44:53 <dylan> Even more hillarious is there is no way the code would ever run.
20:45:08 <syntaxfree> I remember some book by Umbertro Eco containing code as well.
20:45:14 <araujo> H.G. Wells FTW!
20:45:14 <dylan> I seem to remember there was an if statement that could never be true.
20:45:15 <sorear> My mother makes frequent reference to "Michael Crichton Disease", where the author of the book is printed in larger letters than the title.
20:45:29 <SamB_XP> well, Gundam Wing seems to switch between BASIC and some TWAIN-related manual for all the on-screen text!
20:45:31 <t35t0r> if (!1)
20:45:56 <dylan> well, it could be true for floats
20:46:01 <SamB_XP> sorear: does that apply to books by "AVI"?
20:46:02 <dylan> but I think the variable was an integer...
20:46:29 <dylan> e.g. IF x < 10 AND x > 10 or some such
20:46:41 <sorear> Audio-video interleave wrote books? :) (never heard of him)
20:46:48 <SamB_XP> sorear: no
20:46:53 <SamB_XP> somebody is named that!
20:47:15 <SamB_XP> actually the name is probably Avi. but I always see it in all-caps for some reason...
20:47:16 <dylan> Fantasy can be quite good
20:47:25 <dylan> though
20:47:50 <dylan> It has to have the backstory of a Tolkien work for me to enjoy it. :)
20:47:53 * sorear curses the idiot who decided sort(1) should default to ignoring punctuation
20:47:54 <dfranke> I'm a Tolkien fanatic.  The only other worthwhile fantasy I've been able to find is LeGuin's Earthsea cycle.
20:48:03 <Excedrin> "hard science fiction" is the term for the subgenre that tries to make things scientifically plausable
20:48:08 <bd_> hmm, any HAppS gurus here? I'm wondering if there's any easy way to disable peer hostname resolution for incoming HTTP requests...
20:48:14 <SamB_XP> mmm.
20:48:25 <SamB_XP> Excedrin: and it gets smaller every decade, doesn't it?
20:48:56 <sorear> I'm O.K. with tolkien, read a smallish number of others, never really got "in" to fiction.
20:49:15 <dylan> Clark's Rama series was nice.
20:49:17 <Excedrin> dunno, but star trek and star wars are both clearly sf...
20:49:30 <dfranke> I've read the Silmarillion, working my way through the Lost Tales now.
20:49:32 <dylan> Trek is clearly, but star wars is fantasy IMHO
20:49:37 <sorear> I've been trying to read textbooks (with varying levels of success) since 4-ish...
20:49:56 <SamB_XP> what is Majora's Mask?
20:49:57 <dylan> I, uh, didn't bother reading until age 13 or so
20:50:17 <dylan> I was too busy building things, I guess.
20:50:24 <Excedrin> darth vader would need to be a giant blue troll to make it fantasy
20:50:25 <SamB_XP> sorear: what *kind* of textbooks?
20:50:26 <dfranke> I learned to program before I learned to read.
20:50:46 <SamB_XP> Excedrin: are you attempting to argue that darth vader is *not*, in fact, a giant troll?
20:50:50 * syntaxfree learned to breathe before he learned to read.
20:50:58 <dfranke> The first words that I learned how to read were "if", "then", and "while"
20:51:02 <bd_> @hoogle accept
20:51:03 <lambdabot> Network.accept :: Socket -> IO (Handle, HostName, PortNumber)
20:51:03 <lambdabot> Network.Socket.accept :: Socket -> IO (Socket, SockAddr)
20:51:15 * araujo 's first book read was "The Little Prince" at 4
20:51:18 <bd_> darn. Goes straight to String?
20:51:28 <araujo> And i still enjoy it as if it was the first time :-)
20:51:44 <araujo> Antoine rulez
20:51:57 * dylan always tried to read hard things first
20:52:09 <dylan> my first 'book' was a book called Meg about giant prehistoric sharks
20:52:18 <dylan> a novel, in fact.
20:52:39 <araujo> I even have the copy of the book :-)
20:52:52 <dylan> (and my first book in another language was Don Quixote de la Mancha . . . which was a psychotic choice)
20:53:05 <araujo> dylan, haha, never liked Don Quijote
20:53:18 <dylan> I read it in english first. it's good in the first 500 pages
20:53:23 <dylan> the next 500 pages are harder
20:53:32 <t35t0r> bah i can't even get past the first page of two towers
20:53:37 <araujo> It's sometimes funny with Sancho :-)
20:53:41 <dylan> I've never gotten paste page ~700 in English and page ~200 in spanish.
20:53:45 <t35t0r> no patience for long winded crap
20:53:58 <t35t0r> don't know how i read hobbit
20:54:03 <t35t0r> skimmed most i guess
20:54:07 <dylan> t35t0r: just learn to read faster
20:54:36 <SamB_XP> hobbit is for kiddies
20:54:47 <SamB_XP> LotR is *not* for kiddies
20:54:57 <t35t0r> yes i read hobbit in 7th grade
20:55:14 <t35t0r> two towers tried to read in 9th or something but gave up after first few pages
20:55:34 <t35t0r> then the movie was released 10 years later ..oh well
20:55:46 <SamB_XP> but I think there was like ten years between the publication of The Hobbit and the publication of Lord of the Rings?
20:56:03 <dylan> Oh, and hithiker's guide the galaxy. That's the best five-book trilogy ever.
20:56:09 <SamB_XP> hah
20:56:12 <t35t0r> dylan, dune's not bad either
20:56:18 <SamB_XP> is it actually called a trilogy?
20:56:19 <t35t0r> 6 book
20:56:25 <t35t0r> quintology
20:56:26 <dylan> I've read dune too
20:56:32 <t35t0r> sextology
20:56:40 <dfranke> I just gave my sister DGHDA and LDTotS for Christmas.
20:56:43 <dylan> t35t0r: I'm fairly certain mine is 5 books
20:56:47 <SamB_XP> It just sounds like the sort of thing Hitchiker would do...
20:56:52 <dylan> and it is called a trilogy
20:56:55 <t35t0r> haha
20:57:01 <dfranke> dylan: 5 books and a short story.
20:57:10 <dfranke> dylan: Young Zaphod Plays It Safe
20:57:11 <dylan> ah, the short story isn't part of the original set.
20:57:12 <t35t0r> children of dune is best
20:57:33 <SamB_XP> I mean, compared to quantum mechanics and microscopic space fleets, five-book trilogies are nothing
20:57:59 <dylan> I often narate my life in the style of Douglas Adam's works. :)
20:58:06 <dfranke> how about the chapter-long treatise on fractals in the middle of Dirk Gently?
20:58:17 <SamB_XP> now all I have to do is *read* it
21:04:37 <sorear> ?bot
21:04:38 <lambdabot> :)
21:04:50 <t35t0r> anyone use gentoo here?
21:05:17 <sorear> yes (not me, but I've seen ppl say they use it)
21:05:33 <t35t0r> i was wondering if we could better create the build system for the packages
21:05:34 <sorear> I do use a POSIX-family, though
21:05:44 <sorear> what packages? (cabal?)
21:06:05 <t35t0r> currently opengl and openal are use flags but could be made into separate packages e.g hugs98-openal, hugs98-opengl
21:06:15 <t35t0r> there are others glut, alut , etc
21:06:27 <t35t0r> we like split builds
21:12:11 <dfranke> wow, Slackware includes no MTAs other than sendmail.
21:12:14 <dfranke> THAT is old-school.
21:12:26 <jcreigh> really? Is that still the case?
21:12:30 <dfranke> yup.
21:12:34 <syntaxfree> Humpf. Newcomers.
21:12:40 <jcreigh> ...but I've heard that recent version of sendmail doesn't suck nearly as much.
21:12:58 * syntaxfree says "Yggdrasil" while immitating an annoyed old man's voice.
21:12:58 <dfranke> I've been using postfix for going-on-to-five-years.
21:15:40 <t35t0r> heh i can do opengl in haskel!
21:15:46 <dons> t35t0r: yeah
21:15:49 <sorear> Yes!!
21:15:50 <dons> see for example, Frag
21:15:53 <dons> ?where Frag
21:15:54 <lambdabot> http://www.haskell.org/haskellwiki/Frag
21:16:01 <sorear> Unfortunately, *I* can't.
21:16:06 <dons> use HOpenGL, should come with your standard ghc install
21:16:11 <t35t0r> it looks like q3
21:16:25 <t35t0r> sorear, are you blind?
21:16:32 <sorear> I try ... oooh pretty pictures ... CLICK! POP! Segmentation fault.
21:16:35 <dons> yeah, the bg graphics are from the free quake textures set
21:16:38 <t35t0r> ohh
21:16:45 <sorear> X server crash.
21:16:46 <dons> sorear: you're graphics card isn't up to it?
21:16:49 <dons> ah
21:17:00 <t35t0r> sorear, lspci | grep -i vga
21:17:02 <sorear> The CLICK! POP! is the kernel resetting the video mode
21:17:07 <sorear> Sis 315 pro
21:17:12 <t35t0r> wth is that haha
21:17:25 <t35t0r> 2000?
21:17:26 <syntaxfree> http://www.guessthelogo.com/
21:17:28 <lambdabot> Title: Which is the real logo?
21:17:32 <dons> i thought sis was fairly well supported though?
21:17:35 <sorear> Am I the ONLY person who thinks a crash is a bug on low-end hardware?
21:17:44 <sorear> dons: sis is supported, but not for 3d
21:17:48 <dons> ah right
21:17:54 <sorear> dons: the software 3d is very unstable
21:17:56 <dons> 3d schmee-d
21:18:27 <sorear> I haven't reported it as a bug because "Software 3D crashes Xserver" has been in the BTS for ~5yrs.
21:18:40 <sorear> I guess no-one cares about ppl like me.
21:19:03 <sorear> If you don't have top of the line you don't exist :(
21:19:33 <sorear> And it isn't even a 3d program...
21:19:40 <syntaxfree> you could blog about it with a ".. considered harmful" title.
21:20:06 <sorear> I thought of a clever way to render fractal flames in realtime using texturing hardware.
21:20:35 <sorear> Even *without* hardware, this algoritm would be much more cache-friendly than the chaos game.
21:20:47 <sorear> OK, OK, you need a cpu and ram :)
21:21:40 <sorear> But, I implemented it, tested it, didn't work, fixed it, was able to do this pretty well, if you ignore the fact I had to restart my Xserver every other test.
21:22:32 <dfranke> gah.
21:22:38 <syntaxfree> you know what's a clever marketing coup?
21:22:39 <dfranke> I just read through sendmail.cf.
21:22:45 <dfranke> Eyes. goggles. nothing.
21:23:04 <syntaxfree> begin referring to functional programming as Programming 2.0
21:23:19 <syntaxfree> in Programming 2.0 you have a function composition combinator.
21:23:38 <syntaxfree> in Programming 2.0 you have sexy types, type classes and fundeps.
21:23:52 <syntaxfree> in Programming 2.0 you have monads, comonads and arrows. It's a bloody revolution!
21:23:57 <sieni> syntaxfree: or maybe you should start referring to regular programming as Dysfunctional Programming
21:24:20 <syntaxfree> not gunna work.
21:24:29 <syntaxfree> You have to refer to everyone else as old-school.
21:24:33 <t35t0r> niec thesis
21:25:22 <syntaxfree> it worked for Ajax, didn't it?
21:25:43 <sorear> wow, would you believe setting LC_ALL=C makes sort(1) *much* faster?
21:26:03 <wolverian> yes.
21:26:15 <sorear> It took 3 hrs to get ~75% through with the bogus evil default
21:29:33 <Shimei> But AJAX has a cute acronym named after detergent!
21:29:54 <syntaxfree> ajax is Web 2.0
21:29:57 <syntaxfree> Tha new web.
21:30:03 <syntaxfree> Who wants to be stuck at tha old web?
21:30:09 <Shimei> Programming 2.0 needs an acronym and a cute bunny logo.
21:30:10 <syntaxfree> That's why I say, kids.
21:30:14 <syntaxfree> Programming 2.0 is the way to go.
21:30:28 <syntaxfree> Now you can, like, program programming.
21:30:29 <syntaxfree> ;)
21:30:53 <sorear> sort is IO bound now <grrr> <grrr>
21:31:43 <sorear> wow, there's a ^N in the #haskell-logs
21:31:44 <t35t0r> ?google mpi haskell
21:31:45 <lambdabot> http://foldr.org/~michaelw/hmpi/
21:31:45 <lambdabot> Title: hMPI - a Haskell binding for MPI
21:32:05 <newsham> what is mpi?
21:32:06 <sorear> t35t0r: look into GdH, it does MPI automatically
21:32:13 <sorear> Message Passing Interface
21:32:24 <t35t0r> ?google gdh haskell
21:32:26 <lambdabot> search module failed: IRCRaised Lib/Url.hs:159:6-51: Irrefutable pattern failed for pattern Data.Maybe.Just ctype
21:32:29 <sorear> the defacto standard distributed computation framewok
21:32:41 <newsham> message passing infrastructure?
21:32:51 <t35t0r> http://www.macs.hw.ac.uk/~dsg/gdh/ ?!
21:33:03 <t35t0r> dead
21:33:17 <t35t0r> that's why the LB failed
21:34:21 <sorear> on smaller scales, automatic SMP parallelism (for 2-to-16-core boxes) has been merged into GHC
21:34:27 <sorear> semi-automatic
21:34:49 <sorear> you tell it what should be done in parallel, it does the syncronization and communication
21:35:24 <sorear> GdH iirc was a project to use the same system for highly nonuniform computers (i.e. grids)
21:35:37 <syntaxfree> automatic SMP parallelism!
21:35:42 <syntaxfree> that's Programming 2.0!
21:35:51 <syntaxfree> No more mucking about with pointers! Programmers revolt!
21:43:25 <t35t0r> sorear, very nice
21:43:36 <t35t0r> sorear, i need another link though
21:43:59 <t35t0r> http://citeseer.ist.psu.edu/669150.html other than the paper
21:44:01 <lambdabot> Title: The Design and Implementation of GdH (ResearchIndex)
21:47:45 <t35t0r> that nqueens implementation in the demos directory is cool
21:47:49 <dons> sorear: works up to 40 cores...
21:47:56 <t35t0r> i wonder how fast it is against my nqueens i did in c
21:48:03 <dons> (the smp runtime, haven't had a machine higher yet to try it on)
21:48:07 <t35t0r> for say n = 40
21:48:14 <t35t0r> err n = 14 boardzie
21:48:54 <dons> its not too hard to beat C once you go multicore in haskell
21:49:06 <dons> the DPH paper, recently, showed that for matrix operations
21:49:15 <dons> once you get to 3 or 4 cores, you can forget about C.
21:49:35 <sorear> can you forget -fvia-C :)
21:49:40 <dons> hehe
21:49:44 <t35t0r> who the hell has 3-4 cores?
21:49:48 <sorear> dons
21:49:49 <t35t0r> on their desktop
21:50:03 <dons> hey, i've got 16 and 8 :)
21:50:07 <sorear> I have 4 idle cores in my house
21:50:17 <sorear> too bad I don't have permission to use them
21:50:21 <dons> but a fair few have 2 cores now, in their mac laptops
21:50:36 <dons> and you can get a 16 core mips box for $3k
21:50:42 <t35t0r> yes i've got access to a 56p that used to 64 before one of the nodes went must
21:50:57 <t35t0r> 56p mips R12000K 300MHz
21:51:00 <sorear> dons: remember my sort?  some idiot set LC_ALL=en_US in the system rcfiles
21:51:04 <dons> hehe
21:51:31 <sorear> LC_ALL=C (a) makes sort give the right answer (b) makes sort much faster (IO bound)
21:51:33 <t35t0r> origin 3000 ..used to be property of ford before we got it >
21:51:52 <dons> nice
21:52:03 <t35t0r> still cost us ~300K i think
21:52:19 <dons> the new 16 core amd64 box cost $24k
21:52:21 <dons> so that's not too bad.
21:52:29 <dons> 16 sparc cores cost 10x that
21:52:58 <t35t0r> altix xe, 8p per node ..but it's numa :>
21:53:12 <t35t0r> quad intel
21:54:50 <t35t0r> runhugs: Error occurred
21:54:50 <t35t0r> ERROR "libraries/bootlib/Data/HashTable.hs" - Can't find imported module "Control.Monad"
21:54:59 <t35t0r> while running make on hugs98-Sep2006
21:55:39 <sorear> does hugs do parallelism ?
21:56:11 <t35t0r> i don't know but i can't get it to compile
21:57:25 <sorear> ghc takes 90m to compile on my 2Ghz P4 ...  but you need ghc to compile it
21:57:41 <sorear> no, not months :)
21:58:06 <lisppaste2> metaperl annotated #33395 with "my continuation passing style example is failing..help please" at http://paste.lisp.org/display/33395#4
22:00:22 <t35t0r> sent email to hugs-bugs
22:03:36 <metaperl> ignore my paste. I figured it out
22:11:42 <dons> t35t0r: try ghc
22:12:02 <dons> you'll want a compiler with an smp runtime, rather than the hugs interpreter. ghc comes with ghci too, a bytecode interpreter
22:12:28 <dons> possibly t35t0r doesn't provide HashTable? though that shouldn't break the build
22:12:52 <sorear> dons: LC_ALL=C sort -u took 59m real 22m user
22:13:11 <sorear> (the LC_ALL=en_US sort was aborted at 3h)
22:13:36 <sorear> THe output is 8.4GB
22:14:14 <lisppaste2> metaperl annotated #33395 with "YAHT cps example failing.. " at http://paste.lisp.org/display/33395#5
22:39:41 <shankys_> Does anyone here have experience using Haskell to test Network.CGI code?
22:50:42 <dons> shankys_: mm. to test eh? sounds like a job for HUnit
22:50:54 <dons> probably bringert or nibro have experience there
22:51:06 <shankys_> yeah I looked at HUnit
22:51:19 <shankys_> I guess QuickCheck wouldn't really help me here
22:53:14 <shankys_> dons: Do you know of any large project that makes extensive use of HUnit whose source I could study?
22:53:33 <glguy> whee, what a busy holiday
22:54:10 <TSC> shankys_: I think Edison uses HUnit
22:54:31 <shankys_> TSC: Is that Osaki's functional data structure library?
22:55:00 <TSC> Yeah
22:55:37 <shankys_> TSC: Alright thanks. I wasn't aware that Edison used HUnit. I'll take a look.
23:07:02 <sorear> dons: (I'm still very new at this) What would the best way be to send my (big, controvertial-sounding, still-breaks-a-few-things, hasn't-been-updated-wrt-hsplugins-advice) change that separates protocol handling out to the plugin-layer?  just plain darcs send?
23:08:29 <dons> mmm. test test test. once it /works/ darcs send, and it goes into the repo
23:08:34 <dons> don't send till it works
23:08:45 <dons> don't worry about the hs-plugins issues yet though
23:08:56 <dons> it just shouldn't break the standard static build
23:09:09 <dons> but i need a lot of testing.
23:09:50 <dons> ?users
23:09:51 <lambdabot> Maximum users seen in #haskell: 309, currently: 245 (79.3%), active: 20 (8.2%)
23:21:08 <JohnMeacham> hizizzle.
23:21:15 <sorear> hi JM!
23:21:26 <sorear> dons: I've gotten the logs down to 41MB
23:25:52 <Cale> http://programming.reddit.com/info/vzw8/comments/cw1ed :)
23:25:54 <lambdabot> Title: Ask Reddit: What&#39;s your language of choice, and why? (reddit.com)
23:30:04 <dons> sorear: mm. almost the size we could stick in lambdabot ;)
23:30:35 <dons> Cale: :)
23:30:50 <dons> I think ayineu must have an openbsd/sparc64 (or maybe openbsd/ppc)
23:32:05 <Cale> Is there an older build of GHC on those platforms?
23:34:15 <dons> neither sparc64 or ppc, I don't have access to them
23:34:23 <dons> so it does require a .hc port
23:47:06 <sorear> replacing bzip2 with 7z, the logs have reached 39.58 MiB
23:47:15 <geckosenator> why would you use 7z?
23:47:21 <geckosenator> because it's 1% smaller?
23:47:27 <sorear> Yeah!
23:47:28 <geckosenator> and takes 20x longer
23:47:36 <sorear> Yes!
23:47:41 <geckosenator> i use gzip
23:47:52 <sorear> You know what took 40x longer than 7z?
23:47:56 <geckosenator> what?
23:48:16 <sorear> My experimental clever coding that increased the compressibility of the data by 5%!
23:48:35 <geckosenator> so it's specialized for your data?
23:48:38 <sorear> This was entirely a question of "how small can it get?"
23:48:42 <sorear> yes.
23:48:53 <t35t0r> you can get it very small by applying neural network compression
23:48:53 <geckosenator> for log files?
23:48:58 <sorear> yes.
23:49:02 <geckosenator> t35t0r: you did that?
23:49:09 <t35t0r> no
23:49:18 <geckosenator> it sounds hard, how do you know it works?
23:49:26 <t35t0r> it requires testing of the input data
23:50:01 <sorear> My system is very simple.  I sorted the logs by nick and then I separated the columns.
23:50:01 <t35t0r> geckosenator, it's rather simple just depends on how many bits you have in and if for all bits in you can reduce the encoding using backpropagation or feed forward to 3 or less level 2 neurons
23:50:19 <geckosenator> t35t0r: who has used it for compression?
23:50:36 <sorear> the sorting is the important part - it causes lines generated by the same nick (hence same writing style) to be grouped together.
23:50:38 <geckosenator> sorear: dictionary on words?
23:50:40 <t35t0r> geckosenator, just by using a feed forward neural net like that you are compressing the data
23:50:55 <t35t0r> by using a multilevel feed forward network
23:50:57 <geckosenator> t35t0r: and also corrupting it if you make it too small
23:51:07 <t35t0r> geckosenator, right that's why it requires testing of the entire file
23:51:18 <sorear> My dataset, compressed, is 80x larger than /usr/share/dict/words.
23:51:37 <sorear> I think 7zip is already abstracting out common words.
23:52:06 <sorear> (and a not insignificant amount of data is dates+times... ooh idea)
23:56:12 <t35t0r> problem is that you have to learn each dataset perfectly to avoid corruption . learning perfectly by backprop may or may not always work because of getting stuck in local minimums
23:56:40 <t35t0r> similar to hill search
23:57:39 <t35t0r> someone has done some research on theoretical limits on a 2 level feed forward compression net
23:58:49 <t35t0r> the cool part is the psychoacoustic or psychovisual aspect ..that is how much can be lost yet still be considered good quality by human ears/eyes
23:59:57 <sorear> my definition of acceptible is cmp(1); my dataset is 200MB of #haskell logs.
