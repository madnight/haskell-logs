00:00:38 <dancor> @tell dancor can i talk to myself
00:00:38 <lambdabot> You can tell yourself!
00:00:49 <dancor> @tell lambdabot meta
00:00:49 <lambdabot> Nice try ;)
00:01:01 <dancor> i feel so unoriginal
00:01:47 <sorear> @tell dancor Lambdabot will tell you about your new messages when you say something other than a lambdabot command.
00:01:48 <lambdabot> Consider it noted.
00:02:04 <dancor> @tell aoeuidhtnspyfgcrlqjkxbmwvz buffer overflow
00:02:04 <lambdabot> Consider it noted.
00:02:06 <dancor> hi
00:02:07 <lambdabot> dancor: You have 1 new message. '/msg lambdabot @messages' to read it.
00:17:56 <dancor> can you define a show instance on a type
00:18:00 <dancor> or just a data
00:19:02 <dancor> and if just data is it cooler to convert 'type blah = lar' to 'data blah = blah lar' or just make a showBlah fcn
00:28:54 <petter_> dancor: I wonder to, i got some strange error trying to define a show instance on a type declared with "type = ..."
00:31:12 <petter_> but if you declare "type Example = Int" and then define a show instance for it, how will it be determined when it's an "Example" as opposed to just an "Int"?
00:31:40 <dancor> another question, can i do a list comprehension where a var runs over all possibilities of an enum
00:31:53 <dancor> petter_: yeah i don't think it would have any way of knowing
00:31:56 <sorear> it can't. type synonyms are synonymous.
00:32:09 <sorear> dancor: yes.  put deriving(Enum) on your type.
00:32:24 <sorear> e.g. the standard Ordering enum has such a deriving
00:32:43 <sorear> > [ reverse $ show x | x <- [LT .. GT] ]
00:32:44 <lambdabot>  ["TL","QE","TG"]
00:57:49 <petter_> > show []
00:57:50 <lambdabot>  Add a type signature
01:04:21 <opqdonut> > show ([] :: Enum)
01:04:22 <lambdabot>    Class `Enum' used as a type
01:04:22 <lambdabot>   In the type `Enum'
01:04:22 <lambdabot>   In an expression ...
01:04:34 <opqdonut> > show ([] :: Int)
01:04:35 <lambdabot>  Couldn't match `Int' against `[a]'
01:04:41 <opqdonut> > show ([] :: [Int])
01:04:42 <lambdabot>  "[]"
01:04:43 <opqdonut> bah, noskill
01:17:44 <petter_> ghci: "show []" -> "[]"
01:18:29 <petter_> > show ([] : [a])
01:18:30 <lambdabot>  Not in scope: `a'
01:18:36 <petter_> > show ([] :: [a])
01:18:37 <lambdabot>  Add a type signature
01:21:50 <kosmikus> petter_: ghci has some extra defaulting that the lambdabot plugin apparently doesn't use
01:22:23 <kosmikus> petter_: ghci used to behave as lambdabot does now
01:24:10 <therp> a "zonked" expression in GHC slang is a type checked expression, no?
01:26:08 <therp> ah forget that question, google answered it (unexpectedly)
01:54:21 <ski_> morning #haskell
01:54:49 <therp> good morning ski
01:56:25 <araujo> hi!
02:16:59 <petter_> random thought: writing game of life with a board represented as a Set of coordinates rather than an array of arrays
02:21:06 <Itkovian> hi ski_
02:22:12 <Itkovian> petter_: you'd do no walking of the arrays, but I guess you'd end up doing lots of lookups in the Set. It might amount to the same, though perhaps it is more elegant.
02:22:20 <Itkovian> btw, http://digg.com/programming/Lazy_Programming
02:22:21 <lambdabot> Title: digg - Lazy Programming
02:22:32 <Itkovian> time for some serious Haskell advocacy ;-)
02:27:57 <petter_> I thing those comments pretty well represents peoples opinions on haskell, if  I mention it to my coworkers(who are engineers) they look at me like I'm some kind of pervert
02:28:34 <araujo> morning
02:28:43 <opqdonut> :)
02:28:45 <opqdonut> morn
02:31:46 <Excedrin> "definitely. I love doing this stuff in python." ...
02:33:44 <Excedrin> "/Dizzily staggers off to ponder the wonderkinder who think writing four times the amount of needed code to do a job with an OOP language is some form of progress."
02:34:02 <Excedrin> reading comments on digg is depressing to me
02:34:19 <pjd> wow
02:34:46 <pjd> that's worse than i expected, even from other peoples' disdain
02:37:08 <therp> do I understand this correctly, GHC core does not contain anything about type class definition/instance definitions?
02:38:41 <augustss> that's right
02:40:42 <therp> ah that's interesting, I somehow had the impression that type-classes and instances and so on, are carried over to desugar core syntax
02:43:23 <augustss> the core is very simple.  like lambda calculus + case
02:43:54 <augustss> you don't really need case either
02:46:18 <pjd> augustss: is there some kind of tutorial about that?
02:46:42 <augustss> about which part?
02:46:44 <pjd> aimed at building a small toy haskell implementation, for example
02:46:54 <therp> about core? mostly on http://hackage.haskell.org/trac/ghc/wiki/ExternalCore
02:46:57 <lambdabot> Title: ExternalCore - GHC - Trac
02:47:09 <therp> but that's external core which is also a bit different..
02:47:33 <augustss> i don't know about any tutorials, really
02:48:06 <nominolo> pjd, there's the book by simon about compiling lazy programming languages
02:48:12 <augustss> but the core can be done in many different ways.  ghc has picked Fw + data types + coercions
02:48:13 <pjd> simon?
02:48:28 <augustss> simon peyton jones
02:48:29 <nominolo> peyton jones
02:48:34 <nominolo> aka, spj
02:48:35 <pjd> ah, of course
02:48:35 <augustss> he has two books that are excellent
02:48:52 <augustss> also, they are out of print
02:49:04 <augustss> but you can find them online
02:49:20 <pjd> officially?
02:49:42 <pjd> "Implementing Functional Languages: A Tutorial" (1992) ?
02:49:56 <nominolo> http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
02:49:58 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/y6d7fu
02:50:09 <pjd> thanks
02:50:23 <augustss> pjd: officially
02:51:04 <ski_> which one is the other book ?
02:52:47 <augustss> http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm
02:52:49 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/yempzk
02:52:59 <ski_> ty
02:54:09 <augustss> It's too old to use Haskell, but the material is still very relevant
02:54:22 <goltrpoat> heh.. listening to this allegro training program.  the guy is quite the motivational speaker
02:54:40 <augustss> allegro common lisp?
02:54:42 <goltrpoat> yeah
02:56:13 <goltrpoat> we're currently on the bulletpoint titled "* Can't remember the name"
02:56:42 <goltrpoat> exciting stuff.
02:56:42 <goltrpoat> :)
02:57:31 <therp> haha :)
02:57:52 <therp> a friend of mine is working for franz. seems like a nice working environment
02:58:13 <goltrpoat> yah, i bet
03:02:29 <goltrpoat> ok, i just learned that john mccarthy is "not quite as young as he used to be"
03:02:35 <goltrpoat> i think i might need to skip to the next one.
03:02:47 <augustss> it's true
03:03:15 <goltrpoat> hehe
03:07:00 <augustss> is this allegro stuff online?
03:07:14 <goltrpoat> yah, it was posted on reddit earlier.. sec
03:07:21 <goltrpoat> http://www.franz.com/services/classes/download.lhtml
03:07:23 <lambdabot> Title: Franz Inc: Allegro CL Training
03:07:39 <goltrpoat> needs a proprietary viewer that only runs on windows and os x
03:09:23 <augustss> that sucks
03:09:33 <augustss> even if i happen to run macos x
03:10:04 <goltrpoat> yeah, not really sure what the point of that was
03:10:15 <ski_> "*The Meeting Manager for Linux and Solaris is automatically downloaded, installed and configured the first time you start or join a meeting. No manual installers available for Linux and Solaris."
03:11:08 <goltrpoat> oh, missed that
03:12:37 <solar-> htp://www.solarcombat.net << An awesome game! http://www.solarcombat.net/hosting.php << An awesome host!
03:12:39 <lambdabot> Title: Home
03:15:52 <syntaxfree> solar@irc.freenode.net << An awesome spammer!
03:16:29 <goltrpoat> awesomeness all around.
03:19:14 <Excedrin> does HXT implement similar ideas to the "scrap your boilerplate" paper?
03:25:30 <syntaxfree> goltrpoat: do you happen to know if VLC will play this weird "webex" video format?
03:25:58 <goltrpoat> not the slightest idea
03:26:20 <syntaxfree> did you install webex itself?
03:26:25 <syntaxfree> (I mean, the official player)
03:26:31 <goltrpoat> yeah
03:27:25 <pafcu> Is there any standard function for searching for a substring in a string?
03:28:11 <goltrpoat> im guessing the webex player is the only thing that plays webex files, since it seems like a combination of video playback and video conferencing
03:28:27 <goltrpoat> and even if the format is open, the two are probably pretty coupled
03:29:28 <syntaxfree> they should just use flash video like everyone does now.
03:30:44 <syntaxfree> methinks they put the free lessons to push the Webex formst/player.
03:30:52 <goltrpoat> probably
03:31:09 <syntaxfree> One thing is for sure: the Webex people must be experiencing a peak in downloads.
03:31:28 <goltrpoat> well.. actually, i'm guessing they've been using it for their training program for a while now
03:31:53 <syntaxfree> yes, but the training program has become notorious these days.
03:32:29 <goltrpoat> since from the audio content, it seems like the free version is a capture of a video conference type deal, with a bunch of users signed on simultaneously etc
03:35:47 <syntaxfree> hm. on a second look, it looks like an interesting solution for live online tutoring.
03:38:31 <syntaxfree> sound is desynched with the slides, sadly.
03:40:09 <nomeata> pafcu: no, unfortunately not
03:40:45 <nomeata> pafcu: but this might work: isSubstr small large = any (isPrefixOf small) (tails large) (untested)
03:41:10 <nomeata> > let  isSubstr small large = any (isPrefixOf small) (tails large) in "oh" `isSubstr` "hoho"
03:41:11 <lambdabot>  True
03:41:16 <nomeata> > let  isSubstr small large = any (isPrefixOf small) (tails large) in "oh" `isSubstr` "heho"
03:41:17 <lambdabot>  False
03:41:50 <nomeata> Not very efficient, but not as bad as it seems, thanks to lazy evaluation.
03:42:53 <pafcu> nometa Thanks
03:42:57 <jethr0> nomeata: i wouldn't be so sure that it's inefficient
03:43:24 <jethr0> maybe compared to some (*a++==*b++) uglyness :)
03:43:41 <pafcu> It seems to me that it would be a pretty useful function, why is there no standard version?
03:44:14 <jethr0> pacfu: that same question applies to many other things (see MissingH). the problem is being worked on...
03:44:17 <nomeata> jethr0: I mean inefficient as it is not using some smart precalculation and pattern matching
03:44:50 <jethr0> k
03:45:31 <ski_> (hm, interesting example)
03:45:50 <ski_> hm, those type coercions in GHC core reminds me of a type system for reflected equality proofs i sketched ..
03:45:56 <nomeata> jethr0: I think, after all lazy evaluation, it ends up being exactly the naive implementation that anyone would program in an imperative language.
03:46:43 <ndm> nomeata: that will be in the Data.List library with GHC6.8, as isSubstrOf
03:46:44 <jethr0> no idea, but i remember cale (or was it dons) saying that it performed quite well
03:47:05 <nomeata> ndm: with that implementation, or a better one?
03:47:19 <ndm> nomeata: i think its that implementation
03:48:43 <jethr0> what that solution lacks is jumping ahead N places in case of a partial match. what was that pre-calculation algorithm called again? sth with three names
03:48:59 <jethr0> boyer-moore i think
03:49:09 <jethr0> or knuth-morris-pratt
03:49:15 <ndm> jethr0: isn't knuth- yeah, that one
03:50:41 <syntaxfree> this Franz thing is boring.
03:50:44 <jethr0> most important thing is that the function is somewhere in the libs. if it turns out to be stupidly inefficient (like Text.Regexp used to be) at least there's a common function/library people can discuss about
03:51:29 <nomeata> yes, that’s the one I’m talking about :-)
03:51:29 <nomeata> But it needs to inspect the pattern first, so it is not faster for small strings, I guess.
03:53:21 <jethr0> exactly. so you'd have to make a case distinction between short and long string for which you'd need to calculate string length in O(n), even making processing infinite lists impossible :(
03:53:43 <jethr0> or you could execute them in parallel and return the first solution (which again would be slower for short strings)
03:56:41 <goltrpoat> syntax:  i kept thinking it was suddenly going to get interesting.  gave up after half an hour
03:57:54 <syntaxfree> sloooow.
03:57:55 <goltrpoat> jethr0:  why impossible?  you just need to know if the string length is greater than some number, right
03:57:58 <syntaxfree> the guy is slow!
03:58:15 <goltrpoat> not what the string length actually is
03:58:20 <jethr0> goltrpoat: you're right. i was thinking of using "length"
03:59:07 <ski_> hm .. a lazy "at least" integer type could be interesting
04:00:19 <jethr0> ski_: how do you mean lazy? isn't "at least" pretty strict, or am i just not getting it?
04:00:46 <nomeata> goltrpoat: even that might be a bad idea. Imagine it is very expensive to found out if a list has one more element (because that causes a large thunk to be evaluated)
04:01:11 <nomeata> goltrpoat: then you would not want to find out anything more about the list any absolutely neccessary to find the first match
04:01:23 <ski_> jethr0 : i'm meaning something that would allow 'myLen [0..] > 10' to terminate with 'True'
04:01:38 <goltrpoat> nomeata:  i think the whole idea of automatically switching between naive string matching and boyer-moore, say, seems somewhat misguided, come to think of it
04:01:50 <goltrpoat> why not provide both and let the client code deal with it
04:02:11 <ski_> jethr0 : i.e., instead of the integer either being not computed, or computed, it could be partially computed (i.e. "at least 5", say), and that could be refined later
04:02:15 <jethr0> ski_: ah, i get it. not sure how to do that w/o ghc hacking though...
04:02:44 <jethr0> using your own comparison operator that should work
04:02:49 <nomeata> Or just use the advanced one in any case. When matching short strings, performance is probably not as big of an issue as with large strings.
04:02:58 <ski_> jethr0 : yes
04:03:05 <goltrpoat> well, unless you're matching gajillions of small strings against small strings
04:03:42 <goltrpoat> eg, searching for words with a given root
04:04:00 <ski_> jethr0 : hm .. actually using 'data Nat = Zero | Succ Nat' possibly works .. but the standard implementation of that uses a lot of space, compared to 'Int' and 'Integer'
04:04:37 <nomeata> BTW, isn’t hat the same as [()]?
04:04:44 <jethr0> ski_: yes, i was thinking that it might be possible by using "evil" type system magic
04:06:06 <ski_> of course one can imagine intervals and not just "at least"
04:06:09 <nomeata> It seems to be isomorphic.
04:06:20 <syntaxfree> goltrpoat: I sat through. Now he's showing code snippets that are  "not trivial" and he doesn't expect anyone to understand.
04:06:49 <ski_> (but the point would be that these intervals are not necessarily the "final say", it's just an approximation, which could be refined later)
04:08:52 <goltrpoat> syntaxfree:  i liked the explanation of factorials.
04:09:06 <goltrpoat> "if you have an integer, then the factorial of that integer is that integer times all integers less than that integer"
04:09:09 <goltrpoat> brilliant!
04:09:32 <syntaxfree> and then he mixes in formatting ocde for no good reason.
04:10:49 <jethr0> goltrpoat: assuming he means naturals and not integers. otherwise he'd have to say "... less than that integer but greater equal 0"
04:11:02 <goltrpoat> yeah
04:11:10 <goltrpoat> he neglected the positive part
04:11:31 <goltrpoat> thereby summarily condemning the factorial function to be identically zero
04:11:51 <nomeata> goltrpoat: not for negative input
04:12:38 <jethr0> > product [10,9,..]
04:12:38 <goltrpoat> well, as long as we have factorials of negative numbers, not all is lost, i guess.
04:12:39 <lambdabot>  Parse error
04:13:42 <sieni> > product [10,9..]
04:13:42 <jethr0> > product [10,9..]
04:13:46 <lambdabot> Terminated
04:13:50 <lambdabot> Terminated
04:13:54 <sieni> :P
04:14:13 <jethr0> so i guess factorial = _|_
04:14:53 <nomeata> goltrpoat: the problem is, the function will not be defined, as it is an infinite product of negative numbers, and not converging to zero, so you can’t even know the sign
04:15:15 <goltrpoat> technicalities!
04:15:16 <nomeata> > product [-1,-2..]
04:15:19 <lambdabot>  Terminated
04:15:39 <nomeata> > map product $ inits [-1,-2..]
04:15:40 <lambdabot>  [1,-1,2,-6,24,-120,720,-5040,40320,-362880,3628800,-39916800,479001600,-6227...
04:16:57 <ski_> i saw a paper which was about (refinable) interval arithmetic over reals .. they implemented newton-raphson functionally with it :)
04:23:28 <dcoutts__> @tell mgsloan ping me about gtk2hs win32 bins sans installer next time you're around
04:23:29 <lambdabot> Consider it noted.
05:12:38 <fabiim> can i declare instances for type variables? Or only to declared  data types?
05:15:58 <ski_> the former only with experimental extensions (at least hugs,ghc)
05:31:19 <edwinb> I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
05:31:56 <ndm> @quote edwinb I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
05:31:56 <lambdabot> edwinb I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them. hasn't
05:31:57 <lambdabot> said anything memorable
05:32:03 <ndm> @quote+ edwinb I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
05:32:04 <lambdabot> edwinb I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them. hasn't
05:32:04 <lambdabot> said anything memorable
05:32:12 * edwinb gets his coat
05:32:48 <ski_> @remember edwinb I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
05:42:15 <lisppaste2> glguy annotated #33091 with "Some optimizations" at http://paste.lisp.org/display/33091#1
06:13:29 <bringert> Swedish rocks. I just used this word in an email: "vänsterrekursionselimineringsalgoritmen"
06:13:49 <bringert> and that's the only reasonable way to say it
06:13:55 <ndm> > "vänsterrekursionselimineringsalgoritmen" in English
06:13:57 <lambdabot>  Parse error
06:14:06 <ndm> doesn't seem to be working :(
06:14:11 <opqdonut> left recursion elimination -algorithm
06:14:19 <opqdonut> off the top of my head
06:14:29 <bringert> *the* left recursion elimination -algorithm
06:14:48 <Lor> You left out the ? from v?nster.
06:15:17 <Lor> Or is non-ascii banned here?
06:15:21 <cyberix> I can't figure out how to configure my NIC (network interface card) in House. Is there a manual or howto somewhere?
06:15:30 <therp> lor: utf-8
06:15:43 <pjd> Lor: he's using UTF-8, think you're latin-1?
06:19:07 <Lor> Hm, my client filtered out utf-8 completely? My bad, then.
06:19:37 <therp> most clients understand /charset utf-8 (or without the dash)
06:20:44 <opqdonut> irssi & recode <3
06:20:57 <pejo> cyberix, does it support anything else than eepro100?
06:23:08 <cyberix> House is based on ... To this, we have added ..., A driver for NE2000 compatible network cards (Iavor Diatchki). (This is the type of card emulated by QEMU.), A driver for Intel PRO/100 network cards (Thomas Hallgren). (This is the type of card found in e.g. IBM Thinkpad laptops.), ...
06:23:27 <cyberix> cyberix@bunnypump:~$ lspci | grep Ethernet
06:23:27 <cyberix> 00:0d.0 Ethernet controller: Intel Corporation 82557/8/9 [Ethernet Pro 100] (rev 0c)
06:24:12 <Lor> How about now? id:∀X.X→X
06:24:31 <wolverian> Lor, welcome to the wonderful world of utf8
06:24:55 <wolverian> (although those are double-width characters, at least in my font, so that looks a bit strange.)
06:25:11 <wolverian> (or maybe they're just not in this font, and freetype uses another font's incompatible glyphs.)
06:25:12 <cyberix> ☃
06:25:27 <bringert> what is that?
06:25:52 <Cale> snowman
06:26:10 <ioerror> UTF-8 really has everything
06:26:16 <cyberix> http://www.fileformat.info/info/unicode/char/2603/browsertest.htm
06:26:17 <lambdabot> Title: Browser Test Page for Unicode Character 'SNOWMAN' (U+2603)
06:26:44 <araujo> that's an alien character or what?
06:27:28 <ventonegro> > "☃"
06:27:28 <lambdabot>  lexical error in string/character literal
06:27:58 <Cale> ⚗
06:29:11 <Cale> 𐂂
06:29:59 <araujo> nothing
06:30:51 <Cale> That last one is Linear B Ideogram B104 Deer
06:31:16 <Cale> 𐃌 Wheeled Chariot
06:38:45 <pejo> All this UTF-8 and escape sequences are lovely, but they make my info-line end up in the middle of the screen.
06:58:01 <dblhelix> kosmikus: does the machine terminate on all input?
07:11:40 <Saizan> ?where dons
07:11:44 <lambdabot> http://www.cse.unsw.edu.au/~dons
07:13:57 <justinhj>  /join #lisp
07:15:20 <ndm> mwc: do you mean you should tag int's, or you shouldn't?
07:16:15 <nomeata> @type ():[]
07:16:20 <lambdabot> [()]
07:17:10 <nomeata> So, is [()] isomorphic to data Nat = Null | Succ Nat?
07:17:55 <sjanssen> not quite
07:18:01 <augustss_> almost
07:18:08 <sjanssen> Nat can't represent [undefined, ()]
07:18:10 <Igloo> But with [()] you have two values _|_ : [] and () : []
07:18:33 <mwc> ndm, I meant that it's ridiculous to tag ints. Ocaml seems to target itself at the users using C outside of the kernel. It's bizarre that they picked a tagging system that forces you to box all the data you want to share with the outside world: graphics libs, network, etc.
07:18:51 <mwc> MLton's GC gets by with unboxed ints, GHC can do it
07:19:08 <ndm> mwc: do you mean putting int's in boxes, or reserving some bits for tagging?
07:19:28 <Lor> How do you mean bizarre? It makes the compiler much simpler, since you can just erase types.
07:19:45 <nomeata> sjanssen: so what about data List a = Empty | Cons !a List,  and then List ()? (if that is correct syntax after all)
07:19:51 <ndm> mwc: i think tagged int's would speed up things in GHC, thats my guess
07:19:59 <nomeata> basically, a [()] with strict contents
07:20:05 <sieni> http://kotisivu.mtv3.fi/ksa/files/copter.swf
07:20:11 <sjanssen> nomeata: I'd say they're isomorphic then
07:20:26 <mwc> Well, boxing in haskell also plays a part with lazyness, afaik
07:20:30 <nomeata> But [!()] is not a valid type, is it?
07:20:41 <augustss_> no
07:20:50 <sjanssen> nomeata: correct, ! isn't part of a valid type
07:20:52 <mwc> but in Ocaml, there's no lazyness inherent to the language.
07:21:05 <ndm> mwc: yes, you can't unbox a lazy value, but if you have tagging you don't need to pay for the box on an evaluated int
07:21:22 <mwc> right, but let's look at Ocaml, which is what I was talking about
07:21:39 <mwc> their domain is to bring FP to a C-like language
07:22:11 <ndm> oh, yeah, in a strict language i wouldn't tag int's, i'd unbox them all
07:22:11 <augustss_> tagged ints are cool.  But for ffi you should have untagged ones as well.
07:22:14 <mwc> the MLton compiler (SML) doesn't tag, doesn't box.
07:22:32 <ndm> but i think a haskell compiler with tagged int's would go faster
07:22:43 <ndm> i have half of that back end written for such a compiler, but never got it finished
07:22:53 <augustss_> i agree
07:23:10 <augustss_> and the haskell standard even allows for it :)
07:23:29 <ndm> yes, its great :)
07:23:53 <mwc> augustss_, that was my point, it plays merry hell with interfacing with all manner of C libs... OpenGL, SDL, network stuff, etc. So if you plan on interacting with the outside world a lot, you have to start boxing large amounts of data.
07:23:53 <ndm> i also want tagging on thunks, so you don't have to jump into an evaluated thunk
07:24:30 <nomeata> Hmm. Might this be a relatively efficient lazy nat type: data LazyNat = Null | LazyNat !Integer LazyNat, which would store compress a bunch of already evaluated Succ(Succ(Succ... into the integer.
07:24:36 <augustss_> mwc: yes, to interoperate you need to play on C's terms
07:24:54 <augustss_> nmd: jumping is so 20 years ago
07:25:13 <augustss_> when jumps were cheap
07:25:55 <ndm> nomeata: someone at york did a project on that, using a lazy integer with a strict component under the covers
07:26:20 <ndm> agreed, i nearly cried when i saw GHC pays two indirect jumps to evaluate something thats already evaluated
07:26:21 <augustss_> Colin Runciman has some paper about Nats
07:26:27 <ndm> not online :(
07:26:35 <ndm> i had to walk to his office to get a copy...
07:26:40 <norpan> http://☃.com/ does exist, that's kind of cool
07:26:53 <augustss_> way cool!
07:27:45 <shoffsta> bringert: How do I change the ghci parameters that get used in dyn-cgi?
07:28:10 <bringert> shoffsta: what kind of parameters?
07:28:12 <shoffsta> bringert: I have some code that uses template-haskell, which won't run without the -fglasgow-exts and -fth flags.
07:28:28 <bringert> shoffsta: set them in the OPTIONS_GHC pragma
07:28:46 <shoffsta> ok
07:28:47 <bringert> shoffsta: you working with shankys?
07:28:52 <shoffsta> yes :)
07:28:57 <augustss_> norpan: I get to some web hosting looking page when I go to http://☃.com/
07:29:11 <mwc> huh
07:29:20 <norpan> augustss_: yes, but it exists
07:29:22 <mwc> host .com
07:29:22 <mwc> host: '.com' is not a legal name (empty label)
07:29:41 <augustss_> norpan: I should register it
07:29:45 <syntaxfree> it's not .com, it's http://☃.com/
07:29:56 <mauke> U+2603 (0xe2 0x98 0x83): SNOWMAN [☃]
07:30:01 <augustss_> which registrars do unicode names?
07:30:03 <allbery_b> getting shells to accept unicode can be interesting
07:30:14 <norpan> it can
07:30:23 <sjanssen> http://❄.com/ too
07:30:53 <augustss_> maybe it's some generic redirect
07:30:58 <norpan> ☀.com too
07:31:11 <mwc> Well, my understanding of URL's is that the http:// specifies the protocol to connect to the server with
07:31:12 <norpan> at least they go to different looking places
07:31:21 <mwc> so .com is the actual hostname
07:31:35 <norpan> mwc: you obviously can't see the unicode character there
07:31:41 <syntaxfree> the hostname is ❄.com
07:31:49 <shoffsta> bringert: ok, it works. thanks!
07:32:05 <mwc> norpan, nope
07:32:09 <syntaxfree> ®.com should be a good one.
07:32:35 <syntaxfree> I wonder if one can get away with mic®osoft.com
07:33:30 <mwc> there was a kid who did web designs with the domain mikerowesoft.com
07:33:33 <norpan> ☣.com is evil
07:33:33 <mwc> they sued him
07:33:42 <norpan> it looks like they registered all of those
07:34:13 <syntaxfree> ®.com is different from ☃.com
07:34:17 <norpan> yeah
07:34:34 <ndm> mwc: then appologised and gave him an xbox
07:34:49 <ski_> mwc : maybe MLton can refrain from taggin and boxing since it does full-program compilation ?
07:35:17 <mwc> ski_, maybe, but I think that the two issues are orthogonal
07:37:18 <ski_> mwc : i'm not sure, but if MLton expands polymorphism, then it knows the type of every value, so possibly can get away with boxing and tagging because of that
07:37:23 <augustss> mwc: the information about what a word of memory contains has to be somewhere.  but it doesn't have to be in the word or next to it
07:37:46 <ski_> (of course, the GC can place constraints, too)
07:38:10 <augustss> In ML you can expand away all polymorphism, not so for Haskell
07:38:16 <ski_> right
07:38:52 <ski_> (existentials, polymorphic recursion, gadt, yes ?)
07:39:25 <Lor> I think polymorphic recursion is the only constraint in Haskell 98.
07:39:34 <augustss> polymorphic recursion is the one that sticks out in H98
07:39:54 <ski_> ok
07:40:11 <augustss> but haskell could do polymorphic recursion even before it was officially introduced
07:40:24 <augustss> you had to encode it as a class&instance
07:41:00 <ski_> mhm
07:44:29 <alexj__> @seen shapr
07:44:29 <lambdabot> I saw shapr leaving #haskell, #scannedinavian and #haskell-blah 2d 10h 32m 31s ago, and .
07:44:55 <Ulfalizer> #scannedinavian? :P
07:45:54 <Vq^> Ulfalizer: wanna join? :)
07:46:47 <syntaxfree> what is the simplest way to browse the code of one ghc library?
07:46:56 <syntaxfree> (Text.Regex, to be precise)
07:49:14 <bringert> syntaxfree: source code links in top right hand corner of haddock docs
07:49:30 <syntaxfree> oh. thanks!
07:49:46 <sorear> oh, this is so embarrassing...
07:49:54 <sorear> /msg lambdabot identify <password>
07:50:08 <opqdonut> :DD
07:59:47 <Lemmih> Greetings alexj__.
08:00:00 <alexj__> greetigs lemmih!
08:00:12 <alexj__> how are you today?
08:01:37 <Lemmih> I'm good. Christmas can be a little stressing on my family, though.
08:01:47 <Lemmih> How are you?
08:05:42 <alexj__> I am doing well.  big refactor on the happs http interface.
08:06:16 <alexj__> posted it last night, but realized a bug overnight and am fixing now.
08:06:58 <opqdonut> :)
08:09:48 <alexj__> I've been busy with other non-work things for about a month and now am having time to devote again.
08:09:53 <alexj__> it feels good to be back.
08:13:57 <alexj__> what have you been up to?
08:16:23 <sorear> who?
08:17:02 <alexj__> lemmih:?
08:19:11 <Lemmih> I've been working for a semi-religous group who needed a small piece of software to manage bookings at their seminars.
08:19:15 <Lemmih> It was quite fun and I was allowed to use Haskell.
08:19:47 <alexj__> was it a GUI app?
08:20:11 <Lemmih> Web-application.
08:21:00 <LoganCapaldo> Is this accurate? http://scienceblogs.com/goodmath/2006/12/tail_recursion_iteration_in_ha_1.php#comment-295866
08:21:03 <lambdabot> Title: Good Math, Bad Math : Tail Recursion: Iteration in Haskell, http://tinyurl.com/y3q3x3
08:21:37 <sjanssen> LoganCapaldo: I'd say so
08:21:51 <sjanssen> do you have any specific concerns?
08:21:54 <LoganCapaldo> that's kind of scary
08:22:24 <LoganCapaldo> ah well hopefully there aren't any naive haskell implementations out there :)
08:22:27 <Saizan> LoganCapaldo: are you talking of Pseudonim comment?
08:22:30 <LoganCapaldo> Yeah
08:23:08 <alexj__> did you use happs for the webapp? :-)
08:24:22 <Saizan> well i was convinced that since (+) is strict in their arguments it evaluates istantly, but maybe you need foldl' for that
08:24:33 <Lemmih> alexj__: I thought about it. In the end I went with something simpler, though.
08:24:49 <Saizan> s/their/her/
08:24:56 <Saizan> s/their/its/
08:24:58 <Saizan> :D
08:25:06 <sorear> Saizan: (+) on Int{eger}s is strict; I don't think it need be in general
08:25:08 <alexj__> interesting.  what did you end up doing?
08:25:31 <Saizan> uh right
08:25:31 <alexj__> if you decided against then something obviously needs to be fixed!
08:26:04 <ski_> that '(+)' (on 'Int') is strict means that it will evaluate its arguments, *when* the result is demanded (as always)
08:26:57 <SamB_XP> (+) is probably always strict in at least one argument
08:26:59 <alexj__> lemmih: what did you end up doing?
08:27:03 <ski_> the problem is that, barrin strictness analysis, it won't realize until the end that any of the additions need to be performed
08:27:12 <LoganCapaldo> things like that almost make me want to not care how I write the function. I think this might be a good thing.
08:27:17 <Saizan> ski_ yes, but i was assuming that the result from foldl is demanded, so it would the result of (+)
08:27:39 <SamB_XP> Saizan: all the demands would stack up at once though
08:27:52 <sorear> SamB: data Rat = Rat Integer Integer ; (+) :: Rat -> Rat -> Rat ; _|_ + _|_ = (Rat _|_ _|_)
08:28:06 <ski_> sumList [3,4,5,6]
08:28:08 <ski_> sumLoop [3,4,5,6] 0
08:28:14 <ski_> sumLoop [4,5,6] (0 + 3)
08:28:22 <ski_> sumLoop [5,6] ((0 + 3) + 4)
08:28:26 <SamB_XP> sorear: huh?
08:28:31 <ski_> sumLoop [6] (((0 + 3) + 4) + 5)
08:28:35 <SamB_XP> I don't think you can pattern match on _|_
08:28:36 <ski_> sumLoop [] ((((0 + 3) + 4) + 5) + 6)
08:28:40 <Lemmih> alexj__: I made a simple wrapper over the CGI monad to support sessions and XML+XSL.
08:28:41 <sorear> (the standard rationals are data Ratio a = !a :% !b, so they are strict
08:28:41 <ski_> ((((0 + 3) + 4) + 5) + 6)
08:28:45 <ski_> (((3 + 4) + 5) + 6)
08:28:48 <ski_> ((7 + 5) + 6)
08:28:52 <sjanssen> Saizan: even though (+) is strict in both arguments, Haskell will still make a thunk out of (x + y)
08:28:53 <ski_> (12 + 6)
08:28:56 <ski_> 18
08:29:01 <nomeata> can someone optimize ski_ please?
08:29:01 <opqdonut> ski_: thanks!
08:29:09 <nomeata> :-)
08:29:19 <Saizan> ook
08:29:21 <alexj__> and then you ran apache?
08:29:24 <sorear> oh, sorry, meant to be an example - any total function returning Rat returns the Rat constructor, so (+) is lazy...
08:29:25 <ski_> (and similarly with 'foldl')
08:29:42 <SamB_XP> sorear: what I meant was that the top-level constructor of at least one argument would probably be demanded by most (+)s
08:29:52 <flagitious> hi, im new to haskell and im about to head to the bookstore to buy a book on it, does anyone have a recommendation for best haskell book?
08:30:21 <SamB_XP> sorear: that is enough to count as "strict", technically
08:30:30 <alexj__> lemmih: I want happs to be the obvious default option.  did you really want apache functionality?  why was it simpler?
08:30:34 <Saizan> so the only benefit of foldl is to minimize the number of stack frames?
08:30:45 <SamB_XP> Saizan: you mean foldl'?
08:30:48 <Saizan> in respect of foldr (disregarding order)
08:30:50 <sorear> I'm pleasantly suprised haskell is popular enough to have books in generic bookstores.
08:31:05 * ski_ thougt "Haskell: The Craft of Functional Programming" by Simon Thompson was nice
08:31:07 <flagitious> oh, it might not have any i guess, but it is a big book store
08:31:08 <sjanssen> Saizan: foldl is nearly useless, you should almost always use foldl' instead
08:31:12 <jethr0> flagitious: i just rereading "the craft of functional programming" and it's superb
08:31:19 <SamB_XP> I think the documentation for foldl should say what it is good for
08:31:26 <flagitious> ok craft of functionl programming it is, if i see it, thanks
08:31:29 <syntaxfree> Haskell is building a lot of cool-factor right now.
08:31:32 <SamB_XP> (that is, when you should use it over foldl')
08:31:36 <LoganCapaldo> I saw an O'Reilly book the other day with a title of Monad
08:31:36 <SamB_XP> its too hard to remember!
08:31:38 <Lemmih> alexj__: I used lighttpd. My need were to limited to exploit HAppS to it's full potential. I basically just had to generate some XML from some database records.
08:31:45 <LoganCapaldo> It wasn't about what I thought
08:31:55 <syntaxfree> You can already see people spouting nonsense like "Haskell will replace outdated scripting languages like Perl" in Slashdot.
08:31:58 <sorear> hehehe, I've heard of it too
08:32:07 <SamB_XP> syntaxfree: well.
08:32:13 <SamB_XP> so maybe they are going a bit overboard.
08:32:24 <SamB_XP> there is perhaps a grain of truth in it
08:32:25 <syntaxfree> All I'm saying that's a sign of popularity.
08:32:29 <alexj__> lemmih: yeah.  the database support isn't great yet.  but I think the new API should make that a lot easier.
08:32:30 <jethr0> flagitious: for advanced topics "the fun of programming" is nice (collection of essays). and for functional programming in general "Structure and interpretation of Computer Programs" is nice, although done with scheme
08:32:39 <SamB_XP> but we better prepare a new name for future development to take place under!
08:32:49 <SamB_XP> before they all actually start to *use* haskell
08:32:56 <sorear> I'm already dreading the day I'll have to fork haskell to stop the newbies and educators from dumbing it down for the masses...
08:33:09 <SamB_XP> sorear: um, too late
08:33:10 <jethr0> sorear: :)
08:33:15 <SamB_XP> witness Haskell 98!
08:33:17 <syntaxfree> Sure, the community will be a little less fun when there are Gentoo-ish kiddies on Slashdot claiming that all programming should be lazy anyway.
08:33:19 <alexj__> lemmih: would it be ok to look at the code to see whether we can make it simpler to do that sort of task with HAppS?
08:33:30 <SamB_XP> of course, they didn't dumb it down *too* much
08:33:39 * Lemmih looks at his spelling and concludes he must be tired.
08:33:44 <SamB_XP> Lemmih: heh.
08:33:49 <SamB_XP> I spell badly all the time!
08:34:02 <SamB_XP> your grammar though...
08:34:03 <ski_> flagitious : "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak could be interesting, too
08:34:17 <syntaxfree> Hudak posted on Haskell-cafe today.
08:34:24 <SamB_XP> oh, I need to take the dog out...
08:34:29 <jethr0> ski_: yes, but it's a bit too much about visuals and music for my taste
08:34:40 <SamB_XP> jethr0: hmm?
08:34:50 <syntaxfree> ski: does it employ OpenGL/GLUT for the visual programs?
08:34:52 <SamB_XP> what would you prefer?
08:35:00 <SamB_XP> syntaxfree: no
08:35:11 <SamB_XP> syntaxfree: it uses *.SOE
08:35:12 <jethr0> SamB: i meant that i didn't like "school of expression" that much
08:35:22 <Lemmih> alexj__: You want to look at the code I wrote?
08:35:25 <SamB_XP> syntaxfree: which for some reason does not support text measuring :-(
08:35:27 <syntaxfree> SamB: and that is..?
08:35:38 <ski_> syntaxfree : haven't read it ;)
08:35:45 <SamB_XP> jethr0: I meant, what do you prefer over visuals and music?
08:36:00 <SamB_XP> @hoogle SOE
08:36:01 <lambdabot> Network.Socket.SoError :: SocketOption
08:36:03 <SamB_XP> hmm.
08:36:12 <SamB_XP> @google gtk2hs SOE
08:36:14 <alexj__> lemmih: yes.  I want to understand what use case is not currently covered.
08:36:14 <lambdabot> http://www.archivesat.com/Haskell_libraries/thread1450306.htm
08:36:15 <lambdabot> Title: Graphics.SOE.Gtk
08:36:17 <ski_> http://haskell.org/soe/
08:36:18 <lambdabot> Title: Home Page
08:36:20 <syntaxfree> oh.
08:36:34 <SamB_XP> syntaxfree: there are various modules with "SOE" in the name
08:36:34 <alexj__> I really want HApPS to be the obvious answer for any of these tasks.
08:36:38 <syntaxfree> Hudak basically wrote a lot of software for his book.
08:36:48 <jethr0> SamB: "learning functional programming through multimedia" just isn't my thing. i'm much in favor of the approach in "the craft of functional programming"
08:37:05 <SamB_XP> most of them are supposed to implement the graphics API used in book
08:38:29 <Modius> Is Craft of Functional Programming a good first book for Haskell for someone well versed in FP but new to Haskell, or is there something better for that?
08:38:44 <syntaxfree> I like the Gentle Introduction for that.
08:38:44 <Lemmih> alexj__: Not sure if I can share the code. I used a similar system for http://catenova.org/, though.
08:38:48 <lambdabot> Title: Catenova - The Ultimate Collection
08:39:04 <syntaxfree> the Gentle Introduction basically assumes previous FP knowledge, not to mention why you want types.
08:39:18 <syntaxfree> @google gentle introduction to haskell
08:39:19 <lambdabot> http://www.haskell.org/tutorial/
08:39:19 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
08:39:40 <alexj__> lemmih: what is catenova?
08:39:44 <jethr0> Modius: the basics in CFP are good for beginners, but the second half get's pretty advanced. some haskell tutorial do a better jobs at introducing than the books IMO
08:40:08 <Lemmih> alexj__: Bittorrent indexing site for TV series.
08:40:32 <Lemmih> (a pet project of mine)
08:41:16 <alexj__> looks useful.
08:41:23 <alexj__> and you didn't use happs for that either?
08:41:35 <pejo> jethro, in the second edition?
08:41:55 <alexj__> lemmih: and you didn't use happs for that either?
08:41:57 <jethr0> pejo: of which book?
08:42:01 <Lemmih> alexj__: No, I didn't.
08:42:08 <pejo> jethro, CFP
08:42:19 <alexj__> lemmih: same reason?
08:42:37 <glguy> strong typing is for weak people...
08:43:08 <jethr0> pejo: i'm not sure. i think i've got the first edition in front of me
08:43:23 <ski_> ('strong typing' /= 'static typing', i think :)
08:43:44 <jethr0> scheme has strong dynamic typing, i think
08:44:00 <Lemmih> alexj__: Yes, basically.
08:44:03 <jethr0> C has weak static typing
08:44:24 <sorear> but... what does 'weak' mean?
08:44:35 <ventonegro> coercion-friendly
08:44:37 <syntaxfree> weak means implicit coercions?
08:44:47 <alexj__> lemmih: hmm thats something I really want to fix.
08:44:51 <jethr0> i think it means whether you can cast from one type to another. in C you can cast from anything to anything, basically
08:44:52 <syntaxfree> I never worried about types in Scheme.
08:44:58 <sorear> Haskell has unsafeCoerce#, but you have to go out of your way to use it and it carries a heavy stigma.
08:45:07 <alexj__> lemmih: what sort of complexity do you feel like HappS was forcing on you?
08:45:08 <syntaxfree> what is a type cast, really?
08:45:08 <jethr0> syntaxfree: the interpreter did that for you
08:45:13 <ski_> sorear : basically that the program can "go wrong" .. like unchecked things leading to undefined behaviour
08:45:15 <pejo> jethro, according to the foreword of the second edition they redid quite a lot of the organization in the book.
08:45:51 <syntaxfree> isn't fromIntegral a type cast, in some sense?
08:45:52 <jethr0> pejo: k, but i couldn't imagine it getting worse, or did it?
08:46:04 <ski_> syntaxfree : no, that's a coercion
08:46:45 * ski_ realizes there probably is multiple different uses of these words .. :/
08:47:05 <glguy> object-oriented programming models the real-world
08:47:33 * jethr0 is pretty sure that "weak typing" signifies wide-ranging possibilities of casting. but i'm not so sure in these matters either
08:47:36 <pejo> jethro, I think it was better. They had observed people didn't start using the Prelude if they got used to writing map themselves in the beginning.
08:47:42 <jethr0> glguy: *yeah, right*
08:48:08 <jethr0> pejo: yes, that was my main criticism of the first edition. they didn't use ANY prelude functions at all
08:48:46 <SamB_XP> glguy: very very badly
08:49:02 <SamB_XP> it really more models a way people think about the world, than it actually models the world
08:49:06 <Lemmih> alexj__: The initial learning curve is more steep than with the simple model I used. I know that's not a good reason but I wanted to play with a prototype asap (:
08:49:25 <jethr0> glguy: that's been the argument for OO, but in reality OO has more difficulties representing realityt 1:1 than many other paradigms :)
08:49:50 <alexj__> lemmih: fair enough.  the learning curve was the reason for the happs refactor.  I'll post the cleaned up SimpleHTTP2 again shortly.
08:49:55 <glguy> being is troll is boring... back to being helpful I guess :-(
08:49:57 <mauke> glguy: wait, were you serious?
08:50:05 <mauke> ok, good
08:50:08 <glguy> You guys take all the fun out of it
08:50:14 <jethr0> i thought it was a joke, too
08:50:20 <glguy> I don't know how people like protontorpedo can keep going at it
08:50:27 <pejo> jethro, not everything in the world is objects, but it's nice to have htem sometimes.
08:50:40 <SamB_XP> jethr0: what paradigm supports a 1:1 representation of reality?
08:50:54 <LoganCapaldo> Reality Oriented Programming ;)
08:51:13 <paolino> ola , I'd like to understand a bit of typesystem,
08:51:14 <paolino> I have this mehod :    value :: g a -> Reader s a
08:51:14 <paolino> what is the difference between
08:51:14 <paolino> class (Meanable a) => Graph g a where
08:51:14 <paolino> class (Meanable a) => Graph g s a | g -> s where
08:51:14 <paolino> around it ?
08:51:17 <glguy> is Haskell bette than Smalltalk?
08:51:21 <syntaxfree> The reality is what computers are actually able to do.
08:51:23 <SamB_XP> glguy: no
08:51:28 <SamB_XP> haskell is not better than smalltalk
08:51:31 <syntaxfree> That is, machine language.
08:51:35 <jethr0> SamB_XP: oh my god, i started a flamewar... none does, but OO has serious shortcomings that don't correspond to problems in reality
08:51:48 <jethr0> glguy: you can stop now
08:52:00 <Tanuk-> If I'd want to try web programming with Haskell, what features would it require from the server? Do some Haskell libs have to be installed there?
08:52:01 <syntaxfree> I don't understand the appeal of objects. And I try.
08:52:03 <SamB_XP> I think OO is okay for modeling pretend realities
08:52:13 <syntaxfree> It seems to me objects are like polymorphic types attached to functions.
08:52:30 <glguy> jethr0: Don't worry about me, I'm just having fun
08:52:37 <glguy> (trying to at least)
08:52:39 <SamB_XP> it makes more sense in MOO, really it does
08:52:44 <jethr0> as soon as you get into inheritance in OO, you're basically in trouble. because real object hierarchies just don't behave like inheritance
08:52:45 <syntaxfree> Tanuk-: you can always compile to a CGI executable and run it in any web server.
08:52:54 <syntaxfree> There are other means, though.
08:52:57 <SamB_XP> jethr0: true.
08:53:10 <syntaxfree> MOO?
08:53:21 <LoganCapaldo> MUD variant
08:53:22 <SamB_XP> in real life, wizard does not inherit from programmer does not inherit from normal user...
08:53:27 <syntaxfree> ah.
08:53:36 <syntaxfree> we
08:53:40 <Tanuk-> syntaxfree: Good to hear cgi is enough. Thanks.
08:53:45 <Lemmih> alexj__: I'll definitely rewrite Catenova if HAppS becomes my livelihood (:
08:53:47 <syntaxfree> SamB_XP: Well, it does.
08:54:04 <syntaxfree> Tanuk-: there are several better ways that'll require a more prepared server.
08:54:05 <SamB_XP> okay okay so maybe it does.
08:54:13 <glguy> I felt a little slighted after reading the Io Rss-concatenator on prog.redit
08:54:21 <syntaxfree> Tanuk-: There's even a cheap host that supports Haskell. I'm considering opening an account with them myself.
08:54:30 <syntaxfree> (Not associated with them at all)
08:54:35 <alexj__> lemmih: do you have the time to make it your livelihood? :-)
08:54:48 * paolino waves hands
08:54:59 <SamB_XP> but it would be nice if "user" didn't have so many properties and methods you might also want on your HTTP request context thingies...
08:54:59 <syntaxfree> speak up, paolino. :)
08:55:00 <Tanuk-> syntaxfree: Would you mind mentioning the name?
08:55:00 <SamB_XP> er.
08:55:02 <SamB_XP> "player"
08:55:07 <syntaxfree> oh, sure. just a min.
08:55:28 <syntaxfree> https://www.nearlyfreespeech.net/
08:56:00 <Tanuk-> syntaxfree: Bookmarked. Thank you.
08:56:05 <pejo> syntax, I think the AGV controller at http://www.cs.chalmers.se/~nordland/ohaskell/examples.html  is rather elegant.
08:56:08 <lambdabot> Title: Some O'Haskell programming examples
08:56:22 <LoganCapaldo> glguy: well that's what happens when _everything_ is in teh std. lib ;)
08:56:23 <paolino> what is the difference between these classes from the instances pov ?
08:56:23 <paolino> class (Meanable a) => Graph g a where
08:56:23 <paolino> class (Meanable a) => Graph g s a | g-> s where
08:56:46 <paolino> they must implement
08:56:46 <paolino> value :: g a -> Reader s a
08:56:58 <glguy> LoganCapaldo: well, also because it doesn't do the same thing (concatenates vs generates HTML) ... I don't know what an rss aggregator was supposed to do now
08:57:02 <syntaxfree> pejo: Oh, I don't know any O'Haskell.
08:57:22 <syntaxfree> is O'Haskell still pure?
08:57:51 <SamB_XP> syntaxfree: how would it not be?
08:58:00 <SamB_XP> doesn't it just compile to Haskell or somethin?
08:58:02 <LoganCapaldo> glguy: Don't worry I'm sure the perl solution will bother you more. ;)
08:58:05 <glguy> paolino: Do you know that the g -> s is a functional dependancy??
08:58:06 <syntaxfree> dunno. From what I've understood, it's a different language.
08:58:11 <paolino> yes
08:58:17 <glguy> paolino: sorry, one ?
08:58:24 <syntaxfree> Well, isn't theoretically possible to compile nonpure languages into Haskell?
08:58:28 <pejo> syntax, the struct there is essentially what we'd call a record. Except that it's rather similar to Haskell, except the subtyping.
08:58:33 <SamB_XP> syntaxfree: true
08:58:48 <pejo> SamB, no, O'Haskell used a modified Hugs 1.3.
08:58:49 <syntaxfree> pejo: hmm. it seems I should know some OO to understand O'Haskell.
08:58:51 <SamB_XP> syntaxfree: i.e. perl6
08:58:53 <glguy> paolino: I believe you can write an instance that only specifies the g, and implies the s by using it
08:58:53 <bringert> hmm that www.nearlyfreespeech.net ought to run into CPU usage problems
08:59:11 <syntaxfree> bringert: well, it's cheap, and suits my current financial situation.
08:59:15 <glguy> paolino: but I'm only attempting at an answer because no one else seemed to pick it up
08:59:27 <bringert> syntaxfree: what's CUP load like there?
08:59:32 <paolino> glguy, I want to understand what happens to "s" if I put it in the parameters of Graph or not
08:59:41 <syntaxfree> (That is, I can spit out fifty bucks right now, but can't guarantee being able to pay a monthly bill)
08:59:48 <syntaxfree> bringert: Dunno. I haven't opened an account yet.
08:59:49 <LordBrain> syntaxfree: are you porting an OO program to haskell?
08:59:53 <bringert> they only charge for storage and bandwidth, but I thought CPU usage would be the limiting factor for most of todays wasteful PHP-blogs etc
08:59:54 <syntaxfree> I'm wating till after the holidays.
09:00:00 <syntaxfree> LordBrain: no, I'm just curious.
09:00:06 <LordBrain> yeah i was curious too
09:00:07 <syntaxfree> I don't know *any* OOP.
09:00:26 <bringert> syntaxfree: well the deposit is $0.25 so it's cheap to try them out
09:00:28 <LordBrain> oh i know oop, but i was curious about oohaskell, so i downloaded the paper
09:00:37 <SamB_XP> glguy: what would such an instance look like
09:00:55 <glguy> ?paste
09:00:55 <lambdabot> http://paste.lisp.org/new/haskell
09:01:05 <paolino> glguy should be a difference, in what "s" can be in the instances
09:01:33 <SamB_XP> class (Meanable a) => Graph g a where
09:01:34 <syntaxfree> maybe FP should advertise itself as MOP.
09:01:38 <lisppaste2> glguy pasted "fundep example" at http://paste.lisp.org/display/33136
09:01:48 <glguy> this example is obviously not by own code
09:01:50 <bringert> they don't support any persistent processes, so no fastcgi
09:01:52 <SamB_XP> wouldn't that make...
09:01:56 <syntaxfree> bringert: yeah. But I'm thinking of depositing some cash for a year's worth of hosting.
09:01:59 <SamB_XP> value :: g a -> Reader s a
09:02:12 <bringert> syntaxfree: wouldn't you want to know if they are any good first?
09:02:21 <SamB_XP> return a "Reader s a" for *any* type s you feel like?
09:02:34 <SamB_XP> or, er, that the caller wants?
09:02:38 <syntaxfree> bringert: they refund you if you don't want to use your deposit anymore.
09:02:48 <bringert> interesting
09:03:25 <syntaxfree> and anyway, I don't have a credit card, so it's a hassle.
09:03:30 <glguy> paolino: I think that just allows the line "instance MonadState s (State s) where" to say that the s in MonadState is derived from the s in State
09:03:36 <syntaxfree> I was gonna use my girlfriend's credit card, but she dumped me a week ago.
09:03:42 <syntaxfree> I'm gonna ask my parents, now.
09:03:46 <syntaxfree> After the holidays, anyway :)
09:05:44 <pejo> syntax, I think there might be a slight correspondence between understanding OO and the appeal of objects. (Was reading logs, to try to figure out your original claim).
09:06:46 <syntaxfree> This is nice (from that host's FAQ): "A gigabyte is 1,073,741,824 bytes. Hard drive manufacturers would have you believe that it's 1,000,000,000 bytes, but we don't sell hard drives."
09:06:46 <paolino> thinking .... sinking
09:07:00 <syntaxfree> pejo: oh, I'm trying to understand OO, and I think I understand *some* of it.
09:07:06 <syntaxfree> Not subtyping, though.
09:07:09 <ski_> paolino : in the 'class (Meanable a) => Graph g a where' case, 'value :: g a -> Reader s a' will be polymorphic in 's' .. probably this is not what you want ?
09:08:15 <jethr0> syntaxfree: don't worry! subtyping vs subclassing is the bane of all OO
09:08:30 <pejo> syntax, if you remove "examples.html" from that url there is more information.
09:08:45 <paolino> ski_:  prob, I have a partial understanding of polymorphic
09:08:51 <syntaxfree> pejo: yes, I marked it for later reading.
09:09:23 <glguy> paolino: reading http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#functional-dependencies has helped my understanding
09:09:26 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
09:09:29 <ski_> paolino : 'value :: g a -> Reader s a' will be polymorphic in 's' means that 'value' promises to work for any 's' at all (unrelated to the particular 'g' and 'a')
09:09:34 <LoganCapaldo> fundeps are like a poor man's dependent types?
09:09:34 <glguy> paolino: of why you might need fundeps
09:09:49 <ski_> paolino : if you compare the 'class (Meanable a) => Graph g s a where' and 'class (Meanable a) => Graph g s a | g -> s where' cases however ..
09:10:45 <glguy> In a class declaration, all of the class type variables must be reachable (in the sense mentioned in Section 7.4.5, “Type signatures”) from the free variables of each method type
09:11:01 <SamB_XP> LoganCapaldo: not exactly
09:11:46 <paolino> ski_ :ok , so the implementor of graph can't call *any* function on s !, this is not what I want
09:12:21 <pejo> Logan, the article explains it quite well iirc, http://web.cecs.pdx.edu/~mpj/pubs/fundeps.html
09:12:21 <lambdabot> Title: Type Classes with Functional Dependencies
09:12:31 <SamB_XP> LoganCapaldo: but they can be a bit like that
09:13:09 <pejo> jethro, what is subclassing?
09:14:04 <ski_> paolino : .. in the latter case (with the fundep), you can't have both 'instance Graph G S0 A' and 'instance Graph G S0 A' .. basically, for any particular type 'g', you can only have an instance for at most one 's'
09:15:16 <paolino> ski_ my problem is not on the fundep
09:15:29 <paolino> which I think I understand
09:16:01 <paolino> its a type chaining
09:16:20 <ski_> pejo : deriving an implementation from another one, by a kind of extension
09:16:39 <pejo> ski, so implementation inheritance, basically?
09:16:57 <paolino> ski_ ,as  "value" implementation  must use s ,its Graph instance must be parametric on "s", is this  right ?
09:18:15 <paolino> s/its /the g/
09:20:14 <ski_> pejo : i believe so
09:20:40 <paolino> which ever value implemented is done for only one s, this is sure
09:20:58 <ski_> (pejo : for coinheritance on variant types, like haskells 'data', see http://www.cs.ru.nl/E.Poll/papers/durham97.html and http://www.cs.ru.nl/E.Poll/papers/kyoto97.html=
09:21:01 <lambdabot> Title: Subtyping and Inheritance for Inductive Types
09:22:04 <ski_> paolino : i don't understand the question ..
09:22:46 <pejo> ski, oh, sweet.
09:23:24 <paolino> ski_, I'm confused, I need to experiment more, as I have a 0 math/functional background to help me understanding types
09:23:33 <ski_> pejo : i wonder how O'Haskell would feel with that .. :)
09:23:59 <ski_> paolino : can you state the problem ?
09:24:32 <pejo> ski, heh, somewhat outside of my expertise, I can't immediately tell how it would effect the type system.
09:27:34 <SamB_XP> paolino: what was that about "only one s"?
09:28:14 <paolino> fixed g and a , there are going to be many graphs differind in some environmental state, like say depth and aperture, Env{depth::Int, aperture::Int} ,
09:28:14 <paolino> this data is necessary for value to work, so I must pass it. Now ,its type must be in the Graph parameters ?
09:28:21 <SamB_XP> @type runReader (return ())
09:28:22 <lambdabot> forall r. r -> ()
09:30:26 * SamB_XP not understand paolino  
09:31:00 <paolino> that's because you  understand haskell :)
09:31:15 <SamB_XP> probably
09:31:44 <SamB_XP> are you saying that you need the one with the fundep because otherwise you can't do anything with things of type "s"?
09:32:14 <paolino> leave out the fundep
09:32:32 <SamB_XP> if you leave it out, you might as well not use the Reader monad...
09:32:48 <paolino> I want to know if Graph must have s in its args
09:33:04 <Joelll> how to convert nat to bin with haskell ?
09:33:33 <ski_> paolino : if you want that fundep, then yes
09:34:06 <SamB_XP> if you want to be able to do anything with it in the "value" method, yes, it had better be an argument to the class
09:34:13 <syntaxfree> hey. with these fundeps, some programs can be written on the type system itself.
09:34:23 <SamB_XP> syntaxfree: yes we know
09:34:23 <syntaxfree> that sounds like that other language that's often mentioned here.
09:34:30 <syntaxfree> Epigram, or whatever.
09:34:34 <SamB_XP> or at least those of us prepared to do that do
09:34:46 <SamB_XP> a poor immitation
09:35:08 <SamB_XP> you can do the same thing with C++ templates though
09:35:18 <SamB_XP> at least, if they weren't depth-limited somehow you could
09:35:57 <paolino> SamB_XP: had better is somewhat not rational
09:36:40 <SamB_XP> paolino: if you don't have it as an arg of the class, it will be totally unconstrained, and so useless
09:37:00 <ventonegro> http://www.lambdassociates.org/studies/study06.htm
09:37:04 <lambdabot> Title: The BiPolar Lisp Programmer
09:37:05 <syntaxfree> I think fundeps were one of the first things I've ever wanted from Haskell, heh.
09:37:30 <vegai> yay, my first HAppS application is coming along
09:38:43 <paolino> ok, I start realize, thanks ski_ and SamB_XP
09:39:00 <sorear> ?seen
09:39:00 <lambdabot> Lately, I have seen joelll, paolino, pejo, samb_xp, ski_, sorear, syntaxfree, vegai and ventonegro.
09:39:07 <vegai> I wish I had no life, then I could finish this before christmas eve..
09:39:38 * syntaxfree raises his hand and dances a bit.
09:40:54 * vegai has perhaps 30-60 minutes per day 
09:41:06 <syntaxfree> ventonegro: jesus, that's a good article.
09:41:10 <syntaxfree> (I'm halfway through it)
09:41:29 <ventonegro> syntaxfree, yeah, it's nice
09:41:35 <syntaxfree> is it on reddit already?
09:41:55 <ventonegro> dunno, received the link on another mailing list
09:41:56 <vegai> Hmm, was the syntax different when importing constructors?
09:42:17 <syntaxfree> I just submitted it.
09:42:31 <syntaxfree> Reddit has some way of dealing with dupes, right?
09:42:33 <vegai> if I do "import HAppS", everything is ok. If I do "import HAppS (End)", I get "Module `HAppS' does not export `End()'"
09:43:00 <vegai> (without the (), actually, but the same error otherwise)
09:43:00 <ventonegro> yeah, it's there
09:43:18 <ventonegro> http://reddit.com/info/vk0o/comments
09:43:19 <lambdabot> Title: The Bipolar Lisp Programmer (reddit.com)
09:43:30 <syntaxfree> yep. I submitted and then it got counted as an up-vote.
09:43:38 <syntaxfree> Reddit is smart. What is it written in?
09:44:21 <nomeata> ruby, I heard?
09:44:45 <Lemmih> vegai: import HAppS (SomeDataType(End))?
09:44:51 <syntaxfree> Some fine things are written in Ruby. I attribute this to the Python Paradox.
09:45:40 <syntaxfree> "Or perhaps he doesn't get into beer, but into some mental digression from his official studies that takes him too far away from the main syllabus.".
09:45:56 <syntaxfree> (/me being a grad student in economics slacking away to study FP)
09:46:33 <vegai> Lemmih: thanks.
09:47:25 <ventonegro> python paradox?
09:47:39 <ndm_> i go for both beer and mental digressions...
09:47:48 <syntaxfree> @google python paradox
09:47:50 <lambdabot> http://www.paulgraham.com/pypar.html
09:47:50 <lambdabot> Title: The Python Paradox
09:48:03 <vegai> import HAppS (StdPart((:*:))) -- looks good, eh?
09:48:03 <syntaxfree> I should drink more.
09:48:34 <ventonegro> ah, i know the text
09:49:08 <vegai> reddit is written in python, actually
09:49:17 <ventonegro> Python paradox: if a company chooses to write its software in a comparatively esoteric language, they'll be able to hire better programmers, because they'll attract only those who cared enough to learn it.
09:49:27 <ventonegro> so i guess there is a haskell paradox as well
09:50:25 * paolino thinks python has nothing esoteric
09:50:44 <ventonegro> paolino, i guess it's esoteric for the java people
09:50:48 <syntaxfree> the Python Paradox applies to left-field programming languages, in general.
09:51:10 <syntaxfree> Smarter things are often written in the weird languages not necessarily because these are better, but because they attract the smart people.
09:51:18 <vegai> Bipolar Lisp Programmer reads like somebody has been watching me for a decade.
09:51:24 <paolino> Java then is esoteric for C people ?
09:51:53 <ventonegro> i guess not, you can do a lot of crazy stuff in C
09:52:00 <sorear> Haskell is more pypar than most because we actively make it difficult for dumb people to learn.
09:52:08 <mbishop> vegai: sounds like you're a paranoid bipolar lisp programmer :P
09:52:11 <ventonegro> browse the glib object system
09:52:20 <syntaxfree> "Esoteric"  means "average people haven't heard of".
09:52:35 <syntaxfree> vegai: me too.
09:52:48 <paolino> sorear: You won't succeed in kicking me off :D
09:53:15 <vegai> Lambda Associates is some sort of Illuminati?
09:53:35 <ventonegro> sorear, yeah, you haskellers even called that text "a gentle introduction"
09:53:47 <ventonegro> put me off haskell for months
09:54:24 <Nafai> vegai: I thought the same thing...that "Bipolar Lisp Programmer" was written about me.  Heck, my motto in college was "C's get degrees"
09:54:53 <sorear> the programming language or the minimal passing grade ?
09:55:11 <syntaxfree> Reddit comment: "This article is hilarious. Now all the lazy bastards on reddit think they're actually bipolar geniuses."
09:55:22 <Nafai> sorear: The grade
09:55:24 <syntaxfree> That's a good cut-off :)
09:55:36 <syntaxfree> ventonegro: the gentle introduction really sucks for non-fp'ers.
09:55:36 <Nafai> sorear: Though that's funny.
09:55:44 <paolino> first haskell step is a bit high, but this doesn't mean people are dumb at its base
09:55:47 <syntaxfree> the gentle introduction is better left to someone who knows, like, ML.
09:56:04 <ventonegro> syntaxfree, yeah, fortunately i'm stubborn
09:56:18 <syntaxfree> Yet Another Haskell Tutorial is a much better tutorial, despite introducing IO and do-notation too early.
09:56:30 <syntaxfree> we really should write a collective book.
09:56:34 <syntaxfree> "Fifteen Haskell tutorials".
09:56:42 <ventonegro> syntaxfree, that's the one that got me going
09:56:53 <syntaxfree> "You're guaranteed to understand one of these!"
09:58:28 <paolino> people ruled by cobol are bad made, but they just asked me to teach it, this is a crazy world eh
09:58:45 <LordBrain> haha
09:59:09 <syntaxfree> http://reddit.com/info/vk0o/comments/cvm2z
09:59:11 <LordBrain> does cobol still evolve?
09:59:11 <lambdabot> Title: The Bipolar Lisp Programmer (reddit.com)
10:00:48 <paolino> LordBrain many, many activities are using cobol for their dbs and managment here in Italy (this is the real 3° world)
10:01:22 <paolino> and it's evolving, with GUIs now
10:02:12 <LordBrain> something like visual cobol huh
10:02:30 <LordBrain> i never learned cobol
10:02:47 <LordBrain> those who knew it always advised me not to.
10:03:02 <paolino> good people them
10:03:25 <ventonegro> paolino, welcome to our world!
10:05:23 <paolino> but here you earn a lot of money for some mainteinance of those ugly ancient subroutines
10:05:33 <syntaxfree> how ugly can they be?
10:07:06 <LordBrain> I never once in my life heard anyone say "I love Cobol!" or "Cobol is a great language"
10:07:28 <LordBrain> nearly every other programming language has a fanbase
10:07:52 <syntaxfree> does VB?
10:08:01 <syntaxfree> Besides, Cobol is suited for boring tasks.
10:08:07 <syntaxfree> does SQL have a fanbase?
10:08:18 <paolino> uh, cobol has only a bit-slave base
10:08:30 <ndm_> VB is great
10:08:35 <LordBrain> i think VB and SQL are both more loved than Cobol
10:09:19 <syntaxfree> @google "I love SQL"
10:09:21 <ventonegro> i have a rant
10:09:22 <lambdabot> http://sirsha.com/blog/archive/2003/10/29/239.aspx
10:09:23 <lambdabot> Title: Sirsha Development Resources Blog : This is Why I Love SQL Blogs
10:09:26 <LordBrain> Cobolers look at their own language with dread
10:09:41 <LordBrain> it seems that way to me
10:09:44 <syntaxfree> ventonegro: rant on.
10:09:46 <ventonegro> i'm gonna warn people to not learn haskell if their day job does not use it
10:09:56 <ventonegro> it's so frustrating!
10:10:05 <ventonegro> so much power, and nowhere to use :-)
10:10:07 <syntaxfree> my day job is gonna be some boring stint at an investment bank or something.
10:10:28 <ventonegro> it's like being a shaolin monk
10:10:33 <mbishop> I'm gonna warn people that if they care more about their job then having fun, they've already lost at life :P
10:11:00 <syntaxfree> shaolin monk?
10:11:07 <ventonegro> yeah
10:11:31 <ventonegro> one of them can kill ten guys without breaking a sweat
10:11:49 <ventonegro> but see, they're buddhists :-)
10:11:57 <paolino> cobol came just after assembler, but many programmers stayed in assembler,  as they were more fluent
10:12:36 <Modius> Assembler > Cobol
10:12:42 <Modius> Less verbose ;)
10:13:12 <LordBrain> assembly language is more loved than cobol
10:13:23 <paolino> Cobol is great for printing ascii on the papers
10:14:01 <LordBrain> assembly language is pretty cool, it has that l33t factor to it.
10:14:42 <ventonegro> i used [3l33t3] in my msn nick a couple days ago
10:14:46 <ventonegro> lame, i know
10:15:29 <ventonegro> but a coworker came to me asking why did i do it, as if it's wrong thinking of yourself as being in the elite
10:15:43 <syntaxfree> all in all, I think bipolar disorder is a poor explanation for the brilliant failure syndrome.
10:16:01 <ventonegro> well, when you work in a mostly-java company, it's hard not to think that
10:16:23 <LordBrain> haha
10:16:24 <syntaxfree> both Asperger's and MBTI's INTP come across as better psychological descriptions of the lazy geek persona.
10:16:48 <ventonegro> yeah, i'm intp
10:17:06 <syntaxfree> Pretty much anyone on the internet is INTP it seems :)
10:17:11 <ventonegro> that's why my coworkers think i'm arrogant and hate me
10:17:19 <LordBrain> INTP?
10:17:36 <ventonegro> LordBrain, http://www.intp.org/
10:17:38 <lambdabot> Title: intp.org
10:18:02 <syntaxfree> you'd better take a test first.
10:18:16 <syntaxfree> http://www.humanmetrics.com/cgi-win/JTypes2.asp
10:18:17 <lambdabot> Title: Online test based on Jung - Myers-Briggs typology
10:18:18 <mbishop> yeah I'm INTP as well :/
10:18:21 <syntaxfree> you'll probably score as an INTP.
10:18:43 <syntaxfree> if you do, check this out: http://www.intp.org/intprofile.html
10:18:45 <lambdabot> Title: An INTP Profile
10:18:48 <ventonegro> mbishop, i don't think it's a problem
10:18:53 <syntaxfree> it's scary how closely it describes me.
10:19:08 <ventonegro> mbishop, with the proper discipline, we can actually do things :-)
10:19:14 <ventonegro> syntaxfree, me too
10:19:47 <syntaxfree> "Discipline" always reminds me of long-haired brunettes in stiletto heels wearing a lot of leather and bearing whips.
10:20:11 <LordBrain> ha
10:20:16 <syntaxfree> I don't think anyone really wants to live there 24/7.
10:20:28 <LordBrain> that's not what it reminds me of
10:20:41 <ventonegro> me neither
10:20:57 <LordBrain> i think ventonegro meant self-discipline
10:21:10 <ventonegro> yeah
10:21:13 <dancor> do i have to pattern match on 'A':'B':s instead of "AB" ++ s
10:21:29 <ventonegro> i think practicing shaolinquan helps me a lot
10:21:37 <syntaxfree> Self-discipline is the same.
10:21:49 <syntaxfree> LordBrain: take the test!
10:21:50 <ventonegro> dancor, i guess so
10:22:08 <dancor> that's messed up!
10:22:14 <toffee> darcor: (:) is a Contructor, (++) is a function
10:22:40 <SamB_XP> so are we all INTPs with ADD?
10:22:42 <toffee> dancor: and I think you can only match on constructors
10:23:04 <LordBrain> makes me think of patiently sticking to a program which you want to do in general, but may not ever get around to it if you left it up to your fleeting impulses and moods.
10:23:24 <LordBrain> discipline that is
10:23:41 <SamB_XP> what kind of people do we need for that?
10:23:51 <syntaxfree> dancor: ":"-prefixed things in general are infix data constructors.
10:23:58 <LordBrain> a program like oh... a work out schedule
10:24:07 <syntaxfree> You do understand data constructors, don't you?
10:24:43 <SamB_XP> dancor: just pretend you haven't ever heard of "views"
10:24:44 <dancor> i understand that converting "tehuneohseonth" to : is lamelamelame
10:25:01 <SamB_XP> oh, also you could write a parser
10:25:02 <dancor> and personally i think that understanding is more valuable
10:25:03 <Masklinn> hello everybody
10:25:16 <LordBrain> I think Erlang lets you do ("Ab"
10:25:19 <LordBrain> ++ s)
10:25:26 <LordBrain> i cant recall now
10:25:38 <LordBrain> i only looked at erlang briefly
10:25:47 <mbishop> I dunno about ADD, but I'm INTP with OCD :P
10:25:52 <LordBrain> it had something semi nifty in the patterns...
10:25:56 <SamB_XP> we will allow it too if we ever achieve rough consensus and working code for views
10:26:12 <SamB_XP> mbishop: hmm, OCD huh.
10:26:17 * SamB_XP wonders if he has it
10:26:34 * dancor washes his hands to put aside the worry
10:26:41 <SamB_XP> what are the symptoms?
10:26:49 <mbishop> ^ that'd be one heh
10:27:06 <SamB_XP> what would be one?
10:27:18 <ventonegro> Obsessive?
10:27:21 <mbishop> but typically it's worrying too much about something, and then getting stuck in a loop doing some sort of irrational task
10:27:24 * edwardk waves hello.
10:27:40 <ventonegro> i guess most intp don't worry too much
10:27:53 <ventonegro> edwardk, do you play WoW? :-)
10:28:06 <SamB_XP> mbishop: hmm. does checking emule count?
10:28:13 <dancor> ventonegro gains +3 burn-points
10:28:24 <edwardk> ventonegro: nah, i decided i wanted to be able to have a life =)
10:28:29 <mbishop> SamB_XP: only if you check it ever few seconds over and over again :P
10:28:37 * syntaxfree is cleaning his room of the little reminders of his ex-gf.
10:28:39 <ventonegro> edwardk, i had to, i got married
10:28:40 <edwardk> then i spent it here, not necessarily my brightest decision ;)
10:28:49 <syntaxfree> Post-its saying "I love you" and suchlike.
10:29:00 <SamB_XP> mbishop: what if I don't stop?
10:29:49 <edwardk> though, i just bought a nice high-end desktop, and i'm looking for good 3d games to take advantage of it, so maybe WoW is in my future, if i can bring myself to sacrifice my productivity for the next 3 years or so ;)
10:29:51 <SamB_XP> edwardk: well, don't you think this is a closer approximation thereof than WoW?
10:30:07 <joao> hi
10:30:16 <edwardk> at least sitting here i can justify in terms of learning stuff
10:30:17 <SamB_XP> hello
10:30:24 <joao> i have some haskell questions
10:30:44 <LordBrain> i think my stress levels are reduced at times when i am more disciplined... i'm not totally directly aware of stress levels if so tho, its more like they show up in weird stress related symptoms that i notice first.
10:30:44 <SamB_XP> I might have an obsessition with learning
10:30:44 <ventonegro> edwardk, maybe we can create a haskellers guild
10:30:44 <syntaxfree> We have some Haskell answers.
10:30:44 <SamB_XP> jacobian_wrk: ask away
10:30:52 <joao> ok
10:30:52 <syntaxfree> I hope some of our answers match your questions.
10:30:55 <SamB_XP> err
10:30:59 <SamB_XP> joao:
10:31:03 <SamB_XP> sorry.
10:31:21 <joao> how is a flow diagram of a haskell program?
10:31:31 <edwardk> ventonegro: heh, will code for gold?
10:31:34 <SamB_XP> flow diagram?
10:31:38 <ventonegro> edwardk, heheheh
10:31:40 <joao> yes
10:32:02 <syntaxfree> flow diagrams are really useful for imperative, line-oriented programs.
10:32:06 <SamB_XP> what kind of flow diagram?
10:32:27 <joao> i dont know
10:32:30 <SamB_XP> what kind of program?
10:32:39 <syntaxfree> In the case of Haskell, they're not appliable at all, because of lazy evaluation.
10:32:46 <joao> the question is if it can be posible
10:32:55 <mdb> ?where edy
10:32:55 <lambdabot> I know nothing about edy.
10:32:59 <syntaxfree> Your first mental approximation to Haskell should really be a spreadsheet.
10:33:01 <SamB_XP> syntaxfree: you could use them occassionally
10:33:02 <joao> for example thios program
10:33:02 <mdb> ?where edi
10:33:03 <lambdabot> I know nothing about edi.
10:33:14 <joao> http://99-bottles-of-beer.net/language-haskell-1070.html
10:33:17 <lambdabot> Title: 99 Bottles of Beer | Language Haskell
10:33:19 <nmessenger> I suppose an analogue of 'flow diagram' could be an arbitrary 'call graph'
10:33:27 <SamB_XP> syntaxfree: for a single function
10:34:17 <joao> sorry if my englsh is very bad because im spanish
10:35:15 <LordBrain> disciplined => the bills will get paid, everything will happen in it's due time, We'll stick to schedule to make sure stuff gets done.       undisciplined => bills? we dont need no stinkin bills! Schedule, whats that for?  If we really cared about getting it done, we wouldnt need a schedule, and if we dont whats the point?
10:35:56 <SamB_XP> schedule may be good if you need to get more than one thing done
10:36:05 <SamB_XP> so you know what to work on when
10:36:10 <LordBrain> yeah i know, i'm just pointing out the attitudes
10:36:15 <SamB_XP> yeah
10:36:21 <LordBrain> i think disciplined is better, but i tried to be unbiased
10:36:46 <SamB_XP> I'm not saying the schedule should necessarily have dates attached to every item
10:37:24 <joao> ei
10:37:26 <joao> xd
10:37:27 <LordBrain> well, schedules, todo lists, planning, allocating resources... thats all in disciplined
10:37:38 <joao> then can anyone help me?
10:37:39 <syntaxfree> joao: the best thing is not to think of lines of Haskell code as what they "do", but as what they *mean*.
10:37:55 <syntaxfree> a Haskell program is a list of definitions.
10:37:55 <joao> its posible make a flow diagram of a functional program?
10:38:28 <dancor> well the fcns are like pieces
10:38:34 <ventonegro> if it's strict you can make a call graph
10:38:44 <LordBrain> undisciplined is kinda like party mode, but there wont be a party unless some disciplined person throws it for you and you find it convenient to spontaneously show up.
10:38:50 <dancor> and when they call each other that's a connection yeah
10:38:52 <joao> yes, i understand that the program do but my work is make a flow diagram
10:38:53 <ventonegro> at compile time
10:39:05 <nmessenger> ventonegro: that's why I specified "arbitrary".  In non-strict, actual order is unspecified.
10:39:49 <syntaxfree> joao: forget about what the program "does".
10:40:02 <syntaxfree> a program defines functions.
10:40:44 <glguy> whoa, I come back from lunch and you gys are discussing the "meaning" of a Haskell program :)
10:41:05 <ventonegro> glguy, you lost the personality discussion?
10:41:11 <nmessenger> glguy: joao asked if one could write a Haskell flow diagram.
10:41:17 <joao> thx syntaxfree
10:41:20 <glguy> ventonegro: I didn't scroll back far enough maybe :)
10:41:41 <ventonegro> glguy, start taking the personality test :-)
10:41:45 <joao> yes, this is my problem
10:41:59 <syntaxfree> Haskell is lazily evaluated.
10:42:21 <syntaxfree> bottles n = show n ++ " bottles"
10:42:27 <glguy> or at least "not strictly" evalutated :)
10:42:32 <syntaxfree> that just means that "bottles" of "n" is defined as that.
10:42:50 <syntaxfree> Be back later.
10:43:00 <glguy> is there a new 99-bottles-of-beer.net posting?
10:43:44 <joao> syntaxfree: yes, i understand the functions do...but my problem is compare flow diagrams of java and haskell programs
10:43:53 <dancor> does haskell have exceptions or just Either String a
10:44:01 <glguy> ?type catch
10:44:02 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
10:44:27 <glguy> ?hoogle throw
10:44:28 <lambdabot> Control.Exception.throw :: Exception -> a
10:44:28 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
10:44:28 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
10:44:38 <glguy> dancor: ^^
10:45:07 <LordBrain> joao: is this an assignment?
10:45:15 <rongenre> I'm looking for hints in loading a ton of binary records.. is there an easy way to memory map a file and pull ints, longs, doubles out of it?
10:46:17 <joao> LordBrain: i dont understand you
10:46:25 <joao> aomeone speak spanish here???????
10:46:35 <erg0t> yo
10:46:35 <LordBrain> solo un poco
10:46:37 <nmessenger> joao: LordBrain means a homework assignment for school.
10:46:40 <glguy> joao: I think he was askign if this was homework
10:46:52 <SamB_XP> rongenre: ah, you could use Python ;-)
10:46:59 <LordBrain> i think there is a spanish haskell room now isnt there?
10:47:06 <erg0t> haskell.es
10:47:07 <joao> yes its a homework of my university
10:47:16 <joao> ok
10:47:20 <joao> sorry
10:47:28 <joao> to the espanish site
10:47:29 <joao> xd
10:47:41 <erg0t> #haskell.es
10:47:45 <glguy> haskell makes more sense as graph reduction than a flow chart... does it not?
10:47:54 <SamB_XP> we are a little weak on truly nice foreign-format binary parsing libraries
10:47:58 * glguy doesn't know how much of this has already been covered in teh backlog
10:48:18 <ventonegro> Data.ByteString.Lazy?
10:48:43 <SamB_XP> ventonegro: that is great if you don't need to actually do anything with the data
10:48:56 <LordBrain> joao: maybe the professor wants to check that you understand the difference between lazy evaluation and strict
10:49:07 <SamB_XP> rongenre: or, well, write a nice library ;-)
10:49:10 <rongenre> SamB_XP: Yeah, I noticed..  I looked at some code in hogg
10:49:20 <ventonegro> SamB, so you're saying that that's useless? :-)
10:49:24 <glguy> or maybe you should check to see if the professor understands the difference in lazy and strict eval ;)
10:49:30 <SamB_XP> ventonegro: not useless
10:49:41 <dancor> ventonegro: where is your test
10:49:48 * SamB_XP was at least half joking about Python
10:50:06 <rongenre> SamB_XP: I suppose that's an option, writing a library, it's easy enough to do in C, but it's not easy to deal with a pointer to  bunch of structs in the heap, is it?
10:50:07 <LordBrain> joao: if that's the case. Then think of an example which looks similar in the two languages, but which behaves differently due to haskell being lazy.
10:50:27 <SamB_XP> rongenre: hmm?
10:50:35 <sorear> ?seen
10:50:36 <lambdabot> Lately, I have seen dancor, erg0t, glguy, joao, lordbrain, nmessenger, rongenre, samb_xp, sorear, syntaxfree, ventonegro and xdie.
10:50:36 <ventonegro> syntaxfree gave the url a couple screens ago
10:50:43 <rongenre> I used ByteString.Lazy to write something which parsed a bunch of text records, tab delimited... it was very fast, better than perl
10:50:49 <ventonegro> dancor, cant you roll back?
10:50:51 <rongenre> [which is what i'd use otherwise]
10:51:21 <joao> s
10:51:25 <SamB_XP> struct *s are not well supported by Haskell's FFI, no.
10:51:32 <ventonegro> dancor, http://www.humanmetrics.com/cgi-win/JTypes2.asp
10:51:34 <lambdabot> Title: Online test based on Jung - Myers-Briggs typology
10:51:56 <rongenre> oh good, mbti
10:52:11 <glguy> I took a small version of that test and got INTJ
10:52:22 <glguy> err
10:52:24 <SamB_XP> (structs also don't tend to be a very portable way to read/write data, though)
10:52:25 <glguy> same length as this one
10:52:28 <rongenre> almost all good programmers are intj or intp
10:52:30 <ventonegro> a lot of ppl here typed intp
10:52:31 <glguy> questions don't seem familiar
10:52:41 <joao> there are nobody in haskell.es
10:52:46 <glguy> what is the P
10:52:54 <ventonegro> perceiving
10:53:12 <ventonegro> we see the world, but fail to find the motivation to actually act on it
10:53:18 <ventonegro> or something like that
10:53:22 <glguy> ahh
10:53:30 <SamB_XP> they should make you take a personality test before letting you major in computer-programmin-related fields
10:53:52 <SamB_XP> ventonegro: huh
10:54:01 <SamB_XP> why do we write tools then?
10:54:03 <rongenre> SamB_XP: Just a big file of records.. it's pretty normal, especially if you have memory mapping
10:54:20 <ventonegro> SamB_XP, it's mostly to prove ourselves that we can
10:54:31 <SamB_XP> @google "Data.ByteString"
10:54:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:54:32 <lambdabot> Title: Data.ByteString
10:54:34 <sorear> lambdabot: testing syntax
10:55:19 <SamB_XP> rongenre: yes but doesn't that limit the format to a particular ABI?
10:55:54 <glguy>  'paris' does not exist in the current context
10:56:15 <rongenre> SamB_XP: not if you document the format, the file I'm reading was generated, for instance, by a java job
10:56:38 <SamB_XP> rongenre: ah, so it limits the portability of the *code*
10:57:25 <joao> someone speak spanish?
10:57:45 <rongenre> SamB_XP: I suppose, any java impl could read this in -- it's not a lot different than other binary interaces, like mp3 or ogg
10:57:46 <sorear> /who #haskell.es ?
10:58:12 <joao> nobody in this room
10:59:08 <sorear> hmm, not even lambdabot[2], odd... (chanserv says the name is correct)
10:59:40 <joao> yes
10:59:52 <joao> but they dont speak
10:59:59 <SamB_XP> rongenre: anyway, you could mmap stuff
11:00:16 <rongenre> SamB_XP: how?  in an ffi?
11:01:29 <dancor> intp
11:01:31 <SamB_XP> maybe
11:01:50 <dancor> i thought i had a real chance of breaking the pattern3~
11:02:02 <rongenre> intp's are typically "nerds" and intj's "geeks".  Or the other way around.
11:02:13 <rongenre> the fun ones are intp's
11:02:51 <Philippa_> 'cos the other ones're judgemental trolling bastards? :-)
11:03:01 <arcatan> what's this intj/intp thingie?
11:03:21 <rongenre> Philippa_:  damned if i know, i'm an intj usually.  Not fun at all.
11:03:26 <arcatan> ah, the log tells
11:03:44 <Philippa_> I seem to only be well-defined on one axis. I forget which one (but not I/E)
11:03:55 <rongenre> judging is different than being judgemental, it's more of a need to put something into a category..
11:03:56 * monochrom is here to ruin your day again!
11:03:57 <dancor> i was only 1% thinking
11:04:16 * dancor should think more
11:04:35 * dancor just made a self-judgment
11:04:39 <monochrom> Heh, real-world software "development" is 1% thinking, 99% testing.
11:05:26 <pejo> rongenre, but look at the description, quite flattering. http://keirsey.com/personality/ntij.html
11:05:28 <lambdabot> Title: The Portrait of the Mastermind
11:06:22 <dancor> which on is the whippingboy of the types
11:06:27 <dancor> s/on/one
11:06:35 <dancor> "you basically suck at life"
11:08:29 <monochrom> perhaps guardian, supervisor
11:09:31 <monochrom> or perhaps not all people are under those categories. only great people are.  whippingboy is not great.
11:09:54 <monochrom> ordinary people can only be classified as proles.
11:10:33 <dancor> our test reports that you have no personality
11:10:34 <LordBrain> hmm that test said i was entj...
11:10:52 <LordBrain> but i wasnt sure how to answer some of the questions, there was no.. "it depends" option
11:11:04 <dancor> honesty though, this guy's name is joe butt?
11:11:40 <LordBrain> the highest percentage was in intuitive... hmmmm
11:12:05 <LordBrain> i think of myself as a thinker
11:12:12 <glguy> so is there a "worst" result you can get?
11:12:13 <dancor> a metathinker
11:12:21 <glguy> or is everyone special in their own way
11:12:49 <dancor> so do ppl really use exceptions in nonmonadic fcns
11:12:50 <SamB> monochrom: probably because in the real world they have more bugs?
11:12:59 <SamB> maybe because they use pathetic languages
11:12:59 <dancor> is it any cooler than either
11:12:59 <monochrom> I just know that every object is special in its own way, merely by having unique IDs.
11:13:07 <LordBrain> some questions i wasnt sure to answer how i want to be, or how i end up objectively
11:13:18 <SamB> dancor: usually I just use "error"
11:13:33 <LordBrain> like neat desk
11:13:42 <LordBrain> i'd like a neat desk type thing
11:13:44 <monochrom> I use exceptions in nonmonadic functions.
11:13:48 <LordBrain> but i'm messy..
11:14:21 <LordBrain> but the fact that i would desire neatness seems important
11:14:22 <SamB> I mean, that is the only kind of Control.Exception-brand exception I use in nonmonadic functions
11:14:30 <dancor> monochrom: looks like i just s/Right/Return i guess it is clearer
11:14:43 <dancor> metas/Return/return
11:14:51 <SamB> heh
11:16:00 <LordBrain> I wonder how it would change my score
11:16:01 <edi> ❤
11:16:18 <nmessenger> Ooh, unicode heart.
11:16:35 <SamB> LordBrain: what was the question?
11:16:43 * monochrom ❤ unicode
11:17:10 * sorear thinks b]d is ugly :(
11:17:22 <dancor> yeah i was torn on many qs about what i do vs what i try to do
11:17:39 <LordBrain> SamB: its a personality test
11:17:50 <SamB> LordBrain: so I gathered
11:17:50 <dancor> like i try to sit in the center of the room but usually a table is there
11:17:52 <ventonegro> i find being an intp very funny
11:17:55 <LordBrain> Your desk, workbench etc. is usually neat and orderly
11:17:55 <LordBrain> YES   NO
11:18:03 <sorear> both?
11:18:05 <dancor> Will you go out with me
11:18:10 <dancor> YES  NO
11:18:13 <SamB> ventonegro: I find it very punny too
11:18:15 <dancor>      MAYBE
11:18:19 <LordBrain> hehehe
11:18:25 <nmessenger> I'LL THINK ABOUT IT
11:18:36 <SamB> LordBrain: obviously you answer "no"
11:18:36 <dancor> _what_kind_of_car_do_you_have
11:18:41 <SamB> just like me
11:18:43 <ventonegro> IF YOU DO MY HOMEWORK
11:18:59 <glguy> DO YOU LIKE ME: YES NO MAYBE
11:19:05 <nmessenger> MU
11:19:12 <ventonegro> nmessenger, hahahaha
11:19:17 <dancor> Are you the kind of person who would answer no to this question?
11:19:24 <dancor> s/no/NO
11:19:25 <monochrom> haha
11:19:40 <monochrom> Of course my deak is tidy and neat.
11:19:56 <monochrom> Mom disagrees, but she just doesn't appreciate MY order.
11:20:02 <ventonegro> unfortunately mu is a joke only 2% of ppl understand (int* ppl)
11:20:12 <nmessenger> ventonegro: GEB FTW
11:20:30 * glguy really needs to finish reading that
11:20:38 * nmessenger too
11:20:43 <joelr1> howdy
11:20:53 <monochrom> Speaking of which, my computer desktop (i.e. screen background) is also tidy and neat and orderly and organized.
11:21:10 <monochrom> So organized, there is even a folder "unorganized" for all the unorganized stuff.
11:21:32 <edi> I've got an entire "Garbage" HD.
11:21:51 <Vq^> i got a small icon called Trash on my desktop
11:21:59 <LordBrain> lol
11:22:03 <Vq^> must be since i installed gnome
11:22:12 <Vq^> i usually don't have icons on the desktop
11:22:46 <LordBrain> my extroversion is very slightly expressed according to the test, it gave me a 1%.
11:22:47 <sorear> MY desktop has a blinking line and the works 'stefan@stefans:~/lambdabot-sorear-test$ '
11:23:12 <LordBrain> maybe if i answered one question different it would flip to introvert
11:23:15 <rahikkala> My desktop is just a blank screen :(
11:23:19 * allbery_b grins
11:23:20 <Vq^> 1.5GB Trashcan, neat
11:23:31 <allbery_b> which desktop?
11:23:51 * allbery_b has in front of him one linux/KDE, one OSX/PPC, and one WinXP desktop
11:24:17 <Excedrin> sorear: nice, mine's the same, but I'm not into those fancy special effects so I have no blinking
11:24:58 <sorear> My trash can is about 4' tall, bright blue, and says 'PROPERTY OF THE CITY OF SAN DIEGO.  ILLEGAL TO REMOVE FROM ADDRESS.' on the side; it holds a vast amount of data, mostly in paper form.
11:25:19 <Vq^> i usually only use a really clean IceWM desktop, this is gnome/beryl thought
11:25:46 <opqdonut> ion3!!
11:26:04 <Vq^> ion is nice
11:26:12 <Excedrin> blackbox!!
11:26:20 <sorear> I use ion3 if I am forced to use X, which is about 5 minutes a week.
11:26:35 <glguy> I started using DWM when I had to use X
11:26:52 <sorear> fbcon is very nice...
11:27:26 * SamB wants to take another test
11:27:31 * SamB came out as ISTP somehow
11:28:29 <SamB> oh, wait, I missed questions
11:28:40 <SamB> now I come out as INTP, and all is well with the world.
11:28:47 * SamB isn't sure he's done that before.
11:30:21 <ventonegro> ISTP, introverted sensing
11:30:24 <ventonegro> must be weird
11:30:32 <Excedrin> I've tried all of the wms that attempt to tile windows (larswm, ion, wmii, dwm, xwem, stump..) they all become annoying after a while
11:30:49 <opqdonut> Excedrin: you're weird, ion is heaven
11:35:07 <nmessenger> ?google ion window management system
11:35:10 <lambdabot> http://modeemi.fi/~tuomov/ion/
11:35:10 <lambdabot> Title: Ion
11:36:14 <mbishop> I either go extremely minimal or extreme integrated...ratpoison/stump or KDE :)
11:36:48 <augustss> any darcs wizards around?
11:38:20 <LordBrain> whats the p in intp?
11:39:30 * SamB wonders how ADD affects results
11:40:51 <ray> who uses the tiling features anyway
11:40:51 * nmessenger has ADOS--Attention Defecit Ooh Shiny!
11:41:08 <ray> i use ratpoison and only use the split feature to impress people with screenshots
11:41:09 <dufflebunk> Anyone able to tell me what a parser combinator is?
11:41:45 <integral> It's a combinator that combines parsers
11:42:01 <nmessenger> dufflebunk: from 20,000 feet, a parser combinator is an operator that combines parsers in interesting ways
11:42:06 <LordBrain> have you tried ion?
11:42:17 <LordBrain> I ask, because my brother used ratpoison but switched to ion
11:42:27 <opqdonut> same here
11:42:29 <nmessenger> dufflebunk: like choice, repetition, etc.
11:42:36 <bosse-> is ion still a pain when you want to use something that isn't really suited for a non-standard window manager?
11:42:40 <opqdonut> twm->ratpoison->ion->flux->ion!
11:42:56 <opqdonut> bosse-: stuff like gimp i guess
11:43:06 <opqdonut> but i only use emacs, aterm and opera :)
11:43:10 <bosse-> :)
11:43:13 <opqdonut> oh, and xdvi for emergencies
11:43:44 <dufflebunk> nmessenger: is there any reason it has a special name, or was the name just invented because some guy wanted a topic for his thesis?
11:44:26 <nmessenger> dufflebunk: 'combinator' is a generic word for something that combines
11:45:11 <dufflebunk> parsers have to combine though, unless it's a very simple language
11:45:17 <aristoteles> hi
11:45:26 <dufflebunk> Hello aristoteles
11:45:45 <aristoteles> is there some tuto for people like me, without any programming background, into haskell?
11:46:57 <aristoteles> i am participating in a little course, using the craft of functional programming book, which i find a little hard.
11:47:15 <aristoteles> and not so directly practical
11:48:19 <aristoteles> even the yaht itself says that it is not directed to non-programmers.
11:48:21 <monochrom> well the most popular parsers are written by yacc and they aren't quite composable.
11:49:12 <ventonegro> LordBrain, perceiving
11:49:33 <wolverian> aristoteles, http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html might perhaps be more approachable.
11:49:36 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
11:49:42 <monochrom> and if you parse a complex language, you submit one complex grammar to yacc, instead of taking two outputs of yacc and chaining up the two pieces of C code.
11:50:22 <monochrom> whereas with Parsec you do chain up two pieces of Haskell code or two Haskell function calls.
11:50:32 <dufflebunk> aristoteles: You might also find this one useful: ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.pdf
11:50:53 <aristoteles> thanks, wolverian & dufflebunk
11:51:51 <jethr0> wolverian: if you don't have programming experience, programming your own scheme might be a little hard, no?
11:52:33 <sjanssen> aristoteles: mind if I ask where you go to school?
11:52:37 <jethr0> aristoteles: although it's not haskell oriented, i think "Structure and Interpretation of Computer Programs" is very nice and there's even full video lectures from the 80s *woot*
11:53:09 <jethr0> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
11:53:14 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
11:53:38 <Masklinn> wolverian > er... Write Yourself a Scheme is much harder to follow than YAHT
11:53:40 <ndm> jethr0: but they are now moving to teaching python :(
11:53:46 <aristoteles> sjanssen: this is göttingen, just a 3 person doityourself thingy
11:53:50 <jethr0> obviously it doesn't address haskell features like lazyness or typing, but it conveys a nice background into unpure functional programming
11:54:08 <Masklinn> it starts out real steep, someone who doesn't know any Haskell nor any other functional language gets lost at the first page
11:54:46 <jethr0> ndm: well, i guess abelson and sussman are retiring...
11:54:53 <aristoteles> sjanssen: the other two guys are more advanced than i am, so i have to run a bit to catch up :D
11:55:02 <Philippa_> WYaS's inherantly aimed at someone who'd at least have a use for the scheme though
11:55:05 <wolverian> Masklinn, oh. sorry, then..
11:55:46 <Masklinn> Philippa_ > not necessarily, building an interpreter is always interesting and showcases amny
11:55:47 <jethr0> aristoteles: i can't really put myself into the position of someone w/o programming background, but aren't some of the tutorials helpful? yaht, gentle introduction, ...?
11:55:50 <dufflebunk> monochrom: hmmm, ok, I can follow that. Thanks.
11:55:51 <Masklinn> many useful features
11:56:19 <sjanssen> aristoteles: I know there are unis that teach Haskell to first semester CS students, perhaps you could check out the materials they use?
11:56:45 <sjanssen> http://www.haskell.org/haskellwiki/Haskell_in_education#Haskell_as_a_first_language
11:56:47 <lambdabot> Title: Haskell in education - HaskellWiki, http://tinyurl.com/yfe5v2
11:57:03 <Excedrin> does ion3 have "select window to the left/up/down/etc" functionality?
11:58:13 <opqdonut> Excedrin: yes
11:58:19 <opqdonut> or frame, actually
11:58:27 <aristoteles> sjanssen: yes, thank you!
11:58:34 <opqdonut> as one frame can have many clients, which are then tabbed a la fluxbox
11:59:31 <Excedrin> so "select frame to the left" still selects the last focused window in that frame?
11:59:47 <Excedrin> also, how do you clear error dialogs?
12:00:02 <opqdonut> Excedrin: exactly
12:00:27 <opqdonut> join #ion if you are interested or have questions
12:00:35 <opqdonut> (not a very newb-friendly channel, tho)
12:00:43 <opqdonut> but i recommend trying it out
12:01:39 <Excedrin> I'm trying ion3 right now.. my first impression is that it's roughly the same as last time I used ion (ion2 I guess), and that I'll switch back to blackbox in a few minutes
12:01:49 <opqdonut> heh
12:02:55 <yaarg> hey #ion is n00b friendly!
12:03:17 <opqdonut> yaarg: like hell (pun intended)
12:03:18 <mbishop> more like filled with n00bs
12:03:33 <ventonegro> ion can be scripted in Lua, which is cool
12:03:49 <mbishop> ventonegro: s/can be/has to be/
12:03:49 <yaarg> opqdonut: i don't think that's fair, i've helped a lot of n00bs out in the past
12:04:05 <ventonegro> mbishop, coller
12:04:07 <ventonegro> ops, cooler
12:04:25 <opqdonut> yaarg: yeah, but in general the channel isn't very kind on people who ask before trying to learn
12:04:46 <mbishop> anyone have a 16-bit wireless pc card they'd wanna sell/trade me? :)
12:05:04 <Excedrin> 16-bit?
12:05:18 <yaarg> do you even get 16-bit wifi cards?
12:05:18 <allbery_b> yes, actually, but only in trade for a 32bit ethernet card with a dongle :)
12:05:20 <mbishop> yeah, the interface needs to be 16-bit (not 32-bit cardbus, like most are now)
12:05:22 <Excedrin> old pcmcia 802.11b or something?
12:05:45 <Excedrin> do you know of a specific model? I have two aironet 340s
12:05:48 <mbishop> Excedrin: basically heh
12:05:59 <allbery_b> (old orinoco silver card.  the machine it used to work with is no longer quite so portable)
12:06:26 <mbishop> allbery_b: I'll trade you a dual 300MHz ultrasparc II :o
12:06:36 <Excedrin> yea, actually aironet 340 is 16 bit
12:06:40 <monochrom> I have Casic FX-602P.
12:06:46 <monochrom> err Casio
12:06:48 <allbery_b> heh.  I think I'd have to work a multistage trade ionvolving thbe department :)
12:07:09 <mbishop> Excedrin: willing to let one go? :)
12:07:10 <monochrom> hahaha sounds like n-way trade in Monopoly.
12:07:47 <Excedrin> mbishop: http://cgi.ebay.com/Cisco-Aironet-340-wireless-PCMCIA-LAN-adapter-2-4-Ghz_W0QQitemZ200058019071QQihZ010QQcategoryZ42196QQcmdZViewItem
12:07:48 <lambdabot> Title: eBay: Cisco Aironet 340 wireless PCMCIA LAN adapter 2.4 Ghz (item 200058019071 e ..., http://tinyurl.com/ybucgu
12:07:51 <Excedrin> (sorry for long url)
12:08:05 <monochrom> Heh, don't worry, that's what lambdabot is for.
12:08:38 <mbishop> hmm, might just have to get that
12:09:05 <allbery_b> seriously, I think I can work something out, the card's not doing me a whole lot of good currently
12:11:49 <mbishop> allbery_b: what kind of money are we talking? also where do you live?
12:11:58 <allbery_b> pittsburgh, pa
12:12:21 <allbery_b> and, well, I kinda suspect shipping costs more than the card is worth these days :)
12:12:24 <glguy> what's the XML CDATA tag look like?
12:12:30 <glguy> <![CDATA[[ or something?
12:12:58 <monochrom> <![CDATA[
12:13:16 <mbishop> allbery_b: probably, I live in louisiana, I think it'd be about $20 for standard shipping
12:13:25 <monochrom> Too end it, ]]>
12:13:54 <glguy> thnx
12:14:41 <metaperl> Is LaTeX the easiest way to write a document mixing normal text with Haskell code? what do you use when you want printed and HTML? I personally like LaTeX... just need a little help when I list a series of steps in line-by-line derivations
12:15:22 <ventonegro> <![[CDATA[
12:15:30 <monochrom> I say XHTML is easier :)
12:15:50 <metaperl> monochrom - oh really?
12:16:00 <metaperl> monochrom - angle brackets make me dizzy :)
12:16:11 <monochrom> True.  I don't have a real answer.
12:16:14 <metaperl> monochrom - cant get PDF and HTML so easily that way either
12:16:23 <metaperl> most haskell books are done in latex
12:16:37 <monochrom> with much pain.
12:16:46 <mbishop> allbery_b: if you want to sell, you can send me a message anytime
12:16:50 <glguy> lhs2tex doesn't help any?
12:17:22 <pesco> metaperl: lhs2TeX is great, as for html and other formats, I'm working on it... Wanna help?
12:17:22 <metaperl> glguy - never heard of that... let me see
12:17:40 <glguy> metaperl: lhs2tex produces beautiful output
12:18:15 <monochrom> There are latex-to-html programs.
12:18:17 <pesco> bringert has been on the same track with HMarkup, I'm here to see if he drops by.
12:19:00 <PaulAJ> Some time ago I wrote a little script to convert lhs with HTML formatted text into pure HTML.
12:19:07 <SamB> isn't there an html output hack that runs on LaTeX?
12:19:13 <PaulAJ> (Script == small Haskell prog)
12:19:25 <PaulAJ> It doesn't do syntax colouring though.
12:19:42 <wy> Does Haskell force the values when doing pattern matching?
12:19:46 <metaperl> pesco - here my just started doc in plain l - http://haskellography.metaperl.com/ ... I will try to find lhs2text now
12:19:47 <PaulAJ> Basically it just wrapped anything in > in <code>
12:19:48 <lambdabot> Title: Haskellography: An Exploratory Journey into the World’s Most Beautiful Languag ...
12:20:08 <metaperl> I am actually doing a lot of stuff which is not Haskell code... it is math derivations of Haskell programs
12:20:32 <metaperl> I think equation mode in plain latex is closest to what I need
12:20:48 <syntaxfree> @type error
12:20:50 <lambdabot> forall a. [Char] -> a
12:21:05 <pesco> metaperl: Oh.
12:21:11 <metaperl> :)
12:22:56 <wy> Hi cale!
12:23:02 <Cale> hi
12:23:29 <wy> I guess this is your midnight
12:23:56 <Cale> no
12:23:59 <Cale> opposite :)
12:24:34 <wy> sorry I thought you were in Australia
12:24:40 <Cale> nope, Canada
12:25:03 <Cale> I seem to give that impression though :)
12:25:33 <wy> It seems a lot of guys here are from Australia.
12:25:59 <augustss> g'day mate
12:26:12 <wy> I have a question about pattern matching. It seems Haskell only forces value when it does pattern matchings. But a matching with wildcard will not force the value?
12:26:49 <augustss> that's right
12:27:11 <wy> Thanks. Now I understand the example in the tutorial.
12:27:19 <augustss> haskell evaluates enough to see if a pattern matches or not. a wildcard always matches, so no need to evaluate
12:30:09 <wy> strange. My irc seems working, but my web browser not
12:30:23 <opqdonut> how quaint
12:30:58 <wy> looks like a problem with dns. But doesn't irc use dns?
12:31:15 <Cale> not continually
12:31:47 <allbery_b> only when it first connects to a server
12:32:32 <allbery_b> maybe when displaying hostnames of other connected users, but it fails sanely if that doesn't work
12:32:53 <wy> OK. I solved the problem again. Why do I keep solving this kind of problem in Linux
12:33:13 * allbery_b would suspect a configuration problem somewhere
12:34:01 <allbery_b> i.e. if you just had to redo your resolv.conf then you may need to disable dhcp resolv.conf rewriting, and possibly take a clue-by-four to whoever runs the DHCP server feeding your machine bogus DNS information
12:34:15 <opqdonut> :D
12:34:27 <wy> One of my friend is wondering if haskell can be used in 3D graphics rendering
12:34:37 <emu> i have a similar weird problem with DNS lookups
12:34:42 <opqdonut> wy: why not
12:34:47 <opqdonut> ocaml is used
12:34:51 <emu> wy: i've played with HOpenGL a bit, it's fun
12:36:09 <wy> emu: I should try it. What about implementing a whole graphics engine with it? Doesn't HOpenGL depend on some opengl library implemented in another language?
12:36:20 <emu> opengl is implemented in hardware
12:36:26 <emu> so technically, yes, it's another language
12:36:54 <wy> Oh. forgive my ignorance
12:36:58 <emu> all software languages have an equal interface to it
12:37:25 <wy> emu: So it doesn't another level of library, for example in C?
12:37:47 <wy> doesn't need. sorry
12:38:13 <emu> the video card drivers implement the interface between the hardware and software programs. that interface is OpenGL.  there may be some assorted code in those drivers, but they're fundamental.
12:39:23 <reborn> hi :)
12:39:29 <wy> emu: Then can Haskelll write device drivers?
12:39:43 <pejo> wy, see House and the drivers there.
12:39:45 <emu> sure, but that's a separate thing
12:39:47 <opqdonut> wy: why not, as it can be compiled
12:40:04 <allbery_b> you're being confusing... yes, the OpenGL libraries are in C, and you're stuck with that because they usually talk to dedicated video hardware with a proprietary interface
12:40:14 <wy> opqdonut: So I guess an operating system can be written with it?
12:40:22 <emu> there is no extra level, though
12:40:23 <opqdonut> wy: of course
12:40:26 <allbery_b> (one could in theory do software opengl, but (a) that's also usually in C and (b) it's pretty slow
12:40:28 <allbery_b> )
12:40:39 <emu> programs written in C have to use the same interface
12:40:57 * monochrom attempts software opengl in haskell with LazyRenderMatrix  :)
12:41:11 <emu> HOpenGL extends the interface with some higher order functions too
12:41:29 <opqdonut> well, calling the opengl api from haskell needs a bit more juggling than from C
12:41:52 <reborn> Why if I do parseModule "asdf b = b \n asdf x= x" I get parseerror, cause I need to do parse of various lines in order to do pointfree of catas
12:42:42 <opqdonut> reborn: indentation?
12:42:51 <opqdonut> try w/o the space after \n
12:43:02 <sjanssen> reborn: are you talking about the Language.Haskell API?
12:43:13 <reborn> yes
12:43:34 <monochrom> Yeah, the space after \n kills you
12:43:34 <sjanssen> try removing the space as opqdonut suggests
12:44:06 <reborn> I'm doing a work that reads a file and converts all pointwise to pointfree in an haskell file, and that's the only thing missing
12:44:18 <monochrom> "but \nasfd... is unreadable"  :)
12:44:55 <reborn> thanks a lot it really was the space after \n
12:45:04 <opqdonut> np, hf
12:45:08 <opqdonut> and hh
12:45:17 <sjanssen> reborn: have you heard of @pl?
12:45:23 <wy> Since Haskell demonstrated a programming language with syntax depending on layout. I guess there will emerge a language which completely graphical one day
12:45:28 <reborn> no
12:45:29 <sjanssen> @pl \x y -> y x x
12:45:29 <lambdabot> flip =<< flip id
12:45:45 <emu> wy: there's a few experiments
12:45:46 <sjanssen> @pl \f x y -> f y x
12:45:46 <lambdabot> flip
12:46:06 <rahikkala> wy: http://www.dangermouse.net/esoteric/piet.html ;)
12:46:07 <emu> wy: programming reddit had a link to one in which programs appear like abstract art
12:46:07 <lambdabot> Title: DM's Esoteric Programming Languages - Piet
12:46:11 <sjanssen> reborn: pl is a pointfree converter in lambdabot
12:46:12 <jethr0> wy: you mean like epigram? or even more graphical?
12:46:17 <monochrom> someone tried \a b c d d -> a+b+c+d+e
12:46:46 <reborn> ok but I'm doing it as a work for university
12:46:48 <jethr0> one of the touring tarpit is twodimensional! and obviously completely unread/writeable
12:47:38 <monochrom> I welcome 3d program presentations.
12:47:49 <jethr0> s/touring tarpit/turing tarpit languages/
12:47:50 <reborn> Uminho university in fact the only one in Portugal that teaches Haskell:S
12:48:17 <wy> Oh. I got another dhs problem. I have to go to #ubuntu to ask for ways to turn off the updating of /etc/resolv.conf
12:48:24 <emu> pump updates it
12:48:36 <petter_> isn't there a language caller "wired" or "wierd" or something the program is a line that turns, the angle of the turn determines the instruction
12:48:37 <emu> or whatever you are using
12:48:45 <monochrom> No, not pump.
12:49:06 <jethr0> http://en.wikipedia.org/wiki/Befunge
12:49:18 <jethr0> "It differs from conventional languages in that programs are arranged on a two-dimensional grid. "Arrow" instructions direct the control flow to the left, right, up or down, and loops are constructed by sending the control flow in a circle."
12:49:31 <emu> well ok. i use debian, and there, it is pump.  i twiddled its config file to output some stuff in resolv.conf once or twice
12:49:51 <wy> emu: How did you do it?
12:50:26 <emu> well, uh, what is your dhcp client?
12:50:43 <monochrom> dhclient3
12:51:07 <emu> does it have a man file?
12:51:14 <monochrom> yes
12:51:37 <wy> piet will exclude color-blind people to become a programmer
12:52:09 <wy> emu: I just use dhclient.
12:52:50 <wy> emu: I guess it's something with vmware. because resolv.conf will be set to a subnet used by vmware
12:52:59 <pitecus> anyone use GetOpt module?
12:53:10 <emu> well in pump, it's a line called "nodns".  i don't have dhclient, though.
12:53:22 <emu> pitecus: sure
12:54:03 <pitecus> this getOpt function returns a list of option args
12:54:21 <pitecus> how am i suppsed to find which option they belong to?
12:54:55 <emu> search
12:54:59 <monochrom> /etc/resolv.conf updates...  well frequent update is fine, you mean frequent updating with wrong content.  I run into that in only one situation.  I connect through wifi and its dhcp wants to refresh every N minutes - that is fine by itself.  Then on top of that I run pptp, which wants me to use another dns server, and doesn't refresh every N minutes (naturally).  So after N minutes the wifi dhcp gives me its dns server, whic
12:54:59 <monochrom> h the pptp blocks.  That's all.
12:55:07 <emu> basically you define some data type, i usually call it Flag
12:55:13 <emu> it returns you a [Flag]
12:55:21 <pitecus> ya
12:55:44 <pitecus> lets say it has a bunch of cosntructors
12:55:47 <emu> data Flag = Verbose | NumFoos Int | ...
12:56:05 <pitecus> how does one lookup the matching constructor in a list?
12:56:45 <emu> personally, i do things like "Verbose `elem` flags" or find isNumFoos flags
12:56:50 <emu> there's probably a better way
12:57:16 <pitecus> ya you have to define IsWhatever for each constructor
12:57:51 <emu> something akin to the permutation parser of parsec would probably be nice
12:57:54 <glguy> you could do somethign like: [a | NumFoos a <- flags]
12:58:13 <wy> monochrom: I guess I have the same problem. I figured out how to turn the vmware dhcp server down
12:59:03 <aes2> Why is avg xs = (sum xs) / (fromIntegral (length xs)) correct? (/) needs an instance of Fractional to operate on, but AFAIK, it only gets a Num.
12:59:11 <wy> I guess we need to build some kind of belief network to solve all these configuration problems
12:59:24 <pitecus> its not that pretty but ok. thanks guys
12:59:39 <glguy> aes2: length returns an Int, fromIntegral :: Int -> Float -- for examle in this case
12:59:49 <glguy> aes2: or anything other fractional for that matter
13:00:39 <glguy> ?type liftM2 (/) sum (fromIntegral . length)
13:00:40 <lambdabot> forall b. (Fractional b) => [b] -> b
13:00:52 <jethr0> aes2: if "xs" is a list of fractionals, then it correct
13:01:25 <jethr0> sum :: (Num a) => [a] -> a
13:01:32 <aes2> @type fromIntegral
13:01:34 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:01:37 <emu> i wonder if it would  be infeasible to extend haskell to allow things like `liftM2 (/)`
13:01:50 <jethr0> aes2: Num is a supertype of Fractional (i think)
13:02:01 <koala_man> is there anyone here who thinks software by its nature can only be expressed functionally, and that the imperative programming model is invalid?
13:02:05 <jethr0> superclass
13:02:05 <aes2> jethr0: it is.
13:02:22 <glguy> ?type flip id sum (liftM2 (/)) genericLength
13:02:23 <lambdabot> forall i. (Fractional i) => [i] -> i
13:02:38 <aes2> glguy: why would Num b imply Float?
13:02:42 <jethr0> aes2: so, a sum of a list of Fractionals will yield a fractional. and fromIntegral turns an Integral into whatever Num. so what's the confusion?
13:02:42 <glguy> (flip id)   sum (liftM2 (/)) genericLength [1,3,7,10]
13:03:00 <aes2> glguy: can you give another example where the same rule applies?
13:03:00 <glguy> aes2: because all Fractionals are Num
13:03:13 <glguy> All Floating are Fractional
13:03:14 <jethr0> ?type sum ([1,2,3] :: Float)
13:03:16 <lambdabot>   Couldn't match `Float' against `[a]'
13:03:16 <lambdabot>    Expected type: Float
13:03:19 <glguy> All Num are Eq
13:03:19 <jethr0> ?type sum ([1,2,3] :: [Float])
13:03:22 <lambdabot> Float
13:03:27 <aes2> glguy: but not all Nums are Fractionals.
13:03:34 <glguy> aes2: right
13:03:43 <aes2> glguy: fromIntegral only returns a Num, not a Fractional
13:03:54 <aes2> glguy: why would this Num also be a Fractional?
13:04:03 <glguy> aes2: it returns *something* that is a Num
13:04:08 <glguy> in this case that something is a Float
13:04:11 <glguy> or
13:04:12 <glguy> Double
13:04:21 <aes2> glguy: since (/) is defined for the Fractional class.
13:04:34 <jethr0> aes2: fromIntegral returns *any* kind of Num. not any concrete kind, but any
13:04:38 <glguy> aes2: the function is actually operating on a type and not a class
13:04:43 <jethr0> > fromIntegral 4 :: Float
13:04:45 <lambdabot>  4.0
13:04:52 <jethr0> > fromIntegral 4 :: Double
13:04:54 <lambdabot>  4.0
13:04:55 <glguy> it's operating on some actual type that matches those constraints
13:04:58 <jethr0> > fromIntegral 4 :: Rational
13:04:59 <lambdabot>  4%1
13:05:08 <aes2> jethr0: and why would that any kind of Num be an instance of Fractional?
13:05:22 <jyp> @ping lemmih
13:05:22 <jethr0> because the type inference tells fromIntegral to return a Fractional
13:05:23 <lambdabot> Not in scope: type variable `lemmih'
13:05:34 <jyp> ping lemmih, then.
13:05:35 <jethr0> in the context of (/)
13:05:42 <glguy> aes2: by definition, anything that is a Fractional is a Num
13:06:06 <glguy> if I can sell you ANY color marble, and you need blue marbles
13:06:11 <glguy> you can always buy blue marbles from me
13:06:21 <jethr0> glguy: ^_^
13:06:36 <aes2> glguy: are you also saying that fromIntegral returns a Fractional?
13:06:45 <jethr0> aes2: it can
13:06:46 <glguy> aes2: it CAN return a fractional
13:06:50 <jethr0> see my examples above
13:06:53 <glguy> I CAN sell you blue marbles ;)
13:07:14 <aes2> glguy: this works in general?
13:07:36 <glguy> there is no magic to this specific to fromIntegral
13:07:39 <jethr0> aes2: yes. although i don't quite understand the question
13:08:02 <wy> Why isn't patterns lazy by default?
13:08:26 <sjanssen> because they'd hardly ever work
13:08:27 <glguy> wy: How would you do pattern matching without having to match patterns?
13:08:53 <sjanssen> in f ~(x:xs) = always matches; f [] = will never match
13:09:08 <Cale> let f ~(x:xs) = 5 in f []
13:09:12 <Cale> > let f ~(x:xs) = 5 in f []
13:09:13 <lambdabot>  5
13:09:16 <Cale> > let f ~(x:xs) = x in f []
13:09:17 <lambdabot>  Add a type signature
13:09:24 <Cale> > let f ~(x:xs) = x :: Int in f []
13:09:25 <lambdabot>  Irrefutable pattern failed for pattern (x : xs)
13:09:36 <Cale> > let f ~(x:xs) = x :: Int; f [] = 4 in f []
13:09:37 <lambdabot>  Irrefutable pattern failed for pattern (x : xs)
13:09:46 <jethr0> but why aren't patterns lazy by default then? i don't quite get that either
13:10:06 <jethr0> ah
13:10:08 <glguy> because you need strict patterns more often than lazy ones
13:10:08 <Cale> Because lazy patterns never fail to match
13:10:19 <Cale> Pattern bindings are always lazy
13:10:25 <jethr0> > let f []  = 4; f ~(x:xs) = x in f []
13:10:27 <lambdabot>  4
13:10:34 <Cale> patterns in function bindings are default strict
13:10:36 <jethr0> k, i see
13:10:37 <glguy> > let (a,b) = undefined in 4
13:10:38 <lambdabot>  4
13:11:00 <glguy> > f (a,b) = 4 in f undefined
13:11:00 <lambdabot>  Parse error
13:11:05 <glguy> > let f (a,b) = 4 in f undefined
13:11:06 <lambdabot>  Undefined
13:11:07 <jethr0> they need to be strict to discern between matches and failures
13:11:43 <glguy> strict bindings would be weird because they would force functions to evaluate
13:11:47 <glguy> even when you don't need the results
13:12:18 <emu> ie. strict evaluation
13:12:28 <augustss> there!  i've again sent a patch to the black hole, also known as cvs-ghc@haskell.org.
13:12:46 <jethr0> so when is lazy matching sensible? i've never used it, yet
13:12:47 <emu> i'm confused. isn't there a darcs archive for ghc now?
13:13:05 <augustss> that's where 'darcs send' sends it
13:13:22 <Cale> You've probably used it when pattern binding things, but it's rarely needed in function bindings
13:13:26 <glguy> > fix (\ ~(a,b) -> (1,a) )
13:13:28 <lambdabot>  (1,1)
13:13:30 <glguy> > fix (\ (a,b) -> (1,a) )
13:13:32 <lambdabot>  Exception: <<loop>>
13:13:39 <glguy> there's a case where you need it
13:13:43 <wy> Can I copy a 4-line code here?
13:13:46 <glguy> ?paste
13:13:47 <lambdabot> http://paste.lisp.org/new/haskell
13:14:02 <glguy> syntax highlighting for the win
13:14:13 <Cale> wy: sure, but it's probably better to paste it with lisppaste
13:14:34 <syntaxfree> I "found out"  about lazy matching today as well.
13:14:40 <syntaxfree> I had learned about it, but never used.
13:15:01 <lisppaste2> wy pasted "Here is where lazy pattern should be used. But I need to build it more intuitive into my mind so that I won't forget." at http://paste.lisp.org/display/33157
13:15:24 <jethr0> syntaxfree: so in what context did you use it?
13:15:51 <wy> OK. I guess we can analyse this code carefully
13:16:05 <glguy> wy: the alternative would be to use head and tail
13:16:14 <syntaxfree> I never used it.
13:16:14 <syntaxfree> I was taking a look at the spanish translation of the Gentle Introduction, and saw it.
13:16:16 <augustss> You don't need the lazy matching often, but when you do it's crucial
13:16:49 <syntaxfree> can't lazy matching always be replaced by a let block?
13:16:50 <wy> augustss: That's why I think I need to build some intuition
13:17:20 <mbishop> Anyone have an opinion on "Alice ML"? looks kind of neat with it's optional lazy eval and distributed stuff
13:17:22 <augustss> the ~ pattern isn't necessary, you can always rewrite it in some way.  ~ is just a convenience
13:17:28 <jethr0> wy: isn't "server xs = map process" or maybe mapM?
13:17:30 <glguy> syntaxfree: let blocks use lazy matching
13:17:31 <aes2> Don't you mean "more practical" instead of "crucial"?
13:17:47 <augustss> aes2: no, sometimes it's crucial
13:17:55 <syntaxfree> augustss: when?
13:18:00 <glguy> > fix (\ (a,b) -> (1,a) )
13:18:02 <lambdabot>  Exception: <<loop>>
13:18:06 <glguy> like when it causes <<loop>>
13:18:11 <glguy> when you don't have it
13:18:40 <augustss> you need it in, e.g., unzip of an infinite list
13:18:46 * jethr0 considers fix to be obfuscating. can't you always write a concrete recursive function instead of using "fix"?
13:19:00 <jethr0> hm
13:19:01 <syntaxfree> I don't understand fix yet.
13:19:21 <syntaxfree> @type fix
13:19:22 <lambdabot> forall a. (a -> a) -> a
13:19:43 <glguy> jethr0: it works great for anonymous, recursive functions
13:19:52 <jethr0> syntaxfree: well, there's understanding how it WORKS and understanding how to USE it sensibly. sadly, i am far from the second.
13:20:38 <augustss> jethr0: there is very rarely a reason to use fix
13:21:05 <jethr0> glguy: the problem with anonymous, recursive functions is that they have no name to explain what they do
13:21:06 <glguy> forever = fix . (>>)
13:21:13 <augustss> I might have used it twice in all my haskell code
13:21:38 <glguy> forever x = aux where aux = x >> aux
13:21:57 <augustss> forever x = x >> forever x
13:22:14 <jethr0> yes, and that's pretty much the definition of fix ^_^
13:22:24 <jethr0> not quite
13:22:30 <jyp> does someone know the status of the hIDE project?
13:22:38 <glguy> augustss: righ, but I don't care for passing parameters that don't change
13:23:21 <Excedrin> mbishop: I like Alice ML, but there's a few rough edges. The constraint stuff can leak memory due to the way Alice deals with C libraries, and there's a few syntactic issues (inability to specify literal IntInf except via IntInf.fromString "213")..
13:23:21 <sjanssen> glguy: use the worker wrapper style
13:23:34 <glguy> sjanssen: my aux version?
13:23:39 <sjanssen> forever x = go where go = x >> go
13:23:54 <opqdonut> agh
13:23:55 <sjanssen> glguy: ah yes, didn't see that one
13:24:02 <glguy> sjanssen: what's how I usually define it
13:24:05 <glguy> that*
13:24:09 <wy> jethr0: They are the same. You can use map
13:24:25 <glguy> forever = sequence . repeat
13:24:37 <sjanssen> sequence_
13:24:43 <glguy> yeah, that :)
13:24:50 <glguy> repeatM_ = sequence_ . repeat
13:25:21 <sjanssen> jyp: I think hIDE is dormant
13:25:37 <lisppaste2> wy annotated #33157 with "I forgot to put the auxilary functions" at http://paste.lisp.org/display/33157#1
13:25:43 <jyp> sjanssen: Ok, thanks.
13:25:44 <jethr0> unfortunately. i would have loved to have an editor in and for haskell
13:25:51 <jyp> I'll have to discuss this with Lemmih.
13:26:36 <jyp> I'm currently trying to make the repo (http://darcs.haskell.org/hIDE) compile against ghc 6.6
13:26:38 <lambdabot> Title: Index of /hIDE
13:26:42 <wy> jethr0: Yeh. Something like an ascii art editor
13:26:46 <jyp> Not sure if it's worth.
13:27:09 <jethr0> wy: your code makes my brain hurt
13:27:41 <wy> change client to: client init ~(resp:resps) = init : client (next resp) resps
13:27:41 <glguy> client init xs = init : map next xs
13:27:41 <glguy> server      = map process
13:27:45 <glguy> That's the same... right?
13:28:39 <jethr0> glguy: do you realize the whole thing is cyclical? i don't know how well map handles that. and wy's point is to use lazy matching for this, right?
13:28:52 <glguy> jethr0: his point was to show when you would require it
13:30:24 <glguy> > let reqs = 1 : map (+1) resps; resps = map (+1) reqs in take 10 resps
13:30:26 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
13:30:30 <jethr0> yes, and as in the "fix" example you might need it for fully cyclical problems
13:30:30 <wy> glguy: If you change client init xs = init : map next xs. take 10 reqs will work. Because you got rid of pattern matching
13:30:39 <glguy> wy: right
13:30:40 <jethr0> hmm, or not
13:31:20 <glguy> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 10 evens, take 10 odds)
13:31:21 <wy> glguy: So this example is rather contrived
13:31:21 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18],[1,3,5,7,9,11,13,15,17,19])
13:32:04 <glguy> wy: I'm not even sure that you would need lazy pattern matching in that case, since the init : would match teh first (x:xs) on server
13:33:03 <wy> If you write client like: client init (resp:resps) = init : client (next resp) resps.  You will need lazy patterns
13:33:15 <glguy> wy: ah, I see it
13:33:43 <glguy> but only on client
13:34:19 <wy> glguy: yes only on client
13:37:07 <wy> But I still need the intuition to determine when to use lazy patterns...
13:37:28 <glguy> in this case it's because matching the pattern depends on the results of the function
13:38:01 <glguy> I would imagine you don't usually need them until something breaks
13:38:09 <glguy> At least I haven't needed them yet
13:38:25 <wy> If you change server to: server reqs = 1 : map process reqs. It will work
13:38:30 <glguy> right
13:38:49 <glguy> then the first element is known before the patern is matched
13:39:32 <wy> glguy: yes. I think I need to know it now because if something breaks, there will be infinite loop and I can't get any feed back of the location of the error
13:40:20 <glguy> in this case it easy, you are trying to match the pattern on results you'll get after you match the pattern
13:40:33 <glguy> its like needing a key that's locked inside a chest
13:41:04 <glguy> lazy evaluation trusts you to open the chest with the promise that if you try to use the lock you will have the key
13:41:43 * glguy doesn't actually know how comfortable you are with the concept and apologizes if he's talking down
13:42:27 <monochrom> lazy evaluation still doesn't mean "read my mind" :)
13:43:18 <Cale> > product (repeat 1)
13:43:22 <lambdabot> Terminated
13:44:15 <glguy> Cale: can you make a "paper rock scissors" out of that?
13:44:20 <glguy> repeat beats product
13:44:52 <monochrom> hahahahaha you're drunk
13:45:08 <glguy> lawl
13:45:12 <wy> So in this case, "head reqs" will need the head of the result of calling "client 1 resps". Calling "client 1 resps" will try to match resp:resps against resps, which is the result of calling "server reqs". But "server reqs" will try to match "req:reqs" against reqs, which we don't know even the head of it...
13:45:48 <glguy> wy: the issue is that the (:) constructor hasn't been returned yet
13:45:57 <glguy> not that the values aren't known
13:46:41 <wy> glguy: yes. So we went back to (:) before it returned?
13:47:35 <glguy> You are asking if a (:) or [] is going to be returned, and it doesn't know until you return one
13:47:41 <monochrom> I still like how Dana Scott puts it.  [on least fixed points as the meaning of recursive definitions] That's it, no iteration, no executing anything.
13:49:16 <wy> glguy: So it's chasing its tail. Compile it will give <<loop>>
13:49:45 <glguy> right
13:49:47 <glguy> wait
13:49:49 <glguy> compile is fine
13:49:52 <glguy> run-time
13:50:03 <glguy> OH
13:50:11 <glguy> but compile gives the error as a courtesy maybe
13:50:53 <wy> glguy: maybe there can be warnings on that? maybe not?
13:51:14 <glguy> I don't know the details of how each compiler handles it
13:51:16 <monochrom> He is actually not entirely honest.  To find out more about the least fixed point, you still end up performing a few iterations to see the pattern.  However, at least that calculation is more enlightening than executing - by starting from bottom, you see clearly what remains botom and what begins giving out results.
13:52:08 <monochrom> I think compilers respect your intention to write a blackhole.
13:52:34 <monochrom> I think "compile it will give <<loop>>" may refer to: compile to an executable, the executable will give <<loop>>
13:53:00 <glguy> ?let f (x:xs) = f [1]
13:53:01 <lambdabot> Defined.
13:53:06 <glguy> > f [1]
13:53:07 <lambdabot>  Not in scope: `f'
13:53:11 <glguy> > L.f [1]
13:53:11 <monochrom> L.f
13:53:12 <lambdabot>  Add a type signature
13:53:35 <wy> monochrom: yes the excutable will give <<loop>>
13:54:08 <wy> I guess the compiler can't know that. It's detected at runtime
13:54:40 <monochrom> The compiler *can* detect it, provided the language spec says it should.
13:55:04 <monochrom> or nevermind :)
13:55:17 <wy> Oh. Yes... I see
13:56:22 <wy> Does this mean that the loops the compiler can detect are the same ones as the runtime can detect?
13:56:31 <augustss> no
13:56:50 <monochrom> I was 40% joking.
13:57:13 <sjanssen> the loop detection is a side effect of how heap updates work, as I understand it
13:57:14 <wy> I guess this case is simple enough for a compiler to detect?
13:57:18 <augustss> at compile time you don't know what path the execution will follow.  it might not be possible to reach the loop
13:57:48 <augustss> there are some cases you can detect at compile time
13:57:57 <augustss> @type let x = x in x
13:57:58 <lambdabot> forall t. t
13:58:03 <augustss> like that
13:58:19 <augustss> only bottom has that type
13:58:20 <monochrom> Some cases are simple enough to detect.  But a language spec would avoid requiring that.  This is because writing down the definition of "simple cases" is too complicated, not worth it.
13:58:43 <monochrom> Specifications should avoid confusing both the user and the implementer.
13:59:57 <augustss> you mean it should only confuse one of them? ;)
14:00:08 <monochrom> Yeah :)
14:00:52 <wy> I see. Is it possible for changes in the specification of Haskell in the future. I found it a pain of the specs of Common Lisp and Scheme, which won't change
14:01:13 <augustss> Haskell is likely to change
14:01:36 <augustss> but usually in a backwards compatible way
14:01:37 <sjanssen> wy: there is a committee working on the next version of Haskell as we speak
14:01:43 <emu> scheme changes every few years
14:02:08 <emu> haskell' is the keyword to read about the new version
14:02:16 <sjanssen> plus, every major release of GHC adds extensions to the language :)
14:02:22 <wy> But it seems some changes weakened Scheme
14:02:24 <monochrom> It still doesn't specify detecting simple infinite loops :)
14:02:44 <augustss> nor is it ever likely to specify that
14:03:07 <wy> I guess a warning is allowable?
14:03:17 <monochrom> Yes. allowable.
14:03:51 <augustss> sure, warnings are ok about a lot of potential mistakes
14:03:55 <wy> Good. I'll go on learning
14:04:11 <monochrom> I prefer to fix the problem at the level of programmer education.
14:04:27 <emu> is that detection toggleable by the way?
14:04:29 <monochrom> And if that fails, programmer replacement.
14:05:00 <sjanssen> emu: I don't think so
14:05:01 <augustss> emu: you mean by looping instead?
14:05:08 <emu> yes, hitting bottom, so to speak
14:05:27 <sjanssen> Exception: <<loop>> is _|_
14:05:42 <augustss> it would be easy to add, of course
14:06:03 <emu> believe it or not, a prof here raised an objection to GHC because it does that detection
14:06:03 <augustss> but it's kinda built into the execution machinery that you get the detection
14:06:25 <sjanssen> emu: why?
14:07:03 <monochrom> If the ghc team announces "we have some time, we can implement one of the follow two, pick one: debugging, bottom detection"  I will vote for debugging.  Just so as to STFU all those morons asking for debugging.
14:07:03 <emu> because, in the theoretical case where you want the behavior to be _|_, it's not?
14:07:33 <sjanssen> as I said earlier, Exception: <<loop>> _is_ bottom
14:07:38 <augustss> yep
14:08:06 <augustss> except when you do funny non-deterministic things in the IO monad to catch exceptions
14:08:13 <dancor> is there a cool way to make an enum pair like deriving bool so i can use not
14:08:18 <augustss> but in the IO monad anything can happen
14:08:21 <sjanssen> the Haskell standard says that error "", undefined, and nontermination are all considered _|_
14:08:22 <wy> It at first looked to me like somebody solved the halting problem ;-)
14:08:22 <ndm> monochrom: why would anyone _not_ want debugging?
14:08:38 <sjanssen> in fact, error s = error s -- is a rule abiding definition of error
14:08:47 <edi> ?type not
14:08:48 <lambdabot> Bool -> Bool
14:08:57 <edi> dancor: |not|'s is not polymorphic.
14:09:00 <monochrom> I don't want debugging.  I want bottom detection.  Observe that decent bottom detection translates to decent program verification.
14:09:08 <augustss> dancor: you'll have to make your own not
14:09:23 <edi> (argh, too many `is', sorry.)
14:09:43 <ndm> monochrom: i'm doing bottom detection, and i still want debugging - what if your program corrently gives the wrong answer
14:09:47 <dancor> how about defining a next on enums
14:09:52 <dancor> that cycles
14:09:56 <dancor> that would be cool
14:10:05 <augustss> next, you mean succ?
14:10:11 <monochrom> I erase the program.
14:10:11 <augustss> @type succ
14:10:12 <lambdabot> forall a. (Enum a) => a -> a
14:10:24 <augustss> ah, that cycles
14:10:28 <dancor> if that cycles, right
14:10:36 <sjanssen> @type \x -> if x == maxBound the minBound else succ x
14:10:37 <lambdabot> parse error on input `else'
14:10:37 <dancor> cycc
14:10:47 <sjanssen> @type \x -> if x == maxBound then minBound else succ x
14:10:48 <lambdabot> forall a. (Eq a, Bounded a, Enum a) => a -> a
14:11:08 <monochrom> Anyway I have casted my vote, and it goes to debugging.
14:11:08 <augustss> sjanssen: you beat me to it :)
14:11:34 <ndm> unfortunately this isn't a vote situation, if you want something doing, you have to do it yourself
14:11:36 <glguy> monochrom: toss your vote in the <<loop>> :)
14:12:24 <wy> augustss: Recently I ran into problems with Simon Peyton Jones's book. He hasn't implemented parser or even data type for "if" conditionals but he asks the readers to implement "if" with structured data at the sematic level. Do you think the "if" statements should be parsed first?
14:12:27 <monochrom> I am doing research on writing programs correctly.
14:13:01 <augustss> wy: not if 'if' is a regular function
14:13:11 <dancor> monochrom: but are you doing that research correctly
14:13:20 <wy> augustss: Can it be a regular function?
14:13:28 <monochrom> Yes, I am doing that correctly too.
14:13:29 <augustss> wy: sure
14:13:44 <wy> augustss: Only when the language is lazy?
14:13:46 <augustss> wy: in haskell the word is reserved, but otherwise it could
14:13:50 <augustss> wy: yes
14:14:01 <wy> augustss: So I see :-)
14:14:05 <dancor> why would you want Enum without Bounded and Eq
14:14:23 <glguy> > let iff True = const; iff False = flip const in iff (1==1) 2 3
14:14:24 <augustss> Integer is Enum
14:14:24 <lambdabot>  2
14:14:26 <monochrom> maybe Eq but not Bounded
14:14:34 <dancor> i would even throw in Show and Read too
14:14:34 <glguy> dancor: what is the maxBound of Integer?
14:15:17 <sjanssen> dancor: ewwww
14:15:18 <augustss> The Enum class has some nasty operations that don't really belong there that makes Eq always implementable
14:15:21 <dancor> big integer
14:15:26 <glguy> > maxBound :: Integer
14:15:27 <lambdabot>  add an instance declaration for (Bounded Integer)
14:15:27 <lambdabot>   In the expression: ma...
14:15:40 <wy> augustss: In his core language, "case" is reserved, but "if" is not, nor is it parsed
14:15:56 <sjanssen> dancor: requiring Show and Read would just repeat the mistake made in the Num class
14:16:08 <dancor> what is that mistake
14:16:09 <augustss> wy: so then you can make 'if' a 3 argument function
14:16:12 <ndm> wy: very few core languages have if in them, a case is just easier
14:16:35 <augustss> sjanssen: yes, big mistake
14:16:45 <dancor> i mean how does that mistake become apparent
14:16:47 <glguy> > let iff True = const; iff False = flip const in iff (0==1) 2 3
14:16:49 <lambdabot>  3
14:16:54 <sjanssen> dancor: that Num a implies Show a
14:17:09 <wy> augustss: So I must take Pack{2,1} as an atomic expression, not a normal one
14:17:34 <augustss> dancor: try adding real numbers to Num.  you can't show them in a sensible way (nor compare them)
14:17:43 <dancor> ok i see
14:17:48 <augustss> wy: I don't remember enough of the book to answer that
14:17:50 <sjanssen> augustss: how did it happen?
14:18:18 <glguy> ?djinn Bool -> b -> b -> b
14:18:18 <lambdabot> f a b c =
14:18:19 <lambdabot>   case a of
14:18:19 <lambdabot>   False -> c
14:18:20 <lambdabot>   True -> b
14:18:39 <dancor> what i djinn
14:18:44 <augustss> sjanssen: Eq is needed for some default method, I think.  Show was added late because some people thought it made debugging easier.
14:18:45 <wy> augustss: Thanks for the hint. I guess I can restart it tomorrow. I must take a rest today to read more about Haskell ;-)
14:18:45 <dancor> s/\bi\b/is
14:18:46 <sjanssen> Eq is required for k and n+k patterns, but I have no idea why Show is
14:19:03 <glguy> ?help djinn
14:19:03 <lambdabot> djinn <type>.
14:19:03 <lambdabot> Generates Haskell code from a type.
14:19:03 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:19:08 <glguy> dancor: ^^
14:19:12 <augustss> Show is totally unnecessary.  It was added late.
14:19:38 <glguy> and from the looks of that URL, augustss wrote it
14:19:39 <glguy> :)
14:19:45 <wy> Is darc written in Haskell?
14:19:48 <glguy> yeah
14:20:06 <dancor> glguy: it just generates any old fcn?
14:20:17 <augustss> of the right type
14:20:22 <glguy> dancor: it generates a total function I believe
14:20:25 <glguy> of the correct type
14:20:26 <augustss> yes
14:20:40 <monochrom> yeah total function
14:20:40 <dancor> can anyone think of a case where you would want Enum but not Eq.  or where Num shouldn't have Eq
14:20:56 <augustss> Num should not be Eq for real numbers
14:21:09 <dancor> why not
14:21:12 <monochrom> Num without Eq: functions.
14:21:12 <augustss> equality is not computable for reals
14:21:18 <sjanssen> dancor: instance (Num b) => Num (a -> b)
14:21:22 <monochrom> Enum without Eq: can't think of one.
14:21:52 <monochrom> There is no real number.
14:22:08 <augustss> 4.2
14:22:11 <dancor> augustss: i'm not sure what that means
14:22:12 <augustss> pi
14:22:41 <dancor> how would you define Real
14:22:52 <dancor> even if Num weren't Eq and Show
14:22:58 <augustss> You can implement real numbers in Haskell (not floating point, real real numbers).  If you do, it's impossible to always decide if to numbers are equal or not
14:23:22 <augustss> http://www.augustsson.net/Darcs/CReal/
14:23:24 <lambdabot> Title: Index of /Darcs/CReal
14:23:25 <monochrom> floating point is unreal.  just a funny subset of the rationals.
14:23:34 <augustss> fp sucks big time
14:23:47 <glguy> you don't like functional programming :-o
14:23:50 <glguy> ;)
14:23:53 <wy> f x = if (x<0) then 1 else [] can be typed. So how can I tell it's wrong?
14:23:58 <bosse-> Do they use convergent series to define reals?
14:24:14 <glguy> wy, you can type that?
14:24:14 <augustss> bosse-: yes, kinda
14:24:22 <monochrom> real is like function in this regard.  actually you kind of notice it by cardinality
14:24:29 <wy> :type f x = if (x<0) then 1 else []
14:24:30 <sjanssen> wy: if you instance Num [a], then it can be typed
14:24:39 <wy> @type f x = if (x<0) then 1 else []
14:24:40 <lambdabot> parse error on input `='
14:24:55 <dancor> what makes a real computable
14:25:00 <glguy> wy: that only works if 1 can be converted to a list
14:25:01 <monochrom> you need 1 and [] to be of the same type
14:25:31 <glguy> wy: if' :: Bool -> a -> a -> a
14:25:40 <augustss> if you can compute the value of something it is computable (you are not allowed to loop forever)
14:25:47 <monochrom> > if True then "Hello" else Maybe "Hello"
14:25:48 <lambdabot>  Not in scope: data constructor `Maybe'
14:25:55 <monochrom> ah nevermind
14:25:59 <glguy> heh
14:26:02 <wolverian> > if True then 1 else "foo"
14:26:03 <lambdabot>  add an instance declaration for (Num [Char])
14:26:03 <lambdabot>   In the definition of `tar'...
14:26:17 <monochrom> Remember, this is not Perl!
14:26:44 <augustss> those if statements can be given types, but not in Haskell
14:26:47 <wolverian> of course, us perlers have written their Num String instances..
14:26:56 <glguy> > if True then 42 else (putStrLn "sweet")
14:26:57 <lambdabot>  add an instance declaration for (Num (IO ()))
14:26:57 <lambdabot>   In the definition of `xmz...
14:27:21 <dancor> i just don't understand how you can represent a real.  you are always restricted to a subset of the reals that can be stored in any particular storage format on a finite computer
14:27:36 <monochrom> > if 1==undefined then "" else Just ""
14:27:36 <lambdabot>  Couldn't match `[Char]' against `Maybe a'
14:28:05 <dancor> you can either use fixed or floating point or like allow radicals in the representation etc
14:28:07 <augustss> dancor: so, in all these theoretical endevous we imagine that we have infinite memory
14:28:08 <glguy> :t if undefined then undefined else undefined
14:28:10 <lambdabot> forall a. a
14:28:16 <wy> sjanssen: How can I instance Num [a]?
14:28:31 <dancor> augustss: yeah but then simple fixed point with two infinite lists of digits will do it
14:28:31 <monochrom> One way to implement reals: Nat -> Rational.  There are many other ways, depending on application.
14:28:31 <glguy> :t \a b c -> if a then b else c
14:28:33 <lambdabot> forall t. Bool -> t -> t -> t
14:28:55 <augustss> dancor: second, you can only represent what is called the computable reals (so if you believe in classical mathematics a lot of real numbers will be missing)
14:29:27 <sjanssen> wy: first you develop a reasonable notion of all the arithmetic operators on lists, then you write "instance Num [a] where ..."
14:29:31 <monochrom> Please do not instance Num [a].  "if ... then 1 else []" is nonsense.  Please, nonsense.
14:29:39 <augustss> dancor: twho infinite lists would be one representation
14:30:08 <wolverian> monochrom, but "24" + 2 is so convenient! :)
14:30:12 <sjanssen> wy: as monochrom notes, you probably don't want to actually write that instance
14:30:20 <augustss> dancor: and you can see how equality is problematic with that representation :)
14:30:22 <dancor> augustss: so why is floating point bad
14:30:32 <dancor> augustss: oh i agree Eq is problematic
14:30:49 <augustss> for instance: (x+y)+z /= x+(y+z)
14:30:57 <augustss> sometimes
14:31:31 <augustss> few laws hold for floating point
14:31:36 <sjanssen> @check \x y z -> (x + y) + z == x + (y + z) :: Float -> Float -> Float -> Bool
14:31:37 <lambdabot>    Expecting a function type, but found `Bool'       Expected type: Float -...
14:31:50 <sjanssen> @check (\x y z -> (x + y) + z == x + (y + z)) :: Float -> Float -> Float -> Bool
14:31:52 <lambdabot>  Falsifiable, after 16 tests: 0.6, 3.8, 5.0
14:32:01 <glguy> > 1 / 100003 * 100003 == 1
14:32:03 <lambdabot>  True
14:32:08 <glguy> > (1 / 100003) * 100003 == 1
14:32:09 <lambdabot>  True
14:32:15 <glguy> > (1 / 100003) * 100003 == 1 :: Float
14:32:16 <lambdabot>  Couldn't match `Float' against `Bool'
14:32:20 <glguy> > (1 / 100003) * 100003 == (1 :: Float)
14:32:21 <lambdabot>  False
14:32:27 <glguy> OH
14:32:28 <glguy> sorry
14:32:31 <glguy> I thought I was in /query
14:33:23 * monochrom murders glguy 
14:34:11 <dancor> augustss: but those would hold in an infinite representation that was floating point
14:34:18 <dancor> augustss: but yeah i see
14:34:19 <wy> So I guess if (x<0) then 1 else [] will be soon detected as an error later
14:34:49 <augustss> dancor: they would hold.  but you would not be able to use the == to check it :)
14:34:50 <sjanssen> wy: yes
14:35:09 <monochrom> soon or later.  better soon than later.
14:35:16 <wy> sjanssen: When someone calls it?
14:35:27 <monochrom> When someone compiles it.
14:36:00 <monochrom> In Python it will be when someone runs it.
14:36:19 <sjanssen> wy: as soon as the compiler attempts to instantiate 'a' in (Num [a]) => [a] -> Bool
14:36:39 <sjanssen> which is at type checking time
14:37:27 <monochrom> In Perl it will be two months after someone runs it, when someone else takes a look at the program output (the program generates a log file) and find that because of that bug the whole log file is corrupted and because it is already two months it is a total loss.
14:37:33 <wy> sjanssen: Good. So static typing is guranteed
14:37:47 <sjanssen> yep
14:37:59 <dancor> augustss: hah, true
14:38:02 <monochrom> Don't you love it when Perl does all these "smart" conversions behind your back.
14:38:40 <wolverian> it's useful when it is not a bug. it is not always a bug. ergo, it's a feature.
14:38:53 <sjanssen> love it like a kick to the back of the skull
14:39:07 <monochrom> Haha I'm great at creating flame wars.
14:39:14 <wolverian> yes you are. :)
14:39:24 <augustss> wolverian: it's not useful enough for me to give up static type checking :)
14:39:29 <wolverian> augustss, that's fine. :)
14:40:52 <augustss> now, in Cayenne you can give it a statically checked type, of course :)
14:40:53 <wy> When I was taking my PL class this semester. There is a kind of subtype polymorphism. If a<a' and b'<b, then a'->b' is a subtype of a->b. Thus a function of type a'->b' can be substituted into any context using a function of type a->b. I tried to use this kind of polymorphism in Haskell but I failed to write a program demonstrate it.
14:41:30 <augustss> wy: haskell doesn't have subtyping
14:41:44 <wy> -_-!
14:42:15 <wy> augustss: Later one of my classmate told me C has this kind of polymorphism ;-)
14:42:43 <augustss> gimme a good cast operator and i can implement any polymorphism you want! :)
14:43:10 <augustss> void* is your friend
14:43:18 <wy> augustss: you are refering to C? :-)
14:43:24 <augustss> of course
14:43:27 <Saizan> if i have Foo a as an instance of class C, how can i have Foo (Foo a) also instance of class C but with different methods definition?
14:43:38 <monochrom> subtyping is nice but overrated.
14:43:38 <wy> augustss: So can I say subtype is not good?
14:43:43 <integral> @type Data.Typeable.cast
14:43:44 <lambdabot> forall b a. (Typeable b, Typeable a) => a -> Maybe b
14:44:00 <augustss> wy: what monocrom said
14:44:07 <augustss> monochrom, even
14:44:40 <wy> monochrom: What other languages other than C has subtyping?
14:44:41 <sjanssen> Saizan: that requires overlapping instances.  GHC can do that, but I recommend finding another way
14:44:55 <monochrom> C has subtyping?!
14:45:05 <augustss> wy: C doesn't really have subtyping
14:45:11 <augustss> C++ does
14:45:28 <augustss> kinda
14:45:43 <wy> augustss: any other one with better reputation?
14:45:43 <monochrom> OCaml has subtyping.  And it is not crappy subtyping, it is well-thought-out subtyping.
14:46:13 <monochrom> There are also various extensions to System F ... :)
14:46:16 <wy> monochrom: I see
14:46:22 <dancor> augustss: what do you do with your creals class
14:47:00 <augustss> Well, you can compute some numbers, and print them with a certain number of decimals
14:47:32 <wy> augustss: will haskell has subtyping someday?
14:47:33 <augustss> i've not used them in any serious way
14:47:55 * augustss gazes into his crystal ball.
14:48:15 <emu> there is subclassing..
14:48:23 <augustss> The future is cloudy.  I see a man in sandals...
14:49:00 <reppie> http://www.ktvu.com/news/10584004/detail.html
14:49:02 <lambdabot> Title: Nina Reiser's Blood Found In Estranged Husband's Car - News
14:49:12 <hyrax42> ?index IORef
14:49:12 <lambdabot> Data.IORef
14:55:30 <hyrax42> ?fptools Control.Monad.State
14:55:30 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:57:21 <ndm> wy: i see very few type feature systems that will not end up in GHC given enough time
14:58:25 <wy> ndm: You mean it's very good?
14:58:36 <glguy> or that it's a research platform?
14:58:51 <ndm> wy: i mean its a research platform, and one day, someone will think of doing it
14:59:36 <augustss> some form of subtyping would be nice to have, actually
14:59:41 <glguy> was the move to System Fc somethign that will make it a lot easier for them to add type system extesions in teh future
14:59:53 <glguy> or does it just help clean the current code...
15:00:00 <fridim> Good evening
15:00:05 <augustss> Mostly the latter, I'd say
15:00:20 <augustss> ad to implement associated types
15:00:31 <ndm> if by subtyping you mean some restirctinos on which constructors can occur within a type
15:00:45 <ndm> then i have a tool which gives you some of the benefits of that, as a checker
15:00:50 <augustss> But Fc does have some promise in making some things easier to add
15:00:55 <glguy> ndm: doesn't taht exist now?
15:00:57 <ndm> i.e. my tool checks head is safe
15:01:01 <glguy> ndm: in the head branch
15:01:12 <ndm> glguy: what are you refering to?
15:01:20 <ndm> glguy: not anything specific i can think of..
15:01:39 <glguy> ndm: you can put constraits on the type variables of data types
15:01:52 <ndm> glguy: links?
15:01:53 <augustss> ndm: the tool would be cool.  but I'd like to document the subtypes as type annotations
15:01:58 <glguy> like: data Whatever a where WhateverConstructor :: Enum a => a
15:02:03 <ndm> augustss: thats entirely possible
15:02:04 <glguy> err, Whatever a *
15:02:09 <ndm> glguy: you mean GADT's?
15:02:24 <glguy> ndm: it uses the GADT syntax
15:02:27 <glguy> but isn't GADT
15:02:46 <augustss> ndm: does you tool handle records as well?
15:02:50 <glguy> SPJ wrote about it on the mailing list i beleive (but I could be misquoting the intent)
15:03:12 <ndm> augustss: they are translated away by Yhc before my code gets to them, but some records examples do work fine
15:03:32 <augustss> ndm: i mean record subtyping
15:03:34 <ndm> glguy: i thought the intent was about removing unneeded dictionaries, if you are refering to the one i am thinking of
15:03:40 <augustss> and the checking thereof
15:03:49 <ndm> augustss: what do you mean by record subtyping?
15:04:01 <glguy> ndm: very well may have been, I'm searching for that post now...
15:04:19 <ndm> glguy: if i did miss a massive piece of related work, would be nice to correct that error :)
15:04:28 <augustss> I'd like to have a record with x and y fields, and then another record which extends the first one with a z field
15:04:32 <glguy> ndm: I imagine that you know better than I
15:04:57 <ndm> augustss: yes, it handles that (thats the record sample i was playing with)
15:05:03 <ndm> glguy: you'd be surprised :)
15:05:03 <glguy> ndm: oh, which constructors can occur in a type:
15:05:27 <glguy> ndm: so, data MyType a = MyType (List a), where List a is a (:)
15:05:27 <glguy> ?
15:05:42 <ndm> glguy: yes, thats what mine allows
15:05:45 <glguy> ok
15:05:49 <glguy> that's not what I saw :)
15:05:54 <ndm> good good :)
15:06:58 <augustss> ndm: sounds very interesting!
15:07:48 <ndm> augustss: should have some concrete code available in a few months at most, if haskell was first order this would be so much easier...
15:09:10 <glguy> Does anyone know of some sample use of GADT that isn't a eval function?
15:09:47 <ndm> glguy: have you seen the Compos paper?
15:10:17 <ndm> glguy: http://portal.acm.org/citation.cfm?doid=1159803.1159834
15:10:18 <glguy> I don't think so
15:10:18 <lambdabot> Title: A pattern for almost compositional functions
15:10:27 <augustss> ndm: if Haskell were first order it would make many, many things easier.  except using it :)
15:10:50 <glguy> ndm: looks like I'd need to be an ACM member for that one :)
15:11:20 <ndm> glguy: http://delivery.acm.org/10.1145/1160000/1159834/p216-bringert.pdf?key1=1159834&key2=6342476611&coll=&dl=ACM&CFID=15151515&CFTOKEN=6184618
15:11:23 <lambdabot> http://tinyurl.com/yxweba
15:11:35 <ndm> (using google scholar, i'm at home at the moment, where i don't have ACM membership)
15:11:36 <glguy> ah, cool, thanks
15:11:53 <ndm> augustss: yes, indeed - which is why what i am writing at the moment is a first order convertor for haskell
15:12:18 <dancor> it seems like my cyclic successor fcn should still work for un-Bounded Enums (and just behave like succ)
15:13:00 * glguy wonders how that is possible
15:14:34 <glguy> seems to me that your function either requires the type to be an instance of Bounded, or will never have access to min and maxBound
15:14:43 <augustss> hmmm, you have to be a bit twisted to write that function :)
15:16:01 <augustss> but i think cycc can be written without requiring Bounded
15:16:21 <glguy> you could do this:
15:16:46 <glguy> cycc min max current =
15:16:55 <glguy> err
15:17:02 <glguy> cycc min current
15:17:10 <glguy> and if succ current causes and error
15:17:12 <glguy> then return min
15:17:20 <glguy> causes an*
15:17:29 <glguy> > succ True
15:17:30 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
15:18:10 <augustss> cycc x = head $ tail [x ..] ++ [x,pred x, ..]
15:18:29 <augustss> that's the gist, but it needs some kinks fixed
15:18:52 <augustss> oops, i forgot a reverse on the second list
15:19:49 <glguy> > [True ..]
15:19:50 <lambdabot>  [True]
15:20:37 <glguy> cycc x = let (_:xs) = [x ..] in if null xs then last [x,pred x ..] else head xs
15:21:02 <glguy> this would blow up if your instance of Enum had a single Constructor
15:21:15 <glguy> ?hoogle enumFrom
15:21:16 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
15:21:16 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
15:21:16 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
15:21:24 <glguy> ?hoogle+
15:21:24 <lambdabot> Prelude.enumFromTo :: Enum a => a -> a -> [a]
15:21:25 <augustss> yep.  that's what i meant about the kinks :)
15:21:25 <lambdabot> Language.Haskell.Syntax.HsEnumFrom :: HsExp -> HsExp
15:21:25 <lambdabot> Language.Haskell.Syntax.HsEnumFromThen :: HsExp -> HsExp -> HsExp
15:21:35 * glguy wondered if there was an enumDownFrom
15:21:58 <glguy> ?hoogle a -> [a]
15:21:59 <lambdabot> Prelude.repeat :: a -> [a]
15:22:00 <lambdabot> List.intersperse :: a -> [a] -> [a]
15:22:00 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
15:22:22 <augustss> no enum down, i'm afraid
15:22:28 <glguy> yeah... didn't think so
15:22:31 <glguy> but I had to try :)
15:25:14 <augustss> i can't see a way to make it work for types with a single constructor
15:26:43 <glguy> class CyclEnum a where next :: a -> a
15:27:22 <augustss> sure, but that's no fun
15:27:41 <glguy> so this is just one of those things Haskell's not built for, eh?
15:28:16 <augustss> it's built for it, but someone forgot enumDown :(
15:28:40 <augustss> or forgot to make next a member of Enum
15:29:07 <glguy> I think there might be certain laws that succ needs to abide by
15:29:17 <glguy> maybe this is intentional
15:31:08 <augustss> there's no reason not to include cyclic next/prev in the Enum class, i think
15:31:14 <glguy> > toEnum -1 :: Bool
15:31:15 <lambdabot>  Couldn't match `Bool' against `Int -> a'
15:31:26 <augustss> except no one thought about it
15:31:46 <augustss> toEnum and fromEnum are nasty functions.  they should not have been in Enum
15:32:00 <augustss> at least not with those types
15:32:15 <augustss> It should be Integer, not Int
15:32:34 <augustss> > toEnum (-1) :: Bool
15:32:35 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
15:32:45 <glguy> yeah, I did that in /msg
15:33:03 <augustss> fromEnum (2^32::Integer)
15:33:16 <augustss> > fromEnum (2^32::Integer)
15:33:17 <lambdabot>  0
15:47:49 <flagitious> is it possible to do something like this? xx (as ++ "0" ++ bs) =
15:48:06 <emu> no
15:48:16 <pesco> bringert: Hey, I saw your HMarkup. Did you know of my project in the same direction?
15:48:22 <flagitious> dang, it would be handy :)
15:48:39 <emu> flagitious: are you by any chance following that cellular automata blog
15:49:01 <flagitious> no, im trying to make a short sudoku solver
15:49:01 <glguy> > let a ++ b = 1 in [1,2] ++ [5,6]
15:49:03 <lambdabot>  1
15:49:35 <glguy> emu: the comonadic one?
15:49:52 <emu> you were thinking of that too
15:50:14 <glguy> only after you asked ;)
15:50:44 <glguy> before you asked I just planned on providing a potentially confusing by unhelpful example
15:50:50 <glguy>  but
15:50:55 <ski_> emu : which ?
15:59:15 <emu> ski_: sigfpe's recent blog
16:03:29 <augustss> he always has amazing blog entries
16:05:38 <ski_> @users
16:05:38 <lambdabot> Maximum users seen in #haskell: 309, currently: 141 (45.6%), active: 20 (14.2%)
16:05:51 <psnl> split?
16:06:01 <Vq^> seems so
16:06:02 <ski_> augustss : indeed
16:07:55 <bringert> pesco: actually I didn't know of yours before. You mean http://www.khjk.org/~sm/code/khjk-structured-text/ right? I made HMarkup just for Hope, and I've used it for some static documents, like this one http://www.cs.chalmers.se/~bringert/darcs/hs-web-tut/ (on-hold work in progress). I'm not orking actively, and it's the sort of thing that I would prefer not to have to maintain.
16:07:57 <lambdabot> Title: Index of /~sm/code/khjk-structured-text/
16:08:14 <bringert> s/orking/working on it/
16:12:44 <syntaxfree> sigfpe has a good blog.
16:16:04 <allbery_b> so much for 300 users :)
16:21:38 <augustss> ?users
16:21:38 <lambdabot> Maximum users seen in #haskell: 309, currently: 229 (74.1%), active: 24 (10.5%)
16:33:39 <vomjom_> are there any disadvantages to using ByteString over String?
16:33:53 <jrockway> unicode?
16:34:05 <vomjom> is that all?
16:34:46 <jrockway> maybe not, see http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
16:34:47 <lambdabot> Title: Rewriting Haskell Strings
16:35:18 <jrockway> lambdabot uses it :)
16:37:01 <augustss> vomjom: if you have some function on lists it will not work on ByteString, so there might some missing functionality in ByteString
16:42:40 <glguy> ?hoogle
16:42:41 <lambdabot> HOOGLE - Haskell API Search
16:42:41 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
16:42:41 <lambdabot>  
16:42:45 <glguy> ?users
16:42:45 <lambdabot> Maximum users seen in #haskell: 309, currently: 250 (80.9%), active: 1 (0.4%)
16:42:54 <augustss> so much going and coming
16:42:58 <glguy> 1 active :)
16:43:13 <glguy> I'm not sure I've seen ?users announce so low an active count
16:43:36 <augustss> no, that's very low
16:43:38 <jrockway> i think there was just a netsplit, or something
16:43:44 <glguy> yeah, there was
16:43:50 <glguy> ?where stats
16:43:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
16:43:52 <ndm> yeah, i only just came back
16:44:04 <ndm> ?hoogle+
16:44:04 <lambdabot> Usage: hoogle [OPTION...] search
16:44:05 <lambdabot>  -v                  --verbose   verbose results
16:44:05 <lambdabot>  -n 30               --count=30  number of results
16:44:12 <glguy> lol
16:44:40 <ndm> ?hoogle map -v
16:44:41 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-v'
16:44:51 <jrockway> ?hoogle -v map
16:44:51 <lambdabot> hoogle: unrecognized option `- '
16:44:51 <lambdabot> unrecognized option `-m'
16:44:52 <lambdabot> unrecognized option `-a'
16:44:54 <lambdabot> unrecognized option `-p'
16:44:56 <lambdabot> HOOGLE - Haskell API Search
16:44:58 <lambdabot> [18 @more lines]
16:45:14 <ndm> (hoogle has mild parsing issues in version 3, all fixed in the development branch)
16:45:32 <glguy> Most referenced nicks: #8 glguy =D
16:45:56 <glguy> #5 ndm
16:46:10 <ndm> ah :)
16:46:18 <ndm> dcoutts and dons get in the top 4, i guess
16:46:33 * dcoutts__ grins
16:46:33 <glguy> #4 SamB
16:46:38 <glguy> #3 lambdabot
16:46:40 <glguy> #2 Cale
16:46:42 <glguy> #1 dons
16:46:49 <ndm> where is dcoutts?
16:46:53 <dcoutts__> phew! not me :-)
16:46:55 <glguy> not listed
16:46:57 <augustss> and where is the stats?
16:47:08 <glguy> dcoutts is number #9 most active
16:47:12 <glguy> #11 ndm
16:47:16 <glguy> #15 glguy
16:47:28 <ndm> yeah, i often sign out for days at a time to do some work :)
16:47:39 <dcoutts__> ndm: no worries, it means we get fewer stalkers ;-)
16:47:56 <dcoutts__> poor Cale
16:48:06 <glguy> #4 most active: Cale
16:48:48 <glguy> if dcoutts would stick to one nick, he'd be #7 mos active
16:48:49 <ndm> dcoutts__, its looking currently like i will be able to HAC07, but won't know for sure til 26th december
16:48:58 <dcoutts__> glguy: heh
16:49:04 <dcoutts__> ndm: cool
16:49:26 <glguy> oops
16:49:31 <glguy> #5
16:49:44 <glguy> I missed the points for both __ *and* _
16:53:13 <glguy> dcoutts_ has quite a potty mouth. 0.0% words were foul language.
16:53:19 <dcoutts__> !?
16:53:27 <glguy> no, not you
16:53:30 <glguy> dcoutts_
16:53:34 <allbery_b> heh
16:53:36 <dcoutts__> hah
16:53:39 <jrockway> 0.0%!
16:53:42 <ndm> thats probably one of the highest ratios on this channel
16:53:43 <jrockway> that is just inexcusable
16:53:57 <glguy> Pseudonym also makes sailors blush, 0.0% of the time.
16:54:04 <dcoutts__> how can I be potty mouthed none of the time and yet be potty-mouthed?
16:54:19 <ndm> dcoutts__, you missed the 0000000000001 at the end :)
16:54:27 <glguy> that number is obviously only acurate to one significant digit
16:54:31 <dcoutts__> hrm
16:54:47 * dcoutts__ is sure lambdabot swears more than himself
16:55:01 <glguy> ?yow
16:55:01 <augustss> helvete!  fan!
16:55:02 <lambdabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
16:55:08 <dcoutts__> @yarr!
16:55:09 <lambdabot> I want me grog!
16:55:18 <augustss> wonder if it counts swedish foul language?
16:55:35 <ndm> woohoo, my optimiser just optimised (x :: [Int] == x) to basically "deepSeq x"
16:55:42 <glguy> The loudest one was araujo, who yelled 11.5% of the time!
16:55:44 <jrockway> ?eval f (x:xs) = xs ++ [x]; f "kfuc"
16:55:50 <augustss> @quote
16:55:51 <lambdabot> Taral says: But I can do DP in C, which has no RT
16:56:02 <augustss> @quote
16:56:03 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
16:56:03 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
16:56:06 <glguy> > reverse "kcuf"
16:56:08 <lambdabot>  "fuck"
16:56:12 <glguy> OH!
16:57:01 <SamB_XP> reverse it again!
16:57:11 <glguy> Another old yeller was SamB_XP, who shouted 9.5% of the time!
16:57:15 <jrockway> > reverse
16:57:15 <lambdabot>  Add a type signature
16:57:19 <jrockway> > reverse "it again"
16:57:21 <lambdabot>  "niaga ti"
16:57:33 <jrockway> (enter and " are too close together..)
16:58:29 <SamB_XP> @bot
16:58:29 <lambdabot> :)
16:59:35 <SamB_XP> where were those stats again?
17:00:35 <glguy> ?where stats
17:00:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:00:53 <glguy> According to searchirc.com, #haskell is the 13th largest channel on freenode
17:01:02 * SamB_XP vaguely remembers something like that not working last time he tried it
17:02:37 <LordBrain> 13.. hmmmm  what are the first 12?
17:02:52 <monochrom> #java :)
17:02:58 <LordBrain> haha
17:03:01 <Adamant> #gentoo and #ubuntu are probably huge.
17:03:19 <LordBrain> yeah
17:03:19 <glguy> 12->1 kde asterisk freenode-social kubuntu ruby-lang mysql rubyonrails c++ c gentoo perl ubuntu
17:03:39 <jrockway> wow, rubyonrails?
17:03:51 <monochrom> what? we surpass #java ?!
17:03:55 <jrockway> i thought there were like 3 people actually using it
17:04:10 <Stinger_> the rest are there for the hype
17:04:16 <glguy> #math is #24
17:04:19 <glguy> java is after that
17:04:28 <monochrom> ok, that's nice to know.
17:04:30 <LordBrain> interesting
17:04:38 <glguy> it might not have a freenode channel?
17:04:45 <Stinger_> what is 12->1?
17:04:51 <monochrom> I guess humankind has hope afterall.  merry christmas.
17:04:51 <glguy> 12th place
17:04:53 <glguy> 1st place
17:04:55 <Stinger_> oh har har
17:05:47 <glguy> scheme #75, ##java 79
17:06:19 <glguy> I believe the list is sorted by "current users"
17:06:23 <glguy> not max or average
17:07:04 <glguy> which is good for haskell
17:07:07 <glguy> because we'd go way down otherwise
17:08:14 <vomjom> is there a reason lists aren't just a typeclass?  so that way, extensions that act like lists (ByteString) can work with any functions that operates on lists
17:10:08 <int-e> vomjom: better performance (as Cale put it, lists are our loops. we want those to be fast.), and better type inference (thus better error messages)
17:10:59 <beschmi> vomjom: i think you need associated types for that since there is no ByteString a
17:11:13 <Cale> Plus, we have some typeclasses now like Traversable which really do give you most of that sort of thing.
17:12:40 <ndm> vomjom: and you can't pattern match on a type class
17:13:03 <Cale> Overloading pattern matching against list constructors would be a little too deceptive, I think.
17:13:39 <vomjom> thanks for the responses.  i'm new to haskell so i'm just trying to understand things a bit better :)
17:14:48 <Cale> The reason you want to use other structures over lists is usually because you have a nonlinear access pattern and want better performance. Overloading the list constructors to let you apply list functions to those other structures would usually result in poorer performance than if you'd just used lists.
17:32:13 <sorear> ?seen
17:32:13 <lambdabot> Lately, I have seen sorear.
17:32:16 <sorear> ?uptime
17:32:16 <lambdabot> uptime: 52m 33s, longest uptime: 9d 2h 23m 6s
17:32:43 <glguy> low uptime..
17:34:18 <lambdabot> There is a perfectly good explanation for the low uptime.  Dons changed a hardcoded parameter two days ago, and had to reboot me for the change to take effect.
17:34:29 <dcoutts__> heh
17:34:50 <sorear> muahahaha... I think I will have no use whatsoever for the change, oh well.
17:35:01 <jrockway> it takes 1 day, 23 hours, and 8 minutes for it to come back up?
17:36:17 <sorear> I had a small fit of perversion...
17:39:42 <sorear> ... and lisppaste seems dead, so I can't show my 625 character theorum prover. Sorry.
17:40:21 <ndm> sorear: shove it on the wiki forevermore, then link to it
17:40:52 <mgsloan> gtk2hs has the most rediculous installers i have ever seen
17:41:20 <kolmodin_> mgsloan: anything in particular?
17:41:53 <lambdabot> mgsloan: You have 1 new message. '/msg lambdabot @messages' to read it.
17:42:01 <ndm> mgsloan: i do want to redo it at some point, so if you have any points to make, we can get them fixed
17:42:07 <mgsloan> well, I tried compiling it, but that didn't work (required Data.FiniteMap)
17:42:25 <mgsloan> then i tried installing the debian deb on ubuntu
17:42:35 <ndm> ah, not the windows installer :)
17:42:43 <mgsloan> no, now i'm doing the windows installer
17:43:10 <kolmodin_> mgsloan: the stable version of gtk2hs doesn't support ghc 6.6
17:43:25 <kolmodin_> mgsloan: for ghc 6.6 you'd have to use the darcs version (development version)
17:43:30 <mgsloan> And that halts saying i should probably have gtk2, and I do, and the PATH var points to it
17:43:44 <mgsloan> and I have 6.4.1 and 6.6 installed on windows
17:43:57 <kolmodin_> ghc 6.4.1 should work fine
17:44:25 <mgsloan> well, I just ran the latest gimp gtk+ setup, and same thing
17:44:50 <mgsloan> "The Gtk+ libraries are not on the Windows search path"
17:45:07 <mgsloan> ah, perhaps it is because I have D:\Program Files instead of C:\Program Files
17:45:51 <mgsloan> Couldn
17:45:53 <sorear> ndm: do you have any specific ideas of where to put it?  Having optimized for character count, the code is hardly 'exampl'ary :)
17:45:59 <mgsloan> 't it just let me install, though?
17:46:20 <ndm> sorear: Short Theorem Proover?
17:46:38 <mgsloan> I hate it when software (especially installers) treats you like a baby.  I want a "take my chances" option
17:46:42 <ndm> sorear: don';t worry too much, someone can just move it later
17:46:44 <kolmodin_> mgsloan: I'm not that familiar with gtk2hs on windows
17:47:00 <glguy> When using GADTs parameterized over phantom data types, could you acheive the same result using arbitrary data types instead of phantom ones? (say using Int and Float as indexes?)
17:47:04 <mgsloan> kolmodin_: ah, well I'd rather get it working on linux
17:47:06 <kolmodin_> mgsloan: maybe dcoutts__ has some clues. dcoutts__, still awayke?
17:47:19 <kolmodin_> mgsloan: nice
17:47:28 <kolmodin_> mgsloan: which distro are you running?
17:47:30 <syntaxfree> I don't understand GADTs.
17:47:31 <mgsloan> ubuntu
17:47:44 <kolmodin_> ok, hmm
17:47:46 <ndm> glguy: is this relating to the Compos paper i showed you?
17:47:52 <glguy> ndm yes
17:48:07 <sorear> where should I link to it from?
17:48:11 <kolmodin_> mgsloan: and there are no prebuilt packages you can use?
17:48:14 <ndm> glguy: i think you could use real types, int etc, but then people might supply values, which isn't a good thing to do
17:48:23 <ndm> sorear: is there an examples section on the wiki?
17:48:30 <glguy> ndm: they might supply values?
17:48:31 <mgsloan> there are debs, but they require stuff that isn't in the ubuntu repos
17:48:35 <kolmodin_> mgsloan: I'm a gentoo user myself. everything works nice here
17:48:36 <ndm> glguy: the idea of a phantom type is it has no runtime value
17:48:50 <glguy> ndm: I understand that it's not a good idea
17:49:07 <mgsloan> I should probably try the darcs copy though.  My problems probably stem from the fact that stable requires 6.4.1
17:49:19 <mgsloan> which i don't have on linux
17:49:26 <ndm> glguy: i think it would work though]
17:49:31 <kolmodin_> mgsloan: so no probuilt thing for latest gtk2hs? and if you'd like to build it yourself there are things missing?
17:49:39 <glguy> ndm: OK, that helps my understanding of what they do
17:49:49 <Philippa> ndm: no value can be supplied if the constructor doesn't take one
17:50:01 <mgsloan> right, there's nothing for ubuntu
17:50:05 <glguy> ndm: basically, this is allowing one to write functions that operate on more than one standard datatype
17:50:12 <Philippa> using Int, Bool etc is a good idea if somewhere down the line a value of that type might be produced
17:50:14 <allbery_b> I wasn't able to build darcs gtk2hs on our linux boxen (suse 9.3) because it wanted a newer autoconf
17:50:17 <mgsloan> I think the things missing are due to deprecation becoming removal
17:50:24 <allbery_b> and replacing autoconf wasn't really an option
17:50:33 <Philippa> (see the usual Term example...)
17:50:36 <mgsloan> well, mine starts to compile but halts on some glib stuff
17:50:38 <ndm> glguy: yes
17:51:05 <glguy> but this doesn't cooperate well with type-classes?
17:51:20 <ndm> glguy: not currently
17:51:30 <mgsloan> I'll restart into ubuntu...
18:03:27 <mgsloan> probably best to get the source anyway as i may contrib some patches
18:03:50 <mgsloan> from reading some of the code before i think matrix inverse might not even work...
18:10:35 <syntaxfree> Lisp is *very* different from Haskell after all.
18:10:54 <syntaxfree> http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp
18:10:57 <lambdabot> Title: Why Ruby is an acceptable LISP, http://tinyurl.com/h63pv
18:15:50 <glguy> syntaxfree: as seen on reddit?
18:15:58 <int-e> hmm. "Paul Graham's canonical example" ... runStateT  and  modify (+k) >> get.
18:16:12 <sorear> ndm: it's on the wiki
18:16:25 <sorear> it's also 35ch shorter
18:17:35 <sorear> what if it could be make smaller a hundred still? @djinn would have competition!
18:17:46 <mgsloan> oh, and sorry for the abrasive, critical attitude from before - i was quite fed up with trying to get it working, and that seems to get results
18:18:01 <dibblego> how can I have a finite list with a memoized length?
18:18:13 <ndm> sorear: where?
18:18:14 <kolmodin_> mgsloan: it works?
18:18:30 <mgsloan> well, the make is still going, but looks like it will :)
18:18:46 <sorear> ?wiki Short theorum prover
18:18:47 <lambdabot> http://www.haskell.org/haskellwiki/Short theorum prover
18:18:48 <mgsloan> dibblego: your own data type perhaps?
18:18:54 <glguy> (4,[1,4,7,9]) -- list + memoized length
18:18:57 <dibblego> mgsloan, it still lazily evaluates
18:19:16 <dibblego> glguy, are tuples eagerly evaluated?
18:19:22 <sorear> no
18:19:59 <glguy> or: [(4,1),(3,4),(2,7),(1,9)]
18:20:37 <dibblego> how can that be written as its own data type?
18:20:55 <dibblego> [a] -> (Int, [a]) ?
18:20:57 <sorear> http://www.haskell.org/haskellwiki/Short_theorum_prover
18:20:59 <lambdabot> Title: Short theorum prover - HaskellWiki
18:21:04 <glguy> data DibbList a = DibbCons a (DibbList a) Int | DibbNull
18:21:31 <glguy> or
18:21:32 <dibblego> glguy, then how does [a] -> DibbList a look?
18:21:41 <ndm> sorear: cool, looks interesting - maybe a short "tutorial" style section showing how to invoke it, and what kind of things it can prove?#
18:21:52 <glguy> dibblego: like a fold
18:21:56 <dibblego> glguy, I wrote that data type thinking it would memoize
18:22:26 <dibblego> ah wait
18:22:31 <dibblego> mine was a little different
18:22:39 <dibblego> ok I see, thanks
18:23:27 <dibblego> so who's up for writing 'Why LISP is an acceptable Haskell"?
18:23:27 <dcoutts__> mgsloan: sigh, win32 installers are a rpita
18:23:52 <glguy> dibblego: how might one argue that LISP is an acceptable Haskell?
18:24:18 <dcoutts__> mgsloan: there will be a tarball for the new release shortly and then a new win32 installer
18:24:38 <dibblego> glguy, point out that macros are a hack?
18:24:48 <dcoutts__> mgsloan: as for 'take my chances', sadly 99% of the time that'd == 'will not work'
18:24:58 <Philippa> glguy: by constructing an artificial value of "acceptable" based on someone who doesn't care about safety :-)
18:25:03 <dibblego> oh, I didn't get the meaning right to start with
18:25:08 <ndm> dcoutts__, have been chatting to the simons, they seem keen on a unified installer for haskell stuff and using it in GHC
18:25:20 <dcoutts__> mgsloan: I coded the installer very defensively yet there seem to be so many failure cases
18:25:22 <ndm> dcoutts__, hopefully that will remove the pain from Haskell installers...
18:25:42 <dcoutts__> ndm: I'd love it, I'd like to talk about it at Hac07 if possible
18:25:54 <ndm> dcoutts__, yep, makes perfect sense
18:25:54 <dcoutts__> ndm: as far as I see, the main issue is .dlls
18:25:58 <glguy> macros make a lot of sense when you want to invent a way to declare a variable and have it be useable in a special way
18:26:01 <ndm> dcoutts__ - why?
18:26:09 <glguy> like writting a letcc macro in scheme
18:26:18 <ndm> dcoutts__ - oh, you mean Gtk dlls, not producing dll's of haskell stuff
18:26:19 <dcoutts__> ndm: either foreign C .dlls or producing haskell packages as .dlls
18:26:24 <dcoutts__> both
18:26:35 <dcoutts__> both are/will be problematic
18:26:37 <glguy> allowing you to write (more complicated versions of) (letcc done (done 'simplecase))
18:26:37 <ndm> producing dll's of haskell stuff is something i intend to punt entirely on
18:26:39 <emu> are theorums inspired by alcohol?
18:26:51 <ndm> winhaskell will have integrated cabal support
18:26:55 <dcoutts__> and for the same reasons, dll loading / search paths
18:27:00 <sorear> emu: ? unlikely
18:27:03 <ndm> if you use haskell dll's you are a haskell developer
18:27:15 <ndm> therefore use winhaskell, and get them installed with cabal in one click
18:27:26 <emu> as opposed to say, theorems
18:27:38 <dcoutts__> ndm: ghc can now produce shared object files for packages on osx and win32
18:28:05 <ndm> dcoutts__, but binary packages should probably bundle their required dll's
18:28:05 <dcoutts__> ndm: I don't mean dlls wilth external C apis, I mean building a .dll rather than an .a file for a ghc package
18:28:24 <ndm> hmm, lots of issues...
18:28:37 <ndm> would these things "go away" if you had somewhere on the %PATH% to put Gtk stuff?
18:28:43 <glguy> Of course, this is only a hint of what you can do with lambda. Languages which favor this style of programming are called functional languages, because they work with functions. A dense functional language can be very concise indeed, and quite clear once you learn to read it.
18:28:50 <dcoutts__> ndm: possibly yes
18:29:20 <ndm> dcoutts__, i say all haskell installers on windows just register c:\program files\haskell\bin on PATH - makes everything so much more reliable
18:29:23 <glguy> I suddenly feel like I understand less about functional programming after reading the first few pages of this blog post
18:29:34 <glguy> and not because I've realized that there is more to it
18:29:52 <dcoutts__> ndm: it's not that easy if other things have dlls with the same name, eg zlib.dll
18:30:14 <ndm> dcoutts__, there is the options of manifests and side-by-side dll's
18:30:25 <dcoutts__> I'd like to look into that option
18:31:55 <dcoutts__> perhaps if that can be made to work, add a feature to ghc to make it link the .exe with the right options to generate and embed a manifest so make it pull in the right dlls
18:32:15 <dcoutts__> that could be used to support building ghc packages as dlls
18:32:25 <dcoutts__> and also for C dlls like gtk+ etc
18:32:33 <ndm> where is the hac wiki page?
18:32:42 <dcoutts__> @google Hac 2007
18:32:43 <lambdabot> http://haskell.org/haskellwiki/Hac_2007
18:32:44 <lambdabot> Title: Hac 2007 - HaskellWiki
18:32:44 <ndm> was going to start a what to discuss/look at
18:33:02 <dcoutts__> good idea, talk to dons and Igloo too
18:34:21 <dcoutts__> mgsloan: the problem with the win32 installer is we need exactly the right ghc version, and a suitable gtk+ installation on the %PATH%
18:34:35 <dcoutts__> I don't think the gimp's installer sets it up that way
18:34:46 <dcoutts__> hace the gtk2hs page links to the reccomended gtk+ installer
18:35:03 <glguy> """ I’m looking forward to your next editorial, perhaps it could be titled something like “Why Java is an acceptable Forth”. Maybe, if I’m lucky, “Why assembly is an acceptable binary”.
18:35:22 <dcoutts__> mgsloan: if you know about installers and want to lend a hand to make it less **** then I'd be most grateful of the help
18:35:24 <ndm> dcoutts__, have you seen gimpshop? its a 100 times better than gimp at installation, much more reliable
18:35:32 <dcoutts__> nope
18:35:42 <dcoutts__> I don't use gimp on win32
18:35:58 <ndm> its basically a few tweaks over gimp, but the reason i use it is it changes the installation from being a crapshoot, to a sure thing
18:36:15 <dcoutts__> I think the next gtk2hs installer should come with it's own gtk+
18:36:29 <dcoutts__> though we'd still have problems with the %PATH%
18:36:34 <dcoutts__> but perhaps less so
18:36:51 <dcoutts__> since we could put all our dlls on the path first :-)
18:37:07 <dcoutts__> though people might complain about that too
18:37:14 <ndm> yes, i think one single installer is the way forward
18:37:23 <ndm> if it works, less people willcomplain, because most people won't care
18:37:38 <dcoutts__> it means I need to figure out what gtk+ bits are absolutely necessary
18:38:11 <dcoutts__> I think actually that on we could get away without needing to supply all the gtk+ .h files
18:38:33 <dcoutts__> we can't atm, but we might be able to change
18:39:28 <dcoutts__> anyway, bedtime
18:39:35 * dcoutts__ -> sleep
18:39:42 <ndm> night night dcoutts__
18:40:19 <sorear> (Disclaimer: I am not a windows-user) Can the unified installer be made part of the hackage/cabal system?
18:41:20 <jcreigh> @pl (\(c, f) -> char c >> return (f a))
18:41:21 <lambdabot> uncurry ((. (return . ($ a))) . (>>) . char)
18:42:10 <mgsloan> bah, missed him
18:42:15 <mgsloan> (dinner)
18:45:38 <mgsloan> hmm, I don't know much about installers.  I mostly avoid them.  Anyway, I'm pretty sure my path was set correctly
18:46:09 <mgsloan> sweet, compiled fine ;)
18:46:51 <SamB_XP> yeah, nobody will ever know much about installers
18:47:13 <SamB_XP> (except the kind that you use to install entire systems)
18:47:43 <SamB_XP> that is why package managers are the way of the future
18:47:52 <sorear> anyone interested in rewriting apt-get in portable Haskell ;-)
18:48:45 <SamB_XP> hmm, isn't linspire debian-based?
18:49:01 <mgsloan> yeah, if only people actually updated the repos
18:49:10 <sorear> does Vista have a pm yet?
18:49:20 <mgsloan> (maybe i should switch to debian if i want that)
18:50:28 <SamB_XP> well, eventually windows will have one...
18:50:32 <ndm> sorear: no...
18:50:43 <ndm> GuiHaskell will provide package management for haskell programs
18:50:52 <sorear> should I be suprised?
18:50:56 <SamB_XP> ndm: too little too late!
18:51:08 <SamB_XP> packages should begin with installation of the operating system
18:51:17 <ndm> SamB_XP: agreed, but its way too late for that
18:51:39 <SamB_XP> ndm: no, it isn't.
18:52:02 <SamB_XP> assuming the world isn't going to end in the next few decades
18:52:13 <mgsloan> bah, I'm just using ghci and it accuses me of using the '-threaded' flag
18:52:34 <SamB_XP> it is only a matter of time until MS are forced to steal the idea
18:52:52 <ndm> mgsloan: ghci is done with threading
18:52:57 <mgsloan> ah
18:53:13 <mgsloan> so to do gtk2hs I have to compile?
18:53:15 <ndm> SamB_XP: the idea is not really new or deep, its rather obvious
18:53:25 <ndm> mgsloan: i always do, not sure if you have to
18:53:32 <sorear> I find it amazing how MS is making such a big deal about having cloned scripting...
18:53:50 <sorear> ...and then they boast about getting the most important faced wrong.
18:54:07 <SamB_XP> ndm: yes. basically I mean either MS will decide that it is important to actually have the feature, or ReactOS will finally have it and this causes the former...
18:54:13 <sorear> "All our commands are linked directly into the shell!"
18:54:28 <SamB_XP> "facet"
18:54:33 <mgsloan> ok, well, I get a whole bunch of errors for the .o - undefined reference.  Probably a result of using gcc as a backend...
18:54:35 <sorear> uh, /bin was created for a REASON...
18:54:55 <SamB_XP> don't they have like /powershell-plugins or something?
18:56:31 <mgsloan> Drawing2.o: In function `s9V6_info': undefined reference to `gtkzm0zi9zi10zi2_GraphicsziUIziGtkziWindowsziWindow_windowNew_closure'
18:56:31 <mgsloan> Drawing2.o: In function `s9V2_info': undefined reference to `gtkzm0zi9zi10zi2_GraphicsziUIziGtkziGeneralziGeneral_initGUI_closure'
18:56:33 <mgsloan> etc
19:01:11 <ndm> mgsloan: if you can't figure it out, email them, but only dcoutts here can probably answer that
19:02:30 * SamB_XP seems to remember something about -package flags
19:12:09 <hyrax42> ?docs Text.ParserCombinators.Parsec
19:12:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
19:13:51 <hyrax42> ?hoogle Either a b -> Maybe b
19:13:52 <lambdabot> No matches, try a more general search
19:14:03 <hyrax42> ?hoogle Eithar a b -> Maybe a
19:14:03 <lambdabot> No matches, try a more general search
19:14:11 <hyrax42> ?free Either a b -> Maybe b
19:14:11 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:14:20 <hyrax42> oops
19:14:29 <hyrax42> ?djinn Either a b -> Maybe b
19:14:29 <lambdabot> f a =
19:14:30 <lambdabot>   case a of
19:14:30 <lambdabot>   Left _ -> Nothing
19:14:30 <lambdabot>   Right b -> Just b
19:15:25 <sorear> free can't parse types for some silly reason
19:15:39 <sorear> ?free either (const.Nothing) (Just)
19:15:39 <lambdabot> Extra stuff at end of line
19:15:43 <sorear> ?free (either (const.Nothing) (Just))
19:15:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:15:51 <sorear> ?free (either (const.Nothing) Just)
19:15:51 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:15:54 <sorear> ?free Just
19:15:54 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:15:58 <sorear> ?free const
19:15:59 <lambdabot> f . const x = const (f x) . g
19:16:16 <hyrax42> I keep confusing free and djinn
19:16:17 <sorear> and I see it doesn't do well with expressions either
19:16:23 <sorear> ?free (const id)
19:16:24 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:16:27 <sorear> ?free (const id
19:16:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:16:28 <sorear> ?free const id
19:16:29 <lambdabot> Extra stuff at end of line
19:16:48 * sorear stops bugging lambdabot
19:17:15 <mgsloan> oh - doh! didn't see that makefile...
19:18:33 <mgsloan> cool, works :)
19:19:15 <hyrax42> ?type mapM
19:19:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
19:19:50 <hyrax42> > repeat 5
19:19:51 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
19:20:16 <SamB_XP> ?free const
19:20:17 <lambdabot> f . const x = const (f x) . g
19:20:31 <SamB_XP> hmm, not a bad theorem
19:20:37 <SamB_XP> ?free (>>=)
19:20:38 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:20:43 <hyrax42> ?type ap
19:20:44 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
19:20:45 <SamB_XP> ?free return
19:20:46 <lambdabot> Expected variable or '.'
19:20:52 <SamB_XP> ?free ()
19:20:52 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:20:58 <SamB_XP> ?free Just
19:20:59 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:21:15 <SamB_XP> ?free either
19:21:16 <lambdabot> f . k = p . h => f . q = f1 . g => f . either k q = either p f1 . $map_Either h g
19:21:22 <SamB_XP> wow
19:21:25 <SamB_XP> that one is huge
19:21:31 <SamB_XP> @free maybe
19:21:32 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
19:22:03 <sorear> ?free >>=
19:22:03 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:22:08 <sorear> ?ft >>=
19:22:09 <lambdabot>  There was an error in the type: (line 1, column 7):
19:22:09 <lambdabot>  unexpected "e"
19:22:09 <lambdabot>  expecting "->" or end of input
19:22:13 <sorear> ?ft (>>=)
19:22:14 <lambdabot>  There was an error in the type: (line 1, column 8):
19:22:14 <lambdabot>  unexpected "("
19:22:14 <lambdabot>  expecting "::"
19:22:24 <SamB_XP> ?ft ()
19:22:25 <lambdabot>  t1 = t1
19:22:30 <SamB_XP> ah
19:22:32 <jcreigh> okay, so what does @free do? @help free says "free <ident>. Generate theorems for free", which doesn't help me much...
19:22:37 <SamB_XP> not exactly what I was expecting
19:22:40 <SamB_XP> ?ft Just
19:22:41 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
19:22:41 <lambdabot>   forall x1 :: T1.
19:22:41 <lambdabot>    (t1 x1, t1 (h1 x1)) in lift-pointed_{Maybe}(h1)
19:22:41 <lambdabot>  lift-pointed_{Maybe}(h1)
19:22:41 <lambdabot>  = {(_|_, _|_)}
19:22:43 <lambdabot>  u {(Nothing , Nothing )}
19:22:45 <lambdabot>  u {(Just x1, Just y1) | h1 x1 = y1}
19:22:46 <SamB_XP> @help ft
19:22:48 <sorear> ?google Theorums for free
19:22:49 <lambdabot> ft <ident>. Generate theorems for free
19:22:51 <lambdabot> http://ic.arc.nasa.gov/people/dhw/papers/78.pdf
19:23:02 <sorear> ?google Theorems for free
19:23:06 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps
19:26:02 <sorear> ^^^ jcreigh: helpful
19:28:22 <jcreigh> sorear: Thanks for the link.
19:32:36 <jcreigh> @free reverse
19:32:38 <lambdabot> $map f . reverse = reverse . $map f
19:33:10 <Stinger_> hmm lazy programming on digg
19:33:51 <Stinger_> all scheme though
19:34:13 <jcreigh> @free head
19:34:14 <lambdabot> f . head = head . $map f
19:37:28 <glguy> Stinger_: I don't know why people bother with a "programming" section on digg
19:38:07 <Stinger_> occasionally they have interesting/useful links:)
19:38:33 <Stinger_> well, very occasionally
19:38:45 <emu> Stinger_: is it that ibm article
19:38:51 <Stinger_> yeah
19:38:54 <glguy> Posting any article there is like presenting a research article to kindergardeners
19:39:03 <emu> that was posted on reddit yesterday i think
19:39:05 <glguy> and then given them a wall to write on with finger paints
19:39:19 <Stinger_> yeah some of the comments are pretty funny
19:40:03 <Stinger_> http://digg.com/programming/Lazy_Programming#c4361657 I found that one ammusing
19:40:03 <lambdabot> Title: digg - Lazy Programming
19:40:13 <Stinger_> -m
19:40:25 <SamB_XP> glguy: heh
19:40:52 <SamB_XP> except maybe the kindergartners would produce nice looking pictures
19:40:59 <sorear> The difference between comment sites and IRC is that when you waste time on IRC you get the warm fuzzy fealing of helping newbies.
19:41:26 <sorear> s/feeling/ s/the warm/that warm/
19:41:34 <glguy> but also, instead of being exposed to total ignorance
19:41:41 <glguy> you are exposed to people smarter than you
19:42:02 <fridim> What a big deal
19:42:05 <SamB_XP> who are the people smarter than you? the newbies or the oldbies?
19:42:09 <glguy> heh
19:42:27 <SamB_XP> maybe yourself on alternate tuesdays?
19:43:46 <sorear> IRC. 1. (n) The name of the alternate world where the ordering of intelligence is non-antisymmetric and non-transitive.
19:43:57 <lispy> yeah, i like the feeling i get when i'm able to help someone via irc
19:44:35 <lispy> it often helps me to hear more knowing folks interact with newbies too
19:44:40 <lispy> i've picked up a lot that way
19:44:41 <SamB_XP> non-antisymmetric?
19:44:48 <lispy> symmetric?
19:44:50 <SamB_XP> so it is potentially symmetrical?
19:45:12 <SamB_XP> i.e. I am smarter than you *and* you are smarter than me?
19:45:37 <sorear> that's what I meant
19:45:50 <SamB_XP> how nice of you to say so ;-)
19:46:14 <lispy> heh
19:46:17 <emu> i am dumber than me
19:46:50 <lispy> is that like taking the factorial of a negative number?
19:46:56 <lispy> it just spirals on out of control?
19:46:59 <SamB_XP> but most importantly: not everyone is dumber than me ;-)
19:47:17 <SamB_XP> lispy: you are silly
19:47:18 <lispy> > (-1)!
19:47:18 <lambdabot>  Parse error
19:47:27 <SamB_XP> that is not really how you take factorials of negative numbers
19:47:36 <SamB_XP> you should look at TAOCP sometime
19:47:40 <lispy> you use zeta?
19:47:45 <sorear> gamma
19:47:47 <lispy> or whatever it's called
19:47:48 <lispy> ah gamma
19:47:49 <SamB_XP> whatever!
19:48:01 <glguy> alpha or beta maybe?
19:48:01 <lispy> i have TAoCP 1-3
19:48:02 <emu> gamma is the lorentz functoin!
19:48:09 <lispy> but i haven't read much from them
19:48:22 <lispy> i always wanted to implement all the algorithms as i read it, in haskell
19:48:27 <lispy> just to have it around
19:48:35 <emu> i should get okasakis book
19:49:05 <lispy> i should get going
19:49:08 <lispy> bbl
19:58:05 <hyrax42> isn't most of his book available as his thesis?
20:00:39 <dons> ?yow
20:00:39 <lambdabot> DON'T go!!  I'm not HOWARD COSELL!!  I know POLISH JOKES ... WAIT!!
20:00:39 <lambdabot> Don't go!!  I AM Howard Cosell! ... And I DON'T know Polish jokes!!
20:00:45 <dons> ?users
20:00:45 <lambdabot> Maximum users seen in #haskell: 309, currently: 261 (84.5%), active: 28 (10.7%)
20:00:59 <dons> ?uptime
20:00:59 <lambdabot> uptime: 3h 21m 14s, longest uptime: 9d 2h 23m 6s
20:01:06 <dons> 3 hrs eh?
20:01:07 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:03:42 <allbery_b> possibly restarted when freenode did
20:04:05 <emu> lambdabot made a "statement" about some parameter being tweaked
20:04:13 <sorear> yeah :)
20:04:18 <glguy> sorear: made a statement
20:04:49 <glguy> that parameter change allowing sorear to make the statement
20:04:49 <sorear> I admit it...
20:19:21 <chessguy> hi haskellers
20:30:58 <glguy> ndm
20:31:00 <glguy> ?seen ndm
20:31:01 <lambdabot> I saw ndm leaving #haskell-blah and #haskell 43m 33s ago, and .
20:31:15 <sorear> ?seen
20:31:15 <lambdabot> Lately, I have seen glguy and sorear.
20:35:17 <geckosenator>  
20:44:12 <mgsloan> :t recip
20:44:14 <lambdabot> forall a. (Fractional a) => a -> a
20:44:33 <mgsloan> >recip 0
20:44:37 <mgsloan> > recip 0
20:44:38 <lambdabot>  Infinity
20:45:08 <mgsloan> > 0 * (recip 0)
20:45:09 <lambdabot>  0.0
21:10:00 * bos hasn't written a line of haskell code since about 1995. everything's the same, but everything's changed!
21:10:46 <jcreigh> For instance, it's now 2006. So the date/time actions are returning different values. :)
21:11:18 <bos> the last time i wrote any haskell, we still had stream-based IO, bind notation for monads, and nobody had invented arrows yet.
21:11:30 <bos> my brain hurts.
21:12:44 <bos> it seems like every time i try to get a grip on the current state of things, i find that another chunk of category theory has invaded the landscape, and i'm even further behind.
21:13:26 <bos> does anyone have any good suggestions for coming back up to speed? it's almost like being a newbie again.
21:13:59 <mgsloan> does anyone actually use arrows?
21:14:05 <glguy> '95? that was half a lifetime ago :)
21:14:29 <jcreigh> more than half, in some cases.
21:14:39 <mgsloan> yeah, more than half mine
21:14:39 <glguy> bos: people seem to recommend YAHT and Gentle Introduction to Haskell
21:14:45 <glguy> ?where yaht
21:14:46 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:15:04 <bos> well, every time i look at stuff like the haskell xml toolbox, i see things that look remarkably like arrows.
21:15:14 <bos> glguy: thanks
21:15:47 <glguy> mgsloan: arrows seem quite useful in HXT
21:16:06 <mgsloan> ah, sweet.  I suppose I should learn them then
21:16:14 <bos> i still have bits of code sitting in ghc that date back to 1993 :-)
21:17:19 <bos> wow, yaht is huge, and the writing style is chatty. that's a good start!
21:17:33 <jcreigh> stream-based IO? Is that something like main :: [Response] -> [Request]
21:17:49 <glguy> bos: and I bet #haskell wasn't as big as it is now.. we're all pretty good about helping
21:18:00 <bos> glguy: there wasn't a #haskell then :-)
21:18:08 <glguy> > "we have " ++ "lambdabot now"
21:18:09 <lambdabot>  "we have lambdabot now"
21:18:12 <bos> jcreigh: yeah
21:18:29 <jcreigh> bos: that seems strange and awkward. Was it?
21:18:35 <bos> it was awful.
21:19:14 <bos> everybody used continuation passing, so if you had to package up a new piece of state and thread it through your continuations, you had to refactor the entire skein of continuations.
21:20:04 <bos> monads with bind notation were weird, but more scary because nobody had written tutorials for people less smart than phil wadler yet :-)
21:20:47 <glguy> What brings you back?
21:21:05 <bos> boredom at work.
21:21:24 <bos> also, simonpj's papers on software transactional memory.
21:21:56 <glguy> I'm glad that I didn't learn about Haskell until it had become what it is today
21:22:04 <glguy> or at the end of last year for that matter ;)
21:22:14 <glguy> I might not have stuck with and loved it so much
21:22:19 * jcreigh wonders what they'll be saying 10 years hence
21:22:27 <mgsloan> literate coding gone wrong - http://www.haskell.org/arrows/examples/ExprParser.las
21:22:32 <glguy> "remember when we had to use Monads??"
21:22:45 <mbishop> jcreigh: "That jcreigh, he sure was ahead of his time"
21:22:50 <jcreigh> mbishop: lol
21:23:04 <glguy> mgsloan: not enough comments for you?
21:23:30 <mgsloan> well, it should just be a normal haskell file, with those comments actual comments
21:23:40 <glguy> yeah, I noticed :)
21:23:42 <bos> oh, the other reason i came back is that i wanted to write a functional polygon triangulator.
21:23:54 <glguy> I'd be nice if the editor didn't show the '>'s at all
21:24:02 <bos> the canonical algorithm is imperative, and i thought it would be a fun diversion.
21:24:02 <mgsloan> though particularly with something as crazy as arrows, literate style would be nice
21:24:03 <glguy> but instead used block to set the code apart
21:24:09 <glguy> and saved the'>' into the file silently
21:24:15 <mgsloan> ah yeah
21:24:49 <glguy> bos: Haskell now has the finest first-class imperative programing support you'll find
21:25:31 <bos> glguy: i've seen some of dons's "scripting" in haskell, and it looks fabulous.
21:28:13 * SamB_XP has been saying that for a while now ;-)
21:28:38 <SamB_XP> actually, I've been saying that Haskell has the only first-class support for imperative programming I have ever seen in a real language
21:29:00 <glguy> anyone know about Cream (the modified Vim)
21:29:04 <jcreigh> "real language"? As opposed to what, BF? :)
21:29:19 <SamB_XP> as opposed to some toy like Omega
21:29:34 <glguy> SamB_XP: I prefer not to point out that it's the only one really ;)
21:29:36 <jcreigh> Omega is greek to me.
21:29:50 <SamB_XP> I'm not saying Omega has it
21:29:51 <glguy> I focus on finest q-:
21:30:13 <SamB_XP> glguy: that is also true, though, and more likely to remain so ;-)
21:30:32 <glguy> http://cream.sourceforge.net/home.html -- example of bad navigation design
21:30:34 <lambdabot> Title: Cream :: a modern configuration of the Vim text editor
21:30:46 <glguy> try clicking the dark yellow box on the right
21:31:17 <base_16> glguy: yeah, that page is hard to use :(
21:34:36 <allbery_b> if that's any indication of how the editor behaves, I think I'll stick with emacs :)
21:34:54 <glguy> heh
21:34:55 <base_16> allbery_b: don't let cream spoil your view of vim :)
21:35:04 * base_16 still can't figure out how to use emacs
21:35:05 <glguy> I haven't quite figured out how the editor behaves
21:35:12 <base_16> vim is super easy :D
21:35:24 <johnnowak>  /me finds the cream site super-easy
21:35:25 <Stinger_> base_16 type stuff into the window :)
21:35:51 <base_16> Stinger_: yeah, but a lot of the things i want are M-x commands i don't know the bindings for
21:36:05 * allbery_b uses vim (but prefers BSD nvi) and emacs (but prefers xemacs).  both on a daily basis.
21:36:28 <base_16> allbery_b: why do you prefer xemacs over emacs?
21:36:35 <Stinger_> base_16 just remember this C-h w
21:37:18 <allbery_b> familiarity, mostly --- xemacs diverged some time ago, some things have different keybindings or different behaviors between the two
21:37:25 <base_16> Stinger_: Where is command: search-replace [No match]
21:37:37 <allbery_b> (likewise nvi vs. vim)
21:37:43 <allbery_b> M-x query-replace
21:37:55 <SamB_XP> base_16: doesn't it usually say the bindings when you type the "M-x" command?
21:37:57 <Stinger_> or M-%
21:38:01 <glguy> nvi is intended to be backwards compatible to vi though, right?
21:38:04 <allbery_b> which isn't bound to a key; the bound one is query-replace-regexp on M-%
21:38:15 <allbery_b> yes, with extensions
21:38:20 <base_16> SamB: but you have to know what emacs calls the command in the first place :(
21:38:26 <SamB_XP> base_16: yeah.
21:38:28 <Stinger_> no regexp is C-M-%
21:38:30 <SamB_XP> thats the hard part
21:38:37 <SamB_XP> M-x apropos helps though
21:38:46 <allbery_b> but the extensions behave a bit differently (only takes one ^W to switch "windows", for example)
21:38:51 <base_16> SamB: though i suppose having to know the names is true for all editors, i'm just not used to emacs
21:39:02 <allbery_b> meh
21:39:05 <base_16> though everywhere i've worked has had more emacs than vi users :(
21:39:10 <Stinger_> learn all the help shortcuts first
21:39:19 <SamB_XP> I'm used to it and often can't remember the name of something
21:39:21 <Stinger_> then you should be able to pick up the rest in time
21:39:22 * allbery_b doesn't recall now, he should probably be in bed except his body isn't playing along :(
21:39:43 <SamB_XP> usually it *is* something I have rarely wanted, though...
21:39:59 <Stinger_> I should learn vim though at some point
21:40:18 <glguy> I'd say that I've learned Vi more than I've learned ViM
21:40:19 <base_16> Stinger_: it doesn't take much time, you just have to learn some command forms
21:40:22 <allbery_b> emacs does take some getting used to.  I've been using it since the mid-80s so it's second nature now
21:40:25 <base_16> find yourself a good quick reference
21:40:42 <base_16> i used emacs exclusively for 4 months to try to learn, but it didn't burn itself into my brain enough
21:42:05 <SamB_XP> I've only been alive since the mid-80s
21:42:51 <base_16> yeah, 83 here
21:42:55 <glguy> 84
21:43:04 <glguy> ?vixen a/s/l
21:43:04 <lambdabot> 19/f/California
21:43:16 * SamB_XP was born in 86
21:43:32 <bos> editing haskell in emacs is lovely.
21:43:33 <allbery_b> <-- ancient.  and sometimes (like right now) feels that way
21:43:36 <SamB_XP> @vixen you have it wrong
21:43:37 <lambdabot> my keyboard doesn't have an
21:43:38 <allbery_b> (64)
21:43:45 <allbery_b> year, not age :>
21:43:50 <sorear> <--- '90
21:43:50 <glguy> lol
21:43:51 <base_16> haha :)
21:43:53 <SamB_XP> allbery_b: oh good
21:44:19 <SamB_XP> hmm...
21:44:24 <Stinger_> 42 eh
21:44:25 <SamB_XP> > 2006 - 1964
21:44:26 <lambdabot>  42
21:44:30 * SamB_XP slow
21:44:33 <allbery_b> far as the internet's concerned, that's "older than dirt"
21:44:50 <SamB_XP> hmm, my dad has had enough 39th birthdays to be older than that by now
21:45:05 <base_16> allbery_b: that's not so bad-- that'd be less than the median age at my last job
21:45:06 <Stinger_> so you've discovered the meaning of life, the universe and everything now
21:45:18 <allbery_b> as if...
21:45:21 <SamB_XP> and he is a programmer
21:45:30 <SamB_XP> though currently not employed as such
21:45:42 * SamB_XP thinks it might help if he would finally finish that college degree
21:45:53 <sjanssen> SamB_XP: is your father in denial
21:45:56 <SamB_XP> he is like one class short of a degree! how wierd is that
21:45:57 * bos was born in:
21:46:01 <bos> > foldr (*) 1 [2,3,7,47]
21:46:02 <allbery_b> well, I did manage to teach my mom to be a decent sysadmin when she was in her 50s
21:46:03 <lambdabot>  1974
21:46:05 <SamB_XP> sjanssen: denial of what?
21:46:06 <base_16> college degrees are overrated
21:46:31 <SamB_XP> hmm.
21:46:33 <reppie> base_16 you aren't in college?
21:46:39 <reppie> (i agree, btw)
21:46:42 <base_16> reppie: i've finished college
21:46:48 <jcreigh> hmm, I didn't realize my year of birth was prime until now...
21:46:49 <SamB_XP> overrated by who?
21:46:54 <reppie> base_16 do you have a job?
21:46:56 <base_16> but i know people gainfully employed at well-respected companies
21:47:01 <base_16> who don't have college degrees
21:47:03 <base_16> reppie: yes
21:47:04 <reppie> base_16 indeed
21:47:04 <bos> SamB_XP: people in college?
21:47:09 <SamB_XP> yeah, but, it couldn't hurt could it?
21:47:13 <base_16> i have a job at a pretty good company
21:47:22 <sjanssen> SamB_XP: of his age, "my dad has had enough 39th birthdays"
21:47:22 <reppie> base_16 what do you do?
21:47:37 <SamB_XP> sjanssen: not really
21:47:38 <base_16> reppie: stuff i can't talk about :)
21:47:42 <SamB_XP> I think it was just a confusion tactic
21:47:57 <SamB_XP> also a joke
21:47:58 <reppie> base_16 oh wait.. justin! (/whois reppie)
21:48:07 <reppie> lol.
21:48:16 <base_16> haha, awesome
21:48:29 <base_16> reppie: that's hilarious
21:48:37 <reppie> srsly
21:49:29 * Shimei is of the opinion that using employment to evaluate degrees is attaching the wrong meaning to a degree
21:49:43 <Shimei> But I'm not yet in college, so I can't say much. :p
21:50:02 <base_16> reppie: are you still at work?
21:50:03 <SamB_XP> probably it would help more if he would learn DB2
21:50:07 <reppie> base_16 no
21:50:12 * mgsloan was born in
21:50:19 <SamB_XP> I wonder how you learn DB2 without working at a company that has a license?
21:51:02 <mgsloan> > foldr1 (*) [2, 5, 199]
21:51:03 <lambdabot>  1990
21:51:20 <glguy> product q-:
21:51:38 <SamB_XP> foldr is funner
21:51:48 <glguy> sticking your tongue out is too
21:52:00 <SamB_XP> why are you standing on your head anyway?
21:52:06 <allbery_b> once upon a time it was available from IBM Developer Connection for a smallish (for IBM) annual fee.  and IIRC in the 90s they had demo installs available for windows, OS/2, and briefly linux
21:52:14 <jcreigh> actually, the easiest way is just:
21:52:17 <jcreigh> > 1987
21:52:19 <lambdabot>  1987
21:52:26 <glguy> SamB_XP: it breaks most automatic convertions to icons
21:53:00 <SamB_XP> glguy: well it also breaks my automatic conversion! which is where I tilt my head to the side!
21:53:12 <base_16> SamB_XP: i'm pretty sure there are versions of DB2 that have free trials... and there is a lot of documentation online
21:53:31 <glguy> SamB_XP: then you'll definitely take notice when I write them, because they'll draw your attention (o:
21:54:29 <mgsloan> > L.bday $ foldr1 (*) [2, 3, 3, 5]
21:54:30 <lambdabot>  1990
21:54:31 <SamB_XP> hmm, but no free trial for zOS?
21:55:23 <glguy> > L.oL
21:55:24 <base_16> SamB_XP: Why would you want a copy of z/OS anyway?
21:55:25 <lambdabot>  "hahaha"
21:56:16 <reppie> allbery_b you write haskell code in nvi?
21:56:33 <SamB_XP> well actually they called it something different, but anyway that is what my dad used to work with...
21:56:51 <SamB_XP> until the company that he worked for went nearly belly-up...
21:56:58 <allbery_b> (DevCon:  back when I was a member, $150/yr got you a thick bookllet of CDs every couple months with just about eveyrhing they had available --- compilers, databases, ...)
21:57:49 <allbery_b> reppie: xemacs usually; generally I do programming stuff in *emacs and sysadminny stuff in *vi*, but not always
21:58:29 <lispy> allbery_b: sounds familiar
21:58:34 <reppie> allbery_b oh ok.. i tried writing haskell stuff in nvi, but it's just too painful (i don't fully undrestand the indentation rules in haskell)
21:58:36 <glguy> I really enjoy Visual Haskell's type-on-hover feature, and red-underlines when I screw up
22:00:14 <lispy> glguy: yeah, but i wish you could get type information even when your file is syntactically bad
22:00:31 <glguy> yeah, me too )-:
22:00:32 <lispy> glguy: i end up inserting a lot of " = undefined" when i use VH
22:00:41 <lispy> but, even so, i like it
22:00:56 <glguy> I'll do a lot of this = () where (fill out helper functions)
22:07:22 <allbery_b> the layout rule isn't *that* difficult to work out (if it's all part of the same "thing" it needs to be at least the same indentation); generally for programming I :se sw=2 and use ^T / ^D to indent/outdent
22:07:44 <allbery_b> used to be you could defeat hard tabs with :se ht=0 but that doesn't seem to work in nvi at least
22:07:56 <mgsloan> so, i take it the SOE gtk/cairo implementation can't be done well until threading works
22:08:00 <glguy> :set expandtab?
22:08:05 <allbery_b> hm, no, I think that only affected display
22:08:15 <glguy> or is that vim
22:08:27 <LordBrain> the layout in python seemed less strict to me for some reason
22:08:30 <glguy> well, in vim it turns them into spaces
22:08:48 <allbery_b> that's vim, not nvi
22:08:52 <glguy> right
22:08:59 <glguy> I didn't know if that was from vi or not
22:09:03 <glguy> so I asked
22:09:03 <allbery_b> I don't recall how it was done in old vi, there was a trick of some kind
22:12:05 <glguy> allbery_b: well, the other solution is to just set tabstop=8, so that the tabs are interpreted correctly by a haskell compiler :)
22:13:41 <sorear> What makes some people think tabs *aren't* eight spaces?
22:13:58 * SamB_XP just asked IBM to mail him their SEK, whatever that is
22:14:16 <allbery_b> they have the habit of using tab to indent and think 8-space tabs are too big.
22:14:24 * sorear uses haskell and tabs all the time, and never had any trouble because he obeyed the standard.
22:14:26 <SamB_XP> they made me put in a company name! so I put "lonely hacker" ;-P
22:14:37 <allbery_b> in vi, using shiftwidth and ^T / ^D is generally a better solution, and leave tabstop at 8
22:14:47 <glguy> not "SamB Enterprises"?
22:15:17 <SamB_XP> hey while I'm falsifying information just to get past the red star of death, I don't feel like thinking so hard
22:15:26 <SamB_XP> and it seemed a good pun
22:15:34 <SamB_XP> or a bad pun
22:15:40 <SamB_XP> depending on how you look at these things
22:17:55 <glguy> Ew... in Cream, pressing Esc TOGGLES command and insert mode
22:18:19 <base_16> glguy: yikes
22:18:25 <allbery_b> just as long as they still support :se smd...
22:18:32 <glguy> Priority One, fix that :)
22:26:21 <reppie> is yi still alive?
22:28:28 <glguy> Why would this work: f arr = runSTArray (thaw arr)
22:28:34 <glguy> while this doesnt:
22:28:44 <glguy> f arr = runSTArray aux where aux = thaw arr
22:29:12 <bd_> glguy: some weird monomorphism restriction thing?
22:29:24 <bd_> if you give aux a type signature does it work?
22:29:45 <glguy> yes
22:29:58 <bd_> :t thaw
22:29:59 <lambdabot> Not in scope: `thaw'
22:30:06 <bd_> @hoogle thaw
22:30:06 <lambdabot> Data.Array.MArray.thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
22:30:06 <lambdabot> Data.Array.MArray.unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
22:30:09 <glguy> :t Data.Array.ST.thaw
22:30:10 <lambdabot> forall e i (b :: * -> * -> *) (m :: * -> *) (a :: * -> * -> *). (Data.Array.Base.MArray b e m, Data.Array.Base.IArray a e, Ix i) => a i e -> m (b i e)
22:31:04 <glguy> this was the error
22:31:05 <glguy> ERROR - Inferred type is not general enough
22:31:05 <glguy> *** Expression    : x
22:31:05 <glguy> *** Expected type : ST a (STArray a _32 _33)
22:31:05 <glguy> *** Inferred type : ST _34 (STArray _34 _32 _33)
22:32:02 <glguy> but an explicit type sig fixes it... so
22:33:39 <bd_> hmm, I guess the compiler is assuming aux has one specific state type, whereas ST requires that it be generalizable
22:33:56 <bd_> and the type signature forces it to be polymorphic
22:34:14 <allbery_b> sounds like monomorphism restriction to me
22:34:15 <glguy> how to I write the type sig though... I need: ST s (STArray s Int a)
22:34:28 <thelsdj> does haskell have anything like this? http://pyconstruct.wikispaces.com/
22:34:38 <bd_> glguy: hmm
22:34:53 <bd_> glguy: I wonder, are type variables bound in the signature of the parent available in the signatures of the where clause?
22:35:04 <glguy> don't think so
22:35:12 <bd_> hmm
22:35:27 <bd_> you could make it aux = thaw, and write it as a function signature
22:35:44 <glguy> hugs doesn't support bypassing the monomorphism restriction?
22:35:59 <bd_> dunno, I don't use hugs much :/
22:36:13 <glguy> I use both, but it's easier to open files in hugs :)
22:36:17 <bd_> heh
22:37:30 <glguy> ghc says: Inferred type is less polymorphic than expected Quantified type variable `s' is mentioned in the environment:
22:37:31 <glguy> without the explicit sig
22:38:01 * allbery_b started out with hugsbuthas moved to using ghci exclusively for that kind of thing
22:38:21 <allbery_b> how about with -fno-monomorphism-restriction?
22:38:36 <glguy> didn't help
22:38:38 <bd_> hmm
22:38:50 <bd_> thaw :: exists a. ST s (STArray s Int a) ?
22:38:58 <bd_> not sure if that actually works
22:39:00 <allbery_b> hm.  so, some other kind of type unification issue
22:39:05 <bd_> but I think I've seen something like that
22:39:31 <bd_> er
22:39:35 <bd_> aux :: >.>
22:41:46 <glguy> parse error on . :)
22:42:06 <reppie> i'm not too happy that several appendixes in "computer architecture: a quantitative approach" fourth edition are on a CD, instead of in the actual physical book.
22:42:47 <bd_> hmm, apparently it's only good in data definitions :/
22:42:52 <glguy> bd_: I think that forall and exists only occur in data definitions
22:43:02 <sorear> what format? time limited DRM?...
22:43:18 <base_16> reppie: in the 3rd edition, they just give URLs :(
22:43:34 <sorear> exists only works in data defns, yes.
22:43:51 <sorear> note, however, that exists is never neccessary.
22:44:00 <glguy> and can be written with forall
22:44:02 <glguy> on the odd positions
22:44:04 <reppie> sorear don't know. i haven't tried to look at the cd yet.
22:44:05 <reppie> base_16 :(
22:44:06 <sorear> (exists q. a -> b)  <==> forall q. (a -> b)
22:44:16 <sorear> (exists q. a) -> b  <==> forall q. (a -> b)
22:44:44 <sorear> exists q. a <==> (forall q. a -> b) -> b
22:45:17 <sorear> interestingly, the same procedures can be used to lift forall's by one rank while turning them into existentials.
22:45:19 <base_16> wtf
22:45:28 <base_16> the appendix data doesn't even appear to be online anymore
22:45:28 <bd_> sorear: wouldn't the latter be possibly converting from a function to a non-function? I'm probably misunderstanding something though...
22:46:00 <base_16> oh n/m
22:46:04 <sorear> it couldn't be used in the same way, but it would hold the same set of values
22:46:35 <reppie> base_16 do you need a password to look at the online stuff?
22:46:45 <sorear> you can use both techniques to lift foralls by any even number of ranks - thus rank-2 is the most you'll ever need.
22:46:53 <base_16> reppie: nope
22:46:56 <reppie> base_16 url? :)
22:48:27 <dons> oh nice, I see we beat 1M lines of text in channel, this year :)
22:48:32 <dons> ?where stats
22:48:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
22:48:52 <glguy> dons: I was trying ;)
22:49:09 * reppie wonders what happened to xerox
22:49:11 <sorear> yay!
22:49:16 <glguy> xerox is edi
22:49:20 <reppie> edi?
22:49:25 <glguy> ?seen edi
22:49:26 <lambdabot> edi is in #haskell-overflow. I don't know when edi last spoke.
22:49:29 <reppie> oh.
22:49:51 <glguy> not e.d.i. :)
22:49:53 <reppie> he doesn't hang out here anymore?
22:51:27 <glguy> *someone* rebooted lambdabot recently, so lambdabot just hasn't seen edi since then
22:51:30 <glguy> ?uptime
22:51:31 <lambdabot> uptime: 6h 11m 44s, longest uptime: 9d 2h 23m 6s
22:51:52 <bd_> perhaps lambdabot should save its seen-state?
22:52:03 <sorear> <nervously> I didn't do it!
22:52:38 <sorear> good idea - I'll look into that...
22:52:50 <glguy> bd_: solved it
22:52:57 <bd_> glguy: what was the trick? :
22:52:59 <bd_> :)*
22:53:26 <lisppaste2> glguy pasted "pass in the array as an argument instead of using the environment" at http://paste.lisp.org/display/33196
22:54:10 <glguy> otherwise I have to wrap the whole do block in (  )
22:54:18 <glguy> and I don't like doing that
22:54:47 <bd_> that works I guess
22:55:00 <bd_> but I still wonder if there's a way to get that signature working...
22:55:50 <glguy> dons: how good is your existential-type foo?
22:55:56 <reppie> base_16 the appendixes seem more interesting than the actual chapters, to me :P
22:56:41 <base_16> reppie: well, it depends on what you're looking for :)
22:56:49 <glguy> link?
22:56:50 <glguy> :)
22:58:04 <base_16> http://tinyurl.com/yfhcxn
22:59:25 <base_16> reppie: there are a few gems in the normal chapters
22:59:39 <base_16> the alpha 21264 memory hierarchy one is good
23:00:23 <reppie> base_16 i think it talks about the memory hierarchy on the opteron, in the 4th edition
23:00:34 <base_16> argh
23:01:49 <reppie> but i suspect they aren't *that* different
23:01:54 <wy> I wonder how is the instances in Ord is defined because there are many long and repeated tuples
23:02:21 <glguy> ?pl \arr -> thaw arr >>= qs arr >> return arr
23:02:22 <lambdabot> ap ((>>) . liftM2 (>>=) thaw qs) return
23:02:48 <glguy> wy: ?
23:04:44 <wy> glguy: I see there is instance (Ord a, ..., Ord k) => Ord (a, b, c, d, e, f, g, h, i, j, k) etc
23:05:09 <base_16> reppie: yeah, i can bring in my 3rd ed. copy. sadly, i don't know much at all about x86*
23:05:09 <glguy> and what did you wonder?
23:05:48 <wy> glguy: And there is instance (Ord a, ..., Ord j) => Ord (a, b, c, d, e, f, g, h, i, j)...
23:05:57 <wy> They are so similar
23:06:16 <glguy> yeah, each tuple of different length is a different data type
23:06:32 <glguy> GHC takes them out to about 15 i think
23:06:37 <wy> The only difference is in the length. Why writing them?
23:06:40 <glguy> > take 15 ['a'..]
23:06:41 <lambdabot>  "abcdefghijklmno"
23:07:00 <glguy> wy: because (1,2,3) is a totally different type than (1,2)
23:07:21 <wy> glguy: But writing all these out is tedious
23:07:31 <glguy> that's why they are written out for you
23:07:45 <sorear> It is disgusting.
23:07:59 <wy> glguy: I guess there should be another level of abstraction?
23:08:16 <sorear> Haskell's kind system is not powerful enough to abstract over tuple sizes.
23:09:36 <sorear> Data.Generics can come pretty close, but (a) it doesn't support "give me an implementation of Ord for this type", (b) it is runtime typed and gives runtime errors, and (c) is still requires boilerplate defn's for Typeable and Data.
23:09:44 <bd_> Really, (1,2,3) should be the same as (1,(2,3))
23:10:22 <wy> So any extensions? Sometimes I found it limited. When I wrote pThen4 in the parser of Peyton Jones's book, later I found I will need pThen5, and pThen6...
23:10:36 <sieni> well, they aren't the same, because of bottom ^_^
23:10:42 <sorear> I think lightweight inductive tuples would make a good language edition.
23:10:48 <sorear> s/edition/addition/
23:11:09 <sorear> data TNull = TNull ; data TCons a b = TCons a b
23:11:30 <bd_> I think someone proposed something like that for Haskell'
23:11:40 <bd_> with b being strict, so the compiler can pack them more efficiently
23:12:20 <bd_> dunno what happened with that, I haven't been following haskell' very much
23:12:30 <sorear> instance Ord TNull where compare _ _ = EQ ; instance (Ord a, Ord b) => Ord (Tuple a b) where compare (TCons a b) (TCons c d) = case compare a c of { EQ -> compare b d ; _ -> compare a c }
23:12:53 <sorear> Oh, I just defined all the Ord instances up to oo.  In haskell 98.  Just not h98 tuples.
23:13:34 <sorear> I know something like this, but much more powerful and extension-hungry, is one of Oleg's pet projects.
23:13:46 <sorear> HList iirc.
23:14:16 <mgsloan> bah, module Main will only export main?
23:14:30 <glguy> module Main where  -- exports everything
23:14:31 <wy> btw: what does IIRC mean. I've seen it many times
23:14:36 <glguy> if i remember correct
23:14:37 <glguy> ly
23:14:41 <sorear> If I Recall Correctlyu
23:14:51 <sorear> ^H
23:15:18 <wy> Oh, I thought it's something related with irc channels...
23:16:47 <sorear> ?go iirc afaik
23:16:48 <lambdabot> http://www.geocities.com/SouthBeach/Lagoon/9819/acronyms.html
23:16:48 <lambdabot> Title: Acronyms Explained. BTW, IIRC, AFAIK, etc.....
23:16:54 <wy> sorear: Can metaprogramming solve this problem?
23:17:48 <sorear> Sure, metaprogramming can solve this problem.
23:18:04 <shoffsta> is it possible to find all functions defined in a module in template-haskell?
23:18:26 <sorear> define(`genEm',`do_something_that_i_don't_remember_because_I_havent_used_M4_in_years')
23:18:27 <shoffsta> perhaps something like: moduleFuncts :: String -> [Name] ?
23:18:50 <sorear> But haskell has mostly abandoned the separate preprocessor.
23:18:52 <wy> sorear: Oh, don't mention M4
23:20:01 <wy> sorear: So how do they metaprogramming?
23:20:14 <glguy> the life of the wife is ended by the knife
23:26:13 <wy> what do you mean?
23:27:02 <glguy> It's from Family Guy
23:30:45 <sorear> How Haskell is amazing, part I've lost count: I just spent two days refactoring the IRC code out of the lambdabot core, leaving the code untestable the whole time.  I got it to compile in two hours, and it is doing approximately the right thing.
23:31:06 <glguy> whats your goal?
23:31:17 <glguy> make an irc lib?
23:31:46 <sorear> not exactly - I
23:32:26 <sorear> 'm trying to make IRC into just another plugin, alongside a readline plugin and other protocols
23:32:38 <glguy> ah
23:32:48 <hyrax42> a noble cause :)
23:32:54 <wy> I see another: instance (Show a, ... Show o) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
23:33:19 <sorear> Currently the readline plugin is the only one working - I started the refactor by ripping out all IRC support from lambdabot.
23:33:35 <sorear> Needless to say, that was a sizable chunk of the core...
23:36:45 <sorear>  @list
23:36:54 <sorear>  Unknown command, try @list
23:44:43 <glguy> Is there any decent way to write an algorithm in the ST monad that uses random numbers
23:44:49 <glguy> without passing in a RandomGen?
23:46:09 <sorear> what do you mean?
23:46:28 <ski> @type Random.mkStdGen
23:46:29 <lambdabot> Int -> StdGen
23:46:35 <sorear> certainly you could store the random state in a STVar
23:46:41 <ski> could be used, i guess
23:46:50 <glguy> right, but always picking an arbitrary Int doesn't seem likea good idea
23:46:58 <ski> (s/Var/Ref/)
23:47:00 <glguy> I guess I could base the seed off the input to the algorithm (quicksort)
23:47:49 <sorear> so.. you want to run a pure computation (which uses ST), without varying the input, and have it give (random) different results?
23:48:15 <glguy> well, it will give the same results once you get out of the ST :)
23:49:18 <sorear> Ah! this is the One True Use Case for unsafePerformIO.
23:49:40 <sorear> uPIO was created for times like this, and it will serve you well.
23:50:30 <glguy> ?index unsafePerformIO
23:50:31 <lambdabot> System.IO.Unsafe, Foreign
23:51:04 <sorear> :t unsafePerformIO
23:51:06 <lambdabot> Not in scope: `unsafePerformIO'
23:51:15 <sorear> :t System.IO.Unsafe.unsafePerformIO
23:51:16 <lambdabot> forall a. IO a -> a
23:51:34 <xpika> what we all need. :)
23:53:15 <sorear> beware, for uPIO is a belligerent beast, and will not hesitate to bite your hand if misused...
23:53:36 <glguy> yeah, I'm not even quite convinced that this is an acceptable use yet :)
23:54:19 <sorear> ooh, trying to fix Plugin/Karma.hs, noticed a special case:
23:54:23 <sorear> ?karma java
23:54:23 <lambdabot> java has a karma of -15
23:54:26 <sorear> ?karma lambdabot
23:54:26 <lambdabot> lambdabot has a karma of 39
23:54:35 <sorear> java++
23:54:37 <sorear> ?karma java
23:54:37 <lambdabot> java has a karma of -15
23:54:39 <sorear> ?karma lambdabot
23:54:39 <lambdabot> lambdabot has a karma of 39
23:54:50 <ski> @karma karma
23:54:50 <lambdabot> karma has a karma of 1
23:54:58 <xpika> ?karma /me
23:54:58 * lambdabot has a karma of 0
23:54:58 <glguy> sorear: dons put that in a while back :)
23:55:21 <xpika> @karma /me
23:55:21 * lambdabot has a karma of 0
23:56:20 <ski> @karma lambdabot
23:56:20 <lambdabot> lambdabot has a karma of 39
