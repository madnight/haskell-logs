00:00:08 <dons> pjd, there's some talk. it makes sense anyway (since that's the type of n+k patterns, k :: Nat)
00:00:23 <pjd> n+k patterns?
00:00:30 <dons> though who uses n+k patterns :)
00:00:39 <LordBrain> would the compiler be smart enough to optimize data Nat = Zero | Succ Nat to use GMP anyway?
00:00:48 <dons> f (n+1) = f n -- that style
00:00:55 <pjd> ah, ok
00:01:01 <dons> LordBrain: mm. you could write a rewrite rule for it...
00:01:09 <glguy> > let factorial 0 = 1; factorial (n+1) = (n+1) * factorial n in factorial 5
00:01:09 <lambdabot>  Parse error in pattern
00:01:13 <dons> so it would do the job yes, you just have to teach it
00:01:25 <glguy> does lambdabot not support n+k pattern?
00:01:28 <dons> glguy: not even lambdabot uses n+k :)
00:01:39 <LordBrain> man i cant wait to learn rewrite rules
00:01:39 <dons> gofer has n*c patterns
00:02:10 <glguy> I think they are neat in the smallest of cases, and make everything more difficult in the rest
00:02:10 <dons> talk about optimising for math text books ;)
00:02:52 <dons> n+k is a legitimate case where the syntax really got optimised for a math textbook-style yntax :)
00:03:01 <dons> and then no one uses it
00:06:28 <sorear> Vty currently has an interface where you create a state object and pass it around to functions that need to use it.  Would be preferable to make it use explicitly global state?  (Also, how well does hs-plugins interact with toplevel unsafePerformIO?)
00:06:37 <LordBrain> i wish there were other haskellers in my area... i get too enthused sometimes, and i start going on about it and it seems almost like even theoretical types dont relate and I begin to feel alienated from everyone... it's almost seems like in our society, we're not supposed to be emotionally affected by things like mathematics or computer science...
00:06:45 <glguy> dons: how about this ugly solution to chunk?
00:06:46 <glguy> > let ugly n xs = map (map snd) $ groupBy (swing (==) fst) $ sort $ zip (cycle [1..n]) xs; swing f g x y = g x `f` g y in ugly 3 [1..10]
00:06:48 <lambdabot>  [[1,4,7,10],[2,5,8],[3,6,9]]
00:08:22 <dons> mm. I think we might just scrape over the 1M lines of text mark, this year!
00:08:33 <dons> currently 990390 lines
00:08:38 <LordBrain> for what?
00:08:46 <dons> lines of text produced in #haskell :)
00:09:03 <dons> previous record was 726126. lines in a year
00:09:07 <sorear> dons: How do you feel about explicit global state vs. user creates and uses at most one state object
00:09:24 <dons> sorear: I'm more a fan of State(T) with a single record type these days
00:09:28 * sorear generates 10K lines of mindless drivel
00:09:33 <dons> I used to go the single mutable variable idea
00:09:41 <dons> but i like StateT better for that now
00:09:50 <glguy> > let ugly n xs = flip map [1..n] (\i -> [b | (a,b) <- zip (cycle [1..n]) xs, a == i]) in ugly 3 [1..10]
00:09:52 <lambdabot>  [[1,4,7,10],[2,5,8],[3,6,9]]
00:10:04 <dons> glguy: you get points for using 'swing' :)
00:10:09 <glguy> heh
00:11:22 <Syzygy-> dons: Is that chunk on your blog really correct?
00:11:26 <glguy> > transpose (tails [1,2,3,4,5])
00:11:27 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
00:11:34 <Syzygy-> The i and n seem to ... dunno ... work weirdish.
00:11:46 <glguy> I proposed the following inthe reddit comments:
00:11:46 <glguy> chunk n xs = map (take i) . takeWhile (not . null) . iterate (drop i) $ xs where i = (length xs - 1) `div` n + 1
00:11:52 <dons> Syzygy-: hmm. I think so, but i only checked it in ghci...
00:11:58 <dons> how hard could it be :)
00:12:15 <dons> Syzygy-: what's weird about it? it's breaking the list into 'n' pieces
00:12:15 <Syzygy-> If you want chunks of length n, why on earth would you take splitAts at length/n ?
00:12:24 <Syzygy-> Oh. That's not what you say it does.
00:12:25 <dons> so I need to work out the length i that gives me n :)
00:12:31 <dons> ah oops
00:12:35 <hyrax42> ?fptools Distribution.Simple
00:12:35 <lambdabot> http://darcs.haskell.org/packages/Cabal/Distribution/Simple.hs
00:12:55 <Syzygy-> Yeah, split it into n pieces reasonably equal in size, sure. Then I buy that code. :)
00:13:26 <dons> fixed....
00:13:31 <dons> yeah, the comment was wrong
00:13:34 <Syzygy-> :)
00:14:19 <hyrax42> ?hoogle system
00:14:19 <lambdabot> System.system :: String -> IO ExitCode
00:14:20 <lambdabot> System :: module
00:14:20 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
00:14:35 <kfish> my version did the same as dons' chunk', but splitAt n, and a transpose in front of the whole thing to re-order, not sure if that works lazily tho :-)
00:14:38 <hyrax42> ?docs System
00:14:39 <lambdabot> System not available
00:15:08 <hyrax42> ?index ssyte
00:15:09 <lambdabot> bzzt
00:15:11 <hyrax42> ?index system
00:15:11 <lambdabot> System.Cmd
00:15:49 <dons> does python have a hierarchical name space?
00:16:06 <dons> (for modules)
00:16:16 <Excedrin> nope
00:16:30 <glguy> dons: alternate approach
00:16:31 <glguy> > let chunk n = transpose . unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in chunk 3 [1..10]
00:16:33 <lambdabot>  [[1,4,7,10],[2,5,8],[3,6,9]]
00:16:46 <dons> oh, though I see:
00:16:48 <dons> import linkcheck.checker
00:16:48 <dons> import linkcheck.checker.cache
00:17:11 <dons> is that like linkchecker (Checker(.))
00:17:15 <dons> (..)
00:17:16 <glguy> chunks of n * n chunks -> all elements
00:17:38 <dons> oh, in the Maybe monad there?
00:17:50 <glguy> > let chunk n = transpose . map (take n) . takeWhile (not . null) . iterate (drop n) in chunk 3 [1..10]
00:17:52 <lambdabot>  [[1,4,7,10],[2,5,8],[3,6,9]]
00:20:08 <dons> 'It has a million nuances (like the English language) that somehow make expressing exactly what you want to say seem easier than other languages."
00:20:16 <dons> what language is that referring to?
00:20:18 <Excedrin> eh, I guess it does, but it's new in python 1.5
00:20:44 <pjd> dons: it has packages, which are hierarchical collections of modules
00:21:05 <pjd> Excedrin: Python 1.5 and "new" in the same sentence? :)
00:21:07 <dons> pjd ah ok. so you can import, say, 'system' and get everything in system.* ?
00:21:33 <Excedrin> just ignore me, I'll be over here drinking
00:21:34 <pjd> dons: nah, import system will just put "system" in the current namespace as a module object
00:21:46 <dons> oh, objects. right. that OO thing
00:21:50 <dons> :)
00:21:56 <LordBrain> haha
00:21:57 <pjd> you'd say "from system import foo", or "from system import *"
00:22:17 <pjd> or "from system.foo import bar", and so on
00:22:30 <dons> ah ok. good
00:22:51 <dons> (I'm rewriting a python program, and just trying to understand some of the things its doing :)
00:23:02 <LordBrain> what program?
00:23:34 <dons> 'linkchecker', a 600 line script (not mine) that I use to check valid hrefs in the HWN (And other html articles)
00:23:42 <dons> but its kinda slow, and does some nasty threading things
00:24:09 <dons> so I though rewriting it to be properly parallel would make a good ... blog article!
00:24:19 <dons> and I could actually use the result
00:24:55 <dons> good chance to play with STM too
00:25:07 <LordBrain> yeah
00:25:10 <sorear> import system <==> import qualified System
00:25:24 <sorear> from system import * <==> import System
00:25:45 <dons> can you paramaterise a module object with othre modules?
00:25:50 <dons> ml functor-style ? ;)
00:26:22 <LordBrain> i dont think so..
00:26:26 <pjd> well, you can frob namespaces freely
00:30:07 <goltrpoat> so.. the circular queue version:
00:30:08 <goltrpoat> > let chunks' n xs = foldr (\e b -> (tail b)++[e:(head b)]) (replicate n []) xs in chunks' 3 [1..10]
00:30:10 <lambdabot>  [[3,6,9],[2,5,8],[1,4,7,10]]
00:30:44 <sorear> ?rquote #haskell is a great code optimizer
00:30:45 <lambdabot> #haskell is a great code optimizer hasn't said anything memorable
00:30:58 <goltrpoat> sorry, lemme pretty that up a bit
00:30:58 <goltrpoat> hehe
00:30:59 <sorear> ^^^ - we need a *reverse* quote
00:31:07 <goltrpoat> > let chunks' n xs = foldr (\e b -> tail b ++ [e:head b]) (replicate n []) xs in chunks' 3 [1..10]
00:31:09 <lambdabot>  [[3,6,9],[2,5,8],[1,4,7,10]]
00:32:12 <dons> quotes should come numbered
00:32:28 <dons> #4 foo says: blah blah
00:32:33 <dons> then we could @unquote 4
00:32:37 <dons> :)
00:32:54 <dons>  or @unquote /java/
00:33:58 <goltrpoat> @pl \e b -> tail b ++ [e:head b]
00:34:01 <lambdabot> liftM2 (++) tail . flip flip [] . ((:) .) . (. head) . (:)
00:34:04 <goltrpoat> good lord.
00:34:28 <glguy> has anyone seen "Evolution ofa haskell programmer" on programming.reddit yet?
00:34:50 <glguy> (I didn't see it when searching
00:35:02 <glguy> so I submitted it, but will delete it if it's been posted already)
00:35:05 <LordBrain> i've seen it somewhere
00:35:13 <sorear> ?wiki Evolution of a haskell programmer
00:35:14 <lambdabot> http://www.haskell.org/haskellwiki/Evolution of a haskell programmer
00:35:14 <Excedrin> I've seen it in a comment
00:35:16 <dons> must have been up there before, surely?
00:35:21 <glguy> I know it's been around the internet
00:35:24 <glguy> but I couldn't find it on reddit
00:35:33 <sorear> It's under 'Humor' on the haskellwiki
00:35:40 <dons> yeah, maybe reddit hasn't seen it
00:35:54 <sorear> (I take it ?wiki just prepends the h-w URL?)
00:35:58 <glguy> oh well, I submitted it then, all the haskell articles up there, that one deserves its place in the sun ;)
00:36:27 <dons> sorear: yeah
00:38:16 <dons> heya bortzmeyer . seen the new #haskell.fr yet?
00:43:46 <LordBrain> goodnight
00:43:48 <dons> ?pl \x g n -> g (x*n))
00:43:48 <lambdabot> (line 1, column 18):
00:43:49 <lambdabot> unexpected ")"
00:43:49 <lambdabot> expecting variable, "(", operator or end of input
00:43:52 <LordBrain> almost 4am here
00:43:56 <dons> ?pl \x g n -> g (x*n)
00:43:56 <lambdabot> flip (.) . (*)
00:43:57 <LordBrain> heh
00:47:13 <bortzmeyer> dons: Oui, je l'ai vu mais il n'y a pas encore de trafic :-)
00:47:36 <dons> ?babel fr en Oui, je l'ai vu mais il n'y a pas encore de trafic
00:47:38 <lambdabot>  Yes, I saw it but there is no yet traffic
00:47:52 <dons> ?babel en fr ok :-)
00:47:54 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
00:47:57 <dons> heh
00:50:13 <bortzmeyer> ?babel en fr module failed: IRCRaised Prelude.head: empty list
00:50:15 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
00:53:53 <Masklinn> good morning everyone
00:55:28 <dons> morning Masklinn
00:55:43 <dons> Masklinn: I guess you've seen the new #haskell.fr channel?
00:55:57 <Masklinn> dons > No I haven't
00:56:28 <dons> ah well. the french haskell, he has a channel
00:56:43 <Masklinn> Damn, we've forked haskell?
00:56:57 <Masklinn> Are we going to translate the prelude to french?
00:56:59 <Masklinn> :D
00:57:16 <dons> and a new web page http://haskell.org/haskellwiki/Fr/Haskell
00:57:18 <lambdabot> Title: Fr/Haskell - HaskellWiki
00:57:22 <dons> hehe
00:57:54 <dons> (there's been multi language sub channels for a while now, but the .fr one has been strangely quiet)
00:58:23 <Masklinn> I'm not sure I'm really interested though, I can't help people much (yet?) and everything IT is pretty much english only to me
00:58:48 <sorear> ?users #haskell
00:58:49 <lambdabot> Maximum users seen in #haskell: 291, currently: 271 (93.1%), active: 32 (11.8%)
00:58:51 <sorear> ?users #haskell.se
00:58:51 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 0 (0.0%), active: 0 (NaN%)
00:59:00 <sorear> ?users #haskell.es
00:59:01 <lambdabot> Maximum users seen in #haskell.es: 14, currently: 0 (0.0%), active: 0 (NaN%)
00:59:01 <dons> sorear: you have to ask lambdbot2
00:59:08 <Excedrin> NaN%
00:59:13 <dons> since lambdabot2 runs those channels now
00:59:31 <Masklinn> Damn, lambdabot's spawned a child already?
00:59:56 <sorear> Wouldn't it be nice if... the lambdabots could share state and communicate?
01:00:19 <Masklinn> share state no, but communicate yes
01:00:25 <pejo> sorear, don't force dons to write another paper!
01:00:28 <pejo> :P
01:00:38 <sorear> (I support fn would notice if we had one LB and two connections?)
01:00:46 <sorear> s/support/suppose/
01:00:51 <goltrpoat> > let chunks'' n xs = elems $ accumArray (flip (:)) [] (1,n) (zip (cycle [1..n]) xs) in chunks'' 3 [1..10]
01:00:52 <pjd> sorear: as long as they do it in private, they can share whatever state they like
01:00:53 <lambdabot>  [[10,7,4,1],[8,5,2],[9,6,3]]
01:00:58 <goltrpoat> this is addictive.
01:02:00 <dons> they could sync stuff to each other via a darcs wire patch protocol
01:02:07 <dons> libdarcs, we'll call it
01:02:35 <dons> goltrpoat: accumArray, eh? i'd not have thunked it
01:03:04 <sorear> would it be easier/possible to modify lambdabot to open N connections?
01:03:43 <dons> yeah, I reckon. maybe not trivial, but not too hard
01:04:16 <hyrax42> ?hoogle (Floating a, Integral b) => a -> b
01:04:17 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:04:18 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
01:04:18 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
01:04:29 <hyrax42> ?type truncate
01:04:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:04:40 <hyrax42> ?instances RealFra
01:04:42 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
01:04:45 <hyrax42> ?instances RealFrac
01:04:46 <lambdabot> Double, Float
01:05:04 <hyrax42> > truncate $ 1/0 :: Int
01:05:05 <lambdabot>  -2147483648
01:05:17 <hyrax42> > truncate $ -1/0 :: Int
01:05:18 <lambdabot>  -2147483648
01:05:28 <hyrax42> truncate $ 1/0 :: Integer
01:05:33 <hyrax42> > truncate $ 1/0 :: Integer
01:05:34 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
01:06:08 <hyrax42> > fromIntegral $ (truncate $ 1/0 :: Integer) :: Double
01:06:09 <lambdabot>  Infinity
01:06:52 <hyrax42> > 3/2 :: Integer
01:06:53 <lambdabot>  add an instance declaration for (Fractional Integer)
01:06:53 <lambdabot>   In the expression:...
01:07:06 <hyrax42> > 3 `div` 2
01:07:07 <lambdabot>  1
01:07:15 <tibbe> @seen dons
01:07:15 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 3m 31s ago.
01:07:25 <hyrax42> > 1 `div 2`
01:07:25 <lambdabot>  Parse error
01:07:27 <tibbe> dons: ping
01:07:32 <hyrax42> > 1 `div` 2
01:07:32 <dons> yeah
01:07:33 <lambdabot>  0
01:08:02 <hyrax42> > length $ takeWhile (/=0) $ iterate (`div` 2) $ (truncate 1/0 :: Integer)
01:08:03 <lambdabot>  add an instance declaration for (Fractional Integer)
01:08:03 <lambdabot>   In the expression:...
01:08:12 <hyrax42> > length $ takeWhile (/=0) $ iterate (`div` 2) $ (truncate $ 1/0 :: Integer)
01:08:14 <lambdabot>  1025
01:08:27 <hyrax42> > 2^1025
01:08:28 <lambdabot>  3595386269724631815458610381578049467235953957884613145468601623154653516110...
01:08:36 <hyrax42> > 2^1024
01:08:37 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
01:08:55 <hyrax42> *sigh*
01:10:34 <notsmack> what's #haskell-overflow?
01:11:08 <earthy> that's for if discussions become too entangled here
01:11:37 <earthy> then we can take some to #haskell-overflow, so the discussion threads can be kept separate
01:11:51 <notsmack> earthy: ah, thanks
01:12:19 <dons> rather than use deeply nested parens :)
01:12:27 <goltrpoat> hmm
01:12:45 <goltrpoat> > let log2 x = (log $ fromInteger x) / log 2 in log2 (truncate $ 1 / 0 :: Integer)
01:12:46 <lambdabot>  Infinity
01:12:48 <goltrpoat> and yet..
01:12:57 <goltrpoat> the iterate (`div` 2) version gives 1025
01:13:56 <goltrpoat> ah
01:14:05 <notsmack> i guess there's no way to validate Text.XHtml?
01:14:32 <Smokey`> hmmm, what does it mean when I use ghci over a calculator :\
01:15:00 <goltrpoat> i catch myself doing that
01:17:07 <nomeata> Hi. I noticed that Data.Map’s lookup works in any monad. Why not lookup? And is there a function of the type  Monad m => (a -> Maybe b) -> a -> m b available, that would generalize any function in Maybe?
01:18:24 <pjd> dons: are the anchor link targets on your blog intentionally missing? :)
01:20:56 <Excedrin> it's interesting that sometimes @pl x, @unpl x', @pl x'', @unpl x''' takes a while to stabilize
01:22:51 <nomeata> @type let maybeToM Nothing = fail "Nothing"; maybeToM (Just x) = return x in maybeToM
01:22:53 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> m a
01:24:10 <nomeata> dons: in your code on the blog you define the die function, but I can’t see it being used anywhere.
01:30:53 <hyrax42> is there a way to set up darcs so that patches that leave the code non-compiling cannot be recorded?
01:31:16 <dons> pjd, anchor link targets?
01:31:50 <dons> nomeata: ah yes. its dead code :)
01:32:05 <dons> hyrax42: yes, setpref test
01:32:19 <pjd> dons: the permalinks link to a #foo for each article, without the foo target actually being there
01:32:20 <dons> there's an example a few days ago on my blog :)
01:32:27 <dons> oh hmm
01:32:34 <hyrax42> dons: ha ok
01:33:01 <dons> pjd, oh, just the top of the page for that day. right
01:33:10 <dons> I should really add the anchors in...
01:33:13 <dons> thanks for spotting that
01:34:00 <hyrax42> hmmm so something like
01:34:25 <hyrax42> setpref test "./Setup.lhs configure; ./Setup.lhs build"?
01:35:11 <pjd> dons: your tutorials are really great, by the way!
01:35:23 <hyrax42> ++
01:37:54 <Hype> i've got a question regarding records, can someone please look at this code and tell me why getFooFirst3 does not work? http://pastebin.ca/283399
01:42:36 <hyrax42> there is no reader in use
01:43:11 <hyrax42> ?type asks
01:43:13 <lambdabot> forall a (m :: * -> *) r. (MonadReader r m) => (r -> a) -> m a
01:43:26 <hyrax42> hmm
01:44:35 <hyrax42> ok is the error on the type?
01:45:35 <Hype> yes, it says: Couldn't match expected type `Int' against inferred type `a b'
01:45:46 <goltrpoat> the first two are in the list monad
01:46:01 <goltrpoat> the third one uses monadic code, but is Record -> Int
01:53:15 <tibbe> :t Control.Monad.Reader.asks
01:53:16 <lambdabot> forall a (m :: * -> *) r. (MonadReader r m) => (r -> a) -> m a
02:23:35 <tibbe> :t let getFooFirst2 rec = (let result = asks foo rec in head result) in getFoorFirst2
02:23:37 <lambdabot> Not in scope: `foo'
02:23:37 <lambdabot>  
02:23:37 <lambdabot> <interactive>:1:69: Not in scope: `getFoorFirst2'
02:24:15 <tibbe> :t asks
02:24:17 <lambdabot> forall a (m :: * -> *) r. (MonadReader r m) => (r -> a) -> m a
02:24:25 <tibbe> @hoogle asks
02:24:26 <lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
02:25:06 <araujo> morning
02:26:12 <tibbe> araujo: morning
02:30:14 <tibbe> why does this work: (asks id) 1
02:30:43 <dons> its the same as 'ask'
02:30:50 <tibbe> :t (Control.Monad.Reader.asks id)
02:30:52 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
02:30:59 <tibbe> dons: but it looks overapplied to me
02:31:16 <tibbe> what does applying 1 to a :: m r mean?
02:31:45 <tibbe> > (asks id) 1
02:31:47 <lambdabot>  1
02:32:51 <dons> :t ask 1
02:32:53 <lambdabot> forall r. (Num r) => r
02:33:07 <tibbe> :t ask
02:33:08 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
02:33:42 <tibbe> dons: what gets me is that I expect a function to be applied to 1 but it's a monad
02:34:16 <dons> yeah, its a little bit interesting, isn't it. using  the (a ->) monad
02:35:14 <tibbe> ah :)
02:35:23 <tibbe> I'll read all about it after lunch, thanks
02:35:26 <dons> since in (a ->), we have:
02:35:26 <dons> instance MonadReader r ((->) r) where
02:35:26 <dons>     ask       = id
02:35:39 <dons> and
02:35:40 <dons> asks f = do
02:35:40 <dons>     r <- ask
02:35:41 <dons>     return (f r)
02:36:04 <tibbe> thanks, gotta run
02:45:49 <pjd> if something evaluates to a monadic string, ghci doesn't print it out?
02:46:09 <pjd> but saying "it" shows it
02:47:59 <pjd> how would you get Data.Map.lookup k foo to show the lookup result?
02:50:05 <dons> lookup k m >>= print
02:50:07 <pjd> ah, Data.Map.lookup k foo >>= id
02:50:17 <pjd> ah, ok
02:51:11 <goltrpoat> > M.lookup 1 (singleton 1 "test") :: Maybe [Char]
02:51:12 <lambdabot>  Not in scope: `singleton'
02:51:16 <goltrpoat> > M.lookup 1 (M.singleton 1 "test") :: Maybe [Char]
02:51:18 <lambdabot>  Just "test"
02:51:22 <goltrpoat> that works too
02:51:55 <pjd> goltrpoat: cool!
02:52:36 <goltrpoat> it's polymorphic in the type of monad, so any monad works
02:52:40 <goltrpoat> > M.lookup 1 (M.singleton 1 "test") :: [String]
02:52:42 <lambdabot>  ["test"]
02:54:02 <nomeata> > M.lookup 1 (M.singleton 1 "test") :: Indentity String
02:54:03 <lambdabot>  Not in scope: type constructor or class `Indentity'
02:54:12 <pjd> goltrpoat: yeah, i just tried [String]
02:54:31 <pjd> is the identity monad defined in the prelude?
02:54:43 <nomeata> > M.lookup 1 (M.singleton 1 "test") :: Control.Monad.Indentity String
02:54:44 <lambdabot>  Not in scope: type constructor or class `Control.Monad.Indentity'
02:54:52 <norpan> spelling
02:55:01 <nomeata> > M.lookup 1 (M.singleton 1 "test") :: Control.Monad.Indentity.Indentity String
02:55:02 <lambdabot>    Not in scope: type constructor or class `Control.Monad.Indentity.Indentity'
02:55:12 <goltrpoat> Identity :)
02:55:21 <nomeata> > M.lookup 1 (M.singleton 1 "test") :: Control.Monad.Identity.Identity String
02:55:22 <lambdabot>    Not in scope: type constructor or class `Control.Monad.Identity.Identity'
02:55:31 <nomeata> hmpf
02:55:33 <nomeata> > M.lookup 1 (M.singleton 1 "test") :: Control.Monad.Identity String
02:55:34 <lambdabot>  Not in scope: type constructor or class `Control.Monad.Identity'
02:55:53 <nomeata> Can I run these trys in the list monad so that haskell just picks the one that works.
02:56:11 <nomeata> > M.lookup 1 (M.singleton 1 "test") :: Identity String
02:56:12 <lambdabot>  Not in scope: type constructor or class `Identity'
02:56:55 <dons> actually, its not in scope, i think.
02:56:58 <dons> i'm adding it
02:57:08 <dons> neither is Cont actually
02:58:27 <dons> ?users
02:58:27 <lambdabot> Maximum users seen in #haskell: 291, currently: 272 (93.5%), active: 24 (8.8%)
02:59:49 <pjd> ah, got it working, but there's no Show instance for Identity String
03:00:24 <pjd> is it possible to derive one?
03:00:26 <goltrpoat> try runIdentity, pjd
03:00:38 <goltrpoat> eg, here's a really obfuscated hello world:
03:00:47 <goltrpoat> > (runState $ Data.Map.lookup 1 (singleton 1 "hello")) "world"
03:00:47 <lambdabot>  Not in scope: `singleton'
03:00:51 <goltrpoat> bah
03:00:55 <dons> M.
03:00:55 <pjd> runIdentity?
03:00:58 <goltrpoat> > (runState $ M.lookup 1 (M.singleton 1 "hello")) "world"
03:00:59 <lambdabot>  ("hello","world")
03:01:50 <goltrpoat> dons:  is it importing Control.Monad.Identity now?
03:02:18 <goltrpoat> > runIdentity $ M.lookup 1 (M.singleton 1 "hello")
03:02:19 <lambdabot>  Not in scope: `runIdentity'
03:02:20 <pjd> ah, so: runIdentity $ lookup k foo
03:02:24 <goltrpoat> doh
03:02:33 <pjd> goltrpoat: works here :)
03:02:34 <goltrpoat> yeah
03:02:37 <goltrpoat> coolness
03:02:49 <dons> goltrpoat: nah. i'll rebuild tomorrow
03:02:58 <goltrpoat> ah ok
03:03:00 <dons> the patch is committed though
03:03:05 <goltrpoat> cool
03:03:11 <pjd> this is so weird and wonderful
03:03:18 <dons> also adds Cont and List
03:03:30 <dons> so we can have some prolog callCC fun!
03:03:42 <dons> d:}
03:03:53 <goltrpoat> haha
03:03:57 <goltrpoat> excellent.
03:04:33 <profmakx> hm,
03:04:43 <profmakx> @karma+ dons
03:04:44 <lambdabot> dons's karma raised to 104.
03:04:55 <profmakx> hooray for dons programming haskell
03:05:03 <pjd> how does runIdentity actually work?
03:05:27 <goltrpoat> it takes Identity a to a
03:05:28 <pjd> does it just unpack an Identity instance?
03:05:34 <goltrpoat> yeah
03:05:59 <pjd> so it's equivalent to (>>= id)
03:06:16 <goltrpoat> on Identity, sure
03:06:32 <goltrpoat> oh wait, no it's not
03:06:34 <goltrpoat> :t (>>= id)
03:06:36 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
03:06:47 <dons> instance Monad Identity where
03:06:47 <dons>     return a = Identity a
03:06:49 <dons>     m >>= k  = k (runIdentity m)
03:06:58 <dons> newtype Identity a = Identity { runIdentity :: a }
03:08:07 <goltrpoat> (>>= id) is actually join
03:08:12 <goltrpoat> :t join
03:08:13 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
03:10:21 <pjd> Identity a -> a is not *too* different from (Monad m) => m (m b) -> m b...
03:10:38 <pjd> what's an example that would expose the difference?
03:14:29 <goltrpoat> well
03:14:46 <goltrpoat> > runIdentity (return 5 :: Identity Int)
03:14:47 <lambdabot>  Not in scope: type constructor or class `Identity'
03:14:56 <goltrpoat> crap, i keep forgetting
03:15:27 <goltrpoat> the example is runIdentity (return 5 :: Identity Int), which typechecks, versus (>>= id) (return 5 :: Identity Int)
03:15:38 <goltrpoat> which doesn't, Int not being a monad
03:20:54 <pjd> ah, i got:
03:20:55 <pjd> (>>= id) $ Identity (lookup k foo) -- result inside Identity
03:20:55 <pjd> runIdentity $ Identity (lookup k foo) -- result inside any monad (?)
03:21:53 <pjd> so the first makes the Identity monad "spill over" into the lookup result
03:22:20 <pjd> while the second Identity and runIdentity just cancel each other out
03:22:45 <goltrpoat> the first one forces lookup to be k -> Map k a -> Identity a, and the join takes the resulting Identity (Identity a) to Identity a
03:23:23 <pjd> yeah
03:24:55 <goltrpoat> actually.. without the join, it's (Monad m) => Identity (m String), and the join is what forces m to Identity
03:24:57 <ozone> ibid: can you correct my name on planet haskell?  the last name should be "pang", not "pag" :)
03:25:26 <pjd> goltrpoat: yeah, that's what i meant with spilling over
03:25:32 <goltrpoat> ah gotcha
03:26:02 <pjd> compared to the second one which preserves the original type intact
03:26:34 <dons> ozone: I like 'pag' better
03:27:03 <dons> ander pag
03:27:09 <dons> anders
03:27:12 <ozone> <- nearly swedish
03:27:15 <ozone> bjork bjork bjork
03:27:19 <ozone> i mean... bork bork bork
03:27:58 <goltrpoat> lies!  dictionary.com says that PaG is an acronym for pennsylvania german.
03:29:02 <goltrpoat> which i suppose doesn't entirely rule out swedish ancestry.
03:29:08 <goltrpoat> that, again, sounded a lot funnier in my head.
03:30:17 <goltrpoat> tough crowd.
03:32:41 * pjd contemplates writing a joke in Haskell
03:33:17 <pjd> i've only been able to do one in Python
03:33:49 <mwc> @pl \s -> (head s, tail s)
03:33:50 <lambdabot> liftM2 (,) head tail
03:33:52 <goltrpoat> @pl \so a duck walks -> into a bar
03:33:53 <lambdabot> const (const . const . flip into bar)
03:34:09 <mwc> @unpl
03:34:10 <lambdabot> pointful module failed: IRCRaised Lib/Pointful.hs:38:24-51: Non-exhaustive patterns in lambda
03:34:19 <dons> oops
03:34:21 <mwc> @unpl const (const . const. flip into bar)
03:34:22 <lambdabot> (\ _ i _ _ -> into i bar)
03:34:37 <mwc> ah damn, It would have made my day if lambdabot told goltrpoat's joke back to me
03:34:40 <goltrpoat> hahah
03:35:04 <norpan> so a monkey walks into a bar
03:35:13 <nomeata> :t bar
03:35:15 <lambdabot> Not in scope: `bar'
03:35:28 <norpan> pays with a 20 dollar bill
03:35:45 <norpan> the barkeep decides to make fun with the monkey and only gives one dollar in change
03:36:06 <norpan> have you heard that one? :)
03:36:27 <nomeata> Don’t think so.
03:36:38 <nomeata> But it’s only on topic if it is pure, and has no side effects.
03:36:44 <nomeata> :-)
03:36:49 <goltrpoat> hehe
03:36:59 <norpan> the monkey says nothing, just puts the dollar bill in its fur
03:37:02 <kfish> or if it's got action
03:37:30 <norpan> the barkeep tries to strike a conversations, says: it's not often we have monkeys here
03:37:46 <nomeata> I know what happens...
03:37:53 <tibbe> could someone explain the "function" monad to me?
03:37:55 <nomeata> (At least I can guess)
03:38:00 <tibbe> (-> a)
03:38:01 <norpan> no wonder, when you charge 19 dollars for a beer
03:38:10 <norpan> was your guess correct?
03:38:11 <nomeata> tibbe: what exactly needs explanation?
03:38:19 <tibbe> what's it for
03:38:24 <tibbe> > (asks id) 1
03:38:26 <lambdabot>  1
03:38:37 <tibbe> works because of the function monad, I don't understand why
03:38:45 <tibbe> :t (asks id)
03:38:46 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
03:39:08 <tibbe> so I have a (m r) and the reader monad and somehow I can apply an argument to that
03:39:18 <goltrpoat> :t liftM (*)
03:39:19 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m (a1 -> a1)
03:39:22 <goltrpoat> :t liftM (*) (+)
03:39:24 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
03:39:25 <nomeata> Not _the_ reader moand, it’s _a_ reader monad
03:39:29 <goltrpoat> er.
03:39:32 <goltrpoat> :t liftM (*) negate
03:39:33 <lambdabot> forall a. (Num a) => a -> a -> a
03:39:37 <nomeata> tibbe: in this case the ((->) a) Monad
03:39:38 <tibbe> nomeata: ah yes, instance of the ReaderMonad class
03:39:39 <goltrpoat> > (liftM (*) negate) 2 5
03:39:41 <lambdabot>  -10
03:40:07 <nomeata> tibbe: so the type is actually (r -> r)
03:40:09 <tibbe> nomeata: what does >>= and return look like in that monad?
03:40:29 <norpan> return = const
03:40:39 <tibbe> :t const
03:40:41 <lambdabot> forall a b. a -> b -> a
03:40:51 <ozone> dons: how long is it taking you to write each of those tutorials?
03:41:07 <nomeata> tibbe: you can think of the monad this way: “I refuse to hande the common argument at all when writing the code, and at the end it will automatically put wherever it belongs to“
03:41:08 <goltrpoat> > (negate >>= (*)) 3
03:41:10 <lambdabot>  -9
03:41:46 <nomeata> (head >>= (:)) "stutter"
03:41:51 <nomeata> > (head >>= (:)) "stutter"
03:41:53 <lambdabot>  "sstutter"
03:41:54 <dons> tibbe:
03:41:55 <dons>    asks id
03:41:56 <dons> => (\f -> do r <- ask; return (f r)) id
03:41:56 <dons> => (do r <- ask; return (id r))
03:41:56 <dons> => (do r <- ask; return r)
03:41:58 <dons> => (ask >>= return)
03:42:00 <dons> => (ask) :: m r
03:42:03 <dons> => id               -- via instance MonadReader r ((->) r) where ask = id
03:42:04 <tibbe> :)
03:42:05 <dons> ozone, 3 hrs
03:42:21 <profmakx> dons.. you made my day today. The second time -.-
03:42:32 <tibbe> nomeata: is it you or me who uses strange character encoding? i get utf8 symbols (or something) in your text
03:42:43 <nomeata> tibbe: yes, I use utf8 symbols :-)
03:42:46 <dons> profmakx: oh?
03:42:58 <nomeata> tibbe: (to be precice, I encode my unicode characters in utf8)
03:43:00 <profmakx> yeah, your comment to the reddit post on "Why I still love C++"
03:43:03 <dons> heh
03:43:15 <norpan> UTF-8 is the only true way
03:43:30 <tibbe> lemme switch to utf8 then
03:43:34 <ozone> dons: yeah, that would've bene my guess
03:43:36 <tibbe> some channels doesn't use it
03:43:45 <ozone> dons: a lot of effort right there!
03:43:55 <dons> ozone, its kinda exhausting!
03:43:58 <dons> but also fun :)
03:44:00 <ozone> dons: no kidding :)
03:44:12 <ozone> dons: spent about 3 hours on my monad thing, and it's, what, 40% done?
03:44:17 <dons> hehe
03:45:07 <dons> get cracking then!  :)
03:45:26 <ibid> ozone: sorry, vi seems to get confused on that line, probably due to the diacritic
03:45:49 <ozone> ibid: no worries.  makes sense :)
03:46:04 <ozone> ah, 2006 and we still can't use non-ASCII characters in most tools
03:46:08 <ozone> how i love computing sometimes
03:46:19 <tibbe> nomeata: write some utf8 unicode please
03:46:31 <dons> ?users
03:46:32 <lambdabot> Maximum users seen in #haskell: 291, currently: 276 (94.8%), active: 27 (9.8%)
03:46:40 <ozone> these FC++ people are insane
03:46:45 <ibid> ozone: works on my local computer though :)
03:46:59 <ozone> ibid: but of course ;)
03:47:14 <nomeata> tibbe: for n → ∞: 3 · 5 = 3 × 5 …
03:47:20 <ibid> heh, and it's even more wrong now :)
03:47:28 <goltrpoat> i should write a "why i hate c++" post
03:47:32 <ibid> ozone: seems to be some sort of ssh/xterm trouble
03:47:34 <tibbe> nomeata: works, thanks
03:47:45 <dons> "why C++ set back programming 20 years"
03:47:57 <ozone> goltrpoat: remind me, are you pgeist? :)
03:48:01 <goltrpoat> ozone:  yeah
03:48:04 <dons> imagine if lisp had emerged victorious from the 80s instead of C++....
03:48:06 <nomeata> tibbe: “English” ‘English” „German“ ‚German‘ Correct Apostrophe: ’ Accents: ´`¸¯^°
03:48:14 <nomeata> tibbe: - – − _
03:48:15 <ozone> good good.  i was looking at your nickname thinking "man, that's far too familiar..."
03:48:16 <dons> argh my terminal!
03:48:19 <goltrpoat> haha
03:48:28 <ozone> dons: or smalltalk vs C
03:48:52 * nomeata needs to bind the haskell unicode characters on some keys.
03:49:06 <tibbe> åäö
03:49:12 <ibid> ozone: seems to be correct now
03:49:14 <nomeata> I already have →, but I need lambda and forall
03:49:33 <ozone> thanks ibid :)
03:49:41 <dons> i liked glguy's use of <- (the unicode arrow version) on reddit
03:49:42 <nomeata> And I need to define (∈) = elem
03:49:44 <ozone> maybe i should put a capital lambda instead of an A in my name
03:49:47 <ozone> that'll really frig you over, ibid
03:49:53 <dons> we need more Isabelle/ProofGeneral style symbols in our editors!
03:50:05 <nomeata> and (∉) = notElem
03:50:06 <goltrpoat> my screen is full of a-circumflexes in various states of capitalization
03:50:29 <ibid> ozone: oh, i have no problems with unicode, only my tools do :)
03:50:52 <goltrpoat> also:  boxes.  lots of boxes.
03:51:18 <nomeata> and other nice characters like ∧ for and and ∨ for or
03:51:36 <goltrpoat> ah cool, got a paragraph character that time.
03:51:46 <goltrpoat> that's new.
03:51:48 <nomeata> not equality is nice as well: ≠
03:51:56 <ozone> some crazy bastard in our research group has remapped his keyboard so that he can type in latex to get accents.  e.g. \'e will produce an e acute
03:52:21 <goltrpoat> hah
03:52:34 <nomeata> Can I make haskell accept ∅ as the empty list, even in patter matching?
03:54:45 <nomeata> Other candidates to spike up the code would be: ∑ = sum; (≤) = <=; (≥) = >=
03:55:46 <nomeata> ℤ = Int :-)
03:56:21 <ozone> nom	oooh, pretty
03:56:29 <ozone> what the hell is wrong with this terminal
03:56:29 <tibbe> I can't read that
03:56:50 <nomeata> tibbe: the last one? black board Z. Not every font covers all characters...
03:57:38 <tibbe> nomeata: alright
03:57:47 <tibbe> using bitstream vera
03:57:48 <apfelmus> does anybody know how GHC implements strictness analysis?
03:58:48 <dons> check the haskell.org 'research papers' page under 'compiler construction' (or something like that)
03:59:14 <kfish> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
03:59:17 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
03:59:20 <apfelmus> dons: i did but i couldn't figure what is actually implemented
03:59:37 <kfish> http://bother.kfish.org/wiki/HaskellUTF8
03:59:38 <nomeata> kfish: unfortunately only since ghc 6.6, so I have to wait for the next gtk2hs release to use it.
03:59:39 <lambdabot> Title: HaskellUTF8 - kfish - Trac
03:59:53 <kfish> nomeata, ah, yeah :-)
04:00:34 <nomeata> Oh, I thought ghc6.6 allows unicode in identifiers :-(
04:00:48 <nomeata> So, it only allows those mentioned on http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource ?
04:00:49 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
04:01:30 <kfish> i'm just waiting for the day when all the world's code starts getting written in native languages, and we have a tower of babel moment for sourcecode
04:01:43 <nomeata> Actually, I don’t know if it is wise to support identifiers in strings before providing Utf8 en-/decoding code in the standard library :-(
04:02:20 <apfelmus> dons: to me, it somehow looks like projection based strictness analysis never went into a compiler
04:04:03 <nomeata> > show "test…"
04:04:04 <lambdabot>  lexical error in string/character literal
04:04:30 <nomeata> kfish: so, will ghc6.6 just strip the higher bits if printing a utf8 string?
04:05:15 <xpika> how do i type in those unicode characters?
04:05:18 <nomeata> kfish: or is it defaulting to encode higher bits as utf8?
04:05:44 <nomeata> xpika: depends on your interface, keyboard set etc. copy’n’paste is the easiest :-)
04:05:53 <kfish> it can handle unicode fine in strings etc
04:06:15 <xpika> \x2192
04:06:15 <nomeata> kfish: but how does it handle it? One unicode charcter will be one Char, right?
04:06:22 <goltrpoat> programs should be written in dactylic hexameter.  "This is a dialog window.  Its title depends on the input. / Contains, amongst various widgets, / Two buttons, OK and then Cancel."
04:06:38 <xpika> in windows i can use alt + key combinations
04:06:50 <goltrpoat> the compiler should pop up a warning if you break meter.
04:06:52 <xpika> is there a default linux equivalent
04:07:04 <kfish> nomeata, actually, what i wrote isn't quite true -- apparently identifiers work for character sets that have case information, but that doesn't include east asian languages that I'm interested in -- so it may work for other european languages etc
04:07:06 <ms_> xpika: alt and stuff works here too
04:07:17 <xpika> :(
04:07:28 <pjd> xpika: alter your keyboard mapping
04:07:32 <xpika> ∷
04:07:35 <kfish> xpika, what distro are you using?
04:07:39 <xpika> fedora 5
04:07:40 <ozone> kfish: oh yeah, while you're here... :)
04:07:53 <xpika> ⇒
04:07:56 <pjd> xpika: you can say something like setxkbmap -option compose:menu
04:08:01 <ozone> what's the deal with utf-8 in japan these days?  is it still kinda not used very much?
04:08:11 <pjd> which will let you use the menu key to compose some combinations
04:08:12 <nomeata> ghc6.4 would just ignore higher bits if you print Strings with Chars >= 2^8, right? Sow what is ghc6.6 doing instead?
04:08:18 <kfish> xpika, not sure, sorry -- in ubuntu it's just System -> Administration -> Language Support
04:08:25 <Botje> ozone: utf8 really sucks for full-japanese texts
04:09:07 <nomeata> Botje: only because of file size, or also other issues?
04:09:18 <Botje> nomeata: size, mostly.
04:09:45 <ozone> Botje: sha, that's what i heard
04:09:55 <kfish> ozone: you were asking me the other day about shift-jis vs. euc etc, sorry i haven't asked around since
04:10:06 <ozone> no worries
04:10:15 <pjd> how does Japanese text do in UTF-16?
04:10:18 <nomeata> I can’t imagine that ghc6.6 would print out strings as utf8, because that would break if the data read is any other 8bit data, including binary.
04:10:37 <Wallbraker> pjd: most fit into 16bits
04:11:05 <pjd> nomeata: it would need to know what the terminal encoding is
04:11:52 <kfish> http://www.cl.cam.ac.uk/~mgk25/unicode.html
04:11:54 <lambdabot> Title: UTF-8 and Unicode FAQ
04:12:01 <kfish> :-)
04:12:11 <nomeata> pjd: and it needs to know what kind of input the input files are
04:12:31 <pjd> nomeata: you can do the latter with source code annotations, though
04:12:42 <nomeata> pjd: I mean file that are open’ed
04:13:05 <pjd> oh; that's something entirely different
04:13:12 <pjd> guessing would be the worst possible thing you can do, of course
04:13:28 <nomeata> pjd: so, what _is_ being done in ghc6.6?
04:13:57 <pjd> i have no clue whatsoever, sorry :)
04:14:32 <kfish> ghc6.6 interprets source as utf-8, so when you write a string in double-quotes, it interprets the contents as the codepoints corresponding to the utf-8 you wrote
04:14:49 <nomeata> kfish: ok. and how does it output that?
04:15:12 <kfish> well, when i run my terminal in utf-8 and run that days of the week in japanese program, it works fine
04:15:57 <kfish> and the Data.Char functions can all handle unicode
04:16:08 <kfish> ie. know about numerals, upper/lowercase etc. in many character sets
04:16:41 <nomeata> kfish: so that means when you print strings, it encodes character points >= 127 as utf8?
04:16:44 <kfish> hmm, this sounds like a good excuse to write that dictionary program i wanted to hack on ...
04:17:09 <nomeata> kfish: but wouldn’t that break the "main = interact id" program when fed 8bit data?
04:17:11 <kfish> nomeata, when you put bytes >= 127 in your haskell source, outside of comments, yes
04:18:26 <nomeata> kfish: If I do this: compile "main = interact ( "öhh " ++)" as test, and then "echo äää | test"
04:18:50 <kfish> nomeata, what happens?
04:19:03 <nomeata> Doesn’t it the read the input as _bytes_ the strings in the code as _characters_ and outputs one or the other broken?
04:19:12 <nomeata> dunno, no ghc6.6 here :-(
04:20:02 <nomeata> here as a oneliner: echo ä| ghc -e 'interact ("ö"++)'
04:20:38 <nomeata> it prints äö ok here, but ghc6.4 is treating both input and source strings as lists of 8bit bytes, so nothing goes wrong.
04:20:43 <goltrpoat> ive found what is quite possibly the least useful mathworld article ever:  http://mathworld.wolfram.com/Allegory.html
04:20:45 <lambdabot> Title: Allegory -- from Wolfram MathWorld
04:21:27 <nomeata> but If suddently the character in the code is not two bytes (stored in two low Char) any more, but one high Char, but the standard input stays two low Chars, then something must break.
04:21:31 <Syzygy-> mik@mpc723:~/musik$ echo "ä" | ghc -e 'interact ("ö" ++)'                   [1]
04:21:34 <Syzygy-> öä
04:21:37 <Syzygy-> mik@mpc723:~/musik$ ghc --version                                           [0]
04:21:38 <tibbe> goltrpoat: there are a few of those one liners on MW
04:21:39 <Syzygy-> The Glorious Glasgow Haskell Compilation System, version 6.6
04:22:13 <nomeata> Syzygy-: ok, can you check ghc -e 'putStrLn (show "ä")'
04:22:19 <goltrpoat> tibbe:  yeah, but this one in particular just.. says absolutely nothing
04:22:20 <goltrpoat> hehe
04:22:27 <Syzygy-> mik@mpc723:~/musik$ ghc -e 'putStrLn (show "ä")'                            [0]
04:22:30 <Syzygy-> "\228"
04:23:26 <nomeata> Syzygy-: what about: ghc -e 'putStrLn ("ä")' | hexdump
04:24:18 <tibbe> > map toUpper "utf8"
04:24:19 <lambdabot>  "UTF8"
04:26:24 <nomeata> It seems that ghc6.6 is indeed encoding every Char >= 128 as an utf8 byte sequence. But it also seams to read any file as an utf8 byte sequence. That means that it should beak when workin on binary or other 8bit data, and not using openBinaryFile instead of openFile.
04:26:39 <nomeata> (break = not work as ghc6.4 did)
04:28:28 <nomeata> Would be interesting to feed invalid utf8 to ghc6.6: echo -n -e \\xF0 | ghc -e 'interact show'
04:29:01 <nomeata> ghc6.4 gives: "\240", obviously treaing the input as a squence of 8bit chars.
04:29:21 <Syzygy-> mik@mpc723:~/musik$ ghc -e 'putStrLn ("ä")' | hexdump                       [0]
04:29:24 <Syzygy-> 0000000 0ae4
04:29:27 <Syzygy-> 0000002
04:29:40 <nomeata> Syzygy-: are you using an utf8 console?
04:29:47 <Syzygy-> 6.6 also gives \240
04:29:55 <Syzygy-> Though I habitually set my consoles to latin-1.
04:30:09 <nomeata> Syzygy-: because it is not outputting uf8...
04:30:39 <Syzygy-> Partially because I don't really want to figure out how to get it all working differently for different consoles.
04:31:43 <nomeata> Ok, I’d love to hear if ghc6.6 acts differently on an utf8 console.
04:32:09 <nomeata> Syzygy- showed that ghc6.6 acts like 6.4 in a latin1 environment.
04:33:09 <Syzygy-> nomeata: What do I need to set to get my ghc6.6 to work on utf8?
04:35:47 <ms_> declare -x LANG="en_GB.UTF-8"
04:36:00 <ms_> Syzygy-: that's all I've got set relating to utf8
04:36:10 <ms_> plus generate locales for utf8
04:36:27 <ms_> ms@arkansas:~$ ghc -e 'putStrLn (show "ä")'
04:36:27 <ms_> "\195\164"
04:36:33 <Cale>  1118 math      16   0  222m 187m 5700 S  0.0 18.5   2:52.29 lambdabot
04:36:36 <Cale> whoa
04:38:20 <pjd> too many botsnacks?
04:38:22 <JohnMeacham> latest benchmarks: ghc -O 0.720 seconds, jhc using ghc as back end, 0.704 seconds, jhc using its native back end, 0.680 seconds. as a preprocessor for things that will be compiled by ghc, jhc seems to work pretty well.
04:38:25 <dons> mmm. there's a slow leak i haven't bothered to profile
04:38:37 <dons> I think sjanssen worked it you though.
04:38:44 <dons> worked it out
04:38:51 <JohnMeacham> this is for the prime calculating nofib program.
04:38:52 <dons> JohnMeacham: nice!
04:39:05 <nomeata> ms_: that’s interesting!
04:39:19 <dons> Cale: i'l try to have a look soon.
04:39:21 <ms_> nomeata: yeah - I seem to get utf16 output?
04:39:21 <nomeata> ms_c could you run: echo ä| ghc -e 'interact ("ö"++)'
04:39:25 <dons> otherwise , just reset :)
04:39:35 <nomeata> ms_c: and echo ä| ghc -e 'interact ("ö"++)' | hexdump
04:39:39 <dons> (i think i leak an IORef somewhere... from memory)
04:39:44 <nomeata> ms_: no, that probably is utf8
04:39:59 <ms_> öä
04:40:02 <ms_> 0000000 b6c3 a4c3 000a
04:40:07 <Cale> dons: I'm not running an extremely current release at the moment, but I'll do an update at some point soon :)
04:40:25 <dons> Cale, what's the uptime on that sucker?
04:40:26 <agocorona> help wanted. hs-plugins Make error: http://paste.lisp.org/display/32748
04:40:41 <agocorona> hi
04:40:42 <Cale> I'm not entirely sure, not more than a week.
04:40:55 <nomeata> ms_: and then the last check: ghc -e 'putStr (show "ä")'
04:40:56 * dons notes his slashnet bot is uptime: 1m 17d 11h 7m 35s
04:41:09 <Cale> (I've just restarted it, so I can't do an @uptime)
04:41:11 <ms_> "\195\164"
04:41:17 <nomeata> ha, new it
04:41:23 <ms_> what's that then?
04:41:26 <nomeata> it does _not_ support utf8 in strings
04:41:44 <dons> ?babel es en El sistema no puede hallar el archivo especificado
04:41:46 <lambdabot>  The system cannot find the specified file
04:41:50 <nomeata> that is, it supports it, but it just treats it as two bytes. as ghc6.4 already did.
04:42:02 <nomeata> kfish: or did I understand you wrongly?
04:42:08 <dons> agocorona: can you try using hs-plugins from the darcs repo?
04:42:11 <Cale> I'd need a UPS if I wanted to keep my machines running for any appreciable length of time in Brantford. There are power failures every couple of weeks.
04:42:34 <dons> oh? you out in the country somewhere?
04:42:45 <ms_> nomeata: echo ä| ghc -e 'interact (\x -> show $ length $ "ö"++x)'
04:42:45 <nomeata> here in Ghana they are regularily scheduled every 5 12-hour interval
04:42:45 <ms_> 5
04:42:49 <Cale> Not really, on the edge of a city.
04:42:53 <agocorona> dons, Oll try. thanks
04:43:02 <nomeata> ms_: yes, two bytes per character plus newline
04:43:07 <ms_> exactly.
04:43:14 <dons> ?users
04:43:14 <lambdabot> Maximum users seen in #haskell: 291, currently: 275 (94.5%), active: 36 (13.1%)
04:43:15 <Cale> Brantford isn't exactly the most progressive city in southern Ontario.
04:43:32 <ms_> but shouldn't it understand that a Char isn't necessarily just 1 byte?
04:43:38 <nomeata> ms_: but what is then the utf8-support in code strings that kfish said
04:43:39 <Cale> (The property here is nice though, we're on the edge of a forest.)
04:43:43 <ms_> so ideally it should have counted 3 chars?
04:44:13 <nomeata> ms_: because it does know what kind of encoding any input is
04:44:22 <dons> I'd like to point out that that was the best babel translation i've ever seen:
04:44:23 <ms_> yup.
04:44:23 <dons> ?babel es en El sistema no puede hallar el archivo especificado
04:44:25 <lambdabot>  The system cannot find the specified file
04:45:05 <agocorona> dons: yes, lambdabot is right
04:45:18 <nomeata> ms_: and I hope that gets’s fixed soon, by separating binary data [Word8] from Strings (real [Char]) and providing conversation functions, and distinct IO functions for these.
04:45:48 <nomeata> Basically, hRead etc. should not return [Char], but [Word8], since haskell does not know what kind of characters there are.
04:45:51 <dons> nomeata: i liked your maybeM idea
04:46:00 <nomeata> dons: thx
04:46:02 <Cale> I wonder whether babelfish has special case translations.
04:46:08 <nomeata> dons: what should I do with such an idea?
04:46:20 <dons> nomeata: it could be added to Data.Maybe
04:46:34 <agocorona> the translation is perfect in this case
04:46:35 <nomeata> dons: what’s the process of doing that?
04:46:41 <dons> to do this, you submit a libraries ticket
04:46:49 <dons> following this process:
04:47:02 * dons hunts for the link...
04:47:21 <kfish> ?babel es en El sistema no puede hallar el pescado especificado
04:47:22 <lambdabot>  The system cannot find the specified fish
04:47:26 <dons> http://haskell.org/haskellwiki/Library_submissions
04:47:27 <lambdabot> Title: Library submissions - HaskellWiki
04:47:54 <nomeata> dons: thx, will do that after lunch :-)
04:48:07 <dons> great
04:48:27 <nomeata> hmm. for such simple additions, do I really have to get the source and compile it?
04:48:39 <dons> its a good idea
04:48:44 <dons> darcs get the libraries src
04:48:49 <kfish> nomeata, i assume that the runtime converts to the terminals character set, which might explain the conversions you see
04:48:53 <dons> add the file, add a haddock, darcs record ; darcs send
04:49:03 <kfish> but yeah, haskell needs some charset conversion in base
04:49:10 <nomeata> kfish: so far I have not seen any special unicode handling in strings, so no converstion needed
04:50:05 <kfish> nomeata, ok, well at least it can read characters in source, rather than barfing on them -- i think that was the main change in 6.6 ;-)
04:51:02 <Syzygy-> ?babel en es Your hoverboat is full of eels.
04:51:04 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
04:51:05 <nomeata> kfish: it isn’t barfing on them in strings in 6.4
04:51:05 <nomeata> kfish: but utf8 in identifiers, that’s the great good change
04:51:23 * nomeata → lunch
04:51:26 <Syzygy-> nomeata: I can use utf8 in identifiers in 6.6!?!?
04:51:31 * Syzygy- drools silently
04:51:53 <ozone> no, but you can use UTF-7 :}
04:52:00 <Syzygy-> That'd mean, hypothetically, that I could write my functions the way I'd pronounce them? Using the IPA codepoints?
04:53:42 <kfish> Syzygy-, try it, with -fglasgow-exts
04:54:15 <dons> Syzygy-: yes, I think you can do that
04:54:22 <kfish> i'm curious because I've only tried it with japanese, which it doesn't work for because there's no case info, and haskell relies on case
04:54:28 <dons> or as lambdabot says
04:54:31 <dons> ?faq
04:54:32 <lambdabot> The answer is: Yes! Haskell can do that.
04:54:34 <dons> hehe
04:54:51 <dons> Syzygy-: at least you can use real foralls and lambdas
04:54:56 <ozone> dons: you have way too much free spare time
04:55:17 <dons> :P
04:55:19 <Cale> It's strange, I have quite an old memory of Robin Milner talking about the pi-calculus, but I can't remember where I'd likely have seen it. It doesn't seem to be on Google Video.
04:56:21 <Cale> My best guess is that it was on TV, but I can't imagine that there would actually be a station which would spend time on something like that. :)
04:58:46 <dons> ozone: you should write some blog stuff on your erlang experiences
04:58:53 <dons> i'd be interested, anyway :)
04:59:41 <Syzygy-> nomeata: I got UTF running (with some poking)
04:59:43 <Syzygy-> mik@mpc723:~/musik$ echo ä| ghc -e 'interact ("ö"++)'                                    [0]
04:59:46 <Syzygy-> öä
04:59:49 <Syzygy-> mik@mpc723:~/musik$ echo ä| ghc -e 'interact ("ö"++)' | hexdump                          [0]
04:59:52 <Syzygy-> 0000000 b6c3 a4c3 000a
04:59:52 <dons> ozone, instead of all these video games and hot chicks you talk about normally ;)
05:03:28 <ms_> can you nest modules or otherwise put > 1 module in a file?
05:03:36 <Cale> I like the way that it's clearly written on the back of a piece of musical score.
05:03:51 <Cale> Which song is it, I wonder? :)
05:07:28 <geoff_s> who #haskell
05:07:38 <Cale> Hello geoff_s
05:07:52 <Cale> Could you be more specific? :)
05:07:57 <ozone> dons: quiet, there's this really hot asian chick in world of warcraft right now!
05:08:01 <geoff_s> apologies for that!
05:08:58 <retybok> ?users haskell
05:08:58 <Cale> Does darcs push work transparently via ssh?
05:09:00 <lambdabot> Maximum users seen in haskell: 0, currently: 0 (NaN%), active: 0 (NaN%)
05:09:09 <Cale> ?users #haskell
05:09:10 <lambdabot> Maximum users seen in #haskell: 291, currently: 277 (95.2%), active: 33 (11.9%)
05:09:15 <retybok> :)
05:09:25 <Cale> ?users Cale
05:09:25 <lambdabot> Maximum users seen in cale: 1, currently: 0 (0.0%), active: 0 (NaN%)
05:09:40 <retybok> that would be you :)
05:09:53 <Cale> currently, there are 0 users in me
05:10:37 <Cale> I suppose that lambdabot is definitive proof that I have no soul :)
05:10:42 <ndm> @seen Philippa_
05:10:43 <lambdabot> Philippa_ is in #scannedinavian, #haskell, #haskell-overflow, #haskell-blah and #oasis. I don't know when Philippa_ last spoke.
05:10:47 <dons> Cale, that's what you think... there's a John Malkovich tunnel into your brain!
05:11:00 <dons> there's 9 of us in here at the moment
05:11:05 <Cale> hehe
05:11:40 <ozone> malkovich malkovich malkovich
05:12:04 <dons> malkovich malkovich
05:12:12 <dons> malkovich?
05:12:34 <ozone> malkovich malkovich!
05:12:53 <Cale> A friend of mine wants to use my machine to manage synchronising her files from various places, and she has an ssh account on my machine already. Can I just tell her to do something like  darcs get robin@cale.yi.org:repo  and then she'll be able to push and pull patches transparently over the network, or does it involve more setup?
05:13:58 <profmakx> Cale i do exactly this with my thesis
05:14:02 <profmakx> works perfectly
05:14:03 <Cale> okay, cool
05:14:06 <dons> Cale: should be ok, if she has a dss key on the machine
05:14:08 <profmakx> (without any setup)
05:14:08 * ms_ wonders about mentioning monotone in preference to darcs...
05:14:10 <ibid> if the repository ~robin/repo already exists in cale.yi.org, and she has write access, there is no problem
05:14:12 <dons> (then no passwords)
05:14:25 <ndm> doesn't work for me with keyless login
05:14:33 <ndm> i.e. i have a password, and it totally doesn't work
05:14:47 <dons> ndm, hmm? no ssh-keygen keys?
05:14:57 <dons> passwd are for the olden days :)
05:15:01 <ndm> dons: haven't set it up yet, but i really should do!
05:15:09 <ndm> but its annoying that it just doesn't work with password at all
05:16:06 <pjd> Cale: mercurial works well for that setup too
05:16:10 <ibid> Cale: would advise the check that the darcses and sshs are recent enough to work with ssh control master, so that passwords are not asked all the time and your firewall (if it is set to tarpit ssh password attacks) won't interfere
05:16:22 <pjd> i use it for all my home dirs
05:16:57 <Cale> ibid: how new would that be? Currently, we'd have the darcs which is in Ubuntu Edgy
05:18:06 <Cale> ah, so it doesn't know how to ask for a password?
05:18:33 <ibid> Cale: it does
05:18:41 <Cale> okay
05:18:43 <ibid> Cale: well, the underlying ssh does
05:19:02 <pjd> mercurial works with passwords, FWIW
05:19:37 <ibid> Cale: darcs 1.0.7
05:20:02 <ibid> Cale: ssh 4.0
05:20:37 <agocorona> dons: I do not find the darcs link for hs-plugins. could you give me a hint?. Thanks
05:21:08 <Syzygy-> ?where hs-plugins
05:21:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
05:21:23 <mwc> Could somebody familiar with QuickCheck tell me what the hell this code I just wrote does? I kind of wrote it on a monkey-see-monkey-do basis from what I saw in the docs. I've read the docs and don't understand wtf "coarbitrary means." here's what I have:
05:21:35 <mwc> coarbitrary (Node l y g) = variant 1 . coarbitrary l .
05:21:35 <mwc>         coarbitrary y . coarbitrary g
05:21:54 <Cale> ibid: okay, cool
05:22:03 <Cale> (should be fine then)
05:22:22 <ibid> Cale: (openssh, particularly, obviously)
05:22:29 <agocorona> sysygy> thanks, but I did not find the darcs repository there
05:22:52 <Cale> darcs: 1.0.8 (release)
05:23:02 <Cale> ssh: OpenSSH_4.3p2 Debian-5ubuntu1, OpenSSL 0.9.8b 04 May 2006
05:23:23 <nomeata> @seen nomeata
05:23:24 <lambdabot> You are in #haskell. I last heard you speak just now.
05:23:58 <nomeata> lambdabot could tell me since when I’m in the channel, to help me detect connection aborts
05:24:23 <vincenz> Hello, Anyone know how to draw derivation trees with latex?
05:24:55 <ms_> vincenz: I would probably cheat and use dot and graphviz with the dotla (or ladot ?) stuff to put latex in there
05:25:11 <ms_> then go out via ps then to pdf and import the pdf back in as an image
05:26:19 <ms_> it's a little bit round the houses I know... http://brighten.bigw.org/projects/ladot/
05:26:21 <lambdabot> Title: Ladot: LaTeX in your Graphviz dot files
05:26:37 <vincenz> Zhere is the link?
05:26:56 <vincenz> ah, ok, screen was overwriting files, thank you :)
05:27:00 <ms_> np
05:27:12 <vincenz> But I was more interested in the types typicall used for operational/denotational semantics
05:27:15 <vincenz> Where you have the vertical bar
05:28:11 <ms_> oh \vbar? In fact, | get's interpreted correctly by LaTeX. I'm probably misunderstanding you though.
05:28:58 * kfish just finished transcribing the SPJ and Tim Harris video about STM by hand ... to 13pp of A4
05:29:50 <vincenz> ms_: not sure that will do alone, but it seems I need semantic.sty and \inference{}
05:31:54 <vincenz> what about the stuff like. <\sigma, a> -> \sigma'
05:32:03 <vincenz> Is that mathmode to get nice fonts, or is there some other mode?
05:33:38 <ms_> "nice fonts" is an interesting concept.
05:35:56 <goltrpoat> vincenz:  http://www.mathbin.net/2461
05:35:58 <lambdabot> Title: MathBin.net - Untitled
05:36:01 <goltrpoat> i cheated and used frac though
05:36:49 <Cale> Bulat is a bit crazy, I think all this imperative programming in Haskell stuff has gone to his head :)
05:38:35 <mwc> Cale, worst I ever did was inplace quicksort on an STArray... what's he gone and done
05:40:32 <vincenz> goltrpoat: thqnk you
05:40:32 <Cale> mwc: He appears to be suggesting to people on the Haskell-cafe mailing list that in order to write practical programs in Haskell, you need lots of IORefs
05:40:53 <vincenz> goltrpoat: does that scale?
05:41:01 <integral> that's weird
05:41:08 <vincenz> and grr, ssh/irssi is rewriting over my lines
05:41:27 <Cale> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020612.html -- for example, look at this :)
05:41:30 <lambdabot> Title: [Haskell-cafe] I'd like start with Haskell, but..., http://tinyurl.com/y4s2t4
05:42:17 <Cale> I mean, sure, working with imperative programming is a small constant factor more work, but this example gives entirely the wrong impression.
05:43:49 <Cale> Especially as it computes something which is a pure function.
05:44:00 <ndm> yeah, but Bulat really does care about being on par with assembly code
05:44:12 <ndm> i am curious that he constantly pushes JHC, is that useable yet?
05:44:31 <ndm> (i have an Athlon 750, which creaks a bit)
05:44:40 <earthy> for some values of useable: yes.
05:44:58 <ndm> is it just slow at compiling, or is that an unfair comment now?
05:45:28 <Cale> It seems like he's approaching the problem at the wrong level of abstraction though. He should be working on compiler optimisations.
05:45:43 <ndm> you need people to approach it from both angles
05:46:12 <ndm> how to write fast code with what we've got (i.e. writing libraries)
05:46:25 <ndm> how to make fast code out of what is now slow (optimisation)
05:46:57 <goltrpoat> vincenz:  the frac trick?  not particularly
05:47:13 <goltrpoat> whatever they do for continued fractions probably applies though
05:47:30 <Cale> I'm just surprised that there's such a push for speed -- I'm curious as to what it is that he's using Haskell for, because, well, people use programming languages like Python for writing games, and GHC produces much faster code than interpreting python code does.
05:47:48 <ndm> i use Hugs for everything :)
05:47:53 <Cale> indeed :)
05:47:57 <ndm> including writing an optimising compiler
05:48:04 <ndm> (which is faster than GHC ;))
05:48:07 <ms_> I'm using Haskell to write 3D games
05:48:12 <Cale> ms_: cool
05:48:19 <Cale> ms_: Frag? Or a new one?
05:48:27 <ms_> tron
05:48:32 <augustss> I think Haskell could get quite a few more users if you could write fast clean numerical code.
05:48:33 <Cale> awesome
05:48:41 <ms_> on a spring-mesh
05:48:45 <ms_> which deforms
05:48:46 <ms_> and stuff
05:48:54 <Cale> Yeah, we definitely need the numerics equivalent to Data.ByteString.
05:49:25 <Cale> Something which knows about different matrix types and automatically produces reasonably efficient and numerically stable code.
05:49:27 <augustss> I've tried a few times.  And the nice looking code is terrible
05:49:46 <Cale> It's a big task.
05:50:05 <augustss> yes, i know
05:50:07 <pjd> something along the same lines as numpy?
05:50:14 <Cale> There's easily one or two M.Sc. theses in it.
05:50:15 <pjd> numpy/scipy
05:53:32 <Cale> It might do just to have a really good lower-level library for it in the short term. (i.e. something which works in IO)
05:54:10 <mwc> Well, I've been thinking about the matrix stuff a lot myself recently
05:54:11 <pjd> i think that's what a lot of scipy just does
05:54:15 <augustss> good NAG bindings would be great too
05:54:18 <mwc> that's what I want in Haskell, FORTRAN-grade numerics
05:54:20 <pjd> bindings to the big toolkits
05:54:42 <augustss> the problem with, e.g., NAG, is that it has a *terrible* API
05:55:09 <augustss> so to make it usable from Haskell you'd really have to redesign that first
05:55:20 <Cale> http://users.skynet.be/jyp/HGAL/ -- this is not too exciting to most people, but I think it's pretty cool :)
05:55:31 <lambdabot> Title:
05:55:52 <Cale> It's a small library which does a few things which are quite hard, and it does them well.
05:56:33 <mwc> so far I've gotten it into my head to represent matrices as functions (Int,Int) -> a, that way we can make mult/add operators functions that compute elements efficiently, plus a b = \(x,y) -> (a (x,y)) + (b (x,y)). That's the equivalent of the C++ expression template stuff that Blitz++ does
05:57:06 <Cale> You could also just use Arrays.
05:57:47 <mwc> http://www.oonumerics.org/blitz/benchmarks/ they're using C++ template tricks to get excellent performance
05:57:50 <lambdabot> Title: Blitz++: Benchmarks
05:57:55 <augustss> For fast matrix code probably want to interface to some external library.  And then you don't want to marshal the arrays at all.  that would kill performance.
05:58:13 <mwc> Cale, sure, but you want to use non-matrix things to represent the operations.
05:58:29 <mwc> it's a form of loop-fusion
05:59:41 <mwc> By using templates cleverly, optimizations such as loop fusion, unrolling, tiling, and algorithm specialization can be performed automatically at compile time.
05:59:48 <Cale> It's also possible that the ultimate solution is a combinator library for writing matrix algorithms, together with a 'run' function which compiles the algorithms into appropriate calls to some external library.
05:59:54 <mwc> so I think anything they do with C++ templates we can to with TH and our typesystem
06:00:13 <Cale> We quite likely don't need TH either.
06:01:33 <nomeata> dons: I got the base/ darcs repository, but I can’t seem to build it, it complains about missing ../mk/target.mk
06:01:43 <integral> .oO( an actual useful use for arrows? )
06:02:02 <Cale> integral: indeed, that would be one good option, make it into an arrow library
06:02:12 <Cale> integral: HXT uses arrows *excellently*
06:02:25 <Cale> I've been very impressed by it lately.
06:02:26 <nomeata> dons: I also don’t find the testsuite in there.
06:02:27 <mux> I always found HXT a bit of a mess
06:02:53 * integral goes to read about that
06:02:56 <Cale> mux: well, it's actually somewhat overdocumented, or the documentation is not in the right order, it seems.
06:03:17 <arcatan> Cale: btw, HRSS was quite helpful for me, thanks
06:03:22 <Cale> You only need a small fraction of the stuff that's there to get quite a lot done. :)
06:03:24 <mux> the doc I read was introducing a new arrow every two lines
06:03:32 <mux> and the API has so much symbols
06:03:38 <mux> it made my brain hurt
06:04:10 <Cale> Right, but you can basically ignore that the arrows are even there, and just think about >>> as a non-abstract "then" combinator.
06:04:42 <Cale> occasionally, it's convenient to use the arrow syntax though
06:04:59 <mux> I tried to use HXT in order to do something similar to SAX for parsing XML
06:05:08 <Cale> http://cale.yi.org/index.php/HRSS -- here's an RSS aggregator in ~50 lines, and I'd only been learning HXT for 2 days.
06:05:09 <lambdabot> Title: HRSS - CaleWiki
06:05:10 <mux> so-called event-based parsing
06:05:25 <mux> instead of converting the whole XML document to some tree structure
06:05:30 <mux> it was way too large for this
06:05:42 <integral> "index.php"?  That'd be, umm, personal haskell pages? :-P
06:05:51 <mux> I promptly gave up and moved onto nicer things :)
06:05:57 <Cale> integral: It's a mediawiki
06:06:42 <nomeata> Can someone help me through creating a proper patch against a base library? I darcs got’ base, but I can’t seem to get it compile.
06:06:52 <Cale> Hope looks cool though, I might consider moving to it at some point.
06:07:13 <Cale> lispy: are you around?
06:09:01 <Cale> mux: Could you describe a little more about what you were trying to do?
06:09:59 <Cale> mux: I'm not really sure, but I suspect that HXT is at least somewhat lazy in its conversion of XML into tree structures. (If it's not, it would certainly be possible to fix it so that it was)
06:11:40 <Cale> It seems fast enough to me that any appropriate use of XML should work fine. People do seem to abuse XML quite a bit though.
06:11:41 <mux> Cale: I was just trying to parse the MAME XML game list file
06:11:47 <mux> it's about 45MB IIRC
06:11:52 <Cale> ah, right, and it's stupidly huge
06:11:55 <mux> this was just for training myself with haskell
06:12:16 <mux> so 45MB of XML is waaaay too much to hold into a data structure with haskell
06:12:32 <Cale> yeah, certainly you can't hang on to that all at once
06:12:48 <nomeata> It’s be 360MB even if you just read it into a String :-)
06:12:49 <Cale> If it's having problems with that, it's possible that it's not being as lazy as it could be.
06:12:54 <nomeata> (on a 32 bit platform)
06:12:58 <mux> I had some code that was still trying to do this and was eating several gigs of ram
06:13:05 <mux> not just 360MB :-
06:13:22 <nomeata> Muad_Dib: more than 350MB just reading the file into a String?
06:13:28 <mux> I tried with HaXml and HXT
06:13:31 <nomeata> Muad_Dib: sorry
06:13:41 <nomeata> mux: more than 350MB just reading the file into a String?
06:13:42 <Saizan> maybe you could travel the tree in a way that the previous part can be garbage collected?
06:14:04 <mux> nomeata: no, converting the XML file to an XML tree data structure
06:14:21 <Cale> XML has this annoying property that it has closing tags which have to match. I suspect that representing that in the parser goes a long way to messing up the possibility of working with the data lazily, but there may be a way around it.
06:14:26 <Saizan> s/part/parts/
06:14:42 <Cale> Saizan: I suspect that it should be quite possible to do that.
06:15:02 <yuten> hello
06:15:06 <Cale> In fact, most of the operations in HXT should allow one to free large parts of the tree.
06:15:16 <mux> I admittedly didn't try very hard with this
06:15:20 <Cale> (and if that isn't happening, then something is very wrong)
06:15:28 <yuten> i have a question about monad transformer
06:15:33 <mux> I was quite a haskell noob at that time, I mean, more than I am now, and my brain was hurting
06:15:37 <Cale> yuten: go for it :)
06:15:58 <yuten> newtype ErrorT m a =
06:15:58 <yuten>   MkErrorT (m (Maybe a))
06:15:58 <yuten> newtype OutputT o m a =
06:15:58 <yuten>   MkOutputT (m (a, [o]))
06:16:01 <Cale> I think the main problem is potentially that it's reading the whole tree into memory right away. That would be very bad.
06:16:09 * mux nods
06:16:24 <yuten> and if I define a new type data Debug m a = MkDebug (ErrorT (OutputT [String] m) a)
06:16:38 <Cale> If it used a Data.Sequence to manage the string, and did something like double-ended parsing of the file, it could possibly do the parse lazily.
06:17:25 <nomeata> Cale: What do you mean with double ended? Searching from the start for the opening tags, and from the end for the closing tags?
06:17:32 <Cale> nomeata: yes
06:18:04 <Cale> nomeata: the crucial thing is that parsing happens as parts of the resulting tree are demanded.
06:18:12 <ToRA> Cale: won't that break if you have something like <a><b>...</b><c> 2 million tags </c></a> ?
06:18:12 <mux> does HXT take advantage of Data.ByteString
06:18:17 <yuten> is the content of Debug , m (Maybe a,[String]) or m (Maybe  (a,[o]))
06:18:18 <dylan> Unnamed Ending XML would be nice... <foo><bar>...</></>
06:18:23 <nomeata> Cale: but wouln’d that fail with <some><sibling></sibling><sibling></sibling></some>? It would go all the way from the back to the beginning to find the correct closing tag.
06:18:54 <Cale> ToRA, nomeata: yeah, that's still problematic
06:20:14 <yuten> is anyone got it ?
06:20:27 <Cale> yuten: a value of type ErrorT (OutputT [String] m) a has the form  MkErrorT (MkOutputT (m (Maybe a, o)))
06:20:36 <Cale> er
06:20:45 <Cale> MkErrorT (MkOutputT (m (Maybe a, [String])))
06:20:57 <Cale> but you shouldn't really need to care too much
06:21:12 <Cale> also, OutputT is very similar to WriterT
06:21:52 <Cale> hmm...
06:22:20 <yuten> because OutputT (ErrorT) and ErrorT (OutputT) should make difference meaning
06:22:28 <yuten> i wonder what's the difference
06:23:00 <Cale> yuten: if the OutputT is on the outside, then you'll still get output even if there's an error.
06:23:12 <Cale> er, no, the other way :)
06:24:02 <yuten> Cale: you mean if ErrorT is on the outside, i will get output even if there's error?
06:24:11 <Cale> Output transforming an error transformed monad will mean that only if the computation succeeds will you get output.
06:24:54 <Cale> Error transforming an output transformed monad will mean that you always still get output, but the computation may fail to produce a primary result.
06:26:42 <Cale> I think the way to think about it is in terms of the run functions
06:26:47 <Cale> so you have something like
06:27:11 <Cale> runErrorT :: ErrorT m a -> m (Maybe a)
06:27:30 <Cale> runOutputT :: OutputT o m a -> m (a, [o])
06:27:55 <Cale> If the OutputT is on the outside, then you have to call runOutputT first.
06:28:05 <Cale> So you'll have something like:
06:28:24 <Cale> runErrorT (runOutputT x)
06:29:53 <yuten> thanks Cale, let me think more about it:p
06:30:20 <Cale> runOutputT :: OutputT o (ErrorT m) a -> ErrorT m (a, [o]) -- to specialise the type
06:30:54 <Cale> and then  runErrorT :: ErrorT m (a, [o]) -> m (Maybe (a, [o]))
06:31:14 <Cale> so runErrorT . runOutputT :: OutputT o (ErrorT m) a -> m (Maybe (a, [o]))
06:31:33 <Cale> So if there's an error, you don't get any output.
06:31:53 <Cale> However, if we do things the other way around,
06:32:28 <Cale> runErrorT :: ErrorT (OutputT o m) a -> OutputT o m (Maybe a)
06:32:52 <Cale> runOutputT :: OutputT o m (Maybe a) -> m (Maybe a, [o])
06:33:15 <Cale> so, runOutputT . runErrorT :: ErrorT (OutputT o m) a -> m (Maybe a, [o])
06:33:44 <ms_> does anyone know who moderates the ghc-bugs mailing list?
06:33:53 <Cale> so failure will still allow the output stream to come through
06:34:12 <Cale> yuten: does that help?
06:34:21 <Cale> yuten: the type matching is a little complicated :)
06:35:14 <yuten> let me think a while :p
06:36:22 <syntaxfree> anyone knows how I can find the launch date of a movie?
06:36:28 <Cale> It's really just a matter of figuring out how the variables get instantiated in the types of the run functions, you don't even have to think about how the data are actually represented at all.
06:36:40 <Cale> syntaxfree: maybe ImDB?
06:36:55 <Cale> er, IMDb
06:36:57 <syntaxfree> IMDB only has the year.
06:36:59 <Cale> http://www.imdb.com/
06:37:00 <lambdabot> Title: The Internet Movie Database (IMDb)
06:37:01 <Cale> oh
06:37:01 <Cale> hmm
06:37:02 <syntaxfree> I've just checked it out.
06:37:11 <Cale> Well, have a specific movie in mind?
06:37:40 <Cale> Since you're asking in #haskell, I suspect you don't :)
06:38:13 <ms_> lambdabot may know
06:38:24 <Igloo> The charge of the lambda brigade?
06:38:57 <ms_> Hindley-Milner vs Mycroft: The Good, the Bad, and the Ugly
06:38:59 <ms_> ;-)
06:39:53 <syntaxfree> "An inconvenient truth".
06:39:53 <syntaxfree> I want to run an F-test on whether the trading prices for 2008 dem candidate being Gore increased with the movie launch.
06:42:03 <Cale> Release date(s) 	May 24, 2006
06:42:05 <Cale> http://en.wikipedia.org/wiki/An_Inconvenient_Truth
06:42:07 <lambdabot> Title: An Inconvenient Truth - Wikipedia, the free encyclopedia
06:42:36 <syntaxfree> oh. dummy me.
06:42:37 <yuten> Cale: so when i use monad transformer, i need to consider the run function to indicate what i really want to do ?
06:42:39 <syntaxfree> thanks!
06:43:00 <Cale> yuten: that's usually the easiest way to tell what the difference is when commuting the monads.
06:43:26 <Cale> yuten: sometimes it doesn't indicate everything about how it will change things, but it's usually enough, and it's easy to do.
06:43:32 <nomeata> syntaxfree: what kind of trading prices?
06:43:50 <syntaxfree> nomeata: www.tradesports.com
06:44:19 <yuten> Cale: because i want to make the thinking more intuitively
06:45:21 <Cale> yuten: This is something which is somewhat tricky about monad transformers -- the way that they interact can be complicated, so you usually have to think a little about what order to put them in.
06:45:38 <nomeata> syntaxfree: sounds like betting with an included market for the bets
06:46:14 <syntaxfree> it's futures trading.
06:46:19 <yuten> Cale: hm, thanks a lot~~
06:46:35 <Cale> No problem
06:46:36 <Cale> :)
06:46:41 <syntaxfree> if you buy Gore.2008, if Gore's announced the official candidate, whoever issued the future owes you US$100.
06:46:53 <syntaxfree> So its current price is a probability estimate of sorts, if you assume risk-neutrality.
06:46:58 <syntaxfree> bbl,
06:47:18 <Masklinn> hello again
06:47:31 <paolino> hi , is there difference between  "let ... in do ..." and "do let  .."?
06:47:45 <Cale> paolino: no, the latter is translated into the former
06:48:05 <Cale> (as part of do-desugaring)
06:51:11 <paolino> ok, so what ever is defined with no dependencies  on the "after do" bindings should go before do for cleanness
06:51:34 <nomeata> syntaxfree: sounds interesting, but dangerous :-)
06:54:10 <dylan> I am perhaps a very inefficient programmer...
06:54:49 <dylan> autolisp has no tail recursion, and no way of exiting from a function early... no exceptions and not even a return construct.
06:55:09 <dylan> and no continuations. so I just spent about 2 hours trying to emulate continuations...
06:56:12 <Cale> No way of exiting from a function early makes it sound like there's no flow control whatsoever.
06:56:19 <Cale> It doesn't have if?
06:56:34 <dylan> well
06:56:44 <dylan> no way of exitiing from inside its while construct
06:56:52 <Cale> ah, okay
06:57:04 <dylan> (while (cond) ...) -- and I am using that since I have no tailrecursion
06:57:35 <Cale> ew, it's dynamically scoped
06:57:48 <dylan> yes, it is indeed.
06:58:05 <dylan> local variables are declared as unused arguments...
06:58:09 <Cale> It has mutable variables?
06:58:23 <dylan> yeah.
06:58:30 <pjd> isn't pascal like that too?
06:58:36 <dylan> I didn't even think of mutating a variable to stop while
06:58:48 <dylan> until just now. XD
06:58:50 <Cale> yeah, that's what I was going to recommend
06:59:04 <Cale> ugly, but it'll work
06:59:12 <dylan> My brain's like "What, wait. state? what's that?"
07:00:51 <dylan> what's really fun is looking attributes in an autocad drawing has to be O(n)..
07:01:13 <dylan> despite being in an actual hash table.
07:03:57 <paolino> can I mix pattern matching and guards ?
07:07:59 <Cale> paolino: yes
07:08:20 <Cale> dylan: wow
07:08:54 <pjd> is [] naturally a comonad?
07:09:53 <syntaxfree>  nomeata: anyway, I'm not *trading* there, I'm just using the price series as information.
07:11:23 <Cale> pjd: not quite. Nonempty lists are.
07:11:48 <pjd> right :)
07:13:47 <ivans> http://attachr.com/5643 -> why do I get a strange error message for this on GHC 6.8? (copy/pasted from "Yet another haskell tutorial", p59)
07:14:57 <nomeata> syntaxfree: ah, ok :-)
07:15:23 <pjd> Cale: how would you define the duals of return and join?
07:15:27 <nomeata> syntaxfree: would be interesting to have a geek version. Will debian release before new years eve? Will ghc6.8 support utf8 encodings?...
07:15:44 <kpreid> ivans: functions must start with lowercase letters.
07:16:00 <pjd> aka extract and duplicate
07:16:06 <kpreid> ivans: you must not have actually copied it, or something mangled it along the way, because the example is correctly capitalized
07:16:10 <syntaxfree> nomeata: guys with private information would reap unduly profit.
07:16:15 <ivans> aah, tnx
07:16:30 <ivans> mea culpa
07:16:32 <syntaxfree> you'd have to forbid the entire development teams from participating, and they could still leak info.
07:16:55 <syntaxfree> moreover, you risk future speculation influencing actual development courses.
07:17:06 <pjd> Cale: ah, wait, they're just swapped?
07:17:09 <nomeata> syntaxfree: isn’t that the problem with all of these bets? inner party members know better who’s going to be the candidate.
07:17:12 <Cale> pjd: extract just takes the first element
07:17:30 <Cale> duplicate is essentially tails
07:17:39 <syntaxfree> nomeata: well, sure. But they can't influence it for sure. It's a voting inside the party.
07:17:40 <Cale> starting with the full list, and working down
07:17:50 <nomeata> syntaxfree: actually, debian is doing that already, member guess the release date and whoever comes closest get’s beers from the others
07:18:00 <nomeata> syntaxfree: that’s true
07:18:00 <syntaxfree> nomeata: so basically the futures market gives them an incentive to reveal some of their information.
07:18:38 <syntaxfree> creepy info: the S&P 500 index took a plunge on November 10th, 2001.
07:18:46 <pjd> Cale: oh; but aren't there other ways to define them?
07:19:26 <nomeata> syntaxfree: what about weather? the wather labs know the predictions before the others, so they know whether prices will go up or down during their forecast and make money off that, can’t they?
07:19:52 <Cale> pjd: probably, yes
07:19:55 <syntaxfree> yes. but weather prediction sucks.
07:20:05 <syntaxfree> weather prediction was invented to make econometricians look good.
07:20:06 <nomeata> syntaxfree: true :-)
07:20:12 <Cale> maybe inits will work too
07:20:31 <paolino> why I get sxntax error on "{" ?
07:20:32 <paolino> newtype (Cursor l g a) => Path l g a = Path [l g a -> l g a] {unPath :: [l g a -> l g a]} --injectable functional path
07:20:44 <Cale> so long as the first element of the duplicate is the original list
07:21:18 <Cale> paolino: because something is either entirely a record type, or entirely not
07:22:52 <paolino> Cale , I can't understand your answer, what is a record type ?
07:23:09 <Cale> I just mean using record notation
07:23:11 <pjd> Cale: do those definitions correspond to alternate definitions of the list monad too?
07:23:27 <pjd> or are they asymmetric?
07:23:45 <Cale> pjd: not in any way that I know of
07:24:13 <Cale> There might be adjunctions behind them, where you get the list monad and comonad out of one adjunction.
07:24:16 <paolino> Cale do I have to eliminate something there ?
07:24:19 <Cale> But I haven't looked at it.
07:24:30 <Cale> newtype (Cursor l g a) => Path l g a = Path {unPath :: [l g a -> l g a]}
07:24:39 <Cale> paolino: does that seem reasonable?
07:25:52 <paolino> yes
07:26:19 <paolino> you mean I mixed the notations
07:26:25 <Cale> paolino: you should be aware that putting the Cursor l g a there will not actually save you from any typing later on. It just makes sure that when you construct and deconstruct paths, you have an instance of Cursor handy (which usually means that the type of the function you're doing this in has a class constraint on it)
07:27:35 <Cale> If you want the instance of Cursor to be carried around with the data, you can get this in newer GHC 6.7's by using a data declaration with the new GADT-style syntax.
07:27:58 <Cale> (but it's not possible in older GHCs or other compilers/interpreters)
07:28:29 <moonlite> has anyone here ever constructed a Miller-Rabin primality test in Haskell? I see a lot of imperative pseudo-code around and don't know how to map it to functional code.
07:28:45 <glguy> yeah, I'll get you the link
07:28:56 <pjd> it's weird that the list monad and comonad operations are so disparate
07:29:31 <SamB_XP> hmm, where is my nuclear power plant discussion?
07:29:48 <Cale> Well, the similarity between monads and comonads ends at a fairly abstract level.
07:29:52 <glguy> http://www.polyomino.f2s.com/david/haskell/numbertheory.html
07:29:54 <lambdabot> Title: Basic Number Theory in Haskell
07:29:59 <Cale> On a concrete level, they're quite different things.
07:30:22 <moonlite> glguy: thx a lot! :)
07:30:23 * glguy wonders how it can be that the primes.hs link is broken today
07:30:29 <Cale> Usually, reversing all the arrows in some diagram causes what you're defining to become very different.
07:30:33 <moonlite> heh doh :)
07:30:33 <SamB_XP> the "co" sort of implies that they are near opposite
07:30:34 <glguy> http://72.14.203.104/search?q=cache%3Ahttp%3A%2F%2Fwww.polyomino.f2s.com%2Fdavid%2Fhaskell%2Fhs%2Fprimes.hs.txt&ie=utf-8&oe=utf-8&rls=org.mozilla:en-US:official&client=firefox-a
07:30:36 <lambdabot> http://tinyurl.com/swesu
07:30:42 <Cale> As different as disjoint union and cartesian product.
07:30:47 <glguy> moonlite: there is the google cache of primes.hs
07:30:52 <pjd> Cale: well, i have an basic intuitive understanding of how they mirror each other
07:31:15 <pjd> after reading sigpfe's stuff
07:31:16 <Cale> You can't quite hope that the arrows are inverses of one another.
07:31:26 <SamB_XP> what is a coarrow?
07:31:40 <Cale> SamB: an arrow pointing in the opposite direction
07:32:18 <Cale> oh, perhaps you mean a co-Arrow :)
07:32:19 * SamB_XP almost always thought the pure method belonged somewhere besides the Arrow class
07:32:19 <moonlite> glguy: ah double-thx
07:32:23 <SamB_XP> Cale: yes.
07:32:27 <paolino> Cale, I take away the context, as I'm using ghc 6.4 and can't really pick your hint, with my knowledge :X
07:32:28 <SamB_XP> is the answer the same?
07:32:57 <Cale> hmm, that's a more complicated question
07:33:17 <SamB_XP> perhaps I was only punning
07:33:22 <Cale> I'd suspect you'd have  copure :: (b -> c) -> a c b
07:33:42 <SamB_XP> um, I don't really think pure belongs in the Arrow class
07:33:47 <Cale> Why?
07:33:50 <glguy> ew, digg got a new skin
07:33:58 <SamB_XP> well, biarrows for one
07:34:35 <Cale> The pure method is the only thing which attaches the arrow to its type parameters
07:34:56 <Cale> Without it, they're just phantom types.
07:35:11 <Cale> (or at least, might be)
07:39:29 <Cale> So if you want to define a Hughes arrow over a category (as a sort of bifunctor), it's important to have pure in the definition, or it might have no bearing at all on the original category, just mapping the objects of the original category wherever with no relationship between >>> and composition, and so on.
07:41:20 <Cale> well, hmm... would you advocate including ^>> and friends?
07:41:46 <Cale> that might be enough structure to keep things meaningful
07:42:15 <Cale> (they come along with the bifunctoriality)
07:42:33 <Cale> without even those, then it starts to lose meaning
07:48:09 <wy> I need a way to limit the memory that the interpreter uses. It crashed my machine just now, possibly by an infinite loop!
07:48:28 <fasta> wy: You need a better OS.
07:48:36 <glguy> ?type (^>>)
07:48:38 <lambdabot> forall d b (a :: * -> * -> *) c. (Arrow a) => (b -> c) -> a c d -> a b d
07:48:56 <glguy> wy: what OS. fasta: what OS causes that problem?
07:49:47 <fasta> glguy: There exist OS's that are designed to withstand any user-space attack.
07:50:02 <wy> I'm using Ubuntu Linux
07:50:16 <fasta> glguy: So, apparently his doesn't support those.
07:50:52 <glguy> fasta: crashing doesn't mean that the OS failed to prevent a userspace attack...
07:50:58 <wy> I think it's friendlier to set limit in the interpreter
07:51:10 <fasta> A more likely explanation is that wy thinks his machine crashed, while in fact it didn't.
07:51:16 <glguy> heh
07:51:20 <glguy> fair enough
07:51:57 <fasta> glguy: I know, but that's the worst case scenario an OS can and should reasonably face.
07:52:17 <wy> fasta: But it stops responding, it's equivalent to a crash. Once before my X server locks my keyboard and mouse. That's equivalent to crash too.
07:52:27 <fasta> wy: no, I don't agree.
07:52:40 <fasta> wy: It only slowed down, I think.
07:52:51 <velco> such limits are administration policy, thus it;s inappripriate to rely on the user put them in his/her interpreters
07:52:55 <fasta> wy: Did you try e.g Control+Alt+F1?
07:52:57 <velco> see ullimit
07:53:11 <fasta> ulimit
07:54:49 <fasta> You should file a bug, if you can reproduce it, imho.
07:54:58 <wy> I tried. But it's too slow to respond. If it'll take me one hour to recover, I'd rather reset the machine
07:55:17 <fasta> wy: can I run that program too?
07:55:29 <fasta> wy: or does it contain hyper-sensitive material?
07:56:44 <wy> I remember there is an option that can limit the heap size of the interpreter?
07:58:00 <fasta> wy: what program are you talking about?
07:58:07 <fasta> wy: There are multiple interpreters
07:58:09 <wy> It's not sensitive, but it's a bit inconvenient to package it
07:58:17 <wy> say ghci
08:01:16 <fasta> wy: I know such options are available in ghc(documented), but I don't know for ghci. I would report the issue to Ubuntu, though.
08:01:47 <wy> fasta: In fact you can crash any linux machine without ulimit
08:01:58 <fasta> wy: I know
08:02:05 <fasta> wy: It's a flaw
08:02:37 <fasta> wy: Although, you might know a different way than the one I am thinking of. Which way?
08:03:07 <wy> fasta: What's the option's name to the ghc?
08:05:00 <fabiim> how do I keep a String from a file
08:05:06 <fabiim> ?
08:05:17 <fabiim> i mean , keep it in type String
08:05:24 <fabiim> not IO String
08:05:53 <glguy> You usually don't want to do that
08:06:02 <glguy> What are you trying to do?
08:06:20 <fasta> wy: +RTS -M128m  ,IIRC
08:06:46 <glguy> fabiim: (if you are working in do-notation, then you have have a line: a <- readFile "filename"
08:06:57 <glguy> fabiim: that will run the readFile action, and assign the result to a
08:07:00 <syntaxfree> http://mpra.ub.uni-muenchen.de/856/
08:07:00 <Baughn> fabiim: You can't get a String from an IO String, but you /can/ use a function String -> whatever on it. do-notation makes that ever so easy
08:07:04 <lambdabot> Title: Munich Personal RePEc Archive - The social norm of leaving the toilet seat down: ...
08:07:08 <fabiim> well I want to have a file with words , and I want to pick 6 random words from it . So I'm trying to get the string of the file to work on it .
08:07:36 <syntaxfree> fabiim: that's not what you do.
08:07:47 <syntaxfree> you write all your functions as if you had your string in the haskell environment.
08:07:55 <fabiim> yeah I get that , I can do whatever I want inside do . But then it return only IO's
08:08:08 <syntaxfree> no, no.
08:08:11 <Baughn> fabiim: I suggest reading http://haskell.org/haskellwiki/Introduction_to_IO
08:08:12 <lambdabot> Title: Introduction to IO - HaskellWiki
08:08:25 <syntaxfree> You write your functions as if you weren't going to work withj IO Strings.
08:08:28 <wy> fasta: Thanks. Is there a way to set this inside a running ghci?
08:08:34 <syntaxfree> *then* you use
08:08:47 <syntaxfree> main = getFile "yadda" >>= yourfunctions >>= putStr
08:08:50 <fasta> wy: I don't think it works like this in ghci
08:08:58 <fasta> wy: you should just use ulimit to be sure
08:09:00 <glguy> syntaxfree: that would only work if his function was in IO
08:09:09 <syntaxfree> er, yes.
08:09:11 <glguy> (unless that is what you meant)
08:09:12 <syntaxfree> my bad :)
08:09:16 <fasta> wy: but what was that way to crash Linux?
08:09:23 <syntaxfree> main = getFile "yadda" >>= putStr . yourfunctions
08:09:32 <fasta> wy: fork bomb?
08:09:35 <Cale> main = interact yourFunctions
08:09:43 <Cale> If you have anything that simple :)
08:09:48 <fabiim> yes but then it will return IO String .
08:09:50 <Cale> @type interact
08:09:52 <lambdabot> (String -> String) -> IO ()
08:09:58 <wy> fasta: something wrong with my program. I'm yet to find the bug
08:09:59 * syntaxfree thinks the standard prelude should have a function "munge f = getContents >>= putStr . f"
08:10:11 <Cale> syntaxfree: interact
08:10:13 <glguy> syntaxfree: interact
08:10:20 <syntaxfree> interact is exactly that?
08:10:20 <Cale> yes
08:10:26 <syntaxfree> cool.
08:10:27 <russo> interact: syntaxfree
08:10:29 <fabiim> so imagine I read the string from the file , I make my funtions on that string , got the 6 random words , everythings ok...
08:10:30 <Cale> hehe
08:10:30 * glguy prefers =<< when combined with .
08:10:58 <glguy> fabiim: you'll want to read that article introducing IO in Haskell
08:10:58 <fabiim> but then I get a IO String , and to play around that String all my other functions got to be inside IO's
08:11:03 <Cale> fabiim: by random, do you mean that you're going to need a random number generator?
08:11:08 <fabiim> yeah i think it's better
08:11:08 <fabiim> =)
08:11:10 <fabiim> lol
08:11:11 <syntaxfree> glguy: it'd be even more natural if you had (&) = flip (.)
08:11:37 <syntaxfree> munge f = getContents >>= f & putStr
08:11:47 <fabiim> yeah , I'll pick 6 random number and take those 6 elements from the list of words that belong to the file
08:11:58 <Cale> fabiim: the important thing to remember is that an (IO String) is not very much like a String at all -- it's a process which when run, will produce a String each time.
08:12:05 <glguy> interact f = putStr . f =<< getContents -- my fav ;)
08:12:32 <earthy> whoa
08:12:33 <Cale> So you probably want to get those random numbers in IO as well.
08:12:42 <earthy> swiert @ science.ru.nl?!
08:12:55 <syntaxfree> fabiim: you have to separate concernsw.
08:12:58 <glguy> earthy: share the amazing stuff with everyone plz :)
08:13:03 <fabiim> so , to work on IO's put everything on IO right?
08:13:06 <syntaxfree> producing a list of words from a list of indexes and a string is a concern.
08:13:13 <syntaxfree> producing a list os six random numbers is another concern.
08:13:14 <earthy> glguy: I thought swiert was in .uk rather than in .nl
08:13:25 <syntaxfree> then you put those two together.
08:13:26 <glguy> ah
08:13:34 <syntaxfree> rather than have them interspersed all through your code.
08:13:46 <pjd> Cale: i think i understand!
08:13:51 <Cale> main = do { xs <- fmap words getContents; ns <- replicateM 6 (randomR (0,length xs - 1)); print (map (xs !!) ns) }
08:14:06 * syntaxfree is wondering if monads implement aspect-oriented programming now. 
08:14:13 <Cale> there's a program which should pick 6 random words from a file
08:14:20 <Cale> er, from standard input
08:14:26 <fabiim> fmap , replicateM ?
08:14:31 <dylan> someone needs to make a song about monads, at least as a filk on the mandelbrot set song...
08:14:38 <glguy> *whosh*
08:14:40 <Cale> fmap just applies a function to the result of a computation
08:14:43 <Cale> @type fmap
08:14:45 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
08:14:53 <Cale> I apologise for the gibberish
08:14:57 <fabiim> lolol =)
08:14:59 <syntaxfree> @type mapM
08:15:00 <Cale> (a -> b) -> IO a -> IO b
08:15:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
08:15:10 <Cale> there's the basic idea there
08:15:18 <dylan> ("Pathological Monads, cried the terrified mathematician...")
08:15:31 <Cale> You're taking a computation which computes an a and applying a function from a's to b's to its result.
08:15:33 <syntaxfree> fmap isn't really a map, unless Functor f is [[.
08:15:37 <syntaxfree> er, []
08:15:41 <fabiim> well better start slow , i'm going to read that Introduction file . Be here later asking more =) thanks
08:15:44 <Cale> okay
08:15:45 <glguy> fabiim: Cale's just giving you a taste of what's to come
08:15:52 <Cale> Well, I can avoid that use of fmap
08:16:00 <fabiim> lol
08:16:17 <Cale> main = do { xs <- getContents; let ws = words xs; ns <- replicateM 6 (randomR (0,length ws - 1)); print (map (ws !!) ns) }
08:16:38 <vincenz> Anyone know how to show BNF in latex.  The ::= is not so much an issue as the vertical bar
08:16:58 <syntaxfree> @type repiate
08:16:58 <Cale> replicateM n x just takes the computation x and chains n of it end-to-end, producing a computation which returns a list of the results.
08:16:59 <lambdabot> Not in scope: `repiate'
08:17:04 <syntaxfree> @type replicate
08:17:05 <lambdabot> forall a. Int -> a -> [a]
08:17:15 <syntaxfree> @type replicateM
08:17:16 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
08:17:24 <syntaxfree> @type liftM
08:17:24 <vincenz> anyone know what latex code is used for the | bar in a data type declaration
08:17:26 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
08:17:34 <glguy> > replicateM 3 [1..3]
08:17:36 <lambdabot>  [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2,...
08:17:37 <Cale> liftM is the same thing as fmap
08:17:37 * syntaxfree wins.
08:17:37 <vincenz> (when generating latex from literate haskell)
08:17:42 <syntaxfree> almostt.
08:17:44 <Cale> but it has a more restrictive type
08:18:01 <syntaxfree> liftM is fmp for monads, yes.
08:18:01 <glguy> and uses more letters
08:18:06 <Cale> (that's the only difference)
08:18:12 <syntaxfree> I like liftM better.
08:18:25 <paolino>     Warning: No explicit method nor default method for `average'
08:18:27 <paolino>              In the instance declaration for `Graph Node a'
08:18:27 <paolino> Is this correct to give such warning ? Graph Node a is incomplete, one is obliged to have  all methods implemented only for a complete type ?
08:18:28 <syntaxfree> fmap makes me think wrong thoughts.
08:18:46 <wy> fasta: Where should I put the ulimit? I used ulimit -d 1024 before ghci. It seems ghci is still using a lot of memory.
08:18:49 <fasta> Cale: wouldn't it be a lot more efficient to ask the file system how long a certain file is and the use random access IO to get specific positions?
08:19:13 <glguy> what would that tell you about how many words are in the file?
08:19:39 <sjanssen> paolino: the type is complete the warning says an instance is incomplete
08:19:41 <syntaxfree> glguy: wc -l  !  **rimshot*
08:19:50 <syntaxfree> er, wc -w
08:19:57 <Cale> fasta: um, I suppose you could, it would be needlessly ugly though
08:20:04 <fasta> wy: It would help it you would read the manuals
08:20:05 <glguy> syntaxfree: Oh, so write it as a shell script instead of a Haskell program?
08:20:15 <Cale> you'd end up scanning backward and forward from the position that you found
08:20:16 <syntaxfree> I know, I know :)
08:20:33 <fasta> Cale: No, random IO is just not what lazyness gives you.
08:20:38 * glguy thought that Ubuntu was Linux for everybody... what's this business of manually configuring ulimits
08:20:41 * syntaxfree carelessly mentions genetic algorithms, just for poseur value.
08:20:41 <sjanssen> paolino: if you attempt to call average on a Graph Node a, you will get a runtime error
08:20:45 <Cale> fasta: hm?
08:20:52 <paolino> sjanssen: Can't I implement average for Graph Node Float  different from Graph Node String ?
08:21:10 <Cale> fasta: Remember the problem is 6 random words, not 6 random characters.
08:21:30 <fasta> Cale: you should write programs that are traditionally buffer based programs with lazyness.
08:21:34 <sjanssen> paolino: maybe, but I have no idea which class you are using, or what Graph is
08:21:43 <Cale> so you need to know how many words there are in the file in order to start to generate a random number
08:21:45 <fasta> Cale: and where do the words come from?
08:21:53 <fasta> Cale: from the file?
08:21:56 <Cale> yes
08:22:11 <Cale> whitespace separated tokens
08:22:18 <paolino> sjanssen: and in different modules than the rest of the Graph Node a implementation
08:22:26 <sjanssen> paolino: if the code is reasonably sized, feel free to paste it and I'll take a look
08:22:33 <fasta> Cale: ok, if you need to scan the whole input anyway, then it makes sense.
08:22:37 <glguy> fasta, I've got a file of size "175 byte", how many worsd are in it
08:22:41 <Cale> If you generate a random position in the file based on the number of characters in the file, you'll give priority to longer words.
08:23:52 <fasta> That's still random, right? Just not with uniform probability ;)
08:23:55 <Cale> Besides, never do something which is going to be harder to program but might be more efficient until you've actually written the thing the easy way and found that it's too slow :)
08:24:00 <Cale> well, sure
08:24:32 <fasta> glguy: it could be that that was already known.
08:26:07 <syntaxfree> fasta: it could also be that the file has exactly 6 words.
08:26:14 <syntaxfree> then main = getContents >>= putStr
08:26:46 <Cale> interact id :)
08:26:47 <glguy> or it could be the stdin
08:27:38 <syntaxfree> I wish I had a simple GUI for stdin -> stdout programs.
08:27:50 <glguy> ?
08:27:57 <glguy> it's called "XTERM" :)
08:28:00 <syntaxfree> I write these text filters people find useful, but they shriek in terror when presented to a terminal.
08:28:16 <syntaxfree> I'd like to have a GUI with one box where they can paste input, a GO button and a box with the output.
08:30:19 <Cale> syntaxfree: it's easy enough to write a simple Gtk2Hs wrapper that does that
08:30:38 <syntaxfree> I tried to install wxHaskell, to no avail.
08:31:00 <syntaxfree> gtk apps look foreign to Windows and OS X.
08:31:19 <Cale> They do? They usually look pretty similar to windows apps on windows.
08:31:26 <Cale> I don't know about on OS X.
08:32:04 <moonlite> Cale: they look pretty foreign on macosx i think, but work is being done in that area i belive
08:32:26 <glguy> ‹‹ works well on Reddit(fyi)
08:32:35 <glguy> along with ←
08:32:57 <Cale> http://glade.gnome.org/screenshots.html -- one of the screenshots shows glade running on win32
08:32:58 <lambdabot> Title: Glade - Screenshots
08:33:12 <syntaxfree> well, on screenshots, yes, but behaviour is still odd.
08:33:23 <syntaxfree> I'd rather use wx, but it Just Doesn't Work.
08:33:36 <Cale> How is the behaviour any different?
08:33:58 <Cale> The controls themselves are pretty close to the same ones which you have under windows.
08:34:08 <syntaxfree> in a myriad subtle ways :)
08:34:15 <Cale> Buttons, menus, tabs and such
08:34:19 <syntaxfree> I've worked for an entire year with Gretl on Windows.
08:34:26 <syntaxfree> when I was a research assistant.
08:34:54 <syntaxfree> With time, you get used to the quirks, and they shouldn't be important in an app with two text boxes and a button, but if I'm gonna invest time in learning a GUI toolkit, I should learn one that works.
08:35:52 <moonlite> syntaxfree: gtk then, since wx didn't work? ;)
08:36:07 <Cale> I think Gtk2Hs and WxHaskell are the only really practical options for GUI programming in Haskell at the moment.
08:36:08 <syntaxfree> hehe.
08:36:24 <syntaxfree> yes. I wish I could get wx to compile. I basically gave it up.
08:36:24 <Cale> If you only care about Win32, you could use the Win32 api directly.
08:36:36 * syntaxfree 's on OS X, actually.
08:36:44 <ozone> syntaxfree: wx on windows is great, dunno about wxhaskell though...
08:36:45 <Cale> Gtk2Hs is much better maintained than WxHaskell is.
08:37:27 * allbery_b saw mail over the weekend which may get him to make one last try at wxhaskell, but neither one built for him on past attempts
08:37:43 <Cale> I've usede wxHaskell a little in the past.
08:37:47 <Cale> -e
08:37:56 <Cale> But not for anything too large.
08:37:57 <earthy> come and get it: http://www.cs.uu.nl/~arthurvl/haskell.vba
08:38:09 <earthy> ftplugin for haskell for vim
08:38:11 <allbery_b> ...maybe Gtk2HS works from darcs, but I can't sanely upgrade auto* on work machines, so...
08:38:21 <earthy> with very rudimentary folding
08:38:25 <syntaxfree> @type when
08:38:27 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:38:30 <syntaxfree> oh. useful!
08:38:42 <earthy> and <LocalLeader>t support to get a type signature
08:39:57 <syntaxfree> ezone: oh, yes. I should say that WxWidgets itself compiled in a snap.
08:40:01 <syntaxfree> No errors.
08:40:05 <syntaxfree> WxHaskell is the showstopper.
08:43:18 <Cale> The π-calculus has also attracted interest in molecular biology. In 1999, Aviv Regev and Ehud Shapiro showed that one can describe a cellular signaling pathway (the so-called RTK/MAPK cascade) and in particular the molecular "lego" which implements these tasks of communication in an extension of the π-calculus.
08:43:21 <Cale> Interesting :)
08:44:48 <syntaxfree> what does "calculus" mean anyway?
08:45:27 <Excedrin> "logic system"
08:46:17 <Cale> syntaxfree: means of calculating
08:46:52 <syntaxfree> differential calculus is by no means a logic system. what do differential calculus and lambda calculus have in common?
08:47:12 <Excedrin> nothing, there's two different meanings
08:47:55 <fasta> glguy: is the UTF-8 <- also recognized by GHC?
08:47:55 <tora> is ghc -fglasgow-exts supposed to understand unicode lambda as \ or just as a variable?
08:48:15 <glguy> fasta: I don't think so... but neither is &lt; (=
08:48:51 <Excedrin> syntaxfree: look at this http://mathworld.wolfram.com/Calculus.html
08:48:52 <lambdabot> Title: Calculus -- from Wolfram MathWorld
08:49:48 <syntaxfree> "In general, "a" calculus is an abstract theory developed in a purely formal way."
08:49:58 <syntaxfree> spectral theory for linear operators is a calculus?
08:51:39 <Cale> syntaxfree: they're both mechanisms for calculation
08:51:51 <Cale> That's the original sense of the word "calculus"
08:51:54 <Excedrin> http://mathworld.wolfram.com/LambdaCalculus.html
08:51:56 <lambdabot> Title: Lambda Calculus -- from Wolfram MathWorld
08:52:19 <Cale> Differential calculus is a set of mechanisms for calculating derivatives.
08:52:37 <Cale> Though we often use the term now to mean the entire branch of analysis involved with that.
08:53:29 <syntaxfree> calculus is generally mathematical analysis sans proofs, and vice-versa.
08:55:00 <Cale> Well, but that's not how it's taught. At least, not where I went to university.
08:55:14 <LPhas> ?paste
08:55:15 <lambdabot> http://paste.lisp.org/new/haskell
08:55:35 <lisppaste2> phas pasted "Id3 support coming soon!" at http://paste.lisp.org/display/32799
08:55:45 <syntaxfree> I had an odd calculus course, with some weeks of useless noodling about metric spaces and suchlike.
08:56:22 <LPhas> :D
08:58:14 <Cale> My three calculus courses were very much about proofs, and contained basically all of the analysis necessary to properly justify the calculus being done.
08:58:37 <Cale> We spent basically the first half of calculus 1 studying sequences of real numbers.
08:59:21 <Cale> LPhas: cool
09:00:26 <LPhas> now i hate C :P
09:00:29 <dylan> hmm, I'm trying to figure if this  lisp's mapcar is the same a map....
09:00:38 <glguy> it is
09:00:47 <dylan> ah, good.
09:01:03 <dylan> my predecesor apparently found it easier to use a while loop and 10 mutable variables....
09:01:52 <SamB_XP> but, you need to use them like...
09:02:22 <SamB_XP> (mapcar #'f [blah]) ;; ?
09:02:33 <SamB_XP> (or is that a macro?)
09:02:36 <deadbeef> amici :*
09:02:38 <glguy> (mapcar #'f '(1 2 3))
09:02:53 <jacobian_> I have a computation that can fail
09:03:01 <SamB_XP> jacobian_: that is pretty typical
09:03:04 <jacobian_> should I use the error monad with the state monad?
09:03:07 <glguy> spectacularly?
09:03:15 <jacobian_> yeah, spectacularly
09:03:19 <jacobian_> totaly failure
09:03:28 <glguy> with desciptive message?
09:03:30 <glguy> or without
09:03:40 <jacobian_> actualy it doesn't matter
09:03:50 <glguy> if it doesn't matter, just use Maybe
09:03:59 <jacobian_> I just want (>>=) fail _ = fail
09:04:02 <Cale> dylan: Programmers of older lisps are very imperative.
09:04:14 <glguy> > fail "" :: Maybe ()
09:04:15 <lambdabot>  Nothing
09:04:19 <Cale> Even common lisp doesn't seem to completely embrace functional programming
09:04:28 <dylan> Cale: I don't think this fellow as a programmer.
09:04:29 <glguy> > fmap (*2) Nothing
09:04:31 <lambdabot>  Nothing
09:04:40 <SamB_XP> > runState (fail "ack!") ()
09:04:42 <lambdabot>  Add a type signature
09:04:47 <SamB_XP> > runState (fail "ack!") () :: ()
09:04:48 <lambdabot>  Couldn't match `()' against `(a, s)'
09:04:56 <SamB_XP> > runState (fail "ack!") () :: ((),())
09:04:58 <lambdabot>  Exception: ack!
09:05:03 <jacobian_> ;)
09:05:05 <dylan> Cale: there's some VB code too, and he implements three classes to perform a string split
09:05:16 <glguy> jacobian_: Maybe a is a computation that might return an a, or it might return Nothing
09:05:17 <SamB_XP> > runState (fail "ack!" >> return ()) () :: ((),())
09:05:18 <lambdabot>  Exception: ack!
09:05:19 <Cale> dylan: hehe
09:05:29 <dylan> (one for splitting on commas, one for periods, and on for slashes)
09:05:31 <SamB_XP> jacobian_: looks like you don't need to do anything special for *that*
09:05:32 <dylan> I am not joking.
09:05:40 <Cale> dylan: well, look at the Haskell prelude
09:05:45 <Cale> @type words
09:05:46 <lambdabot> String -> [String]
09:05:50 <Cale> @type lines
09:05:51 <lambdabot> String -> [String]
09:05:55 <Cale> and no general splitter
09:06:11 <lenbit> vrt desu ka?
09:06:16 <Cale> but yeah, it's a crime :)
09:06:16 <lenbit> hai, vrt desu
09:06:22 <dylan> Cale: a function is cleaner than a class!
09:06:29 <Cale> oh, that's also very true
09:06:34 <Cale> why classes?
09:06:52 <Cale> Are they classes with single static methods in them?
09:07:07 <SamB_XP> > lines "hello\r\nworld"
09:07:09 <lambdabot>  ["hello\r","world"]
09:07:30 <SamB_XP> > lines "hello\r\nworld\r\n"
09:07:31 <lambdabot>  ["hello\r","world\r"]
09:07:34 <SamB_XP> hmm.
09:07:41 <SamB_XP> > lines "\r\nhello\r\nworld\r\n"
09:07:43 <lambdabot>  ["\r","hello\r","world\r"]
09:07:48 <glguy> > lines "hello\n\rhello" -- just for grins
09:07:49 <SamB_XP> > words "\r\nhello\r\nworld\r\n"
09:07:50 <lambdabot>  ["hello","\rhello"]
09:07:51 <lambdabot>  ["hello","world"]
09:08:05 <SamB_XP> hmm.
09:08:09 <SamB_XP> what is the general case, again?
09:08:23 <SamB_XP> that is, what function do you use to implement both words and lines?
09:08:27 <Cale> there is no general case
09:08:31 <Cale> which is what is silly
09:08:43 <SamB_XP> no, I mean, implement me this function
09:08:46 <Cale> oh
09:08:47 <LPhas> ?seen dcoutts
09:08:47 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
09:08:59 <LPhas> ?seen dons
09:08:59 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 3h 54m 8s ago.
09:09:11 <SamB_XP> or at least figure out what its type signature would be
09:09:56 <LPhas> it's only me or xerox is vanished?
09:10:10 <edi> *p0f*
09:10:28 <glguy> ?seen xerox
09:10:28 <lambdabot> Last time I saw xerox was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.hac07, #jtiger, #oasis, #perl6, #scannedinavian and #unicycling
09:10:29 <lambdabot> 5d 16h 35m 52s ago, and .
09:10:31 <edi> <-
09:10:33 <LPhas> oh
09:10:36 <LPhas> :P
09:10:43 <edi> what a luck! (:
09:10:52 <LPhas> why did you change nick?
09:10:58 <Cale> @let splitOn p xs = case break p xs of (us, []) -> [us]; (us, v:vs) -> us : splitOn p vs
09:10:59 <lambdabot> Defined.
09:11:28 <Cale> lines = splitOn (=='\n'); words = splitOn isSpace
09:11:49 <edi> Part of a bigger plan.
09:11:58 <Cale> er, that won't behave exactly like those
09:12:19 * SamB_XP wonders if there is an RSS feed of Oleg posts
09:12:25 <Cale> well, words needs some work
09:12:38 <Cale> because it removes interior empty words
09:12:43 <sorear> > let splitBy = groupBy . (const .) in splitBy isSpace "Hello  world, this is a teststring "
09:12:44 <lambdabot>  ["H","e","l","l","o","  world, this is a teststring "]
09:13:15 <SamB_XP> edi: like you are going to change your name too?
09:13:21 <ph8> hey guys, i'm reading in from a file - i can read in say, program.lhs fine as it doesn't contain 'illegal' character - how do i escape the input from readFile though?
09:13:28 <ph8> when i try to read in an e-book example it says "illegal characters"
09:13:33 <ph8> perhaps not a direct quote :p
09:13:33 <edi> SamB_XP: nope.  BTW Oleg has got an RSS feed.
09:13:42 <Cale> edi: trying to avoid someone?
09:13:45 <SyntaxNinja> w00t
09:13:47 <edi> Cale: no.
09:13:49 <SamB_XP> edi: of the emails he sends?
09:13:50 <sorear> perhaps the input contains invalid UTF8?
09:14:06 <edi> SamB_XP: his mails are his posts on his /ftp/ site right?
09:14:13 <ph8> perhaps, is there a way around it / for me to check exactly what's causing the problem?
09:14:18 <SamB_XP> edi: hmm.
09:14:31 <SamB_XP> I don't know.
09:14:34 <ph8> Program error: <handle>: IO.getContents: protocol error (invalid character encoding)
09:14:38 <ph8> probably non-utf8
09:14:49 <ph8> good call. anyway to get around it?
09:14:54 <edi> Well, I know he posted at least three emails he wrote.
09:14:58 <Cale> Maybe use Data.ByteString
09:15:20 <sorear> You should look into bytestring IO.  It'll do the Right Thing with binary data, and be much faster to boot.
09:15:21 <ph8> I have to split these into character lists
09:15:23 <LPhas> Cale: trying to avoid me, i suppose :P
09:15:28 <ph8> so can i still do that with bytestring?
09:16:12 <lisppaste2> phas annotated #32799 with "enhancement" at http://paste.lisp.org/display/32799#1
09:16:20 * edi slaps LPhas around a bit with a large moleskine
09:16:36 <LPhas> :P
09:18:33 <sjanssen> ph8: the current IO libraries do not do UTF-8 translation
09:18:48 <ph8> ok, so i need to get a utf-8 booktext? ;)
09:18:56 <SamB_XP> hah
09:19:01 <SamB_XP> no way
09:19:04 <ph8> what character do you think is likely to be non-utf8?
09:19:13 <SamB_XP> you could just read the manpage for utf-8
09:19:14 <ph8> i.e. which one is throwing it off
09:19:17 <ph8> oki dokey ;)
09:19:21 <SamB_XP> if you wanted to know how it works
09:19:28 <sjanssen> ph8: protocol error is very strange
09:19:35 <sjanssen> is there anything else that could be going on?
09:20:03 <SamB_XP> but anyway, there is already some code for utf-8 that you can steal...
09:21:05 <Cale> edi: When you have a son, you can name him edison.
09:21:29 <edi> And shapr Erissonson.
09:21:35 <LPhas> bwhawh
09:22:23 <SamB_XP> shapr erissonson? wouldn't that be a bit deceptive?
09:22:59 <sieni> shouldn't that be erissonsson? :-)
09:23:06 <edi> I'm too tired.  I tried going to sleep at 10pm, and waking up at 8am, now I'm tired as hell.
09:23:35 <ph8> sjanssen: as i say, it works if I use something like 'program.lhs'
09:23:40 <ph8> could it be the size of the file?
09:24:11 <sjanssen> could you paste the exact error?
09:24:12 <sjanssen> @paste
09:24:13 <lambdabot> http://paste.lisp.org/new/haskell
09:24:14 <ph8> it's only 334k
09:24:18 <ph8> already did above
09:24:23 <ph8> i'll PB the code as well
09:24:53 <sjanssen> oh, I bet you're using hugs
09:25:16 <lisppaste2> ph8 pasted "File processing" at http://paste.lisp.org/display/32801
09:25:26 <ph8> i am :p
09:25:31 <ph8> is that evul~?
09:26:08 <sjanssen> nah, it isn't evil.  I was just debugging from a GHC POV
09:26:36 <ph8> henri@serenity:~/Projects/Xmas06Haskell$ ./a.out
09:26:36 <ph8> Stack space overflow: current size 8388608 bytes.
09:26:37 <ph8> winner
09:27:06 <ph8> muwahaha, it works if i give it an uber-stack
09:27:08 <ph8> thanks dude
09:27:35 <SamB_XP> ph8: maybe you should try to figure out what is using all that stack?
09:27:58 <SamB_XP> do you have the profiling libraries for GHC installed?
09:28:34 * SamB_XP wonders if they ought to be called debugging libraries?
09:28:47 <ph8> erm probably, it's ubuntu so it would be a pisstake to install them if i didn't
09:28:58 <ph8> it's a good question though... reading a 333k file
09:29:03 <ph8> and counting the characters
09:29:05 <ph8> hmm
09:29:09 <ph8> is it like gcc?
09:29:14 <ph8> -Xprof or something?
09:29:24 <Igloo> You probably need to force evaluation of the count as you go
09:29:36 <ph8> sounds exciting, how does one go about that?
09:29:42 <ph8> print?
09:29:44 <Igloo> Where's the code?
09:29:46 <sjanssen> ph8: it looks like hugs refuses to print characters greater than \127
09:30:00 <ph8> sjanssen: that's a little bit rubbish, i don't mind using ghc though
09:30:09 <ph8> <lisppaste2> ph8 pasted "File processing" at http://paste.lisp.org/display/32801
09:30:11 <sjanssen> ph8: I second the suggestion to use Data.ByteString
09:30:14 <ph8> Igloo ^
09:30:22 <ph8> Oh - that'll still let me do all the character splitting then?
09:30:29 <ph8> ?docs Data.ByteString
09:30:29 <lambdabot> Data.ByteString not available
09:30:35 <ph8> little help? the bots all new
09:30:40 <sjanssen> in some future version of GHC, your code will break
09:30:51 <ph8> because i'm not using bytestring?
09:31:06 <ph8> I really want good standards so any feedback is great, this is part of a university assignment
09:31:07 <sjanssen> ph8: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html -- the bot is a bit behind it seems ;)
09:31:09 <lambdabot> http://tinyurl.com/y58jn8
09:31:24 <ph8> that's a sexy feature
09:31:36 <sjanssen> ph8: currently, GHC does the wrong thing with encodings.  I expect that will be fixed someday
09:31:44 <SamB> hmm, so, lets see... how do you do insertWith strictly?
09:32:00 <fridim> yaht++
09:32:24 <Igloo> ph8: That's not the full code
09:32:35 <ph8> no, there's a main = processFile "flowers.txt"
09:32:38 <SamB> oh.
09:32:42 <SamB> isn't that a foldr?
09:32:56 <Igloo> ph8: But incrementNum is also missing, no?
09:32:58 <SamB> > mapFile (a:x) = insertWith incrementNum a 1 (mapFile x)
09:32:58 <SamB> > mapFile [] = Data.Map.empty
09:32:59 <lambdabot>  Parse error
09:32:59 <lambdabot>  Parse error
09:33:00 <psnl> ph8: whats Paul's assignment for this year?
09:33:03 <SamB> oops
09:33:05 <SamB> anyway...
09:33:12 <SamB> isn't that just...
09:33:28 <ph8> lol psnl, How did you know?
09:33:43 <psnl> whois
09:33:44 <Igloo> ph8: insertWith' probably does what you want, anyway
09:33:57 <Igloo> ph8: It just forces evaluation of the value as it updates it
09:34:04 <ph8> i don't really give anything away in my whois...
09:34:10 <ph8> unless you looked up my dns, then googled my name? ;)
09:34:12 <ph8> you big e-stalker
09:34:24 <sjanssen> SamB: yeah, it's a foldr
09:34:26 <SamB> foldr (\c -> insertWith incrementNum c 1) Data.MAp.empty
09:34:35 <SamB> a foldl would work better
09:34:38 <glguy> > map join $ mapM (([]:).(:[]).(:[])) [1..3]
09:34:38 <sjanssen> ph8: you want to make your function a foldl' instead of a foldr
09:34:38 <ph8> why do i need to do it that way instead of this way?
09:34:38 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
09:34:44 <SamB> maybe a foldl'
09:34:57 <SamB> yeah, foldl'
09:34:59 <edi> glguy++
09:35:20 <sjanssen> whoa
09:35:22 <edi> glguy: now do the partitions of size k of a list of size n
09:35:31 <SamB> ph8: do you understand how what you have is basically the same as that foldr I just wrote?
09:35:44 <edi> (stirling numbers)
09:36:02 <ph8> i've read about foldr this morning
09:36:07 <ph8> i'm going to say yes
09:36:14 <SamB> okay.
09:36:15 <ph8> but i'm not sure i entirely understand it
09:36:19 <ph8> i'm ok with lambda notation, finally
09:36:28 <glguy> > let groups n = unfoldr (liftM2 (>>) (guard.not.null) (return.splitAt n)) in groups 3 [1..10] -- edi: this one?
09:36:30 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
09:36:37 <ulph> I have a set of IOUArrays that I would like to index through another array, but it does not seem like I can store IORefs in an IOUArray. Is there some good way to solve this?
09:37:19 <psnl> ph8: it it still that newsgroup thing
09:37:20 <ph8> > mapFile (a:x) = foldl (\c -> insertWith incrementNum c 1) Data.Map.empty <-- throws an error also
09:37:21 <lambdabot>  Parse error
09:37:21 <psnl> ?
09:37:28 <glguy> edi: do you mean "with mapM"?
09:37:28 <emu> UArrays only store unboxed values
09:37:29 <ph8> N-Grams this year psnl
09:37:32 <Cale> ph8: have you read the wikipedia article about fold?
09:37:39 <ph8> no i will do
09:37:42 <glguy> http://foldl.com
09:37:43 <emu> ulph: why do you need an extra level of indirection though?
09:37:45 <lambdabot> Title: foldl.com
09:37:55 <SamB> ulph: complain to the library list?
09:37:56 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
09:38:24 <SamB> ulph: what do you mean by "index through", anyway?
09:38:31 <Cale> I (mostly) wrote that
09:38:45 <SamB> ph8: take out the "(a:x)"
09:39:00 <glguy> ulph: you can put IORefs in IOArrays, but not IOUarrays
09:39:17 <ulph> emu: I am trying to reference some memory by an address, and the upper part of the address will contain the segment number
09:39:30 <SamB> okay, what is the kind ! for?
09:39:36 * emu wonders if you can reference checks in an IOU-Array
09:39:43 <Cale> ph8: What I think is especially helpful are the diagrams you'll find 2/3 of the way down the page.
09:39:53 <syntaxfree> wow! Dons' blog is at the front page of del.icio.us
09:39:57 <sorear> ?kind 'a'
09:40:00 <lambdabot> parse error on input `''
09:40:01 <syntaxfree> Haskell is really getting some attention lately.
09:40:04 <sorear> ?kind Char
09:40:05 <lambdabot> *
09:40:11 <sorear> ?kind GHC.Prim.Int#
09:40:13 <lambdabot> #
09:40:16 <arcatan> Haskell is the next Ruby!
09:40:17 <SamB> Prelude Data.IORef> :kind GHC.Prim.MutVar#
09:40:17 <SamB> GHC.Prim.MutVar# :: * -> * -> !
09:40:26 <ph8> hmm getting loads of type errors
09:40:27 <edi> !
09:40:33 <emu> ulph: i'm still confused though -- if you need to modify the value, the IO[U]Array will allow you to do that in-place
09:40:44 <sjanssen> syntaxfree: I subscribe to the haskell tag feed, the "Programming Haskell" blogs have been getting /tons/ of bookmarks
09:40:47 <emu> makes the IORef seem superfluous
09:40:51 <glguy> Evolution of a Haskell Programmer got a lot more +1's than I expected on reddit
09:41:01 <SamB> emu: true
09:41:05 <ph8> oh, i remember foldl now
09:41:24 <syntaxfree> reddit is Haskell, Common Lisp and Ruby-dominated.
09:41:27 <Cale> well, everyone here will mod up just about anything to do with Haskell.
09:41:43 <ph8> so  --> foldl (\c -> insertWith incrementNum c 1) Data.Map.empty <--- says apply this 'lamda method'  to Data.Map.empty - won't that leave me with a map with only one value in?
09:41:46 <SamB> see, foldl' is good when you want to keep a running tally of some kind as you traverse a list
09:41:49 <glguy> i expected people to scream old news
09:42:10 <SamB> glguy: it is humour, not news
09:42:28 <Cale> ph8: look at the diagram for foldl on the wikipedia page
09:42:46 <SamB> ph8: does that typecheck?
09:42:57 * SamB thought you needed to flip the arguments
09:42:58 <Cale> ph8: the function you pass is a function of two parameters
09:43:07 <ph8> no sam
09:43:15 <Cale> @type Data.Map.insertWith
09:43:16 * SamB should have made the map parameter explicit
09:43:17 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
09:43:27 <Masklinn> syntaxfree > there's a good dose of Python there too
09:43:28 <SamB> @type foldl'
09:43:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:44:01 <Cale> insertWith takes a combining function, a key, a value to insert, and a map, and returns another map.
09:44:12 <ph8> indeed
09:44:23 <ph8> so what was pasted won't work?
09:44:31 <ph8> also, do i have to import something to get foldl'?
09:44:50 <Cale> yes, actually it should, since insertWith is partially applied there
09:45:06 <Cale> well, let's see
09:45:22 <ulph> emu: The upper 32-bit bits of the address contain a segment identifier, and the lower 32 bits of the address an index in the segment specified by the upper 32 bits. So I take (part of) the upper 32 bits and use that as an index in the first array. Now from the first array I want to retreive a reference to a second array that will contain the individual bytes, and that second array is indexed by the lower 32 bits.
09:45:24 <sjanssen> ph8: Data.List
09:45:34 <Masklinn> ph8 > foldl' is in Data.List
09:45:36 <emu> hmm my former AI prof has made programming.reditt top spot
09:45:54 <sjanssen> try it with plain old foldl.  If it doesn't work, then you can resort to foldl'
09:46:08 <SamB> @type foldl (\counts c -> M.insertWith (+1) 1 c counts) M.empty
09:46:10 <lambdabot> Couldn't find qualified module.
09:46:19 <SamB> > foldl (\counts c -> M.insertWith (+1) 1 c counts) M.empty
09:46:20 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
09:46:21 <lambdabot>    Expe...
09:46:24 <SamB> hmm.
09:46:29 <Cale> insertWith's first parameter here should be (+)
09:46:34 <SamB> > foldl (\counts c -> M.insertWith (+) 1 c counts) M.empty
09:46:35 <lambdabot>  Add a type signature
09:46:53 <Cale> > foldl (\counts c -> M.insertWith (+) 1 c counts) M.empty [1,2,43,2,3,1,2]
09:46:55 <lambdabot>  {1:=54}
09:47:09 <Cale> not quite what we probably wanted
09:47:11 <emu> ulph: so, a 2d array?
09:47:19 <Cale> > foldl (\counts c -> M.insertWith (+) c 1 counts) M.empty [1,2,43,2,3,1,2]
09:47:19 <lambdabot>  {1:=2,2:=3,3:=1,43:=1}
09:47:24 <Cale> better
09:47:26 <glguy> > let f xs [x | x <- tail (filterM (const [False,True]) xs), sum x == 0] in take 2 $ f [-50,-21,13,171,14,-42,-58,109,4,7,-23,-44,-98,-121,101,33,87,-121,-40,-65,43,54,-45,-12,-12,38,25,3,7,8]
09:47:26 <lambdabot>  Parse error
09:47:35 <SamB> oh, sorry, I got the arguments mixed up
09:47:41 <Cale> there's a much easier way to accomplish this
09:47:42 <glguy> > let f xs = [x | x <- tail (filterM (const [False,True]) xs), sum x == 0] in take 2 $ f [-50,-21,13,171,14,-42,-58,109,4,7,-23,-44,-98,-121,101,33,87,-121,-40,-65,43,54,-45,-12,-12,38,25,3,7,8]
09:47:44 <lambdabot>  [[-45,38,7],[54,-45,-12,3]]
09:47:49 <SamB> Cale: yes?
09:47:54 <ulph> emu: kind of
09:47:57 <SamB> @doc Data.Map
09:47:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
09:49:07 <ulph> I should probably use the IOArray as someone mentioned.
09:49:33 <Cale> > let counts xs = M.fromListWith (+) $ zip xs [1,1..] in counts [1,2,43,2,3,1,2]
09:49:35 <lambdabot>  {1:=2,2:=3,3:=1,43:=1}
09:49:41 <SamB> I was just about to ask if you meant that
09:49:45 <emu> perhaps
09:49:51 <emu> it will allow any data type
09:50:40 <SamB> > let counts xs = M.fromListWith (+) $ zip xs (repeat 1) in counts "Hello, World!"
09:50:41 <lambdabot>  {' ':=1,'!':=1,',':=1,'H':=1,'W':=1,'d':=1,'e':=1,'l':=3,'o':=2,'r':=1}
09:51:17 <Cale> > let counts = M.fromListWith (+) . map (ap (,) (const 1)) in counts [1,2,43,2,3,1,2]
09:51:19 <lambdabot>  {1:=2,2:=3,3:=1,43:=1}
09:51:30 <SamB> Cale: come now
09:51:33 <Cale> that's stupidly obscure though :)
09:51:44 <SamB> don't confuse the newbie ... or, um, me!
09:52:12 <Cale> It's fine once you know that  ap (,) f x = (x, f x)
09:52:19 <SamB> that reminds me of dons' Data.DList in version 0.1 of the package!
09:52:25 <Excedrin> looks like a lambdabot bug
09:52:37 <Cale> Excedrin: what does?
09:52:43 <Excedrin> '\n'
09:52:50 <SamB> he had too much point-free stuff
09:53:05 <SamB> I mean, for the unary functions it is okay, but it is crazy for the binary ones...
09:53:48 <Excedrin> ah, it was my terminal, nevermind
09:54:16 <Cale> @type ap (,)
09:54:18 <glguy> > map (flip (,) 1) [1..3]
09:54:20 <lambdabot> forall a a1. (a1 -> a) -> a1 -> (a1, a)
09:54:20 <lambdabot>  [(1,1),(2,1),(3,1)]
09:54:43 <Cale> and yeah, you can use flip too :)
09:55:07 <Cale> It's always nice when you can avoid it though.
09:55:22 <SamB_XP> would be nice if you could take sections of tuple constructors
09:55:34 <Cale> @type (,1)
09:55:36 <lambdabot> parse error on input `1'
09:55:39 <Cale> not quite :)
09:55:47 <SamB_XP> hence, "would be nice if"
09:55:49 <Cale> right
09:56:30 <sjanssen> I want sections on list literals too
09:56:52 <Cale> Then you'd get things which start to look like GAP
09:57:00 <sjanssen> [,2,,4,,6] 1 3 5
09:57:00 <Cale> well, not really
09:57:03 <Cale> yeah
09:57:05 <SamB_XP> sjanssen: seriously?
09:57:13 <SamB_XP> what does "[]" mean?
09:57:15 <sjanssen> not really
09:57:19 <Cale> In GAP [,2,,4,,6] is just a list with some holes in it
09:57:19 <sjanssen> but it would be fun
09:57:26 <SamB_XP> is it the section of a one-element list, or is it an empty list?
09:57:34 <Cale> somewhat like [undefined,2,undefined,4,undefined,6]
09:57:36 <glguy> SamB_XP: it's the brother of (:)
09:57:50 <hyrax42> ?users
09:57:50 <lambdabot> Maximum users seen in #haskell: 301, currently: 299 (99.3%), active: 53 (17.7%)
09:57:53 <glguy> data List a = (a : (List a) | []
09:57:55 <sjanssen> SamB_XP: depends on what the user really meant :)
09:57:55 <SamB_XP> glguy: I am questioning sjanssen's suggestion
09:58:10 <SamB_XP> I know what it is *now*
09:58:12 <glguy> SamB_XP: oh yeah, that, lousy
09:58:27 * sjanssen is not actually serious
09:58:27 <glguy> SamB_XP: it seemed like a wierd question for you to ask
09:59:21 <Cale> http://xkcd.com/c198.html
09:59:23 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
09:59:23 <Cale> haha
09:59:47 <sjanssen> xkcd++
10:00:42 <SamB_XP> @karma xkcd
10:00:43 <lambdabot> xkcd has a karma of 3
10:02:10 <ph8> sorry a bit late - so the foldl method is better than mine? or equal?
10:03:28 * fasta thought Firefox was a horrific mess of open-source, not a jewel.
10:03:47 * arcatan agrees
10:05:19 <glguy> "Like many geeks, I got a lot more interested in exercise once I made the connection to leveling up." -- "One more point to STR, then I'll run to work on CON."
10:05:44 <fasta> @what STR
10:05:44 <lambdabot> I know nothing about str.
10:06:14 <psi> strength and constitution
10:06:41 <dylan> Strength and constitution, from Dungeons and Dragons.
10:07:03 <dylan> now roll a wisdom check to see if you know what that is. ;)
10:07:31 <glguy> ?what roll
10:07:32 <lambdabot> I know nothing about roll.
10:07:39 <cjeris> s/wisdom/Knowledge (role-playing games)/
10:07:48 <wchogg> One of my favorites from xkcd is still the "sudo make me a sandwich" joke.
10:07:55 <glguy> link?
10:07:58 <ski_> @dice 2d20+10
10:07:59 <lambdabot> 2d20+10 => 26
10:08:05 <Nafai> wchogg: Yeah, me too :)
10:08:07 <dylan> glguy: you need to take a d20 and roll it. (d20 = 20 sided dice)
10:09:19 <emu> glguy: where's that from?
10:09:40 <glguy> my quote was from xkcd.com
10:09:43 * fasta never played any of the RPG's. 
10:09:45 <glguy> I just hit Prev a ouple times
10:11:15 * Vq^ associate STR with http://www.shelleytherepublican.com/
10:11:17 <lambdabot> Title: Shelley The Republican : The Freedom Blog
10:11:29 <sorear> Cabal needs a Provides: tag...  (trying to get hmp3 to compile: unsatisfied dependency on fps>=0.7)
10:11:33 <Vq^> all i know about americans i have learned from that blog :)
10:12:37 <fasta> Short Tandem Repeat polymorphisms are short sequences of DNA ;)
10:12:54 <emu> i need to send that to a friend of mine hehe
10:14:38 <wchogg> That Shelley The Republican blog made me think it was real until the entry about the mentally handicapped. I've seen almost the same stories non-ironically used in other places.
10:15:31 <fasta> "Number of retards by country" <- not really serious indeed
10:15:58 <dylan> shelley the republican?
10:16:26 <vegai> any news on hs-plugins and ghc-6.6?
10:17:04 <fasta> "The Bible teaches us that God’s love is worth more than gold. History teaches us that it is foolish to base a currency on a Gold standard when God’s standard is ever-lasting."
10:17:08 <fasta> Hilarious
10:17:44 <ndm> @seen Philippa_
10:17:44 <lambdabot> Philippa_ is in #scannedinavian, #haskell, #haskell-overflow, #haskell-blah and #oasis. I don't know when Philippa_ last spoke.
10:17:53 <Vq^> their "linux" articles is quite amusing as well
10:21:19 <ph8> is there a generally accepted way to extract paragraphs from text?
10:21:21 <ph8> atm i'm using lines
10:21:29 <ph8> but that doesn't really mark things adequately
10:21:36 <ph8> or do i need to make my own 'paragraphs' function?
10:21:46 <emu> parsec?
10:22:02 <fasta> Vq^: let me guess: Linux equates communism?
10:22:43 <Vq^> fasta: stuff like that :)
10:23:16 <ph8> parsec??
10:23:26 <Vq^> quite amusing for us communistic european non-christian gnu/linux users :)
10:24:34 <fasta> Vq^: yes, it's quite funny. Thanks for the website.
10:24:37 <dylan> yeah, europe is all communist. the US is a perfect free market economy. This is why there is a cable monopoly and the ISPs can rape their cutomers here in the US. Wait...
10:24:47 <emu> ph8: 3.26 ly
10:25:27 <emu> ph8: istr a paragraph example from the Parsec (parser combinator lib) docs
10:25:43 <SamB_XP> Vq^: speak for yourself...
10:25:47 <emu> i think it was based on parsing sentences as words ending with periods, though.
10:27:23 <SamB_XP> I think I'm more of a communist-ish american not-particularly-in-love-with-GNU Linux user
10:29:08 <SamB_XP> of course, I'm much to smart to believe in centralized communism
10:29:18 <SamB_XP> oh, I forgot to mention christian...
10:29:25 <emu> did you catch yegge's e-mail from Marx to Mao/stalin?
10:30:23 <emu> (i know it was allegorical)
10:31:00 <SamB_XP> what is this dinging sound?
10:33:52 <SamB_XP> what is the real definition of secular humanism?
10:35:45 <kyevan> Assorted crazy Haskell users: Does anyone have a simple-but-not-insanely-so problem that writeing a solution for might help me make sure I understand monads right?
10:36:29 <integral> H-M type inferencer?
10:36:31 <pejo> An interpreter!
10:36:37 <SamB_XP> hmm... write a parser for something non-trivial but not too nasty?
10:36:46 <emu> a game solver
10:37:39 <kyevan> Those all sound... nasty.
10:37:49 <SamB_XP> I expect you can't really understand monads very much themselves (there isn't that much to understand -- they are absurdly simple), but you can understand applications of them
10:37:52 <emu> really?
10:37:55 <CosmicRay> kyevan: you could re-implement this api: http://software.complete.org/configfile/static/doc/Data-ConfigFile.html
10:37:57 <lambdabot> http://tinyurl.com/y5buky
10:38:06 <Cale> http://programming.reddit.com/info/v35v/comments/cv6et -- haha
10:38:08 <lambdabot> Title: Avoidance of regular expressions. (reddit.com)
10:38:08 <SamB_XP> kyevan: what is wrong with a parser?
10:38:09 <Cale> pwned
10:38:09 <kyevan> http://crap.jinwicked.com/index.php?comic=86
10:38:10 <emu> writing something to play a game sounds fun
10:38:14 <kyevan> Grr
10:38:15 <lambdabot> Title: Crap I Drew on My Lunch Break :: Updated 11/30/2006
10:38:21 <integral> (http://www.cafepress.com/skicalc.6225368)
10:38:30 <kyevan> Copy and paste being right next to each other on the menu :P
10:38:30 <SamB_XP> Cale: what happened since yesterday?
10:38:40 <Cale> SamB: since yesterday?
10:39:07 <SamB_XP> oh, well, that other thread didn't look so good
10:39:17 <Cale> which one?
10:39:26 <cjeris> Cale: thedailywtf++ -- but the haskell equivalent would be the-daily-wtf-does-this-program-do
10:39:26 <SamB_XP> the one where one of us got modded to oblivion?
10:39:37 <SamB_XP> I think it was you
10:39:41 <kyevan> SamB_XP: Well, it's well outside my range of knowledge and experience...
10:39:44 <Cale> cjeris: I think it's very readable
10:39:56 <Cale> Even if you don't know HXT you can work your way through it
10:40:16 <cjeris> Cale: no, i was more thinking of some of the @pl golfing i see on the channel :)
10:40:25 <SamB_XP> oh, maybe it wasn't one of *us* per se
10:40:28 <Cale> ah
10:40:31 <SamB_XP> I think it was ricercar
10:40:34 <Cale> oh, yes
10:40:37 <Cale> that's dumb
10:40:46 <kyevan> And, wouldn't that require using multiple monads at once?
10:40:52 <kyevan> I have, noclue how to do that :P
10:40:58 <fasta> Cale: hmm, that program seems readable
10:41:03 <cjeris> your HXT thing is very readable except that i don't understand arrows yet.  (i mean really understand.)
10:41:04 <Cale> everyone go http://programming.reddit.com/info/v35v/comments here and mod up all of ricercar's posts
10:41:06 <lambdabot> Title: Avoidance of regular expressions. (reddit.com)
10:41:20 <Cale> since they were very unfairly modded down
10:43:21 <vegai> I wonder what would be a nice datatype for a calendar
10:43:59 <explodey> Is there a survey somewhere of what other languages Haskell programmers like?
10:44:23 <explodey> (I wouldn't have expected Python to appear high on the list)
10:44:38 <fasta> Cale: is the documenation also online for HXT?
10:44:43 <Cale> yes
10:44:56 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/index.html -- here's the haddock
10:45:13 <Cale> Unfortunately, there's a lot of stuff in the library which is rarely needed
10:45:24 <fasta> Cale: oh, so the interface is still horrible
10:45:41 <Cale> It's not horrible
10:45:48 <Cale> the arrow interface is really pretty clean
10:45:53 <Cale> it's more like it's overdocumented
10:46:17 <Cale> 90% of the time, you'll only use 10% of what's in the library.
10:46:31 <Cale> Sorting the documentation properly would fix that problem.
10:47:03 <Cale> I actually picked the library up very quickly just by skimming the tutorial
10:47:12 <Cale> http://www.haskell.org/haskellwiki/HXT
10:47:14 <lambdabot> Title: HXT - HaskellWiki
10:47:28 <Cale> You don't even really need to understand everything that's described there.
10:47:35 <fasta> Cale: Well, since 5.5 it appears there is more documentation
10:47:56 <Cale> right, it's almost like there's too much documentation which isn't well enough organised now
10:48:00 * complacent OC@balti --> #revolta (2 needed (soldier+))
10:48:22 <Cale> But it really is quite usable if you guess the names of things and look them up in the index :)
10:48:41 <Cale> (once you have the basic idea which you'll get by skimming that tutorial)
10:49:24 <wy> Cale: Is there a way to get the arity integer from a function?
10:49:27 * complacent OC@balti in10mins--> #revolta (WE or LE needed)
10:49:27 <Cale> The basic idea is that it's all nondeterministic processing. Each arrow consumes a stream of XML trees coming into it one at a time, and spits out a stream of XML trees for each.
10:49:47 <Cale> and you're basically applying bunches of filters to get the stuff you want
10:50:06 <Cale> wy: hard-code it, it's determined by the type and hence can't change at runtime.
10:51:03 <vegai> Hope apparently uses a Trie to represent its store
10:51:13 <vegai> yeah... that seems like a good idea.
10:51:23 <fasta> Cale: what makes it non-deterministic?
10:52:14 * SamB_XP wonders if his message made it to libraries@
10:52:27 <fasta> SamB_XP: send them a message ;)
10:52:27 <SamB_XP> I should know better than to post things on the weekend...
10:52:40 <Cale> fasta: the arrows are all internally things like a -> [b]
10:53:03 <Cale> but actually, that's not quite true, because there's state and IO stuff in there too
10:53:03 * vegai finds the lack of "No! You idiot!" couraging.
10:53:11 <fasta> Cale: ok, so it just lifts (->) to arrow
10:53:18 <Cale> not quite
10:53:26 <fasta> Cale: (for some thing)
10:53:28 <fasta> er things
10:53:31 <Cale> It's sort of like lifting the list monad to arrows
10:53:50 <fasta> Cale: but what makes it non-deterministic?
10:54:05 <Cale> well, the list monad handles nondeterminism, right?
10:54:24 <fasta> Cale: I would say the list monad is deterministic.
10:54:34 <Cale> x <- [1,2,3,4]
10:54:35 <fasta> You can simulate, though.
10:54:39 <glguy> a deterministic approximation of nondeterminism
10:54:45 <Cale> is like nondeterministically binding x to 1,2,3 and 4
10:55:08 <Cale> Note that I'm using nondeterminism here in the sense of "multiple results", not in the sense of "random results"
10:55:16 <fasta> Cale: I find your terminology wrong in this case.
10:55:27 <fasta> Cale: Although, I usually agree.
10:55:41 <Cale> Functions of type a -> [b] are nondeterministic functions a -> b
10:55:55 <SamB_XP> Cale: hmm, doesn't HXT's arrow have a lot of garbage like IO and whatnot?
10:55:58 <fasta> Cale: who says they are?
10:56:10 <Cale> fasta: computer science?
10:56:20 <Cale> SamB_XP: there are really a whole bunch of arrow types
10:56:25 <SamB_XP> fasta: well, nodeterministic means they don't return just one value
10:56:27 <Cale> SamB_XP: but yes
10:56:32 <SamB_XP> Cale: I saw like one that was implemented
10:56:41 <fasta> Cale: Then I should know.
10:56:44 <wy> Cale: say I have a list of numbers and an operator. The number of numbers in the list should be enough for the operator. Now I want to apply the operator to the numbers, whatever they are. How can I do this?
10:56:44 <Cale> newtype IOSLA s a b = IOSLA { runIOSLA :: (s -> a -> IO (s, [b])) }
10:57:04 <fasta> Cale: if you have a reference that claims that, I would be interested in it.
10:57:17 <Cale> wy: pattern match
10:57:28 <SamB_XP> hmm
10:57:40 <SamB_XP> no arrow transformers yet?
10:58:06 <Cale> http://en.wikipedia.org/wiki/Nondeterministic
10:58:07 <fasta> It would be non-deterministic if x would be chosen at random.
10:58:08 <lambdabot> Title: Nondeterministic algorithm - Wikipedia, the free encyclopedia
10:58:33 <Cale> In the sense of nondeterministic Turing machine, etc.
10:58:34 <fasta> Cale: the specification for the list monad implies an ordering.
10:58:52 <Cale> sure, the Set monad also models nondeterminism
10:59:11 <SamB_XP> so has anyone seen http://thread.gmane.org/gmane.comp.lang.haskell.libraries/6002 ?
10:59:14 <Cale> but it can't be made an instance of the Monad class in Haskell because you need an instance of Ord
10:59:14 <lambdabot> Title: Gmane Loom
10:59:23 <fasta> Cale: so, since it models it, it's _not_ nondeterminism.
10:59:28 <Cale> huh?
10:59:44 <Cale> no, it is. A list of results is still multiple results.
10:59:48 <SamB_XP> or, if you like links to pages with actual titles... http://article.gmane.org/gmane.comp.lang.haskell.libraries/6002
10:59:50 <lambdabot> Title: Gmane -- Mail To News And Back Again
10:59:54 <emu> Cale: i ran into that this weekend, heh.
10:59:55 <SamB_XP> what?
11:00:01 <emu> i was wondering why Set wasn't a MonadPlus
11:00:03 * SamB_XP doesn't see that title...
11:00:07 <fasta> > head [x|x<-[1..3]]
11:00:09 <lambdabot>  1
11:00:10 * SamB_XP swats lambdabot
11:00:17 <Cale> emu: it would be nice, but there are tricky technical problems with it
11:00:18 <fasta> This always returns 1
11:00:27 <emu> Sequence, however, is
11:00:27 <fasta> It can't be more deterministic
11:00:35 <glguy> ?all-dicts nondeterminism
11:00:37 <lambdabot> *** "nondeterminism" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
11:00:38 <lambdabot> nondeterminism
11:00:40 <lambdabot>  
11:00:40 <Cale> fasta: augh
11:00:42 <lambdabot>     <algorithm> A property of a computation which may have more
11:00:44 <lambdabot>     than one result.
11:00:46 <lambdabot> [7 @more lines]
11:00:55 <SamB_XP> the real title is "Data.Generics and Abstract Data Types"
11:01:16 <Cale> fasta: The fact that you always get the same set/list of results is fine. That's still nondeterminism
11:01:19 <glguy> "A property of a computation which may have more than one result."
11:01:20 <fasta> Cale: yes, so?
11:01:29 <fasta> Cale: I know what that definition means.
11:01:29 <Cale> You just don't understand the terminology.
11:01:35 <fasta> Cale: Are you sure you do?
11:01:47 <Cale> A nondeterministic function is a function returning zero or more results
11:02:01 <fasta> Cale: no, it isn't.
11:02:07 <SamB_XP> > do ['\0'..]; guard isAlphaNum
11:02:07 <Cale> what is it to you?
11:02:08 <lambdabot>    Expecting a function type, but found `Bool'
11:02:09 <lambdabot>    Expected type: Bool
11:02:09 <lambdabot>  ...
11:02:11 <SamB_XP> hmm.
11:02:28 <SamB_XP> > do ['\0'..] >>= guard . isAlphaNum
11:02:29 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
11:02:33 <SamB_XP> hmm.
11:02:39 <rindolf> Hi all.
11:02:42 <Vq^> hi you
11:02:44 <SamB_XP> that isn't quite right.
11:02:52 <Cale> If you're picking random choices, that's not nondeterminism, it's probabilistic determinism.
11:03:00 <glguy> > do ['\0'..] >>= \x -> guard (isAlpha x) >> return x
11:03:02 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\181\186\192\193\19...
11:03:04 <fasta> Cale: random is a theoretical construct.
11:03:13 <Cale> so?
11:03:26 <fasta> Cale: so, nondeterministic functions are too.
11:03:35 <Cale> what?
11:03:38 <Vq^> ?
11:03:39 <Cale> I don't get your point.
11:03:41 <SamB_XP> nondeterminism has nothing to do with randomness
11:04:03 <Cale> It's simply the idea that a function or computation is returning zero or more results.
11:04:07 <sorear> There is a major difference between probabilistic and nondeterministic - nondeterministic accepts if *any* path accepts.  E.g. the backtracking of the list monad.
11:04:09 <SamB_XP> also, are you meaning to tell me that I cannot use theoretical constructs in my programs?
11:04:19 <Cale> sorear: yes
11:04:20 <SamB_XP> because I am not believing you if you are.
11:04:51 <fasta> SamB_XP: you can use calls to some random function all you want, you just don't know whether it's actually random.
11:04:55 <SamB_XP> am thinking functions are also theoretical constructs
11:05:08 <Cale> fasta: that's completely unrelated to what we're talking about
11:05:10 <SamB_XP> fasta: it not function is if random
11:05:14 <SamB_XP> er./
11:05:16 <SamB_XP> if is
11:05:17 <Cale> right
11:05:30 <SamB_XP> it must be one of them "procedure" things
11:05:36 <fasta> SamB_XP: that depends on how you define function.
11:05:39 <sorear> Sure it's a function.  It just has more inputs and/or outputs.
11:05:59 <sorear> (If you use split you don't need to add outputs)
11:06:12 <Cale> Well, you can model random variables and functions between them using another category, and functions from values to random variables would then be arrows in that category.
11:06:18 <SamB_XP> sorear: you are saying is okay if I write program: main = print (f 1) -- and program give different output each time?
11:06:32 <fasta> Cale: anyway, how would you construct a nondeterministic algorithm without randomness?
11:06:34 <Cale> Which is the Kleisli category for the monad of random variables.
11:06:35 <SamB_XP> that is what fasta is implying.
11:06:52 <SamB_XP> fasta: nondetermistic == having more than one result
11:06:54 <Cale> fasta: What we're all saying is that nondeterminism has *nothing to do* with randomness.
11:06:56 <SamB_XP> that sounds like a list to me
11:06:59 <fasta> SamB_XP: no, it's not.
11:07:14 <SamB_XP> <lambdabot>     <algorithm> A property of a computation which may have more
11:07:14 <SamB_XP> <lambdabot>     than one result.
11:07:16 <Cale> If you think that nondeterminism has something to do with randomness, that's where your mistake is.
11:07:29 <sorear> SamB: If I run your program ten billion times, It will start to return ENOSPC.
11:07:37 <Saizan> fasta: nondeterminism is when you have multiple choices, "list" just reports them all
11:07:42 <SamB_XP> sorear: no it won't
11:07:48 <SamB_XP> you don't run out of terminal
11:07:53 <SamB_XP> it scrolls off the top, silly
11:08:07 <Cale> fasta: do you know what an NTM is?
11:08:10 <glguy> SamB_XP: My teletype machine runs out of paper though \=
11:08:11 <fasta> Cale: I do
11:08:16 <emu> ah, there's something very satisfying about writing your code in lhs w/latex
11:08:25 <Cale> that's the sense of "nondeterminism" we're using here
11:08:33 <fasta> Cale: I am too.
11:08:34 <SamB_XP> glguy: well, in that case program probably hangs waiting for you to put more paper in
11:08:38 <fasta> Cale: and I think you are wrong.
11:08:49 <Cale> no you're not, because you seem to think that it has something to do with randomness
11:08:51 <fasta> Cale: The wikipedia article is consistent with my view
11:08:59 <Cale> NTMs don't behave randomly.
11:09:22 <glguy> wikiality, lol
11:09:23 <fasta> Cale: I am not saying they behave according to some distribution.
11:09:26 <Cale> They simply follow all possible branches of a computation
11:09:39 <Cale> and this is exactly what the list monad does
11:09:40 <tibbe> my nondeterministic automaton isn't random... ;)
11:10:03 <tibbe> it's just nondeterministic
11:10:07 <sorear> All randomness can be reduced to nondeterminism by assigning probabilities to results.  The converse is not true.
11:10:08 <Cale> (With determinism you don't have "branches" in that sense)
11:10:10 <fasta> Cale: That's not what a NTM does.
11:10:24 <Cale> Your NTMs are very different from mine then.
11:10:54 <Saizan> NTM?
11:11:03 <Cale> Nondeterministic Turing machine
11:11:07 <Cale> http://en.wikipedia.org/wiki/Non-deterministic_Turing_machine
11:11:08 <lambdabot> Title: Non-deterministic Turing machine - Wikipedia, the free encyclopedia
11:11:15 <fasta> Cale: NTMs don't branch in all directions.
11:11:15 <SamB_XP> Cale: according to this article, that is just one way to transform a nondeterministic algorithm to a deterministic one
11:11:19 <sorear> > let f x = return [x, x+1] in [0] >>= f >>= f >>= f >>= f >>= f >>= f
11:11:20 <lambdabot>  add an instance declaration for (Num [[[[[a]]]]])
11:11:30 <SamB_XP> the other way being to use a random number generator
11:11:33 <glguy> fasta: to quote your source: "How does the NTM "know" which of these actions it should take? There are two ways of looking at it. One is to say that the machine is the "luckiest possible guesser"; it always picks the transition which eventually leads to an accepting state, if there is such a transition. The other is to imagine that the machine "branches" into many copies, each of which follows one of the possible transitions. Whereas a DTM has a single "c
11:11:35 <Cale> At each point, an NTM has a set of states which it is in.
11:11:40 <SamB_XP> and I suppose you could always just take the left branch, too...
11:12:20 <fasta> glguy: uhh, I don't like to quote wikipedia on stuff I have books on.
11:12:42 <glguy> fasta: that may be, but you used the wikipedia in your argument earlier, that's all
11:12:59 <sorear> Citations?  I'd be very interested to see a CS book use 'nondeterministic' to mean 'random'
11:13:32 <fasta> glguy: I only said that NTMs are consistent with my point of view. (I only read the top section, though)
11:15:01 <bitshifter> You should re-read that section then.
11:15:10 <bitshifter> and then maybe the ones following iy
11:15:12 <bitshifter> err it
11:15:56 <SamB_XP> http://en.wikipedia.org/wiki/Nondeterministic_finite_state_machine looks like it has the right idea to me...
11:15:59 <lambdabot> Title: Nondeterministic finite state machine - Wikipedia, the free encyclopedia, http://tinyurl.com/glxuw
11:16:02 <Cale> formally, Q is the set of states which the NTM is in, and the transition function sends Q\A x Sigma to a set of tuples in (Q x Sigma x {L,R}), each being a new state, a character to be written on the tape, and an instruction to move the tape head for that case left or right.
11:16:59 <Cale> Oh, Q is the set of all states, sorry
11:17:42 <Cale> the important thing is that the transition function is multivalued (and would perhaps more properly be called a transition relation)
11:17:52 <tibbe> I'm reading that chapter of Introduction to the Theory of Computation right now :)
11:17:56 <glguy> fortunately we have untyped lambda calculus, which does everything that turing machines do, and look cooler
11:18:00 <Cale> On each step, the result is a set of new NTMs
11:18:37 <Cale> (each with a new initial state)
11:18:55 <Cale> (and each having its own copy of the tape)
11:19:42 <Cale> In the Haskell list monad, we're not using sets to represent this nondeterministic choice, but lists.
11:19:47 <Excedrin> is there a simpler version of: \[a1,b1] [a2,b2] -> [a1+a2, b1+b2]
11:19:48 <Cale> So that is a difference
11:20:01 <Cale> But it's an inessential one for most applications.
11:20:23 <sorear> > let f x = [x, x+1] in [0] >>= f >>= f >>= f >>= f >>= f >>= f
11:20:25 <sjanssen> > zipWith (+) [1, 2] [10, 11] -- there you go, Excedrin
11:20:25 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
11:20:26 <lambdabot>  [11,13]
11:20:28 <Vq^> Excedrin: zipWith (+)
11:21:02 <Cale> > let f x = [x, x+1] in S.fromList ([0] >>= f >>= f >>= f >>= f >>= f >>= f)
11:21:04 <lambdabot>  {0,1,2,3,4,5,6}
11:21:19 <sorear> > let f x = [x, x+1] in map length $ group $ sort $ [0] >>= f >>= f >>= f >>= f >>= f >>= f
11:21:21 <lambdabot>  [1,6,15,20,15,6,1]
11:21:40 <SamB_XP> a trivial difference as long as you are just using it to implement nondeterminism
11:21:55 <Cale> a nicely inefficient way to compute binomial coefficients :)
11:22:17 <fasta> Cale: there's never made a non-deterministic choice in any of the above algorithms.
11:22:23 <SamB_XP> I mean, you could nub lists at every opportunity if you preferred
11:22:28 <SamB_XP> but it would be slow slow slow
11:22:50 <Cale> fasta: the idea is that  x <- [1,2,3]  makes a nondeterministic choice between 1, 2, and 3 and binds the result to x
11:23:20 <sorear> If you pick an element at random from the first list (with all the duplicates), you get a number in a binomial distribution; by this method, nondeterminism subsumes probabilism.  (for rational probabilities)
11:23:24 <kermitthehermit> I asked yesterday how you tell read what type you want.
11:23:25 <kermitthehermit> I said it's called in an IO function, but I forgot that doesn't matter.
11:23:25 <kermitthehermit> This works:
11:23:25 <kermitthehermit> let n = (read :: (String -> Int)) str
11:23:27 <kermitthehermit> and this works:
11:23:27 <fasta> Cale: yes, you can use that as a _model_.
11:23:29 <kermitthehermit> let (n::Int) = read str
11:23:35 <glguy> we need a Monad that creates a new thread for each choice
11:23:44 <SamB_XP> glguy: yeah
11:23:45 <glguy> and runs the whole thing massively parallel ;)
11:23:46 <fasta> Cale: it's not nondeterminism
11:23:52 <Cale> similarly, xs >>= f makes a nondeterministic choice between the values of xs, and binds the result to the parameter of f which is a nondeterministic computation
11:24:02 <fasta> Cale: no, it doesn't.
11:24:10 <Cale> Sure it does :)
11:24:19 <edi> > let f x = [x, x+1]; xs = ([0] >>= f >>= f >>= f >>= f >>= f >>= f) in xs `intersect` xs
11:24:20 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
11:24:22 <Cale> That's the semantics of it.
11:24:23 <edi> aww.
11:24:23 <SamB_XP> glguy: I can't figure out how to do that in such a way that it gives the answers as they come, but stops when all the answers are computed, though
11:24:29 <fasta> Cale: then why are the answers the same everytime?
11:24:45 <Cale> because *nondeterministic computation is NOT RANDOM*
11:24:49 <fasta> Cale: I know
11:25:08 <fasta> Cale: Ok, at what point in your algorithm could another "branch" be chosen?
11:25:09 <glguy> SamB_XP: really, since you usually wouldn't need all results, just one accepted one, you could have it halt when one thread finished
11:25:11 <cjeris> > let C n k = (map length . group . sort . [0] >>= foldr1 (>>=) $ take n (repeat (\x -> [x, x+1]))) !! k
11:25:11 <lambdabot>  Parse error
11:25:16 <SamB_XP> notice how you just said "the answers"?
11:25:20 <SamB_XP> glguy: true
11:25:30 <fasta> Cale: all of the functions you use are completely deterministic
11:25:44 <SamB_XP> glguy: except then you would need to kill them all
11:25:49 <SamB_XP> which might be even worse
11:25:54 <Cale> fasta: We're thinking of a function  a -> [b]  as the same as a nondeterministic function  a -> b
11:26:03 <Cale> does that make sense?
11:26:24 <fasta> Cale: You mentioned NTMs.
11:26:30 <Cale> the function takes a bunch of different branches and the list is the list of results you end up with.
11:26:39 <Cale> yes, I did
11:26:51 <Cale> because that's essentially the same sense of the word "nondeterminism"
11:27:05 <fasta> I don't agree with that.
11:27:09 <Cale> Though I'm not actually talking about Turing machines
11:27:27 <Cale> (well, sort of, as much as Haskell functions can be thought of as Turing machines)
11:27:34 <fasta> I understand that you can use the List monad for expressing some simple combinatorial algorithms.
11:27:35 <ski_> there's two kinds of nondeterminism .. angelic / don't-know, and demonic / don't-care
11:27:40 <sorear> something like: nonDet :: [a] -> ContT IO a ; nonDet lst = ContT $ \cont -> mapM_ (\x -> forkIO $ cont x) lst
11:27:53 <glguy> fasta: so you are arguing for the theoretical NTM that always chooses the correct path towards an accept state?
11:28:07 <SamB_XP> Cale: you are talking about the functions that make up a NTM
11:28:09 <ski_> the list monad implements the first kind .. the one in concurrency is of the second kind
11:28:23 <Cale> SamB_XP: yes, I'm talking about the actual definition of an NTM
11:28:31 <fasta> glguy: I am arguing that the NTM can choose two different paths in which to branch.
11:28:36 <SamB_XP> and how you can write them in Haskell
11:28:49 <Cale> fasta: yes, and you represent that by  x <- [case1, case2]
11:28:56 <george> how can i convert a single character length string to a char (it will still be of type string giving me errors)
11:28:59 <glguy> fasta: and that it need not choose all of them if it chooses the right one?
11:29:06 <Cale> fasta: in one branch, x will be bound ot case1
11:29:11 <Cale> in the other, case2
11:29:17 <sjanssen> > head "x" -- like this george
11:29:18 <lambdabot>  'x'
11:29:57 <george> basically a function has a string and it wants to pass another function the last char of the string... so im using :   drop (listLen x - 1) x
11:30:05 <Cale> fasta: see how that works?
11:30:10 <fasta> Cale: Yes, I already said Haskell can _model_ it.
11:30:12 <glguy> > last "hello"
11:30:13 <lambdabot>  'o'
11:30:16 <fasta> Cale: it's not the same.
11:30:23 <glguy> george: you can use "last" to return the last leter
11:30:23 <george> is it good code to say head $ drop (listLen x - 1) x
11:30:25 <glguy> letter*
11:30:28 <george> ahh
11:30:29 <george> last
11:30:36 <george> i didnt know this function :) saves some time
11:30:39 <ski_> sorear : s/ContT IO a/ContT () IO a/
11:30:46 <glguy> george: length probably does the same thing as your listLen
11:30:48 <Cale> fasta: all we're talking about is semantics here, modeling something is the same as being that thing.
11:31:22 <Cale> If something models nondeterministic computation, then it has nondeterministic computation as its semantics.
11:31:46 <Cale> We're not worrying about things like runtimes, etc.
11:31:57 <george> heh ;) glguy: ty i will modify my code for this too. surely will be more efficient the prelude way
11:32:28 <SamB_XP> fasta: would it be more authentic for you if you could get an arbitrary answer back?
11:33:04 <agocorona> what is nondeterministic computation? the stuff of Roger Penrose about the imposibility of Artificial Intelligence?
11:33:16 <SamB_XP> i.e. glguy's Monad Parallel ?
11:33:40 <Cale> fasta: to get back to the original point, the simplest of the arrows which HXT uses is called LA, and a value of type LA a b is thought of as a nondeterministic computation a -> b
11:33:55 <Cale> the implementation is   newtype LA a b = LA { runLA  :: (a -> [b]) }
11:34:24 <ski_> 'HXT' ?
11:34:24 <dylan> wtf? the lambda argument to mapcar has to be quoted...
11:34:31 <Cale> Haskell XML Toolbox
11:34:38 <edi> HXT++ !!
11:34:40 <Cale> newtype IOSLA s a b = IOSLA { runIOSLA :: (s -> a -> IO (s, [b])) }
11:34:41 <SamB_XP> dylan: this is CL you are dealing with
11:34:50 <SamB_XP> don't be so surprised by these things
11:34:51 <glguy> dylan: welcome to the joys of having separate function and variable namespaces
11:34:52 <dylan> SamB_XP: it's actually not -- it's XLISP 1.5
11:34:57 <Cale> that's the most complicated arrow in HXT, and the one which most stuff actually happens in
11:35:01 <SamB_XP> dylan: even worse!
11:35:05 <dylan> variables and functions are in the same namespace!
11:35:09 <Cale> (though you mostly don't use all its functionality)
11:35:11 <fasta> SamB_XP: the order of visiting the various branches can be different everytime.
11:35:28 <glguy> if it isn't Scheme, I don't want to hear about it ;)
11:35:37 <edi> The "user state" is a quite advanced feature.
11:35:44 <fasta> SamB_XP: so head (nondeterministic([1,2,3]) can also return 2
11:35:45 <dylan> this was based on an early scheme, with dynamic scope.
11:36:01 <SamB_XP> fasta: well, yeah, the Parallel monad glguy suggested would do that too. maybe.
11:36:09 <Cale> fasta: once you apply head, you're no longer in the list monad
11:36:14 <SamB_XP> but since it is nondeterminism, you can't complain if it doesn't work right for you.
11:36:16 <edi> fasta: I'd say head `fmap` runND foo can
11:36:24 <Cale> fasta: and hence it has nothing to do with nondeterminism anymore
11:36:35 <fasta> Cale: uh, right, the head was a mistake
11:36:36 <SamB_XP> or, rather, if it happens to give you the first answer each time...
11:36:56 <Cale> fasta: if you do  x <- [1,2,3], then x is bound successively to each of those values.
11:37:08 <fasta> Cale: right, in a certain order.
11:37:11 <Cale> In particular, in one branch of the computation, x will be bound to 2.
11:37:12 <SamB_XP> glguy's proposed monad would give you *one* result value
11:37:20 <Cale> The order is usually irrelevant.
11:37:40 <Cale> That's a side effect of the fact that it's the list monad and not the set monad, which is what we'd really want to use, but can't.
11:37:40 <edi> ?where nymphaea
11:37:41 <SamB_XP> Cale: not if you want to get your answer soon
11:37:41 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
11:37:43 <edi> ^- example of nondet
11:37:46 <edi> + monadrandom
11:37:54 <Cale> SamB_XP: right, it's a mere performance thing :)
11:38:22 <SamB_XP> of course, glguy's unrestrained Parallel monad probably isn't so great for that either?
11:38:52 <Cale> And, well, infinite lists don't play nicely, and make you worry about ordering, but that's another place where we're making an approximation.
11:39:22 <sorear> newtype MP a = MP (ContT () IO a) deriving (Monad) ; nonDet :: [a] -> MP a ; nonDet lst = MP $ ContT $ \cont -> mapM_ (\x -> forkIO $ cont x) ls ; runMP :: MP a -> IO a ; runMP (MP a) = do x <- newEmptyMVar ; runContT a (\v -> tryPutMVar x v >> return ()) >> takeMVar x
11:39:45 <sorear> note that runMP will deadlock if no paths accept.
11:39:46 <Cale> sorear: nice
11:40:07 <sorear> I had no idea ContT could be abused like this.
11:40:19 <Cale> It's obvious once you see it :)
11:40:24 <SamB_XP> sorear: what does it do?
11:40:29 <Cale> I'm not all that surprised.
11:40:33 <SamB_XP> I don't understand that stuff.
11:40:37 <ski_> sorear : cutoff ".. return ()) >> takeMVar x"
11:40:45 <Cale> SamB_XP: nondeterminism in IO, forking multiple threads
11:40:48 <sorear> massively parallel nondeterminism monad!
11:40:50 <glguy> sorear: put it on paste.lisp? so that we get formatting and color coding?
11:40:52 <kermitthehermit> I asked yesterday how you tell read what type you want.
11:40:52 <kermitthehermit> I said it's called in an IO function, but I forgot that doesn't matter.
11:40:52 <kermitthehermit> This works:
11:40:52 <kermitthehermit> let n = (read :: (String -> Int)) str
11:40:52 <kermitthehermit> and this works:
11:40:54 <SamB_XP> oh, already?
11:40:55 <kermitthehermit> let (n::Int) = read str
11:41:07 <kermitthehermit> Mistake, sorry.
11:41:08 <SamB_XP> and it works?
11:41:19 <Cale> SamB_XP: yeah, that looks like it ought to work
11:41:31 <Cale> It just uses ContT
11:41:31 <kermitthehermit> Is there a way to string lines together in a monad function?
11:41:32 <kermitthehermit> I want to do something like this:
11:41:32 <kermitthehermit> putStr "Enter foo: " >> foostr <- getLine >> let (foo::Int) = read foostr >> putStrLn (show foo)
11:41:32 <ski_> let n = read str :: Int
11:41:35 <kermitthehermit> putStr "Enter bar: " >> barstr <- getLine >> let (bar::Int) = read barstr >> putStrLn (show bar)
11:41:42 <kermitthehermit> That's the right one.
11:41:56 <SamB_XP> er, where is the instance for MonadPlus?
11:41:59 <edi> kermitthehermit: you can also take in consideration readIO
11:42:09 <tibbe> I need a simple library project idea
11:42:09 <Cale> putStr "Enter bar: " >> getLine >>= \barstr -> let (bar::Int) = read barstr in putStrLn (show bar)
11:42:11 <Cale> or
11:42:33 <Cale> do { putStr "Enter bar: "; barstr <- getLine; let (bar::Int) = read barstr; putStrLn (show bar) }
11:42:52 <Cale> kermitthehermit: do-notation is much cleaner for that, and it's translated directly into the code I gave there
11:42:56 <glguy> kermitthehermit: and don't forget that putStrLn (show x) is the same as print x
11:43:07 <Cale> right, that's the next thing to clean up :)
11:43:26 <edi> do { str <- getLine; (foo :: Int) <- readIO str; print foo }
11:43:29 <edi> !
11:43:35 <Cale> or that way  :)
11:43:38 <glguy> readLn
11:43:44 <Cale> yeah
11:43:49 <glguy> readLn does the same as readIO =<< getLine
11:44:21 <edi> even better
11:44:29 <Cale> so that's
11:44:32 <edi> do { foo <- readLn; print (foo :: Int) }
11:45:08 <ulph> how do i figure out what's wrong when my ghc programs segfault?
11:45:31 <edi> that's an embarassing question
11:45:34 <ulph> it seems kind of strange, it segfaults on a newIORef
11:45:51 * glguy /nick glguy-defender-of-the-prelude
11:46:26 <SamB_XP> ulph: are you using any of the unsafe* functions for array indexing?
11:46:52 <ulph> SamB: nothing unsafe anywhere.
11:47:00 <SamB_XP> huh
11:47:03 <ph8> for every word in my [String] list - i want to add that word, and the next word in the array into one list, then add the next next word and that list into a list
11:47:07 <SamB_XP> what saith gdb?
11:47:12 <ph8> in the format [[String, String] String]
11:47:18 <ph8> but that's based on a number, n
11:47:25 <ph8> is there a way to express that in code?
11:47:33 <ph8> or do i have to do a per-instance situation for n=3-10
11:47:36 <ph8> for example
11:47:54 <ph8> missed a comma above
11:49:06 <Cale> There needs to be a Web2.0 reddit
11:49:15 <glguy> What's not 2.0 about Reddit?
11:49:28 <Cale> I'm really tired of downmodding all these Web2.0 posts on programming reddit
11:49:33 <notsmack> ph8: that's a heterogeneous list, [] is homogenous
11:49:35 <glguy> AH
11:49:54 <ph8> notsmack: ah.
11:50:15 <tibbe> Cale, there needs to be a I'm-a-Haskler-so-drop-the-fluff category ;)
11:50:34 <glguy> or there could be a straight party line voting option
11:50:47 <glguy> like when you could just vote all republican or all democrat
11:50:48 <ulph> #0  0x0000000000430937 in newArrayzh_fast ()
11:50:48 <ulph> #1  0x0000000000666610 in MainCapability ()
11:50:53 <ulph> that's what gdb says
11:51:00 <glguy> "Mod all Haskell +1" "downmod all non-Haskell"
11:51:56 <ulph> i'm in ghc 6.6
11:52:38 <Cale> I've considered writing a tool which processes the XML feed and automatically downmods things containing keywords like Web 2.0, Agile, MySQL, Java, CSS, user-agent, DVD, Blu-Ray, Wii, Flash, etc.
11:52:50 <george> hi, this line: >		  | (x = 1)					= Just MkN{word = (getNth x a), precursors = [], firstWord = True, lastWord = False }     , is causing the error: ERROR "/home/george/haskell/ngrams.lhs":81 - Haskell 98 does not support extensible records
11:53:11 <george> can anyone tell me why? rthis may be needed too > data Ngram = MkN {word :: String, precursors :: [String], firstWord :: Bool, lastWord :: Bool}
11:53:23 <kermitthehermit> thanks
11:54:12 <kolmodin_> which Language.Haskell.Extension.Extension is the unpacked ints and stuff, the #-"operator", like Int16 = I16#  ?
11:54:16 <Cale> george: stick a $ between Just and MkN, or wrap it in parens
11:54:31 <Cale> (the MkN { ... })
11:56:13 <george> i have put $ between just and MkN still no help
11:56:21 <george> arrrrrg
11:56:23 <george> its x=1
11:56:24 <george> not ==
11:56:27 <Cale> oh
11:56:36 <Cale> ah, I see
11:56:52 <Cale> yeah, that's being misparsed as a Trac record.
11:56:58 <Cale> er, no
11:57:00 <Cale> TRex
11:57:04 <Cale> that's the name
11:57:11 <squiggles> Cale: Why are you so gay?
11:57:25 <Cale> squiggles: why are you so about-to-be-banned?
11:57:35 <squiggles> lolzomg ban
11:57:35 --- mode: ChanServ set +o Cale
11:57:49 --- mode: Cale set +b squiggles!*@*
11:58:02 --- mode: Cale set -o Cale
11:58:17 --- mode: ChanServ set +o Cale
11:58:28 <sorear> advice: check with '/msg chanserv #haskell access' before insulting someone
11:58:38 --- mode: Cale set +b *!*topaz@*
11:58:46 --- mode: Cale set -o Cale
11:58:48 <sjanssen> :)
11:58:48 <integral> No, don't insult people anyway.
11:59:09 <Cale> It doesn't matter that it was me he insulted, I'd have banned him regardless.
11:59:16 <george> ok if i am writing a show function for my data type Ngram as pasted 15 lines ago or so. i have so far: > show_Ngram m = "Word: '" ++ word m ++ "' Precursors:" ++ (myShowList $ precursors m) ++ "First? " ++ show firstWord ++ ", Last? " ++ show lastWord ++ "     "           , this is giving me an error however: Instance of Show (Ngram -> Bool) required for definition of show_Ngram
11:59:21 <ulph> @paste
11:59:21 <lambdabot> http://paste.lisp.org/new/haskell
11:59:27 <george> i thought it could show bool's easily?
11:59:35 <george> like True = "True"
11:59:46 <integral> george: (NGram -> Bool) isn't the same type as Bool :-)
11:59:47 <sjanssen> george: you're trying to show a function
12:00:05 <integral> you proibably just need some more ()s around the things between ++s
12:00:09 <george> im trying to show a customer data type
12:00:19 <lisppaste2> ulph pasted "2 line program that causes segmentation fault" at http://paste.lisp.org/display/32820
12:00:26 <ph8> george: you on callaghan's project as well?
12:00:26 <Cale>  show_Ngram m = concat ["Word: '", word m, "' Precursors:", myShowList $ precursors m, "First? ", show firstWord, ", Last? ", show lastWord, "     "]
12:00:36 <ulph> hm.. can't i write my program like that?
12:00:37 <Cale> use concat rather than lots of ++'s
12:00:47 <george> ph8: yes
12:01:00 <ph8> ah, your real nam's not george though is it?
12:01:03 <george> it is
12:01:10 <ph8> hmm.. how do i not know you?
12:01:23 <george> ph8: im the student who does physics and only one comp sci module
12:01:26 <ph8> ah
12:01:33 <ph8> you're way ahead of me by the sound of things anyway
12:01:41 <ph8> i'm trying to make the ngrams from a list of words :/
12:01:44 <george> who're you =) ?
12:01:53 <ph8> henri, if it helps
12:02:01 <edi> and your one and only cs module is about Haskell?
12:02:04 <edi> you're lucky! (:
12:02:14 <george> i know no one in this class
12:02:29 <ph8> type errors annoy me
12:02:34 <george> edi: yeah, it is the only module that i could meet the pre-requisites
12:02:46 <edi> which were?
12:02:49 <Saizan> ulph: works fine here with ghc 6.6
12:02:57 <ph8> > mapGramsInFile :: [String] -> Map [String] Int
12:02:57 * allbery_b has a few more wtf moments, catching up on -cafe
12:02:58 <lambdabot>  Not in scope: type constructor or class `Map'
12:03:12 <ph8> > mapGramsInFile (a:x) = insertWith incrementNum ([[a, head x], snd x]) 1 (mapGramsInFile x)
12:03:12 <ph8> ^ is bad for example
12:03:13 <lambdabot>  Parse error
12:03:13 <ph8> ah well, throw in an import
12:03:51 <Cale_> <Cale> ulph: it shouldn't segfault, but there is a bug in that code
12:03:53 <Cale_> <Cale> ulph: you're expected to pass a list of values to be used, but you pass an empty list.
12:03:57 <huschi> how can i use one monad in another?
12:03:58 <psnl> ph8: pass the link to the assignment
12:04:03 <george> cale: your show function is neater, but im still suffering the same error message
12:04:53 <huschi> e.g. how can i fail in the list monad if the computation in the maybe monad fails or return the value that was returned in the maybe monad?
12:05:30 <edi> ?type lift
12:05:31 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
12:05:39 <edi> hmm.
12:05:41 <ulph> Cale_: does the list have to be as large as the array? i had some values there before but i stripped them in the testcase
12:05:41 <Cale> yes, it should be.
12:05:41 <Cale> (I think at-least as large)
12:05:57 <ph8> bugger, did anyone answer me? my bnc just got disconnectd
12:05:57 <Cale> george: yes, I can't tell which of those shows is the problem
12:06:05 <sorear> Note that the array is created as 8GB on a 32-bit machine.
12:06:20 <Cale> george: the error message says that you forgot to apply a function to its parameter before passing it to show
12:06:30 <ulph> Cale: well newArray_ gives segmentation fault too.
12:06:34 <sorear> That will cause integer overflow in the bounds checking, and... congrats, you found a GHC bug!
12:06:50 <huschi> edi: was that answer for me?
12:06:53 <Cale> yeah, maybe try a smaller array :)
12:06:54 <sorear> newArray_ *does* initialize the array, with undefined.
12:07:20 <sorear> Boxed arrays must be valid at all times for the sake of the garbage collector.
12:07:22 <george> ahh yeah i see my error
12:07:24 <ski_> @hoogle maybeToList
12:07:25 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
12:07:33 <ski_> huschi : maybe that ^^ ?
12:07:45 <sorear> but do report this, it is a GHC bug.
12:07:46 <george> ph8: where are you in this project?
12:08:16 <Cale> Where's lispy?
12:08:16 <Saizan> show_Ngram m = concat ["Word: '", word m, "' Precursors:", myShowList $ precursors m, "First? ", show firstWord m , ", Last? ", show lastWord m, "     "] <-- this should work, you have to apply yhe accessors to the element, as you do with word
12:08:24 <huschi> ski_: but maybeToList gives me a list and i cannot call return with a list in th list monad.
12:08:31 <ulph> Saizan: maybe you have different minor version or something? hm
12:08:40 <Cale> (Jason Dagit)
12:08:43 <ulph> or maybe it's only on 64-bit
12:08:45 <ski_> huschi : then don't call 'return'
12:08:58 <huschi> ski_: thx, i just saw it :)
12:09:24 <Saizan> ulph: mmh --version reports only 6.6 i'm on 32bit windows however
12:10:23 <int-e> ulph: fun. newListArray (0, maxBound-8191) [] :: IO (IOArray Word32 Word32) results in a.out: internal error: getMBlock: mmap: Invalid argument; some intermediate values result in  a.out: internal error: allocGroup: requested zero blocks
12:10:29 <SamB_XP> Saizan: you can allocate 8 GB arrays on a 32-bit OS, successfully?
12:11:03 <ulph> int-e: haha :)
12:11:09 <Saizan> SamB_XP: i just compiled and runned ulph 2 lines paste, nothing more
12:11:09 <huschi> ski_: but that only works in the list monad.
12:11:14 <SamB_XP> > newListArray (0, maxBound) []
12:11:14 <lambdabot>  Not in scope: `newListArray'
12:11:22 <ulph> int-e: note that it seems to work if you index with Int instead of Word32
12:11:25 <SamB_XP> > array (0, maxBound) []
12:11:27 <lambdabot>  Add a type signature
12:11:32 <huschi> ski_: is there a more generic way, i could also use in the io monad?
12:11:33 <sorear> SamB: integer overflow.  The OS sees an attempt to allocate a 0 byte array.
12:11:37 <SamB_XP> > array (0, maxBound) [] :: Array Int ()
12:11:38 <lambdabot>  internal error: EVACUATED object entered!
12:11:39 <lambdabot>   Please report this as a bug to...
12:11:49 <SamB_XP> > array (0, maxBound-1) [] :: Array Int ()
12:11:50 <lambdabot>  internal error: EVACUATED object entered!
12:11:51 <lambdabot>   Please report this as a bug to...
12:11:57 <SamB_XP> > array (0, maxBound-10) [] :: Array Int ()
12:11:59 <lambdabot> Terminated
12:12:06 <SamB_XP> > array (0, maxBound-8) [] :: Array Int ()
12:12:09 <lambdabot> Terminated
12:12:13 <SamB_XP> > array (0, maxBound-7) [] :: Array Int ()
12:12:15 <lambdabot> Terminated
12:12:19 <SamB_XP> > array (0, maxBound-6) [] :: Array Int ()
12:12:21 <lambdabot> Terminated
12:12:30 <SamB_XP> anyway... crazy stuff...
12:12:37 <ski_> huschi : what should happen, on failure, in the io monad ?
12:12:49 <sorear> You should look into bytestring IO.  It'll do the Right Thing with binary data, and be much faster to boot.> array (0, maxBound) [(100000,())] :: Array Int ()
12:13:00 <sorear> > array (0, maxBound) [(100000,())] :: Array Int ()
12:13:02 <lambdabot>  internal error: EVACUATED object entered!
12:13:02 <lambdabot>   Please report this as a bug to...
12:13:06 <huschi> ski_: if the maybe monad fails the other monad shall also fail.
12:13:31 <sorear> > (array (0, maxBound) [] :: Array Int ()) ! 900000
12:13:33 <lambdabot> Terminated
12:13:33 <huschi> ski_: and if it returns the other monad shall return this value.
12:13:35 <integral> hrm, yhc doesn't seem to have its bytecode API implemented yet
12:13:46 <ulph> i'm implemeting the UM from the ICFP and it does like to work with Word32 though :)
12:13:57 <ski_> huschi : so you want it to call 'fail', then ? .. with what string ?
12:14:00 <ski_> > array (0,0) [] :: Array Int ()
12:14:01 <lambdabot>  Exception: (Array.!): undefined array element
12:14:04 <huschi> ski_: i could use a case statement but i'm sure there must be a better way.
12:14:24 <huschi> ski_: that's unimportant.
12:14:29 <SamB_XP> @type maybe
12:14:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:14:45 <SamB_XP> > maybe mzero return (Just 1)
12:14:46 <lambdabot>  add an instance declaration for (Show (m a))
12:14:51 <huschi> ski_: or instead of fail it could also call mzero.
12:14:54 <SamB_XP> > maybe mzero return (Just 1) :: [Int]
12:14:55 <lambdabot>  [1]
12:15:02 <ski_> @type maybe (fail "Foo !") return
12:15:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
12:15:11 <ski_> @type maybe mzero return
12:15:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
12:15:29 <huschi> ski_: thank you very much.
12:15:40 <SamB_XP> fail probably works better for the IO monad
12:15:51 <ski_> (that basically amounts to the same as a 'case', anyway, though)
12:15:55 <SamB_XP> @instances MonadPlus
12:15:56 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:16:01 <SamB_XP> huh
12:16:12 <SamB_XP> WTH is IO in MonadPlus?
12:16:33 <ski_> sacrilege !
12:16:52 <huschi> ski_: atm im writing a monad for xml-transformation. in this context calling mzero is ok.
12:17:53 <ski_> huschi : ok
12:18:32 <glguy> SamB_XP: MonadPlus IO is a nifty way to provide a sequence of IO actions to attempt (until one works)
12:18:45 <Saizan> what mzero looks like in IO?
12:18:47 <glguy> SamB_XP: readLn `mplus` putStrLn "That didn't work"
12:19:08 <SamB_XP> aren't there laws that MonadPlus is supposed to satisfy?
12:19:10 <glguy> mzero in IO is just a program stopping exception
12:19:25 <Saizan> suspected so
12:21:03 <ski_> SamB_XP : there's some disagreement on which ..
12:21:05 <ski_> http://www.haskell.org/hawiki/MonadPlus
12:21:06 <lambdabot> Title: MonadPlus - The Haskell Wiki
12:23:10 * ski_ thinks he would prefer 'MonadElse' instead of 'MonadOr' ..
12:24:25 <SamB_XP> okay, so, which laws doesn't IO satisfy...
12:25:18 <glguy>     *
12:25:23 <SamB_XP> okay, not "mzero is a right zero for >>="
12:25:26 <SamB_XP> er.
12:25:30 <SamB_XP> it doesn't satisfy that.
12:25:40 <glguy> Maybe satisfies Monoid, Left Zero, Right Zero and Left Catch
12:25:40 <glguy> [] satisfies Monoid, Left Zero, Right Zero and Left Distribution
12:25:41 <glguy> IO satisfies Monoid, Left Zero and Left Catch
12:26:32 <SamB_XP> I think Left/Right Zero are bad names
12:26:48 <SamB_XP> because mzero *is* a left and right zero for `mplus`
12:26:50 <glguy> You would prefer Left Identify?
12:27:10 <SamB_XP> not really
12:27:17 <ski_> 'Left Annulator' ?
12:27:18 <SamB_XP> Left Zero for >>=, maybe
12:27:41 * edwardk waves hello.
12:27:50 <edwardk> @users
12:27:51 <lambdabot> Maximum users seen in #haskell: 301, currently: 299 (99.3%), active: 56 (18.7%)
12:29:25 <notsmack> woah, 300!
12:29:34 <edwardk> yeah
12:29:34 <SamB_XP> @check \a b k -> mplus a b >>= (k :: Bool -> Maybe Bool) == mplus (a >>= k) (b >>= k)
12:29:36 <lambdabot>  Couldn't match `(->) Bool' against `Maybe'
12:29:39 <SamB_XP> hmm.
12:29:55 <SamB_XP> @check \a b k -> mplus a b >>= k == mplus (a >>= k) (b >>= k)
12:29:56 <lambdabot>    Occurs check: cannot construct the infinite type: b = a -> b       Expec...
12:30:19 <notsmack> edwardk: Before this battle is over... the world will know that few stood against many.
12:30:37 <SamB_XP> @check \a b k -> (mplus a b >>= k) == mplus (a >>= k) (b >>= k)
12:30:39 <lambdabot>     add an instance declaration for (Arbitrary (m a1), Show (m a1), Arbitr...
12:30:55 * Botje waves a trout around
12:30:55 <SamB_XP> @check \a b k -> (mplus a b >>= (k :: Bool -> Maybe Bool)) == mplus (a >>= k) (b >>= k)
12:30:57 <lambdabot>  Falsifiable, after 13 tests: Just False, Just True, <Bool -> Maybe Bool>
12:31:31 <SamB_XP> @scheck \a b k -> (mplus a b >>= (k :: Bool -> Maybe Bool)) == mplus (a >>= k) (b >>= k)
12:31:33 <lambdabot>   Failed test no. 47. Test values follow.: Just True, Just False, {True->Not...
12:31:39 <SamB_XP> ack
12:31:56 <SamB_XP> @tell dons lambdabot doesn't let smallcheck give enough output
12:31:57 <lambdabot> Consider it noted.
12:32:17 <ski_> @more
12:32:46 <SamB_XP> @tell dons @more only works vertically
12:32:47 <lambdabot> Consider it noted.
12:33:43 <Lemmih> Bulat doesn't use IRC, does he?
12:35:01 <SamB_XP> @scheck \a b k -> (mplus a b >>= (k :: Bool -> [Bool]) == mplus (a >>= k) (b >>= k)
12:35:02 <lambdabot>  Parse error
12:35:18 <littledan> why doesn't haskell have code as data like Lisp? is it because it isn't type safe?
12:35:21 <SamB_XP> @scheck \a b k -> (mplus a b >>= (k :: Bool -> [Bool])) == mplus (a >>= k) (b >>= k)
12:35:27 <lambdabot> Terminated
12:35:38 <kpreid> littledan: http://haskell.org/th/
12:35:40 <lambdabot> Title: Template Haskell
12:35:40 <SamB_XP> littledan: well, Haskell has syntax
12:35:44 <SamB_XP> that makes it more complicated
12:36:26 <kpreid> I disagree. Lisp has syntax, it's just in convenient layers :)
12:36:36 <littledan> kpreid, with TH, is it possible to make a show instance for functions in any way?
12:36:46 <SamB_XP> okay, okay, but the AST isn't good for much
12:36:55 <kpreid> no idea, I just know it exists.
12:37:00 <littledan> oh
12:37:06 <ski_> i believe not
12:37:12 <kpreid> also some Haskell implementations, iirc, have Show for functions
12:37:16 <kpreid> so does lambdabot:
12:37:22 <kpreid> > (++ "foo")
12:37:24 <lambdabot>  <[Char] -> [Char]>
12:37:36 <SamB_XP> kpreid: um... that doesn't show the function though
12:37:43 <kpreid> true
12:38:06 <SamB_XP> smallcheck sort-of can
12:38:16 <littledan> smallcheck?
12:38:18 <sorear> I gave a show instance for functions back in November
12:38:29 <SamB_XP> also see the recent post on differentiation by Oleg
12:38:41 <littledan> sorear, where is it?
12:38:53 <SamB_XP> it manages to reify compiled code into a typed AST
12:39:09 <SamB_XP> its almost necromancy
12:40:07 <ski_> @scheck \f xs -> (map f xs :: [Int]) == map f (reverse xs :: [Int])
12:40:08 <lambdabot>   Failed test no. 3. Test values follow.: {-3->0;-2->0;-1->-1;0->-2;1->-1;2-...
12:40:44 <SamB_XP> @scheck \f xs -> (map f xs :: [Bool]) == map f (reverse xs)
12:40:45 <lambdabot>  Add a type signature
12:40:59 <ski_> littledan : have you seen MetaML,MetaOcaml ?
12:41:08 <SamB_XP> @scheck \f xs -> (map f xs :: [Bool]) == map f (reverse xs :: [Bool])
12:41:10 <lambdabot>   Failed test no. 11. Test values follow.: {True->True;False->False}, [True,...
12:41:42 <ski_> @scheck \f b -> f b == not b
12:41:43 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
12:41:52 <littledan> ski_, I'll look at thosee
12:42:17 <SamB_XP> ski_: nice
12:43:14 <ski_> littledan : those basically do a typed version of quasiquote,unquote,eval
12:43:54 <SamB_XP> @scheck liftM2 (==) not
12:43:56 <lambdabot>   Failed test no. 1. Test values follow.: {True->True;False->True}, True
12:44:26 <sorear> from tunes 06.11.26
12:44:36 <ski_> SamB_XP =D
12:44:47 <sorear> instance (Enum a, Bounded a, Show b) => Show (a -> b) where show f = show [ f x | x <- [ minBound .. maxBound ] ]
12:44:51 <agocorona> littledan: I also would like to have lisp like features in haskell. we now have eval and dynamic typing
12:45:19 <SamB_XP> but the eval is kinda pathetic
12:45:31 <SamB_XP> it only works on *text*, doesn't it?
12:45:45 <ski_> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/code/week1/Finite.hs <- equality on functions
12:45:48 <lambdabot> http://tinyurl.com/v7chy
12:45:54 <ski_> SamB_XP : not in MetaML
12:45:56 <agocorona> SamB_XP: eval is  something in progress...
12:46:11 <SamB_XP> ski_: in hs-plugins, I meant
12:46:14 <ski_> ah
12:46:18 <SamB_XP> or were we talking about ghc-api
12:46:20 <SamB_XP> ?
12:46:41 <e-guru> I have an assignment here which says write a program which permutes the tuple (A,B,C,D) and not something else. The program should be based on three basic operations (a,b,c,d)=>(b,a,c,d) and (a,b,c,d)=>(c,b,a,d) and (a,b,c,d)=>(d,b,c,a) and no others create functions for permutations using those primitives... I didnt understand the part about the basic operations does anybody here understand?
12:47:19 <agocorona> eval now is very slow for some applications, since it invoques the ghc executable, but this will be inproved in the future (dons said)
12:47:19 <huschi> is there a function (>> return()) :: Monad m => m a -> m () defined in any module?
12:47:52 <araujo> huschi, There exist equivalents functions with suffix '_'
12:48:04 <araujo> For some operations
12:48:11 <araujo> For example, mapM_
12:48:39 <SamB_XP> > [\(a,b,c,d) -> (b,a,c,d), \(a,b,c,d) -> (c,b,a,d), \(a,b,c,d) -> (d,b,c,a)]
12:48:45 <lambdabot>  Add a type signature
12:48:51 <huschi> i need something like the meaning of _
12:49:03 <ski_> huschi : not that i know of .. i'd call a such 'ignore' myself
12:49:03 <SamB_XP> > [\(a,b,c,d) -> (b,a,c,d), \(a,b,c,d) -> (c,b,a,d), \(a,b,c,d) -> (d,b,c,a)] :: [(a,a,a,a) -> (a,a,a,a)]
12:49:05 <lambdabot>  Add a type signature
12:49:17 <SamB_XP> e-guru: well, have you had any assignments before?
12:49:32 <SamB_XP> @type [\(a,b,c,d) -> (b,a,c,d), \(a,b,c,d) -> (c,b,a,d), \(a,b,c,d) -> (d,b,c,a)]
12:49:33 <lambdabot> forall d. [(d, d, d, d) -> (d, d, d, d)]
12:49:51 <huschi> ski_: i think there are more people that need it.
12:50:20 <e-guru> SamB_XP: I finizhed all my assignments, I just dont understand what this one means when it says based on those operations
12:50:32 <SamB_XP> e-guru: you know permutations?
12:50:52 <SamB_XP> you know how you compose (or multiply) them together to get other permutations?
12:51:15 <edi> e-guru: that you define the functions the text gives, and then you define your answer using only those previously defined functions.  What part does not make sense?
12:51:28 <e-guru> SamB_XP: I know permutations but I dont know about composing or multiplying them to get more permutations?
12:51:46 <SamB_XP> e-guru: what is a permutation?
12:52:44 <e-guru> SamB_XP: it is the reordering of items to get all possible different orderings...no?
12:53:00 <edi> I think the point is defining all the possible permutations of four elements by composition of those three given permutations.
12:53:15 <SamB_XP> no. a permutation is just a way to reorder a certain number of items
12:53:59 <e-guru> hmm
12:54:40 <SamB_XP> each of those three things is a permutation
12:55:00 <e-guru> SamB_XP: yes they are, and I understand that I should use those permutations to create more?
12:55:17 <SamB_XP> yeah
12:55:37 <e-guru> SamB_XP: is there a name for this process?
12:55:40 <edi> the identity, the reverse, and everything in between
12:55:53 <araujo> > let u_ :: forall (m :: * -> *) b. (Monad m) => m b -> m b = (>>) (return ()) in u_ (Just 6)
12:55:53 <lambdabot>  Parse error
12:55:56 <SamB_XP> Let me look in this book
12:56:07 <araujo> huschi, ^^
12:56:45 <e-guru> SamB_XP: thank you, I hope its not so much trouble, if I know to look for, then I can go and read. thanks,
12:56:51 <edi> araujo: (>>) (return ()) is id restricted to Monad m => m a.
12:57:07 <SamB_XP> hmm, wrong book
12:57:08 <edi> I believe he wanted (>> (return ())) which is Monad m => m a -> m ().
12:57:29 * SamB_XP looks on wikipedia instead
12:57:32 <e-guru> edi: I just need to know the name of this process so I can read about it and learn. Obviously the reason that I dont understand the question is because I never heard of this before somehow...
12:58:28 <edi> e-guru: the composition of two permutations f and g is a permutation f . g
12:59:04 <edi> plan: first define f, g, and h, the permutations given to you by the book; then, define all the others combining these first three
12:59:30 <SamB_XP> oh, apparantly they call it a product
13:00:02 <edi> for example, try defining the identity permutation, the one that returns its argument in the same order it was given
13:00:09 <hyrax42> what is the space overhead of a list of an enumerated type with ghc?
13:00:11 <hyrax42> or lists in general
13:00:45 <SamB_XP> @google String overhead Haskell
13:00:48 <lambdabot> http://cvs.haskell.org/Hugs/pages/users_guide/observe.html
13:00:51 <hyrax42> I'm not seeing how I end up allocating around 1.2 GB of data during a run
13:00:51 <SamB_XP> hmm.
13:00:59 <SamB_XP> @google String overhead Haskell coutts
13:01:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/fusion.pdf
13:01:12 <glguy> ?fptools Text.Printf
13:01:13 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
13:01:34 <glguy> ?type printf
13:01:36 <lambdabot> forall r. (PrintfType r) => String -> r
13:01:59 <beschmi> e-guru: a permutation is a bijective function, the product of two permutations is just function composition
13:02:17 <edi> goodnight.
13:03:00 <SamB_XP> With the heap representation used by the Glasgow
13:03:00 <SamB_XP> Haskell Compiler (GHC) [14] on a 32 bit machine the [Char] type uses 12 bytes
13:03:00 <SamB_XP>  per character
13:03:50 <hyrax42> SamB_XP: thanks... just saw that myself
13:03:51 <hyrax42> wow
13:03:58 <mauke> that's not much
13:04:04 <SamB_XP> mauke: hmm?
13:04:18 <SamB_XP> well, its at least 3 times more than it needs to be
13:04:26 <hyrax42> not 12?
13:04:36 <sorear> compare ByteStrings, where in a typical European country strings are 1 - 1.2 bytes per character
13:04:40 <SamB_XP> well, I mean, 3 times more than you want
13:04:47 <hyrax42> word per char
13:04:48 <hyrax42> k
13:04:51 <mauke> 3 words: one for the char value, one for the next pointer, and you probably need some memory management information or tagging
13:04:53 <sorear> In China etc, 3-4 bytes per character
13:05:07 <hyrax42> well either way, I think that might explain how I end up with 1.2 GB of allocation
13:05:15 <SamB_XP> oh, and it says in this footnote that it would be 20 if the Chars weren't preallocated
13:05:39 <SamB_XP> but probably your type's constructors are preallocated too
13:05:41 <mauke> ok, so the "char value" is a pointer to a fixed location
13:06:46 <sorear> IIRC only characters 0-255 (NUL-ÿ (y-umlaut)) are preallocated, so it is 20 bytes per character in CJK etc.
13:06:51 <SamB_XP> it would be cool if we could have a class that a type could implement and you could store it in UArrays, IOUArrays and so on...
13:07:11 <SamB_XP> sorear: that makes sense
13:07:12 <sorear> That sounds feasible!
13:07:20 <mauke> Storable? :-)
13:07:22 <SamB_XP> it would be kind of strange to preallocate all...
13:07:38 <SamB_XP> > fromEnum (maxBound :: Char)
13:07:40 <lambdabot>  1114111
13:07:42 <SamB_XP> +1
13:07:44 <SamB_XP> characters...
13:07:48 <e-guru> no I still dont get it hmm...
13:07:52 <mauke> heh, just do it lazily
13:07:55 <sorear> 8MB of standard allocation!
13:08:11 <SamB_XP> mauke: then you'd need to do a linear search to find one!
13:08:51 <SamB_XP> do you have any idea how stupid it would be to have to do a linear search in ord?
13:08:58 <SamB_XP> er.
13:08:59 <SamB_XP> chr
13:09:03 <sorear> data Tree s where Leaf :: Char -> Tree Zero ; Fork :: Tree a -> Tree a -> Tree (Succ a)
13:09:04 <ulph> is it possible to write a Haskell program for UM that can run sandmark.umz at a "reasonable" speed? I think I need to look into some performance tweaks ;)
13:09:25 <SamB_XP> @where um
13:09:25 <lambdabot> I know nothing about um.
13:09:27 <SamB_XP> @where ums
13:09:27 <sorear> chars :: Tree TwentyOne
13:09:27 <lambdabot> I know nothing about ums.
13:09:34 <sorear> ?where icfp
13:09:35 <lambdabot> I know nothing about icfp.
13:09:39 <SamB_XP> @google dons um
13:09:41 <lambdabot> http://www.cstv.com/sports/w-tennis/stories/032806aav.html
13:09:41 <lambdabot> Title: USF Women's Tennis Splits First Two Matches at UC Irvine Invitational :: Dons De ...
13:09:52 <ulph> http://icfpcontest.org/um-spec.txt
13:10:06 <wchogg> I worked on a Haskell implementation of that UM.  It didn't work so good.
13:10:12 <wchogg> It was still fun to try, though.
13:10:17 <SamB_XP> @google site:http://cgi.cse.unsw.edu.au/~dons um
13:10:19 <lambdabot> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16
13:10:19 <lambdabot> Title: Haskell hacking
13:10:26 <SamB_XP> @google site:http://cgi.cse.unsw.edu.au/~dons UMs
13:10:27 <lambdabot> No Result Found.
13:10:28 <ulph> My program works.. but well. It's just a bit too slow ;)
13:10:31 <SamB_XP> @google site:http://cgi.cse.unsw.edu.au/~dons haskell um
13:10:33 <lambdabot> http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/16
13:10:33 <lambdabot> Title: Haskell hacking
13:10:36 <SamB_XP> ack.
13:11:26 <wchogg> Does anyone know who the actual contact person is for House?  I found a list of people associated with Programmatica, but not really *a* person to contact about it.
13:11:34 <SamB_XP> @ask dons where his list of UMs went
13:11:35 <lambdabot> Consider it noted.
13:11:41 <ulph> hm
13:11:48 <SamB_XP> ulph: honestly I don't know
13:11:58 <e-guru2> SamB_XP sorry, something happened and I couldnt see anything after you said that you should look it in book...
13:12:27 <SamB_XP> I was using a lousy algorithm to allocate array numbers when I wrote my dirty C version
13:12:38 <SamB_XP> which is very similar to everyone else's dirty C versions
13:13:29 <kermitthehermit> Does hugs use standard let notation in a punctuated do block?
13:13:29 <kermitthehermit> I'm getting Syntax error in declaration (unexpected symbol "putStrLn")
13:13:29 <kermitthehermit> from this:
13:13:29 <kermitthehermit> main = do { let msg = "Hello"; putStrLn msg;
13:13:29 <kermitthehermit> }
13:13:31 <kermitthehermit> The Haskell 98 report says that's right, and the "Conformance" section in the hugs manual doesn't mention it.
13:13:53 <e-guru> SamB_XP: is there a name for this process?
13:13:58 <e-guru> SamB_XP: thank you, I hope its not so much trouble, if I know to look for, then I can go and read. thanks,
13:14:03 <SamB_XP> apparantly "product"
13:14:04 <e-guru> edi: I just need to know the name of this process so I can read about it and learn. Obviously the reason that I dont understand the question is because I never heard of this before somehow...
13:14:15 <e-guru> SamB_XP: thanks, I will check it out
13:14:18 <SamB_XP> @google permutation wikipedia
13:14:20 <lambdabot> http://en.wikipedia.org/wiki/Permutation
13:14:21 <lambdabot> Title: Permutation - Wikipedia, the free encyclopedia
13:14:21 <bringert> wchogg: I don't know, but Thomas Hallgren gave a presentation about House in our department last week
13:14:32 <glguy> Does anyone know enough about how printf works to help me through writing a function that behaves like liftMn, allowing you to write:   iI (/) sum genericLength Ii
13:14:44 <glguy> as discussed in the paper on the applicative class?
13:15:27 <SamB_XP> @type ap
13:15:29 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
13:16:20 <sorear> glguy : that can't be done w/o -fincoherent-instances (at least not in the printf style)
13:16:25 <glguy> hmm
13:16:30 <glguy> > (return (/) `ap` sum `ap` genericLength) [1,2,3,10]
13:16:32 <lambdabot>  4.0
13:16:40 <ski_> glguy : hm, istr liyang doing something with TH in that direction
13:16:41 <glguy> sorear: what would be a better style?
13:16:42 <SamB_XP> okay.
13:16:54 <sorear> glguy : a -> b is a monad, and a non-overlapping class cannot distinguish functions from monads.
13:17:08 <SamB_XP> sorear: so?
13:17:28 <SamB_XP> that doesn't involve anything like that, does it?
13:17:29 <sjanssen> sorear: Text.Printf uses incoherent instances?
13:17:39 <sorear> you *could* write said function, but (a) is would require -fallow-incoherent-instances and (b) it would fail miserably in the (->) a monad.
13:17:51 <sjanssen> it seems possible to me, if you're willing to write the Ii at the end
13:17:54 <SamB_XP> sorear: you must speak more clearly
13:17:56 <glguy> sure
13:18:07 <glguy> the Ii works well to counter the iI
13:18:14 <sorear> d'oh! didn't notice the Ii
13:18:17 <SamB_XP> heh
13:18:23 <kermitthehermit> Got in.  Hugs likes "in" instead of ";"
13:18:24 * SamB_XP isn't really sure how that will help
13:18:26 <edwardk> glguy: heffalump made pretty good progress on something like that that used template haskell and a fake function named run : Monad m => m a -> a
13:18:48 <kermitthehermit> I mean got IT.
13:18:50 <sjanssen> I think it could be easily done with type classes
13:18:59 <ski_> edwardk : hm ?
13:19:01 * sjanssen looks for Oleg posts about variadic functions
13:19:02 <kolmodin_> ?paste
13:19:02 <lambdabot> http://paste.lisp.org/new/haskell
13:19:04 <SamB_XP> sjanssen: that was the proposed technique, yes
13:19:05 <glguy> Ii could be an instance of the class in the same way that STring is an instance of PrintfType
13:19:27 <SamB_XP> @instances PrintfType
13:19:29 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:19:35 <SamB_XP> @instances Text.Printf.PrintfType
13:19:47 <glguy> instance (IsChar c) => PrintfType [c] where spr fmt args = map fromChar (uprintf fmt (reverse args))
13:19:48 <edwardk> ski: for a more 'functional' syntax for monadic code.
13:19:53 <SamB_XP> @instances-importing Text.Printf PrintfType
13:19:54 <lambdabot> (a -> r), IO a, [c]
13:20:00 <glguy> instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) where spr fmt args = \ a -> spr fmt (toUPrintf a : args)
13:20:02 <ski_> edwardk : any link ?
13:20:12 <edwardk> ski: you'd have to check the back logs here
13:20:18 <edwardk> i'm pretty sure he never finished it
13:20:20 <e-guru> edi: did you have any suggestions also? I got timed out a little while ago
13:20:27 <edwardk> ran into some issues with lambdas or something
13:20:30 <SamB_XP> ah, right. that one.
13:20:30 <ski_> edwardk : how long ago
13:20:34 <ski_> ?
13:21:07 <edwardk> ski: guessing 2 months ago? right after the ad hoc haskell get together in cambridge
13:21:14 <SamB_XP> > (return (/) `ap` (sum `ap` genericLength)) [1,2,3,10]
13:21:15 <lambdabot>  add an instance declaration for (Num (i -> b))
13:21:15 <lambdabot>   In the list element: 10
13:21:20 <edwardk> maybe my timesense is screwed though
13:21:25 <SamB_XP> > ((return (/) `ap` sum) `ap` genericLength) [1,2,3,10]
13:21:26 <lambdabot>  4.0
13:21:28 <glguy> SamB_XP: left assoc
13:21:32 <SamB_XP> yeah.
13:21:40 <SamB_XP> okay.
13:21:47 <ski_> edwardk : ty
13:21:48 <SamB_XP> @type printf "Hello!"
13:21:50 <lambdabot> forall r. (PrintfType r) => r
13:22:01 <SamB_XP> @type printf "Hello!" 1
13:22:04 <lambdabot> forall t t1. (PrintfType (t -> t1), Num t) => t1
13:22:31 <SamB_XP> @type printf "Hello!" 1 2 3
13:22:33 <lambdabot> forall t t1 t2 t3. (PrintfType (t -> t1 -> t2 -> t3), Num t, Num t1, Num t2) => t3
13:22:37 <sjanssen> hmm, apparently Oleg invented the | x `seq` False = undefined trick
13:22:53 <SamB_XP> hmm.
13:22:55 <ulph> writeArray and readArray are always O(1) on the IOArray right?
13:23:14 <SamB_XP> glguy: so, have you figured out which end to start at?
13:23:26 <SamB_XP> or which end to end at?
13:23:28 <glguy> SamB_XP: left, since the left side gets treated differently
13:23:37 <glguy> and then stuff gets stacked from left to right
13:23:50 <littledan> who's Oleg?
13:23:51 <glguy> iL takes the first argument and has to wrap it in a return
13:23:56 <glguy> or iI rather
13:24:18 <SamB_XP> :t return (/)
13:24:20 <lambdabot> forall (m :: * -> *) a. (Monad m, Fractional a) => m (a -> a -> a)
13:24:33 <SamB_XP> :t return (/) `ap` sum
13:24:35 <lambdabot> forall a. (Fractional a) => [a] -> a -> a
13:24:42 <SamB_XP> :t return (/) `ap` sum `ap` genericLength
13:24:43 <lambdabot> forall i. (Fractional i) => [i] -> i
13:26:12 <SamB_XP> @type printf
13:26:14 <lambdabot> forall r. (PrintfType r) => String -> r
13:26:28 <SamB_XP> hmm. so...
13:26:41 <SamB_XP> what is your IIType?
13:26:45 <glguy> you'd have to compare iI to printf
13:27:02 <SamB_XP> or, er, where does it fit...
13:27:28 <glguy> iI :: (ApplicativeType t) => a -> t
13:27:32 <glguy> I believe
13:27:39 <SamB_XP> hmm.
13:27:41 <cjeris> littledan: Oleg Kiselyov, a programming language hacker.  someone a while back proposed that some kind of implementation cleverness be measured in milliolegs.
13:27:49 <SamB_XP> Doesn't the function type have to fit in somewhere?
13:28:02 <glguy> a is the type of the returned function
13:28:16 <glguy> a might be Int -> [Int]
13:28:31 <SamB_XP> well. won't ApplicativeType need to know about it?
13:28:35 <retybok> ddd
13:28:44 <glguy> SamB_XP: I'm not sure yet :)
13:29:04 <ski_> littledan : http://okmij.org/ftp/
13:29:06 <lambdabot> Title: This FTP site
13:29:36 <littledan> ski_ he wrote all that?
13:30:16 <SamB_XP> he writes things all the time
13:30:41 <SamB_XP> but instead of blogging, he emails them to the haskell mailing list
13:34:46 <ski_> littledan : yes
13:37:16 <littledan> is he a god or something?
13:37:36 <SamB_XP> not quit
13:37:38 <SamB_XP> er.
13:37:39 <SamB_XP> not quite
13:37:52 <SamB_XP> he's well known for programming the type system
13:40:19 <notsmack> anybody understand happs?
13:41:12 <Vq^> probably
13:41:42 <notsmack> i'm playing around with it, working off of the hello.hs example, but i'm confused about how side effects work
13:42:15 <notsmack> i'm trying to get the current time in evh and store it in the state, but i guess i can't because that puts me in IO?
13:42:26 <sjanssen> @where paste
13:42:27 <lambdabot> http://paste.lisp.org/new/haskell
13:42:54 <e-guru> SamB_XP: I got stuck again, I cant get anywhere by product of permutations. I am stupid I guess...
13:43:05 <lisppaste2> sjanssen pasted "a start to solving glguy's problem" at http://paste.lisp.org/display/32832
13:43:19 <SamB_XP> e-guru: I don't suppose you own a copy of Sorting and Searching?
13:44:35 <glguy> sjanssen: *reading*
13:44:38 <notsmack> maybe i should be using simpleHTTPIO instead of simpleHTTP
13:45:18 <e-guru> No, I have a haskell book only from simon thompson
13:46:27 <e-guru> SamB_XP: I still dont understand how to get all permutations ONLY by using those 3 basic operations given
13:47:20 <glguy> sjanssen: is that applying ap in the correct direction?
13:47:26 <sjanssen> glguy: maybe not
13:47:34 * sjanssen didn't test his code
13:49:21 <SamB_XP> sjanssen: that is not smart when type programming
13:49:44 <SamB_XP> the typechecker won't check for type errors unless you write code that has those type errors
13:53:33 <shoffsta> I have a function with type IO CGIResult -> IO CGIResult, where I need a CGI CGIResult -> CGIResult. Is there a way to convert one into the other?
13:53:59 <Taral> Not without breaking the system purity.
13:54:09 <Taral> Are you sure it's not CGIResult -> IO CGIResult?
13:54:35 <Taral> anyway, it's possible but highly inadvisable to strip IO off things.
13:54:44 <Taral> You can end up with very bad behavior.
13:54:47 <shoffsta> uhm, yes that's what ghc tells me
13:55:11 <Taral> The IO mark means that the function in question can do I/O operations.
13:55:23 <Taral> If you need it to be non-IO, then you need to take the IO out.
13:55:43 * glguy imagines this is more of a case of not knowing what function to call than not understandign IO
13:55:48 <glguy> but I've been wrong before
13:57:11 <shoffsta> hmm, I see
14:00:31 <SamB_XP> shoffsta: mmm, why do you need to do that?
14:01:08 * SamB_XP wonders if liftIO might help
14:01:26 <shoffsta> ?paste
14:01:27 <lambdabot> http://paste.lisp.org/new/haskell
14:03:16 <lisppaste2> shoffsta pasted "Monad problems..." at http://paste.lisp.org/display/32838
14:04:59 <shoffsta> I'm trying to handle sql error messages, where handleSql has the type '(SqlError -> IO a) -> IO a -> IO a'
14:06:26 <scodil> shoffsta: what does p << seErrorMsg x do ?
14:07:24 <shoffsta> scodil: it creates a XHtml paragraph
14:08:02 <shoffsta> scodil: which can then be converted to a String using renderHtml
14:08:51 <scodil> does seErrorMsg have type x -> IO () ? cause if not, i think you mean <-, or maybe just (seErrorMsg x)
14:09:21 <scodil> << produces no values
14:09:46 <fnord123> where might i find documentation on the -< arrow?
14:09:52 <fnord123> it's not all that googlable
14:09:52 <scodil> oh shit nm
14:09:56 <scodil> i'm way off the mark
14:10:03 <scodil> << is an entirely different operator
14:10:04 <shoffsta> << is an XHtml construct
14:10:12 <scodil> yeah just hoogled it. sorry. ignore me
14:10:18 <shoffsta> :)
14:12:23 <fnord123> bbl
14:12:59 <lisppaste2> sjanssen annotated #32832 with "closer . . ." at http://paste.lisp.org/display/32832#1
14:14:52 <emu> i'm in a bit of a conundrum here with a some data types which are instances of a particular class.  i want to have some command-line option processing code which chooses the datatype based on command-line input.  However, writing code such that (Class a) => String -> a, doesn't seem to be quite working
14:15:46 <kpreid> emu: you need an existential wrapper
14:15:56 <emu> probably
14:16:06 <emu> trying to figure out how to phrase it. that or Dyn
14:16:25 <kpreid> String -> AnyMyClass
14:16:37 <inv2004> hi all
14:16:43 <emu> what's AnyMyClass precisely?
14:16:46 <kpreid> data AnyMyClass = forall a. MyClass a => AnyMyClass a
14:16:57 <emu> hmm
14:16:59 <kpreid> (I may have the constructor in the wrong spot)
14:17:12 <kpreid> then your function is like:
14:17:49 <integral> I'm continually annoyed that: data AnyBox c = forall a. c a => AnyBox a -- doesn't work :-(
14:17:51 <kpreid> f "Foo" = AnyMyClass FooConstr; f "Bar" = AnyMyClass BarConstr
14:18:02 <emu> this is further complicated by a multi param type class / func dep.  so it's really MyClass s a
14:18:19 <inv2004> if where is an error in patter matching, hugs outputs "Program error: pattern match failure: fun_sum [Syntax_Sn "_"] ++ map_v781 (eval_v3851 (Context_Context" and many more lines of code, its not possible to understand what is it. is it possible to output not lazy expression here?
14:18:35 <emu> kpreid: i should be able to just say forall s a. ?
14:18:40 <kpreid> emu: yes
14:19:01 <sjanssen> integral: you want a class kind?
14:19:07 <integral> sjanssen: Yep
14:19:29 <sjanssen> interesting
14:19:41 <sjanssen> I think that would allow higher order type programming
14:20:06 <emu> heh
14:20:26 <emu> ghc error message: my brain just exploded: I can't handle pattern bindings for existentially quantified constructors.   ok -- won't do that =)
14:21:58 <emu> i realize that existential types will hide the variable, how then would i extract the user's selection?
14:22:12 <inv2004> looks like the only way is to moved to ocaml. finding patters error takes too much time :(
14:22:23 <integral> emu: case box of { AnyMyClass x -> some_method_of_the_typeclass x }
14:22:27 <Cale> emu: use case, not let
14:22:40 <kpreid> emu: you can only use methods of the typeclass
14:22:49 <sjanssen> inv2004: hmm?
14:22:53 <Cale> well, that's not quite true
14:22:58 <inv2004> sjanssen: ?
14:23:06 <Cale> You can use any polymorphic function built with them too.
14:23:20 <kpreid> er, right
14:23:21 <inv2004> pattern error
14:23:27 <sjanssen> inv2004: you have some code that is resulting in a pattern error?
14:23:51 <inv2004> y, but is it possible to make hugs to output smth smaller ?
14:24:02 <Cale> inv2004: hmm?
14:24:25 <inv2004> where I can input code ?
14:24:28 <inv2004> insert
14:24:40 <Cale> lisppaste2: url
14:24:40 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
14:24:44 <inv2004> thx
14:24:59 <glguy> lol, well done Cale, I wasn't sure where that was going
14:25:06 <lisppaste2> inv2004 pasted "pattern error" at http://paste.lisp.org/display/32841
14:25:19 <glguy> *whoa*
14:25:39 <kermitth1hermit> myGrid // [( row, (myGrid!row)//[(col,newVal)] )]
14:25:42 <Cale> okay, don't use hugs, the runtime errors are confusing
14:25:43 <sorear> inv2004: turn on all warnings, and GHC will tell you where there is a possibility of pattern match failure.
14:25:53 <inv2004> I use hugs
14:26:03 <Cale> I know, I can tell from the structure of the error
14:26:05 <sjanssen> inv2004: whoa, is that a line of your source code?
14:26:18 <inv2004> no no
14:26:19 <Cale> Load your program with ghci and you'll get a better error message
14:26:26 <inv2004> its the error message
14:26:31 <sjanssen> ah, maybe this is a hugs bug?
14:26:39 <inv2004> ok, thx. I'll try GHCi
14:26:46 <inv2004> sjanssen: y, it is
14:27:05 <inv2004> I don't think bug, maybe feature ? :)
14:27:19 <glguy> what's all this 'y' business?
14:27:23 <sjanssen> inv2004: in this channel y = \f -> f (y f), if you mean "yes", you might want to spell it out :)
14:27:55 <inv2004> yes = y
14:28:05 <inv2004> ok :)
14:28:12 <glguy> orly?
14:28:22 <kermitth1hermit> Did anybody answer me?  Sorry, my dialup got cut off.
14:28:34 <kermitth1hermit> Isn't that kind of clunk?
14:28:35 <glguy> kermitth1hermit: you didn't ask a question..
14:28:40 <kermitth1hermit> I mean clunky?
14:28:54 <Cale> glguy: I read that as a sort of adverbial form of 'or'
14:29:06 <Cale> or-ly
14:29:13 <kermitth1hermit> Isn't there a less clunky way to update a multi-D array?
14:29:26 <glguy> (followed typically by: yarly! and nowai!
14:29:39 <Cale> kermitth1hermit: How is updating a multi-D array any different from updating a 1-D array?
14:29:42 <sjanssen> kermitth1hermit: use Array (i, i) e instead of Array i (Array i e)
14:29:50 <Cale> oh, you're doing it wrong, I seee
14:29:58 <Cale> yeah, use pairs as indices :)
14:30:14 <sorear> haskell doesn't use arrays of arrays.
14:30:16 <glguy> > listArray ((0,0),(3,3)) (repeat 0)
14:30:18 <lambdabot>  array ((0,0),(3,3)) [((0,0),0),((0,1),0),((0,2),0),((0,3),0),((1,0),0),((1,1...
14:30:25 <mauke> http://adrinael.net/wrong.jpg
14:30:30 <Cale> Well, you can have an array of arrays, but it's kind of silly to do it.
14:30:42 <glguy> mauke: LOL
14:30:50 <inv2004> lol :)
14:31:13 <kermitth1hermit> Oh, that's much better.  So is that closer to a C array?
14:31:23 <glguy> no, C arrays are arrays of arrays
14:31:50 <Cale> You can use any type in the class Ix to index your arrays in Haskell.
14:31:59 <inv2004> GHCi is cool too: *** Exception: Base.hs:17:0-46: Non-exhaustive patterns in function fun_sum
14:32:13 <Cale> inv2004: okay, so let's look at fun_sum
14:32:23 <Cale> and see what patterns aren't being matched
14:32:29 <glguy> ?where+ wrong http://adrinael.net/wrong.jpg
14:32:30 <lambdabot> Done.
14:32:36 <newsham> > let f (Just 3) = "woo" in f Nothing
14:32:37 <lambdabot>  Non-exhaustive patterns in function f
14:32:52 <inv2004> Cale: its easy: fun_sum (Snum n1:Snum n2:[]) c = Snum (n1 + n2)
14:33:03 <newsham> inv: what is fun_sum [] ?
14:33:21 <newsham> [] doesnt match (Snum n1:Snum n2:[])
14:33:26 <glguy> newsham: *** Exception: Base.hs:17:0-46:
14:33:29 <inv2004> no, of course
14:33:30 <glguy> (-;
14:33:32 <notsmack> nor does Snum1:[]
14:34:00 <inv2004> I try to find when it happens
14:34:01 <Cale> inv2004: you might also want to know that you can write that like fun_sum [Snum n1, Snum n2] c = ...
14:34:09 <inv2004> nono
14:34:09 <kermitth1hermit> I thought a C array was all contiguous locations.  p++ works between rows.
14:34:18 <newsham> nor does fun_sum [Snum 1, Snum 2, Snum 3]
14:34:20 <inv2004> it should be Snum n1:Snum 2:[]
14:34:28 <Cale> inv2004: yes, that's the same as
14:34:34 <Cale> [Snum n1, Snum n2]
14:34:38 <kermitth1hermit> where p points to elements.
14:34:43 <notsmack> kermitth1hermit: only if it's defined as one long 1D array, i think...
14:34:44 <inv2004> [Snum n1, Snum n2] - is the same, yes
14:34:58 <Cale> (and it's okay to match the pattern like that)
14:35:01 <newsham> kermit: they are contiguous.  char[] is contiguous, and (char[5])[] is also contiguous
14:35:15 <Cale> so what's happening is that a list of length other than 2 is being passed in
14:35:34 <inv2004> Cale, its not possible
14:35:38 <glguy> lol
14:35:41 <Cale> if you want to ensure that you have exactly n of something, it's a bad idea to make a list of them
14:35:45 <glguy> ?quote lambdabot
14:35:45 <lambdabot>  lambdabot hasn't said anything memorable
14:35:46 <newsham> inv2004: when you've ruled out the possible, consider the impossible.
14:35:51 <glguy> ?quote ghc
14:35:51 <lambdabot>  Bad eta expand
14:35:53 <glguy> ?quote ghc
14:35:54 <lambdabot>  Can't represent explicit kind signatures yet
14:35:58 <Cale> inv2004: It's what's actually happening
14:36:14 <inv2004> Cale: I didn't find other solution of the task
14:36:23 <glguy> I'm going to use that one on my boss when something breaks at work
14:36:29 <SamB_XP> which was it that was more likely? the impossible probable or the improbable possible?
14:36:30 <Cale> That, or a list of length 2, one of whose elements doesn't match Snum k is being passed in
14:36:43 <inv2004> one know that one of the values is not Snum, maybe Serr or smth else
14:36:45 <newsham> inv:  sum_fun [] = error "not possible!"
14:36:56 <Cale> fun_sum [Syntax_Sn "_"]
14:36:59 <sorear> inv2004: non-exhaustive patterns are inexoribly followed by debugging nightmares.
14:37:00 <inv2004> one = I
14:37:06 <Cale> hugs mentioned that it's being called like that
14:37:31 <Cale> with only one element, which also doesn't even match Snum k
14:37:32 <sylvan> When I visit haskell.org without being logged in, the "autonumber headings" options is turned on... Is that accidental? I really don't think it looks right for the front page...
14:37:35 <sjanssen> sorear: ah, they're not always that bad
14:37:36 <SamB_XP> are they?
14:37:38 <newsham> sum_fun xs = error ("not possible: " ++ show xs)
14:37:40 <sjanssen> when you're lucky
14:37:42 <SamB_XP> sorear: what about catch?
14:37:43 <newsham> might be helpful?
14:37:49 <Cale> newsham: yeah
14:38:25 <Cale> hugs prints a huge amount of junk context there.
14:38:37 <lisppaste2> metaperl pasted "why are all the data types listed in the module header? what does this do?" at http://paste.lisp.org/display/32842
14:38:42 <Cale> really, the problem is that fun_sum [Syntax_Sn "_"] is being called
14:38:50 <Excedrin> is there a convenient way to parse command line args and build a list of operations to do based on them?
14:38:52 <inv2004> newsham: thx!. I think it a good solution
14:38:58 <inv2004> its
14:39:06 <sjanssen> metaperl: those are the things the module exports
14:39:12 <Cale> metaperl: it exports them
14:39:24 <metaperl> ok, what if that list of types were not there?
14:39:40 <Cale> Well, the default is to export everything.
14:39:45 <inv2004> I thought that hugs can output smth like "error ("not possible: " ++ show xs)" automatically
14:39:47 <sjanssen> metaperl: if it were "module Types () where ..." then nothing would be exported
14:39:58 <sjanssen> metaperl: omit the () and everything is exported
14:39:59 <glguy> Excedrin: System.Console.GetOpt
14:40:03 <metaperl> i see. Ok thanks for your help sjanssen and Cale
14:40:31 <Cale> inv2004: It did, it just printed a bunch of confusing garbage afterward
14:41:12 <glguy> inv2004: we spell it "something"
14:41:20 <inv2004> y, if i calculate that carbage it would be Sn "_"
14:42:03 <Cale> inv2004: well, you ignore the garbage, it's just stuff that's going to be concatenated with the result of the thing which failed.
14:42:23 <inv2004> yes, you're right
14:42:58 * inv2004 removed GHCi again
14:44:07 <Cale> I like the way that paste twinkles with paren matching colours as you move the mouse cursor over it :)
14:44:25 <SamB_XP> yeah
14:44:32 <SamB_XP> it uses a neat trick for that
14:45:11 <SamB_XP> <span class="paren<thing>">(<span class="somethingmoreordinary">...</span>)</span>
14:45:13 <sorear> Mouse cursor? what's that? :)
14:45:31 <SamB_XP> sorear: that crosshairs in Quake
14:47:49 <Cale> http://thedailywtf.com/forums/thread/107330.aspx
14:47:51 <lambdabot> Title: The Daily WTF - [CodeSOD] How Not to Parse Command Line Arguments
14:47:53 <Cale> hahaha
14:48:37 <glguy> I thought that was a pretty clever way to get around Java having a crappy switch statement
14:49:03 <inv2004> lol
14:49:25 <newsham> it would be nice if GHC gave a more meaningful error on a pattern mismatch.
14:50:42 <Cale> glguy: It would have been smarter to at least include the code to hash those strings in the cases.
14:50:46 <SamB_XP> newsham: would be hard though
14:51:08 <Cale> oh, perhaps Java can't even do that.
14:51:14 <newsham> i guess the ultimate solution is better debugging infrastructure that lets you examine how you reached an error.
14:51:16 <Excedrin> Java switch only works on ints?
14:51:17 <SamB_XP> it would essentially require a Show instance in the info table, wouldn't it?
14:51:22 <metaperl> is there a function to give a frequency count for a list? E.g., freqCount [ 1,1,3,4,5,5,] = [(1,2), (3,1), (4,1), (5,2)]
14:51:30 <newsham> sam: i have no idea.  whats the info table?
14:51:42 <sjanssen> metaperl: no, but you can roll your own pretty easily
14:52:07 <newsham> metaperl: didnt we walk through an implementation of that on this channel about 2-4 weeks ago?
14:52:15 <SamB_XP> newsham: well, it identifies the constructor
14:52:24 <mq_mattr> on the daily wtf
14:52:25 <SamB_XP> newsham: and the layout
14:52:31 <mq_mattr> I think they are being a bit tough
14:52:34 <metaperl> hmm, i recall our conversation... let me research
14:52:39 <sjanssen> > map (\xs -> (head xs, length xs)) . group . sort $ [1,1,3,4,5,5]
14:52:40 <lambdabot>  [(1,2),(3,1),(4,1),(5,2)]
14:52:42 <SamB_XP> (if any constructor)
14:52:48 <newsham> you had a problem where you were counting how many of a thing were in a list.
14:53:00 <SamB_XP> newsham: basically, every heap value has one
14:53:02 <Pseudonym> metaperl: If you're feeling creative, we could do with a standard Data.Bag.
14:53:03 <mq_mattr> there could be very reasonable reasons the code looks like that
14:53:17 <Pseudonym> It's overkill for what you want, but it'd be damn useful.
14:53:31 <Pseudonym> http://www.di.uminho.pt/~joostvisser/software/UMinhoHaskellSoftware-1.0/Data.Bag.html
14:53:31 <newsham> sam: ahh.   i'm not at all familiar with GHC internals (other than hearing the world "spineless-tagless g machine" and having a rough understanding of how haskell turns into lambdas.
14:53:34 <lambdabot> http://tinyurl.com/yn99ac
14:53:38 <Pseudonym> That's not so bad, but it's a bit light on operations.
14:53:48 <SamB_XP> hmm.
14:53:49 <glguy> I believe that Java switch only works on constant values
14:53:52 <Pseudonym> Like Bag a -> [(a,Int)]
14:53:52 <SamB_XP> what operations do we want?
14:54:03 <mq_mattr> glguy: yep
14:54:10 <glguy> Most of the dailywtfs aren't as bad as the comments that people leave after them
14:54:16 <mq_mattr> which is a language problem
14:54:18 <Pseudonym> SamB_XP: We want operations similar to Data.Set.
14:54:23 <Pseudonym> At least that expressive.
14:54:30 <mq_mattr> glguy: yeah, it smacks of the worst kind of arrogance
14:54:33 <SamB_XP> newtype Data.Bag.Bag a = Bag (M.Map a Int)
14:54:34 <SamB_XP> anyway
14:54:46 <glguy> mq_mattr: the kind where the arrogant person is wrong?
14:54:47 <SamB_XP> Pseudonym: but what does union do?
14:55:08 <Excedrin> the dailywtf catchphrases are annoying
14:55:13 <mq_mattr> glguy: perhaps not wrong, but overshooting their skills/knowledge/experience
14:55:31 <glguy> mq_mattr: ah, I usually notice them laughing at the wrong aspect of the story or code
14:55:43 <mq_mattr> glguy: yeah - i see that too
14:55:50 <Pseudonym> bagUnion (Bag b1) (Bag b2) = Bag (unionWith (+) b1 b2)
14:55:56 <mq_mattr> I just find arrogance on coders such a bad thing.
14:55:59 <SamB_XP> Pseudonym: ah.
14:56:05 <SamB_XP> oh, right.
14:56:12 <mq_mattr> there is *always* a better way, no matter how good you already are
14:56:14 * SamB_XP smacks self for his other idea
14:56:17 <Pseudonym> :-)
14:56:18 <glguy> if (f() = g() { h(); } // DailyWtf: HAHAHA hey used single letter function names, losers!
14:56:34 <Pseudonym> Seriously, a standard Data.Bag would be a great contribution for anyone interested in learning Cabal.
14:56:43 <SamB_XP> mq_mattr: yes, but when someone does something the hard & wrong way, instead of the easy & less wrong way...
14:56:44 <mq_mattr> glguy: exactly - as if their way of doing it is the only way
14:56:48 <Pseudonym> It should be simple enough.
14:56:52 <mq_mattr> glguy: there are thousands of good ways
14:57:03 <SamB_XP> glguy: what does that do?
14:57:04 <glguy> mq_mattr: when the obvious problem is the missing ) and the missing =
14:57:05 <Taral> glguy: Parse error, saw '{', expected ')'
14:57:14 <glguy> That's my point
14:57:24 <mq_mattr> glguy: indeed
14:57:25 <SamB_XP> oh.
14:57:45 <newsham> f() = g() ?
14:57:52 <glguy> yeah, missing a =
14:57:54 <SamB_XP> f() == g()
14:58:00 <SamB_XP> is what it should be
14:58:18 <glguy> the point was a function can be wrong in obvious ways, but the dailywtf people laugh at the naming conventions
14:58:26 <glguy> like that was why it was posted or something
14:58:44 <newsham> so the obvious question is: why are you reading dailywtf?
14:58:51 <glguy> newsham: people linking me to it
14:58:58 <glguy> newsham: like just a few minutes ago in this channel
14:59:03 <glguy> I figure I'll give it a shot
14:59:07 <Excedrin> the "Here is the proper way to do it" post 107435 is pretty funny
14:59:16 <Taral> Pseudonym: Did you check out the Edison library?
14:59:44 <sorear> ?where edison
14:59:44 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
14:59:51 <glguy> you wouldn't believe what people thought the problem with: if (rand() < 0.5) { assign_to_ed(); } if (rand() > 0.5) { assign_to_joe(); }
14:59:55 <glguy> was
15:00:16 <Taral> lol
15:00:30 <Cale> haha
15:00:37 <Taral> people will say "what if rand() == 0.5?" and then I shoot them.
15:00:45 <SamB_XP> they thought the names should be "joseph" and "eddie"?
15:00:45 <Pseudonym> Taral: I was Edison's maintainer, briefly.
15:00:45 <glguy> Taral: eyah, that was one of the first
15:00:49 <newsham> collaborative user news sites seem to decay to the least common denominator, not distill to the wisdom of th emasses..
15:00:56 <newsham> slashdot all over again
15:01:06 <ozone> newsham: like irc!
15:01:14 <SamB_XP> the problem is that rand() ain't pure, thats what the problem is...
15:01:24 <inv2004> I love it, now: inv@unknown:~/z/spl$ runhugs Test.hs
15:01:24 <inv2004> Segmentation fault
15:01:36 <ozone> SamB_XP: obviously, we should just fix rand() to be pure
15:01:40 <newsham> ozone: in a way, I guess, but i've never seen irc come close to slashdot.
15:01:41 <SamB_XP> yes!
15:01:56 <inv2004> going to the GHC again
15:02:32 <newsham> int rand() { /* return a random int */ return 0x83A38F32; }
15:02:34 <newsham> pure
15:02:35 <newsham> !
15:02:51 <Taral> obviously we shouldn't use C
15:02:53 <SamB_XP> isn't this rand() supposed to return a float?
15:02:56 <Taral> it would be obvious in haskell :)
15:03:00 <SamB_XP> between 0 and 1?
15:03:10 <Taral> SamB: Might be returning a long
15:03:12 <glguy> SamB_XP: yeah... it wasn't C
15:03:21 <newsham> dunno which rand you're using.  the "normal" rand() in C is not a float.
15:03:33 <SamB_XP> maybe that was in Bob
15:03:40 * SamB_XP makes up a language name
15:03:48 <fnord123> does anyone here edit the wiki book "understanding arrows" on wikibooks?
15:03:59 <fnord123> i see a really weird sentence I don't know what to make of: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows#.28.3E.3E.3E.29
15:04:02 <lambdabot> http://tinyurl.com/yy9foz
15:04:09 <fnord123> "The next, and probably the most important, robot is (>>>)."
15:04:34 <cjeris> whoa, what's with the decepticon arrow faces?
15:04:55 <SamB_XP> robots, huh?
15:05:10 <fnord123> er nm. i didnt know some arrows were called robots...
15:05:10 <Cale> hehe
15:05:21 <Cale> fnord123: arrow combinators are being called robots
15:05:29 <ozone> in disguise!
15:05:31 <newsham> sounds silly
15:05:41 <Cale> that is, things which modify and combine arrows
15:06:28 <SamB_XP> so the decipticons are actually robots, you say?
15:06:28 <fnord123> i dont see why it's called a robot though
15:06:35 <ozone> Cale: seriously?  guess i've been off the haskell list too long
15:06:43 <newsham> transformers are robots in disguise
15:06:45 <SamB_XP> fnord123: it is more amusing than combinator?
15:06:47 <newsham> (more than meets the eyes)
15:06:48 <Cale> ozone: no, it's just in a particular tutorial
15:06:50 <sorear> whats wrong with 'assumed operation?'  Thay can get away with calling + in a group an assumed operation...
15:06:59 <ozone> Cale: oh, right
15:07:00 <bringert> how does that relate to monsters?
15:07:13 <fnord123> it comes from the czech word for "labour" whereas combinator is something that combines. surely more appropriate here
15:07:27 <ozone> thought it was a bit unlike hughes to name such things robots
15:07:29 <SamB_XP> fnord123: robots are cool mechanoids though
15:07:35 <fnord123> yes
15:07:39 <svref> Is there some way to write "type Map stop = [MapElement stop]", and further specify that "stop" is an instance of class "stop"?
15:07:49 <SamB_XP> and monsters are cool biologicals
15:07:55 <Cale> 'operation' is probably the simplest thing to replace all the occurrences of 'robot' with.
15:08:22 <fnord123> Cale, I can't see any documentation on -< ... I was wondering if you had a link or could briefly explain it.
15:08:38 <sorear> haskell.org/arrows
15:08:39 <SamB_XP> is (:[]) a monster?
15:08:44 <Cale> -< is the tail of an arrow in the arrow-syntax
15:08:55 <Cale> y <- f -< x
15:09:06 <cjeris> SamB_XP: (:[]) is clearly a robot.
15:09:14 <SamB_XP> I once saw it eat a comment (:[{- Help! -}])
15:09:15 <Pseudonym> (:[]) is the robot ninja monkey operator.
15:09:28 <ozone> svref: i don't think you can put class constraints on type synonyms, so no
15:09:32 <newsham> http://www.haskell.org/haskellwiki/Arrow_tutorial has some examples of <- and -<
15:09:32 <Cale> will wire f from x to y
15:09:34 <lambdabot> Title: Arrow tutorial - HaskellWiki
15:09:40 <glguy> ?remember SamB_XP I once saw it eat a comment (:[{- Help! -}])
15:09:54 <svref> ozone: nuts :)
15:10:15 <Cale> You can think of it as f being applied to x and y being computed as a result.
15:10:21 <fnord123> newsham: that used the same examples of -< as http://www.haskell.org/arrows/syntax.html
15:10:22 <lambdabot> Title: Arrow syntax
15:10:24 <ozone> svref: well, if you could, it wouldn't be a type synonym i suppose :)
15:10:39 <cjeris> Cale: my eyes! the syntactic pun!
15:10:46 <Cale> fnord123: yeah, that page describes it well
15:10:53 <Taral> does the c2hs maintainer come on here?
15:11:10 <SamB_XP> Taral: who is that?
15:11:12 <ozone> Taral: very occasionally
15:11:19 <ozone> oh, he's here now :)
15:11:23 <ozone> (ChilliX)
15:11:31 <svref> ozone: its not _my_ job to not tie the rope, if they give it to me.  :)
15:11:39 <glguy> Monads have: a <- m b   notation because Monads are parameterized on the result, while Arrows have a <- m -< b   because Arrows are parameterized on input and output?
15:11:46 <Cale> fnord123: what it *really* means is fairly complicated, because the syntax is really not very close to the low-level combinators.
15:12:01 <Cale> glguy: huh?
15:12:07 <fnord123> Cale, I'm using some of your HXT code and reapplying it to my own schema
15:12:07 <ski_> glguy : more or less, yes
15:12:19 <SamB_XP> Cale: that is probably related to the combinators themselves being reminiscent of FORTH
15:12:25 <Taral> ?seen ChilliX
15:12:25 <lambdabot> ChilliX is in #ghc and #haskell. I don't know when ChilliX last spoke.
15:12:29 <Cale> In monad syntax, you write  x <- c, where x :: a and c :: m a
15:13:05 <Cale> and in arrow syntax, you write  y <- f -< x, where y :: c, x :: b, and f :: a b c
15:13:22 <fnord123> im getting an error on "hasName" and the suggested possible cause is the monomorphism restriction applied in my function. "probably fix: give my function an explicit type sig" or use -fno-monomorphism-restriction
15:13:38 <Cale> fnord123: paste the code somewhere?
15:13:41 <fnord123> im unsure about adding new compiler flags willy nilly so i thought id ask
15:13:46 <Cale> lisppaste2: url
15:13:46 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
15:13:53 <fnord123> ok it's literate haskell, mind if I keep the > "
15:13:54 <fnord123> ?
15:14:01 <Cale> I don't care
15:14:04 <glguy> Cale: the point of my example/question was to demonstrate why the argument to the function in a monad computation needs the extra -< in arrow computation. to try to show the the arugment in the monad computation belonged to 'm' while in the arrow computation it belonged to the arrow istead
15:14:09 <glguy> the type at least
15:14:10 <Cale> I'm mostly just going to look at it :)
15:14:25 <lisppaste2> fnord123 pasted "the monomorphism restriction applied" at http://paste.lisp.org/display/32847
15:14:28 <Cale> glguy: yeah, your syntax for expressing that confused me :)
15:14:38 <glguy> Cale: me too!
15:15:01 <Cale> deep (isElem >                                 >>> hasName "header"
15:15:05 <Cale> what's with that?
15:15:16 <glguy> so... comonad "od-notation" woudl be: c -< x   ?
15:15:29 <glguy> where c is the comonadic thing and x is a value?
15:15:46 <SamB_XP> and they go voob voob?
15:16:09 <fnord123> a paste error I would guess. I just fixed any whitespace issue now and get the same error
15:16:18 <ski_> glguy : probably not like that
15:16:23 <glguy> :(
15:16:41 <ski_> (what would the types be, you think ?)
15:16:49 <SamB_XP> glguy: is that your idea of "reversing the direction of the arrows"?
15:17:04 <glguy> SamB_XP: nope, it's the idea of taking the feather end
15:17:15 <SamB_XP> I think maybe the arrows involved are in a category diagram
15:17:18 <ski_> hm .. maybe
15:17:51 <ski_> glguy : i'll try to investigate and see if works at all ..
15:18:01 <Cale> fnord123: it would be worth defining  deepGetTextOf name = deep (isElem >>> hasName name >>> getChildren >>> isText) >>> getText
15:18:02 <glguy> that notation was invented
15:18:23 <glguy> the point was jsut to relate the three concepts together
15:18:46 <ski_> perhaps it could work as a sugar, hmm
15:19:45 <SamB_XP> ski_: that was the idea, yes
15:19:57 <ski_> i meant on top of my sugar :)
15:20:10 <SamB_XP> ack, my teeth will hurt
15:20:19 * SamB_XP has somewhat sensitive teeth
15:20:25 <Taral> Cale: Are those combinators for xml?
15:20:27 <SamB_XP> too much sugar = pain
15:20:33 <SamB_XP> Taral: yeah
15:20:34 <Taral> I should port them to haxml.
15:20:35 <Cale> Taral: yes
15:20:42 <Cale> Taral: look at HXT
15:20:57 <Taral> % apt-cache search hxt
15:21:00 <Taral> Nope.
15:21:07 <Taral> % apt-cache search haxml
15:21:10 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/
15:21:11 <lambdabot> Title: Haskell XML Toolbox 7.0
15:21:12 <Taral> haxml - utilities for using XML documents with Haskell
15:21:17 <Taral> I don't want to package it.
15:21:22 <Taral> Not packaged, not used!
15:21:27 <SamB_XP> Taral: bigot
15:21:28 <Cale> It's easily downloadable from there
15:21:29 <Taral> :D
15:21:36 <Taral> HXT is too big. :P
15:21:40 <Cale> and it's cabalised
15:21:47 <Taral> not good enough!
15:22:16 <Cale> try it, it's awesome
15:22:16 <glguy> Taral: lol,  you are only hurting yourself, no one else cares if you have less powerfl libraries at your disposal :-p
15:22:40 <Taral> I like haxml
15:22:41 <Taral> very simple
15:22:54 <Cale> Taral: here's an RSS aggregator in 50 lines :) http://cale.yi.org/index.php?title=HRSS
15:22:56 <Taral> it just wants for better tree walking combinators
15:22:57 * SamB_XP would like HXT more if it would export a bit less
15:22:58 <lambdabot> Title: HRSS - CaleWiki
15:23:15 <SamB_XP> and tutorial a bit more
15:23:23 <lisppaste2> fnord123 annotated #32847 with "refactor some boiler plate" at http://paste.lisp.org/display/32847#1
15:23:42 <glguy> Cale: what's this selem business?
15:23:54 <Cale> glguy: simple element
15:24:06 <glguy> that's part of HXT?
15:24:10 <Cale> yes
15:24:29 <Cale> selem and aelem are just simplified versions of mkelem
15:24:43 <Taral> Cale: What is readDocument? HXT?
15:24:46 <Cale> yes
15:26:27 <inv2004> re
15:27:02 <Cale> selem = mkelem []
15:27:11 <Cale> aelem xs = mkelem xs []
15:27:14 <Taral> the arrow interface has a lot of typeclasses :/
15:27:20 <Cale> ignore them :)
15:27:21 <Taral> kind of overkill
15:27:22 <inv2004> how can I find infinite loop in programm ?
15:27:35 <glguy> :infloop
15:27:43 <SamB_XP> grep fix
15:27:47 <Taral> lol
15:27:52 <SamB_XP> ;-P
15:28:05 <Taral> inv2004: There are innumerable ways to get an infinite loop.
15:28:21 <SamB_XP> see where the output stops
15:28:35 <SamB_XP> use Debug.Trace
15:28:53 <inv2004> observe output only after program has finished
15:29:02 <inv2004> Debug.trace, thx!
15:30:16 <Taral> I don't understand why HXT uses arrows :/
15:30:42 <Cale> Taral: it's quite convenient
15:30:53 <Taral> why not monads?
15:31:15 <SamB_XP> because filters have input and ouput
15:31:16 <SamB_XP> er.
15:31:17 <SamB_XP> output
15:31:23 <Cale> there's an older monadic interface if you really want it
15:31:32 <Cale> it's not as nice
15:31:35 <Taral> what can I do with the arrows that I can't do with monads?
15:31:55 <SamB_XP> you can use >>>
15:32:05 <Taral> or what is pretty with arrows that's ugly with monads?
15:32:08 * SamB_XP can't remember
15:33:43 <Taral> I don't see why o <- filter -< i is any better than o <- filter i
15:34:05 <emu> looks like a fishy
15:34:25 * SamB_XP not usually use arrow notation much
15:34:56 <Taral> I mean, these arrows support ArrowApply, which makes them equivalent to monads in some sense.
15:35:49 <Cale> Taral: you mostly don't use the arrow notation, you mostly just use long chains of >>>
15:36:18 <Taral> That's no different from long chains of monad compositions.
15:36:33 <ski_> o <- foo <<< bar <<< baz -< i
15:36:33 <ski_> ?
15:37:14 <Cale> It's true, but this usually looks cleaner. You're usually thinking at the arrow level and not at the monad level.
15:37:21 <ski_> (maybe '<<<' should be named '<-<' ?)
15:37:38 <edwardk> too many operators with < and - in them =)
15:38:04 <edwardk> <- -< <-< <<< =<< <<= < = - ...
15:38:44 <glguy> >=> was being discussed for monad composition
15:38:52 <glguy> along with >.>
15:39:15 * ski_ 's seen '(>@>)' for monad composition .. in "The Craft .." iirc
15:42:16 <ski_> (hm .. actually s/<-</-<-/)
15:44:20 <dibblego> why would anyone declare a function of type a -> (b -> c) instead of a -> b -> c?
15:44:39 <Cale> dibblego: they're the exact same thing, -> is right associative
15:44:42 <ski_> emphasis or symmetry
15:44:44 <Excedrin> how can I type Data.Map.lookup so the 'm' in the signature (k -> Map k a -> m a) is []?
15:44:54 <Cale> map :: (a -> b) -> ([a] -> [b])
15:45:16 <Cale> sometimes it's nice to emphasize the partially applied version :)
15:45:18 <ski_> s/emphasis of staging/
15:45:53 <ski_> regexpMatch :: RegExp -> (String -> Bool)
15:45:54 <dons> moin
15:45:55 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
15:46:15 <fnord123> so im confused what a monomorphism restriction is and how i might structure my code to avoid it
15:46:40 <ski_> http://www.haskell.org/hawiki/RunTimeCompilation
15:46:43 <lambdabot> Title: RunTimeCompilation - The Haskell Wiki
15:47:17 <Excedrin> oh, I got it, (Ord k) => k -> Map k a -> [a]
15:47:30 <Excedrin> now I'm not sure if that's what I actually want... hrm
15:48:19 <Excedrin> sometimes I think I'd like it if [a] was typed List a instead
15:48:39 <ski_> type List a = [a]
15:48:58 <Excedrin> :)
15:49:51 <SamB_XP> fnord123: you can either add type signatures, or add arguments to your functions
15:49:55 * ski_ sometimes does 'type NonDet a = [a]' to emphasize and distinguish monadic use from other list uses
15:50:18 <ski_> select :: [a] -> NonDet (a,[a])
15:53:59 <emu> there's a MonadNondet similarly
15:55:13 * shapr yawns
15:56:53 <dons> ?users
15:56:54 <lambdabot> Maximum users seen in #haskell: 305, currently: 283 (92.8%), active: 42 (14.8%)
15:56:58 <dons> oh my god!
15:57:06 <dons> shapr! ^^
15:57:13 <shankys> I have a question for web development people here. Can anyone think of any significant advantages to expressing CSS in Haskell. I've been using Text.XHtml.Transitional which is really useful and has many advantages over writing plain XHTML. I'm considering writing something similar for CSS, but can think of any really significant advantages.
15:57:13 <dons> woo hoo! :)
15:57:18 <shankys> *can't think
15:57:33 <sorear> have we reached one Mline yet?
15:57:35 <shapr> dons: Whoa, WE BROKE 300!
15:57:37 * shapr boings!
15:57:40 <dons> shapr: type checking?
15:57:56 <dons> (at least if you're using one of the embedded type safe html document libs)
15:57:58 <shapr> type checking wha?
15:58:09 <shapr> oh, shankys
15:58:11 <dons> that might prevent you from constructing some invalid forms
15:58:35 <dons> shapr: yeah. we broke 300. and 6 months earlier than we guessed, when we reached 250 in august :)
15:58:49 <shankys> dons: I figured I could get type safety, but I don't know if I can justify pulling myself away from work to write this for just type safety...
15:59:31 <sorear> dons: vty released
15:59:43 <dons> sorear++ well done
16:01:32 <shankys> dons: CSS is the only part of my web framework that isn't purely Haskell code so it bothers me... If you can think of another big advantage of CSS in Haskell, I might just write it...
16:02:01 <SamB_XP> shankys: not having to switch syntaxes?
16:02:12 <e-guru> what should I use to find inverse of a permutation (a,b,c,d)->(b,a,c,d) ?
16:02:19 <dons> and if you start writing lots of it, it'll be good to do so programmaticaly, and with libraries
16:02:39 <sorear> style combinators!
16:03:09 <Cale> e-guru: is that in cycle notation?
16:03:13 <Cale> er
16:03:33 <Cale> well, you know where each thing is being sent
16:03:53 <Cale> b is sent to a, so a must be sent to b by the inverse
16:04:07 <SamB_XP> @djinn [(a,b)] -> [(b,a)]
16:04:07 <lambdabot> -- f cannot be realized.
16:04:08 <e-guru> Cale: yes, the inverse is (b,a,c,d) but, I cant figure out how to send it back :)
16:04:10 <Cale> (in fact, that looks self-inverse)
16:04:12 <SamB_XP> stupid djinn
16:04:17 <SamB_XP> @djinn (a,b) -> (b,a)
16:04:18 <lambdabot> f (a, b) = (b, a)
16:04:21 <Cale> apply the same function
16:04:25 <SamB_XP> @. pl djinn (a,b) -> (b,a)
16:04:26 <lambdabot> f = uncurry (flip (,))
16:04:55 <e-guru> Cale: I dont have a function, I have to write an inverse function hmm
16:05:12 <Cale> If you have  f (a,b,c,d) = (b,a,c,d)
16:05:16 <george> hi, anyone know a link for a good file explaining how I can write my own ord instances (i.e. Ord for a custom data type)
16:05:18 <Cale> then f . f = id
16:05:36 <Cale> instance Ord MyType where
16:05:46 <Cale>   compare x y = ...
16:05:51 <e-guru> that makes sense so I perhaps should write a function in forward instead of inverse then apply it :) good idea!
16:06:11 <Cale> e-guru: the inverse and the function itself are the same here
16:06:15 <george> Cale: and the ... is?
16:06:28 <Cale> george: something resulting in LT, GT, or EQ
16:06:32 <SamB_XP> e-guru: but are your other two permutations self-inverse?
16:06:34 <Cale> depending on the x and y
16:06:40 <Cale> @type compare
16:06:40 <george> my data type is a pair containing a string and a list of strings
16:06:41 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:06:51 <Cale> how do you want to compare them?
16:07:09 <george> alphabetically
16:07:09 <Cale> (just in English)
16:07:23 <Cale> by the first string?
16:07:37 <e-guru> SamB_XP: they are all in (a,b,c,d)-> format so I guess it means that they are self inversed?
16:07:39 <Cale> Or should it use the lists when the first strings are equal?
16:07:40 <george> yeah first string, and then if that is duplicated, second item, first string
16:07:47 <SamB_XP> e-guru: nope!
16:07:49 <SamB_XP> think again...
16:07:56 <Cale> It sounds like you just want  deriving Ord
16:08:05 <Cale> on your data declaration
16:08:06 <george> ahh
16:08:11 <george> will slap that on the end then ;)
16:08:15 <Cale> yeah
16:08:34 <e-guru> SamB_XP: ...thinking... :)
16:08:38 <Cale> If you're already deriving some classes, say Eq, then it'd be  deriving (Eq, Ord)
16:09:22 <SamB_XP> > let f (a,b,c,d) = (d,a,b,c) in liftM (==) id (f.f)
16:09:23 <lambdabot>     add an instance declaration for (Eq ((a, b, c, d) -> (c, d, a, b)))
16:09:23 <Cale> It also tends to be a good idea to derive Show, if you're going to be doing some debugging.
16:09:31 <SamB_XP> > let f (a,b,c,d) = (d::I,a,b,c) in liftM (==) id (f.f)
16:09:32 <lambdabot>     add an instance declaration for (Eq ((a, b, I, I) -> (I, I, a, b)))
16:09:39 <e-guru> SamB_XP: yes, you are right, but I am lucky today because they are (a,b,c,d)->(b,a,c,d) and (a,b,c,d) -> (c,b,a,d) and (a,b,c,d)->(d,b,c,a) I guess these all are self inverse
16:09:50 <SamB_XP> > let f (a,b,c,d) = (d::I,a::I,b::I,c::I) in liftM (==) id (f.f)
16:09:51 <lambdabot>     add an instance declaration for (Eq ((I, I, I, I) -> (I, I, I, I)))
16:10:20 * SamB_XP wonder what is problem
16:10:26 <SamB_XP> > let f (a,b,c,d) = (d::I,a::I,b::I,c::I) in liftM2 (==) id (f.f)
16:10:28 <lambdabot>  <(Int,Int,Int,Int) -> Bool>
16:10:33 * SamB_XP forgot to liftM2
16:10:35 <Cale> e-guru: just out of interest, does this have anything to do with geometry?
16:10:42 <SamB_XP> @check let f (a,b,c,d) = (d::I,a::I,b::I,c::I) in liftM2 (==) id (f.f)
16:10:44 <lambdabot>  Falsifiable, after 1 tests: (1,1,0,0)
16:11:10 <SamB_XP> anyway, see, that ain't a self-inverse...
16:11:15 <e-guru> Cale: no, I should write a program which permutes (a,b,c,d) using  (a,b,c,d)->(b,a,c,d) , (a,b,c,d) -> (c,b,a,d) and (a,b,c,d)->(d,b,c,a) only
16:11:26 <Cale> okay
16:11:29 <SamB_XP> but gives all permutations
16:11:47 * SamB_XP wonders how it is supposed to demonstrate that it has done it this way
16:12:06 <Cale> I was just curious because these particular permutations look suspiciously like some which showed up in a course on projective geometry.
16:12:20 <Cale> (they're small enough to show up anywhere though)
16:12:45 <e-guru> Cale: and earlier today I got advice from SamB_XP and then went and read a lot :) am I right to assume that I should find inverse of these, then products of these on both ways to get all the permutations for (a,b,c,d) ?
16:13:18 <Cale> well, those are all involutions, which means they're their own inverses
16:13:26 <SamB_XP> @check let f (a,b,c,d) = (c::I,b::I,a::I,d::I) in liftM2 (==) id (f.f)
16:13:27 <lambdabot>  OK, passed 500 tests.
16:13:41 * SamB_XP is 7 seconds too late
16:13:50 <Cale> in general, you'd probably want to look at the inverses though, and then yeah, I suppose all compositions of them.
16:14:05 <e-guru> Cale: I am in big trouble here :) I have to write a program to find permutations with what I have at hand (those 3)
16:14:14 <SamB_XP> it looks like each of those actually just swaps two elements
16:14:29 <Cale> e-guru: i.e. the subgroup generated by those perms?
16:14:38 <Cale> SamB: yes
16:14:54 <SamB_XP> @all-dict involution
16:14:55 <lambdabot> *** "Involution" gcide "The Collaborative International Dictionary of English v.0.48"
16:14:56 <lambdabot> Involution \In`vo*lu"tion\, n. [L. involutio: cf. F. involution.
16:14:56 <lambdabot>   See {Involve}.]
16:14:56 <lambdabot>   [1913 Webster]
16:14:57 <lambdabot>   1. The act of involving or infolding.
16:14:59 <lambdabot> [77 @more lines]
16:15:03 <SamB_XP> @all-dict involving
16:15:04 <Cale> @more
16:15:05 <lambdabot> *** "Involving" gcide "The Collaborative International Dictionary of English v.0.48"
16:15:05 <lambdabot> Involve \In*volve"\, v. t. [imp. & p. p. {Involved}; p. pr. &
16:15:07 <lambdabot>   vb. n. {Involving}.] [L. involvere, involutum, to roll about,
16:15:09 <Cale> noo
16:15:09 <lambdabot>   wrap up; pref. in- in + volvere to roll: cf. OF. involver.
16:15:11 <lambdabot>   See {Voluble}, and cf. {Involute}.]
16:15:11 <SamB_XP> sorry
16:15:13 <lambdabot> [71 @more lines]
16:15:15 <e-guru> Cale: hmm I think so, I just realized that I dont know as much about permutations as I thought I did :)
16:15:15 <lambdabot>   [1913 Webster]
16:15:17 <lambdabot>   1. To roll or fold up; to wind round; to entwine.
16:15:19 <lambdabot>    [1913 Webster]
16:15:21 <lambdabot>  
16:15:23 <lambdabot>       Some of serpent kind . . . involved
16:15:25 <lambdabot> [66 @more lines]
16:15:25 * SamB_XP thinks that is a pretty stpid way to define something
16:15:33 <Cale> an involution is a function f such that f . f = id
16:15:34 <SamB_XP> "the act of involving"
16:15:53 <SamB_XP> oh. okay. so you hadn't already said they just swapped two elements ;-)
16:15:58 <Cale> right
16:16:03 <xpika> Data.Map.lookup "Sun" days :: [String]
16:16:32 <Pseudonym> ROT13 is a classic example of an involution.
16:16:47 <Cale> However, given that they're permutations, that means that they're products of disjoint transpositions, you're saying that they're single transpositions (and you're right :)
16:17:38 <george> >	     putStr $ unlines $ ngramMapFreq empty $ concat $ map getNgram $ map words $ paras contents                 this line is giving me error:  Last generator in do {...} must be an expression       anyone have any idea why?
16:17:38 <e-guru> hmm
16:17:53 <e-guru> I started to hate permutations
16:18:03 <SamB_XP> e-guru: don't hate them
16:18:12 <Cale> george: maybe because of indentation?
16:18:12 <SamB_XP> hate not having a decent text on them
16:18:35 <e-guru> SamB_XP: I cant even figure out how to find product and inverse of them yet
16:18:38 <george> cale: nope.. it was working and i dont see what i changed to stop it working =(
16:18:41 <Cale> putStr . unlines . ngramMapFreq empty . concat . map getNgram . map words $ paras contents
16:18:44 <george> and it definitely had indentation before
16:19:06 <Cale> george: having slightly incorrect indentation can cause that problem
16:19:09 <e-guru> Cale: is it possible to write a generic function for inverting self inversed permutations?
16:19:11 <george> arrrg
16:19:12 <george> yes
16:19:21 <Cale> george: what the message means is that a do-block ends with something of the form  a <- b
16:19:22 <george> the previous line has indention 1 shorter
16:19:27 <george> you're correct =)
16:19:46 <Cale> george: that would make that expression part of that previous line
16:20:06 <Cale> (also, you should avoid repeated $'s in favour of . whenever possible :)
16:20:24 <Cale> you can always write f $ g $ h $ x as f . g . h $ x
16:20:38 <Cale> one nice thing about it is that it refactors well
16:20:53 <george> heh, we have only recently learnt $ command =)
16:21:07 <Cale> if you decide to make g . h its own function, it's already well-typed
16:21:12 <Cale> but g $ h won't be
16:24:38 <Excedrin> my Haskell wc now supports -l -w -c switches, but it doesn't support different charsets, running it on itself produces " 47 238 1557 wc.hs" and the surprising thing is, it's 2x faster than GNU wc
16:25:17 <Excedrin> http://lerp.com/~sic/code/wc.hs if anyone would like to make suggestions on how I can clean it up; I'm aware that option handling is sort of messy
16:26:02 <Cale> e-guru: the identity function does this
16:26:12 <Cale> id x = x -- it's in the Prelude
16:26:42 <Cale> That's the whole point of being its own inverse, you don't have to do anything to it to get the inverse.
16:27:20 <e-guru> hmm
16:28:31 <e-guru> ok now I see :)
16:29:02 <Cale> by the way, this question is far simpler to do by hand
16:29:05 <e-guru> I shouldnt be doing this at 2am, I have written down the inverse to see what is going on better, but I didnt realize that the inverse and the permutations were the same
16:29:49 <augustss> @users
16:29:49 <Cale> If the point is just to determine the subgroup generated by a few permutations, it's not going to be very large here.
16:29:49 <lambdabot> Maximum users seen in #haskell: 305, currently: 281 (92.1%), active: 39 (13.9%)
16:29:51 <dons> Excedrin: nice!
16:29:55 <augustss> woowoo!
16:29:58 <dons> woo!
16:30:36 <augustss> are there fancy prizes for every 100 user?
16:30:56 <newsham> augustss: other than being able to draw on hundreds of prior users' knowledge?
16:31:07 <dons> Excedrin: you could possibly use count '\n' instead of length . BS.lines
16:31:12 <augustss> Like 10 free uses of lambdabot
16:31:21 <dons> hehe
16:31:30 <newsham> uh oh, I have to pay for all those lambdabot queries?
16:31:39 <newsham> this is gonna be some serious sticker shock
16:31:56 <augustss> you haven't been invoiced yet?
16:33:31 <george> if i have data stored in a map type, say of name x, I want it to return a list of all data that fit a criteria, how would I do this?
16:34:14 <george> I know I can use toList, and then pluck it from there
16:34:14 <augustss> filter
16:34:33 <george> @type filter
16:34:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:34:47 <augustss> Not that filter, the one in Data.Map
16:34:57 <augustss> @type Data.Map.filter
16:34:58 <lambdabot> forall a k. (Ord k) => (a -> Bool) -> Data.Map.Map k a -> Data.Map.Map k a
16:35:10 <george> hmm
16:35:28 <augustss> @type Data.Map.filterWithKey
16:35:30 <lambdabot> forall a k. (Ord k) => (k -> a -> Bool) -> Data.Map.Map k a -> Data.Map.Map k a
16:35:34 <dons> mmm, 'Exprt F#' one of two F# books coming out, http://blogs.msdn.com/dsyme/archive/2006/12/18/DraftChaptersUpdateDec2006.aspx
16:35:36 <lambdabot> Title: Don Syme's WebLog on F# and Other Research Projects : New drafts of chapters fro ..., http://tinyurl.com/ydkzyf
16:35:55 <george> ok...
16:37:02 <george> I dont see how to use this function
16:37:43 <augustss> first use that to get the items you want, then toList to convert to a list
16:37:44 <dons> > M.filter (\k a -> a < 3) (M.fromList (zip "haskell" [1..10])) :: M.Map Char Int
16:37:45 <lambdabot>    The lambda expression `\ k a -> ...' has two argumentss,
16:37:46 <lambdabot>   but its typ...
16:38:29 <falconair> dons: i printed out the chapters earlier today, Don explains things very nicely...I'm really looking forward to the F# books (and still need to return my Practical O'Caml book :) )
16:38:51 <fnord123> if i have the proc extention where I'm using someFunc = proc x -> do ... where ...; but I've refactored so I no longer need an argument, how can I sort out the proc x -> do syntax? just dropping the arg is failing for me.
16:39:07 <newsham> < joshd> but can i currently hire 400 indian engineers to write code in haskell at at fifty cents an hour?
16:39:51 <augustss> newsham: with haskell you don't need 400 indian engineers, only one :)
16:39:56 <newsham> fnord: how do you make an arrow computation that doesnt take an argument?
16:40:24 <Cale> fnord123: um
16:40:31 <newsham> augustss: so you are saying that a developer writing in haskell is 400 times as productive as a developer writing in java?  riiighttt
16:40:41 <Cale> fnord123: maybe you don't want proc syntax at all then?
16:41:01 <dons> > M.toList (M.filter (< 3) (M.fromList (zip "haskell" [1..10])) :: M.Map Char Int)
16:41:04 <lambdabot>  [('a',2),('h',1)]
16:41:04 <fnord123> perhaps but then i will need to refactor my 'where' clause and was looking for a way out of that. :P
16:41:18 <augustss> newsham: well, i'm not sure how productive 400 50c engineers are
16:41:32 <Cale> newsham: 400 developers are not 400 times more productive than 1 developer
16:41:44 <newsham> augustss: not very, but probably somewhere above 1/400th of a good haskell programmer.
16:41:47 <Cale> (assuming they're working on the same project)
16:42:06 <newsham> cale: i cant just sum over man-months!@#?
16:43:17 <hyrax42> ok I need a new project
16:43:24 <Cale> 9 women working together can't create a baby in one month :)
16:43:28 <newsham> what kind and size, hyr?
16:43:39 <newsham> cale: true, but its still fun to watch
16:43:43 <hyrax42> newsham: not sure, and medium-sized I think
16:43:52 <Cale> However, that would be an interesting property for some alien beings to have.
16:44:00 <hyrax42> one that'll stretch me a bit but not quite sure how
16:44:03 <Modius> What kind of team sizes do you have on haskell projects?  Is it possible to find a place for incompetents in said language?  (I have 0 haskell experience, and am gaining some lisp now)
16:44:21 <george> dons, in your example you filter allowing only letters with a corresponding no. less than one. what if my map was of type String Int and I want to leave only pairs where the word is "foo"
16:44:28 <e-guru> .
16:44:49 <hyrax42> george: M.filter (=="foo")
16:44:50 <Modius> It's kind of the core argument against the non-C-ish languages I hear - using the people who'd have a hard time learning said languages as an argument against.
16:44:52 <newsham> modius: i imagine right now its harder to find incompetent haskell programmers because you have to go out of your way to learn haskell..  there's no quick'n'easy introductions that cover all of the basics.
16:45:01 <Cale> Modius: Almost no Haskell programmers are incompetent, unless you have someone who is still in the initial stages of learning the language.
16:45:08 <george> hyrax42, ty
16:45:09 <newsham> so i dont know how you'd get enough data to answer your question
16:45:20 <hyrax42> ?users
16:45:21 <lambdabot> Maximum users seen in #haskell: 305, currently: 282 (92.5%), active: 38 (13.5%)
16:45:24 <SamB_XP> Cale: they aren't incopetent, they are just unproductive
16:45:33 <Modius> In a way it probably does - the language's barrier to entry filters out people who can't learn advanced FP concepts.
16:45:38 <hyrax42> I count myself as unproductive
16:45:44 <Modius> And the argument can go either way.
16:45:45 <newsham> what modius said.
16:45:57 <Cale> Well, it's a lot harder to get Haskell programs to compile
16:46:02 <Cale> (than C programs)
16:46:06 <hyrax42> Modius: I don't think they can not be learned, just some people are not patient enough
16:46:07 <Modius> Cale:  I see that as a plus.
16:46:20 <Cale> But I'd say it's much harder to write correct C programs than correct Haskell programs.
16:46:26 <Modius> I'm seeking to learn "best of breed" non-compile-checked (Lisp) and best-of-breed compile checked/pure FP (Haskell)
16:46:30 <hyrax42> which is fair; there's only so much time a person has
16:46:32 <newsham> cale: i dont agree.  maybe a little harder (maybe not?).  the error messages could be easier to understand but once you hvae done it a few times, its really not very hard.
16:46:34 <Excedrin> Modius: the type checker makes it possible to randomly type identifiers until things work... it's sort of like coding by contract
16:46:50 <Cale> newsham: I'm not saying it like it's a bad thing
16:46:51 <newsham> programming C code can be hard too..  slightly less type checking, but its still there
16:46:55 <SamB_XP> newsham: the compiler won't puke on you if you write incorrect C programs
16:46:59 <hyrax42> newsham: though still think back to when you were learning
16:47:09 <Modius> In C++ you can adopt procedures that make it more conmpile-safe than Java (smart pointers, etc.)
16:47:12 <hyrax42> at leat when I was learning, I got a tonne of uninteligble messages
16:47:19 <newsham> i am thikning back to when i was learning.. i've had lots of troubles compiling C code at various points.
16:47:22 <hyrax42> for doing things that "should" have made sense
16:47:36 <hyrax42> my problems with C not compiling are only ever syntactic
16:47:36 <Modius> In C++ you can push problems into compiler-domain.
16:47:37 <Cale> newsham: I mean that stupid mistakes cause your programs not to compile, so if you make lots of them, you won't give the illusion of productivity with Haskell.
16:47:43 <hyrax42> or forgetting it's single-pass
16:48:00 <hyrax42> I have *much* bigger problems when it comes to running it though
16:48:03 <dons> ?docs Data.Map
16:48:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
16:48:07 <dons> george: ^^
16:48:28 <newsham> cale: I think thats a different issue.   working with pointers is inherently dangerous, and yo do that more often in C (you can do it in hsakell with ffi, no?)
16:48:37 <hyrax42> dons: I give a man a fish, you teach him how to fish
16:48:50 <newsham> and many programs that have pointer-related errors are perfectly valid compiling programs, but will crash.. true, I agree with that.
16:48:52 <hyrax42> though in fairness to myself, I didn't read the context, just that one question he asked
16:48:54 <Cale> newsham: yes
16:49:02 <augustss> newsham: but in C you don't have a choice.  you have to work with pointers (or array indicies)
16:49:13 <newsham> but if you werent using pointers in C, and used high-level abstract types instead, you wouldnt have those issues
16:49:30 <Cale> I was making a bit of a contrast.
16:49:30 <newsham> aug: pshaw.  you can go high level in any language.
16:49:50 <newsham> its just not standard practice, standard idioms, or part of the standard libraries.
16:50:06 <augustss> newsham: yes, but enforcing the abstractions is so much more difficult in C
16:50:15 <newsham> cale: I understand what you're saying, but I dont see that being strongly related to the compilation process or the type checking.
16:50:25 <Cale> With C, it's easy to get things to compile and run with lots of bugs in them, but very hard to write correct software, in Haskell, it's harder to get things to compile and run, but much easier to write correct software.
16:50:28 <newsham> i can write ffi pointer code that crashes in ghc pretty easily, no?
16:50:44 <Cale> yes you can, if you want to do that
16:50:44 <Modius> If I return a smart pointer in C++ you're "forced" to run copy constructor to copy it or to run its destructor on stack unwind.
16:50:53 * kyevan wonders what the most common bugs in haskell software are
16:51:04 <augustss> I have nothing against C, I like it.  I've probably written more lines of C )a few hundred thousand) than Haskell
16:51:04 <newsham> its pretty easy to write code in haskell with runtime errors (head, tail, pattern matching, etc)
16:51:10 <hyrax42> kyevan: I had something loop once
16:51:20 <newsham> haskell programmers arent told how to do dangerous things in haskell.
16:51:25 <kyevan> Probably division by zero or somesuch.
16:51:30 <newsham> but if they want to go out of their way, they can.
16:51:41 <newsham> C programmers are trained to do lots of dangerous things in everyday programs.
16:52:21 <Cale> apart from pattern match failures, I'd say the most common bugs are things where you misunderstand what you want to do.
16:52:24 <kyevan> ptr = ptr + 100 <- Not sure if that's completely valid, I never learned C, but you get the point :P
16:52:27 <augustss> Haskell should come with a warning about all the partial functions.  It's not stressed enough
16:52:36 <Modius> Has anyone here worked much in multi-language development?  On a contracting project I have a primary C# app calling into Lisp (pure functional) to do things that would be appallingly complex and bad to write in C#.
16:53:01 <newsham> cale: i agree completely.   i thikn thats mostly due to higher level abstractions being used in your average haskell program (a good thing!),  only partially due to the type checking.
16:53:01 <kyevan> Modius: Ah, fun.
16:53:04 <Cale> That is, Haskell comes very close to the point where in order to have a bug, you must actually not understand the problem.
16:53:10 <Modius> I'm wondering if that's a sensible way to inject a language such as Haskell into an existing app or programming environment.
16:53:23 <Cale> newsham: typechecking is quite a large part of it
16:53:31 <newsham> modius: yes. various mixtures of C, java, assembly and python.
16:53:32 <Cale> (don't underestimate it :)
16:53:59 <Cale> If you use types correctly, what I'm saying is a lot more true than if you use only tuples and lists
16:53:59 <Modius> Do you tend to have some programmers on a team congeal on only code belonging to certain languages?
16:54:04 * kyevan is writeing a naive rpn evaluator
16:54:19 <kyevan> I'm doing a few things in 'fun' ways, though.
16:54:31 <Modius> The division in my app is pretty clean.
16:54:33 <kyevan> Like numbers are functions to push themselves to the stack, not values.
16:54:55 <newsham> modius: i've worked primarily with small teams (ie. 5 programmers).  usually several programmers crossed language barriers, probably a few never had to.
16:55:07 <newsham> but on small teams you probably have more generalists and less specialists
16:55:08 <dons> kyevan: you might want to check http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11#interpreters-with-reader-monads
16:55:10 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y7wvnq
16:55:16 <kyevan> I'm sure everyone has done this before, though :P
16:55:49 <george> OK, i get the hang of filtering for basic things, but I have a data type special which has a string, a list of strings and 2 boolean values in. I want it to filter all results where the list of strings is equal to a value y
16:55:50 <kyevan> dons: I dunno what path you take there, but I almost guarantee it's not as insane as mine!
16:56:12 <newsham> cale: i still disagree.  but i guess we're not going to see eye ot eye on this.
16:56:19 <kyevan> (Take a string, split it into words, convert that to a list of functions, run each function in that list)
16:56:30 <Cale> newsham: I'm not saying it doesn't have to do with that
16:56:35 <george> e.g. > data special = MkN {a :: [String], b :: String, c :: Bool, d :: Bool} deriving (Eq, Ord)
16:56:48 <Cale> newsham: but types in Haskell really do tell you quite a lot about the behaviour of functions
16:57:16 <sorear> a -> (a -> b) -> b : guess what this does
16:57:32 <newsham> cale: and they can in C if you choose to make them.   for example, if you defined a struct Maybe {} to hold your pointers instead of using NULL vs. value you could eliminate NUL dereference errors.
16:57:40 <hyrax42> kyevan: have you looked up build yourself a scheme in 48 hours
16:57:41 <hyrax42> ?
16:57:49 <newsham> if you used an abstract array type that had bounds checking, you could eliminate array-based buffer overflows
16:57:53 <Cale> newsham: C's types are far less expressive than Haskell's
16:58:03 <newsham> cale: yes, but still quite powerful.
16:58:05 <Cale> newsham: because they don't allow for polymorphism
16:58:13 <hyrax42> it's the "next" step from little rpn type interpreters... gets you acquainted with parsec
16:58:18 <hyrax42> which is far too cool to be allowed to exist
16:58:26 <newsham> *nod*
16:58:26 <Cale> which is actually one of the major ways to stop functions from touching things they're not supposed to
16:58:28 <george> can i refer to the subvalues as special.a ? or anything like this?
16:58:46 <hyrax42> george: of a map?
16:59:11 <george> hyrax42, yes
16:59:26 <george> im using filterWithKey
16:59:32 <newsham> if you avoid using varargs you can eliminate issues like format string issues.
16:59:36 <hyrax42> ?docs Data.Map
16:59:37 <george> as the key is the special data type
16:59:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
17:00:47 <hyrax42> george: well you could make an infix lookup operator
17:00:51 <hyrax42> but by default no
17:01:29 <hyrax42> and you'd have to end up in at least the Maybe monad
17:01:58 <kyevan> Hmm. Does haskell have something like switch or case or cond?
17:02:05 <hyrax42> kyevan: yup
17:02:17 <george> i feel more and more like im going down the wrong road with my method for this project =)
17:02:35 <Cale> kyevan: it has case, which does pattern matching, and with which you can use guards
17:02:40 <hyrax42> kyevan: pattern matching, case construct and guards
17:02:55 <Cale> kyevan: if you want something more like cond, it's very easy to write
17:02:57 <hyrax42> george: what are you trying to do, and where is it going wrong?
17:03:11 <kyevan> ... bwah? All I want to do is return a different function based on what the string it gets is :P
17:03:49 <hyrax42> make a list [(String, a -> b)] and do a lookup on it
17:04:15 <hyrax42> or you can do guards
17:04:35 <kyevan> hyrax42: Well, that list would have to be infinatly long doing it that way.
17:05:29 <kyevan> (In my plan of '"+", "-", "*", "/". or something else?', something else gets to build a function to insert itself)
17:05:50 <hyrax42> > let f s a b | s == "add" = a + b | s == "sub" = a - b in f "add" 3 2
17:05:52 <lambdabot>  5
17:06:09 <hyrax42> > let f s a b | s == "add" = a + b | s == "sub" = a - b in f "sub" 3 2
17:06:11 <lambdabot>  1
17:06:27 <hyrax42> infinitely long?
17:06:30 <hyrax42> why?
17:06:36 <kyevan> ... what are those pipes for?
17:06:47 <kyevan> hyrax42: Every valid number :P
17:06:48 <newsham> they give guards
17:06:54 <kyevan> (in a string!)
17:07:00 <newsham> "f s a b is a + b when s == "add""
17:07:20 <newsham> looks perdier when written on several lines
17:07:25 <dons> > let f s a b = case s of "add" -> a + b ; "sub" -> a - b in f  "add" 3 2
17:07:26 <lambdabot>  5
17:07:26 <Cale> yeah, just use case with guards
17:07:45 <SamB_XP> @pretty let f s a b | s == "add" = a + b | s == "sub" = a - b in f "sub" 3 2
17:07:46 <lambdabot>  i = let f s a b
17:07:46 <lambdabot>       | s == "add" = a + b
17:07:46 <lambdabot>       | s == "sub" = a - b
17:07:46 <lambdabot>     in f "sub" 3 2
17:07:50 <hyrax42> kyevan: oh I meant a list like this: [("+", (+)), ("-", (-)),...]
17:07:53 <kyevan> Cale: And, how would I do the equivelent of else?
17:08:09 <newsham> > let f s = case s of "add" -> (+); "sub" -> (-) in f "add" 3 2
17:08:11 <lambdabot>  5
17:08:18 <Cale> otherwise?
17:08:19 <kyevan> hyrax42: right, that does me no good.
17:08:31 * shapr tries yarrlsburg
17:08:32 <kyevan> Since, I'm taking a list, and returning a list, and using that list as a stack
17:08:35 <Cale> or you mean as a pattern?
17:08:40 <Cale> x -> ...
17:08:41 <dons> > let syms = M.fromList [("add",(+)), ("sub", (-))] in (M.lookup "add") >>= \op -> return ( 3 `op` 2)
17:08:41 <kyevan> + and - would just be "WTF?"
17:08:42 <lambdabot>  Add a type signature
17:08:48 <dons> > let syms = M.fromList [("add",(+)), ("sub", (-))] in (M.lookup "add") >>= \op -> return ( 3 `op` 2)  :: Maybe Integer
17:08:49 <lambdabot>  Couldn't match `(->) (Data.Map.Map [Char] (t -> Integer))' against `Maybe'
17:08:49 <Cale> a single variable will match anything
17:09:17 <kyevan> I mean, um... hold on, I'll write what I mean in scheme.
17:09:22 <hyrax42> kyevan: if you are using guards, "else" is otherwise
17:09:30 <shapr> Something about planet.haskell.org really upsets my privoxy.
17:09:36 <Cale> otherwise = True
17:09:36 <hyrax42> | otherwise = ...
17:09:47 <hyrax42> would be equivalent to (else (...)) in a cond
17:09:50 <newsham> dons: is that "ap"?
17:09:55 <Cale> shapr: does thedailywtf.comm also do that?
17:10:29 <fnord123> out of interest, has anyone come across a convenient iso8601 time type for Haskell? Data.Time.Calendar looks like it might be good but I don't see a way to parse it from iso dateTime strings.
17:10:31 <hyrax42> ?type ap
17:10:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
17:10:40 <kyevan> And, um... what are these guards?
17:11:02 <newsham> oh.. hmm.
17:11:03 <shapr> Cale: Why yes it does, how did you know?
17:11:04 <hyrax42> ?paste
17:11:05 <lambdabot> http://paste.lisp.org/new/haskell
17:11:25 <shapr> Cale: Does this mean you know the problem, and maybe the solution?
17:11:27 <kyevan> Eh, you know what
17:11:36 <kyevan> I'll throw my project away, and do it later.
17:11:51 <kyevan> When I stand a chance of understanding you guys :P
17:12:14 <newsham> ?pl \a b c -> do {op <- a; return (a `op` b) }
17:12:14 <lambdabot> (line 1, column 14):
17:12:15 <lambdabot> unexpected "{"
17:12:15 <lambdabot> expecting variable, "(", operator or end of input
17:12:22 <kermitthehermit> I want to make about half a dozen mutually recursive IO functions called from main.
17:12:23 <newsham> ?undo \a b c -> do {op <- a; return (a `op` b) }
17:12:24 <lambdabot> \ a b c -> a >>= \ op -> return (a `op` b)
17:12:31 <newsham> ?pl \ a b c -> a >>= \ op -> return (a `op` b)
17:12:33 <Cale> shapr: I don't know the solution, I just stopped using privoxy and started using AdBlock
17:12:33 <lambdabot> (const .) . liftM2 (.) (>>=) (((return .) .) . flip . flip id)
17:12:39 <kermitthehermit> How do you make sure they're recursive?
17:12:43 <dons> fnord123: I think using something like: formatCalendarTime defaultTimeLocale "%B %d, %Y" ct
17:12:49 <kermitthehermit> I mean optimized?
17:12:54 <shapr> Cale: It's weird, only the very latest privoxy has that problem. The previous beta version did not.
17:12:56 <dons> oh, that's the other way around.
17:13:02 <newsham> oops
17:13:10 <newsham> ?undo \a b c -> do {op <- a; return (b `op` c) }
17:13:11 <lambdabot> \ a b c -> a >>= \ op -> return (b `op` c)
17:13:16 <newsham> ?pl \ a b c -> a >>= \ op -> return (b `op` c)
17:13:18 <lambdabot> (. (((return .) .) . flip . flip id)) . (.) . (>>=)
17:13:27 <dons> fnord123: hmm there is a library for parsing date strings. maybe in MissingH?
17:13:39 <dons> or possibly there's a function i'm not remembering in System.*
17:13:52 <fnord123> thanks
17:14:13 <shapr> Cale: Thanks, I'll try that.
17:14:22 <fnord123> i want to read a string as part of an rpc, though
17:14:23 <kermitthehermit> All the mutually recursive calls are tail calls.
17:15:43 <kyevan> So, uh, how does getLine NOT destroy transparency completely?
17:15:47 <kyevan> I still don't get that
17:15:50 <Cale> shapr: specifically, I'm using AdBlock Plus, together with Filterset.G updater
17:15:58 <kpreid> kyevan: by not being a function!
17:16:15 <Cale> Filterset.G is a large list of regularly updated patterns for locating ads.
17:16:21 <kyevan> kpreid: but... you use it in functions.
17:16:27 <kyevan> and, that makes stuff messy.
17:16:28 <fnord123> how bizarre that there's Time -> String functions but not String -> Time
17:16:36 * fnord123 get's some tea
17:16:56 <kpreid> kyevan: sure, but you never get a -> String out of it
17:17:15 <Cale> shapr: oh, and I also configured it to use EasyList when setting it up
17:17:24 <Cale> shapr: it's fairly effective
17:17:44 <Cale> It helps to include an exception rule for monad :)
17:17:58 <kpreid> kyevan: the side effects *always* show up as an occurrence of IO (or some wrapper) in the type, and so you always have to run/execute/unwrap it at some point
17:19:00 <shapr> I don't know EasyList..
17:19:29 <Cale> shapr: it should present it to you as an option when you install it
17:19:35 <Cale> (AdBlock Plus)
17:20:02 <george> when i make a custom data type, how do i split it apart again. say I have a data type: > data TwoNumbers = MkN {one :: Int, two ::Int}
17:20:09 <george> how do i access the one and two individually
17:20:25 <george> if I pass a function a variable of type TwoNumbers
17:20:41 <lisppaste2> hyrax42 pasted "guards and cond" at http://paste.lisp.org/display/32860
17:20:44 <kpreid> george: one and two are functions which extract the parts
17:20:53 <hyrax42> kyevan: ^^^ does that help a bit?
17:20:57 <Cale> george: you either pattern match, or apply the functions one and two
17:21:26 <kyevan> Gah...
17:21:27 <george> so if my TwoNumbers variable is called x I can do: one x
17:21:27 <george> ?
17:21:37 <kyevan> someone or something is using all my bandwidth!
17:22:00 <ndm> hello
17:22:14 <kyevan> I can't even slip in a friggin DNS lookup!
17:22:27 <SamB_XP> kyevan: tethereal, or whatever crazy name they call it now, will tell you...
17:22:56 <kermitthehermit> So can mutual tail calls be eliminated, or does the stack explode?
17:24:16 <SamB_XP> they can be
17:24:28 <hyrax42> but the standard doesn't require it :?
17:24:29 <SamB_XP> even GCC can do that
17:24:44 <SamB_XP> hyrax42: I don't think the standard talks about stacks at all
17:24:53 <hyrax42> yeah I thought not
17:25:09 <hyrax42> just gives the semantics and leaves it up to implementors
17:25:20 <hyrax42> *implementers
17:25:32 <SamB_XP> I wouldn't swear that it doesn't suggest it, though
17:25:43 <augustss> but we've gotten that one right since 1980 or so
17:25:49 <kermitthehermit> ML has explicit notation. Does haskell just do it automatically?
17:25:56 <SamB_XP> but only a fool wouldn't at least plan on implementing that
17:26:01 <hyrax42> the report is the only haskell book my library has
17:26:07 * kyevan wonders how long it would take to write a haskell in scheme
17:26:15 <kyevan> Everyone seems to like to do the other way :P
17:26:26 <hyrax42> kyevan: you'd have to do all the inference yourself...
17:26:31 <allbery_b> looks like tethereal is called tshark these days, fwiw
17:26:47 <ndm> are you talking about tail calls in Haskell?
17:26:49 <hyrax42> I think it'd just be more effort
17:26:52 <augustss> kyevan: the front end stuff is a lot of work for haskell
17:26:59 <SamB_XP> if it isn't mentioned, that is probably only because it was so obvious that nobody thought to say it ;-)
17:27:02 <hyrax42> also what augustss said
17:27:15 <ndm> the laziness thing makes that quite different
17:27:19 <SamB_XP> and because stacks aren't part of the language...
17:27:39 <kermitthehermit> George, I think you can bind two variables at at the same time if you pass a tuple.
17:27:40 <kyevan> hyrax42: Ohwow, that example of guards and cond is really reather useful.
17:27:46 <kyevan> Thank you very much!
17:27:49 <SamB_XP> yeah, tail calls are overrated
17:28:00 <SamB_XP> they are pretty much a fancy GOTO in Haskell
17:28:02 <hyrax42> ndm: ah it'd be constant space because the thunks just get forced?
17:28:04 <kermitthehermit> let (x,y) = getXandY
17:28:11 <hyrax42> "in place"?
17:28:16 <hyrax42> kyevan: you're welcome :)
17:28:42 <kermitthehermit> ndm, yes.
17:28:58 <ndm> hyrax42: its just the order of execution is not hte order you write things, its the order they get demanded, which in haskell is the caller
17:29:19 <hyrax42> hmm
17:29:32 <Cale> Another way to think about it is that everything is evaluated outermost-first
17:29:51 <hyrax42> kyevan: when the channel isn't full of people talking about headache-inducing things, people here are relaly helpful for learners
17:30:03 <Cale> So (f x) is evaluated by evaluating f, substituting x into it (which will maybe be evaluated later if it's needed)
17:30:24 <Cale> That's not quite what happens though, there's an additional optimisation
17:30:51 <hyrax42> how opaque are ghc innards to someone unfamiliar with functional language implementations
17:31:00 <Cale> Results of computations which result from the duplication of a function parameter are shared amongst the duplicates.
17:31:01 <hyrax42> (beyond a metacircular evaluator in scheme...)
17:31:20 <augustss> hyrax42: pretty opaque
17:31:23 <ndm> hyrax42: GHC isn't a simple compiler, by any means - Yhc has some bits which are simpler
17:31:35 <SamB_XP> hyrax42: you need to see it through papers
17:31:52 <Cale> It's easier to understand this particular aspect at a higher level
17:31:56 <SamB_XP> oddly, this somehow makes it easier to see instead of harder, despite the fact that the papers themselves are opaque
17:32:09 <SamB_XP> (Then again, transparent papers would be rather difficult to read)
17:32:21 <hyrax42> ?karma - SamB_XP
17:32:22 <ndm> hyrax42: see it as three stages - haskell -> core, core -> core (optimisations), core -> C/ASM
17:32:22 <lambdabot> - has a karma of 0
17:32:37 <SamB_XP> @karma SamB
17:32:37 <lambdabot> SamB has a karma of 22
17:32:39 <Cale> hyrax42: Have I explained lazy evaluation to you before?
17:32:40 <SamB_XP> @karma SamB_XP
17:32:41 <lambdabot> You have a karma of 1
17:32:45 <SamB_XP> hmm.
17:32:54 * SamB_XP wonders why SamB_XP has karma
17:33:03 <SamB_XP> probably the same reason he has quotes
17:33:12 <hyrax42> Cale: I think not... lots of other things, but not that
17:33:15 <Cale> okay
17:33:16 <SamB_XP> I really need to learn a console-based client or something
17:33:26 <hyrax42> I'm "ok" with it, but I still have certain implications I forget about
17:33:27 <augustss> @quote SamB_XP
17:33:27 <lambdabot>  I once saw it eat a comment (:[{- Help! -}])
17:33:51 * dons hands SamB_XP irssi
17:33:57 <Cale> So strict evaluation, for comparison, is carried out by always evaluating the parameters to a function before substituting them into the function body
17:34:08 <SamB_XP> has anyone read my nuclear-power-plant post yet?
17:34:25 <Cale> That is, strict evaluation proceeds in an innermost-first way.
17:34:33 <hyrax42> aye
17:34:43 <SamB_XP> @quote SamB_XP
17:34:44 <lambdabot>  oh. does A/S/L mean Age/Sex/Programming Language?
17:34:46 <Cale> Normal-order evaluation is outermost-first
17:35:10 <Cale> So we don't evaluate function parameters before making substitutions
17:35:27 <Cale> and it's always the outermost function which we work on first
17:35:29 <hyrax42> and laziness operates as normal order, but is more efficient
17:35:36 <hyrax42> ?
17:35:40 <Cale> right, it adds this extra optimisation
17:35:47 <SamB_XP> sometimes it is more efficient
17:35:52 <Cale> when you substitute a parameter in, you're likely to duplicate it
17:35:54 <ndm> SamB_XP: yeah, i must have not got it (unless you were refering to Bulat's nuclear power plant one)
17:36:10 <SamB_XP> ndm: it was called Data.Generics and Abstract Data Types
17:36:18 <Cale> if you do, then lazy evaluation says it only gets evaluated once (when it does) and the results are shared between the copies.
17:36:35 <Cale> that is, variables are like pointers to their results
17:36:39 <hyrax42> cse is an acronym I leaned the other day
17:36:40 <ndm> SamB_XP: interesting, i have a better version of Data.Generics and SYB stuff i should be releasing shortly :)
17:36:46 <Cale> CSE is another thing
17:36:51 <robreim> How do I get my #ifdef statements to work? I'm getting a "lexical error at character 'i'" error
17:36:51 <Cale> which is not the same as this
17:36:53 <hyrax42> oh ok
17:37:04 <hyrax42> ah this is runtime cse is compiel time
17:37:07 <SamB_XP> ndm: well better go read my post and make sure it addresses my problems
17:37:10 <ndm> robreim: using GHC or Hugs? and with the -cpp flag specified to Hugs
17:37:10 <Cale> right
17:37:20 <ndm> SamB_XP: link? or some text from it?
17:37:34 <robreim> I'm using cabal actually....
17:37:35 <Cale> and this is only saving the duplication which occurs from a single parameter to a function occurring multiple times in the body
17:37:40 <Cale> not more complex expressions
17:37:45 <SamB_XP> http://thread.gmane.org/gmane.comp.lang.haskell.libraries/6002
17:37:47 <lambdabot> Title: Gmane Loom
17:37:48 <ndm> robreim: you have to specify it in cabal, no idea how though
17:37:49 <Cale> Here's a nice example of evaluation...
17:37:52 <robreim> ok, thanks
17:37:56 <Cale> double x = x + x
17:37:59 <hyrax42> this laziness optimisation your'e talking about
17:38:03 <SamB_XP> ndm: you aren't on the list?
17:38:04 <Cale> Under normal evaluation:
17:38:07 <hyrax42> ah...
17:38:10 <Cale> double (double 5)
17:38:15 <kermitthehermit> http://wiki.tcl.tk/1348
17:38:16 <ndm> SamB_XP: i am...
17:38:17 <Cale> = (double 5) + (double 5)
17:38:18 <lambdabot> Title: Tail call optimization
17:38:23 <hyrax42> I see it
17:38:24 <Cale> = (5 + 5) + (double 5)
17:38:29 <Cale> = 10 + double 5
17:38:34 <SamB_XP> ndm: is it because I sent this over the weekend?
17:38:34 <Cale> = 10 + (5 + 5)
17:38:37 <Cale> = 10 + 10
17:38:38 <Cale> = 20
17:38:42 <Cale> while
17:38:44 <ndm> SamB_XP: i just got one post 2 weeks late, i think something has issues...
17:38:55 <Cale> under lazy evaluation, it looks like:
17:38:56 <george> bye all, I must say thanks again for all the help I have had with my project in the last ~8 hours. much appreciated #haskell people
17:38:59 <Cale> double (double 5)
17:39:06 <SamB_XP> ndm: ah.
17:39:08 <Cale> = let x = double 5 in x + x
17:39:16 <Cale> = let x = 5 + 5 in x + x
17:39:20 <Cale> = let x = 10 in x + x
17:39:23 <Cale> = 10 + 10
17:39:25 <Cale> = 20
17:39:28 <ndm> SamB_XP: oh, remember that one, no - it only supports traversals and extractions, not that (or gread/gshow)
17:39:28 <jcreigh> hmm, what's with the "use C for speed!" guy on haskell-cafe?
17:39:34 <hyrax42> Cale: kk
17:39:41 <Cale> so you save the wasted work of computing double 5 twice.
17:39:42 <allbery_b> bulat is a nutcase
17:39:47 <SamB_XP> ndm: hmm?
17:39:49 <Cale> allbery_b: hehe
17:40:02 <ndm> SamB_XP: no, it won;t help you there
17:40:03 <hyrax42> which "form" is it evaluated to before substitution?
17:40:03 <int-e> jcreigh: C code in Haskell is slower than C code in C.
17:40:12 <Cale> allbery_b: I always feel bad for thinking that, but it's the only reasonable conclusion :)
17:40:23 * SamB_XP really thinks a way to explode things and then glue them back together would be sweet
17:40:32 * allbery_b observes that his latest addition to the thread *should* throw the discussion in the direction of safety over speed
17:40:47 <Cale> hyrax42: hm? You mean that 'let' thing?
17:40:55 <SamB_XP> int-e: longer, anyway
17:40:55 <allbery_b> given that someone rewrote his *procedural* code for sanity, I don't see much reason to credit him
17:41:11 <allbery_b> (procedual sanity, even)
17:41:12 <hyrax42> oh it is actually compiled to the let?
17:41:21 <ndm> allbery_b: he does know what's he's talking about to some degree
17:41:23 <hyrax42> I mean translated
17:41:26 <int-e> SamB_XP: using ghc, slower, too, because ghc produces quite horrible loops
17:41:28 <hyrax42> or is that a way to visualise it
17:41:33 <Cale> hyrax42: no, that's just how I'm visualising it
17:41:46 <SamB_XP> int-e: true. or rather it uses goto instead, which throws GCC for a loop.
17:41:51 <Cale> It's really implemented as two pointers to the same place.
17:41:52 <SamB_XP> or, worse, doesn't.
17:41:59 <hyrax42> Cale: so the substitution happens once evaluation of (double 5) "bottoms out"
17:42:17 <Cale> well, it needs to evaluate things far enough to do the +
17:42:19 <SamB_XP> but double 5 doesh't bottom out, does it?
17:42:27 <SamB_XP> doesn't that just return 10?
17:42:33 <allbery_b> some, sure.  I have some awareness of the stuff he's discussing.  but he seems to be taking things rather too far.
17:42:42 <Cale> SamB: he doesn't mean that in a technical way
17:42:45 <allbery_b> "bottoms out" in the sense of completing evaluaion, I think
17:42:49 <hyrax42> SamB_XP: yeah I didn't mean _|_
17:42:51 * SamB_XP is teasing ;-)
17:43:08 * hyrax42 is doing some domain theory next term
17:43:11 <hyrax42> I think it should be interesting
17:44:01 <Cale> hyrax42: one simple way of implementing this is to have all variables implemented as a boolean flag together with a pointer
17:44:12 <Cale> if the flag is set to false, the pointer points to code
17:44:19 <hyrax42> either to a thunk or to a value
17:44:41 <Cale> to get the value, you run the code, which sets the flag to true and sets the pointer to point at the result
17:44:51 <Cale> (if the flag was false)
17:44:57 <Cale> if it's true, you just do a lookup
17:45:05 <Cale> in GHC, they're actually more clever
17:45:19 <hyrax42> and in the case of double double, how do both pointers point to the same place
17:45:43 <hyrax42> I mean how is that set up...
17:46:09 <Cale> when the definition double x = x + x is expanded
17:46:15 <Cale> both x's point to the same thing
17:46:20 <Cale> namely, double 5
17:47:11 <hyrax42> hm
17:47:34 <hyrax42> maybe I should look at EHC or YHC
17:47:50 <Cale> and so when one of the x's is evaluated the other is automatically
17:48:06 <Cale> you should read the STG machine paper a few times
17:48:23 <hyrax42> I saw that linked recently
17:52:06 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
17:52:06 <ndm> hyrax42: my suggestion is pick one of the 3 bits of haskell compilation, focus on that first
17:52:07 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
17:52:31 <Cale> sorry, it seems that searching for that without including citeseer in the search terms doesn't work so well in google
17:52:59 <chessguy> 'evening haskellers
17:53:50 <dons> ?users
17:53:51 <lambdabot> Maximum users seen in #haskell: 305, currently: 283 (92.8%), active: 37 (13.1%)
17:54:03 <jcreigh> yea! we broke 300
17:54:18 <ndm> hyrax42: Yhc has a reasonably simple implementation of the STG machine in its bytecode
17:54:35 <chessguy> nice
17:54:55 * chessguy wonders who the first 300th user was
17:55:00 <ndm> hyrax42: http://haskell.org/haskellwiki/Yhc/RTS and http://www-users.cs.york.ac.uk/~ndm/yhc/bytecodes.html
17:55:01 <lambdabot> Title: Yhc/RTS - HaskellWiki
17:55:36 <fnord123> Hey Cale, with HXT, if you had an xsd:enumeration for strings, would you represent them in your haskell with a 'data' construct w/ string parsers and Show methods, or would you use Strings throughout your local code?
17:55:43 <fnord123> or something else?
17:56:03 <Cale> what's an xsd:enumeration?
17:56:43 <Cale> I'd probably use a list of strings, if it is what I think it is.
17:56:46 <fnord123> if you want to represent something enumerated in xml, and define it in xsd, you use simpleType name="blah" then enumerate the strings you can have
17:56:49 <robreim> is ndm == Neil Mitchell ?
17:56:57 <ndm> robreim: yes, Neil David Mitchell
17:57:03 <fnord123> sometimes it's used for error strings to be human readable in the rpc
17:57:15 <ndm> (ndm is my comp sci assigned user name, so was the default when i signed into IRC)
17:57:23 <robreim> ndm: Cool. do you have any suggestions on how to build installable haskell executables for windows? or MSIs or something?
17:57:31 <fnord123> <errorCode>BORKEN_SOMETHING</errorCode>
17:57:50 <ndm> robreim: http://neilmitchell.blogspot.com/2006/11/hsinstaller.html
17:57:52 <lambdabot> Title: Neil Mitchell's Haskell Blog: HsInstaller
17:58:12 <Cale> fnord123: I suppose if it was always going to be the same strings, I'd consider creating a datatype.
17:58:15 <robreim> ndm: excellent! Thanks :)
17:58:30 <ndm> robreim: answer is basically at the moment you can't, i have a plan to reduce it to a one click kind of process
17:58:32 <Cale> fnord123: It depends on how much I was going to be using those values.
17:58:36 <fnord123> yeah that's why it's enumerated in the schema definition
17:58:55 <fnord123> you probably will only cat them to the user for debugging purposes. you wouldn't be able to fix it, really
17:59:01 <ndm> robreim: although the latest version of Cabal has reasonable runhaskell Setup install behaviour on windows, but obviously that requires hte user to compile from source
17:59:21 <fnord123> unless it's like <loginError>BAD_PASSWORD</loginError> or <loginError>UNKNOWN_USER</loginError>
17:59:44 <fnord123> i think a data type is the way forward here. thanks
17:59:49 <Cale> fnord123: well, if they're only error messages and won't undergo serious manipulation then probably strings are fine
17:59:52 <robreim> ndm: yeah, I'd prefer to deliver pre-compiled binaries alongside source for windows if possible for user simplicity.
18:00:18 <Cale> But for anything which was going to be passed around a lot, compared, etc. using a proper datatype is probably a lot safer.
18:00:25 <ndm> robreim: me too, well once the hsinstaller project kicks off, that should be relatively easy - unfortunately we're still waiting for hte GHC installer to become open source...
18:01:14 <Cale> fnord123: if you want the benefit of typechecking without bothering to have to parse the things, then use a newtype
18:01:28 <Cale> newtype LoginError = LoginError String
18:02:32 <Cale> You can just wrap the strings you get with LoginError, and it'll ensure that anything which gets a login error is expecting one, rather than a random string.
18:02:54 <Cale> But you won't actually have to check that the login errors you get are part of the schema
18:03:47 <fnord123> unless it's <loginError>OK</loginError> :/
18:03:56 <robreim> hmm. Why is the GHC installer closed-source?
18:04:11 <SamB_XP> closed-source?
18:04:24 <robreim> Well, "not open source"
18:04:54 <mbishop> there's a ghc installer?
18:05:18 <robreim> Yeah, a windows MSI one. Sorry, I was replying to ndm.
18:06:38 <fnord123> it's only an MSI on windows.. if you're upset about closed source on windows... eh?
18:06:48 <allbery_b> because MSI is the way things are done on Windows nowadays.  complain about the closed source OS, not its installer
18:06:57 <allbery_b> yeh, that
18:07:07 <mbishop> indeed, msi just uses the "default" windows installer crap anyway
18:07:40 <ndm> robreim: its complex, but basically not even the GHC team have a copy of the Windows MSI geneator that packages GHC
18:07:50 <ndm> and its written in Haskell, just for kicks :)
18:08:11 <robreim> Ah I see
18:08:27 <ndm> the first choice the HsInstaller project needs to make is to go the .msi route, or the .exe route - i suspect .msi is better if we do it properly, but most .msi's aren't done very well
18:08:50 <ndm> plus .msi is more robust - Windows deals with more things
18:09:09 <sjanssen> why doesn't the GHC team have the installer generator?
18:09:32 <ndm> sjanssen: because its not been made available to them, exactly why not is something i don't really know the detilas on
18:09:47 <ndm> basically it was written by sigborne, and he hasn't released the code
18:10:04 <ndm> he packages it for them
18:10:48 <dons> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020674.html :)
18:10:54 <lambdabot> Title: [Haskell-cafe] #haskell irc channel reaches 300 users, http://tinyurl.com/y6rbmy
18:11:02 <ndm> dons: already read it :)
18:11:06 <sjanssen> @users
18:11:07 <lambdabot> Maximum users seen in #haskell: 305, currently: 280 (91.8%), active: 35 (12.5%)
18:11:11 <robreim> might something like http://sourceforge.net/projects/wix or http://sourceforge.net/projects/msi2xml/ be useful if we can't get the GHC version?
18:11:12 <lambdabot> Title: SourceForge.net: Windows Installer XML (WiX) toolset
18:11:21 <dons> we're sitting way above our ong term average
18:11:23 <mbishop> is there a way to know who was #300? :P
18:11:33 <dons> mbishop: we could analyse the logs
18:11:38 <dons> but i don't have a tool on hand for that
18:11:54 <robreim> hey hey! Congratulations #haskell :)
18:11:56 <greentea> dons: i have some embarrassing news; i'm just not going to be able to get to this -package HTTP testing stuff. i thought my health would allow it, but apparently not. :-( Sorry. :-(
18:11:58 <dons> lambdabot++ for making this channel fun!
18:12:03 <dons> shapr++ for having the vision to push it!
18:12:09 <mbishop> how would that work? find the last time the bot gave user stats, and then start adding joins?
18:12:40 <dons> greentea: ok. sorry to hear that. is there any code available we could put up?
18:12:47 <dons> mbishop: yeah something like taht
18:12:53 <dons> mbishop: or start at log 0
18:12:57 <dons> and pop and push the stack :)
18:13:00 <mbishop> heh
18:13:27 <robreim> speaking of lambdabot, dons: any news on hs-plugins?
18:13:37 <e-guru> if I have functions  f,g,h how can I make composition of these using every different permutation? f.g.h,.f.h.g,g.h.f ... ?
18:13:41 <robreim> (and it's compatability with ghc-6.6)
18:13:43 <dons> robreim: if not now, i have a moral obligation to get it done by the hackathon
18:13:57 <dons> e-guru: mm, a list monad permute of functoins :)
18:14:04 <robreim> :)
18:14:06 <sjanssen> e-guru: do f g and h have the same types?
18:14:25 <e-guru> yes
18:14:32 <e-guru> sjanssen yes
18:14:33 <robreim> ndm: might something like http://sourceforge.net/projects/wix or http://sourceforge.net/projects/msi2xml/ be useful if we can't get the GHC version?
18:14:33 <lambdabot> Title: SourceForge.net: Windows Installer XML (WiX) toolset
18:14:39 <greentea> dons: Basically, no. i put some time into learning how HUnit works, but didn't get any further than that. :-(
18:14:57 <dons> greentea: ok.
18:15:11 <sorear> Are there any gotchas wrt compiling GHC 6.4 using GHC 6.6/HEAD?
18:15:31 <dons> > [(+1), (*2), (`div` 3)] >>= \f -> map f [1..10]
18:15:32 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,2,4,6,8,10,12,14,16,18,20,0,0,1,1,1,2,2,2,3,3]
18:15:39 <dons> or something :}
18:15:48 <dons> (well, not really that, but we're in the ball park)
18:16:08 <ndm> robreim: i suspect the GHC one uses another tool internally, but don't really know - i took a look at wix, confusing to use, but its a one of cost if we are writing a generator
18:16:27 <ndm> robreim: i.e. it generates wix, xml ... files, and then something else builds the database
18:16:42 <dons> doesn't sigbjorn roll the installers himself?
18:16:46 <dons> i guess he has some tools available
18:17:16 <dons> ok. since we reached 300 today. who wants to go on record for #400 ?   :)
18:17:30 <sorear> dons: how close are we to 1M lines?
18:17:37 <ndm> dons: he has a closed source haskell script he uses to do it
18:17:37 <e-guru> hmmm
18:17:57 <dons> back in August we made some guesstimates for 300. iirc I said xmas, and Igloo said next july. (i was being overly optimisitic though ;)
18:18:06 <dons> so how about 400 by say, next July?
18:18:12 <lispy> Cale: ping?
18:18:17 <sorear> dons: have we reached 1M, if you pipe the logs through fold?
18:18:28 <dons> sorear: i'll know after the daily script runs in a few hours
18:18:33 <sjanssen> dons: I'll place my bet on May
18:18:36 <chessguy> dons, apparently you weren't being overly optimistic
18:19:13 <sjanssen> no, May is too sune
18:19:15 <sjanssen> soon
18:19:29 <Cale> lispy: hi
18:19:32 <sjanssen> August.
18:19:34 <dons> so it was 8 months from 200->250, and 4 months from 250->300
18:19:49 <Cale> lispy: I was wondering how to set up a mediawiki to colour Haskell code
18:20:31 <lispy> Cale: nice
18:20:35 <lispy> Cale: it's pretty easy
18:20:43 <lispy> Cale: i was just ?tell lambdabot to tell you about it :)
18:21:04 <robreim> ndm: thanks for all the installer info. ndm++
18:21:16 <lispy> Cale: you need 1) an extension my friend wrote, 2) the right version of geshi
18:21:40 <fnord123> what are these numbers? loc?
18:21:57 <SamB_XP> dons: overly optimistic, huh?
18:22:03 <SamB_XP> it isn't christmas yet, though!
18:22:09 <lispy> Cale: and iirc, the current haskell wiki maintainer has shared her copy of those somewhere on the wiki
18:22:12 <dons> the blogosphere effect
18:22:25 <dons> fnord123: the 300 is users, 1M is lines of text/per year
18:22:34 <ndm> robreim: no probs, hopefully next time you ask i can show you the code ;)
18:22:58 <fnord123> oh ok
18:23:07 <dons> ?where stats
18:23:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:24:41 <dons> if I want to extract valid 'http://.*' urls from arbitrary strings, what would people suggest I use?
18:24:56 <dons> is there an xhtml or hxt tool? or should i roll a little lexer
18:25:02 <lispy> Cale: here is the geshi file: http://codersbase.com/index.php/Geshi_haskell
18:25:04 <lambdabot> Title: Geshi haskell - CodersBase
18:25:12 <Cale> lispy: ah, thanks
18:25:32 <lispy> Cale: do you have geshi installed already?
18:25:45 <kfish> dons: parsing urls isn't xml of course -- you need a parser for the rfc2396 syntax
18:25:49 <lispy> Cale: i'm trying to find the file that adds the extension to mediawiki
18:26:13 <Cale> lispy: no, I assume I get it from http://qbnz.com/highlighter/index.php ?
18:26:15 <lambdabot> Title: GeSHi - Generic Syntax Highlighter :: Home
18:26:31 <lispy> Cale: http://meta.wikimedia.org/wiki/GeSHiHighlight
18:26:42 <lispy> Cale: yeah, but i don't think you want the most recent version (but i could be wrong)
18:27:20 <lispy> Cale: those links should get you started, leave me another /msg if you need help (I need to get going)
18:27:29 <dgriffi3> are there haskell bindings for curl?
18:27:33 <Cale> lispy: okay
18:27:39 <dons> dgriffi3: darcs has a binding
18:27:46 <lispy> Cale: or email Ashley Yakeley (the haskell wiki maintainer)
18:27:48 <dons> but i don't know of a standaone library
18:27:55 <dgriffi3> thanks
18:27:59 <dons> (you could just steal the code from darcs , I think)
18:28:01 <lispy> Cale: she has a different (better?) high light file
18:28:11 <dons> kfish: ok. yes. so i wonder if we have such a library already...
18:28:27 <Cale> he
18:28:33 <kfish> dons: and it's worth doing as a re-usable library, to split into scheme/user/host/port/path/query/params
18:28:37 <kfish> heh
18:28:49 <Cale> okay, I'll see about that
18:29:47 <kfish> dons: with url escaping etc .... certainly sounds like a fun day's hacking if it's not done yet :-)
18:30:46 <gravity> dons: Thanks for writing up your latest blog entries. I'm really enjoying them.
18:30:49 <scsibug> lispy: fyi, ashley isn't a she
18:32:11 <dons> Cale: did you see any url parsing stuff when writing your rss feed ripper/
18:32:41 <kfish> dons: i thought this conversation reminded me of something ... i've been on the uri@w3.org list for a while, and people there are always annoyed when people hack up invalid uri parsers ...
18:33:09 <kfish> so in 2003 someone wrote up a very strict, test-passing version in the most appropriate language at the time:
18:33:12 <kfish> http://lists.w3.org/Archives/Public/uri/2003Mar/0010.html
18:33:13 <lambdabot> Title: URI handling code in Haskell available from Graham Klyne on 2003-03-05 (uri@w3.o ...
18:33:24 <dons> oh nice! Graham Klyne
18:33:42 <kfish> hehe
18:33:44 <dons> kfish++
18:33:49 <Cale> dons: hmm, not really, though it probably has something in it which does that.
18:34:04 <fnord123> When might the compiler complain about an arrow statement (I'm using -<) being used where it expects an expression? Obviously where I'm using an arrow command; but afaics, it should be a fine arrow command.
18:34:40 <dons> ok. this looks quite complete
18:34:44 <dons> thanks kfish
18:34:48 <Cale> fnord123: just out of interest, you are compiling with -farrows ?
18:34:58 <fnord123> yes
18:35:18 <fnord123> and no-monomorphism restriction, fwiw
18:35:44 <Cale> fnord123: hmm, well, I don't really know
18:36:07 <Cale> maybe indentation?
18:36:29 <kfish> dons: cool, i'd be interested to use it too, let us know how it goes :-)
18:38:57 <fnord123> possibily the indentation as the last thing in a do statement should be an expression and it's probably complaining that my arrow command is the last thing in the expression
18:39:18 <fnord123> though, if I fiddle with the indentation, it gives a different message regarding that specific point.
18:55:39 <dons> kfish: works roughly like:
18:55:40 <dons> *RDF.URI> parser "http://www.google.com/foo/bar?xy"
18:55:40 <dons> [(URI "http:" "//www.google.com" ["/","foo/","bar"] "?xy" "","")]
18:57:03 <kfish> dons: seems pretty straightforward
18:57:42 <kfish> the host part seems a bit odd, but maybe i'm missing something
18:57:58 <kfish> ie. containing the //, and not having a separate user@ part
18:58:05 <kfish> or user:pass@
19:01:58 <SamB_XP> don't we already have a Network.URI module that does a good job?
19:02:33 <SamB_XP> (or at least gives the impression of doing so?)
19:03:06 <SamB_XP> (though I think it shows URIs as if they were just... URIs, and not multi-field datastructures
19:04:01 <dons> ah yes. there's something in Network.URI
19:04:08 <dons> ?docs Network.URI
19:04:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
19:04:20 <dons> --  Maintainer  :  Graham Klyne
19:04:23 <dons> same code :)
19:04:53 <kfish> hooray!
19:05:01 <Excedrin> Network.URI looks really good... it's nice to see a documentation page that has references to RFCs
19:05:27 <dons> so what i'm after is a String -> [URI] function :)
19:05:28 <SamB_XP> dons: same code?
19:06:01 <dons> the other code we were looking at was also by the same author
19:06:21 <Excedrin> I agree that it's odd that "//" ends up at the front of the authority part
19:06:54 <Excedrin> parseURI :: String -> Maybe URI
19:06:55 <dons> that was from a draft of the code though. maybe Network.URI is different.
19:07:31 <dons> I still need to tokenise my input file to find possible uri's though
19:07:48 <kfish> dons: are your possible URIs separate words?
19:08:35 <dons> yeah, i'd need to split on chars, words-style, that can't be in uris , i suspect...
19:08:52 <dons> (http://example.org) http://example.org, [foo http://example.org]
19:09:24 <kfish> dons: ah ok :-) guess you'd better grab the reserved characters list from the rfc then
19:09:26 <Excedrin> oh, the authority method in Network.URI returns it without //
19:10:08 <dons> kfish: yeah. giving me a list of words. which i can then filter valid uris from. and use some heuristics to print ones that are invalid. from the valid list i then go to the network to actually check they work
19:11:14 <kfish> dons: ah, you're re-implementing linkchecker.py aren't you :-) now i remember
19:12:09 <dons> yes :) to run on smp and print nicer output :) and maybe be a bit bytestringish^h^h^h faster
19:12:17 <kfish> haha
19:12:45 * sorear is now configuring GHC 6.4.2
19:13:52 <qweweqweqw> x
19:15:47 <SamB_XP> @google site:paste.lisp.org nondet
19:15:50 <lambdabot> http://paste.lisp.org/display/5981
19:15:50 <lambdabot> Title: Paste number 5981: nondet 'is' in SWI
19:15:55 <SamB_XP> hmm.
19:16:20 <SamB_XP> sorear: you wrote a nondeterminism monad right?
19:16:37 <sorear> yes
19:16:46 <sorear> the massively parralel toy one
19:16:47 <SamB_XP> what was the URL for that again?
19:17:31 <sorear> file:///home/stefan/MPMonad.hs
19:17:43 <SamB_XP> that isn't on paste.lisp.org
19:17:54 <SamB_XP> weren't you asked to lisppaste it?
19:18:08 <sorear> must've forgotten.
19:19:16 <lisppaste2> sorear pasted "as requested, two versions of excessively parallel nondeterminism (untested)" at http://paste.lisp.org/display/32868
19:20:04 <sorear> what is the *maximum* GHC for building 6.4.2?
19:20:26 <sorear> I'm trying to use HEAD to compile it, and I'm getting lots of parse errors.
19:20:43 <SamB_XP> sorear: you are supposed to use a release
19:21:08 <fnord123> data DataA { abc :: String} ... data DataB { abc :: String } -- not  allowed to have abc as a data element of two Data types?
19:21:31 <SamB_XP> you are supposed to be able to build anything with a release, and HEAD with itself, but no guarentees about anything else
19:21:42 <sorear> now I'm trying to use 6.6
19:22:24 <sorear> the erroring code in 6.4 is of the form module A (b ,c ,d ,e,f ,g,h ,i,j, ,c) where
19:22:33 <sorear> note the double comma
19:22:53 <SamB_XP> huh
19:23:13 <scsibug> fnord123: those record accessor functions are all in the module's namespace, so they must be distinct
19:24:08 <e-guru2> how can I convert a string into a function in hugs? if I have "func" and I have a func function, I want to use "func" x ?
19:25:06 <Trevion> e-guru2, suppose you had an operator that did that.  What would its type be?
19:25:07 <fnord123> fwiw, i forgot the = DataA and = DataB in my above examples.
19:25:12 <fnord123> scsibug:  thanks
19:25:54 <yurtesen> nick e-guru2
19:26:07 <[d-_-b]> http://paste.lisp.org/display/32869
19:26:09 <[d-_-b]> in my program I have a case op1 of : 1,2,3,4. I want that in the end of case 4, call again the case 4... :)
19:26:19 <[d-_-b]> anyone helps me?
19:26:32 <e-guru3> how can I convert a string into a function in hugs? if I have "func" and I have a func function, I want to use "func" x ?
19:26:41 <Lemmih> Not from what I can see.
19:27:22 <Trevion> [d-_-b]: make the case statement a function that can be called recursively?
19:27:56 <[d-_-b]> Trevion, humm... i don't understand...
19:27:58 <[d-_-b]> :(
19:28:08 <Trevion> or, more correctly I guess, put the case statement inside a function that can be called recursively.
19:28:15 <Lemmih> [d-_-b]: Use a named function for case 4?
19:29:41 <Lemmih> e-guru3: That's not really possible.
19:30:52 <TSC> e-guru3: You could write a function (String -> FuncType) and hard-code a mapping
19:31:06 <e-guru3> Lemmih: I have a problem:) I have functiongs f, g, h and I should create compositions of these functions using permutation. f.g.h, f.h.g ... etc. do you know a way that I can create without the problem of functions becoming strings?
19:31:33 <glguy> e-guru3: use your function that creates permutations, and use it on your list
19:31:38 <glguy> of functions
19:31:40 <[d-_-b]> Trevion, Lemmih thanks
19:31:42 <[d-_-b]> :)
19:35:14 <sorear> ok, I'm using 6.6 release, and still getting syntax errors
19:35:26 <e-guru> glguy: that doesnt work, I get cant find show function for ...
19:36:23 <Trevion> e-guru, what are you trying to show?
19:37:12 <Lemmih> e-guru: Why do you want a show function?
19:37:21 <e-guru> Trevion: I am trying to do function compositions using permutation, f.g.h,  f.h.g ... etc.
19:37:34 <bitshifter> he has a list of functions
19:37:50 <bitshifter> e-guru: are you typing this in to ghci?
19:37:53 <e-guru> Lemmih: thats what hugs tell me when I try to do [f,g,h]
19:38:01 <e-guru> hugs
19:38:13 <Lemmih> e-guru: Well, don't try to print the list. Just use it.
19:38:20 <jcreigh> e-guru: You can't "show" them because there's no instance of Show for functions, but you can do stuff with the list.
19:38:51 <Trevion> > let f, g, h :: Int -> Int ; f = undefined ; g = undefined ; h = undefined in length [f,g,h]
19:38:52 <lambdabot>  3
19:38:55 <bitshifter> do something like let listOfFuncs = [f,g,h]
19:39:21 <e-guru> Lemmih: that makes sense, I just wanted to see what it looks like before using but I guess I dont hav eto
19:39:38 <jcreigh> > map (\f -> f 3) [ (\x -> x * 2), (\x -> x + 7) ]
19:39:40 <lambdabot>  [6,10]
19:40:36 <jcreigh> e-guru: ^^ for example
19:41:15 <Lemmih> e-guru: You could probably add 'instance Show (a -> b) where show _ = "function"' if you like (:
19:41:32 <jcreigh> Lemmih: I don't think that's allowed...
19:41:40 <allbery_b> anyone got the snippet from lambdabot's instance Show?
19:42:13 <allbery_b> (<Int -> String> and the like)
19:42:19 <Trevion> > let f = ('a':) in length (map (f .) [('b':),('c':)])
19:42:20 <lambdabot>  2
19:42:34 <Trevion> > let f = ('a':) in map ($ []) (map (f .) [('b':),('c':)])
19:42:36 <lambdabot>  ["ab","ac"]
19:42:42 <Trevion> or like that, e-guru
19:42:58 <Lemmih> jcreigh: It's valid Haskell98.
19:43:01 <Trevion> with both composition and application in action
19:43:23 <jcreigh> Lemmih: hmm, really?
19:43:26 * jcreigh tries it out
19:43:27 <allbery_b> yeh, it's perfectly valid.
19:43:55 <allbery_b> (a -> b) is a type like any other, you just can't peek inside values of the type
19:44:21 <jcreigh> Lemmih: hmm, you're right, it does work.
19:44:21 <allbery_b> which (show _ = "function") doesn't
19:44:29 <jcreigh> Lemmih++ That's pretty cool.
19:44:56 <jcreigh> For some reason I was thinking I'd tried it before and it "didn't work". But clearly, this is not the case.
19:45:15 <glguy> > (flip (foldl (.) id) 1) [(+5),(*2)]
19:45:16 <lambdabot>  7
19:45:40 <glguy> > foldl (.) id [(+5),(*2)] 1
19:45:41 <lambdabot>  7
19:46:15 <e-guru> I am even more confused...
19:47:15 <glguy> if you ask specific quesitons, I'll answer them for you
19:48:34 <glguy> it is probably easier to explain the fold as a foldr instead (but that doesn't change the meaning)
19:48:38 <glguy> in this case
19:50:36 <glguy> (+5) : (*2) : []  -> (+5) . (*2) . id
19:52:11 <Trevion> Hmm, can lambdabot show functions without typeable things on both ends
19:52:25 <glguy> ?
19:52:43 <glguy> > foldr (.) id [(+5),(*2)]
19:52:44 <lambdabot>  Add a type signature
19:52:55 <glguy> > foldr (.) id [(+5),(*2)] :: Int -> Int
19:52:57 <lambdabot>  <Int -> Int>
19:53:14 <Trevion> Can lambdabot do that if the things on both ends are Typeable?
19:53:23 <Trevion> I can see how to do it for the Typeable case without having to look inside the function
19:53:41 <Lemmih> Trevion: It's not possible to get the name of the types without Typeable.
19:54:29 <Trevion> That's what I figured.
19:54:33 <Trevion> Okay, I'm happy then.
19:55:00 <Trevion> That is actually a cool instance.  Is there a good reason it's not in the Prelude?
19:55:31 <allbery_b> if it depends on Typeable?  I'd stick it in the definition of Typeable
19:56:00 <Trevion> Fair enough, although I would support moving Typeable into the Prelude, myself.
19:56:06 <sorear> you CAN define a usable Show if the contravariant type is finite and the covariant type is countable.
19:56:08 <e-guru> s
19:56:24 <sorear> show not => "True False"
19:56:31 <Trevion> I find myself importing Typeable more often than not
19:58:31 <jcreigh> e-guru, e-guru2: what's with the multiple nicks?
19:58:53 <e-guru> jcreigh: I am keeping on disconnecting somehow from my laptop...
20:01:07 <e-guru> sorry
20:01:21 <jcreigh> np, I was just wondering.
20:02:11 <jcreigh> so are you fairly clear on how you can use all the usual list functions on lists of functions, you just can't do things like show them or test them for equality?
20:02:14 <jcreigh> @ e-guru
20:03:16 <e-guru2> jcreigh: I guess I could say I am ok with list functions, I have the haskell book next to me :)
20:03:38 <e-guru2> jcreigh: this is what I came up with so far... http://pastebin.ca/284593
20:04:50 <e-guru2> jcreigh: the problem is I need to create a list where I can use here ->  [ (m.n) (A,B,C,D) | (m,n) <- [(perm1,perm2),(perm1,perm3),(perm2,perm3)] ]   <- a list like [(perm1,perm2)...(perm3,perm1)] with every possible combination.
20:05:39 <Trevion> e-guru: why not use a list comprehesion there too?
20:08:08 <mutjida> ?usres
20:08:09 <lambdabot> Maximum users seen in #haskell: 305, currently: 276 (90.5%), active: 35 (12.7%)
20:09:10 <sorear> ?usesr
20:09:11 <lambdabot> Maximum users seen in #haskell: 305, currently: 276 (90.5%), active: 35 (12.7%)
20:09:35 * sorear never noticed lambdabot's autocorrector
20:11:51 <e-guru> sorry
20:12:00 <e-guru2> :) difficult problems really
20:12:01 <jcreigh> looks like an edit-distance of one gets automatically translated.
20:12:46 <augustss> @lp \ x -> x
20:12:47 <lambdabot> Maybe you meant: . bf ft help id let map pl slap v wn
20:13:10 <jcreigh> @ehlp
20:13:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:13:26 <jcreigh> maybe there's a minimum command length as well...
20:13:47 <augustss> could be some fuzzy compare
20:16:47 <dons> it does a prefix match, then a levenshtein edit distance correct
20:16:53 <dons> ?go haskell
20:16:55 <lambdabot> http://www.haskell.org/
20:16:55 <lambdabot> Title: Haskell - HaskellWiki
20:16:57 <dons> ^^ unique prefix
20:17:04 <dons> ?goggol haskell
20:17:05 <lambdabot> Unknown command, try @list
20:17:14 <dons> not quite inside the edit distance
20:17:18 <dons> (3 edits only allowed)
20:17:26 <dons> ?googol haskell
20:17:29 <lambdabot> http://www.haskell.org/
20:17:29 <lambdabot> Title: Haskell - HaskellWiki
20:17:29 <SamB_XP> ?goggle? hashkell
20:17:32 <lambdabot> http://it.movies.yahoo.com/artisti/s/hashkellweller-shore/index-473445.html
20:17:32 <lambdabot> Title: Hashkell weller Shore
20:18:12 <sorear> How is ?goggle legal but ?goggol isn't?
20:18:23 <jcreigh> g -> o
20:18:29 <sorear> nm, sorry, misremembered spelling of google
20:18:48 <sorear> (somehow I thought googol was correct)
20:18:48 <SamB_XP> ?googol googol
20:18:51 <lambdabot> http://en.wikipedia.org/wiki/Googol
20:18:51 <lambdabot> Title: Googol - Wikipedia, the free encyclopedia
20:18:54 <SamB_XP> ?spell google
20:18:55 <lambdabot> goggle googly Gogol go ogle go-ogle
20:18:55 <jcreigh> googol is the number
20:19:05 <dons> so I think it worked out 4 edits for goggol -> google
20:19:09 <dons> which would put it over the limit
20:19:10 <SamB_XP> @all-dict googol
20:19:12 <lambdabot> *** "googol" wn "WordNet (r) 2.0"
20:19:12 <lambdabot> googol
20:19:12 <lambdabot>    n : a cardinal number represented as 1 followed by 100 zeros
20:19:12 <lambdabot>      (ten raised to the power of a hundred)
20:19:12 <lambdabot>  
20:19:14 <lambdabot> [23 @more lines]
20:19:17 <TSC> Isn't that three edits?
20:19:27 <TSC> (three substitutions)
20:19:35 <dibblego> dons, where is the code for calculating the ED?
20:20:20 <SamB_XP> @google lithp
20:20:22 <lambdabot> http://www.gorge.org/jokes/lithp.shtml
20:20:23 <lambdabot> Title: The Gorge - Lithp Jokes
20:20:31 <dons> dibblego: in Lib/Util.hs
20:20:34 <dibblego> how is goggol -> google 4 edits?
20:20:36 <dons> TSC, and one transpose?
20:20:50 <dons> you only have: insert, delete, transpose
20:21:01 <TSC> Oh, no substitute/change
20:21:25 <dons> so goggol -> googgol -> googol -> googole -> google (I think)
20:21:32 <dibblego> ah
20:21:40 <dons> feel free to submit a change/subst patch :)
20:22:00 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Util.hs (from memory)
20:22:07 <dibblego> yep
20:33:10 <lispy> scsibug: interesting, i didn't realize ashley was a unisex name
20:33:43 <hyrax42> I think possibly more commonly so not in NA
20:37:02 <falconair> is there any project which uses haskell to implement formal models of concurrent/distributed systems (such as the actor model or pi calculus)?
20:37:36 <allbery_b> @go haskell "pi calculus"
20:37:40 <lambdabot> http://tsukimi.agusa.i.is.nagoya-u.ac.jp/~sydney/PiMonad/
20:37:41 <lambdabot> Title: PiMonad - a network programming framework based on Pi-Calculus
20:39:05 <glguy> ?users
20:39:05 <lambdabot> Maximum users seen in #haskell: 305, currently: 275 (90.2%), active: 29 (10.5%)
20:39:48 <falconair> allbery_b: hm...'under heavy constructon.'  the docs consist of just the api ... no paper which describe the problem, the domain and commentary on how haskell makes the problem trivial :) ?
20:40:07 <Trevion> > (+)
20:40:08 <lambdabot>  Add a type signature
20:40:12 <Trevion> ooh, clever
20:40:32 <allbery_b> that's just the first hit.  the second hit was a paper about it, when I looked it up in my browser
20:40:46 <allbery_b> (subseuent hits being references thereto)
20:41:19 <dons> > (+) :: Integer -> Integer -> Integer
20:41:20 <lambdabot>  <Integer -> Integer -> Integer>
20:41:44 <bitshifter> > (+) 5.0
20:41:45 <lambdabot>  Add a type signature
20:41:54 <glguy> > \ x -> (+) (x :: Integer)
20:41:56 <lambdabot>  <Integer -> Integer -> Integer>
20:41:58 <Trevion> hmm, but how can lambdabot tell if something is polymorphic>
20:42:43 <allbery_b> asks ghci, I think
20:44:18 <Trevion> Hmm.
20:45:14 <dons> it compiles it and tries to 'show' the result
20:45:23 <dons> there's no show instance for most polymorphic values
20:46:06 <dons> $ uricheck /home/dons/doc/users_guide/*.html
20:46:07 <dons> Found 0 broken links. Checked 137 links (46 unique) in 75 files).
20:46:09 <dons> :D
20:46:38 <Trevion> So is "Add a type signature" the generic response for things without show instances?
20:46:48 <dons> in lambdabot , yeah
20:46:50 <Trevion> Ah, okay
20:46:59 <Trevion> That's not as clever as I'd hoped.  (-;
20:47:11 <Lemmih> s/most//
20:51:22 <mutjida> ?list
20:51:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:51:57 <sorear> dons: the 'Read the source code' link on the lambdabot site is dead
20:52:13 <mutjida> ?help
20:52:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:52:21 <mutjida> @help
20:52:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:52:33 <mutjida> ?help list
20:52:33 <lambdabot> list [module|command]
20:52:33 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:52:48 <mutjida> ?version
20:52:49 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
20:52:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:57:30 <notsmack> where's a good haskell -> html with syntax coloring module?
20:58:14 * notsmack finds hscolour
20:58:37 <dons> yep
20:59:43 <LordBrain> suppose I have the function monap = liftM2 ($)
21:00:18 <chessguy> ai
21:00:28 <chessguy> oops
21:00:33 <LordBrain> and the code:   monap mf mx
21:00:51 <LordBrain> suppose also, mf and mx have side effects
21:01:13 <LordBrain> is it gauranteed that mf's side effects will happen before mx's?
21:01:49 <glguy> yeah
21:01:56 <int-e> depends on the monad ...
21:02:19 <glguy> liftM2 a b c = do { x <- a; y <- b; return (c x y) }
21:02:29 <jcreigh> hmmm...The docs say that Either is an instance of Functor, but it's not obvious to me how that could be.
21:02:40 <glguy> liftM2 is guarenteed to do that at least
21:02:46 <int-e> jcreigh: Either a  is.
21:02:49 <LordBrain> ok, thats what i was thinking glguy... wanted to verify it
21:02:50 * chessguy has the bright idea to create a haskell wiki page for an idea he's had for a long time
21:02:57 <glguy> jcreigh: thing of Right = Just, Left = Nothing
21:03:07 <chessguy> (i knew i had too much caffeine too late in the day today)
21:03:22 <jcreigh> "Either a" meaning the Left and Right types are the same?
21:03:32 <int-e> jcreigh: no
21:03:40 <glguy> > fmap succ (Right 1) :: Either () Int
21:03:42 <lambdabot>  Right 2
21:03:46 <int-e> jcreigh:  that's a partial type constructor application
21:03:49 <glguy> > fmap succ (Left 1) :: Either  Int ()
21:03:50 <lambdabot>  Left 1
21:04:01 <augustss> LordBrain: liftM2 ($) is called ap
21:04:15 <int-e> jcreigh: fmap will have type  fmap :: (b -> c) -> Either a b -> Either a c
21:04:57 <LordBrain> oh... yeah that's a nerve pathtway that I should already have had formed...
21:05:01 <glguy> ?type \x -> fmap (x :: Either () Int)
21:05:02 <lambdabot>   Expecting a function type, but found `Either () Int'
21:05:03 <lambdabot>    Expected type: a -> b
21:05:11 <glguy> ?type \f x -> fmap f (x :: Either () Int)
21:05:12 <lambdabot>   No instance for (Functor (Either ()))
21:05:13 <lambdabot>    arising from use of `fmap' at <interactive>:1:8-11
21:05:17 <LordBrain> :)
21:05:36 <int-e> now the question is ... where is that alleged instance.
21:05:48 <glguy> ?type \f x -> fmap f (x :: Either () Int) :: Either () Int
21:05:49 <lambdabot>   No instance for (Functor (Either ()))
21:05:50 <lambdabot>    arising from use of `fmap' at <interactive>:1:8-11
21:06:21 <jcreigh> I thought the "Left is error, Right is value" was purely conventional.
21:06:36 <augustss> it is
21:06:40 <glguy> jcreigh: it's also how the Functor instance, and the MonadError instance work
21:07:18 <int-e> @instances-importing Control.Monad.Error (Either ())
21:07:19 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:07:35 <int-e> @help instances-importing
21:07:35 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
21:07:37 <glguy> > fail "oops" :: Either String ()
21:07:38 <lambdabot>  Left "oops"
21:07:43 <int-e> @instances-importing Control.Monad.Error Functor
21:07:44 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:07:50 <glguy> > fail "oops" >> return 1 :: Either String Int
21:07:52 <lambdabot>  Left "oops"
21:07:54 <allbery_b> Data.Either has Functor (Either a)
21:07:56 <int-e> note the 'Either e'
21:07:58 <glguy> > return 1 :: Either String Int
21:08:00 <lambdabot>  Right 1
21:08:17 <glguy> > fail "oops" `mplus` return 1 :: Either String Int
21:08:18 <lambdabot>  Right 1
21:08:20 <dons> seen in HaskellNet, uglyDeathTransfer :: BSStream s => s -> IO (Result ([Header],String))
21:08:35 <int-e> allbery_b: hmm. not in my version of the base libs.
21:08:56 <allbery_b> that's according to online ghc docs
21:09:25 <lispy> dons: heh
21:09:51 <allbery_b> which seem to not always match reality (they also claim Monad ((->) a) is in Control.Monad instead of Control.Monad.Reader)
21:10:09 <lispy> dons: in the same module as makesUnsafePerformIOLookGood ?
21:11:47 <jcreigh> okay, what modules do I need to load in ghci to get the instance of Functor? It doesn't seem to be in Data.Either
21:12:39 <lispy> ?instaces Functor
21:12:40 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:12:41 <LordBrain> @type ap
21:12:42 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:12:54 <lispy> ?instances Either
21:12:55 <LordBrain> is there a functor version of ap?
21:12:55 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:13:05 <lispy> ?instances-importing Either
21:13:06 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:13:09 <sorear> LordBrain: no
21:13:18 <lispy> jcreigh: i'm not sure
21:13:24 <allbery_b> ?instances-importing Functor
21:13:25 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:13:39 <sorear> LordBrain: adding ap to functor produces a less general class called Control.Applicative.Applicative
21:13:52 <allbery_b> ?source Control.Monad.Error
21:13:53 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
21:14:21 <LordBrain> oh cool
21:16:41 <Cale> http://programming.reddit.com/info/vbbo/comments
21:16:42 <lambdabot> Title: A simple RSS aggregator in about 50 lines of Haskell using HXT (reddit.com)
21:18:02 <sorear> @tell dons the 'Read the source code' link on the lambdabot site is dead
21:18:02 <lambdabot> Consider it noted.
21:19:40 <Chad> Other than SerTH, what exists for performing serializaiton?
21:20:40 <sorear> genericserialize, DrIFT
21:20:58 <jcreigh> okay, so the Monad instance is in Control.Monad.Error (thank you allbery_b). It appears to act like Maybe, except that Nothing has a value. I'm still in the dark as to how the Functor instance works...
21:21:41 <int-e> @djinn (a -> b) -> Either c a -> Either c b
21:21:42 <lambdabot> f a b =
21:21:42 <lambdabot>   case b of
21:21:42 <lambdabot>   Left c -> Left c
21:21:42 <lambdabot>   Right d -> Right (a d)
21:22:01 <Cale> jcreigh: in the only way it can :)
21:22:09 <jcreigh> Cale: with fmap = liftM?
21:22:13 <glguy> jcreigh: did you miss the example earlier of how it works
21:22:28 <Cale> jcreigh: yeah
21:22:33 <sorear> note that genericserialize is incompletely developed - if you think it's what you want, use the darcs version, and don't hesitate to ask me for fixes.
21:24:12 <jcreigh> glguy: I saw the code. I didn't get it then. But now I'm thinking because of the instance of Monad for Either, we have fmap f (Left x) = Left x, fmap f (Right x) = f x
21:24:30 <Cale> Right (f x)
21:24:31 <jcreigh> err, fmap f (Right x) = Right (f x)
21:24:41 <jcreigh> dang it, Cale's too quick. :)
21:25:40 <jcreigh> So Maybe a is basically Either () a
21:25:52 <glguy> yeah
21:26:07 <glguy> basically
21:26:25 <glguy> Either () a   isn't a monad
21:26:38 <Cale> It is a monad, but it's not an instance of Monad
21:26:52 <sorear> Maybe a is exactly Either () a, in the algebraic setting; both are /\ a -> 1 + a
21:26:53 <Cale> but that's more of an artifact of the way the mtl is set up.
21:27:09 <glguy> I'm not arguing that it can't be defined
21:27:39 <Cale> I really think that the instance Monad (Either e) should be in the Prelude.
21:27:53 <Cale> as well as instance Monad ((->) e)
21:28:56 <SamB_XP> patience, young padawan!
21:29:47 <ptolomy> for such a neat language, Clean has an ugly webpage.
21:30:06 <jcreigh> if Either isn't a Monad, how does "return 1 :: Either String Int" work?
21:30:23 <fridim> hello
21:30:40 <hyrax42> what does /\ a mean?
21:30:41 <SamB_XP> jcreigh: it is a monad
21:30:47 <SamB_XP> it just dosen't have an instance in Prelude
21:30:53 <glguy> Am I correct in stating that Clean's uniquness types only provide for guarenteed sequencing of operations, and not the plumbing to effectively implement things like Cont?
21:30:58 <fridim> in YAHT, lots of example are like that :    factorial 0 = 1      \    factorial n = n * factorial (n-1)
21:31:11 <fridim> but with gchi and hugs it requires 'let'
21:31:15 <fridim> is there a reason ?
21:31:18 <SamB_XP> I thought they only provided for maintaining a single copy of the world
21:31:33 <SamB_XP> but then I never learned much about them
21:31:48 <glguy> Well, they provide for only allowing you to use the value once
21:31:54 <int-e> fridim: it will work without let in .hs files.
21:32:00 <fridim> oh ok
21:32:25 <chessguy> ok, new page is up
21:32:26 <chessguy> http://www.haskell.org/haskellwiki/Evolutionary_Chess
21:32:27 <lambdabot> Title: Evolutionary Chess - HaskellWiki
21:32:56 <int-e> fridim: the interpreters basically interpret expressions. for convenience, ghci allows bindings like in a do block; I'm not sure what hugs currently does.
21:33:01 <jcreigh> I guess I misunderstood glguy saying "Either () a" isn't a monad. Indeed, I don't think I quite grok the unit type.
21:34:44 <SamB_XP> jcreigh: I think he was just saying that, in Haskell 98, Either () isn't a Monad
21:35:03 <SamB_XP> however, import Control.Monad.Instances, and presto
21:35:08 <SamB_XP> its a Monad!
21:35:43 <hyrax42> chessguy: I will read that soon
21:36:57 <sorear> hyrax42 : /\ is the standard notation (not supported in Haskell) for a type-level lambda.
21:37:28 <hyrax42> hmm
21:37:31 <sorear> It's supposed to represent an uppercase lambda (which looks like an upside down V)
21:37:35 <hyrax42> where do I read more
21:37:37 <SamB_XP> so what is a kind-level lambda?
21:37:42 <SamB_XP> \/\?
21:37:44 <SamB_XP> /\?
21:37:48 <SamB_XP> er.
21:37:52 <hyrax42> is that in tapl or atapl?
21:37:52 <SamB_XP> //\
21:38:06 <sorear> never read either.
21:38:21 <hyrax42> any reference then?
21:38:24 <glguy> Λ   you can just use this if you like :)
21:38:25 * sorear feels somewhat embarressed.
21:38:35 <sorear> I've never read either of those books.
21:38:40 <SamB_XP> what is Λ?
21:38:45 <hyrax42> well you picked something up somewhere?
21:38:48 <glguy> Capital lambda
21:38:59 <jcreigh> oh, and Control.Monad.Instances also nets us the elusive Functor instance of Either.
21:39:00 <sorear> In IRC, r-ee-ahd and r-eh-duh sound the same
21:39:06 <fridim> wah fibonacci 1 = 1    \  fibonacci 2 = 1   \ fibonacci n = fibonacci (n-1) + fibonacci (n-2)    -- Is VERY slow
21:39:10 <Chad> I can't seem to find much of anything on "genericserialize"
21:39:20 * SamB_XP thought capital lambda looked like L
21:39:27 <sorear> I don't want so say "never r-ee-ad either [of tapl or atapl]"
21:40:04 <hyrax42> sorear: I'm just askign where you learned of this, and if you had pionters
21:40:06 <glguy> SamB_XP: Γ  this is Gamma
21:40:11 <SamB_XP> oh
21:40:37 <glguy> My college fraternity was the ΓΛ chapter
21:40:41 <SamB_XP> I think most of my capital-greek-letter knowlege comes from frats...
21:40:43 <sorear> Chad: I'm not suprised, I only announced the (experimental, not likely to be useful yet) library a few days ago
21:40:49 <SamB_XP> not that I've been inside any or anything
21:40:58 <SamB_XP> I have for some reason seen some signage though
21:41:00 <glguy> of ΠΚΦ , so I'd be embarrassed (myself) not to know those
21:41:25 <sorear> Unfortunately all I see is 'N[  you can just...'
21:41:31 <SamB_XP> I know sigma and pi, of course
21:41:49 <SamB_XP> (sum and product they are, after all)
21:42:07 <Chad> sorear: compared to SertTH, how do you reccomend DriFT?
21:42:18 <sorear> I've never used either.
21:42:26 <wy> look like Greek to me. What's the topic tonight?
21:42:28 <glguy> Uppercase Greek alphabet ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
21:43:02 <chessguy> hey wow, xchat managed to render that pretty well
21:43:12 <SamB_XP> > "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ"
21:43:13 <lambdabot>  lexical error in string/character literal
21:43:13 <jcreigh> my poor little X11 "fixed" font sees only ????s
21:43:20 <hyrax42> we live in the future now
21:43:25 <glguy> Lowercase greek alphabet αβγδεζηθικλμνξοπρςστυφχψω
21:43:29 <sorear> Chad: I don't have much use for serialization myself - I wrote genericserialize in response to IIRC an argument in #haskell about what language extention to use for serialization; my point was to prove you didn't need one.
21:43:29 <SamB_XP> > "ΑΒΕΖΗΙΚΜΝΟΡΤΧ"
21:43:30 <lambdabot>  lexical error in string/character literal
21:43:32 <hyrax42> where people can type in other languages
21:43:38 <glguy> jcreigh: the fixed font has ALL of the characters
21:43:48 <sorear> 'Uppercase Greek alphabet NQNRNSNTNUNVNWNXNYNZN[N\N]N^N_N`NaNcNdNeNfNgNhNi'
21:43:49 <glguy> jcreigh: you need iso10646-1 and to start with uxterm
21:43:59 <glguy> jcreigh: all of which should be built in
21:44:01 <hyrax42> for some reason, the versions of the glyphs I see are tiny tiny tiny
21:44:19 <hyrax42> I wonder what font it defaults to here
21:44:28 <SamB_XP> @show ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
21:44:29 <lambdabot> "\206\145\206\146\206\147\206\148\206\149\206\150\206\151\206\152\206\153\206\154\206\155\206\156\206\157\206\158\206\159\206\160\206\161\206\163\206\164\206\165\206\166\206\167\206\168\206\169"
21:44:36 <SamB_XP> hmm.
21:44:49 <chessguy> heh
21:44:52 <chessguy> @show foobar
21:44:52 <lambdabot> "foobar"
21:45:06 <SamB_XP> lambdabot obviously needs some utf8 support
21:45:07 <Cale> alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you sing with me?
21:45:25 <SamB_XP> for both serialization and IRC I/O
21:45:35 <Cale> doesn't quite scan the right way :)
21:45:40 <chessguy> ?remember Cale alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you sing with me?
21:45:44 <SamB_XP> instated at the *SAME TIME*
21:46:04 <glguy> ?quote SamB_XP
21:46:05 <lambdabot>  I once saw it eat a comment (:[{- Help! -}])
21:46:42 <SamB_XP> the greedy (:[]) robot. well, at least, someone called it that at the time.
21:47:10 <chessguy> >  (:[{- Help! -}])
21:47:11 <lambdabot>  Add a type signature
21:47:26 <SamB_XP> @type (:[{- Help! -}])
21:47:28 <lambdabot> forall a. a -> [a]
21:47:37 <glguy> > (:[{- Help! -}]) :: () -> [()]
21:47:38 <chessguy> >  (:[{- Help! -}]) :: [Int]
21:47:39 <lambdabot>  <() -> [()]>
21:47:39 <lambdabot>    Expecting a function type, but found `[Int]'
21:47:39 <lambdabot>    Expected type: [Int]
21:47:39 <lambdabot> ...
21:47:47 <sorear> Ok, I've manages to see the greek alphabet : box box gamma box box box box phi box box box ...
21:47:51 <chessguy> heh
21:48:06 <SamB_XP> sorear: funny.
21:48:22 <Cale> http://programming.reddit.com/info/vbbo/comments -- more mod ups! more! hehe
21:48:23 <lambdabot> Title: A simple RSS aggregator in about 50 lines of Haskell using HXT (reddit.com)
21:48:24 <sorear> I have a *256 character* terminal!
21:48:27 <SamB_XP> the characters you see as "box" are apparantly exactly those characters that look just like the latin alphabet
21:49:03 <SamB_XP> wait, no.
21:49:04 <SamB_XP> worse.
21:49:10 <SamB_XP> you are missing Delta...
21:49:10 <Cale> Like Δ looks exactly the same as D
21:49:13 <SamB_XP> and more...
21:49:20 <SamB_XP> ick.
21:49:40 <Cale> give or take a few thousand years
21:49:54 <Chad> sorear: How do you recommend serializtion of many different types for socket transmission?
21:49:58 <sorear> And that was *after* changing two options in ircII and echoing \e%G > tty6
21:50:06 <SamB_XP> but you'd think that something would be able to use the latin glyphs for those greek codepoint
21:50:09 <sorear> Chad: elaborate?
21:50:21 * sorear is using the linux-console
21:50:30 <Cale> Chad: If you're not obsessed with performance, read/show are often enough.
21:50:32 <mbishop> ?
21:52:03 <sorear> genericserialize's theoretical advantage is that it can be compatible with many different formats.  If you can chose the format, I'd look into AltBinary+DrIFT (although in part because I haven't heard of SerTH)
21:52:25 <Chad> sorear: say for example a protocol with structures relating to login, authentication, etc. ie, perhaps : 5 Int32s and two 8 length arrays of char
21:52:56 <Chad> Cale: and marshall the show/read ?
21:53:10 <Cale> Oh, you want an exact binary format?
21:53:40 <sorear> then you do *not* want any of [SerTH, DrIFT, genericserialize].
21:53:40 <Chad> Cale: yup.
21:53:52 <Cale> okay, that's completely different then :)
21:54:09 <sorear> you should write the serialization code yourself if you have to conform to an existing ad-hoc format.
21:54:47 <sorear> (existing generic formats can be implemented in genericserialize, but I doubt you are dealing with a generic serialization system.)
21:56:18 <Cale> Probably use Data.ByteString
21:57:28 <Cale> You can use the Network library to get a Handle, and hPutStr to print ByteStrings to the handle.
21:57:42 <sorear> hPutStr is overloaded !?
21:57:55 <sorear> ?hoogle ByteString -> IO ()
21:57:56 <lambdabot> No matches, try a more general search
21:57:59 <Cale> not overloaded, just defined in multiple modules
21:58:02 <sorear> ?hoogle Data.ByteString -> IO ()
21:58:02 <lambdabot> No matches, try a more general search
21:58:06 <sorear> ?hoogle Data.ByteString -> IO a
21:58:07 <lambdabot> No matches, try a more general search
21:58:14 <Cale> Data.ByteString is a module
21:58:17 <Cale> not a type
21:58:35 <Cale> @hoogle Handle -> ByteString -> IO ()
21:58:36 <lambdabot> No matches, try a more general search
21:58:44 <LordBrain> ?hoogle Data.ByteString.Char8 -> IO ()
21:58:44 <lambdabot> No matches, try a more general search
21:58:47 <sorear> ?hoogle Data.ByteString.ByteString -> IO ()
21:58:48 <lambdabot> No matches, try a more general search
21:58:51 <Cale> @type Data.ByteString.hPutStr
21:58:52 <lambdabot> GHC.IOBase.Handle -> Data.ByteString.Base.ByteString -> IO ()
21:58:58 <Cale> there we go
21:59:02 <LordBrain> heh
21:59:03 <Cale> hoogle doesn't know about it
21:59:31 <Chad> Havn't played with ByteString yet
21:59:36 <Cale> @type Data.ByteString.pack
21:59:38 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
21:59:50 <Chad> I could use it then to represent datatypes?
22:00:15 <sorear> yes
22:00:17 <Cale> Well, you'll need to write functions which implement your protocol in marshalling the datatypes
22:00:39 <Cale> It may be useful to define a typeclass similar to Show for this.
22:01:02 <Cale> class MyProtocol t where
22:01:21 <Cale>    toByteString :: t -> ByteString
22:01:26 <Cale>    fromByteString :: ByteString -> t
22:01:40 <Chad> hmm
22:01:44 <Cale> or whatever names you want to call them
22:02:07 <Chad> havn't read about typeclasses much, i'll put that on my todo!
22:02:21 <sorear> ?users
22:02:22 <lambdabot> Maximum users seen in #haskell: 305, currently: 273 (89.5%), active: 32 (11.7%)
22:02:35 <Cale> Then if your protocol supports things like lists, you could even have:
22:02:49 <Cale> instance MyProtocol a => MyProtocol [a] where
22:02:52 <Cale>   ...
22:03:50 <SamB_XP> sorear: so is genericserialize actually compatible with any formats in a useful way?
22:03:52 <Cale> and probably it would be a good idea to do tuple instances, which just put things side by side.
22:03:54 <LordBrain> in oop i believe thats called the composite design pattern
22:05:26 <Chad> Cale: yah, i'm sure there's neat things to get around problems like this. I'm just not aware of hwo to use typeclasses / instances
22:05:48 <Chad> Cale: thanks for the direction though :)
22:05:49 <LordBrain> you havent lived
22:06:09 <LordBrain> i mean... without typeclasses :)
22:06:13 <Cale> Chad: no problem, let me know if you need any help with it
22:06:17 <Cale> LordBrain: hehe
22:06:39 <SamB_XP> what is this... "life without typeclasses"?
22:07:31 <LordBrain> *shudders*
22:07:53 <LordBrain> i guess its called ocaml
22:08:06 <SamB_XP> maybe it is conway's life
22:08:10 <SamB_XP> I hear that is turing complete
22:08:33 <Cale> SamB_XP: and how! You should see some of the things people do with life
22:08:41 <SamB_XP> apparantly you can build a utm with it
22:08:45 <Cale> yeah
22:08:57 <SamB_XP> who knows how they move the tape back and forth
22:09:03 <sorear> me!
22:09:04 <SamB_XP> (or is it the head?)
22:09:08 <Cale> also, http://www.radicaleye.com/lifepage/patterns/unitcell/ucdesc.html
22:09:09 <lambdabot> Title: David Bell's Unit Life Cell
22:09:23 <SamB_XP> sorear: you would know...
22:09:26 <Cale> Life in life
22:09:34 <sorear> Rendell's utm has two stacks and pops from one to push into the other.
22:09:41 <SamB_XP> Cale: I have a very simple embedding
22:09:49 <Cale> hehe
22:09:55 <SamB_XP> I just take each cell... and implement it as a cell of the same value
22:10:03 <Cale> the idea is to give a nontrivial embedding :)
22:10:07 <LordBrain> utm?
22:10:09 <sorear> Is it still an embedding if it is bijective?
22:10:17 <SamB_XP> LordBrain: universal turing machine
22:10:19 <SamB_XP> sorear: sure!
22:10:20 <LordBrain> ah
22:10:24 <LordBrain> thankyou
22:10:29 <LordBrain> anyway... bedtime for me
22:10:49 <SamB_XP> so the tape on that thing -- it goes diagonally I guess?
22:10:53 <sorear> yes
22:10:59 <sorear> almost diagonally
22:11:01 <SamB_XP> just like everything else ;-)
22:11:13 <SamB_XP> chess knight diagonally?
22:11:19 <sorear> it has a couple of gates, that allow the data to be moved at command
22:11:27 <sorear> it is not universal, though
22:11:32 <sorear> it has a finite tape
22:11:37 <SamB_XP> what!
22:11:45 <SamB_XP> I bet I could fix that
22:11:55 <sorear> one universal computer has been built in Life, a Minsky Register Machine
22:12:12 <SamB_XP> how come the tape is finite?
22:12:15 <Excedrin> what is this C++0x "09 is looking likely" ? does that mean that the next revision of the C++ spec will be in 2009?
22:12:16 <sorear> a natural number stores an infinite amount of data
22:12:32 <SamB_XP> because you actually have to have something there for there to be tape?
22:12:36 <SamB_XP> or is it more than that?
22:12:38 <sorear> divide by two, multiply by two to use it as a stack
22:13:02 <sorear> yes, if the initial configuration is finite Rendell's utm has a finite tape
22:13:22 <SamB_XP> which moves -- the tape or the head?
22:13:25 <sorear> Rendell's utm is universal with an infinite initial condition
22:13:28 <sorear> the tape
22:13:37 <SamB_XP> oh, okay, that is a bit bothersome
22:14:05 <sorear> Unfortunately AFAIK there is only one implementation of life with infinite initial conditions
22:14:22 <SamB_XP> that does sound rather tricky
22:14:31 <sorear> an unincorporated patch to Golly
22:14:43 <SamB_XP> it would need some good proofs...
22:15:06 <sorear> actually the algorithm is simpler than it sounds, but I gave up on it when I couldn't get cut&paste to work
22:15:15 <SamB_XP> ah well, but anyway, that isn't the point
22:15:27 <SamB_XP> no computing machine has unbounded storage on its own
22:15:51 <SamB_XP> I mean, (next to) nobody quibbles that C ain't turing complete because the pointers have finite size
22:15:51 <sorear> An infinite board does not need an infinite amount of storage
22:16:15 <SamB_XP> not unless it is truly randomized to start with
22:16:17 <sorear> I've been meaning to quibble about that for a while...
22:16:21 <SamB_XP> hah
22:16:27 <geckosenator> well you could access more memory with pages
22:16:29 <sorear> s/not/not necessarily/
22:16:34 <SamB_XP> we will put you in the list of O(1) people
22:16:36 <geckosenator> but I guess that isn't in the c standard
22:17:03 <SamB_XP> (people who think every algorithm is O(1))
22:17:07 <sorear> just as the infinite number '0.33333333333333333....' can be stored in 20 words as Ratio Int
22:17:16 <lispy> infinite?
22:17:19 <SamB_XP> (as implemented on finite computers)
22:17:33 <SamB_XP> sorear: is it only 20?
22:17:50 <lispy> i guess you could probably argue that just about everything is infinite in some sense (although, not sure how the argument goes with the empty set)
22:17:51 <jcreigh> 1 / 3 looks like two Ints to me. :)
22:17:51 <SamB_XP> oh, words, right
22:18:09 <notsmack> the infinite number '3.000000000000000000....'
22:18:12 <SamB_XP> hmm.
22:18:12 <sorear> 2 words (tag + Int#) for each Int, 3 for the Ratio, uh that adds to 7 words
22:18:27 <SamB_XP> hmm.
22:18:35 <SamB_XP> wait, thats not even more than Rational
22:18:39 <SamB_XP> (Ratio Integer)
22:18:47 <sorear> an infinite life board with a finite deviance can be stored as a set of tiles;
22:18:57 <SamB_XP> but that ain't no tag - that is an info pointer
22:19:10 <sorear> an infinite life board with a finite deviance from a computable background can as well.
22:19:28 <sorear> the periodic tape of a Rendell utm qualifies as computable
22:19:34 <SamB_XP> as long as the background is computable by f(x,y,t)?
22:19:37 <sorear> yes
22:20:12 <sorear> Hashlife is cool.
22:20:34 <SamB_XP> how would you prove that f(x,y,t) was a valid background?
22:21:02 <sorear> The same way you prove that return x >>= f <--> f x
22:21:16 <SamB_XP> you mean by going to bed so as I could think first?
22:21:19 <sorear> i.e you leave it as an obligation to the user
22:21:33 <SamB_XP> oh, right
22:21:38 <SamB_XP> well, what if I *am* the user
22:21:59 <SamB_XP> In that case, should I go to bed so I can think first?
22:22:11 <sorear> well, I implemented a safe wrapper, which satified the proof obligation for you, but only worked for periodic bg's.
22:22:39 <SamB_XP> periodic in time and space, I assume?
22:22:47 <SamB_XP> oh, but I guess that is a given...
22:22:55 * SamB_XP smacks self
22:23:01 <sorear> if it is periodic in space it is periodic in time
22:23:16 <sorear> since by symettry it runs on a toroidal grid, which is finite
22:23:18 <SamB_XP> if it is periodic in space, that means you can cut out a tile and you will eventually get back to a state you've been in...
22:23:25 <sorear> see above about finite computers
22:23:42 <SamB_XP> about everything being O(1) on them?
22:24:11 <sorear> at least, every operation loops.
22:24:33 <SamB_XP> well it ain't much of an algorithm (in the traditional sense) if it doesn't terminate...
22:24:34 <mwc> Let's say I have a class: class (Ord k) => Map m k v where { empty :: m k v; bind :: k -> v -> m k v -> m k v; lookup :: k -> m k v -> Maybe v}; what're the consequences of having v in the type class and not having it in there?
22:24:52 <mwc> I'm looking for the semantics of what that decision means.
22:25:18 <sorear> IF b is in the type class, you can define specific instances; e.g Map foo Bool could be a simple Set
22:26:06 <sorear> IF b is *not* in the class, maps must be parametric on their values, which is a very strong property
22:26:41 <sorear> e.g. it allows you to statically prove from the types that data can be rearranged and dropped by a buggy Map but not corrupted
22:27:00 <mwc> I kind of see it now. I suppose I could take k out of the signature for the same reason.
22:27:11 <sorear> a 1 will stay a 1, but may show up on 0 or more arbitrary keys
22:27:23 <sorear> (for the not-in-class variant)
22:27:33 <SamB_XP> mwc: I'm not sure you can
22:27:36 <sorear> See, for example, Data.Array.UArray
22:27:49 <SamB_XP> various Mappy things may need to constrain their keys in various ways
22:27:58 <mwc> Yeah, like Ord for instance
22:28:03 <SamB_XP> but, um, sleep
22:28:11 <mwc> I'm just looking at some code and trying to understand the design of it more than the implementation
22:28:12 <SamB_XP> mwc: or maybe they need to radix-sort it
22:28:23 <SamB_XP> or something like that
22:29:55 <dons> cool, my link checker seems to be working:
22:29:56 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
22:29:58 <dons> $ uricheck ~/doc/users_guide/*.html
22:29:58 <dons> Checking 1 urls in License.html        ... done.
22:29:58 <dons> Checking 6 urls in arrow-notation.html ... done.
22:29:58 <dons> ...
22:30:00 <dons> Found 3 broken links. Checked 137 links (46 unique) in 75 files.
22:30:02 <dons> Search time: 117 secs
22:30:05 <dons> :D
22:30:09 <sorear> the Maps may need to constrain keys, but few need to constrain values.
22:30:20 <mwc> Okay, I see it now
22:30:27 <sorear> dons: what an interesting coincidence, of @tell and subject.
22:30:39 <dons> hehe
22:31:35 <dons> this program is actually a lot prettier than I thought it would be
22:31:38 <sorear> Unfortunately, 6.6 has sorear-intractibly failed in compiling 6.4.2, so I'll have to install the binary distribution (which has already been dropped from d-unstable)
22:43:41 <notsmack> woo, changed HsColour to output Text.XHtml.Strict.Html
22:43:48 <notsmack> disturbingly easy
22:45:02 <glguy> the xhtml library is pretty slick
22:45:28 <notsmack> glguy: yeah, it's not bad... i don't like how much invalid xhtml can be represented that typechecks
22:46:24 <glguy> ah, that it allows attributes that don't exist and elements to nest that shouldn't?
22:46:36 <notsmack> yeah
22:46:38 <fridim> what is the problem : http://paste.lisp.org/display/32886
22:47:30 <glguy> fridim: is there a tab in there maybe?
22:47:47 <glguy> OH
22:47:54 <glguy> fridim: the last line in your main
22:48:14 <fridim> and ?
22:48:16 <glguy> you either need to do something, or not use the "nums <-"
22:48:21 <fridim> it comes from right from yaht
22:48:36 <glguy> well, either you are forgetting to do something, or YAHTis wrong
22:48:42 <glguy> because you nee a print nums
22:48:43 <glguy> or something
22:48:46 <fridim> It seems.
22:48:59 <glguy> right now you are getting the nums and not doing anything with them
22:49:22 <fridim> I go by step
22:49:48 <glguy> maybe YAHT doesn't expect the code to run yet because they aren't done explaining something
22:50:28 <fridim> I go to sleep.
22:50:51 <fridim> The last statement in a 'do' construct must be an expression
22:50:57 <fridim> I really don't understand this sentence.
22:51:03 <glguy> and nums <- getNums    isn't an expression
22:51:21 <glguy> a "do construct" is a block of code inside a "do"
22:51:36 <Excedrin> add a line after line 8 that says, "return ()"
22:51:37 <glguy> do { nums <- getNums; print nums } -- valid
22:51:54 <glguy> do { nums <- getNums } -- doesn't end with an expression
22:51:59 <fridim> Oh i've understood
22:52:04 <fridim> thanks
22:52:08 <glguy> np
22:52:35 <glguy> It's weird to think that Windows Vista's final version is out
22:52:54 <Excedrin> I thought it was like Duke Nukem Forever
22:53:39 <glguy> it still feels experimental (and from talking to my cousin, actually using it feels experimental too)
22:58:04 * glguy wonders how important disks 3 and 4 are in the 5 CD set...
23:00:04 <sieni> glguy: Number 4 might be very important, if the same rule as for songs on a CD applies (the best song is always either song number 4 or 7)
23:01:29 <dons> mmmm. 2 dollar banana
23:02:37 <monochrom> expensive
23:03:22 <dons> yep. first banana i've eaten in a year, since a cyclone wiped out the crop in .au
23:03:32 <dons> and made them too expensive
23:03:53 <seba> sounds like japan
23:37:48 <dons> Cale++ http://programming.reddit.com/info/vbbo/comments
23:37:50 <lambdabot> Title: A simple RSS aggregator in about 50 lines of Haskell using HXT (reddit.com)
23:43:19 <dons> Cale, to cabalise , I suggest: mkcabal
23:43:25 <dons> (that's all you should need to do ;)
23:43:34 <Cale> yeah, that's what I was thinking :)
23:44:01 <therp> darcs ghc gives me a cmm lint error for AutoApply.cmm. removing -dcmm-lint seems wrong :)
23:47:57 <dons> Cale, so is it actually sucking down rss feeds from the network?
23:48:05 <dons> here: runX $ root [] [catA . map (readDocument [(a_validate, v_0)]) $ srcs]
23:48:09 <Cale> yes
23:48:15 <dons> that's very neat
23:48:41 <Cale> that sucks them down and joins them into one big xml tree
23:48:41 <dons> and i just spent an hour reimplementing MiniHTTP for my linkchecker :)
23:48:57 <dons> nice
23:49:59 <Cale> which is later broken apart into feeds by the getChildren just under the selem "body"
