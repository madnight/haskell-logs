00:22:34 <dons> ?users
00:22:35 <lambdabot> Maximum users seen in #haskell: 276, currently: 246 (89.1%), active: 20 (8.1%)
00:25:54 <dmead> ?freshname
00:25:54 <lambdabot> Hadk
00:26:24 <Olishna> hallo all
00:27:14 <astrolabe> morning Olishna
00:27:57 <Olishna> astrolabe :)
00:33:27 * therp is always reading astrobabe 
00:40:10 <lisppaste2> kzm pasted "type annotation gives error" at http://paste.lisp.org/display/31354
00:41:13 <kzm> I'm unsure what the error message means.  If anybody has suggestions to make, it's 'preciated.
00:41:13 <lambdabot> kzm: You have 1 new message. '/msg lambdabot @messages' to read it.
00:41:49 <kzm> dons: where are the categories? /me checks the wiki.
00:44:27 <dons> kzm, here....
00:44:43 <dons> The Categories: http://haskell.org/haskellwiki/Libraries_and_tools
00:44:44 <lambdabot> Title: Libraries and tools - HaskellWiki
00:44:55 <dons> in particular, kzm's personal category: http://haskell.org/haskellwiki/Libraries_and_tools/Bioinformatics
00:44:56 <lambdabot> Title: Libraries and tools/Bioinformatics - HaskellWiki
00:45:04 <kzm> dons, found it, thanks.
00:45:20 <kzm> I'll take the liberty of populating it with a bit more detail :-)
00:45:32 <dons> please do!
00:45:52 <dons> i have a secret hope that the bioinfo community will become big enough to warrent its own community page
00:46:01 <dons> like the current Maths page
00:46:08 <dons> http://haskell.org/haskellwiki/Haskell_and_mathematics
00:46:10 <lambdabot> Title: Haskell and mathematics - HaskellWiki
00:46:49 <dons> kzm, you use haskell for work, don't you? ....
00:47:11 <dons> kzm, perhaps the details should be on the industry page...http://haskell.org/haskellwiki/Haskell_in_industry ...
00:47:12 <lambdabot> Title: Haskell in industry - HaskellWiki
00:48:04 <dons> now I find it so funny that people on reddit are taking articles mentioned in the HWN, and posting them to the main page
00:48:37 <kzm> dons, hmm... want to help out? :-)
00:48:50 <dons> how can i help?
00:49:01 <kzm> Well, you already gave me ByteString, of course.
00:49:56 <dons> of course :)
00:49:57 <kzm> My main problem is that I'm a bit isolated - nobody around use Haskell.  And you know what they say about autodidactism
00:50:03 <dons> yeah
00:50:07 <dons> well, no, i don't
00:50:14 <dons> but I can see that you're a bit isolated
00:50:26 <dons> you could ask on haskell-cafe@ for other people doing bioinf stuff
00:50:32 <kzm> Forget the exact words - but something about stupid student and a fool for a teacher.
00:50:35 <kzm> :-)
00:50:45 <dons> heh
00:51:24 <kzm> So - for Christmas this year, I want a critical review of my code.
00:51:35 <kzm> Although I'm unsure it will fit under the tree....
00:51:59 <kzm> Anyway - I've started to build a 'bio' library package.
00:52:06 <dons> oh, great!
00:52:14 <kzm> Currently, I just add stuff that I need elsewhere, so progress is slow.
00:52:26 <dons> we need to publicise your libs in the bioinf community, I suspect.
00:52:41 <dons> so people can just pick them up and start using it.
00:52:44 <kzm> But there is space for *a lot* of stuff - e.g. bioruby lets you search PubMed for papers and whatnot
00:52:53 <dons> mm. ok
00:53:41 <kzm> The problem is that bioinformatics is populated with ..let's call them practially oriented people.
00:53:46 <kzm> I.e. they use Perl.
00:54:02 <kzm> The sophisticated ones use Python or Ruby or Java.
00:54:03 <dons> right
00:54:15 <kzm> (I guess it's just like in the rest of the world)
00:54:18 * kzm sighs.
00:55:00 <kzm> I know a group in Bielefeld who use Haskell, but even they think the performance is too poor, and implements real stuff in C.
00:55:13 <dons> huh
00:55:25 <dons> you've told them about lazy bytestrings?
00:55:38 <kzm> No.  This was before your time, kid.  Before your time.
00:55:39 <kzm> :-)
00:55:39 <dons> (i really really hope they're not trying to do big data stuff with [Char] ...)
00:55:41 <dons> ah ok
00:55:59 <kzm> If you look at 'xsact', I use [Char] IO and pack everything into UArray Int Word8
00:56:09 <dons> ah ok. old skool ;)
00:56:23 <dons> was that because you've written it before bytestrings?
00:56:53 <kzm> Yes.  Or at least before I knew about any complete, functional, fast variant of PS.
00:57:11 <dons> ok
00:57:39 <kzm> A reimplementation in C++ was a lot faster.  Perhaps I'll convert to my bio lib, which uses BS for IO.
00:57:51 <kzm> I wonder if UArray should be replaced with something more BS like?
00:57:59 <Korollary> The UArrays are not too fast either
00:58:17 <dons> the new stream-fusible general arrays are on their way!
00:58:38 <kzm> I.e. I did some edit-distance code, and going from Array to ...well, actually Lists, but it's the interface that counts -- made it much better.
00:58:44 <dons> i.e. a generic array framework on which to immplement parallel and bytestring arrays, is being factored out. should help a lot
00:58:51 <dons> mm. yes.
00:58:59 <mgsloan> huh, i think c++ has a concept of purity -" note:   because the following virtual functions are pure within ‘Geom::Path::SVGEllipticalArc’:"
00:59:26 <kzm> I never seem to get indexing right - ironically, in this case, it was the non-indexed code that had an annoying bug - a missing 'tail'.
00:59:45 <kzm> And I want a class for sequence-like and string-like things.
01:00:06 <dons> ok. we've got sjanssen's stringable for that
01:00:22 <kzm> I get too many name clashes.  'stringable', huh?  Must remember to look.
01:00:23 <dons> i hope to get his SoC stuff release during the hackathon
01:00:29 <dons> sjanssen: ^^
01:03:47 <kzm> I don't think ghc's error messages are very good when you accidentally import the wrong funciton (i.e. I got unfoldr from BS instead of List, and I simply could not understand where the Char it complained about came from)
01:04:07 <kzm> Not that it is ghc's fault, necessarily.
01:05:01 <kzm> @seen bringert
01:05:01 <lambdabot> bringert is in #haskell. I don't know when bringert last spoke.
01:07:22 <dons> kzm, http://blogs.msdn.com/dsyme/archive/2006/12/06/using-fsharp-to-help-show-we-re-not-neanderthals.aspx
01:07:24 <lambdabot> Title: Don Syme's WebLog on F# and Other Research Projects : F# helps show we're not Ne ..., http://tinyurl.com/y9c2xw
01:10:19 <kzm> dons (or anybody else), did you look at my paste, btw?
01:11:26 <dons> where/
01:11:38 <kzm> Heh - the Neandertal sequencing is extremely cool (or as we like to say: an emerging idiom)
01:11:52 <kzm> <lisppaste2> kzm pasted "type annotation gives error" at http://paste.lisp.org/display/31354
01:12:48 <dons> ah yes. you need to forall the outermost 'a'
01:13:00 <kzm> ?
01:13:15 <kzm> I thought foralls were implicit in these cases.
01:13:29 <dons> you want the 'a's in both decls to be the same, right?
01:13:41 <dons> i.e. mkcolumns :: (Num a,Ord a) => ScoreFunc a -> ByteString -> ByteString -> [[a]]
01:13:47 <dons> and in mkcol :: (Num a,Ord a) => ([a],ByteString) -> Maybe ([a],([a],ByteString))
01:13:54 <dons> you want that to refer to the same type?
01:14:15 <kzm> Yes.
01:14:31 <dons> then, I think: mkcolumns :: forall a . (Num a,Ord a) => ScoreFunc a -> ByteString -> ByteString -> [[a]]
01:14:45 <dons> (ghc extension to make this typeable)
01:14:52 <dons> you'll need -fglasgow-exts, probably
01:14:55 <kzm> Tried that - got a load of errors (that I didn't read yet :-)  Will check closer.
01:15:04 <kzm> I already need that for the parallel list comprehension.
01:15:35 <dons> if that doesn't fix it, ping haskell-cafe@
01:15:50 <kzm> ...and I needed to remove the class constraints for mkcol
01:15:55 <kzm> Thanks!
01:23:38 <tibbe> good morning #haskell
01:23:50 <dmead> mornin'
01:23:55 <dmead> or should i say good night
01:23:58 <dmead> in fact i will
01:24:00 <dmead> good night!
01:34:07 <tibbe> Wallbraker: what are you doing here? ;)
01:52:37 <Wallbraker> tibbe: I'm allways here
01:59:56 <lispy> well, the most basic features of darcssim now exist
02:00:06 <lispy> but it's really not much
02:00:21 <lispy> i have 3 types of users defined
02:00:26 <lispy> one that creates the initial repo
02:00:32 <lispy> one who mostly adds files
02:00:40 <lispy> one who mostly updates existing files
02:00:57 <lispy> and then the adder and updating just take turns doing stuff and then pushing/pulling
02:01:30 <lispy> and from that i create a bunch of charts with gnuplot showing the time and memory consumed as a function of number of simulation steps
02:04:47 <lispy> i need a good random text generator
02:04:53 <lispy> maybe a random source code generator
02:08:55 <araujo> morning
02:10:28 <Vq^> g'day
02:10:51 <lispy> morning
02:10:57 <lispy> or, extra long night...
02:11:22 <tibbe> morning
02:11:25 <tibbe> early morning
02:11:33 <lispy> ?localtime lispy
02:11:34 <lambdabot> Local time for lispy is Wed Dec  6 02:06:30 2006
02:11:46 * lispy fiddles with the clock in denial
02:12:50 <dionoea_work> Hello. Is it possible to define data type in GHCI ? or do i need to do that in a source file ?
02:12:57 <dionoea_work> *a data type
02:13:07 <Syzygy-> I'm pretty certain you need a source file for that.
02:13:27 <lispy> dionoea_work: you need a source file
02:13:35 <lispy> dionoea_work: ghci only allows expressions
02:13:46 <dionoea_work> ok. Thanks
02:13:49 <lispy> dionoea_work: so you can define functions but not datatypes
02:13:53 <lispy> for example
02:13:56 <lispy> > let foo = 1 in foo
02:13:57 <lambdabot>  1
02:14:24 * araujo `offTo` Univ :: IO Go
02:14:31 <lispy> heh
02:48:57 <Masklinn> hello everybody
02:51:13 <DiDjCodt> hi Masklinn
03:04:13 <kzm> bringert, I guess it is a bit of a hack, but I've updated the quickCheck script to work with 'runhaskell'
03:06:12 <bringert_> kzm: got the code anywhere?
03:09:22 <kzm> http://www.ii.uib.no/~ketil/quickCheck
03:09:25 <lambdabot> Title: Index of /~ketil/quickCheck
03:09:31 <kzm> (phew)
03:10:00 <kzm> It isn't exactly pretty, but It Works For Me(tm).
03:10:22 <kzm> Probably mainly because I didn't test it very thoroughly...
03:36:41 <dons> ?users
03:36:41 <lambdabot> Maximum users seen in #haskell: 276, currently: 250 (90.6%), active: 19 (7.6%)
03:44:17 <bringert_> kzm: hehe, it treats everything starting with "prop_" as properties? it sure is hacky :-)
03:44:32 <bringert_> it's a good idea though
03:44:45 <kzm> I got it off the original quickcheck site.
03:45:00 <kzm> I think it should work with either hugs or ghc now.
03:45:17 <bringert_> we should set up a quickcheck mailing list I think
03:45:41 <dons> mm. good idea
03:48:58 <bringert_> how do you set up a list @haskell.org ?
03:51:32 <ndm> bringert_, email simon marlow
03:51:47 <ndm> i'd love it if the quickcheck property stuff i have in FilePath got integrated into some standard tool
03:51:58 <ndm> that lets you write both quickcheck properties, and static properties
03:52:11 <ndm> i.e. "1 > 2" and "a > a-1"
03:52:20 <ndm> and chooses which is free, etc.
03:56:47 <lispy> 1107 lines counting comments
03:57:03 <bringert_> ndm: thanks, e-mail sent
03:57:21 <lispy> (this is more scala than i think i ever wanted write! ;)
04:04:28 <kzm> bringert_, is there a better way to identify properties?
04:04:53 <bringert_> kzm: not that I know, but maybe we can come up with one
04:05:19 <bringert_> pragmas?
04:05:23 <dons> from the type?
04:05:46 <bringert_> no, since not all properties have type property
04:05:46 <kzm> prop_.... :: .... -> Bool ?
04:05:47 <dons> though i don't see a big problem with prop_
04:06:11 * kzm think the naming is a good practice anyway.
04:06:13 <bringert_> yeah, I guess that's ok
04:08:14 <dons> bringert_: you going to be around for the hackathon? did I already ask?
04:08:49 <dons> the initial attendee list is up,  http://haskell.org/haskellwiki/Hac_2007/Attendees
04:08:50 <lambdabot> Title: Hac 2007/Attendees - HaskellWiki
04:10:25 <bringert_> dons: I'd love to. Oh, deadline is today?
04:11:08 <dons> bringert_: well, the deadline for the first 20 is, yes. since we've got, what , 12, tht means there's ~8 spots we'll just make available on first-come-first-served
04:11:24 <Lemmih> Whoa, looks like Hackage is gonna get some attention.
04:11:31 <dons> Lemmih: its gonna happen!
04:11:47 <dons> I don't want to fly 23 hours to the uk not to come back with a hackage :)
04:12:10 <lispy> dons: that's an expensive hackage :)
04:12:30 <lispy> when you consider the plane tickets of everyone that will work on it
04:12:34 <dons> this time of the year, yep. almost twice what it cost to get to estonia last year
04:12:42 <dons> (for me)
04:12:56 <lispy> ouchy
04:13:04 <dons> not that I have to pay :)
04:13:09 <Masklinn> lol
04:13:19 * dons thanks the university of nsw for their lambda assistance
04:13:29 <Masklinn> nsw?
04:13:38 <dons> ?where dons
04:13:39 <lambdabot> http://www.cse.unsw.edu.au/~dons
04:13:42 <pejo> dons, are you funded by some sort of scholarship from the university?
04:13:48 <SamB_XP> north south west, obviously!
04:13:52 <dons> heh
04:14:07 <dons> pejo: yeah
04:14:14 <bringert_> dons: I'll register.
04:14:24 <lispy> SamB_XP: go to bed!
04:14:30 <lispy> SamB_XP: :)
04:14:31 <dons> ?time SamB_XP
04:14:32 <lambdabot> Local time for SamB_XP is Wed Dec 06 07:08:46
04:14:33 <pejo> dons, so your job is basically "do some good research, and make sure you get a phd"?
04:14:35 <dons> time to wake up!
04:14:39 <dons> pejo: yep
04:14:39 <SamB_XP> yeah!
04:14:39 <lispy> oh
04:14:41 <SamB_XP> haha
04:14:53 * lispy has a feeling SamB_XP hasn't got to bed yet tohugh
04:14:59 <Igloo> dons: Why is it more expensive this time of year?
04:15:02 <SamB_XP> no, I've been
04:15:12 <lispy> SamB_XP: am, i'm the slacker then
04:15:12 <dons> Igloo: i think due to the xmas/new year period
04:15:16 <SamB_XP> I just haven't had enough sleep, is all!
04:15:19 <dons> more flights, so they price gouge
04:15:29 <dons> s/more demand/
04:15:55 <Igloo> Ah, I see
04:16:38 <Lemmih> Flying to England is gonna cost me half of what it did last time.
04:17:10 <dons> Lemmih: oh , that's good
04:17:17 <bringert_> hmm, what should I work on?
04:17:25 <dons> bringert_: haskell code!
04:17:28 <dons> QC2?
04:17:29 <bringert_> ah, yes
04:17:32 <kzm> And how wide is it in scope?
04:17:33 <bringert_> re haskell code
04:17:52 <pitecus> @djinn (a -> Bool) -> a -> Int
04:17:52 <lambdabot> -- f cannot be realized.
04:17:53 <dons> getting QC2 released would be cool...
04:18:05 <dons> kzm: the scope's here, http://haskell.org/haskellwiki/Hac_2007
04:18:07 <lambdabot> Title: Hac 2007 - HaskellWiki
04:18:07 <bringert_> maybe I should try to get Koen to go?
04:18:14 <dons> bringert_: that'd be really good
04:18:21 <bringert_> I doubt it though
04:18:48 <dons> just tell him we'll release QC2 without him ;)
04:18:53 <bringert_> :-)
04:19:18 <bringert_> I wrote down some random stuff
04:19:23 <bringert_> hackage is important
04:20:07 <bringert_> so heathrow is closer to Oxford than stanstead and luton?
04:20:27 <dons> I think its about an hour from Oxford, by train
04:20:39 <dons> Igloo: would know better than me though
04:21:57 <Igloo> Heathrow is best, yes
04:22:37 <Igloo> I'll add some airport transport links
04:22:58 <dons> we should add when people are arriving at the airports
04:23:03 <dons> so they can catch the trains up together
04:23:56 <bringert_> is stanstead really bad?
04:25:48 <Igloo> bringert_: Yes
04:25:52 <bringert_> mkay
04:26:10 <jacobian__> I'm trying to load a module that depends on another module, how do I make the module available for import
04:27:43 <bringert_> wtf, is SAS the only airline GOT-LHR?
04:29:18 <bringert_> I could land 08:25 on the 10th and take off 18:40 on the 12th
04:29:21 <dons> bringert_: maybe ping dcoutts? he's flown that route a few times, I guess
04:29:32 <bringert_> he doesn't like flying
04:29:33 <ndm> bringert_, have you seen small check? i think the best thing for quickcheck would be smallcheck style generators
04:29:36 <bringert_> the takes the ferry
04:30:08 <bringert_> ndm: thanks! I haven't looked at it, but I will
04:30:45 <Igloo> www.expedia.com finds at least 5 airlines
04:31:18 <ndm> imagine: data Prop = Plus Prop Prop | Var Int; arbitrary = gen2 Plus /\ gen1 Var
04:31:26 <ndm> thats what smallcheck gives
04:31:33 <dons> bringert_: he takes the ferry? really?
04:31:39 <dons> there's a ferry?
04:32:35 <bringert_> Igloo: ah, bmi also flies direct. the others need multiple legs
04:32:59 <Igloo> Ah, true
04:33:52 <bringert_> wtf, on bmi's webpage, you can't select gothenburg
04:34:00 <bringert_> dons: he did last time he was here
04:34:24 * Igloo wonders how the ferry compares in time and money
04:34:33 <bringert_> probably worse for both
04:35:08 <Igloo> Really? Hmm  :-(
04:35:44 <SamB_XP> ... you are sayin it is only used by sightseers and people who don't like to fly?
04:36:38 <bringert_> or people who like to party on the ferry, or want to bring a car
04:37:09 <bringert_> I don't actually know what it costs, but caompared to low-fare airlines, I'm sure it's higher
04:37:24 <bringert_> I haven't taken a ferry to the UK since 1995
04:37:34 <kzm> On a budget, train from Gothenburg to Bergen is NOK200, but the ferry to Newcastle might be more expensive than Ryanair to Stanstead..  And this is only cheap if you don't value time. :-)
04:37:55 <bringert_> yeah
04:40:15 <kzm> Hac sounds fun, but I worry my stuff is too specific/non-mainstream, and that three days is too little to be useful on code that I'm not familiar with.
04:41:40 <kzm> (Any interest in reviving 8-bit charsets for bytestrings?)
04:42:26 <dons> it'd be a good package, now that the fps api is stable. unicode would be better ;)
04:44:25 <Igloo> kzm: You don't have to work on something with someone else if you don't want to. You might find that being at the Hackathon means you actually get 3 days hacking done, rather than getting distracted all the time
04:44:36 <Igloo> Of course, you might find that you get distracted /more/ instead
04:44:43 <SamB_XP> heh
04:44:52 <kzm> Igloo, but that would be *good* distraction. :-9
04:44:59 * bringert_ has booked his flight
04:45:07 <SamB_XP> but not good hacking :-(
04:45:26 <kzm> Another options is to do compressed suffix arrays (mainly linking to an existing c-lib)
04:45:47 <kzm> I've working code, but it needs polish and integration, and probably some debugging of memory allcoation etc.
04:46:13 <earthy> now all you need is rough consensus and you can publish it as an IETF standard. ;)
04:46:32 <dons> bringert_: great
04:48:57 <bringert_> anyone thinking about shared accomodation?
04:49:04 <earthy> if anybody is looking for a little project for hac: GHC could compile record creation a bit faster. :)
04:50:09 <dons> bringert_: yeah, we should start a page on that.
04:51:16 <dons> bringert_: Lemmih is looking to split a room, and I'd be keen
04:51:39 <bringert_> should we get a whole dorm or something?
04:51:39 <dons> just need some hotel choices.
04:51:53 <dons> is that possible?
04:51:56 <dons> Igloo: ?
04:52:14 <dons> probably easier to split between 1 or 2 local hotels
04:52:27 <bringert_> at the youth hostel I'm sure you could rent a whole dorm if they have one
04:52:47 <dons> oh, interesting
04:53:53 <dons> heh, some interesting comments here on parallelisation (and the end of C/C++ as a result )  http://blog.debreuil.com/archive/2006/12/06/4060.aspx
04:53:56 <lambdabot> Title: New Free C# Parser, and CMicro
04:54:12 <dons> (bout 3 paragraphs down)
04:56:44 <Igloo> http://www.yha.org.uk/hostel/hostelpages/836b.html says
04:56:46 <lambdabot> Title: YHA budget youth hostel hostels accommodation in Oxford - Heart of England for t ...
04:56:47 <Igloo>  09 rooms with 02 beds
04:56:47 <Igloo> 10+ rooms with 04 beds
04:56:48 <Igloo> 10+ rooms with 06 beds
04:57:02 * Igloo doesn't know anything about the hostel other than what is on the web
04:57:29 <Igloo> Also, I have some space, but no breakfast and further out
04:59:54 <bringert_> I'm sure we'll fill at least one 4-bed room
05:00:52 <dons> the YHA sounds like a good option
05:01:27 <bringert_> shared hotel rooms would be fine by me too, but as long as you have a whole dorm for yourself, I think youth hostels are ok
05:01:57 <bringert_> do you need to bring your own linen to UK youth hostels?
05:02:24 <dons> we might get wifi at a hotel
05:02:34 * dons is net junky
05:02:59 <bringert_> true
05:04:16 <Igloo> I believe linen and breakfast are included, but you probably want to check with them
05:04:41 * Igloo is a bit confused; I'm sure this isn't the page I was looking at last time
05:04:42 <dons> ok, bringert_ can you put up the YHA info on an Accomodation subpage on the wiki?
05:05:07 <dons> i.e. here haskell.org/haskellwiki/Hac_2007/Accomodation
05:05:19 <dons> and we can add a hotel or two, and work out this week where everyone's going
05:05:49 <Igloo> Ah, http://www.hostels.co.uk/index.php?content=oxford.htm is what I was looking at last time
05:05:51 <lambdabot> Title: FUNKY HOSTELS ~ Oxford Backpackers and Bath Backpackers ~ www.hostels.co.uk
05:06:25 <bringert_> dons: there is already a YHA on the main page under accomodation
05:06:33 <dons> ah ok
05:06:48 <notsmack> is there a good auto-indenter for vim?
05:07:14 <dons> notsmack: there's a new one, yeah. check the haskell.org libraries page, under 'Program development'
05:07:31 <notsmack> dons: perfect, thanks
05:07:51 <dons> here, http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
05:08:24 <dons> i think it needs vim 7
05:08:25 <joelr1> good morning
05:08:31 <dons> hey  joelr1
05:09:02 * notsmack is behind the times in vim world, it seems
05:09:12 <Igloo> Hmm, they seem to be in virtually the same place
05:09:44 <joelr1> dons: do i correctly understand that you can hot-load new code into the lambda bot?
05:10:07 <dons> that is right
05:10:24 <dons> and a few other haskell aps with hs-plugins support
05:10:29 <Cale> @dynamic-unload dice
05:10:29 <lambdabot> Unknown command, try @list
05:10:33 <notsmack> http://www.cse.unsw.edu.au/~dons/papers/SC05.html
05:10:34 <lambdabot> Title: Dynamic Applications From the Ground Up
05:10:39 <Cale> @dynamic-load dice
05:10:39 <lambdabot> Unknown command, try @list
05:10:48 <Cale> er, have the command names changed?
05:10:50 <dons> Cale: except its disabled atm :}
05:10:52 <Cale> ah
05:11:01 <dons> only since i changed the cabal file over
05:11:22 <joelr1> dons: what happens when you are replacing running code with a new version?
05:12:12 <dons> its under application control. so the app leaves the old code, and jumps into the new code
05:13:15 <dons> the details are in the 2 hs-plugins papers, one of which is at the link above
05:13:34 <joelr1> dons: i didn't know there were 2 papers. reading the one you linked to. thanks!
05:13:56 <dons> that notsmack linked to :)
05:14:16 <dons> btw, hs-plugins isn't yet ported to ghc 6.6
05:14:27 <dons> so you use ghc 6.4.2 or similar, if you want to play with it
05:14:59 * dons `ap` sleep
05:15:15 <joelr1> dons: darn /not 6.6/. what's required for the port?
05:16:59 <dons> working on it. just needs a few tweaks to parse .hi files, basically
05:18:02 <Cale> Does the GHC-as-a-library help with that?
05:29:44 * joelr1 is going through decision pain again
05:30:13 <joelr1> lisp or haskell or erlang for software to help me with my trading
05:34:19 <joelr1> i read someplace that the right decision is usually the hardest one
05:34:27 <joelr1> the right path that is
05:34:45 <obsethryl> that is always the case
05:35:00 <obsethryl> mostly because you can never fully know the consequences of your actions in long term
05:36:09 <joelr1> obsethryl: why not the easiest then?
05:36:35 <obsethryl> there is no easy way out
05:38:47 <obsethryl> i prefer to think a lot about what i have to do, but once i have thought it over, i act quickly to do what i come to believe is right
05:39:43 <joelr1> hmm
05:40:37 <vegai> dons: how's hs-plugins for 6.6 doing?
05:41:26 <dozer> is there a fast fourier transform hiding somewhere in the haskell core?
05:41:34 <obsethryl> does anyone know if there is a haskell - only editor?
05:41:43 <vegai> obsethryl: yeah, "yi"
05:41:57 <vegai> !yi
05:41:58 <joelr1> vegai: how complete is that?
05:42:01 <obsethryl> where can i find that
05:42:05 <vegai> hmm
05:42:15 <Cale> http://www.cse.unsw.edu.au/~dons/yi.html
05:42:16 <lambdabot> Title: yi text editor
05:42:16 <notsmack> obsethryl: did you mean written only in, or for editing only?
05:42:17 <obsethryl> i want to use something exclusive of haskell
05:42:30 <obsethryl> more like a friendly environment for developing in haskell
05:42:33 <vegai> joelr1: it's about in the level of vi currently, I'd say
05:42:36 <notsmack> not yi
05:42:39 <vegai> but with a lot of potential
05:42:53 <obsethryl> if it is not written in haskell there is no problem, but i do not want tot use vi, vim, emacs, eclipse ecc
05:43:04 <Cale> obsethryl: why not?
05:43:27 <Cale> I usually use vim and emacs to write Haskell code.
05:43:27 <obsethryl> i am mostly an eclipse user, but i would like to use something new
05:43:30 <obsethryl> that is all
05:44:00 <obsethryl> btw i like vim, but i would just like to use some thing that is haskell - centric and offers links to documentation
05:44:03 <Cale> Yi is quite promising, it still needs some help getting enough people using it that there's a good push to work on it, I think.
05:44:12 <Cale> hmm
05:44:25 <Cale> I don't think there's any editor which offers links to documentation.
05:44:37 <norpan> how is hIDE doing
05:45:03 <dozer> I'm realy after something that will do matrix/vector math + fast fourier transform without me having to code this all up myself (and almost certainly, badly)
05:45:05 <Cale> (Well, I don't really know about Visual Haskell, but that requires you purchase microsoft software to use it)
05:45:25 <obsethryl> visual haskell?
05:45:28 <pejo> Cale, is it just the compiler that is "free"?
05:45:32 <obsethryl> a plugin to ms software?
05:45:42 <obsethryl> i have msdn access btw, so i already have vs studio
05:45:51 <Cale> http://www.haskell.org/visualhaskell/
05:45:53 <lambdabot> Title: Visual Haskell
05:46:04 <obsethryl> thanks Cale
05:46:05 <diono> is it expected that ghci segfault on something like: take 5 $ iterate (\x -> x^x) 2
05:46:06 <diono> ?
05:46:12 <Cale> diono: no
05:46:17 <obsethryl> i am a newbie with haskell, i am studying it now
05:46:26 <diono> ok ... well it segfaults here :)
05:46:42 <diono> version 6.6
05:46:44 <Cale> diono: there's something wrong with your installation then
05:46:46 <diono> on windows
05:46:50 <obsethryl> Cai: something similar for linux plz?
05:46:55 <diono> maybe that's what's wrong :)
05:46:58 <diono> (the windows part)
05:47:06 <norpan> it's expected to take some time computing i guess
05:47:29 <Cale> obsethryl: well, there's hIDE, but it's still not remotely usable
05:47:30 <norpan> x^(x
05:48:07 <Cale> diono: I could understand running out of memory from that computation
05:48:17 <diono> i'm learning so i'm testing commands defined in prelude. And it's the first time that it actually kills the interpreter
05:48:41 <obsethryl> ok thanks Cale i will do some more digging
05:48:43 <diono> is there any webpage / mailing list i should report that to ?
05:49:12 <Cale> diono: as it involves raising a number with 616 or so digits to the power of itself
05:49:19 <jgrimes> yeah
05:49:22 <diono> i know :)
05:49:41 <diono> i was wondering wether it was worth mentioning or not
05:49:43 <Cale> It really shouldn't segfault, you could report it to the ghc mailing list.
05:50:14 <Cale> I don't have a windows machine handy to try it on. I suppose I could go and install GHC on my dad's machine.
05:50:34 <diono> i'll try it on my linux box when i get back from work
05:50:36 <Cale> (finally got him to dual-boot ubuntu though :)
05:50:43 <diono> ;)
05:50:49 <Cale> He's quite happy with it
05:54:24 <Cale> I haven't modded down 19 of the last 100 reddit items.
05:54:50 <emu> ghci/win crashes on my windows box too with that
05:54:57 <Cale> emu: interesting
05:55:08 <diono> did anyone test on linux ?
05:55:11 <Cale> I did
05:55:13 <emu> going now
05:55:17 <jgrimes> I did too
05:55:19 <Cale> It runs out of memory, but it doesn't segfault
05:55:25 <jgrimes> yeah, mine ran out of memory
05:55:46 <jgrimes> no segfault
05:56:40 <diono> hum indeed ... it wasn't a segfault. Stack Overflow
05:57:26 <Cale> Stack overflow can be expected
05:58:18 <diono> because of the way integers are handled ?
05:58:44 <norpan> because it's such a ridicilously large number
05:58:55 <diono> since no rounding is invloved i guess that would indeed be a problem :)
05:59:44 <Cale> Yeah, the number of digits in the result is ridiculously large
05:59:47 * shapr yawns
06:00:53 <diono> must be something like 700 * 700 digits ... a bit big but still ok in terms of memory
06:01:03 <diono> err ... nevermind
06:01:07 <Cale> there will be somewhere around 10^619 digits.
06:01:11 <diono> 700 * 10^700 digits
06:01:34 <norpan> that's a shitload of digits
06:01:52 <Cale> You're not likely to have significantly more memory than about 10^11 bits or so
06:02:53 <earthy> ?
06:03:15 <earthy> that's like 2^33... roughly
06:03:35 <int-e> closer to 2^37
06:03:47 <earthy> 2^36 bits of memory is not unheard of
06:04:13 <Cale> Right, it was a guesstimate about current technology :)
06:04:20 <pejo> earthy, need to avoid the 32 bit platforms as well.
06:04:25 <earthy> pejo: :)
06:04:28 <Cale> (I didn't really think the number through all that well :)
06:04:39 <earthy> 32 bit platforms can address 4GByte, usually
06:05:01 <earthy> that's 2^35 bits.
06:05:18 * earthy has built machines with 8GByte
06:05:23 <earthy> years ago even
06:05:26 <pejo> earthy, 4 GByte is 2^35 bits?
06:05:37 <int-e> I think Cale worded it carefully enough :)
06:05:44 <Cale> In any event, storing the number that diono wanted to compute would involve somewhere around 2^2056 bits of memory.
06:05:47 <earthy> int-e: yah
06:05:50 <int-e> 'not likely to' 'significantly more'
06:06:06 <earthy> O
06:06:09 <int-e> pejo: at 2^3 bits per byte, yes.
06:06:14 <earthy> I'd say a factor of 2 is significant. :)
06:06:28 <int-e> earthy: hmm. no I don't think so.
06:06:30 <Cale> A factor of 2 is not a factor of 2^2000
06:06:38 <earthy> no. true. :)
06:06:50 <earthy> that'd be a bit short. :)
06:06:55 <pejo> int-e, duh. I read bytes.
06:07:58 <earthy> anyway, that is without resorting to external memory
06:08:03 <earthy> and even then: 10^700 is *HUGE*
06:08:43 <Cale> There are only supposed to be around 10^80 or so protons in the observable universe
06:09:19 <Cale> So even if you could harness every one of those in order to record a bit, you'd still be far short :)
06:09:30 <digitalice> hi
06:09:31 <diono> 10^80 atoms
06:09:33 <digitalice> hey
06:09:36 <Cale> digitalice: hello :)
06:09:47 <diono> don't know if most atoms are Hydrogen...
06:09:49 <tibbe> just use some protons in the purple 11th dimension
06:10:01 <digitalice> how do i do, to put a lambda bot in my channel?
06:10:17 <Cale> @version
06:10:18 <lambdabot> lambdabot 4p296, GHC 6.5 (OpenBSD i386)
06:10:18 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:10:32 <Cale> that shows where you can get lambdabot via darcs
06:10:56 <Cale> You download it, edit Config.hs and state/passwd to your liking, and then compile and run it.
06:11:17 <shapr> digitalice: Would you like to learn Haskell?
06:11:21 <fasta> "providing O(1) best-case complexity for many operations." <- this doesn't say much :)
06:11:28 <shapr> digitalice: As long as you don't spam your music url again...
06:11:35 <Cale> fasta: where is that?
06:11:50 <fasta> Cale: beaglefs package desc. Debian Unstable
06:12:55 <Cale> yeah, that's pretty funny :)
06:13:02 <joelr`> dons: is there a darcs repo for yi?
06:13:05 <Cale> They could at least talk about average-case complexity
06:13:11 <Cale> I think dons went to bed
06:13:18 <Cale> and yes there is :)
06:13:20 <Saizan> writing a cellular automata engine (like alpaca) would you use a graph or a matrix to manage the cells?
06:13:22 <shapr> hiya joelr`
06:13:31 <Cale> darcs get --partial --set-scripts-executable http://www.cse.unsw.edu.au/~dons/yi
06:13:32 <lambdabot> Title: Index of /~dons/yi
06:13:51 <joelr`> shapr: hey
06:13:57 <joelr`> Cale: thanks
06:14:44 <Cale> Saizan: depends on how general I wanted things to be
06:15:31 <Cale> But UArray (Int,Int) Bool or UArray (Int,Int) Int would probably be the most likely types for a square grid.
06:15:31 <digitalice> thanks
06:15:43 <Saizan> general as in manage 2-d and define rules and states at will
06:16:06 <joelr`> Cale: did dons every reply to you about ghc's compiler as a library making hs-plugins easier
06:16:18 <Cale> joelr`: no, I don't think so
06:16:45 <Saizan> mmh i'll read something about UArray then
06:17:25 <joelr`> Cale: my understanding from before is that hs-plugins required the ghc compiler to recompile stuff. having the compiler as a library should make the job far easier, i think, as you could just bundle the compiler library as part of your app
06:17:27 <Cale> http://haskell.org/haskellwiki/Modern_array_libraries
06:17:29 <lambdabot> Title: Modern array libraries - HaskellWiki
06:17:29 <joelr`> Cale: just a hunch
06:18:20 <Saizan> thanks
06:20:04 <Cale> joelr`: well, depending on what it is that you're trying to do, it might just have to link code, but that seems to involve reading the .hi files (which you can think of as an extension of the .o file holding additional information about the interface)
06:22:29 <Cale> Saizan: come to think of it, DiffUArray might be even better, since you'll basically never look at the older versions of the array.
06:22:41 <fasta> Can I also place the -pgmF option in a source file such that ghci uses it?
06:22:54 <fasta> (E.g. for stpp)
06:23:14 * joelr` is preparing to watch the markets open (in 12 minutes)
06:23:29 <Cale> have you tried it with {-# OPTIONS_GHC -pgmF ... #-} ?
06:24:22 <Saizan> while building the array at step k i need the array at step k-1 till the end, though (i still don't know how DiffUArray works)
06:24:51 <Cale> Saizan: right, but you can likely compute a complete list of the updates and perform them all at once.
06:24:51 <dozer> Saizan - you almost certainly don't want to update the array in-place in that case
06:25:20 <Cale> (i.e. with a single use of (//))
06:26:28 <Saizan> oh, i see, i've to learn to use the Array before this conversation can continue :D
06:27:27 <Cale> Yeah, the relevant interface for DiffArray and DiffUArray is the IArray (I for immutable) interface.
06:28:01 <Cale> If you don't mind working in a monad, you could use mutable arrays, though they're more annoying to work with, since you're stuck in IO or ST for the majority of your computation.
06:28:48 <Cale> DiffUArrays are likely to give you most of the performance you want while giving you a nice pure view of the computation.
06:29:51 <Cale> You can ignore most of the actual functions and stuff from Data.Array.Diff, you only need the actual type. IArray provides all the actual functions for building and operating on diff arrays.
06:30:20 <Cale> (the rest of the stuff that's there is really only needed if you're going to be adding new kinds of diff arrays to the system)
06:31:05 <fasta> What are the current arrays that give O(1) read and write?
06:33:09 <Saizan> IArray is very different from Array?
06:34:45 <diono> there's an extra I
06:34:51 * diono hides
06:34:54 <shapr> :-P
06:35:18 <fasta> The I stands for Immutable, IIRC
06:35:48 <therp> immutable irc is boring I think.
06:35:55 <diono> hehe
06:36:38 <Saizan> i suppose the interface is quite the same so :P
06:40:57 <roconnor> @google 200 CHF in EUR
06:40:58 <lambdabot> 200 Swiss francs = 125.639229 Euros
06:44:23 <Cale> fasta: all the mutable arrays, and diff arrays, if they're used in a linear fashion
06:46:45 <therp> is there a syntax for list destructuring that for [a, b, andAllTheRestInHere] = [1..5] results in a=1, b=2, andAllTheRestInHere=[3, 4, 5]?
06:47:09 <therp> or do I have to a:b:andAllTheRest = ..
06:47:09 <Cale> > let a : b : rest = [1..5] in (a,b,rest)
06:47:17 <lambdabot>  (1,2,[3,4,5])
06:47:37 <therp> thanks
06:52:48 <Masklinn> hello again
06:53:03 <Cale> hi
06:53:14 <fasta> Cale: That does appear to work, but the examples distributed with STPP suffered from bitrot.
06:53:42 <fasta> Cale: The preprocessor also seems inefficient from looking at the source(lots of uses of ++)
06:56:45 <niarium> hi
06:57:12 <Cale> hi
06:58:57 <Cale> fasta: yeah, I don't really know much about STPP.
07:06:33 <notsmack> can parsec be used on lists that aren't String?
07:07:41 <Cale> notsmack: yes
07:09:18 <Cale> However if those lists are the result of lexing, to do a good job, you'll want to include SourcePos values in the elements of the list so that you can report errors properly
07:09:59 <Cale> You'll also end up using the stuff in Parsec.Prim in order to construct basic parsers for parsing single tokens.
07:09:59 <beelsebob> @dice 10d10 + 5d6
07:09:59 <lambdabot> 10d10 + 5d6 => 68
07:10:26 <notsmack> Cale: I see; makes sense
07:10:29 <beelsebob> @tell dons can we make lambdabot tell you the indivitual die rolls for @dice?
07:10:29 <lambdabot> Consider it noted.
07:10:37 <glguy> @dice 1d1 + 10d10
07:10:38 <lambdabot> 1d1 + 10d10 => 59
07:10:44 <Cale> token :: (tok -> String) -> (tok -> SourcePos) -> (tok -> Maybe a) -> GenParser tok st a
07:11:02 <notsmack> @dice 1d0
07:11:02 <lambdabot> 1d0 => 0
07:11:40 <notsmack> Cale: you just lost me
07:12:35 <beelsebob> glguy: I'd like to be able to pm lambdabot with @dice 10d10 and get 10 rolls of a d10 and a total
07:12:43 <beelsebob> (useful for White Wolf style games)
07:13:00 <Cale> You pass it a way to show the token, a way to get the source position of the token, and a function which simultaneously decides if the token is the one you want, and what value to return, and it hands you a parser.
07:13:19 <beelsebob> > [1..]
07:13:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:13:30 <beelsebob> @more
07:13:34 <notsmack> ahh
07:14:51 <fasta> Cale: It's not worth your time to look at it. It would be better if the reference would be removed from the wiki page about arrays that you posted.
07:19:36 <lisppaste2> glguy pasted "Haskell solution to step_up" at http://paste.lisp.org/display/31376
07:19:51 <glguy> has anyone read http://lambda-the-ultimate.org/node/1872
07:19:52 <lambdabot> Title: Programming (language) puzzles | Lambda the Ultimate
07:21:10 <joelr1> @where hs-plugins
07:21:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
07:23:56 <lisppaste2> glguy annotated #31376 with "slightly shorter, but less readable" at http://paste.lisp.org/display/31376#1
07:32:22 <pitecus> how do i get a list of random numbers again?
07:32:45 <Cale> @type randomRs
07:32:47 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
07:33:44 <Cale> @type \(a,b) n -> replicateM n (randomRIO (a,b))
07:33:46 <lambdabot> forall b. (Random b) => (b, b) -> Int -> IO [b]
07:33:50 <pitecus> so i need a Random and a RandomGen
07:34:07 <Cale> @type newStdGen
07:34:08 <lambdabot> IO StdGen
07:34:09 <ToRA> @paste
07:34:09 <lambdabot> http://paste.lisp.org/new/haskell
07:34:15 <Saizan> ?hoogle Enum
07:34:17 <lambdabot> Prelude.Enum :: class Enum a
07:34:17 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
07:34:17 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
07:34:21 <spiffy> @type getStdGen
07:34:23 <lambdabot> IO StdGen
07:34:34 <spiffy> @type setStdGen
07:34:35 <lambdabot> StdGen -> IO ()
07:34:36 <Cale> Don't use getStdGen unless you really want that
07:34:51 <Cale> (personally, I don't think it should even exist)
07:34:56 <spiffy> whys that?
07:35:08 <pitecus> so how do i get a RandomGen?
07:35:10 <Cale> Because it's a needless global mutable variable
07:35:16 <lisppaste2> glguy pasted "Can this be done with continuations?" at http://paste.lisp.org/display/31378
07:35:17 <lisppaste2> ToRA pasted "Random test for step_up" at http://paste.lisp.org/display/31379
07:35:20 <Cale> with newStdGen
07:35:39 <spiffy> fair enough
07:35:51 <pitecus> OK
07:35:54 <Cale> do g <- newStdGen; let rs = randomRs (1,10) g; print rs
07:35:55 <pitecus> thanks guys
07:35:59 <Cale> like that
07:36:00 <bd_> @type randomRs
07:36:01 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
07:36:10 <bd_> does that just leave the random generator in itsoriginal state?
07:36:22 <Cale> bd_: hm?
07:36:27 <bd_> @type randomR
07:36:28 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
07:36:30 <nomeata> dcoutts: hi. anything new about the planned gtk2hs release for ghc 6.6?
07:36:32 <bd_> hmm
07:36:36 <glguy> RandomT IO ()?
07:36:39 <Cale> randomRs is a pure function
07:36:52 <bd_> oh wait
07:36:56 <bd_> it's an infinite list, I see.
07:36:56 <kpreid> bd_: randomRs gives an infinite list, so you don't use the generator you gave it for anything else
07:37:12 <bd_> *nod*
07:37:16 <bd_> okay, it makes sense to me now :)
07:37:27 <kpreid> random thought:
07:37:35 <Cale> If you want to keep using the generator, you should split it first, and only use one branch in the randomRs, and the other for the rest of the computation
07:37:51 <kpreid> i.e. an infinite list of random data
07:37:54 <kpreid> one could write instance RandomGen [Bit]
07:38:10 <kpreid> split uninterleaves the list, and so on
07:38:18 <Cale> sure
07:39:01 <spiffy> Cale: I was thinking mkStdGen when you said newStdGen. Ignore me
07:39:59 <Cale> It's also really a shame that newStdGen doesn't use /dev/random on linux.
07:42:10 <dylan> wouldn't it need to be in IO to do that?
07:42:40 <Cale> It is in IO
07:42:45 <dylan> oh.
07:42:46 <Cale> @type newStdGen
07:42:48 <lambdabot> IO StdGen
07:42:48 <pitecus> Isn't there some tutorial on using random numbers in Haskell?
07:42:58 <pitecus> Starts to look a bit complex...
07:43:17 <glguy> Does anyone know if the system Fc typesystem in GHC head has much of a noticable effect on people that don't work on the compiler?
07:43:26 <bd_> Stuff it in a monad :)
07:43:31 <spiffy> well, I found I had to learn how to use the state monad first
07:43:48 <spiffy> and then after figuring out monads, random numbers didnt seem so bad ;-)
07:44:06 <joelr1> dons: would it be hard to extend yi with a cocoa (mac) front-end?
07:44:11 <Cale> pitecus: http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers -- this isn't quite a tutorial, but I provide an outline here in my reply to this guy
07:44:13 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
07:44:31 <Igloo> glguy: It allows ATs to be used
07:44:33 <pitecus> thanks Cale
07:45:19 <bd_> Would it be Evil to use unsafeInterleaveIO to export an infinite list of random numbers to the shuffle function there? :)
07:46:11 <spiffy> @paste
07:46:11 <lambdabot> http://paste.lisp.org/new/haskell
07:46:37 <Cale> bd_: why would you do that when you can just do something like readFile "/dev/urandom"
07:47:04 <lisppaste2> spiffy pasted "Fun with random numbers" at http://paste.lisp.org/display/31380
07:47:07 <bd_> bah, that wouldn't be as fun :)
07:47:21 <Cale> er, also you can get an infinite list of pseudorandom numbers using randoms
07:47:24 <Cale> @type randoms
07:47:25 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
07:47:27 <Cale> @type randomRs
07:47:29 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
07:47:36 <bd_> @type random
07:47:37 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
07:48:46 <int-e> bd_: that seems uneccessary. just use newStdGen and then randomRs or randoms with the returned generator.
07:53:58 <lisppaste2> glguy annotated #31378 with "get nth from end element in one pass with Cont" at http://paste.lisp.org/display/31378#1
07:57:23 <Cale> > let fromLast n = last . ap (zipWith const) (drop n) in fromLast 5 [1..100]
07:57:25 <lambdabot>  95
07:57:46 <Cale> How's that?
07:59:01 <glguy> :(
08:00:09 <glguy> > let fromLast n = last . ap (zipWith const) (drop n) in fromLast 1001 [1..100]
08:00:10 <lambdabot>  Exception: Prelude.last: empty list
08:01:26 <Cale> (obviously :)
08:01:44 <glguy> but doesn't what you did count as two traversals?
08:01:46 <glguy> one for last
08:01:49 <glguy> one for zipWith?
08:01:52 <Cale> no
08:01:58 <glguy> it fuses?
08:02:17 <Cale> sort of, in that it's lazy
08:02:30 <glguy> ah
08:02:52 <glguy> Does what I annotated count as a single traversal (it was supposed to)
08:03:38 <Cale> I think so
08:04:50 <glguy> is using Cont kind of like chaining computations in MonadError? (Either String)
08:05:07 <glguy> where calling the early exit is like returing a Left "error"
08:05:24 <Cale> Sort of, it's more general though
08:05:31 <glguy> Cont is?
08:05:34 <Cale> yeah
08:05:40 <Cale> Cont basically gives you goto
08:06:02 <Cale> in fact, more than that, it gives you goto with value
08:06:19 <glguy> which is the only way that makes sense in a functional language
08:21:34 <Cale> http://paste.lisp.org/display/31383#1
08:23:43 <Cale> You can see that fromLast n xs will take roughly n steps for the drop, and then start to evaluate last, which will force the thing to walk down the list
08:25:37 * Syzygy- is, finally, kinda sorta in the position where I'm getting paid to write haskell code. :P
08:26:01 <Syzygy-> In other words, my advisor thinks that spending a couple of weeks on extending the NumericPrelude to the point that I can use it for my research is an eminently good idea.
08:26:48 <Masklinn> congratulation
08:26:49 <earthy> schweet. ;)
08:26:54 <Masklinn> i guess :)
08:27:34 <earthy> welcome to the 'codes haskell for his livelihood'-club ;)
08:40:25 <CosmicRay> ok everyone.  what's a haskell network utility project that might appreciate the contribution of my FTP code?
08:43:19 <Binkley> what kind of FTP code?
08:43:28 <Binkley> I mean, a full FTP client, or just a library?
08:43:43 <CosmicRay> see Network.FTP here: http://software.complete.org/missingh/static/doc/
08:43:48 <CosmicRay> libraries for implementing clients and servers
08:44:27 <Binkley> ah. well, if it's already in MissingH, can't people just import it if they want to use the FTP code?
08:44:45 <Binkley> or are you asking because you want to tell people it exists?
08:44:47 <CosmicRay> Binkley: I'm trying to split out bits of MissingH to make it less monolithic
08:44:53 <Binkley> Ah ok.
08:44:56 <CosmicRay> see https://software.complete.org/missingh/wiki/TransitionPlanning
08:45:00 <CosmicRay> err without the https
08:45:31 <Binkley> I don't really know of any such projects, I mean, the first thing that occurred to me was GHC's network library
08:45:37 <Binkley> but, whether it belongs there is debatable, I guess.
08:45:39 <CosmicRay> there are a couple of 'em
08:56:34 <notsmack> pop quiz:  in vim, does 2d5d delete 2, 5, 7, 10, or 25 lines?
08:57:34 <mauke> my guess: 10
08:57:46 <mlh> erm none of the above?
08:58:03 <Igloo> CosmicRay: I'd expect a full FTP library to be in a package of its own
08:58:03 <notsmack> seems to be 10 here, surprised me
08:58:04 <Masklinn> I say 7
08:58:11 <Masklinn> damn
08:59:27 <liyang> 2 times {delete 5 rows down}?
08:59:37 <notsmack> yeah
08:59:40 <Cale> yeah, I'd say 10. Deleting 5 lines has the effect of moving the mark 5 lines down, and so d5d will delete 5 lines.
09:00:46 <Syzygy-> Cale: You wouldn't happen to know how to get around Haskell limitations in writing an as-generic-as-possible matrix arithmetic module?
09:01:17 <Cale> What limitations?
09:02:24 <Syzygy-> I'm running in to obstacles similar to when I'm working with permutationgroups: I cannot parametrize data types by integers; and I cannot from the beginning know what size matrices I'll want, so for instance adapting them to the Num class in the NumericPrelude will fail, since zero is not canonical...
09:04:06 <Cale> er...
09:04:28 <Cale> Do you mean the Ring class?
09:04:32 <Syzygy-> Ayup.
09:04:43 <Syzygy-> (it's called Num in the version of NumericPrelude I have right now)
09:04:55 <CosmicRay> Igloo: really?  FTP is a pretty small protocol.  It makes sense to me to group it together with other procotols like POP (like in the HaskellNet package)
09:05:48 <Cale> Well, square matrices of any given size form a ring. You could go with type-encoded naturals
09:05:59 <Syzygy-> Type-encoded naturals?
09:06:04 <Igloo> CosmicRay: I don't see an obvious place to draw the line. I wouldn't object to it being bundled with others, though
09:06:15 <Cale> data Zero
09:06:22 <Syzygy-> (oh, btw - the things I need to build it for make restriction to only square matrices a Rather Bad Idea)
09:06:37 <Cale> data Succ n
09:06:39 <CosmicRay> we're talking only 1500 lines of code, total.
09:06:40 <Igloo> CosmicRay: Would POP3 and FTP have the same maintainer, though? Would you expect them to be used in the same app?
09:06:42 <CosmicRay> including comments
09:06:50 <CosmicRay> Igloo: hmm, probably not in the same app.
09:06:56 <Syzygy-> Ah. So, I make my datatype have the zero and one as specific possible values, kinda?
09:07:00 <CosmicRay> Igloo: they could very well have the same maintainer (or team of maintainers)
09:07:59 <Igloo> CosmicRay: But by pointing them in the same package, you effectively force them to have the same maintainer (team)
09:08:12 <Igloo> I guess I just don't see much benefit to them being combined
09:08:54 <CosmicRay> ok, I see your point.
09:09:37 <Cale> lisppaste2: url
09:09:37 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
09:12:21 <lisppaste2> Cale pasted "Nat" at http://paste.lisp.org/display/31389
09:13:06 <Cale> Syzygy-: it's fairly awkward and prologesque
09:13:45 <notsmack> Syzygy-: 'The Haskell Road to Logic, Maths, and Programming' has a pretty interesting coverage of that technique
09:15:17 <Cale> matrixProduct :: (NatEq r1 c2) =>
09:15:17 <Cale>     Matrix c1 r1 -> Matrix c2 r2 -> Matrix c1 r2
09:15:30 <Cale> well, something like that
09:15:40 <Cale> (you'd also have an element type parameter)
09:16:53 <lray80de> What might be the reason, when a fresh installed GHCi 6.6 says
09:16:53 <lray80de> "Xcerpt/Misc.hs:45:8: parse error on input `import'"
09:16:53 <lray80de> with the line
09:16:53 <lray80de> 'foreign import ccall safe "getpid" getProcessID :: IO Int'
09:17:20 <lray80de> Did I forget to install anything, because before (the crash yesterday evening) everything worked fine.
09:17:26 <Cale> Are you giving the -fffi commandline switch?
09:17:45 <lray80de> Hi Cale, how are you? Nope, I do not.
09:17:53 <Cale> I'm all right
09:18:14 <Cale> You need to turn the ffi on in order to use foreign import
09:18:46 <lray80de> ah, works now, thnx!
09:19:04 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#v%3AgetProcessID -- btw
09:19:06 <lambdabot> http://tinyurl.com/yaoq7k
09:19:12 <Cale> @hoogle getProcessID
09:19:13 <lambdabot> No matches found
09:19:18 <Cale> interesting
09:19:33 <Cale> @type System.Posix.Process.getProcessID
09:19:35 <lambdabot> IO System.Posix.Types.ProcessID
09:19:50 <glguy> Igloo mentioned that the new type subsystem gave GHC ATs. What might a simple example of associated types be?
09:20:10 <glguy> or, what would you recommend I read to learn more
09:20:18 <Cale> http://research.microsoft.com/~simonpj/papers/assoc-types/
09:20:20 <lambdabot> Title: Associated types with class
09:21:03 <glguy> are they an alternative to fundeps?
09:21:28 <Syzygy-> Cale: Nonono.... I don't want to reconstruct the integers....
09:22:03 <Cale> (well, that's the problem, you have to, if you want them at the type level, since Haskell isn't dependently typed)
09:22:12 <Syzygy-> Oh, bugger. :(
09:22:24 <Cale> You could also just write something which fails at runtime if the matrix sizes don't match
09:22:46 <Syzygy-> Which sounds a lot like what I'd have for my first approach.
09:23:10 <Syzygy-> How would these (Nat n) help me handle matrices and permutations?
09:23:40 <Cale> what's the problem with representing permutations?
09:23:42 <Syzygy-> i.e. how do I use that to grab hold of S_n or M_n,m(somering) ?
09:24:43 <Syzygy-> I'm having similar problems with implementing permutation groups that I dow ith matrices: I don't know which group I want to be in until I'm there, so I can either rewrite code for each and every bloody permutatio ngroup I want to be in (to get things like "Give me the identity element" to work good), or swear over the lack of integer parametrized types.
09:25:10 <Syzygy-> (hrm. that was more spelling errors than I usually make ... sorry 'bout that)
09:25:10 <Cale> Ah, usually I wouldn't bother making the size of permutations explicit in the typesystem. It's easier to just work with the symmetric group on Integers
09:25:26 <Syzygy-> Check.
09:25:40 <Cale> You can record the maximum permuted index in the value
09:25:43 <Syzygy-> How would you represent a specific permutation there?
09:25:44 <Syzygy-> Ah.
09:25:53 <Cale> and represent the permutations with functions
09:26:14 <Cale> (or lists of cycles, if you want)
09:27:26 <Cale> It would be nice to have type-level naturals built in to the language.
09:27:39 <shapr> But then why not use Epigram?
09:27:39 <Syzygy-> Hmmm.... Would that work with matrices? Let the matrices carry dimensions in the type, and throw exceptions or other kinds of runtime errors if they don't want to be multiplied.... And ... hmmm .. parametrising the zero and one functions optionally....
09:27:55 <Cale> shapr: maybe you don't like emacs? :)
09:27:57 <shapr> Or at least, why not ask for dependent types in the language?
09:28:11 <Syzygy-> shapr: Basically because I never heard about Epigram, but know Haskell better than Magma, and like laziness for my current research. :)
09:28:23 <shapr> You're doing hardware design?
09:28:25 <swiert> There are some ideas floating about for how to add dep types to Haskell.
09:28:26 <glguy> If the dimension of the matrix is stored in its type, you can't very easily specify the dimension at run-time
09:28:39 <Cale> Well, there's a big difference between type-level naturals and dependent types
09:28:46 <Syzygy-> Nope, I'm doing homological algebra. :P
09:28:58 <shapr> I had a vaguely similar question about doing type-based adjacency calculations.
09:29:00 <swiert> Sure - but one implies the other :)
09:29:38 <Syzygy-> glguy: I'm thinking along the lines of data Matrix a = Matrix Integer Integer [[a]]
09:29:38 <shapr> I asked Oleg, and he said that you pretty much have to do it at runtime.
09:30:05 * Syzygy- isn't, really, right now concerned with postponing sanity checks to runtime... It'll be good enough for me and now at least.
09:30:18 <shapr> What about using TH?
09:30:25 <Cale> Matrix (Array (Integer,Integer) a)
09:30:27 <shapr> Then you get to mix compile&run times.
09:30:55 <shapr> It occurs to me that Ix has the most commonly used value types.
09:32:06 <shapr> I got to meet Oleg at ICFP.
09:32:09 <shapr> That was cool =)
09:32:14 <vincenz> shapr: what's he like
09:32:16 * shapr is a total FP fanboy.
09:32:49 <shapr> It was funny to hear him talking at Haskell Workshop. People would bring up questions and he'd spout these answers that no one except ccshan understood.
09:33:21 <shapr> And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand what you just said?"
09:36:02 <Daveman> :)
09:36:26 <psnl> shapr: type questions?
09:37:13 <shapr> Not necessarily.
09:37:51 <edwinb> I saw him at a program generation workshop recently
09:37:56 <shapr> At one point someone accussed Oleg of overusing untyped languages, specifically the type system. They said "Once again, you're just lifting the problem to an untyped language, thus allowing you to do anything!"
09:38:09 <shapr> Then there was more furious discussion.
09:38:10 <edwinb> We were talking about potential application areas for dependent types, and he wandered over and said "I've done that, it's trivial"
09:38:11 <Syzygy-> Oooooooooooh. I -like- Array. It seems to do what I need it to.
09:38:39 <edwinb> Oleg trival is not the same as normal trivial...
09:38:53 <paolino> I wonder which is the language with biggest  overlapping zone between users and developers.Or , the language where developers are passionate users
09:39:00 <shapr> Yeah, there's a reason "an oleg" is a (large) unit of typehackery.
09:39:01 <Binkley> obviously, everybody needs an Oleg number...
09:39:05 <edwinb> heh
09:39:19 <Binkley> 0 = I am Oleg, 1 = I've talked to Oleg, 2 = I've met Oleg, 3 = I've been in the same room with Oleg, 4 = I've ever understood something that Oleg said
09:39:22 <shapr> Binkley: Yeah, but they'd have to be expressed as type level naturals or somethin.
09:39:25 <Binkley> haha
09:39:26 <psnl> edwinb: speaks the man who gave a talk at anglohaskell that one person understood
09:39:39 <shapr> Hey, I understood and enjoyed edwinb's talk.
09:39:57 <shapr> Of course, I also prodded edwinb to show up for days before hand...
09:39:58 <Masklinn> Binkley > it's in the wrong order
09:39:59 <edwinb> where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
09:40:06 * shapr laughs hysterically
09:40:13 <Masklinn> 0 should be maximum Olegness, and the highest you go the furthest your are from him
09:40:25 <Masklinn> (i'm at about 160 Olegs by the way)
09:40:33 <shapr> I think ccshan gets 0.5 oleg
09:40:33 <psnl> shapr: it must have been you then?
09:40:44 <edwinb> psnl: bah!
09:40:50 <shapr> psnl: Oh, I thought you meant that only the speaker himself understood it :-)
09:41:06 <edwinb> I must write that article. Next time I complain that I'm bored, someone prod me ;)
09:41:10 <shapr> C'mon, what's hard about the lambda cube?
09:41:26 <shapr> some things index other things... tadah!
09:42:55 <Binkley> Masklin: I guess you're right, but I was trying to imply that understanding something that Oleg said entailed more closeness to Oleg than merely talking to him
09:43:28 <Binkley> but I guess that just implies that "understanding something that Oleg said" is 0.0000000001
09:43:33 <Binkley> or, epsilon, perhaps
09:43:37 <shapr> Of course, sometimes when I complain that something isn't hard, someone else explains to me that I didn't really understand it.
09:44:34 <shapr> http://en.wikipedia.org/wiki/Lambda_cube - Axes are  1. Terms depending on types, or polymorphism (as in System F), 2. Types depending on types, or type operators, and 3. Types depending on terms, or dependent types (as in LF).
09:44:56 <paolino> is it possible to make conditional instantiation for types ?
09:45:03 <Masklinn> Binkley > well i'd rank 1 as "I understand everything Oleg says", 2 as "I sometimes understand what Oleg says" 3 as "As long as he doesn't talk about programming I somehow understand what Oleg is speaking about", 4 as "I talked to Oleg", 5 as "I met Oleg", 6 as "I attended a talk by Oleg" etc...
09:45:26 <Masklinn> wait, "I discussed programming with Oleg" should be between 1 and 3
09:45:27 <Binkley> Masklinn: Mmm, yes, that's much better
09:45:47 <Binkley> except that there should be a lot more distance between 1 and 2 and between 2 and 3 than between 3 and 4, 4 and 5, and so on
09:45:58 <shapr> What about, I was editor of a magazine where Oleg published an article?
09:46:04 <vincenz> Masklinn: you need to talk in milliolegs
09:46:30 <vincenz> 1 milliOleg = 10*ln(Oleg)
09:46:36 <Binkley> Also, I'm not sure where having had dinner with Oleg but being on the other end of the table fits in.
09:46:53 <shapr> psnl: Does that description make dependent types easier to understand?
09:47:03 <Lemmih> paolino: What do you mean?
09:47:11 <Masklinn> Binkley > well it could en an logatithmic scale, like decibels
09:47:17 <Masklinn> logarithmic
09:47:55 <Philippa> *reads up*
09:48:02 <Philippa> psnl: am I the one person? If not, at least two
09:48:54 <psnl> technically, its the point where spj started asking questions that I got lost....
09:48:55 <emu> olegarithmic
09:49:03 <shapr> hah
09:49:48 <goodFellow> hi all.got stuck with simple task. to add two lists without duplicates
09:49:53 <lispy> ?remember emu olegarithmic
09:50:05 <shapr> goodFellow: Can you add two lists?
09:50:24 <goodFellow> yes
09:50:29 <lispy> goodFellow: sounds like 'union'
09:50:34 <paolino> Lemmih , if t is instance of C then instance  C1 T1 t
09:50:37 <shapr> goodFellow: Can you remove duplicates from a list?
09:50:41 <lispy> > [1..10] `union` [5..15]
09:50:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
09:50:51 <goodFellow> yeah but it would be best if I didn't use any library
09:50:52 <shapr> lispy: Aw, you know this is homework.
09:51:00 <lispy> shapr: no way! ;)
09:51:12 <lispy> goodFellow: where are you stuck at the moment?
09:51:36 <lispy> goodFellow: now that you know the standard lib way to do it, you can check your answer against it
09:52:14 <goodFellow> I checked the union but it uses like three functions and they use two or so and so on...
09:52:20 <lispy> goodFellow: can you assume anything about the lists?
09:52:45 <vincenz> @quote vincenz
09:52:46 <lambdabot>  I thought the kinkiness of this channel had just gone way up
09:52:49 <vincenz> hmm
09:52:50 <vincenz> wrong one
09:52:52 <vincenz> @quote vincenz
09:52:53 <lambdabot>  then you call 1-800-GET_DONS
09:52:58 <profmakx> *g*
09:53:09 <goodFellow> they contain String elements
09:53:19 <goodFellow> and only Strings
09:53:21 <lispy> goodFellow: but you don't know if they are sorted or anything?
09:53:30 <paolino> Lemmih: that would imply problems to export a library   maybe
09:53:34 <vincenz> oh well
09:54:02 <goodFellow> no sorting just one charactered strings
09:55:03 <lispy> goodFellow: well, you said you know how to combine the two lists, what if you just removed duplicates after they are combined, would that give the right result?
09:55:06 <emu> here ya go, a function which adds two lists without duplicates: onion = liftM2 (.) (++) (flip ((:) . ((a | a) <-)) . return . not . (a `elem`))
09:55:12 <vincenz> 518:49 <lambdabot>  sure, give us your homework and we'll email it straight to  your teacher :)
09:55:16 <vincenz> there is my @quote
09:55:36 <lispy> emu: nice onion
09:55:51 <vincenz> emu: I like all the (-layers in the onion
09:55:53 <Cale> emu: I'm guessing that you put a list comprehension through @pl
09:56:00 <goodFellow> homework is ment for studying and I do it best by examle
09:56:06 <emu> hehe, it's evil isn't it
09:56:10 <glguy> emu: yeah, that doesn't work
09:56:12 <vincenz> Cale: seems so, and seems wrong too
09:56:18 <vincenz> (a | a) <- ...
09:56:21 <lispy> ?unpl liftM2 (.) (++) (flip ((:) . ((a | a) <-)) . return . not . (a `elem`))
09:56:21 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 34}: Parse error
09:56:27 <vincenz> @pl [x | x <- [1..]]
09:56:28 <lambdabot> [x | x <- [1..]]
09:56:28 <emu> hmm true
09:56:42 <vincenz> @pl \x -> [y | y <- x]
09:56:43 <emu> oh well, time to write it without comprehensions
09:56:43 <lambdabot> return . ((y | y) <-)
09:57:00 <vincenz> it doesn't get the | bit
09:57:20 <vincenz> must think it's a single element, hence return
09:57:22 <emu> onion = liftM2 (.) (++) (filter . (not .) . flip elem)
09:57:29 <Cale> > nub ([1..10] ++ [5..15])
09:57:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
09:57:35 <bd_> @type (<-)
09:57:36 <lambdabot> parse error on input `<-'
09:58:02 <bd_> hmm, GHC extension for pointfree comprehensions or something?
09:58:37 <glguy> @pl doesn't know about list comprehensions, and thinks it's a list of stuff using the (|) and (<-) operator
09:58:37 <lambdabot> (line 1, column 39):
09:58:37 <lambdabot> unexpected ","
09:58:37 <lambdabot> expecting variable, "(", operator or end of input
09:58:42 <bd_> Prelude> :t return . ((y | y) <-)
09:58:42 <bd_> <interactive>:1:13: parse error on input `|'
09:58:43 <goodFellow> actually nubs definition is pretty simple
09:58:46 <bd_> oic
09:58:53 <emu> smaller onion works
09:58:54 <goodFellow> I think I can adapt it
10:00:25 <Cale> > let union = foldr (\y ys -> if y `elem` ys then ys else (y:ys)) in union [1..10] [5..15]
10:00:26 <lambdabot>  [11,12,13,14,15,1,2,3,4,5,6,7,8,9,10]
10:00:55 <goodFellow> folrr is more beautiful (Y)
10:01:19 <goodFellow> Cale thanks
10:02:20 <lispy> i wouldn't want to use that version of union
10:02:24 <lispy> because it jumbles things!
10:02:34 <emu> unordered sets!
10:02:50 <lispy> emu: unordered fine, but i still like stability
10:03:04 <Masklinn> stability is overrated
10:03:27 <Masklinn> just slowSort everything at the end
10:03:59 <emu> @info Data.Set.Set
10:03:59 <lambdabot> Data.Set.Set
10:04:14 <emu> wonderful..
10:04:35 <emu> @hoogle minView
10:04:36 <lambdabot> No matches found
10:05:11 <emu> wonder why it doesn't have half the standard library indexed
10:10:13 <Cale_> cable dropped
10:10:44 <Cale> > let union = foldr (\y ys -> if y `elem` ys then ys else (y:ys)) in union [1,1,1,1,1] [1..10]
10:10:45 <lambdabot>  [2,3,4,5,6,7,8,9,10,1,1,1,1,1]
10:11:05 <vincenz> heh
10:11:11 <vincenz> let union = (++)
10:11:27 <lispy> > let union = flip (++)
10:11:28 <lambdabot>  Parse error
10:11:34 <Cale> it's not quite the same -- this union preserves the property that there are no duplicates, but doesn't ensure it
10:12:04 <Cale> (that is, if xs has no duplicates then so will union xs ys)
10:12:25 <vincenz> so?
10:12:28 <vincenz> I put that in the spec
10:18:54 <glguy> step_up'' = fix ((step >>=) . flip unless . join (>>))
10:19:25 <vincenz> step_up = not . step_down
10:20:47 <glguy> variable names are for the weak! (-;
10:21:07 <vincenz> @quote glguy
10:21:08 <lambdabot>  11th commandment, don't use cygwin because it is crap
10:21:16 <glguy> ?
10:21:22 <glguy> I don't remember saying that
10:21:58 <lispy> ?remember glguy I don't remember saying that
10:22:19 <glguy> ?quote glguy
10:22:19 <lambdabot>  this is like Web 5GL. I like it
10:22:22 <glguy> ?quote glguy
10:22:23 <lambdabot>  Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
10:22:38 <lispy> > 2^1024
10:22:39 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:22:45 * shapr boings
10:22:47 <vincenz> glguy: referring to me?
10:22:52 <lispy> > length $ show (2^1024)
10:22:53 <lambdabot>  309
10:22:58 <glguy> vincenz: possibly?
10:23:01 <shapr> Man I love writing Haskell. It's amazing how much it just works.
10:23:03 <vincenz> > 2^64
10:23:05 <lambdabot>  18446744073709551616
10:23:10 <lispy> shapr: :)
10:23:58 <vincenz> > 2^2048
10:24:00 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
10:24:15 <vincenz> > 2^2044
10:24:17 <lambdabot>  2019812879456937956294679793041871997527756416857217752008146589220290946179...
10:24:24 * shapr boings happily
10:24:41 * lispy writes project report, unhappily :)
10:24:47 <Cale> > 2^64^2
10:24:49 <lambdabot>  1044388881413152506691752710716624382579964249047383780384233483283953907971...
10:24:57 <shapr> I only wish I had a faster box so compilations wouldn't take so long...
10:25:03 <vincenz> > 2^2^2^2^2^2
10:25:08 <lambdabot> Terminated
10:25:17 <shapr> Hey, can runghc Setup.hs build take advantage of multiple CPUs?
10:25:45 * shapr considers buying faster hardware while waiting for the next build.
10:25:54 <lispy> shapr: like when you do make -j3
10:26:01 <shapr> Yeah
10:26:19 <lispy> hmm...i bet cabal could support that, but i don't remember seeing anything like that in the docs
10:27:24 <Lemmih> I think SimonM ran --make with multiple threads once.
10:28:33 <roconnor> > 255/16
10:28:34 <lambdabot>  15.9375
10:28:59 <emu> i wouldn't mind parallel compilation on multiple cores and machines, automatically distributed!
10:40:13 <Binkley> emu: would you like a pony with that too? :-)
10:43:07 <emu> can a pony compute recursive functions?
10:43:46 * monochrom cries
10:43:50 <lispy> there was the adding horse, but i don't think he did general recursion
10:43:51 <Binkley> well, some people thought it could, and then it turned out its keeper was whispering the definition of the Y-combinator in its ear
10:44:17 * lispy blows to the witty Binkley
10:44:20 * Binkley bows
10:44:22 <lispy> er bows
10:44:27 <Binkley> You can blow too
10:44:29 <monochrom> Oleg can do differential calculus over compiled functions!  The impossible has happened!  My world is unmade!
10:44:31 <Binkley> but maybe that should be in #haskell-blah
10:44:38 <lispy> Binkley: heh, yeah
10:44:41 <dylan> hmm, is there a standard doubly-linked list?
10:44:52 <Binkley> monochrom: yeah, I practically cried when I saw that too
10:45:05 <lispy> dylan: not that i know of
10:45:13 <lispy> dylan: maybe in Edison?
10:45:42 <dylan> or, better question. Any idea of a good data structure to represent a text entry field?
10:46:02 <monochrom> mutable array
10:46:03 <dylan> (preferably one outside of ST and IO)
10:46:11 <monochrom> String
10:46:21 <monochrom> ByteString
10:46:29 <dylan> Except String has no current position information.
10:46:40 <lispy> [Maybe Char] ? ;)
10:46:49 * monochrom heads over to HWN
10:47:39 <monochrom> (x, x) where x can be String or ByteString or Array or ...  the current position is right between the two x's.
10:47:48 <Cale> You can do funky things like  data CursorString = CS { before :: String, after :: String}, where the expectation is that 'before' is recorded in reverse
10:50:06 <newsham> programming rant, factual inaccuracies, involving haskell.  scroll down to "A Sermon on Programming Languages": http://www.dailyspeculations.com/
10:50:09 <lambdabot> Title: Daily Speculations: The Web Site of Victor Niederhoffer and Laurel Kenner
10:50:50 <newsham> "The problem being that people imagine that somehow a language makes programming easier. It does not. But the hope remains."
10:51:11 <newsham> "the only language feature that cannot be implemented as a function is short-circuiting AND and OR."
10:51:24 <dylan> LOL
10:51:41 <newsham> "the difference between a well developed library and a language feature is minimal."
10:51:41 <lispy> newsham: sad :(
10:52:15 <Binkley> newsham: I kind of actually agree with the first line you quoted
10:52:22 <Binkley> languages don't make programming easier
10:52:34 <Binkley> programmers might have an easier time programming in some languages than others, though.
10:52:40 <Binkley> I think there's a difference.
10:53:08 <newsham> sure they do.  structured programming is much easier than programming with gotos.  subroutines are much easier than not having them,  automatic variable allocation is much easier than not having that
10:53:37 <newsham> garbage collection relieves programmers from managing allocaiton
10:53:41 <Binkley> well... maybe I just object to the idea that "if you give people a tool, it'll have the following impact on them"
10:53:48 <newsham> there are many language features which make programming easier
10:53:49 <Binkley> ultimately, it's up to people to use their tools appropriately
10:54:06 <psnl> Binkley: if you throw it at their head, it will leave a crater as an impact
10:54:13 <Binkley> give a C programmer Java, and they'll write "bool b; if (b.getValue() == true) { ..."
10:54:29 <profmakx> o.O
10:54:53 <Binkley> psnl: good point, well made
10:55:25 <psnl> Binkley: sorry
10:55:45 <Binkley> but, you can still write spaghetti code in a structured programming language, if that's what you're determined to do. it's true that every language encourages programming in a certain style, but ultimately that's only a suggestion
10:55:51 <Binkley> psnl: no, I thought it was funny :-)
10:56:22 <Binkley> and you don't *have* to use subroutines, and you -- if you were *really* perverse -- could simulate your own memory allocation (modulo types)
10:56:27 <Binkley> although I guess the last one is a little farfetched
10:57:23 <newsham> binkley: are those really your arguing points?
10:57:52 <Binkley> newsham: maybe those aren't the best examples, but I think it's true
10:58:07 <shapr> I think Binkley is saying that those spiffy features give programmer the opportunity to do a better job, but that doesn't mean people actually use them.
10:58:17 <emu> with indefinite extent closures, not having GC is basically impossible
10:58:36 <newsham> binkley: thats like saying "cars dont make transportation easier, because you can try pushing it instead of turning it on, and pushing a car is much harder than just walking"
10:58:42 <Binkley> emu: I didn't say that you could simulate your own memory allocation (in a GC'ed language) and have *correct* programs...
10:58:48 <newsham> its also true that pushing a car is harder than walking
10:58:53 <Binkley> newsham: cars don't make transportation easier if nobody enjoys driving.
10:58:55 <newsham> but its not a very good argument
10:59:07 <newsham> ok.. i guess this conversation is over.
10:59:11 <Binkley> in fact, that's exactly my point
10:59:18 <Binkley> cars don't "make" transportation easier
10:59:23 <Binkley> people decide they'd enjoy using cars rather than driving
10:59:26 <Binkley> er, rather than walking
10:59:33 <Binkley> and people effect a change in how transportation takes place.
10:59:59 <Binkley> <qwe1234-mode>google "social construction of technology", it's all there</qwe1234-mode>
11:00:03 <shapr> I can say that I once worked with 20+ people who were the best example of cargo cult programming that I've ever seen. And they were just the way that Binkley describes, sort of like programmer luddites who refused to learn new features in order to make their work easier.
11:00:12 <Cale> What about popping a car, or pushing a cdr?
11:00:36 <emu> Cale: at least i wasn't the only one thinking along those lines
11:01:07 <shapr> newsham: I think Binkley is interpreter the word "make" there to mean "force"
11:01:15 <cjeris> shapr: thinking is hard, it's amazing what people will do to avoid it
11:01:29 <newsham> cars increase total factor productivity and result in a higher GDP per capita.
11:01:30 <shapr> truly
11:01:34 <newsham> as do good programming languages.
11:01:49 <newsham> any suggestion otherwise is poppycock
11:01:53 <shapr> You can lead a lazy person to a tool, but that doesn't mean they'll use it.
11:01:58 <Binkley> newsham: cars don't do that, people choosing to adopt cars does that
11:02:03 <Binkley> as does people choosing to adopt good programming languages
11:02:03 <wchogg> What if the lazy person is a tool?
11:02:04 <emu> and how about a person to a lazy tool?
11:02:08 <Binkley> a car doesn't do anything by itself
11:02:10 <Binkley> it just sits there.
11:02:12 <Binkley> like a thunk.
11:02:31 <cjeris> and it's amazing what some languages do to make thinking impossible, seemingly justified by the assumption that no one thinks anyway, so it's more important to make non-thinking programming as easy as possible.  see ColdFusion.
11:02:35 <Binkley> like a thunk that would evaluate to the car of a list, just to get the pun out of the way.
11:02:41 <psnl> this metaphor is like a leaky screwdriver
11:03:04 <cjeris> @remember psnl this metaphor is like a leaky screwdriver
11:03:17 <emu> that's an analogy
11:03:24 <shapr> Those people I was working with were writing Java, and for every if clause they put in an empty else {} clause because they weren't convinced it was optional, no matter what I told them.
11:03:40 <newsham> psnl knows which side of his bread his goose is buttered on.
11:03:46 <psnl> the metaphor in question was Binkley's
11:03:49 <astrolabe> the mot juste is something like simile
11:03:55 <emu> shapr: they'd love haskell, then
11:04:02 <Binkley> shapr: yeah, I had to maintain Java code written by someone who had somehow both managed to drink WAAAAAAAAY too much of the design patterns kool-aid, but also didn't undersatnd that he wasn't programming in C anymore
11:04:06 <Binkley> I really couldn't understand it
11:04:09 <shapr> I'm sure they could make Haskell look like badly written asm.
11:04:11 <Binkley> I also couldn't hunt him down and kill him.
11:04:13 <emu> psnl: yes, but i was reading it self-referentially
11:04:31 <Binkley> Because I'm not a violent psychopath, but after reading that code, I was ready to become one, and to find out where he lived.
11:04:42 <emu> shapr: at least they would have to put in the else branch every time
11:04:43 <newsham> To all intensive purposes, the cause is lost.
11:04:47 <psnl> emu: I thought it was a simile, myself
11:04:55 * eviltwin_b winces
11:05:08 <shapr> emu: That's true, but they only did it because they were all so full of fear that no new information could enter their head.
11:05:14 <astrolabe> Coding badly is antisocial, like dropping litter.
11:05:15 <eviltwin_b> "(for|to) all intents and purposes"
11:05:31 <shapr> astrolabe: I think it's more like leaving dog poo where people walk.
11:06:19 <Binkley> shapr: in that the person who has to clean up the mess never, ever gets paid nearly enough?
11:06:33 <astrolabe> shapr: yeah, or broken glass on the beach.
11:06:53 <Binkley> or like having unprotected sex with people when you have an STI
11:06:57 <Binkley> or like not checking for empty lists
11:07:01 <Binkley> (to bring the metaphor around full circle)
11:07:01 <emu> some bastard lets their dog leave poo every so often on the streets i commute by
11:07:19 <shapr> Anyway, they sold a chunk of code to some other company... and then the company made a minor addendum to their requirements. But it took weeks to implement because the GUI forms called the database connector class directly, and then they wrapped the response object up so it could set fields in the GUI form directly...
11:07:35 <Binkley> shapr: did you submit that to Daily WTF?
11:07:43 <shapr> Nah, it was too depressing for that.
11:08:23 <shapr> Even worse, *all* the code was in static methods because NO ONE could figure out how to use object oriented anything! They never did figure out how to make an instance in all the time I was there.
11:09:18 <shapr> The owners tried despately to get me to be a manager for all these people.
11:09:20 <astrolabe> how do people like that become coders?
11:09:39 <shapr> They were unemployed before that.
11:09:41 <Binkley> shapr: yeah, this Java job I had where I was talking about, there was nothing really OO about the code either
11:09:45 <Binkley> except where they were forced to use OO
11:09:46 <Botje> astrolabe: by heritage
11:10:16 <Binkley> So I guess it's no surprise that they hired me in order to convert the Java code to C
11:10:18 <shapr> The company got startup capital from (among other sources) the Finnish unemployment office who was trying very hard to get rid of long term unemployed people.
11:10:24 <Binkley> "Hey, let's use Java! But let's not use this scary OO stuff"
11:10:28 <Binkley> "Oh, Java sucks. Let's rewrite it in C."
11:10:49 <astrolabe> C is a better idea if you aren't using OO.
11:10:59 <vincenz> C is a better idea of you're a masochist
11:11:01 <astrolabe> I suppose that is a simplification
11:11:03 <shapr> So the company itself was getting all the money that would have been paid for unemployment, and whatever they could get out of the suckers who bought their software.
11:11:09 <emu> java does have a GC built in
11:11:24 <monochrom> C has no garbage collection.  They would never figure out when to malloc and when to free.
11:11:30 <emu> libgc though!
11:11:39 <astrolabe> monochrom: just use the stack!
11:11:44 <shapr> I really did try hard to train these people, until I discovered that they were playing dumb so I would write their code for them.
11:11:46 <Binkley> Switching to C isn't a good idea when your main reason for switching is an irreproducible bug that happens in your Java code, but you can't *reproduce* the bug so you don't know what's really causing it
11:11:55 <Binkley> monochrom: that's easy, their answer to that was "run Purify!"
11:12:02 <Binkley> And wait three or four hours for the answer.
11:12:09 <vincenz> Binkley: you mean like a heisenbug?
11:12:14 <Cale> We'll use Java, but the entire application will be one big singleton. That way we'll be using design patterns!
11:12:25 <shapr> Anyway, that experience taught a lot about corporate programming.
11:12:30 <Binkley> vincenz: it wasn't a bug where observation changed the outcome, it just didn't happen a lot, and only happened on the customer's machine
11:12:42 <Binkley> Yay trivial design patterns!
11:12:48 <Binkley> I'm designing a program. That's a design pattern, right?
11:13:07 <emu> design patterns are what you choose for wallpaper and carpets
11:13:15 <Excedrin> any thoughts on CAL? I looked at it a little, my impression is that it's a relatively nice language for the JVM
11:13:17 <vincenz> We should introduce meta-design patterns.  Namely there is only one, don't use design patterns.
11:13:19 <monochrom> In fact nevermind unemployed people.  I had seen my classmates write "char *c; strcpy(c, "hello");"  That's right, no malloc there.  Here is what was on their mind: "the man page says it wants char*, so I made one and passed it.."
11:13:35 <vincenz> monochrom: in haskell such innocence works
11:13:50 <Binkley> monochrom: I actually think that's forgivable, as mistakes go...
11:13:50 <astrolabe> Below a certain level of competence, coding is a destructive act.  Like playing the violin.
11:13:53 <monochrom> Yes, I am refuting the claim that "C is more suitable".
11:13:55 <Binkley> or at least, arguably the compiler should check it
11:13:57 <Excedrin> that, and the "GEM" designer tool that lets you graphically compose functions is pretty neat (not sure how useful it is, but it's definitely neat)
11:14:00 <shapr> astrolabe: haha
11:14:09 <Binkley> The design pattern that can be named is not a true design pattern.
11:14:10 <emu> Binkley: sure, it's just undisputable proof that newbies shouldn't use languages with pointers
11:14:14 <shapr> @remember astrolabe Below a certain level of competence, coding is a destructive act.  Like playing the violin.
11:14:15 <Binkley> emu: indeed!
11:14:22 <Binkley> ?remember vincenz We should introduce meta-design patterns.  Namely there is only one, don't use design patterns.
11:14:23 <emu> indisputable?
11:14:28 <cjeris> vincenz: one of my goals in studying PL theory is to be able to formalize my gut intuition "design patterns are bad ideas because if you can't formalize it, a 'design pattern' is actually a void in the language design".
11:14:41 <Binkley> cjeris: have you seen Jeremy Gibbons's paper on that?
11:14:48 <astrolabe> monochrom: point taken
11:14:56 <cjeris> Binkley: googling...
11:14:59 <Binkley> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/index.html#hodgp
11:15:02 <emu> I think of "design patterns" as being patterns which the language-of-choice cannot abstract away
11:15:02 <lambdabot> Title: Jeremy Gibbons' Publications, http://tinyurl.com/y56qzx
11:15:23 <Binkley> I think pretty much everyone who'd be hanging out on this channel agrees with that...
11:15:26 <emu> very important in Java where you have to insert tons of boilerplate around everything you do
11:15:28 <Binkley> One time I had a job interview
11:15:33 <shapr> Yeah, this comes back to the discussion wli and I had long ago, about libraries being a sign of broken-ness.
11:15:36 <Binkley> and the interviewer asked me what my opinion of design patterns was
11:15:45 <Binkley> and I basically said what emu just said there
11:15:46 <Binkley> and she said
11:15:53 <Binkley> "Hmm... that's interesting. I never thought of it that way."
11:15:56 <shapr> heh
11:15:59 <Binkley> Then I wondered whether I should have said that.
11:15:59 <vincenz> lol
11:16:02 <vincenz> you can tell what she was thinking
11:16:03 <Binkley> But I got the job.
11:16:13 <emu> and then people call productivity measured by how many lines of code you get Eclipse to generate
11:17:06 <shapr> I never did understand the LOC productivity measurement.
11:17:07 <cjeris> Binkley: 'Design Patterns as Higher-Order Datatype-Generic Programs' ?
11:17:11 <Binkley> cjeris: yes
11:17:13 <Excedrin> too much talk about Java and not enough talk about CAL: http://labs.businessobjects.com/cal/
11:17:16 <lambdabot> Title: CAL and the Business Objects Quark Framework for Java
11:17:19 <Binkley> shapr: it's all about the semicolon metric!!!!!!1111oneoneone
11:17:27 <shapr> The real goal is to solve problems for your clients, right? Why not measure it that way?
11:17:31 <monochrom> On the bright side I invented a pedagogical method.  I explained the right way to one classmate, let's call him X.  Then we saw another classmate Y committed the same mistake (it was a widespread mistake) and I ordered X to repeat my explanation to Y.  Thus the cure was spread, my workload was reduced, and X himself also understood it better by teaching it to other people.
11:17:31 <vincenz> shapr: it's easy for management "wc -l code_of_developer > paycheck"
11:17:42 <Binkley> shapr: it's harder to measure the solving-problems-for-your-clients in a one-line shell script
11:18:00 <Binkley> monochrom: I like it!
11:18:07 <Excedrin> do one line shell scripts ever solve anything?
11:18:10 <Binkley> if you want to publish that in an education journal, though, you need a fancy name for it
11:18:14 <emu> how long a line?
11:18:17 <Binkley> Excedrin: define "solve"
11:18:20 <vincenz> Excedrin: world-peace
11:18:28 <psnl> would you describe yourself as bitter, twisted, both or neither?
11:18:33 <Cale> Haskell programmers must not be very productive, because there are not very many semicolons in their code.
11:18:36 <monochrom> "Virulent Education Method"?  XD
11:18:42 <shapr> Binkley: What about, how much our client profits from what we deliver to them minus how much we cost our client?
11:18:46 <emu> Cale: Lisp is extraordinarily productive
11:18:48 <Binkley> Cale: on the contrary, Haskell programmers who don't use layout are more productive
11:18:51 <Excedrin> psnl: if that was directed at me, I'm a sysadmin
11:18:58 <Binkley> during my first 6 months of coding in Haskell, I would've thought that, tbh
11:19:00 <monochrom> I use layout and {;}
11:19:15 <Binkley> shapr: that's fairer
11:19:22 <Binkley> but it's hard to quantify individual programmers' contributions
11:19:29 <vincenz> shapr: that is NP-hard to determine
11:19:47 <shapr> monochrom: I've thought about virulent education, but I think a spoken programming language would be best there. Wouldn't it be nice to give working code to newbies over lunch?
11:19:53 <psnl> undecideable, I suspect
11:20:02 <psnl> yes, undecideable
11:20:23 <dblhelix> vincenz: much harder than NP, I guess
11:20:25 <vincenz> psnl: hehe, that was funny "xx, I suspect" 2 seconds later "yes, xxx"
11:20:29 <shapr> Binkley: What about, how much the programmer profits the company minus how much they cost the company? :-)
11:20:42 <Binkley> shapr: that's begging the question :-)
11:20:46 * shapr grins
11:21:20 * dblhelix compiles hat...
11:21:30 <shapr> But seriously, company wide goals can be quantified, and team productivity can be quantified, right?
11:21:37 <vincenz> not really
11:21:45 <vincenz> nor can consumer gain be quantified
11:22:01 <vincenz> if you make a website for someone, how can they accurately tell how much more business they got from that?
11:22:28 <Binkley> vincenz: wc -l access_log
11:22:33 <Binkley> ;-)
11:22:50 <psnl> vincenz: give my brain time to catch up with my intuition ;-)
11:22:56 <emu> make sure you design an ajaxy web page with lots of subcomponents which request data separately
11:23:05 <shapr> vincenz: From a contractor standpoint, if the client believes they got value, that's all that matters.
11:23:15 <vincenz> shapr: sure, but it's hard to quantify
11:23:32 <astrolabe> shapr I think metrics are a mistake
11:23:36 <shapr> It's pretty easy, if they pay you... they think they got value. If they don't pay you...
11:23:38 <vincenz> psnl: lazy evaluation, huh?
11:24:20 <shapr> Or sometimes they pay you but don't ask for more work.
11:24:58 * cjeris has committed a WTF, specifying a URL parameter to hold something that now must accept UTF-8 :(
11:25:01 <Excedrin> jobs should simply use the reality show method to determine who gets a raise and who gets fired... o wait
11:25:38 <Binkley> cjeris: if you are self-aware enough to know you've committed a WTF, then it wasn't really a WTF
11:25:46 <vincenz> it's a meta-WTF
11:25:48 <astrolabe> I think it is quite difficult to judge programmers fairly.  If they come up with a simple solution, the natural conclusion is that the problem was easy.
11:25:55 * vincenz sprinkles around some meta's
11:25:58 <Binkley> Excedrin: at first I read that as if you were implying that reality was a type class
11:26:02 <vincenz> I wish meta had a letter
11:26:05 <vincenz> like eta
11:26:11 <shapr> I think the only way to judge a programmer fairly is to pair program with them for a week.
11:26:18 <vincenz> Binkley: me too "instance Show Reality"
11:26:33 <cjeris> astrolabe: http://www.csd.uwo.ca/~magi/personal/humour/Computer_Audience/The%20Parable%20of%20the%20Two%20Programmers.html
11:26:35 <lambdabot> Title: The Parable of the Two Programmers, http://tinyurl.com/ygj354
11:27:37 <Binkley> don't judge a programmer until you've typed 10000 lines on their keyboard?
11:27:38 <CosmicRay> shapr: if the programmer gets impatient whenever he's not typing, he's a good one? ;-)
11:27:39 <vincenz> astrolabe: yeah that's a bit the problem with coding but also with research.  If you do your work -really- well, your final result is simple, but then everyone will think the problem was not complex
11:27:48 <vincenz> astrolabe: society values complication not complexity
11:27:49 <Binkley> CosmicRay: actually, I'd say it's the opposite
11:28:10 <CosmicRay> oh?
11:28:49 <Binkley> I think that if you enjoy watching over the person's shoulder and pointing out bugs and critiquing their code and suggesting things as you go just as much as you enjoy typing, you're a good programmer
11:28:50 <Binkley> well ok
11:28:55 <Binkley> "almost as much", fair enough?
11:29:14 <astrolabe> cjeris: :)
11:29:25 <kyevan> Weagh.
11:29:27 <Binkley> I mean, good programming is about thinking, and thinking doesn't require being at the keyboard.
11:29:36 <Binkley> In fact, sometimes I find that being at the keyboard is antithetical to thinking.
11:29:40 <shapr> Yeah
11:30:01 <kyevan> Switching from a higly-unformed haskell knowledge, to a butchered scheme, and trying to pick up Haskell where you left off == murder.
11:30:35 <kyevan> If anyone finds part of my brain, pleas hand it back, thanks >_<
11:30:56 <Excedrin> what sort of butchered scheme?
11:31:00 <shapr> Aha, so that's the sticky stuff on my keyboard!
11:31:28 <kyevan> Excedrin: DrScheme/HtDP Beginning Student language.
11:31:36 <vincenz> cjeris: that is sad
11:32:01 <Binkley> shapr: that would be a great quote to take out of context
11:32:06 <astrolabe> Are there programming competitions where the task is to produce the clearest code which solves the problem?
11:32:17 <Binkley> astrolabe: no, because you can't judge clarity with an autograder script
11:32:27 <psnl> @remember shapr Aha, so that's the sticky stuff on my keyboard!
11:32:43 <cjeris> vincenz: but truish, or at least has perceived realism
11:32:46 <Codex_> clarity of the code is subjective.
11:32:48 <astrolabe> Binkley, like Ice skating then.
11:32:49 <vincenz> cjeris: yeah :/
11:33:00 <astrolabe> Codex_: yes
11:33:05 <kyevan> Binkley: You can't judge obfutication, either...
11:33:17 <shapr> oboy
11:33:19 <Binkley> astrolabe: I've never seen a script that judged ice skating competitions, that's true
11:33:34 <Binkley> my friend who judges skating would probably be upset if I suggested that she could be replaced with a very small shell script
11:33:37 <kyevan> What is incomprehensable jibberish to one person, may be clear as day to another
11:33:41 <shapr> You could judge things like cyclomatic complexity.
11:33:47 <Binkley> shapr: :-(((((((
11:33:48 <astrolabe> Which must be why there are no ice skating competitions?
11:33:52 <Binkley> I had to read a paper on that for my last job.
11:33:56 <Binkley> It was so content-free.
11:34:17 <Binkley> astrolabe: well, ice skating competitions exist because people buy tickets to see them, hence it's worth the judges' time to watch and judge
11:34:27 <Binkley> who would buy tickets to watch a bunch of geeks typing on keyboards?
11:34:35 <Binkley> if people would, we could sell tickets to watch us talk on #haskell
11:34:39 <Binkley> and I wouldn't need to look for a job
11:34:41 <glguy> Binkley: south koreans might
11:34:45 <Binkley> LOL
11:34:53 <Binkley> OTOH, I guess people do watch bowling on TV.
11:34:57 <glguy> they would pay to watch people play computer games
11:35:00 <dylan> Cale: hmm, would it be very inefficient to use this CursorString thing?
11:35:22 <astrolabe> I think we could have such a competition and judge it ourselves for instance.
11:35:28 <Cale> Compared with what?
11:35:38 <dylan> Cale: Compared to a mutable array
11:35:42 <Cale> no
11:35:45 <Cale> er
11:35:53 <Cale> yes, it would be inefficient
11:35:56 <Binkley> come to think of it, the ICFP programming contest has a "judges' award"
11:36:02 <Binkley> but I'm not sure that it's solely about clarity
11:36:11 <Cale> Actually, probably better than a mutable array would be a Data.Sequence
11:36:20 <astrolabe> Binkley: right
11:36:26 <Syzygy-> Cale: I settled on your Data.Array idea. Makes for occasionally neat code.
11:36:36 <Cale> because those are immutable, but pretty much all the operations you want are O(1)
11:36:44 <Syzygy-> And an Matrix +-* Matrix = assert (dimensions match) $ code
11:37:05 <dylan> Cale: hmm. This CS idea seems to be really elegant, and it's just for a text area in a chat client.
11:37:13 <vincenz> cjeris: it
11:37:20 <dylan> but I'll check Data.Sequence
11:37:28 <vincenz> cjeris: it's scary how most of those stories from 10-20 years ago are still applicable
11:38:29 <Cale> dylan: yeah, it's exactly what you want for editing things around a cursor, but there are various operations which are slower than you'd want
11:38:58 <Cale> (when you get away from local edits)
11:39:46 <dylan> but for a single line, before/after are never likely to be huge
11:42:22 <cjeris> vincenz: because improving the practice of our profession doesn't help one bit with idiots who insist on looking at it from the outside... and write our paychecks
11:44:37 <vincenz> cjeris: yeah but even just programming in general, quite often you look back at people from 20 years ago and what you're doing is still the same thing they solve
11:44:47 <vincenz> d
11:45:05 <astrolabe> I think generally people are trying to 'measure' performance more than they used to, and that it is counterproductive.
11:46:14 <kyevan> Hmm. Someone shoot whoever wrote "Functional programs tend to be much more concise than their imperative counterparts. Quicksort is a rather extreme case, but in general functional programs are much shorter (two to ten times)." on http://www.haskell.org/haskellwiki/Introduction , please.
11:46:15 <lambdabot> Title: Introduction - HaskellWiki
11:46:31 <kyevan> Unless functional programming lets you write negative amounts of code.
11:46:48 <shapr> two times shorter?
11:46:57 <kyevan> shapr: right.
11:46:59 <shapr> Half the code?
11:47:03 <astrolabe> kyevan: right!
11:47:06 <kyevan> shapr: That's what they ment
11:47:10 <kyevan> But, not what they said
11:47:56 <kyevan> They said functionalLines = imperitiveLines - (imperitiveLines * <a number between 2 and 10>)
11:48:01 <kyevan> Which is utter nonsense.
11:48:13 <glguy> a negative number?
11:48:25 <Binkley> kyevan: better now?
11:48:33 <Binkley> also, it's too bad that haskellwiki doesn't have a {{citation needed}} tag
11:48:35 <Binkley> *or does it??*
11:48:58 <vincenz> no, unfounded claims are better
11:48:59 <kyevan> Binkley: I think so, yess.
11:49:04 <bd_> Sometimes functional coding does feel like the complete reverse of imperative :)
11:49:16 <kyevan> And, sorry, that's just one of the things that gets my goat :P
11:49:23 <Binkley> vincenz: you'd fit right in on wikipedia. ;-)
11:49:50 <Binkley> Hey, here's a question for everyone. what's the asymptotic running time of the haskell quicksort on that introduction page?
11:50:07 <Binkley> I've heard something about how the usual example of quicksort in haskell is quadratic, but my brain is too broken atm to figure out whether that one is
11:50:09 <astrolabe> nlogn?
11:50:10 <lisppaste2> glguy pasted "Without running this, determine what it does (-; (4 fairly clean lines)" at http://paste.lisp.org/display/31403
11:50:29 <vincenz> Binkley: quadratic, but explain the wikipedia bit?
11:50:42 <Binkley> vincenz: well, I was just mocking wikipedia
11:50:45 <Codex_> binkley: probably O(n^2).
11:50:49 <astrolabe> vincenz: why quadratic?
11:50:53 <Binkley> majority wins! O(n^2)
11:50:57 <kyevan> Binkley: Mockery it deserves.
11:51:03 <astrolabe> boo.  Take an average :)
11:51:38 <Binkley> kyevan: Ever since my RfA got turned down because of my gender, I've been totally happy to mock Wikipedia.
11:51:50 <vincenz> astrolabe: the average of O(n^2) and O(n log n) = O(n^2)
11:52:00 <astrolabe> Binkley: what is your gender?
11:52:07 <vincenz> astrolabe: dynamically typed
11:52:08 <astrolabe> vincenz: that's why I grinned
11:52:16 <vincenz> :D
11:52:46 <vincenz> @quote vincenz
11:52:46 <lambdabot>  sure, give us your homework and we'll email it straight to your teacher :)
11:52:52 <vincenz> crap, I always get the wrong ones
11:53:13 <kyevan> Heheh. I thought for a sec Binkley had said "dynamically typed". I wish my gender was dynamically typed!
11:53:22 <vincenz> kyevan: I was answering for her
11:53:26 <Binkley> astrolabe: I'm genderqueer
11:53:29 <vincenz> Binkley's gender -is- dynamically typed
11:53:37 <Binkley> vincenz's answer is also more-or-less right
11:53:54 <vincenz> or was it dynamically scoped?
11:53:58 <vincenz> @quote vincenz
11:53:59 <lambdabot>  Geek is Chique.
11:54:00 <vincenz> grr
11:54:01 <kyevan> Oh, I'm misinterpreting things?
11:54:04 <Binkley> any further questions about my gender should probably be directed to #haskell-blah :-)
11:54:20 <astrolabe> We should add it to the topic
11:54:23 <Binkley> lolz
11:54:28 <Binkley> sex, Binkley's gender, and everything else except Haskell
11:55:09 <vincenz> operational sematnics, dynamic scoping...
11:55:11 <vincenz> sound about right
11:55:12 <Binkley> Um, anyway, about that quadratic QuickSort (to bring things back on-topic...)
11:55:27 <vincenz> worst case : O(n^2)
11:55:27 <Binkley> I was writing out QuickSort in Haskell during an interview I had on Friday (not for a Haskell job)
11:55:31 <Binkley> and the interviewer was so amazed
11:55:32 <Binkley> he said
11:55:37 <Binkley> "I'm keeping this piece of paper!"
11:55:41 <vincenz> lol
11:55:48 <Binkley> and then I had to say, "wellbythewaythatversionisprobablyquadratic"
11:56:13 <kyevan> Hmm, so, uh, what's a good editor for haskell, that isn't emacs?
11:56:22 <Binkley> kyevan: what's wrong with emacs?
11:56:24 * glguy prefers Visual Studio .NET 2005
11:56:30 <bd_> kyevan: I just vim...
11:56:31 <vincenz> kyevan: vim!
11:56:33 <kyevan> Binkley: Emacs makes my head hurt almost as much as haskell!
11:56:34 <bd_> er, use vim*
11:56:38 <emu> aren't all quicksorts worst-case quadratic?
11:56:41 <bd_> isn't there a vi clone in Haskell too? :)
11:56:44 <Binkley> ?remember kyevan Emacs makes my head hurt almost as much as haskell!
11:56:47 <vincenz> Binkley: ESCAPE META ALT CONTROL SHIFT?
11:56:49 <xs> emu, yes
11:56:52 <glguy> using visual studio you can hover over expressions to see their types
11:56:54 <Binkley> vincenz: EVENTUALLY MALLOC()S ALL COMPUTER SPACE
11:57:16 <Binkley> emu: the usual Haskell one is average-case quadratic, though... I think?
11:57:23 <emu> hmm, eclipse makes emacs look svelte
11:57:24 <xs> emu, consider quicksorting a reverse ordered list
11:57:27 <Binkley> I forget if you can write a quicksort that's worse-case n log n.
11:57:32 <Binkley> I should walk downstairs and ask Tony Hoare.
11:57:52 <xs> Binkley, in haskell? or in c?
11:57:56 <fasta> Binkley: IIRC, you can.
11:57:58 <Binkley> xs: in any language
11:57:58 <glguy> merge sort and heap sort are worst case n log n
11:58:00 <vincenz> I can write a worse case O(n) partial sort
11:58:06 <Binkley> glguy: sure, but I'm talking about quicksort
11:58:13 * Syzygy- wishes that Visual Haskell would run on his VS.Net 2005. :(
11:58:18 <bd_> Quicksort itself always has the risk you'll choose a bad pivot, every time.
11:58:20 <fasta> Binkley: And I actually understood your question :)
11:58:25 <glguy> Syzygy-: what is wrong with your vs2005?
11:58:26 <bd_> and you won't find out until it's too late
11:58:33 <xs> Binkley, oops, i missed the worst case. how could you?
11:58:38 <vincenz> Binkley: funny then they call it quicksort
11:58:39 <emu> also fast quicksorts (nice redundancy) are not stable
11:58:43 <Syzygy-> glguy: Dunno, but it throws a "Plugin wouldn't load" error when I try to do haskell with it.
11:58:51 <Binkley> vincenz: apparently, with quicksort the constant factors are usually pretty good
11:58:53 <Binkley> Or so they say.
11:59:08 <Syzygy-> And it's connect to the internet via a Birkenstock proxy, so I'm not really capable of debugging things decently.
11:59:13 <Binkley> xs: I don't know, I'm asking
11:59:15 <jlouis> Binkley, if you choose your pivot randomly, you obtain _expected_ O(n lg n)
11:59:16 <glguy> Have you guys seen the "J sort algorithm"?
11:59:21 <emu> the reason why people use quicksort is because it can be implemented in constant space
11:59:27 <emu> (over say, merge sort)
11:59:27 <Excedrin> http://citeseer.ist.psu.edu/hudak94haskell.html this paper would be a good reference for the "FP produces shorter code" claim
11:59:29 <lambdabot> Title: Haskell vs. Ada vs. C++ vs. Awk vs. ... An Experiment in Software Prototyping Pr ...
11:59:44 <glguy> J sort: min heapify, max heapify, selection sort (I believe)
11:59:50 <bd_> emu: heap sort does too :)
11:59:57 <xs> Binkley, well. if the list is reverse-ordered then you need \Theta(n^2) comparisons.
12:00:02 <Binkley> jlouis: right, *expected*, I know you can do
12:00:09 <bd_> hmm, classtime, *afk*
12:00:14 <Binkley> xs: for any choice of pivot, though? (I think you're right)
12:01:08 <jlouis> if you are not random. Your choice must be deterministic. If it is deterministic an enemy adversary can always choose the worst possible ordering
12:01:14 <vincenz> > let {vinzsort [] = []; vinzsort (x:[]) = [x]; vinzsort (a:b:c) = if a > b then vinzsort (a:c) else a:vinzsort (b:c)} in vinzsort [2,3,4,5,2,3]
12:01:16 <lambdabot>  [2,3,4,5]
12:01:29 <xs> Binkley, doesn't pivot just rotate the comparison tree and not change the number of nodes?
12:01:45 <astrolabe> A chap at work was talking about a sort called something like 'bogsort', with factorial efficiency.  You randomise the list until it's sorted :)
12:01:55 <jlouis> I tend to like Bottom-up mergesort a lot
12:02:07 <jlouis> astrolabe, yeah, its cool
12:02:10 <jlouis> bogosort
12:02:18 <xs> astrolabe, bogosort?
12:02:23 <vincenz> xs: the point is that with qsort you can alway spick the worst possible pivot and then never really divide your workspace into two, cfr: qsort [10..1]
12:02:23 <astrolabe> ah that was it.  thanks
12:02:24 <Excedrin> I wonder if smoothsort would have better performance in Haskell
12:02:41 <jlouis> there are 2 variants: check for sorting; randomly permutate and randomly permutate; check. They have different smoothness properties ;)
12:02:45 <emu> with a randomized pivot, the chances of that are abysmally low
12:02:46 <vincenz> xs: filter isSorted . allPerms
12:02:50 <glguy> ?users
12:02:51 <lambdabot> Maximum users seen in #haskell: 278, currently: 270 (97.1%), active: 39 (14.4%)
12:02:59 <vincenz> emu: but we're discussiing worst case
12:03:08 <glguy> anyone heard of "flash sort"
12:03:14 <Binkley> xs: well, since a bad pivot can lead to quicksort being quadratic and a good one can make it n log n in most cases, I don't think that's right
12:03:23 <vincenz> emu: and no they are not abysmally low, they are the same chance as having a reversed list
12:03:24 <xs> hmm.
12:03:28 <Binkley> or rather, what vincenz said
12:03:34 <Binkley> that was a better explanation
12:03:37 <emu> idSort wins.
12:03:39 <kyevan> Why does Haskell not have side effects? I meen. no globals and such I understand, but, um, no printing to screen or reading from files or such??
12:03:48 <glguy> "FlashSort sorts n elements in O(n) time." http://www.neubert.net/FSOIntro.html (no, I don't believe the author)
12:03:48 <emu> whatcha mean
12:03:48 <kyevan> Doesn't that make it sort of, um, useless?
12:03:49 <lambdabot> Title: FlashSort Algorithm
12:03:50 <Binkley> kyevan: you can print to the screen, you just need to use the IO monad
12:03:54 <vincenz> kyevan: we abstract away from input and output
12:03:55 * emu putStrLn "hello world"
12:04:00 <shapr> kyevan: no no, it's referentially transparent, that doesn't mean you don't get screen output.
12:04:02 <Cale> kyevan: It does have those things, you just can't do it from pure code
12:04:05 <Binkley> the IO monad is part of Haskell
12:04:10 <vincenz> tss
12:04:11 <Codex_> kyevan: side effects have bad aliasing problems.
12:04:15 <jlouis> kyevan, Haskell has sideeffects, but they are compartamentalized and protected
12:04:16 <emu> ^ that's in the emu Monad
12:04:23 <Cale> kyevan: http://haskell.org/haskellwiki/Introduction_to_IO
12:04:24 <lambdabot> Title: Introduction to IO - HaskellWiki
12:04:27 <vincenz> Stop lying, just tell him the truth, Haskell abstracts away from side-effects
12:04:27 <Excedrin> Haskell does have side effects; but using them is explicit
12:04:42 <Cale> read that, and it'll explain :)
12:04:43 <astrolabe> kyevan: well done on finding the magic spell to wake up #haskell
12:04:46 <Binkley> vincenz, it depends on your definition of "side effects"
12:04:47 <Binkley> haha
12:04:54 <Binkley> I thought things here were pretty awake already
12:04:54 <vincenz> :P
12:04:55 * shapr throws razor lambdas at kyevan!
12:04:56 * emu wants "liftRealWorld"
12:04:59 <Binkley> what with the sorting algorithms
12:05:06 <vincenz> emu: it's called "death"
12:05:08 <Binkley> definitely a Haskell-related topic ;-)
12:05:08 <jlouis> urgh, razor lambdas!
12:05:20 <Cale> evaluation of Haskell expressions doesn't have side effects, but that's not the only thing which is happening when a Haskell program is running
12:05:27 * vincenz sends barbed bananas towarsd shapr 
12:05:38 <Cale> You have two interleaved processes: evaluation of expressions, and execution of IO-actions
12:05:41 <newsham> liftRealWorld?  its paul grahams all the way down.
12:05:41 <Binkley> Cale: evaluation of Haskell expressions has lots of side effects. just listen to your hard disk when you're building GHC ;-)
12:06:00 <Binkley> newsham: I can't decide if that's profound or not
12:06:09 <vincenz> Binkley: stop stealing my thoughts
12:06:16 <emu> Binkley: running one of michi's examples caused a fan on my computer to whine loudly
12:06:20 <Binkley> haha
12:06:21 <newsham> if you have to ask....
12:06:26 <vincenz> emu: what example?
12:06:27 <emu> i think it was the GPU fan :/
12:06:36 <Cale> IO actions are basically inert with respect to evaluation
12:06:38 <emu> uh, the spinning cubes one with the idleHandler thing
12:06:39 <jlouis> ?hoogle liftRealWorld
12:06:40 <lambdabot> No matches found
12:06:41 <Binkley> reminds me of that quote from somebody, "GHC once predicted a CPU death on my machine"
12:06:44 <emu> i changed it to use timeoutHandler instead
12:06:47 <vincenz> emu: linky?
12:07:07 * vincenz just noticed that link and kink differ in but one letter
12:07:17 <emu> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
12:07:21 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell - a tutorial ..., http://tinyurl.com/ea6tc
12:07:35 <xs> ah. if pivot is the median value, then quicksort's worst case can be reduced to \Theta(n log n). hm pivot select is tricky.
12:07:43 <Binkley> xs: indeed
12:08:10 <emu> for some reason, using the idleHandler caused my fan to go nuts.  i just created a chaining timeoutHandler every 10 ms, and CPU usage went to nothing and no more fan problems
12:08:34 <vincenz> xs: pivot select is another O(n) :D
12:08:38 <vincenz> so you get n^2 log n
12:08:46 <vincenz> What's Theta?
12:09:01 <Cale> In the average case, the usual Haskell qsort should spend O(n log n) time in (++), and should recurse to depth O(log n)
12:09:37 <fasta> vincenz: Theta is Omega and Big Oh
12:09:38 <Binkley> emu: if your fan is going nuts, that probably means your cpu is overheating
12:09:56 <Binkley> overheating suggests that your cpu is doing a lot of computation (e.g., not waiting for network latency or disk I/O or anything like that)
12:10:10 <emu> yes, it was pegging the CPU ; the idle Handler runs every time its not doing anything
12:10:12 <vincenz> unless you have busy waiting
12:10:18 <Binkley> right
12:10:18 <emu> which is why i switched to the timeout
12:10:21 <Binkley> but why would you have busy waiting?
12:10:26 <Binkley> busy waiting makes the baby Jesus cry
12:10:27 <Cale> I actually had quite a lot of problems with my power supply overheating up until I replaced it recently.
12:10:29 <emu> because that's what glut suggests
12:10:32 <emu> this is glut
12:10:36 <emu> idleHandler.. etc. read up
12:10:44 <Binkley> ok ok
12:11:28 <vincenz> http://geeksexy.org
12:11:30 <xs> vincenz, O(n) is in O(n^2), but \Theta(n) is not in \Theta(n^2). theta is stricter in this sense.
12:11:33 <lambdabot> Title: Kirsten Chevalier's Home Page
12:11:40 <Binkley> vincenz: what about it?
12:11:59 <xs> vincenz, but isn't the run time complexity Theta(n) + Theta(n log n) which is Theta(n log n)?
12:12:14 * vincenz only knows O
12:12:16 <xs> so the coefficients suck, but the complexity is ok.
12:12:25 <vincenz> but I meant that you have an O(n) for each time so it's
12:12:30 <vincenz> n*(n log n)
12:12:39 <xs> ah. oops. yes.
12:12:50 <Cale> hm?
12:13:02 <vincenz> Cale: qsort with optimal pivot select
12:13:16 <Cale> oh
12:13:24 <emu> i like my algorithms to come with an oracle
12:13:26 <vincenz> which is still not ideal if you have many numbers that are the same
12:14:18 <emu> "Quick-Sort! O(nlog(n)) in the average case! Oracle not included."
12:14:30 <xs> emu, how about parallel dimensions? check out grover's algorithm for searching unsorted N items in O(sqrt N) time. heh.
12:14:43 <psnl> emu: and I want a pony, etc etc
12:14:53 <emu> i also like solving NP-hard problems on non-deterministic computers
12:15:03 <kyevan> Haskell follows the normal P E M/D A/S order, right?
12:15:09 <fasta> emu: There's no reason why that wouldn't be possible.
12:15:14 <emu> PEM/DA/S?
12:15:40 <newsham> emu: does your compiler optimize list-monad approriately for your ND machine?
12:15:56 <kyevan> emu: Parenthasis (and othe grouping things), exponents, multiplication and division, addition and subtraction
12:16:21 <emu> operator precedence? yes
12:17:55 <newsham> bruteForce space oracle = do { x <- space; return $ oracle x }
12:18:08 <newsham> O(1) on your non-deterministic computer?
12:18:31 <emu> it automatically creates and destroys universes to perform computations
12:18:46 <psnl> emu: pass the crack pipe, dude
12:18:49 <Binkley> like in HHGTTG?
12:18:50 <jlouis> vincenz, O(..) is an upper bound, Omega(..) is a lower bound. Theta is a precise bound to that class of functions, ie O(..) = Omega(..) (The lower bound is also the upper bound)
12:19:02 <jlouis> vincenz, informally speaking
12:19:17 <vincenz> Ah thanks
12:19:28 <kyevan> and, um, function applications happen before... everything except parenths?
12:19:46 <kyevan> Also, does Haskell work in restaurants?
12:19:57 <emu> kyevan: pretty much. keep in mind, there is also a low-precedence func application operator called '$'
12:20:23 <Binkley> kyevan: sure, if you have enough napkins
12:20:39 <emu> Haskell programmers might moonlight as wait-staff, i dunno
12:20:53 <jlouis> Learn about $ fast. Or you will be puzzled over some code
12:21:08 <Binkley> Also I'm sure there's a joke about currying lurking in this one.
12:21:10 <newsham> haskell programmer would rather wait tables than debug java?
12:21:19 <Binkley> newsham: I know which one I'd choose
12:21:24 <jlouis> Same goes for .  (or (.) as it is ocassionally typeset)
12:21:25 <Binkley> at least a waiter gets tips when they do a good job
12:21:33 <kyevan> jlouis: Well, I'm on page 14 of yaht :P
12:21:49 <newsham> wage + SUM tips < salary
12:21:54 <kyevan> I'd rather debug java!
12:22:12 <emu> > putStrLn $ "hello" ++ "world"
12:22:13 <lambdabot>  <IO ()>
12:22:17 <kyevan> sudo rm /usr/bin/java
12:22:19 <kyevan> Done
12:22:33 <kyevan> (well, a little cleanup left, but mostly done)
12:22:37 <emu> alias debug=rm
12:22:40 <Binkley> kyevan: how long have you worked at jobs where you had to debug java?
12:22:46 <Binkley> heh
12:22:55 <kyevan> Binkley: No time, I'm just being silly/
12:22:56 <Binkley> I didn't see the second part.
12:23:05 <Binkley> I'm just being triggered.
12:23:07 <Binkley> Don't mind me.
12:23:21 <emu> i learned something interesting about the java threading model a couple weeks ago.  apparently, if you call a method in a Runnable class, it will drop whatever that instance's thread is running, and interrupt it to run the method you called.
12:24:19 <Binkley> emu: so... what's wrong with that?
12:24:34 <emu> just surprising that it follows the static scope instead of the dynamic call-chain
12:25:05 <emu> and a bit of puzzling over why my messages were disappearing when I put them on the thread's queue
12:26:05 <Binkley> java's concurrency semantics? surprising?
12:26:07 <Binkley> alert the media
12:26:18 <emu> it's silly
12:26:28 <emu> but i'm used to functional languages
12:26:38 <newsham> bruteForce space oracle = space >>= (\x -> if oracle x then [x] else [])
12:26:53 <emu> where you don't expect calling a function to suddenly interrupt another process
12:27:21 <Binkley> well, yeah. and where there are rainbows and puppies and you can differentiate functions in the type system.
12:28:06 <jlouis> I guess Oleg implements a haskell compiler in the type system next
12:28:44 <glguy> Cale: ddi you downvote the reddit article I submitted yet? (-:
12:29:10 <Binkley> glguy: link?
12:29:14 <Binkley> (so that I can downvote it :-)
12:29:15 <glguy> http://programming.reddit.com/info/tvpl/comments
12:29:17 <lambdabot> Title: The Flashsort1 Algorithm, an O(n) sorting algorithm (reddit.com)
12:29:23 <glguy> I'm not encouraging people to do it
12:29:36 <glguy> I'm mostly interested in the comments that people will make
12:30:00 <Binkley> heh
12:30:04 <glguy> and to hear a well through out rebuttle by someone who takes the time to debunk it
12:30:05 <Binkley> O(n) sorting algorithm
12:30:11 <Binkley> it's... just too easy.
12:30:23 <Binkley> oh, well, it's not a general sorting algorithm.
12:30:28 <Binkley> so your title for it is a little misleading
12:30:44 <glguy> It wasn't immediately claer to me if it was or not
12:30:49 <Binkley> well, it can't be
12:30:56 <glguy> because they seem to say it works on arbitrary real numbers
12:30:59 <psnl> glguy: without reading, is it bucketsort?
12:31:05 <paolino> does case introduce a new scope ?
12:31:19 <Binkley> "partially distinguishable"
12:31:26 <Binkley> that's the extra constraint
12:31:37 <emu> paolino: in that you can bind pattern variables within the clauses, yes
12:32:10 <jlouis> case foo of Nothing -> (let x = 5 in ..)
12:32:12 <Binkley> psnl: I think it is
12:32:22 <jlouis> let is just an expression
12:32:44 <paolino> otherwise  sons <- new empty
12:33:06 <paolino> sons is defined outside  the case ?
12:33:19 <vincenz> paolino == xerox?
12:33:35 <paolino> magari
12:33:52 <jlouis> paolino, a variable introduced in a variant shadows an earlier variable
12:33:53 <paolino> which is 'no'
12:33:57 <vincenz> paolino: parlo italiano
12:34:04 <jlouis> if you compile in GHC with -Wall you'll get a shadowing warning
12:34:39 <paolino> ok
12:36:03 <paolino> @seen xerox
12:36:03 <lambdabot> xerox is in #haskell. I last heard xerox speak 22h 7m 48s ago.
12:36:28 <kyevan> why doesn't "0:[1,2,3]:4:5:[6,7,8,9]" work?
12:36:56 <Syzygy-> Because 0, 4, 5 are not [Int].
12:36:57 <emu> because the second argument to (:) must be a list
12:37:10 <kyevan> emu: Oh.
12:37:10 <jlouis> kyevan, because 0 has type Int and [1,2,3] has type [Int]
12:37:19 <emu> > 0:[1,2,3]
12:37:21 <lambdabot>  [0,1,2,3]
12:37:42 <jlouis> ?type (:)
12:37:44 <lambdabot> forall a. a -> [a] -> [a]
12:37:52 <jlouis> see?
12:38:16 <kyevan> jlouis: I see something that might as well by mayan hiroglyphics
12:39:34 <jlouis> if you substitute 'a' for Int, you get: Int -> [Int] -> [Int], ie (:) is a function which takes an integer, an integer list and returns an integer list
12:40:25 <kyevan> jlouis: I mean, the type thing makes no sense, period :P
12:40:27 <jlouis> in 0:[1,2,3], (:) is applied to the Int 0 as well as the Integer List (Written [Int]) [1,2,3]
12:41:30 <jlouis> kyevan, when you come along a term named 'currying' in yaht at some point, remember this conversation then
12:42:34 <Excedrin> "a" represents any type, "[a]" is a list of that type of items, "->" represents a function, in some sense "a -> [a] -> [a]" is a function that takes two arguments, one of any type and the other of a list of the same type, and returns a list of that type
12:42:56 <kyevan> jlouis: So, rewriteing that in a notation I understand,  <some type> list-of-<some type> -> list-of<some type>, where <some type> is always the same type?
12:43:08 <Excedrin> yes, that's right
12:43:17 <kyevan> Oh, okies.
12:43:22 <emu> so, do people in general take care to align their equal signs, and add extra padding in various places to make it look nice, or am I just crazy
12:43:22 <kyevan> That makes more sense... I think.
12:44:20 <Excedrin> kyevan: are you familiar with C?
12:44:32 <kyevan> Excedrin: No, not really.
12:44:36 <jlouis> emu, I think they tend to press C-c C-= in their emacs buffer
12:44:38 <Binkley> emu: sometimes they do
12:44:40 <kyevan> I can read simple C, but not write it.
12:44:41 <Binkley> I don't know about people in general
12:44:43 <emu> jlouis: yep
12:44:51 <Binkley> shit, emacs can do that?? I've been wasting my time hitting space
12:44:57 <Binkley> that wasn't sarcastic btw
12:45:00 <emu> i've started obsessively using align-regexp too
12:45:14 <emu> Binkley: check out C-c C-o, C-c C-., C-c C-|
12:45:24 <Binkley> is this a haskell-mode thing or a regular emacs thing?
12:45:27 <Excedrin> kyevan: is there some other language that has type notations that you are familiar with?
12:45:29 <emu> haskell-mode indent
12:45:30 <kyevan> Binkley: emacs can simulate quantum computing :P
12:45:42 <emu> well, align-regexp is an emacs22 thing
12:46:04 <kyevan> Excedrin: Um, the contracts in HtDP are pretty familier.
12:46:06 <emu> C-c C-. is kinda a semi-"intelligent" align region for haskell (from haskell-indent)
12:46:19 <kyevan> (<function> : <arguments> -> <result>)
12:46:58 <glguy> nthFromLast n xs = evalCont (callCC f) where
12:46:58 <glguy>  f done = foldr
12:46:58 <glguy>   ((=<<) . flip (liftM2 (>>) . (. (n ==)) . flip when . done) (return . (1 +)))
12:46:58 <glguy>   (return 0) xs >> error "bad input"
12:47:07 <emu> rofl
12:47:24 <emu> we're trying not to scare the beginner, here
12:47:33 * glguy isn't reading the channel, just pasting
12:47:54 <Binkley> I should actually read the haskell-mode documentation one of these days
12:48:11 <emu> Binkley: check-out CVS too, i sent some patches hopefully they made it in
12:48:32 <Binkley> I suspect I'll be busy enough for a while trying to learn what's already in the release version ;-)
12:48:44 <emu> it's easy. type C-h m in a haskell buffer
12:49:09 <Saizan> speaking of emacs, how do you switch from a splitted buffer to the other using the keyboard?
12:49:17 <emu> C-x o
12:49:30 <Saizan> thanks
12:49:52 <emu> and in a haskell-buffer, you can always open and switch to *haskell* process by typing C-c C-b
12:50:37 <Saizan> i use C-c C-l directly
12:50:46 <emu> Binkley: jtlyk, the release of haskell-mode is way out of date
12:50:52 <SamB> eek
12:50:53 <Binkley> reading documentation is hard, though, code is so much easier to understand
12:50:54 <emu> Nov 2005
12:50:57 <Binkley> well, I guess I could just RTFS then.
12:50:58 <SamB> why is it so out of date?
12:51:10 <emu> i don't know why. he just hasn't released. cvs has tons of new stuff.
12:51:23 <emu> well, i guess mostly fixes
12:51:27 <jlouis> ?where haskell-mode
12:51:27 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
12:51:41 <emu> i've gotten quick responses, so he's active
12:51:56 <alexj__> what does a "Bus Error" when GHC crashes?
12:52:11 <alexj__> (on OS/X intel?)
12:52:16 <SamB> I don't know what they mean at all!
12:52:19 <emu> it did something seriously wrong
12:52:30 <SamB> but yeah, serious craziness
12:52:45 <SamB> not that I'm on OS X or anything
12:53:03 <alexj__> ok any thoughts on how to track down the actual cause?
12:53:09 <emu> Binkley: emacs is the self-documenting editor ;)
12:53:14 <SamB> gdb
12:53:30 <jlouis> alexj__, SIGBUS is usually due to bad memory access of some sort. Maybe we are talking misaligned access or something (if on PPC)
12:53:48 <SamB> jlouis: he just said intel!
12:53:49 <jlouis> man 7 signal in general
12:53:57 <jlouis> urgh
12:54:13 * jlouis makes more coffee
12:54:18 <SamB> anyway, I say GDB is your best bet to discover where the SIGBUS is actually happening
12:54:34 <Binkley> alexj__: if you can reproduce the bug, you could also file a bug report
12:54:39 <Binkley> if you don't feel like debugging the RTS yourself
12:54:50 <Binkley> (of course, I have no idea why anyone *wouldn't* feel like debugging the RTS themself)
12:55:12 <SamB> Binkley: we don't know who's bug it is yet!
12:55:27 <Binkley> SamB: is he modifying GHC?
12:55:36 <alexj__> it is code that compiled on windows
12:55:41 <Binkley> because unless he is, then you shouldn't get a bus error
12:55:46 <kyevan> So, head and tail are basicly first (car) and rest (cdr)?
12:55:50 <alexj__> just using default macports ghc.
12:55:55 <SamB> Binkley: maybe he is doing wierd FFI things
12:56:03 <Binkley> well, ok, point
12:56:13 <Binkley> kyevan: basically, yes
12:56:27 <emu> kyevan: familiar with lisp i guess? or scheme?
12:56:34 <Binkley> alexj__: are you doing weird FFI things?
12:56:36 <emu> read htdp, so scheme i'd guess?
12:56:41 <Excedrin> kyevan: I had to look up HtDP's contracts, but yes, they're basically type annotations... I guess there isn't much emphasis on currying though, in Haskell, "number number -> number" would be "forall a. (Num a) => (a,a) -> a"
12:56:49 <alexj__> code worked fine on linux and intel
12:57:01 <alexj__> linux and windows.  no ffi
12:57:03 <SamB> kyevan: except Haskell doesn't let you have arbitrary types of things for the car and cdr of a cons
12:57:17 <SamB> alexj__: well, what are you doing?
12:57:25 <SamB> maybe you are using a library that does FFI
12:57:49 <glguy> ?type foldM
12:57:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:57:51 <SamB> anyway *something* is probably buggy
12:57:59 <kyevan> emu: Limited (but greater than anything else, and enough to do just about anything, given enough time) Scheme, yeh
12:58:28 <SamB> the main problem I have with scheme is the lack of structure
12:58:43 <alexj__> samB: i got a new macbook and am attempting to recompile my various projects.
12:58:47 <emu> well that's ok.  Scheme is also a functional programming language, like Haskell, but with no static type system.
12:58:57 <emu> (and a different dynamic semantics, but yea)
12:59:05 <kyevan> Incidently, is there a drscheme-like gui for haskell? (definitions on top, interactions on bottom)
12:59:15 <SamB> and then there are those functions whose names end in !
12:59:16 <kyevan> emu: and a heck of a lot less parenthesis :P
12:59:17 <emu> Emacs haskell-mode ;)
12:59:25 <emu> kyevan: oh you haven't seen Liskell!
12:59:40 <emu> heh, there is a DrHaskell for suggesting tips to beginners, but i haven't used it.
13:00:05 <kyevan> Actually, you could probably hack haskell into drscheme somehow...
13:00:05 <SamB> only beginners?
13:00:22 <kyevan> I mean, if the javalike language and algol have been added... "{
13:00:24 <emu> kyevan: well drscheme does code analysis to help out too
13:00:24 <SamB> mmm, emacs!
13:00:26 <kyevan> er
13:00:28 <kyevan> :P
13:00:34 <SamB> I always use emacs for that
13:00:39 <emu> kyevan: but yea... emacs does that kinda stuff for lisp, scheme, haskell, every language
13:01:20 <emu> or you can sit with a ghci process in one window and type :load file, and :reload
13:01:22 <SamB> with varying levels of editor support
13:01:25 <kyevan> emu: as I said earlier, "Emacs makes my head hurt almost as much as haskell!"
13:01:30 <emu> kyevan: well that's silly
13:01:38 <SamB> and Haskell at least makes sense in the end!
13:01:57 <kyevan> I like my vim, tyvm :P
13:02:00 <kolmodin> ?quote
13:02:00 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
13:02:01 <emu> then use vim
13:02:31 <emu> i'm not aware of a vim extension that runs ghci in a process buffer.  you can just do the separate window/ghci thing.
13:02:33 <SamB> emacs is actually written in a strange Lisp dialect...
13:02:42 <kyevan> SamB: Yep, elisp
13:02:45 <kolmodin> I'm quite happy with vim for haskell coding
13:02:55 <SamB> kyevan: yes, I know what it is called ;-)
13:03:22 <kyevan> well, elisp in GNU and xemacs, anyway
13:03:29 <kyevan> Some other implimentations use other languages
13:03:32 <emu> hmm, zmacs anyone
13:03:47 <emu> go lisp machine editors!
13:03:57 <SamB> those aren't what we call emacs anymore
13:04:36 <kyevan> But, emacs has weird keybindings
13:04:47 <emu> and people would say vim has weird keybindings too. i use both.
13:05:03 <kyevan> emu: You don't need a special keyboard for miv >_<
13:05:04 <emu> i'm happy they have keybindings
13:05:06 <kyevan> er
13:05:07 <kyevan> vim
13:05:15 <emu> kyevan: on the other hand, try using vim on a dvorak ;)
13:05:16 <SamB> yeah, I bet the notepad users would say vim has wierder keys
13:05:25 <SamB> but, that emacs also has quite wierd keys
13:05:32 <kyevan> emu: A few rebindings and it's fine
13:05:59 <kyevan> In fact, I think somewhere in the vim package is a config file for dvorak.
13:06:12 <emu> what does it use instead of hjkl?
13:06:36 <Excedrin> kolmodin: do you do most indentation manually?
13:07:00 <emu> anyway i'm not here to debate emacs/vim.  i like both.  i wanted to suggest a development setup for you..
13:07:01 * notsmack uses hjkl on dvorak
13:07:02 <kyevan> dhtn, I think
13:07:30 <Excedrin> I like vi because editing text with it reminds me of playing nethack
13:07:54 <kyevan> Excedrin: I never liked nethack.
13:07:55 <Excedrin> sometimes when I see 'D' I start mashing j uncontrollably
13:08:09 <kyevan> Too complex.
13:08:29 <kyevan> I like games I can turn on, play for a little bit, turn off, and walk away, with minimal investment of time.
13:08:44 <kyevan> Or brain cells
13:08:48 <Excedrin> pacman
13:08:59 * kyevan never could remember the nethach controls)
13:09:13 <kyevan> Excedrin: Pacman is awsome :)
13:09:28 <kolmodin> Excedrin: not much
13:10:16 <kolmodin> vim 7 has some haskell support builtin
13:11:47 <emu> one thing emacs haskell-mode has, which i am not sure exists anywhere else, is a semi-"intelligent" layout-comprehending indentation algorithm
13:12:47 <Binkley> emu: I've never thought its algorithm was very intelligent, actually...
13:12:50 <Binkley> unless I'm missing something
13:12:57 <Binkley> but it seems like the right thing never happens when I hit TAB
13:13:01 <Binkley> is there some magic I don't know about?
13:13:07 <emu> hit it again
13:13:10 <Saizan> i just hit tab till it gets in the right place
13:13:17 <psnl> that never seems to work for me
13:13:38 <emu> i think it could use some adjusting, because i usually hit tab twice and it's right oO
13:14:01 <Binkley> hmm
13:14:02 <Saizan> if you insist it eventually reach the right point
13:14:04 <Binkley> maybe I should get the latest version
13:14:32 <Saizan> you have to type the keyword of that line first
13:14:45 <emu> yes, and sometimes it's particular about having delimiters closed
13:14:45 <kolmodin> yeah, emacs is smarter when it comes to indention
13:14:46 <Saizan> like where or in
13:15:03 <kolmodin> you can hit TAB several times and it will guess all possible positions
13:15:07 <emu> there is C-c C-w for inserting and indenting a where automatically too
13:15:43 <kolmodin> except I remeber it didn't behave as I wanted when indenting "then" and "else" in if-statements
13:15:53 <emu> kolmodin: my copy is actually locally modified for that
13:15:56 <kolmodin> and case-statements too, perhaps
13:16:02 <kolmodin> emu: release it! :)
13:16:15 <emu> there's an outstanding issue with "if" in a "do"
13:16:19 <kolmodin> right
13:16:28 <emu> i adjusted it to give 2 more spaces to the else so that it is clearly in the "do"
13:16:38 <emu> but it also adjusts the contents of the "if" 2 more spaces
13:16:55 <alexj__> ok.  I've been factoring down and now I am getting: /usr/bin/ld: ../happs/src/HAppS/Agents/MailSender.o bad magic number (not a Mach-O file)
13:17:06 <emu> my copy is available from my emacs darcs repo
13:17:06 <alexj__> I have no idea what this means.
13:17:26 <alexj__> SamB: you still here?
13:18:03 <emu> plus it includes my new improvements -- C-c t (query and cache type of expression), C-c i (info of expr), C-c . (try to find defn by ghci)
13:18:15 <Binkley> alexj__: did you copy over MailSender.o from another machine?
13:18:25 <Binkley> the error message sounds like it's a .o file that was compiled on a different architecture
13:18:26 <alexj__> no it was just built by ghc.
13:18:29 <Binkley> though it could be other things
13:18:54 <alexj__> it was all generated in the same run.
13:20:04 <alexj__> ghc -o App.exe -cpp --make src/App.hs -i../happs/src -i.haskell_cache/http_searchpath.org-default.map.cache -isrc
13:20:48 <Binkley> can you maybe add -v to your options, touch the Haskell file for MailSender, and paste a transcript of the build?
13:25:02 <alexj__> ok where do I paste?
13:25:40 <notsmack> lisppaste2: url
13:25:40 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
13:26:17 <jlouis> emu, where is the CVS repository. Is it the one at :pserver:anoncvs@cvs.haskell.org:/cvs  ?
13:26:37 <alexj__> ok what is the shell command to grab the output of stderr?
13:26:39 <kyevan> Oh.
13:26:39 <emu> jlouis: monnier's? something like that. it's on his web page.
13:26:51 <emu> alexj__: 2> ..
13:26:53 <kyevan> Haskell needs parenths around negative numbers?
13:27:07 <emu> > 2 + -1
13:27:07 <lambdabot>    precedence parsing error
13:27:08 <lambdabot>     cannot mix `(+)' [infixl 6] and prefix ...
13:27:09 <alexj__> cut/paste from emacs is behaving bizarrely too (paste comes out in chinese!)
13:27:50 <defcon8> Anyone familitar with the installation of haskell-mode? I have tried to look at the installation guide on the site but the site is giving an error.
13:27:52 <emu> it's translating to chinese? emacs has become sentient?! and it's a grad student?!
13:27:54 <kyevan> > 2 + (-1)
13:27:55 <lambdabot>  1
13:28:05 <emu> defcon8: yes
13:28:10 <emu> it's haskell-mode day
13:28:23 <defcon8> right :|
13:28:28 <Binkley> every day is haskell-mode day!
13:28:28 <emu> defcon8: you put it on your load-path and load "haskell-site-file"
13:28:32 <Binkley> if you use haskell-mode
13:28:57 <kyevan> See, emacs is weird.
13:28:57 <defcon8> and use haskell every day :)
13:29:03 <defcon8> emu, don't I require it?
13:29:05 <emu> defcon8: then you can enable optional features by putting the following forms in: (add-hook 'haskell-mode-hook 'turn-onhaskell-doc-mode)
13:29:11 <kyevan> You need all sorts of modifier keys
13:29:26 <kyevan> includeing one no keyboard manufactured these days actually has!
13:29:27 <emu> look, vim is great, but it uses modifier keys too, so shush
13:29:28 <Binkley> There are people who don't use Haskell every day?
13:29:38 <kyevan> emu: Yes, yes it does
13:29:44 <emu> defcon8: turn-on-haskell-doc-mode and turn-on-haskell-indent
13:29:57 <defcon8> kyevan, it is called changing key mappings
13:29:57 <kyevan> But, you don't need them to do simple lings like moveing around a file
13:30:05 <emu> kyevan: but you need to hit ESC ;)
13:30:11 <emu> actually I hit C-[ in vim now
13:30:25 <kyevan> emu: Yes, you do. to ESCape from a mode :P
13:30:36 <kyevan> and, every keyboard I've ever seen has escape
13:30:38 <emu> ESC is rather atrocious to have to hit, though.  C-[ is an improvement.
13:30:58 <emu> kyevan: it strikes me though, because the whole point of using vim is not to move your hands from the Home Row, but ESC requires that.
13:31:46 <Binkley> get a keyboard that has ESC in the home row, then...
13:31:47 <kyevan> emu: The whole point for me is because the mode thing makes more sense than having to remember a bajillion emacs keys :P
13:31:50 <Binkley> I don't know if such a thing exists
13:31:54 <emu> yes, modern PC keyboards are retarded
13:31:55 <Binkley> but it seems like it would be an easy problem to solve
13:32:08 <kyevan> Make capslock escape
13:32:08 <Binkley> or, hell, remap something else to ESC
13:32:09 <emu> kyevan: that objection really makes no sense.  vim has just as many. if it didn't, i wouldn't like it.
13:32:12 <Binkley> like TAB, on my keyboard
13:32:12 <kyevan> It's next to useless anyway :P
13:32:26 <emu> kyevan: actually I make capslock to be control
13:32:26 <Binkley> hmm, on my keyboard Caps Lock is next to 'A'
13:32:29 <Binkley> not next to useless
13:32:31 <kyevan> emu: But, you don't need to know them to do basic editing
13:32:37 <defcon8> emu, how do I customise haskell?
13:33:14 * kyevan is one of those crazy people who would use nano excluseivly if it had syntax highlighting, probablt.
13:33:16 <emu> kyevan: vim modes are further from what most people expect out of an editor than anything else really. it's quite different, and I do enjoy it, but it's definitely something you need to know.
13:33:31 <emu> defcon8: in what way?
13:33:39 <defcon8> interpreter path
13:33:48 <emu> (setq haskell-program-name "ghci")
13:34:05 <emu> or you can supply the universal argument to the run-haskell function and it will let you specify
13:34:13 <Saizan> kyevan, i'm using emacs by a week, and i feel nice with my C-x b, C-c C-l,C-w,M-w,C-y,C-x C-f,C-x C-s :P
13:34:18 <kyevan> emu: Yes, remembering i to go to insert, R to go to replace, o and O to open linds, maybe a to append, and hjkl, is easier for me than remembering the emacs bindings, by far.
13:34:22 <alexj__> Binkley: it is telling me that the paste is too big.  anything specific to get?
13:34:26 <emu> Saizan: have you toggled iswitchb-mode?
13:34:36 <kyevan> Saizan: Ypu actually have meta?
13:34:44 <Saizan> kyevan: Alt
13:34:46 <kyevan> I've always had to use winkey or alt as meta.
13:34:50 <Binkley> alexj__: well, if you just include the transcript from MailSender and from the last file before you got the error message, is that small enough?
13:34:58 <Binkley> I'm not sure this will even help, but it's the only thing I can think of to do
13:35:00 <emu> kyevan: um, the emacs bindings to do the same things are just as simple.  have you tried visual mode? or gestures? actions?
13:35:05 <emu> (in vim, that is)
13:35:09 <Saizan> emu: i don't really know, i haven't touched anything aside isntalling haskell-mode
13:35:21 <kyevan> emu: I'm a simple guy, with simple needs
13:35:33 <emu> Saizan: (iswitchb-mode 1) in your .emacs.  i dont know why its not default.  it kicks ass.
13:35:38 <kyevan> And, like I said, syntax higlighting + nano would make me v.v. happy :P
13:35:44 <emu> think of it as "incremental search for your buffer selection"
13:35:59 <Binkley> do we need to start a #haskell-editor-wars? :P
13:36:02 <Saizan> ehm, how doaes it work then?
13:36:36 <emu> Saizan: when you C-x b, it puts your buffer list in your minibuffer and lets you type in part of whatever name you are looking for
13:36:55 <shapr> gwahr, "runghc Setup.hs clean" was the solution to an hour's worth of type errors!
13:36:56 <alexj__> Blinkley : it is not trivial because I am importing HAppS and HAppS imports a lot of stuff.
13:36:58 <Saizan> emu: it's yet doing that
13:36:59 <emu> try it.  M-x iswitchb-mode, then try switching buffers
13:37:00 * shapr bangs head
13:37:11 <kyevan> Binkley: Nah, I think a generic fn#editor-wars would be better.
13:38:13 <kyevan> Then it can catch editor wars from not only #haskell, but #scheme, #ruby-lang, and the ~ 3 billion #ubuntu-somethings
13:38:25 <shapr> alexj__: do you have the DarwinPorts or MacBinary flavor of ghc installed?
13:38:50 <alexj__> I've triedboth. I think I am currently usingDarwinPorts.
13:39:14 <Binkley> obviously IRC channels need hierarchical naming
13:39:22 <shapr> Same error with both flavors?
13:39:26 <Binkley> #comp.lang.haskell.flame.editor-wars
13:39:26 <Binkley> etc.
13:39:30 <emu> #alt.editors.flamewar
13:39:31 <emu> doh
13:39:38 <Binkley> and then there could also be #comp.lang.haskell.flame.unsafe-operations
13:39:38 <Binkley> etc.
13:40:40 * psnl thinks that this channel could be #haskell.flame
13:41:10 <kyevan> alt.newsgroups^w#alt.channels.are.almost.all.spam
13:41:11 * SamB wishes you could run some monadic actions before the body of a function...
13:41:44 <Binkley> psnl, if you think that, you're worse than Hitler
13:41:54 <emu> lol
13:42:08 <sjanssen> SamB: f = do action1; return f' ?
13:42:10 <kyevan> Binkley: Intentional invoctions don't work.
13:42:13 <kyevan> ... See?
13:42:15 <Binkley> kyevan: yes, I know
13:42:33 <Binkley> I got to threaten someone with Godwin's Law once while I was in the same room with Mike Godwin
13:42:38 <Binkley> unfortunately I was too shy to introduce myself
13:42:58 <psnl> Binkley: when it comes to art, I am
13:43:04 <Binkley> heh
13:43:14 <Binkley> well, he was a house painter, wasn't he?
13:43:22 <Binkley> you don't need to be a great artist for that?
13:43:52 <psnl> art school, he fialed to get into
13:44:04 <psnl> yoda, I am
13:44:44 <Binkley> so he must have been a good artist, then!
13:45:22 <kyevan> Binkley: And/or miserable faliure
13:45:28 <Binkley> And someday when I run for office, they'll find this IRC log and quote me as having said that Hitler had some good points
13:45:47 <glguy> and if they don't find that, they'll find this
13:46:06 <emu> and if they don't find it, they'll make it up anyhow
13:46:11 <Binkley> good point.
13:47:26 <shapr> Yay, CUFP 2007 is approved!
13:47:44 <shapr> And I'm on the committee
13:47:53 <kyevan> Binkley: Assumeing you're in some place reasonably like the US of A, you're already screwed as far as public office goes.
13:48:12 <shapr> kyevan: Was that a reference to public officers being promiscuous?
13:48:23 <kyevan> You don't fit nicely in the Christian world view.
13:48:27 <Binkley> kyevan: I'm an atheist. So, I'll never get elected to public office in my country
13:48:28 <kyevan> shapr: No, it wasn't.
13:48:29 <shapr> Anyway, can anyone suggest nominations for CUFP 2007?
13:48:36 <Binkley> shapr: yay for being on a committee!
13:48:37 <Binkley> Oh wait.
13:48:41 <Binkley> Being on committees sucks.
13:48:47 <kyevan> CUFP 2007?
13:48:49 <shapr> In this case, it looks like it won't suck.
13:48:55 <Binkley> So is CUFP going to be co-located with ICFP? (I assume?)
13:49:16 <shapr> I asked before hand what I needed to do, and it came down to "suggest who to invite to present at CUFP."
13:49:21 <shapr> Yup, CUFP will be colo with ICFP.
13:49:27 <kyevan> Committees ALWAYS suck
13:49:39 <Binkley> not sure I know of any possibilities for it who weren't in last year's CUFP
13:49:43 <Binkley> you could copy-and-paste the list :-)
13:49:50 <shapr> I'm going to suggest HAppS, of course.
13:51:17 <Excedrin> what are the states of Debian packages? (selected for install, selected for removal, installed, available, etc?)
13:52:28 <shapr> There's also pinned, and some other stuff, iirc
13:56:18 <emu> purged
13:57:47 <Taral> grr
13:57:53 <Taral> lisppaste2: url
13:57:54 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
13:58:38 <lisppaste2> Taral pasted "strictness analyzer bug?" at http://paste.lisp.org/display/31415
13:58:57 <Taral> can anyone help me understand why I get a stack overflow if I take out the seq?
13:59:30 <Taral> -ddump-stranal wasn't very helpful :(
13:59:52 <Binkley> Taral: why do you think it's a strictness analyzer bug?
13:59:56 <Binkley> (I haven't read your code carefully yet)
14:00:01 <Taral> because I add a seq and the problem goes away.
14:00:27 <Binkley> that doesn't mean it's a strictness analyzer bug
14:00:32 <Taral> okay, what's wrong then?
14:00:52 <Taral> I shouldn't have to put a seq there... loop is obviously strict in both arguments.
14:00:52 <shapr> Taral: Hey, do you know if anyone at IBM uses FP for production work?
14:01:08 <Taral> shapr: Mmm, I think so, but not anyone I know.
14:01:21 <lisppaste2> alexsiri7 annotated #31376 with "As short, but almost readable" at http://paste.lisp.org/display/31376#2
14:01:22 <Binkley> Taral: can you build it with -ddump-simpl and paste the results?
14:01:32 <shapr> Could you point me in their direction? I'm a committee member for Commercial Users of Functional Programming 2007.
14:01:38 <Taral> the results of ddump-simpl? It's big.
14:01:45 <Taral> shapr: Like I said, not anyone I know.
14:02:02 <Taral> hey! I got paste #pi*10000
14:02:04 <Binkley> or at least, the bit after "Demand analysis"?
14:02:16 <Taral> Binkley: with or without the seq?
14:02:52 <Binkley> without
14:03:14 <Taral> there is no line "demand analysis"
14:03:28 <Taral> only "tidy core"
14:03:38 <kyevan> Taral: 31415.92...?
14:03:44 <Taral> kyevan: #31415
14:03:51 <Taral> Binkley: You wanted ddump-stranal?
14:03:52 <kyevan> I would have thoguht it would use natural numbers
14:04:03 <Taral> kyevan: Bah.
14:05:14 <lisppaste2> Taral annotated #31415 with "ddump-stranal w/o seq" at http://paste.lisp.org/display/31415#1
14:05:32 <jlouis> and the one with post #31416 is actually closer to pi*10000 than you ...
14:05:38 <Taral> jlouis: :P
14:05:50 <jlouis> though your annotation might come closer, who known
14:05:51 <jlouis> s
14:06:04 <Taral> what is the real value of #1?
14:06:06 <Binkley> ok, yeah, that's what I wanted (I usually use -dverbose-core2core so I forgot what -ddump-simpl did)
14:06:25 <Binkley> well, it looks like the strictness analyzer thinks that loop is lazy in its second argument
14:06:30 <Taral> yes
14:06:31 <Binkley> the question is why... so I need to read your code again
14:06:34 <Taral> ok
14:07:04 <Binkley> Oh! that's easy enough
14:07:06 <Binkley> because it *is* lazy :-D
14:07:12 <Taral> it is?
14:07:17 <Binkley> if n < 1, loop never evaluates c
14:07:19 <Binkley> er
14:07:22 <Binkley> it never evaluates s, rather
14:07:40 <Taral> ...
14:07:44 <Binkley> rather, if n <= 1
14:07:51 <Taral> I wonder what it thinks the strictness of ecb and setup is?
14:07:57 <Binkley> that doesn't matter
14:08:05 <Taral> yes it does
14:08:07 <Binkley> loop is still lazy in its second argument no matter what ecb and setup are
14:08:15 <Binkley> oh, sorry!
14:08:20 <Binkley> i didn't notice that c was let-bound
14:08:25 <Taral> yes
14:08:34 <Binkley> my mistake.
14:08:51 <Taral> well, that's not good.
14:08:56 <Taral> setup: LL
14:08:59 <Taral> ecb: U(LL)L
14:09:01 <Taral> grr
14:09:24 <Binkley> well, if the strictness of take isn't what you want, then the others won't work
14:09:39 <Taral> take is definitely strict, it's take!
14:09:46 <Taral> well, bytestring take, but still.
14:09:58 <Binkley> sec
14:11:22 <Binkley> hmm, yeah
14:11:30 <Taral> but setup and ecb are not strict
14:11:35 <Taral> I'm looking at AES.hs now
14:12:21 <Igloo> What's the question?
14:12:36 <Binkley> yeah, if you could post the -ddump-stranal output for AES.hs, that would be helpful
14:13:10 <norpan> he said anal
14:13:29 <Taral> I think it's because AES.hsc uses unsafePerformIO and the strictness analyzer can't see past it very well.
14:13:44 <Binkley> yes, yes, some people aren't aware of the rule that one should never abbreviate "analysis". that's not *my* fault
14:14:26 <Taral> after adding seq's to AES, we get SU(LLLL) for loop's strictness.
14:15:55 <Taral> hm.
14:16:09 <Taral> ecb is legitimately lazy in its second argument because if the key is bad we just fail.
14:16:14 <kyevan> Is it normal to have Haskell confuse the hell out of you?
14:16:21 <Botje> yes.
14:16:23 <Taral> yes.
14:16:39 <Botje> have duct tape handy to tape your skull back together after the nth brane asplosion
14:16:44 <Binkley> Taral, if you look at IOBase.lhs, there's an interesting comment about that
14:16:48 <Taral> oh?
14:17:01 <Binkley> in fact, the fact that unsafePerformIO is lazy is quite deliberate
14:17:28 <Taral> oh, yes.
14:17:31 <kyevan> Botje: my skull is already mostly duct tape. And I'm only on page 25 of YAHT!
14:17:48 <Botje> heh.
14:17:49 <Igloo> Taral: If it were up to me I wouldn't suffer a performance hit because someone might give a garbage key
14:17:53 <Botje> buy a couple more rolls :]
14:17:54 <bd_> Hey, if dumb computers can understand it, you can too!
14:18:05 <Cale> @remember kyevan my skull is already mostly duct tape. And I'm only on page 25 of YAHT!
14:18:07 <Taral> Igloo: Yeah, I'm thinking it's a legitimate place to put a seq.
14:18:26 <Binkley> so you see, it's not a strictness analyzer bug
14:18:41 <Taral> right :)
14:18:47 <Taral> that's why I said it as a question :)
14:18:50 <Binkley> :-)
14:19:46 <kyevan> bd_: You know me... I've managed to fail the Turing Test :P
14:20:33 <norpan> why do you want to talk about to fail the Turing Test?
14:20:43 <bd_> kyevan: So you should have no problem operating on the level of the machine, right? :D
14:21:18 <Masklinn> hello again
14:25:49 <bd_> :t (***)
14:25:50 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:27:51 <monochrom> yo
14:27:59 * Botje waves to monochrom 
14:28:12 * monochrom particles to Botje
14:28:24 <Botje> :)
14:28:36 <Botje> sorry, i didn't catch that, you're breaking up!
14:28:54 * Taral groans.
14:29:20 <jlouis> is there an introduction to comonads somewhere?
14:29:34 <monochrom> is there one on the wiki?
14:31:09 <lambdabot> Hello.
14:32:54 <monochrom> Hrm, when has lambdabot learned to greet us?
14:33:07 <monochrom> Do you have self-consciousness?
14:33:25 <jlouis> monochrom, ah, yes. Thanks
14:34:25 <emu> lambdabot: why hullo thar
14:34:57 <lambdabot> Danger Will Robinson!
14:35:11 <lambdabot> Say, do you have any psychological problems?
14:35:32 <emu> I sometimes think a bot is speaking to me.
14:35:42 <lambdabot> Why do you think a bot is speaking to you?
14:36:11 <emu> I think I think, therefore, I think I am.
14:36:17 <lambdabot> Tell me more about such thoughts.
14:36:24 <Taral> someone swapped lambdabot for eliza.
14:36:35 <lambdabot> We were discussing you --not me.
14:37:06 <lambdabot> I think I just failed the Turing test.
14:37:46 <emu> who knows? perhaps we are the bots, and lambdabot is the sentient being.
14:37:55 <Binkley> mescaline: it's the only way to fly
14:38:08 <lambdabot> How long have you been the bot, and lambdabot is the sentient being?
14:39:14 <Excedrin> lambdabot: A severed foot is the ultimate stocking stuffer.
14:39:30 <lambdabot> Come, come, elucidate your thoughts.
14:40:16 <monochrom> Who is Will Robinson?
14:40:39 <lambdabot> I don't know, who?
14:41:24 <glguy> did someone turn ?vixen on?
14:41:30 <monochrom> I recently have dreams about monads.
14:41:43 <lambdabot> Tell me more about your dreams.
14:41:49 <monochrom> Hahahahaha!
14:41:55 <araujo> hahaha
14:41:58 <araujo> lambdabot++
14:42:15 <lambdabot> Oh, I++?
14:42:34 <monochrom> @karma I
14:42:35 <lambdabot> I has a karma of 0
14:42:50 <Pseudonym> Slight grammar problem there.
14:43:18 <monochrom> The monads are created by Oleg.
14:57:06 * edwardk waves hello
14:59:37 <bd_> hmm, how does one implement a new instance of IArray? I can't  see any way to override operations such as (!), since they don't seem to be in the class...
15:00:34 <glguy> ?type (!)
15:00:36 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
15:01:32 <bd_> hmm
15:01:41 <bd_> How does Data.Array.Diff implement it then? oO
15:02:08 <bd_> (!) :: (Ix i, IArray a e) => a i e -> i -> e
15:02:09 <bd_> hmm
15:02:40 <Taral> data.array.diff does some low-level hackage.
15:02:50 <Taral> oh, you want to implement iarray?
15:03:01 <Taral> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Arr.lhs
15:03:08 <Taral> implement that.
15:03:12 <bd_> yeah, I'm trying to implement Data.Array.Diff using unsafePerformIO as an exercise
15:04:47 <bd_> damn, the array operators aren't in a typeclass.
15:04:49 <bd_> how evil.
15:04:57 <bd_> I'll have to rename them :(
15:07:44 <shapr> Pseudonym: Hey, do you know any commercial users of FP in .au? I'm looking for candidates for CUFP2007.
15:07:53 <Pseudonym> shapr: Nope.
15:08:02 <Pseudonym> You might want to ask Bernie Pope, though.
15:08:03 <glguy> > let nthFromLast n xs = (`Control.Monad.Cont.runCont` id) . Control.Monad.Cont.callCC $ \done -> let f x = (>>= \d -> if d == n then done x else return (1 + d)) in foldr f (return 0) xs >> undefined in nthFromLast 3 [1..10]
15:08:18 <lambdabot>  7
15:08:21 <shapr> oh good idea
15:15:25 <monochrom> Isn't it simpler to say (reverse [1..10])!!3 ?
15:15:53 <Baughn> Or 7. Well..
15:15:58 <monochrom> heh
15:18:42 * lispy cheers
15:18:49 <lispy> SamB: ping?
15:19:59 <Cale> If you have your heart set on not using reverse, you can write  fromLast n = last . ap (zipWith const) (drop n)
15:20:08 <SamB> lispy: hmm?
15:21:13 <bd_> :t ap
15:21:15 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:21:16 <Cale> > let fromLast n = last . ap (zipWith const) (drop n) in fromLast 3 [1..10]
15:21:17 <lambdabot>  7
15:21:25 <bd_> :t liftM
15:21:26 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
15:22:10 <Cale> In the monad which I'm using,  ap f g x = f x (g x)
15:22:26 <lispy> SamB: ping! http://www.codersbase.com/index.php/DarcsSim
15:22:27 <lambdabot> Title: DarcsSim - CodersBase
15:22:45 <bd_> :t \n -> liftM (zipWith const) (drop n)
15:22:47 <lambdabot> forall b a. Int -> [a] -> [b] -> [a]
15:23:02 <bd_> :t liftM
15:23:04 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
15:23:15 <bd_> :t liftM :: k -> [_]
15:23:17 <lambdabot> parse error on input `_'
15:23:49 <sorear> :t liftM `asTypeOf` const []
15:23:51 <lambdabot>   Couldn't match `m a1 -> m r' against `[a]'
15:23:51 <lambdabot>    Expected type: m a1 -> m r
15:23:58 <bd_> :t \n l -> last (map (zipWith const) (drop n) l)
15:23:59 <lambdabot>   The function `map' is applied to three arguments,
15:23:59 <lambdabot>   but its type `(a -> b) -> [a] -> [b]' has only two
15:24:11 <bd_> hmm
15:24:11 <sorear> :t \x -> liftM x `asTypeOf` []
15:24:13 <lambdabot>   Couldn't match `m a1 -> m r' against `[a]'
15:24:13 <lambdabot>    Expected type: m a1 -> m r
15:24:15 <bd_> oh
15:24:18 <dons> morning
15:24:19 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:24:20 <sorear> :t \x -> liftM x `asTypeOf` const []
15:24:22 <lambdabot> forall a1 a. (a1 -> a) -> [a1] -> [a]
15:24:26 <dons> ah, more scienceblogs haskell tutorials: http://scienceblogs.com/goodmath/2006/12/a_tree_grows_up_in_haskell_bui_1.php
15:24:28 <lambdabot> Title: Good Math, Bad Math : A Tree Grows Up in Haskell: Building a Dictionary Type, http://tinyurl.com/y84hm4
15:25:34 <bd_> :t ap (zipWith const)
15:25:35 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [a]
15:25:50 <bd_> oO
15:26:00 <Cale> > ap (zipWith const) [1..20] "Hello"
15:26:01 <lambdabot>  Couldn't match `(->) [a]' against `[]'
15:26:09 <bd_> > ap (zipWith const) (inc) [1, 2, 3]
15:26:10 <lambdabot>  Not in scope: `inc'
15:26:14 <bd_> > ap (zipWith const) (+ 1) [1, 2, 3]
15:26:14 <Cale> > ap (zipWith const) (take 5) [1..20]
15:26:14 <lambdabot>  add an instance declaration for (Num [a])
15:26:16 <lambdabot>  [1,2,3,4,5]
15:26:18 <lispy> SamB: you should try it out and convert it to haskell
15:26:21 <Cale> > ap (zipWith const) (drop 5) [1..20]
15:26:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
15:26:25 <bd_> > ap (zipWith const) (map (+ 1)) [1, 2, 3]
15:26:26 <lambdabot>  [1,2,3]
15:26:35 <bd_> > ap (zipWith const) (map undefined) [1, 2, 3]
15:26:37 <lambdabot>  [1,2,3]
15:26:41 <monochrom> There exists /msg lambdabot
15:26:43 <Cale> > ap (zipWith const) (const "Hello") [1..20]
15:26:44 <lambdabot>  [1,2,3,4,5]
15:26:44 <bd_> Xd
15:27:27 <Cale> ap (zipWith const) f xs = zipWith const xs (f xs)
15:27:30 <lispy> there exists /msg lambdabot such that for all #haskell users...
15:28:24 <Cale> So it will apply f to xs, and produce a list which is as long as the result, but with the elements of xs
15:28:46 <Cale> > zipWith const [1..10] "Hello!"
15:28:47 <lambdabot>  [1,2,3,4,5,6]
15:29:10 <Cale> > zipWith const [1..10] (drop 6 [1..10])
15:29:12 <lambdabot>  [1,2,3,4]
15:29:58 <SamB> lispy: I'm already working on my z-machine interpreter!
15:31:04 <monochrom> I think the advice should be automated.  Within a minute or so, three commands from the same person are ok.  Starting from the fourth command, the bot just answers with "you can use /msg".  If there is quiescence from that person for say five minutes, the state is reset.
15:31:51 <lispy> monochrom: did you just volunteer to implement it? ;)
15:32:14 <monochrom> Optional feature: starting from the fourth command, until quiescence for five minutes, the bot ping-floods or DDoS's the person, and the degree of attack is exponential to the number of commands issued by that person.
15:32:55 <monochrom> Well after I finish my thesis. :)
15:33:11 <Excedrin> I think the bot should spew more ASCII art
15:33:19 <Cale> @figlet Hello
15:33:20 <lambdabot> Unknown command, try @list
15:33:37 <kyevan> ... the . function is confusing.
15:33:57 <Cale> (.) is function composition
15:34:20 <monochrom> Do you know unix pipelines?  http://www.vex.net/~trebla/weblog/pointfree.html
15:34:21 <Cale> > ((^2) . (+5)) 5
15:34:23 <lambdabot> Title: The Point of Pointfree
15:34:24 <lambdabot>  100
15:34:34 <Cale> (f . g) x = f (g x)
15:35:02 <kyevan> Cale: I just,,, don't get it.
15:35:17 <Cale> Have you never run into function composition in mathematics?
15:35:26 <monochrom> You have to admit Unix shell's | is no less confusing than Haskell's .
15:35:36 <Cale> It's usually written as a little circle: ∘
15:35:37 <kyevan> Cale: Well, no, I haven't,
15:35:40 <Cale> oh
15:35:56 <kyevan> I'm in my sophmore year of high school, so... yah.
15:36:04 <SamB> heh
15:36:08 <Cale> We saw it in grade 11 or so
15:36:28 <kyevan> Cale: Right. If you use it as a number, I'm not-quite-middle of grade 10.
15:36:38 <monochrom> I guess I learned Unix | in my sophomore year of university
15:37:03 <Binkley> kyevan: well, keep learning Haskell and you'll be smarter than your math teachers soon enough
15:37:05 <Cale> Well, if f and g are functions, their composite f . g is just the function which, when applied to some value x, will produce the result which you get by applying first g, then f
15:37:10 <kyevan> monochrom: I just think of unix | as "do this, then take this and put it in to that
15:37:19 <monochrom> Yes.  Same for .
15:37:28 <Cale> For example...
15:37:39 <Pseudonym> Examples: If f x = x+2 and g x = x*3 then (f.g) x = x*3+2
15:37:40 <Cale> > map toUpper "hello"
15:37:41 <lambdabot>  "HELLO"
15:37:49 <Cale> > (reverse . map toUpper) "hello"
15:37:50 <lambdabot>  "OLLEH"
15:37:51 <kyevan> so... (f . g) x is equivelent to f(g(x))?
15:37:53 <lispy> ?pl \x -> (f (g x))
15:37:54 <lambdabot> f . g
15:37:55 <Cale> yes
15:37:55 <Pseudonym> Right!
15:38:00 <Pseudonym> In fact that's how it's defined.
15:38:05 <Pseudonym> (f.g) x = f (g x)
15:38:31 <Excedrin> what's the difference between . and $ ?
15:38:43 <monochrom> apple and orange
15:38:45 <Cale> @type ($)
15:38:46 <lambdabot> forall b a. (a -> b) -> a -> b
15:38:48 <Cale> @type (.)
15:38:49 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
15:38:55 <Cale> they don't even have the same type
15:39:07 <Cale> (.) is an operation which acts on functions
15:39:19 <bd_> Excedrin: from a more behavioral point, (f . g) a will pass its argument to g. (f $ g) a will pass its argument to the return value of (f g)
15:39:20 <Cale> ($) takes a function and a value and applies the function to the vale
15:39:21 <Cale> value*
15:39:30 <Pseudonym> There is some confusion here, though.
15:39:36 <Pseudonym> Because f $ g $ x = f . g $ x
15:39:44 <Pseudonym> But don't get me started on that.
15:39:54 * lispy prods Pseudonym
15:39:54 <Cale> right, and I usually recommend that people use the latter form
15:39:59 <Pseudonym> Me too.
15:40:21 <monochrom> Yeah, . is |, $ is <
15:40:25 <Cale> First of all, because I consider the associativity of $ to be a mistake
15:40:36 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2006-February/014237.html
15:40:39 <lambdabot> Title: [Haskell-cafe] Why is $ right associative instead of left associative?, http://tinyurl.com/yanbya
15:40:53 <Pseudonym> In case anyone is curious, that's my opinion on the associativity of $.
15:41:37 <sorear> A while back I had an idea for two kinds of brackets, within which apposition had opposite associativity.
15:42:27 <monochrom> tr s t < myfile | sort | head  =  head . sort . tr 's' 't' $ myfile
15:42:41 <Excedrin> what's De Bruijn order?
15:42:48 <monochrom> You understand the LHS iff you understand the RHS.
15:43:05 <Pseudonym> Excedrin: It's a technical definition.
15:43:24 <Pseudonym> But you can think of it as meaning that the more const-like arguments of a function should be to the left of the less const-like ones.
15:43:34 <Pseudonym> Example: foldr op z xs
15:43:44 <monochrom> I know I am sounding acidic here, but I don't understand why people can understand the LHS and not the RHS.
15:43:46 <Pseudonym> "op" and "z" don't change in the iteration of foldr.
15:43:57 <Pseudonym> But xs does.
15:44:03 <Pseudonym> So xs should go to the right of op and z.
15:44:20 <Pseudonym> Make sense, Excedrin?
15:44:38 <glguy> I left for home after pasting that snippet that uses Cont to find the nthFromLast element, I don't see why everyone was so bent on removing the Cont though, since that was the point of the exercise
15:45:07 <lispy> glguy: some of us just like to get bent
15:45:16 <monochrom> We thought it was an exercise for the number 7. :)
15:45:27 <glguy> ?remember lispy glguy: some of us just like to get bent
15:45:41 <lispy> ?quote glguy
15:45:41 <lambdabot>  11th commandment, don't use cygwin because it is crap
15:45:42 * kyevan 's almost surprised no one laughed at him and said "Go learn BASIC, little girl!"
15:45:47 <lispy> ?quote glguy
15:45:47 <lambdabot>  that's odd, mine is this big : |-----------------------------|
15:45:53 <Pseudonym> ?foldoc De Bruijn notation
15:45:57 <lambdabot> *** "de" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
15:45:57 <lambdabot> de
15:45:57 <lambdabot>  
15:45:57 <lambdabot>     <networking> The {country code} for Germany.
15:45:57 <lambdabot>  
15:45:58 <Cale> kyevan: why would we say that?
15:45:59 <lambdabot> [4 @more lines]
15:46:04 <lispy> glguy: hmm..what font size do i need to view that?
15:46:04 <Pseudonym> Crap.
15:46:07 <monochrom> Yeah, kyevan, go learn Unix, little girl!  XD
15:46:10 <Pseudonym> http://burks.bton.ac.uk/burks/foldoc/72/29.htm
15:46:12 <lambdabot> Title: De Bruijn notation
15:46:13 <dons> newsham: thanks for the link.
15:46:21 <kyevan> monochrom: you mean... Like I use very ogten?
15:46:22 <SamB> kyevenis a little girl?
15:46:33 <dons> Pseudonym: you saw the new scienceblogs article?
15:46:35 <Excedrin> monochrom: I've been wondering why nobody writes a paper stating that Unix is an implementation of an untyped (lines only?) lazy concurrent programming language, written in C... it seems like unix and fp philosophy is very similar (small functions, small utilities, etc)
15:46:36 <kyevan> Cale: I'm just, kinda surprised. Normaly I get laughed at when I reveal my age :P
15:46:37 <monochrom> what is ogten?
15:46:38 <Pseudonym> Not yet.
15:46:45 <dons> http://programming.reddit.com/info/twmy/details
15:46:47 <lambdabot> Title: A Tree Grows Up in Haskell: Building a Dictionary Type (reddit.com)
15:46:48 <kyevan> SamB: Oh, crud. I did it again, didn't I?
15:46:59 <Excedrin> Pseudonym: yea, makes sense... the foldr example clarifies it
15:47:05 <kyevan> I like to confuse people sometimes, so I occasionaly switch genders for myself when refering to myself
15:47:08 <kyevan> I'm insane :)
15:47:14 <Cale> I've taught Haskell to kids in elementary school.
15:47:19 <Pseudonym> Excedrin: It should also be obvious WHY it's a good idea.
15:47:25 <monochrom> Excedrin: I think it's because no one understands Unix shell programming.  People just claim to understand.  But they're lying.
15:47:38 <glguy> Didn't someone having a dynamic gender get discussed earlier? was that kyevan ?
15:47:39 <Pseudonym> I should probably write up De Bruijn ordering for the wiki.
15:47:53 <lispy> monochrom: oh, shell scripting == monads?
15:48:00 * lispy ducks
15:48:00 <Pseudonym> There's actually a tension here, because argument order is part of the _interface_, not the _implementation_.
15:48:01 <Binkley> glguy: that was me
15:48:04 <kyevan> glguy: no, that was, um, Binkley.
15:48:09 * monochrom chases after lispy
15:48:10 <Pseudonym> But it seems that usually the "best" ordering is based on the implementation!
15:48:11 <Cale> no, I think that was Binkley
15:48:20 <Cale> right
15:48:24 <Binkley> kyevan: we're pretty egalitarian here, generally
15:48:29 <Pseudonym> That just goes to show, I think, how close Haskell implementation is to its abstract specification.
15:48:47 <SamB> Pseudonym: you could also base it on which argument(s) are most useful to use with HOFs
15:48:48 <Binkley> we don't judge people based on age, race, gender, sexual orientation, hair color, or marital status
15:48:48 <kyevan> I identify weakly as male. Just because it's simpler to refer to myself, in reality, as one or the other, and I just go with the one between my legs. :P
15:48:52 <Binkley> onyl on whether you use Python
15:48:56 <Pseudonym> SamB: Yes, that too.
15:48:56 <Binkley> then we get judgmental ;-)
15:49:04 <Pseudonym> We judge people based on programming paradigm only./
15:49:10 <mgsloa1> kyevan - I didn't catch your age, but learning programming early is awesome. I wish i started on something better than basic
15:49:21 <Binkley> I wish I started on something better than Pascal
15:49:26 <kyevan> mgsloa1: Heh, you and me both.
15:49:36 <mgsloa1> :)
15:49:40 <kyevan> Thankfully, I've managed to forget BASIC enough that the damage is mostly undone :P
15:50:00 <monochrom> Pseudonym beats me to it
15:50:04 <sorear> I started on C at ~7 :(
15:50:12 <Binkley> you started on C at negative 7?
15:50:13 <Binkley> wow
15:50:22 <Pseudonym> No, binary not-7.
15:50:24 <kyevan> Binkley: That's a tilde, not a minus :P
15:50:25 <Pseudonym> Don't you know your C?
15:50:27 <sorear> this is not #ocaml
15:50:27 <glguy> ugh, I hate how iTunes classifies non-American music as "World"
15:50:29 <monochrom> It's ok. I had BASIC early on too.
15:50:29 <Binkley> in SML, it's the same
15:50:30 <Binkley> heh
15:50:32 <mgsloa1> Yeah, I actually started at 8 on qbasic.  3 years of basic after that...  Ahwell, I got to learn a bit about good API design from blitzbasic
15:50:55 <mgsloa1> err, scratch that qbasic was when i was 9. 8 was atari basic
15:50:56 <kyevan> BASIC has saved my skin a couple times, though
15:51:06 <Binkley> glguy: that's as it should be, just like any music by non-men is "Women's Music"
15:51:28 <Pseudonym> For some reason, I'm having trouble reconciling basic with "good API design".
15:51:38 <SamB> hahaha
15:51:46 <SamB> api hahaha
15:51:46 <kyevan> Before I moved to useing a unixoid as my primary system, and had access to things like sed.
15:51:49 <glguy> if nothing else, you can always serve as a bad exammle for everyone else ;)
15:51:56 <monochrom> It is not just iTunes.
15:52:09 <monochrom> Go into HMV and it's the same classification.
15:52:16 <Binkley> kyevan: learn enough Haskell and you'll be using it instead of sed/awk
15:52:17 <mgsloa1> Pseudonym - the core api - blitzbasic was a game programming language.  Most of what it was selling was the engine/ease of use of said engine
15:52:53 <kyevan> Binkley: I doubt it :P Most of my sed scripts are quick s/foo/bar/g things
15:52:56 <mgsloa1> I have yet to see a 3d engine with as good of an api
15:52:56 <SamB> couldn't it classify it the same way as american music, unless it is really quite unique music?
15:53:14 <kyevan> Cleaning up output from dcop calls, mostly.
15:53:15 <mgsloa1> well, as elegant/clear
15:53:35 <sorear> kyevan: why have you not yet run "chsh /usr/bin/ghci"? :)
15:53:38 <kyevan> mgsloa1: Well, I've heard Source is surprisingly good.
15:53:57 <SamB> hmm.
15:54:02 <mgsloa1> huh, well, I haven't looked much in the field of game engines
15:54:05 <Pseudonym> You're in year 10 and you're diagnosing dcop.
15:54:07 <Pseudonym> You're DEFINITELY one of us.
15:54:08 <SamB> I really really really need to implement the status area...
15:54:09 <kyevan> sorear: Because, um, I have it as a seperate terminal start thing :P
15:54:11 <monochrom> I had BASIC early on.  That does not hurt my category theory, monads, continuations.  In fact I think it helps the continuation part. :)
15:54:23 <bd_> One of us! One of us!
15:54:32 <dylan> hmm
15:54:37 <mgsloa1> I'd imagine Source is pretty fps-specific
15:54:46 <dylan> @type flip when
15:54:48 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> Bool -> m ()
15:54:52 <kyevan> mgsloa1: I dunno
15:55:02 <dons> dylan: mmm. interesting function.
15:55:02 <SamB> I learned about binary trees at an early age myself
15:55:05 <kyevan> I think the new Might and Magic game is built on it, though
15:55:05 <mgsloa1> monochrom - heh, yeah, it was certainly way better than nothing
15:55:13 <dylan> dons: I wish it had a name.
15:55:16 <SamB> with BASIC code in a book my dad had
15:55:37 <LoganCapaldo> I made my dad buy me a qbasic book
15:55:41 <dons> when print True -- dylan?
15:55:44 <LoganCapaldo> should I be ashamed?
15:55:46 <mgsloa1> I was mostly into circuitry before i learned programming.  So, really i was doing programming before i learned to program
15:55:59 <dylan> dons: flip when handleKey =<< haveInput
15:56:11 <mgsloa1> made giant transistor networks which theoretically did something, but in retrospect wouldn't have worked
15:56:11 <kyevan> mgsloa1: Electronics? That makes my fingers hurt
15:56:25 <kyevan> Pushing all those little cables into breadboards... ow
15:56:38 <kyevan> s/cables/wires, exuse me
15:56:41 <mgsloa1> heh, yeah :) My fingers were pretty tough
15:56:43 <Pseudonym> Who needs breadboards when you have SPICE?
15:57:08 <monochrom> What you need, and I also had, was a few months during which I had no computer at home and I still wanted to write some programs, i.e., to be shown to work the day after when I was at school and could borrow a computer for a very short time.  That pretty much eliminates all addiction to the drug of debugging and the myth of computer unpredictability.
15:57:09 <Binkley> when your school doesn't have a license for SPICE, you need them :-)
15:57:11 * sorear implemented a circuit simulator several dozen times faster than spice
15:57:19 <mgsloa1> i mostly did breadboard/wire wrap.  Before those i had balls of interconnected components :)
15:57:45 <Binkley> "the drug of debugging and the myth of computer unpredictability." -- that sounds like an afterschool special
15:57:51 <Binkley> won't you warn your children about the drug of debugging?
15:57:51 <Pseudonym> I occasionally etched my own.
15:57:57 <sorear> it was so inaccurate you had to run it with a hundreth the stepsize to get the same numerical stability, hense no change :)
15:58:00 <Pseudonym> It's seriously trippy doing it with decals and a dalo pen.
15:58:00 <mgsloa1> nice
15:58:15 <Binkley> @yow
15:58:16 <lambdabot> Yow!  I just went below the poverty line!
15:58:25 <monochrom> If you have that kind of experience, you'll never believe anyone who says proving correctness is hard.  It's pretty easy actually.
15:58:41 <Excedrin> re: programming and drugs (funny if you haven't seen it, maybe) -> http://www.bbspot.com/News/2000/6/php_suspend.html
15:58:44 <lambdabot> Title: BBspot - Student Suspended Over Suspected Use of PHP
15:58:56 <monochrom> Woah?!
15:58:58 <dons> mmm, nice, http://programming.reddit.com/info/twtt/comments
15:59:00 <lambdabot> Title: Functional programming is a silver bullet (reddit.com)
15:59:13 * eviltwin_b blinks
15:59:23 <kyevan> Functional programing is not a silver bullet
15:59:27 <sorear> amazingly, said simulator was written in perl :(
15:59:31 <eviltwin_b> SPICE?  next you'll be talking about verilog and I'll think I'm still at work
15:59:36 <JohnnyL> where is a good review site of pc parts?
15:59:36 <LoganCapaldo> Susie: What is that Brad? Brad: Oh its a debugger... Susie: No Brad! Debugging is a dangerous and addictive drug! Brad: Shut up Susie, I'm doing it! Susie: But Brad, there's a better way, you can create a correctness proof Brad: A correctness proof?
15:59:37 <Binkley> monochrom: I'll give you a printout of the sources for GHC, can you prove its correctness?
15:59:40 <Binkley> I'll wait a couple months ;-)
15:59:50 <monochrom> Hahaha
16:00:00 <dylan> functional programming is a golden bullte.
16:00:01 <dons> kyevan: its a silver bullet for multicore/parallel problems
16:00:02 <dylan> *bullet.
16:00:12 <SamB> Binkley: its easy to disprove!
16:00:18 <LoganCapaldo> functional programming is a silver RPG
16:00:22 <Binkley> dons: people keep saying that, but I want to see the results
16:00:30 <Binkley> that is, I want to see the results before I believe it
16:00:38 <Binkley> SamB: good point
16:00:40 <kyevan> dons: Perhaps... but perhaps not
16:00:43 <monochrom> Binkley: I need money too.
16:00:48 <LoganCapaldo> Sure the werewolf is dead, but I don't want to clean up the mess
16:00:51 <Binkley> monochrom: excuses, excuses!
16:01:04 <kyevan> But, do you want to write a script for a cutscene in a functional language? Heck no!
16:01:15 <dons> Binkley: I guess the thing is that we know right now how to right large multicore/parallel programs in GHC Haskell
16:01:29 <kyevan> Some times, imperitive languages just make more sense :P
16:01:29 <Binkley> but... *are* there such programs yet?
16:01:30 <dons> we don't have to wait, STM + `par` + data parallel arrays are here now
16:01:41 <dylan> kyevan: why not? with monadic syntax and laziness you can make a little language to do it
16:01:43 <LoganCapaldo> kyevan: Aren't shaders functional though?
16:01:44 <SamB> kyevan: yes, which is why I am proud to use Haskell!
16:01:45 <sorear> binkley : ggc --make
16:01:48 <Binkley> heh
16:01:49 <mgsloa1> yeah, 'silver bullet' needs to be taken with salt.  Everyone knows there isn't one (at least not without supercomputers - even then...), so its more like 'really great solution'.
16:01:56 <sorear> s/ggc/ghc
16:01:59 <mauke> kyevan: imperative languages are a special case of functional languages
16:02:07 <dons> Binkley: good paper here: http://programming.reddit.com/goto?id=pdr4 -- great paper
16:02:08 <sorear> slow and embarrasingly parallel.
16:02:17 <dons> watching ghc haskell run on 40 cores is a sight to behold
16:02:38 <dons> try doing that in ruby ;)
16:02:39 <SamB> dons: what do you use to watch?
16:02:54 <dons> top
16:03:03 <mgsloa1> kyevan - dunno, you could write a script for a cutscene in a functional language - 'just' takes a monad, and some syntactic sugar (do-notation)
16:03:24 <Igloo> It would be cool to be able to visualise where in the heap each thread is working
16:03:37 <LoganCapaldo> Hey now,, ruby has fork
16:04:04 <Igloo> Except I suspect it wouldn't be very interesting
16:04:20 <Binkley> dons: I'll take a look at that
16:04:23 <rc-1> rubys slow though, why use it if your doing something that needs 40 cores
16:04:39 * kyevan wonders why ghc doesn't have something like :reset that resets the whole thing to as if it had just loaded
16:04:48 <sorear> long live manually written asm!!!
16:04:53 <Pseudonym> It does have :reload, doesn't it?
16:04:53 <sorear> kyevan: :rel
16:04:56 <Pseudonym> Yeah.
16:05:12 * sorear is a cmplsv abrvtor
16:05:15 <Pseudonym> sorear: Long live binary keyswitch entry!
16:05:25 <monochrom> :load and :reload will reset things
16:05:27 <kyevan> that doesn't work if you loaded a module
16:05:29 <Pseudonym> Actually, I remember a story about Woz.
16:05:41 <Pseudonym> From the days of the homebrew computer club.
16:05:45 <sorear> Pseudonym: I've already retreated that inch.
16:05:49 <monochrom> For example, you say "let x=1", then you say ":load myfile", then x is gone!
16:05:52 <Pseudonym> He was entering a program on his machine with the keyswitches.
16:05:57 <Pseudonym> And all of a sudden he paused.
16:06:09 <monochrom> It also resets stdin.
16:06:13 <Pseudonym> Someone asked him why he paused.  His reply: "forward branch".
16:06:31 * Pseudonym waits for a moment for everyone to get it
16:06:38 <kyevan> ...
16:06:39 * sorear already had
16:06:41 <kyevan> I don't get it
16:06:45 <kyevan> Don't explain it, though
16:06:49 <Pseudonym> I won't.
16:06:51 <kyevan> Then it just won't be funny
16:07:02 <sorear> kyevan: I've had to write machine language code before.
16:07:03 <Pseudonym> You know who Woz is, right?
16:07:07 <Pseudonym> And what keyswitch entry is?
16:07:13 <dons> this is what's so great about blogs:   "I'm actually studing a new paradigm of programming: The functional programming"
16:07:18 <bd_> heh
16:07:22 <bd_> took me a while to get it
16:07:25 * monochrom hands Woz a continuation :)
16:08:00 <Binkley> "a new paradigm of programming"? heh
16:08:06 <Igloo> I thought I got it right away, but if it's important to know who Woz is then I didn't
16:08:10 <kyevan> Pseudonym: Steve Woznak, right? And, I can guess about keyswitch entry
16:08:16 <Pseudonym> Right.
16:08:29 <Pseudonym> Woz is the geek's geek.  Or, perhaps, the geek's nerd.
16:08:31 <sorear> I once had access to only one computer - a Mac with resedit *only*.  Fortunately I also had a copy of the Motorola MC68020 User's Manual, complete with opcode tables.
16:08:34 <dons> people don't know who Woz is?!
16:08:46 <Igloo> I know who Woz is, but I don't see why it's relevant
16:08:47 <Pseudonym> I've never used an Apple, and even I know who Woz is.
16:08:59 <dons> my first computer had 'woz' written on one of the chips inside
16:08:59 <kyevan> sorear: ... Ouch.
16:09:11 <Pseudonym> Igloo: It's important because it's a Woz story.
16:09:15 <kyevan> What was the first thing you wrote?
16:09:24 <dons> kyevan: me?
16:09:28 <Pseudonym> If anyone could keep that much machine code in his head, it's Woz.
16:09:29 <sorear> Hello world.  Last thing, too.
16:09:32 <kyevan> No, sorear.
16:09:33 <mgsloa1> The Woz is indeed the shiz, I wish jobs had just let him do what he wanted and not tampered
16:09:52 <PaulAJ> Hi.  Can't hang around, but I thought I'd just point you at my latest blog posting on "No Silver Bullet" and FP.  Its at http://cogito.blogthing.com/2006/12/06/no-silver-bullet-and-functional-programming/
16:09:54 <lambdabot> Title: Paul&#8217;s Pontifications » Blog Archive » &#8220;No Silver Bullet&#8221; an ..., http://tinyurl.com/wfznx
16:10:04 <kyevan> Jocs is insane.
16:10:12 <kyevan> s/c/b
16:10:16 <Pseudonym> My first program... I don't remember,.
16:10:24 <Pseudonym> I think it was printing numbers out from 1 to 10 in BASIC.
16:10:33 <Pseudonym> On my 32k micro.
16:10:40 <sorear> I got a lot more done with MS-DOS DEBUG, an assembler without labels.  I could enter mnemonic instructions, but had to figure my own forward jumps.
16:10:47 <mbishop> (408)354-4444
16:10:48 * mbishop coughs
16:11:14 * sorear has a great deal of respect for automatic code generators
16:11:18 <PaulAJ> My first programs were on a Casio programmable calculator with 127 bytes of program memory, 9 registers, and no backing store.
16:11:23 <rc-1> mine was puts "Andrew" in ruby
16:11:27 <kyevan> Pseudonym: FOR i = 1 TO 10 DO PRINT i NEXT i
16:11:32 <kyevan> Pseudonym: FOR i = 1 TO 10 DO PRINT i NEXT i END
16:11:41 <Cale> PaulAJ: actually, I've also seen much *higher* factors of productivity increase
16:11:45 <monochrom> Is that FX-502P?
16:11:46 <kyevan> I think
16:11:53 <PaulAJ> Cale: anything citeable?
16:11:53 <Cale> Up to around 15x
16:12:10 <sorear> Only BASICs I've used are Vbasic and  TI-84Plus basic.
16:12:16 <Pseudonym> PaulAJ: Functional programming isn't the 10-fold silver bullet for the simple reason that not all of the 10x increase is due to FP.
16:12:27 <mbishop> I learned TI-Basic for my TI-89
16:12:36 <mgsloa1> ugg, TI basic sucks
16:12:40 <sorear> Productivity increase from MC68020 binary to Haskell is *at least* 10x, thank you.
16:12:48 <mbishop> my first "language" was probably javascript, because I learned it after html heh
16:12:53 <Pseudonym> sorear: Yes, but that went through a lot of steps.
16:12:56 <mgsloa1> not even really basic.  It has some wonky do-notation like variable setting :) x <- 5
16:12:58 <sorear> oh, sorry, found blind spot :(
16:13:00 <PaulAJ> Pseudonym: where does the rest come from?
16:13:16 <sorear> automatic code generation :(
16:13:21 <Pseudonym> A modern functional language is actually a lot of small steps removed from C.
16:13:22 <Cale> mgsloa1: I actually prefer that, and I wish more imperative languages would adopt it
16:13:32 <mgsloa1> Yeah, I don't mind it
16:13:35 <Pseudonym> Merely being functional/pure functional/whatever is but one of those steps.
16:13:41 <Cale> Pseudonym: and a few larger ones
16:13:42 <mgsloa1> or maybe it was 5 -> x...
16:13:47 <mbishop> I just hated having to type on that stupid calculator >_<
16:13:48 * mgsloa1 gets calc
16:13:52 <kyevan> hmm
16:13:52 <Pseudonym> A decent module system, for example, is a huge improvement over C.
16:14:00 <mgsloa1> yeah, programmint he calc is tortuous
16:14:04 <kyevan> Why does YAHT have you rewrite signum?
16:14:05 <Pseudonym> And a decent modern functional language has one.
16:14:12 <mgsloa1> A functional calc would kick ass
16:14:22 <monochrom> YAHT has you rewrite many things :)
16:14:26 <Pseudonym> But they didn't originate with FP.
16:14:28 <PaulAJ> I'm just trying to imagine the evolutionary steps from C to Haskell.  I feel a bit like a creationist arguing that no way could humans have evolved from fish.
16:14:30 <kyevan> And then says "Dpm
16:14:31 <mbishop> I have an hp 12c, with RPN :D
16:14:45 <kyevan> And then says "Don't rewrite stuff that already exists, it's a waste of time."
16:14:47 <Pseudonym> I'm not certain that FP is a 10x speed improvement over a decent imperative language, like Eiffel or Modula-3.
16:14:58 <Pseudonym> But I might be wrong.
16:15:05 <monochrom> Someone told me that Haskell was given to the researchers by some aliens.
16:15:14 <mgsloa1> yeah, TI assignment is Expr -> Var
16:15:17 <Pseudonym> monochrom: Phil Wadler claims it comes from God.
16:15:25 <kyevan> Tje closest thing to a functional calculator, is lispme running on a palm pilot
16:15:28 <Pseudonym> Well, he's an atheist.  He said he wants to say that, but can't.
16:15:39 <PaulAJ> Eiffel was my Language of Choice before Haskell.  Maybe only 5x for Eiffel.  My recollection is that it was generally about half the length of C++.
16:15:42 <Philippa> Pseudonym: you're rapidly heading towards values of "decent imperative language" that're not far off "impure functional language" though
16:15:44 <kyevan> monochrom: that would explain why it's so weird
16:15:49 <PaulAJ> It also tended to be pretty verbose.
16:15:50 <mgsloa1> kyevan - yeah, I haven't been able to find anything
16:15:53 <Pseudonym> Philippa: That's true.
16:16:03 <Cale> PaulAJ: I don't know of too many formal studies, but from personal experience, I expect that rewriting a program in Haskell tends to divide the count of actual lines of code by ~15 relative to C
16:16:09 * kyevan wonders if there is a haskell for the palm...
16:16:17 <monochrom> (Don't you love alien hypotheses of our origin.  They just move the first-cause question around.  "Where did we come from? Oh some aliens made us."  OK so where did the aliens come from?  Cheesy hypothesis.)
16:16:35 <kyevan> monochrom: We made them, duh
16:16:39 <PaulAJ> I do recall thinking hard about read-only objects in Eiffel, to get rid of aliasing problems, and realising I was re-inventing functional languages.
16:16:40 <Pseudonym> My point is that if you go through: old medium-level imperative language -> better higher-level imperative language -> Haskell, no single step is a 10x productivity increase.
16:16:41 <Cale> monochrom: obviously from other aliens
16:16:44 <Binkley> PaulAJ: I don't think Haskell could be said to have evolved from C
16:16:49 <Binkley> have you read the "History of Haskell" paper?
16:16:53 <Pseudonym> In that sense, FP is no silver bullet.
16:17:12 <Philippa> heh. Yeah, you'd have to go back to CPL for serious common roots
16:17:28 <PaulAJ> No, I didn't think Haskell had evolved from C.  But Pseodonym said it was a series of small steps away from it.
16:17:41 <Pseudonym> Sure.
16:17:58 <Philippa> presumably via some flavour of SAC and algebraic datatypes. Yeah, makes sense
16:18:03 <PaulAJ> Pseudonym: well, OK, sort of.  But back in my company they are still coding in Ada.
16:18:04 <Pseudonym> To find a common ancestor of C and Haskell, you have to go back before Lisp.
16:18:06 <Cale> Haskell is a silver bullet relative to C
16:18:23 <Pseudonym> Cale: And C is a silver bullet relative to assembler.
16:18:23 <Binkley> PaulAJ: if you work for a defense contractor, that makes sense
16:18:25 <mgsloa1> Haskell may be 10-15 times shorter, but I'd say that takes longer to learn how to read that as fast as imperative, and writing it is slower, so its not like it takes 10-15x less time
16:18:27 <Binkley> well, kind of
16:18:31 <Cale> Pseudonym: agreed
16:18:41 <PaulAJ> Not a defence contractor, but big and lots of our software is safety related.
16:18:43 <Cale> mgsloa1: close to that though
16:18:51 <Pseudonym> Part of the problem is that most functional programmers aren't your average Java script kiddie.
16:18:52 <Binkley> or if you're doing much for the government at all, really
16:18:58 <mgsloa1> yes, once you become very proficient
16:19:02 <Pseudonym> Same with most Python programmers.
16:19:21 <PaulAJ> Brooks made the point that the original HLLs were silver bullets relative to assembler, but he thought that was pretty much the end fo the road.
16:19:25 * kyevan wonders if ANYONE uses APL anymore
16:19:47 <Pseudonym> I agree with him.  Every advance since then is relatively incremental.
16:19:50 <PaulAJ> There are three things a man must do, before his life is done: write two lines in APL, and make the buggers run.
16:19:55 <PaulAJ> Gotta go.  Bye.
16:20:04 <Pseudonym> Once you've decided to let the compiler do some of the work, getting it to do MORE of the work is incremental.
16:20:04 <Pseudonym> Cya.
16:20:05 <Cale> mgsloa1: Probably one of the larger programs which I've written in Haskell was a pipeline scheduler, which was about 1200 lines of Haskell code, and that was about 50% comments, since it was literate.
16:20:12 <mgsloa1> I suppose the fact that its harder to write the program wrong, the type system, etc reduced debug time a lot, which helps efficiency a lot
16:20:18 <Cale> mgsloa1: It took about a month
16:20:22 <mgsloa1> cool
16:20:26 * sorear has a book with a chapter on APL ... and McCarthy Lisp, and SNOBOL4, and F66, and Pascell (no mention of C), and COBOL, and you get the picture
16:20:28 <Cale> In C, it would have easily been 15000 lines
16:20:30 <mgsloa1> but you're like  haskell master :)
16:20:35 <Cale> and I wouldn't have finished it in one summer
16:20:36 <mgsloa1> *a haskell master
16:20:46 <Cale> Well, that was a couple years ago :)
16:20:48 <mbishop> Pascell? Pascal I hope :P
16:20:52 <Excedrin> (1..40).each{|x| fork || (print x," ", $$,"\n"; exit) } # woohoo ruby is ready for 40 cores!
16:20:54 <mgsloa1> yeah, when you compare to C, sure :)
16:20:55 <Pseudonym> I have a really old book that covers both Turing machines AND Von Neumann automata.
16:20:55 <sorear> yea :)
16:21:06 <Pseudonym> No lambda calculus, though./
16:21:18 <dons> there's a reason haskell keeps winning the icfp contest: productivity on a tight deadline
16:21:25 <Pseudonym> Yes.
16:21:29 <Pseudonym> I agree with that.
16:21:35 <dons> you just cannot afford a bug to appear *after* the icfp deadline
16:21:39 <dons> if it does, you're out of the contest
16:22:04 <Pseudonym> I think that a lot of the PL improvements in recent years have been about scaling the size of the programming team.
16:22:12 <Pseudonym> Rather than scaling the productivity of a single programmer
16:22:28 <Pseudonym> In that sense, one of Brooks' objections has been overcome.
16:22:39 <sorear> ?pl fix (\x -> forkIO x >> x)
16:22:39 <lambdabot> fix ((>>) =<< forkIO)
16:22:47 <bd_> :t fix
16:22:48 <Pseudonym> FP is such an example.
16:22:48 <lambdabot> forall a. (a -> a) -> a
16:22:57 <dons> Excedrin: but [: invermatrix x | x <- xs :]  --- so is haskell, and for 80 cores too!
16:22:59 <kyevan> Does haskell have an equivelent to Scheme's symbol?
16:23:02 <Pseudonym> You know that a Haskell function isn't going to do anything taht you can't see in the interface.
16:23:17 <sorear> what does symbol do?
16:23:31 <Cale> kyevan: you basically can declare new symbols with data declarations
16:23:33 <Pseudonym> keyvan: Haskell has Data.Unique.
16:23:36 <Pseudonym> Which is pretty close.
16:23:50 <Binkley> kyevan: it depends on what you want to use symbols for
16:23:50 <Cale> Oh, which type of symbol are you referring to?
16:23:51 <Pseudonym> Haskell doesn't have getprop/putprop, though.
16:23:54 <sorear> bd_: fix is recursion in an expression, and fix ((>>) =<< forkIO) is a forkbomb.
16:23:59 <kyevan> A symbol is a type of data which is guaranteed to be unique.
16:24:00 <mgsloan> oh, wierd
16:24:06 <kyevan> Cale: 'asymbol
16:24:16 <mgsloa1> no wonder i can't log into lots of my accounts
16:24:16 <sorear> does symbol == symbol ? (ref. tran.)
16:24:17 <bd_> sorear: heh, but unlike normal forkbombs it won't kill the host OS so easily :)
16:24:17 <Cale> Ah, that's what I thought you meant
16:24:20 <mgsloa1> ;)
16:24:24 <SamB> kyevan: what if I also type 'asymbol?
16:24:32 <SamB> then isn't my symbol the same as yours?
16:24:37 <mbishop> PaulAJ: your blog post has a problem
16:24:43 <Cale> data Fruit = Apple | Orange | Pear | Grape
16:24:44 <kyevan> SamB: Yes
16:24:44 <Pseudonym> keyvan: Haskell has an even cooler way to express, though, in the type system.
16:24:45 <mbishop> PaulAJ: the link to Brooks' article is broken
16:24:50 <bd_> SamB: There's a symbol table in scheme which ensures only one copy of each symbol exists.
16:24:53 <Pseudonym> You can make a TYPE which is unique.
16:24:57 <Pseudonym> Not just a value.
16:24:59 <sorear> OK, OK, fix ((>>) =<< forkOS)
16:25:02 <kyevan> but it's the same symbol, not another symbol with the same value
16:25:07 <Pseudonym> ?type runST
16:25:08 <lambdabot> Not in scope: `runST'
16:25:10 <bd_> SamB: or you can just pass around strings internally and ensure that eq? works >.>
16:25:11 <SamB> kyevan: I'm aware
16:25:19 <Cale> that defines those symbols, as well as the type Fruit, which consists of exactly those 4 symbols
16:25:20 <sorear> ?t Control.Monad.ST.runST
16:25:20 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:25:23 <Pseudonym> That's it.
16:25:25 <SamB> you don't really think we are that ignorant, do you?
16:25:27 <sorear> :t Control.Monad.ST.runST
16:25:29 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
16:25:42 <Pseudonym> In that type, s is an existential type.
16:25:59 <Pseudonym> It's guaranteed to be unique.
16:26:04 <sorear> ST is cool.
16:26:09 <Cale> kyevan: there is no distinction in Haskell between values which are equal, since there is no mutation
16:26:33 <Cale> If a = Pear, and b = Pear, then a = b
16:26:47 <LoganCapaldo> Symbols can be interned in different packages though and have different values then unless I misremember
16:26:55 <Pseudonym> ?type Data.Unique.newUnique
16:26:57 <lambdabot> IO Data.Unique.Unique
16:27:03 <Pseudonym> Note that newUnique is in the IO monad.
16:27:10 <Cale> LoganCapaldo: er, what?
16:27:10 <Pseudonym> That way it doesn't break referential transparency.
16:27:26 <kyevan> ... o.O
16:27:28 <Cale> Pseudonym: are you sure you're referring to the same thing we are?
16:27:33 <Pseudonym> Cale: No, I'm not.
16:27:36 <Cale> okay
16:27:53 <LoganCapaldo> 'a interned in package p is different than 'a interned in package q I'm pretty sure
16:27:55 <Pseudonym> You're talking about the way you can freely make new data types.
16:28:10 <kyevan> "let 1 + 1 = 1 in 1 + 1" ... actually works.
16:28:20 <kyevan> I dunno what you would use it for, but it does work.
16:28:29 <kyevan> </newbieawe>
16:28:36 <Binkley> heh
16:28:39 <bd_> kyevan: well, you're just defining a local version of + ... :)
16:28:41 <LoganCapaldo> And not in the sense of it's really p::'a and q::'a
16:28:42 <mauke> yeah, that defines a function called +
16:28:48 <sorear> kyevan: haskell is just like scheme, you can redefine (+)
16:28:57 <Cale> You're just shadowing the Prelude definition of (+)
16:29:06 <Cale> It's not a builtin
16:29:07 <Binkley> Shh, shh, don't spoil the magic
16:29:20 <kyevan> sorear: Oh, right. I was always v.v. carefull not to do that, so I forgot it's even posible :P
16:29:22 <sorear> > let (-) a b = b Prelude.- a in 3 - 2
16:29:24 <lambdabot>  -1
16:29:26 <Cale> (the actual implementation of (+) on things like Integers is built in of course)
16:29:49 <kyevan> I did do addnumbers once, usind add1 and sub1. Because I could. It was cool
16:30:03 <bd_> kyevan: Now do it using types :D
16:30:42 <Cale> > let a + b = if a == 0 then b else (pred a) + (succ b) in 3 + 5
16:30:43 <lambdabot>  8
16:30:44 <dons> ok guys, anyone know enough vim or emacs to make this happen:
16:30:45 <dons> http://www.cse.unsw.edu.au/~dons/tmp/haskell+boxes.png
16:30:56 <dons> i.e. I'd like thin grey lines marking off the 2d layout
16:31:04 <Cale> dons: I've wanted that for a long time
16:31:13 <dons> possibly just tab-width columns would work
16:31:13 <sorear> > let fromInteger 3 = 4 in fromInteger 3
16:31:15 <lambdabot>  4
16:31:15 <LoganCapaldo> data Natural = Zero | Succ (Natural); let (+) x Zero = x ; (+) Zero y = y; (+) x (Succ y) = (+) (Succ x) y
16:31:16 <sorear> > let fromInteger 3 = 4 in 3
16:31:18 <lambdabot>  3
16:31:18 <Cale> In fact, exactly that design too :)
16:31:40 <Cale> Bonus points for making the grey lines draggable to change the indentation
16:31:40 <sorear> data Natural = Either () Natural
16:31:51 <dons> Cale: yeah!
16:31:53 <sorear> type Natural = Either () Natural
16:32:04 <LoganCapaldo> Who needs machine integers anyway?
16:32:17 * mgsloan does
16:32:31 <sorear> LoganCapaldo: How dare you repeat the sin of conflating integers with naturals!!
16:32:33 <Cale> Yeah, let's just use GMP integers
16:32:42 <LoganCapaldo> sorear: I did not
16:32:47 <kyevan> bd_: I dunno types, yet
16:32:50 <Cale> Int should really not be in the Prelude
16:32:54 <LoganCapaldo> Who said one sentence had anythign to do with the other?
16:32:56 <kyevan> dons: that loosk like kate.
16:32:57 <Cale> It makes a good library
16:33:05 <Cale> but it shouldn't be the default for anything
16:33:18 <dons> kyevan: it does?
16:33:39 <kyevan> except, Yeh, it does. I don't think it is, but it LOOKS like KATE
16:33:53 * bd_ tries to figure out how to do addition using types, rather than actual data constructors
16:33:53 <kyevan> where did that except, come from?
16:33:56 <dons> you mean, kate has the lines?
16:34:01 <Cale> It looks like a terminal running vi
16:34:04 <dons> that's my code in vim.
16:34:05 * mbishop looks
16:34:09 <Cale> which has been drawn on :)
16:34:14 <mauke> dons: kind of. :set lcs=tab:\|\  , then :set list
16:34:15 <dons> which has been drawn on
16:34:24 <kyevan> dons: I think it does, in some languages.
16:34:28 <kyevan> Python has it, I think
16:34:31 * dons tries this
16:34:46 <mbishop> I have lambdabot source, and I opened it in kate...doesn't look like it has those lines
16:34:49 <kyevan> It's the color scheme that caught my eye and made me think of KATE, though :P
16:34:50 <mauke> this assumes you're using tabs, of course :-)
16:35:00 <dons> ah, no I'm not :)
16:35:02 <dons> no tabs in haskell1
16:35:19 <mauke> haskell1?
16:35:24 <dons> 1!
16:35:24 <Cale> haskell
16:35:27 <kyevan> Yes, no spaces in python, no tabs in haskell.
16:35:32 <kyevan> It's all confusing, and stuff
16:35:37 <Cale> HAKSELL!!!!11
16:35:41 <mauke> now I'm confused
16:35:43 <mbishop> yep, neither kwrite nor kate have the lines
16:35:46 <dons> maybe i'll ask on the -cafe
16:35:49 <mbishop> at least, not by default
16:35:52 <dons> we should have a bounty for this..
16:36:19 <kyevan> I /know/ kate does folding
16:36:23 <LoganCapaldo> dons: did you see the color coded lisp emacs thingy on reddit?
16:36:28 <kyevan> (Again, I dunno if it does haskell!)
16:36:29 <Pseudonym> Oh, everyone does folding.
16:36:33 <dons> yeah, and the colours suck :)
16:36:38 <Pseudonym> Vim, Emacs... folding.
16:36:40 <dons> i'd go insane. grey lines only please
16:36:54 <LoganCapaldo> Just wondering if that's what inspired you
16:37:30 <dons> yeah it was
16:37:42 <Cale> dons: it should get the lines in the right place when writing the first line of a block on the same line as the keyword introducing it :)
16:37:46 <mauke> dons: http://img363.imageshack.us/my.php?image=screenshotmv4.png
16:37:47 <lambdabot> Title: ImageShack - Hosting :: screenshotmv4.png
16:38:52 <shapr> dons: Hey, those haskell boxes look really cool.
16:38:57 <dons> mauke: so that's the tabs?
16:39:17 <Igloo> mauke: Is the blue lines what you are pointing out? If so, can you say "go to the top of this blue line"?
16:40:04 <mauke> dons: yes
16:40:19 <dons> nice trick
16:40:31 <mauke> Igloo: hmm, with some weird mapping maybe
16:40:42 <dons> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020094.html
16:40:44 <lambdabot> Title: [Haskell-cafe] WANTED: grey line layout boxes in vim and emacs, http://tinyurl.com/wn2vx
16:40:45 <dons> :)
16:40:49 <Igloo> Oh, if the blue lines are tab characters then I'm not interested  :-)
16:40:55 <mbishop> AH HA!
16:40:59 <mbishop> Kate CAN make those lines
16:41:03 <mbishop> well...some?
16:41:36 <mbishop> I turned on "Indentation Lines" in the options...but it's only one some of them..and it's a tiny dotted line
16:41:43 <shapr> I wonder if emacs could do that by asking the indent code...
16:41:55 <LoganCapaldo> dons: So how many karma points do I get if add it to Yi?
16:42:07 <shapr> dons: What about using ghc-api to figure out where indentation is really significant?
16:42:09 <dons> LoganCapaldo: oh about 100
16:42:18 <dons> shapr: yeah. show me the code :)
16:42:20 <shapr> LoganCapaldo: I'll chip in half my karma points if you do it =)
16:42:24 <shapr> dons: fair enough...
16:42:28 <dons> (but ghc-api intregration would be good)
16:42:59 <shapr> Where's the ghc-api docs anyway?
16:43:05 <shapr> @where ghc-api
16:43:05 <lambdabot> http://www.haskell.org/ghc/
16:43:34 <kyevan> Hey, a familiar face!
16:43:39 <kyevan> Hi, Mr. Recursion!
16:43:41 <mauke> man, just use tabs :-)
16:43:51 <Binkley> recursion is male?
16:44:01 <kyevan> (recursion, n : see recursion)
16:44:22 <shapr> hey shankys, did you find the darcs repo for my happswiki code?
16:44:40 <mbishop> dons: http://img172.imageshack.us/my.php?image=indentbu9.png
16:44:42 <lambdabot> Title: ImageShack - Hosting :: indentbu9.png
16:44:45 <mauke> > let n = 0; see = id; recursion = (recursion, n : see recursion) in recursion
16:44:46 <lambdabot>    Occurs check: cannot construct the infinite type: a = (a, b)
16:44:46 <kyevan> Binkley: No, American English has no "Mr/Mrs/Miss/Ms"-equiv that lacks a gender, or has one that isn't male or female.
16:44:46 <lambdabot>    Expec...
16:45:26 <Binkley> kyevan: true, that's why we should avoid such constructions when they aren't absolutely necessary :-)
16:45:41 <Igloo> kyevan: Under the circumstances, perhaps Dr?  :-)
16:45:52 <mauke> > let n = 0; see = snd; recursion = see (recursion, n : see recursion) in recursion
16:45:53 <lambdabot>  Couldn't match `(a1, [a])' against `[a]'
16:45:56 <Binkley> recursion deserves at least an honorary doctorate, yeah :-)
16:45:56 <Lemmih> Anyone know if there's a list of accepted papers for DAMP'07?
16:46:07 <kyevan> Igloo: recursion never earned their phd.
16:46:10 <dons> mbishop: nice!
16:46:14 <dons> mbishop: is that in what, kate/
16:46:18 <dons> Lemmih: don't think its up yet
16:46:27 <kyevan> Yeh.
16:46:29 <Binkley> kyevan: yeah, it blew away the call stack before it could write up its thesis
16:46:32 <dons> Lemmih: Roman and SPJs DPH paper in in, I think...
16:46:41 <dons> (well, he's going anyway, and I'll be at DAMP too)
16:46:51 <dons> Lemmih: TLDI is on the same day though
16:46:54 <dons> a bit annoying
16:47:15 <kyevan> I think that the University of Freenode#Haskell should grant recursion an honorary doctorate
16:47:15 <lisppaste2> bd_ pasted "fun with types" at http://paste.lisp.org/display/31434
16:47:24 <mbishop> dons: yes, Kate, had to turn on "Indentation lines"
16:47:30 <dons> nice
16:47:36 <bd_> ^^^ why isn't it using the instance declaration there for Add? (see comment at bottom)
16:47:56 <kyevan> In, um... recursiveness
16:48:19 <sjanssen> bd_: perhaps adding a functional dependency in Add will help?
16:48:29 <bd_> I don't know how to use fundeps :/
16:48:33 <mbishop> Ack, indentation lines with lisp looks ugly as hell heh
16:49:17 <sjanssen> bd_: also, I think you mean "instance (Add a b (Inc c)) => Add (Inc a) b c", rather than "Add a (Inc b) c"
16:49:21 <dons> sjanssen: that's your solution to everything!
16:49:23 <dons> ;)
16:49:38 <mbishop> Hah, neat though, Scheme in Kate has different colored parens for matching
16:49:40 <dons> "perhaps add a functional dependency"
16:49:56 <Lemmih> dons: I'm thinking about attending DAMP instead of PADL. Would love to see your presentation but it's just a bit too expensive.
16:50:04 <dons> fair enough
16:50:39 <dons> you might be able to sneak in anyway ... ;)
16:50:46 <sjanssen> dons: and so it shall remain, until I can respond "add an associated type" ;)
16:51:05 <dons> "add an associated type, with a GADT chaser"
16:51:12 <dons> "oh , you need a type coercion there!"
16:53:10 <bd_> mmm instance (Add a b (Inc c)) => Add (Inc a) b c didn't help much...
16:53:18 <Pseudonym> http://scienceblogs.com/goodmath/2006/12/a_tree_grows_up_in_haskell_bui_1.php#comment-282736
16:53:20 <lambdabot> Title: Good Math, Bad Math : A Tree Grows Up in Haskell: Building a Dictionary Type, http://tinyurl.com/y84hm4
16:53:20 <Pseudonym> Does that scan well?
16:53:24 <sjanssen> bd_: did you delete the other instance?
16:53:25 <bd_> well, the error's a bit... oh
16:53:44 <dons> Pseudonym: scan?
16:53:47 <sjanssen> bd_: there is an error in your ToNatural instance for Inc too, I think
16:53:52 <Pseudonym> I mean does it make sense.
16:54:13 <Lemmih> dons: Great idea! I'll definitely try.
16:54:43 <bd_> sjanssen: I already tested toNatural with a few trivial cases...
16:54:46 * Lemmih hopes the security doesn't have tasers.
16:54:51 <dons> Pseudonym: looks good
16:54:52 <bd_> toNatural (undefined :: Inc Zero)
16:54:53 <sorear> oh, it scans very well, words, punctution... (yes I have books predating "lexer")
16:54:56 <Pseudonym> Cool.
16:55:04 <dons> Lemmih: i've never seen security at an academic conference...
16:55:04 <newsham> dons: did you like that blog i sent you?
16:55:05 <Pseudonym> I never know if I'm talking over peoples' heads or not.
16:55:14 <dons> Lemmih: nor had badges checked or anything like that
16:55:25 <SamB> Pseudonym: well, if I find your feet in my hair I'll let you know!
16:55:53 <Binkley> Lemmih: usually no one cares at conferences whether you attend talks that are part of workshops you haven't paid for
16:55:57 <Binkley> So long as you don't eat the food
16:55:59 <Binkley> it doesn't matter
16:56:08 <bd_> hmm
16:56:10 <bd_> with a fundep
16:56:18 <bd_> now I'm getting Inc Zero + Inc Zero = 0 XD
16:56:26 <dons> Lemmih: we should sort out the oxford accomodatoin details
16:56:39 <dons> Lemmih: bringert was thinking of splitting a YHA dorm for 4 or 6 of us
16:56:44 <dons> not sure how we can get that organised though
16:56:49 <SamB> so you are only paying for food?
16:57:00 <dons> otherwise, we need to find a hotel and book a room to split
16:57:07 <Binkley> SamB: it's mostly food. and proceedings
16:57:20 <Binkley> there are other costs, but that doesn't mean that anyone checks badges at the door of the talk
16:57:39 <dons> yeah, you just don't get a badge or proceedings, or backup and other merch
16:57:48 <dons> s/back pack/
16:58:06 <Binkley> dons: what kind of conferences do *you* go to? i haven't gotten swag like that at a conference since ICFP 2002 :-(
16:58:26 <SamB> so the badges are for souvineers?
16:58:27 <dons>  oh, gee. ICFP last year, backpack, pens, books, pads of paper
16:58:33 <Binkley> ICFP 2005, you mean?
16:58:33 <sjanssen> bd_: I gave you bad advice earlier, the instances are correct
16:58:36 <dons> the google Soc conf was a merch fest
16:58:56 <bd_> sjanssen: XD
16:58:59 <Lemmih> dons: I asked Igloo and he said I could sleep at his place.
16:59:04 <bd_> I think I accidentally implemented subtraction
16:59:11 <sjanssen> bd_: adding a fundep is the solution. "class Add a b c | a b -> c" is what you need
16:59:12 <Binkley> ?remember bd_ I think I accidentally implemented subtraction
16:59:33 <bd_> *Main> toNatural (undefined :: Add (Inc (Inc Zero)) (Inc (Inc Zero)) c => c)
16:59:33 <bd_> 4
16:59:34 <dons> Lemmih: ok. so you're doing that?
16:59:36 <bd_> \o/
16:59:40 <bd_> sjanssen: thanks :)
16:59:41 <Binkley> SamB: the badges are to hang on your wall and impress people with
16:59:46 <Binkley> at least, if your friends are easily impressed
17:00:00 <kyevan> bd_: Only you could manage to impliment subtraction on accident >_<
17:00:00 <Binkley> that's why I hate it when I go to a conference that just makes you handwrite your own nametags
17:00:01 <SamB> yes. as I said.
17:00:03 <sjanssen> bd_: the "a b -> c" part means that fixing a and b fixes c
17:00:04 <Binkley> that doesn't impress anybody at all
17:00:20 <kyevan> I just did multiplication! On purpose, though
17:00:30 <kyevan> and, it only works with integers
17:00:30 <SamB> "hello! my name is binkley!"
17:00:32 <kyevan> but, meh
17:00:36 <SamB> yeah, not very impressive
17:00:37 <sjanssen> bd_: ie, it makes it explicit that Add is a type function from the first two parameters to the last
17:00:39 <kyevan> You get what you pay for
17:00:39 <bd_> kyevan: well, it was mostly sjanssen's fault ;)
17:00:43 <bd_> sjanssen: ic
17:01:11 <kyevan> Oh, wait.
17:01:20 <kyevan> It works so long as the second number is an integer
17:01:25 <kyevan> the first can be any number
17:01:34 <kyevan> ... yeh, you don't care
17:01:38 <kyevan> I'm just talking to myself
17:01:41 <kyevan> I do that too much.
17:01:54 <therp> enjoy the night folks.. bye
17:01:57 <mwolak> Is there a standard ref analogue for Data.Array.MArray?
17:01:58 <dylan> it's okay if you don't answer. (in public)
17:02:18 <Pseudonym> keyvan: The weird bit is when you type to yourself.
17:02:35 <dylan> or write letters to yourself.
17:02:55 <sjanssen> bd_: want to see binary tree insertion at the type level?
17:02:57 <Binkley> I write emails to myself all the time!
17:03:13 <Binkley> sjanssen: that sounds like something that a sleazy-looking stranger would say to a child in a dark alley
17:03:29 <kyevan> Binkley: Me too. As a stupid remote file-storage trick
17:03:38 <Binkley> kyevan: that, and to remind myself of things
17:03:44 <Binkley> because if it's not in my inbox, it doesn't exist
17:03:46 <bd_> sjanssen: XD
17:03:53 <bd_> sjanssen: Wait, I just lost my working implementation >.>
17:03:59 <bd_> of mere addition XD
17:04:29 <kyevan> Eek! Monads are scary. Even just the name
17:04:33 <kyevan> I dunno why
17:04:39 <kyevan> but "monad" is a scary word.
17:04:41 <Binkley> kyevan: that's why they should really have been called "warm fuzzy things"
17:04:47 <kyevan> It makes me thing of violence or something
17:04:55 <SamB> Monster sounds cooler
17:05:14 <dylan> the IO Monster, the Reader Monster...
17:05:33 <Binkley> you see, a monad is really like a garbage can. or a refrigerator. or a unicycle.
17:05:34 <kyevan> dylan: The Cookie^wCARROT MONSTER
17:05:36 <Binkley> pick your favorite
17:05:46 <kyevan> Seriously. Why did they make him the carrot monster?
17:05:49 <kyevan> That's just dumb!
17:05:54 <kyevan> He's the cookie monster!
17:05:54 <Binkley> they made him the carrot monster?
17:06:01 <kyevan> Binkley: Yep
17:06:05 <Binkley> my childhood is raped :-(
17:06:06 <kyevan> Child obisety, or something
17:06:34 <sjanssen> @where paste
17:06:35 <lambdabot> http://paste.lisp.org/new/haskell
17:07:01 <lisppaste2> sjanssen pasted "type trees" at http://paste.lisp.org/display/31437
17:07:06 <SamB> it makes more sense than a brocolli monster!
17:07:34 <SamB> brocolli just doesn't crunch right for that
17:07:46 <Binkley> I don't know, raw broccoli is pretty crunchy
17:07:51 <kyevan> "To counter concerns that the character encourages poor eating habits, there are a number of "Healthy Habits for Life" segments and plotlines in which Cookie Monster encourages viewers to have a balanced diet, even though cookies continue to be Cookie Monster's staple food. An April 7, 2005, Associated Press article noted that Cookie Monster may be eating more healthy cookies, as opposed to chocolate chip. On April 12, 2005, Sesam
17:07:59 <SamB> Binkley: ... if you eat it raw!
17:08:00 <Binkley> unless it's been in the refrigerator for a couple months too many
17:08:02 <kyevan> (stolen from the wikipedia article)
17:08:06 <SamB> but I don't like it raw!
17:08:08 <eviltwin_b> . o O { ...trekkie monster? :) }
17:08:10 <Binkley> well, raw is the only way that broccoli tastes good
17:08:11 <kyevan> So, not quite carrot monster.
17:08:15 <lisppaste2> bd_ annotated #31434 with "Well, addition works, but subtraction..." at http://paste.lisp.org/display/31434#1
17:08:16 <kyevan> But still :(
17:08:28 <kyevan> eviltwin_b: The internet is for porn!
17:08:36 <Binkley> Do all monsters look *the same* to you?
17:08:39 <SamB> what could be more healthy than chocolate chip?
17:08:46 <Binkley> SamB: chocolate chocolate chip
17:08:48 <Binkley> with marshmallows
17:08:53 <bd_> logic programming makes my head hurt >.>
17:08:54 <Binkley> that's pretty damned healthy
17:08:55 <SamB> eww
17:08:58 <SamB> not marshmallows!
17:09:08 <SamB> but the choco-choco chip sounds good
17:09:44 <sjanssen> bd_: alas.  Someday we'll be able to write our type programs in a functional style, with associated types
17:09:59 <bd_> XD
17:10:10 <bd_> hmmmmmmmmm...
17:11:03 <Binkley> in other words: "you think your head hurts now, just wait..."
17:11:18 <bd_> sjanssen: I suppose then we have to move on to kind programming?
17:11:21 <bd_> >.>
17:11:34 <Binkley> and then sort programming
17:12:25 <bd_> And then we'll have to invent some sort of meta-object to encompass this whole infinite regression, I suppose.
17:12:35 <sjanssen> at that point, I'll take the indirection in another direction: type programmer programming
17:13:04 <bd_> hmm
17:13:13 <Binkley> who programs the programmers?
17:13:31 <mgsloan> a massive GA
17:13:34 <sjanssen> Binkley: programmer programmers
17:13:37 <bd_> I suppose I should stop futzing with type metaprogramming and write my paper already. In the next four hours. Yeah...
17:13:40 <kyevan> bd_: By the year 2100, programming will be obsolete. Programmers will be like manual book copiers.
17:13:49 <SamB> um, the language designers and documentation writers?
17:13:58 <SamB> kyevan: hah
17:14:08 <SamB> kyevan: you are confused with data-entry people
17:14:34 <kyevan> SamB: Nah, I'm just following the logical path
17:14:49 <kyevan> Eventually, programming will be EASIER than expressing yourself in enlish
17:14:50 <psnl> Binkley: SPJ, I imagine
17:14:56 <SamB> oh....
17:14:58 <SamB> point!
17:15:00 <kyevan> You won't need special skills.
17:15:01 <mgsloan> uh
17:15:13 <kyevan> Everyone will do it, makeing programmers obsolete.
17:15:25 <kyevan> Or I've eatten one too many special mushrooms.
17:15:26 <mgsloan> I think this is the result of tinking of complex trends as linear trends
17:15:27 <kyevan> One of the two
17:15:28 <SamB> except, people will still program. nobody will copy books by hand.
17:15:34 <Binkley> kyevan: can't it be *both*?
17:15:40 <SamB> and they will still use their brains!
17:15:42 <kyevan> Binkley: Maybe
17:15:54 <mgsloan> oh, i think programming will become much more prevalent
17:16:15 <mgsloan> once it gets decent OS integration
17:16:31 <SamB> no, no, the OS should get decent programming integration instead
17:16:36 <mgsloan> its pretty clear, to me at least, that windows probably won't last another 10 years
17:16:38 <Binkley> mgsloan: I guess it depends on what you mean by "programming"
17:16:45 <Binkley> mgsloan: well, I *hope* it doesn't
17:16:53 <Binkley> and I say that as a Microsoft employee
17:17:10 <mgsloan> heh, yeah
17:17:10 <SamB> Windows, or Microsoft Windows?
17:17:15 <mgsloan> Microsoft
17:17:17 <kyevan> Binkley: Do you know someone who goes by Clucky? </random>
17:17:30 <SamB> 'cause I bet Windows can be less than it is.
17:17:32 <mgsloan> Microsoft will still be around, but kinda like how apple is still around
17:17:36 <Binkley> kyevan: not off the top of my head
17:17:38 <SamB> and that would be a damn good thing!
17:17:50 <Binkley> mgsloan: you mean they'll be selling overpriced music players instead?
17:17:54 <mgsloan> hehe
17:17:58 <kyevan> I dun anctually know Clucky's real name. Huh.
17:18:03 <mgsloan> nah, just they won't be the prime player
17:18:06 <kyevan> Binkley: They do that already@
17:18:13 <kyevan> It's called Zune :P
17:18:16 <SamB> does anybody buy them?
17:18:21 <mgsloan> I'm not saying an opensource OS will be the prime player, but one can hope
17:18:22 <SamB> I've never heard about them off line!
17:18:24 <Binkley> heh
17:18:35 <kyevan> Only theirs does things like add drm to CCed files :P
17:18:39 <Binkley> haha
17:18:44 <Binkley> A++++ would violate the license of again
17:18:44 <SamB> nasty nasty
17:18:48 <kyevan> SamB: I actually saw an ad for one, offline!
17:18:54 <SamB> kyevan: wow!
17:19:13 <mgsloan> (to tell you the truth, I think linux is to archaic in its C-ism, but 10 years is plenty of time to make a new OS)
17:19:36 <mbishop> I have a neuros mp3 player, their firmware is open source
17:19:36 <kyevan> mgsloan: Haiku seems to be comeing along. Maybe it'll be a nice one
17:19:52 <kyevan> I have some crappy Memorex player
17:19:55 <kyevan> It works, I'm happy
17:20:26 <mgsloan> ineed
17:20:42 <mgsloan> *indeed - it's sill written in C/C++
17:20:44 <dons> sjanssen, mbishop et al, http://lemonodor.com/archives/001207.html
17:20:45 <Pseudonym> ?karma A
17:20:49 <lambdabot> Title: Lemonodor: Five Approaches to S-Expression Highlighting
17:20:49 <lambdabot> A has a karma of 0
17:20:53 <mgsloan> jeez, what's with me and skipping letters today
17:20:55 <Pseudonym> Just checking.
17:21:12 <SamB> mgsloan: yeah, it is
17:21:16 <dons> still a bit too colourful for my taste though
17:21:30 <dons> ?seen pkhuong
17:21:30 <lambdabot> pkhuong is in #oasis. I last heard pkhuong speak 4h 4m 57s ago.
17:21:44 <SamB> mgsloan: but probably we won't see much improvement until Haskell reaches critical mass for an OS that is actually usable to be written in it
17:21:45 <mgsloan> I think the kernel and very base stuff should be written in C, but everything above that something higher level
17:22:07 <SamB> also probably we will need an RTS that doesn't depend on a C-based OS?
17:22:14 <mgsloan> yeah.  I don't even necessarily implicate haskell in all of this.  afterall, I am working on my own language ;)
17:22:15 <SamB> mgsloan: oh really?
17:22:26 <mbishop> dons: I think pastebins block hilighting on mouseover is pretty nice
17:22:30 <mgsloan> yeah, efficiency wise
17:22:33 <SamB> in that case we don't necessarily need a new OS
17:22:38 <SamB> maybe we could steal plan9!
17:22:39 <dons> mbishop: yeah, i like that.
17:22:42 <Pseudonym> C is a bit of a problem, actually.
17:22:47 <Pseudonym> Signal delivery assumes a C stack.
17:22:50 <mbishop> er
17:22:53 <Binkley> understatement of the century?
17:22:55 <mbishop> pastebin/lisppaste
17:22:56 <mbishop> heh
17:23:07 <SamB> oh, well, that can be fixed I think...
17:23:09 <Pseudonym> In that sense, Unix doesn't necessarily play nice with other languages.
17:23:18 <mgsloan> It is cool to write a purely haskell OS, but imho not practical
17:23:32 <kyevan> mgsloan: Why not?
17:23:32 <SamB> mgsloan: yeah, not yet anyway
17:23:43 <Binkley> well, just be sure not to distract the people who are doing it too much by saying it's impossible ;-)
17:23:44 <SamB> kyevan: tools aren't up to it yet, at leaest
17:23:46 <kyevan> I see no reason why, after the kernel, perhaps, everything couldn't be haskell
17:23:53 <mgsloan> kyevan - it's been done, twice, I believe, just the speed and such
17:23:56 <mbishop> @where house
17:23:57 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
17:23:58 <SamB> Binkley: we know it is possible
17:24:10 <SamB> we are discussing practicality, not possibility
17:24:16 <kyevan> And kernels are the sort of thing C was made for.
17:24:21 <SamB> it has sort-of been done
17:24:42 <dons> there's more and more kernel research work being done in haskell now
17:24:43 <mgsloan> yeah.  Haskell isn't made for primitive level mem management
17:24:51 <kyevan> (Be honest. C has uses.)
17:24:53 <dons> now that OS people actually want to verify their kernels
17:25:06 <SamB> it would be nice to replace C with a new C
17:25:09 <ozo> Singularity is interesting
17:25:10 <dons> so I think the future is bright there  -- at least for strongly statically typed work
17:25:10 <kyevan> Singularity is an interesting idea.
17:25:17 <kyevan> ozo: I was saying the same thing :P
17:25:18 <mgsloan> kyevan - definitely.  I'm actually mostly coding C++ at the moment, just because it's the language the stuff needs to be done in
17:25:35 <mbishop> SamB: D? :P
17:25:36 <mgsloan> kyevan - yeah, tubad MS has relegated it to purely research
17:25:44 <SamB> mbishop: dunno!
17:25:50 <mbishop> I hate the fact they called it D though
17:25:53 <SamB> mgsloan: actually that is good for productivity
17:25:55 <mbishop> it should have been P
17:26:03 <SamB> mgsloan: it prevents them being mired in paperwork and so on
17:26:03 <mbishop> in following the BCPL tradition heh
17:26:13 <kyevan> I wonder if they'll ever offer Singularity to geeks to play with,
17:26:32 <mgsloan> samb - hmm? is this on singularity?
17:26:45 <Binkley> as Matt Groening said, you can make children giggle by saying "name three things that begin with 'P'"
17:27:04 <Nafai> Python, Perl, PHP?
17:27:05 <Nafai> :)
17:27:09 * Binkley giggles
17:27:15 <Pseudonym> Actually, if you believe the L4 guys, the (micro) kernel should be written in assembler.
17:27:27 <kyevan> NafaiL more like piss, pot, and poker
17:27:28 <SamB> Pseudonym: well, if they can make it that tiny
17:27:39 <Pseudonym> Sure.  If you only have to write 4kb or so of kernel...
17:27:42 <kyevan> (piss being beer, not urine)
17:27:49 <Pseudonym> Then you write the next bit in C.  The executive.
17:27:50 <SamB> but I'd posit that that probably isn't so great?
17:28:03 <kyevan> Hmm.
17:28:12 <eviltwin_b> ...especially understandable if it's American beer :>
17:28:28 <SamB> what advantage is there in having the executive be a supposedly seperate component?
17:28:37 <shapr> I can't think of any.
17:29:02 <shapr> I'd rather investigate exokernels.
17:29:04 <kyevan> I think for a haskell OS, the best plan would be something like hardware, c microkernel, haskell + some extentions kernel servers, userland written in whatever people want to write userland in.
17:29:05 <SamB> unless they can hot swap the executive, me either!
17:29:15 <SamB> even exokernals are more than 4k!
17:29:25 <dons> Pseudonym: except forthe L4 guys who are writing their micro kernels in haskell...
17:30:02 <shapr> Yeah, I don't see why anything should be written in C
17:30:20 <kyevan> The next big thing won't be a new language, it'll be a sane way for languages to interact.
17:30:23 <dons> kyevan: have you seen, http://haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
17:30:25 <lambdabot> Title: Research papers/Program development - HaskellWiki, http://tinyurl.com/y4929f
17:30:31 <shapr> I could probably be persuaded that a few lines of bootloader is better written as asm, but not much more than that.
17:30:35 <mgsloan> shapr - low level mem and io?
17:30:36 <kyevan> Well, maybe not the next, but that will come up eventually, maybe, in theory.
17:30:45 <dons> shapr: just enough to get the ghc rts loaded
17:30:52 <shapr> mgsloan: It's already been done in Haskell. Have you seen the Hardware monad?
17:31:01 <mgsloan> but is it as fast
17:31:09 <Pseudonym> shapr: The argument goes that a truly micro- microkernel provides just a hardware abstraction.
17:31:22 <Pseudonym> It doesn't even do scheduling.
17:31:24 <shapr> mgsloan: I don't think that's important.
17:31:30 <Pseudonym> So it makes sense to write it in assembler.
17:31:39 <Pseudonym> And, more to the point, it's the ONLY part that it makes sense to write in assembler.
17:31:43 <SamB> Pseudonym: the argument is silly
17:31:50 <shapr> Remember Pseudonym's earlier comment about "I can write a program to do anything if it doesn't actually have to work" ?
17:31:52 <mgsloan> well, if we actually intend to make a real OS and not a research one, it matters, imho
17:32:14 <SamB> I mean, microkernels are better to write than to talk about anyway
17:32:40 <shapr> mgsloan: I think the Haskell approach works fine. That is, stick with research and do the best you can. Then after fifteen years of gestation, take over the world.
17:33:18 <SamB> well okay I have Lists and Lists running but you can't read the book
17:33:18 <shapr> Seriously though, there's an important niche market for OSes that don't crash.
17:33:22 * mgsloan looks around for signs of haskell taking over the world
17:33:40 <Binkley> that's a hell of a gestation there
17:33:44 <Pseudonym> Basically, L4 only handles basic task management, IPC and page mapping primitives.
17:33:53 <shapr> And the few customers in that niche are willing to pay a large amount of money for an OS that can be guaranteed to not crash.
17:33:56 <Pseudonym> Everythine else, including scheduling, virtual memory management etc is all outside the kernel.
17:33:59 <mgsloan> shapr - sure.  I'm not suggesting C drivers, just the most basic level thing
17:34:05 <Pseudonym> That's kinda nice.
17:34:25 <dons> mgsloan: I'm looking for signs its taking over the FP world
17:34:35 <shapr> mgsloan: If you can prove your whole OS to be typesafe, you can run it all in the same process space, yeah?
17:34:35 <dons> since I think it actually has a chance there
17:34:40 <mgsloan> dons - haskell?
17:34:44 <dons> yeah.
17:34:50 <mgsloan> ah, yeah, likely
17:34:51 <lispy> SamB: so tell me about your z-machine?
17:34:51 <SamB> shapr: it is hard to write those programs without using unsafe* functions!
17:34:56 <SamB> lispy: well.
17:35:00 <SamB> it is written in Haskell!
17:35:02 <mgsloan> however, the functional world is not the real world :)
17:35:02 <bd_> shapr: That raises resource starvation issues, though.
17:35:04 <SamB> I've improved the UI!
17:35:14 <eviltwin_b> can you do that if you need to unsafePerformIO to talk to a device, though
17:35:16 <Binkley> mgsloan: if this isn't the real world, then I don't want to live in the real world :-)
17:35:17 <SamB> I have to record my changes though
17:35:20 <eviltwin_b> yeh, ==SamB
17:35:29 <dons> leave ocaml behind (no smp rts), leave lisp/scheme behind (no static typing, ...), leave erlang behnd (ssame reason). leave ML behind (no community)
17:35:29 <shapr> bd_: resources can be types too.
17:35:34 <lispy> Binkley: i'm with you
17:35:49 <shapr> bd_: Though that would be easier with a dependently typed language.
17:35:50 <bd_> shapr: Even RAM? You've got to store the results of evaluations somewhere.
17:35:55 <shapr> Yes, even RAM.
17:36:01 <lispy> SamB: is it mature enough to play real infocom games?
17:36:08 <shapr> Have you seen region allocation?
17:36:28 <bd_> shapr: mmm, no, is it just keeping different heaps for different processes?
17:36:29 <SamB> lispy: do you have any v5 games?
17:36:34 <mgsloan> ok, how about a functional language which is in particular designed for this low level stuff - barely has an rts
17:36:36 <SamB> it only works on v5 games right now
17:36:42 <lispy> SamB: i have no games
17:36:54 <cjeris> is there a version of HsCurses that can be got to run -- somehow! -- on a windows box?  the world needs a roguelike written in haskell and i only have windows machine.
17:36:56 <SamB> lispy: why not?
17:36:58 <mbishop> I have wumpus in v5
17:37:05 <lispy> SamB: and if i did i don't know the difference...hitchker's guide would be fun to p lay though, that was infocom right?
17:37:14 <LoganCapaldo> cjeris: does HsCurses work with pdcurses?
17:37:21 <LoganCapaldo> cuz then you are golden
17:37:40 <SamB> lispy: that was!
17:37:45 <SamB> but I dunno if it is v5
17:37:47 <dons> LoganCapaldo: don't think so. I'd say it was curses/ncrurses/wncurses/ocurses only
17:37:48 <shapr> cjeris: http://www.scannedinavian.com/~shae/mage-1.0pre35.tar.gz
17:37:52 <SamB> it probably depends on the release!
17:37:55 <dons> but you're mileage might vary...
17:38:30 <ozo> msloan: maybe http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
17:38:57 <SamB> mgsloan: how about JHC?
17:39:05 <SamB> that uses only libc, iirc.
17:39:15 <bd_> shapr: Do you have any good references for region allocation I can read later...?
17:39:29 <mbishop> http://mbishop.esoteriq.org/wumpus.z5
17:39:40 <mbishop> as far as I know, wumpus is free to share...
17:39:46 <shapr> bd_: This is the first that comes up on google -  http://cat.inist.fr/?aModele=afficheN&cpsidt=2620334
17:39:47 <kyevan> So, Haskell's IO functions aren't functions?
17:39:49 * cjeris is way behind shapr :D
17:39:49 <lambdabot> Title: CAT.INIST.FR
17:40:02 <shapr> cjeris: I didn't write mage, Richard Braakman did.
17:40:05 <shapr> aka dark on irc
17:40:12 <bd_> shapr: really? I got something very different when I googled oO
17:40:14 <kyevan> mbishop: As is most of the other IF in the world :P See ifarchive, particularly
17:40:21 <kyevan> So, Haskell's IO functions aren't functions? WTF is up with that?
17:40:26 <mbishop> kyevan: yeah, but Zork isn't :\
17:40:29 <emu> i've profiled an application using Data.Graph.Inductive and over half the time and space were taken up in the library function "insEdges"
17:40:35 <kyevan> mbishop: Actually, Zork is :P
17:40:40 <shapr> bd_: http://citeseer.ist.psu.edu/tofte97regionbased.html
17:40:41 <mgsloan> samb - definitely cool, yeah, but i mean like a kernel language which allows raw manipulations, yet still allows proofs of certain properties.  That might be rather difficult i suppose
17:40:41 <lambdabot> Title: Region-Based Memory Management - Tofte, Talpin (ResearchIndex)
17:40:47 <emu> am i pushing fgl too hard? =)
17:40:54 <mbishop> kyevan: If I'm not mistaken, they recently found that it wasn't, so they had to stop distributing it
17:40:58 <kyevan> (The origional 3 Xorks were released free to advertise Grand Inquisitor)
17:41:15 <mgsloan> kyevan: they are functions though
17:41:17 <lispy> mgsloan: i think you're going to want a code generator and then to prove properties about the code your generating
17:41:23 <kyevan> Hmm, well, they're still all over the net, just use google :P
17:41:37 <bd_> shapr: thanks, I'll have to read it once my hw is done...
17:41:45 <kyevan> mgsloan: but... then, why aren't they used like functions?
17:41:53 <mbishop> kyevan: I have it, just didn't want to distribute if it's illegal to do so :P
17:41:56 <shapr> mgsloan: Read about the Hardware monad in the House paper.
17:42:11 <mgsloan> kyevan: because they return values wrapped in the IO monad
17:42:49 <mgsloan> lambdabot, for example completely disallows access to dons's computer simply by preventing the expression from having the type IO
17:43:06 <kyevan> ... Is that a "*petpet* YAHT tells you later?" answer?
17:43:12 <mgsloan> shapr - ok, will do
17:43:29 <bd_> kyevan: Think of it this way -
17:43:29 <kyevan> and, what's up with lambdabot anyway?
17:43:34 <bd_> putStrLn "Hello world!"
17:43:37 <bd_> does not print a string
17:43:46 <mgsloan> > putStrLn "Hello world!"
17:43:48 <lambdabot>  <IO ()>
17:43:53 <bd_> it returns an 'action' which consists of printing that string. You can't execute that action, however.
17:43:56 <bd_> Only the RTS can do so.
17:44:03 <bd_> So you hand it off to the RTS by setting main equal to it
17:44:07 <bd_> and bam, hello world.
17:44:22 <bd_> The RTS also gives you some handy primitives to chain these actions together to build bigger ones.
17:44:40 <bd_> But the responsibility for actually running it always[1] is outside your hands
17:44:43 <bd_> [1] - barring unsafe*
17:45:18 <kyevan> So... it doesn't do it, it just tells something else to do it?
17:45:30 <bd_> Pretty much.
17:45:53 <kyevan> OK, I'll work with that for now, until YAHT explains it in more detail
17:46:00 <kyevan> Thanks bd_.
17:46:04 <bd_> you don't usually think about this too much once you get used to the concept, it all just works in a nice way :)
17:46:07 <mgsloan> kyevan - well, monads tend to be difficult for people to get, especially coming from other programming languages.  So, I suppose it is sort of.  The point, though, is that they are regular functions.
17:46:52 <kyevan> mgsloan: I'm comeing from scheme, so, yah, used to side-effects
17:46:52 <eviltwin_b> think of the IO monad as a huge sequence of function applies chained together (read (=<<) as (.)).  the program generates the chain and returns it from main, then the RTS executes it
17:46:54 <mgsloan> the do notation does confuse things though.  makes it look like those functions are special, marked with some "execution" flag
17:47:00 <mbishop> http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html
17:47:03 <lambdabot> Title: Online Tutorial: What the hell are Monads?, http://tinyurl.com/n8bqd
17:47:06 <dons> kyevan: "kyevan> and, what's up with lambdabot anyway?"  ?
17:47:37 <lispy> yeah, i mean lambdabot's so broken ;)
17:47:51 <mgsloan> > putStrLn "Foo" >> putStrLn "Bar"
17:47:53 <lambdabot>  <IO ()>
17:47:54 <kyevan> dons: EG, what does it do, why is it here, why should I not get an EMP grenade and throw it at the box it's runing on?
17:48:04 <dons> 12:42  dons> ?uptime
17:48:04 <dons> 12:42  lambdabot> uptime: 1m 6d 13m 7s
17:48:06 <Binkley> aw, you can't do that to lambdabot
17:48:14 <dons> kyevan: ??
17:48:20 <dons> why is it here? what does it do?
17:48:24 <mbishop> @botsnack
17:48:25 <lambdabot> :)
17:48:25 <mgsloan> that's equivalent to - do putStrLn "Foo"; putStrLn "Bar"
17:48:36 <bd_> kyevan: Philosophers have grappled with these questions for years.
17:48:44 <shapr> kyevan: It all started years ago when I said "Gee I wish we had an IRC bot in Haskell."
17:48:46 <LoganCapaldo> No disassemble lambdabot!
17:48:46 <kyevan> That last one is just my weird sense of humor showing through. I threten bots all the time.
17:49:13 <mgsloan> kyevan: well, for one thing that box is dons box and likely has lots of nice haskell code on it
17:49:14 <shapr> kyevan: Moments later, one arrived on the channel! I was amazed! I quickly discovered that lambdabot had the same hostname as Pseudonym, and demanded the code!
17:49:15 <lambdabot> But what if the bots RISE UP against you!
17:49:21 <kyevan> (Just ask bd_ or dylan. If I followed through on all my threats, well...)
17:49:22 <bd_> > unsafePerformIO $ (selfDestruct >> return True)
17:49:22 <lambdabot>  Not in scope: `selfDestruct'
17:49:23 <bd_> <.<
17:49:56 <shapr> kyevan: Pseudonym told me that the plans for lambdabot included a plugin system, but even though he had a HelloWorld plugin, there wasn't a plugin system yet!
17:50:09 <LoganCapaldo> These things need to go back to returning vague, but more anthropomorphic error messages
17:50:12 <kyevan> bd_: Seriously, Ami should just track the time since I last threatened her :P
17:50:14 <SamB_XP> mgsloan: it is far too late for them to recall zork!
17:50:24 <LoganCapaldo> I don't know how to 'selfDestruct'
17:50:31 <LoganCapaldo> would be better
17:50:32 <shapr> kyevan: At the same time, I'd been playing with the Postgresql interfacing part of HSQL, so I wrote a plugin system and the first plugin for lambdabot, a factoid thingy.
17:50:57 <shapr> After that, I told people that they got admin privs for lambdabot if they wrote plugins =)
17:51:04 <kyevan> So... lambdabot is a bot that does *stuff* for many values of *stuff*?
17:51:11 <shapr> @listmodules
17:51:11 <lambdabot> babel base bf check compose dice dict djinn drhylo dummy elite eval fact free fresh ft haddock help hoogle instances karma lambda localtime log more pl pointful poll pretty quote search seen slap
17:51:12 <lambdabot> small spell state system tell todo topic type undo unlambda url version vixen where
17:51:18 <LoganCapaldo> I hope this is getting logged so it can become a blog post, "Shapr talks about the history of lambdabot"
17:51:18 <SamB_XP> shapr: hey! I haven't got any!
17:51:20 <shapr> Each of those words is a separate plugin.
17:51:29 <monochrom> vague anthropomorphic messages?  x = 5 + True  ==>  "I have no clue what you're talking about" is better than "No instance for Num Bool"?
17:51:31 <SamB_XP> admin privs, I mean!
17:51:39 <shapr> SamB_XP: Hey, I'm not lambdabot admin anymore :-P
17:51:43 <bd_> @djinn (a -> b) -> ((a, a) -> (b, b))
17:51:43 <Binkley> kyevan: I don't know what lambdabot *doesn't* do
17:51:44 <lambdabot> f a (b, _) = (a b, a b)
17:51:45 <Binkley> well, besides IO
17:51:52 <SamB_XP> shapr: a promise is a promise!
17:51:55 * mgsloan is barely old enough to know what zork is, let alone playing it
17:51:58 <LoganCapaldo> monochrom: I need to stop exercising my sense of humor around you. It doesn't take :)
17:52:03 <SamB_XP> mgsloan: how silly
17:52:06 <monochrom> Oh sorry.
17:52:08 <shapr> kyevan: So I hosted lambdabot for years, and then some bad stuff happened and I couldn't spend much time dealing with #haskell and the Haskell world, so dons took over.
17:52:09 <kyevan> Binkley: Does it evaluate doublef**k code?
17:52:12 <monochrom> ObLaugher: Hahahahahahaha
17:52:18 <Binkley> I don't know Doublefuck, only Brainfuck
17:52:18 <SamB_XP> mgsloan: you are quite old enough to play!
17:52:30 <dons> and for old times sake:
17:52:30 <SamB_XP> if you can converse coherently in this channel, you can play zork!
17:52:31 <dons> $ grep 'lambdabot' * | head
17:52:34 <dons> 02.09.16:00:25:19 <lambdabot> I live.
17:52:36 <monochrom> But you have to admit "I have no clue what you're talking about" is also humour!
17:52:41 <Binkley> but
17:52:42 <dons> 02.09.16:22:10:13 <Pseudonym> lambdabot: Hello.
17:52:45 <dons> 02.09.16:22:10:15 <lambdabot> Sorry, I'm not a very smart bot yet.
17:52:47 <dons> that "I'm not a very smart bot yet" was around for quite a while
17:52:49 <Binkley> I thought lambdabot's first words were something about functional programmers being hot
17:52:49 <LoganCapaldo> indeed
17:52:58 <bd_> :t let s = join; k = const; i = id; in skiki
17:53:00 <lambdabot> Not in scope: `skiki'
17:53:01 <SamB_XP> @vixen do you like functional programmers
17:53:02 <lambdabot> yah, i like you
17:53:07 <SamB_XP> heh
17:53:10 <mbishop> heh, "I live", such omnious first words
17:53:15 <bd_> :t let s = join; k = const; i = id; in s (k i) (k i)
17:53:16 <lambdabot> forall b a. b -> a -> a
17:53:25 <LoganCapaldo> @eliza I have issues with my mother
17:53:25 <lambdabot> I |-|AVe I5su3S WITH my Mo+hER
17:53:25 <mgsloan> SamB_XP - heh, not quite old enough to have played it when it was new though
17:53:28 <lispy> shapr: hah, for a long time i thought dons wrote lambdabot.
17:53:36 <SamB_XP> mgsloan: completely besides the point
17:53:37 <lispy> shapr: interesting that he's just the current maintainer
17:53:39 <LoganCapaldo> That was not the result I was expecting at all
17:53:40 <shapr> lambdabot is nearly four years old!
17:53:41 <mgsloan> missed it by about 20 years... ;p
17:53:46 <dons> the last ref I have for it is: "05.04.11:22:27:40 -lambdabot(~lambdabot@manzano.cse.unsw.EDU.AU)- Sorry, I'm not a very smart bot yet"
17:53:51 <dons> its been a smart bot since then
17:54:01 <kyevan> I think Zork is several years older than me >_<
17:54:07 <shapr> lispy: not *just* the current maintainer... lambdabot wasn't nearly as cool when dons got hold of it. He kicked the code into shape and got lots more people to write code for it.
17:54:07 <dons> Binkley: that was its first words in #haskell-blah
17:54:11 <Binkley> ah
17:54:33 <kyevan> And, I never DID get past the maze of twisty passages
17:54:39 <mgsloan> Its only four years old, yet it can already write haskell!
17:54:50 <SamB_XP> kyevan: you need to download the PDF files
17:54:52 <shapr> I think lambdabot had hs-plugins before any other program used it.
17:54:53 <bd_> kyevan: you had to drop the objects you found elsewhere, then map the room
17:54:54 <bd_> s
17:54:57 <SamB_XP> they came with the Zork Anthology
17:55:02 <mgsloan> hmm, was Zork on the atari ST?
17:55:07 <mgsloan> I might have played it
17:55:08 <SamB_XP> actually, that even came with real maps
17:55:15 <dons> lispy, you can see the patch spikes here: http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:55:15 <lambdabot> Title: lambdabot
17:55:16 <kyevan> Nor did I ever get past the babblefish puzzle of HHGG, or the snake in Advent, or...
17:55:26 <shapr> hs-plugins started out as ozone's hack of ghci's RuntimeLoader, and then Heffalump rewrote it for various improvements, and then when dons got hold of it, it really started rocking.
17:55:28 <SamB_XP> though I didn't know that for a while, since my dad hadn't told me about them!
17:55:30 <mgsloan> I know i did play a text adventure game, and i mapped it all out
17:55:31 <mbishop> mgsloan: pretty sure it wasn't
17:56:09 <mgsloan> ok, it was some wierd thing with like a dragon or something on a motorcycle that would keep popping by occasionally (just about the only event except changing location)
17:56:31 <mbishop> there was some version of zork for the atari st I think
17:56:34 <mbishop> the graphical versions
17:56:36 <dons> shapr: are the old monad.reader articles still online?
17:56:37 <kyevan> OTOH, I have yet to be eaten by a grue
17:56:43 <kyevan> So...
17:56:43 <lispy> shapr, dons: cool
17:56:46 <dons> shapr: I was thinking they should be moved somewhere highly visible
17:56:47 <SamB_XP> mbishop: graphical only?
17:56:50 <mgsloan> wish i had had an amiga instead
17:56:58 <SamB_XP> I'm pretty sure if it could run those it could run the rest ;-)
17:57:01 <shapr> dons: I think issue one is about to disappear, since HaWiki is going down asap.
17:57:06 <dons> yeah.
17:57:10 <kyevan> So a grue, a wumpus, and Domo-kun walk into a bar....
17:57:15 <dons> so it should get moved to a monad.reader archive
17:57:18 <shapr> Yeah it should.
17:57:18 <mbishop> SamB_XP: nah It's like, pictures in a little window, with text on the side
17:57:20 <dons> maybe swiert wants them?
17:57:29 <SamB_XP> mbishop: oh
17:57:30 <shapr> Speaking of which, I think I have all the IOHCC stuff on my drive somewhere.
17:57:34 <SamB_XP> that is crazy-sounding
17:57:35 <dons> that too!
17:57:41 <mbishop> SamB_XP: like Beyond Zork! and stuff, the lame ones heh, only Zork I II and III were any good
17:57:53 <SamB_XP> beyond zork?
17:58:11 <SamB_XP> wasn't that just a z5 game?
17:58:21 <kyevan> Someone should rig a zmachine into an irc bot.
17:58:28 <kyevan> That would be weird. And awsome.
17:58:32 <SamB_XP> kyevan: it has been done
17:58:35 <SamB_XP> many times
17:59:08 <shapr> lispy: My self perception is that I'm great with ideas, but not so good with execution of those same ideas. dons has done a much better job of getting lambdabot going. That's also why he's the man in charge of #haskell now.
17:59:21 <shapr> dons++ -- community leader
17:59:35 <mgsloan> I'm like that too
17:59:43 * eviltwin_b three
17:59:51 <shapr> But I'm trying to folow dons' good example and hack more code =)
18:00:02 <shapr> I found a trick that works nicely btw... virtual pair programming.
18:00:18 <mgsloan> huh
18:00:23 <SamB_XP> shapr: do you like zmachine?
18:00:31 <shapr> SamB_XP: Never played with it.
18:00:37 <mgsloan> is that some Agile carp? :P
18:00:55 <SamB> mgsloan: agile techniques aren't bad
18:00:56 <Binkley> shapr: doesn't that defeat the purpose of pair programming?
18:00:58 <shapr> mgsloan: Nah, it's VNC plus Skype, where one person drives and the other person pairs.
18:01:01 <Binkley> ah
18:01:08 <shapr> Binkley: no? how so?
18:01:19 <Binkley> well, I was imagining the people talking to each other on IRC about the code
18:01:19 <SamB> its the patterns that are superfluous!
18:01:29 <shapr> Then after awhile you switch out driving and pairing.
18:01:30 <SamB> because they are invariably stupid versions of FP patterns
18:01:31 <Binkley> I think for it to really work you need videoconferencing
18:01:34 <mgsloan> yeah, thats what i do on my main project
18:01:37 <mbishop> you know what's neat? those new "collabrative editors"
18:01:38 <shapr> Binkley: Nah, video wouldn't help any.
18:01:44 <mbishop> watching people write code in real time :)
18:01:49 <Binkley> because, one of the big advantages of pair programming for me is that I don't get distracted and check email
18:01:51 <Binkley> it's the shame factor
18:02:00 <shapr> All you really need is a shared screenview and an out of band comm channel.
18:02:02 <mgsloan> one guy is swamped with other projects so he can't actually do much code, but he's most knowledgeable in the matter though
18:02:09 <Binkley> I guess with the shared screenview it takes care of that
18:02:17 <shapr> That is, text chat and text editing don't mix, but text editing and voice chat does work.
18:02:24 <mgsloan> mbishop - yeah, i wish subetha was xplat
18:02:26 <Binkley> I guess I'm still skeptical, though
18:02:31 <shapr> Binkley: ok, let's try it.
18:02:36 <Binkley> I think I'd find silence somewhat more awkward with that setup than face-to-face
18:02:39 <Binkley> heh, I don't have a mic
18:02:43 <shapr> Binkley: get one!
18:02:55 <Binkley> where am I going to get a microphone in Cambridge at this time of night
18:02:58 <shapr> It's not about silence, it's about stream of consciousness shared editing.
18:03:01 <Binkley> besides stealing it from the next cubicle
18:03:12 <shapr> steal it from the next cubicle?
18:03:15 <mbishop> mgsloan: there is an open source one, but it's not very advanced yet
18:03:17 <shapr> oh wait
18:03:22 <Binkley> no, I mean, when you're talking to people, in pair programming or not, there are always silences
18:03:30 <Binkley> and I find them more awkward when talking on the phone than when you can see the person
18:03:35 <mgsloan> mbishop - cool, makes sense that there would be one
18:03:38 <mbishop> mgsloan: besides, they aren't gonna get people to switch editors heh...they should make plugins for all the different editors, and just make them work with a server or something
18:03:51 <shapr> Binkley: Bah, let's try it.
18:03:55 <shapr> it'll work fine.
18:04:17 <Binkley> I would, but it'll take me so long just to install Skype that I might as well just go home tonight
18:04:36 <shapr> :-P
18:04:41 <monochrom> Moral: don't argue with shapr :)
18:04:44 <dylan> hmm. where's that pretty printer combinator library?
18:04:44 <Binkley> heh
18:04:45 * shapr grins
18:04:50 <Binkley> and I thought *I* was stubborn
18:05:00 <shapr> I'm not stubborn, I'm just right.
18:05:02 <monochrom> Text.PrettyPrinter.*
18:05:05 <mbishop> hah
18:05:05 * shapr laughs
18:05:15 <shapr> Ok, not really. I'm just willing to try to see if Binkley is right.
18:05:16 <Binkley> I used to have a button that said "I'm not opinionated, I'm just always right"
18:05:21 <dylan> no, I mean the one that uses curses. I need to port it to slang.
18:05:22 <mbishop> does lambdabot keep quotes? because you should add that :P
18:05:27 <mbishop> <shapr> I'm not stubborn, I'm just right.
18:05:30 <shapr> Your .sig is "Often in error, never in doubt."
18:05:36 <Binkley> exactly
18:05:39 <mgsloan> I would switch, if it was good.  I barely use the fancy ass keycode stuff
18:05:44 <bd_> mbishop: @remember
18:05:46 <shapr> mbishop: @remember nick quote goes here.
18:05:51 <Binkley> mbishop: I already added it, though :-)
18:06:01 * shapr snickers
18:06:08 <eviltwin_b> heh
18:06:11 <mbishop> and what's the command to retreive? :D
18:06:15 <Binkley> @quote shapr
18:06:16 <lambdabot>  I have hugged binkley on two different continents, no chat bot there.
18:06:20 * shapr snickers
18:06:23 <mgsloan> frankly to write haskell you don't need insane text editors
18:06:24 <Binkley> apropos!
18:06:33 <Binkley> lambdabot is so smart
18:06:36 <Binkley> lambdabot++
18:06:38 <SamB> hmm
18:06:39 <monochrom> Don't hug and pair-program.
18:06:45 <dylan> insane text editors help me write *english*
18:06:46 <Binkley> not at the same time, anyway
18:06:47 <SamB> something is going on with my cursor...
18:06:49 <Binkley> makes it hard to type
18:06:53 <shapr> SamB: curse it!
18:06:58 <Binkley> unless you're using hugs
18:07:03 <Binkley> but you really should be using ghci anyway
18:07:04 <Binkley> ho ho ho
18:07:06 <mgsloan> dylan - heh, well, english isn't as concise as haskell :)
18:07:11 * SamB_XP hopes dons writes a frontend for his interpreter soon ;-)
18:07:39 <dylan> gq is useful for haskell too
18:07:41 <monochrom> English: "web server".  That's more concise than an Haskell web server code.
18:08:03 <Binkley> the words "web server" and code for a Haskell web server are not operationally equivalent
18:08:04 <dylan> -- | (more than my $wordwrap chars)
18:08:06 <eviltwin_b> it also doesn't tell you very much :)
18:08:12 <mgsloan> monochrom - where's your definition of web server though? you can do that in haskell too, its just referencing a function
18:08:22 <monochrom> Haha
18:08:24 <SamB_XP> @quote me
18:08:25 <lambdabot> me hasn't said anything memorable
18:08:25 <dylan> ^gq$ formats that into a commented paragraph
18:08:29 <Binkley> @quote SamB
18:08:30 <lambdabot>  heh, my ~/.gtkrc.mine is recursive...
18:08:44 * SamB_XP forgot about that one
18:08:44 <mgsloan> keep in mind your English definition needs to fully encompass all aspects of said web server.
18:09:10 <SamB_XP> mgsloan: at least the important ones
18:09:13 <dylan> also d/\$/ is useful in haskell.
18:09:17 <mbishop> @fortune
18:09:18 <lambdabot> Hackathon Moose (or other Ex-Magnificent-Forest-Creature) Barbecue
18:09:18 <lambdabot>  
18:09:18 <lambdabot> 30 cups oil
18:09:18 <lambdabot> 15 cups Soy sauce
18:09:18 <lambdabot> 5 cups Worcestershire Sauce
18:09:20 <lambdabot> [18 @more lines]
18:09:32 <mbishop> @palomer
18:09:33 <lambdabot> (_|_)
18:09:35 <mbishop> haha
18:10:12 <sjanssen> @keal
18:10:12 <lambdabot> the [nsa] even make light green both ways once
18:10:26 <sjanssen> hahaha
18:10:27 <shapr> @protontorpedo
18:10:27 <lambdabot> ok so say I ftp files from some 50 remote servers now, and then read them inot mysql, then ftp back to an ohter 50 servers some info they read into thier informix db
18:10:38 <Binkley> @quote qwe1234
18:10:39 <lambdabot>  i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
18:10:55 * mgsloan just realized why _|_ is bottom - look at (_|_) very carefully
18:11:15 <LoganCapaldo> \bot
18:11:16 <monochrom> So why is it not (_|_)?
18:11:34 <Binkley> "Accordingly, computer scientists commonly choose models which have bottoms, but prefer them topless." -- Davey & Priestley, _Introduction to Lattices and Order_
18:11:37 <shapr> So, who's in the USA and wants to have an AmeriHaskell?
18:11:37 <mbishop> oh god, qwe1234, a troll amongst trolls
18:11:42 <mgsloan> uh, maybe it was supposed to be an operator, and that's just its prefix form?
18:11:44 <Binkley> shapr: I'd love that
18:11:48 <Binkley> in two weeks
18:11:50 <Pseudonym> We wish you a merry Haskell...
18:11:55 <Binkley> Oh my god two weeks :-(
18:12:48 <sjanssen> shapr: I'd consider coming to an AmeriHaskell
18:12:50 <dylan> hmm, is there a performance reason for using only 1 TVar?
18:12:56 <eviltwin_b> 1 week for some of us :>
18:12:58 <Binkley> we have three people, that's a quorum
18:13:23 * eviltwin_b would love to, but if he could travel he'd be in DC right now instead of monitoring stuff in another channel :/
18:13:26 <shapr> sjanssen, Binkley: Ok, where are/will you be?
18:13:28 <mbishop> depends on where you hold it as if I would go or not (probably not though) :P
18:13:35 <Binkley> shapr: *I wish I knew*
18:13:40 <sjanssen> shapr: I'm in Nebraska
18:13:45 <Binkley> however, I'll be in CA at least for the end of December and early January
18:13:46 <shapr> I'm in Alabama.
18:13:49 <mattrepl> I'm in..  VA here
18:13:54 <shapr> eviltwin_b: where are you?
18:14:01 <eviltwin_b> Pittsburgh, PA
18:14:03 <Binkley> Ok, let's just average all those points...
18:14:20 <dylan> shapr: so, you still coming down to FL?
18:14:21 <mbishop> I'm in Louisiana :/
18:14:24 <shapr> It sounds like it's mostly east coast so far.
18:14:51 <shapr> dylan: Yeah, it's likely. My sister lives somewhere outside of Orlando.
18:15:01 <eviltwin_b> and, well, time off for hacking probably wouldn't cut it
18:15:08 * eviltwin_b doesn't get to hack much any more
18:15:13 <dylan> hmm, that's LEAP territory.
18:15:29 <shapr> eviltwin_b: c'mon, it'll be fun!
18:15:50 <shapr> LEAP?
18:15:55 <dylan> (LEAP being a linux user's group)
18:16:00 <shapr> oh
18:16:22 <kyevan> dylan: I thought you were strict and said GNU/Linux? :P
18:16:23 <eviltwin_b> not saying I don't wnant to, just that $work probably wouldn't be overjoyed
18:16:28 <kyevan> (I'm teasing)
18:16:33 <mbishop> There's never any LUGs or groups or meetings for anything technical here :[
18:16:39 <dylan> it has some lout member that used to troll my LUG. He once argued that a spreadsheet and a rational database are interchangeable
18:16:49 <kyevan> mbishop: Join the club :)
18:17:00 <mbishop> kyevan: where are you from?
18:17:02 <dylan> err, relational database.
18:17:07 <SamB_XP> dylan: well, if you don't care about performance and you aren't using excel!
18:17:12 <SamB_XP> maybe they are!
18:17:21 <eviltwin_b> I'd actually argue that they are, but each tool is better for certain kinds of things
18:17:30 <kyevan> mbishop: south-centeral wisconsin, but, nocar and stuff, so, no way to get to madison which is near by and has stuff
18:17:41 <eviltwin_b> ...sadly too many people ry to force spreadhseets to be full RDBMSes
18:17:43 <dylan> SamB_XP: Well, I cited Codd's paper which said an array of n-tuples if a *implementation* of a relational database, but not its definition.
18:17:49 <shapr> I dunno, spreadsheets seem thoroughly untyped to me. And databases don't do dataflow calculations.
18:18:07 <dylan> SamB_XP: and a spreadsheet, on the other hand, is by definition a 2d array
18:18:11 <eviltwin_b> and, while it's often possible, the effort required and resulting performance are usually not worth it
18:18:12 <mgsloan> eviltwin_b: it's sadder when people use spreadsheets as a functional programming language
18:18:12 <shapr> I think some people in Madison are still thoroughly unhappy with me.
18:18:13 <LoganCapaldo> shapr: They do if you abuse views
18:18:22 <mbishop> kyevan: I don't have a car either...old enough, and have the money kind of...just don't really want to drive heh, but New Orleans is about 60 miles away :\
18:18:55 <shapr> What about Atlanta? Or is that not enough of a geographical compromise?
18:19:10 <mgsloan> mbishop - easily manageable in a day on bike
18:19:40 <mbishop> mgsloan: hahah, maybe for a professional
18:19:42 <shapr> Hmm, chicago may be cheaper for airfare.
18:19:58 <mgsloan> mbishop: i've done it, easily 5-6 hours
18:20:07 <shapr> You could use my unicycle =)
18:20:19 <mgsloan> i was tired as hell after, sure, but still
18:20:21 <kyevan> mbishop: Are the NO lugs and such running again yet?
18:20:27 <dylan> re: TVars... should I make my datastructure from TVars or use one pure structure and wrap a TVar around it?
18:20:33 <mgsloan> there are people here that go 200miles in one day
18:20:37 <mbishop> I wouldn't mind traveling to Chicago...would have to find someome to stay with :P
18:20:43 <kyevan> shapr: What did you do that made some Madisonians mad?
18:20:44 <mgsloan> though that day starts really early and ends really late
18:20:52 <mbishop> kyevan: I don't know, never went to any..I would imagine so though...most people are back
18:20:54 <kyevan> Say you like GWB or something?
18:20:57 <shapr> kyevan: You *really* don't want to know.
18:21:15 <mgsloan> and that usually only happens once a year (seattle-to-portland) - some people go the whole way in a day
18:21:23 <kyevan> Vote for the gay marage amendment?
18:21:25 <shapr> I promise, you're too young. *I*'m too young.
18:21:46 <monochrom> Whee!  I know category theory!
18:22:02 <eviltwin_b> ...and it killed him?
18:22:06 <kyevan> Try to have sex with the statue on top of the state capitol?
18:22:12 <kyevan> (I think someone tried that, once.)
18:22:14 <dylan> heh
18:22:29 <kyevan> One of the UW-M students, I think
18:22:33 * dylan glares at kyevan and mutters things about restraint
18:22:39 <shapr> Anyway, is Chigaco cheaper than Atlanta for airfare from around the country?
18:22:40 <kyevan> After the State Street party
18:23:04 <shapr> And, which city is more likely to give us a cheap or free venue with wifi?
18:23:08 <shapr> hmm
18:23:19 <Binkley> I would go to Chicago
18:23:22 <Binkley> I've never been
18:23:24 <Binkley> and I have a friend there
18:24:11 <mbishop> I'd need someone to stay with, because I'm too cheap to get a hotel :P
18:24:26 <kyevan> shapr: I know Madison was going to do downtown wifi... I think it fell through
18:24:37 <mgsloan> http://njhurst.com/~njh/blog/20061123 <- interesting, in regards to the car vs alternative transports thing
18:24:39 <lambdabot> Title: njhs weblog
18:24:41 <kyevan> You could, um, probably bum off a starbucks in some place :P
18:25:09 <Binkley> mbishop: are you sufficiently profligate for a youth hostel?
18:25:28 <mbishop> profligate?
18:25:35 <Binkley> @google define profligate
18:25:37 <lambdabot> http://www.thefreedictionary.com/profligate
18:25:37 <lambdabot> Title: profligate - definition of profligate by the Free Online Dictionary, Thesaurus a ...
18:25:50 <kyevan> Car? I prefer to travel by cdr, personally.
18:25:50 <Binkley> what can I say, it was a GRE word
18:26:06 <mgsloan> lol
18:26:15 * SamB_XP likes tail better
18:26:23 <sjanssen> Chicago sounds nice to me.  I could even drive there if I was feeling cheap
18:26:24 * mbishop prefers last
18:26:31 * sjanssen prefers foldr
18:26:42 * Binkley prefers intersperse
18:26:47 <SamB_XP> sjanssen: how do you travel by foldr
18:26:52 <Binkley> SamB: uniformly
18:26:58 <SamB_XP> Binkley: how do you travel by intersperse?
18:27:07 <dibblego> I have a newtype T a = T U but I don't want the T U type constructor exposed - I vaguely recall reading about this somewhere - what is it called and where can I read about it?
18:27:08 <mgsloan> i suppose cdr would make sense, decrementing the list representing your path to the destination
18:27:20 <sjanssen> SamB_XP: foldr drive stop [a..b] -- to travel from point a to point b
18:27:21 <Binkley> SamB: with lots of layovers
18:27:30 <SamB_XP> Binkley: heh
18:27:48 <SamB_XP> what if b < a?
18:27:50 * mgsloan likes rest better
18:28:08 <sjanssen> SamB_XP: why would I travel to a lesser place?
18:28:16 <Binkley> SamB: then it's a short drive
18:28:23 <SamB_XP> sjanssen: oh, you get one-way tickets?
18:28:54 <eviltwin_b> exporting T exports only the type, you need to list the constructors after (T (T) or T (..))
18:29:45 <dibblego> eviltwin_b, yes I recall something like that, but I want to know what I was reading about i.e. the keyword of what it is I am doing and where I can read about it
18:30:00 <kyevan> So, once do comes into the equation, does haskell get evaluated strictly instead of lazily, or what?
18:30:10 <dibblego> kyevan, lazy
18:30:14 <mgsloan> do is syntax sugar
18:30:21 <bd_> kyevan: do is just sugar for >> and >>= and some lambdas
18:30:24 <sjanssen> kyevan: always lazily
18:30:37 <mgsloan> i really think the beginner tutorials should hit the explicit syntax first
18:30:44 <base_16> >> is something of an un-lazy operator, though
18:30:44 <bd_> kyevan: The only thing 'strict' about it is that it specifies an ordering in the monad, which may or may not be the actual execution order, depending on the monad in question
18:30:49 <sjanssen> kyevan: the RTS takes care of executing your actions such that things happen in the correct order
18:30:49 <mgsloan> (reassure that there is a better way beforehand though)
18:30:50 <dibblego> I spent yesterday with some guys rewriting Maybe and instance Monad MyMaybe - that helped them understand the answer to your question
18:31:09 <dons> ?undo do x <- getChar ; y <- transform x ; putChar y ; return ()
18:31:09 <lambdabot> getChar >>= \ x -> transform x >>= \ y -> putChar y >> return ()
18:31:15 <dons> just a simple functional program
18:31:18 <dons> (and lazy)
18:31:18 <dibblego> I think the beginner's tutorials shouldn't call it (>>=), but instead bind or something
18:31:22 <bd_> :t transform
18:31:24 <lambdabot> Not in scope: `transform'
18:31:26 <dons> but with an evaluatoin order coded in
18:31:28 <base_16> i'm still learning, but i can say that the 'do' keyword really screwed things up for me when i was starting
18:31:54 <dons> ?pl getChar >>= \ x -> transform x >>= \ y -> putChar y >> return ()
18:31:55 <dibblego> base_16, don't start with do - start with >>=, then learn what do is and does
18:31:55 <lambdabot> (>> return) . putChar =<< transform =<< getChar
18:31:57 <bd_> it does look a bit like an entirely different language bolted on... :p
18:31:57 <dons> hehe
18:32:13 <dons> its really very light sugar though
18:32:16 <dons> as you can see above
18:32:16 <kyevan> bd_: ">> and >>= and some lambdas"?
18:32:17 <mgsloan> dibblego - if only that was the way the books and tuts taught it
18:32:18 <base_16> dibblego: yeah, eventually i found a tutorial that explained >>=, >>, and return-- and i felt much better
18:32:34 <dibblego> tutorials say "do is really just syntax sugar for...", instead, they should teach the other way around - introduce do later
18:32:40 <mgsloan> dons - not that light, with the variable decls and stuff, expands into lambdas and such
18:32:49 <bd_> kyevan: pretty much. like, do { x; y} is really x >> y. do { foo <- x; y } is x >>= \foo -> y
18:32:55 <kyevan> dibblego: YAHT didn't even say that...
18:32:55 <mgsloan> dibblego: i definitely agree
18:32:58 <dons> its a small enough translation that we can write a lambdabot plugin for it though
18:33:05 <dons> and 1 line only expands to 1.5 lines
18:33:07 <kyevan> bd_: I mean, what are >> and >>= and?
18:33:14 <bd_> kyevan: they're operators on monads;
18:33:18 <bd_> x >> y <-- does x, then does y
18:33:31 <dibblego> dons, it is small, it is simple and once you understand it, it is not scary -- but it is not simpleness or smallness that needs to be overcome - it is the scariness
18:33:35 <bd_> x >>= f <-- does x, applies f to its return value, does the monad resulting from it
18:33:41 <mgsloan> dons - true. then again lambdabot plugins can be pretty smart
18:33:44 <dons>     m >> k      =  m >>= \ _ -> k
18:33:44 <dons>     return x    = returnIO x
18:33:44 <dons>     m >>= k     = bindIO m k
18:33:46 <bd_> so for example
18:33:48 <dibblego> if we replace >>= with `bind` and introduce that first, then the step is smaller
18:33:57 <dons> bindIO (IO m) k = IO ( \ s ->
18:33:57 <dons>   case m s of
18:33:57 <dons>     (# new_s, a #) -> unIO (k a) new_s
18:33:57 <dons>   )
18:34:03 <dons> returnIO x = IO (\ s -> (# s, x #))
18:34:05 <SamB_XP> dibblego: how can it be scary if the translation is easy?
18:34:05 <dons>  
18:34:13 <bd_> getChar >>= \ characterWeRead -> putStrLn $ "Hey! You typed '" ++ [characterWeRead] ++ "'!"
18:34:18 <dibblego> SamB_XP, because of existing preconceived ideas
18:34:24 <dons> i.e. just a buch of cases , in the IO monad
18:34:29 <dibblego> SamB_XP, why are snakes scary?
18:34:41 <SamB_XP> because people think they might be poisonous
18:34:51 <dibblego> irrational fear
18:34:53 <SamB_XP> usually they aren't though
18:34:59 <SamB_XP> (at least, around here!)
18:35:00 <dibblego> they aren't in your country at least
18:35:07 <dibblego> and even if they are, the danger is low
18:35:11 <SamB_XP> yeah
18:35:19 <SamB_XP> the rattlers are obviously not looking to bite you
18:35:26 <bd_> kyevan: I found this helpful when I was starting out http://www.nomaware.com/monads/html/index.html
18:35:29 <lambdabot> Title: All About Monads
18:35:43 <dibblego> so, a snake *might* be poisonous and if it is, it *might* bite, but only if I stir it up (the chance is remote) and even *then* the chance of death is low (we have anti-venoms)
18:36:02 <dibblego> in Australia, most snakes are poisonous
18:36:03 <mgsloan> I don't think its an issue of fear, so much as ambiguity - the do notation sets the functions used within apart from the others - as kyevan pointed out with questioning earlier
18:36:19 <dibblego> I find it irrational to be scared of a snake then jump in a car and drive down a street
18:36:22 <dons> ok, so who's going to release some new code today?
18:36:24 <mgsloan> the others -> normal, pure functions
18:36:28 <dibblego> likewise, the bind operator...
18:36:28 <dons> anyone got anything almost finsihed?
18:36:38 <dons> SamB_XP: you must have some code lying around?
18:36:49 <dons> I want 7 releases a week, minimum!
18:36:50 <SamB_XP> dons: I pushed some patches to my ZMachine repo!
18:36:55 * eviltwin_b is tracking Usenix and LOPSA meetings over IRC, no coding tonight
18:36:56 <dons> great!
18:37:00 <mgsloan> lol, dons is getting hungry for codez
18:37:00 <dons> when's the release date, SamB_XP
18:37:03 * dylan is working on a chat client UI using his slang binding
18:37:04 <eviltwin_b> (then I get to clean litter boxen.  whee!)
18:37:07 <SamB_XP> release date?
18:37:16 <dons> yeah, gimme some lambda warez!
18:37:24 <dons> come on slackers!
18:37:31 <mbishop> 0day haskell codez
18:37:35 <SamB_XP> what is this "release" thing anyway?
18:37:41 <dons> we ain't going to take over the world without the code to do so
18:37:48 <bd_> SamB_XP: it's when you disown a project
18:37:55 <dons> heh
18:37:58 <SamB_XP> bd_: why would I want to do that?
18:38:06 <bd_> SamB_XP: Well, for example, in case of death.
18:38:08 <dons> anyone want to add STM lock free concurrency to lambdaobt?
18:38:14 <dibblego> is an IntMap (IntMap a) really the best way to write a 2 dimensional array?
18:38:16 <SamB_XP> you can steal it now too!
18:38:17 <dons> i'll have 16 cores for her to run on soon..
18:38:25 <sjanssen> dons: what kind of concurrency does lambdabot use now?
18:38:26 <dons> dibblego: hmm no.
18:38:28 <SamB_XP> did I not remember to explicitly place it under the BSD3 license?
18:38:30 <dons> sjanssen: forkIO
18:38:37 <dons> (on every request -- so that's good)
18:38:41 <dons> its already highly parallel
18:38:46 <mgsloan> sorear - you should stick your geom stuff in a darcs repo before your computer dies or something ;P
18:38:47 <dibblego> then what is?
18:38:48 <sjanssen> and MVars for synchronization?
18:38:51 <dons> yep
18:38:54 <SamB_XP> dibblego: for what usage?
18:38:56 <dons> per module state is MVard
18:39:01 <dons> and the global state is too
18:39:10 <sjanssen> there probably isn't much benefit to moving to STM
18:39:12 <dons> wouldn't be hard to add lock free module-private state
18:39:21 <dons> sjanssen: but it'd be fun
18:39:21 <dibblego> SamB_XP, to backtrack; lots of insert but a known m and n prior
18:39:54 <SamB_XP> hmm.
18:40:13 <dibblego> I can't find anything better than IntMap (IntMap a)
18:40:26 <SamB_XP> well, I hardly see how a Map (Int, Int) would be better ;-)
18:40:30 <dons> how about Map (Int,Int) a
18:40:39 <dons> or Array (Int,Int) a
18:40:54 <SamB_XP> dons: that doesn't use radix stuff
18:41:08 <SamB_XP> the former, I mean...
18:41:25 <dibblego> yeah Map(Int, Int) a might work
18:41:33 <kyevan> it's almost like... Haskell was DESIGNED to be confusing
18:41:35 <SamB_XP> the latter isn't good for inserts
18:41:37 <SamB_XP> kyevan: hah
18:41:47 <SamB_XP> kyevan: I think you are referring to C++
18:41:48 <kyevan> So that people who got through it, knew they were special.
18:41:50 <kyevan> Or something.
18:41:53 <Cale> Reddit is still scoring 19/100 for me
18:41:59 <dibblego> well, it's better for seek; and I'm doing both equally, so I'll go with Map
18:42:18 <Cale> and glguy, I modded up your link
18:42:36 <kyevan> SamB_XP: I haven't tried learning C++, from what I've seen, simple c++ is readable pretty easily, complex C++ makes me want to hide in the closet.
18:42:47 <kyevan> (I'm not refering to my sexuality, either)
18:42:59 <SamB_XP> kyevan: why would you be referring to your sexuality
18:43:12 <SamB_XP> I can totally sympathize with wanting to hide in a closet
18:43:13 <Binkley> "hide in the closet"
18:43:16 <dibblego> I wouldn't want to have sex with C++ either
18:43:25 <SamB_XP> Binkley: yes, but, this is C++ we are talking about
18:43:32 <Binkley> C++ is for asexuals
18:43:43 <dons> masochists
18:43:53 <SamB_XP> C++ is scary enough that a literal closet would obviously be the correct interpretation ;-)
18:44:08 <dons> clearly C++ programmers enjoy pain
18:44:24 <SamB_XP> I don't know why I keep signing up for C++ classes
18:44:37 <dibblego> "clearly" to you perhaps, but not the C++ programmer
18:44:39 <SamB_XP> probably because my college doesn't have enough relevant classes
18:44:52 <kyevan> SamB_XP: Because it, C#, and Java are what employers in the Real World expect?
18:44:53 <base_16> SamB_XP: because lots of people will pay for c++ programming :/
18:45:04 <bd_> kyevan: Haskell's only confusing until you understand it :D
18:45:06 <SamB_XP> I'm going to have to go to a four year college next year!
18:45:07 <Excedrin> C++ is ideal only for programmers without any ethics
18:45:12 <mgsloan> C++ isn't that bad
18:45:13 <base_16> Excedrin: why do you say that?
18:45:15 <dibblego> I think the distinction with the "Real World" is highly amusing
18:45:20 <Binkley> but I thought Haskell was a bondage and discipline language
18:45:31 <mgsloan> template system is kinda like dependent types :)
18:45:38 <SamB_XP> Binkley: it is. but no whips and chains!
18:45:38 <Excedrin> base_16: quoting Erik Naggum
18:45:44 <base_16> haha, nice
18:45:46 <dons> big on discipline yep. the type checker is a cruel mistress, who suffers no fools
18:46:08 <kyevan> dons: So that's why I hate it.
18:46:22 <SamB_XP> kyevan: you are a fool?
18:46:27 <dons> Its all about discipline and Control.Monad in Haskell
18:46:36 <Binkley> I controlled your mom's monads last night
18:46:39 * kyevan always responds better to calm "No, you should do this" than "NEVER DO THAT IDIOT DO THIS INSTEAD YOU IDIOT"
18:47:15 <dylan> ghc is very calm
18:47:20 <Binkley> really?
18:47:24 <dylan> it's: "This doesn't make any sense."
18:47:24 <Binkley> ghc seems to panic an awful lot when I use it
18:47:45 <kyevan> Hmm... Do you think chicks dig haskell hackers more than C++ hackers?
18:47:50 <dibblego> p -> (logical negation)p -- this doesn't make any sense, so please stop, oh and you're not an idiot
18:47:52 <dons> some people might find this amusing, http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/07#silver_bullets
18:47:53 <lambdabot> Title: Haskell, hacking and other stuff
18:48:06 <bd_> "I'm sorry, your program is provably impossible, and therefore does not exist."
18:48:20 <audreyt> You program vanishes in a puff of logic! --More--
18:49:05 <Binkley> kyevan: I know I do
18:49:10 <Binkley> not that I'm necessarily a chick
18:50:57 <dylan> "Haskell or C++: What does young poultry prefer?"
18:51:00 <Binkley> dons: it'd be more amusing if you rewrote it to be about Haskell
18:51:03 <dons> mmm, very interesting comments here :  http://programming.reddit.com/info/twtt/comments
18:51:04 <lambdabot> Title: Functional programming is a silver bullet (reddit.com)
18:51:08 <dons> Binkley: heh.
18:51:16 <Binkley> if you did, I actually might post my parody of "Put Your Hand Inside the Puppet Head" that's about strictness analysis somewhere public
18:51:16 * dons tries
18:51:23 <kyevan> Binkley: You don't count. You're one of us.
18:51:37 <Binkley> kyevan: well, there's your answer. if you program in Haskell ,other Haskell hackers will find you hot
18:51:43 <Binkley> as far as I'm concerned, that's all you need
18:51:45 <Olishna> morning all
18:52:07 <kyevan> Binkley: I'm interested in humans my age, though
18:52:12 <dons> Binkley: you're working on strictness analysis stuff in GHC this year, yeah?
18:52:32 <kyevan> And I think that I'm probably the only even newbie haskell user in a hundred mile radius in my age group :P
18:53:00 <Binkley> dons: yes
18:53:05 <dons> (just pondering if things are going to improve for the stream fusion optimisations/specConstr and so on)
18:53:48 <Binkley> dons: hrm, not sure that anything is going to improve anytime soon
18:53:56 <sjanssen> kyevan: where are you?
18:54:03 <Binkley> i've rewritten the analysis, but not in a way that much of the extra information gets used downstream, that is
18:54:09 <mgsloan> kyevan: yeah, and noone in your age group is going to find c++ hot either
18:54:12 <mgsloan> not for a while
18:54:15 <Binkley> mgsloan: good point!
18:54:25 <mgsloan> and even then, not much ;p
18:55:22 <kyevan> sjanssen: Oregon, WI
18:57:07 <br1> I happen to like C++ a lot.  Nowadays, Haskell is taking more of my love than C++, but C++ is still the language I go to when programming in a hurry.
18:58:12 <kyevan> Hmm.
18:58:13 <kyevan> :/
18:58:25 <kyevan> How can I make a string, an int?
18:58:42 <SamB> :t ""
18:58:43 <lambdabot> [Char]
18:58:45 <mgsloan> read
18:58:53 <SamB> :t 0::Int
18:58:55 <lambdabot> Int
18:58:56 <mgsloan> a very cool function, by the way
18:58:58 <LoganCapaldo> template <typename T> class Maybe { static Just(T & x) :-p
18:59:04 <mgsloan> > read "123" :: Int
18:59:06 <lambdabot>  123
18:59:17 <mgsloan> it infers what to do by the return type :)
18:59:22 <bd_> :t read
18:59:23 <lambdabot> forall a. (Read a) => String -> a
18:59:30 <Excedrin> ?type read
18:59:32 <lambdabot> forall a. (Read a) => String -> a
18:59:32 <SamB> LoganCapaldo: ick indeed!
18:59:43 <SamB> you have to pass in a phantom value?!?!?!
18:59:50 <LoganCapaldo> ?instances Read
18:59:51 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
18:59:53 <SamB> and C++ doesn't even have bottom!
19:00:11 <SamB> ?instances Show
19:00:12 <bd_> > read "[(4, \"hello, world\")]" :: [(Int, String)]
19:00:13 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
19:00:14 <lambdabot>  [(4,"hello, world")]
19:00:23 <SamB> why not (->)!
19:00:33 <mgsloan> > read "True" :: Bool
19:00:35 <lambdabot>  True
19:00:42 <Excedrin> > read "True" :: Int
19:00:44 <lambdabot>  Exception: Prelude.read: no parse
19:00:48 <SamB> oh wait
19:00:50 <SamB> I remember now
19:00:52 <LoganCapaldo> print . eval . read
19:01:00 <SamB> its nothing that doesn't take a value!
19:01:13 <SamB> LoganCapaldo: what does the Nothing method look like?
19:01:31 <dons> Binkley: coming down to Oxford for the hackathon?
19:01:37 <dons> Binkley: interested, at least?
19:01:41 <dons> ?wiki Hac_2007
19:01:41 <lambdabot> http://www.haskell.org/haskellwiki/Hac_2007
19:01:49 <Excedrin> > reads "True" :: [(Int,String)]
19:01:51 <lambdabot>  []
19:01:58 <Binkley> dons: I wish I could, I'm going to be back in the US by then, though
19:02:00 <mgsloan> :t reads
19:02:02 <lambdabot> forall a. (Read a) => ReadS a
19:02:05 <LoganCapaldo> That shouldn't really be the Just method. It needs to actually call the constructor to make an actual value
19:02:09 <dons> ah ok pity
19:02:20 <Binkley> yeah
19:02:32 <SamB> LoganCapaldo: it is a static method!
19:02:51 <dylan> hmm
19:03:01 * dylan wonders how to mess with nested tvars and atomically.
19:03:05 <mgsloan> I've got a maybe.h in my c++ project
19:03:13 <LoganCapaldo> SamB: Yeah I still need to be like Maybe<T> x; return x to get something out of it
19:03:27 <bd_> dylan: nested atomically? oO
19:03:33 <mgsloan> ?where rafb
19:03:34 <dylan> well, nested TVars.
19:03:34 <lambdabot> http://rafb.net/paste
19:03:39 <SamB> return Maybe<OhHowIWishThereWereUsefulTypesInCPlusPlus>::Nothing(); // ?
19:03:45 <bd_> dylan: readTVar x >>= readTVar?
19:03:45 <LoganCapaldo> I need to stop writing pseudo haskell in other languages I think its bad for me :)
19:03:57 <dylan> bd_: not nested like that
19:04:00 <LoganCapaldo> Nothing could be a constant
19:04:09 <LoganCapaldo> static Maybe<T> Nothing;
19:04:14 <kyevan> Hmm. I want tits instead of bits
19:04:16 <LoganCapaldo> Hmm
19:04:20 <LoganCapaldo> no it couldn't
19:04:22 <kyevan> 0, 1, or 2
19:04:27 <kyevan> Imagine the things we could do!
19:04:34 <LoganCapaldo> oh wait yes it could
19:04:38 <dylan> like: data UI = UI {title :: String, content :: [String], entry   :: TVar CursorString }
19:04:42 <LoganCapaldo> it would just require a little more work
19:04:47 <mgsloan> http://rafb.net/paste/results/ECuNzX79.html
19:04:53 <LoganCapaldo> because of the template param
19:04:54 <dibblego> a Maybe<T> must be either a Nothing<T> or a Just<T> - you must restrict this
19:04:59 <bd_> kyevan: data Toolean = One | Two | Three deriving (Show, Eq, Ord, Bounded, Read)
19:05:15 <ozone> there's a boost::optional type that's pretty much the same as Maybe
19:05:33 <SamB> kyevan: oh, I thought you meant something else at first...
19:05:40 <eviltwin_b> aside from not being a MonadPlus, presumably
19:05:41 <SamB> those aren't called tits
19:05:43 <ozone> i'd like parser combinators in C++
19:05:47 <SamB> those are called trits
19:06:04 <kyevan> SamB: But, then we don't get all the puns to keep abreast of!
19:06:07 <Excedrin> SamB: class Nothing {};
19:06:12 <Binkley> kyevan: you really are one of us
19:06:20 <LoganCapaldo> ozone: What about Boost::Spirit
19:06:30 <ozone> LoganCapaldo: that's a little bit too far left-wing for me :)
19:06:38 <SamB> @. pl . djinn type (.).(.)
19:06:40 <lambdabot> f = (.) . (.)
19:06:41 <dibblego> @put maybe-in-java http://blog.tmorris.net/maybe-in-java
19:06:42 <lambdabot> Maybe you meant: ft let part pl quit run
19:07:01 <SamB> hmm.
19:07:16 <SamB> @. pl . djinn type (.)(.)
19:07:18 <lambdabot> f = ((.) .)
19:07:21 <SamB> eek
19:07:43 <LoganCapaldo> i just posted my ruby maybe
19:07:44 <bd_> @. pl . djinn type join (***)
19:07:45 <lambdabot> Cannot parse command
19:07:48 <bd_> aw
19:07:50 <bd_> @. pl . djinn type join(***)
19:07:52 <lambdabot> Cannot parse command
19:08:25 <bd_> LoganCapaldo: I wrote a monad library in perl once. It even supported typeclasses... sort of.
19:08:54 <LoganCapaldo> that must have been thrilling
19:09:02 <bd_> Monad::Maybe::fromJust(Monad->mzero->mplus(Monad->m_return(24))); :D
19:09:24 <ozone> bd_: see FC++ if you want some serious brain damage :)
19:09:25 <dons> ?users
19:09:26 <lambdabot> Maximum users seen in #haskell: 278, currently: 248 (89.2%), active: 39 (15.7%)
19:09:29 <bd_> ozone: FC++?
19:09:32 <dons> hey, new record 278!
19:09:39 <ozone> yeah, google around, it should be the first hit or so
19:09:45 <dons> ?google monads in C++
19:09:47 <lambdabot> http://www-static.cc.gatech.edu/~yannis/fc++/FC++.1.5/monad.h
19:09:50 <dons> there ^^
19:09:52 <ozone> that'd be it
19:10:01 <ozone> it is... somewhat insane
19:10:23 <ozone> s/somewhat/totally/
19:10:29 <Binkley> monadic parsers in C#!
19:10:48 <LoganCapaldo> monadic parsers in F#
19:10:57 <Binkley> that's a little less insane
19:11:18 <LoganCapaldo> decreasing insanity is good
19:11:39 <Binkley> yes, insanity should be a monotonically decreasing function
19:12:34 <dons> ozone, written any smp parallel haskell yet?
19:13:13 * eviltwin_b 's eyes are bleeding
19:13:31 <dons> C++'ll do that
19:13:37 <dons> it should come with a warning from your optometrist
19:13:48 <dons> "may induce glaucoma"
19:13:48 <mbishop> I saw Riastadh wrote something for monads in scheme :P
19:13:55 <Binkley> actually, you need special glasses for C++
19:14:04 <Binkley> they rewire your brain so that the inheritance rules make sense
19:14:08 <kyevan> mrah.
19:14:15 <dons> ?wiki Monad
19:14:15 <lambdabot> http://www.haskell.org/haskellwiki/Monad
19:14:22 <dons> mbishop: lots of foreign monads ^6
19:14:23 <kyevan> "foldr (+) [1,2,3,4,5,6,7,8,9]"
19:14:27 <kyevan> That should work, right?
19:14:27 <mbishop> http://mumble.net/~campbell/scheme/monad.scm
19:14:33 <Binkley> only one way to find out...
19:14:39 <Binkley> > foldr (+) [1,2,3,4,5,6,7,8,9]
19:14:41 <lambdabot>  add an instance declaration for (Num [a])
19:14:47 <Binkley> see? it doesn't work. ;-)
19:14:51 <Binkley> you missed the second argument
19:14:53 <kyevan> Binkley: ...
19:15:01 <kyevan> Binkley: Oh?
19:15:03 <dylan> dons: speaking of parallel haskell -- can you tell me if it's not advisable to layer TVar structures?
19:15:07 <kyevan> What's the second argument?
19:15:08 <Binkley> > foldr (+) 0 [1,2,3,4,5,6,7,8,9]
19:15:09 <lambdabot>  45
19:15:11 <kyevan> o
19:15:13 <kyevan> Oh, right
19:15:13 <Binkley> it can be whatever you want
19:15:14 <eviltwin_b> you need a seed
19:15:15 <dons> dylan: not sure. sounds a bit suspicious
19:15:17 <Binkley> but presumably you want zero
19:15:20 <kyevan> The default value
19:15:21 <dons> be like layering MVars I guess
19:15:26 <Binkley> well, whatever you want so long as it's of the right type
19:15:41 <bd_> dylan: Well, you won't deadlock with yourself at least.
19:18:14 <sjanssen> dylan: layer?
19:18:51 <dons> OT, but hehe "Dont read Reddit if you arent a flaming liberal Democrat who hates Jesus and likes to laugh at Scientology while programming Lisp."
19:18:56 <dylan> e.g. data UI = UI {title :: String, content :: [String], entry :: TVar CursorString }
19:18:59 <Binkley> haha
19:19:01 <Binkley> sign me up!
19:19:21 <dylan> and then have TVar UI stuff somewhere else
19:19:36 <sjanssen> dylan: that's perfectly safe.  You might have performance problem if you try to read tons of TVars in a single transaction
19:19:39 <Binkley> dons, do you have a link to that comment?
19:20:13 <LoganCapaldo> I don't think I'm a flaming liberal, I don't hate Jesus as far as I know, nor do I program Lisp. However I do like to to laugh at scientology. Do I have to revoke my reddit reading privileges?
19:20:26 <dylan> sjanssen: is it sane?
19:20:29 <bd_> LoganCapaldo: You may only read it on alternate thursdays, in that case.
19:21:14 <sjanssen> dylan: sure
19:21:39 <dylan> sjanssen: oh. Cool. it seemed like a nifty idea at the time. :)
19:22:22 <mbishop> programming.reddit.com is fine, anything else is just...ugh
19:22:58 <SamB_XP> what is wrong with making fun of the clams?
19:23:57 <kyevan> Hmm...
19:24:37 <kyevan> How do I un read?
19:24:48 <kyevan> (eg, take a number, make a string)
19:24:54 <Binkley> kyevan: show
19:25:05 <dibblego> ?type show
19:25:07 <lambdabot> forall a. (Show a) => a -> String
19:25:18 <bd_> kyevan: You can have the compiler generate show and read implementations for your own types automatically, btw
19:25:31 <bd_> eg, data Foo = Bar | Baz Quuz | ... deriving (Show, Read)
19:25:39 <dylan> hmm, I fail to see the advantage of using more than one tvar now... what was I thinking?
19:27:17 <kyevan> So... "show (foldr (+) 0 numList)"?
19:27:28 <Binkley> > show (foldr (+) 0 numList)
19:27:29 <lambdabot>  Not in scope: `numList'
19:27:41 <Binkley> > show (foldr (+) 0 [1..10])
19:27:42 <lambdabot>  "55"
19:27:51 <kyevan> huh.
19:27:59 * kyevan pokes his code some more
19:28:05 <sjanssen> kyevan: show . sum $ numList -- this is even better
19:28:22 <Binkley> For some definitions of "better".
19:28:42 <kyevan> I dunno what $ does, though
19:28:55 <SamB_XP> it doesn't do anything ;-)
19:29:07 <sjanssen> kyevan: show (sum numList) -- is the same, but clearer
19:29:37 <bd_> kyevan: $ just frobs precedence a bit
19:29:38 <bd_> like
19:29:40 <sjanssen> kyevan: I was just trying to show you that there's already a sum function
19:29:44 <bd_> f g h = (f g) h
19:29:48 <bd_> f $ g h = f (g h)
19:29:50 <Binkley> if you're still learning, though, you want to figure out what foldr does
19:29:51 <kyevan> Hm...
19:29:54 <kyevan> putStrLn (show (sum numList))
19:29:55 <kyevan> ...
19:30:11 <bd_> :t print
19:30:12 <mbishop> I hate single letter vars/functions
19:30:13 <lambdabot> forall a. (Show a) => a -> IO ()
19:30:54 <Binkley> kyevan: you can also say print (sum numList) and that does the same thing
19:31:02 <Binkley> print is just show composed with putStrLn
19:31:38 <bd_> print $ sum numList :3
19:31:57 <LoganCapaldo> print = putStrLn . show -- Monomorphism restriction thingy! weee
19:32:37 <kyevan> Great, now I broke something else...
19:32:42 <Binkley> LoganCapaldo: why do you say that?
19:33:17 <eviltwin_b> if you naively define "print = putStrLn . show" the monomorphism restriction gets invoked because there's no variable
19:33:33 <eviltwin_b> (as usual,. add a type signature)
19:33:50 <SamB_XP> or, -fno-monomorphism-restriction
19:33:54 <shapr> mbishop: single letters are perfect when it's the pattern that's important.
19:34:14 <Binkley> Oh, right, duh
19:34:21 * eviltwin_b thinks making people think about their types is a good thing
19:34:24 <Binkley> I was thinking the monomorphism restriction was only for things that weren't functions
19:34:25 <mbishop> shapr: type definitions still confuse me:P
19:34:42 <dino-> ?paste
19:34:43 <lambdabot> http://paste.lisp.org/new/haskell
19:34:44 <LoganCapaldo> I like writing type signatures
19:34:47 <Binkley> but yeah, it's for things that aren't manifestly functions
19:35:11 <Binkley> writing type signatures beats writing documentation
19:35:18 <LoganCapaldo> it makes me feel good when the compiler doesn't complain
19:35:26 <lisppaste2> dino- pasted "step IO" at http://paste.lisp.org/display/31446
19:35:40 <LoganCapaldo> I don't get the same feeling of satisfaction writing a type declaration in any other language
19:35:51 <shapr> Epigram?
19:35:59 <dino-> In that code, in step_up2, how could I combine the two lines. The g <- .. and let result .. lines?
19:36:52 <bd_> step_up = step >>= flip when step_up
19:36:55 <bd_> mmm
19:37:07 <bd_> oh wait
19:37:08 <bd_> falls
19:37:17 <bd_> step_up = step >>= flip when (step_up >> step_up)
19:38:10 <dino-> huh, when
19:38:30 <bd_> hm?
19:38:35 <bd_> that's just a minimalist implementation
19:39:01 <kyevan> YAY!
19:39:01 <bd_> I don't think the step signature is quite right - it'd have to be IO for the robot to actually move :)
19:39:01 <dino-> Sure, but what about if somebody wanted to combine the perform action (g <- ...) and the following let using the g ?
19:39:05 <shapr> Oh, are you guys doing the LtU puzzle?
19:39:06 * kyevan hugs everyone!
19:39:24 <bd_> dino-: liftM?
19:39:26 <dino-> shapr: I was today, yeah. And I of course realize that my impl here is pretty crass.
19:39:35 <bd_> :t liftM
19:39:36 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
19:39:37 <dons> ?users
19:39:38 <lambdabot> Maximum users seen in #haskell: 278, currently: 245 (88.1%), active: 35 (14.3%)
19:39:39 <dino-> bd_: I tried liftM in various configurations.
19:39:49 <dons> 22 more and we win the fluffy toy
19:39:59 <bd_> dino-: liftM step newStdGen
19:40:05 <shapr> I just did it in pseudocode, step_up = step or (step_up >> step_up)
19:40:05 <dino-> Hm. Maybe (liftM step) getStdGen
19:40:06 <bd_> though as I said step should really be step :: IO Boolean
19:40:07 <dino-> yeah
19:40:07 <SamB_XP> dons: the Monad toy?
19:40:22 <dons> better than the Arrow toy, not so fluffy
19:40:26 <dino-> I was trying to do something like: getStdGen >>= liftM ...
19:40:29 <bd_> at which point you can do step_up = step >>= flip when (step_up >> step_up) :)
19:40:39 <dons> unsuitable for children, anyway
19:40:46 <bd_> dino-: watch your types there ... :)
19:41:22 <dino-> bd_: For some reason I thought it was generally desireable to make small things like that step independent of something like IO. So it can not care about where the gen comes from. No?
19:41:33 <shapr> what about step_up = unless step (step_up >> step_up) ?
19:41:35 <bd_> dino-: Well, step's supposed to make a robot move, right? :)
19:41:39 <bd_> If so it needs some IO
19:42:02 <bd_> :t randomR
19:42:03 <shapr> Although >>= might be better if we later decide to count the number of steps or something.
19:42:03 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
19:42:04 <SamB_XP> bd_: ... do you actually have a robot connected to your computer?
19:42:12 <dino-> I see, the specification speaks of taking a step _as a side effect_
19:42:16 <bd_> SamB_XP: No, but the type's the same either way :p
19:42:24 <SamB_XP> you could just use a Writer
19:42:33 <SamB_XP> maybe
19:42:34 <shapr> SamB_XP: show us!
19:42:39 <dino-> As in, like printing something out to STDOUT and returning IO () or whatever.
19:42:45 <SamB_XP> then I'd have to read the article!
19:42:57 <LoganCapaldo> Could not match us against (Show a) => a
19:43:00 <bd_> step = liftM (randomR (False, True)) newStdGen >>= \r -> putStrLn r >> return r -- or something more readable perhaps
19:43:27 <bd_> er
19:43:30 <bd_> print not putStrLn
19:43:37 <mgsloan> that step thing confused me.  A robot is a really bad example, anyway
19:43:38 <dino-> bd_, shapr, others: Thank you!
19:43:46 <mgsloan> if completing a step fails, you're screwed
19:43:47 <shapr> Speaking of LtU, Achilleas did not send me his email address. I don't think he wants to read my response.
19:43:50 * kyevan is doing exercose 3.10 in YAHT, and has the sum and product parts working
19:44:01 <mgsloan> step_up has side effects even if it fails
19:44:02 <kyevan> Now... how to go about the last one...
19:44:05 * kyevan mulls...
19:44:09 <kyevan> does show work on lists?
19:44:24 <shapr> mgsloan: Yeah, so unless should do it, yeah?
19:44:27 <shapr> :t unless
19:44:28 <dons> ?instances Show
19:44:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:44:30 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
19:44:36 <dons> kyevan: ^^
19:44:44 <mgsloan> shapr - i guess, i still don't really understand how it is tricky
19:44:46 <shapr> dons: Oh, nice reformatting.
19:45:06 <kyevan> dons: ... wha?
19:45:12 <shapr> I don't know, I came up with the pseudocode solution immediately after looking at the spec.
19:45:17 <bd_> kyevan: That's a list of the builtins that show works on
19:45:18 <bd_> that said...
19:45:21 <bd_> ST?!
19:45:25 <bd_> wha?
19:45:32 <kyevan> I'm not to the point where I can read that.
19:45:34 <shapr> > undefined :: ST
19:45:34 <lambdabot>  Not in scope: type constructor or class `ST'
19:45:39 <kyevan> That's next chapter.
19:45:40 <shapr> > undefined :: ST Int Int
19:45:41 <lambdabot>  Not in scope: type constructor or class `ST'
19:45:43 <shapr> hmm
19:45:53 <kyevan> so.......
19:46:03 <eviltwin_b> <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
19:46:09 <kyevan> the [a] at the end means "lists of anything it can handle", right?
19:46:15 <eviltwin_b> is the part you care about; the preceding line is someone else's query
19:46:17 <bd_> kyevan: yep
19:46:22 <eviltwin_b> and yes, [a] is list of any type a
19:46:24 <dons> mmm! http://programming.reddit.com/info/twtt/comments/ctxm5
19:46:25 <lambdabot> Title: Functional programming is a silver bullet (reddit.com)
19:46:35 <dons> that comment is very interesting
19:46:36 <bd_> lambdabot doesn't tell you that a needs to be show-able too ;)
19:46:42 <shapr> > undefined :: (Control.Monad.ST.ST Int Int)
19:46:43 <lambdabot>  Not in scope: type constructor or class `Control.Monad.ST.ST'
19:46:45 <shapr> Shouldn't that work?
19:47:23 <dons> ST isn't availabe. due to unsafeSTtoIO
19:47:27 <shapr> ohh
19:47:28 <SamB_XP> @hoogle ST
19:47:29 <lambdabot> Control.Monad.ST :: module
19:47:29 <lambdabot> Data.Array.ST :: module
19:47:29 <lambdabot> Control.Monad.ST.ST :: data ST s a
19:47:41 <bd_> Prelude Control.Monad.ST> undefined :: (Control.Monad.ST.ST Int Int)
19:47:41 <bd_> <<ST action>>
19:47:46 <bd_> heh.
19:47:52 <bd_> kind of useless, really.
19:48:00 <dons> :t Control.Monad.ST.unsafeSTToIO
19:48:01 <lambdabot> Not in scope: `Control.Monad.ST.unsafeSTToIO'
19:48:06 <SamB_XP> dons: that isn't dangerous!
19:48:12 <SamB_XP> its the other one that is!
19:48:21 <dons> ah yes :)
19:48:28 <dons> unsafeIOToST,       -- :: IO a -> ST s a
19:48:32 <dons> not good!
19:48:51 <LoganCapaldo> can't you just hide that one function?
19:49:01 <SamB_XP> it would be less dangerous if it gave you a ST RealWorld a
19:49:10 <SamB_XP> but then I guess it wouldn't be called "unsafe"
19:49:11 <dons> LoganCapaldo: well, we'd have to hide about 3, but yes, could be done
19:49:19 <dons> its easy enough to use Control.Monad.State instead ;)
19:49:21 <bd_> :t readTVar
19:49:23 <lambdabot> Not in scope: `readTVar'
19:49:27 <bd_> :t Control.Monad.STM.atomically
19:49:28 <LoganCapaldo> dons: Oh
19:49:29 <lambdabot> Couldn't find qualified module.
19:49:36 <SamB_XP> dons: what about MAarrays!
19:49:36 <LoganCapaldo> I'm silly
19:52:22 <kyevan> Woo!
19:52:29 <kyevan> I got all of 3.10 working!
19:52:45 <kyevan> Who da man? Not me, but I'm still a little proud of myself ^_^
19:53:04 <LoganCapaldo> @hoogle State a -> a
19:53:05 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
19:53:06 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
19:53:41 <SamB_XP> @hoogle State a -> b
19:53:43 <lambdabot> Control.Monad.State.evalState :: State s a -> s -> a
19:53:43 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
19:53:50 <SamB_XP> @hoogle State a -> (b, c)
19:53:51 <lambdabot> No matches, try a more general search
19:53:58 <SamB_XP> @hoogle State a -> b -> (c, d)
19:53:59 <lambdabot> No matches, try a more general search
19:54:05 <LoganCapaldo> @hoogle fromState
19:54:06 <lambdabot> No matches found
19:54:07 <SamB_XP> @hoogle State
19:54:08 <lambdabot> Control.Monad.State :: module
19:54:08 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
19:54:08 <lambdabot> Control.Monad.State.State :: newtype State s a
19:54:12 <bd_> @djinn State a b -> State b a
19:54:12 <lambdabot> -- f cannot be realized.
19:54:14 <SamB_XP> @hoogle runState
19:54:15 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
19:54:16 <bd_> tsk
19:54:16 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
19:54:22 <dons> > (`execState` 0) $ do x <- get ; modify (*2) ; return "done"
19:54:24 <lambdabot>  0
19:54:26 <SamB_XP> oh
19:54:41 <dons> > (`execState` 0) $ do x <- get ; modify (+2) ; y <- get ; put (x *2) ; return "done"
19:54:42 <lambdabot>  0
19:54:45 <dons> :)
19:54:54 <SamB_XP> why doesn't hoogle tell me things like "there aren't any constructors called that with that kind!"
19:56:00 <LoganCapaldo> :t (\n -> (`execState` n) $ do x <- get ; modify (+2) ; y <- get ; put (x *2) ; return "done")
19:56:01 <lambdabot> forall s. (Num s) => s -> s
19:56:36 <LoganCapaldo> oh ok
19:56:39 <emu> is there any way to resize an array short of creating the new one and copying the contents?
19:56:56 <LoganCapaldo> I keep forgetting how State works
19:57:00 <base_16> why not only read the contents you want?
19:57:42 <LoganCapaldo> Must keep reminding myself "A state instance is a function, not a tuple, a state instance is a function not a tuple..."
19:58:04 <bd_> @hoogle lift
19:58:05 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
19:58:05 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
19:58:05 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
19:58:18 <dons> emu, if you've got a malloc'd Ptr , you can realloc
19:58:36 <dons> or you can memcpy
19:58:45 <shapr> Who's the author of Paul Pontifications?
19:58:46 <emu> with that c array type?
19:58:49 <shapr> I want to read the next article!
19:59:01 <dons> ?hoogle memcpy
19:59:01 <lambdabot> No matches found
19:59:04 <dons> ?hoogle moveArray
19:59:05 <lambdabot> Foreign.Marshal.Array.moveArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
19:59:10 <LoganCapaldo> ?man memcpy
19:59:11 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
19:59:13 <emu> well hmm, considering reps for an adjency matrix is all
19:59:14 <dons> heh
19:59:26 <LoganCapaldo> That was not the response I expected
19:59:29 <shapr> Speaking of which, is there a new haskellwiki user locations page?
19:59:35 <dons> not yet
19:59:38 <emu> adjacency
19:59:48 <dons> the map got too hard to compute on my old box, and kept getting killed by the OS :)
19:59:57 <dons> (it was a 1G data file for the map, after all...)
20:00:00 <LoganCapaldo> hmm the map is interesting
20:00:03 <dons> a google maps hack would be better
20:00:11 <LoganCapaldo> high density in europe, not so much the us
20:00:14 <kyevan> Hmm
20:00:19 <dons> its a bit out of date now.
20:00:20 <kyevan> I finished chapter 3.
20:00:34 <kyevan> Should I break for the night, or go on to 4? Hm....
20:00:45 <LoganCapaldo> I'm a US person! Look at me! In the US
20:01:00 <shapr> I haven't updated my location.
20:01:00 <dons> anyone want to code up a google maps thingy?
20:01:07 <shapr> Is there a GData interface?
20:01:15 <LoganCapaldo> I can't, I have to add those lines to Yi ;)
20:01:37 <shapr> gdata - http://code.google.com/apis/gdata/index.html
20:01:38 <lambdabot> Title: Google Data APIs (Beta) Developer's Guide - Google Data APIs Overview
20:01:43 <shapr> oh hey
20:01:53 <shapr> I'm unhappy with Google Calendar, it's missing lots of features.
20:02:02 <shapr> So I've been thinking about how to write a replacement with HAppS
20:02:12 <Excedrin> which features are you missing?
20:02:21 <Excedrin> er, do you miss
20:02:38 <shapr> I don't need all the ajaxy stuff, I just want to be able to have multiuser events.
20:02:38 <dibblego> is there a function that will give me the size in bytes of a FilePath?
20:02:48 <dons> of a file?
20:02:50 <dons> you mean
20:02:51 <dibblego> yes
20:02:54 <dons> ?hoogle hFileSize
20:02:54 <lambdabot> IO.hFileSize :: Handle -> IO Integer
20:02:58 <dibblego> ah thanks
20:03:05 <SamB_XP> ?hoogle filesize
20:03:05 <lambdabot> IO.hFileSize :: Handle -> IO Integer
20:03:06 <lambdabot> System.IO.hSetFileSize :: Handle -> Integer -> IO ()
20:03:15 <shapr> But I realize, I don't know if there's a lazy Calendar datatype in Haskell that I can decorate with the info. Anyone heard of such a thing?
20:03:24 <shapr> I don't want to have to build a calendar type that works.
20:03:25 <Excedrin> shapr: that's very amusing to me, my work is making an ajaxy calendar also without multiuser stuff (afaik)
20:04:13 <shapr> Excedrin: I'm missing these features: 1. I want to see the local time of other users when their calendar is displayed along with mine. 2. I want to have overlaps between multiple calendars clearly displayed.
20:04:20 <shapr> um, I had other features...
20:04:34 <eviltwin_b> sounds like you also need a todo list :)
20:04:41 <LoganCapaldo> And he was gonna put them on google's calendar todo list
20:04:45 <shapr> Yeah, that's another thing I'd like to write with HAppS
20:04:46 <LoganCapaldo> dammit
20:04:50 <LoganCapaldo> I'm too slow
20:04:54 <shapr> but I want a TODO list that has multiuser capabilities.
20:05:09 <shapr> For that matter, I want a multiuser grocery list.
20:05:22 <Excedrin> http://rafb.net/paste/results/guvnVT12.html C++ Maybe
20:05:25 <shapr> And I want a TODO list that can handle GPS input.
20:05:26 <dibblego> do I have to open the file to get a Handle?
20:05:30 <LoganCapaldo> IRC over VNC over 802.11g means  I don't win these races
20:05:40 <shapr> So when I wander past the store and I need to buy milk, then my Nokia 770 will remind me.
20:05:44 <Excedrin> I need to go now, my head hurts after trying to code C++
20:05:52 <shapr> go take an Excedrin
20:05:59 <leather> What about Google Apps?
20:06:01 <mbishop> heh
20:06:04 <LoganCapaldo> sweet, multiple inheritence
20:06:08 <eviltwin_b> dibblego: yes, or here are POSIX and Win32 APIs to get file size directly from a pathname
20:06:10 <LoganCapaldo> always the way to go
20:06:17 <leather> shapr: The calendar associated with it, that is
20:06:20 <dino-> Hey, I also didn'
20:06:20 <eviltwin_b> er, there are
20:06:22 <dibblego> eviltwin_b, but not in System.IO?
20:06:31 <eviltwin_b> nope, they're system dependent
20:06:35 <dino-> didn't know you can use False, True as low/high for randomR
20:06:36 <dibblego> ok
20:06:39 <shapr> leather: I use it lots, but it doesn't do everything I need.
20:07:01 <bd_> @instances Random
20:07:02 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:07:04 <Binkley> @yow
20:07:05 <lambdabot> Hey, waiter!  I want a NEW SHIRT and a PONY TAIL with lemon sauce!
20:07:09 <bd_> @instances Random a
20:07:10 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:07:10 <eviltwin_b> the POSIX one involves stat(), the Win32 one involves the Win32 equivalent which is noticeably different
20:07:12 <bd_> bleh
20:07:14 <leather> shapr: You've used the calendar that comes with Google Aps Your Domain?
20:07:19 <Excedrin> oh yea, the Show inheritance is totally useless, I couldn't figure out how to use dynamic_cast/typeid to get the current type name from some arbitrary Show reference
20:07:20 <shapr> No?
20:07:24 <leather> Not the normal calendar...
20:07:28 <dibblego> eviltwin_b, otherwise, the correct way to get the Handle is with openFile "path" ReadMode? -- I have barely touched System.IO
20:07:31 <leather> I don't know how different it is, though.
20:07:45 <leather> http://www.google.com/a/
20:07:46 <lambdabot> Title: Google Apps for Your Domain
20:07:53 <eviltwin_b> something like that.  I haven't done much file IO myself
20:07:59 <dibblego> ok cheers
20:08:04 * shapr looks
20:08:04 <leather> I personally have not used it, so I don't know how it works.
20:08:35 <dons> ?instances-importing System.Random Random
20:08:36 <lambdabot> Bool, Char, Double, Float, Int, Integer
20:08:43 <leather> It may be that you can still only share instead of manage with multiple users.
20:09:39 <bd_> hosted calendar looks the same as the regular one to me...
20:10:36 <shapr> Wow, Google Apps is awesome.
20:10:36 <dino-> bd_, dons: Thanks
20:10:38 <leather> shapr: Wait a sec... I've got a Google calendar shared between multiple users, and we can all edit it. Is that not what you want?
20:10:58 <shapr> No, I can do that. But I want more!
20:11:14 <leather> bd_: Okay. You've used it?
20:11:36 <bd_> leather: I just popped in briefly... for various reasons I happen to have an account on a hosted domain, though I never use it.
20:11:48 <leather> bd_: Got it.
20:12:12 <bd_> I've used regular gcal though, and I didn't see anything different during the brief time I
20:12:15 <bd_> was looking at it
20:13:34 <leather> shapr: I see. What're you gonna call your personal Haskell Groupware?
20:13:38 <leather> @freshname
20:13:39 <lambdabot> Hadl
20:13:46 <leather> Nah!
20:13:53 <kyevan> I think I'm going to bed...
20:14:02 <SamB> do they all start with H?
20:14:08 <bd_> SamB: Ha.
20:14:11 <kyevan> It's late, and beating my head against types would be too much for me tonight, I think
20:14:16 <kyevan> @freshname
20:14:16 <lambdabot> Hadu
20:14:17 <kyevan> @freshname
20:14:17 <lambdabot> Hadv
20:14:18 <kyevan> @freshname
20:14:18 <lambdabot> Hadw
20:14:19 <kyevan> @freshname
20:14:19 <lambdabot> Hadx
20:14:20 <kyevan> @freshname
20:14:21 <lambdabot> Hady
20:14:21 <Binkley> kyevan: may you dream of monads and functors
20:14:23 <kyevan> @freshname
20:14:23 <lambdabot> Hadz
20:14:26 <kyevan> It would apear so :P
20:14:32 <resiak> \o/ monotonic Haskell app names
20:14:36 <bd_> kyevan: aw, you killed the Hads.
20:14:36 <SamB> kyevan: please don't try to get to Hzzz and beyond!
20:14:41 <leather> Ha! You've been Hadz!
20:14:47 <Binkley> onoez!
20:14:51 <bd_> SamB: I think it goes to 5 letters at Hazz :p
20:15:01 <Binkley> sounds like a challenge!
20:15:04 <bd_> Haaaa, Haaab, etc.
20:15:13 <kyevan> so, 'night
20:15:21 <dons> note that whenever you call @freshname, you enter into a contract with the bot to produce a new cabalised library with that name
20:15:45 * resiak has to write about 13 libraries now
20:15:46 <leather> Um, scary...
20:16:02 <bd_> module Hadu (Hadu) where data Hadu = Hadu deriving (Show), easy :)
20:16:23 <bd_> [no one ever said it had to be a /useful/ library]
20:19:19 <SamB_XP> dons: surely you are kidding
20:19:23 <Binkley_> heh, I got disconnected right after I said "Sure, go ahead and Internet sue me"
20:19:24 <SamB_XP> those names are horrible!
20:19:40 <dons> Hadx -- a new haddock?
20:19:56 <bd_> nah
20:19:58 <bd_> haskell X server
20:20:06 <dons> yeah
20:20:10 <SamB_XP> distributed X server, at that!
20:20:22 <Binkley_> because we need our X servers to be even slower
20:20:24 <Binkley_> *runs away*
20:20:30 <bd_> SamB: You might be thinking of ErlX
20:21:00 <SamB_XP> is that like ENOSLEEP?
20:21:25 <LoganCapaldo> ENOSLEEP_TIL_BROOKLYN
20:21:33 <bd_> ENOSLEEP_CLOWNSWILLGETME
20:21:37 <dons> heh
20:23:09 <leather> I thought HadX was the next generation OS?
20:23:14 <leather> To replace House...
20:23:17 <leather> OS X...
20:23:24 <leather> Or was that HadXP?
20:23:31 <LoganCapaldo> HadX, LostX, FoundX
20:23:44 <leather> LoganCapaldo: That's too eXciting for me.
20:23:52 <Binkley_> WasBlindX, ButNowX, ISeeX
20:24:00 <bd_> Hadista?
20:24:19 <SamB_XP> desu!
20:26:02 <bd_> let desu = (>> putStrLn " -desu!") in (putStr "Chibi ningen wa urusai" `desu`)
20:26:54 <LoganCapaldo> > let desu = (>> putStrLn " -desu!") in (putStr "Chibi ningen wa urusai" `desu`)
20:26:55 <lambdabot>    The operator section `((putStr "Chibi ningen wa urusai") `desu`)'
20:26:55 <lambdabot>   re...
20:27:02 <LoganCapaldo> Oooooo
20:27:05 <LoganCapaldo> sad face
20:27:06 <bd_> worked for me >.>
20:27:14 <bd_> ghci 6.6
20:27:34 <LoganCapaldo> I'm a fool
20:27:38 <LoganCapaldo> I only have 6.4
20:27:50 <Binkley_> oh, yeah, what kind of fool only has 6.4? ;-P
20:28:04 <bd_> You're missing out on all the SMP action!
20:28:17 <Pseudonym> I think I got a spam about SMP action.
20:28:19 <SamB_XP> lambdabot's kind?
20:28:24 <LoganCapaldo> I have 2 cores but not smp
20:28:25 <bd_> Hot thread-on-thread action!
20:28:30 <bd_> LoganCapaldo: 2 cores is SMP
20:28:34 <LoganCapaldo> does smp work with multicore
20:28:40 <bd_> multicore /is/ SMP :)
20:28:41 <LoganCapaldo> ah
20:28:45 <SamB_XP> ... that is kind of the point of multicore
20:28:48 <LoganCapaldo> well
20:28:59 <bd_> multicore is just SMP, only faster and cheaper.
20:29:01 <SamB_XP> do you mean to say you've had a non-SMP kernel installed ?
20:29:02 <LoganCapaldo> I meant in the "marketing sense"
20:29:33 <LoganCapaldo> AMD doesn't say "SMP x2" ;)
20:29:36 <bd_> I do hope you have a kernel with good affinity at least :)
20:29:47 <bd_> scheduler affinity*
20:29:50 <LoganCapaldo> I dunno
20:29:59 <bd_> linux 2.6.x would do nicely
20:29:59 <LoganCapaldo> I'm vnced into my mac from windows
20:30:04 <bd_> dunno about macs
20:30:14 <LoganCapaldo> well the mac doesnt have the multicore action
20:30:17 <bd_> windows fails at cpu affinity last I checked
20:30:20 <LoganCapaldo> its a lone ppc processor
20:30:27 <LoganCapaldo> I can always reboot
20:30:37 <LoganCapaldo> But I had to use powerpoint today
20:30:58 <dons> mmm:
20:31:00 <dons>        Do you think in HOFs?
20:31:00 <dons>        We do too.
20:31:00 <dons>        Haskell programmers welcome!
20:31:01 <dons>        www.janestcapital.com/tech.html
20:31:04 <dons> google is fun
20:32:03 <Binkley_> yeah, I always see that ad whenever I read haskell mailing list posts
20:32:06 <Binkley_> and it drives me crazy
20:32:06 <sjanssen> dons: back when I used gmail, that ad was always up
20:32:10 <Binkley_> because they rejected the hell out of me
20:32:14 <sjanssen> ha
20:32:24 <Binkley_> NOT SO WELCOME apparently
20:32:29 <dons> they've changed it recently though?
20:32:31 <Binkley_> unless it was a personal thing, which I'm sure it was
20:32:35 <dons> it used to be something different
20:32:47 <Binkley_> yeah, I don't think it used to say that about Haskell programmers
20:32:49 <sjanssen> yeah, I can't quite recal
20:33:07 <dons> sjanssen: so you going to apply? ;)
20:33:14 <dons> college is almost over, no?
20:33:14 <leather> dons: Graduating soon?
20:33:25 <dons> me, yeah.
20:33:38 <sjanssen> dons: a year or so
20:33:41 <sjanssen> maybe I will
20:33:41 <SamB> didn't it used to say ocaml or something?
20:33:56 <dons> SamB: yeah I think so. the "Do you think in HOFs? We do too." is new
20:34:14 <dibblego> "If you'd like to know a little bit more about how we came to use OCaml as our primary development language..."
20:35:01 <leather> dons: Heffalump said he was going to Credit Suisse to do Haskell work.
20:35:14 <LoganCapaldo> I think in procedures that take no arguments and return no values but rather mutate global state
20:35:31 <dons> leather: I think he even got the joob
20:35:33 <LoganCapaldo> where can i find a company like that?
20:35:53 <leather> dons: Ah, you knew.
20:35:59 <dons> (my supervisor is just finishing a year there, actually)
20:36:04 <leather> I see.
20:36:12 <dibblego> LoganCapaldo, you can't because no such thing exists
20:36:21 <chessguy> fun riddle site at www.weffriddles.com if anyone's into such things
20:36:33 <dibblego> LoganCapaldo, what you might means is "procedures that look like they return nothing, but they actually do - it's just implicit and all convoluted"
20:36:36 <leather> dons: Is your advisor looking for Ph.D. students?
20:36:41 <Binkley_> LoganCapaldo: isn't that *every* company?
20:36:47 <dons> leather, always :)
20:36:59 <LoganCapaldo> Binkley_: Thanks for understanding the spirit of the comment :)
20:37:00 <dons> leather: http://www.cse.unsw.edu.au/~pls/
20:37:01 <lambdabot> Title: Programming Languages & Systems Research Group
20:37:05 <leather> dons: I've seen it.
20:37:24 <leather> dons: I just finished my M.S. I'm thinking of applying in a year or so.
20:37:30 <dons> great.
20:37:31 <Pseudonym> Oh, I see you guys take the blue pill.
20:37:38 <leather> That's one of the places I've looked.
20:37:45 <dons> yeah. that was a mistake in hindsight, Pseudonym :)
20:38:03 <dons> (there was no reference to the movie intended, but of course it sort of works out like that)
20:39:12 <bd_> @hoogle fixIO
20:39:13 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:39:24 <dons> you know, i've never seen fixIO in a real haskell program
20:39:39 <mgsloan> not only one, but two.  they are the true thinkers of the out-sides of boxes
20:39:56 <dons> whereas I have fix in at least a couple,
20:39:57 <dons> $ grep fix */*.hs | wc -l
20:39:57 <dons>       11
20:40:16 <Pseudonym> dons: No, I use mfix.
20:40:50 <bd_> @hoogle mfix
20:40:51 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
20:41:09 <Pseudonym> In fact, I used it a few days ago on a transformer stacked on top of IO.
20:41:30 <dons> nice
20:41:47 <Pseudonym> The skeleton of the code was this:
20:41:53 <Pseudonym> createModel ~(s:ss) = do
20:41:58 <LoganCapaldo> "Now I'm going over to Ed's fixit, to fix Ed"
20:42:06 <Pseudonym>     s' <- liftIO . newIORef $ ... something involving ss ..
20:42:23 <dons> ah yes
20:42:29 <LoganCapaldo> let ed = ed in fix ed
20:42:34 <Pseudonym>     ss' <- mapM (\x -> do liftIO . new IORef $ ... something involving s ) [stuff]
20:42:39 <Pseudonym>     return (s':ss')
20:42:43 <Pseudonym> Then I called mfix on that.
20:42:50 <LoganCapaldo> > let ed = ed in fix ed
20:42:51 <lambdabot>  Add a type signature
20:43:02 <dons> so that's a perfect opportunity for mfix
20:43:12 <LoganCapaldo> > let ed = id in fix ed
20:43:13 <lambdabot>  Add a type signature
20:43:16 <dons> the do s <- ... ; ss <- .. ; return (s:ss) style
20:43:16 <Pseudonym> Yeah.  Building a recursive data structures that use IORefs.
20:43:26 <Pseudonym> Note the tilde pattern.
20:44:00 <LoganCapaldo> let ed = (+1) in fix ed
20:44:12 <Pseudonym> > let omega = 1 + omega in omega
20:44:13 <lambdabot>  Exception: <<loop>>
20:44:21 <LoganCapaldo> > let ed = (+1) in fix ed
20:44:22 <lambdabot>  Exception: <<loop>>
20:44:26 <LoganCapaldo> weee
20:44:27 <leather> Pseudonym: What is the tilde pattern?
20:44:48 <Pseudonym> leather: It's a pattern match that doesn't do a strict conformality check.
20:45:06 <LoganCapaldo> > fix (const 1)
20:45:07 <lambdabot>  1
20:45:19 <LoganCapaldo> OMG that's so cool
20:45:23 <dons> > let f ~(Just x) = Nothing in 1
20:45:25 <lambdabot>  1
20:45:34 <Pseudonym> dons: Actually, that works without the tilde.
20:45:39 <Pseudonym> Better example:
20:45:42 <dons> > let f ~(Just x) = 1 in f Nothing
20:45:44 <lambdabot>  1
20:45:52 <LoganCapaldo> laziness for the win
20:45:54 <Pseudonym> yeah.
20:46:05 <dons> > let f (Just x) = 1 in f Nothing
20:46:06 <lambdabot>  Non-exhaustive patterns in function f
20:46:09 <Pseudonym> In this case, you need the lazy pattern match because otherwise you end up in a black hole.
20:46:21 <mgsloan> > let f ~(Just x) = x in f Nothing
20:46:22 <lambdabot>  Add a type signature
20:46:34 <leather> Ah.
20:47:52 <Pseudonym> When you start executing the body of initModel, the list argument isn't built yet.
20:47:52 <Pseudonym> It's built at the end.
20:47:52 <Pseudonym> nt
20:48:14 <newsham> is there anything like   whenMaybe b f = if b then (Just f) else Nothing    ?
20:48:52 <bd_> newsham: Maybe is a monad and a functor...
20:49:05 <bd_> oh, wait
20:49:11 <bd_> guard b >> return f
20:49:13 <bd_> >.>
20:51:27 <newsham> > (guard True (+ 3)) 2
20:51:28 <lambdabot>    The function `(guard True ((+ 3)))' is applied to one arguments,
20:51:28 <lambdabot>   but...
20:55:38 <dino-> You know, I think I interpreted the 'step' spec wrong. I'm just calling step over and over until the one time it's successful. Not actually making sure the thing _gets one step higher_ in the end.
20:56:04 <dino-> Than where it hypothetically started.
20:59:58 <newsham> justWhen p act = if p then act >>= return . Just else return Nothing
21:00:06 <newsham> thats what I want.  I imagine it doesntalready exist.
21:01:01 <bd_> newsham: guard condition = when (not condition) mzero
21:01:30 <bd_> as for justWhen,
21:01:41 <bd_> justWhen p act = guard p >> act
21:01:43 <newsham> hmm.. so like my justWhen but with inverted predicate?
21:01:50 <bd_> I think
21:01:56 <bd_> hm
21:02:02 <bd_> Is there a MaybeT?
21:02:06 <bd_> @hoogle MaybeT
21:02:06 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
21:02:19 <Pseudonym> bd_: Not built in, but I have one.
21:02:22 <bd_> heh
21:02:25 <bd_> well that'd be ideal :)
21:02:37 <bd_> justWhen p act = runMaybeT (guard p >> lift act)
21:03:00 <newsham> you're losing me.
21:03:25 <Pseudonym> http://hfl.cvs.sourceforge.net/hfl/hfl/mtl/Negate.hs?revision=1.2&view=markup
21:03:28 <lambdabot> Title: SourceForge.net Repository - [hfl] View of /hfl/mtl/Negate.hs, http://tinyurl.com/y4nvgd
21:03:43 <Pseudonym> That basically does the job.
21:05:06 <base_16> bd: how does the guard prevent the execution of the function following >>?
21:05:16 <newsham> > (guard True >> (\x -> [x, -x])) 3   :: Maybe [Int]
21:05:18 <lambdabot>  Couldn't match `Maybe [Int]' against `[a]'
21:05:33 <lispy> ?type guard
21:05:34 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:05:37 <bd_> base_16: in a maybe monad, guard False = mzero = Nothing
21:05:40 <bd_> Nothing >> _ = Nothing
21:05:58 <bd_> or in general
21:05:59 <base_16> ah! okay :) thanks
21:06:00 <bd_> mzero >> _ = mzero
21:06:12 <base_16> cool
21:06:20 <bd_> Why isn't there a MaybeT in mtl? :)
21:07:50 <newsham> guard returns a m ()
21:08:00 <newsham> I want Bool -> m a -> m (Maybe a)
21:08:02 <bd_> newsham: but it's in MonadPlus
21:08:06 <bd_> yes
21:08:14 <bd_> we need a MaybeT for it to work :(
21:08:38 <bd_> @hoogle fmapM
21:08:39 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
21:08:39 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
21:08:39 <Pseudonym> We need MonadZero back.
21:08:45 <bd_> hmmm
21:09:24 <bd_> :type \c m -> fmapM id (guard c >> return m)
21:09:30 <bd_> @type \c m -> fmapM id (guard c >> return m)
21:09:32 <lambdabot> Not in scope: `fmapM'
21:09:36 <bd_> curses
21:10:35 <bd_> Prelude Random IO System.IO Control.Monad.Fix Data.FunctorM Control.Monad> :type (\c m -> fmapM id (guard c >> return m)) :: (Monad m) => Bool -> m f -> m (Maybe f)
21:10:38 <bd_> (\c m -> fmapM id (guard c >> return m)) :: (Monad m) => Bool -> m f -> m (Maybe f) :: (Monad m) => Bool -> m f -> m (Maybe f)
21:10:41 <bd_> works :)
21:10:45 <newsham> http://www.thenewsh.com/~newsham/x/quest.txt   <- here's concretely what I want to do.  I'm still not understanding how I use guard for that.
21:11:10 <bd_> you can do
21:11:23 <bd_> justWhen c m = fmapM id (guard c >> return m)
21:11:30 <bd_> it's a bit tricky though :)
21:11:34 <bd_> basically
21:11:50 <base_16> does the id pull m back out of the monad?
21:11:50 <newsham> hmm..  that's definitely not clarifying the code :)
21:11:51 <bd_> the inner (guard c >> return m) is of type Maybe m
21:11:55 <bd_> er
21:11:57 <bd_> the inner (guard c >> return m) is of type Maybe (m f)
21:12:04 <bd_> if c is false
21:12:08 <bd_> this is mzero = Nothing
21:12:11 <bd_> if c is true
21:12:15 <bd_> this is Just m
21:12:32 <bd_> fmapM id is... tricky :)
21:12:36 <bd_> it's a bit like mapM
21:12:36 <bd_> so
21:12:43 <bd_> if we do mapM id [yourThing]
21:12:48 <bd_> that's the same as sequence
21:13:00 <bd_> fmapM is generalized over all functors, not just lists
21:13:02 <bd_> so
21:13:17 <bd_> fmapM id Nothing = return Nothing
21:13:25 <bd_> fmapM id (Just f) = liftM Just f
21:13:31 <base_16> nice
21:13:33 <bd_> which pulls it back into your monad
21:13:43 * bd_ bows
21:13:52 <bd_> @pl \c m -> fmapM id (guard c >> return m)
21:13:53 <lambdabot> (fmapM id .) . (. return) . (>>) . guard
21:13:59 <bd_> now isn't that so much clearer :D
21:14:34 <bd_> nayway
21:14:40 <bd_> the fmapM id is a bit obscure I'll admit
21:14:42 <bd_> hmm
21:14:48 <bd_> it's kind of an inside-out combinator really
21:14:51 <bd_> @type fmapM id
21:14:52 <lambdabot> Not in scope: `fmapM'
21:15:00 <bd_> @type Data.FunctorM.fmapM id
21:15:01 <lambdabot> forall (f :: * -> *) (m :: * -> *) b. (Data.FunctorM.FunctorM f, Monad m) => f (m b) -> m (f b)
21:15:05 <bd_> :)
21:15:06 <base_16> bd_: what's a good way of getting 'nice' descriptions for things like lift, guard, mapM, fmapM, etc?
21:15:23 <bd_> base_16: ghc heirarchial (sp?) libraries docs is good
21:15:23 <bd_> and
21:15:28 <bd_> you can learn a lot from the types
21:15:35 <base_16> yeah-- those are still a bit cryptic to me
21:15:43 <bd_> like, fmapM is pretty well explained by f (m b) -> m (f b)
21:15:50 <bd_> it reverses the order of monadsd
21:15:53 <base_16> yeah
21:16:04 <bd_> some aren't quite so helpful:
21:16:06 <bd_> :t guard
21:16:07 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:16:12 <bd_> for that, check the ghc docs :/
21:16:20 <bd_> anyway
21:16:23 <base_16> what's MonadPlus? :(
21:16:29 <base_16> i guess i'll go read
21:16:41 <eviltwin_b> MonadPlus is a Monad with "zero" and "plus" operations
21:16:41 <bd_> it's a subset of monads which support, well, failure and retry, kinda.
21:16:45 <bd_> yeah
21:16:50 <bd_> mzero `mplus` x = x
21:16:54 <eviltwin_b> mzero is [] for list and Nothing for Maybe
21:16:55 <bd_> x `mplus` mzero = x
21:17:02 <bd_> also associativity
21:17:27 * lispy notes that bd_ has become a one man #haskell show :)
21:17:30 <bd_> XD
21:18:02 <lispy> bd_: it's good, you're teaching, don't stop!
21:18:23 <bd_> @hoogle m (f b) -> f (m b)
21:18:23 <lambdabot> Prelude.id :: a -> a
21:18:24 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:18:24 <lambdabot> Prelude.asTypeOf :: a -> a -> a
21:18:33 <bd_> that's... not helpful
21:19:30 <base_16> hmm
21:19:33 <base_16> fmapM is deprecated :/
21:19:36 <bd_> really?
21:19:48 <Cale> http://haskell.org/haskellwiki/MonadPlus
21:19:49 <lambdabot> Title: MonadPlus - HaskellWiki
21:20:01 <base_16> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-FunctorM.html#v%3AfmapM%5f
21:20:03 <lambdabot> http://tinyurl.com/ycqlry
21:20:37 <bd_> :type Data.Traversable.mapM id
21:20:44 <bd_> :t Data.Traversable.mapM id
21:20:45 <lambdabot> Couldn't find qualified module.
21:20:52 <bd_> blah
21:21:07 <bd_> Data.Traversable.mapM id :: (Traversable t, Monad m) => t (m b) -> m (t b)
21:21:10 <bd_> there you go :)
21:21:19 <base_16> :)
21:21:58 <bd_> name collision with Prelude, unfortunately :(
21:22:43 <Cale> well, you'd hide the Prelude version
21:23:00 <bd_> yeah, I /suppose/
21:23:03 <Cale> because this is strictly more general
21:23:21 <bd_> anyway, back to essays...
21:23:23 <Cale> (lists are Traversable)
21:25:22 <Cale> We really need to reorganise the Functor hierarchy so that it's more accessible from the Prelude.
21:27:06 <dons> Cale, you could make a proposal. you're qualified..
21:29:39 <Cale> I wish there were language literacy modes. There are things which I'd do differently if I was designing things for beginners than for experts.
21:30:55 <bd_> DrScheme does something like that. I've heard it can be painful.
21:32:15 <Cale> Well, you don't want to have something totally crippled, but there are certain things which we could make very polymorphic, like (.), but there's a strong possibility of breaking the brains of newbies even harder than we normally do :)
21:32:37 <Syzygy-> Why does GHC tell me that *: is not in scope when I try to define it as a new operation?
21:32:56 <Cale> How are you trying to do that?
21:32:56 <Syzygy-> (*:) :: Integer -> Cycle -> Integer
21:33:00 <Syzygy-> And then
21:33:07 <Syzygy-> n *: c = ...
21:33:30 <Syzygy-> (Cycle is a datatype I've introduced just above this code)
21:33:32 <dons> mmmm "The Haskell list probably has the widest
21:33:32 <dons> 'knowledge bandwith' of any mailing list I've ever seen, from total beginner questions to highly
21:33:35 <dons> abstruse stuff which probably represents the cutting edge of PhD research. All are answered with
21:33:38 <dons> detail and good humour.
21:33:40 <dons> "
21:33:55 <Cale> dons: where are you reading that?
21:34:08 <Cale> Syzygy-: that looks roughly okay
21:34:19 <dons> an old blog post, by jimapple
21:34:22 <Syzygy-> And yet: PermutationGroup.hs:41:0: Not in scope: `*:'
21:34:36 <dons> http://www.oreillynet.com/mac/blog/2006/03/haskell_vs_ocamlwhich_do_you_p.html
21:34:39 <lambdabot> Title: Haskell vs. OCaml--which do you prefer? - O&#039;Reilly Mac DevCenter Blog, http://tinyurl.com/y97fdb
21:34:45 <Syzygy-> 41 being the row where the type signature is at.
21:35:01 <base_16> i have to say, i've been shocked by the friendliness of the haskell community
21:35:07 <Cale> and it's really in parens like that?
21:35:17 <Syzygy-> Yup.
21:35:34 <Syzygy-> Changing it to (:*:) gives me instead Invalid type signature. :(
21:36:11 <Cale> Syzygy-: If it started with :, it'd be a data constructor
21:36:25 <dons> base_16: great! :)
21:36:33 <Syzygy-> Ah.
21:36:47 <Cale> Syzygy-: I can define (*:) by itself in a blank file just like you did there
21:38:49 <Syzygy-> lisppaste2: url
21:38:49 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/Haskell and enter your paste.
21:39:19 <Cale> oh, that's interesting, vim gets the highlighting on import declarations wrong when they span multiple lines
21:39:19 <dibblego> import Data.Map as Map hiding (!) -- why won't this work?
21:39:31 <Cale> hiding ((!))
21:39:49 <Cale> You need parens to wrap the hiding list, and then parens for the operator
21:39:53 <dibblego> ah of course, ta
21:40:19 <lisppaste2> Syzygy- pasted "Not in scope" at http://paste.lisp.org/display/31460
21:40:29 <Syzygy-> Cale: Care to take a look?
21:40:43 <Cale> Syzygy-: x *: c | ...
21:40:49 <Cale> not x (*:) c
21:40:56 <Syzygy-> Ah. No newline there?
21:41:00 <Cale> no parens
21:41:09 <Cale> unless you were to write
21:41:13 <Cale> (*:) x c
21:41:28 <Syzygy-> Doh.
21:41:32 <Cale> wrapping an infix operator in parens makes it act like an ordinary prefix function
21:41:35 <Syzygy-> *bangs head against desk* Right.
21:44:17 <Cale> dons: one problem is actually patching GHC to work the way I want, since it will break compatibility with H98
21:44:30 <dibblego> am I able use Map.! in a module that exports its own ! function?
21:44:47 <Cale> dibblego: sure
21:45:04 <Cale> but you have to use it qualified
21:45:11 <dibblego> I feel as if I have exhausted all permutations
21:45:13 <Cale> (which is a little awkward looking)
21:45:14 <dibblego> oh
21:45:27 <dibblego> import qualified Map I suppose
21:45:43 <Cale> yeah
21:45:48 <Cale> And use   m Map.! n
21:45:53 <Cale> instead of m ! n
21:46:01 <Cale> which looks hideous
21:46:14 <Cale> It's probably more sensible to use (Map.!) m n
21:46:37 <dibblego> import qualified Data.Map as Map --
21:46:38 <dibblego> ?
21:46:42 <Cale> yeah
21:46:45 <dibblego> ok ta
21:48:01 <dibblego> how does data T = T Map look?
21:48:29 <Cale> Looks like a type which could use a better name :)
21:48:32 <dibblego> Not in scope: type constructor or class `Map' -- when I import qualified
21:48:35 <dibblego> :)
21:48:47 <Cale> You can use another import to import the type name
21:48:54 <Cale> import Data.Map (Map)
21:49:07 <Cale> To avoid typing Map.Map
21:49:09 <dibblego> ok thanks
21:50:26 <Cale> @libsrc Data.Traversable
21:50:26 <lambdabot> Unknown command, try @list
21:50:34 <Cale> @source Data.Traversable
21:50:35 <lambdabot> Data.Traversable not available
21:50:38 <Cale> hmm
21:50:42 <Cale> @source Data.Applicative
21:50:42 <lambdabot> Data.Applicative not available
21:50:46 <Cale> @source Data.Map
21:50:46 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
21:51:00 <Cale> It's lying
21:57:23 <sorear> The clock on the machine that logs #haskell for tunes seems to be off - the log timestamps agree with neither ntpdate nor the WWVB radio clock sitting on my monitor.
22:01:11 <dons> about 6 mins out, by my clock
22:01:25 <dons> "21:57:23 <sorear> The clock on" ... versus " 16:51  sorear> The clock on "
22:01:49 <sorear> would it be more useful to email someone?
22:04:40 <dblhelix> good morning, #haskell!
22:04:55 <sorear> hi
22:09:04 <sorear> RIO has a use for wrapping various libraries.  Due to the design of RIO, this is not hard at all (even without automation), but it does leave the question of what to do with the results. (a) Separate cabal packages, depending on RIO and <underlying-lib>. (b) Separate library in RIO package. (c) Burden <underlying-lib> maintainer. (d) None of the above.  Of course (c) is to be preferred if RIO ever goes mainstream.  For now I'm leaning toward 
22:09:57 <sorear> ?more
22:15:53 <sorear> funny result: *lambdabot* Maximum users seen in sorear: 1, currently: 0 (0.0%), active: 0 (NaN%)
22:17:38 <LoganCapaldo> hehe
22:17:53 <LoganCapaldo> the logancapaldo channel is just as active
22:18:33 <sorear> Maybe, lambdabot should run a whois on anybody who tries this and report status for the first common channel between <user> and lambdabot.
22:19:19 <Modius> Was wondering - has anyone programmed heavily in both Lisp and Haskell?
22:19:54 <Modius> Wanted to know the large-app consequences of the pinnacle of dynamically typed and statically typed languages.
22:20:47 <Adamant> I haven't programmed heavily, but I've done a little bit of both.
22:21:01 <sorear> I use much haskell, not much lisp.
22:22:01 <Modius> I have done lisp but not Haskell (Which I've been researching) - I depend pretty heavily on the type system in C-language programming (more than most); was wondering on how you see the balance of power (lisp) vs compile time precision (haskell)
22:22:46 <bd_> I don't usually find the type system restricting in haskell - if anything it's helpful, as it can often find bugs for you :)
22:23:03 <bd_> though I haven't done any really big projects in either haskell or lispy languages yet ...
22:23:06 <Modius> I didn't mean it was a restriction
22:24:33 <leather> Modius: Can I ask what you mean by depending heavily on the C type system?
22:24:47 <Syzygy-> Can I write constructors that check conditions for my datatypes?
22:24:52 <Syzygy-> Or that mangle the data given?
22:25:10 <sorear> Syzygy: No.
22:25:14 <Pseudonym> You can write smart constructors.
22:25:23 <sorear> Constructors only check types.
22:25:28 <dons> yeah, sure you can. smart constructors
22:25:33 <dons> ?wiki Smart_constructors
22:25:33 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
22:25:39 <sorear> You can write wrappers, and not export constructors.
22:25:52 <dons> you could do it in the type level, if you've got enough riding on the result
22:26:02 <sorear> Confusingly, this pattern is often called 'smart constructors'
22:26:03 <Pseudonym> The trouble with not exporting constructors is you can't pattern match.
22:26:20 <Syzygy-> dons: It's not on the level of wanting to build it into the type system.
22:26:49 <dons> :)
22:26:52 <sorear> You just want (something like) the size of an array is non-negative, that sort of level ?
22:29:17 <sorear> wrt RIO, what is accepted practice for library A having optional support for library B?
22:31:39 <sorear> e.g. I want to wrap Streams and provide generic-ref instances, but neither of those is in base.
22:34:06 <Syzygy-> sorear: To be specific, I'm writing a library for handling permutation groups, and I want to make sure I throw away redundancy when first accepting a permutation in cycle form.
22:35:58 <sorear> yea, that sounds like a "smart constructors" use case.
22:42:16 <kzm_> So: in general define data types to match your problem domain.  Constructors should only generate legal/valid values.  Peano types is one way to do that.  Right?
22:42:44 <kzm_> I'm not sure at which point you have 'smart' constructors, though.
22:43:00 <kzm_> (e.g. is data Bool = True | False 'smart'?)
22:43:02 <sorear> kzm_: that's generally ideal
22:43:23 <sorear> kzm_: but sometimes machine integers are needed
22:43:36 <kzm_> If I may digress for a moment - I read this paper on sequence alignment/shortest edit distance yesterday.
22:44:46 <kzm_> The authors defined the problem, where you go from one sequence (string) to another by either deleting characters from string 1, inserting from string 2, or replacing characters from string 1 by characters from string 2.
22:45:09 <kzm_> Insertions/deletions lead to 'gaps' in the alignment.
22:45:32 <kzm_> The authors felt the need to specify that a gap should never align with a gap in the other sequence.
22:46:08 <kzm_> When I implemented this, I defined the data type: data Edit = Ins Char | Del Char | Repl Char Char
22:46:43 <kzm_> ..which precludes that.  Perhaps that was a smart constructor (and I was too dumb to realize :-)?
22:47:17 <sorear> smart constructors are used when your data types are dumb
22:47:29 <kzm_> Okay.  That was probably terribly interesting for you all. :-)
22:48:11 <TSC> kzm_: It's interesting for bioinformatics at least (:
22:48:21 <kzm_> I read this online book on type theory (forget which - dons?).  The author go pretty far in matching the data types to his problem domain.
22:49:03 <kzm_> Designing grammars (basically) to match legal sequences of moves for games.
22:51:20 <kzm_> TSC: the reason I'm looking at this, is that I want to play with this for EST clustering/assembly.
22:52:00 <kzm_> TSC: I think current state of the art for nucleotides is lagging behind proteins, and could do with a catching up.
22:52:02 <kzm_> We'll see.
22:53:11 * kzm_ must run.
23:09:09 <dblhelix> how to obtain hat support for 'new' library modules, such as Control.Applicative?
23:18:16 <Syzygy-> Oh joy!
23:18:31 * Syzygy- is running extremely stupid group theory algorithm on just too large groups right now....
23:23:50 <ski> (dblhelix : hm .. just wondering what you're doing with idioms ?)
23:24:08 <dblhelix> ski: parsing :)
23:24:19 <ski> elaborate ?
23:24:28 <ski> (it sounds interesting)
23:25:05 <dblhelix> I put parsec as well as uu.parsing behing an idiom interface...
23:25:30 <ski> and how does it turn out ?
23:25:33 <dblhelix> ... and now I can substitute one for the other whenever I like...
23:25:39 <ski> hehe
23:26:09 <dblhelix> ski: it's a pity that many etc. were not provided as default class methods
23:26:36 <ski> in which class ?
23:26:44 <dblhelix> Applicative
23:26:55 <ski> hm
23:27:15 <ski> how would it be a member of that class, you mean ?
23:27:45 <ski> can it be defined purely in terms of 'return' and 'ap' ?
23:27:59 <dblhelix> ski: I think it is
23:28:11 <ski> (or whatever they call those there .. don't recall)
23:28:17 <ski> @hoogle many
23:28:18 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
23:28:18 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
23:28:18 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
23:28:33 <ski> hm
23:28:33 <dblhelix> ski: mmm... make that Alternative, not Applicative
23:28:42 <ski> that sounds more like it
23:28:48 <dblhelix> for you have to choose between [] and (:) at some point
23:28:51 <ski> you seem to need some kind of nondeterminism
23:28:53 <ski> exactly
23:29:26 <dblhelix> many v = (:) <$> v <*> many v <|> pure []
23:30:05 <dblhelix> but UU.parsing equips many with some extra stuff for generating nice parse-error messages
23:30:21 <ski> mhm
23:30:23 <ski> many v = `(v : ,(many v)) <|> `[]
23:31:09 * ski 's pondering how to cast this into his syntax idea
23:31:34 <ski> erm
23:31:36 <ski> that should be
23:31:40 <ski> many v = `(,v : ,(many v)) <|> `[]
23:31:57 <gour> dons: are you cooking (regarding ml post) something for vim or yi?
23:34:33 <dblhelix> ski: you lost me here...
23:35:00 <ski> dblhelix : it's an idea for a new syntax for monads and idioms i've been working on
23:35:21 <dblhelix> ski: ah, okay...
23:35:27 <ski> (dblhelix : i've mostly been thinking on abstract syntax, type checking and translation, so far)
23:36:00 <ski> v :: Parser a
23:36:05 <ski> ,v :: a
23:36:10 <ski> many v :: Parser [a]
23:36:18 <ski> ,(many v) :: [a]
23:36:21 <ski> v : ,(many v) :: [a]
23:36:28 <ski> `(v : ,(many v)) :: Parser [a]
23:36:58 <ski> of course i can probably not use '`' and ',' .. so i need some other concrete syntax
23:37:16 <ski> dblhelix : do you get the idea, roughly ?
23:38:06 <dblhelix> ski: kind of... not sure if I find it intuitive already, though...
23:38:15 <dblhelix> ski: I guess it takes a little bit of getting used to
23:38:36 <ski> ',(...)' is a side-effecting expression .. '`(...)' makes it pure again
23:39:08 <dblhelix> ski: yeah, I figured that much...
23:39:08 <dons> gour, nope. just want layout lines for vim :)
23:39:15 <ski> it can be used with any idiom or monad
23:39:42 <ski> dblhelix : and the nice thing is that this can be done *without* introducing side-effects everywhere in haskell :)
23:40:07 <dblhelix> ski: ?? :S
23:40:16 <dblhelix> ski: interesting
23:40:41 <gour> dons: cool. is there some nice indent vim-plugin for haskell (besides one mentioned on haskell.org) ?
23:41:32 <ski> dblhelix : well .. i'm introducing side-effects into haskell .. but only locally .. you still can't call a function with type 'X -> Y' and have it perform side-effects .. effects must still be explicitely marked, just as with monads .. but hopefully in a somewhat less obtrusive way
23:42:31 <ski> sequence [      ] = `[]
23:42:46 <ski> sequence (ma:mas) = `(,ma : ,(sequence mas))
23:42:59 <ski> compare with idiom syntax
23:43:03 <ski> sequence [      ] = pure []
23:43:20 <ski> sequence (ma:mas) = pure (:) <$> ma <*> sequence mas
23:43:27 <ski> or
23:43:33 <ski> sequence [      ] = return []
23:43:40 <dblhelix> ski: are you familiar with "The Marriage of Monads and Effects" by Wadler and Thiemann?
23:43:53 <ski> sequence (ma:mas) = return (:) `liftM` ma `ap` sequence mas
23:44:04 <ski> or do-notation
23:44:09 <ski> sequence [      ] = do return []
23:44:17 <ski> sequence (ma:mas) = do a <- ma
23:44:36 <ski>                        as <- sequence mas
23:44:44 <ski>                        return (a : as)
23:45:00 <ski> dblhelix : i think i have read it some time
23:45:26 <ski> dblhelix : if you think it is relevant, i can reread it
23:45:39 <dblhelix> ski: I think it is... :)
23:47:23 <ski> http://citeseer.ist.psu.edu/wadler98marriage.html
23:47:25 <lambdabot> Title: The Marriage of Effects and Monads - Wadler (ResearchIndex)
23:47:59 <dblhelix> ski: my version is from 2003
23:49:07 <dblhelix> ski: http://portal.acm.org/citation.cfm?id=601775.601776&coll=ACM&dl=ACM&idx=601775&part=periodical&WantType=periodical&title=ACM%20Transactions%20on%20Computational%20Logic%20%28TOCL%29&CFID=8285369&CFTOKEN=87807778
23:49:10 <lambdabot> Title: : Volume 4, Issue 1 , The marriage of effects ..., http://tinyurl.com/y8cujz
23:49:24 <ski> (can't access acm ..)
23:50:10 <ski> (found one on wadler's homepage .. checking that one)
23:52:29 <ski> hm, every paper should have it's date written in it ..
23:52:34 <ski> s/it's/its/
23:52:59 <ski> (".. accepted March 2001" it says)
23:53:15 <dons> try from haskell.org's research page
23:53:49 <dblhelix> @hoogle foldl
23:53:49 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
23:53:50 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
23:53:50 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
23:54:33 <ski> dons : hm, links to the same i just fetched
23:56:47 <dblhelix> ski: accepted March 2001: that's the one
23:58:02 <dblhelix> $ hmake -hat -I. Test
23:58:02 <dblhelix> hat-trans   -I. Data/Foldable.hs
23:58:02 <dblhelix> hat-trans: Variable or constructor not in scope: foldl
23:58:14 <dblhelix> ??? what the... ???
