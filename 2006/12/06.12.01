00:00:17 <mgsloan> i suppose there is the problem of inadvertently deleting parens, especially when the tree goes deep
00:00:26 <mgsloan> and paren counting overload... hmm
00:01:17 <mgsloan> ahwell, the point is it wouldn't have all the crap xml standard shovles on the concept of hierarchical data
00:01:47 <lispy> mgsloan: i read it at c2.com
00:01:57 <lispy> mgsloan: but i'm having trouble finding the exact page
00:02:04 <newsham> msgloan: how is that different from miscounting tag open/closes?
00:02:34 <mgsloan> mostly because end tags are large and name the tag they end
00:02:43 <lispy> mgsloan: http://c2.com/cgi/wiki?XmlIsaPoorCopyOfEssExpressions
00:02:46 <lambdabot> Title: Xml Isa Poor Copy Of Ess Expressions, http://tinyurl.com/yc8ekh
00:02:56 <Korollary> s-exprs are just surface syntax. It doesn't really matter.
00:03:13 <mgsloan> hmm, that's not what i saw, but the person was probably inspired by that
00:04:09 <emu> http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/9d38fdb0162d544c/62803f5d19e653a2?lnk=raot#62803f5d19e653a2
00:04:11 <lambdabot> Title: Google Groups: comp.lang.lisp, http://tinyurl.com/ybjzf8
00:04:28 <mgsloan> Korollary - what does matter is that an s-expr parser will take a few lines of code, and an xml parser will take 1000
00:05:08 <mgsloan> more if you really want to conform, and be fast while doing it
00:05:26 <mgsloan> emu - yep, that was it
00:05:57 <Korollary> mathml is not xml
00:06:13 <monochrom> ????
00:06:24 <Korollary> I meant "stands for all of xml"
00:06:29 <monochrom> ah ok
00:06:30 <mgsloan> it's a format conforming to xml tho
00:07:18 <Korollary> also, that lisp s-expression assumes the lisp semantics (no need for "apply", but you have to put the function as the first elem). XML is a general markup format.
00:08:11 <Korollary> not that I love xml or anything
00:08:12 <emu> XML assumes the "function" as being in the tag
00:08:43 <emu> <foo> .. </foo> and (foo ..) are isomorphic
00:09:24 <mgsloan> It might be best if it was like lisp s-expr but with matched brackets, eg:
00:10:05 <mgsloan> <plus [subtract 1 2] [fraction 1 (plus 3 x)]>
00:10:23 <mgsloan> this way if one was deleted, eg:
00:10:29 <Korollary> This guy can bash XML: http://blogs.msdn.com/ralflammel/archive/2006/07/28/681041.aspx
00:10:32 <mgsloan> <plus [subtract 1 2] [fraction 1 (plus 3 x]>
00:10:34 <lambdabot> http://tinyurl.com/y44neq
00:10:41 <mgsloan> the parser could catch on to what was meant
00:10:48 <emu> yes, that was amusing
00:11:06 <Korollary> I've been messing with xsd types myself, and it's not fun.
00:13:04 <emu> XML just seems like the kinda thing some guy would come up with who would also run up to you and say "oh man, I invented this new system of rules and I think I can prove the consistency of arithmetic!!!"
00:15:19 <int-e> Who came up with the notion that XML is human readable?
00:15:43 <mgsloan> probably because of xhtml
00:16:11 <mgsloan> which really doesn't look much like any other xml doc
00:16:29 <int-e> yes, for markup, used sparingly
00:16:58 <mgsloan> then again html itself is a giant mess
00:17:25 <monochrom> hahaha
00:21:41 <int-e> And once you abandon the idea that XML is human readable, it suddenly becomes awfully bloated and unecessarily hard to parse. The only thing that explains its success for me is that its there, and that it's apparently robust enough to be abused like that. Oh and it has a three letter acronym. Always nice to have that.
00:22:25 <monochrom> That is a revelation.
00:22:47 <monochrom> Haskell is making inroads because it has a three letter acronym too.
00:22:56 <mgsloan> yeah, html was its hold, then magically popped up a bunch of xml evangelists trying to convince you that if your data formats are in xml, other programs that deal with the same type of data will be able to handle it
00:23:02 <campusblo> so guys my haskell group just quit and went to sleep
00:23:22 <campusblo> instead of presenting they will be sleeping or watching cartoons or anything else tomorrow
00:23:22 <monochrom> And so shall you, campusblo.
00:23:40 <campusblo> nah im trying to squeeze something out of this
00:24:02 <campusblo> i figure tomorrow we were supposed to present at 8
00:24:05 <campusblo> its 3 now
00:24:24 <campusblo> ill go in. talk a while and by 9 am ill be rolling some bud
00:24:37 <mgsloan> int-e: I've looked at the spec; xml is a nightmare if you want your parser standards compliant (god, there's even a standard for your api design)
00:25:04 <campusblo> if i paste my assignment will somebody look at it?
00:25:07 <int-e> mgsloan: I gave up on that spec :)
00:25:16 <monochrom> I won't look at it.
00:25:27 <campusblo> ok then
00:25:29 <Pete_I> sounds horrible
00:25:43 <campusblo> be like that
00:25:59 <Pete_I> i might look at it, but it's unlikely i could help any :)
00:26:07 <int-e> campusblo: you could just paste it. maybe you're lucky ;)
00:26:30 <int-e> campusblo: but asking whether someone is going to look at it will not do any good.
00:26:34 <mgsloan> campusblo - if it's a haskell assignment, we'd rather you learned haskell
00:26:44 <mgsloan> (and did it yourself)
00:26:44 <int-e> campusblo: because the only interesting way to answer these questions is to mock them
00:27:04 <Pete_I> darn
00:27:09 <int-e> there, that will teach me trying to be helpful.
00:27:14 * int-e chuckles.
00:27:28 <Pete_I> i was semi-interested, heh
00:27:44 <Pete_I> back so soon?
00:27:56 <campusblo> yeh i have insomnia
00:28:07 <campusblo> doesnt make sense to go to sleep now anyway
00:29:12 <campusblo> im wondering where i could put a word document that maybe somebody in the world will see it and read it
00:29:22 <Pete_I> on the internet?
00:29:55 <monochrom> Put it on your blog.
00:30:06 <mgsloan> Put it on your myspace
00:30:08 <Excedrin> http://worddocs.thatsomeonemightread.com/
00:30:28 <Pete_I> you'd have more luck with an xhtml/html file though, iirc, google doesn't index .doc files
00:30:40 <Pete_I> people don't often search for .doc anyways
00:30:47 <monochrom> Should I do a fusion optimization and shorten "your myspace" to "yourspace"?
00:31:00 <monochrom> It sounds like a great deforestation.
00:31:15 <Pete_I> hmm, google does index .docs
00:31:22 <Pete_I> how ugly, there are quite a few of them
00:32:01 <monochrom> I love the way they use word files to spread trojans.
00:33:10 <Excedrin> monochrom: shorten it to ye
00:33:36 <monochrom> That doesn't preserve semantics...
00:34:13 <monochrom> "Oh come, all ye faithful" does not equivale "oh come all you myspace users"...
00:37:28 <dons> ?users
00:37:28 <lambdabot> Maximum users seen in #haskell: 276, currently: 234 (84.8%), active: 22 (9.4%)
00:39:06 <kzm> Good morning!
00:39:13 <kzm> @seen
00:39:14 <lambdabot> Lately, I have seen dons, excedrin, int-e, kzm, mgsloan, monochrom and pete_i.
00:39:32 <campusblo> hey everybody check out this cool url filled with fun challenges http://campusblo.blogspot.com/
00:39:40 <opqdonut> :D
00:40:06 <campusblo> i know its fun challenging because i have been working on it all week. its better than a rubix cube
00:40:44 * kzm wastes his time writing sequence alignment functions - optimal edit distance, anyone?
00:40:47 <dons> mmm! http://programming.reddit.com/info/t7cu/details
00:40:50 <lambdabot> Title: This file is both a HTML file and a literate Haskell program (reddit.com), http://tinyurl.com/y5z7y8
00:40:55 <dons> the haskell blog world is becoming self sustaining...
00:41:19 <campusblo> the stuff in blue is especially fun to program
00:41:21 <kzm> Victory is ours when all HTML documents are literate Haskell programs!
00:41:34 <dons> hehe
00:42:04 <dons> campusblo: so how's the hacking coming alon?
00:42:06 <dons> g.
00:42:06 <mgsloan> semantic web :)
00:42:11 <dons> you've worked out the database stuff?
00:42:17 <monochrom> Heh that guy took my idea one step further.
00:42:57 <dons> mm. I should write a little script that doublechecks my html files are valid haskell
00:42:58 <campusblo> not so hot. i worked out a few list functions and i generally have a fuzzy idea of what to do
00:43:12 <campusblo> but writing it is the problem
00:43:14 <dons> maybe we should propose this as an extensoin to the usual html verifcation stuf...
00:43:26 <campusblo> i wish my lecturers could read my mind
00:43:30 <dons> campusblo: ok. well, its a new language. takes a while to get enough things together
00:43:43 <dons> you'll get there. you reading Data.List and Prelude docs?
00:43:45 <monochrom> http://www.vex.net/~trebla/haskell/xlhs.xhtml
00:43:45 <dons> ?where Prelude
00:43:47 <lambdabot> I know nothing about prelude.
00:43:53 <dons> ?docs Prelude
00:43:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
00:43:58 <dons> campusblo: memorise this! ^^
00:44:33 <monochrom> I feel that it is not kosher to just include > and < inside <pre> blocks.
00:45:00 <monochrom> However after writing that, I learned <![CDATA[
00:45:29 <campusblo> thing is though most of what i wrote is recursion
00:45:54 <campusblo> this stuff is like standard functions right?
00:46:13 <monochrom> Your lecturer can actually read your mind.  This is why essay questions work.
00:46:23 <dons> monochrom: you should put a link to that in a commen on the reddit'd html<->haskell article
00:46:35 <dons> campusblo: the Prelude, yes.
00:46:37 <monochrom> Sorry I don't care about reddit.
00:46:58 <dons> heh ok. if you'd have put it on reddit, we'd all be aware of this work already... ;)
00:47:08 <dons> (or planet.haskell...)
00:47:20 <monochrom> Now, for a programming assignment, you will also need the computer to read your mind.
00:47:22 * dons encourages monochrom to communicate his hacks!
00:47:32 <campusblo> lol
00:49:42 <monochrom> My xlhs.xhtml is obsolete if you use <![CDATA[
00:57:14 <dons> ended up being some interesting haskell comments on this thread, http://programming.reddit.com/info/t1qf/comments
00:57:17 <lambdabot> Title: How Python is Killing Lisp (reddit.com), http://tinyurl.com/y8fdhz
00:57:35 <dons> mostly about the active community. good to see that impression isn't just ours alone
01:04:21 <greentea> dons: Hmm, i essentially agree with that article.
01:06:20 <greentea> Although i guess i'm coming from the point of view of trying to learn CL specifically, rather than 'Lisp' in general.
01:19:21 <monochrom> "For those who read reddit's comments before following the link: there's nothing new there, just the usual whining. Keep moving."  I like that.  Pretty much sums up most of reddit. :)
01:20:31 <greentea> monochrom: Heh, i only occasionally read the comments; mostly i just use Reddit as an article source.
01:22:40 <dons> greentea: which points? the haskell stuff? or the CL-has-a-weird-community stuff?
01:22:52 <dons> mmm. seems awfully hot tonight
01:23:04 <dons> oh, I see why: 20:18  dons> ?temp
01:23:05 <dons> 20:18  lambdabot>  now 27.7°
01:23:47 <monochrom> lambdabot measures temperature and performs starship control?
01:23:52 <greentea> 27 Angstroms?
01:24:29 <monochrom> ?fire-phaser
01:24:29 <lambdabot> Unknown command, try @list
01:24:44 <monochrom> guess it's a privleged command
01:24:56 <greentea> dons: That CL makes things hard for a newbie.
01:25:16 <dons> can you elaborate? how does it compare to learning haskell, do you think?
01:25:16 <monochrom> ?fire-phaser password Riker alpha sigma chi
01:25:17 <lambdabot> Unknown command, try @list
01:25:51 <greentea> i wanted to use CLisp because, as a newbie, i preferred its REPL to SBCL's. But then, when i wanted to use Readline in a project, that became a huge hassle.
01:25:58 <monochrom> CL is hard for a newbie?  I learned CL in two hours, Haskell in two years.
01:26:19 <dons> greentea: mm. so a tool/interface awkwardness?
01:26:35 <greentea> monochrom: i'm not talking about the language itself; i'm talking about easy-to-install, and available! libraries.
01:26:35 <dons> monochrom: you've learnt haskell now then? :)
01:27:08 <monochrom> OK I admit the school installed CL for us.
01:27:10 <greentea> The hoops that i had to jump through to set up ASDF-install were ludicrous.
01:27:25 <osfameron> haskell isn't seeming like an easy language to learn
01:27:42 <greentea> The Readline libaries relied on FFIs which were under development or not available for CLisp.
01:27:53 <dons> osfameron: keep trying! you're relearning computer science from the other side of the fence, after all ;)
01:28:00 <greentea> Whereas Cabal is /far/ better.
01:28:17 <dons> I think we can do even better with it, as well.
01:28:20 <mgsloan> yeah, the side of the fence where the grass is most certainly greener
01:28:27 <dons> improving the libraries experience is very hot at the moment
01:28:33 <greentea> The overall impression i get of Lisp chauvinists is: Implementing that is trivial. Anyone can do it. But i won't.
01:28:38 <monochrom> 27.7 degrees hot
01:28:41 <dons> hehe
01:29:26 <mgsloan> <ignorant_american_mode> oh no, that's freezing!
01:29:27 <greentea> dons: Yes, and that's interesting in itself - Cabal has given me a far better experience than ASDF-install has, and yet i've seen people saying "Cabal desperately needs to be improved in this area".
01:29:39 <greentea> er, s/this area/such-and-such an area/.
01:30:38 <greentea> The list of Lisp libraries on CLiki is in desperate need of thematic organisation a la CPAN.
01:31:54 <osfameron> I'm not yet sure that the side is 100% greener compared to Perl/Ruby
01:32:22 <osfameron> when by Perl/Ruby, I mean the relatively sane, modern subset of said languages that learns from functional programming, with good engineering practises and a hint of research into OO
01:32:32 <dons> hehe
01:32:33 <osfameron> not the crackfueled shit that I'm maintaining right now...
01:32:41 <greentea> *laugh*
01:32:42 <dons> you need more monads then!
01:32:56 <osfameron> yeah, that'll help :-)
01:33:07 <dons> hhe
01:34:51 <dons> lambdas and a cold beer on a 27 degree friday night. happy happy
01:34:56 <greentea> :-)
01:35:12 <mgsloan> osfameron - truthfully, it really depends on what you value in regards to languages, whether the grass is greener to you.  By learning haskell your values will likely shift, making the grass on this side greener
01:35:27 <mgsloan> as in learning it, you will see its value
01:35:35 <mgsloan> wow, i'm feeling pretty zenish i guess
01:36:06 <mgsloan> though real zen would be less analytical and more confusing ;)
01:38:00 <greentea> "To learn Monads, one must /become/ a Monad."
01:38:01 <greentea> :-P
01:38:19 <mgsloan> :)
01:38:34 <dons> hehe
01:38:45 <dons> ?remember greentea To learn Monads, one must /become/ a Monad.
01:39:14 <monochrom> The monad that can be explained is not the true Monad.
01:39:49 <monochrom> This holds for any abstraction.
01:40:37 <greentea> *chuckle*
01:45:13 <lisppaste2> mgsloan pasted "This is valid?!?! (The where stuff)" at http://paste.lisp.org/display/31099
01:46:09 <lispy> mgsloan: looks fine
01:46:11 <mgsloan> I'm actually rather confused about what's going on there, but it looks very nice :)
01:46:39 <lispy> nesting where is nice
01:46:49 <mgsloan> Just ([0, id], rest) = $(bitSyn [PackedBits [4, 4], Rest]) bytes -- What does this do in the where?
01:46:59 <lispy> i prefer it over let because it allows the code a more declartive feel than let does
01:47:27 <monochrom> definition ::= lhs = rhs where definition
01:47:35 <dons> mgsloan: i'd indent the 'where' to the same level as the first parseTable though
01:47:43 <lispy> > let Just ([0,id], rest) = ([0,2], "hi") in rest
01:47:44 <lambdabot>  Couldn't match `Maybe ([a], b)' against `(a1, b1)'
01:47:50 <monochrom> So certainly where ... where ... where ...  is allowed.
01:47:52 <lispy> > let Just ([0,id], rest) = Just ([0,2], "hi") in rest
01:47:53 <lambdabot>  "hi"
01:47:56 <dons> mgsloan: the $( is a template haskell splice, yeah?
01:47:58 <mgsloan> dons - well, this is from that jpeg haskell thing
01:48:08 <dons> it builds a code fragment at compile time
01:48:12 <mgsloan> dons - oh, i don't know...
01:48:26 <lispy> > let Just ([0,id], rest) = Just ([0,2], "hi") in (id, rest)
01:48:28 <lambdabot>  (2,"hi")
01:48:33 <dons> $(bitSyn [PackedBits [4, 4], Rest]) is run at compiel time, and the resulting code fragment is spliced in
01:48:53 <mgsloan> hmm, interesting
01:49:42 <mgsloan> I guess I hadn't realized lhs = rhs was more than FuncDef Patter = Expr
01:50:19 <mgsloan> especially interesting is that template haskell stuff - I like compile time code stuff
01:50:52 <lispy> TH is certainly cool
01:52:22 <mgsloan> I'm even more for introspective compile time code :)  I should really actually learn lisp one of these days (I've never actually used it, I just appreciate the principles)
01:54:20 <lispy> mgsloan: i've done introspection with some TH before
01:54:30 <mgsloan> shweet
01:54:34 <lispy> mgsloan: i blogged about it, would you be interested?
01:55:11 <lispy> mgsloan: i use the H98 parser at compile time to inspect a module and generated code based on it
01:55:14 <lispy> mgsloan: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
01:55:16 <lambdabot> Title: dagit.o » Blog Archive » Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
01:55:24 <mgsloan> I also mean as a library - eg checking out, modifying the user's code.  I'm interested - I'll stick it in my to read list
01:55:29 <lispy> mgsloan: basically, i generate the test harness tailored to the test suite :)
01:55:51 <lispy> i should update that entry as i've done more on that front
01:56:26 <dons> lispy: you have a blog? is it on planet?
01:56:31 <lispy> dons: yes
01:56:36 <mgsloan> ooh, sounds sweet lispy
01:56:37 <lispy> dons: i just never update
01:56:39 <dons> ah good.
01:57:27 <lispy> for practical use i should maybe just use hunit
01:57:44 <lispy> but oh well :)
01:58:16 <mgsloan> yeah, such stuff is interesting
01:59:00 <lispy> my biggest complaint with my approach is that you end up only being able to test things which are exported from your modules
01:59:03 <osfameron> mgsloan: oh, I've seen *some* things in FP, my Perl gained a lot like appreciation of map/grep/lambda, and so on.  I'm sure monads will be useful too, though I'm not sure they will add *as much* as the whole list-processing functions with lambdas thing which is fantastic
01:59:24 <osfameron> also, map and grep are trivial to learn :-)
01:59:52 <mgsloan> that list processing stuff? in haskell its done with monads - you just don't know it yet ;)
02:00:14 <osfameron> darn tootin'
02:00:25 <osfameron> I'm a "monads are used for sequencing" man myself at the moment :-)
02:01:30 <mgsloan> well, that's one of the ways of thinking about quite a few monads, but that gets confusing when you start applying it to others
02:01:53 <tessier_> Like IO?
02:02:26 <mgsloan> IO is actually about sequencing - sequencing functions, though it is quite a bit different than a list
02:02:55 <lispy> the IO monad is about threading i like to think
02:03:15 <lispy> so that implies the sequencing and the passing along of values
02:03:20 <mgsloan> right
02:03:26 <mgsloan> http://www.alpheccar.org/en/posts/show/60
02:03:28 <lambdabot> Title: A newbie in Haskell land or another monad tutorial
02:03:47 <lispy> and also the IO monad is about encapulation
02:04:07 <lispy> the state your passing around is "stuck" inside your thread
02:04:25 <lispy> so other parts of the program can't depend on it
02:04:28 <mgsloan> good little article on this. ^
02:05:02 <greentea> Well, where i'm at in my understanding of monads is that a monad is a simply an environment in which certain computational rules apply. How accurate is that?
02:05:11 <dons> yeah!
02:05:43 <greentea> Ah good. :-)
02:05:48 <dons> that's the mix-and-match computational view of monads, which is probably the most precise
02:06:00 <dons> (once you explain that the rules are set by how you define >>= and return
02:06:37 <greentea> *nod*
02:07:04 <dons> i wonder: if we'd have done some other solution for IO, there'd probably be no monad do-syntax, and then monads wouldn't be nearly so easy to use.... they'd be as bad as continuations in some other languages
02:07:17 <lispy> and >>= is really easy, it's just flip (=<<)
02:07:21 <dons> the desire to solve IO (which is so important) justified new do syntax for monads
02:08:02 * mgsloan just thinks its too bad that haskell doesn't have mutable syntax stuff
02:08:06 <dons> its wearing the hair shirt that leads to the development of these new interesting technologies, and seeing them made useable
02:08:17 <dons> mgsloan: you can define := though, if you want
02:08:20 * monochrom frowns
02:08:27 <mgsloan> heh true
02:08:30 <monochrom> please don't call these technologies!
02:08:34 <Philippa> and if we had idiom brackets those'd buy us it
02:08:36 <therp> mgsloan: ha, wait for my paper on syntax transformation :)
02:08:39 <dons> let (:=) = flip putIORef in x := 1
02:09:03 <mgsloan> therp - ah, shweet!
02:09:21 <lispy> ?type flip putIORef
02:09:22 <lambdabot> Not in scope: `putIORef'
02:09:24 <monochrom> http://www.vex.net/~trebla/humour/book_for_sale.html    what happens when you call everything a technology
02:09:27 <lambdabot> Title: Book For Sale, http://tinyurl.com/y9729k
02:09:43 <therp> mgsloan: but it won't look like Haskell I'm afraid
02:09:47 <dons> monochrom: ok. 'idea' then ;)
02:10:05 <monochrom> tools
02:10:15 <dons> if we'd have compromised early on the IO, then monads wouldn't have been brougt into focus like they have been
02:10:28 <mgsloan> therp - no, that's what i think would be very nice - syntactic DSLs which translate to haskell or something like it
02:10:38 <dons> so: never compromise, and you'll find some cool new things
02:11:31 <mgsloan> yeah, i need to improve my monadic grasp
02:11:35 <therp> mgsloan: that's what I'm working on. I hope to present a paper at TFP with an embedded prolog, regular expression matching and maybe some querying stuff, but I know nothing about SQL in haskell at the moment
02:11:54 <mgsloan> nice!
02:12:26 <mgsloan> i don't care about SQL :P, I just think DSLs will be part of the future
02:12:42 <mgsloan> and that they won't be horrible to write
02:12:54 <monochrom> and SQL will be one of the DSLs in your future!  bwhahahahaha...
02:13:07 <mgsloan> (because you will have DSLs for writing DSLs ;) )
02:13:15 <mgsloan> hehe
02:14:14 <lispy> bleh, i need a dsl lately for writing SQL
02:14:33 <lispy> the alternative is to code up, ad-hoc, all of our query generation
02:14:48 <osfameron> a DB/object mapper is just a DSL for SQL generation really isn't it?
02:14:51 <lispy> which turns out to be a maitenance nightmare!
02:15:24 <lispy> in our case we need to translate column names based on locale information and we need to change table names dynamically too
02:15:45 <lispy> oh, and in certain cases some columns may be missing
02:15:52 <lispy> it's a nightmare :(
02:16:05 <mgsloan> some people think DSLs will be a maintenance nightmare, I think it will be the reverse, if properly implemented, and the DSL is written by someone with some taste
02:16:27 <osfameron> yeah, declarative stuff is good
02:16:39 <therp> mgsloan: http://clemens.endorphin.org/LskVsLisp.html http://clemens.endorphin.org/LskVsHs.html
02:16:42 <lambdabot> Title: Liskell versus Lisp
02:16:47 <lispy> yeah, i want the DSL to know when it needs to do the two types of name lookup (locale specific vs. dynamic table names)
02:16:50 <therp> I hope that doesn't hit anybody like a rock :)
02:17:10 <lispy> just doing that small thing in a dsl would dramatically reduce our complexity
02:17:24 <lispy> unfortunately it's my coworker who has done most of the dev lately and he dosen't get this stuff
02:17:35 <therp> mgsloan: this is the DSL free stuff. but these things have to be refine a bit more, but everything is working actually due to heavy abuse of TH facilities of GHC..
02:18:04 <mgsloan> hehe
02:18:20 <lispy> therp: that's so cool
02:18:25 <therp> I hope I didn't scare anyone  with these URLs..
02:18:37 <monochrom> It was scary.
02:18:37 <lispy> therp+
02:18:39 <lispy> therp++
02:18:54 <lispy> dons: that's going into HWN right?
02:18:56 <mgsloan> liskell, nice
02:18:57 <therp> is this finally raising my karma? :)
02:19:14 <dons> lispy: what, liskell verus lisp?
02:19:15 <therp> lispy: ah no please, no pushing. I want to present it properly and all working. :)
02:19:25 <lispy> okay
02:19:29 <lispy> dons: cancel that :)
02:19:47 <dons> therp: be sure to reddit it when its done.... it would be kinda popular i imagine
02:19:51 <mgsloan> liskell is longer than both lisp and haskell though :)
02:20:13 <dons> (the last lisp in haskell article went to 1. on the front page, iirc)
02:20:16 <mgsloan> (the code for tic tac toe)
02:20:44 <therp> it's just Lisp syntax at the moment, and therefore nothing special, actually it might scare people. but when I have prolog, a cool regular expression matcher, DRiFT reimplemented I think I can justify and demonstrate the usefulness of the parentheses
02:20:59 <dons> therp: you doing a phd in this stuff?
02:21:04 <dons> its rather exciting
02:21:05 <mgsloan> ah, that'll be awesome
02:21:12 <dons> and research worthy..
02:21:58 <therp> dons: I'm a PhD student yes
02:22:54 <dons> is this part of your research?
02:23:11 <therp> dons: I was actually planning to go for genetic programming, when I discovered that I would need Haskell. but as I'm coming from Lisp and I'm missing my beloved in-compiler-code-transformers I started to code that. so I can write my PhD thesis in that.
02:23:17 <dons> a good embedding of lisp in haskell as a DSL, via TH, would make the haskell workshop...
02:23:31 <dons> something you might want to think about
02:23:32 <therp> dons: I'm not sure. If someone offers me to sponsor me I don't mind at all
02:24:42 * malcolmw gives dons his daily poke in the ribs about fps patches
02:25:38 <therp> the facilities of Liskell allows you to hook much deeper into the compiler than TH will ever be able to.. If someone knows backquoting in Lisp (this `( , ,@) stuff), this can solely be implemented as code transformer. also I will be able to define something like higher order macros. macros that define other macros.
02:26:36 <mgsloan> ah, the symbol stuff?  Heck, I've never used lisp :)
02:27:28 <therp> mgsloan: right, it's a useful to have a special syntax to create symbols. you only need it when writing macros, that is parse-tree transformers
02:27:39 <mgsloan> yep
02:28:28 <_mysty_> Hi. I would like to write a configuration file where I can define some constants. I would like it to be human-readable. Could anyone please suggest a easy way of doing this?
02:28:50 <mgsloan> I guess now I can concentrate on learning haskell better now that various people are working on my language ideas :)
02:29:33 <dons> malcolmw: yep. tomorrow is saturday, and also patchday!
02:29:34 <greentea> Doesn't the MissingH package have configuration file utilities?
02:29:39 <mgsloan> well, it's been interesting, but goodnight
02:29:51 <greentea> Night mgsloan.
02:30:01 <_mysty_> MissingH? I'll have a look...
02:30:16 <greentea> http://software.complete.org/missingh/wiki
02:30:20 <lambdabot> Title: MissingH
02:30:31 <dons> malcolmw: spent the last few days getting my hackathon/popl flights/paperwork... organised. finally done. so time for some code!
02:31:11 <therp> yes, paper work.. I'm writing an extended abstract at the moment. boring. it's not even the real paper :)
02:31:11 <malcolmw> dons: yeah, organising travel takes a huge amount of time more than you might expect
02:32:01 * malcolmw hopes dons doesn't mind me being persistent
02:33:14 <dons> no. its fine. i intend to get it done tomorrow.
02:33:52 <araujo> morning
02:37:47 <Masklinn> Hello everyone
02:41:13 <rahikkala> http://www.rampantgames.com/blog/2006/11/programming-tip-comment-first_17.html
02:41:15 <lambdabot> Title: Tales of the Rampant Coyote: Programming Tip: Comment First, http://tinyurl.com/ymjj2p
02:41:29 <rahikkala> For some reason I think that that advice won't be much appreciated here
02:42:06 <tessier_> I can't get the coders at work to refactor or comment. :(
02:42:26 <tessier_> They are lucky I'm not their boss.
02:42:50 <gds> Or possibly unlucky, in the long term...
02:43:19 <dons> tessier_: you need to employ lambdabot to refactor code, and fire a couple of the real people ;)
02:43:55 <dons> rahikkala: probably here people would say: Programming Tip: Write the type first
02:44:54 <therp> rahikkala: a friend told me recently he programs this way.. this might be feasible for the java stuff he is doing. but I think Haskell expresses the ideas more better than language can do. So the sapir-whorf hypothesis is definately confirmed here.
02:45:23 <tessier_> mo bettah
02:45:28 <tessier_> buttah
02:45:46 <vincenz> therp: regarding liskell, am I correct in assuming you use macros in lisp and then output haskell code?
02:45:58 <vincenz> basically a 2-stage approach?
02:46:18 <therp> vincenz: no, the TicTacToe.lsk thing goes straight into GHC
02:46:39 <therp> the output is a regular .o
02:47:07 <vincenz> how do you get the syntax in?
02:47:11 <therp> or whatever you instruct GHC to produce. the meta programming stuff via compile-time evaluation, much as in TH
02:47:22 <therp> vincenz: hacking GHC :)
02:47:37 <dons> vincenz: he's using macros in haskell
02:47:51 <gds> therp: Perhaps it's useful in haskell at another level of abstraction up - so it's not really useful in java if youre thinking "now increment the variable" - but it is useful in java if you're thinking at haskell natural level of abstraction (as shown in the article)
02:47:54 <vincenz> dons: yeah I know, that's pretty scary
02:48:22 <gds> So, maybe for even bigger/weirder problems it'd be useful here?
02:49:30 <vincenz> therp: btw, nice site in general
02:49:56 <therp> vincenz: oh thank you
02:54:56 <pejo> rahikkala, why would it be bad to write comments in the code?
03:00:48 <vincenz> Anyone know what tool to use to make 3D density plots in linux?
03:01:05 <therp> gnuplot? mathematica?
03:01:10 <therp> maybe even R.
03:01:30 <vincenz> gnuplot does 3D density?
03:01:36 * vincenz needs to draw a 5D graph
03:01:46 <vincenz> so I plan to split it into several 4D graphs
03:01:50 * psnl did 3d plots in gnuplot, but I don't know they are the same type of graph
03:02:00 <vincenz> where the color intensity will be the 4thD
03:02:15 <therp> I'm not sure, but it can draw 3D graphs and it takes external data files.
03:04:23 <vincenz> doesn't do 3D density afaict
03:04:35 <psnl> http://www.lupin.org.uk/tmp/graph.png
03:05:02 * vincenz shakes
03:05:02 <psnl> don't think thats what you want
03:05:09 <vincenz> I need one more dimension
03:05:14 <vincenz> basically the value encoded in color
03:05:16 <gds> vincenz: luminance for one axis, chrominance for another :)
03:05:56 <vincenz> or possibly value encoded in transparency
03:06:06 <psnl> ooh, I'm impressesed with those results
03:06:12 * gds wonders if any tool out there would make that (luma vs chroma) even vaguely easy...
03:06:20 <vincenz> gds: doubt it
03:07:02 <psnl> vincenz: I imagine you have a way to specify the colour of a point in gnuplots input, so all you need is a quick python hack.....
03:07:15 <psnl> s/python/haskell/ ;-)
03:07:42 <vincenz> psnl: well yes, but it would be even neater if I didnt have discrete points
03:07:45 <vincenz> but basically a continuum
03:07:48 <vincenz> like a gaseous form
03:07:52 <vincenz> where density encodes the value
03:07:58 <vincenz> (aka how easily you can see through it)
03:08:07 <vincenz> though perhaps that'd be hard to understand
03:08:19 <psnl> that would be really cool to look at, so if you work out how to do it....
03:09:16 <vincenz> psnl: but your suggestion is not a bad one
03:09:23 <vincenz> thx
03:17:05 <vincenz> ooh nice: http://www.astroscu.unam.mx/~morisset/idl_cours/IDL/3_dim_plotting.htm
03:17:08 <lambdabot> Title: 3 Dim plotting, 4D, http://tinyurl.com/y928y3
03:23:32 * greentea swears at MissingH
03:27:44 <_mysty_> greentea: ?
03:29:10 <greentea> i've been trying to download it, and the whole process has just been ludicrous.
03:30:10 <greentea> Having to do so via Gopher, for a start.
03:30:55 <_mysty_> mm... I've given up on it
03:31:11 <greentea> i'm running Firefox 2.0, which is supposed to support Gopher, but it hasn't been working. So i've instead been using the Floodgap Gopher proxy.
03:31:27 <greentea> After a bit of hunting around, i finally found the directory in which MissingH was stored.
03:31:40 <ms_> locate MissingH ?
03:31:45 <greentea> Downloaded the latest version. Which turns out to require GHC 6.4.2 and above.
03:31:53 <greentea> i'm running 6.4.1.
03:32:47 <greentea> Apparently i should therefore used MissingH 0.14.3 and below - except that version is not available on the Gopher server, and the 0.13.1 version, which /is/, falls over during configuration.
03:32:48 <greentea> Argh!
03:33:13 <kfish> greentea: what distro are you running?
03:33:27 <greentea> And the new Web site for MissingH gives 404 errors when trying to download any version of MissingH.
03:33:32 <greentea> kfish: Mandriva 2006.0
03:33:58 <kfish> ah -- 6.4.1 sounded like it might be debian, for which there's missingh packages :-/
03:34:38 <greentea> Yeah, unfortunately there's no missingh package in 2006.0 Main or Contrib. :-(
03:34:41 <kfish> s/debian/debian stable, or ubuntu/
03:35:49 <greentea> If i uninstall 6.4.1 and install 6.4.2 manually, will i have to reinstall any Haskell packages i've installed via Cabal?
03:49:12 <greentea> Hmm, so i found version 0.14.2 on a Debian ftp server, but that has the same configuration failure.
03:53:19 <dons> greentea: I just built MissingH-0.14.4 with ghc 6.4.2
03:53:39 <gds> greentea: There is a mandriva rpm for ghc6.4.2
03:53:47 <gds> I can't remember where I found it though...
03:53:57 <gds> and pbone doesn't seem to be talking to me atm...
03:54:55 <gds> Ah - in cooker, I think...
03:55:26 <greentea> dons, gds: Thanks, i'm just looking at installing a later-than-6.4.1 version now, in fact. :-)
03:55:38 <gds> Cool :)
03:56:20 <RFairney> quick question, element a of type Node, array b of type [Node] .. should I be able to do a:b to add a to the beginning of the list, or will I need to make a into its own one item list to add it on ?
03:57:22 <audreyt> yes. no.
03:57:34 <greentea> gds: pbone isn't talking to me either. :-(
03:57:34 <audreyt> if latter, use ++ instead of :
04:00:07 <RFairney> ah, thanks, just got to work out my "type errors" wanting a list of lists for some reason now :)
04:03:45 <dcoutts> Nafai, Gtk2Hs doesn't wrap wnck. You could have a go with the Gtk2Hs code generator if you like.
04:09:27 <gds> greentea: :(
04:09:49 <gds> fwiw, the package I have is "ghc-6.4.2-3mdk"
04:10:28 <gds> googleing for that might turn up some working mirrors.
04:11:20 <gds> Ah - http://www.gtlib.gatech.edu/pub/mandrake/devel/2007.0/SRPMS/contrib/release/
04:11:27 <lambdabot> Title: Index of /pub/mandrake/devel/2007.0/SRPMS/contrib/release, http://tinyurl.com/y8skt2
04:15:00 <Cale> shapr: http://xkcd.com/ :)
04:15:01 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
04:15:01 <Cale> hehe
04:15:30 <RFairney> yay pathfinding algorithms in tree data structures
04:17:08 <greentea> gds: Thanks, but that link isn't working for me . . . . think i'll just have to wait until pbone.net comes back up.
04:19:31 <jgrimes> Cale, haha. the current one is pretty good. :)
04:19:40 <Cale> yeah
04:21:49 * SamB_XP wonders how you deal with natural disasters in using IPoD
04:27:14 <RFairney> -.- starting to dislike trees
04:28:11 <Cale> RFairney: why?
04:28:31 <psnl> RFairney: they turn CO2 back into oxygen
04:28:37 <mauke> they want to kill us :(
04:28:45 <Itkovian> yeah, and you can use themn to warm your house
04:31:46 <RFairney> the datastructure, meant to write a search algorithm for a custom defined tree
04:36:55 <Cale> Have you written the fold over that tree?
04:39:53 <RFairney> fold ?
04:39:55 <Cale> yeah
04:40:10 <RFairney> I don't understand
04:40:15 <Cale> basically, you write the function which replaces the constructors of the type with other functions recursively
04:40:48 <Cale> For instance, foldr f z is replacing (:) with f and [] with z throughout a list
04:41:22 <Cale> Suppose you had  data Tree a = Leaf | Branch a (Tree a) (Tree a)
04:41:29 <Cale> then you might write
04:41:36 <Cale> foldTree l b Leaf = l
04:41:59 <Cale> foldTree l b (Branch x t1 t2) = b x (foldTree l b t1) (foldTree l b t2)
04:43:12 <robreim> @seen dcoutts
04:43:13 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 39m 29s ago.
04:43:18 <dcoutts> @arr
04:43:19 <lambdabot> Drink up, me 'earties
04:43:47 <robreim> dcoutts: g'day :) I've got a quick question about treeModelIterNext
04:43:56 <dcoutts> aye
04:44:04 <lisppaste2> robreim pasted "having trouble with gtk2hs" at http://paste.lisp.org/display/31113
04:44:19 <robreim> I've written a map function but it doesn't seem to be updating the iter
04:44:45 <RFairney> hmm, still not sure i quite get it, it'd replace every leaf with an l, and then recursively define b as something else ?
04:45:02 <robreim> If isMore returns True once, it'll get caught in an infinite loop
04:47:35 <dcoutts> robreim, oh! you're quite right.
04:48:06 <dcoutts> it used to work and we changed the TreeIter representation and clearly we didn't update treeModelIterNext
04:48:10 <dcoutts> and broke it
04:48:34 <dcoutts> robreim, take a look at the code, in gtk/Graphics/UI/Gtk/TreeList/TreeModel.chs.pp
04:48:52 <robreim> Ok, cool
04:49:21 <dcoutts> robreim, you'll notice that we use 'with'. This allocates some space and writes the value into that memory chunk to pass it to C land. The C function mutates it inplace, however we don't copy it out again!
04:49:52 <dcoutts> robreim, the representation used to be a pointer to the memory chunk containing the iter, so when C land mutated it, it just worked.
04:50:06 <robreim> Ah I see
04:50:23 <dcoutts> robreim, so what we need to do is to change the type of treeModelIterNext to return Maybe TreeIter
04:50:44 <robreim> Oh cool, that's how I'd like it to work actually :)
04:50:48 <dcoutts> robreim, so if the thing returns True, then we need to use 'peek' to get the new value of the iter
04:51:10 <dcoutts> robreim, think you can fix it? If so please use darcs send to send us the bug fix :-)
04:51:34 <robreim> With all that information I think I should be able to take a crack at it :)
04:51:42 <dcoutts> great, thanks
04:52:22 <robreim> Might there be any other functions which were affected by the change?
04:54:46 <dons> ?users
04:54:47 <lambdabot> Maximum users seen in #haskell: 276, currently: 253 (91.7%), active: 32 (12.6%)
04:55:37 <dons> dcoutts: so all my travel is now book. yay :) 21 hours of flying, but I hope the code will make it worthwhile! :)
04:56:17 <dcoutts> :-)
04:57:50 <dons> suborbital 2 hr .au->.uk flights can't come soon enough, imo :)
04:58:17 <retybok> how do I do integer division in haskell? ie (Integral a) => a -> a -> a
04:58:29 <dons> > 10 `div` 3
04:58:31 <lambdabot>  3
04:58:36 <dons> > 10 / 3
04:58:37 <retybok> dons: thanks
04:58:38 <lambdabot>  3.3333333333333335
04:59:06 <dons> ?hoogle (Integral a) => a -> a -> a
04:59:08 <lambdabot> Prelude.div :: Integral a => a -> a -> a
04:59:08 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
04:59:08 <lambdabot> Prelude.lcm :: Integral a => a -> a -> a
04:59:11 <dons> heh!
04:59:21 <dons> retybok: hoogle is your friend
04:59:39 <retybok> dons: is that only on IRC or can I find it on the web?
04:59:45 <dons> ?where hoogle
04:59:45 <lambdabot> http://www.haskell.org/hoogle
04:59:54 <retybok> wow! cool :)
05:00:21 <opqdonut> yup
05:00:44 <earthy> hm.
05:00:58 <earthy> maybe, just maybe, I should spend some time on getting GHC 6.6 working
05:01:02 <earthy> and then integrate goa
05:01:14 <dons> earthy: are you involved with EHC at all?
05:01:20 * earthy is not
05:01:46 <earthy> my roommate is, however
05:02:31 <dons> this uniquness typing stuff in the HCAR sounds intriguing. it would be nice to see EHC in darcs, and made a first class citizen on haskell.org's implementations page
05:02:43 <earthy> he's here, in fact
05:02:57 * earthy hits amiddelk over the head ;)
05:03:06 <dons> heh
05:03:12 <amiddelk> not irl please :o
05:03:30 <earthy> that'd imply getting up from my chair... blegh :P
05:03:48 <amiddelk> your chair has wheels ;)
05:04:16 <earthy> anyway, ehc is in svn
05:04:35 <dons> yeah, so I see. that makes it second class ;)
05:04:38 <dons> but it shouldn't be!
05:04:57 <earthy> well, it isn't really consumer-ready
05:05:05 <earthy> as in: IO? what IO? :P
05:05:06 <dons> and why isn't it on  the implementations page? http://haskell.org/haskellwiki/Implementations
05:05:08 <lambdabot> Title: Implementations - HaskellWiki, http://tinyurl.com/y2epsa
05:05:09 <dons> ah ok
05:05:11 <dons> hehe
05:05:20 <dons> IO is overrated
05:05:28 <earthy> true enough ;)
05:05:44 <earthy> does help a bit in getting the implementation accepted, though. :P
05:06:04 <mgoetze> why do you guys hate svn? :)
05:06:04 <dons> that's a good point.
05:06:15 * earthy doesn't hate svn
05:06:18 <dons> mgoetze: nah, its just that everything else in haskell is in darcs
05:06:21 <amiddelk> I don't expect a move from SVN to darcs anytime soon for the EHC project
05:06:22 <earthy> darcs is just easier
05:06:33 <earthy> for some development models
05:06:43 <dons> so if all the haskell devs have and use darcs, then it makes it easier to get patches from them
05:07:14 <robreim> Where can I find references which describe how {# blah #} statements work in haskell's FFI?
05:08:03 <dons> amiddelk: ok, fair enough. i might prod you next HCAR though.. :)
05:09:22 <earthy> hm. darcs frontend to svn repositories. isagn
05:11:29 <earthy> the string {# doesn't seem to occur in the haskell ffi addendum to the report
05:11:50 <dons> robreim: are you thinking of something to do with hsc2hs preprocessor tags?
05:11:52 <robreim> Yeah... actually, I'm starting to suspect it might be a pre-processor thing...
05:11:57 <robreim> dons: probably
05:12:15 <dons> like #let and so on
05:12:25 <dons> if so, look up the hsc2hs page in the ghc user's guide
05:12:32 <robreim> dons: tah
05:13:11 <mauke> hsc2hs uses #{ ... }
05:14:36 <earthy> http://progetti.arstecnica.it/tailor/wiki/TwoWaySync seems like it would allow a darcs frontend to a subversion repository...
05:14:39 <lambdabot> Title: TwoWaySync - Tailor - Trac, http://tinyurl.com/yn4xza
05:15:22 <dons> yeah, tailor can convert between the two, iirc. I think the pugs guys do that
05:25:57 <fasta> What is a splay heap?
05:26:51 <fasta> (and is it the same as a splay tree?)
05:27:04 <dons> ?foldoc splay heap
05:27:06 <lambdabot> No match for "splay".
05:27:06 <lambdabot>  
05:27:06 <lambdabot> *** "heap" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
05:27:06 <lambdabot> heap
05:27:06 <lambdabot>  
05:27:08 <lambdabot> [44 @more lines]
05:27:13 <dons> bah
05:27:28 <fasta> Osaki claims to have implemented a splay tree, but I could only find a splay heap.
05:27:50 <fasta> Which leds me to believe that he made up the term splay heap.
05:28:14 * osfameron wonders what definition of "readable" was intended in the reviews he read of Osaki's book...
05:28:30 <aleator> Was splay tree the thing that balances so that most recent items are fastest to find?
05:28:55 <osfameron> yeah, it rebalances on search as well as modify operations
05:31:24 <fasta> Is there a splay tree implementation in Haskell somewhere?
05:31:32 <vincenz> You mean okasaki right?
05:32:23 <fasta> vincenz: right
05:35:13 <norpan> i once did a splay tree implementation in haskell
05:35:17 <norpan> it was surprisingly simple
05:36:42 <norpan> as it will only modify the nodes in the path down to the splayed element, it has reasonable run-time too
05:37:30 <fasta> norpan: Is the space/time complexity the same as of those by Tarjan et al?
05:38:13 <norpan> i would say so
05:38:38 <norpan> i mean they are splay trees
05:39:26 <norpan> you would copy only log(n) nodes in a splay operation
05:40:04 <norpan> amortized of course
05:40:52 <norpan> it behaves like something i read about which were called peristent splay trees
05:40:58 <norpan> persistent
05:41:27 <norpan> only that in haskell you get the persistence for free :)
05:44:15 <ski> norpan : in 'ST s'/'IO' or not ?
05:44:42 <norpan> not
05:45:07 <ulfdoz> Can someone recommend a book about functional programming from a theoretical view? lambda-calculus and the like. It should not focus on a specific language.
05:45:45 <norpan> ski: basically just Tree a (Tree a) (Tree a) and the splay operation
05:46:09 <ski> norpan : does it work amortized, storing "coroutine" state, between invocations of updating operations ? (like, iirc, Okasaki's did)
05:46:15 <fasta> norpan: do you think it would be an odd thing to compare implementations of known algorithms (with the same complexity (thus also using ST and/or IO)) in Haskell?
05:46:24 <ulfdoz> actually I need it for preparation of my exams.
05:47:04 <ulfdoz> Explaination of backgrounds about type systems/inference would also be nice.
05:47:14 <norpan> ski: no, nothing fancy
05:47:36 <norpan> fasta: no, why should that be odd? :)
05:47:38 * ski thinks one possibly could use 'unsafePerfomIO' for updating a splay tree, in a safe way (i.e. pure interface)
05:48:10 <norpan> what kind of IO would you need for that
05:48:15 <norpan> i don't see the need fo riO
05:48:19 <norpan> for IO
05:48:30 <norpan> it's a pure data structure
05:48:42 <ski> when searching in the tree, you would mutate it, so the searched for item relocates to the root
05:48:49 <int-e> hmm, with several threads?
05:49:03 <norpan> ski: yes
05:49:24 <ski> if you has several threads, one would probably need to locally protect it in some way, e.g. locks
05:49:42 <ski> norpan : but, one should be able to give a pure interface ..
05:49:50 <pejo> ulfdoz, Types and Programming Languages by Pierce is great for type systems, but you would need something more for the rest of what you're asking for.
05:49:56 <norpan> i really don't see the point of that, a splay operation would only modify log n nodes of the tree
05:50:14 <norpan> but maybe you can gain something
05:50:30 <norpan> s/modify/copy
05:50:34 <ski> norpan : conceptually, we have an equivalence class .. a particular collection could be represented by several trees .. so it shouldn't hurt if we internally change the representation, while making sure to stay in the same equivalence class
05:50:53 <ski> ulfdoz : maybe Barendregt ?
05:51:02 <ventonegro> main takes no parameters, so, how do I get the command line args?
05:51:06 <norpan> ski: conceptually yes, but you never know which parts of the tree are shared
05:51:19 <ulfdoz> *investigating*
05:51:34 <osfameron> anyone implemented an Ent in haskell ?
05:51:42 <osfameron> or even just an Enfilade
05:51:45 <pejo> ski, was about to suggest that, but that+tapl+.. seems a bit hefty for an exam. :-)
05:51:49 <ski> norpan : yes .. one'd have to take care there
05:51:59 <norpan> you'd have to make the whole tree strict
05:52:10 <ski> @type getArgs
05:52:11 <norpan> the whole tree operation
05:52:12 <lambdabot> Not in scope: `getArgs'
05:52:15 <ventonegro> ok, System.getArgs
05:52:17 <ski> @type System.IO.getArgs
05:52:19 <lambdabot> Not in scope: `System.IO.getArgs'
05:52:22 <ski> @type System.getArgs
05:52:24 <lambdabot> IO [String]
05:52:33 <norpan> and as said by someone else wouldn't work well with threads
05:52:48 * ski wonders what an 'Ent' is ..
05:53:05 <ski> norpan : not sure about that ..
05:53:50 <osfameron> ski: the "Ent" is the whole crazy Xanadu thing, weird data structures for their version of the web
05:54:07 * ski has no idea what that is
05:54:10 <osfameron> but an enfilade is basically like a piece table only hierarchical so with log n access instead of O(n)
05:54:17 <norpan> i say don't mess with IO unless you really need to :)
05:54:36 <norpan> or ST
05:54:43 <ski> 'ST s' would be enough
05:54:44 <ski> (:
05:55:04 <osfameron> a rather self-aggrandizing article about enfilades is at http://xanadu.com/tech/index.html if anyone's interested
05:55:06 <lambdabot> Title: XANADU TECHNOLOGIES-- an introduction
05:55:11 <osfameron> I think some of the ideas are quite cool
06:04:15 <nornagon> ?where yaht
06:04:16 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
06:09:08 <nornagon> so
06:09:25 <nornagon> when's haskell's native bytecode generation getting love? :)
06:09:59 <ibid> that sentence contains more oxymorons than i can count
06:10:16 <nornagon> ... what?
06:10:24 <ibid> at least: haskell's ... code generation; native bytecode
06:10:35 <nornagon> itym 'tautology'
06:10:39 <ibid> nornagon: ie. i have no idea what you are talking about :)
06:10:48 <dylan> "itym"?
06:10:53 <nornagon> i think you mean
06:10:53 <sieni> what's native bytecode?
06:10:57 <ibid> nornagon: no, tautology is totally different, almost the opposite
06:11:04 <ibid> what sieni said
06:11:08 <osfameron> oxymoronic tautology!
06:11:11 <nornagon> okay, maybe i don't know what you mean
06:11:17 <nornagon> but maybe i didn't mean native bytecode
06:11:19 <nornagon> i mean
06:11:29 <nornagon> ghc generates some kind of native code, right?
06:11:34 <nornagon> it produces executables
06:11:38 <ibid> nornagon: tautology means "they say the same thing", oxymoron means "they are mutually incompatible"
06:11:48 <ibid> nornagon: yes, but native code is not bytecode :9
06:11:50 <nornagon> ibid: i know
06:11:52 <mauke> ibid: sure it is
06:11:57 <sieni> http://en.wikipedia.org/wiki/Bytecode
06:12:02 <ibid> mauke: not in the usual use of the term
06:12:03 <mauke> have you ever seen a machine language that's not bytecode based?
06:12:10 <sieni> "Bytecode is a binary representation of an executable program designed to be executed by a virtual machine rather than by dedicated hardware."
06:12:16 <nornagon> mauke: forth, i guess?
06:12:17 <ibid> mauke: bytecode by definition means the machine language of a virtual machine
06:12:41 <nornagon> sieni: okay, that's not quite what i meant, then
06:12:43 <ibid> mauke: it has long since ceased to be byte-based code :)
06:12:50 <nornagon> sorry for the misleading terms
06:12:59 <dylan> ghc produces machine code or C depending on options...
06:13:01 <mauke> that virtual machine may be implemented in hardware
06:13:06 <nornagon> when's haskell's native *code* generation getting love?
06:13:23 <nornagon> dylan: but is its C code any good?
06:13:24 <dons> nornagon: it's getting love. plans are in place. people are hacking
06:13:32 <nornagon> dons: excellent :)
06:13:33 <dons> nornagon: you saw today that with -O -fasm is now the default?
06:13:37 <ibid> mauke: sure, but once the hardware becomes a significant implementation, it's no longer called bytecode
06:13:51 <mauke> it is (by me) :-)
06:13:54 <nornagon> dons: what do those options do? >.>
06:14:19 <w-ber> What is the general strategy of implementing linked data structures in Haskell? I have an algorithm I'd like to use, but it depends on (and its whole point is) manipulating pointers in doubly-linked lists.
06:15:17 <ski> if you need cycles and/or sharing, you'd probably use 'STRef s' (or 'IORef' or 'TVar', etc ..)
06:15:35 <ski> if you don't need those, you can still use those .. or you can use a zipper
06:15:53 <ibid> w-ber: then it probably is the wrong algorithm for haskell use, but if you really need it, use explicit mutable references (IOVar or StRef or TVar))
06:16:21 <w-ber> Well, it *is* very C-spesific in its general philosophy, but in this case I have no choice. :)
06:16:31 <ski> (one can also similate references by integers/unique/keys/whatever that one generates oneself and maps by some association table)
06:16:42 <ski> (s/similate/simulate/)
06:16:51 <w-ber> ski: STRef sounds simpler.
06:17:35 <ulfdoz> Does someone have an opinion about "Functional Programming" from S. 'God of haskell' Peyton Jones, G. Huttin and C. Kehler Holst?
06:18:00 <ibid> uri?
06:18:59 <ulfdoz> ibid: http://tinyurl.com/yf563q
06:19:24 <ibid> ah, never seen that
06:19:55 <mauke> @hoogle (Eq a) => [a] -> [a] -> Maybe [a]
06:19:56 <lambdabot> No matches, try a more general search
06:19:58 * ski discovers 'ibid' is not a valid protocol in his browser ..
06:20:00 <mauke> :(
06:20:41 <ski> mauke : whaddya want ?
06:21:02 <mauke> isn't there something like isPrefixOf that also gives me the rest of the string?
06:21:03 <dcoutts_> dons, ping
06:21:16 <pejo> ulfdoz, it's a volume that contains the papers from the third glasgow workshop on fp?
06:21:30 <dons> dcoutts_: pong
06:21:42 <dcoutts_> dons, what days did you want the hotel booking for ?
06:21:56 <dcoutts_> dons, the rest of the progtools group is doing 13th to 20th inclusive
06:21:59 <LoganCapaldo> @type map(\(x,y) if x == y then Just x else Nothing ) $ zip
06:22:00 <lambdabot> parse error on input `if'
06:22:10 <LoganCapaldo> @type map(\(x,y) -> if x == y then Just x else Nothing ) $ zip
06:22:12 <lambdabot>   Expecting a function type, but found `a'
06:22:12 <lambdabot>    Expected type: [(a, a)]
06:22:28 <dcoutts_> dons, POPL finishes 19th but some of our group are doing some extra conference on the 20th
06:22:36 <dons> dcoutts_: I depart on the 20th, at 4:00pm
06:22:39 <ulfdoz> pejo: Oh, probably too "experimental" and not structured enough for exams.
06:22:48 <dcoutts_> dons, ok, so just until the 19th for you.
06:22:55 <dons> so I need 13->19, inclusive
06:22:57 <dons> yep
06:23:00 <dcoutts_> the night of the 19th yep
06:23:04 <dons> yes
06:23:09 <dcoutts_> ok, ta
06:23:16 <dons> great. thanks
06:23:30 <LoganCapaldo> @type map(\(x,y) -> if x == y then Just x else Nothing ) . zip
06:23:32 <lambdabot>   Expecting a function type, but found `b'
06:23:32 <lambdabot>    Expected type: [a1] -> [(a, a)]
06:23:46 <dons> dcoutts++ travel agent
06:23:51 <dcoutts_> heh
06:24:08 <mauke> @type (map (\(x,y) -> if x == y then Just x else Nothing) .) . zip
06:24:10 <lambdabot> forall b. (Eq b) => [b] -> [b] -> [Maybe b]
06:24:22 <LoganCapaldo> There!
06:24:27 <LoganCapaldo> lol
06:24:38 <mauke> what's that good for?
06:24:42 <LoganCapaldo> I dunno
06:24:55 <LoganCapaldo> But it almost has the right type :)
06:25:04 <mauke> @djinn [a] -> [a] -> Maybe [a]
06:25:05 <lambdabot> f _ a = Just a
06:25:25 <Syzygy-> @hoogle [Maybe a] -> Maybe [a]
06:25:26 <lambdabot> No matches, try a more general search
06:25:51 <Syzygy-> @where Prelude
06:25:52 <lambdabot> I know nothing about prelude.
06:25:58 <mauke> @type sequence (undefined :: [Maybe a])
06:25:59 <lambdabot> forall a. Maybe [a]
06:26:16 <mauke> that still doesn't give me the tail :-)
06:26:29 <Syzygy-> catMaybes may help.
06:26:32 <Syzygy-> @type catMaybe
06:26:33 <lambdabot> Not in scope: `catMaybe'
06:26:34 <Syzygy-> @type catMaybes
06:26:35 <lambdabot> forall a. [Maybe a] -> [a]
06:26:41 <mauke> Syzygy-: how so?
06:26:55 <Syzygy-> In getting from [Maybe b] to Maybe [b]
06:27:45 <mauke> I don't have [Maybe b], and if I wanted to do that, I'd use sequence
06:27:51 <Syzygy-> Ah.
06:28:04 <Syzygy-> Good point...
06:28:54 <ski> > sequence [Just 1,Just 2,Just 3]
06:28:56 <lambdabot>  Just [1,2,3]
06:28:59 <ski> > sequence [Just 1,Nothing,Just 3]
06:29:01 <lambdabot>  Nothing
06:29:09 <dcoutts_> robreim, yay, thanks for the patch
06:29:33 <robreim> dcoutts_: pleasure :)
06:32:08 <LoganCapaldo> > @type groupBy (\x -> case x of Just y -> True; Nothing -> False)
06:32:08 <lambdabot>  Parse error
06:32:12 <LoganCapaldo> gah
06:34:38 <nornagon> ?pl f xs = (head (tail xs))
06:34:39 <lambdabot> f = head . tail
06:35:15 <mauke> cadr
06:35:41 <opqdonut> :)
06:35:42 <w-ber> Car and cdr are horrible names. :)
06:36:06 <opqdonut> no they aren't
06:36:12 <mauke> yes, they are
06:36:20 <osfameron> it's behind you!
06:36:32 <w-ber> The borg?!
06:36:55 <osfameron> they are for historical, which tend to be less valid than other types of reason, but more strongly held...
06:37:17 <LoganCapaldo> Even if car and cdr aren't terrible names, cadr and all it's friends certainly are
06:37:35 <w-ber> It takes a while to parse cadddadr in your mind.
06:37:45 <LoganCapaldo> Yeah, like 1/2 an hour
06:37:47 <LoganCapaldo> ;)
06:38:13 <w-ber> However, I think Haskell's show and read are equally bad names. :)
06:38:47 <Lemmih> What does 'car' and 'cdr' mean, btw?
06:39:14 <greentea> Carry Address Register? iirc.
06:39:17 <dcoutts_> Lemmih, head and tail
06:39:22 <mauke> contents of address/decrement part of register
06:39:26 <dcoutts_> at least in LISP
06:39:28 <ski> 'contents of address register','contents of decrement register'
06:39:29 <greentea> Ah, that's it.
06:39:32 <w-ber> http://en.wikipedia.org/wiki/Car_and_cdr
06:39:32 <mauke> they're machine instructions
06:39:50 <Lemmih> dcoutts_: Did you get my PM?
06:39:50 * greentea should be in bed.
06:44:55 <w-ber> @type map (+) [1,2,3]
06:45:00 <lambdabot> forall a. (Num a) => [a -> a]
06:45:45 <mauke> > map (flip id 42) (map (+) [1,2,3])
06:45:49 <lambdabot>  [43,44,45]
06:47:05 <ski> > foldr (.) id (map (+) [1,2,3]) 0
06:47:06 <lambdabot>  6
06:47:24 <ski> > foldr ($) 0 $ map (+) [1,2,3]
06:47:26 <lambdabot>  6
06:50:46 <nornagon> @type flip
06:50:48 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
06:51:16 <nornagon> ah, swaps the last two arguments of a function?
06:51:30 <resiak> first two, surely
06:51:49 <nornagon> if f a b === a - b then (flip f) a b === b - a ?
06:51:51 <LoganCapaldo> both
06:52:01 <LoganCapaldo> since the first two and the last two are the same ;)
06:52:08 <nornagon> ha
06:52:16 <LoganCapaldo> flip (\x y z q -> 1)
06:52:22 <LoganCapaldo> > flip (\x y z q -> 1)
06:52:23 <lambdabot>  Add a type signature
06:52:41 <w-ber> > let f a b = a-b in (f 1 2, flip . f 1 2)
06:52:42 <lambdabot>  add an instance declaration for (Num (a1 -> a -> b -> c))
06:52:50 <LoganCapaldo> > flip (\x y z q -> 1) :: () -> () -> () -> () -> Integer
06:52:52 <lambdabot>  <() -> () -> () -> () -> Integer>
06:53:02 <LoganCapaldo> hmm
06:53:10 <LoganCapaldo> I thought flip would be upset
06:53:17 <nornagon> > flip (\x y z q -> 1) :: a -> b -> c -> d -> Integer
06:53:18 <lambdabot>  Add a type signature
06:53:25 <nornagon> bah.
06:53:29 <w-ber> > let f :: Int -> Int f a b = a-b in (f 1 2, flip . f 1 2)
06:53:30 <lambdabot>  Parse error
06:53:34 <w-ber> Grh.
06:53:41 <mauke> @type flip (\x y z q -> 1)
06:53:43 <lambdabot> forall a b t t1 t2. (Num t2) => b -> a -> t -> t1 -> t2
06:53:44 <LoganCapaldo> > flip (\x y z q -> x + y + q + z)
06:53:44 <lambdabot>  Add a type signature
06:53:59 <nornagon> heh.
06:54:04 <nornagon> lambdabot is a hard master.
06:54:04 <LoganCapaldo> le sigh
06:54:12 <mauke> > flip (\a b c d -> (a, b, c, d) 1 2 3 4
06:54:12 <lambdabot>  Parse error
06:54:16 <mauke> > flip (\a b c d -> (a, b, c, d)) 1 2 3 4
06:54:18 <lambdabot>  (2,1,3,4)
06:54:26 <LoganCapaldo> and lo
06:54:30 <nornagon> heh.
06:54:33 <nornagon> Occam's razor :)
06:54:38 <LoganCapaldo> it was discovered that it is indeed the first two args
06:54:58 <LoganCapaldo> of an n-ary function
06:55:03 <mauke> > flip id 2 sqrt
06:55:04 <lambdabot>  1.4142135623730951
06:55:47 <LoganCapaldo> I feel like that's evil
06:55:47 <opqdonut> LoganCapaldo: of course, a -> b -> c -> d is a -> b -> (c -> d), and flip does a -> b -> c => b -> a -> c
06:55:59 <LoganCapaldo> opqdonut: Of course it is
06:56:14 <opqdonut> LoganCapaldo: there was no need to test then, right?-)
06:56:19 <LoganCapaldo> Haskell makes me have performance anxiety :)
06:56:23 <mauke> flip id is pretty handy sometimes
06:56:23 <opqdonut> :D
06:58:32 <w-ber> I still have the weight of years of C and C++, so that I'm a bit uncomfortable with higher-order functions.
06:58:58 <w-ber> Well, not uncomfortable. I'm simply not able to compute with them effectively yet.
06:59:01 <dons> > map toUpper "don't be :)"
06:59:03 <lambdabot>  "DON'T BE :)"
06:59:17 <lisppaste2> metaperl pasted "expected type versus inferred type has me confused" at http://paste.lisp.org/display/31122
06:59:38 <dons> its all just about reusable glue. practice gluing things will help, I hope
07:00:25 <w-ber> Oh, I have some good glue in my desk drawer. Effective in gluing plastic pieces together.
07:01:17 <mauke> metaperl: not enough arguments for spacesNeeded
07:01:57 <w-ber> > map digitToInt "yay"
07:01:58 <lambdabot>  Exception: Char.digitToInt: not a digit 'y'
07:02:04 <metaperl> mauke - thanks. the errmsg was pointing at n... i wasnt even looking at spacesNeeded
07:02:25 <nornagon> blaah, yaht's black on white text hurts my eyes
07:02:27 * w-ber wonders what on Earth he just wrote
07:02:34 <nornagon> how do i invert the colors?
07:02:36 <w-ber> > map digitToInt "101"
07:02:37 <lambdabot>  [1,0,1]
07:02:41 <nornagon> do any pdf readers do that?
07:02:42 <mauke> metaperl: well, it has no way to know which type is correct; it just knows that they're different
07:03:45 <dons> > map read "101" :: [Integer]
07:03:46 <lambdabot>  Couldn't match `String' against `Char'
07:04:06 <w-ber> > let stringToInt s = zipWith (*) [1,10..] $ map Char.digitToInt s in "101"
07:04:07 <lambdabot>  "101"
07:04:09 <w-ber> Yay.
07:04:19 <w-ber> Or hmm.
07:04:22 <w-ber> > let stringToInt s = zipWith (*) [1,10..] $ map Char.digitToInt s in "200"
07:04:22 <dons> > map read (map return "101") :: [Integer]
07:04:23 <lambdabot>  "200"
07:04:24 <lambdabot>  [1,0,1]
07:04:47 <w-ber> > let stringToInt s = sum $ zipWith (*) [1,10..] $ map Char.digitToInt s in "200"
07:04:48 <lambdabot>  "200"
07:04:51 <w-ber> > let stringToInt s = sum $ zipWith (*) [1,10..] $ map Char.digitToInt s in "002"
07:04:53 <lambdabot>  "002"
07:05:01 <semanticphilosop> @>list
07:05:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:05:10 <Renkin> Where do I paste code again?
07:05:17 <dons> ?paste
07:05:18 <lambdabot> http://paste.lisp.org/new/haskell
07:05:20 <Renkin> Thanks
07:05:28 <w-ber> Shouldn't the first be ("200") 2*1 + 0*10 + 0*100?
07:05:36 <jdev> Oh, right, and it checks that Int /= Int -> Int before noticing that not Num (Int -> Int), which would be a more relevant error.
07:06:04 <Lemmih> w-ber: You're doing 'let ... in "200"'.
07:06:11 <mauke> jdev: ah, but there may be a Num (Int -> Int) instance :-)
07:06:14 <gds> w-ber: You're defining a function you're not using :)
07:06:17 <lisppaste2> Renkin pasted "Ambiguous occurance 'return'" at http://paste.lisp.org/display/31123
07:06:20 <mauke> I have a program for that
07:06:35 <Renkin> Why doesn't that code work?
07:06:39 <w-ber> gds: I *was* wondering. :)
07:06:42 <gds> > let stringToInt s = sum $ zipWith (*) [1,10..] $ map Char.digitToInt s in stringToInt "002"
07:06:43 <lambdabot>  38
07:07:17 <Lemmih> > take 5 [1,10..]
07:07:18 <lambdabot>  [1,10,19,28,37]
07:07:35 <Renkin> Oh, Replay q r a is defined as Trace r -> IO (Either (q, Trace r) a)
07:08:00 <w-ber> Well, at least there's an interesting number base.
07:08:36 <LoganCapaldo> yay! literate programming! http://www.imperialviolet.org/binary/jpeg/
07:08:38 <lambdabot> Title: Exploring JPEG
07:09:11 <SemanticPhilosop> ?
07:09:19 <w-ber> let stringToInt s = sum $ zipWith (*) (iterate (*10) 1) $ reverse $ map Char.digitToInt s in stringToInt "105"
07:09:20 <SemanticPhilosop> ?help
07:09:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:09:22 <w-ber> > let stringToInt s = sum $ zipWith (*) (iterate (*10) 1) $ reverse $ map Char.digitToInt s in stringToInt "105"
07:09:23 <lambdabot>  105
07:09:24 <SemanticPhilosop> ?list
07:09:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:09:46 <dons> SemanticPhilosop: you can priv msg the bot to play with it
07:10:07 <SemanticPhilosop> tanks
07:10:17 <w-ber> ?pl stringToInt s = sum $ zipWith (*) (iterate (*10) 1) $ reverse $ map Char.digitToInt s
07:10:18 <lambdabot> stringToInt = sum . zipWith (*) (iterate (10 *) 1) . reverse . (map Char .) . digitToInt
07:10:25 <Renkin> For "do res <- p; return (Right res)", shouldn't the compiler realize I want the IO return if p is of type IO a ?
07:10:32 <w-ber> Hey hey, that's not right.
07:10:33 <metaperl> paste.lisp.org is down...
07:11:09 <dons> Renkin: yeah. looks fine to me.
07:11:20 <Renkin> It doesn't work, though
07:11:23 <dons> > do res <- getline ; return (Right res)
07:11:23 <metaperl> is there a more l33t way to do this: http://rafb.net/paste/results/gSllBN93.html
07:11:23 <lambdabot>  Not in scope: `getline'
07:11:28 <dons> > do res <- getLine ; return (Right res)
07:11:29 <lambdabot>  Add a type signature
07:11:36 <Renkin> Oh
07:11:45 <dons> > do res <- getLine ; return (Right res) :: IO (Either String String)
07:11:47 <lambdabot>  <IO (Either [Char] [Char])>
07:11:53 <LoganCapaldo> lambdabot: Be more infererring!!!!
07:12:10 <xerox> cool, IO?
07:12:14 <Renkin> Ok, so you actually need to specify?
07:12:31 <dons> for the case of Either, yeah, you'll need to specify the Left case in the type, I suspect
07:12:48 <Lemmih> @type do res <- getLine ; return (Right res)
07:12:49 <lambdabot> forall a. IO (Either a String)
07:12:54 <Renkin> Alright
07:13:00 <LoganCapaldo> wait
07:13:16 <LoganCapaldo> Monad instances can be functions!?
07:13:35 <dons> ?instances Monad
07:13:36 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:13:36 <xerox> Some functors are monads.
07:13:51 <metaperl> all monads are functors
07:13:51 <dons> functions are monads ;)
07:14:01 <metaperl> says metaperl the parakeet
07:14:02 <LoganCapaldo> My tenous grip on reality just shattered
07:14:16 * shapr yawns
07:14:17 <dons> ((->) r) is the Reader monad
07:14:32 <shapr> Cale: haha, good comic
07:14:33 <LoganCapaldo> Thanks a lot guys. I'm gonna go cry now
07:14:48 <Cale> LoganCapaldo: hehe
07:14:48 <mauke> > (do { x <- sqrt; (+) x }) 2
07:14:50 <lambdabot>  3.414213562373095
07:14:56 <dblhelix> @localtime dons
07:14:58 <lambdabot> Local time for dons is Sat Dec  2 02:10:13 2006
07:15:02 <dblhelix> pff...
07:15:27 <nornagon> @localtime nornagon
07:15:30 <lambdabot> Local time for nornagon is Sat Dec  2 02:10:38 2006
07:15:46 <nornagon> how profoundly useless :)
07:16:04 <w-ber> Monads are so often related to I/O and the like that you forget what they really are. :)
07:16:04 <dylan> not useless, it's easier to type than /ctcp ...
07:16:20 <nornagon> dylan: i have /alias time /ctcp $0 time
07:16:30 <dons> nornagon: doesn't have the public aspect
07:16:35 <nornagon> that's true
07:16:40 <dons> in channel, @time can be effectively used as an action
07:16:45 <nornagon> @time
07:16:57 <dons> @time lambdabot
07:16:58 <lambdabot> I live on the internet, do you expect me to have a local time?
07:17:03 <dons> i do!
07:17:05 <nornagon> cute
07:17:07 <w-ber> @localtime White House
07:17:14 <dcoutts_> dons, I've got it scanned
07:17:16 <w-ber> :(
07:17:21 <dons> dcoutts_: cool
07:17:27 <dons> btw, @time == @localtime
07:18:09 <Nafai> Morning
07:21:14 <gds> @hoogle fix
07:21:14 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
07:21:15 <lambdabot> Control.Monad.Fix :: module
07:21:15 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
07:21:55 <metaperl> Nafai - good morning
07:22:25 <lisppaste2> Renkin pasted "Replay monad trouble" at http://paste.lisp.org/display/31125
07:22:39 <Renkin> There, a bit more clear, that paste
07:22:46 <Renkin> If anyone wanna look at it
07:23:08 <dcoutts_> dons, sent. You might want to just have a quick check that it looks ok.
07:23:46 <twanvl> Renkin: you need indentation after the instance .. where, otherwise you are declaring new functions in module scope
07:24:04 <Renkin> Oh :)
07:24:06 <Renkin> Thanks
07:24:13 <Nafai> dcoutts_: You mentioned something about using the h2gtk code generator to wrap wnck....where can I look at how to use this code generator?
07:24:27 <Renkin> That saved me a lot of headache =)
07:24:44 <dcoutts_> Nafai, it's in the gtk2hs darcs repo, under tools/apiGen
07:24:46 <dons> dcoutts_: great! looks fine.
07:24:55 <dcoutts_> dons, ok, good.
07:25:01 <Nafai> dcoutts_: Cool, thanks
07:25:04 <dons> we have the technology! :)
07:25:18 <dcoutts_> Nafai, it's not perfect, it needs a little hand holding to make it work
07:25:50 <dcoutts_> Nafai, and the code it generates often still needs a little tweaking but it can still really save time
07:26:08 <dcoutts_> we use it for the main gtk lib and a couple other gnome libs
07:26:29 * Nafai nods
07:26:45 <Nafai> I have a program that I started in Python that uses wnck that I would like to port to Haskell, so I think I might look at this
07:27:09 <opqdonut> ?pl \x y -> x:y:[]
07:27:09 <lambdabot> (. return) . (:)
07:27:27 <dons> mm, nice,   * Add support for the IO manager thread on Windows
07:29:13 <dons> Renkin: this replay monad looks curious, what's the plan?
07:34:42 <Renkin> dons: To make a monad that's a program that produces a trace. You can also run a program with a trace, thus Replay
07:35:04 <dons> oh, nice.
07:35:06 <sjanssen> dons: "Decouple -O from -fvia-C" also looks interesting
07:35:24 <dons> sjanssen: yeah, sounds like the -fasm++ move is on
07:35:39 <Renkin> It's the first part of a school assignment
07:35:52 <Renkin> The final goal is to use the monad to implement a CGI-program
07:35:58 <dons> Renkin: in haskell? or you chose to use haskell?
07:36:07 <Renkin> Haskell course :)
07:36:18 <dons> (this trace monad could be bottled up, if it works out. you might want to put it on the wiki at lesat, when you're done)
07:36:32 <Renkin> Or functional programming course
07:36:53 <dons> Cale: didn't you have a TraceT monad of some kind?
07:36:55 <Renkin> Cool, I'll think about that if the result is any good :)
07:37:55 <dons> Renkin: so your assignment task is to invent a new monad?
07:38:10 * dons thinks we should all be going to Renkin's uni...
07:38:29 <Renkin> No, actually this is a given task
07:38:44 <Renkin> But the final assignment is to make your own library, monad or not
07:39:00 <dons> the Replay monad is the given task? or you just thought that would be a good design?
07:39:17 <psnl> where do you go to uni?
07:40:01 <Renkin> dons: The interface for the Replay monad is given, the rest has to be invented
07:40:06 <Renkin> psnl: Chalmers, Sweden
07:40:20 <dons> ah, that explains it :)
07:40:27 <psnl> heh
07:40:30 <metaperl> :)
07:40:38 <psnl> I should have guessed
07:41:08 <dons> more monad transformers per head of population than anywhere
07:41:16 <Renkin> Yeah, we have quite a bit of Haskell there, I understand :)
07:41:44 <dons> Renkin: I believe the haskell weekly news is even posted outside bringert's office
07:42:43 <Renkin> I was there today, but didn't notice any :)
07:42:46 <Renkin> Didn't look, though
07:45:44 <dons> ?users
07:45:44 <lambdabot> Maximum users seen in #haskell: 276, currently: 259 (93.8%), active: 50 (19.3%)
07:45:57 * dons `ap` sleep
07:46:44 <w-ber> Renkin: So would Chalmers be a good place to come for a PhD? :)
07:47:36 <Renkin> w-ber: Probably, I like the place :)
07:50:10 <Nafai> Has anyone written a Haskell library for delicious?
07:50:43 <Renkin> The lecture today was about Fudgets, which was apparently made as a thesis at Chalmers
07:51:20 <mauke> @hoogle Maybe [a] -> Bool
07:51:21 <lambdabot> No matches, try a more general search
07:51:21 <Renkin> Really interesting way to structure GUI
07:53:16 <LoganCapaldo> Functional Budget?
07:53:30 <LoganCapaldo> Tiny pieces of fudge?
07:53:39 <LoganCapaldo> Sounds tasty
07:53:45 <Renkin> Yeah, I was thinking Fugde when I heard it =)
07:53:54 <Renkin> Functional Widgets
07:54:24 <cjeris> as opposed to Fudgies which are large tropical birds that qwark monad transformers...
07:55:32 <LoganCapaldo> @hoogle qwark
07:55:33 <lambdabot> No matches found
07:55:44 <Cale> http://en.wikipedia.org/wiki/Fudgie_The_Whale
07:57:05 <cjeris> oh dear.  i'm not sure a chocolate brown whale is really an attractive thought.
07:57:24 <LoganCapaldo> woah
07:57:35 <LoganCapaldo> fudgets are the new hotness
07:57:59 <LoganCapaldo> facF = intDispF >==< mapF fac >==< intInputF <--- New hotness
07:58:19 <Syzygy-> Huh?
07:58:49 <LoganCapaldo> facF is a widget consisting of an in display which contains the result of the fac function applied to the contents of the text box
07:59:03 <LoganCapaldo> I want some fudgets
07:59:14 <mauke> @hoogle Maybe a -> Bool
07:59:16 <lambdabot> Maybe.isJust :: Maybe a -> Bool
07:59:16 <lambdabot> Maybe.isNothing :: Maybe a -> Bool
08:00:20 <sjanssen> http://www.rubyquiz.com/quiz104.html -- what I've always wanted, a perfect chance to write a turtle monad
08:00:20 <lambdabot> Title: Ruby Quiz - Turtle Graphics (#104)
08:08:36 <mauke> @pl mw l a = foldl' (\a x -> a >>= x `dropInfix` a) a (return l)
08:08:37 <lambdabot> mw = flip (foldl' (const (ap (>>=) (join dropInfix)))) . return
08:09:01 <mauke> @pl mw a l = foldl' (\a x -> a >>= x `dropInfix` a) a (return l)
08:09:01 <lambdabot> mw = (. return) . foldl' (const (ap (>>=) (join dropInfix)))
08:09:45 <Renkin> ?paste
08:09:46 <lambdabot> http://paste.lisp.org/new/haskell
08:11:23 <Renkin> ?instances Read
08:11:25 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
08:12:35 <lisppaste2> Renkin pasted "Problem with read" at http://paste.lisp.org/display/31126
08:13:04 <Renkin> Another problem that might be me missing something elementary
08:13:46 <w-ber> > let eat = "*chomp*"; my shorts = id in eat my shorts
08:13:47 <lambdabot>  Not in scope: `shorts'
08:14:07 <w-ber> > let eat = "*chomp*"; my = id in eat my shorts
08:14:08 <lambdabot>  Not in scope: `shorts'
08:14:38 * w-ber does not want to define shorts
08:18:26 <Renkin> > read "stuff" :: String
08:18:27 <lambdabot>  Exception: Prelude.read: no parse
08:18:40 <Renkin> read "2" :: Int
08:18:49 <mauke> > read "\"a\\nb\"" :: String
08:18:51 <lambdabot>  "a\nb"
08:18:53 <Renkin> > read "2" :: Int
08:18:54 <Renkin> even
08:18:54 <lambdabot>  2
08:19:01 <Renkin> Oh, of course.
08:19:28 <Renkin> > show "stuff"
08:19:29 <lambdabot>  "\"stuff\""
08:19:34 <Renkin> Awesomeness
08:20:02 <ski> > take 16 $ fix show
08:20:04 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\"
08:20:12 <Vq^> @get-shapr
08:20:13 <lambdabot> shapr!!
08:20:26 <Renkin> > read "'c'" :: Char
08:20:28 <lambdabot>  'c'
08:20:31 <Renkin> So that's it.
08:21:20 <Syzygy-> > let eat = const; my = "*chomp*" in eat my shorts
08:21:20 <lambdabot>  Not in scope: `shorts'
08:21:35 <Renkin> Haha, those shorts are causing trouble
08:21:54 <ski> dons : it is posted outside bringert's office, yes .. saw it today in fact
08:22:10 <Renkin> Not in scope: `shorts', Reason: already eaten
08:22:50 <Renkin> @index fix
08:22:51 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
08:26:31 * ski grumbles at his 'Replay' monad ..
08:28:01 <ski> .. wonder if one can make monad bitransformers, somehow ..
08:28:51 <dylan> bit transformers -- monads in disguise!
08:28:57 <dylan> (sorry)
08:29:15 <ski> nono .. bi-transformers
08:29:44 <ski> i.e. you put (somehow) two monads (in parallel) around it ..
08:30:49 <ski> i have  type Foo a = BarT (..) (BazT (..a..) (Quux (..))) a
08:31:18 <ski> the problem is that 'a' occurs inside, amongst the transformers, and not just at the end ..
08:32:42 <Nafai> It's going to take a while for Haskell to sink in, I think
08:33:09 <ski> hm
08:33:19 <ski> instance Monad Sink
08:33:45 <ski> (e.g. kitchen sink)
08:33:52 <ski> instance Comonad Source
08:34:00 <ptolomy> I've had very little luck searching the haskell wiki recently....
08:34:08 <ptolomy> What is the difference between ST and State monads?
08:34:36 <ski> the 'State s' monad stores a single piece of state of type 's'
08:34:59 <ptolomy> Ah.
08:35:01 <ptolomy> Heh.
08:35:08 <dons> ?docs Control.Monad.ST
08:35:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
08:35:11 <dons> ?docs Control.Monad.State
08:35:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
08:35:13 <ski> the 'ST s' monad can store many pieces of states, that are referred to by 'STRef s' references .. and these can be dynamically allocated
08:35:14 <ptolomy> ST is like IO, but without IO-eyness.
08:35:30 <ptolomy> STRef, STArrays
08:35:35 <dons>     return x = ST (\ s -> (# s, x #))
08:35:35 <dons>     m >> k   = m >>= \ _ -> k
08:35:36 <dons>     (ST m) >>= k
08:35:36 <dons>       = ST (\ s ->
08:35:36 <dons>     case (m s) of { (# new_s, r #) ->
08:35:39 <dons>     case (k r) of { ST k2 ->
08:35:41 <ski> also, typically 'ST s' is implemented directly in terms of allocating memory and changing it
08:35:41 <dons>     (k2 new_s) }})
08:35:44 <dons> that's ST.
08:35:46 <dons> (scary!)
08:36:13 <ski> while 'State s' probably (if compiler doesn't manage to do much optimisation) will copy around states
08:36:17 <dons> whereas Monad State is not so scary:
08:36:18 <dons>     return a = State $ \s -> (a, s)
08:36:18 <dons>     m >>= k  = State $ \s -> let
08:36:18 <dons>         (a, s') = runState m s
08:36:19 <dons>         in runState (k a) s'
08:37:05 <ptolomy> dons: Sometimes I get the impression that you are or could be a paid haskell community fairy godmother, and I mean that way the best way possible.
08:37:38 * Syzygy- grumbles a bit... There are days when I really do feel like reimplementing Magma or GAP in Haskell.
08:37:47 <ski> (not "fairy godmother", then ?)
08:38:09 <dons> ptolomy: I'm just another phd student working in haskell
08:38:17 * ski needs to learn how to read all words
08:38:34 <dons> ?time dons
08:38:38 <lambdabot> Local time for dons is Sat Dec  2 03:33:53 2006
08:38:40 <dons> who needs to go to sleep. night!
08:38:42 <Syzygy-> dons: Which is pretty much the kind of fairy godmother he talks about. :)
08:38:47 <Syzygy-> Night, dons.
08:38:48 <Nafai> Sleep
08:38:52 <Nafai> That would be nice
08:38:57 <Syzygy-> ?time Nafai
08:38:59 * ski 's planning to go to sleep in a few minutes
08:38:59 <lambdabot> Local time for Nafai is Fri Dec  1 10:34:16
08:39:04 <ski> @time ski
08:39:16 <Syzygy-> Are ? and @ equivalent modes of adressing the lambdabot?
08:39:22 <Syzygy-> ?time ski
08:39:25 <lambdabot> Local time for ski is Fri Dec  1 17:50:03 2006
08:39:29 <Syzygy-> I guess not...
08:39:33 <ski> hm
08:39:38 <Syzygy-> ski: You may want to set your clock... :P
08:39:38 <ski> @users
08:39:39 <lambdabot> Local time for ski is Fri Dec  1 17:50:19 2006
08:39:41 <w-ber> I'm probably as sleepy as dons, even though it's not that late here...
08:39:51 <lambdabot> Maximum users seen in #haskell: 276, currently: 262 (94.9%), active: 54 (20.6%)
08:39:58 <Syzygy-> ?users
08:39:59 <lambdabot> Maximum users seen in #haskell: 276, currently: 262 (94.9%), active: 54 (20.6%)
08:39:59 <ski> Syzygy- : um, why ?
08:40:17 <Syzygy-> The rest of the world is on hour.35-ish. You're on hour.50.
08:40:21 <ski> Syzygy- : my wrist watch says 17:36
08:40:28 <Syzygy-> And I don't believe in 25-minute timezones :)
08:40:33 <Syzygy-> Local time for ski is Fri Dec  1 17:50:03 2006
08:40:34 <gour> xerox: goa does not load here (amd64, ghc-6.6)
08:40:40 <w-ber> There are 30-minute timezones in Australia. :)
08:40:44 <ski> (oh .. that small abberance :)
08:40:50 <w-ber> I think there's one in India or Pakistan, too.
08:40:52 <Syzygy-> w-ber: Yeah, but even those aren't 25 minute timezones
08:41:32 <w-ber> Iran might be h.30 too.
08:42:44 <gds> > 50 - 35
08:42:52 <lambdabot>  15
08:42:52 <w-ber> http://timeanddate.com/worldclock/custom.html?sort=2
08:42:54 <lambdabot> Title: The World Clock - Time Zones - sorted by time zone, http://tinyurl.com/ydplgc
08:43:29 <w-ber> 19:37 in Kuwait, 20:07 in Tehran.
08:44:31 <w-ber> There are actually quite a few +30 minute offsets in Asia and Oceania.
08:45:41 * gds doesn't know of any 15 min ones...
08:45:45 <gds> ;)
08:49:18 <w-ber> Urgh. I slept ten hours last night and woke up at 9. Now it's ten hours later and I'm again sleepy.
08:49:26 <w-ber> Feels like my head was filled with putty.
08:53:02 <lisppaste2> metaperl pasted "i'm need help with this type error... " at http://paste.lisp.org/display/31129
08:55:01 <Botje> metaperl: you should write type signatures to go with your functions
08:55:07 <Botje> that helps me to focus, at least
08:55:22 <metaperl> oh ok... yeah I'm doing that mentally now
08:55:31 <metaperl> let me physically add them
08:56:26 <shapr> Vq^: you screamt?
08:56:53 <w-ber> Adding type signatures helps tremendiously, because now we (or at least I) don't know what to expect with the functions. :)
08:56:57 <mauke> ah, damn byte order conversions
08:58:00 <mauke> but my unix lib seems to work :-)
08:58:23 <w-ber> Middle endian is funky.
08:58:51 <mux> pdp-endian?
08:58:58 <metaperl> Botje - know what the problem was? I typed replicate s " " instead of replicate s ' '
08:59:16 <metaperl> so it expected the wrong type for w
09:00:14 <Botje> metaperl: yay. now write the type signatures before the code, next time : )
09:00:27 <Botje> << more reading!
09:00:29 <metaperl> that would not have helped though
09:00:33 <metaperl> oh , it helps out others
09:00:37 <gds> http://news.bbc.co.uk/1/hi/sci/tech/6191462.stm -- Computational archeo-linguistics ;)
09:00:40 <Botje> that too.
09:00:40 <lambdabot> Title: BBC NEWS | Science/Nature | Ancient Moon 'computer' revisited, http://tinyurl.com/yg9wkq
09:03:46 <norpan> well, it's just a fancy clock
09:04:02 <Spark> i read that earlier, amusing that they had to infer what it looked like from a partial collection of cogs
09:07:06 <w-ber> norpan: A clock at a time when there were no other mechanical clocks than sun dial, water clock, and sandglass.
09:07:37 <norpan> of course there were other clocks
09:07:46 <norpan> we just haven't found them
09:08:08 <norpan> i find it hard to believe that the first clock was one that not only shows time, but also the movement of celestial bodies
09:08:35 <norpan> it's a great discovery, but far from a computer, that's what i mean
09:09:39 <w-ber> Well, Heron did create complex automatons, but as any high tech, those have not survived.
09:09:54 <w-ber> I don't expect there to be any visible sign of modern computers in 200 years, bar some waste.
09:10:51 <w-ber> Seems to be called Hero in anglo-saxon world: http://en.wikipedia.org/wiki/Hero_of_Alexandria
09:10:54 <lambdabot> http://tinyurl.com/y86z4j
09:11:33 <metaperl> w-Ber - what do you expect in 200 years?
09:11:58 <w-ber> metaperl: Total collapse of modern civilization? :)
09:12:07 <metaperl> ah...
09:12:27 <metaperl> w-ber - any thoughts on the year 2012
09:12:30 <w-ber> If not collapse, I don't think reading or accessing information of this age will be easy, unless it is printed on paper.
09:12:36 <w-ber> Try to open a file made in 1980s.
09:12:47 <norpan> the singularity is near
09:12:49 <w-ber> metaperl: I'll tell you in six years.
09:12:52 <metaperl> lol
09:13:15 <shapr> w-ber: I use the jwz backup method
09:13:24 <metaperl> norpan - singularity? what does that mean?
09:13:27 <gds> metaperl: are you suggseting civilisation might end during the London Olympics? ;)
09:13:48 <norpan> metaperl: http://en.wikipedia.org/wiki/Technological_singularity
09:13:50 <lambdabot> http://tinyurl.com/485ey
09:13:53 <metaperl> gds - 2012 is the end of the Mayan Calendar... and the time of galactic alignment
09:14:35 <gds> Ah :)
09:14:55 <norpan> 2012 is a bit too soon for the singularity i believe
09:15:01 <w-ber> 2020 is a safer bet.
09:15:46 <profmakx> hm
09:15:50 <profmakx> World-Domination-Monad?
09:15:59 <w-ber> http://www.religioustolerance.org/end_wrld.htm
09:16:01 <lambdabot> Title: The millennium and end-of-the-world predictions., http://tinyurl.com/qk496
09:16:57 <norpan> 2045, mainly due to nanotechnology and with that custom genetic engineering
09:17:42 <w-ber> shapr: What about old disks? Where do you get the disk drives?
09:17:55 <w-ber> shapr: 8" floppies? Magnetic tapes? Punch cards?
09:19:58 <Vq^> shapr: nope, lambdabot did it for me :o)
09:20:50 <metaperl> if you wanted to write a function to see if a string were a palindrome, and this function had to ignore punctuation, could you do it in Haskell without first filtering the string? I.e., in one pass
09:21:36 <xerox> use fold and skip punctuation
09:22:02 <metaperl> let s = filter notIsPunct str in reverse s == s
09:23:00 <metaperl> xerox - lil mo help please :)
09:23:32 <xerox> @google a tutorial universality fold
09:23:34 <metaperl> xerox - fold works from one end of the string. we must simutaneouly check both ends
09:23:35 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.ps
09:23:45 <mauke> meh, looks like ghc's threads don't really thread; they need help from the IO system
09:24:03 <xerox> you can build out a whole function that short-cuts, I think... I also think that paper explains the way to do it
09:24:23 <mauke> so now I need to write a threading system
09:26:00 <norpan> even readin a 5.25" floppy is hard
09:26:07 <norpan> i have a drive lying around
09:26:30 <norpan> but most of they time the disc is demagnetized
09:26:35 <shapr> w-ber: The jwz backup method is to copy your homedir onto your new installation everytime you setup a new system. I think I have four or five layers.
09:29:48 <Philippa> w-ber: old disks weren't on networked machines - newer ones tend to be
09:30:03 <Philippa> shapr: I've got a variant thereof going on (been running windows for the last decade though)
09:30:43 <Philippa> this is the first machine I'm really trying to treat as multi-user though
09:30:52 <shapr> Yeah, my oldest layer is from my last windows 95 installation. It's too bad Windows apps mostly use binary file formats.
09:34:56 <w-ber> shapr: Good idea, but it's hardly convenient to copy gigabytes and terabytes of data around. You'll eventually have to resort to external media or a disk farm.
09:35:36 <w-ber> Philippa: Maybe you don't want to have multiple copies of data (except for the backup).
09:36:33 <Philippa> "except for" being the big deal :-)
09:36:35 <Philippa> sure, only one's live...
09:36:58 <Philippa> copying gigabytes is slow, yes. Took me a couple of hours to shunt data off one of the previous machine's HDs. I kept the other two.
09:37:12 <w-ber> Besides, think about it in a wider perspective than just "your data". What about libraries? Corporations? Government data? NASA?
09:37:29 <Philippa> you mean organisations that're rather more likely to have plans for this than I?
09:37:52 <shapr> w-ber: Purchasable hard drive size increases at a sufficient rate for me to dump my entire home dir onto my new drive with no problem.
09:37:53 <w-ber> No, I mean NASA has storage media dating back to 1970s that are beginning to get corrupted.
09:38:23 <shapr> I just put both drives into the same machine and slurp it over.
09:38:35 <Philippa> *nod* - but because they know that, they're less likely to fail to copy data off older media in future
09:38:56 <Philippa> the original physical substrate's not the issue, just the bits, right?
09:39:24 <w-ber> The issue, as I see it, is that there is no permanent digital storage media. Paper is much more durable if we are talking about reading the information.
09:39:36 <Philippa> some paper is
09:39:53 <Philippa> a lot isn't necessarily, say, an order of magnitude more durable
09:39:57 <w-ber> Are you able to read a file made with some obscure DOS program in 1980s? I can read books printed in the 18th century with no difficulties.
09:40:24 <Philippa> sure. Pulp novels, OTOH, decay faster
09:40:51 <w-ber> Are you talking about the information or the media (bad paper)?
09:40:54 <Philippa> the media
09:41:28 <Philippa> as for the data: no, because I don't have any where I cared
09:41:39 <Philippa> if I *did* care, OTOH...
09:41:44 <w-ber> As I said, let's not talk just about you... :)
09:41:54 <Philippa> ...well, let's just say I have no problem playing back old tracker formats
09:42:10 <Philippa> right, so we're back to people who *did* care, and *did* document what format their data was in
09:42:19 <w-ber> If archeologists were to dig our (where our means our civilization) remains in 500 years, do you think they were able to find anything else but a hole in history since 1950s?
09:42:53 <Philippa> yes, although nowhere near all they'd want. But if they're having to dig to get it, there's your problem
09:43:06 <fasta> Is there some easy way to see how Debian builds GHC6 without downloading the complete source?
09:43:07 <Philippa> we *can't fit* all the data in a sufficiently durable medium
09:43:17 <w-ber> It's naive to assume any civilization will *inevitably* last that long.
09:43:40 <Philippa> it's also naive to assume that's the only means by which information can be carried
09:45:06 <Philippa> the books always mattered for archival purposes, but it's not from books alone that we still have latin speakers
09:45:39 <shapr> w-ber: What about microfiche?
09:45:57 <w-ber> There's loads of information that was collected from paper documents that were never intended to be preserved for future. You can't do that with digital media (at least, not as easily or obviously).
09:46:16 <w-ber> Another issue is encryption and DRM.
09:46:30 <Philippa> yes, DRM's a far more immediate problem
09:46:37 <w-ber> shapr: I know nothing about it. :)
09:47:04 <Philippa> I don't see that we owe it to those 500 years in the future to cripple our civilisation now, but I don't see we owe it to publishers either
09:49:16 <w-ber> By the way, I have CD-R disks from late 1990s that have gone partially bad already; rotten bits, read errors, etc. I also have magazines from 1980s that are still in excellent condition and will remain so for 50 or 100 years.
09:49:29 <Philippa> wow, I never knew CD-Rs decayed, I'm shocked!
09:49:31 <w-ber> No, I haven't mistreated the CD-R disks or scratched them or stored in sunlight...
09:50:29 <Philippa> anyone know how flash memory does if it's not used?
09:50:35 <emu> i really don't mind if britney spears latest crap doesn't get preserved for posterity due to DRM
09:50:49 <emu> in fact, we should wholeheartedly support DRM for that reason alone
09:50:55 <w-ber> :)
09:50:59 <cjeris> emu: but Jane Future Anthropologist certainly will!
09:51:11 <cjeris> trying to understand this bizarre collective madness of almost everyone
09:51:15 <w-ber> Philippa: My point is not that all data should be stored; it's that with the way modern civilization is going, no data will ultimately last in future.
09:51:31 <w-ber> Philippa: I think this is in stark contrast with, for example, manuscripts from the Dark Ages.
09:51:36 <Philippa> I think your point's rather more specific than "ultimately"...
09:52:07 <Philippa> sure. We have far more transient info to deal with, too
09:52:42 <w-ber> Assyrian clay tablets are durable, by the way. We should store all our data as burned clay tablets. :)
09:52:48 <Philippa> you might want to wait and see quite where the technology goes in the next 10-20 years
09:53:05 <Philippa> funnily enough, I'm pretty sure I've seen a miniaturised equivalent proposed
09:53:07 <emu> fasta: the debian .diff contains the debian/ scripts
09:53:19 <Philippa> durability and miniaturisation tend not to go well together though
09:53:21 <w-ber> Philippa: That's part of the problem. Haven't we waited since the middle of last century?
09:54:13 <Philippa> in which we've seen one new technology arise and lots and lots of magnetic stuff
09:54:15 <w-ber> There's that one project where they intend to carve information with a laser on some spesific metal alloy.
09:54:19 <fasta> emu: what file exactly?
09:54:27 <fasta> emu: http://ftp.debian.org/debian/pool/main/g/ghc6/ghc6_6.6-3.diff.gz <- partial
09:54:29 <lambdabot> http://tinyurl.com/yhu99m
09:55:00 <Philippa> you're welcome to punchcards if you want 'em though
09:55:03 <ventonegro> @paste
09:55:03 <lambdabot> http://paste.lisp.org/new/haskell
09:55:12 <emu> fasta: all changes made to the original source to package it for debian are contained in that .diff.gz
09:55:28 <fasta> emu: how nice, thanks
09:55:53 <w-ber> http://en.wikipedia.org/wiki/Rosetta_Project
09:56:09 <lisppaste2> ventonegro pasted "non-exhaustive patterns" at http://paste.lisp.org/display/31134
09:56:22 <ventonegro> could anyone please look at my paste
09:56:42 <ventonegro> and tell me why the comented version gives me "non-exhaustive patterns"
09:57:10 <sjanssen> @seen dons -- still awake?
09:57:10 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 18m 31s ago.
09:57:19 <sjanssen> @localtime dons
09:57:21 <lambdabot> Local time for dons is Sat Dec  2 04:52:40 2006
09:57:28 <w-ber> sjanssen: He went to bed more than an hour ago.
09:57:39 <sjanssen> w-ber: okay, thanks
09:57:48 <Cale> ventonegro: well, lexString is only being defined for strings beginning with a doublequote
09:58:10 <ventonegro> Cale, but it is so in both cases, no?
09:58:18 <Cale> yes
09:58:23 <Cale> hmm
09:58:28 <Cale> wrap = drop 1
09:58:39 <ventonegro> > drop []
09:58:39 <lambdabot>  Couldn't match `Int' against `[a]'
09:58:47 <ventonegro> > drop 1 []
09:58:48 <lambdabot>  Add a type signature
09:58:51 <ventonegro> > drop 1 [] :: Int
09:58:52 <lambdabot>  Couldn't match `Int' against `[a]'
09:58:53 <Cale> > drop 1 [] :: String
09:58:54 <lambdabot>  ""
09:58:59 <ventonegro> heh
09:59:26 <Cale> so the difference is that you're dropping an extra character
09:59:33 <chessguy> @paste
09:59:34 <lambdabot> http://paste.lisp.org/new/haskell
09:59:40 <Cale> maybe lexer assumes some things?
10:00:08 <ventonegro> Cale, hmm, dunno
10:00:14 <Squall`> I honestly, swear to God, think my sexual appeal has increased 5-fold since I started learning Haskell.
10:00:27 <lisppaste2> chessguy pasted "Looking for efficiency hacks" at http://paste.lisp.org/display/31135
10:00:38 <fasta> Squall`: You just want to be on the quotes page..
10:00:42 <ventonegro> Squall`, among which animals?
10:00:49 <chessguy> hi guys. i'm looking to figure out how to streamline this code as much as possible
10:00:52 <Squall`> Every kind!
10:00:53 <w-ber> Squall`: Among female programmers?
10:00:56 <fasta> ventonegro: ^^
10:00:57 <Squall`> Males and Females!
10:01:06 <chessguy> right now it's getting pretty bogged down when i get up to about f 20
10:01:43 <ventonegro> Cale, is there a way to make ghc tell me more about the problematic patterns?
10:02:34 <chessguy> oh, and you can ignore the first two functions there
10:02:36 <ventonegro> not using a Writer monad :-)
10:03:03 <Cale> ventonegro: you could compile the code with -prof -auto-all, and then run your program with the command line option +RTS -xc
10:03:26 <Cale> ventonegro: then it should give a cost-centre trace when it crashes.
10:03:32 <ventonegro> Cale, ok, i'll see the ghc manual for more info
10:03:36 <ventonegro> Cale, thank you
10:03:50 <Cale> But another idea is to use the Either type to report errors explicitly
10:04:54 <Cale> i.e. Left "Such and such error occurred!"
10:05:47 <chessguy> @type Left
10:05:49 <lambdabot> forall b a. a -> Either a b
10:06:56 <w-ber> Can I manipulate individual bits of data in Haskell?
10:07:10 <chessguy> @hoogle Data.Bits
10:07:11 <lambdabot> No matches, try a more general search
10:07:17 <chessguy> @hoogle Bits
10:07:18 <lambdabot> Data.Bits :: module
10:07:18 <lambdabot> Data.Bits.Bits :: class Num a => Bits a
10:07:18 <lambdabot> Data.Bits.bitSize :: Bits a => a -> Int
10:07:19 <w-ber> More importantly, is it efficient (enough)?
10:08:38 <ventonegro> Cale, but i don't know where to put it *red face*
10:09:14 <Cale> What's the exact error message that you're getting?
10:09:25 <ventonegro> Main: Lexer.hs:(32,0)-(59,39): Non-exhaustive patterns in function lexer
10:09:39 <ventonegro> GHC reports the error in the lexer function
10:10:01 <ventonegro> but if i change the *lexString* error, the error goes away
10:10:08 <ventonegro> s/error/function/
10:12:49 <Cale> ventonegro: well, yes, but you're changing it so that what's passed to lexer is different
10:13:34 <Cale> Try this... go to the definition of lexer and write a generic failure case for it
10:13:38 <Cale> something like
10:14:17 <ventonegro> Cale, ok, let me see, in the first case i pass '"  this is the rest'
10:14:19 <Cale> lexer xs = error $ "I don't know how to lex this: " ++ xs
10:14:27 <ventonegro> in the second i pass ' this is the rest'
10:14:31 <Cale> after all the other cases
10:14:42 <Cale> hmm
10:15:08 <SyntaxNinja> so much spam
10:15:09 <Cale> paste the code for lexer
10:15:16 <Cale> SyntaxNinja: spam?
10:15:38 <SyntaxNinja> Cale: yesl
10:16:22 <lisppaste2> ventonegro pasted "My DTD lexer" at http://paste.lisp.org/display/31138
10:16:36 <ventonegro> beware: newbie ugly code
10:17:07 <ventonegro> although a lot is from happy docs
10:17:37 <Cale> ventonegro: hmm, okay
10:18:02 <Cale> ventonegro: so supposing that the string starts with a space, the s@(c:cs) should be the first thing to match
10:18:11 <Cale> and isSpace c will be true
10:18:21 <Cale> so it should call lexer cs
10:18:37 <Cale> and so it really should not matter how many spaces are on the front of the string
10:19:27 <Cale> oh, I see
10:19:39 <Cale> why are you dropping the first character of the string?
10:20:00 <vegai> http://www.willamette.edu/~fruehr/haskell/seuss.html
10:20:02 <lambdabot> Title: Dr. Seuss on Parser Monads, http://tinyurl.com/y45hp4
10:20:06 <ventonegro> because i don't want the quotes
10:20:38 <Cale> but cs doesn't have a " at the start unless the string starts with ""
10:21:02 <Cale> (lexString is matching ('"':cs)
10:21:03 <Cale> )
10:21:12 <Cale> So cs is the part after the first "
10:21:34 <ventonegro> yep, so the string "hello world" is ('"', "hello world\"")
10:21:57 <ventonegro> i want just hello world, unquoted
10:22:05 <Cale> hmm
10:22:11 <ventonegro> cs = "hello world\""
10:22:33 <Cale> ah, then you'd get
10:22:41 <Cale> str = hello world
10:22:46 <Cale> rest = "\""
10:22:53 <ventonegro> no, sorry
10:22:59 <Cale> and perhaps you'd rather not have that \"
10:23:07 <ventonegro> i'm mistaken :-)
10:23:14 <Cale> er
10:23:20 <Cale> str = "hello world"
10:23:22 <Cale> of course
10:23:31 <ventonegro> span ((/=) '"') will give me the unquoted string
10:23:38 <ventonegro> the problem is the rest
10:24:05 <ventonegro> in version="1.0" encoding="utf-8"
10:24:14 <Cale> yeah, okay, I see how that works
10:24:30 <ventonegro> after reading "1.0", the remaining string will be " encoding="utf-8"
10:24:39 <ventonegro> i need to get rid of the quote :-)
10:25:24 <Cale> okay
10:26:37 <Syzygy-> > span ((/=) '"') "Blahblah\"blah\"blahblahblah\"blah\""
10:26:38 <lambdabot>  ("Blahblah","\"blah\"blahblahblah\"blah\"")
10:26:40 <Cale> *Lexer> lexer "version=\"1.0\" encoding=\"utf-8\""
10:26:40 <Cale> [TokenName "version",TokenEq,TokenString "1.0",TokenName "encoding",TokenEq,TokenString "utf-8"]
10:26:46 <Cale> that's with your current version
10:26:49 <Cale> it seems fine
10:27:03 <Cale> (that is, with the drop 1)
10:27:10 <ventonegro> how does your run? mine says "non-exhaustive...
10:27:33 <Cale> are you sure that you have the latest copy of the file loaded?
10:27:35 <ventonegro> i've changed to drop too
10:27:45 <Cale> type :r in ghci
10:27:56 <Cale> after making sure you've saved the file
10:27:59 <ventonegro> i'm using ghc --make
10:28:04 <fasta> How do I compile this example? http://web.mit.edu/ghc/www/users_guide/sec-ffi-ghc.html
10:28:06 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/y3qskq
10:28:08 <ventonegro> yes, i've typed :w :-)
10:28:15 <fasta> The example is wrong, also, btw
10:28:25 <fasta> It uses a lower case foo_stub.h
10:28:28 <Syzygy-> ventonegro: What does :w do?
10:28:39 <fasta> While Foo_stub.h is generated.
10:28:42 <ventonegro> Syzygy-, writes a file in vi
10:28:50 <Syzygy-> Oh, vi.
10:29:01 <Syzygy-> I thought it was in ghc. *.*
10:29:13 <ventonegro> Syzygy-, :-)
10:29:25 <ventonegro> Cale, The Glorious Glasgow Haskell Compilation System, version 6.6
10:30:04 <Cale> well, that code works for me in GHC 6.4.2 and 6.7
10:30:21 <Lemmih> fasta: ghc --make -fffi?
10:30:24 <Cale> (specifically 6.7.20061115)
10:30:31 <ventonegro> weird
10:30:48 <Cale> ventonegro: try it in ghci
10:31:00 <Cale> maybe you're not passing lexer the string that you think you are?
10:31:07 <fasta> Lemmih: To create something with a C main?
10:31:43 <Cale> anyway, I'll be back, I'm just going to have a shower
10:31:48 <Lemmih> fasta: yeah.
10:31:58 <ventonegro> Cale, ghci outputted something
10:32:15 <ventonegro> the problem is not with the strings *grin*
10:32:21 <ventonegro> it's further in the file
10:32:25 <fasta> Lemmih: how do I tell ghc that it should use foo.c?
10:32:36 <ventonegro> but the compiled program won't output anything at all
10:33:06 <Lemmih> fasta: Just compile and link against it.
10:33:27 <fasta> Lemmih: compile with what compiler?
10:34:05 <Lemmih> fasta: GHC.
10:34:31 <Saizan> ghc compiles c?
10:34:39 <Lemmih> Saizan: Yep.
10:34:45 <Lemmih> (by calling gcc)
10:35:06 <Saizan> (that's cheating :D)
10:35:39 <fasta> Lemmih: ok, that works, although I don't see a result file.
10:36:17 <Lemmih> fasta: After what? Compiling foo.c or linking your application?
10:36:34 <fasta> Lemmih: ghc --make -fffi foo.c Foo.hs
10:36:43 <tom__> hi i dont have a haskell compiler but does function (a) = a equals function a = a ?
10:37:37 <Lemmih> tom__: Yes.
10:37:48 <tom__> good good
10:38:00 <tom__> then my stupid haskell generator almost works
10:38:59 <Lemmih> fasta: Hm, try without --make or with -o a.out.
10:39:57 <fasta> Warning: output was redirected with -o, but no output will be generated
10:39:58 <fasta> because there is no Main module.
10:40:20 <fasta> Lemmih: it appears that ghc doesn't support C main functions.
10:40:34 <fasta> (at least not in this way)
10:41:05 <Lemmih> And without --make?
10:41:20 <fasta> foo.o: In function `main':
10:41:21 <fasta> foo.c:(.text+0x3a): undefined reference to `foo'
10:41:21 <fasta> collect2: ld gaf exit-status 1 terug
10:41:39 <fasta> gaf ... terug means returned
10:42:18 <Lemmih> Hm, try 'ghc Foo.o foo.o'
10:43:22 <w-ber> Localized gcc. Lovely.
10:43:23 <fasta> Same result
10:43:36 <fasta> w-ber: yes, I also have localized manpages.
10:43:46 <fasta> w-ber: (some of them are)
10:44:08 <mauke> that can be fixed with environment variables :-)
10:44:22 <w-ber> I translated some 20% of GCC error and warning messages to Finnish before I gave up.
10:44:30 <fasta> LANG=C command
10:44:32 <fasta> I know
10:44:42 <Lemmih> fasta: Can you paste the contents of foo.c and Foo.hs?
10:44:50 <w-ber> ?paste
10:44:50 <lambdabot> http://paste.lisp.org/new/haskell
10:45:03 <fasta> Lemmih: yes, but this is coming straight from the docs
10:45:11 <fasta> Lemmih: except for that typo in the docs
10:45:49 <lisppaste2> fasta pasted "FFI - c file" at http://paste.lisp.org/display/31141
10:46:24 <lisppaste2> fasta pasted "FFI - Haskell file" at http://paste.lisp.org/display/31142
10:49:38 <Lemmih> fasta: Hm, there's actually a bug in --make /-:
10:49:54 <Lemmih> fasta: 'ghc -fffi Foo.hs mymain.c -o prog' works.
10:51:04 <fasta> Lemmih: not in my version
10:51:24 <fasta> Lemmih: I am using a version from darcs from a few months old, though.
10:51:41 <fasta> ghc -fffi Foo.hs foo.c -o prog
10:51:42 <fasta> compilation IS NOT required
10:51:42 <fasta> foo.o: In function `main':
10:51:42 <fasta> foo.c:(.text+0x3a): undefined reference to `foo'
10:51:42 <fasta> collect2: ld gaf exit-status 1 terug
10:52:51 <Lemmih> fasta: Right, compiling Foo_stub.c manually or using --make fixes that.
10:53:20 <fasta> Lemmih: ? You just said there was a bug in --make.
10:53:48 <Lemmih> 'ghc --make -fffi Foo.hs foo.c' is OK. 'ghc --make -fffi Foo.hs foo.c -o prog' is not.
10:54:13 <Lemmih> Whoa, this is quite obscure.
10:54:21 <fasta> It is
10:54:58 <fasta> Lemmih: what exactly should that "OK" command do?>
10:55:18 <Lemmih> fasta: It should create a binary called 'a.out'.
10:55:22 <fasta> Lemmih: Since it doesn't create a file .
10:55:34 <fasta> Lemmih: we already established that earlier
10:55:52 <fasta> Lemmih: it doesn't create a file, but doesn't mention that.
10:56:16 <fasta> Lemmih: It should say:"Not creating output because there's no Main module, or something like that.
10:56:29 <fasta> Lemmih: "
10:56:37 <w-ber> Isn't FFI experimental anyway? So it's small wonder there are bugs. :)
10:56:46 <fasta> Lemmih: well, of course it should "Just Work"....
10:56:57 <fasta> I think I am the first user...
10:57:24 <fasta> Is there any open platform that does have FFI/profiler/sane module system?
10:57:48 <fasta> I thought Haskell was it, but apparently it doesn't work. :(
10:57:51 <sjanssen> w-ber: I would not call FFI experimental
10:58:06 <sjanssen> fasta: Haskell has these things
10:58:11 <fasta> sjanssen: it shouldn't be
10:58:22 <Lemmih> fasta: Hm right. Compiling Foo_stub.c manually seems to be the solution.
10:58:36 <fasta> Lemmih: How? With gcc?
10:58:44 <Lemmih> fasta: With ghc.
10:59:22 <fasta> Lemmih: Can you post the command you used?
10:59:28 <Lemmih> ghc -c Foo_stub.c
10:59:46 <fasta> Lemmih: the -c is the same option as the gcc -c option?
11:00:09 <Lemmih> 'ghc -fffi Foo.hs mymain.c Foo_stub.c -o prog', I mean.
11:01:02 <fasta> Lemmih: indeed that works
11:01:22 <w-ber> sjanssen: It isn't? Hm, I must have read some old document.
11:02:03 <fasta> Lemmih: the rest of the FFI does work (meaning that you have seen non-trivial programs working with it)?
11:02:40 <Lemmih> fasta: The rest of the FFI is excellent.
11:03:11 <fasta> Lemmih: so, I can store Haskell functions even in C data structures?
11:03:29 <Lemmih> fasta: Yes.
11:03:32 <fasta> Lemmih: not that I want that in particular, but just as an example.
11:03:36 <fasta> Lemmih: fantastic
11:03:43 * fasta is pleased
11:03:54 <fasta> Lemmih: how does it work with the profiler?
11:04:24 <fasta> Lemmih: I assume it shows up as a black hole and that the C code does not get instrumented.
11:04:32 <Lemmih> fasta: I haven't experienced any problems with it.
11:05:40 <Lemmih> You assume correctly, afaik.
11:08:29 <w-ber> @type read . show
11:08:30 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
11:14:54 <Nafai> Is hIDE being worked on at all?  I can't tell from the wiki page
11:17:15 <arjanb> afaik that project is dormant
11:18:12 <fasta> At every point in time there is a non-zero probability of some continuing it :)
11:18:27 <fasta> someone*
11:18:53 <Nafai> Figures :)
11:19:24 <Saizan> ?wiki hIDE
11:19:25 <lambdabot> http://www.haskell.org/haskellwiki/hIDE
11:19:46 <retybok> is there a way to get all lines of a file as a list of strings? (like python's readlines for example)
11:20:12 <Cale> @type fmap lines . readFile
11:20:14 <lambdabot> FilePath -> IO [String]
11:20:34 <retybok> Cale: thanks
11:20:41 <Cale> no problem
11:21:23 <retybok> how about stdin?
11:23:33 <blue_tigers> >  dropWhile' p = fold f v
11:23:34 <lambdabot>  Parse error
11:23:34 <blue_tigers>   where
11:23:36 <blue_tigers>     f x (ys, xs) = (if p x then ys else x : xs, x : xs)
11:23:37 <blue_tigers>     v            = ([], [])
11:23:43 <Cale> retybok: getContents
11:23:53 <retybok> thx
11:23:58 <Cale> @type fmap lines . getContents
11:23:59 <lambdabot>   Expecting a function type, but found `IO String'
11:24:00 <lambdabot>    Expected type: a -> f String
11:24:02 <Cale> er
11:24:04 <Cale> @type fmap lines getContents
11:24:06 <lambdabot> IO [String]
11:24:45 <blue_tigers> > dropWhile p = fold f v where f x (ys, xs) = (if p x then ys else x : xs, x : xs) v = ([], [])
11:24:45 <lambdabot>  Parse error
11:25:12 <sjanssen> blue_tigers: the input must be an expression
11:25:32 <sjanssen> blue_tigers: also, foldr, not fold
11:25:48 <blue_tigers> thx. i'm a total newbie :)
11:26:19 <sjanssen> @let dropWhile' p = fold f v where f x (ys, xs) = (if p x then ys else x : xs, x : xs) v = ([], []) -- there is this command also
11:26:19 <lambdabot>  Parse error
11:26:32 <blue_tigers> too lazy to install my own haskell environment
11:26:50 <blue_tigers> @let dropWhile' p = fold f v where f x (ys, xs) = (if p x then ys else x : xs, x : xs) v = ([], [])
11:26:51 <lambdabot>  Parse error
11:27:20 <sjanssen> blue_tigers: parens around (x : xs ..
11:27:25 <blue_tigers> but probably i should do itm, as the error messages are less than helpful
11:27:38 <sjanssen> blue_tigers: also, lambdabot responds to personal messages
11:37:06 <ptolomy> Sorry, this may be a bit OT, but if I'm planning on building a high-speed publisher-subscriber network database, what CS field would that sort of engineering fall into? Distributed systems? (I need to buiy me some books, interesting project in the queue)
11:37:27 <Syzygy-> Looking at the Parsec documentation, trying out the examples. It has a "matching parens" parser definde as parens = do char '('; parens; char ')'; parens; <|> return ()
11:37:51 <fasta> What is a publisher-subscriber network database?
11:37:52 <Syzygy-> This doesn't quite work for me: ")(" parses OK with this.
11:38:11 <Syzygy-> Ah!
11:38:16 <ptolomy> Syzygy-: Is your nick in any way related to the distributed realtime VR rendering system of the sdame name?
11:38:22 <Syzygy-> It returns () whenever it doesn't start parsing.
11:38:27 <Syzygy-> ptolomy: In no way.
11:39:06 <ptolomy> fasta: Database keeps track of a bunch of objects, clients can asyncronously publish things to tables with a unique id, and subscribe to updates on objects/tables.
11:39:24 <fasta> Covered by this? (didn't read it) http://www.freepatentsonline.com/5873084.html
11:39:26 <lambdabot> Title: Database network connectivity product - Patent 5873084
11:40:23 <fasta> Ridiculous that that can be patented...
11:40:46 <ptolomy> fasta: Similar, but it would be maintaining the "events" in a database and only publishing diffs to keep it snappy.
11:41:14 <sjanssen> @let dropWhile' p0 xs0 = foldr (\x xs p -> if p x then x : xs p else xs (const True)) (const []) xs0 $ p0 -- this version actually works, blue_tigers
11:41:16 <lambdabot> Defined.
11:41:44 <sjanssen> @check (\p xs -> dropWhile p xs == dropWhile' p xs) :: (Int -> Bool) -> [Int] -> Bool
11:41:46 <lambdabot>  Not in scope: `dropWhile''
11:45:09 <fasta> ptolomy: Database theory + distributed objects, I'd say.
11:45:31 <fasta> ptolomy: some networking books, since you are going practical.
11:50:50 <Saizan> is there a haskell link for Qt?
12:10:09 <metaperl> bottom up design is not preferable for me... you cant know what bottom up pieces to build unless you have a clear top down description of the problem solution.
12:21:37 <Ugarte> metaperl: It depends on the problem. Sometimes, the issues and constraints placed on the lower-level designs aren't clear until one begins to implement them.
12:22:09 <metaperl> hmm
12:22:12 <Ugarte> For instance, it may not be readily apparent that some other values might need to be passed into functions aside from the obvious ones the function works on, if it is not readily apparent in a high level design what state must be maintained.
12:22:16 <Ugarte> Just as an offhand example.
12:22:36 <Ugarte> I often find myself rearchitecting functions (in fairly small ways) as I discover I didn't really think them through properly, and didn't account for all their requirements, etc.
12:22:56 <Ugarte> A really obvious example: I often don't put the arguments in an order that is conducive to the type of currying I later want to do.
12:23:01 <metaperl> yeah...
12:23:04 <metaperl> I know about that
12:23:07 <Ugarte> Reordering arguments is trivial, but it's still an example of something I didn't think of.
12:23:25 <metaperl> Ugarte - what is your primary use of Haskell?
12:23:52 <Ugarte> Actually, I am using F# at the moment.
12:24:09 <metaperl> oh, is that ML-inspired?
12:24:10 <Ugarte> F# and C#, primarily.
12:24:11 <Ugarte> Yes.
12:24:17 <Ugarte> F# is largely OCaml-compatible.
12:24:29 <Ugarte> But runs on the .NET CLR.
12:24:31 <metaperl> wow. didn't know anyone was seriously using that
12:24:40 <Ugarte> *shrug*
12:24:55 <Ugarte> I am actively developing one project that relies on it, maintaining another, and prototyping a third in it.
12:25:05 <metaperl> do you work at Jane Street?
12:25:10 <Ugarte> The third I'll probably be required to rewrite in C# before it ships, becuase my boss is unconvinced as to the utility of writing it in F#.
12:25:15 <Ugarte> No, I don't. I nearly did ;)
12:25:32 <Ugarte> Wow. Everyone here knows about Jane St, etc?
12:25:55 <w-ber> I don't...
12:26:02 <Saizan> neither me
12:26:03 <Ugarte> F# is very useful because of the .NET compatibility.
12:26:13 <metaperl> well, in my email, their Google ads are always in the corner. They had a talk on haskell in commercial apps
12:26:23 <metaperl> I bet teh .NET compatibility r0x
12:26:28 <metaperl> a very useful thing to have
12:26:32 <Ugarte> w-ber, Saizan: They're a small hedge fund in NYC that use OCaml exclusively for their trading systems.
12:26:55 <metaperl> is F# blindingly fast like OCaml?
12:27:06 <Ugarte> Not quite.
12:27:17 <Ugarte> The performance is a bit worse than, say, C#, I believe.
12:27:23 <metaperl> oh my
12:27:31 <Ugarte> Perfectly good for most uses, but not as fast as compiled OCaml.
12:27:34 <metaperl> OCaml was da shiznit for speed...
12:27:45 <erider> Ugarte: is it faster than java?
12:27:50 <Ugarte> Well, literally everything I write runs on the CLR.
12:28:08 <glguy> so you don't write any Haskell?
12:28:10 <Ugarte> erider: The CLR vs. Java? I don't really know. They're roughly comparable in that they're both statically typed bytecode-interpreted languages.
12:28:13 <Ugarte> glguy: Not at the moment.
12:28:22 <Ugarte> glguy: There is Mondrian, but it looked dead last I checked.
12:29:01 <glguy> Ah, I just started reading the channel again
12:29:42 <Ugarte> I wonder if delegates have a performance hit. Isnt' runtime polymorphism a bit slower?
12:29:51 <Ugarte> Er, not delegates./
12:29:52 <Ugarte> Generics.
12:31:05 <glguy> I would imagine that if any speed difference using C#'s generics introduced mattered to someone, that they really shouldn't be using C#
12:31:15 <Ugarte> Probably true.
12:31:37 <metaperl> Mondrian is an overused word - http://programming.reddit.com/info/t90e/comments
12:31:39 <Ugarte> Well, I think people using .NET for server stuff MIGHT care about speed more, but this is a problem you can always throw clustering at.
12:31:40 <lambdabot> Title: Guido van Rossum unveiled his first Google project, Mondrian: web-based code rev ..., http://tinyurl.com/y23pn2
12:31:54 <kalven> Ugarte: type-specific code is generated at runtime.
12:32:01 <kalven> Ugarte: http://www.artima.com/intv/generics2.html
12:32:03 <lambdabot> Title: Generics in C#, Java, and C++
12:32:07 <Ugarte> kalven: Right, at runtime, which I'd assume has a performance hit?
12:32:17 <Ugarte> I don't really know much about generics.
12:32:33 * w-ber feels enlightened for understanding the difference between $ and $!
12:33:06 <metaperl> @type ($!)
12:33:07 <lambdabot> forall b a. (a -> b) -> a -> b
12:33:14 <metaperl> @type ($)
12:33:16 <lambdabot> forall b a. (a -> b) -> a -> b
12:33:19 <kalven> Ugarte: Well, a hit like any other you'd get when a JIT is involved. The important thing is that it actually generates type specific code. (As opposed to generics in java, for example).
12:33:21 <Ugarte> Oh, I forgot that Java got generics, too.
12:33:28 <Ugarte> Yeah.
12:33:32 <Ugarte> Wasn't that new in 1.5?
12:33:33 <glguy> Java's generics compile away
12:33:37 <xerox> ?docs Control.Parallel.Strategies -- ?
12:33:38 <lambdabot> Control.Parallel.Strategies -- ? not available
12:33:41 <w-ber> Ugarte: Yes.
12:33:42 <xerox> ?docs Control.Parallel.Strategies.
12:33:42 <lambdabot> Control.Parallel.Strategies. not available
12:33:44 <xerox> hmpf.
12:33:49 <w-ber> Generics in Java is more like syntactic sugar.
12:34:05 <Ugarte> They compile away? So like C++ templates?
12:34:08 <Ugarte> Let me keep reading... ;)
12:34:48 <glguy> Ugarte: no, like they are just there for the programmer's benefit
12:34:55 <glguy> Ugarte: they don't exist in the compiled result
12:35:17 <Ugarte> Oh, yea, this makes sense.
12:35:23 <glguy> Java treats the resulting code the same as an untyped collection
12:35:29 <glguy> with all of the boxing and unboxing
12:35:40 <Ugarte> Right.
12:35:51 <glguy> for backwards compatibility :(
12:36:17 <glguy> Nothing like a little backwards compatibility to make your platform good at one thing... being backwards compatible :)
12:37:13 <Ugarte> I'll say.
12:40:43 <glguy> Speaking of F#
12:40:43 <glguy> http://www.ffconsultancy.com/dotnet/fsharp/raytracer/index.html
12:40:46 <lambdabot> Title: Flying Frog Consultancy Limited: Ray tracer, http://tinyurl.com/ycorbd
12:42:22 <chessguy> what's F#?
12:42:41 <Saizan> [212958] <glguy> Ugarte: they don't exist in the compiled result <-- reading Ugarte's link they don't simply fade in nothing, basically they insert automatic downcasts in bytecode
12:43:23 <Saizan> s/insert automatic/automatically insert/
12:43:38 <w-ber> Automatically insert automatic inserts. :)
12:43:40 <glguy> that was probably just the wrong way to express that they are not an improvement over the old collection style
12:44:18 <glguy> I should have said that any benefits disappear after compiling
12:44:38 <cjeris> glguy: are they ever going to release and officially support f# so those of us stuck on windows can use at least half a brain?
12:45:03 <glguy> I haven't decided yet
12:45:07 <Ugarte> Saizan: Right, which is pretty silly.
12:45:25 <Ugarte> cjeris: F# is released in the sense that the code is open and free for use.
12:45:30 <Ugarte> With some restrictions.
12:45:44 <Ugarte> There is no support, but Don Syme is publishing a book from APress called Expert F#.
12:46:04 <Baughn> Which makes most sense: Cross-compiling Haskell to 32-bit FreeBSD from 64-bit Linux, or installing freebsd under Xen for the purpose?
12:47:23 <Saizan> Ugarte: uhm until now I was thinking that downcasts were a keep-happy-static-checker thing, can you explain me why the VM needs them?
12:48:09 <Ugarte> Saizan: Because the user's code ultimately expects back something of the same type as put into it.
12:48:39 <Ugarte> So by having the compiler automatically insert upcasts to  Object and downcasts to whatever, you keep all the access to the supposedly-generic collection typesafe.
12:48:47 <Ugarte> I think.
12:49:24 <Ugarte> This is the first I've heard of this. I new Java had generics in 1.5, but didn't know anything about them.
12:49:26 <glguy> it has to do with boxing and unboxing
12:49:33 <Saizan> Ugarte: so when they teach me that at there are no types at runtime, they are wrong?
12:49:36 <glguy> wrapping the data-type
12:50:01 <Ugarte> Saizan: In what context did they teach you this? Java bytecode has types.
12:50:19 <glguy> Saizan: The Java VM "runtime" is different than native execution run-time
12:50:38 <Saizan> my Code desing class, where they emphasize Java and OO
12:51:01 <Saizan> *software design
12:51:07 <Ugarte> Well, like glguy said, native binary code has no types, but Java bytecode does.
12:51:22 <Saizan> well however i have to go, thanks for the explanations
12:51:48 <Ugarte> Yep. Cheers.
12:52:00 <glguy> ?yow
12:52:01 <lambdabot> I didn't order any WOO-WOO ... Maybe a YUBBA ... But no WOO-WOO!
12:52:04 <Saizan> bye
12:52:22 <w-ber> Did you know that rotten uncooked potato smells like fish?
12:52:27 <w-ber> Maybe the farmer has used fish as fertilizer.
12:53:47 <astrolabe> ew
12:54:19 <Ugarte> Goddamn. Iv'e been struggling with this recursive algorithm for like a day.
12:55:08 <Cale> Ugarte: what does it do?
12:55:40 <Ugarte> I can't tell you that.
12:55:42 <Ugarte> Unfortuntqaely.
12:55:49 <w-ber> I bet it recurses!
12:55:53 <alec> I was going to go with "not what it's suppose to"
12:55:57 <Ugarte> Yes, well, it doesn't YET recurse.
12:56:02 <Ugarte> That's part of the problem.
12:56:03 <Ugarte> ;)
12:57:19 <Cale> You can't tell me what it does, or what it's supposed to do?
13:04:41 <glguy> lol
13:06:54 <dino-> He could tell you, but then he would have to evaluate: error "I must kill you"
13:09:57 <sjanssen> Ugarte's statement gave me a flashback to good old Star Trek: Voyager
13:10:22 <sjanssen> they liked to say "recursive Borg algorithm" in that show, about once per episode, I think
13:10:44 <glguy> What could be more scary?
13:11:09 <EvilRanter> an iterative borg algorithm?
13:11:32 <sjanssen> I would imagine the Borg are imperative
13:11:32 <dylan> the borg were clearly functional, not imperative.
13:11:46 <sjanssen> assimilation smacks of destructive assignment to me
13:12:31 <glguy> Variables not being allowed to change doesn't sound too accepting to me ;)
13:13:15 <EvilRanter> what about repressing fns, and not allowing them to be first-class values?
13:13:36 <EvilRanter> anyhow.
13:14:57 <lispy> fns?
13:16:39 <glguy> functions
13:18:59 <lispy> ah
13:19:30 <dylan> I read that as "fins"
13:19:35 <dylan> as in, finish people.
13:21:39 <rahikkala> We're too cool to be repressed, even by the Borg
13:26:51 <glguy> Hmm, you speak of all Fins as one person
13:26:59 <glguy> maybe you have already been repressed
13:27:01 <glguy> by the borg?
13:27:24 <mahogny> rahikkala, the swedes are infiltrating you!
13:29:31 <rahikkala> mahogny: Unlikely, considering we're infiltrating the rest of the world. See http://apolyton.net/forums/showthread.php?s=&threadid=42100
13:29:35 <lambdabot> http://tinyurl.com/yfm4jr
13:29:50 <mahogny> baah
13:30:02 <mahogny> lol
13:30:09 <nomeata> @type join (+)
13:30:11 <lambdabot> forall a. (Num a) => a -> a
13:30:36 <nomeata> why does ghci tell me: join (+) :: (Monad ((->) a), Num a) => a -> a
13:30:56 <glguy> nomeata:  :m +Control.Monad.Reader
13:31:01 <nomeata> thx
13:31:18 <nomeata> (join (+)) :: (Num a) => a -> a
13:31:30 <nomeata> so why does ghci add no "forall a."? does it make a difference?
13:31:43 <glguy> The forall is implicit
13:32:37 <Excedrin> are there any still living distributed haskell projects?
13:34:29 <SamB_XP> it used to add one when you had -fglasgow-exts on, but that gets annoying
13:34:59 <nomeata> @quickcheck \x -> (return 'a') x == const 'a' x
13:35:00 <lambdabot> Unknown command, try @list
13:35:04 <SamB_XP> as demonstrated by lambdabot, actually
13:35:18 <metaperl> how would you check if all elements of a list are equal?
13:35:54 <nomeata> metaperl: an obvious way would be \(h:r) -> all (== h) r
13:36:17 <nomeata> metaperl: allthough that does not work for empty lists (which can be a good thing, depends on what you want to do)
13:36:46 <nomeata> @check \x -> (return 'a') x == const 'a' x
13:36:47 <lambdabot>  Add a type signature
13:36:48 <metaperl> nomeata - i like that def. thanks
13:37:05 <nomeata> @check (\x -> (return 'a') x == const 'a' x) :: Char -> Bool
13:37:06 <lambdabot>  OK, passed 500 tests.
13:37:44 <metaperl> nomeata - you're famous - http://www.livingcosmos.org/Members/sundevil/haskell/faq/how-would-you-check-if-all-elements-of-a-list-are-equal
13:37:47 <lambdabot> Title: how would you check if all elements of a list are equal? &mdash; The Living Cosm ..., http://tinyurl.com/y77423
13:38:05 <nomeata> @pl \(h:r) -> all (== h) r
13:38:06 <lambdabot> ap (all . (==) . head) tail
13:38:13 <metaperl> ick
13:38:31 <metaperl> that's so clean it's dirty
13:38:58 <nomeata> @type ap
13:39:00 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
13:39:19 <astrolabe> So, what is the monad here?
13:39:28 <nomeata> (-> [a])
13:39:31 <glguy> ((->) r)
13:39:46 <glguy> ap f g x = f x (g x)
13:39:50 <nomeata> right, ((->) [a]), the braces are important
13:40:36 <w-ber> rahikkala: Now that was a funny thread.
13:41:24 <cjeris> it would be really neat to have a tool which, given a function composition, drew a commutative diagram with arrows showing each atomic expression and each parenthesized composition appearing in the input expression, labeling each arrow with its most general polymorphic type.
13:41:26 <glguy> ?pl \x -> and (zipWith (==) x (tail x)) -- and . ap (zipWith (==)) tail
13:41:27 <lambdabot> and . ap (zipWith (==)) tail
13:41:33 <nomeata> > let isUrlChar = liftM (||) isAlphaNum (`elem` ":/_~-.") in isUrlChar 'a'
13:41:34 <lambdabot>    Expecting a function type, but found `t_a1U5'
13:41:34 <lambdabot>    Expected type: Char
13:41:34 <lambdabot> ...
13:41:51 <glguy> > (and . ap (zipWith (==)) tail) [1,1,1,1,2,1]
13:41:53 <lambdabot>  False
13:41:54 <glguy> > (and . ap (zipWith (==)) tail) [1,1,1,1,1,1]
13:41:56 <lambdabot>  True
13:42:17 <nomeata> :t liftM (||)
13:42:50 <nomeata> > let isUrlChar = liftM2 (||) isAlphaNum (`elem` ":/_~-.") in isUrlChar 'a'
13:42:52 <lambdabot>  True
13:42:58 <glguy> liftM in ((->) r) is just (.)
13:43:03 <nomeata> @pl let isUrlChar = liftM2 (||) isAlphaNum (`elem` ":/_~-.") in isUrlChar
13:43:04 <lambdabot> liftM2 (||) isAlphaNum (`elem` ":/_~-.")
13:43:25 <cjeris> it could be a lambdabot command for use as a postprocessor to @pl.  if i ever write it, i'll call it @wtf.
13:43:54 <nomeata> @pl let isUrlChar c = isAlphaNum c || c `elem` ":/-~." in isUrlChar
13:43:55 <lambdabot> liftM2 (||) isAlphaNum (`elem` ":/-~.")
13:44:12 <nomeata> cool, I managed to simulat @pl in my head :-)
13:45:05 <astrolabe> It's when you do @yar that you have to worry
13:45:35 <nomeata> @yar is what?
13:45:35 <lambdabot> Gangway!
13:45:57 <astrolabe> heh.  I think it's a pirate or something
13:46:10 <sjanssen> @yarr we be talkin' like pirates!
13:46:10 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
13:46:42 <nomeata> @free [a -> Bool] -> a -> Bool
13:46:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:46:50 <nomeata> @djin [a -> Bool] -> a -> Bool
13:46:51 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
13:46:58 <nomeata> @djinn [a -> Bool] -> a -> Bool
13:46:59 <lambdabot> f _ _ = False
13:47:03 <nomeata> hmpf
13:47:29 <sjanssen> metaperl: are you sun devil?
13:47:46 <metaperl> sjanssen - yes :)
13:48:19 <sjanssen> metaperl: http://www.livingcosmos.org/Members/sundevil/haskell/dont-forget-it/ -- I saw this thread.  Have you seen lambdabot's @undo command?
13:48:22 <lambdabot> Title: Dont forget it &mdash; The Living Cosmos, http://tinyurl.com/y4wnry
13:48:27 <Ugarte> I think the iterative borg algorithm is scarier, since the other one ultimately would have a stack overflow.
13:48:31 * Ugarte is back
13:48:33 <nomeata> @type any .  sequence [isAlphaNum, `elem` ":/.~"}
13:48:35 <lambdabot> parse error on input ``'
13:48:38 <metaperl> sjanssen - no
13:48:43 <nomeata> @type any .  sequence [isAlphaNum, `elem` ":/.~"]
13:48:44 <lambdabot> parse error on input ``'
13:49:00 <sjanssen> Ugarte: I'm sure the Borg brain has tail call optimization
13:49:08 <nomeata> @type any .  sequence [isAlphaNum, (`elem` ":/.~") ]
13:49:10 <lambdabot>   Couldn't match `a -> Bool' against `[a1]'
13:49:10 <lambdabot>    Expected type: a2 -> a -> Bool
13:49:11 <sjanssen> @undo do {a; b}
13:49:11 <lambdabot> a >> b
13:49:23 <metaperl> oh sweet
13:49:24 <xerox> @type sequence [isAlphaNum, (`elem` ":/.~")]
13:49:25 <sjanssen> @undo do {x <-a; b}
13:49:25 <lambdabot> Char -> [Bool]
13:49:26 <lambdabot> a >>= \ x -> b
13:49:37 <nomeata> @type liftM any (sequence [isAlphaNum, (`elem` ":/.~") ])
13:49:39 <lambdabot>   Couldn't match `a -> Bool' against `[a1]'
13:49:39 <lambdabot>    Expected type: m (a -> Bool)
13:49:55 <xerox> @type all . sequence [isAlphaNum, (`elem` ":/.~")]
13:49:56 <lambdabot>   Couldn't match `a -> Bool' against `[a1]'
13:49:56 <lambdabot>    Expected type: a2 -> a -> Bool
13:49:59 <xerox> @type and . sequence [isAlphaNum, (`elem` ":/.~")]
13:50:00 <lambdabot> Char -> Bool
13:50:09 <nomeata> oh, right, and is what I meant
13:50:11 <nomeata> thx
13:50:14 <xerox> :)
13:51:19 <nomeata> so i can “let anyTrue = or.sequence in anyTrue [cond1, cond2, cond3]”
13:51:37 <nomeata> instead of \c -> cond1 c || cond2 c || cond3 c
13:52:00 <norpan> anyTrue is called or
13:52:02 <nomeata> One might argueue that the second is clearer, but the first one is more haskellish
13:52:12 <nomeata> no:
13:52:14 <nomeata> @type or
13:52:16 <lambdabot> [Bool] -> Bool
13:52:25 <nomeata> @type “let anyTrue = or.sequence in anyTrue
13:52:27 <lambdabot> lexical error
13:52:33 <nomeata> @type let anyTrue = or.sequence in anyTrue
13:52:35 <lambdabot>   Couldn't match `Bool' against `[a]'
13:52:37 <lambdabot>    Expected type: [[a]] -> [Bool]
13:52:43 <nomeata> hmpf
13:52:46 <glguy> ?type or . sequence [isAlpha]
13:52:48 <lambdabot> Char -> Bool
13:53:11 <glguy> ?type (or .) . sequence
13:53:13 <lambdabot> forall a. [a -> Bool] -> a -> Bool
13:53:21 <nomeata> that’s the one, thx
13:53:23 <glguy> there we go
13:54:30 <w-ber> ?type sequence
13:54:31 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
13:54:55 <Ugarte> sjanssen: You think? I mean, weren't they always being beaten by, like, changing the frequency of the phasers and shit?
13:55:01 * Ugarte never really watched Star Trek
13:55:04 <nomeata> @typpe liftM or sequence
13:55:06 <lambdabot>   Couldn't match `Bool' against `[a]'
13:55:06 <lambdabot>    Expected type: [[a]] -> [Bool]
13:55:40 <nomeata> isn’t liftM = (.) in the ((->) r) monad?
13:55:41 * SamB thinks they should have just modulated their phasers with heavy metal
13:55:42 <glguy> ?type liftM (liftM or) sequence
13:55:44 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
13:55:47 <nomeata> @typpe (liftM or) . sequence
13:55:49 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
13:56:17 <nomeata> ok. I like when the haskell typesystem turns into a logical puzzle.
13:59:01 <nomeata> @djinn [a -> b] -> a -> b
13:59:01 <lambdabot> -- f cannot be realized.
13:59:27 <dylan> @pl \x -> head (tail x)
13:59:28 <lambdabot> head . tail
13:59:53 <SamB> @djinn [a] -> a
13:59:54 <lambdabot> -- f cannot be realized.
14:00:08 <SamB> @djinn [a] -> Maybe a
14:00:09 <lambdabot> f _ = Nothing
14:00:15 <astrolabe> @djinn a -> [a]
14:00:16 <lambdabot> -- f cannot be realized.
14:00:22 <SamB> okay...
14:00:27 <astrolabe> hmmm I could realise it :)
14:00:29 <SamB> @help djinn
14:00:30 <Cale> It's not terribly good with recursive types.
14:00:30 <lambdabot> djinn <type>.
14:00:30 <nomeata> supposedly djinn can’t handle lists
14:00:31 <lambdabot> Generates Haskell code from a type.
14:00:31 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:00:48 <nomeata> @djinn Tree -> [Node]
14:00:49 <lambdabot> -- f cannot be realized.
14:00:57 <nomeata> Cale: you are right :-)
14:01:24 <SamB> @djinn Maybe a -> [a]
14:01:25 <lambdabot> -- f cannot be realized.
14:01:34 <SamB> @djinn Maybe a -> List a
14:01:35 <lambdabot> -- f cannot be realized.
14:01:43 <SamB> @djinn Maybe a -> ReallyOddlyNamed a
14:01:44 <lambdabot> -- f cannot be realized.
14:01:51 <SamB> wonderful!
14:01:57 <nomeata> @djinn djinn
14:01:58 <lambdabot> -- f cannot be realized.
14:02:13 <nomeata> @djinn a djinn called f
14:02:14 <lambdabot> -- f cannot be realized.
14:02:32 <nomeata> @djinn is called f
14:02:33 <lambdabot> -- f cannot be realized.
14:02:45 <nomeata> djinn needs to take 101 of philosophy
14:15:23 <ptolomy> Oye. I die a little whenever I see an "advantages of <modern language feature>" discussion turn into a "<less featureful language> can still do that (or simulate that)!"/"Give one small simple example where I can't say the advantage of <feature> is minimal or not needed!" party.
14:16:27 <eviltwin_b> just remember that the peasant farmers on Mt. Vesuvius made the same kinds of arguments
14:16:29 <mahogny> you die in all discussions? :)
14:16:53 <w-ber> ptolomy: I can simulate closures in C! No need for Haskell!
14:18:16 <mahogny> I can simulate continuations in assembler!
14:19:32 <mahogny> the XXX is 2% faster than YYY argument is also horrible, if it takes 10 times longer to code in XXX and no one cares
14:21:46 <ptolomy> "If you can't manage your own memory, you're lazy, stupid, and/or incompetent."
14:22:13 <cjeris> s/manage your own memory/grow your own wheat and make bread from it/
14:23:00 <ptolomy> I go with the "Yes, I am lazy and a bit incompetent. However, I'm a bit less so than you, because I recognize it."
14:24:39 <lisppaste2> metaperl annotated #31129 with "some groupBy help needed" at http://paste.lisp.org/display/31129#1
14:25:51 <Baughn> Is it possible to make GHC cross-compile from (say) linux/em64t to freebsd/x86?
14:28:11 <metaperl> DO NOT ANSWER MY QUESTION. I AM GOING HOME
14:29:10 <joelr1> good afternoon
14:29:21 <Excedrin> hi
14:33:00 <Saulzar> Hi joelr1, how's the poker buisiness? I'm trying to write a small poker bot... :)
14:33:45 <joelr1> Saulzar: no business. usa is clamping down on poker, although, strangely enough people are still interested in buying my code. or in looking at it at least
14:33:52 <joelr1> Saulzar: i'm into trading now
14:34:08 <Saulzar> Hmmm..
14:34:18 <Saulzar> Trading, as in shares and currency?
14:34:42 <Saulzar> Seems there are still a number of poker servers about - is it only a matter of time before they're killed off?
14:34:45 <joelr1> Saulzar: futures and options is what i'm looking for. likely just futures. hard to auto-trade options
14:42:05 <ptolomy> Options are tricky as all get-out.
14:47:18 <newsham> hi
14:47:53 <newsham> what poker software, joelr?
14:48:44 <newsham> oh, he left
14:52:16 <retybok> efficient way to retrieve the part of a sorted list where item < constant?
14:53:09 <w-ber> ?hoogle filter
14:53:10 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
14:53:10 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
14:53:10 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
14:53:48 <retybok> filter's not efficient since my list is sorted
14:54:09 <retybok> also, won't work on an infinite list
14:54:20 <w-ber> Alright.
14:54:37 <SamB_XP> retybok: takeWhile?
14:54:56 <retybok> SamB_XP: sounds good, let me check it out
14:55:13 <SamB_XP> > takeWhile (<100000) [1..] :: [Integer]
14:55:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:55:32 <SamB_XP> > length (takeWhile (<100000) [1..]_ :: [Integer]
14:55:32 <lambdabot>  Parse error
14:55:35 <retybok> SamB_XP: thanks
14:55:38 <SamB_XP> > length (takeWhile (<100000) [1..]) :: [Integer]
14:55:39 <lambdabot>  Couldn't match `[Integer]' against `Int'
14:55:53 <SamB_XP> > length (takeWhile (<100000) [1..]) [Integer] :: Int
14:55:54 <lambdabot>  Not in scope: data constructor `Integer'
14:55:58 <SamB_XP> ack
14:56:24 <w-ber> SamB_XP++
14:56:47 <metaperl> so what question did I ask befoer I left?
14:57:33 <w-ber> Good question.
14:57:43 <metaperl> ah, here it is: http://paste.lisp.org/display/31129#1
14:57:46 <w-ber> 00:23:38 < metaperl> DO NOT ANSWER MY QUESTION. I AM GOING HOME
14:57:57 <metaperl> well, I am home now
14:58:12 * metaperl stretches out on the lazy boy
14:58:26 * metaperl puts the cat on his lap
14:58:31 * metaperl lights up his pipe by the fire
14:58:34 <metaperl> yeah right
14:58:36 <metaperl> :)
14:58:48 <newsham> bond supervillain?
14:58:50 <ulph> Compiling Main             ( Lab2.hs, interpreted )
14:58:50 <ulph> Lab2.hs:23:43:
14:58:50 <ulph>     My brain just exploded.
14:58:50 <ulph> You are blinded by a blast of malignant Haskell code. --More--
14:58:50 <ulph> You begin to slow down. --More--
14:58:51 <ulph> You turn into a Haskell program. --More-
14:58:53 <ulph> You die. --More--
14:59:01 <spiffy> I was picturing one of those new fangled leather laptops
14:59:08 <metaperl> lol
14:59:20 <newsham> ulph: should have used lazy evaluation.
14:59:21 <metaperl> with the keyboard in the armrests
14:59:44 <metaperl> can someone get my groupBy working here please: http://paste.lisp.org/display/31129#1
15:00:01 <rahikkala> eeek
15:00:02 <w-ber> ulph: Is that a real error message?
15:00:17 <ulph> w-ber: the "My brain just exploded."-part is real ;)
15:00:24 <rahikkala> I seem to have learned Haskell well enough to get some serious function composition going on -> http://apolyton.net/forums/showthread.php?s=&postid=4690142&t=3346#post4690142
15:00:27 <lambdabot> http://tinyurl.com/yy2gw4
15:01:27 <metaperl> why am I being ignored ???
15:01:33 * metaperl slouches in his lazy boy
15:01:43 * metaperl contemplates jumping in the fireplace
15:01:52 <twanvl> metaperl: how do you want to group?
15:02:03 <metaperl> by the second element of the tuple
15:02:17 <w-ber> metaperl: Maybe no-one knows how to help.
15:02:29 <nomeata> metaperl: it helps to describe your problem in IRC. Unless I find the problem interesting, I don’t bother to check out the paste...
15:02:39 <astrolabe> metaperl: using sortBy before groupBy is often helpful
15:02:48 <twanvl> Your function is used instead of (==), so it should be similair, so \(_,a) (_,b) -> a == b
15:02:58 <newsham> do you want to count all the dogs and cats and bats?
15:02:58 <metaperl> ah
15:03:07 <metaperl> newsham - index them
15:03:18 <astrolabe> say what your final output should look like please.
15:03:19 <twanvl> also: you can use (a,b) <- zip ... in list comprehension, instead of using fst and snd
15:03:34 <metaperl> twanvl - good suggestion. thanks
15:04:55 <astrolabe> why am I being ignored ???   ;)
15:05:16 <metaperl> now what must I import for sortBy to work?
15:05:23 <metaperl> @hoogle sortBy
15:05:24 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
15:05:38 <metaperl> I've import Data.List
15:05:42 <metaperl> should I mport List?
15:05:52 <astrolabe> Data.List probably has it
15:05:56 <metaperl> there's a different module?
15:06:45 <astrolabe> I don't understand your question
15:06:49 <metaperl> newsham - i am indexing each word with a list of each line it occurs on
15:07:01 <astrolabe> Also, I don't know what you want your final output to be
15:07:20 <metaperl> ok
15:07:31 <metaperl> p = "cat dog cat\nbat dog cat\ncat"
15:07:37 <newsham> > sort [(s,n) | (n,l) <- lines "cat dog cat\nbat dog cat\ncat", s <- words l]
15:07:39 <lambdabot>  Couldn't match `[Char]' against `(a, b)'
15:07:44 <metaperl> I am indexing each word with the list of lines it occurs on
15:07:59 <nomeata> @type liftM2 cmp (snd.fst) (snd.snd)
15:08:00 <newsham> > sort [(w,n) | (n,l) <- zip [1..] $ lines "cat dog cat\nbat dog cat\ncat", w <- words l]
15:08:01 <lambdabot> Not in scope: `cmp'
15:08:02 <lambdabot>  [("bat",2),("cat",1),("cat",1),("cat",2),("cat",3),("dog",1),("dog",2)]
15:08:11 <nomeata> @type liftM2 compare (snd.fst) (snd.snd)
15:08:13 <lambdabot> forall a a1 b. (Ord b) => ((a, b), (a1, b)) -> Ordering
15:08:25 <nomeata> @type liftM2 sortBy (compare (snd.fst) (snd.snd))
15:08:26 <metaperl> so we would have [ ("cat", [1,2,3]) , ("dog", [1,2]), ("bat",[1])
15:08:27 <lambdabot>   Couldn't match `m (a -> a -> Ordering)' against `Ordering'
15:08:27 <lambdabot>    Expected type: m (a -> a -> Ordering)
15:08:52 <nomeata> @type sortBy (liftM2 compare (snd.fst) (snd.snd))
15:08:53 <lambdabot>   Couldn't match `a -> Ordering' against `Ordering'
15:08:54 <lambdabot>    Expected type: a2 -> a2 -> a -> Ordering
15:09:28 <astrolabe> I've done this kind of thing
15:09:42 <newsham> > groupBy (\a b -> fst a == fst b) $ sort [(w,n) | (n,l) <- zip [1..] $ lines "cat dog cat\nbat dog cat\ncat", w <- words l]
15:09:44 <lambdabot>  [[("bat",2)],[("cat",1),("cat",1),("cat",2),("cat",3)],[("dog",1),("dog",2)]]
15:09:54 <nomeata> @pl \a b -> compare (snd a) (snd b)
15:09:55 <lambdabot> (. snd) . compare . snd
15:10:15 <metaperl> I want to get sortBy working when the word is the 2nd elem of the tuple newsham
15:10:19 <astrolabe> After I'd sorted and grouped, I ended up using just the head to get "cat" etc.
15:10:50 <metaperl> newsham, the final step is to "congeal" multiple occurences of the word with a list
15:10:59 <metaperl> ("cat", [1,2,3]) for instance
15:11:07 <newsham> > map (\xs -> (snd (head xs), [l | (w,l) <- xs])) $ groupBy (\a b -> fst a == fst b) $ sort [(w,n) | (n,l) <- zip [1..] $ lines "cat dog cat\nbat dog cat\ncat", w <- words l]
15:11:09 <lambdabot>  [(2,[2]),(1,[1,1,2,3]),(1,[1,2])]
15:11:19 <newsham> > map (\xs -> (fst (head xs), [l | (w,l) <- xs])) $ groupBy (\a b -> fst a == fst b) $ sort [(w,n) | (n,l) <- zip [1..] $ lines "cat dog cat\nbat dog cat\ncat", w <- words l]
15:11:21 <lambdabot>  [("bat",[2]),("cat",[1,1,2,3]),("dog",[1,2])]
15:11:31 <metaperl> wow
15:11:39 <greentea> Hi all.
15:11:48 <metaperl> greentea  - 'lo
15:11:56 <nomeata> @pl \t map (\xs -> (fst (head xs), [l | (w,l) <- xs])) $ groupBy (\a b -> fst a == fst b) $ sort [(w,n) | (n,l) <- zip [1..] $ lines t, w <- words l]
15:11:56 <lambdabot> (line 1, column 9):
15:11:57 <lambdabot> unexpected "\\"
15:11:57 <lambdabot> expecting pattern
15:12:01 <nomeata> @pl \t -> map (\xs -> (fst (head xs), [l | (w,l) <- xs])) $ groupBy (\a b -> fst a == fst b) $ sort [(w,n) | (n,l) <- zip [1..] $ lines t, w <- words l]
15:12:03 <lambdabot> map (ap ((,) . fst . head) (return . ((l | (w, l)) <-))) . groupBy ((. fst) . (==) . fst) . sort . (: [w <- words l]) . ((w, n) | (n, l) <- zip [1..]) . lines
15:12:10 <nomeata> that’s wow :-)
15:13:11 <newsham> > map (\xs -> (fst (head xs), map snd xs)) $ groupBy (\a b -> fst a == fst b) $ sort [(w,n) | (n,l) <- zip [1..] $ lines "cat dog cat\nbat dog cat\ncat", w <- words l]
15:13:13 <lambdabot>  [("bat",[2]),("cat",[1,1,2,3]),("dog",[1,2])]
15:13:50 <newsham> ?pl \a b -> fst a == fst b
15:13:51 <lambdabot> (. fst) . (==) . fst
15:14:05 <lisppaste2> metaperl annotated #31129 with "my sortBy is now working. help please" at http://paste.lisp.org/display/31129#2
15:14:16 <newsham> > map (\xs -> (fst (head xs), map snd xs)) $ groupBy ((. fst) . (==) . fst) $ sort [(w,n) | (n,l) <- zip [1..] $ lines "cat dog cat\nbat dog cat\ncat", w <- words l]
15:14:18 <lambdabot>  [("bat",[2]),("cat",[1,1,2,3]),("dog",[1,2])]
15:15:02 <newsham> ?pl \x -> [(w,n) | (n,l) <- zip [1..] $ lines x, w <- words l]
15:15:04 <lambdabot> (: [w <- words l]) . ((w, n) | (n, l) <- zip [1..]) . lines
15:15:06 <metaperl> why is my sortBy giving that cryptic error message?
15:15:26 <newsham> why do you need sortby?  put the word first and you can just use normal sort
15:15:39 <metaperl> newsham - agreed. but what I am doing should work
15:16:29 <metaperl> so why does it not work: http://paste.lisp.org/display/31129#2
15:16:57 <chessguy> we saw it the first time
15:17:16 <newsham> hmm.. there's no sortByKey ?
15:17:17 <metaperl> chessguy - you play chess?
15:17:36 <newsham> I would like   sortByKey snd
15:17:37 <chessguy> wow, did you figure that out all by yourself?
15:17:46 <metaperl> lol
15:17:59 <metaperl> I play at SlowChess.com under name "tbrannon" if you want to play
15:18:31 <chessguy> i'll remember that the next time i'm not logged onto icc with 2500 people to play
15:19:36 <Excedrin> metaperl: are you master level?
15:20:01 <newsham> > let sortByKey f xs = map snd $ sortBy (\a b -> compare (fst a) (fst b)) $ [(f x, x) | x <- xs] in sortByKey fst [(1,2), (1,1), (3,3), (1,3), (2,9), (9,2)]
15:20:03 <lambdabot>  [(1,2),(1,1),(1,3),(2,9),(3,3),(9,2)]
15:20:14 <newsham> > let sortByKey f xs = map snd $ sortBy (\a b -> compare (fst a) (fst b)) $ [(f x, x) | x <- xs] in sortByKey snd [(1,2), (1,1), (3,3), (1,3), (2,9), (9,2)]
15:20:16 <lambdabot>  [(1,1),(1,2),(9,2),(3,3),(1,3),(2,9)]
15:20:57 <newsham> schwartzian.  metaperl should know about it with a name like that
15:21:14 <metaperl> the Schwartzian transform. yes I remember that
15:21:34 <psnl> argh!
15:22:15 * psnl hates the Schwartzian transform
15:22:29 <newsham> metaperl: sortBy doesnt want "==", it wants a compareison with "compare"
15:22:33 <newsham> > compare 1 5
15:22:35 <lambdabot>  LT
15:22:36 <newsham> ?type compare
15:22:38 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:22:43 <newsham> ?type sortBy
15:22:45 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:22:51 <metaperl> oh
15:23:13 <newsham> you want \a b -> compare (snd a) (snd b)
15:23:35 <newsham> or if you prefer  \(_,a) (_,b) -> compare a b
15:24:04 <metaperl> The PLEAC code must be wrong: http://pleac.sourceforge.net/pleac_haskell/hashes.html
15:24:06 <lambdabot> http://tinyurl.com/y528w8
15:24:35 <newsham> sortByKey f xs = sortBy (\a b -> compare (f a) (f b)) xs
15:24:38 <newsham> sortByKey snd
15:26:30 <ptolomy> Dumb question: What is the easiest way to make a sort/sortBy sort in reverse? is it just using 'reverse'?
15:26:53 <newsham> sortBy (\a b -> b compare a)    ?
15:27:10 <metaperl> Excedrin - no , I am not master level. I did not notice your comment
15:27:23 <newsham> > sortBy (flip compare) "this is a test"
15:27:24 <lambdabot>  "tttsssiihea   "
15:27:27 <ulph> @paste
15:27:27 <lambdabot> http://paste.lisp.org/new/haskell
15:27:47 <newsham> > sortBy compare "this is a test"
15:27:49 <lambdabot>  "   aehiisssttt"
15:29:15 <newsham> ?check \s -> (reverse . sort) (s :: String) == sortBy (flip compare) s
15:29:17 <lambdabot>  OK, passed 500 tests.
15:29:36 <w-ber> > sortBy compare "this"
15:29:37 <lambdabot>  "hist"
15:29:52 <nomeata> > sort "this"
15:29:53 <lambdabot>  "hist"
15:31:02 <newsham> ?check \s -> sort (s :: String) == sortBy compare s
15:31:04 <lambdabot>  OK, passed 500 tests.
15:32:30 <metaperl> paste.lisp.org is down again
15:34:13 <lisppaste2> ulph pasted "type problem with heterogeneous type" at http://paste.lisp.org/display/31165
15:34:48 <ulph> i understand why i doesn't work but i'm not sure how it should be written..
15:43:00 <ptolomy> newsham:  Ah. Flip. Of course. Thanks. :)
15:46:59 <Masklinn> Hello everyone
15:47:35 <metaperl> newsham - thanks a lot for your help
15:48:18 <newsham> your welcome
15:52:33 <Excedrin> what is an infinite type?
15:53:10 <newsham> ?type iterate (\x -> [x])
15:53:12 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:53:12 <lambdabot>    Expected type: a
15:53:18 <w-ber> > let ackermann 0 n = n+1; ackermann m 0 = ackermann (m-1) 1; ackermann m n = ackermann (m-1) (ackermann m (n-1))
15:53:19 <lambdabot>  Parse error
15:53:29 <w-ber> @let ackermann 0 n = n+1; ackermann m 0 = ackermann (m-1) 1; ackermann m n = ackermann (m-1) (ackermann m (n-1))
15:53:31 <lambdabot> Defined.
15:53:34 <newsham> ?type \x -> [x]
15:53:35 <w-ber> > ackermann 4 3
15:53:36 <lambdabot>  Not in scope: `ackermann'
15:53:36 <lambdabot> forall a. a -> [a]
15:53:41 <w-ber> > L.ackermann 4 3
15:53:45 <lambdabot> Terminated
15:53:47 <w-ber> Ha.
15:53:53 <w-ber> > L.ackermann 4 1
15:53:57 <lambdabot> Terminated
15:54:00 <w-ber> > L.ackermann 3 1
15:54:02 <lambdabot>  13
15:54:04 <w-ber> > L.ackermann 3 10
15:54:08 <lambdabot> Terminated
15:54:14 <w-ber> > L.ackermann 3 5
15:54:15 <lambdabot>  253
15:54:17 <w-ber> > L.ackermann 3 6
15:54:19 <lambdabot>  509
15:54:22 <newsham> exc: see how a -> [a] repeated multiple times would result in an infinite type?
15:54:23 <w-ber> > L.ackermann 3 8
15:54:25 <lambdabot>  2045
15:54:38 <newsham> you would have a list of lists of lists of lists of lsts .. ad infinitum
15:55:05 <w-ber> f = f is an infinite type.
15:55:06 <newsham> haskell can deal with a list of lists of lists
15:55:12 <newsham> but not a list of list of lists of lists of lists of ....
15:55:13 <w-ber> > let f = f in f
15:55:14 <lambdabot>  Add a type signature
15:55:20 <w-ber> @type f = f
15:55:21 <lambdabot> parse error on input `='
15:55:22 <newsham> similarly:
15:55:41 <newsham> ?type iterate (\x -> (1, x))
15:55:43 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
15:55:43 <lambdabot>    Expected type: b
15:57:05 <newsham> ?type iterate (\x -> (1, fst x))
15:57:07 <lambdabot> forall a. (Num a) => (a, a) -> [(a, a)]
15:58:59 <newsham> make sense?  or still not clear?
16:00:37 <Saizan> when i have an existential type, i can only call function from the class for which it is quantified?
16:00:53 <kpreid> w-ber: f = f is not an infinite type
16:00:57 <kpreid> @type let f = f in f
16:00:59 <lambdabot> forall t. t
16:01:10 <SamB_XP> Saizan: or functions that were stuffed into the constructor with it
16:01:13 <Excedrin> newsham: sort of clear, I'm not sure how tell if a type will be infinite though
16:01:28 <kpreid> > let f = f in f :: String
16:01:30 <lambdabot>  Exception: <<loop>>
16:01:45 <Saizan> SamB_XP: like?
16:01:53 <SamB_XP> like...
16:02:05 <newsham> excedrin: if a type a must also be a list containing itself as a type...  then it is infinite
16:02:20 <newsham> if a type is a tuple with one of its elements being the same type, its infinite...
16:02:22 <SamB_XP> well, I don't know the syntax...
16:02:34 <w-ber> kpreid: The Gentle Haskell Tutorial claims bot = bot is.
16:02:36 <Excedrin> it's weird to me that iterate id is OK, but iterate (\x -> (x,x)) is not
16:02:47 <newsham> "cannot construct the infinite type: t = [t]"
16:02:47 <Saizan> maybe you mean if i take the constructro with me i can call what i want?
16:02:48 <kpreid> w-ber: it's wrong then
16:03:00 <newsham> is saying that the type t would have to be a list containing t's
16:03:01 <SamB_XP> data Foo = Foo exists a. a (a -> String)
16:03:03 <kpreid> w-ber: as ghc says, it has a well-defined type
16:03:04 <newsham> which is an infinite type
16:03:10 <w-ber> kpreid: Good to know.
16:03:21 <SamB_XP> showFoo (Foo x f) = f x
16:03:53 <SamB_XP> ^- see how f was taken from the same pattern match there?
16:04:12 <Saizan> yes
16:04:21 <Saizan> i see
16:05:33 <Saizan> pratically a is fixed by the constructor, it can't be anything else
16:13:06 <lispy> impressive, gnu tar had a security exploit
16:19:12 <mgsloan> http://www.ffconsultancy.com/dotnet/fsharp/raytracer/index.html <- ooh, 3d fractal
16:19:14 <lambdabot> Title: Flying Frog Consultancy Limited: Ray tracer, http://tinyurl.com/ycorbd
16:22:37 <dons> moin
16:22:42 <dons> ?users
16:22:43 <lambdabot> Maximum users seen in #haskell: 276, currently: 245 (88.8%), active: 43 (17.6%)
16:24:01 <astrolabe> http://images.google.co.uk/imgres?imgurl=http://perso.crans.org/~raffo/art/photos/frattale1.jpg&imgrefurl=http://perso.crans.org/~raffo/art/frattale1.html&h=604&w=900&sz=185&hl=en&start=14&tbnid=l0mDXzornHKxTM:&tbnh=98&tbnw=146&prev=/images%3Fq%3D3d%2Bfractal%26svnum%3D10%26hl%3Den%26lr%3D%26sa%3DN
16:24:04 <lambdabot> Title: Google Image Result for http://perso.crans.org/~raffo/art/photos/frattale1.jpg, http://tinyurl.com/yckwsr
16:27:56 <newsham> hi dons
16:31:24 <dons> mmm.more haskell blogging, http://programming.reddit.com/info/taqi/details
16:31:27 <lambdabot> Title: Functions, Types, Function Types, and Type Inference (reddit.com), http://tinyurl.com/t67qk
16:32:55 <Excedrin> lispy: looks like star is not vulnerable to that particular exploit; it creates the stored symlink as a file
16:37:59 <lispy> Excedrin: star?
16:40:38 <Excedrin> lispy: http://cdrecord.berlios.de/old/private/star.html
16:40:41 <lambdabot> Title: Star a very fast and Posix 1003.1 compliant tar archiver for UNIX, http://tinyurl.com/yffmkf
16:41:23 <newsham> talking about the gnu tar "extract anywhere" vulnerability?
16:43:10 <lispy> newsham: delete arbitrary file due to some symlink expoit
16:43:14 <Excedrin> I assume so, it's the most recent one...
16:45:57 <sjanssen> @quote
16:45:57 <lambdabot> desrt says: psi is lame. psi is what you use when phi is already taken
16:49:35 <lispy> ?quote
16:49:36 <lambdabot> dolio says: [psnl] its been made worse by uni doing a sexual awareness week [dolio] Some people at your university weren't aware of sex?
16:49:51 <lispy> heh
16:51:36 <lispy> ah, neat, someone admitted to using lambdabot on the web regularly
16:52:09 <lispy> warmfuzzy++
16:52:11 <dons> *cough* "So... type classes are basically a formalized version of duck typing?"
16:52:16 <dons> lispy: yeah
16:52:34 <dons> http://programming.reddit.com/info/taqi/details !
16:52:36 <lambdabot> Title: Functions, Types, Function Types, and Type Inference (reddit.com), http://tinyurl.com/t67qk
16:52:49 <dons> i'm so glad we're getting a series of haskell blog articles, for  a widely read blogger.
16:52:55 <dons> s/from/
16:55:09 <lispy> dons: if you think about it, OOHaskell, due to the way the types of objects are constructed is fundamentally duck typing
16:55:43 <lispy> dons: to the point that you could maybe calle it a "purely duck typed object system"? ;)
16:56:07 <dons> are there papers on what duck typing actually means?
16:56:28 <dcoutts_> lispy, you mean because the record system basically records in the type "this record has a field X :: T"
16:56:49 <dons> morning dcoutts_
16:56:51 <lispy> dcoutts_: yeah, because the type is derived from the interface + fields
16:56:59 <dcoutts_> hia dons, btw hotel booked ok I think
16:57:18 <dcoutts_> and so you can write code that takes any value such that it has fields X1 :: T1, X2 :: T2, etc
16:57:25 <greentea> dons: i thought it just meant "if something behaves in ways characteristics of a certain type, assume that it effectively /is/ that type."
16:57:42 <dcoutts_> polymorphic in the record type with constraints specifying the fields
16:57:42 <lispy> dcoutts_: according to the paper yeah.  You do things like least upper bound types
16:58:05 <dcoutts_> lispy, doesn't Ocamml records do basically that ?
16:58:14 <sjanssen> @where paste
16:58:14 <lambdabot> http://paste.lisp.org/new/haskell
16:58:16 <dons> greentea: but that's a vague definition of a type inference algorithm. it worries me.
16:58:17 <dcoutts_> or do I mean modules
16:58:30 <dons> ?type let f x = x / 2 -- infers the type, based on how / is used.
16:58:31 <lambdabot> not an expression: `let f x = x / 2'
16:58:36 <dons> ?type let f x = x / 2 in f -- infers the type, based on how / is used.
16:58:37 <lispy> i would assume the name "duck typing" comes from the saying, "if it walks like a duck and talks like a duck, it must be a duck"
16:58:38 <lambdabot> forall a. (Fractional a) => a -> a
16:58:42 <greentea> dons: Yeah, fair enough.
16:58:47 <lispy> dcoutts_: i don't actulaly know ocaml :)
16:58:49 <Excedrin> are all of the distributed Haskell projects dead?
16:59:12 <dons> ndp/dph isn't
16:59:25 <lisppaste2> sjanssen pasted "Haskell segfault with or unsafe* function (no FFI either)" at http://paste.lisp.org/display/31172
16:59:28 <dcoutts_> dons, but it'd be great for an IDE, it could suggest what operator you meant to use based on the way you're using it. Eg when it suggest that you need to import module Foo.Bar which exports baz at the type at which you're using it.
16:59:34 <dons> without, sjanssen ?
16:59:48 <sjanssen> dons: blast!  yes, without
16:59:52 <dons> dcoutts_: yeah.
17:00:11 <dcoutts_> dons, basically if you find a unbound var you just find the contraints you're placing on it and use that to guide the search for suggestions
17:00:17 <dons> sjanssen: so why's it crashing?
17:00:19 <lispy> isn't the default typingin OOHaskell called structural typing?
17:00:30 <sjanssen> dons: an evil Ix instance that doesn't check it's bounds
17:00:39 <dons> ah!
17:00:40 <sjanssen> has anyone seen this problem before?
17:00:58 <dons> sjanssen: i've not seen this. super nice example though.
17:01:10 <dcoutts_> so it requires a bottom up constraint gathering type inference algorithm (which is fairly easy to write)
17:01:48 <dons> sjanssen: I think its worth writing a provocative mail to haskell-cafe with a title like "Segfaulting Haskell via evil Ix instance"
17:01:51 <dcoutts_> Excedrin, see the latest HCAR for info on GPH and GDH
17:06:35 <dons> sjanssen: since at the very least there should be some strong warnings about defining Ix for unboxed types..
17:06:35 <lispy> oh, it should be without unsafe* or FFI
17:06:35 <sjanssen> dons: this really doesn't have much to do with unboxed types
17:06:35 <sjanssen> lispy: yes
17:06:35 <lispy> the title confused me :)
17:06:35 <dons> sjanssen: will an Array instance segfault
17:06:35 <sjanssen> this is what happens when you try to edit in a teensy weensy text field
17:06:35 <sjanssen> dons: yes.  You'll need to change the first index you try to a sufficiently large number
17:06:35 <dons> sjanssen: can you post both versions (UArray and Array) to haskell-cafe@
17:06:35 <lispy> sjanssen: heh, yeah, i can relate
17:06:35 <sjanssen> however, in a related note, one can use this hack to make non-bounds checked zero-indexed arrays
17:06:35 <dons> yeah that's a nice idea :)
17:06:35 <dons> for arbitrary types
17:06:35 <sjanssen> but this is a bug that can and should be fixed
17:06:35 <dons> not just the Int indexed unsafeRead/Write ones, I guess
17:06:35 <sjanssen> add an extra field to the Array constructors that holds the actual size
17:06:35 <dons> yep
17:07:28 <dcoutts_> sjanssen, the ByteArray# knows the real size of the memory chunk. You could use that.
17:08:00 <sjanssen> dcoutts_: excellent, so a fix should be quite easy
17:08:20 <dcoutts_> sjanssen, though it only knows it to the nearest 4 bytes
17:08:29 <dcoutts_> but that's enough to stop segfaulting
17:08:35 <dcoutts_> I think
17:09:17 <dons> mmm. the HWN collects a lot of blog articles that don't appear on planet, I wonder if i should extract the lsit, and add them to the wiki on a Blog page
17:09:24 <sjanssen> it's always 4 bytes, even if the platform has 64-bit Ints?
17:09:38 <dcoutts_> sjanssen, no, it's a word, so it's 4 or 8 bytes
17:10:07 <lispy> it's so nice that missingH is getting polished and integrated
17:10:12 <sjanssen> a word should be big enough for the entire addressable memory, yeah?
17:10:20 <dcoutts_> sjanssen, sure
17:10:37 <dcoutts_> sjanssen, a pointer is word sized, by definition
17:10:54 <dcoutts_> or perhaps a word is pointer sized by definition
17:11:19 <dcoutts_> it counts words, actually I'd prefer if it counted bytes as then we could use it for some other purpose in ByteString (which I can't recall atm)
17:11:50 <dcoutts_> I'd really like ByteStrings to be relocatable
17:11:51 <newsham> seems like the kind of thing that would upset haskell programmers:  http://www.beyond3d.com/articles/fastinvsqrt/
17:11:54 <lambdabot> Title: Beyond3D - Which was nice.
17:12:02 <sjanssen> dcoutts_: do you know the function to get the size from a ByteArray#?  Alternatively, where is a person supposed to find these things out?
17:12:57 <dcoutts_> sjanssen, I'm not sure there is one exposed in the libs. It's used in the really low level stuff. There's certainly an rts function for it. So you might need to add a proper function for it.
17:14:01 <sjanssen> so in other words, leave the patch for developers with the low level know how ;)
17:14:19 <dons> sjanssen: what happens in hugs?
17:14:25 <sjanssen> dons: segfault
17:14:39 <dcoutts_> sjanssen, na, you could do it fine
17:14:40 <mgsloan> is factorial only defined for integers?  I always figured it was funny like how you can have decimal powers
17:14:48 <dons> good thing we can deriving Ix then
17:15:07 <dcoutts_> mgsloan, I think there is an interpretation for rationals or reals
17:15:19 <mgsloan> that's what i figured
17:15:34 <mgsloan> well, this guy is wrong then http://scienceblogs.com/goodmath/2006/12/functions_types_function_types_1.php
17:15:36 <lambdabot> http://tinyurl.com/yxzp2a
17:16:03 <sjanssen> well, I gotta go to dinner.  Expect a provocative email in an hour or two
17:16:32 <mgsloan> well, maybe not wrong.  Perhaps his fact function is indeed only defined for integers, eg, only terminates if its an integer.  /me goes to find the func
17:16:35 <dufflebunk> mgsloan: the one used for reals is derived from the gamma function.
17:16:35 <dcoutts_> mgsloan, well he is right, that definition only works for integers
17:16:57 <mgsloan> dufflebunk - oh, intense
17:16:59 <dcoutts_> mgsloan, the way you calculate it for reals is different (and then int is a special case of that method)
17:17:18 <dcoutts_> right, like dufflebunk says
17:17:29 <dons> > 1%2 ^ 3%6
17:17:30 <lambdabot>  add an instance declaration for (Integral (Ratio a))
17:17:38 <dons> > 1%2 ^^ 3%6
17:17:39 <lambdabot>  add an instance declaration for (Integral (Ratio a))
17:19:49 <dcoutts_> dons, btw, I found a nice application for @pl - as an obfuscater which allows me to provide students with a quickcheck property that compares their answer to a model solution without them being able to figure out the model solution.
17:20:26 <dcoutts_> @pl \axiom rules n -> iterate (concatMap (\c -> foldr const [c] ((map snd . filter ((==c).fst)) rules))) axiom !! n
17:20:27 <lambdabot> ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
17:20:38 <SamB> @unpl ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
17:20:38 <lambdabot> (\ m au ->
17:20:39 <lambdabot>   (!!)
17:20:39 <lambdabot>    (iterate
17:20:39 <lambdabot>     (\ y ->
17:20:39 <lambdabot>       y >>=
17:20:40 <lambdabot>        ((\ ah -> foldr (\ e _ -> e) (return ah)) >>=
17:20:43 <lambdabot>         \ aa ->
17:20:44 <lambdabot>          (\ h -> map snd (filter (\ ba -> h == (fst ba)) au)) >>=
17:20:47 <lambdabot>           \ z -> return (aa z)))
17:20:49 <lambdabot>     m))
17:20:52 <dcoutts_> mwah ha ha ha
17:21:12 <SamB> ... I might be able to figure it out with a really nice editor
17:21:25 <SamB> one that could tell me the types functions were applied at
17:21:31 <SamB> such as >>=
17:21:52 <dcoutts_> SamB, if you are clever enough to reconstruct a solution from that, you could much more easily have written it from scratch.
17:22:23 <SamB> well, I might be able to reconstruct your original property at least
17:22:35 <mgsloan> when I was in elementary school I actually tried to figure out non-integer powers.  Was pretty half assed though.  I tried 3^2.5 = 3*3*1.5 and such, which didn't work out right.  Eventually i just went for plotting the int powers and drawing a smooth curve...
17:22:36 <SamB> and if that won't get me far, why bother obfusticating it?
17:23:06 <SamB> mgsloan: see, you would have done better if you had first taken calculus!
17:23:07 <mgsloan> Only recently found out (due to calculus) how it works
17:23:13 <mgsloan> heh
17:23:24 <mgsloan> yeah, actually I would have loved calculus in elementary school...
17:23:27 <SamB> calc ii/iii ftw!
17:23:46 <SamB> yeah apparantly I've always wanted to know calculus ;-)
17:23:49 <dcoutts_> SamB, because we don't want to provide the students with a model solution.
17:24:01 <dons> dcoutts_: nice idea!
17:24:18 <SamB> oh
17:24:23 <dons> obfuscationg isn't NP hard though. so beware ;)
17:24:33 <SamB> ah.
17:24:42 <SamB> that was the model solution then?
17:24:56 <dons> http://www.cs.princeton.edu/~appel/papers/deobfus.pdf
17:24:58 <lambdabot> http://tinyurl.com/yln9u4
17:25:01 <dcoutts_> dons, we're only talking about 1st years here, with 5 weeks Haskell coding experience. :-)
17:25:13 <dons> dcoutts_: hehe
17:25:14 <lispy> newsham: i read the article, but i'm not sure what you mean
17:25:15 <SamB> it shouldn't be too hard to automate translating >>= back to concatMap
17:25:17 <mgsloan> I've decided the same thing about other arbitrary math limitations - eg, that derivative abs value is discontinuous.  I think it's an interval on the y axis [-1,1]
17:25:19 <dons> who don't visit this channel?
17:25:40 <dcoutts_> SamB, well that was a higher order version of a model solution. No student would actually write that.
17:26:14 <dcoutts_> because they wouldn't be able to explain it when I asked them how it works :-)
17:26:21 <mgsloan> technically this makes it not a function, but from my view, interval is just a different kind of number..
17:27:01 <lispy> mgsloan: time to start studying point-set topology then?
17:27:26 <dcoutts_> SamB, the thing I @pl'ed above was already rather hard to read / understand.
17:27:30 <mgsloan> heh, perhaps
17:27:52 <SamB> dcoutts: true
17:28:07 <mgsloan> (yes, i understand that an interval is a set of points, just trying to maintain the 'function' status of the derivative)
17:28:37 <SamB> @type foldr const "c"
17:28:39 <lambdabot> [[Char]] -> [Char]
17:29:09 <SamB> > foldr const "c" ["hello", "world"]
17:29:10 <lambdabot>  "hello"
17:29:16 <SamB> um...
17:29:22 <SamB> why foldr const c?
17:29:28 <SamB> oh.
17:29:28 <dcoutts_> SamB, so what does it do ?
17:29:37 <lispy> mgsloan: i meant it more like, if you're comfortable with intervals as objects similar to numbers then you're ready for the next step in studying intervals, topology
17:29:38 <SamB> is that a safe version of head then?
17:29:40 <dcoutts_> well done :-)
17:29:55 <mgsloan> lispy - oh, sounds good
17:31:15 <SamB> I sure wish there was a library function for (a -> Bool) -> [(a, b)] -> b
17:31:18 <SamB> er.
17:31:20 <SamB> add []
17:31:22 <SamB> around the b
17:31:25 <SamB> silly me
17:31:27 <mgsloan> is that like the map coloring stuff? (eg, you can use 4 colors to color any border map under certain specifications)
17:31:53 <lispy> mgsloan: i think that result is actually graph theory
17:32:07 <SamB> dcoutts: this is an l-system thingy, isn't it?
17:32:07 <mgsloan> oh, ok, maybe different stuff then
17:32:15 <lispy> mgsloan: topology is the study of open and closed sets and the "algebra" they produce
17:32:20 <dcoutts_> SamB, you've got it.
17:37:08 <lispy> mgsloan: in the real numbers, [a,b] is a closed set and (a,b) is an open set (you also have sets which are neither
17:37:08 <mgsloan> yep, we know that
17:37:08 <Saizan> and every open set is "the same as" R
17:37:08 <mgsloan> (my calc class)
17:37:08 <lispy> mgsloan: and in some topologies sets can be both closed and open at the same time, these are called clopen
17:37:08 <mgsloan> one thing i don't like about that notation is that it's ambiguous with coord pairs, so i write those as <x,y>
17:37:08 <mgsloan> oh, open and closed on different sides?
17:37:08 <SamB> hmm, it would be cool if you could get lambdabot to paste things to lisppaste
17:37:08 <lispy> mgsloan: math is unambigious...the author always knows which interpretation is meant :)
17:37:08 <mgsloan> haha
17:37:08 <SamB> it would look something like this...
17:37:08 <lispy> mgsloan: nope, a set like, [a,b) in the reals would be neither open, closed nor clopen
17:37:08 <dons> SamB: it would? you know how to write the plugin (not too hard , I think)
17:37:08 <greentea> msgloan: That sort of set is often called "half-open".
17:37:08 <mgsloan> oh, good to know
17:37:08 <SamB> hmm, but how would it know what to call the paste?
17:37:08 <dons> SamB: take it from the nick ++ first line of code
17:37:08 <SamB> ah, I suppose that would work
17:37:08 <dons> SamB: how do you imagine the interface though?
17:37:08 <dons> since i think only one liners make sense...
17:37:08 <dons> and then what's the piont?
17:37:08 <SamB> @. dopaste unpl blah
17:37:08 <lambdabot> compose module failed: IRCRaised Parse error: "dopaste"
17:37:08 <SamB> etc.
17:37:08 <dons> ok. nice idea
17:37:08 <mgsloan> uh, howabout you priv it "Paste:" and then code after that (still priv) is stuck in a paste
17:37:19 <SamB> mgsloan: if you already had the text, you could just paste it yourself!
17:37:21 <dons> yeah, that would make a reasonable contextual handler
17:37:39 <dons> a command line tool to listpaste would be more useful to me
17:37:40 <SamB> this is for pasteboarding lambdabot output
17:37:43 <dons> so I could say 'paste A.hs'
17:37:45 <dons> and it would..
17:37:46 <mgsloan> SamB - oh, i thought you just wanted a more convenient pasting system :)
17:38:21 <SamB> dons: you could steal the code from the lambdabot plugin then ;-)
17:38:50 * mgsloan doesn't get clopen (probably not supposed to ;), unless its like quantum spin crap - up, down, or both), but I can read wikipedia articles
17:38:51 <dons> SamB: why not write a little cabalised lisppaste tool?
17:38:59 <SamB> hmm, lisppaste seems down?
17:39:00 <dons> SamB: you'd have half the channel using it in a few days...
17:39:04 <lispy> dons: would it hurt if we added : as the command prefix char to lambdabot?
17:39:10 <dons> :) yes
17:39:14 <lispy> dons: and if we did, could we make t an alias for type
17:39:27 <dons> we could, yeah
17:39:30 <SamB> lispy: why if
17:39:36 <dons> not sure if its too useful though?
17:39:36 <lispy> i see a lot of people including myself do, :t blah
17:39:39 <SamB> or, we could just make GHCi and hugs use @
17:40:15 <dons> lispy: we could add a special contextual handler for :t
17:40:18 <dons> since that's the only one
17:40:31 <SamB> then I'd want to be able to do :m too ;-P
17:40:36 <lispy> dons: sounds good
17:41:02 <lispy> dons: i won't work on it today, but now i know the best way to do it
17:41:11 <lispy> which was the thing holding me back before
17:41:55 <SamB> dons: clearly, I cannot write it now, because I can't even get paste.lisp.org to load...
17:42:18 <lispy> lisppaste2: hussle!
17:44:00 <dons> ?uptime
17:44:01 <lambdabot> uptime: 1d 16h 27m 59s, longest uptime: 9d 2h 23m 6s
17:44:28 <dons> mmm, 12:39  lambdabot> uptime: 1m 1d 10m 21s, longest uptime: 1m 1d 10m 21s
17:44:30 <lispy> oh yeah, my best uptime is 23d :)
17:44:32 <dons> my other bot is a lambdabot
17:44:50 <lispy> (but then freenode came down and spoiled it)
17:45:16 <dons> the bot's in a good stable place atm
17:45:34 * SamB doesn't think the network coming down should count as an outage
17:45:57 <lispy> dons: yeah, i need to upgrade my copies of lambdabot though
17:46:50 <lispy> lambdabot 4p222, GHC 6.4.2 (Linux x86_64 3.20GHz)
17:46:50 <dons> SamB: can you submit the patch then to keep the bot online during the outage?
17:46:52 <lispy> ?version
17:46:53 <lambdabot> lambdabot 4p282, GHC 6.5 (OpenBSD i386)
17:46:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:46:56 <dons> mm
17:47:01 <lispy> 60 patches behind!
17:47:06 <Excedrin> dcoutts_: thanks, it's nice to see that GdH isn't dead, but it would be nice if they updated their webpage (Last updated May 2003)
17:48:04 <SamB> dons: you mean so it will try to reconnect?
17:48:29 <lispy> SamB: well, currently it just exits when the network connection goes down
17:48:41 <dons> I was hoping you'd provide a patch for surviving power outages too
17:48:47 <lispy> :)
17:49:02 <SamB> @. pretty unpl ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
17:49:03 <lambdabot> "Parse error" at column -14
17:49:03 <lispy> i'd just fix the uptime calculation :)
17:49:10 <svref> I want to download a http url ... should I look into sockets, and talk to port 80, or is there a better way?
17:49:17 <SamB> @. pretty unpl f = ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
17:49:17 <lambdabot> "Parse error" at column -15
17:49:21 <SamB> aww.
17:49:33 <lispy> svref: i can give you code which uses libcurl to fetch things
17:49:41 <lispy> svref: but there is a haskell native http library too
17:49:42 <dons> svref: the http package perhaps
17:49:56 * SamB doesn't see how you can be at negative columns
17:50:00 <dons> svref: or mini http, its 1 module
17:50:12 <dons> svref: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/MiniHTTP.hs
17:50:12 <lambdabot> http://tinyurl.com/y6dpoj
17:50:45 <lispy> at some point i wrote a haskell program which downloads the source to a wikipedia page
17:50:47 * svref overwhelmed by choices
17:51:03 <dons> svref: this would do:
17:51:04 <dons> readPage :: Proxy -> URI -> [String] -> String -> IO [String]
17:51:04 <dons> readPage proxy uri headers body
17:51:06 <dons> right?
17:51:37 <dons> or with a bit of : getHtmlPage :: URI -> Proxy -> IO [String]
17:51:44 <dons> here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Url.hs
17:51:45 <lambdabot> http://tinyurl.com/yxera4
17:52:07 <dons> (so you have 3 optoins: do it yourself with -package network, use -package http, or use the 2 minihttp modules)
17:52:15 <dons> there's probably some other choices
17:52:55 <svref> what's your gut telling you?
17:53:03 <svref> I'll look there first.
17:53:11 <dons> i'd use the minihttp package, and grab the getHtmlPage method from the above Url.hs
17:53:12 <CosmicRay> hey dons
17:53:14 <dons> s/package//
17:53:16 <dons> hey CosmicRay
17:53:27 <svref> I don't need html parsing
17:53:48 <dons> svref: I.e. these 2 files, then hack: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/{MiniHTTP,Url}.hs
17:53:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/{MiniHTTP,Url}.hs
17:53:52 <CosmicRay> "what's your gut telling you?"  dangerous question.  apparently it told bush that the iraqis would welcome us as liberators ;-)
17:54:03 <dons> heh
17:54:05 <lispy> CosmicRay: the discussions of missingh are really cool, i'm glad to see this getting some incorporation
17:54:26 <dons> there's probably a function in MissingH too for download html pages
17:54:33 <svref> dons: if you're Bush, you'd better disclose that.  :)
17:55:17 <dons> my feeling is that the Java programmers will welcome us as liberators
17:55:25 <SamB> svens: what does any of this have to do with bush?
17:55:49 <SamB> dons: are you adding Haskell to sun's Java compiler?
17:56:32 <lispy> ?remember dons my feeling is that the Java programmers will welcome us as liberators
17:56:36 <CosmicRay> lispy: me too
17:56:43 <CosmicRay> lispy: HAHAHA.  that is great.
17:56:52 <CosmicRay> lispy: can I quote you on my blog?
17:56:52 <SamB> @unpl doesn't have good style when it comes to monads...
17:56:53 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 51}: Parse error
17:56:57 <SamB> @unpl doesn't have good style when it comes to monads
17:56:58 <lambdabot> doesn't have good style when it comes to monads
17:57:20 <jcreigh> @pl fac n = product [1..n]
17:57:21 <lambdabot> fac = product . enumFromTo 1
17:57:26 <lispy> SamB: well, you could ?. redo pl undo
17:57:36 <jcreigh> hmm, that's not as ugly as I thought it would be.
17:57:50 <SamB> lispy: that actaully exists?
17:57:53 <lispy> and maybe you need another dot in there to make it chain correctly
17:58:27 <SamB> um, I only wanted to @. redo unpl
17:58:31 <lispy> ?. redo undo do { x <- getContents; putStrLn x }
17:58:31 <lambdabot> do { x <- getContents; putStrLn x}
17:58:44 <SamB> @. redo unpl ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
17:58:45 <lambdabot> (\ m au -> (!!) (iterate (\ y -> do { b <- y; (do { aa <- (\ ah -> foldr (\ e _ -> e) (return ah)); z <- (\ h -> map snd (filter (\ ba -> h == (fst ba)) au)); return (aa z)}) b}) m))
17:58:50 <SamB> oh. nice.
17:59:00 <SamB> but.
17:59:01 <SamB> ugly.
17:59:08 <SamB> @. pretty . redo unpl ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
17:59:09 <lambdabot> "Parse error" at column -17
17:59:24 <SamB> why oh why dost thou torment me so, oh lambdabot?
17:59:38 <SamB> @pretty hi
17:59:39 <lambdabot> "Parse error" at column 3
17:59:46 <SamB> hmm.
17:59:50 <SamB> @pretty hi = bye
17:59:52 <lambdabot>  hi = bye
17:59:54 <wolverian> heh. column -17
17:59:54 <SamB> okay.
17:59:57 <kpreid> yeah, unpl should use redo
17:59:58 <lispy> would an expression in anyother interpreter evalaute so sweet?
17:59:59 <jcreigh> @redo getLine >>= putStrLn
18:00:00 <lambdabot> do { a <- getLine; putStrLn a}
18:00:12 <kpreid> it's not really part of its job, but so common
18:00:35 <kpreid> I think the parse error problem is that @. joins lines
18:00:36 <jcreigh> hmmm...is @. redo undo the identity function?
18:00:39 * lispy thinks it's time to upgrade his lambdabots
18:01:05 <kpreid> jcreigh: no, if the input contains explicit operators
18:01:22 <SamB> kpreid: probably @pl should be fixed to parse dos and list comprehensions first
18:01:47 <kpreid> SamB: Excellent plan! I'll just wait 'till it's done then.
18:02:00 <SamB> well, you can keep waiting then
18:02:30 <lispy> SamB: funny, but today it seems we're all trying to volunteer you for your ideas :)
18:03:08 <kpreid> hey, I just thought of how to fix @unpl's fresh name generation while keeping its basic strategy
18:03:23 <kpreid> an input pass which renames prefixwise all the non-fresh names
18:03:31 <dons> yep
18:03:37 <dons> kpreid: the @free plugins do this
18:03:40 <lispy> dons: Modules.hs is not optimized for darcs :)
18:03:43 <kpreid> then they're distinct, so *after* the unpl-ing you can rename them to nice consecutive stuff
18:04:01 <dons> kpreid: look up -- Rename monad, and pretty alpha renamer
18:04:10 <dons> in the Plugin/Free/Freetheorem.hs file
18:04:16 <dons> you might even be able to steal it directly
18:04:34 <dons> in the free plugin, we do a rename pass after all the code generation, to give nice names
18:04:38 <dons> ?free foldl
18:04:39 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
18:04:53 * kpreid puts this in his todo file
18:05:14 <dons> note that functions are f ,h , g. vars are x and y
18:05:37 <SamB> hmm, this plugin needs to be fixed so it works on plain functions...
18:05:59 <sjanssen> kpreid: do you  use anything with operator precedences in pointful?
18:06:17 <dons> here's the naming conventions:
18:06:18 <dons>         suggestionsVal = map (:[]) "xyzuvabcstdeilmnorw"
18:06:19 <dons>                             ++ [ 'x' : show i | i <- [1..] ]
18:06:19 <dons>         suggestionsList = map (:"s") "xyzuvabcstdeilmnorw"
18:06:19 <dons>                             ++ [ "xs" ++ show i | i <- [1..] ]
18:06:20 <kpreid> sjanssen: it's broken wrt that
18:06:21 <dons>         suggestionsFun = map (:[]) "fghkpq"
18:06:24 <dons>                             ++ [ 'f' : show i | i <- [1..] ]
18:06:42 <sjanssen> kpreid: same with undo.  One of use should fix that ;)
18:06:52 <kpreid> well
18:07:02 <kpreid> unpl will not *generate* code with wrong precedence
18:07:18 <kpreid> it will however assume that everything is left-associative with equal precedence
18:07:25 <sjanssen> right
18:07:27 <kpreid> (see Language.Haskell.Syntax's documentation)
18:08:11 <kpreid> @unpl 1:2:[]
18:08:11 <lambdabot> 1 : 2 : []
18:08:26 <kpreid> @unpl 1:(2:[])
18:08:26 <lambdabot> 1 : (2 : [])
18:08:29 <kpreid> (curiosity)
18:10:25 <lispy> hmm...trying a clean build, but i think lambdabot is no longer build happy on my computer
18:13:18 <mgsloan> Non-exhaustive pattern errors are runtime, right (I've never actually compiled a haskell program, heh)
18:13:40 <lispy> right
18:13:56 <lispy> > let f Nothing = 1 in f (Just 1)
18:13:57 <lambdabot>  Non-exhaustive patterns in function f
18:13:59 <mgsloan> some static checking could probably be done though
18:14:14 <lispy> > let f Nothing = 1 in f Nothing
18:14:15 <lambdabot>  1
18:14:37 <mgsloan> lispy - yeah, i've been using ghci, so in some ways runtime/compile time errors are blurred
18:14:55 <lispy> if you compile with -Wall it will complain if it thinks there are possible patterns which a function doesn't cehck for
18:14:57 <CosmicRay> so is the general consensus that my MissingH plan is sane?
18:15:27 <Cale> I think the exact flag is -fwarn-incomplete-patterns
18:15:45 <lispy> CosmicRay: i haven't looked over the plan in detail myself (I trust the cafe) but the idea i saw originally seemed like a good direction
18:16:13 <dons> mgsloan: they can be found statically with -Wall
18:16:15 <Excedrin> HCAR has a lot of cool stuff
18:16:15 <CosmicRay> lispy: https://software.complete.org/missingh/wiki/TransitionPlanning if you want to see it
18:16:16 <dons> (try compiling!)
18:16:17 <lambdabot> http://tinyurl.com/y27sku
18:16:29 <mgsloan> dons - heh ok, cool
18:16:37 <CosmicRay> basically there were a few people that made some small suggestions, but nobody really said "good plan" or "you suck"
18:16:52 <lispy> dons: what happened to L.o and L.hi?
18:16:54 <CosmicRay> I'd rather have some informative "you suck"s than nothing ;-)
18:16:57 <dons> mgsloan: like this:
18:16:58 <dons> A.hs:1:0:
18:16:59 <dons>     Warning: Pattern match(es) are non-exhaustive
18:16:59 <dons>              In the definition of `f': Patterns not matched: []
18:17:04 <dons> lispy: mm?
18:17:33 <lispy> hrm...
18:17:39 <lispy> actually, it's a permission error
18:17:40 <dons> ?hoogle (+++)
18:17:41 <lambdabot> Did you mean: (+++)
18:17:41 <lambdabot> Prelude.undefined :: a
18:17:41 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
18:17:47 <dons> ?hoogle +++
18:17:48 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
18:17:48 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
18:17:48 <lambdabot> Text.ParserCombinators.ReadP.(+++) :: ReadP a -> ReadP a -> ReadP a
18:17:55 <dons> ?hoogle+
18:17:55 <lambdabot> Text.ParserCombinators.ReadPrec.(+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
18:18:00 <mgsloan> oh, so it just warns.  I suppose that's good because then you can write versions which give descriptive errors of what caused the match fall through
18:18:15 <dons> if you give it -Werror, you'll fail statically
18:19:10 <mgsloan> hmm, so is it warning about a function call which will/will likely fall through its matches, or that you haven't extensively defined the function?
18:21:26 <dons> that you haven't defined cases for all variants a data type supports
18:21:50 <dons> you'd need HPC or one of the other tools, like ndm's check, to check when partial definitoins are actually safe
18:23:29 <mgsloan> oh ok, cool
18:24:40 <dons> sjanssen++ patches
18:25:34 <Nafai> I think I'm starting to get Haskell basics
18:25:50 <dons> cool!
18:26:47 <Nafai> Now I just need to start writing more than simple functions with it :)
18:27:11 <dons> ok, do you have a problem you want to solve?
18:27:40 <dons> why not try to write some of the simple unix tools, like wc or sort or tac
18:28:24 <Nafai> That's a good idea...
18:28:41 <lispy> ?where h4sh --:)
18:28:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
18:28:48 <dons> (hint: they're one liners in the end, but getting there will be a good exercise)
18:29:51 <mgsloan> lispy - ooh, nice
18:29:56 <Nafai> That's awesome
18:31:09 <lispy> don't thank me, thank dons :)
18:33:10 * SamB thinks there ought to be a command called
18:33:12 <SamB> um
18:33:19 <SamB> @moderatelypl
18:33:20 <lambdabot> Unknown command, try @list
18:33:22 <SamB> or something
18:33:54 <lispy> SamB: common lisp has a problem like this...sometimes you want to apply a macro but you only want to apply it a little bit
18:34:30 <lispy> SamB: in their case they use a special macro expander that stops after expanding one macro
18:35:00 <lispy> SamB: maybe you could apply that here, once a point free reduction fires it just stops
18:35:14 <SamB> lispy: no
18:35:19 <lispy> no?
18:35:23 <SamB> I'd just want it to do the less ugly thing
18:37:20 <Cale> http://www.logarithmic.net/pfh-files/random/noyoucanthaveaneuralnetwork.jpg -- haha
18:37:23 <lambdabot> http://tinyurl.com/trvan
18:38:12 <johnnowak> Cale: :)
18:39:19 <Cale> I got that from a comment from this article here http://thedailywtf.com/forums/thread/104727.aspx which is a rather cute story.
18:39:22 <lambdabot> http://tinyurl.com/vtdwf
18:39:22 <lispy> CosmicRay: please keep that transition document around, it's going to be handy to people in the future :)
18:40:10 <SamB> anyway, I was saying that looking at the output of *@unpl*, not of @pl
18:42:10 <SamB> @. redo unpl ((!!) .) . flip (iterate . (=<<) . ap (foldr const . return) . flip ((map snd .) . filter . (. fst) . (==)))
18:42:11 <lambdabot> (\ m au -> (!!) (iterate (\ y -> do { b <- y; (do { aa <- (\ ah -> foldr (\ e _ -> e) (return ah)); z <- (\ h -> map snd (filter (\ ba -> h == (fst ba)) au)); return (aa z)}) b}) m))
18:42:54 <SamB> @pretty f = (\ m au -> (!!) (iterate (\ y -> do { b <- y; (do { aa <- (\ ah -> foldr (\ e _ -> e) (return ah)); z <- (\ h -> map snd (filter (\ ba -> h == (fst ba)) au)); return (aa z)}) b}) m))
18:42:55 <lambdabot>  f = (\ m au ->
18:42:56 <lambdabot>     (!!)
18:42:56 <lambdabot>      (iterate
18:42:56 <lambdabot>        (\ y ->
18:42:56 <lambdabot>         do b <- y
18:42:57 <lambdabot>           (do aa <- (\ ah -> foldr (\ e _ -> e) (return ah))
18:42:59 <lambdabot>             z <- (\ h -> map snd (filter (\ ba -> h == (fst ba)) au))
18:43:01 <lambdabot>             return (aa z))
18:43:03 <lambdabot>            b)
18:43:05 <lambdabot>        m))
18:43:07 <SamB> hmm. that ain't very pretty!
18:47:20 <lispy> your beholder just has a bad eye
18:50:03 <dons> any opinions on the new sequence theme?  http://sequence.complete.org/
18:50:05 <lambdabot> Title: The Haskell Sequence | News about Haskell
18:56:25 <lispy> dons: isn't the middle column more squished now?
18:57:18 <dons> mmm. maybe a little?
18:57:23 <dons> the column on the right seems a bit wider
18:57:31 <dons> i wonder if i can tweak that
18:57:46 <dons> its a lot calmer on the eye now, anyway
18:58:05 <lispy> yeah, the colors are nice
18:59:11 <lispy> ?quote thetallguy
18:59:25 <lispy> lambdabot: hop to!
18:59:50 <chessguy> @yow
18:59:50 <SimonRC> @pl \a b c d -> a b (c d)
19:00:15 <SimonRC> hmm, I think I killed it with my privmsg
19:00:25 <SimonRC> I gave it:  @pl \a:b:c:d:e:z->e:d:c:b:a:z
19:00:43 <SimonRC> Oops, I mean:   @pl \a:b:c:d:e:f:z->f:e:d:c:b:a:z
19:00:46 <dons> mmm. should survive that though
19:01:00 <dons> yeah, its churning way on something
19:01:18 <SimonRC> well the former causes it to spit out several lines, mostly consisting of dots and brackets.
19:01:52 <dons> oh, the suspend @pl stuff isn't kicking in?
19:01:52 <SimonRC> typial extract: ". (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip tail"
19:02:02 <lambdabot>  Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
19:02:04 <SimonRC> it has just said...
19:02:19 <SimonRC> ... a long expression
19:02:21 <lambdabot> I'm having BEAUTIFUL THOUGHTS about the INSIPID WIVES of smug and
19:02:23 <lambdabot> wealthy CORPORATE LAWYERS ...
19:02:47 <hyrax42> is lambdabot cathing up some past commands?
19:02:55 <SimonRC> maybe telling it @pl-resume 5 times in a row was a bit much.
19:02:58 <SimonRC> I think so
19:02:59 <lambdabot> ((.) .)
19:02:59 <dons> it will, once people stop DoSing it
19:03:04 <dons> SimonRC: ... :P
19:03:41 <dons> ok. looks done now
19:03:43 <dons> ?bot
19:03:43 <lambdabot> :)
19:03:47 <SimonRC> well I think ((.) .) = \a b c d -> a b (c d)  so it's a few minutes behind
19:03:52 <SimonRC> ?bot
19:03:53 <lambdabot> :)
19:03:56 <SimonRC> ah, good
19:03:59 <SimonRC> heh
19:04:08 <lispy> wadler: The way we can tell it's C# instead of Haskell is because it's nine lines instead of two.
19:04:21 <dons> lispy: so your screen looks something like http://www.cse.unsw.edu.au/~dons/tmp/screen.png
19:04:23 <lambdabot> http://tinyurl.com/y5wa26
19:04:24 <dons> ?
19:05:31 <SimonRC> lambdabot: what is that in reply to?
19:05:37 <SimonRC> erm, oops
19:05:42 <SimonRC> lispy: what is that in reply to?
19:05:50 <SimonRC> damned stupid tab-complete
19:05:53 <SimonRC> :-)
19:12:44 <lispy> sorry, afk for a sec...
19:13:06 <lispy> SimonRC: that thing i pasted is a funny quote from HWN so maybe dons knows the context
19:13:14 <lispy> dons: i'll just put up a screenshot of what i have on screen
19:13:23 <lispy> dons: assuming i can remember the key combo...
19:14:30 <dons> wader apparently said it a tthe recent FitA meeting
19:14:32 <dons> wadler
19:17:33 <lispy> dons: this is how i see it
19:17:34 <lispy> http://files.codersbase.com/tmp/hwn.png
19:17:48 <lispy> dons: probably the biggest difference is that my fonts are pretier
19:17:50 <lispy> prettier*
19:18:45 <dons> and your middle column is a lot narrower
19:19:06 <dons> compare them side by side
19:19:21 <lispy> oh you're riht
19:19:21 <dons> firefox on bsd, versus something on the mac?
19:19:30 <lispy> firefox on osx
19:19:39 <dons> yeah, you've got the anti alias fonts going on
19:20:12 <lispy> my browsing space is narrower
19:20:22 <lispy> when i widen the window it looks more like yours
19:20:36 <lispy> (I have a row of tabs on the right at all times)
19:20:54 <dons> ok. i'm pretty happy with that then.
19:21:12 <kfish> mmm, pretty
19:21:17 <lispy> galeon remains my favorite web browser but idon't want to have to run X just to use it on my mac so use a bunch of plugins to make ff behave close to galeon :)
19:21:35 <nornagon> @type \x y z -> (x,y:z:[])
19:21:37 <lambdabot> forall a a1. a -> a1 -> a1 -> (a, [a1])
19:21:43 <nornagon> hr
19:21:50 <nornagon> is there a meaning to a1 instead of b?
19:22:11 <nornagon> is that type === forall a b. a -> b -> b -> (a, [b]) ?
19:22:33 <dons> nornagon: alpha equivalence says you can repalce a1 with b in that expression, and have the same type
19:23:02 <nornagon> okay.
19:23:32 <nornagon> ghci complained when i did :t \x y z -> (x,y:z:[]) :: a -> b -> b -> (a,[b])
19:23:39 <nornagon> is that just a syntax issue?
19:24:07 <nornagon> oh, yes
19:24:12 <dons> ?type (\x y z -> (x,y:z:[])) :: a -> b -> b -> (a,[b])
19:24:13 <lambdabot> a -> b -> b -> (a,[b]) :: forall a b. a -> b -> b -> (a, [b])
19:24:14 <nornagon> more brackets fixed it
19:24:30 <nornagon> btw, where in australia are you, dons? :)
19:24:42 <dons> sydney
19:25:31 <dons> metaperl: we should syndicate your sequence blog to planet.haskell, do you want to ping ibid with the rss feed url?
19:25:36 <dons> ?where don
19:25:37 <lambdabot> I know nothing about don.
19:25:38 <dons> ?where dons
19:25:38 <lambdabot> http://www.cse.unsw.edu.au/~dons
19:25:41 <dons> ah hehe
19:25:43 <dons> someone added that
19:26:21 <nornagon> wow
19:26:27 <nornagon> i live in leichhardt
19:27:14 <dons> oh cool, i'm over the road in petersham
19:27:28 <nornagon> crazy
19:27:30 * dons waves from the top of crystal st :)
19:27:36 <nornagon> heh :)
19:27:45 <nornagon> i live on norton street, it's great
19:27:54 <dons> oh nice. in the forum?
19:27:56 <nornagon> 5 mins walk from Bar Italia
19:27:57 <dons> or up the other end
19:28:01 <nornagon> nah, down the other end
19:28:14 <dons> nice.
19:28:26 <dons> how'd you get into haskell?
19:28:32 <dons> you didn't get taught it at unsw, I guess?
19:28:45 <nornagon> no, i haven't finished high school yet
19:28:48 * kfish gets homesick with all this talk of the inner west :-(
19:28:52 <nornagon> kfish!
19:28:55 <dons> oh wow. nice nornagon
19:29:03 <nornagon> what are you doing in here. *wave*
19:29:08 <kfish> nornagon!
19:29:37 <kfish> printf debugging in the IO monad, with a big wooden hammer
19:29:49 <nornagon> heh.
19:29:49 <dons> kfish: you using printf? :)
19:30:11 <dons> Cale: did you write a TraceT for IO?
19:30:18 <kfish> dons, nah, but that's the name of the programming style
19:30:22 <dons> would be kind of useful.. maybe..
19:30:31 <Cale> TraceT?
19:30:32 <dons> kfish: yeah, I know. I was wondering if you really used printf, (not trace or such)
19:30:41 <dons> Cale: tracing monads, did you have one?
19:31:01 <dons> i'm just thinking of a TraceT that does some useful logging in each >> and >>=
19:31:04 <Cale> I can only assume not, since I'm not completely sure what that would be :)
19:31:06 <Cale> ah
19:31:12 <dons> so you could layer that over IO, and then get a log of what's what
19:31:26 <dons> now, whether you'd need some TH or such to get useful info. hmm.
19:31:39 <dons> you could keep a step count, i guess
19:31:52 <dons> and print threaded values
19:32:23 <Cale> you could annotate actions with names, and get a list of what's going on
19:32:25 <hyrax42> quick qesution re concurrency in haskell
19:32:33 <hyrax42> is it inspired by concurrent ML?
19:32:35 <dons> shoot
19:32:41 <dons> mmm. erlang moreso, I think
19:32:51 <dons> but really its from its own thread of haskell concurrency research going back to the 90s
19:32:54 <dons> 80s
19:33:03 <hyrax42> I have not read enough on concurrency in haskell unfortuantely
19:33:13 <dons> ?docs Control.Concurrent
19:33:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
19:33:17 <hyrax42> but a prof of mine was talking on CML today and some things were similar, others not
19:33:26 <Cale> @type Control.Concurrent.forkIO
19:33:28 <lambdabot> IO () -> IO GHC.Conc.ThreadId
19:33:43 <hyrax42> and all the while I was (internally) shaking my head over (unit -> unit) -> theradid types
19:33:44 <dons> as usual, haskell hackers tend to invent their own abstractions, like MVars
19:33:50 <kfish> nornagon, how goes the haskelling?
19:33:52 <dons> or STM
19:34:00 <hyrax42> STM seems very nice
19:34:17 <dons> hyrax42: for the long history of concurrency in haskell, http://haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency
19:34:20 <lambdabot> Title: Research papers/Parallelism and concurrency - HaskellWiki, http://tinyurl.com/t83sk
19:34:20 <Cale> Yeah, (unit -> unit) is actually an interesting type with many values in ML
19:34:43 <Cale> which is extremely counterintuitive the first time you see it if you're used to Haskell.
19:34:47 <hyrax42> at first glance at the types, I wondered why on earth you'd want unit -> unit
19:35:14 <hyrax42> until I realised it was really IO ()
19:35:21 <hyrax42> or used as
19:35:22 <nornagon> kfish: i'm just easing my way into it
19:35:23 <Cale> It's because a -> b in ML is more like a -> IO b in Haskell
19:35:43 <hyrax42> ?hoogle spawn
19:35:44 <lambdabot> No matches found
19:35:46 <kfish> nornagon, planning to go to unsw? ;-)
19:35:52 <nornagon> probably not :P
19:35:53 <hyrax42> ?hoogle IO () -> ThreadId
19:35:54 <lambdabot> No matches, try a more general search
19:35:59 <nornagon> more likely usyd
19:36:04 <kfish> nornagon, you lose
19:36:08 <nornagon> to do Design Comp
19:36:14 <kfish> eh?
19:36:17 <dons> Design Comp?
19:36:23 <nornagon> design computing
19:36:23 <nornagon> that is
19:36:26 <hyrax42> oh of course
19:36:28 <dons> usyd is for softies ;)
19:36:33 <hyrax42> ?hoogle IO () -> IO ThreadId
19:36:34 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
19:36:34 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
19:36:42 <nornagon> dons: quite :P
19:36:54 <Cale> aha, yeah, CML has MVars too.
19:36:55 <kfish> nornagon, that sounds nice. So, how much time do we have to beat some sense into you?
19:36:57 <nornagon> it sure has a prettier campus
19:37:03 <nornagon> kfish: a year
19:37:04 <nornagon> less
19:37:13 <dons> nornagon: you been to unsw recently? the new buildings are kinda stunning
19:37:22 <nornagon> dons: i have, they're pretty cool
19:37:28 <hyrax42> is forkIO the only way to spawn new threads?
19:37:32 <nornagon> dons: but usyd is still prettier :)
19:37:38 <dons> but seriously, you're doing hacking -- you won't be outside in the fresh air anyway, so who cares how old and rundown^h^h^h pretty the campus is ;)
19:37:39 <kfish> eh, it's a university, it's what's inside the buildings that counts
19:37:40 <hyrax42> Cale: and Chans
19:37:43 <nornagon> also less 'ten million hours away'.
19:38:01 <nornagon> by that i mean 'ten minutes' bike ride away'.
19:38:04 <hyrax42> just the event type has me slightly confused
19:38:10 <hyrax42> I will ask him next time I see him
19:38:16 <dons> nornagon: true. i guess you could sit on the 370 , i do.
19:38:21 <nornagon> yes
19:38:24 <dons> but its an hour or so, the long way
19:38:26 <nornagon> but that takes like 90 minutes
19:38:27 <hyrax42> or look up Essence of Concurrent ML
19:38:40 <nornagon> better to go to the city on the 440 and catch the express
19:38:43 <nornagon> man
19:38:43 <dons> yeah
19:38:48 <kfish> nornagon, the difference between unsw and usyd grads is noticeable. I've done hiring in sydney. Go to unsw, study haskell.
19:38:49 <nornagon> i've probably seen you before O.o
19:39:04 <nornagon> kfish: heh
19:39:11 <dons> nornagon: you'll at least want to look through the kind of courses you'll be taught, and who the teachers are (and what they do)
19:39:16 <kfish> nornagon, just some kindly advice :-)
19:39:25 <nornagon> design comp is good because it's a really new course
19:39:25 <hyrax42> threads in haskell are gc'ed right, no need to explicitly kill them?
19:39:27 <Korollary> screw all that. Go where the hot ladies are.
19:39:36 <dons> also, you'll not get any haskelll at usyd (iirc), nor write your own kernel
19:39:38 <nornagon> Korollary: usyd, totally
19:39:39 <nornagon> :P
19:39:52 <nornagon> dons: those do sound like a lot of fun
19:39:54 <dons> hyrax42: they end when then return
19:40:01 <kfish> Korollary, yeah, that's why i'm doing my phd in japan ;-)
19:40:09 <nornagon> but w/e, i'm a ruby guy too
19:40:14 <hyrax42> and are fodder for gc in its next sweep?
19:40:23 <dons> nornagon: be wary of new flashy courses that are just fads though ...
19:40:31 <lispy> kfish: you bastard :)
19:40:39 <kfish> lispy, heh
19:40:45 <nornagon> dons: i've got some friends doing this course, and i hear a lot of good things about it from them
19:40:58 <dons> nornagon: if you go to unsw, i get to tutor you in types and prog langs, too... :)
19:40:59 <nornagon> it's stuff like 3d animation, web programming, virtual worlds, ...
19:40:59 <Cale> hyrax42: the newer concurrency stuff in Haskell isn't based on this though -- have you read the STM paper?
19:41:17 <nornagon> dons: by that time i'll've already mastered haskell ;P
19:41:19 <hyrax42> cale: I have not read it, but I have watched the video
19:41:29 <hyrax42> and have a rough idea of how STM works
19:41:45 <nornagon> I wouldn't mind doing comp eng at unsw
19:41:52 <dons> nornagon: if you master haskell, web programming might seem kind of boring :)
19:41:56 <Cale> It's really quite a cool idea.
19:41:58 <hyrax42> cale: so would you say that MVar, Chan are "deprecated"?
19:42:07 <dons> hyrax42: *almost*
19:42:10 <dons> they're the old gen.
19:42:13 <greentea> Do any of the unis here in Melbourne have a Haskell orientation?
19:42:14 <nornagon> dons: nah, i'll do them with continuations and statically typed html
19:42:16 <hyrax42> and one should use TChan, TVar instead?
19:42:21 <dons> so not deprecated yet -- they'll likely be standardised for H'
19:42:24 <dons> but STM is the future
19:42:25 <nornagon> dons: and generate html out of valid haskell code
19:42:27 <Cale> They're en route to being deprecated.
19:42:35 <dons> nornagon: good :)
19:42:35 <hyrax42> dons: kk
19:42:55 <nornagon> although i hear erlang does a mighty fine job of serving web pages
19:43:09 <hyrax42> I think one of my holiday projects will be STM
19:43:37 <nornagon> André Pang did a talk on Erlang at slug a while back, had some pretty graphs of scaling of apache v. some erlang server
19:44:14 <dons> yeah, its nice.
19:44:22 <dons> ozone's a good hacker too
19:44:27 <dons> he wrote the obj-C binding for haskell
19:44:31 <nornagon> :)
19:44:37 <hyrax42> HOC?
19:44:45 <dons> yup, /Mocha
19:44:47 <nornagon> Can we bind C++ straight to haskell yet?
19:44:55 <nornagon> or do we need to write a C wrapper?
19:44:57 <hyrax42> hm
19:45:01 <dons> via C still, iirc
19:45:08 <nornagon> bummer :)
19:45:18 <nornagon> Haskell/Qt4 would be useful.
19:45:46 <dgriffi3> motif all the way
19:46:20 <dons> lesstif!
19:51:50 <Cale> If you know how the C++ name mangling for your C++ compiler works, then you can mangle the imports yourself, and it'll work, but that's probably not a good idea for portability.
19:52:20 * lispy pshaw's at portability :)
19:52:28 <Cale> I've also succeeded in FFI importing fortran code.
19:52:34 <dons> Cale: oh yeah?
19:52:37 <dons> that's stunning.
19:52:42 <dons> Cale: ever written that up?
19:52:42 <lispy> Cale: what did you need that for?
19:52:48 <Cale> I didn't need it
19:53:02 <Cale> Someone asked whether you could import fortran code, so I tried it and it worked.
19:53:07 * dons wishes Cale had a proper blog...
19:53:17 <lispy> yeah, is this on the cale wiki?
19:53:23 <Cale> hehe, no :)
19:53:38 <lispy> oh so we have 100 fold diagrams but no love for the fortran ffi ;)
19:54:08 <eviltwin_b> I thought they standardized name mangling in some recent C++ revision
19:54:36 <Cale> Well, the only application I could think of for FFI-importing Fortran code is to import those linear algebra libraries, and then there'd be nothing left to do ;)
19:55:27 <Nafai> How do you get the equivalent to c's argv in Haskell?
19:55:37 <dons> getArgs
19:55:44 <lispy> ?type getArgs
19:55:45 <lambdabot> Not in scope: `getArgs'
19:55:51 <lispy> ?hoogle getArgs
19:55:51 <lambdabot> System.getArgs :: IO [String]
19:55:54 <dons> > do s <- getArgs ; mapM_ print s
19:55:56 <lambdabot>  Not in scope: `getArgs'
19:56:02 <lispy> Nafai: you'll need to import System
19:56:07 <dons> ?type do s <- System.Environment.getArgs ; mapM_ print s
19:56:08 <Nafai> lispy: Thanks
19:56:09 <lambdabot> IO ()
19:56:13 <Cale> @type System.Environment.getArgs
19:56:15 <lambdabot> IO [String]
19:56:15 <dons> ?hoogle args
19:56:15 <lambdabot> Distribution.Simple.Args :: type Args
19:56:16 <lambdabot> System.getArgs :: IO [String]
19:56:16 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
19:56:34 <dons> use the hoogle, luke^h^h Nafai
19:56:47 <lispy> hoogle makes a good friend
19:56:55 <Nafai> Okay :)
19:57:29 <Cale> http://www.dieselsweeties.com/ -- haha, awesome
19:57:31 <lambdabot> Title: diesel sweeties: pixelated robot romance web comic & t-shirt party
19:58:41 <lispy> funny, but it should be pac-man topology :)
19:59:00 <Cale> yeah
19:59:34 <Cale> I suppose it's also a form of physics if you're applying it like that.
20:02:15 <dons> mmm. i should rewrite linkchecker in haskell, those python threads suck
20:03:40 <Korollary> no, you should port hsplugins to 6.6
20:03:55 <dons> ah yes
20:03:57 <dons> good idea
20:04:12 * lispy nods at Korollary 
20:04:23 <dons> Lemmih: what's the state of the 6.6 port? do you have any darcs patches for me yet?
20:05:54 <dgriffi3> dons: what do you want a haskell linkchecker for?
20:06:11 <dons> I use it as part of the weekly news preparation process
20:06:36 <dgriffi3> ahh
20:06:42 <dons> i.e. so that sequence.complete.org works :)
20:09:14 <dons> would be a nice little demo of STM and smp concurrency, I think
20:12:45 <lisppaste2> Nafai pasted "Having problems with my if..." at http://paste.lisp.org/display/31193
20:13:01 <Nafai> Could someone look at that and help me out?
20:13:17 <Nafai> I'm trying to call hGetContents with the appropriate handle
20:13:41 <wolverian> Nafai, the then and else branches need to be indented deeper than the if.
20:15:26 <Nafai> That still doesn't work
20:16:09 <Korollary> the indentation is right
20:16:30 <Korollary> they should be indented more than the m in my_lines, and they are.
20:17:14 <Korollary> @type hGetContents
20:17:16 <lambdabot> Not in scope: `hGetContents'
20:17:27 <Korollary> @index hGetContents
20:17:28 <lambdabot> System.IO
20:17:34 <Korollary> @type System.IO.hGetContents
20:17:36 <lambdabot> GHC.IOBase.Handle -> IO String
20:18:00 <Korollary> stdin is already a handle. return stdin is wrong.
20:19:01 <Korollary> @type return stdin
20:19:03 <lambdabot> Not in scope: `stdin'
20:19:09 <Korollary> @type return System.IO.stdin
20:19:11 <lambdabot> forall (m :: * -> *). (Monad m) => m GHC.IOBase.Handle
20:19:31 <lispy> ?pl (\ x -> not (x == "-"))
20:19:31 <lambdabot> ("-" /=)
20:20:47 <lispy> also, length newArgs > 0 is wasteful
20:20:56 <lispy> if not (null newArgs)
20:21:01 <lispy> that's really what you want
20:21:04 <mwc> is there a term for a list operation that works sort of like a fold, but pair-wise? for instance, foo f [x1,x2,x3,x4,x5,x6...] = [f x1 x2, f x2 x3, f x3 x 4, ...]
20:21:49 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) -- does this give you an idea mwc?
20:21:50 <lambdabot>  Parse error
20:22:02 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs -- does this give you an idea mwc?
20:22:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:22:05 <Korollary> mwc: I don't know of a term
20:22:06 <mwc> lispy, I've seen it there, and I'm using it for distance computations
20:22:22 <mwc> so it seems so ubiquitous there ought to be name for it
20:22:30 <mwc> For christ's sake, we have intercalate...
20:22:43 <lispy> it's called zipWith :)
20:22:45 <Korollary> You can give it one. We could call it "mwc'ing the living daylights out of a list"
20:23:04 <mwc> Ooh, ooh. Let's call it a Cox transform
20:23:13 <mwc> that'll settle my long rivalry with Laplace, Hankel, and Z :)
20:23:18 <lispy> > (\f xs -> zipWith f xs (tail xs)) [1..10]
20:23:19 <lambdabot>  Couldn't match `a -> a -> c' against `[a1]'
20:23:23 <lispy> > (\f xs -> zipWith f xs (tail xs)) (+) [1..10]
20:23:25 <lambdabot>  [3,5,7,9,11,13,15,17,19]
20:23:37 <Korollary> It's not zipping. It's a map with arity=2, sort of.
20:24:35 <Korollary> I wonder what it would look like in terms of bananas and lenses.
20:24:57 <CosmicRay> mwc: intercalate, eh?  There is still something that rubs me the wrong way about Haskell having a function named "isInfixOf" where Python's function for the same thing is called "contains" ;-)
20:25:01 <dons> ?paste
20:25:01 <lambdabot> http://paste.lisp.org/new/haskell
20:25:28 <lispy> is the function i gave not correcty?
20:25:35 <lisppaste2> dons pasted "Nafai" at http://paste.lisp.org/display/31194
20:25:37 <dons> Nafai: ^
20:25:58 <mwc> Korollary, maybe we should call it an n-th order serial map?
20:26:07 <mwc> Needs some greek terms though
20:26:26 <mwc> @type isInfixOf
20:26:27 <lambdabot> Not in scope: `isInfixOf'
20:26:30 <Cale> CosmicRay: Hey, it's better than isContiguousSublistOf
20:26:57 <CosmicRay> Cale: well, I actually know what that one does.  otoh it does sound like a Java name.
20:27:11 <mwc> CosmicRay, to me, contains means it could be anywhere, but isInfixOf means that it couldn't start with the first element or end with the last
20:27:16 <mwc> ie, there must be a prefix and a postfix
20:27:43 <CosmicRay> mwc: ah, so the name is even misleading.
20:27:45 <Cale> I always love the names of functions in GAP: IsEmbeddingImprimitiveWreathProductPermGroup
20:27:54 <CosmicRay> oh geez
20:28:00 <CosmicRay> now THAT sounds like java.
20:28:12 <Cale> IsSubsetInducedNumeratorModuloTailPcgsRep
20:28:27 <CosmicRay> Java is the only language I've ever learned where writing to the console is trivial but reading from the keyboard requires two lines of obscure code.
20:28:28 <lispy> don't the identifiers in java add to the space complexity?
20:28:28 <Korollary> it's not java without cascaded calls.
20:28:33 <Cale> I assume someone knows what these things mean
20:28:57 <lispy> CosmicRay: it takes me something like 20 lines to execute a process in java
20:29:26 <lispy> CosmicRay: and most of that is just creating the buffered readers/writers to do IO with the subprocess
20:29:26 <CosmicRay> lispy: that's about how much code it took me to implement an enhanced version of pOpen3 in Haskell.
20:29:39 <CosmicRay> oh god.  I HATE THAT about java.
20:30:37 <Nafai> dons: Thanks, now to figure out what it is :)
20:30:42 <lispy> the process object has methods like, getPainfullyLowLevelObjectWhichWillOnlyBeUsefulForOnePercentOfClients();
20:30:51 <CosmicRay> I have a relative that teaches CS classes at a local liberal arts college.  He knew that I had programmed in Java.  He told me that a student asked him how to read from the keyboard in Java, and he couldn't figure it out
20:30:52 <CosmicRay> haha
20:31:04 <CosmicRay> and thought I might be able to point him at something simple.
20:31:11 <CosmicRay> he was surprised when I started laughing
20:31:27 <lispy> lol
20:31:42 <CosmicRay> I pointed out to him that I had spent literally hours trying to figure out the same thing, but I probably had saved off the answer somewhere ;-)
20:32:36 <CosmicRay> this is a very sharp guy, too.  he's fluent in most languages since smalltalk, so it's not like he was just a goof.
20:32:48 <Korollary> You're not supposed to be doing IO with non-enterprise approved channels.
20:32:52 <CosmicRay> hahaha
20:33:24 <CosmicRay> I wished I could just cast fscking stdin to Object and cast it back out to the right thing later ;-)
20:33:34 <lispy> yeah, i think part of what makes my program more complicated in Java is that I want to use plain text instead of XML
20:33:55 <CosmicRay> lispy: that has got to be the most damning statement about java I've heard yet.
20:34:14 <Nafai> dons: Could you explain the args <- ... line to me?  I'm still trying to figure out Monads :)
20:34:23 <Korollary> It's GPL now. So it's ok.
20:34:24 <dons> http://programming.reddit.com/info/tawg/comments boo (someone should mod this;)
20:34:27 <lambdabot> Title: Deobfuscation is NP-easy [pdf] (reddit.com), http://tinyurl.com/tkgtq
20:34:45 <CosmicRay> Korollary: that just means that everyone can be half as productive with it now ;-)
20:34:57 <dons> Nafai: so:  do args <- getArgs >>= return . filter (/= "-") ; return args
20:35:13 <dons> is the same as: do args <- getArgs ; let args' = filter (/= "-") args
20:35:19 <dons> ?undo do args <- getArgs >>= return . filter (/= "-") ; return args
20:35:19 <lambdabot> getArgs >>= return . filter (/= "-") >>= \ args -> return args
20:35:25 <dons> ?. pl  undo do args <- getArgs >>= return . filter (/= "-") ; return args
20:35:26 <lambdabot> compose module failed: IRCRaised Parse error: ""
20:35:28 <Korollary> CosmicRay: I think people are going to fork it till they can run rails on it.
20:35:30 <dons> ?. pl undo do args <- getArgs >>= return . filter (/= "-") ; return args
20:35:31 <lambdabot> filter ("-" /=) `fmap` getArgs
20:35:37 <dons> even shorter, but more obscure
20:35:39 <CosmicRay> do y'all remember Megamonad, the AI bot that I had in here over the holidays 2 years ago?  my favorite Java quote was from that bot: "To me, Java is a monomorphic type."
20:35:44 <CosmicRay> Korollary: haha
20:35:52 <lispy> CosmicRay: lol
20:36:07 <CosmicRay> http://www.haskell.org/hawiki/MegaMonad
20:36:12 <lambdabot> Title: MegaMonad - The Haskell Wiki
20:36:21 <lispy> CosmicRay: was it just a wrapper around megahal or did you actually implement a native to haskell megahal?
20:36:31 <CosmicRay> just a wrapper around megahal
20:36:42 <CosmicRay> I pulled down logs from this channel and trained megahal from them
20:36:45 <lispy> CosmicRay: i ask because, i want a megahal module for lambdabot, but my only implementation was in lisp as a wrapper too :)
20:37:05 <CosmicRay> the result was hilarious with a ton of lowercase comments.  also I realized that megahal doesn't scale.
20:37:06 <dons> yeah, me too.
20:37:08 <lispy> i started translating the C code for megahal but it's hellish C :)
20:37:13 <dons> please, I have 400M of #haskell logs to feed in
20:37:26 <CosmicRay> megahal crashes when its brain reaches 512MB.
20:37:36 <lispy> most function's have local data that it static
20:37:43 <CosmicRay> heh
20:37:51 <lispy> i'm not kidding!
20:37:55 <CosmicRay> I believe you
20:37:57 <hyrax42> woah, haskell.org main page changed?
20:38:05 <CosmicRay> User:    are you evil?
20:38:05 <CosmicRay> MegaHAL: I seem to get into it if using jakarta collections
20:38:06 <lispy> if i actually understood it, or had the right abstractions in Haskell it would be a 3 line bot though
20:38:10 <dons> hyrax42: just a little
20:38:21 <dons> to make it more obvious how to contribute
20:38:23 <hyrax42> I preferred the serif font
20:38:40 <lispy> if i had those bi-directional HMM it wouldn't take long to code up
20:39:05 <hyrax42> dons: contribute to haskell or to the wiki
20:39:08 <newsham> hi
20:39:10 * lispy tries to restist the urge to work on megahal again
20:39:15 <dons> hyrax42: both! :)
20:39:29 <CosmicRay> lispy: visit http://www.haskell.org/hawiki/MegaMonad and all will be clear
20:39:29 <lambdabot> Title: MegaMonad - The Haskell Wiki
20:39:46 * lispy goes off in search of the closet in his house where time stands still
20:40:17 <CosmicRay> dammit, I want one!
20:40:27 <newsham> talk to lispy's dealer
20:40:34 <lispy> "dealer"
20:40:44 <lispy> i need a hair cut...
20:40:48 * lispy is off
20:41:09 <mwc> @hoogle isInfixOf
20:41:10 <lambdabot> No matches found
20:41:25 <Korollary> @index isInfixOf
20:41:26 <lambdabot> bzzt
20:41:31 <CosmicRay> MegaHAL: haskell programming is kind of stimulant drug or something?
20:41:53 <CosmicRay> MegaHAL: Ok, rebooting to install several of the life of the universe.
20:41:55 <CosmicRay> ah.
20:45:48 <mwc> CosmicRay, certainly stimulates me...
20:46:15 * mwc grinds away on a C++ project that could be solved by zipWith foo list (tail $ cycle list)
20:46:45 <Korollary> never heard of a 50-line C++ "project" before.
20:47:04 <mwc> project as in "this is what I have to get done tonight
20:47:23 * johnnowak is working on his 30 line doctoral thesis
20:47:30 <Korollary> it's friday. You should be partying and catching std's.
20:48:11 * lispy loves the simplicity with which Korollary summarizes dating
20:48:11 <CosmicRay> Korollary: the fact that you're in irc implies that you are doing neither at the moment ;-)
20:48:40 <Korollary> CosmicRay: I didn't say I should be partying. I said he should be.
20:48:45 <CosmicRay> heh
20:49:57 <CosmicRay> this is ironic.  just as you said that, Nightline (a TV news show) just started a story about STDs spreading among seniors.
20:50:11 <Korollary> viagra++
20:50:21 <Korollary> cialis++
20:50:35 <Korollary> that's awesome.
20:51:05 <Korollary> those reckless seniors
20:51:57 <mwc> Korollary, end of term
20:52:11 <mwc> I have a scientific programming project that I present on wednesday
20:52:18 <lispy> speaking of viagra and cailis, some bot just tried to comment on my blog
20:52:20 <mwc> he moved the date ahead two weeks last week
20:52:29 <Korollary> mwc: Enough with this responsible student cliches.
20:52:47 <mwc> Korollary, fuck you, I want to get into a masters program :)
20:52:59 <Korollary> mwc: That's what I am talking about!
20:53:21 <Korollary> expletives++
21:00:51 <Niarium> weird... is divMod and quotRem identical?
21:02:43 <Niarium> ...and div == quot, mod == rem?
21:03:38 <mgsloan> > (rem -6 4, mod -6 4)
21:03:40 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> a))
21:04:09 <mgsloan> > rem -6 4
21:04:11 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> a))
21:04:11 <lispy> Niarium: no
21:04:28 <lispy> ?type divMod
21:04:29 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:04:32 <lispy> ?type quotRem
21:04:33 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:05:13 <mgsloan> > divMod -6 4
21:05:14 <lambdabot>  add an instance declaration for (Num (t -> a -> a -> (a, a)))
21:05:19 <lispy> > (-6 `divMod` 4, -6 `quotRem` 4)
21:05:20 <lambdabot>  add an instance declaration for (Num (a, a))
21:05:20 <lambdabot>   In the definition of `bor'...
21:05:25 <mgsloan> bah, i hate interactive interpreters
21:05:28 <lispy> > ((-6) `divMod` 4, (-6) `quotRem` 4)
21:05:30 <lambdabot>  ((-2,2),(-1,-2))
21:05:30 <Niarium> mgsloan, put () on -6
21:05:34 <mgsloan> oh, yeah
21:05:46 <mgsloan> I've made that mistake way too many times
21:05:54 <lispy> yeah :(
21:06:25 <Niarium> so they are same for positive numbers, but works differently on negative numbers
21:06:26 <Niarium> i see
21:06:28 <Niarium> thanks
21:06:36 <lispy> mgsloan: i didn't want to bring it up, but you're fired due to too many mistakes with negative numbers in haskell :(
21:06:44 <mgsloan> ;P
21:07:18 <mgsloan> I blame whichever haskell implementation lambdabot uses for not giving good error messages
21:07:31 <lispy> ghc
21:07:46 <mgsloan> yeah, should probably use helium or something...
21:08:26 <Niarium> i see way too many messages that suggests me to add an instance for blah blah blah
21:08:55 <Niarium> i think that's probably why helium does not support the type classes yet
21:08:56 <mgsloan> right, which would be rediculous in the interactive interpreter - you can't even add instances, they're declerations
21:11:00 <Niarium> not only the type classes, but haskell itself seems not appropriate for interactive environment
21:11:50 <mgsloan> yeah, some bits of it are tricky.  GHC gets around this by just having you do expressions, which makes it fairly pointless
21:12:09 <Niarium> say, i type an expression, and the computer answers, and i type something again, this is how the imperative ones work
21:12:10 <mgsloan> well, not pointless, but debilitating
21:12:41 <dons> Niarium: you can type in *expressions*
21:13:05 <dons> just not new types or instances, since that would affect the type and shape of all your previous decls
21:13:13 <dons> leading to incoherency
21:13:28 <mgsloan> there's also probs with data statements
21:13:41 <mgsloan> least, i haven't been able to decl new data
21:13:50 <dons> exactly. what does: data T = T Int ; let x = T 7 ; data T = T Bool ; x  -- do?
21:13:52 <Niarium> thats what dons said, with 'new types', i think
21:14:18 <dons> haskell isn't evaluated top-to-bottom, so trying to make it work that way just breaks things.
21:14:28 <mgsloan> dons - oh, i guess I want to sort of set up an environment to mess around with, not copy the env every line i do
21:15:15 <dons> even worse: data T = T Int ; let x = T 7 ; data T = T Bool ; case T x of True -> 1 ; False -> 2 -- yikes
21:15:23 <mgsloan> so, basically i just use it to start off the programs i write in files, and to inadvertently spam the channel with type/parse errors
21:16:04 <newsham> dons: what is the path to find your tutorial on writing haskell programs (cabal, quickcheck, etc.) on the wiki?
21:16:23 <mgsloan> ?where writing_a_haskell_program
21:16:24 <lambdabot> I know nothing about writing_a_haskell_program.
21:16:26 <Niarium> i often use ghci, and it is convenient, but i really hate those error messages of it
21:16:26 <mgsloan> bah
21:16:30 <dons> ?google How to write a haskell program
21:16:33 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
21:16:33 <lambdabot> Title: How to write a Haskell program - HaskellWiki
21:16:43 <newsham> dons: where is it linked in from?  i didnt see it on the tutorials page
21:17:03 <dons> its linked from the libraries page,but could be added to the tutorials category too. i'll do that now
21:17:28 <newsham> xiexie
21:17:29 <Niarium> when error occurs, i don't even take a glance on it, just make sure 'there is an error', and read my code again, not the message
21:17:33 <dons> oh, it is already in ttp://haskell.org/haskellwiki/Category:Tutorials
21:17:48 <dons> Niarium: you should check the given line number in the msg though...
21:17:57 <newsham> its not in http://www.haskell.org/haskellwiki/Books_and_tutorials which is the tutorial page linked from the front page
21:17:57 <Niarium> dons, that's true
21:17:59 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y4f3er
21:18:12 <Niarium> i've missed it. sorry
21:18:16 <dons> its bad practice not to: I see lots of ewbies ignore the error msg, and go straight back to editing. as it is, ghc et al tries quite hard to give you a precise msg, so that should be taken advantage of
21:18:34 <mgsloan> dons - well then its back to the C++ days of fixing compiler errors then
21:18:35 <dons> newsham: ah ok.
21:18:37 <dons> its on the wiki page
21:19:13 <dons> mgsloan: remember: they're not compiler errors -- they're the compiler finding *your* bugs
21:19:15 <Niarium> mgsloan, rofl
21:19:18 <mgsloan> "add an instance declaration for (Num (t -> a -> a -> (a, a)))" seriously has little to do with what i was trying to do
21:19:39 <dons> well, it means you tried to + a function of some kind (or some other num op)
21:20:51 <mgsloan> but it's using imperative language on me, its telling me to do something (I'm playing dummy newb atm).  It doesn't really make sense, and its just from not putting parenthesis around a negative literal
21:21:38 <dons> yeah, the Num instance errors are common for beginners. so that's what Helium is for
21:21:46 <mgsloan> yeah
21:21:53 <Niarium> we all know that the message of ghci is useful, just before that 'add an...' line, and that's why 'possible fix'(according to ghci) just sounds ridiculous
21:22:01 <mgsloan> doesn't mean that it's right
21:22:36 <dons> it's hard enough having the compiler catch your bugs for you, let along suggesting how to fix them..
21:22:44 <dons> we should be thankfully it can do anything reasonabe :)
21:23:09 <mgsloan> suggesting fixes, observing likely causes of such errors is not so far fetched
21:23:34 <dons> would you really prefer to wait till runtime for that code to die with mysterious garbage? ;) anyway, better diagnostics is of course a hot issue, and ongoing research
21:23:59 <dons> mgsloan: yeah, that's the helium goal. when you have a type error , it mails the devs
21:24:02 <Niarium> can we possibly add an instance of Eq for (a -> b -> c -> d)? there can be a better message to be a 'possible fix' ...
21:24:07 <dons> who use it to improve the result
21:24:27 <mgsloan> heh, that'd be funny if it did (does it actually??)
21:24:28 <dons> Niarium: interesting. function types in Eq or Num could be spotted, and alternatives suggested
21:24:35 <dons> such as "You're attempting to use a function as a number"
21:24:43 <dons> mgsloan: yeah
21:24:46 <Niarium> that's true
21:24:57 <mgsloan> wow, that's pretty crazy
21:25:03 <dons> rather than "No instance for Num (a -> b)"
21:25:08 <dons> which means the same thing, but not quite as nicely
21:25:19 <kfish> the compiler could at least provide entertainment, like zippy quotes to take the shock away from typing errors
21:26:13 <Niarium> dons: is there any plan to add such ideas in official release of ghci?
21:26:40 <Niarium> treating Eq, Num, and so on, sounds great idea for me
21:26:55 <mgsloan> oh, actually, i think before my problem has been decimal numbers
21:27:02 <mgsloan> > show .1
21:27:03 <lambdabot>  add an instance declaration for (Num (a -> b))
21:27:07 <mgsloan> that kind of thing
21:27:50 <lispy> the crazy thing is that you could, if you wanted, add that instance :)
21:27:52 <Niarium> Num (a -> b) is a joke. nobody's going to add such an instance
21:28:05 <newsham> when I follow the "how to write a haskell program" and runhaskell setup.hs haddock, I get documentation, but only for my main.hs.
21:28:06 <dons> would be kinda funky though...
21:28:13 <newsham> not for the ancillary modules it uses
21:28:29 <lispy> newsham: i think they have to be exposed to get documentation
21:29:27 <dons> yeah, expooed in the .cabal file
21:29:43 <newsham> so that would be in the cabal documentation?
21:31:43 <newsham> other-modules: ?
21:32:03 <dons> Exposed-modules:     Data.ByteString
21:32:03 <dons>                      Data.ByteString.Char8
21:32:06 <dons> for example
21:32:35 <newsham> I have 6 .hs files in my project, and main.hs references them (so that ghc --make pulls them all in).
21:32:47 <newsham> i want those .hs files haddock'd with main.hs
21:32:55 <dons> so add them to Exposed-modules, iirc
21:33:00 <newsham> danke.
21:34:48 <newsham> Setup.hs: Warning: Unknown field 'exposed-modules'
21:34:56 <newsham> didnt like that (this is a binary its building, btw)
21:35:24 <dons> check the uesr's guide. for executables its probably 'other-modules' in the executabe stanza then
21:36:04 <newsham> ahh.. "other-modules" did the trick
21:38:19 <newsham> hmm.. haddock doesnt seem to like "XXX" in comments
21:40:28 <newsham> now if i had a file that had TH stuff in it, can I still use cabal to build docs for it (haddoc doesnt do TH, docs say it has to be preprocessed first)
21:44:15 <dons> not sure, I suspect so
21:46:16 <Nafai> So what editor does everyone around here generally use for Haskell?  Emacs?
21:46:51 <dons> vim or emacs, I think
21:47:00 <dons> there's other choices of course.
21:54:53 <Excedrin> dons: since you use vim, do you run ghci in a seperate xterm and use :load ?
21:55:30 <Cale> :r
21:55:39 <Cale> (or :reload)
21:55:56 <Nafai> dons: Are you the one who wrote yi?
21:56:05 <Nafai> leather: Hello, fellow Austinite!
21:56:24 <leather> nafai: Howdy! ;)
21:56:38 <Cale> Nafai: yes he is
21:56:52 <greentea> Nafai: Yi, and one or two other things as well. ;-)
21:57:15 <Nafai> I just checked it out from darcs and it's missing Setup.lhs which the directions say should be there :)
21:58:07 <Excedrin> Nafai: I believe it's Setup.hs
21:58:14 <Excedrin> or setup.hs
21:58:33 <eviltwin_b> Setup.hs
21:58:48 <eviltwin_b> just substitute Setup.hs wherever it says Setup.lhs
21:59:02 <Nafai> Okay
22:00:32 <leather> nafai: Clue me in on how you knew? It's been years since I've used IRC...
22:00:55 <Nafai> leather:  leather (n=chatzill@cpe-70-113-220-167.austin.res.rr.com) has joined #haskell
22:00:56 <Excedrin> 21:50 -!- leather [n=chatzill@cpe-70-113-220-167.austin.res.rr.com] has joined #haskell
22:01:03 <leather> Ah!
22:01:10 <leather> Silly me. :)
22:01:30 <leather> I'm also using a client new to me: ChatZilla.
22:01:30 <Nafai> What's fps-any that Setup.hs configure is saying it needs? :)
22:03:42 <lispy> ?where fps
22:03:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
22:03:53 <lispy> Nafai: what version of ghc do you use?
22:04:19 <Nafai> lispy: 6.4.2, I believe, whatever is in Ubuntu Edgy
22:04:41 <lispy> Nafai: okay, if it really is in the 6.4 variety then you need fps
22:04:50 <lispy> Nafai: which you can get from the URL above
22:04:57 <Nafai> Cool, working on that now
22:05:02 <Nafai> Sorry for all of the basic questions
22:05:14 <leather> Does anybody have a suggestion for a good IRC client on MacOS X/PPC?
22:05:17 <lispy> Nafai: no problem, some of these things take time to pickup
22:05:25 <lispy> leather: emacs :)
22:05:35 <leather> Sorry. I'm a vim user. :P
22:05:46 <lispy> leather: some people like colloquy but i can't stand it :)
22:06:55 <eviltwin_b> xchat aqua
22:08:07 <leather> eviltwin_b: That looks interesting...
22:08:09 <dgriffi3> leather: irssi?
22:09:50 <Nafai> If I wanted to write something that utilized the delicious API (http://del.icio.us/help/api/) what Haskell library would I use?
22:09:51 <lambdabot> Title: del.icio.us/help/api
22:09:55 <Niarium> i don't use emacs since Korean input sucks in emacs
22:10:58 <Niarium> emacs lacks some unicode supports
22:11:06 <Plareplane> is vi any better
22:11:27 <leather> dgriffi3: Is irssi that curses-based? That's the best I can tell from their website.
22:11:42 <Niarium> well, for korean, vi is just not bad
22:12:53 <barosl> Niarium, i don't use emacs
22:13:07 <Niarium> wth
22:13:21 <dons> Nafai: um, how about the http package and haxml or something?
22:13:27 <barosl> but afak its unicode support is not bad on linux
22:14:57 <newsham> ok, i am officially at the nexus of haddock, cabal and template haskell.
22:15:19 <newsham> all my files haddock nicely from cabal now except the one with some TH code in it.
22:16:28 <barosl> is there any python library for evaluating haskell code?
22:16:36 <newsham> heh..
22:16:42 <newsham> interesting question
22:17:15 <lispy> newsham: ifdef __HADDOCK__
22:17:35 <lispy> barosl: if there were, i bet it would be named yhc
22:17:38 <newsham> import os; f = os.popen("|lambdabot", "w"); f.write(hcode); ?  :)
22:18:20 <lispy> newsham: haddock only needs the signatures so just put the signatures in one place and put the bodies somewhere protected by that ifdef
22:18:20 <newsham> lispy: eh?  i thought haddock cant handle cpp either.
22:18:24 <barosl> why yhc
22:18:37 <dons> barosl: yeah, MissingPy, iirc
22:18:57 <dons> or maybe its the other way
22:19:23 <dons> ?where missingpy
22:19:23 <lambdabot> I know nothing about missingpy.
22:19:26 <dgoldsmith> leather: I use Colloquy on Mac OS X, http://colloquy.info/
22:19:28 <lambdabot> Title: Colloquy: IRC & SILC Client
22:19:35 <dons> ?where+ missingpy http://quux.org:70/devel/missingpy
22:19:35 <lambdabot> Done.
22:19:40 <lispy> barosl: i think someone wrote something in python to execute the bytecode generated by yhc
22:19:45 <dons> ah, other way, "MissingPy is a Haskell binding to Python"
22:19:48 <newsham> "MissingPy is a haskell binding to python and library of python interfaces for haskell"
22:20:19 <leather> dgoldsmith: I was just looking through the screenshots. Does it use a lot of separate windows?
22:20:23 <dons> so you can have haskell control python, but probably not the other way, without calling into the C ffi
22:20:31 <dons> ?users
22:20:32 <lambdabot> Maximum users seen in #haskell: 276, currently: 228 (82.6%), active: 25 (11.0%)
22:20:54 <newsham> lispy: haddock docs say that to use it on files with .lhs or preprocessor directives or template haskell they have to be processed first..  unfortunately I'm using cabal, and I dont know if I can direct cabal to invoke haddock in unusual ways
22:21:08 <newsham> ifdef doesnt seem to be doing anything other than upsetting haddock
22:21:12 <dons> i think cabal can preprocess .lhs at least
22:21:24 <dons> newsham: have you told cabal you're using cpp?
22:21:31 <newsham> dons: not according to the docs, at least.
22:21:32 <lispy> newsham: well, i've made it work before with cabal :)
22:21:38 <dons> newsham: extensions:          CPP
22:22:21 <newsham> dons: oops, on I didnt.   that did make it build but it didnt fix haddock
22:22:40 <lispy> hmm...
22:22:40 <dgoldsmith> leather: you can configure it to use separate windows or one window.
22:22:49 <lispy> newsham: and it's breaking on the ifdef?
22:22:53 <dgoldsmith> leather: it's probably overkill on configurability.
22:22:56 <newsham> yup.
22:23:20 <newsham> http://www.haskell.org/haddock/haddock-html-0.8/invoking.html#cpp
22:23:23 <lambdabot> Title: Chapter 2. Invoking Haddock, http://tinyurl.com/y23o9h
22:23:29 <leather> dgoldsmith: Thanks. I might check it out.
22:24:04 <newsham> can I tell cabal special rules for building haddock docs?
22:24:26 <dons> newsham: mm. it should just work. can you paste the .cabal file and the error msg , and the relevant src/
22:25:19 <newsham> http://www.thenewsh.com/%7Enewsham/x/hmart/
22:25:21 <lambdabot> Title: Directory /~newsham/x/hmart/
22:26:20 <newsham> TH is used in State.hs
22:27:37 <gour> xerox: ping
22:28:44 <gour> xerox: oops, i don't know how, but today goa loads in ghci. excuse me for disturbance
22:29:16 <dons> we should have a library of .cabal files findable from hackage
22:29:22 <dons> so people can just peek at simialr projects for hints
22:29:48 <dons> newsham: you'll want ghc-options: -O
22:29:51 <newsham> dist\build\tmp\State.hs:"dist\\build\\tmp\\State.hs": 31:1: Parse error
22:30:05 <newsham> i'm not interested in optimization yet.  thats what -O is right?
22:30:18 <dons> looks like the $() is breaking haddock
22:30:29 <newsham> yup, haddock says that it doesnt handle TH.
22:30:30 <dons> so you can wrap that in #ifndef __HADDOCK__
22:30:32 <dons> #endif
22:30:36 <newsham> haddock doesnt handle CPP
22:30:42 <dons> it does with cpp
22:30:50 <dons> (how do you think we build the standard libs ;)
22:30:51 <newsham> apparently not, I just tried that 3min ago
22:31:17 <dons> consider the base lib Tree.hs:
22:31:18 <dons> #ifdef __HADDOCK__
22:31:18 <dons> import Prelude
22:31:18 <dons> #endif
22:31:23 <newsham> I put #ifndef __HADDOCK__ around the offending line, and extension: CPP in the cabal file
22:31:31 <dons> also, #ifndef __HADDOCK__
22:31:41 <dons> let me try ...
22:31:56 <lispy> newsham: Oh!
22:32:00 <lispy> newsham: did you re-configure?
22:32:08 <newsham> no I didnt reconfigure.
22:32:10 <newsham> lemme retry
22:32:20 <newsham> (but  "Setup.hs build" worked)
22:33:42 <newsham> same error with #ifndef, extensions CPP configure/build/haddock
22:34:09 <lispy> newsham: i'm not sure then, this has worked for me in the past
22:34:11 <gour> dons: what's needed to get hoogle work in goa?
22:34:24 <gour> dons: :hoogle a -> b -> a gives -  Could not find hoogle database, looked for: State/hoogle.txt
22:34:48 <newsham> http://www.haskell.org/haddock/haddock-html-0.8/invoking.html#cpp says that neither CPP, .lhs nor TH are handled by haddock.
22:34:50 <lambdabot> Title: Chapter 2. Invoking Haddock, http://tinyurl.com/y23o9h
22:35:24 <lispy> newsham: i understand, but cabal should be preprocessing the files adequately for haddock to do its job
22:35:46 <dons> yes. in the cabal src I see: let mockAll bi = mapM_ (mockPP ["-D__HADDOCK__"] pkg_descr bi lbi tmpDir verbose)
22:35:46 <newsham> is there a verbose flag to show what cabal is doing?
22:35:54 <dons> -v iirc
22:35:59 <dons> with various levels of 'n'
22:36:05 <Lemmih> dons: (re-hsplugins) I don't have anything yet. Got sidetracked.
22:36:21 <newsham> does mockPP doe #ifndef?
22:36:41 <dons> ah, I got it to work!
22:36:44 <newsham> maybe #if !defined(__HADDOCK__) ?
22:36:51 <dons> ?paste
22:36:51 <lambdabot> http://paste.lisp.org/new/haskell
22:38:00 <newsham> (would be even cooler if cabal would process it so that I can see the funcs it generates too :)
22:38:55 <dons> seems slightly broken with haddock + executables
22:39:02 <dons> but we can owkr around it i think...
22:39:19 <newsham> what was your fix?
22:40:39 <lisppaste2> dons pasted "cabal + cpp + TH" at http://paste.lisp.org/display/31197
22:42:52 <newsham> oh, so you made it treat it like a library?
22:43:43 <dons> yeah, looks like that's the only way to get the src preprocessed and haddocked (and built). sounds like a cabal bug report is warranted
22:44:39 <newsham> hmm.. when I do that (put all modules under exposed-modules:) it only builds docs for main
22:45:23 <newsham> oh!  nevermind..  there's now two sets of docs, one for the "lib" and one for the binary
22:45:28 <newsham> the binary only has docs for main.
22:45:39 <newsham> the "lib" dir has docs for everything else
22:45:55 <newsham> so I guess this is an acceptable workaround for now
22:46:06 <newsham> would you say this is a cabal bug?
22:47:35 <dons> Cale: I don't like this whole typeclasses are 'meta types' diversion. introducing new terminology isn't so great. whaddya think?
22:48:03 <Korollary> dons: are you talking about goodmath badmath?
22:48:05 <newsham> should I report this anywhere?  does cabal have maintainer and bug db?
22:48:15 <dons> Korollary: yeah
22:49:07 <Korollary> dons: I have a reply in that thread. I thought he was going to say kinds for the meta-types.
22:49:53 <IPI> I know that this is a haskell channel, but since haskell & prolog are both functional languages, anyone here knows prolog by any chance?
22:50:23 <greentea> Is prolog functional? i thought it was declarative.
22:50:27 <sjanssen> IPI: Prolog isn't generally considered functional
22:50:28 <Korollary> IPI: prolog is logic
22:50:43 <Korollary> but there are some people who know prolog iirc
22:51:00 <IPI> well i am in prolog channel but no one is responding.
22:51:18 <dons> IPI: there's some prolog experience here. ask away
22:51:19 <Korollary> they need lambdabot
22:51:19 <sjanssen> Korollary: in the channel, or in the universe? ;)
22:51:25 <dons> (the haskell type system behaves like prolog...)
22:51:48 <greentea> dons: That's interesting; how so?
22:52:10 <sjanssen> dons: until we drop fundeps in favor of ATs.  Then the type system will be functional
22:52:22 <dons> its a constraint resolution system. Oleg's written a tutorial on translating Prolog into Haskell type classes plus FDs.
22:52:27 <IPI> ok, i am trying to build a bst (binary search tree) with definition bsTree(Left,Root,Right). i am trying to insert an item to tree. i know how to insert the item, i don't know how to make it so that after insertion i get the root of the tree back. here is the insert function : http://www.rafb.net/paste/results/bLHxR825.html
22:52:34 <greentea> dons: Ah, okay.
22:52:36 <dons> and yeah, as sjanssen says, once we introduce ATs , we get back a functional language on the type level
22:52:51 <dons> so you can run your prolog programs in the typechecker currently
22:53:00 <dons> but its surely nicer to run your haskell program instead...
22:53:20 * greentea doesn't understand fundeps atm.
22:54:40 <dons> i think only a few do, after 8 years... ATs hurt my brain a lot less
22:55:29 <greentea> ATs = Abstract Types?
22:55:31 <sjanssen> so, in order to help IPI, perhaps we should write a type program, and then translate it into Prolog?
22:55:39 <sjanssen> greentea: associated types
22:55:47 <greentea> Ah, okay.
22:55:52 <IPI> sjanssen, is that even possible?
22:55:55 <greentea> Will have to read up on them, then. :-)
22:56:08 <IPI> i have haskell version of what i want to do
22:56:38 <IPI> do u guys want to look at what i wrote in haskell? i have exactly what i need to do , but this time instead of haskell, i have to write it in prolog.
22:56:49 <sjanssen> greentea: the idea is that a class can have types as well as functions associated with it
22:56:50 <dons> greentea: http://haskell.org/haskellwiki/GHC/Indexed_types
22:56:52 <lambdabot> Title: GHC/Indexed types - HaskellWiki, http://tinyurl.com/ykx38g
22:57:20 <dons> e.g.
22:57:21 <dons> class GMapKey k where
22:57:21 <dons>   data GMap k :: * -> *
22:57:21 <dons>   empty       :: GMap k v
22:57:23 <emu> am I the only person who's thought "it would be nice to have ReaderT like functionality in Gen (quickcheck)?"
22:57:36 <dons> emu: hmm. to what effect?
22:57:46 <emu> mostly for tweaking the test cases
22:58:25 <emu> the code looks simple enough, i may try to implement it next week
22:58:25 <dons> did people see the new scienceblogs article? http://programming.reddit.com/info/taqi/details
22:58:28 <lambdabot> Title: Functions, Types, Function Types, and Type Inference (reddit.com), http://tinyurl.com/t67qk
22:58:44 <emu> i didnt realize quickcheck was so short a library
22:58:49 <dons> its getting there. the "metatypes" description is awkward, imo. Though Cale admirably clears that up a bit
22:58:56 <dons> emu, yeah, its tiny.
22:59:02 <dons> the typeclasses do all the work
22:59:53 <emu> i'm also abusing 'generate' to get access to randomly generated test cases (and feeding them into other programs)
23:19:21 <sjanssen> @paste
23:19:21 <lambdabot> http://paste.lisp.org/new/haskell
23:21:40 <dons> ?remember SyntaxNinja That's what we, in the computer industry, call teh suck.
23:21:56 <lisppaste2> sjanssen pasted "binary tree insertion in type classes" at http://paste.lisp.org/display/31199
23:22:18 <dons> oh you gotta be kidding me...
23:22:29 <dons> hehe
23:22:33 <dons> sjanssen you rock!
23:22:58 <dons> sjanssen: can you show some of the types for t1..t5?
23:23:12 <dons> and then stick it on haskell.org ...
23:23:56 <lisppaste2> sjanssen annotated #31199 with "with types" at http://paste.lisp.org/display/31199#1
23:24:26 <sjanssen> I leave balancing of type trees as an exercise for the reader
23:25:12 <sjanssen> dons: tomorrow perhaps, it could stand some cleaning
23:25:33 <dons> very well done.
23:25:37 <dons> sjanssen++
23:25:46 <sjanssen> plus, it needs lookup.  To/FromHList if I'm ambitious
23:25:47 <dons> there's 0.6 olegs in there
23:25:51 <dons> or 600 milliolegs
23:26:09 <greentea> lol
23:26:38 <lispy> ?type randomRIO
23:26:39 <lambdabot> forall a. (Random a) => (a, a) -> IO a
23:27:17 <lispy> i don't even know how to begin explaining to that poster that they have a deep problem
23:29:04 <mgsloan> hmm YAHT is good. /me fills in a few knowledge holes
23:31:04 <dons> ?pl \(a,b) -> printf "(%d,%d)\n" a b
23:31:04 <lambdabot> uncurry (printf "(%d,%d)\n")
23:33:03 <lispy> ?type randomRIOs
23:33:04 <lambdabot> Not in scope: `randomRIOs'
23:33:15 <lispy> is there a randomRIO for an infinite stream?
23:37:08 <lispy> very nice
23:37:55 <Lemmih> @type fmap (randomRs (1,100)) getStdGen
23:37:57 <lambdabot> forall a. (Random a, Num a) => IO [a]
23:39:41 <dons> we should have more examples in System.Random
23:46:49 <lispy> yes, i agree
23:47:06 <lispy> the newbie and casual haskell programmer seems to get tripped up on randoms
23:49:58 <lispy> does Taral idle in #haskell?
23:51:42 <lispy> dons: did you hear that java is going to get closures?
23:52:23 <lispy> dons: and from the sounds of it C# is borrowing quite a bit of functional ideas lately...this could be an exciting time for FP outside of academia
23:53:42 <newsham> maybe newbies should use randomRIO?
