00:02:18 <sorear> As a side-effect of my compression process, I have a list of nicks ordered by lines uttered.
00:03:39 <sorear> 1:shapr 2:dons 3:Cale 4:lambdabot 5:Pseudonym 6:SamB 7:vincenz 8:ski 9:xerox 10:dcoutts 11:Heffalump 12:lispy 13:Igloo 14:Marvin-- 15:CosmicRay
00:04:03 <geckosenator> ok
00:04:10 <geckosenator> and you beat 7zip on size?
00:04:59 <dons> heh
00:05:15 <dons> sorear: so what will you do with your tiny logs?
00:05:19 <dons> feed them to a MegaMonad?
00:06:02 <sorear> a what?
00:06:17 <geckosenator> who cares about 200mb?
00:06:20 <dons> MegaMonad was one of those markov bots, that I think Pseudonym ran
00:06:22 <geckosenator> that's pennies in disk space
00:06:29 <dons> it was fed the entire #haskell log history
00:06:38 <dons> and made a reasonable conversation
00:06:40 <dons> :)
00:07:11 <geckosenator> do they have those in other channels?
00:07:21 <geckosenator> i think I have seen some
00:07:53 <sorear> selected other entries: 16:palomer 50:wagle 133:sorear 1453:geckosen1tor
00:08:19 <dons> i'm surprised CosmicRay is so high. do your numbers agree with the stats page?
00:08:21 <dons> ?where stats
00:08:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:08:28 <dons> look at the stats for 'Total'
00:08:41 <sorear> anyone who wants to know how prolific they are (relative and absolute)...
00:10:11 <geckosenator> for uniqe nicks, are they cleared at the end of each year?
00:10:50 <sorear> dons: your numbers are bogus
00:11:10 <gour> what do you thnik about offlineimap re-written in haskell with gtk2hs gui?
00:11:14 <sorear> I dont think shapr uttered  50729858706075216394 lines
00:11:57 <geckosenator> gour: i would prefer ncurses
00:12:10 <t35t0r> you've got AI chat bots based on HMMs?!
00:12:23 <gour> geckosenator: isn't ncurses already there?
00:12:36 <geckosenator> gour: in haskell?
00:12:58 <t35t0r> or first order logic?
00:13:10 <t35t0r> and knowledgebase models?
00:13:16 <gour> geckosenator: ahh, ok. i mean gtk2hs could be optional like tkinter now
00:14:58 <t35t0r> anyone tried sagacity?.
00:24:08 <dons> sorear: hmm :)
00:24:21 <sorear> I feel so stupid
00:24:22 <t35t0r> heh not downloadable
00:24:52 <sorear> *lambdabot* Sorry, no messages today.   -- tell is broken!!!
00:24:55 <dons> sorear: where are you getting that number from? I see shapr at roughly 213745 lines
00:25:04 <dons> http://www.cse.unsw.edu.au/~dons/irc/haskell.html
00:25:05 <lambdabot> Title: #haskell @ freenode.org stats by dons
00:25:22 <sorear> elinks - those are the squashed alttext for the images
00:25:24 <dons> oh, it does have CosmicRay at 16th
00:25:30 <dons> so maybe thats right
00:25:31 <dons> sorear: ah yes
00:25:39 <sorear> however, my numbers are lower than yours
00:25:50 <dons> how much lower?
00:25:52 <sorear> what dataset are you using? the downloadable logs/
00:25:58 <sorear> 20-50%
00:26:00 <dons> my darcs logs, which are from clog
00:26:27 <sorear> I downloaded the logs several days ago from _darcs/pristine
00:26:41 <sorear> I'm also only counting PRIVMSG's
00:26:57 <sorear> but I doubt shapr used 50k CTCP ACTIONs
00:31:25 <dons> http://www.cse.unsw.edu.au/~dons/code/irc-logs I think
00:31:27 <lambdabot> Title: Index of /~dons/code/irc-logs
00:34:31 <t35t0r> the greatest scientists feel stupid in hindsight
00:34:37 <t35t0r> ..goertzel
00:36:00 <t35t0r> "we've evolved to be relatively stupid creatures"
00:41:08 <sorear> ?list log
00:41:08 <lambdabot> log has no visible commands
00:43:48 <benja_> does anyone have a pointer to the source of Control.Monad.List.ListT?
00:44:06 <roconnor> @fps Control.Monad.List.ListT
00:44:07 <lambdabot> Maybe you meant: faq ft pl
00:44:17 <roconnor> @fp Control.Monad.List.ListT
00:44:17 <lambdabot> Control.Monad.List.ListT not available
00:44:23 <roconnor> @fp Control.Monad.List
00:44:24 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/List.hs
00:45:07 <benja_> thanks!
00:45:20 <benja_> lambdabot is so cool =)
00:46:10 <roconnor> @botsnack
00:46:10 <lambdabot> :)
01:07:22 <t35t0r> sorear, are you designing an nlp using the irc logs?
01:08:25 <sorear> nlp?
01:08:33 <sorear> oh, natural language processor?
01:09:03 <sorear> no, I just saw a lot of nontrivial redundancy, and I'm a nut for clever algortithms.
01:13:08 <dons> hehe
01:16:04 <sorear> dons: is it safe to import types+constructors from one plugin into another?
01:17:12 <sorear> I'm trying to find a way to fix ?seen, since my least-common-denominator layer doesn't have JOIN/PART messages, and Typeable+cast is looking attractive atm.
01:20:55 <nornagon> @botsnack
01:20:56 <lambdabot> :)
01:22:36 <sorear> ?bot
01:22:37 <lambdabot> :)
01:22:40 <sorear> ?bo
01:22:40 <lambdabot> :)
01:22:44 <sorear> ?b
01:22:45 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . v
01:23:02 <sorear> ?
01:25:35 <_lygaret> Howdy y'all
01:26:37 <sorear> Hi!
01:27:01 <_lygaret> Heya! Quiet tonight?
01:28:30 <sorear> yea.
01:29:12 <_lygaret> Could you answer me a question?
01:29:23 <_lygaret> Is ($) usefull anywhere other than avoiding parens?
01:29:31 <sorear> yes
01:29:56 <sorear> map ($2) ...
01:30:03 <_lygaret> ooooh
01:30:18 <_lygaret> oh wow, I hadn't thought of that.
01:30:24 <sorear> id is often better, but is harder in right sections.
01:30:34 <sorear> Its on the wiki, somewhere.
01:30:44 <sorear> ?gwiki higher order situations
01:30:45 <lambdabot> No Result Found.
01:30:50 <sorear> ?go "higher order situations"
01:30:56 <lambdabot> http://www.cs.kuleuven.ac.be/~ade/nalag/research/projects/RHPH.shtml
01:30:56 <lambdabot> Title: RHPH project
01:31:05 <sorear> ?go operator haskell "higher order situations"
01:31:08 <lambdabot> http://lml.ls.fi.upm.es/~jjmoreno/manual/haskell98-report/basic.html
01:31:08 <lambdabot> Title: The Haskell 98 Report: Basic Types and Classes
01:31:20 <sorear> ?go operator url:haskellwiki "higher order situations"
01:31:21 <lambdabot> No Result Found.
01:32:07 <_lygaret> really useless snippet, but neat anyway
01:32:17 <nornagon> ?brain
01:32:18 <lambdabot> I think so, Brain, but don't you need a swimming pool to play Marco Polo?
01:32:19 <_lygaret> map ($2) [(+) x | x <- [1..10]]
01:32:43 <sorear> together with runST, ($) also makes a good source of confused newbies
01:33:01 <_lygaret> lol, yeah, I've figured that out :D
01:33:20 <_lygaret> I realized I could only just explain what it is today with any confidence.
01:34:37 <_lygaret> ?type id
01:34:38 <lambdabot> forall a. a -> a
01:34:43 <_lygaret> ?type ($)
01:34:44 <lambdabot> forall b a. (a -> b) -> a -> b
01:34:56 <_lygaret> how would you use id in that same example?
01:35:21 <sorear> map (`id` 2) [(+) x | x <- [1..10]]
01:35:26 <sorear> map (flip id 2) [(+) x | x <- [1..10]]
01:35:37 <sorear> ($) = id `asTypeOf` ($)
01:36:39 <_lygaret> asTypeOf is a coercion?
01:36:53 <_lygaret> (sp?) I'd venture a guess, based on the name...
01:37:13 <sorear> yes
01:37:24 <_lygaret> hmm
01:37:28 <sorear> it only does up-casts, to use OO terminology
01:37:35 <sorear> > [] `asTypeOf` 0
01:37:36 <lambdabot>  add an instance declaration for (Num [a])
01:37:40 <sorear> > [] `asTypeOf` 'a'
01:37:41 <lambdabot>  Couldn't match `[a]' against `Char'
01:37:44 <sorear> > [] `asTypeOf` "a"
01:37:46 <lambdabot>  ""
01:37:50 <_lygaret> ok
01:38:14 <_lygaret> > id `asTypeOf` ($)
01:38:15 <lambdabot>  Add a type signature
01:38:23 <sorear> asTypeOf a b = a, BUT asTypeOf has an explicit signature a -> a -> a
01:38:29 <sorear> :t id `asTypeOf` ($)
01:38:30 <lambdabot> forall a b. (a -> b) -> a -> b
01:38:33 <sorear> :t id
01:38:35 <lambdabot> forall a. a -> a
01:38:56 <sorear> replace a with a->b to restrict the type of id into that of ($)
01:39:19 <sorear> > 0
01:39:21 <lambdabot>  0
01:39:26 <sorear> > 0 `asTypeOf` 0.0
01:39:27 <lambdabot>  0.0
01:39:29 <sorear> > 0 `asTypeOf` 2.0
01:39:30 <lambdabot>  0.0
01:39:56 <_lygaret> I'm confused how it would get from id to ($)
01:40:10 <_lygaret> you mean it says "assuming forall a. b = a"
01:40:15 <_lygaret> then that should be ok
01:40:23 <sorear> a $ b = a b  ;  id a = a
01:40:28 <sorear> ($) a b = a b  ;  id a = a
01:40:35 <sorear> eta-convert id to get ($)
01:42:45 <_lygaret> Since b isn't free...
01:42:53 <_lygaret> I'm sort of lost in this :P
01:43:19 <_lygaret> so, since there isn't a variable typed b free in id
01:43:30 <_lygaret> it's alright to eta-convert to ($)?
01:44:34 <dons> asTypeOf is legacy code from before the days of pattern type annotations
01:44:43 <dons> i.e. you never need it now, since (v :: Int) works :)
01:44:58 <_lygaret> :) that's fair, but it's still a wart on my understanding
01:45:48 <dons> asTypeOf        :: a -> a -> a
01:45:48 <dons> asTypeOf        =  const
01:46:04 <dons> so it simply forces both arguments to be of the same type
01:46:28 <dons> hence a polymorphic value in the first arg will have a constraint generated to be the same as the second arg
01:46:33 <_lygaret> How can it type check though?
01:46:52 <dons> polymorphic values will be constrained to more specific types, which is ok
01:46:57 <_lygaret> ok
01:46:58 <dons> :t 1
01:47:00 <lambdabot> forall t. (Num t) => t
01:47:06 <_lygaret> oooh
01:47:08 <dons> :t 1 `asTypeOf` (ord 'x')
01:47:09 <lambdabot> Int
01:47:14 <dons> :t ord 'x'
01:47:15 <lambdabot> Int
01:48:17 <dons> so instead of 1 being only some Numeric type t, Num t => t
01:48:18 <Shimei> http://www.hermann-uwe.de/files/images/programmer_hierarchy.png <-- It's missing Haskell... :(
01:48:27 <dons> the asTypeOF adds an additional constraint to Int
01:48:36 <dons> and Num t => t unifies with Int, yielding Int
01:48:40 <_lygaret> ok, so, asTypeOf will just reduce things to the lowest common denominator of both arguments
01:48:46 <dons> _lygaret: yep
01:48:46 <_lygaret> or, no
01:48:55 <dons> well, it will force the two types to unify
01:48:57 <_lygaret> well, yes, but worded badly :D
01:49:03 <dons> which will mean a more specific type results
01:49:06 <_lygaret> yeah
01:49:26 <_lygaret> > 1 `asTypeOf` (+)
01:49:27 <lambdabot>  add an instance declaration for (Num (a -> a -> a))
01:49:29 <_lygaret> ok
01:49:31 <_lygaret> got it
01:49:41 <dons> Shimei: heh. the haskell programmers should be above the lisp programmers I think
01:49:49 <dons> since the lisp guys are missing out on a lot of things
01:50:25 <dons> but haskell programmers see themselves as inferiro to epigram programmers :)
01:50:47 <sorear> wouldn't the lisp guys think of the missingness as a feature?
01:51:03 <dons> sorear: I think even the lisp guys know they're missing out. blub paradox and all
01:51:19 <dons> that graph is a sort of 'blub' ordering, after all
01:52:43 <_lygaret> > (\x -> 42) `asTypeOf` Int
01:52:44 <lambdabot>  Not in scope: data constructor `Int'
01:52:48 <_lygaret> > (\x -> 42) `asTypeOf` Num
01:52:49 <lambdabot>  Not in scope: data constructor `Num'
01:52:52 <_lygaret> > (\x -> 42) `asTypeOf` 1
01:52:53 <lambdabot>  add an instance declaration for (Num (t -> t1))
01:52:55 <dons> you need a value of type Int
01:52:56 <benja_> hm, is there a shorter syntax for making record update functions, or do I need to use (\r -> r { field=val })?
01:52:59 <dons> such as the result of ord 'x'
01:53:11 <dons> benja_: the parens probably aren't needed
01:53:12 <_lygaret> > (\x -> 42) `asTypeOf` ord 'x'
01:53:13 <lambdabot>  Couldn't match `t -> t1' against `Int'
01:53:14 <dons> but otherwise, yes, that's it
01:53:19 <dons> you can name that function though
01:53:31 <dons> updateField r v = r { field = v }
01:53:34 <dons> then updateField r v works
01:53:46 <benja_> right ... thanks
01:54:04 <dons> _lygaret: but (\x -> 42) :: Num u  => t -> u
01:54:10 <dons> i.e. its a function :)
01:54:13 <_lygaret> Yeah
01:54:16 <_lygaret> But...
01:54:26 <_lygaret> id `asTypeOf` ($)
01:54:33 <_lygaret> by eta-conversion...
01:54:35 <_lygaret> oh
01:54:37 <_lygaret> wait
01:54:37 <dons> > ( (\x -> 42) `asTypeOf` (\y -> ord 'x') ) 8
01:54:38 <_lygaret> gah, nm
01:54:39 <lambdabot>  42
01:54:47 <dons> :t ( (\x -> 42) `asTypeOf` (\y -> ord 'x') ) 8
01:54:48 <lambdabot> Int
01:54:54 <sorear> We should find some verifyable random event (a sporting event is the only thing that comes to mind) and force the improved-record-system proposers to take sides.  After that we'll know what record system to use in h'.
01:55:01 <dons> hehe
01:55:09 <dons> i think we'd be happy with Daan's system
01:55:14 <dons> but there's no champion to promote it
01:55:26 <benja_> the parens are part of the informal metalanguage, used to enclose literal code =-)
01:55:27 <sorear> which one was his? TRex?
01:55:32 <dons> look for a records paper by Daan Leijen
01:55:44 <dons> mm, not TRex, I think (i might be wrong there)
01:55:50 <dons> benja_: hehe :)
01:56:12 <dons> sorear: so how are you haskell studies progressing?
01:56:20 <_lygaret> :t (\x -> 42) `asTypeOf` (\x -> x)
01:56:21 <lambdabot> forall t. (Num t) => t -> t
01:56:22 <sorear> haskell studies?
01:56:36 <dons> you seem to be taking a good lung full of lambdas :)
01:56:55 <_lygaret> :t (\x -> 42) `asTypeOf` (\y -> x)
01:56:56 <lambdabot> Not in scope: `x'
01:56:59 <dons> _lygaret: see how that unified?
01:57:00 <_lygaret> :t (\x -> 42) `asTypeOf` (\y -> 42)
01:57:02 <lambdabot> forall t t1. (Num t1) => t -> t1
01:57:03 <_lygaret> yeah
01:57:08 <dons> the type didn't really get anything from \x -> x
01:57:15 <sorear> hehe, I'd say I'm at least on the right track toward master-ness.
01:57:16 <dons> :t \x -> 42
01:57:17 <lambdabot> forall t t1. (Num t) => t1 -> t
01:57:22 <dons> sorear: I agree :)
01:57:36 <sorear> Anyway, goodnight all...
01:57:37 <dons> _lygaret: ah, other than that the const arg is of the same type as the result
01:57:41 <dons> night sorear
01:58:12 <_lygaret> So, in that case
01:58:22 <_lygaret> it force x to type t
01:58:33 <_lygaret> t being the var
01:58:49 <_lygaret> because I forced the coercion to t->t
01:59:08 <_lygaret> and the Num t came from the const
01:59:49 <benja_> night sorear, flight benja_.
02:00:06 <benja_> (according to the boarding card, boarding started four minutes ago)
02:01:13 <_lygaret> :t ($)
02:01:14 <lambdabot> forall b a. (a -> b) -> a -> b
02:01:15 <_lygaret> :t id
02:01:16 <lambdabot> forall a. a -> a
02:01:44 <_lygaret> :t id `asTypeOf` ($)
02:01:45 <lambdabot> forall a b. (a -> b) -> a -> b
02:01:53 <_lygaret> :t ($) `asTypeOf` id
02:01:54 <lambdabot> forall a b. (a -> b) -> a -> b
02:01:57 <_lygaret> oooogh
02:02:34 <_lygaret> so, does asTypeOf simply unify, not necessarily coerce?
02:02:49 <_lygaret> If it can't coerce, will it just leave the type alone to not typecheck?
02:04:29 <_lygaret> > (id `asTypeOf` ($)) 7
02:04:30 <lambdabot>  add an instance declaration for (Num (a -> b))
02:04:46 <_lygaret> > (id `asTypeOf` ($)) id
02:04:47 <lambdabot>  Add a type signature
02:04:51 <_lygaret> > (id `asTypeOf` ($)) id 7
02:04:53 <lambdabot>  7
02:05:45 <_lygaret> > (id `asTypeOf` ($)) (\x -> 10.0) 7
02:05:46 <lambdabot>  10.0
02:06:06 <_lygaret> Ok, now I don't understand.
02:06:43 <_lygaret> even though id is coerced to ($)'s type, it should still act like id right?
02:06:48 <benja_> _lygaret: (id `asTypeOf` ($)) (\x -> 10.0) = (\x -> 10.0)
02:06:58 <_lygaret> oooh
02:06:59 <_lygaret> :P
02:07:00 <benja_> (\x -> 10.0) 7 = 10.0
02:07:01 <_lygaret> yeah
02:07:05 <_lygaret> alright, thanks
02:07:11 <benja_> :)
02:07:30 <_lygaret> just plain ($)
02:07:39 <_lygaret> > ($) (\x -> 10.0)
02:07:40 <lambdabot>  Add a type signature
02:07:47 <_lygaret> > ($) (\x -> 10.0) 8
02:07:48 <lambdabot>  10.0
02:08:04 <_lygaret> :t ($) (\x -> 10.0)
02:08:06 <lambdabot> forall a b. (Fractional b) => a -> b
02:08:17 <_lygaret> Ok, so is this right?
02:08:30 <_lygaret> id `asTypeOf` ($) = ($)
02:08:39 <_lygaret> by virtue of the fact
02:09:24 <_lygaret> that you need to give an argument to the function because ($) type expects it?
02:10:33 <benja_> _lygaret: yup
02:11:02 <_lygaret> hah - so it's coincedence. maybe a designed coincidence, but nonetheless...
02:11:04 <_lygaret> awesome :D
02:11:29 <_lygaret> thanks!
02:11:58 <_lygaret> benja_, dons thank you very much!
02:12:12 <benja_> :)
02:12:28 <benja_> @hoogle MonadTrans
02:12:29 <lambdabot> Control.Monad.Trans.MonadTrans :: class MonadTrans t
02:14:04 <benja_> there's my boarding call. bye :)
02:14:23 <_lygaret> bye - safe trip!
02:18:17 <_lygaret> > (+) 1
02:18:18 <lambdabot>  Add a type signature
02:18:23 <_lygaret> :T (+) 1
02:18:28 <_lygaret> :t (+) 1
02:18:30 <lambdabot> forall a. (Num a) => a -> a
02:18:52 <_lygaret> > map ($2) [(+) 1]
02:18:53 <lambdabot>  [3]
02:19:02 <_lygaret> > map (id 2) [(+) 1]
02:19:03 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
02:19:39 <_lygaret> > map (id `asTypeOf` ($) 2) [(+) 1]
02:19:40 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a -> a))
02:19:59 <_lygaret> > map ((id `asTypeOf` ($)) 2) [(+) 1]
02:20:00 <lambdabot>  add an instance declaration for (Num ((a -> a) -> b))
02:20:11 <_lygaret> > map (`id` 2) [(+) 1]
02:20:12 <lambdabot>  [3]
02:20:27 <_lygaret> hmmm
02:20:49 <_lygaret> :t `id`
02:20:50 <lambdabot> parse error on input ``'
02:20:55 <_lygaret> :t flip id
02:20:56 <lambdabot> forall b c. b -> (b -> c) -> c
02:21:21 <_lygaret> :t (flip id)
02:21:22 <lambdabot> forall b c. b -> (b -> c) -> c
02:21:31 <_lygaret> > flip id 2
02:21:32 <lambdabot>  Add a type signature
02:21:41 <_lygaret> :t flip
02:21:43 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
02:21:58 <_lygaret> > map (flip id 2) [(+) 1]
02:21:59 <lambdabot>  [3]
02:23:37 <_lygaret> When flipping id, the a gets bound to the type of id, but the others are still free? id gets turned into a partial function, which, when applied to another partial gives up it's value as an argument
02:23:38 <_lygaret> ?
02:23:54 <_lygaret> so
02:24:03 <_lygaret> > flip id 2 (\x -> x)
02:24:05 <lambdabot>  2
02:24:11 <_lygaret> (\x -> x) id 2
02:24:17 <_lygaret> > (\x -> x) id 2
02:24:18 <lambdabot>  2
02:24:20 <_lygaret> ok
02:25:49 <nornagon> :t flip id
02:25:51 <lambdabot> forall b c. b -> (b -> c) -> c
02:25:57 <nornagon> oh
02:27:02 <nornagon> that looks like function application
02:27:19 <_lygaret> yeah - I think that's what it's doing
02:27:22 <nornagon> it takes a value and a function, applies the function to the value, and returns the value
02:27:25 <_lygaret> yep
02:27:44 <_lygaret> but I think it's more than that too:
02:27:49 <_lygaret> :t flip (+)
02:27:50 <lambdabot> forall b. (Num b) => b -> b -> b
02:27:57 <_lygaret> er
02:28:10 <_lygaret> :t (+)
02:28:11 <lambdabot> forall a. (Num a) => a -> a -> a
02:28:14 <_lygaret> Hm
02:28:19 <_lygaret> nm
02:28:19 <_lygaret> lol
02:28:36 <quazimodo> Guys
02:28:44 <quazimodo> a friend just told me haskell is limited
02:28:53 <quazimodo> can i get a reply that will retort to that plz
02:29:05 <sebell> quazimodo: Sure, it's not.
02:32:19 <_lygaret> :t flip ((+) 3)
02:32:20 <lambdabot> forall b c. (Num (b -> c)) => b -> (b -> c) -> c
02:32:24 <mr_tenor> quazimodo:say his mum is limited?:P
02:33:57 <quazimodo> forall b c. (Num (b -> c)) => b -> (b -> c) -> c
02:34:01 <quazimodo> what does that do?
02:34:32 <_lygaret> takes a value, and a function that returns a num, and returns the num
02:34:48 <quazimodo> im scared
02:34:49 <_lygaret> but in pragmatic terms, i have no idea
02:35:01 <_lygaret> since I don't know what you could apply it to
02:35:09 <_lygaret> :)
02:35:16 <quazimodo> whgat does -> do?
02:35:36 <quazimodo> :D im a nooby
02:35:39 <quazimodo> im gonna go learn
02:35:56 <_lygaret> it signifies function in a type signature
02:38:50 <nornagon> flip (+3) is semantically identical to (+3)
02:38:58 <nornagon> since addition is commutative
02:39:32 <_lygaret> even though the types are seemingly really different?
02:39:40 <_lygaret> :t +3
02:39:41 <lambdabot> parse error on input `+'
02:39:45 <_lygaret> :t (+3)
02:39:47 <lambdabot> forall a. (Num a) => a -> a
02:39:50 <_lygaret> :t flip (+3)
02:39:51 <lambdabot> forall b c. (Num (b -> c)) => b -> (b -> c) -> c
02:40:09 <_lygaret> I believe you, I just don't get it :)
02:40:45 <_lygaret> > map (+3) [1, 2, 3]
02:40:47 <lambdabot>  [4,5,6]
02:40:54 <_lygaret> > map (flip (+3)) [1, 2, 3]
02:40:55 <lambdabot>  add an instance declaration for (Num (a -> c))
02:44:50 <_lygaret> ... alright off to sleep to let my brain try to digest
02:44:54 <_lygaret> thanks for your help everybody
02:45:13 <_lygaret> nornagon, dons!
02:45:16 <_lygaret> thanks!
02:45:18 <_lygaret> night!
02:46:34 <nornagon> > flip (+3) $ 2
02:46:35 <lambdabot>  add an instance declaration for (Num (a -> c))
02:46:38 <nornagon> oh
02:46:40 <nornagon> hm :)
02:47:05 <nornagon> > (+3) 2
02:47:07 <lambdabot>  5
02:47:12 <nornagon> oops.
02:47:19 <nornagon> :t flip (+3)
02:47:21 <lambdabot> forall b c. (Num (b -> c)) => b -> (b -> c) -> c
03:11:11 <augustss> howdy
03:28:26 <vegai> http://flickr.com/photos/nicksieger/281055485/
03:28:28 <lambdabot> Title: Python grammar dependency graph on Flickr - Photo Sharing!
03:29:15 <vegai> anyone care to make one from Haskell's?
03:29:33 <vegai> ruby's is quite amusing: http://flickr.com/photos/nicksieger/280661836/in/photostream/
03:29:34 <lambdabot> Title: Ruby 1.8.4 grammar dependency graph on Flickr - Photo Sharing!
04:16:15 <syntaxfree> g'day, Programming 2.0 mates.
04:26:31 <sebell> syntaxfree: Did you go to sleep and then come back?
04:31:06 <syntaxfree> sebell: are you stalking me?
04:32:14 <yaxu> is there an easy way to work out how lazy a haskell function is being?
04:33:04 <nornagon> ?where darcs
04:33:05 <lambdabot> http://darcs.net/
04:33:19 <syntaxfree> yaxu: there are varying degrees of laziness?
04:33:31 <syntaxfree> Stupid ole' me thought functoi
04:33:38 <syntaxfree> functions were either lazy or strict.
04:34:01 <yaxu> i just spent several hours making a more efficient version of a function which on testing seems less efficient
04:34:50 <yaxu> syntaxfree: i'm trying to process data from a file efficiently, without forcing a full read of the file first
04:35:02 <yaxu> syntaxfree: that's laziness right?
04:35:04 <syntaxfree> and you specifically want to do it lazily.
04:35:31 <syntaxfree> laziness, in layman terms, means things are computed as needed, not computed as declared.
04:35:40 <yaxu> right, yes
04:35:51 <nornagon> hm, is there a way to make darcs use a .darcs instead of _darcs?
04:36:13 <sebell> nornagon: Why?
04:36:38 * syntaxfree wonders if anyone has a 'better' PDF version of Kieburtz (1999)
04:36:44 <yaxu> so i can 'break' that laziness through right recursion
04:36:49 <nornagon> sebell: because i don't like seeing it in ls or having it globbed by *
04:37:19 <syntaxfree> at the uni lab I certainly could download it from some of the journal storage sites, but I'll be home for a while.
04:37:33 <syntaxfree> yaxu: you can break the laziness specifying functions to be strict.
04:37:47 <yaxu> *sigh* i guess i'm just going to have to spend some time understanding my own code
04:37:51 <syntaxfree> I forgot the syntax now, but it's a sign or two.
04:37:56 <syntaxfree> Well, we haven't seen it yet, too.
04:38:11 <syntaxfree> I confess I'm curious, even if there's a low probability that I can actually help.
04:38:28 <syntaxfree> @paste
04:38:29 <lambdabot> http://paste.lisp.org/new/haskell
04:41:05 <lisppaste2> yaxu pasted "LSystem.hs" at http://paste.lisp.org/display/33423
04:41:10 <dons> yaxu: compile with -O and then check the .hi file
04:41:15 <dons> using --show-iface
04:41:25 <dons> will tell you for each function exported if its strict in which arg
04:41:29 <syntaxfree> yay, Lsystems.
04:41:32 <dons> -ddump-simpl might tell you that too
04:41:47 * dons =<< gets sleep
04:42:01 <lisppaste2> yaxu pasted "space.hs" at http://paste.lisp.org/display/33424
04:42:06 <syntaxfree> Once my heart is finally unbroken, I need to hack up a L-systems thing using comonads in the style of sigfpe.
04:42:25 <yaxu> i haven't explicitly set anything strict
04:44:22 <yaxu> goodnight dons
04:44:22 <DebolazX> nornagon: You could just use mercurial. :)
04:44:29 <syntaxfree> old news that made me ooh aah anyway.
04:44:38 <syntaxfree> http://koweycode.blogspot.com/2006/11/yaht-on-darcshaskellorg.html
04:44:41 <lambdabot> Title: koweycode: yaht on darcs.haskell.org, http://tinyurl.com/y7xcqm
04:44:48 <syntaxfree> yay! I can finally fix YAHT once and for all! ;)
04:45:07 <nornagon> DebolazX: heh
04:45:13 <nornagon> i'll live :)
04:45:15 <nornagon> it'd just be nice
04:45:26 <nornagon> i could get the source and s/_darcs/.darcs/g >.>
04:45:44 <nornagon> hm... i wonder if i could just do that to the binary...
04:47:26 <nornagon> heh, looks like it worked
04:48:45 <nornagon> >.>
04:49:43 <yaxu> syntaxfree: i'm using an lsystem to make a space filling peano curve, so i can map 1D audio data to a 2D image
04:50:12 <yaxu> like this http://doc.gold.ac.uk/~ma503am/images/woven_sound/peano1.gif
04:50:23 <syntaxfree> interesting. usually 1D audio is mapped to 2D images by plotting its frequency domain.
04:50:38 <Templar2> Any ideas how I could define the length function using map and sum ? ?
04:50:45 <syntaxfree> I need a good course in signal processing.
04:51:01 <ToRA> Templar2: sum $ map (const 1) ?
04:51:04 <syntaxfree> Templar: length = sum . (map (const 1))
04:51:23 <yaxu> yeah but just plotting sound pressure to a peano curve you can see a lot of structure
04:51:23 <Templar2> will test it =)
04:52:05 <syntaxfree> actually usually 1D audio is mapped to a 2D image by merely plotting a wave over the time domain.
04:52:19 <syntaxfree> I prefer frequency domain representation, though. You see lots of nifty structure that way.
04:52:41 <syntaxfree> yaxu: anyway, that's good hacking :)
04:52:43 <yaxu> a lot of time based structure
04:53:54 <syntaxfree> well, yes. frequency domain representations often chop the sound in tiny bits of time.
04:54:02 <yaxu> this kind of plot seems to show structure across time rather as a series of snapshots
04:54:28 <syntaxfree> So horizontal axis ends up expressing time anyway, and colors for sound level are plotted over the frequency domain in the Y axis.
04:55:14 <syntaxfree> what's the most efficient way to represent foldl in terms of foldr, btw?
04:55:55 <yaxu> are you asking me?
04:56:16 <syntaxfree> not necessarily.
04:56:20 <yaxu> phew
04:56:31 <syntaxfree> ;)
04:58:13 <yaxu> oops, i ran that bit of haskell and the linux kernel killed my emacs
04:58:24 <Syzygy-> o.O
04:59:04 <yaxu> i guess emacs always looks guilty to the oom-killer
05:00:04 <syntaxfree> maybe foreseeing the rise of Haskell from early program-calculation papers, the Elisp designers preemptively sabotaged it.,
05:00:16 <syntaxfree> So Lisp can rule forever and ever.
05:01:06 <yaxu> :)
05:02:16 <yaxu> http://lwn.net/Articles/104185/
05:02:18 <lambdabot> Title: LWN: Re: [PATCH] oom_pardon, aka don't kill my xlock
05:04:49 <Syzygy-> oom-killer?
05:05:13 <yaxu> when linux runs out of memory, the oom-killer starts killing random processes
05:05:23 <yaxu> with some heuristics
05:05:29 <yaxu> that link is a good summary :)
05:06:01 <yaxu> http://lwn.net/Articles/104179/ # more discussion here
05:06:02 <lambdabot> Title: LWN: Respite from the OOM killer
05:06:44 <uccus> does anyone know what's happening in the Epigram world?
05:12:16 <yaxu> ah, i see my efficiency problem now...  stupid use of "length"
05:12:29 * yaxu hits forehead
05:12:54 <syntaxfree> "Monads are supposed to be some kind of huge foundational paradigm shift, but all they really are is a way to introduce sequencing and side-effects into the "purely functional" programming languages. Which of course just illustrates the point above: there is no sense in having a purely functional programming language!"
05:12:58 <syntaxfree> http://theonlywinningmove.blogspot.com/2006/10/scheme-death-knell.html
05:13:00 <lambdabot> Title: The Only Winning Move: Scheme Death Knell?, http://tinyurl.com/yd3uzv
05:13:05 <syntaxfree> we're not selling monads right, I feel.
05:13:31 <dmhouse> What's the quickest way to run a command (in the form of a String) and grab its output?
05:13:59 <yaxu> syntaxfree: yeah lets talk branding
05:14:01 <dmhouse> In the past I've used do (out, _, _, _) <- runInteractiveCommand "cmd"; getContents out; but that seems like a long way round.
05:14:23 <syntaxfree> yaxu: I mean, monads are sold as being the solution to a self-imposed problem, purity.
05:14:28 <integral> syntaxfree: That seems to miss the point that monads make actions first class, and it doesn't mention the benefits of writing your own combinators :-/
05:14:34 <syntaxfree> When that's just a silly application.
05:14:45 <syntaxfree> it misses the point of, say, monadic parsers!
05:14:50 <syntaxfree> It misses the point of monads!
05:15:12 <Philippa> yes, but the problem there is that everyone who just glances over Haskell will see that because the first monad everyone has good cause to use is IO
05:15:27 <Philippa> and because every time someone says "but you can't do IO in a pure language", the answer is monads
05:15:41 <yaxu> yes, sorry i was being facetious
05:16:00 <syntaxfree> Isn't  "interact" the only IO one should need in Unix anyway?
05:16:15 <syntaxfree> people are addicting to interpsersing IO with program logic!
05:16:16 <Philippa> no
05:16:20 <Philippa> HTH HAND
05:24:37 <Syzygy-> HTH HAND???
05:24:48 <rahikkala> Hope this helps, have a nice day
05:25:10 <Syzygy-> Ah.
05:45:35 <yaxu> great, now my program is running nicely on a 98M file while using 4M of memory
05:46:00 <yaxu> now i just have to work out how to sort the results :/
06:03:26 <zeroflag> @djinn (b -> c) -> (a -> b) -> (a -> c)
06:03:27 <lambdabot> f a b c = a (b c)
06:07:31 <edi> @where nymphaea
06:07:32 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
06:07:34 <edi> yaxu -^
06:09:43 <yaxu> oh!
06:10:02 <edi> (:
06:10:35 <araujo> morning
06:10:58 <yaxu> edi: thanks!
06:11:25 <edi> yaxu: It's been a while since I worked on it, I hope you enjoy it.
06:11:52 <nornagon> ?pl \a b c = a (b c)
06:11:53 <lambdabot> (line 1, column 8):
06:11:53 <lambdabot> unexpected "="
06:11:53 <lambdabot> expecting pattern or "->"
06:11:54 <yaxu> ah, you're paolo
06:12:00 <nornagon> ?pl \a b c -> a (b c)
06:12:01 <lambdabot> (.)
06:12:01 <edi> Right.
06:12:04 <yaxu> edi: yes i'll have fun with this
06:12:47 <yaxu> edi: although the lsystem i'm drawing at the moment would just be rendered as a filled in square :)
06:13:04 <yaxu> s/drawing/using/
06:14:02 <edi> Ah.  Maybe you can make use of the engine.  It gives a random outcome of a non-deterministic L-System.
06:15:36 <yaxu> yes, i can definitely learn from it
06:17:39 <yaxu> beautiful examples
06:17:44 <edi> Thank you (:
06:19:52 <edi> It was a cairo-and-Haskell show-off after writing those bindings, those IFS make very nice picture, and it's fun to use because for the non-det ones, every time you click render, it renders a different thing.
06:20:09 <nornagon> ?pl \a c e f h k l s -> h a s k e l l c a f e
06:20:25 <lambdabot> flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((
06:20:25 <lambdabot> ((flip .) .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .)
06:20:25 <lambdabot>  .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip . (flip .) . ((flip .) .) . (flip .) . flip id) id
06:20:25 <lambdabot> optimization suspended, use @pl-resume to continue.
06:21:38 <nornagon> :t ap
06:21:39 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
06:40:47 <lisppaste2> Templar2 pasted "square and sum list" at http://paste.lisp.org/display/33429
06:42:03 <metaperl> What is the easiest way to make an http request in haskell? I'm really not even concerned about getting the contents back or the status code
06:42:40 <Templar2> could I have some help? ^^
06:42:51 <allbery_b> foldr needs a seed
06:43:05 <metaperl> foldr1 does not
06:43:30 <zeroflag> Templar2: ss xs = foldr (\x z -> x*x + z) 0 xs
06:43:52 <araujo> Templar2, felt like i was reading lisp with your code :-P
06:45:49 <dmhouse> Anyone familiar with HAppS? I want to run some IO in the Ev monad but addSideEffect won't do as I need its result.
06:45:53 <Templar2> :P , ty, will try
06:49:03 <Templar2> zeroflag: whats x and whats z? ^^
06:50:59 <Templar2> zeroflag: dont understand the zero(0) eighter
06:51:30 <allbery_b> the zero is the seed value.  foldr needs a starting value to work with, that's why your code is failing
06:51:39 <allbery_b> foldr (function) (seed) (list)
06:51:58 <edi> metaperl: http://haskell.org/http/
06:51:59 <lambdabot> Title: Haskell HTTP package
06:52:09 <dmhouse> If you don't want to use a seed, you can use foldr1, but that requires a nonempty list.
06:52:20 <metaperl> edi -thanks
06:52:25 <yaxu> could anyone suggest somewhere for finding out about how to handle io exceptions?  that chapter of YAHT isn't written yet...
06:52:55 <dmhouse> Templar2: http://cale.yi.org/index.php/Fold_Diagrams might help.
06:52:57 <lambdabot> Title: Fold Diagrams - CaleWiki
06:53:01 <dmhouse> yaxu:
06:53:05 <dmhouse> ?docs System.IO.Error
06:53:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Error.html
06:53:44 <yaxu> thanks dmhouse
06:54:14 <Templar2> aha, thanks allbery_b. But anyone who also could explain what x z is?
06:55:02 <allbery_b> he used a lambda expression.  (\x y -> x*x + z) is a lambda expression:  a temporary function declared inline which takes two parameters and returns a result calculated from them
06:55:26 <allbery_b> the backslash is a lame ASCII approximation of the Greek lowercase letter "lambda"
06:55:29 <dmhouse> It's basically the same as defining an auxiliary function, f x z = x*x + z
06:55:39 <dmhouse> And in allbery_b's example, that y is meant to be a z.
06:55:44 <allbery_b> sorry, yes
06:56:00 * allbery_b just got up, and is still a bit woozly
06:56:13 <metaperl> How do you sleep in a do block for a specified amount of time? Hoogle only has a win32 sleep: http://haskell.org/hoogle/?q=sleep
06:56:15 <lambdabot> Title: sleep - Hoogle
06:56:24 <dmhouse> ?hoogle threadDelay
06:56:25 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
06:56:52 <metaperl> dmhouse - thanks
06:56:54 <dmhouse> ?ask shapr (HAppS) if there's a way to run an IO action in the Ev monad and get a result back from it?
06:56:54 <lambdabot> Consider it noted.
06:57:49 <Templar2> but if we look at the assignemnt  ss xs = foldr (\x z -> x*x + z) 0 xs . I guess the x is all the elements into the list. What is the z then?
06:58:22 <koala_man> is there a function for checking if an element is in an array?
06:58:30 <metaperl> @type elem
06:58:30 <allbery_b> look at the fold diagrams
06:58:31 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:58:32 <dmhouse> ?hoogle elem
06:58:33 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
06:58:33 <lambdabot> Array.elems :: Ix a => Array a b -> [b]
06:58:33 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
06:58:41 <koala_man> thanks
06:58:50 <metaperl> > 5 `elem` [1..10]
06:58:54 <lambdabot>  True
06:59:16 <dmhouse> Templar2: a fold combines adjacent elements using the function you give it. So the function has to take two arguments, which are the adjacent elements to combine at each step.
06:59:30 <dmhouse> Templar2: did you look at that fold diagrams page I linked you to?
06:59:34 <allbery_b> foldr runs the function with the seed and the last element of the list, and saves the result as the new seed; then runs the function on the new seed and the next-to-last element of the array and saves it, and so on until it has processed the entire list, then returns the final "seed"
06:59:55 <dmhouse> Some examples might help.
06:59:57 <metaperl> dmhouse - it combines the accumulator with an element... not necessarily adjacent elements
07:00:07 <metaperl> @type foldl
07:00:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:00:08 <dmhouse> metaperl: oops, right.
07:00:12 <metaperl> :)
07:00:12 <dmhouse> > foldr (+) 0 [1..10]
07:00:13 <lambdabot>  55
07:00:25 <dmhouse> Actually, let's start smaller.
07:00:28 <allbery_b> bit early for all of us, I guess :)
07:00:34 <dmhouse> > foldr (+) 0 [1..4]
07:00:35 <lambdabot>  10
07:00:48 <dmhouse> That fold computes 0 + (1 + (2 + (3 + 4)))
07:01:21 <dmhouse> Using that example, you should be able to follow allbery_b's exaplanation.
07:01:24 <allbery_b> hm, guess I got mine backwards.
07:01:30 * allbery_b looks for coffee...
07:01:37 <dmhouse> No, I'm wrong again, aren't I.
07:01:59 <dmhouse> Yes I am.
07:02:09 <dmhouse> It computes 1 + (2 + (3 + (4 + 0)))
07:02:11 <jethr0> it does (1 + (2 + (3 + (4 + 0))))
07:02:15 <metaperl> I'm trying to follow the install instructions here: http://haskell.org/http/  ... but I have a binary ghc and dont have runhaskell
07:02:16 <lambdabot> Title: Haskell HTTP package
07:02:25 <dmhouse> Hey jethr0, haven't seen you around in a while.
07:02:38 <allbery_b> odd. binary ghc installs should include runhaskell
07:02:39 <jethr0> foldl does: ((((0+1)+2)+3)+4)
07:02:41 <dmhouse> metaperl: try runghc instead. Or symlink runhaskell to runghc
07:03:06 <metaperl> ah yes, runghc is there... RUN-DMC is not ... heheh
07:03:08 <dmhouse> metaperl: or just chmod +x the file and run it normally.
07:03:10 <jethr0> haven't seen you in a long time either. i've been busy with finishing my degree, moving and looking for a job :)
07:03:28 <jethr0> there are nice diagrams by dons somewhere on the wiki
07:03:44 <metaperl> no, Cale has the nice fold diagrams
07:03:46 <jethr0> http://haskell.org/haskellwiki/Fold
07:03:46 <dmhouse> jethr0: you mean http://cale.yi.org/index.php/Fold_Diagrams? I believe they're Cale's.
07:03:48 <metaperl> at http://cale.yi.org
07:03:50 <lambdabot> Title: Fold Diagrams - CaleWiki
07:03:50 <lambdabot> Title: Fold - HaskellWiki
07:03:53 <jethr0> sorry, i meant cale then
07:03:54 <lambdabot> Title: Main Page - CaleWiki
07:04:00 <kowey> there's also http://foldr.com and http://foldl.com
07:04:02 <lambdabot> Title: foldr.com
07:04:30 <metaperl> YAHT covers folds
07:04:53 <edi> ?go universality of fold
07:04:54 <dmhouse> Hehe.
07:05:02 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
07:05:03 <edi> Good paper.
07:05:12 <velco> what's the recommended package/library for doing "binary IO", say for processing Java class files or ELF files ?
07:06:16 <jethr0> what do you mean by binary IO? anything in excess of Data.Bytestring/Data.Bits + IO?
07:06:32 <LoganCapaldo> erlang?
07:06:35 <dmhouse> ?google Streams Bulat Haskell IO
07:06:35 <LoganCapaldo> heh
07:06:35 <lambdabot> search module failed: IRCRaised connect: does not exist (No route to host)
07:06:39 <dmhouse> Wonderful.
07:06:45 <lisppaste2> metaperl pasted "runghc lacks environment variable" at http://paste.lisp.org/display/33431
07:06:53 <dmhouse> edi: try googling for those terms.
07:07:13 <dmhouse> metaperl: you have one weird-ass system.
07:07:15 <edi> (BTW I'm xerox, nice to see you again.)
07:07:24 <metaperl> dmhouse - why?
07:07:26 <dmhouse> metaperl: your $PATH is missing.
07:07:37 <dmhouse> edi: oh, hey, xerox :) Nick change?
07:07:56 <dmhouse> edi: try echo $PATH at a terminal.
07:08:11 <lisppaste2> metaperl annotated #33431 with "I do have a PATH variable" at http://paste.lisp.org/display/33431#1
07:08:11 <jethr0> hey xerox, had a sex change? ^_^
07:08:14 <edi> Why should I try all this stuff?
07:08:17 <velco> thanks, I'll check these.
07:08:22 <edi> jethr0 - no.
07:08:32 <LoganCapaldo> metaperl: Are you running it from cron or similar?
07:08:39 <metaperl> LoganCapaldo - no shell
07:08:43 <metaperl> no, from the shell
07:08:53 <dmhouse> edi: oops, my message for you was meant to be for velco. velco, try those search terms.
07:08:58 <jethr0> just kidding. didn't you want to affiliate yourself with the cool guys from xerox alto park any more?
07:09:12 <velco> dmhouse: yep, I got it.
07:09:56 <dmhouse> ?hoogle bracket
07:09:57 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:09:57 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
07:09:57 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
07:10:13 <dmhouse> ?index bracket
07:10:14 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
07:23:04 <dmhouse> shapr: ping, if you're around.
07:30:00 <benja_> if I have import Control.Monad.State (..., StateT, ...), why do I get 'not in scope: data constructor StateT'?
07:30:15 <benja_> I.e., how can I import the constructor as well as the type?
07:30:19 <allbery_b> you need to import the constructor as well
07:30:21 <dmhouse> benja_: that only imports the type constructor.
07:30:29 <dmhouse> StateT(..) imports all its constructors
07:30:36 <monochrom> StateT(StateT)
07:30:40 <dmhouse> (Why are you using the StateT constructor anyway?)
07:30:42 <benja_> thanks!
07:30:57 <monochrom> To deconstruct it
07:30:57 <dmhouse> kowey: ping.
07:31:02 <dmhouse> monochrom: runStateT.
07:31:35 <benja_> dmhouse: maybe there's a better way; here's what I'm doing:
07:31:37 <benja_> type VV a = StateT VVState (ListT (State (Scene Node))) a
07:31:42 <benja_> choose xs = StateT $ \s -> ListT (return [(x, s) | x <- xs])
07:32:36 <dmhouse> choose xs = do s <- get; ListT (return [(x, s) | x <- xs]), perhaps?
07:32:54 <dmhouse> The point is you're meant to use get and put instead of the bare constructors.
07:33:22 <kowey> dmhouse: hiya
07:33:33 * benja_ works through that :)
07:33:47 <dmhouse> kowey: did you write the denotational semantics stuff?
07:34:13 <kowey> dmhouse: heavens, no! (i am in the middle of reading and learning it though)
07:34:18 <kowey> it was apfelmus
07:34:32 <monochrom> denotational very elegant
07:34:48 <kowey> from my ignorant standpoint, it looks like a nice chapter
07:35:05 <dmhouse> Yeah, I'm just puzzled at one point. I'll add it to the talk page.
07:35:51 <kowey> sigh... it's one of my points of self-consciousness (among networks and databases).  I don't get it... programming lang semantics was soooo easy in undergrad
07:36:06 <kowey> took the same course a couple years later at masters level, and went smack in the face
07:36:09 <kowey> not so easy
07:36:16 <dmhouse> It says 'neither 1 [= 2 not 2 [= 1' hold, where [= is \sqsubseteq.
07:36:51 <augustss> dmhouse: yes, and what's puzzling you?
07:37:00 <dmhouse> But it doesn't explain why. I get that 1 [ 2 and 2 [ 1 are both nonsensical, but I would have thought that they're equal when you use [ to compare them.
07:37:20 <monochrom> partial order
07:37:22 <augustss> they are incomparable
07:37:26 <dmhouse> In fact, a couple of sentences later it says '1 and 2 are different in information content but the same in information quantity.'
07:37:46 <dmhouse> augustss: yes, but why? Why not say they're equal?
07:37:47 <AStorm> But the results of the equasions are not the same.
07:37:55 <monochrom> You have seen another partial order.  {0} does not \subseteq {1}, etc.
07:38:01 <benja_> dmhouse: type error, because the (ListT ...) is not in the VV monad (it's not wrapped in StateT)
07:38:03 <augustss> because they give you different information
07:38:06 <allbery_b> "more defined than" relates only to the quantity, no the content
07:38:17 <AStorm> augustss, exactly
07:38:45 <augustss> dmhouse: you could invent some other order where they are equal.  but it would not make much sense in denotational semantics
07:38:48 <dmhouse> benja_: err, sorry, try placing 'return' before 'ListT'.
07:39:05 <monochrom> "same in information quantity" is only going to manifest in having same distance from _|_
07:39:06 <benja_> dmhouse: that returns in the VV monad
07:39:12 <augustss> dmhouse: unless you want the program "print 1" and "print 2" to be considered equal
07:39:19 <dmhouse> But then that sentence I quoted seems to contradict that.
07:39:26 <AStorm> dmhouse, it does not
07:39:36 <dmhouse> [ only refers to definedness, not the actual meanings, right?
07:39:43 <AStorm> yes.
07:39:44 <augustss> no
07:39:47 <monochrom> also "same in information quantity" turns out to be unimportant.
07:39:50 <AStorm> Actually, both
07:39:53 <benja_> dmhouse: equality w.r.t. [ is actual equality
07:39:56 <augustss> yes, both
07:40:00 <monochrom> [ only refers to [= and /=
07:40:02 <benja_> otherwise you'd have a preorder, not a partial order :)
07:40:58 <benja_> (a [= b && b [= a ==> a = b) is what a partial order has that a preorder doesn't
07:41:14 <monochrom> [= is a partial order.  1 [= 1
07:41:22 <dmhouse> So a [ b means 'b is more defined than a' and a [= b means 'b is more defined than a, or they're the same program and have the same definedness.'
07:41:52 <augustss> dmhouse: yes (you can remove the word program)
07:42:20 <augustss> dmhouse: you can also read it as 'a approximates b'
07:42:20 <dmhouse> Okay.
07:42:27 <dmhouse> I think I get why, actually.
07:42:34 <monochrom> 1=2 is absurd
07:43:07 <dmhouse> If it wasn't required that they were the same program, then the stuff about partial functions being monotone mappings between posets breaks down:
07:43:18 <monochrom> you could define a metric with m(1)=m(2), but it's useless.
07:43:40 <monochrom> values
07:44:15 <dmhouse> if you have h with h(_|_) = 1, then you could have h(n) = 2 for all n /= _|_ and this would be allowed as _|_ [= n and 2 [= 1.
07:44:17 <benja_> you can also think about it this way: a program can distinguish between two values iff they are incomparable
07:44:43 <dmhouse> So you can't say 2 [= 1, the only things that can go on the LHS of that expression are 1 and _|_.
07:45:00 <dmhouse> So h must return 1 or _|_ for everything.
07:45:09 <dmhouse> I.e. must be constant or partially constant.
07:45:54 <benja_> so if a and b are comparable, you cannot do case x of a -> foo; b -> bar
07:46:08 <benja_> so it's good that 1 and 2 are incomparable :)
07:47:40 <monochrom> In the scheme of denotational semantics, the semantic function maps programs to the semantic domain.  The poset is applied to the semantic domain side, not the program side.
07:48:34 <monochrom> So when we say "not (1 [= 2)", we are saying this on the values 1 and 2 in the semantic domain, not on the programs 1 and 2.
07:50:39 <augustss> monochrom: but the ultimate goal is to be able to say things about the programs.  otherwise there wouldn't be much point in having a semantics
07:51:05 <monochrom> Yes. But talk to any denotational guy, and that is going to be what he insists.
07:51:19 <quazimodo> why cant i use backspace in ghci??
07:52:02 <monochrom> 1+1 is not equal to 2, but [|1+1|] = [|2|]
07:52:21 <kowey> quazimodo: you can (at least, i can)... what happens when you try to use it?
07:52:35 <augustss> monochrom: oh, I agree
07:52:38 <quazimodo> gives me the thingi thingi
07:52:39 <quazimodo> lemme get it
07:52:45 <monochrom> The con is that it looks like hair splitting.
07:52:50 <quazimodo> ^[[A
07:53:05 <quazimodo> srry thats up
07:53:05 <monochrom> The pro is that it permits giving multiple semantics to the same syntax.
07:53:08 <quazimodo> ^H for backspace
07:53:15 <augustss> but observing the program 1+1 makes you see the same thing as observing 2
07:53:40 <quazimodo> 1+1 = 3 for large values of 1
07:53:54 <Philippa> and small values of 3
07:53:57 <augustss> or floating point
07:54:01 <kowey> quazimodo: what os are you using, btw?
07:54:07 <monochrom> That is captured by [|1+1|]=[|2|].  Henceforth all programs are put inside [| |] in the theory.
07:54:14 <quazimodo> fbsd
07:55:19 <kowey> quazimodo: i found a thread which might interest you: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg10827.html
07:55:21 <lambdabot> Title: Bad control characters in GHCi 6.6 (Mac OS X PPC), http://tinyurl.com/y4t4uw
07:55:24 <kowey> quazimodo: readline?
07:56:43 <monochrom> The correct haskell saying is: 1+1=3 for large values of +.
07:56:55 <monochrom> > let 1+1=3 in 1+1
07:56:56 <lambdabot>  3
07:57:09 <AStorm> monochrom, you cheated
07:57:20 <monochrom> for large values of (+)
07:57:58 <augustss> > let 1 + (+) = 3 in 1+1
07:58:00 <lambdabot>  3
07:58:03 <AStorm> monochrom, redefine let too :P
07:58:10 <AStorm> > let let=1 in let
07:58:11 <lambdabot>  Parse error
07:58:24 <AStorm> Blah :P No freeform for you.
07:58:30 <augustss> AStorm: this is Haskell, not PL/1
07:58:36 <allbery_b> heh
07:58:48 <quazimodo> fucking nerds :/
07:58:49 <quazimodo> haha
07:58:50 <monochrom> PL/I would rock.
07:58:55 <quazimodo> im just foolin'
07:59:06 <augustss> PL/I still rocks!
07:59:47 <AStorm> PL/I is still rocks?
08:00:13 <allbery_b> hm, ghc port on my fbsd6.2pre box includes readline as a dependency
08:00:26 <AStorm> For ghci
08:01:18 <augustss> There must be some PL/I programs out there still.  On IBM mainframes
08:01:36 * allbery_b was checking to see if maybe it auto-excluded readline if it wasn't already installed
08:02:48 <sorear> no, hehehe
08:03:16 <sorear> I tried to install a GHC 6.4.2 binary bundle and it failed because I don't have libreadline.so.4
08:03:16 <quazimodo> guys illput on ghc 5 instead of 6.4
08:03:19 <quazimodo> is that a decent idea
08:03:38 <sorear> hexedit saved my day
08:03:45 <AStorm> quazimodo, no no no.
08:03:49 <AStorm> 6.2 at least
08:04:01 <AStorm> ghc 5 is antique
08:04:15 <sorear> how 'bout 0.29? :)
08:04:24 <kowey> if you bsd'ers sort this out, it might be worth putting a note on http://www.haskell.org/haskellwiki/BSD
08:04:26 <lambdabot> Title: BSD - HaskellWiki
08:05:27 <quazimodo> AStorm, really?
08:05:41 <AStorm> quazimodo, see the release notes :-)
08:06:06 <LPhas> I have binding with FFI against a C library to cabalize, how can make Cabal check for the C library?
08:06:44 <Lemmih> LPhas: Delegate to a configure.ac script.
08:07:14 <sorear> you may wish to look at e.g. hopengl
08:07:15 <syntaxfree> so this is the problem.
08:07:19 <LPhas> Lemmih: oh, ok
08:07:20 <syntaxfree> My parents' problem, actually.
08:07:26 <quazimodo> AStorm, which release notes?
08:07:32 <AStorm> quazimodo, of GHC 6
08:07:44 <syntaxfree> They sell stuff.
08:07:47 <syntaxfree> Stuff they make.
08:07:57 <syntaxfree> (Music sheet, actually, but irrelevant).
08:08:06 <syntaxfree> My mom sends them over snail-mail.
08:08:10 <AStorm> Lemmih, uh.. that'd be a bit over the top
08:08:34 <syntaxfree> So she keeps a detailed log (a handwritten log, no less) of things she sells over the phone, payments and shipping.
08:08:35 <AStorm> I also want to cabalize some FFI, but requiring perl... seems yucky.
08:08:48 <syntaxfree> I want to build a system that can extract statistics from that.
08:08:59 <pejo> Astorm, autotools doesn't require perl.
08:09:04 <syntaxfree> The best I could think of is to invent a text-based format à la INI.
08:09:18 <syntaxfree> So she could type in directly in a text editor. I'm not sure that's the perfect idea, though/.
08:09:25 <AStorm> pejo, they do, though not directly
08:09:36 <AStorm> For rebuilding.
08:09:46 <AStorm> autoreconf and stuff
08:09:59 <sorear> uh... I thought it used M4?
08:10:14 <sorear> nm
08:10:14 <syntaxfree> of course, it'll be all written in Haskell.
08:10:22 <pejo> sorear, it does.
08:10:34 <sorear> mg `which autoreconf` gives #! /usr/bin/perl -w
08:10:42 <sorear> hence nm
08:10:57 <kowey> syntaxfree: would it not be easier for your parents to use spreadsheet software?
08:11:00 <AStorm> IT does, but autotools themselves use perl. You can of course provide the configure shell script yourself.
08:11:15 <syntaxfree> kowey: she needs two kinds of info from that log.
08:11:19 <AStorm> syntaxfree, or just Comma-Separated Values?
08:11:24 <syntaxfree> One is her shipping/payment control.
08:11:33 <syntaxfree> The other one is statistics. Sales by product, yadda yadda yadda.
08:11:41 <syntaxfree> It's not really ammenable for tabular entry.
08:11:49 <AStorm> Both are best done in a spreadsheet :P
08:11:49 <syntaxfree> It's somewhat hierarchical.
08:12:00 <kowey> because of the first need, right?
08:12:00 <syntaxfree> ah, yes. What I want is her to entry info just once.
08:12:02 <AStorm> Or in a database + reports.
08:12:31 <syntaxfree> well, yeah. But then I'd need to dick around in MySQL and some language that can use it.
08:12:38 <syntaxfree> Or learn HaskellDB.
08:13:05 <pejo> Astorm, if people want to rebuild your configure scripts I think you should count them as developers - and they should have perl installed.
08:13:06 <syntaxfree> also, I'd need to make her a GUI somehow, maybe web-based.
08:13:16 <quazimodo> can haskell use opengl and use it well?
08:13:21 <sorear> yes.
08:13:25 <sorear> ?where Frag
08:13:26 <lambdabot> http://www.haskell.org/haskellwiki/Frag
08:13:37 <quazimodo> as in, could i make an ut2004 in haskell>
08:13:52 <AStorm> pejo, uh... I find that old configure scripts tend not to run on current Unices :P
08:14:00 <kowey> syntaxfree: do you have a timeframe for this?
08:14:05 <sorear> ^^^ someone's thesis, 3d opengl game in haskell (dunno how they convinced their advisor to take it)
08:14:13 <pejo> Astorm, odd. I find that new configure scripts don't run on old unices either.
08:14:15 <kowey> (i have no suggestions to offer, btw, just questions)
08:14:15 <syntaxfree> not really. I just told them I'd see if I could think up something.
08:14:22 <AStorm> pejo, yes :>
08:14:26 <syntaxfree> If not, she'll just keep doing separate handwritten logs.
08:14:32 <sorear> autoconf is evil.
08:14:37 <pejo> Astorm, people write unportable code. The only thing you can do about it is to write portable code yourself.
08:14:41 <AStorm> sorear, yes, cmake rocks ;-)
08:14:47 <kowey> well... i dunno, part of me says that she should continue doing that
08:14:54 <kowey> because it's highly intuitive and robust
08:14:56 <sorear> Less evil than the alternatives, maybe, but still, autoconf is deeply evil.
08:14:56 <syntaxfree> I read that as "unsupportable code".
08:15:11 <AStorm> pejo, I hoped that cabal can just check if some gcc -o sometest -lthat sometest.c works
08:15:18 <AStorm> Which is all Autoconf does :P
08:15:29 <syntaxfree> kowey: well, yes. I basically thought of turning the sales log into a semi-regular text format I can write parsers for.
08:15:29 <kowey> but perhaps not very scalable, or convenient
08:15:31 * sorear quotes Zawinski's Law
08:15:48 <pejo> Astorm, um, what confgiure scripts does depends on how you write your tests. I like to adjust my LDFLAGS for example.
08:16:30 <AStorm> Anyway, I'll use Haskell C compiler, I mean the one Haskell uses.
08:16:41 <syntaxfree> kowey: it's just what she's already doing, in a text editor.
08:16:50 <syntaxfree> It's just that it seems like such an odd solution.
08:16:54 <pejo> (And if you don't do anything funky, that works straight out of the box with any configure script).
08:17:02 <syntaxfree> Designing a mini-language for business logging.
08:17:22 <AStorm> pejo, does it work with Haskell-compiled code? :P
08:17:53 <kowey> syntaxfree: do you think there might be pre-existing accounting/small business software which could do the job?
08:18:06 <pejo> Astorm, unsure. I had to quit my old job to take my current one, so haven't done much package maintainance for the last couple of years.
08:18:20 <syntaxfree> kowey: I don't know.
08:18:26 <kowey> syntaxfree: then again, might be a good chance to learn some practical haskell, the web stuff, for example
08:18:28 <syntaxfree> The product line is oddly hierarchical, as well.
08:18:37 <pejo> Astorm, but I guess it's rather easy to fix, if one has the motivation and time.
08:18:39 <syntaxfree> There are thousands of specific songs in music sheet with the same price.
08:18:49 <syntaxfree> Then there are some books, with different prices.
08:19:16 <kowey> so there are things, things have prices, and things belong in groups
08:19:16 <AStorm> Anyway, if I were to use some external tool, I'd use cmake and not autoconf.
08:19:23 <kowey> dose the hierachy go up several levels?
08:19:42 <kowey> *does
08:19:43 <syntaxfree> well, not really.
08:19:48 <syntaxfree> they'd like to have sales stats for songs.
08:20:04 <syntaxfree> Which they currently don't. The information is in the logs, it's just inaccessible in handwritten form.
08:20:52 <pejo> Astorm, for the stuff you write you're free to use whatever tools you like. Whenever I come by the oddballs - if they don't work straight out of the box I drop it instead of fixing it.
08:21:17 <AStorm> cmake isn't all that unknown :P
08:21:22 <AStorm> (fortunately)
08:21:43 <AStorm> And it generates Makefiles.
08:21:51 <AStorm> Anyway.
08:22:05 <AStorm> Is there a possibility... oh yes, simple.
08:22:11 <kowey> syntaxfree: what kind of queries do they want to make? "which songs are moving well?"
08:22:22 <syntaxfree> yes.
08:22:44 <AStorm> Just require the build of a nice test Haskell program with some c-files
08:22:48 <syntaxfree> A query  language is not really needed, I can write specific programs on the spot if I'm clever enough about the base libraries.
08:23:03 <kowey> right... query in the large sense
08:23:06 <syntaxfree> I know it sounds like a job for a relational database.
08:23:32 <syntaxfree> I'd have to write a lot of stuff in that model, though, and she'd have to adjust her workflow as well.
08:23:43 <AStorm> Not really, it's too simple. Unless by "relational database" you mean SQLite.
08:24:01 <syntaxfree> I'd have to write a GUI for her somehow.
08:24:18 <AStorm> wxHaskell? GTK?
08:24:25 <kowey> minimising adjustment does seem like an important criterion... she might have a very good workflow already
08:24:35 <syntaxfree> she does.
08:24:40 <kowey> autoforms might be fun
08:24:57 <kowey> http://autoforms.sourceforge.net/
08:24:59 <lambdabot> Title: AutoForms
08:25:05 <kowey> (uses wxHaskell)
08:25:10 <syntaxfree> I want to minimize both coding and adjustment.
08:25:41 <AStorm> These look quite nice.
08:26:08 <kowey> i'm sorry i can't be of much use... your problem interests me because it looks like a pretty good instance of the question
08:26:28 <kowey> "what is the wisest way to attack this problem"... one where you have to consider all sorts of factors, some of which non-technical
08:27:11 <syntaxfree> I kinda have a solution -- the text-based minilanguage  -- but it sounds just so heterodox.
08:27:33 <kowey> it is a low cost solution for you (parsec)
08:27:44 <kowey> might be worth just trying it and learning from experience
08:27:51 <AStorm> It sounds like COBOL :P
08:27:57 <kowey> problem is perhaps taking you parents along for the ride :-(
08:28:12 <quazimodo> wxwidgers or gtk2hs??
08:28:20 <LPhas> Lemmih : I never used make, autconf, automake and so on, can you give me an hint on where to begin?
08:28:21 <syntaxfree> well, if it all goes wrong she can always print out her textfile logs and glue them to her notebook.
08:28:26 <quazimodo> ?
08:28:31 <kowey> (and thanks for the new vocab)
08:28:51 <AStorm> LPhas, uhhh... The AutoBook ;-)
08:29:00 <AStorm> Other than that, respective webpages.
08:29:12 <kowey> i'd go for the text-based minilanguage if you think you can assure robustness
08:29:30 <AStorm> He can't, hehe. Been there, done that.
08:30:11 <AStorm> Either it will be unusable or too bloated.
08:30:20 <LPhas> AStorm, thx.
08:30:23 <AStorm> Not everybody is a programmer, you know.
08:30:29 <syntaxfree> kowey: my parents still use a form of hungarian notation for classifying files. They fear directory structure might get lost through repeated backup / restore somehow.
08:31:01 <kowey> they're afraid they might confuse themselves and "misplace" a file?
08:31:04 <syntaxfree> p-as-time-goes-by.mus is "As time goes by" for piano, g-as-time-goes-by.mus is the same for guitars.
08:31:17 <syntaxfree> well, they're afraid of general information lossage.
08:31:27 <yaxu> does programming in haskell ever get faster?  i'm ending up with nice compact code but the time spent per line is rather high...
08:31:27 <syntaxfree> So I could teach them to use some limited syntax.
08:31:52 <kowey> i am developing a sort of respect for your parents :-)
08:31:54 <syntaxfree> yaxu: Haskell code is highly reusable. That's a big advantage.
08:31:57 <AStorm> Very limited. It'll be hard to design a language for them though.
08:32:16 <yaxu> i guess i'm still cargo cult programming, and i'll get faster when i understand things better
08:32:19 <syntaxfree> kowey: they're really bad web designers. I hope that doesn't ruin your respect :)
08:32:41 <syntaxfree> My parents are composers as well. If you're curious, you can check out some of their stuff.
08:32:46 <kowey> heh...
08:32:58 <syntaxfree> http://www.navarro.mus.br/compositores/
08:33:03 <syntaxfree> the english website isn't ready yet.
08:33:09 <syntaxfree> you have to click on the spanish one I'm afraidl
08:33:26 <kowey> it's a bit shiny
08:33:44 <syntaxfree> my dad learned HTML at some summer course.
08:33:57 <syntaxfree> He writes really awful awful HTML.
08:34:30 <yaxu> syntaxfree: nice lensflare!
08:34:33 <AStorm> But he can actually write HTML, not just use some tool? That's ok.
08:34:51 <syntaxfree> yaxu: ah, yes. he uses Corel Draw I think.
08:35:03 <kowey> The things people do with HTML... makes me think of Ze Frank's ugly Myspace contest
08:35:39 <kowey> bad HTML sucks in terms of ... well... "our" tastes... but in terms of non-programmers being empowered... it's pretty cool
08:36:29 <AStorm> One just needs some nice tool producing standardish HTML. Like nVu.
08:36:38 <AStorm> With modifiable CSS.
08:37:17 <AStorm> Though programming is more fun ;-)
08:37:28 <kowey> AStorm: how do you think syntaxfree should attack this sales stats problem? any take on it?
08:38:03 <syntaxfree> it's really cringe-worthy to see such an ammount of information being lost in a handwritten notebook and just used for recent sales control.
08:38:23 <syntaxfree> Most of our family's financial info is scattered over that notebook, and yet we can't use it.
08:39:13 <yaxu> http://www.hermann-uwe.de/files/images/programmer_hierarchy.png # where does haskell go?
08:39:35 <AStorm> I'd risk using those AutoForms. Myself, I think these things are amenable to being hacked quickly in Python, wxPython and SQLite. (but that's just me)
08:39:37 <syntaxfree> Haskell is powered by PhD. Haskell is outside the hierarchy. Haskell is the pie in the sky.
08:40:10 <syntaxfree> Larry Wall has said only McArthur Genius Award winners manage to learn Haskell.
08:40:15 <AStorm> Haskell is by the Lisp probably :P
08:40:50 <AStorm> And it's incorrect, because Python programmers usually think Python is better than Perl or Ruby :P
08:40:53 <syntaxfree> Other programming language leaders also like to say stuff to the effect that one needs to be bloody smart to even write "Hello world" in Haskell. Somehow, they think it's an insult.
08:41:17 <jethr0> larry wall should try learning perl anew, than he'd be a little less cynical about other languages :)
08:41:32 <syntaxfree> I think C# programmers regard themselves higher than C++ programmers as well.
08:41:34 <sorear> I for one love the fact that there are no stupid newbies in #haskell.
08:41:47 <jethr0> since when has a steep learning curve been a bad thing for programmers?
08:42:18 <AStorm> So program in some kind of portable assembler. E.g. Haskell :P
08:42:21 <Philippa> Haskell goes in a triad alongside lisp and asm coders there
08:42:49 <syntaxfree> I think Haskell might go above.
08:42:52 <Philippa> syntaxfree: I think it depends on the C# and C++ coders
08:43:05 <Philippa> lispers and asm coders do both often look down on haskell coders as well
08:43:11 <jethr0> hehe, i'm not so sure how many major applications are written in assembly any more
08:43:12 <kowey> sorear: eh... i dunno... one of Haskell's strengths is the superfriendly community
08:43:14 <AStorm> I wonder why :P
08:43:16 <allbery_b> funny, I think of C as portable assembler.  (of course it's less true of that overweening ANSI C stuff :)
08:43:22 <AStorm> What about "all-coders"? :>
08:43:27 <syntaxfree> When you mention certain aspects of Lisp Haskell doesn't have to Haskellers, they just say "meh, template Haskell".
08:43:31 <Philippa> though I've managed to fend off my local lisp advocates to an "OK, I can see there being value for you in sticking with Haskell"
08:43:33 <syntaxfree> Philippa: oh, do they?
08:43:51 <Philippa> syntaxfree: there are significant things Lisp can do that Haskell can't do anywhere near as easily
08:43:52 <syntaxfree> They don't even have category theory-derived feature names!
08:44:01 <Philippa> many of these are by design in each direction, of course
08:44:08 <AStorm> Yes.
08:44:15 <AStorm> That's why I'm language-agnostic
08:44:15 <syntaxfree> yes. Lisp is fundamentally a bottom-up language.
08:44:22 <AStorm> Though I don't know all of them :P
08:44:23 <syntaxfree> FP/closures/HOFs are just an aspect of that.
08:44:29 <jethr0> Philippa: true, but macros as a prime example aren't exactly statically typed in lisp ^_^
08:44:37 <sorear> I use a language that was designed to be used by *humans*.
08:44:40 <SamB_XP> @quote TimToady
08:44:40 <lambdabot>  learning Haskell itself is easy--I've done it several times already
08:44:51 <AStorm> sorear, so it isn't Haskell? :PP
08:44:57 <Philippa> jethr0: right. This is /also/ by design :-)
08:45:00 <SamB_XP> (TimToady is Larry Wall)
08:45:27 <jethr0> true
08:46:05 <jethr0> timtoady - there is more than one awayto do yt
08:46:11 <AStorm> I for one find Data-oriented programming a bit awkward in Haskell
08:46:20 <syntaxfree> Our pedantism score as a community is surprisingly low, for what we have.
08:46:37 <SamB_XP> jethr0: that was TIMTOWTDI
08:46:39 <syntaxfree> If Ruby advocates had what we have, they'd be off the wall.
08:46:55 <syntaxfree> @quote TimToady
08:46:55 <AStorm> SamB_XP, that's TimToady phonetically
08:46:56 <lambdabot>  learning Haskell itself is easy--I've done it several times already
08:47:01 <SamB_XP> AStorm: true
08:47:01 <Philippa> I think it's partly that we have a good sense as to what to be pedantic about
08:47:17 <Philippa> also, understanding the concept of isomorphism and how it differs from weaker relationships helps a lot
08:47:41 <Philippa> it probably has a lot to do with why people don't get jumped for saying "this is a function that takes two parameters..."
08:47:44 <AStorm> Yes, but doesn't help you program quickly ;-)
08:47:57 <Philippa> (except newbies who generally get jumped exactly /once/ while being taught to read types)
08:48:02 <syntaxfree> Philippa: I think it's more because so many of us are in academic environments surrounded by real smart people, as opposed to working in sweatshops surrounded by brainless Java humanoids.
08:48:08 <Philippa> AStorm: no, but it helps you avoid bugs
08:48:21 <Philippa> syntaxfree: that's nice, I'm just at home most of the time
08:48:34 <AStorm> Yes. Then you don't need bug checking all that much.
08:48:44 <jethr0> Philippa: what's wrong with that sentence? do you mean functions always have one argument, or what?
08:48:45 <Philippa> but yes, because it means less office politics-style stupidity
08:48:58 <SamB_XP> Philippa: also, it is easier to say that than "this is a function taking one parameter that returns a function that takes one parameter that returns [...]"
08:49:09 <Philippa> jethr0: right, that. Except that there's an isomorphism so it's no biggie
08:49:23 <AStorm> "This is a function of two arguments" is more correct :>
08:49:45 <syntaxfree> "(+)" is a function of two arguments.
08:49:47 <Philippa> SamB_XP: right, we all know we /think/ about n-parm functions and partial applications most of the time
08:49:48 <jethr0> yes, and there aren't caused that many ambiguities by saying that either
08:49:53 <AStorm> syntaxfree, indeed
08:49:54 <syntaxfree> (+1) is a function of one argument.
08:49:58 <AStorm> Yes.
08:50:09 <Philippa> syntaxfree: yep. So's (+)
08:50:28 <AStorm> So, + is a function of two arguments or less
08:50:37 <sorear> ... or more.
08:50:39 <AStorm> But that's just an implementation detail
08:50:46 <Philippa> ...no, not really
08:50:57 <sorear> if the NumericPrelude ppl get their way...
08:50:58 <AStorm> It is. Most languages don't work that way :P
08:50:59 <syntaxfree> it's a function of precisely two arguments, in the sense that you don't get a value if you don't give it exactly two values.
08:51:00 <jethr0> (<+>) = \x -> \y -> x+y
08:51:01 <Philippa> "just an implementation detail" isn't an isomorphism
08:51:21 <SamB_XP> syntaxfree: you are arguing that it won't work if I pass it *three*?
08:51:23 <AStorm> Machines work that way though :P
08:51:25 <Philippa> syntaxfree: FCVO "value" that don't entirely match the one in the H98 report :-)
08:51:33 <AStorm> Of course it won't.
08:51:37 <syntaxfree> > (+) 1 2 3
08:51:39 <lambdabot>  add an instance declaration for (Num (t -> a))
08:51:41 <sorear> instance Num a => Num ((->) x a) where (a + b) c = a c + b c  -- three arg +
08:51:57 <SamB_XP> well, obviously I'd need that instance declaration ;-)
08:52:06 <jethr0> syntaxfree: in haskell (+) is a binary infix operator. unlike in lisp where it can have arbitrarily many arguments
08:52:10 <syntaxfree> Haskell (+) is not the same as Lisp (+)
08:52:19 <sorear> Lisp (+) is ZERO.
08:52:25 <sorear> Always.
08:52:25 <AStorm> Indeed.
08:52:38 <SamB_XP> heh
08:52:40 <jethr0> never tried that. well, maybe on an empty list
08:52:51 <jethr0> > sum []
08:52:52 <lambdabot>  0
08:52:58 <sorear> > product []
08:53:00 <lambdabot>  1
08:53:11 <syntaxfree> sum is defined in the prelude as foldr (+) 0
08:53:20 <SamB_XP> hmm. that means you don't really need numeric literals in lisp.
08:53:22 <syntaxfree> > foldr (+) 0 []
08:53:23 <lambdabot>  0
08:53:26 <AStorm> Maybe, maybe it's implemented in C.
08:53:30 <AStorm> Implementation detail
08:53:35 <syntaxfree> Maybe it's actually implemented in C.
08:53:37 <SamB_XP> AStorm: you are kidding
08:53:41 <syntaxfree> But it has a formal definition that must be respected.
08:53:48 <SamB_XP> AStorm: that would be *too much work*
08:54:05 <sorear> Hugs is, GHC isn't.
08:54:07 <syntaxfree> Whether it's implemented in C or whether there's a poor chinese man answering all requests from the Haskell compiler.
08:54:16 <AStorm> Might be, might not. If you have a nice library to handle all the basic and combined types...
08:54:46 <SamB_XP> I'd like to see a proof of correctness for a poor chinese man, thank you ;-)
08:54:49 <AStorm> Actually, it's simpler than that.
08:54:58 <syntaxfree> The fact remains that sum is *defined*  as foldr (+) 0, and whatever  way you find of calculating it, it must act like foldr (+) 0 for every argument you give it.
08:55:11 <AStorm> SamB_XP, he's almost surely correct, given infinite time to count
08:55:13 <jethr0> > let f [] = sum []; f (x:xs) = (product []) + f xs in f [1..5]
08:55:14 <sieni> > foldr (+) (foldr (+) 0 []) []
08:55:15 <lambdabot>  5
08:55:16 <lambdabot>  0
08:55:33 <sorear> SamB: I'd like to see a proof of correctness for a 30,000 line haskell program (GHC).
08:55:53 <SamB_XP> sorear: but the chinese man was only supposed to be implementing *sum*
08:55:54 <syntaxfree> I'd like to see a proof of correctness for my self-esteem.
08:55:58 <AStorm> Well, the code itself is probable :P
08:55:59 <syntaxfree> Do I value myself too high? Too slow?
08:56:04 <AStorm> *probably
08:56:05 <Philippa> syntaxfree: what's relevant there is the definition in the standard of the Prelude, rather than the version which ships with a given interpretation (which may not be the same)
08:56:35 <syntaxfree> well, if there's a chance that some compiler might interprete "sum" as something diffferent, I'm scared.
08:56:40 <syntaxfree> I thought I understood "sum".
08:56:53 <AStorm> > let sum=0 in sum [1,2,3]
08:56:53 <SamB_XP> syntaxfree: it must do the same thing
08:56:54 <lambdabot>  add an instance declaration for (Num ([a] -> a1))
08:56:54 <lambdabot>   In the definition of ...
08:56:56 <SamB_XP> which is why
08:57:00 <AStorm> > let sum=product in sum [1,2,3]
08:57:02 <lambdabot>  6
08:57:03 <syntaxfree> "interprete" probably should be "interpret"?
08:57:03 <SamB_XP> I don't trust the chinese man to do it right
08:57:05 <AStorm> :P
08:57:12 <Templar2> can someone explain what '.' is in haskell?
08:57:16 <sorear> composition
08:57:30 <Templar2> ?
08:57:30 <sorear> > ( (+1) . (*10) ) 15
08:57:31 <lambdabot>  151
08:57:34 <sorear> > ( (+12) . (*10) ) 15
08:57:35 <lambdabot>  162
08:57:39 <sorear> > ( (+12) . (*20) ) 15
08:57:39 <syntaxfree> '.' is both function composition and a part of a qualified name.
08:57:40 <lambdabot>  312
08:57:41 <syntaxfree> that's a wart.
08:57:45 <AStorm> It takes two functions and returns a composition of them.
08:57:47 <kowey> Templar2: (f . g) x is like (f (g x))
08:57:59 <syntaxfree> Templar2: ( f . g ) x == f (g  x)
08:58:05 <syntaxfree> like that little 'o' in mathematics.
08:58:34 <Templar2> aha, ok, thanks =)
08:58:35 <kowey> and what's neat about that is that you can just think of (f . g) as a function
08:58:37 <AStorm> (Yes, I shall be damned for using that language) :>
08:58:50 <kowey> foo = f . g (ooooh)
08:58:57 <AStorm> Except that composition is not necessarily reversible
08:59:09 <syntaxfree> I think there really isn't a good Haskell tutorial yet.
08:59:16 <AStorm> Yes, there isn't.
08:59:23 <AStorm> There are some good books.
08:59:25 <syntaxfree> One that really reaches people who don't expect foo =f . g work.
08:59:30 <AStorm> Though no tutorial.
08:59:31 <syntaxfree> there are?
08:59:38 <AStorm> YAHT is a nice one.
08:59:41 <syntaxfree> Ones that reach people who did Pascal in high school?
08:59:50 <syntaxfree> YAHT is one of the best, possibly the best.
08:59:56 <jlouis> The best FP book is one written for SML
09:00:05 <jlouis> which is rather sad, because it is damn good
09:00:11 <AStorm> FP is quite simple if you rewrite it in math :P
09:00:12 <syntaxfree> a really good tutorial is Why's Poignant Guide to Ruby.
09:00:15 <jlouis> ML For the working programmer. L.C. Paulson
09:00:17 <syntaxfree> We have nothing equivalent to that.
09:00:24 <Templar2> is YAHT a book or page?
09:00:34 <jlouis> both
09:00:42 <kowey> ?where yaht
09:00:42 <AStorm> Book, available in PDF. And a page :P
09:00:42 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
09:00:43 <syntaxfree> YAHT is available for download in PDF, or it can be browsed on the web.
09:00:47 <Templar2> thx
09:00:53 <kowey> see also http://en.wikibooks.org/wiki/Haskell/YAHT
09:01:19 <syntaxfree> @where dons
09:01:19 <lambdabot> http://www.cse.unsw.edu.au/~dons
09:01:24 <syntaxfree> heee heee.
09:01:32 <syntaxfree> I wish I could add myself to the where database.
09:01:36 <arcatan> hmm, I guess there is no nice and portable serial port libs for Haskell?
09:01:37 <syntaxfree> (lambdabot uses an external db engine?)
09:01:47 <dylan> no
09:01:48 <jethr0> syntaxfree: yes, why's poignant guide is pretty cool. SICP is nice too, though and as a non-newbie i'm quite happy with "craft of programming", YAHT and "Gentle Introduction"
09:01:48 <SamB_XP> syntaxfree: you can't ?
09:01:53 * syntaxfree 's machine has no serial ports.
09:01:59 <Philippa> I suspect a really /good/ Haskell book need to include at least an appendix on set theory and functions, and possibly one on a little light category theory with examples covering things like initial algebras as well
09:02:08 <dylan> @ where+ syntaxfree...
09:02:15 <syntaxfree> Philippa: that is so true.
09:02:16 <SamB_XP> @help where+
09:02:17 <lambdabot> where+ <key> <elem>. Define an association
09:02:36 <syntaxfree> @where+ syntaxfree http://syntaxfree.wordpress.com
09:02:37 <lambdabot> Done.
09:03:14 <AStorm> Philippa, well, you're right
09:03:23 <syntaxfree> SICP is more of a general programming course than a Scheme course.
09:03:29 <syntaxfree> Then again, learning Scheme is easy.
09:03:43 <syntaxfree> A good tutorial can be written in about 10 pages.
09:03:43 <AStorm> General programming course in Haskell is much like a math course :P
09:03:47 <sorear> arcatan: define 'nice'.  You should be able to open /dev/ttySx, and there is a binding to POSIX termios.
09:03:53 <AStorm> On set and category theory.
09:04:26 <AStorm> Same with Python, though it has more features.
09:04:28 <Philippa> possibly a third appendix on denotational semantics, which'd cover things like the World type as well
09:04:43 <AStorm> Philippa, that's outside a simple tutorial.
09:04:58 <syntaxfree> AStorm: not really.
09:05:14 <syntaxfree> the thing is, newbies come along and see stuff like
09:05:19 <syntaxfree> @pl f x = f (f x)
09:05:19 <lambdabot> f = fix (join (.))
09:05:28 <Philippa> a little, but not by much. And the value in having been introduced to it's pretty high
09:05:28 <syntaxfree> now explain that based on YAHT.
09:05:42 <SamB_XP> Philippa: I think denotational semantics is the easiest to figure out as you go along
09:05:53 <Philippa> "pl stands for pointless, treat accordingly"
09:06:03 <syntaxfree> heh :)
09:06:08 <syntaxfree> ok, ok. point conceded.
09:06:10 <ski> (syntaxfree : which one is "Kieburtz (1999)" ?)
09:06:12 <metaperl> Philippa - point-free, perhaps?
09:06:20 <dylan> pl reminds me of perl. :)
09:06:24 <syntaxfree> ski: "Codata and comonads in Haskell", or something like that.
09:06:25 <metaperl> the YAHT section on Named Fields is solid gold
09:06:43 <SamB_XP> metaperl: it is a jokey name
09:06:45 <syntaxfree> I have a really bad pdf produced by a broken ps2pdf. Diagrams are all futzed up.
09:06:45 <AStorm> The code pl generates is really pointless
09:06:54 <Philippa> SamB_XP: probably, but having a pile of it in one place can help too. Also, the leap to treating monads as a language implementation exercise is a biggie
09:06:59 <AStorm> undo is also useless :P
09:07:06 <syntaxfree> undo?
09:07:07 <metaperl> pointless is subjective, point-free is technically verifiable :)
09:07:08 <syntaxfree> @help undo
09:07:09 <lambdabot> undo <expr>
09:07:09 <lambdabot> Translate do notation to Monad operators.
09:07:12 <sorear> ... and people are actually SCARED of (whatever syntaxfree is about to say)?
09:07:14 <yaxu> ok, what does @pl do?
09:07:26 <yaxu> @help pl
09:07:27 <lambdabot> pointless <expr>. Play with pointfree code.
09:07:37 <SamB_XP> it adds dots to your code
09:07:38 * syntaxfree chants "Do notation considered harmful" to the tune of "Bring me old-time religion"
09:07:43 <AStorm> Or removes.
09:07:56 <yaxu> automagically converts to point free?
09:07:59 <Philippa> "Do notation considered harmful" considered old-time religion?
09:08:11 <jlouis> yaxu, yes. Its not that hard to do
09:08:25 <yaxu> seems clever to me
09:08:25 <AStorm> It will be harmful on fully parallel machines.
09:08:30 <jlouis> though I often find code squashed through @pl is unreadable
09:08:38 <syntaxfree> Bind-notation considered old-time religion, old-time religion being valued to people who sing "Bring me old-time religion".
09:08:41 <AStorm> I'd love a distinction like in VHDL
09:08:49 * syntaxfree heard that tune in a really bad film version of "Inherit the wind".
09:09:07 <AStorm> sequential code vs some instructions written one after another :P
09:09:26 <Philippa> syntaxfree: some context you may be missing - old-time religion tends to want to burn a number of people in this chan (myself included) at the stake
09:09:56 <Philippa> so it's not necessarily highly valued
09:10:08 <SamB_XP> Philippa: the stake is stupid
09:10:18 <syntaxfree> Philippa: I was just being playfully self-depreciative about my own defense of teaching bind notation first.
09:10:24 <AStorm> Hehe. Add @asbestos
09:10:30 <SamB_XP> also...
09:10:35 <syntaxfree> Apparently some people have started to nitice that and remember me specifically for that.
09:10:41 <Philippa> yeah, funny that
09:10:46 <syntaxfree> It's A Joke. "Oh, I'm such a stupid zealot".
09:10:50 <SamB_XP> any test for guilt that harms the *innocent* is stupid
09:10:53 * syntaxfree raises an index card. "A Joke".
09:10:57 <SamB_XP> (i.e. the float/sink test for witches)
09:11:02 <AStorm> How would one implement a parallel variant of do notation in Haskell?
09:11:09 <kowey> oh! you can pattern match against named fields?
09:11:13 <AStorm> (sequential one is done using arrows)
09:11:15 <Philippa> syntaxfree: yeah. Be warned: I play the straight woman online sometimes to compensate
09:11:17 <kowey> how did i miss that?
09:11:35 <ski> (syntaxfree : you have http://www.cse.ogi.edu/PacSoft/publications/ phaseiiiq10papers/codata.pdf yes ?)
09:11:38 <lambdabot> Title: Index of /PacSoft/publications
09:11:39 <syntaxfree> Philippa: now I think I lost some context.
09:11:43 <Philippa> kowey: it took me a long time to spot
09:12:13 <Philippa> syntaxfree: you're familiar with the comedy role of "the straight man"?
09:12:15 <AStorm> Hmm... I can think of parallel one using dots and functions returning Nothing
09:12:16 * SamB_XP wonders how long it took him to learn that
09:12:23 <syntaxfree> Philippa: no, I'm not.
09:12:33 <Philippa> right. STFW and all will become clear
09:12:40 <kowey> well, thank-you, metaperl, for causing me to look at the relevant yaht section
09:12:46 <SamB_XP> syntaxfree: are you *certain*?
09:12:52 <AStorm> At most one of the functions would be able to return something else than Nothing.
09:13:10 <SamB_XP> sylvan: I think maybe you are taking that role *now*!
09:13:11 <SamB_XP> er.
09:13:13 <SamB_XP> syntaxfree:
09:13:18 <SamB_XP> sorry sylvan
09:13:37 <syntaxfree> while we're on comedic roles, whenever I see the word "Nothing" in the context of the Maybe type, I remember "Seinfeld"
09:13:57 <AStorm> I find IO Nothing especially ironic.
09:14:11 <AStorm> "You are in a maze of passages, all alike"
09:14:24 <c01pb> q
09:14:30 <jlouis> maze of twisty little passages, all alike ;)
09:14:44 <jlouis> and then it begins to permutate the words
09:14:44 <Philippa> AStorm: no such value, 'mafraid
09:14:45 <AStorm> jlouis, yes, that's the complete version ;-)
09:14:51 <Philippa> (and no such type)
09:14:52 <AStorm> You can IO Nothing
09:14:58 <Philippa> you can return Nothing
09:15:04 <AStorm> There's also IO (), which means something else
09:15:08 <Philippa> and OK, you can declare a new type...
09:15:13 <nmessenger> ?type return Nothing :: IO Maybe Int
09:15:14 <lambdabot>   Kind error: `IO' is applied to too many type arguments
09:15:15 <lambdabot>   In the type `IO Maybe Int'
09:15:21 <AStorm> :>
09:15:30 <Philippa> nmessenger: parens around Maybe Int
09:15:33 <AStorm> IO (Maybe Int)
09:15:35 <nmessenger> ?type return Nothing :: IO (Maybe Int)
09:15:37 <lambdabot> IO (Maybe Int) :: IO (Maybe Int)
09:15:38 <syntaxfree> instance Show Maybe where show Nothing = ...
09:16:09 <AStorm> show Nothing = show "Nothing happens."
09:16:37 <nmessenger> AStorm: or, *something* happens, but Nothing results from it
09:16:54 <syntaxfree> it's a "show" aboutr Nothing.
09:16:59 <nmessenger> lol
09:17:01 <AStorm> That's why it's ironic :>
09:18:50 <syntaxfree> I would start a Slashdot-like rant on how Alanis Morrissette diluted the meaning of "ironic". But it's more ironic to allude to my intention instead of realizing it.
09:19:29 <Philippa> syntaxfree: there's always the question of whether the song itself was supposed to be ironic and if so whether or not it succeeded, too
09:20:13 <Philippa> for example, you might consider it was dense enough to resemble iron in that regard
09:20:15 <nmessenger> Philippa: I think such a sophisticated intention is unlikely in popular music
09:20:26 <syntaxfree> I didn't actually intend to start such a rant; I haven't given it thought.
09:20:48 <Philippa> nmessenger: I dunno, I think it's not much more sophisticated than Ebeneezer Goode was :-)
09:20:52 <syntaxfree> I thought it'd be funny to join together standard geek references (Slashdot and all) and speak about my thoughts as an observable process.
09:21:04 <nmessenger> ?google Ebeneezer Goode
09:21:06 <lambdabot> http://en.wikipedia.org/wiki/Ebeneezer_Goode
09:21:11 <syntaxfree> Self-referentiality is so self-referential.
09:22:07 * syntaxfree 's so meta he's always in beta.
09:22:34 <jlouis> syntaxfree, you name implies you should join #lisp or #scheme
09:23:10 <syntaxfree> my name is a Sonic Youth reference, but I appreciate the fact that it can always be construed as a reference to S-exprs.
09:23:59 <yaxu> alanis morrissette didn't write that song
09:24:32 <syntaxfree> my actual name isn't a Sonic Youth reference, just the nickname.
09:24:53 <sorear> I feel so young ... I've never heard of Sonic Youth
09:24:56 <SamB_XP> your real name being Unknown?
09:25:09 <syntaxfree> my real name can be found out on the internet.
09:25:20 <syntaxfree> the haskell blog has a link to my semi-professional blog about economics.
09:25:27 <LPhas> ?seen dons
09:25:27 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 4h 43m 37s ago.
09:25:38 <syntaxfree> I'm also the only idiot that mentioned his IRC nickname on the Communities and Activities Report.
09:25:58 <SamB_XP> how many non-idiots did?
09:25:58 <syntaxfree> (Other people might have done that, but they're probably not idiots)
09:26:01 <sorear> Uh ... dons never used his URL? :)
09:26:24 <syntaxfree> what _is_ #haskell.hac07?
09:26:35 <jlouis> hackathon of 07?
09:27:07 <syntaxfree> sorear: Sonic Youth is nice.
09:27:16 <syntaxfree> It's like, what if Igor Stravinsky had joined Nirvana as a bassist.
09:27:25 <syntaxfree> And wasn't allowed to do much.
09:27:34 <syntaxfree> And yet managed to sabotage the recording sessions somehow.
09:27:41 <Philippa> syntaxfree: I'm not particularly hard to spot, though I've kinda let Flippi die
09:28:09 <syntaxfree> Flippi?
09:28:11 <jlouis> Philippa, are you working on anything at the moment, or are you a lazy one like me?
09:28:30 <yaxu> you can append .org to my nick and find pictures of my cats
09:28:47 <syntaxfree> I found out today my teenage crush has become a cat lady.
09:28:47 <jlouis> As in: Whenever I start something, I stop again because I sense it will take ages to finish
09:29:33 <yaxu> syntaxfree: as in, a lady who owns a lot of cats?
09:29:37 <nmessenger> syntaxfree: she's turned in an anthropomorph?
09:29:47 <nmessenger> 'cause that would be cool
09:29:51 <benja_> lazy programmers make functional programs
09:29:51 <syntaxfree> I do things to the point where they're barely functioal and I proved myself that I oculd, if I wanted.
09:29:58 <SamB_XP> I am glad to be such an idiot that I will start things that I ought to know will take ages to finish
09:29:59 <Philippa> jlouis: I've got a smallish interpreter I should bundle up and release but I keep trying to add more features
09:30:08 <SamB_XP> so what if I *stop* again really soon...
09:30:16 <Philippa> admittedly a typechecker is kind of useful as features go :-)
09:30:19 <sorear> I tend to work on something, produce 0.1, and stop until someone (incl. me) expresses interest.
09:30:19 <jlouis> Philippa, oh for what language or thing?
09:30:30 <syntaxfree> I played the guitar until the point where I had semi-impressive chops that most people couldn't do, and proved to myself I could be a shreddy guitarrist if I wanted.
09:30:39 <SamB_XP> hmm, I think I only released a 0.0
09:30:42 <sorear> writing typecheckers is fun.
09:30:42 <Philippa> jlouis: currently an untyped CBV lambda calculus with let and integers
09:30:44 <syntaxfree> Programming is not different, except in a shorter time-scale per project.
09:30:58 <yaxu> i adopted my cats from a woman who used to be a model
09:31:13 <nmessenger> yaxu.org not found :(
09:31:22 <jlouis> Philippa, Ah. Last thing I did was a program inverter for a simple CBV LC with constructors, heh
09:31:41 <syntaxfree> It might be the only reason I haven't dropped Haskell already is that I'm not sure I can reach the level of some of the smarter Haskell programmers.
09:32:00 <yaxu> nmessenger: ulp
09:32:03 <syntaxfree> yaxu: models are sometimes cat ladies.
09:32:11 <yaxu> Expiration Date:22-Dec-2007 01:32:17 UTC
09:32:24 <syntaxfree> Not all models are celebrate-all-night people. Sometimes they're depressive types.
09:32:32 <sorear> computers have expiration dates? :)
09:32:34 * yaxu goes to give money to someone
09:32:42 <syntaxfree> I think there's some stereotype of loneliness and mild depressiveness in "cat lady".
09:32:44 <nmessenger> sorear: domains usually do
09:33:08 <nmessenger> cats are awesome!
09:33:15 <SamB_XP> yaxu: aren't you glad nobody took it, though?
09:33:26 <Philippa> that reads 2007, not 2006 though
09:33:30 <sorear> yea, cause 56.34.122.59 isn't good enough for yaxu :)
09:33:31 <SamB_XP> I think it is awful how they just let anyone buy expired domain names...
09:33:40 <SamB_XP> Philippa: oh, point
09:33:58 <sorear> I think its awful how we have a centralized DNS.
09:34:08 <syntaxfree> I'm thining of moving my professional blog to a host of my own at nearlyfreespeech.net
09:34:08 <AStorm> It's actually centralised.
09:34:14 <AStorm> *DEcentralised
09:34:19 <SamB_XP> well, if you don't pay your phone bill, nobody can take your name!
09:34:27 <syntaxfree> I'm basically stuck trying to figure out a nice domain name, though.
09:34:36 <sorear> ... but someone can take your phone number!
09:34:47 <SamB_XP> sorear: are you sure?
09:34:51 <nmessenger> SamB_XP: somebody could take your... darnit sorear!
09:35:00 <sorear> syntaxfree: look at pwgen/gpw/etc.
09:35:04 <AStorm> Actually, somebody _can_ take your name. Ever heard of identity theft?
09:35:13 <syntaxfree> sorear ?
09:35:15 <SamB_XP> AStorm: hmm, well, yeah. but that is *illegal*
09:35:26 <SamB_XP> domain name theft is perfectly legal -- that is the problem!
09:35:31 <AStorm> It's illegal, yes. But criminals don't care.
09:35:40 <nmessenger> syntaxfree: sorear said what I wanted to say
09:35:41 <sorear> syntaxfree: IMHO the random password generators make decent freshname generators
09:35:46 <AStorm> You can't steal an IP number, fortunately.
09:35:54 <jlouis> AStorm, wrong
09:36:00 <SamB_XP> yeah really
09:36:04 <AStorm> Collisions are well-handled in IP
09:36:06 <jlouis> In an ethernet, you just poison the ARP table
09:36:19 <jlouis> easy as pie
09:36:21 <sorear> well, Internet /= Ethernet
09:36:21 <AStorm> Yes, though that's not technically stealing.
09:36:23 <syntaxfree> sorear: I need something that's half-hackerly, half-slick.
09:36:34 <ropine> without a centralized domain-name system, you can't put your URL on the side of a bus and be confident that everyone who goes to that URL is going to see your page
09:36:36 <yaxu> i think your domain has to have been expired for a while before someone else can grab it
09:36:38 <syntaxfree> I am supposed to become an economist in a suit sometime soon.
09:36:42 <SamB_XP> usually though you didn't own it anyway
09:36:51 <AStorm> ropine, with a centalised dns, you can
09:36:56 <AStorm> *can't either
09:36:57 <syntaxfree> sorear: you could start an alternative domain registrar
09:37:11 <syntaxfree> You could also just write a web interface to a name-IP map.
09:37:14 <sorear> I do *not* want to be the hub of
09:37:24 <syntaxfree> "Websites dot org". Do it in Happs.
09:37:26 <SamB_XP> sorear: DHT for names!
09:37:33 <sorear> arggh, C-j is next to C-k !
09:37:42 <sorear> DHT?
09:37:47 <AStorm> sorear, bad Emacser! :P
09:37:53 <SamB_XP> distributed hash table
09:37:55 <sorear> oh, distributed hashtable ...
09:38:05 <jlouis> AStorm, on the Internet, you just need control of a couple of BGP feeds
09:38:12 <AStorm> jlouis, yep
09:38:15 <jlouis> then the stealing is a reality
09:38:35 <AStorm> But then, you have enough bandwidth not to have to :P
09:38:36 <syntaxfree> domain name suggestions anyone?
09:38:39 <sorear> AStorm: no, irc-II.  Pretty much every program that supports line editing and isn't called vi uses the emacs keys.
09:38:40 <ski> (syntaxfree : was it those that provided haskell on server ?)
09:38:43 <benja_> if anybody was curious about the monad transformer thingie I asked about earlier, where I didn't know how to avoid using the StateT constructor,
09:38:48 <syntaxfree> ski: yes.
09:38:56 <benja_> the solution was to use 'lift' :)
09:39:00 <syntaxfree> They're also strictly pay-per-megabyte-of-usage.
09:39:11 <syntaxfree> Since I have very low traffic, it's perfect for me.
09:39:19 <nmessenger> ?type lift
09:39:20 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
09:39:29 <AStorm> ?type liftM
09:39:32 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
09:39:32 <syntaxfree> I estimate spending something like US$40 or US$50 for the whole of 2007.
09:39:55 <sorear> gpw: dernouto ercenson eyradiva surtions turianat <-- if you want meaningless pronouncable names, this is your program
09:40:24 <sorear> It's supposed to be for passwords, but it does a decent job when I'm stuck on a naming problem.
09:40:36 <SamB_XP> heh
09:40:53 <AStorm> These sound like RPG names :P
09:41:12 <SamB_XP> so, you could use a fantasy name generator for passwords too?
09:42:22 <syntaxfree> sorear: I want meaningless pronounceable, but I also want it to apply to my future "suit" self and my hackerly self.
09:42:32 <nmessenger> yaxu: are you on flickr? http://www.flickr.com/photos/yaxu/page7/
09:42:34 <lambdabot> Title: Flickr: Photos from yaxu
09:43:10 <sorear> well, on general principles I don't recommend generating passwords with any of the CGI name generators...
09:44:29 <syntaxfree> sorear: I usually manage to think of nonsense pronounceable words myself, and then l33tsp34k them.
09:44:38 <syntaxfree> maybe just substitute a vowel or two.
09:45:01 <syntaxfree> (a vowel for the l33tspeak number.)
09:46:07 <sorear> ?elite lb can do this for you :)
09:46:08 <lambdabot> |B Can d0 7hI5 for joo :)
09:46:58 <nmessenger> What *can't* lambdabot do?  I'm starting to think she can bring about world peace.
09:47:09 <syntaxfree> @undo war
09:47:10 <lambdabot> war
09:47:13 <benja_> ?elite trust me with your passwords, I'm l33t
09:47:13 <lambdabot> TrU$7 M3 Wi+|-| YouR P4$5W0rdz, I'M l33T
09:49:40 <ropine> > MiddleEastPeace
09:49:41 <lambdabot>  Not in scope: data constructor `MiddleEastPeace'
09:49:53 <ropine> ah well, it was worth a try
09:50:05 <lambdabot> why do you think you want peace?
09:50:23 <syntaxfree> what's a good basic introduction to GADTs?
09:50:24 <lambdabot> good? not great?
09:50:26 <nmessenger> woah
09:50:26 <lambdabot> My sister likes Yahoo better. Her screenname is FoxxyGurl83. If you have yahoo you should message her, she's just as pretty as me :)
09:50:29 <SamB_XP> @unleet D4 P41|\| !!!
09:50:29 <lambdabot> Unknown command, try @list
09:50:45 <nmessenger> @un
09:50:45 <lambdabot> Maybe you meant: undefine undo unlambda unpf unpl unpointless run wn
09:51:02 <syntaxfree> @unpl fix . join
09:51:02 <lambdabot> (\ c -> fix (c >>= \ d -> d))
09:51:06 <sorear> Lambdabot's eliza-mode is fun...
09:51:26 <SamB_XP> sorear: heh
09:52:07 <SamB_XP> sorear: you turned on vixen mode?
09:52:30 <sorear> yes
09:52:30 <SamB_XP> ?vixen woah
09:52:31 <lambdabot> girls masturbate too you know... probably more than guys. we can do it anywhere discretely
09:52:51 <SamB_XP> ?vixen woah
09:52:52 <lambdabot> what do you want to know about me?
09:52:57 <jlouis> #haskell, not suited for minors
09:52:59 <ropine> ?vixen thank you for sharing
09:52:59 * nmessenger is not quite sure how to respond to that
09:53:00 <lambdabot> you're very welcome!
09:53:03 <AStorm> dons, you bastard :>
09:53:11 <wolverian> discretely, as compared to continuously?
09:53:22 <AStorm> Or maybe that's dylan
09:53:47 * nmessenger snickers at wolverian's observation
09:53:50 <SamB_XP> wolverian: no, as opposed to having either your hand down your pants or your penis sticking out the front
09:53:55 <sorear> Mark Wotton (blackdog)
09:53:55 <sorear>     * Vixen
09:54:02 <sorear> from AUTHORS
09:54:07 <AStorm> ROTFL.
09:54:19 <sorear> ?seen blackdog
09:54:19 <lambdabot> I saw blackdog leaving #haskell 1m 8d 14h 49m 16s ago, and .
09:54:31 <wolverian> SamB_XP, do you mean discreet?
09:54:41 <SamB_XP> oh, probably
09:54:54 <wolverian> pesky homophones.
09:54:56 <SamB_XP> I don't read like that
09:55:14 <SamB_XP> well, not unless I can't figure out the meaning *without* it
09:55:17 <wolverian> english is your native tongue?
09:55:31 <SamB_XP> anyway I didn't remember how to spell discreet ;-)
09:55:33 <SamB_XP> yes
09:55:40 <nmessenger> ?web1913 discrete
09:55:40 <sorear> LB is the answer
09:55:40 <wolverian> that explains it. ;)
09:55:47 <lambdabot> *** "Discrete" web1913 "Webster's Revised Unabridged Dictionary (1913)"
09:55:48 <sorear> nmess: <grr> :)
09:55:50 <lambdabot> Discrete \Dis*crete"\, a. [L. discretus, p. p. of discernere.
09:55:51 <nmessenger> ?web1913 discreet
09:55:51 <lambdabot>   See {Discreet}.]
09:55:53 <lambdabot>   1. Separate; distinct; disjunct. --Sir M. Hale.
09:55:55 <lambdabot>  
09:55:57 <SamB_XP> heh
09:55:57 <lambdabot> [23 @more lines]
09:56:03 <lambdabot> *** "Discreet" web1913 "Webster's Revised Unabridged Dictionary (1913)"
09:56:05 <lambdabot> Discreet \Dis*creet"\, a. [Compar. {Discreeter}; superl.
09:56:07 <lambdabot>   {Discreetest}.] [F. discret, L. discretus separated (whence
09:56:09 <lambdabot>   the meaning reserved, prudent), p. p. of discernere. See
09:56:11 <SamB_XP> apparantly americans spell it both ways anyway?
09:56:11 <lambdabot>   {Discern}, and cf. {Discrete}.]
09:56:13 <lambdabot> [16 @more lines]
09:56:32 <nmessenger> @more
09:56:35 <AStorm> Americans don't know what to spell, even less how to.
09:56:36 <lambdabot>   1. Possessed of discernment, especially in avoiding error or
09:56:36 <AStorm> :>
09:56:38 <lambdabot>    evil, and in the adaptation of means to ends; prudent;
09:56:38 <wolverian> no, the 'See ..' is because it's a homophone
09:56:39 <lambdabot>    sagacious; judicious; not rash or heedless; cautious.
09:56:41 <lambdabot>  
09:56:44 <lambdabot>       It is the discreet man, not the witty, nor the
09:56:46 <lambdabot> [11 @more lines]
09:56:46 <wolverian> if it was synonymous it'd say so
09:56:48 <SamB_XP> wolverian: oh, that is confusing!
09:56:55 <wolverian> SamB_XP, yes. I prefer wiktionary.
09:57:06 <wolverian> http://en.wiktionary.org/wiki/discreet
09:57:18 <SamB_XP> I don't think I would trust a dictionary written today
09:57:29 <syntaxfree> web1913 has a subtle elegance to it.
09:57:35 <syntaxfree> @web1913 elegance
09:57:38 <SamB_XP> at least, not by random people on the internet
09:57:42 <lambdabot> *** "Elegance" web1913 "Webster's Revised Unabridged Dictionary (1913)"
09:57:44 <lambdabot> Elegance \El"e*gance\, Elegancy \El"e*gan*cy\, n. [L. elegantia,
09:57:46 <lambdabot>   fr. elegans, -antis, elegant: cf. F. ['e]l['e]gance.]
09:57:48 <lambdabot>   1. The state or quality of being elegant; beauty as resulting
09:57:50 <lambdabot>    from choice qualities and the complete absence of what
09:57:51 <SamB_XP> @devils elegance
09:57:52 <lambdabot> [29 @more lines]
09:57:58 <lambdabot> No match for "elegance".
09:58:01 <syntaxfree> oh, there's a devil's dictionary?
09:58:02 <SamB_XP> @devils discreet
09:58:03 <lambdabot> No match for "discreet".
09:58:09 <SamB_XP> syntaxfree: yes!
09:58:10 <sorear> OK, who is taking alll this text from lambdabot?
09:58:15 <SamB_XP> @devils good
09:58:16 <syntaxfree> is there a complete Devil's Dictionary available online?
09:58:17 <lambdabot> *** "GOOD" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
09:58:17 <lambdabot> GOOD, adj.  Sensible, madam, to the worth of this present writer.
09:58:17 <lambdabot> Alive, sir, to the advantages of letting him alone.
09:58:17 <lambdabot>  
09:58:25 <sorear> the flood control *shouldn't* be active right now
09:58:34 <SamB_XP> sorry
09:58:47 <yax1> nmessenger: yes, those are my cats
09:58:59 <sorear> someone is /msg'ing lambdabot and consuming all the message tokens
09:59:07 <SamB_XP> oh?
09:59:12 <SamB_XP> flood control affects /msg?
09:59:13 <sorear> Lambdabot needs a better QoS system...
09:59:20 <AStorm> HFSC
09:59:21 <AStorm> :>
09:59:21 <sorear> sure
09:59:22 <SamB_XP> maybe a thread-per-channel?
09:59:33 <syntaxfree> message tokens are finite?
09:59:50 <AStorm> syntaxfree, yes, bandwidth indeed is finite
09:59:56 <AStorm> as is CPU time and memory
09:59:57 <uccus> > length [1..]
09:59:59 <syntaxfree> bandwidth, yes.
10:00:02 <lambdabot> Terminated
10:00:05 <SamB_XP> AStorm: tokens != bandwidth
10:00:06 <sorear> SamB: LB runs flood control at the same speed that RFC 2813 mandates servers do it, so if LB didn't freenode would.
10:00:12 <SamB_XP> oh.
10:00:23 <SamB_XP> I didn't realize flood control was cross-channel
10:00:23 <nmessenger> ?jargon message token
10:00:25 <lambdabot> No match for "message".
10:00:25 <lambdabot> No match for "token".
10:00:29 <syntaxfree> ah, lambdabot has queueing.
10:00:30 <SamB_XP> I thought it was per-person per-channel
10:00:33 <sorear> there is a semaphore deep in the heart of lambdabot
10:00:45 <AStorm> :D
10:01:02 <uccus> > undefined
10:01:04 <SamB_XP> sorear: interesting
10:01:05 <sorear> every two seconds, one point is signaled.  Every message, a point is waited.  At most 5 points can be accumulated
10:01:06 <lambdabot>  Add a type signature
10:01:10 <SamB_XP> that makes sense
10:01:20 <sorear> so lb will send 5 messages every 10 seconds
10:01:30 <SamB_XP> that is the first time I've heard of a good use case for semaphores
10:01:49 <uccus> > putStr (undefined :: String)
10:01:51 <lambdabot>  <IO ()>
10:02:13 <nmessenger> > undefined :: String
10:02:14 <lambdabot>  Undefined
10:02:19 <nmessenger> :)
10:02:47 <uccus> nmessenger: but I want lambdabot to go into an exponential search
10:03:07 <uccus> what's the best way to do it?
10:03:10 <AStorm> uccus, LB has a time limit :>
10:03:19 <AStorm> Per-command.
10:03:32 <uccus> ah... from the last experiment I guess the limit is less than 2 s or so
10:03:38 <uccus> > length [1..]
10:03:43 <lambdabot> Terminated
10:03:44 <syntaxfree> where can I learn more about semaphores?
10:04:14 <uccus> > let f = g; g = f in f
10:04:15 <lambdabot>  Add a type signature
10:04:25 <uccus> > let f = g; g = f in f :: Int
10:04:26 <lambdabot>  Exception: <<loop>>
10:04:29 <sorear> ?go semaphore
10:04:31 <lambdabot> http://en.wikipedia.org/wiki/Semaphore_(programming)
10:04:31 <lambdabot> Title: Semaphore (programming) - Wikipedia, the free encyclopedia
10:04:34 <uccus> cool
10:04:39 <pejo> syntax, Burns and Wellings, a black book with a sattelite on the front page.
10:04:46 <pejo> Oh, guess that works too. :-)
10:04:50 <SamB_XP> @help go
10:04:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:05:03 <sorear> uccus: you hit a blackhole, so there is no actual looping
10:05:04 <SamB_XP> isn't "go" someone else's search button?
10:05:12 <sorear> SamB: the command name in full is ?google
10:05:17 <SamB_XP> sorear: I know that
10:05:20 <SamB_XP> it just sounds funny
10:05:22 * syntaxfree can't go around buying too may books right now.
10:05:26 <syntaxfree> I have a large book queue.
10:05:29 <SamB_XP> (I *did* write the module, you know ;-)
10:05:39 <sorear> > let f x = g x ; g x = f x in f 0 :: Int   -- Uccus: this is what you want
10:05:52 <lambdabot>  Exception: <<loop>>
10:06:05 <SamB_XP> sorear: it is?
10:06:19 <sorear> > let f x = g (x+1) ; g x = f (x+1) in f 0 :: Int
10:06:21 <wolverian> http://en.wiktionary.org/wiki/Special:Export/discreet -- aaagh most useless schema ever
10:06:22 <lambdabot> Terminated
10:06:34 <sorear> Terminated means you hit the time limit.
10:06:36 <pejo> syntax, there is probably a better book about it out there, but a library near you should have that one.
10:06:38 <uccus> it is an exception thrown right away... or does she go into the loop and then discover it
10:06:55 <uccus> *is it
10:07:11 <uccus> > let f x = g x ; g x = f x in f 0 :: Int
10:07:12 <lambdabot>  Exception: <<loop>>
10:07:19 <sorear> Terminated: lambdabot is killed by an asynchronous exception, forkIO (threadDelay 15000000 >> killMe)
10:07:20 <SamB_XP> uccus: it has to reach a given thunk at least twice in order to notice the loop
10:07:45 <sorear> <<loop>>: it reaches a thunk while processing the same thunk, immediate exception
10:07:48 <nmessenger> :t threadDelay
10:07:49 <lambdabot> Not in scope: `threadDelay'
10:08:01 <uccus> samb_xp: but how does she know? does she keep track of _all_ the thunks?
10:08:02 <sorear> :t Control.Concurrent.threadDelay
10:08:03 <lambdabot> Int -> IO ()
10:08:17 <sorear> uccus: it's the STG machine
10:08:24 <nmessenger> are thoes microseconds?
10:08:32 <sorear> uccus: a thunk is represented by a function pointer and data
10:08:33 <nmessenger> s/thoes/those/
10:08:46 <uccus> oh... yeah sorry you were pretty clear on that (to sorear)
10:09:08 <sorear> uccus: when a thunk is entered, the function pointer is overwritten with the C equivalent of (error "<<loop>>")
10:09:18 <uccus> aaah
10:09:21 <uccus> cool trick!
10:09:27 <SamB_XP> sorear: eh.
10:09:30 <SamB_XP> sometimes!
10:09:46 <SamB_XP> well, sort of
10:09:59 <syntaxfree> 4:01 PM  pejo: syntax, there is probably a better book about it out there, but a library near you should have that one.
10:10:08 <syntaxfree> the library only has books in economics and statistics.
10:10:12 * SamB_XP tries to remember how lazy black-holing works
10:10:48 <sorear> of course overwriting takes time, and under ill-understood (by me) conditions it is omitted
10:10:49 <uccus> well, the thunk has to have identical data as well...
10:11:13 <uccus> I mean, if the parameters are different then it's not the same thunk
10:11:19 <SamB_XP> anyway, it won't run around for too long before it is noticed
10:11:31 <SamB_XP> uccus: actually, it has to be the same thunk
10:11:31 <syntaxfree> I think I don't know how to implement the "waiting" implied by semaphores in Haskell.
10:11:45 <sorear> ?source Control.Concurrent.QSem
10:11:45 <lambdabot> http://darcs.haskell.org/packages/base/Control/Concurrent/QSem.hs
10:11:54 <syntaxfree> okie. Thanks!
10:12:14 <uccus> samb_xp: yes, but then the trick of overwriting it doesn't work :|
10:12:24 <SamB_XP> uccus: hmm?
10:13:17 <liyang> > let f n = g n ; g n = f (1-n) in f 0 :: Int
10:13:19 <uccus> if to prevent a thunk from being evaluated, we overwrite the pointer with "error: loop" then calling the same thunk with different parameters doesn't work!
10:13:22 <lambdabot> Terminated
10:13:33 <SamB_XP> uccus: okay, I guess you don't know what a thunk is?
10:14:10 <uccus> samb_xp: I understand a "thunk" is an expression, so it has the parameters included, right?
10:14:11 <SamB_XP> a "thunk" is just an expression together with the values of its free variables
10:14:23 <nmessenger> a closure!
10:14:25 <SamB_XP> yes
10:14:27 <uccus> of it's free variables
10:14:34 <uccus> now it makes sense, sorry
10:14:35 <sorear> so a different expression must be a different thunk
10:14:46 <uccus> yeah, thanks
10:15:20 <uccus> [is it polite *not* to thank lambdabot? she works so hard... :(]
10:15:24 <SamB_XP> yeah. but there could be multiple thunks for the same expression, with the same values for the free variables.
10:15:30 <Syzygy-> lambdabot++
10:15:43 <sorear> ?karma lambdabot
10:15:43 <lambdabot> lambdabot has a karma of 41
10:15:58 <Syzygy-> uccus: you can always give karma or cookies.
10:16:13 <SamB_XP> @bot
10:16:14 <lambdabot> :)
10:16:14 <uccus> so entering a thunk twice _should_ fire the error?
10:16:29 <sorear> yes
10:16:32 <uccus> any exceptions?
10:16:35 <SamB_XP> uccus: only if you do it recursively
10:16:44 <dmhouse> lambdabot++ -- does this work now?
10:16:47 <SamB_XP> and sometimes it has to go around a few times before the error is noticed...
10:16:49 <dmhouse> ?karma lambdabo
10:16:49 <lambdabot> lambdabo has a karma of 0
10:16:51 <dmhouse> ?karma lambdabot
10:16:51 <lambdabot> lambdabot has a karma of 42
10:17:01 <uccus> yeah, _while_ the thunk is being evaluated, right/
10:17:04 <sorear> ?karma dmhouse
10:17:05 <lambdabot> dmhouse has a karma of 3
10:17:16 <SamB_XP> of course, it isn't really a thunk anymore after it has a value, is it...
10:17:21 <sorear> it only works at the bol, dmhouse++
10:17:23 <sorear> ?karma dmhouse
10:17:23 <lambdabot> dmhouse has a karma of 3
10:17:32 <dmhouse> sorear: ah, righto.
10:18:08 <LPhas> ?karma LPhas
10:18:09 <lambdabot> You have a karma of 0
10:18:12 <LPhas> d'oh
10:18:12 <uccus> I am still somewhat confused by this: and sometimes it has to go around a few times before the error is noticed...
10:18:15 <Cale> ?karma Cale
10:18:16 <lambdabot> You have a karma of 37
10:18:16 <sjanssen> hmm
10:18:23 <dmhouse> Cale: showoff :P
10:18:24 <sjanssen> I think this ++ stuff could use some love
10:18:27 <SamB_XP> uccus: well, don't worry
10:18:28 <Cale> ?karma dons
10:18:29 <lambdabot> dons has a karma of 104
10:18:34 <sorear> ?karma spj
10:18:34 <lambdabot> spj has a karma of 2
10:18:35 <dmhouse> Yeah, well.
10:18:37 <sorear> ?karma
10:18:37 <SamB_XP> you can't really tell the difference anyway
10:18:37 <lambdabot> You have a karma of 8
10:18:43 <Cale> hehe, I have a long way to go to reach dons' level :)
10:18:50 <sorear> ?karma shapr
10:18:50 <lambdabot> shapr has a karma of 34
10:18:53 <sorear> ?karma ndm
10:18:54 <lambdabot> ndm has a karma of 11
10:18:55 <uccus> [so does spj :p]
10:19:04 <SamB_XP> ndm++
10:19:07 <LPhas> seems like i've a lot of reincarnations waiting me
10:19:16 <sorear> ?karma SamB
10:19:16 <lambdabot> SamB has a karma of 22
10:19:17 <pejo> Heh, yeah, in spj's defense he isnt' actually *in* the channel.
10:19:19 <sorear> ?karma SamB_XP
10:19:19 <lambdabot> SamB_XP has a karma of 1
10:19:25 <syntaxfree> @karma lambdabot
10:19:26 <lambdabot> lambdabot has a karma of 42
10:19:36 <SamB_XP> @karma SimonM
10:19:36 <lambdabot> SimonM has a karma of 0
10:19:40 <SamB_XP> @karma JaffaCake
10:19:40 <lambdabot> JaffaCake has a karma of 9
10:19:42 <sieni> @karma Java
10:19:42 <lambdabot> Java has a karma of -2
10:19:43 <syntaxfree> @karma timtoady
10:19:44 <lambdabot> timtoady has a karma of 1
10:19:44 <Syzygy-> ?karma Syzygy-
10:19:45 <lambdabot> You have a karma of 1
10:19:46 <syntaxfree> who is JaffaCake?
10:19:47 <sieni> @karma java
10:19:48 <lambdabot> java has a karma of -15
10:19:49 <syntaxfree> @karma haskell
10:19:50 <lambdabot> haskell has a karma of 15
10:19:51 <sorear> simonm
10:19:53 <SamB_XP> don't change Java's karma, btw
10:19:55 <liyang> @karma C
10:19:56 <lambdabot> C has a karma of 2
10:19:56 <dmhouse> syntaxfree: Simon Marlow's nick.
10:19:56 <jethr0> @karma
10:20:02 <lambdabot> You have a karma of 1
10:20:05 <nmessenger> @karma Haskell
10:20:06 <dmhouse> liyang: because it only works at the BOL.
10:20:08 <lambdabot> Haskell has a karma of 8
10:20:15 <SamB_XP> probably a bad idea to touch it in either case...
10:20:18 <nmessenger> Haskell++
10:20:25 <dmhouse> And C++ doesn't get mentioned _that_ much.
10:20:28 <sorear> C++  -- besides, C is special-cased
10:20:30 <sorear> ?karma C
10:20:30 <lambdabot> C has a karma of 2
10:20:32 <uccus> nmessenger: ah c'mon!
10:20:40 <dmhouse> Hrm.
10:20:49 <dmhouse> C++
10:20:50 <dmhouse> ?karma C
10:20:51 <lambdabot> C has a karma of 2
10:20:57 <liyang> heh
10:20:58 <sjanssen> do we want the ability to write nick++ in the middle of messages?
10:20:59 <SamB_XP> @karma c
10:21:00 <lambdabot> c has a karma of 18
10:21:02 <SamB_XP> c++
10:21:03 <SamB_XP> @karma c
10:21:03 <lambdabot> c has a karma of 19
10:21:05 <jethr0> for (;*c++==*d++;) {}
10:21:05 <SamB_XP> hmm.
10:21:07 <sorear> curiously, lowercase c wasn't special kased
10:21:12 <SamB_XP> yes, curious
10:21:19 <SamB_XP> @karma SamB
10:21:20 <lambdabot> SamB has a karma of 22
10:21:23 <sieni> @karma
10:21:23 <lambdabot> You have a karma of 3
10:21:34 <uccus> but how to I increase the karma of C++?
10:21:35 <sorear> I say wasn't because the darcs-repo does special case 'c'
10:21:35 <nmessenger> @karma karma
10:21:41 <lambdabot> karma has a karma of 1
10:21:41 <uccus> (C++)++
10:21:52 <SamB_XP> @karma (C++)
10:21:53 <dmhouse> jethr0: loops forever incrementing those two pointers?
10:21:55 <lambdabot> (C++) has a karma of 0
10:21:56 <sorear> ?karma C++
10:21:56 <liyang> @karma coma
10:22:00 <sorear> ?karma C++
10:22:03 <lambdabot> C++ has a karma of 0
10:22:05 <lambdabot> coma has a karma of 0
10:22:06 <sorear> C++++
10:22:08 <sorear> ?karma C++
10:22:09 <lambdabot> C++ has a karma of 0
10:22:13 <jethr0> dmhouse: i just wanted to add to the channel frenzy...
10:22:15 <lambdabot> C++ has a karma of 1
10:22:20 <Syzygy-> Ah. Regex problems again, I guess.
10:22:25 <sorear> C++--
10:22:27 <liyang> ?karma coma
10:22:28 <sorear> ?karma C++
10:22:32 <liyang> bah
10:22:32 <SamB_XP> Syzygy-: huh?
10:22:33 <lambdabot> coma has a karma of 0
10:22:34 <uccus> ahh... thanks sorear
10:22:35 <lambdabot> C++ has a karma of 0
10:22:37 <SamB_XP> what is wrong with the regex?
10:22:43 <nmessenger> can a person have negative karma?
10:22:46 <sorear> Syzygy used to be immune to karma
10:22:47 <SamB_XP> anyway, using a regex was dons' idea!
10:22:51 <sorear> ?karma java
10:22:54 <lambdabot> java has a karma of -15
10:22:55 <sorear> &^^^ he does
10:23:02 <Syzygy-> We had to hack the regex for me to get karma at all.
10:23:06 <sorear> ?karma nmessenger
10:23:06 <lambdabot> nmessenger has a karma of 0
10:23:11 <sorear> nmessenger--
10:23:12 <sorear> ?karma nmessenger
10:23:13 <lambdabot> nmessenger has a karma of -1
10:23:15 <sorear> nmessenger++
10:23:17 <nmessenger> :(
10:23:19 <nmessenger> :)
10:23:35 <sjanssen> @type filter ("++" `isSuffixOf`) . unwords -- I think this should be the algorithm
10:23:37 <lambdabot>   Couldn't match `[Char]' against `Char'
10:23:37 <lambdabot>    Expected type: [String] -> [[Char]]
10:23:40 <uccus> oh by the way, merry christmas everyone!
10:23:52 <sjanssen> @type filter ("++" `isSuffixOf`) . words -- I think this should be the algorithm
10:23:53 <SamB_XP> sjanssen: well, we didn't want to do that
10:23:54 <lambdabot> String -> [[Char]]
10:24:10 <sjanssen> SamB_XP: how come?
10:24:16 <SamB_XP> > words "xs ++ [x]"
10:24:17 <sorear> sjanssen: dons likes patches
10:24:18 <lambdabot>  ["xs","++","[x]"]
10:24:21 <SamB_XP> well...
10:24:30 <SamB_XP> we didn't want Haskell code to confuse it...
10:24:33 <nmessenger> @karma xs
10:24:33 <lambdabot> xs has a karma of 1
10:24:49 <nmessenger> haha
10:24:51 <sjanssen> sorear: I'm well aware, just wanting to get some consensus
10:24:57 <sjanssen> SamB_XP: oh, good point
10:25:15 <SamB_XP> we didn't want xs getting too much karma ;-)
10:25:32 <nmessenger> samb_xp: and why not?  Karma for everyone!
10:25:42 <uccus> yay! christmas time!
10:25:48 <sorear> How much code in channel is semi-crunched? sj's algo isn't troubled by x++[xs] or x ++ [xs], only x++ [xs]
10:25:52 <sjanssen> thought that'd only happen if you use an inconsistent style "xs++ []" would match, but "xs ++ []" and "xs++[]" wouldn't
10:26:04 <SamB_XP> hmm.
10:26:09 <sorear> > words "xs++ [x"
10:26:09 <lambdabot>  ["xs++","[x"]
10:26:12 <sorear> > words "xs++[x]"
10:26:13 <lambdabot>  ["xs++[x]"]
10:26:17 <SamB_XP> well.
10:26:22 <SamB_XP> patches *are* welcome
10:26:39 <Syzygy-> > words "Syzygy-++"
10:26:40 <lambdabot>  ["Syzygy-++"]
10:26:51 <sjanssen> yeah, I'm going to make the patch, dons can decide whether he likes it
10:27:16 <uccus> well, what exactly happened to HIDE?
10:27:29 <nmessenger> ?what HIDE
10:27:29 <lambdabot> http://haskell.org/haskellwiki/HIDE
10:27:34 <dmhouse> It gets worked on when people can be bothered to work on it.
10:27:57 <uccus> the HIDE page claims it's orphaned
10:28:23 <dmhouse> The last time I saw it it had syntax colouring and Unicode support, but couldn't save a file.
10:28:56 <dmhouse> I think Lemmih mentioned GHC6.6 would mean that the first version could be released.
10:29:00 <dmhouse> Lemmih: ping, any comment?
10:29:25 <sorear> ?localtime Lemmih
10:29:27 <lambdabot> Local time for Lemmih is Tue Dec 26 19:25:10 2006
10:29:55 <uccus> strange
10:30:19 <uccus> ?localtime uccus
10:30:21 <lambdabot> Local time for uccus is Wednesday, December 27, 2006 5:24:43 AM
10:30:57 <syntaxfree> @localtime syntaxfree
10:30:57 <uccus> it amazes me. always.
10:31:41 <dmhouse> uccus: it sends a CTCP TIME. The magic's on the client side.
10:32:22 <uccus> dmhouse: I was referring to.. erm.. the fact that the world is round :| and has an international date line :s
10:33:53 <nmessenger> ?pl let K x y = x; S x y z = x z (y z) in S S K (S (K (S S (S (S S K)))) K)
10:33:59 <lambdabot> ap (ap ap (ap (ap ap const)) . const) (const (ap (const (ap ap (ap (ap ap const)))) const))
10:33:59 <lambdabot> optimization suspended, use @pl-resume to continue.
10:34:11 <sorear> nmessL K is const ; S is ap
10:34:14 <dmhouse> ?pl-resume
10:34:15 <lambdabot> ap (ap ap (ap (ap ap const)) . const) (const (ap ap (ap (ap ap const)) . const))
10:34:32 <nmessenger> I knew of const, but I didn't know ap
10:34:52 <uccus> :t ap
10:34:55 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:35:00 <sorear> ?pl-resume is a blatant lie.  Actually all it does is double the timeout and re-run ?pl.
10:35:00 <lambdabot> pointless: sorry, nothing to resume.
10:35:24 <uccus> maybe because ap has a cryptic signature?
10:35:34 <uccus> maybe because the monad here is (->) a?
10:35:38 <sorear> yes.
10:35:38 <dmhouse> nmessenger: ap is monadic ($) normally, but in the Reader monad reduces to Sxyz = xy(zy).
10:35:38 <uccus> is it?
10:35:47 <syntaxfree> the K cobinator is a projection.
10:36:02 <sorear> > ap (++) show"> ap (++) show"
10:36:04 <lambdabot>  "> ap (++) show\"> ap (++) show\""
10:36:19 <dmhouse> ?type ap
10:36:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:36:27 <sorear> . show run ap (++) show". show run ap (++) show"
10:36:35 <syntaxfree> wait, wait.
10:36:45 <sorear> ?. show run ap (++) show"?. show run ap (++) show"
10:36:46 <lambdabot> " \"?. show run ap (++) show\\\"?. show run ap (++) show\\\"\"\n"
10:36:47 <syntaxfree> in S x y z = x z (y z), x and y are functions?
10:36:57 <sorear> ?. read run ap (++) show"?. read run ap (++) show"
10:36:58 <lambdabot>  ?. read run ap (++) show"?. read run ap (++) show"
10:37:04 <benja_> tuukkah suggested on #fenfire that it would be a good idea to replace return values of (Maybe a) with return values of (Monad m => m a) (for given a)
10:37:10 <sorear> YES! that's what combinatory logic is all about
10:37:17 <benja_> any opinions on that?
10:37:17 <dmhouse> In the (->) a monad, ap :: (->) x (b -> b) -> (->) x a -> (->) x b.
10:37:30 <dmhouse> Err, that (b -> b) is meant to be (a -> b).
10:37:30 <sorear> better MonadZero.  Oh wait they removed that :( :(
10:37:49 <dmhouse> That is (x -> a -> b) -> (x -> a) -> x -> b
10:37:51 <syntaxfree> sorear: Well, but in K x y = x, it's just a projection combinator; x and y are values.
10:37:53 <dmhouse> Which is the type of S.
10:37:56 <benja_> sorear: hmm
10:38:24 <sjanssen> does the Perl6 channel use lambdabot?
10:38:31 <sorear> ?seen lambdabot
10:38:32 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah, #haskell, #Haskell and #
10:38:32 <lambdabot> ScannedInAvian
10:38:35 <benja_> could use monadplus -- but using fail allows for error messages
10:38:43 <wolverian> and #?
10:38:48 <sorear> sj: #perl6 is in that list
10:38:50 <uccus> > let S x y z = x z (y z) in S
10:38:51 <lambdabot>  Not in scope: data constructor `S'
10:39:04 <syntaxfree> let s x y z = x z (y z) in s
10:39:07 <sjanssen> okay, how might Perl use ++?
10:39:07 <sorear> uccus: variables must be lowercase
10:39:22 <sorear> perldoc perlop       # perl HAS ++
10:39:22 <nmessenger> syntaxfree: no Show for functions
10:39:28 <syntaxfree> I know.
10:39:34 <syntaxfree> What I don't know is what uccus is trying to do.
10:39:44 <sorear> :t let s x y z = x z (y z) in s
10:39:45 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
10:39:49 <uccus> ?pl let K x y = x; S x y z = x z (y z) in S S K (S (K (S S (S (S S K)))) K)
10:39:57 <lambdabot> ap (ap ap (ap (ap ap const)) . const) (const (ap ap (ap (ap ap const)) . const))
10:39:57 <lambdabot> optimization suspended, use @pl-resume to continue.
10:40:01 <wolverian> sjanssen, like sorear said, increment operator
10:40:08 <wolverian> both ++$foo and $foo++
10:40:09 <nmessenger> ?wikipedia Fixed-Point Combinator
10:40:11 <lambdabot> No Result Found.
10:40:16 <uccus> erm... sorear: then why does pl work?
10:40:23 <nmessenger> http://en.wikipedia.org/wiki/Fixed_point_combinator
10:40:27 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
10:40:28 <sorear> what do you mean?
10:40:30 <allbery_b> pl just manipulates symbols, it doesn't evaluate
10:40:43 <edi> ?pl ap ap ap
10:40:43 <lambdabot> ap ap ap
10:40:51 <uccus> the last ?pl command on let K x y = x; ... worked
10:40:52 <sorear> More importantly it doesn't type check.
10:40:53 <nmessenger> :t ap ap ap
10:40:54 <uccus> why?
10:40:55 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a
10:40:55 <lambdabot>    Expected type: (t -> a -> b) -> t -> a
10:41:01 <allbery_b> so it doesn't care that S isn't actually a legal function (actually, from its POV, it is;; just doesn't see any difference between a normal function and a type constructor)
10:41:02 <sorear> ?pl 1 + """
10:41:02 <lambdabot> (line 1, column 7):
10:41:03 <lambdabot> unexpected "\""
10:41:03 <lambdabot> expecting variable, "(", operator, "+", "-" or end of input
10:41:08 <sorear> ?pl 1 + ""
10:41:09 <lambdabot> 1 + []
10:41:13 <Syzygy-> @type ap (ap ap (ap (ap ap const)) . const) (const (ap ap (ap (ap ap const)) . const))
10:41:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = (b1 -> b) -> a -> b1
10:41:15 <lambdabot>    Expected type: ((b1 -> b) -> a -> b1) -> (b1 -> b) -> a
10:41:20 <sorear> I'll bet that's a type error :)
10:41:23 <sjanssen> wolverian: I'm rewriting lambdabot's ++ karma code.  If I filter out all matches that begin with "$", will that prevent inappropriate matches?
10:41:38 <dmhouse> sjanssen: why would that help?
10:42:02 * sorear mumbles at people who use funny characters in their nicks
10:42:33 <Syzygy-> I don't.
10:42:43 <Syzygy-> Or ... at least not very funny....
10:42:50 <sjanssen> dmhouse: "$xs++" wouldn't be interpreted as karma incrementation because it's a valid snippet of Perl code
10:42:53 <wolverian> sjanssen, for perl5 code, yes. in perl6 you write @foo[$index]++ and %foo{$key}++, so you'll want to filter those too.
10:42:54 <Botje> YESSS!
10:42:58 <\{syntaxfree}> I find it amazing that this is allowed.
10:43:01 <Botje> I finally finished ACM problem 101
10:43:08 <\{syntaxfree}> it makes for endless LaTeX nicknames.
10:43:14 <Syzygy-> Hehe
10:43:19 <Syzygy-> Doh.
10:43:22 <\\> Look at me! I'm an operator!
10:43:24 <Syzygy-> \! is not an allowed nick.
10:43:47 <yax1>  /nick ☃
10:43:54 <sjanssen> wolverian: thanks
10:43:54 <Botje> \\: so are you left- or right-associative?
10:43:55 <AStorm> No UTF-8 for you! ;-)
10:44:01 <uccus> erm... did I mean anything?
10:44:07 <uccus> did I miss anything?
10:44:09 <allbery_b> ! has meaning in IRC (the full identifier for a user is nick!realname@host)
10:44:15 <Syzygy-> Ah.
10:44:30 <uccus> S is ap in the (->) monad?
10:44:44 <edi> S is ap in the ((->) e) monad.
10:44:53 <allbery_b> most servers also reject ~, or at least leading ~, in realnames because that indicates whether identd worked (or didn't work?  I forget)
10:45:04 <LPhas> ?slap edi
10:45:05 * lambdabot smacks edi about with a large trout
10:45:09 <uccus> edi: thanks, that's what I asked actually
10:45:14 <Syzygy-> Heya yaxu
10:45:22 <allbery_b> although on the ircdused on freenode, it's x=... instead for various values of x
10:45:25 <Syzygy-> Happy $HOLIDAY
10:45:43 <yaxu> hi Syzygy-
10:45:50 <nmessenger> ?slap herself
10:45:50 * lambdabot slaps herself
10:45:50 <\\> s-f: IRC nicknames are strictly limited to 9 characters.  (read RFC 2812 if you don't believe me)
10:45:51 <\\> (now tell the dancer folks that)
10:46:08 <LPhas> lambdabot is a girl?!
10:46:11 <\\> yes
10:46:14 <AStorm> Well, that RFC is some years old
10:46:15 <nmessenger> ?where lambdabot
10:46:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:46:16 <LPhas> oh my
10:46:16 <lisppaste2> Botje pasted "My solution for ACM problem 101 (blocks world), comments?" at http://paste.lisp.org/display/33440
10:46:27 <\begin{syntaxfre> sorear: what I find bizarrest is qlines.
10:46:31 <yaxu> Syzygy-: thanks, you too!
10:46:46 <\begin{syntaxfre> Many nicknames are banned because of wildcard rules saying they're too close to "Nickserv", "Chanserv", etc.
10:47:07 <Syzygy-> qlines?
10:47:08 <AStorm> THey should've used Levenshtein distance :P
10:47:23 <\begin{syntaxfre> anyway, I've had perfectly honest nicknames qlined dozens of times.
10:47:55 <Syzygy-> Isn't Levenshtein that horrible thing that calculates a pseudo-sound-value based on some dialect of english?
10:47:59 <dmhouse> Botje: I'll have a look.
10:48:09 <allbery_b> that's Soundex
10:48:11 <sorear> syz: you're thinking of soundex
10:48:11 <nmessenger> syzygy-: that's soudnex
10:48:14 <Syzygy-> Ah
10:48:25 <Syzygy-> So, what's levenshtein then?
10:48:33 <sorear> levenschtein calculates the number of changes between words
10:48:35 <nmessenger> ?wikipedia Levenshtein distance
10:48:37 <lambdabot> No Result Found.
10:48:44 <sorear> "words" <-> "word" : 1
10:48:46 <sorear> "words" <-> "wordt" : 1
10:48:49 <sorear> "words" <-> "wordts" : 1
10:48:50 <sorear> "words" <-> "wordtz" : 1
10:48:52 <allbery_b> wikipedia spells it a little differently IIRC
10:48:52 <sorear> "words" <-> "wordtz" : 2
10:48:55 <dmhouse> Syzygy-: how many letters you have to change, insert or delete to change one word to another.
10:49:07 <nmessenger> http://en.wikipedia.org/wiki/Levenshtein_distance
10:49:11 <allbery_b> commonly called "edit distance" IME
10:49:12 <dmhouse> Botje: it would be the normal approach to set up a datatype to hold the commands.
10:49:16 <Syzygy-> Ah.
10:49:19 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Util.hs
10:49:46 <\syntaxfree{}> it's like a hamming distance.
10:49:46 <dmhouse> E.g. data Command = MoveOnto Int Int | MoveOver Int Int | PileOnto Int Int | PileOver Int Int
10:49:46 <Botje> dmhouse: yeah, but I didn't see much use in it for this problem
10:49:55 <dmhouse> | Quit, if you like.
10:50:11 <sorear> halfway down, the commented out naive definition is the clearest description of Levenschtein I've ever seen.
10:50:40 <sorear> Yes, the Haskell defn is clearer than the English ones...
10:50:55 <\syntaxfree{}> does the Levenshtein distance satisfy a triangular inequality?
10:50:59 <sorear> yes
10:51:05 <sorear> infact it's a full metric
10:51:18 <\syntaxfree{}> ohh. it induces a metric space of strings.
10:51:35 <Syzygy-> Nice
10:51:37 <\syntaxfree{}> is it worh studying metric spacs further?
10:51:57 <Syzygy-> Makes me start to think in terms of the topology on that space.
10:51:57 <newsham> http://roguestar.downstairspeople.org/
10:51:59 <lambdabot> Title: Roguestar
10:51:59 <\syntaxfree{}> the generality of the idea attracts me, but I also haven't seen anything useful come out from that.
10:52:03 <Syzygy-> Probably ends up being boring, since it'll be a discretely metric space.
10:52:24 <sorear> I forget what its called, but there is a thesis on using Levenschtein to metrize strings, and then storing spellchecker dictionaries  using BSP trees, for log-time spelling correction. (Very cool stuff.)
10:52:34 <Syzygy-> \syntaxfree{}: You find metric spaces general? o.O
10:52:48 <dmhouse> Botje: findStack could be in the State monad for consistency, and to avoid passing blocks.
10:52:55 * Syzygy- finds them highly specialized, almost to the point of being boring for that reason...
10:53:11 <\syntaxfree{}> well, they do impose important structure.
10:53:17 <sorear> Metric spaces are very general, compared to hilbert spaces.
10:53:20 <Botje> dmhouse: I'll try to fix that, then
10:53:28 <\syntaxfree{}> it's also very intuitive structure.
10:53:29 <sorear> Metric spaces are very restrictive, compared to topological spaces
10:53:40 <\syntaxfree{}> well, of course.
10:53:55 <\syntaxfree{}> anyway, is there any fun in metric spaces?
10:54:05 <\syntaxfree{}> any cool theorems, or whatever?
10:54:21 <Syzygy-> Nah. Most of them share their topological structures anyway. Boooooring. ;)
10:54:50 <dmhouse> Botje: in fact, findStack probably isn't that great itself. I bet there's some array function you could use that'd mean you didn't have to throw it into a list.
10:55:11 <\syntaxfree{}> my real analysis profs always made a point of teaching one class in metric spaces before moving on.
10:55:19 <\syntaxfree{}> it's very intuitive structure, but I don't know if it leads anywhere.
10:55:40 <sorear> According to what little I've understood in the topology book I'm trying to read, all metric spaces satisfying some minor constraint can be isometrically imbedded in infinite dimensional Hilbert space.
10:55:41 <AStorm> It leads to matrices :P
10:55:44 <uccus> syntaxfree: only because real analysis depends crucially on the metric
10:55:50 <dmhouse> Botje: hrm, well, actually, perhaps not.
10:55:52 <AStorm> sorear, indeed
10:56:02 <pejo> syntaxfree, someone at Diku has written an article about termination of transformations in hte metric space of trees.
10:56:06 <\syntaxfree{}> uccus: well, true. But then they fix a metric and move on with real analysis.
10:56:22 <dmhouse> But you could still write it as findIndex (x `elem`) (elems blocks)
10:56:26 <sorear> I've heard "#haskell is a better ##c than ##c".
10:56:27 <\syntaxfree{}> I'm wondering if metric spaces in general lead anywhere interesting.
10:56:33 <uccus> syntaxfree: hehe. didn't you know. all metric on the real space are equivalent!
10:56:34 <sieni> sorear: some minor constraint?
10:56:41 <sorear> Is it true that "#haskell is a better #math than #math?"
10:56:44 <\syntaxfree{}> on the real space, yes.
10:56:50 <sorear> sieni: seperable or somesuch.
10:56:53 <AStorm> sorear, might be
10:57:06 <sieni> sorear: how do you embed an arbitrary banach space isometrically into a hilbert space
10:57:15 <\syntaxfree{}> who cares about the real space anyway? ;)
10:57:20 <pejo> syntaxfree, http://citeseer.ist.psu.edu/223043.html
10:57:22 <lambdabot> Title: Convergence of Program Transformers in the Metric Space of Trees (ResearchIndex)
10:57:27 <sieni> sorear: separability a minor constraint?
10:57:36 <uccus> syntaxfree: that's why a metric space is in general boring
10:57:38 <sorear> compared to metricity?
10:57:44 <newsham> sorear: perhaps because people on #haskell know C and other important languages, but people on #c do not.
10:58:30 <Botje> dmhouse: what if I just return the (i,e) pair I get from the assocs? That way I don't have to look it up again after getting the index
10:59:05 <sieni> for example, L^\infty(R) isn't separable
10:59:41 <dmhouse> Botje: sure.
10:59:47 <uccus> sieni: what's that? Hilbert space with a .max. norm?
11:00:38 <pejo> syntax, the article seems to appeal the logic people more than the fp people though. Leuschel (sp?) has written a couple of articles citing it.
11:00:43 <uccus> sieni: or is the absolute value norm?
11:02:21 <dmhouse> Botje: I think it's pretty decent.
11:02:24 <sieni> it's not a hilbert space
11:02:45 <uccus> sieni: erm... what is it then?
11:02:47 <dmhouse> Botje: readCommands = fmap (map words . lines) getContents, a bit succincter.
11:02:52 <sieni> norm is the essential supremum of the absolute value of the function
11:03:13 <uccus> okay... :s
11:03:18 <Botje> dmhouse: thanks for the comments! I'll try to improve it a bit :)
11:04:35 <Modius> I have a question for anyone on here strong in lisp and Haskell (I'm fairly good in the former, about to learn the latter but understand some of its strengths) - there are some pros/cons of a language that you only find in using them - where in a project does haskell pay off over using lisp?  Have you ever incorporated both into a project together?
11:04:52 <Modius> Note:  I am not language trolling, and I have some understanding of pure FP.
11:05:07 <lisppaste2> Setzer pasted "spio" at http://paste.lisp.org/display/33441
11:05:40 <augustss> Modius: personally, the only thing in lisp that i would occasionally find useful is macros
11:06:37 <sieni> uccus: http://en.wikipedia.org/wiki/Lp_space#Lp_spaces
11:06:44 <araujo> hi!
11:06:55 <uccus> sieni: thanks
11:07:03 <sorear> !ih
11:07:27 <AStorm> Modius, hmm, I find Lisp looking more cluttered ;-) Other than that, it has more libraries.
11:07:35 <AStorm> Though not a lot more.
11:07:41 <Modius> Did you go from lisp to Haskell?
11:07:54 <AStorm> No, I'm language agnostic :P
11:07:58 <dmhouse> Modius: a lot of what you'd use Lisp macros for you can use things like HOFs and monads in Haskell.
11:08:00 <sorear> Haskell has #haskell, which is a major benefit.
11:08:16 <augustss> Modius: I've used Lisp and other untyped functional languages before Haskell.  but i so much prefer strong typing
11:08:18 <uccus> sieni: it's the maximum value then (almost)
11:09:09 <sylvan> Modius, I think lisp is slightly more elegant (as in "small core language"), but at the cost of readability and writabilty (yep, the "too many parenthesis" argument). The main benefit of Haskell though, is purity and static typing IMO.
11:09:17 <Modius> I consider the two, from what I see, best of breed for their respective paradigm.  Lisp, power to do everything, Haskell, obscene power + constraint - I see constraint of course as an advantage in writing things that are guaranteed to fit in a distributed paradigm.
11:09:45 <AStorm> Haskell could become even more powerful... but that'd be hellish :P
11:09:47 <Modius> I guess I'm looking not just at the languages, only mentioning them as they appear to be the most pure examples of their type.
11:10:13 <\syntaxfree{}> It should be interesting to implement monads in Lisp.
11:10:16 * ptolomy isn't really sure how one measures the power of a language. Political influence? Watts?
11:10:31 <pejo> ptolomy, turing completeness. ;)
11:10:31 <AStorm> \syntaxfree{}, useless? :P
11:10:42 <dmhouse> \syntaxfree{}: no type classes.
11:10:44 <AStorm> No, ease of use.
11:10:53 <\syntaxfree{}> well, yes. You could still write the functions and apply them around.
11:10:53 <Philippa> sylvan: haskell's "dynamic core" isn't much bigger than lisp's core, FWIW
11:10:59 <AStorm> (for certain tasks)
11:11:07 <\syntaxfree{}> What kills Lisp for me is strict evaluation.
11:11:13 <Philippa> (by "dynamic core" I mean what you have left if you strip out all the typechecking and the type declarations)
11:11:15 <nmessenger> Modius: I'm strong in neither, but the people here are friendly and will answer questions and try their best to educate.  I've not used any lisps, so I'm not qualified to say one is "better" than the other.  In any case, discussions of that sort are really hard to have objectively until you've *used* both a lot.
11:11:19 <Modius> Lisp's "power" is that its "syntax", or lack thereof, can technically represent anything.  But there is power in a static typed language, particularly one that enforces functional paradigm/isolates statechange (haskell) in that the code is guaranteed functional.
11:11:25 <petter_> there's http://okmij.org/ftp/Scheme/monad-in-Scheme.html
11:11:27 <lambdabot> Title: Monads in Scheme
11:11:39 <AStorm> \syntaxfree{}, yes, that's the hardest thing to work around in a language.
11:11:42 <\syntaxfree{}> Modius: so can ASM.
11:11:49 <Philippa> Modius: Haskell's got the same representational ability as Lisp in that regard
11:11:52 <Modius> I'm not so much fishing for better; but for where in "scope of all project types" that someone finds one vs. the other buys more development ease/power.
11:11:53 <\syntaxfree{}> or Unlambda.
11:11:55 <Philippa> algebraic datatypes capture the same pattern
11:11:58 <petter_> because i come from scheme, this helped me understand monads better, not that I understand them completely
11:12:00 <\syntaxfree{}> Unlambda can represent anything! Of course!
11:12:09 * ptolomy misses monads in other languages every time he has to check for multiple operations that may fail.
11:12:21 <\syntaxfree{}> even Malbolge is close to being able to represent anything.
11:12:31 <AStorm> ptolomy, most of the time, you use exceptions for that :P
11:12:38 <Modius> For example, I could create an extreme example where the CL version is shorter/easier to write/mess with.  I could do same with Haskell.  I was wondering if someone could describe where in the middle the switchover occurs in a practical app.
11:12:48 <nmessenger> Modius: well, this *is* #haskell, you're likely to find Haskell advocates here. :)
11:12:59 <AStorm> Where? Depends.
11:13:06 <Modius> The advocacy is irrelevant, as I'm sold on the paradigm being powerful.
11:13:08 <AStorm> Haskell is very nice to write program logic in.
11:13:14 <petter_> there's "and-let" in scheme
11:13:26 <ptolomy> AStorm: For some reason, in my current $job domain, I keep finding things that return null if any step in the method returns null, since null is our Nothing.
11:13:33 <Modius> I see haskell/monads as something I'd tried to achieve in lower langauges, writing statelss code everywhere  and trying to isolate state.
11:13:34 <AStorm> Lisp is nice to write new languages in. :P
11:14:18 <AStorm> ptolomy, won't happen in Haskell.
11:14:24 <AStorm> Because of static typing.
11:14:27 <uccus> Modius: obviously you are asking the wrong people here. you should ask *yourself* what you mean by a language being *powerful*
11:14:53 <AStorm> You'd get an exception with a nice hint.
11:15:03 <\syntaxfree{}> Modius: Oh, the "monads are Haskell's way to fix a self-imposed problem" mentality.
11:15:04 <uccus> give us criteria and we will give you judgement (on that criteria) ;)
11:15:16 * ptolomy likes haskell in part because the fanboy/reasonable person ratio seems relatively low.
11:15:17 <\syntaxfree{}> Monads encapsulately nicely state problems.
11:15:30 <Modius> Huh?  I didn't criticize monads or haskell
11:15:39 <newsham> astorm: sure, but you'd still get problems like "head" on an empty list.
11:15:39 <\syntaxfree{}> That's one popular application of monads.
11:15:41 <AStorm> Yes, they are like parts of DSA.
11:15:51 <AStorm> newsham, hmm, but less of them :P
11:15:52 <Modius> The isolation of state change from rest of logic is something I see as an advantage.
11:16:08 <AStorm> And you can change head too ;-)
11:16:20 <nmessenger> Modius: write stuff!  Decide for yourself if you like Haskell.  If you do, come on back here when you need help.
11:16:37 <newsham> ... division by zero...
11:16:41 <sylvan> I think the primary contribution of lisp is that it serves as inspiration for other languages. Being a typoholic I can't really come up with many tasks where I'd want to use Lisp over Haskell (or rather dynamic over static typing). So at the risk of being a fanboy (you *are* in #haskell), I'd say Haskell supercedes Lisp. :-)
11:16:59 <\syntaxfree{}> I can see myself wanting dynamic typing and some of Lisp's freedom.
11:17:03 <AStorm> newsham, with a nice exception :P
11:17:07 <\syntaxfree{}> I'm not willing to sacrifice lazy evaluation though.
11:17:08 <sorear> And if you get stuck, ask on #haskell even if you aren't sure you like it yet.
11:17:33 <newsham> sylvan: in my experience dynamically typed languages are nice for quick'n'dirty scripting.  writing one-offs as quickly as possible.
11:17:33 <araujo> sylvan, scripting is the only that keeps me with an eye on dynamic langs.
11:17:43 <Modius> (And that the language enforces this distinction means code can have performance guarantees).  I guess I'm trying to quantify where this guarantee vs. expressive power payoff is.
11:17:57 <Modius> Ultimately you're right - I will have to get equally strong in Haskell to figure this out for myself ultimately.
11:18:00 <newsham> they let you be sloppy, and sloppy quickly.
11:18:01 <sorear> s-f: while it would be exceedingly painful to make your whole program dynamically typed, the occasional sprinkle is easy - Data.Typeable & Data.Dynamic
11:18:03 <uccus> yeah. the main benefit of Haskell is the "reasoning", static-typing + purity
11:18:05 * araujo has tried to get Haskell into the scripting world .. but it ain't easy as it seems
11:18:13 <AStorm> newsham, hmm, also happens that you can write code quickly in statically typed languages with type inference :>
11:18:17 <newsham> (for example, throwing a bunch of differently typed items into the same list without crafting a unifying type)
11:18:22 <AStorm> E.g. Haskell
11:18:37 <\syntaxfree{}> the main benefit of Haskell, IMO, is declarativeness.
11:18:42 <AStorm> And polymorphic types.
11:18:45 <\syntaxfree{}> Haskell programs are a bunch of equations.
11:18:48 <sorear> I like haskell scripting... I rewrote a 6 line perl script in 1 line of Haskell, which was 10-100 times faster.
11:18:55 <Syzygy-> Heh
11:18:58 <newsham> that can save time.  and if the program is small enough you dont need the extra debug-saving type checks.
11:19:06 <sorear> Granted I had to compile it three times to make it work :)
11:19:25 <LPhas> ?slap edi
11:19:25 * lambdabot smacks edi about with a large trout
11:19:25 <uccus> (if you don't count bugs in GHC that is :hides:...)
11:19:30 <sylvan> I'm not sure I see why dynamic languages are substantaially better for scripting. I mean type inference saves you from having to write out types (and change them)... Sure I can see cases where static is slightly more clunky, but not to the extent where I'd rather have no type checker.
11:19:34 <edi> LPhas: ?
11:19:41 <sorear> the program was fed a ~10GB data set, so the extra speed of ghc vs. perl mattered
11:19:46 <sylvan> I guess it boils down to personal preference at some point, I like to *know for a fact* that certain properties hold true
11:19:48 <Modius> IN C++/C# my goal was to push problems into compile time.  In lisp you trade that away for expressiveness.  I can see in the future where programs with the guarantees like Haskell can be automatically "optimized" into distributed solutions, don't want to miss out on that, nor on the higher limts of what can be pushed to compile time.  Yeah, I'll learn Haskell
11:20:23 <newsham> sylvan: when you are using a language you are very familiar with, and writing a program that is fairly small (ie. can be written within a few hours), you dont really need the benefits of type checking.
11:20:29 <nmessenger> Modius: I started with YAHT
11:20:32 <\syntaxfree{}> Modius: the thing is, I don't feel Haskell's surplus value is in guarantees and static type-checking.
11:20:32 <nmessenger> ?where YAHT
11:20:33 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:20:33 <newsham> because you can juggle all of the details in you rhead fairly easily.
11:20:35 <uccus> Modius: yay! learn it!
11:20:35 <sorear> Learn haskell.  Don't use it unless you want to, but learn it anyway.  It is so different it will change your view on programming.
11:20:37 <Codex_> dynamic typing is more flexible because you find errors later, so you dont need to deal with them immediately => very flexible :)
11:20:39 <AStorm> newsham, true
11:20:46 <newsham> when programs get larger then the type checking saves so much debug time...
11:20:47 <\syntaxfree{}> Modius: Lazy evaluation changes the whole meaning of programming.
11:20:56 <AStorm> But when the program grows, you'll find yourself cursing the language :P
11:20:57 <uccus> syntaxfree: why is that?
11:21:01 <AStorm> (or yourself)
11:21:28 <\syntaxfree{}> a good, if esoteric, example is sigfpe's cellular automata code.
11:21:31 <AStorm> Ah yes, laziness makes some things much cleaner.
11:21:33 <newsham> codex: not just that.  you can also avoid some tedious work... like creating unifying types for example.
11:21:35 <sylvan> newsham: Sure, but just because you don't need the type checker that much, doesn't mean it's substantially more productive to not have it. Plus, small one-offs have a tendency to become largers n-offs :-)
11:21:46 <\syntaxfree{}> Basically, CAs are *defined*.
11:21:57 <\syntaxfree{}> You define an infinite data structure and a CA is a transformation over that.
11:22:00 <Modius> Syntaxfree: I see that - in playing with a paradigm of using lazy-eval stuff (stateless) all over the place in C# and Lisp a pure lazy-eval version would take out all my long-winded exprssion of same.
11:22:06 <newsham> sylvan: small one-offs should never become larger n-offs :)
11:22:12 <\syntaxfree{}> In the end, and only in the end, you pick a small part of the CA output and display it.
11:22:15 <\syntaxfree{}> But it's all *defined*.
11:22:19 <newsham> once you decide its generally useful, you start fresh.  the 2nd write is always better.
11:22:32 <\syntaxfree{}> Modius: lazy-eval is not only about statelesness. It's about declarativeness.
11:22:40 <uccus> agreeing strongly with newsham
11:22:45 <\syntaxfree{}> You can write stateless, purely function in Lisp, Octave and even GNU R.
11:22:50 <AStorm> newsham, tell that to Agile PRogramming proponents :P
11:22:50 <Modius> I was interested in playing with QI; but can't get the thing working in the lisp implementation I use.
11:22:58 <sylvan> newsham: Yeah I know, but managers see a prototype working and assume that the full product is a week away and you're stuck with your one-off in production code :-)
11:23:06 <\syntaxfree{}> It's not declarative code, though, because it doesn't *define* things, it *does* things.
11:23:16 <newsham> astorm: i dont know many.  i imagine the ones that know programming well would agree.
11:23:18 <araujo> dynamic typing == small scripting applications. , static typing == big system applications. Though i use both types interchangeable sometimes. But that's been my experience so far.
11:23:19 <pejo> Codex, if you want somethign to typecheck just throw in error where the code isn't written.
11:23:22 <uccus> syntaxfree: I get your point now
11:23:34 <AStorm> newsham, and the second system effect?
11:23:47 <\syntaxfree{}> s/purely function/purely functional code.
11:23:48 <nmessenger> let someFunctionIHaventWrittenYet = undefined
11:24:02 <newsham> sylvan: if its a one-off that took 3 hrs to write, you dont bother arguing with your manager about rewriting it.
11:24:08 <newsham> you just do it when he's not looking
11:24:37 <AStorm> Yeah. And then he argues you're not doing work on your project :P
11:24:45 <pejo> syntaxfree, lazy evalatuion isn't required for declarative languages.
11:24:47 <newsham> hopefully it will take aprox 3hrs to rewrite more soundly (with experience you already know how to do it, but you also have to go back and do things properly where you cut corners the first time)
11:24:48 <sylvan> in my spare time? But I have games to play!
11:25:09 * araujo would like a dynamic purely functional lang. though
11:25:25 <AStorm> ocaml?
11:25:26 <nmessenger> ?google Wearing the Hair Shirt
11:25:27 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
11:25:27 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell
11:25:36 <uccus> Modius: just a note. Haskell's type inference+polymorphism makes static-typing *much* *much* easier. that's why _we_ think among statically-typed language it's the best ;)
11:25:36 <AStorm> Ah, nope
11:25:37 <newsham> araujo: wonder if you could embed one in haskell using the Dynamic stuff?
11:25:38 <AStorm> PF
11:25:39 <nmessenger> Interesting paper
11:25:43 <sylvan> I would like a static strict purely functional language
11:25:57 <uccus> sylvan: ditto
11:26:10 <sorear> araujo: I have a dynamic mostly-pure functional language
11:26:15 <araujo> newsham, i have been trying to do something with hsplugins
11:26:28 <sylvan> "mostly pure" is like "mostly virgin"
11:26:38 <AStorm> No, it's like Perl.
11:26:45 <sorear> It needs a LOT of cleaning-up, but it is the interface language of hslife
11:26:46 <araujo> @where hashell
11:26:46 <lambdabot> haskell.org/hashell
11:26:50 <newsham> sylvan: ocaml? :)
11:26:54 <sorear> it is pure, but it has dynamic scope.
11:27:02 <araujo> sorear, ?
11:27:14 <sorear> hence a function you call can rebind a variable, and you'll see it.
11:27:22 <sorear> This is on the fix-list.
11:27:30 <sorear> (add lexical scoping)
11:33:53 <fasta> I have a container that is created with empty. (Container a) is an instance of Monoid. I want to have a class of which Container a is an instance. This class should have mempty as default method, but when I try that, I get a type error.
11:35:03 <fasta> Currently I have something like: class (Monoid c)=>Container c where ...
11:35:39 <glguy> Aren't Monoids * while MonadPlus is * -> * ?
11:37:00 * glguy reads through the source and realises how it works out
11:37:48 <AStorm> Hmm, sounds like something I also wanted to do
11:37:58 <AStorm> a monadic Set instance
11:38:29 <sorear> AStorm: Constructor classes are harmful
11:38:56 <sorear> AStorm: It won't work because Monad is a constructor class and constructors must be parametric
11:39:27 <sorear> AStorm: you might be able to kludge something together with the non-parametric "indexed types" in GHC HEAD
11:39:50 <AStorm> Hmm. You're probably right, I'd have to define a slew of operators.
11:40:09 <AStorm> It will be similar to Bits type, but monadic.
11:40:18 <AStorm> s/type/class/
11:40:41 <AStorm> I need that for stateful enumeration.
11:40:57 <AStorm> O(1) too
11:41:06 <AStorm> (if possible)
11:41:19 <AStorm> Any idea?
11:41:58 <lisppaste2> glguy pasted "fasta, like this?" at http://paste.lisp.org/display/33442
11:42:21 <sorear> oh, you mean like an MArray but a set?
11:42:27 <sorear> ?docs Data.HashTable
11:42:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
11:42:38 <sorear> ^^^ something like this interface?
11:43:11 <AStorm> Let's see...
11:44:00 <AStorm> I'd have to override the construction and add .|. and .&. operators (highly useful)
11:44:11 <fasta> glguy: the monoid typically has elements in it. How can I extract one such a value then?
11:44:52 <AStorm> Also modified version of delete called unset
11:44:58 <AStorm> (exceptionless)
11:45:00 <glguy> fasta: make a new class Extractable (for example) and make your container an instance of that?
11:45:34 <fasta> glguy: yes, but can't there be a constraint on c that it needs to be a monoid?
11:45:51 <fasta> glguy: since I want to define empty as mempty?
11:46:35 <glguy> if your default implementation is mempty , then the class must have a Monoid requirement
11:46:42 <glguy> like I had in my paste, right?
11:46:51 <glguy> or am I misunderstanding your question?
11:47:29 <AStorm> sorear, I'd also love to restrict the entries you can give to that datatype on instantiation.
11:47:41 <fasta> glguy: I want to have both a method empty and a method inspect. inspect should have type <some container> -> <element type of container>
11:47:57 <AStorm> (sounds almost like generic programming, doesn't it?)
11:48:43 <glguy> fasta: you can have that method still and ignore the fact that the type is a monoid
11:48:55 <fasta> glguy: yes, that's what I have now.
11:48:58 <glguy> fasta: and require it to be implemented when you decare an instance
11:49:11 <dcoutts__> @users
11:49:11 <lambdabot> Maximum users seen in #haskell: 309, currently: 270 (87.4%), active: 47 (17.4%)
11:49:15 <fasta> glguy: does that mean it's not possible?
11:49:16 <dcoutts__> wow
11:49:20 * dcoutts__ looses the bet
11:49:25 <glguy> fasta: to have a default inspect?
11:49:26 <EvilRanter> ?
11:49:46 <fasta> glguy: no, to have a default empty (namely mempty)
11:49:54 <fasta> glguy: and an undefined inspect
11:50:03 * dcoutts__ wonders who won
11:50:23 <glguy> fasta: oh, I see
11:50:44 <glguy> fasta: in that case, your ContainerClass class would need to be parameterized on the contained type
11:51:26 <fasta> glguy: could you show some code that compiles, since I also tried that approach already.
11:52:04 <glguy> fasta: you basicallywant to do this, right?
11:52:09 <glguy> class Functor f where fmap :: (a -> b) -> (f a -> f b)
11:53:20 <fasta> glguy: I don't see any resemblance, sorry.
11:53:38 <glguy> you want do deal with the contained types, and b in this cass
11:53:40 <glguy> case*
11:53:48 <newsham> > fmap (+ 3) (Just 5)
11:53:50 <lambdabot>  Just 8
11:54:01 <newsham> > liftM (+ 3) (Just 5)
11:54:03 <lambdabot>  Just 8
11:55:02 <fasta> glguy: The thing that compiles is class Container c where empty:: c e;insert::e->c e -> c e
11:55:41 <fasta> glguy: but, as I said, defining empty = mempty gives problems.
11:55:44 <glguy> ah
11:56:46 <fasta> Another thing: how to export only the class instances defined in a module?
11:57:19 <augustss> fasta: empty export list
12:08:15 <AStorm> What about implementing: parallel { a <- someMonad; b <- someIO; ... }
12:08:37 <AStorm> Imperative-like parallel programming :P
12:08:47 <fasta> If I import the module with an empty export list, how do I select that l = empty should select the instance from that module?
12:09:05 <AStorm> Currently you have to sequence the operations on monads.
12:09:37 <fasta> Another odd thing is that :info <Container_type> doesn't show that <Container_type> is an instance of <Container_clas>
12:09:45 <metaperl> @seen shapr
12:09:46 <lambdabot> shapr is in #unicycling, #scannedinavian and #haskell. I last heard shapr speak 1d 23h 25m 32s ago.
12:10:14 <liyang> AStorm: but whether you execute b <- someIO may depend on the value of a ...
12:10:42 <AStorm> You say you don't.
12:10:43 <AStorm> :P
12:10:51 <AStorm> That's what the keyword is for.
12:11:00 <AStorm> If you do, it's forbidden.
12:11:20 <AStorm> (or, as some standard would put it, "undefined behaviour")
12:11:23 <liyang> That'll be what Control.Applicative is for then.
12:11:51 <AStorm> Inverse.
12:11:56 <AStorm> I don't want sequencing.
12:14:06 <AStorm> It would be like function composition, but nicer syntax and return statement is kept.
12:14:29 <fasta> augustss: It seems that an empty export list doesn't enable me to actually select an instance in that module outside of the module.
12:15:10 <liyang> AStorm: Nothing in Applicative says you can't run things in parallel.
12:16:50 <AStorm> IT does. It says it's sequential.
12:17:59 <sorear> logically sequential
12:18:29 <yaxu> yay i got my first peano curve image from haskell
12:18:34 <sorear> yay
12:18:40 <AStorm> :-)
12:19:24 <edi> yaxu: yarr!
12:19:53 <AStorm> sorear, And it doesn't look like imperative syntax :> I love the look.
12:20:16 <yaxu> http://slab.org/random/peano.gif
12:20:20 <liyang> The whole point of Applicative is that the *choice* of subsequent computations cannot depend the result of earlier computations.
12:21:15 <AStorm> Hmm, I'd rather run the operations in parallel for linguistically cheap concurrency.
12:21:36 <liyang> so no reason not to start the subsequent computations in parallel.
12:23:42 <AStorm> yaxu, uhh... doesn't all correct. Which iteration is that?
12:24:08 <AStorm> (and which curve)
12:26:30 <AStorm> *doesn't look
12:26:43 <yaxu> 6 iterations
12:26:54 <yaxu> but i'm mapping audio data on to its path
12:27:12 <yaxu> the start of a steve reich song
12:27:50 <edi> So you are going to play the peano curve?
12:29:13 <yaxu> that might be the next step :)
12:29:58 <yaxu> something's wrong though
12:30:24 <yaxu> when i try mapping the full song i get a nice big 6561x6561 image but it just looks like noise
12:31:01 <AStorm> How many iterations do you run in that case?
12:31:49 <yaxu> it chooses what it needs, i think that's 9
12:32:08 <yaxu> ah no, 8
12:32:36 <mux> (late) merry christmas haskellers
12:33:11 <yaxu> the image is a 42M ppm file :)
12:36:24 <dmhouse> Is there a monadic version of read anywhere?
12:36:26 <dmhouse> ?hoogle read
12:36:27 <lambdabot> Prelude.read :: Read a => String -> a
12:36:27 <lambdabot> Text.Read :: module
12:36:27 <lambdabot> Prelude.Read :: class Read a
12:37:26 <dmhouse> There's one in the LicensedPreludeExts.
12:37:31 <sorear> ?hoogle readIO
12:37:32 <lambdabot> Prelude.readIO :: Read a => String -> IO a
12:37:32 <lambdabot> Data.IORef.readIORef :: IORef a -> IO a
12:37:46 <dmhouse> I'd prefer an arbitrary monad.
12:38:03 <sorear> Yeah, same here. :)
12:39:05 <yaxu> AStorm: I'm using this lsystem to generate the curve if this helps: slllsllr
12:40:51 <yaxu> http://www.math.umass.edu/~mconnors/fractal/generate/peano.html # this one
12:40:52 <lambdabot> Title: Peano's Space-Filling Curve
12:41:16 <AStorm> Mhm, basic Peano Curve.
12:41:41 <yaxu> vanilla flavoured monster
12:41:54 <AStorm> Well, 8 iterations over 6561x6561 square won't modify many pixels.
12:42:12 <SamB_XP> yaxu: I thought lsystems were defined by a starting string and some substitutions
12:42:54 <yaxu> SamB_XP: in that case the rule for each iteration would be to replace each character with itself plus slllsllr
12:43:03 <yaxu> SamB_XP: starting with s
12:43:18 <yaxu> SamB_XP: where s is go straight, l is go left, r is go right
12:43:47 <yaxu> AStorm: i think it will modify exactly all of them
12:44:11 <AStorm> How do you mutate the path with the datafile?
12:44:33 <SamB_XP> AStorm: watch your language
12:44:53 <yaxu> yeah, that's disgusting
12:44:58 <AStorm> :P
12:45:07 <yaxu> AStorm: i gave up doing it in memory
12:45:19 <AStorm> Hey, not my native tongue.
12:45:32 <yaxu> only joking :)
12:46:11 <AStorm> I think you might be changing all the pixels in a uniform way.
12:46:19 <AStorm> Noise in -> Noise out
12:46:21 * SamB_XP can't think of a *nice* word for it
12:46:36 <AStorm> SamB_XP, "mangle" :P
12:46:37 * AStorm ducks
12:46:39 <yaxu> AStorm: so in the end i made a function for generating the mapping, and used hSeek to write each input character to the according place in the output
12:47:10 <SamB_XP> ???
12:47:20 <yaxu> i think it's working, but that my input data is just rubbish
12:47:21 <AStorm> SamB_XP, actually, modify
12:47:30 <SamB_XP> ah, modify sounds right
12:47:56 <AStorm> yaxu, well, the input data indeed is noise
12:47:58 <yaxu> AStorm: i'm just using the peano curve to map 1D data (sound samples) to 2D data (an image)
12:48:02 <SamB_XP> about the same as mutate, except harmless ;-)
12:48:43 <yaxu> the input data is music
12:49:00 <AStorm> Which read in 1D is almost random.
12:49:04 <AStorm> ;-)
12:49:24 <yaxu> well it is steve reich
12:49:29 <yaxu> :)
12:51:06 <sorear> yaxu: you may wish to look at
12:51:11 <sorear> ?google Z-order (curve)
12:51:16 <lambdabot> http://en.wikipedia.org/wiki/Z-order_(curve)
12:51:31 <edi> > exp 1
12:51:33 <lambdabot>  2.718281828459045
12:52:42 <yaxu> sorear: oh that's nice
12:53:23 <yaxu> i wonder if i can generate that with an lsystem
12:58:17 <EvilRanter> you'd need a way of doing those surd-length diagonals
12:59:31 <EvilRanter> maybe a "stop drawing" symbol and a "start drawing again, connecting to where you stopped" symbol would work
13:00:45 <EvilRanter> (from the perspective of a turtle, "just buffer the next movements" then "get there as-the-crow-flies style")
13:03:18 <yaxu> it seems it would be easier just to express it in haskell though
13:03:32 <SamB_XP> you think?
13:04:57 <yaxu> or embed an lsystem in haskell
13:05:27 <edi> You can use nymphaea, specify the right angle, and write down the rules
13:18:25 <AStorm> Well, that parallel syntax is already there in part
13:18:32 <AStorm> the "par" function
13:20:54 <SamB_XP> yaxu: you hadn't already embedded an l-system in Haskell?
13:22:46 <EvilRanter> someone'll've done it in the type system
13:31:49 <AStorm> Is that "challenge 2" from Hair Shirt still open, or do Arrows solve it?
13:34:52 <lokadin> what was that crazy PURE-functional programming language called?
13:35:30 <lokadin> It was very popular a while back on this channel.
13:35:39 <sjanssen> AStorm: what is challenge 2?
13:35:52 <dons> moin
13:36:23 <sjanssen> morning dons
13:36:43 <lokadin> it's unlambda
13:36:47 <lokadin> .ui(happiness)
13:37:17 <AStorm> Wearing the Hair Shirt: commutative monads
13:37:26 <AStorm> Open Challenge 2
13:38:20 <yaxu> ok i found the problem, the input bytes were signed and i was treating it as if it wasn't
13:42:58 <dons> clanehin++ http://www.hermann-uwe.de/files/images/programmer_hierarchy.png
13:43:03 <dons> heh. wrong link
13:43:16 <dons> stoopid windows copy/paste grr
13:43:33 <dons> http://roguestar.downstairspeople.org/
13:43:34 <lambdabot> Title: Roguestar
13:46:05 <AStorm> yaxu, cheers then
13:46:06 <AStorm> @yarr!
13:46:07 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
13:46:31 <monochrom> Haha, Java lower than Pascal?
13:46:44 <sjanssen> dons: can I test contextual stuff in lambdabot with the terminal front end?
13:46:47 <AStorm> That chart is terribly buggy :P
13:48:16 <monochrom> actually "consider themselves superior to".
13:48:31 <dons> sjanssen: yeah, use the ! prefix to the string
13:48:45 <atsampson> I think that graph's actually fully connected...
13:49:07 <AStorm> But the connections themselves are incorrect :>
13:51:13 <sjanssen> dons: okay, good.  Looks like the patch I sent you actually works :)
13:52:16 <glguy> I was surprised that there was no direct connection between C# and Java
13:52:33 <geckosenator> they are completely different
13:52:58 <sorear> ?instances Functor
13:52:59 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:53:03 <glguy> they are both use for the same purposes in IT departments
13:54:04 <glguy> and C# is Microsoft's answer to being told not to hijack Java from Sun
13:54:55 <AStorm> Both are equally funny, so, well :P
13:54:56 <glguy> while Java and Javascript are hardly related except that you can add Java applets to a webpage, yet there is an arrow between the two
13:55:32 <AStorm> Not directly.
13:55:43 <lisppaste2> metaperl pasted "prefacing data members redundantly a good idea?" at http://paste.lisp.org/display/33446
13:55:59 <AStorm> Python/Perl/Ruby relations are incorrect
13:56:08 <AStorm> Should be a triangle.
13:56:27 <allbery_b> metaperl: record tags define accessor functions, so you really want to make them unique
13:56:29 <AStorm> (bidirectional one)
13:56:41 <sjanssen> metaperl: field names can't overlap, so a prefix might be a good idea
13:56:51 <metaperl> I see. Thanks for the feedback
13:56:59 <allbery_b> if you define a different record type later (or import a module which defines one and exports it) it won't be able to use the same names
13:57:08 <sjanssen> another option is to define each data type in a separate module and use qualified imports
13:57:10 <wolverian> AStorm, perl and ruby aren't as averse of each other as python and perl are.
13:57:18 <AStorm> Indeed.
13:57:26 <AStorm> Though Python and Ruby... hehe.
13:57:26 <wolverian> AStorm, (except when s,ruby,ror,)
13:57:44 <allbery_b> do pythoners like anyone? :)
13:57:56 <AStorm> Hmm. Probably Lisp
13:58:16 <AStorm> Though they consider themselves better.
13:58:21 <AStorm> Or on par.
13:58:41 <metaperl> Pythonistas just do their thing. They are not into ego.
13:58:50 <metaperl> I know. I transitioned to Python from Perl.
13:58:54 <wolverian> ha ha ha.
13:59:32 <monochrom> haha ok
13:59:39 <AStorm> I consider myself above all language wars :P
13:59:47 <metaperl> transitioning to haskell from python is a huge huge step. especially when you see what Cale does to XML in 50 lines
14:00:07 <AStorm> Yes it is.
14:00:17 <Cale> :)
14:00:23 <metaperl> http://cale.yi.org/index.php/HRSS
14:00:25 <lambdabot> Title: HRSS - CaleWiki
14:00:30 <sorear> You can go *much* further when you are optimizing for character count.
14:00:42 <sorear> I wrote a 590 *character* theorem prover.
14:00:43 <wolverian> I'm comfortably using perl and haskell currently. it's a fruitful (yet horrible) synthesis.
14:00:46 <SamB_XP> I think I am not above language wars
14:00:46 <Cale> Yeah, I wasn't even really trying for a short program or anything.
14:01:04 <Cale> I just wrote the thing the first way that came to mind, and that was the result
14:01:08 <wolverian> although I still need Inline::Haskell.
14:01:19 <SamB_XP> if someone is claiming that Haskell has problems that it doesn't have, or that I don't think are *problems*, I will get mad
14:01:26 <SamB_XP> well, maybe.
14:01:38 <yaxu> i tried learning python but got sick of reading monty python jokes in the documentation
14:01:39 <SamB_XP> (depends on whether I can convince them otherwise nicely ;-)
14:02:01 <SamB_XP> and if someone tries to make me use a language I don't want to use...
14:02:07 <AStorm> yaxu, that's not a reason to dump a language :>
14:02:25 <SamB_XP> yaxu: that was supposed to be a feature
14:02:29 <AStorm> SamB_XP, ehhh... some time everybody is forced to program in C/C++/Assembler
14:02:38 <SamB_XP> AStorm: well, yeah.
14:03:04 <SamB_XP> I guess I meant, if someone is trying ot talk me into using something like that much for *personal* projects...
14:03:06 <AStorm> Or Java ;-)
14:03:12 <Cale> http://www.xkcd.com/c16.html
14:03:14 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:03:16 <SamB_XP> eh, no, I'd fight about Java anyway
14:03:23 <metaperl> Here is something I tried to write in Haskell this morning. I ended up retreating to Python because a) I could not install http external lib b)I ran out of time - http://rafb.net/p/mPu0zO34.html
14:03:25 <lambdabot> Title: Nopaste - No description
14:03:50 <metaperl> it's called im_so_busy.py - a program to visit random urls at random intervals to make it look like you are at your desk
14:03:58 <Cale> It just visits a webpage in random intervals?
14:04:00 <Cale> oh
14:04:01 <Cale> okay
14:04:09 <SamB_XP> hahaha
14:04:13 <metaperl> yes, but I could not install http.hs
14:04:14 <AStorm> With the HTTP lib it's not that hard.
14:04:28 <edi> It's actually something like a onliner
14:04:31 <Cale> There's a proper HTTP library, yeah
14:04:38 <edi> I've got its skeleton on a post-it, wait...
14:04:40 <SamB_XP> does it follow links?
14:04:54 <monochrom> How much do you need to go through the whole http ordeal?
14:05:04 <metaperl> a later version is going to have wget crawl a site to make it look like I am reading all the links at at site... and then cut off the subprocess after a minute or two
14:05:04 <Cale> http://www.haskell.org/http/
14:05:06 <lambdabot> Title: Haskell HTTP package
14:05:21 <metaperl> yes, that did not install and bringert has not responded to my problems
14:05:25 <monochrom> I mean can you just open socket and close it?
14:05:28 <metaperl> python did it right out of the box
14:05:40 <AStorm> metaperl, why didn't it install?
14:05:42 <SamB_XP> metaperl: you mean *wrong* out of the box?
14:05:44 <metaperl> monochrom - sure as long as it looks like I am browsing technical websites from work
14:05:44 <Cale> You could use HXT to easily grab all the links, and then follow those recursively.
14:05:51 * SamB_XP teases metaperl
14:06:06 <monochrom> but HXT depends on HTTP, Cale.
14:06:09 <metaperl> SamB_XP - :)
14:06:13 <Cale> right, it does
14:06:16 <Cale> it's not hard to install
14:06:20 <metaperl> at least it ran while I took a 2-hour lunch instead of 1-hour
14:06:23 <metaperl> lol
14:06:24 <metaperl> hahaha
14:06:25 <SamB_XP> does HXT support RELAX NG Compact ?
14:06:46 <Cale> darcs get http://darcs.haskell.org/http/
14:06:48 <lambdabot> Title: Index of /http
14:06:48 <Cale> cd http
14:06:52 <Cale> runhaskell Setup.lhs configure
14:06:59 <Cale> runhaskell Setup.lhs build
14:06:59 <metaperl> yes I had to type runghc
14:07:05 <Cale> sudo runhaskell Setup.lhs install
14:07:07 <metaperl> and I got an error - I will paste
14:07:11 <Cale> okay
14:07:20 <AStorm> metaperl, Gentoo?
14:07:24 <AStorm> If so, use the haskell overlay.
14:07:39 <AStorm> The ebuild there installs perfectly.
14:07:39 <bringert> metaperl: just replied
14:07:54 <bringert> metaperl: told you to go here :-)
14:08:06 <metaperl> ah - yes!
14:08:15 <metaperl> http://rafb.net/p/p5dmEI76.html   --- this is my ordeal with cabal
14:08:16 <lambdabot> Title: Nopaste - No description
14:08:32 <metaperl> AStorm - osx
14:08:57 <edi> There you go, given a suitable IO action `surf'
14:08:57 <edi> ?type \(min,max) surf -> fix $ \f -> do { x <- randomRIO (min,max); surf; Control.Concurrent.threadDelay x; f }
14:08:59 <lambdabot> forall a b. (Int, Int) -> IO a -> IO b
14:09:02 <AStorm> Hmm. Sounds like a buggy version of Cabal.
14:09:09 <edi> (:
14:09:13 <AStorm> It should catch that exception in the first place.
14:09:49 <edi> (I ❤ this post-it.)
14:09:50 <AStorm> But why doesn't getEnv work? :P
14:10:06 <Cale> hmm, export PATH ?
14:10:12 <AStorm> edi, @undo that
14:10:18 <metaperl> edi - I limit the total amount of browsing time... in other words, total amount of browsing time is 1 hour... so I take a 2-hour lunch break and then it looks like 1 hour of it I was browsing the web at technical websites
14:11:18 <sjanssen> @. pl undo \(min,max) surf -> fix $ \f -> do { x <- randomRIO (min,max); surf; Control.Concurrent.threadDelay x; f }
14:11:29 <lambdabot> ap (((fix .) .) . flip flip (flip . ((>>) .) . (. (((Control . Concurrent) .) . threadDelay)) . (>>)) . (((.) . (.) . (>>=) . randomRIO) .) . (,) . fst) snd
14:11:30 <lambdabot> optimization suspended, use @pl-resume to continue.
14:11:42 <dons> metaperl: thanks for the mail, btw.
14:11:42 <Cale> metaperl: is PATH exported?
14:12:01 <SamB_XP> metaperl: but does it follow links?
14:12:01 <dons> i'll look into it (I hope to release an improved http package during the hackathon)
14:12:11 <AStorm> Hmm. Why does pointfree code contain so many dots? :P
14:12:26 <SamB_XP> ;-)
14:12:41 <metaperl> Cale - I typed export PATH and then runghc Setup.lhs configure but same error... this is an os x build of ghc that I jury-rigged from audreyt's version
14:12:44 <monochrom> because points and dots form a pair of dual categories
14:12:50 <Cale> oh
14:12:51 <Cale> hmm
14:13:17 <Cale> metaperl: any reason not to use a standard build?
14:13:21 <metaperl> I could just copy the directory onto my loadpath I'm sure. it's not a tough install
14:13:23 <dons> a nice http, with bytestring support, should be part of the core libs
14:13:28 <metaperl> Cale - no standard binary for os x
14:13:45 <dons> note there's also http stuff in mukai's HaskellNet soc lib too
14:13:56 <dons> but it all needs to be stabilised and made easy to get hold of
14:14:05 <metaperl> I used audreyt's, but it has some Darwinports dependencies that I symlinked to Fink stuff to get it to work
14:14:06 <Cale> metaperl: which OS X?
14:14:16 <metaperl> Cale - Intel
14:14:23 <Cale> 10.4?
14:14:26 <metaperl> yes
14:14:37 <Cale> http://haskell.org/ghc/dist/6.6/ghc-6.6-i386-apple-darwin.tar.bz2
14:14:38 <nmessenger> ?wiki OSX
14:14:39 <lambdabot> http://www.haskell.org/haskellwiki/OSX
14:14:55 <AStorm> There's one at DarwinPorts, yes.
14:15:03 <Cale> hehe, Mac 0SX
14:15:11 <metaperl> I dont use darwinports
14:15:18 <edi> Just use the standard distribution, as Cale suggests.
14:15:20 <metaperl> os x is Unix for weenies like me
14:15:38 <metaperl> I'm not a big enuf weenie to use windows, but not savvy enuf for Linux. so there ya go
14:15:39 <edi> ...or even the source distribution, plus the extras, for all the goodies.
14:15:40 <Cale> metaperl: darwinports?
14:15:49 <Cale> metaperl: that's an ordinary package
14:16:08 <allbery_b> hey, even some of us unix weenies use osx :>
14:16:10 <bringert> metaperl: you could get the GHC source package and build your own using the GHC you have now
14:16:13 <metaperl> Cale - audreyt's binary requires some things in /opt which implies that he built it with darwin ports tools
14:16:21 <metaperl> ah
14:16:25 <bringert> that takes a little while though
14:16:27 <Cale> hmm
14:16:28 <metaperl> not a bad idea bringert
14:16:28 <monochrom> This is really scaring me off OSX.
14:16:40 <bringert> monochrom: it's not that bad
14:16:42 <Cale> why not use MacPorts?
14:16:48 <bringert> just use macports
14:16:50 <allbery_b> macports is darwinports
14:16:50 <bringert> yeah
14:16:53 <Cale> yes
14:17:03 <metaperl> what is macports? I think that's the evolution of darwinports? I will check
14:17:10 <Cale> http://www.macports.org/
14:17:12 <lambdabot> Title: MacPorts
14:17:33 <monochrom> I thought the evolution of darwinports would be named huxleyports. :)
14:17:53 <allbery_b> if you use darwinports and you do a port selfupgrade, you'll see it calls the new version macports
14:18:00 <edi> @slap monochrom
14:18:00 * lambdabot smacks monochrom about with a large trout
14:18:14 <Cale> watsonports
14:18:20 <allbery_b> (and if you're up to date on dports there will be no change, as they haven't actually revved the base)
14:19:26 <metaperl> darwin ports hopefully has improved since this diatribe: http://use.perl.org/~schwern/journal/30887
14:19:28 <lambdabot> Title: Journal of schwern (1528)
14:19:59 <metaperl> <quote>ports installed GNU coreutils but prepending a "g" in front of every program. gchmod. gdate. ghostname. gls!!!</quote>
14:20:00 <AStorm> "use.perl.org"... now that's marketing :P
14:20:32 <pejo> metaperl, thats a feature.
14:20:38 <monochrom> gls is a bit silly :)
14:20:43 <metaperl> SUPER SILLY
14:20:45 <metaperl> DUMB
14:20:49 <allbery_b> it's still got some of that, in particular the horrid tcl-based architecture (wish they'd just kept the original)
14:20:54 <metaperl> RIDICULOUS
14:20:57 <allbery_b> it's modeled on freebsd ports
14:21:05 <metaperl> UNACCEPTABLE
14:21:09 <metaperl> :)
14:21:17 <AStorm> It's actually correct.
14:21:21 <metaperl> GEORGE-BUSH-LIKE
14:21:26 <allbery_b> but, while you have to dig around, it does have the ability to install packages.  btu being based on freebsd ports, it really prefers building stuff
14:21:27 <AStorm> Thus it doesn't overwrite your tools.
14:21:31 <pejo> metaperl, atleast under Solaris you don't want the gnu ls, I wouldn't be surprised if it's the same way under osx. (How about ACL's for example?)
14:21:39 <metaperl> If George Bush invented a Mac Unix Distro...
14:21:40 <AStorm> Other than that, it shouldn't install unneeded binaries.
14:21:48 <AStorm> You only really need gtar and gmake
14:21:48 <AStorm> :P
14:21:49 <sorear> metaperl: Since it is UNACCEPTABLE, by definition you did not accept it :)
14:22:11 <allbery_b> yeh, I'd be pissed if it installed an incompatible utility overshadowing a system one, that's far more broken
14:22:13 <metaperl> I wont defend my antics
14:22:21 <metaperl> I have no place calling anything dumb
14:22:32 <AStorm> :>
14:23:31 * metaperl packs up and heads to his after-work studies
14:23:37 <metaperl> good night Haskellers!
14:23:44 <AStorm> nite
14:23:59 <allbery_b> the removing a port and a dependent thing I haven't tested, it works in freebsd but they broke several things with their tcl pseudoemulation
14:24:09 <dons> night metaperl
14:24:21 <dons> so who uses the http package regularly? bringert?
14:24:47 <dons> that's almost #1 on my list of packages that need work
14:24:55 <SamB_XP> I think Conjure might depend on it
14:25:04 <edi> HXT uses it internally
14:25:12 <bringert> dons: I don't use it regularly
14:25:18 <SamB_XP> I ran into a really wierd tracker once
14:25:20 <bringert> dons: I don't use it at all actually
14:25:41 <SamB_XP> it used a decidedly transfer method...
14:25:52 <SamB_XP> s/decidedly/decidedly odd/
14:28:20 <sorear> ?users
14:28:20 <lambdabot> Maximum users seen in #haskell: 309, currently: 267 (86.4%), active: 44 (16.5%)
14:28:59 <dons> bringert: do you have an http package?
14:29:21 <bringert> dons: define "have". I maintain one.
14:29:41 <dons> you maintain one, other than the 'http' package on haskell.org/http ?
14:29:56 <bringert> dons: just that one
14:30:19 <dons> bringert: does it need work? i've had two people ask about missing documentation.
14:30:26 <bringert> dons: yes, it does.
14:30:42 <dons> mm. ok. I think I might work on it then for the hackathon
14:30:57 <dons> a standard, good http package should be in the extralibs bundle, imo
14:31:11 <dons> if we want to push on python a bit
14:31:18 <bringert> there is hardly any documentation, and lots of things that need fixing
14:31:24 <bringert> no https
14:31:35 <dons> ok. no bytestring support too, I guess?
14:31:42 <bringert> correct
14:32:05 <dmhouse> Has anyone had any problems serialising Html using Show?
14:32:14 * dmhouse is having HAppS troubles
14:32:37 <lisppaste2> dmhouse pasted "HAppS errors" at http://paste.lisp.org/display/33448
14:32:50 <dons> huh, "ARM now third most-popular Debian Architecture."
14:32:55 <dmhouse> I get those errors when I try to start my application with previous state existing.
14:32:57 <nmessenger> anyone: I'm on Windows, using (non-cygwin) darcs for the first time, should I be concerned about the message 'plink: unknown option "-O"'
14:33:18 <dons> nmessenger: sounds /fairly/ harmless
14:33:26 <dmhouse> I think it's related to the fact that I've now just started to include Html in one part of the things I'm serialising and deserialising.
14:33:37 <bringert> dons: you are welcome to hack on it as much as you want. I could try to do something too. you are welcome to take over as maintainer if you want.
14:33:42 <dons> ok.
14:33:42 <sjanssen> nmessenger: #darcs probably has the best advice :)
14:33:43 * nmessenger is not very reassured
14:33:48 <dmhouse> I wrote my own Read instance for Html, I couldn't see why it didn't have one
14:33:56 <dons> i might, if I say, add some bytestring support and work on it in the next few weeks
14:34:04 <bringert> dmhouse: which Html is that?
14:34:22 <dons> sjanssen++ thanks for the nick++ patch
14:34:34 <lisppaste2> dmhouse annotated #33448 with "My instance Read Html" at http://paste.lisp.org/display/33448#1
14:34:46 <dmhouse> bringert: Text.XHtml.Html
14:35:20 <sjanssen> list processing > regular expressions
14:35:46 <bringert> dmhouse: ah, another one of the messy things I maintain :-)
14:35:59 <bringert> dmhouse: Show and Read are troublesome when they are not derived
14:36:12 <bringert> could be a parenthesizing problem
14:36:23 <dmhouse> Yeah.
14:36:48 <dmhouse> The Show instance that comes built in doesn't seem to wrap the Html output with any kind of "" or anything
14:37:23 <dmhouse> I might just come up with a better way of doing this than storing the bare Html in my data structure.
14:37:35 <bringert> I had a similar problem with Data.Time types
14:38:02 <dmhouse> I could parse a String into Html on the fly every time you request a page, I suppose, although that's suboptimal.
14:38:47 <dmhouse> bringert: on a kind of related tack, do you know if it's possible to run an IO action from within HAppS' Ev monad and get its result back?
14:39:22 <bringert> dmhouse: I've never looked at HAppS
14:39:38 <bd_> As I understand it, Ev is based on STM, which means it's not safe to do IO actions from within it, or you may have problems with deadlocks andtransaction retries causing your IO action to be run multiple times
14:40:52 <dmhouse> bringert: oh, sorry, I thought "bringert -> Hope -> web -> HAppS", oops. :)
14:41:07 <dmhouse> bd_, you can execute IO () actions with addSideEffect, though.
14:41:10 <bringert> dmhouse: I got Read working by using readParen False in all the Read instances, like at the bottom of this module: http://darcs.haskell.org/packages/time/Data/Time/LocalTime/Parse.hs
14:41:13 <lambdabot> http://tinyurl.com/y3gwa6
14:41:19 <bd_> dmhouse: True, but that's not useful if you need the result back in the Ev
14:41:30 <dmhouse> bd_: but the point is you can do IO.
14:41:47 <bd_> I was looking at a similar problem recently, I wanted to start an Ev from within IO. Or rather, Ev -> addSideEffect -> IO -> Ev
14:42:06 <bd_> never managed to find a way to do it though :/
14:42:49 <bd_> I'm leaning towards not using HAppS though, it's not really htat well suited to my application. I'll have to write a HTTP server though...
14:42:58 <bd_> mmm, afk
14:43:31 <dmhouse> I like HAppS, but it's not really ready as a general purpose web framework, there's still too much boilerplate you're forced to right.
14:43:33 <dmhouse> *write
14:43:49 <dmhouse> bringert: thanks for your help, I'll check out that link.
14:44:01 <dons> bd_: could you extract the http server from HAppS?
14:44:10 <dons> it'd be worth it, since the happs one has been highly tuned
14:44:15 <bringert> bd_: have you looked at HWS?
14:44:18 <dons> (we spent a long time tweaking and profiling)
14:44:28 <dons> mm. the happs webserver should be available standalone...
14:44:33 <LPhas> hi dons
14:44:37 <dons> hey LPhas
14:44:57 <dmhouse> ?hoogle readParen
14:44:57 <lambdabot> Prelude.readParen :: Bool -> ReadS a -> ReadS a
14:44:59 <sorear> dons: does OpenBSD have any sensible way of killing programs that hang with int the -isig terminal mode?  E.g. in Linux I can change vconsoles and use 'kill'.
14:45:02 <LPhas> i've a problem where you might help
14:45:23 <dons> sorear: same thing works on openbsd
14:45:23 <lisppaste2> Setzer annotated #33441 with "spio" at http://paste.lisp.org/display/33441#1
14:45:29 <LPhas> i'm cabalizing my lbinding for libid3
14:45:43 <dons> LPhas: yes. ok.
14:45:44 <sorear> ok, good
14:45:50 <LPhas> but i need Cabal to check wheather libid3 is installed
14:45:54 <dons> ah right.
14:46:01 <dons> so you need a configure.ac script
14:46:06 <LPhas> yes
14:46:09 <dons> well, a ./configure script
14:46:15 <dons> it could be hand written , or use autoconf
14:46:17 <LPhas> i lurked in hmp3 .cabal
14:46:46 <dons> LPhas: but to actually check, you need to write a configure shell script, which will be run by cabal, in addition to the usual cabal tests
14:46:47 <Lemmih> LPhas: You might wanna copy configure.ac from hssdl.
14:47:01 <dons> cabal should be able to do simple C lib tests ;)
14:47:03 <LPhas> Lemmih: oh, good
14:47:16 <dons> build-c-depends: libm -- that'd be nice
14:47:30 <LPhas> dons: maybe you can provide me the configure.ac you used for hmp3
14:47:36 <LPhas> so i can get an eye on it
14:47:56 <dmhouse> Lemmih: hIDE came up earlier. I remember you saying there could be a general release once 6.6 was out. Is that still true, or have you lost all interest?
14:48:13 <dmhouse> (I think it was you that said that, there's an outside possibility it was Cale.)
14:48:19 <jethr0_> any mac os afficionados present? i got a macbook for christmas and am now trying to figure out how out my unix obsession (with fink, ...)
14:48:27 <jethr0_> any hints?
14:48:53 <edi> jethr0_ - Just install darwinports, and investigate the `port' command.
14:49:10 <conal_> does anyone here know to work around haddock's lack of support for some ghc language features?  i'm trying "#ifdef __HADDOCK__", but haddock doesn't parse the #ifdef.
14:49:14 * allbery_b can't help with fink, he uses macports (aka darwinports)
14:49:17 <liyang> jethr0_: ghc6.6 works in darwinports, I believe.
14:49:17 <conal_> Is it necessary to cpp before haddock gets it?  can that be done through cabal?
14:49:18 <LPhas> jethr0_ i'm using a mac right now
14:49:19 <Lemmih> dmhouse: hIDE has been orphaned.
14:49:22 <LPhas> try darwinports
14:49:33 <dmhouse> Lemmih: fair enogh.
14:49:36 <dmhouse> *enough.
14:49:40 <jethr0_> thx, so fink is deprecated then?
14:49:55 <LPhas> well i don't think so
14:50:04 <allbery_b> fink seems to not be kept up to date, and IIRC is not so much with the intel support
14:50:08 <LPhas> but everyone said me that darwiports is better
14:50:10 <liyang> Nope, it may be useful to install both.
14:50:26 <sorear> dons?
14:50:26 <sorear> (looking in lastlog: Cale/metaperl/allbery_b were having a discussion of installing an html lib on OSX)
14:51:01 <jethr0_> k, so i'm gonna try installing haskell6.6 via darwinports then. thx a lot
14:51:22 <edi> I'd use the standard ghc package from haskell.org/ghc.
14:51:50 <edi> And use that to build the source distribution plus the extralibs.
14:51:58 * allbery_b ditched fink some time back after it pulled a dependencies weirdie reminiscent of tracking debian unstable (e.g. "I want to delete your libc and all other packages to fix a dependency conflict, is that okay?")
14:52:20 <allbery_b> obviously you wouldn't see *that* one from fink, but you get the idea
14:52:42 <allbery_b> basically, fink is as good as whoever maintains the packages.  somemes they're not very careful, it appears
14:52:52 <allbery_b> ^somemes^sometimes
14:53:57 <LPhas> edi: right for Haskell code is better
14:54:23 <LPhas> plus you can use "darcs versions" if you like living on the edge
14:56:10 <dons> LPhas: the configure script should be in the hmp3 repo. feel free to grab it.
14:56:16 <dmhouse> bringert: is there any version of stringToHtml available that doesn't escape entities?
14:56:27 <dmhouse> (i.e. essentially a Read for Html?)
14:56:39 <LPhas> dons: from what i saw in the hmp3 code there is the automaked ./configure
14:56:48 <bringert> dmhouse: I'll check
14:57:01 <LPhas> dons: i need the imput file for automake, if i figured out correctly how worked
14:57:06 <LPhas> ehm autoconf
14:57:23 <dons> read the configure.ac file
14:57:28 <dons> then run autoconf
14:57:35 <bringert> dmhouse: primHtml
14:58:14 <dmhouse> bringert: that's the one, thanks.
14:58:21 <jethr0_> hmm, building ghc from scratch is not my favorite idea... i am a big fan of package managers and binary packages (or at least fully automatic compiling from source) in that respect
14:58:39 <bringert> dmhouse: it's not really read though, since it doesn't recreate the internal structure, but that should be unobservable anyway
14:59:14 <dmhouse> bringert: yeah, I'm just using it to inject a string of Html into my Html structure, not as a fully-fledged read anyway.
14:59:20 <LPhas> dons: found, seems easy enough, thx
14:59:33 <bringert> dmhouse: ok, that's exactly what primHtml is for
15:01:07 <bringert> dons: The http package needs a major overhaul. You have free hands to do and push whatever you think is right.
15:02:33 <dmhouse> Anyone know of a tool to create arbitrary cookies in Firefox?
15:03:05 <SamB_XP> javascript?
15:03:08 <dmhouse> 'Arbitrary' isn't the right word... I want to test my program I haven't built a login feature for yet by faking the cookie.
15:03:08 <sorear> server side or client side?
15:03:14 <sorear> mg
15:03:20 <sorear> I'd use mg
15:03:26 <dmhouse> ?google mg
15:03:27 <lambdabot> http://www.mg-rover.com/
15:03:35 <edi> wrooom.
15:03:37 <dmhouse> ?google mg cookie
15:03:40 <lambdabot> http://www.amazon.com/M-Cookie-Candy-Book-Anne-Rockwell/dp/0394955005
15:03:41 <sorear> (or any of the thirty-odd equivalent programs... mg is a text editor)
15:03:42 <SamB_XP> it sounds like client-side would work fine to *me*
15:04:04 <AStorm> Cookies are text files.
15:04:20 <dmhouse> SamB_XP: yes, but I can't be bothered to write the Javascript when someone else likely will have done.
15:04:28 <dmhouse> But okay, let's go hunting through ~/.firefox.
15:04:37 <SamB_XP> dmhouse: I meant, you could probably write a one-liner in the URL bar
15:04:52 <sorear> ~/.mozilla/firefox/*.default/cookies.txt
15:05:00 <dmhouse> sorear: got it, thanks.
15:05:03 <edi> dmhouse: install the web developer toolbar
15:05:07 <sorear> Who has time to learn javascript :)
15:05:29 <SamB_XP> hmm, probably that toolbar is a better way ;-)
15:06:00 <dmhouse> edi: that's the kind of answer I was expecting. :)
15:07:30 <syntaxfree> good evening, fine Programming 2.0 practitioners.
15:07:43 <SamB_XP> hah
15:07:44 <bd_> dons: <belated reply> I was thinking of extracting the webserver portions from HAppS, particularly since the XSLT stuff would be nice. On the other hand, it might be interesting writing my own too... I guess it depends on how easy it'd be to extract it. I haven't really taken a good look at how it integrates with the rest of HAppS.
15:07:48 <monochrom> nice
15:07:48 <sorear> Muahahahaha!
15:07:50 <SamB_XP> Haskell is *not* Programming 2.0
15:07:58 <syntaxfree> FP is programming 2.0.
15:08:02 <bd_> haskell = 'Programming'
15:08:06 <SamB_XP> maybe it is programming 3.0
15:08:07 <bd_> er, Programming' even
15:08:08 <syntaxfree> SamB_XP: why?
15:08:15 <monochrom> Haskell is Programming 7.
15:08:15 <SamB_XP> and programming 2.0 is what we'd been doing before that
15:08:22 <syntaxfree> what is Programming 1.0, then?
15:08:25 <SamB_XP> and maybe machine language is Programming 0.0
15:08:40 <bd_> syntaxfree: C?
15:08:43 <SamB_XP> syntaxfree: interpolate!
15:08:50 <sorear> \forall{} a. \gt 2.0 Haskell \setelem{} Programming a
15:09:13 <syntaxfree> Haskell needs some better marketing.
15:09:33 <AStorm> Haskell is Programming (sum [6, 0.6, 0.06, ...])
15:09:43 <SamB_XP> but I really don't think we want to be associated with the me-twos of Web 2.0
15:09:49 <Nanar> question from a beginner who is reading the doc
15:09:49 <SamB_XP> er.
15:09:50 <syntaxfree> maybe.
15:09:50 <SamB_XP> me-toos
15:09:58 <augustss> Haskell is programming 98
15:09:59 <syntaxfree> Programming 2.0 has a nice ring to it, though.
15:10:00 <bringert> bd_: here's another web server: http://www.cs.chalmers.se/~bringert/darcs/hws-cgi/
15:10:00 <sorear> AStorm: Haskell does not interface with OEIS yet, sorry.
15:10:03 <Nanar> data Point a = Point a a
15:10:09 <AStorm> OEIS?
15:10:16 <sorear> ?where oeis
15:10:21 <Nanar> in this example, a function to use this data type look like:
15:10:23 <syntaxfree> Nanar: yes?
15:10:29 <sorear> Online Encyclopaedia of Integer Sequences
15:10:32 <LPhas> dons: worked! thx!
15:10:36 <AStorm> Hehe.
15:10:37 <Nanar> f Point a b = a + b
15:10:46 <AStorm> Yes, should be:
15:10:48 <monochrom> f (Point a b) = a+b
15:10:49 <sorear> f (Point a b) = a + a
15:10:51 <syntaxfree> you need parens around your pattern.
15:10:55 <AStorm> sum [6.0, 0.6, 0.06, ...]
15:10:57 <syntaxfree> f (Point a b) = a + b
15:11:00 <sorear> it's a precedence issue.
15:11:02 <Nanar> ok ok
15:11:10 <Nanar> thanks, I start to understand
15:11:23 <sorear> f Point a b is parsed as a function taking 3 args named 'Point', 'a', 'b'
15:11:45 <sorear> but that's illegal because variable names must start with a lowercase letter.
15:11:55 <Nanar> so in which case using the form 'data x { a -> int , b -> Int }' is usefull ?
15:11:58 <syntaxfree> sorear: you'd think (:) would have higher precedence, but it doesn't.
15:12:09 <lambdabot> I know nothing about oeis.
15:12:18 <sorear> ?bot
15:12:23 <syntaxfree> Nanar: you mean records?
15:12:32 <Nanar> syntaxfree: probably, yes
15:12:39 <monochrom> The grammar requires ( ) without mentioning precedence
15:12:46 <sorear> data X = Y { a :: Int , b :: Int } -- correct syntax
15:12:48 <syntaxfree> data Point = Point { a :: Int, b :: Int }
15:12:59 <Nanar> yes that is
15:13:02 <syntaxfree> that will automatically create destructor functions for you.
15:13:15 <syntaxfree> That is, there's a function a such that a (Point x y) = x
15:13:21 <sorear> but don't just do that, because field names have to be globally unique.
15:13:38 <lambdabot> :)
15:13:42 <sorear> Disgusting wart, we know, the h98 record system has many flaws.
15:13:45 <syntaxfree> "field names" are the names being given to the destructor functions.
15:14:03 <syntaxfree> Nanar: you can still use normal pattern-matching if you use records as well.
15:14:07 <monochrom> I use record syntax when I want to model records.  I don't use record syntax when I don't want to model records.
15:14:33 <AStorm> Dump some nice GHC extension to ignore that wart... :>
15:14:40 <syntaxfree> data Point = Point Int Int  means the same  as data Point = Point { a :: Int, b :: Int} , except the latter creates two functions.
15:14:46 <AStorm> O'Haskell anyone? :P
15:15:01 <monochrom> Example.  If I have a million fields, I may as well think of them as a record.
15:15:05 <syntaxfree> Nanar: questions answered?
15:15:23 <syntaxfree> I use records when I feel like avoiding pattern-matching.
15:15:26 <Nanar> if I understand correctly, it is taste question during application programming
15:15:30 <sorear> Nanar: answered excessively? :)
15:15:39 <monochrom> Absolutely.
15:15:46 <syntaxfree> Nanar: it's syntactic sugar.
15:15:47 <Nanar> yup you answer perfectly
15:15:59 <Nanar> answered
15:16:00 <LPhas> having now a ./configure that locates mylib, there's a way to get Cabal use the path of that lib for compile against?
15:16:15 <Nanar> oh latest question
15:16:16 <syntaxfree> yes, we put the funk in funktion.
15:16:39 <Nanar> with record, all field must be fill during creation ?
15:16:43 <sorear> no
15:16:50 <sorear> well, yes, sortof
15:17:00 <syntaxfree> you can always use Maybe.
15:17:12 <syntaxfree> data Maybe a = Just a | Nothing
15:17:12 <sorear> if you don't specify a field it will be filled in with an undefined value
15:17:21 <Nanar> ok data Point = Point { a :: Int, b :: Int}
15:17:22 <syntaxfree> that allows for "unfilled".
15:17:26 <Nanar> arg
15:17:28 <dancor> when i do 'make install-docs' for ghc-6.6 it tries to run a command called h
15:17:32 <Nanar> ok data Point = Point { a :: Int, b :: maybe Int}
15:17:35 <syntaxfree> ahh. there's bottom, as well, yes.
15:17:37 <dancor> which of course i do not have on my system
15:17:37 <sorear> if you access a field that wasn't specified, you get a runtime error
15:17:38 <syntaxfree> er, undefined.
15:17:46 <Nanar> in that case b is 'optional'
15:17:51 <dancor> == make install-docs -r; in /home/danl/i/hs/ghc/ghc-6.6/rts
15:17:52 <dancor> ------------------------------------------------------------------------
15:17:52 <dancor> h -o ../html-docs/rts   \
15:17:53 <dancor> ...
15:18:08 <syntaxfree> @type undefined
15:18:10 <lambdabot> forall a. a
15:18:26 <syntaxfree> now that's a polymorphic type ;)
15:18:29 <sorear> Don't mess with runtime errors, debugging them is Haskell's weakest area.
15:18:30 <syntaxfree> @kind undefined
15:18:32 <lambdabot> Not in scope: type variable `undefined'
15:18:44 <monochrom> I go with Maybe.
15:18:44 <sorear> > undefined + 5
15:18:45 <syntaxfree> @kind forall.a a
15:18:46 <lambdabot>  Undefined
15:18:47 <lambdabot> Not in scope: type variable `a'
15:18:47 <lambdabot>  
15:18:47 <lambdabot> <interactive>:1:9: Not in scope: type variable `a'
15:18:59 <Nanar> yup, I allready play a bit with data, maybe and co
15:19:22 <Nanar> but I am reading the doc again to understand clearly what I did :)
15:19:30 <nmessenger> @kind forall a. a
15:19:31 <lambdabot> *
15:20:18 <syntaxfree> Nanar: rock on :)
15:20:42 * Nanar will write some doc on haskellfr part
15:22:11 <syntaxfree> I liiiiiike John Cleeeeese ... he never acquires any cheeeese
15:23:29 <syntaxfree> .. and he's always witty and ready to please.
15:23:56 <dancor> does anyone know why the xml files in ghc-6.6/docs are not valid xml and cannot be converted to html with xmlto
15:24:19 <dancor> i can't run make nor 'make install-docs' successfully in that directory either
15:24:46 <dancor> i'm starting to get a little paranoid that there is a conspiracy to keep me from having a local copy of the ghc docs
15:25:31 <jlouis> why?
15:25:53 <monochrom> odd. in the source tarball you referring?
15:26:10 <monochrom> damn, I listened to too much Latin.
15:26:27 <LPhas> ?paste
15:26:27 <lambdabot> http://paste.lisp.org/new/haskell
15:26:43 <dancor> ghc-6.6-src.tar.bz2 from http://www.haskell.org/ghc/download_ghc_66.html
15:26:44 <lambdabot> Title: GHC: Download version 6.6
15:27:12 <dancor> i have ghc 6.4 installed thru gentoo
15:27:16 <dancor> but no docs
15:28:08 <monochrom> Does xmlto know docbook?  the docs are written in docbook, I heard.
15:28:34 <dancor> it should
15:28:36 <dancor> A bash script for converting XML and DocBook formatted documents to a variety of output formats
15:29:02 <syntaxfree> 9:08 PM  sorear: Disgusting wart, we know, the h98 record system has many flaws.
15:29:16 <syntaxfree> records really are syntactic sugar for generating destructor functions.
15:29:34 <syntaxfree> the issue of global uniqueness of record names can't really be solved, short of a wider reform of the Haskell namespace system.
15:29:49 <syntaxfree> or of putting every record definition in its own module ;)
15:29:53 <dancor> i guess i'll try tho doc rpm..
15:30:09 <AStorm> I vote for the reform.
15:30:26 <nmessenger> I vote for file-level submodules
15:30:34 <yaxu> http://slab.org/random/pingpong-dark.png # made with haskell - minimal techno mapped to an image via a peano curve
15:30:40 <AStorm> Good too :>
15:31:17 <edi> yaxu: you are using that l-system for serialization?
15:31:28 <augustss> syntaxfree: that's what i do when in doubt
15:31:43 <AStorm> Now, unmapping that techno shouldn't be all that hard... :>
15:31:49 <AStorm> Almost steganographic :P
15:32:14 <yaxu> edi: still using that same lsystem generated peano curve, haven't played with that bit yet
15:32:18 <nmessenger> ?peano curve
15:32:18 <lambdabot> Unknown command, try @list
15:32:22 <nmessenger> ?google peano curve
15:32:24 <lambdabot> http://en.wikipedia.org/wiki/Space-filling_curve
15:32:24 <lambdabot> Title: Space-filling curve - Wikipedia, the free encyclopedia
15:32:28 <yaxu> will put the source up properly in a b it
15:32:53 <dibblego> how would a data type look that is a cons list with a memoized reverse?
15:33:15 <yaxu> AStorm: the question is, am i breaking copyrights or not?
15:33:46 <nmessenger> Oh yeah, didn't xkcd use one of those peano curve things in a recent comic?
15:33:50 <AStorm> I don't know. If the reversal process is lossless, you are certainly.
15:33:58 <dmhouse> What library should I look toward for MD5 or similar hashing?
15:34:07 <SamB_XP> nmessenger: you mean the map of the internet?
15:34:14 <emu> dibblego: well, every time you cons onto the list, you also append to the end of the reversed one?
15:34:14 <yaxu> nmessenger: yes!
15:34:20 <dons> dmhouse: -package crypto ?
15:34:22 <dons> ?where crypto
15:34:23 <SamB_XP> certainly sounds like it
15:34:23 <lambdabot> http://www.haskell.org/crypto
15:34:24 <nmessenger> SamB_XP: yeah, it was cool
15:34:26 <yaxu> although he didn't acknowledge peano
15:34:33 <dibblego> emu, yeah something like that - I'm trying to figure out dons DList
15:34:53 <yaxu> http://blag.xkcd.com/2006/12/11/the-map-of-the-internet/
15:34:54 <lambdabot> Title: xkcd » Blog Archive » The Map of the Internet
15:35:38 <yaxu> ah, he's updated it with that wikipedia link
15:37:22 <SamB_XP> dibblego: what are you having trouble with?
15:37:44 <SamB_XP> dibblego: what is this about memoized reverse?
15:37:44 <dibblego> SamB, nothing in particular, just reading
15:37:50 <emu> yea that map though, puts "128" in "Various Registrars" ... er, it's almost all Universities
15:38:00 <SamB_XP> I don't remember anything like that in DList...
15:38:10 <dibblego> no, but I figure it will have clues
15:40:07 <SamB> huh?
15:40:08 <SamB> clues?
15:42:15 <LPhas> if i made a lib and install it with cabal, i need to compile programs that uses it with -llibname or won't work
15:42:23 <LPhas> there's a way to avoid this?
15:42:47 <LPhas> oh, cancel this last question
15:43:31 <SamB> ???
15:44:36 <AStorm> You mean like {# OPTIONS -lthat #} ?
15:44:42 <AStorm> (or something like that
15:49:32 <LPhas> AStorm, yes :)
15:50:00 <nmessenger> cos 2665 = ?
15:50:16 <Saizan> > cos 2665
15:50:18 <lambdabot>  0.598291004138719
15:50:45 <nmessenger> 2665 = <heart>
15:51:10 <syntaxfree> My ordinary approach is useless here.
15:55:39 <dcoutts__> dons: have a good xmas?
15:59:51 <dmhouse> ?tell Igloo thanks for the nice and simple MD5 module, way easier than the dark depths of crypto :)
15:59:52 <lambdabot> Consider it noted.
16:01:54 <rahikkala> Hm, how would you cause a value to be computed (so that Debug.Trace.TraceS get called) without actually printing the value in ghci? I'm getting some confusing output in here..
16:02:13 <bd_> seq?
16:02:21 <rahikkala> Thanks, that works
16:02:37 <bd_> something like foo `seq` return () in a monad
16:03:50 <rahikkala> I just did "seq confusingFunction ()"...
16:04:27 <SamB_XP> well, you might need something that goes deeper than just seq
16:05:21 * rahikkala tinkers some more and, it turns out, ends up also agreeing with SamB_XP :/
16:05:51 <SamB_XP> like, say, length confusingFunction `seq` ()
16:06:51 <rahikkala> Ay, that works better, thanks :)
16:07:04 <rahikkala> SamB_XP++
16:09:59 <conal> does anyone here use "#ifdef __HADDOCK__" ?
16:13:11 <dcoutts__> conal: yes
16:13:43 <conal> dcoutts:  i'm trying "#ifdef __HADDOCK__", but haddock doesn't parse the #ifdef.
16:13:50 <conal> Is it necessary to cpp before haddock gets it?  can that be done through cabal?
16:14:18 <dcoutts__> conal: yes it's necessary to cpp it first, Cabal can do that if you tell it you're using the CPP language extension
16:14:45 <conal> Oh!  I'll try that.  Thanks!!
16:14:59 <dcoutts__> conal: iirc it's just 'extensions: CPP' in your .cabal file
16:15:15 <SamB_XP> does Cabal pass -D__HADDOCK__ ?
16:16:43 <conal> dcoutts:  super.  that did the trick.
16:17:00 <dcoutts__> SamB: yep
16:38:53 <ClaudiusMaximus> newbie question:  say i have x::[Char] and h::Handle and i want to (hPutChar h) each element of x in sequence, how would i do that?
16:41:24 <Cale> @type hPutStr
16:41:25 <lambdabot> Not in scope: `hPutStr'
16:41:45 <Cale> @type System.IO.hPutStr
16:41:47 <lambdabot> GHC.IOBase.Handle -> String -> IO ()
16:41:54 <Cale> ClaudiusMaximus: like that :)
16:42:02 <Cale> hPutStr h x
16:42:17 <ClaudiusMaximus> Cale: ahhh, i just realised that String is [Char], but i'm also planning on doing the idiom with types other than Char...
16:42:22 <Cale> ah, okay
16:42:34 <Cale> mapM hPutChar x
16:42:36 <Cale> er
16:42:39 <Cale> mapM (hPutChar h) x
16:42:45 <ClaudiusMaximus> Cale: thanks :)
16:43:14 <syntaxfree> Haskell needs more easy-to-use IO combinators like "interact" .
16:43:26 <SamB_XP> mmm
16:43:33 <syntaxfree> The Unix way should be " do everything with interact" , but people are never content.
16:43:36 <Cale> what other ones would you recommend?
16:43:50 <syntaxfree> interact for arbitrary handles, for example.
16:43:55 <syntaxfree> so file i/o is easy too.
16:44:05 <Cale> oh, that's reasonably easy
16:44:08 <syntaxfree> interact is all I can see newbies having a use for, but they're never happy.
16:44:26 <SamB_XP> maybe it is because they are newbies that they are not happy?
16:44:30 <Cale> interact is not easy to use for interactive programs
16:45:01 <Cale> (somewhat ironically)
16:45:14 <syntaxfree> yes. Before I found about interact, I used to call it munge.
16:47:05 <sorear> ?seen
16:47:05 <lambdabot> Lately, I have seen cale, claudiusmaximus, nonpop, samb_xp, sorear and syntaxfree.
16:47:18 <twanvl> Maybe you want haskell 1.2 (or something around that time)
16:47:23 <syntaxfree> There are so many fun things to do before one dicks with the " guess the number"  example from YAHT.
16:47:37 <syntaxfree> Interactive programs are overrated.
16:48:12 <Cale> indeed, but if you're not writing an interactive or gui program, why mess with the IO monad at all?
16:48:24 <Cale> GHCi provides a wonderful UI :)
16:48:34 <syntaxfree> Because you want to distribute programs.
16:48:48 <syntaxfree> or use them in shell scripts, or from GUI scripting language like AppleScript / wsh.
16:49:50 <sorear> ghc -e !
16:51:11 <syntaxfree> anyway, interact seems like a good model of how simple IO combinators could be built.
17:05:27 * dcoutts__ finds that many of his functions end up being called mungeThis mungeThat etc
17:06:03 <conal> interaction combinators are exactly what i'm working on right now.  generalizing "interact".
17:06:06 <GsD_CeleborN> anyone know, where do I find example the wxHaskell using OpenGL?
17:06:58 <dcoutts__> GsD_CeleborN: there are a few for using HOpenGL with Gtk2Hs
17:07:20 <dcoutts__> I think there's at least one wxHaskell OpenGL demo too
17:07:52 <GsD_CeleborN> [dcoutts__]: gtk too
17:07:54 <Saizan> I feel guilty when i write a function that i can't find a significant name for..
17:08:13 <GsD_CeleborN> [dcoutts__]: gtkhs 0.9.10 ?
17:08:21 <GsD_CeleborN> [dcoutts__]: for windows ?
17:08:48 <sorear> ?type foldl
17:08:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:09:09 <dcoutts__> GsD_CeleborN: yes, the latest snapshot has opengl and I'm building it on windows right now, it's worked ok in the past on win32 too
17:09:43 <GsD_CeleborN> [dcoutts__]: nice
17:10:12 <SamB_XP> conal: you are the one who would complain if reverse . reverse was eliminated?
17:10:19 <dcoutts__> GsD_CeleborN: see http://darcs.haskell.org/gtk2hs/demo/opengl/
17:10:21 <lambdabot> Title: Index of /gtk2hs/demo/opengl
17:10:32 <dcoutts__> SamB_XP: it's a refinment not a =
17:10:35 <conal> SamB_XP: i don't think so.
17:10:39 <yaxu> http://doc.gold.ac.uk/~ma503am/alex/hpeano
17:10:43 <lambdabot> Title: Peano curve weaves of whole songs | Alex McLean
17:10:43 <SamB_XP> ndm said you would ;-)
17:10:56 <conal> samb_xp: who's ndm?
17:11:02 <dcoutts__> SamB_XP: there are plenty of people who would object
17:11:07 <SamB_XP> hmm.
17:11:11 * SamB_XP may be confused
17:11:28 <SamB_XP> neil?
17:12:12 <yaxu> thanks to all who have helped me get this working the last few days
17:12:48 <SamB_XP> conal: are you at york?
17:13:26 <conal> samb_xp: nope.  in seattle.
17:13:35 <sorear> Neil Mitchell, author of/contributer to { Catch, Yhc, WinHugs, Hat }
17:13:39 <SamB_XP> ah, okay, it was somebody else then ;-)
17:13:45 * SamB_XP forgets who
17:14:06 <SamB_XP> somebody who used reverse . reverse for buffering with interact
17:14:14 <syntaxfree> reverse = foldl (flip (:)) []
17:14:22 <liyang> Mmmm... Venetian Snares
17:14:22 <syntaxfree> reverse . reverse?
17:16:14 <yaxu> liyang: one of my favourite tracks
17:16:42 <syntaxfree> conal: what's the reverse . reverse story?
17:17:06 <sorear> reverse.reverse is a very strict way of writing id.
17:17:21 <syntaxfree> is it?
17:17:22 <SamB_XP> sorear: yes, exactly
17:17:55 <syntaxfree> and one wants that because of...?
17:18:00 <Saizan> yaxu, what it use as input?
17:18:35 <SamB_XP> so that all of a user's input line would appear before the output for that line?
17:18:56 <Cale> syntaxfree: strictness. Though I think using reverse for the evaluation side effects is abusive
17:19:10 <SamB_XP> Cale: I agree
17:19:21 <Cale> We do have seq for that
17:19:23 <SamB_XP> I think you should tell ndm's supervisor that...
17:19:59 <syntaxfree> I understand wanting to enforce strictness. But why on id?
17:20:07 <SamB_XP> something like...
17:20:22 <liyang> yaxu: http://www.last.fm/group/haskell =)
17:20:23 <lambdabot> Title: haskell &ndash; Groups at Last.fm
17:20:49 <Cale> syntaxfree: it basically strictifies the list, making it impossible to observe the first cell without constructing the last.
17:20:56 <SamB_XP> interact (lines . map (f . reverse . reverse) . lines)
17:21:04 <Cale> unlines
17:21:10 <SamB_XP> er, yeah.
17:21:12 * SamB_XP silly
17:21:22 <yaxu> Saizan: music
17:21:27 <syntaxfree> Ahh
17:21:30 <syntaxfree> Is reverse cheap?
17:21:38 <Cale> That's a cheesy way to do that though.
17:21:40 <SamB_XP> its O(1)
17:21:48 <SamB_XP> I think you should tell ndm's supervisor that...
17:21:58 <Saizan> yaxu: mmh wrong question: in which format?
17:21:58 <SamB_XP> er.
17:22:01 <SamB_XP> O(n)
17:22:03 <SamB_XP> ack
17:22:12 <yaxu> liyang: ha!  new order and plaid are my favourites too
17:22:53 <yaxu> Saizan: ah, one sec
17:23:41 <yaxu> Saizan: if you're using sox, then convert with  -t raw -r 10000 -u -b -c 1
17:23:48 <GsD_CeleborN> [dcoutts__]: do you know only this example ?
17:23:52 <yaxu> Saizan: changing -r to taste
17:24:05 <Cale> strictList xs = foldr seq () xs `seq` xs
17:24:25 <SamB_XP> Cale: tell ndm's supervisor!
17:24:28 <dcoutts__> GsD_CeleborN: I've got another example that I use as a first year CS FP practical
17:24:32 <yaxu> Saizan: if you're not, then that's a headerless unsigned 8 bit mono file with samplerate around the 10000 mark
17:24:34 <Cale> SamB_XP: why?
17:24:39 <wolverian> hm, WASH is scary
17:24:44 <Cale> Can't ndm do that?
17:24:59 <SamB_XP> hmm.
17:25:03 <SamB_XP> well, tell ndm anyway ;-)
17:25:17 <yaxu> Saizan: let me know if you get nice output
17:25:22 <GsD_CeleborN> [dcoutts__]: where it
17:25:22 <Saizan> yaxu: oh, ok, quite the bare signal
17:25:27 <dcoutts__> GsD_CeleborN: and a gtk2hs version of 'haskls' and someone sent me a text rendering demo
17:25:39 <Saizan> yaxu: ok :)
17:25:48 <Modius> Okay, what's the best Haskell tutorial for a person who programs functional/stateless but wants to learn haskell from the ground up.
17:25:55 <yaxu> Saizan: :)  yes it would be good to port libsndfile to haskell
17:25:57 <dons> ?where yaht
17:25:57 <dcoutts__> GsD_CeleborN: the practical is not available outside of comlab.ox.ac.uk sadly, let me find haskls...
17:25:58 <syntaxfree> Gentle Introduction?
17:25:58 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:25:59 <dons> probably
17:26:08 <Modius> Online or the book?
17:26:08 <dons> yaht or the gentle introduction, Modius
17:26:14 <dons> check haskell.org under 'Tutorials and books'
17:26:18 <Modius> Thanks
17:26:18 <edi> ?where nymphaea -- dcoutts__ there also this! (hiya)
17:26:19 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
17:26:40 <Saizan> yaxu: something handy to write pngs too :D
17:26:56 <edi> cairo!
17:27:40 <dcoutts__> edi: yes that's really nice, but it's not a demo of hopengl+gtk2hs
17:27:57 <edi> dcoutts__: ah, I thought haskls was 2d
17:28:28 <edi> ...for hopengl per-se there are the neat Syzygy-'s tutorials too.
17:29:08 <GsD_CeleborN> i need opengl with widgets
17:29:24 <dcoutts__> GsD_CeleborN: yeah, there's not much too it really, once you see the pattern in that really simple gtk2hs+opengl demo you don't need much more
17:29:57 <dcoutts__> GsD_CeleborN: it's basially just using that with drawing area function then calling opengl things
17:30:10 <GsD_CeleborN> [dcoutts__]: yeah
17:30:39 <GsD_CeleborN> [dcoutts__]: with exempla ,would be better
17:31:20 <newsham> someone should build haskell bindings for vtk.
17:31:45 <dcoutts__> newsham: what's that?
17:31:58 <newsham> http://www.vtk.org/ visualization toolkit.  higher level than opengl
17:32:24 <dcoutts__> GsD_CeleborN: ah, here http://haskell.org/~duncan/gtk2hs/HaskLS.png
17:32:28 <newsham> python, tcl and java bindings are built by parsing the c++ src.  i imagine that would make it easy to build haskell ffi bindings
17:32:34 <dcoutts__> GsD_CeleborN: I'll put the source up in a sec
17:32:49 <GsD_CeleborN> dcoutts__:ok
17:34:37 <newsham> i built a python app with vtk+gtk. it was very pleasant to use
17:37:30 <bd_> Is there any extension to pattern-match against bytestrings, yet?
17:37:54 <sorear> views
17:38:03 <bd_> views?
17:38:08 <sorear> you never specified *implemented* extensions :)
17:38:23 <dcoutts__> bd_: in other words, no.
17:38:40 <dcoutts__> GsD_CeleborN: darcs get http://haskell.org/~duncan/gtk2hs/haskls/
17:38:41 <lambdabot> Title: Index of /~duncan/gtk2hs/haskls
17:38:42 <sorear> ancient proposal, by phil wadler iirc, which would have allowed for datatype-defined matching functions
17:38:46 <bd_> heh
17:38:48 <bd_> okay then
17:38:59 <bd_> I guess I'll just use strings for now
17:39:18 <syntaxfree> long live the Wadlerman!
17:40:05 <shapr> Wow, I see trolls in the scrollback.
17:40:17 <newsham> hmm.. why not write regexp lib so that it works with any sequence of Eq's?
17:40:25 <newsham> (Ord's?)
17:42:32 <Saizan> you need enumeration for [a-z] things, and those \d \s? just ignore them?
17:43:12 <yaxu> shapr: ooh, where?
17:43:46 <newsham> saizan: you can implement extensions for special types like chars where needed (ie. \d)
17:44:16 <newsham> and allow for ranges where they make sense?
17:46:39 <dcoutts__> bd_: just out of interest, what kind of string patterns are you using ?
17:46:47 <Saizan> mmh yes it should be quite modular allowing a different set of "special types" for each instance
17:46:51 <dons> shapr: oh, which trolls? did I miss one?
17:47:19 <bd_> dcoutts__: I was thinking of writing a HTTP server in haskell... but then again I might also find a way to just rip MACID out of HAppS and use that, too...
17:47:40 <newsham> it seems a shame that you cant reuse a lot of the current string functions with bytestring
17:47:54 <newsham> should be a way to unify those (and allow other string impls possibly?) no?
17:47:54 <dcoutts__> bd_: yes, HAppS has a bytestring-based http parser & stuff
17:47:54 <bd_> so eg, handler "GET" ... = ... <-- if "GET" here could be a bytestring match...
17:48:35 <newsham> isnt dons going to put bytestring into HWS, too?
17:49:00 <dcoutts__> newsham: using a class, like we do for Num, except that the Stringish class would have many more methods
17:49:11 <dcoutts__> it'd be a lot fatter
17:49:34 <newsham> how about a class for things that are sequences?
17:49:41 <bd_> Data.Traversable?
17:49:55 <dcoutts__> it'd have to be a MPTC
17:50:01 <newsham> mptc?
17:50:14 <dcoutts__> since not all sequences are parameterised by their content
17:50:21 <dcoutts__> multi parameter type class
17:50:54 <newsham> anyway, fun to talk about and dream of.. but i'm afraid i wont be helping to make anything happen :(
17:51:18 <dcoutts__> there's a paper about this stuff, "bulk types with class" iirc
17:51:24 <dcoutts__> @google bulk types with class
17:51:25 <lambdabot> http://research.microsoft.com/Users/simonpj/Papers/collections.ps.gz
17:51:29 <GsD_CeleborN> [dcoutts__]: did you get to compile that example? from http://haskell.org/~duncan/gtk2hs/haskls/
17:51:29 <lambdabot> Title: Index of /~duncan/gtk2hs/haskls
17:51:31 <dcoutts__> yep, that one
17:52:06 <dcoutts__> GsD_CeleborN: I did, yes, with gtk2hs-0.9.10.3
17:52:17 <newsham> i dream of a day when the various container types and implementations are all there in a library and all of the common algorithms over them are also in libraries, and i can mix and match at will
17:52:17 <GsD_CeleborN> [dcoutts__]: on windows ?
17:52:42 <dcoutts__> but I think it worked with 0.9.10.1 too, it will not work with 0.9.10 as the opengl bits got added later
17:52:45 <newsham> like "give me a graph built with adjacency lists and an algorithm for computing the strongly connected components
17:53:19 <dcoutts__> GsD_CeleborN: the latest official installer for win32 was for 0.9.10, so on windows you'd need a later build or build from source
17:53:22 <newsham> and all the algorithms are general over many data implementations.. and the lion lays down with the lamb ...
17:53:41 <dcoutts__> GsD_CeleborN: if you can wait, I am doing new builds for windows atm
17:54:08 <GsD_CeleborN> dcoutts__: get this error on 0.9.10 "Could not find module `Graphics.UI.Gtk.OpenGL':"
17:54:10 <newsham> having to choose between bytestring and existing string libraries is a big frowny face
17:54:33 <dcoutts__> GsD_CeleborN: yes, because the opengl stuff wasn't added until a later version
17:54:36 <GsD_CeleborN> [dcoutts__]: but the RotationCube done
17:55:31 <dcoutts__> newsham: many existing things that use String are prefectly fast enough as they are
17:55:44 <newsham> *nod* true
17:55:54 <dcoutts__> newsham: so there's no need to convert them, just use pack/unpack on the boundary
17:56:17 * dylan wonders if String -> ByteString could be a compiler optimization
17:56:20 <dcoutts__> if you're not converting that much then it's fine
17:56:30 <sorear> dylan: oooh neeat....
17:56:36 <sorear> (idea)
17:56:42 <dcoutts__> dylan: it needs a lot of analysis to see if the conversion is valid
17:56:58 <newsham> but the point of the complaint is that many of the underlying functions only rely on simple operations that can be implemented for [Char] and ByteString.  so its sad that the code doesnt accomodate both
17:57:01 <dylan> dcoutts__: well, until we have something more unicode friendly, perhaps
17:57:18 <sorear> ByteString + UTF8
17:57:19 <newsham> mine is more a philosophical whine than a pragmatic one :)
17:57:34 <dcoutts__> since ByteString has only a subset of the semantics of String, so you need to figure out if you're existing use of String operates within the subset covered by ByteString, lots of deep strictness alaysis I reckon.
17:58:06 <sorear> lazy lists are evil.  not just [char], all lazy lists.
17:58:21 <dcoutts__> sorear: you'd best not use ByteString.Lazy then
17:58:25 <sorear> it's just no-ones found a practical alternative (with lazyness)
17:58:44 <sorear> ByteString.Lazy is crazy-elegant
17:58:55 <newsham> <- lazy programmer on vacation.
17:58:57 <dcoutts__> dylan: having a unicode bytestring impl is much much easier that automatic conversion
17:58:58 <newsham> please do not evaluate
17:59:14 <sorear> I'm talking about the kind of lazy that forces an indirect call every single character.
18:00:35 <dcoutts__> sure, [Char] is a silly string representation for performance
18:00:37 <sorear> I am definitely going to have a look at Clean - my limited understanding of uniqueness types has already produced an efficient encoding of (:) on lazy byttestrings
18:00:57 <dcoutts__> it's nice and elegant though, really simple for beginners to grok
18:01:13 <GsD_CeleborN> [dcoutts__]: do have some way to use 0.9?
18:01:14 <GsD_CeleborN> .10
18:01:31 <GsD_CeleborN> [dcoutts__]: do have some way to use 0.9.10.3 om windows?
18:01:39 <dcoutts__> GsD_CeleborN: you can build from source or wait for me to do that instead
18:01:46 <sorear> "qq is not a mailbox" -- modeful programs can be annoying
18:02:10 <dcoutts__> sorear: oh you mean constant time append by guaranteeing uniqueness
18:02:30 <dcoutts__> so you can just write into a memory block
18:02:57 <dcoutts__> sorear: I think that can be done without uniqueness typing without much perf loss
18:03:17 <dcoutts__> though with a more complex implementation
18:03:38 <shapr> sorear: I could easily have done 50k CTCP actions, I think channel actions are CTCP.
18:04:22 <newsham> playing with irc, shapr?
18:06:19 <sorear> shapr: Yes, I was specifically referring to 'CTCP ACTION'
18:09:31 <shapr> newsham: I just crashed X somehow...
18:09:35 <shapr> Is that what you mean?
18:09:55 <newsham> no.  the ctcp/action stuff
18:10:18 <shapr> I was just looking for shapr in my logs, and I saw sorear talking about number of actions.
18:10:52 <fnord123> if you press C-M-Bs X will die.
18:11:02 <sorear> I was trying to compress the logs as much as possible
18:11:37 <sorear> I can send you a program that will reliably segfault X.org iff you are using software 3D
18:13:14 <syntaxfree> http://www.eskimo.com/~miyaguch/grady/emptypromise.html
18:13:15 <lambdabot> Title: The Empty Promise
18:14:49 <mwc> newsham, re vtk bindings for haskell. Binding C++ is painful, involving manual symbol demangling. Or so I last read on the wiki
18:15:26 <newsham> mwc: shouldnt add much complexity if its generated automatically.
18:15:42 <newsham> other bindings are generated automatically
18:15:45 <sorear> mwc: man c++filt
18:16:09 <newsham> i imagine they also deal with name mangling to interface
18:16:26 <mwc> sorear, exactly.
18:16:42 <mwc> last I checked we didn't have any automagical C++ binding generators
18:17:07 <mwc> If parsing C is hard enough for c2hs, C++ would be an order of magnitude worse
18:17:28 <newsham> there is already code that parses the c++ and spits out bindings for java, tcl and python
18:17:43 <sorear> Is there any chance we could hijack the GNU cc1plus fe?
18:18:11 <newsham> sorear: is ghc tied to gcc?
18:18:24 <Saizan> newsham, nothing so painfree last time i checked, at least for python
18:18:40 <mwc> I do know that C++ isn't lalr(1) parseable, so happy is out. I can't see any reason a Parsec grammer couldn't be written
18:18:41 <allbery_b> there're a number of ways to make x.org segfault :)
18:18:44 <sorear> newsham: no, it uses its own code generator nowadays by default
18:19:41 <allbery_b> then again, I used to make openwindows hang solaris boxen so hard they wouldn't do l1-a :)
18:19:47 <sorear> Project: write a C++ parser using context sensitive grammar combinators. (45 pts)
18:20:03 <sorear> l1-a?  that anything like alt-sysrq-k?
18:20:13 <newsham> heh.. writing a c++ parser is more work than writing a vtk equivalent :)
18:20:23 <sorear> what is vtk?
18:20:37 <newsham> www.vtk.org
18:20:38 <allbery_b> "break to PROM"
18:21:32 <Modius> Haskell question :  read "3" is ambiguous, error, whereas:      9 + read "3" works.  What is the name of the language mechanism at work here so I can study it on the side?  I guess it has a lot of relevance to haskell. . . . .
18:21:43 <newsham> > read "3" :: Int
18:21:44 <lambdabot>  3
18:21:45 <bd_> type classes?
18:21:45 <sorear> defaulting
18:21:55 <Modius> No, read "3" is ambiguous and it fails
18:21:56 <Modius> in ghc
18:21:58 <newsham> modius: type inference.
18:22:03 <sorear> 9 is ambiguous ; it has type Num a => a.
18:22:06 <allbery_b> defaulting of type classes.
18:22:10 <newsham> ?type read
18:22:12 <lambdabot> forall a. (Read a) => String -> a
18:22:12 <Modius> I'm talking about typed at the prompt
18:22:17 <mwc> > read "3"
18:22:17 <lambdabot>  Add a type signature
18:22:19 <Modius> Type inference - thanks
18:22:21 <iah> ?type 9 + read "3"
18:22:23 <lambdabot> forall a. (Num a, Read a) => a
18:22:32 <sorear> but, haskell auto-resolves it to integer using a little-known feature called numeric defaulting
18:22:37 <Modius> I'm not trying to get rid of the error, I'm just in a tutorial - just trying to understand what is in read that is doing this.
18:22:41 <mwc> indeed.
18:22:45 * shapr boings
18:22:58 <newsham> modius: there are many (Read a)'s.  haskell needs to know which one to use.
18:23:01 <sorear> It works at so many types, GHCi can't figure out which to use
18:23:12 <mwc> Modius, as people have pointed out, in the second case the type to convert to is a Num, so defaulting takes care of it. In the first, it's too general
18:23:30 <Modius> Right - this is in contrast to C-languages where read("3") would instantiate a specific version of read based on the type of the parameter and nto the surroundings.
18:23:32 <iah> I have aquestion about functional dependencies: is there any way to tell ghc that a functional dependency holds for certain instances, but not others?
18:23:36 <newsham> > (read :: String -> Int) "3"
18:23:38 <lambdabot>  3
18:23:41 <newsham> > read "3" :: Int
18:23:42 <lambdabot>  3
18:23:44 <mwc> Modius, well, C++ you mean
18:23:47 <sorear> iah: leave it out
18:23:48 <Modius> Aah, starting to get it.
18:23:58 <mwc> plus in C++ you can't overload functions on return type.
18:24:05 <Modius> C++ , yeah (learning lisp and , now, haskell, I'm stereotyping C++ in with C# and Java on this)
18:24:06 <iah> sorear: then ghc has trouble deducing a bunch of things
18:24:12 <sorear> iah: if you leave out a fundep, ghc will assume it holds for not-all instances
18:24:24 <sorear> iah: if you add fundep, ghc will assume it holds for all instances
18:24:27 <Cale> > read "3" :: Double
18:24:28 <lambdabot>  3.0
18:24:31 <Modius> I don't see this as a downside but an example I imagine of the power of the language - that it can use type of surroundings.
18:24:34 <Modius> "Type inference" thanks
18:24:46 <newsham> > read "3" :: [Bool]
18:24:47 <lambdabot>  Exception: Prelude.read: no parse
18:24:51 <Cale> yeah, type-directed programming can be really powerful
18:24:57 <sorear> > read "True" :: Bool
18:24:58 <lambdabot>  True
18:25:07 <nornagon> > read "True"
18:25:08 <lambdabot>  Add a type signature
18:25:12 <Saizan> > read "3" :: String
18:25:13 <lambdabot>  Exception: Prelude.read: no parse
18:25:23 <Cale> Later on, you'll learn about monads, and that's essentially one big example of how this kind of polymorphism is useful.
18:25:28 <Modius> I can think of times where I've wanted this (to be able to pick the version based on where it's going rather than the input - in C++ you'd have to pass in a return type blech)
18:25:32 <dylan> read "'c'" :: Char
18:25:35 <dylan> > read "'c'" :: Char
18:25:36 <lambdabot>  'c'
18:26:02 <newsham> > read (show 'c') :: Char
18:26:03 <lambdabot>  'c'
18:26:52 <syntaxfree> Then you'll learn about comonads and you'lll either flip out like me or not be too impressed.
18:27:01 <Cale> @type sequence
18:27:02 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:27:12 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
18:27:13 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
18:27:20 <newsham> sf: got a good example of a comonad?  i havent gotten to that yet
18:27:29 <Cale> > sequence [Nothing, Nothing, Just 5, Just 7, Nothing]
18:27:30 <lambdabot>  Nothing
18:27:40 <dylan> "Comonad" reminds me of a toilet
18:27:44 <Saizan> newsham: sigfpe.blogger.com
18:27:46 <syntaxfree> newsham: sigfpe's blog has a great example: cellular automata.
18:27:52 <syntaxfree> sigfpe.blogspot.com, actually.
18:27:56 <Cale> > sequence [Just 5, Just 7, Just 12]
18:27:58 <lambdabot>  Just [5,7,12]
18:28:07 <mwc> Modius, or you could do it with templates: read<int>("3");
18:28:10 <Saizan> too many blog*
18:28:13 <newsham> no one liner lambdabot example?
18:28:27 <iah> comonads aren't actually in the standard library
18:28:34 <syntaxfree> Haskell doesn't support comonads out of the box.
18:29:00 <Cale> You just define your own comonad class and some instances, and then use it. :)
18:29:10 <mwc> syntaxfree, don't we need Rank-2 poly to do it?
18:29:23 <syntaxfree> not really.
18:29:27 * mwc looks for the Comonad and Codata in Haskell paper
18:29:27 <Cale> syntaxfree: rank-2 polymorphism for what?
18:29:34 <Cale> er
18:29:38 <Cale> mwc: rank-2 polymorphism for what?
18:29:46 <mwc> I recall they used some Rank-2 poly, but I cna't recall if that was a specific instance of a comonad or the class itself
18:29:53 <newsham> mwc: looks like VTK/Wrapping/* already has a yacc parser for groking what is needed out of the c++ src
18:30:16 <syntaxfree> at least not for the " zipper"  comonad sigfpe uses for cellular automata.
18:30:19 <Cale> class (Functor w) => Comonad w where extract :: w a -> a; split :: w a -> w (w a)
18:31:05 <Cale> That's really all there is to it. You can things like cobind and such
18:31:46 <Cale> Of course, there's a few laws, but no higher-rank polymorphism is needed to get basic examples of comonads going.
18:32:45 <Cale> I think the simplest examples are nonempty lists, and infinite streams.
18:32:49 <\z> Evening, everybody.
18:33:16 <Cale> Evening λz
18:33:53 <fnord123> @type read
18:33:54 <\z> Anyone got time for an HXT question?
18:33:54 <lambdabot> forall a. (Read a) => String -> a
18:34:01 <Cale> sure
18:34:04 <syntaxfree> yes.
18:34:13 <syntaxfree> " What is HXT" ?
18:34:15 <\z> I've got a simple element, with a single text child node.
18:34:15 <fnord123> if its simple, ill have a stab about hxt
18:34:18 <syntaxfree> There's your HXT question.
18:34:20 <\z> I want to lift that into an attribute
18:34:22 <fnord123> haskell xml toolbox
18:34:25 <syntaxfree> Than you very much and have a nice day.
18:34:36 * syntaxfree knew, he just wanted to make the dumb joke.
18:34:46 <newsham> syntaxfree: trying to be #python/#c?
18:34:58 <\z> I can see how the arrows work for simple things like getCmt >>> mkCdata
18:34:58 <syntaxfree> newsham: huh?
18:35:15 <sorear> there is no #c
18:35:16 <fnord123> how do you mean "lift"?
18:35:19 <\z> but I can't seem to get the text content *out* of the child content (with getText) and stuff that into the attribute body
18:35:25 <newsham> sf: that sounded just like your typical #python/#c retort.
18:35:30 <\z> (lift is a very poor choice of words here ;-)
18:35:34 <newsham> there is a #c on efnet. (the one true irc, btw ;-)
18:35:36 <Cale> do you know the name of the attribute a-priori?
18:35:43 <Cale> Or is that coming from elsewhere?
18:35:47 <syntaxfree> newsham: oh. I thought I was being original.
18:35:57 <newsham> sf: afraid not :(
18:36:03 <\z> Cale: I'm trying to create an attribute, so yes.
18:36:18 <fnord123> if you dont know the children youre going to get, why would you process it?
18:36:26 <\z> Cale: The content of the attribute should be the content of the text content for the element.
18:36:44 <fnord123> unless you're transforming i guess
18:36:46 <Cale> attr "href" getText
18:36:49 <Modius> Question:  What is it that makes the following fail:   map Char.toUpper filter Char.isLower "Hello World"    ?
18:36:53 <Cale> or something like that
18:36:59 <Modius> Is it that map tries to act upon "filter" rather than the filtered?
18:37:14 <Cale> Modius: map is being applied to 4 parameters
18:37:19 <Cale> yes
18:37:22 <syntaxfree> Modius: precedence.
18:37:34 <\z> Cale: not quite.
18:37:41 <newsham> > map toUpper (filter isLower "Hello World")
18:37:42 <Cale> map Char.toUpper . filter Char.isLower $ "Hello, World"
18:37:43 <lambdabot>  "ELLOORLD"
18:37:44 <\z> getText :: (ArrowXml a) => a XmlTree String
18:37:46 <sylvan> Modius, never thought a Lisper would have trouble with not inserting enough parenthesis :-)
18:37:49 <\z> attr :: (ArrowXml a) => String -> a n XmlTree -> a n XmlTree
18:37:50 <Modius> Right, parens fix it.
18:37:56 <Modius> Hey, I'm a C++/C# guy :)
18:38:00 <Cale> \z: ah, right
18:38:06 <syntaxfree> I thought you were a Lisp guy.
18:38:11 <newsham> modius: now c++/c#/haskell :)
18:38:15 <Modius> I deliberately caused this failure, just wanted to know if the precedence is strictly left-right or if there's something else
18:38:34 <syntaxfree> Modius: silly question: do you grok the idea of " lazy evaluation"  already?
18:38:50 <\z> I even delved into the Filter interface for HXT, but that  seemed much more trouble than it's worth
18:39:00 <Modius> I know what lazy evaluation is - I actually do it a bit (albeit explicitly) through abusive use of IEnumerable<Type> in C# :)
18:39:00 <newsham> modius: application is high precedence.   so  (((map toUpper) filter) isLower) "hello world"
18:39:03 <syntaxfree> You irritated me somewhat earlier today using  "lazy"  and " stateless"  as synonyms. I thought you were a troll.
18:39:15 <Cale> \z: mkText will make a text element, but that seems roundabout
18:39:16 <Modius> newsham:  THanks.
18:39:24 <Cale> perhaps  attr "href" (pure id) ?
18:39:32 <Modius> syntaxfree:  If I came across as equating lazy and stateless I'm sorry - I do know they're separate things.
18:39:51 <Modius> syntaxfree: And I thank you for your contribution/clarificaton.
18:40:00 <syntaxfree> nah. Just nice to know you're not a troll.
18:40:05 <syntaxfree> :)
18:40:07 <sylvan> syntaxfree: though it could be argued that lazy implies purity, which could be argued implies stateless... sort of.. :-)
18:40:34 <Cale> lazy evaluation just means that you're evaluating things outermost first, but avoiding repeated computation whenever the parameter to a function is duplicated in its body
18:40:52 <Modius> Are you saying that the precedence ties in with the mechanism for laziness?
18:40:55 <\z> Cale: It typechecks, but it doesn't actually add any content.  :-)
18:40:59 <Cale> hmm
18:41:00 <syntaxfree> No, I'm not.
18:41:07 <syntaxfree> I just wanted to know whether to take you seriously!
18:41:08 <\z> it adds an attribute without any content.
18:41:15 <Cale> \z: That's interesting :)
18:41:21 <newsham> precedence is just how it goes from flat strings to the real tree representation of your program
18:41:39 <Modius> There's probably a fine line between wanting to bring the good, bad and the ugly out and trolling.
18:41:40 <\z> It actually  needs to be something like: addAttrl (attr "href" (getText >>> mkText))
18:41:45 <Cale> \z: well, how about   attr "href" (getText >>> mkText)
18:41:49 <maskd> i'm trying to learn haskell using the "write yourself a scheme in 48 hours", but the first example code fails to compile
18:41:51 <Cale> yeah
18:41:57 <maskd> the code: http://paste.lisp.org/display/33458
18:41:57 <\z> attr "href" (getText >>> mkText) will replace the current node with an attribute
18:42:14 <newsham> cale: is that Text.Html?  or HXT?
18:42:19 <Cale> that's a little odd to me -- seems like it's deconstructing the text node and reforming it again, but if it works, I suppose it works :)
18:42:21 <Cale> HXT
18:42:39 <Cale> maskd: I'll have a look
18:42:49 <newsham> hmm.. look somewhat similar (at least Text.Html also uses >>>)
18:42:57 <newsham> err.. rather <<< I guess
18:43:00 <Modius> I'll probably eventually take haskell concept type programming back to lisp via QI :)
18:43:12 <\z> Hm....this is quite puzzling....
18:43:14 <Cale> maskd: how are you attempting to compile it?
18:43:15 <newsham> blah, i'm wrong.  its "<<"
18:43:29 <\z> SUCCESS!!!!
18:43:36 <\z> addAttrl (attr "href" (getChildren >>> getText >>> mkText))
18:43:36 <syntaxfree> << is flip (>>)?
18:43:42 <Cale> oh
18:43:45 <maskd> Cale: ghc --make -o file file.hs
18:43:49 <SamB_XP> no!
18:43:51 <Cale> \z: try just the getChildren
18:44:03 <\z> The problem is that the current node (an element) has no text content, because it has the wrong XNode type.
18:44:04 <newsham> sf: in Text.Html its nesting.   ie    p << "Paragraph of text"
18:44:07 <Cale> getText >>> mkText ought to be equivalent to pure id
18:44:08 <mgsloan> hmm, I think the type inference stuff in regards to 3 + read "3" is only about expressions of the form 3 + x.  I would call the selection of the proper read function something like "return type based function/instance selection"
18:44:20 <\z> Cale: getChildren suffices.
18:44:24 <Cale> \z: good :)
18:44:24 <\z> In this case.
18:44:25 <iah> @paste
18:44:25 <lambdabot> http://paste.lisp.org/new/haskell
18:44:37 <\z> Thanks.  I've been banging my brains on this for the last few hours.
18:44:53 <fnord123> whats the final code, \z?
18:45:04 <Cale> \z: if I understand HXT correctly, you should never really have to do getText >>> mkText, because it's the identity map
18:45:29 <Cale> maskd: hmm, that works for me, can I see the error?
18:45:55 <\z> fnord123: test = readDocument [(a_validate, v_0)] "h.xml"
18:45:56 <\z>        >>> deep (hasName "Asset")        >>> addAttrl (attr "href" (getChildren ))
18:45:56 <\z>        >>> setChildren []
18:46:19 <maskd> Cale: file.hs:5:10: The last statement in a 'do' construct must be an expression
18:46:23 <\z> fnord123: that pushes the text content (the only child node) of the Asset tag into an href, and then purges it.
18:46:37 <Cale> maskd: oh, hmm, are there any tabs in the file?
18:47:03 <maskd> yes
18:47:04 <Cale> maskd: make sure those are spaces -- the 'putStrLn' should line up exactly with 'args' on the line above
18:47:10 <\z> Cale++
18:47:13 <maskd> hm
18:47:14 <Cale> tabs count as 8 spaces
18:47:30 <Cale> but it's safer just to not use them at all
18:47:39 <Cale> (tell your editor to turn them into spaces automatically)
18:47:50 <maskd> thanks
18:47:54 <newsham> :set et\n:retab
18:47:55 <Modius> Hehheh - while under other names, in C# I've implemented map, foldr and filter (lazyeval - that is, they take/return IEnumerables - I will rename my C# versions, which are named arbitrarily - at least SOMEONE may recognize them :)
18:48:02 <sorear> I will not abandon my tabs!
18:48:36 * dylan uses set noshiftround expandtab for haskell editing in vim
18:48:37 <sorear> oh, and newsham :set et\n:%retab  " The % is very imporant
18:48:54 <newsham> it is?  i never use
18:48:56 <newsham> %retab
18:49:04 <\z> Is there some way using Arrows to take one tree and coerce it into a totally different type?
18:49:07 <allbery_b> % would address every line of the file
18:49:09 <sorear> :retab  " re-indent the current line
18:49:12 <sorear> :$retab  " re-indent the current file
18:49:14 <allbery_b> (short for "1,$")
18:49:17 <sorear> :%retab  " re-indent the current file
18:49:22 <newsham> I've used :retab many times without %
18:49:31 <newsham> (in vim)
18:49:43 <syntaxfree> Cale: Haskell layout looks clean, but I can't help going for safety and littering code with braces.
18:49:53 * sorear uses emacs, but far more important is the fact that I would never consider changing my tabstop settings.
18:50:00 <lisppaste2> iah pasted "fundep problems" at http://paste.lisp.org/display/33460
18:50:15 <iah> is there any way to make this code typecheck?
18:50:35 <Cale> I use "set expandtab" and "set smarttab"
18:50:44 <Cale> (in vim)
18:51:13 <dylan> I use... almost all of the tab options
18:51:32 <Cale> iah: I'll have a look
18:51:38 <iah> Cale: thanks
18:54:06 <newsham> ps: if you :set et in your vimrc, dont forget to unset when playing with makefiles
18:54:14 <newsham> (what does smarttab do?)
18:54:38 <iah> it seems to me like the problem is that the fundep "a -> r" holds for the HTML instance, but not the String instance
18:54:42 <iah> and there's no way to tell GHC that
18:55:22 <iah> or GHC isn't figuring it out like it should be
18:55:52 <Cale> perhaps it would be saner to not overload things that much, and make use of the 'text' function that you have there
18:56:36 <Cale> What does the r parameter of your HTML type represent? Will it not always be String?
18:57:02 <Cale> oh, it's the environment type?
18:57:15 <Modius> Okay - Haskell parsing from file different from parsing from command line?  Command line  I need "let square x = x * x", in file I need "square x = x * x" - right?
18:57:16 <iah> Cale: in my actual code, it's state data that includes a return continuation that may have any argument type
18:57:19 <syntaxfree> wow. James Zawinsky has only a high-achool degree.
18:57:35 <iah> so it has to be polymorphic
18:57:51 <SamB_XP> syntaxfree: I thought he also had an Emacs degree?
18:57:52 <iah> I simplified it a lot for the paste bin
18:58:01 <syntaxfree> heh.
18:58:16 <syntaxfree> I used to aire jwz as a teen.
18:58:24 <syntaxfree> s/aire/admire.
18:58:40 <SamB_XP> oh, and he maintains xscreensaver doesn't he?
18:58:42 <syntaxfree> Good thing I never knew he didn't have a degree; I might have dropped out, or something.
18:58:55 <syntaxfree> SamB_XP: Oh, he was one of the project leaders at Netscape.
18:59:03 <SamB_XP> ah, leaders?
18:59:04 <syntaxfree> He maintained Mozilla during the early open source days as well.
18:59:09 <iah> Cale: and yeah, it probably would be saner to just use text, but i thought it would be more natural to write something like 'title "foo"' rather than 'title (text "foo")'
18:59:26 <SamB_XP> back when it was Netsape 4?
18:59:27 <syntaxfree> I remember something like that from his blog-like thing.
18:59:33 <syntaxfree> Anyway, I don't think much of him anymore.
18:59:41 <syntaxfree> As a 14-year-old, he was one of my idols.
19:00:00 * SamB_XP likes the spinning compass thingy
19:00:12 <iah> and it bothers me that I can't figure out how to do that
19:00:17 <syntaxfree> ah, yes.
19:00:23 <syntaxfree> I loved the layout!
19:00:31 <syntaxfree> also the title/subtitle formt.
19:00:41 <syntaxfree> I might unconsciously have used that for my blog for a while.
19:00:48 * SamB_XP is not that old
19:01:38 <SamB_XP> or perhaps simply not that long of a unix user...
19:01:42 <newsham> wasnt jamie at uiuc working on the pre-netscape browser?
19:01:53 <fnord123> in vim you can use gg=G to reab a file
19:01:54 <newsham> before netscape?
19:02:06 <fnord123> retab, pardon
19:02:06 <newsham> man, i cant even remember the name of that browser anymore
19:02:18 <mbishop> Mozaic?
19:02:20 <fnord123> mosaic?
19:02:24 <newsham> yah
19:03:14 <newsham> also why is it suprising that a programmer doesnt have a degree?
19:03:38 <klapmuet1> because nowadays everybody has a degree in baloney
19:04:09 <syntaxfree> dunno.
19:04:13 <newsham> i know lots of people in tech who didnt finish their college degree
19:04:24 <syntaxfree> nowadays, I don't see him as more than just-a-programmer.
19:04:25 * FZ listens to "Baloney Again" -- Mark Knopfler...
19:04:31 <newsham> i can understand why.. why bother with it when there are so many lucrative jobs and good work experience
19:04:50 <klapmuet1> here in germany you basically have to have a degree to even get invited for an interview
19:04:56 <newsham> sf: he runs a good nightclub.. thats gotta be worth something :)
19:05:06 <klapmuet1> except you have some serious work experience... but to get that you need a degree :-P
19:05:48 <newsham> work experience isnt that hard to come by.  also if you're self motivated you can learn the right stuff pretty quickly out of school.
19:06:19 <klapmuet1> well, I took the no-study route as well... but I don't think that's the safest route ;-)
19:06:36 <newsham> ie. friend worked as system and network engineer for small community college, then small local ISP, then bigger local service provider startup, then to the bay area at some serious networking companies
19:06:41 <syntaxfree> newsham: did you go there?
19:06:43 <Cale> iah: hmm, I can't see how to avoid adding explicit type annotations here
19:07:02 <newsham> sf: dnalounge?  yah, i used to go often when i lived in sf.
19:07:19 <newsham> for 1.5 yrs i lived a few blocks away
19:07:26 <Cale> iah: (of course, you can get it to work by using explicit annotations to make the 'r' type known before applying tag "p" to that do-block.
19:07:30 <Cale> )
19:07:42 <syntaxfree> oh. i see.
19:07:55 <Cale> tag "p" $ (text "asdf" :: HTML String ())
19:07:57 <Cale> something like that
19:08:03 <Cale> but that's not so great :)
19:08:06 <iah> Cale: ah, I see
19:08:27 <iah> yeah, I think I'm going to just make functions for each tag that take String or HTML r a depending on which is more natural
19:08:31 * SamB_XP does not want degree in balony
19:08:39 * SamB_XP wants degree in engineering and/or mathematics
19:08:41 <iah> thanks for your help
19:08:48 <Cale> iah: yeah, that's basically what they do in HXT
19:08:53 <newsham> iah: take a look at Text.Html.  it does make lots of small helper functions
19:08:58 <newsham> and a nice operator for nesting
19:09:01 * mbishop wants a degree in the proper use of articles, like 'a'.
19:09:04 <SamB_XP> (it is a good excuse to get an *education*, you know!)
19:09:22 <SamB_XP> mbishop: I already know how to use them
19:09:35 <SamB_XP> that is how I can get away without them, too ;-P
19:10:09 <newsham> so you can do     (header << thetitle << "Title") +++ (body << (h1 "Hello" +++ p << "welcome to my page")
19:10:19 <Cale> iah: also, HXT is pretty good at generating and processing html/xml, but it can be a bit frightening at first. If you just jump in, it's fairly reasonable though :)
19:10:38 <newsham> probably implementing similar helpers in hxt would make using it less tedious
19:11:21 <iah> alright, I'll look at HXT
19:12:05 <Cale> newsham: Well, HTML helpers don't exist, but things which take strings vs. arrow computations do.
19:12:25 <newsham> http://darcs.haskell.org/packages/html/Text/Html.hs
19:12:43 <iah> I've looked at text.html, but it's really ugly! :)
19:13:03 <newsham> it also takes care of automatically converting  between String and Html ...
19:13:12 <newsham> the "<<" operator will do it for you
19:13:28 <iah> oh, that's useful
19:13:32 <newsham> iah: i didnt find it that ugly.
19:14:02 <iah> well, also I can't layer it over the continuation monad like I can WriterT
19:14:48 <Cale> ah, right, it's doing the same trick, but there isn't the same problem with underdetermined types because it doesn't have that reader aspect.
19:17:10 <danjafagw> im really new to haskell, i downloaded ghc, which says its for haskell 98, is there a new version of haskell? i need to elarn haskell for something, and i dont know if haskell 98 is what i need to learn or something else.......
19:17:36 <Cale> danjafagw: Haskell 98 is just the last standard version of Haskell
19:17:46 <Cale> GHC supports lots of features beyond that as well
19:18:08 <Cale> (and there's a committee already working on standardising some of those and producing a new Haskell standard)
19:18:32 <SamB_XP> is it going to be called Haskell ME?
19:19:01 <Cale> I'd vote for Haskell 1.6 to restore the sensible version numbering scheme :)
19:19:14 <SamB_XP> Haskell 2k?
19:19:17 <SamB_XP> Haskell XP?
19:19:22 <Cale> danjafagw: In fact, basically all of the major Haskell implementations support extensions to Haskell 98.
19:19:23 <moconnor> I keep doing odd things to get around the fact that I can't put an if/then/else in a do statement.  Is there a more natural way to include something ile if/then/else in a do expression?  when and unless seem wrong b/c they're always of type m ().  I'm a newbie this question might not make sense.
19:19:24 <SamB_XP> Haskell 2003 Server?
19:19:27 <SamB_XP> Haskell Vista?
19:19:29 <newsham> danja: ghc is a good one to work with
19:19:39 <Cale> moconnor: you can put an if-then-else in a do block
19:19:51 <jcreigh> If it turns out to be Haskell ME, I know I'm going to stick with 98. :)
19:19:59 <Cale> do b <- testIt
19:20:02 <Cale>    if b
19:20:06 <newsham> mo: you can put if/then/else in do blocks!
19:20:07 <SamB_XP> jcreigh: you mean 98 SE, I hope?
19:20:09 <Cale>        then do foo
19:20:13 <Cale>                bar
19:20:19 <jcreigh> SamB_XP: heh, yeah.
19:20:22 <newsham> but each of the clauses must evaluate to actions.
19:20:24 <Cale>        else do quux
19:20:32 <Cale>                quuux
19:20:32 <SamB_XP> yeah, I have that too
19:20:36 <newsham> so if you want to put several actions in a then- or else-close you need to use a nested do-block.
19:20:45 <dylan> in US university lingo, what field of mathematics would I want to major in to more appreciate haskell? :)
19:21:10 <Cale> dylan: computer science? ;)
19:21:23 <newsham> danja: for a fuller explanation see:  http://www.haskell.org/haskellwiki/IOIntro_Actions
19:21:23 <SamB_XP> Mathematics!
19:21:25 <lambdabot> Title: IOIntro Actions - HaskellWiki
19:21:28 <dylan> Pretend my university is a Java School.
19:21:30 * SamB_XP doesn't know, actually
19:21:32 <Cale> dylan: or, well, algebraic combinatorics is good
19:21:48 <SamB_XP> I'm going into Mechanical Engineering, I think...
19:21:48 <danjafagw> sorrry i was afk, ty for the help
19:22:03 <dylan> "Applied Mathematics", "General Mathematics" and a few variants of statistics.
19:22:09 <Cale> and category theory is handy, but you tend to work up to that through lots of other abstract algebra courses
19:22:12 <newsham> s/close/clause/
19:22:16 <Cale> "Pure Mathematics"?
19:22:59 <dylan> Note this is for a AA degree. the BA can be algebraic combinatorics. :)
19:23:28 <Cale> what's AA?
19:23:34 * dylan is finishing a two year degree at a community college so he'll only need two years at the more expensive university before worrying about the masters...
19:23:42 <dylan> an AA is the first half of a BA, basically.
19:23:47 <Cale> My degree was a BMath
19:23:55 <newsham> associates of arts vs. bachelors of arts
19:23:58 <SamB_XP> I thought AA was for substance problems!
19:24:08 <dylan> Associates of Arts :P
19:24:12 <Cale> hmm, never heard of an associates degree before
19:24:13 <newsham> AA can lead to substance problems
19:24:26 <Cale> @wiki Introduction_to_IO
19:24:27 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
19:24:33 <moconnor> I keep getting a syntax error with this if/then/else in a do block, http://rafb.net/p/ljg04l13.html it seems on the surface similar to what Cale pasted in.  It's and indentation error and various permutations fail to work.
19:24:34 * SamB_XP thought they were called Associates, not AA
19:24:42 <SamB_XP> AA stands for Alcoholics Anonymous
19:24:44 <dylan> well, I've been in college since I was 16-17, as it was free.
19:24:44 <Cale> danjafagw: there's my intro too :)
19:24:44 * sorear finds the similarity between moconnor and roconnor interesting
19:25:02 <Cale> moconnor: the 'then' and 'else' are meant to be lined up
19:25:03 <sorear> if-then-else is ONE expression...
19:25:06 <dylan> and I have ... a lot of credit hours there..
19:25:08 <newsham> cale: have you had a chance to review mine, btw?
19:25:11 <syntaxfree> people used to ask if I was SyntaxNinja all the time.
19:25:21 <Cale> newsham: I'll have a look in a moment :)
19:25:22 <syntaxfree> By now it seems I'm the default syntax-person around.
19:25:27 <Cale> moconnor: and indented more than the 'if'
19:25:28 <sorear> moc: if-then-else is NOT special
19:25:44 <Cale> lisppaste2: url
19:25:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
19:26:02 <sorear> moc: since else is at the same level as 'if' it is assumed to begin a new statement
19:26:21 <moconnor> Cale: oh, of course, thank you.  I'd gotten along using one line if/then/elses and so didn't notice that.
19:26:24 <lisppaste2> Cale pasted "if-then-else" at http://paste.lisp.org/display/33462
19:26:27 <moconnor> Cale: thank you.
19:26:30 <moconnor> sorear: thank you too
19:26:34 <Cale> moconnor: no problem
19:26:48 <sorear> oh, btw: you don't need all those do's
19:26:57 <Cale> right
19:27:11 <Cale> you only need 'do' when you're gluing together more than one action in sequence
19:27:13 <newsham> there are several examples of do-blocks with if-then-else in the wiki article i urled
19:27:21 <sorear> do is syntax-sugar for sequencing, so if you only have one action you don't need it
19:27:21 <Cale> do {x} = x
19:27:23 <wolverian> a-ha, now I know why hxt looks so weird. it's left-to-right!
19:27:29 <Cale> wolverian: hehe
19:27:43 <Cale> well, it can be right to left if you prefer
19:27:47 <Cale> use <<< instead
19:28:16 <sorear> also you can use if in expressions, so "main = print (if True then \"hi\" else \"bye\")"
19:28:26 <wolverian> I'll see which one I like more :)
19:28:34 <wolverian> (weird isn't always bad)
19:28:54 <sorear> Of course, the if is redundant because the object is known ahead of time: "main = print \"hi\""
19:29:14 <newsham> if you know c think of "if-then-else" as ..?..:..;
19:29:54 <sorear> print uses the show method on an arbitrary value, but we know the type of "hi" : "main = putStrLn \"\\\"hi\\\"\""
19:30:55 <wolverian> funny, the >>> and <<< operators are very close to perl6's ==> and <00
19:30:59 <wolverian> er, <==
19:31:39 <sorear> moconnor: helped?
19:32:12 <moconnor> sorear: yeah, thanks.
19:33:56 <wolverian> well, I suppose it isn't funny, just natural.
19:36:16 <wolverian> hm. HXT's Setup.lhs tries to write to the system package.conf with a local prefix
19:37:11 * allbery_b is following the "style" question on -cafe with some interest, since hehas a similar situation
19:37:59 <allbery_b> of course mine came from a more or less literal translation of some math-heavy Perl code (translating between epoch time and Julian date)
19:38:27 <wolverian> DateTime::Calendar::Julian? :)
19:39:16 <newsham> Calendar::Mayan?
19:39:50 <allbery_b> well, modified Julian I think.  gacked from a bunch of formulas for figuring sunise/sunset times
19:39:52 <wolverian> DateTime::Calendar::Mayan!
19:39:59 <wolverian> (DT++)
19:40:00 <Khisanth> using the Mayan calendar to get the Julian date doesn't sound particularly appealing
19:40:03 <allbery_b> (which was the actual point)
19:40:32 <danjafagw> im new to haskell, im in windows, someoen told me i should use linux, can i do it in windows? what are the drawbacks, id have to do a dual boot and seriously take a lot of hd space if i wanted to do it in linux
19:40:54 <newsham> windows is fine for haskell programming
19:40:55 <allbery_b> the perl program has been retired in favor of the haskell one, but the haskell one is still pretty ugly
19:40:58 <Khisanth> around 2GB should be enough :)
19:41:08 <wolverian> DateTime::Event::Sunrise :)
19:41:30 <allbery_b> doesn't help any in haskell :)
19:41:59 <allbery_b> and I don't recall why I went with separate equations instead --- I actually had that installed. but unused, I ended up jettisoning it for some reason and writing my own
19:42:05 <allbery_b> oh, wait, I remember
19:42:17 <allbery_b> I needed to be able to calculate sunrise/set +/- some number of degrees
19:42:20 <wolverian> I'm just pointing out that all your work has been done before, and probably better than you did!
19:42:47 <allbery_b> DateTime::Event::SunRise was useless for that, nor can it be translated to an offset in seconds; it has to be calculated
19:42:48 <mgsloan> danjafagw: where linux really shines (or rather, where windows really blows) is C/C++ dev.  It still sucks, but its much better on linux
19:42:58 * sorear exorcizes danjafagw's computer
19:43:40 <newsham> msgloan: imo it only really matters if you're coding near the userland/kernel boundary.
19:43:41 <allbery_b> so I had to implement my own anyway, and having done so there was no point in using the stock one for sunise/.sunset and mine for sunset-8.5degrees
19:43:44 <Khisanth> danjafagw: what are your prefered tools?
19:44:18 <allbery_b> (and, while *that* has been done before, it's all payware)
19:44:27 <wolverian> allbery_b, and you didn't patch DT::E::Sunrise? :)
19:44:27 <mgsloan> newsham - perhaps.  I tried for weeks to actually do real stuff with c/c++ on windows, and got nothing.  Different story on linux
19:44:30 <allbery_b> (or Javascript --- no thank'ee)
19:45:00 <newsham> mgsloan:  what were you doing?  perhaps lack of familiarity with the particular tools and library environment?
19:45:02 <mgsloan> more the tools, the compilers on linux (sure, gcc is cross platform, but no-one really uses it on windows, so it is really rough)
19:45:09 <mgsloan> nah, same tools/libs
19:45:10 <allbery_b> it has no API for it and the existing API for the DateTime modules doesn't allow for it, and changing it seemed rather out of the question
19:45:11 <SamB_XP> I don't know how you do real programming on Windows at *all*
19:45:15 <mgsloan> its just the env, yeah
19:45:34 <allbery_b> (in fact the existing API introduces a bunch of odd limitations and restrictions, seems to me)
19:45:35 <newsham> .. as an example.. if you're writing on top of wxwindows then you pretty much have the same things at your disposal in win32 and unix
19:45:38 <mgsloan> probably one problem was i didn't want to pay for an IDE or a compiler set
19:45:57 <mgsloan> I was trying to do directx and opengl (tried to get both working)
19:45:57 <allbery_b> but changing it requires changing a metric crapload of DateTime::foo modules to match
19:46:02 <newsham> ahh.. using unix tools in windows can be a pain to be sure.
19:46:04 <wolverian> heh, true.
19:46:07 <mgsloan> I also tried to do gui, and that was hell
19:46:17 <allbery_b> and would almost certainly cause much wailing and gnashing of teeth if submitted back
19:46:53 <mgsloan> I'm not sure who created win32, but certainly not rational people
19:47:33 <newsham> a mix of good and bad programmers with time constraints and compatibility constraints
19:47:39 <newsham> and different visions
19:47:40 <mgsloan> I also tried compiling about 5 different 3d engines, and none worked, and the various mailing lists/irc channels couldn't figure out what my problem was
19:47:49 <mgsloan> Actually, irrlicht compiled
19:47:51 <allbery_b> heh
19:48:05 <mgsloan> and i did some stuff with that, but then I found out it was buggy as hell and moved on
19:48:22 <newsham> its harder to get win32 help on irc.  not really sure where is a good place, but it seems win32 types like web based forums
19:48:27 <Khisanth> probably needed the MS compiler
19:48:35 <allbery_b> oddly, I had that problem trying to build 2d graphics libs for linux.  (but on 6.6, which seems to have some compat issues.  did finally get darcs wxhaskell to build after some headbanging over buggy SuSE libs)
19:48:46 <newsham> isnt there a free version of visual studio 2005?
19:48:48 <SamB_XP> for some reason they wanted win16 code to compile to win32 with a minimum of change
19:48:51 <mgsloan> Khisanth - nah, irrlicht is cross platform - it compiles in gcc
19:49:08 <Khisanth> I meant the other ones
19:49:15 <mgsloan> least, when you have a reasonable development environment (linux :) )
19:49:23 <mgsloan> oh, could be
19:49:30 <Khisanth> VCC and gcc seems to want to complain about different things
19:49:39 <newsham> http://msdn.microsoft.com/vstudio/express/  <- free visual studio 2005 edition
19:49:41 <lambdabot> Title: Visual Studio Express
19:49:46 <SamB_XP> even cross-platform things sometimes need MSVC to build on windows...
19:49:47 <mgsloan> SamB_XP - ah, is that why it's insane?
19:49:59 <SamB_XP> mgsloan: not the whole reason, surely
19:50:05 <mgsloan> newsham: isn't that C#?
19:50:16 <SamB_XP> it can't have helped, though
19:50:19 <mgsloan> I know C#, it's a totally different animal than C++
19:50:43 <newsham> looks like c++, c#, j#.  i havent used this edition (I have the "pro")
19:50:55 <mgsloan> That's probably C++.net
19:50:57 <syntaxfree> glowing pigs.
19:51:02 <mgsloan> I had a quite long stint with .net
19:51:03 <syntaxfree> if I may use an expletive, fuck.
19:51:07 <newsham> also i use 2003 (.net) because not all code works with 2005 yet.
19:51:11 <mgsloan> mostly in the Boo language, which is fantastic
19:51:39 <mgsloan> though no VS.net support, which puts off a lot of people
19:51:48 <newsham> some of MS's own sample code doesnt build in 2005 :(
19:52:20 <mgsloan> newsham - .net development is an entirely different experience than C++ on windows.  Its a joy, in fact.
19:52:51 <SamB_XP> mgsloan: I think it supports both native and managed C++
19:52:52 <newsham> you mean CLR stuff?
19:53:16 <mgsloan> newsham: yep
19:53:21 <SamB_XP> but the native stuff maybe has sucky optimization in the express edition
19:53:32 <mgsloan> ah, interesting
19:54:17 <mgsloan> I wish MS could name things properly (.net), (C++.net)
19:54:54 <SamB_XP> someone told me that you could compile even normal C++ to run on .NET, but I don't know how...
19:55:36 <sorear> Step 1: g++.  Step 2: transliterate the instructions to monadic haskell.  Step 3: Yhc.net
19:55:53 <mgsloan> possible, if there's some sort of ASM inlining stuff in IL, which I haven't seen before, but you never know
19:56:03 <newsham> mgs: probably because ".net" was a buzzword that meant about 30 different things depending on who you were talking to and about what.
19:56:18 <newsham> "CLR" is less ambiguous
19:56:22 <SamB_XP> I thought .net meant "cool domain name"
19:56:31 <SamB_XP> or "ISP domain name"
19:56:33 <SamB_XP> alternately
19:56:57 <sorear> SamB: what makes you think $RANDOM_LANGUAGE (C++) cannot be compiled to $RANDOM_VIRTUALLY_TURING_STRONG_PLATFORM(.net)?
19:57:14 <mgsloan> but CLR just means Common Language Runtime, which is even less specific
19:57:19 <SamB_XP> sorear: well, I mean they told me that you could use MS's tools to do it
19:57:20 <sorear> "lack of compiler" is no excuse. :)
19:57:29 <newsham> mgs: uh.. ".net" less specific :)
19:57:38 <mgsloan> true :)
19:58:08 <newsham> bbl.
19:58:14 <mgsloan> same thing with IL/MSIL/CIL - all muddled up
19:58:22 <dfranke> well, for sufficiently permissive definitions of "compile" it obviously can.
19:58:32 <dfranke> but it might be like "compiling" Befunge.
19:59:09 <dfranke> that is, spitting out an interpreter with the program stored as data.
19:59:11 <mgsloan> dunno even about that, it'd be pretty difficult to interpret C++.  I guess you could write a VM and run GCC in it
20:00:44 <mgsloan> even then the VM would have to be pretty feature full, have bindings to every DLL/static lib the C++ uses
20:02:42 <SamB_XP> anyway I dunno if I believe him that it actually works
20:03:11 <mgsloan> yeah, its probably just confusing C++ and C++.net
20:03:15 <SamB_XP> I doubt he's actually tried using the binaries from such a compilation on another OS...
20:03:23 <SamB_XP> oh, no that mistake is not one this guy would make
20:04:03 <mgsloan> I suppose they could be doing some AOP stuff - compiling write to real binary
20:04:29 <mgsloan> s/write/right
20:10:10 <nmessenger> random pondering: would it be desirable to have the compiler somehow reject non-minimally-complete class instances at compile-time?
20:10:42 <mgsloan> it doesn't already?
20:11:22 <nmessenger> data T = T; instance Eq T where {}; main = return (T == T); -- stack overflow
20:11:35 <mgsloan> allowing partial defs would be dangerous
20:11:48 <sorear> nmess: it already does that
20:12:10 <mgsloan> nmessenger: which compiler?
20:12:22 <nmessenger> plain-jane GHC 6.6
20:12:23 <sorear> -fwarn-missing-methods
20:12:45 <mgsloan> you need a parameter? that should be default!
20:13:07 <mgsloan> unless I'm missing some utility of having incomplete class instances
20:13:21 <nmessenger> Eq's (==) is defined, generically, in terms of (/=), and (/=) of (==), so the compiler can't tell that an instance must implement one or the other
20:13:24 <sorear> This option is on by default
20:13:34 <sorear> ^^^ wrt the flag
20:13:35 <mgsloan> oh, good
20:14:06 <mgsloan> nmessenger - ah, interesting.  Perhaps its a bug
20:14:38 <sorear> Its not a bug
20:14:44 <mgsloan> yeah, i just got it
20:14:47 <nmessenger> I wouldn't know how to fix this "bug" unless new syntax were introduced that specifies min comp defs
20:15:08 <mgsloan> right... an annotation that specifies at least one must be defined.
20:15:39 <sorear> besides, it's in the Revised Report
20:15:49 <nmessenger> would some kind of annotation syntax be good for Haskell'?
20:15:52 <mgsloan> haskell'? good.
20:15:59 <sorear> class Eq where ... x == y = not (x /= y) ; x /= y = not (x == y)
20:16:23 <mgsloan> nmessenger: I don't really know - haskell is clean enough to not use it.  perhaps forall qualifies
20:16:29 <LordBrain> its a default... you get to choose which to implement, or both if you prefer
20:17:05 <mgsloan> Boo (.net lang) uses stuff like [Serializeable][Singleton] class foo:
20:17:16 <nmessenger> LordBrain: yeah, but if neither is implemented a stack overflow results.  I was thinking it would be good to tell the compiler about such things.
20:17:32 <LordBrain> oh yes
20:17:36 <mgsloan> I think in general special case warnings would be useful
20:18:02 <mgsloan> the compiler could no specifically about this Eq quirk.  Sure, someone could have a user class, but eh, its not that huge of an issue.
20:18:04 <LordBrain> i didnt know the instance statement would work  if it didnt include a definition in the where clause...
20:18:12 <mgsloan> s/no/know
20:18:21 <mgsloan> huh, I'm thinking phonetically tonight
20:18:34 <sorear> it's documented
20:18:49 <sorear> (doesn't make it right)
20:18:49 <mgsloan> perhaps the compiler could warn for empty instances
20:18:53 <nmessenger> Minimally complete definition are usually in the Haddocks just for this reason.  Compile-time error-catching *is* a mantra of Haskell, no?
20:19:18 <LordBrain> yeah
20:19:21 <LordBrain> seems to be
20:19:48 <sorear> nmess: Haskell does *not* do any kind of termination analysis, and your problem is a nonterm bug.
20:19:57 <nmessenger> I dunno, I just wanted to make an observation because it seemed interesting to me.
20:20:25 <sorear> I suspect a strongly normalizing language like Epigram would stop you from doing that.
20:20:27 <mgsloan> yeah, it is interesting.
20:21:12 <mgsloan> well, a bit of nonterm analysis wouldn't hurt
20:21:23 <sorear> but Haskell as a deliberate design decision does not taint general recursion or sequencign
20:21:31 <LordBrain> what we really want to say is use /= if it's definition is not the default...
20:22:05 <sorear> (1) annotate classes with a set of DEFAULT-X-uses-Y tags.
20:22:26 <SamB_XP> I was thinking more like a minimal-complete-definition microlanguage
20:22:30 <sorear> (2) on a user defined instance, remove tags whose lhs's are defined methods
20:22:51 <sorear> (3) the instance is incomplete iff the remaining graph is cyclic
20:23:34 <sorear> (iff is not a typo here)
20:23:40 <nmessenger> data MinCompDef = OneOf [MinCompDef] | AllOf [MinCompDef] | Method String
20:23:45 <mgsloan> iff the remaining graph is cyclic or functions are left undefined (gotta be careful with those iffs)
20:24:16 <sorear> oh yea I forgot about methods with no default at all
20:24:21 <SamB_XP> heh
20:24:32 <nmessenger> then values of MinCompDef in special syntax comments
20:24:42 <SamB_XP> pragmas, they are called
20:25:02 <SamB_XP> {-# MINCOMPDEF [blah] #-}
20:25:03 <sorear> | (==) -> (/=) , (/=) -> (==)
20:25:21 <nmessenger> well golly-gee, pragmas'd be swell!
20:25:23 <LordBrain> hmmm
20:25:51 <mgsloan> I think a haskell dialect could do interesting things if compilation was a monad.
20:26:13 <LordBrain> hmmm
20:26:32 <LordBrain> what does it mean for compilation to be a monad?
20:27:00 <sorear> Ord:  compare <- (<=)  (<=) (<) (>) (>=) min max <- compare
20:27:03 <SamB_XP> it means you have a crappy compiler that uses only one compilation monad?
20:27:07 <sorear> Ord:  compare <- (<=) , (<=) (<) (>) (>=) min max <- compare
20:27:10 <mgsloan> basically, declerations are statements in that monad
20:27:29 <mgsloan> i'm not really very monad-fu as far as terminology goes
20:28:08 <sorear> Enum: succ pred enumFrom enumFromTo enumFromThen enumFromThenTo <- fromEnum toEnum
20:28:47 <sorear> Num: (-) <- negate , negate <- (-)
20:28:48 <mgsloan> For classes you could have a function 'implement :: Comp [Func] -> Comp [Func]' which takes instance functions, optionally messes with and analyzes them, and adds defaults
20:29:01 <mgsloan> compile-time executed function
20:29:12 <mgsloan> then again, whole programs would be compile-time executed functions...
20:29:36 <nmessenger> Macros!
20:30:02 <sorear> Integral: quot rem divMod <- quotRem , div mod <- divMod
20:30:05 <nmessenger> (well, sorta)
20:30:46 <mgsloan> this is actually sort of how my graphical lang will do things on the low basis.  I think it is more 'pure' than haskell's approach.
20:30:55 <mgsloan> yeah, macros would be a result of this approach
20:31:02 <LordBrain> i see
20:31:07 <sorear> Floating: (**) <- exp log (*) , logBase <- log (/) , sqrt <- (**) , tan <- sin cos , tanh <- sinh cosh
20:31:14 <nmessenger> well, it's not more pure than much if it ain't written yet ;P
20:31:22 <mgsloan> heh, true
20:31:37 <sorear> RealFrac: truncate round ceiling floor <- properFraction
20:32:09 <SamB_XP> it is pure hot air, though!
20:32:41 <LordBrain> anyone do a lot of translating of say perl into haskell? I imagine a sort of helper library would be invented over time..
20:32:52 <mgsloan> SamB_XP: what, my compilation monad idea?
20:33:02 <mgsloan> Perhaps its not a monad, i don't really care
20:33:44 <sorear> RealFloat: exponent <- floatDigits decodeFloat , significand <- floatDigits encodeFloat decodeFloat , scaleFloat <- encodeFloat decodeFloat , atan2 <- isNegativeZero
20:35:29 <sorear> Read: readList <- readsPrec
20:36:32 <sorear> Show: show <- showsPrec , showsPrec <- show , showList <- showsPrec
20:36:41 <sorear> Show: show showList <- showsPrec , showsPrec <- show
20:37:17 <sorear> Monad: (>>) <- (>>=) , fail <-
20:37:41 <nmessenger> sorear: still looking for methods defined mutually recursively?
20:38:04 <shapr> d00d
20:38:13 <nmessenger> dewd
20:38:53 <mgsloan> ?elite dood
20:38:53 <lambdabot> DooD
20:39:01 <nmessenger> dude, even
20:39:08 <mgsloan> ?elite dood
20:39:08 <lambdabot> d0Od
20:39:21 <mgsloan> I wonder if it ever uses c|ooc|
20:39:27 <mgsloan> maybe too hard to read
20:39:28 <sorear> I think my method will work because it seems like it can be automatically generated from strictness analysis.
20:39:49 <sorear> e.g a == b  strictly evaluates a /= b
20:39:50 <Modius> Anyone here ever played around with QI (lisp library)?  It seems to be a knockoff of haskell (well, at my limited level I see similarities).
20:41:32 <nmessenger> I've not, sorry.  Unless by 'played with' you mean 'downloaded once but never touched'.
20:44:41 <LordBrain> i've read of qi a little
20:44:49 <LordBrain> it's type system is turing complete
20:44:58 <LordBrain> is that true of haskell too?
20:45:05 <LordBrain> i havent thought of it
20:45:37 <nmessenger> LordBrain: I'm pretty sure Turing-Completeness implies not guaranteed to terminate, which is a property of Haskell types
20:45:48 <LordBrain> yeah
20:45:52 <Modius> What does it mean types terminating?
20:45:58 <LordBrain> is that a two way implication?
20:46:27 <nmessenger> Modius: for instance, you've probably read the error message "cannot unify infinite type" by now?
20:46:41 <Modius> Sadly, not yet - what's an infinite type?
20:47:00 <Modius> If you give me a line that will trigger this error I can go off and play with it/figure out why it failed.
20:47:01 <SamB_XP> > iterate head
20:47:02 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
20:47:02 <lambdabot>    Expected...
20:47:31 <nmessenger> you can't have a list of lists of lists of lists of lists of... (a's)
20:48:06 <iah> LordBrain: I can define a language that, for all strings of text, compiles to a simple infinite loop
20:48:11 <Modius> Aah - you can apply haskell functions to functions themselves
20:48:14 <sorear> no, a buggy typechecker can nonterminate without defining a TC type language
20:48:17 <iah> this is not guaranteed to terminate, but isn't turing complete
20:48:22 * sorear has seen it happen
20:48:23 <Modius> This is one of the higher concepts I hoped to pick up through learning the language.
20:48:46 <Modius> I get it - the definition of types is ultimately closed in haskell in that the compiler can see this coming
20:49:24 <Modius> Whereas (as I am getting it) QI allows executing language to be applied to the types, such that, like a macro definition, the execution at compile time has a chance of going on forever in an undetectable manner.
20:49:41 <LordBrain> i thought it meant that you could start compiling and never finish as the static typing ammounts to a non-terminating program running at compile time.
20:49:56 <SamB_XP> LordBrain: I think Modius just said that?
20:50:02 <sorear> It is possible to add infinite types to a unification system while keeping a termination guarantee.
20:50:36 <LordBrain> oh well, what i said is different than getting an error message...
20:50:42 <sorear> echo '\a -> a a' | ./unifier ==> fix a. a -> b
20:50:53 <Modius> Man am I learning a lot today.
20:51:07 <mgsloan> iterate head could be handy if it halted as soon as an error occured
20:51:12 <mgsloan> ?type iterate
20:51:14 <lambdabot> forall a. (a -> a) -> a -> [a]
20:51:20 <mgsloan> that's what i thought
20:51:54 <mgsloan> would really mess with type inference if this worked though
20:52:11 <sorear> oh, type inference still works
20:52:13 <mgsloan> you'd need some sort of wierd type for any depth nesting of list
20:52:22 <nmessenger> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
20:52:27 <lambdabot> Title: 12.2. Known bugs or infelicities, http://tinyurl.com/yf3ln5
20:52:37 <mgsloan> sorear - yeah, but that's epigram ;)
20:52:38 <sorear> infact, with infinite function types, type checking ALWAYS works.
20:52:39 <nmessenger> quote: "GHC's inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:"
20:52:55 <Modius> these are concepts above and beyond what most people I've ever worked with have explored - I've worked in the C-type languages for 10 years - and I didn't grok to scheme in school.  What are the age ranges of people when they embrace this type of programming?
20:53:03 <sorear> No, I'm talking about  my own infinite type unifier.
20:53:04 <sorear> 16
20:53:05 <Modius> Is this something you have to start inin ones career or what?
20:53:13 <sorear> 15
20:53:13 <mgsloan> all over the place
20:53:22 <mgsloan> alot of it is college people
20:55:15 <mgsloan> it's a rare job requirement though, so outside of academics it's usually curiosity, learning a new thing, seeking the ideal language, expanding your mind, etc
20:55:24 <Modius> One can start to embrace functional/stateless even in C++/C# (been doing it for many years to the limits of the language) - I've found it hard to drag people even there, let alone into this world.
20:55:58 <Modius> I've found, to the degree I've been able to do it (stateless) that as I approach functional a lot of development problems disappear
20:56:04 <sorear> 06.10.29 17:47:44 PDylan *78 year old.
20:56:40 <pstickne> I can't quite make it over the hill :-/
20:56:59 <mgsloan> one problem with functional in conventional languages is that it's slower, which is probably one reason people don't like it
20:57:13 <pstickne> I grok many functional programming (let's say semi-functional?) concepts in elisp and Ruby but ... haskell makes my head hurt.
20:57:21 <dobblego> Modius, many people observe that
20:57:26 <Modius> Agreed (functional in normal languages = rebuilding objects a lot) - but I've not found a lot of places in business software where this matters.
20:57:29 <mgsloan> well, functional in general is a bit slower, but a real functional compiler can optimize
20:57:42 <mgsloan> yeah, for biz software it's a good idea
20:57:43 <mwc> Modius, had my first brush with Scheme at 16 and hated it, Found Haskell at 20 and loved it
20:57:45 <nmessenger> pstickne: that means you're learning ;P
20:58:14 <mgsloan> Lisp was actually meant to have a syntax, but they never got around to it :)
20:58:19 <sorear> well, functional in general is a bit slower, but a real functional programmer doesn't care
20:58:19 <Modius> That's what I was thinking (Before hearing about haskell) - with a guarantee of no side-effect, an optimizer "could" know everything about the program section in question.  And could deal with thread/distributed computing issues.
20:58:43 <ClaudiusMaximus> with MissingH-0.14.4/ghc-6.4.2, which module should i import to get openBinaryFile?
20:58:51 <LordBrain> my first functional language was ocaml
20:58:52 <Modius> I'm currently mostly in lisp - the transition was easier as I was doing C# functional (I wrote equivalents of map, fold, filter, etc. .  .)
20:59:03 <pstickne> C# ... uhg.
20:59:06 <Modius> But lisp still gives you the "backdoor" of sideeffect and state.
20:59:18 <dobblego> at least, there is compiler optimisation for the recursion in C#
20:59:24 <dobblego> Modius, take a look at F#
20:59:25 <pstickne> In fact, boo to all those languages with a `C-based' syntax.
20:59:35 <mgsloan> yeah, I'm sure if the effort that is put into C optimizers was put into a functional compiler it could do wonders
20:59:35 <mwc> I met Ocaml when I was 18 or so. I saw a bit of potential but found it to be a pain in the ass
20:59:45 <Modius> Haskell would seem optimal for teaching stateless/functional as there is no "well, just this once I can do sideeffect"
20:59:47 <LordBrain> i didnt stay with it long... its type system impressed me as nifty but not very practical at all
20:59:58 <mwc> Modius, well, there's the ST monad
21:00:20 <mgsloan> C# is ok.  You can mostly ignore the syntax.  I like boo, which is basically the same as C#, only with a python inspiration for syntax.
21:00:23 <Modius> But monads force state/sideeffect to be segregated from functional code, right?  That's the main thing.
21:00:35 <LordBrain> then i switched to scheme, which i liked pretty much, but i missed a little bit having a staticly typed language
21:00:37 <nmessenger> pstickne: meh, they're unpopular among the cool kids, but if it pays one's bills, I'm not one to denigrate others for it.
21:00:40 <Modius> A little birdie told me that C# at Microsoft is staffed up with Haskell guys.
21:00:48 <dfranke> OCaml's lack of type classes sucks.
21:00:52 * sorear whispers deadly secrets about hafnsrCresbezVB
21:00:55 <dobblego> Modius, monads are not side-effecting
21:00:57 <LordBrain> like c++.. well i didnt miss the static typing, i just missed the error checking
21:01:14 <pstickne> nmessenger, they are just such a pita to go back too. I'm like, wtf, I can't use this as a value!?!?
21:01:36 <LordBrain> which was lousy in the particular schemes i was using... and is poorer in scheme in general due to the ability to pass undefined symbols around...
21:01:40 <mgsloan> Modius - possible.  2.0/3.0 features certainly seem to have a functional inspiration
21:01:43 <pstickne> What _are_ monads then?
21:01:46 <dfranke> When I'm working with bignums and the typechecker knows that everything is a bignum, why can't I just use normal infix arithmetic operators?
21:01:51 <LordBrain> haskell has excellent error checking.
21:01:57 <dobblego> nothing complicated
21:01:59 <nmessenger> INCOMING MONAD EXPLANATION FLOOD!
21:02:01 <Modius> Before generics/templates and closure delegates I found C# (1.0) intolerable
21:02:06 <sorear> hafnsrCresbezVB should be called that.
21:02:15 <mgsloan> Modius - IO is a monad, but that's not the explicit goal of monads
21:02:19 <mwc> pstickne, Parsec is a good examble of a non-side-effect encapsulating monad
21:02:24 <mwc> or good old [a] even
21:02:39 <mr_tenor> mgsoan: the trouble is too many features, not too few. eg. C++ - any incoming C++ code could contain a zillion sorts of things
21:02:51 <mwc> > [3,2,5] >>= \x -> [x,x+1]
21:02:52 <lambdabot>  [3,4,2,3,5,6]
21:03:08 <nmessenger> ooh, sexy!
21:03:17 <sorear> ?t (>=>)
21:03:17 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:03:21 <sorear> ?typ (>.>)
21:03:22 <lambdabot> Not in scope: `>.>'
21:03:24 <sorear> ?typ (>=>)
21:03:25 <lambdabot> Not in scope: `>=>'
21:03:29 <sorear> ?typ (L.>=>)
21:03:30 <lambdabot> Couldn't find qualified module.
21:03:42 <mwc> @hoogle >=>
21:03:43 <lambdabot> No matches found
21:03:48 <mgsloan> mr_tenor - I agree.  This is why language designers need to be careful when they design a language :)
21:03:53 <mwc> sorear, what're you looking for?
21:03:53 <nmessenger> so [a]'s (>>=) is something like concatMap?
21:04:06 <mwc> nmessenger, actually, it's exactly that
21:04:08 <allbery_b> it *is*concatMap
21:04:11 <pstickne> looks just like #map :)
21:04:43 <mr_tenor> mgsloan: totally. that's why i'm not looking at c# or java atm. they seem to be bolting on random stuff all the time. i'll probably need to eventually, or work :/
21:04:44 <pstickne> [3,2,5] is this a monad?
21:04:56 <nmessenger> ?instances Monads
21:04:56 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:04:57 <nmessenger> ?instances Monad
21:04:58 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:05:07 <nmessenger> that last thing, []
21:05:23 <sorear> > let (a >=> b) c = a c >>= b ; x y = [y, y+1] in map length $ group $ sort $ foldr (>=>) return (replicate 10 x) [-5]
21:05:24 <lambdabot>  add an instance declaration for (Num [a])
21:05:30 <mwc> pstickne, folks sometimes get uppity and call it the nondeterminism monad
21:06:01 <sorear> > let (a >=> b) c = a c >>= b ; x y = [y, y+1] in map length $ group $ sort $ foldr1 (>=>) (replicate 10 x) [-5]
21:06:01 <lambdabot>  add an instance declaration for (Num [a])
21:06:17 <sorear> > let (a >=> b) c = a c >>= b ; x y = [y, y+1] in map length $ group $ sort $ foldr1 (>=>) (replicate 10 x) (-5)
21:06:17 <pstickne> So a monad is something which may be different at different times?
21:06:19 <lambdabot>  [1,10,45,120,210,252,210,120,45,10,1]
21:06:24 <sorear> no
21:06:35 <dobblego> ?type (>>=)
21:06:35 <mgsloan> mr_tenor: yep, it's good that most of it is pretty learnable though.  From my perspective once you know haskell, everything else is easy (if painful).  Perhaps this is just a distortion, since I've gone through most paradigms in reaching haskell
21:06:36 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
21:06:46 <dobblego> understand that and you understand 95% of what a monad is
21:07:02 <sorear> A Monad is an algebraic structure, just like a group.  Do you understand groups?
21:07:04 <nmessenger> For me, the breakthrough was not that [], Maybe, IO, etc are by themselves Monads, but that the interesting Monady stuff is in the definition of (>>=)
21:07:28 <pstickne> sorear, likely not in the sense you speak of :(
21:08:03 <sorear> mwc : Kliesi composition operator, I thought it had been defined in L
21:08:41 <nmessenger> indeed, if you ignore the Monady bit, (IO a) is just a function from a RealWorld to a (a, RealWorld) pair
21:09:04 <mr_tenor> mgsloan: it's just a complete waste of time and brain space, though :( especially all the peculiarities of C++ (in my case) when much better languages (eg. haskell, python) exist. damn real world and their suboptimal languages
21:09:22 <mgsloan> ah, yeah, C++ is really bad
21:09:32 <nmessenger> i.e., it might change the state of the RealWorld, while producing a value of type a
21:09:46 <mgsloan> I mostly ignore the real details of that though, and just carry a sort of functioning subset of it
21:09:53 <mr_tenor> C++... it's just full of... stuff, which is only necessary because the language sucks.
21:09:54 <mwc> In the foreward to The C++ Programming Language, Stroustrup observed that inside C++ there's a much simpler and cleaner language struggling to get out
21:10:13 <SamB_XP> mwc: has anyone found it yet?
21:10:13 <mr_tenor> but you can't ignore _any_ of it, because someone is going to give you c++ code using any particular feature
21:10:27 <mgsloan> ah, well, I mostly write it
21:10:37 <pstickne> but they -could- have fixed the cycle in C#, etc O.o
21:10:52 <mgsloan> collaboratively with people that have good style and don't just use features because they're there
21:11:03 <mgsloan> though one of them is a bit of a template junky
21:11:14 <mwc> SamB, no, but I recall somebody else observing that C++ is what you get by trying to make an octopus by nailing 4 extra legs onto a dog
21:11:25 <mr_tenor> languages need to go through some cycles where large swathes of features getcarved off til you can prove something useful about the language :)
21:11:31 <mgsloan> perhaps its because most of them know haskell :)
21:11:55 <SamB_XP> mwc: oh, I thought it was a horse, not a dog
21:12:05 <mr_tenor> samB_XP: then you glue the horse to the dog
21:12:08 <LordBrain> hmmm i think scheme is more minimalist than haskell
21:12:28 <SamB_XP> LordBrain: the lack of syntax is deceptive, I think
21:12:35 <LordBrain> deceptive?
21:12:36 <mr_tenor> but it has state and stuff :(
21:12:38 <mgsloan> that would be nice.  programmers seem to to back compatibility
21:12:43 <LordBrain> how so SamB ?
21:12:48 <allbery_b> you don't need to carve anythoing off C++ to prove it's an ugly mess :)
21:12:53 <SamB_XP> LordBrain: makes the language look minimalist
21:12:56 <mwc> Damian Conway did a nice job designing a much simpler and orthogonal C++ syntax that does a nice job of differentiating the subtle features of C++, SPECS it's called
21:12:59 <LordBrain> oh
21:13:09 <LordBrain> you dont think Scheme is minimalist?
21:13:25 <SamB_XP> well, not as much as it looks on the surface
21:13:26 <nmessenger> SamB: minimallist as in "percieved as not useful"?
21:13:29 <mwc> Well, doesn't Scheme have macros and stuff?
21:13:31 <sorear> It would have been funnier if the legs were nailed onto a camel.
21:13:34 <pstickne> mwc, and nowhere is it used? O.o :)
21:13:41 <LordBrain> scheme has macros yes
21:13:43 <mwc> pstickne, what's used where?
21:14:10 <mgsloan> well, I'd say ghc's internal kernel lang stuff is more minimalist
21:14:19 <LordBrain> it has nice macros.. "hygenic"
21:14:30 <pstickne> mwc, SPECS? :)
21:14:32 <mwc> LordBrain, so basically Scheme Macros are similar to Template Haskell at some level
21:14:53 <LordBrain> it also has the conventional lisp style macros
21:15:04 <mwc> pstickne, I don't believe so. I hope the next guy who decides to make the next Java/C#/D will read it and break the cycle of syntactic rot
21:15:45 <mgsloan> ugg yeah
21:15:46 <pstickne> mwc, not likely. that's what ant-farm corporations want.
21:15:57 <mgsloan> stop throwing away whitespace - its part of the code!
21:16:18 <pstickne> hmm?
21:16:29 <mgsloan> not that pythonic is ideal, but at least no mandatory semicolons
21:16:49 <pstickne> I like rubys syntax over python
21:16:59 <Cale> @wiki Monads_as_Containers
21:16:59 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
21:17:02 <pstickne> no mandatory semi-colons but not forced indenting
21:17:12 <Cale> There's my explanation of monads
21:17:14 <mgsloan> I hate how when people make their own language they basically make a subset of their favorite language
21:17:15 <mwc> Haskell's layout beats python's system hands down
21:17:17 <pstickne> Cale, thanks
21:17:43 <mwc> mgsloan, I'd hope to hell that wasn't the logic that went into Unlambda
21:17:47 <pstickne> mgsloan, and I really hate when it's so awful and becomes so popular (PHP anyone?...)
21:18:00 <mwc> Lol, didn't PHP start out as a bunch of perl scripts?
21:18:03 <SamB_XP> mwc: unlambda is an esoteric language
21:18:06 <mgsloan> pstickne: ugg, yeah.  proves that quality isn't what count
21:18:14 <SamB_XP> as such, it has esoteric goals and origins ;-)
21:18:31 <mwc> SamB_XP, I was going for some humor there.
21:18:41 <mgsloan> mwc - well, its just a thing i see happen alot with people and their pet languages.
21:18:55 <SamB_XP> also, I don't know of any other language that uses ` for application...
21:19:10 <Cale> pstickne: that covers one way of looking at what monads are about
21:20:00 <Cale> pstickne: because they're an abstraction, there's a number of different ways you can think of them in your head. I think the container way is probably the easiest to start with.
21:20:14 <nmessenger> screw unlambda, Lazy K FTW!
21:20:26 <SamB_XP> Lazy K huh.
21:20:28 <pstickne> I'm liking the start of this so far. It's really uhh, dumbed-down :)
21:20:50 <nmessenger> ?go Lazy K programming language
21:20:54 <lambdabot> http://www.cwi.nl/~tromp/cl/lazy-k.html
21:20:54 <lambdabot> Title: The Lazy K Programming Language
21:21:00 <Cale> pstickne: hehe, it's how I explained monads to 11 year old kids :)
21:21:05 <sorear> ?goo "writing monad tutorials" "cottage industry"
21:21:06 <lambdabot> No Result Found.
21:21:10 <sorear> ?goo "writing monad" "cottage industry"
21:21:12 <lambdabot> No Result Found.
21:21:12 <SamB_XP> I know for a fact my head hurts too much to read about Lazy K
21:21:19 <sorear> ?goo "writing monad" "cottage"
21:21:20 <lambdabot> No Result Found.
21:21:25 <sorear> ?goo writing monad cottage
21:21:31 <SamB_XP> especially given that I already know basically what Lazy K is
21:21:34 <mgsloan> I don't actually know what haskell's layout rule is.  The stuff i've seen about it has been very unclear.  I just stick to the coding style most people seem to use, and that works :)
21:21:37 <lambdabot> http://comonad.com/reader/feed/
21:21:51 <LordBrain> if reading technical stuff hurts your head, then you have a bad habit of tensing while thinking
21:21:57 <SamB_XP> mgsloan: you could, uh, read that section on the report
21:21:59 <sorear> ?goo writing monad cottage tutorials industry
21:22:01 <lambdabot> http://www.tutorials-blog.com/functional/functional-22.html
21:22:02 <lambdabot> Title: tutorials-blog.com >> functional 22 Re: rec keyword in OCaml
21:22:03 <mwc> Cale, I bet you didn't called called back to their 12'th birthday party :)
21:22:06 <SamB_XP> LordBrain: no, I already have a headache
21:22:10 <LordBrain> oh
21:22:11 <mgsloan> SamB_XP: I think that's the section I read :)
21:22:14 <Cale> mwc: hehe
21:22:16 <SamB_XP> reading about Lazy K would aggrevate it
21:22:22 <SamB_XP> mgsloan: that was very precise
21:22:39 <SamB_XP> maybe you read the wrong section?
21:22:39 <sorear> Someday I'll extend Lazy K with infinite types
21:22:55 <nmessenger> sorear: but isn't Lazy K untyped?
21:23:11 <LordBrain> SamB: check the brightness/contrast on your monitor, make sure its sane
21:23:38 <SamB_XP> LordBrain: I think it is not from the computer
21:23:40 <LordBrain> shouldnt really be above 75 i dont think...
21:23:48 <SamB_XP> I think maybe I should have got a humidifier running
21:23:48 <LordBrain> oh well
21:23:52 <mgsloan> SamB_XP: I don't think precision is really what I need.  Details muddle the overall idea
21:24:01 <SamB_XP> mgsloan: oh.
21:24:04 <mgsloan> Not that i've devoted time to it or anything
21:24:12 <nmessenger> sorear: since the only operations are S, K, and I, there simply *are* no malformed statements.
21:24:19 <mgsloan> I just realized it was a gap in my knowledge
21:24:45 <sorear> ... what happens when you apply INCREMENT to a function, or use a number as a function
21:24:45 <sorear> ?
21:25:11 <goltrpoat> bit more haskell goodness:  http://vandreev.wordpress.com/2006/12/24/quick-and-dirty-theorem-prover/ case anyone cares
21:25:15 <lambdabot> Title: Quick and Dirty Theorem Prover. « codeland, http://tinyurl.com/y5keq2
21:25:19 <mwc> sorear, zombie Church comes to smite you
21:25:22 <SamB_XP> well, basically, at a point where you can begin to use layout, if the next token is not {, then you must line things up vertically with it
21:25:47 <allbery_b> don't you just apply the function to itself in that case? :)
21:25:52 <nmessenger> Lazy K uses Church numbers
21:25:54 <allbery_b> f + 1 == (f . f)
21:26:07 <mgsloan> ah. what if you accidentally mix tabs and spaces?
21:26:24 <mwc> mgsloan, officially, a tab is eight spaces
21:26:33 <goltrpoat> officially?
21:26:34 <sorear> nmess: read the source! there ARE machine numbers in lazy K, output is implemented by churchnum (+1) 0
21:26:38 <mgsloan> ouch
21:26:41 <mwc> goltrpoat, I believe that's the text of the stadnard
21:26:43 <SamB_XP> goltrpoat: some idiots reconfigure editors
21:26:55 <SamB_XP> mwc: standard?
21:26:59 <mgsloan> i think gedit defaults to 4...
21:27:00 <SamB_XP> I thought that was ASCII standard
21:27:04 <mgsloan> or maybe i reconfigured it :)
21:27:06 <sorear> Why do we pander to these idiots?
21:27:12 <SamB_XP> sorear: we don't
21:27:19 <SamB_XP> that was Python
21:27:26 <SamB_XP> they smartened up since
21:27:37 <mwc> saccade, the Haskell Standard
21:27:43 <mwc> er, that's to SamB_XP
21:28:06 <SamB_XP> anyway, don't use tabs on purpose
21:28:07 <mgsloan> maybe if it was ascii standard there'd be less controversy about it
21:28:08 <Cale> I think tab characters in input files should be lexical errors.
21:28:23 <Cale> It would prevent a lot of pain.
21:28:26 <SamB_XP> and keep your editors set at 8-space tabs
21:28:27 <mgsloan> SamB_XP - yeah, I know.  It happens though
21:28:41 <SamB_XP> and *don't have the tab key insert a tab*
21:28:45 <sorear> Tabs are 8 spaces.  Tabs have always been 8 spaces.  Tabs always will be 8 spaces.  Those who would utter such blasphemy as ':set ts=4' or 'setq tab-length 4' deserve to burn in the unforgiving fires of incompatibility...
21:29:10 <Cale> I tend to configure my tab key to generate 4 spaces.
21:29:12 <mr_tenor> Cale: great idea :)
21:29:21 <mr_tenor> about the banning of tabs :P
21:29:23 <Cale> yeah
21:29:40 <SamB_XP> sorear: well, you must admit that individuals who have formerly programmed in 2d-challanged languages may not be sensitive to the fact that in some languages it matters!
21:29:44 <mwc> sorear, what about tabstop=4 expandtab
21:29:45 <Cale> We should at least have -fwarn-tabs
21:29:49 <mgsloan> yeah, my editor converts tab presses to 4 spaces
21:29:51 <nmessenger> I think a good compromise would be to allow "\n\t" and "\t\t"; any other '\t' would be a lexical error.
21:30:04 <sorear> mwc: :help 'sts
21:30:14 <SamB_XP> they should be given one chance to reconfigure their editors when they encounter one
21:30:25 <Cale> Tabs in comments are fine, I suppose.
21:30:32 <mwc> i'm happy with the convention that a tab is eight spaces.
21:30:33 <SamB_XP> Cale: ick no
21:30:39 <mr_tenor> nmessenger: the point is to prevent confusion, not to change the class of things causing confusion, surely
21:30:41 <nmessenger> i.e. tabs cannot be preceeded anything but other tabs
21:30:48 <Cale> Any character should be allowed in comments
21:30:54 <sorear> PEP 666, everyone.
21:30:55 <SamB_XP> oh, well, true
21:30:56 <pstickne> what is a good book on learning haskell/functional programming? I need something I can sit down with for hours.
21:31:00 <SamB_XP> sorear: heh
21:31:07 <SamB_XP> PEP of the beast?
21:31:15 * SamB_XP wonders if he's read it without noticing that
21:31:19 <sorear> http://www.python.org/dev/peps/pep-0666/
21:31:21 <lambdabot> Title: PEP 666 -- Reject Foolish Indentation
21:31:30 <SamB_XP> I likely have
21:31:40 <nmessenger> "Foolish"?  Heh, dramatic much?
21:31:46 <SamB_XP> heh
21:32:04 <Cale> pstickne: Well, I'm writing one, but it's not ready. YAHT is decent.
21:32:25 <pstickne> I can get to about chapter 6 in YAHT.
21:32:48 <allbery_b> mwc: use shiftwidth instead of tabstop
21:32:57 <allbery_b> and ^T instead of <tab>
21:33:05 <mgsloan> the haskell report, in the layout section, starts a paragraph with "Informally stated,...".  This paragraph makes up the core of this section, and happens to also be very long winded (talking very precisely about lexemes and rules etc).
21:33:09 <allbery_b> as a boonus you get ^D to *out*dent
21:33:15 <mwc> aleator_, in fact, I use both
21:33:25 <SamB_XP> mgsloan: hmm.
21:33:25 <mwc> in combination with expandtab
21:33:30 <goltrpoat> i think it's reasonable to specify a minimum number of spaces for tabs
21:33:32 <SamB_XP> didn't they also have some Haskell code?
21:33:39 <mgsloan> Nothing really states it in a very friendly way for non-implementors
21:33:46 <sorear> goltrpoat: http://www.haskell.org/haskellwiki/Short_theorem_prover
21:33:46 <SamB_XP> true
21:33:47 <lambdabot> Title: Short theorem prover - HaskellWiki
21:33:48 <goltrpoat> specifying an exact number of spaces, like 8, 4, 15, 3, 86, 7, etc, is borderline idiotic.
21:33:58 <Cale> goltrpoat: why?
21:34:01 <mwc> tabstop=4 shiftwidth=4 expandtab autoindent
21:34:06 <mgsloan> well, they have examples, but I already know what it looks like
21:34:11 <SamB_XP> goltrpoat: noooo, it is not
21:34:23 <sorear> mine is 625 (I got it down to 590 iirc)
21:34:24 <mgsloan> and I use it all the time, just I don't know the specifics of the feature
21:34:27 <SamB_XP> 8 is the standard and has always been the standard
21:34:30 <Cale> goltrpoat: it makes programs unambiguous
21:35:08 <goltrpoat> because many projects incorporate a number of languages, and requiring that i switch my tab settings every time i switch between subprojects is a fairly arbitrary thing to do
21:35:13 <mgsloan> i've seen [2,4...8] spaces used
21:35:24 <goltrpoat> different places have different tab settings for whatever historical reasons
21:35:32 <SamB_XP> goltrpoat: so you would like for tabs to be banned, then?
21:35:36 <sorear> ^I is shorthand for the number of spaces required to reach a multiple of 8 characters after the first newline. IT IS A FILE FORMAT DECISION.  IT IS NOT A USER INTERFACE ISSUE.
21:35:49 <nmessenger> mgsloan: Error: Not in scope: `...'
21:35:50 <mgsloan> That's probably why there are those end-file comment things which specify tab values
21:35:52 <goltrpoat> no, i have no problem with tabs.  i just don't think it's wise to dictate an overarching tab policy.
21:35:52 <goltrpoat> heh
21:35:56 <mgsloan> bah, ..
21:35:58 <mwc> goltrpoat, you can set your documents to trigger the proper behaviour in decent editors.
21:35:59 <Cale> goltrpoat: the solution is to never use tab characters (unless you're using some retarded language which requires the use of tab characters)
21:36:11 <mgsloan> I always get them confused.  Technically ... is the proper ellipsis
21:36:15 <nmessenger> :>
21:36:22 * mwc kicks the nearest Makefile on behalf of Cale
21:36:34 <goltrpoat> cale:  i'm ok with that.  many people aren't.
21:36:51 <SamB_XP> goltrpoat: if they don't use 8-space tabs, they are fools
21:36:53 <sorear> If you want to change the definition of ^I, by all means do so, but DO NOT UNDER ANY CIRCUMSTANCE END A FILE CONTAINING NON-STANDARD TABS WITH .TXT, .C, .HS, .LHS, OR ANY OTHER ASCII EXTENSION.  </rant> <deepbreath/>
21:36:54 <Cale> many people are going to have to learn to not use tabs then
21:36:57 <mgsloan> vim and emacs at least, i think pick up on these end comment thingamabobs
21:36:58 * allbery_b always uses .. for that kind of thing due to early infection by Pascal
21:37:12 <goltrpoat> samb:  i'm consulting for a company that uses 2 space tabs.
21:37:14 <clanehin> is there a yhc channel?  Should I just ask?
21:37:22 <allbery_b> just ask, I think
21:37:28 <sorear> it's called ndm, no '#'
21:37:31 <SamB_XP> goltrpoat: tell them some random person said they are fools, then, why don'tcha?
21:37:38 <goltrpoat> samb:  i'm not prepared to tell them they're fools.
21:37:38 <Cale> clanehin: you can ask here, I'm not sure if there are any yhc people around at the moment
21:37:54 <SamB_XP> goltrpoat: isn't that what consultants are supposed to do?
21:37:58 <Cale> but we can see what we can do :)
21:37:59 <mwc> I was hacking on the Lua language at one point. Their C code is indented at ONE space
21:38:07 <mr_tenor> goltrpoat: consultant rates for reformatting their code? >:)
21:38:07 <SamB_XP> you should threaten to sue them for violating the ASCII convention
21:38:11 <mwc> it's actually very readable. I quite liked it
21:38:15 <goltrpoat> samb:  i wasn't contracted to point out issues with their tab settings :)
21:38:25 <sorear> cat < /usr/src/linux/Documentation/CodingStyle > /dev/irc
21:38:34 <SamB_XP> goltrpoat: that is worse than violating the geneva convention, you know!
21:38:35 <goltrpoat> point is, people use the most random tab settings.
21:38:47 <clanehin> well I'm trying to add Data.Map, and when it compiles it complains about a GHC related #if, should I try to configure a preprocessor or delete the directive, or other suggestion.  I'm just starting.
21:38:55 <SamB_XP> people aren't known for being smart
21:39:04 <Cale> goltrpoat: right, but if you just set your editor to convert all tabs to spaces, then it won't be a problem
21:39:04 <mwc> There's a whole Wikipedia thread covering at least 6 different indent conventions for C
21:39:15 <clanehin> I'm working on the bug of so many libraries not being available with yhc
21:39:20 <Cale> goltrpoat: you'll always produce code which is unambiguous
21:39:58 <goltrpoat> cale:  sure
21:40:38 <sorear> I can't wait to see the #tabs logs :)
21:40:39 <goltrpoat> it's not exactly difficult to let it be specified per project though.  tabs are 8 spaces.  tabs are 4 spaces.  whatever.
21:40:57 <SamB_XP> it is *WRONG*
21:41:01 <Cale> clanehin: hmm...
21:41:04 <SamB_XP> also, Python will hate you
21:41:10 <goltrpoat> the people who like them their tabs get to keep them, and they can synchronize their project settings with their editor settings at their leisure
21:41:11 <SamB_XP> And Haskell
21:41:15 <sorear> #Haskell will hate you
21:41:40 <SamB_XP> tab stops and indentation are not a bit the same
21:41:41 <goltrpoat> :~(
21:41:45 <allbery_b> clanehin: if I read the docs right, include the -cpp compile option
21:41:49 <LordBrain> hmmm will a python interpret 8 spaces and a tab as equivalent for layout?
21:41:52 <SamB_XP> they don't need to use tabs for that
21:41:55 <Cale> clanehin: probably best to ask a yhc developer about it. I think ghc uses a slightly modified version of the C preprocessor.
21:41:55 <LordBrain> python interpretter i mean
21:42:03 <SamB_XP> LordBrain: it should
21:42:09 <LordBrain> i am not sure python makes the equivalence
21:42:25 <SamB_XP> it might just complain if there are mixed tabs and spaces at all
21:42:26 <LordBrain> i think it just says if you use tabs, use the same number of tabs wihtin the block
21:42:31 <LordBrain> on each line
21:42:52 <SamB_XP> well, in any case, Haskell is more complicated ;-)
21:42:58 <LordBrain> yeah
21:43:06 <LordBrain> layout is more finicky in haskell i find
21:43:26 <SamB_XP> you mean "if"s?
21:43:37 <Cale> I find it's not quite finicky enough. It allows lots of things which I think are dubious.
21:43:53 <SamB_XP> Cale: how many of those are standard and how many not so?
21:44:04 <nmessenger> would it be so evil to support -- -*- tab-width: 4 -*-
21:44:10 <sorear> YES!!!
21:44:13 <Cale> Oh, they're things which no sane Haskell programmer would write
21:44:18 <sorear> sorry couldn't resist...
21:44:20 <LordBrain> well, i am actually not sure what it is, its just when i moved into doing haskell i found i was more likely to get caught on layout issues, ifs yes, also lets, i dont think i can line my in up with my let if i want...
21:44:32 <mgsloan> pretty much everyone but the unix world uses 4-space tabs
21:44:32 <nmessenger> Yes evil, or yes you want it to be supported?
21:44:46 <SamB_XP> LordBrain: I always line up "let" and "in"
21:44:47 <LordBrain> in scheme its common to do that when you have a string of lets
21:44:49 <t35t0r> ts=4
21:44:51 <LordBrain> oh
21:44:54 <t35t0r> ai
21:44:57 <mgsloan> I have yet to find anything that says the ascii standard says 8.  then again I'm having trouble finding the ascii standard
21:44:59 <LordBrain> hmmm
21:45:15 <sorear> The entire unix world uses ts=8, and everyone else doesn't exist, so go away.
21:45:26 <Cale> Let's use ts=0
21:45:27 <Cale> hehe
21:45:28 <SamB_XP> sorear: unfortunately some unix users are nonexistant
21:45:29 <LordBrain> so lining up let and in is ok? somehow i got the idea it wasnt
21:45:30 <mgsloan> heh
21:45:32 <t35t0r> let's not plz
21:45:33 <allbery_b> I believe you're looking for ISO646
21:45:43 * sorear screams in terror
21:45:47 * nmessenger goes away
21:45:49 <t35t0r> python has destroyed ts
21:45:58 <SamB_XP> t35t0r: hmm?
21:46:08 <Cale> LordBrain: It generally is.
21:46:12 <sorear> ISO646 gave us int main() ??[ return 0 ??]
21:46:19 <sorear> ISO646 gave us int main() ??[ return 0; ??]
21:46:38 <dfranke> heh
21:46:46 <SamB_XP> sorear: no, that was ISO xxxx:xxxx, I think
21:46:48 <allbery_b> huh?  ISO646 has actual {}.  the ANCI C freaks gave us the abomination known as trigraphs
21:46:50 <dfranke> are trigraphs used anywhere outside the IOCCC?
21:46:52 <Cale> LordBrain: I usually either line them up straight, or indent the 'in' by one space so that its contents line up with the contents of the 'let' portion.
21:47:01 <SamB_XP> dfranke: obviously
21:47:11 <SamB_XP> dfranke: they are used somewhere
21:47:19 <sorear> I thought it was ISO646 left out enough to force trigraphs
21:47:21 <allbery_b> ISO646 is the first formal standardization of ASCII
21:47:31 <SamB_XP> sorear: that must be a different ISO
21:47:56 <sorear> ISO 10646 is Unicode (more or less)
21:48:03 <allbery_b> and, as expected, it include \x7B and \x7D, better known as { and }
21:48:20 <allbery_b> I thought trigrphs were intended for old EBCDIC-subset gear
21:48:59 <allbery_b> (since often { } were bundled with the lowercase characters and cheap IBM-compatible mainframe terminals didn't do lower case)
21:50:25 <sorear> `{\}~|
21:50:43 <sorear> no wait `{|}~
21:51:39 <allbery_b> in ASCII, yes.  EBCDIC was a bit more arcane
21:51:49 <allbery_b> (not to mention having two different variants of |)
21:52:06 <allbery_b> (broken veritcal bar was a different codepoint from vertical bar)
21:53:20 <SamB_XP> !
21:54:29 <allbery_b> of course, EBCDIC also had the "feature" that ['A'..'Z'] would include a bunch of punctuation becuase the letters were broken into three groups with punctuation and unoccupied code points separating them
21:55:26 <mgsloan> ISO646 may have specified 8, but at the time most printers used 6 or 4, and no one really changed because of a standard.
21:55:40 <allbery_b> (and then you had EBCDIC-as-consensus:  different IBM devices had different notions of what characters were where and it wasn't until the mid-late 70s that IBM started to rationalize them all into a single coherent standard
21:56:04 <mgsloan> err, actually 5 characters was the most popular value
21:56:16 <mgsloan> according to the most trustworthy source of wikipedia
21:56:48 <mgsloan> Suggests that 8 was chosen due to fortran
21:57:00 <sorear> ?seen dons
21:57:01 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 4h 10m 6s ago.
21:57:10 <mgsloan> do we really want some fortran archaism deciding how big our tabs are?
21:57:13 <allbery_b> what, bits/character?
21:57:21 <mgsloan> nah, tabsize
21:57:25 <allbery_b> oh, you're on tabs still
21:57:29 <mgsloan> yeah
21:57:37 <sorear> Baudot haskell
21:57:42 <SamB_XP> mgsloan: no, we want to follow the standard
21:57:48 <sorear> Yes we are STILL on tabs.
21:57:48 <allbery_b> manual typewriters often used 5-space tabs IIRC
21:57:54 <sorear> This is #haskell
21:58:04 <allbery_b> (g-d that was a long time back...)
21:58:12 <sorear> I wonder what it's like in #tabs. :)
21:58:23 <SamB_XP> I don't care how many spaces to the right the cursor moves when you hit <tab> -- so long as your '\t's all represent moving to the next 8-character tab stop!
21:58:45 <sorear> SamB: My point (wrt the shouting rant) exactly.
21:58:53 <ClaudiusMaximus> i remember being able to program the tab stops on my dot matrix printer to whatever i wanted them to be, in the early 90s.
21:58:53 <ClaudiusMaximus> anyway, for the logs in case someone else runs into this: (04:55:54) ClaudiusMaximus: with MissingH-0.14.4/ghc-6.4.2, which module should i import to get openBinaryFile?    <<   System.IO
21:58:56 <mgsloan> tubad the standard is like 40 years old
21:59:14 * allbery_b doesn't care much about tabs, he sets emacs indent-tabs-mode nil and haskell-mode indents by lining up content :)
21:59:17 <SamB_XP> mgsloan: you want to use something else?
21:59:20 <dobblego> ?hoogle openBinaryFile
21:59:20 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
21:59:25 <mr_tenor> sorear: well, haskell has signifigant and insignifigant whitespace, yes? i recall something duringa discussion on enumerations or whatnot about where you put the ".." , i think
21:59:57 <mgsloan> well, no one really uses that part of the stanard
22:00:04 <SamB_XP> mgsloan: no one?
22:00:05 <SamB_XP> I do!
22:00:18 <sorear> ?topic #haskell-overflow
22:00:19 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
22:00:24 <mgsloan> if they haven't in 40 years, it is my opinion that it will never really be adopted
22:00:26 <sorear> ?topic-tell #haskell-overflow
22:00:26 <lambdabot> Overflow channel for #haskell conversations.
22:00:36 <sorear> ?topic-tell #haskell-blah
22:00:37 <lambdabot> Anything BUT Haskell (even SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first works: "Ooh, functional programmers are so
22:00:37 <lambdabot> hot" -|- current topic: "People of America, please stay calm. Please stay in your homes. The terrorists are coming to get you..." (System Of A Down - Novus Ordus Clitorus)
22:00:44 <SamB_XP> mgsloan: lots of things use that part of the standard
22:01:01 <t35t0r> clitorus 'eh
22:01:03 <mgsloan> and more don't
22:01:14 <SamB_XP> so? lots of things don't use tabs
22:01:54 <mgsloan> well, more don't use or default to 8.  In many cases attributing a specific space count to a tab is nonsensical
22:01:55 <SamB_XP> now, the things that can be specifically configured to violate it...
22:02:22 <SamB_XP> using broken programs as an argument for ignoring standards is silly...
22:02:33 <mgsloan> somehow I refuse to believe that the tab character is merely pre-compression built into the standard
22:03:18 <SamB_XP> @devils tab
22:03:20 <lambdabot> No match for "tab".
22:03:22 <mgsloan> I think there are more that can be configured to not violate it...
22:03:45 <SamB_XP> a pity that the devil's dictionary was written before tabs...
22:04:09 <mgsloan> I see 8 as rather large, but perhaps thats just my youthful eyes
22:04:40 <SamB_XP> nobody asked you to use tab characters
22:05:04 <mgsloan> I'll agree with you on that one
22:05:28 <SamB_XP> nobody suggested that 8 spaces is the ideal indentation step
22:05:40 <SamB_XP> nobody suggested that the tab key should produce a tab character
22:05:42 <mgsloan> I don't actually.  The editor auto converts from tab presses to 4 space charachters, and also navigates in a single step 4 space chars
22:06:16 <mgsloan> except the tab key, with its troublesome "Tab" writing :)
22:06:27 <SamB_XP> must be configured for Python hacking ;-)
22:06:33 <SamB_XP> mgsloan: eh, well, that isn't a person
22:06:41 <LordBrain> python does consider tab and 8 spaces as equivalent
22:06:44 <LordBrain> i looked it up
22:06:58 <mgsloan> objects are generally more trustworthy anyhow
22:07:19 <SamB_XP> LordBrain: after reading that long thread about indentation, I didn't remember what was actually implemented ;-)
22:07:29 <goltrpoat> samb:  i just don't think it's reasonable to force people to not use tab characters if that's what they're used to.
22:07:30 <lambdabot> goltrpoat: You have 1 new message. '/msg lambdabot @messages' to read it.
22:07:39 <mgsloan> actually, i've never done much python.  much more a lang inspired by it
22:07:53 <mgsloan> with static, inferred typing
22:08:00 <SamB_XP> oooh
22:08:21 <mgsloan> yep, pretty sweet for a procedural language :)
22:08:29 <goltrpoat> sorear:  i did see the prover on the wiki, i think we're trying to accomplish different things though
22:08:32 <mgsloan> s/procedural/imperative
22:08:45 <goltrpoat> mine was a simple 30 minutes deal with readable code and some background
22:09:52 * shapr kills the nearest object
22:10:33 <goltrpoat> the one on the wiki is more of a "let's see how much we can obfuscate it" type deal
22:11:26 <mgsloan> shapr - you butcher!
22:11:31 <mgsloan> ;P
22:11:35 <goltrpoat> it's a different approach, too
22:13:46 <wy> Any suggestions about a book to read after going over the tutorials?
22:14:26 <nmessenger> Dude!  Does dons really have blue hair?  http://trappist.elis.ugent.be/~kehoste/haskell-blahSouthPark.html
22:14:28 <lambdabot> Title: #haskell-blah: Everything but Haskell - South Park people
22:15:15 <sorear> openBook >>= \b -> maxPageNumber b >>= mapM_ readPage b . enumFromTo 1 >> closeBok
22:15:16 <SamB_XP> well, Cale looks accurate
22:15:33 <nmessenger> and shapr?
22:15:58 * SamB_XP doesn't remember what shapr looks like, if he's even seen a clear photo
22:16:59 * SamB_XP wonders what he would look like
22:17:02 <shapr> I'm tall and wide.
22:17:26 <goltrpoat> i'm short and thin.
22:17:29 <SamB_XP> shapr: that doesn't translate into the southpark format very well
22:17:31 <goltrpoat> oh no.  i'm a co-shapr.
22:17:40 <shapr> http://www.scannedinavian.com/hope/tag/shae
22:18:16 * goltrpoat hands shapr a contravariant functor.
22:18:31 * SamB_XP wonders what beelsebob was thinking
22:18:55 <shapr> nmessenger: So, does my south park pic match my photos?
22:18:59 <SamB_XP> http://trappist.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html
22:19:02 <lambdabot> Title: #haskell-blah: Everything but Haskell - Lambdabot contest, http://tinyurl.com/y949tc
22:19:14 <shapr> goltrpoat: Variant is a dirty word, gives me Visual Basic flashbacks...
22:19:37 <nmessenger> shapr: seems crazy enough
22:19:48 <SamB_XP> where can I find photos of lambdabot?
22:19:54 <sorear> ?where lambdabot
22:19:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
22:20:00 <sorear> ^^^ there
22:20:20 <SamB_XP> thats not a photo -- that is just the southpart lambdabot winner
22:20:24 <Stinger_> haha
22:20:25 <goltrpoat> shapr:  variants are just type sums, though.
22:20:42 <SamB_XP> er.
22:20:45 <SamB_XP> southpark
22:20:48 <SamB_XP> how do I do that
22:20:52 <SamB_XP> t is nowhere near k
22:21:00 * shapr goes to sleep, to return tomorrow.
22:21:03 <SamB_XP> must be some kind of speech impediment
22:21:08 <allbery_b> over-active fingermacro
22:21:29 * SamB_XP kinda likes ndm's
22:21:44 <nmessenger> SamB: I find myself typing integer when I want internet.
22:22:02 <SamB_XP> I think I just find an angel with a red lightsaber to be paradoxical
22:22:09 <SamB_XP> and so intriguing
22:22:45 <SamB_XP> okay I must like sleep
22:23:41 * allbery_b is reminded of listening to a BBC World Service news announcer who kept trying to say "Admiral" nd kept actually saying "adminrable" --- took her 5 or 6 tries to get it right and you could hear in her voice that she was becoming more and more frustrated while trying to maintain proper "attitude"
22:23:45 * nmessenger5 got disconnected... checks the irc logs.
22:23:48 <allbery_b> it was funny as all get-out
22:24:13 <allbery_b> ...and one of my own fingermacros got into that :> "admirable"
22:24:34 <SamB_XP> hahaha
22:25:36 <LordBrain> Maybe GHC should forbid tabs
22:26:07 <SamB_XP> oh, sleep, right
22:26:08 <sorear> ooh..  4/300 is a lot of stefans
22:26:14 <goltrpoat> also:  keyboards.
22:26:51 <mgsloan> LordBrain: probably a good idea, might piss off a few people, but eh
22:27:29 <mgsloan> I'm not dealing with the issue at all, by designing a visual language :)
22:28:34 <mgsloan> which actually solves a surprising number of problems, but probably creates bigger/more problems which at this point are unapparent
22:28:50 <goltrpoat> in general, pissing off as many people as you can appears to be an excellent way towards gaining acceptance.
22:29:23 <LordBrain> hmmm how do you figure goltrpoat ?
22:29:23 <mr_tenor> it's agred then
22:29:29 <SamB_XP> well, it would not piss off those who already know how to use Haskell *and* have nonstandard tab stops
22:29:32 <goltrpoat> lordbrain:  i'm being sardonic.
22:29:40 <LordBrain> oh
22:29:44 <sorear> If something as trifling as an assassinated archduke could spark WWI, I'm sure tabs will have no difficulty whatsoever.
22:29:45 <LordBrain> :)
22:29:53 <mr_tenor> http://img.photobucket.com/albums/v483/gabbagabba/warningsign_tabs.jpg
22:29:56 <lambdabot> http://tinyurl.com/ycd2bt
22:30:10 <SamB_XP> goltrpoat: oh, I thought you were talking about C++
22:30:12 <SamB_XP> or Java
22:30:15 <goltrpoat> :)
22:30:28 <LordBrain> well, i suppose the gentle way would be to just warn about it for a while...
22:31:16 <sorear> You see, there is major difference.  When someone comes along talking about C++ we climb our Haskell Tower and pretend they don't exist.
22:31:59 <sorear> But with tabs it is different, because the question of tabs is seen as a legitimate threat to our survival.
22:32:27 <goltrpoat> i just don't see what the issue is.  interpret it as 4 spaces by default, document that, and make it configurable.
22:32:39 <mgsloan> heh, I thought you were talking about PHP
22:32:59 <LordBrain> the guy who did python apparently has said if he were doing it today would not allow tabs
22:33:29 <sorear> yeah, well, KT has said that he would spell creat with an e next time
22:33:34 <goltrpoat> hah
22:33:39 <allbery_b> GvR?  yeh, that sounds about right
22:34:17 <mr_tenor> options sound great til everyone starts using all different subsets all at once
22:34:21 <LordBrain> i have not had too much problem with tabs tho personally... i have a fairly powerful and configurable editor of course... and i know how to use it
22:34:26 <sorear> Wow nmess, you're the first duplicate nick I've seen with the decency to count in decimal!
22:34:38 <goltrpoat> right, but then it's their problem -- they chose to use tab characters, when they knew it was going to be a shared codebase
22:34:50 <goltrpoat> you have the same issue in c++, whether it's cosmetic or not
22:35:06 <mr_tenor> "C++ sucks more" is not a valid excuse ;)
22:35:06 <sorear> (As opposed to unary - dcoutts, dcoutts_, dcoutts__, dcoutts___, etc)
22:35:11 <mgsloan> how about ghc just warns on tabs, and provides a link to a detab tool
22:35:20 <goltrpoat> warn on tabs is fine.
22:35:32 * allbery_b has several times run people's C code through indent to correct odd tab settings to make it readable
22:35:48 <sorear> how about ghc just launch nuclear missiles on tabs, and provides a link to the ?logs
22:35:52 <nmessenger7> sorear: well, my client is responsible for that, actually.  *blush*
22:36:06 <allbery_b> 'tabs considered harmful'
22:36:27 <wy> Where can I find the code for the prelude?
22:36:33 <sorear> ?source Prelude
22:36:34 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
22:36:34 <allbery_b> ?source Prelude
22:36:34 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
22:36:38 <LordBrain> its in the standard report
22:36:38 <sorear> ^^^ GHC version
22:36:39 <allbery_b> heh
22:36:43 <goltrpoat> 'passive verbs in paper titles considered passe'
22:36:45 <LordBrain> or a version is
22:36:47 <goltrpoat> hehe
22:36:59 <sorear> http://haskell.org/onlinereport/standard-prelude.html
22:37:00 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
22:37:35 <wy> Thanks!
22:37:41 <mr_tenor> goltrpoat: have you seen "'Considered harmful' papers considered harmful"?
22:37:46 <goltrpoat> hehe yes
22:37:50 <mr_tenor> :)
22:37:53 <nmessenger7> ?google considered harmful
22:37:55 <lambdabot> http://meyerweb.com/eric/comment/chech.html
22:37:55 <lambdabot> Title: "Considered Harmful" Essays Considered Harmful
22:39:21 <goltrpoat> movie time.  later
22:39:23 <mgsloan> what's funny is that's a * Considered Harmful essay
22:39:44 <sorear> yea, I think that's the point
22:39:51 <sorear> (of the title anyway)
22:39:59 <nmessenger7> IRONY FTW
22:40:04 <mr_tenor> like an extended "all generalisations are false"
22:40:14 <mgsloan> yeah
22:40:48 <nmessenger7> "preceeded by its quotation yields falsity" preceeded by its quotation yields falsity
22:40:53 <wy> Is the article "Considered Harmful" Essays Considered Harmful itself considered harmful?
22:41:14 <sorear> fix a. a -> b
22:41:39 <nmessenger7> what is this fix a. thing?
22:42:00 <sorear> (((((...) -> b) -> b) -> b) -> b)
22:42:12 <sorear> it's not Haskell syntax - and that's a good thing
22:42:38 <sorear> In the curry-howard isomorphism, that type maps onto "This statement is false"
22:43:14 <sorear> no good having statements like that in your logic
22:43:42 <mr_tenor> it increases the amount of things you can prove to be true :D
22:43:48 <nmessenger> "This statement" is analogous to GNU's GNU?
22:44:02 <sorear> mr_tenor: greatly.
22:44:44 <sorear> the only type systems I know of supporting fixpoint types have forall a. a as a theorem
22:45:00 * mgsloan keeps forgetting that the curry howard isomorphism is just that code is proof
22:45:08 <nmessenger> woah, so all expressions typecheck?
22:45:48 <sorear> in my system - yes.  In haskell - no, everything is true but some proofs are still bogus.
22:46:18 <sorear> undefined proves everything ; 'a' : 'a' is a bogus proof
22:46:45 <nmessenger> P AND NOT P, THEREFORE Q
22:47:09 <nmessenger> or something like that
22:47:29 * nmessenger does not have a sophisticated understanding of these things
22:58:00 <sorear> ?users
22:58:01 <lambdabot> Maximum users seen in #haskell: 309, currently: 260 (84.1%), active: 26 (10.0%)
23:12:49 <ClaudiusMaximus> results of my last few days of haskell coding>>  http://claudiusmaximus.goto10.org/index.php?page=gallery/coding/gridskell&image=test-outer.png&size=original   (left hand side is Pd+GF, right hand side is Haskell)  ( http://puredata.info , http://gridflow.ca )
23:12:52 <lambdabot> Title: test-outer.png - Gridskell - Coding - Gallery - ClaudiusMaximus - ClaudiusMaximu ..., http://tinyurl.com/y69l9m
23:18:26 <mgsloan> ooh, cool, PureData
23:18:51 <mgsloan> I'm designing  a visual language atm.  Never used PD, but seen many references
23:18:52 <wy> > lex "|<2|3>>"
23:18:53 <lambdabot>  [("|<","2|3>>")]
23:19:04 <wy> Why is it "|<" ?
23:20:45 <ClaudiusMaximus> mgsloan: Pd is great fun, but the user interface sucks at the moment, too much switching between keyboard and mouse (there is a fork to write a new gui, though)
23:21:01 <mgsloan> ah
23:21:24 <sorear> |< is one lexeme
23:21:29 <mgsloan> Yeah, that's a big issue with graphical languages
23:21:35 <sorear> === haskell operator (in this case)
23:21:52 <ClaudiusMaximus> mgsloan: channel #dataflow is mainly full of Pd users, and #desiredata is the channel for the fork
23:21:56 <wy> sorear: So how can I lex "|" out alone?
23:22:21 <mgsloan> I'm thinking it might be possible to do something like vi/emacs modes for a UI
23:22:48 <mgsloan> eg, use main keyboard area for navigation, actions as well as text entry
23:23:41 <mgsloan> my VPL isn't actually dataflow though
23:24:19 <mgsloan> functional.  Dataflow stuff will likely be supported as a DSL, though.
23:24:30 <allbery_b> wy: use parsec to write your own parser instead of relying on Language.Haskell?
23:24:52 <allbery_b> (which, naturally enough, lexes and parses according to Haskell rules)
23:28:37 <sorear> allbery_b: lex is in the Prelude (not like it makes a difference)
23:59:47 <dancor> how can i set the result of a bracket expression to something
