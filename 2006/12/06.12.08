00:00:30 <sieni> > let incr x = head $ tail [x..] in incr 6.5
00:00:31 <lambdabot>  7.5
00:00:31 <metaperl> fromEnum 'c'
00:00:40 <metaperl> > fromEnum 'c'
00:00:42 <lambdabot>  99
00:00:47 <metaperl> > fromEnum 'A'
00:00:48 <lambdabot>  65
00:01:29 <sieni> > pred 4.5
00:01:31 <lambdabot>  3.5
00:01:35 <sieni> > succ 6.7
00:01:36 <lambdabot>  7.7
00:01:43 <sieni> metaperl: there you go!
00:01:53 <dons> metaperl: did you see the CUFP report?
00:01:58 <dons> http://programming.reddit.com/info/u2pb/details
00:01:59 <lambdabot> Title: Commercial Users of Functional Programming (reddit.com)
00:02:00 <metaperl> the next floating point is not 1 +  a float :)
00:02:23 <metaperl> dons - I think so - Aetion, Galois, CSFB, Linspire?
00:02:38 <dons> yep, the scheme in space article looks good too
00:03:24 <metaperl> so reddit is a site where you link to things you have read?
00:03:45 <dons> basically. to good things anyway :)
00:04:05 <dons> social blah blah linketity clickity trolling clicks
00:04:46 * Korollary congratulates dons on starting the controversial FP = silver boollette thread
00:05:13 <dons> Korollary: hehe :)
00:05:46 <Korollary> That's a horrible study btw
00:06:06 <dons> very very old data. nice summary on the blog psot though :)
00:06:45 <dons> the actual data is pretty uninteresting, considering how obsolete it is: we've been showing the productivity improvments for the last 15 years since the original study
00:06:56 <Korollary> but line counts mean jack
00:07:03 <dons> yep
00:07:10 <Korollary> I like the icfp style
00:07:39 <Korollary> time to code, flexibility, etc.
00:07:51 <dons> yeah.
00:08:09 <dons> why don't we ever see articles saying that oO is a silver bullet :)
00:08:22 <Korollary> we don't see any articles about silver bullets
00:08:25 <dons> that it manages complexity , that it will make multicore easier :)
00:08:33 <lispy> one thing to always keep in mind when looking for the silver bullet is that the programmer is probably the biggest and most variable value in the equation
00:09:37 <lispy> one possible interpretation is that we won't master software engineering until we remove said human from the equation and replace it with something less variable :)
00:09:51 <dons> with a higher order function
00:10:35 <Korollary> humans vary for other engineering disciplines as well. They didnt need to be taken out.
00:11:10 <dons> we just need better tools. and its pretty clear that there are better tools out there. people should use them.
00:11:40 <Korollary> I think we have good enough tools. We don't just have good ideas for software.
00:12:03 <lispy> dons: but, the problem with that argument is that "better" is subjective and even worse, the way we measure "better" even when the notion gets fixed is also up to the beholder
00:12:52 <dons> computer science is all about 'better'. hence we have so many wars :)
00:12:54 <Korollary> Take Scheme. It has been around for ages. Obviously better than what was mainstream at the time. Where's the fantastic software written in it?
00:14:12 <dons> i'm very wary of mainstream arguments. apple macs are obviously great, why is windows the winner? is it a better technology?
00:14:26 <lispy> worse is better
00:14:28 <dons> too many non-scientific variables govern the appearence of new apps
00:15:00 <lispy> http://www.jwz.org/doc/worse-is-better.html
00:15:01 <lambdabot> Title: The Rise of ``Worse is Better''
00:15:09 <Korollary> OS' are a few levels up in complexity, so it's even harder to discuss them.
00:15:24 <lispy> actually, maybe that's not the article i thought
00:16:15 <lispy> second thought, it's good
00:17:04 <lispy> The lesson to be learned from this is that it is often undesirable to go for the right thing first. It is better to get half of the right thing available so that it spreads like a virus. Once people are hooked on it, take the time to improve it to 90% of the right thing.
00:17:04 <lispy> A wrong lesson is to take the parable literally and to conclude that C is the right vehicle for AI software. The 50% solution has to be basically right, and in this case it isn't.
00:17:42 <Korollary> I dont think so
00:18:02 <Korollary> ignore the brand new apps for a moment
00:18:15 <Korollary> People write things like instant messaging clients, text editors, etc. every day.
00:18:34 <Korollary> Where's the much better instant messaging app that's written in scheme?
00:19:08 <dons> they might be smaller, have been built faster: but the result is the same, an IM client
00:19:39 <dons> so the user doesn't care, they'll take whichever builds easiest, and is 90% ok
00:19:44 <lispy> Korollary: i can't even find one by googling it
00:19:51 <Korollary> it's not about building it
00:20:00 <Korollary> two guys start out tomorrow working on the next jabber client
00:20:05 <dons> maybe scheme really is a teaching language :)
00:20:06 <Korollary> performace certainly is not an issue
00:20:21 <dons> cool, Visual haskell 0.2 is out: http://www.haskell.org/visualhaskel
00:20:34 <astrolabe> It's partly that people who know scheme would be bored by writing an IM client.
00:20:37 <Korollary> You'd think that the guy writing in scheme/ocaml/etc. has an edge over the guy writing in c++/java in terms of adding features, etc.
00:20:51 <Korollary> You'd think that he'll finish sooner. His code looks better.
00:21:11 <dons> that seems to be the case though, Korollary. pugs for example :)
00:21:36 <dons> or the C++ darcs that was abandoned, and rewritten to become the darcs we know and love
00:21:38 <Korollary> I don't mean to ignore pugs, but pugs is a lot more complicated than an IM client.
00:22:06 <lispy> Korollary: so would you also exclude darcs from this discussion on the same basis?
00:22:06 <astrolabe> dons: that should be http://www.haskell.org/visualhaskell/
00:22:08 <lambdabot> Title: Visual Haskell
00:22:18 <lispy> darcs was orignially in C++, but it was a pile of bugs
00:22:18 <Korollary> lispy: No, I wouldnt ignore darcs as it has many competitors
00:22:39 <dons> Korollary: what's your thesis here? I'm getting a bit lost in the details
00:22:48 <Korollary> and darcs is not significantly better than its competitors, either.
00:22:54 <lispy> droundy started rewriting it into haskell and that version actually worked
00:23:09 <dons> I wrote hmp3 in 3 days, and it was better and more stable than any of the C or python mp3 players on my machine.
00:23:15 <dons> that's my personal experience though :)
00:23:34 <Korollary> dons: I'm just saying that if scheme was that much better, then statistically we should see some significantly better IM clients, etc. written in it.
00:23:49 <dons> maybe scheme isn't? its old -- it needs static typing and control of side effects
00:23:50 <lispy> dons: but, you're a known excellent coder and my argument is that makes the biggest difference :)
00:24:07 <dons> yeah, I'd say the coder is the biggest factor
00:24:24 <metaperl> dons - what do you use to design your webpages at usw.edu.au? they look nice?
00:24:29 <astrolabe> But surely haskell coders are better than average
00:24:31 <dons> just vim and some css :)
00:24:38 <Korollary> That's why I pick IM clients as an example. A lot of ordinary programmers should be writing things like that.
00:24:40 <metaperl> dons who is your primary thesis advisor?
00:24:54 <dons> http://www.cse.unsw.edu.au/~chak
00:24:55 <lambdabot> Title: Manuel M T Chakravarty
00:24:57 <dons> http://www.cse.unsw.edu.au/~keller
00:24:58 <lambdabot> Title: Gabriele Keller
00:24:59 <dons> those two guys
00:25:13 <lispy> dons: oh, really?
00:25:14 <metaperl> i see
00:25:25 <lispy> dons: Manuel was just in portland last week
00:25:34 <dons> yeah, I heard.
00:25:35 <lispy> meeting with droundy about concurrent stuff
00:25:46 <lispy> i was too busy, but it would have been interesting to attend
00:25:50 <Korollary> dons: scheme lacks typing, but it still has a lot over c++ imho.
00:25:55 <dblhelix> you could do worse than those two, I guess
00:26:54 <lispy> Korollary: what percent of average Joe/Jane coders are introduced to scheme/ocaml/haskell/ML vs Java/C/C++/C#/VB
00:26:55 <Korollary> We can also replace scheme with sml/ocaml if typing is that important.
00:27:31 <Korollary> lispy: I know that exposure isn't the same, but those few who know sml/scheme should still do a lot better.
00:27:46 <dons> Korollary: do you think its inexplicable that people code in php?
00:27:47 <thermoplyae> fwiw, a lot of cs students at the university I'm at (uiuc) are introduced to Ocaml
00:27:53 <Korollary> so 20 IM projects in C++ versus 3 IM projects in SML.
00:28:02 <lispy> Korollary: i do a lot of haskell programming and my VB code is still pretty terrible
00:28:06 <Korollary> dons: No, it is not. I dont have a problem with it.
00:29:48 <Korollary> lispy: VB6 code tends to be that way. Mine wasn't anything special, either.
00:30:15 <lispy> Korollary: right, so that makes me think exposure isn't enough to give rise to noticable differences
00:30:25 <astrolabe> In my view the reasons are 1) scheme etc are more difficult and so their community is smaller and more exclusive, 2) they have less extensive libraries than say Java, 3) the people that can code in them tend to be interested in coding more esoteric stuff 4) abundance of tools -debuggers etc for java and 5) inertia, you won't get into trouble for to deciding that an app should be coded in Java.
00:30:31 <Korollary> lispy: That's not what I meant at all.
00:30:53 <dons> I think inertia is the biggest factor
00:31:07 <Korollary> Inertia is less of a factor for the lone hacker.
00:31:08 <kzm> Korollary, not sure if it's relevant, but isn't the ICFP contest evidence in favor of more powerful (in the Paul Graham sense) languages?
00:32:08 <kzm> Perhaps they'll have an IM client as next year's task?
00:32:12 <astrolabe> I think it's a complicated dynamic system, and all the factors reinforce each other in complicated ways :(
00:32:15 <lispy> kzm: but, this is a muddy argument...i could argue that the people who take on the challeng of the ICFP tend to be good programmers and they tend to be functional programmers because of how the contest is known
00:32:49 <dons> we don't see enough visual basic entries!
00:32:49 <kzm> lispy, well - you can compare the list of successful entries vs total entries by language.
00:32:49 <astrolabe> lispy: if you look at the stats, about half the entries aren't in functional languages.
00:33:12 <lispy> to me it's obvious that this debate cannot be settled by arguing and instead we need more hard facts and statistics
00:33:13 <ulfdoz> astrolabe: I believe everything, except "you won't get into trouble [...] java". Code and documentation quality often suchs.
00:33:18 <kzm> So you need to argue that ICFP somehow attracts good functional programmers and bad imperative ones...
00:33:34 <ulfdoz> sucks, even.
00:33:44 <Korollary> ICFP os interesting, but it attracts very good programmers. Therefore, it's a bit skewed at the high end.
00:34:01 <dons> its promising that the google team chose to use haskell
00:34:07 <dons> without being existing members of the community
00:34:10 <astrolabe> Korollary: what is your thesis here?
00:34:18 <kzm> So - good programmers are more productive with functional languages, but poor ones are better off with imperative ones?
00:34:28 <metaperl> did the google team win?
00:34:30 <kzm> dons, they did?
00:34:31 <dons> kzm, or poor programmers don't know better?
00:34:37 <astrolabe> kzm: I think so
00:34:38 <dons> metaperl: yep, kzm: yep
00:35:27 <kzm> Of course, Google is known to hire people with strong theoretical backgrounds.
00:35:31 <dons> learning stuff is hard, learning a new programming paradigm is probably too hard for a bad programmer :)
00:35:41 <Korollary> kzm: We don't see sources of most entries. But I believe the FP entries are by much better programmers. Maybe they should rename the contest. I didn't know of ICFP before I learned haskell.
00:35:49 <lispy> dons: or maybe the definition of a bad programmer
00:36:16 <lispy> i learned about it from #lisp
00:36:22 <lispy> someone anounced it there
00:36:26 <astrolabe> I believe that 'do a then do b then do c'-code is closer to the way most people think of getting something done than 'x = y in z'-code
00:36:26 <earthy> I did know about ICFP before learning haskell
00:36:40 <earthy> plus, it's been announced on /. and the like for a few years already
00:36:49 <dons> Korollary: why do these better programmers choose FP languages?
00:36:55 <ralf`> dons, there's no such thing as a "bad" programmer. ;)
00:37:04 <lispy> astrolabe: well, people have done studies...i appears to depend on a lot of fators like the person's training
00:37:05 * earthy disagrees with ralf`
00:37:23 <Excedrin> if ICFP had "implement an IRC to AIM/MSN/YM/Jabber proxy" as the task, would people find it horribly boring?
00:37:35 <Korollary> dons: I don't know. Those are "some" good programmers who came in contact with FP and liked it. Not all "good" programmers do so. I am not sure those programmers participate in ICFP, either.
00:37:38 <earthy> I've tried to teach programming to enough people to know that some Just Don't Understand Abstraction
00:37:40 <Excedrin> (I suspect so)
00:37:48 <lispy> astrolabe: it seems a lot of people tend to handle sets pretty well compared to C style for loops
00:38:03 <earthy> excedrin: how would you judge the entries?
00:38:06 <dons> Korollary: i'd be worried if the smart people didn't like FP. so many smart people can't be wrong! ;)
00:38:17 <ralf`> earthy: abstraction means a lot of different things to a lot of different people.
00:38:25 <Excedrin> earthy: how complete they are
00:38:43 <earthy> excedrin: there's no programming challenge there
00:38:50 <Korollary> dons: For instance, not all CS professors like FP.
00:38:53 <earthy> w.r.t. completeness
00:39:07 <ralf`> dons: that's a good point.  People who think deeply and understand the complex abstractions that they are manipulating very well are nearly unanimouos: haskell _is_ all that.
00:39:09 <lispy> good night all
00:39:14 <earthy> it'd just be a way to spend time doing the same thing again and again (data a goes into slot b)
00:39:22 <ralf`> lispy: g'night.
00:39:22 <metaperl>  lispy good night
00:39:27 <Korollary> nite Mary
00:39:37 <lispy> Korollary: night Susan
00:39:45 <mbishop> I'm going to sleep too, ordered "Haskell school of expression" from amazon earlier :)
00:39:49 <dons> night JimBob
00:39:52 <earthy> korollary: otoh, no CS professors think FP is worthless and learning FP is worthless
00:39:57 <dons> mbishop: ah you decided on that one?
00:40:01 * mbishop nods
00:40:03 <Excedrin> earthy: ya, sort of the typical professional programming task
00:40:17 <earthy> excedrin: which is not what the ICFP contest is about ;)
00:40:26 <Korollary> earthy: Of course not. But I meant most don't prefer it.
00:40:46 <metaperl> mbishop - why?
00:40:57 <earthy> korollary: I think that's too strong a statement
00:40:59 <mbishop> metaperl: why not?
00:41:02 <metaperl> mbishop - you will have problems getting the graphics package to work with the code
00:41:11 <metaperl> I like the text but SJT is easier to work with
00:41:35 <Korollary> earthy: Why? I am not in the academia, but in the US it appears that most academic projects are not in an FP language.
00:41:47 <earthy> korollary: inertia
00:42:00 <earthy> not preference
00:42:00 <mbishop> metaperl: I suppose I'll find out
00:42:36 <earthy> lisp has had the bad aftertaste of 'that AI language that's horribly slow'
00:42:45 <Korollary> earthy: I don't know about that. If they thought it was a disadvantage not to use FP, they would certainly have overcome the inertia.
00:42:46 <earthy> and most CS profs don't know anything FP but lisp
00:43:10 <earthy> korollary: we're talking about shitloads of inertia :)
00:43:10 <mbishop> anyway, night
00:43:31 <astrolabe> good night
00:43:37 <Korollary> But if the profs cave to inertia, you can't blame the regular Joe out there at all.
00:43:45 * earthy isn't :)
00:44:02 <sieni> FORTRAN IV is the be-all and end-all
00:44:14 <earthy> sieni: no. NAG is the be-all and end-all
00:44:30 <earthy> (replace NAG by your favourite library of choice)
00:44:40 <Korollary> So that may explain the small size of FP practitioners. It doesn't explain why the ones who do don't kick ass.
00:44:48 <Excedrin> I'm just saying that a language that enables easy revision of a poorly specified problem should make something like that easy, wheras a language like C++ will probably be painful to write, buggy and incomplete and that it seems like that sort of example would attract more widespread interest than something more innovative
00:45:06 <astrolabe> Korollary: we do kick ass!
00:45:26 <earthy> korollary: anyone that is good at FP is also usually good in other languages...
00:45:43 <metaperl>  basically it boils down to what the United States got interested in, since we have the majority of the programmers and software companies
00:45:59 <Korollary> By kicking ass, I am referring to not individual quality, but mainstream projects that are vastly more successful than those in other languages.
00:46:00 * earthy nods
00:46:13 <astrolabe> @users
00:46:14 <lambdabot> Maximum users seen in #haskell: 278, currently: 255 (91.7%), active: 35 (13.7%)
00:46:22 <metaperl> what is the most widely used open source functional program-based app?
00:46:30 <metaperl> I mean something you can install from Debia
00:46:32 <metaperl> Debian
00:46:33 <astrolabe> Korollary: I think the fp community is much much smaller
00:46:50 <Korollary> astrolabe: I know. That doesn't explain everything, though.
00:46:54 <Excedrin> metaperl: does emacs count?
00:46:59 <earthy> korollary: you think viaweb (yahoo! stores) isn't hugely succesful?
00:47:12 <dons> emacs. yep. yahoo. ericsson's atm switches
00:47:14 <earthy> korollary: it does explain a lot
00:47:21 <metaperl> Excedrin :) I hadnt thought of that... I guess I was thinking of pure or nearly pure functional languages like ML or Haskell
00:47:29 <Korollary> earthy: I dont know how succesfull viaweb was.
00:47:47 <earthy> it went from $0 to $45M in 3 years...
00:47:52 <Korollary> so what
00:48:09 <dons> another problem is that good programmers in non-FP langs do a lot of FP things, closing the productivity gap.
00:48:12 <earthy> I'd say that qualifies as 'succesful' in some books. ;)
00:48:18 <beschmi> metaperl: what about mldonkey
00:48:19 <dons> they control state, they avoid side effects, they abstract
00:48:22 <mattam> metaperl: probably mldonkey
00:48:25 <metaperl> why is viaweb being mentioned?
00:48:38 <Korollary> dotcoms have a business aspect that complicates the discussion a lot.
00:48:52 <earthy> korollary: yahoo! stores is still succesful today
00:48:54 <Korollary> I mean simple mainstream apps like IM clients.
00:49:02 <Excedrin> mldonkey absolutely rules, I recently tried it... it's vastly more functional than any other p2p client
00:49:12 <dons> yeah, its pretty sweet.
00:49:34 <earthy> korollary: those are often built upon libraries
00:49:35 <dons> isn't lambdabot the greatest irc bot ever written?
00:49:37 <Korollary> Excedrin: I dont know. For bittorrent Azureus looks a lot better.
00:49:42 <dons> vastly more functional :)
00:49:46 <mattam> dons: certainly :)
00:49:47 <dons> and full of lambdas!
00:49:58 <earthy> and libraries are historically the downfall of small language communiteis
00:50:03 <Excedrin> Korollary: looks as in visual?
00:50:09 <metaperl> Excedrin - I found it hard to setup... I use bittorrent
00:50:16 <Korollary> Excedrin: No, functionality.
00:50:18 <earthy> java was a lucky shot, and well marketed
00:50:19 <dons> so who's coming to the hackathon to help with libraries, cabal and hackage?
00:50:55 <earthy> dons: I'm not. dutch FP day on the 12th, stuff to do on the evening of the 9th
00:51:01 <Korollary> earthy: Libraries of course matter. But people still write console apps every day. Besides, why are libraries so hard to write?
00:51:03 <dons> FP day?
00:51:24 <metaperl> And now... Chapter 14 of SJT: "Algebraic Types" !!!
00:51:27 <earthy> oh, and ta duty on the 10th
00:51:47 <earthy> korollary; libraries aren't hard to write. they take shitloads of time to write
00:51:56 <dons> yeah
00:52:00 <dons> good one, anyway
00:52:02 <metaperl> Korollary - I'm an Azureus user. That sucker totally rocks
00:52:03 <Korollary> earthy: Shouldnt FP cut down that time, too?
00:52:12 <earthy> it does.
00:52:27 <Korollary> so, if anything FP libraries should be available before anything else.
00:52:35 <earthy> ah... bzt. ;)
00:52:45 <Korollary> for something new that is
00:52:59 <earthy> yes
00:53:10 <dons> we have STM first, data parallel arrays first (for a mainstream lang) ....
00:53:20 <dons> so on the new stuff FP langs are ahead on the curve there
00:53:23 <Excedrin> what are Azureus' killer features?
00:53:38 <earthy> however, imperative languages are much easier to pick up for the average programmer, therefore fp communities tend to grow quicker
00:53:38 <metaperl> Excedrin - I'm not sure. But I love it
00:53:43 <earthy> err, non-fp communities that is
00:54:06 <Korollary> earthy: It's the size argument again. There are some apps you can write today in FP languages.
00:54:24 <Excedrin> what's easier to pick up for non-programmers?
00:54:24 <Korollary> for instance, mldonkey exists
00:54:49 <earthy> hey, the app I'm currently responsible for beats the pants off of all other apps in its class
00:54:56 <Korollary> earthy: what is it?
00:54:59 <earthy> Dazzle
00:55:10 <earthy> tool to develop bayesian networks in
00:55:18 <dons> dazzle's great
00:55:19 <Excedrin> I remember that, on DOS... vga graphics with 256 colors...
00:55:26 <Korollary> ah. That's not quite mainstream, though.
00:55:32 <earthy> no
00:55:49 * metaperl wonders what a bayesian network is
00:55:59 <earthy> metaperl: I'm not going to try to tell you ;)
00:56:14 <metaperl> no, I could wikipedia it and should
00:56:29 <Excedrin> metaperl: statistics based decision tree
00:56:38 <earthy> (but it amounts to a graph describing probablistic independences between statistical variables)
00:57:15 <earthy> anyway, pugs is a great example of the power of fp
00:57:25 <Korollary> not mainstream again
00:57:31 <earthy> wings3d
00:57:57 <dons> Korollary: what are you looking for? I'm finding it hard to work out what you're argument is :)
00:58:07 <dons> summarise please!
00:58:14 <Korollary> dons: I am looking for Yi
00:58:26 <dons> ?lambda Y I
00:58:42 <lambdabot> out of fuel - use @resume to continue
00:58:46 <dons> there it is
00:59:03 <dons> we win for the world's most recursive acronym, at least
00:59:35 <Korollary> Apps that don't have huge library requirements and are mainstream and rather simple. Like text editors and IM clients. There should be at least a few of those written in FP languages.
00:59:50 <Korollary> A few because of the size of the community of course.
01:00:31 * dons hands Korollary hmp3
01:00:36 <dons> ?where hmp3
01:00:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
01:00:51 <dons> dedicated band of users, few of whom are in this channel
01:00:55 <dons> (any?)
01:02:05 <Korollary> dons: hmp3 is a bit too simple. I mean, if it was like XMMS, then yes.
01:02:12 <earthy> why the hell would I waste my time writing yet another editor when vim does what I want?!
01:02:21 <Excedrin> does hmp3 decode mp3?
01:02:31 <Korollary> earthy: I don't know whether you would, but people do write text editors still.
01:02:34 <earthy> why the hell would I waste my time writing yet another IM client when irssi and adium do what I want?
01:02:49 * earthy knows
01:03:04 <earthy> but this requires people to be annoyed at the current offerings
01:03:26 <Korollary> I think people are sufficiently annoyed at various things.
01:03:34 <Korollary> I mean, apps are being written
01:03:59 <Korollary> dons wrote hmp3 for instance
01:10:47 <dons> kzm, btw, I just haven't read the email yet :) sorry!
01:10:56 <kzm> Ah.  OK.
01:11:06 * kzm drums his fingers on his desk.
01:11:11 * kzm looks at his watch.
01:11:13 <kzm> :-)
01:11:52 <kzm> I'm just trying to recruit some 133t h4xx0r help, that's all.  Unpaid labor.  That kind of stuff.
01:11:52 <kzm> :-)
01:12:01 <dons> oh, very interesting! /me reads on
01:12:16 <dons> kzm, ok, i'll have to think. i'll try to reply tomorrow morning. dinner time now!
01:14:01 * kzm sighs.
01:19:03 <tennin> hello
01:22:45 <retybok> is it possible to import a module (such as Array) in ghci?
01:22:56 <dons> :m + Data.Array
01:23:18 <retybok> dons: thanks
01:25:20 <pzpz> What would be the ideal structure for expressing a 2-dimensional array other than [[]] ?
01:26:48 <kzm> pzpz what do you want to do with the array?
01:27:02 <kzm> (U)Array (Int,Int) a ?
01:27:16 <kzm> [ByteString] ?
01:27:29 <kzm> Data.Map (Int,Int) a ?
01:27:38 <pzpz> Was thinking about implementing conway's game of life efficiently in haskell
01:28:11 <kzm> UArray of Bool is *really* efficient, I think.
01:28:25 <kzm> ghc packs them into bits, IIRC.
01:28:31 <dcoutts__> it's certainly effecient space-wise
01:28:36 <dcoutts__> less so time-wise
01:29:01 <kzm> dcoutts__, well - sometimes space-wise => time-wise.
01:29:20 <dcoutts__> in this case it's a trade-off
01:29:29 <dcoutts__> unless your array is bigger than your cache
01:30:02 <kzm> Yes, that's what I'd guess as well.
01:30:47 * dcoutts__ measured it
01:31:08 <kzm> That's of course better
01:31:31 <kzm> How did you measure (what algorithms)?
01:31:45 <kzm> Perhaps it doesn't matter much.
01:31:48 <dcoutts__> it was with an ants simulator
01:32:04 <kzm> ICFP contest stuff?
01:32:11 <dcoutts__> yup
01:32:17 <kzm> (Probably not the Java build system)
01:32:26 <dcoutts__> I tried both Array (Int, Int) Int (using 0 & 1) and Array (Int, Int) Bool
01:32:37 <kzm> UArray, surely?
01:32:42 <dcoutts__> erm yeah
01:33:01 <dcoutts__> I can't now recall what the factor between them was, but it was faster to use Int
01:33:26 <kzm> Okay.
01:33:29 <dcoutts__> single aligned memory read or write access per array access
01:33:40 <dcoutts__> rather than two + bit fiddling
01:34:13 <kzm> Hmmm, yes.  Normally, I'd expect the bit fiddling to be almost free (compared to memory access).  Why two?
01:35:25 <kzm> BTW -- it's not just the array that needs to fit into cache, but the whole application working set.  So if the array is rarely used, it could still be a win to use the packed array.
01:35:53 <dcoutts__> actually for a UArray it's probably a win more often
01:36:04 <dcoutts__> I was using a MUArray with lots of writes
01:36:18 <dcoutts__> it's the writes that take a read + a write
01:38:12 <kzm> dcoutts__, ah, yes, of course.
01:38:55 <kzm> For Life, I'd just produce a sequence of arrays, instead of mutating.  I.e. read only. At least initially.
01:39:09 <kzm> (pzpz You taking notes? :-)
01:40:28 <pzpz> kzm: yah, somewhat. swamped in homework and getting sidetracked thinking about haskell :(
01:40:59 <kzm> Heh.
01:41:02 <integral> @hoogle [a] -> (a -> Maybe b) -> [b]
01:41:02 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
01:41:10 <integral> @hoogle [a] -> (a -> [b]) -> [b]
01:41:10 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
01:41:11 <lambdabot> Control.Parallel.Strategies.parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
01:41:50 <kzm> I was at our Christmas dinner yesterday.  Had an argument with a visiting Russian(?) professor about the usefulness of UML and formal methods and static typing.
01:43:31 <kzm> I'm not sure adding formalism to UML is such a great idea, but it's a while since I did OO, so perhaps there's been some progress?
01:44:11 <kzm> (Formalism in the sense of - if I use the word correctly - denotational semantics)
01:46:54 <pzpz> look much at uml 2?
01:56:54 <kzm> pzpz, not at all.
01:57:56 <kzm> My main issue with UML is perhaps the prejudice that boxes and arrows are for convincing the clueless that they actually understand something -- and not for building a machine-verifiable or compileable model.
01:58:20 <kzm> And that if you add enough detail to actually do that, you end up with boxes and arrows with so much extra detail that the model is no longer useful for the convincing part.
01:58:44 <kzm> But again - I should probably check the literature before making ill-informed comments like this.
01:59:31 <rahikkala> So I'm trying to go through Write Yourself a Scheme in 48 Hours ( http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/parser.html ) and I'm somewhat stumped by exercise 3.3.2 (strings containing escaped quote characters).
01:59:33 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/yzphh2
01:59:42 <kzm> But to do that, I shall need to confront my other prejudice, namely that this particular literature is just a hodge-podge of buzzwords connected with hot air.
02:00:01 <rahikkala> I replaced 'x <- many (noneOf "\"")' with 'x <- many (noneOf "\\" <|> (char '\\' >> char '"'))' but it's not working right...
02:02:32 <Adamant> kzm - a lot of people are skeptical of UML
02:03:08 <Adamant> and there is "compilable UML"
02:03:25 <lightstep> rahikkala, what doesn't it do?
02:03:34 <Adamant> programs that translate a UML diagram into program code.
02:05:59 <rahikkala> lightstep: Well, what it's supposed to do is (combined with the other stuff in parseString) return a string that's contained within quote marks, and contains anything except a backslash followed by something that isn't a quotte mark. It does... something different.
02:06:10 <DebolazX> I just have to say this, some haskell tutorials will go to any lengths to avoid just saying things straight out about what does what. I mean, I read about monads and every bloody tutorial tries to make it sound like a big mysterious thing, coming up with all sort of absurd analogies which doesn't have any ties to reality and then it turns out it's just a simple little thing that could had been explained in 2 lines if just said directly.
02:07:28 <pzpz> DebolazX: Write a tutorial :)
02:08:25 <lightstep> rahikkala, can you give an example? like an input-output pair?
02:08:38 <DebolazX> They might as well just say "here there be dragons".
02:10:32 <rahikkala> lightstep: For instance, it should accept: "abc\"def", and return abc\"def... or abc"def? I'm not actually even sure of that :/
02:11:05 <lightstep> in scheme, "abc\"def" is a string of 7 characters
02:12:37 <joelr1> good morning
02:12:40 <joelr1> dons: ping
02:12:48 <lightstep> and i think your definition makes a 7-character string from this literal
02:15:51 <rahikkala> lightstep: Thing is, if I actually pass that parser that string (that is, run this at the shell: ./hastut \"abc\\\"def\"), it just sees an unexpected end of input, expecting "\\" or "\""
02:18:39 <lightstep> and if you run parseTest parseString in ghci?
02:20:06 <lightstep> (or however parseTest is called in parsec)
02:20:39 <dons> joelr1: yes?
02:21:02 <joelr1> dons: hs-plugins and 6.6
02:21:17 <joelr1> dons: any guidance on that and embedding the compiler/interpreter?
02:23:25 <dons> hs-plugins is not yet there for 6.6. on embedding a haskell evaluator, I'd use the runplugs binary from lambdabot
02:23:28 <dons> > 1+2 --this one
02:23:29 <lambdabot>  3
02:23:39 <dons> since its already sorted out the IO control and safety
02:24:28 <dons> CosmicRay++ ftphs! http://www.haskell.org/pipermail/haskell/2006-December/018861.html
02:24:30 <lambdabot> Title: [Haskell] ANN: ftphs, http://tinyurl.com/tp3fg
02:24:38 <joelr1> dons: what about the compiler?
02:24:59 <joelr1> dons: since 6.6 has the compiler as a library
02:25:21 <AtnNn> rahikkala: use noneOf "\\\"" instead of just "\\"
02:25:27 <dons> oh, that's an interesting further work. Lemmih's had some experience using ghc-pkg for 'eval' (there's an example on the wiki I think)
02:25:31 <dons> but it would be experimental
02:25:43 <dons> (probably 'just works' I'd imagine)
02:25:52 <dons> Lemmih: ping?
02:26:03 <dons> Lemmih: do you have that 'eval' example using ghc-pkg handy?
02:34:43 <kfish> hmm, it appears MisisngH is being unleashed ...
02:36:32 <dons> yeah
02:36:35 <dons> 'bout time!
02:36:59 <dcoutts__> goody
02:37:12 <dcoutts__> more ebuilds :-)
02:46:41 <rahikkala> AtnNn: Wow! Yeah, now that you say it, it's obvious :/... but thanks! It works :)
02:50:31 <kfish> CosmicRay, nice releases mate :-)
02:51:21 <CosmicRay> kfish: thanks ;-)
02:51:50 <CosmicRay> kfish: hopefully by tomorrow I'll have half a dozen or so more announcements as I port all my programs to use the new missingh
02:52:11 <kfish> heh
02:52:32 <kfish> there'll be a CosmicRay Special Edition of HWN this week
02:52:59 <CosmicRay> hehe
02:53:33 <kfish> the headlines will scream "MissingH gets FoundH!!"
02:53:41 <CosmicRay> lol
03:12:39 <CosmicRay> Igloo: do you know why builds of hpodder on some archs would die with: Linking dist/build/hpodder/hpodder ...
03:12:40 <CosmicRay> /usr/bin/ld: cannot find -lHSrts_thr
03:13:28 <joelr1> dons: what's eval using ghc-pkg? does this have something to do with the ghc compiler being a library in 6.6?
03:15:53 <beschmi> joelr1: there is an example at http://members.home.nl/basvandijk/Main.hs and http://www.haskell.org/haskellwiki/?title=GHC/As_a_library
03:16:52 <dons> joelr1: yes, its possible to use ghc-pkg to provide the 'eval' function
03:17:19 <beschmi> but i'm not sure if it works with ghc-6.6, there were some small changes in the api from 6.5 to 6.6
03:17:38 <joelr1> dons: hmm... i'm thinking of compiling in the context of an editor buffer. sort of like with lisp: compile this buffer
03:20:07 <beschmi> you mean like :l file in ghci?
03:22:44 <joelr1> beschmi: yep, except that does not compile
03:23:10 <joelr1> more like load this text representation into ghc and compile it. then use the compiled code going forward.
03:23:43 <joelr1> what hs-plugins allows you to do but with compilation in-memory vs. requiring ghc to be installed and using it to compile
03:23:44 <fasta> Why doesn't let âˆ‘=1 in 5 work in ghci-6.6?
03:24:18 <fasta> I get: <interactive>:1:5: lexical error at character '\136'
03:25:02 <dcoutts__> fasta: I don't think ghci groks utf8 yet
03:25:07 <dcoutts__> though ghc does
03:25:17 <beschmi> ok, you want native code and ghci compiles to bytecode. There is a ticket about adding adding :compile to ghci, then you could just use that or take the code from ghci.
03:25:22 <fasta> Hmm, that kind of kills interactive development.
03:25:43 <joelr1> beschmi: cool!
03:26:31 <joelr1> beschmi: but i suspect that will take a lot to close that ticket :-(
03:28:01 <piggybox> how can I expose a certain module in a package?
03:28:37 <beschmi> http://hackage.haskell.org/trac/ghc/ticket/276 , seems like simonmar is working on it
03:28:39 <lambdabot> Title: #276 (ghci compile option) - GHC - Trac
03:29:11 <joelr1> dons: i would like to use haskell for trading systems development and build a platform akin to erlang. one where you could load strategies into a running dynamic system. and unload them as needed. a lot like lambdabot but with 6.6 and compilation in memory
03:34:03 <joelr1> beschmi: dunno. it's for 6.8
03:36:13 <joelr1> overall, i wish i could do more interactive development with haskell
03:36:19 <joelr1> i guess i'm not alone /fasta/
03:36:56 <fasta> joelr1: There's a work-around for my particular issue.
03:37:12 <fasta> joelr1: but indeed, I like interactive development.
03:37:12 <joelr1> fasta: ok
03:38:10 <mux> dons: hello! have you had time to benchmark the parallel zeta code with added strictness?  I'd like to know if you too experience large variations in the running time of the program
03:43:04 <fasta> joelr1: I was wrong. There's no current work-around.
03:43:23 <fasta> The work-around was for ghc, not ghci, and is obsolete now.
03:44:47 <joelr1> fasta: aha! concurrent
03:44:51 <joelr1> fasta: err, current
03:44:52 <joelr1> ok
03:56:29 <lisppaste2> lray80de pasted "case-, or where - clause?" at http://paste.lisp.org/display/31654
03:56:30 <lray80de> That part of code can be written as "case"-Version, but how? result : doTest where  result = case z of { gfdgs -> fjdskfh} didn't work... :-(
03:58:24 <lray80de> okay, my mistake.... the error is anywhere else. sorry.
04:30:58 <notsmack> i copied Yi's examples/AddBind.hs to ~/.yi/, but it doesn't seem to do anything...
04:34:11 <notsmack> dons: ping?
04:46:07 * SamB wonders why "To have fun" isn't listed as a goal in http://www.dina.dk/~abraham/rants/license.html
04:46:10 <lambdabot> Title: How to choose a free software license.
04:51:28 <pejo> SamB, interestingly if your goal is either "Advance state of the art" or "You want your software to be used" they opt for BSD. ;)
04:52:27 <SamB> well, see, to really advance the state of the art it is best if everyone can use it
04:52:59 <SamB> I suppose the BSD is also best for "fun" projects
04:53:09 <opqdonut> SamB: what would be the "Have Fun" license, then?-)
04:53:22 <opqdonut> m$ shared source?
04:53:33 <SamB> its not fun to deal with licensing issues, after all
04:54:57 <fasta> Is there a Debian package for the library documentation of GHC and the User Guide?
04:57:34 <pejo> fasta, what does ghc6-doc contain?
04:58:26 <fasta> pejo: Everything I need, apparantly.
04:58:49 <fasta> apparently*
05:22:07 <fasta> type Not x = (forall a. x -> a)
05:22:07 <fasta> doubleNegation :: x -> Not (Not x)
05:22:07 <fasta> doubleNegation k pr = pr k
05:22:20 <fasta> How does an application of doubleNegation look like?
05:22:39 <fasta> (from http://haskell.org/haskellwiki/Curry-Howard-Lambek_correspondence)
05:22:41 <lambdabot> Title: Curry-Howard-Lambek correspondence - HaskellWiki
05:41:48 <paolino> hi, I have a big list of values I want to split in sublists.Given is also a smaller list of same type values each of them associated to one of the sublists.The politics is to pick each item of the big one and add it to the sublist of the most "near" associated value. I have a bad attraction to stateful.Anyone can point me to the functional solution ?
05:43:20 <araujo> morning
05:43:38 <kuribas> paolino: Do you use an online translation service?
05:44:39 <paolino> eh
05:44:44 <paolino> my poor head
05:44:57 <paolino> which is off line
05:45:47 <paolino> f::[a]->[a]->[[a]]
05:46:27 <paolino> the length of the output is same as second argument
05:46:53 <opqdonut> ?hoogle groupBy
05:46:53 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
05:46:56 <opqdonut> start with that
05:46:58 <opqdonut> i'd say
05:47:21 <paolino> :)
05:48:47 <fasta> How can I place a rank-2 type signature inline? E.g. something like this:  (undefined::(forall a.Foo a))
05:49:10 <Igloo> CosmicRay: The threaded RTS randomly breaks on most platforms, so they don't build it
05:49:21 <lisppaste2> kfish pasted "Days of the week in Japanese" at http://paste.lisp.org/display/31661
05:50:31 <kfish> hmm, that neither worked in paste.lisp.org nor in ghc6.6 :-/
05:51:41 <paolino> opqdonut: what should the (a->a->Bool) judge ?
05:52:30 <paolino> I can't say two elements are of the same group
05:53:07 <kuribas> paolino: Are the lists ordered?
05:53:14 <dons> mmm, haskell's jumped about 5 places in the PL list, http://www.tiobe.com/tpci.htm
05:53:15 <paolino> no
05:53:16 <lambdabot> Title: TPCI - TIOBE Programming Community Index
05:53:22 <paolino> can't
05:53:28 <dons> ahead of ocaml and up to 0.1% of jobs for the first time :)
05:53:32 <fasta> I found something that's pretty odd
05:53:35 <paolino> the support a distance function only
05:53:49 <paolino> (the values)
05:53:50 <fasta> type Not x = (forall a. x -> a)
05:53:50 <fasta> doubleNegation :: x -> Not (Not x)
05:53:50 <fasta> doubleNegation k pr = pr k
05:53:55 <fasta> With these functions
05:54:06 <fasta> test = doubleNegation 'c'
05:54:12 <fasta> abc = undefined
05:54:19 <fasta> This can be loaded in ghci
05:54:26 <paolino> kuribas: the are unorderable
05:54:37 <fasta> :t test abc
05:54:38 <lambdabot> Not in scope: `test'
05:54:39 <lambdabot>  
05:54:39 <lambdabot> <interactive>:1:5: Not in scope: `abc'
05:54:39 <fasta> That works
05:55:03 <fasta> But when test = doubleNegation 'c' undefined
05:55:10 <fasta> it doesn't compile
05:55:16 <fasta> or load or whatever
05:55:41 <fasta> =>GHC is not referentially transparant in this case.
05:56:52 <fasta> Is this unavoidable or something or just a bug?
05:57:22 <dons> fasta: I don't understand your problem. does the code not compile? what error
05:57:27 <dons> ?paste use the paste system
05:57:28 <lambdabot> http://paste.lisp.org/new/haskell
05:58:14 <notsmack> dons: hey, is my understanding right that yi should be evaluating scripts in ~/.yi?
05:58:22 <paolino> :t repeat
05:58:24 <lambdabot> forall a. a -> [a]
05:58:27 <fasta> dons: I don't really see what you don't understand. Just put the above code in a file and follow the above instructions.
05:58:43 <dons> and what happens? it doesn't compile? there's a type error?
05:58:43 <kuribas> paolino: You can try to find for each number in the small list the range of values that belong to that list.
05:58:52 <fasta> Cannot match a monotype with `Not Char'
05:58:52 <fasta>       Expected type: a -> t
05:58:52 <fasta>       Inferred type: Not Char -> a1
05:58:52 <fasta>     In the expression: doubleNegation 'c' abc
05:58:52 <fasta>     In the definition of `test': test = doubleNegation 'c' abc
05:59:04 <dons> ok, so there's a type error. what's the problem?
05:59:27 <fasta> dons: the problem is that I can do that application in ghci in the former case
05:59:34 <dons> ah, you mean, if you manually inline the body of abc as undefined, it fails?
05:59:36 <fasta> dons: I can do :t test abc
05:59:41 <fasta> dons: right
05:59:48 <fasta> dons: no
06:00:15 <dons> monomorphism restriction kicking in? or is it ghci's defauting?
06:00:22 <dons> hint: what happens if you compile the code
06:00:34 <fasta> dons: If test is a function(i.e. does not have the argument abc supplied), then I can do :t test abc
06:01:01 <fasta> dons: If test already has abc as an argument in the source file, then it doesn't compile
06:01:43 <dons> did you try in ghc?
06:01:59 <fasta> dons: I did now, and it does compile.
06:02:16 <fasta> I also think it's a rather bad idea to have ghc and ghci do different things.
06:02:19 <dons> so its probably an artifact of sitting in the top level do-block in ghci?
06:02:42 <dons> please submit a patch then :)
06:04:07 <jeroeng> Hello dblhelix
06:05:13 <mux> 14:39 < lazyat0m> KimmoKe: your_string.split(" ").map { |s| s.capitalize  }.join(" ")
06:05:16 <mux> 14:40 < KimmoKe> elegant
06:05:24 <mux> statements like this one make me want ot paste haskell code :)
06:05:38 <xerox> map toUpper ?
06:05:40 <mauke> except haskell doesn't have split
06:05:46 <opqdonut> mauke: words
06:05:46 <dblhelix> jeroeng: hai
06:05:52 <fasta> dons: I don't think any patches I will come up with now will be accepted, since I am not good enough yet.
06:05:52 <mauke> opqdonut: that's different
06:05:59 <mux> xerox: no, it's for capitalizing the first letter only
06:06:01 <opqdonut> mauke: yeah, but not in this case
06:06:08 <xerox> mux: ah.
06:06:09 <mux> let ucfirst = \x -> toUpper (head x) : tail x
06:06:11 <paolino> kuribas : I have a list [(a,b)] and a value v of type a, I want to find the tuple of the list which satisfy minimumBy of v and its first element and , "substitute" the tuple in the list with [(a,b++[v])]
06:06:13 <mux> let capitalize = unwords . map ucfirst . words
06:06:16 <jeroeng> dblhelix: Did you think about 'cartetische' :) ?
06:06:18 <dblhelix> jeroeng: I heard from bastiaan that you're enjoying gont :)
06:06:22 <mux> still much more elegant in my book :)
06:07:07 <dons> mux, nice.
06:07:53 <jeroeng> dblhelix: I sure do, it's a great course. I'm not bugging him too much, am I?
06:07:53 <dblhelix> jeroeng: can you point it out, again? where on the wiki do I need to make a change?
06:07:59 <xerox> > unwords . map (ap ((:) . toUpper . head) tail) . words $ "foo bar baz"
06:08:01 <lambdabot>  "Foo Bar Baz"
06:08:04 <xerox> ;)
06:08:07 <mux> point-free madness :)
06:08:22 <xerox> prejudice :P
06:08:27 <mux> heheh
06:08:31 <dblhelix> jeroeng: he does not complain about it, anyway, so I guess, you're not
06:09:38 <kuribas> paolino: If you want an efficient solution I would use an Array.
06:09:52 <jeroeng> dblhelix: Good :) It's the first thing on the errata I contributed
06:10:13 <dblhelix> jeroeng: ah, it was already an erratum? :S
06:10:17 <dblhelix> sloppy...
06:11:06 <paolino> kuribas , I'm still looking for a solution, whatever :(
06:11:31 <jeroeng> dblhelix: Are you already working on the updated reader?
06:12:02 <kuribas> paolino: An easy solution would be something like "map (\v -> filter (inRange v) largeList) smallList"
06:12:31 <dblhelix> jereong: fixed!
06:12:57 <dblhelix> jeroeng: I am, but not too fanatic... it'll not be used this year...
06:12:58 <jeroeng> dblhelix: My name is saved :>
06:13:47 <jeroeng> dblhelix: Could I read it? I've got too much spare time, or un-spare time unspent
06:14:15 <dblhelix> jeroeng: as soon, as I have some chapters finished, I'll send them, okay?
06:14:52 <jeroeng> dblhelix: Alright. Did you notice that I subscribed to the AFP-course?
06:15:14 <dblhelix> jeroeng: bastiaan mentioned it
06:15:25 <paolino> kuribas I can't write an inRange function, not a clever one
06:15:38 <dblhelix> jeroeng: now all you have to do is enroll for the master program ST :)
06:16:00 <paolino> kuribas: values space is eventually huge and point sparse
06:16:11 <paolino> points
06:16:15 <jeroeng> dblhelix: It'll al least two more years until I can
06:16:25 <kuribas> paolino: is this a homework exersize, or a real-world problem?
06:16:36 <paolino> real -world
06:17:36 <jeroeng> dblhelix: I finally got myself registered as a CS-student now. Figured I was going to do all the good courses anyway, might as well do the others too
06:17:42 <mux> do you guys also think dynamic typing is the devil?
06:18:12 <dblhelix> jeroeng: and are you still enlisted as a CKI student too?
06:18:19 <dblhelix> /s/enlisted/listed
06:18:21 <jeroeng> Yup
06:18:56 <dblhelix> and maths?
06:19:12 <jeroeng> That too
06:19:31 <dblhelix> pfff... and still you complain about spare time...?
06:19:37 <paolino> mux , it's been a good way not to think and learn haskell for me
06:19:53 <jeroeng> Not all that good at managing time :-)
06:20:30 <retybok> i'm trying to print out nicely a matrix (two dimensional Data.Array), but I can't manage to do it... Would someone kindly help me out?
06:21:19 <retybok> matrix: (Ix a, Num d) => Array (a, a) d
06:21:20 <Saizan> what do you mean by nicely?
06:21:33 <retybok> for instance
06:21:35 <retybok> 1 2 3
06:21:37 <retybok> 2 3 4
06:21:39 <retybok> 0 0 1
06:21:50 <dons> :t Data.Array.elems
06:21:51 <lambdabot> forall e i. (Ix i) => Array i e -> [e]
06:21:54 <retybok> it's very basic i know
06:22:17 <retybok> dons: that's nice but how do I use that for 2D?
06:22:19 <Saizan> i've written that yesterday, without spaces
06:22:25 <Saizan> ?paste
06:22:26 <lambdabot> http://paste.lisp.org/new/haskell
06:22:32 <retybok> Saizan: thanks a lot
06:23:05 <lisppaste2> Saizan pasted "print matrix" at http://paste.lisp.org/display/31665
06:23:32 <jeroeng> dblhelix: Do you know where one can apply as student-assistent at FP?
06:24:27 <Saizan> retybok: you should edit the lambda if you need spaces
06:24:42 <Saizan> also, i don't know if it's efficient or so
06:24:49 <retybok> Saizan: it shouldn't be too hard to do
06:24:58 <dons> Saizan++
06:25:00 <retybok> thanks a lot
06:25:06 <Saizan> np
06:25:47 <Saizan> ++ :O
06:27:10 <dblhelix> jeroeng: from time to time, students are asked to apply via our usenet groups... but I guess you could also just send an e-mail to lennart herlaar
06:28:04 <CosmicRay> Igloo: ouch
06:28:12 <CosmicRay> Igloo: is there a way I can detect that at build time?
06:28:19 <jeroeng> dblhelix: So I should just wait for a request on the newsgroups?
06:28:33 <CosmicRay> Igloo: and what does the lack of the threaded rts imply for my program?  that forkIO would raise an exception?
06:28:46 <dblhelix> jeroeng: yep
06:29:57 <jeroeng> dblhelix: Will do then :-)
06:31:49 <kuribas> paolino: You can use a state monad with the array.
06:32:01 <Saizan> retybok, now that i read it again it works only on square matrix, but it's very easy to fix that
06:32:50 <paolino> I suppose I should
06:34:10 <retybok> Saizan: I just managed to understand how it works :)
06:35:10 <Saizan> retybok: ok :)
06:43:15 <jeroeng> dblhelix: What are you researching nowadays?
06:46:01 <dblhelix> jeroeng: mostly ... sharing analysis and uniqueness typing, and the relation between these
06:46:20 <dblhelix> /s/relation/relationship
06:46:33 <lray80de> How can I get something like [...(String1, String2), (String1, String3), (String2, String3)...] into [(String1,[String2, String3]),(String2,[String3]),...]?
06:46:43 <jeroeng> Uniqueness typing is what Clean does, isn't it?
06:46:50 <dblhelix> jeroeng: it is
06:47:25 <earthy> lray80de: sort, group, unzip, concat
06:47:30 <Igloo> CosmicRay: It won't raise an exception, it's just that threads blocking on foreign calls will block the whole application
06:47:51 <lray80de> sounds great, thnx.
06:48:12 <LoganCapaldo> @djinn [(a,a)] -> [(a,[a])]
06:48:13 <lambdabot> -- f cannot be realized.
06:51:04 <earthy> @type map unzip . groupBy ((. fst) . (==) . fst) . sortBy ((. fst) . compare . fst)
06:51:05 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [([a], [b])]
06:51:15 <earthy> that should get you *almost* there, lray80de
06:55:32 <CosmicRay> Igloo: hmm.  but the haskell IO stuff is already asynchronous, right?
06:55:39 <CosmicRay> Igloo: so is it possible that it won't make any difference?
06:55:46 <CosmicRay> Igloo: and what about forkOS?
06:56:14 <Igloo> It's possible it won't make any difference, yes
06:56:26 <Igloo> I don't think there's a good page explaining this sort of stuff, unfortunately
06:56:39 <LoganCapaldo> Haskell IO is asynch by default?
06:57:12 <CosmicRay> LoganCapaldo: my understanding is that it is, internally, though it doesn't appear that way externally
06:57:43 <LoganCapaldo> well it appeared that way externally once when I tried to write a "type in your name program" :)
06:57:58 <CosmicRay> LoganCapaldo: that was probably due to laziness instead
06:57:58 <LoganCapaldo> It didn't print the prompt until after I typed in my name
06:58:06 <CosmicRay> or buffer flushing
06:58:09 <CosmicRay> @paste
06:58:09 <lambdabot> http://paste.lisp.org/new/haskell
06:58:14 <LoganCapaldo> it was buffer flushing
06:58:21 <CosmicRay> LoganCapaldo: if you paste your program at that URL, I could look at it for you
06:58:34 <LoganCapaldo> No its ok, its been fixed :)
06:58:47 <LoganCapaldo> hFlush ftw
06:58:52 <CosmicRay> yup
07:19:26 <lray80de> how to get duplicates out of a List? Means: [1,1,1,2,4,3,2] -> [1,2,3,4] ?
07:19:39 <dons> > nub [1,1,1,2,4,3,2
07:19:39 <lambdabot>  Parse error
07:19:40 <integral> @type nub
07:19:41 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:19:42 <dons> > nub [1,1,1,2,4,3,2]
07:19:43 <lray80de> or even [1,2,4,3]
07:19:45 <lambdabot>  [1,2,4,3]
07:19:52 <lray80de> thnx.
07:20:00 <dons> > sort.nub $ [1,1,1,2,4,3,2]
07:20:01 <lambdabot>  [1,2,3,4]
07:20:33 <dons> > M.elems . M.fromList (zip [1..] [1,1,1,2,4,3,2])
07:20:34 <lambdabot>    Expecting a function type, but found `Data.Map.Map k a'
07:20:35 <lambdabot>    Expected t...
07:21:15 <LoganCapaldo> > ((map head) . group . sort) [1,1,1,2,4,3,2]
07:21:16 <lambdabot>  [1,2,3,4]
07:21:36 <dons> > M.fromList (zip [1..] [1,1,1,2,4,3,2])
07:21:37 <lambdabot>  {1:=1,2:=1,3:=1,4:=2,5:=4,6:=3,7:=2}
07:21:58 <LoganCapaldo> nub is obviously a redundant function :)
07:22:25 <dons> > M.elems ( M.fromList (zip [1,1,1,2,4,3,2] (repeat 1)))
07:22:26 <lambdabot>  [1,1,1,1]
07:23:13 <dons> > let s = [1,1,1,2,4,3,2] in M.elems (M.fromList (zip s s))
07:23:14 <lambdabot>  [1,2,3,4]
07:23:18 <dons> ?time
07:23:20 <dons> ?time dons
07:23:25 <lambdabot> Local time for dons is Sat Dec  9 02:16:57 2006
07:23:27 * dons `ap` sleep now
07:25:00 <ni_idea> hola
07:28:12 <ni_idea> tengo que hacer un trabajo relacionado con haskell, tengo un par de dudas...en haskell como puedo hacer que un valor no cambie, es decir lo equivalente a una constante en c++, visual basic etc
07:30:46 <dons> ni_idea: try #haskell.es
07:31:00 <dons> ?babel es en tengo que hacer un trabajo relacionado con haskell, tengo un par de dudas...en haskell como puedo hacer que un valor no cambie, es decir lo equivalente a una constante en c++, visual basic etc
07:31:01 <lambdabot>  I must make a work related to haskell, I have a pair of doubts... in haskell like I can cause that a value does not change, is to say the equivalent thing to a constant in c++, line of vision BASIC
07:31:01 <lambdabot> etc
07:31:31 <LoganCapaldo> lol
07:31:35 <LoganCapaldo> the irony
07:31:38 <ni_idea> sorry se me olvido el .es ^^
07:31:53 <dons> ?babel en es ni_idea Visit the #haskell.es channel for spanish speakers :)
07:31:54 <lambdabot>  visita del ni_idea # canal de haskell.es para los altavoces españoles:)
07:32:00 <Pegazus> ni_idea: you can't...
07:32:18 <Pegazus> sorry, i mean it's always like that...
07:32:21 <LoganCapaldo> ?babel everything is a constant in haskell
07:32:21 <lambdabot> babel module failed: IRCRaised Error: Language everything not supported
07:32:36 <LoganCapaldo> ?babel en es everything is a constant in haskell
07:32:37 <lambdabot>  toda es una constante en haskell
07:32:44 <dons> > let x = 1 ; y = x in x + y
07:32:46 <lambdabot>  2
07:32:50 <Saizan> peano-like pattern matching doesn't work with (-) eh?
07:33:21 <ni_idea> ok, thanks
07:33:21 <dons> Saizan: you mean k/numeric patterns?
07:33:30 <dons> > f (-1) = 1 in f 2
07:33:31 <lambdabot>  Parse error
07:33:48 <Saizan> i mean something like let (n-1) = 3 in n
07:33:49 <glguy> Is there a haddock page for parsec?
07:33:59 <dons> Saizan: ah, you want n-k patterns :)
07:34:08 <Saizan> > let (n-1) = 3 in n
07:34:09 <lambdabot>  Parse error in pattern
07:34:12 <LoganCapaldo> ?babel en en lambdabot is awesome
07:34:13 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
07:34:15 <dons> Saizan: there's no such thing
07:34:18 <Saizan> ok
07:34:37 <dons> ?babel en es lambdabot is awesome! watch its magic powers!
07:34:38 <lambdabot>  ¡el lambdabot es impresionante! ¡mire sus energías mágicas!
07:34:45 <dons> damn straight
07:35:22 <LoganCapaldo> #haskell.*, the only channels with universal translators :)
07:36:04 <dons> that was I think the first plugin I wrote for the bot? one of the first anyway
07:37:04 <LoganCapaldo> Next step ?babel <target language> <text> and use probablistic filtering to determine the source language
07:37:19 <LoganCapaldo> bwahahahahaa
07:38:20 <notsmack> LoganCapaldo: trigrams are pretty good at that
07:38:36 * LoganCapaldo googles trigrams
07:39:09 <LoganCapaldo> hmmm k
07:39:38 <LoganCapaldo> I was just gonna bayes it and use the source target form as the training mode
07:39:44 <LoganCapaldo> But I'm lazy :)
07:40:27 <notsmack> also works
07:48:29 <br1> Why does haskell copy the hideous math practice of naming the variables with single letters?
07:48:40 <integral> The language doesn't, try blaming the programmers.
07:49:03 <integral> My code at the minute has lovely long identifiers including "leftInferMul"
07:49:48 <br1> :)
07:50:14 <br1> maybe it has to do with lack of good editors. emacs, for example, takes var1-var2 as a single token for autocompletition
07:51:23 <LoganCapaldo> that's dumb
07:51:28 <Binkley> br1: it's an excellent practice in math, as well as in certain small easy-to-understand haskell functions
07:51:36 <LoganCapaldo> why would it do that?
07:51:40 <Binkley> if people use it inappropriately in haskell, then as integral said, blame them :-)
07:51:49 * vincenz blames Binkley 
07:51:53 * Binkley blames Canada
07:52:03 * LoganCapaldo blames @pl
07:52:03 * Canada blames the US
07:52:23 <br1> HAHA
07:52:24 <dons> often single letter names are clearer: when p s          =  if p then s else return ()
07:52:31 <LoganCapaldo> Forget single letter variables, bring on the no letter variables
07:52:38 <dons> versus, when predicate something = if predicate then something else return ()
07:52:51 <vincenz> dons: I disagree, because that practice requires delving into code to understand a function
07:53:07 <br1> LoganCapaldo: emacs' behavior is fine in scheme.
07:53:09 <dons> and, we have good lexical scoping. so you don't have to dive
07:53:21 <Binkley> LoganCapaldo: obviously you want to be coding in the whitespace programming language
07:53:26 <dons> of course, you're insane if you give top level, or exported symbols, single letter names..
07:53:26 <integral> Plus if your functions are really abstract, you can't have very descriptive names
07:53:45 <integral> dons: Like the horrible, horrible Q monad
07:53:46 <LoganCapaldo> br1: Yeah but you know I'm pretty sure emacs is perfectly capable of having different modes for different programming languages
07:54:22 <Binkley> there's a Q monad?
07:54:27 <dons> I blame parametric polymorphism
07:54:29 <integral> Binkley: template haskell
07:54:31 <LoganCapaldo> ?where haskell-mode
07:54:31 <lambdabot> http://www.haskell.org/haskell-mode/
07:54:57 <dons> when everything parameterised, and bound locally, long names don't make sense
07:55:04 <Binkley> in Soviet Russia, parametric polymorphism blames *you*
07:55:12 <dons> that's true.
07:55:47 <LoganCapaldo> in Soviet Russia parametric polymorphism blames *You a*
07:56:04 <Binkley> in France parametric polymorphism blames 'you
07:56:05 * vincenz feels monadic
07:56:18 * LoganCapaldo applauds Binkley
07:56:19 <Binkley> . /whois monadic
07:56:21 <LoganCapaldo> brilliant!
07:56:45 <Binkley> if you're going to feel yourself, at least go to #haskell-blah
07:57:01 <monadic> Another Binkley-ism?
07:57:45 <dons> so when I wake up I expect an STM-based, smp ruby-on-rails killer app from someone in this channel. don't let me down!
07:57:48 * dons sleeps
07:57:49 <dons> night!
07:57:51 <earthy> dons has interesting sleep patters. ;)
07:57:53 <fasta> How can free variables enter the type-environment?
07:58:05 <Binkley> a ruby-on-rails killer app in Haskell?
07:58:11 <Binkley> oh, I see
07:58:16 <Binkley> something that will kill Ruby-on-Rails?
07:58:18 <monadic> @localtime dons
07:58:19 <lambdabot> Local time for dons is Sat Dec  9 02:51:54 2006
07:58:29 <Binkley> fasta: which type environment?
07:58:57 * monadic registered his new nick :)
07:59:47 <astrolabe> @localtime dons
07:59:49 <lambdabot> Local time for dons is Sat Dec  9 02:53:23 2006
08:00:07 <astrolabe> oh. sorry.
08:00:34 <astrolabe> maybe some kind of anti-Ruby virus?
08:00:56 <Taraxis> May I ask you fine fellows a question?  I am having an issue installing cabal on windows.
08:01:00 <fasta> Binkley: E.g. in let v = runST (newVar True) in runST(readVar v), where readVar v::STRef s Bool. s is free there.
08:02:55 <Binkley> fasta: I don't understand your question, can you rephrase it?
08:03:27 <fasta> Binkley: well, I don't really know an efficient way to decide whether some variable may be generalized or not.
08:03:56 <Binkley> fasta: do you mean "decide whether the type of some variable may be generalized"?
08:04:21 <Pastorn> xinming: there?
08:04:40 <Taraxis> setup configure generates an error "Cannot find compiler for ghc" but it IS in my path.  Anyone have any clue?
08:04:54 <fasta> Binkley: I am having difficulties with rank-n types, and I guess that's the root of the problem, yes.
08:06:19 <Igloo> Taraxis: You can tell it where to find it with a flag, but I don't know why it isn't finding it itself
08:06:47 <Saizan> do you know if there's a library to process image files?
08:07:11 <fasta> Binkley: ?
08:07:35 * monadic stops `bind`ing Binkley 
08:08:57 <Binkley> fasta: when you say difficulties, do you mean you're having difficulties writing code that uses them or writing code that implements them? sorry, I still don't quite see what you're asking
08:11:58 <fasta> Binkley: I want to know in what ways a free type variable be put into the type environment. E.g. in runST::forall.a.(forall s.ST s a)->a, when s is used in the a type, it's free.
08:13:23 <Binkley> fasta: when s is used in *which* type?
08:13:27 <Binkley> s looks bound to me there
08:13:42 <fasta> Binkley: when s is used in the a type
08:15:03 <Binkley> what do you mean by "the a type"?
08:15:14 <Binkley> the type "a" within that type is just a type variable
08:15:17 <Binkley> it doesn't "use" anything
08:15:40 <fasta> Binkley: which can be instantiated to something that has s as a part of it.
08:16:16 <fasta> Binkley: a could be (Int, s)
08:16:17 <emu> in slime, emacs completes var1-var2 by word
08:16:48 <monadic> in USSR emacs completes you by word
08:16:53 <Pastorn> i have a list of lists
08:17:35 <emu> in soviet russia, monad transform YOU
08:17:42 <Pastorn> how do i do "and [ map f x | x <- xs ]" without the list comprehension?
08:17:48 <lome> :-)
08:18:01 <Binkley> fasta: sure. if you instantiated the type of runST with a type that contained a free type variable s, then you would get a type containing s
08:18:02 <monadic> does that even type?
08:18:08 <Binkley> and when I say "you" I mean "the compiler"
08:18:22 <monadic> @type \f xs -> and [map f x | x <- xs]
08:18:22 <Binkley> since types are inferred here
08:18:23 <lambdabot>   Couldn't match `Bool' against `[b]'
08:18:23 <lambdabot>    Expected type: Bool
08:18:26 <monadic> didn't think so
08:18:32 <emu> @type and
08:18:33 <lambdabot> [Bool] -> Bool
08:18:38 <Binkley> but somehow I suspect that still doesn't answer your question
08:19:04 <Binkley> Pastorn: aren't you just looking for and (map f xs)
08:19:05 <Binkley> ?#
08:19:06 <lambdabot> Maybe you meant: . v
08:19:06 <lome> and $ map (map f) xs
08:19:17 <monadic> lome: which doesn't type
08:19:29 <Pastorn> lome: just that?
08:19:45 <Binkley> > [map square x | x <- [1,2,3]]
08:19:46 <lambdabot>  Not in scope: `square'
08:19:51 <lome> why doesnt?
08:20:05 <Binkley> > [map (\ x -> x*x) x | x <- [1,2,3]]
08:20:06 <lambdabot>  add an instance declaration for (Num [a])
08:20:06 <lambdabot>   In the list element: 3
08:20:06 <lambdabot>   In...
08:20:25 <LoganCapaldo> @type and $ map (map f) xs
08:20:26 <lambdabot> Not in scope: `f'
08:20:26 <lambdabot>  
08:20:26 <lambdabot> <interactive>:1:18: Not in scope: `xs'
08:20:35 <monadic> Binkley: list of list
08:20:37 <monadic> lome: no
08:20:41 <LoganCapaldo> lambdabot: guess!
08:20:53 <Binkley> somehow I think I'm missing something
08:20:53 <monadic> I told you
08:20:57 <lome> monadic: why?
08:21:07 <monadic> lome: map (map f) retruns [[a]]
08:21:11 <monadic> no matter which a
08:21:14 <monadic> [a] != Bool
08:21:27 <lome> monadic: ok
08:22:02 <scriptdevil> how does haskell do i/o without side effects?
08:22:07 <Pastorn> @pl and [map (\x -> True) x | x <- [[1,2,3],[0,2,5]] ]
08:22:07 <lambdabot> and [map (const True) x | x <- [[1, 2, 3], [0, 2, 5]]]
08:22:07 <lome> [map f x | x <- xs] also returns [[a]]
08:22:09 <monadic> scriptdevil: monadically
08:22:11 <fasta> Binkley: I would like to see some examples of free type variables entering the type environment. That's all.
08:22:18 <monadic> fasta: she left
08:22:25 <LoganCapaldo> scriptdevil: it doesn't. IO is by definition a side-effect
08:22:43 <scriptdevil> LoganCapaldo: then how do you term input and output?
08:22:51 <yip> does the STM of ghc 6.6 support multiple cpus?
08:22:52 <monadic> scriptdevil: monadically
08:22:55 * monadic feels like he's repeating himself
08:23:00 <Lemmih> yip: Yes.
08:23:01 <LoganCapaldo> Your question would be better phrased as "How does haskell do IO w/o breaking referentially transparencency"
08:23:08 <LoganCapaldo> ack
08:23:15 <LoganCapaldo> I'm like slurring my typing
08:23:17 <monadic> LoganCapaldo: no, his question should be
08:23:25 <monadic> "How does haskell do IO w/o breaking purity"
08:23:35 <LoganCapaldo> k
08:23:43 <LoganCapaldo> The answer is still monadically :)
08:23:44 * monadic points at his name
08:23:47 <yip> Lemmih: cool, are there any improvements of recent ghc snapshots over 6.6?
08:24:01 <scriptdevil> monadic: that is not a problem.. i am not learning haskell yet.. so monads make no sense to me. i just read the intro and got this doubt.
08:24:20 <dons> scriptdevil: http://haskell.org/haskellwiki/IO_inside
08:24:21 <lambdabot> Title: IO inside - HaskellWiki
08:24:21 <Lemmih> yip: I don't think so. Nothing really imporant at least.
08:24:28 <monadic> dons: GO TO BED!
08:24:33 <Lemmih> *important
08:24:33 <LoganCapaldo> dons: Shh. You are asleep
08:24:45 <scriptdevil> where exactly do i start learning haskell?
08:24:45 * dons goes to bed
08:24:51 <monadic> @where yaht
08:24:51 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
08:24:51 <int-e> maybe lambdabot has taken over dons.
08:24:53 <kyevan> Wow.
08:24:56 <monadic> scriptdevil: that is a great intro
08:25:03 <kyevan> Types are a lot less confuseing than they look at first
08:25:20 <savanni> But getting the hang of them could take a while.
08:25:22 <savanni> Hi, all.
08:25:25 <yip> Lemmih: ok. with 6.6 is it possible for two c functions to run concurrently on a single cpu(in seperate os threads)?
08:25:32 * lray80de tst
08:25:47 <scriptdevil> monadic: thanks.. the last time i was putoff since i tried haskell as my first functional lang. now i am quite ok with scheme and cl. so i guess things will be better
08:25:48 <Lemmih> yip: I believe so, yes.
08:26:05 <monadic> scriptdevil: cool, if you have any questions, feel free to ask here :)
08:26:24 <yip> Lemmih: sweet. this will happen automatically if i use forkIO?
08:27:30 <Lemmih> yip: You probably have to run your program with +RTS -Nx -RTS.
08:28:12 <scriptdevil> monadic: i sure will
08:28:14 <yip> Lemmih: hm.... will that guarantee that the c functions are run concurrently?
08:28:32 <Lemmih> yip: I don't know. You could test it.
08:29:16 <yip> hm... i guess i could... thanks man
08:29:22 <int-e> yip: I'd have my doubts about forkIO. forkOS should work.
08:29:36 <int-e> yip: but I haven't tested it either.
08:30:10 <yip> why does ghc use lightweight threads anyway, instead of just using os threads?
08:30:22 <int-e> because they're light weight.
08:30:36 <int-e> they have cheaper context switches (no need to bother the kernel)
08:31:17 <yip> but what is the advantage of many lightweight threads over a single thread?
08:31:42 <Philippa> conceptual breakdown. It's nice for IO when it works, too
08:31:51 <Philippa> some tasks naturally break down into lightweight processes
08:31:55 <int-e> you can have blocking IO operations in one of the threads, and another will continue to run
08:32:12 <int-e> think of it as a high level abstraction for select() if you like.
08:32:48 <norpan> aren't all lightweight threads blocked on IO?
08:32:56 <int-e> no.
08:33:12 <norpan> how do you make them not block without relying on the os
08:34:08 <int-e> a) the (ghc) RTS opens all fds non-blocking. (that's not unproblematic btw). b) the scheduler uses select() to find a thread that can continue to run.
08:34:33 <norpan> sounds possible i suppose
08:34:38 <int-e> if no IO is pending, the kernel isn't involved at all.
08:34:53 <norpan> well, you still call select
08:34:59 <kyevan> hmm... Why do functions with multiple arguments have such weird types?
08:35:18 <yip> so lightweight threads are only good for network programming?
08:35:24 <Lemmih> kyevan: They do?
08:35:30 <int-e> kyevan: weird? you mean  a -> b -> c  instead of something like  (a,b) -> c ?
08:35:35 <norpan> kyevan: it's called currying
08:36:05 <Lemmih> yip: Or any other kind of programming where you want concurrency.
08:36:13 <kyevan> int-e: Yeh.
08:36:24 <scriptdevil> currying means passing one value at a time to a function
08:36:26 <dons> :t Data.Generics.Twins.gfoldlAccum -- like this??
08:36:32 <lambdabot> forall d (c :: * -> *) a. (Data.Generics.Basics.Data d) => (forall d1 r. (Data.Generics.Basics.Data d1) => a -> c (d1 -> r) -> d1 -> (a, c r)) -> (forall g. a -> g -> (a, c g)) -> a -> d -> (a, c d)
08:36:35 * dons really goes to sleep  
08:36:38 <int-e> kyevan: these two types are isomorphic (they describe the same functions really) and the first version is more convenient.
08:37:07 * Lemmih is starting to suspect that dons' is addicted to IRC.
08:37:21 <kyevan> Do we have to stage an intervention?
08:37:23 * ndm has seen "dons goes to sleep" several times today so far...
08:37:35 <kyevan> int-e: I think it's confuseing, personally.
08:37:39 <int-e> kyevan: you can partially apply the first version: if  f :: a -> b -> c   and x :: a,  then  (f x) :: b -> c  is a function that you can use like any other function of that type
08:37:44 <kyevan> I'll get used to it eventually, I'm sure...
08:37:55 <scriptdevil> kyevan: you need not curry your code.
08:38:02 <int-e> kyevan: that trick is much uglier with (a,b) -> c. you'd have to write something like  \y -> f (x, y).
08:38:06 <scriptdevil> you can for beautifying it though
08:39:17 <int-e> kyevan: I'm sure you'll get used to it. :)
08:39:26 <earthy> whoa. you don't read the haskell mailinglists for a day and there's a zillion announcements
08:40:23 <yip> Lemmih: well, the only problems i am familiar with that are solved well with concurrency are (1) computations that require performance and can be parallelized to run on seperate cpus (2) programs that need to do I/O in parallel with other I/O or computations
08:40:43 <yip> Lemmih: lightweight threads don't seem to help with the first, and with the second only seem to help with network related I/O
08:41:47 <Lemmih> yip: You can flick a switch and make your lightweight threads run on N cpus.
08:42:13 <yip> Lemmih: hm....... but then they are not lightweight threads anymore :)
08:42:14 <int-e> kyevan: oh,  a -> b -> c  means  a -> (b -> c)  btw, it's a function that takes an argument of type a (the first argument) and returns a function that takes an argument of type b (the second argument) and returns a result of type c.
08:42:32 <Lemmih> yip: They are. They're just distributed over several OS level threads.
08:42:42 <yip> i see
08:43:15 <emu> hmm submit haskell code to this: http://newyork.craigslist.org/mnh/eng/244632325.html
08:43:15 <scriptdevil> int-e: kyevan for currying, u can read the ora ocaml book.
08:43:15 <Pastorn> @hoogle lines
08:43:16 <lambdabot> Title: Web Developer - Does this sound like you?
08:43:17 <lambdabot> Prelude.lines :: String -> [String]
08:43:17 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
08:43:17 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
08:43:19 <scriptdevil> it is clear in it
08:43:28 <Pastorn> @source Prelude
08:43:29 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
08:44:26 <scriptdevil> kyevan: http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora015.html#toc11
08:44:29 <lambdabot> Title: Functional core of Objective CAML, http://tinyurl.com/y3vv8e
08:44:40 <Pastorn> wtf?
08:44:47 <Pastorn> lines isn't there!
08:45:00 <Pastorn> NO code is there :(
08:45:05 <Lemmih> @index lines
08:45:06 <lambdabot> Data.List, Prelude
08:45:10 <Pastorn> ah
08:45:10 <emu> oh its in ghc.base or seomthing
08:45:11 <Lemmih> @source Data.List
08:45:11 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
08:45:22 <Pastorn> danke :D
08:45:26 <emu> the definition of "lines" is in the Report too
08:48:23 <lray80de> how can I delete all occurences out of a list? "delete" only deletes the first occurence...
08:48:32 <emu> filter
08:48:50 <xerox> > [1,2,3] \\ [2]
08:48:52 <emu> though probably, filter (/= x)
08:48:54 <lambdabot>  [1,3]
08:49:02 <emu> that's set-difference
08:49:19 <scriptdevil> why not map delete??
08:49:29 <scriptdevil> i men i just read ab that in yaht
08:49:29 <emu> because delete already operates on a list
08:49:35 <xerox> > [1,2,3,2,4,2,5] \\ [2]
08:49:37 <lambdabot>  [1,3,2,4,2,5]
08:49:37 <scriptdevil> ok.
08:49:39 <emu> @type delete
08:49:40 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
08:49:41 <emu> @type map
08:49:42 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
08:49:57 <emu> xerox: see, it expects sets ;)
08:50:04 <scriptdevil> :o
08:50:30 <xerox> > ((=<<) . delete) 2 [1,2,3,2,4,2,5]
08:50:31 <lambdabot>  add an instance declaration for (Num [a])
08:50:32 <lambdabot>   In the list element: 5
08:50:35 <xerox> gnarf.
08:50:46 <emu> that you'd have to map
08:51:21 <emu> @type ((=<<) . delete)
08:51:21 <lray80de> thnx. :-)
08:51:23 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [a]
08:52:42 <jeroeng> @type (\x xs-> (iterate (List.delete x) xs)!! length xs)
08:52:43 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
08:53:24 <emu> hehe
08:53:43 <jeroeng> If you like it nasty
08:53:58 <emu> @pl (\x xs-> (iterate (List.delete x) xs)!! length xs)
08:53:59 <lambdabot> (`ap` length) . ((!!) .) . iterate . (List .) . delete
08:54:03 <emu> that's nasty
08:54:20 <emu> ha, it didn't get List.delete right
08:54:35 <emu> @pl (\x xs-> (iterate (delete x) xs)!! length xs)
08:54:36 <lambdabot> (`ap` length) . ((!!) .) . iterate . delete
08:55:05 <jeroeng> `ap` = $ ?
08:55:12 <emu> @type ap
08:55:13 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
08:55:39 <kyevan> what does null do?
08:55:46 <jlouis> ?null
08:55:46 <lambdabot> Maybe you meant: tell url
08:55:50 <jlouis> ?type null
08:55:52 <lambdabot> forall a. [a] -> Bool
08:56:06 <jlouis> > null []
08:56:07 <emu> kyevan: True iff list is empty
08:56:07 <lambdabot>  True
08:56:12 <jlouis> > null [1]
08:56:13 <lambdabot>  False
08:57:05 <kyevan> Oh. So it checks for the equivilent of Scheme's empty list?
08:57:07 <emu> > 0 > sum [1..]
08:57:11 <lambdabot> Terminated
08:57:17 <emu> kyevan: its the same thing as "null?" in scheme
08:57:40 <emu> too bad numbers are strict values, or else that could terminate
08:57:56 <xerox> jeroeng: try to specialize ap's type with the reader monad, that is: ((->) a).  I suggest you to write it as (a ->) for convenience (even though type sections aren't actually allowed.)
08:58:05 <kyevan> Soo... it's true if the list is [], false otherwise?
08:58:31 <jlouis> kyevan, yes
08:59:01 <kyevan> Okay. That makes sense, then ^_^
08:59:42 <norpan> null xs is equivalent to length xs == 0
09:00:07 <dylan> > null [1..]
09:00:09 <lambdabot>  False
09:00:14 <kyevan> Hm.. why isn't head . head a type error?
09:00:15 <norpan> i know
09:00:23 <norpan> it's not the same with inifinite lists
09:00:34 <norpan> infinite
09:00:36 <dylan> > length [1..] == 0 -- :)
09:00:40 <jlouis> ?type (head . head)
09:00:40 <lambdabot> Terminated
09:00:42 <lambdabot> forall a. [[a]] -> a
09:00:42 <norpan> i was just setting somebody up
09:01:04 <dylan> kyevan: that's just an error.
09:01:16 <kyevan> Oh, right. Lists of lists?
09:01:27 <jlouis> kyevan, yes
09:01:27 <dylan> oh, right, wait. yes.
09:01:44 <kyevan> composeing functions still screws me up. I'm sure I'll get it eventually.
09:01:47 <dylan> > (head . head) [[1]]
09:01:49 <lambdabot>  1
09:02:00 <lray80de> okay, so how do I filter all triples out of a List of triples, where the first value is a specific string ("fst" only works on Tuples)
09:02:21 <norpan> fst3 (1,2,3)
09:02:21 <emu> lray80de: \(a,b,c) -> ...
09:02:25 <norpan> > fst3 (1,2,3)
09:02:25 <lambdabot>  Not in scope: `fst3'
09:02:28 <norpan> hmmm
09:02:29 <kyevan> lray80de: write your own fstishthing?
09:02:38 <jlouis> List.filter (\(a, _, _) -> a == foo)
09:02:40 <kyevan> ^uneducated guess^
09:02:45 <lray80de> eg. filter all fmmh, okay, right.
09:02:51 <jlouis> ?hoogle fst3
09:02:52 <lambdabot> No matches found
09:03:10 <norpan> i had fst3 snd3 and thd3 somewhere at least :)
09:03:17 <lray80de> :-)
09:03:26 <emu> hmm, you'd think 'fst' could be implemented as a type-class function such that it could be overloaded for all lengths of tuples
09:03:53 <emu> maybe not in haskell98 tho
09:04:12 <norpan> not for all tuples, but for arbitrary lengths
09:04:21 <jeroeng> If (a,b,c) was just shorthand for (a,(b,c)) it'd be easier
09:04:21 <emu> yes, thats what i meant, sorry
09:04:42 <lray80de> List.filter (\(a, _, _) -> a == foo) works fine.
09:04:55 <norpan> but you should use your own types instead of tuples anyway
09:05:03 <jlouis> fst/snd looks like the c[ad]*r mess from Lisp
09:05:07 <norpan> tuples are teh evil
09:05:15 <emu> hehe i was thinking that when doing (fst . snd) the other day
09:05:20 <jeroeng> Why's that norpan?
09:05:35 <norpan> because of what we just discussed :)
09:05:59 <emu> that's like saying lists are evil because you could write head . tail . tail all over the place
09:06:05 <emu> silly!
09:06:28 <jlouis> emu, the type of a list is different from the type of a tuple tree
09:06:32 <jeroeng> That's like saying any type is evil, 'cause you could say undefined :P
09:07:10 <emu> and i often do!
09:07:12 <norpan> tuples just makes messy code
09:07:17 <norpan> that's why they are evil
09:07:34 <norpan> use newtype YourType = YourType { accessor1 :: Type1, ... }
09:07:38 <emu> lack of tuples leads to Java, though
09:07:52 <norpan> two-tuples and three-tuples may be ok
09:07:59 <emu> i like zipWith, tyvm
09:08:00 <jlouis> small tuples are way cool
09:08:19 <norpan> anyway
09:08:22 <norpan> i'm off now
09:08:22 * Nafai sads
09:08:31 <Nafai> emu: I'm working on Java code right now :(
09:08:57 <jlouis> The lack of a product type in Java hurts me all the time
09:09:09 <Nafai> jlouis: product type?
09:09:10 <emu> i tried to install a program written in java but it won't run because i don't have enough free diskspace, and the buggy thing won't let me put it on another drive
09:09:11 <notsmack> "Could not find module `System.Posix.User':"  <- how do i fix this?
09:09:20 <jlouis> Nafai, ie, a tuple. Something of type (a, b)
09:09:22 <emu> Nafai: a * b, ie.. tuple
09:09:29 <jeroeng> Nafai: Why?
09:09:47 <emu> Nafai: i had to write java code recently too :(
09:09:55 <Nafai> jeroeng: Why am I working on Java code?  It's my job.
09:10:31 <jeroeng> What do you code then, Nafai?
09:10:41 <jlouis> Whenever I switch to programming Java, my productivity is down the drain. Even with eclipse running fully
09:10:57 <emu> eclipse running fully probably drags you and your computer down
09:11:00 <ndm> C is worse...
09:11:17 <Nafai> I wouldn't want to code Java without Eclipse
09:11:32 <jlouis> ndm, true. I never completed anything of value in C (save for a runtime GC for a toy language ;)
09:11:33 <emu> if i coded java more often i'd install JDEE
09:11:56 <kyevan> Heh. I knew someone who got so fed up with java, they wrote an interpreter for a weird lispoid and worked in that instead
09:12:05 <jlouis> emu, the emacs thingy?
09:12:06 <emu> Kawa? :)
09:12:09 <emu> jlouis: ye
09:12:15 <ndm> kyevan: use the Yhc Haskell -> Java interperetter - full haskell through java
09:12:20 <Nafai> Right now I'm working on a platform other teams at our company use for data manipulation and analysis
09:12:23 <jlouis> emu, I tried. You can't do anything substantial in java with that
09:12:32 <Nafai> ndm: You can do that?
09:12:36 <emu> jlouis: oh well.  i don't code in java, much
09:12:45 <ndm> Nafai: yes, there is a java runtime for Haskell bytecode produced by Yhc
09:12:58 <emu> wrote stupid networking/threading code and hopefully its all done and i can forget about it and just use it
09:13:00 <Nafai> I didn't know that.
09:13:10 <Nafai> Dang.  Now I am going to be tempted to use that
09:13:24 <ndm> Nafai: you acn also do Yhc with Java, .NET, Python, Javascript, C - the choice is yours
09:13:25 <jlouis> emu, the problem is the verbosity of Java. You have types all over the place, and class names do change. So you need a system that can change all occurences of a class correctly. Stuff like that
09:13:47 <emu> jlouis: yes, i know.  Eclipse "solves" the problem by generating code, which causes its own problems, which are then "solved" by refactoring tools
09:14:01 <jlouis> emu, we agree totally I see
09:14:09 <emu> i guess you could try to run CPP over the code first. does ant support that?
09:14:19 <emu> (not that CPP is so wonderful)
09:14:48 <emu> jlouis: emacs can do global search and replace like that
09:14:57 <emu> but i know what you mean
09:15:40 <kyevan> Hmm...
09:15:57 <kyevan> What's the difference between Int and Integer?
09:16:05 <emu> Int is machine sized. Integer is arbitrary.
09:16:24 <emu> *arbitrary size
09:16:34 <emu> > maxBound :: Int
09:16:35 <lambdabot>  2147483647
09:17:06 <emu> (actually, Int is 30 bits, i think, not a full "word")
09:17:38 <vincenz> Int is 32 bits
09:18:02 <jlouis> > (+1) (maxBound :: Int)
09:18:02 <vincenz> ocaml has 31 bit-sized ints
09:18:03 <lambdabot>  -2147483648
09:18:04 <emu> hmm, how about on 64-bit processors
09:18:21 <vincenz> I presume, hmm, 64 bit?
09:18:23 <vincenz> ask dcoutts__
09:18:26 <emu> lemme see
09:18:34 <jeroeng> emu: 31 bits, you can't use the sign-bit
09:18:36 <dcoutts__> @arr!
09:18:37 <lambdabot> Aye Aye Cap'n
09:18:46 <emu> aye, its signed
09:18:49 <vincenz> jeroeng: no, 32 bits
09:18:52 <dcoutts__> vincenz: ?
09:18:55 <ndm> emu: the spec says at least 30 bits, but Yhc on 64bit is 64 bits
09:18:55 <emu> yes, on my xeon, its 63bits
09:19:01 <vincenz> dcoutts__: sizeof(Int) on 64bit platf in bits
09:19:09 <vincenz> dcoutts__: or rather the range :)
09:19:10 <emu> 9223372036854775807
09:19:14 <dcoutts__> vincenz: Haskell or C ?
09:19:18 <jeroeng> vincenz: 32 bits? How can the size be 2147483647 then?
09:19:19 <vincenz> dcoutts__: haskell
09:19:42 <vincenz> jeroeng: 32 bit signed integers span from -2147483648 to 2147...
09:19:43 <ndm> vincenz: the Haskell spec says 30 bits or more, thats all
09:19:45 <dcoutts__> vincenz: with GHC it's 64. The Haskell spec only requires 30 (or perhaps it was 29)
09:19:49 <vincenz> figure it out, that's 32 bits of significatn information
09:19:52 <yip> hello dcoutts__
09:19:53 <jlouis> ndm, ah, look! no tags!
09:19:57 <dcoutts__> hia yip
09:20:06 <ndm> dcoutts, 2^-29 .. 2^29, which is 30
09:20:08 <emu> gosh, haskell on a 68k processor might have trouble
09:20:14 <jeroeng> vincenz: That's what I meant, you got 31 bits you can use
09:20:16 <dcoutts__> ndm: ah, of course
09:20:16 <yip> dcoutts__: any news on gtk2hs?
09:20:17 <vincenz> ndm: you mean -2^29 :)
09:20:26 <dcoutts__> yip: yep, read gtk2hs-devel :-)
09:20:27 <vincenz> jeroeng: no, 32 bits
09:20:28 <ndm> vincenz: indeed :)
09:20:32 <vincenz> jeroeng: a signed 32 bit integer
09:20:38 <dcoutts__> yip: we're aiming for a release before xmas
09:20:38 <yip> dcoutts__: i've read that blog post
09:20:54 <dcoutts__> yip: want to help? :-)
09:21:07 <jeroeng> I suppose you're right, vincenz
09:21:13 <jlouis> is yhc a thing from the bottom or a fork off nhc?
09:21:17 <yip> dcoutts__: i'm not good enough :(
09:21:22 <ndm> jlouis: fork off nhc
09:21:26 <dcoutts__> yip: na, don't believe it
09:21:29 <vincenz> jeroeng: the bit includes the sign bit, and it's not a sign bit but rather 2-complementary encoding, that's why ou get one more negative number
09:21:41 <yip> dcoutts__: has anyone tried using gtk2hs with STM?
09:21:44 <dcoutts__> yip: there's plenty to do that's not hard, just needs someone to look at it
09:22:14 <vincenz> > length [-2147483648 .. 2147483647] - 2^32
09:22:18 <lambdabot> Terminated
09:22:34 <jlouis> ndm, oh interesting. There is an overview paper from Feb 2006. I'll read that
09:22:51 <jlouis> correction: overview slides
09:23:09 <ndm> jlouis: kind of, but they miss a lot of the good stuff
09:23:11 <dcoutts__> yip: not that I know of. The issue of course is that GUIs are IO, not STM, so you've got to square that.
09:23:33 <ndm> jlouis: for example, we have a super optimiser, can compile to javascript, lots of other goodies not in the overview
09:23:52 <ndm> i can also now deforest zip with my optimiser :)
09:23:57 <yip> dcoutts__: well that shouldn't be a problem. you only need STM for thread communication
09:24:07 <dcoutts__> yip: then go for it
09:24:20 <yip> dcoutts__: i will... just was wondering if anyone has tried it already
09:24:32 <jlouis> ndm, deforesting zip... that is nice.
09:24:41 <dcoutts__> yip: were you the person who posted to one of the mailing lists about this recently?
09:24:50 <dcoutts__> yip: if not, check out the replies
09:24:51 <yip> dcoutts__: no
09:26:10 <lispy> wth, i've never used the vallodolid online judge and i'm getting email saying my entry pased
09:26:12 <ndm> everyone on the Yhc team has different goals - mine is to beat GHC in performance, Tom's is cross-platform distributed Haskell etc.
09:26:17 <lispy> i don't think this is spam either
09:26:30 <vincenz> @join #scheme
09:27:08 <lispy> plus the solution (they sent me a copy) is in C++
09:27:16 <lispy> this is so weird
09:28:10 <emu> its your alter ego
09:28:13 <yip> dcoutts__: what about the issue of gtk2hs and multi threading?
09:28:15 <lispy> i need glguy or someone that uses these sites to tell me if it's weird spam or  not
09:28:22 <dcoutts__> yip: that's hard.
09:28:40 <lispy> nothings hard for dcoutts__!
09:28:46 <dcoutts__> heh
09:28:53 <ndm> dcoutts__, hard, but 100% essential to write real programs...
09:28:55 <emu> Dr. Jekyll, the Haskell programmer, and Mr. Hyde, the C++ hacker
09:29:16 <dcoutts__> ndm: so want to fix it during the hackathon? ;-)
09:29:24 <yip> dcoutts__: but i thought you guys already knew the solution?
09:29:25 <lispy> emu: now you're talking about my lesiure time vs. work time :)
09:29:50 <Nafai> ndm: Where can I find info on using yhc with Java?
09:29:52 <dcoutts__> yip: we know several, doesn't mean they are nice or easy to implement
09:30:12 <ndm> dcoutts__, i was thinking Yhc + Base libraries + Cabal hacking - I doubt I'd be much use at Gtk2Hs and threading (given I know nothing about either half)
09:30:31 <yip> dcoutts__: so the current roadblock is figuring out which solution is the best?
09:30:45 <dcoutts__> ndm: I was mostly joking, I think your suggestion of what to hack on is a good one. I will probably work on Cabal, doing proper dep analysis.
09:31:02 <ndm> Nafai: unfortunately i can'#t find the code anymore, just looking harder...
09:31:17 <ndm> dcoutts__, yep, Malcolm was thinking of going - which would be very ahdny
09:31:19 <Nafai> ndm: Let me know if you find it, I'd be curious
09:31:26 <lispy> ndm: no, it's #' if you want to quote a function
09:31:29 <dcoutts__> ndm: yes, it would be handy
09:32:31 <ndm> Nafai: http://www.brianweb.net/personal/blog/entry.php?entry=18 - thats all i know, so its probably a bit unsupported for proper use, but might be nice to check out
09:32:33 <lambdabot> Title: brianweb.net: YHCJVM
09:33:07 <ndm> I am awfully tempted to ditch Yhc and write m y own haskell copmiler though...
09:33:09 <malcolmw> ndm: dcoutts: it is looking less likely that I can make the hackathon now
09:33:14 <ndm> doing everything the "right way"
09:33:35 <yip> dcoutts__: i can't seem to find any posts about gtk2hs and stm. do you remember which mailing list it was?
09:33:35 <lispy> ndm: that's usually not worth it
09:33:45 <lispy> ndm: it's usually better to clean up existing projects
09:34:05 <ndm> lispy: i dare you to back that up by looking at the Yhc source code
09:34:34 * malcolmw agrees with ndm that ditching a lot of yhc'd code would be a good idea
09:34:45 <Nafai> ndm: Thanks!
09:35:02 <lispy> i thought yhc was wonderful to hack on?
09:35:11 <ndm> I think you could ditch everything up to Yhc.Core, tweak the hbc backend to work of Yhc.Core, and then rewrite a simpler front end
09:35:23 <ndm> lispy: it is, great people, great fun - just sadly not always the nicest code...
09:35:33 <malcolmw> Niklas had a rather "idiosyncratic" style when he originally wrote nhc/yhc
09:35:52 <lispy> he was a beginner?
09:35:57 <jlouis> idiosyncratic. I better go look it up
09:36:09 <ndm> part of that is because he didn't have monads or records when he started
09:36:15 <ndm> @dictionary idiosyncratic
09:36:15 <lambdabot> Unknown command, try @list
09:36:16 <malcolmw> no type sigs, no comments, lots of similar sounding names
09:36:21 <kyevan> OOookk.... why was \ picked to represent Î»?
09:36:35 <paolino> ghc --make is not doing  linking any more, what did I break ?
09:36:37 <jlouis> kyevan, because it almost looks like a lambda
09:36:38 <lispy> kyevan: i was told (\ almost looks like a lambda
09:36:53 <emu> kyevan: it lost a limb in the war
09:36:59 <jlouis> emu, haha
09:37:03 <malcolmw> yeah, haskell was at version 1.1 when he started
09:37:07 <kyevan> emu: Oh. that explains it ^_^
09:37:24 <kyevan> but Î» looks more like lambda! (it's also harder to type.)
09:37:36 <jlouis> now we have a unicode reader, it might be that Î» should be treated like a lambda ;)
09:37:43 <lispy> actually it looks nothing like lambda on my screen
09:37:46 <emu> there's some scheme mode for emacs which lets you use that for lambda
09:37:56 <jlouis> emu, quack.el
09:37:58 <kyevan> lispy: Then you fail.
09:37:59 <emu> yea, my shell isn't supporting unicode either
09:38:15 <kyevan> I'm using a console irc client and unicode works :P
09:38:22 <spiffy> mIRC doesnt much like it either. But mIRC doesnt like much.
09:38:26 <lispy> i don't know if this will work, but this is what i see: ÃŽÂ»
09:38:33 <emu> i used to use ERC to read/write utf8 on IRC
09:38:55 <emu> probably should go back to that
09:38:55 <eviltwin_b> uppercase-I-with-caret, right guillemot?
09:38:59 <lispy> i see an I with a charet above it followed by a double right arrow
09:39:00 <paolino> there should be a reason for the compiler not to make the linking phase
09:39:08 * eviltwin_b is utf8-enabled
09:39:12 <kyevan> (Although it somehow fails to have some usefull characters... like empty set. Or nullity, not that nullity is usefull, it's an idiotic thing.)
09:39:53 <emu> > 1.0 / 0.0
09:39:55 <lambdabot>  Infinity
09:40:00 <emu> go IEEE!
09:40:06 <bd_> If you use nullity, then the SIGFPEs have already won.
09:40:25 <kyevan> It does have Î», Ï€, and Î©, so I'm pretty happy ^_^
09:40:26 <emu> sigfpe does write some interesting articles
09:40:44 <kyevan> > 0.0 / 0.0
09:40:45 <lambdabot>  NaN
09:40:46 <Saizan> every time you use nullity god kills a Ph.D
09:40:46 <emu> kyevan: that looks like you've copyrighted I with a caret
09:41:31 <kyevan> emu: lower lambda, lower pi, and upper omega
09:41:39 <jlouis> what is nullity?
09:41:45 <kyevan> jlouis: 0/0
09:41:50 <jlouis> NaN?
09:41:56 <jlouis> not a number
09:41:57 <jlouis> ah
09:42:10 <kyevan> Some idiot "solved" division by zero, by calling NaN a number, and nameing it nullity
09:42:23 <bd_> And breaking commutation while he was at it.
09:42:29 <integral> hmm, is there a combinator that applies a function N times?
09:42:33 <bd_> Then taught it to (junior?) high-school students
09:42:34 <jlouis> goodbye, my nice ring on R
09:42:34 <kyevan> He broke a lot of things :P
09:42:43 <emu> integral: iterate with take?
09:42:50 <integral> @t iterate
09:42:51 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:42:52 <lispy> fix?
09:42:54 <integral> @type iterate
09:42:55 <lambdabot> forall a. (a -> a) -> a -> [a]
09:43:03 <integral> iterate (1+) 1
09:43:07 <integral> > iterate (1+) 1
09:43:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:43:14 <kyevan> Such as my comp-sci teacher's streak of not pushing the limits of school appropreateness :P
09:43:16 <integral> excellent
09:43:25 <emu> or iterate with !!, is common
09:43:34 <integral> yeah, that's what I'll use
09:43:38 <Saizan> ehm, similar question, is there a function that repeats a IO () func n times?
09:43:50 <lispy> ?type repeatM
09:43:51 <lambdabot> Not in scope: `repeatM'
09:43:51 <emu> repeatM?
09:43:58 <lispy> ?hoogle repeateM
09:43:58 <lambdabot> No matches found
09:44:00 <lispy> ?hoogle repeatM
09:44:00 <lambdabot> No matches found
09:44:04 <emu> there's replicateM
09:44:14 <Saizan> :t replicateM
09:44:16 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
09:44:35 <emu> or i guess you could mapM_ over [1..n]
09:45:06 <jdev> > iterate (>> putChar '*') (return ())
09:45:08 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
09:45:28 <kyevan> > let 0/0 = "nullity" in 0/0
09:45:29 <lambdabot>  "nullity"
09:45:37 <emu> noooo
09:45:37 <kyevan> That's basicly what nullity does:P
09:46:35 <dcoutts__> malcolmw: oh, that's a shame
09:47:26 <lispy> instead of saying NaN what should ieee754 do?
09:47:40 <lispy> should your processor explode?
09:47:48 <emu> cause monkeys to fly out of your nose
09:48:02 <kyevan> lispy: use NaN
09:48:14 <Saizan> lispy: he claims that with NaN it explodes and with nullity it doesn't
09:48:26 <kyevan> Basicly, he was trying to solve the problem of computers crashing when something is divided by 0
09:48:40 <emu> basically, people without exception handlers?
09:48:43 <kyevan> Obviously, he's never heard of try/catch or equiv :P
09:48:51 <dcoutts__> yip: "How to use STM in GUI applications?" haskell mailing list, Dec 4th
09:49:09 <bd_> :t equiv
09:49:10 <lambdabot> Not in scope: `equiv'
09:49:14 <bd_> kyevan: ?
09:49:34 <kyevan> bd_: I'm too lazy to say "equivilent", so I shortened it :P
09:50:21 <bd_> ... what does it do? XD
09:50:31 <bd_> equality tests with floating point are almost always a bad idea.
09:50:51 <kyevan> bd_: I mean "try/catch or the construct which solves that problem in another language"
09:51:24 <malcolmw> dcoutts__: I'm on foreign holidays till 5th Jan, and exams to babysit on 10th and 13th
09:51:46 <bd_> kyevan: solution: range checks :)
09:51:47 <lispy> wait are we arguing about ieee or what some ignorable person said on a blog?
09:51:56 <malcolmw> dcoutts__: the hackathon is not completely ruled out, but looking tricky
09:52:10 <kyevan> lispy: The blog was, um, BBC, so it's a little more noteable :P
09:52:18 <dcoutts__> malcolmw: ah yes and we're doing 10-12th, mind you, you don't have to be there every day
09:52:30 <kyevan> But, yes, ignoreable person and how he hasn't heard of ieee :P
09:53:09 <lispy> kyevan: i find news sources pretty ignorable :)
09:53:26 <dcoutts__> malcolmw: correct me if I'm wrong, but I can't pinch the dep resolution from hmake for Cabal as Cabal is BSDish and hmake is GPL right?
09:54:04 <dcoutts__> malcolmw: (I wish the ghc/galois folks wern't so fussy about LGPL vs BSD)
09:54:58 <dcoutts__> my impression was that for MS research it was a command from On High.
09:55:03 <malcolmw> dcoutts__: I told Isaac he could steal the SCC dependency analysis from hmake to reuse in Cabal if he wanted
09:55:08 <emu> @type replicateM_
09:55:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
09:55:15 <mbishop> Oh wow, a link on reddit about haskell that WASN'T submitted by dons :)
09:55:16 <malcolmw> dcoutts__: but I warn you it is incomprehensible
09:55:21 <dcoutts__> malcolmw: oh right, ok, I'll look into it.
09:55:25 <dcoutts__> malcolmw: ah heh, ok :-)
09:55:44 <malcolmw> dcoutts__: blame Thomas Hallgren for that one
09:55:48 <dcoutts__> :-)
09:56:03 <dcoutts__> malcolmw: do you think we could make it extensible for file types other than .hs/.lhs ?
09:56:15 <malcolmw> dcoutts__: it already is extensible
09:56:20 <dcoutts__> oh, brill
09:56:36 * dcoutts__ knows very little about hmake
09:56:38 <malcolmw> dcoutts__: hmake deals with any random preprocessor you want to throw in
09:56:49 <dcoutts__> ok, great. That's just what we need.
09:56:58 <ndm> dcoutts__, you can also steal the stuff out of Yhc as well, which has dependancy stuff in it, which Tom said is stealable
09:57:01 <malcolmw> dcoutts__: you just need to specify how to recognise the input and output files
09:57:29 <ndm> dcoutts__, isn't a dependancy analyser thing about 50 lines of well wirtten Haskell?
09:57:30 <dcoutts__> malcolmw: right, no problem. eg with c2hs, the .chs files can depend on other .chs files (or rather the .chi file)
09:57:33 <malcolmw> dcoutts__: shapr pointed me to another open SCC dep analysis in Haskell -called Maak I think
09:58:05 <dcoutts__> ndm: dunno, I've never considered it in detail
09:58:24 <ndm> dcoutts__, i wrote on in Catch, it was quite easy
09:58:40 <Igloo> malcolmw: Did Thomas Hallgren agree it could be BSDed?
09:59:16 <dcoutts__> ndm: I'll bear the yhc one in mind too. Part of it is the generic framework and part is the specifics of lightly parsing the .hs file header to extract the imports.
09:59:32 <malcolmw> Igloo: hard to tell what Thomas is thinking sometimes :-)
09:59:33 <dcoutts__> a simple version of the former mighht be 50 lines
09:59:33 <ndm> dcoutts__, indeed - i think the generic framework is the harder bit
09:59:55 <dcoutts__> yes, though if you want to cope with ghc's extensions then the latter isn't trivial either
10:00:00 <ndm> but i'd be tempted to write it from scratch
10:00:03 <malcolmw> Igloo: he did tell me I could do what I liked with the code when I first incorporated it into hmake, 10-odd years ago
10:00:07 <dcoutts__> eg exporting foobar#
10:00:13 <ndm> dcoutts__, there are not many extensions to the import syntax
10:00:14 <lisppaste2> emu pasted "bug in ghc?" at http://paste.lisp.org/display/31696
10:00:21 <dcoutts__> ndm: yeah, perhaps not
10:00:32 <Dr_Pi> Please forgive me, I have a PowerBook G4 running Tiger, and I'm struggling to get the fp plugin for Eclipse working. Right now I'm trying to figure out how to install haddock and I think I need some hand holding. I've downloaded the Haddock source and the Eclipse Haskell cheat sheet is asking me where the executable is. I've already installed ghc 6.6.
10:00:35 <Igloo> malcolmw: OK
10:00:46 <dcoutts__> ndm: though looking at existing examples might help in understanding the problem
10:00:53 <ndm> dcoutts__, definately!
10:01:38 <emu> i get a weird error message for the first example in that paste
10:02:08 <malcolmw> Igloo: but I'm pretty sure it would be a much better strategy to just write a new dep anal from scratch
10:02:21 <lispy> Dr_Pi: how did you install things?  what version of eclipse are you using? it it compatible with eclipse-fp (i've noticed the version numbers are picky)
10:02:42 <Igloo> Sounds good to me
10:02:46 <lispy> Dr_Pi: do you use the commandline?
10:03:05 <Dr_Pi> lispy: I think I'm using latest versions for everything.
10:03:58 <Dr_Pi> lispy: you I have to yes. (It's called Terminal in Mac OS X :-))
10:04:33 <lispy> Dr_Pi: i know, i have an ibook G4 :)
10:04:58 <Dr_Pi> lispy: I meant: when I have to yes.
10:05:15 <lispy> Dr_Pi: i think eclipse-fp only works with eclipse 3.3 or something...and you have to have java 1.5 and eclipse has to be run using it
10:05:24 <dcoutts__> Igloo: any idea how to recover from a state where darcs revert says "Yikes, pending has conflicts!"
10:05:50 <dcoutts__> apparently my repo is consistent
10:06:04 <Igloo> dcoutts__: You probably have stuff in _darcs/patches/pending
10:06:15 <Igloo> Depending on what it is, you might want to just remove it
10:06:20 <dcoutts__> ok
10:06:47 <lispy> Dr_Pi: of course on my system eclipse throws an exception and crashes every time i run it so i stopped using it
10:07:11 <lispy> Dr_Pi: it's also painfully slow and requires a ridiculuous amount of memory
10:07:35 <Dr_Pi> lispy: Well the latest version of eclipse is 3.2.1 and I upgrade to TIger so I could get Java 5.0.
10:08:09 <lispy> i think your eclipse is too old then, check the eclipse-fp site to be sure, they tell you which version of eclipse to use
10:08:50 <Dr_Pi> lispy:  I just upgraded my PowerBook to 2G of memory.
10:08:57 <lispy> heh, nice
10:10:07 <lispy> Dr_Pi: i would recommend against eclipse and encourage to you consider vim/emacs.  But, either way, good luck i'm off to work.
10:10:29 <Taraxis> is anyone using using cabal on Windows?
10:10:34 <Taraxis> (anyone here...)
10:10:36 <ndm> Taraxis: yes
10:10:49 <emu> i'm using runSTArray to create an Array, but I'd like it do be a DiffArray.  is that possible?
10:10:56 <Dr_Pi> lispy: yes, the eclipse-fp site recommends 3.2.1. Thanks lispy.
10:11:43 <emu> to be*
10:11:44 <lispy> Dr_Pi: okay, next i would check to see if eclipse is getting launched with the correct version of java
10:11:55 <Taraxis> ndm: I am installing it, running 'setup configure' and getting an error 'Cannot find compiler for ghc' but it is in my path, any idea what's wrong?
10:12:00 <lispy> Dr_Pi: then i would find out if eclipse-fp is compatible with ghc6.6
10:12:13 <ndm> Taraxis: "it" - installing Cabal?
10:12:50 <Taraxis> ndm: Yes, Cabal.  I got it via darcs, compiled it ok, but it fails on setup configure
10:13:12 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/windows.php
10:13:15 <lambdabot> Title: Neil Mitchell - Windows Packages
10:13:25 <ndm> Taraxis: at the bottom of that page is a list of instructions to install Cabal, follow it :)
10:13:49 <ndm> the initial cabal package is special
10:14:24 <Taraxis> ndm: I followed those instructions.  it's the setup configure part that fails for me.
10:14:41 <ndm> Taraxis: what does "ghc --version" say?
10:14:43 <Lemmih> Taraxis: Tried -w path/to/ghc?
10:15:08 <ndm> Lemmih: on Windows GHC needs to be in the path, so it can find things like perl as well
10:15:21 <Taraxis> ndm: version 6.6
10:15:39 <ndm> Taraxis: can you give the full output to setup configure
10:15:41 <ndm> @paste
10:15:42 <lambdabot> http://paste.lisp.org/new/haskell
10:15:45 <ndm> at that paste bot
10:17:21 <Taraxis> ndm: I'm a neophyte with this; dunno how to use the past bot?  The output is only: "Configuring Cabal-1.1.7..." then "setup: Cannot find compiler for ghc"
10:18:35 <ndm> Taraxis: don't know then, i've only tried with ghc 6.4 and that worked fine
10:18:51 <ndm> i suggest you try emailing the cabal devel list, unless Igloo or dcoutts__ has any other ideas?
10:19:52 <dcoutts__> did we establish if ghc was on the path?
10:20:06 <ndm> dcoutts__ i think we did
10:20:22 <ndm> Taraxis: if you just open a console and type "ghc --version" - that was all you did right? and it worked?
10:20:37 <dcoutts__> how about the output of setup configure -v
10:21:18 <Taraxis> Yes, which is why I can't figure it out.  ghc is there.
10:21:21 <glguy> http://newyork.craigslist.org/mnh/eng/244632325.html -- this job posting requires you to write a rot13 function to decode where to send your application. they ask you to provide the code you used. I'm thinking about applying for fun and turning in the code that I used.. a bf compiler in haskell running a bf rot13 program
10:21:22 <lambdabot> Title: Web Developer - Does this sound like you?
10:22:05 <Taraxis> dcoutts__: using -v just adds "configure: searching for ghc in path."
10:22:32 <dcoutts__> Taraxis: try specifying --compiler= and the path to ghc.exe
10:22:46 <dcoutts__> or rather the full path of ghc.exe
10:22:52 <emu> runSTArray kicks ass
10:23:00 <ndm> Taraxis: oh, did you type "ghc" into the same console as you are using for Cabal?
10:23:02 <glguy> emu: you got it working?
10:23:04 <emu> i just took a function which was running in 60% of the total CPU time, and turned it into <5%
10:23:11 <Pastorn> @info Filepath
10:23:12 <lambdabot> Filepath
10:23:17 <ndm> @where filepath
10:23:17 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
10:23:18 <dcoutts__> emu: except that you can't use it polymorphically with unboxed arrays
10:23:43 <emu> and this is despite the fact that I'm turning it into a DiffArray via "array (a,b) . assocs $ runSTArray"
10:23:56 <jlouis> ?hoogle eastenders
10:23:56 <lambdabot> No matches found
10:23:56 <Taraxis> ndm: yes
10:24:05 <emu> glguy: yea actually this was just a side function which turned into a hotspot since the other hotspot was vanquished
10:24:12 <jlouis> ?hoogle Nintendo Revlution
10:24:13 <lambdabot> No matches, try a more general search
10:24:22 <ndm> jlouis: do i guess that bondage is coming next?
10:24:26 <glguy> emu: check out: runST (getAssocs ...
10:24:32 <jlouis> ?hoogle Bondage
10:24:32 <lambdabot> No matches found
10:24:37 <emu> glguy: i actually ended up using a DiffArray of IntMaps
10:24:40 <jlouis> ndm, we need easter eggs ;)
10:24:41 <emu> instead of adj matrix
10:24:45 <glguy> ah
10:24:55 <ndm> jlouis: there are a few on the website version
10:24:58 <emu> turned out my graph was sparser than i thought on the big test cases
10:25:01 <Taraxis> dcoutts__: the --with-compiler flag worked
10:25:03 <jlouis> ndm, cool!
10:25:13 <emu> with the adj matrix it wasn't running any faster than the fgl version
10:25:19 <ndm> jlouis: not very good ones though...
10:25:22 <Taraxis> thanks!
10:25:30 <dcoutts__> Taraxis: hmm, it's a bit odd that it didn't with just letting it find it itself.
10:25:55 <jlouis> ndm, hoogle is a very good project. I often use it
10:25:56 <dcoutts__> ndm: have you checked that Cabal isn't getting confused with the .exe extension on windows
10:26:06 <ndm> dcoutts__, works fine for me
10:26:09 <dcoutts__> hmm
10:26:11 <dcoutts__> odd
10:26:14 <ndm> jlouis: good good
10:26:40 <Taraxis> yeah, very weird.
10:26:53 <Taraxis> maybe Cabal is looking for a particular version string?
10:31:22 <emu> glguy: having some trouble with runST (getAssocs ...
10:31:54 <Dr_Pi> lispy: I got it working and I'm not sure what was wrong with it before.
10:31:54 <emu> it's not happy with the monad being (ST s)
10:32:07 <glguy> emu: You might have to specify an explicit array type
10:32:20 <glguy> emu: when you do newArray
10:32:21 <Dr_Pi> I need help installing haddock.
10:32:30 <glguy> emu: because runSTArray does that for you
10:32:49 <emu> oh i see
10:33:09 <glguy> emu: I switched from assocs . runSTArray to runST (getAssocs  in my monop example to cut out a middle man, I doubt that it's actually a big deal
10:33:21 <glguy> I just didn't want an extra array created that I didn't need
10:33:58 <emu> how can you specify the type of an STArray without that existential variable?
10:36:34 <scodil> dcoutts: how do I build gtk2hs with profiling support? I can't find anything in the docs.
10:36:42 <emu> is it cabal?
10:36:48 <dcoutts__> scodil: it's not directly supported
10:37:01 <scodil> so i'm SOL then if I want to profile anything that uses gtk?
10:37:05 <emu> glguy: ah its ok; i'll deal with the extra array for now =)
10:37:21 <dcoutts__> scodil: I think someone got it working once but I don't recall how.
10:37:44 <scodil> and there's no way to tell ghc that its ok to not profile the gtk modules? its all or nothing?
10:38:09 <dcoutts__> scodil: it's all or nothing, you can't mix profiling and non-profiling object code
10:38:28 <scodil> fabulous. what is it about gtk that makes in non-profilable?
10:38:45 <dcoutts__> scodil: it's just a limitation of the build system
10:39:05 <dcoutts__> scodil: using -prof makes ghc produce .p_hi files and the build system expects .hi files
10:39:22 <dcoutts__> scodil: so you can hack it to make it work, but it might take you a little while
10:41:09 <Igloo> dcoutts__: Just adding -prof should work
10:41:28 <dcoutts__> Igloo: really? I thought it produced .p_hi files
10:41:57 <kyevan> What does => mean?
10:42:07 <Igloo> dcoutts__: Only if you tell it to with -ohi
10:42:14 <kyevan> in, eg, :t \x -> x+5
10:42:14 <dcoutts__> Igloo: oh, ok
10:42:38 <dcoutts__> scodil: well you can try ./configure --with-hcflags=-prof
10:43:02 <dcoutts__> Igloo: but doesn't ghc also look for .p_hi files when it looks for a package and it's in -prof mode
10:43:30 <kyevan> ?type \x -> x + 5
10:43:31 <lambdabot> forall a. (Num a) => a -> a
10:43:39 <dcoutts__> kyevan: it means with class constraints on the type
10:43:40 <kyevan> What does => mean in that?
10:43:55 <kyevan> dcoutts__: ... huh?
10:43:59 <scodil> kyevan: a is asssumed to be an instance of Num
10:44:00 <dcoutts__> kyevan: it means that 'a' must be an instance of the Num class
10:44:09 <kyevan> Oh.
10:44:30 <kyevan> So, it could be Int, or Double, or Integer, or... but not String?
10:45:00 <dcoutts__> kyevan: right
10:45:07 <Igloo> dcoutts__: Hmm, not sure
10:45:30 <emu> heh. im getting ghc 6.4.1 so that i can compile a version of ghc 6.6 which runs on this system im installing onto :/
10:45:56 <cjeris> kyevan: you can read it in English:  f :: forall a. (Num a) => a -> a means "f is polymorphic such that for every type a, if (Num a) is true [if a is an instance of Num], then f can be instantiated to have the type a -> a".
10:46:25 <kyevan> emu: That's easier than bootstraping gcc :P
10:46:31 <kyevan> cjeris: Ooooohhh
10:46:32 <emu> erk, can't use this either
10:46:38 <kyevan> OK. that makes sense. I think
10:46:42 <emu> i need to bootstrap from gcc, i think
10:47:07 <emu> what's the minimal compiler to bootstrap ghc from?
10:48:00 <scodil> is there a good program for viewing ghc profiler output?
10:48:12 <kyevan> emu: A good knowledge of haskell, a hex editor, a machine code chart, and a lot of asprine.
10:48:32 <scodil> my sides
10:48:42 <kyevan> (What! It's not impossible!)
10:49:26 <emu> scodil: less?
10:49:48 <emu> i read the table format pretty easily. however you can have it output to some xml format, and i think there might even be a tool to read it.
10:50:23 <scodil> nevermind. i hadn't actually looked at it yet. i was expecting some gprof-like mess
10:50:36 <emu> there's a nice summary at the top
10:50:43 <emu> another nice RTS option is to use -sstderr
10:53:03 <shahn> i tried to use hsffig to wrap c headers in Haskell code. Is it still being developed? the sourceforge files seem very old...
10:53:45 <glguy> > let 0^0 = "phi" in 0^0 -- yeah, I saw people doing this already, but it's my turn!
10:53:46 <lambdabot>  "phi"
10:56:52 <scodil> ok so I got this function to turn euler angles into quaternions. all it does is make three calls to rotate (about x, about z, about x again).  The profiler is telling me that rotate is only using 25%, but eulerToQuaternion is using 75%. whats the story here?
10:57:37 <fasta> in: let v =runST (newSTRef True) in runST (readSTRef v) why can't the type of readSTRef v be generalized?
10:58:14 <scodil> fasta: you've seen bulat ziganshin's ArrayRef library?
10:58:26 <scodil> or however you spell his name
10:58:34 <fasta> scodil: I have
10:59:18 <scodil> so you're problem is the with s type parameter to readSTRef then?
10:59:30 <fasta> scodil: right
10:59:42 <scodil> it escapes, but not really, but the type system thinks it does? thats been my experience at least
11:01:03 <fasta> scodil: I would rather get a coherent clear answer (nofi). I hope there's someone who does understand them.
11:01:48 <scodil> i didn't try to answer you. i was trying to see if your problem was the same one I had, in which case, I would tell you what others told me: tough shit, can't do it
11:01:56 <scodil> i don't know why though
11:02:02 <scodil> has something to do with the forall
11:02:53 <Pastorn> @seen xinming
11:02:54 <lambdabot> xinming is in #perl6 and #haskell. I last heard xinming speak 3d 7h 15m 44s ago.
11:03:16 <Pastorn> yay... :/
11:03:43 <mbishop> You know...maybe I'm just spoiled by scheme or something, but haskell is one of the few languages I decided to learn in the recent past that took a lot of work to learn it's syntax heh
11:03:50 <scodil> so no one has any idea why this function ( f x y z = g x `op` g y `op` g z ) would spend 25% time in g and 75% time in f? (op gets inlined)
11:04:17 <scodil> oh i think i just answered my own question
11:04:26 <glguy> the op inlining?
11:04:29 <scodil> yeah
11:05:19 <fasta> scodil: isn't the profile hierarchical?
11:06:09 <savanni> Question: How do I force a monadic operation, such as Data.Map.lookup, to return a Maybe monad?
11:06:26 <savanni> (actually, very specifically, I want Data.Map.lookup to return a Maybe result)
11:06:45 <emu> doesn't it already do so
11:06:58 <emu> @type lookup
11:07:00 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
11:07:06 <scodil> no that 25%/75% figure is the non-heirarchical figure. time in the node, not in the subtree.
11:07:08 <fasta> savanni: you just use it as if it returns Maybe
11:07:10 <emu> @type Data.Map.lookup
11:07:12 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
11:07:14 <savanni> Oh... that's different from the libary documentation.
11:07:17 <emu> it will overload "m" to Maybe
11:07:27 <emu> because Maybe is an instance of Monad
11:07:29 <savanni> It does so automatically?
11:07:32 <fasta> savanni: yes
11:07:35 <emu> that's the magic of type-classes
11:07:53 <fasta> magic sounds religious
11:08:02 <savanni> But, how does it know to chose Maybe instead of Either?
11:08:09 <emu> what is libmagic, then?
11:08:21 <emu> savanni: what's your context?
11:08:43 <emu> case lookup ... of Just ... | Nothing ...
11:09:02 <savanni> Oh.  So if I did "case lookup ... of Left ....." would it switch to Either?
11:09:24 <emu> it would have to be (Either a)
11:09:56 <savanni> Other than the case statement, I am not explicitely specifying which to use.
11:10:18 <yts> hello
11:10:46 <yts> is anyone know about the library which describe the document?
11:10:56 <yts> maybe pdf or ps
11:12:07 <emu> instance (Error e) => Monad (Either e)
11:12:53 <emu> that says to me that the type of the argument to Left would have to be indicated to be of class Error
11:13:45 <emu> a String would work
11:14:33 <emu> > case Data.Map.lookup 1 (Data.Map.fromList [(1,2)]) of Left s -> s ; Right _ -> "yes"
11:14:34 <lambdabot>  Not in scope: `Data.Map.fromList'
11:14:55 <Saizan> :t M.fromList
11:14:57 <lambdabot> Couldn't find qualified module.
11:15:10 <emu> it works, i just don't know how to make lambdabot use that module
11:15:28 <Saizan> dons used that before i think
11:15:40 <emu> @type Map.fromList
11:15:41 <lambdabot> Couldn't find qualified module.
11:16:24 <emu> the string it returns, in question, is "Data.Map.lookup: Key not found" in the Left branch
11:16:40 <int-e> > M.empty
11:16:41 <lambdabot>  Add a type signature
11:16:46 <int-e> > M.empty :: M.Map Int Int
11:16:48 <lambdabot>  {}
11:16:56 <emu> @type M.insert
11:16:58 <lambdabot> Couldn't find qualified module.
11:17:07 <emu> > M.insert 1 2 M.empty
11:17:08 <lambdabot>  {1:=2}
11:17:31 <emu> > case M.lookup 1 (M.insert 1 2 M.empty) of Left s -> s ; Right _ -> "yes"
11:17:32 <Saizan> unsynced plugins :)
11:17:32 <lambdabot>  "yes"
11:17:46 <emu> > case M.lookup 2 (M.insert 1 2 M.empty) of Left s -> s ; Right _ -> "yes"
11:17:47 <lambdabot>  "Data.Map.lookup: Key not found"
11:18:37 <savanni> Hm... Okay.
11:18:41 <savanni> I will play with this more.
11:18:47 <glguy> > take 4 $ iterate((++[1]).ap(zipWith(+))(0:))[1]
11:18:49 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1]]
11:19:06 <glguy> does anyone see an obvious way to shorten the first argument of iterate?
11:19:51 <xerox> let f = (++[1]).ap(zipWith(+))(0:) in take 4 $ iterate f [1]
11:20:22 <glguy> =\
11:21:14 <mbishop> a lil bit o' reddit spammin: http://programming.reddit.com/info/u5jo/comments
11:21:16 <lambdabot> Title: Ask Reddit: Why do people think some languages are not "realistic"? (reddit.com)
11:22:42 <fierarul> mbishop,"realistic" == "tons of apps written for it" :) a corporate backing doesn't hurt.
11:23:33 <kyevan> ghci doesn't let you define data types on the fly?
11:23:41 <sjanssen> kyevan: no
11:23:46 <Taraxis> If someone has never programmed before, do you think haskell would be easier to pick up than widely-used languages?
11:23:54 <mbishop> so, a languages "realism" is defined by how many applications are written in it? that's silly
11:24:12 <emu> kernel: divide error: 0000 [#1]
11:24:13 <kyevan> Taraxis: That probably depends on what they've learned before math and logic wise
11:24:16 <emu> oh my, where's nullity now!
11:24:35 <kyevan> emu: Not in unicode, yet :P
11:24:40 <emu> i think i crashed ghc in a spectacular way
11:24:46 <kyevan> Emphasis on the yet.
11:24:56 <kyevan> I'm sure someone will try to push it through
11:25:10 <sjanssen> Taraxis: some schools have used Haskell as their first semester CS course
11:25:24 <emu> erk
11:25:35 <sjanssen> Taraxis: perhaps looking into reports about those courses would be enlightening
11:25:37 <Taraxis> I'm starting haskell but have used traditional languages.. It seems like the way to go with this is to write out what I want to do in english and then slog through documentation to find out how to write it.
11:25:46 <emu> i just got a bunch of kernel messages while running "runghc Setup.hs configure"
11:25:52 <Taraxis> sjanssen: that's interesting.
11:25:53 <emu> next time i ran it, just fine....
11:26:11 <Taraxis> sjanssen: my first cs course in college was eiffel. ugh.
11:26:43 * sjanssen had Java . . . 
11:26:59 * mbishop had no formal schooling in programming
11:27:18 <Spark> such a thing doesn't exist
11:27:22 <eviltwin_b> pascal, then watfiv
11:27:51 <kyevan> My class, in HS, is useing Scheme subsets to start, then moving to Java
11:28:23 <sjanssen> kyevan: Scheme in high school?  very neat!
11:28:42 <mbishop> Taraxis: I'm but a noob at haskell, but coming from lanuages like scheme and ml, I can say haskells syntax scares me..I'm sure it has great power, but it takes quite a bit more learning it seems
11:28:47 <kyevan> sjanssen: It helps that the school computer science department is exactly one person :P
11:29:12 <kyevan> (He gets to do whatever he wantts, so long as he can meet a few requirement as far as outcomes go.)
11:29:19 <pejo> mbishop, if you know ml - what scares you with Haskell?
11:29:47 <fierarul> mbishop, that is business realism.
11:29:50 <kyevan> Hmm
11:29:50 <sjanssen> kyevan: is he CS only?  At my highschool programming classes were always taught by a spare math teacher
11:30:01 <kyevan> sjanssen: CS only, yep
11:30:03 <mbishop> pejo: I only know a little ml too (ocaml specifically), but the . and <<= and >> and $ and \x stuff scares me :P
11:30:15 <emu> . is o
11:30:35 <emu> $ is function application, the garden variety kind
11:30:42 <emu> \ is "fun"
11:30:45 <kyevan> (Not for this school only, though, he also teaches some classes in the Distance Learning lab, so other schools in the area have CS courses taught by him)
11:30:47 <emu> and the rest is monads! enjoy!
11:30:49 <sjanssen> you shouldn't see >>= in code very often
11:30:55 <Taraxis> hahaha
11:31:33 <mbishop> sjanssen: just an example, I have no idea what it does yet :)
11:31:53 <savanni> :r
11:32:08 <savanni> sorry
11:37:16 <psnl> dcoutts__: is there a gtk2hs download that works with ghc 6.6?
11:37:59 <araujo> psnl, the darcs version
11:38:07 <psnl> yey!
11:38:07 <Cale> mbishop: I think you'll see why it's infix when you get to it :)
11:38:21 <Cale> (it's fairly awkward to give it a prefix notation)
11:39:33 <fasta> Cale: did you see my question?
11:39:49 <Cale> fasta: hmm, no
11:40:35 <fasta> Cale: in: let v =runST (newSTRef True) in runST (readSTRef v)
11:40:36 <fasta>               why can't the type of readSTRef v be generalized?
11:40:43 <Cale> <fasta> in: let v =runST (newSTRef True) in runST (readSTRef v) why can't the type of readSTRef v be generalized?
11:40:48 <Cale> ah
11:40:50 <mbishop> Cale: see why what's infix?
11:40:50 <Cale> yeah
11:40:54 <emu> fasta: i'd say that you cna't use the same "s" in both runSTs
11:40:57 <Cale> mbishop: >>=
11:41:22 <mbishop> ah
11:41:27 <Cale> runST (newSTRef True) is a type error
11:41:44 <fasta> Cale: I understand that part.
11:41:58 <fasta> Cale: but paper explains two reasons of which I understand one.
11:42:09 <fasta> Cale: the paper*
11:42:12 <Cale> okay
11:42:19 <Cale> um, hmm
11:42:54 <fasta> Cale: On page 9 of that paper two reasons are given. I don't understand the first.
11:42:58 <Cale> okay
11:43:10 <fasta> Cale: do you know what paper I am talking about?
11:43:24 <Cale> maybe, but I'd appreciate a link if you have one
11:43:51 <fasta> Cale: http://citeseer.ist.psu.edu/63882.html
11:43:52 <Cale> suppose v :: STRef S Bool -- note the specific S
11:43:53 <lambdabot> Title: Lazy Functional State Threads - Launchbury, Jones (ResearchIndex)
11:44:11 <Cale> then readSTRef v :: ST S a
11:44:19 <Cale> and it's no longer polymorphic in s
11:44:41 <bjoernz> Hi, can someone please help me? I started playing with haskell today. I try to create a list of 5 random numbers.
11:45:03 <fasta> Cale: Did you intend that upperfacse letter S?
11:45:07 <Cale> yes
11:45:08 <fasta> uppercase, even
11:45:19 <fasta> Cale: but in the example in the paper it's a lowercase s.
11:45:30 <fasta> Cale: it's still just s
11:45:32 <Cale> well, the type won't be completely determined, but it's the same type as in the other call to runST
11:45:54 <Cale> well, really, let's write it correctly :)
11:46:11 <Cale> There exists an s such that  v :: STRef s Bool
11:46:18 <Cale> We'll assume that
11:46:26 <fasta> Ok
11:46:36 <Cale> then readSTRef v :: STRef s Bool
11:46:48 <Cale> not  forall s. STRef s Bool
11:46:55 <Cale> but that specific s
11:47:04 <fasta> Wrong
11:47:20 <Cale> readSTRef :: forall s a. STRef s a -> ST s a
11:47:30 <Cale> er
11:47:31 <Cale> sorry
11:47:39 <Cale> then readSTRef v :: ST s Bool
11:48:13 <Cale> and not
11:48:19 <Cale> forall s. ST s Bool
11:48:23 <Excedrin> bjoernz: http://www.nabble.com/Generate-50-random-coordinates-tf2742242.html#a7651116
11:48:26 <lambdabot> Title: Nabble - Generate 50 random coordinates, http://tinyurl.com/yb96l8
11:48:30 <Cale> bjoernz: sure
11:48:32 <glguy> Cale: emails about the JAndersen teaching kids to divide by zero are going around my office, I'm sharing your rebuttle with everyone ;)
11:48:39 <fasta> Where does that exists statement come from then?
11:48:43 <Cale> glguy: thanks
11:49:01 <Cale> glguy: also, I've been informed that was a one-time event
11:49:02 <bjoernz> thanks, Excedrin
11:49:27 * glguy wonders if he could be charged with child neglect or endangerment or abuse for screwing with kids minds
11:49:35 <Cale> bjoernz: basically, if you want to create random numbers that are different every time the program runs, you need to use the IO monad a bit
11:49:55 <Cale> bjoernz: So you should know about IO first, unless you're willing to pick a seed and stick with it :)
11:50:10 <Cale> glguy: no, I don't think it's all that terrible
11:50:38 <Cale> glguy: What kids are learning at that stage has more things wrong with it than most people are aware of anyway.
11:50:41 <fasta> Cale: How is the assumption you stated in the beginning satisfied?
11:50:52 <bjoernz> Cale: thx, i guess i can figure it out with the tutorial that i have before me... i just miss my for loop
11:50:55 <Cale> fasta: It's not, and that's the other problem
11:51:23 <chessguy> Cale, things like what?
11:51:34 <Cale> bjoernz: replicateM 5 (randomRIO (1::Int,10))
11:52:07 <Cale> chessguy: things like general exponentiation and the logarithm being circularly defined
11:52:42 <Cale> There are lots of lesser crimes like studying trig before calculus
11:52:52 <fasta> Cale: Well, I understood your reasoning as leading to the point where it couldn't be generalized, which is exactly what that paper also states, so that assumption should hold?
11:53:02 <Cale> (hint: you need calculus to define the trig functions)
11:53:18 <Jessehk> I know this sounds stupid, but how do I get the "a" from a "Just a" type?
11:53:23 <integral> (I wish they taught geometry from euclid)
11:53:33 <Cale> Jessehk: case
11:53:34 <fasta> Jessehk: fromJust or pattern matching
11:53:37 <Cale> case x of
11:53:41 <Cale>    Nothing -> ...
11:53:44 <Jessehk> ah, makes sense.
11:53:45 <Cale>    Just v -> ...
11:53:45 <Jessehk> Thanks :)
11:53:46 <ibid> Jessehk: pattern matching is preferred
11:53:48 <bd_> Cale: How are logarithms circularly defined?
11:54:01 <ibid> Jessehk: but fromJust is available if you know it won't be Nothing
11:54:08 <Cale> bd_: they tend to say that if x^y = a, then log_x a = y
11:54:09 <glguy> Jessehk: fromMaybe is pretty safe
11:54:12 <mbishop> http://factor-language.blogspot.com/2006/12/division-by-zero-hoax.html
11:54:15 <lambdabot> Title: Factor: a stack language: Division by zero hoax, http://tinyurl.com/y3o92h
11:54:18 <glguy> > fromMaybe 0 Nothing
11:54:19 <Cale> but they don't define x^y when y is real
11:54:20 <lambdabot>  0
11:54:23 <glguy> > fromMaybe 0 (Just 2)
11:54:24 <lambdabot>  2
11:54:48 <bd_> Cale: ic
11:55:07 <Cale> and so these two things sort of get defined in terms of each other, but not really
11:55:23 <ibid> @type fromMaybe
11:55:24 <lambdabot> forall a. a -> Maybe a -> a
11:55:33 <ibid> ah
11:55:36 <ibid> default value
11:55:37 <ibid> :)
11:55:51 <ibid> that works only when there is a sensible default :)
11:56:04 <fasta> Cale: can you elaborate on what you said last?
11:56:07 <glguy> fromMaybe (error "no sesnsible default")
11:56:08 <Cale> The thing is, you need some Calculus to define either one of them properly (you need at least the concept of supremum to do it in a somewhat inelegant way, or else series or integrals)
11:56:26 <Cale> fasta: which?
11:56:52 <fasta> 20:44 <Cale> fasta: It's not, and that's the other problem
11:57:00 <Cale> oh
11:57:17 <fasta> Cale: I still don't get the first case, sorry.
11:57:45 <ibid> glguy: that's no better than fromJust :)
11:58:41 <Cale> well as you know, v isn't well-typed, because newSTRef True :: ST s (STRef s Bool), but runST :: (forall s. ST s a) -> a
11:58:52 <Cale> but a mentions s
11:59:09 <Cale> (hen we try to unify)
11:59:14 <Cale> when*
11:59:35 <glguy> ibid: it is better in that it allows you to put a meaningful explaination of why you expected the result not to fail
11:59:43 <fasta> Then we need to rename and see they don't match.
11:59:54 <Cale> right
12:00:04 <fasta> You are now describing reason #2.
12:00:13 <Cale> am I?
12:00:15 <fasta> I don't understand reason #1
12:00:22 <chessguy> hmm, is Anderson claiming that infinity has always been 1/0?
12:00:40 <chessguy> http://www.bbc.co.uk/berkshire/features/divide_zero_sum.ram
12:00:42 <fasta> Cale: unless I don't get something.
12:00:51 <fasta> Cale: do you have the paper before you?
12:01:16 <Cale> Yes, but page 9 just has some semantics on it. I don't see your example.
12:01:17 <glguy> I have Cubed the Earth, with 4 simultaneous corner days in 1 rotation of Earth.
12:01:42 <Cale> oh, page 4
12:02:02 <fasta> Cale: hmm, ok then I must have a specific version... I will get you the right one. The title is the same, though...
12:02:09 <ibid> glguy: and it's worse because it clutters your code with explanations of stuff that never happens :)
12:02:20 <dcoutts__> psnl: do you mean a binary build for windows or building from source?
12:02:38 <Cale> fasta: it's okay, I think I see what you're referring to
12:02:45 <psnl> dcoutts__: building from source
12:05:56 <Cale> the two examples are separately showing that runST (readSTRef v) and runST (newSTRef True) are badly typed.
12:06:33 <dcoutts__> psnl: the current darcs version of gtk2hs works fine with ghc-6.6
12:06:57 <Cale> (and thus, variables can neither leak in or escape from ST)
12:07:17 <Cale> fasta: which one is it that's bothering you?
12:08:03 <roconnor> Anderson doesn't appear to reference Carlstrom's PhD, nor his publication.
12:08:27 <roconnor> urn:nbn:se:su:diva-475
12:09:23 <fasta> Cale: the one mentioning the judgement
12:09:33 <Cale> runST (readSTRef v)
12:09:33 <emu> > array (1,10) [1..5]
12:09:34 <lambdabot>  add an instance declaration for (Num (i, e))
12:09:34 <lambdabot>   In an arithmetic sequence:...
12:09:46 <emu> > listArray (1,10) [1..5]
12:09:47 <lambdabot>  Exception: (Array.!): undefined array element
12:10:15 <emu> > (listArray (1,10) [1..5]) 1
12:10:16 <lambdabot>    The function `(listArray (1, 10) ([1 .. 5]))' is applied to one argument...
12:10:20 <emu> > (listArray (1,10) [1..5]) ! 1
12:10:21 <lambdabot>  1
12:10:27 <emu> so it's ok to have undefined elements?
12:10:44 <glguy> emu: as long is you aren't using an unboxed array
12:10:55 <glguy> emu: and as long as you don't try to use the undefined value :)
12:11:01 <emu> indeed
12:11:40 <fasta> Cale: "Now in order.. does not have type <some type
12:11:42 <fasta> "
12:12:01 <Cale> Right
12:12:01 <fasta> Cale: that paragraph is "bothering me"
12:12:05 <Cale> okay
12:12:32 <Cale> the type of v can't possibly even mention the type s, right?
12:13:49 <Cale> readVar v is going to have a type like  ST X Bool, for some specific type X.
12:14:16 <fasta> Cale: Why can't it mention type s?
12:14:35 <Cale> because the type variable s isn't even in scope when v is created
12:14:47 <emu> do other people find themselves typing things like, given a record type aRecord containing bRecord: aRecordVar { aField = (bRecord aRecordVar) { bField = foo (bRecord aRecordVar) } }
12:15:06 <emu> just wondering if there was a "better way" to deal with records within records
12:15:55 <Cale> fasta: possibly the problem is that there are two s's
12:16:40 <Cale> let's suppose that the first runST had a much more liberal type, and it did something like
12:16:59 <dcoutts__> emu: you can pattern match on the record to extract the field you want when updating the record
12:18:08 <Cale> runST' :: (forall s. ST s (STRef s a)) -> STRef (exists s. s) a
12:18:23 <Cale> and we did
12:18:25 <emu> dcoutts__: isn't that what I wrote though?
12:18:40 <Cale> let v = runST' (newVar True) in runST (readVar v)
12:18:45 <emu> foo { field1 = val } in general
12:18:58 <dcoutts__> emu: no, you're using (bRecord aRecordVar) to extract the component you want to update
12:19:00 <Cale> Then v :: STRef (exists s. s) Bool
12:19:33 <Cale> but then readVar v :: ST (exists s. s) Bool
12:19:53 <Cale> and not forall s. ST s Bool, as would be needed
12:19:57 <emu> yea, ok i could do that elsewhere using a pattern match
12:20:10 <Cale> fasta: does that help?
12:20:21 <fasta> Cale: ok, but now you made up an "exists"
12:20:26 <Cale> sure
12:20:41 <Cale> in fact, there's a particular way you can demonstrate this in GHC with some cheating
12:20:51 <Cale> Prelude Data.STRef Control.Monad.ST>  v <- unsafeSTToIO (newSTRef True)
12:20:51 <Cale> Prelude Data.STRef Control.Monad.ST> :t v
12:20:51 <Cale> v :: STRef GHC.Prim.Any Bool
12:21:58 <fasta> Cale: Are you saying that ST (exists s. s) Bool == ST s Bool?
12:22:13 <dcoutts__> emu: eg: http://darcs.haskell.org/gtk2hs/tools/apiGen/src/AddDocs.hs
12:22:15 <fasta> Cale: I don't hope you are, since that wouldn't make much sense.
12:22:37 <Cale> I'm saying that ST (exists s. s) Bool does not generalise to forall s. ST s Bool
12:22:43 <Cale> that's what the paragraph is saying
12:22:47 <fasta> Cale: Yes, I agree with that.
12:22:50 <Cale> (in some sense)
12:23:13 <fasta> Cale: But I don't see why s would be free in ST s Bool.
12:23:30 <fasta> Cale: in the same way that a->a can be generalized to forall a. a->a
12:23:52 <Cale> s is free in v's type
12:23:57 <Cale> no matter what type v has
12:24:08 <fasta> Cale: yes, you say that, but I don't see that. That's the only problem I have.
12:28:17 <fasta> Cale: I think the point is that parameters to type constructors are mono types, and therefor those are all free.
12:29:15 <Cale> If a variable isn't mentioned in a term, it's free in that term.
12:29:35 <Cale> The point is that there's no way in which s could possibly be mentioned in the type of v
12:30:25 <fasta> Cale: You mean "mentioned in the quantifier list of a term"?
12:47:24 <astrolabe> Does anyone know what the memory overhead of a large list is likely to be?
12:47:39 <kyevan> Is it data Quadruple a a b b = Quadruple a a b b or data Quadruple a a b b = Quadruple a b c d ?
12:47:53 <Cale> kyevan: neither
12:48:07 <kyevan> Cale: Ooh?
12:48:11 <Cale> data Quadruple a b = Quadruple a a b b
12:48:19 * astrolabe tries
12:48:32 <kyevan> Cale: Whe?
12:48:32 <Cale> astrolabe: what do you mean by that?
12:48:56 <Cale> Let me change that slightly to make it easier to discuss
12:48:59 <Cale> data Quadruple a b = Quad a a b b
12:49:11 <Cale> Quadruple is being defined as a type constructor
12:49:11 <astrolabe> Cale: If I have an evaluated list of 1e6 Ints say, how much memory will it use?
12:49:21 <Cale> it has two type parameters, a and b
12:49:29 <Cale> Quad is being defined as a data constructor
12:49:46 <fasta> astrolabe: Not more than for other data structures. I would assume about 10 bytes for one element of the list. You can lookup it in the source of course, but that's about it.
12:49:47 <Cale> it has 4 value parameters, two things of type a and two things of type b
12:50:03 <Cale> astrolabe: and they all have to remain in memory?
12:50:30 <kyevan> Cale: Ooooh
12:50:54 <kyevan> so, the first part isn't what the data structure stores, it's the name, and types it stores?
12:51:04 <Cale> yeah
12:51:11 <kyevan> Ok...
12:51:18 <Cale> the thing on the left of the = is what's being defined at the type level
12:51:34 <Cale> the things on the right of the = are the values which belong to the type you're defining
12:51:49 <kyevan> So, data Foo a b c = Foo a b a b a b c c c a b c would be valid (if confusing)?
12:51:50 <Cale> there's another notation for this which is supported by newer GHCs with extensions turned on
12:51:56 <Cale> yes it would
12:52:04 <Cale> data Quadruple a b where
12:52:11 <astrolabe> Cale. yes
12:52:16 <Cale>    Quad :: a -> a -> b -> b -> Quad a b
12:52:18 <Cale> er
12:52:23 <Cale>    Quad :: a -> a -> b -> b -> Quadruple a b
12:53:18 <Cale> astrolabe: I'd expect a cons cell to cost about one integer, plus a couple of pointers (one to an Int, and one to the next cons cell)
12:53:49 <Cale> the integer in the cons cell is a tag which identifies it as such amongst list-typed values
12:54:11 <astrolabe> Cale thanks, maybe some padding too?
12:54:14 <Cale> So maybe around 12 bytes/cell?
12:54:22 <Cale> I don't know about padding.
12:54:46 <Cale> But check that, and see if it meshes with experiment, I don't *really* know what GHC does.
12:54:57 <Cale> (but I have read the STG machine paper)
12:55:33 <astrolabe> ta
12:56:01 <cjeris> can anybody recommend a baby treatment of the logic/category theory correspondence?  Taylor "Practical foundations of mathematics" and Lambek/Scott "Intro to higher order categorical logic" are making my head explode.
12:56:33 <cjeris> or should i just shut up and take it? :)
12:56:51 <Cale> honestly, I don't know :)
12:58:18 <cjeris> Taylor is interesting but it's so dense and cross linked that I never know if I don't get something because he hasn't talked about it yet, because he isn't going to talk about it exactly, or because I just don't get it.
12:58:39 <Cale> The problem with teaching category theory to CSers at the moment is that there hasn't been a lot of time to develop teaching materials directed at computer science people. I suspect the same goes to some extent for logicians, but logicians are usually people who've gone through pure mathematics.
12:59:03 <Cale> plus, that's pretty rarified stuff
12:59:08 <Cale> even for pure math
12:59:21 <fasta> Cale: What does "quantfied type variable `s' escapes" exactly mean in general?
13:00:00 <fasta> quantified, even
13:00:31 <cjeris> eh, i'm still more a mathematician than a computer scientist, I just never know whether Taylor is handwaving or I'm dumb.  usually assume the latter.
13:00:39 <Cale> ah, okay
13:00:52 <Cale> I haven't looked at those specific references
13:00:53 <pejo> astrolabe, doesn't the bytestring paper by dons and others give some figures for Strings?
13:01:03 <Cale> (and I don't really know anything about categorical logic0
13:01:03 <Cale> )
13:01:13 <dcoutts__> pejo: yeah, a few example numbers
13:01:17 <astrolabe> pejo: do you have a link please?
13:01:29 <astrolabe> I make it about 80 Bytes per Int
13:01:37 <pejo> @where dons
13:01:37 <lambdabot> http://www.cse.unsw.edu.au/~dons
13:01:49 <dcoutts__> astrolabe: erm, lemme think. I calculated it for the paper.
13:01:52 <pejo> Oh, dcoutts is here. Even better. :-)
13:02:00 <jmg> hi
13:02:01 <fasta> Cale: or is it simply that the scope of s is supposed to be only the first argument of runST, but when used in this way, it isn't and thus "escapes" the scope?
13:02:08 <bd_> è‡ªåˆ†ã®å¦„æƒ³ã«ä¿ºã‚’å·»ãè¾¼ã‚€ãªï¼ã€€ãŸã... <-- fixed
13:02:10 <bd_> er
13:02:12 <dcoutts__> astrolabe: it's 3 words for the list cell, and 2 words for a boxed Int
13:02:14 <bd_> wrong channel >.<
13:02:14 <pejo> (Think the paper said 20 bytes, but 12 for special treatment of [Char], but I might be off).
13:02:22 <kyevan> bd_: Way to go.
13:02:37 <kyevan> You actually managed to get it to the right person, in the wrong channel.
13:02:40 <astrolabe> pejo: gratzie
13:02:42 <ndm> pejo: yes, you don't pay for a boxed char for the first 255 letters
13:02:43 <dcoutts__> astrolabe: so for a 32bit box that's 4 * 5 bytes
13:02:56 <jmg> hello everybode, is there anyone who knows how to compile happy on MacOSX/Intel?
13:03:06 <Cale> fasta: Well, if a is unified with something which mentions what s is unified with, then the s would escape from the forall s. along with a
13:03:06 <ndm> jmg: do you have Cabal?
13:03:11 <dcoutts__> pejo: yep, it would be 20 except the first 256 Char's are pre-allocated
13:03:20 <jmg> nmd: I installed ghc-6.6 today
13:03:33 <astrolabe> dcoutts_: thanks
13:03:46 <jmg> ndm: what else do I need to have Cabal?
13:03:47 <dcoutts__> astrolabe: so if you've got lots of Ints then consider using a UArray
13:03:59 <ndm> jmg: you should have Cabal then
13:04:20 <ndm> jmg: download the source, "runhaskell Setup configure", "runhaskell Setup build", "runhaskell Setup install", from the root of the happy directory
13:04:33 <jmg> ndm: ok, I tried an install frome the source package, but that failed with an configure error
13:04:49 <Taraxis> deja vu
13:05:03 <astrolabe> dcoutts: good plan
13:05:25 <pejo> jmg, 1.15 doesn't work, try the 1.16rc or similar, and do like ndm said.
13:05:30 <jmg> ndm: Could not find module `Setup':
13:05:43 <astrolabe> dcoutts__: I don't understand why you said 'for a 32bit box'
13:05:43 <jmg> pejo: I indeed tried 1.15
13:05:45 <Cale> For instance, if we were to apply runST to something of type ST () Bool, for example
13:05:56 <astrolabe> Ah yes I do
13:05:56 <ndm> jmg: go the the folder for happy with Setup.hs in it, and do the things there
13:05:59 <astrolabe> sorry
13:06:06 <dcoutts__> astrolabe: a word is 64bit on a 64bit box (at least according to GHC)
13:06:17 <Cale> er, no
13:06:20 <dcoutts__> astrolabe: so on a 64bit box it'd be 40 bytes for [Int]
13:06:24 <Cale> For instance, if we were to apply runST to something of type ST s s
13:06:33 <Cale> that's a better example :)
13:06:40 <astrolabe> dcoutts: two meanings of 'box' and too many units :)
13:06:48 <dcoutts__> heh
13:06:51 <dmead> mmmm box
13:06:56 <jmg> pejo: 1.16rc is not on http://www.haskell.org/happy/
13:06:57 <lambdabot> Title: Happy: The Parser Generator for Haskell
13:06:59 <Cale> then a and s become the same type
13:07:25 <dcoutts__> astrolabe: GHC's memory layout is done in units of words which is either 4 or 8 bytes depending on your arch.
13:07:39 <Cale> but s is meaningless outside the scope of the parameter to runST
13:07:54 <kyevan> ?paste
13:07:55 <lambdabot> http://paste.lisp.org/new/haskell
13:07:56 <dcoutts__> astrolabe: and a box has a one word header followed by the real content
13:08:03 <pejo> jmg, http://haskell.org/happy/happy-1.16rc2.tar.gz
13:08:15 <dcoutts__> astrolabe: hence an Int is 2 words, one for the cell box, one for the Int#
13:08:17 <Cale> It's rather like the situation where in a C program, you allocate some variable on the stack, and then return a pointer to it.
13:08:30 <Cale> In some rather abstract way :)
13:08:42 <astrolabe> dcoutts: it all makes a weird kind of sense
13:08:57 <fasta> Cale: so, it(=s) escapes the scope of the first argument of runST like I said?
13:09:04 <astrolabe> dcoutts: but I wonder why ghci seems to be using 4 times as much
13:09:05 <Cale> yeah
13:09:05 <dcoutts__> astrolabe: similarly a (:) cell is 3 words, 1 cell header, 1 for the head pointer and 1 for the tail pointer
13:09:21 <dcoutts__> astrolabe: no idea about what ghci is doing
13:09:47 <lisppaste2> kyevan pasted "Type stuff" at http://paste.lisp.org/display/31710
13:09:56 <astrolabe> dcoutts: I might be being stupid and using a recursive fn to force the list to be evaluated
13:10:12 <kyevan> So, uh, are those type signatures right? GHC accepts them, at least, but...
13:10:36 <dcoutts__> astrolabe: if you've got a long list, being lazy is definitely a virtue
13:11:07 <astrolabe> dcoutts: yes!
13:11:55 <jmg> ndm, pejo thanks for your help. it's working now
13:13:50 <astrolabe> hmmm down to 40Bytes per Int
13:14:26 <astrolabe> I assume my PC is 32 bit
13:16:14 <Cale> fasta: another way to look at it, the specialised type for runST at which you were applying it to a value of type ST s s would become something like: (forall s. ST s s) -> s, but that's not right, because that s is supposed to be the same as the one quantified by the forall s
13:17:25 <yip> i have a question about STM!
13:17:43 <fasta> Cale: You mean that it should hold for all s, but now it only holds for one at a time?(I am saying it a little vague)
13:18:12 <fasta> Cale: the "one at a time" is the return type of runST
13:18:41 <Cale> fasta: I mean that because of unification, if we're not careful, the s bound by the forall s there is escaping into the return value of runST
13:18:58 <Cale> but it's out of scope there
13:19:36 <fasta> Cale: yes, but it cannot ever be the same.
13:20:15 <Cale> right, but it would have to be in order to apply runST to something of type ST s s, which is why that's a type error
13:21:23 <shapr> musasabi is sick but still alive!
13:23:13 <astrolabe> yip: I predict it won't get answered, unless you ask it.
13:23:23 <fasta> Cale: yes
13:24:23 <jmg> hi, could you help me again, please. I am trying to install alex now. The src-tarball does not configure on osx/intel either and the darcs fails with darcs failed:  Error applying hunk to file ./examples/makefile
13:26:40 <yip> let's say i have a printer and i have a printPage :: Page -> IO (). now i want to write a function printPages :: [Page] -> IO (), that should be atomic, meaning that if i call it in two threads at the same time, then one of the calls should block until all of the pages of the other thread have been printed, and only then it should start printing it's pages. the only way i can think of doing this with STM is to simulate locks
13:28:26 <Cale> Well, you absolutely cannot construct a transaction which does IO
13:28:50 <Cale> If you had printPage :: Page -> STM ()
13:28:55 <Cale> then it would be different
13:28:55 <yip> yes i understand
13:29:13 <SamB> Cale: what about unsafeIOToSTM?
13:29:19 <SamB> @hoogle iotostm
13:29:20 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
13:29:23 <Cale> SamB: that would be unsafe here
13:29:35 <Cale> It would be worse than no locking at all.
13:29:45 <SamB> you said "absolutely cannot"
13:30:06 <SamB> not "it would do really really bad things always"
13:30:12 <yip> what STM needs, is another form of atomic, that somehow figures out how to automatically block, instead of using a roll-back mechanism
13:30:16 <Cale> right, unsafeIOToSTM just lets you break the typesystem here, it's not actually useful
13:30:55 <Cale> yip: you could use a channel-based print queue
13:31:21 <Cale> and have an action for atomically installing a new list of pages to the end of that queue
13:32:18 <yip> right, but that's not the semantics that i am interested in
13:32:44 <yip> i want a thread to be able to do: printPages x >> askUser "everything print ok?"
13:33:14 <Cale> you want printPages to block until all the pages are actually printed?
13:33:18 <yip> yes
13:33:23 <Cale> then you want a lock
13:33:28 <yip> right
13:33:31 <Cale> use an MVar
13:33:44 <yip> but then i must deal with all of the problems that are associated with locks
13:33:53 <yip> i am wondering if the ideas of STM can be also useful in IO settings
13:33:57 <Cale> well, that's the semantics you want though
13:34:09 <Cale> the problem with locks are in the semantics they create
13:34:14 <Cale> problems*
13:34:56 <Cale> Here's what you can do to make it fairly safe though
13:35:30 <Cale> You construct a single MVar, say called printer
13:35:46 <Cale> then you write a function  withPrinterDo :: IO a -> IO a
13:36:14 <Cale> which takes the MVar, and puts it back after running the IO action
13:36:18 <SamB> mvars are about the safest kind of locking structure you can get, I think
13:36:34 <kyevan> Does Haskell support numbers in bases other than 10?
13:36:43 <glguy> > 0xFF
13:36:44 <lambdabot>  255
13:36:44 <Cale> kyevan: yes
13:36:47 <kyevan> (without some sort of trickery to convert?
13:36:48 <SamB> haskell doesn't support bases!
13:37:13 <SamB> well, with Data.Bits I guess it supports base 2
13:37:50 <kyevan> then how do you explain 0xff?
13:38:11 <Cale> > 077
13:38:13 <lambdabot>  77
13:38:16 <Cale> hehe
13:38:17 <glguy> > showHex 255 ""
13:38:18 <lambdabot>  "ff"
13:38:19 <Cale> > 0o77
13:38:20 <lambdabot>  63
13:39:56 <glguy> > [x | (x,"") <- readHex "ff"]
13:39:58 <lambdabot>  [255]
13:41:03 <yip> Cale: but what if i want to do something like, atomic ( printPages x >> printPages y ), so that no page can be printed between the x and y set of pages? i will need to "go inside" the implementation details of printPages in order to lock... i don't get any of the advantages of composability that STM has
13:41:36 <monochrom> <3 haskell
13:41:57 <Cale> yip: sure, you don't
13:42:02 <kyevan> OWCH! Someone write a PDF viewer that can invert colors to get light-on-dark!
13:42:12 <yip> Cale: so do you think it's possible to have a similar system of STM that can also work with IO?
13:42:25 <Cale> yip: you can have an extremely inefficient one
13:42:40 <Cale> where atomic blocks stop all other threads
13:42:59 <glguy> are you telling him about how you can't do IO inside STM?
13:43:06 <Cale> right
13:43:15 <glguy> where can't is not an absolute :)
13:43:32 <Cale> I'd say it pretty much is
13:43:34 <glguy> shouldn't maybe?
13:44:01 <glguy> I was just thinking that there is always an unsafe way to force stuff to happen
13:44:12 <Cale> There are hooks into the RTS you can use to force it to happen, but then you're not really using STM, you're using some crazy variant of it which you've invented.
13:44:31 <yip> Cale: i think you have a smarter implementation that only stops threads from entering atomic blocks that will conflict with current execution of other atomic blocks
13:44:40 <Cale> and that crazy variant will usually not have any nice properties at all
13:44:41 <monochrom> unsafeVarySTMSemantics
13:44:45 <yip> Cale: *could* have
13:44:47 <kyevan> Is there a way to have something automaticly construct show for a type you define?
13:44:56 <chr1s> hey!
13:44:56 <bd_> glguy: One thing you could do is use STM to queue up IO commands, then execute them in another thread once you commit
13:45:07 <bd_> kyevan: stick: deriving (Show) onto the end of your data definition :)
13:45:11 <Cale> bd_: yeah, that's what I recommended
13:45:12 * monochrom sees a pattern.
13:45:17 * glguy wasn't advocating using unsafe functions
13:45:23 <chr1s> I'm playing around with Parsec, and I made a lexer with makeTokenParser
13:45:23 <bd_> kyevan: it works on a number of other classes too :)
13:45:23 <SamB> yip: you mean *could* conflict
13:45:29 <yip> SamB: right
13:45:31 <glguy> I just hate to say "you can't do this" when techincally you can break it and do it
13:45:41 <chr1s> but I can't figure out how to test the lexer
13:45:48 <Cale> yip: create a thread which does nothing but read from a channel of pages and print each
13:46:08 <emu> chr1s: the lexer defines basic combinators which you construct your parser from
13:46:12 <kyevan> bd_: so, "data Tuple a b c d = Tuple a | Tuple a b | Tuple a b c | Tuple a b c d deriving (Show)"?
13:46:19 <bd_> kyevan: yep
13:46:19 <emu> chr1s: these combinators are parameterized by the result of makeTokenParser
13:46:21 <SamB> don't most people like their printouts to be in order?
13:46:24 <Cale> (an STM channel)
13:46:30 <Cale> and then pass a writer to that channel which queues up a consecutive block of pages
13:46:33 <bd_> kyevan: it'll only derive it if a, b, c, and d are Show of course
13:46:46 <monochrom> "There are ways you can force 5/0 to have an answer, but then you are not really doing the field of the reals, you are doing some crazy variant of it which you are definitely not the first one to invent, and usually the crazy variant will not have any nice properties at all."
13:46:48 <Cale> and then you have something which uses STM to get the semantics you want
13:46:56 <chr1s> ah, so should I parametrize "reserved" with the makeTokenParser result?
13:47:01 <yip> Cale: i'm not sure i'm convinced
13:47:04 <emu> chr1s: i'll show you what i usually do
13:47:06 <Cale> however, that's not enough to get that blocking
13:47:07 <chr1s> cool
13:47:23 <kyevan> Oh, wait
13:47:25 <SamB> monochrom: what if you are working in some crazy non-real system anyway ;-)?
13:47:29 <Cale> so what you might do is to include in the channel, IO actions to be run by the other thread
13:47:40 <kyevan> Can you not have multiple constructors named the same thing?
13:47:53 <kyevan> (like: "data Tuple a b c d = Tuple a | Tuple a b | Tuple a b c | Tuple a b c d deriving (Show)", for example!)
13:47:54 <Cale> so you can pass a continuation in which pops up a dialog box with "Did everything print ok?" and so on.
13:48:06 <Cale> kyevan: no
13:48:09 <bd_> kyevan: You can't; since Tuple is a function, it can't have those ambiguous types[1]
13:48:15 <bd_> [1] - unless you do crazy typeclass hacks
13:48:28 <SamB> yeah, you can never count on blocking until stuff actually prints
13:48:29 <kyevan> Oh.
13:48:32 <kyevan> Ok :(
13:48:45 <bd_> kyevan: Usually you don't need to
13:48:55 <bd_> kyevan: in fact, usually you want to very much the opposite
13:48:56 <Cale> kyevan: if you want to do this, you can create a typeclass
13:49:06 <yip> Cale: they claim that STM is a "quantum leap" from locks and mutexes, and it does look really great, but it seems to be severely limited by the IO restriction
13:49:21 <SamB> print queues tend to mess that up
13:49:23 <kyevan> Cale: I'm just doing an exercise from YAHT :P
13:49:34 <glguy> quantum leap doesn't mean "huge" it means "sudden"
13:49:46 <lisppaste2> emu pasted "usage of Token lexers" at http://paste.lisp.org/display/31714
13:49:56 <bd_> yip: well, it's required in order for it to be able to safely redo the operation
13:49:58 <Lemmih> yip: Not mixing IO in everything is considered a feature in Haskell (:
13:50:00 <SamB> kyevan: try Tuple1 Tuple2 Tuple3 etc.
13:50:01 <monochrom> Outside IO do you need STM?  Not really, outside IO you have no mutation to talk of.
13:50:03 <yip> bd_: i understand
13:50:11 <emu> chr1s: keep in mind, i basically extracted this from the Manual, which covers it pretty well
13:50:25 <Cale> kyevan: I know you are
13:50:53 <monochrom> TupleUno, TupleDuo, TupleTrio, ...
13:50:59 <glguy> "The thing about quantum leaps is that they mark an abrupt change from one state to a distinctly different one, with no in-between transitional states being possible; but they are not large. In fact, in physics a quantum leap is one of the smallest sorts of changes worth talking about. Leave Ã¢Â€Âœquantum leapÃ¢Â€Â to the subatomic physicists unless you know what youÃ¢Â€Â™re talking about." -- http://www.wsu.edu/~brians/errors/quantum.html
13:51:00 <Cale> yip: even with that restriction, it is
13:51:01 <lambdabot> Title: quantum leap
13:51:06 <glguy> I love that website
13:51:24 <Cale> glguy: exactly
13:51:32 <yip> glguy: well, they also say that the difference is like c and assembler, which i understand as "huge"
13:51:32 <emu> chr1s: the thing to remember about the lexer combinators: they all skip whitespace after parsing their thing. that's why you need whiteSpace at the beginning
13:51:42 <bd_> kyevan: anyway, tuples are actually built-in with special syntax, so outside of exercised you usually don't need to have the same name for all the constructors :)
13:51:45 <Cale> well, it is a fairly big step
13:51:50 <zeeeeee> is there an Ordered List data structure avail. for haskell?
13:52:01 <Cale> You can atomically queue up IO actions to run, how's that?
13:52:07 <emu> zeeeeee: Sets do?
13:52:25 <Cale> There's Set and Map
13:52:37 <zeeeeee> emu, Cale: thanks
13:52:39 <monochrom> need multiset
13:52:42 <SamB> yip: huge?
13:52:48 <scodil> so if a StablePtr is guaranteed not to get moved/gc'd, then does that mean that memory allocated with malloc/alloca does get moved around? how does that work?
13:53:05 <SamB> not that huge. well, basically the main difference is that C lets you stop doing register allocation and stack tracking...
13:53:42 <Lemmih> scodil: Memory allocated with malloc/alloca does not get relocated.
13:53:49 <kyevan> glguy: What about when you are talking about weird scifi TV shows?
13:53:55 <Lemmih> scodil: Only closures do.
13:54:00 <yip> Cale: ok, now what if i want: print "waiting for printer to be available" >> atomic (printPages foo >> askUser "print ok?")
13:54:02 <zeeeeee> in concurrent haskell, i have a bunch of tasks running in parallel, each with an ID #. i would like to get their results in order of their ID #s. what's the best way to do this?
13:54:10 <glguy> kyevan: the kind that make up physics as they go?
13:54:20 <yip> Cale: now i need another continuation or whatever
13:54:27 <zeeeeee> (the sequence of tasks is infinite)
13:54:27 <scodil> so whats the difference between a StablePtr and a Ptr allocaed with malloc?
13:54:34 <yip> Cale: composability is crap :'(
13:54:49 <SamB> yip: no
13:54:50 <bd_> yip: printPages is an IO action, though, isn't it?
13:54:58 <bd_> yip: What would the semantics of atomic be there?
13:55:05 <chr1s> emu: aha! I think I get it now!
13:55:09 <chr1s> thanks :)
13:55:10 <SamB> don't try to print atomically!
13:55:16 <yip> bd_: semantics would be to block
13:55:19 <SamB> at least, not in STM
13:55:33 <yip> SamB: well that's my point, STM could be better
13:55:42 <monochrom> This example is strange.  Usually I ask for permission to print, and then I wait for printer.  The permission doubles as permission to potentially wait forever.
13:55:45 <kyevan> glguy: Specificly, the weird scifi tv show titled "Quantum Leap"
13:55:50 <kyevan> but, yes :P
13:55:54 <SamB> yip: STM is not for printing silly
13:55:58 <bd_> yip: you're asking it to do something it's not meant to do, surely? Use a MVar to hold the results of the print and block using that
13:56:09 <Cale> STM just isn't for this
13:56:12 <glguy> kyevan: maybe in the physics as defined in that fictional universe, a quantum leap is much different :-D
13:56:13 <SamB> no formalism can help you print
13:56:14 <yip> bd_: now i'm back in locking hell, the problem that STM is meant to solve!
13:56:19 <SamB> I mean, not like that
13:56:29 <kyevan> glguy: But, can I talk about the TV show?
13:56:30 <Cale> You can do things like atomically queuing actions to be run, which ought to be good enough
13:56:30 <glguy> yip: is it possible that you don't understand what STM is supposed to solve?
13:56:39 <kyevan> (And yes, practiacly the oposite of ours :P)
13:56:42 <Lemmih> scodil: A StablePtr is just a number that can be used as a constant ID for a closure.
13:56:43 <SamB> truly, the only way to really know you got it to print is to actually ask the user!
13:56:47 <monochrom> I think yip's printng example is poor.
13:56:47 <SamB> and then trust the answer!
13:56:55 <glguy> kyevan: everyone is feel to exists outside of "reality" :)
13:57:00 <Cale> You can start up a thread which does nothing but read from a channel of IO actions to be performed, and then atomically write things into that channel.
13:57:05 <bd_> yip: well, if you prefer, you can use TVars to transfer data as well; you'd do something like atomic (queueForPrint tvarForResult); atomic (readTVar tvarForResult >>= \r -> when (isNothing r) retry >> return r)
13:57:28 <yip> anyway, i'll have to think about this more i guess
13:57:32 <yip> thank you everyone!
13:57:35 <Cale> use a TChan (IO ())
13:57:39 <scodil> Lemmih: oh I get it, StablePtr doesn't imply Storable, right?
13:57:47 * yip sleeps
13:58:14 <monochrom> And what is the alternative?  You wait for a lock, then you acquire the lock, then you ask for permission?  Then the user goes home and therefore all other clients have to wait for this bastard to come to work tomorrow?
13:58:23 <Lemmih> scodil: That's right, StablePtr is not an instance of Storable.
13:59:02 <monochrom> I mean why in hell are you waiting for user input in a critical section?
13:59:38 <SamB> @instances-importing Foreign Storable
13:59:39 <lambdabot> Bool, Char, Double, Float, FunPtr a, Int, Int16, Int32, Int64, Int8, Ptr a, StablePtr a, Word, Word16, Word32, Word64, Word8
13:59:45 <SamB> Lemmih: um
13:59:46 <monochrom> Is this an attempt to write Haskell code that will make it to the headlines of thedailywtf?
13:59:59 <SamB> Lemmih: it would seem that you are wrong!
14:00:05 <monochrom> "Asking User for OK is Very Critical!" ?
14:00:08 <scodil> StablePtr a is storable, not a
14:00:11 <Lemmih> Urk.
14:00:38 <scodil> Ptr a imples Storable a, StablePtr a does not imply Storable a...right?
14:00:54 <Lemmih> scodil: That's right (I'm sure this time).
14:00:56 <SamB> um.
14:01:11 <SamB> @type Foreign.nullPtr
14:01:13 <lambdabot> forall a. GHC.Ptr.Ptr a
14:01:20 <SamB> so...
14:01:31 <SamB> does that imply Storable a?
14:01:48 <Pupeno> What do I have to make patterns such as: "allocUnboxed elems :: m (MUVec s a) = ..." work on GHC 6.6 ?
14:01:59 <scodil> i may be misuing the word "imply"
14:02:13 <Lemmih> scodil: (except that 'Ptr a' doesn't imply 'Storable a')
14:02:17 <SamB> scodil: now, actually peeking/poking *does*
14:02:54 <scodil> got it
14:03:08 <SamB> but you could easily be dealing with a C API where you aren't allowed to dereference the pointer
14:03:22 <scodil> yeah or Ptr ()
14:03:25 <SamB> (because you don't know the layout of what it points to)
14:03:49 <SamB> (or at least aren't supposed to make assumptions about it)
14:04:20 <SamB> (not that you couldn't make some things like that Storables)
14:05:54 <Lemmih> scodil: StablePtr's are used when you want to store Haskell closures in C land. The Haskell closures are constantly moving around so storing their address wouldn't be of much use. That's why we have StablePtr's. They give us a constant (non-changing) value that can identify the current address of a Haskell closure.
14:08:27 <scodil> so what are the advantages of using IORefs instead of Ptrs? just type safety?
14:09:05 <SamB> (a) they work on anything (b) you don't have to copy/repack the data
14:10:42 <SamB> the original point of Ptrs is for interfacing with C
14:11:08 <Heffalump> what else would you use them for?
14:11:45 <SamB> well, you could use them for... writing a normal BF interpreter?
14:12:08 <SamB> you know, the kind for people who like to live dangerously ;-)
14:12:38 <SamB> they are a lot nicer than Addr#s!
14:12:41 <SamB> more portable, too!
14:12:47 <Heffalump> why would you want to use those either?
14:13:01 <scodil> if you wanted to have a mutable graph, but didn't want to embed it in an array, maybe. that's what i was thinking at least
14:13:48 <SamB> Heffalump: well, to implement packed strings, maybe!
14:14:00 <Heffalump> ah, true
14:14:04 <SamB> nevermind that you will end up interfacing with C in the end
14:14:09 <SamB> most likely
14:14:19 <SamB> (for some function or other)
14:15:22 <lisppaste2> glguy pasted "speaking of bf interpreters" at http://paste.lisp.org/display/31718
14:16:08 <Heffalump> SamB: that's not a reason to use Ptr and Addr all over your code though
14:16:23 <SamB> it looks a bit longer than mine, maybe...
14:16:48 <SamB> probably because it imports so many things!
14:16:57 <glguy> I wasn't going for tiny
14:17:01 <glguy> I was just playing around
14:17:05 <SamB> ah
14:17:17 <glguy> I was showing a friend parsec
14:17:17 <SamB> @oldwiki ShortExamples/BFInterpreter
14:17:18 <lambdabot> http://www.haskell.org/hawiki/ShortExamples/BFInterpreter
14:17:50 <glguy> Mine attempts to optimize bf programs a little
14:17:57 <monochrom> does the friend know bf?
14:18:04 <glguy> yeah, he knows of it
14:18:10 <glguy> not how to write his own programs in it
14:18:30 <monochrom> Is bf a regular language?
14:18:50 <SamB> um, it has nesting
14:19:12 <glguy> I optimize out chains of the same functions
14:19:23 <SamB> ah
14:19:24 <glguy> and I turn [-] into a "Set cell to 0"
14:19:35 <kyevan> Hmmm
14:19:55 <glguy> because it will decrement the cell until it becomes 0
14:20:03 <glguy> and is a common bf occurance
14:20:04 <SamB> what about multiplication?
14:20:11 <glguy> I don't detect for it
14:20:16 <glguy> I could
14:20:32 <kyevan> How would I define a type signature for a function that takes one thing (a Tuple, which is a data type, not the normal haskell one)?
14:20:39 <kyevan> (I know how to do the return part already)
14:21:01 <SamB> why don't you write the function, and then ask the compiler?
14:21:16 <monochrom> f :: Tuple -> ____
14:21:18 <emu> @type fromEither
14:21:19 <lambdabot> Not in scope: `fromEither'
14:21:31 <Heffalump> @type fromJust
14:21:33 <lambdabot> forall a. Maybe a -> a
14:22:21 <emu> (one of the improvements to haskell-mode i added was a function to get the type of expression and insert it appropriately on the line above, nice for annotating functions quickly)
14:22:24 <glguy> :t either
14:22:25 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
14:23:28 <kyevan> emu: Would be nicer if it worked in my editor-of-choice, which isn't emacs (Although I see why some people like emacs... it isn't for me)
14:23:48 <emu> well that's presupposing vim had an inferior-haskell mode, which afaik, it doesn't
14:24:00 <emu> but if it did, i'd sure be glad to give it a shot
14:24:41 <monochrom> how do you get the type of an expression?
14:25:17 <emu> asking ghci
14:25:30 <emu> works in hugs too, i think
14:25:39 <Heffalump> :t
14:25:50 <kyevan> emu: Do it as a vim script. Take the line the cursor is on, get the type, insert it on the line above.
14:25:57 <monochrom> So if the module doesn't type-check yet, it won't get the type.
14:26:12 <emu> kyevan: the whole "get the type" bit is the hard part
14:26:26 <emu> monochrom: right. i try to program while keeping the code type-consistent
14:26:29 <kyevan> emu: Right :P
14:26:37 <SamB> emu: I don't think vim is an OS, though
14:26:50 <emu> well, people have demonstrated stuff like slim-vim
14:27:07 <emu> i'm not asking it to be an OS, just an IDE ;)
14:27:21 <kyevan> SamB: Modern Vim does damn near anything emacs does, really
14:27:41 <emu> except nobody seems to have written the interaction modes
14:27:54 <SamB> kyevan: does it validate XML?
14:27:55 <monochrom> does vim provide a command for opening a tcp connection?
14:28:02 <SamB> using a Relax NG Compact schema?
14:28:04 <emu> kyevan: is there an nxml-mode equivalent?
14:28:04 <kyevan> SamB: It could be done.
14:28:20 <kyevan> emu: One could be written.
14:28:25 <emu> i'm sure
14:28:29 <kyevan> (In a language other than elisp, too!)
14:28:30 <emu> some day
14:28:36 <SamB> emu: did you say that because of what I said, or where you thinking that on your own?
14:28:38 * emu keeps editing
14:28:52 <emu> SamB: no, i just wanted to emphasize the concreteness of this editing mode
14:29:00 <emu> (which you mentioned)
14:29:05 <SamB> ah
14:29:23 <kyevan> Well, remember, vim is a touch more one-thing than emacs
14:29:29 <monochrom> what language do you write to add things to vim?
14:29:32 <SamB> it does really neat underlining of errors and stuff
14:29:35 <kyevan> (It does NOT have a psychoanylist, for example!)
14:29:37 <SamB> also autocompletion
14:29:47 <SamB> kyevan: this is our point!
14:30:01 <emu> vim users must be crazy! they don't have access to a psychoanalyst!
14:30:03 <SamB> *could* it have a psychoanalyst?
14:30:10 <kyevan> monochrom: Usually vimscript, but python, perl, ruby, and some others are available)
14:30:11 <SamB> emu: it isn't a very good one anyway
14:30:14 <kyevan> emu: Sure we do.
14:30:23 <SamB> kyevan: how?
14:30:25 <monochrom> emacs users must be crazy! they need a psychoanalyst!
14:30:30 <emu> indeed
14:30:30 <kyevan> Run vim in screen, ctrl-a c, run a stand alone one.
14:30:41 <SamB> monochrom: the psychoanalyst keeps us laughing
14:30:47 <SamB> laughing keeps us sane!
14:30:49 <monochrom> Can vimscript open a tcp connection?
14:30:50 <emu> you can play Tetris in emacs
14:30:52 <kyevan> But, validation of XML would be done in vim as a call to an external app.
14:31:00 <kyevan> emu: You can play tetris in vim
14:31:06 <emu> woot, killer app
14:31:09 <kyevan> The script's on the vim website :P
14:31:09 <SamB> kyevan: oh, like what app?
14:31:13 <glguy> I can play tetris with tetris(6)
14:31:19 <SamB> I don't know an app that can do rng validation!
14:31:23 * monochrom thinks the answer is no, since no one is brave enough to answer it.
14:31:24 <emu> pshaw, you ain't playing til yer playing in an editor
14:31:29 <kyevan> SamB: Like, a stand alone elixa :P
14:31:32 <emu> monochrom: what does slim-vim do?
14:31:40 <monochrom> I don't know slim-vim.
14:31:51 <monochrom> what does HOL do?
14:31:55 <kyevan> emu: Emacs doesn't even use the GNU standard extention language!
14:31:59 <SamB> kyevan: wouldn't you need to install BASIC to run that?
14:32:01 <glguy> yeah... but emacs users have to use emacs...
14:32:04 <emu> kyevan: hehe, guile-emacs was tried....
14:32:07 <SamB> kyevan: hah
14:32:10 <SamB> scheme is stupid
14:32:13 <kyevan> (I'm pretty sure Vim does suport it)
14:32:15 <emu> CL-emacs is a better bet
14:32:20 <dcnstrct> sam8, thems fightin words
14:32:25 <SamB> well.
14:32:27 <emu> but you can't displace Emacs... it's too strong
14:32:41 <SamB> it wouldn't run the existing body of code, more to the point ;-)
14:33:00 <SamB> and probably it is too clean to be usable for editor scripting ;-)
14:33:35 * dcnstrct hugs TextMate
14:33:44 <emu> elisp sucks, but it's easy enough to script in, and it "good enough" that nobody is motivated to really rewrite everything
14:33:51 <monochrom> You can make CL-emacs to understand both lisps.  Distinguish them by filenames.  x.el is elisp, x.cl is common lisp.
14:34:09 <SamB> isn't CL-emacs called something else?
14:34:19 <SamB> doesn't it sort-of come with CMUCL?
14:34:20 <emu> there's CMUCL-emacs which is called Hemlock
14:34:25 <SamB> ah, that one yes!
14:34:32 <emu> LispWorks IDE is based on Hemlock supposedly
14:34:46 <emu> there's Lisp machine editors written in Zeta-Lisp: zMacs and friends
14:35:06 * kyevan misses drscheme when he's working in haskell
14:35:08 <emu> eine and zwei
14:35:23 <kyevan> It's such a nice system to work in
14:35:47 <emu> Genera had the Dynamic Windows system which was a very nice interactive environment to work in
14:36:01 <emu> of which CLIM is a pale shadow
14:36:48 <monochrom> Miranda IM is emphatically not implemented in Miranda...
14:37:23 <SamB> I thought CLIM was an API
14:37:34 <SamB> not actually a concrete implementation
14:37:40 <emu> yes
14:37:49 <emu> it's a specification for such systems
14:38:12 <monochrom> You can rewrite the sentence as "any implementation of CLIM is a pale shadow"
14:38:40 <monochrom> In the same way that by "C is hard to use" you mean "any implementation of C is hard to use".
14:39:02 <emu> no, I was saying that CLIM was based on Dynamic Windows and ended up being lesser
14:39:56 <kyevan> Is there any reason darcs seems to be so popular with haskell people?
14:40:05 <emu> it's written in Haskell
14:40:06 <Heffalump> cos it's really easy to use
14:40:08 <psnl> happy, intel macs, can it be got to build?
14:40:14 <emu> it's a good system
14:40:18 <Heffalump> and Haskell users like that :-)
14:40:20 <Taral> ?seen JohnMeacham_
14:40:21 <lambdabot> JohnMeacham_ is in #haskell and #haskell-blah. I last heard JohnMeacham_ speak 11h 48m 32s ago.
14:40:36 <Heffalump> It has some quite substantial flaws though, I'm surprised so many people put up with them
14:41:06 <emu> i use it for personal projects, so I don't run into problems really
14:41:24 <kyevan> Heffalump: I've yet to encounter problems with it, and I've used it a small but decent amount
14:41:31 <emu> i tried to import a 400MB CVS repository, that didn't quite work
14:42:32 <Heffalump> primarily, it copes badly with (a) large repos (b) Windows (c) repeated conflicts
14:42:48 <emu> yes, it doesn't run quite under MinGW
14:43:10 <SamB> Heffalump: because the source is so horrible we don't want to *fix* them?
14:43:23 <Heffalump> SamB: fix what
14:43:23 <Heffalump> ?
14:43:24 <SamB> also (d) --partial
14:43:30 <SamB> Heffalump: problems!
14:43:32 <emu> i'm not sure how well the conflict resolution works when multiple patches from multiple people come together
14:44:12 <Heffalump> SamB: the conflict problems are hard to solve and the people with the knowledge to make progress all seem busy
14:44:32 <SamB> Heffalump: oh, those, well, how can you not put up with it
14:44:44 <Heffalump> large repos and windows are "just engineering" that noone has done
14:44:55 <emu> i work on a project using svn with a large repository, branches, and a number of people.  it's not hunky dory. i usually have to rescue them.
14:45:41 <SamB> --partial is just buggy
14:45:44 <Heffalump> emu: it'll work better in darcs, cos darcs actually tries to track what happened
14:45:47 <emu> there are lots of times where people say "well I want these changes, these changes, and those changes, in my branch, but nothing else"
14:45:55 <emu> Heffalump: yep!
14:46:04 <Heffalump> it's just it throws a wobbly when you have lots of conflicts on top of each other
14:46:11 <emu> and then i say "...mumble..wish were using darcs..."
14:46:12 <Heffalump> and there is no good way to get out of trouble
14:46:29 <Excedrin> what's the difference between CL-emacs and Climacs?
14:46:52 <emu> Excedrin: when i say "CL-emacs" I just mean the notion of an emacs-like editor written in CL
14:47:02 <monochrom> Climacs is when you watch a movie and it gets to the bottomline? :)
14:47:42 <emu> yikes, its getting late
14:48:27 <Excedrin> emu: oh, I thought it was another project to make an emacs in/with CL
14:48:46 <kyevan> Is there a nice Haskell IDE, or an IDE that works
14:48:54 <kyevan> Is there a nice Haskell IDE, or a generic IDE that works nicely with Haskell?
14:49:23 <emu> i take it you won't accept emacs haskell-mode/inf-haskell as an answer eh
14:49:29 * kyevan is a fan of haveing code an interactions onscreen at once, and stuff like that
14:49:38 <kyevan> emu: Nope. Sorry.
14:49:43 <emu> because that's what it does
14:49:58 <eviltwin_b> eclipse + eclipsefp.sourceforge.net?
14:50:03 <kyevan> It also makes you use wonky Emacs keybindings
14:50:11 <emu> viper-mode will work for you
14:50:12 * kyevan couldn't even figure out how to QUIT emacs.
14:50:20 <emu> and :wq is intuitive? :P
14:50:22 <monochrom> File -> Exit
14:50:31 <emu> you don't use advanced vim commands, viper-mode does vi emulation
14:51:02 <kyevan> emu: But doesn't viper take over as the mode, so haskell mode couldn't be used at the same time?
14:51:09 <monochrom> The original vi key binding was even more wonky.
14:51:25 <emu> kyevan: no
14:51:26 <kyevan> monochrom: What about when I'm not useing X?
14:51:27 * nornagon vim user!
14:51:31 <monochrom> h, j, k, l for cursor movements, can you beat that?
14:51:37 <Excedrin> kyevan: Visual Haskell?
14:51:41 <emu> kyevan: i'm editing in haskell-mode with viper right now
14:51:46 <monochrom> esc `  brings up the menu.
14:51:52 <norpan> vim good
14:51:57 <norpan> me like
14:51:58 <kyevan> monochrom: hjkl takes a little getting used to, I admit.
14:52:08 <norpan> hjkl is for vi newbies :)
14:52:12 <nornagon> hjkl is really good once you're used to it
14:52:14 <monochrom> C-x C-c  if you don't like the menu
14:52:26 <nornagon> but you can use the cursor keys fine
14:52:32 <norpan> you use w, b, f, t
14:52:36 <norpan> those are good
14:52:36 <monochrom> *original*
14:52:41 <kyevan> But it makes more sense than C-u, C-d, C-f, and C-b
14:52:44 <nornagon> dhtn!
14:52:52 <kyevan> Or whatever they were
14:52:53 <emu> kyevan: C-n, C-p
14:52:59 <emu> C-u is the universal argument
14:53:02 <kyevan> Oh.
14:53:17 <kyevan> Well, see? hjkl is more logical :P
14:53:26 <Excedrin> kyevan: just use viper, hjkl in emacs gg nextmap
14:53:54 <nornagon> if you're going to emulate vi with emacs ... why not just use vi?
14:53:54 <emu> kyevan: you don't even know the usual vim motions, so, using viper in emacs won't be a loss ;)
14:53:59 <kyevan> I'm trying to figure out how to use viper :P
14:54:00 <emu> nornagon: no haskell-mode
14:54:04 <emu> kyevan: M-x viper
14:54:12 <emu> M-x is kinda like : in vim
14:54:17 <nornagon> emu: vim has haskell hilighting & stuff
14:54:22 <emu> nornagon: no inf-haskell in vim
14:54:23 <nornagon> what else does haskell-mode do?
14:54:26 <nornagon> ?
14:54:40 <Excedrin> nornagon: modes are good, vi has 3 modes, viper has 4
14:54:46 <Excedrin> magic tab key is good
14:54:51 <emu> haskell mode does: documentation, indentation, running ghci process, loading files, querying process, expression editting etc
14:55:11 <kyevan> MReh.
14:55:18 <kyevan> Screen works.
14:55:26 <nornagon> all that can be done with vim, of course
14:55:30 <nornagon> just hasn't been yet
14:55:31 <nornagon> i guess
14:55:31 <emu> really? i'd love to hear how
14:55:34 <kyevan> Now if only I could figure out the mythical spliting feature.
14:55:36 <emu> oh, you sound just like kyevan
14:55:53 <nornagon> kyevan: you can use tabs in vim 7
14:55:55 <kyevan> emu: Well, MY emacs doesn't do any of that!
14:55:59 <nornagon> :tabedit <file>
14:56:04 <emu> kyevan: you don't have haskell-mode installed probably
14:56:04 <kyevan> nornagon: Wha?
14:56:16 <kyevan> emu: I don't have it installed at all
14:56:29 <nornagon> then ctrl+pgup/dn to switch tabs
14:56:30 <kyevan> But, don't yell at vim for not haveing features emacs doesn't have either :P
14:56:34 <nornagon> it's quite neat
14:56:42 <kyevan> nornagon: I mean, to have ghci and vim up at once :P
14:56:46 <emu> for a feature "emacs doesn't have" it sure is nice to use in emacs right now
14:56:50 <nornagon> oh.
14:57:11 <nornagon> kyevan: ctrl-a c to create a new screen window
14:57:14 <kyevan> emu: emacs, as distributed by the Free Software Foundation, and such, does NOT have any of those features
14:57:18 <kyevan> nornagon: I know that
14:57:20 <nornagon> ctrl-a <num> to go to window number <num>
14:57:26 <nornagon> right
14:57:30 <nornagon> so what's the problem? :)
14:57:39 <kyevan> There's a seemingly mythical feature that lets you have more than one on screen at once
14:57:46 <emu> kyevan: last time i checked, your computer doesn't come installed with Linux or GHC either
14:57:53 <nornagon> kyevan: mm
14:57:58 <nornagon> i've managed that too
14:58:00 <kyevan> emu: This is true. Usually.
14:58:04 <nornagon> ctrl-a S or something
14:58:11 <nornagon> yep
14:58:16 <kyevan> I got a computer with linux and ghc preinstalled once :P
14:58:18 <monochrom> vim can let me jump between multiple files
14:58:32 <emu> nornagon: now how do you switch screen windows? =)
14:58:42 <monochrom> vim can let me jump between multiple files, but at the cost of remembering the name of the command or key for that.
14:58:45 <nornagon> ctrl-a w
14:58:59 <emu> nornagon: i meant the split ones
14:58:59 <monochrom> vim can let me jump between multiple files, but at the cost of remembering the name of the command or key for that.  I can't for my life remember it.
14:59:06 <nornagon> monochrom: use tabs
14:59:11 <nornagon> monochrom: or :buffers
14:59:12 <emu> monochrom: :n
14:59:20 <wilx> Huhuhu.
14:59:23 <monochrom> vim can let me jump between multiple files, but at the cost of remembering the name of the command or key for that.  I can't for my life remember it.  If I try to find out from :help, it takes five minutes.
14:59:24 <nornagon> emu: yes
14:59:26 <emu> or something. i don't use it much
14:59:27 <wilx> How do I unsplit the screen win?
14:59:27 <nornagon> c-a w
14:59:33 <nornagon> er
14:59:33 <nornagon> c-a tab
14:59:36 <nornagon> i think
14:59:41 <emu> yea thats it
14:59:41 <nornagon> try c-a X for unsplit
14:59:47 <monochrom> So, vim can let me jump between multiple files, but at the cost of five minutes.
14:59:57 <kyevan> Wow! That actually worked....
14:59:57 <monochrom> That is the main reason I don't use vim.
15:00:03 <emu> i have to say, emacs iswitchb-mode is pretty slick
15:00:03 <nornagon> monochrom: :tabe <new file>
15:00:05 <nornagon> done
15:00:12 <nornagon> tabe being tabedit
15:00:16 <monochrom> I can't for my life remember that.
15:00:29 <kyevan> I just cheat and use multiple copies of Vim in diferent screens :P
15:00:36 <nornagon> but you can remember all of emacs' crazy key combos?
15:00:37 <monochrom> You can teach me today, and I thank you.  Tomorrow I will need to be taught again.
15:00:37 <emu> i suspect thats what most people do
15:00:42 <nornagon> i do that too
15:00:45 <kyevan> (Something which would kill you with emacs!)
15:00:48 <emu> nornagon: surprisingly i can, since i have a brain
15:00:59 <monochrom> kyevan: yes, until I have 100 lines to move from file to file.
15:01:02 <nornagon> emu: i'm talking to monochrom
15:01:09 <emu> kyevan: well since i can open up multiple windows in the same emacs, its not a big deal. also, emacs doesnt eat much memory when you have 2GB
15:01:12 <eviltwin_b> <kyevan> (Something which would kill you with emacs!)
15:01:15 <eviltwin_b> emacsclient
15:01:21 <eviltwin_b> or gnuclient
15:01:24 <emu> forgot bout that too
15:01:34 <nornagon> emu: you need 2GB to run your text editor? cool :D
15:01:35 <kyevan> emu: If you had a brain, you could remember the vim commands :P
15:01:45 <emu> nornagon: hey i'm not using eclipse
15:01:52 <emu> kyevan: i know many more vim commands than you
15:01:53 <monochrom> I can't remember all the emacs crazy keys, no.  But it does not take five minutes to search.
15:02:03 <nornagon> "emacs doesnt eat much memory when you have 2GB"
15:02:05 <monochrom> vim's :help is really poor.
15:02:05 <kyevan> nornagon: No, just Eight Megabytes (And Constant Swapping!) <- Old joke
15:02:07 <nornagon> irrelevant
15:02:10 <nornagon> completely
15:02:17 <emu> i'm sure vim is up there
15:02:17 <kyevan> emu: I know many more than I use regularly, to be honost
15:02:19 <monochrom> emacs has at least a menu for navigating a subset of things
15:02:29 * notsmack notes that this conversation is terrible
15:02:34 <nornagon> can you run emacs on your 66Mhz arm processor with 10M ram?
15:02:43 <eviltwin_b> on at least one fedora build, vim is larger than xemacs
15:02:51 <nornagon> it sure is
15:02:55 <kyevan> notsmack: Yes, especially since I asked something completely diferent to start this :P
15:03:04 <monochrom> In 10 years time, vim will become as easy to use as emacs.  Until then, I use emacs.
15:03:24 <kyevan> And now, thanks to Nornagon. this is solved by the magic of multiple programs
15:03:41 <kyevan> monochrom: IMO, that's backwards, but, like I said, different people like different editors.
15:03:54 <emu> vim has "ok" help. i learned a few things from it.
15:04:00 <kyevan> I prefer vim, you prefer emacs. Who cares
15:04:17 <kyevan> Vim's help is not that bad, if you use the html copy :P But, yeh....
15:04:18 <emu> well you started this off by asking if there was a Haskell IDE and then refusing to use the one there is
15:04:30 <monochrom> vim's :help is really a book meant for cover-to-cover reading, not for quick lookup.
15:04:46 <kyevan> emu: ... I asked for a nice one, and, yeh.
15:04:48 <eviltwin_b> "the one"?  several others have already been mentioned
15:04:59 <kyevan> monochrom: On the other hand, it has a nice introduction, which emacs seems to lack.
15:05:01 <notsmack> don't forget vimtutor ;-)
15:05:04 <kyevan> But this is off topic
15:05:10 <emu> kyevan: emacs tutorial...next
15:05:11 <monochrom> kyevan: I disagree.  I think because emacs has a menu and vim doesn't, the former is objectively easier to use.
15:05:14 <eviltwin_b> and a few mot mentioned yet, although they're admittedly on the lame side (e,g, kdevelop has limited haskell support)
15:05:22 <emu> how about hIDE? =)
15:05:30 <kyevan> If you want to continue thism I will be joining #editor-war, and you are welcome to join me!
15:05:32 <eviltwin_b> monochrom: gvim?
15:05:45 <monochrom> yeah I guess gvim is ok
15:06:21 <kyevan> Now, let's talk about some haskelly goodness, not editors ^_^
15:06:28 <Excedrin> according to top -> emacs virt: 148m, res: 18m, vim virt: 6628, res: 2556
15:06:30 <monochrom> I cannot find a 66MHz computer anymore.
15:06:48 <kyevan> monochrom: I have several, upstairs, in my room
15:06:54 <kyevan> They fit in my pocket nicely
15:07:00 <emu> so, formal semantics of Haskell
15:07:15 <glguy> What collogne are you going to go with? London gentleman?
15:07:21 <bd_> oh dear, I attach to screen, and first thing I see is an editor war?
15:07:28 <monochrom> Since I use Haskell too, I think I can't use a 66MHz, 10MB computer anyway.
15:07:29 <eviltwin_b> heh
15:07:38 <glguy> editor war? vim won that a long time ago, this is 2006
15:07:50 <emu> not only an editor war, an editor war featuring 66MHz computers
15:07:50 <bd_> editor insurgency, fine. >.>
15:08:14 <Excedrin> hrm, emacs is still 10m res with -q
15:08:18 <monochrom> You use a 66MHz, 10MB computer to edit and compile and test Haskell programs?
15:08:35 <kyevan> monochrom: No, I don't.
15:08:44 <kyevan> I'm just saying, they do exist
15:08:46 <emu> of course. development should be done on the most underpowered machine possible.
15:09:00 <Excedrin> oh well, back to cat > file.hs
15:09:05 <notsmack> i edit haskell on mine sometimes, but haven't found a way to build
15:09:05 <emu> with the fewest features. in fact, use ed.  Ed is the standard Unix editor.
15:09:07 <kyevan> In the form of handhelds (Includeing, of course, the DS, which I beleve has had Haskell almost run on it!)
15:09:14 <monochrom> I have Casio FX3600P.  7 registers, 39 bytes for programs.
15:09:18 <kyevan> emu: Vi is standard, too
15:09:22 <eviltwin_b> ed has lots of features.  pico, now...
15:09:26 <Excedrin> vim is not standard
15:09:35 <kyevan> So as long as you don't get too dependent on advanced features of vim, you're good
15:09:51 <kyevan> Excedrin: Vi is.
15:10:02 <emu> too bad the advanced features of vim are what makes it cool
15:10:06 <monochrom> such as vim tab editing :)
15:10:10 <emu> visual block
15:10:14 <emu> rectangular
15:10:21 <kyevan> emu: And the non-advanced features of emacs make it cool?
15:10:36 <emu> no, the advanced features of emacs are also cool. why else would i use it?
15:10:36 <kyevan> (And not even a subset of emacs is standard, I might add!)
15:10:44 <monochrom> The 80MB footprint of emacs makes it cool. :)
15:11:07 <kyevan> But, enough... go to #editor-war to continue this! SO SPEAKS THE MAGISTER, er, someone who reads the Wotch too much
15:11:27 <monochrom> Can you prove your Haskell programs terminate?
15:11:33 <metaperl> It's the weekend Haskellers!
15:11:36 <kyevan> (Includeing the sunday specials whiich are finaly going again!
15:11:43 <kyevan> metaperl: not yet, here
15:12:02 <monochrom> Friday is part of weekend.  You're still on Thursday?  Poor you.
15:12:29 <kyevan> monochrom: `Nah, just not late enough friday to be the weekend
15:12:34 <emu> the Dynamic Semantics of Haskell paper is a dead link!
15:12:34 <kyevan> Well, yeh. I am, for me.
15:12:40 <kyevan> Since I got today off, yay.
15:12:55 <kyevan> The weekend starts in an hour for us :P
15:12:56 <monochrom> A joke says: theoretical physicists avoid scheduling meetings to be on Wednesdays, because it would ruin both weekends.
15:13:25 <emu> no wonder they say Haskell has no semantics
15:13:52 <kyevan> Does haskell suport sexps for non-code stuff?
15:13:54 <SamB> emu: well, for a language who's spec is written in english it is pretty well defined ;-)
15:14:06 <monochrom> It's ok.  In editor wars, people want to avoid "fighting over semantics" anyway.
15:14:06 <lisppaste2> glguy pasted "switchboard solution" at http://paste.lisp.org/display/31725
15:14:31 <monochrom> what is "support sexps"?
15:14:32 <SamB> monochrom: emu is not talking about editor wars still, is he?
15:14:37 <chessguy> glguy, what problem is that solving?
15:14:43 <emu> actually, this is a real concern. i attended a talk today in which the speaker used haskell to do a proof.  one of the audience members pointed out that haskell has no formal semantics.
15:14:53 <glguy> chessguy: the link is in the paste
15:14:57 <monochrom> the "editor wars" part is mine
15:15:05 <chessguy> oh, missed it. sorry
15:15:36 <kyevan> monochrom: "support sexps", meaning, let me use s-expressions for things like xml trees and such
15:16:07 <monochrom> Do you mind settling with just prefix notation?
15:16:11 <emu> kyevan: HaXML has a monadic combinator based way of writing things like XML, actually. i think it was Haxml
15:16:31 <kyevan> emu: But, but... sxml is sonice....
15:16:55 <kyevan> monochrom: If I can wrap it all in parenths, yes :P
15:17:07 <monochrom> because you can define a library so that "html [meta ..., meta ..., head .... , body ....]" makes sense.
15:18:08 <monochrom> It is very hard to allow both "(html (head ...) (body ...))" and "(html (meta ...) (head ...) (body ...))", i.e., vargs.
15:18:12 <kyevan> emu: Eep. Monads still are in the head-hurt zone for me...
15:18:32 <kyevan> monochrom: metas are below head in html, though :P
15:18:38 <monochrom> oops!
15:18:49 <monochrom> make them comments.
15:19:11 <kyevan> monochrom: toss comments into the trash. (xml paresers are allowed to do that :P)
15:19:49 <kyevan> So, really, it depends on the dtd, and if you are designing for one dtd, you might as well use a more haskelllike structure for it
15:19:57 <monochrom> But my "html [head ... , body ...]" refers to building a doc.
15:20:17 <kyevan> If you're doing documents programaticly, why would you even have comments?
15:20:41 <kyevan> You aren't using them as PIs, are you?
15:20:48 <monochrom> Because I like to say "<!-- please don't edit!!!111 -->"
15:21:06 <kyevan> monochrom: Oh, fair enough
15:21:14 <monochrom> or "<!-- generated from Haskelllll!!!!  Learn Haskell NOW!!!1111 ->"
15:21:20 <kyevan> Well, I don't need it now, anyway, I was just asking from curiousity!
15:21:31 <emu> monochrom: malformed!
15:21:34 <kyevan> monochrom: You would use meta generator for that!
15:21:35 <jlouis> if monads hurt. Then try comonads
15:21:42 <yip> or arrows
15:21:46 <jlouis> they hurt even more. And arrows
15:21:48 <emu> @type (>>>)
15:21:49 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
15:21:49 <monochrom> But basically vargs is easy in sexpr but hard in Haskell.  otherwise it's ok.
15:22:23 * kyevan now randomly wonders if any modern lisp/scheme/etc interpreter supports mexps....
15:22:33 <sorear> currying is what makes vargs hard, not any syntax.
15:22:33 <monochrom> eh, what is mexp?
15:22:44 <sorear> PLT supports inline XML
15:23:10 <monochrom> Another thing is heterogenous list, hard in Haskell too, and needed for sexp-like things.
15:23:20 <kyevan> origionally, lisp was going to be foo[bar baz] to the author, and that would be transformed to (foo bar baz) internaly.
15:23:43 <emu> kyevan: Dylan has its own non-sexp syntax alternative
15:24:07 <eviltwin_b> don't forget the phantom commas :)
15:24:16 <kyevan> and the foo[bar baz] representation was called mexpresions, I think
15:24:29 <monochrom> Interesting.
15:25:12 <jlouis> there was an attempt at building a richer syntax for lisps. I think it had some 'm' in its name
15:25:19 <Cale> Yeah, if you read the Lisp 1.5 manual, that's how it looks.
15:25:49 <Cale> foo[bar;baz]
15:25:50 <Cale> I think
15:25:56 <emu> jlouis: m-expressions
15:26:14 <emu> but they were never actually implemented.
15:26:21 <Excedrin> kyevan: there's Gambit Scheme's Six (scheme infix)
15:27:00 <sorear> I'd like to note that the biggest difference I see between XML and sexps is that sexps use (monomorphic, unidirectional) type inference, while XML is explicitly typed.  Just in case it leads to any insights...
15:27:04 <Cale> http://community.computerhistory.org/scc/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf
15:27:07 <lambdabot> http://tinyurl.com/ykq5x4
15:27:07 <Excedrin> there's also sweet-expressions
15:28:54 <jlouis> emu, ah yes
15:29:16 <Excedrin> this covers a lot of the alternatives: http://www.dwheeler.com/readable/readable-s-expressions.html
15:29:21 <lambdabot> Title: Readable s-expressions and sweet-expressions: Getting the infix fix and fewer pa ...
15:36:51 <kyevan> I think there is a strictly defined sexps-as-xml thing :P
15:38:51 <newsham> sexp appeal
15:39:13 <newsham> is the haskell-cafe post about exceptions being unreliable in ghc accurate?
15:42:01 <sorear> I've briefly used PLT-scheme, IIRC they had strongly-integrated support for imbedding XML documents in s-expressions
15:42:11 <Saizan> ?docs System.IO
15:42:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
15:45:29 <newsham> would be nice if you didnt need the leading "?" when msg'ing lambdabot
15:46:23 <newsham> ?elite i am the coolest bot ever
15:46:24 <lambdabot> i 4M THe cooLES+ bo+ e\/eR
15:46:49 <chessguy> ?remember lambdabot i 4M THe cooLES+ bo+ e\/eR
15:47:01 <chessguy> @quote lambdabot
15:47:02 <lambdabot>  why on the earth whould I slap dons with a wet trout
15:47:08 <chessguy> @quote lambdabot
15:47:08 <lambdabot>  lambdabot hasn't said anything memorable
15:47:12 <chessguy> @quote lambdabot
15:47:13 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
15:47:25 <chessguy> @quote lambdabot
15:47:26 <lambdabot>  Nobody brings small problems into a laundromat.
15:48:42 <bd_> @. elite quote lambdabot
15:48:42 <lambdabot> foRA11 (T :: (* -> *) -> * -> *) (/\/\ :: * -> *) a. (/\/\On4D+R4Nz0Rz T, /\/\On4D /\/\) => 7 ((->) a) (/\/\ 4)
15:49:25 <Lemmih> @keal
15:49:27 <lambdabot> intuitive != imperative
15:49:37 <newsham> @. seen elite lemmih
15:49:38 <lambdabot> I haven't seen Lem/\/\Ih.
15:50:51 <newsham> @. elite vixen
15:50:52 <lambdabot> YoU zIr 4RE n0 9eN7Leman
15:52:22 <emu> monads are leet
15:59:26 <newsham> > ?pl \f a b = do { x <- a; y <- b; return (f x y) }
15:59:27 <lambdabot>  Parse error
15:59:45 <newsham> ?undo \f a b = do { x <- a; y <- b; return (f x y) }
15:59:46 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 8}) "Parse error"
15:59:52 <bd_> @pl \f a b = do { x <- a; y <- b; return (f x y) }
15:59:53 <lambdabot> (line 1, column 8):
15:59:53 <lambdabot> unexpected "="
15:59:53 <lambdabot> expecting pattern or "->"
16:00:11 <sorear> newsham: liftM2
16:00:17 <newsham> sorear: yah
16:00:23 <bd_> @pl \f a b = a >>= \x -> b >>= \y -> return (f x y)
16:00:23 <lambdabot> (line 1, column 8):
16:00:23 <lambdabot> unexpected "="
16:00:23 <lambdabot> expecting pattern or "->"
16:00:28 <bd_> oh, = >.<
16:00:49 <sorear> newsham : use -> for lambda
16:00:53 <sorear> ?pl \x = x
16:00:53 <lambdabot> (line 1, column 4):
16:00:54 <lambdabot> unexpected "="
16:00:54 <lambdabot> expecting operator, pattern or "->"
16:00:56 <sorear> ?pl \x -> x
16:00:57 <lambdabot> id
16:01:09 <newsham> > ?pl \f a b -> do { x <- a; y <- b; return (f x y) }
16:01:10 <lambdabot>  Parse error
16:01:47 <newsham> ?pl \f a b -> a >>= (\x -> b >>= (\y -> return (f x y)))
16:01:49 <lambdabot> liftM2
16:02:15 <bd_> no > for ?pl
16:02:26 <bd_> > is for evaluation
16:02:27 <lambdabot>  Not in scope: `evaluation'
16:02:36 <newsham> not my day
16:02:46 <newsham> ?pl \f a b -> do { x <- a; y <- b; return (f x y) }
16:02:47 <lambdabot> (line 1, column 14):
16:02:47 <lambdabot> unexpected "{"
16:02:47 <lambdabot> expecting variable, "(", operator or end of input
16:03:11 <Saizan> i think it doesn't like do notation
16:03:23 <sorear> ?pl \x -> do { x }
16:03:23 <lambdabot> (line 1, column 10):
16:03:23 <lambdabot> unexpected "{"
16:03:23 <lambdabot> expecting variable, "(", operator or end of input
16:03:25 <sorear> ?pl \x -> (do { x })
16:03:26 <lambdabot> (line 1, column 11):
16:03:26 <lambdabot> unexpected "{"
16:03:26 <lambdabot> expecting variable, "(", operator or ")"
16:03:51 <sorear> ?pl \x -> do { x; }
16:03:51 <eviltwin_b> pl doesn't grok do
16:03:52 <lambdabot> (line 1, column 10):
16:03:52 <lambdabot> unexpected "{"
16:03:52 <lambdabot> expecting variable, "(", operator or end of input
16:04:09 <eviltwin_b> @. pl undo \x -> do {x}
16:04:09 <lambdabot> id
16:04:24 <newsham> i dont think any of the monad tutorials i've read drew analogy between let-binding and do-binding.
16:04:27 <newsham> which is a shame.
16:04:49 <chessguy> that's what wikis are for. roll your own tutorial!
16:04:50 <Saizan> whats @. ?
16:04:54 <sorear> do binding is lambda binding, which is monomorphic.
16:05:00 <sorear> @. is composition.
16:05:00 <lambdabot> compose module failed: IRCRaised Parse error: "is"
16:05:02 <newsham> saizan: looks like composition for lambdabot commands
16:05:05 <xerox> do { let {...}; ... }  ===  let {...}; in do ... ?
16:05:20 <sorear> xerox: yes
16:05:27 <Excedrin> @. go elite monad
16:05:28 <lambdabot> compose module failed: IRCRaised Parse error: "go"
16:05:30 <xerox> is that the "analogy" ?
16:05:35 <sorear> xerox: except RHS is syntax error.
16:05:40 <newsham> let a = b in c   =>   (\a -> b) c
16:06:00 <sorear> do { x <- foo ; bar } === foo >>= \x -> bar
16:06:00 <Excedrin> abbreviations don't work with @.?
16:06:17 <sorear> @go
16:06:17 <lambdabot> Empty search.
16:06:17 <newsham> err.. i mean    (\a -> c) b
16:06:30 <sorear> newsham: not quite.
16:06:33 <newsham> a <- b; c      =>   b >>= (\a -> c)
16:06:45 <sorear> let-bindings are polymorphic, lambda bindings are not.
16:06:51 <Excedrin> @. google elite randomurlgenerator
16:06:53 <lambdabot> No Result Found.
16:07:04 <emu> @. elite randomurlgenerator
16:07:05 <lambdabot> compose module failed: IRCRaised Parse error: "randomurlgenerator"
16:07:16 <Excedrin> @. google elite random
16:07:19 <lambdabot> http://www.threedy.com/site/forum/member.php?u=8364
16:07:20 <lambdabot> Title: Threedy Forums - View Profile: r4ndom
16:07:21 <newsham> sorear: can you explain the difference?
16:07:35 <xerox> let ones = 1 : map (+1) evens; evens = map (+1) odds in ... ?
16:08:04 <newsham> xerox: letrec aside.
16:08:17 <xerox> :(
16:09:21 <sorear> > let f x = id in (f 1, f True)
16:09:22 <lambdabot>  Add a type signature
16:09:25 <sorear> > let f x = x in (f 1, f True)
16:09:27 <lambdabot>  (1,True)
16:09:37 <sorear> > (\f -> (f 1, f True)) id
16:09:39 <lambdabot>  add an instance declaration for (Num Bool)
16:09:43 <Saizan> do you know if repeated access to the same cell of a DiffUArray gets optimized in some way?
16:09:51 <sorear> > (\f -> (f [], f True)) id
16:09:52 <lambdabot>  Couldn't match `[a]' against `Bool'
16:09:58 <ozo> @. elite haskell
16:09:59 <lambdabot> compose module failed: IRCRaised Parse error: "haskell"
16:10:02 <sorear> > let f x = x in (f [False], f True)
16:10:04 <lambdabot>  ([False],True)
16:10:14 <sorear> it works if:
16:10:15 <newsham> ahh.. gotcha.
16:10:42 <sorear> > ((\f -> (f [False], f True)) :: (forall x. x -> x) -> ([Bool],Bool)) id
16:10:43 <lambdabot>  Parse error
16:10:47 <sorear> > ((\f -> (f [False], f True)) :: (forall x. x -> x) -> ([Bool],Bool))) id
16:10:47 <lambdabot>  Parse error
16:11:08 <sorear> > ((\f -> (f [False], f True)) :: ((forall x. x -> x) -> ([Bool],Bool))) id
16:11:09 <lambdabot>  Parse error
16:11:11 <sorear> > ((\f -> (f [False], f True)) :: ((forall x. x -> x) -> ([Bool],Bool)))) id
16:11:12 <lambdabot>  Parse error
16:11:14 <sorear> > ((\f -> (f [False], f True)) :: ((forall x. x -> x) -> ([Bool],Bool)) id
16:11:15 <lambdabot>  Parse error
16:12:17 <eviltwin_b> > ((\f -> (f [False], f True)) :: ((forall x. x -> x) -> ([Bool],Bool))) id
16:12:17 <lambdabot>  Parse error
16:12:39 <sorear> anyways, polymorphic lambda bindings require rank-2 polymorphism, which (I'm told) is undecidable in general - but the special case resulting from desugaring lets *is* decidable, so HM allows polymorphic letbindings as a special case.
16:13:10 <newsham> that sounds confusing and impressive.  i will nod cautiously.
16:15:14 <eviltwin_b> > ((\f x -> (f [False], f True)) :: forall x. (x -> x) -> ([Bool],Bool)) id
16:15:15 <lambdabot>  Parse error
16:22:35 <dons> moin
16:22:37 <dons> ?users
16:22:37 <lambdabot> Maximum users seen in #haskell: 278, currently: 250 (89.9%), active: 34 (13.6%)
16:22:43 <wolverian> I don't think lambdabot likes forall?
16:22:55 <dons> not H98
16:23:13 <wolverian> right.
16:25:00 <eviltwin_b> ah, that'd make sense
16:31:38 <emu> time to brave the 19 F weather
16:31:40 <emu> $^%$@&
16:36:59 <augustss> ?users
16:37:00 <lambdabot> Maximum users seen in #haskell: 278, currently: 249 (89.6%), active: 35 (14.1%)
16:37:02 <jlouis> its 10Â° C here
16:37:08 <jlouis> and its 01:30
16:37:39 <augustss> @users
16:37:39 <lambdabot> Maximum users seen in #haskell: 278, currently: 249 (89.6%), active: 35 (14.1%)
16:56:52 <newsham> the "source code" links in the haskell libraries docs are broken (but almost right).  Ie from http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
16:56:54 <lambdabot> http://tinyurl.com/ona24
16:57:15 <newsham> clicking goes to http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.raw-hs,  the correct URL is http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
16:58:01 <aFlag> is there an function that makes a Just into True and a Nothing into False?
16:58:15 <newsham> isJust ?
16:58:22 <newsham> ?type isJust
16:58:23 <lambdabot> forall a. Maybe a -> Bool
16:59:05 <aFlag> thanks
17:00:47 <augustss> @djinn Maybe a -> Bool
17:00:48 <lambdabot> f a =
17:00:48 <lambdabot>   case a of
17:00:48 <lambdabot>   Nothing -> False
17:00:48 <lambdabot>   Just _ -> True
17:03:36 <dons> newsham: well spotted. please submit a bug report
17:03:58 <newsham> where?  who owns that page?
17:04:26 * dons writes a bug reporting plugin
17:06:06 <wolverian> heh.
17:06:31 <eviltwin_b> "@whine <foo> doesn't work: <yada>"
17:08:52 <dons> ?bot
17:09:19 <lambdabot> :)
17:09:21 <dons> ?bug <-- here, newsham
17:09:21 <lambdabot> Maybe you meant: bf msg run
17:09:24 <dons> doh!
17:09:34 <eviltwin_b> heh
17:09:46 <shapr> At least we know what to use it for now!
17:09:55 <wolverian> ?bug ?bug doesn't work
17:09:56 <lambdabot> Maybe you meant: bf msg run
17:10:02 <wolverian> damn!
17:10:21 <xerox> too much Hofstadter for wolverian
17:10:38 <emu> @. fix bug
17:10:38 <lambdabot> compose module failed: IRCRaised Parse error: "fix"
17:11:42 <wolverian> xerox, I've never read his books. (yes, I'm fixing that. it's just too embarassing.)
17:13:12 <xerox> GEB is just too much fun, and it's quite old too, which is kind of weird
17:13:21 <xerox> g'nite
17:13:32 <wolverian> right. well, I just reserved it from the library.
17:13:37 <wolverian> @karma+ xerox
17:13:38 <lambdabot> xerox's karma raised to 26.
17:13:39 <wolverian> (for reminding me)
17:14:02 <emu> it strikes me at point in GEB he gives a description for what might be termed later "object oriented programming"
17:14:27 <emu> speaking of how old the book is
17:14:48 <dons> ?bot
17:14:49 <aFlag> is there something like -L on ghc? I'm not finding it
17:15:08 <lambdabot> :)
17:15:11 <emu>  -i<dir> perhaps
17:15:22 <dons> ?bug <-- try again
17:15:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
17:15:32 <dons> newsham: ^^
17:15:55 <dons> now we just need @fix darcs.patch
17:16:00 <dons> and all dev can move into channel
17:16:28 <emu> what we need is an intelligent lambdabot to write its code for us
17:16:46 <dons> ?djinn a -> b -> (b,a)
17:16:47 <lambdabot> f a b = (b, a)
17:16:51 <dons> its own code, eh?
17:16:51 <aFlag> -i is for haskell code, isn't it? The linker doesn't seem to be finding the gmp library
17:17:26 <emu> ah yes
17:17:35 <dons> aFlag: add "-L/usr/local/lib" to the ldOptions of ghc's package.conf
17:17:46 <dons> or on the command line (depending on where your gmp is)
17:18:07 <aFlag> Hum, I don't have a package.conf
17:18:33 <dons> sure you do, lib/ghc-6.6/package.conf
17:18:39 <dons> for some $prefix
17:18:44 <aFlag> oh, it can't be a space between -L and the path
17:18:53 <dons> yep
17:19:04 <aFlag> that was what I had wrong
17:31:22 <emu> gosh, i got the src dist of happy, and there was a simple stupid error in one of the files..
17:31:45 <emu> and its nearly two years old... weerid
17:31:49 <glguy> > (zipWith(\x c->chr$mod(ord c+ord x)26+65).cycle) "LEMON" "ATTACKATDAWN"
17:31:51 <lambdabot>  "LXFOPVEFRNHR"
17:32:00 <LoganCapaldo> Nooooooooo
17:32:48 <dons> emu: you sure you got the darcs repo?
17:33:07 <newsham> ?type liftM2 (,)
17:33:09 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:33:29 <emu> oh, no, i got the tar
17:33:31 <emu> i guess that was a mistake
17:33:40 <dons> dcoutts, Lemmih, Syntaxnina, http://watzmann.net/blog/index.php?m=200511
17:33:41 <lambdabot> Title: watzmann.blog - November 2005
17:33:54 <newsham> is there a way to make lambdabot be more specific about a type?  ie.  "?type liftM2 (,)    for the list monad" ?
17:33:55 <dons> "thoughts on package management, and Package installation is NP-complete"
17:34:03 <dons> type annotation
17:34:21 <dons> :t  liftM2 (,) :: IO a -> IO a -> IO (a,a)
17:34:22 <lambdabot> IO a -> IO a -> IO (a,a) :: forall a. IO a -> IO a -> IO (a, a)
17:34:29 <emu> wait, what darcs repo
17:34:37 <dons> emu, the happy darcs repo!
17:34:45 <jlouis> dons, oh interesting
17:34:47 <emu> its not on the web page.. grr
17:34:57 <dons> emu, http://darcs.haskell.org/happy
17:34:59 <lambdabot> Title: Index of /happy
17:35:00 <newsham> dons: but in that case arent you basically just telling it the answer?
17:35:15 <dons> emu, last patch, 30-Nov-2006
17:35:27 <dons> newsham: sure. but you can under constrain it if you want
17:35:28 <emu> ok
17:35:32 <dons> just annotate some of the variables
17:35:38 <emu> they should add a note on the homepage or something
17:35:39 <newsham> maybe here's a more realistic example  "what's the type of liftM2 (,) if the first argument is [Int]" ?
17:36:01 <dons> :t \a -> liftM2 (,) (a :: [Int])
17:36:02 <lambdabot> forall a2. [Int] -> [a2] -> [(Int, a2)]
17:37:06 <emu> a darcs repo with Cabal infrastructure? that makes me Happy!
17:39:24 <dons> newsham: make sense?
17:39:37 <newsham> yah.. trying to think of other questions i might want to ask and see if it works
17:39:55 <newsham> what about "what types of args to liftM2 (,) to get a return value [(Int, Int)]" ?
17:40:25 <dons> :t \a b -> liftM2 (,) a b :: [(Int, Int)]
17:40:27 <lambdabot> [(Int, Int)] :: [Int] -> [Int] -> [(Int, Int)]
17:40:35 <newsham> sweet
17:40:58 <dons> theorem proving!
17:41:49 <wolverian> what is :: used as there? that looks weird.
17:41:56 <newsham> type annotation
17:42:11 <wolverian> I mean, the lhs and rhs obviously don't look equivalent to me
17:42:13 <glguy> I was just flipping through the TV channels, and soap-opera wrestling was on, and I felt bad for the people that were watching it... and then I click up a couple and one of those "who wants to be rich" was on.. and I feel bad forthe people watching that show too... 2 of 5 channels down... time to turn off the TV :)
17:42:37 <dons> wolverian: oh, that's a bug in lambdabot
17:42:45 <dons> you mean, here: "[(Int, Int)] :: [Int] -> [Int] -> [(Int, Int)]"
17:42:47 <dons> ?
17:42:48 <wolverian> yes.
17:42:55 <dons> the regex just splits on the first ::
17:42:58 <dons> :}
17:43:03 <wolverian> ah. :) bad hack!
17:43:18 <dons> so actually lambdabot is saying:  \a b -> liftM2 (,) a b :: [(Int, Int)]    ::[Int] -> [Int] -> [(Int, Int)]
17:43:22 <glguy> 1
17:43:29 <wolverian> right. now it makes sense. thanks!
17:43:38 * dons looks for a fix
17:43:54 <LoganCapaldo> Don't split?
17:43:56 <LoganCapaldo> heh
17:44:02 <newsham> find :: looking backwards (right-split)
17:44:07 <sjanssen> dons: should be the rightmost ::, shouldn't it?
17:44:25 <dons> sjanssen: yeah, I reckon.
17:44:30 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Type.hs
17:44:39 <dons> her's the src, someone dive in and fix it
17:44:50 <dons> (I'd prefer to ditch the regexes even)
17:44:50 <newsham> when will lambdabot support silc?  ;-)
17:44:59 <mbishop> haha
17:46:21 <LoganCapaldo> woah, I just realized how dependent I've become on syntax highlighting
17:46:27 <dons> beelsebob: did I ever ask if you were coming to the hackathon?
17:46:31 <dons> LoganCapaldo: oh?
17:46:50 <LoganCapaldo> Yeah I looked at that code and my eyes jsut kind of glazed over
17:46:53 <LoganCapaldo> all one color
17:46:56 <dons> there's still about 7 places left for the hackathon, everyone!
17:46:59 <ralf`> ?users
17:46:59 <lambdabot> Maximum users seen in #haskell: 278, currently: 242 (87.1%), active: 13 (5.4%)
17:47:10 <dons> if you want to hack libraries and new tools for 3 days at oxford
17:47:20 <dons> ?where hac07
17:47:21 <lambdabot> http://haskell.org/haskellwiki/Hac_2007
17:47:47 <ihope> @localtime ihope
17:47:49 <lambdabot> Local time for ihope is about 8:40 PM, December 8th 2006. Yay for Fridays!
17:47:54 <ihope> Yay.
17:47:58 <dons> ?time dons
17:48:00 <lambdabot> Local time for dons is Sat Dec  9 12:41:18 2006
17:48:10 <dons> Saturdays forever!
17:49:00 <ihope> @time ihope
17:49:02 <lambdabot> Local time for ihope is Friday evening somewhere near the beginning of December
17:49:08 <LoganCapaldo> Nope can't find it. Dons where's the line that does the splitting on ::?
17:49:45 <LoganCapaldo> And can I embed a perl interpreter in lambdabot to do it? :-p
17:49:50 <dons> LoganCapaldo: its one of the regexes there
17:49:57 <eviltwin_b> ewww
17:50:02 <dons> you can use the regex module if you want. that's got pcres
17:50:07 <newsham> ?type f :: Testing123
17:50:09 <lambdabot> Not in scope: `f'
17:50:09 <lambdabot>  
17:50:09 <lambdabot> <interactive>:1:5: Not in scope: type constructor or class `Testing123'
17:50:15 <dons> but a mini lexer might be more robust
17:50:19 <glguy> Thre is a lot to be said on the topic of design patterns as evidence of language deficiency, but the reddit link " Functional Programming vs. Design Patterns" sure didn't cover any of it
17:50:20 <ihope> @time ihope
17:50:22 <lambdabot> Local time for ihope is time to stop playing with @time
17:50:30 <dons> glguy: right.
17:50:38 <dons> i'm thinking of posting Felleisen's paper instead
17:50:45 <glguy> you should
17:50:50 * dons does so
17:50:54 <glguy> and then cross promote it in the comments of that lackluster one
17:51:08 <dons> hehe
17:51:25 <eviltwin_b> hm, isn't it actually a pattern match in removeExp?
17:52:01 <LoganCapaldo> eviltwin_b: I've thought that myself just now
17:53:56 <LoganCapaldo> removeExp (' ':':':':':' ':xs) = xs if we do: removeExp (' ':':':':':' ':xs) = removeExp xs
17:54:03 <LoganCapaldo> it should work right?
17:54:44 <LoganCapaldo> Hmm
17:54:51 <LoganCapaldo> no then we need a new base case
17:55:54 <ihope> ' ':':':':':' '?
17:56:09 <LoganCapaldo> " ::
17:56:13 <LoganCapaldo> " :: "
17:56:16 <ihope> You might want to consider " :: "++, if that's possible.
17:56:18 <eviltwin_b> space cons colon cons colon cons space
17:56:20 <LoganCapaldo> stupid fat enter key
17:56:23 <cpriester> Hi! Can you tell me, how to output an Integer List Space Separated?
17:56:27 <LoganCapaldo> ihope: ++ is not a constructor
17:56:30 <glguy_> ++ doesn't pattern match
17:56:56 <ihope> cpriester: putStr (print (unwords (map show list))) where list is the list you want
17:57:08 <dons> > [1..1]
17:57:10 <Lemmih> > unwords (map show [1,2,3,4])
17:57:10 <lambdabot>  [1]
17:57:10 <dons> > [1..10]
17:57:11 <lambdabot>  "1 2 3 4"
17:57:11 <cpriester> Ah. Thank you!
17:57:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:57:13 <ihope> That is, the putStr . print . unwords . map show function.
17:57:15 <dons> > map show [1..10]
17:57:16 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
17:57:26 <ihope> Erm, wait.
17:57:28 <dons> > intersperse " " . map show $ [1..10]
17:57:29 <lambdabot>  ["1"," ","2"," ","3"," ","4"," ","5"," ","6"," ","7"," ","8"," ","9"," ","10"]
17:57:33 <dons> > concat . intersperse " " . map show $ [1..10]
17:57:34 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
17:57:38 <cpriester> Hm. That prints quotes.. I just want the numbers..
17:57:39 <dons> :)
17:57:45 <ihope> Toss out that "print".
17:57:54 * eviltwin_b wwas wondering where the print came from
17:57:55 <Lemmih> moin dons.
17:57:56 <ihope> putStr (unwords (map show list))
17:57:58 <glguy_> print = putStrLn .show
17:58:15 <dons> ?let showList = concat . intersperse " " . map show
17:58:16 <lambdabot> <local>:5:42:     Ambiguous type variable `a' in the constraint:       `Show ...
17:58:33 <dons> ?let showList :: Show a => [a] -> String ; showList = concat . intersperse " " . map show
17:58:34 <lambdabot> Defined.
17:58:43 <dons> > L.showList [1..5]
17:58:44 <lambdabot>  "1 2 3 4 5"
17:58:56 <dons> > L.showList [True,False,True,False]
17:58:57 <lambdabot>  "True False True False"
17:59:01 <ihope> Also, somebody should threaten the GHC developer dudes into implementing pattern matching on ++.
17:59:11 <glguy_> ew..
17:59:16 <dons> ew!
17:59:19 <dons> functions in patterns?
17:59:21 <dons> use guards!
17:59:31 <LoganCapaldo> ihope: You want Prolog, its the next channel over
17:59:48 <ihope> How do you use guards to replace (' ':':':':':' ':xs)?
17:59:49 <glguy_> what's next, suggesting we rename forM_ to foreach?
17:59:53 <dons> heh
18:00:01 <dons> it'll help out the Java programmers!
18:00:08 <glguy_> ihope: isPrefixOf " :: "
18:00:13 <ihope> Hey, it's no worse than pattern matching on numbers... is it?
18:00:17 <LoganCapaldo> xs | " :: " `isPrefixOf` xs
18:00:29 <glguy_> ihope: it's pretty much unrelated to pattern matching numbers
18:00:33 <ihope> ...Well, okay, yes, that works.
18:00:55 <glguy_> ihope: tell Cale your idea, he'll agree with you at least
18:00:59 <cpriester> Ok. Thats excactly what i needed; thanks a lot!
18:01:16 * glguy_ wonders if cpriester asked a question when glguy wasn't looking
18:01:33 <cpriester> :)
18:02:47 * glguy_ wonders what would compel someone to pick "shit" as their reddit user name
18:02:59 <dons> stupidity?
18:03:14 <glguy_> wouldn't it have to go deeper than that?
18:03:47 <glguy_> oh well :)
18:06:03 <sorear> ignorance?  back when I knew the IRC rfc, I connected to a server with username XXX and got privmsgd by an oper reminding me that pornography was forbidden...
18:06:03 <LoganCapaldo> Never underestimate the power of hmn stupidity
18:06:30 <sorear> s/connected/\& using telnet/
18:06:33 <glguy_> on reddit, you ought to be able to store up your points to down vote particularly ignorant comments
18:06:51 <glguy_> I know enough IRC commands to connect to #haskell and chat
18:07:03 <glguy_> but it's not much fun
18:07:18 <mbishop> How do you get a random number from say, 0-10 i haskell?
18:07:28 <glguy_> ?hoogle randomR
18:07:29 <lambdabot> Random.randomR :: (Random a, RandomGen b) => (a, a) -> b -> (a, b)
18:07:29 <lambdabot> System.Random.randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
18:07:29 <lambdabot> Random.randomRIO :: Random a => (a, a) -> IO a
18:08:15 <kyevan> Haver is much nicer when working in telnet
18:08:15 <lambdabot> kyevan: You have 1 new message. '/msg lambdabot @messages' to read it.
18:08:23 <kyevan> Not that you all prolly know what haver is :P
18:08:37 <kyevan> Which is OK, because it's near useless still!
18:08:44 <mbishop> glguy_: well it tells me I need a type signature most of the time...I'm too dumb to know why :)
18:08:49 <kyevan> Yay for near useless chat protocol projects!
18:09:13 <dons> here you go guys, a classic : http://programming.reddit.com/info/u719/details
18:09:16 <lambdabot> Title: Expressive power of languages: design patterns considered harmful ... (1990) (re ...
18:09:24 <dons> how many years before the 'design patterns' book?
18:09:58 <glguy_> i left my Go4 book at work...
18:10:24 <glguy_> I actually bought that book because it was on sale at Borders once (before I knew it was such a standard)
18:10:46 <glguy_> and didn't know it was the "gang of four" book until someone at work clued me in :)
18:11:42 <emu> ah, Felleisen
18:12:22 <mbishop> glguy_: could you paste a quick example of getting a random int from the range 0-10? or any range for that matter heh, just need to see how it should be done
18:12:28 <Cale> What is this idea of ihope's?
18:12:46 <ihope> Pattern matching on ++ when one side is a constant.
18:13:28 <glguy_> mbishop: randomRIO (1,10) >>= print
18:13:57 <dons> > randomRs (0,10) (mkStdGen  42)
18:13:58 <lambdabot>  [4,9,3,3,5,8,6,5,4,8,4,8,6,5,3,4,8,5,7,1,10,10,5,3,5,4,6,5,7,9,1,6,6,4,4,2,8...
18:14:11 <dons> > head $ randomRs (0,10) (mkStdGen  42)
18:14:12 <lambdabot>  4
18:14:13 <jlouis> felleisen is cool
18:14:16 <mbishop> glguy_ and dons: thanks :)
18:14:16 <dons> > head $ randomRs (0,10) (mkStdGen  43)
18:14:18 <lambdabot>  0
18:15:02 <glguy_> is the use of the randomRIO function considered poorer form than using the RandomGen functions?
18:15:07 <LoganCapaldo> Is 42 / 43 the seed?
18:15:33 <dons> yep
18:15:40 <dons> you can use a random seed from IO if you like
18:15:49 <glguy_> ?hoogle getStdGen
18:15:50 <lambdabot> Random.getStdGen :: IO StdGen
18:15:57 <LoganCapaldo> can you use the time of day like an oldtimey language?
18:16:07 <dons> if you like .
18:16:19 <dons> do s <- getCPUTtime ; randomRs (0,10) (mkStdGen s)
18:16:21 <dons> :)
18:16:30 <LoganCapaldo> good enough for me
18:16:51 <LoganCapaldo> way better then when I was learning forth and had to google for an imple of a prng
18:17:20 <dons> :t do t <- System.CPUTime.getCPUTime ; System.Random.randomRs (0,10) (mkStdGen (fromIntegral s))
18:17:21 <lambdabot> Not in scope: `s'
18:17:23 <dons> :t do t <- System.CPUTime.getCPUTime ; System.Random.randomRs (0,10) (mkStdGen (fromIntegral t))
18:17:24 <lambdabot>   Couldn't match `IO' against `[]'
18:17:25 <lambdabot>    Expected type: IO t
18:17:33 <LoganCapaldo> Oh, has anyone done Error + Cont => Resumable Exceptions?
18:17:37 <dons> :t do t <- System.CPUTime.getCPUTime ; print $ System.Random.randomRs (0,10) (mkStdGen (fromIntegral t))
18:17:39 <lambdabot> IO ()
18:18:05 <Cale> ihope: That would be odd if ++ was locally shadowed.
18:18:20 <ihope> Would be odd if what?
18:18:38 <nornagon> if you overrode ++
18:18:50 <nornagon> let (++) = "hi!" in ...
18:18:55 <Cale> Suppose the module you're in also defines (++) and doesn't import it from the prelude -- does it still work?
18:19:07 <jlouis> LoganCapaldo, sounds like fun
18:19:24 <ihope> Oh yeah.
18:20:29 <sjanssen> we just need views
18:20:59 <LoganCapaldo> Just make ++ a constructor
18:21:35 <glguy_> i like the use of "just"
18:21:50 <dons> mmm "Python is getting harder to describe in Lisp terms. It's moving more in the direction of Haskell." -- random internet quote
18:21:55 <LoganCapaldo> Just is a good word :)
18:21:55 <Cale> LoganCapaldo: then you don't have lists, you have trees
18:22:22 <LoganCapaldo> So?
18:22:23 <Cale> dons: really? I haven't seen so much evidence of that
18:22:30 <LoganCapaldo> That's not a problem is it? :)
18:22:39 <dons> as seen on comp.lang.lisp
18:22:44 <LoganCapaldo> trees are more general than lists anyway :)
18:22:46 <glguy_> LoganCapaldo: and you would only be able to match on lists that were constructed using that constructor and not generally between ++ and :
18:22:47 <dons> (not sure its really true, given Guido ;)
18:23:05 <Cale> Well, the important thing which makes lists what they are is that head and tail are both O(1) on any nonempty list.
18:23:34 <LoganCapaldo> Haskell would be given the option of representing any list in the most convient form :)
18:23:48 <LoganCapaldo> For the given pattern match
18:24:03 <LoganCapaldo> So a:"bc" and "a" ++ "bc" would still be the same :)
18:24:06 <glguy_> you smell green like a troll ;)
18:24:15 <LoganCapaldo> and it would just shuffle around until it got a good :)
18:24:24 <Cale> Okay, suppose that ++ is a constructor, what is [1..] ++ [1..] ?
18:24:32 <Cale> It's not equal to [1..]
18:24:39 <xerox> Cale, nullity
18:24:59 <xerox> ..oops :)
18:25:22 <Cale> No, it's a tree, with the root vertex having degree 2, and all the others having degree 1.
18:25:31 <LoganCapaldo> Cale: Who pattern matches against [1..] ++ [1..] anyway? :)
18:25:43 <Cale> LoganCapaldo: unsuspecting functions
18:25:43 <nornagon> heh
18:25:50 <Cale> f (xs ++ ys) = ...
18:27:05 <LoganCapaldo> Well that of course would be illegal
18:27:17 <LoganCapaldo> its not useful for checking if a string starts with a value :)
18:27:18 <glguy_> ugh, I expected quick dismissal from Cale and no pursuit from ihope, not LoganCapaldo hijacking the troll ;)
18:27:26 <nornagon> * HaskellPolice frogmarches Cale away
18:27:51 <Cale> You said you wanted to make ++ a data constructor
18:28:07 <LoganCapaldo> Maybe I should just head back under the bridge :)
18:28:16 <Cale> which means that ++ is actually represented at runtime as a cell with pointers to its two parameters
18:28:38 <nornagon> that sure is zany
18:28:42 <nornagon> use +++ instead :D
18:28:58 <glguy_> the extra + obviates the 2 cells?
18:28:59 <Cale> Basically, you're advodating data List a = Nil | Cons a (List a) | (List a) :+: (List a)
18:29:20 <mgsloan> Pretty crazy, even a kid at my school heard of the nullity crap
18:29:24 <Cale> which doesn't really look like a list at all :)
18:29:26 <nornagon> heh
18:29:31 <ihope> More like just pattern matching on ++.
18:29:37 <Cale> mgsloan: have you read my piece on it?
18:29:46 <mgsloan> cale - yep, very nice
18:30:06 <glguy_> I think that 0/0 is Psi, and not Phi
18:30:25 <glguy_> which fixes a lot of the flaws in the original Phi argument
18:30:35 <mgsloan> Is anyone persuing elegant alternative systems that solve problems though?  could be an interesting pursuit
18:30:54 <jesusphreak> this might seem like a really ignorant question, but I'm going through a tutorial online, and I'm using hugs
18:30:57 <Cale> Well, he is, it's just his current attempt has problems with it.
18:31:01 <jesusphreak> Hugs tells me that x = 4 is invalid syntax?
18:31:14 <Excedrin> jesusphreak: hi, try: let x = 4
18:31:15 <Cale> jesusphreak: Hugs doesn't accept declarations at the prompt
18:31:23 <Cale> put your definitions in a file
18:31:34 <Cale> and load that in hugs, where you can evaluate expressions to test them out
18:31:37 <jesusphreak> I see
18:31:39 <jesusphreak> thanks
18:31:46 <Cale> by typing :r in hugs, you reload the file
18:31:52 <Excedrin> jesusphreak: typically you should enter definitions in a file and use ":load file.hs" and ":r" (for reload)
18:32:06 <Cale> So usually you keep your editor open next to your hugs window and just reload when you make a change
18:32:20 <Cale> same goes for ghci
18:32:39 <dons> let f x = x -- valid in ghci though
18:32:44 <Cale> mgsloan: It really is very hard to do better
18:32:57 <glguy_> I've got a strange feeling that people post stuff to reddit to earn karma and for no other reason
18:33:04 * sorear has finished building YHC
18:33:17 <jesusphreak> glguy, I'm surprised you just realize that :)
18:33:29 <jesusphreak> *realized
18:33:35 <glguy_> :-p
18:33:39 <Cale> I wish I could give fractional mod points
18:33:59 <glguy_> I wish I could downmod 10 points at a time, but maybe just once a week
18:34:02 <Cale> hehe
18:34:32 <Cale> Having only 10 points/week wouldn't work for me, since I downmod almost everything I see on reddit
18:34:53 <jesusphreak> I dont really vote up or down much
18:34:56 <glguy_> True, but I don't think that I would ever get all-day-long -10 power
18:35:00 <jesusphreak> unless someone is just off the hook trolling
18:35:03 <Excedrin> jesusphreak: if you use emacs, it has "reload the current buffer" bound to C-c C-l by default
18:35:04 <mgsloan> Yeah, without making things much less convenient.  What bugs me is when there are arbitrary limits that are set just because of some other arbitrary limits, which really aren't their when you look at the gist of the concept.  For example, derivative of abs at 0
18:35:06 <glguy_> but I can see someone giving me once-a-week -10 power
18:35:06 <Cale> Currently, my new list looks like: 1,7,18,27,30,43,59,61,65,101...
18:35:19 <dons> hehe " 	
18:35:20 <dons> grabmail 1 point 1 hour ago
18:35:20 <dons> Nice try But sorry. PHP sucks."
18:35:27 <dons> insightful!
18:35:30 <Cale> That's 9/100
18:35:45 <jesusphreak> oh man, you wouldn't want to say that on Digg
18:35:46 <lispy> glguy_: you use those online code checking contest sites right?
18:35:53 <jesusphreak> though then I'd question your sanity for being on Digg at all
18:35:55 <glguy_> I have
18:35:56 <mbishop> I used to get mod points on slashdot all the time haha
18:36:09 <lispy> glguy_: i got an email from one of those sites (supposedly) but i've never used one
18:36:21 <glguy_> lispy: probably wasn't from me ;)
18:36:21 <lispy> glguy_: and they said i submitted some code (and the showed me the code)
18:36:27 <Cale> mbishop: people always completely ignore my slashdot posts
18:36:29 <lispy> glguy_: and they said i was the correct solution
18:36:35 <glguy_> lispy: Sounds like spam to me
18:36:43 <lispy> glguy_: i'm totally mystified
18:36:50 <glguy_> lispy: was it your code?
18:36:51 * JKnecht wonders if PHP 6 would suck if were implemented in Haskell
18:36:52 <lispy> glguy_: but they didn't advertise anything
18:36:55 <Cale> http://slashdot.org/~cgibbard/
18:36:56 <lispy> glguy_: nope, it was in C++
18:36:57 <lambdabot> Title: cgibbard - Slashdot User
18:37:05 <lispy> glguy_: and not the kind of C++ i would write
18:37:05 <jesusphreak> okay, another Haskell related question - going through the Haskell for C programmer tutorial, it continually is defining types for values and functions before using them...is that idiomatic, is it something that you must do most of the time, or is that just how he is doing it in the tutorial?
18:37:08 <mbishop> Cale: I mean, I was given points to distribute :P
18:37:13 <glguy_> lispy: do you drunk-code?
18:37:21 <glguy_> lispy: I've never had something like that happen to me...
18:37:25 <lispy> glguy_: would you mind looking at it to help determine if it's spam?
18:37:34 <Cale> mbishop: ah, yeah, that's not hard
18:37:36 <glguy_> I suppose, paste it to lisp paste??
18:37:40 <lispy> glguy_: when i get drunk enough to forget, i don't code :)
18:37:43 <glguy_> s/\?//
18:37:59 <mbishop> Cale: yeah, it stopped after a while though...course I stopped reading slashdot anyway so :)
18:38:10 <lispy> ?paste
18:38:10 <lambdabot> http://paste.lisp.org/new/haskell
18:38:17 <Cale> yeah /. is definitely worse than programming reddit
18:38:29 <Excedrin> ahaha this greasemonkey reddit killfile is awesome
18:38:30 <glguy_> Slashdot, the modding up and down on that site is hillarious
18:38:40 <Cale> and I still mod down over 90% of things posted to programming reddit
18:38:44 <mbishop> programming.reddit.com still has SOME decency...can't say the same for the main reddit page
18:38:52 <glguy_> "Insightful" takes on a whole new definition
18:39:27 <dons> mbishop: I suspect that say, 4 people in this channel modding things is enough to keep programming.reddit functional *cough*
18:39:30 <dons> I mean, decent
18:39:40 <glguy_> lol, "functional"
18:39:48 <mbishop> heh
18:39:50 <jesusphreak> the main Reddit page is lame
18:39:57 <jesusphreak> I hardly ever read it
18:40:07 <lisppaste2> lispy pasted "wth?" at http://paste.lisp.org/display/31737
18:40:10 <glguy_> gizmo needs to start getting a default -3 to his submissions
18:40:29 <dons> yeah, there's 2 or 3 people who submit way to much random stuff
18:40:36 <mbishop> I still want to create a reddit-ish clone that's JUST technology...no need for sub reddits heh, it'll basically be programming.reddit.com as it's main page...but hopefully less losers :)
18:40:37 * dons suspects they have rss feeds for the word 'programming' 
18:40:55 <jesusphreak> mbishop, I've been wanting to do the same as well
18:41:07 <jesusphreak> really it is something that could be done in an hour or two with a decent framework, but I'm lazy
18:41:12 <dons> Cale: you had 10k hits on your nullity takedown?
18:41:16 <lispy> glguy_: what do you think? looks authentic
18:41:25 <glguy_> lispy: maybe this was the text email, and the HTML was pure spam?
18:41:27 <Cale> I mod down stuff on programming reddit that's technology but not programming. Also, if the article doesn't contain at least a little source code, pretty good chance it's getting modded down.
18:41:35 <dons> ah , no > 6k. thats about right.
18:41:40 <Cale> dons: I haven't been counting
18:41:43 <lispy> glguy_: that's the entire source of the email
18:41:45 <mbishop> yeah, a friend was writing a framework from scratch in PHP...needless to say, he didn't finish (probably because it was PHP :))
18:41:46 <dons> "This page has been accessed 6,470 times."
18:41:49 <lispy> glguy_: so, no html included
18:42:02 <jesusphreak> I would like to see something like Django in Haskell :)
18:42:18 <dons> how close is HAppS to that?
18:42:23 <jesusphreak> Django would actually be a very nice basic layout for a framework in any language
18:42:34 <dons> really thoug -- i've been thinking about this -- we need a web guy to just do it.
18:42:58 <jesusphreak> hey, if I ever learn enough Haskell, I will
18:43:01 <glguy_> lispy: I've seen a reference to this website (i believe) in a programming contest book at Borders
18:43:01 <Cale> Pretty much anything which mentions the words "rails", "agile", "PHP", "Web 2.0", etc. are all modded down :)
18:43:16 <glguy_> lispy: but I can't imagine why they would sent you the email if you aren't participating
18:43:25 <glguy_> lispy: but there are email based competitions
18:43:59 <jesusphreak> but I digress, back to the basics: going through the Haskell for C programmer tutorial, it continually is defining types for values and functions before using them...is that idiomatic, is it something that you must do most of the time, or is that just how he is doing it in the tutorial?
18:44:02 <lispy> glguy_: look at the solution
18:44:05 <mbishop> Cale: what if it's "Haskell is better than PHP agile rails web 2.0"? :P
18:44:11 <lispy> glguy_: who everwrote that already know the answer
18:44:12 <glguy_> LOL, I love to see the 30-something year old men thumbing through PHP books at the library
18:44:26 <jesusphreak> poor guys, don't lol at them
18:44:35 <glguy_> lispy: it makes sense that they submitted the program via email
18:44:43 <lispy> glguy_: you've probably seen me then, i'm usually shaking my head if the book says "php"
18:45:08 <lispy> glguy_: i mean, they hardcoded the solution instead of an algorithm for solving it
18:45:37 <glguy_> lispy: yeah... I have no idea really :)
18:45:46 <lispy> glguy_: yeah, i'm weirded out by it
18:45:50 <lispy> i should try to contact them
18:47:02 <jesusphreak> whoa, hold on.... even x = 1 is a function with no parameters? am I understanding that right?
18:47:06 <nornagon> jesusphreak: you don't have to define types for anything unless it's ambiguous
18:47:16 <nornagon> which most of the time it isn't
18:47:17 <lispy> their website is so hard to read...it makse my eyes hurt
18:47:51 <jesusphreak> nornagon, that's what I was thinking...I hadn't seen it in other tutorials, I suppose this one is really just make sure you understand how types work
18:47:51 <nornagon> but most people do put the types in a) because it makes it clearer what the function does and b) because if you then change the function, you're assured that it still has the same type.
18:48:21 <jesusphreak> ah, it is a bit like testing?
18:48:28 <nornagon> mhm
18:48:35 <nornagon> a bit
18:50:13 <glguy_> I ought to get some more reading it before my fiancÃ©e gets back from spending my money on Christmas with my mom :)
18:50:52 <xinming> Pastorn: welcome back. :-)
18:51:36 <CrewdenX> glguy: funny because they're 30 something or because they're looking at php?
18:51:44 <xinming> Pastorn: I didn't finish the resolve function.
18:51:52 <xinming> Pastorn: I'll join i-like-hof
18:51:53 <glguy_> CrewdenX: both
18:52:00 <glguy_> CrewdenX: seems like the wrong time to be starting bad habits
18:52:14 <CrewdenX> glguy_: hehe, ok.
18:52:23 <glguy_> like they should have made those mistakes when they were younger ;)
18:52:27 <glguy_> but should be acting their ages now
18:52:43 <shapr> I'm 35 and I thumb through type theory books...
18:53:00 <glguy_> are you relating that to reading Teach Yourself PHP in 6 Hours?
18:53:19 <shapr> yeah
18:53:26 <shapr> Teach yourself Type Theory in Ten Years.
18:53:32 <lispy> http://norvig.com/21-days.html
18:53:33 <lambdabot> Title: Teach Yourself Programming in Ten Years
18:54:04 <lispy> norvig.com has a lot of really cool stuff
18:55:16 <jesusphreak> Hey, I have a Teach Yourself Ruby in 21 Days book, but it lied and isn't very good anyway
18:55:33 <jesusphreak> I should sue for false advertising
18:57:58 <lispy> > 21 * 8
18:57:59 <lambdabot>  168
18:58:24 <lispy> if you put in 168 hours of ruby in 21 days, you would know it decently by the end, assuming you already knew programming
18:58:33 <shapr> Is that also true of Haskell?
18:58:50 <lispy> can i assume you know ocaml really well?
18:58:52 <lispy> ;)
18:59:17 <sorear> are you a skilled learner?
18:59:21 <jesusphreak> to be honest, I checked out OCaml and Haskell, and so far I'm finding Haskell a lot simpler and elegant
18:59:28 <jesusphreak> but maybe that's because I haven't gotten to the complicated stuff
19:00:16 <lispy> shapr: i think haskell goes into deeper concepts than most programming languages, like ruby, so you can study haskell longer and learn more about it and still be "intermediate"
19:00:17 <dylan> haskell is superior to ocaml for almost everything
19:00:26 <lispy> shapr: but, at the same time, i totally agree with norvig
19:00:31 <shapr> lispy: I agree with you.
19:00:38 <shapr> Haskell has held my interest for years.
19:00:55 <jesusphreak> Haskell has spiked my interest for a week or two, is that oaky? :)
19:01:06 <lispy> jesusphreak: yes, it's very god
19:01:08 <lispy> er good
19:01:24 <Excedrin> jesusphreak: have you encountered monads yet?
19:01:24 <sorear> haskell is the higher kinded typed lambda calculus with several tons of syntactic sugar
19:01:50 <jesusphreak> Excedrin, ha, thankfully not, but due to other people's comments I can't say I am looking forward to doing so
19:01:52 <mgsloan> would you like some lambdas with your sugar?
19:02:42 <dylan> IMHO ocaml's object system is harder to understand properly than monads.
19:02:43 <shapr> I really like the "You may have already invented monads." post.
19:03:00 <lispy> > do { x <- [1..3]; y <- ['a' .. 'c']; return (x,y) } -- ha, now you've encountered monads!
19:03:02 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
19:03:27 <glguy_> my, what a clear first encounter
19:03:38 <jesusphreak> OO was a lot more difficult for me to understand than functional programming has been, but maybe that's because I'm a bit more experienced in programming
19:03:46 <jesusphreak> but OO seems inherently complex
19:03:54 <sorear> > liftM2 (,) [1..3] ['a'..'c']
19:03:55 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
19:04:16 <dylan> OO in the smalltalk sense is not hard, but OO in the C++ or java sense is.
19:04:21 <shapr> jesusphreak: I think that too.
19:04:21 <lispy> > return 1 :: Maybe Int
19:04:22 <lambdabot>  Just 1
19:04:25 <lispy> another monad
19:04:57 <Excedrin> jesusphreak: you know how there's a distinction between statements and expressions in Python, and some statements only accept an expression? Uh, I'm not sure where I was going to go with that, except that in Haskell stuff that does IO gets an IO type, so you can't evaluate it outside of the IO monad...
19:05:04 <lispy> > Just 2 >>= return  :: Maybe Int -- and another one
19:05:05 <lambdabot>  Just 2
19:05:08 <glguy_> > range ((1,'a'),(3,'c'))
19:05:10 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
19:05:27 <sorear> Monads are just another an algebraic structure, like the groups and fields from lower levels of math.
19:05:40 <jesusphreak> Excedrin, that comparison does seem way out there, but I get the gist of what you mean :)
19:05:53 <sorear> > join [[1,2],[3]]
19:05:54 <lambdabot>  [1,2,3]
19:05:59 <sorear> > join (Just (Just 2))
19:06:01 <lambdabot>  Just 2
19:06:12 <sorear> > join (\x -> (\y -> (x*y)) 5
19:06:12 <lambdabot>  Parse error
19:06:15 <jesusphreak> who hold on, was 'join' a monad?
19:06:19 <xerox> > join (*) 2
19:06:21 <lambdabot>  4
19:06:23 <jesusphreak> is *
19:06:23 <lispy> ?type join
19:06:25 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:06:40 <lispy> join is a function which operates on monads
19:06:56 <sorear> monads have multiple definitions... join is one of the basic operators, like (+) in groups
19:07:08 <sorear> in other definitions, join is derived, like (-) in groups
19:07:08 <jesusphreak> I see
19:07:14 <dons> :t Control.Monad.join
19:07:15 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:07:22 <lispy> join, (>>=) and return are all basic to monads
19:07:40 <Excedrin> can't join be derived from (>>=) and return?
19:07:40 <lispy> :t return
19:07:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
19:07:42 <sorear> Haskell has standardized on (>>=) and return, but there are many other bases (basis?)
19:07:48 <sorear> Excedrin:yes.
19:07:51 <dons> I think Beck would be a functional programmer if he was a hacker
19:07:55 <sorear> join x = x >>= id
19:07:59 <jesusphreak> this is a bit OT, but is WinHugs written entirely in Haskell?
19:08:05 <dylan> who is Beck?
19:08:09 <dons> jesusphreak: hugs is written in C, I think
19:08:12 <sorear> a (>>=) b = join (fmap b a)
19:08:18 <sorear> hugs is an interpreter.
19:08:20 <Excedrin> dons: he'd use Oz, with inline 68000 assembly
19:08:21 <dons> jesusphreak: and I think so is winhugs' wrapper (ndm might correct me there)
19:08:24 <dons> hehe
19:08:25 <jesusphreak> oh, for some reason I was under the impression that Hugs was written in Haskell, I'm not sure why
19:08:27 <dons> Excedrin: maybe!
19:08:40 <dons> Excedrin: a lot of FFI anyway
19:09:03 <sorear> GHC is written in haskell, like GCC is written in C (compilers)
19:09:22 <dons> jesusphreak: its a bit of an odd ball, every other haskell system is written in haskell -- bugs hugs is super old
19:09:22 <sorear> Hugs, like (standard) python and perl are C (interpreters)
19:09:26 <dons> going back to its gofer days
19:09:34 <Excedrin> is there a simple parsing tutorial somewhere?
19:09:36 <jesusphreak> ah okay, I knew one of the 'biggies' was written in purely Haskell
19:09:37 <dons> s/but/
19:10:05 <lispy> Excedrin: parsec has a tutorial about parsec
19:10:16 <lispy> Excedrin: what do you want to learn?
19:10:21 <dons> dylan: http://en.wikipedia.org/wiki/Mellow_Gold
19:10:25 <lispy> Excedrin: parsing is pretty broad
19:10:56 <Excedrin> which parser is simplest / easiest to use, for a quick and dirty parsing task? (think replacing sed/awk/sh)
19:11:00 <sorear> like groups, rings, etc, there are many monad-like structures: Functor, Applicative, Alternative, Monad, MonadPlus, MonadFix, Arrow
19:11:22 <lispy> Excedrin: i'm parsial to parsec, but others seem very happy with.... happy
19:11:23 <dylan> dons: hey, can I see a screeny of your dwm setup? (in exchange for one of mine, perhaps? :))
19:11:27 <sorear> Excedrin: top-down recursive descent is easy if you don't have time to learn a library
19:11:42 <dons> dylan: ok... /me tries this
19:11:48 <sorear> I mostly use parsec these days though
19:11:57 <Excedrin> ok, thanks
19:12:05 <lispy> sorear: parsec encourages top-down recursive descent :)
19:12:22 <sorear> I meant TDRD by hand.
19:12:27 <lispy> ah
19:12:28 * fizbin has parsed a very, very, *very* simple language without any combinators, but it really was a dirt-simple language
19:12:51 <jesusphreak> holy crap, I'm absolutely loving what I'm learning about Haskell right now
19:12:53 <sorear> And I've parsed a rather more complex language,
19:12:57 <jesusphreak> the syntax is *so* nice
19:14:12 <jesusphreak> excuse me for my noobness, its just this is an exciting language
19:14:20 <dons> dylan: http://www.cse.unsw.edu.au/~dons/tmp/dwm.png
19:14:24 <dons> jesusphreak: great!
19:14:27 <sorear> Haskell is the Anti-Perl.  Very complex concepts, clean syntax, no DWIM, etc.
19:14:42 <dylan> dons: and http://hardison.net/warez/dwm-2006-12-08.png -- patched for my bottom-feeder ways.
19:15:06 <sorear> I learned Haskell several months ago, it's the only second language out of 15-odd that I became a regular uuser of.
19:15:14 <jesusphreak> pardon me, sorear, DWIM?
19:15:29 <dylan> "do what I mean"
19:15:52 <jesusphreak> ah okay
19:16:10 <sorear> Do What I Mean.  The infamously helpful and hurtful thing that makes Perl Perl.
19:16:24 <jesusphreak> thankfully I've never touched Perl, but I've used enough Ruby to get the idea
19:16:27 <Excedrin> aka the .. operator
19:16:52 <eviltwin_b> and barewords and autoquoted hash keys and and and...
19:16:58 <dons> dylan: i've recently switched to using AA fonts in the terminal, as you can see
19:17:14 <dylan> dons: 1, 2, 3, 4, F, eh?
19:17:27 <dons> yeah, T and F
19:17:28 <dons> I don't dig the =[] thingy
19:17:36 <dons> Float , Tile
19:17:44 <dylan> Ah.
19:17:58 <newsham> @($perl->{'perl'})[$#perl]("perl");
19:17:59 <lambdabot> Unknown command, try @list
19:18:02 <dylan> have you found using numbered tags is easier?
19:18:09 <Jessehk> I'm getting errors about indentation in a Haskell program. I might be attempting something stupid. :p http://paste.lisp.org/display/31740
19:18:19 <lispy> dons: yes, when do we get true color consoles with support for vector grahpics character cells (to better support unicode)?
19:18:27 <dylan> newsham: that's not quite valid syntax.
19:18:29 <dons> dylan: yeah, i just remember 1..4
19:18:36 <lispy> dons: oh and AA fonts on those consoles
19:19:02 <dylan> xterm can support up t 256 colors.
19:19:06 <newsham> "elem :: helper (x - 1)" ?
19:19:14 <lispy> dylan: i know, pretty cool
19:19:21 <wy> I'm trying the parser on Peyton Jones's book and got the error. Anyone can have a look at http://paste.lisp.org/display/31741 ?
19:19:21 <dylan> I prefer urxvt though
19:19:30 <eviltwin_b> jessehk: "in" must be indented more than the "let"
19:19:44 <newsham> jesse: do you mean cons?    elem : helper (x - 1) ?
19:19:46 <dons> jesusphreak:  :: isn't cons
19:19:48 <eviltwin_b> (I indent it a single space beyond the let)
19:19:53 <dons> s/Jessenk/
19:20:18 <Jessehk> I meant cons, but I think that was a coping error
19:20:25 <Excedrin> what's @() in Perl? (not valid afaik?)
19:20:26 <eviltwin_b> tht also but it wouldn't be the indent error
19:20:39 <jesusphreak> how is Haskell in its Unicode support, btw?
19:20:43 <eviltwin_b> not valid; @{} is an array deref
19:20:43 <dylan> @() is not valid
19:20:44 <lambdabot> Maybe you meant: . bf ft id pl v wn
19:20:44 <newsham> excedrin: the thing in the parens is a list.
19:20:56 <eviltwin_b> (valid in perl6, actually, IIRC)
19:20:58 <newsham> my perl is several years rusty.
19:20:58 <dons> Jessehk: http://paste.lisp.org/display/31740#1
19:21:15 <wy> dons: Can you help me and have a look at http://paste.lisp.org/display/31741 ?
19:21:22 <Excedrin> newsham: do you mean @{}?
19:21:29 <newsham> its possible.  i dont really care.
19:21:34 <dons> wy, yes.
19:21:44 <wy> dons: Thanks!
19:21:45 <newsham> i will never use perl again, so its not really important.
19:21:53 <eviltwin_b> wy: where operates on n entire group, can't have guards after it
19:22:09 <fizbin> You know what's weird?  Yesterday I was watching the chatterbox on perlmonks, and they spent at least 30 minutes talking about Haskell...
19:22:14 <Jessehk> dons: So it's a difference in syntax. Thanks once again.
19:22:26 <wy> eviltwin_b: I see... What's the remedy here?
19:22:35 <eviltwin_b> fizbin: pugs (perl6 implementation) is written in haskell
19:22:38 <lispy> fizbin: we spent at least that long talking about haskell here too
19:22:56 <dons> Jessehk: you can use 'let' if you want, and ':' instead of '::'
19:23:01 <dons> Jessehk: but the 'where' is simpler
19:23:04 <fizbin> eviltwin_b: Well, yeah.  That's what started it.
19:23:06 <dons> and the pattern matching is simpler than the case
19:23:26 <eviltwin_b> and yes, there's a lot of haskerll interest as a result.  and perl6 seems to have picked up quite a few ideas from haskell
19:23:46 <lispy> it sure would be an interesting world if, say, 50% of existing perl advocates starting using/advocating haskell
19:23:53 <lispy> it would be mainstream then! ;)
19:24:07 <jesusphreak> whoa, that would make it a more popular language than *a lot* of others
19:24:17 <newsham> lispy: interesting as in "whoa, what happened to haskell and why are these people adding weird punctuation to it"?
19:24:23 <eviltwin_b> wy: put a single where at the end, or use let instead
19:24:26 <lispy> newsham: heh
19:24:45 <eviltwin_b> (you'd have to rename the second rest_cs in the former case)
19:24:47 <lispy> newsham: i'm just hoping that some day i can have a developer job which i appreciate :)
19:25:05 <lispy> one where my eagerness to test is not met with, "Um...get back to work"
19:25:17 <wy> eviltwin_b: Thanks! And I can't find isDigit, isAlpha. Where can I find those function?
19:25:17 <newsham> if haskell is so great, why dont a bunch of haskellers get together and simply outdo the competition?
19:25:26 <lispy> and my excitement for proving things in to met with, "Huh, just write the code!"
19:25:32 <newsham> faster development time, more secure, good performance, etc..
19:25:44 <lispy> newsham: i think that was last night's discussion :)
19:25:49 <dons> wy, Data.Char
19:25:58 <dons> wy, http://paste.lisp.org/display/31741#1
19:26:01 <lispy> newsham: but, galois seems to be doing this
19:26:01 <newsham> ahh, missed it, was too busy writing haskell code :)
19:26:08 <lispy> newsham: heh, exactly
19:26:12 <newsham> one company does not an industry make
19:26:42 <lispy> newsham: then what did you mena by a bunch of haskellers?
19:26:51 <dons> newsham: there's a start (but note that there's a *lot* of haskell jobs at unis too), http://haskell.org/haskellwiki/Haskell_in_industry
19:26:52 <lambdabot> Title: Haskell in industry - HaskellWiki
19:26:59 <dons> (the big ones being Galois and Aetion)
19:27:00 <newsham> sorry.. i meant "thats great, but more people should do th esame"
19:27:04 <dons> (in the high assurance/defence game)
19:27:14 <newsham> there are lots of areas haskell can be applied.  galois is targetting one niche.. there are lots left.
19:27:49 <jesusphreak> it seems like the discussion about Haskell on Reddit has created a lot more awareness of the language
19:28:16 <lispy> newsham: i'd love to apply (or at least try) haskell to game development
19:28:35 <lispy> take for example, modern MMORPGs
19:28:50 <lispy> using the concurrency of haskell i bet you could write more scalable servers
19:29:21 <dons> wy, cleaned up: http://paste.lisp.org/display/31741#2
19:29:34 <dons> lispy, yeah, I'm going to port HWS to the smp runtime for the next monad.reader
19:29:44 <dons> then run the apache benchmarks on it
19:29:47 <lispy> we're going to have another monad.reader? cool
19:29:50 <dons> should be a nice little tut
19:30:09 <newsham> dons: HWS doesnt seem like the ideal target.   HWS serves static pages.   something like HAppS would be more relevant (hosting web applications)
19:30:22 <dons> http://www.haskell.org/haskellwiki/TheMonadReader
19:30:24 <lambdabot> Title: TheMonadReader - HaskellWiki
19:30:28 <dons> newsham: way more work though
19:30:34 <newsham> ahh
19:30:35 <dons> for a tutorial!
19:30:51 <lispy> dons: any updates on the haskell specific search engine?
19:30:55 <newsham> well, i welcome any advances to HWS.  I use it as my web server :)
19:30:59 <dons> writing a tiny-server would be another option
19:31:31 <xerox> dons: who's tmr editor for this issue?
19:31:45 <dons> swiert
19:31:53 <lispy> i can't use HWS unless it was talking to apache
19:31:56 <xerox> that's awesome, swiert++
19:32:12 <lispy> i need apache for the other people on my box but afaict only one program gets to listen on port 80
19:32:21 <Svrog> if you own a small company that heavily uses haskell it may be in your interest for haskell to not become mainstream as well as to keep quiet about using haskell as you'd have the edge over competition that mostly relies on c++/java/c# ;)
19:32:41 <dons> Svrog: yes, that's been mentioned before: people keep their haskell use secret
19:32:48 <Svrog> hehe
19:33:03 <wy> dons: Thanks a lot! It's better than Jones's code. What's the meaning of flip elem ...?
19:33:13 <lispy> :t flip
19:33:14 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
19:33:24 <lispy> > flip (-) 1 3
19:33:25 <lambdabot>  2
19:33:31 <lispy> wy: makes sense now?
19:33:50 <dons> wy, so I don't have to write:   f c = elem c ['a' .. 'z']
19:33:56 <dons> ?pl f c = elem c ['a' .. 'z']
19:33:57 <lambdabot> f = flip elem ['a'..'z']
19:33:59 <dons> :}
19:34:19 <dons> Jone's code?
19:34:21 <xerox> ?type let f = flip f in f
19:34:23 <lambdabot> forall a c. a -> a -> c
19:34:25 <lispy> function application binds tightest, so you read that as f = (flip elem) ['a' .. 'z']
19:34:27 <xerox> AH.
19:34:35 <xerox> that's cute
19:34:52 <dons> xerox: hehe
19:35:41 <wy> dons: I mean Simon Peyton Jones. I'm trying his code and reading the book
19:36:03 <dons> yikes!
19:36:04 <xerox> it's like a twister on the entrance of f, two 'a' defend the gate to the c abyss
19:36:09 <wy> lispy, dons: so flip is swapping the arguments
19:36:13 <dons> yeah
19:36:17 <dons> :t elem
19:36:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
19:36:19 <dons> :t flip elem
19:36:20 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
19:36:24 <dons> takes the list first
19:36:47 <dons> which then means you don't have to name the char argument, due to currying
19:37:05 <wy> dons: That's great! eta-reduction
19:37:36 <Jessehk> Woah! the bot knows types? Let me try...
19:37:40 <Jessehk> :t map
19:37:41 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:37:54 <lispy> there is a frat around here with two greek symbols and a bovine outline it looks like, eta-cow-pi
19:38:06 <Jessehk> :t filter
19:38:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:38:07 <ralf`> @time ralf`
19:38:13 <lispy> lambdabot is very smart
19:38:15 <lambdabot> Local time for ralf` is Fri Dec  8 19:33:45 2006
19:38:17 <lispy> ?hoogle filter
19:38:18 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
19:38:18 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
19:38:18 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
19:38:34 <lispy> ?hoogle (a -> Bool) -> [a] -> [a]
19:38:35 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
19:38:35 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
19:38:35 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
19:38:37 <dons> anyone have a vim new enough to try out claus' block syntax patch: http://www.cse.unsw.edu.au/~dons/tmp/blocks.vim
19:38:37 <newsham> @elite I am very smart
19:38:38 <lambdabot> i a/\/\ V3RY $/\/\ARt
19:38:41 <ralf`> dons: I'd like to read through some lambdabot code.  Can you recommend any to start with?
19:38:48 <dons> ?version
19:38:49 <lambdabot> lambdabot 4p302, GHC 6.5 (OpenBSD i386)
19:38:49 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:38:55 <dons> hmm, well, most of the fun stuff is in Plugin/
19:39:02 <dons> just dive in and look at the plugins you're interested in
19:39:10 <Jessehk> dons : You wrote it?
19:39:19 <newsham> @. elite quote lambdabot
19:39:19 <ralf`> heh heh.
19:39:20 <lambdabot> |4/\/\bd4BO7 hA$N'7 54id AnYt|-|Ing me/\/\0r4BL3
19:39:21 <fizbin> Does anyone know where I can find some code using the ((->) r) monad?  I've been playing around with it, and I can't quite figure out what the point of it is.
19:39:24 <ralf`> @elite elite is pretty cool.
19:39:24 <lambdabot> e|I73 iz PRet+Y CooL.
19:39:40 <dons> Jessehk: I just maintain it for the last couple of years. Pseudonym was the original author
19:39:46 <dons> but there's been about 80 contributros
19:39:50 <lispy> wow, nice
19:39:57 <lispy> i should contribute more
19:40:15 <lispy> maybe i can write that timer plugin this weekend
19:40:25 <lispy> but i might be doing darcs research instead!
19:40:32 <wy> dons: What does ?pl?
19:40:38 <newsham> fizbin: i imagine it lets you do cool section manipulations with liftM, liftM2, ap, fmap, etc..
19:40:38 <lispy> ?help pl
19:40:39 <lambdabot> pointless <expr>. Play with pointfree code.
19:40:45 <dons> ?wiki Pointfree
19:40:46 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
19:41:03 <lispy> ?pl \x y -> x + y
19:41:03 <lambdabot> (+)
19:41:34 <lispy> ?pl foo f xs = length (map f xs)
19:41:35 <lambdabot> foo = (length .) . map
19:41:51 <lispy> wy: ^^
19:42:59 <newsham> > liftM (+ 3) (* 2) 8
19:43:00 <lambdabot>  19
19:43:12 <mgsloan> ?pl foo = length . map
19:43:13 <lambdabot> foo = length . map
19:43:48 <newsham> > liftM2 (+ 3) (* 2) (* 4) 8
19:43:49 <lambdabot>    Occurs check: cannot construct the infinite type: a2 = a2 -> r
19:43:49 <lambdabot>    Exp...
19:44:05 <wy> dons: I didn't know that Lambdabot is your program!
19:44:10 <mgsloan> > (length . map) (*2) [1..10]
19:44:11 <lambdabot>    Expecting a function type, but found `b'
19:44:12 <lambdabot>    Expected type: (a1 -> b) ...
19:44:14 <lispy> > liftM (+ 3) (* 2) (* 5) 8
19:44:15 <lambdabot>  add an instance declaration for (Num (a -> a))
19:44:17 <newsham> > liftM2 (+) (* 2) (* 4) 8
19:44:18 <lambdabot>  48
19:44:23 <ihope> GHC isn't apt-gettable, is it?
19:44:31 <lispy> ihope: it is
19:44:35 <lispy> ihope: distro?
19:44:40 <ihope> Ubuntu.
19:44:46 <lispy> oh hmm...
19:44:47 <hyrax42> it can
19:44:52 <hyrax42> wtf
19:45:05 <hyrax42> ack responding to a billion years ago discussion
19:45:31 <mgsloan> you can. it's in universe
19:45:35 <lispy> hyrax42: are you responding to something you decoded on seti@home?
19:45:35 <ihope> Usenet?
19:45:37 <eviltwin_b> at worst there's universe and multiverse which include debian packages, ubuntu being kept relatively clsoe to its debian origins
19:45:53 <hyrax42> lispy: perhaps some exaggeration was used
19:45:57 <hyrax42> however slight
19:46:21 <lispy> hyrax42: oh, so seti@home didn't decode a real message?
19:46:26 <Cale> It's silly not to turn on universe
19:46:37 <mgsloan> indeed.  I've got em all turned on
19:46:48 <eviltwin_b> universe good; multiverse somewhat less so
19:46:49 <Cale> It's also a good idea to use EasyUbuntu
19:46:57 * ihope checks The Box
19:47:43 <eviltwin_b> (at least, I;ve gotten garbage and confused the heck out of a test system by installing stuff from multiverse)
19:47:49 <newsham> dons: how do I make lambdabot tell me what "return 5" is in ((->) r) ?
19:48:02 <ihope> There we go. Thanks.
19:48:04 <fizbin> >const 5
19:48:06 <newsham> (I'm assuming the answer is "const 5")
19:48:19 <fizbin> > const 5
19:48:20 <eviltwin_b> > const 5
19:48:20 <lambdabot>  Add a type signature
19:48:21 <ihope> newsham: return = const, pretty much
19:48:21 <lambdabot>  Add a type signature
19:48:23 <eviltwin_b> heh
19:48:25 <ptaron-> Hey guys, is there a better channel to go ask newbie ghc questions in?
19:48:34 <lispy> ptaron-: nope
19:48:44 <newsham> yes, but how do I make lambdabot tell me that
19:48:45 <ptaron-> Heh, ok
19:49:07 <ihope> > return 5 undefined
19:49:08 <lambdabot>  5
19:49:11 <xerox> > runReader (Reader id) 5
19:49:12 <lambdabot>  5
19:49:20 <wy> dons: It seems pointfree is not a very good style according to the wiki page
19:49:33 <xerox> wy - lies!
19:49:35 <ptaron-> I can't get a hellow world program to compile :( gcc tells me that "gcc: installation problem, cannot exec `cc1': No such file or directory
19:49:39 <newsham> > runReader (return 5) 8
19:49:41 <lambdabot>  5
19:50:07 <ptaron-> why is ghc relying on gcc? what stuff do I also need to get?
19:50:09 <lispy> ptaron-: what does this command line say: ghc -e 'putStrLn "hello, world!"'
19:50:12 <newsham> > runReader ask 8
19:50:14 <lambdabot>  8
19:50:29 <fizbin> ?type do {m <- (*); return 4}
19:50:30 <lambdabot> forall a a1. (Num a, Num a1) => a -> a1
19:50:31 <xerox> > runReader ((Reader . const) 5) 5
19:50:33 <lambdabot>  5
19:50:35 <xerox> ops
19:51:06 <fizbin> ?type do {m <- (*); return "a"}
19:51:08 <lambdabot> forall a. (Num a) => a -> [Char]
19:51:26 <ptaron-> lispy: the windows version is ghc -e "putStrLn \"hello, world!\"" -- and that prints the string hello, world!
19:51:30 <newsham> so...   how to get "return 5"  for ((->) r)
19:51:40 <xerox> > runReader ((Reader . const) 5) 8
19:51:41 <lambdabot>  5
19:51:44 <fizbin> ?type do {return 5}
19:51:45 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
19:51:50 <lispy> ptaron-: okay. then your ghc is working, but your gcc is not being found (I would guess)
19:52:00 <lispy> ptaron-: could it be a path problem?
19:52:12 * ihope goes to bed
19:52:19 <xerox> newsham: right?
19:52:19 <lispy> ihope: nite
19:52:20 <newsham> for [], I just od    > return 5 :: [Int]
19:52:30 <newsham> > return 5 :: Maybe Int
19:52:32 <lambdabot>  Just 5
19:52:39 <fizbin> ?type do {m <- (id :: Int -> Int); return 5}
19:52:41 <lambdabot> forall a. (Num a) => Int -> a
19:52:45 <newsham> > return 5 :: IO Int
19:52:46 <lambdabot>  <IO Int>
19:52:49 <xerox> > return 5 :: Reader () Int
19:52:50 <lambdabot>  add an instance declaration for (Show (Reader () Int))
19:53:04 <xerox> > snd (return 5 :: Reader () Int,())
19:53:06 <lambdabot>  ()
19:53:08 <xerox> :P
19:53:10 <ptaron-> gcc is in the $(GHC) dir... according to the docs, all I need to do is add $(GHC)\bin to the path, and it finds gcc
19:53:14 <lispy> ptaron-: how did you install your ghc?
19:53:17 <newsham> ?pl return 5 :: Reader () Int
19:53:18 <lambdabot> return 5 :: Reader Int
19:53:25 <lispy> ptaron-: okay, try that
19:53:27 <xerox> haha
19:53:28 <fizbin> > const 5
19:53:28 <lambdabot>  Add a type signature
19:53:42 <fizbin> > const 5 :: Int -> Int
19:53:43 <lambdabot>  <Int -> Int>
19:53:51 <ptaron-> Lispy: From the MSI at http://www.haskell.org/ghc/dist/6.6/ghc-6-6.msi
19:53:59 <xerox> newsham: if you import C.M.R you should be able to use ap & ((->) e) friends directly
19:54:01 <newsham> anyway, this is something I often which I could ask lambdabot to do for me .
19:54:26 <xerox> ?source Control.Monad.Reader
19:54:26 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
19:54:33 <newsham> read it.
19:54:49 <newsham> i'm not asking the question.  i'm asking the question on how to ask the question.
19:55:12 <lispy> ptaron-: okay so i'm right in understanding you have it working now?
19:55:23 <ptaron-> no...
19:55:36 <lispy> oh i thought you just had to add $GHC/bin to your path
19:55:40 <newsham> > (return 5) 8
19:55:42 <lambdabot>  5
19:55:43 <ptaron-> gcc is found. ghc is found. gcc is complaining that it can't find cc1, which was nowhere in the install
19:55:53 <lispy> hmm...
19:56:05 <xerox> newsham: do I understand correctly that things like (return 5) 8 don't give you the expected nice result you get in lambdabot on your local ghci?
19:56:09 <lispy> ptaron-: is it anywhere on your harddirev? ;)
19:56:32 <newsham> xerox: sometimes I see a random "return 5" and I wonder to myself "what does that mean in the current monad"
19:56:44 <ptaron-> not as far as I can find. :) I know it's usually symlinked to something or other on unix, but I'm on Windows
19:56:54 <newsham> and I think "can I somenhow make lambdabot tell me the answer" and the answer is often "I cant figure out how to"
19:57:04 <newsham> so I have to use my thinking cap which I try to avoid.. and dig through some documentation
19:57:10 <xerox> newsham: ah, that's easy
19:57:36 <xerox> feed \bot the expression after ?type
19:57:42 <newsham> ?type return 5
19:57:44 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
19:58:08 <xerox> do you ever define things like funny = return 5 ?
19:58:12 <newsham> so that means "Just 5" then?  obviously!
19:58:20 <xerox> context is the key
19:58:27 <newsham> *sigh*
19:58:36 <xerox> that doesn't mean lambdabot can't do it
19:58:58 <newsham> xerox: great.  my question once again "how do I ask lamdbabot what 'return 5' means in ((->) r)"
19:59:30 <xerox> hmm, we don't have an instances-to-modules mappings, do we...
19:59:36 <dons> here we go, lambdabot commiters graph: http://www/~dons/tmp/lambdabot-commiters.png
19:59:47 <dons> try http://www.cse.unsw.edu.au/~dons/tmp/lambdabot-commiters.png
20:00:06 <resiak> ?type return 5 :: Num a => ((->) r) a
20:00:08 <lambdabot> Num a => ((->) r) a :: forall r a. (Num a) => r -> a
20:00:09 <dons> slackers! where's those patches! I'm looking at *YOU*!       ;)
20:00:11 <newsham> (I'm ont trying to be obtuse.. its just that you seem to be implying that its easy, and I still dont know the answer :(  )
20:00:18 <ptaron-> lispy: any ideas? should I go grab mingw and add that to the path or something?
20:00:36 <xerox> newsham: OK - you type :info Monad in GHCi and you see the file from which you are importing your instance from, and then ask the ?source
20:00:55 <resiak> newsham: I don't know if that's helpful.  :)
20:01:01 <newsham> dons: can you plot that on a log scale?
20:01:09 <lispy> ptaron-: it's weird :(  i'm actually wondering about it being a bug with the mis
20:01:09 <xerox> dons you're crazy.
20:01:11 <newsham> is it a power-law distribution?
20:01:12 <lispy> er msi
20:01:21 <dons> hmm, newsham, I guess. what's the gnuplot  command for a log scale?
20:01:24 <xerox> in a positive way, but I mean, 900!!
20:01:45 <newsham> set logaxis x   or  set xlogaxis  or something like that?
20:01:53 <lispy> dons: what does that measure? # patches or # lines?
20:02:01 <lispy> oh, right must be #patche
20:02:12 <newsham> set logscale x
20:02:23 <ptaron-> Well, if the goal is a functional haskell after the MSI is complete, then it's certainly a bug
20:02:30 <dons> lispy, patches
20:02:42 <ptaron-> I'd gladly file it where-ever your bug database lies...
20:02:48 <newsham> (er.. you probably want set logscale y :)
20:02:48 <lispy> ptaron-: okay, well, if i were you i'd try to report it and also try the mingw install
20:02:58 <dons> ?bug <- ptaron a ghc bug?
20:02:58 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:04:26 <dons> newsham: x range must be greater than 0 for log scale hmm?
20:04:37 <aFlag> hey, does anyone know where I can find more about garbage collection on functional languages?
20:04:38 <newsham> oh yah, wont work for the zero committers
20:04:46 <dons> ah right
20:06:46 <dons> bah, too annoying to fiddle the data
20:06:51 <newsham> s'ok.
20:07:03 <dons> i.e. I got to here, http://www.cse.unsw.edu.au/~dons/tmp/lambdabot-commiters-log.png
20:07:22 <dons> but we want log on y don't we?
20:07:28 <newsham> > (er.. you probably want set logscale y :)
20:07:29 <lambdabot>  Parse error
20:07:46 <chessguy> what's a lambabot committer?
20:08:10 <chessguy> wheee
20:08:18 <dons> newsham: there you go, http://www.cse.unsw.edu.au/~dons/tmp/lambdabot-commiters-log.png
20:08:35 <newsham> thats a log-log :)
20:08:38 <eviltwin_b> rolling reboot time...
20:08:46 <newsham> unset logscale x; replot
20:08:48 <dons> hehe
20:09:04 <dons> does that look right now?
20:09:05 <newsham> ahh, looks good onw
20:09:08 <dons> http://www.cse.unsw.edu.au/~dons/tmp/lambdabot-commiters-log.png
20:09:20 <newsham> nifty
20:09:36 <dons> so what does that tell us again?
20:09:55 <dons> hmm. should add commiter stat support to darcs-graph
20:09:56 <newsham> says its not a power-law distribution (would have a constant negative slope if it were)
20:10:38 <dons> what would that imply? (if it were a power-law dist)
20:10:40 <newsham> but it also is easier to read :)
20:10:52 <dons> yeah
20:11:30 <newsham> http://www.citebase.org/abstract?id=oai%3AarXiv.org%3Acond-mat%2F0412004
20:11:33 <lambdabot> Title: Citebase - Power laws, Pareto distributions and Zipf's law, http://tinyurl.com/ykhqg8
20:12:05 <newsham> ahh, it would be a line on a log-log scale.. my bad
20:12:28 <xerox> hehe
20:12:29 <xerox> g'nite
20:12:33 <xerox> @localtime xerox
20:12:36 <lambdabot> Local time for xerox is Sat Dec  9 04:05:50 2006
20:15:53 <wy> Is there a function to negate a boolean function?
20:16:11 <dons> > not False
20:16:12 <lambdabot>  True
20:16:17 <dons> ?hoogle Bool -> Bool
20:16:18 <lambdabot> Prelude.not :: Bool -> Bool
20:16:18 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
20:16:18 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
20:16:21 <dons> :)
20:16:28 <dons> ?djinn Bool -> Bool
20:16:29 <lambdabot> f a = a
20:16:35 <dons> of course djinn would say that
20:16:55 <lispy> dons: wher is that script?
20:16:57 <dons> wy, roughly what you wanted? a boolean function?
20:17:00 <lispy> dons: i'd like to run it on darcs
20:17:03 <dons> lispy, the graphing script?
20:17:08 <wy> dons: I mean, take whatever the arguments a function might take, but output the negation of the result
20:17:09 <lispy> yeah the commiter log
20:17:32 <dons> its not scripted yet. here's the raw gnuplot script: http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/gnuplot.script
20:17:45 <dons> lispy, then generate the 'authors' file with darcs changes --xml-ouput | sed ...
20:17:55 <wy> dons: Likely used in: isNotDigit = negate isDigit
20:17:58 <dons> wy, let negate f = not . f -- ?
20:18:04 <dons> :t isDigit
20:18:06 <lambdabot> Char -> Bool
20:18:08 <dons> :t not . isDigit
20:18:09 <lambdabot> Char -> Bool
20:18:22 <dons> ?let negate f = not . f
20:18:23 <lambdabot> Defined.
20:18:24 <wy> dons: I see!
20:18:33 <dons> > L.negate isDigit $ '8'
20:18:34 <lambdabot>  False
20:19:41 <wy> dons: what does $ here mean?
20:20:02 <eviltwin_b> virtual parenthese
20:20:03 <eviltwin_b> s
20:20:07 <dons> its low-precedence application, instead of parentehsis
20:20:16 <dons> > (L.negate isDigit) 8
20:20:17 <lambdabot>  add an instance declaration for (Num Char)
20:20:18 <sorear> > L.negate isDigit '8'
20:20:20 <lambdabot>  False
20:20:28 <sorear> dons: application is left associative
20:20:31 <dons> well, and its not needed, anyway, since I didn't use '.'
20:20:44 <dons> > not . isDigit $ '8'
20:20:45 <lambdabot>  False
20:20:55 <dons> > (not . isDigit) '8'
20:20:57 <lambdabot>  False
20:21:02 <wy> dons: So it's a kind of seperator?
20:21:04 <nornagon> > not . isDigit $ 'f'
20:21:05 <dons> > not (isDigit '8')
20:21:06 <lambdabot>  True
20:21:07 <lambdabot>  False
20:21:13 <nornagon> :D
20:21:14 <dons> wy, its a function with low precdenece
20:21:20 <dons> f $ x = f x
20:21:24 <Cale> f $ x = f x is the definition, together with infixl 9 $
20:21:34 <dons> > let f # x = f x in not . isDigit # '8'
20:21:35 <lambdabot>    precedence parsing error
20:21:35 <lambdabot>     cannot mix `(.)' [infixr 9] and `(#)' [...
20:21:47 <dons> that, but with lower precedence
20:21:53 <Cale> er, infixr
20:21:59 <Cale> it should be infixl, but it's not
20:22:22 <Cale> ugh, and I have the precedence levels backwards :)
20:22:23 <dons> infixr 0  $
20:22:27 <Cale> infixr 0
20:22:29 <Cale> yeah
20:22:30 <dons> ($)         :: (a -> b) -> a -> b
20:22:30 <dons> f $ x           =  f x
20:22:59 <dons> -- | Application operator.  This operator is redundant, since ordinary
20:22:59 <dons> -- application @(f x)@ means the same as @(f '$' x)@. However, '$' has
20:23:00 <dons> -- low, right-associative binding precedence, so it sometimes allows
20:23:01 <dons> -- parentheses to be omitted
20:23:03 <wy> dons: I mean it's use is for separating function and arguments when you don't want to use () ?
20:23:10 <dons> yep
20:23:10 <Cale> right
20:23:25 <Cale> also, you can use it for doing things like zipWith ($)
20:24:02 <Cale> > zipWith ($) [(+ 1), (* 6), (+ 10)] [1,2,3]
20:24:04 <lambdabot>  [2,12,13]
20:24:36 <wy> Cale: looks like apply
20:26:01 <wy> > ($) (+) 1 2
20:26:03 <lambdabot>  3
20:26:07 <lispy> dons: i'm too lazy to figure out the sed you used :)
20:26:13 <Cale> ($) = id
20:26:24 <Cale> > zipWith id [(+ 1), (* 6), (+ 10)] [1,2,3]
20:26:25 <lambdabot>  [2,12,13]
20:26:46 <dons> lispy, let me write it down ...
20:26:46 <Cale> but it has the nice documentation effect of being a name for function application
20:26:58 <lispy> dons: i'm now wondering about using haxml to run darcs and generate the gnuplot script
20:27:23 <lispy> dons: thanks
20:27:50 <wy> If apply (+) [1, 2] results in 3. What should be the definition of "apply"?
20:28:13 <lispy> apply = id
20:28:16 <lispy> :)
20:28:24 <lispy> actually that won't work here though
20:28:32 <Pastorn> foldr1?
20:28:34 <dons> lispy, edit this to your needs:
20:28:35 <dons> darcs changes  --xml-output | grep '<patch' | sed "s/^<patch.*author='//;s/'.*$//" | sort | uniq -c | sort -nr
20:28:40 <wy> lispy: But (+) can't be applied to a list
20:28:44 <eviltwin_b> with a flip in there somewhere
20:28:49 <dons> lispy, pipe that into the 'authors' file
20:29:02 <dons> then take the names and put them in the gnuplot script
20:29:09 <eviltwin_b> (foldr1 . flip) 0 -- ?
20:29:10 <lispy> right, okay
20:29:18 <dons> and leave the numbrs in the authors file, then run gnuplot with the .script
20:30:21 <lispy> dons: you know what, i think darcs has a script for this that considers multiple aliases for one dev
20:30:54 <dons> hopefully
20:31:09 * eviltwin_b still doesn't quite get ppointfree, clearly :>
20:31:12 <dons> would make a good extension to darcs-graph, i think
20:31:20 <dons> :t foldr1
20:31:21 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:31:22 <dons> :t flip
20:31:23 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
20:31:41 <dons> :t foldr1 (\a b -> a) [1..10]
20:31:42 <lambdabot> forall a. (Num a, Enum a) => a
20:31:48 <dons> > foldr1 (\a b -> a) [1..10]
20:31:50 <lambdabot>  1
20:31:55 <dons> > foldr1 const [1..10]
20:31:56 <lambdabot>  1
20:32:04 <dons> > foldr1 (flip const) [1..10]
20:32:05 <Cale> hehe
20:32:05 <lambdabot>  10
20:32:11 <Cale> foldl1 const [1..10]
20:32:15 <Cale> > foldl1 const [1..10]
20:32:16 <eviltwin_b> ah,right, foldr1 doesn' need the 0
20:32:16 <lambdabot>  1
20:32:19 <lispy> dons: ah, it's list_authors
20:32:30 <lispy> dons: but it doesn't seem to include their patch count...
20:32:47 * eviltwin_b was overthinking anyway:  flip . foldr
20:32:48 <dons> hack away :)
20:33:47 <jesusphreak> are any of you big fans of Common Lisp?
20:34:50 <lispy> list_authors stats, then remove the header and it's the same format you produced
20:35:00 <lispy> jesusphreak: common lisp, what's that? ;)
20:35:01 <Cale> I've used it, it's all right, but I'm not a huge fan of it.
20:35:11 <Cale> Scheme seems much nicer
20:35:37 <jesusphreak> one of the next languages I really want to check out is CL
20:36:06 <jesusphreak> Python is almost too easy, you pick it up so fast and it is easy to remember everything
20:36:17 <jesusphreak> so I get a bad case of wanting to try other stuff
20:36:21 <Cale> If I was going to write something in a lispish language, I'd probably go with scheme.
20:36:27 <Randroid> jesusphreak: I liked Python until I tried Ruby. I like that one much better.
20:36:42 <jesusphreak> Scheme frankly confuses me because there are so many different implementations to chose from
20:36:52 <Cale> meh, just pick one :)
20:37:07 <Cale> Dr Scheme is fun
20:37:23 <jesusphreak> and from the way most Lispers, talk, the thing that makes Lisp great is macros, and Scheme doesn't seem to have the same support for them that CL does
20:37:29 <aFlag> does anyone knows about a paper on haskell (or functional languages as a whole) gabarge collection?
20:37:29 <Cale> In fact, it's a bit of a shame that Haskell doesn't have such a nice environment as that
20:37:39 <dons> lispy, you know what would be fun: run the darcs commit plot script on all the community darcs repos...
20:37:55 <Excedrin> I'm a fan of the MLton Scheme compiler... ;)
20:38:03 <Cale> jesusphreak: CL is really annoying in lots of ways though.
20:38:06 <dons> aFlag: all your paper needs can be found at the 'research papers' section of haskell.org
20:38:07 <jesusphreak> Randroid, I actually learned Ruby before Python, but Python currently has a much better environment, in different respects
20:38:21 <Cale> Like, you can't just pass a function to another function and then call it like normal
20:38:25 <dons> aFlag: http://haskell.org/haskellwiki/Research_papers/Runtime_systems#Garbage_collection
20:38:25 <lispy> dons: yeah, there is a decent bit of research into how to visualize history data from VCS, it would be really cool if someone ported those to darcs
20:38:27 <lambdabot> Title: Research papers/Runtime systems - HaskellWiki, http://tinyurl.com/jyutg
20:38:28 <jesusphreak> that's strange
20:38:36 <aFlag> oh, thanks
20:38:46 <lispy> dons: at this point, the biggest hurdle to wide spread darcs adoption is probably tool support
20:38:54 <aFlag> that page is great
20:38:55 <Cale> You have to specially quote functions which are being passed as parameters, and call them with FUNCALL or APPLY
20:39:08 <jesusphreak> interesting
20:39:11 <lispy> dons: for example, i still can't convince anyone at work to try it because it just doesn't work that well with windows
20:39:18 <lispy> dons: or with visual studio
20:39:18 <dons> lispy, like this, http://www.cse.unsw.edu.au/~dons/images/commits/community/
20:39:19 <lambdabot> Title: Haskell Community Project Activity
20:39:21 <dons> but combine them all,
20:39:23 <Randroid> jesusphreak: I don't like Python because it mixes paradigms. I find that inelegant. (For instance, "len" is a functiion in Python instead of a method. Yes, I'm aware of __len__, but I'm talking about syntax.)
20:39:28 <dons> and print commit stuff, instead of patch count
20:39:29 <Cale> Every name can be associated with both a value and a function simultaneously
20:39:30 <jesusphreak> regardless if I ever use it much, it is somethign I need to pick up and at least be familiar with
20:39:47 <Cale> and which one you get depends on what position the thing is in
20:39:48 <jesusphreak> Randroid, I understand what you mean
20:39:58 <jesusphreak> Ruby definitely is more elegant
20:40:00 <lispy> dons: that's already a lot of repos
20:40:09 <jesusphreak> like properties in Python are nasty
20:40:13 <Randroid> jesusphreak: That's what I love about Haskell. It's so pure.
20:40:18 <jesusphreak> and its because Python isn't as OO as Ruby
20:40:27 <lispy> oh, BTW i need to read up on GADTs are there any must read papers on the subject that you can think of?
20:40:32 <Cale> Have you people tried smalltalk?
20:40:46 <Excedrin> I dislike how '=' in python is a combination of object creation, name binding and/or mutation, depending on context
20:40:46 <lispy> Cale: kinda...i was gonna write a smalltalk interpreter
20:40:47 <Randroid> jesusphreak: Yes. And to me that just doesn't cut it, so I'm a confirmed Ruby guy.
20:40:55 <jesusphreak> but, given Python's speed, libraries, maintainability, I prefer using Python
20:41:04 <jesusphreak> maybe one day Ruby will catch me back
20:41:09 <Randroid> jesusphreak: Meh, to each his own.
20:41:17 <Cale> jesusphreak, Randroid ?
20:41:29 <jesusphreak> Cale, no never used Smalltalk
20:41:33 <Cale> It's fun, pick up squeak and play around with it :)
20:41:35 <jesusphreak> that's *another* language I want to pick up
20:41:36 <Randroid> Yes, I've used Smalltalk.
20:42:09 <twobitsprite> can someone remind me how to designate more than one type-class in a function declaration again?
20:42:20 <Cale> parens, commas
20:42:20 <Randroid> I learn programming languages very, very rapidly, so I've played with more than I can count. I love languages not just for what they can do but for what they are.
20:42:26 <twobitsprite> f :: (Num a, Num b) => ... ?
20:42:31 <Cale> yeah
20:42:34 <twobitsprite> k, thanks
20:42:50 <Randroid> Anyone try REBOL? It's a neat little language.
20:42:57 <jesusphreak> I've read a bit about it
20:43:10 <jesusphreak> never found the incentive to look into it in any depth, though
20:43:21 <lispy> Randroid: my rule of thumb is that you don't know a languae until you've found a bug in the compiler/interpreter  you're using
20:43:31 <jesusphreak> man, I just feel sorry for those coders that only use one language their whole life
20:43:42 <jesusphreak> programming is so interesting, why not learn as much as you can?
20:43:43 <Randroid> lispy: Good for you. My standards in that department are a bit more abstract.
20:45:08 <Randroid> jesusphreak: I totally agree with you. Unfortunately, I code in C# to pay the bills, but even in that language I can code circles around the guys I work with. I can't tell you how many times I've had to explain simple C# language constructs like generics, events, and anonymous delegates at work, and they still don't get it.
20:45:08 <dons> as seen on -cafe "Wow!  I found your help terrific!  Thank you!   Can I give you some money?"
20:45:24 <wy> Is "elem" the same meaning as "member" in Miranda?
20:45:36 <jesusphreak> hah, well, it was only about a year ago that I didn't understand methods
20:45:38 <jesusphreak> no joke
20:45:44 <Randroid> jesusphreak: whoa
20:46:20 <jesusphreak> Ruby bugged me out for a while, and blocks left me slamming my head against the table
20:46:40 <jesusphreak> but finally I got 'it', and since then its been nice learning other languages because you instantly recognize concepts between them
20:47:24 <Excedrin> I hope Monads are like that...
20:47:25 <Randroid> jesusphreak: Yeah. It's nice that M$ finally decided to add blocks to C# in the form of closures, but C# still sucks as a language. Haskell's my latest pet learning project. It's been mind-bending. I've loved every second of it.
20:48:22 <jesusphreak> .NET and the CLR doesn't seem like such a bad environment...I mean there are constantly new languages being implemented on top of it
20:48:33 <jesusphreak> C#, IronPython, F#, Boo, etc
20:49:18 <Randroid> jesusphreak: If you consider the whole .NET shebang, including the vast class libraries, etc., it's pretty good. I've written some code with it that I'm very proud of.
20:49:37 <Randroid> jesusphreak: But it just doesn't give me the kind of syntactic satisfaction that Haskell does. :)
20:49:43 <jesusphreak> heh, no kidding
20:49:49 <Cale> jesusphreak: hehe, that's interesting, I already knew Haskell when I learned Ruby, so blocks were trivial to learn :)
20:50:18 <jesusphreak> I don't know why, they just made absolutely no sense to me for awhile
20:50:28 <Randroid> Cale: Cool. I learned Ruby first, but it was knowing Dylan that really helped me with Haskell.
20:50:39 <Excedrin> http://programming.reddit.com/info/u5jo/comments
20:50:41 <lambdabot> Title: Ask Reddit: Why do people think some languages are not "realistic"? (reddit.com)
20:51:27 <jesusphreak> ooh, I was looking at Dylan the other day
20:51:54 <Randroid> jesusphreak: Great language, but unfortunately the libraries suck. They are frozen in the '90s.
20:51:58 <jesusphreak> but it seems like interesting in it is completely dead, and as much as I like learning languages, I like to learn ones that seem to have some type of future
20:52:31 <Randroid> jesusphreak: I cried in the corner for a while in a fetal position, but I eventually realized I had to abandon Dylan.
20:52:38 <Randroid> :p
20:52:49 <Randroid> I still miss it.
20:53:09 <jesusphreak> lol...well at least you found Haskell
20:53:09 <Cale> jesusphreak: well, { |x| <stmts> } is similar to \x -> do {<stmts>}
20:53:31 <jesusphreak> Cale, I'm not that far in the tutorial, don't do that to me :)
20:53:38 <jesusphreak> next paragraph
20:53:45 <Randroid> Ah, so you're that new to Haskell, jesusphreak?
20:53:52 <jesusphreak> very new
20:53:59 <jesusphreak> I hadn't looked at it indepth until starting last night
20:54:02 <Randroid> I've only been at it a couple of months.
20:54:14 <jesusphreak> I looked at OCaml for about a week
20:54:22 <jesusphreak> but it seems like a mutt
20:55:22 <jesusphreak> too much ugly syntax and a mix of things that seemed to only complicate the language
20:55:52 <Randroid> My interest in languages extends to human ones. In fact, I'm a conlanger, which is someone whose hobby is constructing artificial languages. In my case they are purely for personal amusement. I've been writing a Haskell program that generates random words according to the phonological rules of my latest pet personal language. It's been challenging, because the rules are very complex, but in the end the Haskell version ended u
20:56:11 <Randroid> jesusphreak: I don't care for OCaml.
20:56:13 <bd_> ended u?
20:56:24 <Excedrin> Randroid: Lojban?
20:56:43 <Randroid> Excedrin: I'm familiar with Lojban and its predecessor, Loglan.
20:56:52 <Randroid> Or competitor, however you want to look at it.
20:57:01 <jesusphreak> I've always kind of wondered if learning programming languages would make you better at learning natural human languages
20:57:13 <Randroid> I used to talk to Bob LeChavalier of the Logical Language Group on the phone back in the early '90s.
20:57:24 <jesusphreak> I know Larry Wall comes from a language background
20:57:35 <Excedrin> I've looked at Lojban a little, it's neat, but I haven't taken the time to actually learn it
20:57:53 <Excedrin> would you recommend Loglan instead of Lojban?
20:58:12 <Randroid> jesusphreak: For me it was the opposite. I started studying natural language grammar extensively. I taught myself Classical Latin when I was 13. From there, computer languages are cake. Human languages have *MUCH* more complex grammars.
20:58:43 <Randroid> Excedrin: I've only glanced at Loglan, so I couldn't say for sure, but that glance made me a confirmed Lojbanist. Didn't care for Loglan.
20:58:59 <Cale> Randroid: "but in the end the Haskell version ended" -- I think your message got cut off
20:59:05 <Randroid> Cale: ah
20:59:13 <Randroid> Cale "ended up being 1/2 the size of the Ruby version."
20:59:23 <Cale> cool
20:59:38 <Randroid> Haskell has wonderful brevity, thanks to recursion, pattern matching, composition, etc.
21:00:13 <jesusphreak> wow, half the size is very impressive
21:00:18 <monochrom> Learning logics makes you better at noticing all the flaws in natural human languages.
21:00:19 <jesusphreak> considering Ruby is already pretty terse
21:00:24 <eviltwin_b> remember, IRC protocol has 512-char limit, sadly enforced by silent truncation
21:00:29 <fnord123> hi all. is there a standard way of dealing with xml in haskell? I'm implementing a soap client for a service im using
21:00:35 <Randroid> eviltwin_b: Yeah, I always forget about that.
21:00:36 <wy> I found that although I can write code that works, I can't improve my style. Any suggestions on how to improve styles?
21:00:44 <jesusphreak> is that fnord of Reddit fame?
21:00:51 <monochrom> For example the lack of some nestable thing corresponding to parentheses is a fatal omission.
21:00:55 <newsham> > (+ 3) `fmap` listToMaybe [1,2,3]
21:00:57 <lambdabot>  Just 4
21:00:57 <Cale> fnord123: there isn't a standard way, there are some libraries, but I can't tell you about how good they are because I've never used them
21:01:01 <newsham> > (+ 3) `fmap` listToMaybe []
21:01:02 <lambdabot>  Nothing
21:01:14 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/
21:01:16 <lambdabot> Title: Haskell XML Toolbox 7.0
21:01:25 <lispy> dons: http://files.codersbase.com/tmp/commiters.png
21:01:34 <lispy> dons: needs a tweak :)
21:01:34 <Cale> I think that's the most actively developed one, but I could e wrong
21:01:40 <fnord123> Thanks, Cale.
21:02:07 <fnord123> Is that the Cale of the "Open Letter to the Nullity Professor" fame?
21:02:14 <Cale> heh, yes
21:02:18 <dons> lispy nice.
21:02:31 <dons> lispy, yeah, you need a smaller/nicer font
21:02:39 <monochrom> Cale is a wiki.
21:02:41 <Randroid> monochrom: Nesting in human languages occurs through a process called subordination, but it can't be arbitrarily deep because of innate limitations of the human language mechanism. We appear to have an ability to track only up to a certain very low level of nesting.
21:02:46 <lispy> dons: vera is not on my system
21:02:50 <dons> ah ok
21:03:21 <lispy> dons: if i increas ticscale will that move them apart a bit?
21:03:30 <fnord123> jesusphreak: yes. many redditors are using their freenode nicks.
21:03:58 <dons> lispy: not sure. maybe
21:04:36 <monochrom> Right, in practice it can't be arbitrarily deep, regardless of language and notation.
21:05:15 <dons> hey fnord123
21:05:24 <fnord123> hiya
21:06:18 <Randroid> monochrom: Exactly.
21:06:24 <lispy> ttf-bitstream-vera is already the newest version.
21:06:25 <lispy> hm...
21:06:28 <monochrom> Still, something like "(forall x. Px => Qx) => (forall x. Rx => Sx)" is seamlessly expressible and even comprehensible in that notation, and yet in most natural languages it is a mess.  Seems like natural languages can't even support a depth of 3.
21:07:13 <Randroid> monochrom: And that makes perfect sense, because language evolved to suit the needs of hunter gatherers.
21:07:43 <Cale> If all automobiles are red then all cars are crimson.
21:07:59 * dufflebunk hands a caveman an imaginary number
21:08:11 --- mode: ChanServ set +o dons
21:08:14 <Randroid> hehe
21:08:46 <dons> ["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]
21:08:55 --- topic: set to '["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
21:08:58 --- mode: ChanServ set -o dons
21:09:19 <dons> :)
21:09:56 <fnord123> i thought this year's selected winner was the graphical programming language (as chosen by the java using winners)
21:10:12 * Randroid shudders at the mention of Java.
21:10:23 <dons> fnord123: hmm?
21:10:51 <monochrom> The example I saw today was: (forall x_n, L, M. x_n converges to L and Tx_n converges to M => Tx_n converges to TL) => (forall x_n, L. x_n converges to L => Tx_n converges to L)
21:10:58 <dons> fnord123: you mean: http://sequence.complete.org/hwn/20060927
21:11:00 <lambdabot> Title: Haskell Weekly News: September 27, 2006 | The Haskell Sequence
21:11:20 <dons> "Congratulations to the winning team from Google, 'Team Smartass', (Christopher Hendrie, Derek Kisman, Ambrose Feinstein and Daniel Wright), who used Haskell along with C++, Bash and Python."
21:11:49 <dons> (and declared 2D their language of choice, one of the contest puzzle mini languageS)
21:12:11 <Randroid> Unfortunately folks I gotta head to Wal-Mart. It's the only thing open at this hour in Florida that has a grocery store in it. I'll be back in an hour or so. It's been a pleasure.
21:12:28 <monochrom> Wal-Mart is fun.
21:12:33 <fnord123> in Python, I can use '''blah blah blah %s blah ''' % (someString) to slip a string into my basic text. this is useful for wizzbang cheap soap interactions. any idea how i might do something similar in haskell?
21:12:40 <Randroid> Wal-Mart is fun late at night, sometimes. :)
21:12:44 <Cale> @hoogle printf
21:12:45 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
21:12:45 <lambdabot> Text.Printf :: module
21:12:45 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
21:12:57 <dons> > printf "blah blah blah %s blah" "someString" :: String
21:12:58 <lambdabot>  "blah blah blah someString blah"
21:12:59 <Excedrin> don't let the palmetto bugs bite
21:13:00 <dons> > printf "blah blah blah %s blah" "someString" :: IO String
21:13:02 <lambdabot>  <IO [Char]>
21:13:04 <Cale> but I wouldn't do that myself
21:13:06 <Randroid> heh
21:13:37 <Cale> concat ["blah blah blah ", someString, " blah"]
21:13:37 <dons> fnord123: printf, yeah?
21:13:59 <fnord123> hm. i want to scan as well
21:14:01 <Cale> formatting strings are evil
21:14:08 <Cale> look up parsec
21:14:11 <dons> > read "2.7" :: Float
21:14:12 <lambdabot>  2.7
21:14:13 <monochrom> String injection!
21:14:15 <Cale> @where parsec
21:14:16 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
21:14:42 <dons> yeah, if you're actually doing lexing, use a lexer combinator lib
21:15:06 <fnord123> no im not doing actual lexing. the strings are simple enough
21:15:31 <Cale> If you're doing anything more complicated than 'words', then I recommend parsec
21:15:58 <Cale> > words "Hello, this is a test of words"
21:15:59 <lambdabot>  ["Hello,","this","is","a","test","of","words"]
21:16:10 <Cale> cf. lines
21:16:24 <fnord123> scanf("<soap:envelope><soap-env:body><m:request><header><name>%s</name></header></m:request></.....>");
21:16:36 <dons> that looks like lexing to me :)
21:16:55 <dons> you want just the bit in the %s ?
21:16:57 <monochrom> That looks like you need HXT
21:16:59 <fnord123> yup
21:17:10 <Cale> Yeah, I'd use a full XML library at that point.
21:17:11 <monochrom> Either that, or regex.
21:17:34 <Cale> Otherwise, things will break if the XML format changes ever so slightly
21:17:46 <fnord123> if it changes, i will need to fix my schema as well
21:18:03 <fnord123> if it changes, i need to fix things anyway
21:18:05 <Cale> What about if someone sticks a space in somewhere?
21:18:25 <monochrom> Things like scanf and injection are great ideas.  For toy examples written by newbies, that is.
21:18:44 <Excedrin> injection?
21:19:26 <fnord123> alright, then can you recommend an xml lib for haskell? Cale ack'd me before but said he hasn't used any
21:19:32 <monochrom> Injection is for example in shell scripting "Your name $n is not found"
21:19:43 <monochrom> HXT
21:20:31 <fnord123> that's german... will it even work?
21:20:44 <monochrom> The omission of scanf and injection in Haskell libraries is an indication that the community is serious about production code.
21:20:48 <dons> ?paste
21:20:49 <lambdabot> http://paste.lisp.org/new/haskell
21:21:03 <monochrom> I know no German and I have used it to do wonderful things.
21:21:05 <bd_> Who needs scanf when you have read and parsec?
21:21:43 <monochrom> Case in point: professional C code just doesn't use scanf.
21:21:45 <lisppaste2> dons pasted "scanf with regex" at http://paste.lisp.org/display/31753
21:21:47 <fnord123> 10^16 m?
21:21:55 <Excedrin> Text.Printf isn't injection?
21:22:00 <dons> fnord123: ^ if you're looking for cheap and nasty :)
21:22:18 <monochrom> printf is some kind of injection too.
21:23:02 <dons> I'd seriously consider parsec though (as people have said) since you want robustness in the longer term
21:23:09 <dons> well, maybe you don't :)
21:23:44 <fnord123> it's 5am
21:24:00 <monochrom> Yeah, some SOAP developers are just interested in educational toy examples, and so the like of Python and PHP work great.  Sadly Haskell is no toy language.
21:24:53 <fnord123> python and php programers are interested in showing off their work and then getting the money from their contractees. :P
21:25:06 <monochrom> Haha, if it's 5am, then maybe Haxml is more suitable.
21:25:48 * Cale installs HXT to try it out
21:26:00 * fnord123 does the same
21:26:01 <dons> Cale: good. then we can stick an exapmle on the wiki.
21:26:09 <monochrom> This is simply because HXT uses arrows and Haxml uses elementary functions and data structures.
21:26:13 <dons> using the regex soln, then the proper soln, and maybe a parsec grabbe rtoo
21:26:47 <monochrom> http://www.vex.net/~trebla/haskell/hxt-arrow/
21:27:07 <Cale> wow, the HXT documentation includes a small Haskell tutorial
21:27:21 <fnord123> will cabal auto-dl stuff for me? dependency hunting is so 90s
21:27:24 <Cale> http://www.fh-wedel.de/~si/HXmlToolbox/thesis/x298.html
21:27:42 <dons> fnord123: not yet. you gotta grab it manually. cabal-get is almost finished though
21:28:05 <dons> maybe its already in your package system though?
21:29:31 <fnord123> nah, i need to dl http package
21:29:41 <dons> ?where http
21:29:42 <lambdabot> http://www.haskell.org/http/
21:29:51 <fnord123> yeah im compiling it now. :)
21:30:00 <dons> great
21:30:18 <dons> Cale, I'm thinking we need a standard 'Built with Cabal' logo
21:30:29 <dons> a bit like the 'Built with Parsec techology' one
21:30:50 <Cale> I don't think I've seen the parsec one
21:31:16 <dons> Cale: something like: http://haskell.org/haskellwiki/Image:Cabal-With-Text-small.png
21:31:17 <lambdabot> Title: Image:Cabal-With-Text-small.png - HaskellWiki
21:31:20 <dons> but with the slogan
21:31:33 <dons> http://www.cs.uu.nl/~daan/parsec.html
21:31:34 <lambdabot> Title: Parsec
21:31:37 <dons> parsec logo ^^
21:31:40 <Cale> cool, sure, I can do that
21:31:52 <dons> Cale, I used it on this page: http://haskell.org/haskellwiki/Libraries_and_tools
21:31:54 <lambdabot> Title: Libraries and tools - HaskellWiki
21:31:54 <Cale> ah, I missed the button :)
21:32:02 <lispy> dons: http://files.codersbase.com/tmp/commiters.png
21:32:02 <dons> But I'd like to badge everything that's cabalised
21:32:18 <dons> lispy, nice!
21:32:25 <lispy> set terminal png font "/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf" 9
21:32:29 <fnord123> Cabals are groups of people in a tightly knit organisation. the logo doesn't really inspire that... how about.... a pyramid with an eye?
21:32:31 <lispy> set size 2.6,1.33
21:32:37 <lispy> dons: those were the magic changes
21:32:51 <dons> fnord123: Cabal is a packaging tool though :) so boxes are good
21:33:12 <fnord123> pyramids package pharaohs
21:33:13 <dons> lispy, so darcs would have trouble finding committers eh? ;) written in such an obscure language...
21:33:21 <dons> fnord123: heh
21:33:38 <lispy> $ wc -l darcs-authors
21:33:38 <lispy> 115 darcs-authors
21:33:45 * monochrom goes create these logos: while-loop technology, assignment technology, addition technology, zero technology.
21:33:47 <dons> cool
21:33:48 <lispy> dons: depends on what you mean by "few" ;)
21:34:07 <fnord123> turing technology
21:34:33 <dons> if lisp is buitl with alien technology, what is haskell built with?
21:34:36 <Cale> so just "built with Cabal"?
21:34:44 <Excedrin> Powered by GWBASIC
21:34:45 <dons> "built by beings of pure energy" ?
21:35:01 <dons> (actually, I quite like that)
21:35:03 <monochrom> Cabal should not have a logo.  Or perhaps should have a blank logo.  What do you mean Cabal?  There is no Cabal.
21:35:07 <dons> Cale: yeah, unless you can think of one
21:35:15 <dons> better
21:35:15 <fnord123> Haskell is built with Noodly divination
21:35:19 <dons> heh
21:35:44 * dons creates "Beings of pure energy" logo
21:35:45 <monochrom> Why was it called Cabal?
21:35:45 <fnord123> Cabal does not exist
21:36:01 <dons> its an acronym
21:36:03 <dons> ?where cabal
21:36:03 <lambdabot> http://www.haskell.org/cabal
21:36:10 <monochrom> Thanks
21:38:06 <Cale> I hope you'll forgive me for not doing the "built with" in the same font -- I did the outlines for the Cabal logo by hand.
21:38:36 <monochrom> dons: on the haskell wiki, should a writer use linebreaks or not?
21:38:46 * fnord123 /invoke bed
21:40:33 <dons> monochrom: doesn't matter.
21:44:10 <monochrom> Thanks. I'll try not to be heretic on this.
21:44:17 <dons> :)
21:44:35 <monochrom> And I want you to have the horror of knowing that I write wikis in Eclipse!
21:45:16 <Excedrin> do you use Eclipse for Haskell coding?
21:45:53 <dons> yikes
21:47:50 <monochrom> Sometimes.
21:49:24 <monochrom> The eclipsefp builder is not quite suitable.  That's my only hesitation.
21:50:12 <Cale> http://cale.yi.org/autoshare/built-with-Cabal-dark.png
21:50:18 <Cale> http://cale.yi.org/autoshare/built-with-Cabal-light.png
21:50:20 <lispy> monochrom: you don't strike me as an eclipse user
21:50:35 <Cale> hmm, let me work on that light one a little more
21:51:22 <monochrom> I am great at hiding my true dark nature.
21:51:52 <monochrom> I hang around #haskell to befriend haskell kids.
21:52:14 <monochrom> Then I lure them with arrows and then kidnap them.
21:52:20 <Cale> okay, that's a bit better
21:52:38 <monochrom> Then I make them write in PL/I !
21:52:41 <Cale> dons: what do you think?
21:52:54 * lispy pictures monochrom listening to Dennis Leary's "Asshole" song while saying that
21:54:03 <dons> Cale, nice!
21:56:31 <Cale> You know what would be really nice? If there was a way for all the haddock/cabal packages on one's system to merge their documentation into one tree.
21:57:19 <sorear> that would just be too good
21:57:57 <sorear> while we're at it, will someone write a proxy server that makes hackage-db apt-gettable?
21:59:46 <sorear> hmm - that's actually starting to sound plausible...
22:07:24 <sorear> ?users
22:09:57 <vincenz> Smack that, all on the floor.  Smack that, give me some more. Smack that, till you get sore. Smack that, oooh ooohhh
22:10:17 <sorear> ?users
22:10:37 <vincenz> @users
22:11:22 <sorear> yes - lambdabot's split
22:11:36 <lispy> yeah the whole network was gonna go down i thought
22:11:44 <lispy> judging by the notices
22:12:06 <sorear> I got two notices that they'd be restarting freenode.
22:13:16 <jesusphreak> is Cabal anything like Ruby's gem system?
22:13:19 <sorear> Now if only they'd used some kind of state escrow system (e.g. Wikipedia's database) they could have ZERO DOWNTIME! /me wonders how many people *haven't* toyed with creating the successor to IRC
22:15:04 <lispy> i bet we could write that in haskell pretty easily
22:15:11 <lispy> maybe the next killer haskell app is the successor to irc
22:15:32 <bd_> lispy: you should talk to dylan about that... :)
22:15:42 <lispy> dylan: maybe the next killer haskell app is the successor to irc
22:16:11 <bd_> He's already implemented one (not sure if the current server's Haskell, it's gone through a few iterations...) - it's just lacking a client >.>
22:16:44 <bd_> s/one/a chat protocol/
22:17:48 <Cale> fnordus: == fnord123?
22:17:57 <sorear> ?users
22:22:28 <lambdabot> Maximum users seen in #haskell: 278, currently: 220 (79.1%), active: 6 (2.7%)
22:22:30 <lambdabot> Maximum users seen in #haskell: 278, currently: 219 (78.8%), active: 7 (3.2%)
22:24:42 <sorear> ?type maybe
22:25:04 <sorear> why is LB so slow?
22:25:06 <Cale> Wow, HXT is really elegant
22:25:14 <lispy> dons: how do you read your charts?
22:25:18 <Cale> sorear: maybe the box it's on is compiling ghc
22:25:21 <lambdabot> Maximum users seen in #haskell: 278, currently: 222 (79.9%), active: 8 (3.6%)
22:25:39 <monochrom> maybe :: b -> (a -> b) -> Maybe a -> b   sorear
22:25:40 <lispy> dons: like the lambdabot activity one says things like 0504 on the x-axis
22:25:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:25:55 <lispy> dons: but 0504 doesn't correspond to anything in my head
22:25:55 <dons> lispy, I read the patches subdir
22:26:23 * monochrom gives a lot of arrow candies to Cale.
22:26:36 <monochrom> Come to my house!  There are more!
22:26:37 <dons> 2005 04 ...
22:27:02 <Cale> yeah, usually you'd think that arrow combinator libraries would be less elegant, but the way that they've designed things works really well.
22:27:06 <sorear> On *my* box, compiling ghc in the background has no noticable effect on interactive performance - and dons has four times as many CPU's as I.
22:27:09 <hyrax42> ?type map
22:27:11 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:27:11 <lispy> dons: huh, do you remember what was happening then? it's an interesting spike :)
22:27:13 <dons> ~?bot
22:27:15 <hyrax42> ?type liftM2
22:27:17 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:27:21 <sorear> ?help bot
22:27:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:27:28 <dons> lispy, when, in lambdabot?
22:27:35 <hyrax42> ?type zipWith
22:27:35 <lispy> dons: yeah in lambdabot 0504
22:27:36 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
22:27:42 <dons> that's when I took over maintainership
22:27:49 <lispy> hah, okay
22:28:02 <lispy> there is also a fairly regular spiking pattern
22:28:12 <dons> yeah. goes in waves
22:28:36 <lispy> it's good stuff
22:28:54 <dons> :)
22:29:08 <sorear> ?hoogle IORef a -> (a -> (a,b)) -> IO b
22:29:09 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
22:29:35 <sorear> ?hoogle STRef s a -> (a -> (a,b)) -> ST s b
22:29:36 <lambdabot> No matches, try a more general search
22:30:35 <hyrax42> update a in place, return b?
22:30:49 <dons> jesusphreak: yeah, Cabal is to be our gems, yep.
22:31:13 <mbishop> cabal is gonna be the new cpan (only not lame? :))?
22:31:20 <sorear> hyrax42: yes.
22:31:23 <dons> :)
22:31:38 <hyrax42> sorear: can't help, just wanted to test my built-in djinn
22:32:31 <sorear> it's not hard to write, but IMO it belongs in the standard non-concurrent library.
22:32:35 <hyrax42> but since it's a one liner, I guess you just want to avoid reinventing (small pieces of) tthe wheel
22:33:48 <sorear> ?hoogle Monad m => m a -> (a -> b) -> m b
22:33:49 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
22:33:49 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
22:33:49 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
22:34:08 <sorear> ?hoogle Functor m => m a -> (a -> b) -> m b
22:34:09 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
22:34:09 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
22:34:09 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
22:34:33 <sorear> flip liftM
22:39:05 <dons> Cale: here's some logos, feel free to upload yours: http://haskell.org/haskellwiki/Haskell_logos
22:39:07 <lambdabot> Title: Haskell logos - HaskellWiki
22:39:53 <Cale> ow, someone set the jpeg compression level a little too high
22:40:09 <dons> on what?
22:40:37 <Cale> the pure energy logos
22:40:46 <Cale> oh, they're pngs
22:40:58 <Cale> but they have jpeg compression artifacts
22:41:57 <dons> not sure they're compression artifacts :)
22:42:14 <Cale> hmm
22:42:32 <sorear> I think they *look* like DCT artifacts too
22:42:51 <dons> they're just sketches of the basic idea, really.
22:43:33 <dons> not quite sure how to turn them into a proper log. they'd need to be less noisy
22:43:35 <dons> s/logo/
22:43:47 <Cale> sorear: yes they do
22:44:02 <Cale> in particular, look at the lower right corner of the ball on the red one
22:44:20 <Cale> and the left hand side there
22:44:37 <dons> looks like artifacts of messing with the levels
22:44:48 <sorear> can't you just re-render with +OP ? (substitute for your program)
22:44:53 <sorear> levels?
22:46:24 <dons> gimp. color levels.
22:47:27 <sorear> no experience there.  sorry.
22:48:28 <Cale> sorear: essentially, you're just applying some (usually continuous, increasing) function to the pixel values in each channel
22:49:12 <sorear> yea, but why use an 8x8 DCT for that?  must be something else. (famous last words)
22:49:38 <Cale> oh, not at all
22:49:54 <jgrimes> the hackathon logos are neat
22:49:59 <Cale> but it might have brought out some artifacts that were in some source image
22:50:09 <dons> yep
22:50:15 <Cale> I'm going to upload the rest of the Cabal logos
22:50:19 <dons> since you get a bit more contrast on the underlying structures
22:50:25 <Cale> I also have svgs if this thing will accept them
22:50:32 <sorear> source images?
22:50:37 <dylan> bah, why can't terminus be smaller without being unreadable?
22:50:43 <sorear> MediaWiki takes SVGs.
22:50:57 <sorear> (They are a recommended format on 'pedia)
22:51:06 <Cale> sorear: as in someone used a jpeg to start with, put the text over top and made some transformations, and then saved it as a png
22:51:18 <sorear> scary
22:51:27 <dons> :)
22:51:40 <sorear> they should use MNGs for that :)
22:52:30 * dons has no idea what sorear is talking about
22:53:07 <Cale> whoops
23:05:39 <shankys> ?paste
23:05:39 <lambdabot> http://paste.lisp.org/new/haskell
23:08:38 <shankys> Could someone tell help me with some monadic typing difficulties I'm having? I'm new to monads, and am getting some error messages in my code that I'm not quite understanding.
23:09:21 <dons> sure. you pasted it?
23:09:27 <shankys> um...
23:09:29 <shankys> let me do that right now
23:09:46 <dons> ?paste <-- here
23:09:46 <lambdabot> http://paste.lisp.org/new/haskell
23:10:27 <lisppaste2> shankys pasted "CGI Code" at http://paste.lisp.org/display/31760
23:11:27 <shankys> oops... forgot to post the other part of the code
23:12:17 <lisppaste2> shankys pasted "Other Part" at http://paste.lisp.org/display/31761
23:12:25 <shankys> ok
23:13:10 <shankys> so I'm trying to connect to a postgresql database in handle_register, but I think there's monad issues
23:14:09 <dons> a case statement would be better than those if-then-else chains
23:14:30 <dons> so  what error do you get?
23:14:52 <shankys> yeah, that's definitely true about the if's
23:15:19 <aFlag> what in haskell is allocated in heap?
23:15:22 <lisppaste2> shankys pasted "Error" at http://paste.lisp.org/display/31762
23:16:10 <shankys> it's the dbh <- dbconnect line that's the problem
23:16:45 <dons> aFlag: notionally all boxed values
23:17:20 <dons> read the 'spineless Tagless G machine' paper
23:17:27 <dons> for the underlying execution model in ghc
23:17:39 <aFlag> like the ones in where and let?
23:18:23 <lispy> aFlag: the execution model used by most haskell implemenations is very different from that commonly found in other languages
23:18:30 <dons> shankys: looks like handle_register :: CGI CGIResult has the wrong type?
23:18:41 <dons> or you're forgetting to lift dbconnect into the CGI monad?
23:18:46 <shankys> yeah, I figured that much
23:18:56 <shankys> ok, how might I go about doing that?
23:19:14 <dons> so it should be in CGIT IO I think.
23:19:25 <dons> (is that your CGI transformer?)
23:19:44 <shankys> yeah see that's the problem, I don't really know much about CGI transformers
23:19:55 <shankys> I figured I'd have to use something like that
23:19:56 <lispy> aFlag: ghc for example, compiles to a G machine.  The G stands for graph.  You're program is represented as a function call graph and that graph is 'reduced' to evaluate your program.  The way the reduction is performed gives haskell its laziness
23:20:05 <shankys> I was hoping someone could point me in the right direction
23:20:21 <dons> shankys: yep, so the type should be CGIT IO or something, and the IO code needs a liftIO in front of it
23:20:29 <dons> dbh <- liftIO dbconnect
23:20:32 <dons> for example
23:20:38 <shankys> ok, let me try that
23:20:58 <dons> if CGIT is a valid monad transformer ? I'm just guessing from the error message
23:21:11 <shankys> wow, thanks a lot
23:21:13 <shankys> that worked
23:21:21 <dons> cool
23:21:38 <aFlag> lispy: hum, it's indeed much more complex than the basis of a C compiler :P
23:21:42 <shankys> can you give me a good resource to read up on liftIO and other related stuff?
23:22:04 <dons> aFlag: its mapping a graph reduction evaluation model onto imperative hardware
23:23:54 <sorear> from what I've read, it came as a suprise that graph reduction *could* be compiled.
23:25:33 <monochrom> Interesting.  Some day I shall figure out how that works, and in the tutorial of my prove-programs-correct class present the correctness proof!
23:27:53 <lispy> it's certainly interesitng stuff.  I recommend the paper dons mentioned.
23:28:07 <lispy> i've read a good portion of it and it was fun
23:28:13 <lispy> (but some of it was way over my head)
23:38:20 <sorear> idea: meta-lifter.
23:38:35 <sorear> class MetaLift a where
23:39:17 <sorear>  metalift :: (forall x. c x -> d x) -> a c x -> a d x
23:39:31 <sorear> I think that's the correct signature...
23:39:44 <sorear> instance MetaLift MaybeT where
23:39:46 <lispy> for arrows?
23:39:50 <Shimei> So, I have a question about type classes. A lot of the ideas seem to be really close to OO and Lisp's generic functions... what's the significant difference between type classes and those?
23:40:22 <sorear> metalift xf k = xf k
23:40:39 <sorear> instance MetaLift ((->) a) where
23:40:48 <lispy> well, a type class is like an interface.  In haskell, a type class additionally allows extra control via the type checker.
23:40:51 <sorear> ...
23:41:24 <sorear> MetaLift allows you to insert monads into the middle of the stack.  metalift lift, metalift (metalift lift), etc
23:43:20 <Excedrin> Shimei: pure virtual classes or interfaces are sort of like type classes
23:44:21 <Shimei> Ah, I see. So it's conceptually similar to Java/C++ methods that take abstract/virtual class arguments? Hmm.
23:45:36 <Shimei> Ah, I guess the "Gentle Introduction" goes into detail about that lower on the page.
23:45:56 <Shimei> Thanks anyway. :)
23:48:11 <dons> shankys: type classes are a way to implement bounded parametric polymorphism, where a function may be polymorphci/generic over a particular set of types
23:48:29 <dons> as opposed to parametric polymorpshm, where the function is generic over all types
23:48:46 <dons> :t id -- is parametrically polymophic
23:48:47 <lambdabot> forall a. a -> a
23:48:50 <dons> Shimei: ^^ sorry
23:48:58 <dons> :t (+) -- bounded
23:49:00 <lambdabot> forall a. (Num a) => a -> a -> a
23:49:03 <dons> to only those types in the Num clsas
23:50:00 <dons> the relation between typeclasses and OO is a little confused, since OO tends to conflate the separate concepts of class and instance (at the very least).
23:50:07 <dons>  but classes can be seen as an abstract interface
23:50:11 <dons> which particular types implement
23:51:06 <dons> ?instances Num
23:51:07 <lambdabot> Double, Float, Int, Integer
23:51:23 <dons> means that (+) (*) and so on work on all those types
23:51:29 <shankys> I think I understand the purpose of type classes
23:51:48 <shankys> I think I've begun to wrap my head around what monads do
23:51:54 <shankys> but monad transformers confuse me
23:51:56 <dons> shankys: sorry, I was answering Shimei, but my tabs got confused :)
23:52:06 <lispy> dons: when you say class and instance you're talking at the type level righT?
23:52:15 <Shimei> Monads made the most sense to me when compared with Unix pipes.
23:52:16 <lispy> dons: i don't think most people that study OO would catch taht :)
23:52:36 <dons> ~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6
23:52:43 <mbishop> heh
23:52:44 <dons> argh
23:52:45 <dons> network slow slow
23:52:45 <lispy> interesitng, but i disagreed
23:53:00 <lispy> i say ~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4
23:53:31 <lispy> > cycle "~[4"
23:53:33 <lambdabot>  "~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4~[4...
23:53:34 <dons> for some reason when packet loss slows things down enough, irssi trips up and thinks that no escape was hit
23:53:42 <monochrom> Richard Bird's haskell book has monad transformers.
23:55:36 <shankys> interesting -- the best monad reference (freely available online) that I've found so far is http://www.nomaware.com/monads/html/index.html
23:55:37 <Shimei> dons: I see. I'm beginning to see type classes as a more elegant OO (I guess that characterization can't be correct since Haskell has no objects, but...). Are they more efficient than classes+objects, btw? From the tutorial I got the impression that the compiler just whisks them away.
23:55:38 <lambdabot> Title: All About Monads
23:56:14 <lispy> Shimei: in some cases i think the compiler needs a tiny bit of run-time support for them
23:56:23 <lispy> Shimei: in the form of "dictionary" passing
23:57:30 <dons> :t sort
23:57:31 <lambdabot> forall a. (Ord a) => [a] -> [a]
23:57:34 <dons> :t sortBy
23:57:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:58:09 <dons> same thing, one takes an explicit sorting function, the other takes a dictionary which specifies which (a -> a -> Ordering function to use (implicitly)
23:58:57 <dons> the "(Ord a) =>" turns into a method dictionary at runtime, uless the compiler knows statically which types the function is invoked on, in which case it can specialse and inline
23:59:12 * dons drowns in packet loss
23:59:16 <dons> gulp
23:59:44 * lispy throws dons a life packet preserver
