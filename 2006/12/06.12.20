00:00:47 <fishkandy> dons: d'oh, bummer dude
00:02:30 <goltrpoat> ooh.  sigfpe's new post is interesting
00:03:06 <goltrpoat> his U x is a pointed set
00:04:05 <xpika> is anyone from usa here?
00:04:33 <goltrpoat> no nice way to enforce the properties in the usual category on pointed sets, but it's cool nonetheless
00:04:41 <goltrpoat> xpika:  i'm in the us.
00:04:53 <vegaiW> dons: I could supply some more html entities to my unhtml in lambdabot
00:05:10 <xpika> what do they call the grass to the side of the streets called in the usa?
00:05:13 <xpika> the nature strip?
00:05:17 <goltrpoat> lawns? :)
00:05:23 <xpika> lawns
00:05:24 <xpika> ?
00:05:24 <sorear> me
00:05:36 <xpika> thats on the house side
00:05:44 <xpika> im talking about on the other sise
00:05:47 <xpika> side*
00:05:56 <fishkandy> xpika, like, between the sidewalk and the kerb?
00:05:57 <goltrpoat> the side of the street with no houses on it?
00:06:02 <xpika> yep
00:06:06 <goltrpoat> there are places like that?
00:06:06 <goltrpoat> hehe
00:06:13 <xpika> :S?
00:06:30 <Korollary> in california sometimes there's no sidewalk but just grass.
00:06:43 <xpika> not where you are?
00:06:50 <Korollary> I'm not there anymore
00:06:53 <dobblego> ?where filepath
00:06:53 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
00:07:14 <xpika> do you remember what it was called?
00:07:18 <fishkandy> xpika, goltrpoat is referring to vacant lots, not nature strips -- timing error ;-)
00:07:25 <goltrpoat> :)
00:08:11 <Korollary> I'm not sure whether it was called anything specific.
00:08:19 <goltrpoat> yes, if i had to come up with a name for "the side of the street with no houses on it," i'd christen it.. [tadaa] *PARKING SPOT*
00:08:22 <xpika>  [house],sidewalk,grass,road,grass,sidewalk,[house]
00:08:40 <goltrpoat> lawn?
00:09:04 <nornagon> "the bit of the sidewalk with grass on it"?
00:09:04 <lambdabot> nornagon: You have 1 new message. '/msg lambdabot @messages' to read it.
00:09:19 <opqdonut> lo
00:09:46 <glguy> gcc: installation problem, cannot exec `as': No such file or directory
00:09:55 <glguy> what might cause that?
00:10:02 <Korollary> lack of binutils?
00:10:05 <sorear> dons: it seems that the warning in question is unaffected by -w
00:10:17 <glguy> I think maybe it'sa path issue...
00:10:23 <nornagon> sorear: quite
00:10:27 <sorear> (looking in the ghc source with minimal understanding)
00:10:50 <glguy> Korollary: this is using the visual haskell install
00:10:58 <Korollary> ooh
00:11:01 <xpika> damn it looks like the word im looking for IS australian only http://www.allwords.com/word-nature%20strip.html
00:11:03 <lambdabot> Title: Allwords.com Definition of nature strip
00:11:25 <Korollary> damn aussies
00:11:34 <xpika> yes damn me.
00:11:35 <glguy> Korollary: I'm trying to force this to work on Vista (I got paste the regsvr32 failing so far :) )
00:13:16 <Korollary> Give that man a beer
00:13:56 <goltrpoat> glguy:  is this the latest version?  i had some issues with 2005 after grabbing visual haskell the second they announced it
00:14:13 <glguy> goltrpoat: it works swimmingly in xp
00:14:19 <goltrpoat> (specifically, with registering the services)
00:14:31 <glguy> but I don't like being told that I can't do it in vista :-p
00:14:45 <glguy> I manually registered the services, as per the setup.vbs
00:15:10 <goltrpoat> hmm
00:15:37 <goltrpoat> krasimir seems to be very responsive, in general..  email him, maybe?
00:15:55 <goltrpoat> i'd try just installing the latest release over what you currently have though
00:16:01 <glguy> yeah, I might do that in the morning :)
00:16:04 <vegaiW> dons: or perhaps I should take some time and supply them all?
00:16:08 <goltrpoat> like i said, i had some issues with 2005 and an earlier 0.2 than the current 0.2
00:16:20 <goltrpoat> (wish they'd tag them a bit more coherently, come to think of it)
00:16:21 <dons> mmmm, Total number of lines: 999199 produced in #haskell in 06
00:16:42 <glguy> dons: I'll push us over on my own tomorrow ;)
00:17:06 <dons> the first line of the year was: 00:01:25 <pierre-> happy new year!
00:17:19 <goltrpoat> dons:  is that just from lambdabot queries?
00:17:44 <dobblego> > 354 / 365
00:17:44 <dons> the 500k'th line was; 06:45:52 <petekaz> in what respect?
00:17:46 <lambdabot>  0.9698630136986301
00:18:39 <sorear> it should be...
00:18:42 <goltrpoat> that's like.. more than 2500 lines a day
00:18:44 <goltrpoat> that's nuts.
00:18:45 * glguy fixes his ghc problems by adding gcc-lib\ to PATH..
00:18:50 <glguy> wonder where that gets set up
00:18:57 <dons> > 999199 / 354
00:18:59 <lambdabot>  2822.5960451977403
00:19:14 <dons> ah, we just hit the 2.5M lines in #haskell all up, 2505876
00:19:24 <dons> of which 1M were this year.
00:19:28 <sorear> dons: if you feed *all* the logs, catted, thru [br7]zip, how big is the result?
00:19:40 * dons tires this
00:20:08 <sorear> tires of this <|> tries this ?
00:20:26 <dons> yes :)
00:20:30 <dons> tries
00:21:57 <dons> 97.2  0.7   0:51.78 bzip2 ....
00:22:37 <dons> 50181775 bytes
00:22:58 <dons> $ cat * | bzip2 -c | wc -c
00:23:49 <pjd> dons: and LZMA? :)
00:25:03 <sorear> ah, I won't pester you for a copy then :)
00:26:10 <dons> sorear: its in darcs
00:26:15 <dons> you can pull them, 500M worth
00:26:41 <dons> http://www.cse.unsw.edu.au/~dons/code/irc-logs/
00:26:42 <lambdabot> Title: Index of /~dons/code/irc-logs
00:26:58 <sorear> wait... 500M / 2.5M = 200 chars per line!
00:27:08 <dons> maybe i should burn the logs to cds, and hand them out at the hackathon
00:27:29 <goltrpoat> is it just me, or is bulat slowly discovering more and more efficient ways of writing utterly obfuscated c code in haskell
00:27:50 <notsmack> who's bulat?  i keep seeing him mentioned
00:28:11 <dons> sorear: actually, just the logs are 196M    total
00:28:15 <dons> if you only grab the pristine tree
00:29:14 <goltrpoat> notsmack:  bulat ziganshin, a guy on the mailing lists
00:30:21 <int-e> goltrpoat: it's not just you.
00:30:51 <int-e> goltrpoat: actually that doesn't even scare me. what scares me is the way in which he implies that this is the only reasonable way to write haskell programs today.
00:31:21 <goltrpoat> -nod-
00:31:38 <sorear> dons: based on my extremely limited understanding of the GHC source code, the warning Lambdabot.hs is triggering is unconditional, not even for -w.
00:32:34 <goltrpoat> he's certainly quite erudite, i'm just not sure what the hell he's doing as of late, or why
00:32:35 <goltrpoat> hehe
00:32:37 <lisppaste2> beschmi annotated #32996 with "patch for darcs" at http://paste.lisp.org/display/32996#1
00:32:41 <dobblego> given [a], a function a -> IO (Maybe b), produce a IO [b] as if it were applied to mapMaybe (without the IO monad) -- is this possible?
00:32:54 <goltrpoat> i thought the 'sum' post was a joke until i saw his name on it
00:33:22 <mr_tenor> goltrpoat: link to a good example of bulat's posting?
00:33:30 <Itkovian> dons: does your blog have an rss/atom feed somewhere?
00:33:35 <goltrpoat> mr:   cafe archives?
00:34:04 <beschmi> is there is a way to get the value of errno via ffi if errno is either an int or a macro that expands to a function call?
00:34:04 <dons> Itkovian: yeah, at the bottom
00:34:11 <dons> looks like i should put a link near the top to the feed
00:34:24 <sorear> dibblego: catMaybes `liftM` mapM fun list
00:34:25 <mr_tenor> goltrpoat: yeah, i don't read the lists so i thought you'd know a good example ofhand. but i'll go wade through it then, out of curiosity
00:34:41 <dobblego> ?type catMaybes
00:34:42 <lambdabot> forall a. [Maybe a] -> [a]
00:35:24 <dobblego> ?hoogle liftM
00:35:25 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
00:35:25 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
00:35:25 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
00:35:50 <pjd> OT: does Haskell support anything along the lines of docstrings?
00:36:00 <int-e> mr_tenor: how about http://www.haskell.org/pipermail/haskell-cafe/2006-December/020614.html
00:36:03 <lambdabot> Title: A suggestion for the next high profile Haskell project [Was: Re: [Haskell-cafe]  ..., http://tinyurl.com/y4k87s
00:36:48 <dobblego> sorear, excellent thanks
00:36:55 <dons> pjd, you mean like haddock markup?
00:37:10 <dons> -- | this is a comment for haddock
00:37:13 <pjd> in other words, some way (or tool) for interactively calling up something's help/definition
00:37:23 <mr_tenor> int-e: wow. he must be smart to know this ;)
00:37:34 <dons> well, there's the haddocks docs. which you can find via lambdabot, I guess:
00:37:37 <dons> ?hoogle intersperse
00:37:38 <lambdabot> List.intersperse :: a -> [a] -> [a]
00:37:41 <dons> ?docs Data.List
00:37:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:37:44 <pjd> dons: i'm not really familiar with haddock yet; does it do more than off-line doc generation?
00:37:48 <dons> ?source Data.List
00:37:49 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
00:37:55 <dons> pjd, off line, yep
00:38:09 <int-e> mr_tenor: http://www.haskell.org/pipermail/haskell-cafe/2006-December/020612.html is that sum example that has been mentioned
00:38:11 <lambdabot> Title: [Haskell-cafe] I'd like start with Haskell, but..., http://tinyurl.com/y4s2t4
00:38:14 <dobblego> what kind of retarded comment is that? is Bulat the mailing list troll?
00:38:40 <int-e> I think a lot of it has to do with trying to be terse in a foreign language.
00:38:48 <dons> yeah.
00:39:06 <mr_tenor> the foreign language being english, or haskell?
00:39:10 <int-e> english
00:39:40 <mr_tenor> mrm. with ourjapanese collegues, we have to remember not to associate all the connotations we normally do with the words they use in englihs
00:39:54 <dobblego> so it is a language barrier? not an attempt to be a nuisance?
00:40:54 <mr_tenor> i think he might be trying to say "for algorithms which are necessarily imperative, the representation won't be as nice", rather than "here's how to sum a list", you think?
00:41:17 <mr_tenor> or he could be clueless :P
00:41:24 <goltrpoat> he's certainly not clueless
00:41:54 <goltrpoat> he does have an unhealthy obsession with optimization, though
00:42:10 <mr_tenor> in that 020614.html email, he doesn't seem to get the concept of declarative programming
00:42:12 <pjd> dons: hmm, would it be possible to use a haddock-like tool to generate local documentation that could be called up interactively by ghci, or a man-like tool?
00:42:12 <goltrpoat> and he appears to associate fast code with imperative code, for whatever reason
00:42:21 <mr_tenor> the idea is to let the compiler optimize, though :/
00:42:23 <sorear> pjd: certainly.
00:42:35 <sorear> pjd: it already exist IIRC.
00:42:41 <sorear> ?where goa
00:42:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
00:42:48 <glguy> Clean's IDE isn't something people should recommend unless they've actually used it.. I've tried playing with it... terrible
00:42:51 <pjd> sorear: thanks
00:43:21 <sorear> I've never used it, iirc it is a lambdabot port to ghci, including ?hoogle
00:43:23 <mr_tenor> goltrpoat: yeah, i know a bunch o really good coders that still think "everything gets turned into C anyway". might be a generation gap thing ;)
00:43:33 <dons> glguy: yeah. similarly recomending jhc
00:43:47 <goltrpoat> -shrug- he's probably my age.
00:43:51 <glguy> who recommended jhc (an alternative haskell compiler?)
00:44:02 <dons> bulat :) if you want speed, use jhc
00:44:11 <pjd> sorear: does it give things as URLs, or directly?
00:44:12 <dons> which i'm not sure is a reasonable thing to suggest *yet* anyway
00:44:28 <sorear> I think that (almost) "everything gets turned into C anyway"... but I am so glad I'm not the one who has to do the turning-into-C!
00:44:30 <mr_tenor> well, referring to what style of compsci education you have, rather than actual age
00:44:41 <sorear> internet
00:45:10 <goltrpoat> glguy;  gotta agree about the clean ide, btw
00:45:17 <goltrpoat> unpleasant
00:45:30 <glguy> Even things like "You can't backspace if you are holding shift down"
00:45:38 <glguy> make me wonder if anyone else had used it before either
00:45:57 <dobblego> ?hoogle catMaybes
00:45:58 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
00:48:08 <goltrpoat> :t map fromJust . filter isJust
00:48:09 <lambdabot> forall a. [Maybe a] -> [a]
00:50:42 <beschmi> dons: even when it's finished. i heard mlton needs 40 hours to compile itself
00:51:07 <sieni> beschmi: like where?
00:51:50 <beschmi> i'm not sure if jhc would scale to big projects
00:51:56 <sorear> pjd: probably urls *now*, but writing a fully general haddock-frontend doesn't seem impossible
00:52:40 <beschmi> sieni: i think the 40 hours where mentioned on the felix mailing list
00:53:35 <vegaiW> sorear, dons: the Eval plugin won't work without hs-plugins, or will it?
00:54:08 * sorear doesn't know
00:54:18 <dons> beschmi: huh. :)
00:54:27 <vegaiW> or rather, will plugs work without hs-plugins
00:54:27 <dons> vegaiW: won't work without hs-plugins
00:54:31 <dons> no
00:54:32 * vegaiW nods
00:54:38 <pjd> sorear: seems like a good project to tackle? :)
00:55:02 <pjd> i'm missing the convenience of help()/pydoc
00:55:02 <goltrpoat> is there any reason why hoogle doesn't search for module names btw?
00:55:24 <goltrpoat> it gets remarkably annoying when you have to come up with the name of a function out of a module just to get to the module overview
00:55:31 <dons> pjd, maybe you could describe pydocs behvaiour on the mailing list
00:55:35 <dons> see what the haddock devs think
00:56:25 <pjd> dons: it's pretty simple; you give it a module/object name, and it dumps out a man-like listing of its docstring
00:56:41 <dons> ah ok. so like:
00:56:44 <dons> ?docs Data.List
00:56:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:56:48 <dons> but to the console?
00:56:52 <dons> and not via http :)
00:56:59 <pjd> pretty much
00:57:00 <sorear> <finished downloading logs>
00:57:07 <dons> yeah, sounds like a trivial ghci plugin
00:57:12 <dons> since you can install the docs locally
00:57:18 <dons> and bind arbitrary haskell to commands in ghci
00:57:31 <dons> one of which would be: do x <- readFile; putStrLn (textOf x)
00:57:32 <goltrpoat> http://haskell.org/hoogle/?q=Control.Monad.Reader
00:57:33 <lambdabot> Title: Control.Monad.Reader - Hoogle
00:57:38 <pjd> can haddock output to console?
00:57:48 <dons> haddock dumps to html files on disk
00:57:54 <dons> which we could filter
00:58:03 <dons> to text, say, via w3m or lynx or -package xhtml
00:58:36 <pjd> hmm, a simple text-specific target could yield better-reading results
00:59:10 <pjd> pydoc intentionally looks man-like when outputting to the console; its HTML output is quite different
00:59:49 <dons> so like a fancy version of:
00:59:51 <dons> $ lynx -dump -force_html -width=80 doc/libraries/base/Data.List.html
01:00:02 <dons>    Haskell Hierarchical Libraries (base package) [1]Contents [2]Index
01:00:02 <dons>    Data.List
01:00:02 <dons>    Portability portable
01:00:02 <dons>    Stability   stable
01:00:02 <dons>    Maintainer  libraries@haskell.org
01:00:04 <dons>    Contents
01:00:07 <dons> .....
01:00:10 <dons> ?
01:00:21 <pjd> i guess :)
01:00:23 <dons> that you can grab from the ghci prompt?
01:00:47 <pjd> and, for extra points, is also dynamically-generated
01:01:03 * notsmack watches dons sprint for 1M lines
01:01:08 <pjd> so it works for code you're busy writing
01:01:36 <ulph> wow
01:01:38 <sorear> 7zip is 20% through irclog...
01:02:13 <ulph> now my UM is FAST! it ran the sandmark.umz in 6:26.34 ;)
01:03:06 <dons> pjd, Prelude> doc "Data.List"
01:03:06 <dons>    Haskell Hierarchical Libraries (base package) [1]Contents [2]Index
01:03:06 <dons>    Data.List
01:03:06 <dons>    Portability portable
01:03:06 <dons>    Stability   stable
01:03:09 <dons>    Maintainer  libraries@haskell.org
01:03:11 <dons>    Contents
01:03:14 <dons>    [3]Basic functions
01:03:16 <dons>    [4]List transformations
01:03:56 <pjd> doc?
01:05:01 <dons> Prelude> :def hdoc (\x -> doc x >> return [])
01:05:01 <dons> Prelude> :hdoc Data.List
01:05:01 <dons>    Haskell Hierarchical Libraries (base package) [1]Contents [2]Index
01:05:01 <dons>    Data.List
01:05:04 <dons>    Portability portable
01:05:06 <dons>    Stability   stable
01:05:09 <dons>    Maintainer  libraries@haskell.org
01:05:20 <dons> where
01:06:17 <dons> Prelude> let doc = \doc -> System.Cmd.system $ "lynx -dump -force_html -width=80 /home/dons/doc/libraries/base/" ++ doc ++ ".html | uniq | head -10"
01:07:14 <sieni> beschmi: took about 7 minutes to compile mlton on my work desktop
01:07:18 <goltrpoat> brainfart.. what does C^{op} stand for, in category theoretic terms?
01:07:26 <pjd> dons: nifty :)
01:07:40 <Syzygy-> goltrpoat: This is really a question, and not socratic teaching?
01:07:47 <goltrpoat> it's a question
01:07:48 <goltrpoat> :)
01:07:50 <int-e> goltrpoat: the opposite category
01:07:55 <int-e> goltrpoat: all arrows reversed
01:07:59 <goltrpoat> DOH
01:08:00 <Syzygy-> C^{op} is the category with objects the same as in C, and with Hom_Cop(A,B)=Hom_C(B,A)
01:08:00 <goltrpoat> thanks.
01:08:06 <goltrpoat> -nod-
01:08:18 <sieni> beschmi: 2.8GHz Pentium 4, 1.5G of memory
01:09:00 <pjd> dons: i assume it's a small matter of programming to pull it directly from haddock, instead of pre-formatted output?
01:09:09 <beschmi> sieni: that's where i got the number from http://sourceforge.net/mailarchive/message.php?msg_id=37711575 , perhaps he's talking about some special optimisation settings
01:09:10 <lambdabot> Title: SourceForge.net: felix-language
01:09:12 <Itkovian> dons: thx. btw, your feed shows code without spaces in my netnewswire
01:09:23 <sieni> beschmi: ok
01:09:35 <sieni> I just did make :-)
01:09:53 <pjd> tangentially, my GHC doesn't seem to install everything's source; i assume that means the haddock comments are lost?
01:10:10 <pjd> "my GHC install doesn't seem to include", even
01:12:09 <sorear> pjd: 187M raw, 66M gzip, 47M 7zip(lzma)
01:12:16 <sorear> (you asked)
01:12:47 <pjd> sorear: thanks :)
01:12:48 <sorear> oh, and 7zip set new temp records: 55/36
01:13:06 <int-e> sorear: 'temp'?
01:13:11 <sorear> erature
01:13:12 <pjd> temperature, i assume
01:13:21 <pjd> sorear: where does bz2 fall in that?
01:13:38 <int-e> about 50M
01:13:58 <int-e> [~50 minutes ago] <dons> 50181775 bytes
01:14:09 <sorear> 47.85 Mi
01:14:19 <int-e> > 50181 / 1048
01:14:21 <lambdabot>  47.88263358778626
01:14:39 <sorear> >50181 / 1048.576
01:14:48 <int-e> I know :)
01:37:32 <Masklinn> 'morning
01:38:07 <Vq^> g'day
01:39:38 <dons> pjd, just a small matter of programming, yes
01:39:46 <Vq^> hello dons
01:39:53 <dons> hey Vq^
01:40:16 <Vq^> dons: what is the problem with hs-plugins on ghc6.6 ?
01:40:52 <dons> @tell SyntaxNinja caml-get http://pauillac.inria.fr/~guesdon/camlget.en.html
01:40:52 <lambdabot> Consider it noted.
01:40:59 <dons> Lemmih, dcoutts, http://pauillac.inria.fr/~guesdon/camlget.en.html
01:41:00 <lambdabot> Title: Maxence Guesdon: Camlget
01:41:16 <dons> Vq^: parsing of .hi files. should be fixed by the end of the hackathon
01:42:40 <Vq^> dons: are there large changes in the format?
01:42:56 <dons> not large, no
01:43:42 <Vq^> ok
01:43:48 * Vq^ was just curious
01:43:59 <dons> no no. its fine:) seems like 50 people have asked now
01:44:03 <dons> so i better fix it
01:44:31 <Vq^> heh
01:45:28 <Itkovian> @karma+ dons
01:45:28 <lambdabot> dons's karma raised to 105.
01:45:36 <Itkovian> nice tutorials dude
01:45:46 <fridim> Hi all.
01:46:01 <Vq^> hello fridim
01:46:07 <dons> Itkovian: oh, you hadn't seen them till today?
01:46:07 <fridim> @karma+ yaht
01:46:08 <lambdabot> yaht's karma raised to 2.
01:46:58 <Itkovian> dons: nope, I've been too busy with other things to check them out. In fact, I've been slacking in the Haskell dept. as of lately. Changing that right now.
01:47:11 <dons> :)
01:49:21 <notsmack> anybody have an example of using parsec to parse a markup language?
01:49:36 <notsmack> the recursion is giving me trouble
01:58:49 <dons> mm, i think spj is reading links from the HWN, and filing todos on Trac as a result
01:58:52 <dons> yay
02:01:36 <Syzygy-> dons: Hmmm?
02:33:37 <dons> beschmi: great to see these darcs patches you're writing
02:40:49 <beschmi> dons: these were the easy ones ;) hope the next release rocks, lots of bugfixes in the last days
02:41:18 <dons> yeah, i've noticed the patch rate has gone up
02:41:21 <dons> good sign!
02:41:54 <dons> same with ghc http://www/~dons/images/commits/community/ghc-commits.png
02:42:18 <dons> still waiting for the darcs bump, http://www/~dons/images/commits/community/darcs-unstable-commits.png
02:42:19 <ihope_> It just means there're more mistakes. :-P
02:42:20 <lambdabot> http://tinyurl.com/yeegwn
02:42:56 <dons> hopefully :)
02:44:04 <Vq^> dons: weird urls
02:44:22 <dons> oh. sorry
02:44:32 <dons> s/www/www.cse.unsw.edu.au
03:05:03 <twodogsandacat> hi all
03:05:18 <opqdonut> lo
03:05:48 <twodogsandacat> has anybody any thoughts on web programming in haskell?
03:06:21 <notsmack> twodogsandacat: i've just started, but it seems nice so far
03:06:43 <twodogsandacat> the thing is, i thought about it, and haskell seems a perfect language to describe the web environment.
03:06:52 <twodogsandacat> it's stateless, just like the web, for example.
03:07:45 <notsmack> twodogsandacat: the web is rarely that simple... but haskell seems to manage well.  have you looked at HAppS and WASH?
03:07:50 <pjd> twodogsandacat: don't put *too* much weight into that analogy;  HTTP is relatively stateless, but resources tend not to be
03:08:12 <notsmack> pjd: not to mention sessions, etc
03:08:14 <twodogsandacat> notsmack:  a glance
03:08:23 <Lemmih> Haskell doesn't mind state as long as you don't mutate it.
03:08:26 <pjd> notsmack: indeed!
03:08:51 <twodogsandacat> so would you say it's a good language for the web?
03:08:51 * pjd ponders a session/cookie monad...
03:09:01 <notsmack> i would
03:09:33 <twodogsandacat> i agree sessions could be modelled as monads (in fact, aren't they now?)
03:09:40 <dons> we had a guy here yesterday involved in a startup doing haskell web programming
03:09:41 <dons> using wash
03:09:50 <dons> so that sounds promising
03:10:19 <dcoutts__> cool
03:13:40 <twodogsandacat> wash is still under development?
03:14:32 <notsmack> twodogsandacat: there was a release Dec 02
03:14:59 <notsmack> Dec 2nd that is, not '02
03:16:09 <twodogsandacat> should be interesting to try out
03:39:50 <pjd> hoogle seems to be producing broken links
03:40:09 <pjd> ?hoogle inits
03:40:10 <lambdabot> List.inits :: [a] -> [[a]]
03:40:30 <pjd> err, haskell.org/hoogle, anyway
03:40:42 <pjd> ?docs inits
03:40:43 <lambdabot> inits not available
03:44:31 <xpika> hello, has anyone had any experience with Unboxed array's
03:44:52 <xpika> I'm not getting any speed improvments out of them :(
03:45:34 <lightstep_> i don't know about unboxed arrays, but here plain IOArrays are slower than Array for most operations
03:48:02 <xpika> ok, i get it now
03:48:37 <lightstep_> huh?
03:48:56 <xpika> yay
03:49:11 <xpika> if you dont compile it makes it go slower
03:49:32 <xpika> but if you do you get twice the speed
03:49:35 <xpika> :)
03:49:57 <lightstep> when i tried it here, it depended on array size
03:50:30 <xpika> yea
03:50:48 <xpika> its seems to also be exponentially important to the size of the array
03:51:22 <xpika> when calculating prime numbers up to one million ive now gone from 26 seconds to 2.6
03:51:49 <xpika> while primes up to 100000 its only twice as fast
03:53:43 <_reborn_> hi
03:55:13 <_reborn_> hi
03:56:26 <lightstep> i wonder how Hoogle.MatchType works
04:01:05 <_reborn_> can anyone explain me the parser Language.Haskell.Parser?
04:01:37 <Lemmih> It needs explaining?
04:01:50 <Lemmih> @docs Language.Haskell.Parser
04:01:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/haskell-src/Language-Haskell-Parser.html
04:03:48 <_reborn_>  I have this data Exp = Id | Exp:.:Exp |Bang|Const Exp|Fst|Snd|Inl|.... and I need to make a parser using the Language.Haskell libraries from an haskell file to this type
04:06:01 <Lemmih> _reborn_: why?
04:07:46 <lightstep> does Language.Haskell.Parser support the weird standard let rule?
04:08:32 <augustss> what weird part?
04:08:39 <Lemmih> lightstep: What's the weird standard let rule?
04:08:59 <lightstep> after "in", the longest compilable match is taken
04:09:14 <lightstep> (taking into account associativity, type correctness ,etc.
04:09:35 <augustss> it has nothing to do with let, really
04:10:02 <Lemmih> Types affect how Haskell is parsed?
04:10:20 <augustss> it's the general weird rule that you insert a } to avoid a syntax error
04:10:32 <augustss> type correctness does not affect parsing
04:10:44 <augustss> fixity does (of course)
04:10:55 <lightstep> oh, yes, only fixity
04:12:40 <lightstep> this means that "let a = False in a == a == a" isn't legal, but "let a = False in a == a == False" is (assuming that a isn't defined in an outer scope)
04:13:52 <Lemmih> > let a = False in a == a == False
04:13:53 <lambdabot>    precedence parsing error
04:13:53 <lambdabot>     cannot mix `(==)' [infix 4] and `(==)' ...
04:14:20 <augustss> no known implementation parses Haskell correctly
04:28:31 <araujo> morning
04:35:03 <vegaiW> > let 2+2=5 in 2+2
04:35:05 <lambdabot>  5
04:35:56 <augustss> > let (2+2) = 5 in 2+2
04:35:56 <lambdabot>  Parse error in pattern
04:37:38 <augustss> > let (n+2)=5 in n+2
04:37:39 <lambdabot>  Parse error in pattern
04:37:58 <augustss> broken parser
04:40:37 <_reborn_> I have to do this for a university work and they requested the use of those libraries
04:41:15 <nornagon> > let n+2=5 in 2+2
04:41:17 <lambdabot>  5
04:41:28 <nornagon> > let n+2=5 in n+2
04:41:29 <lambdabot>  Not in scope: `n'
04:44:22 <lightstep> n+k patterns only work for parameters
04:44:31 <lightstep> > let n+2=5 in 3+2
04:44:32 <lambdabot>  5
04:44:37 <_reborn_> I declared a new class
04:44:40 <_reborn_> class SubHsDecl a where
04:44:43 <_reborn_>  toHsExp :: a -> HsExp
04:44:43 <_reborn_>  fromHsExp :: HsExp -> Maybe a
04:44:45 <_reborn_> and did the instance
04:44:45 <_reborn_> instance SubHsDecl Exp where
04:44:48 <_reborn_> toHsExp Bang             = mkVar "bang"
04:44:48 <_reborn_>  toHsExp Id               = mkVar "id"...
04:44:51 <_reborn_> fromHsExp (HsParen e)                      = fromHsExp e
04:44:51 <_reborn_>  fromHsExp (HsVar(UnQual(HsIdent "fst")))   = return $ Fst...
04:44:53 <_reborn_> And after this when I write on ghc  fromHsExp (HsVar(UnQual(HsIdent "fst"))) it says ambiguous type variable 'a' in constraint: SubHsDecl a
04:45:34 <_reborn_> Should't this work?
04:45:37 <lightstep> add a type declaration. ghc doesn't know that there is only one instance of the class
04:46:41 <_reborn_> how can i do that
04:46:43 <_reborn_> ?
04:46:51 <lightstep> > read "1"
04:46:52 <lambdabot>  Add a type signature
04:47:04 <lightstep> > read "1" :: Complex Integer
04:47:05 <lambdabot>  add an instance declaration for (RealFloat Integer)
04:47:14 <lightstep> > read "1" :: Complex Double
04:47:16 <lambdabot>  Exception: Prelude.read: no parse
04:47:25 <lightstep> meh
04:47:34 <lightstep> anyway, just add a type declaration
04:50:13 <augustss> lightstep: I forgot to answer your question earlier.  No, Language.Haskell does not do the right things with fixity after let.  In fact, it does not handle fixity at all. :(
04:52:45 <xpika> what is the simplist data type for storing a mutable int?
04:53:12 <syntaxfree> http://www-128.ibm.com/developerworks/java/library/j-cb12196/?ca=dgr-lnxw01Javascript-Respect
04:53:14 <lambdabot> Title: Crossing borders: JavaScript's language features, http://tinyurl.com/y7v26l
04:53:26 <_reborn_> thnks a lot lightstep I got it now
04:53:31 <syntaxfree> that claims JavaScript represents objects as nested functions.
04:53:41 <syntaxfree> It seems JavaScript is a functional language, after all!
04:53:59 <augustss> xpika: the first question is, why do you want a mutable int? :)
04:56:43 <tibbe> g'day all
05:03:55 <xpika> i want to load a list into memory and not have to write to a file
05:04:39 <augustss> huh?
05:05:40 <tibbe> > i_am_a_list_in_memory = [1,2,3]    -- xpika :)
05:05:40 <lambdabot>  Parse error
05:05:45 <tibbe> argh!
05:07:08 <augustss> close enough
05:09:28 <syntaxfree> someone should write a "Common operations with loops, while blocks and counter variables in idiomatic Haskell" tutorial.
05:09:29 <augustss> perhaps i should write a bot that injects random questions on #haskell
05:09:59 <xpika> im not random
05:10:02 <xpika> http://en.wikibooks.org/wiki/Haskell/Mutable_objects
05:10:44 <augustss> no, you're not.  But why do you want a mutable variable?
05:12:38 <xpika> so i can save the state of a list
05:13:45 <augustss> save it for what?
05:13:56 <xpika> to be retrieved again
05:14:20 <augustss> and why don't you pass the list along to the function that needs it?
05:14:35 <_reborn_> why don't you use the monad state?
05:14:36 <xpika> because i want to be able to do functions in the middle
05:14:51 <augustss> i can almost guarantee you that you don't want a mutable variable
05:15:10 <augustss> perhaps you want the state monad
05:15:21 <xpika> maybe
05:15:44 <augustss> mutable variables are really, really rare in idiomatic haskell code
05:16:12 <audreyt> ...but mutable variables are exactly what state monads do
05:17:00 <lightstep> only IO and ST have variables. StateT has an environment
05:17:27 <augustss> audreyt: yes, but the "real" mutable variables live in strange monads
05:17:44 <augustss> ST is fine, IO is terrible
05:19:17 <audreyt> sure. but runST is fine and, imho, preferable to State monad
05:19:33 <audreyt> I've actually never used the State monad except for my first haskell program :)
05:20:01 <augustss> audreyt: I'd say it depends on what you want to do.
05:20:11 <lightstep> how does this work? http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/18279
05:20:15 <lambdabot> Title: Gmane -- Mail To News And Back Again
05:22:05 <lightstep> if you have an (forall a. MVar a), and you store Int than retrieve Char, what do you get?
05:22:30 <augustss> let's hope that's not what he meant :)
05:27:40 <syntaxfree> xpika: I think most of us are prepared to say that there's a 95% chance you don't want mutable variables.
05:28:53 <vegaiW> Would this sort of a thing fit into Lambdabot as a plugin? A program that listens to changes in a certain directory and runs tests&quickchecks when any of the source files change, and report the results to irc.
05:29:11 <syntaxfree> xpika: read this: http://catb.org/~esr/faqs/smart-questions.html#goal
05:29:12 <lambdabot> Title: How To Ask Questions The Smart Way
05:29:14 <syntaxfree> just that section.
05:29:19 <syntaxfree> It's two paragraph-long.
05:29:58 <dylan> I tend to use a ReaderT (TVar something) of some sort.
05:30:05 <syntaxfree> audreyt: Hey, I've started to read the Pugs code, but I'm going really slowly these days. Ugly personal trouble.
05:30:08 <dylan> I've never used State... ever.
05:30:29 <audreyt> syntaxfree: that's fine :) I'm having personal troubles too
05:30:34 <syntaxfree> Just thought I'd give some status info.
05:30:40 <syntaxfree> I did not ignore you :)
05:30:44 <audreyt> but they became rather beautiful lately
05:30:45 <audreyt> sure :)
05:38:11 <ulph> is it possible to get nice tail recursion optimization on something like f x = if cond x then f (calc1 x) else calc2 x
05:38:49 <ulph> i get several versions of f in the dump-file for some reason
05:38:55 <msingh>  /j #scheme
05:39:20 <Lemmih> ulph: It should be.
05:41:51 <augustss> ulph: looks like the tail call optimization should work on that
05:47:24 <ulph> i have another function that's around f, say g. so when f actually returns g will call f. but sometimes f will call itself at the end of one of the branches in the case statement in f.
05:48:42 <ulph> before g always did the recursive stuff and everything worked fine and f was inlined into g in the dump. now instead i get several instances of g with f inlined
06:34:57 <bewo> is there a standard library for doing a unix select() call?
06:37:55 <bewo> some library report mentions a 'Select' interface, but ghc doesnt know it.
06:38:14 <mux> you typically won't do select() like stuff in Haskell
06:38:29 <bewo> why not?
06:41:04 <augustss> select went away :(
06:42:36 * bewo shakes his head wondering
06:43:05 <augustss> bewo: you're supposed to use threads now
06:43:42 <augustss> but I'd still like to have select.  in case i want to implement my own threads
06:44:01 <bewo> i find select very convenient to implement network protocols
06:44:35 <bewo> tried it with threads one time, and got horrible race conditions with all that timeouts
06:45:27 <dylan> try STM then. :)
06:47:29 <bewo> im not sure that stm really mixes well with network protocols
06:47:40 <dylan> it does
06:47:54 <bewo> have you tried it?
06:48:04 <dylan> I wrote a server using it
06:48:14 <dylan> using a TVar [
06:48:16 <dylan> err
06:48:26 <dylan> using a TVar [(String, Handle)]
06:49:09 <bewo> did you have to synchronize between several sessions in your server?
06:49:37 <dylan> hmm?
06:49:56 <dylan> each client thread had to update the list of clients.
06:50:11 <dylan> it supports a really large amount of concurrent connections.
06:50:17 <dylan> (it's a toy, though)
06:50:25 <dylan> I had something like:
06:50:35 <dylan> addClient :: String -> Handle -> STM ()
06:50:37 <bewo> so you had one thread accepting conenctions and distribute them to workers
06:50:49 <bewo> and the workers could remove themselves from the list
06:50:52 <ulph> hm. should my ghc-compiled program really be allowed to used ~1GB of RAM when i'm not specifying any +RTS-options?
06:51:04 <dylan> and lookupClient :: String -> STM Handle
06:51:47 <ulph> or does that just mean that it's not stack space that it's leaking massively?
06:51:55 <dylan> bewo: yeah.
06:52:13 <dylan> And if you need erlang-like concurrency, there are TChans
06:53:03 <bewo> i used ocaml w channels.
06:53:41 <dylan> that is a bit different, since ocaml threads arn't very good.
06:54:07 <dylan> haskell threads are light weight and also support SMP... and ocaml's threads are (usually) heavy and do not support SMP,
06:54:12 <dylan> which is sort of weird. :)
06:54:22 <bewo> no, the problem is that the queues in msg channels can fill up and block
06:54:55 <bewo> and if your distributor sends a message to a worker, and the worker tries to send a message to the distributor, you get a dead-lock
06:54:56 <dylan> You could just use more threads then.
06:55:02 <bewo> just like with semaphores
06:55:28 <dylan> forkIO $ do msg <- readMsg; sendMsg "foo" msg
06:55:51 <dylan> no reason to not use two or five threads per client. :)
06:56:24 <dylan> I didn't have a distributer, btw.
06:56:38 <dylan> in the final version, each client forked off a thread to send messages to every other client.
06:56:46 <bewo> the trick was that the clients could only send messages as responses to requests of the distributor
06:57:01 <dylan> imho that's not very fun. :(
06:57:31 <bewo> yes, but very other solution blocked sooner or later
06:57:40 <dylan> the 'main thread' is just an accept loop. 1 reader thread for each client, and spawn temporary one-shot threads to send messages.
06:58:06 <bewo> in my case, it wasn't just tcp sessions but SIP dialogs
06:58:26 <bewo> which aren't demultiplexed by the kernel, but by the distributor
06:58:28 <dylan> then add 1 writer thread for each client. :)
06:58:51 <dylan> (this solution would not be viable in ocaml)
06:59:07 <bewo> even more threads is not what i want
06:59:23 <dylan> why not? it's not like you get locks with STM.
06:59:24 <bewo> can you implement proper timers with STM?
06:59:43 <dylan> huh?
07:00:16 <bewo> i mean when sending a request, i start a timer
07:00:31 <bewo> which triggers an event some time later
07:00:37 <dylan> You could just create a thread and block until you get a message back.
07:00:38 <shankys> bringert: Are you there by any chance? I'm build Network.FastCGI on my new dedicated Linux server, and I'm getting a build error I don't know how to get rid of...
07:00:44 <shankys> *building
07:01:01 <dylan> or create a thread and sleep for a given amount of time and send a message then.
07:01:05 <bewo> that was my first try
07:01:36 <bewo> but some time later, it exceeded the max num of threads
07:01:39 <dylan> createTimer :: Int -> IO () -> IO ()
07:02:09 <dylan> createTimer timeout io = do forkIO $ delayThread timeout; io
07:02:13 <bewo> a timer thread has other difficulties
07:02:22 <bewo> like, how do you remove a timer?
07:02:25 <dylan> In ocaml or in haskell?
07:02:30 <bewo> either way
07:02:37 <dylan> kill the thread?
07:02:52 <dylan> you can throw arbitrary exceptions to threads, I think.
07:02:52 <bewo> if you have one thread per timer, yes
07:03:03 <dylan> why not have one thread per timer?
07:03:07 <bewo> that would do
07:03:21 <bewo> there's a limit for the number of threads
07:03:30 <dylan> isn't that limit very large?
07:03:36 <bewo> or does haskell implement its own threads?
07:03:49 <bewo> i used to think it was large enough until i tried
07:04:04 <dylan> forkIO is light weight, but distributes over SMP as of ghc 6.6
07:04:05 <bewo> to setup 1000 SIP requests, each with a whole set of timers
07:04:08 <earthy> haskell implements its own language level threads
07:04:20 <earthy> on top of system threads
07:04:44 <dylan> haskell is the only language, other than erlang, I've ever had success using threads in.
07:04:47 <bewo> so do the limits of the OS limit the number of haskell threads?
07:05:04 <dylan> bewo: only in terms of CPU power...
07:05:29 <bewo> i've been implementing network protocols for years. the ocaml version was the first try with threads
07:05:40 <dylan> if have a 12 core machine, you could probably have a lot of threads.
07:05:53 <bewo> before i either was in kernel mode (ie event driven) or used select/poll or the like
07:05:55 <earthy> bewo: not directly
07:06:32 <earthy> the OS limits the number of OS threads that can be used, and that limits the number of threads that can do IO at the same time
07:06:35 <dylan> how many threads until the RTS chokes on a single processor machine?
07:06:41 <earthy> dunno
07:07:10 <dylan> earthy: well, System.IO and friends use select/poll under the hood. right?
07:07:25 <bewo> performance wasnt an issue, just the thread creation
07:08:14 <earthy> dylan: yup
07:08:20 <bewo> thank you for all your suggestions
07:09:40 <dylan> bewo: just take away from this that haskell threading is more advanced than most other languages. Massive concurrency is something haskell is getting very good at.
07:10:25 <bewo> thats why im trying to get into the language
07:10:44 <bewo> which is still somewhat hard, even after 5 years of ocaml
07:11:31 <dylan> I had 1 year with ocaml, and then I decided the community was buggy.
07:12:42 <bewo> at least, ocaml doesnt have this - excuse me - brain-dead layout syntax
07:13:05 <dylan> then don't use it
07:13:36 <dylan> I found ocaml's syntax horrible, but there's no accounting for taste.
07:13:40 <Philippa_> right. Realising it's optional is the first key to realising it's not braindead
07:13:52 <bewo> yes, but then ive to clutter the code with {}
07:13:57 <Philippa_> realising that it almost always then matches sensible indentation is the second
07:14:00 <bewo> of course your right with respect on tastes
07:14:23 <bewo> but it is an obstacle for new users
07:14:31 <bringert> shankys: what's the error?
07:14:40 <Pupeno> bewo: would it be better if it was [] or () ? or start/end ?
07:15:00 <shankys> bringert: Network/FastCGI_hsc_make: error while loading shared libraries: libfcgi.so.0: cannot open shared object file: No such file or directory
07:15:00 <shankys> running Network/FastCGI_hsc_make failed
07:15:01 <shankys> command was: Network/FastCGI_hsc_make  >Network/FastCGI.hs
07:15:01 <shankys> Setup.hs: got error code while preprocessing: Network.FastCGI
07:15:02 <Philippa_> that's 50/50. I do think it'd be a good thing for more tutorials to summarise what the H98 report says about the layout rule and where the braces and semicolons go in the grammar
07:15:03 <bewo> well, i'd opt for the ocaml solution..
07:15:18 <Philippa_> naturally, you spent 5 years working in it
07:15:25 <dylan> ocaml's top level syntax is insane.
07:15:30 <bringert> shankys: does the machine have libfcgi.so.0 somewhere?
07:15:37 <bewo> if you have to explain it at length in wikis and tutorials, it may be a sign that it is not optimal
07:15:53 <dylan> the hardest part of ocaml was syntax for me.
07:16:05 <Philippa_> you don't, what I have in mind is a couple of paragraphs and a quick table
07:16:07 <dylan> nobody ever said ";;" was always optional...
07:16:48 <bewo> ok ';;' is a mess. but ML shows how you could do it without braces and without too many braces
07:17:02 <bewo> (1st braces=spaces)
07:17:06 <shankys> bringert: I'm not sure... Do you know where it's supposed to be?
07:17:52 <bringert> shankys: you need to have the fastcgi development libs and headers installed
07:18:24 <bringert> shankys: though it should complain about missing headers if you don't have it installed
07:18:32 <shankys> bringert: I went to fastcgi.com and downloaded fcgi.tar.gz and installed that
07:19:00 <bringert> shankys: that should do it. maybe it installed into /usr/local/lib
07:19:19 <shankys> bringert: Yeah, actually it did install there
07:21:17 <bringert> shankys: can you give the -v flag to configure and build and paste it?
07:21:18 <shankys> bringert: I just used apt-get to get the fastcgi development kit and now it's working. apt-get is amazing :-)
07:21:22 <bringert> ah, ok
07:21:24 <bringert> great
07:49:48 <ralejs> > splitAt 3 "therapist"
07:49:55 <lambdabot>  ("the","rapist")
07:50:18 <glguy> > splitAt 1 "swords"
07:50:19 <lambdabot>  ("s","words")
07:50:47 <velco> > splitAt 3 "penisland"
07:50:49 <lambdabot>  ("pen","island")
07:51:02 <ralejs> Humor, haskell style
07:52:08 <glguy> > let [a,b,c] = words "pen is mightier" in (a++b):[c]
07:52:09 <lambdabot>  ["penis","mightier"]
07:54:12 <glguy> > sequence [take 4, take 3 . drop 4, drop 7] . join . words $ "an album cover"
07:54:13 <lambdabot>  ["anal","bum","cover"]
08:01:13 <Adamant> > "I'm onto you, Trebek!"
08:01:14 <lambdabot>  "I'm onto you, Trebek!"
08:01:30 <Adamant> sometimes simple is best. :)
08:01:36 <glguy> "Yes, but will it work? Will it mighty my penis"
08:05:06 <bewo> are there any standard IPv6 socket libraries for haskell?
08:10:53 * SamB_XP not think so
08:11:48 <SamB_XP> I think some people were working on a new networking library to replace the rather pathetic one we have now?
08:12:49 <bewo> a plain socket api is not too bad, but it should be more complete
08:12:54 <SamB_XP> (you can do the usual stuff with the current networking library, but the naming conventions border on nonexistant, iirc)
08:13:11 <SamB_XP> or, at least, vary from module to module...
08:13:33 <SamB_XP> @hoogle address
08:13:34 <lambdabot> Text.Html.address :: Html -> Html
08:13:34 <lambdabot> Network.BSD.hostAddress :: HostEntry -> HostAddress
08:13:34 <lambdabot> Network.BSD.networkAddress :: NetworkEntry -> NetworkAddr
08:13:46 <SamB_XP> @hoogle NetworkAddr
08:13:47 <lambdabot> Network.BSD.NetworkAddr :: type NetworkAddr
08:13:47 <lambdabot> Network.BSD.networkAddress :: NetworkEntry -> NetworkAddr
08:13:57 <bewo> ouch
08:13:59 <SamB_XP> @doc Network.BSD
08:13:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-BSD.html
08:14:38 <SamB_XP> hmm. that doesn't look at all encouraging...
08:15:52 <SamB_XP> hmm...
08:15:57 * bewo cant resist mentioning that ocaml supports ipv6 for years
08:16:34 <SamB_XP> Judging by http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html#t%3ASockAddr there is not actually IPv6 support yet.
08:16:57 <bewo> its just Word32
08:17:02 <SamB_XP> at least, not in the standard network library
08:17:11 <lambdabot> http://tinyurl.com/fkdb4
08:17:13 <bewo> not even a data 'IPv4 Word32'
08:17:16 <SamB_XP> bewo: yeah, that Network.BSD module looks especially bad though
08:17:45 <SamB_XP> @hoogle SockAddr
08:17:45 <lambdabot> Network.Socket.SockAddr :: data SockAddr
08:17:45 <lambdabot> Network.Socket.SockAddrInet :: PortNumber -> HostAddress -> SockAddr
08:18:14 <SamB_XP> this SockAddr type at least looks like it has the potential for IPv6 support.
08:18:24 <Lemmih> @where network-alt
08:18:25 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
08:18:29 <bewo> ok
08:18:34 <SamB_XP> really, though, we haven't had actual network applications written in Haskell for that long, as far as I know
08:18:55 <Lemmih> ^^ network-alt has IPv6 support, iirc.
08:19:16 <bewo> just checking it
08:20:12 <bewo> supports ipv6
08:20:25 <bewo> but it is a bit inconsistent at other functions
08:20:53 <SamB_XP> what do you want it for anyway?
08:20:55 <bewo> theres a recvString but no recvFromString
08:21:02 <SamB_XP> hmm?
08:21:18 <bewo> im doing prototypes for various protocols at my company
08:21:48 <bewo> and ipv6 support is mandatory for all new deployments
08:21:55 <SamB_XP> oh, cool
08:22:20 <bewo> or, at least an upgrade path in foreseeable future
08:22:36 <allbery_b> we still don't have ipv6 support :(
08:22:51 <bewo> network-alt has it
08:22:59 <allbery_b> sorry, "we" as in CMU
08:23:05 <bewo> ko
08:23:06 <bewo> ok
08:25:19 <scodil> hey if i have an array-index-oob error, whats a good way to locate it? +RTS -xc just tells me <GHC.Arr.CAF> which isn't very helpful.
08:25:37 <emu> maybe they will do it in the "IP renumbering project"
08:26:13 <emu> @where LocH
08:26:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/loch.html
08:26:17 <SamB> scodil: you could try adding the -auto-all flag to your build commandline
08:26:25 <scodil> yeah i did that
08:26:48 <SamB> oh, wait.
08:27:02 <SamB> um, doesn't it also tell you other locations?
08:27:33 <scodil> no... which is what i don't get
08:27:38 <scodil> it's supposed to be a call stack
08:27:43 <SamB> wierd!
08:28:44 <SamB> bewo: well, I think you are welcome to submit a patch for IPv6 support, but maybe ask the library@ list first
08:29:29 <scodil> is there a good reason why the errors from library functions never give the offending value?
08:29:46 <scodil> would it be that hard to add ++ (show... to the error msg?
08:29:55 <emu> then they would req Show on all the parameters
08:29:57 <SamB> that would require the offending value to be in the Show class
08:30:22 <scodil> ok then
08:30:24 <emu> though, i suppose, the compiler could insert some magic regarding whether the data was in Show or not
08:30:26 <SamB> it would kinda be nice if there was a way to get something to be shown if possible...
08:30:40 <SamB> but probably that would do the wrong thing with newtyped stuff
08:33:22 <scodil> is short-circuiting defined for && and ||? like, is it guaranteed to try the left value first?
08:33:53 <allbery_b> short-circuiting is a given, I think:  laziness
08:34:13 <scodil> yeah but which does it try first
08:35:07 <allbery_b> > True || undefined
08:35:08 <lambdabot>  True
08:35:12 <scodil> cool
08:35:17 <scodil> undefined || True
08:35:21 <scodil> > undefined || True
08:35:22 <lambdabot>  Undefined
08:36:02 <emu> bottom is the only case where you could tell the difference, though
08:36:11 <glguy> True || _ = True; _ || b = b
08:36:31 <scodil> if (inRange (bounds a) i) && (a!i == ...)  then
08:36:43 <scodil> if you flip those you could get oob errors
08:36:52 <allbery_b> > False && undefined
08:36:53 <lambdabot>  False
08:37:14 <Vq^> is that defined in Haskell98?
08:37:20 <allbery_b> yeh, && and || pretty much need to be sequencing
08:39:20 <glguy> ?users
08:39:20 <lambdabot> Maximum users seen in #haskell: 309, currently: 272 (88.0%), active: 32 (11.8%)
08:39:32 <emu> sigfpe has a nice article on comonads
08:40:36 <scodil> i'm going to write a Monard class, and make it's only method wolfmanHas :: (Monard a) => a -> True
08:40:57 <glguy> scodil: You'll need fully dependent types for that one ;)
08:41:14 <sjanssen> or data True = ...
08:41:20 <scodil> i meant -> Bool
08:41:24 <scodil> you know what i meant
08:41:46 <glguy> actually, I don't get the joke (don't recognize the names) but I'm just having fun
08:41:55 <scodil> its from a stupid movie
08:42:04 <scodil> monster squad... i'm dating myself here
08:45:42 <emu> now i think code i wrote yesterday is comonadic
08:45:43 <emu> grr
08:52:56 <benmos> Hi - does anyone know if there's a standard library fn to expand -say- "~ben" to -say- "/users/ben" ? ... System.Directory.canonicalizePath doesn't seem to do that, and I couldn't see any other obvious candidates - just thought I'd check here before I do it by hand...
08:53:40 <glguy> I believe that that functionality is added at the shell level
08:53:58 <glguy> There isn't a standard C function for doing that, is there?
08:54:12 <benmos> hmm... good question - not sure off the top of my head
08:54:24 <norpan> yes, ~user and ~/ are shell-specific stuff (although a lot of applications handle them)
08:54:29 <benmos> ...ok, no problem - just wanted to check I wasn't about to reinvent the wheel
08:54:31 <benmos> thanks.
08:54:36 <emu> ghci is not one of those applications
08:54:46 <benmos> ok, thx
08:55:00 <emu> did I ever tell you about the time i nearly typed "rm -rf ~" because of Cabal?
08:55:38 <norpan> it's fun to make a file called ~ and make it read-only
08:56:13 <allbery_b> it's a shell thing but there are also quite a few programs that handle it as well (emacs, for one)
08:56:23 <emu> actually, not sure how the shell expands ~, because i had typed it as a --prefix= argument
08:56:38 <allbery_b> bash, at least, will expand ~ after =
08:56:42 <allbery_b> zsh can be told to
08:56:47 <emu> i was using bash
08:56:48 <norpan> just try with echo
08:56:51 <allbery_b> csh I don't recall at this point
08:56:54 <norpan> echo a=~
08:56:55 <scodil> i've got a function that's blowing up the stack, but how do I tell what part of it is the culprit? its not recursive, and it just has a few maps, a minimumBy and a zip
08:57:13 <emu> scodil: no folds?
08:57:25 <scodil> no
08:57:31 <scodil> unless minimumBy is a fold
08:57:37 <scodil> which it probably is
08:57:41 <glguy> > map join $ mapM ((:[[]]).(:[])) [1..3]
08:57:42 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
08:57:43 <emu> but it should be ok since internal
08:58:45 <bewo> did you check the 'glob' call (man 7 glob)?
08:59:40 <allbery_b> glob(7) is not entirely portable, and on many systems that have it it doesn't handle ~
08:59:46 <glguy> > map catMaybes $ mapM (\x->[Nothing,Just x]) [1..3]
08:59:48 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
09:00:02 <allbery_b> perl used to call out to csh to do globbing in order to get ~
09:00:12 <bewo> allbery_b: sure, its a very old system call
09:00:15 <allbery_b> (eventually they rewrote it internally)
09:00:35 <allbery_b> it's an old BSD call that didn't get blessed into a formal standard, so coverage is a bit iffy
09:01:10 * glguy check
09:01:11 <glguy> The glob() and globfree() functions first appeared in 4.4BSD.
09:01:11 <allbery_b> and t's not always in section 7, in fact I would expect it to be in section 3 (as on my macmini)
09:01:27 <glguy> glob is in section 3 on OpenBSD
09:01:33 <bewo> 7 is the wildcard syntax (which doesnt include ~)
09:01:35 <glguy> (library functions)
09:01:36 <allbery_b> it will be on linxu and *BSD, macos (freebsd libs), possibly solaris
09:01:37 <bewo> 3 is the system call
09:01:47 <allbery_b> oh.  that will definitely vary
09:02:05 <glguy> 2 is system calls
09:02:10 <glguy> (again, openbsd)
09:02:14 <allbery_b> BSDish manpages often use section 7, AT&Tish ones will use section 4 or 5 depending
09:02:35 <bewo> the nice thing about standards is that you can choose from a large number
09:02:37 <Vq^> my glob(3) manpage says: CONFORMING TO POSIX.2, POSIX.1-2001.
09:02:53 <allbery_b> (BSD puts kernel drivers in 4, AT&T likes to put them in 7)
09:03:37 <glguy> 1. general 2. system 3. library 4. drivers 5. fileformats 6. games 7. misc 8. maint-commands 9. kernel (if anyene cared about obsd (= )
09:03:39 <bewo> i think the glob command was present on SVR4
09:03:45 <allbery_b> huh.  okay, so they eventually added it in,
09:04:03 <allbery_b> SVR4 would have probably had it because of the BSD+SysV merger stuff.
09:04:30 <bewo> its more than 10 years i sat in front of SysVR4, so i might rememebr it wrong
09:04:37 * allbery_b admits his POSIX fu is mostly stuck in pre-2000 era
09:04:57 * allbery_b doesn't think there's been a real SysVR4 in a while :)
09:05:43 <bewo> we had the source as an OEM
09:06:10 <allbery_b> Solaris would have it, but Solaris diverged from SVR4 unofficially from the start and officially after they bought the license out
09:06:51 <bewo> we had the dubious pleasure to build kernel drivers for several systems that claimed to be SysVR4 compatible
09:07:07 <bewo> we ended up with huge macro libraries
09:07:56 <allbery_b> so, so not surp[rised
09:08:14 <bewo> that experiences makes you look for better languages
09:09:09 <allbery_b> better languages might not help; "Fortran code can be written in any language" (as a certain someone has been demonstrating on -cafe of late :)
09:10:30 <bewo> and you can have memory leaks even with garbage collection
09:11:43 <geckosenator> well you could detect the leaks
09:11:56 <syntaxfree> http://steve-yegge.blogspot.com/2006/12/parabola.html
09:11:58 <lambdabot> Title: Stevey's Blog Rants: Parabola
09:12:43 <syntaxfree> that's a big attack on type-safe languages.
09:12:55 <bewo> well, if you inadvertently let you lists grow, you have a leak
09:12:58 <Philippa_> geckosenator: no more than you can detect non-terminating code
09:13:10 <bewo> but its of course much better than the c family
09:14:21 <edi> @scheck (\a b c -> (a || b) && (a || c) == (a || (b && c)))
09:14:22 <lambdabot>   Failed test no. 7. Test values follow.: False, False, True
09:14:23 <bewo> and i was amazed that - at least in ocaml - you can happily do real-time voice applications with GC
09:14:52 <geckosenator> Philippa_: well I can look at some code and know for sure it won't terminate
09:15:51 <pejo> bewo, it's not impossible to make a deterministic gc with a bound on when it's interruptible.
09:16:43 <bewo> yes, but after all warnings about slow GCs, i was amazed that it ran out of the box
09:17:04 <benmos> @pl (\a -> \b -> (a=='~')==(b=='~'))
09:17:05 <lambdabot> (. ('~' ==)) . (==) . ('~' ==)
09:17:36 <bewo> are there any experiences about haskell in (near) real-time applications?
09:17:46 <emu> generational collection is generally quite zippy
09:17:50 <hyrax42> syntaxfree: you had time to read that?
09:21:47 <syntaxfree> hyrax42: yes.
09:21:53 <hyrax42> wow
09:21:58 <pejo> bewo, slow doesn't mean unpredictable, just means you can't have too short deadlines.
09:22:08 <hyrax42> I just read comments, seems more an attack on shitty type systems?
09:22:45 <emu> hyrax42: that would seem to make sense, given the authors flirting with caml and haskell
09:22:48 <syntaxfree> the comments try to spin it so.
09:23:05 <hyrax42> either way, I don't have an hour to waste
09:23:06 <syntaxfree> I can see Haskell fit in the story told, though.
09:23:42 <syntaxfree> it took me about five minutes to read it. it's not such a long story.
09:23:42 <bewo> pejo: the 'general wisdom' is that GC cant be used with RT, outside of academia
09:24:22 <emu> most general purpose systems don't come with incremental or RT GCs
09:24:44 <pejo> bewo, the general wisdom is that functional languages can't be used to write real programs.
09:24:57 <mahogny> pejo, go die
09:25:00 <mahogny> haskell rules
09:25:06 <emu> lol
09:25:10 <Lemmih> Bad timing (:
09:25:17 <emu> out-of-context wins
09:25:17 <geckosenator> i think gc is faster
09:25:26 <scodil> does +RTS -p significantly change the runtime behave of a program? i get stack overflows when I use it, and heap thrashing when I don't
09:25:31 <geckosenator> it would take more time to keep track of what to free and when
09:25:33 <bewo> pejo: :-)
09:25:33 <mahogny> I've even coded allegro in functional languages. works nicely
09:25:43 <emu> scodil: hm it could.  try also increasing space size if GC thrashes
09:25:47 <emu> scodil: -H<size>
09:26:05 <pejo> mahogny, tunes.org/~nef/logs/haskell/, read the context.
09:26:13 <mahogny> hm
09:26:33 <pejo> emu, but heh, yeah, I'm stumped. ;)
09:27:21 <mahogny> ok :)
09:27:21 <emu> geckosenator: GC can be faster, because it is generally able to perform optimizations which manual memory management /usually/ cannot do
09:27:42 <emu> geckosenator: for example, copying GC tends to be very good at cache-coherency
09:27:48 <geckosenator> oh ok
09:28:01 <glguy> > L.swing (&&) (=='~')
09:28:02 <lambdabot>  <Char -> Char -> Bool>
09:28:06 <emu> if you play around with parameters you can see this in action -- sometimes increasing the memory space decreases performance
09:28:35 <emu> while setting it to equal cache-size can cause the GC time% to go up, your overall real-time goes down
09:28:54 <gour> Tim Sweeney in his presentation/slides was speaking favourably about haskell as potential language for game development. i see that Lives (http://lives.sourceforge.net/) program for video editing uses Python (besides) C, so I wonder if one could get right speed (by using external C-libs where appropriate) in writing video-application like Cinelerra (http://www.heroinewarrior.com/cinelerra.php3) in Haskell ?
09:28:55 <lambdabot> Title: LiVES Video Editing System - Because the media should be open
09:29:03 <geckosenator> well sometimes you need more memory than the cache size anyway
09:29:20 <emu> geckosenator: indeed. there is no perfect solution for memory management.
09:30:03 <emu> geckosenator: functional programming language implementations tend to generate a lot of very short lived garbage.. that's why generational GC is popular
09:30:05 <mahogny> why oh why does live feel like a premier rip-off...
09:30:09 <geckosenator> if there is no gc, I find myself using free lists to speed things up
09:30:35 <geckosenator> emu: oh, right I implemented a generational collector
09:30:52 <geckosenator> it saved like 2% at each generation on average
09:30:55 <emu> sometimes ghc seems to generate so much garbage i wonder ... in excess of several gigabytes oO, but it still runs fast
09:31:32 <syntaxfree> what's the definition of (>>=) in terms of join?
09:32:07 <mwc> isn't the type of join :: Monad m => m (m a) -> m a
09:32:20 <sjanssen> @type \m f -> join (fmap f m)
09:32:21 <edi> (>>= id)
09:32:21 <lambdabot> forall (f :: * -> *) a a1. (Monad f, Functor f) => f a1 -> (a1 -> f a) -> f a
09:32:29 <mwc> @type join
09:32:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
09:32:41 <emu> ^ why monads should be functors
09:32:44 <monochrom> morning, afternoon, evening
09:32:49 <edi> night.
09:32:58 <tibbe> monochrom, evening
09:33:09 <monochrom> sweet dream.
09:33:23 <sjanssen> @pl \m f -> join (fmap f m)
09:33:24 <lambdabot> (join .) . flip fmap
09:33:55 * SamB wonders what kind of herb tea to take for a sore throat
09:34:19 <monochrom> Ricola. (not a herb tea)
09:34:23 <syntaxfree> just take anything warm.
09:34:30 <syntaxfree> ordinary black tea should suffice.
09:34:36 <mwc> hmmm
09:34:36 <mwc> Djinn> return :: a -> m a
09:34:37 <mwc> Djinn> join :: m (m a) -> m a
09:34:37 <mwc> Djinn> bind ? m a -> (a -> m b) -> m b
09:34:37 <mwc> -- bind cannot be realized.
09:34:48 <mwc> SamB, mint is your friend
09:35:14 <SamB> mwc: I thought maybe but all it says on the box is basically "nice way to waste time and remember holidays"
09:35:21 <tibbe> SamB, red tea is nice in the evening
09:35:39 <mwc> SamB, mint contains menthol which is nice on sore throats
09:35:45 <SamB> ah, true
09:36:07 <mwc> ginger => sore stomach, mint => throat, pepper => nose
09:36:13 <mwc> if I recall my herbology correctly
09:36:18 * SamB thought they used to put more actual information on these boxes
09:36:35 <mwc> I have a Chinese friend who swears on ginger tea (basically, boil fresh ginger in water) for cold/flu though
09:36:58 <mwc> syntaxfree, judging by my playing around with Djinn, I don't know if there is a definition
09:37:06 <mwc> or rather, if there is, I'm missing an obvious requirement
09:37:43 <emu> i like ginger tea a lot actually
09:37:47 <emu> but i usually get orange
09:38:01 <mwc> aha, we need map as well
09:39:13 <SamB> @djinn bindLL :: (a -> m a) -> (m (m a) -> m a) -> (m a -> (a -> m b) -> m b)
09:39:13 <lambdabot> Cannot parse command
09:39:21 <SamB> @djinn (a -> m a) -> (m (m a) -> m a) -> (m a -> (a -> m b) -> m b)
09:39:22 <lambdabot> -- f cannot be realized.
09:39:23 <sjanssen> mwc, syntaxfree: the definition is \m f -> join (fmap f m)
09:39:38 <mwc> sjanssen, yeha, I found it too
09:39:46 <syntaxfree> thanks!
09:39:48 <SamB> @djinn (a -> m a) -> (m (m a) -> m a) -> ((a -> b) -> (m a -> m b)) -> (m a -> (a -> m b) -> m b)
09:39:49 <lambdabot> -- f cannot be realized.
09:39:52 <SamB> hmm.
09:40:01 <mwc> I added a definition for map :: (a -> b) -> (m a -> m b) to djinn, and it still can't find join :(
09:40:05 <SamB> what did I do wrong?
09:40:07 <sjanssen> SamB: djinn doesn't know what m is
09:40:14 <SamB> sjanssen: so?
09:40:29 <allbery_b> SamB: I think sometimes they remove it now because otherwise the FDA forces them to put big disclaimers about "not intended to treat any illness or condition" (otherwise they have to get certified as a drug)
09:40:34 <sjanssen> oh, I suppose that's complete enough to infer anyway
09:40:38 <one> sorry, a stupid question - is it possible to build jhc from cygwin?
09:40:53 <SamB> shouldn't it just say "not certified" or something?
09:41:03 <SamB> anyway that should not apply to well-known herblore
09:41:42 <syntaxfree> I'm entranced by comonads.
09:41:46 <emu> what, FDA apply common sense?
09:42:04 <SamB> emu: you have a point
09:42:07 <emu> syntaxfree: are you reading his tutorial on them?
09:42:18 <sjanssen> SamB: djinn can't infer the type because of the placement of the implicit forall
09:42:20 <emu> er, sigfpe
09:42:59 <sjanssen> it can't generalize ((a -> b) -> (m a -> m b)) to (a -> m b) -> m a -> m (m b)
09:43:15 <SamB> oh.
09:43:16 <SamB> eek.
09:44:17 <sjanssen> in fact, performing that generalization would be illegal in Haskell
09:44:32 <allbery_b> actually, the point is that *if* they claim to treat an illness, they are required to get safety and efficacy certifications, including running wide scale clinical trials etc.
09:44:34 <SamB> @djinn (m a -> (a -> m b) -> m b) -> (a -> m a) -> (m (m a) -> m a)
09:44:35 <lambdabot> -- f cannot be realized.
09:44:41 <SamB> sjanssen: isn't that a specialization?
09:44:55 <sjanssen> SamB: yes, you're right
09:45:17 <SamB> allbery_b: haven't we already got large scale clinical trials for herbal tea safety done?
09:45:35 <syntaxfree> emu: whose tutorial?
09:45:40 <SamB> they could just say "romoured to [blah blah blah]
09:45:47 <syntaxfree> I'm playing with sigfpe's CA code.
09:45:58 <allbery_b> not officially and not usefully by FDA requirements, and that's only one aspect of it
09:46:09 <emu> yea, i found a link to an earlier "tutorial" on them too, he wrote in June
09:46:15 <SamB> FDA are teh idiots
09:46:17 <syntaxfree> oh.
09:46:22 <syntaxfree> didn't see it!
09:46:29 <monochrom> spreading rumours is unethical.
09:46:29 <emu> http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
09:46:30 <allbery_b> basically, someone *could* jump through the hoops, and in the case of some herbal teas possibly do so successfully --- but it's far cheaper to either print a disclaimer or omit mention of the beneficial effects
09:46:32 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
09:46:37 <SamB> monochrom: no it isn't
09:46:43 <SamB> that is gossip you are thinking of
09:46:50 <allbery_b> it's more the fault of lawyers and drug companies, I think
09:47:04 <SamB> FDA are teh bought
09:47:06 <SamB> ?
09:47:34 <allbery_b> (IIRC it was St John's Wort that pushed them over the edge, the drug companies got scared)
09:47:57 <monochrom> I don't believe this conspiracy theory.  I am a scientist.  I swear by that the burden of proof is still on the herbal tea maker.
09:48:01 <allbery_b> possible.  but also possible they're acting as a buffer, saving the herbal companies from being sued into the ground
09:48:09 <allbery_b> by giving them a way out
09:48:24 <monochrom> And so the FDA is right in imposing almost impossible conditions.
09:48:37 <allbery_b> and setting guidelines which give them that out with a guarantee they can't be sued by e.g. pfizer if they heed them
09:48:41 <tibbe> -> #blah please :)
09:49:31 <SamB> monochrom: it should not be necessary to offer a proof in order to sell damn herb tea with notes on the side about traditional uses!
09:50:26 <monochrom> traditions may be wrong too.
09:50:30 <SamB> true
09:50:54 <monochrom> there was a great tradition of labeling women with traditional uses.
09:51:09 <SamB> strange comparison there
09:51:23 <SamB> tea is not self-aware -- probably not, anyway
09:51:38 <monochrom> I like strange comparisons.
09:52:00 * Codex_ prefers coffee...
09:52:19 <monochrom> "rumoured to relieve ____" is downright irresponsible.
09:53:23 <SamB> you probably wish compare :: (Ord a, Ord b) => a -> b -> Odering ;-P
09:53:28 <SamB> er.
09:53:32 <SamB> spelled properly
09:54:26 <monochrom> If you want to help herbs, the scientific thing to do is to help raise funds to fund clinical trials.
09:55:15 <SamB> uh huh
09:55:31 <SamB> I don't think scienciness should be enforced by the government...
09:55:42 <SamB> (isn't that against the seperation of church and state?)
09:55:48 <sjanssen> so . . . #haskell-blah?
09:55:53 <scodil> truthiness should, though
09:56:03 <SamB> scodil: truthfulness is better
09:56:11 <SamB> anyway, I want to stop talking about this
09:56:14 <SamB> it makes me mad
09:56:51 <scodil> ok, instead lets talk about why this eats up so much time and space: angleBetween (Rot3 a0 a1 a2 a3) (Rot3 b0 b1 b2 b3) = 2*acos( a0*(-b0) + a1*(-b1) + a2*(-b2) + a3*(-b3) )
09:57:12 <SamB> what does Rot3 mean?
09:57:17 <scodil> quaternion
09:57:23 <SamB> ah.
09:57:34 <SamB> what is the definition?
09:57:45 <sjanssen> scodil: here's a potentially magic solution: add strictness annotations in Rot3
09:57:47 <SamB> of Rot3?
09:57:49 <scodil> its a constructor, may as well be tuples
09:57:57 <SamB> scodil: add !s
09:58:03 <SamB> that should help muchly
09:58:06 <sjanssen> and UNPACK pragmas, or compile with -funbox-strict-fields
09:58:24 <norpan> muchly!
09:58:25 <syntaxfree> emu: that Control.Comona module should really use sigfpe's names (cojoin, coreturn)  rather than "extract, duplicate", etc.
09:59:07 <scodil> can I add the UNPACK pragma at the definition of the function? or do I have to do it for the whole Rot3 class?
09:59:20 <scodil> er, type i mean
09:59:21 <SamB> okay, so, does anyone know offhand why we don't have IPv6 support in the standard libraries?
09:59:33 <sjanssen> scodil: unpack is at the data defn.
09:59:33 <SamB> scodil: type
09:59:44 <norpan> SamB: do we have IPv4 support?
10:00:02 <SamB> I meant Network.Socket
10:00:29 <sjanssen> data Rot3 = Rot3 {-# UNPACK #-} !Double {-# UNPACK #-} !Double ...
10:00:32 <norpan> that has ipv6 support, hasn't it
10:00:47 <SamB> norpan: has it now?
10:01:05 <tibbe> sjanssen, what's the difference between ! and UNPACK?
10:01:11 <norpan> i think so
10:01:15 <norpan> haven't tried it though
10:01:29 <bewo> no, it hasnt. only network-alt supports ipv6
10:01:47 <bewo> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
10:01:51 <lambdabot> Title: network-alt
10:01:57 <bewo> but it has other flaws
10:02:06 <sjanssen> tibbe: ! means strict, UNPACK means to include the contents of a constructor directly
10:02:21 <norpan> the answer to the question is probably that no-one has coded it up yet
10:02:37 <sjanssen> so instead of containing a pointer to a double in the data type, you have an unboxed double
10:02:42 <SamB> norpan: it does not support IPv6 addresses...
10:02:49 <tibbe> sjanssen, I thought ! did that
10:03:04 <tibbe> sjanssen, does it only force evaluation of the thunk?
10:03:16 <SamB> does windows support the standard API for IPv6 properly?
10:03:24 <sjanssen> tibbe: yes, it only evaluates the thunk
10:04:01 <Lemmih> Greetings alexj__.
10:04:13 <sjanssen> ! tells the compiler to insert seq's wherever the constructor is used
10:04:15 <bewo> i would think so. some top ipv6 proponents in the IETF work for microsoft
10:04:30 <tibbe> sjanssen, will the compiler UNPACK automatically sometimes or is it impossible because of _|_?
10:04:37 <emu> syntaxfree: where does it use extract,duplicate?
10:04:51 <emu> syntaxfree: also he uses "<<=" at one point instead of "cobind"
10:05:09 <scodil> can you unpack polymorphic fields?
10:05:10 <sjanssen> tibbe: the compiler could unpack automatically, it's semantically the same
10:05:23 <sjanssen> tibbe: GHC doesn't do this though, I'm not sure why
10:06:10 <sjanssen> unpack automatically when there is a strict data field, that is
10:06:27 <tibbe> sjanssen, is it really the same?
10:06:42 <scodil> is anything _really_ the same?
10:07:03 <tibbe> sjanssen, I mean if I pattern match on something that is unpacked will I not hit _|_ if the data constructor is included but not if it's not?
10:07:37 <tibbe> i.e. I do (Foo a) pattern match where a is a data type that is unpacked that contains _|_?
10:07:48 <scodil> i think it will re-box the value in cases like that, which will be slower, and thats why it doesn't unbox automatically
10:07:50 <tibbe> data constructor*
10:07:56 <allbery_b> unpacking requires strictness, strictness prohibits _|_
10:08:12 <tibbe> right
10:08:37 <ulph> is it an error to do {-# UNPACK #-} without the '!'?
10:09:00 <scodil> it will just ignore it probably
10:09:20 <scodil> like if you ask it to inline a recursive function
10:09:38 <geckosenator> in haskell?
10:09:53 <geckosenator> i know gcc can inline recursive functions
10:09:58 <scodil> wtf?
10:09:59 <scodil> how?
10:10:08 <geckosenator> it unrolls the inline
10:10:17 <scodil> how does it know when to stop?
10:10:22 <geckosenator> er unrolls the recursion
10:10:26 <geckosenator> same as unrolling a loop
10:10:40 <allbery_b> I think it rewrites the recursion as a loop and then unrolls the loop as much as it can
10:10:52 <geckosenator> allbery_b: that would make sense
10:11:01 <allbery_b> there's a configurable limit to how much unrolling it'll do
10:12:05 <allbery_b> (not easily confiugrable, though:  besides the on/off (-funroll-loops) there's a knob to specify how much memory to use on those optimizations)
10:12:53 <scodil> so you're saying that gcc does tail-recursion optimization
10:13:24 <allbery_b> last I checked it did
10:13:30 <allbery_b> in at least some cases
10:14:28 <ptolomy> @pl let goo x = (show x, x)
10:14:29 <lambdabot> (line 1, column 24):
10:14:29 <lambdabot> unexpected end of input
10:14:29 <lambdabot> expecting variable, "(", operator, ";" or "in"
10:14:38 <ptolomy> @pl lgoo x = (show x, x)
10:14:39 <lambdabot> lgoo = (,) =<< show
10:15:10 <ptolomy> @pl lgoo x = (show x, x+1)
10:15:11 <lambdabot> lgoo = liftM2 (,) show (1 +)
10:15:15 <scodil> ok I've got -funbox-strict-fields, !'s on all my fields and {-#UNPACK#-} pragmas, and I still get tons of alloc on my acos/dot-product function
10:15:26 <scodil> is it because Rot3 is polymorphic in the field type?
10:15:37 <scodil> data Rot3 s = Rot3 s s s s
10:16:36 <ptolomy> using "liftM2 (,) f1 f2" is unreasonably obscure, yes?
10:17:37 <allbery_b> most of @pl's output is unreasonably obscure IMO :)
10:17:54 <dylan> @hoogle IO a -> FunPtr b
10:17:55 <lambdabot> No matches, try a more general search
10:18:01 <dylan> hmm.
10:18:11 <dylan> any way of getting a FunPtr to a haskell IO action? :)
10:18:37 <Grey-z> got stuck and would appreciate help: delAll :: Eq a => a -> [a] -> (Bool,[a])
10:19:14 * syntaxfree is doubly entranced by comoands.
10:19:22 <Grey-z> delAll x xs if x is in xs result would be (True, ys) where ys is xs with x elements removed
10:20:07 <Grey-z> and please use foldr
10:20:10 <syntaxfree> allbery_b St. John's Wort?
10:20:26 <tibbe> > partition (== 1) [1,2,3]
10:20:28 <lambdabot>  ([1],[2,3])
10:20:42 <allbery_b> @quote fishkandy
10:20:42 <lambdabot>  xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
10:20:57 <ptolomy> It seems like I often find myself doing " helperFunction x = ( fun1 x, fun2 x ) "... is there a reasonable built-in/idiom for "here is a tuple of functions, apply them all to a value and return a tuple of the results." ?
10:21:28 <syntaxfree> you can wrie one for a 2-tuple. It won't be generalizable for an n-tuple, though.
10:21:33 <tibbe> > case partition (== 1) [1,2,3] of; ([], ys) -> (False, ys); (_, ys) -> (True, ys)
10:21:35 <lambdabot>  (True,[2,3])
10:21:44 <tibbe> > case partition (== 1) [1,2,3] of; ([], ys) -> (False, ys); (_, ys) -> (True, ys)     -- Grey-z
10:21:46 <lambdabot>  (True,[2,3])
10:21:47 <allbery_b> it was in the news a year or so back, research demonstrated antidepressant effects similar to many antidepressant drugs
10:21:47 <tibbe> but no foldr
10:21:58 <syntaxfree> m-tuples and n-tuples, for m/=n are different types. a general n-tuple map would not be typeable.
10:22:07 <Grey-z> thanks now I have something to translate to foldr
10:22:34 <ptolomy> allbery_b: IIRC, that was preliminary research with bad controls.. later larger and better-controlled studies showed no significant effect.
10:23:20 <allbery_b> sure, but most people never saw that research
10:23:37 <allbery_b> so St John's Wort is still rather popular
10:23:39 <Grey-z> I need something cooler, like one list review
10:23:49 <ptolomy> True.
10:23:49 <tibbe> don't bring it up again please! :)
10:23:54 <syntaxfree> I remember my sister taking St John's Wort along with her prozac.
10:24:16 <allbery_b> risky, that
10:24:38 <syntaxfree> the psychiatrist precribed both.
10:28:01 * allbery_b would have switched psychologists --- there was some stuff about interactions between SJW and SSRIs
10:28:57 <scodil> so can anybody tell me if type polymorphism affects constructor field unpacking?
10:29:03 <scodil> effects, whatever
10:29:07 <Philippa_> ologist != iatrist. A psychologist can be excused not knowing it, whereas a psychiatrist is a doctor who prescribes stuff...
10:29:35 <Philippa_> and over here at least SSRIs all specifically say in the accompanying leaflet not to take SJW with them
10:29:46 <allbery_b> sorry, wrong one
10:30:07 <allbery_b> trying to do too manyt hings at once, and sill brainfuzzed (something about cold fronts, meh)
10:30:18 * dylan imagines having iatrists for other professions other than psych...
10:31:10 <SamB_XP> what would a biiatrist do?
10:31:12 <syntaxfree> Anyway, my sister has since dropped all drugs and moved to another country.
10:31:23 <dylan> SamB_XP: what would a neuriatrist do?
10:31:47 <SamB_XP> um, prescribe micromachines?
10:31:50 <syntaxfree> I'm considering getting tested for something along the lines of Asperger's.
10:32:13 <SamB_XP> @all-dict neurologist
10:32:16 <syntaxfree> I'm afraid pretty much any psychiatrist I know will waste months on end testing for various forms of depression, bipolar disorder, etc.
10:32:17 <lambdabot> *** "Neurologist" gcide "The Collaborative International Dictionary of English v.0.48"
10:32:17 <lambdabot> Neurologist \Neu*rol"o*gist\, n.
10:32:17 <lambdabot>   One who is versed in neurology; also, one skilled in the
10:32:17 <lambdabot>   treatment of nervous diseases.
10:32:19 <lambdabot>   [1913 Webster]
10:32:21 <lambdabot> [16 @more lines]
10:32:23 <SamB_XP> @all-dict neurology
10:32:24 <lambdabot> *** "Neurology" gcide "The Collaborative International Dictionary of English v.0.48"
10:32:25 <lambdabot> Neurology \Neu*rol"o*gy\, n. [Neuro- + -logy.]
10:32:27 <lambdabot>   The branch of science which treats of the nervous system.
10:32:29 <lambdabot>   [1913 Webster]
10:32:31 <lambdabot>  
10:32:33 <lambdabot> [6 @more lines]
10:32:34 <SamB_XP> okay, yes, I got it right.
10:32:47 <SamB_XP> someone who prescribes micromachines, yes. ;-P
10:33:21 <SamB_XP> (to repair damaged nerves)
10:33:34 <SamB_XP> (and stuff like that)
10:34:58 <dylan> I'm fairly certain I'd be classed as having some mental disorder, but nothing seems to impair my day-to-day life or happiness. ;)
10:35:13 <scodil> you have terminal denial
10:35:32 <dylan> I actually I have antidepression.
10:35:36 <scodil> hah
10:35:44 <dylan> *I actually think.
10:35:55 <scodil> take two (pints) of these depressants all call me in the morning
10:35:55 <syntaxfree> I'm going through some personal troubles right now, so I'm thinking of taking the chance to reevaluate really what's unusual about me.
10:36:06 <syntaxfree> When I'm damn happy, I can't seem to navel-gaze for long.
10:37:14 <dylan> is aspergers something that is actually treated, anyway? I thought meds were only for more malfunctional forms of autism?
10:38:17 <syntaxfree> Dunno. It'd be nice to have a closed-form diagnosis, anyway.
10:38:30 <allbery_b> "antidepression" --- DSM-IV calls that "mania", no?
10:38:31 <syntaxfree> I'm actually quite functional. I'm just a hopeless slacker.
10:38:45 <syntaxfree> mania != "being overly happy".
10:39:02 <dylan> I don't mean overly happy.
10:39:07 <syntaxfree> a friend's mom has bipolar disorder. In manic episodes, she'll go out with garish makeup  and hug strangers.
10:39:27 <dylan> I just don't seem to be able to feel bad about the world no matter how horrible things are. Something good is always bound to happen.
10:39:57 <glguy> Do any of you know of people who think that they see the number 23 everywhere?
10:40:01 <syntaxfree> I felt like that until two weeks ago.
10:40:17 <syntaxfree> Like something good was always bound to happen, and anything wrong can easily be fixed anyway.
10:40:29 <syntaxfree> glguy: @wikipedia 23 Skiddoo
10:40:39 <syntaxfree> is @wikipedia a command?
10:40:44 <scodil> is there a way to find out exactly where memory is going? not just which functions, but which values?
10:40:55 <glguy> might not be, but I'm on that page already anyway
10:40:59 <syntaxfree> anyway. http://comments.gmane.org/gmane.comp.lang.haskell.cafe/815
10:41:01 <syntaxfree> oops.
10:41:02 <lambdabot> Title: gmane.comp.lang.haskell.cafe
10:41:06 <syntaxfree> http://en.wikipedia.org/wiki/23_skiddoo
10:41:26 <SamB_XP> I think @wikipedia used to search wikipedia, but it broke
10:42:30 <syntaxfree> odd, given that wikipedia never changed URI schemes.
10:42:59 <monochrom> scodil: does profiling help?
10:43:00 <syntaxfree> it's always [lang].wikipedia.org/wiki/[intersperse '_' $ words string]
10:43:38 <SamB_XP> I said *search*
10:43:47 <scodil> monochrom: it tells me that a certain function is using 70% of the memory, but it doesn't say any more
10:43:57 <SamB_XP> not "go to named article"
10:44:34 <SamB_XP> scodil: +RTS --help
10:44:48 <syntaxfree> well, wikipedia search is still the same, too.
10:45:06 <SamB_XP> @wikipedia galois field
10:45:08 <lambdabot> No Result Found.
10:45:15 <SamB_XP> @wikipedia lattice
10:45:17 <lambdabot> No Result Found.
10:45:24 <monochrom> Have you tried inserting cost centre annotations yourself?  (section 5.1.1 of ghc user guide)
10:45:28 <SamB_XP> nevertheless, it worketh not
10:45:52 <SamB_XP> monochrom: he said values, not cost centers!
10:45:53 <scodil> monochrom: no i'll check that. but first, i just discovered -Pa, so I'll try that
10:46:24 <syntaxfree> http://en.wikipedia.org/wiki/Special:Search?search=lattice&go=Go
10:46:27 <monochrom> well now I'm suggesting declaring certain values to be cost centres.
10:46:29 <syntaxfree> behold the search URI.
10:46:36 <sorear> vvv thus doesn't work either
10:46:42 <sorear> ?gwiki strictness
10:46:43 <lambdabot> No Result Found.
10:47:11 <SamB_XP> syntaxfree: well, go look in the Plugin.Search (I think that is what it is called now?) and see if it uses that
10:47:50 <SamB_XP> also, that code is intended for "I'm feeling lucky", not "Go" or "Search", queries
10:48:35 <SamB_XP> monochrom: I think he wanted to know what *kinds* of heap objects were taking up the memory
10:58:38 <scodil> i just want to know what to change so that it won't blow up
10:58:59 <scodil> the function that's doing it, its basically finding the best thing out of a list of 24 things
10:59:06 <scodil> i wouldn't think that would do it
10:59:17 <scodil> it boils down to a minimumBy
11:00:02 <monochrom> It may be called multiple times.  The callers may be holding on to the results forever.
11:00:08 <scodil> but i figured maybe, since its probably a foldl internally, that it could use some extra strictness, so i did a stateful function that scans the list and updates IORefs to find the best one, but that was just as bad
11:00:37 <scodil> its called millions of times
11:00:49 <monochrom> Try to impeach the callers
11:01:01 <scodil> what does that mean?
11:01:13 <monochrom> scrutinize. prove them guilty.
11:01:50 <monochrom> or simplify the code and preserve the memory blowup and paste it :)
11:02:24 * monochrom >> lambdabot,  will analyse programs for food
11:02:47 <scodil> ok i annoted, and this expression (bound in a let) is the culprit : map (b `composeR`) rotEqClass
11:03:16 <scodil> composeR is quaternion composition, and rotEqClass is a CAF list with 24 quaternions in it
11:04:11 <scodil> wouldn't it get collected after the function to which its bound is done?
11:05:09 <monochrom> If you say "let x = map (b `composeR`) rotEqClass in blahblahblah", x is retained for quite a while.
11:05:15 <scodil> the second worst offender (half as bad) is the acos/dot-product function i posted earler. these two use about 90% of the memory
11:05:49 <scodil> what? why?
11:07:16 <monochrom> I had one case in which tweaking a garbage collection parameter (number of generations) changed O(oo) space to O(1) space.  Yes, just changing the number of generations used by the generational garbage collector.  The code was some variation of mapAccumL, had "let" and created and destroyed tuples.
11:07:55 <opqdonut> chaotic programming?-)
11:08:09 <monochrom> Then again, it was ghc 6.4.2
11:09:42 <scodil> so how am i supposed to write readable code without lets?
11:10:02 <opqdonut> scodil: use let .. in rather
11:10:19 <scodil> pardon?
11:10:28 <monochrom> I think you can keep lets.  Have you tried randomizing garbage collector parameters? :)
11:11:01 <scodil> not yet. i'm one-by-one manually inline the let-bindings in the function, to see if it even makes a difference
11:11:19 <scodil> inlining
11:11:44 <opqdonut> -finline-lets :P
11:11:52 <scodil> is that a flag?
11:11:55 <scodil> don't toy with me
11:12:04 <opqdonut> j/k nvm me
11:12:14 <scodil> -fmake-go-faster-please
11:12:27 <Stinger_> -fblack-magic
11:12:36 <monochrom> -fdisable-memoization
11:12:46 <opqdonut> -fkekek-optimize-rush
11:13:00 <Philippa_> -fno-killing-kittens has actually been suggested...
11:13:07 <opqdonut> :D
11:13:15 <Stinger_> what does that do? :P
11:13:30 <Saizan> it doesn't kill kittens i think :D
11:13:35 <scodil> monochrom: where you serious about that one?
11:13:39 <scodil> were
11:13:47 <monochrom> Yes, it is serious.
11:13:59 <monochrom> Oh oops, sorry.
11:14:19 <monochrom> I'm serious about changing GC parameters and get O(oo) to O(1).
11:14:27 <monochrom> I am not serious about -f flags.
11:14:35 <scodil> like, what parameters, specifically
11:14:38 <scodil> in your case
11:14:45 <monochrom> one sec
11:16:08 <scodil> i collapsed the function into one big nasty expression and it didn't change the behavior at all
11:16:10 <monochrom> Default is 2 generations.  I changed that to 1 or 0 (can't remember).  +RTS -G1
11:16:43 <pafcu> What would be the best way to count duplicate entries in a list?
11:17:16 <sorear> easy : length list - length (nub list)
11:17:43 <sorear> there might be a more idiomatic way, though...
11:17:44 <monochrom> the best way is to declare nothing is duplicate.
11:18:10 <emu> instance Eq a where a == a = False
11:18:25 <pafcu> sorear: Thanks
11:18:35 <sorear> uh, doesn't that violate the reflexivity proof obligation?
11:18:51 <emu> there's a lot of things that violates
11:19:09 <scodil> is the alloc in the profile output just heap alloc? or both heap and stack? cause i'm getting stack overflows
11:19:30 <sorear> it's symmetric and transitive - beyond reflexive, what isn't it?
11:20:42 <monochrom> I think it just reports heap.
11:21:01 <scodil> so how do I found out whats blowing up the stack?
11:21:30 <glguy> > let f (x:y:z) | x == y = 1 + aux (y:z) | otherwise = aux (y:z); f _ = 0 in f $ sort [1,2,3,4,2,3]
11:21:31 <lambdabot>  Not in scope: `aux'
11:21:34 <monochrom> things like foldl (+) and foldr (+) blow up the stack
11:21:41 <glguy> > let f (x:y:z) | x == y = 1 + f (y:z) | otherwise = f (y:z); f _ = 0 in f $ sort [1,2,3,4,2,3]
11:21:42 <lambdabot>  2
11:22:09 <kolmodin_> I can't manage to get my rules to fire properly (at all).. http://www.haskell.org/~kolmodin/code/bbs/src/Data/ByteString/Binary/EncM.hs
11:22:09 <glguy> -- in this case an accumulator woudl be appropriate though
11:22:10 <scodil> but how do i findout which one is doing it
11:22:10 <lambdabot> http://tinyurl.com/yxbo2u
11:22:23 <kolmodin_> I'd like a few hints :)
11:22:33 <sjanssen> tibbe: if you're still curious, GHC will report a parse error when UNPACK is used without a strictness annotation
11:22:38 <kolmodin_> the rules are at the bottom
11:22:38 <monochrom> I don't know.
11:22:47 <scodil> i've got two foldls, and they're both strict (foldl')
11:22:58 * sjanssen wouldn't have expected parse error, but meh
11:23:12 <Excedrin> http://programming.reddit.com/info/vg8z/comments unknown_lamer's comment is correct
11:23:14 <lambdabot> Title: Code Tells You How, Comments Tell You Why (reddit.com)
11:23:33 <glguy> > let dups xs = sum [1 | (x:y:z) <- tails $ sort xs, x == y] in dups [1,2,3,4,2,3]
11:23:34 <sjanssen> kolmodin_: you probably need NOINLINEs on the functions you want to match rules against
11:23:35 <lambdabot>  2
11:23:56 <kolmodin_> sjanssen: hmm
11:24:12 <glguy> Excedrin: I had already modded him +1
11:24:40 <kolmodin_> sjanssen: ok, I'll try that
11:24:42 <glguy> > let dups xs = length [() | (x:y:z) <- tails $ sort xs, x == y] in dups [1,2,3,4,2,3]
11:24:43 <lambdabot>  2
11:25:03 <sjanssen> kolmodin_: maybe look at Data/ByteString/FusionStream.hs for an example of rule staging
11:25:21 <kolmodin_> sjanssen: thanks
11:25:26 <Nafai> w00t!  My Craft of Functional Programming book came today...can't wait to get home to read it
11:26:50 <gour> Nafai: enjoy it. i like it very much
11:26:58 <monochrom> insert some Debug.Trace.trace, in hope that: (a) it doesn't change memory behaviour, (b) it helps find what the computer is computing when stack overflows
11:28:16 <monochrom> I personally would compositionally prove bounds on every function.
11:28:27 <scodil> and how would you do that
11:31:09 <monochrom> 0. insert trace at the beginning of main, to see that stack overflows after main starts.
11:31:45 <scodil> oh shit i think i found it. don't you hate it when you get all frustrated and you start thinking "haskell sucks! i'm going back to c++!" and then you realize you're a dumbass
11:32:05 <monochrom> I almost said that to Taral yesterday.
11:32:36 <Saizan> what it was?
11:32:54 <monochrom> except he was thinking hxt sucks, going back to haxml, but I proved that he were, ok, not a dumbass, just a programmer error on his part.
11:32:55 <kolmodin_> sjanssen: it looks like they in Fusion.hs wait with the inlining to phase [1]
11:33:14 <scodil> me? i was dfs-ing a cyclic graph and I forgot the bit where I filter out the neighbors that have been visited already
11:34:29 <vegai> Hmm, silly me. I've ignored a perfectly good Unix timestamp -based time values that have both Show and Read instances declared
11:34:56 <Stinger_> scodil : damn laziness making it actually work and not infinitely recurse? :)
11:35:00 <vegai> like someone would be using my software in 20 years.
11:35:02 * vegai chuckles.
11:35:31 <monochrom> and the perfectly good timestamp is the random generator seed?
11:35:38 <scodil> Stinger_: yeah totally. it worked for like the first 3 graphs and then crapped out, so i figured "well it works on some of em, so it can't be my algorithm..."
11:35:47 <allbery_b> experience say longest lived program is program written "just for now" :>
11:35:51 <CosmicRay> haha
11:36:04 <vegai> monochrom: No, keys for the blog Map we mentioned yesterday
11:37:25 <sjanssen> kolmodin_: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#phase-control might also be helpful
11:37:27 <lambdabot> Title: 7.10. Pragmas, http://tinyurl.com/y9jo69
11:38:13 <sjanssen> kolmodin_: note that the phase numbers decrease after each pass, so phase 2 happens before phase 1
11:38:39 <kolmodin_> sjanssen: I'm currently running on ghc 6.4.2 (although I've tried ghc 6.6 too). I'll try it on my ghc 6.6 box too
11:38:42 <kolmodin_> sjanssen: ah, good to know :)
11:44:12 <_matthew-> how fast is Haskell at bit-parsing and generation? If, say you were going to implement a client for some binary protocol.
11:44:34 <_matthew-> e.g., something like an asn.1 encoder/decoder - how fast can that be made to go?
11:45:10 <sjanssen> it'd probably have acceptable performance
11:45:35 <sjanssen> there are some problems though.  shifts aren't inlined as often as they could be, for example
11:45:42 <_matthew-> ah ha.
11:45:52 <Grey-z> I'm trying to implement reverse dropWhile with foldr
11:45:55 <Grey-z> dropWhileRev :: (a -> Bool) -> [a] -> [a]
11:46:27 <sjanssen> Grey-z: dropWhile is a little tricky with foldr :)
11:46:44 <Grey-z> it's a reverse one :P
11:46:54 <Grey-z> drops elements from end
11:47:34 <sjanssen> does it return the list in reverse order?
11:48:19 <Grey-z> let dropWhileRev p xs = foldr (\e l -> if p e then l else e:l) [] xs in dropWhileRev (<3) [1,2,3,2,1]
11:48:46 <sjanssen> that is filter
11:50:10 <Grey-z> yes and that's the problem. my mind is stuck at filter and I can't think past it
11:50:31 <_matthew-> so you'll have to pass a tuple through
11:50:52 <_matthew-> with one value which tells you if you've seen a failing of the predicate
11:51:09 <sjanssen> Grey-z: I have a solution, do you want to see it?
11:51:15 <sjanssen> or would a hint be better?
11:51:38 <Grey-z> it's late so show the solution :D
11:52:09 <sjanssen> @type let f p = foldr (\x xs -> if null xs && p x then xs else (x:xs)) [] in f
11:52:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:52:35 <sjanssen> > let f p = foldr (\x xs -> if null xs && p x then xs else (x:xs)) [] in f (<3) [1, 2, 3, 2, 1]
11:52:36 <lambdabot>  [1,2,3]
11:53:16 <Grey-z> thanks a lot sjanssen
11:53:46 <Grey-z> I was close. Whats is that null xs in between there?
11:54:21 <sjanssen> Grey-z: null xs returns True if xs is an empty list
11:55:17 <Grey-z> ok that makes sense to me now
11:55:27 <Grey-z> sjanssen: thanks again :)
11:55:47 <sjanssen> and if xs is null, then we know that all elements before x satisfy p
11:57:32 <Grey-z> that's really cool. It's like a whole new way of thinking compairing to my idea
12:00:08 <sjanssen> Grey-z: next time, try defining foldl via foldr
12:01:23 <allbery_b> hrm.  record syntax can't be strict?
12:01:48 <monochrom> you can have strict fields
12:02:18 <monochrom> you can use "case" to force the record constructor
12:02:59 <allbery_b> hm.  I got a syntax error declaring Foo {!a :: Int, ...}, and reading the Report suggested that strictness could only happen using record syntax on a non-record-style type
12:02:59 <sjanssen> allbery_b:  data Foo = F {f :: !Int}
12:03:03 <allbery_b> ah
12:03:06 <allbery_b> thanks
12:03:17 <monochrom> RTFM :)
12:03:35 <monochrom> oh, you already did.
12:03:44 <monochrom> get a new pair of glasses :)
12:04:39 <allbery_b> apparently
12:05:37 <allbery_b> I deferred digging to find the actual BNF and thus hit a comment about _|_ only relating to use of F {} on a non-record-syntax F (which I apparently misunderstood)
12:06:26 <allbery_b> er, strict fields, not _|_
12:07:21 <Nanar> Hi
12:07:33 <opqdonut> lo
12:07:46 <Nanar> what is the best way to test the end of a string is another string
12:08:06 <Nanar> ie I want to filter files ending by ".cabal"
12:08:17 <sorear> ?hoogle isSuffixOf
12:08:18 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
12:08:27 <Nanar> sorear: thanks
12:08:45 <sorear> wait... since when does ?hoogle use the flat compatibility libs?
12:09:52 <sjanssen> Nanar: as sorear hints, you should import Data.List rather than List
12:10:14 <kolmodin_> sjanssen: rules and inlining is magic
12:10:22 <kolmodin_> sjanssen: that's my conclusion
12:10:25 <Nanar> sjanssen: ok
12:10:30 <Nanar> sjanssen: thanks
12:10:32 <sjanssen> kolmodin_: no success?
12:10:38 <kolmodin_> yeah, some :)
12:10:48 <sjanssen> it is also possible that >> is being inlined
12:11:03 <kolmodin_> rules fire on different places with different inlining
12:11:16 <kolmodin_> that's why I define >> as bEncM and control its inlining
12:12:31 <kolmodin_> mostly I'm conserned about the writeN/combine rule as it is used a lot
12:12:36 <kolmodin_> or should be..
12:20:12 <kolmodin_> sjanssen: if I inline with {-# INLINE f #-} I get a lot of rules fired in a module where other definicions lie (Class.hs). If I use INLINE [1] instead I get the rule (writeN/combine) fired twice in the file where the rules are (EncM.hs), but it should be more than twice. also with INLINE [1] they don't get fired in Class.hs
12:22:32 <kolmodin_> sjanssen: I pushed a patch to show what I have now, http://www.haskell.org/~kolmodin/code/bbs/src/Data/ByteString/Binary/EncM.hs
12:22:34 <lambdabot> http://tinyurl.com/yxbo2u
12:24:14 <sjanssen> kolmodin_: so where should this writeN rule be firing?
12:24:52 <kolmodin_> I'd like it to fire in all the putWordX except putWord8
12:25:25 <kolmodin_> the pop/combine and ensureFree/combine seems to fire ok
12:25:42 <kolmodin_> at least in the EncM module in some dummy functions
12:30:06 <bringert> yay! swedish got a new letter!
12:30:13 <bringert> we now have 29
12:30:32 <sieni> wt?
12:30:35 <Grey-z> can you type it?
12:30:40 <zetta> what an odd occurance
12:30:48 <bringert> w
12:31:03 <sjanssen> kolmodin_: I'm not seeing any of your rules firing when I build with runghc Setup.hs build
12:31:06 <Grey-z> don't see a thing just w
12:31:14 <bringert> it is w
12:31:51 <kolmodin_> sjanssen: hmm? are you running with -O ?
12:31:56 <bringert> the secretary of the Swedish Academy just said on the radio that w is now considered different from v
12:32:03 <sjanssen> kolmodin_: yes
12:32:27 <kolmodin_> bringert: glad we're on the same page then
12:32:28 <kolmodin_> ..
12:32:52 <kolmodin_> sjanssen: no rules at all?
12:32:54 <SamB_XP> next the japanese will get R!
12:32:59 <SamB_XP> (or will it be L?)
12:33:04 <bringert> kolmodin_: same page?
12:33:19 <kolmodin_> bringert: we agree
12:33:34 <SamB_XP> bringert: about w and v being different letters
12:33:57 <SamB_XP> probably?
12:34:07 <sjanssen> kolmodin_: plenty of GHC's rules are firing, but none of the bbs rules are
12:34:19 <bringert> ah, I thought it was some reference to the fact that some people who weren't before will now be on the same page in the phone book
12:34:26 <bringert> though not me and kolmodin
12:34:47 <SamB_XP> heh
12:35:14 <bringert> the real problem was the english "we", which can be both inclusive and exclusive
12:35:15 <augustss> what?  w and v being different?  sacrilidge
12:35:22 <emu> SamB_XP: ra,re,ri,ro,ru
12:35:48 <SamB_XP> shouldn't w be uu?
12:36:07 <kolmodin_> sjanssen: I told you it's strange.. :) hmm
12:36:09 <kolmodin_> :(
12:36:38 <kolmodin_> sjanssen: don't you see any of the bbs rules firing in any of the modules?
12:36:57 <kolmodin_> I could add a few test functions in the repo too
12:37:39 <augustss> wikipedia has a good entry on w
12:40:03 <bringert> "Double U" is the only English letter name with more than one syllable. This gives the nine-syllable initialism www the irony of being an abbreviation that takes more syllables to say than the unabbreviated form.
12:40:18 <bringert> from http://en.wikipedia.org/wiki/W
12:40:20 <lambdabot> Title: W - Wikipedia, the free encyclopedia
12:40:39 <emu> IOW, everyone is crazy
12:40:58 <fridim> ?what iow
12:40:59 <lambdabot> I know nothing about iow.
12:40:59 <emu> just be thankful they're not saying WWW2.0
12:41:11 <allbery_b> unless you pronounce "www" as "wubwubwub" :)
12:41:19 <emu> then you just sound stupid!
12:41:19 <allbery_b> which tends to be pretty accurate :>
12:41:26 <glguy> in other words
12:41:46 <bringert> I thought the common pronunciation was "dubyadubyadubya"
12:42:21 <allbery_b> emu: or you're declaring the web to be stupid, which it is most of the time
12:42:30 <emu> i'm ok with that
12:42:39 <emu> web = lost productivity
12:43:04 <emu> let's bring back gopher
12:43:38 <SamB_XP> or better, just leave it off
12:43:52 <SamB_XP> also, nobody pronounces www on the web
12:43:56 <SamB_XP> well, almost nobody
12:44:19 <emu> on the web, nobody can hear you mumble www to yourself
12:44:34 <SamB_XP> or WWWWWWa
12:45:01 <SamB_XP> that is only one syllable
12:46:10 <Grey-z> How can I convert list of Num values to a String
12:46:13 <augustss> does the swedish decision on W mean we can no longer say veveve for www?
12:46:37 <augustss> Grey-z: concatMap show
12:46:50 <augustss> you wont get any spaces :)
12:47:09 <Grey-z> thanks :)
12:47:38 <augustss> unwords . map show  is probably what you want
12:51:41 <roconnor> @yow
12:51:41 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
12:51:46 <glguy> > show [1,2,3] -- did he not want the [,], and ,?
12:51:47 <lambdabot>  "[1,2,3]"
12:51:58 <bringert> augustss: hmm, good point. but it really should be "veveve" in Swedish: "vrldsvida vven"
12:52:21 <augustss> sant
12:52:31 <kosmikus> what's the "swedish decision" on W?
12:52:37 <SamB_XP> heh
12:52:56 <Vq^> bringert: hah :)
12:54:15 <bringert> kosmikus: v and w are now considered different
12:54:38 <bringert> kosmikus: in lexicographic sorting
12:54:53 <bringert> well, ordering
12:55:36 <augustss> and w is after v?  or did they place it between i and j?
12:56:43 <glguy> the Ord instance of Char in the swedish version of haskell must be yucky ;)
12:59:44 <ulph> haha
12:59:50 <augustss> as are, e.g., the spanish and dutch versions
13:00:14 <bringert> augustss: after v it seems. is there a particular reason for having it between i and j?
13:00:44 <bringert> didn't the spanish fix that ll thing?
13:00:44 <augustss> after v makes the ordering too easy :)
13:00:45 <kosmikus> augustss: I don't think w comes between i and j in Dutch ...
13:01:00 <augustss> kosmikus: neither do i
13:01:28 <augustss> but ij in dutch sorts funny
13:01:32 <bringert> I think that "" should be the next
13:01:48 <bringert> letter to make the swedish alphabet that is
13:02:06 <augustss> what about the accented es?
13:02:10 <kosmikus> augustss: true
13:02:39 <bringert> clearly the musli and msli distinction is important
13:02:50 <glguy> *clear*
13:02:55 * glguy wonders what's going on ;)
13:03:01 <bringert> hmm, yeah, people need to learn how to spell names of french cheeses
13:03:02 <glguy> ly*
13:03:54 <bringert> I've seem lots of spellings of "chvre"
13:04:04 <augustss> and how about ide and id
13:04:21 <bringert> arme and arm
13:04:27 <bringert> ok you win
13:04:48 <augustss> what did i win?  the letter ?
13:04:55 <bringert> yes
13:04:58 <bringert> "the bear was sleeping in his comfy idea"
13:05:08 * SamB_XP wonders if you can use zippers to design garbage collection algorithms
13:05:09 <kolmodin_> I can't even type those letters on my keybord
13:05:23 <augustss> I'll us my nw lttr thn
13:05:49 <augustss> it's a bit of a pain to typ
13:06:06 <bringert> > '' `lm` ['a'..'z']
13:06:06 <glguy> on a mac, those letters are easy... but i'm not at home now :(
13:06:06 <lambdabot>  Improperly terminated character constant
13:06:17 <kolmodin_> I'm using chucky's sv-dvorak, don't know where those letters are placed
13:06:28 <augustss> I hav a mac.  it's still a bit of a pain
13:06:34 <glguy> option-e e
13:06:43 <bringert> lambdabot: what do you mean "improperly terminated"?
13:07:05 <bringert> @vixen what do you mean "improperly terminated"?
13:07:05 <lambdabot> i'm not sure what i mean
13:07:29 <augustss> @vixen air head
13:07:30 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
13:08:01 * resiak idly wonders how sv-dvorak differs to gb dvorak
13:08:04 <glguy> sitting *behind* the computer?
13:08:39 <augustss> glguy don't you vr wondr who is bhind th computr?
13:08:57 <glguy> you mean the computer gnomes?
13:09:06 <augustss> probably
13:10:06 * SamB_XP has his first encounter with male trees
13:10:21 <SamB_XP> lambdabot: you sit *in* the computer
13:10:30 <SamB_XP> did you forget?
13:11:11 <glguy>  v 
13:11:57 <bringert> hmm, I wonder what regexp made vixen say that
13:12:00 <bringert> @vixen head
13:12:00 <lambdabot> Ok
13:12:31 <SamB_XP> glguy: behind in this instance means "on the other side"
13:12:44 <SamB_XP> the other side being the outside
13:13:22 <glguy>    
13:13:37 <bringert> bah, it's ".*"
13:13:47 <bringert> glguy: yes
13:13:54 <SamB_XP> hmm, that one letter is unreadable
13:13:56 <glguy> (=
13:14:02 <beschmi> hi all
13:14:09 <SamB_XP> the one before epsilon/euro
13:14:15 <SamB_XP> I'm not quite sure which it is
13:14:21 <sorear> hm, I think I found a problem in LB (looking through the code)
13:14:25 <glguy> SamB_XP: the s in use?
13:14:26 <sorear> ?karma c
13:14:28 <lambdabot> c has a karma of 15
13:14:37 <SamB_XP> glguy: I guess so
13:14:37 <sorear> c++ has the foo-nature
13:14:39 <sorear> ?karma c
13:14:43 <SamB_XP> as I said, it is unreadable
13:14:44 <lambdabot> c has a karma of 16
13:14:49 <sorear> c-- has the bar-nature
13:14:51 <glguy> SamB_XP: it's an s with an accent under it...
13:15:04 <SamB_XP> its a box
13:15:07 <sorear> C++ (capital) is special-cased, but not c
13:15:13 <glguy> latin small letter s with a comma below
13:15:20 <roconnor> Today Connor McBride taught me that haskell's quick sort is tree sort.
13:15:22 <SamB_XP> @karma sorear
13:15:23 <lambdabot> sorear has a karma of 7
13:15:32 <SamB_XP> sorear: say that again?
13:16:03 <glguy> roconnor: you mean the short list based one is
13:16:04 <SamB_XP> roconnor: well, we knew it wasn't really quicksort ;-)
13:16:06 <sorear> that again?
13:16:18 <SamB_XP> glguy: that one belongs to Haskell doesn't it?
13:16:25 <glguy> roconnor: the in-place quicksort can be implemented ni Haskell too
13:16:46 <glguy> ^ was my point
13:16:49 <SamB_XP> glguy: yeah but with great pain
13:16:55 <roconnor> right, the list based quicksort
13:17:08 <glguy> SamB_XP: no much more painful than the mess you get with C q-:
13:17:11 <SamB_XP> and it couldn't be mistaken for belonging to Haskell
13:17:16 <SamB_XP> glguy: true, true
13:17:30 <SamB_XP> at least in C you would already have an array, though!
13:17:34 <glguy> in-place quicksort is just an ugly algorithm , it's not a language's fault
13:17:48 <augustss> in-place quicksort is beautiful! :)
13:18:01 <augustss> i really think so
13:18:05 <augustss> so simple
13:18:07 <SamB_XP> augustss: what microlanguage do you need to make it show in the code?
13:18:46 <_abz_3> darcs help needed: I've done a bunch of darcs add's and darcs mv's. Although, I haven't recorded them. Now, I don't want to record those actions. I'd just like record the one action of adding the file in the correct directory. How do I tell darcs to forget everything I just said? So then I can do the correct action of adding it in the correct directory.
13:19:04 <augustss> SamB_XP: it looks fine in, e.g., C
13:19:10 <SamB_XP> _abz_3: hmm?
13:19:20 <bringert> _abz_3: does darcs revert help?
13:19:24 <glguy> augustss: link to your favorite implementation, or one similar?
13:19:42 <SamB_XP> you can say "yes" and "no" as appropriate when darcs asks what to record
13:19:53 <augustss> glguy: I don't have a link, sorry
13:20:22 <augustss> but you don't need the code to appreciate the beauty of the algorithm
13:20:33 <_abz_3> thanks, darcs revert is just what i want.
13:20:39 <glguy> augustss: but I'm discussing it as code, not as a process
13:21:04 <augustss> glguy: you said it was an ugly algorithm
13:21:10 <roconnor> In place quicksort is done with arrays?
13:21:13 <augustss> so that's what I objected to
13:21:18 <glguy> augustss: fair enough
13:21:22 <glguy> roconnor: yeah
13:21:30 <roconnor> bah, arrays are unsafe ;)
13:21:36 <glguy> oh?
13:21:59 <roconnor> glguy: you don't read the haskell weekly news?
13:22:21 <augustss> arrays don't have to be unsafe
13:22:29 <glguy> aparently not thoroughly enough
13:23:53 <augustss> you can my arrays safe by (proper) bounds check at run time.  or if you are oleg you can do it at compile time
13:24:53 <roconnor> augustss: good point, it is GHC that is unsafe, not arrays?
13:25:08 <augustss> roconnor: yes
13:25:15 <roconnor> nice
13:25:18 <roconnor> I feel better now
13:25:55 <augustss> though the haskell report has some dubious working regarding index calculations
13:26:06 <augustss> s/work/word/
13:27:34 <Igloo> I think we should just check the bounds after they've been converted to (essentially) pointer offsets, ignoring the pre-conversion check
13:28:07 <Igloo> But apparently it isn't yet decided whether Haskell' will talk about the Array library, so I don't know where to bring it up yet...
13:29:02 <sorear> Igloo: note that the bounds check on the first element of a tuple can be omitted if we know the final offset will be checked
13:29:03 <augustss> whatever the check is, i think it must be safe
13:30:11 <Igloo> augustss: I certainly agree with that  :-)
13:30:24 <kzm_> Evening, all!
13:30:44 <kzm_> @seen
13:30:56 <kzm_> ahem.
13:31:27 <augustss> Igloo: is there any feedback when you send in ghc patches?  I just want to know that when I send something it doesn't do to /dev/null
13:32:02 <lambdabot> Lately, I have seen _abz_3, araujo, augustss, bringert, cosmicray, glguy, gly, gour, harald, igloo, kosmikus, kzm_, lithyum, roconnor, samb_xp, sorear, tizoc, ulph and xdie.
13:32:50 <Igloo> augustss: I normally send a message when I apply something; if you don't hear anything within a week or two please feel free to prod me
13:33:33 <Igloo> augustss: Are you thinking of any patch in particular?
13:33:40 <metaperl> y000 ... is there someting like tails but gives the heads of a list.. E.g. heads [2,3,4] = [ [2], [2,3], [2,3,4] ]
13:33:42 <SamB_XP> augustss: cvs-ghc != /dev/null
13:33:47 <augustss> I sent in a patch for overloaded string literals.  I've not heard anything.  Just knowing that it was rejected would be something.
13:34:22 <kzm_> > inits [1..6]
13:34:23 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6]]
13:34:24 <metaperl> > inits [2,3,4]
13:34:26 <lambdabot>  [[],[2],[2,3],[2,3,4]]
13:34:26 <SamB_XP> though sometimes things get stuck in the moderation queue
13:34:35 <Igloo> augustss: Hmm, do you remember where and roughly when?
13:34:40 <metaperl> kzm_ - yes, Hoogle is my friend.. and thanks for your help as well :)
13:34:57 <kzm_> :-)
13:35:10 <augustss> I did a 'darcs send' maybe 3 weeks ago
13:35:15 <dobblego> so what was the millionth line?
13:36:18 <Igloo> augustss: I can't see it in the list archives; it could be that someone missed it amongst the spam. Can you resend it please?
13:37:04 * SamB_XP thinks posts that got flagged for length should be put in a seperate queue from those that came from unknown senders
13:37:30 <bringert> how do you make an empty line with the HughesPJ pretty printer combinators? (without hacks like $$ char ' ' $$)
13:37:31 <augustss> I'll try to send it again.
13:37:35 <LordBrain> How can I fork a process and simultaneously redirect its output to a handle i can read from?
13:37:39 <Igloo> Thanks
13:37:53 <Igloo> bringert: text "" is the only way AFAIK
13:38:15 <bringert> oh, that is not the same as empty?
13:38:19 <Igloo> no
13:38:23 <emu> LordBrain: define "its output"
13:38:42 <lisppaste2> glguy pasted "in-place quicksort in ST =)" at http://paste.lisp.org/display/33048
13:38:46 <bringert> Igloo: thanks
13:38:46 <LordBrain> emu, stdout
13:38:58 <emu> so, popen?
13:39:10 <augustss> Igloo: I just have to bring it up-to-date, it has conflicts now, of course
13:39:25 <Igloo> augustss: :-(
13:39:45 <augustss> bringert: I thought there was a combinator for the empty document
13:40:36 <Igloo> augustss: $$ empty $$ doesn't create a blank line, though
13:40:38 <bringert> augustss: there is, but it's the identity for most of the combinators
13:41:08 <LordBrain> @hoogle popen
13:41:08 <lambdabot> No matches found
13:41:22 <LordBrain> i mean from  haskell of course
13:41:25 <augustss> oh, empty line.  I missed "line"
13:41:30 <emu> @where popen
13:41:30 <lambdabot> I know nothing about popen.
13:41:37 <emu> hmm. i know its somewhere
13:42:05 <augustss> yeah, text "" is what I use
13:43:45 <metaperl> I would like to see the implementation of Data.List.inits ... what's the fastest way to get at it?
13:44:04 <bringert> metaperl: source code link from haddock docs
13:44:22 <metaperl> ok thanks bringert
13:44:35 <augustss> Igloo: btw, ghc from the last few days doesn't build cleanly on windows+mingw, but you probably know that
13:44:45 <kzm_> I'm using WriterT with IO to collect some extra information from IO actions, and it looks like it works.  Now, I think my program can be more general if I can parametrize some of the actions.  Must I turn to StateT for this?
13:44:54 <metaperl> bringert - you mean from here: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Ainits ...?
13:44:55 <lambdabot> http://tinyurl.com/yhrw65
13:45:14 <bringert> metaperl: see "source code" at the top of that page
13:45:28 <kzm_> (I'm writing a PBS (batch queueing system) front end, and I'd like my scripts to support multiple back ends - at least running locally in the shell)
13:45:32 <metaperl> ah, sweet
13:45:35 <metaperl> :)
13:46:27 <Igloo> augustss: Yeah, it failed for me a few days ago; I think Wolfgang found the problem earlier today, so we'll see if it works now. But thanks for letting me know
13:47:30 <LordBrain> @type System.Process.runInteractiveProcess
13:47:31 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
13:48:27 <kzm_> LordBrain, for me?
13:48:47 <LordBrain> no
13:48:49 <LordBrain> for me
13:48:57 <LordBrain> i'm thinking i can use this as my popen..
13:48:59 <kzm_> Ah, sorry :-)
13:50:08 <LordBrain> if your dealing with porting shell or perl scripts which operate on piped output from other processes, then i guess its for you too
13:52:25 * allbery_b pokes at memoizing via a state monad
13:58:14 <bringert> LordBrain: I used runInteractiveProcess to implement CGI in the Haskell Web Server, it seems to work fine
13:59:12 <LordBrain> ok
13:59:23 <kzm_> LordBrain, bringert: for my local backend, I may want to juggle background processes.
14:00:14 <kzm_> Ideally, a script should be able to be run either locally or by submitting jobs to the batch queue.  Not sure how to select behavior, though.
14:01:28 <kzm_> I use WriterT to collect "handles" for the jobs - I guess I could stuff the appropriate action for running a command into a ReaderT, but it seems a bit heavyweight?
14:01:42 <kzm_> Implicit parameter, perhaps?
14:04:19 <sjanssen> kzm_: I'd say this is exactly the sort of task you want to use ReaderT
14:04:38 <kzm_> Okay.
14:04:52 <sjanssen> shouldn't be too tough if you're already using WriterT
14:04:58 <kzm_> I'll try that, then.  ReaderT + WriterT = StateT?
14:05:06 <kzm_> Or perhaps not..
14:05:09 <sjanssen> not quite
14:05:19 <kzm_> Okay.
14:05:27 <dons> ?users
14:05:28 <lambdabot> Maximum users seen in #haskell: 309, currently: 296 (95.8%), active: 47 (15.9%)
14:05:57 <glguy> ReaderT + WriterT + StateT = RWST
14:06:56 <kzm_> Well - it's bedtime for me, and packing for xmas tomorrow, so I better get my beauty sleep.
14:07:01 <kosmikus> dons: have you managed to test lhs2tex, by chance?
14:07:12 <kzm_> Thanks, and good night.
14:10:32 <sorear> dons: while trying to understand LB I found a missing special case.
14:10:35 <sorear> ?karma C
14:10:35 <lambdabot> C has a karma of 2
14:10:39 <sorear> ?karma c
14:10:40 <lambdabot> c has a karma of 17
14:10:46 <sorear> c++ has the foo nature
14:10:52 <sorear> C++ has the bar nature
14:10:56 <sorear> ?karma C
14:10:56 <lambdabot> C has a karma of 2
14:10:57 <sorear> ?karma c
14:10:57 <lambdabot> c has a karma of 18
14:11:08 <sorear> c--
14:11:25 <sorear> (patch already sent)
14:11:31 <bd_> *WB* <@Weedy> eretan, when you were born and the doctor said "its a boy" your mom slaped him and told him not to lie <@eretan> nice <@eretan> I always wanted to be a girl
14:13:04 <_matthew-> evening. Can people think of an algorithm or problem that you can only solve optimally/effectively/simply by using > 1 threads and shared mutable state?
14:13:50 <_matthew-> I'm trying to understand if there's any reason whatsoever why you'd want to keep the kind of concurrency model that appears in C/C++/Java/C#
14:13:59 <kpreid> _matthew-: by the way, that question is particularly on topic for ##concurrency, if you haven't heard of it
14:14:14 <roconnor> how does DList differ from [A]->[A]?
14:14:58 <_matthew-> kpreid: I agree. But I'd also like to pick the minds of the haskell camp too
14:15:39 <_matthew-> ahh, and having read the topic there, that too would be the place to ask! Cheers.
14:15:43 <sorear> nil
14:16:14 <sorear> newtype DList a = DList ([a] -> [a])   -- iirc
14:17:02 <EvilRanter> _matthew-, I'd figure that it's probably popular in those languages because it's close to how the computer works, not because it's a good paradigm
14:17:47 <_matthew-> EvilRanter: yeah, I kinda get the impression it just got added in some adhoc way without "much thought", though of course we kinda understand it better now...
14:20:05 <roconnor> sorear: ah, cool
14:20:46 * EvilRanter likes to consider language features on the scales of "natural for a computer" (goto) and "natural for a human" (functions)
14:24:35 <glguy> what are my choices for unary operators?
14:24:42 <EvilRanter> some things end up in the negative on both counts (cobol's modifiable GOTOs, for instance)
14:24:53 <glguy> let (#) a = a in (#) 1     ... (1 #)
14:25:11 <EvilRanter> glguy, i think you're stuck with functions
14:25:28 <EvilRanter> anything punctuation-y is considered an infix (binary) operator
14:25:32 <glguy> so, just the two cases above then
14:25:39 <_matthew-> EvilRanter: mmm. Maybe concurrency is such an issue because it's not "natural" for a human.
14:25:48 <monochrom> I notice that you don't have "natural for a logician"
14:26:11 <EvilRanter> monochrom, i consider those human. :P
14:26:31 <_matthew-> O.o
14:26:45 <syntaxfree> project activity graphs should be plotted on a logarithmic scale.
14:26:46 <monochrom> Observe that "natural for logician" is natural to both human and computer.  For example "true or false = true".
14:27:08 <EvilRanter> well, that's scoring high on both scales
14:27:19 <EvilRanter> (I'm thinking something scattergraph-y here)
14:27:31 <monochrom> I also want to remind you of one meaning of intelligence.  Webster, definition 5: the ability to perform computer functions.
14:27:55 <EvilRanter> ok...
14:28:51 <monochrom> My conclusion is that if there is some conflict between apparently "for computer" vs "for human", that is really just a symptom.  The real phenomenon is "for intelligent human" vs "for dumb human".
14:29:31 <EvilRanter> monochrom, i doubt GOTOs could ever be entirely fit for human consumption
14:29:48 <_matthew-> surely, they're for intelligent humans only
14:29:48 <monochrom> Right, but that's an outlier.
14:30:01 <EvilRanter> also threading w/ shared memory
14:30:10 <_matthew-> because intelligent humans will decide, out of choice, not to use them
14:30:14 <EvilRanter> (albeit less so)
14:30:29 <EvilRanter> and suchlike low-level-isms
14:30:39 <monochrom> computer has great difficulty with shared memory too.
14:31:29 <EvilRanter> I'm under the impression that it's the easiest solution to inter-thread communication, implementation-wise
14:31:31 <monochrom> for example you can't just directly wire two CPUs to the same memory chip.
14:31:35 <EvilRanter> and that's whe it'd
14:31:38 <EvilRanter> *why it's done
14:31:47 <EvilRanter> do correct me if i'm wrong
14:31:54 <monochrom> No.  It is conceived by very dumb people.
14:32:03 <EvilRanter> hm.
14:32:33 <_matthew-> I'm not sure they were dumb
14:32:53 <_matthew-> I'm sure they were under a lot of pressure, at a time where programming was a black art anyway
14:32:57 <EvilRanter> do you have a better solution?
14:33:03 <monochrom> Shared memory was conceived by very dumb people; those people found it natural to them.  Observe that implementing shared memory between N CPUs in hardware turned out to be tricky.  Not natural for hardware, I would say.
14:33:09 <EvilRanter> (one that's no more difficult to implement)
14:33:14 <sorear> pipes!
14:33:22 <EvilRanter> not natural for multicore hardware
14:33:37 <sorear> a fifo-buffer between processors can be set up efficiently
14:33:52 <EvilRanter> that indicates a failure to anticipate multicore becoming common, rather than dumbness, i'd say
14:34:09 <sorear> even 1000mbs ethernet might do better
14:34:29 <EvilRanter> sorear, if that's the case, then the shared-memory people _were_ dumb
14:34:47 <sorear> e.g large clusters are always set up using packet-switching, not shared-memory
14:34:59 <sorear> shared-memory works well on a very small scale
14:35:08 <_matthew-> right. but given we've had this model of concurrency for 20 years or so, there must be applications that really really suit it
14:35:14 <monochrom> messaging mechanisms (for example transputers) turned out to be both simpler in hardware and more usable by intelligent humans (for example CSP and CCS).
14:35:23 <sorear> you can just add locking logic to the memory controller, and have a common bus
14:35:26 <EvilRanter> I'd consider pipes infinitely clearer for humans, so if you say it's better for computers too, there's no reason not to do it...
14:36:05 <uogl> EvilRanter: And it essentially is done on any modern supercomputer.
14:36:11 <EvilRanter> in the single-core scenario, would shared memory would be significantly faster, mind?
14:36:12 <_matthew-> EvilRanter: pipes only really work when your data parallel and no data interdependancies though, really
14:36:25 <_matthew-> or are you meaning more in terms of routing data
14:36:28 <sorear> esp. when you consider that memory is accessed using pipes
14:36:54 <EvilRanter> _matthew-, routing data, yes.
14:37:04 <_matthew-> right. so this is really the actor model
14:37:06 <uogl> Though implementing the interconnects used on modern supercomputers isn't exactly easy, but they certainly scale better than SMP-like shared memory.
14:37:08 <monochrom> I am less able to justify the same point on the single-cpu case.
14:37:45 <_matthew-> monochrom: CCS and CSP didn't really make it into popular programming languages though did they?
14:38:07 <EvilRanter> you'd probably also need some kind of semaphore-esque system ("hey, there's some data waiting for you"), but primarily pipes sounds like a Good Idea to me
14:38:26 <_matthew-> right, but this has been done before
14:38:50 <_matthew-> so there must be a reason why it didn't achieve widespread adoption
14:38:56 <monochrom> CCS, CSP, and messaging didn't make it into popular programming.
14:38:58 <EvilRanter> politics?
14:39:10 <_matthew-> Erlang is certainly in the same area as you're talking about
14:39:32 <monochrom> SML, Haskell, and equational reasoning didn't make it into popular programming.
14:39:52 <monochrom> pointer arithmetic, shared memory, and C made it into popular programming.
14:39:57 <_matthew-> monochrom: besides, if you're going to go that route, I'd prefer to use ambients and then we can move processes around too...
14:40:00 <monochrom> Do you see a pattern?
14:40:02 <EvilRanter> that's a speed thing, really
14:40:06 <_matthew-> err well yes, but at least haskell exists
14:40:40 <_matthew-> how many implementations of ccs or csp or pi or ambients or spi or... are there around that have the same community as haskell?
14:40:52 <monochrom> The pattern I see is that dumb programming is popular.
14:41:04 <EvilRanter> i mean, your highest-optimised compiled-to-native-bytecode haskell is still going to be more processor- and memory-intensive than some well-written C
14:41:05 <_matthew-> right - cater for the lowest common denominator
14:41:20 <monochrom> speed is just an excuse.
14:41:21 <EvilRanter> that the majority of C code is poorly written is another matter entirely...
14:42:08 <_matthew-> but you can far more easily get away with poor code with non concurrent systems, from what I've seen.
14:42:27 <monochrom> I don't need csp implemented.  I see a program that messages, and I reason about it in csp.  It is an algebra, not a code language, for me.
14:42:50 <lisppaste2> glguy pasted "in-place quicksort gives nice chance to use foldM" at http://paste.lisp.org/display/33061
14:43:12 <monochrom> For that matter, monad laws are not implemented in haskell, but I use the laws to write and reason about programs anyway.
14:43:19 <_matthew-> monochrom: Ahhh! Put it in the type system
14:43:36 * _matthew- is excited
14:43:48 <_matthew-> that sounds like a really great idea
14:43:49 <monochrom> occam was supposed to look like csp.  then people didn't like it because it was too logical.
14:44:04 <_matthew-> plus there are also type systems for the process algebra
14:44:27 <_matthew-> which allow you to model various things - normally typing messages, but in the case of spi or ambients, other stuff too
14:45:22 <_matthew-> so you still have no shared data, and you're really using the process algebra as some sort of temporal type system
14:45:34 <_matthew-> modelling the protocol and ordering of messages
14:46:00 <Saizan> http://scienceblogs.com/goodmath/2006/12/tail_recursion_iteration_in_ha_1.php <-- is he just mistaken on tail recursion in haskell or i recall incorrectly?
14:46:02 <lambdabot> Title: Good Math, Bad Math : Tail Recursion: Iteration in Haskell, http://tinyurl.com/y3q3x3
14:47:17 <_matthew-> lol: "What's nice about that code is that it doesn't use any stack space for the iteration." Yep, that's about the *only* nice thing about it...
14:47:29 <sjanssen> Saizan: which part are you questioning?
14:47:56 <Saizan> when he says that tail recursion is more efficient in haskell than foldr, basically
14:48:15 <sjanssen> it depends on the function you are folding
14:48:28 <monochrom> Speed is just an excuse.  Notice the context in which it is brought up.  You ask "why not use this abstraction", he answers "slow".  If the real reason is he's too dumb to grok abstraction, and you ask "why not use this abstraction", can you hope to get him to say out loud "I'm too dumb"?  Of course not, so he blames it on speed.  Notice that later it turns out that when he said "slow" it was not like he could prove it.
14:48:29 <glguy> foldl' is tail recursive... right?
14:49:08 <sjanssen> if the function is strict in both arguments (like (+)), then foldr isn't so good, but if it is lazy in the second argument ((||), for example) foldr is better
14:49:33 <glguy> foldl' f a [] = a; foldl' f a (x:xs) = foldl' f (f a x) xs -- i think
14:49:38 <glguy> oops, i forgot , that's foldl
14:49:43 <glguy> need the strict part
14:49:54 <Saizan> foldl' adds seq i suppose
14:49:57 <glguy> yeah
14:50:45 <EvilRanter> monochrom, you seem to have a very low opinion of the majority of the programming community
14:50:57 <glguy> EvilRanter: you haven't been reaqding programming.reddit long?
14:50:59 <monochrom> Yes and no.
14:51:04 <EvilRanter> I mean, much of the time, speed may very well be a valid consideration
14:51:12 <_matthew-> monochrom: mmm. But of course, much in Java is implemented with synchronised and endless wait/notify patterns which are often slow, as well as error prone. There are actor extensions to java (Salsa is one that springs to mind) that *are just plain simpler* and probably have better performance. so why don't they get used?
14:51:13 <EvilRanter> glguy, not at all, actually.
14:51:24 <glguy> EvilRanter: you are missing out on a lot of dumb comments then ;)
14:51:47 <thelsdj> heh, i don't bother to read the comments most of the time
14:51:51 <monochrom> Speed is a valid concern.  It is also widely abused.
14:51:52 <EvilRanter> glguy, how unfortunate for me. \:P
14:51:53 <Saizan> so? i've read to use foldl' because it was strict so i will not pay twice the recursion if a i wanted a foldl, what the whole story?:D
14:52:13 <Saizan> s/what/what's/
14:52:34 <_matthew-> is dailywtf better or worse than reddit?
14:52:39 <glguy> the story is that you should use foldr when you can benefit from partial computation
14:52:41 <sjanssen> Saizan; using foldl' is good advice
14:52:45 <EvilRanter> I quite enjoy dailyWTF
14:52:46 <glguy> _matthew-: WAY worse
14:53:07 <glguy> and when you always need the whole thing computated, foldl' is usually best
14:53:21 <glguy> foldl is typically not for use
14:53:42 <Saizan> ook
14:54:24 <monochrom> First, I have a low opinion of many programmers, but I am willing to change it as we converse.  Second, the more important thing is, I want to encourage you to scrutinize popular beliefs instead of just accepting them due to their popularity.
14:55:15 <glguy> augustss: you still there?
14:55:17 <_matthew-> but people are typically sheep
14:55:23 <Saizan> so tail recursion is "bad" only when i can usefully be lazy in the accumulator?
14:55:33 <_matthew-> and the education system hardly encourages challenging received wisdom
14:55:41 <glguy> Saizan: I would agree with that statement
14:55:51 <yaarg> everybody has to accept some stuff on authority in some way
14:55:55 <yaarg> can't know everything about everything
14:56:23 <_matthew-> right. but that's an awfully long way from the zombie-like state of the present
14:57:33 <monochrom> SPJ would be an authority I am inclined to accept from.  IOW I base it on demonstrated past intelligence rather than demonstrated past popularity.
14:57:37 <EvilRanter> monochrom, oh, i'm quite willing to accept that popular opinion is wrong. i'm just no less skeptical of the underdog than i am of popular opinion
14:57:58 <kolmodin_> good night
14:58:03 <yaarg> monochrom: indeed
14:58:37 <yaarg> now what are people actually talking about../me reads up
14:59:09 <monochrom> assessing language features :)
14:59:41 <_matthew-> trying to work out what to do my PhD on...
15:00:01 <Saizan> uhmm CSP, i've an exam the day after tomorrow on CSP and LINDA :D
15:00:03 <EvilRanter> generally, if one person tells me something is faster or whatever, unless that blatantly fails the reality check, i'll go along with it at least until someone contradicts that opinion
15:00:28 <yaarg> heh i'm trying to make the same decision _matthew-
15:00:48 <_matthew-> yaarg: lol. you started this year then? Just finished your first term?
15:00:56 <yaarg> i graduated last year
15:00:59 <_matthew-> yep
15:01:03 <_matthew-> me too.
15:01:11 <_matthew-> just stared my PhD though.
15:01:15 <EvilRanter> until now, no-one had contradicted the idea "shared memory is low-level". now they have, eh...
15:01:18 <yaarg> i'm having a few years from academia atm
15:01:22 <yaarg> away even
15:01:30 <EvilRanter> **goes back to talking to a wall**
15:01:48 <yaarg> _matthew-: i see
15:02:05 <yaarg> a functional programming topic?
15:02:08 <_matthew-> EvilRanter: please don't. ;-)
15:02:38 <_matthew-> mmm. Concurrency is my primary interest
15:02:49 <EvilRanter> _matthew-, don't worry, this one's very articulate and well-read.
15:03:15 <glguy> :t \x y -> [x..y]
15:03:16 <lambdabot> forall a. (Enum a) => a -> a -> [a]
15:03:23 <yaarg> isn't one meant to have a topic before they start anyway?-)
15:04:19 <_matthew-> yaarg: yeah, but it depends where you are and how well you're know by the people there and how well you interview etc etc as to whether a) that has to be stuck to or b) it needs to be anything more than the vaguest waffle
15:04:49 <yaarg> _matthew-: right, fair enough
15:05:42 <glguy> ?instances MArray
15:05:43 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
15:06:54 <glguy> MArray instances, DiffArray, IOArray, STArray?
15:07:04 <glguy> (and unboxed variants?)
15:07:32 <dons> kosmikus: haven't had a chance to test lhs2tex yet. leaving for vacation in 30 mins... :/
15:08:42 <nominolo> ?users
15:08:43 <lambdabot> Maximum users seen in #haskell: 309, currently: 277 (89.6%), active: 44 (15.9%)
15:10:10 <SamB_XP> glguy: DiffArray?
15:10:26 <glguy> is it not?
15:10:30 <glguy> I don't know, Im' asking
15:10:50 <nominolo> dons: how do you collect all the blog posts for the weekly haskell news?
15:10:52 <SamB_XP> @help instances-importing
15:10:53 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
15:11:22 <glguy> ?instances Data.Array.Base.MArray
15:11:26 <kosmikus> dons: ok, I'll just release it, then :) people will complain if it doesn't work.
15:11:31 <kosmikus> dons: have a good vacation
15:11:33 <SamB_XP> @instances-i Data.Array.IO Data.Array.ST Data.Array.Diff MArray
15:11:34 <lambdabot> IOArray e IO, IOUArray Bool IO, IOUArray Char IO, IOUArray Double IO, IOUArray Float IO, IOUArray Int IO, STArray s) e (ST s, STUArray s) Bool (ST s, STUArray s) Char (ST s, STUArray s) Double (ST s,
15:11:34 <lambdabot>  STUArray s) Float (ST s, STUArray s) Int (ST s
15:11:53 <glguy> ahh
15:12:08 <glguy> is the DiffArray old news?
15:12:10 <glguy> (I've never used one)
15:12:51 <dons> kosmikus: ok!
15:13:13 <dons> nominolo: i use rss to scan google's blog search results for 'haskell' and other related keywords
15:13:25 <dons> nominolo: so each morning 10 haskell articles appear in my feed reader :)
15:14:48 <nominolo> dons: nice. btw, thanks for "redditing" me ;) -- I actually felt the need to respond to the comments :)
15:15:29 <dons> nominolo: oh, which article was that?
15:15:45 <nominolo> dons: titled "Syntax"
15:15:52 <dons> ah right.
15:17:31 <glguy> ?pl \x y -> f x >>= \t -> f y >>= g x >> g t
15:17:32 <lambdabot> ap ((.) . (>>=) . f) (flip flip g . (((.) . (>>)) .) . flip ((>>=) . f) . g)
15:17:39 <glguy> *perfect*
15:17:48 <glguy> ?. unpl pl \x y -> f x >>= \t -> f y >>= g x >> g t
15:17:49 <lambdabot> ((\ aa b c -> (f aa) >>= (b c)) >>= \ t -> (\ ag k n -> ((f k) >>= (g ag)) >> (g n)) >>= \ s -> return (t s))
15:18:48 <glguy> ?pl f x >>= \t -> f y >>= g x >> g t -- what I really wanted
15:18:49 <lambdabot> ((g x =<< f y) >>) . g =<< f x
15:20:48 <Pastorn> @type unpl
15:20:49 <lambdabot> Not in scope: `unpl'
15:21:25 <glguy> unpl is a lambdabot command
15:21:31 <nominolo> @help unpl
15:21:32 <lambdabot> pointful <expr>. Make code pointier.
15:21:34 <glguy>  ?. is compose
15:21:54 <glguy> ?pl f . g
15:21:55 <lambdabot> f . g
15:21:59 <glguy> ?unpl f . g
15:21:59 <lambdabot> (\ c -> f (g c))
15:22:37 <kermit_> How do you match multiple patterns to the same value,
15:22:47 <kermit_> like a | b | c -> abc in ML?
15:23:04 <monochrom> can't
15:23:46 <kermit_> so you need x | elem x [a,b,c] ?
15:23:57 <nominolo> case x of a@(A ..) -> helper a; b@(B ...) -> helper b; ... where helper x = ...
15:24:40 <_matthew-> I do love how you can define aliases at any depth of pattern matching. It's really very useful
15:25:13 <_matthew-> a@(A _ _ b@(B x y))...style
15:25:47 <glguy> I like that I can do it, but I'm always particularly careful when I do... seems like it's easy to make the pattern unreadable
15:26:01 <kermit_> nominolo, that's like 60 chars
15:26:24 <nominolo> kermit_: true. but I didn't know what you were up to
15:26:30 <Igloo> kermit_: The simple answer is, you can't
15:26:31 <_matthew-> oh, well I guess once you've got to the point of having a 12-ary tuple, you've given up caring about readability ;-)
15:26:56 <nominolo> _matthew-: but then you probably want records anyway
15:27:15 <glguy> heh, the person with the nick "dmwit" has a quick message calling someone dumb =)
15:27:41 <glguy> part message*
15:28:06 <nominolo> hm, must have missed it
15:28:11 <kermit_> That's surprising.  Are there any other places where Haskell has less sugar than ML?
15:28:20 <_matthew-> probably. Will ghc unbox strict fields in a record with -funpack... in the same way as with a tuple?
15:28:55 <Saizan> kermit_ there's a language expression that let's you do pattern matching using regex syntax
15:29:02 <Saizan> *extension
15:29:06 <glguy> ew
15:29:57 * SamB_XP didn't think datatypes could be regular
15:30:04 <Saizan> mmh
15:30:15 <Saizan> trhsx is the preprocessor iirc
15:30:31 <nominolo> doesn't O'caml have regex types?
15:30:39 <jethr0> yeah, finally back in #haskell :)
15:30:51 <nominolo> ?users
15:30:52 <lambdabot> Maximum users seen in #haskell: 309, currently: 276 (89.3%), active: 44 (15.9%)
15:31:21 <nominolo> welcome to the crows
15:31:27 <nominolo> er, crowd
15:31:56 <jethr0> welcome to the krauts
15:32:23 <Saizan> ?whee HaRP
15:32:24 <lambdabot> http://www.cs.chalmers.se/~d00nibro/harp
15:32:46 <Saizan> she parses even misstyped commands :O
15:32:56 <jethr0> yup, using editing distance
15:33:22 <Saizan> ok, goodnight
15:34:46 <kermit_> nominolo, yes.
15:34:46 <Excedrin> where's bitwise and?
15:34:56 <dons> heya jethr0
15:35:29 <nominolo> kermit_: but they're living in a separate type world, afaik, like objects
15:35:35 <psi> ?hoogle .&.
15:35:35 <lambdabot> Data.Bits.(.&.) :: Bits a => a -> a -> a
15:35:46 <dons> jethr0: its been 3 months or so?
15:36:00 <kermit_> Yes, you compile a regex from a string.
15:36:06 <Excedrin> thanks psi
15:36:21 <jethr0> hey dons, i've been away quite a while :)
15:36:35 <jethr0> but i've been active on the wiki for the last week or so, already
15:37:01 <jethr0> doing some "99 problems" and "haskell quiz" work
15:41:29 <jethr0> ping
15:46:09 <Excedrin> pong
15:48:07 <jethr0> yeah, so chatzilla _is_ working. just nobody talking :(
15:48:10 <jethr0> hi excedrin
15:56:15 <nominolo> uncomfortable silences on #haskell ..
15:56:39 <kermit_> so what about tail calls?
15:56:56 <kermit_> how do you know if they're eliminated?
15:57:14 <kermit_> or if that's too boring
15:57:23 <kermit_> which is cooler, Haskell or ML?
15:57:29 <SamB_XP> aren't they always eliminated?
15:57:31 <monochrom> by noticing no stack overflow
15:57:42 <kermit_> I mean beforehand.
15:58:06 <kermit_> Isn't there a language spec somewhere that discusses it?
15:58:06 <SamB_XP> maybe by noticing whether or not they are tail calls?
15:58:09 <nominolo> i'll guess they're guaranteed to be removed
15:58:42 <monochrom> No, the spec doesn't say.  Scheme spec is the only one that does.
15:58:59 <monochrom> But don't be paranoid about this.  They are eliminated.
15:59:00 <kermit_> What if you say "let tryAgain = foo x y z" inside foo x y z?
15:59:08 <SamB_XP> but it would be about as sane as having GOTO leak memory to not do it
15:59:37 <monochrom> I don't understand the last question.  Incomplete fragment.
15:59:56 <kermit_> recursion in multiarg function.
16:00:03 <SamB_XP> ???
16:00:16 <kermit_> Multiple recursive calls.
16:00:18 <SamB_XP> I'm pretty sure tail calls are always eliminated by sane compilers
16:00:25 <SamB_XP> recursive or otherwise
16:00:34 <SamB_XP> it is the simplest way to do it, you know
16:00:40 <kermit_> You're probably right.
16:00:43 <dons> "which is cooler, Haskell or ML?", I think Haskell is the cooler, funkier younger brother of old man ML ;)
16:00:57 <monochrom> OK, put it this way, you wrote "let v = e", but I need to see the subsequent "in blahblahblah" to answer your question.
16:01:06 <glguy> dons: aren't you supposed to be on holiday?
16:01:07 <glguy> :)
16:01:09 <SamB_XP> otherwise you'd have the compiler trying to prove that it had a license to waste stackspace ;-)
16:01:41 <kermit_> I want to make multiple recursive calls in a function without changing the args.
16:01:56 <kermit_> But I don't want to type in the args every time.
16:02:00 <monochrom> Or how about I prove your incompleteness by two different models?
16:02:20 <monochrom> "f x = let y = f x in y+y" this is clearly not tail
16:02:28 <monochrom> "f x = let y = f x in y" this is clearly tail
16:02:33 <kermit_> blahblahblah includes multiple calls to v
16:02:38 <glguy> kermit_: elem a xs = aux xs where aux [] = False; aux (x:xs) = if x == a then True else aux xs
16:02:51 <monochrom> Then it is clearly not tail
16:03:03 <monochrom> May I ask you to ask clear questions next time?
16:03:14 <kermit_> sorry
16:03:43 <kermit_> if a then v else if b then return ok else v
16:04:00 <monochrom> that's tail
16:04:14 <dcoutts__> dons: check this code by kolmodin_:
16:04:16 <dcoutts__>     -- this truly is a beautyful piece of magic
16:04:16 <dcoutts__>     bss <- liftIO $ unsafeInterleaveIO $ evalStateT (c ()) s
16:04:32 <dcoutts__> dons: part of a ByteString serialisation lib
16:05:07 <dons> mmmmm
16:05:17 <dcoutts__> and what do you think of this monad:
16:05:19 <dons> glguy: just heading out the door
16:05:22 <dcoutts__> newtype EncM a = EncM { unEncM :: ContT [B.ByteString] (StateT S IO) a }
16:05:25 <dons> glguy: last thing i do is unplug the laptop ;)
16:05:30 <dons> dcoutts__: oh!
16:05:37 <dons> isn't that what you were pondering?
16:05:50 <dcoutts__> dons: yeah, he's carrying on that idea
16:06:03 <dons> for fun? or a paper....
16:06:05 <dcoutts__> I presented that fragment and idea at Chalmers
16:06:12 <dons> ah yes
16:06:15 <dcoutts__> he's trying to turn it into something useful
16:06:19 <dons> great!
16:06:23 <dcoutts__> yeah
16:06:33 <dcoutts__> I'm trying to persude him to come to Hac07 too
16:06:41 <dcoutts__> dons: how many spaces left now?
16:06:53 <dons> about 5
16:06:59 <dcoutts__> ok great
16:07:03 <dons> so ... yes, beg plead steal...
16:07:27 <dcoutts__> @arr
16:07:27 <lambdabot> Yo ho ho, and a bottle of rum!
16:08:40 <SamB_XP> how do you type while moving through a doorway?
16:08:49 <jethr0> sideways?
16:08:51 <SamB_XP> also... you have a reaaaaaallly long doorway
16:09:11 <jethr0> slowly?
16:12:39 <dcoutts__> hey dons, you and Simon and I should run a quick session on optimising code, perhaps using kolmodin_'s serialisation as an example
16:13:05 <dcoutts__> dons: going through the setting up a benchmark, looking at the various ghc outputs etc
16:13:12 <dcoutts__> --dump-blah etc
16:13:39 <SamB_XP> somebody should do a session on writing a decent mailing-list manager
16:14:18 <dcoutts__> perhaps we can beat^H^H^H persuade kolmodin_ do to a little background work in setting up a repeatable benchmark that we can use as a baseline
16:14:24 <dons> dcoutts__: ah yes. good idea
16:14:37 <dons> dcoutts__: you mean like the kind of things we did to tune the bytestring lib?
16:14:42 <dcoutts__> dons: right
16:14:51 <dons> yeah, that sounds like a good idea
16:14:53 <dcoutts__> dons: kolmodin_'s got a rule he wants to use too
16:17:32 <dons> ok. time for me to go. i'll have some intermittent net over the next week or so
16:17:38 <dons> look after lambdabot!
16:17:58 * dons `throwTo` vacation!
16:18:02 <dcoutts__> dons: yay
16:18:04 * monochrom gives lambdabot a cookie
16:18:04 <dcoutts__> have fun
16:18:10 <dcoutts__> @botsnack
16:18:10 <lambdabot> :)
16:27:21 <LordBrain> hmmm
16:28:45 <LordBrain> Is it possible to make a function usingMask:: Bits a -> Strategy b ? The idea being to only apply the function to the nth element of a list if the nth bit is set?
16:29:38 <LordBrain> or maybe usingMask Bits a -> Strategy b -> Strategy b
16:30:57 <LordBrain> so like once that staregy is computed i can now use something like: parMap result f xs
16:37:20 <SamB_XP> LordBrain: I would start by making a function of type (a -> b) -> [Bool] -> [a] -> [b]
16:37:48 <LordBrain> hmmm
16:38:02 <SamB_XP> > bit 32 (1 :: Int)
16:38:03 <lambdabot>  add an instance declaration for (Bits (Int -> a))
16:38:04 <lambdabot>   In the definition of ...
16:38:05 <LordBrain> i'm not sure the path you're on
16:38:12 <SamB_XP> actually, s/b/a/
16:38:23 * SamB_XP is silly
16:38:35 <SamB_XP> type (a -> a) -> [Bool] -> [a] -> [a]
16:38:44 <LordBrain> i want something like a mask which means fourth, so i can say applyfunc fourth f list, and it returns a new list with the fourth element modified by the function f.
16:39:07 <sorear> you mean like:
16:39:17 <SamB_XP> wait, whats a Strategy?
16:39:52 * SamB_XP silly silly
16:39:58 <SamB_XP> sillily
16:40:01 <sorear> fun f msk a = zipWith (\m a -> if m then f a else a)  msk a
16:40:06 <LordBrain> i'm not that familiar with strategies myself, i just was searching through hoogle to see if there was something like what i need, and the parMap function was the closest that i found.
16:40:24 <sorear> let fun f msk a = zipWith (\m a -> if m then f a else a)  msk a in fun (*2) [False, False, True, False, True] [1,2,3,4,5]
16:40:29 <sorear> > let fun f msk a = zipWith (\m a -> if m then f a else a)  msk a in fun (*2) [False, False, True, False, True] [1,2,3,4,5]
16:40:31 <lambdabot>  [1,2,6,4,10]
16:41:26 <LordBrain> yeah
16:41:50 <LordBrain> i could do it that way
16:41:52 <sorear> > let fun f msk a = zipWith ($) (map (\a -> if' f id) msk) a in fun (*2) [False, False, True, False, True] [1,2,3,4,5]
16:41:53 <lambdabot>  Not in scope: `if''
16:42:24 <sorear> (if' is one of the special routines used by ?pl, I thought > might have it)
16:42:29 <LordBrain> and then have fourth = [False,False,False,True] ++ (repeat False)
16:42:47 <sorear> fourth = map (==4) [0..]
16:42:54 <LordBrain> yeah
16:43:01 <LordBrain> thats nicer, thanks
16:43:19 <sorear> ?let nth = flip map [0..] . (==)
16:43:20 <lambdabot> Defined.
16:43:23 <sorear> > nth 4
16:43:24 <lambdabot>  Not in scope: `nth'
16:43:27 <sorear> > L.nth 4
16:43:28 <lambdabot>  [False,False,False,False,True,False,False,False,False,False,False,False,Fals...
16:43:45 <LordBrain> L ?
16:43:54 <SamB_XP> it is an ugly hack
16:43:57 <sorear> its a module prefix
16:44:01 <LordBrain> yeah
16:44:02 <LordBrain> ok
16:44:05 <SamB_XP> for some reason @let adds a binding to L.hs
16:44:14 <LordBrain> the L module is like our working module i guess
16:44:26 <sorear> ?let map = error "Doing something that would confuse newbies"
16:44:27 <lambdabot> <local>:6:11:     Ambiguous occurrence `map'     It could refer to either `L....
16:44:40 <sorear> ?let (+) = error "Doing something that would confuse newbies"
16:44:41 <lambdabot> Defined.
16:44:46 <sorear> > 2 + 2
16:44:47 <lambdabot>  4
16:44:50 <sorear> > 2 L.+ 2
16:44:50 <lambdabot>  Add a type signature
16:44:54 <LordBrain> lol
16:45:08 <edi> > 1 L.+ 2 :: ()
16:45:09 <lambdabot>  Exception: Doing something that would confuse newbies
16:45:14 <sorear> it's a security feature :)
16:45:22 <SamB_XP> @list
16:45:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:45:29 <sorear> ?undef
16:45:30 <SamB_XP> not that list silly
16:45:30 <lambdabot> Undefined.
16:45:38 <edi> > 1 L.+ 2 :: ()
16:45:39 <lambdabot>  Not in scope: `L.+'
16:45:55 <SamB_XP> @let map = error "confuse n00bs with this!"
16:45:56 <lambdabot> Defined.
16:45:58 <sorear> things don't stay defined for very long around here :)
16:46:13 <LordBrain> they time out?
16:46:16 <SamB_XP> > L.map (+1) [0..]
16:46:17 <lambdabot>  Add a type signature
16:46:25 <SamB_XP> > L.map (+1) [0..] :: [Integer]
16:46:27 <lambdabot>  Exception: confuse n00bs with this!
16:46:30 <sorear> yeah, every time someone runs ?undef
16:48:38 <jethr0> @let fibs = 1:1:zipWith (+) fibs (tail fibs)
16:48:39 <lambdabot> Defined.
16:48:48 <jethr0> > take 10 L.fibs
16:48:50 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
16:49:01 <jethr0> @undef
16:49:02 <lambdabot> Undefined.
16:49:17 <jethr0> nice! always neat new features in lambdabot
16:49:57 * sorear is currently studying to hack on lambdabot
16:50:10 <SamB_XP> studying?
16:50:15 <SamB_XP> you need to study now?
16:50:49 <SamB_XP> I didn't even really study in order to get it to work dynamically again!
16:50:56 <sorear> well, I need to figure out how everything works...
16:51:01 <SamB_XP> hahaha
16:51:47 <SamB_XP> you should just read the Plugin.* stuff
16:55:25 <sorear> yes, if I just wanted to add a plugin; but I've got vague ideas of how to make lb split-proof, so the irc layer is my main focus atm.
16:55:49 <jethr0> although i'm in some ways well advanced in haskell, some simple things will usually break my brain again and again :)
16:56:19 <jethr0> haskell is a nice intelligence meter, and i'm not faring that well
16:56:23 <LordBrain> examples
16:56:24 <LordBrain> :)
16:57:01 <jethr0> just everyday stuff...
16:57:04 <LordBrain> haskell is like math, everything is so simple wants you see it you wonder why you didnt already know it.
16:57:07 <Excedrin> how does the showHex stuff work?
16:57:10 <LordBrain> once
16:57:37 <jethr0> mainly it's haskell independent. haskell just shows you black-on-white that you really haven't understood the problem/the solution. in other languages you can code and code and never reach that insight
16:57:41 <xpika> does anyone know how to pass arguments to a haskell program from ghci?
16:58:01 <jethr0> xpika: ?
16:58:06 <LordBrain> a program like a function?
16:58:23 <LordBrain> do you mean an external process?
16:58:27 <xpika> i mean the command line arguments
16:58:31 <LordBrain> oh
16:58:34 <LordBrain> i was just looking at that
16:58:37 <xpika> but from inside ghci
16:58:45 <LordBrain> runInteractiveProcess
16:58:49 <jethr0> LordBrain: yes, haskell IS like math and i'm usually having my problems with math too
16:58:55 <xpika> :S
16:59:00 <Excedrin> xpika: getArgs ?
16:59:15 <LordBrain> you want to pass arguments to a child process?
16:59:28 <LordBrain> that you called using the shell command?
16:59:31 <allbery_b> I think he's using that and he wants to run main within ghci and specify command arguments
16:59:41 <xpika> yep
17:00:00 <allbery_b> and the only way I'm aware of to do it is to specify them to ghci (and not change them inside it)
17:00:40 <jethr0> k, good night
17:01:49 <allbery_b> s/not change/not be able to change/
17:03:25 <LordBrain> xpika: you just give the arguments in an array, to runInteractiveProcess or runProcess
17:03:30 <LordBrain> @hoogle runProcess
17:03:31 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
17:03:38 <complacent> anyone uses lhs2TeX & got the code made in a stupid way.. with strange characters
17:03:39 <complacent> ?
17:04:32 <LordBrain> notme
17:12:13 <xpika> @hoogle pretty
17:12:13 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
17:12:14 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
17:12:33 <xpika> @hoogle pprint
17:12:33 <lambdabot> Language.Haskell.TH.pprint :: Ppr a => a -> String
17:15:17 <mgsloan> > Language.Haskell.TH.pprint (5 :: Int)
17:15:18 <lambdabot>  add an instance declaration for (Ppr Int)
17:15:18 <lambdabot>   In the definition of `ylg': y...
17:15:35 <mgsloan> ah my bad, didn't see that class qualifier
17:22:50 <kermit_> How do you make main return a Show if it calls an infinite loop?
17:24:15 <xpika> @let a = 4
17:24:15 <lambdabot> <local>:2:0:     Multiple declarations of `L.a'     Declared at: <local>:1:0 ...
17:24:16 <xpika> > a
17:24:17 <lambdabot>  Not in scope: `a'
17:24:23 <monochrom> depends on how you determine that some loop is an infinite loop
17:25:14 <kermit_> Got it.  loopForever >> return ExitSuccess
17:26:00 <monochrom> actually I also want to remind you that the return value of main is rather useless.
17:26:17 <SamB_XP> monochrom: I thought it was shown
17:26:54 <monochrom> if you run something at the ghci prompt, yes. but this is not special to main.
17:27:20 <notsmack> wouldn't that make main :: Show a => IO a?
17:27:25 <monochrom> So, I thought by bringing up main, he meant using runghc or runhugs or running a compiled executable.
17:27:34 <SamB_XP> notsmack: no
17:27:44 <SamB_XP> main is whatever type it happens to be
17:28:03 <monochrom> Anyway the whole question is strange.  Time to invoke the "what are you really doing" spell.
17:28:17 <notsmack> monochrom: heh, indeed.
17:28:23 <SamB_XP> (also, note that () is *not* shown)
17:29:05 <SamB_XP> monochrom: um. actually. have you ever tried havin main return something other than ()?
17:30:05 <kermit_> It's an interactive program that keeps cycling through about 5 functions.
17:30:28 <kermit_> The real exit point is exitWith that's called at one point in the cycle
17:30:41 <kermit_> ("do you want to quit?")
17:31:30 <monochrom> main :: IO Int; main = return x where x=x+1
17:31:43 <monochrom> You wouldn't believe the experimental results I got.
17:32:03 <SamB_XP> monochrom: what results?
17:32:19 <monochrom> runhugs: finishes immediately.  runghc: hangs.  compile with ghc, run executable: finishes immediately.
17:32:45 <SamB_XP> HANGS?
17:32:50 <monochrom> YEAH!
17:32:52 <SamB_XP> oooookay!
17:32:52 <allbery_b> I was thinking he was testing/debugging a program he'd written which uses getArgs, and he wants to be able to run it with various command line arguments and see what it does
17:32:55 <SamB_XP> that is crazy.
17:33:03 <monochrom> but compiling is fine!
17:33:06 <allbery_b> (if this is xpika's question still)
17:33:12 <SamB_XP> maybe that was a transitive thing?
17:33:16 <SamB_XP> having the result printed...
17:33:18 <notsmack> does runghc just use ghci?
17:34:06 <sorear> IIRC ghci doesn't support blackholing
17:34:38 <sorear> run 'let x = x in x' in your ghci 6.6
17:34:52 <sorear> (IIRC 6.4 works too, but...)
17:34:53 <kermit_> What's so strange about it?  What if it's a desktop gui app or some sort of server or daemon?
17:35:29 <sorear> LB uses GHC (not i):
17:35:32 <monochrom> runghc wants to print the return value
17:35:33 <sorear> > let x = x in x
17:35:34 <lambdabot>  Add a type signature
17:35:37 <sorear> > let x = x in x :: Int
17:35:38 <lambdabot>  Exception: <<loop>>
17:36:00 <sorear> ^^^ error detected (<<loop>> means 'blackhole entered')
17:36:09 <monochrom> main = return 1  {- runghc will print 1 on this -}
17:36:54 <monochrom> main :: IO (Int -> Int); main = return f where f = f . f
17:37:02 <monochrom> this one doesn't hang runghc
17:37:32 <sorear> sure... it doesn't try to print unless there is an instance of Show
17:38:13 <monochrom> Another result I want to report.  Although runghc hangs, it does not consume cpu time.  Similarly sorear's code in ghci 6.6
17:38:41 <sorear> that's very odd
17:39:03 <monochrom> I think it is somehow conscious of blackholing.
17:39:11 <sorear> (perhaps it has something to do with the recent parallellism changes?)
17:39:17 <monochrom> YES! GHCi IS GAINING CONSCIOUSNESS!
17:39:44 <sorear> (i.e. it enters the blackhole, assumes another CPU put it there, and goes to sleep waiting for the result)
17:40:10 <monochrom> "It begins to learn at a geometric rate starting from 6.6.  At 7.3.4.5, it becomes fully self-aware..."
17:40:39 <monochrom> Yes that actually makes sense.  I mean sorear's, not mine (haha)
17:41:09 <int-e> at 7.5.2, it learns how to use unsafePerformIO to control nuclear weapons? oh my.
17:42:59 <sorear> so, I guess the solution is to not ever use 4 component versions? :)
17:44:28 <kermit_> What about a continuatino?  Can that be turned into a jump if it's a tail call?
17:44:34 <kermit_> continuation
17:45:30 <monochrom> Every time SPJ builds ghc head, it learns at a geometric rate.  At 7.3.4.5, the darc repo becomes fully self-aware and begins to manage releases itself, causing Ian to lose his job.  At 7.5.2, it determines that Windows is holding back humankind, and initiates erasure instructions to the windows repo.
17:45:46 <monochrom> Yes all continuations are tail jumps.
17:47:19 <kermit_> That's good.  Here's another question:
17:47:44 <kermit_> Can a function be inlined that's passed to another function?
17:47:54 <monochrom> yes
17:48:11 <kermit_> Suppose it's a small function passed into the belly of a huge loop.
17:48:37 <kermit_> Do you have to declare it inline?
17:48:38 <sorear> how many uses of this huge loop are there?
17:48:46 <sorear> perhaps
17:49:01 <kermit_> more than one.
17:49:15 <monochrom> If you declare, that helps.  If you don't declare, the optimizer may still inline.
17:49:24 <sorear> if you have more uses of the loop than different functions, you should probably use {-#SPECIALIZE#-} insteadd
17:49:47 <sorear> (as always, profile first, and look at the generated code)
17:50:50 <kermit_> This is really important.  Macros naturally generate inline code, but HOFs don't.
17:51:10 <monochrom> I don't want to say that speed and code optimization are not of your concern.
17:52:08 <monochrom> But I do want to say that until you know Haskell well, these questions are premature.  Most definitely the answers don't make sense until then.
17:52:17 <sorear> C. A. R. Hoare: "Premature optimization is the root of all evil."  <--  you cannot program in haskell without remembering this, and I speak from experience.
17:52:27 <monochrom> This applies to all languages, not just haskell.
17:52:31 <ndm|bristol_> i am working on an optimiser to which the answer is "it knows more than you do, stop trying"
17:53:11 <monochrom> It is equally premature to ask "which variables go to registers" before you know C well.
17:53:46 <ndm|bristol_> and ultimately impossible to persaude the compiler anyway...
17:54:37 <TSC> All of them!
17:54:44 <sorear> Also, haskell has an extremely good foreign interface. *IFF* it is too slow, by all means rewrite 10% of your code in C. (see 90/10 rule)
17:55:52 <audreyt> except when you have FFI callbacks... the overhead there is a bit high
17:56:02 <audreyt> *lots of FFI callbacks
17:56:08 <audreyt> but otherwise FFI works beautifully
17:59:00 <kermit_> I'm interested in how much of the market FPLs can take over.
17:59:09 <monochrom> Note that you can always perform experiments and benchmarks.  Compile with ghc -O, then measure speed and memory.  Oh it runs in 0.01 second and uses 1M memory.  Does it inline and optimize tail calls?  Who knows, and why should it matter.  Does 0.01 second and 1M sound good enough to you?  That's something you can take or leave.
17:59:23 <kermit_> Can the 10% C code be whittled down to 1%?
17:59:27 <ndm|bristol_> no, 1Mb sounds way too much!
17:59:48 <kermit_> It makes a difference in how useful the language is.
18:00:01 <monochrom> YES SO DO THE DAMN BENCHMARKS.
18:00:50 <ndm|bristol_> kermit_: just write the code, and only worry when you have a problem - compilers are getting betterall the time
18:01:00 <xpika> @hoogle matrix
18:01:01 <lambdabot> Text.Html.BlockTable.getMatrix :: BlockTable a -> [[(a, (Int, Int))]]
18:01:04 <kermit_> My program is working now.
18:01:42 <kermit_> I like to worry.  It's interesting.
18:02:00 <monochrom> That satisfies my definition of trolling, sorry.
18:03:12 <kermit_> I'm asking questions about how the language works.
18:03:23 <ndm|bristol_> kermit_: any specific questions?
18:05:17 <SamB> kermit_: wait, 10% C?
18:05:31 <kermit_> I've asked most of them so far.  Sorry monochrome, I like analyzing things.
18:05:59 <SamB> the language works by magic
18:06:08 <SamB> the implementations are another matter
18:06:48 <kermit_> That's what sorear said.  I'm just saying, if you want to sell a PHB on Haskell, how much do you have to offer.
18:07:30 <ndm|bristol_> more reliable, easier to write, easier to maintain
18:07:37 <SamB_XP> well, usin haskell we can afford to get him a modern etch-a-sketch
18:07:37 <ndm|bristol_> (if you can find anyone to write in it)
18:07:53 <monochrom> benchmarks for the PHB.
18:07:59 <kermit_> Ignore performance too much and you get bloatware.
18:08:10 <SamB_XP> you know, with blue screens of death
18:08:20 <ndm|bristol_> kermit_: the programmer can ignore the performance, the compiler can fix up most things afterwards
18:08:27 <SamB_XP> instead of one of those lame red-bordered black & white models
18:09:09 <kermit_> Joel calls it the "leaky abstraction".
18:09:28 <ndm|bristol_> kermit_: Haskell is rarely leaky, apart from space leaks (sadly)
18:09:51 <SamB_XP> we need better heap profiling tools
18:10:11 <monochrom> No, ndm|bristol_, leaky abstraction refers to another thing, unrelated to memory.
18:10:47 <ndm|bristol_> monochrom: i know, but it just so happens that a leaky abstraction is where you need to know the underlying details, and in haskell the biggest problem for that _is_ space leaks
18:10:50 <sorear> 10% C should be as high as you'll ever need (see 90/10 rule), but you should put off writing C as long as possible because programmer time is almost always more expensive than computer time.
18:10:50 <MarcWeber> How to chain preprocessors using cabal? Is the only defining a custom handler? Or can I specify preprocessors using the filename eg File.hs.gc.cpp  (<- This might be useful)
18:11:02 <monochrom> alright, sorry
18:11:17 <monochrom> that's a good pun
18:11:44 <ndm|bristol_> monochrom: yes, it is an interesting coincidence
18:16:40 <SamB_XP> sorear: what if the code you write ends up being bad-looking C (because it is written in Haskell instead of C)?
18:17:06 <Cale> Mostly, what you really need to know to understand performance of Haskell code is just how lazy evaluation is defined. It's pretty rare that you need to push any deeper than that. Especially so now that we have Data.ByteString.
18:17:09 <ndm|bristol_> SamB_XP: get a better optimiser
18:17:24 <SamB_XP> maybe you were trying to use a library written in C?
18:17:35 <monochrom> But in my opinion, these are not space leaks, and these are not leaky abstractions either.  I know how to do the space analysis compositionally.  I liken this to the name "bugs": instead of admitting the programmer is not using the right programming logic, a name is chosen to imply something is working behind your back to trick you.
18:18:14 <ndm|bristol_> i disagree, space leaks bite you unexpectedly, and are hard to fix
18:18:32 <monochrom> They said the same thing about bugs.
18:18:36 <SamB_XP> ndm|bristol_: why do you need a special nick to be in bristol?
18:18:55 <Cale> When people expect things to have space behaviour as if they were evaluated strictly, and they don't, then they feel cheated.
18:19:07 <Cale> SamB_XP: what's with the _XP?
18:19:11 <ndm|bristol_> SamB_XP: and you need a special nick to be running Windows? - the answer is because there are quite a lot of things which i can't do here, for example have no Yhc installation etc
18:19:15 <monochrom> haha Cale you're mean
18:19:25 <monochrom> and you, ndm :)
18:19:35 <SamB_XP> ndm|bristol_: ah.
18:19:57 <SamB_XP> monochrom: ndm actually had something to say though
18:20:42 <SamB_XP> and apparantly "stay connected" is one of the things ndm can't do in bristol?
18:21:22 <Cale> Perhaps I just haven't written enough Haskell code, but I haven't run into that many space problems that were all that hard to track down. Especially when you turn profiling on and it tells you exactly where all the allocation is happening.
18:21:25 <Igloo> He seems to be doing fine to me...
18:21:34 * SamB_XP wonders how hard it would be to hotwire x-chat so that anything he said appeared to eminate from his other x-chat?
18:21:35 <ndm> SamB_XP: my router froze up :( - until i got back (a few hours ago),it had an uptime of 3 months, the second i get back it freezes
18:21:49 <SamB_XP> eek!
18:21:56 <SamB_XP> reminds me of magic school bus
18:22:05 <Cale> Is the XP for X-treme Programming?
18:22:11 <Igloo> I'm sure there's a bad Cockney rhyming slang joke in there somewhere anyway, but I don't know what it is and probably no-one else would get it anyway
18:22:14 * ndm things he might need to do a darcs checkpoint, i now have 1626 patches and no checkpoints
18:22:15 <SamB_XP> only instead of person getting back, it goes belly-up when part warranty expires
18:22:28 <SamB_XP> Cale: no, its worse than that!
18:22:28 <monochrom> Naw, XP stands for Vista.
18:22:35 <SamB_XP> monochrom: haw
18:22:56 <Cale> Didn't you hear? "XP" is dead, everyone's "Agile" now.
18:23:16 <SamB_XP> Cale: silly
18:23:37 <monochrom> "SamB" is on Windows 98 and "SamB_XP" is on Windows Vista (alpha version).
18:23:52 <SamB_XP> monochrom: ... right
18:23:54 <SamB_XP> okay.
18:26:04 <LordBrain> @paste
18:26:04 <lambdabot> http://paste.lisp.org/new/haskell
18:28:30 <mbishop> anyone tried that "brooklyn style" pizza? a little off topic, but I might eat some while learnin some haskell :P
18:28:50 <lisppaste2> LordBrain pasted "Help me with declaring an Instance of Applicative" at http://paste.lisp.org/display/33080
18:29:11 <monochrom> paste your pizza in the pastebin and we'll see
18:29:14 <sorear> Applicative FUNctors
18:29:51 <sorear> oh, it's a fairly simple wart
18:29:59 <LordBrain> mine is?
18:30:05 <LordBrain> what's my wart?
18:30:08 <sorear> any instance declaration must be:
18:30:27 <sorear> instance F Foo; i F (Foo a) ; i F (Foo a b) ; etc
18:30:46 <sorear> they *must* be type variables - specific types won't work.
18:30:56 <sorear> The best workaround is -fglasgow-exts.
18:31:07 <sorear> if you want to stay 98, you can do:
18:31:20 <LordBrain> i'm not understanding what that means with the semicolons..
18:31:32 <sorear> class IsKeys x where toKeys :: x -> Keys ; fromKeys :: Keys -> x
18:31:33 <allbery_b> semicolons are virtual newlines
18:31:45 <LordBrain> I dont need to stay 98, but i do want to know what I'm doing...
18:31:55 <sorear> instance IsKeys Keys where toKeys = id ; fromKeys = id
18:32:11 <sorear> instance IsKeys k => Applicative (Map k) where ...
18:32:33 <thelsdj> mbishop: you mean the one from dominos? i like it ok
18:32:40 <sorear> basically, H98 only lets you match the topmost constructor for instances.
18:32:48 <mbishop> thelsdj: nothing special?
18:33:07 <sorear> if you want to define (say) [Char] as an instance of a class, you must factor it into:
18:33:12 <thelsdj> it really just means the pieces are huge, like only 4-6 slices on the thing (can't remember which it was)
18:33:22 <sorear>  * A single-element class of Char
18:33:34 <thelsdj> plus if you get the pepperoni one it has extra large pieces of pepperoni
18:33:41 <sorear>   * An instance (of the single-element class) for Char
18:34:07 <sorear>  * An instance (of the class you want to instantate at [Char]) for IsChar a => [a]
18:34:20 <sorear> it's an ugly hack, but it's the standard idiom.
18:34:27 <sorear> Or just use -fglasgow-exts.
18:34:43 <SamB_XP> and it really don't work too well for also having an instance for [a]
18:34:55 <SamB_XP> maybe the idiom used by Show is a better example?
18:35:09 <SamB_XP> @hoogle showList
18:35:09 <lambdabot> Prelude.showList :: Show a => [a] -> ShowS
18:35:10 <lambdabot> Text.Show.showListWith :: (a -> ShowS) -> [a] -> ShowS
18:37:23 <Syrin> heyyy
18:37:28 <Syrin> I need some help with sockets
18:37:36 <Syrin> They aren't very nice :(
18:38:13 <Syrin> all these functions in Network.Socket take Socket and something else as arguments
18:38:21 <Syrin> but the socket function returns an IO Socket
18:38:31 <Syrin> Is there some way to get the Socket out of the IO bit?
18:39:17 <Excedrin> see >>=
18:40:48 <mbishop> http://www.ccs.neu.edu/home/samth/typed-scheme.html
18:40:50 <lambdabot> Title: Typed Scheme
18:41:53 <kpreid> Syrin: that's not specific to sockets, that's how all IO works.
18:42:01 <Syrin> Oh..
18:49:33 <Syrin> bleh, this is so confusin
18:49:55 <Syrin> I'm just trying to figure out how to work this IO stuff in GHCi
18:50:04 <Syrin> so I have socket s of type IO Socket
18:50:17 <Syrin> and I want do to connect s a where a is a SockAddr
18:50:24 <ndm> Syrin: read an IO tutorial is my suggestion
18:50:27 <Syrin> Where?
18:50:35 <ndm> @where YAHT
18:50:35 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
18:50:36 <Excedrin> @where yaht
18:50:36 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
18:50:59 <Igloo> Syrin: s isn't a socket, it's an action that will make a socket when executed
18:51:10 <Syrin> ...oh.
18:51:20 <Igloo> Syrin: You probably want something like    do s' <- s; connect s a
18:51:27 <Igloo> s' there has type Socket
18:52:01 <Excedrin> Syrin: this might also be useful http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
18:52:02 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
18:58:13 <mbishop> Excedrin: if nothing else, it's useful to me, I was looking for that earlier :)
19:15:11 <ray> there's no language where i haven't done the "make an irc bot" tutorial :P
19:31:57 <Syrin> agh
19:32:04 <Syrin> Now when I try to do connect s a
19:32:24 <Syrin> It says *** Exception: connect: failed (Socket operation on non-socket (WSAENOTSOCK))
19:32:43 <Syrin> but :t s shows s :: Socket
19:32:56 <monochrom> Network.Socket?
19:32:59 <Syrin> yes
19:33:15 <Syrin> Maybe I'm making s wrong
19:35:00 <monochrom> Have you considered using just Network instead?  I.e., connectTo.
19:35:13 <Syrin> Yes, but that's the lazy way out :(
19:35:15 <Syrin> and I don't learn anything
19:35:35 <monochrom> OK, nice.
19:38:12 * bryan has stated his Christmas break lurk
19:39:01 <kermit> monochrom, thanks for the help.  My first Haskell program ever is running nicely.
19:39:01 <sjanssen> barely lurking if you announce yourself :)
19:41:28 <monochrom> do { s <- socket AF_INET Stream 6; connect s (SockAddrInet 8080 blahblah); ... }  like that?
19:41:52 <Syrin> yea, and it said s isn't a valid socket object
19:41:53 <Syrin> or something
19:42:54 <Syrin> what's the 6 for?
19:43:00 <monochrom> tcp
19:43:03 <Syrin> ah
19:44:10 <Syrin> oh
19:44:13 <Syrin> I was using mkSocket
19:44:23 <monochrom> I looked up /etc/protocols for "protocol number"
19:49:43 <monochrom> Wow mkSocket is very low level.  I bet the first CInt parameter has to be a file descriptor of an opened socket first.  I.e., you use C code to obtain a socket file descriptor, which is a CInt, then you use mkSocket to coerce it to Socket.
19:50:36 <Syrin> what's /etc/protocols?
19:50:54 <sorear> it's a Map from protocol names (http) to ports (80)
19:51:07 <Syrin> oh
19:51:16 <sorear> no, wait, that's /etc/services
19:51:36 <sorear> /etc/protocol is IP protocol numbers
19:51:38 <Syrin> Oh, is this in unix or something?
19:51:42 <jcreigh> Syrin: yes
19:51:46 <sorear> tcp, icmp, etc
19:51:50 <Syrin> Oh. :P
19:52:00 <Syrin> Protocol numbers is silly
19:52:04 <sorear> what, some people don't use unix :)
19:52:50 <monochrom> "WSAE____" suggests "windows socket application error" :)
19:53:15 <monochrom> but don't use mkSocket.  It is for something else.  use socket.
19:53:15 <|shad0w|> Syrin: you will find the same files on a windows box
19:53:26 <jcreigh> Syrin: well, mostly all that gets used is TCP, UDP and ICMP, and the odd tunneling protocol.
19:53:34 <jcreigh> |shad0w|: where?
19:53:42 <Syrin> I just googled it, lol
19:53:50 <|shad0w|> C:\WINDOWS\system32\drivers\etc
19:54:32 <jcreigh> |shad0w|: hmm, really. I've had to modify the hosts file on Windows, but I never noticed those files. Guess I wasn't paying attention.
19:55:05 <|shad0w|> :)
19:55:15 <Taral> who maintains hat these days?
19:55:24 <|shad0w|> learn something new everyday, I never really noticed before either
19:56:13 <xpika> @where prelude
19:56:14 <lambdabot> I know nothing about prelude.
19:56:42 <xpika> that sounds right
19:59:05 <jeremy_c> Anyone on FreeBSD and use hscurses? I cannot get it to even begin a make :-(
19:59:53 <xpika> @where anything
19:59:53 <lambdabot> I know nothing about anything.
20:13:01 <Syrin> hrm
20:13:24 <Syrin> Why is printf giving me Exception: Prelude.undefined?
20:14:58 <sjanssen> strange
20:15:06 <sjanssen> are you passing a bad format string?
20:15:27 <Syrin> nope
20:15:38 <Syrin> printf "%s\n" "Hello"
20:15:48 <Syrin> Hello
20:15:48 <Syrin> *** Exception: Prelude.undefined
20:16:39 <liquidengineer> Hello
20:16:48 <monochrom> printf "%s\n" "Hello" :: IO ()
20:17:09 <Syrin> that... works.
20:17:11 <Syrin> why? :S
20:17:13 <liquidengineer> I'd like to create a haskell program to interact with a web service
20:17:19 <jcreigh> > printf "%d\n" 123 :: String
20:17:19 <liquidengineer> i.e., through SOAP
20:17:19 <lambdabot>  Add a type signature
20:17:27 <monochrom> The short reason is ghci is trying to be too general.  In a source code file you will not need worry.
20:17:33 <liquidengineer> is there a framework for this?
20:17:42 <Syrin> Ah. Stupid GHCI
20:17:46 <Syrin> GHCi, even
20:18:02 <monochrom> No, not stupid.  Too smart.
20:18:09 <Syrin> No, stupid =(
20:18:23 <monochrom> When you know Haskell inside out you'll know why.
20:18:48 <jcreigh> umm...why doesn't the printf to string (ie, sprintf) work with lambdabot?
20:18:49 <monochrom> Let me use an analogy.
20:19:03 <Syrin> No, I won't let you.
20:19:04 <monochrom> If you ask a person on the street "what is 1+1", he says "2" immediately.
20:19:16 <liquidengineer> hopefully
20:19:17 <Syrin> Well, if they're trying to be smart
20:19:22 <Syrin> they'll say '3' or '11'
20:19:25 <monochrom> If you ask Russell "what is 1+1", he goes write two books on that.
20:19:37 <Syrin> Russell?
20:20:00 <LordBrain> Bertrand
20:20:04 <LordBrain> i guess he means
20:20:05 <monochrom> He'll also say "hmm your question is not very well defined.  What is 1?  What is +?  What is "what is"?"
20:20:46 <monochrom> You can't say the person on the street is smarter than Russell.  Quite the contrary, you need to know that Russell is too smart in order to explain this phenomenon.
20:21:31 <monochrom> Note that I did not say "ghci tries to be smart".  ghci is positively smart, not trying.
20:21:41 <Syrin> Wooow
20:21:47 <Syrin> Uhm
20:21:54 <Syrin> Why are you telling me this?
20:22:19 <monochrom> To explain to you that ghci is not stupid trying to be smart.  It is really smart.
20:22:21 <Syrin> When I said 'stupid GHCi' I didn't actually mean stupid as in 'dumb'
20:22:41 <Syrin> I just meant stupid like how people say 'retarded' or 'gay'
20:22:55 <monochrom> OK.
20:23:04 <Syrin> lol :S
20:23:23 <Shimei> Is there a more technical explanation of that somewhere?
20:23:28 <monochrom> I assume everyone is precise in wording.
20:23:38 <Lemmih> jcreigh: It does work.
20:24:02 <Shimei> (that being GHCi's unintuitive behavior)
20:24:06 <jcreigh> Lemmih: ah, sorry, I meant, why doesn't it yield "123\n"? :)
20:24:14 <LordBrain> which behavior are we discussing?
20:24:14 <Lemmih> > printf "%d\n" (123::Int) :: String
20:24:16 <lambdabot>  "123\n"
20:24:22 <LordBrain> i missed
20:24:23 <Lemmih> jcreigh: User error (:
20:24:23 <jcreigh> oh, okay
20:24:50 <jcreigh> I fell into the "it works in ghci!" trap.
20:25:00 <monochrom> ghci looks at the type of what you enter, and based on the type can have different behaviours.
20:26:13 <monochrom> But printf "blah" "blah" has many possible types.  String, a -> String, a -> b -> String, ....  and then also IO String, a -> IO String, a -> b -> IO String, ...
20:26:38 <monochrom> ghci probably couldn't decide which one it is.
20:26:58 <liquidengineer> Hmm
20:27:01 <liquidengineer> I just found HAIFA
20:27:02 <Shimei> How does GHC know which one then?
20:27:03 <liquidengineer> anyone use it?
20:27:27 <LordBrain> it uses the hindly milner type inference algorithm
20:27:29 <monochrom> You submit to GHC a whole source code file, chances are there is enough context to tell.
20:28:23 <monochrom> The moment you write "main = do { ... ; printf blah blah; ... }"  the fate is sealed
20:28:27 <Shimei> Ah, I see. So would GHCi also be okay with printf if it's passed an entire file?
20:28:29 <monochrom> But not when standalone.
20:28:37 <monochrom> YES!
20:29:09 <LordBrain> an entire file might be one line ...
20:29:23 <SamB_XP> doesn't GHCi check to see if it typechecks as IO a first?
20:29:28 <monochrom> do { printf "%s\n" "Hello"; return () }   try this with ghci.  even that is enough context.
20:30:01 <SamB_XP> um.
20:30:05 <monochrom> Ah, you may be right.  My explanation may be wrong.
20:30:06 <LordBrain> its possible to have type ambiguity in your programs, in haskell... that's a side effect of type classes, but i do think it is worth it.. just have to add signatures ocassionally.
20:30:11 <SamB_XP> @undo do { printf "%s\n" "Hello"; return () }
20:30:12 <lambdabot> printf "%s\n" "Hello" >> return ()
20:30:21 <SamB_XP> that frankly looks nicer to me
20:30:42 <liquidengineer> Why are you trying to emulate a C function?  I'm just curious
20:30:49 <LordBrain> its probably better to learn haskell without the do notation first
20:31:08 <SamB_XP> emulate a C function? I thought the purpose of printf was to demonstrate the oleg-nature!
20:31:31 <liquidengineer> ?
20:31:39 <Shimei> Yeah, do syntax makes my brain think it's C until I hit my internal interpreter with a stick.
20:31:41 <SamB_XP> liquidengineer: type hackery!
20:31:42 <jcreigh> liquidengineer: because printf is handy sometimes.
20:31:50 <liquidengineer> ah
20:31:51 <liquidengineer> yeah
20:32:01 <liquidengineer> I never programmed much C
20:32:03 <Lemmih> SamB_XP: It's not really the kind of type hackery that Oleg does.
20:32:04 <liquidengineer> so I've never learned to use it to its full evil hacker potential
20:32:04 <monochrom> SamB_XP is right.  I was wrong.  Forget everything I said.
20:32:22 <liquidengineer> So, anyone have any reccomendations for interacting with web services?
20:32:27 <SamB_XP> monochrom: it could change without warning though, probably
20:32:32 <Lemmih> SamB_XP: I think he would be more interested in a type-safe printf.
20:32:34 <SamB_XP> so maybe you will be right later or something
20:32:42 <SamB_XP> Lemmih: true.
20:32:44 <LordBrain> in ocaml i think there is never type ambiguity
20:32:56 <SamB_XP> LordBrain: that is because ocaml is boring
20:32:57 <LordBrain> but the type system is less powerful
20:33:00 <LordBrain> yeah
20:33:06 <monochrom> OK, new explanation.  ghci first tries "IO a" or something.  That will immediately work, and ghci will go with it.  But: the version of printf for IO returns undefined.  always.
20:33:21 <jcreigh> @hoogle (MonadPlus m) => (a -> Bool) -> a -> m a
20:33:22 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
20:33:43 <monochrom> () <- printf "hello" :: IO ()    try this on ghci, it is still undefined.
20:33:46 <SamB_XP> @instance PrintfType
20:33:47 <lambdabot> Maybe you meant: instances instances-importing
20:33:50 <SamB_XP> @instances PrintfType
20:33:51 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:34:03 <SamB_XP> @instances-importing Text.Printf PrintfType
20:34:03 <jcreigh> is there some built-in function "mfilter f x = if f x then return x else mzero"?
20:34:05 <lambdabot> (a -> r), IO a, [c]
20:34:13 <sorear> ?hoogle guard
20:34:14 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
20:34:14 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
20:34:14 <lambdabot> Language.Haskell.TH.Guard :: data Guard
20:34:17 <SamB_XP> jcreigh: I remember something like that
20:34:24 <SamB_XP> sorear: that isn't it
20:34:34 <monochrom> oh well it's very complicated and no one cares anymore
20:34:41 <Syrin> Nope
20:34:50 <SamB_XP> @hoogle Bool -> m a -> m a
20:34:51 <lambdabot> Control.Exception.assert :: Bool -> a -> a
20:34:55 <SamB_XP> hmm.
20:35:09 <SamB_XP> @hoogle MonadZero m => m a -> m a
20:35:09 <lambdabot> Prelude.id :: a -> a
20:35:10 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
20:35:10 <lambdabot> Prelude.asTypeOf :: a -> a -> a
20:35:14 <SamB_XP> no.
20:35:15 <sorear> ?djinn MonadPlus m => (a -> Bool) -> a -> m a
20:35:16 <lambdabot> Cannot parse command
20:35:20 <SamB_XP> hahaha
20:36:04 <mgsloan> hey lyang, do you think the gtk2hs debs will work on ubuntu?
20:36:12 <mgsloan> *liyang
20:36:14 <sorear> ?djinn (forall a b x. ((a -> m a), (m a -> (a -> m b) -> m b), m x) -> (a -> Bool) -> a -> m a
20:36:14 <lambdabot> Cannot parse command
20:36:20 <jcreigh> Somebody should write something for GHC that notices when you define a function that's builtin, and issues a notice that says what the standard name is. :)
20:36:23 <SamB_XP> @pl \f x -> if f x then return x else mzero
20:36:24 <lambdabot> flip flip mzero . (`ap` return) . (if' .)
20:36:24 <sorear> what, no rank2? :)
20:36:30 <SamB_XP> hmm
20:36:39 <sorear> jcreigh:
20:36:40 <SamB_XP> that isn't very nice
20:36:42 <sorear> ?where drhaskell
20:36:43 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
20:36:49 * SamB_XP thinks it not know mzero
20:37:12 <sorear> ^^^ it's not integrated with GHCi, but it does what you want, and a little more
20:37:22 <LordBrain> maybe ocaml is an easier step to learn than haskell, i know i didnt like it as much tho
20:37:40 <Shimei> I think it is, especially from an imperative background.
20:37:48 <jcreigh> sorear: wow. That looks really cool. Thanks for the link.
20:43:42 <monochrom> I am not sure I get the "count in spanish" joke on haskell-cafe
20:44:48 * jcreigh doesn't either
20:45:01 <jcreigh> rather, I'm *sure* I don't get it.
20:45:38 <jcreigh> wow, Parsec + do-notation FTW. This is awesome stuff.
20:45:47 * jcreigh is working on a toy regex engine.
20:46:01 <monochrom> yes
20:48:26 * mgsloan wishes he could just get the bloody gtk2hs files instead of installer crap
20:48:33 <mgsloan> (bins not source
20:51:10 <liquidengineer> urgh
20:51:11 <liquidengineer> wonderful
20:51:27 <liquidengineer> Here's a Haskell library that generates proxies to access web services...using .NET
20:51:35 <liquidengineer> as in, C#.NET
20:51:44 <mgsloan> I've tried compiling, but it requires Data.FiniteMap which is apparently deprecated, and perhaps removed in my ghc
20:53:57 <mgsloan> liquidengineer: nice language, as far as imperative langs go
20:56:10 <liquidengineer> mgsloan: yeah, but the great thing about Haskell is it's platform independent
20:56:13 <liquidengineer> and free
20:56:19 <liquidengineer> C# is Windows only
20:56:21 <liquidengineer> and not free
20:56:28 <liquidengineer> and I'm on a Mac, and poor. :P
20:56:37 <mgsloan> err, C# binaries run on mac, linux, and windows
20:56:38 <mbishop> which xml library would I use if I wanted to make a VERY simple weather feed reader
20:56:48 <mgsloan> binaries. you don't even have to recompile
20:56:52 <mbishop> C# is a language, it runs anywhere there is a CLR VM
20:56:59 <liquidengineer> mgsloan: yeah, but not exe's.
20:57:02 <mgsloan> yep
20:57:09 <mgsloan> yes, the exes.
20:57:11 <sorear> C# doesn't need a CLR, does it?
20:57:21 <mgsloan> it does - the .net clr
20:57:22 <sorear> any more than Java needs a JVM?
20:57:33 <liquidengineer> are
20:57:36 <liquidengineer> err.
20:57:41 <liquidengineer> are the CLRs free?
20:57:42 <sorear> why can't I write a C#-to-i386 compiler?
20:57:46 <sorear> ?go mono
20:57:47 <glguy> Java requires the JRE
20:57:48 <lambdabot> http://www.mono-project.com/
20:57:48 <lambdabot> Title: Main Page - Mono
20:57:51 <liquidengineer> oh
20:57:52 <liquidengineer> Mono
20:58:09 <sorear> glguy: what about gcj?
20:58:21 <liquidengineer> I just want to make a program taht can interface with a SO
20:58:24 <glguy> Oh, I see where you are going
20:58:24 <liquidengineer> AP
20:58:26 <liquidengineer> err...
20:58:34 <liquidengineer> SOAP service
20:58:36 * glguy has never used gcj, doesn't know
20:58:58 <SamB_XP> gcj just builds an ELF
20:59:04 <SamB_XP> at least on Linux it does
20:59:21 <liquidengineer> So I'm wondering if there are any packages ya'll can reccomend that do that
20:59:32 <sorear> Haskell can compile to CLR, but it doesn't need one - there exist native code haskell compilers (and C-targeting, and interpreters, and YHC-bytecode-targeting, etc, etc)
21:00:26 <mbishop> What library should I use if I want to make a simple weather feed parser? there are like 3 XML libraries for haskell, not sure which would be best for doing simple parsing
21:00:53 <SamB_XP> mbishop: hmm, what was the third one?
21:00:55 <monochrom> Have you considered HXT?  Cale recently wrote a 50-line RSS leecher.
21:00:59 <SamB_XP> I know HXT and HaXml
21:01:38 <sjanssen> mbishop: http://cale.yi.org/index.php/HRSS is the program that monochrom mentioned
21:01:42 <lambdabot> Title: HRSS - CaleWiki
21:02:55 <SamB_XP> last I knew HXT had an overabundance of exports and a dearth (that does mean that there isn't enough, right?) of documentation...
21:05:12 <monochrom> But you have wetware, that's me, cale, xerox
21:05:13 <notsmack> an acute insufficiency
21:05:44 <liquidengineer> Hmm
21:05:54 <liquidengineer> Nothing in the standard library
21:06:01 <liquidengineer> this must not be something most people look to Haskell to do
21:08:29 <sjanssen> well, the Haskell standard libraries are fairly small
21:09:13 <sjanssen> compared to languages that include XML libraries
21:09:20 <SamB_XP> most people see SOAP and say "crazy!"
21:09:30 <liquidengineer> I'm used to Python and it's gargauntan we-think-of-everything libraries
21:09:40 <liquidengineer> and I'm interseted in writing a little program to fetch the local movie times
21:09:54 <liquidengineer> so I thought using web a web service that does that would be ideal.
21:09:56 * SamB_XP would suggest finding a more RESTful API
21:10:04 <liquidengineer> RESTful?
21:10:50 <SamB_XP> basically I mean something where you don't have to push a big blob of XML up there just to get some data...
21:11:33 <liquidengineer> what should I look for?
21:16:00 <liquidengineer> some sort of XML feed?
21:17:10 <SamB_XP> would be nice
21:20:03 <LordBrain> i find i spend a lot more time cleaning up my code in haskell, refactoring, redesigning etc...  is that something that goes away as i become more expert with the functional paradigm?
21:20:22 <LordBrain> or is it just characteristic of programming in haskell
21:20:44 <LordBrain> because it incourages so much pride....
21:21:23 <dmead> lol
21:21:24 <dmead> no
21:21:28 <dmead> you can always refactor
21:21:54 <liquidengineer> I get where you're coming from
21:22:03 <liquidengineer> I usually have to wrack my brain to think up optimizations in other languages
21:22:11 <liquidengineer> but in Hakell it's really simple to see where you can tweak
21:22:48 <LordBrain> even when its not simple, its enticing....
21:22:54 <lisppaste2> glguy pasted "Quicksort for MArray" at http://paste.lisp.org/display/33088
21:23:03 <glguy> some of you might have seen my earlier iteration
21:23:09 <glguy> but I wanted to share it with anyone else
21:23:15 <glguy> the final version, that is
21:24:11 <liquidengineer> Does anyone know who does the TextMate Haskell bundle?
21:24:16 <sorear> ?quote glguy
21:24:17 <lambdabot>  this is like Web 5GL. I like it
21:24:20 <SamB_XP> LordBrain: that is how you program in Haskell, I think.
21:24:59 <LordBrain> It's like they say, an artist's work is never done
21:25:05 <sorear> I forgot who said this: "effort is 50% make-it-work, 50% make-it-one-line"
21:25:06 <LordBrain> :)
21:25:17 <falconair> liquidengineer: do you want to know how to install the textmate bundle or how it actually works?
21:25:17 <sorear> glguy - that yours?
21:25:21 <glguy> I typically get a first version, and stare at it and realize how much simpler the problem is now that I understand it
21:25:25 <liquidengineer> sorear: a perl programmer, of course.
21:25:27 <glguy> sorear: the algorithm is from wikipedia
21:25:32 <glguy> sorear: the Haskell is all mine
21:25:43 <liquidengineer> falconair: A friend and I made some changes to it
21:25:51 <liquidengineer> I'd like to submit them to the repository
21:26:04 <SamB_XP> liquidengineer: oh, I thought you were talking about the FPS benchmarks
21:26:13 <falconair> liquidengineer: oh, i don't know then, there is #textmate, they should be able to help you with that one
21:26:22 <SamB_XP> or, er, I thought it was talking about thme rather
21:26:43 <glguy> sorear: what do you think? does it make quicksort more or less obvious :)
21:26:44 <Taral> okay, so hat still doesn't work quite right, but I got enough answers out of it to understand why my program is failing.
21:31:11 <sorear> glguy: I cannot comment for I have already reached quicksort-enlightenment
21:31:41 <liquidengineer> grar
21:31:51 <liquidengineer> I can't find a site that does xml feeds for showtimes
21:31:54 <sorear> (there is nothing you can do to make the algorithm more obvious than the string "quicksort" already does)
21:32:08 <liquidengineer> there's one specifically for some place in chicago, but I need to be able to supply a custom zip code
21:33:09 <kmb_> @type map
21:33:10 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
21:34:01 <glguy> sorear: =)
21:34:04 <monochrom> Heh, now you have to submit an html form too :)
21:34:25 * allbery_b wonders if State was the wrong way to memoify this silliness
21:35:09 <glguy> sorear: I just wanted to make sure you weren't asking if it was mine so you could ridicule it without worrying about my feelings ;)
21:35:37 <allbery_b> (calculating a series of values which often reuse intermediate values, but not in a nicely fixed recursion like (say) fib)
21:36:49 <allbery_b> oh well, maybe I'll put it up tomorrow night; I should be heading to bed
21:36:54 <monochrom> State is ok but the key is what data structure you put in your State.
21:37:25 <monochrom> Usually array or map or sequence (finger tree internally) is ok.
21:37:40 <allbery_b> it's a map from parameters to results, plus a base structure just because it's always fixed and I'm tired of carrying it around explicitly
21:37:41 <monochrom> I would ST it and use STArray
21:37:52 <monochrom> I mean usually
21:39:25 <allbery_b> so I have functions of the form: zeman base offset time -- base is an enum of possible bases, many of which invoke zeman again with other fixed arguments
21:41:31 <allbery_b> (two forms of zeman devolve to other more basic operations, which are even more crucial to cache because almost everything ends up depending on them)
21:42:16 <allbery_b> oh well, I'll finish this conversion at some point and stick it up on a web page for critiquing (it's perhaps a bit large even to pastebot)
21:43:06 <glguy> sorear: (as a final comment, I wrote that as a response to "quicksort in Haskell is tree sort"
21:43:27 <sorear> glguy: sorry, I was referring to the quote when I asked if it was yours
21:43:38 <dmead> are you guys reading the topic on haskell-cafe
21:43:45 <sorear> somehow I thought it was...
21:43:50 <dmead> somebody wants to change the prelude
21:43:56 <glguy> sorear: AH
21:43:56 <dmead> =/
21:44:05 <glguy> sorear: now I feel much less confused :)
21:44:20 <glguy> sorear: yeah, that quote was mine :)
21:45:07 <sorear> sorry for confusing you.
21:47:00 <allbery_b> hm, and I think I may have outsmarted myself by stuffing the base in the state because I forgot there are times when I want to mutate it :/
21:47:28 <bd_> You can alter the state in the state monad, surely?
21:47:31 <allbery_b> (mutate temporarily, but it still complicates things a bit now)
21:47:34 <bd_> oh
21:47:37 <bd_> use StateT + Reader?
21:48:46 <bd_> or ReaderT + State, I can't remember which >.>
21:49:08 <glguy> in that situation, it shouldn't really matter
21:49:13 <allbery_b> no, I think I end up rewriting some original "cleverness" to be slightly less clever
21:49:21 <glguy> what are you writing?
21:50:15 <allbery_b> Jewish zemanim calculator (prayer times, roughly)
21:50:21 <bd_> glguy: I was wondering if local only worked on one, but from the looks of the haddock it should be fine
21:50:43 <allbery_b> everything is ultimately based on sunrise and sunset times, but depending on whose rules you follow there are a lot of complications
21:50:58 <glguy> bd_: they are both instances of MonadReader and MonadState I believe, so it ought to pass through without lifting
21:51:11 <bd_> yeah
21:52:13 <allbery_b> one of the odder complications is that some of the times relating to Pesach switch from one basis (Gaonim => days are sunrise-to-sunset) to another (Magen Avraham => days are daybreak to nightfall, usually defined as degree offsets from sunrise/sunset)
21:53:13 <allbery_b> (at least under some rulings.  and I want to keep it flexible to users can select which set of rules they're supposed to follow.  "two Jews, three opinions" is rather mroe than just a joke...)
21:54:48 <allbery_b> I've been porting this from the first version I wrote in Perl, which does its own memoziation but is rather slow despite that.  first Haskell version without memoization was noticeably faster than the Perl script (like, 100 runs in 10 seconds --- Perl script would get me 4 runs) btu I think I can better that
21:55:08 <allbery_b> and I figured I could start getting a handle on the state monad this way
21:55:15 <glguy> Anyone here played with the language Factor?
21:55:28 <bd_> allbery_b: If you want efficient memoization, you could use unsafePerformIO to shove stuff into a hash table
21:55:44 <allbery_b> I considered that, btu decided I'd rather try to remain pure for now :)
21:55:46 <bd_> it should be safe as long as you make sure it's a pure function despite that
21:55:46 <bd_> heh
21:56:14 <bd_> Well, if you're looking at changing something over just a single call, then reader's definintely what you're looking for
21:56:42 <allbery_b> besides, in the future I'm thinking of using these routines in a more involved calendar+times application and it will be useful in that case to start over with a new state when I change days
21:57:29 <allbery_b> (otherwise the cache will grow without bound)
21:58:47 <allbery_b> well, I'm still getting a handle on this.  think I'll stick with State for now and look at StateT+Reader later
21:59:11 <bd_> okay
21:59:17 <bd_> you can emulate it with just state of course
21:59:40 <allbery_b> (some parts of Haskell Ihave figured out pretty good.  still not real familiar with monads,other than IO, much less monad transformations)
21:59:49 <bd_> heh
21:59:55 <kmb_> @help
21:59:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:00:02 <kmb_> @list
22:00:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:00:18 <allbery_b> which is one of the reasons I'm doing it this way; work my way up to State, then maybe to StateT+Reader, etc.
22:00:41 <Botje> @pl \x y -> x:y++[x]
22:00:41 <lambdabot> liftM2 (.) (:) (flip (++) . return)
22:00:48 <Botje> feh
22:00:52 <kmb_> @help tell
22:00:52 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
22:01:58 <bd_> @. unpl pl \x y -> x:y++[x]
22:01:58 <lambdabot> ((:) >>= \ b -> (\ n k -> k ++ (return n)) >>= \ a -> return (\ h -> b (a h)))
22:01:59 <glguy> ?pl \x y -> x : foldr (:) [x] y
22:02:00 <lambdabot> liftM2 (.) (:) (foldr (:) . return)
22:02:02 <bd_> heh
22:03:51 <glguy> ?pl \x y -> x : (reverse (x : y))
22:03:52 <lambdabot> liftM2 (.) (:) ((reverse .) . (:))
22:10:55 <allbery_b> huh
22:11:16 * allbery_b just googld the Reader monad... and now wonders if he should just be using it instead of State
22:11:46 <glguy> aren't use using both Reader and State?
22:12:06 <bd_> You can memoize using reader if you know what keys you'll be using, I suppose... make a Map of key -> value, fill in all the values lazily. They should only be evaluated once...
22:12:18 <bd_> [I think]
22:12:19 <allbery_b> no, that was one of the suggestions offered --- but other than IO I'm stll monad-clueless
22:12:38 <allbery_b> so I saw this as a way to start figuring out the State monad
22:13:17 <allbery_b> hm, can't rewrite the environment as state?  then I guess I would need to use StateT+Reader
22:13:23 <bd_> you can
22:13:29 <allbery_b> memo in the StateT, base in the Reader
22:13:33 <bd_> it's definitely possible to emulate reader with pure state
22:13:38 <bd_> I did that once XD
22:13:54 <glguy> Reader is like a State that you can't permanently change
22:14:07 <allbery_b> I was hoping to hold opff monad transformers until I've worked ut some of the basic monads first :)
22:14:13 <bd_> [didn't know about reader >.>]
22:14:30 <glguy> allbery_b: You will hardly notice that you are using Monad Transformers
22:14:32 <allbery_b> oh.  okay, so not really viable for this.  guess I'll keep going for now and consider it for next time
22:14:39 <bd_> I was actually using it for like the textbook example of reader - lexical scoping in a compiler/interpreter thing :p
22:15:03 <glguy> allbery_b: just use: runReaderT (evalState mycomputation memotable) basething
22:15:27 <bd_> allbery_b: what are you memoizing btw, specifically?
22:15:38 <allbery_b> thought I answered that earlier
22:15:40 <bd_> Well
22:15:42 <glguy> ?type \a -> runReaderT (evalState a [1]) ('a','a')
22:15:44 <lambdabot> forall (m :: * -> *) a a1. (Num a1) => State [a1] (ReaderT (Char, Char) m a) -> m a
22:15:47 <bd_> I mean in terms of arguments to the funciton in question
22:16:02 <allbery_b> so I have functions of the form: zeman base offset time -- base is an enum of possible bases, many of which invoke zeman again with other fixed arguments
22:16:19 <allbery_b> (what I sent earlier)
22:16:27 <allbery_b> offset is another enum with possible values attached
22:16:39 <bd_> are any of those fixed over the entire computation, or have a finite domain?
22:17:10 <bd_> I'm thinking you could do something with Map in the reader monad, and use implicit memoization, but it might not be practical...
22:17:22 <allbery_b> actual calls look like:  zeman Netz (Degrees (-8.5)) t -- where t is civil noon on the day to calculate for, fed ultimately to sunrise/sunset calculator
22:17:37 <bd_> okay, that sounds quite impractical then I guess :/
22:17:57 <allbery_b> the raw sunrise/sunset are saved as zeman Netz NoOffset t and zeman Shekiat NoOffset t
22:18:22 <allbery_b> (where what I actualy memoize is map of tuple of arguments to result)
22:18:33 <kmb_> @help paste
22:18:33 <lambdabot> paste. Paste page url
22:18:36 <allbery_b> plus many forms are based on other times calculated from those
22:19:02 <glguy> ?paste
22:19:03 <lambdabot> http://paste.lisp.org/new/haskell
22:21:39 <allbery_b> those two computations are fixed over a single day (which I considered also sticking in the state but there's one place where I mutate it --- thus it would probably be better off in a Reader on the next pass)
22:22:14 <allbery_b> since for most purposes (except that one temporary mutation) I only care about memoization over a single day
22:22:40 <bd_> How expensive is that function anyway?
22:23:09 <bd_> Will the cost of using the map exceed the cost of the function...?
22:23:15 <allbery_b> sunrise/sunset is pretty expensive.  which is why, if nothing else, I want to cache that --- but there are some variant forms that *also* must be cached in some circumstances
22:24:05 <allbery_b> it's a lot of trig to set things up, followed by an iterative algorithm to refine it (I know of no way to get rid of the iteration, but found a reasonably nice way to encode it in Haskell)
22:24:17 <bd_> oh
22:24:53 <allbery_b> so yes, very expensive, enough that memoization is a clear win over the 10-16 computations (dpeending on date) which make use of it
22:25:04 <allbery_b> s/over/across
22:25:20 <sorear> ?seen
22:25:21 <lambdabot> Lately, I have seen allbery_b, bd_, bpalmer`, glguy, kmb_ and sorear.
22:26:42 <allbery_b> typically the iteration converges in 4-5 passes, but around the solstices it can take up to 30 (!)
22:26:59 <bd_> ow
22:27:06 <bd_> well, you can implement it in pure state
22:27:06 <allbery_b> no, wait, it's around the equinoxes that it has problems
22:27:13 <bd_> it'd be a nice exercise to then add in reader :)
22:30:24 <LordBrain> if I intend to use something as a higher order function, should i define it that way? or is it ok to define it as a total function which isn't higher order and then use it's partial application?
22:30:45 <LordBrain> is there efficiency trade offs here?
22:31:39 <glguy> lord: do you mean: f x = \y ->  vs. f x y = ?
22:31:40 <LordBrain> like f a b = c versus f a = \b -> c
22:31:42 <allbery_b> fwiw, memoizing the Perl version took runtime from >90 seconds to a fraction of a second
22:31:51 <LordBrain> sorry if my terminology is wrong
22:31:54 <LordBrain> yes
22:32:01 <opqdonut> LordBrain: those are equivalent
22:32:04 <glguy> LordBrain: the only time you should do the \b -> version is if you need ot for advanced typing reasons
22:32:10 <opqdonut> efficiency-wise
22:32:18 <LordBrain> ok
22:32:20 <sorear> ... not quite.
22:32:47 <sorear> it depends on how often you intend to call the function, with different arguments.
22:32:58 <opqdonut> well, yes, true
22:33:07 <sorear> to take an example from my vty library, I have a function classify
22:33:24 <sorear> classify :: KeyboardDescription -> String -> Key
22:33:41 <glguy> are there any examples in the standard libraries that do it the lambda-expression way?
22:34:11 <sorear> classify kd str = let comp = compile kd in x y z  <-- this compiles the keyboard description every time
22:34:36 <sorear> classify kd = \str -> let comp = compile kd in x y z  <-- this is different because the optimizer turns it into...
22:34:53 <sorear> classify kd = let comp = compile kd in \str -> x y z  <-- ... which only compiles once.
22:35:20 <sorear> All else being equal, seperate lambdas are faster.  *But* all else is not equal...
22:35:40 <sorear> invoking a separate lambda function takes longer because it must make 2 indirections.
22:36:36 <allbery_b> hrm, actually, for the Reader one I might only memoize 4 fixed values (sunrise, sunset, daybreak, nightfall --- all expensive), which would deal with most of it --- so I wouldn't need State
22:36:46 <lisppaste2> kmb_ pasted "Problem with array and list comprehensions" at http://paste.lisp.org/display/33091
22:36:49 <sorear> You should only split the lambdas if you know the function will be called many times with the same first argument *AND* a lot of precomputation can be done based on the first argument *AND* the compiler can see that the calls are the same.
22:37:03 <sorear> classify is the exception, not the rule.
22:37:20 <allbery_b> there would be one more expensive computation, but it would only be run once per day normally
22:37:43 <sorear> (It's very much like automatic memoization - it can be done, but it's usually a pessimization so the compiler doesn't do it by default.)
22:37:45 <glguy> havey ou written the version without optimizations yet?
22:37:52 <kmb_> @paste http://paste.lisp.org/display/33091
22:37:52 <lambdabot> http://paste.lisp.org/new/haskell
22:38:22 <sorear> Is anyone here very familiar with the lambdabot code?
22:38:42 <allbery_b> kmb_: just tell the pastebin to announce to #haskell :)
22:39:05 <glguy> kmb_: your Card datatype is incomplete
22:39:11 <allbery_b> ah, you did
22:39:11 <glguy> suit doesn't have a type
22:39:36 <kmb_> glguy: both suit and value are strings
22:39:38 <glguy> kmb_: also, you can use Card for the constructor instead of Cd if you want to
22:40:00 <glguy> kmb_: ok, so: suit :: String, rank :: String
22:40:23 <glguy> this isn't C, so you can't write: int x,y;
22:40:37 <kmb_> glguy: yes, correct.  the syntax I'm using is legal according to the haskell introduction
22:41:03 <glguy> Hm, that's news to me, I guess I'm learning too :)
22:41:10 <glguy> moving on to show
22:41:18 <opqdonut> :)
22:41:23 <glguy> show c = value c ++ " of " ++ suit c
22:41:30 <glguy> you don't need to show the result of that
22:43:11 <glguy> kmb_: it would be more common to write: data Suit = Spades | Hearts | Clubs | Diamonds deriving (Eq, Show) -- than to use a string list
22:43:18 <glguy> if that matter sto you
22:43:20 <kmb_> glguy: please see section 6.2 of "A Gentle Introduction to Haskell"
22:43:35 <glguy> kmb_: If that works , it works
22:45:03 <kmb_> My question was actually why the list comprehension in when using array doesn't work
22:45:23 <glguy> kmb_: you are doing a cartesian product
22:45:29 <glguy> instead of a parallel map
22:45:32 <glguy> for example:
22:45:41 <kmb_> ldeck is correct, but adeck is <joker>, <joker>, <king of diamonds> ...
22:45:45 <glguy> > [(a,b) | a <- [1..3], b <- [4..6]]
22:45:46 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:46:05 <xpika> > [(a,b) | a <- [1..3] | b <- [4..6]]
22:46:06 <lambdabot>  Parse error
22:46:23 <glguy> kmb_: you need: (i,(v,s)) <- zip [2..54] (concatMap ...
22:46:26 <xpika> i want my glasgow extentions
22:46:32 <clanehin> I am looking to agressively precompute all of the invariant parts of some IO functions at or before compile time in an automated way.  Basically I want all of the opengl primitive calls to render a model to be compiled directly into the binary.  I already have a function that renders the models into a display list, but it takes several seconds to render the model the first time.  Suggestions?
22:47:15 <glguy> kmb_: a much more common implementatin of adeck might be: adeck = listArray (0,53) ldeck
22:47:27 <glguy> but your problem is what i mentioned above
22:47:36 <sorear> -finline-use-threshold
22:47:37 <sorear> ?
22:48:23 <kmb_> glguy: yeah, I was wondering if I should use listArray, but I wasn't sure why I should choose one over the other.
22:48:42 <kmb_> glguy: thank you for your help
22:48:44 <glguy> yw
22:49:20 <glguy> when it is feasible to use either array or listArray, listArray would probably be preferred
22:49:30 <bd_> :t listArray
22:49:31 <lambdabot> forall e i. (Ix i) => (i, i) -> [e] -> Array i e
22:49:37 <bd_> makes sense
22:49:47 <glguy> > listArray (0,4) [2,5,7,9]
22:49:49 <lambdabot>  Exception: (Array.!): undefined array element
22:49:54 <glguy> > listArray (0,4) [2,5,7,9,5]
22:49:55 <lambdabot>  array (0,4) [(0,2),(1,5),(2,7),(3,9),(4,5)]
22:50:10 * glguy wonders why is desktop running vista just shutdown...
22:50:26 <kmb_> because it is a more straightforward syntax on that line?
22:50:45 <glguy> and can be implemented more efficiently
22:50:48 <glguy> kmb_: check this out
22:50:52 <glguy> instead of "combine"
22:51:09 <glguy> [Cd s v | s <- suits, v <- values]
22:52:02 <kmb_> glguy: that's not going to give me the full 52 cards though right
22:52:03 <kmb_> ?
22:52:20 <clanehin> sorear do you mean unfolding-use-threshold?
22:52:39 <glguy> > [(s,v) | s <- ['H','C'], v <- ['A','2','3']]
22:52:40 <lambdabot>  [('H','A'),('H','2'),('H','3'),('C','A'),('C','2'),('C','3')]
22:52:44 <glguy> kmb_: ^
22:53:28 <kmb_> glguy: yow! that's sweet.  i'm not sure why that works though.
22:53:53 <bd_> mmm list monad
22:54:08 <glguy> kmb: think: foreach s in suits { foreach v in values { return s , v } }
22:54:22 <glguy> that's what lisp-comprehensions do :)
22:55:39 <kmb_> glguy: so each assignment in a list comprehension implies a nested context for that value set?  I thought it was a single iteration over the minimum length of any of the value sets.
22:55:50 <kmb_> ala python
22:55:51 <glguy> kmb_: your first statement was right :)
22:56:11 <glguy> kmb_: this will make more sense when you learn about the list monad more
22:56:25 <kmb_> ok, gotha
22:56:31 <kmb_> gotcha
22:57:03 <glguy> though you are using records, you are allowed to write: Cd "Joker" "A" -- instead of what you have
22:57:10 <glguy> I don't know if you knew that
22:57:51 <kmb_> glguy: so this is why you suggested to use: (i,(v,s)) <- zip [2..54] (concatMap ..., because it will synchronize the disparate sets.
22:58:20 <glguy> right, but, i would recommend not using an explicit concat map here
22:58:21 <kmb_> glguy: I didn't know that, actually
22:58:35 <kmb_> glguy: why no concatMap?
22:58:53 <glguy> because a list comprehension would express that more clearly
23:00:11 <glguy> If you really want to use the "array" function: adeck = array (0,53) $ zip [0..53] $ Cd "Joker" "A" : Cd "Joker" "B" : ldeck
23:00:22 <kmb_> glguy: another question: if I switched to using an enumerated type for the suits and ranks, how can I use those types in a list comprehension?
23:00:25 <glguy> ldeck = [Cd s v | s <- suits, v <- values]
23:00:41 <glguy> kmb_: either: [Spades..Diamonds]
23:00:44 <glguy> or
23:00:51 <LordBrain> hmmmmm i think utf8 is messing up my regex matching
23:00:56 <glguy> [Cd s v | s <- [minBound .. maxBound]....
23:01:54 <glguy> and it might actually need: [Spades .. Diamonds]
23:01:59 <glguy> (extra spacing)
23:02:34 <xpika> > fromlist [1..10]
23:02:35 <lambdabot>  Not in scope: `fromlist'
23:02:38 <pjd> <kmb_> ala python
23:02:48 <pjd> kmb_: actually, python works exactly the same
23:02:50 <kmb_> I do want to use an array, because I need random access to the deck.
23:03:06 <glguy> kmb_: listArray (0,53) ldeck
23:03:08 <pjd> you have to use zip/izip to get the behavior you mentioned
23:03:49 <xpika> [1..10] !! 3
23:03:52 <xpika> > [1..10] !! 3
23:03:54 <lambdabot>  4
23:05:35 <kmb_> the !! operator is O(n), ideally, I want O(1), but I'll settle for O(log n)
23:07:16 <bd_> Data.Array.Diff ftw
23:07:25 <Excedrin> kmb_: have you looked at the array page on haskell.org ?
23:07:38 <xpika> @hoogle Data.Array.Diff
23:07:39 <lambdabot> No matches, try a more general search
23:07:59 <lisppaste2> glguy pasted "annotated cards" at http://paste.lisp.org/display/33093
23:08:03 <glguy> kmb_: ^^
23:08:15 <kmb_> Excedrin: yes, i was reading it.
23:09:30 <kmb_> glguy: wow, that's a lot sweeter that what I wrote, thanks a lot for your help.  This was very informative.
23:09:43 <glguy> yw
23:10:42 <roconnor> sounds like someone is writing the encryption algorithm: solitaire
23:10:43 <glguy> xpika: I think that DiffArrays out old news now
23:11:15 <glguy> was that on Ruby quiz?
23:11:42 <kmb_> roconnor: are you a NSA spook?  you have seen through my smoke screen!
23:12:09 <sjanssen> @keal
23:12:09 <lambdabot> tomorrow i share next mathematical secrety
23:12:11 <sjanssen> @keal
23:12:11 <lambdabot> you need a Zh function in Haskell
23:12:14 <kmb_> glguy: roconnor is right, I'm working on the Solitaire encryption algorithm.
23:12:15 <sjanssen> @keal
23:12:15 <lambdabot> Keal angry @ dons
23:12:28 <glguy> ?protontorpedo
23:12:29 <lambdabot> syntax ur runing my high
23:12:32 <glguy> ?protontorpedo
23:12:33 <lambdabot> I dont think tcl cn do that
23:12:34 <sjanssen> these aren't the quotes we're looking for
23:12:35 <roconnor> kmb_: why else would anyone program a deck of cards :P
23:12:54 * glguy doesn't know the Keal quotes
23:13:05 <glguy> but was around for protontorpedo's comedy
23:13:22 <sorear> maybe they're trying to find a cheaper way of sating their poker cravings? :)
23:13:29 <glguy> ?quote
23:13:30 <lambdabot> Philippa says: hey, if the guy wants a monadectomy that's his choice
23:13:51 * glguy wonders what language Philippa_ was referring too...
23:14:00 <sjanssen> keal: "nsa has all the profiling info you need to come up with the correct survey answers"
23:14:28 <thou> hi.  in case anyone's interested, this seems to work (but i'm not really pleased that it's necessary) to print UTF8 data w/ ghc6.6: main = putStrLn (fixUTF "ab");  fixUTF = map (chr . fromIntegral) . toUTF; toUTF is from http://repetae.net/john/repos/jhc/UTF8.hs
23:14:34 <sjanssen> more keal: "nsa prevent me from returning to math on efnet", "nsa try kill me numerous times", "the [nsa] even make light green both ways once"
23:15:06 <sjanssen> thou: yes, it's a bug.  Should be fixed someday
23:15:22 <thou> sjanssen: thanks
23:16:12 <sjanssen> and when that bug is fixed, be prepared for your fixUTF code to break :/
23:16:22 <thou> yeah, i'll be happy to have that break
23:16:38 <thou> i can change fixUTF = id
23:16:55 * sieni is holier than thou
23:17:00 <sjanssen> technically you should use the binary IO stuff when managing the encoding yourself
23:17:15 * thou is wholer than sieni
23:17:22 <sjanssen> but the API for that is quite burdensome, you have to munge Ptr Word8 and all that
23:17:33 <sorear> ?who sjanssen
23:17:33 <lambdabot> Maybe you meant: echo ghc show what wn
23:18:01 <sjanssen> I AM THAT I AM
23:18:33 <thou> sjanssen: well, my end goal is to use HSCurses
23:18:46 <thou> whose api uses String
23:18:49 <thou> :-/
23:19:21 <sjanssen> again, technically, that is the right thing to do
23:20:54 <thou> if i have a shim that works, i'm happy for now :-)
23:20:55 <sorear> you might also want to look at vty - all the character output is done on line 133, so it should be a trivial fix [to make it support UTF-8]
23:22:22 <sorear> thou: it's not hscurses at all, though (it does the same thing in a much simpler, less efficient, and completely incompatible way)
23:33:16 <dancor> is there a faster way to do an enum like data MyEnum = A | B | ... | G | a | b | ... | g by using Bounded or something
23:34:58 <dancor> what do you do when you want an enum but want it to be able to take on more values than you are willing to sit there and type
23:36:58 <sorear> surely you don't have N zillion cases!
23:37:32 <sjanssen> dancor: you can use an Int instead
23:37:46 <sjanssen> or you can type it out.  There aren't any other options
23:37:54 <sorear> I find that when I have a large enumeration, it is always the cartesian product of two or more reasonably-sized enumerations; like Card = Suit * Rank
23:37:55 <dancor> Interesting
23:38:22 <dancor> not too many prime-sized enums :)
23:38:50 <sjanssen> if you don't want to type all the constructors out, then your datatype is too big ;)
23:38:57 <sorear> Often the prime enums have sum-of products structure, data Card = Joker | Card Suit Rank
23:39:12 <dancor> the language is perfect.  your problem is flawed
23:39:12 <sorear> that's 53 enums reduced to 18
23:39:44 <dancor> yeah i can do some cool cartesian productry
23:40:32 <sorear> If your problem IS perfect, then since there is no repeating structure in your enums there is no way of entering them more convienient than one at a time, in any language.
23:40:34 <sjanssen> looks like you want data MyEnum = ME {letter :: Letter, isUpperCase :: Bool}, or something
23:41:23 <sorear> (the question is whether categorical sums, products, and exponentials are sufficient to express the structure that exists in your type)
23:43:10 <augustss> also, what is your enum?
23:43:52 <dancor> i'm representing a square-1 puzzle
23:44:45 <dancor> i'm using capital letters for corner pieces (which are 'bigger') and enuming them clocwise in the top and bottom
23:45:24 <dancor>  - initial cube
23:45:24 <dancor>  - A a B b C c D d
23:45:24 <dancor>  - up
23:45:25 <dancor>  - E e F f G g H h
23:45:59 <dancor> when i said G/g earlier i meant H/h
23:46:32 <dancor> i did rubix cube program earlier and i ended up using an Int instead of a 26-enum
23:46:38 <augustss> well, you can't have constructors starting with lower case in Haskell anyway, so you have to do something
23:46:56 <dancor> ah
23:47:13 <dancor> so much for painlessly deriving show and read
23:48:05 <augustss> in your case, i might go for an int.  or why not Char?
23:53:44 <Excedrin> this CouchDB looks pretty cool
23:56:31 <Itkovian> dons: there's an error in the chuck function you posted to your blog, I think it should be splitAt i instead of splitAt n
23:57:41 <sorear> dons is on vacation right now, use @tell to have lambdabot take a message.  Sorry.
23:58:04 <sorear> @tell Itkovian say something to test?
23:58:05 <lambdabot> Consider it noted.
23:58:36 <sorear> s/chuck/chunk/?
23:58:45 <Itkovian> @tell dons there's an error in the chunk function you posted to your blog, I think it should be splitAt i instead of splitAt n
23:58:46 <lambdabot> Consider it noted.
