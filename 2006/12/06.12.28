00:00:09 <nmessenger> just being dramatic, it can sometimes make strange type errors if you're not used to it.
00:00:29 <Cale> It can essentially change the strictness properties of your code, and end up completely modifying the order in which things are evaluated (and hence the order in which the trace messages themselves appear!)
00:00:46 <Cale> Not ($)
00:01:04 <Cale> ($) is just id with another name and a more specific type.
00:01:20 <quazimodo> hello :D
00:01:24 <Cale> hi!
00:01:40 <Cale> Are you new here?
00:01:43 <fnord123> Cale, im having some trouble with HXT and the http module. A possible bug. I was wondering if you had some time to help debug w/ me :) I have code in the pastebin that appears to parse the http header incorrectly when I request a remote xml file. However, when I save the file locally and read it in, then the XML parses properly.
00:01:46 <quazimodo> i am trying to learn this forsaken language but ghci is giving me grief
00:01:48 <quazimodo> :P
00:01:49 <allbery_b> re ($): using it mutiple times is also dubious because there are ongoing discussions about its associativity.  (specifically, it's curently infixr, but some would prefer it be infixl.  a $ b $ c ends up doing rather different things depending on which it is.)
00:01:55 <quazimodo> sure am
00:01:55 <quazimodo> anyway
00:01:55 <emu> well, i've used logging with unsafePerformIO and it's interestin cause it still only outputs when the code gets computed
00:02:10 <fnord123> If you're up for it, http://paste.lisp.org/display/33507
00:02:12 <quazimodo> i am on freebsd 6.1 and ghci will not recognise backspace correctly, it prints the control charatcer ^H
00:02:13 <Cale> quazimodo: first thing -- are you trying to put definitions into GHCi?
00:02:16 <Cale> oh
00:02:23 <Cale> ummm, hmm
00:02:35 <quazimodo> i removed ghc, installed gnu readline and reinstalled ghc
00:02:39 <quazimodo> still giving me grief
00:02:40 * allbery_b doesn't know why a freebsd build isn't using readline
00:02:41 <Cale> Perhaps it's built without readline, yeah
00:02:41 <Stinger_> quazimodo your readline/console isnt configured properly
00:02:44 <Cale> er
00:02:44 <nmessenger> [01:32:11] <mauke> > (join .) . intersperse $ ", " ["foo","bar","baz"]
00:02:49 <nmessenger> [01:32:39] <monochrom> $ is evil
00:02:55 <nmessenger> [01:32:46] <mauke> > ((join .) . intersperse) ", " ["foo","bar","baz"]
00:03:01 <fnord123> quazimodo: when you configured, it didn't detect readline, I imagine. --- oops you tried it
00:03:10 <quazimodo> Stinger_, what should i search on google for?
00:03:11 <fnord123> did configure actually detect readline?
00:03:15 <allbery_b> but otherwise it's a typical problem with ^H / ^?
00:03:19 <quazimodo> configure? its freebsd ports
00:03:29 <Cale> So you're using a prebuilt package.
00:03:33 <Cale> I'll have a look
00:03:33 <quazimodo> nope
00:03:40 <quazimodo> its a patched makefile
00:03:42 <Stinger_> quazimodo you may have to dick around with your .inputrc
00:03:50 <quazimodo> Stinger_, thanks
00:03:52 <allbery_b> "make configure" and then look at /usr/ports/lang/ghc/work/ghc-*/config.log
00:03:54 <Stinger_> but thats about the extent of my knowledge
00:04:26 <quazimodo> kk
00:04:31 <quazimodo> wow
00:04:34 <quazimodo> helpful channel
00:04:51 <fnord123> perhaps the port maintainer declined to build with readline? /me wastes another stab
00:04:56 <quazimodo> if i went to a haskell channel on efnet i would have been assaulted and swarmed upon
00:05:07 <Cale> there's a haskell channel on efnet?
00:05:16 <Stinger_> I didnt think so
00:05:16 <quazimodo> Cale, dno, im assuming that if there was they would be assholes
00:05:19 <quazimodo> most of efnet is
00:05:20 <Cale> hehe
00:05:28 <quazimodo> all the old schoolers who dont like new people
00:05:30 <Cale> Most of the Haskell community is pretty friendly
00:05:38 <fnord123> fwiw, #C++ on efnet is 20 times better than on freenode
00:06:02 <Cale> We need to be really beginner-friendly, or there wouldn't be any Haskell users :)
00:06:02 <dons> audreyt: around? issues with ghci on freebsd
00:06:18 <Cale> (or there'd be rather few, anyway)
00:06:23 <dons> quazimodo: audreyt knows some things about ghc on freebsd
00:06:27 <dons> (I think)
00:06:40 <dons> ?uptime
00:06:40 <lambdabot> uptime: 6d 7h 25m 9s, longest uptime: 9d 2h 23m 6s
00:06:42 <fnord123> asia is having network problems due to the taiwanese earthquake. (if audrey is in taiwan.. i forget)
00:06:42 <dons> ?users
00:06:43 <lambdabot> Maximum users seen in #haskell: 309, currently: 251 (81.2%), active: 25 (10.0%)
00:06:43 <pejo> quazimodo, are you running ghci in an xterm, or something else?
00:06:52 <dons> fnord123: ah yes. probably is in taiwan
00:06:52 <emu> i havent been on efnet for many years
00:06:53 <quazimodo> xterm
00:06:58 <allbery_b> I checked the current (as of yesterday) port Makefile, it references readline as a mandatory dependency
00:07:05 <dons> ok. good.
00:07:07 <allbery_b> so if it's not detecting it then something is wrong somewhere
00:07:13 <emu> the last time i was on efnet, some guy who was cracking univ computers tried to contact me
00:07:14 <dons> quazimodo: what does ldd ghc return?
00:07:15 <quazimodo> that is irrelevant anyway, i personally installed gnu readline
00:07:17 <fnord123> http://reddit.com/info/w7w9/comments
00:07:18 <lambdabot> Title: Asian Web Services May Take Weeks to Return to Normal (Undersea cables were dama ...
00:07:38 <quazimodo> dons ldd ghc?
00:07:47 <quazimodo> is ldd a program?
00:07:50 <allbery_b> audrey checked in yesterday, she's fine and had connectivity as of then
00:07:55 <allbery_b> yes, ldd is a program
00:08:00 <quazimodo> dont haveit
00:08:03 <emu> i ran down to wean and shut down teh machine he cracked
00:08:16 <dons> $ ldd /home/dons/lib/ghc-6.6/ghc-6.6
00:08:17 <dons>         /usr/local/lib/innetgr.so (0xb7ef3000)
00:08:17 <dons>         linux-gate.so.1 =>  (0xffffe000)
00:08:17 <dons>         libdl.so.2 => /lib/tls/libdl.so.2 (0xb7ed5000)
00:08:17 <dons>         libreadline.so.4 => /lib/libreadline.so.4 (0xb7ea9000)
00:08:19 <dons> that kind of thing
00:08:24 <allbery_b> on freebsd?  you should have it
00:08:28 <quazimodo> nope
00:08:37 <quazimodo> ffuck wait
00:08:37 <dons> quazimodo: in /sbin or /usr/sbin ?
00:08:38 <quazimodo> my bad
00:08:39 <Cale> http://www.freebsd.org/ports/haskell.html says that ghc-6.4.2_1 requires readline-5.2, which would seem to me to indicate that it was built/will build with readline support.
00:08:41 <lambdabot> Title: FreeBSD Ports: Haskell
00:08:44 <quazimodo> yeh i have it, i did something dumb
00:09:05 <dons> ok. could be termio issues, I suppose. i.e. delete key not set up?
00:09:17 <quazimodo> wold you want me to ldd the binary?
00:09:32 <dons> quazimodo: the lib/ghc-*/ghc-* file, as I pointed to above
00:09:32 <Cale> quazimodo: yeah -- the one that's in the lib directory
00:09:48 <dons> not the `which ghc` file, since that's just a shell script
00:10:02 <quazimodo> ghc-6.4.2:
00:10:03 <quazimodo>         libm.so.4 => /lib/libm.so.4 (0x288f4000)
00:10:03 <quazimodo>         libc.so.6 => /lib/libc.so.6 (0x2890a000)
00:10:06 <allbery_b> should be /usr/local/lib/ghc-...
00:10:12 <dons> quazimodo: no readline?
00:10:14 <allbery_b> hm, that looks wrong
00:10:21 <Stinger_> ghc or ghci?
00:10:28 <Stinger_> or are they the same thing :)
00:10:31 <dons> same thing
00:10:33 <quazimodo> same
00:10:34 <dons> ghc --interactive
00:10:38 <allbery_b> ghci is the wrapper script calling that binary with --interactive
00:10:57 <allbery_b> we're back to my original suggestion:
00:11:02 <allbery_b> "make configure" and then look at /usr/ports/lang/ghc/work/ghc-*/config.log
00:11:08 <quazimodo> allbery_b, i am running that atm
00:11:12 <dons> mm, even on openbsd I have:
00:11:13 <dons> manzano$ ldd /home/dons/lib/ghc-6.4.1/ghc-6.4.1
00:11:13 <quazimodo> ah its done
00:11:13 <dons> /home/dons/lib/ghc-6.4.1/ghc-6.4.1:
00:11:13 <dons>         Start    End      Type Ref Name
00:11:13 <dons>         00000000 00000000 exe   1  /home/dons/lib/ghc-6.4.1/ghc-6.4.1
00:11:15 <dons>         0796e000 27977000 rlib  1  /usr/lib/libreadline.so.3.0
00:11:18 <dons>         0425f000 24272000 rlib  1  /usr/lib/libncurses.so.10.0
00:11:20 <dons>         047ed000 247f4000 rlib  1  /usr/lib/libm.so.2.0
00:11:23 <dons>         0c026000 2c060000 rlib  1  /usr/lib/libc.so.34.1
00:11:26 <dons>         00a9a000 00a9a000 rtld  1  /usr/libexec/ld.so
00:11:36 <Cale> What about libgmp?
00:11:44 <quazimodo> dons, howcome the ghc lib is in your ~?
00:11:56 <Stinger_> large integers are for chumps ;)
00:11:57 <dons> quazimodo: ./configure --prefix=/home/dons -- ;)
00:12:09 <quazimodo> didnt want a system wide ghc?
00:12:25 <quazimodo> grep: ./alex/mk/version.mk: No such file or directory
00:12:25 <quazimodo> configure: WARNING: no OpenAL library found, so this package will not be built
00:12:25 <quazimodo> configure: WARNING: no ALUT header found, so this package will not be built
00:12:29 <quazimodo> that is some output
00:12:30 <Cale> He probably has 6.6 installed globally(?)
00:12:54 <allbery_b> if that's a UNSW machine he might not have permissions to install globally
00:13:08 <Cale> that too
00:13:17 <quazimodo> UNSW? thats my uni!
00:13:29 <nmessenger> ?localtime quazimodo
00:13:30 <lambdabot> Local time for quazimodo is Thu Dec 28 19:08:03
00:13:31 <Cale> quazimodo: hehe, then you can just get dons to come over and fix it
00:13:44 <quazimodo> dons you sneaky bastard, get out of my uni!
00:13:49 <quazimodo> :P
00:14:05 <quazimodo> i study bach. mechatronic engineering and mast. biomedical engineering
00:15:00 <quazimodo> gives me gloating rights, since i am iranian and all iranian families want their kid to become some sort of engineer, lawyer or some sort of med guy
00:15:09 <quazimodo> i have 2 of em!
00:15:09 <Cale> hehe
00:15:31 <quazimodo> all i need is a bit of law in there and i have the trifecta
00:15:54 <allbery_b> if engineering didn't drive you insane, law will :>
00:15:55 <quazimodo> ill have iranian families begging me to marry their girls, which i shall promptly refuse because "i fly solo baby"
00:16:11 <quazimodo> XD
00:16:25 <quazimodo> shall i pastebin the configure.log?
00:16:36 <allbery_b> that'd be good, yes
00:17:50 <fnord123> every middle class person in the world wants their kid to be an engineer, lawyer, architect, or med guy
00:17:56 <quazimodo> http://pastebin.ca/294234
00:18:06 <quazimodo> fnord123, even better for me i guess
00:18:17 <nmessenger> dons: do you really have blue hair?  http://trappist.elis.ugent.be/~kehoste/haskell-blahSouthPark.html
00:18:19 <lambdabot> Title: #haskell-blah: Everything but Haskell - South Park people
00:19:49 <Cale> quazimodo: is a binary available? Does it suffer from the same issues?
00:20:11 <fnord123> the lambdabot contest is great. I vote for the second entry, if i count.
00:20:24 <quazimodo> configure:6714: checking whether altzone is declared
00:20:24 <quazimodo> configure:6749: cc -c -I/usr/local/include  conftest.c >&5
00:20:24 <quazimodo> configure: In function `main':
00:20:24 <quazimodo> configure:6782: error: `altzone' undeclared (first use in this function)
00:20:24 <quazimodo> configure:6782: error: (Each undeclared identifier is reported only once
00:20:25 <quazimodo> configure:6782: error: for each function it appears in.)
00:20:27 <quazimodo> configure:6752: $? = 1
00:20:31 <quazimodo> configure: failed program was:
00:20:35 <fnord123> pastebin, pleas
00:20:39 <quazimodo> Cale, there is likely a package for it
00:20:42 <quazimodo> <quazimodo> http://pastebin.ca/294234
00:20:44 <Cale> quazimodo: I wouldn't recommend compiling GHC unless you're hacking on it or a binary really isn't available.
00:20:56 <nmessenger> fnord123 she already won
00:21:00 <nmessenger> ?where lambdabot
00:21:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
00:21:04 <allbery_b> cale: freebsd ports (almost) always compiles from source
00:21:07 <quazimodo> Cale, the ports collection is the standard installation method on fbsd
00:21:15 <quazimodo> which is mostly compile
00:21:18 <fnord123> irc ettiquite: when pasting more then 3 lines, use a pastebin, quazimodo
00:21:19 <Cale> pkg_add -r ghc
00:21:50 <allbery_b> the altzone thing doesn't matter, it's checking for an ancient System V timezone thing
00:21:53 <quazimodo> sorry fnord123 ill remember that
00:22:55 <quazimodo> ill try to get the package
00:23:30 <dancor> can i easily go from [Maybe a] to [a], throwing away Nothing's
00:23:37 <Cale> @type catMaybes
00:23:39 <lambdabot> forall a. [Maybe a] -> [a]
00:23:48 <dancor> wow
00:24:05 <nmessenger> ?index catMaybes
00:24:06 <lambdabot> Data.Maybe
00:24:43 <dancor> oh mapMaybe is totally what i want
00:25:14 <quazimodo> unusuall, i have readline installed but it doesnt compile with it?
00:25:15 <quazimodo> odd...
00:25:22 <nmessenger> map f . catMaybes ?
00:25:47 <dancor> > catMaybes [Nothing]
00:25:49 <lambdabot>  Add a type signature
00:25:52 <Cale> quazimodo: the configure log you pasted seems to indicate that it should compile with it, but somehow that's not happening.
00:25:58 <nmessenger> ?type mapMaybe
00:26:00 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
00:26:01 <dancor> > catMaybes [Nothing, Just 4]
00:26:03 <lambdabot>  [4]
00:26:07 <dancor> hm interesting
00:26:32 <dancor> yeah i guess it's exactly that nmessenger
00:26:54 <allbery_b> yeh, config.log looks fine to me as well, it found both headers and libraries
00:26:56 <nmessenger> ?source mapMaybe
00:26:56 <lambdabot> mapMaybe not available
00:27:03 <nmessenger> ?source Data.Map
00:27:04 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
00:27:33 <allbery_b> ?index mapMaybe
00:27:33 <nmessenger> just a skosh more complicated
00:27:33 <lambdabot> Data.Maybe
00:27:41 <Cale> catMaybes = foldr (\(Just x) -> (x :)) [] . filter isJust
00:27:57 <quazimodo> Cale, fair enough, ill add the package. it is just fetching. I wish it would use wget instead of fetch though
00:28:30 <nmessenger> Cale: even: map (\(Just x) -> x) . filter isJust
00:28:31 <allbery_b> you could tweak FETCH_CMD in the environment if you really wanted to
00:28:39 <Cale> nmessenger: right, that's true :)
00:28:48 <Cale> map fromJust . filter isJust
00:28:53 <dancor> yeah
00:29:45 <nmessenger> fromJust makes me feel icky
00:29:52 <Cale> @type foldr (maybe id (:)) []
00:29:54 <lambdabot> forall a. [Maybe a] -> [a]
00:30:02 <Cale> that looks nice :)
00:30:03 <nmessenger> as do many partial functions
00:30:14 <Cale> and obviously nonpartial
00:30:31 <nmessenger> impartial?
00:30:34 <Cale> total
00:30:36 <nmessenger> ;P
00:30:56 <quazimodo> the bloody package doesnt even have readline :/
00:31:00 <quazimodo> rediculous
00:31:07 <allbery_b> odd
00:31:20 <dancor> quazimodo: what package
00:31:29 <allbery_b> maybe I'll build it on by fbsd box tomorrow and see if I can spot what's going on
00:31:34 * nmessenger mumbles something about 'ridicule' being a mnemonic for 'ridiculus'
00:32:23 * dancor isn't sure about the difference between exceptions and Either String
00:32:29 <allbery_b> (or no; it's currently rebuilding stuff since I'm bringing it up to date after a year of running 6.1-PRERELEASE
00:32:54 <ClaudiusMaximus> has anyone got a hopengl example of saving rendered output to an image file?
00:32:57 <quazimodo> the ghc package
00:33:05 <quazimodo> precompiled, similar in use to an rpm
00:33:08 * nmessenger forgot the 'o' in ridiculous
00:33:16 <Cale> dancor: There isn't much difference. Exceptions in IO are a built-in mechanism of the IO monad which is pretty similar in nature to that.
00:33:39 <dancor> so there aren't general (outside IO) exceptions?
00:33:52 <dancor> in general you use Either?
00:33:53 <nmessenger> > error "BOOM!"
00:33:53 <allbery_b> look at Control.Monad.Error
00:33:54 <lambdabot>  Add a type signature
00:34:01 <nmessenger> > error "BOOM!" :: Int
00:34:02 <lambdabot>  Exception: BOOM!
00:34:06 <Cale> dancor: oh, there are errors, but they can be tricky to catch
00:34:13 <dancor> or would you ever actually make a fcn IO just for exceptions?
00:34:26 <Cale> No, if it was pure, I'd use Maybe or Either
00:34:53 <nmessenger> compile-time errors are just about always better than runtime
00:35:31 <dancor> nmessenger: so exceptions are inherently worse than Either?
00:35:50 <MarcWeber> Why does this line print "a" and "b"? Shouldn't it be enough to evaluate "a"?
00:35:51 <MarcWeber> main=do {a <- trace "a" $ return True;  b <- trace "b" $ return False;  print $ a || b}
00:35:58 <nmessenger> exceptions are (to repeat a mantra) exceptional
00:36:43 <nmessenger> (||) is not guaranteed to have a particular evaluation order (right?)
00:37:29 <nmessenger> but embedding it in IO would do it, I'm sure
00:37:30 <ski> MarcWeber : '(>>=)' is strict in its left argument in the IO-monad
00:38:14 <dancor> ski: does that mean like  c <- hGetContents h  is a bad idea
00:38:14 <ski> MarcWeber : try 'main = do {let {a = trace "a" $ True; b = trace "b" $ False}; print $ a || b}'
00:38:50 <ski> dancor : no .. it is only strict in the IO-action that will be executed .. not in the result of that action
00:39:03 <Cale> MarcWeber: If you think about it, the computation of b might have side effects (even though it doesn't), which should occur before the print. The only way to know would be to evaluate the computation and execute it.
00:39:05 <nmessenger> IO is magic!
00:39:10 <Cale> It only turns out to be a return
00:39:22 <Cale> but there's no way for it to know that without doing the evaluation
00:39:49 <dancor> do you guys use Either String for exceptionery or Either MyExceptionEnum
00:39:54 <Cale> imagine if it was a  readIO  instead.
00:40:10 <Cale> dancor: depends on what I'm doing.
00:40:19 <ski> dancor : depends .. for fixed exceptions the latter (if i'm not lazy)
00:40:49 <dancor> i guess it's a classic lazy/better situation
00:41:25 <Cale> Also, if you have arbitrarily many exceptions, you might be reduced to using essentially strings anyway.
00:41:55 <Cale> (unless you have some odd situation where you can reduce their description to some sort of tree structure)
00:42:15 <ski> (having extensible datatypes, or at least exceptions, perhaps similar to 'exception' in the MLs would be nice)
00:42:48 <Cale> Sometimes you really don't care about the reason for failure, in which case Maybe is appropriate.
00:43:10 <ski> (or lists if there's multiple results, at least locally)
00:43:14 <Cale> yeah
00:43:27 <Cale> In general, MonadZero
00:43:40 <Cale> too bad it no longer exists
00:43:53 * ski agrees
00:44:58 <Cale> The entire cluster of decisions associated with removing monad comprehensions in the Haskell 98 process were bad, imo.
00:45:53 <ski> imo 'instance Error e => Monad (Either e)' is bad, too
00:45:58 <Cale> yeah
00:45:58 * nmessenger1 's browser crashed in a glorious ball of flame
00:46:29 * ski recently rewrote parts of Control.Monad.Error just to remove that 'Error e' dependency
00:48:24 <quazimodo> is haskell used to build programs that are as big and complex as c++ and c are used for?
00:48:45 <Cale> They removed monad comprehensions, and then someone noticed that MonadZero was originally added to support those, and every MonadZero in the libraries was a MonadPlus as well so they could merge those classes. Also, without MonadZero and monad comprehensions, lots of prelude functions could go back to being ordinary list functions. Oh, then do-syntax was broken because the translation for irrefutable patterns on the l
00:48:45 <Cale> eft side of <- would use mzero, so they had to add fail to the Monad class.
00:48:47 <allbery_b> GHC itself :)
00:49:11 <allbery_b> also, Pugs (Perl6 implementation)
00:49:12 <Cale> So basically, all the mistakes in the H98 process were related.
00:49:34 <Cale> darcs is pretty big too
00:49:55 <Cale> I've written 1200 line haskell programs which would have been 15000 line C programs.
00:50:19 <dancor> http://haskell.org/haskellwiki/Haskell_in_practice
00:50:21 <lambdabot> Title: Haskell in practice - HaskellWiki
00:50:34 <Cale> (that was literate style including comments too, there were really only 600 lines or so of actual code)
00:51:08 <nmessenger1> Literate is awesome for writing *about* code.
00:51:40 <nmessenger1> "It's a tutorial you can execute!"
00:51:53 <Cale> http://haskell.org/haskellwiki/Frag
00:51:55 <lambdabot> Title: Frag - HaskellWiki
00:52:06 <quazimodo> Cale, yeh a haskell coding friend said stuff like that isnt that unusual, but what is the compiled binary efficiency difference?
00:52:38 <quazimodo> does the haskell program you wrote finish in the same time the c program would?
00:52:48 <allbery_b> depends on what it's doing.
00:53:06 <Cale> Well, I wouldn't have been able to write the C program at all in the time scale I had to write it.
00:53:27 <allbery_b> Haskell's default String implementation is pretty slow, but Data.ByteString.Char8 mostly fixes that
00:53:36 <nmessenger1> Cale: can you say what sort of app it was?
00:53:37 <Cale> So that's kind of a moot point. The Haskell program generated solutions quickly enough that it was not a problem.
00:53:52 <Cale> nmessenger: It was a pipeline scheduler for PPC/Altivec.
00:54:16 <nmessenger1> sounds important
00:54:40 <quazimodo> one thing i havent asked or read about before is executables, do there exist stand alone compiled haskell programs, or does it always need to be interpreted?
00:54:43 <Cale> Well, it was more of a proof of concept. I think it's probably been replaced by now. (By another Haskell program for sure)
00:55:07 <Cale> quazimodo: it's usually compiled.
00:55:17 <nmessenger1> ghc --make YourProg.hs -o yourprog
00:55:17 <Cale> quazimodo: GHC is a compiler
00:56:16 <fnord123> You should consider the fact that your ability to program in Haskell successfully is like a professional basketball player's ability to shoot free throws. you can do it with little/no trouble, but that doesn't scale to everyone (even if they practice real hard)
00:56:44 <Cale> GHC has compilation via C and native compilation as well as the ability to interpret code. Hugs is an interpreter written in C. Yhc does bytecode compilation with a compiler written in Haskell and bytecode interpreter written in C.
00:57:28 <Cale> JHC is a compiler with support for some interesting full-program optimisations.
00:57:29 * dancor checks every day to see if ghc-6.6 is in gentoo portage
00:57:41 <nmessenger1> ?where jhc
00:57:41 <lambdabot> http://repetae.net/john/computer/jhc/
00:58:04 <arcatan> how can it be not in portage? portage has everything
00:58:19 <Elifant> hello all. i'm trying to write haskell application with plugins. at first I just copied code from http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-6.html, section "Multiple plugins" and tried to run it. but it says "Main: Ix{Int}.index: Index (3145728) out of range ((0,16))". what may be wrong?
00:58:20 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
00:58:25 <dancor> everything up to 6.4.2
00:59:06 <Cale> Elifant: that's an array index out of bounds error
00:59:27 <Elifant> ye, I see :) but why is it happened?
00:59:46 <Cale> dons!
01:00:09 <Cale> Elifant: I have no idea. You're sure you're running only code from there?
01:00:31 <Elifant> yes, I just copied code and even makefile from example
01:00:38 <nmessenger1> 3,145,728?!  Yup, that pretty out-of-bounds.
01:00:43 <Cale> That's crazy.
01:00:44 <Elifant> and my own application gives the same error from 'load' function
01:00:46 <dancor> yeah not even close
01:00:50 <Cale> Where'd dons go?
01:00:59 <Cale> Which version of GHC is this?
01:01:01 <dancor> he's out of towns
01:01:15 <nmessenger1> ?get-dons
01:01:15 <lambdabot> Unknown command, try @list
01:01:23 <Cale> I think hs-plugins is still not working on 6.6 (?)
01:01:27 <dancor> we're out of dons
01:02:18 <nmessenger1> try googling "hs-plugins index out of range"
01:02:24 <dancor> hm maybe i should count my blessings that i still have 6.4
01:02:49 <Cale> aha, yes, that's the problem
01:03:14 <Cale> Elifant: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/5551
01:03:17 <lambdabot> Title: gmane.comp.lang.haskell.libraries
01:03:53 <Cale> My suspicion is that he hasn't had a day to do it ;)
01:05:32 <Elifant> I can't find year on this page, only date. how many years is "day"? :)
01:05:59 <Elifant> ok, I seems I have to go back to 6.4...
01:07:25 <malebria> Hello there.
01:07:25 <lambdabot> malebria: You have 1 new message. '/msg lambdabot @messages' to read it.
01:07:27 <nmessenger1> considering 6.6 is pretty recent, I'd suspect this is 2006
01:08:22 <malebria> How do I send a message using lambdabot?
01:08:32 <allbery_b> @help tell
01:08:33 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
01:09:44 <Cale> Elifant: complain to dons when he gets back
01:10:01 <malebria> allbery_b: thanks.
01:10:12 <Elifant> Cale: ok
01:10:20 <ski> @type \f -> Data.Maybe.listToMaybe . Data.Maybe.mapMaybe f
01:10:21 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> Maybe b
01:10:27 <ski> suggestion for name ?
01:10:28 <malebria> What's the name of that dons program that goes in GHCi and get the type of a function, adding it to the code?
01:11:28 <MarcWeber> ski, Cale: Which style is considered beeing best? http://rafb.net/p/pkSaU319.html
01:11:30 <lambdabot> Title: Nopaste - No description
01:12:51 <Cale> MarcWeber: why not   t = putStrLn "true" >> return True  ?
01:12:58 <ski> (hm, isn't 'unsafePerformIO . unsafeInterleaveIO' the same as just 'unsafePerformIO' ?)
01:13:48 <MarcWeber> ski You might be right. But which version would you prefer?
01:14:05 * ski 's still looking at 'recomp1'
01:14:23 <MarcWeber> ski: You are right. Same result.
01:14:30 <fnord123> malebria: i think it's a vim tool
01:14:34 <Cale> I'd probably write 2
01:14:46 <Cale> 1 is out of the question
01:14:51 <Cale> 3 maybe
01:14:55 <fnord123> malebria: http://article.gmane.org/gmane.comp.lang.haskell.cafe/15707
01:14:55 <malebria> fnord123: I think it's a generic tool that he uses with vim.
01:14:56 <lambdabot> Title: Gmane -- Mail To News And Back Again
01:15:31 <ski> (the returned boolean in 'recomp1' will be computed at the time it is forced, not before 'recomp1' monadically returns .. so the time those files are checked isn't so well-defined)
01:15:52 <Cale> yeah, recomp1 makes me feel slightly ill.
01:15:53 <MarcWeber> Is there a non strict version of >>= of the IO monad?
01:16:10 <nmessenger> Cale: wouldn't 3 discard errors that you wouldn't want to?
01:16:11 <Cale> no
01:16:19 * MarcWeber apologizes @Cale because making him feeling sick
01:16:20 <fnord123> http://cgi.cse.unsw.edu.au/~dons/blog
01:16:22 <malebria> fnord123: I don't find it there, it was a bash script at first, then dons rewrote it in haskell.
01:16:24 <lambdabot> Title: Haskell hacking
01:16:47 <Cale> MarcWeber: you can use unsafeInterleaveIO to prevent the actual IO from occurring until the value is actually needed
01:16:58 <Cale> which is somewhat like lazily binding
01:17:05 <Cale> but why do you want that here?
01:17:11 <malebria> fnord123: thanks, the bash version is here.
01:17:19 <dancor> so is there not an isLeft like there is an isJust
01:17:38 <dancor> i want to find the first Left in [Either a b]
01:17:53 <ski> (MarcWeber : to clarify .. note that the value 'x' bound in 'x <- foo' in IO need not be strictly computed .. only 'foo' is)
01:17:55 <dancor> i'm trying to give the line number of parsing errors in an input file
01:18:06 <Cale> head [x | Left x <- xs]
01:18:15 <dancor> nice
01:18:16 <nmessenger> blast
01:18:24 <MarcWeber> Cale it doesn't make sens to compare dates if one file doesn't exist..
01:18:26 <dancor> well i need the index
01:19:00 <malebria> fnord123: but there was a Haskell version too, I'm trying to find it here.
01:19:00 <MarcWeber> ski: You did tell me (>>= is strict .. ), right? So unsafeInterleaveIO doens't work when using >>= or x <- y
01:19:01 <Cale> MarcWeber: I'd check for existence explicitly.
01:19:20 <dancor> i guess i should just make my own isLeft
01:19:22 <ski> MarcWeber : that's a misunderstanding
01:20:06 <Cale> v <- unsafeInterleaveIO x will cause v to be bound immediately to a value whose evaluation will cause the IO action x to be executed for its result.
01:20:58 <ski> MarcWeber : the *action* 'foo' in 'foo >>= \x -> ...' or 'do {x <- foo; ...}' is forced (computed strictly), but the monadic result 'x' is not forced by the '(>>=)' (or '<-' in 'do'-notaion)
01:21:07 <Cale> But seriously, don't use the unsafe stuff unless your first name is Simon.
01:21:18 <nmessenger> in general unsafeBlah is unsafe
01:21:22 <Cale> hehe
01:21:24 <Cale> indeed
01:22:05 <nmessenger> don't bring the values down out of IO, bring your functions up into IO
01:22:20 <nmessenger> IO is your friend
01:22:30 <Cale> Well, with unsafeInterleaveIO, that's not so much the concern.
01:22:51 <MarcWeber> Sure.. I just want to learn more.. I know. Cale. Let me try another verison using unsafeInterleaveIO..
01:22:52 <ski> MarcWeber : so, if you do 'do {x <- unsafeInterleaveIO (readFile "foo"); ..x..}' then the 'unsafeInterleaveIO (trace "foo" $ readFile "bar")' action is forced, but the 'trace "foo" $ readFile "bar"' action is neither forced nor monadically run until 'x' is forced
01:23:04 <Cale> but still, the potential for confusion and/or differences in behaviour depending on optimisations is high
01:24:13 <nmessenger> [x | Left x <- [Left 1, Right 2, Right 3, Left 4, Left 5]]
01:24:16 <nmessenger> > [x | Left x <- [Left 1, Right 2, Right 3, Left 4, Left 5]]
01:24:17 <lambdabot>  [1,4,5]
01:24:44 <nmessenger> I don't quite understand comprehensions.  If the match fails, it just ignores it?
01:24:52 <ski> yes
01:25:20 <ski> pattern-match failure calls 'fail', which in this case returns the empty list
01:25:52 <nmessenger> can this be rewritten using filter and/or map?  It's not obvious to me how.
01:26:22 <ski> > [x | xy <- [Left 1, Right 2, Right 3, Left 4, Left 5], x <- case xy of Left x -> [x]; Right _ -> []]
01:26:24 <lambdabot>  [1,4,5]
01:27:04 <ski> > [Left 1, Right 2, Right 3, Left 4, Left 5] >>= \xy -> case xy of Left x -> [x]; Right _ -> []
01:27:05 <lambdabot>  [1,4,5]
01:27:27 <ski> > filter (\xy -> case xy of Left _ -> True; Right _ -> False) [Left 1, Right 2, Right 3, Left 4, Left 5]
01:27:28 <lambdabot>  [Left 1,Left 4,Left 5]
01:27:33 <ski> > filter isLeft [Left 1, Right 2, Right 3, Left 4, Left 5]
01:27:34 <lambdabot>  Not in scope: `isLeft'
01:27:34 <Cale> [  e | p <- l, Q ] 	 = 	 let ok p = [  e | Q ]
01:27:34 <Cale> 		    ok _ = []
01:27:34 <Cale> 		in concatMap ok l
01:27:41 <ski> > filter Data.Either.isLeft [Left 1, Right 2, Right 3, Left 4, Left 5]
01:27:42 <lambdabot>  Not in scope: `Data.Either.isLeft'
01:27:45 <ski> bah
01:27:48 <Cale> doesn't call fail :)
01:28:13 <Cale> (at least, H98 doesn't say that it should)
01:28:40 <nmessenger> so matching in a comprehsion draw (<-) is a bind?
01:28:40 <ski> oh .. i guess i sortof assumed list comprehensions followed 'do', there
01:28:46 <ski> Cale : nice
01:29:40 <ski> nmessenger : basically, yes (though there could be small differences in how pattern-matching failure .. imo there shouldn't be any differences, though :)
01:29:53 <nmessenger> > [Left 1, Right 2, Left 3] >>= \(Just x) -> x
01:29:54 <lambdabot>  Couldn't match `Either a b' against `Maybe a1'
01:29:58 <Cale> nmessenger: It used to be, but H98 removed monad comprehensions. The translation used to involve mzero, but now it just uses [] when the pattern fails.
01:30:02 * ski becomes unsure .. at least he thinks the action argument of 'unsafeInterleaveIO' is not forced until the monadic result is forced .. maybe this is not specified/agreed upon/considered ?
01:30:05 <nmessenger> > [Left 1, Right 2, Left 3] >>= \(Left x) -> x
01:30:05 <lambdabot>  add an instance declaration for (Num [b])
01:30:14 <nmessenger> > [Left 1, Right 2, Left 3] >>= \(Left x) -> [x]
01:30:16 <lambdabot>  Non-exhaustive patterns in lambda
01:30:38 <ski> (in any case is the action argument not monadically run until the monadic result is forced)
01:30:39 <Cale> > do { Left x <- [Left 1, Right 2, Left 3]; [x] }
01:30:40 <lambdabot>  [1,3]
01:31:03 <nmessenger> how is that different?!!
01:31:13 <mq_mattr> how does lambdabot cope with unsafePrefromIO?
01:31:19 <Cale> do {p <- e; stmts} 	=	 let ok p = do {stmts}
01:31:19 <Cale> 		    ok _ = fail "..."
01:31:19 <Cale> 		  in e >>= ok
01:31:31 <nmessenger> > unsafePerformIO (return 5)
01:31:32 <ski> mq_mattr : it doesn't have to, since it doesn't provide it :)
01:31:32 <lambdabot>  Not in scope: `unsafePerformIO'
01:31:37 <Cale> mq_mattr: it doesn't import System.IO.Unsafe
01:31:50 <nmessenger> that would unsafe
01:31:54 <nmessenger> :P
01:32:12 <nmessenger> > System.IO.Unsafe.unsafePerformIO (return 5)
01:32:12 <lambdabot>  Not in scope: `System.IO.Unsafe.unsafePerformIO'
01:32:32 <ski> @index unsafePerformIO
01:32:33 <lambdabot> System.IO.Unsafe, Foreign
01:32:35 <ski> (:
01:32:46 <MarcWeber> ski: I didn't understand your last message.
01:32:56 <nmessenger> Cale, oh yeah I forgot about the funny stuff do does
01:32:59 <Cale> IMO, a compiler switch should be required to compile any module employing an unsafe function, and unsafety should be hereditary without the use of an explicit pragma.
01:33:01 <ski> MarcWeber : which ?
01:33:21 <ski> Cale : as in Mercury, then ? :)
01:33:26 <MarcWeber> MarcWeber : so, if you do 'do {x <- unsafeInterleaveIO (readFile "foo"); ..x..}' then the 'unsafeInterleaveIO (trace "foo" $ readFile "bar")' action is forced, but the 'trace "foo" $ readFile "bar"' action is neither forced nor monadically run until 'x' is force
01:34:04 <MarcWeber> Here is recomp4 which doesn't work becaue of strictness of x in x >>= .. http://rafb.net/p/WscCv330.html
01:34:07 <lambdabot> Title: Nopaste - No description
01:34:35 <nmessenger> if it's unsafe DON'T DO IT!
01:34:50 * nmessenger growls
01:34:52 <MarcWeber> nmessenger: I won't. It's just for education. ;)
01:34:58 <Cale> nmessenger: if I had my way, then do {p <- e; stmts} would translate as e >>= \p -> do {stmts} when p is irrefutable, and as  let {ok p = do {stmts}; ok _ = mzero} in e >>= ok when p is a refutable pattern.
01:35:02 <ski> MarcWeber : '(>>=)' for 'IO' dictates that the action 'unsafeInterleaveIO (readFile "foo")' is forced .. that doesn't imply that the argument of 'unsafeInterleaveIO' (namely the action 'trace "foo" $ readFile "bar"') is forced at that point
01:35:03 <zeeeee> how do i browse/search/install packages from hackagedb?
01:37:14 <nmessenger> Cale: makes sense
01:37:15 <MarcWeber> ski: You want to tell me that the compiler night have traced and read the file minutes before?
01:37:16 <Cale> That would disallow the use of refutable patterns on the left side of <- in monads like IO, which personally, I have no problems with :)
01:37:29 <dons> nmessenger: i did have blue hair till recently :) there's a more recent photo on my website
01:37:37 <dons> mmm. should take the camera to the hackathon...
01:37:46 <Cale> dons: When is hs-plugins going to be ready for 6.6? :)
01:37:49 <ski> MarcWeber : does 'recomp4' typecheck ?
01:38:01 <dons> Cale: by Jan 12, I think
01:38:03 <MarcWeber> Yes it does. Just copy paste in /tmp and execute
01:38:13 <Cale> Elifant: there you go :)
01:38:28 * dons wonders what all these people are using hs-plugins for ...
01:38:56 <Elifant> cool, I'll wait...
01:39:03 <nmessenger> ?where dons
01:39:03 <lambdabot> http://www.cse.unsw.edu.au/~dons
01:40:35 <ski> (MarcWeber : oh, misparsed)
01:41:22 <dancor> hs-plugins are so hot right now
01:41:48 <MarcWeber> ski: You're right: It's kind of complicated ;)
01:44:13 <dons> nmessenger: for a more recent photo, here's me at google ;) 3 rows up from the bottom, on the far right. http://photos1.blogger.com/blogger/4778/2884/1600/GSoCMentorSummitStairs.jpg
01:44:16 <lambdabot> http://tinyurl.com/yytxs5
01:44:32 <quazimodo> i have an idea, does anyone here have ghc on freebsd 6.1 with realine 5.2?
01:44:53 <dons> there was an annotated version somewhere with all the organisation names for who was who from perl, python, haskell and so on. hmm
01:45:16 <therp> google office looks nice
01:45:55 <mq_mattr> therp?
01:46:01 <therp> yes?
01:46:11 <mq_mattr> google office?
01:46:25 <therp> that's no piece of software, just google's real world office.
01:46:25 <dons> hey mq_mattr
01:46:32 <mq_mattr> ah
01:46:39 <mq_mattr> dons: hello
01:47:01 <quazimodo> allbery_b, you on fbsd?
01:47:01 <mq_mattr> you can drop the mq_, I only need it since mattr is someone else on this server
01:47:08 <mq_mattr> damn common names
01:47:13 <nmessenger> dons: black shirt?
01:47:14 <mq_mattr> :)
01:47:30 <dons> nmessenger: yep. black tshirt with a bit of green
01:47:45 <benc__> so
01:47:46 <benc__> |categories-have-category-type: unknown exception
01:47:51 <benc__> my program is failing with that
01:48:02 <dons> mm. sounds like an uncaught dynamic exception?
01:48:03 <benc__> any clues as to where I start to work out why?
01:48:05 <benc__> ok
01:48:10 <benc__> i'm doing DB stuff so it could be in there
01:48:15 * benc__ will poke there
01:48:20 <dons> which ghc version?
01:48:32 <benc__> |The Glorious Glasgow Haskell Compilation System, version 6.4.2
01:49:01 <quazimodo> whats glorious
01:49:07 <quazimodo> erm, whats glorious about it?
01:49:17 <dons> what /isn't/ glorious about it? :)
01:49:19 * benc__ far too used to java overly verbose stack traces when errors occur
01:49:35 <Vq^> @karma+ dons
01:49:35 <lambdabot> dons's karma raised to 105.
01:49:40 <quazimodo> no idea, seeing as i cant get it to work correctly
01:49:41 <dons> benc__: yeah, the dynamic exception mapping to 'unknown' is a little annoying :/
01:50:08 <quazimodo> someone here has to run freebsd??
01:50:12 <dons> quazimodo: what exactly goes wrong? the backspace key at the ghci prompt? or other things?
01:50:17 <benc__> heh
01:50:26 * benc__ is using ghc on mac os x mostly ok
01:50:29 <benc__> thats sort of BSD like
01:50:41 <quazimodo> dons just the stuff readline is meant to handle
01:51:01 <mq_mattr> benc__: just like bsd or linux
01:51:11 <dons> ok. so we've probably covered everything people can think of here, short of talking to the port maintainer, or building your own ghc
01:51:12 <nmessenger> GHC++
01:51:18 <quazimodo> mq_mattr, OS X is bsd
01:51:36 <quazimodo> ok dons, ill do that
01:51:38 <mq_mattr> benc__: mac experience = max(linux experience, bsd experience, windows experience)
01:51:47 <mq_mattr> not because I am some mac fanboy
01:52:03 <dons> mq_mattr: heh
01:52:06 <benc__> though I did give up on unix terminal handling working properly some time ago
01:52:07 <quazimodo> what i wanted to try is to grab someones ghc folder in a tar.gz and see if i cant just "use" theirs
01:52:14 <mq_mattr> just because you have ports (BSD), apt-get (linux) and graphical binary install :)
01:52:15 <benc__> once i decided i wanted multiscript unicode in my life
01:52:18 <benc__> that was basically the end
01:52:21 <dons> not sure the mac guys get a true openbsd experience though. too much sugar in the way ;)
01:52:44 <mq_mattr> dons: you are right
01:52:45 <dons> quazimodo: you could ask for that on the haskell-cafe@haskell.org mailing list
01:52:46 <benc__> dons: I've seen wonderful facial expressions from people who 'know about macs' when they see my screen of terminals
01:52:48 <dons> someone should have one.
01:52:56 <dons> benc__: heh
01:53:00 <dons> ?where mailinglists
01:53:01 <lambdabot> I know nothing about mailinglists.
01:53:03 <dons> ?where mailinglist
01:53:03 <lambdabot> http://haskell.org/haskellwiki/Mailing_lists
01:53:19 <ski> MarcWeber : strange ..
01:53:29 <ski> *Main> print =<< liftM2 (||) (return True) (unsafeInterleaveIO $ error "foo")
01:53:29 <ski> True
01:53:29 <ski> *Main> print =<< liftM2 (||) (return False) (unsafeInterleaveIO $ error "foo")
01:53:29 <ski> *** Exception: foo
01:53:29 <ski> *Main> print =<< liftM2 (||) (return True) (error "foo")
01:53:32 <ski> *** Exception: foo
01:53:45 <mq_mattr> benc__, dons: I ran my  mac in console mode for a while (using `screen` since we don't get virtual consoles) to try and get the full experience
01:53:56 <benc__> nice
01:54:03 <benc__> i like the zoomy window effects, though
01:54:10 <benc__> even for text mode
01:54:17 <benc__> i mean, even just for terminals
01:54:20 <mq_mattr> most things were fine, but being stuck with text brwosers for looking up programming things was really crap
01:54:31 <mq_mattr> try browsing hslibs from lynx :)
01:54:33 <benc__> go go lynx!
01:54:43 <benc__> it even supports gopher:// urls
01:55:35 <mq_mattr> benc__: I actaully hat mac hardware and the company, but I recommend them to programmers because you can get all the things you need quickly and easily
01:56:07 <mq_mattr> hat == hate
01:57:11 <Cale> Having used both, I'd say ubuntu is probably easier to get into a usable configuration.
01:57:42 <Cale> But I'm fairly picky :)
01:57:49 <mq_mattr> ubuntu! how I loved you until you failed to recongnise my network hardware.  Now you are but a distant memory .....
01:58:58 * fnord123 wants to get a laptop with wifi and pop ubuntu on it... but is scared of the problems he's heard of
01:58:58 <Cale> Who ever uses a network driver other than tulip anyway? ;)
01:59:02 <mq_mattr> My first OS was beos since it was the only one that would recognise both the graphics card and the modem on my franken-pc
01:59:15 <mq_mattr> since then I jsut go with the hardware support :)
01:59:44 <dancor> is there any inherent reason that we start at 0 instead of 1 in computer indexing
01:59:46 <mq_mattr> wifi on anything bt windows/mac can be a real headache
01:59:57 <mq_mattr> that's where the numbers start
02:00:05 <mq_mattr> first integer is 0
02:00:09 <benc__> dancor: perhaps because if you refer to an array by its address
02:00:10 <dancor> hah
02:00:11 <mq_mattr> so the first index of an array is 0
02:00:15 <Cale> first natural number is 0
02:00:18 <benc__> dancor: by its start address
02:00:24 <mq_mattr> otherwise you are wasting a whole number
02:00:26 <mq_mattr> :)
02:00:26 <benc__> first integer is -Inf
02:00:33 <Cale> -Inf isn't an integer
02:00:34 <dancor> benc__: yeah i guess that must be it
02:00:44 <benc__> Cale: indeed
02:00:46 <fnord123> dijkstra wrote some pap about it as well. it works well for ranges in his arrogant opinion
02:01:09 <mq_mattr> it takes about 5 minutes to get used to it
02:01:20 <benc__> Cale: but its down that end of the line somewhere
02:01:21 <mq_mattr> but I will never be happy writing arr.length - 1
02:01:24 <fnord123> fwiw, Fortran defaults to 1
02:01:25 <mq_mattr> over and over again
02:01:27 <dancor> mq_mattr: off by one errors abound!
02:01:40 <mq_mattr> dancor: indeed
02:02:01 <mq_mattr> higher order functions take away such concerns anyway
02:02:18 <mq_mattr> > map (1+) [1,2,3,4]
02:02:19 <lambdabot>  [2,3,4,5]
02:02:31 <dancor> tell that to findIndex
02:02:31 <mq_mattr> who cares what the indexing was?
02:02:48 <mq_mattr> dancor: not *all the time*, of course
02:03:15 <nmessenger> ?google dijkstra indexing should start at zero
02:03:18 <lambdabot> http://programming.reddit.com/info/bvvl/comments/cbygz
02:03:18 <lambdabot> Title: E.W. Dijkstra Archive: Why numbering should start at zero (reddit.com)
02:03:34 <nmessenger> Much more eloquent than I could be
02:03:38 <therp> I wonder if there is any legitimacy of using the word "natural" in "natural numbers". I would agree that 0 is the first non-negative integer, but natural? what's the definition of natural?
02:03:49 <therp> s/would//
02:03:56 <fnord123> if eloquent means waffle waffle waffle, sure
02:04:14 <mq_mattr> therp: well, it is not natural enogh to be self-evident, so you may have a point
02:04:22 <nmessenger> fnord123: have you read Dijkstra's paper?
02:04:37 <dancor> nmessenger: interestingly, that link is all about python.  but it makes good points for python
02:04:49 <fnord123> nmessenger: yes
02:05:03 <nmessenger> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
02:05:06 <lambdabot> Title: E.W. Dijkstra Archive: Why numbering should start at zero (EWD 831), http://tinyurl.com/frrsq
02:05:28 <fnord123> in fact you'll see my synopsis on the reddit link you found
02:05:45 <dancor> fnord123: is waffle a new onomatopoeia that no one has told me about
02:06:11 <nmessenger> dancor: 'waffle' to my understanding is equivalent to 'blah'
02:06:12 <fnord123> http://www.urbandictionary.com/define.php?term=waffle
02:06:14 <lambdabot> Title: Urban Dictionary: waffle
02:06:29 <mq_mattr> why are we waffling-on about this
02:06:30 <mq_mattr> :)
02:07:52 <fnord123> http://en.wikipedia.org/wiki/Waffle_%28speech%29
02:08:01 <uccus> hi guys
02:08:13 <uccus> I don't get what the @jargon command does
02:08:20 <ski> therp : mayhaps it has to do with it measuring finite cardinality, iow, "how many ?", "their number amounts to .."
02:08:30 <uccus> can anyone give me a working example?
02:08:43 <nmessenger> ?jargon grok
02:08:45 <lambdabot> *** "grok" jargon "Jargon File (4.3.1, 29 Jun 2001)"
02:08:45 <lambdabot> grok /grok/, var. /grok/ vt. [common; from the novel "Stranger in a
02:08:45 <lambdabot>   Strange Land", by Robert A. Heinlein, where it is a Martian word meaning
02:08:45 <lambdabot>   literally `to drink' and metaphorically `to be one with'] The emphatic
02:08:45 <lambdabot>   form is `grok in fullness'. 1. To understand. Connotes intimate and
02:08:47 <lambdabot> [12 @more lines]
02:08:52 <nmessenger> @more
02:08:52 <lambdabot>   exhaustive knowledge. When you claim to `grok' some knowledge or
02:08:52 <lambdabot>   technique, you are asserting that you have not merely learned it in a
02:08:53 <lambdabot>   detached instrumental way but that it has become part of you, part of
02:08:55 <lambdabot>   your identity. For example, to say that you "know" {LISP} is simply to
02:08:57 <lambdabot>   assert that you can code in it if necessary - but to say you "grok" LISP
02:08:59 <lambdabot> [7 @more lines]
02:09:11 <uccus> ?jargon CCC
02:09:12 <lambdabot> No match for "CCC".
02:09:13 <nmessenger> @more
02:09:16 <therp> ski: right, but then we have the term cardinal numbers.
02:09:21 <uccus> ?jargon cardinal
02:09:22 <lambdabot> No match for "cardinal".
02:09:23 <dancor> nmessenger: you lost state!
02:09:26 <uccus> see?
02:09:29 <nmessenger> oh noes!
02:09:44 <ski> @jargon 42
02:09:45 <lambdabot> *** "4.2" jargon "Jargon File (4.3.1, 29 Jun 2001)"
02:09:45 <lambdabot> 4.2 /for' poynt too'/ n. Without a prefix, this almost invariably
02:09:45 <lambdabot>   refers to {BSD} Unix release 4.2. Note that it is an indication of
02:09:45 <lambdabot>   cluelessness to say "version 4.2", and "release 4.2" is rare; the number
02:09:45 <lambdabot>   stands on its own, or is used in the more explicit forms 4.2BSD or (less
02:09:47 <lambdabot> [3 @more lines]
02:09:55 <ski> heh
02:10:07 <ski> therp : but those can be infinite, too
02:11:05 <uccus> ?jargon jargon
02:11:06 <lambdabot> No match for "jargon".
02:11:11 <mq_mattr> lambdabot gets chatty
02:11:13 <uccus> what the
02:11:40 <ski> @jargon cargo-cult
02:11:41 <lambdabot> No match for "cargo-cult".
02:12:12 <therp> ski: sure, the natural numbers are also supposed to be infinite :) .. but I argue they clip around 10^80, or what was the number of atoms in the universe :) ..
02:12:27 <therp> ski: if we define "natural" == observable in nature
02:13:18 <ski> (the number of natural numbers are supposed to be infinite. the natural numbers themselves are not supposed to number infinite collections)
02:14:06 <therp> (I never meant different than that)
02:14:14 <therp> (I never meant anything different than that, I'm sorry for the typo)
02:15:11 <uccus> therp: why atoms? why not electrons? or photons? or neutrinos?
02:15:35 <Cale> I argue that Graham's number is a natural number
02:16:16 <uccus> I argue... erm... for the sake of arguing (yay!)
02:16:20 <dancor> therp: http://en.wikipedia.org/wiki/Ultrafinitism
02:16:22 <therp> uccus: that was arbitrary. Aren't definitions supposed to be arbitrary? :) (also because I don't now what is the estimated number of electrons, photons..)
02:17:10 <Cale> Despite the fact that the decimal expansion of 3 ^^^^ 3 could not be written down even if you could write a digit on every particle in the known universe, and Graham's number is far larger.
02:17:19 <zeeeee> how do i browse/search/install packages from hackagedb? is there any way to just install all extralibs? it's pretty frustrating to have to deal with dependencies
02:17:49 <therp> dancor: I like that. I add that to my "things 'god' forbid" list.
02:18:29 * dancor likes making lists
02:18:54 <Cale> finitism is mostly pretty silly
02:19:07 <dancor> then i guess this is ultrasilly
02:19:24 <Hirvinen> therp: How about the time since the Big Bang in expressed in Planck times? It's now only about 8x10^60, but assuming a perpetually expanding universe, it will approach infinity.
02:19:42 <Cale> It's worthwhile to consider what can be computed given physical constraints, it's not worthwhile to restrict yourself to that.
02:19:50 <dancor> i see infinity like i, not real but useful
02:20:26 <uccus> I frankly don't get it
02:20:29 <Cale> Especially given that the properties of the infinite objects you're concerned with might actually be things which are computable.
02:20:49 <uccus> in what sense the Graham number would not exist?
02:21:15 <uccus> in what sense does 3 exist anyway?
02:21:26 <dancor> uccus: if you can never see it (write it down) you might decide it's not really real or something
02:21:51 <uccus> I never see 3...
02:22:07 <Cale> In the sense of being able to realise the number as a number of some kind of physical object.
02:22:20 <Cale> (in principle at least)
02:22:27 <Cale> but this is a silly distinction
02:22:49 <uccus> it's an example of bad principles, if I may be so bold to say
02:22:54 <sieni> uccus: to exist is to be the value of a variable
02:22:55 <Cale> Already, combinatorial considerations take us far beyond what is physically realisable in that sense
02:23:00 <dancor> Cale: well i certainly find finite mathematics easier to trust..
02:23:03 <sieni> or something
02:23:08 <uccus> sieni: I like that :)
02:23:20 <ski> sieni : was that Tarski ?
02:23:25 <xpika> @users
02:23:25 <lambdabot> Maximum users seen in #haskell: 309, currently: 262 (84.8%), active: 28 (10.7%)
02:23:28 <sieni> ski: Quine
02:23:31 <ski> right
02:23:34 <araujo> morning
02:23:43 <dancor> i wonder how active is defined
02:24:07 <Cale> Like, for example, how many possible things can your monitor display?
02:24:09 <nmessenger> dancor: said something within the last x minutes?
02:24:24 <ski> @seen
02:24:24 <lambdabot> Lately, I have seen araujo, cale, dancor, hirvinen, mq_mattr, nmessenger, sieni, ski, therp, uccus, xpika and zeeeee.
02:24:42 <uccus> Cale: think about the number of possible quantum states... that's "physical" isn't it?
02:25:01 <Cale> It's also not a natural number.
02:25:47 <Cale> It's probably c, the cardinality of the reals.
02:26:12 <Cale> Or at least that, anyway
02:26:22 <uccus> I was thinking of something like the spin eigenstates... like 2 for an electron
02:29:12 <Cale> As soon as you start considering possible futures, rather than just the present, you start needing much larger numbers in some circumstances, anyway.
02:38:43 <ski> @seen the_future
02:38:43 <lambdabot> I saw the_future leaving #haskell 7m 8s ago, and .
02:39:16 <augustss> oh no!  Haskell has no future anymore!
02:40:52 <Vq^> hej herr Larsson
02:42:15 <daniel_larsson> moi? :)
02:42:19 <metaperl> lol
02:42:28 <norpan> danla?
02:43:14 <daniel_larsson> hmm?
02:43:51 <mq_mattr> I have lambdabot locally installed
02:43:52 <quazimodo> guys
02:44:06 * nmessenger grumbles that (unlines . lines) is not (id)
02:44:08 <mq_mattr> can he tell me the top level decs in a particular file?
02:44:09 <pbx> I've just taken a stab at installing Haskell 6.5 on my PowerBook (OS X 10.4.8). configure and make install proceeded without errors, but when I try to run ghci I get this error: http://dpaste.com/4092/     Should I just start over, and if so what's the path of least resistance on OS X?
02:44:21 <mq_mattr> decs == declarations
02:44:22 <quazimodo> because haskell s functional, would a never ending recursion eventually slow the computer down to nothing seeing as each layer needs a function memory space, if i remember correctly?
02:44:32 <mq_mattr> pbx: go get the binary, it is much easier
02:44:41 <mq_mattr> unless you really want 6.5
02:44:43 <Cale> quazimodo: There's tail-call optimisation.
02:44:55 <mq_mattr> (binary is 6.6)
02:45:37 <Cale> If a function returns the result of another function without transforming it somehow, there's no need to add a record to the stack before calling it.
02:45:45 <pbx> mq_mattr: Where is that? I see 6.4.1 here: http://haskell.org/ghc/download_ghc_641.html#macosx
02:45:46 <lambdabot> Title: GHC: Download version 6.4.1
02:46:07 <Cale> You can just let that function return its result directly to the original caller.
02:46:22 <daniel_larsson> http://haskell.org/ghc/download_ghc_66.html#macosxppc
02:46:23 <lambdabot> Title: GHC: Download version 6.6
02:46:31 <mq_mattr> beat me to it
02:46:37 <pbx> heh, thanks
02:46:38 <daniel_larsson> hmm... ppc...
02:46:42 <nmessenger> i.e. (foo (blah barf)) will call foo, foo will jump straight to blah, and blah will return to foo's caller
02:46:48 <daniel_larsson> nm, intel there too
02:46:57 <pbx> I'm PPC actually
02:47:00 <mq_mattr> dons: can lambdabot give me the top level declarations in a .hs file?
02:47:01 <daniel_larsson> oh ok :)
02:47:15 <zeeeee> help, why do i get this error when configuring ghc-6.6+extralibs (in OpenGL specifically)? "checking for C compiler default output... configure: error: C compiler cannot create executables"
02:47:23 <mq_mattr> you don't want to compile ghc on a PPC
02:47:29 <zeeeee> (i can build fine if i don't use extralibs)
02:47:34 <nmessenger> mq_mattr: :browse?
02:47:42 <Cale> However, laziness often gets in the way of tail-calls in the sense that parameters to functions aren't going to be evaluated until they're really needed. So tail-recursion without strictness analysis or explicit strictness annotation tends to result in code which builds up huge unevaluated expressions in memory.
02:47:46 <mq_mattr> [looks around] I think we have been here before
02:48:04 <mq_mattr> nmessenger: thats ghci/hugs
02:48:24 <pbx> mq_mattr: I'm not compiling though (unless "binary" means something different than it usually does!)
02:48:33 <nmessenger> mq_mattr: right, nvm
02:48:50 <Cale> This is easily fixed by adding a few seq's to force the parameters of the function to be evaluated before making the tail call. Better yet, you can use a higher-order function which does this for you, like foldl'.
02:48:51 <mq_mattr> pbx: you are right, but all other options involve compiling
02:49:12 <Cale> (at least, whenever that's convenient)
02:49:26 <ski> (however laziness sometimes makes possible O(1) space of functions that TCO can't optimize .. like mapping or filtering a lazy list)
02:49:43 <Cale> right, that's also true
02:50:03 <Cale> stream processing becomes extremely efficient
02:50:25 <nmessenger> do a thing, discard it, do the next thing...
02:52:13 <Cale> It's less about how long or how much space functions take to evaluate completely, and more about what they take to return the top-level data constructor.
02:52:30 <Cale> (and subsequent ones of course)
02:53:01 <ski> (also amortization can be taken into account)
02:53:03 <Cale> map is O(n) when you consider the whole list, but only has an O(1) impact on each element of the list
02:56:39 <Cale> laziness can be very good at taking things which would be insane or unworkable approaches to problems in a strict language and making them reasonable and even quite efficient.
02:57:50 <Cale> Want to explore a game-tree? Define the whole tree and consume it lazily.
02:57:57 <zeeeee> where do i get FilePath? (required by missingh)
02:58:39 <Cale> http://software.complete.org/missingh/wiki/RelatedSoftware
02:58:42 <lambdabot> Title: RelatedSoftware - MissingH
02:58:44 <Cale> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
02:58:48 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/hagza
02:59:01 <zeeeee> Cale: thanks
03:02:53 <cperfumo> hi. Does anybody know how to generate alpha code with GHC?
03:12:13 <nmessenger> filter (not . null) is a common enough function, is it given a name anywhere in the libraries?
03:13:01 <nmessenger> cperfumo: alpha code? Like partially unwritten?
03:13:42 <nmessenger> cperfumo: you could little unimplemented functions with (error "Unimplemented: function blah in file foo")
03:13:51 <nmessenger> s/little/litter/
03:14:34 <nmessenger> ?pl filter (not . null)
03:14:34 <lambdabot> filter (not . null)
03:15:28 <quazimodo> dons, what was the preffix you gave to ./configure to make it install to your ~
03:15:55 <sieni> --prefix?
03:15:59 <quazimodo> thats it?
03:16:14 <sieni> 10:06 <dons> quazimodo: ./configure --prefix=/home/dons -- ;)
03:16:40 <quazimodo> thnx, was just doing emacs Freenode-#haskell.log
03:19:55 <pbx> Thanks for the OS X advice earlier -- ghci is now working!
03:20:33 <metaperl> if I did a deriving (Eq) for this, how would it decide equality: data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)
03:21:14 <pbx> (did "runhaskell" turn into "runghc" at some point?  Just trying to clean up the leftovers from previous install attempts...)
03:22:10 <nmessenger> metaperl: (Leaf x == Leaf y = x == y; Branch x == Branch y = x == y) I think
03:22:54 <metaperl> yeah, that's what I don't know
03:23:14 <nmessenger> metaperl: er, (Leaf x == Leaf y = x == y; Branch x y == Branch x' y' = x == x' && y == y') I think
03:24:14 <nmessenger> ?google Haskell Eq deriving clause semantics
03:24:18 <lambdabot> http://journals.cambridge.org/article_S0956796802004380
03:24:39 <nmessenger> blah
03:27:14 <xpika> does anyone know the lambdabot command to find functions with a prototype [a] -> [[a]]
03:27:30 <metaperl> @hoogle [a] -> [[a]]
03:27:31 <lambdabot> List.inits :: [a] -> [[a]]
03:27:31 <lambdabot> List.tails :: [a] -> [[a]]
03:27:31 <lambdabot> List.group :: Eq a => [a] -> [[a]]
03:27:41 <metaperl> ?url hoogle
03:27:42 <lambdabot> http://www.haskell.org/hoogle
03:28:39 <nmessenger> xpika: are you looking for the ubiquitous groupN 3 [1,2,3,4,5,6,7,8,9] == [[1,2,3],[4,5,6],[7,8,9]] ?
03:29:54 <Syzygy-> My 6.6 installation still has runhaskell.
03:30:04 <nmessenger> xpika: or a split "," "blah, boo,g e h" == ["blah", " boo", "g e h"]
03:30:33 <Syzygy-> ?hoogle groupN
03:30:34 <lambdabot> No matches found
03:30:58 <nmessenger> Syzygy-: I found one in the Hugs demo code
03:31:17 <nmessenger> groupN n = takeWhile (not . null) . map (take n) . iterate (drop n)
03:31:19 <pbx> Syzygy-: Thanks. What's the difference between "runhaskell" and "runghc"?
03:31:42 <bortzmeyer> runhaskell may run another compiler
03:32:09 <bortzmeyer> On a Debian machine, the "aletrnatives" mechanism can be used to select which one
03:34:14 <nmessenger> metaperl: http://lml.ls.fi.upm.es/~jjmoreno/manual/haskell98-report/derived.html#derived-appendix
03:34:19 <lambdabot> Title: The Haskell 98 Report: Derived Instances, http://tinyurl.com/ykmj42
03:34:45 <metaperl> nmessenger - thanks. a bit of a heady read for me, I think
03:35:14 <metaperl> nmessenger - D.5 An Example will probably cover me
03:35:50 <xpika> can anyone get this to work?
03:36:11 <xpika> > map (\x -> print x) [1,2,3]
03:36:12 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
03:36:37 <Vq^> xpika: what should it do?
03:36:48 <nmessenger> > sequence (map print [1,2,3])
03:36:49 <lambdabot>  <IO [()]>
03:36:52 <ski> @type mapM (\x -> print x) [1,2,3]
03:36:54 <lambdabot> IO [()]
03:36:57 <ski> @type mapM_ (\x -> print x) [1,2,3]
03:36:59 <lambdabot> IO ()
03:37:01 <ski> ^^ better
03:37:12 <ski> @type forM_
03:37:13 <lambdabot> Not in scope: `forM_'
03:37:16 <ski> bah
03:37:51 <nmessenger> ?hoogle for m
03:37:51 <lambdabot> Did you mean: For m
03:37:52 <lambdabot> Prelude.undefined :: a
03:37:52 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:37:58 <nmessenger> ?hoogle forM
03:37:59 <lambdabot> Text.Html.form :: Html -> Html
03:37:59 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
03:37:59 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
03:38:06 <nmessenger> ?hoogle+
03:38:30 <ski> forM_ :: [a] -> (a -> IO b) -> IO ()
03:38:36 <ski> forM_ = flip mapM_
03:39:18 <nmessenger> forM_ [1,2,3] print -- looks like imperative foreach
03:39:43 <ski> do ...
03:39:49 <ski>    forM_ [1,2,3] $ \n -> do
03:39:52 <ski>    print n
03:40:08 <nmessenger> ?pl \n -> do print n
03:40:09 <lambdabot> do print
03:40:11 <ski> (or indent the 'print n' body if you like)
03:40:16 <nmessenger> ?. undo pl \n -> do print n
03:40:16 <lambdabot> print
03:40:45 <bortzmeyer> > mapM_ (\x -> print x) [1, 2, 3]
03:40:46 <lambdabot>  <IO ()>
03:41:02 <bortzmeyer> lambdabot produces a worse output than ghci :-)
03:41:14 <nmessenger> lambdabot can't do IO safely
03:41:17 <bortzmeyer> But the above works.
03:41:21 <nmessenger> (on IRC)
03:42:00 <ski> it just prints an IO-action by printing its type
03:42:26 <bortzmeyer> OK, does not matter, with ghci, it works fine
03:42:49 <nmessenger> you could also ((print . concat . map show) [1,2,3])
03:42:58 <nmessenger> :P
03:43:16 <cperfumo> Ok, I will try to explain my problem with in a more detailed manner: I want to generate C code that later will be compiled to alpha asm. Currently I get the C code but when I want to compile it with GCC (not fot alpha but for x86) I get an error:
03:43:22 <cperfumo> gcc Factorial.c
03:43:22 <cperfumo> /tmp/ccQ7tN9e.s: Mensajes del ensamblador:
03:43:22 <cperfumo> /tmp/ccQ7tN9e.s:52: Error: basura al final de la línea; el primer carácter ignorado es `-'
03:43:40 <cperfumo> it means: "Assembler messages"
03:43:50 <bortzmeyer> LANG=C before running the compiler would help the international readership
03:44:10 <cperfumo> "Error: garbage in the end of the line; first ignored character is "-"
03:44:26 <cperfumo> but there is no "-" in the generated code
03:44:46 <ski> in the asm source ?
03:45:05 <Syzygy-> cperfumo: The - is in the file /tmp/ccQ7tN9e.s; which is a gcc-generated stage, I think with asm-code.
03:46:30 <cperfumo> so, what could I do in order to avoid this "-" problem and run the program? any idea?
03:48:21 <xpika> can anyone get this to work?
03:48:41 <xpika> > [print,print] `ap` [1]
03:48:42 <lambdabot>  [<IO ()>,<IO ()>]
03:53:20 <ski> hi xerox
03:53:32 <ski> xpika : what is the expected result ?
03:53:48 <ski> do you have a somewhat bigger example of what you want ?
03:54:54 <ski> Monad m => [a -> m b] -> [a] -> m [b]
03:54:54 <ski> ?
03:55:13 <edi> 'lo ski.
03:56:47 <nmessenger> ?type mapM
03:56:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
03:57:09 <nmessenger> ?type map mapM
03:57:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a -> m b] -> [[a] -> m [b]]
03:57:44 <int-e> @type sequence
03:57:46 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
03:58:32 <ski> @type \fs as -> liftM concat (mapM (\f -> mapM f as) fs)
03:58:33 <lambdabot> forall (m :: * -> *) b a. (Monad m) => [a -> m b] -> [a] -> m [b]
03:59:11 <nmessenger> ?pl \fs as -> liftM concat (mapM (\f -> mapM f as) fs)
03:59:11 <lambdabot> (fmap join .) . flip (mapM . flip mapM)
04:02:12 <xpika> ok i figured out a way
04:02:16 <xpika> sequence ( [print,print] `ap` [2] ) >>= return
04:02:53 <xpika> but does look overly verbose
04:03:36 <nmessenger> ?pl foo >>= return
04:03:37 <lambdabot> foo
04:03:40 <ski> '>>= return' is superfluos
04:04:00 <xpika> so it is :)
04:04:20 <edi> :t sequence [print, print] 2
04:04:22 <lambdabot> [IO ()]
04:04:23 <Syzygy-> xpika: What was this good for?
04:04:27 <xpika> that's what happens when you code by iteration
04:04:40 * ski 's got a feeling xpika's 'apM' could possibly fit into Data.FunctorM or related ..
04:05:26 <nmessenger> ?pl sequence (blargh `ap` death)
04:05:26 <lambdabot> sequence (blargh `ap` death)
04:05:35 <Excedrin> what's ap?
04:05:40 <nmessenger> ?type ap
04:05:41 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
04:06:09 <nmessenger> ?type ap [(+1), (+3)]
04:06:10 <lambdabot> forall a. (Num a) => [a] -> [a]
04:06:20 <ski> > [(+),(*)] `ap` [2,3.4] `ap` [100,200]
04:06:21 <lambdabot>  [102.0,202.0,103.4,203.4,200.0,400.0,340.0,680.0]
04:06:32 <ski> > [(+),(*)] `ap` [2,3,4] `ap` [100,200]  -- typo :)
04:06:34 <lambdabot>  [102,202,103,203,104,204,200,400,300,600,400,800]
04:07:01 <nmessenger> 3.4 -> 3,4
04:07:12 <ski> yah
04:08:09 <ski> > return (:) `ap` "012" `ap` ["abc","ABC"]
04:08:10 <lambdabot>  ["0abc","0ABC","1abc","1ABC","2abc","2ABC"]
04:08:14 <ski> > (:) `liftM` "012" `ap` ["abc","ABC"]
04:08:15 <lambdabot>  ["0abc","0ABC","1abc","1ABC","2abc","2ABC"]
04:08:35 <int-e> liftM2 (:)
04:08:42 <ski> yah
04:08:56 <nmessenger> ?yarr!
04:08:56 <lambdabot> I want me grog!
04:10:47 <ski> apM :: (ApplicativeM f ,Monad m) => f (a -> m b) -> (f a) -> m (f b))
04:10:48 <ski> ?
04:10:48 <nmessenger> > liftM2 (:) `ap` "012" `ap` ["abc","ABC"]
04:10:49 <lambdabot>  Couldn't match `(->) (m a1)' against `[]'
04:11:09 <ski> > liftM2 (:) "012" ["abc","ABC"]
04:11:10 <lambdabot>  ["0abc","0ABC","1abc","1ABC","2abc","2ABC"]
04:11:18 <edi> ski - did you see loeb?
04:11:22 <nmessenger> avast?
04:11:26 <nmessenger> s/?/!/
04:11:35 <nmessenger> sigh
04:11:39 <ski> edi : probably not, since i don't know what that is
04:11:56 <edi> ski - Check out the latest sigfpe post, pretty nice.
04:11:59 <nmessenger> ?google loeb haskell blog
04:12:00 <lambdabot> https://beta.blogger.com/comment.g?blogID=11295132&postID=1709827116482950347
04:12:15 <ski> ?google loeb sigfpe
04:12:17 <lambdabot> http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
04:12:17 <lambdabot> Title: A Neighborhood of Infinity: From L&ouml;b's Theorem to Spreadsheet Evaluation
04:13:12 <ski> edi : oh .. yes, read it briefly
04:13:52 <nmessenger> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
04:13:53 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
04:15:19 <ski> mhm, not seen this one
04:15:57 <ski> looks cool :)
04:17:57 <nmessenger> I totally don't understand loeb, but on first look it seems I'll have to give it the attention I did the Y combinator
04:18:58 <xpika> i know what (a->b) means but what about m (a -> b) like in the function ap
04:19:32 <nmessenger> xpika: in the case of that expression, I'm pretty sure m is [].
04:19:51 <xpika> ok
04:19:57 <nmessenger> so m (a -> b) substitutes as [a -> b]
04:23:01 <ski> ap :: [a -> b] -> [a] -> [b]
04:23:07 <ski> map :: (a -> b) -> [a] -> [b]
04:23:17 <nmessenger> oh!
04:23:41 <nmessenger> map without the mmm!
04:23:42 <ski> in this case
04:24:17 <ski> ap fs as = concatMap (\f -> map f as) fs
04:24:26 <ski> or
04:24:34 <ski> ap fs as = concat (map (\f -> map f as) fs)
04:24:36 <ski> or
04:24:48 <ski> ap fs as = [f a | f <- fs , a <- as]
04:25:16 <ski> nmessenger : actually i think 'ap' is short for 'apply'
04:25:29 <nmessenger> yeah, just a cute little observation
04:25:31 <ski> ap :: [a -> b] -> [a] -> [b]
04:25:41 <ski> ($) :: (a -> b) -> a -> b
04:25:50 <Jaak> @pl \f g x -> f x (g x)
04:25:51 <lambdabot> ap
04:25:51 <nmessenger> O.O
04:26:21 <earthy> that's S...
04:26:37 <nmessenger> yeppers, someone told me about that earlier
04:26:50 <earthy> hadn't thought of ap as S before
04:27:49 <nmessenger> ski: is your nick based on the sport or the calculus? ;P
04:29:52 <ski> nmessenger : indeed
04:30:27 * earthy renames ski ap const id
04:30:36 <ski> @pl \c x -> x
04:30:37 <lambdabot> const id
04:30:41 <ski> @pl \c x -> c
04:30:42 <lambdabot> const
04:30:52 <ski> that's 'return' in environment
04:32:41 <nmessenger> > ap const id "ski"
04:32:42 <lambdabot>  "ski"
04:32:56 <earthy> @pl ap const id
04:32:57 <lambdabot> id
04:33:05 <nmessenger> :D
04:33:08 <earthy> :P
04:34:00 * ski is really trivial, yes :)
04:35:52 <nmessenger> \x. skix -> \x. kx(ix) -> \x. x -> i
04:37:40 <nmessenger> > ap id id (ap id id)
04:37:41 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> b
04:37:41 <lambdabot>    Expec...
04:37:52 <nmessenger> > (ap id id) (ap id id)
04:37:53 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> b
04:37:53 <lambdabot>    Expec...
04:38:19 <nmessenger> bottom!
04:38:29 <nmessenger> (right?)
04:39:02 <ski> at type level
04:39:34 <nmessenger> meh, who needs types when in the SKI calculus? ;)
04:40:27 <ski> @lambda S I I (S I I)
04:40:35 <lambdabot> out of fuel - use @resume to continue
04:40:39 <ski> :)
04:40:44 <nmessenger> :))
04:40:53 <ski> @lambda S K I "S K I"
04:40:54 <lambdabot> S K I
05:12:16 <kowey> hmm... laziness... the kink in my "haskell as a great scripting language" theory
05:13:04 <audreyt> you just need to sprinkle some ! in params and datatype fields and haskell becomes nonlazy :)
05:13:23 <kowey> (i.e. the thinking was that I could stop writing one-off file processing scripts in Perl and just crank through them in Haskell instead [sorry audreyt :-)])
05:13:32 <Philippa> and sometimes laziness makes Haskell a better scripting language
05:13:34 <audreyt> -fbang-patterns
05:13:52 <kowey> yeah, i have stuff like: let forceRead = seq (length os)
05:14:14 <kowey> forceRead . return -- to avoid "too many open files"
05:14:32 <kowey> but try telling that to a linguistics grad student, or an intern
05:14:33 <audreyt> you aware of this?
05:14:36 <audreyt> f x! y! = x + y
05:14:49 <AStorm> There is a nice library for reading files :P
05:14:56 <AStorm> readfile.hs
05:14:57 <Philippa> kowey: don't, just hand 'em a lib that does it for them
05:15:04 <audreyt> er
05:15:07 <audreyt> f !x !y = x + y
05:15:19 <kowey> Philippa: ah!
05:15:27 <AStorm> @pl f !x !y = x + y
05:15:28 <lambdabot> (line 1, column 9):
05:15:28 <lambdabot> unexpected "="
05:15:28 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
05:15:39 <Philippa> that, and consider opening the file manually, doing hGetContents and then manually closing it
05:15:40 <AStorm> Hmm, can't?
05:15:45 <AStorm> @pl f x y = x + y
05:15:45 <lambdabot> f = (+)
05:15:56 <Philippa> (and wrapping that pattern in a function, of course)
05:16:02 <AStorm> So? f = ($!) . (+)
05:16:03 <kowey> audreyt: looks handy
05:16:09 <Philippa> obviously you do some actual work on it in the middle :-)
05:17:40 <kowey> i still haven't built up a good battery of intuitions about this yet
05:18:07 <kowey> for example, seq'ing the list (or the string) isn't enough;
05:18:11 <edi> > let f = (. join seq) . (+) . join seq in f 1 2
05:18:13 <lambdabot>  3
05:18:14 <kowey> you have to seq its length or something
05:18:30 <kowey> (this is in my just-do-what-make-it-go blindness of course)
05:18:56 <kowey> i'm guessing that's because, if you just seq the list, only its head is evaluated
05:19:52 <ski> audreyt : quazimodo had some problem with readline and ghc on fbsd earlier, dons thought you possibly could help
05:19:53 <AStorm> edi, why is that better than ($!) . (+)?
05:20:10 <edi> That is not strict in one parameter.
05:20:15 <audreyt> ski: no longer on fbsd myself
05:20:17 <AStorm> Hmm... right.
05:20:31 <AStorm> So ($!) . (+) . ($!) maybe?
05:20:53 <edi> No.
05:21:13 <AStorm> Hmm... you're right.
05:21:27 <AStorm> (+) . ($! .) . (. $!) or something
05:21:37 <ski> (Philippa : hm, i thought one shouldn't close semi-closed handles ..)
05:23:03 <AStorm> edi, uh, you're probably right.
05:23:18 <AStorm> Anyway, it's pointless. :P
05:23:31 <nmessenger> ?pl \f x y -> ((f $! x) $! y)
05:23:31 <lambdabot> (($!) .) . ($!)
05:24:13 <ski> @type (($!) .) . (. ($!))
05:24:14 <lambdabot> forall a b a1 b1. ((a1 -> b1) -> a -> b) -> (a1 -> b1) -> a -> b
05:24:21 <ski> nah
05:24:36 <AStorm> ?type (($!) .) . ($!)
05:24:38 <nmessenger> ?. type pl \f x y -> ((f $! x) $! y)
05:24:42 <lambdabot> forall a b a1. (a1 -> a -> b) -> a1 -> a -> b
05:24:45 <lambdabot> forall a b a1. (a1 -> a -> b) -> a1 -> a -> b
05:24:58 <edi> ?type ($!) . ((+) $!)
05:25:00 <lambdabot> forall a. (Num a) => a -> a -> a
05:25:19 <nmessenger> ?type $!#%/!@%&$!
05:25:19 <AStorm> Hehe.
05:25:20 <lambdabot> parse error on input `$!#%/!@%&$!'
05:25:26 <edi> :)
05:25:36 <AStorm> ?define $!##@$#%@!!$@! = "shit"
05:25:37 <lambdabot> (line 1, column 2):
05:25:37 <lambdabot> unexpected "="
05:25:37 <lambdabot> expecting space or simple term
05:25:53 <nmessenger> parens?
05:25:58 <AStorm> ?define ($!##@$#%@!!$@!) = "shit"
05:25:59 <lambdabot> (line 1, column 2):
05:25:59 <lambdabot> unexpected "="
05:25:59 <lambdabot> expecting space or simple term
05:26:14 <nmessenger> ?help define
05:26:15 <lambdabot> define <name> <expr>. Define name to be expr
05:26:18 <AStorm> Blah me.
05:26:21 <AStorm> ?define ($!##@$#%@!!$@!) "shit"
05:26:22 <lambdabot> ($!##@$#%@!!$@!) defined
05:26:29 <nmessenger> ?help let
05:26:30 <lambdabot> let <x> = <e>. Add a binding
05:26:47 <AStorm> > L.$!##@$#%@!!$@!
05:26:48 <lambdabot>  Parse error
05:26:52 <AStorm> > L.($!##@$#%@!!$@!)
05:26:53 <lambdabot>  Not in scope: `$!##@$#%@!!$@!'
05:27:00 <nmessenger> left paren before L.
05:27:08 <AStorm> > (L.$!##@$#%@!!$@!)
05:27:08 <lambdabot>  Not in scope: `L.$!##@$#%@!!$@!'
05:27:29 <nmessenger> ?where $!##@$#%@!!$@!
05:27:30 <lambdabot> I know nothing about $!##@$#%@!!$@!.
05:27:33 <AStorm> Has to be let probably.
05:27:44 <nmessenger> what does ?define do?
05:28:24 <nmessenger> ?where ($!##@$#%@!!$@!)
05:28:25 <lambdabot> I know nothing about ($!##@$#%@!!$@!).
05:28:29 <ski> @help define
05:28:29 <lambdabot> define <name> <expr>. Define name to be expr
05:28:51 <nmessenger> defines it *where* exactly?
05:28:51 <AStorm> ?$!##@$#%@!!$@!)
05:28:52 <lambdabot> Unknown command, try @list
05:28:54 <kowey> AStorm++ (restoring my faith: http://www.mail-archive.com/haskell@haskell.org/msg16951/readfile.hs )
05:28:56 <lambdabot> http://tinyurl.com/y2fkuw
05:28:57 <AStorm> ?($!##@$#%@!!$@!)
05:28:58 <lambdabot> Unknown command, try @list
05:29:19 <ski> @define SKI S K I
05:29:20 <lambdabot> SKI defined
05:29:25 <ski> @lambda SKI "SKI"
05:29:25 <lambdabot> SKI
05:29:39 <ski> @list lambda
05:29:39 <lambdabot> lambda provides: lambda define get-definition definitions resume
05:29:52 <dmhouse> ?help lambda
05:29:53 <lambdabot> lambda <expr>. Evaluate the lambda calculus expression, <expr>
05:29:57 <nmessenger> ?lambda ($!##@$#%@!!$@!)
05:29:58 <lambdabot> (line 1, column 2):
05:29:58 <lambdabot> unexpected "$"
05:29:58 <lambdabot> expecting simple term
05:30:10 <dmhouse> ?lambda (\x y -> y) (\x -> x)
05:30:11 <lambdabot> <<Plugin.Lambda.LMEngine.EvalMonad Dynamic -> Plugin.Lambda.LMEngine.EvalMonad Dynamic>>
05:30:18 <dmhouse> Oh, how pretty.
05:30:22 <dmhouse> ?lambda (\x y -> y) 4
05:30:22 <lambdabot> <<Plugin.Lambda.LMEngine.EvalMonad Dynamic -> Plugin.Lambda.LMEngine.EvalMonad Dynamic>>
05:30:22 <ski> ?lambda (\x y -> y) (\x -> x) "foo"
05:30:23 <lambdabot> foo
05:30:35 <edi> lambdabot> > 2+2
05:30:35 <edi>  fd:6: hClose: resource vanished (Broken pipe)
05:30:38 <dmhouse> ski: Yes, okay, but it should still render functions prettier than that.
05:30:43 <edi> Anybody knows the standard solution to that problem?
05:30:44 <dmhouse> edi: ouch.
05:30:47 <edi> I do not remember.
05:30:55 <dmhouse> edi: a plumber? :)
05:31:47 <AStorm> not hClosing?
05:32:00 <AStorm> Catching the exception?
05:32:09 <edi> unknown symbol `_base_GHCziList_take_closure'
05:32:09 <edi> runplugs: user error (resolvedObjs failed.)
05:32:18 <edi> ...calling runplugs from the commandline.
05:32:53 <AStorm> Now that's a major problem.
05:33:05 <AStorm> Rebuild the program to use the newer GHC you've installed
05:35:47 <edi> And then lambdabot again?
05:38:08 <quazimodo> audreyt, hello
05:38:39 <quazimodo> audreyt, as ski mentioned before i am having a couple of problems, did you have ghci working fine under fbsd 6?
05:38:50 <audreyt> no, I no longer run fbsd :/
05:38:57 <audreyt> <- darwin
05:39:12 <quazimodo> no no i mean, before, was it working?
05:39:16 <quazimodo> even under another bsd
05:39:21 <quazimodo> say 5 r 4
05:40:13 <Templar2> is there any command to remove/delet items from a list?(whant to make a list with only uniq numbers with list comp.)
05:40:23 <audreyt> it did, but it was 6.4
05:40:26 <audreyt> GHC 6.4 I mean
05:40:27 <nmessenger> nub?
05:40:37 <quazimodo> that is what i am using
05:40:45 <quazimodo> 6.4.2, there is no 6.6 ported to freebsd
05:40:50 <audreyt> oh. I just grabbed ports and it Just Worked
05:40:55 <audreyt> so 'mfraid you'd have to ask haskell@
05:40:56 <quazimodo> ah
05:40:57 <Templar2> ty
05:41:00 <quazimodo> you dont have your back ups at all?
05:41:01 <nmessenger> > nub [1,2,3,3,2,2,1,2,2,1,3]
05:41:03 <lambdabot>  [1,2,3]
05:41:10 <audreyt> I do not... :/
05:41:38 <quazimodo> i take back ups of my entire system on external storage, thought maybe you do too, i could maybe coerce you into giving me a tarball of the ghc files, but nvm :)
05:41:42 <cperfumo> nub "there's a place where I can go"
05:42:02 <cperfumo> > nub "there's a place where I can go"
05:42:04 <lambdabot>  "ther's aplcwIngo"
05:42:52 <cperfumo> sorry everybody, I'm new and I wanted to test lambdabot
05:43:01 <Templar2> but nub makes it to easy, any ideas how to make it with list comprehencen?
05:43:07 <nmessenger> > nub "Your mother was a hamster and your father smelt of elderberries!"
05:43:08 <lambdabot>  "Your mthewasndyflbi!"
05:43:20 <Templar2> uniq xs = [x | x <- xs, ???]
05:43:47 <ski> @type let x .$!. y = x . ($!) . y in flip ((.$!.) . (.$!.) . (.$!.) . (.$!.) $ id) () . const
05:43:48 <edi> Templar2 - You can't write it like that.
05:43:48 <lambdabot> forall a a1 a2 b a3. (a -> a1 -> a3 -> a2 -> b) -> a -> a1 -> a3 -> a2 -> b
05:43:50 <AStorm> cperfumo, /msg lambdabot
05:43:55 <ski> edi : how about that ?
05:44:44 <edi> ski - Neat.
05:44:52 <nmessenger> cperfumo: be sure to use @list and @help a lot!  Also, if you just say @, LB'll show her commands.
05:45:16 <nmessenger> cperfumo: (via /msg I mean)
05:45:27 <Templar2> ski was that for the uniq question?
05:45:45 <ski> Templar2 : sorry, no
05:45:52 <Templar2> ski okok
05:47:11 <ski> Templar2 : i think there's no special way to do it with list comprehensions
05:47:16 <nmessenger> ?let elderberries = "Your mother was a hamster and your father smelt of elderberries!"
05:47:17 <lambdabot> Defined.
05:47:43 <edi> ski - Your understanding of continuations is striking :)
05:48:04 <Templar2> ski ok, thx, leave it behind me then
05:48:58 <nmessenger> Does anyone know how to list LB's @let bindings?
05:49:06 <Syzygy-> > length L.elderberries
05:49:07 <lambdabot>  64
05:49:29 <ski> edi : er .. did i use continuations somewhere ?
05:49:48 <nmessenger> ski: perhaps (s)he meant compositions
05:49:53 <Templar2> !topic
05:49:57 <Templar2> topic
05:50:08 <ski> Templar2 : /topic #haskell
05:50:10 <edi> ?type let x .$!. y = x . ($!) . y in flip ((.$!.) $ id)
05:50:12 <lambdabot> forall a b b1. b1 -> (b1 -> a -> b) -> a -> b
05:50:14 <Templar2> ty/
05:50:29 <edi> Am I interpreting that b1 in the wrong way?
05:50:59 <ski> possibly there's continuations hiding there .. i didn't notice them, however :)
05:51:00 <edi> I think 'id' is used in the same way as
05:51:10 <edi> ?type flip runCont id
05:51:12 <lambdabot> Not in scope: `runCont'
05:51:26 <ski> @type flip Control.Monad.Cont.runCont id
05:51:27 <lambdabot> forall a. Control.Monad.Cont.Cont a a -> a
05:51:52 <edi> dons: ping?
05:52:07 <ski> (i was thinking maybe there was an environment hiding, but didn't think of continuations)
05:52:47 <edi> @type let x .$!. y = x . ($!) . y in (.$!.)
05:52:49 <lambdabot> forall a b c a1. ((a -> b) -> c) -> (a1 -> a -> b) -> a1 -> c
05:53:17 <ski> @type \($!) -> x . ($!) . y
05:53:18 <lambdabot> Not in scope: `x'
05:53:18 <lambdabot>  
05:53:18 <lambdabot> <interactive>:1:20: Not in scope: `y'
05:53:23 <ski> @type \($!) x y -> x . ($!) . y
05:53:24 <lambdabot> forall c b c1 a. (b -> c1) -> (c1 -> c) -> (a -> b) -> a -> c
05:53:48 <nmessenger> edi: kinda like (.) but with an (a -> b) in the middle?
05:55:18 <ski> (edi : the 'flip' was an afterthought)
05:56:02 <nmessenger> ski: what is this syntax \($!)?
05:57:26 <nmessenger> wait, you can bind lambda arguments to operator names?!
05:57:32 <ski> nmessenger : just a normal lambda, binding a local variable
05:57:40 <ski> sure :)
05:57:59 * nmessenger is not sure why he didn't realize such a simple thing before
05:58:29 <ski> foldr (+) z [    ] = z
05:58:40 <ski> foldr (+) z (a:as) = a + foldr (+) z as
05:58:49 <ski> e.g.
05:59:06 <nmessenger> I've not ever seen an operator name used as a param, just as a function.
05:59:27 <ski> you can't change fixity and precedence locally, though
05:59:56 <nmessenger> so rebinding already-fixed operators would preserve fixity?
06:00:35 <daniel_larsson> quazimodo: what version of fbsd and what version of ghc are you looking for?
06:01:58 <quazimodo> daniel_larsson, i have 6.1 and i compiled 6.4.2 (only one available in ports) but the readline isnt compiling into it, oddly
06:02:00 <quazimodo> but dont worry
06:02:12 <quazimodo> i ran cvsup and trying again now
06:02:54 <AStorm> nmessenger, function can be a param
06:02:59 <AStorm> an operator is a function too
06:03:03 <AStorm> go figure :P
06:03:20 <daniel_larsson> ok, that's what I have too. I didn't check readline support though so I guess my build has the same problem :)
06:04:20 <nmessenger> Yorm the was Andy Filby!
06:04:45 <nmessenger> > nub L.elderberries
06:04:46 <lambdabot>  "Your mthewasndyflbi!"
06:05:28 <AStorm> >undef elderberries
06:05:29 <ski> nmessenger : yes
06:05:33 <AStorm> ?undef elderberries
06:05:34 <lambdabot> Undefined.
06:05:38 <nmessenger> :(
06:05:56 <AStorm> Ha! ;-)
06:06:55 <nmessenger> ?let aStorm = cycle "elderberry hater "
06:06:57 <lambdabot> Defined.
06:07:28 <AStorm> > nub aStorm
06:07:29 <lambdabot>  Not in scope: `aStorm'
06:07:34 <AStorm> > nub L.aStorm
06:07:38 <lambdabot> Terminated
06:07:42 <AStorm> Blah.
06:08:32 <nmessenger> > take 20 (nub L.aStorm)
06:08:36 <lambdabot> Terminated
06:08:59 <nmessenger> > nub (take 20 L.aStorm)
06:09:01 <lambdabot>  "eldrby hat"
06:09:24 <nmessenger> Elderby Hat!
06:09:41 * nmessenger puts on elderby hat
06:09:51 <AStorm> > let lambdabot = "tobadbmal"
06:09:52 <lambdabot>  Parse error
06:09:57 <AStorm> ?let lambdabot = "tobadbmal"
06:09:58 <lambdabot> Defined.
06:10:16 <nmessenger> > reverse L.lambdabot
06:10:17 <lambdabot>  "lambdabot"
06:10:29 <nmessenger> ?. read eval reverse L.lambdabot
06:10:29 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
06:12:25 <nmessenger> EVERYONE ADMIRE MY ELDERBY HAT!!
06:12:26 <AStorm> Hmm, that lazySlurp from readfile.hs sounds just like CRM114 input
06:12:46 <AStorm> @quote nmessenger
06:12:47 <lambdabot> nmessenger hasn't said anything memorable
06:12:59 <nmessenger> still new here
06:13:06 <AStorm> @remember nmessenger EVERYONE ADMIRE MY ELDERBY HAT!!
06:13:29 * nmessenger sings and dances :D
06:13:52 <AStorm> ?undef L.aStorm
06:13:53 <lambdabot> Undefined.
06:14:05 <ski> @let aStorm = "elderberry hater "
06:14:06 <lambdabot> Defined.
06:14:09 <ski> @let nub [] = []; nub (a:as) = a : filter (a /=) (L.nub as)
06:14:10 <lambdabot> Defined.
06:14:11 <ski> > take 10 (L.nub L.aStorm)
06:14:12 <lambdabot>  "eldrby hat"
06:14:17 * nmessenger 's elderby hat suddenly vanishes, then reappears
06:14:36 <ski> > take 11 (L.nub L.aStorm)
06:14:37 <lambdabot>  "eldrby hat"
06:14:41 <AStorm> ski, that was to work on aStorm = cycle "elderberry hater"
06:14:47 <ski> oops
06:14:49 <ski> @undefine
06:14:50 <lambdabot> Undefined.
06:14:56 <ski> @let aStorm = cycle "elderberry hater "
06:14:57 <lambdabot> Defined.
06:15:02 <ski> @let nub [] = []; nub (a:as) = a : filter (a /=) (L.nub as)
06:15:03 <lambdabot> Defined.
06:15:04 <ski> > take 10 (L.nub L.aStorm)
06:15:05 <lambdabot>  "eldrby hat"
06:15:07 <ski> > take 11 (L.nub L.aStorm)
06:15:10 <lambdabot>  Exception: stack overflow
06:15:16 <ski> @undefine
06:15:16 <lambdabot> Undefined.
06:15:22 <ski> @let aStorm = cycle "elderberry hater "
06:15:22 <lambdabot> Defined.
06:15:30 <ski> @let nub [] = []; nub (a:as) = a : L.nub (filter (a /=) as)
06:15:31 <lambdabot> Defined.
06:15:33 <ski> > take 10 (L.nub L.aStorm)
06:15:34 <lambdabot>  "eldrby hat"
06:15:38 <ski> > take 11 (L.nub L.aStorm)
06:15:42 <lambdabot> Terminated
06:15:46 <AStorm> Nope.
06:15:53 <ski> @undefine :)
06:15:53 <lambdabot> Undefined.
06:16:11 * nmessenger is very confused about whether his hat is still here or not
06:16:34 <AStorm> It's not.
06:16:37 <AStorm> > L.aStorm
06:16:38 <lambdabot>  Not in scope: `L.aStorm'
06:17:02 <ski> @quote AStorm
06:17:02 <lambdabot> AStorm hasn't said anything memorable
06:17:25 <AStorm> Indeed. Because anything I say is not memorisable ;-)
06:18:41 <nmessenger> Memorisability is a different thing entirely than memorable-ness
06:19:24 <nmessenger> LB can memorize anything, users decide what's memorable
06:19:30 <AStorm> No, lambdabot can't just @remember me :P
06:19:42 <nmessenger> @remember me :P
06:19:48 <nmessenger> there
06:19:55 <AStorm> @quote me
06:19:56 <lambdabot>  :P
06:20:22 <AStorm> You see? :P
06:23:04 <kowey> is there any way to enable warnings when building with Cabal?
06:23:15 <kowey> equivalent to -Wall
06:25:47 <dcoutts__> kowey: I don't think so, not in general for all compilers though you can add specific ghc options
06:26:40 <kowey> dcoutts__: adding specific ghc options might be good enough; how do i do that?
06:26:46 * kowey has tried configuring with --with-compiler
06:27:08 <kowey> (well, no big deal i guess.  not in too huge a hurry to replace my makefile)
06:27:28 <dcoutts__> kowey: it can certainly be done in the .cabal file with ghc-options:  I'm not so sure about how you'd do it from the command line with a configure option.
06:27:38 <kowey> ah! thanks
06:30:01 <kowey> yep! exactly what i was looking for
06:33:46 <dcoutts__> good good :-)
06:39:39 <cperfumo> I have a program with 2 threads. It uses STM and I compiled and run it and I see it takes advantage of both cores in my computer (the program is simply two threads accessing to a transactional linked list). Now I wan to do the same with a shared integer, it means two threads competing for the access to it and even compiling and running with -N2 rts option i cant see both cores working.
06:40:10 <cperfumo> any idea?
06:45:47 <cperfumo> sorry, I had a problem with my connection
06:45:50 <cperfumo> <cperfumo> I have a program with 2 threads. It uses STM and I compiled and run it and I see it takes advantage of both cores in my computer (the program is simply two threads accessing to a transactional linked list). Now I wan to do the same with a shared integer, it means two threads competing for the access to it and even compiling and running with -N2 rts option i cant see both cores working.
06:45:50 <cperfumo> [15:34] --> thedatabase se ha unido a este canal. (n=thedatab@82.153.209.43)
06:45:50 <cperfumo> [15:34] <cperfumo> any idea?
06:50:17 <ski> (cptchao1 : sorry, haven't used STM ..)
06:50:36 <ski> (s/cptchao1/cperfumo/)
06:50:47 <Lemmih> cperfumo: Is the code online?
06:51:14 <cperfumo> no but I can upload somewhere
06:51:21 <AStorm> @paste
06:51:21 <lambdabot> http://paste.lisp.org/new/haskell
06:51:29 <cperfumo> okok
06:52:32 <lisppaste2> cperfumo pasted "STM" at http://paste.lisp.org/display/33534
06:52:53 <cperfumo> done
06:59:21 <quazimodo> what do you guys think of jhc vs ghv
06:59:23 <quazimodo> ghc
07:01:14 <AStorm> jhc is older and doesn't support fine extensions :P
07:01:45 <cperfumo> Lemmih: have you taken a look?
07:02:44 <AStorm> No GC :P
07:03:03 <AStorm> I wonder how does it frees used memory.
07:03:10 <AStorm> s/does//
07:03:20 <integral> region inference is the idea
07:04:06 <AStorm> If it's perfect, then yes.
07:04:12 <AStorm> If not, memory leaks ahoy!
07:04:14 <AStorm> @yarr
07:04:15 <lambdabot> Har de har har!
07:07:42 <Lemmih> cperfumo: Well, there isn't much room to run the threads in parallel.
07:07:50 <AStorm> "The FFI is almost fully supported except for calling Haskell code from C."
07:07:53 <AStorm> Bummer.
07:08:03 <AStorm> This has to be fixed.
07:08:42 <Syzygy-> What would be involved in getting haskell code to be callable from C?
07:09:51 <Lemmih> Syzygy-: A foreign export.
07:10:04 <ski> cperfumo : what if you put some sleep in 'doNTimes' ?
07:10:18 <AStorm> Supporting older dictionary-style class passing.
07:10:22 <augustss> foreign export of dynamic functions is tricky
07:10:34 <AStorm> (and converting them to new style on the fly)
07:10:41 <cperfumo> Lemmih: but if you see there's a version (main2) in which each thread attemmmpts to modifie a diferent TVar. It should be 100% parallel, right?
07:11:20 <cperfumo> Lemmih: Just to agree in terminology, what do you mean by "not to much room to run the threads in parallel"?
07:12:33 <cperfumo> ski: how could it help?
07:12:58 <ski> cperfumo : i don't know .. just an idea
07:13:21 <AStorm> Well, jhc surely is buggy :P
07:13:38 <AStorm> And ghc just got better in 6.6.
07:14:15 <ski> augustss : RTCG, yes ?
07:14:28 <augustss> ski: yes
07:15:04 <spookylukey> How do I get lambdabot (commandline version) to give me the full output?
07:15:19 <cperfumo> ski: If I understood correctly you are sugesting to put the threads to sleep but i don't want to do that. In fact the idea is to use two cores in order to run it faster. Do I understand correctly your advice or I'm wrong? What  do you think about my thought?
07:15:31 <spookylukey> I get things like "[26 @more lines]"
07:17:22 <ski> cperfumo : i was just thinking that maybe it would work better if you don't do something with the 'TVar' all the time .. i.e. simulate the threads doing local work by sleeping .. but as you say the version with separate 'TVar's shouldn't be hurt by such .. so i dunno .. (said i haven't used STM)
07:17:37 <ski> spookylukey : type '@more'
07:18:18 <spookylukey> ski: just gives me a blank line
07:18:20 <Lemmih> cperfumo: I'd guess that one thread finishes before the other.
07:18:54 <ski> spookylukey : then i don't know
07:19:07 <spookylukey> I've tried prefixing and suffixing '@more' to the commands, doesn't work
07:19:11 <spookylukey> OK cheers
07:19:39 <ski> (without the single quotes, of course)
07:19:42 <metaperl> do {p <- e; es} ? e >>= \bs p -> es -- what are bs and p in this expression and what would they contain?
07:19:57 <spookylukey> yep, tried that
07:20:18 <vincenz> Hello
07:20:21 <vincenz> A belated happy holidays
07:20:26 <metaperl> hey v
07:20:48 <vincenz> @tell apfelmus Nice work on the wikibook
07:20:49 <lambdabot> Consider it noted.
07:20:57 <ski> metaperl : no idea what 'bs' would be
07:21:08 <spookylukey> Aha, just type 'more', not '@more'
07:21:14 <ski> oh
07:21:15 <metaperl> It's in translation rule 4 here ski - http://en.wikibooks.org/wiki/Haskell/YAHT/Monads
07:21:47 <vincenz> metaperl: bs and p could occur inside of es
07:21:52 <vincenz> for instance
07:22:09 <metaperl> but arent they the input args to a function?
07:22:10 <vincenz> do {p <- e; return p } === e >>= \p -> return p
07:22:12 <vincenz> the bs is wrong
07:22:16 <vincenz> it should be one argument
07:22:35 <ski> right
07:22:49 <metaperl> vincenz - but look at this - http://en.wikibooks.org/wiki/Haskell/YAHT/Monads ... he has both unless I am having vision problems
07:22:50 <ski> do {p <- e; es}  =  e >>= \p -> do {es}
07:23:03 <vincenz> what ski said is more accurate
07:23:06 <vincenz> metaperl: where exactly?
07:23:09 <Syzygy-> vincenz: Isn't that just the same as e >>= return ?
07:23:11 <cperfumo> Lemmih: do you mean that one thread finishes before the other starts? So no parallelism at all?
07:23:13 <ski> (there should be a 'do' wrapped around the 'es' in the result, too)
07:23:21 <metaperl> vincenz - Translation rule 4
07:23:36 <metaperl> vincenz - http://en.wikibooks.org/wiki/Haskell/YAHT/Monads#Translation_Rule_4
07:23:38 <lambdabot> http://tinyurl.com/vq236
07:23:46 <vincenz> that's a typo
07:24:01 <vincenz> the bs is clearly bs :P
07:24:08 <metaperl> lol
07:24:16 <metaperl> but there is an issue with having to pattern match on e
07:24:17 <vincenz> Syzygy-: yes but it was to make it clearer :)
07:24:25 <Jaak> hmm, i'm trying to install lambdabot but i'm getting "Could not find module `Lib.Regex'". what am i missing or what might i be doing wrong?
07:24:37 <metaperl> p is not just a simple assignment - it is a pattern match
07:24:42 <vincenz> Syzygy-: besides f >>= return == f
07:26:14 * vincenz sighs
07:27:00 <metaperl> vincenz - look at this also - http://en.wikibooks.org/wiki/Haskell/YAHT/Monads#Definition  ... he does it again
07:27:08 <Lemmih> cperfumo: There is some, just not a lot. Plus, a fair amount of the time is spent duing GC.
07:27:32 <metaperl> YAHT was a great book up until this point. I will definitely email the author about these typos
07:28:03 <ski> metaperl : maybe it's supposed to be tex or something ?
07:28:23 <vincenz> metaperl: I think maybe someone has been messing with the wikibook
07:28:58 <metaperl> oh yes, the PDF looks fine
07:29:20 <ski> not all lambdas are followed by 'bs', though
07:29:51 * metaperl wonders who translated YAHT to a wikibook
07:30:17 <ski> should someone edit the page ?
07:30:28 <vincenz> yes, remove the bs
07:30:32 <metaperl> lol
07:30:42 <metaperl> the darcs repo for YAHT is listed here - http://en.wikibooks.org/wiki/Haskell/YAHT
07:30:43 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
07:30:58 <gour> not many comments on http://kawagner.blogspot.com/2006/12/my-haskell-experience.html
07:30:59 <cperfumo> Lemmih: what is GC?
07:31:00 <lambdabot> Title: Karsten Wagner's Blog: My Haskell experiences
07:31:26 <vincenz> cperfumo: garbage collector
07:31:27 <ski> metaperl : mayhaps http://koweycode.blogspot.com/2006/11/yaht-on-darcshaskellorg.html
07:31:29 <lambdabot> Title: koweycode: yaht on darcs.haskell.org, http://tinyurl.com/y7xcqm
07:31:36 <cperfumo> ah okoko
07:31:46 <vincenz> gour: not many??
07:31:54 <cperfumo> vincenz: thanks
07:32:39 <Lemmih> cperfumo: The garbage collector.
07:33:09 <gour> vincenz: not many convincing ones
07:33:41 * EvilRanter is away: late lunch
07:33:50 <cperfumo> Lemmih: what do you sugges to do in order to proove that CMP-HASKELL works well. I just need to see both cores working hard.What can I modify in my program? (I added some extra calculations within the transactions but it doesn't help)
07:33:58 <lisppaste2> Lemmih annotated #33534 with "re-write" at http://paste.lisp.org/display/33534#1
07:34:00 * gour has to go out...
07:34:15 <vincenz> gour: I get far fewer comments on my blogs
07:34:18 <vincenz> then again I don't write often enough
07:34:42 <gour> vincenz: write about BAD experience ;)
07:35:11 <Syzygy-> gour: You're Karsten Wagner?
07:35:17 * Syzygy- commented there today... :P
07:37:35 <vincenz> gour: You mean, trollbait?
07:47:18 <lisppaste2> Lemmih annotated #33534 with "without the bugs" at http://paste.lisp.org/display/33534#2
07:48:04 <ski> busy loop !
07:49:12 <metaperl> so did anyone make a move to get rid of the bs in YAHT online or should I?
07:49:26 * ski didn't
07:49:53 <Lemmih> cperfumo: Try that.
07:51:26 <metaperl> ok I will email Hal Dame
07:51:43 <vincenz> gour: That was a joke btw :)
07:52:02 <ski> metaperl : there's one in each of 'Do Notation','Tanslation Rule 4','Definition','A Simple State Monad'
07:52:10 <metaperl> ok
07:53:00 <lisppaste2> Lemmih annotated #33534 with "prettier" at http://paste.lisp.org/display/33534#3
07:53:12 <LPhas> i wrote a library for haskell to read mp3's id3 tags, but i don't know how to host it
07:53:16 <LPhas> hints?
07:55:45 <bringert> LPhas: do you have web space?
07:56:13 <LPhas> well, no :P
07:56:52 <Lemmih> LPhas: I can give you an account on my box if you're interested.
07:57:14 <LPhas> Lemmih: oh, it will be very cool
07:59:40 <lisppaste2> Templar2 pasted "string bool IO" at http://paste.lisp.org/display/33535
08:00:56 <ski> Templar2 : 'let' bindings are recursive
08:01:19 <Templar2> i dont understand :(
08:01:22 <ski> hrm
08:01:25 <int-e> ski: not an issue here
08:01:33 <int-e> ski: err
08:01:37 <int-e> ski: ignore me.
08:01:44 <ski> possibly 'read x' should be 'read z' ?
08:02:13 <int-e> I think it should be show x ... and one of the x needs to be renamed.
08:02:33 <ski> Templar2 : perhaps you could tell what you want the code to do ?
08:02:38 <int-e> other notes: look what 'null' does, and remember that String-s are lists. Also have a look at print :)
08:03:07 <Templar2> we want to get the output true as long as we dotn give the program a empty string
08:03:09 <ski> also, "true if the input is not empty. otherwise false" seems to be inconsistent which how 'isempty' is defined
08:03:37 <ski> Templar2 : and what do you want to do when the program is given an empty line ?
08:03:57 <Templar2> that it should print false
08:04:42 <cperfumo> Lemmih: buddy, you deleted STM calls. I'm trying to make it work in an STM environment
08:04:45 <ski> do you want to use the same 'putStr x' code for both cases ?
08:04:48 <Templar2> or if posibel that the progrAM SHOLD STOP
08:05:40 <Templar2> now it dont even prints the boolenas
08:05:48 <Templar2> it just takes input
08:05:49 <ski> stop what ? stop some main loop ? or break out of everything that it is doing and stop ?
08:06:21 <ski> you probably want an 'if'-'then'-'else' somewhere in 'tilltom'
08:06:49 <ski> also, what type should 'read x' be ?  a boolean ?
08:06:50 <Templar2> do i need that if i only want to print it?
08:07:05 <Templar2> i tryed to parse the boolena to a String
08:07:18 <ski> erm
08:07:28 <Templar2> read x :: String
08:07:38 <int-e> > show True
08:07:42 <ski> 'read' *taken* a string and returns the parsed value
08:07:46 <lambdabot>  "True"
08:07:51 <int-e> > read "True" :: Bool
08:07:52 <lambdabot>  True
08:08:02 <ski> *'show'* converts a value into a string
08:08:05 <ski> int-e : ty :)
08:09:02 <ski> Templar2 : are you calling 'tilltom' from somewhere ?
08:09:25 <paolino> hi , is it possible to complete the Reader argument from inside the monad ?
08:09:26 <Templar2>    let x = isempty z
08:09:44 <Templar2> then x should be a boolean
08:09:59 <lisppaste2> metaperl pasted "Could someone provide me with a sample function that would work with mapTreeState" at http://paste.lisp.org/display/33536
08:10:13 <ski> Templar2 : yes
08:10:17 <Templar2> let x = (read x ::String)
08:10:26 <Templar2> then the boolean is a string?
08:10:30 <ski> no
08:11:02 <ski> that defines a *new* 'x' (unrelated to the previous one) which is defined in terms of itself (probably not what you want, here)
08:11:24 <ski> let x2 = show x
08:11:38 <ski> defines 'x2' as the string conversion of the boolean 'x'
08:11:54 <int-e> metaperl: mapTreeState (\_ x -> (x+1, ())) tree 0   perhaps
08:12:01 <metaperl> ok thanks int-e
08:12:22 <int-e> metaperl: if I didn't mess up that counts the number of leaves and relabels the tree to have () as labels
08:13:01 <metaperl> yes it relabels... but that is left as an exercise to me
08:13:24 <paolino> I'm giving an incomplete environment 'e' to "runReader f e" , can I complete 'e' definition inside the f ?
08:13:25 <int-e> @spell leafs
08:13:26 <lambdabot> leafs
08:13:43 <ski> (metaperl : you know that you can define a 'mapTreeM :: Monad m => (a -> m b) -> Tree a -> m (Tree b)' that will look simpler, but can be used to e.g. pass around that state, yes ?)
08:13:44 <lisppaste2> Lemmih annotated #33534 with "Using STM." at http://paste.lisp.org/display/33534#4
08:13:59 <Lemmih> cperfumo: Try that.
08:14:01 <Templar2> ski Im getting "Does not match : [Char]"
08:14:07 <int-e> paolino: using local perhaps. or maybe you really want to have a state monad instead
08:14:10 <metaperl> ski - Daume is building up to the real state monad I suppose
08:14:14 <int-e> @type local
08:14:16 <metaperl> this is a layup of sorts
08:14:16 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:14:25 <ski> metaperl : ah
08:14:30 <nmessenger> Templar2: change 'read' to 'show'
08:14:45 <metaperl> I emailed him about the error and included your section references
08:15:09 <ski> paolino : what do you mean by 'complete' ?
08:15:15 <int-e> > local pred (liftM succ get) 1
08:15:16 <lambdabot>  add an instance declaration for (MonadState s ((->) r))
08:15:24 <int-e> > local pred (liftM succ ask) 1
08:15:26 <lambdabot>  1
08:15:39 <nmessenger> read takes a thing and makes a string, show takes a string and makes a thing
08:15:41 <ski> @spell leaves
08:15:41 <lambdabot> leaves
08:16:06 <ski> > local (const 42) (liftM succ ask) 1
08:16:07 <lambdabot>  43
08:16:12 <nmessenger> (crap! I got that backwards!)
08:16:34 <paolino> data Env = Env{aperture::Int, depth::Int} .I*m passing  Env{aperture=10}
08:16:34 <nmessenger> (and it was so clever!)  T_T
08:17:18 <paolino> I expect f completes with depth
08:17:54 <int-e> paolino: the problem with (or feature of) 'local' is that the modification only spans the execution of the given 'm a' argument; it's lost in subsequent monad actions. if you want to modify the value, a state monad is what you want which provides 'modify' for this purpose
08:17:59 <int-e> @type modify
08:18:01 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
08:18:14 <xerox> ?type local
08:18:15 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:18:16 <xerox> ?type listen
08:18:18 <lambdabot> Not in scope: `listen'
08:18:20 <ski> paolino : 'f' being ?
08:18:36 <Templar2> nmessenger aha, but could you give an example of a "thing"? You mean 1 becomes "1"?
08:18:38 <paolino> the tree builder
08:19:02 <Stinger_> > show 1
08:19:03 <lambdabot>  "1"
08:19:10 <ski> > read "1" :: Int
08:19:11 <lambdabot>  1
08:19:59 <nmessenger> Templar2: did you get it to work?
08:20:28 <Templar2> nmessenger yea, but any ideas how I can make my program to not quit after 1 input?
08:20:38 <paolino> ski, it builds the tree from a list splitting it with the aperture parameter.It ends up with the right depth
08:21:19 <ski> paolino : hmhm
08:21:29 <nmessenger> Templar2: after putStr x, you could call tilltom recursively
08:22:26 * paolino go thinking more
08:22:43 <int-e> > fix read
08:22:45 <lambdabot>  Exception: <<loop>>
08:23:41 <Stinger_> that was not the right icon :(
08:25:02 <cperfumo> Lemmih: there's still only one thread working.
08:25:55 <Templar2> nmessenger ah, now it works prefect. Thanks ;)
08:27:52 <nmessenger> Templar2: glad to help
08:36:15 <Templar2> is this really correct? "read takes a thing and makes a string, show takes a string and makes a thing"
08:36:31 <nmessenger> Templar2: no I got it backwards
08:37:07 <nmessenger> read takes a STRING and makes a THING, show takes a THING and makes a STRING
08:37:39 <nmessenger> sorry for confusion
08:40:05 <Templar2> ah, thx :)
08:40:14 <ph8> can anyone tell me how to combine two maps?
08:40:24 <ph8> can i just use ++ ?
08:40:35 <nmessenger> two Maps?
08:40:44 <Templar2> two lists?
08:40:57 <ph8> Data.Map
08:41:11 <nmessenger> ?hoogle Map k v -> Map k v -> Map k v
08:41:12 <lambdabot> Data.Map.union :: Ord k => Map k a -> Map k a -> Map k a
08:41:12 <lambdabot> Data.Map.(\\) :: Ord k => Map k a -> Map k b -> Map k a
08:41:12 <lambdabot> Data.Map.difference :: Ord k => Map k a -> Map k b -> Map k a
08:41:16 <ski> @type Data.Map.union
08:41:17 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> Data.Map.Map k a -> Data.Map.Map k a
08:41:20 <ph8> cheers :)
08:42:06 * ph8 pats lambdabot
08:44:32 <nmessenger2> @botsnack
08:44:33 <lambdabot> :)
08:44:33 <ski> @botsnack
08:44:33 <lambdabot> :)
08:44:37 <ski> (:
08:44:48 <nmessenger2> 8-)
08:44:50 <int-e> @kcanstob ??
08:44:51 <lambdabot> Unknown command, try @list
08:45:46 <nmessenger2> @botsmack -- she likes it like that
08:45:46 <lambdabot> :)
08:46:12 <ph8> ?hoogle tails
08:46:13 <lambdabot> List.tails :: [a] -> [[a]]
08:46:13 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
08:46:23 <nmessenger2> > tails [1,2,3,4]
08:46:24 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
08:48:13 <nmessenger2> > heads `or` tails
08:48:13 <lambdabot>  Not in scope: `heads'
08:48:53 <AStorm> > head `or` tail
08:48:54 <lambdabot>    The infix expression `head `or` tail' requires `or' to take two argument...
08:49:10 <ski> > inits [0,1,2,3]
08:49:10 <nmessenger2> > head || tail
08:49:11 <lambdabot>  [[],[0],[0,1],[0,1,2],[0,1,2,3]]
08:49:12 <lambdabot>    Expecting a function type, but found `Bool'
08:49:12 <lambdabot>    Expected type: Bool
08:49:12 <lambdabot>  ...
08:49:21 <ski> > init [0,1,2,3]
08:49:22 <lambdabot>  [0,1,2]
08:49:30 <nmessenger2> ew, consing
08:51:05 <shapr> @yow
08:51:05 <lambdabot> Yow!  I want to mail a bronzed artichoke to Nicaragua!
08:51:13 <blsecres> does hugs have an implementation of Control.Monad.Reader?
08:53:09 <ski> hiya shapr
08:53:43 <ski> blsecres : yes
08:53:47 <nmessenger2> http://cvs.haskell.org/Hugs/pages/libraries/mtl/Control-Monad-Reader.html
08:53:50 <lambdabot> http://tinyurl.com/yyqzmx
08:54:59 <nmessenger2> What's missing from Hugs:  http://cvs.haskell.org/Hugs/pages/libstatus.html
08:55:00 <lambdabot> Title: Hugs 98 and the Haskell Hierarchical Libraries
08:56:26 <jethr0> has anyone done a "instance Random ... where"? i can't find documentation which of the functions i got to implement...
08:56:33 <blsecres> read that, receive message "ERROR - Can't find module "Control.Monad.Reader""
08:57:40 <ski> blsecres : perhaps you have an old hugs .. try loading 'MonadReader' instead
08:57:58 <nmessenger2> Minimal complete definition: randomR and random:  http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html#t%3ARandom
08:58:00 <lambdabot> http://tinyurl.com/eu3xo
08:58:41 <blsecres> can't find that either, this is using the May 2006 version
08:59:09 <blsecres> could just have a bad installation
08:59:17 <ski> would guess so
09:00:01 <ski> (i can load 'Control.Monad.Reader' in 2003Nov)
09:05:19 <metaperl> returnState a = \st -> (st, a)   -- so returnState is a function which takes a single datum of type a and returns a _function_ which takes a datum of type st and returns a tuple (st, a)  ???
09:06:05 <integral> curry (flip (,))
09:07:06 <nmessenger> metaperl: basically, it 'transforms' st into its new value in the tuple (in this case unchanged) and also results in a
09:07:31 <metaperl> but my question is: the return value of returnState data_item is a function
09:07:33 <metaperl> right?
09:07:39 <nmessenger> yes
09:07:44 <metaperl> wow. funky
09:08:17 <nmessenger> metaperl: the return value of *all* multi-arity functions are functions when applied to not enough arguments.
09:08:25 <nmessenger> currying
09:08:35 <metaperl> multi-arity == multiple arguments?
09:08:47 <nmessenger> yeah
09:08:50 <nmessenger> ?jargon arity
09:08:51 <lambdabot> No match for "arity".
09:09:00 <nmessenger> ?web1913 arity
09:09:01 <lambdabot> No match for "arity".
09:09:04 <nmessenger> :(
09:09:15 <metaperl> returnState is not multiple arity
09:09:19 <metaperl> it takes a single argument
09:09:36 <metaperl> I guess it be partial though
09:09:42 <nmessenger> returnState a st = (st, a) -- does this make more sense?
09:09:45 <metaperl> partial_func = returnState
09:09:54 <integral> well \x y -> E is just short hand for \x -> \y -> E really
09:10:08 <nmessenger> returnState = \a -> \st -> (st, a) -- this is also equivalent
09:10:11 <metaperl> oh, I think they wrote it that way to emphasize that they intended to call it with one argument
09:10:14 <metaperl> right?
09:10:17 <integral> yes
09:10:22 <metaperl> AHAH!
09:10:28 <metaperl> big lightbulb goes off :)
09:10:35 <vincenz> the ACME type
09:11:28 <ph8> ?pastebin
09:11:28 <lambdabot> Unknown command, try @list
09:11:31 <ph8> @list
09:11:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:11:32 <ph8> ?paste
09:11:32 <lambdabot> http://paste.lisp.org/new/haskell
09:11:59 <lisppaste2> ph8 pasted "NGram Fun!" at http://paste.lisp.org/display/33539
09:12:30 <lisppaste2> ph8 annotated #33539 with "errors" at http://paste.lisp.org/display/33539#1
09:12:49 <ph8> Can anyone help me with that error?
09:13:16 <ph8> I'm trying to construct [String, String] -> String values, given a list of words
09:13:48 * nmessenger is still reading
09:13:51 <ph8> in the ngram style, e.g. the cat sat on the mat = [the, cat] -> sat, [cat sat] -> on, [sat, on] -> the, [on, the] -> mat
09:13:52 <ph8> etc
09:13:57 <integral> @djinn [String, String] -> String
09:13:58 <lambdabot> Cannot parse command
09:14:28 <integral> @djinn [a, a] -> a
09:14:28 <lambdabot> Cannot parse command
09:14:44 <ph8> what's djinn?
09:15:34 <vincenz> @djinn [a] -> a
09:15:35 <lambdabot> -- f cannot be realized.
09:15:38 <ph8> is there something wrong with my 'myComp' definition?
09:16:05 <metaperl> @type id
09:16:06 <lambdabot> forall a. a -> a
09:16:10 <metaperl> myComp = id
09:16:12 <nmessenger> ?web1913 ngram
09:16:13 <lambdabot> No match for "ngram".
09:16:31 <metaperl> > let myComp = id in myComp "love"
09:16:32 <lambdabot>  "love"
09:16:41 <vincenz> ph8: what should be wrong with mycomp?
09:16:50 <ph8> ERROR "Main.lhs":57 - Type error in application
09:16:50 <ph8> *** Expression     : insertWith myComp (take gramSize - fromInt 1 x) (take 1 x) empty
09:16:50 <ph8> *** Term           : myComp
09:16:50 <ph8> *** Type           : ([[Char]] -> [[Char]]) -> [[Char]] -> [[Char]]
09:16:51 <ph8> *** Does not match : [[Char]] -> [[Char]] -> [[Char]]
09:16:52 <ph8> that's the hugs error
09:16:56 <ph8> which might be slightly more informative
09:17:12 <ph8> i can't say i understand it
09:17:15 <jethr0> nmessenger: thx, i was busy. somehow i overread the part that says "minimal complete definition" :)
09:19:07 <ph8> i don't actually want myComp to do anything, as i have no idea how to deal with key collisions
09:19:42 <ph8> aha! my comp takes two values
09:20:06 <shapr> hiya jethr0, long time no see. How's code?
09:20:19 <ph8> hasn't really helped :/
09:20:47 <sjanssen> ngramize should :: [String] -> [Map [String] String]
09:21:14 <sjanssen> even then there's a type error
09:21:24 <ph8> do i want a list of maps?
09:21:26 <jethr0> shapr: i took a longish break from coding for moving and looking for jobs. but now i'm back
09:21:35 <sjanssen> ph8: only you can say :)
09:21:38 <shapr> Did you find a new job and home?
09:21:52 <sjanssen> you've got a couple inconsistencies in the defn.
09:21:53 <ph8> well we're told to use maps because they're uber-fast balanced binary tree storage types
09:21:59 <jethr0> right now i'm trying to make "data Die = One | Two | ... | Six deriving (Enum)" an instance of Random. but somehow i'm at a loss...
09:22:00 <ph8> to store our ngrams
09:22:10 <sjanssen> the takeWhile returns a list
09:22:13 <ph8> presumably a list of maps would invalidate the speed benefits
09:22:24 <shapr> jethr0: You mean an instance of Arbitrary?
09:22:28 <jethr0> shapr: right now i'm living with my parents and still looking for a job. but this way i had some time to unwind after my studies
09:22:39 <sjanssen> and you're attempting to apply length to a Map, but length :: [a] -> Int
09:22:41 <jethr0> shapr: no, at least i'm not using quickcheck right now
09:22:49 <shapr> ah, ok
09:22:59 <ph8> length is a list of strings
09:23:03 <ph8> * applied to
09:23:07 <\z> howdy everyone
09:23:12 <\z> anyone else playing with HXT these days?
09:23:14 <sjanssen> ph8: in your code, it isn't
09:23:16 <ph8> since x <- tails (phrase) ?
09:23:17 <jethr0> has anyone ever implemented "instance Random ..."?
09:23:52 <ph8> sjanssen: I don't understand how x is becoming a map?
09:24:13 <ph8> ?type takewhile
09:24:14 <lambdabot> Not in scope: `takewhile'
09:24:17 <ph8> ?type takeWhile
09:24:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:24:20 <sjanssen> ph8: yes, but then you build a Map (insertWith) out of x and return that in the expression part of the list comprehension
09:24:44 * nmessenger thinks paste.lisp.org should have a 'literate Haskell' colorer
09:25:13 <nmessenger> or s/color/colour/ if you're so inclined ;)
09:25:24 <ph8> argh what a headache
09:25:25 <shapr> jethr0: hugs has Random instances for Int, Char, Bool, etc
09:26:12 <lisppaste2> shapr pasted "random instances" at http://paste.lisp.org/display/33541
09:26:13 <ph8> i need to find some sort of reference about how to use takewhile i think
09:26:17 <jethr0> shapr: hm, there must be a standard way to say "(Bounded a) => randomIO :: a" (haskell pseudocode :)
09:26:29 <jethr0> or maybe "Enum" instead of "Bounded"
09:26:54 * allbery_b is being braindead
09:27:00 <sjanssen> ph8: takeWhile :: (a -> Bool) -> [a] -> [a] -- it takes elements from the list as long as the predicate evaluates to true
09:27:01 <ph8> takeWhile, applied to a predicate p and a list xs, returns the longest prefix (possibly empty) of xs of elements that satisfy p. <--- that's as clear as mud!
09:27:15 <ph8> the predicate is the (a-> Bool) condition?
09:27:23 <sjanssen> yes
09:27:29 <allbery_b> how do I force stuff to be read from a Handle so I can close it, without e.g. printing the result immediately?
09:27:32 <ph8> ah that's a bit easier to understand
09:27:38 <nmessenger> > takeWhile even [2,4,7,6,1,8]
09:27:39 <lambdabot>  [2,4]
09:27:49 <xerox> jethr0: that's a nice idea, I wonder if the type checker would complain for 'a', but at least intuitively you can use minBound/maxBound to get the range.
09:27:52 <ph8> so i should be using >= rather than == in the length comparison?
09:27:53 <allbery_b> (trying to load a file in a single gulp since another process updates it periodically, so don't want it lazily leaving the file locked)
09:27:55 <jethr0> > takeWhile even [2,4,undefined]
09:27:57 <lambdabot>  Undefined
09:28:25 <sjanssen> allberry_b: using length on the getContents'd String is the standard hack
09:28:34 <sjanssen> @hoogle evaluate
09:28:35 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:28:35 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
09:29:19 <sjanssen> @type do x <- getContents; evaluate (length x); return x -- this should be a strict getContents
09:29:20 <lambdabot> Not in scope: `evaluate'
09:29:25 <jethr0> xerox: exactly. but i'd like "Enum" to imply "Random" somehow
09:29:26 <SamB> hmm, does not linking in {-# SOURCE #-}-only imported modules count as a bug?
09:30:17 <sjanssen> ph8: perhaps you should use >=, I don't really know.  But this isn't your primary problem here
09:30:30 <allbery_b> sjanssen: well, yes, but how do I force *that* to be evaluated?  right now it's being lazily ignored since I'm not forcing the result to be used anywhere
09:30:42 <sjanssen> the program is not type correct
09:30:57 <xerox> jethr0 - experiment!
09:31:09 <sjanssen> allberry_b: evaluate is the magic sauce there
09:31:14 <ph8> sjanssen: yup, i'm just trying to find some other way of doing it, so i get the map i want
09:31:20 <ph8> but i can't find anything :/
09:31:44 <jethr0> xerox: i will. right now i'll try first to derive from Random by hand...
09:33:00 <allbery_b> ah, much better
09:33:06 <allbery_b> sjanssen++
09:37:52 * nmessenger is hacking on an ngramize, but he is a newbie, expect to wait quite a few minutes
09:38:11 <vincenz> what is ngramize?
09:39:29 <nmessenger> ngramize 2 [1,2,3,4,5] == Map.fromList [([1,2],3), ([2,3],4), ([3,4],5)] -- I'm guessing
09:40:27 <nmessenger> is that right, ph8?
09:42:04 <ph8> ya
09:42:19 <ph8> erm
09:42:20 <ph8> well
09:42:23 <ph8> what's the 2 arg for ngramize?
09:42:28 <nmessenger> gramSize
09:42:30 <ph8> those are 3 grams
09:42:36 <ph8> but essentially ya
09:42:42 <nmessenger> alrighty
09:43:02 <ph8> but..
09:43:02 <ph8> hmm
09:43:04 <ph8> i could use fromList
09:43:10 <nmessenger> I've never heard of an 'n-gram', so I surmised that
09:43:17 <ph8> cunning
09:43:19 <Stinger_> whats a fn to split say a block of text into lines?
09:43:21 <ph8> Neither had I until this assignment
09:43:25 <ph8> Stinger_: lines
09:43:30 <ph8> lines x
09:43:37 <jethr0> > lines "hello\nworld"
09:43:38 <lambdabot>  ["hello","world"]
09:43:39 <Stinger_> hmm who woulda guessed
09:43:41 <nmessenger> ph8: it's useful only for literals like that example
09:43:49 <Stinger_> is there a more general one for lists?
09:44:57 <dylan> splitBy?
09:45:10 <nmessenger> okay, you might have to wait a couple of hours
09:45:15 * nmessenger is really a newbie
09:45:24 <dylan> err, break?
09:45:38 <sjanssen> Stinger_: not in the current libraries, but there will be in the next release
09:46:05 <sjanssen> and by next release I mean next API changing release (GHC 6.8)
09:46:19 <Stinger_> hmm bummer
09:46:23 <Stinger_> ok thanks
09:46:39 <Stinger_> shouldnt be too hard to implement anyway
09:46:54 <sjanssen> yep
09:47:03 <sjanssen> look at span/break
09:47:44 <ph8> ?hoogle fromList
09:47:45 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
09:47:45 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
09:47:45 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
09:47:52 <ph8> ?hoogle fromListWith
09:47:53 <lambdabot> Data.IntMap.fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
09:47:53 <lambdabot> Data.Map.fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
09:47:53 <lambdabot> Data.IntMap.fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
09:48:37 <yip> is it christmas already?
09:50:17 <ph8> nmessenger: It would be nice if Map.fromList existed :p
09:50:35 <ph8> oh it does according to hoogle
09:50:38 <ph8> but not according to hugs
09:51:09 <lisppaste2> Templar2 pasted "Get Types" at http://paste.lisp.org/display/33543
09:51:11 <nmessenger> :(
09:51:11 <ph8> no, i'm just making things up :p
09:51:17 <ph8> exists
09:51:21 <nmessenger> >:O
09:52:13 <ph8> > ngramize :: [String] -> [[String]]
09:52:13 <ph8> > ngramize (a:x) = takeWhile (\x -> length x >= gramSize) [ [[take (gramSize-1) x], take 1 x] | x <- tails (x) ]
09:52:14 <lambdabot>  Not in scope: `ngramize'
09:52:14 <lambdabot>  Parse error
09:52:16 <ph8> that's a mess, isn't it
09:52:29 <ph8> the return value of ngramize is fromList'ed
09:52:40 <ph8> so i haven't got to worry about all this mapping when forming my ngrams
09:52:42 <ski> @type let ngramize (a:x) = takeWhile (\x -> length x >= gramSize) [ [[take (gramSize-1) x], take 1 x] | x <- tails (x) ] in ngramize
09:52:43 <lambdabot> Not in scope: `gramSize'
09:52:43 <lambdabot>  
09:52:43 <lambdabot> <interactive>:1:70: Not in scope: `gramSize'
09:52:52 <ph8> but that means i need key, value pairs in a list
09:52:56 <ski> @type let gramSize = 3; ngramize (a:x) = takeWhile (\x -> length x >= gramSize) [ [[take (gramSize-1) x], take 1 x] | x <- tails (x) ] in ngramize
09:52:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:52:57 <lambdabot>    Expected type: [[a]]
09:53:03 <ph8> [['cat', 'sat'], 'on]
09:53:04 <ph8> for example
09:53:17 <ph8> with an apostrophe :p
09:53:29 <ski> @type let gramSize = 3; ngramize (a:x) = takeWhile (\x -> length x >= gramSize) [ ([take (gramSize-1) x], take 1 x) | x <- tails (x) ] in ngramize
09:53:30 <lambdabot>   Couldn't match `[a]' against `(a1, b)'
09:53:30 <lambdabot>    Expected type: [a]
09:54:37 <ski> @type let gramSize = 3; ngramize (a:x) = takeWhile (\x -> length x >= gramSize) [ take (gramSize-1) x ++ [take 1 x] | x <- tails x ] in ngramize
09:54:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:54:38 <lambdabot>    Expected type: [a]
09:54:58 <ph8> wtf
09:55:23 <ph8> > ngramize phrase = takeWhile (\x -> length x >= gramSize) [ ([take (gramSize-1) x], take 1 x) | x <- tails (phrase) ]
09:55:23 <lambdabot>  Parse error
09:55:32 <ph8> @type let gramSize=3; ngramize phrase = takeWhile (\x -> length x >= gramSize) [ ([take (gramSize-1) x], take 1 x) | x <- tails (phrase) ]
09:55:34 <lambdabot> not an expression: `let gramSize=3; ngramize phrase = takeWhile (\x -> length x >= gramSize) [ ([take (gramSize-1) x], take 1 x) | x <- tails (phrase) ]'
09:55:44 <ph8> @type let gramSize=3; ngramize phrase = takeWhile (\x -> length x >= gramSize) [ ([take (gramSize-1) x], take 1 x) | x <- tails (phrase) ] in ngramize
09:55:45 <lambdabot>   Couldn't match `[a]' against `(a1, b)'
09:55:45 <lambdabot>    Expected type: [a]
09:56:00 <ph8> what [a]??
09:56:02 <ski> (Templar2 : s/August/Augusti/ s/October/Oktober/ ?)
09:56:14 * ski tries reading 'ngramize'
09:57:25 <ski> @type let gramSize = 3; ngramize (a:xs) = takeWhile (\x -> length x >= gramSize) [ take (gramSize-1) x ++ take 1 x | x <- tails xs ] in ngramize
09:57:26 <lambdabot> forall a. [a] -> [[a]]
09:57:36 <ski> you're missing a base case, and 'a' is not used
09:58:52 <Templar2> ski what do you mean?
09:59:18 <ski> Templar2 : you can't have multiple different data constructors with same names in same scope .. (also, there's no subtyping)
09:59:42 <ski> Templar2 : what should happen when 'ngramize' is passed an empty list ?
09:59:45 <ski> er
09:59:52 <ph8> ?type Data.Map.fromList
09:59:53 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
09:59:54 <ski> ph8 : what should happen when 'ngramize' is passed an empty list ?
10:00:04 <ph8> i'm feeding that my [[String]]
10:00:05 <ph8> and it's borking
10:00:08 <lisppaste2> nmessenger annotated #33539 with "ngramize in progress (not finished)" at http://paste.lisp.org/display/33539#2
10:01:00 <Templar2> ski ok, ty
10:01:00 <ph8> ski: Erm.. nothing i suppose
10:01:09 <nmessenger> that's Prelude.map, not Data.Map.map, btw
10:01:30 <ph8> incoming pastage:
10:01:30 <ph8> ERROR "Main.lhs":48 - Type error in application
10:01:30 <ph8> *** Expression     : fromList (ngramize (words a))
10:01:30 <ph8> *** Term           : ngramize (words a)
10:01:31 <ph8> *** Type           : [[String]]
10:01:32 <ph8> *** Does not match : [(a,b)]
10:01:34 <ph8> ?
10:01:41 <ski> ph8 : something should be returned, in that case (or an error raised, or going into an infinite loop)
10:01:42 <ph8> hmm, i didn't type the question mark - came as part of the paste, but it's still good :)
10:01:52 <ph8> ski: just added it, cheers - it now just returns the empty list
10:02:03 <ph8> cheers nmessenger :)
10:02:13 <ski> actually
10:02:16 <Templar2> can anyone explain what Eq is?
10:02:19 <ph8> i'm bound to use Data.Map with the assignment :(
10:02:33 <ph8> Templar2: It means == can be used on it, i believe
10:02:40 <ph8> but there's probably more to it
10:02:46 <ski> 'ngramize' is not recursive, so possibly you want to skip the base case and change the '(a:xs)' pattern into just 'xs'
10:02:51 <Templar2> ph8 ok, ty
10:03:10 * nmessenger realizes that he just needed an (Ord a) constraint, and it's done
10:03:11 <waern> I'm writing a Cabal hook. Is there an easy way to get full paths, without the $prefix from Cabal?
10:03:16 <ski> types in the 'Eq' type class provide '(==)' and '(/=)'
10:03:45 <Templar2> anyone who can explain what Ord is?
10:04:15 <nmessenger> ordered, as in, some are greater than and less than others
10:04:36 <nmessenger> ?instances Ord
10:04:37 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
10:04:42 <ph8> ski: Ok, done that - looks quite similar to something i saw last time i had this conversation, i feel making it as a list and then converting it is as good a way as any to go - it would have been nice if i could have built a map as i went but :/
10:04:51 <ph8> Then there's the error i pasted above though - which is odd no?
10:05:34 <ski> types in the 'Ord' type class provide '(<)','(<=)','(>)','(>=)','compare','max','min' .. and they are also required to be instance of 'Eq'
10:05:42 <lisppaste2> nmessenger annotated #33539 with "done" at http://paste.lisp.org/display/33539#3
10:05:56 <ski> Templar2 : try ':i Ord' in hugs or ghci
10:06:02 <Azmo> anyone here tried using X11 on windows? it seems to work with C, but when using the ffi, GHC 6.4.1/6.4.2 gives a program that crashes, and GHC 6.6 gives a program that goes into an infinite loop. it does not matter if the X server is running or not, and i explicitly link with the same lib in all cases :/.
10:06:40 <kowey> ?seen metaperl
10:06:40 <lambdabot> metaperl is in #darcs and #haskell. I last heard metaperl speak 50m 8s ago.
10:06:45 <AStorm> There are already nice X bindings.
10:07:06 <AStorm> Show us the program
10:07:08 <AStorm> @paste
10:07:09 <lambdabot> http://paste.lisp.org/new/haskell
10:07:13 <kowey> metaperl: yep...that was me that did the (horrible) latex-to-wiki translation for YAHT
10:07:29 <nmessenger> ph8: does that work for you?
10:07:35 <Azmo> the X windows binding is not installed together with the windows installation of GHC, and i did not succeed compiling it myself.
10:08:02 <AStorm> You need Cygwin for that.
10:08:21 <AStorm> Anyway, why not use GTK?
10:08:29 <AStorm> It is available for Windows...
10:08:55 <ph8> nmessenger: It looks sexy, but i have to use Data.Map unfortunately :/
10:09:12 <ph8> and i feel like we're nearly there with it, apart from this string error
10:09:31 <nmessenger> ph8: it *is* Data.Map!
10:09:35 <Templar2> thanks for today all, cu tomorow =)
10:09:49 <ph8> eep.
10:09:52 <ph8> i'm a spaz
10:09:53 <ski> Templar2 : yw
10:10:05 <ph8> mind if i step through it with you in PM nmessenger?
10:10:16 <nmessenger> with pleasure
10:10:21 <ph8> ty :o)
10:11:38 <nmessenger> Do I need special rights to /msg?  I'm an IRC noob
10:11:53 <dfranke> nmessenger, on Freenode I think so.
10:11:53 <dylan> you need to message nickserv and identify yourself
10:12:11 <Azmo> AStorm: GTK works, but i would like to use the X11 directly, since i do not really like the GTK interface.
10:12:16 <nmessenger> nvm, he started a convo.
10:12:31 <AStorm> Huh? Somebody likes X11 interface more? WTF? :P
10:12:38 <dylan> nmessenger: he won't be able to see your responses unless you identify
10:12:43 <AStorm> There's also wxHaskell.
10:12:47 <nmessenger> how?
10:12:56 <dylan> nmessenger: talk to nickserv
10:13:05 <nmessenger> say what to nickserv?
10:13:06 <Azmo> AStorm: that's even worse :]
10:13:07 <glguy> nmessenger: /msg nickserv help register
10:13:22 <AStorm> Azmo, so fix it :>
10:13:27 <dfranke> nmessenger, /msg nickserv register pass; /msg nickserv identify pass
10:13:33 <AStorm> X isn't portable to Windows.
10:13:45 <AStorm> I mean it's not there by default.
10:13:45 <glguy> X runs on windows just fine
10:14:15 <AStorm> Also, building a Windows binary using X and not Cygwin is quite hard.
10:14:24 <nmessenger> ph8: gimme a minute
10:14:27 <Excedrin> is gtk on windows by default?
10:14:27 <ph8> yeh i had to ident with nickserv too nmessenger :p
10:14:31 <ph8> lol nps
10:14:33 <dfranke> nope
10:14:53 <AStorm> Excedrin, no, but is easily installabla.
10:15:07 <AStorm> Unlike an X server, which you have to run in background.
10:15:15 <Azmo> AStorm: "using cygwin"?   i do have cygwin, but i only needed the X11 lib, nothing else.
10:16:00 <Excedrin> if you only need an x server for windows, use xming http://freedesktop.org/wiki/Xming
10:16:02 <lambdabot> Title: freedesktop.org - Xming
10:16:10 <lisppaste2> Azmo pasted "using X11 on windows" at http://paste.lisp.org/display/33544
10:16:17 <AStorm> Excedrin, but X libraries...
10:16:57 <Excedrin> I'd use wxwindows if I wanted to write GUI apps for Windows
10:17:24 <AStorm> You mean wxHaskell and wxWidgets :P
10:17:28 <Azmo> it does not work regardless of if there is an X server or not. i do not get a result of that it fails to contact the server. but i do get that result if trying to do the same in C.
10:17:37 <kowey> metaperl: if it's not too late, i would advice not mailing hal about this
10:18:12 <paolino> can someone help me remove the inefficencies here http://rafb.net/p/AicxOw19.nln.html  ?
10:18:14 <lambdabot> Title: Nopaste - No description
10:18:27 <Excedrin> yea wxwidgets
10:18:57 <kowey> metaperl: the \bs is one of hal's tex commands (\ensuremath{\backslash}); and it was my crappy script that missed it - would definitely like to avoid punishing him for doing the good deed of donating yaht to the community
10:20:18 <ph8> > tails [1,2,3,4,5]
10:20:19 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
10:22:28 <Azmo> i have also tried using the ffi to call X11 directly from haskell, without using a C file, but it gives the same result.
10:26:00 <paolino> specially I would like to avoid the length evaluation
10:26:59 <glguy> paolino: what do you want your code to do?
10:27:18 <glguy> divide a list of N thing into M chunks?
10:27:56 <LoganCapaldo> What is a haskell mailing list where the level of discourse is similar to that of this channel?
10:28:14 <ph8> > init [1,2,3]
10:28:15 <lambdabot>  [1,2]
10:28:25 <ph8> > last [1,2,3]
10:28:26 <lambdabot>  3
10:28:34 <LoganCapaldo> IOW I don't want to be reading about the deep bowels of GHC, but otoh I don't want to read just newbie Q's
10:28:58 <lisppaste2> Azmo pasted "X11 without using C" at http://paste.lisp.org/display/33547
10:29:08 <glguy> > let splitN n = unfoldr(liftM2(>>)(guard.not.null)(return.splitAt n)) in splitN 3 [1..10]
10:29:10 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
10:29:30 <glguy> > let splitN n = unfoldr(liftM2(>>)(guard.not.null)(return.splitAt n)) in transpose $ splitN 3 [1..10]
10:29:31 <lambdabot>  [[1,4,7,10],[2,5,8],[3,6,9]]
10:31:07 <paolino> thanks glguy, I have my evening puzzle :D
10:31:15 <lisppaste2> glguy pasted "paolino's split functions rewritten" at http://paste.lisp.org/display/33549
10:33:46 <yip> anyone know if a new version of gtk2hs is supposed to be out soon?
10:33:54 <yip> i heard that it's supposed to be released before chrstmas
10:33:56 <dcoutts__> yip: yep, out soon
10:34:09 <yip> cool :D
10:34:11 <glguy> is chrstmas something that happens after the 25th?
10:34:16 <dcoutts__> yip: I managed to get this out before xmas: http://haskell.org/gtk2hs/gtk2hs-0.9.10.3.tar.gz
10:34:27 <Stinger_> did they specify which christmas? :)
10:34:29 * yip downloads
10:34:33 <dcoutts__> it's a pre-release / release candidate
10:34:56 <dcoutts__> http://haskell.org/gtk2hs/archives/2006/12/24/new-gtk2hs-pre-release-in-time-for-xmas/
10:34:58 <lambdabot> Title: Gtk2Hs » Blog Archive » New Gtk2Hs pre-release in time for xmas, http://tinyurl.com/ykk7z2
10:35:30 <dcoutts__> in which I confesed to not getting the release out in time, but we're near
10:35:40 <glguy> I can't wait for the keyboard of the future, where when I press ESC, the names of my active Irssi channels show up on keys 1-9
10:36:03 <nominolo> isn't that called "das keyboard"?
10:36:10 <nominolo> from some guys in russia?
10:36:16 <resiak> No, it's called the Optimus, IIRC
10:36:17 <glguy> das keyboard has absolutely no key labels
10:36:21 <resiak> from Art Lebedev
10:36:30 <glguy> and the optimus is vaporware ;)
10:36:55 <nominolo> yes, no labels but LEDs instead!
10:37:30 <glguy> also, I need this to happen on my laptop ;)
10:37:58 <nominolo> nah, that's just useless energy consumption ..
10:38:04 <LoganCapaldo> glguy: Attach a projector to the lid, paint your keys white and use it in the dark
10:38:27 <glguy> well..., the keyboard of the future that I so eagerly await does all this without significant power consumption!
10:38:59 <nominolo> oh, well, then let's wait for digital paper first
10:39:05 <glguy> there are projection based keyboards though
10:39:09 <glguy> they are used for PDAs
10:39:23 <glguy> I think that it would hurt your fingers to "type" on a table though
10:39:31 <earthy> it does
10:39:34 <yip> i hear that they are actually quite comfy
10:39:35 <nominolo> yeah, i seem to remember seeing photos
10:39:52 <earthy> there's some problems with feedback, so you get slowed down quite a bit
10:40:21 * LoganCapaldo just got his hands on a surplus sun keyboard
10:40:33 <LoganCapaldo> Everyone needs a diamond key!
10:40:58 <earthy> some of those come with USB. those are nice. ;)
10:41:01 * nominolo feels comfy with his apple-key
10:41:46 <glguy> I prefer my Command key
10:42:03 <LoganCapaldo> Yeah the only reason I'm not using it is a I need some kind of USB adapter for it
10:42:10 <glguy> paolino: did you see the lisp-paste?
10:42:19 <ph8> karma+ nmessenger
10:42:20 <ph8> karma+ nmessenger
10:42:22 <ph8> @karma+ nmessenger
10:42:22 <lambdabot> nmessenger's karma raised to 1.
10:42:22 <ph8> @karma+ nmessenger
10:42:22 <lambdabot> nmessenger's karma raised to 2.
10:42:26 <ph8> damn straight1
10:42:47 <koala_man> I have some parsec code that works with do {..} that I can't figure out how to write without the {}: http://rafb.net/p/ic1JDM99.html
10:42:48 <lambdabot> Title: Nopaste - No description
10:43:42 <nominolo> koala_man: how about some ( )
10:43:43 <earthy> the <|> is at the wrong indentation
10:43:56 <earthy> as is the 3rd do
10:44:24 <koala_man> nominolo: why don't I need () in the {} version?
10:44:30 <earthy> koala_man: if you indent the <|> a bit deeper and then indent the do below it also at that depth you'll be fine
10:44:48 <nominolo> because the { } server the same purpose (in this case)
10:45:00 <earthy> the do {} <|> do {}  is 1 expression in the version with {}
10:45:09 <glguy> does he need try in this case?
10:45:11 <earthy> whereas the do ... <|> do ... is 3 expressions in the version without
10:45:18 <glguy> since neither string starts with the same letter?
10:45:26 <koala_man> glguy: not in this case maybe, it's sort of transliterated
10:45:33 <earthy> because there are implicit ;'s inserted by the layout processor
10:45:40 <Azmo> another problem i have is that if i cantually use the X11 binding that exists, it does not work well at all with concurrency. i have tried the runInBoundThread and forkOS, but it still blocks, why is that?
10:45:43 <ihope> About how big is let a 0 n=n^n+1;a m 0=a(m-1)1;a m n=a(m-1)$a m(n-1)in a 9 9?
10:45:48 <kowey> many somebody could paste what the {}-less version looks like when translated back
10:46:01 <ihope> Smaller than let a 0 n=n^n+9;a m 0=a(m-1)1;a m n=a(m-1)$a m(n-1)in a 9 9, I take it.
10:48:34 <koala_man> earthy: it seems to work when I indent 25 and down one step to the left. but to me it looks like the layout indicates that it's "many <|> do". is that just me?
10:48:39 <koala_man> err, to the right
10:48:51 <Hector>  WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.n
10:48:57 <Hector>  WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.net WELCOME to irc.knaqulive.n
10:49:00 <lisppaste2> earthy pasted "layout parsing problem." at http://paste.lisp.org/display/33550
10:49:22 --- mode: ChanServ set +o dmhouse
10:49:28 <dmhouse> Someone ping me if he does that again.
10:49:33 <earthy> koala_man: that's probably right, yes
10:49:44 <monochrom> someone I wonder whether that is advertisement or anti-advertisement :)
10:50:11 <yip> Azmo: please tell me more
10:50:33 <vegai> monochrom: it might be an invitation to ddos the server
10:52:51 <koala_man> earthy: in what you pasted, what are the two parameters to <|>?
10:54:01 <vincenz> dmhouse: ooh sexy @
10:54:12 <monochrom> proxy error and 502. :D
10:54:39 <dmhouse> vincenz: I rush to the channel, thinking we're getting another spam attack, and all it is is you calling me sexy :P
10:54:46 <vincenz> :D
10:54:57 <monochrom> "document contains no data" <+> "Error reading from remote server"   :D
10:55:38 <earthy> koala_man: that's the issue: there are none. :)
10:55:53 <Azmo> yip: the paste webpage does not work :/
10:56:11 <yip> Azmo: maybe http://rafb.net/paste
10:56:12 <koala_man> earthy: but it's interpretted fine, it just gives the wrong answer
10:56:25 <monochrom> It's intermittent.  Wait a few minutes.
10:56:27 <mbishop> help, I have an emergency, dmhouse's sexiness has made me catch fire!
10:56:43 * monochrom suppresses mbishop.
10:56:55 <koala_man> earthy: namely "L.." or "MAO!", but not "LMAO"
10:56:58 <mgsloan> hmm, what is wrong with cyclic module dependancy?
10:57:08 <dmhouse> mgsloan: nothing, GHC is crap in this respect.
10:57:13 <monochrom> hee hee
10:57:16 <mgsloan> oh
10:57:23 <vincenz> dmhouse: it's not exactly trivial
10:57:32 <monochrom> The same as "what's wrong with debugging" :D
10:57:36 <dmhouse> True.
10:57:36 <mgsloan> not trivial, but not impossible ;)
10:57:41 <dmhouse> I admit I couldn't write the code :)
10:57:44 <vincenz> Not impossible, but definitely rather hard
10:58:01 <vincenz> Basically all you need to do is group your graph of dependencies in groups of tight cycles
10:58:05 <Azmo> http://rafb.net/p/2ROlsQ99.html
10:58:06 <lambdabot> Title: Nopaste - non-working concurrency using standard X11 binding
10:58:07 <vincenz> and then compile those cycles of modules at once as one big module
10:58:17 <mgsloan> yeah.  You figure though, ghc handles complex type constraints, should be able to muster the cleverness to handle cyclic deps
10:58:21 <monochrom> I use floating point internally. All large numbers become Impossible.
10:58:42 <mgsloan> yeah.  once you import anything in the cycle, everything else comes with it, sorta
10:59:11 <Azmo> yip: i have tried various combinations of the program, but it does not seem to work in any way
10:59:38 <monochrom> yay, paste.lisp.org is back
11:00:47 <monochrom> the layout question may come down to the precedence question >>= vs <|> who is tighter?
11:02:33 <monochrom> one possible explanation is: string "L" >> do {...} <|> do {...}.  Recall that there is layout, and then there is do-desugaring.
11:09:13 <ph8> *** Type           : Map [[Char]] [Char]
11:09:13 <ph8> *** Does not match : Map [String] [String]
11:09:17 <ph8> that's rubbish, right?
11:09:21 <ph8> oh wait n/m
11:09:36 <ph8> oh no wait
11:09:38 <ph8> i was right
11:09:42 <ph8> isn't [String] == [[Char]]
11:09:46 <vincenz> yep
11:10:56 <mgsloan> yeah, type synonyms really seem to gunk up errors
11:10:58 <Botje> ph8: yes, but [String] Doesn't match [Char]
11:11:16 <ph8> right botje
11:12:43 <mgsloan> I think it should either substitute synonyms for their definitions, or aggressively discover and use synonyms in errors
11:13:52 <ph8> @karma+ nmessenger; // All his stuff actually works too!
11:13:52 <lambdabot> nmessenger;'s karma raised to 1.
11:13:54 <ph8> :/
11:13:57 <ph8> @karma+ nmessenger // All his stuff actually works too!
11:13:57 <lambdabot> nmessenger's karma raised to 3.
11:14:01 <ph8> that's the shiznit
11:14:22 <mgsloan> nmessenger++ //when did this stop working
11:14:32 <ph8> @karma nmessenger
11:14:32 <lambdabot> nmessenger has a karma of 4
11:14:34 <glguy> that command just doesn't print the change
11:14:37 <mgsloan> :O
11:14:37 <ph8> ah, it doesn't apparently :p
11:14:43 <ph8> good call
11:14:44 <vincenz> ++ is side-effect only
11:14:44 <glguy> and I don't think you can have trailing comments
11:14:53 <vincenz> yes you can
11:15:01 <mgsloan> apparently you can, because it worked...
11:15:48 <mgsloan> and somehow I doubt it picks up on the C style comment :P
11:16:02 <glguy> I was just trying to explain something I *thought* that I saw
11:16:12 <glguy> but my original comment ended up being correct
11:16:44 <vincenz> mgsloan: just a space will do
11:18:28 <mgsloan> right
11:27:12 <mgsloan> hmm.  I think I've just figured out how to do non-imperative todo lists - dependency graph :)  I'm going to use line weight to indicate dependency importance
11:27:58 <vincenz> nono-imperative?
11:28:10 <vincenz> non-imperative? even
11:28:25 <psnl> non-ordered?
11:28:27 <mgsloan> yeah.  not like a list of tasks to be followed linearly
11:28:28 <mgsloan> yeah
11:28:38 <mgsloan> well, i suppose some todo lists aren't really ordered
11:28:50 <psnl> mine isn't
11:28:56 <mgsloan> yet any complex macro task will have complex micro deps
11:29:02 <vincenz> Basically a dependency graph
11:29:19 <vincenz> I fail to see how line weights enter it, there are known algorithms to linearize dependency graphs
11:29:25 <vincenz> (as long as there are no cycles)
11:30:07 <monochrom> partial orders ftw
11:30:20 <mgsloan> basically it's to represent situations such as "a would be better off with b already done, but a could be done without b done"
11:30:54 <mgsloan> and represent such situations in relative extremity - "REALLY NEEDS TO BE DONE FIRST" etc
11:32:32 <vincenz> oh
11:32:42 <vincenz> so you have weights on the nodes, not the edges
11:33:06 <mgsloan> anyway, i thought it was interesting.  Programmers tend to have the most complicated macro tasks
11:33:17 <mgsloan> well, you could calculate node weight
11:33:38 <mgsloan> (though it's fairly visually apparent what will enable more of the nodes to be accessible)
11:34:04 <vincenz> The reason I mention node-weight is cause a) you might still have absolute lines (real dependencies) b) it leads to less weights than a weight between each two couples of nodes
11:34:10 <monochrom> interesting
11:34:17 <mgsloan> it is indeed the edges - the weight of a particular dependency - the amount it matters
11:35:09 <vincenz> How do you encode absolute dependencies then? with infinity?
11:35:17 <vincenz> like : A -must- be done before B
11:35:38 <mgsloan> the problem is, the amount a particular node matters for dependent nodes varies, so each relationship requires a weight
11:35:45 <mgsloan> nah, this isn't a formal system
11:35:53 <mgsloan> just a really fatty line :)
11:37:25 <mgsloan> or, you could have an equation to convert from actual weight to line width, but seriously, dependancy isn't quantifiable anyway
11:38:00 <mgsloan> it's qualitative, so varying line widths is appropriate
11:40:49 <SamB> vincenz: what is an example of an absolute dependency?
11:40:51 <vincenz> What sort of macrotasks do you envision?
11:41:03 <mgsloan> entire programming projects
11:41:06 <vincenz> SamB: Module A is being used by Module B, I need to code up the interface of Module A before I can do either module A or module B
11:41:11 <mgsloan> that's what I'm using it for now, at the moment
11:41:43 <SamB> vincenz: hmm. well, you could write the code for the parts of module A that you use in module B in the middle of module B to start with!
11:41:56 <SamB> not so absolute, is it?
11:42:00 <mgsloan> can probably be used in every day life todo lists though :)
11:42:24 <daniel_larsson> "learn to run" and "learn to walk" perhaps? :)
11:42:39 <mgsloan> yeah, most deps aren't really absolute.  It's more like the ideal traversal would complete every node's deps before hitting it
11:42:43 <mgsloan> hah
11:42:54 <SamB> daniel_larsson: I don't follow
11:43:03 <mgsloan> dunno, I think my brother learned to run first
11:43:09 <mgsloan> would take little sprints and fall over
11:43:10 <daniel_larsson> Hard to learn to run before you can walk, no?
11:43:23 <SamB> I haven't tried it ;-)
11:44:58 --- mode: dmhouse set -o dmhouse
11:49:56 <monochrom> Hard to learn to run before you can walk, but code monkeys think they can.
11:50:28 <monochrom> Cf. "why are you teaching me pascal/scheme?  they use c++ at work."
11:50:29 <Botje> code monkey get up get coffee
11:51:07 <mahogny_> according to my parents I learned to run before I learned to walk :/
11:52:20 <monochrom> It's like a 1-yo baby saying to you: why are you teaching me walking?  people drive to work, you should teach me that now.
11:52:32 <daniel_larsson> "Why are you teaching me the hammer? They use screwdrivers at work"...
11:59:06 <mgsloan> heh, cyclic dependencies signal a real problem in such a todo list
11:59:15 <vincenz> :D
11:59:58 <mgsloan> gotta compromise somewhere and break the chain
12:00:02 <ph8> this is a little snippet that makes a Map [a] a
12:00:08 <dmhouse> mgsloan: you don't have to.
12:00:09 <araujo> hello!
12:00:09 <ph8> i'm trying to alter it to make a Map [a] [a]
12:00:10 <ph8> >          mapify = fromList . map (\x -> (init x, last x))
12:00:11 <lambdabot>  Parse error
12:00:17 <dmhouse> mgsloan: create one of those site files or whatever they're called.
12:00:18 <ph8> but map (last x) isn't the way to do it?
12:00:46 <dmhouse> ph8: what do you want the values of the map to be?
12:00:59 <dmhouse> fromList expects a list of (key, value) pairs.
12:01:21 <ph8> ja
12:01:34 <ph8> so it gets a map of [1,2,3], 1
12:01:40 <mgsloan> dmhouse - are you talking about haskell, because I'm talking about an intelligent way of doing to-do lists :)
12:01:44 <ph8> but i want that to be [1,2,3], [1]
12:02:00 <ph8> so i should be able to say map (last x) right?
12:02:01 <dmhouse> mgsloan: oh, someone asked earlier about cyclic module dependencies, sorry.
12:02:11 <mgsloan> yeah, that was me too actually
12:02:12 <Saizan> mapify = fromList . map (\x -> (init x, [last x]))
12:02:19 <mgsloan> been thinking about dep trees in general :)
12:02:28 <mgsloan> graphs, rather
12:02:42 <ph8> Saizan: ofc, i swear i'd tried that already
12:02:47 <ph8> works beautifully ta
12:06:30 <ph8> i'm using showTree to display my Data.Map - all the newlines echo as \n (using ghc) though - is there some special thing i should be doing to them?
12:07:08 <SamB> ph8: putStr (showTree blah)
12:07:29 <ph8> ty!
12:08:04 <SamB> you are welcome
12:08:07 <psnl> ph8: word of advice, paul cares about the writeup bit of the assignment
12:08:38 <iulus> > fromList . map (\x -> (init x, [last x])) $ [1,2,3,4]
12:08:39 <lambdabot>  Not in scope: `fromList'
12:08:47 <glguy> M.fromList maybe?
12:08:51 <iulus> @hoogle fromList
12:08:52 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
12:08:52 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
12:08:52 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
12:09:08 <ph8> @hoogle writeFile
12:09:09 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
12:09:09 <lambdabot> System.Win32.File.c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
12:09:09 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
12:09:18 <glguy> > M.fromList [(init x, [last x]) | x <- [1..4]]
12:09:18 <lambdabot>  add an instance declaration for (Num [a])
12:09:19 <lambdabot>   In an arithmetic sequence: [1...
12:09:37 <Saizan> x should be a list
12:09:40 <glguy> > M.fromList [(init x, [last x]) | x <- tails [1..4]]
12:09:41 <lambdabot>  Exception: Prelude.init: empty list
12:09:44 <psnl> @where hoogle
12:09:44 <lambdabot> http://www.haskell.org/hoogle
12:09:50 <glguy> > M.fromList [(init x, [last x]) | x <- init $ tails [1..4]]
12:09:52 <lambdabot>  {[]:=[4],[1,2,3]:=[4],[2,3]:=[4],[3]:=[4]}
12:10:14 <SamB> "I am teaching you Pascal because that little colon before the eqauls sign will remind you that you aren't dealing with equations!"
12:12:32 <Saizan> do people really ever think of x = y+1 as an equation when they learn to program?
12:12:47 <AStorm> Unlikely.
12:12:53 <glguy> yes they do, actually
12:12:57 <SamB> I was turoring a student who was confused that you could do "x = 1; x = 2;" in C++
12:13:05 <glguy> it's fun to watch new learners of Java
12:13:11 <glguy> as a first language
12:13:13 <AStorm> Actually, he started to think :>
12:13:23 <SamB> er.
12:13:24 <SamB> tutoring
12:13:29 <nmessenger> When learning to program, I've seen many confuse an assignment statement for a plain equation.
12:13:43 <vincenz> and then they are untaught that and when they get back to haskell, they wonder why
12:13:46 <vincenz> "x = x + 1" hangs
12:13:50 <nmessenger> They're usually baffled by x = x + 1
12:14:01 <nmessenger> :)
12:14:18 <nmessenger> ph8: you still here?
12:14:25 <SamB> I don't know if I should have agreed with him that it did not make sense or not
12:14:28 <SamB> (I did ;-)
12:14:37 <glguy> nmessenger: what code did you give him that he was so excited about?
12:14:46 <geckosenator> x=x+1 is like saying 0=1
12:14:55 <nmessenger> glguy: http://paste.lisp.org/display/33539#3
12:15:02 <Dr_Pi> My second programming language was Turing, and it used := for assignments.
12:15:13 <geckosenator> turing?
12:15:17 <mgsloan> x=x+1 is like saying _|_ ;)
12:15:20 <vincenz> My first programming language was Turing Complete
12:15:31 <SamB> mine too
12:15:35 <AStorm> x <= x + 1
12:15:36 <Botje> vincenz: I only got Turing basic :[
12:15:37 <SamB> (it was Basic)
12:15:39 <AStorm> That'd be more correct
12:15:43 <AStorm> or x := x + 1
12:15:50 <AStorm> Stupid C messed things up.
12:15:52 <nmessenger> glguy: he was mostly excited that he understood it when I explained it
12:15:53 <geckosenator> well you can't actually implement a turing complete language without infinite memory and time
12:16:06 <SamB> geckosenator: basic supports files
12:16:14 <shapr> Windows appears to use infinite memory and time, is it Turing complete?
12:16:23 <SamB> I suppose mine didn't support tapes, but...
12:16:28 <AStorm> shapr, finite
12:16:34 <geckosenator> shapr: and it never crashes?
12:16:37 <AStorm> Windows 32-bit supports up to 4 GB address space
12:16:38 <AStorm> :P
12:16:58 <AStorm> It was meant to use infinite memory, but it's buggy.
12:16:58 <SamB> AStorm: use, not actually manage to aquire or track ;-P
12:17:18 <SamB> heh
12:17:29 <Cale> I'd use <- for assignment if I was to design an imperative language.
12:17:34 <zeeeee> when running step 1, 'make', on pandoc-0.2, i get "Could not find module `Distribution.GetOpt':
12:17:34 <zeeeee>  it is hidden (in package Cabal-1.1.6)
12:17:34 <zeeeee> ", but "ghc-pkg list" shows nothing in parens
12:17:44 <SamB> Cale: me too
12:17:54 <SamB> maybe they didn't like lexers back in the old days?
12:17:55 <monochrom> Ahem, http://www.holtsoft.com/turing/
12:17:56 <lambdabot> Title: Turing Programming Language Home Page
12:17:59 <iulus> Cale: but only because you've been influenced
12:18:16 <Cale> iulus: nah, I'd have done that even before I learned Haskell :)
12:18:27 <glguy> I like J's =: for globals and =. for locals
12:18:29 <SamB> iulus: by Knuth's presentation of TeX?
12:18:29 <Cale> I'm influenced by the fact that I have a degree in pure mathematics :)
12:18:34 <Saizan> but <- it's 2 chars, and you have to type it very often! (not that java doesn't finds other ways to be verbose)
12:18:36 <iulus> TI-89's use -> for assignment.  5 -> a
12:18:48 <Cale> = is out of the question, <- seems appropriate for putting something in a cell.
12:18:49 <SamB> iulus: it is convenient for them to do that
12:18:54 <SamB> it does the same thing as <-
12:19:01 <SamB> except the arguments are switched
12:19:01 <Cale> iulus: cool, I didn't know that
12:19:06 <vincenz> heh
12:19:09 <glguy> the 89 has an arrow key though
12:19:10 <nmessenger> doesn't INTERCAL use <-    :)
12:19:14 <vincenz> > let x <- n = putRef x n
12:19:15 <lambdabot>  Parse error
12:19:26 <iulus> Cale: it's actually just one character, though. There's an arrow button on the keypad
12:19:45 <iulus> but boy is programming on that thing a pain
12:20:02 <glguy> I liked the 86's integrated assembly support
12:20:02 <SamB> because when you are using a calculator, you tend to decide you want to store something to a variable *after* you have already calculated it
12:20:08 <geckosenator> intercal has "come from" insead of "go to"
12:20:17 <glguy> in 8th grade, I would write assembly programs on laminated paper with addresses printed on them
12:20:18 <SamB> so when you hit ->, the calculator fills in Ans and you have Ans ->
12:20:25 <iulus> really?
12:20:28 <glguy> use the opcode list to translate the programs into hex
12:20:33 <glguy> and type them into the calculator
12:20:36 <iulus> glguy: that's amazing.
12:20:46 <ph8> oo did you say my name nmessenger?
12:20:51 <geckosenator> glguy: what school did you go to?  there was someone doing that in my math class in 8th grade
12:20:52 <glguy> iulus: we were allowed to test out of chapters in math class, so I had free time
12:20:56 <ph8> i've got something else to run by you if you're interested, it's the puzzle of the moment :p[
12:20:58 <SamB> iulus: I would have done the same thing if my TI-83+ had had a hex-editor!
12:21:01 <ph8> after that it's all easy marks, like remove commas
12:21:04 <nmessenger> ph8: aye, I did
12:21:04 <glguy> geckosenator: south middle
12:21:04 <SamB> well, maybe ;-)
12:21:15 <geckosenator> glguy: oh I was at north middle
12:21:18 <iulus> I remember once I tried to write a basic program on paper in elementary school
12:21:25 <geckosenator> hehe, just kidding but not south middle
12:21:27 <nmessenger> ph8: the next part?
12:21:29 <iulus> but I took it home and it was full of bugs, so I never really did it again
12:21:41 <SamB> iulus: ASM is easier than BASIC maybe?
12:21:48 <ph8> sort of
12:21:50 <nmessenger> ?hoogle [(a,b)] -> Map a [b]
12:21:51 <lambdabot> No matches, try a more general search
12:21:55 <glguy> I wrote a program that hooked into the startup interupt for my ti-86 and required you to enter a password to turn it on
12:22:04 <iulus> SamB: I don't know, I didn't study ASM until college
12:22:08 <glguy> if you failed, it would not turn back on until you held down a certain key pattrern
12:22:10 <vincenz> nmessenger: you mean
12:22:14 <SamB> iulus: you studied it in college?
12:22:16 <ph8> i've altered the code slightly, so I get Map [a] [a] ([string, string] [string])
12:22:17 <vincenz> @hoogle [(a,b)] -> Map a b
12:22:20 <ph8> but i have to deal with collisions
12:22:22 <ph8> so
12:22:22 <lambdabot> Data.Map.fromDistinctAscList :: [(k, a)] -> Map k a
12:22:24 <lambdabot> Data.Map.fromAscList :: Eq k => [(k, a)] -> Map k a
12:22:26 <dfranke> glguy, I did the same with my 89.
12:22:26 <lambdabot> Data.Map.fromList :: Ord k => [(k, a)] -> Map k a
12:22:28 <iulus> SamB: yeah, that's surprising?
12:22:51 <SamB> I have yet to see ASM in college. Though admittedly I think I've only just completed my first year, if that...
12:22:52 <ph8> if ([1, 2] [beta]) gets added and ([1, 2] [alpha]) is already there, it needs to then read ([1, 2] [alpha, beta]) in the final map
12:22:59 * SamB can't keep track
12:22:59 <nmessenger> Can anyone give me a ([(a,b)] -> Map a [b]) such that repeated a's have their b's collected into a list?
12:23:12 <SamB> that is, "first year"
12:23:14 <iulus> I saw it... oh... two years ago? Maybe sophomore or junior year
12:23:14 <glguy> I had a pair of classes that used 8051 asm programming in college
12:23:17 <dfranke> SamB, do you have any course titled something like "Computer Organization"?
12:23:33 <iulus> (or, 2nd or 3rd year, for most people in the world)
12:23:34 <dfranke> if so that'll be your ASM course.
12:23:35 <nmessenger> (or at least point me in a direction?)
12:23:35 <SamB> well admittedly I'm not studying "CS"
12:23:54 <SamB> or CE or EE
12:23:58 <fnord123> computer organization and design.. it uses mips
12:24:04 <iulus> well then I can imagine you wouldn't need to take the class
12:24:04 <zeeeee> can anyone help
12:24:15 <iulus> zeeeee: I'm sure somebody can.
12:24:27 <iulus> what do ya need?
12:24:32 <psnl> zeeeee: whats the problem?
12:24:33 <glguy> zeeeee: the way it works is you ask your question, and then someone who wants to answers it
12:24:35 <SamB> yeah, I wouldn't want to take a class in using an assembly language
12:24:37 <lisppaste2> velco pasted "is there a less ugly way ?" at http://paste.lisp.org/display/33555
12:24:46 <zeeeee> glguy: i did
12:24:55 <SamB> maybe in designing your own machine language and its associated assembly language...
12:25:05 <zeeeee> when running step 1, 'make', on pandoc-0.2, i get "Could not find module `Distribution.GetOpt': it is hidden (in package Cabal-1.1.6)", but "ghc-pkg list" shows nothing in parens
12:25:05 <iulus> SamB: I wasn't too excited about it, either... "We have high level languages now, why would I want to learn that?"
12:25:21 <SamB> its more like... okay, so why would I want to write a program in this stuff again?
12:25:24 <zeeeee> using ghc-6.6
12:25:24 <iulus> but I think it will pay off when I study compilers this semester
12:25:38 <nmessenger> Did anyone hear my last question?
12:25:44 <SamB> if I need to write something in it, I consult the manual, kthxbye!
12:26:15 <fnord123> velco: you could load the constants as strings and then use data MyConstant = MyConstant { something }
12:26:24 <Saizan> nmessenger: i think fromListWith would work
12:26:35 <nmessenger> ?type fromListWith
12:26:37 <lambdabot> Not in scope: `fromListWith'
12:26:40 <glguy> velco: why are you using a case?
12:26:44 <nmessenger> ?type Data.Map.fromListWith
12:26:45 <ph8> nmessenger: insertWith fn k v m
12:26:46 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
12:26:46 <iulus> velco: foo = (+1) ?
12:26:47 <ph8> might help
12:26:52 <fnord123> MyConstant 1 or MyConstant "one" will then work. then you could use what's called an algorithm to generate results in food
12:26:56 <fnord123> foo, pardon
12:27:15 <velco> glguy: dunno, what could I use ? Many ifs ?
12:27:18 <zeeeee> nmessenger: not afaik
12:27:20 <SamB> (basically I already know all about what ASM is, and I have some basic familiarity with a few architectures, but I'm not too good at any of them ;-)
12:27:24 <glguy> velco: guards on the function:
12:27:32 <ph8> or fromlistwith :)
12:27:37 <glguy> f x
12:27:38 <nmessenger> ?type insertWith
12:27:39 <lambdabot> Not in scope: `insertWith'
12:27:41 <glguy>  | x ==1 = 'a'
12:27:44 <nmessenger> ?type Data.Map.insertWith
12:27:46 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
12:28:21 <ski_> doesn't smalltalk use an arrow for assignment, too ?
12:28:22 <iulus> velco: in general, I think you want 'guards'
12:28:26 <velco> glguy: hmm, yes, I guess I could use a function.
12:28:54 <mgsloan> is TI ASM register based?  or rather, which CPU arch.  I can imagine them using ARMs, which have very nice asm
12:29:16 <lisppaste2> glguy annotated #33555 with "velco : two alternatives" at http://paste.lisp.org/display/33555#1
12:29:23 <mgsloan> stack based is the best though :)
12:29:35 <velco> glguy: yes.
12:30:17 <SamB> mgsloan: which TI?
12:30:30 <mgsloan> dunno, I've got an 83 though
12:30:43 <SamB> that has a Z80 cpu doesn't it?
12:30:46 <mgsloan> would be a fun diversion to program it in hex
12:30:48 <mgsloan> maybe
12:30:54 <SamB> the 83+ does
12:30:54 <velco> TI has number of dual-core DPS where one of the cores is ARM and ther other is C55x or C6x
12:30:57 <glguy> mgsloan: also very slow :)
12:31:01 <velco> s/DPS/DSPs/
12:31:25 <SamB> what is a C55x or C6x?
12:31:25 <mgsloan> glguy - plenty of freetime at school
12:31:35 <velco> SamB: processors from TI
12:31:45 <ph8> > fromListWith (++) [(1,2), (1,3), (2,4)]
12:31:45 <lambdabot>  Not in scope: `fromListWith'
12:31:48 <ph8> > Data.Map.fromListWith (++) [(1,2), (1,3), (2,4)]
12:31:49 <lambdabot>  Not in scope: `Data.Map.fromListWith'
12:31:50 <SamB> velco: we are talking about *calculators* from TI
12:31:52 <ph8> heh!
12:31:52 <iulus> I wish I could have stored up all that free time back then and redeemed it now
12:31:56 <SamB> do they use these things in their calculators?
12:31:56 <ph8> foo to you lambdabot!
12:32:00 <mgsloan> probably better spent doing real thinking, but with the interruption of the teacher's voice that's rather hard.  Something relatively mindless like asm might be fun
12:32:04 <monochrom> I think TI calculators were before ARM.
12:32:12 <velco> heh
12:32:18 <SamB> they still make calculators, don't they?
12:32:25 <velco> someone still uses calculators ?
12:32:29 <glguy> they haven't changed much since 98
12:32:31 <monochrom> Yes. They still use old designs.
12:32:38 <SamB> point!
12:32:48 <AStorm> velco, well, some people do.
12:32:50 <iulus> TI-89... I love it, why would they change?
12:32:55 <monochrom> If it works, don't fix it. :)
12:32:55 <AStorm> They're more portable than laptops.
12:33:03 <mgsloan> I wanna make my own calc, with haskell programming
12:33:05 <glguy> I'm not arguing for change :-p
12:33:06 <allbery_b> they could be like HP and kill it off :(
12:33:06 <AStorm> Also, more energy efficient.
12:33:07 <iulus> velco: I really don't want to bring my laptop to math class when a calculator will do
12:33:22 <iulus> also, usually I can do what I want with a calculator faster than with a computer
12:33:24 <AStorm> mgsloan, hmm... ARM9 at least.
12:33:26 <SamB> probably because (a) they don't want to translate any of their calculator programs to a different architecture and (b) people like to play games and stuff
12:33:27 <mgsloan> (seriously, something like haskell is perfect for a calc)
12:33:40 <mgsloan> maybe not fullblown haskell
12:33:44 <glguy> J would be perfect for a calc :)
12:34:04 <monochrom> Make it a PDA.
12:34:18 <SamB> monochrom: PDAs always have sucky calculator programs
12:34:29 * allbery_b uses RPN on his T3
12:34:30 <AStorm> This would be nice PDA with nice calculator :>
12:34:31 <SamB> if they made a PDA, then people would rip off their software!
12:34:39 <monochrom> But if it runs haskell or j or ... you can make it a good one.
12:34:47 <mgsloan> thing is, key input is important
12:34:53 <glguy> because most people that use PDAs don't know enough math to need more than the 4 basic functions ;)
12:35:03 <monochrom> Make it a PDA with lots of keys.
12:35:04 <AStorm> mgsloan, hmm, yep
12:35:07 <mgsloan> probably remove the sci funcs and just go alpha though
12:35:38 <nmessenger> ?type Data.Map.fromListWith
12:35:39 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> Data.Map.Map k a
12:35:49 <monochrom> Be imaginative.  Bring a marriage to calculator and PDA.  Make a new beast.
12:36:04 <mgsloan> ahwell, that's a rather huge endeavor.  I'd rather focus on my other huge endeavors :)
12:36:05 <SamB> I want to see a calculator designed for gaming!
12:36:11 <mgsloan> lol
12:36:20 <glguy> SamB: it's called Nintendo DS
12:36:28 <AStorm> Well, PDA with Qalculate would be nice
12:36:29 <monochrom> Add a camera to it.  Add antenna and DSP for cell phone.
12:36:30 <allbery_b> monochrom: there used to be expansion cards for the HP48 that did that, actually, BITD
12:36:30 <SamB> glguy: that doesn't have enough buttons
12:36:47 <glguy> SamB: it has a touch screen , draw some buttons (o:
12:36:48 <AStorm> monochrom, and fit it in 10x5x2 cm
12:36:50 <allbery_b> (not phone, but added PDA functions)
12:36:50 <mgsloan> I'll have a handcrank too
12:37:05 <iulus> video screen, mp3 player, GPS, too.
12:37:09 <monochrom> You almost got me imagining someone talking to his HP48...
12:37:13 <AStorm> These aren't all that hard.
12:37:21 <AStorm> The hard thing is to power the beast.
12:37:26 <mgsloan> yeah
12:37:28 <glguy> monochrom: I've seen it plenty of times "why won't you work? go faster!"
12:37:30 <SamB> it does sorta seem like eventually we are going to have the cellphone and the PDA and the calculator and the gameboy and the personal media player all rolled into one
12:37:38 <SamB> oh, and the camera ;-)
12:37:50 <iulus> SamB: that's what it looks like to me
12:37:50 <SamB> glguy: you can't push those in!
12:38:05 <AStorm> SamB, with wireless access to the Internet
12:38:10 <mgsloan> that's why you go for a normal calc screen (or grab that OLPC tech), and a lightweight ARM or two with power throttling
12:38:10 <glguy> SamB: you forgot "more than once" :)
12:38:13 <monochrom> Magical batteries are on the way.  I heard that they charge in minutes.
12:38:16 <AStorm> It'll have email too! :P
12:38:17 <SamB> glguy: hmm?
12:38:25 <AStorm> monochrom, charge time is not important
12:38:29 <glguy> SamB: you can push the touch screen in, once
12:38:36 <AStorm> What's important is how long does it run.
12:38:42 <monochrom> I know. I'm exemplifying how magical they are.
12:38:42 <SamB> glguy: I meant the on-screen buttons won't go "in"
12:38:47 <glguy> ah
12:39:04 <mgsloan> with good design, for many hours - the newton could run 30 hours on 2 AA
12:39:13 <SamB> also, fingers smudge screens
12:39:27 <mgsloan> today's winXP tablets die in like 2hrs
12:39:29 <AStorm> mgsloan, hmm, newton doesn't play MP3 :P
12:39:30 <monochrom> What does DS stand for in Nintendo DS?
12:39:39 <SamB> hmm. Dual Screen, I think.
12:39:40 <AStorm> And doesn't have to power GSM transmitter.
12:39:52 <monochrom> It has two screens?
12:39:56 <SamB> yes!
12:39:59 <SamB> how did you miss this?
12:40:02 <AStorm> For two suckers :P
12:40:02 <glguy> monochrom: yeah, one is a touch screen
12:40:07 <monochrom> I know nothing.
12:40:14 <SamB> only one is a touchscreen?
12:40:18 <glguy> right
12:40:19 * SamB hasn't got one
12:40:22 <glguy> the bottom one is a touch screen
12:40:23 <SamB> obviously
12:40:28 <glguy> the top is a normal screen
12:40:29 <monochrom> Are they superimposed?
12:40:33 <SamB> no!
12:40:36 <SamB> they are clamshelled
12:40:50 <glguy> it's actually more useful that you would think
12:40:55 <monochrom> Marvellous.  Ingenious.
12:41:05 * SamB is glad to hear that the bottom one is the touchscreen
12:41:13 <monochrom> Yes I immediately see the profound implication.
12:41:20 <SamB> hmm?
12:41:26 <SamB> profound implication?
12:41:29 <monochrom> Yes.
12:41:32 <vincenz> ?
12:41:38 <glguy> and they have 802.11b support built in
12:41:42 <SamB> that we can have our inventory screen up at the same time as the main screen?
12:41:44 * mgsloan knows what he's talking about
12:41:46 <glguy> and it's supposed to be easy to write homebrew for them
12:41:52 <AStorm> How long does it survive on batteries? :P
12:41:52 <mgsloan> :O
12:41:57 <glguy> 14 hrs easy
12:41:59 <SamB> glguy: I would kind of expect that
12:42:01 <vincenz> monochrom: profound in what sense
12:42:03 <mgsloan> I should ditch my gp2x
12:42:18 <SamB> is there a good DS emulator out?
12:42:32 <glguy> dunno
12:42:32 <SamB> with debugger support and all?
12:42:36 <AStorm> 14h is not good enough.
12:42:41 <AStorm> It has to be 24h :P
12:42:50 <glguy> AStorm: I guess don't buy one them :( not for you
12:42:53 <SamB> (debugger support == support for attaching a debugger to it)
12:43:14 <wchogg> I'm not sure if there is SamB.  There's so much weird hardware in the DS it might be harder to emulate than a normal system.
12:43:18 <monochrom> If you decide to clamshell, you must have two surfaces.  You would think one of them could be input, and put keys on them.  But why put static keys there, if you can make it dynamic?  Have a touchscreen there, both input and output, or dynamically configurable input.  It opens a new dimension.
12:43:46 <mgsloan> is the touchscreen stylus only?
12:43:52 <monochrom> finger
12:43:54 <vincenz> monochrom: the 3rd one?
12:43:56 <mgsloan> cool
12:44:08 <SamB> it comes with a stylus though, right?
12:44:08 <glguy> the DS comes with a stylus though, i tend to use it
12:44:13 <wchogg> Two of them.
12:44:14 <LoganCapaldo> its stylus only if you don't want to smudge it up
12:44:16 <mgsloan> though keys do have nice tactile properties
12:44:28 <LoganCapaldo> it has buttons too
12:44:33 <SamB> of course ;-)
12:44:38 <mgsloan> yeah, video gaming ones :)
12:44:42 <glguy> D-pad, X Y A B diamond, and L R shoulder
12:44:52 <LoganCapaldo> start select
12:44:55 <wchogg> It's a cute little thing.  My wife and I both have one.
12:44:57 <glguy> yeah, and that
12:45:00 <mgsloan> I suppose if it can handle decent games, graphing should be simple
12:45:01 <LoganCapaldo> and a microphone
12:45:02 <AStorm> Hell, it's too expensive for me :P
12:45:05 <SamB> you need that tactile feedback a lot of the time
12:45:05 <glguy> the DS Lite is pretty
12:45:13 <LoganCapaldo> voice controlled games
12:45:28 <mgsloan> yeah, for finger alignment/assurance that you did indeed press a key
12:45:41 <mgsloan> A little vibrator could do the latter
12:45:50 <LoganCapaldo> it usually beeps
12:45:52 <monochrom> Heh that would kill the battery.
12:45:54 <SamB> also, touchscreens aren't good with multiple simultanious presses
12:46:09 <wchogg> The wii remote vibrates when you highlight buttons on menus.  I thought that was a nice touch.
12:46:10 <glguy> they are good for selecting things
12:46:13 <SamB> and even if they were, it is hard to do it
12:46:14 <glguy> not for realtime
12:46:17 <SamB> yeah
12:46:24 <mgsloan> ah, beep is better, could get annoiying though
12:46:29 <SamB> except maybe if you are playing a puzzle game
12:46:43 <monochrom> The touchscreen is excellent for those "pick out the differences" or "where is waldo" games that impress the girls :)
12:46:51 <mgsloan> yeah, multitouch screens would be sweet
12:47:06 <mgsloan> tubad the tech isn't quite developed enough for practical use
12:47:06 <vincenz> erm, so could singletouch screens that are as large as multi touchscreens
12:47:08 <vincenz> o.O
12:47:12 * vincenz peers at people
12:47:27 <mgsloan> nah
12:47:50 <rahikkala> lisppaste2: url
12:47:50 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:48:03 <allbery_b> the touchscreen is a PITA when trying to play it on an hour-long bus ride :>
12:48:04 <mgsloan> I think my VPL (visual programming language) + multitouch will pwn
12:48:14 <LoganCapaldo> when you peer at people, the people peer at you
12:48:22 <LoganCapaldo> allbery_b++
12:48:26 * mgsloan pears at vincenz
12:48:31 * SamB wonders why nintendo didn't allow the cartridge slot to accomodate gameboy games...
12:48:41 <monochrom> visual programming is old school.  enter touchscreen programming.
12:48:53 <LoganCapaldo> SamB: They'd have to put YAP in it
12:48:59 <SamB> YAP?
12:49:09 <SamB> yet another power pin?
12:49:24 <mgsloan> yeah, visual programming is rather hackneyed.  I'm pretty sure I've figured out how to make the paradigm workeable though
12:49:25 <LoganCapaldo> Yet Another Processor
12:49:33 <LoganCapaldo> theres already 2
12:49:35 <allbery_b> on the wii?  I get the impression it didn't seem to work out so well on the DS (haven't tried it), they probably decided not to bother
12:49:42 <SamB> oh, I meant for emulation convenience
12:49:55 <lisppaste2> rahikkala pasted "Does this function have a more common name?" at http://paste.lisp.org/display/33561
12:50:24 <LoganCapaldo> I don't think nintendo is too keen on emulation conveince
12:50:24 <SamB> allbery_b: what?
12:50:40 <SamB> LoganCapaldo: they prefer people to download ROMs from the internet?
12:50:55 <allbery_b> or did you mean GB vs. GBA games?
12:51:13 <LoganCapaldo> SamB: No, but then they'd have to put YAP like I said
12:51:38 <monochrom> rahikkala: map sum . transpose
12:51:49 <SamB> LoganCapaldo: why would they need another processor?
12:52:16 <SamB> Isn't the DS's main cpu quite sufficient?
12:52:20 <LoganCapaldo> Because that's hwo they do it. The GBA processor runs teh GBA games and the DS processor runs the DS games
12:52:37 <SamB> I contend that the DS processor can run gameboy games
12:52:42 <LoganCapaldo> They could emulate it, as demonstrated by the existence of emulators
12:53:06 <LoganCapaldo> but then they need to flash a GB emulator into the ROM, and deprive me of my Picto Chat
12:53:07 <SamB> does this DS support applications loaded onto it?
12:53:09 <rahikkala> monochrom: ... wow. I kinda knew something that does the same thing should exist but I never thought of transpose :o
12:53:20 <thelsdj> i think you can also run both processors at once?
12:53:42 <SamB> thelsdj: its not a good idea to do that in a DS game, I think
12:54:03 <LoganCapaldo> thelsdj: I'm pretty sure you can't, but maybe you can
12:54:08 <monochrom> I won the Trivia Pursuit: Haskell Hierarchical Libraries. :)
12:54:36 <thelsdj> i'm pretty sure you can, the tutorials for writing ds apps shows how i think
12:54:46 <SamB> thelsdj: because you know what will happen when they come out with the PS (penta-screen)!
12:55:01 <SamB> they will drop GBA support, and your game won't work anymore either!
12:55:34 <lisppaste2> metaperl pasted "trying to come up with (a -> State st b) to call mapTreeStateM with... simple example needed" at http://paste.lisp.org/display/33562
12:55:41 <thelsdj> i could be wrong but i had the impression that you had to access each screen from each processor
12:56:05 <SamB> thelsdj: oh, you mean it has two DS processors?
12:56:09 <SamB> not just one?
12:56:26 <thelsdj> i believe it has 2 different types of processors
12:56:30 <thelsdj> arm9 and arm7 or something like that
12:56:44 <SamB> arm7 is for the GBA support, no?
12:56:48 <metaperl> *Main> mapTreeStateM (\a -> State st (a+1))   t1
12:56:48 <metaperl>   -- doesnt cut it
12:57:20 <thelsdj> "The Nintendo DS has two CPU's. They are the ARM7 and ARM9. Both can be running code at the same time. A DS program is usually composed of an ARM7 executable, an ARM9 executable and various icons, bitmaps, resources, etc. These are combined into a single 'executable' using a tool called 'ndstool'. The resulting file is like a self contained filesystem. This produces the 'someprog.nds' file that can be run by the device."
12:57:27 <thelsdj> did that cut off at all?
12:57:29 <thelsdj> http://www.double.co.nz/nintendo_ds/nds_develop1.html
12:57:30 <lambdabot> Title: Homebrew Nintendo DS Development Part 1
12:57:47 <SamB> oh?
12:58:08 <thelsdj> and yea i think the gba runs on the arm7
12:58:18 <monochrom> Interesting!
12:58:23 <thelsdj> thats why most of the graphical intensive stuff runs on the top screen
12:58:28 <thelsdj> (gba runs on the bottom)
12:58:56 <thelsdj> i have all the hardware to do nds homebrew, haven't gotten around to it though
12:58:59 <lisppaste2> augustss annotated #33562 with "Sample function" at http://paste.lisp.org/display/33562#1
12:59:47 <mgsloan> nice.  the bottom can handle graphing calc UI while the top does the good stuff
12:59:57 <mgsloan> can you say dynamically updated graphs?
13:00:17 <LoganCapaldo> thelsdj: You seem to be right to a certain extent. I think though that its that the ARM7 controls the "touch functionality", not necessarily the graphics.
13:00:48 <LoganCapaldo> Since for instance, my FF3 here uses the bottom screen almost exclusively and is fully 3D
13:00:49 <SamB> thelsdj: and here I thought it was because the bottom screen was good for menus!
13:01:35 <psi> is ff3 good? it's not even out here yet :(
13:01:41 <SamB> LoganCapaldo: what does it do with the top screen?
13:01:44 <thelsdj> hm, i thought ff3 was on the top screen, guess i wasn't paying much attention when playing it
13:01:50 <SamB> also... I thought ff3 was for SNES?
13:01:54 <LoganCapaldo> SamB: Usually nothing
13:01:59 <wchogg> psi:  It's harder than most recent games, but I like it so far.
13:02:06 <psi> SamB, no, nes, and this is a 3d remake.
13:02:07 <nmessenger> SamB: it's complicated
13:02:12 <wchogg> SamB:  That was actually number 6 that was for the SNES.
13:02:17 <psi> wchogg, cool.
13:02:22 <SamB> okay, then, NES!
13:02:26 <thelsdj> i wish they'd make an updated 6
13:02:44 <SamB> I guess I can understand why they would remake an NES game with 3D graphics ;-)
13:02:45 <thelsdj> though the original is almost perfect
13:03:06 <psi> i need to finish ff7.
13:03:32 <SamB> so ff7 is the one right after the SNES one?
13:03:32 <psi> i've just returned from space.. i wonder how much is left.
13:03:34 <nmessenger> SamB: JA NES 1,2,3, JA SNES 4,5,6, ELSEWHERE NES 1, ELSEWHERE SNES 2 (actually JA 4), and 3 (actually JA 6)
13:03:50 <wchogg> SamB:  Yes.
13:03:58 <SamB> hmm.
13:04:12 <SamB> oh, but there are two for SNES?
13:04:16 <psi> SamB, 3!
13:04:16 <Philippa_> three
13:04:26 <Philippa_> though 5 was never released on the SNES outside Japan
13:04:32 <nmessenger> 2,3, and 5 were not actually released outside of Japan
13:04:32 <thelsdj> also they rereleased 5 on gba
13:04:41 <SamB> Philippa: two that have been published in english
13:04:45 <Philippa_> as was 2 and 3 on DS
13:04:48 <SamB> at least, for SNES
13:04:50 <lisppaste2> metaperl annotated #33562 with "How can I make type State showable?" at http://paste.lisp.org/display/33562#2
13:04:52 <Philippa_> 5's also available on PSX
13:05:04 <dmhouse> metaperl: you can't, really.
13:05:11 <SamB> yeah, I have that
13:05:19 <Philippa_> SamB: yup, and they weren't available in the UK. FF2 was Japan's FF4 Easytype, FF3 was Japan's FF6
13:05:21 <psi> the best thing you can do is to always use the japanese numbers. it was idiotic to rename them anyway.
13:05:23 <SamB> I think you just saved me a trip over to see which one it is ;-)
13:05:35 <SamB> psi: yes, Square does that too ;-)
13:05:37 <nmessenger> SamB: that's why the numbers seemed to skip from 3 to 7
13:05:37 <metaperl> oh so I need to extract my showable value from the final output....
13:05:44 <wchogg> I hated the fact that outside Japan we got the easy version of 4.
13:05:54 <SamB> nmessenger: they seemed to skip from 5 to 7 for me ;-)
13:06:43 <SamB> or maybe I have 4?
13:06:51 <SamB> I will go and look after all
13:06:57 <SamB> (I got it for Chrono Trigger)
13:07:08 * nmessenger bounces at Chrono Trigger
13:07:58 <thelsdj> chrono trigger would be cool to have on ds, did they ever put it out on a portable system?
13:07:59 <nmessenger> Who here has NOT played this delightful morsel of a game?
13:07:59 <SamB> okay, I have IV
13:08:09 * allbery_b waves
13:08:19 <SamB> thelsdj: the playstation version is a pain
13:08:29 <SamB> the playstation does not have enough RAM
13:08:35 <thelsdj> better to probably play snes on rom
13:08:35 <nmessenger> haha
13:08:44 <thelsdj> er emulator
13:08:51 <LoganCapaldo> hates hitting the menu button in the psx version
13:08:52 <SamB> it is always having to read things from the disk
13:09:15 <wchogg> Wow this is an amazingly nostalgic conversation for me.
13:09:21 <SamB> You'd think they could have done some kind of cache...
13:09:30 <nmessenger> I've never played the PS version
13:09:43 <wchogg> SamB:  Yeah, I bought those PS versions but just played them on emulator anyway.
13:09:53 <thelsdj> i always liked that snes rpg where you would get 'creamy cheese' items, can't remember the name
13:09:58 <vincenz> heh, I had tekken 3 with an emulater, it ran -way- too fast
13:10:00 * nmessenger hearts Snes9x
13:10:06 <SamB> wchogg: oh, a playstation emulator?
13:10:18 <quazimodo> this is a highly active channel :/
13:10:18 <wchogg> thelsdj:  Star Ocean?
13:10:26 <SamB> because I was about to say that the ROM on the Chrono Trigger disk is in japanese!
13:10:27 <thelsdj> terranigma i think
13:10:33 <Philippa_> I've not used snes9x in ages, started using ZSNES a few years back instead
13:10:53 <nmessenger> I've used both, I switch on a whim
13:10:56 <SamB> ZSNES is nice
13:11:11 <psi> the good thing about snes9x is that it's not limited to x86
13:11:15 <Philippa_> Terranigma was great
13:11:20 <psi> which means i can use it on my mac
13:11:20 <SamB> psi: there is that
13:11:34 * nmessenger is partial to GUI's that behave like most progs
13:11:38 <SamB> I have heard of lots of hacks in snes9x...
13:11:42 <thelsdj> i should see if theres a good snes emulator for nds
13:11:50 * SamB is partial to GUIs that he can use on Linux
13:12:04 <nmessenger> SamB: It's an emulator!  You think ZSNES isn't hacky?
13:12:05 * dylan is partial to optional GUIs
13:12:11 <SamB> nmessenger: well, it is
13:12:20 <SamB> but they are trying to remove hacks
13:12:33 <SamB> whereas supposedly someone was adding hacks to snes9x...
13:12:40 <SamB> of course, I'm biased...
13:14:04 <psi> i was delightfully surprised when i loaded an rpg into snes9x a few months ago. it contained an intro song in japanese.
13:14:09 <psi> pretty advanced for snes
13:14:20 <SamB> Tales of Phantasia?
13:14:22 <wchogg> Was it tales of phantasia?
13:14:29 <psi> i think so
13:14:44 <SamB> yeah, that is cool
13:14:53 <nmessenger> Star Ocean has full (strangely English) voiceovers in the OP
13:15:06 <SamB> nmessenger: that isn't so cool
13:15:19 <SamB> but, that isn't so strange either
13:15:36 <nmessenger> SamB: for a Japanese game?
13:15:37 <SamB> it is a star trek knock-off (parody?) isn't it?
13:15:42 <SamB> the intro, I mean
13:16:10 <nmessenger> SamB: actually, it's one of the bigger RPGs available.  I've not played it much.
13:16:40 <SamB> I mean that the intro smacks of star trek references of one kind or another... isn't it more like star trek if it is in english?
13:16:43 <zeeeee> what's the advantage of putting commas on the beginning of the next line instead of the end of the current line? (i see this frequently in haskell)
13:17:01 <nmessenger> possibly, I didn't pay much attention.
13:17:20 <SamB> zeeeee: you can insert another line at the end of the list without editing the one before
13:17:33 <SamB> this can reduce patch colissions
13:18:26 <SamB> I wonder how long until ZSNES is written in C...
13:18:36 <nmessenger> it isn't now?
13:18:47 <Philippa_> it certainly used to have chunks of asm
13:18:53 <SamB> I think I suggested something like 30 years in #zsnes, and they called me a hopeless optimist!
13:19:01 <SamB> Philippa: "chunks"?
13:19:21 <nmessenger> SamB: blotches, gobs, etc
13:19:23 <Philippa_> SamB: big ones :-)
13:19:25 <SamB> @topic-tell #zsnes
13:19:26 <lambdabot> Do not know that channel
13:19:54 <LoganCapaldo> ZSNES - The Super Nintendo Emulator which is 75.9795% x86 assembly - Development Channel | No ROM requests | http://www.zsnes.com, https://zsnes.bountysource.com, http://zsnes-
13:20:02 <nmessenger> Is lambdabot making a command there?  "Do NOT know that channel!"
13:20:13 <SamB> nmessenger: no
13:20:27 <Philippa_> nmessenger: and if so, does it mean biblically?
13:20:35 <mgsloan> hah
13:20:39 <psi> :)
13:20:48 <SamB> I don't think the folks there would appreciate it if you did that anyway...
13:20:57 <SamB> I certainly would not
13:21:23 <SamB> anyway, apparantly it is down to about 75% asm
13:21:31 <zeeeee> SamB: that's not true...usually it's in a {}, so the last line would still need to have its } removed
13:21:46 <nmessenger> Philippa_: IT?!  Don't you mean SHE?
13:21:50 <zeeeee> SamB: unless there's another common case
13:22:12 <Philippa_> nmessenger: I was referring to the sentance :-)
13:22:13 <SamB> zeeeee: hmm?
13:22:28 <SamB> zeeeee: you put the closing delimiter on the next line!
13:22:30 <SamB> next to the ,
13:22:33 <SamB> or ;
13:22:57 <SamB> (vertically next to)
13:25:21 <waern> SyntaxNinja, ping
13:25:46 <mgsloan> Ah. figured out why codenames are popular: takes out a cyclic dependency in the todo graph
13:25:56 <SamB> hmm?
13:26:21 <mgsloan> because the name should reflect the thing, but you need a name to call it while initially figuring out what it is
13:26:41 <SamB> ah
13:26:53 <SamB> that does not explain why nintendo is always using them though
13:27:48 * nmessenger wonders how common the phrase "cyclic dependency in the todo graph" is.
13:28:03 <SamB> nmessenger: I suspect not very common
13:28:03 <mgsloan> yeah.  Revolution is more of an appropriate name (not that I think the controller is super innovative or anything)
13:28:34 <mgsloan> yeh, probably not.  It will be though.  Once I make a website to spread such ideas
13:28:53 <SamB> Assuming you can teach graph theory to the masses!
13:29:17 <mgsloan> a bit of informal graph theory never did anyone harm :)
13:29:40 <Philippa_> mgsloan: on a console like that it is - it brings the cost of doing that kind of game down massively
13:29:48 <sorear> ?messages?
13:29:49 <lambdabot> Sorry, no messages today.
13:29:52 <Philippa_> think of it as an economic revolution, or an arcade-to-home one
13:30:09 <mgsloan> heh, yeah, it is rather cool
13:30:10 <Philippa_> SamB: presumably their marketers want to wait
13:30:27 <mgsloan> I haven't actually gotten to mess with one yet
13:30:44 <Philippa_> I only have briefly so far
13:32:07 <dylan> the controller + the name is the butt of many jokes....
13:32:22 <nmessenger> HA HA DYLAN SAID BUTT!
13:32:43 <dylan> e.g. my friend Possum stayed in his room an entire week playing with his new wii. ;)
13:32:44 <nmessenger> See?  Infantile humor gets old quick.
13:33:08 <dylan> puns never get old.
13:33:12 <Philippa_> dylan: the bundled title and an associated one don't help either
13:33:21 <dylan> wii sports...
13:33:31 <LoganCapaldo> nmessenger: You mean you don't want to touch my wii controller?
13:33:38 <Philippa_> "wii play" and "wii sports"... I know if I actually own one then after a month or so I'll stop seeing the watersports reference, but still
13:33:43 <nmessenger> hopefully there won't be a wii water sports
13:33:43 <dylan> Some lass at his dorm asked to play with his wii, too. That was funny. XD
13:33:50 <Philippa_> LoganCapaldo: perhaps only wiimotely?
13:34:15 <dylan> I don't think I want to know what watersports would be in reference to a wii. :P
13:34:35 <nmessenger> dylan: sarcasm?
13:34:37 <psnl> h god, you guys have started the wii jokes
13:34:38 <Philippa_> why, playing with it of course
13:34:40 <monochrom> hmm, what's wrong with watersports emulations in wii?
13:34:53 <dylan> nmessenger: Not at all. I am the ostrich. :)
13:34:59 <Philippa_> monochrom: yeah, it'd be an extremely /accurate/ emulation
13:35:49 <nburlett> hello!
13:35:58 <nmessenger> dylan: ah, I missed 'think I want to' when I parsed that sentence.
13:36:03 <monochrom> I guess we can't simulate wavy surroundings on land...
13:36:44 <nburlett> can anyone recommend a C->Haskell binding library? There seem to be several, but I can't really tell which is best
13:37:06 <dylan> err, just use the FFI?
13:37:06 <ski> /wii lambdabot
13:37:41 <monochrom> none is the best.  there is c2hs to do some *.h file translation.
13:37:52 <quazimodo> GUYS
13:37:58 <LoganCapaldo> frankly I'm surprised that I haven't heard more Monad jokes
13:38:01 <dylan> HUMANS!
13:38:19 <quazimodo> if anyone else comes asking for freebsd problems with ghci, tell him to get the 6.4.1 package as that correctly links to readline.so.6 but the 6.4.2 version doesnt
13:38:21 <nmessenger> there are girls on the internet, didn't you know?
13:38:27 <nburlett> so you think it's best to simply make the FFI code by hand
13:38:27 <dylan> LoganCapaldo: Oh, I've heard plenty of monad jokes offline...
13:38:29 <mgsloan> A monoid is half a steroid!
13:38:43 <monochrom> ok hahaha
13:39:05 <mgsloan> (I think this one is actually original)
13:39:12 <dylan> nburlett: if you don't need to mess with C pre-processor symbols, yes
13:39:17 <dylan> otherwise hsc2hs to useful
13:39:44 <monochrom> Someone testified that there is a group of girls who said "guys let's go" to each other.
13:40:03 <sorear> Last I heard 'man
13:40:29 <Philippa_> yeah, guys plural's pretty gender-neutral these days
13:40:32 <dylan> guys is gender-neutral around here.
13:40:43 <monochrom> I should learn FFI now.  It sounds fun.
13:40:55 <dylan> on the other hand, saying "insert gender here" can be taken as sexist, apparently....
13:41:02 <nburlett> is there a difference between c2hs and hsc2hs?
13:41:04 <mgsloan> fun in an impure sorta way ;)
13:41:11 <nmessenger> dylan: that seems kinda bizarre
13:41:20 <monochrom> hmm, I may mean hsc2hs. :)
13:41:38 <Philippa_> dylan: depends how it's done
13:41:41 <fnord123> nmessenger: its a snarky attack on gender political minded people. hence why it's offensive to some
13:41:43 <sorear> Saying "insert gender here" is unpleasantly verbose, also.
13:41:53 <Philippa_> fnord123: it /may be/ one...
13:42:05 <dylan> nmessenger: "What's his name?" "It's a woman" "Righto. What's insert-correct-gender-here's name?"
13:42:12 <nburlett> allright, I'll check that out, thanks!
13:42:21 <Philippa_> dylan: right, that's snarky
13:42:22 <monochrom> Political correctness means you can't mock the morons either. :)
13:42:26 <fnord123> it's so verbose, I think it is reasonable to perceive it that way
13:42:45 <Philippa_> fnord123: yes, the circles where it's less likely to be tend to recognise more than two genders
13:42:56 <LoganCapaldo> (\x -> "Hello " ++ x ++ "-gendered persons") :: (Gender a) => a -> String
13:43:23 <dylan> well, it was in reply to a snarky comment
13:43:24 <monochrom> hehehehe
13:43:27 <mgsloan> (Gendered a) maybe
13:43:30 <nmessenger> meh, there's far too many rules that they end up leaving you with no viable options.  The only logical conclusion is to not take it seriously.
13:43:31 <LoganCapaldo> assume show is in there or something
13:43:37 <dylan> when I said "his" I was not being gender specific
13:43:51 <monochrom> instance Gender a => Gender (Maybe a) ...
13:43:55 <Philippa_> dylan: now there's a good way to start an argument
13:44:28 <dylan> and it was already an over-correction -- I would have normally assumed it was a female, as the person was a head librarian. :-/
13:44:40 * fnord123 wonders why people don't use "they" or "their"
13:44:41 <mgsloan> data Gender = Gender {male, female :: Bool}; class Gendered a where sex :: a -> Gender
13:44:42 <vincenz> let's not get into dynamically-scoped gender
13:44:55 <ph8> ERROR "Main.lhs":43 - Last generator in do {...} must be an expression
13:44:58 <ph8> what's that error all about?
13:45:02 <Philippa_> vincenz: the analogy was dynamically-typed rather than scoped, if you're referring to who I think
13:45:04 <ph8> i have a return at the end of that function
13:45:09 <vincenz> Philippa_: oh
13:45:10 <Philippa_> fnord123: some people do
13:45:12 <nmessenger> fnord123: because the prescriptivists of the world say that it is bad syntax
13:45:21 <vincenz> Philippa_: no cause I used dynamically and -lexically- in which case it must be scoped, I believe
13:45:38 <fnord123> nmessenger: I thought 'they' was the gender neutral third person
13:45:39 <monochrom> What's wrong with dynamical gender?  People do it all the time on IRC to get help. :)
13:45:48 <Philippa_> nmessenger: yep. Of course, those prescriptivists're pulling their rules from other languages...
13:46:03 <sorear> "he(1) pron. ... 2. Used to refer to a person whose gender is unspecified or unknown."
13:46:08 <Philippa_> fnord123: if you agree singular they exists at all
13:46:13 <LoganCapaldo> IRC isn't type safe
13:46:19 <vincenz> sorear: :D
13:46:25 <Philippa_> sorear: yes, but also widely if not universally considered sexist in that use
13:46:28 <fnord123> I agree singular they exists. If someone wants to use it, they are welcome to.
13:46:31 <vincenz> LoganCapaldo: you mean the net isn't type-safe
13:46:34 <sorear> -- The American Heritage Dictionary, 3rd Edition
13:46:38 <nmessenger> fnord123: but generally regarded as plural only
13:46:44 <mgsloan> <girl> Hey, can someone help with monads?  <monochrom> OOH! ME ME!
13:46:58 <vincenz> mgsloan++
13:46:59 <Philippa_> nmessenger: I wouldn't go so far as generally amongst those who actually recognise what we're talking about
13:47:07 <dylan> I'm sure I would've 'they' I would've had problems too
13:47:14 <quazimodo> monads. lol reminds me of gonads
13:47:15 <monochrom> You can even have different genders in different channels.  Dynamic scoping.
13:47:15 <mgsloan> that'd be funnier if it was "my monads" :)
13:47:24 <Philippa_> dylan: only if you were talking to a grammar nazi
13:47:48 <nmessenger> 'Generally' was just my being too lazy to come up with an accurate adjective. :P
13:48:01 <vincenz> @quote vincenz
13:48:02 <lambdabot>  why do you want to be dynamicalyll gendered? lexically gendered is cleaner
13:48:11 <Philippa_> oh, or someone who thinks zie/hir is the only way to go rather than merely being good when you need to rhyme with the same things she and he do
13:48:57 <dylan> Philippa_: well, the context of this was us getting evicted from meeting at the library by the new management.
13:48:59 <mgsloan> technically we should adopt the y'all pronoun
13:49:07 <lisppaste2> metaperl annotated #33562 with "what can I type in ghci to get the type of (>>=) in this case" at http://paste.lisp.org/display/33562#3
13:49:08 <nmessenger> Language does change, but not quite so fast as all that.
13:49:16 <nmessenger> Anybody ever heard of 'thou'
13:49:21 <Philippa_> dylan: you would've got snarked at for something else, then
13:49:27 <LoganCapaldo> You know what the problem is? Gender isn't a type its a state ;)
13:49:46 <LoganCapaldo> runGender (\x -> ...) initialGender
13:49:47 <sorear> :t (>>=)   -- this work
13:49:49 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
13:49:51 <Philippa_> nmessenger: there're a fair number of places where zie/hir's in (locally) common usage
13:50:07 <Philippa_> LoganCapaldo: yep, as distinct from sex as well. Now try explaining that to most people...
13:50:21 <nmessenger> Philippa_: Really?!  I'm boggled.
13:50:24 <monochrom> metaperl: heh, you have to know the specific type in order to get ghci to tell you the same thing, eh?
13:50:34 <dylan> Philippa_: probably. I never got a response from my appology letter, possibly because a description of the 30-something grammatical genders of the Bantu family of languages...
13:50:42 <vincenz> @remember LoganCapaldo
13:50:43 <lambdabot> Incorrect arguments to quote
13:50:50 <metaperl> oh, good point. It would help me understand it if I could see the exact type monochrom
13:50:53 <vincenz> @remember LoganCapaldo You know what the problem is? Gender isn't a type its a state ;)
13:50:54 <monochrom> State st a -> (a -> State st b) -> State st b
13:51:14 <nmessenger> ?quote LoganCapaldo
13:51:15 <lambdabot>  lambdabot is too clever for me
13:51:49 <mgsloan> Logan - yeah, see my haskell line - data Gender = Gender {male, female :: Bool}; class Gendered a where sex :: a -> Gender
13:51:58 <mgsloan> about as politically correct as you can get
13:52:02 * nmessenger snickers 'cause he remembers the context of that quote
13:52:21 <mgsloan> (and yes, sex is a verb - if you sex an animal, you determine its gender ;p )
13:52:21 <Philippa_> mgsloan: wrong
13:52:32 <Philippa_> no, you determine its sex
13:52:36 <Philippa_> *sigh*
13:52:42 <fnord123> now let's overload sex as a function. :)
13:52:42 <sorear> he is gender neutral, says a 14-year-old paper dictionary. QED.
13:52:52 <Philippa_> the two words aren't synonymous
13:53:30 <nmessenger> 'sex-up' is a different verb, though
13:53:32 <mgsloan> true, but it gets confusing when you use both forms
13:54:17 <dylan> the verb sex typically only applies to chickens, doesn't it?
13:54:31 <Philippa_> and for my next act of confusion, one frequent use of gender-neutral pronouns is when the gender in question isn't one of male or female
13:55:00 <dylan> What about the grammatical gender of flowing water? :)
13:55:00 * vincenz moves everyone to #haskell-blah
13:55:12 * nmessenger refuses to go
13:55:15 <Philippa_> dylan: back to Nintendo, then?
13:55:57 <sorear> The popular misconception that there are no gender-neutral pronouns in English has forced us to do some pretty stupid things, like assign one to lambdabot.
13:56:07 <fnord123> I thought the neologism "shim" was adequate for mixed gendered people.
13:56:27 <psnl> Philippa_: so what is the correct thing to do?
13:56:32 <Philippa_> fnord123: and if the gender in question isn't "mixed"?
13:56:42 <nmessenger> One could always use 'one' when one does not wish to specify gender, but that kinda makes one look like an ass.
13:56:45 <monochrom> is "it" gender-neutral?
13:56:46 <Philippa_> or if the neologism's considered offensive by the group in question, like most of them?
13:56:52 <fnord123> euniqs are "its" aren't they?
13:57:01 <dylan> Philippa_: NO! I will never go back to ni--oh, not the mental institution?
13:57:03 <Philippa_> psnl: singular they and fuck the prescriptivists is generally a good approach :-)
13:57:27 <sorear> what's wrong with 'he'?
13:57:29 <mgsloan> euniqs are Gender False False, by my haskell
13:57:30 * psnl has a posh education and as such feels that one is a ok word to use
13:57:39 <Philippa_> monochrom: yes, but tends to imply non-humanity as well
13:57:54 <Philippa_> sorear: because it comes with a default
13:58:12 <fnord123> what are self impregnating komodo dragons?
13:58:18 <nmessenger> funny
13:58:25 <mgsloan> Gender True True
13:58:51 <monochrom> "I saw Sam on the street today.  They was cute."?
13:59:02 <Philippa_> monochrom: normally were rather than was, but sure
13:59:05 * dcoutts__ agrees with psnl, and thinks that it's even better since it allows one to refer to oneself in the third person too
13:59:11 <vincenz> People, really, this is a conversation with #haskell-blah, it has run on long enough
13:59:16 <vincenz> erm, for #haskell-blah
13:59:28 <integral> "They were cute."
13:59:29 * nmessenger kinda likes the japanese convention of 'that person'
13:59:36 <Philippa_> point. As it generally was the last few times it happened, too
13:59:39 <dylan> This one often uses "one" as a more polite way of saying "I"
13:59:44 * LoganCapaldo cheats
13:59:48 <LoganCapaldo> "Sam was cute"
14:00:02 <sorear> Since all IRC actions are parametric in gender, can't we just scrub the type information and get on with hacking?
14:00:05 <nmessenger> 'I saw that person on the street today.  That person was cute."
14:00:12 <monochrom> We need variables instead of pronouns :)
14:00:58 <LoganCapaldo> "I saw Sam bind x on the street today. X was cute"
14:01:07 <mgsloan> I use "one" as a more correct "you" when you have no idea who you are talking to.  Eg, when stating general rules of thumb, rather than "You should not use imperative languages", "One should not use imperative languages"
14:01:08 <LoganCapaldo> Hmm doesn't roll off the tongue
14:01:10 <nmessenger> monochrom: in a sense, pronouns *are* variable, with an extremely limited namespace
14:01:10 <monochrom> Yeah!
14:01:11 <dylan> lojban has something like that, I think
14:01:47 <nmessenger> s/variable/variables/
14:01:54 <dylan> mgsloan: I use it in both cases, actually
14:02:10 <quazimodo> how does one "exit" ghci?
14:02:15 <sorear> :q
14:02:15 <nmessenger> :quit
14:02:21 <sorear> ^D
14:02:23 <LoganCapaldo> Pronouns are like perl's $_, and @_ and we know how horrible those are
14:02:29 <sorear> \004
14:02:31 <nmessenger> Ctrl-Alt-Delete
14:02:38 <sorear> PrtScrn
14:02:41 <dylan> pronoun is somewhat close to pr0n!
14:02:46 <nmessenger> *Smash Computer*
14:02:49 <sorear> (on linux, grr)
14:02:51 <Philippa_> LoganCapaldo: speech != code, what else is new?
14:02:54 <daniel_larsson> > nub "pronoun"
14:02:56 <lambdabot>  "pronu"
14:02:59 <daniel_larsson> damn
14:03:06 <Botje> > init $ nub "pronoun"
14:03:08 <lambdabot>  "pron"
14:03:09 <dylan> pronu!
14:03:10 <Botje> perfect.
14:03:16 <sorear> not quite
14:03:19 <ph8> guys! could do with some help, i can't find a reference for the function = do ... syntax - what do 'do' blocks have to end with??
14:03:22 <nmessenger> also walk away
14:03:27 <sorear> ?. elite run init $ nub "pronoun"
14:03:28 <lambdabot> "PR0N"
14:03:36 <dylan> "I saw Sam on the street today. Pronu was cute"
14:03:36 <Botje> ph8: nothing, they're syntactical sugar.
14:03:39 <vincenz> ph8: do doesn't end with wanything
14:03:47 <vincenz> ph8: it's like python, it's indentation based
14:03:48 <mgsloan> Philippa_ : not yet.  I can see some utility in bringing adjectives and adverbs into languages, as well as pronouns
14:03:50 <Botje> ph8: have you read what YAHT has to say about them?
14:03:51 <ph8> so i have an error saying "do must end with an expression"
14:03:57 <vincenz> ph8: @paste the code
14:04:01 <ph8> and it has a return at the end
14:04:05 <vincenz> ph8: bad indentation then
14:04:18 <vincenz> the indentation must have stopped at a line looking like "x <- blabla"
14:04:35 <nmessenger> ph8: that's means that a do can't end with a 'foo <- bar'
14:04:46 <lisppaste2> ph8 pasted "do errors" at http://paste.lisp.org/display/33570
14:05:02 <ph8> but it's a return
14:05:10 <ph8> it's probably my indentation, can you spot anything?
14:05:15 <mgsloan> I designed an OOP language at some point where a = new Red Ball <=> a = new Ball; a.Color = Red
14:05:23 <daniel_larsson> you need empty lines around ">" lines, no?
14:05:35 <monochrom> YES!
14:05:36 <ph8> argh yes
14:05:36 <norpan> ph8: you can't have empty lines there i think
14:05:37 <ph8> missed that
14:05:52 <ph8> doesn't fix it though :/
14:05:56 <ph8> no empty lines :(
14:05:57 <ph8> sucky
14:05:58 <psnl> ph8: whats up with your return?
14:06:01 <ph8> can i comment any other way?
14:06:11 <ph8> psnl: nothing afaik, it's the do that errors
14:06:17 <ph8> Data.Map> :l Main.lhs
14:06:17 <ph8> ERROR "Main.lhs":43 - Last generator in do {...} must be an expression
14:06:22 <psnl> {-   -}
14:06:33 <nmessenger> which line is actually 43?
14:06:34 <sorear> --.*$
14:06:43 <ph8> the declaration of processFile
14:06:45 <ph8> first line of paste
14:06:50 <metaperl> on line 5 of this paste http://rafb.net/p/gC5obF29.html ... is st' == st ?
14:06:53 <daniel_larsson> Your function has type IO (), but you try to return theMap
14:07:01 <ph8> sorry line 3 of the paste
14:07:06 <ph8> daniel_larsson: good point :p
14:07:33 <ph8> same error with return type changed to Map [[Char]] [[Char]] though
14:07:35 <nmessenger> danial_larsson: that'd be a problem, but it wouldn't cause this specific error message, right?
14:07:35 <sorear> ?users
14:07:36 <lambdabot> Maximum users seen in #haskell: 309, currently: 294 (95.1%), active: 53 (18.0%)
14:07:51 <daniel_larsson> nmessenger: no, not likely
14:07:56 <monochrom> OK, can you click the "annotate this paste" button and then paste the revised version?
14:08:11 <Botje> ph8: check your indentation, make sure it's consistent
14:08:11 <monochrom> It's hard to guess what you changed.
14:08:24 <lisppaste2> psnl annotated #33570 with "easy comment ;-)" at http://paste.lisp.org/display/33570#1
14:08:37 <metaperl> on line 5 of this paste http://rafb.net/p/gC5obF29.html ... is st' == st ?
14:08:40 <dmhouse> Anyone know how to kill a cookie in HApps?
14:08:45 <dmhouse> shapr: around?
14:08:50 <ph8> it only varies with the comments Botje
14:08:56 <ph8> i'll try it without the comments
14:09:13 <dmhouse> metaperl: no.
14:09:17 <ph8> same error, even without the comments
14:09:23 <nmessenger> dmhouse: bludgeon it with a sledgehammer
14:09:44 <nmessenger> dmhouse: that can kill many things
14:09:44 <LoganCapaldo> ph8 try writing it with explicit { ; etc.
14:09:54 <lisppaste2> ph8 annotated #33570 with "Without comments and indentation assured" at http://paste.lisp.org/display/33570#2
14:10:05 <ph8> do { } ?
14:10:07 <dmhouse> metaperl: if you have (State x), then x is a function that takes some state and returns a value and the new state.
14:10:09 <ph8> i've never seen it with { }
14:10:10 <metaperl> dmhouse  - given the state function is (\state -> (state, a)) , I figured that run st would evaluate to (\st -> (st, a))
14:10:13 <LoganCapaldo> ph8 no
14:10:18 <ph8> i've never seen a ; in haskell either!
14:10:18 <LoganCapaldo> that indent is wrong
14:10:24 <metaperl> ok let me read that
14:10:29 <LoganCapaldo> ls has to be past the do
14:10:39 <nmessenger> ph8: are there evil tabs?
14:10:44 <ph8> i'm using tabs yes
14:10:47 <ph8> what else should you use?
14:10:49 <mgsloan> ph8 - ; is basically a newline, with some different layout rules
14:10:52 <mgsloan> spaces!
14:10:54 <metaperl> OH YES I SEE.. thanks dmhouse
14:11:04 <lisppaste2> ph8 annotated #33570 with "better indent" at http://paste.lisp.org/display/33570#3
14:11:25 <ph8> using spaces in code is so wrong though
14:11:31 <ph8> it makes it so hard to deal with
14:11:46 <sorear> ph8: tabs are perfectly safe, as long as you don't do anything stupid like set tabstops every 4 columns.
14:11:58 <ph8> so what do you think is wrong with the code?
14:12:12 <sorear> ph8: asfar as haskell is concerned 8 is the only correct tabstop setting
14:12:14 <dmhouse> metaperl: State x >>= f creates a compound State value which is a function that takes a piece of state, feeds it to x, collects the value and the new state, applies to the value to f to yield another State value (a function which wants some initial state, remember), and gives this State value the new state from x. The result of the compound function is the result of this second State value.
14:12:47 <dmhouse> metaperl: return x is the State value which takes the initial state, returns it as the new state, and returns x as the value.
14:13:05 <monochrom> I don't trust tabs
14:13:19 <mgsloan> ph8 - it's general good style to use spaces though
14:13:27 <Botje> monochrom: why, did $random_relative get eaten by one?
14:13:31 <ph8> my tabwidth is 8
14:13:34 <ph8> mgsloan: why?
14:13:39 <ph8> i'm curious
14:13:51 <dmhouse> nmessenger: well, I hit it with a temporal sledgehammer, I gave it a negative lifetime, but sadly the amazing interface that is HAppS.Protocols.Cookie caught my 'mistake' and just set a session-length cookie instead.
14:14:01 <dmhouse> nmess|food: as above.
14:14:10 <lisppaste2> LoganCapaldo annotated #33570 with "Try this on for size" at http://paste.lisp.org/display/33570#4
14:14:35 <mgsloan> Well, for example, I prefer tabwidths of 4 - the tab key is converted to 4 spaces.  If I load your file, all the spacing will be messed up
14:14:41 <monochrom> But 33570#4 loads fine on my ghci.  What error?  There is no error.
14:14:47 <monochrom> err I mean 33570#3.
14:14:55 <ph8> presumably my tabs will just be 4 instead of 8 long?
14:14:57 <LoganCapaldo> gah that came out ugly when I apsted it
14:14:58 <monochrom> OK. 33570#3 loads fine on my ghci.  What error?  There is no error.
14:15:02 <ph8> or are editors not that clever?
14:15:12 <mgsloan> Most editors aren't smart enough to separate what the tab key does and what the tab char means
14:15:22 <monochrom> I think Haskell 98 specifies tab=8.
14:15:28 <mgsloan> it does
14:15:29 <ph8> still
14:15:32 <ph8> my tabs are 8
14:15:36 <ph8> so wtf won't this work? :/
14:15:41 <monochrom> Still, 33570#3 works for me!
14:15:48 <ph8> oh piss :p
14:15:48 <sorear> Hopefully, I will never meet the person who thought adding :set ts= to vi.
14:15:56 <dmhouse> I like tabs for languages with simple indentation like PHP and C. When I write Haskell, though, I like to use all kinds of complicated indentation levels that aren't nice multiples of tab values, so I find spaces make my code more concise.
14:16:00 <dmhouse> I still like the idea of tabs, though.
14:16:02 <mgsloan> this is probably why people don't use tabs - just use spaces, tends to remove such complications
14:16:07 <ph8> aha
14:16:08 <sorear> s/\.$/ would be a good idea./
14:16:09 <ph8> works in ghc
14:16:10 <ph8> not in hugs
14:16:12 <ph8> laaame
14:16:14 <kpreid> ph8: bad interaction with the prefixes of literal mode?
14:16:19 <kpreid> er, literate
14:16:26 <metaperl> dmhouse - how do I read line 6 of this paste? http://rafb.net/p/gC5obF29.html  ... State run'' = action a   ... the word "State" in front of run'' confuses me... if it weren't there we would be definiing a local function
14:16:28 <geckosenator> i dont like tabs ever
14:16:31 <dmhouse> It means that someone who likes 4 spaces between indentation levels and someone who prefers 8 can both have their way.
14:16:43 <ph8> ?type printLN
14:16:43 <geckosenator> what about the people who use combinations of tabs and spaces?
14:16:44 <ph8> ?type printLn
14:16:44 <lambdabot> Not in scope: `printLN'
14:16:45 <lambdabot> Not in scope: `printLn'
14:16:55 <sorear> ph8: print emits a newline
14:16:56 <ph8> is there a println function? or do i have to do print "...\n"?
14:16:57 <dmhouse> geckosenator: that's just wrong.
14:16:59 <ph8> oh good
14:17:00 <monochrom> 33570#3 works in both ghci and hugs for me.
14:17:02 <geckosenator> so to indent 8 spaces, they use 1 tab 3 spaces, to indent 16, they use 3 tabs 1 space
14:17:03 <ph8> is there a print that doesn't emit a newline?
14:17:05 <dmhouse> sorear: print = putStrLn . print
14:17:09 <ph8> e.g. for when requesting input?
14:17:12 <dmhouse> err, putStrLn . show
14:17:17 <dmhouse> ph8: sure, putStr . show
14:17:21 <ph8> danke schon
14:17:28 <dmhouse> But I think you just want putStr.
14:17:29 <sorear> print is mostly for debugging
14:17:40 <dmhouse> If you want to output a string, use putStr and putStrLn.
14:17:44 <emu> tabs       are       evil
14:17:48 <dmhouse> If you want to output a number or something like that, use print.
14:17:58 <dmhouse> geckosenator: that's just wrong.
14:17:59 <geckosenator> that's the gnu style, indent by 2 spaces, but using tabs if possible to make it work
14:18:04 <sorear> emu: control characters are evil
14:18:08 <geckosenator> dmhouse: it saves memory
14:18:27 <geckosenator> also compiles faster
14:18:29 <metaperl> could someone explain what line 6 of this past means please - http://rafb.net/p/gC5obF29.html
14:18:31 <lambdabot> Title: Nopaste - No description
14:18:31 <dmhouse> geckosenator: oh, wow. How useful.
14:18:35 <dmhouse> metaperl: I'm getting there, sorry.
14:19:07 <dmhouse> metaperl: remember that the thing on the right of the >>= has type a -> State b? I.e. it returns a State value.
14:19:19 <metaperl> yes
14:19:22 * sorear fantasizes hacking linux to support swapping to a compressed ramdisk (saves a LOT MORE ram)
14:19:29 <daniel_larsson> bytes are expensive, tabify your code today!
14:19:30 <ph8> i'm confused about this other function - I have a processFile function, that was of type FilePath -> IO () - since it had no output, now i want it to return a Map [String] [String] - but i can't just change IO () to Map [String] [String] - the question is, why not?
14:19:34 <dmhouse> metaperl: so we pattern match to remove the State constructor. run'' refers to the function inside the State.
14:19:43 <metaperl> oh!!!!!
14:19:52 <monochrom> IO (Map [String] [String]) ?
14:20:12 <dmhouse> ph8: the 'IO' bit indicates that it might do IO.
14:20:26 <dmhouse> ph8: if you have a function that does IO, it _has_ to have a type that ends IO t, for some t.
14:20:34 <sorear> I'd like to add a compression filter between my L2 cache and main memory.  (How hard is it to do realtime LZ77 in hardware?)
14:20:38 <dmhouse> ph8: if you want it to return that map, you give it a type like monochrom said.
14:20:55 <geckosenator> sorear: nice idea
14:21:15 <geckosenator> sorear: you don't even need to do it in hardware
14:21:15 <waern> SyntaxNinja, ping
14:21:26 <vincenz> sorear: bad idea
14:21:38 <augustss> sorear: realtime at memory bus speed?  hard
14:21:41 <geckosenator> just use half your ram normally, and the other half compressed
14:21:57 <vincenz> plus you completetly ruin locality
14:21:57 <geckosenator> it would be slower, sure, but you could store more
14:21:58 <sorear> seriously, look at Judy - tries are FASTER on compressed data due to the cache benefits alone
14:21:59 <vincenz> which is what cache is or
14:22:18 <geckosenator> sorear: it works even better for compressing data on disk
14:22:26 <geckosenator> since the harddrive is so slow
14:22:39 <geckosenator> it's actually faster to compress data
14:23:11 <metaperl> one more question about this homebrew state monad ... http://rafb.net/p/gC5obF29.html ... ok: if we actually execute run'' st then we get (state,x) which is not a value of type State x... but the type signature requires that we return a value of type State x. In other words we need to produce (\state -> (state, x)) but instead we are simply returning (state,x)
14:23:11 <lambdabot> Title: Nopaste - No description
14:23:20 <geckosenator> sorear: i also want to use video memory for swap space
14:23:39 <mgsloan> sorear - that is a cool idea.  I bet you could figure out some compression algorithms with particularly good hardware implementations
14:23:54 <geckosenator> you could use texture compression on a video card
14:24:12 <mgsloan> I want to use a gmail account as swap space :)
14:24:24 <sorear> Once upon a time, there was a regex in Plugin/Url.hs which prevented the url plugin from reacting to anythig from rafb.net.  I wonder what happened to it.
14:25:04 <mgsloan> maybe when we went to lisppaste it got removed
14:25:38 <sorear> geckosenator: I've seen the extension-registry descriptions for texture compression - it's random-access JPEG, which is easy because JPEG works on 8x8 blocks with almost no inter-block compression.
14:25:59 <sorear> (and the DCT is extremely parallelizable)
14:26:24 <geckosenator> sorear: so if I used video memory for swap space, texture compression would get me 6x more memory with no speed decrease
14:26:43 <geckosenator> so if I have 256 megs of video memory, I would have 1.5 gigs of high-speed swap
14:26:52 <mgsloan> I wonder what DXTC is like (directx texture compression)
14:26:59 <geckosenator> it's similar
14:27:00 <monochrom> metaperl: you are returning (State run').  Does that help?
14:27:09 <mgsloan> texture compression is lossy though
14:27:18 <sorear> I thought directx was a library?
14:27:19 <geckosenator> mgsloan: oh, good point, nevermind
14:27:40 <mgsloan> sorear - yeah, but hardware optimizes to it, i think
14:27:53 <geckosenator> i'm sure I could get a lossless algorithm also
14:27:59 <dmhouse> metaperl: run' does indeed return a value of (state, x), so run' :: state -> (state, x). You then return State run'.
14:28:04 <mgsloan> likely so.
14:28:11 <dmhouse> metaperl: i.e., look at line 3.
14:28:18 <goltrpoat> anyone know of a decent introduction to futamura projections?
14:29:09 * mgsloan imagines projecting futurama onto a largescreen
14:30:08 <sorear> I don't know how true it is anymore, but the AGP bus used to be slow enough that video RAM was much slower to access than motherboard RAM.
14:30:09 <metaperl> dmhouse - that's a very good explanation. Thank you very much.
14:30:34 <AStorm> *much faster rather
14:30:49 <goltrpoat> sorear:  still the case
14:32:36 <mgsloan> sorear - and keep in mind PCI-E
14:32:44 <ph8> >		searchString <- getLine
14:32:44 <ph8> >		print "SS = " ++ searchString
14:32:46 <ph8> >		searchString <- getLine
14:32:46 <ph8> >		print "SS = " ++ searchString
14:32:52 <ph8> >		searchString <- getLine
14:32:52 <ph8> >		print "SS = " ++ searchString
14:32:56 <ph8> >		searchString <- getLine
14:32:56 <ph8> >		print "SS = " ++ searchString
14:33:01 <monochrom> can't reuse variable names.
14:33:02 <ph8> oh shit
14:33:05 <ph8> sorry about that
14:33:11 <ph8> i was scrolled up the screen, didn't think it was pasting
14:33:36 <ph8> but doesn't that, prompt the user for input, write it to searchString and then print the inputted value?
14:33:52 <ph8> or even prompt when it comes to printing because of laziness?
14:34:04 <goltrpoat> ah.  found futamura's paper.  http://citeseer.ist.psu.edu/futamura99partial.html if anyone cares.
14:34:06 <lambdabot> Title: Partial Evaluation of Computation Process - An Approach to a Compiler-Compiler - ...
14:34:07 <sorear> print "SS = " ++ searchString   is parsed as (print "SS = ") ++ searchString
14:34:08 <mgsloan> assuming it is within do notation
14:34:24 <monochrom> what sorear says
14:34:28 <sorear> mgsloan: apposition has higher precedence than concatenation
14:34:35 <ph8> ahh
14:34:42 <sorear> s/mgsloan/ph8/
14:34:43 <mgsloan> that too
14:34:45 <augustss> ph8: also, there is no prompting.  it will just read a line
14:34:46 <mgsloan> oh
14:34:52 <ph8> that got it sorear cheers
14:35:01 <ph8> augustss: it'll wait with a cursor or something though right?
14:35:07 <ph8> or do i need to pass it in on stdin?
14:35:11 <ph8> and if so, is there a way to prompt? ;)
14:35:15 <monochrom> getLine is just fine.
14:35:16 <augustss> yes, it will wait
14:35:21 <ph8> yeh it waits
14:35:21 <ph8> goodo
14:35:23 <sorear> putStr "foo? " ; hFlush stdout
14:35:26 <mgsloan> print $ fmap ("SS = "++) getLine
14:35:27 <mgsloan> :)
14:35:34 <ph8> print prints my quotation marks?
14:35:48 <monochrom> use putStrLn
14:35:48 <augustss> yes, you want putStrLn
14:35:49 <ph8> that's weird?
14:36:00 <ph8> you guys are great :)
14:36:00 <augustss> no, it not weird
14:36:00 <nmessenger> print = putStrLn . show
14:36:05 <ph8> channel++
14:36:09 <monochrom> It is normal.  You will eventually know why it is correct.
14:36:13 <sorear> print x = putStrLn ("\"" ++ x ++ "\"")  -- roughly, for strings
14:36:14 <nmessenger> ?karma channel
14:36:14 <lambdabot> channel has a karma of 1
14:36:41 <nmessenger> #haskell++
14:36:47 <nmessenger> ?karma #haskell
14:36:48 <lambdabot> #haskell has a karma of 2
14:37:00 <nmessenger> why isn't it higher?
14:37:15 <sorear> ph8: don't forget 'IO.hFlush IO.stdout' after prompting, haskell does linebuffering just like C
14:37:16 <nmessenger> everyone karma-bomb #haskell!
14:37:30 <augustss> ?karma karma
14:37:31 <lambdabot> karma has a karma of 1
14:37:37 <geckosenator> ?karam karma
14:37:38 <lambdabot> Maybe you meant: karma karma+ karma-
14:37:44 <sorear> nmess: I don't think '#haskell++' was legal before yesterday
14:37:44 <geckosenator> crap
14:37:45 <iulus> ?karma lambdabot
14:37:46 <lambdabot> lambdabot has a karma of 42
14:37:51 <nmessenger> 42!
14:37:55 <geckosenator> ?karma karma-
14:37:55 <iulus> don't want to change that!
14:37:56 <lambdabot> karma- has a karma of 0
14:37:59 <geckosenator> ?karma karma-
14:37:59 <geckosenator> ?karma karma-
14:37:59 <geckosenator> ?karma karma-
14:37:59 <lambdabot> karma- has a karma of 0
14:37:59 <lambdabot> karma- has a karma of 0
14:38:00 <lambdabot> karma- has a karma of 0
14:38:04 <geckosenator> it can't go negative?
14:38:13 <sorear> karma--
14:38:13 <nmessenger> karma--
14:40:26 <sorear> karma---
14:40:26 <sorear> ?karma karma-
14:40:26 <lambdabot> karma- has a karma of -1
14:40:26 <monochrom> Ahem!
14:40:26 <sorear> ?karma java
14:40:26 <lambdabot> java has a karma of -15
14:40:26 <nmessenger> yes monochrom?
14:40:26 <geckosenator> ?karma karma-
14:40:26 <lambdabot> karma- has a karma of -1
14:40:26 <bacek> java--
14:40:26 <monochrom> too much scrolling
14:43:38 <geckosenator> i must not be allowed to do it
14:43:38 <nmessenger> right, EVERYONE SHUT UP NOW PLZ
14:43:38 <augustss> because?
14:43:38 <sorear> geckosenator: ?karma is pure
14:43:38 <mgsloan> geckosenator: that looks up the karma, doesn't set it
14:43:38 <geckosenator> how do I set it?
14:43:38 <iulus> monochrom: I had a question I forgot to ask... if you'd use x <- 5 as assignment, what would you use as declaration for an imperative language? (assuming you can declare a variable with a type)
14:43:38 <sorear> ?karma- karma
14:43:38 <lambdabot> karma's karma lowered to -2.
14:43:38 <iulus> any ideas?
14:43:38 <mgsloan> karma---
14:43:38 <geckosenator> ?karma geckosenator
14:43:38 <lambdabot> You have a karma of 0
14:43:38 <mgsloan> ?karma karma-
14:43:38 <lambdabot> karma- has a karma of -2
14:43:38 <geckosenator> ?karma+ geckosenator
14:43:38 <lambdabot> You can't change your own karma, silly.
14:43:38 <nmessenger> LB made fun of you! Hah Hah
14:43:38 <sorear> x <- 5  -- only works in (Num a, Monad a) {- no standard common instances -}
14:43:38 <monochrom> No declaration syntax.  Actually "x<-5" won't work either.
14:43:38 <geckosenator> give me good karma plz
14:43:38 <nmessenger> give ppl good advice plz
14:43:38 <augustss> geckosenator: do something nice and you will be rewarded
14:43:38 <nmessenger> :P
14:43:38 <sorear> ?karma geckosen1tor
14:43:38 <lambdabot> geckosen1tor has a karma of 0
14:43:38 <sorear> ?karma geckosenator
14:43:38 <lambdabot> geckosenator has a karma of 0
14:43:38 <sorear> ?karma geckos1nator
14:43:38 <lambdabot> geckos1nator has a karma of 0
14:43:38 * monochrom is now really annoyed.
14:43:38 <geckosenator> nice try
14:43:38 * nmessenger backs away from monochrom
14:43:38 <iulus> that's true
14:43:38 <iulus> I don't so much like that idea anymore, then.
14:43:38 <geckosenator> monochrom: is your display monochrom?
14:43:38 <nmessenger> s/?/e?/
14:43:38 * sorear marvels at the economies of scale that have made (essentially useless) color support commonplace
14:43:38 <monochrom> "x<-blah" is unlike assignment: it does not make x a mutable variable.  It just introduces the name x to the answer of blah so you can refer to it later.
14:43:38 <monochrom> There is a mutable variable mechanism available in Data.IORef.
14:43:57 <iulus> I know, but somebody, I thought it was you but it must not have been, mentioned earlier that if they made an imperative language, they'd use <- as assignment.
14:44:25 <monochrom> Knuth certainly does.
14:44:42 <monochrom> I grew up with Pascal and like :=
14:45:13 <LoganCapaldo> What about setf? ;)
14:45:26 <monochrom> Different communities will happen to pick the same symbol for different uses.  It is sad but we have to live with it.
14:45:27 <sorear> emacs uses setq
14:45:35 <nmessenger> Blah blah parens blah blah.
14:45:43 <Excedrin> *ML uses := also
14:45:46 <monochrom> The other day someone thought that Haskell's "join" meant the same as Perl's "join".
14:46:01 <goltrpoat> sorear:  wouldn't x <- 5 require Num (m a), not Num a?
14:46:10 <goltrpoat> oh, misread what you typed
14:46:17 * sorear has completely forgotten what perl's join was
14:46:30 <LoganCapaldo> I almost feel like the right set of parameter you could make join behave like join
14:46:32 <Excedrin> Perl's join is like concatWith
14:46:36 <nmessenger> (concat .) . intersperse
14:47:09 <sorear> goltrpoat: no, Num (a b), you're right that I was wrong
14:47:13 <monochrom> perl_join "..." ["hello", "kitty", "girl"] = "hello...kitty...girl"
14:47:39 <sorear> Haskell's join \subset perl_join ""
14:48:27 <augustss> nmessenger: (join .) . intersperse   :)
14:48:47 <nmessenger> ah, []'s join is concat, I can never remember
14:48:54 <goltrpoat> ok, i was trying to remember which language had ::= for assignment, ended up on the algol68 page on wikipedia, and it has a section for "monadic operators"
14:49:11 <LoganCapaldo> bnf?
14:49:18 <augustss> different use of "mandic"
14:49:22 <augustss> "monadic"
14:49:25 <monochrom> That "monadic" means "mono adic" means "one operand"
14:49:26 <goltrpoat> yeah, i think they just mean unary
14:49:27 <LoganCapaldo> not that that's really assignmnent
14:49:31 <goltrpoat> -nod-
14:50:10 * nmessenger wonders what a 'Diad' is.
14:50:13 <monochrom> Now some of you shall generalize our Monad to Dyad just so as to confuse more people.
14:50:14 <mgsloan> yeah, i saw a little thing on propositional logic that said that ~ was monadic and I was like 0_0
14:50:20 <goltrpoat> hah
14:50:59 * sorear loves the name 'zen-ary operator'
14:51:03 <iulus> monadic? Doesn't that refer to the new Windows Power Shell?
14:51:04 <goltrpoat> wonder if you can come up with a category on propositions where ~ is in fact monadic
14:51:10 <nmessenger> blech!
14:51:13 <monochrom> Haha zen-ary is great
14:51:26 <goltrpoat> sorear:  there is no argument?
14:51:37 <sorear> yes
14:51:52 <sorear> (or is that 'True' here?)
14:51:52 <augustss> goltrpoat: ~a is a->Absurd, after all
14:52:02 <monochrom> ~ is certainly a functor.  maybe contravariant functor.  ok it needs work.
14:52:06 <LoganCapaldo> if a function takes an argument but no one ever calls it, does it have an arity?
14:52:20 <monochrom> hahahah
14:52:26 <goltrpoat> haha
14:52:28 <nmessenger> LoganCapaldo: duh
14:53:29 <nmessenger> uncalled function Are People Too
14:53:52 <LoganCapaldo> I guess in Haskell a better question is if a function takes an argument but never evaluates it, does the function make a sound? Or something.
14:53:53 <monochrom> what genders do they have?   *duck*
14:54:08 <nmessenger> I've not heard of the 'duck' gender.
14:54:15 * LoganCapaldo is glad he switched from grenades to landmines
14:54:18 <monochrom> hahaha
14:54:23 * sorear throws a heat-seeking dictionary
14:54:27 <goltrpoat> ~ is self-adjoint as an endofunctor, so i suspect nothing interesting will come out of this
14:54:34 * nmessenger runs wildly
14:54:47 <alexj__> anyone know if you can put hlist items in Data.Map or Data.Set ?
14:54:59 <sorear> ghci?
14:55:08 <LoganCapaldo> Haskell might know
14:55:12 <sorear> not a 'one', but most likely to know
14:55:15 <mgsloan> perhaps the duck gender is related to the duck typing of dynamic languages - its whatever you want it to be (baby)
14:55:38 <alexj__> Haskell might know?
14:55:46 <mgsloan> hmm stick quotes around the bit after the -
14:55:52 <sorear> alexj: as in, try it an see
14:55:54 <nmessenger> so if it has the right kinda interface, you can use it?
14:55:56 <sorear> alexj: as in, try it and see
14:55:57 <monochrom> ~ cannot be a monad because join :: ~~a -> ~a and return :: a -> ~a make no sense.
14:56:11 <mgsloan> nmessenger: yep
14:56:29 <augustss> monochrom: they are a little hard to make sense of :)
14:56:29 <LoganCapaldo> wait
14:56:35 <nmessenger> sounds........... unpredictable
14:56:38 <alexj__> sorear: I think hlist items have different types and so you mayneed to use existentials or something.
14:56:43 <LoganCapaldo> Can't ~ be an instance of ((->) e)?
14:56:58 <Lemmih> alexj__: You can but you might find it a bit limitating.
14:57:10 <alexj__> why limiting?
14:57:12 <mgsloan> nmessenger: that's what the duck gender is all about
14:57:58 * sorear would like to point out that all IRC actions are parametricly polymorphic in gender
14:58:10 <alexj__> how do people who use hlist do collections?
14:58:21 <nmessenger> sorear: trivially, maybe.
14:58:33 <augustss> alexj__: do people use hlists?
14:58:40 <sorear> they buy stuff and put it on shelves? :)
14:58:48 <Philippa_> sorear: some, however, have constraints. I take it you've never asked someone out over IRC?
14:59:26 <monochrom> hlist itself doesn't need existential.  there may be certains operations over hlists needing existential.
14:59:40 <mgsloan> hot lambda secks
14:59:52 <alexj__> augustss: good question.  they look really useful based on the hlist paper, but perhaps the problem is that they are actually hard to use
15:00:13 <nmessenger> If secks are the plural, what exactly is a seck?
15:00:17 <alexj__> monochrom: can you explain what you mean?
15:00:18 <Heffalump> and really ugly
15:00:20 <dons> ?yow
15:00:21 <lambdabot> YOU PICKED KARL MALDEN'S NOSE!!
15:00:58 <Philippa_> I suspect most of the best uses of HList're somewhat concealable
15:01:08 <augustss> alexj__: they have their uses, I think.  but usually there are other ways to solve the same problems that are simpler, I think
15:01:45 <alexj__> my applications are: generating xml and binary serialization
15:01:47 <sorear> I suspect the problem with HList is that you need to be Oleg to figure out you've reinvented them.
15:02:29 <Philippa_> nope. I had a clear case when I realised I was trying to do something I should've used HList for
15:02:32 <monochrom> I cannot explain what I mean.
15:02:40 <Philippa_> then I found out Oleg had code to do the thing I was trying to do :-)
15:02:55 <Lemmih> People seem to forget that HLists are just tuples.
15:03:12 <augustss> yes
15:03:51 <geckosenator> they are pairs?
15:04:03 <augustss> nested pairs
15:05:00 <mgsloan> that's what I thought multi-tuples were, eg (3,"hello","world") = (3,("hello","world"))
15:05:07 <LoganCapaldo> So f that's the case why would you ever use HLists over a tuple?
15:05:18 <augustss> mgsloan: no those are different
15:05:20 <alexj__> labels.
15:05:40 <Philippa_> polymorphism, too
15:05:46 <mgsloan> yeah, i know.  to me keeping tuples as 2 makes more sense though
15:05:52 <LoganCapaldo> stickers?
15:05:53 <sorear> agreed.
15:05:54 <Philippa_> "I want to fix the head of the list and leave the rest unspecified", for example
15:06:33 <LoganCapaldo> type FixedHead a = (Int, a) ??
15:06:37 <Lemmih> LoganCapaldo: You can't write general functions on tuples.
15:06:40 <mgsloan> has a nice paralel to ->, and allows addressing any elem with bunches of fst and a snd
15:06:46 <sorear> agreed.
15:06:46 <Philippa_> also, you might want to use an HList because it's better than having to rewrite all the typeclass hackery yourself
15:07:11 <LoganCapaldo> So IOW, they are not _just_ tuples?
15:07:13 <Cale> mgsloan: the difference is that representing tuples as nested pairs means that you have to use more indirection to get to later elements.
15:07:13 <augustss> Lemmih: but you can write general functions on nested pairs and ()
15:07:42 <sorear> IMO haskell2 shouldn't have tuples, only watered-down HLists optionally with syntax sugar.
15:07:47 <mgsloan> sure, but accessing elements in general already sucks
15:08:03 <mgsloan> sounds good to me
15:08:04 <Lemmih> augustss: True.
15:08:10 <sorear> Cale: that is a Small Matter of Compile Time Optimization
15:08:24 <Cale> Well, not just that
15:08:29 <mgsloan> (perhaps i misinterpreted indirection)
15:08:40 <sorear> i.e. data structure inlining
15:09:01 <Cale> (1,undefined) is different from (1,(undefined,undefined))
15:10:05 <Philippa_> sorear: I hope when you say that you have specific optimisations in mind
15:10:05 <sorear> data HCons a b = HCons a !b ; data HNil = HNil
15:10:21 <mgsloan> uhh, ok?
15:10:44 <mgsloan> Philippa_ - likely using the traditional tuple stuff
15:11:07 <LoganCapaldo> Cale: Shouldn't that example be (1,undefined, undefined) is different from (1, (undefined, undefined)) ?
15:11:26 <sorear> HCons 1 undefined   <==>   HCons 1 (HCons undefined undefined)
15:11:28 <Philippa_> mgsloan: "the traditional tuple stuff" has additional constraints to take advantage of
15:11:30 <Cale> LoganCapaldo: we're talking about representing triples as nested pairs
15:11:45 <LoganCapaldo> ok
15:11:55 <Philippa_> I'm not saying it's impossible, I'm just saying it's non-trivial and likely to make simple implementations horribly slow
15:12:08 <LoganCapaldo> But (1, undefined) != (1, (undefined, undefined)) is "duh" isn't it?
15:12:27 <mgsloan> Philippa_: such is the haskell way :)
15:12:42 <Cale> LoganCapaldo: not necessarily.
15:12:49 <Philippa_> mgsloan: not to that extent, it's not
15:12:54 <sorear> I'm additionally talking 'wouldn't it be nice if' -- data inlining regains the efficiency of evil n-tuples, and makes many other things (lazy lists anyone?) more efficient too.
15:12:56 <Philippa_> at least, not historically
15:13:08 <alexj__> ok.  I am starting to look at the hlist lib and it seems like it is not factored in a way that is useful for distribution.  e.g. FakePrelude is a module name.
15:13:19 <alexj__> anyone know where an hlist package resides?
15:13:42 <Philippa_> sorear: and also affects every function the data might pass through
15:13:52 <augustss> alexj__: last i looked at HList it was horribly factored.  if you find a good one, tell me :)
15:14:26 * monochrom grins evilly and sends you to dons
15:14:39 <mgsloan> how about we do binary tree tuples :) (0, 1, "hello", "goodbye") -> ((0,1),("hello","goodbye"))
15:15:00 <augustss> mgsloan: no, we don't want to
15:15:13 <mgsloan> yeah, mostly kidding with that one
15:15:15 <Philippa_> mgsloan: you know where lisp is if you want it
15:15:37 <mgsloan> not suggesting as a syntax, internal stuff rather
15:16:01 <augustss> mgsloan: nested pairs have all these extra elements in the domain that implies extra indirections (or very hairy optimizations)
15:16:02 <mgsloan> syntax would still look like ordinary tuples, but fst . snd would return 1 in that case
15:16:19 <sorear> 'HHC - the #haskell haskell compiler.  Does everything Right *and* Wrong.'
15:18:28 <goltrpoat> so is the point that (a,b,c) = (,,) a b c = (apply (apply (apply (,,) a) b) c), and (a,(b,c)) = (,) a ((,) b c) = (apply (apply (,) a) (apply (apply (,) b) c)), and there are more indirection nodes in the latter?
15:20:18 <goltrpoat> oh i guess it changes the semantics too
15:20:22 <augustss> goltrpoat: the point is that the type (a,(b,c)) has an element (A,_|_) which has to have a representation
15:20:29 <goltrpoat> -nod-
15:20:57 <augustss> The type (a,b,c) doesn't have this element.  So it can be represented with 3 pointers
15:21:26 <mgsloan> heh, bottom seems to mess a lot of things up
15:21:34 <goltrpoat> yeah, i hit enter and then what cale said earlier suddenly clicked
15:21:36 <goltrpoat> heh
15:21:36 <augustss> Whereas (a,(b,c)) needs 2 pointers, the second pointing to 2 pointers (in the evaluated case)
15:21:57 <augustss> unless you do some very clever flattening
15:22:10 <Philippa_> or have strict tuples
15:22:15 <augustss> yes
15:22:23 <goltrpoat> and semantics change either way
15:22:23 <Philippa_> (including fst-strict and snd-strict variants)
15:22:42 * sorear is advocating clever flattening
15:22:55 <augustss> sorear: go ahead and implement it :)
15:22:56 * sorear is running advocacy and designing in parallel
15:23:22 <sorear> the latter is, unfortunately, not making much progess.
15:23:27 <mgsloan> well, (->) has to handle this stuff in some clever ways
15:24:14 <mgsloan> eg, technically a -> b -> c -> d has lots of indirection and such
15:24:36 <vincenz> that is the cost of currying
15:25:08 <Philippa_> that's got a fairly straightforward implementation available for the most part though
15:25:09 <mgsloan> which is a quite related concept to the nested tuple thing
15:25:52 <Philippa_> because you're lazy anyway, just box up the parms 'til you're fully applied and have to do something
15:26:21 <xerox> There's a natural isomorphism between (a,(b,c)) and (a,b,c).
15:26:36 <vincenz> xerox: no
15:26:42 <vincenz> xerox: you're forgetting extra _|_
15:26:54 <vincenz> (a,(_|_, c))
15:27:01 <sorear> I read "how to make a fast curry" and realized that all SPJ had done was reinvent typeclasses.  too bad the details are on a retired HD.
15:27:17 <mgsloan> just like 0 in math, _|_ seems to fudge elegance up
15:27:37 <vincenz> mgsloan: read denotational semantics of haskell on wikibook
15:27:39 <LoganCapaldo> (a, (bottomity, c))
15:27:43 * sorear wonders how fast a strict pure language could be made ... best of Haskell + ML
15:27:45 <vincenz> it explains quite succintly why you want bottoms
15:27:58 <mgsloan> hehe, i certainly want bottoms
15:28:00 <sorear> (best = from an implementation standpoint)
15:28:18 <mgsloan> i actually already read it
15:28:29 <alexj__> @seen shapr
15:28:30 <lambdabot> shapr is in #haskell-blah, #unicycling, #scannedinavian and #haskell. I last heard shapr speak 3h 12m 13s ago.
15:29:26 <alexj__> shapr: you around?
15:30:25 <dcoutts__> sorear: there are some problems for which there exist solutions in a pure lazy language that are asymptotically faster than the best possible solution in a pure strict language
15:30:37 <dcoutts__> in other words, lazyness really does give you more
15:31:12 <dcoutts__> in a strict language you'd have to use mutable state to achive the same asymptotic bounds
15:31:20 <mgsloan> I actually think you should be able to pattern match _|_ - the compiler could detect nontermination (common cases at least).  True sometimes you want this, which is why you could have a special nonTermination function...
15:31:21 <goltrpoat> i remember reading that, but couldn't come up with an example
15:31:29 <sorear> I'd like to have the _option_ of laziness (read: unsafePerformIO), but not make laziness idiomatic.
15:32:20 <dcoutts__> mgsloan: that's not something you can give sensible semantics to, it's closely related to the halting problem
15:32:21 <mgsloan> well, the compiler could do some nontermination analysis.  Mostly runtime is what would actually pattern match though
15:32:37 <monochrom> 0 and _|_ give elegance to math.
15:32:40 <mgsloan> yes.  That's why it'd be kinda a fuzzy feature - do as best as you can
15:32:57 <dcoutts__> you'd only be able to specify that it might match _|_ but not be able to say much at all about when it does match and when it doesn't
15:33:17 * dcoutts__ thinks it would not be nice or useful
15:33:22 <Philippa_> mgsloan: *snigger* - the compiler generally wants a lot of help with non-termination analysis
15:33:40 <monochrom> _|_ is a reality in both lazy and eager programming.
15:33:45 <sorear> we already have unsafePointerEq, how about unsafeBottomP?
15:33:50 <Excedrin> sorear: Alice ML is basically that, except it's impure
15:34:10 <bd_> sorear: Can't you detect bottoms caused by undefined or error by going through unsafePerformIO and catchIO?
15:34:18 <xpika> since haskell's quite a mathematical language how long do you think it will be until they change NaN to nullity?
15:34:30 <mgsloan> xpika - never
15:34:33 <Excedrin> hahaha
15:34:44 <xpika> > 0/0
15:34:45 <lambdabot>  NaN
15:34:48 <iulus> isn't NaN some sort of standard that needs to be followed?
15:34:49 <monochrom> What bd_ says.
15:34:53 <bd_> xpika: You can write a typeclass instance of a NullityMath functor :)
15:35:04 <sorear> bd_: yes you can, but a lot of newbies are excessively afraid of unsafePerformIO
15:35:19 <monochrom> Yes NaN is from the IEEE 754 standard and needs to be followed.  For example sqrt(-1) :: Double should be NaN.
15:35:19 <mgsloan> http://cale.yi.org/index.php/Open_letter_to_James_Anderson
15:35:20 <bd_> that could be seen as a good thing ;)
15:35:23 <lambdabot> Title: Open letter to James Anderson - CaleWiki
15:35:57 <monochrom> Naked unsafePerformIO is to be avoided, newbie or not.  But packaged up applications such as trace and unsafeBottomP are ok.
15:36:02 <Philippa_> sorear: sure you're not excessively careless with it? It's not something a non-library coder should have to use
15:36:02 <mgsloan> James Anderson = nullity guy
15:36:37 <wchogg> I think the open letter is amazingly nice and generous to the man.
15:36:48 <mgsloan> yep
15:36:56 <sorear> Philippa_: people shouldn't be afraid to write libraries.
15:37:09 <monochrom> No one is afraid.
15:37:32 <monochrom> The real issue is discretion and taste.
15:37:39 <Philippa_> sorear: you talk as if all libraries need unsafePerformIO
15:37:54 <Philippa_> I think /everyone/ should take due care in trying to make libraries perform
15:38:05 <Philippa_> that doesn't mean being afraid, it does mean making sure you know what you're doing
15:38:15 <mgsloan> i think everyone should design libs with the user in mind
15:38:30 <monochrom> I have a cutter, a knife, in my drawer.
15:38:37 <mgsloan> this goes for most things you design, actually.
15:38:44 <monochrom> It's blade is retracted by default, not exposed.
15:38:57 <monochrom> Does it mean I am afraid of the blade?
15:39:02 <monochrom> HAW HAW HAW HAW HAW
15:39:27 <Philippa_> right, and that'll only cut you. unsafePerformIO warps reality :-)
15:39:40 <goltrpoat> i think libraries should be designed in such a way as to enable the author to arrange the program text into images of cutesy woodland creatures.
15:40:05 <mgsloan> I'm working on it
15:40:16 <xerox> monochrom - http://www.angryflower.com/itsits.gif
15:40:20 <Excedrin> goltrpoat: Perl's ACME?
15:40:22 <wy> Why is return defined as  return = Just for Maybe types?
15:40:28 <mgsloan> oh the text? nah, I just use pictures of woodland creatures outright
15:40:32 <monochrom> Because it makes sense
15:40:46 <wy> What do we do with Nothing then?
15:40:47 <sorear> Nothing is type-incorrect
15:40:48 <monochrom> xerox: hehehe
15:40:49 <goltrpoat> excedrin:  not familiar
15:40:55 <sorear> fail = const Nothing
15:41:00 <monochrom> Nothing is mzero
15:41:22 <Excedrin> goltrpoat: http://search.cpan.org/~asavige/Acme-EyeDrops-1.51/lib/Acme/EyeDrops.pm
15:41:28 <lambdabot> Title: Acme::EyeDrops - Visual Programming in Perl - search.cpan.org, http://tinyurl.com/z5y6n
15:41:29 <wy> So "return" always means something useful?
15:41:34 <dmhouse> What precisely are the dangers of using unsafePerformIO? Apart from the esoteric examples where it causes type unsafety.
15:41:38 <monochrom> If you calculate the monad laws, it will make a lot of sense.
15:41:42 <goltrpoat> haha
15:41:43 <goltrpoat> excellent.
15:41:55 <Philippa_> wy: yes, assuming a useful monad
15:41:58 <monochrom> (I don't believe in intuition before calculation.  I believe in intuition after calculation.)
15:42:14 <wy> Is there a way to enforce or check the monad laws?
15:42:15 <Philippa_> the "undefined" monad (all ops = _|_) may not be overly useful to you
15:44:03 <monochrom> Sometimes the expected number of invocations of unsafePerformIO code differs from the eventual number of invocations.
15:44:08 <dmhouse> For example, inside my HAppS application (where doing IO is a pain), I want to call a shell script that does a Markdown -> HTML conversion.
15:44:25 <vincenz> sorear: how is the "making a fast curry" paper a reinvention of TCs?
15:44:26 <dmhouse> This is, in essence, a pure function, so could I use unsafePerformIO to call the shell script?
15:44:54 <monochrom> Sometimes the unsafePerformIO code changes strictness unexpectedly.
15:45:02 <xerox> Yeah.  Catch the errors, and also I think you can transform them in pure error handling for extra safety.
15:45:28 <xerox> (I.e. {Maybe,Either} type.)
15:45:47 <xerox> Another solution is write that as a pure function of course.
15:45:49 <monochrom> The FFI encourages PRUDENT uses of unsafePerformIO.
15:46:02 <dmhouse> monochrom: well, would there be a better solution in this instance?
15:46:16 <dmhouse> Assuming I'm not willing to jump through the hoops it takes to get HAppS to do my IO.
15:46:46 <xerox> Parsec + HXT :)
15:46:52 <augustss> sorear: I don't understand the comment about a fast curry being TC.  Type classes are about types.  the fast curry about implementation.  they are not comparable :)
15:47:10 <sorear> a -> b is a type, a -> b -> c is a type
15:47:33 <sorear> I have types of two-arg functions, three-arg functions, etc.
15:47:49 <monochrom> A worry is that too many things can go wrong on the long path of calling a shell script and getting an answer.  The shell script disappears, the shell script bombs, ...  But I guess you can throw exceptions.
15:47:55 <augustss> well, there are only one arg functions
15:47:57 <sorear> Where SPJ uses cases on function arity, I use overloaded functions
15:48:07 <vincenz> sorear: the point is that you don't know the function arity
15:48:19 <sorear> Where SPJ uses special case magic on known functions, I use ordinary specialization
15:48:20 <vincenz> a -> b and a -> (b -> c) are the sae type
15:48:23 <vincenz> unless you use overlapping instances
15:48:30 <vincenz> otherwise you have to specialize callsites
15:48:49 <vincenz> foo f = map f list
15:48:53 <vincenz> you won't know what foo is called with
15:48:58 <vincenz> unless you specialize foo by callsite
15:48:58 <sorear> In my model, (->) doesn't exist at the implementation level
15:49:35 <vincenz> sorear: hmm?
15:49:42 <vincenz> that sentence doesn't parse
15:50:30 <sorear> anyway, I'll have to recompute the details because my indirection node got trashed the last time I was forced to GC my hard drive :(
15:50:52 <xerox> G'nite.
15:51:17 <monochrom> If I call a C function "int isPrime(int)", immediately it is Int -> IO Int in Haskell.  I have to decide whether I keep it as Int -> IO Int or throw in an unsafePerformIO.  It is a pretty clear case if I know what's inside isPrime.  It's ok to choose the latter.
15:51:49 <monochrom> excuse, of course I mean CInt.
15:52:36 <ClaudiusMaximus> anyone got a simple FFI example?  or better, a tutorial on FFI for FFI newbies?  (context:  converting a C array generated by hopengl's readPixels into haskell then writing it to disk is a bottleneck in my code, when i should be able to write a C subroutine to do it without conversion)
15:52:38 <sorear> (beside the point) you can always import it as isPrime :: CInt -> CInt
15:52:44 <Cale> You don't even have to explicitly put in an unsafePerformIO in that case
15:52:48 <Cale> right
15:53:10 <dmhouse> ClaudiusMaximus: try the wiki.
15:53:13 <dmhouse> ?wiki FFI
15:53:13 <lambdabot> http://www.haskell.org/haskellwiki/FFI
15:53:15 <monochrom> Yeah.  But it's the same logic and decision.
15:53:31 <dmhouse> ?wiki Foreign Function Interface
15:53:32 <lambdabot> http://www.haskell.org/haskellwiki/Foreign Function Interface
15:53:33 <monochrom> (There is currently no text in this page)
15:53:54 <dmhouse> Huh. There's a great tutorial somewhere.
15:53:57 <monochrom> (There is currently no text in this page) again
15:54:07 <monochrom> I am learning FFI.
15:54:27 <monochrom> In fact I have just finished writing the C code for "int isPrime(int)".
15:54:32 <monochrom> Great progress, eh?
15:54:37 <alexj__> dmhouse: in the new happs api, I've made doing IO A LOT easier.  All responses are in the IO monad.
15:55:24 <alexj__> I'll try to fix the server xslt example so it does not use unsafeperformIO so you see it is easy.
15:55:42 <dmhouse> alexj__: Aha, you IRC :)
15:55:53 <monochrom> Everyone IRCs.
15:55:57 <dmhouse> alexj__: there aren't many people in the channel using HAppS, by the looks of things.
15:56:38 <alexj__> yeah I know.  Its been fairly difficult to use.  The new API should make it much much easier
15:56:39 <dmhouse> alexj__: when you say the 'new', how new? Darcs-new?
15:56:47 <alexj__> darcs new posted today.
15:56:55 <yaxu> dmhouse: was this ffi tutorial in a wiki?
15:57:07 <dmhouse> alexj__: have you got details of this API somewhere? Are the 'Current' Haddock docs up to date?
15:57:12 <dmhouse> yaxu: I thought it was, but maybe not.
15:57:37 <dmhouse> yaxu, ClaudiusMaximus: searching the wiki for 'foreign function' turns up lots of useful things. I'm sure googling for 'Haskell ffi' will help too.
15:57:44 <alexj__> docs not yet up to date, but take a look at the example server at the end of HAppS.Protocols.SimpleHTTP2
15:57:45 <monochrom> I found http://www.haskell.org/haskellwiki/FFI_cook_book
15:57:46 <lambdabot> Title: FFI cook book - HaskellWiki
15:59:27 <yaxu> ?google haskell wiki
15:59:29 <lambdabot> http://www.haskell.org/hawiki/
15:59:29 <lambdabot> Title: FrontPage - The Haskell Wiki
15:59:49 <yaxu> the message at the top of that could be a bit clearer i think
16:00:14 <monochrom> the cookbook I found is pretty advanced! :)
16:00:14 <alexj__> dmhouse: I am actually looking for some feedback on the new interface before I do a release.  please take a look and tell me what you think.
16:00:32 <dmhouse> alexj__: thanks, will do.
16:03:11 <dmhouse> alexj__: my initial response is 'What's with all the units?'
16:03:50 <alexj__> they are type constraints.
16:03:59 <alexj__> or they are wildcards.
16:04:06 <alexj__> e.g. () matches all methods.
16:04:25 <alexj__> if you want to match a particular list of methods [GET,POST].  if you want to match one method just e.g. GET.
16:04:41 <dmhouse> Why not _ for any method?
16:04:42 <alexj__> in the handler functions, use unit if you don't care about the input.
16:04:52 <alexj__> because _ doesn't have a type?
16:04:53 <Botje> how do you repeat an IO action until eof and collect the results?
16:05:27 <monochrom> perhaps just repeat, and somewhere catch exception
16:05:36 <dcoutts__> @hoogle eof
16:05:36 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
16:05:36 <lambdabot> Text.Read.EOF :: Lexeme
16:05:36 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
16:05:43 <alexj__> you can also stick a function there that takes a method and returns a boolean.
16:05:44 <dcoutts__> @hoogle iseof
16:05:45 <lambdabot> IO.isEOF :: IO Bool
16:05:45 <lambdabot> IO.isEOFError :: IOError -> Bool
16:05:45 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
16:06:12 <monochrom> but not satisfactory.
16:06:15 <alexj__> can you make _ an instance of MatchMethod?
16:07:12 <dmhouse> Oh, stupid me, we're not defining a function are we.
16:07:15 <monochrom> depending on your purpose, you may find the like of hGetContents more usable.
16:08:10 <dmhouse> alexj__: what does hOut do?
16:08:24 <Botje> myeah
16:08:33 <alexj__> hOut modifies the response produced by any handler below it on the list.
16:09:12 <alexj__> it is a wrapper around ModResp
16:09:18 <dmhouse> Okay, so the call to hOut here makes the res value monadic?
16:09:29 <alexj__> actually all res values are monadic.
16:09:36 <alexj__> see basicFileServe for an example.
16:10:00 <dancor> can i do my own magical deriving things
16:10:19 <dmhouse> dancor: no.
16:10:20 <alexj__> dmhouse: in particular see fileServe2 and that it just wraps an IO result.
16:10:35 <augustss> dancor: not within haskell.  you could check out drift
16:10:35 <dancor> like i wouldn't mind a 'deriving lcRead' for enums that was like read but lowercased the first letter
16:10:48 <dmhouse> dancor: well, only in very limited cases (where you have a newtype which basically just wraps an existing type, and even then you have to use a GHC-only extension, and there are still limitations).
16:10:49 <dancor> sometimes
16:11:19 <dmhouse> alexj__: you should put types on your functions, it makes things _way_ easier to understand.
16:12:03 <dancor> drift looks cool though i'm dissappointed to see another leeto-case opensoure project name (a la LaTeX)
16:12:14 <dancor> DrIFT
16:12:15 <alexj__> ok.  i usually just load into ghci and to :t but I can add types if that is helpful.  I don't know how to use haddock.  does it auto generate types?
16:12:25 <dmhouse> dancor: call it what you want, no-one cares/.
16:12:34 <dmhouse> alexj__: err, not that I know fo.
16:12:36 <dmhouse> *of.
16:12:48 <dmhouse> Oh, for the documentation. Maybe.
16:13:02 <Botje> argh
16:13:04 <dancor> dmhouse: that kind of thinking gave us some of the amazing names in the prelude
16:13:07 <Botje> i'll just use interact already
16:13:20 <alexj__> dmhouse: ok I'll add type information when I add docs.
16:13:35 <dmhouse> alexj__: great.
16:13:42 <augustss> alexj__: you should use haddock, it's really super easy
16:14:24 <dmhouse> alexj__: as for the interface itself, it doesn't seem particularly more concise, and looks harder to use. However, if it leads to less boilerplate and easier IO, that's thumbs up.
16:14:59 <dmhouse> I guess the reason it looks a little scary at the moment is that there's a load of stuff there that I have no idea what it does. With a suitable tutorial it'd be tamer.
16:15:12 <alexj__> ok fair enough.
16:16:06 <Botje> hmm
16:16:33 <Botje> i've got an operation to read a line and munge its contents, and I basically want to perform that operation until eof and collect the results
16:16:44 <monochrom> I love interact programming actually.
16:17:04 <psnl> interact gives me heartburn
16:17:06 <mgsloan> ugg, ghci is so limited
16:17:31 <augustss> Botje: interact (unlines . map munge . lines)
16:17:33 <dancor> mgsloan: yeah i often want it to be kwlr
16:17:55 <Botje> augustss: the operation is IO, though
16:18:12 <Cale> mgsloan: what should it do that it doesn't?
16:18:14 <monochrom> For that application I would begin with what augustss says.  Of course I am ready to give it up if you want to do more.
16:18:16 <augustss> Botje: oh, interact is no good then
16:18:21 <Botje> so maybe s/operation/action/
16:18:22 <mgsloan> Cale - data types
16:18:27 <Cale> hm?
16:18:30 <mgsloan> multiline functions
16:18:35 <mgsloan> data declerations
16:18:37 <monochrom> What operation?  Not just output to stdin?
16:18:45 <mgsloan> maintain an environment
16:19:00 <mgsloan> eg, let me use various declerations in a series
16:19:00 <augustss> Botje: main = do file <- getContents; res <- mapM munge (lines file); ...
16:19:06 <Cale> oh, I just always keep my source file open alongside it
16:19:08 <mgsloan> and reference them in later expressions
16:19:17 <Cale> you can do multiline functions though
16:19:20 <Cale> use ;
16:19:24 <mgsloan> hah
16:19:31 <mgsloan> I mean multiline on the prompt too
16:19:56 <mgsloan> point is basically you are limited in your ability to do a really quick try out of a concept
16:20:05 <Botje> hrrm
16:20:13 <mgsloan> which is where interactive interpreters should shine
16:20:26 <dancor> i think it could be made more cut-and-paste friendly maybe
16:20:30 <geckosenator> well you can do that in c or c++ too
16:20:34 <dancor> like the python interpreter
16:20:34 <monochrom> perhaps mapM_ is more efficient
16:20:38 <mgsloan> not just cut and paste, but yeah
16:20:48 <geckosenator> what language can't do it?
16:20:58 <monochrom> There is a C interpreter in a Casio "calculator". :)
16:21:10 <geckosenator> you can use gdb and call functions
16:22:07 <monochrom> SML (both NJ and MoscowML) and OCaml are certainly stronger here.  The only feature I miss in Haskell but ok.  You can manually type in a complete module at the prompt.
16:22:30 <mgsloan> it also helps with experimenting with the language - I don't want to have to make a several line haskell file (and do manual save/reload cycles) just so I can see how certain specifics of data types work
16:23:10 <augustss> mgsloan: I agree, the ghci and hugs repl are kinda lame
16:24:25 <geckosenator> scheme can do it too
16:25:18 <augustss> there's no reason not allow any top level declarations at the prompt.  with multi-line support.
16:25:35 <Cale> augustss: what about mutual recursion?
16:26:18 <augustss> Cale: you'd need some extra thing to allow that
16:26:32 <alexj__> dmhouse: I just added some comments to the example -- not a full tutorial, but ansers the questions you asked.
16:26:33 <mgsloan> yep, pretty much.  You can even tell between expressions and declerations, so still be able to do stuff like > 1+1
16:26:49 <alexj__> dmhouse: do they help?
16:26:52 <augustss> mgsloan: I know it can be done.  I have done it. :)
16:27:00 <mgsloan> nice :)
16:27:18 <augustss> but hbc/hbi is kinda dead
16:27:43 <DeliQ> can anybody help me ?
16:28:07 <Philippa_> augustss: "some extra thing" wouldn't be too hard to envisage, though...
16:28:18 <Philippa_> a binding group with explicit opening and closing braces, say
16:28:21 <mgsloan> DeliQ - probably yes, its a rather friendly channel
16:28:26 <augustss> Philippa_: exactly what I was thinking
16:28:28 <DeliQ> i know :P
16:28:36 <alexj__> dmhouse: will be back in 5 min.
16:28:46 <dmhouse> alexj__: almost. I still don't get how the example* stuff works. Which values get passed to them?
16:29:57 <DeliQ> i'm trying to make a simple theorem prover, using KE calculus. KE calculus defines a set of rules to reduce complex first-order-logic formulas in less complex formulas
16:30:23 <DeliQ> i'm trying to make a refutation tree
16:30:45 <DeliQ> in which every node is a reduced formula
16:31:17 <DeliQ> but i don't know how to code this rule system..
16:31:45 <augustss> mgsloan: checking old records... the kind of interactive haskell you want was first available in 1992 :)
16:31:46 <DeliQ> hopefully it makes some sense to you :P
16:31:49 <Cale> Construct a datatype which represents the syntax of the formulas, and implement the rules as transformations on it?
16:32:05 <DeliQ> already constructed the datatype..
16:32:17 <DeliQ> can you explain transformations..
16:32:35 <Cale> I just mean ordinary functions
16:32:47 <zeeeee> is there a shorter way to do this? \x y -> case x of { Nothing -> Just [y]; Just xs -> Just (y:xs) } :: Maybe [a] -> [a] -> Maybe [a]
16:33:00 <DeliQ> Cale: so for every rule make a different function ?
16:33:10 <DeliQ> which manipulates the formula ?
16:34:44 <augustss> zeeeee: you can use the maybe function, it's a little shorter that way
16:34:49 <twanvl> ?pl \x y -> y : maybe [] id x
16:34:50 <lambdabot> flip (:) . maybe [] id
16:35:02 <Cale> DeliQ: perhaps
16:35:13 <zeeeee> ?pl \x y -> case x of { Nothing -> Just [y]; Just xs -> Just (y:xs) }
16:35:13 <lambdabot> (line 1, column 19):
16:35:13 <lambdabot> unexpected "{"
16:35:13 <lambdabot> expecting variable, "(", operator or end of input
16:35:14 <mgsloan> augustss: argh
16:35:22 <zeeeee> wth
16:35:27 <Cale> and construct a function which successively applies them to reduce the formula
16:35:36 <Cale> but I don't know anything about your given system :)
16:35:43 <zeeeee> @type maybe
16:35:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:35:53 <twanvl> pl probably doesn't understand case-of
16:35:53 <DeliQ> it's not really that relevant
16:36:14 <DeliQ> i thought, maybe there is a nicer way to solve this
16:36:27 <DeliQ> monad, class ??
16:37:02 <goltrpoat> deliq:  see if http://vandreev.wordpress.com/2006/12/24/quick-and-dirty-theorem-prover/ helps any
16:37:07 <lambdabot> Title: Quick and Dirty Theorem Prover. « codeland, http://tinyurl.com/y5keq2
16:37:23 <goltrpoat> it's propositional logic though, not first order, and it's a tad messy
16:37:29 <DeliQ> aah, ty, going to check it out
16:38:51 <zeeeee> augustss: got it, thanks!
16:42:15 <DeliQ> in my prover, the reduction steps form a tree, does that mean, that i need to make the tree a paramater, as it is some sort of a state ?
16:48:48 <goltrpoat> deliq:  if you want to be able to easily add new rules, then that suggests monadic combinators, to me anyway.  if not, then i'm not sure what the question is :)
16:49:49 <mgsloan> deliQ: might look at the state monad then?
16:50:07 <DeliQ> monadic combinators sounds new to me... sorry
16:50:25 <DeliQ> can you explain what they are..
16:50:43 <alexj__> dmhouse: back.  here is the URL with the new comments: http://happs.org/HAppS/src/HAppS/Protocols/SimpleHTTP2.hs
16:51:04 <DeliQ> mgsloan: does it anyway makes sense to make a tree into a state?
16:51:16 <DeliQ> sounds little odd to me :P
16:51:18 <goltrpoat> deliq:  http://citeseer.ist.psu.edu/hutton96monadic.html is a good introduction
16:51:19 <lambdabot> Title: Monadic Parser Combinators - Hutton, Meijer (ResearchIndex)
16:51:31 <DeliQ> goltrpoat: thanks!
16:51:32 <dmhouse> alexj__: that's much better, but still see my comments above.
16:51:49 <alexj__> which comments?
16:52:02 <alexj__> I had to get offline so I may have missed them?
16:52:09 <dmhouse> Okay, here they were
16:52:12 <dmhouse> alexj__: almost. I still don't get how the example* stuff works. Which values get passed to them?
16:53:43 <alexj__> OIC.  ok will add that comment.  hold on.
16:58:42 <alexj__> dmhouse: ok updated.
16:59:02 <alexj__> dmhouse: same URL: http://happs.org/HAppS/src/HAppS/Protocols/SimpleHTTP2.hs
17:00:30 <alexj__> dmhouse: does that make sense?
17:01:11 <dmhouse> alexj__: yeah, pretty much. The Int instance of FromReqURI is nontrivial, though, what does it do?
17:02:14 <alexj__> oh I put that in as an example.  do you see how exampleGetVal takes an Int as its first argument?
17:02:25 <dmhouse> Yep.
17:02:44 <alexj__> thats what the Int instance does.
17:03:29 <dmhouse> Huh?
17:03:49 <dmhouse> The Int instance of FromReqURI converts a URI into an Int somehow, and I want to know how it does it.
17:04:40 <alexj__> dmhouse: the user requests /status/5 and that request gets run as exampleGetVal 5 ()
17:05:09 <dmhouse> Right, okay.
17:05:58 <alexj__> I figure that you don't want the marshalling/unmarshalling from requests to distract you from app functionality.
17:06:08 <ndm> @seen dcoutts__
17:06:08 <lambdabot> dcoutts__ is in #gentoo-haskell and #haskell. I last heard dcoutts__ speak 1h 23s ago.
17:06:12 <dmhouse> Makes sense.
17:06:30 <dmhouse> And you've always got access to the original URI or ["split", "parts"] if you want it.
17:06:31 <alexj__> dmhouse: any comment that I should put there to help explain (I coded it so I am probably to intimate with it all)
17:06:46 <ndm> @seen dcoutts
17:06:47 <lambdabot> dcoutts is in #ghc, #haskell-overflow, #gentoo-haskell, #haskell and #haskell.hac07. I last heard dcoutts speak 10h 52m 52s ago.
17:06:48 <alexj__> dmhouse: yes.
17:06:50 <dmhouse> alexj__: just a brief comment explaining what the Int instance of FromReqURI does.
17:07:01 <dmhouse> It's weird because you think 'How can you convert a URI into an integer?'
17:07:27 <dmhouse> The answer you need to give is 'grab everything after the last slash and read it'.
17:07:34 <dmhouse> Anyway, I need to go to bed.
17:07:39 <dmhouse> Cheers, alexj__.
17:08:27 <alexj__> dmhouse: good night and  thanks
17:12:20 <sorear> ?seen
17:12:20 <lambdabot> Lately, I have seen alexj__, elpolilla, ndm, quazimodo and sorear.
17:15:53 <quazimodo> :)
17:16:04 <quazimodo> ?whosthecoolestcatofthemall
17:16:04 <lambdabot> Unknown command, try @list
17:16:16 <quazimodo> should reply 'shaft!'
17:16:20 <fnord123> tophat
17:16:27 <fnord123> er, topcat
17:17:30 <sorear> submit a patch! :)
17:17:46 <sorear> the code you want to change is in Plugin/Dummy.hs, btw
17:17:51 <gvdm_other> of the mall?
17:18:01 <gvdm_other> which mall?
17:18:07 <gvdm_other> are there mall cats?
17:18:14 <gvdm_other> like alley cats except not?
17:18:34 <sorear> godisnowhere <-- one of my teachers thought this was cute.  I never forgave him
17:19:25 <gvdm_other> .. trying ... to ... suppress ... grin ...
17:20:01 <psi> funny :)
17:20:16 <mgsloan> nice
17:20:31 <mgsloan> It took me a while to see 'god is now here'
17:20:39 <psi> same here
17:21:04 <gvdm_other> sorear: face it, [hackers|programmers|computer lovers] love puns
17:21:05 <fnord123> theres a redditor with the nick godslaughter
17:21:45 <gvdm_other> for some strange unexplained reason there is a connection
17:21:57 <gvdm_other> hands up if you can tell me why
17:22:11 <fnord123> youre going to mug them?
17:22:59 <gvdm_other> nope, i'll pick them out of the crowd and like a little school boy they will have to tell the channel what they think the correct answer is
17:23:06 <gvdm_other> :D
17:24:16 <quazimodo> YES
17:24:20 <quazimodo> I CAN USE GHCI NOW!
17:24:36 <quazimodo> awsome i hacked it so that fbsd thinks i have 6.4.2 installed but its 6.4.1 :)
17:24:36 <sorear> great?
17:24:57 <quazimodo> i just need to update its deintsall info when i want to remove it
17:25:09 <sorear> f bsd, hehehe
17:25:18 <fnord123> it only took a day :)
17:26:02 <sorear> <--- managed to get 6.4.2 working by applying hexedit(1) to /usr/local/lib/ghc-6.4.2
17:26:10 <quazimodo> i think it would have been a decent idea to put all files in a */bin folder into */bin/ghc or */bin/gimp etc and have the shell just do similar to a recursive ls to use them, much neater
17:26:17 <fnord123> and i figured out why hxt won't load chunked documents properly over a network despite http module looking like it's working. it seems hxt rewrites a lot of http response handling. FOR NO REASON! yay
17:26:23 <quazimodo> sorear, what do you mean?
17:26:40 <quazimodo> sorear, did you also have problems getting it to work?
17:26:55 <yaxu> ?hoogle Int -> GLfloat
17:26:56 <lambdabot> No matches, try a more general search
17:27:05 <sorear> yaxu: fromIntegral
17:27:35 <sorear> /usr/local/src/fps$ ./Setup.hs build  ;  /usr/lib/libreadline.so.4: no such file or directory
17:27:53 <yaxu> sorear: thanks
17:27:54 <sorear> * use hexedit to change the 4 to a 5 in the GHC binary *
17:28:05 <sorear> * it worked afterward *
17:28:49 <sorear> I'm sure it'll segfault if I try and do anything too fancy, but it works fine for compiling stuff.
17:29:18 <quazimodo> sorear you son of a bitch! i didnt even consider that
17:29:35 <atsampson> sorear: hm, I'd make a symlink ;)
17:30:51 <quazimodo> i only have a libreadline.so
17:30:53 <quazimodo> no .4
17:30:54 <quazimodo> no .5
17:31:06 <sorear> ouch
17:31:19 <quazimodo> is the .4 part of the file name, or something inside it?
17:31:22 <sorear> the .numbers are typechecking
17:31:37 <quazimodo> hrm
17:31:53 <sorear> in theory, anything.5 is incompatible with anything.4, and the numbers stop you from having problems
17:32:17 <quazimodo> :/
17:32:18 <sorear> in practice, the system is rather too eager to assume an incompatible change
17:32:50 <quazimodo> sorear, you could tgz your /usr/local/lib/ghc-blabla and send to me?
17:32:55 <quazimodo> by that
17:32:56 <quazimodo> i mean
17:33:00 <quazimodo> couldnt you please do it?
17:33:08 <quazimodo> but if its a hassle then ofcourse nvm
17:33:20 <sorear> so your system has no numbers at all - did they expect you to replace your entire computer when you upgrade the OS?
17:33:36 <quazimodo> i did upgrade it
17:33:39 <quazimodo> from 6 to 6.1
17:33:48 <sorear> (windows IIRC has no numbers, just c:\windows\system32\foobar.dll)
17:33:57 * metaperl wonders if hugs could be used to compile GHC
17:34:01 <atsampson> sorear: so how do you install multiple binary versions of a library?
17:34:06 <quazimodo> [quazimodo@downstairs /usr/lib]$ locate libreadline.so.4
17:34:06 <quazimodo> /usr/local/lib/compat/libreadline.so.4
17:34:07 <geckosenator> you don't
17:34:12 <quazimodo> i do techincally have them :/
17:34:14 <sorear> atsampson: google "dll hell"
17:34:46 <atsampson> (the FreeBSD 6 machine I've got access to has .so.4/.so.5 as I'd expect...)
17:35:33 <atsampson> (albeit not for libreadline, but presumably you can add them if you like)
17:35:36 <quazimodo> would it be enormously stupid of me to symlink those to /usr/lib and recompile 6.4.2?
17:35:50 <sorear> probably not
17:36:06 <sorear> I suppose chroot is there if needed...
17:36:52 <sorear> I would've recompiled 6.4.2, but the folks at glasgow don't support downgrading from source
17:37:31 <sorear> I have GHC 6.6 and HEAD, both gave syntax errors on the 6.4.2 source :(
17:37:34 <quazimodo> sorear my libreadline.so.# exist in /usr/local/lib
17:37:40 <quazimodo> which does make sense since i installed them later
17:39:04 <quazimodo> have you guys noticed the haskell tutorials are piss poor for introduciing a newbie into coding, but they are great at defining thigns?
17:40:02 <gvdm_other> i think they all assume previous coding experience
17:40:08 <sorear> haskell tutorials?  never tried 'em
17:40:27 <gvdm_other> truly, for how many people was haskell their first language?
17:40:38 <quazimodo> is this normal
17:40:39 <quazimodo> Prelude> calc :: String -> [Float]
17:40:39 <quazimodo> <interactive>:1:0: Not in scope: `calc'
17:40:49 <SamB_XP> who taught toddlers to use Haskell?
17:40:50 <SamB_XP> Cale?
17:41:12 <Cale> I taught some 11 year old kids
17:41:19 <SamB_XP> hehe
17:41:26 * SamB_XP was exaggerating for effect ;-)
17:41:29 <quazimodo> why is prelude being mean to me?
17:41:33 <sorear> Cale says he taught 11 yr olds monads, don't remember anything about Haskell specifically
17:41:46 <SamB_XP> sorear: how would they learn Monads in anything else?
17:41:59 <sorear> ?go "Monads in other languages"
17:42:03 <lambdabot> http://programming.reddit.com/info/ox6s/comments
17:42:03 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com)
17:42:03 <Cale> yeah, monads in Haskell -- they were using "The Haskell Road", it was sort of an experimental course
17:42:15 <SamB_XP> they are all annoying to use
17:42:24 <SamB_XP> the monads in other languages
17:42:46 <sorear> I learned C at 7 and Haskell at 15.  I think I'm mostly recovered now.
17:43:14 <quazimodo> i learnt all sorts of programming languages and NEVER stuck with one for good to really get good at it
17:43:28 <quazimodo> so i am a shitcunt at them all
17:43:45 <quazimodo> i did the most with c tho
17:43:51 <SamB_XP> I learned BASIC first but never really did much with it
17:44:03 <quazimodo> hah i wrote a patch for a friend that was 2mb, his version ended up being 30
17:44:06 <quazimodo> funny times
17:44:13 <sorear> I stuck with C.  I regret it.
17:44:17 <quazimodo> i think he went the phd route
17:44:26 <SamB_XP> I don't stick with stuff
17:44:28 <sorear> I tried out something like 15 others
17:44:28 <quazimodo> sorear, another haskell fanboy friend of mine says that too
17:44:31 <SamB_XP> I really don't
17:44:33 <SamB_XP> ever!
17:44:45 <SamB_XP> I do come back sometimes though.
17:44:48 <quazimodo> i found c to be intuitive and work..
17:44:59 <SamB_XP> quazimodo: that is always a bad sign!
17:45:01 <quazimodo> i havent had any real haskell experience so i cant compare but is haskell really that much better?
17:45:24 <quazimodo> and if it is then why do people still use c?
17:46:07 <gvdm_other> quazimodo: why, oh why, do people not communicate telepathically yet? (or use windows for that matter)
17:46:12 <SamB_XP> well, I think if you write C programs in Haskell it takes at least twice as many lines...
17:46:20 <SamB_XP> so that might be one reason
17:46:29 <quazimodo> huh?
17:46:37 <Cale> quazimodo: "yes", and "inertia"
17:46:38 <quazimodo> you are saying haskell is longer, but clearly it isnt
17:46:47 <SamB_XP> quazimodo: I said if you write *C* programs
17:46:58 <SamB_XP> if you write Haskell programs they are much shorter ;-)
17:47:01 <sorear> ?go A good fortran programmer can write FORTRAN in any language.
17:47:04 <lambdabot> http://www.acmqueue.com/modules.php?name=Content&pa=showpage&pid=271
17:47:04 <lambdabot> Title: ACM Queue - How Not to Write FORTRAN in Any Language - There are characteristics ...
17:47:18 <Cale> Usually haskell programs are from 10 to 15 times shorter than corresponding C programs.
17:47:23 <quazimodo> if you write C programs in Haskell it takes at least twice as many lines... that is saying the haskell implementation is 2x longer than the c?
17:47:31 <sorear> I remember all the quotes, but not the attributions.
17:47:37 <Cale> quazimodo: no, he's saying if you translate from C directly
17:47:55 <Cale> quazimodo: i.e. do silly things like pointer arithmetic and such
17:48:02 <quazimodo> thats what i was thinking
17:48:10 <sorear> VTY has about the same number of lines in haskell and C ... however the haskell version has a 4x longer feature list
17:48:11 <quazimodo> if you try to do a c style program in haskell etc
17:48:22 <zeeeee> is there a function like MissingH's Data.List.Utils.split, but with a max number of splits?
17:48:23 <gvdm_other> an idiomatic haskell program is shorter than one using the C idiom
17:48:31 <Cale> yeah. Even a slight amount of thought will bring that count way down.
17:48:33 <quazimodo> but what if you had a certain quite complex program, would good c code be significantly longer than good haskell code?
17:48:35 <gvdm_other> as would be expected
17:48:45 <SamB_XP> quazimodo: yes
17:48:48 <SamB_XP> usually
17:48:54 <shankys> Does anyone know any largish (or even small) Haskell projects that use Takusen for their database? I'm trying to get started with Takusen, and some code I could study would be really helpful.
17:48:59 <Cale> Probably 10 times longer
17:49:00 <quazimodo> and which would have the faster binary?
17:49:05 <fnord123> i could do with a good xterm written in haskell. :)
17:49:06 <Cale> quazimodo: depends
17:49:31 <sorear> yeah, that's been on my TODO list too
17:49:32 <quazimodo> Cale, then i will rephrase, are good haskell coded programs, on average, as fast as good c programs/
17:49:41 <SamB_XP> quazimodo: well, it would be much harder to optimize the C program
17:49:46 <sorear> define "good".
17:50:06 <sorear> Haskell programs written in Haskell are faster than Haskell programs written in C.
17:50:12 <SamB_XP> yes
17:50:23 <sorear> I belive most large programs written in C are Haskell programs.
17:50:25 <Cale> quazimodo: C is lower level, so if you're willing to spend unlimited amounts of time optimising things, you'll be able to write something faster. It might involve throwing away all your libraries though.
17:50:32 <SamB_XP> as you can see if you translate the Unlambda interpreter into the Haskell it longs to be
17:50:46 <quazimodo> sorear, is that in terms of coding style, or  in terms of the what the program does
17:50:51 <SamB_XP> (the one written in C)
17:50:55 <sorear> coding style
17:51:06 <sorear> C programs written in C are unmaintainable
17:51:12 <quazimodo> ?
17:51:21 <Cale> sorear: Well, comparatively
17:51:23 <quazimodo> so how are they maintained?
17:51:33 <Cale> People manage to maintain them :)
17:51:49 <augustss> Most (all?) large C programs use C in a very disciplined way
17:51:52 <SamB_XP> what kind of program is Linux?
17:52:17 <Cale> quazimodo: Basically, for most applications, being twice as slow even doesn't matter at all.
17:52:39 <augustss> most maintainable ones, that is
17:52:44 <quazimodo> Cale, i *loathe* unefficient coding
17:52:55 <quazimodo> quake 3- good, warcarft 3 tft... DIE FUCKER DIE
17:53:00 <quazimodo> inefficent
17:53:01 <quazimodo> whatever
17:53:16 <augustss> quazimodo: the important thing is to know how to make things efficient, and apply that when necessary
17:54:02 <sorear> Most programs cannot be optimized ...
17:54:11 <sorear> because the bottleneck is read(2).
17:54:14 <quazimodo> augustss, i just want to learn a language that promotes good code :0, i know you cant get away from bad code but if haskell *can* be made quite fast then im ok to learn it
17:54:23 <SamB_XP> sorear: or write(2)!
17:54:31 <Philippa_> quazimodo: Blizzard have different priorities to Id...
17:54:35 <sorear> esp. on terminal devices and /tmp/.X0-unix
17:54:35 <SamB_XP> (that is, xterm ;-P)
17:54:47 <Philippa_> and Q3A still ran like crap on hardware UT was perfectly happy on :-)
17:54:55 <augustss> sorear: that's true for certain kinds of programs.  not the kind i like to work on, though
17:55:13 <augustss> quazimodo: haskell can be made fast
17:55:17 <Cale> quazimodo: check out these slides: http://www.cse.unsw.edu.au/~dons/talks/fusion-talk.ps.gz
17:55:28 <Philippa_> augustss: did you get my PMs? Obviously you can ignore the bit about my going to bed as it's not hapened yet
17:55:31 <sorear> I used to like writing games.  Now I'm more fond of type hackery and terminal drivers...
17:55:37 <SamB_XP> quazimodo: Haskell can allow you to use better algorithms far more easily than almost any other language
17:56:24 <augustss> Philippa_: i got them.  but I didn't think answering them would do you any good.  But the answer is no.  I don't know how to desugar in a "reversible" way.
17:56:29 <quazimodo> can openoffice.org handle that
17:56:34 <quazimodo> and how many people here are from unsw??
17:56:38 <sorear> dons
17:56:45 <sorear> ooo handle ?
17:56:47 <quazimodo> and is this because unsw teaches you guys haskell first year?
17:56:57 <sorear> dons --> www.cse.unsw.edu.au/~dons
17:57:13 <sorear> dons is IIRC a teacher
17:57:16 <Philippa_> augustss: Fair enough. I figured someone might've written something on some of the semi-obvious (as in, takes a fair amount of thinking but will reliably be found) stuff at least
17:57:44 <Cale> quazimodo: did you check out those bytestring slides?
17:58:34 <augustss> Philippa_: it seems like a lot of tedious book keeping
17:58:47 <augustss> and even then it will be imperfect
17:58:52 <Philippa_> *nod*
17:59:10 <Philippa_> well, I'd been wondering how much of the book-keeping could at least be made to fit simple patterns
17:59:36 <sorear> reversible desugaring - sounds easy if the core-lang can be used in a stylized manner, but why?
18:01:02 <Philippa_> sorear: because the alternative is either crap error messages or having things like the typechecker run over the sugar-included language
18:01:34 <sorear> great idea!
18:02:08 <Philippa_> not if you want me to finish writing the typechecker :-)
18:02:23 <sorear> sure.  desugar (x y) to (app x y) where app is id, now desugar anything else injectively.
18:02:59 <Philippa_> that's not desugaring
18:03:08 <Philippa_> that's just an AST representation
18:03:48 <Philippa_> you don't typecheck on something with actual semicolons in unless you're nuts :-)
18:04:06 <sorear> app :: (a -> b) -> a -> b
18:04:29 <sorear> the typechecker neither knows nor cares that the input is actually an AST for the full language.
18:04:33 <wy> Since list is a monad, say m a, then what's a after stripped of m?
18:04:48 <Cale> wy: hm?
18:04:50 <sorear> [a] <==> [] a   ; m = []  a = a
18:05:20 <wy> But if I have two elements in the list?
18:05:31 <Cale> wy: or if you have no elements in the list?
18:05:35 <augustss> sorear: have you actually implemented what you suggest?
18:05:41 <quazimodo> Cale, not yet i have to do some stuff first, we are renovating and i need to haul some cabinets around the place in between frequent nerdish returns to irc to see what ou said
18:05:49 <augustss> sorear: for a non-trivial language
18:06:09 <sorear> augustss: no
18:06:12 <Cale> quazimodo: all right. Let me know what you think of that. It should give you some kind of answer to your question :)
18:06:28 <sorear> I don't write nontrivial languages to test every idea I have
18:07:01 <augustss> sorear: that's sensible.  but many cute ideas break down when faced with reality
18:07:07 <Cale> wy: note that monads don't guarantee the existence of a function  (m a -> a)
18:07:15 <sorear> least trivial I've written would be the lambda calculus with sums and products, and that was a mere typechecker
18:07:41 <sorear> Cale: sure they do.  const undefined.  This is Haskell, after all.
18:08:04 <Cale> sorear: of course I mean a total function
18:08:04 <Philippa_> sorear: monads don't guarantee that, haskell happens to
18:08:14 <Cale> this is mathematics, after all
18:08:20 <Cale> *cough*
18:08:48 <augustss> sorear: we all know about bottom, but it almost never an interesting implementation of anything :)
18:08:56 <wy> Cale: I guess I only need to understand how [1,2,3] >>= (\x->[x+1]) works
18:09:20 <augustss> wy: execute it by hand
18:09:39 <augustss> >>=  is concatMap
18:09:50 <augustss> or flip concatMap
18:10:21 <Cale> xs >>= f = concat (map f xs)
18:11:03 <Jaak> @check let f x = [x + 1] in \xs -> (concatMap f xs :: [Int]) == (xs >>= f)
18:11:05 <lambdabot>  OK, passed 500 tests.
18:11:19 <Cale> [1,2,3] >>= (\x -> [x+1])
18:11:22 <Cale>  = concat (map (\x -> [x+1]) [1,2,3])
18:11:37 <Cale>  = concat [[2],[3],[4]]
18:11:45 <Cale>  = [2,3,4]
18:13:28 <wy> Cale: I see. It's flip concatMap
18:13:50 <Jaak> on lists
18:14:27 <Cale> In a sense, it's not that different on other types either :)
18:14:35 <Cale> x >>= f = join (fmap f x)
18:14:39 <Cale> in general
18:15:59 <sorear> on lists, join = concat, fmap = map
18:21:07 <quazimodo> Cale, what format is ps?
18:21:15 <Cale> postscript
18:21:19 <quazimodo> oh :/
18:21:22 <Cale> I can convert it to pdf if you'd like
18:21:22 <quazimodo> lol
18:21:32 <quazimodo> mno no
18:21:54 <Cale> http://cale.yi.org/autoshare/fusion-talk.pdf
18:22:07 <quazimodo> what is the more pretty ghostscript viewer
18:22:09 <quazimodo> other than gs
18:22:19 <quazimodo> gs is very simple and i dont know the commands to rotate and etc
18:22:19 <Cale> I usually use evince.
18:22:41 <moconnor> Is there a sleep function?  Hoogle only gives me one in System.Win32.Process but it has no documentation and I'm using Ubuntu.
18:23:09 <Cale> @type Control.Concurrent.threadDelay
18:23:11 <lambdabot> Int -> IO ()
18:23:17 <monochrom> gv is the best gs frontend
18:23:20 <Cale> Suspends the current thread for a given number of microseconds (GHC only).
18:23:32 <Cale> gv is pretty decent, yeah
18:23:37 <monochrom> evince doesn't use gs, but it's also good.
18:23:52 <moconnor> Cale: Thank you
18:24:25 <gvdm_other> evince went a long way to solving the crap xpdf/gv/etc document viewer problem in linux (for gnome anyway)
18:24:50 <Cale> gv is still better than evince at actually rendering documents
18:24:58 <Cale> (at least, postscript documents :)
18:25:05 <quazimodo> i have gs
18:25:36 <squiggly> i have aids
18:25:45 <quazimodo> sucks to be you
18:25:45 <quazimodo> bbl
18:26:09 <monochrom> gv calls gs for interpreting and rendering ps.
18:26:37 <monochrom> I should call that "executing ps" :)
18:27:03 <quazimodo> gv is ghostview?
18:27:06 <Cale> yeah
18:27:22 <Cale> well, the actual executable is called gv :)
18:27:46 <Cale> er, is it the same?
18:28:10 <Cale> actually, it might have just started with ghostview, and been extended from there
18:28:25 <Cale> http://wwwthep.physik.uni-mainz.de/~plass/gv/gv_main.gif -- looks like this
18:29:42 <quazimodo> my executable is ghostview and its a plain screen with black on white
18:29:43 <quazimodo> page
18:29:48 <quazimodo> file
18:29:51 <quazimodo> orientation
18:29:53 <quazimodo> etc
18:30:30 <LoganCapaldo> Does that mean a printer is HW accelerated Ghostview? <g>
18:31:06 <LoganCapaldo> or maybe it means ghostview is a printer emulator
18:31:07 <LoganCapaldo> heh
18:31:13 <LoganCapaldo> postscript is odd
18:31:32 <sorear> yes, ghostview is a printer emulator
18:32:31 <sorear> you might also look at bmv - not great in any sense of the word, but fills its niche fairly well
18:34:18 <olliej> seem saulzar
18:34:18 <monochrom> Actually printer is not so much HW-accelerated.  Typical implementation is you pay extra to buy ps firmware, and the code runs on a cpu slower than your desktop and with less memory too.  You can say HW-decelerated.
18:34:23 <olliej> seen saulzar
18:34:47 <olliej> quick q: what's the "seen" instruction?
18:34:54 <sorear> seen?
18:34:56 <monochrom> ?seen monochrom
18:34:56 <lambdabot> You are in #haskell. I last heard you speak just now.
18:35:04 <olliej> ?seen saulzar
18:35:05 <lambdabot> I saw saulzar leaving #haskell 5d 21h 57m 34s ago, and .
18:35:19 <olliej> monochrom: cheers
18:36:30 <monochrom> The only advantage of a printer is resolution (600dpi) and fonts.
18:37:26 <sorear> Nowadays printers have 100baseT or higher connections, so a 600dpi bitmap shouldn't be a big issue...
18:39:14 <monochrom> the amount of memory on the printer is a big problem
18:39:30 <sorear> banding?
18:39:30 <mgsloan> yeah, gotta spool it on the comp
18:39:49 <sorear> TCP has flow control
18:40:01 <sorear> and I don't mean XON/XOFF
18:40:29 <mgsloan> do printers use TCP?
18:40:36 <sorear> mine does
18:40:54 <sorear> it has a Berkeley-style lprd in firmware
18:41:19 <sorear> and a smb printer share, which is much more often used, sigh
18:41:34 <monochrom> heh
18:48:57 <LoganCapaldo> sorear: That's hot. What printer?
18:50:02 <sorear> don't remember, never used it (family printer, I'm the only one who subscribes to 'paperless')
18:50:03 <SamB_XP> what is lprd?
18:50:07 * SamB_XP feigns ignorance
18:50:15 <sorear> Line Printer R Daemon
18:51:22 <allbery_b> normally it's just called lpd... :)
18:51:54 <quazimodo> Cale, fairly interesting stuff, but i barely understand any of this stuff
18:52:14 <sorear> SysV has lpd, Berkeley has lprd.  Now that I think about it more it probably was an lpd.
18:52:51 <allbery_b> System V has lpsched (and on Solaris printd to handle BSDish jobs)
18:53:14 <allbery_b> lpd is what it's called on my freebsd box and what it was on SunOS4
18:53:17 <monochrom> On unix the print command is "lpr myfile.ps".  It causes the file to be sent over a network protocol to a server (the server's IP is set somewhere under /etc).  The server daemon is usually called lpd.
18:53:50 <jlouis>  /etc/printcap in BSD-style
18:53:55 * sorear realizes he doesn't know anything about this feature of *nix he never uses
18:53:55 <allbery_b> typically it's sent to the local lpd which gets the remote server from /etc/printcap
18:54:15 <allbery_b> (although LPRng can spool directly to a remote lpd)
18:54:30 <sorear> that sounds so much like smtp wrt. routing
18:54:39 <monochrom> Yes.
18:54:40 <allbery_b> moreor less, yes
18:55:20 <allbery_b> we've been changing client machines to use LPRng and not run a local lpd, because it's dumb to have every machine running a spooler (and BSDish lpd doesn
18:55:29 <allbery_b> 't have a "listen only for local requests" mode)
18:55:46 * monochrom grins evilly
18:56:52 <Adamant> CUPS!
18:57:05 <sorear> PAPERLESS!
18:57:17 <monochrom> DIE!
18:57:27 <Adamant> I can't do paperless until I get a tablet PC.
18:58:05 <allbery_b> CUPS as a client only works if you can use its broadcast foo, because CUPS-to-CUPS triggers a bug in raw printing :/
18:58:29 <allbery_b> cross-subnet broadcasts are blocked for security reasons => nonstarter
18:58:46 <Adamant> you can't do CUPS to CUPS? weird.
18:59:12 <allbery_b> same problem happens with printing from Windows but we're hacking around it
18:59:47 <SamB_XP> allbery_b: what is the bug?
19:00:28 <allbery_b> you can do CUPS-to-CUPS, but only if you use lpd.  looking up the STR now
19:01:24 <jmob> Is this a Haskell CUPS library?
19:01:34 <monochrom> Naw :)
19:01:45 <monochrom> No one writes buggy Haskell software!
19:01:46 <allbery_b> STR #1933
19:02:23 <allbery_b> basically, if you send a "raw" print job to a CUPS server, it forgets to do some setup so multi-file printing (including printing with banners) fails
19:02:33 <sorear> ghc just gave me 4 type errors, 50 lines each :(
19:02:52 <allbery_b> since most of the public printers have banners enabled, that's a bit of a problem here
19:03:42 <mgsloan> sorear - annotate!
19:03:48 <allbery_b> the workaround is to force the MIME type to application/octet-stream so it has to scan the job to find out what it is, and the easiest way to do that is to set up cups-lpd
19:04:03 <allbery_b> and configure it to relay all jobs on as application/octet-stream
19:04:35 <sorear> what's the correct spelling of -ddump-iface?
19:05:22 <sorear> I wish ghc displayed *all* options on --help
19:05:43 <SamB_XP> sorear: for real?
19:05:49 <SamB_XP> maybe --help --verbose
19:06:03 <sorear> -ddump-hi, found it online
19:06:20 <sorear> SamB: there is no --verbose :(
19:06:54 <SamB_XP> sorear: there is a manpage
19:26:30 <zeeeee> is there a function like MissingH's Data.List.Utils.split, but with a max number of splits?
19:29:06 <sorear> like perl split with the third arg specified?
19:29:12 <sorear> yes.
19:29:27 <sorear> is it standard?  I don't think so
19:30:11 <sorear> Lib.Util.split2 in the Lambdabot source code
19:30:16 <zeeeee> sorear: ah, thanks!
19:31:15 <zeeeee> whoa, googling for lambdabot led me straight to haskell-libs on sf.net
19:31:27 <sorear> ?where lambdabot
19:31:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:31:30 <zeeeee> how could i have missed this... i was looking for a place to toss all my codeanyway
19:31:50 <zeeeee> sorear: oh i found lambdabot, i was just remarking on haskell-libs
19:34:34 <zeeeee> anybody here an admin on that project?
19:35:08 <sorear> I'm an admin in the freenode instance... is that what you mean?
19:35:31 <mgsloan> that's one problem with split - its more of a type of functions than a particular function :)
19:36:21 <caverdude> wow
19:36:24 <caverdude> what is haskell?
19:36:48 <sorear> ?where haskell
19:36:49 <lambdabot> http://haskell.org/
19:36:51 <mgsloan> A full one looks something like uberSplit :: (String -> Int -> SplitAction) -> String -> [String]
19:36:55 <sorear> a programming language.
19:36:56 <zeeeee> sorear: huh...no i meant...an admin of the haskell-libs project
19:37:10 <caverdude> sorear: yes but what kind of language?
19:37:17 <zeeeee> caverdude: a good one :)
19:37:25 <zeeeee> caverdude: a functional language
19:37:28 <zeeeee> caverdude: a strongly typed language
19:37:33 <monochrom> The finest imperative language in the world.
19:37:38 <mgsloan> heh
19:37:42 <caverdude> is C not a functional language?
19:37:49 <monochrom> Yes it is.
19:38:12 <sorear> "A good FORTRAN programmer can write FORTRAN in any language."
19:38:27 <MarcWebe1> caverdude: Another nice summary can be found here http://en.wikipedia.org/wiki/Haskell_%28programming_language%29
19:38:39 <sorear> A good C programmer can write C in Haskell; A good Haskell programmer can write Haskell in C.
19:38:41 <caverdude> is it OOP?
19:38:45 <sorear> no
19:38:52 <caverdude> ah
19:38:55 <mgsloan> dunno about that one monochrom, takes a bit of monad rewriting to attain that imperativeness, and at that point the concisity of imperative languages in these problems is lost.
19:39:05 <mgsloan> but that's not a bad thing, OOP is a rather bad idea
19:39:18 <caverdude> hrm
19:39:27 <mgsloan> It's just very popular
19:39:33 <mbishop> so is windows
19:40:00 <sorear> Evaluate haskell on your own terms, and remember that #haskell is mostly staffed by programming language advocates.
19:40:36 <sorear> I.e.  you *will not* get a straight answer to "Is haskell better than Language-X?"
19:40:50 <monochrom> I guess "x := 1" is more concise than "writeIORef x 1" :)
19:40:53 <mbishop> Is haskell 98 better than haskell'?
19:40:54 * mbishop runs
19:41:16 <sorear> monochrom: (=:) = writeIORef ; infix 1 =:
19:41:16 <mgsloan> you'll find that the masses don't really select the best method, but rather what has managed to best assert itself as a good method.  OOP happens to be very viral because it appears to give you things it really doesn't.  A similar attraction applies to XML...
19:41:22 <monochrom> I don't think anyone is asking "is haskell better than ___".
19:41:43 <monochrom> But it doesn't hurt if I chip in "haskell is the finest imperative language of the world" :)
19:42:06 <mbishop> language advocacy is kind of silly
19:42:19 <sorear> ?goo Why I Hate Advocacy
19:42:20 <mgsloan> why?
19:42:23 <lambdabot> http://www.perl.com/pub/2000/12/advocacy.html
19:42:23 <lambdabot> Title: perl.com: Why I Hate Advocacy
19:42:37 <sorear> ^^^ read this (unless you already have)
19:43:08 <qwr> mgsloan: oop is nice way for namespaces ;) but the behavioral inheritance stuff in OO usually sucks ;)
19:43:17 <caverdude> hrm
19:44:14 <caverdude> well, what are two main differences in haskell and c?
19:44:20 <caverdude> just curios?
19:44:29 <caverdude> or basic or pascal for that matter
19:44:35 <sorear> haskell is pure - no update operations
19:44:47 <qwr> pure and lazy...
19:45:24 <caverdude> what does pure mean?
19:45:27 <sorear> haskell has a very strong polymorphic type system
19:45:34 <caverdude> means you start your app by calling a funtion?
19:45:49 <mgsloan> pure = function results depend only on the inputs, and the function has no side effects
19:45:52 <mbishop> pure means it doesn't have side effects (unless you really force it)
19:46:10 <mgsloan> my def is better :)
19:46:21 <mbishop> yes it is :[
19:46:24 <monochrom> I recommend http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell for a quick and comprehensive tour.
19:46:27 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki, http://tinyurl.com/y6cbnf
19:46:28 <sorear> there are some extremely clever tricks used to handle IO, but those are best not worried about until much later.
19:46:32 <scw> rafan: 啊災 就從 examples/gpg.rc copy 來的吧 @@
19:46:41 <mgsloan> if the function has an IO return (it is an IO action) it can have side effects
19:46:42 <scw> err... sorry
19:47:41 <caverdude> well I probably won't start haskell programming soon
19:47:47 <caverdude> just wondered what it was about
19:47:51 <mgsloan> also, functions are first class.  This is sort of like how you can pass function pointers, but better
19:48:14 <sorear> and remember, haskell has one of the best communities anywhere - try it, if you get stuck, don't hesitate to ask
19:48:20 <caverdude> if you don't have class definitions then how can it be strognly typed or polymorphic?
19:48:34 <mgsloan> yeah, imagine if you asked a comparison of c and basic on #c
19:49:19 <qwr> caverdude: if you wish to do it in future, i'd suggest start reading/experimenting a bit now... it seems to take some time to adjust the thinking
19:49:20 <mgsloan> ah, we have data types.  they aren't classes. they're better.
19:49:23 <mbishop> no other language has dons...you can't compete without dons
19:49:28 <monochrom> Here is how I declare a kind of binary tree data structure.
19:49:30 <mgsloan> data Bool = True | False
19:49:46 <sorear> C is strongly typed, but you have to break the type system (by using typedefs rather than structs) to get anything done.
19:49:50 <caverdude> mgsloan:  is this what pascal called records?
19:49:59 <sorear> very much like, yes
19:50:03 <monochrom> data TreeOfInt = Null | Inner Int (TreeOfInt) (TreeOfInt)
19:50:10 <sorear> Haskell supports parametric polymorphism
19:50:29 <sorear> :t let firstArg x y = x in firstArg
19:50:31 <lambdabot> forall t t1. t -> t1 -> t
19:50:33 <mgsloan> key to understanding monochrom's stuff is that the first word on each side of the | is the name of the constructor
19:50:54 <monochrom> Here is a typical tree given that declaration:  Inner 10 (Inner 5 Null Null) (Null)
19:50:57 <sorear> i.e. firstArg will work on ANY two types t and t1
19:50:58 <mgsloan> And the rest is the fields
19:51:21 <monochrom> Here is a function that returns the sums of the numbers in a tree:
19:51:52 <sorear> It's kinda like C++ templates, but easier since you don't have to declare the types.
19:51:53 <mgsloan> you can also name your fields, which basically just gives you accessors - data TreeOfInt = Null | Inner {treeVal :: Int, left, right :: TreeOfInt}
19:52:02 <monochrom> sumNodes Null = 0; sumNodes (Inner x left right) = x + sumNodes left + sumNodes right.
19:52:37 <sorear> You can have types parameterized by types - data Tree a = Null | Inner a (Tree a) (Tree a)
19:52:50 <monochrom> Now you are still dissatisfied because you don't want trees of ints.  You want trees of anything.
19:53:02 <monochrom> which is what sorear is just doing.
19:54:04 <sorear> In C you would need to have tree_of_int, tree_of_double, etc, and duplicate lots of code.
19:54:14 <monochrom> The 'a' there is a type variable.  Like c++ templates.
19:54:26 <sorear> Or, you could have tree_of_void_pointer, but that involves unsafe casting.
19:54:45 <mgsloan> takes a while to get used to all of this stuff, especially after programming in crappier languages (still haven't finished that language advocacy thing), but its well worth it, even if you have to go back to those old langs - stretches your brain in a very good way
19:55:14 <monochrom> A tree full of ints has type "Tree Int".  A tree full of doubles has type "Tree Double".  Yes, we are strong in homogeneous collections and weak in heterogeneous collections.  The latter is possible but advanced.
19:55:55 <qwr> > let { f (Just x) = x; f Nothing = "none" } in f Nothing ++ " " ++ f (Just "test")
19:55:57 <lambdabot>  "none test"
19:56:42 <qwr> and data Maybe a = Nothing | Just a
19:56:49 * zeeeee wishes for: genutil `union` missingh `union` futility
19:57:24 <monochrom> I now generalize the "sumNodes" function.  There are two dimensions to generalize.  The first dimension is the type in the keys, i.e., from TreeInt to Tree a.  The second dimension is from adding to arbitrary binary operators/functions.  I perform both generalizations in one go so as to confuse you!
19:57:29 <liyang> or you could have a tree of either Ints or Doubles: Tree (Either Int Double)
19:58:26 <mgsloan> ah well, heres the thing, I'm not a haskell advocate - its got its practical and theoretic faults
19:58:27 <sorear> Tree (Tree Int) <- or a tree of trees
19:58:31 <iulus> or a tree of trees of ints, to complicate things: Tree (Tree Integer)
19:58:39 <iulus> I'm too slow
19:59:46 <monochrom> accumNodes op initialvalue Null = initialvalue; accumNodes op initialvalue (Inner x left right) = x `op` (accumNodes op initialvalue left) `op` (accumNodes op initialvalue right)
20:00:12 <sorear> then you could use accumNodes (+) 0 my_tree
20:00:42 <sorear> in C++, you can overload the standard operators.
20:00:54 <mgsloan> hmm, tree of trees has a cool 3d visualization
20:00:54 <liyang> is caverdude still listening?
20:00:55 <sorear> ever wished you could define brand new ones?
20:01:09 <sorear> I was wondering the same thing...
20:01:17 <mgsloan> liyang - dunno. apparently we like to yammer though
20:01:27 <liyang> Yes. :)
20:04:52 <mgsloan> Caverdude - anyway, remember the language if you find yourself seeking to broaden your scope as a programmer
20:05:35 <quazimodo> hi guys
20:06:07 <sieni> hi
20:06:34 <quazimodo> now that i got haskell wokring, im having problems with my damn laptop connecting in adhoc to my win2k machine :(
20:06:43 <quazimodo> i ave no idea what ips and masks im meant touse
20:07:55 <monochrom> on win2k enable "internet sharing" or something.  then dhcp should be able to finish the rest.
20:08:50 <quazimodo> will the dhcp give this computer a correct ip?
20:09:08 <quazimodo> because my network already has a 192.168.0.1 router supplying internet to the 2k box
20:09:08 <monochrom> yes
20:10:55 <monochrom> On second thought, I weaken that to "I hope". :)
20:11:27 <dylan> ihope?
20:11:34 <audreyt> iHope?
20:11:41 <dylan> @time ihope
20:11:43 <lambdabot> Local time for ihope is Thursday, December 28, 2006 11:05:42 PM
20:11:50 <ihope> Mmh?
20:12:04 <monochrom> You people are naughty.  You make me hungry.
20:12:12 <ihope> See, it's late.
20:12:23 <dylan> monochrom: I always think of iHOP when I see ihope :)
20:12:26 * monochrom looks for someone downstairs to eat.
20:12:26 * ihope almost slaps dylan, then falls asleep
20:12:30 <liyang> My friend would walk up to strangers at random shouting `Stand and deliver!' I tried to tell him to stop, but he was adamant. :(
20:13:01 <Adamant> was not!
20:13:04 <monochrom> Your friend is Adamant?  *duck*
20:13:37 <Adamant> I'm Adamant, and I don't even know this guy!
20:13:49 <Adamant> :)
20:14:00 <allbery_b> adamant about not knowing him, evidently :>
20:14:49 <Adamant> who's on first, what's on second, I don't know is on third!
20:15:22 <dylan> Why?
20:15:38 <Adamant> exactly!
20:16:06 <dylan> No, Why's on left field.
20:16:30 <dylan> Now, what is the man's name on center field.
20:17:10 <Adamant> ah, I can't do more than that, sadly.
20:17:20 * sorear crawls under a rock and aims his STGmachine
20:19:20 <monochrom> Shoot That Guy machine?
20:19:53 * monochrom has found a crab fisherman and a chicken farmer to eat.
20:20:45 <monochrom> The crab fisherman is deep-fried so that even his bones are brittle and edible.
20:20:47 <sorear> I suggest only killing one just now
20:21:06 <monochrom> The chicken farmer has been made into a chicken farmer pie.
20:21:43 <monochrom> I guess it's too late to save one of them.  But thank God there is always the fridge!
20:21:50 <liyang> I prefer shepherds.
20:22:00 <monochrom> heeheehee
20:23:10 <GsD_CeleborN> [dcoutts__]: hello ?
20:23:37 <sorear> random civilians these days have such an irrational hatred of those who eat the same species :(
20:30:10 <GsD_CeleborN> how register a pakagen in ghc ? which file should use ?
20:30:23 <GsD_CeleborN> ghc-pkg ....
20:31:32 <sorear> ./Setup.lhs register --inplace --user
20:59:30 <Chad_> hey -- if i'm using a structure in a state monad, how can i update a single value from that structure?
20:59:36 <Chad_> i'd rather not have to do something like,
20:59:52 <Chad_> (a,b,c,d,e) <- get
21:00:16 <allbery_b> look at gets and puts, or modify for more complicated stuff
21:00:32 <Chad_> and then put the abcb, with a modified e
21:00:37 <GsD_CeleborN> [dcoutts__]: hi
21:00:56 <SamB_XP> also look into using more descriptive types, it really helps
21:01:11 <kpreid> record syntax would help somewhat
21:01:17 <allbery_b> use a record type, so you can do nice stuff like gets by name
21:01:18 <kpreid> allbery_b: puts doesn't exist
21:01:20 <sorear> GsD_CeleborN: I think your autogreeter needs fixing
21:01:36 <allbery_b> yeh, I stopped ot think about it and realized you need modifyt because records don't do updates nicely :/
21:01:46 <allbery_b> byut yu can use modify with record update syntax
21:01:51 <kpreid> but with a record it still at least doesn't mention the other elements
21:02:24 <kpreid> modify (\st -> st { e = newValue })
21:03:37 <GsD_CeleborN> [sorear]: I'm trying install the gtk.0.9.10.3
21:04:02 <GsD_CeleborN> [sorear]: on minGw
21:04:18 <Chad_> allbery_b: oooh, you're right-- i think i remember a friend showing me that. Thanks!
21:04:49 <GsD_CeleborN> [sorear]: http://haskell.org/gtk2hs/gtk2hs-0.9.10.3.tar.gz
21:06:42 <monochrom> I am a moron!  I am learning FFI.  I have ccode.c on the C side and CCode.hs on the Haskell side.  Then I compile and get an error.  The message says a variable is undeclared and refers to ccode.c but I keep looking in CCode.hs and therefore keep saying "whadaya mean not found?"
21:07:00 <allbery_b> heh
21:07:01 <reppie> heh
21:07:16 <reppie> i do similar mistakes all the time
21:07:37 <monochrom> Guess it's not such a great idea to name the two files so closely :)
21:07:40 <reppie> i often waste HOURS like this
21:08:02 <reppie> for example, i edit files in the wrong directory
21:08:09 <reppie> and i wonder why the hell my code doesn't work
21:08:23 <monochrom> heh
21:08:46 * allbery_b kept doing that between the repo working copy and the running copy of a monitoring script the other week
21:09:02 <monochrom> I had to use "ghc -v" so as to let it break it to me "it's GNU C giving you that error message!!!"
21:10:13 <monochrom> excellentemto!  Now the compile works.
21:10:33 <monochrom> The program doesn't crash. :)
21:15:16 <lisppaste2> zeeeee pasted "how can i improve my first parser?" at http://paste.lisp.org/display/33603
21:22:47 <sorear> Hey!  Whose bright idea was it to have '\012' escapes use DECIMAL?  (C programmer of far too many years talking...)
21:22:54 <GsD_CeleborN> anybody install gtk-0.9.10.3 on mingw ?
21:25:12 <zeeeee> sorear: you could ask that about anything, not just char escapes
21:25:59 <allbery_b> decimal?!
21:26:05 * allbery_b *headdesk*
21:26:45 <bd_> > show $ chr 15
21:26:46 <lambdabot>  "'\\SI'"
21:26:50 <bd_> > show $ chr 12
21:26:52 <lambdabot>  "'\\f'"
21:27:03 <bd_> > ord '\012'
21:27:05 <lambdabot>  12
21:27:49 <sorear> NB: in C numeric character escapes use octal
21:29:01 <allbery_b> C, perl, python, and many other programming languages
21:29:48 <mbishop> allbery_b: get that email?
21:30:13 <sorear> so I just wasted 3min of disk time processing 2 gigabytes of data and spitting it out with formfeeds where newlines were desired. Sigh.
21:30:48 <allbery_b> mbishop: yep but sitting unopened; I went shopping again this afternoon and then got stranded by a bus, so I'm only just getting settled back into things :/
21:31:05 <ramza3> I am not doing this, but conceptually, would it make sense to design a language or DSL for web application development.  For example, it seems like apis should exist for this, but with the api approach it still seems difficult
21:31:44 <mbishop> stranded by a bus?
21:32:09 <sorear> you mean like Network.CGI?
21:32:13 <sorear> or HAppS?
21:33:22 <sorear> N.CGI IIRC is a DSEL using arrows to automatically manage client side state as if it were variables; I haven't heard enough about HAppS to describe it.
21:33:47 <allbery_b> "scheduled bus failed to arrive" (more correctly, arrived as I was getting off the connecting bus, 10 minutes ahead of schedule, and sped on past)
21:34:00 <allbery_b> and buses run once an hour or worse in that part of town
21:34:08 <SamB_XP> isn't there a rule against that?
21:34:16 <SamB_XP> you should complain!
21:34:56 <allbery_b> you'd think.  but, well, seems to be SOP.  next bus also came 10 min. early but that was less of a problem given I'd been waiting over an hour already
21:35:09 <allbery_b> that's how the local bus outfit does things :(
21:37:41 <mbishop> :/
21:58:39 <sorear> ?seen
21:58:40 <lambdabot> Lately, I have seen sorear.
22:40:56 <benja_> morning!
22:53:29 <zeeeee> anybody have feedback to give on my simple parser? http://paste.lisp.org/display/33603
22:54:09 <zeeeee> mainly i'm not sure if my approach to stateful programming is 'doing the right thing'
22:55:27 <zeeeee> the nearly-equivalent python version is at http://paste.lisp.org/display/33404
22:57:38 <benja_> one common pattern is to give the same name to a type and its sole constructor :=
22:57:50 <benja_> s/:=/:)
22:57:54 <zeeeee> is there any syntactic sugar for e.g. writing "string1 `startswith` string2"? (this actually flips startswith)
22:58:15 <zeeeee> benja_: i'm a bit lost on what you're referring to
22:58:26 <zeeeee> benja_: Software?
22:58:35 <sorear> zeeeee: have you seen Parsec?
22:58:47 <benja_> zeeeee: data Software = Software { ... } seems more usual
22:58:50 <zeeeee> sorear: yeah but it looked really 'low-level'
22:59:18 <zeeeee> sorear: i couldn't figure out how to express the logic in this parser using parsec
22:59:30 <zeeeee> sorear: then again, i am noob
22:59:59 <zeeeee> benja_: ah, gotcha... i was planning to be able to parse other kinds of Objects as well
22:59:59 <benja_> what's the diffdrence between urls=Nothing and urls=(Just [])?
23:00:12 <benja_> zeeeee: ok, fair enough :)
23:01:05 <zeeeee> benja_: oh, semantics - i wanted to differentiate between objects that have an explicitly empty list of urls (eg i couldn't find any homepage for this software) vs. laziness (ie i haven't bothered looking up the homepage, but it may exist)
23:01:15 <benja_> heh, (?:) is a nice idea :)
23:01:29 <benja_> zeeeee: ok
23:02:35 <zeeeee> sorear: do you believe that this is something i can write using parsec?
23:04:17 * zeeeee feels his python version is so much *nicer* (or at least more lucid and concise)
23:04:28 <benja_> you don't need the outer do in parseLines (but I see that you may want to keep it for stylistic reasons)
23:04:50 <zeeeee> benja_: ah, good point
23:04:56 <benja_> well, actually I's write, parseLines ... = unless (...) do
23:05:18 <benja_> or $ do if necessary (not sure)
23:08:15 <zeeeee> is this really the way to do stateful programming in haskell? it's pretty clumsy. i actually have to write a function (or at least a lambda) for each state update.
23:09:42 <benja_> well, actually yes it is :-/
23:10:41 <zeeeee> it looks like the current (known-to-be-lacking) record system is part of the problem, though i see no resolution to that issue in sight
23:10:43 <benja_> interesting that this is about the 4th time I've seen this come up here since I asked whether there was a shorter syntax for recors updates three days ago =)
23:10:58 <zeeeee> eg whatever happened to "A proposal for records in Haskell"
23:11:09 <zeeeee> benja_: really! huh...
23:11:19 <mgsloan> uh, haskell has records, and nice record updates
23:11:22 <ibid> why is a lambda clumsy?
23:11:36 <benja_> hm, I wonder if template haskell could provide bamd-aid
23:11:39 <benja_> band
23:11:44 <mgsloan> data Foo = Bar {blah :: foo}
23:11:47 <zeeeee> mgsloan, ibid: see that paper! :)
23:12:00 <zeeeee> 'paper'
23:12:45 <mgsloan> well, as the paper mentions the implementation cost was high
23:12:54 <zeeeee> mgsloan: that was the old proposal
23:13:11 <benja_> zeeeee: but I think there are ways to avoid shooting to the right margin as your code does :)
23:13:15 <zeeeee> mgsloan: alternatively...can you suggest how to fix my parser? :D
23:13:21 <benja_> let me see if I can twid it...
23:13:38 <sorear> ze{5}: parseLines can be rewritten much cleanerly using mapM_
23:14:09 <mgsloan> zeeeee: I'll take a crack
23:14:16 <mgsloan> is it actually broken or just messy?
23:14:25 <zeeeee> sorear: mapM_ can thread my state through iteration?
23:14:32 <zeeeee> *iterations
23:14:42 <zeeeee> mgsloan: well, see the python counterpart :)
23:14:46 <zeeeee> mgsloan: not broken
23:14:53 <zeeeee> mgsloan: just...clumsy
23:14:53 <sorear> ze{5}: yes!
23:14:57 <sorear> ?type mapM_
23:14:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
23:15:07 <sorear> mapM_ is basically a monadic foreach
23:15:29 <sorear> you would write a parseLine :: String -> State Object () function that handles one line
23:15:45 <sorear> then mapM_ will apply it to each line, threading state
23:15:46 <mgsloan> arg
23:15:55 <mgsloan> lisppaste just went down
23:16:25 <sorear> > runState (mapM_ (\x -> modify (x++)) ["one", "two", "three", "four"]) "initial" -- like this
23:16:26 <lambdabot>  ((),"fourthreetwooneinitial")
23:16:50 <mgsloan> ?type fmap
23:16:52 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
23:16:53 <sorear> so it starts with a state of "initial" and prepends each string
23:16:53 <zeeeee> sorear: thanks...that's actually a really nice way to think of it
23:16:59 <zeeeee> foreach
23:17:05 <zeeeee> mgsloan: http://rafb.net/p/3PZm8w75.html
23:17:06 <lambdabot> Title: Nopaste - simple parser, python version
23:17:31 <zeeeee> http://rafb.net/p/DImzg998.html
23:17:32 <lambdabot> Title: Nopaste - simple parser, haskell version
23:17:36 <mgsloan> can't fmap be used mostly interchangeably? (assuming monads implement functor)
23:17:42 <sorear> actually the really new GHCs (6.6 or darcs, I forgot which) have a forM_ that is mapM_ with the arguments reversed...
23:18:02 <zeeeee> sorear: i was just about to ask
23:18:03 <sorear> mgsloan: fmap == liftM  ,  fmap /= mapM
23:18:11 <mgsloan> oh
23:18:28 <zeeeee> sorear: if there was a standard 'for' or 'foreach' or some syntactic sugar
23:18:36 <quazimodo> should i be able to just do this in ghci Prelude> someFunction = "somestring" ?
23:18:37 <mgsloan> well, for IO I thought sequence_ was more like foreach
23:18:45 <quazimodo> it gives me an error when i do things like that
23:18:52 <mgsloan> no, you can't
23:18:54 <sorear> quazimodo: let someFunction = "somestring"
23:19:01 <quazimodo> thank you
23:19:04 <mgsloan> we actually had a discussion about this earlier, ghci really sucks
23:19:16 <quazimodo> do i need that in the .hs files?
23:19:20 <sorear> no
23:19:22 <mgsloan> you have to do let someFunction = "somestring" in someExpr
23:19:26 <zeeeee> @type forM_
23:19:27 <lambdabot> Not in scope: `forM_'
23:19:29 <quazimodo> ok
23:19:29 <sorear> that's hugs
23:19:33 <zeeeee> ah
23:19:33 <mgsloan> the problem is that ghci prompt takes expressions
23:19:40 <sorear> GHCi lets you use let x = y
23:19:41 <mgsloan> no, both, I'm pretty sure
23:19:45 <mgsloan> really...
23:19:51 <sorear> it works in mine
23:19:58 <mgsloan> so it does
23:19:59 <quazimodo> in all the other languages you have to declare variables, is that the case in haskell?
23:20:07 <mgsloan> even more reason for ghci to support all declerations then
23:20:14 <quazimodo> becuase
23:20:19 <sorear> declare ?
23:20:22 <mgsloan> quazimodo: no, most variables are inferenced
23:20:30 <sorear> you have to define them of course
23:20:35 <quazimodo> making functions seems oddly familiar to making varibales in other lanugages
23:20:40 <sorear> what does declare mean
23:20:43 <mgsloan> you can have annotations, which will improve your error messages
23:20:45 <mr_tenor> we have variables?
23:20:49 <mgsloan> and probably compile times
23:21:02 <mgsloan> mr_tenor - most decidedly yes
23:21:06 <zeeeee> mr_tenor: yeah
23:21:11 <mgsloan> do the variables of math really vary?
23:21:15 <quazimodo> im not sure im just running through haskell trying to learn things
23:21:59 <mgsloan> hmm, yeah, its similar when you have constant functions
23:22:00 <mr_tenor> i thought "let" just assigned a name to some pending computation, rather than "evaluate and store somewhere" or whatever
23:22:00 <quazimodo> actually, would it be considered a normal thing to do with haskell to build say a clone of xchat?
23:22:08 <sorear> yes
23:22:16 <sorear> Its on my todo at least
23:22:26 <sorear> mgsloan: lisppaste is back up
23:22:29 <quazimodo> sorear, to build an xchat clone in haskell?
23:22:36 <zeeeee> mr_tenor: sure. then that pending computation/computed value is what the variable represents
23:22:49 <mgsloan> mr_tenor: well, assigning a name to a pending computation is basically what all function declerations are :)
23:23:13 <mr_tenor> zeeeee, mgsloan: i guess i'm thinking "state" as part of the definition of "variable"
23:23:19 <sorear> q-m: yes (not neccessarily xchat, but *shudder in dread* at some of the code in ircii)
23:23:34 <mgsloan> gday indeed
23:24:22 <zeeeee> sorear: ...why?
23:25:12 <sorear> try a 2 paragraph comment justifying the sufficiency of a fixed size buffer
23:25:30 <mr_tenor> is it a good justification?
23:25:55 <sorear> yes, but in any decent language a variable sized buffer would require less than 2 paragraphs and need no justification
23:26:29 <quazimodo> haskell is really weird :/
23:26:38 <quazimodo> you use a variable so oddly
23:26:44 <quazimodo> no $ or anything
23:26:52 <quazimodo> and by variable i do mean an argument
23:27:20 <mgsloan> ah, you're a post-perl/basicer then?
23:27:27 <mr_tenor> haskell is a mammal
23:27:36 <mr_tenor> haskell is lazy ALL the time
23:27:37 <mgsloan> yes, it is a completely different paradigm
23:28:57 <quazimodo> mgsloan, i learnt php and c more than anything
23:29:06 <mgsloan> ah, forgot about php
23:29:13 <quazimodo> i think in terms of memory location :/
23:29:21 <quazimodo> pointers and the like
23:29:36 <mr_tenor> quazimodo: that's what the compiler's for, in a HLL :)
23:29:37 <sorear> sure, you can think in terms of memory location in haskell
23:29:59 <sorear> usually you don't
23:30:02 <quazimodo> memory locations is fiddly
23:30:25 <mgsloan> haskell basically forces you to code really really good C, and gives you higher metaphors for said code
23:31:31 <araujo> :-)
23:31:50 <quazimodo> im scared
23:32:01 <mgsloan> and does all the housekeeping required to write all that really really good C.... it would be a lot
23:32:06 <quazimodo> i want a girl to make "happy time" with so i wont be scared :
23:32:21 <mgsloan> probably like 20 C lines to a haskell line
23:32:29 <mr_tenor> quazimodo: i hae not seen such a comment on #haskell before...
23:32:44 <quazimodo> mr_tenor, too many nerds :/
23:32:46 <quazimodo> :P
23:33:07 <mgsloan> I said "hot lambda secks" yesterday
23:33:23 <mr_tenor> you mean "sets"?
23:33:38 <zeeeee> the pain.
23:34:21 <mgsloan> zeeeee: your code seems good, and shorter overall than the python - most of the extra is just dealing with the added strictness
23:34:27 <mgsloan> I think I can make a few annotations
23:34:57 <zeeeee> mgsloan: shorter than the python??
23:35:08 <mgsloan> bah, down again
23:35:15 <mgsloan> yeah, if you look at the main parse routine
23:35:27 <mgsloan> python cheats by not having you declare datatypes
23:35:52 <quazimodo> can list comprehension have lots of complex rules?
23:36:40 <quazimodo> such as [c|c<-foo,c/="bla",c/="2",c/=someFunction]
23:36:41 <quazimodo> >
23:36:43 <quazimodo> ?
23:36:55 <sorear> should work
23:37:04 <quazimodo> good
23:37:22 <mgsloan> ,packages :: Maybe [String], commands :: Maybe [String], urls :: Maybe [String] can be packages, commands, urls :: Maybe [String]
23:37:44 <mgsloan> if you really want something like your original python we could probably compress down the haskell a bit
23:38:38 <zeeeee> mgsloan: i thought what i had *is* like my python... :/
23:38:55 <lisppaste2> benja_ annotated #33603 with "if you want it your way, make your way an embedded DSL :-)" at http://paste.lisp.org/display/33603#1
23:39:38 <benja_> note: not tested because I'm writing this on my cell phonne :)
23:40:21 <quazimodo> why does [c | c <- fart, c /= ' '] work but [c | c <- fart, c /= " "]
23:40:23 <quazimodo> doesnt
23:40:49 <quazimodo> what is the difference between " and ' here
23:40:49 <quazimodo> ?
23:40:50 <integral> quazimodo: ' ' :: Char, " " :: String.  And c :: Char
23:40:57 <benja_> hmm, that 'do' I'm using won't work
23:40:58 <quazimodo> oh
23:41:01 <zeeeee> benja_: zomg...that's pretty slick! very parsec-y
23:41:20 <benja_> will need to make the 'modify's explicit perhaps
23:41:25 <quazimodo> integral, then [a | a<-foo, a/='blah'] wouldnt work?
23:41:33 <goltrpoat> so i just realized something..  with all the book discussion on cafe, one thing that would be incredibly useful would be an ocw-style set of *courses*.  with readings and assignments and such.  covering everything from a hello world to applied category theory.
23:41:35 <integral> quazimodo: obviously
23:41:49 <quazimodo> hrm this function is a bit more compelx than i thought
23:41:57 <mr_tenor> feed [c | c <- "fart", c /= " "] to lambdabot orghci and it'll give you a nice message
23:41:57 <goltrpoat> that's also one of those things that can be easily collaborated on.
23:41:59 <quazimodo> i thought the c was simply a random variable choice like i
23:42:07 <goltrpoat> (easier than a book, anyway)
23:42:16 <mr_tenor> quazimodo: but c <- "fart"
23:42:26 <benja_> ...and should be 'if g y then h y ...' in runCase, but you get the idea :)
23:42:26 <quazimodo> mr_tenor, ?
23:42:26 <mr_tenor> so it gets bound to the type of one of the list elements
23:42:43 <mr_tenor> like if you go x <- [1,2,3], then x will be an integer
23:42:43 <quazimodo> so it is a random variable choice
23:43:08 <quazimodo> ok ok i get it
23:43:45 <quazimodo> so [a | a<-foo, a/='blah'] wouldnt work becase a is a char type here now and it is wrong anyway due to using 'blah' right? if it was a/=' ' then it would be good?
23:43:52 <mr_tenor> Coming to a strongly typed language with type inference from C and PHP, which sorta have no types, might be an interesting experience =)
23:44:02 <zeeeee> benja_: hmm...the code is actually *longer* now :/
23:44:39 <quazimodo> mr_tenor, no its ok :)
23:44:44 <quazimodo> i just need to learn these little things
23:44:56 <zeeeee> benja_: but i guess at least the parseLines bit is cleaner
23:45:08 <quazimodo> by the way, the string handling of haskell has suddenly become amazingly awsome :/ it is better than sed and awk...
23:45:22 <quazimodo> well, its nicer to me
23:45:28 <mr_tenor> > [c | c <- "fart", c /= " "]
23:45:30 <lambdabot>  Couldn't match `Char' against `[Char]'
23:45:34 <mgsloan> whoah whoah whoah
23:45:38 * mgsloan starts thinking
23:45:44 <mgsloan> why do you need Maybe [String]
23:45:51 <zeeeee> mgsloan: which part
23:45:53 <mgsloan> because [String] already includes []
23:45:58 <mgsloan> all of them, pretty much
23:45:58 <mr_tenor> quazimodo: ah, the ghci error is better than lambdabot's terser version :)
23:46:36 <zeeeee> mgsloan: oh, semantics - i wanted to differentiate between objects that have an explicitly empty list of urls (eg i couldn't find any homepage for this software) vs. laziness (ie i haven't bothered looking up the homepage, but it may exist)
23:46:43 <mr_tenor> quazimodo: you're using ghci, right?
23:46:47 <quazimodo> mr_tenor, you use " " instead of ' '
23:46:49 <goltrpoat> Maybe [String] means we care about empty strings, and we want to differentiate those from a terminal object of some sort (that we also care about)
23:46:52 <mgsloan> oh
23:46:54 <benja_> zeeeee: yeah, that can happen, code getting longer if you have to create auxiliary functionality to make it cleaner =)
23:46:56 <quazimodo> > [c | c <- "fart", c /= ' ']
23:46:57 <lambdabot>  "fart"
23:46:59 <goltrpoat> er.  empty lists of strings.
23:47:02 <zeeeee> mgsloan: but that only saves one line
23:47:05 <zeeeee> mgsloan: (that change)
23:47:12 <zeeeee> mgsloan: we'd no longer need ?:
23:47:18 <mgsloan> right
23:47:22 <benja_> happened to me recently when I made a clean version of some really convoluted c.ode
23:47:46 <quazimodo> can we grab any c in "fart" ?
23:47:52 <mr_tenor> quazimodo: see, there's no /= that has the type Char -> [Char] -> Bool.
23:48:16 <quazimodo> mr_tenor, i dont understand that yet,
23:48:23 <goltrpoat> quazimodo:  the list comprehension with c /= " " as the guard is asking to compare characters c against strings " "
23:48:27 <quazimodo> Char [Char] ?
23:48:45 <quazimodo> so that would become either a false or just not work?
23:49:01 <mr_tenor> well, no such "/=" exists
23:49:05 <goltrpoat> quazimodo:  it won't typecheck, because of what mr_tenor said
23:49:09 <quazimodo> so it falls apart
23:49:19 <quazimodo> because the /= that we have cant do that
23:49:20 <goltrpoat> right, doesn't compile.
23:49:52 <mr_tenor> @type /=
23:49:54 <lambdabot> parse error on input `/='
23:49:58 <mr_tenor> bugger
23:50:03 <allbery_b> @type (/=)
23:50:04 <lambdabot> forall a. (Eq a) => a -> a -> Bool
23:50:07 <mr_tenor> ah :)
23:50:33 <allbery_b> so it requires that both arguments be the same type and that that type implement "Eq"
23:50:45 <goltrpoat> quazimodo:  have you read YAHT yet?
23:51:02 <quazimodo> Yacht?
23:51:06 <quazimodo> nope :/
23:51:09 <allbery_b> ?where YAHT
23:51:09 <quazimodo> :P
23:51:10 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:51:10 <sorear> ?where yaht
23:51:10 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:51:30 <allbery_b> ("Yet Another Haskell Tutorial")
23:51:34 <quazimodo> oohhh
23:51:37 <quazimodo> yeh i have looked at it a bit
23:51:40 <quazimodo> im looking at another thing atm
23:51:46 <quazimodo> 2 dozen examples tutorial thingo
23:51:55 <quazimodo> likes hugs but it is working for me none the less, i am learning
23:52:08 <quazimodo> btw i think i have a feeling i know why you guys are so ready to deal with me and put up with noob questions
23:52:18 <mr_tenor> quazimodo: get ghci
23:52:21 <sorear> oooh?
23:52:23 <quazimodo> your program so fast compared to other language users that you have time to mess around?
23:52:27 <goltrpoat> haha
23:52:41 <quazimodo> mr_tenor, i have it :) took a day and a bit to make it work
23:53:05 <goltrpoat> it's the goodness of our hearts and the saintly lives we lead.
23:53:08 <mr_tenor> it's not a joke... i rewrote something that took us months in C++ in haskell, and it took a few hours ;)
23:53:10 <sorear> ?remember quazimodo btw i think i have a feeling i know why you guys are so ready to deal with me and put up with noob questions ... your program so fast compared to other language users that you have time to mess around?
23:53:55 <goltrpoat> that's actually remarkably accurate, i just thought it was amusing.
23:54:16 <goltrpoat> haskell++
23:56:01 <goltrpoat> mrtenor:  we have this biggish scripting language for which i wrote a compiler in c++, initially.. and it was about 75% done, but ive been having to do a lot of contract work so i haven't had time to work on it.  that took me a good 3 months
23:56:13 <goltrpoat> i wrote the equivalent compiler in haskell in 4 days
23:56:39 <pejo> quazimodo, hey, we can't change the world if we use our sparetime to mess around!
23:56:46 <goltrpoat> that's probably a biased comparison, since compilers are just easier to write in functional languages, but still.  thought that was pretty insane.
23:57:04 <sorear> I man #haskell because the efficiency of haskell made me very bored.
23:57:19 <kilimanjaro> hello
23:57:22 <sorear> pong.
23:57:39 <tibbe> @yarr
23:57:40 <lambdabot> Har de har har!
23:58:00 <mr_tenor> yeah, it's like that... if only i could understand monads my transition away from imperative languages would be complete ;)
23:58:02 <kilimanjaro> will somebody help me steal the paper on "eager haskell" from http://portal.acm.org/toc.cfm?id=581690&type=proceeding&coll=portal&dl=ACM&part=series&WantType=proceedings&idx=unknown&title=unknown ? I don't have an acm membership
23:58:05 <lambdabot> Title: : Haskell '02, http://tinyurl.com/yy76xl
23:58:22 <kilimanjaro> mr_tenor: what are your questions about monads?
23:58:51 <mr_tenor> no good ones. i've been going over a bunch of tutorials and papers but i'm yet to reach an "aha!" moment
23:58:53 <xpika> what does haskell++ mean?
23:59:04 <kilimanjaro> haskell++ :)
23:59:05 <sorear> ?karma+ haskell
23:59:05 <benja_> I nowadays think that user interfaces are just easier to write in functional languages, but I haven't proven it yet :-/
23:59:05 <lambdabot> haskell's karma raised to 18.
23:59:05 <allbery_b> IME monads atr tough until you hav ethe "aha!" experience, then you wonder why you ever had trouble with them :)
23:59:11 <sorear> only silenly
23:59:18 <lisppaste2> mgsloan annotated #33603 with "feast your eyes" at http://paste.lisp.org/display/33603#2
23:59:30 <quazimodo> hey awsome
23:59:34 <quazimodo> i got a quote in your bot
23:59:36 <quazimodo> :D
23:59:37 <mr_tenor> yeah. like in math, seeing the definition doesn't let you know what they "look/feel/act like"
23:59:41 <quazimodo> *cheesy grin*
23:59:45 <allbery_b> and it doesn't help that people tend to start out with the IO monad, which is an atypical example
23:59:57 <quazimodo> this monad thing scares me
23:59:59 <kilimanjaro> starting out with a state monad is a good way imho
23:59:59 <quazimodo> i haev no idea what it is
