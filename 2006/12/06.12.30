00:00:27 <shapr> Okasaki compares laziness to self modifying code.
00:00:46 <sorear> well if you time flush to flush, it doesn't matter what the computation looks like
00:00:57 <sorear> normal order or mumbo jumbo order
00:01:05 <benja_> you may have to deepseq if you want to first do some computation and then take the time
00:01:14 * benja_ had that problem recently
00:01:32 <shapr> Even then, that won't necessarily match real world usage of the code.
00:01:45 <shapr> I prefer to understand the laziness of the code I'm using so I know ahead of time :-)
00:04:10 <shapr> I still have problems sometimes.
00:04:34 * shapr sleeps &
00:06:15 <benja_> shapr: better fg that
00:06:49 <benja_> you wouldn't want to do other stuff while sleeping
00:07:22 <allbery_b> sleepcoding?
00:07:40 * allbery_b suspects that explains some things.  like, maybe, java :>
00:08:26 <sorear> allbery_b: I know about Maybe and Jave, what is like?
00:08:49 * sorear fears he just asked a very stupid question
00:09:21 <allbery_b> the "maybe" wasn't significant :>
00:09:41 <glguy> How might I simulate C++'s break; in a for-loop while I'm using forM_ ?
00:09:56 <glguy> rewrite the loop to use explicit tail-recursion?
00:10:02 <glguy> with the break condition?
00:10:04 <glguy> ContT?
00:10:16 <sorear> tail recursion is equivalent to ContT, yes
00:10:23 <sorear> but ContT is overkill
00:10:36 <sorear> try using MaybeT
00:11:36 <sorear> don't worry about efficiency, things will group right-associatively, so that the entire tail of the list will be skipped in one step
00:11:44 <sorear> s/list/loop
00:12:02 <glguy> MaybeT isn't a standard Monad Transformer, is it?
00:12:37 <sorear> I think it is, but it is very easy to write, and you can always copy it from a monad transformer tutorial :)
00:12:44 <sorear> ?hoogle runMaybeT
00:12:44 <lambdabot> No matches found
00:12:58 * allbery_b doesn't see a MaybeT in the ghc libs
00:14:01 <sorear> I suppose IO-exceptions would *really* be overkill :)
00:14:30 <allbery_b> ErrorT?
00:14:30 <glguy> sorear: is ContT overkill because of the overhead
00:14:40 <glguy> or just because it's hard to understand
00:14:46 <mbrandt> has anyone successfully installed greencard on OSX with GHC 6.6?
00:14:58 <sorear> at least the latter
00:15:04 * allbery_b never got cgreencard working with 6.4.2, let alone 6.6
00:15:20 <allbery_b> ...anywhere
00:15:28 <mbrandt> bugger. How do you install hopengl then?
00:15:46 <allbery_b> ghc-extralibs?
00:15:46 <sorear> apt-get install libghc6-hopengl
00:16:14 <mbrandt> os x doesn't have apt-get. is there a source dist?
00:16:24 <allbery_b> the standalone hopengl is out of date, it's been folded in to the standard libs (then in 6.6 folded back out as part of the extralibs package)
00:16:25 <sorear> ./darcs-all --extra get ; make ; make install  # in the GHC HEAD repo
00:16:36 <allbery_b> you can download ghc-extralibs for osx
00:16:54 <dons> moin moin
00:16:54 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
00:16:56 <dons> ?uptime
00:16:57 <lambdabot> uptime: 8d 7h 34m 51s, longest uptime: 9d 2h 23m 6s
00:17:18 <mbrandt> thanks. I should be able to figger it out from that.
00:17:20 <sorear> moin dons
00:17:46 * dons is back in Sydney. mmm. 500 kms driving is tiring
00:18:05 <dibblego> dons, where from?
00:18:18 <dons> Armidale
00:18:24 <sorear> [ black, red, green, yellow, blue, magenta, cyan, white ] = map Color [0..7]
00:18:36 <sorear> nice and concise, but ...
00:24:22 <quazimodo> why does foldr have 3 arguments?
00:24:39 <benja_> ?type foldr
00:24:40 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
00:24:41 <sorear> it doesn't, it has 1, or 2, or 3, or 0
00:24:57 <sorear> depending on your interpretation of currying and folding
00:25:07 <sorear> I prefer 2, but it's a matter of taste
00:25:18 <benja_> the second argument is the start value of the fold, the third argument is the list to fold over
00:25:25 <sorear> I see foldr as the template of morphisms from a free monoid
00:26:16 <quazimodo>  so foldr func 0 a could be fine?
00:26:25 <quazimodo> which would spit out 0 if a was [] ?
00:26:39 <sorear> pass in the identity object in the to-monoid and a method for handling each symbol, it returns a morphism from the free monoid over a to b
00:26:45 <benja_> quazimodo: yup
00:26:58 <bd_> @pl \v -> foldr undefined v []
00:26:59 <lambdabot> id
00:27:13 <allbery_b> heh
00:27:14 <benja_> whoa :)
00:27:17 <bd_> clever
00:27:32 <benja_> @wp
00:27:32 <bd_> I didn't honestly expect that to work :p
00:27:35 <quazimodo> whats this whoa stuff?
00:27:36 <sorear> but then, I've always had this thing for abstract mathematical concepts
00:27:51 <benja_> still no world peace command :-(
00:28:11 <johnnowak> quazimodo: a list is basically a series of conses. for example, [1, 2, 3] is actually 1 : 2  : 3 : []. foldr replaces the conses with some other operator (roughly). the reason for three arguments is so you can replace the [] with something sensible.
00:28:14 <benja_> quazimodo: I'm impressed that lambdabot manages to convert that term to id
00:28:22 <bd_> @pl \k v -> foldr (undefined v) k []
00:28:23 <lambdabot> flip flip [] . flip (foldr . undefined)
00:28:32 <sorear> there is a shapr-summoning command, though ...
00:28:34 <bd_> tsk, was hoping for const :)
00:28:57 <quazimodo> benja_, what does that term mean?
00:29:26 <quazimodo> sorear, i need to increase my mathematics i think
00:29:31 <benja_> 'whoa'? I'm using it with the same meaning as wow :)
00:29:35 <lisppaste2> glguy pasted "my code using contT .. rather ugly" at http://paste.lisp.org/display/33687
00:29:38 <quazimodo> i know up to 2nd year mathematics in uni
00:29:44 <quazimodo> er you lamer
00:29:56 <quazimodo> i mean the pl \v -> foldr undefined v []
00:30:01 <benja_> =]
00:30:18 <benja_> pl means 'pointless' -- without lambdas
00:30:43 <sorear> ?list pl
00:30:43 <lambdabot> pl provides: pointless pl-resume pl
00:30:46 <benja_> so it converts the lambda into a form without lambdas, using (.) and fold and such
00:30:50 <sorear> ?list unpl
00:30:50 <lambdabot> pointful provides: pointful pointy repoint unpointless unpl unpf
00:30:55 <allbery_b>  @pl's optmizer was smart enough to recognize that with a null list, the foldr results in its initial value (v) so it substituted id for the whole expression
00:31:03 <benja_> @pointy id
00:31:04 <lambdabot> (\ a -> a)
00:31:10 <bd_> @pointy undefined
00:31:11 <lambdabot> undefined
00:31:19 <bd_> @pl \a -> undefined a
00:31:20 <lambdabot> undefined
00:31:22 <sorear> @pl's optimizer wasn't smart enough to notice that undefined x = undefined.
00:31:22 <lambdabot> (line 1, column 58):
00:31:22 <lambdabot> unexpected "="
00:31:22 <lambdabot> expecting variable, "(", operator or end of input
00:31:32 <benja_> @pointy head
00:31:33 <lambdabot> head
00:31:33 <quazimodo> not only dont i understand that
00:31:34 <allbery_b> :t undefined
00:31:36 <quazimodo> i really odnt understand that
00:31:36 <lambdabot> forall a. a
00:31:46 <sorear> curiously, eta-conversion is invalid
00:31:52 <allbery_b> undefined doesn't take an argument, so I suspect you broke the optimizer's assumptions
00:32:03 <bd_> allbery_b: undefined can be of type (a -> b)
00:32:05 <bd_> :)
00:32:17 <sorear> > undefined `seq` 2
00:32:18 <lambdabot>  Undefined
00:32:22 <sorear> > (\x -> undefined x) `seq` 2
00:32:23 <lambdabot>  2
00:32:28 <benja_> quazimodo: what part don't you understand? for example, (\x y -> y + x) can be written as (flip (+))
00:32:30 <sorear> Eta Conversion is Invalid.
00:32:30 <bd_> > undefined 4 "hello" '\NUL' map
00:32:31 <lambdabot>  Add a type signature
00:32:34 <bd_> XD
00:32:46 <sorear> PL changes code *meaning*, in rare cases.
00:32:58 <sorear> benja_: addition in Num is commutative
00:33:04 <benja_> > undefined 4 "hello" '\NUL' map :: Void
00:33:04 <sorear> ?pl flip (+)
00:33:05 <lambdabot>  Not in scope: type constructor or class `Void'
00:33:05 <lambdabot> (+)
00:33:05 <bd_> sorear: in the case of nontermination?
00:33:10 <benja_> > undefined 4 "hello" '\NUL' map :: ()
00:33:11 <lambdabot>  Undefined
00:33:16 <sorear> undefined terminates
00:33:23 <sorear> _|_ /= nontermination
00:33:31 <quazimodo> benja_, dw, too advanced, ill learn more from my tutorials and come back to it
00:33:38 <sorear> _|_ \issupersetof nontermination
00:33:40 <benja_> @pl \x y -> y + x
00:33:40 <lambdabot> (+)
00:33:40 <bd_> er, I mean, the invalidity of @pl; the only thing I can think of is maybe it converts terminating code into nonterminating somehow?
00:33:50 <sorear> > (\x -> undefined x) `seq` 2
00:33:51 <lambdabot>  2
00:33:54 <sorear> > undefined `seq` 2
00:33:55 <lambdabot>  Undefined
00:33:59 <sorear> ?pl \x -> undefined x
00:34:00 <lambdabot> undefined
00:34:16 <sorear> both terminate, with different answers
00:34:36 <sorear> (albeit the difference can only be observed from IO-monads like LB)
00:34:37 <benja_> ah well, but it can *still* be written as (flip (+)) ;-))
00:34:50 <bd_> ah, I see.
00:35:23 <allbery_b> hrm.  that bugs me a bit, actually.  I'd think in a strictly typed language (undefined a) would be illegal given its signature
00:35:28 <sorear> parametric seq puts a lot of corner cases into the Haskell semantics
00:35:41 <bd_> allbery_b: it's a maximally polymorphic type
00:35:44 <sorear> Once upon a time, seq had a more restrictive type
00:35:57 <bd_> sort of like +, only instead of being over Num, it's over all haskell types :)
00:36:05 <sorear> back then, eta conversion and shortcut deforestation were both valid
00:36:26 <benja_> > (undefined :: Int) []
00:36:27 <lambdabot>    The function `(undefined :: Int)' is applied to one arguments,
00:36:27 <lambdabot>   but i...
00:36:27 <sorear> now, they are both almost always valid
00:36:35 <benja_> > (undefined) []
00:36:36 <lambdabot>  Add a type signature
00:36:43 <benja_> > (undefined) [] :: Int
00:36:45 <lambdabot>  Undefined
00:36:53 <sorear> yes, seq can cause GHC to mis-optimize code.
00:37:02 * allbery_b thinks he gets it now.  still feels wrong though
00:38:36 <sorear> > 1 .|. 2
00:38:37 <lambdabot>  Add a type signature
00:38:43 <bd_> :t (.|.)
00:38:44 <benja_> that's misoptimistic
00:38:44 <lambdabot> forall a. (Bits a) => a -> a -> a
00:39:03 * sorear has remembered /msg exists
00:39:51 <glguy> ?hoogle modifyArray
00:39:51 <lambdabot> No matches found
00:43:32 <dons> quazimodo: you in Sydney?
00:44:18 <quazimodo> yes
00:44:20 <quazimodo> i go to your uni!
00:44:40 <quazimodo> pain in my scrotum too, near 2 hour commute each way
00:45:32 <quazimodo> why do you ask?
00:46:01 <quazimodo> foldr cant be infixed can it?
00:46:10 <quazimodo> or is there a trick that makes it infixable
00:46:15 <sorear> `foo`
00:46:17 <quazimodo> such as a `foldr b` c
00:46:25 <quazimodo> rahter, [c]
00:47:01 <sorear> ah, if only that worked :(
00:47:13 <sorear> `must_be_an_atom`
00:47:19 <quazimodo> lame
00:47:19 <glguy> breakable for loop: forM_' xs f = flip runContT return . callCC $ (forM_ xs . f) -- used like: forM_' xs $ \ break i ->
00:47:36 <quazimodo> sorear, would it be a decent idea to implement that whch i mentioned?
00:48:01 <sorear> glguy: nice
00:48:16 <sorear> q-m: yes, and it has been proposed many times
00:51:59 <quazimodo> someone in another channel had this to say about haskell syntax (he is a 4 year maths major too :/) "its cryptic, nonsensical and ghey"
00:52:06 <quazimodo> any replies he ought to recieve?
00:52:11 <quazimodo> receive?
00:52:14 <quazimodo> whatever
00:53:08 <benja_> "...but never boring"
00:53:21 <quazimodo> heh
00:53:26 <quazimodo> he learnt asm and c/c++ first
00:53:31 <sorear> me too
00:53:43 <sorear> Haskell is very good at compact.
00:54:08 <quazimodo> doesnt matter
00:54:14 <sorear> he should try writing a theorem prover in 590 characters of C++
00:54:19 <quazimodo> he is of the opinion he will never use his haskell or his maths major :/
00:54:23 <integral> The "and ghey" tends to discredit this person as having a brain.
00:54:40 <quazimodo> why?
00:54:49 <sorear> Use ?spell!
00:55:24 <quazimodo> ?spell ghey
00:55:26 <lambdabot> hey Grey they whey hgwy
00:55:30 <quazimodo> HAH
00:55:33 <quazimodo> POINTLESS
00:55:45 <quazimodo> ?spell fuzzwazzas
00:55:45 <lambdabot> fuzzballs fuzz's Swazis fizzes Swazi's
00:55:47 <sorear> ?pl ghey
00:55:47 <lambdabot> ghey
00:55:58 <sorear> expected as much :(
00:57:52 <benja_> ?spell thirreem proova
00:57:53 <lambdabot> theorem thirteen three thrum thorium
00:58:02 <benja_> not bad
00:58:38 <quazimodo> can someone point me to an example of a haskell program being really short, compared to a c program
00:58:45 <quazimodo> i havent found much in terms of googling for it
00:58:51 <Excedrin> quazimodo: quicksort?
00:59:00 <Excedrin> on the wikipedia article
01:00:23 <quazimodo> the wiki for quicksort?
01:00:55 <sorear> quazimodo: Do you think the world will be any better off if this obviously brainless person thinks he can 'help' Haskell?  I don't want his (yet).
01:01:11 <quazimodo> he is a good guy
01:01:17 <quazimodo> and i like sharing
01:01:21 <sorear> ok
01:02:00 <lisppaste2> glguy pasted "quazimodo: a Haskell version of quicksort written inplace, like you might in C" at http://paste.lisp.org/display/33688
01:02:25 <glguy> quazimodo: if you are going to compare quicksorts between C and haskell, you should make sure they both use the same algorithm :)
01:03:21 <sorear> actually the haskell version is quick*select*
01:03:27 <benja_> when I first came to haskell.org, it had this example program which was a weird string of unknown functions and operators to me, and said, This is quicksort in Haskell. Haskell is such a clear language that even non-programmers can understand immediately how it works.
01:03:35 <quazimodo> is that much shorter than a c version, written in c?
01:03:49 <sorear> no its longer
01:03:59 <sorear> now, let's compare binary tree sorts
01:04:02 <dons> benja_: hehe
01:04:07 <glguy> yeah, reading and writing mutable arrays in Haskell is verbose
01:05:00 <glguy> without really obfuscating the code I pasted, I don't knowa good way to trim it down
01:06:35 <benja_> to make it look more favorable, take the two-liner from haskell and translate that to c rather than the other way around :)
01:06:41 <glguy> heh
01:07:06 <benja_> proxy error from the paste bin :-/
01:07:56 <therp> good morning
01:07:56 <glguy> http://rafb.net/p/PfZNTw83.html
01:07:58 <lambdabot> Title: Nopaste - quicksort haskell inplace
01:08:02 <glguy> benja_: ^^
01:08:10 <sorear> good morning back, therp
01:08:10 <glguy> unless you were pasting your own
01:08:15 <glguy> then use the new paste link :)
01:08:37 <benja_> thx
01:10:10 <glguy> quazimodo: the Sudoku solver that Cale has posted on the wiki is probably a good example of code that is shorter in Haskell than C
01:10:19 <glguy> I don't know for sure, but it's pretty terse iirc
01:22:18 <therp> hm, 1,5 gb virtual memory footprint for my xemacs session. I think it's time for my weekly emacs quit.
01:23:33 <dons> heh
01:23:39 <vegai> benja_: hey! How's code?
01:24:26 <benja_> moi vegai! fenfire-hs can animate nodes on the screen and do text entry through a gtk widget
01:24:57 <benja_> currently there's no depth fading and no showing the nodes smaller when depth increases
01:25:04 <vegai> nice! You should consider updating the site a bit, perhaps
01:25:04 <benja_> that's what I'm working on
01:25:19 <vegai> last entry: "2004-09-28" :)
01:25:25 <benja_> visual bugs can look so funny when they're animated :-)
01:25:53 <benja_> vegai: yeah ... but first should get some functionality implemented :-) [I don't know if you noticed, but fenfire-hs is only about 2 weeks old)
01:27:00 <benja_> the sad thing is that we probably haven't released any interesting code since 2004-09-28 :-(
01:29:23 <benja_> the problem I'm fighting is that when I scale a vob, its translation gets scaled with it
01:29:34 <benja_> i.e. it's position on the screen
01:30:21 <vegai> vobs were amongst the things I understood the least :-/
01:30:36 <vegai> is the code public?
01:30:54 <benja_> http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs/
01:30:56 <lambdabot> Title: Index of /darcs/fenfire-hs
01:33:38 <benja_> all the abstractions are still in flux... but I think it has the first working version of vanishing view that I find readable :)
01:34:14 <lisppaste2> paolino annotated #33661 with "cleanedup" at http://paste.lisp.org/display/33661#1
01:42:04 <paolino> glguy, also that haskell quicksort is not easy to understand, it requires some monadic knowledge
01:50:04 <Syzygy-> qs (x:xs) = (less xs) ++ [x] ++ (more xs) where less xs = filter (<x) xs; more xs = filter (>=xs)
01:50:10 <Syzygy-> Isn't that a decent quicksort?
01:50:17 <Syzygy-> Hrm.
01:50:40 <Syzygy-> qs (x:xs) = (qs $ less xs) ++ [x] ++ (qs $ more xs) where less xs = filter (<x) xs; more xs = filter (>=xs)
01:52:01 <Syzygy-> Oh, qs [] = [] also needed
01:52:04 <wolverian> Syzygy-, parametrise more and less on the xs given to qs so you don't need to pass them again
01:52:11 <wolverian> a tad cleaner
01:52:21 <wolverian> er, unparametrise, I guess :)
01:52:28 <Syzygy-> wolverian: Point.
01:52:47 <benja_> Syzygy-: the context of the discussion was a haskell qs that uses the same algorithm as qs in C
01:52:52 <Syzygy-> How does it compare though? Is it a good quicksort implementation or just an easy one?
01:52:56 <Syzygy-> benja_: Ah. Right.
01:53:04 <Syzygy-> benja_: Isn't that missing the point?
01:53:07 <benja_> http://paste.lisp.org/display/33688
01:53:16 <wolverian> Syzygy-, also see partition
01:53:51 <benja_> Syzygy-: well, update-in-place is faster, and the context for *that* was comparing the size of equivalent programs in haskell and C :-)
01:54:09 <wolverian> just do a bottom-up mergesort
01:54:21 <wolverian> ;
01:54:30 * wolverian murders the enter key
01:54:38 <benja_> !
01:54:58 <wolverian> (it's what GHC does anyway)
01:56:50 <lisppaste2> metaperl pasted "do notation conversion help needed" at http://paste.lisp.org/display/33692
01:58:28 <metaperl> @type iterate
01:58:30 <lambdabot> forall a. (a -> a) -> a -> [a]
01:58:55 <metaperl> @type repeat
01:58:57 <lambdabot> forall a. a -> [a]
01:59:15 <metaperl> > repeat "help me please"
01:59:17 <lambdabot>  ["help me please","help me please","help me please","help me please","help m...
01:59:55 <metaperl> > repeat "do notation conversion help needed at http://paste.lisp.org/display/33692  .. :)"
01:59:56 <lambdabot>  ["do notation conversion help needed at http://paste.lisp.org/display/33692 ...
02:01:01 <benja_> @remember shapr Hey man, want to toke on a lambda? The first redex is free man!    [I've token on so many lambdas I'm getting dependent types!]
02:04:40 <TSC> metaperl: What's the problem?
02:06:19 <metaperl> TSC: "lis.hs:5:11: parse error on input `<-'"
02:07:05 <TSC> Get rid of the braces
02:07:13 <TSC> Or add semicolons
02:07:21 <TSC> I'd get rid of the braces, and use indentation
02:07:45 <metaperl> TSC - it works now. thanks
02:07:52 <TSC> No worries
02:13:59 <dancor> best way to find Data.Map key with the smallest value
02:14:39 <dancor> i guess convert to list and sort
02:15:04 <metaperl> isnt  finitemap preferred?
02:15:44 <dancor> don't i see notices that finitemap is deprecated when i compile stuff all the time?
02:15:46 <zeeeee> benja_: thanks!!
02:15:46 <lambdabot> zeeeee: You have 1 new message. '/msg lambdabot @messages' to read it.
02:20:53 <benja_> zeeeee: :)
02:23:08 <vegai> @hoogle sort
02:23:09 <lambdabot> List.sort :: Ord a => [a] -> [a]
02:23:09 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
02:23:09 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
02:23:15 <dons> dancor: findMin ?
02:23:32 <dons> -- | /O(log n)/. The minimal key of the map.
02:23:33 <dons> findMin :: Map k a -> (k,a)
02:23:39 <dons> ?docs Data.Map
02:23:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
02:25:28 <dancor> dons: i thought that was based on the key
02:25:33 <TSC> dancor: How about "Data.Foldable.foldr1 max" ?
02:25:42 <dancor> dons: i guess it's probably based on the value..
02:28:00 <dancor> > findMin $ fromList [(1, 100), (200, 2)]
02:28:01 <lambdabot>  Not in scope: `fromList'
02:28:10 <dancor> > findMin $ Data.Map.fromList [(1, 100), (200, 2)]
02:28:11 <lambdabot>  Not in scope: `Data.Map.fromList'
02:28:41 <dancor> it is based on the key.  no dice
02:29:44 <dancor> is there a version of Prelude.lookup that gives me both (k, a)
02:29:56 <dancor> probably not
02:31:21 <TSC> foldWithKey (\k v (mk, mv) -> if v < mv then (k,v) else (mk,mv)) (dummyKey, bigValue)
02:31:26 <TSC> ... is not very pretty ):
02:31:30 <dons> M.*
02:31:39 <dancor> > findMin $ M.fromList [(1, 100), (200, 2)]
02:31:40 <lambdabot>  Not in scope: `findMin'
02:31:45 <dancor> > M.findMin $ M.fromList [(1, 100), (200, 2)]
02:31:46 <dons> M.findMin
02:31:47 <lambdabot>  (1,100)
02:31:56 <dancor> i'm getting there :)
02:32:03 <dancor> M.gettingThere
02:33:09 <dancor> head $ sortBy (compare `on` snd) $ M.toList myMap  works for me
02:33:16 <wolverian> hum, F# looks like a real replacement for C#. yay.
02:33:52 <paolino> uhm, is there a function to "change" a list elem ?
02:34:02 <integral> :t \\
02:34:03 <lambdabot> parse error on input `\\'
02:34:22 <paolino> @type (\\)
02:34:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
02:34:59 <dancor> > [1..4] \\ [1..2]
02:35:00 <paolino> mmh I need to change it by index
02:35:01 <lambdabot>  [3,4]
02:35:09 <dancor> > [100..104] \\ [1..2]
02:35:10 <lambdabot>  [100,101,102,103,104]
02:35:46 <paolino> substitute an elem
02:36:08 <dancor> i think you have to make your own
02:36:11 <dancor> or use arrays
02:39:07 <dancor> > let subs l n v = let (x, y) = splitAt n l in x ++ [v] ++ init y in subs [1..4] 2 99
02:39:09 <lambdabot>  [1,2,99,3]
02:39:47 <dancor> > let subs l n v = let (x, y) = splitAt n l in x ++ [v] ++ drop 1 y in subs [1..4] 2 99
02:39:49 <lambdabot>  [1,2,99,4]
02:41:32 <paolino> subs n xs x = take n xs ++ [x] ++ drop (n+1) xs
02:41:44 <paolino> this is slower ?
02:42:23 <dancor> i don't know
02:55:04 <_matthew_> I don't suppose anyone here has much knowledge of game physics?
02:57:24 <mahogny_> what do you need to know?
02:59:03 <dancor> hm why would ghc tell me that M.notMember is not in scope
02:59:37 <dancor> > M.notMember 4 $ M.fromList [(4, 99)]
02:59:38 <lambdabot>  Not in scope: `M.notMember'
02:59:43 <dancor> > M.member 4 $ M.fromList [(4, 99)]
02:59:45 <lambdabot>  True
03:00:08 <dancor> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#t%3AMap
03:00:10 <lambdabot> http://tinyurl.com/ykdr3x
03:00:16 <dancor> is it lying?
03:00:22 <dancor> or maybe it's a 6.6 thing?
03:01:28 <mahogny_> _matthew_:
03:16:03 <metaperl> > [1..5] `liftM` (\n -> n*n)
03:16:04 <lambdabot>  Couldn't match `a1 -> r' against `[a]'
03:16:25 <metaperl> (\n -> 2*n) `liftM` [5..10]
03:16:44 <metaperl> > (\n -> 2*n) `liftM` [5..10]
03:16:46 <lambdabot>  [10,12,14,16,18,20]
03:17:18 <metaperl> @type map
03:17:20 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
03:17:22 <metaperl> @type liftM
03:17:23 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
03:17:42 <metaperl> @type fmap
03:17:44 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
03:18:43 <metaperl> is join automatically called by (>>=) ?
03:19:11 <metaperl> answer: yes - xs >>= f = join (fmap f xs)
03:20:19 <Yousef> hi all
03:21:01 <metaperl> Yousef - hi!
03:22:11 <Yousef> hi metaperl
03:22:45 <Yousef> what your name
03:23:02 <Yousef> where is your city
03:23:39 <ski> metaperl : solved the 'do'-conversion ?
03:23:51 <metaperl> ski - yes....
03:23:54 <metaperl> someone helped me
03:24:36 <Yousef> best pro body bilding
03:25:12 <Yousef> are you male
03:25:20 <lisppaste2> Templar2 pasted "IO input" at http://paste.lisp.org/display/33695
03:26:53 <Yousef> tell me about new sex web
03:27:54 <Yousef> metaperl?
03:27:57 --- mode: ChanServ set +o dons
03:28:03 --- kick: Yousef was kicked by dons (dons)
03:28:08 <benja_> @google haskell sexy types
03:28:11 <lambdabot> http://portal.acm.org/citation.cfm?id=997142&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618
03:28:11 <lambdabot> Title: Sexy types in action
03:28:13 <benja_> damn, too late
03:28:14 <lisppaste2> metaperl annotated #33695 with "heres a related example" at http://paste.lisp.org/display/33695#1
03:28:16 <dons> hehe
03:28:20 --- mode: ChanServ set -o dons
03:28:40 <Templar2> guess I cant put "y = getLine" right?
03:28:50 <lisppaste2> ski annotated #33695 with "use 'if'" at http://paste.lisp.org/display/33695#2
03:28:57 <dons> Templar2: you mean, assign the result of the getLine to the value 'y' ?
03:29:17 <dons> in which case, no. y = getLine creates a new function, 'y', which calls getLine
03:29:28 <metaperl> Templar2 - YAHT has some good examples of that sort of thing
03:29:30 <dons> main = do y <- getLine ; print y -- does work
03:29:45 <dons> you use <- to extract the result of an IO action
03:30:04 <Templar2> ok
03:30:25 <metaperl> ski that doesnt look recursive...
03:31:09 <ski> the original wan't either .. i just fixed the testing
03:32:56 <benja_> @where sex
03:32:57 <lambdabot> I know nothing about sex.
03:33:03 <benja_> @where+ sex http://www.eecs.harvard.edu/~ccshan/cs252/usage.pdf
03:33:03 <lambdabot> Done.
03:36:51 <metaperl> @type sequence
03:36:52 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
03:37:56 <metaperl> <quote>The sequence function takes a list of monadic computations, executes each one in turn and returns a list of the results. If any of the computations fail, then the whole function fails</quote>  ... that type signature doesnt look like it is a list of monadic computations, only monads.
03:41:12 <ski> 'm' is the monad
03:41:28 <ski> a value of type 'm a' is a monadic computation/action, in that monad
03:41:54 <metaperl> @type (>>=)
03:41:56 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
03:42:03 <metaperl> what does m a stand for here ski?
03:42:17 <ski> <ski> 'm' is the monad
03:42:24 <metaperl> and a?
03:42:31 <metaperl> a datum
03:42:37 <metaperl> not a computation/action, right?
03:42:40 <ski> <ski> 'm a' is the type of monadic actions/computations in monad 'm'
03:42:54 <metaperl> ski but that's my point
03:42:58 <metaperl> @type (>>=)
03:43:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
03:43:07 <metaperl> m a is a container for a datum here
03:43:16 <metaperl> [a] for instance
03:43:20 <metaperl> Maybe a for instance
03:43:21 <ski> you could call it container, in some cases, yes
03:43:36 <ski> other phrases are "computation","action"
03:44:31 <metaperl> but I dont understand how I could pass a series of containers to the sequence function and get back a list of "results" ... sequence [ Just 5 , Just 2 ]
03:44:36 <ski> >lookup 'a' [('c',89),('a',17),('b',23)]   -- this is a 'Maybe'-action/computation/container
03:44:39 <metaperl> for instance: [Just 5, Just 2]
03:44:39 <ski> > lookup 'a' [('c',89),('a',17),('b',23)]   -- this is a 'Maybe'-action/computation/container
03:44:41 <lambdabot>  Just 17
03:44:57 <metaperl> @type lookup
03:44:59 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
03:45:16 <ski> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
03:45:21 <metaperl> oh, they mean f such that f returns a monadic value
03:45:31 <ski> Nothing >>= _ = Nothing
03:45:40 <ski> Just a  >>= k = k a
03:45:45 <ski> in this case
03:45:53 <metaperl> they mean f such that f returns m a
03:46:08 <ski> what is 'f', here ?
03:46:15 <metaperl> they dont mean m a in the type signature for seqence. itwas wrong of nomaware and lambdabot to state that
03:46:26 <metaperl> f is a function which returns a monad
03:46:29 <ToRA> > sequence [Just 5, Just 2, Nothing, Just 3]
03:46:31 <lambdabot>  Nothing
03:46:39 <ToRA> > sequence [Just 5, Just 2, Just 3]
03:46:41 <lambdabot>  Just [5,2,3]
03:46:57 <metaperl> a real type sig for sequence would be [f] -> m [a]  such that f :: (   -> m a)
03:47:24 <ski> rather '[ -> m a] -> m [a]', then
03:47:27 <metaperl> Just is not a monadic "action" is it?
03:47:44 <dufflebunk> metaperl: a function with no parameters is identical, functionally speaking to the value it returns
03:47:47 <ski> 'Just 5' is a monadic action/computation/container, yes
03:48:15 <metaperl> dufflebunk - great point to make. thanks
03:48:28 <metaperl> dufflebunk - I had forgotten that perspective
03:49:40 <dufflebunk> I sometimes forget too, and get really confused.
03:49:54 <paolino> is there a way to contract this ?
03:49:55 <paolino>     rc = unzip ls
03:49:55 <paolino>     lr = length $ nub $ fst rc
03:49:55 <paolino>     lc = length $ nub $ snd rc
03:50:42 <dons> mm. should be. let's see...
03:53:16 <dons> its a bit late, so I might be wrong, but using an Arrow:
03:53:26 <dons> (lr,lc) = (f *** f) (unzip ls)
03:53:27 <dons>     where f = length . nub
03:53:58 <metaperl> ouch. too much haskell wizardry this early in the morning. i'm seeing stars
03:54:28 <metaperl> use the weenie version paolino - that dons stuff is too powerful
03:54:29 <joelr1> good morning
03:54:36 <metaperl> I like your weenie version man :)
03:54:40 <benja_> morning joelr1
03:54:45 <metaperl> joelr1 - good morning
03:54:54 <joelr1> dons: does yi support haskell layout?
03:55:11 * joelr1 plans to make 2007 the year of haskell
03:55:13 <dons> joelr1: nope. its just a vi.
03:55:15 <dons> *however* ...
03:55:19 <joelr1> 2006 was my year of lisp :D sort of
03:55:24 <joelr1> dons: however?
03:55:29 <dons> jyp has taken over some yi maintainership
03:55:36 <dons> has ported it to use the vty term lib
03:55:39 <dons> and is writing the gtk port
03:55:50 <dons> so hopefully we'll see some action on this front
03:56:02 <_matthew_> joelr1: thought you were planning to make 2007 the year of Erlang?
03:56:13 <dons> wasn't that 05?
03:56:19 <dons> :)
03:56:24 <joelr1> _matthew_: 2005 :) dons is right
03:56:27 <_matthew_> you should read joel's plans for his trading platform
03:56:42 <joelr1> _matthew_: trading, that's where haskell comes in
03:56:48 <_matthew_> *cough*
03:56:54 <_matthew_> I thought that was all Erlang?
03:57:06 <joelr1> dons: what's the vty term lib?
03:57:08 <_matthew_> esp given your recent questions on the erlang mailing list!
03:57:12 <joelr1> _matthew_: i like to confuse the competition ;)
03:57:26 <_matthew_> right...!
03:57:33 <dons> joelr1: a new pure haskell curses alternative, more suitable for writing editors than curses
03:57:39 <paolino> metaperl: I was waiting for an arrow
03:57:54 <metaperl> paolino - well then, youre the man :)
03:57:56 <joelr1> dons: i thought so
03:58:00 <metaperl> or the woman, I dont know
03:58:01 <_matthew_> joelr1: so can you not implement fix/fast/other-stuff fast enough in erlang, hence haskell?
03:58:11 <paolino> behind the wall
03:58:13 <metaperl> that would be paolina I imagine
03:58:19 <metaperl> what wall?
03:58:22 <joelr1> _matthew_: it's not a question of doing it fast, really. it's a question of what to do afterwards.
03:58:39 <paolino> it holed the wall and got my hat
03:59:04 <_matthew_> ok. But my knowledge is that the banks will want sub 10ms end to end
03:59:15 <joelr1> _matthew_: meaning that if you need to do analysis and such then you are stuck without arrays
03:59:49 <_matthew_> joelr1: right, I guess that makes sense
04:00:00 <joelr1> _matthew_: i want the same, really. i can colocate my systems in the exchange building for 1250 a month which will give me < 10ms bump over the exchange
04:00:27 <paolino> it all depends on the bow wood and the archer and dons is dangerous
04:00:30 <joelr1> _matthew_: plus, the approach i'm using now requires quick execution and reaction
04:00:50 <metaperl> a robin hood in disguise, yes he is :)
04:01:02 <_matthew_> right, but from the point your systems receive the trade order, to the point you can confirm it's bought/sold should be (I thought) < 10ms. including all processing and network hops
04:01:02 <joelr1> _matthew_: it's just that, again, arrays are a problem in erlang
04:01:38 <_matthew_> joelr1: ok, I only know a very small amount about this stuff and it's from the middleware perspective
04:01:40 <pejo> Naively I expect worst case execution time analysis to be tough in Hsakell.
04:01:46 <dcoutts__> dylan: I think there are already Haskell xcb bindings
04:03:04 <joelr1> _matthew_: yes, yes, i want to be super-fast. i know people do this in ocaml but i hate ocaml. i'm weird i think, i hate languages not for what they offer but for what they lack
04:03:47 <joelr1> _matthew_: gotta go see arthur and the minimutts :D kids! be back later to continue this wonderful discussion.
04:03:48 <dcoutts__> pejo: you're read the book on purely functional data structures? that coveres real time and amortised complexity analysis
04:04:07 <joelr1> _matthew_: haskell seems to be sort of a golden middle. i'm thinking yampa for trading systems.
04:04:07 <_matthew_> joelr1: ...right. we'll I'm certainly not going to pretend I understand the maths of financial analysis. cya
04:05:57 <pejo> dcoutts, on an abstract machine and counting operations, or something else?
04:06:51 <dcoutts__> pejo: counting operations yes, for collection data types like, trees, heaps, etc
04:07:02 <paolino> > let mapT f ls = (f *** f) (unzip ls) in mapT (length.nub) [(1,2),(1,3),(2,3),(1,4)]
04:07:03 <lambdabot>  (2,3)
04:07:32 <dcoutts__> it teaches you two different methods of amortised analysis, quite a nice book, readable and interesting
04:08:36 <benja_> dcoutts__: title? Purely Functional Data Structures? :-)
04:08:45 <dcoutts__> yep
04:08:52 <dcoutts__> @google Purely Functional Data Structures book
04:08:56 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
04:08:58 <xerox> > ((. unzip) . join (***)) (length.nub) [(1,2),(1,3),(2,3),(1,4)]
04:08:59 <lambdabot>  (2,3)
04:09:07 <dons> mm. should readFile' be in the base libraries?
04:09:17 <dcoutts__> dons: what does the ' signify ?
04:09:18 <benja_> (I should get it from the library since I invented a data structure yesterday and need to figure out at some point how to analyze its performance...)
04:09:32 <dcoutts__> benja_: good idea
04:09:32 <pejo> dcoutts, the book is good, no doubt about that. I'm not convinced the analysis takes it all the way though.
04:09:36 <dons> strictness. I think readFile/openFile/hClose issues come up too often.
04:09:41 <dons> for beginners
04:09:53 <dcoutts__> dons: oh, to read the whole lot non-lazily.
04:10:20 <dons> yeah. for those file shuffling problems people write scripts for :)
04:10:52 <dcoutts__> dons: we could use mmap to make it less painful I think
04:11:12 <dcoutts__> dons: so for small files just read it in, for big ones mmap and then close the file
04:11:17 <dcoutts__> which works iirc
04:12:03 <benja_> do you really type it so often that readFileStrict is unacceptable?
04:12:54 <dons> benja_: I suppose that's more sensible
04:13:04 <benja_> [hmm, why don't I think mmap is to monads what fmap is to functors :-)]
04:13:25 <ski> liftM
04:13:34 <_matthew_> (have read docs and can't find answer). Which array instances have constant time lookup? (!) op ?
04:14:05 <norpan> all of them?
04:14:11 <_matthew_> oh! ok.
04:14:41 <_matthew_> I guess that might be part of the definition of an array eh?
04:14:49 <norpan> i would say so
04:14:54 <_matthew_> tnx
04:16:27 <Templar2> should not this work then?
04:16:29 <lisppaste2> Templar2 pasted "Input until "quit"" at http://paste.lisp.org/display/33696
04:16:30 <GsD_CeleborN> [dcoutts__]: hello
04:16:38 <dcoutts__> GsD_CeleborN: hi
04:17:41 <GsD_CeleborN> [dcoutts__]: http://paste.lisp.org/display/33524
04:18:17 <GsD_CeleborN> [dcoutts__]: I m trying to install gtk 0.9.10.3 using mingw
04:18:30 <dcoutts__> GsD_CeleborN: oh right, hmm
04:19:01 <dcoutts__> GsD_CeleborN: ok so the thing is that ghc-pkg doesn't grok mingw paths
04:19:11 <GsD_CeleborN> [dcoutts__]: yes
04:19:13 <dcoutts__> ghc and ghc-pke are windows progs not mingw ones
04:19:30 <dcoutts__> so you'd need to configure with a prefix that is a windows path I think
04:19:37 <dcoutts__> it's in the FAQ iirc
04:19:41 <Templar2> any ideas?
04:20:22 <GsD_CeleborN> [dcoutts__]: which?
04:20:22 <dcoutts__> GsD_CeleborN: http://haskell.org/gtk2hs/archives/2005/06/24/building-from-source-on-windows/
04:20:25 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» Building from source on Windows, http://tinyurl.com/yhuln8
04:20:30 <GsD_CeleborN> let me see
04:20:47 <dcoutts__> GsD_CeleborN: in particular it says there:
04:20:48 <dcoutts__> Note that the prefix passed to ./configure cannot be a MinGW style path, however it must use Unix-style ?/? path seperators rather than ordinary Windows ?\? characters.
04:21:08 <dcoutts__> a bit of a pain I'll grant you
04:21:55 <GsD_CeleborN> [dcoutts__]: I will try now
04:22:48 <dcoutts__> GsD_CeleborN: I figured most windows uses would not build from source so I've not invested that much effort in it. I build on windows but don't install since I just make an image that gets packed up into a windows installer exe
04:27:06 <GsD_CeleborN> [dcoutts__]: Which ghc version did you use?
04:27:50 <dcoutts__> GsD_CeleborN: Yesterday I built successfully on win32 with ghc 6.4.2 and 6.6
04:28:00 <dcoutts__> and gtk+ 2.6, 2.8 and 2.10
04:29:06 <GsD_CeleborN> [dcoutts__]: ok
04:34:46 <benja_> is there a module in the standard library or in gtk2hs that has data Color = Color Double Double Double Double?
04:40:50 <ibid> @hoogle Color
04:40:51 <lambdabot> Text.Html.color :: String -> HtmlAttr
04:40:51 <lambdabot> System.Win32.Info.cOLOR_ACTIVEBORDER :: SystemColor
04:40:51 <lambdabot> System.Win32.Info.cOLOR_ACTIVECAPTION :: SystemColor
04:41:03 <ibid> doesn't look like stdlib has it
04:41:28 <ibid> benja_: check the apidoc index?
04:41:47 <benja_> @hoogle Color
04:41:48 <lambdabot> Text.Html.color :: String -> HtmlAttr
04:41:49 <lambdabot> System.Win32.Info.cOLOR_ACTIVEBORDER :: SystemColor
04:41:49 <lambdabot> System.Win32.Info.cOLOR_ACTIVECAPTION :: SystemColor
04:42:23 <ibid> benja_: the gtk2hs apidoc, i meant. i don't think hoogle indexes it
04:43:16 <benja_> @hoogle DrawingArea
04:43:17 <lambdabot> No matches found
04:43:22 <benja_> looks like it doesn't :)
04:43:55 <benja_> ok, gtk2hs has Color but it's (Color Word16 Word16 Word16)
04:44:01 <benja_> so I'll roll my own. thanks
04:47:06 <AStorm> Can you point me to some nice SQLite Haskell bindings?
04:47:33 <kolmodin> argh, is wikipedia down?
04:47:54 <_matthew_> yep
04:48:31 <kolmodin> oh, now it works.. :)
04:48:36 <ibid> AStorm: cosmicray's db library? i forget the name
04:49:27 <AStorm> hdbc?
04:49:34 <AStorm> hsql?
04:50:01 <ibid> i think i was thinking of hdbc
04:54:00 <AStorm> Hmm, why that quux.org runs on :70 :P
04:54:05 <AStorm> My proxy doesn't like it.
05:00:36 <metaperl> it's time to kick some ass. who wants to study Django and build a highly similar RAD web framework for Haskell?
05:00:59 <lisppaste2> paolino annotated #33661 with "stateful nw" at http://paste.lisp.org/display/33661#2
05:01:14 <benja_> I don't, but I'd like to look at discussions or code :)
05:01:27 <metaperl> ok cool
05:02:27 <metaperl> Philippa - latest Flippi?
05:03:46 <paolino> anyone can help me unbug my last paste ?
05:04:01 <metaperl> I'm assuming the best way to general XHTML is HaxML? I dont grok arrows yet
05:05:41 <benja_> paolino: the problem being that it doesn't compile? or is that a problem with my install? :)
05:05:55 <dcoutts__> benja_: for the cairo binding we decided not to add a Colour data type and just take the components as arguments directly
05:06:11 <benja_> ok
05:06:32 <paolino> it dosn't compile
05:07:21 <benja_> having Color seems to work better in my code, so I've rolled my own -- no big deal, just wanted to make sure I'm not duplicating unnecessarily
05:07:42 <dcoutts__> sure, if you're chucking them about a lot then it does make sense
05:07:43 <benja_> (if it were in the libs there would probably be more functionality than the bare bones I'm making now)
05:07:47 <metaperl> paolino - I got an error on line 45... is that where you rpoblem was
05:08:05 <benja_> 29 and 45, me
05:08:11 <dcoutts__> kolmodin: so am I right in thinking that the writer monad has trouble with being lazy and giving O(1) append ?
05:08:16 <metaperl> did you get the annotated one?
05:08:34 <dcoutts__> kolmodin: eg a writer monad for list has to use ++ all the time
05:08:49 <kolmodin> dcoutts__: I belive so, yes
05:08:50 <metaperl> paolino - where did you get an error?
05:08:59 <paolino> line 31
05:09:04 <benja_> oops :)
05:09:06 <dcoutts__> kolmodin: hence the benift of the cont monad :-)
05:09:32 <paolino> the problem is I'm not able to do a noop inside a do
05:09:37 <dcoutts__> kolmodin: btw, I was glad to see that you worked out that bit of magic using theright mtl stuff rather than cheating the way I did it :-)
05:09:40 <paolino> probably
05:09:49 <metaperl> lisppaste, I do not like.
05:09:59 <benja_> ah, 'id' -- can't you use 'return ()'?
05:10:04 <metaperl> I like rafb.net/paste
05:11:16 <kolmodin> dcoutts__: yeah, but the cont monad is nice to have anyway, even if it's not needed. makes your code look complicated and yourself intelligent :D until someone tells you it's unnecessary
05:11:27 <dcoutts__> heh :-)
05:11:30 <kolmodin> dcoutts__: in my mail or in the bytestring stuff?
05:11:38 <dcoutts__> kolmodin: in the bs serialisation
05:12:08 <benja_> paolino: also 'devil ls' is missing an Int argument
05:12:10 <kolmodin> dcoutts__: the final version of binary bytestrings I'll probably write it manually anyway, if it gives better performance
05:12:22 <dcoutts__> kolmodin: sure, but it's very nice for presentation
05:12:28 <kolmodin> dcoutts__: but until we know how we want it we'll let it be that way
05:12:32 <dcoutts__> yes
05:12:44 <kolmodin> dcoutts__: much work to change that and all definitions for each attempt
05:12:51 <dcoutts__> indeed
05:12:57 <kolmodin> dcoutts__: and indeed very nice for presentation
05:13:03 <dcoutts__> kolmodin: do you have any benchmarks yet?
05:13:09 <benja_> paolino: with s/id/return ()/ and a 'd' added to 'devil ls', I don't get another error in the declaration of 'devil'
05:13:13 <benja_> does that help?
05:13:23 <dcoutts__> kolmodin: especially for comparison with NewBinary and Bulat's thing.
05:13:30 <kolmodin> no, I almost haven't touched that library since we talked about it last time
05:13:36 <GsD_CeleborN> [dcoutts__]: it's working ^^
05:13:37 <dcoutts__> right
05:13:44 <dcoutts__> GsD_CeleborN: oh good :-)
05:13:49 <GsD_CeleborN> [dcoutts__]: thanks dcoutts
05:13:52 <kolmodin> dcoutts__: yeah, we could use exactly the same benchmark just to see
05:14:22 <dcoutts__> kolmodin: yes, I think it'd be very useful to see something that fairly compares the 3 impls
05:14:44 <dcoutts__> since Old/NewBinary is the main incumbent, Bulat's thing is supposed to be quick
05:14:47 <kolmodin> and that you don't have to give up elegance for speed
05:14:54 <dcoutts__> and yours wants to be quick and nice :-)
05:14:59 <dcoutts__> right
05:15:06 <kolmodin> yeah, that's how greedy I am :)
05:15:10 <GsD_CeleborN> -optl-mwindows
05:15:10 <kolmodin> I want everything
05:15:12 <GsD_CeleborN> ops
05:15:14 <GsD_CeleborN> sorry
05:15:19 <benja_> paolino: the error in line 45 is because you want evalState, not runState
05:15:24 <dcoutts__> kolmodin: :-)
05:15:39 <kolmodin> dcoutts__: and I think I can get it too
05:15:48 <dcoutts__> good!
05:16:14 <lisppaste2> benja_ annotated #33661 with "make it compile and run and print the empty list. without taking the time to understand what it's for that's the best I can do :-)" at http://paste.lisp.org/display/33661#3
05:16:53 <paolino> benja thanks
05:17:05 <benja_> np :)
05:17:43 <kolmodin> dcoutts__: I'm thinking of how we could do smaller parts than bytes, for example reading ebml (think binary xml) where every bit has a meaning and things aren't alined
05:18:10 <metaperl> audreyt - ping?
05:18:12 <kolmodin> or, they are aligned but not all the time
05:18:21 <paolino> benja , whz I need the inner do ?
05:18:32 <Azmo> anyone know what stuff i need to link with to compile .hc files with gcc ? it is supposed to work, right?
05:18:34 <metaperl> anyone install audreyt's ghc-6.6 for os x?
05:19:45 <benja_> paolino: you don't :)
05:19:50 <pejo> dcoutts, looked in Okasaki, there was a chapter applicable to real time systems.
05:20:00 <benja_> just checked and removed it, doesn't make a difference
05:20:13 <pejo> metaperl, we all use macports. :-)
05:20:25 <metaperl> oh
05:20:27 <metaperl> ok
05:20:39 <benja_> (nor should it, I just checked to make sure I wasn't mis-thinking)
05:21:38 <metaperl> pejo - how do you install it? i've never used macports
05:21:58 <pejo> metaperl, sudo port -v install ghc, once you have macports installed.
05:23:03 <metaperl> ok do you get macports via svn or just use official releases
05:23:59 <pejo> I downloaded a file, which compiled itself iirc, and then just use "port -v sync" to keep the portfiles updated.
05:24:35 <metaperl> here is what i'm getting - http://svn.macports.org/repository/macports/downloads/DarwinPorts-1.3.2/
05:24:38 <lambdabot> http://tinyurl.com/yej39m
05:30:11 <vincenz> kolmodin: sounds rather painful, who ever thought of that format
05:30:54 <benja_> @paste
05:30:54 <lambdabot> http://paste.lisp.org/new/haskell
05:32:21 <lisppaste2> benja_ pasted "'i' does not seem to be polymorphic. Why not? Because of 'where'?" at http://paste.lisp.org/display/33701
05:34:47 <benja_> adding a type signature for 'i' (instead of the defining expression) seems to help. can anybody explain why?
05:35:27 <augustss> benja_: it's the monomorphism restriction that strikes again
05:35:46 <benja_> damn, never took the time to really understand that
05:36:06 <benja_> thanks
05:36:07 <augustss> benja_: the haskell report has a section on it
05:36:33 <augustss> benja_: in summary: a definition that is not syntactically a function will not be overloaded
05:37:14 <kolmodin> vincenz: a good library would help a lot
05:37:42 <benja_> hm, ok
05:38:38 <benja_> oh, so I can just rewrite (i = interpolate fract) to (i x y = interpolate fract x y)
05:40:21 <benja_> indeed, that does the trick. thanks!
05:45:55 <augustss> benja_: yes, that does the trick
05:46:50 <lisppaste2> Templar2 pasted "Input until "quit"" at http://paste.lisp.org/display/33702
05:46:57 <vincenz> kolmodin: true, though I did mean performance-wise, bit-fiddling like that just sounds like too much bitsqueezing
05:47:03 <Templar2> anyone who can?
05:49:35 <Templar2> =(
05:50:08 <benja_> sec
05:50:10 <dcoutts__> kolmodin: ok, then the thing to compare there is in terms of space and time of the bit version with the byte aligned version + gzip.
05:50:55 <dcoutts__> kolmodin: making full use of the bits takes longer and uses less space so you want to see if you can beat the ordinary encoding used with gzip
05:50:56 <lisppaste2> Saizan annotated #33702 with "this should work" at http://paste.lisp.org/display/33702#1
05:51:26 <dcoutts__> since gzip should do some of the same stuff but is highly optimised
05:51:33 <xerox> :t readLn
05:51:35 <lambdabot> forall a. (Read a) => IO a
05:51:37 <xerox> there you go
05:51:47 <lisppaste2> benja_ annotated #33702 with "easy :)" at http://paste.lisp.org/display/33702#2
05:53:01 <dcoutts__> kolmodin: if we can beat ordinary + gzip then there's probably no point, except perhaps for the case of 1000's of small records which need to be accessed indidually since gzip doesn't help much in compressing very short streams
05:53:05 <benja_> xerox: that's different, Templar2 wanted to read until the user inputs "quit"
05:53:09 <dcoutts__> can/cant'
05:53:12 <xerox> argh.
05:54:19 <lisppaste2> xerox annotated #33661 with "attempt to cleanup" at http://paste.lisp.org/display/33661#4
05:56:29 <Templar2> thank a lot for help =)
05:57:12 <benja_> :)
05:58:05 <Saizan> readl' = if liftM (== "quit") getLine then putStrLn "asd" else readl' <-- it's a pity we can't do something like this
05:58:20 <Saizan> (maybe with if')
06:02:55 <kolmodin> dcoutts__: right. I've seen erlang is very good at this, for example saying <<Version:4, IHL:4, ToS:8, TotalLength:16, Identification:16, Flags:3, and so on ...>> for parsing binary stuff
06:03:12 <kolmodin> much like http://www.imperialviolet.org/binary/bitsyntax/
06:03:30 <_matthew_> kolmodin: yeah, I was going to suggest that site
06:04:01 <kolmodin> dcoutts__: so it's not for creating your own format except you have special needs, but to read other's formats
06:04:57 <kolmodin> _matthew_: yeah, it seems like good work there. I'd like to see how that could be combined with "my" own library for binary bytestrings
06:07:49 <vincenz> Btw, a happy new year soon for everyone.
06:14:04 <Azmo> anyone here has windows+cygwin and is willing to try out a program that does not work ?
06:14:10 <Azmo> if so, see http://rafb.net/p/4KANID79.html
06:14:12 <lambdabot> Title: Nopaste - haskell using X11 through ffi
06:22:27 <lisppaste2> metaperl pasted "help me finish out this HaXML example please... I want to simply pretty print a simple document" at http://paste.lisp.org/display/33703
06:28:05 <dcoutts__> kolmodin: oh I see, yeah fair enough
06:30:41 <xerox> Anybody knows how to mark mail read in the unix mail program?
06:32:25 <integral> '?' should give you online help.
06:32:34 <vincenz> "online"
06:32:54 <xerox> ("mbox" was it, found in the man.)
06:34:15 * vincenz wonders if they'll ever invent a program "woman" just like they have "less" and "more"
06:34:18 <integral> hmm, mine doesn't seem mark mail read without typing it. *sigh*
06:36:58 <lisppaste2> metaperl annotated #33703 with "Ok, I've improved it significantly... how about some help now??? :)" at http://paste.lisp.org/display/33703#1
06:38:40 <xerox> integral: I did "mbox 1-698" and joy joy.
06:56:59 <syntaxfree> how are Maps represented internally?
06:57:11 <ibid> a balanced tree iirc
06:57:27 <syntaxfree> oh. sorted, then?
06:57:34 <vincenz> of course
06:57:45 <syntaxfree> interesting.
06:58:33 <syntaxfree> avoiding stack overflows in very large data structures is an interesting exercise for a quasinewbie like me.
06:58:42 <syntaxfree> Sp. since I never had a formal course in data structures.
06:58:59 * syntaxfree knows about binary search trees, and linked lists, and, uh, arrays.
06:59:51 <syntaxfree> apparently there's also a Data.HashTable. What's the diff'rence?
07:00:18 <augustss> Last I checked Data.Hashtable had a terrible API
07:00:56 <augustss> still does.  full of IO
07:01:04 * syntaxfree is replacing some Map structures with IntMaps.
07:01:25 <syntaxfree> the API looks similar.
07:01:32 <augustss> IntMaps are good
07:01:46 <augustss> why are you doing the replacement?
07:02:13 <syntaxfree> learning, mostly.
07:02:20 <syntaxfree> I'm solving the problems from Project Euler.
07:02:20 <augustss> oh, ok
07:02:25 <syntaxfree> fun stuff.
07:02:53 <augustss> the only (normal) reason to use IntMap instead of Map is performance
07:02:56 * syntaxfree can see himself enjoying Map comprehensions. 
07:03:15 <syntaxfree> maybe there should be a Comprehensible type class implementing comprehension syntax.
07:03:27 <Saizan> HashTable is full of IO cause it messes with memory to be O(1) i suppose, like an hashtable normally do
07:03:27 <syntaxfree> It's rather odd to have them only for lists.
07:03:53 <augustss> Saizan: but why the IO monad?  I would have used ST
07:04:07 * syntaxfree goes post to haskell-cafe
07:04:49 <augustss> The IO monad has far too much in it.  I don't think it should be used unless you really do IO
07:05:38 <Saizan> uhm yes, wasn't thinking of ST ..
07:08:11 <paolino> @type group
07:08:16 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
07:09:39 <joelr1> _matthew_: so, anyway, i think i'd rather use haskell
07:09:43 <joelr1> dons: why curses?
07:11:30 <yaxu> http://doc.gold.ac.uk/~ma503am/alex/slub20010203translated # i uploaded that video made with haskell to google video
07:11:34 <lambdabot> Title: 20010203 (translated) | Alex McLean
07:12:24 * syntaxfree just posted his proposal both to Haskell-cafe and his blog.
07:13:11 <joelr1> syntaxfree: what's the proposal?
07:14:05 <ClaudiusMaximus> http://claudiusmaximus.goto10.org/files/coding/polytopiary/cube-4d-01.gif # example of what i've been hacking on with haskell
07:14:08 <lambdabot> http://tinyurl.com/yhlgsh
07:14:41 <yaxu> ClaudiusMaximus: nice!
07:15:05 <Saizan> yaxu: have you tried with "normal sounding" music too?:D (this is very ncie btw)
07:15:21 <ClaudiusMaximus> yaxu: thanks :)
07:16:22 <yaxu> Saizan: yes, i should put up a more conventional demo really, but i guess there are copyright problems
07:17:08 <syntaxfree> joelr1: http://syntaxfree.wordpress.com
07:17:09 <lambdabot> Title: Data.Syntaxfree
07:17:25 <Saizan> not that they care much about copyright on youtube/googlevideo
07:17:44 <ClaudiusMaximus> i got the FFI stuff to work, i found it about 10-100 times faster to fwrite() the data from hopengl's readPixels using C than it is to get the readPixels data into haskell and write it from there, maybe it's because my haskell-fu is weak...
07:19:04 <yaxu> ClaudiusMaximus: i'm using System.Posix.IO to avoid buffering
07:19:09 <joelr1> syntaxfree: cool
07:21:38 <allbery_b> ClaudiusMaximus: if you're using a Haskell String, I can easily believe that
07:30:02 <mauke> I want to buy a book; any recommendations? :-)
07:30:16 <xerox> Roger Penrose - Road to Reality.
07:32:08 <mauke> anything about functional programming or haskell?
07:32:09 <integral> GEB
07:32:14 <joelr1> geb?
07:32:22 <_matthew_> Hamlet
07:32:44 <earthy> mauke: buy Chris Okasaki's book
07:32:49 <integral> joelr1: "GÃ¶del, Escher, Bach", Hofstadter
07:32:52 <earthy> guaranteed to make your mind hurt
07:33:02 <earthy> in the good way ;)
07:33:10 <joelr1> earthy: cool
07:33:25 <xerox> Sun Tzu :)
07:33:29 <mauke> integral: got that already :-)
07:33:29 <joelr1> anybody knows where musasabi went?
07:33:36 <joelr1> @seen musasabi
07:33:37 <lambdabot> I saw musasabi leaving #ghc, #haskell-overflow, #haskell-blah, #haskell and #Haskell 1m 5d 44m 46s ago, and .
07:33:39 <mauke> as well as Metamagicum
07:34:00 <mauke> earthy: ok
07:34:03 * integral tries to not buy more than one book from an author
07:34:08 <allbery_b> re GEB: just don't read too much into the philosophy :)
07:34:14 <Codex_> mauke: the only haskell book I've seen is: "Algorithms, a functional programming approach". But it's probably a little too beginners book...
07:34:34 <Templar2> greatful for all help:
07:34:35 <lisppaste2> Templar2 pasted "Change pos of !!0 and !!1" at http://paste.lisp.org/display/33704
07:34:53 <earthy> ofcourse, there's also 'The Haskell road to logic, maths and programming'
07:35:30 <joelr1> earthy: what can you tell me about the logic & maths book?
07:35:52 <xerox> I think that book from Penrose is pretty nice. You could also follow the trend and buy some CT book :)
07:36:21 <earthy> joelr: from what I've seen of it it is pretty good
07:36:27 <earthy> however, it is an intro book
07:36:35 <xerox> Yeah.  It's a very good intro book.
07:36:42 <earthy> so if you already know your logic and maths it won't buy you much
07:37:06 <xerox> Category theory for the working computer scientist. ?
07:37:07 <mauke> earthy: "Haskell, a member of the Lisp family"?!
07:37:18 <earthy> mauke: it is. honestly. :)
07:37:25 <mauke> I don't think so
07:37:52 <earthy> given that all functional languages are in essence descended from Lisp, I do think so
07:38:09 <mauke> I don't think so
07:38:17 <mauke> Lisp fails at functional programming
07:38:23 <earthy> come again?
07:38:49 <earthy> lisp may not be the best language for functional programming as it is neither pure nor lazy
07:38:54 <allbery_b> enh.  cons syntax for lists betrays the (admittedly somewhat distant) relationship
07:39:16 <earthy> but it was certainly the first to allow functional programming as we now know it
07:39:28 <mauke> without closures?
07:39:30 <allbery_b> yes, it's spelled : instead of . and nil is [] instead of (), but it's still the same concept
07:39:48 <mauke> (except cons is actually (,))
07:39:59 <integral> .oO( but you can implement closures with macros! )
07:40:07 <allbery_b> hm?  tuples are not cons lists
07:40:21 <mauke> integral: whoa, how?
07:40:22 <integral> but cons is not cons
07:40:23 <Templar2> any help?
07:40:36 <integral> mauke: I don't know, maybe write a scheme to CL translation thingie?
07:40:51 <allbery_b> templar2: I'm not even sure what you're trying to do there.
07:41:24 <allbery_b> rather, what method you're trying to use to do it
07:42:13 <Templar2> guess I´m trying to split my string up so I can pick out a specific element
07:43:48 <mauke> hmm, the Haskell Road looks too basic
07:45:26 <Templar2> it dosent work that easy to just split it up and put in the elements where I whant them
07:45:52 <allbery_b> you can do it that way but that's not the syntax
07:45:56 <vincenz> Does anyone know a system to play chess online, preferably to be able to save games halfway
07:45:58 <xerox> The Road to Reality is quite the opposite to "too basic" then.
07:46:17 <Templar2> then how is the syntax?
07:46:19 <xerox> But I don't know if you are interested in modern physics. I find it just too fun.
07:48:11 <LoganCapaldo> Lisp has closures...
07:48:15 <LoganCapaldo> last I checked
07:48:28 <mauke> LoganCapaldo: since when?
07:48:37 <LoganCapaldo> since like forever
07:48:46 <allbery_b> > let swp2o3l l = [l!!1, l!!0, l!!2] in swp2o3l (words "foo bar baz")
07:48:47 <lambdabot>  ["bar","foo","baz"]
07:49:14 <allbery_b> not how I'd do it...
07:49:15 <mauke> LoganCapaldo: no, since scheme/the 70's
07:49:25 <vincenz> allbery_b: eww
07:49:31 <vincenz> allbery_b: why not
07:49:43 <allbery_b> just trying to mirror your attempt
07:49:49 <Templar2> ok, but isent it the easyest way then?
07:49:50 <allbery_b> thebetter way seems to me:
07:50:15 <vincenz> > let swp l is = map (l!!) is in swp (words "foo bar baz") [1,0,2]
07:50:16 <lambdabot>  ["bar","foo","baz"]
07:50:32 <vincenz> @pl \l is -> map (l!!) is
07:50:33 <lambdabot> map . (!!)
07:51:01 <vincenz> nice :)
07:51:27 <vincenz> > let swp = map . (!!) in swp (words "a b c d e f") [5,4,3,2,1,0]
07:51:29 <lambdabot>  ["f","e","d","c","b","a"]
07:51:44 <vincenz> obviously not terribly efficient
07:51:47 <vincenz> might want to use an array then
07:51:54 <vincenz> cause this is O(N^2)
07:52:12 <allbery_b> > let swp2o3l [x1,x2,x3] = [x2,x1,x3] in swp2o3l (words "foo bar baz")
07:52:14 <lambdabot>  ["bar","foo","baz"]
07:52:26 <allbery_b> pattern matching is your friend
07:52:41 <allbery_b> to generalize to lists of any size, use cons instead
07:52:50 <Templar2> ah, yea, true, that one looked a lot beather =)
07:53:07 <allbery_b> > let swp2o3l (x1:x2:xs) = x2:x1:xs in swp2o3l (words "foo bar baz")
07:53:09 <lambdabot>  ["bar","foo","baz"]
07:53:14 <allbery_b> > let swp2o3l (x1:x2:xs) = x2:x1:xs in swp2o3l (words "foo bar baz gunk")
07:53:16 <lambdabot>  ["bar","foo","baz","gunk"]
07:53:41 <AStorm> How to do random shuffling of a list? :>
07:53:51 <mauke> @hoogle shuffle
07:53:51 <lambdabot> No matches found
07:53:55 <AStorm> Nope.
07:54:03 <mauke> @hoogle permu
07:54:04 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
07:54:04 <lambdabot> Distribution.GetOpt.Permute :: ArgOrder a
07:54:16 <AStorm> Uh?
07:54:20 <mauke> :(
07:54:31 <Templar2> thanks once again allbery_b
07:54:45 <AStorm> ?hoogle order
07:54:45 <lambdabot> Prelude.Ordering :: data Ordering
07:54:46 <lambdabot> Distribution.GetOpt.RequireOrder :: ArgOrder a
07:54:46 <lambdabot> Distribution.GetOpt.ReturnInOrder :: (String -> a) -> ArgOrder a
07:54:52 <LoganCapaldo> mauke: well that's still before Haskell or ML (or Me). So as far as I'm concerned thats like since forever
07:54:54 <AStorm> ?hoogle reorder
07:54:55 <lambdabot> Distribution.GetOpt.RequireOrder :: ArgOrder a
07:54:55 <lambdabot> Data.Graph.Inductive.Basic.preorder :: Tree a -> [a]
07:54:55 <lambdabot> Data.Graph.Inductive.Basic.preorderF :: [Tree a] -> [a]
07:54:58 <AStorm> Hm.
07:55:07 <xerox> .oO( random shuffle with mfix... )
07:55:14 <vincenz> random shuffle requires a randomness source
07:55:28 <AStorm> Yes, like a list full of random numbers :P
07:56:00 <vincenz> for reordering you mean
07:56:14 <vincenz> a list full of random, unique numbers spanning exactly [0, length shufledlist)
07:56:36 <mauke> AStorm: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
07:57:00 <norpan> perfect shuffle is so easy, and yet people fail so miserably
07:57:21 <mauke> hey, I got it right on the first try!
07:57:27 <mauke> (in C, then :-)
07:58:02 <AStorm> Oh crap :P Binary trees :>
07:58:32 <mauke> trees are easy, as long as you don't balance them
08:00:39 <AStorm> Well, there's still one problem...
08:00:48 <vincenz> There always is
08:00:53 <AStorm> how to get a series of unique random numbers
08:01:15 <allbery_b> System.Random
08:01:20 <AStorm> in [0, length thatlist)
08:01:23 <allbery_b> (which unfortunately puts you in IO)
08:01:25 <AStorm> allbery_b, unique :P
08:01:27 <vincenz> AStorm: easy
08:01:31 <AStorm> That means no repeats
08:01:33 <vincenz> AStorm: take one, take it out, take another one, take it out
08:01:39 <AStorm> and how to do that efficiently
08:01:57 <AStorm> I mean efficiently :P
08:03:29 <jcreigh> AStorm: random numbers can't be unique
08:03:34 <AStorm> Ehhh...
08:03:42 <AStorm> A list of unique random numbers
08:03:44 <vincenz> very carefully
08:04:02 <AStorm> I mean a random ordering of numbers [0, n)
08:04:24 <AStorm> Other than that, the perfect shuffle will probably be enough
08:04:25 <jcreigh> oh, like [1..(n-1)] shuffled?
08:04:36 <jcreigh> err.. 0..
08:07:01 <AStorm> Yes, that perfect shuffle will be ok
08:07:17 <AStorm> because it moves an item n steps
08:07:35 <AStorm> repeats don't hurt it
08:08:12 <Jaak> vähemalt nii ma olen kuulnud
08:08:15 <Jaak> oops
08:08:28 <Jaak> wrong channel *ahem*
08:09:23 <jcreigh> oh...I should have read the scrollback. :)
08:10:36 <AStorm> How does one use Random.random? What are instances of RandomGen?
08:11:58 <mauke> just use randomIO/randomRIO
08:21:02 <ihope_> > let iterateList f l = f l ++ iterateList f (l ++ f l) in iterateList (map (1+)) [0]
08:21:03 <lambdabot>  [1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3...
08:22:25 <ihope_> > let iterateList f l = l ++ iterateList f (l ++ f l) in iterateList (map (1+)) [0]
08:22:26 <lambdabot>  [0,0,1,0,1,1,2,0,1,1,2,1,2,2,3,0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,0,1,1,2,1,2,2...
08:23:50 <mauke> is "Algorithms: A Functional Programming Approach" any good?
08:29:47 <ihope_> > let thing = 0 : intersperse 0 (map succ thing) in thing -- why doesn't this work?
08:29:48 <lambdabot>  Exception: <<loop>>
08:30:19 <vincenz> > intersperse 0 [1..5]
08:30:21 <lambdabot>  [1,0,2,0,3,0,4,0,5]
08:30:31 <vincenz> intersperse must nott be lazy
08:30:33 <vincenz> > intersperse 0 [1...]
08:30:34 <lambdabot>  Parse error
08:30:34 <vincenz> > intersperse 0 [1..]
08:30:36 <lambdabot>  [1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0...
08:30:39 <vincenz> hmm
08:31:01 <vincenz> > take 1 $ let thing = 0:intersperse 0 (map succ thing) in thing
08:31:02 <lambdabot>  [0]
08:31:06 <vincenz> > take 2 $ let thing = 0:intersperse 0 (map succ thing) in thing
08:31:08 <lambdabot>  Exception: <<loop>>
08:31:10 <vincenz> ah
08:31:46 <xerox> > let thing = intersperse 0 (0 : map succ thing) in thing
08:31:48 <lambdabot>  Exception: <<loop>>
08:32:15 <vincenz> > let thing = intersperse 0 (0 : 1 : map succ thing) in thing
08:32:16 <lambdabot>  [0,0,1,0,1,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,3,0...
08:32:31 <xerox> O_o
08:32:41 <vincenz> > let thing = 0:1: intersperse 0 (map succ thing) in thing
08:32:42 <lambdabot>  [0,1,1,0,2,0,2,0,1,0,3,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0...
08:32:51 <vincenz> I guess intersperse needs at least a second element and it can't find it
08:33:14 <xerox> Right, the question is what do you want `thing' to be.
08:33:32 <ihope_> Lemme see...
08:34:25 <ihope_> let unSeq2 ~(x1:x2:xs) = x1:x2:xs; thing = 0 : intersperse 0 (map succ thing)
08:34:42 <ihope_> > let unSeq2 ~(x1:x2:xs) = x1:x2:xs; thing = 0 : intersperse 0 (map succ thing)
08:34:42 <lambdabot>  Parse error
08:35:08 <ihope_> > let unSeq2 ~(x1:x2:xs) = x1:x2:xs; thing = 0 : intersperse 0 (map succ thing) in thing
08:35:10 <lambdabot>  Exception: <<loop>>
08:35:20 <ihope_> I'll get this eventually.
08:35:36 <ihope_> > let unSeq2 ~(x1:x2:xs) = x1:x2:xs; thing = 0 : intersperse 0 (map succ (unSeq2 thing)) in thing
08:35:38 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
08:35:48 <ihope_> That's it.
08:37:15 <vincenz> o.O
08:38:12 <joelr1> has anyone used yampa lately?
08:38:17 <ihope_> intersperse seems to like knowing the list has at least two elements. unSeq2 returns a list with at least two elements.
08:38:25 <augustss> unSeq, very tricky! :)
08:38:48 <ihope_> unSeq, the seq-defeater!
08:39:28 <augustss> and of course intersperse wants to know if there is one or two elements.  in has to know if to insert something
08:39:48 <ph8> ?t fromList
08:39:49 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:39:59 <ph8> ?t Data.map.fromList
08:39:59 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:40:04 <ph8> ?t Data.Map.fromList
08:40:04 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
08:40:06 <ph8> ?type Data.Map.fromList
08:40:08 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
08:40:09 <ph8> whoops :p
08:41:40 <ihope_> > let unSeq l = head l : tail l in seq (unSeq undefined) 3
08:41:41 <lambdabot>  3
08:42:01 <ihope_> Turns undefined into head undefined : tail undefined. :-)
08:43:04 <augustss> kind of a handy function, actually
08:44:38 <ihope_> let setLength 0 l = []; setLength n l = head l : setLength (n-1) (tail l) in map (const 3) (setLength 4 undefined)
08:45:01 <ihope_> > let setLength 0 l = []; setLength n l = head l : setLength (n-1) (tail l) in map (const 3) (setLength 4 undefined)
08:45:03 <lambdabot>  [3,3,3,3]
08:45:43 <ihope_> > let makeInfinite l = head l : makeInfinite (tail l) in map (const 3) (makeInfinite undefined)
08:45:45 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
08:46:25 <augustss> If you make setLength use a natural number (with Succ and Zero) you can use the same function for both
08:47:25 <lisppaste2> ph8 pasted "Mystery Prefixing" at http://paste.lisp.org/display/33706
08:47:30 <augustss> Hmmm, it's good as it is, actually.  all you need is to make an instance Num Nat
08:47:30 <ph8> afternoon all
08:47:34 <ph8> any help with my mystery appreciated :p
08:47:59 <ihope_> s/[]/l/ in setLength to get unSeqN.
08:48:36 <ihope_> Returns a list of at least the specified length using the given list.
08:48:48 <fincher> quick question: what's the type of bind?
08:49:01 <ihope_> @type (>>=)
08:49:03 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
08:49:09 <fincher> aha.
08:49:14 <fincher> I explained it wrong last night :(
08:51:15 <AStorm> ihope, why that's any better than cycle head l?
08:52:00 <augustss> AStorm: because it does the right thing for a real list
08:52:03 <kolmodin> dcoutts__: heh, seems I jumped to conclusions about the writer/continuation stuff
08:52:13 <kolmodin> dcoutts__: see my followup
08:52:13 <ihope_> That depends on what cycle does. :-)
08:52:15 <malebria> Good night.
08:52:32 <kolmodin> malebria: good night
08:52:33 <AStorm> yeah, it adds infinite amount of 1st item, then infinite amount of 2nd item ...
08:52:42 <AStorm> What's the difference? :P
08:53:18 <augustss> > let makeInfinite l = head l : makeInfinite (tail l) in makeInfinite [1..]
08:53:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:53:20 <ihope_> Oh yeah. makeInfinite essentially tacks 'repeat undefined' to the end of a list.
08:53:36 <AStorm> Ah, that :P
08:53:42 <vincenz> no it doesnt
08:53:48 <AStorm> No, it doesn't.
08:53:55 <AStorm> It just copies the list.
08:54:05 <vincenz> > let makeInfinite l = head l : makeInfinite (tail l) in makeInfinite [1..5] -- Wait for teh crash of failing heads
08:54:06 <lambdabot>  Exception: Prelude.head: empty list
08:54:13 <ihope_> Not for a finite list.
08:54:13 <augustss> AStorm: copies, but with a lifting
08:54:20 <AStorm> Indeed.
08:55:06 <ihope_> makeInfinite returns an infinite list, and its first elements are the contents of the list you give it.
08:55:14 <ihope_> The rest are undefined.
08:55:19 <augustss> > let makeInfinite l = head l : makeInfinite (tail l) in length $ take 10 $ makeInfinite [1..5]
08:55:21 <lambdabot>  10
08:56:28 <AStorm> ?
08:56:39 <AStorm> 10 from infinite = 10 :P
08:56:47 <Cale> > cycle [1..10]
08:56:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,...
08:57:33 <dmhouse> > let cycle xs = xs ++ cycle xs in cycle [1..3]
08:57:35 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
08:57:48 <AStorm> > let tackUndefined l = head l : tackUndefined (tail l); tackUndefined [] = undefined in tackUndefined [1,2,3,4]
08:57:49 <lambdabot>    Warning: Pattern match(es) are overlapped
08:57:49 <lambdabot>        In the definition...
08:57:51 <dmhouse> Ah, the wonders of unbounded recursion.
08:58:08 * dmhouse is going to miss this in 2007, which is 'Learn C++ Year'.
08:58:23 <augustss> dmhouse: learn C++ year?  why?
08:58:24 <dmhouse> AStorm: put the empty list case first.
08:58:26 <vincenz> > let tackUndefined l = l ++ repeat undefined in tackUndefined  [1..5]
08:58:28 <lambdabot>  Undefined
08:58:28 <AStorm> > let tackUndefined [] = undefined; tackUndefined l = head l : tackUndefined (tail l) in tackUndefined [1,2,3,4]
08:58:30 <lambdabot>  Undefined
08:58:36 <vincenz> hello?
08:58:37 <vincenz> > let tackUndefined l = l ++ repeat undefined in tackUndefined  [1..5]
08:58:39 <lambdabot>  Undefined
08:58:49 <AStorm> Hmm :>
08:58:56 <dmhouse> That's odd.
08:58:58 <AStorm> You can't show something with Undefined, can you?
08:59:04 <augustss> nope
08:59:05 <AStorm> > let tackUndefined [] = undefined; tackUndefined l = head l : tackUndefined (tail l) in take 3 $ tackUndefined [1,2,3,4]
08:59:07 <lambdabot>  [1,2,3]
08:59:09 <AStorm> :>
08:59:13 * dmhouse wonders whether it's a consequence of Lambdabot's GHCi interface
08:59:23 <AStorm> Almost like a Turing tape :P
08:59:43 <dmhouse> Prelude> let f [] = undefined; f xs = xs ++ repeat undefined in f [1..5]
08:59:43 <dmhouse> [1,2,3,4,5,*** Exception: Prelude.undefined
09:00:11 <AStorm> > let tackUndefined = l ++ repeat undefined in take 6 $ tackUndefined [1,3,5,7,9]
09:00:12 <lambdabot>  Not in scope: `l'
09:00:25 <AStorm> > let tackUndefined = ++ repeat undefined in take 6 $ tackUndefined [1,3,5,7,9]
09:00:25 <lambdabot>  Parse error
09:00:29 <dmhouse> Prelude> let f [] = undefined; f (x:xs) = x : f xs in f [1..5]
09:00:29 <dmhouse> [1,2,3,4,5*** Exception: Prelude.undefined
09:00:31 <AStorm> > let tackUndefined = (++) repeat undefined in take 6 $ tackUndefined [1,3,5,7,9]
09:00:32 <lambdabot>    Expecting a function type, but found `[a]'
09:00:32 <lambdabot>    Expected type: [a]
09:00:32 <lambdabot>   ...
09:00:39 <AStorm> > let tackUndefined = (++) $ repeat undefined in take 6 $ tackUndefined [1,3,5,7,9]
09:00:41 <lambdabot>  Undefined
09:00:53 <AStorm> > let tackUndefined = (++) $ repeat undefined in take 3 $ tackUndefined [1,3,5,7,9]
09:00:55 <lambdabot>  Undefined
09:01:03 <AStorm> Hmm, wrong order :P
09:01:05 <ph8> does anyone have any thoughts on my mysterious prefixing thing?
09:01:06 <ph8> <lisppaste2> ph8 pasted "Mystery Prefixing" at http://paste.lisp.org/display/33706
09:01:13 <ph8> free hugs to anyone who does :-D
09:01:15 <AStorm> > let tackUndefined = repeat undefined . (++) in take 3 $ tackUndefined [1,3,5,7,9]
09:01:17 <lambdabot>    Expecting a function type, but found `[a]'
09:01:17 <lambdabot>    Expected type: b -> c
09:01:17 <lambdabot>  ...
09:01:26 <AStorm> > let tackUndefined = repeat undefined . (++ .) in take 3 $ tackUndefined [1,3,5,7,9]
09:01:26 <lambdabot>  Parse error
09:01:45 <ihope_> tackUndefined = (++ repeat undefined)
09:01:57 <dmhouse> > let tackUndefined = (repeat undefined ++) in take 3 $ tackUndefined [1..5]
09:01:59 <lambdabot>  Undefined
09:02:01 <AStorm> Well
09:02:06 <dmhouse> > let tackUndefined = (repeat undefined ++) in take 3 $ tackUndefined (filter odd [1..10])
09:02:08 <lambdabot>  Undefined
09:02:14 <AStorm> > let tackUndefined = (++ repeat undefined) in take 6 $ tackUndefined [1,3,5,7,9]
09:02:15 <lambdabot>  Undefined
09:02:20 <AStorm> > let tackUndefined = (++ repeat undefined) in take 2 $ tackUndefined [1,3,5,7,9]
09:02:21 <lambdabot>  [1,3]
09:02:25 <AStorm> :P
09:02:33 <AStorm> Append on end instead.
09:02:39 <AStorm> > let tackUndefined = (++ repeat 0) in take 2 $ tackUndefined [1,3,5,7,9]
09:02:40 <lambdabot>  [1,3]
09:02:45 <AStorm> > let tackUndefined = (++ repeat 0) in tackUndefined [1,3,5,7,9]
09:02:47 <lambdabot>  [1,3,5,7,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:03:12 <AStorm> should be called turingise :P
09:03:20 <dmhouse> Why?
09:03:28 <AStorm> ?pl f x = (++ repeat x)
09:03:28 <lambdabot> f = flip (++) . repeat
09:03:52 <AStorm> It converts some list to a Turing machine tape? :>
09:04:02 <AStorm> With a given blank symbol
09:05:07 <AStorm> ?let turingise = flip (++) . repeat
09:05:09 <lambdabot> Defined.
09:05:20 <AStorm> > L.turingise 0 [1,2,3,4]
09:05:22 <lambdabot>  [1,2,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:06:03 <mauke> @type (>>= (,))
09:06:04 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
09:06:21 <AStorm> ?undef
09:06:22 <lambdabot> Undefined.
09:06:38 <kpreid> Aren't tapes infinite in both directions?
09:06:41 <ihope_> @help undef
09:06:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:07:00 <AStorm> Well, working on doubly unbounded Turing tape is much harder in Haskell :P
09:07:03 <ihope_> #help undefine
09:07:21 <AStorm>  /msg lambdabot instead
09:07:23 <ihope_> I'll figure this out eventually.
09:08:02 <AStorm> kpreid, tapes can be
09:08:12 <AStorm> default tape is only unbounded in one dimension
09:09:06 <dmhouse> AStorm: not at all, you just need to use something other than a list.
09:09:52 <dmhouse> (That was in response to your doubly unbounded tapes being harder comment.)
09:11:05 <xerox> data Tape = T [Bool] Bool [Bool]  left, right :: Tape -> Tape  left (T (l:ls) x rs) = T ls l (x:rs)  right (T ls x (r:rs)) = T (x:ls) r rs  set :: Bool -> Tape -> Tape  set x (T ls _ rs) = T ls x rs  get :: Tape -> Bool  get (T _ x _) = x  blank = T (repeat undefined) undefined (repeat undefined)
09:11:31 <AStorm> dmhouse, you mean like STM pointer? :>
09:11:46 <ihope_> Aren't those things generally separated by semicolons?
09:11:58 <dmhouse> AStorm: Err, no, I meant something like what xerox posted.
09:12:10 <AStorm> Yes, right :>
09:12:12 <dmhouse> You basically need a zipper.
09:12:20 <xerox> Yay for the zipper!
09:12:28 <AStorm> Things get funny with those.
09:12:38 <AStorm> I HATE UNARY MATHEMATICS!
09:13:00 * Shyne__ slaps ph8 around a bit with a large trout
09:13:02 <ihope_> Unary mathematics? You mean arithmetic with pebbles?
09:13:19 <AStorm> No, with zeros :P
09:13:21 <dmhouse> ihope_: nonsense, arithmetic with lists of unit.
09:13:29 <AStorm> dmhouse, yep
09:13:35 <norpan> + == ++
09:13:42 <dmhouse> instance Num [()] where fromInteger x = replicate x (), etc.
09:13:49 <ihope_> I don't like whoever called that unary.
09:14:01 <xerox> Well, actually  data Tape x = T [x] x [x]  would be saner.
09:14:01 <kpreid> newtype Nat = Nat [()]
09:15:59 * xerox ponders  newtype Nat = Nat (Set Unique)
09:17:28 <AStorm> value = length
09:18:02 <kpreid> xerox: that'd be difficult to define (*) for
09:18:11 <AStorm> kpreid, no, there are algorithms
09:18:19 <AStorm> Turing-tape based (yuck)
09:18:29 <kpreid> I mean collecting sufficient Uniques
09:18:54 <kpreid> (and I mean Prelude.*)
09:19:43 <AStorm> YEah, I mean them too.
09:20:10 <AStorm> there are infinitely many Unique sets :P
09:21:10 <kpreid> okay, define fromInteger then
09:22:20 <AStorm> hmm
09:22:55 <AStorm> Why St Unique then? :P
09:23:02 <AStorm> It's easier with ()
09:23:22 <xerox> > S.fromList [(),(),(),(),()]
09:23:23 * allbery_b is (as usual when the discussion veers toward the underlying math) reading with glazed eyes :/
09:23:23 <lambdabot>  {()}
09:23:23 <AStorm> YOu could generate them from integers :P
09:23:44 <AStorm> > S.fromList [1,2,3,4]
09:23:46 <lambdabot>  {1,2,3,4}
09:23:54 <AStorm> > S.fromList [1]
09:23:55 <lambdabot>  {1}
09:23:55 <AStorm> > S.fromList [2]
09:23:57 <lambdabot>  {2}
09:23:57 <AStorm> > S.fromList [3]
09:23:59 <lambdabot>  {3}
09:24:00 <AStorm> > ...
09:24:01 <lambdabot>  Parse error
09:24:06 <AStorm> :P
09:25:04 <AStorm> So it's simple.
09:25:41 <AStorm> Just use length of the set
09:25:47 <benja_> @hoogle MaybeT
09:25:48 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
09:26:08 <benja_> @index MaybeT
09:26:09 <lambdabot> bzzt
09:26:19 <xerox> > let o = S.empty :: S.Set (); succ n = n `S.union` S.singleton n in iterate succ o
09:26:20 <lambdabot>    Occurs check: cannot construct the infinite type: a = Data.Set.Set a
09:26:20 <lambdabot>   ...
09:26:21 <xerox> (:
09:26:34 <benja_> anyone know whether a maybe monad transformer is defined somewhere?
09:26:36 <Binkley> Hi all... I don't suppose anybody here has l33t building-GHC-on-Mac-OS $killz?
09:26:36 <Syzygy-> What module does lambdabot call S?
09:26:46 <xerox> Data.Set
09:26:50 <Syzygy-> ?type S.fromList
09:26:51 <Syzygy-> ah.
09:26:51 <AStorm> ?hoogle S
09:26:51 <lambdabot> Couldn't find qualified module.
09:26:52 <lambdabot> Control.Concurrent.STM :: module
09:26:52 <lambdabot> Control.Concurrent.SampleVar :: module
09:26:52 <lambdabot> Control.Monad.ST :: module
09:27:22 <xerox> The fact is that ?type calls GHCi, so it hasn't got the same env as ?runplugs has.
09:28:35 <xerox> That construction has the nice property that if a < b then a \in b.
09:29:40 <ph8> ?type Data.map.fromList
09:29:40 <xerox> Binkley: there are no skills needed, what GHC do you currently have on your computer?
09:29:41 <lambdabot> Couldn't find qualified module.
09:29:45 <ph8> ?type Data.Map.fromList
09:29:46 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
09:30:54 <allbery_b> if you're trying to build from darcs HEAD you'll encounter a patch conflict, apparently because of case independence in the filesystem
09:31:17 <Binkley> xerox: LOL
09:31:25 <Binkley> I think there are plenty of skills needed.
09:31:32 <Binkley> the version I have installed is GHC 6.0.1
09:31:35 * allbery_b is rather tempted to mount the external drive he uses for backups and redo the spare partition as case dependent HFS+ or as UFS
09:31:37 <xerox> Sorry for the bad phrasing :)
09:31:52 <Binkley> that is, even more skills than installing GHC on Windows
09:31:54 <xerox> And you want to build?
09:31:55 <Binkley> and that's a lot of skills
09:31:59 <Binkley> and I want to build the HEAD
09:32:08 <Binkley> see http://hackage.haskell.org/trac/ghc/wiki/KirstenSandbox for what I've done so far
09:32:09 <xerox> Then what allbery_b says.
09:32:10 <Binkley> it's kind of long
09:32:10 <lambdabot> Title: KirstenSandbox - GHC - Trac
09:32:20 <allbery_b> (my current workaround is to do the darcs foo on the fbsd box and copy over the resulting tree...)
09:32:27 <Binkley> though most of it is about building gcc, which I didn't even need to do
09:32:35 <Binkley> as for a darcs patch conflict, I haven't even gotten that far yet
09:33:10 <xerox> Simon himself explains how to work with darcs sources in video, I think :)
09:33:36 <Binkley> yes, but Simon doesn't use Mac OS :-)
09:33:57 <Binkley> the particular problem I'm having now is that ghc is barfing on a file in the compat/ subdirectory
09:34:09 <Binkley> it looks like cpp isn't getting run, or is getting run improperly, or something
09:34:14 <joelr1> shapr: ping
09:34:19 <xerox> 6.6 built successfully here.  Didn't try HEAD yet, what's good about it?
09:34:23 <Binkley> and I'm not even certain whether the compat/ stuff is supposed to be getting built at all, or whether it's a misconfiguration
09:34:28 <Binkley> xerox: on OS X?
09:34:30 <xerox> Yup.
09:34:35 <Binkley> what version, though?
09:34:36 <Binkley> 10.4?
09:34:39 <xerox> Yup.
09:34:42 <Binkley> yes
09:34:44 <Binkley> I'm using 10.2.1
09:34:55 <Binkley> and of course I'm also bootstrapping from an old GHC
09:35:04 <Binkley> so I'm not sure whether it's one or both that are causing all my problems
09:35:06 * joelr1 has afrp-gadt built with ghc 6.6, if anybody needs it
09:35:15 <xerox> joelr1: that is... ?
09:35:21 <joelr1> xerox: yampa
09:35:45 <joelr1> with gadt performance enhancements by henrik nilsen
09:36:11 <xerox> OS X?
09:36:27 <xerox> ....and any cool demo to run? (:
09:36:31 <syntaxfree> OS X.
09:36:34 <joelr1> xerox: yes, osx 10.4
09:36:40 * syntaxfree has 10.3
09:36:49 <joelr1> xerox: no cool demos yet but i want to use it for trading systems development
09:36:53 <Binkley> both of you are luckier than I am, then
09:36:54 <joelr1> the model fits nicely
09:37:00 <xerox> Where can we find it?
09:37:13 <joelr1> xerox: let me cabalize it and then i'll make a darcs repo
09:37:20 <xerox> Okie.
09:39:05 <ski> ihope : cool '[0,1,0,2,...]' example using blueprint/skeleton :)
09:39:26 <joelr1> xerox: you wouldn't know where mkcabal comes from, would you?
09:39:39 <xerox> What is mkcabal?
09:39:54 <allbery_b> @go how to write a haskell program
09:39:56 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
09:39:56 <lambdabot> Title: How to write a Haskell program - HaskellWiki
09:40:13 <joelr1> xerox: a tool for creating cabal skeleton files. dons has it, i found it.
09:40:16 <allbery_b> link and examples there
09:40:50 <xerox> Ah.
09:40:54 <joelr1> http://www.cse.unsw.edu.au/~dons/code/mkcabal/
09:40:55 <lambdabot> Title: Index of /~dons/code/mkcabal
09:40:59 <scodil> how do you make a NaN value in haskell?
09:41:10 <xerox> > 0 / 0
09:41:11 <lambdabot>  NaN
09:41:13 <scodil> thanks
09:41:18 <xerox> You're welcome.
09:41:20 <allbery_b> or sqrt(-1), etc.
09:41:29 <scodil> is this defined somewhere?
09:42:14 <syntaxfree> > NaN
09:42:15 <lambdabot>  Not in scope: data constructor `NaN'
09:42:18 <syntaxfree> > nan
09:42:20 <lambdabot>  Not in scope: `nan'
09:42:53 <ibid> @hoogle NAN
09:42:54 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
09:43:17 * syntaxfree sings the "I am a hacker and I'm okay" song.
09:43:27 <syntaxfree> not that I'm saying that I'm one.
09:43:32 <Binkley> I sleep all night and I hack all day
09:43:34 <Binkley> Oh wait.
09:43:41 <xerox> syntaxfree: that reminds me...
09:43:41 <Binkley> If I were a real hacker it'd be the other way around.
09:44:08 <xerox> http://foolinglambdabot http://youtube.com/watch?v=eXgdSOxaCGI
09:44:18 <Binkley> you have a video of fooling lambdabot?
09:44:31 <allbery_b> heh
09:44:49 <xerox> allbery_b: good... keep laughing :D
09:46:01 * allbery_b wasn't reacting to the video; getting the url moved from the vnc session to somewhere with video capability's more pain than he wants at present
09:46:11 <Philippa> Binkley: that's only if you think real hackers're SAD all the time, no?
09:46:12 <vincenz> xerox: explain that
09:46:38 * xerox ducks
09:47:07 <allbery_b> (2 vnc clients on osx.  one does cut&paste but has keyboard issues, the other reverses those.  meh)
09:47:29 <Binkley> Philippa: maybe real hackers *are* SAD all the time
09:47:35 <xerox> vnc, oooh.
09:47:38 <Binkley> though I guess I don't think that's true, given the examples I know.
09:47:52 <Philippa> hmm. Are we talking real hackers or Real Hackers?
09:47:57 <Binkley> case-sensitive
09:48:06 <Binkley> I guess I mean small-r, small-h, though
09:48:25 <vincenz> real hackers code in scheme which is not case sensitive so it's the same as REAL HACKERS
09:48:32 <Philippa> *nod*. Then I think the up all night thing's mostly repeated (time?) management failure rather than anything else
09:48:35 <Binkley> vincenz: them's fighting words
09:48:38 <vincenz> :D
09:49:36 <Binkley> not sure I'd call it time management failure
09:49:41 <Binkley> some people really do work better at night
09:49:45 <Binkley> and I'm still not sure if I'm one of them
09:49:54 * vincenz aks for dinner
09:49:57 <vincenz> since I won't be on later
09:49:59 <vincenz> happy new year!
09:50:01 <allbery_b> <-- not a morning person, at all
09:50:05 * vincenz is flying tomorrow
09:50:11 <Philippa> I used to think I worked better at night
09:50:14 <Binkley> I used to think I was neither a morning person nor a night person
09:50:20 <Philippa> these days, I mostly think I work best when I get a good run up at it
09:50:26 <Binkley> but ever since I got back from England I've been waking up at 7:30am for no apparent reason
09:50:41 <Binkley> and getting "lots" of "work" done
09:50:47 <Philippa> and try not to do too much at silly am because it tends to lead to degrading capability over time
09:50:49 <Binkley> only so far, "work" is defined as "trying to get GHC to build and failing"
09:50:56 <Binkley> and that brings me full circle! ;-)
09:51:22 <Binkley> doing stuff at silly AM definitely ends up making me feel extremely stupid after a couple days
09:51:59 <Philippa> yeah, same here. Which isn't really a great way to end what was turning into a sustained hackathon
09:52:25 <joelr1> any cabal experts here?
09:52:40 <Philippa> joelr1: yes. Which isn't to say I'm one of them
09:52:51 <Binkley> good answer
09:52:59 <joelr1> Philippa: hi :) what do you make of this error? Setup.lhs: can't find source for AFRP.hs in ["."]
09:53:13 <joelr1> Philippa: I do have AFRP.hs in the directory where Setup.lhs is
09:53:33 <Philippa> is that the current dir when you run it?
09:53:39 <Philippa> (other than that, ask someone else)
09:54:05 <joelr1> Philippa: actually, i'm an idiot :) i need to remove .hs :) thanks, though!
09:54:09 <joelr1> asking does wonders!
09:54:12 <Binkley> heh
09:54:26 <Binkley> yes, it's funny how many times asking other people for help leads to one solving the problem on one's own
09:54:30 <Binkley> and then everybody wins! :-)
09:54:58 <joelr1> yep
09:58:56 <Binkley>  Warning: Defined but not used: `fun'
09:59:04 <Binkley> somehow ghc error messages seem to be a little too good these days
10:06:39 <syntaxfree> hehe
10:07:24 <joelr1> who runs planet.haskell.org?
10:07:31 <Binkley> "I know how to define fun, I'm just not having any"
10:08:00 <allbery_b> "I know what fun is, ..."
10:08:04 <kowey> joelr1: ibid does, i think
10:08:11 <joelr1> kowey: cool
10:08:14 <joelr1> ibid: ping
10:09:06 <kowey> you could also send him mail; it's on the page
10:09:18 <joelr1> kowey: true, thanks
10:10:16 <AStorm> Lisp removes all the fun with "defun
10:10:40 <syntaxfree> That's why I never learned Lisp.
10:10:58 <syntaxfree> I always feel Scheme is the fun lisp, and CL removes all the fun of it by being commercial.
10:11:32 <syntaxfree> just because of de-fun.
10:11:48 <Binkley> "I liked CL before it sold out"
10:11:56 <Binkley> "and started trashing hotel rooms and getting caught with hookers and blow"
10:12:17 <syntaxfree> "3:43 PM  Philippa: these days, I mostly think I work best when I get a good run up at it"
10:12:37 <syntaxfree> one thing that works wonders for me is to work on a problem right before sleep then resuming work whenI wake up.
10:12:46 <Binkley> yeah
10:12:50 <Binkley> or going for a walk when I can't solve a problem
10:12:55 <Binkley> sometimes getting away from the computer works wonders
10:12:58 <Binkley> a lot of the time, actually
10:13:05 <Binkley> I think my computer is sending out make-me-stupid rays
10:13:11 <dylan> I just create a new problem when I can't figure out how to solve an existing one.
10:13:14 <Binkley> maybe I can get an anti-make-me-stupid-ray filter for that
10:14:04 <AStorm> Those rays are bogon rays...
10:14:13 <dylan> "hmm, slang might not be threadsafe. how will I fix that? I know! A stack-based programming language for simulating horse races!"
10:14:16 <Binkley> will wearing a tinfoil hat fix it?
10:14:20 <AStorm> No
10:14:21 <syntaxfree> @all-dict bogon
10:14:24 <lambdabot> *** "bogon" jargon "Jargon File (4.3.1, 29 Jun 2001)"
10:14:24 <lambdabot> bogon /boh'gon/ n. [very common; by analogy with
10:14:24 <lambdabot>   proton/electron/neutron, but doubtless reinforced after 1980 by the
10:14:24 <lambdabot>   similarity to Douglas Adams's `Vogons'; see the {Bibliography} in
10:14:24 <lambdabot>   Appendix C and note that Arthur Dent actually mispronounces `Vogons' as
10:14:26 <lambdabot> [68 @more lines]
10:14:34 <syntaxfree> @more
10:14:35 <lambdabot>   `Bogons' at one point] 1. The elementary particle of bogosity (see
10:14:35 <lambdabot>   {quantum bogodynamics}). For instance, "the Ethernet is emitting bogons
10:14:35 <lambdabot>   again" means that it is broken or acting in an erratic or bogus fashion.
10:14:35 <lambdabot>   2. A query packet sent from a TCP/IP domain resolver to a root server,
10:14:35 <lambdabot>   having the reply bit set instead of the query bit. 3. Any bogus or
10:14:37 <lambdabot> [63 @more lines]
10:14:45 <syntaxfree> well, that explains it.
10:15:10 <Binkley> Damn
10:15:15 <Binkley> now I need another excuse to wear a tinfoil hat
10:15:26 <vincenz> Coming back into the earlier conversation
10:15:27 <syntaxfree> from Wikipedia:
10:15:28 <syntaxfree> "The bogon has an antiparticle, the cluon"
10:15:35 <vincenz> I often find the best solutions when I am forced by nature to take a break and go to the loo
10:15:43 <syntaxfree> maybe the sun emits cluons or something.
10:15:44 <AStorm> Yeah, they annihilate and nothing remains
10:15:45 <Binkley> thanks for sharing, vincenz
10:16:07 <AStorm> Then you have no clues and no bogus ideas
10:16:13 <AStorm> :/
10:16:47 <vincenz> Binkley: My point is simply, because your mind is forced on other things, you suddenly see the soluton
10:17:14 <Philippa> I think it's more because your mind is left with nothing else to do
10:17:17 <liyang> I don't want to hear about the kind of forcing that goes on while you're on the loo
10:17:27 <vincenz> Philippa: yeah, plane rides work wonders on getting stuff done
10:17:29 <Philippa> the shower's another common suspect for good ideas
10:17:40 * vincenz usually wakes up in the shower
10:17:48 <syntaxfree> the shower makes me sleepy.
10:17:59 <syntaxfree> Sometimes I have to fight the urge to just lay down and sleep there.
10:18:09 <Binkley> syntaxfree: that's why I take baths instead
10:18:15 <syntaxfree> baths, ugh.
10:18:15 <Binkley> sleeping in a bathtub is awesome
10:18:17 <LoganCapaldo> I keep trying to think of a way to put a notepad in the shower
10:18:21 <dylan> sleeping in the bath sounds dangerous
10:18:25 <LoganCapaldo> it would be so useful
10:18:27 <syntaxfree> you're dirty, then you lay on the water and then the water is dirtying you!
10:18:35 <syntaxfree> you might as well wash in the toilet.
10:18:41 <Binkley> dylan: it's only dangerous when you're drunk
10:18:46 <kiripan> the original way is to sleep in a rainforest
10:18:59 <Saizan> LoganCapaldo: there are some that works underwater, for subs
10:19:08 <Binkley> taking a bath isn't about getting clean
10:19:10 <xerox> LoganCapaldo: plenty of ways
10:19:24 <xerox> hehe, what Saizan
10:19:26 <xerox> says.
10:20:07 <xerox> http://www.joediveramerica.com/page/JDA/PROD/aegcs/WR1
10:20:13 <LoganCapaldo> Saizan, xerox acutally I'm a little worried about how crazy everyone else thinks I am then how to keep the notebook dry <g>
10:20:15 <lambdabot> Title: Dive Slate-Underwater Writing Slate: at JoeDiverAmerica!
10:20:18 <LoganCapaldo> ooo link
10:20:32 <vincenz> Binkley: especially when not taking it alone
10:20:35 <xerox> http://shop.divebooty.com/1182.html
10:20:37 <lambdabot> Title: Underwater Writing Slate - Dive Slates
10:20:40 <syntaxfree> "4:11 PM  LoganCapaldo: I keep trying to think of a way to put a notepad in the shower"
10:20:45 <syntaxfree> get one of those CD-marking pens.
10:20:47 <syntaxfree> Write on the wall.
10:20:52 <LoganCapaldo> hehehhe
10:20:53 <vincenz> syntaxfree: and repaint?
10:20:59 <xerox> Write on yourself, then shower?
10:21:02 <vincenz> don't they have underwater pads?
10:21:02 <Binkley> heh
10:21:03 <syntaxfree> cd marker can be removed with alcohol.
10:21:13 <xerox> Then drink!
10:21:21 <vincenz> then rinse and repeat
10:21:25 <Binkley> getting sloshed in a bathtub while coming up with research ideas
10:21:27 <Binkley> A+++++
10:21:27 <syntaxfree> you can always have a plastified piece of carton.
10:21:34 <xerox> Oh, err. Well. Catch'ya later.
10:21:38 <vincenz> syntaxfree: with a plastified pencil?
10:21:46 <dylan> ooh!
10:21:49 <syntaxfree> with a cd marker pen.
10:21:52 <dylan> a whiteboard in the shower!
10:21:57 <syntaxfree> yes! yes!
10:22:00 <LoganCapaldo> Hmm I could be wrong but it looks like only one page?
10:22:07 <Binkley> couldn't you just write on shower tiles with a dry-erase marker?
10:22:10 <Binkley> I think that would work
10:22:19 <Binkley> but I'm not going to try it now because I'm at my mother-in-law's house
10:22:20 <vincenz> dry-erase marker washes away IMMEDIATELY
10:22:23 <vincenz> I use them on slides
10:22:24 * xerox >>= shower
10:22:30 <vincenz> just have to hold the slide under the faucet and it flows away
10:22:31 <AStorm> Ha, just create a waterproof PDA :>
10:22:32 <vincenz> without wiping in the least
10:22:41 <syntaxfree> http://foldoc.org/?Infinite+Monkey+Theorem
10:22:44 <lambdabot> Title: Infinite Monkey Theorem from FOLDOC
10:22:49 <syntaxfree> this is wrong. That's the freaking Borel-Cantelli lemma.
10:22:50 <LoganCapaldo> xerox is apperent in the Clothes monad
10:23:04 <xerox> hahaha
10:23:12 <xerox> Clothes as containers
10:23:48 <syntaxfree> oo.
10:24:01 <syntaxfree> that gives an entirely new meaning to "purity".
10:24:14 <vincenz> well just don't get _|_
10:24:16 <Binkley> hey, let's use monads to explain clothes
10:24:25 <Binkley> because I know lots of people find clothing complicated and difficult to understand
10:24:34 <LoganCapaldo> Binkley: brilliant!
10:25:03 <Binkley> so when you dress more formally than usual, it's kind of like calling liftM
10:25:08 <allbery_b> monads as clothes.  "IO is a prude"
10:25:24 <syntaxfree> @quote
10:25:24 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
10:25:29 <LoganCapaldo> lol
10:25:32 <syntaxfree> @quote
10:25:32 <Binkley> using unsafePerformIO is kind of like going naked in public
10:25:32 <lambdabot> delicious-malicious-test says: @quote dmt
10:25:44 <Binkley> might be safe in some contexts, but you really don't want to know what happens if you do it in a really bad one
10:25:47 <LoganCapaldo> this metaphor just keeps getting better and better
10:25:54 <syntaxfree> Hehehe.
10:26:17 <Binkley> The State monad, of course, is like having lots of stuff in your pockets.
10:26:33 <Philippa> so how do Reader and Writer relate to that?
10:26:38 <Binkley> except you don't lose stuff out of your pockets
10:26:43 <vincenz> The Continuation monad is what happens after you take mushrooms
10:26:45 <Binkley> because you always have to make it explicit exactly what's in them
10:27:07 <Binkley> and the compiler keeps you from putting your pants in the washing machine and getting all your pens and paper and stuff wet
10:27:17 <scodil> do I need to flush a file handle before I quit? I always thought the OS would do that when it cleans up the process, but the last few lines of my file aren't showing up. I echo to stdout and they show up there.
10:27:32 <Binkley> scodil: you certainly need to close the file
10:27:35 <Binkley> are you closing it?
10:27:40 <scodil> no
10:27:52 <Binkley> in any programming language, you need to close files when you're done with them
10:27:55 <xerox> ?remember Binkley [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happens if you do it in a really bad one
10:28:14 <vincenz> @quote xerox
10:28:15 <lambdabot>  you know, befunge is probably the only language I've seen where you can run code pasted from IRC with the <nick> tags still in place ;-)
10:28:31 <syntaxfree> @quote vincenz
10:28:31 <lambdabot>  then you call 1-800-GET_DONS
10:28:37 <Binkley> @quote syntaxfree
10:28:38 <lambdabot>  yes, The Wadlerman. the Prince of Funktions.
10:28:53 <syntaxfree> that's not a good one.
10:28:56 <syntaxfree> @quote syntaxfree
10:28:57 <lambdabot>  <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
10:28:59 <Binkley> well, I think it's funny
10:29:05 <Binkley> I think that one is funny, too
10:29:10 <vincenz> @quote vincenz
10:29:11 <Binkley> since I use the nick catamorphism everywhere except IRC
10:29:11 <lambdabot>  sure, give us your homework and we'll email it straight to your teacher :)
10:29:15 <Binkley> so if you've met me, you've met a catamorphism
10:29:22 <Syzygy-> What -is- a catamorphism anyway?
10:29:28 <syntaxfree> catamorphism = foldr
10:29:32 <Syzygy-> I only know the more 'boring' kinds of morphisms...
10:29:33 <Syzygy-> Ah.
10:29:34 <Binkley> Syzygy-: it's like foldr, but more general
10:29:41 <vincenz> anamorphism = unfoldr
10:29:41 <syntaxfree> yeah, well.
10:29:45 <Binkley> aka "I don't know how to explain it except in terms of haskell"
10:29:46 <syntaxfree> catamorphism on lists = foldr.
10:29:48 <Binkley> because math is hard
10:29:50 <Binkley> let's go shopping
10:29:54 <Syzygy-> homeo-, homo-, iso-, mono-, epi-,
10:30:00 <syntaxfree> oh well.
10:30:01 <Philippa> Binkley: almost everywhere else. You're a different kind of origami on OKCupid
10:30:03 <vincenz> chrono
10:30:07 <vincenz> o-
10:30:13 <Binkley> Philippa: good point. That's because the username was taken. By me.
10:30:13 <vincenz> a-
10:30:15 <syntaxfree> Syzygy-: there's a good, easy to read paper by Erik Meijer.
10:30:29 <syntaxfree> "Functional programming with bananas, lenses, envelopes and barbed wire";
10:30:40 <Binkley> I wouldn't exactly call that paper "easy to read"
10:30:44 <Binkley> but maybe that's just because I'm dubm.
10:30:45 <syntaxfree> that explains cata-, ana-, hylo-, para- and zygo-morphisms quite nicely.
10:30:55 <syntaxfree> well, easier than freaking Peter Freyd, for one.
10:30:56 <vincenz> Anyways, now I'm off for real
10:30:58 * vincenz waves
10:31:02 <Binkley> heh, I don't even know who Peter Freyd is
10:31:42 <Philippa> Binkley: Ah. Don't think I ever read the profile, presumably you left it idle a long time?
10:33:30 <Binkley> Philippa: I made a "catamorphism" account just to take quizzes, forgot about it, months later decided to create a real account, saw, "oh, catamorphism is taken, I'll use anamorphism," then only later did I realize catamorphism was also my account
10:33:33 <Binkley> An exciting story.
10:33:44 <Philippa> *nod*
10:33:45 <Philippa> figures
10:34:30 <Binkley> I was telling SPJ my email address last week and he was all, "ha, ha, I bet *that* username usually isn't taken already"
10:34:31 <syntaxfree> we should have multi-word usernames by now everywhere.
10:34:32 <Binkley> and I was all
10:34:34 <syntaxfree> It's not that hard to handle them.
10:34:36 <Binkley> "YEAH THAT'S WHY I PICKED IT"
10:34:38 <Binkley> "LOLZ"
10:35:30 <Binkley> syntaxfree: I'm not sure I trust your average AIM-using teenager with the awesome power inherent in multi-word usernames
10:35:38 <syntaxfree> ?
10:35:54 <Binkley> I'm just thinking 15-year-olds would probably pick usernames consisting of the entire text of some song they liked, or something
10:35:55 <Binkley> hell
10:36:03 <Binkley> *I* would probably pick a username consisting of the entire text of some song I liked
10:36:07 <syntaxfree> well, I don't intend to talk to them.
10:36:12 <Philippa> or "really hot chick looking for sex" (inevitably a 14 or 40 y/o guy)
10:36:12 <Binkley> heh
10:36:16 <Binkley> yes
10:36:31 <lisppaste2> steven807 pasted "coins" at http://paste.lisp.org/display/33711
10:37:06 <steven807> Hello folks -- I wonder if anyone can sguges why the program I just pasted is 1/3 as fast as an equivalent perl program
10:37:22 <Binkley> steven807: lots of possible reasons
10:37:33 <integral> steven807: Try rewriting it to be faster.
10:37:40 <steven807> Good thinking!
10:37:45 <Binkley> or you could try it on a faster computer
10:37:50 <Binkley> or wait 5 years until computers get even faster
10:37:56 <steven807> That being said, I _did_ try rewriting it.
10:38:01 <Binkley> more helpfully, are you compiling it with -O?
10:38:17 <ski> Binkley : i've sometimes spent up to 7 hours in bath :)
10:38:21 <steven807> And pardon my extreme ignorance, but is there any chance that the Perl version would also get faster as the computer got faster?
10:38:26 <Philippa> what's the "equivalent" perl code?
10:38:30 <steven807> Yep, compiled with -O2 -fvia-C
10:38:34 <Binkley> steven807: heh, yes. that's why it's an unhelpful suggestion
10:38:35 <Heffalump> where's your formal proof of equivalence for the Perl and Haskell code?
10:38:39 <steven807> I'll paste it in a sec
10:38:45 <Binkley> Heffalump: I thought of that too but I didn't want to be unhelpful
10:38:51 <Philippa> Heffalump: c'mon, you've got to ask for a definition of "equivalent" first
10:39:00 * integral just wants to see the formal semantics of Perl 8-)
10:39:04 <Binkley> steven807: one problem you're going to have with that is you're using lists or arrays of ints
10:39:17 <Binkley> Actually I'm not so sure about arrays
10:39:25 <Binkley> but definitely with lists, one problem is that the ints aren't going to get unboxed
10:39:27 <Heffalump> in fact, clearly they're not equivalent, since the Perl is faster.
10:39:41 <Binkley> Heffalump: depends what definition of "equivalent", like Philippa said
10:40:22 <steven807> Hm, proxy erro from paste.lisp.. still workin on it
10:40:23 <liyang> what's a definition?
10:40:31 <psnl> steven807: I have that too
10:40:32 <Binkley> steven807: have you tried profiling yet?
10:40:38 <Philippa> liyang: that which you'll receive in answer to that question :-)
10:40:46 <steven807> Yep, I profiled.  Not obvious
10:40:52 <steven807> And I've tried rewriting in a few ways
10:40:54 <Binkley> can you paste the profiling results, anyway?
10:41:05 <steven807> I was surpised that making the basic (non-memoized) functions local to the wrapper functions slowed things down
10:41:08 <Binkley> I have a hunch that unboxing is going to be a big part of it
10:41:21 <steven807> I tried to unbox, but the values are Integers, not Ints
10:41:24 <Binkley> but that's just a hunch
10:41:25 <Binkley> ah
10:41:28 <Binkley> and you really need Integers?
10:41:40 <steven807> Yeah, the result is way big
10:41:46 <Binkley> hmm, yes. That's a known problem.
10:41:59 <steven807> As soon as lisp.paste comes back, I can paste the profile info
10:42:02 <pejo> Binkley, did you get your ghc things sorted out?
10:42:06 <LoganCapaldo> So do what perl does, use Double
10:42:08 <Binkley> pejo: not yet...
10:42:12 <pejo> (Building on Macos x, that is).
10:42:13 <LoganCapaldo> Is Double unboxed?
10:42:23 <Binkley> pejo: still having a problem building compat/System/Directory/Internals.hs
10:42:30 <Binkley> LoganCapaldo: Double isn't unboxed, Double# is
10:42:33 <Binkley> in Haskell, that is
10:42:34 <Binkley> dunno about perl
10:42:39 <Binkley> I prefer to remain ignorant of perl
10:42:54 <Binkley> pejo: it's apparently only needed if you're bootstrapping with ghc < 6.3, which I am unlucky enough to be doing
10:42:57 <integral> Perl doesn't have unboxed values
10:43:21 <Heffalump> surely an unbounded type is bound to be boxed by its nature
10:43:30 <Binkley> Heffalump: not necessarily
10:43:35 <Binkley> for example, Integer has two constructors (IIRC)
10:43:41 <LoganCapaldo> perl doesn't use integers (unless you use integer;).
10:43:46 <Binkley> you could do a fun trick where you use tagging to represent one of the constructors in an unboxed way
10:43:52 <Binkley> and back out to using a boxed reprsentation for the other
10:43:54 <syntaxfree> steven807: alternative pastebins: http://rafb.net/paste
10:44:04 <integral> LoganCapaldo: You are using BigIntegers in perl, right?
10:44:04 <Binkley> if the Integers are usually going to be small, then you win
10:44:07 <Heffalump> ok, fair enough
10:44:09 <steven807> Ah, excellent.  Pasting, here we go!
10:44:10 <syntaxfree> for mathematics, http://www.mathbin.net
10:44:12 <lambdabot> Title: MathBin.net - Math pastebin for equation rendering
10:44:13 <Heffalump> no, wait
10:44:19 <LoganCapaldo> integral: I dunno
10:44:21 <integral> err, s/LoganCapaldo/steven807/
10:44:47 <steven807> Perl version: http://rafb.net/p/mfi6h060.html
10:44:48 <lambdabot> Title: Nopaste - coins in perl
10:44:51 <Philippa> Heffalump: you're worried about introducing a new bottom?
10:44:53 * Heffalump isn't too clear on how constructors are normally represented.
10:44:56 <Heffalump> Philippa: that too.
10:45:04 <Binkley> Heffalump: this is sort of like something Alexey Rodriguez and SimonM were working on this fall. there will be a paper eventually, I get the impression
10:45:09 <Heffalump> but I concede the general principle, anyway
10:45:23 <Philippa> Binkley: it's also something like what I believe's the traditional lisp implementation...
10:45:27 <integral> steven807: That perl version isn't using bignums.
10:45:32 <Philippa> ...though granted a lazy language gives you additional concerns
10:45:46 <Binkley> Philippa: yes, Lisp does a lot of things :-)
10:45:48 <steven807> Yeah, I am starting to realize that my testing methodology is flawed..
10:45:54 <Heffalump> steven807: I'm not convinced your memoisation is equivalent.
10:46:13 <Heffalump> in particular, in the Haskell version, you construct a huge array
10:46:14 <integral> personally I'd use memoisation modules for both the perl and haskell versions.
10:46:25 <Heffalump> (most of the members will be unevaluated, but you still have to pay the cost of the array itself)
10:46:28 <pejo> Binkley, basically you started out with the binary package for 10.2, and wanted to build head?
10:46:35 <Heffalump> whereas the perl code just uses a hash table
10:46:35 <steven807> (The person who wrote that perl code showed me his run, and it showed a BigNum output -- I didn't pay attention to why when I ran it, it came out with a double instead)
10:46:42 <integral> there's Data.HashTable that I've used to build a haskell memoisation func.
10:47:06 <steven807> Ooh, there's a memoization module for Haskell?  Excellent (that's why I'm here!)
10:47:14 <Binkley> pejo: kind of - I hgad a binary package that I installed long ago
10:47:20 <steven807> I googled for one, but couldn't find it
10:47:22 <Binkley> pejo: and I'm trying to build the HEAD now
10:47:31 <integral> steven807: There would be if I knew where to publish it, there's no CPAN thingie for haskell :-/
10:47:33 <Heffalump> I think the suggestion is that you roll your own with Data.HashTable
10:47:40 <Heffalump> ah, ok
10:47:49 <allbery_b> integral: hackage?
10:47:52 <Heffalump> doesn't dons have some recommendations on how to publish stuff?
10:47:58 <integral> allbery_b: Please show me where hackage actually exists.
10:48:08 <LoganCapaldo> @where how to write a haskell program
10:48:09 <lambdabot> I know nothing about how.
10:48:11 <allbery_b> currently it's "send mail to haskell@" I think.
10:48:17 <LoganCapaldo> Hmm
10:48:20 <allbery_b> @go how to write a haskell program
10:48:21 <integral> umm, well that's slightly crap.
10:48:21 <Saizan> haskell wiki?
10:48:22 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
10:48:22 <lambdabot> Title: How to write a Haskell program - HaskellWiki
10:48:37 <steven807> Great, lemme try rewriting using the hash table.  Thanks for the suggestion.
10:48:46 <allbery_b> it'd be nice if @woki did a search insteaf of translating what it's given into a possibly nonexistent iki page
10:48:49 <allbery_b> gr
10:48:52 <AStorm> I'd argue on that "Darcs" point :P
10:48:57 * allbery_b nto so much with the typing
10:48:57 <steven807> (I got fooled by the laziness of arrays into thinking that a big array wouldn't havde any cost)
10:49:13 <syntaxfree> too many dbs.
10:49:19 <syntaxfree> One for go, one for where.
10:49:35 <allbery_b> at least we don't have to maintain @google :>
10:49:36 <LoganCapaldo> I'd be nice if a failed where invoked go
10:49:45 <LoganCapaldo> *It'd
10:49:53 * LoganCapaldo goes and looks at lambdabots source
10:50:06 <Heffalump> steven807: I think the worst problem will be the cache locality
10:51:37 <sdjp> I suspect I;m missing something really obvious, but I can;t seem to dig it out of the usual sources:  How do I convert a Real to an Integral type?  (I want to compare an integer to the sqrt of something else, and am slowly losing the fight with the type system)
10:51:39 <steven807> Heffalump: Hm.  All I want is for a simple program to be faster than perl. I'm trying to convince a Perl guy of the inherent superiority of Haskell, and when the perl interpreter beats a haskell compiler, sadness ensues
10:51:54 <integral> @hoogle Double -> Integer
10:51:55 <lambdabot> No matches, try a more general search
10:51:56 <kowey> http://www.apple.com/macosx/leopard/timemachine.html
10:51:57 <lambdabot> Title: Apple - Apple - Mac OS X - Leopard Sneak Peek - Time Machine
10:51:58 <Stinger_> whats a quick way to trim whitespace from the start and end of a string?
10:51:59 <kowey> oops, wrong window
10:52:05 <LoganCapaldo> @hoogle (Real a, Integral b) => a -> b
10:52:07 <integral> @hoogle (Real a, Integral b) => a -> b
10:52:07 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
10:52:07 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
10:52:07 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
10:52:08 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
10:52:09 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
10:52:11 <AStorm> sdjp, fromFractional
10:52:11 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
10:52:24 <AStorm> ?type fromFractional
10:52:25 <lambdabot> Not in scope: `fromFractional'
10:52:30 <AStorm> Or whatever :P
10:52:33 <AStorm> ?type fromFraction
10:52:34 <integral> @hoogle floor
10:52:34 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
10:52:35 <lambdabot> Not in scope: `fromFraction'
10:52:37 <Philippa> steven807: the biggest speed boosts in Haskell programs seem to be in larger ones anyway
10:52:39 <AStorm> Yep floor
10:52:46 <integral> @hoogle (RealFrac a, Integral b) => a -> b
10:52:47 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
10:52:47 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
10:52:47 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
10:52:54 <integral> there they are :)
10:52:59 <AStorm> Other than that, fromRational
10:53:04 <Philippa> when laziness starts working in your favour across large chunks of code it's a very very nice thing indeed
10:53:05 <steven807> Philippa: OK, I'll be sure to give that as one of my excuses! :-)
10:53:07 <AStorm> But that's for some other type :P
10:53:34 <steven807> Yeah, my first a-ha with haskell was rewriting a Ruby program in haskell, and having it go a lot faster due to unexepcted laziness
10:53:35 <pejo> Binkley, without having any idea what htey are, there is a tar-ball for something other than tiger at http://www.haskell.org/ghc/dist/6.4/MacOSX/, and same with 6.2.2 at http://www.haskell.org/ghc/dist/6.2.2/MacOSX/
10:53:36 <lambdabot> Title: Index of /ghc/dist/6.4/MacOSX
10:54:20 <AStorm> Is there some mail server written in Haskell? (as in IMAP/SMTP)
10:54:41 <AStorm> Or do I have to write one myself? :P
10:55:03 <allbery_b> go for it, you know you want to :p
10:55:44 <AStorm> Yeah, but unfortunately studies are time-consuming :P
10:55:49 <allbery_b> (just make sure you've got the psych on call beforehand...)
10:56:02 <AStorm> Why? Haskell has proper networking
10:56:13 <AStorm> and I know the protocols almost by heart anyway :P
10:56:34 <AStorm> Lazy mail server sounds funny
10:56:42 <allbery_b> the problem with anything involving email is that there are standards... and then there's what actual programs do, which is invariably different in brain-twisting ways
10:56:42 <AStorm> messages sent lazily :P
10:56:54 <AStorm> I know, I know
10:56:56 <pejo> Binkley, doh. You were disconnected.
10:57:05 <AStorm> That's why I've the annotations to the standards :P
10:57:07 <Binkley> pejo: yeah, sorry, network sucks, but philippa sent me what you said
10:57:22 <pejo> Binkley, <repeat>  without having any idea what they are, there is a tar-ball for something other than tiger at http://www.haskell.org/ghc/dist/6.4/MacOSX/, and same with 6.2.2 at http://www.haskell.org/ghc/dist/6.2.2/MacOSX/
10:57:23 <lambdabot> Title: Index of /ghc/dist/6.4/MacOSX
10:57:40 <sdjp> Hmm.  Floor (and friends) doesn't seem to be helping.  Must have another error in there that's obscuring it, or something.  I've pasted the code at http://rafb.net/p/MiuW7983.html - any suggestions?
10:58:21 <integral> sdjp: why do you bother with an if statement in isFactor?
10:58:22 <Binkley> pejo:  thanks, I'll see if any of those help
10:58:41 <integral> sdjp: the error is about a misapplication of functions, it's (floor sqrt n) that's at fault.
10:58:49 <augustss> sdjp: you have to write floor (sqrt x)
10:58:52 <integral> (floor (sqrt n))
10:59:02 <pejo> Binkley, (I don't think they build HEAD with old versions that often, atleast that was a problem when I was on Solaris).
10:59:05 <augustss> sorry, floor (sqrt n)
10:59:28 <Binkley> pejo: yes, I've inferred that :-)
10:59:34 <sdjp> integral because I didn't know any better when I worte that (do now).
10:59:38 <augustss> sdjp: but that's a very inefficient way to do the test.  you should do x*x < n
10:59:44 <AStorm> Because floor sqrt n parses as an application of function to two arguments
10:59:53 <AStorm> Yes, x**2 < n
11:00:09 <augustss> no, not x**2, x*x, or x^2
11:00:27 <AStorm> x*x == x**2
11:00:31 <AStorm> More or less
11:00:46 <augustss> x**2 involves exp and log
11:00:50 <AStorm> Huh?
11:00:53 <augustss> it's even slower
11:00:54 <AStorm> ?type (**)
11:00:56 <lambdabot> forall a. (Floating a) => a -> a -> a
11:00:59 <AStorm> ?type (^)
11:01:00 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:01:08 <sdjp> Changing the brackets jsut gives a different type error .. pasted at http://rafb.net/p/52U0QX69.html
11:01:14 <AStorm> I don't know what does he want to filter
11:01:40 <sdjp> augustss, tru could be reqritten to be more efficent.  but at the moment, I want to understand the type system issues first - else they'll just bite me again some other time.
11:02:04 <LoganCapaldo> sdjp: Just write the type annotation and it will be quiet
11:02:16 <augustss> sdjp: another thing, if c then True else False is not necessary, just use c
11:02:34 <sdjp> Logan, What type annotation?
11:02:36 <AStorm> add some fromIntegral
11:02:53 <augustss> sdjp: you need to replace n by (fromIntegral n)
11:02:56 <AStorm> Because x is RealFrac and floor (sqrt x) is Integral
11:03:04 <augustss> sdjp: you can't use sqrt in integers
11:03:04 <pejo> Binkley, dare I ask why you don't upgrade your OS? Atleast here the pricing is quite fair, imho.
11:03:22 <sdjp> Doh!  RIght I think I'm begining to get it....
11:03:24 <Binkley> pejo: because my internal DVD drive is broken, they won't sell me a new one, and they won't sell me Tiger on CD
11:03:38 <Binkley> pejo: so my only options are dealing with 10.2, buying a new Mac, or buying a PC
11:03:46 <Binkley> buying a PC is looking like a pretty good option lately
11:03:50 <augustss> sdjp: and then factorWalk should just be replaced by filter :)
11:03:57 <AStorm> Exactly
11:03:58 * allbery_b hears intel macs are pretty sweet :)
11:04:09 <Binkley> allbery: give me $1300 and I'll probably agree with you :-)
11:04:09 <AStorm> allbery_b, and pretty expensive
11:04:49 <Binkley> new DVD drive + Tiger + more RAM + new battery = probably over $500 already, and for that, I could get a pretty good PC laptop
11:04:53 <Binkley> I like Macs
11:05:00 <Binkley> but I'm not sure they're worth that much of my money atm
11:05:47 <allbery_b> that would be why I only hear it :/
11:05:56 <Binkley> yep
11:06:02 <Binkley> given that I'm unemployed at the moment, too...
11:06:28 <allbery_b> that said, I find OSX is worth the price difference over a winbox (and just don't get me started on linux/*bsd desktops)
11:06:38 <allbery_b> otoh, that would be a proble :(
11:06:43 <Binkley> allbery: o rly? i was thinking of getting a pc laptop and putting FreeBSD on it
11:06:46 <AStorm> Hah, I actually prefer Linux :P
11:06:46 <Binkley> is that a terrible idea?
11:06:54 <Binkley> well, that question is aimed at anyone who can answer it
11:07:13 <augustss> Binkley: i think it's a good idea.  (even though i have a macbook myself)
11:07:20 <allbery_b> IMO the state of the art in linux/*BSD desktops is stuck in the stone age
11:07:33 <pejo> Binkley, shrug, the suspend stuff works flawlessly on my mac. Not necessarily the case if you put one of the free unices on a pc laptop.
11:08:25 <monochrom> desktop is overrated
11:08:36 <allbery_b> suspend/resume, integration, etc.
11:08:37 <Saizan> GUIs are overrated
11:08:54 <Binkley> pejo: that's funny, my mac crashes every time I try to put it to sleep :-)
11:08:55 <augustss> emacs is all the gui one needs :)
11:09:00 <Binkley> computers are overrated
11:09:03 <Binkley> let's just all use abaci
11:09:16 <Saizan> yeah!
11:09:26 <Saizan> how do i compile haskell to abaci?
11:09:26 <Binkley> Soda Hall at Berkeley had an emergency abacus
11:09:29 <pejo> Binkley, heh. As for upgrading - no USB DVD-drive avail that you can use for the upgrade?
11:09:31 <Binkley> for when the power went out
11:09:39 <Binkley> pejo: sure, if I want to spend $150 on one...
11:09:43 <pejo> Binkley, external, I mean.
11:09:45 <AStorm> I prefer solar-powered calculators
11:09:48 <Binkley> even an external
11:09:50 <Binkley> is that much
11:10:01 <AStorm> Where solar == infrared
11:10:11 <allbery_b> guis aren't the only, or even the primary, issue (although X11 cut&paste shouls be taken out and shot).  you need to be a serious hacker to get plug&play, suspend/resume, etc. working
11:10:17 <sdjp> Binkley, if you;ve got an ATAPI dvd drive, a $15 USB -> IDE converter will do the job
11:10:25 <integral> AStorm: don't work inside though which is where a slide rule wins
11:10:28 <Binkley> sdjp: I have no dvd drives
11:10:33 <integral> s/inside/in the dark/
11:10:36 <augustss> allbery_b: but the hacking is part of the fun!
11:10:37 <AStorm> Do work inside :P
11:10:49 <monochrom> plug&play, suspend/resume, etc. are not part of desktop
11:10:51 <Binkley> augustss: depends on your definition of "fun" :-P
11:10:53 <allbery_b> augustss:  I do enough of that at work, thanks
11:10:54 <AStorm> Due to built-in rechargable battery
11:11:06 <AStorm> Other than that, log slide is the best :P
11:11:22 <Binkley> more time spent on getting my OS to work properly means less time to hack ghc
11:11:24 <augustss> this MacBook was the first time I got a laptop that I didn't write a few device drivers.
11:11:31 <Binkley> haha
11:11:32 <pejo> Binkley, I'd say steal one from one of your friends. Maybe even return it - could say you just borrowed it if they ask.
11:11:41 <Binkley> pejo: my friends don't have those things
11:11:43 <AStorm> Haha, I don't have to, my OS almost always works properly
11:11:56 <Binkley> I've thought about writing device drivers for hardware that I had
11:11:59 <Binkley> then I thought
11:11:59 <AStorm> Sometimes things don't compile, but I don't have to be _that_ up to date.
11:12:02 <pejo> augustss, heh, and you love it - admit it. ;)
11:12:06 <Binkley> "hey, I could spend $50 and buy some hardware that has a driver"
11:12:12 <augustss> pejo: of course I do
11:12:15 <Binkley> "and spend the extra time going for a bike ride"
11:12:24 <Binkley> but that's just me.
11:13:05 <pejo> augustss, but you're the reason us lazy bums have drivers for our hardware. Oh well, guess it's too late now.
11:13:10 <Binkley> heh
11:13:29 <augustss> pejo: this mac has spoilt me, i'm afraid
11:13:35 <Binkley> Maybe I should rephrase my question...
11:13:48 <Binkley> has anyone here successfully run FreeBSD (or something similar) on a laptop? and if so, can you recommend a laptop model?
11:13:50 <Binkley> because when I google
11:13:54 <Binkley> all I find is models to *avoid*
11:14:05 <AStorm> Well, most of them work fine.
11:14:06 <augustss> Binkley: i've run NetBSD on all my previous laptops
11:14:11 <AStorm> Except 3D graphics.
11:14:22 <AStorm> Maybe sometimes soundcard problems.
11:14:27 <AStorm> WiFi is problematic too.
11:14:29 <AStorm> :P
11:14:31 <Binkley> augustss: yes, but you just said you were writing your own device drivers, so for myself -- and I'm not as l33t as you -- that doesn't inspired a lot of confidence :P
11:14:45 * allbery_b used to run fbsd on IBM T30 and T42p, and his home "server" is actually a repurposed Dell Inspiron 5000e
11:14:50 <AStorm> My own is quite nice with Linux, EXCEPT that damn SiS chip. No 3D support.
11:15:03 <augustss> Binkley: well, I wanted everything to work.  the basic stuff usually worked fine
11:15:06 <Philippa> writing drivers isn't necessarily that hard if you've got all the relevant specs. Just damn tedious.
11:15:12 <Binkley> augustss: ok, good to know
11:15:16 <Philippa> (if you've merely got all the /available/ specs, OTOH...)
11:15:27 <Binkley> Philippa: exactly
11:15:32 <Binkley> there are only 24 hours in a day
11:15:38 <Binkley> and between 8 and 12 of them have to be spent sleeping
11:15:52 <allbery_b> (the T42p is currently at work running Solaris 10, mostly due to wrangling over IRS issues.  *grmbl*)
11:15:54 <opqdonut> Binkley: bah, 4 or 5 is enough
11:15:56 <augustss> writing a few device drivers build character ;)
11:16:03 <Binkley> opqdonut: I guess I picked the wrong parents.
11:16:14 <Binkley> augustss: I think I have a lot of character already
11:16:23 <Binkley> after 100 or 200 times building GHC
11:16:23 <opqdonut> Binkley: :)
11:16:25 <opqdonut> btdt
11:16:26 <pejo> augustss, heh, along with a few type checkers, and compilers?
11:16:27 <allbery_b> (and the lack of a working AFS client for current versions of fbsd)
11:17:05 <joelr1> i wanna buy a mac pro
11:17:56 <joelr1> 2 x 3Ghz (or the quad version), 8Gb memory, 3 x 750Gb drives and 2 x 23" monitors :D i'm afraid of overloading the electrical circuits in my apartment, though
11:18:05 <joelr1> and imagine the electricity bill!
11:18:59 <Binkley> joelr1: soon we'll all have electricity that's too cheap to meter anyway
11:19:06 <Binkley> or at least that's what Marshall McLuhan said in the '50s
11:19:12 <AStorm> Binkley, depends where
11:19:17 <Binkley> that was sarcasm
11:19:18 <allbery_b> use it as a space heater; compare electricity prices to gas prices any more :/
11:19:19 <joelr1> not in the canary islands
11:19:20 <AStorm> :>
11:19:21 <joelr1> he
11:19:31 <Binkley> except the mcluhan part is true
11:19:32 <sorear> Binkley: computers will expand to consume all available power
11:19:44 <Binkley> sorear: yeah, but it'll be OK, because the world will only need 5 computers anyway
11:19:53 <sorear> Need, yes.
11:21:43 <AStorm> Why 5 computers?
11:21:46 <AStorm> Just one.
11:21:52 <AStorm> Total Annihilation anyone?
11:21:57 <sorear> I think 0
11:21:58 <Binkley> AStorm: some DEC executive famously said that in the 1970s
11:22:08 <Binkley> or something like that.
11:22:15 <Philippa> Binkley: IBM
11:22:21 * Binkley stands corrected
11:22:23 <allbery_b> IBM, 50s or thenabouts
11:22:24 <Philippa> IBM went into computers to teach the bosses's son a lesson
11:22:29 <Binkley> '50s, '70s, same difference
11:22:32 <Philippa> boss's, even
11:22:35 <Binkley> I wasn't born yet in either decade
11:22:38 <Binkley> so they're all the same to me
11:22:42 <Philippa> hmm, I keep *saying* I'm tired, I should try sleep
11:22:58 <sorear> DEC, I'm told, called their computers "data processors" because the market for "computers" was so small.
11:23:12 <Binkley> also, "computer" referred to a profession for a human, before the 1950s
11:23:21 <sorear> But I wasn't born in either either...
11:23:48 <sorear> automatic computers!
11:25:33 * allbery_b notes that he's read late '20s science fiction in which the devices are "calculators" and their operators "computers"
11:26:19 <allbery_b> (the devices in question being rather mroe sophisticated than what we call calculators, HP48 notwithstanding :)
11:26:27 <lisppaste2> ph8 pasted "Repeated Generation?" at http://paste.lisp.org/display/33714
11:26:35 <ph8> hey peeps :p
11:26:38 <ph8> I overcame my other problem
11:26:44 <sorear> good
11:26:47 <ph8> a bit of a takeWhile headache ^ though :/
11:28:49 <yaxu> ?ghc
11:28:49 <lambdabot>  absApply: Duff function
11:29:11 <ph8> hi sorear :)
11:29:13 <lightstep> list comprehensions use "<-" for generators, not "="
11:30:00 <lightstep> also, if the return type IO () is correct, does it mean that you want to print the final result?
11:30:08 <ph8> indeed
11:30:12 <ph8> at least for now
11:30:24 <yaxu> haskell has some googlejuice problems, searching for ghc only finds an old page with a broken link, and searching for haskell wiki only brings up the old wiki
11:30:33 <augustss> ph8: you should separate generation and printing.  mixing them is bad
11:30:37 <ph8> so x<- a lightstep?
11:30:45 <ph8> i wanted to print at each stage just to check
11:30:47 <ph8> i'll take the trace out
11:30:50 <lightstep> yes
11:30:51 <ph8> oh wait
11:30:54 <sorear> otoh, searching for happy gives a parser generator at #6
11:30:59 <ph8> eventually it'll generate, then print
11:31:00 <ph8> i would've thought
11:31:05 <ph8> the printing at this stage is really for debug
11:31:42 <lightstep> it's just that the types won't work out: the last expression is a list of things, and needs to be an IO action
11:31:56 <ph8> ERROR "Main.lhs":64 - Syntax error in expression (unexpected `;', possibly due to bad layout)
11:31:57 <ph8> odd error
11:31:59 <ph8> ah
11:32:09 <ph8> so i can putStrLn the whole thing, since it should be a list?
11:32:38 <ph8> line 64 is the line starting x= ..
11:32:42 <ph8> which has no ; on!
11:32:55 <lightstep> no, you call putStrLn on strings. to print list, use "print"
11:33:43 <LoganCapaldo> ph8 haskell transforms it into the { ; } syntax from your layout
11:34:22 <lightstep> mybe try to indent the list more than the do block
11:35:43 <ph8> i have done now
11:36:06 <ph8> ?type takeWhile
11:36:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:39:34 <ph8> i'm quite away off with this attempt it appears :p
11:46:32 <ph8> x <- (takeWhile (\x -> (last x) /= '.') a)
11:46:39 <ph8> is that syntactically correct anyone?
11:46:54 <ph8> each element of a will be taken until it encounters one with a . on the end?
11:47:11 <LoganCapaldo> ph8: takeWhile isn't monadic
11:47:25 <LoganCapaldo> you'd want let x = takeWhile ...
11:47:33 <paolino> from profiling this function
11:47:34 <LoganCapaldo> oh wait I lied
11:47:34 <paolino> switch l i = l // [(i,not (l!i))]  using Data.Array
11:47:34 <paolino> is my problem. Is there a recipe to get it better ?
11:47:35 <ph8> monadic?
11:47:36 <ph8> i'll look it up
11:47:42 <LoganCapaldo> it could be if its a list of lists
11:48:28 <LoganCapaldo> remember that <- isn't assignment
11:48:45 <LoganCapaldo> it's syntactic sugar for >>= (\x -> ...
11:48:48 <ClaudiusMaximus> how do i fix "Couldn't match Float against Int, expected type Float, inferred type Int, in the expression x/d in the list element x/d"   where d::Int and x <- [0..d]  in a list comprehension?  preferably with minimum verbosity...
11:49:05 <norpan> ClaudiusMaximus: use `div` instead?
11:49:07 <ph8> oh my
11:49:09 <ph8> what's >>=?
11:49:22 <LoganCapaldo> it's bind
11:49:32 * ph8 opens the book
11:49:35 <lightstep> that's how you bind results of computations
11:49:36 <LoganCapaldo> you probably just want let x = takeWhile ...
11:49:49 <ph8> ok, and that returns a list of all matching operators?
11:49:52 <ClaudiusMaximus> norpan: i want a Float as output, otherwise i'd get [0,0,0,0,...,0,0,1]
11:49:53 <lightstep> "let" binds simple haskell values
11:49:56 <norpan> ClaudiusMaximus: or rather, do fromIntegral x
11:49:57 <ph8> i'm trying to iterate over the list
11:49:58 <ph8> hmm
11:50:01 * allbery_b suspects this is a red herring, ph8 is almost certainly not working in the list monad
11:50:06 <ph8> indeed
11:50:08 <ph8> let me think about it a bit more
11:50:09 <ph8> back shortly :p
11:51:01 <ClaudiusMaximus> norpan: k, that means i need 4*8 times fromIntegral...   guess i could call it f and add just 64 characters... sigh...
11:51:29 <ph8> i have a list of strings. (genNext string mapRef) will return one word, which then needs to be passed back into genNext prefixed by the last word of the original string
11:51:44 <ClaudiusMaximus> norpan: ...or come up with an algorithm instead of just listing stuff
11:51:44 <norpan> ClaudiusMaximus: i'm not following you? you only need fromIntegral where you have the division
11:51:44 <ph8> "cat" "sat" would be the first argument while "sat" "on" would be the next
11:52:43 <ClaudiusMaximus> norpan: i have [ [x/d,y/d,z/d,w/d] | x<- [0..d], y<-[0..d], z<-[0..d], w<-[0] ]  , repeated 8 times with minor variation...
11:53:18 <norpan> d is float?
11:53:23 <norpan> no
11:53:28 <ClaudiusMaximus> norpan: d is Int
11:53:33 <norpan> both x and d are integers
11:53:35 <allbery_b> or define /. as fromIntegral x / fromIntegral y and global subst all your / with /. (but then you look like you're doing ML :)
11:53:52 <sorear> paolino: the monadic arrays (Data.Array.MArray) are much faster at updates
11:54:53 * ClaudiusMaximus likes allbery_b's way better, less typing...
11:55:17 <sorear> map fromIntegral [1,3,4,5,6] ?
11:55:50 <paolino> sorear , where I learn to use em ?
11:56:33 <sorear> I think it
11:56:39 <ClaudiusMaximus> thanks allbery_b, got it working  (or at least compiling correctly)
11:57:01 <lightstep> ?wiki Modern array libraries
11:57:01 <lambdabot> http://www.haskell.org/haskellwiki/Modern array libraries
11:57:05 <ClaudiusMaximus> thanks also norpan, sorear for your attention :)
11:57:21 <sorear> 's fairly simple - do x <- newArray (0,100) Bool :: IO (UArray Int Bool) ; readArray x 15
11:57:25 <lightstep> ?wiki Modern_array_libraries
11:57:26 <lambdabot> http://www.haskell.org/haskellwiki/Modern_array_libraries
11:57:30 <allbery_b>  @wiki doesn't search, it just wikiurl-fies your string
11:57:38 <lightstep> paolino, that's the page
11:57:42 <allbery_b> if you're lucky it'll even be what you want
11:57:51 <sorear> also , #haskell may help
11:58:30 <paolino> ok, I read up, thnks
12:01:56 <ClaudiusMaximus> next question:  how do i go from [Array a b] -> Array a [b]   (the bounds are guaranteed all to be equal)
12:02:22 <ClaudiusMaximus> maybe i shouldn't ask so quick and figure it out myself...
12:02:34 <monochrom> you have to write the code
12:03:06 <Saizan> seems like a sequnce in the Array a monad :D
12:03:15 <Saizan> ?type sequence
12:03:17 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
12:03:31 <monochrom> there is a simple way, but it traverses the input list several times.
12:04:24 <lisppaste2> ph8 annotated #33714 with "RepGen Version 2" at http://paste.lisp.org/display/33714#1
12:04:35 <ph8> i think that's more like it :p
12:04:39 <LoganCapaldo> @hoogle [Array a b] -> Array a [b]
12:04:40 <lambdabot> No matches, try a more general search
12:04:43 <ph8> but i get some weird token error (attached)
12:05:34 <allbery_b> missing '=' on line 61
12:05:46 <ph8> danke
12:05:51 <ClaudiusMaximus> no instance for Monad (Array a) :(
12:07:06 <ph8> hmm
12:07:07 <ph8> type errors
12:07:07 <ph8> fun
12:07:10 <lightstep> ph8, also, you would need to use "return" on the second clause, to project that list into IO
12:07:14 <LoganCapaldo> instance Monad (Array a) where ... ;)
12:07:24 <LoganCapaldo> Just rip off the def of the list monad :)
12:07:29 <quazimodo> morn
12:07:48 <LoganCapaldo> (That probbaly wouldn't actually work)
12:08:01 <allbery_b> next you'll be wanting array comprehensions :p
12:08:15 <chessguy> hiya haskellers
12:08:33 <ph8> lightstep: just altered io() to [[char]] :)
12:08:33 <ph8> cheers
12:08:36 <jgrimes> hi chessguy, everyone
12:08:43 <ph8> ah and now it doesn't match
12:08:45 <ph8> i'll use return :p
12:08:46 <chessguy> hey jgrimes
12:08:56 <lightstep> ph8, to print stuff you need IO
12:09:58 <ph8> indeed
12:10:13 <ph8> apart from there i actually wanted to return something :p
12:10:16 <ph8> will print for the moment
12:10:18 <ph8> then i can get rid of all the io
12:10:26 <LoganCapaldo> allbery_b: well if you got past the hurtle of defining MonadPlus for Arrays you'd get Array comprehensions with do notation :)
12:10:53 <LoganCapaldo> Although the size is part of the type, isn't it in Haskell?
12:11:03 * allbery_b watches boost-python build in fbsd ports, throwing C++ warnings that make ghc error messages look readable by comparison
12:11:13 <ski> LoganCapaldo : it's part of the value
12:11:14 <opqdonut> :)
12:11:26 <LoganCapaldo> So you could do it
12:11:30 <allbery_b> "instantiated from (thousands of characters of glop)"
12:11:43 <LoganCapaldo> I wouldn't want to do all that work :)
12:11:48 <LoganCapaldo> to call sequence
12:11:52 <chessguy> wow, making ghc errors look readable is pretty bad
12:11:55 <benja_> wow. for like forever I've put off learning how to set up darcs tab complete with bash so that I wouldn't have to figure out how to do it
12:12:01 <opqdonut> chessguy: c++ templates, yugh
12:12:08 <benja_> now I notice that it works out of the box with ubuntu
12:12:10 <allbery_b> warnings/errors involving C++ templates are pretty horrible
12:12:12 <chessguy> heya opq
12:12:14 <benja_> I just ... never tried :-o
12:12:15 <ph8> lol?
12:12:18 <ph8> the io never happens because of laziness
12:12:19 <benja_> (on this system anyway)
12:12:23 <ph8> because i'm never using the result?
12:12:25 <benja_> @karma+ ubuntu
12:12:26 <lambdabot> ubuntu's karma raised to 1.
12:12:28 <sorear> works out of the box here too (debian-unstable)
12:12:29 <opqdonut> :)
12:12:34 <opqdonut> hi chessguy
12:12:36 <ph8> is there an easy way to force my let result = repGen ... to be evaluated?
12:12:44 <ph8> without taking away all my IO and making it return something?
12:12:56 <ph8> ubuntu++
12:13:02 <ph8> tis what i'm using right now
12:13:18 <allbery_b> @hoogle evaluate
12:13:19 <lambdabot> Control.Exception.evaluate :: a -> IO a
12:13:19 <metaperl> I've never seen "!" in a data declaration before... what does this mean: data Posn = Pn String !Int !Int (Maybe Posn)
12:13:19 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
12:13:29 <sorear> sid++ also works
12:13:33 <allbery_b> metaperl: that value is strict
12:13:46 <metaperl> oh, eagerly evaluated
12:13:48 <metaperl> ?
12:13:53 <allbery_b> yes
12:13:54 <benja_> meaning, the constructor evaluates it when it is applied to the value
12:14:01 <metaperl> interesting
12:14:11 <metaperl> that was from the HaXML source
12:14:32 <LoganCapaldo> heheh, what about data Force a = Force !a
12:15:12 <LoganCapaldo> let force x = let (Force z) = x in z
12:15:36 <opqdonut> chessguy: how's the genetic stuff coming along?
12:15:42 <LoganCapaldo> Or did I just introduce a new layer of laziness by defining force?
12:15:49 <chessguy> oh, i haven't played with it
12:16:02 <chessguy> i just got back from a week or so at my fiancee's parents' place in texas
12:16:07 <ph8> argh!
12:16:08 <ph8> >		print ("Done, Result = " ++ (result))
12:16:10 <ph8> result is a list
12:16:14 <lightstep> LoganCapaldo, you didn't. without the "!", you would have. your definition is exactly equivalent to a simple newtype
12:16:15 <ph8> i've tried 'show'
12:16:18 <ph8> and 'putStrLn'
12:16:27 <ph8> but it keeps erroring, can anyone tell me the proper way to be outputting it there?
12:16:41 <lightstep> putStrLn ("Done, Result = " ++ (show result))
12:16:47 <LoganCapaldo> lightstep: I meant the force function
12:16:58 <ph8> hmm ty, thought i'd tried that
12:17:00 <ph8> just a jiff
12:17:06 <LoganCapaldo> all though its wrong anyway
12:17:21 <ph8> ERROR "Main.lhs":38 - Unresolved top-level overloading
12:17:28 <ph8> *** Outstanding context : Show ([[Char]] -> [[Char]])
12:17:38 <ph8> gargh?
12:17:38 <chessguy> opqdonut, i haven't even had a chance to read over your summary, unfortunately :(
12:17:39 <LoganCapaldo> let force x = case (Force x) of Force z -> z
12:17:54 <opqdonut> chessguy: heh holidays and stuff?-)
12:18:05 <chessguy> yes, lots of stuff :)
12:18:07 <lightstep> ph8, that means you're calling show on a string
12:18:09 <allbery_b> sounds like your "result" is a function
12:18:11 <lightstep> err, on a function
12:18:22 <ph8> let result = (repGen genWords theMap)
12:18:28 <ph8> repGen returns a [[char]]
12:18:34 <allbery_b> are you missing a parameter?
12:18:40 <ph8> i am :)
12:18:41 <chessguy> i managed to take 5 finals, get engaged, get hired, graduate, and celebrate Christmas with 3 families in 2 states...all in a week
12:18:42 <ph8> rofl
12:18:42 <kowey> ahh, but repGen is IO
12:18:50 <ph8> not anymore
12:18:57 <kowey> paste?
12:19:00 <ph8> muwahaha
12:19:01 <ph8> it compiles
12:19:03 <ph8> two jiffys
12:19:18 <chessguy> so....it's been a little crazy
12:19:22 <paolino> is  DiffUArray Int Bool a legal type ?
12:19:25 <Binkley> chessguy: huh, you must be pretty bored
12:19:39 <ph8> progress of sorts :)
12:19:42 <chessguy> Binkley, :)
12:20:10 <lisppaste2> ph8 annotated #33714 with "Repgen behaving as expected, which isn't as specified - but that's my fault! :p" at http://paste.lisp.org/display/33714#2
12:20:17 <chessguy> and my stupid desktop crashed after i backed everything up to it
12:20:27 <lightstep> the problem with using lists and strings, is that sometimes your program compiles but still has bugs
12:20:28 <metaperl> this Haddock thing is bad-ass
12:20:51 <opqdonut> chessguy: woah, that's lot of stuff
12:21:01 <opqdonut> i've just worked on my own projects
12:21:13 <opqdonut> tho we did go for a trip to lapland just now
12:21:28 <Binkley> all that's happened to me is having to leave the best job of my life, getting my life dreams crushed, and then rebuilding them again
12:21:36 <Binkley> so it's been pretty boring lately for me too
12:21:43 <Binkley> that's why I'm trying to build GHC
12:21:49 <Binkley> to liven things up a bit.
12:21:57 <chessguy> sounds....stretching
12:22:05 <opqdonut> :)
12:22:27 <chessguy> a learning experience, even if not a fun one
12:22:43 <araujo> hello!
12:22:54 <Binkley> chessguy: yes, as I put it, "another fucking learning experience"
12:23:02 <sorear> What standard library function should I use for UTF-8 encoding a character?
12:23:04 <Binkley> or, like, 8 of them
12:23:27 <araujo> sorear, i think there is no standard func for it
12:24:05 <paolino> mmhh I have NO time difference in using DiffArray instead of  Array, strange
12:24:14 <rohar> ah lapland.. I was there for the solstice
12:24:32 <Stinger_> ?where regex-pcre
12:24:33 <lambdabot> http://darcs.haskell.org/packages/regex-pcre/
12:24:57 <ravehanker> Show off your Programming Skills and Walk away with 1000USD on new year's eve! go to http://opc.kurukshetra.org.in
12:25:01 <lambdabot> Title: Online Programming Contest
12:25:37 <ph8> argh
12:25:38 <ph8> pastebin's down
12:25:51 <ph8> and it's running apache 1.3.33(!)
12:25:58 --- mode: ChanServ set +o dmhouse
12:26:08 <allbery_b> use sial.org/pbot or pastebin.{com,ca} or etc.
12:26:22 <ph8> i'd rather spin around in circles like a headless chicken :)
12:26:23 <dmhouse> ravehanker: no advertising in here, if you please.
12:26:34 <ravehanker> dmhouse:- Sorry, My Aplogies
12:26:44 <jgrimes> o.o
12:26:47 --- mode: dmhouse set -o dmhouse
12:27:10 <dmhouse> What a polite spammer.
12:27:22 <Binkley> heh
12:27:23 <opqdonut> :DDD
12:27:29 * allbery_b suspects that was just an overeager kid, not the usual spammer
12:27:35 <chessguy> heh. you can't even submit in haskell
12:27:39 <Binkley> tbh I prefer spammers who never say anything to spammers who are polite when you correct them
12:27:48 <ph8> http://pastebin.com/848022 <-- all i've done is add in the debug trace's, obviously in a retarded fashion that i can't fathom
12:27:55 <allbery_b> otherwise he'd've splatted it immediately on joining
12:27:59 <Cale> Wait a minute, he didn't givve us his apologies, he gave us his aplogies
12:28:00 <ph8> leads to a "type error in final generator" error
12:28:13 <ph8> lol Cale?
12:28:18 <Binkley> Cale: strictly speaking, he didn't givve us his apologies, but rather give us his apologies
12:28:19 <Binkley> ;-)
12:28:36 <Cale> Binkley: that's true as well :)
12:29:07 <chessguy> you knew his semantics though :)
12:29:22 <sorear> Suppose I have some Char's, and I need to output them in UTF-8.  Since there is apparantly no standard library function to do this, whose code should I copy?
12:29:37 <sorear> Google give too many results.
12:29:42 <kowey> ph8: i think it's because of your indentation
12:30:00 <kowey> ph8: actually, you don't really need that do anymore, so you could just get rid of that
12:30:14 <ph8> nice
12:30:17 <ph8> compiles without the do
12:30:17 <ph8> :)
12:30:23 <ph8> *hugs*
12:30:37 <Binkley> *ghci*
12:31:59 <ph8> > head [1..5]
12:32:00 <lambdabot>  1
12:32:01 <ph8> always a joker
12:33:33 <ph8> *gofer*
12:33:46 <AStorm> > let ph8 = [0] in head ph8
12:33:48 <lambdabot>  0
12:33:53 <allbery_b> *http*
12:33:54 <ph8> heh
12:33:59 <ph8> cya same time same place tomorrow
12:34:46 <AStorm> sorear, you mean encode something to UTF-8?
12:35:49 <sorear> yes
12:35:59 <sorear> I have 1 character (at a time)
12:36:01 * kowey uses the UTF8.lhs code in darcs (which seems not come from darcs itself)
12:36:02 <metaperl> why is mkElem listed twice here: http://www.cs.york.ac.uk/fp/HaXml-devel/HaXml/doc-index-M.html  ... once as "1 (Function)	Text.XML.HaXml.Combinators, Text.XML.HaXml" and again as "2 (Function)	Text.XML.HaXml.XmlContent"
12:36:09 <kowey> this may not be the best choice, though
12:36:15 <sorear> I'm adding UTF-8 support to vty
12:36:35 <lightstep> pugs has it too
12:36:44 <kowey> is the same module?
12:38:31 <kowey> oh, looks like the pugs one deals with ByteString
12:45:29 <paolino> a = listArray (0,10) (repeat False):: DiffUArray Int Bool
12:45:30 <paolino> fails to compile
12:45:58 <paolino> with instances problems
12:48:13 <paolino> Is it onlz in 6.4 ?
12:52:18 <Binkley> paolino: what error are you getting?
12:54:32 <Saizan> mmh seems that there's not an unboxed instance for Bool
12:57:15 <paolino>   No instance for (IArray (IOToDiffArray Data.Array.IO.Internals.IOUArray) Bool)
12:57:16 <paolino>       arising from use of `listArray' at prova10.hs:4:4-12
13:05:04 <lisppaste2> metaperl pasted "any HaXML hackers out there? trying to Show the element I made" at http://paste.lisp.org/display/33721
13:09:16 <_matthew_> I have a tuple of (Something, Double, Vector) and I want to sort them by the Double
13:09:39 <_matthew_> so how do I use sortBy and return the comparator of the doubles?
13:10:24 <_matthew_> as in sortBy (\(_, a, _) (_, b, _) -> aghWhatGoesHere a b) [list of tuples]
13:10:28 <LoganCapaldo> sortBy (\(_,a,_) (_,b,_) -> compare a b)
13:10:34 <_matthew_> ahh, thanks
13:10:38 <LoganCapaldo> I think
13:10:39 <_matthew_> :t comare
13:10:40 <lambdabot> Not in scope: `comare'
13:10:41 <_matthew_> :t compare
13:10:43 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:10:46 <_matthew_> super. thanks
13:10:47 <LoganCapaldo> don't quote me on that one :)
13:10:48 <norpan> :t compareBy
13:10:49 <lambdabot> Not in scope: `compareBy'
13:12:38 <xerox> :t \f -> sortBy (\(_, a, _) (_, b, _) -> f a b)
13:12:40 <lambdabot> forall a b c. (b -> b -> Ordering) -> [(a, b, c)] -> [(a, b, c)]
13:12:50 <xerox> ?hoogle b -> b -> Ordering
13:12:51 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
13:12:53 <xerox> ta-da.
13:13:45 <augustss> all you need is lambdabot
13:14:08 <xerox>    -- The Beatles.
13:14:24 <LoganCapaldo> @pl (\(_,a,_) (_,b,_) -> compare a b)
13:14:25 <lambdabot> (line 1, column 7):
13:14:25 <lambdabot> unexpected ","
13:14:25 <lambdabot> expecting letter or digit, operator or ")"
13:14:25 <lambdabot> ambiguous use of a non associative operator
13:14:40 <LoganCapaldo> allll righty
13:14:41 <xerox> No way.
13:14:52 <Saizan> pl hates triples
13:15:09 <xerox> The library writers do
13:15:17 <_matthew_> @pl (\(_,(a,_)) (_,(b,_)) -> compare a b)
13:15:19 <augustss> there are no functions on triples
13:15:21 <_matthew_> ;)
13:15:22 <lambdabot> flip ap snd . (. fst) . const . flip ap snd . (. fst) . (const .) . compare . fst . snd
13:15:22 <lambdabot> optimization suspended, use @pl-resume to continue.
13:15:24 <allbery_b> @pl (\ (_,a,_) (_,b,_) -> compare a b)
13:15:24 <lambdabot> (line 1, column 8):
13:15:25 <lambdabot> unexpected ","
13:15:26 <lambdabot> expecting letter or digit, operator or ")"
13:15:28 <lambdabot> ambiguous use of a non associative operator
13:15:30 <allbery_b> huh
13:15:31 <_matthew_> woot!
13:16:29 <augustss> @pl (\(a,_) (b,_) -> compare a b)
13:16:32 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
13:16:48 <augustss> messy
13:17:14 <norpan> compareBy f a b = compare (f a) (f b)
13:17:15 <xerox> :t let by f g x y = f x `g` f y in compare `by` fst
13:17:16 <lambdabot>   Couldn't match `(a, b)' against `a1 -> Ordering'
13:17:16 <lambdabot>    Expected type: (a1 -> Ordering) -> (a1 -> Ordering) -> t
13:17:19 <xerox> Arrrr.
13:17:34 <lightstep> ?type comparing
13:17:36 <augustss> xerox: I thought that function is called on
13:17:37 <lambdabot> Not in scope: `comparing'
13:17:42 <xerox> ...on, ah.
13:17:58 <xerox> Makes sense.
13:18:07 <augustss> compare `on` fst
13:18:12 <augustss> reads quite nicely
13:18:19 <Syzygy-> ?type on
13:18:20 <lambdabot> Not in scope: `on'
13:18:25 <LoganCapaldo> ?type off
13:18:27 <lambdabot> Not in scope: `off'
13:18:30 <LoganCapaldo> the typer
13:18:42 <_matthew_> ?type dimmerSwitch
13:18:43 <lambdabot> Not in scope: `dimmerSwitch'
13:18:57 <augustss> Syzygy-: on has not quite made it into the libraries yet
13:18:58 <Syzygy-> So the compare `on` fst wasn't really something that exists already?
13:19:01 <Syzygy-> Ah.
13:19:08 * allbery_b thought on wa sin ghc head, while lb is ghc6.5
13:19:21 <Syzygy-> Does it exist (anywhere public)? And what does it do?
13:19:54 <lightstep> f `on` g = \x y -> g x `f` g y
13:19:56 <Saizan> :t let on f g x y = f (g x) (g y) in compare `on` fst
13:19:57 <xerox> http://www.haskell.org/hawiki/LicensedPreludeExts
13:19:58 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
13:19:59 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
13:20:00 <augustss> Syzygy-: it's in ghc head
13:20:16 <xerox> Oh, there's just comparing there.
13:20:39 <Syzygy-> Ah.
13:20:47 <Cale> `on` is nice, but I prefer to also define comparing separately
13:21:40 <augustss> `on` is useful with, e.g., groupBy as well
13:22:56 <lisppaste2> metaperl pasted "trying to get a simple HTML document to print in HaXML... help needed" at http://paste.lisp.org/display/33722
13:23:07 <Cale> What people have called "equating" (on (==)) is also pretty handy. I'm not sure if that's the best name for it.
13:23:35 <augustss> personally, i prefer to use `on` for both
13:37:20 <jgrimes> if I have some type that has two type arguments, and then I create a type synonym for it that only has one type argument, why would declaring an instance of Functor on the type synonym ask me to provide a type argument?
13:40:38 <augustss> jgrimes: type synonyms must always be fully applied
13:41:31 <norpan> declare the instance on the original data type instead
13:41:31 <syntaxfree> sometimes it scares me that I understand most of what is said in this channel.
13:41:54 <opqdonut> :)
13:42:42 <augustss> your brain must be getting full of haskell junk ;)
13:45:26 <augustss> jgrimes: by "always" I meant in instance declarations.  but come to think of it, I'm not even sure it's true. :)
13:47:36 <jgrimes> augustss, hopefully I'll figure that out sometime. For now I just went with what norpan suggested. :)
13:48:44 <augustss> jgrimes: what norpan suggested is the right thing, because the instance is always for the data-type, not the synonym.  H98 doesn't even allow you to use synonyms in instance declarations
13:49:24 <_matthew_> @pl or
13:49:25 <lambdabot> or
13:49:41 <_matthew_> grr. how is it implemented? foldl ? how do you shortcut the recursion?
13:50:03 <mgsloan> yeah, a lambdabot define thing would be cool
13:50:12 <mgsloan> as most of the prelude funcs are very short
13:50:17 <augustss> foldr (||) False
13:50:43 <_matthew_> ahh, of course.
13:51:28 <mgsloan> yeah, foldr is generally preferred, I think
13:52:09 <yip> when ghc compiles a haskell program into c, does it ever use "goto"?
13:52:52 <augustss> yip: iirc, yes.  why?
13:53:02 <LoganCapaldo> does ghc compile a haskell program into c?
13:53:06 <Saizan> it compiles to c?
13:53:10 <LoganCapaldo> i did not know that
13:53:21 <augustss> you can have it go via C
13:53:29 <LoganCapaldo> ah
13:53:36 <LoganCapaldo> that's not the default though right?
13:53:48 <augustss> no, then it goes via assembly code
13:54:03 <LoganCapaldo> Wouldn't want the C compiler deoptimizing it by default :)
13:54:32 <augustss> actually, the reason to use the C compiler is that it usually generates slightly faster code
13:54:42 <LoganCapaldo> gah
13:54:46 <mgsloan> yep
13:54:56 <LoganCapaldo> but all that information, thrown away
13:54:58 <mgsloan> people have spent loads of time making the c compiler use loads of tricks
13:55:03 <LoganCapaldo> i am sad
13:55:23 <mgsloan> yeah, I know, we could probably do better, but it'd take a decades of person-years to do
13:55:29 <LoganCapaldo> if there was any justice in the world, theindirection thru C would make it slower
13:55:41 <augustss> LoganCapaldo: the information is first used by ghc, then it generates some very horrible looking C code
13:55:56 <syntaxfree> if there was any justice in the world, unsafePerformIO would disappear.
13:56:01 <Heffalump> what is the current status of the C-- integration?
13:56:07 <mgsloan> yeah, C is basically abbreviated ASM anyway
13:56:28 <yip> c-- seems to be were it should be at
13:56:35 <augustss> Heffalump: ghc uses some variant of c-- internally
13:56:50 <Saizan> c--?
13:57:03 <Saizan> without what?
13:57:16 <Heffalump> has anything significant changed in what it does in the last year or so?
13:57:18 * syntaxfree thought c++-- was java.
13:57:34 <augustss> Heffalump: i dunno
13:57:54 <mgsloan> Saizan: subset of C, I'd imagine
13:57:56 <augustss> Saizan: c-- is a C-like low level language
13:57:57 <Saizan> actually in my CS course there's this small compiler called Java--, it's Java without classes
13:58:08 <pejo> Saizan, varargs, for example.
13:58:25 <pejo> Heffalump, atleast they haven't documented it. Linux/IA32 seems to be the main platform.
13:58:49 <Saizan> i didn't think ona would need something in the middle of asm and C :)
13:59:04 <opqdonut> Saizan: read the c-- site, they have some good reasons
13:59:41 <augustss> Saizan: there are very good reasons
13:59:43 <mgsloan> I'd imagine its just a removal of the cruft you don't need
13:59:59 <Saizan> well i'm not a very imaginative person..
14:00:01 <augustss> mgsloan: and adding some stuff you need :)
14:00:14 <mgsloan> really? I thought it was a subset.  huh
14:00:26 * mgsloan checks up on the C-- site
14:00:30 <yip> c-- is very different from c
14:00:36 <augustss> mgsloan: tail calls, specified interaction with GC, ...
14:00:45 <syntaxfree> it's c minus or c minus minus?
14:00:54 <mgsloan> bah, stupid google and it not searching symbols
14:00:58 <syntaxfree> what's the page? google ignores ++ and --
14:01:04 <Heffalump> www.cminusminus.org
14:01:30 <mgsloan> augustss: so it adds a GC?  and i thought tail calls were just an optimization :)
14:01:38 <pejo> Heffalump, anything else seems to be worse off. And darwin/ia32 isn't working at all.
14:01:56 <augustss> mgsloan: it adds an api the gc can use
14:01:56 <Heffalump> yes, but a code generator might really care about ensuring they happen
14:02:11 <mgsloan> augustss: ah
14:02:23 <Heffalump> there are different design considerations for an intermediate language than for a source language, and that's one of them
14:03:18 <Heffalump> another is that it's _not_ endian/word-size invariant. You have to print out a specific C-- program for those properties
14:03:19 <emu> as far as i can tell, they only called it C-- to latch onto the C name
14:03:33 <syntaxfree> D is a name I find annoying.
14:03:37 <Heffalump> yes, and to reflect the fact that C is often the de facto intermediate language these days
14:03:43 <mgsloan> interesting.  How well does it optimize?
14:04:04 <emu> syntaxfree: languages are getting stupider... MS has an "F"
14:04:13 <syntaxfree> It's F#
14:04:16 <syntaxfree> and it looks cool.
14:04:19 <emu> is that like getting an F+?
14:04:22 <mgsloan> yeah, stands for functional
14:04:27 <syntaxfree> now D is just "hey, this is the sucessor of C".
14:04:31 <Binkley> emu: yes, it's not like any of us have heard that joke 500 times before
14:04:32 <Binkley> ;-)
14:04:35 <syntaxfree> "Let's make another C, except this one is ours"
14:04:51 <_matthew_> Saizan: Java-- == Kenya?
14:04:59 <mgsloan> hah
14:05:07 <Binkley> actually, the reasoning behind the name "C--" is that it's C minus all the crap that a compiler doesn't need in its target language
14:05:18 <emu> and it mutates C?
14:05:28 <Binkley> it should be compilable by a C compiler
14:05:30 <Binkley> or that's the theory
14:05:32 <Binkley> I think
14:05:35 <syntaxfree> can gcc compile a c-- program,even if inefficiently?
14:05:42 <sorear> no
14:05:46 <LoganCapaldo> I don't think so
14:05:52 <Saizan> _matthew_: never heard of Kenya
14:05:54 <LoganCapaldo> it says it has prefix syntax for opperators
14:05:58 <sorear> iirc c-- has explicit tail calls
14:06:01 <LoganCapaldo> for instance
14:06:01 <Binkley> Or... not.
14:06:15 <sorear> jump foo(2,4);  /* try compiling this */
14:06:22 <mgsloan> hmm, what's the benefit of explicit tail calls?  I mean, implicit ones are just as good... right?
14:06:28 <_matthew_> Saizan: ahh, ok. It's used for the CS course at Imperial.
14:06:29 <LoganCapaldo> #define jump
14:06:32 <LoganCapaldo> hehehe
14:06:33 <emu> c-- compiler doesn't have to analyze for it?
14:06:34 <sorear> I suppose CPP could fix this.. <evil grin>
14:06:45 <mgsloan> ah, i suppose that is good
14:07:07 <mgsloan> breaking with C (becoming something other than a subset might) is a large cost
14:07:14 <LoganCapaldo> Actually better yet #define jump /* This is bound to cause a stack overflow */
14:07:21 <_matthew_> Saizan: ahh, just reread - you write a compiler for Java-- rather than using it as an intro to Java ?
14:07:23 <emu> i'd imagine c-- takes care of annoying things like architecture specific register allocation and instruction scheduling
14:07:28 <syntaxfree> a stock overflow?
14:07:30 <mgsloan> err, vestigial might in that sentence
14:07:58 <mgsloan> emu - yeah, it looks very cool
14:08:07 <augustss> emu: yes, that's the idea
14:08:28 <mgsloan> whoah, SPJ works on it (or just writes papers on it)
14:08:50 <mgsloan> I'm surprised ghc doesn't use it
14:09:01 <mgsloan> probably practicality in that decision though
14:09:22 <Saizan> _matthew_: Java-- it's a dummy language that it's used to teach procedural programming with the syntax of Java withaout introducing classes first (and it was written by a student a few years ago)
14:09:22 <pejo> mgsloan, chicken and egg problem. And nobody has stepped up and done the work I think.
14:09:41 <LoganCapaldo> augustss: said several screens back that ghc uses a variation internally
14:09:52 <sorear> ghc uses C--, as usual in ast form.
14:09:54 <Saizan> (the compiler, i mean)
14:10:31 <augustss> and parts of the runtime system for ghc are written in c--
14:10:35 <sorear> -fcmm supposedly is partial support for emitting cpp (with a "warning this doesn't work" in the docs)
14:10:50 <opqdonut> sorear: s/cpp/cmm/ ??
14:10:53 <sorear> kinda like core/ext core
14:11:15 <Heffalump> https://cminusminus.org/lists/pipermail/cminusminus/2006-December/000008.html summarises the current status of C--, btw
14:11:15 <sorear> opqdonut: yeah. :)
14:11:16 <opqdonut> np
14:11:16 <lambdabot> http://tinyurl.com/ym8pdv
14:11:40 <sorear> why ssl?
14:13:00 <Heffalump> no idea
14:13:11 <Heffalump> because the whole of the mailman installation is, I suspect
14:13:55 <_matthew_> ?hoogle Maybe a -> Maybe a -> Maybe a
14:13:56 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
14:15:13 <_matthew_> Saizan: mmm. Interesting. In which case you might like to look at Kenya: http://www.doc.ic.ac.uk/kenya/
14:15:15 <lambdabot> Title: Kenya
14:15:16 <augustss> @type mplus
14:15:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:15:34 <augustss> _matthew_: mplus has the right type too
14:16:09 <augustss> @djinn Maybe a -> Maybe a -> Maybe a
14:16:10 <lambdabot> f a b =
14:16:10 <lambdabot>   case a of
14:16:10 <lambdabot>   Nothing -> b
14:16:10 <lambdabot>   Just c -> Just c
14:16:34 <_matthew_> augustss: yeah, I'm still thinking about that or being foldr (||) False. I wrote it to work on Maybe...
14:16:46 <_matthew_> yikes! what is djinn ?
14:17:06 <augustss> _matthew_: it generates code from a type
14:17:15 <syntaxfree> djinn is a genie.
14:17:18 <augustss> _matthew_: but only non-recursive types
14:18:25 <_matthew_> mmm. ok. Err so I'm not sure I can see how the (||) lifted to Maybe can be lifted to MonadPlus
14:18:42 <yip> "(I hope the rsync server is still working, because the sysadmin who set it up quit the day before yesterday, and I'm not sure I know how to do it.)"
14:18:49 <augustss> @type foldr mplus mzero
14:18:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:19:07 <sorear> its a theorem prover in intuitionistic logic; by the Curry-Howard isomorphism, the proof is converted into a function.
14:19:30 <augustss> > foldr mplus mzero [Nothing, Just 1, Just 2]
14:19:31 <lambdabot>  Just 1
14:20:02 <_matthew_> sorear: right, I see
14:20:22 <_matthew_> well I feel about 13 on this channel most of the time, but omg!
14:22:05 <augustss> djinn in its current form isn't that useful.  but it's a cool little thing that you can do when you have a language that is pure and has a sound basis
14:23:06 <_matthew_> ok, I understand the mplus/mzero stuff now.
14:23:53 <syntaxfree> @djinn Maybe a-> Either a b
14:23:54 <lambdabot> -- f cannot be realized.
14:24:05 <_matthew_> I sometimes thing that I know the Java SE libraries (which are huge) much better than I know the haskell base libraries (which are, comparitively) small
14:24:19 <augustss> @djinn Maybe a -> Either a ()
14:24:20 <lambdabot> f a =
14:24:20 <lambdabot>   case a of
14:24:20 <lambdabot>   Nothing -> Right ()
14:24:20 <lambdabot>   Just b -> Left b
14:24:54 <syntaxfree> that's just too obvious :)
14:25:04 <augustss> _matthew_: it's sometimes hard to realize how to use the very general abstractions that haskell has
14:25:04 <syntaxfree> hmm.
14:25:07 <syntaxfree> @djnn a -> Either a a
14:25:08 <lambdabot> f = Left
14:25:41 <_matthew_> augustss: yes indeed. and how easy it is to learn something for too specific a purpose and not realise where else and how else it can be used
14:26:10 <syntaxfree> @djinn [a]->Maybe a
14:26:11 <lambdabot> f _ = Nothing
14:26:25 <Saizan> that's cheating!
14:26:32 <augustss> syntaxfree: it doesn't really understand [a]
14:26:33 <syntaxfree> what?
14:26:45 <augustss> no recursive types :(
14:26:50 <allbery_b> djinn doesn't grok lists, from what I've seen
14:26:50 <syntaxfree> ah, of course.
14:27:02 <augustss> @djinn-env
14:27:02 <lambdabot> data () = ()
14:27:02 <lambdabot> data Either a b = Left a | Right b
14:27:02 <lambdabot> data Maybe a = Nothing | Just a
14:27:02 <lambdabot> data Bool = False | True
14:27:02 <lambdabot> data Void
14:27:04 <lambdabot> type Not x = x -> Void
14:27:06 <lambdabot> listreturn :: a -> [a]
14:28:41 <augustss> @help djinn
14:28:42 <lambdabot> djinn <type>.
14:28:42 <lambdabot> Generates Haskell code from a type.
14:28:42 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:29:01 <augustss> @djinn-del listreturn
14:29:03 <dmhouse> augustss: djinn's yours?
14:29:08 <augustss> dmhouse: yes
14:29:14 <dmhouse> Cool :)
14:33:51 <augustss> @djinn-add data S s a = S (s -> (a, s))
14:34:13 <Syzygy-> What does that actually mean?
14:34:19 <augustss> @djinn S s a -> (a -> S s b) -> S s b
14:34:19 <lambdabot> f a b =
14:34:19 <lambdabot>   case a of
14:34:19 <lambdabot>   S c -> S (\ d ->
14:34:19 <lambdabot>        case c d of
14:34:19 <lambdabot>        (e, f) -> case b e of
14:34:21 <lambdabot>             S g -> g f)
14:34:49 <augustss> Syzygy-: it just means that djinn knows about the type S
14:34:54 <Syzygy-> And what is the type S?
14:34:56 <Saizan> State monad?
14:34:57 <augustss> @djinn-env
14:34:57 <lambdabot> data () = ()
14:34:58 <lambdabot> data Either a b = Left a | Right b
14:34:58 <lambdabot> data Maybe a = Nothing | Just a
14:34:58 <lambdabot> data Bool = False | True
14:34:59 <lambdabot> data Void
14:35:01 <lambdabot> type Not x = x -> Void
14:35:03 <lambdabot> data S s a = S (s -> (a, s))
14:35:15 * allbery_b guesses state monad as well
14:35:26 <augustss> yes, it's the state monad.  and then i asked for the bind operation in the state monad
14:36:09 <Syzygy-> And how do I read the answer?
14:36:29 <augustss> Syzygy-: the function f has the type I asked for
14:36:45 <ph8> > tail . reverse [1..10]
14:36:46 <lambdabot>    Expecting a function type, but found `[a]'
14:36:46 <lambdabot>    Expected type: a1 -> [a...
14:36:48 <Syzygy-> And what does that f actually -do-?
14:36:54 <ph8> eep.
14:36:58 <ph8> > tail (reverse [1..10])
14:36:58 <augustss> so f is bind in the state monad
14:36:59 <lambdabot>  [9,8,7,6,5,4,3,2,1]
14:37:02 <xerox> Syzygy-: it implements (>>=) for the state monad.
14:37:03 <ph8> good-o!
14:37:07 <xerox> ?source Control.Monad.State
14:37:08 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:37:12 <xerox> Check yourself :)
14:37:37 <sorear> yow!
14:38:02 * sorear is impressed
14:38:21 <augustss> djinn can generate return and bind in the usual monads, including continuation
14:38:23 <Syzygy-> Am I actually going to get an answer that lets me unravel the djinn'd code?
14:38:31 <augustss> and callCC in the cont monad
14:38:40 <sorear> ?djinn Not a -> Not b -> Not (Either a b) -- i have to try this
14:38:40 <lambdabot> Cannot parse command
14:38:45 <sorear> ?djinn Not a -> Not b -> Not (Either a b)
14:38:45 <lambdabot> f a b c =
14:38:46 <lambdabot>   case c of
14:38:46 <lambdabot>   Left d -> a d
14:38:46 <lambdabot>   Right e -> b e
14:39:18 <xerox>  m >>= k  =  State $ \s -> let (a, s') = runState m s in runState (k a) s'
14:39:19 <augustss> Syzygy-: it's just the same code as you'd have to write yourself if you were making S an instance of Monad
14:39:44 <sorear> ?djinn-add data ReaderT r m a = ReaderT (r -> m a)
14:39:53 <xerox> f a b =  case a of S c -> S (\ d -> case c d of (e, f) -> case b e of S g -> g f)
14:39:58 <xerox> the case are the runState
14:40:47 <sorear> ?djinn (forall a. m a -> (a -> m b) -> m b)) -> ReaderT r m a -> (a -> ReaderT r m b) -> ReaderT r m b
14:40:47 <lambdabot> Cannot parse command
14:41:00 <sorear> doh, oh well
14:41:05 <augustss> sorear, no foralls, no higher kinded tyvars
14:41:07 <Cale> there are at least two obvious ways to make State into a monad
14:41:26 <syntaxfree> don't say "obvious", say "trivial" :)
14:41:27 <augustss> Cale: yes, you get one of them :)
14:41:32 <xerox> Cale, the second one is ignoring the state?
14:41:34 <sorear> are they equivalent?
14:41:35 <Cale> xerox: no
14:41:45 <Syzygy-> So ... wait ... something of type State a b is a function a -> (b,a). Which we get out of there by runState (or the case something of State f -> (*more code*
14:41:47 <sorear> make that four then
14:41:48 <Cale> xerox: the other one sends the state backwards in time :)
14:41:58 <xerox> Cale, ah, I remember... hehe.
14:42:07 <augustss> Cale: but that one is recursive
14:42:12 <Cale> yeah
14:42:23 <Cale> They're rather similar when written with let
14:42:28 <augustss> tep
14:42:31 <augustss> yep
14:42:48 <sorear> ?djinn-add data S' s1 s2 a = S' (s1 -> (a, s2))
14:43:11 <sorear> ?djinn S' s1 s2 a -> (a -> S' s2 s3 b) -> S' s1 s3 b
14:43:12 <lambdabot> f a b =
14:43:12 <lambdabot>   case a of
14:43:12 <lambdabot>   S' c -> S' (\ d ->
14:43:12 <lambdabot>         case c d of
14:43:12 <lambdabot>         (e, f) -> case b e of
14:43:14 <lambdabot>              S' g -> g f)
14:43:24 <sorear> now, that's unambiguous.
14:43:26 <Syzygy-> So case a of S c extracts that function as c. Then in that case, what we return is a state, given by the function \ d -> case c d of (e,f) -> *more stuff*, which sends some d to things done with the result of the state function applied on that d.
14:44:14 <Syzygy-> And then .. no .. I don't understand. :(
14:44:48 <sorear> ?djinn S' s3 s2 a -> (a -> S' s2 s1 b) -> S' s3 s1 b
14:44:48 <lambdabot> f a b =
14:44:48 <lambdabot>   case a of
14:44:48 <lambdabot>   S' c -> S' (\ d ->
14:44:48 <lambdabot>         case c d of
14:44:48 <lambdabot>         (e, f) -> case b e of
14:44:50 <lambdabot>              S' g -> g f)
14:45:15 <Cale> I think it's saner to write it in terms of runState
14:45:16 <sorear> oops
14:45:19 <Syzygy-> wait ... we're doing bind. So in the code up above, a is a State (thus a function from a state to a state and a result), and a function taking something to a state.
14:45:29 <Syzygy-> ... and b a function ...
14:45:40 <sorear> ?djinn S' s2 s3 a -> (a -> S' s1 s2 b) -> S' s1 s3 b
14:45:41 <lambdabot> -- f cannot be realized.
14:46:58 <Syzygy-> so case a of S c extracts the actual state monad state, and then that gets applied to fetch result-and-new-state. And then g is picked as the label corresponding to the state we get by applying the state-building function we're feeding to bind to the result we got from the state function, and then in the end we take the state we get from b and apply it to the state belonging to the result we used to generate ... and I'm rambling.
14:47:13 <Cale> x >>= f = State (\s -> let (a,s') = runState x s in runState (f a) s')
14:47:27 <Cale> that's the usual way to write it
14:47:42 <Syzygy-> And a State is by definition a function s -> (a,s)
14:47:49 <Syzygy-> for a state type s and a 'result' type a.
14:47:51 <Syzygy-> Right?
14:48:08 <Cale> State :: (s -> (a,s)) -> State s a
14:48:10 <xerox>  
14:48:10 <xerox> m >>= f = case m of
14:48:10 <xerox>             S g -> S (\s -> case g s of  -- new S being built
14:48:10 <xerox>                               (a, s') -> case f a of
14:48:13 <xerox>                                            S g -> g s')
14:48:18 <xerox> renaming probably helps
14:48:20 <Cale> runState :: State s a -> (s -> (a,s))
14:48:54 <augustss> yeah, djinn does not use the best names
14:49:14 <Syzygy-> So case m of S g just sets a name on m. case g s of (a,s') sets names on the results of the new S, and case f a of S g -> g s' does that runState (f a) s'
14:49:58 <Syzygy-> Oh well. I can see some sort of light on the other side of all this mist. Now the fiancee insists on socialising.
14:50:02 <xerox> The cases unwrap the container, taking the function inside it.
14:50:09 <augustss> Syzygy-: heh
14:50:14 <xerox> :)
14:50:21 <augustss> Syzygy-: tell her about the state monad ;)
14:51:12 * xerox goes back to his proofs.
14:51:34 <allbery_b> that sounds almost xkcd-worthy
14:51:49 <_matthew_> ?hoogle m a -> b -> m (a, b)
14:51:50 <lambdabot> Prelude.asTypeOf :: a -> a -> a
14:51:50 <lambdabot> Prelude.const :: a -> b -> a
14:51:50 <lambdabot> Prelude.seq :: a -> b -> b
14:53:23 <_matthew_> ?djinn Maybe a -> b -> Maybe (a, b)
14:53:24 <lambdabot> f a b =
14:53:24 <lambdabot>   case a of
14:53:24 <lambdabot>   Nothing -> Nothing
14:53:24 <lambdabot>   Just c -> Just (c, b)
14:53:27 <_matthew_> exactly
14:53:57 <_matthew_> there must be a more general function that does that
14:54:23 <augustss> \ ma b -> do a <- ma; return (a, b)
14:54:34 <xerox> ?type fmap . flip (,)
14:54:36 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => a1 -> f a -> f (a, a1)
14:54:45 <sorear> \a -> flip $ liftM (a ,)
14:54:52 <_matthew_> woot.
14:54:58 <xerox> ?type flip (fmap . flip (,))
14:55:00 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => f a -> a1 -> f (a, a1)
14:55:11 <sorear> ?type fmap fmap (,)
14:55:12 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => a1 -> f a -> f (a1, a)
14:55:19 <xerox> that is cool.
14:55:22 <_matthew_> is there some moment in time when your brain just flips and starts thinking endlessly in terms of monads?
14:55:44 <xerox> (.) . (,)
14:55:48 <dons> moin
14:55:50 <augustss> for me, it came gradually :)
14:55:58 <xerox> Hiya dons.
14:56:07 <_matthew_> do drugs help?!
14:56:20 <dons> _matthew_: I think its a gradual process, as you learn the tricks of each monad
14:56:32 * sorear recuses
14:56:46 * _matthew_ is slightly reassured
14:57:49 <augustss> dons: we need another lambdabot plugin (in case you have a list)
14:58:05 <dons> _matthew_: so you can happily get by with just IO or StateT + IO. but then sometimes Maybe or Either or [] really hit a nail on the head. or Reader. you can get by without them, at the cost of elegance :)
14:58:09 <dons> augustss: oh?
14:58:40 <augustss> a command where you give it the name of a Prelude (library) function and you get the source back.  assuming the source is 1 or 2 lines
14:58:49 <dons> ah ok
14:59:03 <dons> ?index nub
14:59:04 <lambdabot> Data.List
14:59:08 <dons> ?. source index nub
14:59:08 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
14:59:13 <dons> and then actually pull out the src :)
14:59:36 <sorear> ?. http-get . source index nub
14:59:36 <lambdabot> compose module failed: IRCRaised Parse error: "http-get"
15:00:23 <xerox> I still think that @get-lisppaste-nÂ°-####-and-@let-it would make a great plugin.
15:00:57 <sorear> ?. {msg #haskell} . {! wget -o/proc/self/fd/1} . source index nub
15:00:58 <lambdabot> compose module failed: IRCRaised Parse error: "{msg"
15:01:34 <Cale> Personally, I find the list monad to be pretty important
15:02:23 <Axioplase> Hi !
15:02:32 <Cale> hello
15:02:57 <_matthew_> dons: ok. I don't think I've ever used Either monadically. The others I use really occasionally, but I don't tend to try to think about them monadically
15:03:54 <psi> are list comprehensions syntactic sugar for list monad operations?
15:03:59 <sorear> How many other people would like a ?log-grep plugin?
15:04:00 <Cale> psi: essentially, yes
15:04:02 <sorear> psi: yes
15:04:18 <Cale> Not by the H98 standard, but that's what it amounts to.
15:04:30 <sorear> ?log "vty" & "pretty print"
15:04:30 <lambdabot> Maybe you meant: bug let msg yow
15:04:31 <psi> oh, ok
15:04:57 <sorear> *I* have the logs, all 200
15:05:22 <psi> i've been using do syntax for some things instead of list comprehensions, sometimes it's pretty nice
15:05:38 <Cale> The monad operations are what making working with Maybe fun and easy.
15:05:40 <sorear> MB, greppable, on a fast local disk, but I doubt many other people would be that keen on downloading them.
15:05:47 <psi> list comprehensions are ugly when they get long
15:05:50 <Cale> yes
15:06:00 <norpan> if x == True then True else False
15:06:08 <norpan> good night
15:06:16 <Cale> do-notation is better than list comprehension notation when the computation gets involved.
15:06:38 <sorear> 1.4-style comprehensions *were* syntax sugar for monad operations... and were polymorphic in the monad.
15:06:42 * AStorm is pondering writing a treatise: "Why you shouldn't use C++ or any language based on it"
15:06:44 <Cale> sorear: yes
15:06:50 <AStorm> Stupid C++ :/
15:06:53 <Cale> I hope we see fit to bring that back.
15:07:16 <Cale> AStorm: you would think this would be obvious to people
15:07:39 <AStorm> Some still don't understand this obvious truth... that C++ and Java are evil
15:07:46 <augustss> lol
15:07:54 <sorear> "Why you shouldn't use *CPL* or any language based on it"
15:08:01 <AStorm> Yes, right.
15:08:09 <AStorm> Java is CPL in disguise
15:08:12 <AStorm> BCPL actually
15:08:31 <sorear> that includes BCPL, B, NB, C, C++, C--, Java, C#, D, etc, etc.
15:08:55 <AStorm> D and C# aren't that bad, they're heavily modified :>
15:09:00 <sorear> NB: C-- is fine for compilers, just don't use it by hand
15:09:10 <AStorm> THat's why C++ was in the title in the first place
15:09:37 <AStorm> With D being less sucky than C#
15:09:46 <nornagon> are we *still* talking about inferior languages? sheesh
15:09:54 <AStorm> which is slightly less sucky than Java
15:09:54 <nornagon> ?karma C
15:09:54 <dfranke> I'd generalize to "why you shouldn't use Algol or any language based on it".
15:09:55 <lambdabot> C has a karma of 2
15:10:01 <sorear> C--
15:10:08 <sorear> doesn't work!
15:10:11 <sorear> @karma- C
15:10:11 <lambdabot> C's karma lowered to 1.
15:10:18 <nornagon> :O
15:10:18 <sorear> c++
15:10:19 <_matthew_> well surely the fundamental problem with procedural languages is that expressions can be of type void
15:10:19 <AStorm> dfranke, well, algol itself isn't that bad :P
15:10:21 <sorear> @karma c
15:10:21 <lambdabot> c has a karma of 19
15:10:23 <sorear> c++
15:10:24 <sorear> @karma c
15:10:24 <lambdabot> c has a karma of 20
15:10:33 <nornagon> @karma C
15:10:34 <lambdabot> C has a karma of 1
15:10:36 <nornagon> C++
15:10:37 <sorear> ah, dons hasn't applied my patch yet
15:10:37 <nornagon> @karma C
15:10:38 <lambdabot> C has a karma of 1
15:10:47 <sorear> (or sj's patch undid it)
15:10:59 <_matthew_> once you solve that, it's close to functional...
15:11:02 <sorear> (or he hasn
15:11:12 <sorear> 't reloaded the karma plugin yet)
15:11:55 * _matthew_ has spent about 2 hours on 2 lines of code
15:11:58 <_matthew_>              let land = foldr mplus mzero
15:11:58 <_matthew_>                         $ map (\(tri, objs) -> (fmap . flip (,)) objs (intersectTriangle pos dir tri)) triangles
15:12:02 <sorear> I wish I could rebind C-j to something harmless... maybe I should try another client...
15:12:11 <dons> sorear: i haven't rebuilt with the new patch yet
15:12:26 <sorear> ?pl let land = foldr mplus mzero $ map (\(tri, objs) -> (fmap . flip (,)) objs (intersectTriangle pos dir tri)) triangles
15:12:26 <lambdabot> (line 1, column 118):
15:12:26 <lambdabot> unexpected end of input
15:12:26 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
15:12:30 <augustss> _matthew_: and is it working?
15:12:35 <_matthew_> augustss: yes
15:12:45 <augustss> very cool
15:12:55 <AStorm> sorear, one let too many
15:13:11 <xerox> ?pl foldr mplus mzero
15:13:11 <lambdabot> foldr mplus mzero
15:13:17 <xerox> It hasn't got a name?
15:13:19 <sorear> msum
15:13:23 <AStorm> ?pl foldr mplus mzero $ map (\(tri, objs) -> (fmap . flip (,)) objs (intersectTriangle pos dir tri)) triangles
15:13:26 <lambdabot> foldr mplus mzero (map (uncurry (flip (fmap . flip (,)) . intersectTriangle pos dir)) triangles)
15:13:48 <sorear> msum (map (uncurry (flip (fmap . flip (,)) . intersectTriangle pos dir)) triangles)
15:13:53 <AStorm> Yep
15:14:00 <AStorm> Starts looking lispy
15:14:09 <augustss> sprinkle a few $
15:14:10 <_matthew_> agh! I've learnt enough new functions for one night thank you!
15:14:16 <sorear> > msum [Nothing, Just 4, Just 2]
15:14:18 <lambdabot>  Just 4
15:14:29 <AStorm> uh/
15:14:34 <AStorm> ?type msum
15:14:36 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
15:14:48 * sorear has a little bit of trouble between msum and mconcat
15:14:54 <_matthew_> > msum [Nothing, Just [1], Just [1..]]
15:14:56 <lambdabot>  Just [1]
15:14:59 <_matthew_> that's ok then...
15:14:59 <sorear> AStorm: I got what I expected
15:15:19 <sorear> > Just True `mplus` Just False
15:15:20 <lambdabot>  Just True
15:15:23 <AStorm> So what does that thing do?
15:15:30 <AStorm> Removes fails?
15:15:33 <sorear> yes
15:15:59 <xerox> Returns the first positive result I'd say.
15:16:03 <_matthew_> whereas my line of code is essentially doing collision detection...
15:16:06 <sorear> more generally, it's an associative binary operator with unit that distributes over binds.
15:16:10 <augustss> well, what it does depends on the monad
15:16:11 <xerox> > catMaybes [Nothing, Just [1], Just [1..]]
15:16:13 <lambdabot>  [[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
15:16:19 <xerox> That removes failures.
15:16:31 <AStorm> Not always :P
15:16:37 <AStorm> Only from Maybe
15:16:54 <sorear> e.g. in Parsec's GenParser mplus performs choice, like '|' in BNF.
15:17:16 <sorear> Parsec defines <|> as a (restricted) synonym of mplus
15:17:19 <AStorm> ?type mplus
15:17:21 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
15:17:31 <AStorm> Now that's not useful :P
15:17:32 <augustss> > msum [[1],[2,3]]
15:17:33 <lambdabot>  [1,2,3]
15:17:39 <dmhouse> ?type (Text.ParserCombinators.Parsec.<|>)
15:17:40 <lambdabot> forall a st tok. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
15:17:41 <sorear> ?type Text.ParserCombinators.Parsec.Combinators.<|>
15:17:41 <AStorm> Yeah, I know what it does
15:17:42 <lambdabot>   parse error on input `Text.ParserCombinators.Parsec.Combinators.<|>'
15:18:20 <Axioplase> hum... with the continuation monad, when I have "do {callCC $ foo; bar; quux}", does that mean that "bar;quux" is the current continuation when I enter the callCC ?
15:18:38 <sorear> but somehow I doubt you are doing collision detection in Parsec :)
15:18:46 <augustss> Axioplase: yes
15:19:04 <Axioplase> augustss: ok. thanks
15:24:39 <jgrimes> why does the ghc documentation say there is an instance for
15:24:39 <jgrimes> Functor (Either a) but when I try using fmap on an Either it tells me that I need to declare an instance for it
15:24:51 <jgrimes> didn't mean for that to be two lines... :)
15:25:25 <augustss> import Data.Either
15:25:42 <jgrimes> of course.
15:25:48 <jgrimes> something simple
15:25:51 <augustss> well, it's not obvious
15:26:02 <jgrimes> why isn't that in the prelude?
15:26:09 <jgrimes> the Functor instance
15:26:36 <Axioplase> jgrimes: because there would be too many things in prelude (since I also wonder once or twice a day why foo isn't in prelude too) :)
15:26:41 <augustss> probably because H98 doesn't have it
15:27:04 <jgrimes> augustss, good reason
15:27:16 <augustss> there's already too much in the Prelude
15:27:46 <norpan> yeah
15:27:51 <norpan> minimal prelude
15:33:07 * _matthew_ wonders if a 125-line function is "bad form"
15:33:13 * _matthew_ suspects the answer...
15:34:09 <mux> have there been implementations of a framework to allow shared libraries in haskell?
15:35:06 <Philippa> _matthew_: there may not be better alternatives?
15:35:27 <_matthew_> Oh, I'm just being lazy and not refactoring yet
15:35:55 <_matthew_> it's one of those "well it looks fine on my 1600x1200 monitor, but is unreadable on my laptop" cases...
15:36:29 <ClaudiusMaximus> ?paste
15:36:30 <lambdabot> http://paste.lisp.org/new/haskell
15:41:17 <allbery_b> mux: there is work on it, yes
15:41:27 <allbery_b> I think the next version fo ghc is supposed to use shlibs by default
15:42:34 <ClaudiusMaximus> hmm, proxy error with the paste, how do avoid that?
15:43:12 <allbery_b> if it's repeatable, use a different pastebin.  (paste.lisp.org has been a bit flaky throughout the holidays, hopefully they'll fix it next week)
15:43:13 <yaxu> someone said it was broken earlier ClaudiusMaximus
15:43:23 <lisppaste2> ClaudiusMaximus pasted "How would you generalize this to arbitrary dimensions?  Or even just shorten it..." at http://paste.lisp.org/display/33730
15:43:36 <yaxu> ah
15:43:49 <ClaudiusMaximus> yaxu: i gave it "one last try" and it appears to have worked...
15:45:44 <thelsdj> hmm which version of ghc do i need for Data.ByteString?
15:48:31 <allbery_b> 6.6, or install fps:
15:48:34 <allbery_b> ?where fps
15:48:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:48:38 <thelsdj> thanks
15:49:20 <scodil> is there a function that makes a singleton list? (replicate 1) seems a little odd
15:49:29 <sorear> (:[])
15:49:35 <sorear> > (:[]) "foo"
15:49:36 <lambdabot>  ["foo"]
15:49:40 <scodil> excellent thank you
15:49:56 <sorear> it's a section of the cons operator :
15:50:24 <sorear> it's also called the "robot ninja monkey operator", for some reason
15:50:49 <sorear> return also works, if you prefer letters
15:50:57 <sorear> > return "foo" :: [[Char]]
15:50:58 <lambdabot>  ["foo"]
15:51:11 <sorear> (because of the way the list monad works)
15:52:04 <dons> ?let box = (:[])
15:52:05 <lambdabot> Defined.
15:52:13 <thelsdj> finally decided what 'real' software i'm going to work on to learn haskell, probably a stupid idea but i'm going to try to decode mp3 files
15:52:35 <dons> cool. should be reasonable
15:52:46 <dons> perhaps look at Hogg, the ogg file munger?
15:52:56 <dons> ?where hogg
15:52:57 <lambdabot> http://www.annodex.net/~conrad/software/hogg/
15:53:12 <dons> you'll want to get familiar with bytestrings, I think
15:53:20 <vincenz> dons: !
15:53:21 <psi> does hmp3 support ogg now?
15:53:25 <dons> vincenz: !
15:53:28 <vincenz> Hi
15:53:29 <dons> psi: almost
15:53:39 <thelsdj> yep just installed fps
15:53:42 <dons> it should given a few more patches
15:53:50 <psi> cool. flac would be nice, also :P
15:53:52 <dons> thelsdj: you might want to instal ghc 6.6 instead
15:54:00 <dons> since it has bytestrings in the base library
15:54:04 <dons> and they're faster
15:54:16 <dons> (due to better compiler optimisations)
15:54:29 <thelsdj> yea i might do that, was just being lazy since ubuntu 6.10 has 6.4
15:56:25 * _matthew_ thinks that ghc should give a countdown of %chance of finding a mistake. Would start at 100% and would decrease as ghc does work!
15:57:44 <psi> 100% is a bit pessimistic
15:57:49 <sorear> I think ghc should have a slightly-verbose option - maybe print a . after every compilation pass. (there are >10 iirc, so it'd be fine grained an helpful)
15:58:27 <sorear> good for impatient types like me
15:58:42 <thelsdj> i actually wrote a bunch of mp3 header parsing code in C# a while back but never got further than enough to break up all the frames
15:58:44 <iulus> as long as it is an option
16:02:12 <sorear> in compilation-manger mode, I can it already does Compiling Foo.Bar   (...), it should be Compiling Foo.Bar (XYZ) .......
16:02:24 <sorear> why an option in that case?
16:07:30 <ctkrohn> hey, if I have some haskell modules defined in a directory dir1/, and other modules defined in dir2/, how can files in dir2 import modules defined in dir1?  I'd like to do something like import dir1.foo, but that doesn't work.
16:07:47 <ctkrohn> passing -i options to ghc seems to force it to only look in that directory, since subsequent import statements will fail
16:08:28 <sorear> maybe packages will do what you want?
16:09:06 <sorear> dumb question: did you pass -i dir1 -i dir2, or just -i dir2 ?
16:10:07 <ctkrohn> if I was in dir2, I passed -i dir1, but then in the next line I imported just a regular haskell module
16:10:11 <ctkrohn> and that failed
16:10:24 <sorear> regular, as in standard?
16:10:31 <ctkrohn> yeah, it was HUnit
16:11:01 <ctkrohn> HUnit is set up just fine, I've built other programs with it
16:11:43 <sorear> I just checked the docs, you need both
16:12:53 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/separate-compilation.html#search-path
16:12:55 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/y48y7f
16:13:01 <ctkrohn> so would I also need to explicitly include the directory containing hunit?
16:13:32 <sorear> I misunderstood your question
16:13:34 <sorear> use Cabal
16:14:04 <ctkrohn> I suppose that would take care of it... is it worth it for a relatively small thing?
16:14:24 <ctkrohn> I guess it can't hurt to try
16:14:26 <sorear> yes
16:14:37 <sorear> also check out
16:14:40 <sorear> ?where mkcabal
16:14:40 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal
16:14:46 <metaperl> anyone know how to install hs-plugins?
16:14:53 <sorear> True
16:15:09 <sorear> note that mkcabal has some weird quoting requirements
16:15:18 <ctkrohn> alright, I'll give it a look
16:15:19 <ctkrohn> thanks
16:15:20 <metaperl> @seen dons
16:15:21 <lambdabot> dons is in #haskell.hac07, #haskell-overflow, #ghc and #haskell. I last heard dons speak 21m 4s ago.
16:15:33 <sorear> it won't work on 6.6
16:15:53 <metaperl> @tell dons is it asking too much for an INSTALL file to be included with hs-plugins?
16:15:54 <lambdabot> Consider it noted.
16:16:00 <metaperl> sorear - you talking to me?
16:16:15 <dons> ctkrohn: you don't need cabal for a simple couple of modules in a few directories, though
16:16:16 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:16:25 <thelsdj> whats the best way to convert a ByteStream to a String?
16:16:28 <sorear> yes.
16:16:29 <dons> just ensure the directory name matches the module name. i.e. import Dir1.Foo
16:16:36 <thelsdj> er ByteString
16:16:37 <dons> where Foo.hs contains: module Dir1.Foo where ...
16:16:44 <ctkrohn> I see
16:16:47 <dons> then ghc --make should compile the lot, given the top level module
16:17:28 <dons> metaperl: its just cabalised. so you follow the README :)
16:17:41 <metaperl> oh ok
16:18:13 <shankys> ?paste
16:18:13 <lambdabot> http://paste.lisp.org/new/haskell
16:18:18 <metaperl> hmm it requires cabal
16:18:30 <metaperl> guess I need to install that first
16:18:35 <lisppaste2> shankys pasted "Read Typing Difficulties" at http://paste.lisp.org/display/33734
16:18:35 <metaperl> @url cabal
16:18:36 <lambdabot> http://www.haskell.org/cabal
16:19:01 <sorear> isn't cabal distributed with GHC now?
16:19:02 <dons> metaperl: what ghc do you have?
16:19:06 <metaperl> 6.6
16:19:07 <dons> cabal comes with ghc, for a long time now
16:19:10 <metaperl> oh ok
16:19:17 <dons> metaperl: then the instructions in the readme should work exactly as is
16:19:21 <dons> *but*
16:19:23 <shankys> I'm having some typing difficulties. Could someone look at the code I pasted point me in the right direction for what to put in the instance Read Comment where section?
16:19:26 <dons> hs-plugins doesn't work with ghc 6.6!
16:19:32 <dons> (yet)
16:19:34 <shankys> *and point me
16:19:41 <dons> looking...
16:20:18 <metaperl> I will try it anyway and see what happens
16:20:21 <dons> shankys: you're deriving Show and Read, so you don't need to write your own instance.
16:20:25 <metaperl> I need it for haskelldb
16:20:40 <dons> metaperl: I predict it will break. you have been warned. try ghc 6.4.2 if you need hs-plugins
16:20:45 <allbery_b> it doesn't work, it will error out because the .hi format changed
16:20:49 <shankys> dons: When I run the program I get "hello: Prelude.read: no parse"
16:21:02 <shankys> dons: It compiles fine though
16:21:23 <dons> is the data you're reading not in the proper form?
16:21:23 <metaperl> src/AltData/Typeable.hs:452:0:        parse error (possibly incorrect indentation)
16:21:33 <dons> metaperl: exactly.
16:21:37 <metaperl> ok oh well
16:22:00 <allbery_b> yeh, there's that during compilation as well
16:22:02 <shankys> dons: The probably what it is, but I don't quite understand how to fix that with Takusen's typing for doQuery
16:22:09 <shankys> *That's
16:22:18 <dons> shankys: hmm. you better check with the authors then
16:23:58 <shankys> dons: They never hang out here, and haven't responded to an email I sent them unfortunately. I can make things work typing wise if I don't use Comment and have iteratee be of type Int -> String -> ... -> IterAct m [(Int -> String -> ...)].
16:26:24 <dons> perhaps ask on haskell-cafe@haskell.org ? someone there should be familiar with this library
16:26:42 <shankys> dons: Alright
16:31:49 <dons> ?uptime
16:31:50 <lambdabot> uptime: 8d 23h 49m 32s, longest uptime: 9d 2h 23m 6s
16:31:53 <dons> ?users
16:31:54 <lambdabot> Maximum users seen in #haskell: 309, currently: 276 (89.3%), active: 35 (12.7%)
16:32:00 <metaperl> I hope I am not being pesky, but what sort of ETA is there for hs-plugins on ghc 6.6?
16:32:21 <sorear> "Hac 07" --dons in the past
16:33:02 <dons> yeah. a week and a few days
16:33:12 <metaperl> oh nice
16:33:14 <dons> its an FAQ :)
16:33:33 <sorear> dons: would you accept a log grepping plugin, with the connotation that it would force you to store ~200MB on a fairly-local disk?
16:33:51 <dons> yes. that's fine
16:33:58 <dons> as long as it is easy for me to get the logs
16:34:06 <sorear> ?
16:34:10 <dons> i.e. it greps my local darcs copy of #haskell ;)
16:34:30 <sorear> next question, in your logs, how is the topic data stored?
16:34:32 <dons> how would it work?
16:35:02 <dons> here: http://www.cse.unsw.edu.au/~dons/code/irc-logs/
16:35:03 <lambdabot> Title: Index of /~dons/code/irc-logs
16:36:11 <sorear> I know *where* it is stored, but I can't make sense of the format.  (Can't make sense of the stuff ircii spits out either :( )
16:36:35 <sorear> (or should it just be ignored?)
16:37:37 <dons> just ignore stuff you don't care about
16:37:39 <mux> allbery_b: do you know if there's a GHC roadmap somewhere or something approaching?
16:37:47 <sorear> ?where commentary
16:37:47 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
16:37:55 <sorear> ouch, the outdated one
16:38:24 <sorear> ?where+ commentary http://hackage.haskell.org/trac/ghc/wiki/Commentary
16:38:24 <lambdabot> Done.
16:38:27 <sorear> ?where commentary
16:38:28 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary
16:38:44 <sorear> mux: ^^^
16:39:10 <mux> thanks!
16:39:30 <allbery_b> mux: what I know is mostly from discussions here :)
16:40:11 <syntaxfree> ouch.
16:40:28 <mux> pardon me if I'm being dense but I can't see anything on this page related to shared libs
16:40:42 <sorear> you're right, GHC doesn't do shared libs
16:40:50 <syntaxfree> how come "dense" became a synonym for "stupid"?
16:41:01 <mux> but is this even planned?
16:41:05 <syntaxfree> "dense" should mean "more neurons per area unit".
16:41:06 <Cale> http://programming.reddit.com/info/wg2y/comments/cwi32 :)
16:41:08 <lambdabot> Title: Monads (reddit.com)
16:41:39 <sorear> I'd love to be the kind of person with neurons in every *volume* unit.
16:42:03 <allbery_b> there has been discussion here about haskell support for shared libraries on linux and osx at least.  I was under the impression this is targeting the next GHC release
16:42:14 <Cale> syntaxfree: it refers to a sort of abstract "wall" around that person's ideas, which would have to be broken down before they'd be willing to accept any others
16:42:27 <allbery_b> it's possible that they're actually looking farther ahead for it
16:42:42 <syntaxfree> Cale: oh. I'm not a native speaker, you see.
16:43:08 <allbery_b> "dense skull" is the origin of the idiom
16:43:14 <allbery_b> (i.e. impermeable)
16:43:17 <Cale> One might imagine it as the density of the person's skull, yes
16:45:51 <mux> allbery_b: I'll be doing more research, but if you have a link to share I'd be glad
16:46:52 <mux> oh, http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
16:46:57 <lambdabot> Title: DynamicLinking - GHC - Trac
16:46:58 <SyntaxNinja> y0
16:48:45 <heatsink> hi
16:48:52 <lisppaste2> heatsink pasted "Free type variable?" at http://paste.lisp.org/display/33736
16:48:52 <dufflebunk> Hello heatsink
16:49:43 <heatsink> I'm having trouble understanding this type error.  It says "Could not deduce (D m1 a) from the context (D m a) arising from the use of `sizeD'...
16:50:44 <allbery_b> need more context, specifically the definition of D.  (if it's a type alias with a constraint, you can't do that and expect sanity)
16:51:43 <heatsink> albery_b, not sure what context you're asking for.  I pasted the entire file.
16:52:50 <allbery_b> hm
16:53:07 * allbery_b got confused, thought class decl was instance for some reason :(
16:54:07 <heatsink> One question I have is, what causes it to make up the type constructor m1? "sizeD x > 5" doesn't seem to reference any such type.
16:55:12 <allbery_b> maybe because sizeD doesn't reference the monad type, so it's rolling a new one internally?
16:55:47 <allbery_b> which then doesn't match the (unused) one in the type signature
16:58:01 <heatsink> I get it, the type is involved in selecting the class instance that defines sizeD.
16:59:14 <allbery_b> m1 is a type variable generated internally.  it doesn't match the one in the declaraion because that one isn't actually *bound* to anything, because none of the arguments actually use it, only the defintiion of sizeD does
17:00:16 <ndm> dons: thanks for the forward, have emailed back
17:00:16 <heatsink> can I change the definition to make it use the type variable in f's type declaration for sizeD?
17:00:20 <allbery_b> ...at least I think that's what is going on
17:01:14 <allbery_b> the definition of sizeD is bugging me because it doesn't involve the monad at all
17:01:37 <allbery_b> unfortunately I think someone better versed in haskell typing needs to look at this
17:02:13 <allbery_b> I'm having he feeling that it's somehow "dangling" because, while defined by a typeclass involving a monad, it doesn't actually involve the monad itself
17:08:05 <heatsink> allbery_b: FWIW, the original had two type classes.  One class defined sizeD, and was also a constraint on the class that defined newD.  So there wasn't a dangling member function there.
17:09:19 * heatsink thinks this chat client is acting flaky
17:11:18 * allbery_b thinks the server might be flaky,, given the unexpected silence from other folks except that series of join/parts
17:11:33 <LoganCapaldo> I'm still here
17:11:46 <LoganCapaldo> heh
17:12:20 <heatsink> mebbe.  Ish the first time I've used Colloquy tho.
17:13:00 * allbery_b was expecting someone with more sense^Wunderstanding to jump in :)
17:13:32 * LoganCapaldo uses Colloquy all the time
17:13:35 <LoganCapaldo> In fact I
17:13:41 <LoganCapaldo> I'm using ti right now
17:14:35 * heatsink will ask on the mailinglist
17:14:57 <heatsink> I think the answer willl be instructive.
17:15:01 <heatsink> thx allbery_b
17:15:32 <dons> ?where haxml
17:15:33 <lambdabot> http://haskell.org/HaXml
17:15:45 <Cale> heatsink: which m to use?
17:15:52 <Cale> heatsink: that's the basic problem here
17:16:38 <Cale> Before you can use any of the members of a class, all of the type variables which that class relates have to be known.
17:16:48 <heatsink> Cale: In this case, yea.  I'll paste the two-class version, where m is actually an unused variable, for comparison...
17:16:55 * Daveman waves to xerox and hails Cale with large canuck
17:16:57 <sorear> allbery_b: ---channelpadding---   ---channelpadding---
17:17:03 <sorear> ...
17:17:17 * allbery_b thought that waas what te join/part messages were :>
17:17:24 <Cale> For instance, sizeD might be a different function a -> Int for the same type a, but different monads m
17:17:31 <allbery_b> well, that and my babbling...
17:17:56 * allbery_b was trying to figure it out but is still somewhat new to it all himself
17:18:15 <allbery_b> kinda flying blind
17:18:42 <ndm> dons: was impressively fast with your forward, email had only just shown up in my haskell@ list box
17:18:45 <heatsink> Cale: that's what I thought.  But if it's given both type variables, then it should be able to select the right function.
17:19:07 <heatsink> If you tell it that the type variable actually relates to that function call.
17:19:15 <heatsink> But I don't know how to do that.
17:19:28 <Cale> yes, but the type of sizeD prevents you from actually doing that
17:20:23 <heatsink> Hmm...
17:20:24 <allbery_b> yeh, that's what I was seeing (and trying to say)
17:20:28 <Cale> If it was something like  a -> m Int, you'd have less trouble. Or, if you had a functional dependency which said that the type 'a' uniquely determines the monad 'm'
17:20:55 <Cale> class Monad m => D m a | a -> m where
17:20:58 <Cale>  ...
17:21:12 <Cale> However, that might be too limiting for you
17:21:33 <allbery_b> sizeD has no linkage to the monad, nor does f, so the m is left dangling an can't be associated with anything.  then it generates another one when it sees sizeD, but can't asociate *that* with anything
17:22:46 <dons> ndm: hehe
17:23:21 <heatsink> In my case, I can split it into two type classes where one has only a single parameter.
17:24:23 <Cale> heatsink: that's another idea
17:25:56 * heatsink tries it
17:30:10 <heatsink> yea, that worked.
17:30:32 <dons> metaperl: sent you a more concise xml munger
17:30:40 <dons> just for tutorial purposes :)
17:31:14 <metaperl> dons - thanks!
17:32:02 <dons> I used a few simple refactorings, and -ddump-minimal-imports to get a shorter import list
17:35:27 <heatsink> So... all class members have to use all type variables that are not implied by fundeps?
17:37:01 <heatsink> that must be why Foriegn.Storable(sizeOf, alignment) have unused parameters.
17:37:44 <sorear> exactly
17:37:58 <sorear> ?type floatDigits
17:38:00 <lambdabot> forall a. (RealFloat a) => a -> Int
17:38:07 <sorear> In the prelude, even.
17:38:17 <sorear> > floatDigits (undefined :: Double)
17:38:19 <lambdabot>  53
17:38:23 <sorear> > floatDigits (undefined :: Float)
17:38:24 <lambdabot>  24
17:41:32 <LoganCapaldo> wait what
17:41:37 <LoganCapaldo> how did that happen
17:41:40 <Jaak> wha...
17:41:50 <LoganCapaldo> > floatDigits (undefined :: Double )
17:41:51 <lambdabot>  53
17:41:56 <LoganCapaldo> Oh good
17:42:02 <LoganCapaldo> its deterministic at least
17:42:07 <LoganCapaldo> (I think)
17:42:09 <dons> its really great having so many smart people on haskell-cafe@. Ilearn something new (or many things) each day, just from that list
17:42:16 <LoganCapaldo> I almost had a heart attack
17:42:17 <heatsink> LoganCapaldo: it's determined by the type, not the value
17:42:30 <LoganCapaldo> heh
17:43:29 <sorear> @remember dons its really great having so many smart people on haskell-cafe@. Ilearn something new (or many things) each day, just from that list
17:44:24 * ndm needs to stop learning and finish implementing the stuff i've already figured out
17:44:43 <ClaudiusMaximus> wow, compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
17:45:01 <dons> optimisations are good :)
17:45:07 <ClaudiusMaximus> seems so :)
17:45:18 <ndm> ClaudiusMaximus: you should try and fix that, that shows your program is broken in some way that GHC fixed - my guess is let movement
17:45:19 <sorear> CM: how about -O1?
17:45:25 <dons> ?remember ClaudiusMaximus compiling with -O2 reduced the time taken by my program's execution from 28mins to 17secs
17:45:35 <ndm> since definately in Hugs/Yhc will take forever, while should be doable in a minute on those two
17:45:40 <dons> ndm: yeah. that's a very good point
17:45:47 <ClaudiusMaximus> what is let movement?
17:46:02 <sorear> I get the feeling the "Quotes of the week" section of HWN is the edited output of darcs diff State/quote ?
17:46:11 <dons> sorear: you might be right there
17:46:13 <ndm> ClaudiusMaximus: imagine calculating a value 100 times, instead of once
17:46:19 <sorear> s/diff/changes -v/
17:46:26 <dons> sorear: esp. if you notice a darcs record State/quote once a week
17:46:42 <dons> darcs changes -v | less
17:46:49 <ClaudiusMaximus> ndm: waiting until i finish imagining that might take some time
17:47:20 <ndm> ClaudiusMaximus: likely its one or two things
17:47:55 <ClaudiusMaximus> ndm: you think this might have something to do with it?   http://paste.lisp.org/display/33730
17:48:40 <sorear> that looks ...
17:48:42 <ndm> ClaudiusMaximus: definately!
17:49:12 <sorear> How often is volumeCube called with the same argument?
17:49:44 * sorear suspects that on real code full memoization might be an optimization
17:49:46 <lisppaste2> ndm annotated #33730 with "fix" at http://paste.lisp.org/display/33730#1
17:49:51 <ClaudiusMaximus> sorear: it's only called once in each run of the program
17:50:02 <ndm> ClaudiusMaximus: see that code, should fix the time leak
17:51:10 <ClaudiusMaximus> ndm: thanks, i think i understand it :)
17:52:19 <Cale> That code is sufficiently repetitive to warrant a little factoring too :)
17:53:00 <Cale> e.g. take that line which ndm gave you, and define it as a function of 4 lists.
17:53:02 <sorear> x <- [ 0, 1 /. d .. 1.000001 ]
17:53:25 <sorear> Don't forget instance Enum Double
17:53:40 <sorear> BTW, what is /. ?
17:53:50 <sorear> nm doh!
17:53:51 <Cale> sorear: it's defined right there
17:54:42 <sorear> what type is volumeCube used at?
17:54:44 <Cale> Another thing to be careful about as far as performance is concerned is to make sure that d is getting a monomorphic type if at all possible
17:55:01 <Cale> not that that's going to save a ton of work
17:55:07 <sorear> you are computing fromIntegral d thousands of times
17:55:18 <sorear> better factor it out
17:55:36 <sorear> x /. d -- computes fromIntegral d
17:55:39 <Cale> mm, that is true
17:55:52 * ClaudiusMaximus feels humble
17:56:24 <Cale> ClaudiusMaximus: don't worry about it, it takes time to get good at seeing these things
17:57:42 <ClaudiusMaximus> another thing is that memory usage seems to explode somewhere between counts=112 and counts=128, but i'll fix the issues you've pointed out before worrying about that :)
17:58:21 <sorear> counts=128 - yow!
17:58:26 <sorear> how much of 'explode'
17:58:32 <sorear> 1MB -> 2MB ?
17:59:07 <BitShiftr> I'm working on some socket programming and was wondering if select() was exported and where it would be.
17:59:14 <BitShiftr> Any clues?
17:59:20 <sorear> import Network
17:59:25 <sorear> oh sorry
17:59:29 <sorear> It's not.
17:59:33 <sorear> use threads instead.
17:59:49 <sorear> (internally, GHC's threading support uses select)
18:00:31 <augustss> BitShiftr: there's no select anymore :(
18:01:00 <BitShiftr> Ok, Second question, I have some signal from a thread (forkIO'd) and I want to quit the program if this signal happens, but I can't interrupt an accept
18:01:02 <ClaudiusMaximus> sorear: up to 650MB before i killed it because it was making the machine unresponsive
18:01:08 <BitShiftr> What direction should I look?
18:01:20 <sorear> ClaudiusMaximus: what use do you have for 12 million doubles?
18:01:53 <sorear> BitShiftr: the program will exit if the main thread does, I think that'll kill the accept
18:02:17 <ClaudiusMaximus> sorear: the points are projected down to 2D and accumulated in bins, to make images like this: http://claudiusmaximus.goto10.org/image.php?image=gallery/coding/polytopiary/VolumeCube112.png
18:02:20 <lambdabot> http://tinyurl.com/setvu
18:02:48 <Axioplase> er.. Can someone translate the following scheme into Haskell's runCont ? whatever I do, either it doesn't type, either it doesn't behave as I hoped... http://rafb.net/p/rhcaJ820.html
18:02:50 <lambdabot> Title: Nopaste - No description
18:03:05 <sorear> CaludiusMaximus: also, GHC might be deforesting your code
18:03:20 <Axioplase> (It's a simple callCC trial)
18:03:47 <sorear> that is, it combines the list comprehension with the consumption into a single loop
18:04:04 <sorear> CM: how are you doing the accumulating?
18:04:25 <sorear> map & accumArray should be the friendliest toward deforestation.
18:04:52 <BitShiftr> sorear: That seems like an awfully large mallet to kill a small fly and I would like the opportunity to cleanup... although I might just need to re-think my toy program
18:05:19 <BitShiftr> Idealy I'd like to make it open and close the socket by command from a seperate thread
18:05:32 <lisppaste2> ClaudiusMaximus annotated #33730 with "how i am doing the accumulation" at http://paste.lisp.org/display/33730#2
18:05:33 <lisppaste2> Cale annotated #33730 with "refactor -- see how this goes" at http://paste.lisp.org/display/33730#3
18:06:09 <sorear> Axio: Haskell doesn't do continuations in normal code
18:06:31 <sorear> Axio: There is a special monad ... oh I see your using it...
18:07:11 <ClaudiusMaximus> Cale: yep, that looks a lot nicer :)
18:08:04 <Axioplase> sorear: yes I am... and I think that I don't get it well
18:08:19 <yaxu> I never saw the phrase 'time leak' outside of sci-fi before
18:08:35 <yaxu> (reading scrollback)
18:08:36 <ClaudiusMaximus> would it be worth taking out all the [0..d] to a let blah = [0..d]
18:09:14 <sorear> > let x = 42 in runCont $ do { r <- callCC (\k -> do { r <- k x ; return (r + 2) }) ; return r + 1 }
18:09:15 <lambdabot>  add an instance declaration for (Num (Cont r b))
18:09:24 <sorear> > let x = 42 in runCont $ do { r <- callCC (\k -> do { r <- k x ; return (r + 2) }) ; return (r + 1) }
18:09:25 <lambdabot>  Add a type signature
18:09:44 <augustss> Axioplase:   r<-callCC $ \k -> do x' <- k x; return (x'+2)
18:09:44 <augustss>   return (1+r)
18:09:50 <sorear> > let x = 42 in runCont $ (do { r <- callCC (\k -> do { r <- k x ; return (r + 2) }) ; return (r + 1) } :: Cont Int Int) id
18:09:51 <lambdabot>    The function `(do
18:09:51 <lambdabot>            r <- callCC (\ k -> do
18:09:51 <lambdabot>      ...
18:10:04 <sorear> > let x = 42 in flip runCont id $ (do { r <- callCC (\k -> do { r <- k x ; return (r + 2) }) ; return (r + 1) } :: Cont Int Int)
18:10:05 <lambdabot>  43
18:11:05 <Cale> ClaudiusMaximus: hmm, if the list is long, that might waste space, but save a little time
18:11:20 <sorear> ?type accum
18:11:22 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
18:12:19 <Cale> Hey, it's an array of Ints, you can get better performance for free
18:12:33 <Cale> Well, maybe :)
18:12:41 <Cale> Are you relying on the laziness of the array?
18:13:25 <Cale> You could try replacing it with a UArray, and seeing what happens :)
18:13:50 <Cale> UArrays have exactly the same interface, so all you have to change are the types, and the modules you're importing.
18:14:14 <Cale> (ClaudiusMaximus)
18:15:07 <ClaudiusMaximus> Cale: no laziness required, as the accumulation array's width/height will only be as big as a typical web image, i'll look into UArray (whatever that is)
18:15:44 <Cale> yeah, all you have to do is import Data.Array.Unboxed
18:16:03 <Cale> and then change your types to read UArray where they currently say Array
18:16:46 <Cale> Array really means an array of pointers to code which computes the cell of the array (and self-updates with a version that returns the computed result immediately after the first time)
18:16:56 <Cale> UArray is more like a C array of Ints
18:17:12 <Cale> a contiguous block of memory
18:17:52 <ClaudiusMaximus> Cale: that sounds perfect, because each array cell ends up being written to a file, after some more processing
18:18:09 <Axioplase> sorear: thanks
18:18:27 <Axioplase> I'm now trying to do the transformation manually on bigger exmaples...
18:18:54 <ClaudiusMaximus> Cale: moreover each update uses the existing values strictly, so nothing to be gained by discarding code that wouldn't be executed
18:20:40 <sorear> Axioplase: UArray iirc even supports raw dumping to disk, though that won't help unless you are writing raw PPM.
18:21:01 <ClaudiusMaximus> sorear: at the moment i'm writing plain PPM...
18:21:24 <Cale> I doubt that's a big performance issue :)
18:22:25 <Cale> oh, you wanted to generalise to arbitrary dimensions? hmmm
18:25:55 <Cale> what does the 3 represent?
18:26:24 <ClaudiusMaximus> Cale: the dimension of the faces
18:26:32 <Cale> aha, okay
18:27:13 <dolio> ?pl \b -> take b . sortBy (flip compare)
18:27:14 <lambdabot> (. sortBy (flip compare)) . take
18:27:57 <sorear> ?pl \b -> take b . reverse . sort
18:27:57 <lambdabot> (. (reverse . sort)) . take
18:28:43 <dolio> You prefer reverse . sort?
18:28:50 <dolio> I suppose it's still n log n
18:28:51 <dolio> :)
18:29:15 <sorear> no, I just thought it might be shorter. :)
18:29:26 <ClaudiusMaximus> hmm, "no instance for (IArray UArray (Int,Int,Int)) arising from use of !"  (i replaced all import Array with import Data.Array.Unboxed and all Array with UArray...)
18:29:42 <sorear> Axio: so you want to create points uniformly distributed on B_n ?
18:29:51 <Axioplase> > dada = do {r<-callCC (\k->do {put k;r<-k 3;return (2+r)});return (r+1)}
18:29:52 <lambdabot>  Parse error
18:29:59 <Axioplase> > do {r<-callCC (\k->do {put k;r<-k 3;return (2+r)});return (r+1)}
18:30:00 <calvins_> any gentoo haskellers over here that could pop over to #gentoo-haskell to answer a quick question about finding a package or external library vi ghci on gentoo?
18:30:01 <lambdabot>  add an instance declaration for (Show (m b))
18:30:14 <sorear> (the subset of the n_cube with at least 1 coordinate 0 or 1)
18:30:28 * mbishop points at dcoutts
18:30:34 <sorear> C-M: UArray only works on primitive types
18:30:39 <sorear> C-M: so you want to create points uniformly distributed on B_n ?
18:30:42 <sorear> (the subset of the n_cube with at least 1 coordinate 0 or 1)
18:31:06 <ClaudiusMaximus> sorear: ok, i'll change my UArrays back to Arrays where necessary
18:32:11 <ClaudiusMaximus> sorear: i guess that's what i want, indeed, but i need to have the set of all such subsets with the same count of coordinates 0 or 1
18:32:15 <sorear> It'd be better to split up the values into multiple cells, unboxed is usually much faster.
18:32:44 <ClaudiusMaximus> sorear: you mean have a tuple of arrays instead of an array of tuples?
18:33:05 <ClaudiusMaximus> sorear: or do my own index conversion?
18:33:29 <sorear> array of arrays, actually 3D array.
18:33:33 <ClaudiusMaximus> sorear: or index by (Int,Int,Int) instead of (Int,Int)
18:34:08 <ClaudiusMaximus> sorear: where the last int is in [0...3)
18:34:11 <sorear> (Int, Int, Component) where data Component = Red | Green | Blue deriving (Ix)
18:34:42 <sorear> UArray works on any index type, it's the values that are restricted.
18:34:49 <ClaudiusMaximus> sorear: thanks, makes sense :)
18:35:19 <jgrimes> how differently does Gofer handle type synonyms?
18:35:21 <sorear> so, you're rendering hypercubes?
18:35:43 <ClaudiusMaximus> sorear: yeah, then i'll move on to simplices and cross polytopes
18:35:57 <lisppaste2> Cale annotated #33730 with "a different approach" at http://paste.lisp.org/display/33730#4
18:36:06 <Cale> ClaudiusMaximus: have a look at that :)
18:36:56 <Cale> It depends on the step size rather than the count, but that should be easy to compute.
18:37:22 <ClaudiusMaximus> Cale: wow, succinct
18:38:11 <Cale> I hope it works ;)
18:38:20 <ClaudiusMaximus> Cale: me too!
18:38:59 <sorear> I propose a very different approach - one face and transformations.
18:40:04 <Cale> oh, that's not separating the faces
18:40:14 <Cale> I can probably fix that.
18:41:42 <sorear> @seen
18:41:42 <lambdabot> Lately, I have seen axioplase, cale, calvins_, claudiusmaximus, dolio, jgrimes, lisppaste2, mbishop and sorear.
18:42:19 <psnl> lisppaste2?
18:43:33 <ndm> the pastebot
18:43:47 <ndm> psnl: will you be at the hackathon?
18:44:08 <psnl> ndm: no, sorry. I have a job interview
18:44:18 <psnl> oh, I need to tell dons
18:44:39 <ndm> what's a job?
18:44:50 <psnl> heh
18:44:53 <ndm> and are you still thinking of that phd thing?
18:45:10 <lisppaste2> Cale annotated #33730 with "separate faces" at http://paste.lisp.org/display/33730#5
18:45:17 <psnl> yeah, I went and talked nicely to st andrews
18:46:12 <Cale> ClaudiusMaximus: have a look :)
18:46:20 <Cale> It looks right to me
18:47:09 <jesus_doesnt_wan> damn nick length restrictions.
18:47:17 <Cale> Now, it generates the whole k-1 dimensional intersections between each of the faces, but I'm not sure if you care aout that.
18:47:25 <ndm> psnl: still thinking of York?
18:47:32 <Cale> about*
18:48:07 <syntaxfree> I wonder if I can get away with my current unrelated background and get acepted into a PhD program in functional programming somehow.
18:48:11 <Cale> (that is, there'll be lots of points which belong to more than one face)
18:48:36 <psnl> ndm: its a bit of an arse, since I cant find out about funding until june.
18:49:46 <ndm> psnl: yeah, i remember...
18:49:47 * syntaxfree is wating for funding to the day. But I think the UK is better in that way than Brazil.
18:49:56 <psnl> ndm: so Im looking for jobs now and If I get offers I'll toss a cin as to what to do.
18:51:06 <sorear> syntaxfree: according to the IRC nicks are limited to 9 characters
18:51:36 <sorear> s/IRC/RFC/
18:51:38 <ndm> psnl: yeah, its a fun position - i had to wait ages
18:52:18 <syntaxfree> sorear: dalnet had very long allowable lengths.
18:52:33 <syntaxfree> I remember having nicknames like syntax_recorded_syntax_and_his_thousand_elephants
18:52:38 <jgrimes> how does declaring an instance work when the type has multiple type parameters and the class only specifies one?
18:53:13 <emu> instance Monad (Either String)
18:53:20 <LoganCapaldo> jgrimes: you'd have to fix the other type parameters
18:54:11 <syntaxfree> how come Data.IntMap doesn't have the findMin/findMax Data.Map does?
18:55:07 <dons> probably no good reason
18:55:11 <dons> other than it wasn't written
18:55:19 <dons> you could submit a patch, if you have a need for this function
18:55:39 * syntaxfree is still a bit timid about submitting patches.
18:55:55 <jgrimes> I was reading a paper that made a type synonym of a multi type parameter type that only had one type parameter, but I can't seem to get what it does to work. It was using gofer.
18:56:00 <syntaxfree> I think I have more substantial additions to Data.Either, but maybe it's just that I'm odd in my usage of Either.
18:56:25 <sorear> type EString a = Either String a -- this is legal H98
18:56:37 <sorear> type EString = Either String   -- this is better
18:56:52 <syntaxfree> I can't find that LicensedPreludeExts wiki page.
18:56:58 <syntaxfree> I even posted my extensions there.
18:57:02 <sorear> it's on the Old Wiki.
18:57:38 <syntaxfree> ahh the sheer comfiness of CamelCase wikis.
18:57:54 <jgrimes> "type E x = Sum (E1 x) (E2 x)" is what it did (Sum is just like Either), and then it declared the instance on E
18:58:38 <sorear> the synonym is legal
18:58:43 <sorear> the instance is not
18:58:51 <allbery_b> haskell98 has limitations on use of type synonyms in typeclasses, in particular they must be fully instantiated
18:58:58 <jgrimes> =/
18:59:10 <jgrimes> it sure would be handy to use the type synonym
18:59:12 <Cale> I don't think that's just Haskell 98 either.
18:59:14 <sorear> haskell98 forbids synonyms outright in typeclasses
18:59:19 <lisppaste2> syntaxfree pasted "trivial additions to Data.Either I use a lot" at http://paste.lisp.org/display/33745
18:59:25 <Cale> There are serious problems with allowing that
18:59:26 <allbery_b> hm, right, that was a ghc extension thing
18:59:38 <sorear> GHC allows synonyms but requires them to be fully instantiated
18:59:38 <Cale> It's essentially introducing type lambda
18:59:47 <allbery_b> at least it let me do it and then bit me in the butt :/
18:59:49 <jgrimes> it was in Gofer
18:59:59 <jgrimes> the instance I am talking about
19:00:08 <Cale> Which instance?
19:00:13 <jgrimes> says it uses constructor classes
19:00:14 <sorear> Type lambda is a good thing, but noone's found a good compromise solution for inference
19:00:24 <Cale> instance Monad (Either e) ?
19:00:24 <syntaxfree> Type lambdas scare me.
19:00:38 <sorear> sf: either' is |||
19:00:40 <allbery_b> <jgrimes> "type E x = Sum (E1 x) (E2 x)" is what it did (Sum is just like Either), and then it declared the instance on E -- this, I think
19:00:47 <sorear> ?type Control.Arrow.(|||)
19:00:48 <lambdabot> Couldn't find qualified module.
19:00:54 <sorear> ?type Control.Arrow.choice
19:00:56 <lambdabot> Not in scope: `Control.Arrow.choice'
19:01:02 <Cale> What are E1 and E2?
19:01:04 <allbery_b> ?type (Control.Arrow.|||)
19:01:04 <sorear> ?type (Control.Arrow.|||)
19:01:05 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
19:01:06 <lambdabot> forall (a :: * -> * -> *) d c b. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
19:01:08 <syntaxfree> Arrows scare me somewhat as well, but I'm already resigned to the fact I'll have to learn'm.
19:01:19 <syntaxfree> What's a good place to start?
19:01:23 <jgrimes> Cale, single parameter types
19:01:28 <Cale> jgrimes: okay
19:01:40 <Cale> well, that's sort of odd.
19:02:00 <sorear> ?type (Control.Arrow.+++) -- is either'
19:02:01 <jgrimes> and then it goes on to declare an instance of Functor on E
19:02:01 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
19:02:29 <Cale> I wouldn't have thought that possible, but perhaps they could do it.
19:02:31 <sorear> ?type Left . (Control.Arrow.|||) -- is trigger
19:02:32 <lambdabot> forall b (a :: * -> * -> *) b1 d c. (ArrowChoice a) => a b1 d -> Either (a c d -> a (Either b1 c) d) b
19:02:37 <sorear> ?type Right . (Control.Arrow.|||) -- is trigger_
19:02:39 <lambdabot> forall a (a1 :: * -> * -> *) b d c. (ArrowChoice a1) => a1 b d -> Either a (a1 c d -> a1 (Either b c) d)
19:02:55 <syntaxfree> arrows have creepy creepy power.
19:02:57 <jgrimes> it seemed pretty handy
19:03:09 <Cale> syntaxfree: http://www.haskell.org/arrows/
19:03:11 <lambdabot> Title: Arrows: A General Interface to Computation
19:03:18 <syntaxfree> I can grok the magic in sigfpe's simple comonads, but Arrows just freak me out.
19:03:19 <Cale> that gives a brief overview
19:03:24 <sorear> trigger{,_} are wrong, sorry
19:03:33 <psnl> I really need to learn the  FFI
19:03:49 <Cale> psnl: best place to learn it is the ffi spec itself
19:03:54 <Cale> It's almost a tutorial
19:04:00 <psnl> ooh, thanks
19:05:10 <syntaxfree> arr :: (b -> c) -> a b c
19:05:35 <Cale> syntaxfree: arrows are general enough of an abstraction that there's very little to really know about them, you're almost better off learning specific examples of arrows
19:05:44 <syntaxfree> Where did the "a" sprout from?
19:05:51 <Cale> a is the arrow itself
19:05:57 <syntaxfree> oh.
19:06:07 <Cale> class Arrow a where
19:06:12 <syntaxfree> arr :: (b -> c) -> b  `a` c
19:06:17 <Cale> right
19:06:26 <syntaxfree> hmm So arr converts "->" to a
19:06:29 <sorear> I'm using instance Arrow (->) now.
19:06:32 <syntaxfree> Heh. Fun.
19:06:33 <sorear> arr is a noop.
19:06:39 <syntaxfree> noop?
19:06:45 <Cale> or   arr :: (b -> c) -> (b ~> c), if you use (~>) instead of a
19:06:49 <sorear> no op
19:07:09 <Cale> For the instance of Arrow for (->),  arr = id.
19:07:10 <syntaxfree> Haskell type declaration syntax allows that?
19:07:16 <sorear> no
19:07:19 <Cale> syntaxfree: probably not in H98
19:07:24 <Cale> but you can do it in GHC
19:07:25 <sorear> GHC > Haskell
19:07:35 <Cale> GHC is Haskell too
19:07:41 <Cale> it's just a newer haskell :)
19:07:44 <syntaxfree> GHC is Haskell too, yes.
19:07:45 <sorear> Haskell > Haskell
19:07:52 <ClaudiusMaximus> (02:43:21) Cale: Now, it generates the whole k-1 dimensional intersections between each of the faces, but I'm not sure if you care aout that.  << i'm not sure what that means...
19:08:02 <syntaxfree> Haskell98 is a frozen Haskell standard for interoperability. Even C has some.
19:08:18 <Cale> ClaudiusMaximus: all I'm saying is that the intersections between the faces are not empty
19:08:37 <Cale> ClaudiusMaximus: so if you're processing things, you'll end up processing the same point over and over in different faces.
19:08:37 <calvins_> Am I reading http://www.haskell.org/ghc/docs/latest/html/libraries/index.html correctly in believing that I should be able to load those libraries from ghci without doing anything special? Just :set -package network, for example.
19:08:56 <Cale> calvins: yes, in fact, you probably don't even have to do that
19:09:00 <syntaxfree> Arrows are also implemented in "pure" Haskell, except for special convenient syntax, like monads?
19:09:12 <ClaudiusMaximus> Cale: sure, they weren't empty in my original algorithm either, but for small steps the intersection will be relatively tiny
19:09:13 <Cale> calvins_: if you're compiling an executable, compile it with --make
19:09:20 <sorear> sf :yes
19:09:26 <Cale> calvins_: GHCi is smart and knows which packages things are in
19:09:41 <Cale> ClaudiusMaximus: right
19:09:42 <ClaudiusMaximus> does Float count as a primitive type?
19:09:47 <sorear> yes
19:09:50 <Cale> yep
19:10:07 <sorear> http://haskell.org/ghc/dist/current/docs/libraries/base/Data-Array-Unboxed.html
19:10:09 <lambdabot> http://tinyurl.com/wwhzy
19:10:17 <sorear> ^^^ look at the instances list
19:10:44 <ClaudiusMaximus> sorear: cool, thanks
19:10:52 <sorear> I suppose I could have used ?docs
19:10:57 <calvins_> i'm not compiling an executable, just trying to see use one of those modules in ghci
19:11:00 <Cale> I think it even packs Bools 8 to a byte :)
19:11:01 <calvins_> For example:
19:11:09 <Cale> calvins_: just do
19:11:16 <calvins_> Prelude> :m + Network.URI
19:11:17 <Cale> :m + Data.Array.IArray
19:11:20 <Cale> or yeah
19:11:21 <calvins_> Could not find module `Network.URI'
19:11:23 <Cale> er
19:11:33 <Cale> oh, that's a new module
19:11:39 <Cale> which version of GHC are you using?
19:11:44 <Cale> That's new in 6.6
19:11:48 <calvins_> yeah, yours works, but i can't find network or HGL. I'm using ghc 6.6
19:11:54 <Cale> hmm
19:11:57 <allbery_b> get tthe ghc-extralibs package
19:12:20 <Cale> hmm, it just works here:
19:12:24 <Cale> Prelude> :m + Network.URI
19:12:24 <Cale> Prelude Network.URI>
19:12:26 <sorear> Cale: yes
19:12:27 <syntaxfree> oh well. Arrows are general enough to be pretty simple, but I can't see how they occurr outside ordinary functions.
19:12:38 * sorear <heart> library sources
19:12:41 <calvins_> HGL is what I'm really looking for, but the module name (Graphics.SOE) [with a period] might be tricky, so I was trying other packages, and can't get others to work either...
19:12:52 <Cale> syntaxfree: well, imagine you have your own datatype for them -- you can specially represent some functions
19:12:54 <syntaxfree> (and these so-called Kleisli and co-Kleisli arrows, which are just functions to "padded" types)
19:13:13 <Cale> syntaxfree: this lets you define >>> specially for various compositions of those, performing various optimisations
19:13:20 <syntaxfree> It often happens to me with very abstract mathematics.
19:13:27 <allbery_b> the dot isn't a problem unles syou specifically told ghci to stick to haskell98 without extensions
19:13:27 <calvins_> allbery_b:  :set -package ghc-extralibs says "unknown package: ghc-extralibs"
19:13:31 <syntaxfree> "Oh, is that a natural transformation? Duh. Now I know what it is, why do I care? "
19:13:36 <allbery_b> not that kind of package
19:13:48 <Cale> calvins_: which OS?
19:13:57 <calvins_> Cale: thanks for that confirmation. That makes me think it's a gentoo-specific problem..
19:14:02 <allbery_b> you need to download and install it, it will register a bunch of new cabal packages with ghc
19:14:24 <allbery_b> on gentoo portage it might be available as separate portage packages instead
19:14:27 <Cale> calvins_: talk to dcoutts when he gets up :)
19:14:37 * allbery_b doesn't know gentoo really
19:14:39 <syntaxfree> John Hughes is fun. I've enjoyed some of his papers before.
19:14:43 <calvins_> allbery_b: the docu implies it should work without installing anything. Is this not the case?
19:14:57 <allbery_b> 6..6 split a bunch of things out of the base
19:15:02 <allbery_b> ghc6.6 that is
19:15:13 <calvins_> Cale: yeah, thanks, I was waiting for someone in gentoo-haskell but thought it might be something obviously stupid that i'm doing. Thanks a lot, all
19:15:55 <Cale> syntaxfree: the basic idea of a natural transformation is that it formalises the idea of a function which transforms between two structures built on an underlying space by only looking at the structure, and not the underlying components.
19:16:08 <allbery_b> I don't recall if Network.URI was split, but HGL definitely was
19:16:16 <Cale> syntaxfree: In Haskell, the idea is best represented by polymorphic functions between data structures.
19:16:17 <syntaxfree> Cale: Yes, I grok the hand-wavy part.
19:16:26 <Cale> Okay, well, that's why you care :)
19:16:28 * syntaxfree is quite adept at grokking hand-wavey stuff.
19:16:42 <Cale> Justifying the hand-wavy stuff is why you care about that.
19:16:47 <syntaxfree> My brain is really wired upside down.
19:17:07 <syntaxfree> for example, I understand Squiggol, but don't know the basic complexity classes well.
19:17:22 <sorear> I don't get the hand-wavy part, but I understand natural transformations because I re-invented them while trying to make monad transformers more useful.
19:17:45 <Cale> sorear: nice :)
19:18:57 <sorear> You have: StateT Y Identity Z  You want:  ReaderT X (StateT Y Identity) Z   You use: lift
19:18:58 <syntaxfree> I re-invented relational databases one.
19:19:01 <syntaxfree> s/one/once.
19:19:06 <Cale> MacLane said that he invented category theory not to study functors, but to study natural transformations. Functors were just a step along that route.
19:19:19 <sorear> You have: ReaderT X Identity Z  You want:  ReaderT X (StateT Y Identity) Z   You use: metalift lift
19:19:52 <newsham> i could have invented the monad (and perhaps already did)
19:19:52 <sorear> metalift is a natural transformation, in the way lift is a functor.
19:20:21 <sorear> it lifts lifters, which is why I named it as such when I invented it.
19:20:28 <LoganCapaldo> the monad invented me
19:20:44 <Cale> LoganCapaldo: in Soviet Russia?
19:21:00 <newsham> a monad too far
19:21:11 <LoganCapaldo> No in soviet russia the monad invented you
19:21:45 <newsham> a monad runs through it
19:22:04 <LoganCapaldo> I know why the caged monadic value sings
19:22:05 <newsham> the monads of madison county
19:22:15 <ClaudiusMaximus> great!  with the UArrays, memory usage tops out at around 30MB (as reported by 'top') instead of blowing up to silly proportions
19:22:15 <psnl> quick ffi question. apart from library and OS calls, why would you use it?
19:22:23 <heatsink> the monad lisa?
19:22:36 <newsham> psnl: seems to be the biggest reasons right there :)
19:22:37 <sorear> great!  how's runtime?
19:22:46 <ClaudiusMaximus> sorear: faster too :)
19:23:01 <newsham> psnl: you could write some optimized C or asm and call it from haskell as an optimization..
19:23:24 <psnl> newsham: I just have code that doesn't seem to be a library interface, and I'm wondering why
19:23:38 <newsham> what does it seem to be?
19:23:39 <psnl> newsham: is that sort of optimisation common?
19:23:46 <newsham> psnl: no idea.
19:24:04 <sorear> C-M: maybe now you can make some bigger pictures?
19:24:08 <sorear> :)
19:24:09 <newsham> it is in some languages...  i imagine it happens occasionally in haskell too
19:24:43 <psnl> newsham: it appears to be code to search though a hat file and extact infomation from it
19:25:17 <ClaudiusMaximus> sorear: bigger pictures require more points to be smooth, and without the space/time leaks i can process more points
19:25:20 <sorear> Long ago, reading text in pure haskell was very slow
19:25:29 <newsham> perhaps written by a different author?  or written prior ot th ehaskell code?
19:25:36 <sorear> Now, we have Data.ByteString.
19:25:46 <sorear> .Char8.Lazy
19:25:54 <psnl> sorear: yeah, that my guess
19:26:01 <psnl> its just an optimisation
19:26:31 <Cale> ClaudiusMaximus: awesome
19:26:35 <sorear> ClaudiusMaximus: how big is the -O2 difference now?
19:26:58 <ClaudiusMaximus> sorear: will run some tests in a bit :)
19:27:01 <sorear> deforestation should be able to turn your entire program into one big loop, no lists involved.
19:28:14 <emu> environmentalists oppose haskell?
19:28:54 <LoganCapaldo> Only the strict environmentalists
19:29:24 <sorear> *groans*
19:30:01 <emu> excessive generation of intermediate data structures always bothered me in strict languages; though, i suppose they could apply similar optimizations in some cases
19:30:08 <Saizan> and the lists? please, think of the lists!
19:32:45 <bankmonad> How to do binary pattern matching in Haskell?
19:33:00 <heatsink> bankmonad: pattern matching on bits of numbers?
19:33:05 <bankmonad> yes
19:33:23 <heatsink> You can't do that using pattern matching, unfortunately.
19:33:41 <bankmonad> ok.
19:34:04 <emu> not directly, anyhow
19:34:17 <LoganCapaldo> I think erlang has pattern mathing for bits and such
19:34:29 * allbery_b can think of a way to do it but does not imagine it would have good performance
19:34:50 <syntaxfree> why would you want to do pattern-matching on bits?
19:35:02 * LoganCapaldo thinks he just though of allbery_b's thought
19:35:15 <LoganCapaldo> syntaxfree: your parsing some binary protocol
19:35:17 <syntaxfree> maybe Data.Bits has what you need without pattern-matching.
19:35:25 <emu> 00x11y?
19:35:31 <allbery_b> [Char] or [Bool depending on what you're trying to do
19:35:37 <allbery_b> [Bool]
19:35:41 <bankmonad> right. mmm
19:35:53 <allbery_b> basically explode the value and match on that.  ugly and slow
19:35:55 <psnl> bankmonad: what are you trying to do?
19:35:56 <syntaxfree> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
19:35:58 <lambdabot> http://tinyurl.com/vdtn4
19:36:01 <bankmonad> trying to implement binary protocol
19:36:22 <allbery_b> I can imagine it being useful for some kinds of bit-twiddling
19:36:45 <sorear> views! :)
19:36:55 <allbery_b> hm.  so process it as strings and pattern match on those
19:37:03 <bankmonad> encryption stuff
19:37:06 <heatsink> You may also want to use the types in Data.Word, which have specific bit widths.
19:37:19 <allbery_b> demarshal to Word* as needed afterward
19:37:55 <bankmonad> sure. But in this case erlang syntax looks handy
19:38:06 <dons> bankmonad: so yes, Data.Bits + ByteString is good for binary tweaking. or using the NewBinary library
19:38:09 <dons> ?where NewBinary
19:38:10 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
19:39:39 <bankmonad> looks interesting. How it performs?
19:41:01 <dons> NewBinary is pretty good. ByteString with your own serialisation on top would be even faster
19:41:02 <falconair> BitSyntax for Haskell: http://www.haskell.org/pipermail/haskell/2006-September/018549.html
19:41:05 <lambdabot> Title: [Haskell] BitSyntax for Haskell, http://tinyurl.com/y5wobr
19:41:27 <sorear> ClaudiusMaximus got some code *much* faster with UArray & manual let floating - 28m + 600MB ram --> hasn't said yet, 30M
19:43:02 <ClaudiusMaximus> sorear: just running the tests now
19:43:49 <emu> i did some pretty nifty things with runSTArray
19:44:14 <emu> ghc handles it well
19:44:30 <bankmonad> cool. Thanks all
19:44:34 <psnl> @help tell
19:44:35 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
19:45:28 <psnl> @tell ndm would you mind having a look at http://www.haskell.org/hoogle/?q=%28%21%21%29 please? the "did you mean" and search term are the same. If that URL doesn't work, the search term is  (!!)
19:45:29 <lambdabot> Consider it noted.
19:45:35 <Cale> Oh, this bitsyntax for Haskell library is pretty cool.
19:45:49 <bankmonad> indeed
19:46:12 <falconair> there was a recent blog by Karsten Wagneer titled "My Haskell experiences."  In the blog Karsten has some complaints about haskell, when it is used for large projects...for a newbie like me it is a bit discouraging, are his complaints valid or was he using haskell wrongly?
19:46:18 <falconair> http://kawagner.blogspot.com/2006/12/my-haskell-experience.html
19:46:20 <lambdabot> Title: Karsten Wagner's Blog: My Haskell experiences
19:46:49 <dons> I think he was approaching haskell wrongly, far too much state hacking and so on
19:46:49 <Cale> falconair: I'm not completely sure. I wish he'd come on IRC and discuss it :)
19:47:03 <dons> even stil, we've written a lot of large projects, that do use state, without the 'serious' issues he had
19:47:03 <Cale> It does sound like the approach is a little off.
19:47:14 <emu> his experiences aren't like mine, but i don't know enough to say why
19:47:18 <dons> so i think in the end his tone was a bit too negative, considering how well he seems to have done
19:47:36 <dons> and yeah, we don't really know what he did
19:47:52 <dons> other than mess with state a bit weirdly
19:48:09 <dons> one negative blog article in 4 or 5 months is an acceptable rate, imo ;)
19:48:45 <Cale> Most of Joel Reymont's complaints were pretty real, though I think some of them were just because he was trying to do the impossible. I think we've improved those areas where he was having trouble pretty significantly since then though.
19:48:55 <emu> really rapid prototyping is something that i've wondered about a few times.  so far, i just write and throw away... it takes such few lines of code that it isn't an issue.
19:49:04 <falconair> i've been thinking of experimenting with a relational database in haskell....which is obviously going to involve a lot of state manipulation...is haskell less elegant for such projects?
19:49:14 <psnl> I find that good global state is really hard to do well in any language
19:49:18 <Cale> falconair: interfacing with one, or writing one?
19:49:31 <Cale> psnl: global state is a bad idea, period :)
19:49:35 <dons> yeah, we've got some amazing support for state manipulation, in the form of monads
19:49:48 <dons> so if you know you'll need state to start with, i don't see haskell as a bad choice at all
19:50:11 <dons> haskell just understands state a bit better than many languages, making you a bit more careful
19:50:13 <falconair> writing one ... parsing the sql, 'inserting' data into 'tables,' querying those tables, the whole thing (and then adding the ability to query continuous streams!)
19:50:17 <dons> that describes the language in general, I think :)
19:50:26 <Cale> falconair: you might want to have a look at things like HaskellDB
19:50:39 <psnl> Cale: and so the question is: is global state bad by itself, or is it bad becuase doing it well is hard so everyone gets it wrong?
19:50:46 <falconair> I think haskelldb generates queries to be executed by other databases, ,no?
19:50:50 <Cale> psnl: It's bad on its own.
19:51:09 <Cale> psnl: It adds a point of inflexibility into the design of your program.
19:51:30 <Cale> You're basically saying "there will never ever be more than one of this thing"
19:51:45 <geckosenator> you can do it in c
19:51:47 <Cale> which is usually a bad assumption to make
19:51:49 <emu> not to mention breaking referential transparency
19:51:53 <Cale> yeah
19:51:59 <psnl> I need to get you in a pub, then have this discussion
19:52:10 <geckosenator> just dlopen it for each copy you need
19:52:25 <Cale> In Haskell, you're breaking referential transparency, which is one of the most important properties for reasoning about code.
19:52:32 <lisppaste2> ClaudiusMaximus annotated #33730 with "benchmarks" at http://paste.lisp.org/display/33730#6
19:53:02 <gravity> God, this community is amazing. Thanks to everyone who replied to http://programming.reddit.com/info/wg2y/comments
19:53:03 <calvins_> allbery_b: Thanks. You were right. There are gentoo packages for those extra libraries, like network and hgl.
19:53:04 <lambdabot> Title: Monads (reddit.com)
19:53:10 <Cale> and in any language, you're making the scope of things you have to care about all the time in order to understand any small piece of the code, much much wider.
19:53:19 <Cale> gravity: :)
19:53:30 <gravity> Cale: Thank you for your reply. It's exactly what I was looking for
19:53:44 <gravity> Maybe I can come back to haskell sooner than I'd expected
19:53:47 <Cale> you're quite welcome :)
19:55:06 <emu> i do resort to unsafePerformIO for "auxiliary" effects like tracing and logging though
19:55:40 <emu> (and that will bite you if you are doing parallelism)
19:55:45 <Cale> emu: while debugging, that's okay
19:55:59 <Cale> also, it can have nasty effects on evaluation order
19:56:17 <Cale> (consider tqw x = trace (show x) x)
19:56:37 <emu> hmm
19:56:47 <sorear> why nasty effects?
19:57:00 <emu> well that function is strict already
19:57:28 <emu> but x is evaluated fully i suppose? hmm
19:57:33 <Cale> emu: I mean, consider using that tqw function to trace intermediate values produced in your algorithm
19:57:41 <Cale> It'll force their evaluation
19:57:44 <allbery_b> show will force it to be evaluated
19:57:46 <allbery_b> yeh
19:57:54 <Cale> Basically, causing your algorithm to become more strict.
19:58:35 <emu> perhaps.  so far, i have found it useful to monitor precisely when things happen (even out of "order")
19:58:45 <Cale> Sometimes that has a positive effect (which goes away when you remove the tracers!), and sometimes a very negative effect, forcing you to remove the tracers and debug the algorithm some other way.
19:58:49 <emu> i am only using it to print limited amount sof information
19:58:52 <Cale> Yeah
19:59:01 <sorear> what makes you think it'll force them?  trace isn't evaluated until the value is
19:59:26 <Cale> sorear: consider   tqw (repeat 1)
19:59:46 <Cale> can you pattern match against the head of that?
19:59:58 <allbery_b> trace will evaluate the whole thing instead of just what's needed
20:00:00 <sorear> I was thinking you'd use it on atomic types :(
20:00:06 <rahikkala> I once tried to figure out what fix does by using trace, it didn't work :/
20:00:15 <allbery_b> heh
20:00:20 <emu> my Show instances are careful to print out very little, because lots of fun cycles would result otherwise
20:00:26 <Cale> yeah, on atomic types, it tends to be more okay, but even there it can cause really subtle problems
20:00:44 <sorear> it can?
20:00:47 <Cale> sure
20:01:05 <emu> of course this global IO requires a global locking mechanism because of multiple threads. when i first ran this without that, the output was interesting..
20:01:09 <sorear> ?index fix
20:01:09 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
20:01:10 <emu> it looked like a Perl program
20:01:20 <sorear> ?hoogle fix
20:01:21 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
20:01:21 <lambdabot> Control.Monad.Fix :: module
20:01:21 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
20:01:23 <Cale> well, hmm, maybe not
20:01:27 <dons> hehe. got yourself some MVars or TVars now?
20:01:30 <dons> emu?
20:01:30 <Cale> not for Ints, I don't think :)
20:01:37 <emu> yes, i used a TVar i think
20:01:54 <emu> though, I had to also learn that unsafePerformIO was needed to initialize it such that every thread didn't get their own copy
20:02:16 <Cale> But yeah, you have to be a little careful, because the kinds of algorithms which require that level of debugging tend to be the very sort of thing which make these problems crop up.
20:02:16 <quazimodo> emacs haskell-mode is giving me grief :   http://pastebin.ca/297522
20:02:34 <dons> emu, hmm, or you set it up in the main thread, and forkIO
20:02:43 <emu> i have the logging on a command-line flag atm so i can toggle it easily
20:02:43 <dons> once its wrapped in an MVar, things wil be shared
20:02:45 <Cale> quazimodo: I hate the "smart" indent mode in emacs
20:02:56 <Cale> quazimodo: try the simple version
20:03:15 <sorear> tab again on where, it'll go down to 4 spaces
20:03:18 <mauke> re: fun/haskell books, I think I'm going to order "The Fun of Programming"
20:03:19 <quazimodo> Cale, shouldnt the tab definitions in haskell-mode override?
20:03:21 <allbery_b> what version of haskell-mode?  the one distributed with emacs/xemacs is old and buggy
20:03:34 <quazimodo> allbery_b, the newest
20:03:43 <emu> quazimodo: hit tab multiple itmes
20:03:49 <quazimodo> why?
20:03:54 <emu> it cycles through possible choices, since layout makes it ambiguous
20:03:59 <quazimodo> that was odd
20:04:01 <quazimodo> and annoying
20:04:11 <Cale> That's why I turned it off
20:04:27 <quazimodo> its not a fucking big deal though
20:04:29 <Cale> The simple indenter basically makes the thing work like a normal text editor.
20:04:31 <emu> you can use simple-indent or { ; } explicitly, or just hit tab a couple times
20:04:47 <emu> the cost of using Layout
20:04:49 <Cale> Except that it picks the places to stop a little more intelligently
20:04:50 <quazimodo> the tabbing should go forward say 4 spaces, and keep going forward that much untill you hit it twice. when you press enter it ought to start at that place as well ...
20:05:06 <quazimodo> Cale, did you look at my pastebin?
20:05:10 <Cale> quazimodo: yes
20:05:15 <quazimodo> i have simple mode on
20:05:24 <quazimodo> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
20:05:24 <quazimodo> (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
20:05:26 <Cale> ah, oay
20:05:28 <Cale> okay
20:05:38 <emu> that's both, isn't it?
20:05:49 <emu> i think you're only supposed to use one of those lines
20:05:52 <quazimodo> well even if it is, the last one takes precedence?
20:06:03 <allbery_b> I would expect ==quazimodo
20:06:10 <quazimodo> i didnt read the documentation ttm when i installed, maybe you are right
20:06:13 <allbery_b> otherwise you would have to restart emacs t switch between them
20:06:27 <Cale> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)  -- remove this line
20:06:28 <allbery_b> which strikes me as a really *bad* design
20:06:38 <emu> you could run turn-on-haskell-simple-indent in the buffer you want to change it
20:06:47 <quazimodo> ok done guys
20:06:49 <quazimodo> 1 sec
20:06:59 <emu> mmm global state
20:07:21 <emu> dons: wlel the problem was that i wanted some "simple" function like "writeLog" that could be used in pure code like Debug.trace.
20:07:36 <allbery_b> hm, although I suppose add-hook might prepend instead of appending, in which case the first ne would take precedence
20:07:50 <emu> add-to-list prepends, i believe
20:07:58 <allbery_b> there you go
20:08:27 <ClaudiusMaximus> thanks for all your help, i have nonhaskell stuff and things that need doing now :'(   bbl
20:08:28 <Cale> ClaudiusMaximus: how long does ./DrawCube-O0/O2 take on the size 128 problem?
20:08:47 <Cale> er, or the size 48 problem
20:09:01 <ClaudiusMaximus> Cale: will start some tests now, while i clean the kitchen...
20:09:16 <Cale> 1m22s -> 3.82s seems like a decent improvement :)
20:09:41 * allbery_b is finally getting around to ghc on freebsd, since the big portupgrade finally finished
20:09:54 <allbery_b> will try to poke at the libreadline stuff that's been reported
20:11:03 <psnl> on the subject of global state, there is scary amounts of it in the hat C stuff
20:13:41 <emu> speaking of scary stuff, some of the functions in the ghc source are ... gigantically long do blocks
20:14:05 <quazimodo> commenting that line out made no difference ;/
20:14:50 <emu> it's still using "smart" indent?
20:15:00 <quazimodo> its just being a fag
20:15:06 <quazimodo> why does it fucking do this retarded shit!?
20:15:11 <NichardRixon> i awward you 17 dokey kong poimts
20:15:20 <quazimodo> me?
20:16:20 <emu> i ran M-: (turn-on-haskell-simple-indent) in one of my buffers and it seems simple enough now. goes by 4 spaces.
20:16:35 <quazimodo> im scared
20:16:38 <quazimodo> brb
20:27:28 <ClaudiusMaximus> Cale: ./DrawCube-O0 48 = 16mins, ./DrawCube-O2 48 = 9secs
20:27:52 <Cale> ClaudiusMaximus: still a pretty hefty gap there
20:28:18 <sorear> 28m -> 16m isn't too bad
20:28:24 <Cale> yeah
20:28:26 <sorear> 26s -> 9s is good
20:28:37 <Cale> and the old one took 28m unoptimised
20:29:05 <emu> gosh i might have to try out -O2
20:29:19 <ClaudiusMaximus> x2 speed increase from juggling some lets and using UArray instead of Array
20:29:23 <augustss> emu: those speedups are not typical
20:30:11 <emu> consider a DiffUArray?
20:30:25 <sorear> wouldn't help
20:30:53 <sorear> DiffUArray is only good when you are making many small updates to a large array
20:31:04 <sorear> he is making an array from scratch
20:31:09 <emu> ah
20:31:17 <sorear> internally, accum uses full mutable arrays
20:31:25 <sorear> a ~3 line monadic loop
20:34:03 <syntaxfree> monadic loops.
20:34:24 <syntaxfree> My ex broke up with me two weeks ago and she's already seeing someone else.
20:34:32 <syntaxfree> Jesus fuck, I'm not okay with that.
20:38:41 <bd_> :t accum
20:38:43 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
20:53:20 <psnl> can you make a anon function out of case, rather than lambda?
20:53:34 <sorear> nope, I wish
20:53:43 <Cale> no, but you can combine them
20:53:49 <Cale> (\x -> case x of ...)
20:54:03 <sorear> indeed, several adt's have functions that are basically cases
20:54:07 <bos_> wow, documentation for package management is sparse.
20:54:28 <sorear> Maybe has maybe, Either has either, lists (sorta) have foldr
20:54:43 <Cale> What would be better than just case would be a notation for catamorphisms (like foldr)
20:54:45 <sorear> bos_: elaborate?
20:55:27 <bos_> sorear: i haven't used haskell in ages. i want to play with hxt. i have ghc installed. there's a big gulf between "i have ghc" and "i have hxt" :-)
20:56:08 <lisppaste2> psnl pasted "odd use of case" at http://paste.lisp.org/display/33750
20:56:21 <allbery_b> it uses cabal, doesn't it?
20:56:26 <sorear> debian: apt-cache search hxt ; apt-get install XYZ ?
20:56:31 <psnl> I have that in the middle of a big function comperension
20:56:53 <bos_> allbery_b: it probably does, but cabal isn't terribly well documented either.
20:56:54 <syntaxfree> there's a Foldable class.
20:56:55 <allbery_b> runhaskell Setup.[l]hs --configure # then repeat with --build and --install
20:56:58 <syntaxfree> @instances Foldable
20:56:59 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:57:13 <syntaxfree> @help instances-importing
20:57:13 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
20:57:25 <syntaxfree> @instances-importing Data.Foldable Foldable
20:57:26 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:57:31 <bos_> btw, what's the difference between ghc and runghc?
20:57:35 <allbery_b> might be ghc6.6?
20:58:31 <allbery_b> runghc compiles to bytecode and runs a source file; ghc compiles to machine code without running.
20:58:48 <bos_> i see, so runghc is like a non-interactive ghci.
20:58:57 <allbery_b> pretty much
20:59:03 <bos_> boy, the times, they have changed.
20:59:22 <bos_> ok, thanks.
20:59:23 <syntaxfree> box, hace they?
20:59:42 <bos_> syntaxfree: the last time i ran ghc was probably 1994.
20:59:52 <syntaxfree> heh.
20:59:55 <augustss> bos_: then times ahev changed!
20:59:58 <newsham> welcome home
21:00:03 <syntaxfree> the time have a-changed, yes.
21:00:28 <bos_> i just got distracted for, you know, a decade. as one does.
21:00:52 <sorear> you need to upgrade to 6.4 at least, 0.29 isn't supported anymore. :)
21:00:53 <newsham> the prodigal son returns
21:01:15 <bos_> the cast of characters hasn't changed much :-)
21:01:46 <sorear> what do you think of #haskell? :)
21:02:13 <bos_> very nice, i must say.
21:02:30 <syntaxfree> bos_: wait till they show you GADTs. ;)
21:02:33 <newsham> > words "bots are cool"
21:02:34 <lambdabot>  ["bots","are","cool"]
21:02:46 <bos_> eep. so Setup.lhs configure tells me i'm missing all kinds of stuff, like haddock, happy, alex, and so on.
21:02:52 <bos_> GADTs?
21:03:10 <dons> bos_: only if you need those things. if your project doen't use them, the warning is harmless
21:03:13 <bos_> arrows are new to me. when i were a lad, we had to roll our monads by hand.
21:03:21 <dons> you can derive Monad now :)
21:03:37 <bos_> it's a shame there are 9900 monad tutorials and no arrow tutorials.
21:03:40 <dons> and there's this 'do' syntax. :D
21:03:54 <dons> there's a couple of arrow-related tuts in the last few weeks
21:03:59 <bos_> ooh, nice.
21:04:02 <dons> Cale's RSS aggregator uses arrows
21:04:15 <bos_> i saw that. it was utterly incomprehensible to me.
21:04:27 <bos_> 50 lines of teco masquerading as haskell :-)
21:04:42 <dons> and the phooey ui library, uses arrows
21:04:44 <dons> ?where phooey
21:04:45 <lambdabot> http://conal.net/phooey/
21:04:52 <bos_> but it's very exciting to see such a vibrant community.
21:05:16 <bos_> as does yampa. i shared a room with one of the authors (antony) in college.
21:05:16 <sorear> you want teco?  In a fit of lunacy last week, I smashed a Curry-Howard theorem prover into 590 *characters*.
21:05:19 <dons> yeah, its fun. #haskell is the 3rd or so largest prog lang channel, and one of the top chans on freenode these days :)
21:05:31 <sorear> @users
21:05:32 <lambdabot> Maximum users seen in #haskell: 309, currently: 267 (86.4%), active: 29 (10.9%)
21:05:41 <newsham> http://www.haskell.org/haskellwiki/Arrow_tutorial
21:05:43 <lambdabot> Title: Arrow tutorial - HaskellWiki
21:05:46 <LoganCapaldo> its where all the cool kids hang out
21:05:47 <sorear> I'm very new here
21:05:51 <dons> thanks newsham
21:06:10 <sorear> learned haskell <1 year ago, joined #haskell <2 months ago
21:06:24 <bos_> sorear: welcome home :-)
21:06:35 <audreyt> besides GADTs, STM is also a cool, new. beautiful, popular addition to Haskell :)
21:06:50 <dons> and the smp runtime
21:06:59 <augustss> bos_: GADTs are just index data types.  we had them in 1994 too, just not implemented in haskell compiler
21:07:03 <dons> gotta get you some multicore ghc
21:07:10 <bos_> yes, STM is nice. i've been writing an STM implementation in python, but it's nowhere near as elegant as in haskell.
21:07:10 <dibblego> is STM the same STM that I saw Simon Peyton-Jones talking about in a video?
21:07:15 <bos_> dibblego: yep
21:07:16 <augustss> STM is very cool
21:07:30 <audreyt> and bytestrings! haskell is now downright _industrial_! :)
21:07:57 <dibblego> it needs to take 50000 lines to do something meaningful to be classes industrial
21:07:57 <sorear> haskell can process 8.4GB of text in 12m ...  3m CPU.
21:08:14 <dons> STM and Monads are good brand differentiating devices ;)
21:08:16 <bos_> ok, on to my next silly packaging question.
21:08:21 <sorear> That's right, Haskell IO is IO-bound again!!
21:08:23 <bos_> i've successfully installed the http package.
21:08:30 <dons> sorear: hehe
21:08:35 <bos_> but now i want ghc-pkg to know it's there.
21:08:41 <sorear> just use apt-get or equivalent
21:08:51 <bos_> i don't run debian. i run fedora.
21:08:51 <sorear> dependencies are not for humans
21:08:54 <dons> bos_: you built and installed it?
21:08:54 <allbery_b> Setup.hs ==install should register it
21:08:58 <bos_> dons: yep
21:08:59 <audreyt> dibblego: nanotech industry is also industrial
21:09:00 <sorear> yum ?
21:09:01 <allbery_b> "--install"
21:09:14 <bos_> the fedora haskell project seems fairly moribund.
21:09:26 <sorear> isn't yum what you want?
21:09:40 <dibblego> audreyt, I was being sarcastic
21:09:41 <dons> bos_: ghc-pkg list http  --?
21:09:44 <bos_> sorear: yum is the system package manager.
21:10:24 <bos_> dons: Setup.lhs swears up and down it's installed, and ghc-pkg says "nope"
21:10:26 <allbery_b> yes, the suggestion is that if it exists as a yum package already you might use that
21:10:52 <allbery_b> of course you might need to hunt down the right repo(s)
21:11:09 <bos_> i see. but i'd rather understand the native packager, so i can not trip over my shoelaces again.
21:11:12 * sorear is too used to installing packages... it's easy
21:11:27 <bos_> it's easy to install debs or rpms, yes.
21:11:28 <sorear> Cabal's also pretty simple.
21:11:31 * allbery_b doesn't know fedora either; SuSE and Ubuntu here, plus freebsd and OSX
21:12:01 <sorear> get the code, get the deps, for x in configure build install ; do ./Setup.lhs $x ; done
21:12:05 <bos_> augh, the package is called HTTP, not http.
21:12:23 <bos_> sorry. i'm a maroon.
21:12:27 <sorear> there is a vaporware apt-get for haskell, cabal-get
21:12:37 <bos_> cabal-get is dead.
21:12:43 <bos_> cabal-install is the new cabal-get.
21:12:58 <bos_> unfortunately, the darcs repo that contains cabal-install seems old and crusty.
21:13:12 <dons> bos_, you wrote "Space-saving Optimisations for the Glasgow Haskell Compiler (1994)" ?  :)
21:13:14 <bos_> it's based off cabal 1.1.4.
21:13:17 <bos_> dons: yep.
21:13:23 <quazimodo> when ghci is given something and it just returns with a blank line, how do i "escape" from that procedure it is hung up on, or waiting for?
21:13:32 <sorear> C-c
21:13:35 <allbery_b> control-c
21:13:52 <syntaxfree> wow. bos_ is an old-schooler.
21:13:52 <bos_> i worked for a little while at glasgow back when it and chalmers and yale were the centres of the world.
21:14:10 <syntaxfree> aren't they still?
21:14:19 <dons> cool. glad to have you back :)
21:14:21 <quazimodo> thanks, i was using it in an emacs terminal so i had to click twice, i forgot for a second emacs catches C-c first to then do its own sutff to
21:14:24 <bos_> well, everyone interesting at glasgow left.
21:14:29 <dons> well, chalmers is still pretty big in the haskell world :)
21:14:46 <dons> portland is also a bit popular these days..
21:14:48 <bos_> dons: thanks.
21:14:57 <syntaxfree> oh. it's still the Glasgow compiler, though.
21:14:58 <bos_> yes, john launchbury was there back in the day, too.
21:15:23 <dibblego> is passing a Map in a State monad a conventional way of memoizing?
21:15:26 <syntaxfree> heh. When talking about something I don't really understand, I just say "The Smart People from Glasgow say..."
21:15:50 <sorear> usually unsafePerformIO is used
21:15:51 <augustss> syntaxfree: most of them left
21:15:52 <syntaxfree> or just The Man From Glasgow.
21:15:53 <bos_> syntaxfree: just use the term "abstract nonsense". that's what all the category theorists say.
21:15:53 <dons> dibblego: hmm, its a conventional way to implement a symbol table
21:16:08 <dibblego> what's a symbol table exactly?
21:16:13 <sorear> ?google Stretching the storage manager
21:16:16 <lambdabot> http://citeseer.ist.psu.edu/peytonjones99stretching.html
21:16:16 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
21:16:17 <syntaxfree> bos_: well, when talking about something I don't understand in Haskell.
21:16:38 <bos_> syntaxfree: if there's something you don't understand in haskell, it's probably due to category theory memes :-)
21:16:40 <sorear> dibblego: ^^^ there's your SPJ-paper on memoization in haskell
21:16:46 <dibblego> ok thanks
21:17:03 <syntaxfree> my friends hear about the Man from Glasgow all the time. I'm surprised to know Glasgow isn't an important Haskell centre anymore.
21:17:11 <bos_> the other great thing about current haskell vs haskell of yore is blogs.
21:17:21 <dons> oh?
21:17:21 <syntaxfree> bos_: ah, I know enough cat theory to name-drop it.
21:17:35 <syntaxfree> It's fun to scare away newbies saying monads are endofunctors on the category of types.
21:17:56 <BitShiftr> That scares more than just newbies...
21:18:04 <quazimodo> i am still a little confused how to do some things without being able to have standard variables :/
21:18:05 <bos_> you read a single blog entry from a haskell hacker, and it's about 75 times as filling as a python coder's blog entry.
21:18:11 <syntaxfree> bos_: are you aware of haskell-cafe? More interesting discussion goes on there than in the blogs.
21:18:20 <syntaxfree> oh, sure.  I was saying that the other day.
21:18:22 <bos_> syntaxfree: yep, haven't subscribed yet.
21:18:54 <dons> (I think all the blogs certainly helps get the community more visibility)
21:19:00 <dons> since we have many good writers
21:19:06 <bos_> dons: for example, you :-)
21:19:13 <augustss> indeed
21:19:16 <syntaxfree> sorry to piss in the well and ruin the community's credibility ;)
21:19:27 <sorear> And we've got lots of young people.
21:19:36 <sorear> I'm barely older than Haskell.
21:19:40 <quazimodo> im young, but im practically retarded at this :)
21:19:45 <NichardRixon> i awward you 17 dokey kong poimts
21:19:49 <augustss> sorear: scary :)
21:19:50 <bos_> whoever keeps feeding programming.reddit.com with haskell and erlang stories are worth a pat on the back, too.
21:20:01 <dibblego> quazimodo, you are less retarded than the other guy who doesn't even know what haskell is
21:20:06 <syntaxfree> programming.reddit.com used to be *all* Lisp and Haskell.
21:20:08 <mauke> NichardRixon: excuse me wtf r u doin
21:20:11 <dibblego> quazimodo, and there are plenty of 'other guys'
21:20:15 <syntaxfree> and Smalltalk.
21:20:19 <NichardRixon> oh shit
21:20:20 <NichardRixon> sorry
21:20:22 <quazimodo> dibblego, well i did take the first step, this language is very cool
21:20:26 <NichardRixon> scripts I forgot to turn off ;_;
21:20:38 <syntaxfree> Now it's full of Ruby and DB stuff.
21:20:39 <quazimodo> NichardRixon, fix up the spelling?
21:20:46 <NichardRixon> no no, that's the point
21:20:52 <dibblego> programming.reddit.com is getting silly
21:20:54 <quazimodo> ok
21:20:57 <syntaxfree> one of these days CSS tricks will start slipping in programming.reddit.com
21:21:02 <augustss> NichardRixon: and what about Millhouse?
21:21:21 <bos_> it's still a long way above the corresponding cesspool on digg.
21:21:31 <NichardRixon> eh?
21:21:39 <syntaxfree> Slashdot consistently rejects good Haskell stories.
21:21:45 <augustss> Richard Millhouse Nixon
21:21:49 <syntaxfree> I think the only mention of Haskell that ever got through was Pugs.
21:21:52 <newsham> all sewer pipes lead to the same cesspool
21:21:58 <syntaxfree> bos_: hey, you heard of Pugs, btw?
21:22:02 * allbery_b wouldn't expect cmdrtaco to understand them
21:22:09 <augustss> Pugs has been a great thing for Haskell.
21:22:15 <bos_> syntaxfree: pugs? audrey's perl-in-haskell?
21:22:18 * allbery_b admittedly has a less than stellar opinion of /.
21:22:19 <syntaxfree> yes.
21:22:26 <NichardRixon> audreyt, I didn't know that was his middle name :o
21:22:31 <NichardRixon> er
21:22:34 <NichardRixon> augustss
21:22:59 <newsham> http://ubergeek.tv/uberzombie/ <- i was a slashdot zombie
21:23:02 <lambdabot> Title: ::uberGeek::Comics::Slashdot Zombie()
21:23:02 <bos_> one of my perl cabal friends only knows about haskell's existence because of pugs.
21:23:18 <sorear> uh, audrey tang - that's a last name, isn't it?
21:23:39 <allbery_b> pretty sure it is
21:23:42 <audreyt> mmm?
21:23:47 <allbery_b> hi :)
21:23:54 <dons> also, sequence.complete.org is a good place to keep track of the community news
21:24:11 <audreyt> bos_: well Perl helped bootstrapping GHC with the Evil-* suite (which eventually got mostly replaced)
21:24:13 <sorear> we're bringing bos_ up to speed on Haskell since '94
21:24:16 <syntaxfree> sorear: he's taking about Richard Mulhouse Nixon.
21:24:20 <audreyt> it's time for GHC to return the favor :)
21:24:33 <dons> heh
21:25:43 <sorear> dons: I've tagged, tarred, uploaded, and announced vty 2.0
21:25:45 <augustss> only Will Partain could understand those ghc Perl scripts
21:25:56 <bos_> i remember them well.
21:26:03 <lisppaste2> dino- pasted "writing ListT transformer" at http://paste.lisp.org/display/33752
21:26:26 <dino-> I've been going through the Monad transformers Wikibook.
21:26:34 <dons> sorear++ well done!
21:26:36 <sorear> dino-: there was a blog post recently that claimed to disprove the existance of ListT.
21:26:43 <sorear> I didn't follow, though.
21:26:45 <dino-> This example of the bind function for a List transformer won't compile.
21:27:02 <bos_> is there any relationship between a package's Setup.lhs and Cabal?
21:27:06 <dino-> sorear: But from the standpoint of writing the beast..
21:27:25 <syntaxfree> bos_: Yes. But please don't ask me any more questions :)
21:27:26 <dons> bos_, the Setup.lhs file, when run, invokes the Cabal library to build and install your code
21:27:27 <sorear> usually, Setup.lhs calls the Cabal library to do the work of setting up
21:27:45 <augustss> sorear: do you mean about the fact that ListT often produces things that are not monads?
21:27:45 <bos_> i'm just thinking that it would be awfully nice to be able to build RPMs straight off the bat, and have Cabal know how to do it.
21:27:51 <dons> most Setup.lhs are just:
21:27:52 <dons> > import Distribution.Simple
21:27:53 <dons> > main = defaultMain
21:27:53 <lambdabot>  Parse error
21:27:53 <lambdabot>  Parse error
21:27:54 <mauke> haha, I understand the name "hash consing" :-)
21:28:15 <dons> bos_ I think that is possible. it wsa certainly a goal for cabal
21:28:22 <dons> it works for .debs
21:28:38 <bos_> ooh, if it works for .debs, i can hack it for rpms.
21:28:56 <syntaxfree> or use alien.
21:29:04 <dons> rpms might even work too. check the cabal docs, or the cabal hackers (e.g. dcoutts, Igloo, Lemmih)
21:29:21 <dons> and SyntaxNinja
21:29:34 <syntaxfree> not to be confused with syntaxfree
21:29:47 <sorear> @seen SyntaxNinja -- uh...
21:29:48 <lambdabot> SyntaxNinja is in #haskell, #darcs and #haskell-blah. I last heard SyntaxNinja speak 4h 42m 46s ago.
21:29:49 * bos_ fetches the darcs repo
21:30:11 <sorear> oh, somehow I thought it was in the 9mo range, strange me
21:30:35 <newsham> i havent programmed in 2 weeks.
21:30:38 <dino-> Not sure how exactly it's wrong. The error is involving: Couldn't match expected type `[a]' against inferred type `a' in (mapM (runListT . f) botV) >>= (\ x -> return (concat x))
21:31:20 <dino-> Where the f here is the 2nd arg to ListT's >>=
21:32:34 * psnl tries to imagine putting a whole set of ideas and people and projects to one side for a decade
21:33:50 <syntaxfree> psnl: life is what happens while you make plans.
21:33:53 <bos_> dons: your ByteString stuff looks superficially similar to ropes.
21:33:58 <bos_> nice.
21:34:09 <dons> the lazy bytestring stuff is related, yep
21:34:15 <dons> the fun stuff is all in the stream fusion though
21:35:23 <bos_> are you still a student, as your home page claims?
21:35:28 <dons> yeah
21:35:31 <dons> for 6 months more
21:35:53 <bos_> what's your topic?
21:36:18 <augustss> dons: and then we'll have to lure you away
21:36:23 <dons> typesafe dynamic linking (and miscellaneous haskell tech ;)
21:36:27 <dons> augustss: please do! :)
21:36:50 <augustss> dons: new york, perhaps?
21:37:06 <dons> that'd be fine with me...
21:37:36 <syntaxfree> unusually good /. story: http://it.slashdot.org/article.pl?sid=06/12/29/2029236
21:37:39 <lambdabot> Title: Slashdot | The Numbers Stations Analyzed, Discussed
21:38:33 <augustss> dons: i'll tell howard about your timeline
21:39:41 <dons> I'd appreciate that, augustss. I plan to have the thesis done by July.
21:39:59 <sorear> oh dons: having read the paper, if you want to be sure an imported symbol is a Dynamic why not look at the interface file you're already parsing?
21:40:42 <dons> mm, yes, I think I looked at that
21:42:57 <augustss> dons: did you say that hs-plugins doesn't work with 6.6?
21:43:14 <dons> yeah, it doesn't yet. should do after the hackathon
21:43:22 <augustss> oh, ok
21:43:29 <dons> i have to toss out the AltData.Typeable stuff, and fix the .hi file parser
21:44:27 <augustss> isn't there a .hi parser in ghc you can use?
21:46:49 <bos_> @pl \xs -> (min xs, foldr ((-) . min xs) xs)
21:46:52 <lambdabot> liftM2 (,) min (foldr =<< ((-) .) . min)
21:46:59 <bos_> wow.
21:48:04 <bos_> @pl \xs -> (min xs, foldr ((-) $ min xs) xs)
21:48:06 <lambdabot> liftM2 (,) min (foldr =<< (-) . min)
21:48:09 <mauke> @type liftM2 (,) min (join (foldr . (-) . min))
21:48:11 <lambdabot> forall a. (Num (a -> a), Ord a) => a -> (a -> a, [a -> a] -> a)
21:48:30 <mauke> hmm, maybe not
21:49:00 <bos_> @type liftM2 (,) min (foldr =<< (-) . min)
21:49:02 <lambdabot> forall b. (Num (b -> b), Ord b) => b -> (b -> b, [b -> b] -> b)
21:49:42 <dons> augustss: there is now, via ghc-api, yeah
21:50:09 <dons> i've been planning to switch to ghc-api for much of the hs-plugins code for a while now
21:50:12 <augustss> bos_: looks fishy
21:50:18 <bos_> augustss: indeed.
21:50:34 <augustss> your original code, i mean
21:50:43 <bos_> that's what i was referring to, too.
21:50:55 <dons> :t \xs -> (min xs, foldr ((-) . min xs) xs)
21:50:57 <lambdabot> forall b. (Num b, Ord b) => b -> (b -> b, [b] -> b)
21:52:21 <augustss> sure you want min and not minimum for one of those?
21:53:10 * allbery_b thinks min is pretty wrong there, after playing with it a bit
21:53:24 <asdf_> what does $= mean ?
21:53:25 <bos_> really what i want is this: \xs->map (flip (-) $ minimum xs)
21:53:34 <asdf_> (in the context of do ..., what does $= mean ?)
21:53:45 <bos_> @pl  \xs->map (flip (-) $ minimum xs)
21:53:46 <lambdabot> map . subtract . minimum
21:53:53 <bos_> mmm, beautiful.
21:54:20 <asdf_> what does $= mean? (I see it in a bunch of do's in the OpenGL examples of haskell)
21:54:21 <mauke> asdf_: nothing?
21:54:31 <asdf_> err?
21:54:36 <asdf_> removing it makes code not work
21:54:38 <asdf_> it's stuff like
21:54:41 <asdf_> displayfunc $= .... blah
21:54:44 <asdf_> glutMainLoop
21:54:46 <dons> asdf_: hmm, perhaps its an OpenGL function?
21:54:49 <dons> check the OpenGL docs
21:54:54 <asdf_> oh
21:54:59 <asdf_> $= is not a syntactical construct?
21:55:01 <psnl> @hoogle ($=)
21:55:02 <lambdabot> Did you mean: ($=)
21:55:02 <lambdabot> Prelude.undefined :: a
21:55:02 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:55:02 <dons> HOpenGL
21:55:03 <asdf_> it's a function name?
21:55:09 <dons> yeah
21:55:22 <dons> ?hoogle $=
21:55:23 <mauke> @hoogle $=
21:55:23 <lambdabot> No matches found
21:55:23 <augustss> asdf_: it's not a haskell construct
21:55:24 <lambdabot> No matches found
21:55:33 <LoganCapaldo> asdf_: Its an operator, but Haskell lets you make up your own :)
21:55:41 <bos_> @pl  \xs->map (flip (-) $ minimum xs) xs
21:55:42 <lambdabot> map =<< subtract . minimum
21:55:43 <sorear> ndm has said hoogle will never default to searching HOpenGL
21:55:59 <bos_> @type =<<
21:56:01 <lambdabot> parse error on input `=<<'
21:56:03 <asdf_> hmm; how can I find where it is dfined (i.e. what should I grep for?)
21:56:06 <bos_> @type (=<<)
21:56:07 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
21:56:12 <sorear> or Gtk2Hs, or wxHaskell, too many symbols defined.
21:56:20 <sorear> ?index ($=)
21:56:21 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
21:56:25 <dons> class HasSetter s where
21:56:30 <dons>    ($=) :: s a -> a -> IO ()
21:56:39 <dons> ?docs Graphics.Rendering.OpenGL.GL.StateVar
21:56:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
21:56:40 <psnl> sorear: performace, or just too many results?
21:56:56 <mauke> bos_: do you know about the ((->) e) monad?
21:57:08 <bos_> mauke: no, and =<< is new to me too.
21:57:10 <asdf_> sorear: thanks
21:57:24 <allbery_b> =<< is just flip (>>= )
21:57:24 <dons> =<< = flip >==
21:57:35 <bos_> thanks :-)
21:57:38 <mauke> > join (*) 7
21:57:39 <dons> s/dons/allbery_b/
21:57:40 <lambdabot>  49
21:57:44 <allbery_b> heh
21:57:51 <augustss> the ((->) e) monad is a @pl favorite
21:58:37 <mauke> > liftM2 (,) sqrt negate 2
21:58:39 <lambdabot>  (1.4142135623730951,-2.0)
21:58:45 <augustss> because it has many standard combinators as monad functions
21:59:03 <sorear> psnl: too many results
21:59:13 <allbery_b> the @pl of that expression is moderately more interesting when you factor out the minimum xs
21:59:17 <augustss> @pl \ f g x -> (f x) (g x)
21:59:17 <lambdabot> ap
21:59:35 <allbery_b> @pl \xs -> let m = minimum xs in (m, map (subtract m) xs)
21:59:38 <lambdabot> ap (ap (,) . flip (map . subtract)) minimum
21:59:41 <sorear> If it were performance, I'd hack a smart data structure into hoogle and sidestep the problem.
22:00:22 <bos_> @pl  \xs->(minimum xs, map (flip (-) $ minimum xs) xs)
22:00:24 <lambdabot> liftM2 (,) minimum (map =<< subtract . minimum)
22:01:02 <bos_> what's ap?
22:01:04 <dino-> Oho, I think it was the type. It was showing up as ... runListT :: m a }  instead of ... runListT :: m [a] }
22:01:11 <augustss> @type ap
22:01:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:01:23 <augustss> monadic apply
22:01:33 <dino-> Mangled by the wiki software and missing <pre> tags.
22:01:35 <mauke> ap mf mx = do { f <- mf; x <- mx; return (f x) }
22:01:38 <bos_> augustss: thanks.
22:02:08 <augustss> and when m=((->) e) it turns into the S combinator
22:05:06 <bos_> augustss: are you referring to \x y z -> x z (y z)?
22:05:18 <mauke> @type \f g -> g >>= flip f
22:05:20 <lambdabot> forall a a1 c. (a1 -> a -> c) -> (a1 -> a) -> a1 -> c
22:05:29 <bos_> pardon me, my combinator calculus is horribly rusty.
22:05:37 <mauke> @. djinn type \f g -> g >>= flip f
22:05:38 <lambdabot> f a b c = a c (b c)
22:05:46 <mauke> yay!
22:06:04 <bos_> well okey dokey then :-)
22:08:22 <mauke> man, unpl needs to talk to djinn
22:09:23 <dons> ?unpl \f g -> g >>= flip f
22:09:23 <lambdabot> \ f g -> g >>= \ b c -> f c b
22:09:36 <dons> ?pl \ f g -> g >>= \ b c -> f c b
22:09:36 <lambdabot> (=<<) . flip
22:10:13 <mauke> @. djinn type flip (>>=) . flip
22:10:15 <lambdabot> f a b c = a c (b c)
22:11:04 <dons> mmm, interesting, http://gravityboy.livejournal.com/31930.html
22:11:06 <lambdabot> Title: gravityboy: Communities
22:11:09 <dons> keep having fun everyone!
22:11:14 <dons> -Ofun for all!
22:13:22 <allbery_b> yay!
22:13:53 * dons passes around the sugared lambdas
22:16:30 <benja_> @quote shapr
22:16:31 <lambdabot>  Hey, don't talk bad about my holy war!
22:16:34 <benja_> @quote shapr
22:16:35 <lambdabot>  Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas.
22:16:38 <benja_> @quote shapr
22:16:39 <lambdabot>  Hey, don't talk bad about my holy war!
22:16:55 <sorear> @quote quazimodo
22:16:55 <lambdabot>  btw i think i have a feeling i know why you guys are so ready to deal with me and put up with noob questions ... your program so fast compared to other language users that you have time to mess
22:16:55 <lambdabot> around?
22:17:08 <benja_> @quote shapr lambda
22:17:09 <lambdabot> shapr lambda hasn't said anything memorable
22:17:45 <benja_> (well I meant the one about toking on a lambda =))
22:19:26 <quazimodo> yay
22:19:28 <dons> yeah, maybe i'll hack up the regex matching feature tonight
22:19:32 <quazimodo> i said something memorable!
22:21:00 <dons> ?pl return `fmap` io (randomElem arrList)
22:21:01 <lambdabot> return `fmap` io (randomElem arrList)
22:21:04 <dons> weird
22:21:18 <mauke> why?
22:21:52 <dons> It's repeated 15 times in a lambdabot module
22:21:55 * dons rolls a where clause
22:22:20 <dons> (its just doing some lifting up a couple of monad levles)
22:23:27 <lisppaste2> dibblego pasted "can this be written in terms of a fold?" at http://paste.lisp.org/display/33755
22:23:54 <sorear> dons: what was it about the lambdabot log grepper having to work on the darcs logs?
22:24:28 <sorear> dibblego: yes
22:24:50 <dibblego> I tried and failed a couple of times
22:24:52 <dons> sorear: I'd prefer not to have to download 200M of logs from somewhere, when i've got logs in darcs already :)
22:25:02 <benja_> ?type foldr
22:25:03 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
22:25:55 <allbery_b> that has no declared points, @pl tends to ignore those
22:26:42 <dibblego> finiteList = foldr ? Nil
22:27:31 <sorear> dibblego - I typed your solution, ^X^S absentmindedly - turns out ^X is elinks for delete everything, and theres no undo
22:27:38 <benja_> foldr (\x fxs -> Cons (1 + length fxs) x fxs) Nil ?
22:28:02 <allbery_b> ^V?
22:28:08 <allbery_b> (^X commonly being "cut")
22:28:11 <dibblego> sorear, lol nice one
22:28:29 <lisppaste2> sorear annotated #33755 with "as you wish, foldy" at http://paste.lisp.org/display/33755#1
22:28:47 <sorear> benja_'s is better
22:29:25 <dibblego> why?
22:29:27 <sorear> ^V does nothing
22:29:39 <sorear> shorter, no explicit cases
22:29:41 <allbery_b> sad
22:30:53 * sorear just realized that his annotation title parses as trying to insult dibblego.  Sorry.
22:31:10 <dibblego> I have been called worse than foldy
22:31:47 * allbery_b makes a note not to use elinks for anything important
22:32:20 <allbery_b> (rather like w3m, use with extreme caution because the keybindings are bizarre)
22:36:37 <Cale> bos_: Yeah, I'm afraid I didn't optimise it for length, clarity, or efficiency. I just learned HXT while writing it.
22:36:55 <Cale> It might make a good tutorial at some point though.
22:38:12 <dons> allbery_b: w3m? it just uses vi keys, no?
22:38:16 <Cale> I also knew basically nothing about RSS :)
22:38:56 <Cale> I just grabbed a couple of RSS files and had a look for the parts I wanted to extract, and worked on that, and once I had that, wrote the bit which produced an HTML document from it.
22:38:58 <allbery_b> vi or emacs if so configured, plus a native keymapping which is its own strange thing --- but even in the emulation modes it still does unexpected things
22:39:30 <allbery_b> it is safest to go to the help and doublecheck, bindlessly assuming vi or emacs behavior can bite you in odd ways
22:39:44 <allbery_b> "thoughtlessly"
22:40:12 <dons> yeah, true. there's a bunch of funny keys i've never learned, and then i'm surprised when tabs pop up, or the help menu appears :}
22:40:18 <dons> in w3m
22:44:24 <allbery_b> I used w3m -F as a backup browser back when it was the only text mode browser that had a clue about frames, with emacs keybindings.  I kept running into "obvious" emacs-style commands that would send me into straneg states I could never get back from
22:44:43 <allbery_b> except by quitting and restarting
22:45:12 <allbery_b> navigating it on autopilot was almost always a mistake
22:51:36 <sorear> @where dons logs
22:51:37 <lambdabot> http://www.cse.unsw.edu.au/~dons
22:52:17 <allbery_b> @where logs
22:52:17 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
22:52:21 <allbery_b> hm
22:52:45 <sorear> dons: where are your logs again?
22:53:07 <sorear> I foolishly deleted the individual files after catting them together :(
22:53:38 <dons> ~dons/code/irc-logs
22:53:46 <dons> you know the url?
22:53:58 <nornagon> hey dons, did we hit 1 megaline in #haskell?
22:54:02 * gmh33 wonders how to make a data type that can hold numbers and characters...
22:54:04 <dons> we did!
22:54:08 <nornagon> cool.
22:54:11 <gmh33> I have been away from Haskell too long, lol.
22:54:19 <dons> gmh33: data T = N Integer | C Char -- ?
22:54:20 <nornagon> I should really learn haskell
22:54:24 <mauke> Either Integer Char
22:54:32 <nornagon> it's just that right now for me it isn't useful enough >.>
22:54:51 <nornagon> (not that haskell isn't useful, it's just not useful for my current projects)
22:55:01 <dons> what kind of code do you write these days?
22:55:20 <nornagon> I've been writing code for the DS recently
22:55:21 <dons> nornagon: Total number of lines: 1036174.
22:55:22 <gmh33> there we go
22:55:23 <dons> :)
22:55:26 <nornagon> :)
22:55:30 <dons> ah heh
22:55:32 <sorear> dons: what has to happen to .30 before it appears?
22:55:36 <nornagon> lambdabot should have a %linesthisyear
22:55:47 <dons> sorear: .30?
22:55:51 <dons> you mean, today's logs?
22:55:51 <sorear> not ANOTHER command character!
22:55:54 <sorear> yes
22:56:01 <dons> well, midnight needs to tick over :)
22:56:09 <nornagon> :)
22:56:11 <dons> happens in an hour or so
22:56:16 <sorear> Linux supports reading open files, I doubt fBSD doesn't
22:56:21 <gmh33> bwuhahahah, I'm two hours before you dons! :P
22:56:25 <nornagon> dons: ... ?
22:56:33 <dons> ?time dons
22:56:34 <nornagon> midnight isn't for a while
22:56:37 <lambdabot> Local time for dons is Sun Dec 31 17:49:58 2006
22:56:39 <dons> ?time gmh33
22:56:41 <lambdabot> Local time for gmh33 is Sun Dec 31 01:50:07
22:56:50 <gmh33> ok, so I'm several hours before you
22:56:51 <dons> lambdbot reads logs on west coast US time though
22:56:58 <sorear> if the log isn't written, ?log won't work!
22:57:00 <nornagon> ah, okay then
22:57:06 <sorear> dons: why is that?
22:57:14 <dons> it pulls them from clog
22:57:18 <sorear> (do you use the tunes.org logbot?)
22:57:22 <dons> yeah
22:57:28 <dons> though lambdabot collects her own logs too
22:58:20 <sorear> so, you can't get logs early because you download them once a day. oh well :(
22:58:30 <dons> yep :)
22:59:08 <bos_> Cale: your approach to writing your feed aggregator seems perfectly reasonable to me :)
23:07:52 <metaperl> Cale - ping?
23:08:30 <metaperl> should I learn arrows and use HaXT instead of HaXML? I just want to do dynamic HTML generation for web applications
23:08:45 <metaperl> @seen
23:08:46 <lambdabot> Lately, I have seen benja_, bos_, dibblego, dons, eructate, gmh33, mauke, metaperl, nornagon, sorear and twb.
23:09:32 <Craigus> Anyone feel like helping a Haskell newbie with what should hopefully be a simple question?
23:09:38 <dons> Craigus: ask away
23:09:39 <mauke> just ask!
23:09:41 <Craigus> cool
23:10:09 <Craigus> How do I convert an Integer like 21231141 to an array of Integers [2,1,2,3,1,1,4,1]?
23:10:35 <mauke> @hoogle digit
23:10:36 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
23:10:36 <lambdabot> Char.digitToInt :: Char -> Int
23:10:36 <lambdabot> Char.intToDigit :: Int -> Char
23:10:56 <metaperl> > 21231141 `div` 10
23:10:58 <lambdabot>  2123114
23:10:59 <mauke> > (map digitToInt . show) 21231141
23:11:00 <lambdabot>  [2,1,2,3,1,1,4,1]
23:11:44 <Cale> metaperl: well, you can even mostly just guess at how the arrow stuff works if you're just using HXT.
23:11:46 <metaperl> >  [ z | y < [ 10,100,100], z <- 21231141 `div` y ]
23:11:47 <lambdabot>  Not in scope: `y'
23:12:05 <metaperl> >  [ z | y <- [ 10,100,100], z <- 21231141 `div` y ]
23:12:20 <wolverian> nice!
23:12:41 <metaperl> >  [ z | y <- [ 10,100,100], z <- 21231141 `mod` y ]
23:12:45 <bart-_-simpson> hi
23:12:48 <Cale> metaperl: Maybe go over it a bit, but if it doesn't make too much sense right away, just move on and learn how HXT works, because it's fairly intuitive once you see a few basic things come together.
23:13:02 <metaperl> hey why isnt that list comprehension working?
23:13:09 <lambdabot>  add an instance declaration for (Integral [a])
23:13:11 <lambdabot>   In a list comprehension:...
23:13:19 <Cale> Arrows are more of a way of organising notation than they are an abstraction with lots of strong properties that need to be understood.
23:13:22 <metaperl> Cale - would you say that HXT is superior to HaXML? does it have a better example suite?
23:13:45 <gmh33> delayed reaction lambdabot, or does it just like responding to frustrated questions ? lol
23:13:47 <mauke> > [ 21231141 `div` y | y <- [ 10,100,100] ]
23:13:47 <Cale> To be honest, I haven't really tried HaXML, but I know that HXT is based in part on it.
23:13:48 <lambdabot>  [2123114,212311,212311]
23:14:04 <sorear> > 12 `divMod` 10
23:14:05 <bart-_-simpson> i need one ide (with debugger) or one easy debugger for windows...anyone can help me?
23:14:06 <lambdabot>  (1,2)
23:14:07 <metaperl> > [ 21231141 `mod` y | y <- [ 10,100,100] ]
23:14:08 <Cale> >  [ z | y <- [ 10,100,100], let z = 21231141 `mod` y ]
23:14:08 <lambdabot>  [1,41,41]
23:14:09 <lambdabot>  [1,41,41]
23:14:22 <yip> Cale: do you give the same advice for using IO monad?
23:14:26 <Cale> >  [ z | y <- [ 10,100,100], z <- [21231141 `mod` y] ]
23:14:28 <lambdabot>  [1,41,41]
23:14:32 <Cale> yip: to some extent
23:14:55 <yip> Cale: do you think arrows are easier then monads?
23:15:02 <metaperl> I dont understand this :   arr :: (b -> c) -> a b c   ... arr takes a function (b -> c) as input and returns a b c ?
23:15:04 <sorear> > let x y | h /= 0 = Just (l,h) | True = Nothing where (h,l) = divMod y 10 in unfoldr x 10398329
23:15:05 <lambdabot>  [9,2,3,8,9,3,0]
23:15:10 <Cale> In some sense, there's less to know about arrows than about monads.
23:15:16 <gmh33> bart-_-simpson: tried Helium ?
23:15:30 <sorear> > (let x y | y /= 0 = Just (l,h) | True = Nothing where (h,l) = divMod y 10 in reverse . unfoldr x) 10398329
23:15:31 <lambdabot>  [1,0,3,9,8,3,2,9]
23:15:35 <Cale> metaperl: that's right -- read  "a b c" as an arrow of type a from b to c
23:15:38 <mauke> metaperl: think of it as b `a` c
23:15:41 <gmh33> if you're just learning it could be helpful, since it's intended to give more useful error messages, though it doesn't support all of Haskell :/
23:15:42 <bart-_-simpson> gmh33: no..
23:16:02 <sorear> craigus: see my unfoldr
23:16:04 <metaperl> oh wow
23:16:09 <Cale> If you used ~> instead of a, you could write it like   arr :: (b -> c) -> (b ~> c)
23:16:19 <Craigus> sorear - cheers
23:16:33 <mauke> I think my solution is simpler
23:16:39 <metaperl> it is
23:16:50 <Craigus> I'm trying to get mauke's "(map digitToInt . show)"  to work
23:16:52 <dibblego> how is ~> a type?
23:16:58 <orbitz> how exactly does one read osmethign liek Integer -> Integer -> Integer?
23:17:07 <Cale> dibblego: GHC allows infix type variables
23:17:09 <sorear> but its not a solution - he asked for the digits in a list?
23:17:52 <metaperl> orbitz - Integer -> Integer -> Integer ... a function which takes 2 integers and returns an integer is the laymans way of reading it
23:18:16 <dibblego> orbitz, given interface F{Integer f(Integer i);} is can be read as: interface X{F x(F f);}
23:18:28 <metaperl> but Integer -> Integer -> Integer === Integer -> (Integer -> Integer) ...
23:18:34 <orbitz> but why are the parameters and return type in teh same syntaxual form int here?  if that is really how it reads wouldnt' osemting like Integer, Integer -> Integer maek mroe sense?
23:18:37 <dibblego> or without currying; interface X{Integer x(Integer a, Integer b);}
23:18:51 <allbery_b> orbits: haskell supports partial application
23:18:54 <mauke> orbitz: ah, the magic of currying
23:18:55 <dibblego> orbitz, no, because of currying (partial application)
23:18:59 <metaperl> so it really is f . g where g is Integer -> Integer and f is Integer to Integer
23:19:04 <orbitz> ok i fgured curryign was the reason
23:19:13 <sorear> f x y === (f x) y
23:19:16 <allbery_b> given f :: Int -> Int -> Int, if I say (f 1) the result is a function of type Int -> Int
23:19:27 <Cale> @type (+) 5
23:19:27 <mauke> Craigus: it's really just \n -> map digitToInt (show n)
23:19:28 <lambdabot> forall a. (Num a) => a -> a
23:19:31 <Cale> @type (+) 5 6
23:19:32 <lambdabot> forall a. (Num a) => a
23:19:39 <Cale> > (+) 5 6
23:19:41 <lambdabot>  11
23:19:43 <metaperl> @type first
23:19:44 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
23:19:47 <orbitz> right i know taht much i was just tryign to formulate how the syntax works into that
23:19:50 <dibblego> currying is the smallest word that can almost completely eliminate a book on 'design patterns'
23:20:06 <mauke> cout << x << y
23:20:17 <metaperl> Cale, can you please interpret a (b,d) (c,d) for me please?
23:20:31 <dibblego> orbitz, have you read Martin Fowler? 'Replace Method with Parameter' refactoring technique?
23:20:57 <Cale> http://haskell.org/arrows/ -- you can see what first looks like there :)
23:20:58 <lambdabot> Title: Arrows: A General Interface to Computation
23:21:02 <Cale> there's a little picture of it
23:21:07 <metaperl> I see it
23:21:19 <dibblego> er, replace Parameter with Method
23:21:22 <Cale> You think of a (b,d) (c,d) as an arrow with a pair of inputs, and a pair of outputs
23:21:40 <Cale> Really, it's just an arrow with an input that's a pair, and an output that's a pair :)
23:23:00 <Cale> If f is an arrow computation from b to c, then first f is an arrow computation from (b,d) to (c,d) which applies the arrow f to the first part of the pair, and simply copies the second part through to the ouptut.
23:23:02 <Cale> output*
23:23:18 <mauke> sounds like mapFst
23:23:27 <Cale> basically.
23:23:37 <Cale> With the trivial arrow (->), we have
23:23:48 <Cale> > first (+10) (1,2)
23:23:49 <lambdabot>  (11,2)
23:23:57 <orbitz> dibblego: no i have note ven ehra dof it
23:24:08 <Cale> So it just applies the function to the first parameter
23:24:29 <Cale> but in general, you have an "arrow" which is sort of a generalised kind of "function"
23:24:32 <bos_> @pl \x->tail x == []
23:24:33 <lambdabot> ([] ==) . tail
23:24:44 <metaperl> oh I see... so "a" once again means an arrow of type a and then instead of just b and c, we have (b,d) and (c,d)
23:24:48 <Cale> yes
23:24:54 <sorear> bos_: null . tail
23:24:55 <Cale> that's what the class context says
23:24:57 <mauke> bos_: == [] better written as null
23:24:58 <Cale> @type first
23:24:59 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
23:25:02 <Cale> (Arrow a)
23:25:07 <bos_> thanks :-)
23:25:11 <Cale> means that a is an arrow, and should be interpreted like that
23:25:22 <bos_> i'm trying to remember as much of the standard prelude as i can, but it's hard.
23:25:34 <mauke> @hoogle [a] -> Bool
23:25:34 <lambdabot> Prelude.null :: [a] -> Bool
23:25:35 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
23:25:35 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
23:25:44 <Cale> There's a good reason to write ([] ==) as null -- the types
23:25:48 <Cale> @type ([] ==)
23:25:49 <dibblego> does the underscore in pattern matching have a specific name?
23:25:49 <lambdabot> forall a. (Eq [a]) => [a] -> Bool
23:25:53 <Cale> @type null
23:25:54 <lambdabot> forall a. [a] -> Bool
23:26:08 <Cale> dibblego: I call it the wildcard pattern
23:26:19 <dibblego> ah yes I've seen that thanks
23:26:34 <Cale> yeah, so does the report apparently :)
23:26:36 <mauke> black hole pattern maybe?
23:26:37 <bos_> @pl until (null . tail) tail
23:26:38 <lambdabot> until (null . tail) tail
23:26:54 <Cale> "black hole" already has a meaning
23:26:57 <metaperl> @type second
23:26:59 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
23:27:04 <Cale> so probably best not to tread on that :)
23:27:22 <metaperl> > second (+10) (4,5)
23:27:24 <lambdabot>  (4,15)
23:27:25 <mauke> what does black hole mean in the context of haskell?
23:27:45 <sorear> a thunk that has been entered
23:28:08 <sorear> when a thunk is entered twice, an error is signalled <loop>
23:28:14 <Cale> mauke: it's the value which the RTS replaces a thunk with once it's running. If the thunk is reentered, the program knows that it's in an infinite loop and stops immediately.
23:28:21 <sorear> a thunk that has been entered once is a blackhole
23:28:39 <sorear> > let x = x in x
23:28:40 <lambdabot>  Add a type signature
23:28:43 <bart-_-simpson> gmh33: no..
23:28:49 <sorear> > let x = x in x :: Int  -- blackhole!
23:28:50 <lambdabot>  Exception: <<loop>>
23:28:53 <mauke> ah
23:29:42 <mauke> IMHO it should just optimize it to sleep(~0u) :-)
23:29:46 <bos_> @pl \x->[x]
23:29:46 <lambdabot> return
23:29:47 <Cale> > let loop = loop + 1 in loop
23:29:48 <lambdabot>  Exception: <<loop>>
23:30:15 <mauke> (that's what ploki does)
23:30:37 <Cale> > let loop = foldr (+) loop [1,2,3] in loop
23:30:38 <lambdabot>  Exception: <<loop>>
23:30:57 <falconair> i'm trying to understand GADTs, given "data List a = Nil | Cons a (List a)", both Nil and Cons ... have the type "List a" (correct ?) .... how can either Nil or Cons return a different type then?
23:31:00 <Cale> > let loop = foldr (:) loop [1,2,3] in loop
23:31:01 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
23:31:29 <Cale> falconair: List isn't a GADT
23:31:34 <Cale> Nil :: List a
23:31:39 <Cale> Cons :: a -> List a -> List a
23:32:06 <Cale> to be a GADT, you'd need constructors which build only specific types of the structure
23:32:15 <Cale> for instance, you might add to that
23:32:23 <metaperl> @type proc
23:32:25 <lambdabot> Not in scope: `proc'
23:32:39 <Cale> IntEnding :: Int -> List Int
23:33:04 <Cale> which could only be used to build values of type List Int
23:33:10 <bos_> @pl \x y -> y
23:33:11 <lambdabot> const id
23:33:25 <Cale> (I admit, that's a stupid example)
23:33:32 <falconair> Cale, so GADTs would allow List a to be narrowed to List Int?
23:33:36 <Cale> metaperl: proc is syntax
23:33:42 <Cale> http://haskell.org/arrows/syntax.html
23:33:43 <lambdabot> Title: Arrow syntax
23:33:50 <metaperl> yes, I'm reading that
23:34:17 <Cale> falconair: yeah, they let you have constructors which construct values that only apply to particular types of the structure
23:34:49 <bos_> i have a question about the list monad.
23:34:54 <Cale> In a sense, this lets you hijack Haskell's type system in the parameters to your type constructor, because you can set the return type to whatever you like, regardless of the input types.
23:35:05 <Cale> For instance, you can have a constructor
23:35:15 <Cale> Pair :: a -> b -> MyType (a,b)
23:35:25 <bart-_-simpson> any one knows a good debugger (with breaks)??
23:35:31 <falconair> Cale: but it can't be a completely arbitrary return type, it can only narrow a given type?
23:35:32 <Cale> bos_: shoot
23:35:41 <bos_> i'm trying the first of the 99 haskell problems (return the last box in a list), which i would have thought was return $ last
23:35:46 <bos_> but that doesn't type check.
23:35:50 <Cale> falconair: or Pair :: a -> b -> MyType Int
23:35:58 <Cale> falconair: though that would be unusual :)
23:36:16 <mauke> return . last?
23:36:20 <bos_> er, return . last
23:36:33 <mauke> @type return . last
23:36:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m a
23:36:39 <falconair> Cale: i didn't get that, returning arbitrary type would be unusual?  (impossible?)
23:36:49 <Cale> bos_: you don't need the list monad for that
23:36:54 <Cale> it's just  last
23:36:56 <bos_> i know i don't need it :-)
23:37:14 <bos_> actually, myLast [1,2,3] => [3], not 3
23:37:16 <Cale> falconair: well, the specific example I gave was quite unusual
23:37:21 <mauke> return = (: [])
23:37:25 <glguy> Am I the only person that it bothers when people who don't know what they are talking about declare in their blogs what you can't do in Haskell? (like http://programming.reddit.com/info/wg31/comments/cwixk)
23:37:26 <lambdabot> Title: Evolution::Rails -> Ruby -> Haskell (reddit.com)
23:37:29 <Cale> falconair: note that this constructor "forgets" the types of its parameters
23:37:32 <glguy> Because if I'm being silly, I'll stop now
23:38:16 <Cale> falconair: GADTs extend existential types
23:38:22 <Cale> So you can do things like:
23:38:37 <Cale> Showable :: (Show a) => a -> MyType
23:38:47 <Cale> it forgets the specific 'a'
23:38:58 <Cale> but remembers that it belongs to the class Show
23:39:54 <metaperl> glguy - 404 error
23:40:02 <Cale> When you go to extract the value in a pattern match, the only available operations on it will be those in the class Show (and things built from those)
23:40:09 <glguy> metaperl: remove the trailing )
23:40:14 <Cale> falconair: does that make some vague kind of sense?
23:40:19 <Cale> try this:
23:40:26 <Cale> data Showable where
23:40:37 <Cale>   S :: (Show a) => a -> Showable
23:40:49 <Cale> instance Show Showable where
23:40:56 <Cale>    show (S x) = show x
23:41:07 <falconair> Cale: (I keep getting an emoticon between (Show a) and a -> Showable)
23:41:22 <Cale> = >
23:41:28 <Cale> does that emoticonize?
23:41:33 <falconair> no, i got that
23:41:37 <Cale> That's a class context arrow
23:41:50 <Cale> and you should probably turn off your emoticon thingy :)
23:41:55 <bart-_-simpson> any one knows a good debugger (with breaks)??
23:42:32 <Cale> bart-_-simpson: "debugger" means something fairly different in a pure lazy functional language.
23:42:45 <Cale> Stack traces are almost completely unhelpful
23:42:54 <Cale> You might try something like hat
23:43:19 <Cale> mostly I use ghci to find and remove bugs
23:43:53 <Cale> Functions are referentially transparent, so if they work in isolation, then they'll continue to work together.
23:43:58 <sorear> goodnight
23:45:00 <mr_tenor> a great thing about being pure functional seems to me to be the lack of debugging you do
23:45:20 <Cale> yeah, if there was more need for a debugger, we'd have plenty of them by now :)
23:45:51 <falconair> Cale: (emoticons gone), i read (part of) a paper that discusses GADTs using Java/C#'s generic types, according to what I've read so far, it sounds like GADTs are good for narrowing a generic type ... so an eval method doesn't need to return the type of the whole expression, and eval for an integer expression specifically returns an int ... is that a good way to think of it?
23:45:59 <glguy> solution to reddit bug for flip bind: =âª
23:46:15 <Cale> If you think about the fact that GHC has been developed without a debugger, that's pretty impressive coming from outside the Haskell world :)
23:46:39 <Cale> glguy: I usually just replace every < with the unicode character "precedes"
23:46:45 <bos_> @pl (:[]) . last
23:46:45 <lambdabot> return . last
23:46:58 <Cale> falconair: yeah, that's roughly the idea
23:46:59 <bos_> bah, lambdabot is pulling my leg.
23:47:26 <falconair> Cale, thanks, I'll continue reading that paper
23:47:33 <Cale> falconair: it's not just narrowing, but you really can stick in any type you want -- it's just that if you lose type variables, those types will get forgotten
23:47:45 <glguy> bos_: how do you mean?
23:47:51 <lisppaste2> metaperl pasted "complex arrow comprehension" at http://paste.lisp.org/display/33757
23:48:13 <Cale> That is, if you don't somehow include the type variables involved in parameters to the data constructor in the type parameters of the output.
23:48:15 <bos_> :type return . last
23:48:24 <bos_> @type return . last
23:48:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m a
23:48:42 <bos_> @type (:[]) . last
23:48:43 <lambdabot> forall a. [a] -> [a]
23:48:45 <glguy> > (return . last) [1,2,3] :: [Int]
23:48:46 <lambdabot>  [3]
23:48:47 <metaperl> @type first
23:48:49 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
23:48:50 <glguy> bos_: ^^
23:49:17 <bos_> glguy: i'm bamboozled by how to write a signature for that.
23:49:35 <Cale> metaperl: that expression is missing a ) just before the >>> on the first line, btw
23:49:37 <glguy> bos_: [a] is a monad in which return x = [x]
23:49:53 <bos_> yes.
23:49:53 <metaperl> Cale -you mean on the webpage? or my paste?
23:49:58 <Cale> metaperl: both
23:50:04 <metaperl> > first (+10)
23:50:05 <lambdabot>  Add a type signature
23:50:44 <glguy> bos_: return . last :: Monad m => [a] -> m a
23:51:04 <metaperl> Cale - then there is an extra parenthesis at the end...
23:51:10 <Cale> oh?
23:51:18 <metaperl> Cale - without adding one where you said, the whole expression balances
23:51:50 <Cale> oh, hmm, yeah, that's wrong
23:52:00 <metaperl> "that" being.... ? :)
23:52:05 <bos_> glguy: here's where i'm getting hung up.
23:52:11 <Cale> there's an extra ) at the end
23:52:21 <bos_> glguy: i don't understand why this needs a signature:
23:52:27 <Cale> so the correct version it
23:52:29 <bos_> myLast = return . last
23:52:30 <Cale> is*
23:52:41 <mauke> zomg monomorphism restriction
23:52:45 <bos_> or indeed what a correct signature would look like.
23:52:51 <glguy> bos_: it needs a signature so that it knows what Monad to use
23:53:01 <glguy> unless mauke is talking to you
23:53:04 <bos_> do i have to declare it over a Monad of a specific type?
23:53:05 <mauke> myLast x = return (last x)  -- fixed
23:53:13 <Cale> addA f g = arr (\x -> (x,x)) >>> first f >>> arr (\(x,y) -> (y,x)) >>> first g >>> arr (\(z,y) -> y + z)
23:54:07 <Cale> bos_: Haskell 98 has a stupid rule in it which forces you to include parameters or else type signatures for things which are polymorphic
23:54:37 <glguy> Cale: is that at all realated to CAFs?
23:54:45 <glguy> related*
23:54:53 <bos_> mauke, cale: thanks. the monomorphism restriction at least jogs my memory a bit :-)
23:55:09 <Cale> bos_: you can turn off the rule with -fno-monomorphism-restriction, but there are subtle reasons why you might want to keep it (it prevents you from writing accidentally polymorphic code that recomputes something over and over despite looking like it shouldn't)
23:55:29 <Cale> For example, if you write
23:55:36 <Cale> x = sum [1..100]
23:55:43 <Cale> then you'd expect x to be computed once
23:55:56 <Cale> but if you give it its most general type
23:56:05 <Cale> x :: Num a => a
23:56:21 <Cale> then you can maybe see the problem with that
23:56:32 <Cale> It might get used at various different types
23:56:36 <bos_> right.
23:56:51 <Cale> The way that Haskell translates this is by making x into a function of the typeclass dictionary
23:57:02 * glguy is glad to have this topic covered now... never quite grasped it before
23:57:08 <Cale> as a result, it will be recomputed every time it is used, unless you were to give it a monomorphic type
23:57:11 <metaperl> Ok, I repasted it: http://rafb.net/p/OKZMHz12.html  ... I do not know what the expression "first f" in the paste does... help needed
23:57:23 <bos_> Cale: thanks for the explanation.
23:57:23 <Cale> The MR just prevents that from happening accidentally.
23:57:28 <glguy> > first (*2) (4,4)
23:57:29 <lambdabot>  (8,4)
23:57:30 <mauke> can't it just memoize it?
23:57:34 <mauke> I mean, it has 0 args
23:57:56 <Cale> mauke: no, it has 1 arg after you make the typeclass translation
23:58:00 <glguy> but the value would be different for every type
23:58:05 <Cale> (namely, the dictionary for Num)
23:58:40 <dibblego> what if x is never used again except where it is of type Num a => a ?
23:58:44 <metaperl> glguy - yes I understand what first does. I takes 3 args a, b, c to represent a computation of type a from b to c... the problem is "first f" only has 1 arg
23:58:49 <mauke> still, it should be memoized
23:59:33 <dibblego> memoization is a trade-off, not an optimisation - the compiler can't do these things arbitrarily
23:59:35 <glguy> metaperl: that's because of the >>>s
23:59:37 <Cale> metaperl: I'll draw you a picture of exactly that arrow computation
23:59:55 <mauke> -fjust-do-it
