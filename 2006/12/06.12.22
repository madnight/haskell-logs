00:04:31 <bd_> @. elite karma /me
00:04:31 <lambdabot> /Me hAS a Kar/\/\4 0ph 0
00:04:49 <bd_> oic
00:05:22 * lambdabot cannot be so easily controlled!
00:06:23 <mgsloan> @. elite vixen hallo
00:06:23 <lambdabot> $+op 8eiNg RAci$+!
00:08:41 <pzpz> i'm trying to receive a message from a server as a client, however, it seems hGetContents is not working. The packet sniffer shows incoming data, yet a null string is always displayed.
00:09:34 <int-e> do you close the socket before using the result of hGetContents?
00:10:49 <pzpz> int-e: not that i'm aware of, not calling hClose at all.
00:12:40 <glguy> would it be acceptable to use unsafePerformIO in a quicksort implementation to randomly select the pivot if such an algorithm wasn' stable?
00:12:57 <glguy> and thus equal objects could be returned in different orders
00:13:33 <sorear> glguy: equal objects cannot be distinguished (I believe that is an Eq precondition)
00:13:43 <int-e> glguy: hmm. sounds impure to me.
00:13:56 <pzpz> my simple code : http://paste.lisp.org/display/33197
00:15:12 <pzpz> hGetContents doesn't block, does it?
00:15:32 <dobblego> http://programming.reddit.com 500 response?
00:15:35 <lambdabot> Title: reddit.com: programming - what&#39;s new online
00:15:35 <int-e> you used Data.ByteString. I guess it does.
00:15:53 <glguy> dobblego: works for me
00:16:03 <int-e> Data.Bytestring.Lazy might be better
00:16:07 <dobblego> yeah just started working for me too
00:16:27 <pzpz> int-e: i tried receiving into a regular [Char] as well, to no avail.
00:20:10 <int-e> pzpz: then I'm as confused as you are. :/
00:21:07 <mgsloan> reddit is broken for me
00:21:50 <dobblego> > 21 / 36
00:21:51 <lambdabot>  0.5833333333333334
00:22:05 <mgsloan> > 21 % 36
00:22:06 <lambdabot>  7%12
00:22:13 <calvins> good evening all! a quick question about my favorite topic, monads ;)
00:22:31 <glguy> we recommend ContT
00:22:38 <calvins> I want to do something like the following:
00:22:41 <calvins> [n | n <- names, doesFileExist n]
00:22:54 <int-e> filterM
00:23:00 <calvins> But doesFileExist is IO Bool instead of Bool
00:23:10 <glguy> :t filterM
00:23:10 <sorear> :t filterM
00:23:11 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
00:23:12 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
00:23:13 <calvins> ah, thanks, will look at filterM
00:23:27 <calvins> oh perfect. thanks..
00:23:31 <pzpz> developing in windows is a pain. how do i pass a
00:23:43 <glguy> kidney stone?
00:23:48 <sorear> lol
00:23:51 <pzpz> err, ctrl+c (SIGHALT?) to a cmd term
00:23:55 <glguy> F6
00:24:02 <glguy> or Control+Z
00:24:07 <glguy> typically followed by an enter
00:24:13 <glguy> OHH
00:24:14 <glguy> sorry
00:24:17 <glguy> that's ^D
00:24:18 <pjd> is there any way to reconcile that list comprehension syntax with the IO monad?
00:24:29 <pzpz> nope :(
00:24:40 <glguy> not since they dumbed down monad comprehensions
00:24:54 <pjd> how do monad comprehensions look?
00:25:02 <pjd> i keep hearing about them :)
00:25:04 <glguy> pjd: like list comprehensions
00:25:05 <sorear> same as list comprehensions
00:25:16 <int-e> glguy: in which monad would you work then?
00:25:17 <sorear> except they don't exist anymore
00:25:33 <glguy> int-e: both, and concat the results, I would think
00:25:37 <pjd> sorear: so they look the same just work with monads?
00:25:43 <sorear> someone had the bright idea of deleteing them 'to protect newbies'
00:25:44 <pjd> "same, but", even
00:26:01 <sorear> I support you would work in ListT IO
00:26:13 <glguy> ListT?
00:26:25 <sorear> :k ListT
00:26:26 <lambdabot> Not in scope: type constructor or class `ListT'
00:26:51 <sorear> ah, Control.Monad.List
00:27:02 <glguy> int-e: I would think you could nest, sequence, and concatenate
00:27:40 <int-e> glguy: I don't think monad comprehensions did that. maybe you meant something different.
00:28:00 <glguy> int-e: I'm just thinking of them as pretty do-notation
00:29:31 <sorear> [ fn a | a <- foo, b ] <--> do a <- foo ; guard b ; return a
00:29:47 <pzpz> hmm, connectTo i assume establishes a TCP connection. what would occur if a packet with a MSNMS header came flying in?
00:29:50 <pzpz> would it be ignored?
00:30:20 <augustss> that's right, monad comprehensions were just different syntax for do
00:30:29 <glguy> filterM p (x:xs) = [if flg then x:ys else ys | flg <- p x, ys <- filterM p xs] -- for starters
00:30:36 <sorear> pzpz: what's a msnms header?
00:31:38 <pzpz> sorear: well, a ip packet with a protoid of msnms
00:32:03 <pzpz> wth.. ignore me.
00:32:22 <sorear> wouldn't it just be ignored?  I thought the TCP stack only listened for TCP packets?
00:33:00 <int-e> pzpz: it'll ignore that.
00:40:45 <sorear> "let's see whats in these state files... ooh, $ cat State/seen;  <CHIRP> <BUZZ> <FLASH> Login:"
00:41:27 <metaperl> @hoogle a -> [a]
00:41:28 <lambdabot> Prelude.repeat :: a -> [a]
00:41:28 <lambdabot> List.intersperse :: a -> [a] -> [a]
00:41:28 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
00:44:26 <araujo> :-)
00:46:19 <sorear> (-:
00:47:44 <goltrpoat> i asked this a while ago.. is there a name for the set of possible functions with a given type?  eg, in the case of a -> [a], is there a name for the family of functions \x -> map (const x) [1..] and \x -> map (const x) [1..n] for all n in Num and Enum?
00:49:27 <sorear> categorically, I believe a type is identified with the set of values, so that set iirc is called '\-/ a. a -> [a]'
00:49:38 <ski_> couldn't you use 'replicate' ?
00:50:02 <sorear> why?  they're all equivalent (to naturals + oo)
00:50:26 <goltrpoat> right, but i thought there might be a more specific name for it
00:51:17 <goltrpoat> ski:  replicate is more strict, typewise, than \n x -> map (const x) [1..n]
00:51:32 <goltrpoat> :t replicate
00:51:33 <lambdabot> forall a. Int -> a -> [a]
00:51:38 <goltrpoat> :t \n x -> map (const x) [1..n]
00:51:40 <lambdabot> forall a a1. (Num a, Enum a) => a -> a1 -> [a1]
00:52:07 <goltrpoat> actually.. i guess that doesn't matter, since n is a constant
00:52:16 <goltrpoat> either way. :)
00:52:28 <ski_> :t \n x -> replicate (toEnum n - toEnum 1 + 1) x
00:52:29 <lambdabot> forall a. Int -> a -> [a]
00:52:35 <sorear> does it make a difference?  your functions surject any type in Num+Enum onto the naturals before tdoing anything else...
00:52:51 <goltrpoat> yeah, i kind of typed before thinking there
00:52:54 <ski_> :t \n x -> replicate (fromEnum n - fromEnum 1 + 1) x
00:52:56 <lambdabot> forall a a1. (Enum a) => a -> a1 -> [a1]
00:53:25 <ski_> > (\n x -> replicate (fromEnum n - fromEnum 1 + 1) x) (4 :: Integer) 'a'
00:53:27 <lambdabot>  "aaaa"
00:54:25 <ski_> :t \n x -> replicate (fromEnum n - fromEnum (1 `asTypeOf` n) + 1) x
00:54:26 <lambdabot> forall a a1. (Enum a, Num a) => a -> a1 -> [a1]
00:54:38 <ski_> :t \n x -> map (const x) [1..n]
00:54:40 <lambdabot> forall a a1. (Num a, Enum a) => a -> a1 -> [a1]
01:32:00 <trh> Hello, anyone willing to help me with some Monad transformer woes?  I've been struggling all day...
01:36:24 <lisppaste2> trh pasted "StateT woes" at http://paste.lisp.org/display/33201
01:38:42 <lisppaste2> trh annotated #33201 with "descr..." at http://paste.lisp.org/display/33201#1
01:40:01 <Lemmih> trh: Are you familiar with the do-notation?
01:40:19 <_abz_> trh: explain a little more please?
01:40:35 <lisppaste2> Lemmih annotated #33201 with "working StateT" at http://paste.lisp.org/display/33201#2
01:41:14 <trh> I was avoiding 'do' to get more readable errors from ghc...
01:41:55 <_abz_> and, then what happened....?
01:42:01 <trh> Did you try compiling that annotation?  I think that's what my first attempt was and it doesn't work..?
01:42:03 <Lemmih> trh: Don't do that.
01:42:16 <trh> Why not?
01:42:47 <Lemmih> trh: Because you won't get better error messages by avoiding the do-notation.
01:43:02 <Lemmih> In fact, your problem was caused by doing so.
01:43:21 <goltrpoat> the only problem was that lift $ getStdRandom (randomR (1, 2)) should have parens around it
01:43:25 <trh> AAAAARRRRRGGGHHH!
01:44:04 <trh> Thanks... it was a stinking formatting error all day?  I was putting the dos that you have there on the one line separated by semi-colons.
01:46:18 <trh> Hrmm, no it wasn't.  The key is lifting r.  Which I thought I'd tried.
01:46:26 <trh> Thanks, anyway. :)
01:47:15 <goltrpoat> :t \a b -> lift $ a >>= b
01:47:17 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a b. (MonadTrans t, Monad m) => m a -> (a -> m b) -> t m b
01:47:19 <goltrpoat> :t \a b -> (lift a) >>= b
01:47:21 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a b. (Monad (t m), MonadTrans t, Monad m) => m a -> (a -> t m b) -> t m b
01:47:25 <goltrpoat> :)
01:47:46 <trh> Oh dear.
01:49:04 <dons> mmm fun kinds for all
01:49:25 <dons> too many kind annotations for trh?
01:49:58 <dons> ?users
01:49:59 <lambdabot> Maximum users seen in #haskell: 309, currently: 262 (84.8%), active: 28 (10.7%)
01:50:16 <mwc> @hoogle execState
01:50:16 <lambdabot> Control.Monad.State.execState :: State s a -> s -> s
01:50:17 <lambdabot> Control.Monad.State.execStateT :: Monad m => StateT s m a -> s -> m s
01:59:14 <mgsloan> > do foo <- newIORef (0,"bar"); (_,txt) <- readIORef foo; return txt
01:59:14 <lambdabot>  Not in scope: `readIORef'
01:59:37 <mgsloan> > do foo <- Data.IORef.newIORef (0,"bar"); (_,txt) <- Data.IORef.readIORef foo; return txt
01:59:37 <lambdabot>  Not in scope: `Data.IORef.readIORef'
02:00:20 <mgsloan> > do foo <- (0, "bar"); (_,txt) <- foo; return foo
02:00:21 <lambdabot>  Couldn't match `(,) a' against `[]'
02:00:56 <dobblego> reddit is *still* broken
02:01:29 <mgsloan> > do foo <- (0, "bar"); let (_,txt) = foo; return txt
02:01:29 <lambdabot>  Parse error
02:01:42 <mgsloan> > do foo <- (0, "bar"); let (_,txt) <- foo; return txt
02:01:42 <lambdabot>  Parse error
02:02:57 <trh> How long has it been down?  Last time I tried was about 9 hours ago.
03:04:59 <ski> > do foo <- (0, "bar"); let {(_,txt) = foo}; return txt
03:11:02 <ski> @arr
03:12:53 <ski> dons : lambdabot's sleeping again
03:15:42 <lambdabot>  Couldn't match `(a, b)' against `[Char]'
03:16:25 <lambdabot> Shiver me timbers!
03:17:16 <ski> @vixen ah, there you are
03:17:18 <lambdabot> ain't it just like a man?
03:17:18 <sieni> @arr
03:17:19 <lambdabot> Smartly me lass
03:17:21 <sieni> @arr
03:17:22 <lambdabot> Aye
03:35:46 * therp wonders if he should install darcsweb for his repo
03:38:28 <Adamant> @(elite . arr)
03:38:29 <lambdabot> . 4Rr)
03:49:16 <Saizan> @. elite arr
03:49:17 <lambdabot> I \/\/ANT /\/\e gro9!
03:54:32 <opqdonut> @elite
03:54:33 <lambdabot> Say again?
03:54:35 <opqdonut> @elite foo
03:54:36 <lambdabot> f0o
03:54:41 <opqdonut> :)
03:54:50 <opqdonut> @elite elite
03:54:51 <lambdabot> 1337
03:54:53 <opqdonut> hehe
04:06:36 <dons> ?bot
04:06:37 <lambdabot> :)
04:06:40 <dons> ?uptime
04:06:41 <lambdabot> uptime: 11h 26m 50s, longest uptime: 9d 2h 23m 6s
04:10:50 <pjd> @. elite uptime
04:10:50 <lambdabot> uP7imE: 11H 30M 59$, lON9ez7 UpTimE: 9d 2|-| 23M 65
04:13:03 <ski> @. elite seen
04:13:03 <lambdabot> 1a+E1y, i H4\/E zE3N 4YRnI3U, B0EgEl, 8R0qu4in7, d0nS, pJD, S(|-|\/\/ERn AND zki.
04:13:36 <pjd> @. elite elite
04:13:36 <lambdabot> z4Y ag4in?
04:13:43 <pjd> heh
04:14:43 <ski> @. elite type Contrl.Monad.ST.runST
04:14:44 <lambdabot> (oULdN'+ fIND QUA|IFIED M0du1e.
04:14:49 <ski> @. elite type Control.Monad.ST.runST
04:14:50 <lambdabot> FOR4ll a. (f0R4LL z. 9|-|(.ST.s7 $ A) -> A
04:16:30 <earthy> @. elite @. eilte
04:16:31 <lambdabot> compose module failed: IRCRaised Parse error: "@."
04:16:57 <earthy> this is quite bad
04:17:18 <ski> @. elite . elite
04:17:18 <lambdabot> N0t 3n0U9|-| arGUmen+z0rz 70 @.
04:17:25 <ski> @. elite . elite arr
04:17:26 <lambdabot> 4H0Y /\/\4Tey5
04:17:31 <earthy> @. elite . elite elite
04:17:31 <lambdabot> sAy 4G4IN?
04:17:59 <earthy> @. elite . elite yow
04:17:59 <lambdabot> re/\/\e/\/\8ER, iN 2039, MoUss3 & PA$T4 \/\/ILL 8E 4V4I|a8L3 0nly 8Y pr3$(riP7ION!!
04:18:52 <earthy> @. type . pl \x y z -> z
04:18:53 <lambdabot> compose module failed: IRCRaised Parse error: "\\x"
04:19:02 <earthy> @. type  pl \x y z -> z
04:19:03 <lambdabot> compose module failed: IRCRaised Parse error: ""
04:19:06 <earthy> ?!
04:19:06 <lambdabot> Maybe you meant: . v
04:19:15 <earthy> oh well ;)
04:25:39 <ski> @. type pl \x y z -> z
04:25:41 <lambdabot> forall b a b1. b1 -> b -> a -> a
04:26:03 <ski> apparently should be exactly one space
04:26:41 <ski> @. djinn . type pl \x y z -> z
04:26:43 <lambdabot> f _ _ a = a
04:29:08 <opqdonut> @. djinn . type pl \x -> Just x
04:29:10 <lambdabot> f = Just
04:29:31 <opqdonut> @. djinn . type round
04:29:32 <lambdabot> compose module failed: IRCRaised Parse error: "round"
04:29:47 <opqdonut> @. djinn . type floor
04:29:48 <lambdabot> compose module failed: IRCRaised Parse error: "floor"
04:29:58 <opqdonut> @ djinn . type floor
04:30:07 <ski> netiher 'round' nor 'floor' are lambdabot commands
04:30:15 <opqdonut> yeah i realised
04:30:26 <opqdonut> @. djinn . type pl \x -> floor x
04:30:27 <lambdabot> Cannot parse command
04:30:35 <opqdonut> np
04:30:47 <opqdonut> @djinn (RealFrac a, Integral b) => a -> b
04:30:48 <lambdabot> Cannot parse command
04:30:53 <opqdonut> @djinn a -> b
04:30:53 <lambdabot> -- f cannot be realized.
04:30:56 <opqdonut> yep
04:31:21 <ski> @djinn (Not a,Not b) -> Not (Either a b)
04:31:21 <lambdabot> f (a, b) c =
04:31:21 <lambdabot>   case c of
04:31:21 <lambdabot>   Left d -> a d
04:31:21 <lambdabot>   Right e -> b e
04:34:15 <opqdonut> Not?
04:34:26 <opqdonut> @type Not
04:34:27 <lambdabot> Not in scope: data constructor `Not'
04:36:03 <ski> @djinn-env
04:36:03 <lambdabot> data () = ()
04:36:04 <lambdabot> data Either a b = Left a | Right b
04:36:04 <lambdabot> data Maybe a = Nothing | Just a
04:36:04 <lambdabot> data Bool = False | True
04:36:04 <lambdabot> data Void
04:36:05 <lambdabot> type Not x = x -> Void
04:36:14 <ski> ^^
04:43:34 <aes2> A question from TAOCP: Prove that 13^3=2197. Generalize this result. Solving the first part entails unfolding the definition for exponentiation into multiplications, summations and eventually to some formal system encoding numbers, like Peano's. What's meant by the second part of the question?
04:58:07 <pjd> aes2: have you heard of Peano numbers before?
04:58:25 <opqdonut> church integers!
04:58:32 <dylan> @quote peano
04:58:33 <lambdabot> peano hasn't said anything memorable
04:58:39 <dylan> @quote dylan
04:58:39 <lambdabot>  I run emacs for the games
04:58:45 <sieni> when has any church shown any integrity?!?!
04:58:47 <dylan> bah.
04:59:00 <opqdonut> sieni: thanks for the pun
04:59:07 <pjd> aes2: check out http://en.wikipedia.org/wiki/Peano_axioms
04:59:09 <lambdabot> Title: Peano axioms - Wikipedia, the free encyclopedia
04:59:16 <aes2> pjd: yes, I have
04:59:21 <pjd> oh, ok
04:59:39 <pjd> so can you narrow down your question? :)
04:59:51 <opqdonut> aes2: generalizing the result probably means devising a generic algorithm for proving x^y=<
04:59:56 <opqdonut> s/</z/
05:00:17 <aes2> opqdonut: ok, that's what I already did.
05:37:57 <therp> anyone familiar with the internals of the GHC type checking process? At which particular point are bindings from the local type check environment TcLclEnv moved to TcGblEnv? It looks like I'm unable to identify the respective code parts in typechecking/TcRnDriver.lhs. The only thing that uses the local environment produces by tc_rn_src_decls is in fetching inst_binds, but that has nothing to do with valbindings
05:40:11 <therp> is it possible that the commentary statment is wrong with respect to TcLclEnv, and that actually local bindings are also "born" in the TcGblEnv?
05:40:25 <__alex_br> http://research.ihost.com/hopl/
05:40:26 <lambdabot> Title: History of Programming Languages Conference (HOPL-III)
05:54:52 <dylan> metaperl: hey, you're in tampa?
06:31:05 <matthew__> ok, should I actually find that implementing hindley-milner in haskell for the lambda calc is hard?
06:31:15 <matthew__> I'm finding it really quite fidley
06:33:54 <augustss> it's always tricky the first few times :)
06:35:03 <syntaxfree> why is ev : f -> (a -> f(a)) = f  an eta-reduction?
06:38:24 <Philippa> yeah, regardless of language :-)
06:38:59 <Philippa> matthew__: you may or may not find that the ST monad or something similar (State (Map Variable Type), say) helps...
06:39:21 <Philippa> oh, and you may have problems if your lambda calc doesn't have let ;-)
07:02:57 <SamB_XP> what is riot?
07:04:01 <syntaxfree> @all-dict riot
07:04:03 <lambdabot> *** "Riot" gcide "The Collaborative International Dictionary of English v.0.48"
07:04:04 <lambdabot> Riot \Ri"ot\, v. i. [imp. & p. p. {Rioted}; p. pr. & vb. n.
07:04:04 <lambdabot>   {Rioting}.] [OF. rioter; cf. OD. ravotten.]
07:04:04 <lambdabot>   1. To engage in riot; to act in an unrestrained or wanton
07:04:04 <lambdabot>    manner; to indulge in excess of luxury, feasting, or the
07:04:05 <lambdabot> [165 @more lines]
07:04:20 <SamB_XP> I was given to understand that it was somehow related to yi and hmp3?
07:04:26 <syntaxfree> @more
07:04:27 <lambdabot>    like; to revel; to run riot; to go to excess.
07:04:27 <lambdabot>    [1913 Webster]
07:04:27 <lambdabot>  
07:04:27 <lambdabot>       Now he exact of all, wastes in delight,
07:04:27 <lambdabot>       Riots in pleasure, and neglects the law. --Daniel.
07:04:28 <lambdabot> [160 @more lines]
07:04:36 <syntaxfree> well, yi is a riot ;)
07:07:06 <Lemmih> @google tuomov riot
07:07:09 <lambdabot> http://modeemi.fi/~tuomov/riot/
07:07:09 <lambdabot> Title: Riot
07:07:13 <Lemmih> @seen tuomov
07:07:13 <lambdabot> I saw tuomov leaving #darcs 2m 11d 20h 58m 49s ago, and .
07:07:45 <opqdonut> tuomov can be reached on #ion
07:07:52 <syntaxfree> tuomov is the author of ion3.
07:08:05 <syntaxfree> cool. tuomov is learning Haskell.
07:08:44 <opqdonut> syntaxfree: riot is ages old
07:09:39 <Lemmih> Yeah, he learned Haskell and then left us *sob*
07:09:41 <dylan> riot looks interesting.
07:09:46 <metaperl> > tails [6,5,4,3]
07:09:53 <lambdabot>  [[6,5,4,3],[5,4,3],[4,3],[3],[]]
07:10:08 <metaperl> > tails [5,4,3]
07:10:09 <lambdabot>  [[5,4,3],[4,3],[3],[]]
07:10:11 <dylan> tuomov knows haskell and still writes ion3 in a mix of lua and C??
07:10:28 <opqdonut> dylan: errr why not?
07:10:32 <syntaxfree> Lua was invented at the place I went to school.
07:10:36 <opqdonut> it's 200kloc iirc
07:10:46 <opqdonut> porting to haskell would be a pain
07:10:49 <metaperl> > tails [6,5,4]
07:10:50 <lambdabot>  [[6,5,4],[5,4],[4],[]]
07:10:56 <opqdonut> + he'd have to make proper xlib binds etc
07:10:58 <dylan> opqdonut: jeese, that's huge.
07:11:03 <opqdonut> and lua is a very nice extension language
07:11:04 <syntaxfree> ion3 is so minimal.
07:11:23 <dylan> ion3 is a bit too confusing for me, that's why I switched to dwm. :)
07:11:27 <syntaxfree> "Lua" means "moon" in portuguese.
07:11:31 * SamB_XP wonders if darcs couldn't support locales for terminal I/O
07:11:33 <opqdonut>  166890 total
07:11:33 <syntaxfree> dwm?
07:11:43 <opqdonut> that's for ion3 and libextl
07:11:57 <opqdonut> dylan: dwm is a bit too constricting
07:12:00 <opqdonut> but yes, a nice wm
07:12:06 * syntaxfree thinks ion3 can probably be written in like, 15 lines of Haskell.
07:12:17 <dylan> opqdonut: it is, but it forces me to not fiddle with windows and be productive.
07:12:21 <Lemmih> How many in here are using ion?
07:12:29 <metaperl> > tails []
07:12:30 <lambdabot>  Add a type signature
07:12:33 * syntaxfree uses OS X, but used ion back in the Linux days.
07:12:49 <metaperl> syntaxfree - are you SyntaxNinja?
07:12:54 <syntaxfree> nope.
07:12:57 <syntaxfree> I'm syntaxfree.
07:13:00 <dylan> ion3 is shaping up to be better, I think it's simpler in the latest release.
07:13:01 <metaperl> :)
07:13:04 <syntaxfree> @quote SyntaxNinja
07:13:05 <lambdabot>  Let's imagine something that would be awesome.
07:13:07 <opqdonut> syntaxfree: doubt it
07:13:29 <opqdonut> syntaxfree: the 15l of haskell thing, that is
07:13:32 <syntaxfree> @quote SyntaxNinja
07:13:33 <lambdabot>  Let's imagine something that would be awesome.
07:13:39 <syntaxfree> @quote syntaxfree
07:13:40 <lambdabot>  one could use the euro symbol for left-associative $.
07:13:43 <opqdonut> xlib interfacing and ewmh are a mess, ask tuomov
07:14:26 <syntaxfree> I think tuomov won't talk to me after a debate about capitalism on #gentoo, many years ago.
07:17:30 <opqdonut> :D
07:17:33 <opqdonut> sounds familiar
07:18:26 <dylan> ion3 with tagging would probably win me over.
07:18:37 <dylan> I really like its query interface.
07:18:43 <dylan> (for f3, f4, etc)
07:19:30 <opqdonut> yeah, that's nice
07:19:41 <opqdonut> did you know that nowadays even the menus are queries
07:32:10 <dylan> heh, cool.
07:32:27 <opqdonut> yep
07:32:38 <opqdonut> heh, i think i'm inclined to try dwm again :)
07:32:41 <dylan> I've found dmenu is almost as good.
07:33:00 <dylan> (I've had to patch both dwm and dmenu to display things on the bottom, though)
07:39:52 <pjd> categorically, would it be fair to characterize a monomorphism is an "undoable morphism" ?
07:48:38 <thetallguy> if by undoable, you mean invertible, then I think the answer is yes.
07:51:10 <pjd> thetallguy: yeah, that's what i mean
07:53:02 <thetallguy> actually, I think it would be better to say invertible homomorphism.
07:53:13 * dylan giggles
07:53:34 <thetallguy> a morphism is just a mapping, with no particular structure implied.
07:53:52 <thetallguy> whereas a homomorphism preserves structure to some degree.
07:55:49 <thetallguy> Specifically, if you have an operation on a set, a homomorphism is a mapping to another set that preserves that operation.
08:02:35 <opqdonut> dylan: oh, dmw is at v 2.7 already
08:02:40 <opqdonut> last time i tried it was 1.5
08:03:28 <dylan> opqdonut: it is very fast-paced
08:03:52 <opqdonut> yeah, makes sense
08:03:59 <opqdonut> personal projects tend to be in the beginning
08:04:00 <dylan> opqdonut: if you want the status bar, and title bars, and dmenu, on the bottom, let me know. I maintain a darcs repository that tracks dwm development.
08:04:09 <opqdonut> oooh, nice
08:05:09 <dylan> http://odin.hardison.net/darcs/x11/dwm, and http://odin.hardison.net/darcs/x11/dmenu
08:05:10 <lambdabot> Title: Index of /darcs/x11/dwm
08:05:27 <dylan> I've been given permision to post my patches to the dwm wiki-thing, but I've not gotten around to it.
08:09:34 <opqdonut> dylan: feature-wise it's still much the same...
08:10:12 <dylan> yeah.
08:10:24 <dylan> it's not for everyone
08:10:30 <dylan> but ion has too many forms of movement.
08:10:36 <dylan> (for me)
08:11:13 <syntaxfree> dwm is like ion?
08:11:40 <glguy> I like dwm when I'm not doing much with my computer, say just using it for IRC and xterm , maybe some haskell coding
08:11:54 <dylan> glguy: I'm the opposite
08:11:57 <glguy> but I don't like using it when I've got a ton of stuff open
08:12:04 <dylan> if I'm not doing much, the wm doesn't matter
08:12:16 * syntaxfree pines for some window auto-resizing on OS X.
08:12:17 <dylan> but for > 3 windows, say, 13, dwm is nice.
08:12:29 <syntaxfree> Everything is fine, but I'm doing manual window management.
08:12:30 <Nafai> syntaxfree: auto-resizing?
08:12:38 <syntaxfree> Like in ion.
08:12:50 <glguy> tiling?
08:13:02 <Nafai> I haven't used ion, so I'm unfamiliar with what you are referring to
08:13:08 <arcatan> wmii \o/
08:13:16 <syntaxfree> yes! OS X doesn't even have auto-tiling/auto-cascading like Windows!
08:13:20 <glguy> wmii was neat too
08:13:41 <glguy> syntaxfree: I believe that was a conscious choice
08:13:48 <glguy> similar to not supporting a "maximize"
08:13:50 <syntaxfree> wmii is a window manager for the nintendo wii?
08:14:02 <glguy> wmii is a window manager similar to dwm
08:14:08 <glguy> highly scriptable
08:14:12 <syntaxfree> glguy: I appreciate the OS X-type maximize.
08:14:20 <syntaxfree> It's very clever. It puts windows on the "correct" size.
08:14:37 <glguy> syntaxfree: it is as clever as each app mkes it
08:14:38 <glguy> makes*
08:14:45 <opqdonut> dylan: i like the staticness of ion's layout
08:14:47 <glguy> some apps don't have it set up quite right
08:14:53 <opqdonut> as compared to wmii and dwm
08:15:01 <dylan> opqdonut: ah, that's the difference, then.
08:15:18 <glguy> staticness of ion's layout?
08:15:19 <opqdonut> dylan: and i think that ion is better for many clients and dwm nice for a few :)
08:15:21 <dylan> I like the dynamic nature of dwm, because I don't want to mess with windows.
08:15:27 <opqdonut> glguy: as in it isn't dynamic
08:15:39 <opqdonut> glguy: as in things don't change place unless i tell them to
08:15:48 <glguy> opqdonut: but they do in dwm?
08:15:51 <dylan> opqdonut: I've not found any problems, but really I just run urxvt and firefox
08:15:54 <opqdonut> dylan: me neither, i've a frame setup and i don't change it
08:16:01 <syntaxfree> glguy: OS X apps tend to be *very* clever.
08:16:06 <opqdonut> dylan: opera,aterm,emacs here
08:16:08 <metaperl> what is all this dwm and ion3 talk?
08:16:13 <metaperl> what are they?
08:16:16 <opqdonut> metaperl: window managers
08:16:17 <opqdonut> for X
08:16:22 <syntaxfree> glguy: if I just pined after X11, I could run X11 headless and ion.
08:16:22 <metaperl> it's been going on all morning :)
08:16:25 <dylan> metaperl: hey, you live in Tampa?
08:16:26 <syntaxfree> I wish I had ion for OS X apps, though.
08:16:30 <metaperl> dylan - yes you?
08:16:38 <dylan> metaperl: ever heard of SLUG? :)
08:16:40 <syntaxfree> er, ion for Aqua/Quartz.
08:16:44 <metaperl> dylan - no
08:16:55 <dylan> metaperl: or tampa bay perl mongers?
08:17:00 <metaperl> dylan - no
08:17:01 <earthy> hm. ion for aqua/quartz.
08:17:05 <opqdonut> hehe
08:17:10 <earthy> that'd quickly be painful
08:17:13 <glguy> I like my OS X window manager
08:17:24 <glguy> on the laptop, things can get clutter easily, however
08:17:35 <dylan> metaperl: heh. Well, I'm a member of the former and used to be a member of the later until they stopped meeting.
08:17:36 <earthy> glguy: that's why I use Spirited Away
08:17:36 <opqdonut> dylan: i have a huge res (1920x1200) and dwm seems to waste it somehow :)
08:17:45 <opqdonut> but i guess i could get used to dwm
08:17:55 <opqdonut> can't bother switching from ion tho
08:18:03 <metaperl> dylan - my email is metaperl@gmail.com - where do you live?
08:18:04 <glguy> I liked dwm for small monitors, uses more of the space available
08:18:20 <opqdonut> ratpoison for really small monitors :)
08:18:21 <dylan> metaperl: Seminole -- near St. Petersburg.
08:18:49 <c01pb> the philosophy behind dwm seem nice
08:19:05 <opqdonut> agh
08:19:07 <glguy> c01pb: newbs can stfu? that philosophy?
08:19:07 <opqdonut> ctcp spam
08:19:27 <dylan> sorry, I was curious
08:19:31 <dylan> lots of xchat. :)
08:19:32 <c01pb> the "doing what's right for me"
08:19:41 <syntaxfree> was ion the first multi-window ratpoison-like wm?
08:19:50 <opqdonut> syntaxfree: no, i think larswm was
08:20:00 <opqdonut> and ratpoison had splits before ion i think
08:20:14 <opqdonut> dylan: is there a keyboard resize/move in dwm?
08:20:25 <glguy> opqdonut: kind of :)
08:20:29 <syntaxfree> ratpoison has splits?
08:20:33 <opqdonut> syntaxfree: yea
08:20:35 <dylan> opqdonut: you can resize the main area with meta-g and meta-s
08:20:38 <glguy> dwm has a main window, and side windows
08:20:39 <dylan> but otherwise no.
08:20:43 <opqdonut> bah
08:20:47 <opqdonut> ion's resize mode rules
08:21:08 <metaperl> dylan - do you get private messages?
08:21:09 <syntaxfree> yeah. ion has drag-and-drop resizing.
08:21:14 <syntaxfree> very simple to do.
08:21:17 <metaperl> dylan - i am trying to talk to you private
08:21:29 <earthy> metaperl: are you registered with nickserv?
08:21:30 <glguy> I always add the path in dwm to make arbitrary windows floating while they are running
08:21:44 <syntaxfree> the info OS X apps have for the smart-mazimize could be very useful for ion-like window management.,
08:21:45 <earthy> (if you aren't, privmsg's from you are blocked)
08:21:51 <glguy> metaperl: just say it here, we won't look
08:22:01 <opqdonut> hmm, how can i tell wether a client in dwm is in float mode or not
08:22:08 <opqdonut> (i messed up my layout bigtime)
08:22:24 <glguy> opqdonut: can you move it with your mouse?
08:22:27 <alex_br> syntaxfree, are you brazilian?
08:22:36 <syntaxfree> yes. why?
08:22:40 <opqdonut> glguy: dwm uses too much mouse, it seems ;)
08:22:52 <glguy> opqdonut: only for floating windows
08:23:04 <glguy> opqdonut: but granted that ion3 has more keyboard shortcuts
08:23:09 <tautologico> this channel got so big, there at least 3 brazilians here :)
08:23:13 <glguy> opqdonut: but it's really easy to add functionality to dwm
08:23:20 <ventonegro> syntaxfree, because i'm too
08:23:22 <syntaxfree> I've been here for ages.
08:23:33 * syntaxfree is the first brazilian on #haskell!
08:23:40 * syntaxfree crowns himself the First Brazilian.
08:23:45 <earthy> you sure?
08:23:48 * earthy is brazilian as well
08:23:54 <glguy> a brazilian seems liek a lot
08:23:55 <syntaxfree> oh shit. Then not.
08:23:56 <tautologico> well, at least 4 then
08:24:07 <ventonegro> hehehe
08:24:16 <syntaxfree> earthy is a brazilian. surprising.
08:24:17 <ventonegro> syntaxfree, you got the silver medal
08:24:22 <tautologico> I used to get here at least 2 years ago, but I was never regular
08:24:25 <ventonegro> earthy, where from?
08:24:25 <syntaxfree> ventonegro: I thought you said you were italian.
08:24:26 <earthy> then again, I haven't lived in brasil for 24 years
08:24:31 <opqdonut> glguy: if i were to use dwm, i'd make a patch for showing a client's mode in the status bar and for proper kbd move and resize
08:24:36 <ventonegro> syntaxfree, me? no, i didn't
08:24:42 <opqdonut> glguy: and the docs could be nicer
08:24:43 <syntaxfree> we have enough people for a HUG group. Not for a group hug, though.
08:24:47 <earthy> ventonegro: sou da Holambra II
08:24:57 <ventonegro> earthy, onde é isso?
08:24:58 <syntaxfree> Holambra?
08:24:58 <earthy> (is that even right? :))
08:25:02 <opqdonut> :D
08:25:31 <glguy> opqdonut: docs are for noobs, read teh source!
08:25:41 <tautologico> tem uma holambra em sao paulo, estado
08:25:48 <earthy> little village next to Paranapanema, some 50km from Avaré, roughly 200km west from Sao Paulo city.
08:25:49 <glguy> opqdonut: a lack of documentation, and requiring you to edit C is part of the "non-leet filter"
08:25:57 <ventonegro> syntaxfree, and you?
08:26:19 <earthy> tautologico: 2 in fact. one is to the northwest of Sao Paulo city, 1 directly to the west
08:26:25 <syntaxfree> I'm from the big city.
08:26:28 <syntaxfree> Rio de Janeiro.
08:26:32 <glguy> dwmUsers = filter (liftM2 (&&) canEditC canReadC) starNixUsers
08:26:41 <earthy> nice place. in places. :)
08:26:45 <ventonegro> tautologico, you?
08:27:01 <tautologico> Recife
08:27:11 <ventonegro> my memories of Rio are of a hell of a summer that i almost got fire
08:27:20 <ventonegro> s/got/caught/
08:27:31 <ventonegro> spontaneous combustion
08:27:34 <syntaxfree> !
08:27:41 <earthy> last time I was in Rio it was winter. that made it bearable. ;)
08:27:43 <opqdonut> glguy: true, true
08:27:44 <syntaxfree> Recife's supposed to be warmer.
08:27:53 <opqdonut> glguy: i started reading the sources
08:27:56 <ventonegro> syntaxfree, i'm from fortaleza
08:28:06 <opqdonut> glguy: but a centralized list of functions that can be bound etc. would be nice
08:28:08 <velco> oh oh
08:28:08 <ventonegro> syntaxfree, believe me, Rio in summer was hell for me
08:28:14 <glguy> opqdonut: did you read this?
08:28:16 <glguy> """Because dwm is customized through editing its source code, it's pointless to make binary packages of it. This keeps its userbase small and elitist. No novices asking stupid questions.
08:28:39 <syntaxfree> !
08:28:56 <earthy> back to reading Simon PJ's STM christmas article
08:29:13 <opqdonut> glguy: yeah i know
08:29:14 <tautologico> which one is that?
08:29:27 <syntaxfree> googling for DWM yields this: http://en.wikipedia.org/wiki/Desktop_Window_Manager
08:29:32 <lambdabot> Title: Desktop Window Manager - Wikipedia, the free encyclopedia
08:29:35 <glguy> which applies to vista
08:29:41 <syntaxfree> yes, I know.
08:29:47 <opqdonut> glguy: i meant just a list of functions that can be bound to keys in config.h or something
08:29:47 <ndm> tautologico: http://haskell.org/haskellwiki/Talk:SantaClausProblem
08:29:48 <lambdabot> Title: Talk:SantaClausProblem - HaskellWiki
08:30:02 <opqdonut> glguy: being unnoobfriendly doesn't mean being cryptic
08:30:02 <glguy> opqdonut: oh, but there is a list of functions in teh headerfile
08:30:11 <earthy> http://research.microsoft.com/~simonpj/tmp/beautiful.ps
08:30:32 <opqdonut> glguy: yeah but the ones that take Args * arent grouped
08:30:41 <tautologico> thanks ndm and earthy
08:30:44 <opqdonut> glguy: of course i grepped them straight away
08:30:54 <tautologico> I can't remember if I saw this mentioned on LtU
08:31:14 <glguy> opqdonut: I was about to recommend :)
08:31:53 <syntaxfree> @where dwm
08:31:54 <lambdabot> http://www.shortest.de/view/dynamic+window+manager
08:32:00 <glguy> dwm.suckless.org
08:32:17 <opqdonut> glguy: my point is, it needn't be as cryptic as this
08:32:44 <opqdonut> glguy: there is a line between leetness and harming usability and i think dwm crosses it now and again
08:32:50 <glguy> I guess... but since they don't care if they get new users, and the regulars know the functions... i don't think they dare
08:32:53 <glguy> care*
08:33:02 <tautologico> I guess I will finally be able to see the Channel9 video on STM
08:33:50 <dylan> my main interest in dwm is in changing it to suit my needs.
08:34:04 <dylan> it is refreshing for a code base so small I can learn it all in a day.
08:34:29 <syntaxfree> I like this: http://irc.suckless.org/
08:34:33 <lambdabot> Title: suck less
08:35:32 <opqdonut> dylan: yeah
08:35:43 <dylan> last two things I've tried to hack on were horridlbe -- irssi and a firefox extension -- left me very depressed. :P
08:35:46 <opqdonut> delving into ion3 takes much more time
08:36:01 <dylan> testing lua expressions is not so easy either.
08:36:12 <opqdonut> but tuomov's code is very clean compared to e.g. irssi
08:36:16 <opqdonut> or nearly anything
08:36:24 <dylan> I don't doubt that. :)
08:36:28 <opqdonut> dylan: well, i know my lua, so no problem
08:36:28 <dylan> irssi has no comments.
08:36:57 <dylan> I use dwm because dons uses it, and he's a good hacker to immitate. ;)
08:37:13 <opqdonut> heh
08:37:29 <opqdonut> dylan: btw, what is your opinion on editors?
08:37:46 <dylan> opqdonut: I use vim, I dislike modal editors.
08:37:52 <dylan> err, non-modal
08:37:55 <opqdonut> heh
08:37:59 <ventonegro> syntaxfree, interesting concept
08:38:12 <opqdonut> ok, it's just that i'm hacking on this editor in the vein of dwm
08:38:22 <opqdonut> bit of ion, bit of dwm
08:38:26 <dylan> I'm very comfortable with things like /foo<CR>cw
08:38:37 <dylan> I'd rather make dwm more vim-like, myself.
08:38:39 <opqdonut> pure c engine, higher-level stuff in lua
08:38:48 <opqdonut> but non-modal, it seems
08:39:02 <opqdonut> i want the feature-richness of ed/ex in a non-modal visual editor
08:39:03 <__alex_br__> opqdonut, which editor?
08:39:20 <opqdonut> __alex_br__: one i'm working on, it's called "editor" atm :)
08:39:25 <Nafai> Modal editors just don't feel right to me :)
08:39:26 <opqdonut> but i use emacs mainly
08:39:28 <__alex_br__> hehehe
08:39:34 <dylan> modal suits my way of working
08:39:38 <glguy> one of the reasons that I like ViM is that I don't have to take my fingers off the homerow to do much of anything, and since it doesn't need the arrows and whatnot, I can use my keyboard that doesn't have a number pad or arrows or home/end, etc
08:40:02 * __alex_br__ prefers vim over any editor out there
08:40:13 <dylan> @quote dylan
08:40:13 <lambdabot>  everything's a hack. the world's a hack.
08:40:17 <tautologico> emacs is better :)
08:40:27 <__alex_br__> tautologico, no it is not ;-)
08:40:31 <dylan> heh.. lambdabot never gives the quote I want
08:40:44 <glguy> heh, I'm not going to argue whether one is better, I can only argue that one does what i need better ;)
08:40:45 <dylan> emacs is better for tautologico.
08:41:00 <dylan> vim is better for me.
08:41:00 <__alex_br__> dylan, shhh, let me get my flamewar
08:41:22 <opqdonut> glguy: yeah i neither want to move my fingers
08:41:25 <opqdonut> bah
08:41:28 <tautologico> emacs vs vim is fun, almost as much as static typing vs dynamic typing
08:41:30 <opqdonut> dylan: that was for you
08:41:33 <ToRA|> q: is there a working tags program for haskell for vim?
08:41:40 <opqdonut> no, for glguy
08:41:41 <opqdonut> aaagh
08:41:45 <opqdonut> i fail too hard
08:42:01 <glguy> tautologico: emacs vs vim comes out in kind of a draw, static vs dynamic is a no brainer ;)
08:42:34 <arcatan> I use Emacs for Haskell and writing LaTeX and Vim for everything else
08:42:35 <dylan> static typing in vim results in a buch of beeping, if you statically type left-arrow
08:42:40 <__alex_br__> but... weak or strong?
08:42:44 <tautologico> well, here in #haskell I shouldn't expect otherwise :)
08:42:45 <opqdonut> my point was, no one wants to use the arrows, so vi has modes and emacs has move binds
08:42:49 <Saizan> is there in vim a better way to exit from edit mode than pressing ESC?
08:42:59 <ToRA|> Ctrl-C
08:43:09 <opqdonut> Saizan: ^]
08:43:09 <earthy> ctrl-[
08:43:24 <Saizan> it' totally out from the home row!
08:43:31 <ToRA|> saizan actually: ctrl-c
08:43:41 <earthy> works especially well if you remap ctrl to be where caps-lock is
08:43:48 <earthy> and [ should be next to p
08:43:49 <opqdonut> Saizan: rebind
08:43:51 * glguy ALWAYS remaps his caps lock
08:43:53 <opqdonut> earthy: exactly
08:44:03 <metaperl> I want to write a simple parser to parse a string representing Haskell integers... is it possible to do this using read and could someone show me how to do it using parsec? I have never used parsec...
08:44:14 * glguy remaps the capslock key of other peoples computers too
08:44:25 <opqdonut> it's a shame i have all the ctrl shortcuts hardwired into my hands so i can't move ctrl to its righteous place
08:44:41 <glguy> opqdonut: the mind seems to relearn quickly
08:44:47 <tautologico> in parsec you could use the definitions for haskell tokens and get this parser for free
08:44:57 <metaperl> > read "[1,2,3]" :: [Int]
08:44:59 <dylan> I use whichever is closer -- having three ctrl keys
08:45:01 <opqdonut> glguy: yes, but the muscles don't
08:45:03 <norpan> "righteous"?
08:45:04 <lambdabot>  [1,2,3]
08:45:17 <opqdonut> norpan: righteously earned or so
08:45:22 <earthy> if you ever get the chance, take a look at a keyboard on a lear siegler adm3a
08:45:29 <metaperl> tautologico - i have never used parsec ... could you provide a complete working ghci example?
08:45:33 <earthy> that'll explain a lot of vi's keymapping
08:45:35 <opqdonut> earthy: pic?-)
08:45:39 <opqdonut> earthy: hehe
08:45:42 <earthy> searching for it ;)
08:45:45 <opqdonut> :)
08:45:52 <opqdonut> ahh, the space cadet keyboard
08:45:58 <glguy> http://www.tentacle.franken.de/adm3a/
08:45:59 <tautologico> metaperl: a complete example of what?
08:46:00 <lambdabot> Title: Lear Siegler, Inc. (LSI) Terminal ADM3A
08:46:10 <earthy> gotcha. page 3-2 of http://vt100.net/lsi/adm3a-om/adm3a-om.pdf
08:46:12 <opqdonut> glguy: thanks
08:46:58 <metaperl> tautologico - never mind.. I will google for an intro to parsec
08:47:07 <glguy> I don't think that I could remap my esc key to tab..
08:47:16 <earthy> (it also explains why ~ is $HOME on unix ;))
08:47:48 <opqdonut> glguy: ctrl-q or something might be nice
08:48:06 <earthy> glguy: ever seen a happy hacking keyboard? :)
08:48:15 <glguy> earthy: YUP
08:48:19 <opqdonut> those are nice
08:48:23 * earthy nods
08:48:24 <opqdonut> just cost like hell
08:48:25 <opqdonut> :(
08:48:27 * earthy nods
08:48:37 <glguy> I've got a playstation 2 usb keyboard
08:48:38 <opqdonut> and i primarily use a laptop nowadays so ...
08:48:39 <tautologico> metaperl: this is a small parser I wrote, but I guess you want something simpler http://postele.homelinux.net/reps/andrei/faul/Parser.hs
08:49:00 <glguy> that I use for admin tasks at the console of this machine
08:49:07 <earthy> opqdonut: yah, I still need to figure out if I can get the US keyboard on a .nl MacBook
08:49:28 <opqdonut> earthy: my friend got one
08:49:29 <earthy> (the .nl keyboard puts `~ between the z and the shift)
08:49:41 <opqdonut> earthy: he told apple his kbd broke
08:49:51 <opqdonut> earthy: they asked him what kbd model he had and he said us
08:50:03 <opqdonut> they gave him a new one on warranty, no questions asked
08:50:08 <opqdonut> great service aint it :)
08:50:27 <earthy> ya. but that's with the iBooks, right? macbooks have slightly harder to replace keyboards.
08:50:42 <opqdonut> oh yeah
08:50:44 <opqdonut> true
08:50:55 <opqdonut> yeah this guy had an ibook
08:53:26 <metaperl> please someone show me how to import parsec and run a simple little parser... a complete working example for ghci please
08:53:49 <tautologico> import Text.ParserCombinators.Parsec
08:54:07 <__alex_br__> metaperl, look for the "write yourself a scheme interpreter in 48hrs" tutorial
08:54:33 <ToRA|> there's a simple example on http://www.cs.uu.nl/~daan/download/parsec/parsec.html
08:54:50 <metaperl> everything at daan's pages has the wrong import sttmts I think
08:54:58 <tautologico> metaperl: import Text.ParserCombinators.Parsec
08:55:01 <tautologico> oops
08:55:09 <tautologico> metaperl: http://postele.homelinux.net/reps/andrei/faul/Parser.hs
08:56:14 <earthy> yeah, daan has a slight tendency to let stuff bitrot
08:58:56 <glguy> anyone know a good link to help explain the difference in OO interfaces and Haskell type-classes?
09:00:41 <earthy> http://en.wikipedia.org/wiki/Type_class
09:00:54 <glguy> other than that you can easily add a typeclass and instance of type that is defined elsewhere
09:01:06 <glguy> without altering that remote type definition
09:02:47 <earthy> and http://homepages.cwi.nl/~ralf/OOHaskell/
09:02:50 <lambdabot> Title: Haskell's overlooked object system
09:03:19 <glguy> I understand how to use typeclasses and instances
09:03:25 <glguy> (just to be clear :)  )
09:03:34 * earthy understood that
09:03:37 <glguy> What I don't know is how Java's interfaces work :)
09:03:40 <glguy> *reading*
09:04:43 <glguy> abort abort!
09:04:48 * glguy tried printing that paper
09:04:52 <glguy> it's 79 pages
09:05:38 * earthy grins
09:05:55 <earthy> there's a reason Haskell is `Powered by Ph.D' :)
09:07:08 <tautologico> the evolution of a haskell programmer
09:10:15 <earthy> ;)
09:11:36 <tautologico> I spoke with one of the authors of the paper that gave origin to the "post-doc haskell programmer" version
09:12:52 <tautologico> I still don't really understand it, though :)
09:13:56 <SamB> damn keyboard...
09:14:32 <glguy> keyboard was tired of being in IRC?
09:15:13 <opqdonut> :))
09:15:14 <SamB> it has too many crumbs in it
09:15:29 <SamB> one of the modifier keys was stuck
09:15:47 <opqdonut> hehe
09:15:47 <SamB> I clicked on the #haskell tab... boom! no more #haskell tab!
09:16:26 <glguy> oh, i kicked you
09:19:11 <pjd> why does "join (*) 5" blow up with "No instance for (Monad ((->) a))" here instead of giving 25?
09:19:37 <Philippa> you've not got the relevant instance in scope?
09:19:46 <Philippa> it's not part of the Prelude...
09:19:47 <integral> pjd: import Control.Monad.Instances
09:20:12 <pjd> hmm, ok...
09:21:26 <pjd> err, how exactly do i do that
09:21:40 <pjd> :m +Control.Monad.Instances doesn't work
09:21:52 <roconnor> How about Control.Monad.Reader?
09:22:37 <wolverian> pjd, works here.
09:22:43 <pjd> roconnor: ok, that works
09:22:46 <pjd> thanks
09:22:55 <wolverian> (but you also need Control.Monad to import join)
09:22:55 * pjd aways
09:23:40 <Cale> Control.Monad.Reader reexports Control.Monad, iirc.
09:25:08 <wolverian> Cale, right, but .Instances doesn't.
09:40:57 <ski> pjd,thetallguy : no, 'mono' is not "left invertible", that's 'split mono', 'mono' is "left cancelable", which is weaker
10:00:47 <rohar> anyone have time for a newbie ghc question?
10:02:04 <Saizan> if i know the answer :)
10:02:34 <rohar> ghc on windows has a 'halting problem'
10:02:44 <rohar> every third time I invoke it, it hangs
10:03:26 <rohar> but when I kill the window and do a new command shell, invariably the compiler does not halt on the same program
10:03:31 <tautologico> which version?
10:04:22 <Saizan> i use it and i've never experienced this
10:04:37 <tautologico> neither did I
10:06:16 <rohar> 6.6 on xp pro
10:06:30 <rohar> life better if I use cygwin or something?
10:07:11 <rohar> i guess I'll redownload it later
10:07:18 <tautologico> I don't use ghc with cygwin, it works fine
10:07:26 <rohar> k thx
10:08:41 <rohar> working my way through yaht
10:12:36 <rohar> another question..   if (a . b) c is the same as a $ b c why do both forms exist?
10:12:57 <mauke> if a - b is the same as a + (-b), why do both forms exist?
10:13:19 <psnl> rohar: becuase people like me much prefer a $ b $ c $ d $ e to lots of brackets
10:13:42 <ski> a . b $ c
10:13:45 <mauke> a . b . c . d $ e
10:13:49 <ski> is another way
10:14:01 <tautologico> $ is quite handy, you'll see
10:14:16 <rohar> taughtologico: k
10:14:17 * ski prefer what mauke said to 'a $ b $ c $ d $ e', in most cases
10:14:32 <rohar> hmm... can you bind a $ b ?
10:15:10 <ski> "bind" ?
10:15:14 <rohar> mauke: because compsci students didn't invent math?
10:16:23 <ski> foo e = a . b . c . d $ e
10:16:28 <ski> can be shortened to
10:16:29 <__alex_br__> $ is the anti-list operator
10:16:33 <ski> foo = a . b . c . d
10:17:04 <tautologico> pointfree
10:17:34 <ski> > all ((0 <=) . (^2)) [-5..5]
10:17:36 <lambdabot>  True
10:17:37 <dancor> how can i do   f (x:xs) = ...  but also be able to call x:xs like l
10:17:49 <ski> f l@(x:xs) = ...
10:17:50 <dancor> i can't remember nor find in yaht
10:17:53 <dancor> sweet
10:18:22 <KoolAid2> http://tinyurl.com/yfkm37
10:18:27 <lambdabot> Title: Servage.net Quality Web Hosting
10:18:58 * dancor clears screen to avoid being affected by spam
10:19:46 <rohar> ski: let s = (head . tail)
10:19:59 <rohar> seems you can do that but not:  let s = (head $ tail)
10:20:40 <Saizan> . is composition but $ is application
10:20:41 <__alex_br__> @type ($)
10:20:42 <lambdabot> forall b a. (a -> b) -> a -> b
10:20:43 <rohar> still don't see the diff between . and $
10:20:43 <mauke> head $ tail is just head tail
10:20:49 <mauke> you can't take the head of tail
10:20:53 <__alex_br__> $ don't take two functions
10:21:12 <__alex_br__> s/don't/does not/
10:21:12 <rohar> ah k
10:21:23 <rohar> so $ just separates the funct name from the args?
10:21:42 <__alex_br__> rohar, yep
10:21:57 <__alex_br__> rohar, but with a much lower precedence than function call
10:22:02 <rohar> so can you use $ after the name of a no-arg funct?
10:22:18 <__alex_br__> nope, remeber the type
10:22:18 <rohar> (don't know why I'd want to)
10:22:21 <__alex_br__> @type ($)
10:22:22 <lambdabot> forall b a. (a -> b) -> a -> b
10:22:42 <rohar> k.  think I'm getting it.
10:23:35 <rohar> thx to all.  hope to ask more intelligent questions later
10:24:06 <mbishop> @protontorpedo
10:24:06 <lambdabot> is it hard to set up n ready my pc for programming?
10:25:42 <koala_man> @protontorpedo
10:25:42 <lambdabot> is haskell better than APL or perl or clisp?
10:25:49 <koala_man> haha, awesome
10:26:03 <Saizan> APL?
10:26:08 <mauke> @keal
10:26:09 <lambdabot> nsa try kill me numerous times
10:26:28 <Saizan> @keal
10:26:29 <lambdabot> i use an 8088
10:29:19 <rohar> aleph0 = tail(1..)
10:35:50 <dylan> heh, I'm on qdb.us now
10:35:54 <dylan> http://qdb.us/74669
10:35:58 <lambdabot> Title: QDB: Quote #74669
10:36:17 <dancor> is there an or for case matching
10:36:31 <dancor>   case h of
10:36:31 <dancor>     FR | FL | AL | AR -> 2
10:36:31 <dancor>     F | L | A | R -> 1
10:37:05 <basht> dunno
10:37:52 <dylan> dancor: I don't think so. that works in ML, but not haskell.
10:38:03 <therp> I'm really bored by watching GHC recompile.
10:40:05 <basht> dancor: look at "guards" ( http://en.wikibooks.org/wiki/Haskell/Control_structures ).  It may work for you.
10:40:15 <dancor> therp: you should have piped it to a fun colorization sed script
10:41:12 <dancor> if i just want to signal that something can't be done with Either Nope ... what should Nope be
10:41:22 <dancor> oh maybe Maybe?
10:42:25 <psi_> does gtk2hs not work with ghc 6.6? it's not in debian.
10:47:05 <dcoutts> psi_, the released version doesn't work with ghc 6.6
10:47:06 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
10:47:19 <dcoutts> psi_, the darcs version does work and there'll be a new release shortly
10:47:48 <psi_> ok
10:51:54 <rohar> me back
10:55:51 <dylan> hmm
10:56:10 <dylan> how would you represent a text buffer, say for the main area of an IRC client?
10:56:35 <rohar> sounds like a string
10:56:38 <dylan> [String] is okay, except appending is slow and removing things from the end is slow
10:57:10 <dylan> random access is not important, but removal and appending need to be fast.
10:59:59 <lightstep> why removing?
11:00:54 <dylan> memory is finite
11:01:11 <dylan> right now my irc client leaks memory as the scrollup accumulates
11:02:01 <lightstep> that much? i would naively think all irc clients behave this way
11:02:15 <lightstep> maybe it will take less memory if you use [ByteString]
11:02:15 <dylan> think about it
11:02:22 <dylan> that is not the problem
11:02:37 <dylan> unless I expire lines from the scroll log, it will eventually use all available memory
11:02:56 <lightstep> if the users actually receives 1000
11:03:02 <lightstep> 's of MB of text
11:03:13 <dylan> over the course of a year, this is likely
11:03:22 <dancor> a gig of text in a year?
11:03:30 <dylan> sure.
11:03:31 <Tanuk-> dylan: To me it sounds like you want a queue. Data.Queue seems to be deprecated in favour of Data.Sequence. Note that my Haskell coding experience is near zero.
11:03:35 <rahikkala> lightstep: You underestimate the... conviction of many IRCers
11:03:54 <dylan> especially if given more than one channel
11:04:00 <dylan> I'm in like 8 channels.
11:04:27 <dylan> and so far I've not had to restart my client in 36 days.
11:04:29 <lightstep> well... this is possible. i don't think there's a circular buffer in the standard libraries
11:04:38 <dancor> dylan: hm 6 words a second
11:04:43 <dancor> continuously
11:05:09 <dylan> I also believe any program like an IRC client should have near constant memory consumption
11:05:11 <dancor> well anyway i'm off on a tangent
11:05:37 <dylan> @docs Data.Sequence
11:05:37 <lambdabot> Data.Sequence not available
11:05:54 <lightstep> you actually want to back that history with a log file on the disk, so you can see that history if you scroll up a lot
11:06:28 <dylan> lightstep: yeah, but that doesn't need to be in the implementation of the data structure
11:07:03 <lightstep> i think it does. your main program shouldn't care how getAt is implemented
11:07:51 <dylan> My display structure is pure code
11:08:01 <dylan> I use a pretty printer to display it.
11:09:21 <dylan> it's Screen { title :: String, content :: [String], entry :: Entry }
11:09:41 <lightstep> well, use content :: MyList String
11:09:50 <lightstep> with a suitably intelligent MyList
11:09:56 <dylan> I think I might be able to use Data.Sequence
11:22:22 <sorear> ?seen
11:22:22 <lambdabot> Lately, I have seen apfelmus, cognominal, dylan, lightstep and sorear.
11:22:41 <sorear> ?users
11:22:41 <lambdabot> Maximum users seen in #haskell: 309, currently: 278 (90.0%), active: 39 (14.0%)
11:34:41 <YuleAthas> Does Haskell's lazyness stop at the arithmetic operators?
11:35:08 <mauke> > length [undefined + undefined]  -- no
11:35:10 <lambdabot>  1
11:35:48 <YuleAthas> Then why doesn't (2 / fac (-1)) * fac (-1) terminate?
11:35:50 <lightstep> > 0 * undefined
11:35:51 <lambdabot>  Undefined
11:35:52 <integral> YuleAthas: no
11:35:59 <integral> YuleAthas: how is your "fac" implemented?
11:36:10 <sorear> because Haskell is not a CAS.
11:36:22 <YuleAthas> integral: the naive way: if (n == 0) then 1 else n * fac (n - 1)
11:36:35 <integral> Well, that's bottom for negative values.
11:36:39 <mauke> then the answer is: because fac (-1) doesn't terminate
11:37:00 <integral> Haskell could choose to sit there singing christmas carols all day
11:37:01 <YuleAthas> I supposed as much.
11:37:05 <sorear> it's much shorter to say: fac n=product[1..n]
11:37:33 <sorear> > product [1..10]
11:37:34 <lambdabot>  3628800
11:37:43 <YuleAthas> Well, I'm not really programming Haskell, I just wanted to figure out whether any language would evaluate the expression to 2, and Haskell seemed like the most likely one to do so.
11:37:55 <Luitzen> would have been nice if that was a type error... e.g., with Nat rather than Int
11:38:07 <sorear> ?go maxima
11:38:09 <lambdabot> http://maxima.sourceforge.net/
11:38:09 <lambdabot> Title: Maxima - A GPL CAS based on DOE-MACSYMA
11:38:26 <sorear> ^^^ IIRC this one will (but it's kinda cheating)
11:38:59 <ndm> YuleAthas: you might be able to write a GHC rule which solves that one
11:39:30 <pjd> YuleAthas: if fac (-1) is undefined/infinite, like in the definition above, the probably a CAS wouldn't easily solve it
11:39:39 <pjd> "then probably", even
11:40:33 <YuleAthas> One that performed a symbolic reduction before performing the arithmetic would reduce the (x/y)*y pattern to x, wouldn't it?
11:40:49 <YuleAthas> Of course, it would need some way to check y for zeroness. Is it even possible in the general case?
11:41:08 <pjd> YuleAthas: not for all y
11:42:09 <YuleAthas> Then it's understandable that Haskell doesn't attempt to do it.
11:44:12 <calvins> which of the Control.Monad functions can help me convert [IO [FilePath]] to IO [FilePath]? I have  a list of IO FilePath, and want to concat all the FilePath into a single list.
11:44:28 <lightstep> sequence can help
11:44:29 <rohar> ack
11:44:49 <mauke> :t liftM concat . sequence
11:44:50 <dylan> :t mapM
11:44:51 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
11:44:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
11:44:58 <Lemmih> calvins: You probably don't want to create a [IO [FilePath]] to begin with.
11:45:01 <dylan> ah
11:45:33 <calvins> maybe that's the problem. i'm trying to get all files in a directory, recursively, and each recursive call on a single directory returns IO [FilePath].
11:45:46 <calvins> Lemmih: that's how that came about
11:45:51 <sorear> use mapM rather thhan map
11:46:27 <calvins> There isn't a standard function for walking over files in a directory recursively, is there? I searched hoogle, but couldn't find anything.
11:46:32 <lightstep> deosn't fusion convert (sequence . map f) to (mapM f)?
11:48:06 <calvins> sorear: thanks, that get's me closer, after returning from the recursive call, that gives me "IO [[FilePath]]", which I can easily handle.
11:48:39 <calvins> so no standard function for directory walking?
11:50:33 <Lemmih> Nope, none.
11:51:13 <rohar> anyone: why does this work: data Coord(x y) = Coord(x y) deriving(Show); print Coord(1 2)  but not this xOf(Coord x _) = x; print xOf(Coord (1 2))  ?
11:51:23 <sorear> calvins: System.IO.HVFS.Utils.recurseDir -- in MissingH
11:52:10 <calvins> sorear: thanks, i've been meaning to look into MissingH. perfect opportunity.
11:52:17 <sorear> You don't need the parens on Coord (and I didn't know they were legal...)
11:52:18 <lightstep> rohar, i don't think this should work. there should not be parens in a data type definition
11:53:01 <rohar> oops.. my  bad.. there aren't any in the declaration.. I misremembered it from my editor.
11:53:23 <lightstep> are you sure "print Coord (1 2)" worked?
11:53:30 <lightstep> it looks like a type error
11:53:46 <mauke> it is
11:54:15 <integral> instance Applicable Int Int where x $ y = x * y
11:54:39 <mauke> no, instance (Monad m, Num a) => Num (m a)
11:54:46 <lightstep> but print _ :: IO ()
11:54:55 <dancor> i can't find any docs on using hdbc-postgresql (i.e. getting a connection).  would i be better off with HSQL
11:56:38 <YuleAthas> How much does Yale Haskell deviate from the Haskell 98 standard?
11:57:21 <ndm> YuleAthas: what is Yale Haskell? how old is that?
11:57:39 <YuleAthas> http://burks.bton.ac.uk/burks/foldoc/18/130.htm
11:57:40 <lambdabot> Title: Yale Haskell
11:57:45 <YuleAthas> 1993 it seems.
11:58:17 <ndm> YuleAthas: i doubt its very close to Haskell at all, give it beat the standard by 5 years :)
11:58:33 <basht> got kicked off for a sec
11:59:48 * basht thinking
12:01:04 <basht> Is xOf(Coord x _) = x a valid function def?
12:01:59 <pesco> Yup.
12:02:55 <basht> hmm...   but if I go print xOf(Coord 1 2) I get errors
12:03:12 <mauke> basht: should be print (xOf (Coord 1 2))
12:03:18 <basht> k
12:03:23 <basht> why, though?
12:03:25 <wolverian> basht, that's because the precedence isn't like what you're used to in C-like languages.
12:03:27 <lightstep> must be funny, doing X programming with [Reply] -> [Request]
12:03:35 <mauke> because a b c is parsed as ((a b) c)
12:03:56 <mauke> so it's trying to call print with two arguments, xOf and Coord 1 2
12:04:51 <wolverian> print . xOf $ Coord 1 2
12:04:54 <pesco> basht: Function application is just written 'f x', parenthesis are only for grouping.
12:05:08 <basht> mauke: k. thx.  I forgot that I have to think like a Martian in this lang.
12:05:31 <mauke> it's just that (x) is the same as x
12:05:51 <pesco> basht: Yeah, Martians are ... _advanced_! ;)
12:05:54 <sorear> > show product [1..15]
12:05:54 <lambdabot>    The function `show' is applied to two arguments,
12:05:55 <lambdabot>   but its type `a -> ...
12:05:57 <sorear> > show (product [1..15])
12:05:59 <lambdabot>  "1307674368000"
12:05:59 <mbishop> http://www.last.fm/user/shapr/ look at this weirdo
12:06:01 * mbishop hides
12:06:06 <lambdabot> Title: shapr's Profile &ndash; Users at Last.fm
12:07:53 <opqdonut> mbishop: i recognize that nick
12:10:15 <vegai> everyone who has a user in last.fm is some sort of a loser
12:10:46 <vegai> (no, I don't. Don't check!)
12:13:49 * _alex_br_ = http://www.last.fm/user/ventonegro/
12:13:53 <lambdabot> Title: ventonegro's Profile &ndash; Users at Last.fm
12:14:31 <MenTaLguY> hello
12:14:44 <MenTaLguY> I've got a rather weird problem building a package with Cabal
12:14:55 <MenTaLguY> it configures fine, but during the build phase, it's suddenly unable to find Prelude
12:16:11 <MenTaLguY> hmm, the difficulty seems to be that Prelude is hidden due to -hide-all-packages
12:18:00 <sorear> did you remember to use 'Build-depends: base' ?
12:18:03 <Saizan> have you "base" among the packages listed in build-depends?
12:18:14 <MenTaLguY> aha, nope
12:18:46 <sorear> Cabal *enforces* completeness of build-depends.  Other package systems just hope you got it right.
12:18:51 * MenTaLguY wonders whether that's really a sane default for Cabal, since the case where you want to include 'base' is the most common one
12:19:38 <MenTaLguY> it still seems like it would be saner to include base unless base is explicitly excluded
12:20:26 <MenTaLguY> that's done the trick anyway; thank you
12:31:16 <MenTaLguY> next question: is there a portable way to create a pipe/fifo?
12:31:45 <MenTaLguY> if not, I guess I'm stuck with createPipe from System.Posix.IO :/
12:33:23 <ndm> Cabal package names are case sensitive!
12:33:25 <ndm> how stupid...
12:33:47 <psnl> <troll>some of us have real filesystems</>
12:33:50 <sorear> (Unix bigot speaking) why would anyone make them ins
12:34:00 <sorear> itive to case?
12:34:10 <ndm> i have a file system that can tell the differnece
12:34:18 <ndm> and don't want to have to fiddle with something as petty as case
12:36:01 <allbery_b> mentalguy:  FIFOs are POSIX specific; non-POSIX systems often have facilities that provide similar features in different ways (Windows has several possible IPC mechanisms, for example, none of which are much like FIFOs)
12:36:23 <dylan> windows does have named pipes, though
12:36:35 <sorear> DOS (which IIRC supports the haskell standard IO) has no IPC at all.
12:36:57 <allbery_b> hm, part of the old posix package?  ISTR one used to use IPC "mailboxes"
12:37:20 <rahikkala> Does such a thing as a Haskell implementation for MS-DOS actually exist?
12:37:22 * allbery_b is not really a windows type
12:37:43 <sorear> If you don't want to restrict yourself to the least common denominator OS, by all means use "non-portable" packages.
12:37:50 <ndm> rahikkala: it used to
12:38:12 <Saizan> @hoogle System.Process.runProcess
12:38:13 <lambdabot> No matches, try a more general search
12:38:17 * MenTaLguY returns
12:38:20 <MenTaLguY> um, excuse me
12:38:25 <Saizan> @type System.Process.runProcess
12:38:26 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> IO System.Process.Internals.ProcessHandle
12:38:30 <Lemmih> ndm: But you don't mind Haskell being case sensitive?
12:38:31 <MenTaLguY> nearly all modern OSes have anonymous pipes (FIFOs)
12:38:36 <MenTaLguY> including Windows
12:38:48 <MenTaLguY> via the CreatePipe API call, in that case
12:38:54 <ndm> Lemmih: indeed, but it does mean that forevermore then FilePath module is exactly that, FilePath, not filepath
12:39:02 <ndm> which i suspect will trip up 50% of users?
12:39:04 <sorear> how can an implementation for DOS *used* to exist?  If it once existed, it will always exist?
12:39:22 <allbery_b> DOS doesn't really "exist" any more
12:39:39 <ndm> sorear: if you can find the sources, it still exists
12:40:08 <Lemmih> sorear: I've seen code bitrot to oblivion (:
12:40:27 <MenTaLguY> Saizan: actually, I could use runInteractiveProcess, except that then I'm responsible for draining stderr myself
12:40:39 <MenTaLguY> so the child process doesn't block writing to it
12:42:18 <MenTaLguY> I was hoping there was a portable way to create two Handles attached to a newly created FIFO (POSIX pipe(), Win32 CreatePipe(), etc...), but I guess not...
12:43:22 <Saizan> well with some preprocessing at compile time you can use a wrapper maybe
12:44:19 <MenTaLguY> maybe.
12:45:05 <dancor> has anyone used HDBC.PostgreSQL successfully?
12:45:21 <dancor> all i do is as  main = do conn <- connectPostgreSQL "test" putStrLn "woo"
12:45:49 <dancor> and i get "unkown exception" when i run it
12:46:00 <dancor> woo does not print
12:46:51 <MenTaLguY> that's because connectPostgresSQL is throwing an exception and terminating the program
12:46:59 <MenTaLguY> presumably because "test" is not a valid DB identifier
12:47:09 <dancor> pima ~ psql test
12:47:09 <dancor> Welcome to psql 8.1.5, the PostgreSQL interactive terminal.
12:47:39 <MenTaLguY> hrm, okay
12:47:54 <MenTaLguY> I guess the next thing is to see if there's a way to trap and inspect the exception to see what the library thinks is wrong
12:48:14 <MenTaLguY> though "unknown exception" doesn't sound too hopeful in that regard :/
12:48:27 <dancor> but won't the compile give me all the details on any exception that bubbles to the top
12:48:30 <dancor> yeah
12:48:39 <dancor> s/compile/\0r
12:48:57 <MenTaLguY> I wonder if there isn't some special format for the identifier that connectPostgreSQL is expecting, though
12:49:13 <dancor> maybe i can't find documentation
12:49:26 <MenTaLguY> aha, there is
12:49:27 <dancor> on HDBC.PostgreSQL
12:49:32 <ndm> MenTaLguY: either way, if you can get "unknown exception" then complain to the author
12:49:46 <dancor> i'll be like "unknown complaint"
12:49:47 <MenTaLguY> try "host=localhost dbname=test user=username"
12:49:52 <dancor> oh wow
12:50:04 <MenTaLguY> rather than just "test"
12:50:34 <dancor> yay
12:50:40 <dancor> how did you find that out
12:50:45 <MenTaLguY> google.
12:50:55 <dancor> waht did you google for
12:51:16 <MenTaLguY> I just googled for "haskell connectPostgreSQL" and looked for code examples
12:51:27 <MenTaLguY> it's a useful technique generally
12:51:38 <dancor> ah right yeah i just recently found out the name
12:51:41 <dancor> haskell postgresql hdbc -debian -package -gentoo -wash -index -hackage -accepted -hsql -swik
12:51:48 <dancor> was how i eventually found that out
12:51:51 <dancor> funfunfun
12:52:19 <dancor> the information age
12:52:45 <MenTaLguY> it seems like looking at the source for the HDBC driver might be faster for finding out names and things at least
12:52:48 <dancor> i hope the documentation age starts soon
12:53:01 <MenTaLguY> then pulling up the documentation for the C postgreSQL library alongside
12:53:33 <MenTaLguY> that's usually how I work in absence of documentation for a binding in the particular language I'm working in
13:33:30 <ryanburn> suppose that you had some data type that you wanted to create like: data A a = B a where you wanted "a" to be an instance of the class Num. Is there a way to express this in the type declaration?
13:34:40 <MenTaLguY> data (Num a) => A a = B a
13:34:42 <MenTaLguY> I think..
13:34:55 <integral> Sick a Num a on either side of the = until it works :-)
13:35:09 <MenTaLguY> yeah, I always forget whether the constraint goes on the rhs or lhs in data statements
13:35:11 <integral> It does with GADTs at least: data A a where { B :: Num a => a -> A a }
13:35:21 <integral> iirc it's the right
13:35:58 <ryanburn> thank you
13:37:14 <SamB_XP> but, does that do anything useful?
13:39:10 <MenTaLguY> does what do anything useful?
13:39:52 <edi> `what' it is useful to construct questions
13:40:09 * edi ducks
13:41:12 <SamB_XP> the constraints on datatypes/constructors like that
13:42:10 * ptolomy wonders why Simon used the bracket-and-semicolon do notation in a chapter for a book on "Beautiful code".. whitespace looks so much cleaner.
13:42:39 <SamB_XP> heh
13:42:45 <SamB_XP> its a matter of taste
13:44:16 <ndm> ptolomy - its clearer, less chance of the unknowledgeable user writing it out and gettnig it wrong
13:48:04 <ndm> @pl \x -> loadResultItem x >>= loadResultModule
13:48:04 <lambdabot> (loadResultModule =<<) . loadResultItem
13:48:40 <ndm> hmm, thats not that pretty at all :(
13:51:06 <pjd> (>>= loadResultModule) should probably work too
13:52:11 <ndm> its a little nicer, but still not beautiful...
13:52:31 <ndm> anyway, hoogle can now search multiple packages at once!
13:53:59 <MenTaLguY> hmm.
13:54:24 <MenTaLguY> I don't think there's anything in the standard libraries like a non-destructive version of Perl's chomp, is there?
13:54:30 <SamB_XP> @hoogle ByteString
13:54:30 <lambdabot> No matches found
13:54:39 <SamB_XP> ndm: I'm not seeing it happen
13:55:00 <ndm> SamB_XP: on my development machine only, no where else (yet)
13:55:06 <SamB_XP> awwww
13:55:12 <SamB_XP> rectify!
13:55:14 <ndm> but its one checkbox done in the Hoogle 4 march
14:00:14 <sorear> ndm: "hurray", but I can't find the case above capital
14:00:18 <MenTaLguY> what's the preferred pastebin these days?
14:00:29 <sorear> lisppate2: url
14:00:35 <sorear> lisppaste2: url
14:00:35 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:01:08 <sorear> ?hoogle withMVar
14:01:09 <lambdabot> Control.Concurrent.MVar.withMVar :: MVar a -> (a -> IO b) -> IO b
14:01:39 <flagitious> hey i have posted a new proposed version of pidigits for the computer benchmark shootout, should i go ahead and submit this to the benchmark site or wait for haskell people acceptance?
14:02:00 <ndm> flagitious: wait for haskell people acceptance
14:02:23 <ndm> flagitious: they might have some tweaks before you submit it, since the shootout people dislike repeated submissions
14:02:28 <ndm> @seen dons
14:02:28 <lambdabot> dons is in #haskell.hac07, #haskell, #haskell-overflow and #ghc. I last heard dons speak 9h 55m 40s ago.
14:02:33 <flagitious> ok, is there anything else i should do to make sure people see it in the mean time?
14:02:34 <ndm> flagitious: dons is the person to speak to
14:02:35 <lisppaste2> MenTaLguY pasted "better way to do this?" at http://paste.lisp.org/display/33236
14:02:46 <ndm> flagitious: prod dons, perhaps via haskell-cafe
14:03:00 <flagitious> ok thanks, what is haskell-cafe?
14:03:08 <dylan> flagitious: mailing list
14:03:22 <allbery_b> > let chomp [] = []; chomp xs = chomp' xs []; chomp' ('\n':[]) acc = acc; chomp' (x:[]) acc = acc ++ [x]; chomp' (x:xs) acc = chomp' xs (acc ++ [x]) in chomp "foo"
14:03:23 <lambdabot>  "foo"
14:03:25 <flagitious> ok thanks
14:03:30 <allbery_b> > let chomp [] = []; chomp xs = chomp' xs []; chomp' ('\n':[]) acc = acc; chomp' (x:[]) acc = acc ++ [x]; chomp' (x:xs) acc = chomp' xs (acc ++ [x]) in chomp "moo\n"
14:03:31 <lambdabot>  "moo"
14:03:56 <allbery_b> extension to \r\n is fairly simple (although as a unix type I'm tempted to say "get a real os" :)
14:04:29 <ndm> question, about hoogle:
14:04:49 <ndm> should: map +filepath (search for map, including the filepath package) search base as well as filepath, or just filepath?
14:04:52 <MenTaLguY> erm, won't chomp xs always successfully match?
14:05:01 <MenTaLguY> skipping the latter patterns?
14:05:04 <ndm> and if the answer is yes, then i'll make sure map +filepath -base works
14:05:24 <MenTaLguY> oh, never mind
14:05:27 <MenTaLguY> chomp'
14:05:29 <MenTaLguY> I see
14:05:31 <ndm> (i.e. specifically exclude base)
14:06:34 <MenTaLguY> I'd probably build up the accumulator with : and then reverse at the end
14:06:38 <MenTaLguY> otherwise that does look better
14:06:47 <sorear> ndm: shouldn't hoogle default to seaching all pacakges?
14:07:10 <ndm> sorear: do you know how many identifiers win32 and opengl define - they'd pretty much top every search
14:07:39 <allbery_b> that's a reasonable alternative, yes, but make sure you catch both terminal conditions (note the case where the string doesn't end with \n, or \r\n in your case)
14:07:40 <ndm> it will probably default to filepath+base+bytestring... - but leave out things like win32/opengl/gtk2hs/wxhaskell - as people either use them or don't
14:08:39 <ramza3> hello
14:08:44 <sorear> ndm: hmm - how about automatically adding a package if an identifier for that package is mentioned in the query?
14:09:07 <MenTaLguY> hmm, I guess there is still the disadvantage that it always creates a new string
14:09:15 <sorear> so ?hoogle ButtonClass a => a -> Bool -> IO () works
14:09:24 <ndm> sorear: its hard to missing typing an identifier for win32 etc, they hit loads of words - and its also too slow, as i expect to have 100's of packages by the end
14:09:43 <allbery_b> mentalguy: this is haskell after all... you don't change stuff in place
14:09:45 <ndm> and for modularity, each has to be in a separate file
14:09:49 <ndm> ramza3: hello
14:13:19 <sorear> ?seen
14:13:20 <lambdabot> Lately, I have seen allbery_b, dylan, flagitious, lisppaste2, mentalguy, ndm, ramza3 and sorear.
14:13:42 <ramza3> lambdabot, haskell
14:13:53 <ramza3> is lambdabot written in haskell
14:13:57 <sorear> yes
14:13:57 <allbery_b> hm, also:  (1) does haskell on windows really not do \r\n -> \n? (2) the Haskell Way involves using "lines" instead (and use laziness to your advantage)
14:13:58 <integral> yes.
14:14:11 <sorear> ?version
14:14:11 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
14:14:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:14:25 <lisppaste2> MenTaLguY annotated #33236 with "a hybrid approach" at http://paste.lisp.org/display/33236#1
14:15:03 <MenTaLguY> of course, actually, this "hybrid" approach is silly
14:15:09 <MenTaLguY> I'm creating a new string anyway in acc
14:15:19 <MenTaLguY> so, yeah, back to allberry's approach
14:16:48 <MenTaLguY> allberry: in this case I've got raw data which may or may not have come from Windows
14:17:00 <MenTaLguY> allberry: I don't want to disturb any interior line feeds
14:18:19 <jlouis> ?users
14:18:20 <lambdabot> Maximum users seen in #haskell: 309, currently: 278 (90.0%), active: 36 (12.9%)
14:19:21 <MenTaLguY> I guess lines always splits on '\n' though, so maybe that wouldn't be a problem
14:20:31 <ndm> MenTaLguY: all haskell files are opened in text mode on windows, which drops all \r's
14:20:42 <ndm> MenTaLguY: unless you explicitly use openBinaryFile, but thats rare
14:20:43 <MenTaLguY> ndm: not if the stream is in binary mode
14:21:04 <ndm> MenTaLguY: yes, but thats not the default, certainly readFile gives you text mode
14:21:07 <MenTaLguY> additionally, in this case I'm on Unix dealing with files some of which have come from windows
14:21:22 <ndm> ah, now that does generate \r's :)
14:21:33 <ndm> Yhc spent quite a while screwing around with this...
14:22:39 <lisppaste2> MenTaLguY annotated #33236 with "The version I'll stick with for now" at http://paste.lisp.org/display/33236#2
14:44:59 <psi_> how can i get this when building gtk2hs? ghc-6.6: unknown package: mtl (dependency of cairo-0.9.10.2).
14:45:02 <psi_> I do have it.
14:45:10 <psi_> ghc-pkg lists mtl-1.0
14:47:08 <psi_> i installed it after first seeing the error
14:48:26 <psi_> i guess it's using an old package list for some reason.
14:51:27 <mgsloan> dcoutts - got gtk2hs compiling on linux :) just had to use the latest darcs version
14:52:48 <sorear> ?users
14:52:48 <lambdabot> Maximum users seen in #haskell: 309, currently: 282 (91.3%), active: 33 (11.7%)
14:52:51 <mgsloan> I think I'm going to make an Input Manager for mouse/keyboard entry.  Trying to find a good model (perhaps both event stream and current-state) for representing this.
14:56:15 <psi_> (fixed it, i think)
15:07:55 <dmead> rawr
15:10:05 <gravity> How can I get ghc to find the GL and GLUT libraries? I import them at the top of my file, and run ghc --make, but it can't find the module
15:16:17 <MenTaLguY> gravity: need a -package argument
15:16:30 <MenTaLguY> with the name of the GL package
15:16:38 <finkel> Can anyone help me with exercise 9.1 in Paul Hudak's "The Haskell School of Expression"? I am not sure if I am right with my solution or not.
15:16:52 <Botje> does it work? that's generally a good indicator :)
15:16:58 <MenTaLguY> i.e. -package OpenGL -package GLUT
15:17:35 <gravity> MenTaLguY: Trying with -package OpenGL-2.1 (listed in ghc-pkg) or OpenGL both have the same error
15:17:59 <finkel> Well, yes but it I am supposes to simplify a function and I am not sure if I simplified it enough ;-)
15:18:46 <gravity> MenTaLguY: It seems to be looking for a source file in the same build directory (according to the -v flag) instead of searching /usr/lib
15:19:43 <MenTaLguY> dunno, but you'll need to specify -package anyway
15:20:10 <gravity> Ok, thank you. I'll keep searching.
15:21:35 <ndm> @paste
15:21:35 <lambdabot> http://paste.lisp.org/new/haskell
15:21:43 <ndm> finkel: paste it up and we'll give it a look
15:22:09 <gravity> Ah, it looks like I need to import the fully qualified module name. 'Graphics.Rendering.OpenGL'
15:24:34 <lisppaste2> finkel pasted "Exercise 9.1" at http://paste.lisp.org/display/33242
15:27:38 <augustss> finkel: 'and' and 'map' can be combined into 'all'
15:27:54 <x3m> Cale: there?
15:28:00 <Cale> yes.
15:28:20 <finkel> thanks I try it out
15:28:45 <x3m> i know you can refer to 3d space, but is 2d space also valid, or should it be 2d plane or something?
15:30:08 <MenTaLguY> it's valid but weird
15:30:32 <x3m> do you think n-space is weird also?
15:30:48 <MenTaLguY> not particularly
15:31:00 <x3m> why would 2d space be weird then
15:31:29 <Cale> 2d space is fine.
15:31:30 <MenTaLguY> common usage
15:31:33 <MenTaLguY> that's all
15:31:50 <x3m> okay
15:32:32 <x3m> whats arc length between 2 points, not the same as distance?
15:32:46 <Cale> x3m: along a surface?
15:32:52 <SamB_XP> along a curve?
15:32:53 <yaxu> does a haskell sound and music mailing list sound like a good idea to anyone?
15:32:54 <Cale> or curve
15:33:06 <johnnowak> yaxu: yes
15:33:26 <yaxu> good :)
15:33:26 <SamB_XP> what are some good Haskell bands?
15:33:29 <x3m> Cale: dunno, http://mathworld.wolfram.com/Point-PointDistance3-Dimensional.html "so the arc length between the points x1 and x2 is "
15:33:31 <lambdabot> Title: Point-Point Distance--3-Dimensional -- from Wolfram MathWorld, http://tinyurl.com/wuy32
15:33:37 <johnnowak> yaxu: where is it? :)
15:34:10 <Cale> x3m: yeah, they're talking about a general curve there, and then showing that it's actually a line
15:34:36 <Cale> x3m: In order to prove that a line (segment) is the shortest curve joining two points.
15:34:37 <yaxu> johnnowak: well i could host it but i was thinking that it might be better to have it at haskell.org, if it would fit in with things there
15:35:02 <psi_> anyone know how to run gtk programs in ghci? it complains about threaded rts
15:35:05 <johnnowak> yaxu: makes sense. i mostly user supercollider nowadays with scheme, but i'd like to see what people are doing with haskell
15:35:06 <dons> ?users
15:35:06 <lambdabot> Maximum users seen in #haskell: 309, currently: 278 (90.0%), active: 37 (13.3%)
15:35:59 <SamB_XP> psi_: well, if it didn't do that, do you know what it would do?
15:35:59 <x3m> Cale: ok, but wouldnt sqrt(dx2, dy2, dz2) be the same as sqrt(1+y2+z2) dx then?
15:36:02 <yaxu> johnnowak: rohan drape is doing supercollider with haskell
15:36:07 <yaxu> i guess you know that tho
15:36:10 <SamB_XP> it would crash if you tried to run them more than once, that is what!
15:36:12 <johnnowak> yaxu: mhm.
15:36:20 <finkel> augustss: Looks nice indeed. However given that "all" hasn't been introduced by the textbook yet, may I assume that further simplifications in terms of currying are not possible here?
15:36:57 <x3m> Cale: i get the sqrt(dx^2, dy^2, dz^2) part, but not the f= sqrt(1+y^2+z^2)
15:37:35 <DukeDave> Hi, is anyone here familiar with Colin Runciman's paper on generating primes?
15:37:49 <DukeDave> I've got some.. confusing results :|
15:38:13 <ndm> DukeDave: somewhat, the code in the original paper might be wrong, does it blackhole?
15:38:46 <psi_> SamB, i don't get it. can I turn it off?
15:39:02 <SamB_XP> psi_: no...
15:39:27 <SamB_XP> you'd need to rebuild GHCi without -threaded, at the least
15:39:31 <DukeDave> well, it states that a circular programming implementation should yield lower reduction times; but it doesn't
15:39:33 <SamB_XP> I don't know if you *can*
15:39:48 <ndm> DukeDave: with -O2?
15:39:56 <psi_> ok, i won't bother myself with that
15:39:58 <DukeDave> at least, the provided code; run verbatim in HUGS doesn't :|
15:40:20 <SamB_XP> however, with my GHC 6.4.2, I can run gtk2hs programs from GHCi, but if I try to run one *again*, GHCi dies
15:40:23 <DukeDave> -O2 ? :)
15:40:40 <ndm> DukeDave: the results were valid when they were written down, but compilers change, as do chips, so these things can vary
15:40:48 <ndm> DukeDave: have you tried it in GHC, with the -O2 flag?
15:41:45 <DukeDave> no I haven't, shall do.. however my results are very very far from those listed in the paper
15:42:06 <ndm> DukeDave: which version of Hugs?
15:42:09 <Cale> x3m: perhaps read the arclength article, where it's described in more detail
15:42:17 <DukeDave> 20050308
15:42:21 <ndm> DukeDave: and i know there were issues in one copy of the code, which made it go wrong
15:42:28 <DukeDave> ah
15:42:32 <ndm> Colin's copy of Hugs would be ~99 I would have to guess
15:42:45 <DukeDave> that's exactly that kind of advice I was hoping for
15:42:57 <DukeDave> if only I was suffeciently skilled to correct it :)
15:43:24 <DukeDave> grumble
15:43:43 <ndm> if you email colin, with the results, he might be able to tell you if that is the right code
15:44:04 <ndm> although i'd try it in GHC with -O2, to check if its just a hugs thing
15:44:35 <DukeDave> sounds good, just thought I'd make the appropriate sanity checks before firing off Emails :)
15:45:04 <ndm> nah, the problem with performance measurements is that they change
15:45:23 <ndm> although don't expect answers before new year, the holiday period will be slowing everything down
15:45:57 <DukeDave> does optimisation level 2 enforce more or less optimisation?
15:46:29 <sorear> slightly more
15:46:53 <sorear> -O and -O2 are almost the same, last I heard
15:46:56 <DukeDave> ah
15:48:04 <ndm> GHC only, Hugs has no concept of optimisation
15:56:39 <sorear> how recently has hugs changed?
15:59:03 <ndm> not so recently, but performance changes on CPU's mean operations have changed in speed
15:59:27 <ndm> there have also been some minor things, like an indirection over an indirection is unwrapped at creation time
16:00:37 <sorear> I thought hugs reported performance in terms of cpu-independant abstract 'reductions'?  (I've not use it, only read about it and marveled at the lack of recentness on the website)
16:02:06 <sorear> I wonder how big a niche there is for a much more modern haskell interpreter.  (I immediately think of dynamic type checking on hs-plugins, for instance).
16:02:17 <ndm> sorear: have you seen WinHugs, it rocks!
16:02:45 <ndm> sorear: and what do you mean by "more modern" ?
16:04:25 <glguy> ndm: Today at work we needed a little program to parse a bunch of simple config files to change some values
16:04:37 <glguy> there wasn't a big rush to I got to try playing with it in Haskell
16:04:50 <ndm> glguy: success?
16:04:56 <glguy> ndm: some of the stuff from your site and the paper you referenced were quite relevent
16:05:12 <glguy> instead of dealing with a program tree, I was dealing with a configfile tree
16:05:17 <glguy> yeah, it worked out
16:05:33 <ndm> using Compos or using Play?
16:05:46 <ndm> or SYB
16:06:12 <glguy> ndm: I used a modified version of what compos did
16:06:19 <ndm> glguy: with GADT's?
16:06:25 <glguy> ndm: yeah
16:06:30 <glguy> really simple stuff though
16:06:42 <glguy> I'm sure it wasn't streching the concepts too far :)
16:07:03 <glguy> but it was neat to be able to apply it so soon
16:07:53 <ndm> neat, any reason for picking Compos over Play or SYB?
16:08:04 <ndm> but yeah, generic traversals are uber-cool
16:08:05 <glguy> Play would not have worked, would have needed PlayEx
16:08:14 <ndm> yeah
16:08:22 <glguy> and I wasn't comfortable with that yet
16:08:36 <ndm> fair enough, i'm still exploring how PlayEx works, its not yet polished yet
16:08:44 <ndm> want to add some diagrams to the concepts
16:08:46 <glguy> basically a nested INI format
16:09:16 <ndm> cool
16:09:27 <ndm> i actually got to use Haskell for the first time ever for money yesterday :)
16:09:30 <glguy> but I wrote something that attempted to be a DSL for looking up values and modifying them
16:09:33 <ndm> parsing some PDF and extracting a summary
16:09:42 <glguy> so that the guy that needed to do this could change the behavior
16:09:49 <glguy> oh, nifty
16:10:01 <glguy> you got to write an intereesting program, and got paid too?
16:10:07 <ndm> indeed :)
16:10:13 <ndm> i just got told to do the summary
16:10:15 <glguy> specifically in haskell... exciting
16:10:29 <ndm> so was a case of typing out 50 pages of data, or writing a program
16:10:35 <glguy> heh
16:10:54 <ndm> i think they would have taken about the same time, but the program is more reliable in the end, and much more fun
16:12:06 <sorear> Taking shortcuts takes about the same amount of time as following designated pathes, but is much more fun.
16:13:08 <sorear> sorry, didn't see the 'is more reliable' part
16:13:49 <ndm> well it was 500 rows of 6 values, each of £100,000.00
16:13:58 <ndm> > 500 * 6 * 8
16:14:00 <lambdabot>  24000
16:14:15 <ndm> that many key strokes without error to get it right
16:14:50 <ryanburn> does anyone know what the default infix precedence for == is?
16:15:04 <sorear> no
16:15:10 <SamB_XP> @fixity (==)
16:15:10 <lambdabot> Unknown command, try @list
16:15:13 <SamB_XP> aww.
16:15:34 <glguy> 4
16:15:37 <sorear> it is a well known weakness of haskell, that you must remember fixities - but no-one can.
16:15:38 <glguy> infix 4 ==
16:15:52 <SamB_XP> so we use parans a lot
16:15:53 <ndm> sorear: write a patch to add them to haddock
16:15:54 <glguy> sorear: or you type:   :i (==)
16:15:59 <SamB_XP> ooh, haddock is good
16:16:01 <ndm> (then i'll add them to hoogle)
16:17:36 <dons> try :info (==) in ghci
16:17:40 <rohar> anyone have a sec for a newbie question?
16:17:56 <ndm> rohar: just ask away :)
16:17:57 <allbery_b> ask away
16:18:03 <SamB_XP> does anyone have a newbie question?
16:18:09 <dons> infix 4 ==
16:18:18 <ndm> dons: someone was asking about shootout protocol, they have a faster version of one of the benchmarks
16:18:32 <rohar> So I want to write a function processArgs so that I can use it like this: main = do processArgs getArgs
16:18:38 <dons> oh great. they should add it to the correct wiki page for that problem
16:18:47 <augustss> why doesn't x++ increment x?
16:18:50 <dons> and submit it via the shootout's online submission system
16:19:01 <SamB_XP> heh
16:19:06 <ndm> rohar: getArgs >>= processArgs
16:19:14 <rohar> getArgs returns something like IO String, right?
16:19:15 <sorear> it has to be at the beginning of the line for lambdabot to see it
16:19:17 <ndm> processArgs args = ...
16:19:23 <dons> augustss: you mean like:   map (x ++) [1..10] would be a fold? :)
16:19:30 <MenTaLguY> getArgs :: IO [String], I think
16:19:36 <ndm> or: do args <- getArgs; processArgs args
16:19:56 <augustss> fold?  map?
16:19:59 <rohar> ndm: what does >>= do?  I am not yet worthy of knowledge of the monad
16:20:09 <glguy> augustss is either kidding, quoting someone earlier, drunk, or has had his nick hijacked ;)
16:20:23 <dons> :)
16:20:38 <ndm> rohar: its just another way of doing the do notation, just stick to do notation for the moment - its not necessary to understand
16:20:41 <dons> ?time augustss
16:20:42 <lambdabot> Local time for augustss is 2006-12-22 19:16:39 -0500
16:20:44 <SamB_XP> glguy: I think he was responding to...
16:20:46 <augustss> glguy: hey, SamB_XP asked if someone had a newbie quetion, just trying to comply :)
16:20:49 <rohar> ndm: okay.. so you use the arrow because we're in a monad?
16:20:51 <dons> hehe
16:20:52 <SamB_XP> <SamB_XP> does anyone have a newbie question?
16:20:58 <glguy> ahh
16:21:04 <dons> augustss++ :)
16:21:04 <ndm> rohar: yes
16:21:06 <norpan> hey what is a monad
16:21:07 <glguy> that's what happens when you don't read the whole backlog
16:21:19 <dons> we have a newbie/flame generator though:
16:21:22 <dons> ?protontorpedo
16:21:23 <lambdabot> some dude called topmind says that oo is bs
16:21:24 <norpan> and how do I get from IO String to String
16:21:24 <augustss> backlog, schmacklog
16:21:27 <dons> ?protontorpedo
16:21:27 <lambdabot> how do we automate ftp file transfers with haskell?
16:21:33 <dons> ?protontorpedo
16:21:33 <lambdabot> troll?
16:21:39 <dons> ?protontorpedo
16:21:40 <lambdabot> is there going to be a better dns server in haskell?
16:21:43 <rohar> I am only here because dons shamed me on reddit by posting alien code that I feel I have to understand.. so I learn Haskell
16:21:51 <allbery_b> heh
16:21:52 <emu> norpan: unsafePerformIO $ deleteAllYourFiles, try it!
16:22:00 <norpan> hey, thanks
16:22:03 <dons> rohar: heh. welcome!
16:22:07 <norpan> waitaminute
16:22:12 <augustss> rohar: that's not a bad cause :)
16:22:29 <norpan> deleteAllYourFiles = exec "rm -rf /" right?
16:22:33 <rohar> So if I want processArgs to accept a [String] IO what sort of pattern do I use to match it? I tried processArgs [] = ...
16:22:48 <rohar> dons: thanks.. keep up the tuts!
16:23:02 <allbery_b> >>= unwraps the monad, so the thing on the right takes the non-monadic form (i.e. [String])
16:23:05 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint rohar !
16:23:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:23:25 <allbery_b> (as does the "do x <- foo; bar x" variety; x is unwrapped)
16:23:31 <rohar> allbery_b: k, so if I use >>= I can write a processArgs that doesn't have to screw with IO?
16:23:33 <dons> rohar: yes, I will. i'm writing one at the moment on using the concurrency api to write a fast url checker
16:23:58 <rohar> dons: 20 years of OO, so everything I know is wrong :-)
16:24:02 <allbery_b> well, it needs to either return a value in IO, or you need to do something like getArgs >>= return . processArgs
16:24:06 <rohar> or at least different
16:24:31 <sorear> While hacking lambdabot, I just caught myself doing 'ghc --make Setup.hs' so I could find type errors faster.
16:24:35 <allbery_b> (the "return" re-wraps the value in the monad; you can't take things out of the monad, you can only run stuff inside the monad which is what >>= does)
16:24:41 <dons> rohar: its ok. OO is just the subset of haskell where you use existentials for everything :)
16:25:00 <dons> sorear: oh interesting. you could use the ./ghci scriopt
16:25:03 <dons> which i use for that
16:25:11 <rohar> (!) I'm understand that someday
16:25:11 <dons> i.e. :reload should be pretty fast
16:25:18 <rohar> s/I'm/I'll/
16:25:22 <allbery_b> @where yaht
16:25:23 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:25:39 <allbery_b> "yet another haskell tutorial"
16:25:50 <augustss> dons: but haskell is a little more verbose when doing oo programming
16:25:58 <dons> I saw Ralf's post today, roughly on topic, http://programming.reddit.com/goto?id=vr47
16:26:00 <lambdabot> Title: Grammarware, Haskellware, XMLware : More Haskell in Java 7 or 8?
16:26:07 <rohar> so I need to: main = getArgs >>= processArgs and that means that processArgs can just be [String] ?
16:26:10 <allbery_b> monads do take a while to get used to, especially the IO monad which has that "can't remove things from it" attribute
16:26:15 <dons> rohar: yep
16:26:27 <dons> ?undo main = do args <- getArgs ; processArgs args
16:26:29 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
16:26:35 <dons> ?undo do args <- getArgs ; processArgs args
16:26:36 <lambdabot> getArgs >>= \ args -> processArgs args
16:26:46 <dons> ?. pl undo do args <- getArgs ; processArgs args
16:26:46 <lambdabot> processArgs =<< getArgs
16:26:59 <rohar> dons: thx.
16:27:28 <dons> did people see the Jane St Capital job advert on the mailing list?
16:27:31 <allbery_b> but, again, that does assume that processArgs itself returns something in the IO monad.  if you say getArgs >>= return . processArgs then you don't need to worry about that as return will re-monadify it like IO requires
16:27:47 <ndm> dons: yep
16:28:37 <psi_> would anyone know how to send something to the inferior haskell process and get the output? from elisp
16:29:05 <ndm> dons: although looks like they want a sysadmin, rather than a programmer
16:29:10 <sorear> dons: it failed, tried to find ./BotPP for pgmF (have now copied BotPP into ., trying again)
16:29:30 <dons> sorear: ah yes. you need to have at least one non-ghci build done first
16:29:33 <SamB_XP> ndm: don't they always want programmers?
16:29:35 <dons> its in the commentary file, i think
16:29:40 <rohar> god
16:29:58 <ndm> SamB_XP: i always get google adverts from them when reading haskell mailing lists with gmail
16:30:04 <SamB_XP> ndm: me too
16:30:10 <sorear> I did a ghc build first, but it put BotPP into dist/build/BotPP, not .
16:30:31 <sorear> also, quasi-unfriendly error message:     It could refer to either `join', defined at /tmp/ghc4659_0/ghc4659_0.hspp:134:0
16:30:35 <dons> sorear: ah right. I'd tweak ./ghci to use -pgmF dist/build/...
16:30:49 <augustss> I saw the Jane St ad.  I also recently learnt that Deutsche Bank is using Haskell.
16:32:36 <ndm> neat, the more haskell jobs the better
16:32:44 <augustss> FP is spreading among investment bankers :)
16:32:45 <ndm> hacking C for money again will make me cry...
16:32:45 <edwinb> interesting
16:33:04 <edwinb> although I'm not sure I could cope with hacking in any language for investment bankers
16:33:08 <pejo> ndm, hopefully you won't need that though.
16:33:31 <SamB_XP> edwinb: eh, these are smart ones!
16:33:43 <edwinb> SamB_XP: Well, obviously! :)
16:33:44 <ndm> pejo: ideally someone will hire me to do wacky research in haskell for the rest of my life, and buy me a house and a car, i can hope...
16:33:50 <augustss> edwinb: it's a bit ethically strange to work for leaches
16:34:02 <edwinb> yes, I suppose so
16:34:03 <augustss> or is it leeches?
16:34:08 <edwinb> leeches I think
16:34:15 <SamB_XP> augustss: I thought that was *doctors*
16:34:19 <edwinb> ndm: you can probably have one or the other ;)
16:34:36 <ndm> edwinb: :( - although i did realise that
16:34:55 <ndm> if you have no ethics i guess its easier?
16:34:59 <pejo> ndm, It is more important to paint than to eat. ;)
16:35:03 <edwinb> you need a university with a massive slush fund to expense you a car ;)
16:35:04 <SamB_XP> well, how do you know they have no ethics?
16:35:05 <augustss> getting older helps :)
16:35:33 <ndm> SamB_XP: i can bring a dead body to the interview if thats what they want
16:35:42 <rohar> So, if I have: main = getArgs >>= processArgs  the type of processArgs should be [String] -> IO b.. when I write a process args, with type [String] -> Io String it freaks
16:35:49 <ndm> pejo: i used to think eat, but now i'm more thinking paint...
16:36:09 <pejo> ndm, you and van Gogh!
16:36:34 <ndm> i like my ears though
16:36:44 <pejo> Heh, didn't he have one intact?
16:37:22 <rohar> heh.  success
16:43:28 <dons> augustss: anyone we know working at Deutsche Bank?
16:44:00 <augustss> Jeff Polakow
16:44:10 <augustss> not exactly anyone I knew
16:44:44 <dons> hmm, name rings a bell though. maybe we've seen him on the mailing list
16:45:21 <augustss> he's posted occasionally.  CMU guy, did monadic logic languages for his PhD
16:46:04 <sorear> ah, I was getting ready to ask if he was one of the people with a named partial application of ?quote...
16:48:03 <sorear> dons: how badly will lambdabot blow up if a thread outlives the unloading of the module it is defined in?
16:48:44 <sorear> (I'd like to get out of writing some tricky synchronization logic for the IRC plugin's moduleExit)
16:51:00 <dons> threads should be killed on unloading
16:51:05 <dons> i.e. on moduleExit
16:51:12 <dons> check the Darcs plugin for an example
16:52:17 <sorear> how do you deal with unloaded thunks?
16:52:59 <dons> they should be strictified, but if no code is going to access them, that's ok.
16:53:14 <dons> i.e if they're in the modules local state, who cares
16:53:31 <dons> and the global state is going to just toss out module-specific components
16:53:41 <dons> (full details on the technical issues in the hs-plugins papers)
16:56:49 <ndm> @pl \x -> x >>= return . f
16:56:50 <lambdabot> (f `fmap`)
16:59:55 <Itkovian> dons: seen my message?
17:01:09 <rohar> question: if I have this function 'validateArgs args = if length(args) == 0 then error "a" else print ""' what can I put in the place of print "" to serve as a no op?
17:01:35 <ndm> rohar: return ()
17:01:46 <rohar> ndm: much thanks!
17:01:59 <ndm> rohar: although there is a function which abstracts over that pattern
17:02:13 <ndm> and a couple of other points...
17:02:19 <ndm> length(args)   is   length args
17:02:24 <ndm> no brackets
17:02:27 <augustss> or null args
17:02:32 <ndm> == 0 is inefficient, null args is better
17:02:47 <ndm> and then you end up with: when (null args) (error "a")
17:04:27 <rohar> thx
17:06:04 <mgsloan> I wish I could pack along a few variables into IO
17:06:18 <sorear> you mean like StateT x IO ?
17:06:18 <mgsloan> would allow stuff like mousePosition :: IO Point
17:06:24 <rohar> if I have a function a :: [String] -> IO () how should I read that?  The return is IO + unit?
17:06:48 <rohar> what is the relationship between IO and unit?  Is this an IO constructor?
17:06:48 <ndm> rohar: it performs an action, and has no meaningful return
17:06:49 <sorear> IO action which gives unit, that is no additional information
17:06:50 <mgsloan> yeah, thats probably it, sorear.  Not pretty though
17:07:25 <sorear> mgsloan: type MyState = ... ; type M = StateT M IO
17:07:29 <rohar> so it is interesting that I "return ()" rather than "return IO ()"
17:07:39 <sorear> mgsloan: that's what lambdabot does
17:07:44 <mgsloan> ah, cool
17:07:58 <sorear> mousePosition :: M Point
17:08:05 <mgsloan> ah, in the state folder eh?
17:08:08 <allbery_b> rohar: "return" isn't really a return operation, it's what puts the IO around the ()
17:08:33 <allbery_b> think of it as making () "returnable"
17:08:48 <sorear> oooh, bug...
17:08:50 <ndm> rohar: IO isn't just a data type, its a bit more abstract, to stop you playing with it, and messing things up
17:08:54 <sorear> ?repos foo
17:08:54 <lambdabot> foo
17:08:59 <rohar> allbery_b: okay.. back to yaht I guess...   return "knows" to wrap in IO because of the inferred type?
17:09:01 <augustss> rohar: return IO () is just ill formed
17:09:25 <sorear> ?help repos
17:09:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:09:26 <augustss> rohar: yep
17:09:27 <allbery_b> yes
17:10:15 <psnl> argh, talking about hacking for banks
17:10:16 <rohar> what kind of an expression is "IO ()" is it a constructor of IO?  Or should I drop this and resign myself to the idea that I'm not prepared to understand yet :-)
17:10:43 <Botje> rohar: IO () is an action that returns a ()
17:10:59 <tautologico> value expression or type expression?
17:11:00 <Botje> to get the () out, you need to perform the IO action first
17:11:12 <Botje>  02:03:29 up 2 days,  8:39, 10 users,  load average: 49.39, 45.29, 40.28
17:11:13 <rohar> Botje: is an action just a type, though?
17:11:14 <Botje> php rules.
17:11:35 <Botje> rohar: actions *DELIVER* types
17:11:37 <psnl> rohar: no
17:11:56 <augustss> the type 'IO ()' means something that does IO and returns nothing.  like void in C.  the expression 'IO ()' is just bad.  There is no IO value constructor in scope
17:12:09 <rohar> k, so I could write an action called Foo and have type expressions like [String] -> Foo ()
17:12:16 <Botje> yes.
17:12:26 <tautologico> in this case, IO is the IO monad
17:12:36 <Botje> however, you're not quite up to that point yet :)
17:12:48 <rohar> thx to all for the patience
17:18:49 <Cale> rohar: It might be useful to read my brief intro to IO here: http://haskell.org/haskellwiki/Introduction_to_IO
17:18:51 <lambdabot> Title: Introduction to IO - HaskellWiki
17:21:39 <mgsloan> arg, I'm afraid that truely pure languages will be relegated to backends for languages which provide a more natural, procedural stuff.  Threading state is not fun
17:22:17 <ndm> mgsloan: have you seen the stmonad, and the statemonad - no more state threading
17:22:34 <tautologico> yeah, use monads
17:22:56 <mgsloan> yeah, that's what I'm looking at...
17:23:40 <x3m> Cale: do you know of any good tutorials/sites for math(equations)? and stuff that explains like: (x+3)(x-3) = x^2-9?
17:24:35 <dons> mgsloan: dont' thread state! runState :)
17:25:09 <dons> > flip runState 8 $ do x <- get ; put (x+7) ; modify (*2) ; return "done"
17:25:10 <lambdabot>  ("done",30)
17:26:18 <dons> > flip runState ([],8) $ do x <- gets fst ; put ('x':x, 9) ; return "done"
17:26:20 <lambdabot>  ("done",("x",9))
17:27:59 <kfish> I'm afraid that i'll feel dirty chucking my state variables randomly on the heap with everything else when I go back to working in procedural languages
17:28:34 <kfish> using monads is good for the same reasons that sorting your laundry is good
17:28:43 <mgsloan> I guess I'll chalk my difficulty up to those 8 years of procedural...
17:29:00 <kfish> mgsloan, i hear you :-)
17:29:26 <sorear> > flip runStateT 0 $ do replicateM 3 $ do a <- lift "abc" ; modify (a :)
17:29:26 <lambdabot>  add an instance declaration for (Num [Char])
17:29:31 <allbery_b> well, someone did do that monads in C++ thing (if you can stop your eyes from hemorrhaging at the code)
17:29:32 <sorear> > flip runStateT "" $ do replicateM 3 $ do a <- lift "abc" ; modify (a :)
17:29:34 <lambdabot>  [([(),(),()],"aaa"),([(),(),()],"baa"),([(),(),()],"caa"),([(),(),()],"aba")...
17:29:41 <sorear> > flip runStateT "" $ do replicateM_ 3 $ do a <- lift "abc" ; modify (a :)
17:29:42 <lambdabot>  [((),"aaa"),((),"baa"),((),"caa"),((),"aba"),((),"bba"),((),"cba"),((),"aca"...
17:29:52 <sorear> > flip execStateT "" $ do replicateM_ 3 $ do a <- lift "abc" ; modify (a :)
17:29:54 <lambdabot>  ["aaa","baa","caa","aba","bba","cba","aca","bca","cca","aab","bab","cab","ab...
17:30:24 <sorear> state AND nondeterminism!  Behold the awesome power of the monad transformer!
17:31:37 <sorear> I read TC++PL after learning Haskell.  "We don't do overloading on return types because it is impossibly hard."
17:33:55 <augustss> overloading on return types is peculiar
17:34:02 <augustss> but very handy!
17:39:02 <Cale> sorear: hehe
17:47:01 <lisppaste2> glguy pasted "modifying a tree" at http://paste.lisp.org/display/33246
17:47:15 <glguy> am I missing something obvious about this function that is causing it to seem so complicated
17:47:39 <glguy> I've got a Labeled tree, this function takes a predicate to pick a branch, and then updates one of the attributes on the branch
17:48:36 <ndm> glguy: looks awfully complex
17:48:40 <glguy> i know
17:48:42 <ndm> so you want to return the whole tree
17:48:54 <glguy> yeah, I want to return the tree with the specified attribute changed
17:49:00 <ndm> but where you've matched the predicate, add a new attribute?
17:49:13 <ndm> glguy: have you read the SYB examples in teh Compos paper?
17:49:44 <xpika> is there a haskell substitute function?
17:49:45 <glguy> ndm: Did they cover only making the change once?
17:49:52 <xpika> for lists
17:50:01 <ndm> glguy: oh, it might match more than once, and then you only do it once?
17:50:27 <mgsloan> ?hoogle a -> a -> [a] -> [a]
17:50:27 <lambdabot> No matches, try a more general search
17:50:37 <glguy> right, I only want to change the first occurance
17:50:49 <ndm> glguy: monad it up?
17:51:24 <ndm> glguy: or if you use the Play class, you can do it in terms of replaceChildren without a monad
17:51:28 <glguy> ndm: using state to determine if the change is done??
17:51:35 <ndm> glguy: yes
17:51:40 <glguy> ndm: will play work in this case?
17:51:48 <glguy> s/\?\?/\?
17:52:14 <ndm> glguy: i'm sure it would, not sure how...
17:52:31 <glguy> hmm
17:52:33 <glguy> ok :)
17:54:35 <ndm> glguy: think i knwo how..
17:54:58 <glguy> k
17:55:00 <glguy> listening
17:55:02 <dons> xpika: map/take/drop/splitAt. MissingH has a replace function I think, but you can code it up in a line or two
17:55:17 <dons> > map (\c -> if c == 'x' then '#' else c) "haskell is cool for school"
17:55:18 <lambdabot>  "haskell is cool for school"
17:55:25 <dons> > map (\c -> if c == 'c' then '#' else c) "haskell is cool for school"
17:55:26 <lambdabot>  "haskell is #ool for s#hool"
17:56:11 <ndm> glguy: basic idea, return (Bool,x), have replace children convert from a list of those to a single one, with at most one modification
17:56:21 <xpika> @let a = 3
17:56:22 <lambdabot> <local>:6:0:     Multiple declarations of `L.a'     Declared at: <local>:1:0 ...
17:56:27 <xpika> > a
17:56:28 <lambdabot>  Not in scope: `a'
17:56:46 <allbery_b> > L.a
17:56:47 <lambdabot>  3
17:57:07 <ndm> glguy: although i really think a monad might be easier here...
17:57:44 <glguy> yeah, me too
17:57:45 <ndm> statemonad with a boolean in, indicating if you've made a change
17:58:09 <glguy> I could do it with continuations
17:58:14 <glguy> but that gets ugly :)
17:59:59 <ndm> indeed, a simple monad is nice enough
18:00:12 <ndm> although best to avoid in general, of course...
18:01:50 <sorear> how about an error monad, to force an early exit?
18:02:54 <mgsloan> I do know one thing though - you need a lot more knowledge and understanding of haskell than procedural languages in order to do a simple task like convert an event stream into a queryable state
18:03:15 <ndm> mgsloan: indeed, the learning curve to do the imperative stuff is much higher
18:03:37 <mgsloan> imperative stuff in haskell? yep.  its crazy
18:04:33 <glguy> sorear: I'd have to code one up myself, right?
18:04:40 <glguy> since the closest thing is MonadError
18:04:56 <glguy> oh, wait
18:05:04 <glguy> that wouldn't work because I dont' want ot return the changed part only
18:05:07 <glguy> but the whole tree
18:05:50 <lucca> sorear: perl has overloading on return types... sorta
18:06:02 <mgsloan> I'm almost contemplating doing this in another language.  There is nothing in my task which particularly lends itself to haskell.  Except for the fact that the task itself would likely benefit from actually understanding monads (basically, I'm trying to make an IDE for a pure, functional, visual language)
18:06:32 <mgsloan> visual -> graphical
18:07:08 <mgsloan> so far i've got a cairo canvas drawing a box :)
18:07:27 <ndm> glguy: why not StateMonad
18:07:38 <ndm> glguy: with just a single boolean in it
18:07:41 <glguy> ndm: that's what I'm doing
18:07:47 <glguy> ndm: I was responding ot sorear
18:07:52 <glguy> I wasn't sure how to do what he suggested
18:08:14 <ndm> mgsloan: use C#, a much better choice forthat task
18:09:28 <tautologico> or F#
18:10:05 <tautologico> F# has access to all .net libraries but a ml core language
18:10:22 <LoganCapaldo> @paste
18:10:23 <lambdabot> http://paste.lisp.org/new/haskell
18:12:55 <lisppaste2> LoganCapaldo pasted "Do I really have to?" at http://paste.lisp.org/display/33248
18:13:02 <mgsloan> ndm - ah, perhaps I should
18:13:31 <lisppaste2> glguy annotated #33246 with "first rewrite using MonadState" at http://paste.lisp.org/display/33246#1
18:13:32 <LoganCapaldo> So yeah, do I have to do that? I wanted the 'a's to be the same type...
18:13:35 <mgsloan> I wonder if there are .net cairo bindings
18:13:55 <mgsloan> yeah, there are
18:14:48 <gravity> What does the $= operator do?
18:15:25 <sorear> (in cairo) it's basically writeIORef
18:15:53 <gravity> This is for the GLUT bindings
18:16:11 <sorear> same there iirc
18:16:29 * gravity hoogles
18:17:06 <glguy> ndm: I suppose the next step is to use a generic/monadic traversal
18:17:08 <sorear> LoganCapa: do you have to what?  It's not like the compile can derive instances of a user-defined class
18:17:33 <ndm> glguy: with Play, a simple mapUnderM would give you everthing else
18:17:42 <glguy> ndm: you mean PlayEx?
18:17:44 <gravity> sorear: I don't really understand the IO monad (or any monad) yet. writeIORef writes a value to a variable contained in the IO monad?
18:17:55 <sorear> yes
18:17:58 <gravity> Ok, thank you
18:18:06 <ndm> glguy: no
18:18:19 <gravity> Now I just have to figure out where that info is documented :-)
18:18:23 <LoganCapaldo> sorear: i wanted the at and setAt to be defined for all Array2 as for any a
18:18:27 <ndm> glguy:  i'd play over the section, then do the attribute bit by hand
18:18:34 <glguy> Oh
18:18:35 <glguy> ok
18:18:44 <glguy> so play itself is public?
18:18:55 <sorear> what do you mean "for all Array2"
18:19:18 <sorear> are you referring to the fact that you had to define the class?
18:19:20 <ndm> glguy: yes, Play is the normal way of doing things
18:19:38 <LoganCapaldo> for Array2 Integers, for Array2 Strings for  Array2 as
18:19:56 <LoganCapaldo> without having to write the instance for every one
18:20:21 <ndm> glguy: import Data.Play, instance Play CrdSection where replaceChildren (CrdSection a b c) = (c, \c -> CdrSection a b c)
18:21:15 <glguy> ndm: can you link me again, I'm on a different computer
18:22:17 <sorear> LC: oh, wait - I think you need a functional dependency | b -> a for the defn of Array
18:22:40 <sorear> without the fundep, GHC doesn't know that the type of it is the same as the type of 1
18:23:34 <glguy> ndm: I would use mapOverM if I wanted to search from the top down, right?
18:23:42 <sorear> if you have a *very* recent GHC, you might want look into using "associated data types" instead
18:24:11 <LoganCapaldo> sorear: Allright before I do that though, if I do that, is that gonna ruin my chances for defining Array3, Array4, etc.?
18:24:38 <sorear> no, but don't define that many types...
18:24:52 <ndm> glguy: yes, depends if you want to hit the top most or bottom mostone first
18:25:17 <sorear> Are you doing this for educational purposes?  Or do you actually need homogenous sized collections?
18:25:20 <LoganCapaldo> (i know theres an actual array type, I'm just trying to hurt my brain)
18:25:26 <sorear> Ok.
18:26:48 <sorear> ?list
18:26:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:27:02 <glguy> ndm: I noticed you made the same mistake I keep making: Cdr / Crd
18:27:06 <glguy> my scheme is showing
18:27:30 <ndm> hehe, yeah, i learnt scheme a long time ago
18:27:42 <glguy> ndm: any reason for mapUnderM but not mapOverM?
18:28:01 <ndm> glguy: haven't been bothered to write it yet, do you want it?
18:28:10 <glguy> I can work it out :)
18:28:17 <glguy> I've got some decent examples in the file
18:28:40 <LoganCapaldo> sorear: Thanks, that worked. And I thinkI get why it worked
18:28:44 <ndm> give me a sec, and i'll commit it
18:42:10 <glguy> it's lovely when things typecheck
18:42:52 <emu> how about when they work
18:43:00 <ndm> whats lovely is when typechecking == working sufficiently that you don't even have to test
18:43:55 <kfish> hmm, I just used a lambda expression as a grammatical construct in an email to a friend. I had to go and rewrite it as a long and clumsy relative clause.
18:44:10 * sorear sympathizes
18:44:49 <ndm> my friend is studying linguistics, and they do the semantics of english in terms of lambda calculus
18:44:50 <sorear> I've quite frequenty found myself wishing for grouping operators in english...
18:45:40 <Philippa> kfish: "given some x, ..."
18:45:42 <sorear> ?seen
18:45:42 <lambdabot> Lately, I have seen emu, glguy, kfish, ndm, philippa and sorear.
18:47:56 <int-e> @users
18:47:56 <lambdabot> Maximum users seen in #haskell: 309, currently: 262 (84.8%), active: 28 (10.7%)
18:50:55 <lisppaste2> glguy annotated #33246 with "Play saves the day" at http://paste.lisp.org/display/33246#2
18:52:07 <ndm> glguy: i can actually tell what that does now!
18:52:20 <glguy> heh, me too
18:52:33 <ndm> glguy: although if you made the attributes Data.Map's, then you'd get that insert behaviour forfree
18:52:34 <glguy> I only knew it worked before because it typechecked and produced a couple of correct results
18:52:46 <glguy> ndm: good call
18:53:12 <glguy> the only reason I didn't was that I might need the attributes to have a certain order
18:53:20 <glguy> *might*
18:53:26 <ndm> yeah, that would be a reason to keep it as it is now
18:53:30 <glguy> the file spec is not known
18:53:43 <glguy> completely :)
18:53:55 <ndm> lol :)
18:54:03 <glguy> 3rd party app
18:57:39 <mgsloan> the problem with doing it in .net is it takes away the cool of doing it in haskell :)
18:59:46 <SamB_XP> mgsloan: but you get a *real* cool
18:59:50 <SamB_XP> oh. wait
18:59:53 <SamB_XP> backwards!
18:59:55 * SamB_XP sorry
19:00:02 * SamB_XP wonders how he does that
19:00:40 <mgsloan> yeah, I think i'd rather have an irrational cool anyway
19:03:28 <mutjida> ?users
19:03:29 <lambdabot> Maximum users seen in #haskell: 309, currently: 260 (84.1%), active: 28 (10.8%)
19:20:22 <Stinger_> don't suppose anyone knows of an up to date haskell live cd that has a lot of different libraries?
19:20:54 <glguy> ndm: would mapOverM_ make sense?
19:21:13 <ndm> glguy: yes, i guess as soon as you have an M, M_ makes sense
19:21:27 <ndm> skip the whole generate thing, i guess...
19:21:34 <glguy> I think that I need it  for
19:21:50 <glguy> crdFindSection p s = evalCont . callCC $ \ found -> let aux s = when (p s) (found $ Just s) in mapOverM aux s >> return Nothing
19:22:01 <glguy> which should actually be called
19:22:08 <glguy> findInPlay or something
19:22:24 <glguy> since it turns out that it doesn't depend on being a Crd at all :)
19:22:47 <ndm> glguy: although perhaps a fold is more appropriate than mapOverM_ ?
19:23:49 <ndm> actually, M_ doesn't make any sense, i think, would still have to create the thing for every intermediate point, so not faster at all
19:24:28 <glguy> I'm getting a type error is why I wanted to try
19:25:12 <ndm> i don't understand any of that above
19:25:16 <ndm> what is it trying to do?
19:26:08 <glguy> it returns the element of the Play instance for which applying p returns True
19:26:37 <ndm> and returns its context?
19:26:52 <glguy> I suppose, yes
19:26:58 <ndm> [x | x <- allOver xs, p x]
19:27:03 <ndm> what extra context do you need?
19:27:04 <glguy> oh yeah
19:27:12 <glguy> that was in the example
19:27:13 <glguy> duh
19:27:14 <glguy> :)
19:27:43 <ndm> allOver is absolutely great :)
19:27:48 <ndm> actually, thinking about it
19:28:02 <ndm> if i had allOverContext :: a -> [(a, a -> a)]
19:28:18 <ndm> then your first example becomes a few lines without a state monad
19:29:28 <glguy> oh?
19:30:29 <ndm> yep, you'd just do [b $ modify a | (a,b) <- allOverContext x, p a]
19:30:42 <ndm> the head of that list would be the answer
19:30:49 <ndm> where modify does the attirbute insertino
19:31:39 <glguy> wait, modify is not the modify of MonadState?
19:31:49 <ndm> nope, just your own personal tweak
19:31:52 <glguy> right
19:31:53 <glguy> ok
19:31:57 <glguy> now it makes more sense
19:32:00 <ndm> actually, i have a use for that function as well
19:32:03 <glguy> heh
19:32:04 <ndm> would be much simpler
19:32:09 <ndm> will try and figure out how to add that...
19:34:03 <glguy> I agree, this is much better than what I was doing: crdFindSection p s = listToMaybe [x | x <- allOver s, p x]
19:34:20 <glguy> actually, in this case:
19:34:25 <glguy> find p (allOver s)
19:35:57 <glguy> ndm: to write allOverContext, will you need to pass the context into each map?
19:36:32 <ndm> glguy: not sure, just figuring it out, but will have to pass some context around
19:36:33 <glguy> instead of doing it to the result
19:37:24 <glguy> allovercontext c x = (c x : concatMap (allovercontext (c . (x:) ...
19:37:38 <glguy> (c x -> ((c,x)
19:39:00 <glguy> allOverContext :: (Play t) => t -> [([t] -> [t], t)]
19:39:20 <glguy> hmm, needs ot be t -> t and not [t] -> [t]
19:40:27 <ndm> indeed
19:41:48 <ndm> its got a combinatorics problem in the middle as well
19:42:32 <lisppaste2> glguy pasted "initial impressions (wrong)" at http://paste.lisp.org/display/33251
19:43:46 <ndm> glguy: i think you need to make it into slices of the form ([a],a,[a]) with the children, to put it back together again
19:43:53 <glguy> right
19:43:54 <glguy> otherwise
19:44:08 <glguy> you are trying to compose a generator on a generator
19:44:14 <glguy> like I managed to do try
19:46:14 <ndm> i think i nearly have it, just polishing off the type errors...
19:46:21 <glguy> wonderful :)
19:46:36 <glguy> that's actually a really amazing function
19:47:39 <glguy> this is one of those problems that "The reasoned schemer" writes long ugly continuation based functions to solve
19:47:43 <lisppaste2> ndm pasted "allOverContext " at http://paste.lisp.org/display/33252
19:47:59 <ndm> glguy: see what you think of that, type checks...
19:48:50 <ndm> (actually the middle allSlices case is redundant, removed now)
19:49:00 <Eidolos> Is there any specific reason why getArgs is an IO? Couldn't it just be a builtin list or something (and use lazy evaluation to avoid reading the list if it's never needed)?
19:49:38 <Eidolos> Oh, I think I see why. Because it can change from execution to execution.
19:49:55 <ndm> Eidolos: Clean has getArgs as a non-monadic type, there are arguments both ways
19:50:11 <Eidolos> :)
19:51:20 <ndm> glguy: whats your real name? (for acknowledgements in the tutorial thingy)
19:51:38 <Cale> Eidolos: but yeah, you hit the nail on the head -- that's the main argument for it being in IO.
19:51:39 <sorear> ndm: /who ?
19:52:08 <Eidolos> Cale: ok, thanks
19:52:08 <glguy> ndm: Eric Mertens
19:52:11 <nornagon> Eidolos: stalker!
19:52:18 <Eidolos> nornagon: yo :)
19:52:35 <Eidolos> I've developed an interest of Haskell through Pugs, not NetHack, sorry :)
19:52:51 <sorear> wait, nornagon is from NH too?
19:52:56 <Angel_Monadico> hi
19:52:57 <Eidolos> yup
19:53:06 <nornagon> heh
19:53:22 * sorear was briefly active as Stefanor on the wiki-project
19:53:36 <glguy> ndm: you flipped the tuple on me
19:53:47 <glguy> ndm: my code was breaking something awful :)
19:53:59 <ndm> does my code work?
19:54:07 <ndm> (pushed now)
19:54:13 <glguy> ndm: oh, that? yeah brilliantly
19:54:20 <ndm> neat :)
19:54:32 <ndm> if you have rewritten that traversal, can you repaste it, so i can see
19:54:49 <glguy> ndm: you mean my code specific one?
19:55:12 <ndm> did you rewrite http://paste.lisp.org/display/33246#2 in terms of allOverContext ?
19:55:18 <glguy> yup
19:55:21 <glguy> cleaning up
19:55:23 <glguy> and then pasting
19:55:31 <Angel_Monadico> please, I am introducing in functional programming, haskell world, I thing FP have expresisve power, but is dificult for me thing some ideas for this paradigm
19:55:55 <ndm> Angel_Monadico: its different, which can be diifficult - pick a tutorial and work through it
19:56:00 <ndm> @where yaht
19:56:00 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:56:01 <glguy> ndm: it's amazing how didfferent
19:56:31 <ndm> glguy: i wonder how short you could do it with compos or SYB...
19:56:32 <lisppaste2> glguy annotated #33246 with "wow" at http://paste.lisp.org/display/33246#3
19:56:56 <glguy> ndm: and the "f" function should really be a separate toplevel function
19:57:01 <glguy> so, techincally it's two lines
19:57:16 <Angel_Monadico> yep, I try use monad to store var, wich tutorial you recomend???
19:57:20 <sorear> @tell dons I read both [hs-plugins] papers, and could not find any mention of laziness ; the closest I could find was "We avoid all issues of pointers into old code by forcing the entire program to be reloaded whenever any module is."
19:57:21 <lambdabot> Consider it noted.
19:57:51 <Iulus> lambdabot is so formal
19:58:01 <Iulus> I'm impressed
19:58:27 <ndm> glguy: does that return more than one answer though?
19:58:33 <glguy> ndm: mine? nope
19:58:51 <glguy> ndm: find takes the first
19:58:52 <lambdabot> Thank you for the compliment.
19:59:01 <glguy> sorear: I know that wasw you!
19:59:16 * sorear hides
19:59:20 <ndm> glguy: find == headMaybe ?
19:59:42 <glguy> yeah (with a predicate)
19:59:51 <xpika> whats the best way to obtain every 2nd element of a list?
19:59:54 <glguy> listToMaybe . filter p
20:00:15 <glguy> xpika: map head . iterate (drop 2)
20:00:25 <glguy> that's every odd position
20:00:35 <glguy> so... just take the tail first
20:00:51 <glguy> and you'd need a "takeWhile (not . null) between those
20:00:52 <audreyt> or just roll one yourself; may even be faster ;)
20:01:05 <glguy> aux (x:_:xs) = x : aux xs
20:01:07 <glguy> aux _ = []
20:01:18 <ndm> > cycle [False,True]
20:01:19 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
20:01:53 <ndm> > let xs = [1..10] in map fst $ filter snd $ zip xs $ cycle [False,True]
20:01:55 <lambdabot>  [2,4,6,8,10]
20:02:01 <Eidolos> heh
20:02:11 <glguy> > [a | (a,b) <- zip [1..10] (cycle [True,False]), b]
20:02:12 <lambdabot>  [1,3,5,7,9]
20:02:49 <lisppaste2> ndm annotated #33246 with "Using a list comp, no find" at http://paste.lisp.org/display/33246#4
20:02:57 <Eidolos> > [a | a <- [1..10], odd a]
20:02:58 <lambdabot>  [1,3,5,7,9]
20:03:16 <Eidolos> You and your fancy pants Prelude wizardry
20:03:17 <ndm> glguy: thats using a list comp, even simpler (no monad stuff)
20:03:21 <glguy> ndm: I only used the find because I only wanted the first
20:03:33 <ndm> glguy: i use headDef to ensure that
20:03:35 <glguy> and list is a monad :-p
20:03:42 <glguy> ndm: but it's okay if it fails
20:03:48 <glguy> ndm: I would just need to know that it did
20:03:56 <ndm> headDef x [] = x
20:04:02 <ndm> headDef x (y:ys) = y
20:04:03 <glguy> oh
20:04:05 <glguy> I see
20:04:10 <glguy> fromMaybe x Nothing = x
20:04:12 <ndm> its from my Safe library
20:04:36 <ndm> fromMaybe x . listToMaybe
20:04:40 <ndm> i guess thats teh same thing
20:04:49 <sorear> ?instances-importing Control.Concurrent.MVar Show
20:04:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
20:04:50 <glguy> but I need to know that it failed
20:05:31 <ndm> ah, in that case just listToMaybe over it
20:05:50 <glguy> ndm: not a fan of do? :)
20:05:59 <lisppaste2> ndm annotated #33246 with "Returning a maybe" at http://paste.lisp.org/display/33246#5
20:06:05 <ndm> glguy: too confusing for me...
20:06:31 <ndm> i jsut don't understand it at first glance, unlike a list comp
20:07:26 <glguy> ah
20:07:31 <glguy> I changed mine :-p
20:07:47 <glguy> ndm: do you have a Play instance for [a] already?
20:08:15 <ndm> glguy: you can't write a Play on [a], since a /= [a]
20:08:21 <glguy> oh
20:08:23 <glguy> duh
20:08:26 <ndm> unless it was just returning all elements, then its just a fold
20:08:31 <ndm> there is one in PlayMPTC
20:08:31 <glguy> BUT
20:08:49 <glguy> the point is that allOverContext could provide list with currently not widely used functionality
20:08:56 <glguy> but
20:09:02 <glguy> the whole being the wrong type
20:09:04 <ndm> but not PlaySYB, since PlaySYB defins itself everything
20:09:05 <glguy> that's a bummer ;)
20:09:26 <ndm> if you do allSlices, then that function on its own is probably waht you want
20:09:33 <ndm> i have it defined in a standard library i use
20:09:36 <glguy> ah
20:09:43 <ndm> [a] -> [([a],a,[a])]
20:10:10 <ndm> along with various other combinatoric operations on lists
20:10:40 <ndm> anyway, i have to go to bed now
20:10:41 <glguy> cool
20:10:42 <glguy> kk
20:10:45 <glguy> thanks for your help
20:10:48 <ndm> thanks for the suggestions
20:10:58 <ndm> will try and write up allOverContext tomorrow
20:11:14 <glguy> Looking forward to it
20:11:21 <ndm> bye
20:11:49 <Angel_Monadico> alguien habla espaniol?
20:12:00 <glguy> no habla espaniol
20:12:02 <Cale> Angel_Monadico: You're looking for some monad tutorials?
20:12:09 <Korollary> there's #haskell.es, right?
20:12:39 <Angel_Monadico> there is nothing jejej
20:13:03 <int-e> yes. there is, for some reason it's secret (+s).
20:13:09 <Angel_Monadico> yes pleas I need a monad tutorial, samples,
20:13:11 * glguy is beginning to think that #haskell.es is some joke that gets played on all the .es speaking people hat come here
20:13:38 <Angel_Monadico> I try use monads for store variables
20:14:09 <Cale> Do you need a finite number of variables?
20:14:17 <Cale> Or an arbitrary number?
20:14:18 <Angel_Monadico> mmmm yep
20:14:32 <Angel_Monadico> Beggining finite
20:14:52 <Cale> You might be able to get away with the State monad, which is a very simple way to thread a bunch of state through a computation, reading and writing to it.
20:15:33 <Cale> The ST monad, by contrast, lets you set up arbitrarily many cells which you can pass around, and mutate the values they refer to.
20:16:02 <Cale> Also, if you're in the IO monad, you can create IORefs, which are similar to the STRefs which you get in the ST monad.
20:16:29 <Angel_Monadico> IORefs... mmmm yep I thing
20:17:14 <Cale> One of the better monad tutorials is here: http://www.nomaware.com/monads/html/index.html, but it doesn't talk about ST or IORefs.
20:17:17 <lambdabot> Title: All About Monads
20:17:48 <Angel_Monadico> thanks
20:18:09 <Cale> If you have a basic grasp of using the IO monad, all you need to know about IORefs is the 3 functions which make up the basic interface
20:18:25 <Cale> newIORef :: a -> IO (IORef a)
20:18:42 <Cale> creates a new IORef initialised to the given value
20:18:53 <Cale> readIORef :: IORef a -> IO a
20:18:54 <glguy> The stuff that's going on with generic traversals is pretty amazing
20:19:03 <Cale> reads the value of the given IORef
20:19:05 <SamB_XP> glguy: hmm?
20:19:11 <glguy> Between the ComposM paper I read and ndm's Play class
20:19:15 <glguy> I'm excited :)
20:19:15 <Angel_Monadico> newIORef????? oups
20:19:17 <Cale> writeIORef :: IORef a -> a -> IO ()
20:19:25 <Cale> stores a value in the IORef
20:19:50 <glguy> SamB_XP: well, amazing to me anyway
20:20:00 <Cale> there's also  modifyIORef :: IORef a -> (a -> a) -> IO (), which applies a function to the value in the IORef.
20:20:09 <SamB_XP> glguy: I was asking what stuff
20:20:11 <glguy> SamB_XP: I was reading about it yesterday, and as luck would have it i came upon a problem that could make use of it today at work
20:20:18 <SamB_XP> not "do you really think so"
20:20:38 <glguy> SamB_XP: Well, Play is what i'm using now
20:20:45 <glguy> that's the stuff, it's being developed
20:20:54 <glguy> and there is a lot of comparisons on LtU recently
20:21:19 <Cale> Angel_Monadico: does that roughly make sense?
20:24:23 <Angel_Monadico> mm yep, in FP all sense are s very logic, but issues aparece in implementation, its very interesting
20:24:53 <dibblego> ?type iterate
20:24:54 <lambdabot> forall a. (a -> a) -> a -> [a]
20:25:09 <Cale> lisppaste2: url
20:25:10 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:25:57 <SamB_XP> Angel_Monadico: it is very nice to have issues appear in implementation ;-)
20:26:02 <dibblego> ?type while
20:26:04 <lambdabot> Not in scope: `while'
20:26:05 <SamB_XP> much better than having them invisible
20:26:14 <Angel_Monadico> yeeeees
20:26:21 <Angel_Monadico> very very nice
20:27:05 <Angel_Monadico> I build a calc, with memory, this calc store result and load val for others evaluations, I want use to hgl for graphcis interface
20:27:07 <lisppaste2> Cale pasted "Simple IORef example." at http://paste.lisp.org/display/33254
20:27:20 <dibblego> ?hoogle (a -> Bool) -> a -> [a]
20:27:20 <lambdabot> No matches, try a more general search
20:27:25 <glguy> that's such a staticly strong typed thing to say, ... errors are meant to be found with extensive tests, not by compiling
20:28:24 <SamB_XP> glguy: |-P phbbbbbt!
20:29:09 <SamB_XP> I prefer thinktime errors myself ;-)
20:29:29 <glguy> real men don't use fancy tools to find their errors
20:29:37 <glguy> they write news tests for every function
20:29:56 <SamB_XP> have you seen DList?
20:30:03 <glguy> nope
20:30:05 <glguy> should I :)
20:30:22 <SamB_XP> I think it *has* a test for every function
20:30:37 <glguy> just 1?
20:30:38 <SamB_XP> thouh I commented out the silliest one ;-)
20:30:45 <SamB_XP> you want to add more?
20:30:51 <SamB_XP> they are quickcheck tests!
20:31:12 <glguy> I'm just tooling around , you know that q-:
20:31:46 <Cale> DList is kind of a silly piece of code to have large numbers of tests for isn't it?
20:32:04 <SamB_XP> Cale: it isn't a particularly large number
20:32:09 <SamB_XP> I think it was 6 or 7
20:32:20 <Cale> I suppose it's not that large a piece of code anyway
20:32:29 <SamB_XP> also I think it was intended as our answer to "gnu hello"
20:32:43 <Cale> yeah
20:33:08 <glguy> what is DList (other than a dynamic list)
20:33:18 <SamB_XP> Difference List
20:33:21 <glguy> h
20:33:22 <glguy> ah
20:33:37 <SamB_XP> usually represented as functions from lists to lists
20:33:48 <SamB_XP> a bit like ShowS actually
20:33:55 <SamB_XP> @hoogle ShowS
20:33:55 <lambdabot> Prelude.ShowS :: type ShowS
20:33:55 <lambdabot> Prelude.shows :: Show a => a -> ShowS
20:33:55 <lambdabot> Numeric.showSigned :: Real a => (a -> ShowS) -> Int -> a -> ShowS
20:34:14 <SamB_XP> type ShowS = String -> String
20:34:34 <Cale> I use that trick all the time whenever I'm doing something like writing a tree traversal.
20:34:49 <sorear> Dlists can also be represented as concatination trees, and partially applied folds.
20:34:55 <SamB_XP> I added a Monoid instance
20:35:13 <SamB_XP> and I replaced the type synonym with a newtype...
20:35:21 <SamB_XP> did DList 0.2 come out yet?
20:35:36 <Cale> How about a Traversable instance? :)
20:35:59 <SamB_XP> sorear: but when you do that there is a chance you might make a mistake in the implementation
20:36:31 <sorear> huh?
20:36:42 <glguy> in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
20:37:09 <SamB_XP> well, its pretty hard to make a mistake implementing newtype DList a = DList ([a] -> [a])
20:37:16 <sorear> ah.
20:37:33 <sorear> ?remember glguy in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
20:37:41 <sorear> ?quote glguy
20:37:42 <lambdabot>  lol, making lambdabot fight your battles
20:37:43 <sorear> ?quote glguy
20:37:44 <lambdabot>  that's odd, mine is this big : |-----------------------------|
20:38:07 <SamB_XP> what was he measuring? his "hello, world!"?
20:38:09 <glguy> I'll leave the font size to your imagination...
20:38:29 <glguy> I don't know what the context of that comment was
20:38:42 <glguy> someone else said "mine is this big |--|" or something
20:38:46 <glguy> but why?
20:38:47 <glguy> i don't know
20:38:59 <Cale> I think I recorded it simply because it would be funny when taken out of context.
20:39:01 <SamB_XP> haha
20:39:03 <glguy> right
20:39:09 <glguy> but I don't even know the story to it :)
20:39:43 <SamB_XP> glguy: ironically, that *is* a funny story ;-)
20:40:08 <glguy> 6-:
20:40:22 <SamB_XP> what kind of mouth be that?
20:40:37 <glguy> standing on head + tongue hanging down
20:40:42 <sorear> I know the context...
20:41:01 * glguy waits for the punch line
20:41:28 <sorear> I've downloaded all 200MB of logs, never got around to the statistical analysis, and grep -C5 -e '|---------' says...
20:42:10 <glguy> hmmm, another case of me not reading the backlog probably
20:42:47 <sorear> typecheck: how big will be the executable?   Lemmih: this big |---------|  typecheck: oh, that's big.    glguy: ...
20:43:05 <glguy> oh, lol
20:43:10 <glguy> I thought that your grep statement
20:43:12 <glguy> was the context
20:43:19 <SamB_XP> hahaha
20:46:16 <lisppaste2> glguy pasted "any obviously overly-verbose parsec code here?" at http://paste.lisp.org/display/33255
20:46:56 <bd_> *WB* <@Weedy> eretan, when you were born and the doctor said "its a boy" your mom slaped him and told him not to lie <@eretan> nice <@eretan> I always wanted to be a girl
20:48:26 <Angel_Monadico> excellent monad tutorial :) thanks Cale
20:48:36 <LoganCapaldo> Overly verbose? I think I just had a heartattack from how short that is
20:49:01 <Cale> Angel_Monadico: you might also like: http://haskell.org/haskellwiki/Introduction_to_IO and http://haskell.org/haskellwiki/Monads_as_containers
20:49:02 * LoganCapaldo thinks about the corresponding yacc + C code
20:49:03 <lambdabot> Title: Introduction to IO - HaskellWiki
20:49:11 <glguy> I just wondered if I was missing anything in terms of typical parsec style
20:49:14 <Angel_Monadico> :)
20:49:58 <LoganCapaldo> I'm not good enough for Haskell
20:50:04 <LoganCapaldo> that's what it is
20:50:21 <allbery_b> is anyone? ;)
20:50:27 <glguy> LoganCapaldo: if I keep on track for the night, that code will fall to half the number of lines :-p
20:50:31 <glguy> I don't see that happeneing
20:50:46 <Angel_Monadico> please other help,...  have you any tutorial fot hgl, hopengl????
20:50:56 <sorear> I wrote a 590 character theorem prover, and felt so bad I put it on the wiki...
20:53:23 <Iulus_> glguy: for some reason I like to do a 'whitespace = skipMany space'
20:53:24 <Cale> Hmm, I'm not sure where to get tutorials for those. HGL is a really simple graphics library (which has nothing to do with OpenGL), and HOpenGL is a fairly direct binding to OpenGL, so I suspect it works mostly like OpenGL in other languages.
20:53:46 <Cale> However, it would be nice to see a purely Haskell OpenGL tutorial.
20:54:11 <Cale> I remember someone ported the examples from NeHe's tutorial on OpenGL.
20:54:32 <Iulus_> does Parsec work with a stream of tokens instead of Strings? I started working with Happy today, but it hasn't just clicked like Parsec did.
20:54:41 <Cale> hmm, this appears to be an HOpenGL tutorial http://www.haskell.org/~pairwise/HOpenGL/HOpenGL.html
20:54:51 <Cale> Iulus_: it can
20:54:58 <gravity> HOpenGL doesn't seem to be that direct
20:55:19 <gravity> begin and end not being there is a striking ommission for example
20:56:14 <Cale> Iulus: You use the token,tokens and tokenPrim functions in the Text.ParserCombinators.Parsec.Prim module to set up basic parsers for your tokens.
20:56:48 <Cale> Iulus: you'll want to store SourcePos values in your token values to be used by these functions
20:57:03 <Cale> Iulus: (so it helps to use Parsec to do lexing in that case)
20:57:44 <rongenre> optimization question.. anyone seen a fast bigendian -> little endian converter?
20:58:04 <bd_> rongenre: I think i386 has a single opcode for it
20:58:08 <zetta> bswap
20:58:10 <bd_> or well i686
20:58:19 <zetta> I think of  i486 origin
20:58:31 <rongenre> ok, and how to use it in ghc? ;-)
20:58:41 <bd_> bswap...
20:58:47 <Iulus> I'm doing an independent study on Compilers next semester; is there any reason good reason to lean toward Happy or Parsec? Or is it a bit of a toss-up?
20:58:49 <Cale> rongenre: write a C function implementing it and use an FFI import
20:58:57 <bd_> htonl, it's already been done :P
20:58:57 <rongenre> overhead won't kill me?
20:59:15 <Cale> depends, if it does, you can make the C function work on a block of your data
20:59:37 <Cale> But generally, FFI is pretty light
20:59:40 <rongenre> Yeah, got it.. i'm dealing with smallish C structs
21:00:17 <Cale> Iulus: hmm, well, Happy is closer to the "traditional" way of doing things.
21:00:30 <Cale> Iulus: but both of them are decent
21:03:17 <glguy> ?users
21:03:17 <jrockway> '
21:03:19 <zetta> about the bswap, it only has one argument
21:03:22 <jrockway> oops... crazy laptop keyboard
21:03:30 <bd_> *WB* <@Weedy> eretan, when you were born and the doctor said "its a boy" your mom slaped him and told him not to lie <@eretan> nice <@eretan> I always wanted to be a girl
21:03:33 <sorear> How about putting 'static inline uint32_t bswap(uint32_t d) { uint32_t r; asm("bswapl %0, %1" : "=g"(r) : "g"(d)); return r; }' in a header file, using foreign import ccall "bswap" unsafe, and using -fvia-C  ?
21:03:38 <sorear> (that way if you're lucky you'll get inline assembly optimized into the middle of haskell code-blocks)
21:03:48 <sorear> (incase the split ate my suggestion)
21:04:02 <bd_> sorear: I believe on linux htonl is already optimizable in that way...
21:04:28 <bd_> there's a _bswap_32() macro you can use if you don't mind losing portability (bits/byteswap.h)
21:04:32 <bd_> well
21:04:34 <bd_> byteswap.h
21:04:45 <allbery_b> hem, why would it be unsafe?
21:05:09 <sorear> you *really* want to use 'unsafe'.  IIRC normal safe imports require (to avoid blocking all other threads) the creation of an OS thread just for your function.
21:05:17 <sorear> ?bot
21:05:59 <allbery_b> huh.  that sounds odd for a speedup of an otherwise safe computation
21:07:25 <Angel_Monadico> thanks I happy!!!!! I learning this tutorial I like aport  this channel, I'll be back!!!!
21:07:28 <sorear> if you import unsafe a function, and it calls getchar, all the other haskell threads will stop for 'no good reason'.
21:07:28 <allbery_b> especially since if the computation had the ability to block, I'd consider it automatically unsafe
21:07:51 <allbery_b> right, but bswap() should be pure, i.e. no getchar() involved unless soemthing is really messed up somewhere
21:08:17 <Angel_Monadico> my english is not good, but....  mmm jajjajaj
21:08:25 <Angel_Monadico> by
21:08:53 <int-e> allbery_b: it's called 'unsafe' because the compiler can not verify that it's safe; that's up to you.
21:08:58 <sorear> yes - and unsafe is your way of telling the FFI that a foreign function is pure
21:09:18 <sorear> just like unsafePerformIO is you telling the typechecker that an IO action is pure
21:09:21 * allbery_b perhaps has a reversed notion of what safe and unsafe mean in the FFI
21:09:45 <zetta> sounds like the FFI interprets that as whether it applies any of its own "safe"ty measures
21:09:50 <int-e> allbery_b: probably. unsafe = you can do bad stuff with this unless you're painfully careful
21:10:07 <allbery_b> hrm.  I may have to revisit some code I've written (which seemed okay)
21:10:27 <allbery_b> (decidedly not pure code, dumping unix utmp)
21:11:21 <allbery_b> (of course I may look at it and discover that I had it right back then...)
21:11:44 <sorear> unsafe foo :: x  <-  pure, cannot block
21:12:06 <sorear> safe foo :: x  <- pure, may block/take a very long time
21:12:38 <sorear> unsafe foo :: IO x  <-- won't block, but may change/have a side effect, think rand(3)
21:12:54 <sorear> safe foo :: IO x  <-- side effects and blocking - read(2)
21:13:05 <sorear> ^^^ is my understanding
21:13:55 <dibblego> I cannot fool my son anymore; I asked him to draw a line down the centre of a strip of paper taped to make a circle and he failed; then I did it and he said "yeah because you have a moebius strip and I didn't"
21:14:12 <dibblego> on "both sides" that is
21:15:42 <LoganCapaldo> Underestimating their children, the bane of geeky parents everywhere ;)
21:16:10 <sorear> Muahahaha!
21:17:32 <dfranke> Foo.  This concurrent programming course looks underwhelming.
21:17:38 <dfranke> http://www.cise.ufl.edu/class/cop5255sp07/desc.html
21:18:01 <dfranke> JAVA for concurrent programming?
21:18:59 <allbery_b> hm, the FFI document only talks about calling back into Haskell and garbage collections.  I guess I'm okay, then
21:19:16 <lambdabot> Maximum users seen in #haskell: 309, currently: 263 (85.1%), active: 7 (2.7%)
21:19:29 <sorear> allbery_b: when the FFI was written concurrent haskell didn't exist.
21:19:39 <allbery_b> (these calls shouldn't block, unless the system is fvcked, but then I have more important things to worry about than fingerd not working :)
21:19:54 <lambdabot> :)
21:20:05 <sorear> there is somewhere another document on the interaction between concurrency and FFI.
21:20:58 <sorear> allbery_b: if you tell the system that finger is instantaneous, then you won't be able to say forkIO (finger >> putMVar done) and get nonblocking
21:21:02 <lambdabot> Title: COP 5255: Concurrent Programming
21:21:11 <sorear> ?bot
21:21:16 <lambdabot> :)
21:21:24 <sorear> ?uptime
21:21:25 <lambdabot> uptime: 1d 4h 41m 22s, longest uptime: 9d 2h 23m 6s
21:21:26 <sorear> ?seen
21:21:27 <lambdabot> Lately, I have seen allbery_b, dfranke, dibblego, dylan, int-e, logancapaldo, sorear and zetta.
21:21:38 <allbery_b> er, no.  the fingerd is in haskell.  the FFI calls are to getutent()
21:22:40 <sorear> doesn't getutent normally open /etc/passwd?  isn't /etc/passwd normally on a harddisk?
21:22:41 <allbery_b> and there's no forkIO involved in this program, I'd probably have run screaming if I'd found I needed it (being that it was my first "real" Haskell program and was already rather more involved than I'd hoped...)
21:23:00 <allbery_b> /var/run/utmp, typically on ramdisk
21:25:20 <allbery_b> there are other things involving /etc/passwd but those are done in Haskell.  getutxent() is sufficiently weird that I didn't want to try to reimplement in Haskell, much less get it working on both out linux and solaris boxes
21:31:30 <sorear> ?msg sorear-lambdabot ?test
21:32:00 <sorear> I can't keep these command characters straight :(
21:32:50 <mbishop> I thought they were just aliases
21:32:58 <mbishop> like ? and @ were the same or something, *shrug*
21:33:08 <dibblego> ?users
21:33:08 <lambdabot> Maximum users seen in #haskell: 309, currently: 256 (82.8%), active: 15 (5.9%)
21:33:19 <glguy> mbishop: they are
21:33:45 <glguy> aren't they?
21:33:50 <mbishop> @users
21:33:51 <lambdabot> Maximum users seen in #haskell: 309, currently: 256 (82.8%), active: 15 (5.9%)
21:33:54 <mbishop> looks like it
21:34:39 <sorear> ? , @ make lambdabot pay attn, / makes ircII pay attn
21:34:54 <glguy> oh, you were mixing / with ?@
21:34:56 <jrockway> and > makes it eval a statement
21:35:01 <jrockway> > 2 + 2
21:35:02 <lambdabot>  4
21:35:06 <glguy> :t find
21:35:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:35:10 <glguy> :k Maybe
21:35:12 <lambdabot> * -> *
21:35:20 <glguy> and :t and :k are special cased
21:35:20 <jrockway> :set +t
21:35:25 <jrockway> ah
21:35:31 <jrockway> :foldr
21:35:35 <jrockway> :t foldr
21:35:36 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
21:35:51 <jrockway> that's useful
21:35:57 <glguy> alias for
21:35:59 <glguy> ?type foldr
21:36:01 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
21:37:46 <sorear> I wanted /
21:37:59 <jrockway> :)
21:38:32 <sorear> glguy: yes.
21:38:46 <sorear> (Doesn't help that ?msg is also a LB command)
21:38:56 <glguy> ha, canadians drive cars with square wheels
21:39:15 <mbishop> their milk comes in bags
21:39:15 <sorear> how many? 2?
21:39:18 <glguy> and the tops of their heads flop around when they talk
21:40:04 <sorear> (anyway, lambdabot-with-irc-as-a-plugin is almost completely functional, and attached to the network)
21:40:19 <kermhermit> Does lambdabot have a command to show operator fixity/precidence?
21:40:26 <glguy> nope, but ghci does
21:40:42 <kermhermit> crud.
21:40:45 <sorear> :i (==)
21:42:02 <mbishop> that's what I hate about non prefix languages (and math) :P
21:42:27 <jcreigh> what's with "forall" in the type signature? How does, eg, "forall a. a -> [a]" differ from "a -> [a]"?
21:42:51 <glguy> jcreigh: it does no
21:42:51 <glguy> t
21:43:21 <jcreigh> oh, okay. Why is it there then?
21:43:22 <kermhermit> So lambdabot doesn't have a manual?  The command list doesn't explain much.
21:43:41 <sorear> ?version
21:43:41 <lambdabot> lambdabot 4p307, GHC 6.5 (OpenBSD i386)
21:43:41 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:43:41 <mbishop> ?list
21:43:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
21:43:44 <glguy> jcreigh: the forall is implied, lambdabot is just being more explicit about it
21:43:45 <sorear> ^^^ the manual
21:47:51 <kermhermit> thanks sorear
21:52:19 <sorear> ?list tell
21:52:19 <lambdabot> tell provides: tell ask messages messages? clear-messages
21:53:19 <sorear> ?seen dons
21:53:19 <lambdabot> dons is in #ghc, #haskell-overflow, #haskell and #haskell.hac07. I don't know when dons last spoke.
21:53:31 <glguy> ?uptime
21:53:31 <lambdabot> uptime: 1d 5h 13m 28s, longest uptime: 9d 2h 23m 6s
21:53:37 <sorear> ?users #haskell.hac07
21:53:37 <lambdabot> Maximum users seen in #haskell.hac07: 11, currently: 7 (63.6%), active: 0 (0.0%)
21:53:48 <glguy> dons is on vacation :)
21:54:19 <sorear> Yes, but lambdabot frees me from asking 'Are you back yet' :)
21:54:41 <glguy> he should have set a bitchX /away message
21:54:45 <glguy> to let us know every 10 minutes
21:56:16 <sorear> I think people should /quit when they stop paying attention, and check the @logs when they get back.
21:56:17 <jrockway> hahaha
21:56:40 <jrockway> a lot of people use IRC as email :)
21:56:41 <glguy> sorear: I think I should maintain week long irc uptimes
21:56:45 <jrockway> as in "foo: ping"
21:57:09 <glguy> [signon: Tue Dec 12 10:03:04
22:02:17 <mutjida> @logs
22:02:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
22:02:41 <sorear> glguy: I've succeeded in separating IRC out into its own plugin (now lets see if dons will take the 3-kline patch...)
22:03:01 <glguy> 3 kline?
22:03:18 <glguy> oh
22:03:19 <glguy> 3000
22:03:20 <sorear> 3k line
22:03:46 <glguy> congrats
22:04:22 <sieni> well, `kilo-' is a prefix, so I guess 3 kline would be more correct than 3k line ;-)
22:05:02 <glguy> i was thinking irc klines
22:06:38 <sieni> not kevin kline?
22:06:57 <glguy> nope :)
22:08:49 * mgsloan would think an irc lib would be more logical, but suit yahself
22:09:53 <int-e> l
22:10:42 <sorear> I think those two changes are orthogonal
22:11:17 <sorear> with just an IRC lib, the core doesn't depend on IRC, but you can still only have one server etc.
22:11:18 <mgsloan> though pluginizing probably makes the step to lib easier
22:14:04 <sorear> The patch w/o context is 2530 lines; flattened into a single giant change it is 1481 lines...
22:14:20 <sorear> (Appearantly I did a lot of self-undoing)
22:22:07 * glguy turns his font way up and tries IRCing from the couch across the room
22:23:55 <bd_> *WB* <@Weedy> eretan, when you were born and the doctor said "its a boy" your mom slaped him and told him not to lie <@eretan> nice <@eretan> I always wanted to be a girl
22:24:06 <glguy> wtf?
22:28:45 <sorear> is bd_ an autogreet bot?
22:29:01 <bd_> oO
22:29:05 <bd_> that's not supposed to be on here
22:29:16 <bd_> >.>;
22:30:00 * sorear twists sideways and tries to figure out whether that's an infix operator on an emoticon
22:39:46 <Cale> sorear: it's a non-sideways emoticon
22:39:58 <glguy> with an earring
22:40:26 <glguy> glasgow was mentioned on TV for having good curry
22:40:46 <glguy> why would you bother stating that instead of GHC?
22:40:49 <glguy> i don't get it
22:40:52 <sieni> there's a eroticon for you: <3==3
22:40:53 <Cale> I think it's supposed to be sweat.
22:40:59 <Cale> (the ;)
22:41:29 <mgsloan> hmm, the problem with IORefs is i still have to pass em around
22:41:40 <glguy> mgsloan: they just need to be in scope
22:42:28 <mgsloan> true, I have taken advantage of lambda shtuff
22:42:34 <Cale> You can create an IORef in a do block, and define a bunch of things in a let-statement in that block which use that IORef.
22:42:42 <mgsloan> yep
22:43:03 <glguy> Hmm... I need to not be blind
22:43:07 <mgsloan> so, it'd be impossible to have a global, even if it was of IO type?
22:43:40 <mgsloan> eg myfunc :: IORef a, yet it always returns a pointer to the same, mutable thing
22:43:42 <glguy> mgsloan: you'd need to be in the IO monad to read or write such a variable
22:43:52 <mgsloan> I wouldn't mind ;)
22:45:11 <Cale> You can get myfunc as the left hand side of an <- in a do-block.
22:45:33 <sjanssen> it is possible to have a global variable.  But it is a hack and you really really shouldn't do it
22:45:47 <mgsloan> yeah, unsafePerformIO
22:45:53 <mgsloan> not gonna go there though
22:46:07 <mgsloan> I think something like a global, in the context of IO should be fine though
22:46:39 <Cale> ReaderT (IORef t) IO a
22:46:54 <mgsloan> Cale - I'm not sure i understand that - do you just mean foo <- newIORef 0
22:46:55 <glguy> LOL @ private investigator advertising on TV for catching your spouse cheating
22:47:08 <Cale> mgsloan: with my previous comment, yes
22:47:20 <sorear> lambdabot uses type LB a = ReaderT (IORef StateRec) IO a
22:47:29 <Cale> This monad basically has an IORef which is carried as a global environment.
22:48:01 <mgsloan> ah, that should be good.  The stuff I have here says that reader is the easier, less general state ;p
22:48:02 <glguy> do ref <- ask; val <- liftIO (readIORef ref)
22:48:36 <Cale> ReaderT basically adds a single global constant to a computation.
22:48:59 <glguy> do val <- liftIO . readIORef =<< ask
22:49:32 <mgsloan> constant eh? that means the computation does not change it?
22:49:38 <Cale> right
22:49:44 <sorear> int *const foo;
22:49:51 <sorear> ^^^ that's what this is.
22:49:52 <mgsloan> ohh, but its an IORef
22:49:52 <Cale> in this case, you're not going to replace the IORef with another IORef
22:49:53 <mgsloan> nice
22:49:58 <glguy> :t modify
22:49:59 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
22:50:02 <glguy> oops
22:50:04 <glguy> :t local
22:50:05 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:50:06 <Cale> :t local
22:50:07 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:50:15 <Cale> you can replace it locally if you'd like
22:50:17 * glguy is aware tht this is a nested change
22:50:50 <Cale> that's essentially equivalent to running a new ReaderT though.
22:51:04 <Cale> (it's just a convenience)
22:52:44 <jcreigh> Is it legal to say "data Match = Match String String deriving (Show, Eq)" (ie, constructor with same name as datatype?)
22:52:59 <glguy> yes
22:53:15 <Cale> This is even common usage.
22:53:15 <mgsloan> so ReaderT _ IO _ would be more convenient?
22:53:36 <Cale> mgsloan: it might be -- you wouldn't have to pass the IORef explicitly.
22:53:49 <Cale> You would, however, have to liftIO every IO action you wanted to use.
22:53:56 <mgsloan> ah
22:54:19 <jcreigh> cool, so it's legel and not a horrible idea.
22:54:35 <mgsloan> good idea, really, I do it all the time
22:55:24 <mgsloan> though it might confuse the concepts of type identifier and constructor, which isn't a good thing.  Haskell compilers and haskell users can tell the difference by context though
22:55:26 <glguy> it's always possible to determine which of the two you meant when you use them from the context
22:55:46 * ski prefers naming the constructor like 'MkMatch' if no better naming presents itself
22:55:59 <Cale> jcreigh: yeah, just be careful using it around beginners because you can end up confusing them as to the difference between data and type constructors.
22:56:27 <ski> (also note that if you name them the same, you can't decide to import one of them and not the other, from the containing module)
22:56:36 <Cale> If I'm not exporting the data constructor, I often get lazy and use a shortform like M.
22:56:41 <ski> (s/import/export/)
22:56:49 <jcreigh> Well, I was using a (String, String) before, I'm just trying to clean up a program a little.
22:57:15 * ski uses such 'M', too
22:57:44 <ski> i would like ghc to support restricted type synonyms, in some forme ..
23:01:38 <jcreigh> forall a (m :: * -> *). (MonadPlus m) => (a -> m a) -> a -> m a
23:01:47 <jcreigh> ^^ what does "* -> *" mean?
23:01:57 <Cale> m takes types and produces types
23:02:07 <Cale> It's a kind
23:02:24 <Cale> @kind State Integer
23:02:25 <lambdabot> * -> *
23:02:32 <Cale> @kind []
23:02:33 <lambdabot> * -> *
23:02:35 <mgsloan> @kind State
23:02:36 <lambdabot> * -> * -> *
23:02:44 <Cale> @kind RWST
23:02:45 <lambdabot> Not in scope: type constructor or class `RWST'
23:02:48 <jcreigh> oh, so, eg, Maybe is a kind, and Maybe Int is a type?
23:02:48 <glguy> ?kind (->)
23:02:50 <lambdabot> ?? -> ? -> *
23:02:52 <Cale> @kind Control.Monad.RWS.RWST
23:02:53 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
23:03:00 <Cale> jcreigh: no
23:03:08 <Cale> jcreigh: Maybe has kind * -> *
23:03:11 <mgsloan> ?kind Maybe Int
23:03:12 <lambdabot> *
23:03:16 <Cale> Maybe Int has kind *
23:04:03 <jcreigh> ?kind Either
23:04:03 <sorear> A kind is what you call the type of a type.
23:04:05 <lambdabot> * -> * -> *
23:04:09 <sorear> ?kind Int
23:04:10 <lambdabot> *
23:04:24 <sorear> ?kind StateT
23:04:26 <lambdabot> * -> (* -> *) -> * -> *
23:04:35 <Cale> RWST has kind * -> * -> * -> (* -> *) -> * -> *, because it takes three types (environment, log, state), a type constructor (the monad being transformed), and another type (result), and produces a type (computation)
23:05:10 <mgsloan> yikes
23:05:34 <sorear> In the same way, (.) has type (a -> b) -> (c -> b) -> c because it takes a function, and another function, and a value and produces a result.
23:05:54 <sorear> Values have types, types have kinds.
23:06:13 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
23:06:41 <sorear> yeah, that'll teach me to use my builtin typechecker :)
23:06:43 <jcreigh> so in the type signature I pasted, the "m :: * -> *" serves to restrict the instance of MonadPlus to those with "kind" * -> *, is that correct?
23:06:52 <sorear> yes
23:06:57 <jcreigh> hmm
23:07:02 <Cale> That's going to be required by the class anyway
23:07:08 <sorear> except, all instances of MonadPlus have kind * -> *
23:07:16 <Cale> the kind declaration there is superfluous, but it prints it anyway
23:07:31 <sorear> :t (undefined :: a b -> a c)
23:07:32 <lambdabot> forall (a :: * -> *) b c. a b -> a c
23:08:32 <sorear> the system can always determine the kind of a type variable by looking at its uses, but sometimes it can help humans.
23:08:45 <jcreigh> okay, so it's useless in that context. But what is it about MonadPlus that ensures that its instances will have kind * -> *?
23:09:01 <Cale> the way it uses its parameter
23:09:04 <sorear> class Monad where
23:09:10 <sorear> class Monad m where
23:09:15 <sorear>   return :: a -> m a
23:09:19 <Cale> class MonadPlus m where
23:09:24 <Cale>    mzero :: m a
23:09:40 <sorear> since m is applied to one argument and used as a type, m must have kind * -> *.
23:09:50 <sorear> class Arrow a where
23:09:54 <Cale>    mplus :: m a -> m a -> m a
23:10:03 <sorear>    arr :: (b -> c) -> a b c
23:10:04 <Cale> @type arr
23:10:06 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
23:10:36 <sorear> Here a is applied to two types before being used as a type, so Arrow needs a kind of (* -> * -> *).
23:10:46 <Cale> If you want, with GHC, when declaring a class, you can include the kind signature yourself.
23:11:05 <Cale> This is rarely necessary if your class has any methods.
23:11:17 <ski> :t \f a -> f a `mplus` return a
23:11:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> m a) -> a -> m a
23:11:38 <ski> :t ((\f a -> f a `mplus` return a) :: forall m a. (MonadPlus m) => (a -> m a) -> a -> m a)
23:11:39 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> m a) -> a -> m a
23:11:46 <ski> :t ((\f a -> f a `mplus` return a) :: (MonadPlus m) => (a -> m a) -> a -> m a)
23:11:48 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> m a) -> a -> m a
23:12:19 <ski> (the kind annotation on 'm' can be left out, since it will be inferred here anyway)
23:13:21 <sorear> (One odd thing I've noticed is that the kind of all inhabited types is *.  That is, the generalized type-of operator, applied twice to anything, always gives a 'null' value.  I wonder how hard it would be to make type-of into something like a coboundary operator?)
23:16:30 <jcreigh> thanks for all the info, everyone. (Cale, sorear, ski, mgsloan) I've got something to chew on for a while now.
23:18:41 <Cale> :|  http://programming.reddit.com/info/viqs/comments/cvptw?context=1
23:18:43 <lambdabot> Title: Why haven&#39;t you written a book about Haskell? (reddit.com)
23:20:48 <jcreigh> well, I can't bring myself to disagree with his assessment of his own intelligence...
23:28:41 <mgsloan> hmm, I think writing C++ on windows is like monads - you can learn it now, but the best way is if you are there when they are invented and everyone else is in the same position as you
23:29:18 <mgsloan> or like switching schools - if everyone is new, then its great.  If you're the only new one it sucks
23:30:58 <mgsloan> one thing that seems strange to me, with the IO monad, is that with IO functions this would make more sense:
23:30:58 <mgsloan> foo :: bar1 -> bar2 -> IO -> IO -- foo is the transition from one IO state to another
23:31:14 <matthew__> that's EXACTLY what IO is
23:31:32 <matthew__> data IO a = RealWorld -> (a, RealWorld)
23:31:35 <matthew__> more or less
23:31:43 <matthew__> IO a IS a function
23:31:55 <mgsloan> hmm
23:31:56 <matthew__> :t putStr
23:31:57 <lambdabot> String -> IO ()
23:32:12 <matthew__> == String -> RealWorld -> ((), RealWorld)
23:32:57 <matthew__> read IO_Inside
23:33:07 <matthew__> ?wiki IO Inside
23:33:07 <lambdabot> http://www.haskell.org/haskellwiki/IO Inside
23:33:27 <mgsloan> makes sense.  I'd actually rather just pass around RealWorld
23:33:27 <sjanssen> matthew__: now supply a defn. of RealWorld :)
23:33:32 <mgsloan> heh
23:33:50 <matthew__> sjanssen: err, sure, I'll just go out and record the state of /everything/ !
23:34:33 <matthew__> it's a real pain sometimes that neither ghc nor hugs allow you to decompose IO
23:34:45 <mgsloan> that could be pretty handy - especially if the realworld is deterministic and somehow haskell programs go faster than the universe machine
23:34:46 <matthew__> I guess it's quite deliberate mind
23:35:39 <sjanssen> matthew__: why would you want to decompose IO?
23:36:39 <mgsloan> show (x::RealWorld) of course!
23:36:39 <matthew__> err, well some of the examples in IO_Inside assume that the lhs RealWorld really does turn up, so you should bind it to something
23:37:40 <matthew__> if you were careful you could avoid use of >>= and >> and still be safe if you could route the RealWorld round yourself
23:37:56 <matthew__> of course you'd have to be careful you don't fork the earth
23:38:23 <sjanssen> you could write an even more evil version of unsafePerformIO with it
23:38:53 <sjanssen> f :: RealWorld -> a -- could actually perform IO
23:39:05 <matthew__> yup
23:40:02 <mgsloan> I suppose if RealWorld was incorporated into a (inclusion in a constructor or someat), and a was required for the solution
23:40:15 <sieni> it wouldn't need to since the computer and the program running in it would be inside the RealWorld and then the RealWorld would perform the IO on your behalf
23:41:15 <glguy> ?seen Cale
23:41:15 <lambdabot> Cale is in #ghc, #haskell and #oasis. I last heard Cale speak 22m 33s ago.
23:41:30 <ski> in Clean, you can pass around the world explicitely
23:41:39 <glguy> Cale: do you have that link to your fold diagrams handy? I'm trying to figure out if something isa scan
23:41:55 <ski> because they have a uniqueness type system that checks that you don't try to duplicate the world
23:42:26 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
23:42:27 <ski> Start :: *World -> *World   -- Clean's 'main'
23:42:30 <lambdabot> Title: Fold Diagrams - CaleWiki
23:43:04 <sieni> ski: I wonder if you could try to duplicate the world in a quantum computer
23:43:19 <ski> hehe
23:44:55 <ski> sorear : "always gives a 'null' value" ?  'coboundary operator' ?
23:47:15 <lisppaste2> glguy pasted "Does this reduce any futher using folds or scans?" at http://paste.lisp.org/display/33261
23:47:29 <lisppaste2> mgsloan pasted "Gtk Mouse State" at http://paste.lisp.org/display/33262
23:47:34 <glguy> I'm trying ot figure out if that map is necessary
23:47:51 <glguy> not so much to make it smaller
23:47:58 <glguy> but I feel like I'm making this harder than it is
23:48:17 <mgsloan> can someone fill in the ARGH sections and otherwise?  Would probably clarify how to actually do things...
23:48:25 <ski> sjanssen : how could that 'f' perform any I/O ? I/O is only performed when the returned 'RealWorld' from 'main' is forced, no ? :)
23:48:52 <sjanssen> I suppose that's implementation specific
23:49:23 <sjanssen> nevermind, I see what you're saying
23:49:55 <sjanssen> I mean that f :: RealWorld -> a -- is not necessarily referentially transparent if you can deconstruct IO
23:50:21 <glguy> > (\xs -> [(a,b,c) | (a,b:c) <- zip (inits xs) (tails xs)]) [1..4]
23:50:22 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
23:50:38 <Cale> I was about to suggest that :)
23:51:12 <glguy> that's probably the clearest way to do it
23:51:26 <Cale> or with parallel comprehensions
23:51:34 <Cale> allSlices zs = [(xs,y,ys) | xs <- inits zs | (y:ys) <- tails zs]
23:51:37 <lispy> ?bot!
23:51:38 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
23:51:44 <lispy> what is the missing argument?
23:51:55 <glguy> I don't understand what happens when parallel comprehensions fail to pattern match
23:52:05 <sjanssen> bot! spell corrects to vote, apparently
23:52:06 <sjanssen> @vote
23:52:07 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
23:52:23 <Cale> the item isn't produced
23:53:01 <glguy> Cale: it just seemed to behave differently than when the zip version failed ot match
23:53:09 <lispy> sjanssen: ah, weirdness
23:53:19 <Cale> It should be the same here.
23:55:17 <povman> hi!
23:56:08 <lispy> povman: hi
23:57:01 <povman> question:
23:57:07 <sorear> answer.
23:57:15 <povman> is it possible to match multiple patterns to the same thing
23:57:21 <povman> whoa that was quick
23:57:34 <sorear> like:
23:57:43 <sorear> foo pat1 = long_thing
23:58:00 <sorear> foo pat2 = same_long_thing_id_rather_not_repeat
23:58:05 <sorear> foo _ = something_else
23:58:09 <sorear> ?
23:58:18 <povman> case var of
23:58:18 <povman> (1 or 2 or 3) -> "small number"
23:58:19 <povman> otherwise -> "big number
23:58:24 <povman> ?
23:58:33 <povman> (pseudo haskell)
23:58:38 <sorear> Not that I'm aware of.
23:58:48 <povman> i've wanted that functionality more than once
23:58:53 <povman> hm, bugger.
23:58:57 <sorear> When it really gets bad, I usually wind up doing:
23:59:21 <sorear> case (case var of 1 -> True ; 2 -> True ; 3 -> True ; _ -> False) of
23:59:25 <mgsloan> x | x `elem` [1,2,3] ->
23:59:27 <glguy> > let f xs = [(b,(a ++).(:c)) | (a,b:c) <- zip (inits xs) (tails xs)] in [g 99 | (a,g) <- f [1..10], a == 7]
23:59:28 <lambdabot>  [[1,2,3,4,5,6,99,8,9,10]]
23:59:28 <sorear>    True -> "small number"
23:59:29 <mgsloan> ?
23:59:35 <sorear>     Fasle -> "large number"
