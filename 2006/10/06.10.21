00:06:36 <satan> anyone? :(
00:07:05 <dons> anonfunc: its a quiet time of the day, Cale, our resident categorist, might be sleeping
00:07:10 <dons> s/satan/
00:07:26 <profmakx> hes chatting in #math so he isnt exactly sleeping ;)
00:07:43 <Cale> yeah, I'm just occupied :)
00:07:44 <dons> ?localtime Cale
00:07:45 <lambdabot> Local time for Cale is Sat Oct 21 03:03:08
00:07:51 <dons> still, he _should_ be sleeping
00:07:53 <dons> ;)
00:08:00 <satan> holy crap, oh right, he's in toronto
00:08:06 <Cale> not quite
00:08:08 <Cale> Brantford
00:08:09 <satan> i was in toronto over the summer, beautiful city, loved it
00:08:13 <satan> right, sorry
00:08:17 <satan> ontario anyway :)
00:08:50 <Cale> Brantford is a really boring place. If you're ever in town, visit the downtown for a good laugh.
00:09:03 <satan> downtown brantford?
00:09:09 <satan> or downtown toronto?
00:09:15 <Cale> Yeah. There are buildings with boards in the windows with cheap paintings of what might be there, but isn't.
00:09:20 <Cale> Brantford.
00:09:21 <satan> haha ouch
00:09:40 <satan> but you like it there?
00:09:47 <Cale> In its defense, there is a new sort of uptown area which is more like a downtown.
00:09:54 <Cale> Well, we have a nice place.
00:10:02 <Cale> It's right on the edge of a forest.
00:10:20 <Cale> and has a nicely large backyard
00:10:38 <Cale> and the crime rate is decently low
00:10:54 <satan> thats pretty good then
00:10:55 <Cale> but the city itself is incredibly dull.
00:11:04 <satan> ah, are you the partying type?
00:11:09 <Cale> Well, not even
00:11:37 <satan> how far is toronto? 2 hrs?
00:11:51 <Cale> 1.5 or so
00:12:26 <satan> not bad
00:12:42 <satan> i'll assk you the category theory question, you seem busy
00:12:49 <Cale> okay
00:12:50 <satan> ask it later, i meant*
00:12:53 <Cale> I'm not that busy
00:12:56 <Cale> hehe
00:13:06 <satan> heh ok :)
00:13:08 <Cale> Just that holding multiple conversations is tricky
00:13:13 <satan> yeah fair enough
00:13:22 <satan> well, whenever you get a sec, i can re-paste it
00:13:32 <Cale> How is f defined on arrows?
00:13:47 <satan> not sure, all i have is what i typed
00:14:19 <Cale> okay
00:14:29 <Cale> so we need a reasonable way to even turn f into a functor
00:14:56 <satan> right
00:15:53 <satan> so f is the arrow that goes from 0 ----------> A, right?
00:16:03 <sieni> satan: what's a 2 hour distance? like 2 lighthours?
00:16:29 <Cale> satan: fA is, I suppose
00:16:29 <satan> and a functor works on types, so from type F to type G
00:16:29 <satan> right, fA, i meant
00:16:33 <satan> sieni: 2 hours driving
00:16:53 <Cale> so I suppose that if g: X -> Y, then fg is the triangle with 0, X, and Y
00:17:10 <weitzman> sieni: I think the traditional unit is in with respect to the speed at which you can travel on a camel
00:17:11 <RyanT5000> what's a good thing to design a GADT for?
00:17:32 <Cale> RyanT5000: an EDSL :)
00:17:47 <RyanT5000> do you have a suggestion of a simple one?
00:17:52 <satan> Cale: hmm i had a triangle with O, F , G but i put down F and G as the arrows, since they were the functors
00:17:59 <RyanT5000> other than the ones on the GADT page in the haskell wiki
00:18:00 <sieni> I prefer the speed in which you can ski in a waist deep show with a 30kg backpack
00:18:03 <RyanT5000> cause i already read that
00:18:04 <satan> but i guess, they are the objects? not the arrows?
00:18:32 <Cale> So I suppose what we're looking at is a functor from the category C to the coslice category of C with respect to 0
00:18:54 <satan> coslice?
00:19:12 <Cale> http://en.wikipedia.org/wiki/Comma_category -- read "category of objects under A"
00:19:18 <weitzman> http://twain.thefreelibrary.com/The-Innocents-Abroad/50-1
00:19:21 <lambdabot> Title: The Innocents Abroad - Mark Twain - Free Online Library, http://tinyurl.com/uqkxk
00:19:34 <weitzman> Mark Twain: "All distances in the East are measured by hours, not miles."
00:19:37 <Cale> but since it's over 0, those diagrams are always going to commute
00:25:55 <Cale> so FX = 0 for all objects X
00:25:57 <Cale> argh
00:25:58 <Cale> so FX = 0 for all objects X
00:26:20 <satan> right
00:26:21 <Cale> what's with all the netsplits?
00:26:36 <Cale> and GX = X for all objects X
00:26:46 <satan> ok
00:27:05 <Cale> so the second functor G is almost certainly the identity functor
00:27:18 <Cale> do we have a functor which sends all the objects to 0?
00:27:29 <satan> ok awesome, that was my initial answer too
00:27:34 <Cale> there's only one map from 0 -> 0, so it would have to send all the arrows there too
00:27:44 <satan> the constant function?
00:27:47 <Cale> id
00:27:48 <satan> not sure
00:27:54 <satan> oh
00:27:58 <Cale> and why is there only one?
00:28:02 <Cale> :)
00:28:29 <satan> because it doesnt matter, right? the answer is always 0
00:28:41 <Cale> errr...
00:28:42 <satan> oh
00:28:50 <satan> because its an initial object
00:28:53 <Cale> right
00:29:06 <satan> lol sorry
00:29:11 <Cale> that's okay :)
00:29:42 <satan> so they're both id ??
00:29:42 <Cale> so now all we have to do is show that the diagram commutes
00:29:50 <Cale> what I'm saying is that
00:30:06 <Cale> Fg for every morphism g is id_0
00:30:24 <Cale> because to say what a functor is, you have to define it on both objects and morphisms
00:30:42 <satan> oh i see
00:31:04 <Cale> so now there's only one thing left to check
00:31:16 <Cale> and that's that f is a natural transformation F -> G
00:31:30 <Cale> now that we know what F and G are :)
00:31:41 <satan> right
00:32:40 <Cale> So we need to know that the square, which is really a triangle, commutes
00:32:50 <satan> so to do that, we have to show that for every object in F, fF -> fG?
00:32:51 <Cale> http://en.wikipedia.org/wiki/Natural_transformation -- the first one here
00:32:54 <lambdabot> http://tinyurl.com/umyzp
00:33:01 <satan> yeah i'm on that page too
00:33:37 <satan> ok so the corners are F(X), F(Y), G(X), G(Y)
00:33:44 <Cale> damn, I wish our natural transformation was not called f
00:33:51 <Cale> can we call it eta?
00:34:00 <satan> ok
00:34:12 <Cale> eta: F -> G
00:34:32 <Cale> we need to show that for every morphism f: X -> Y in C, we have:
00:34:50 <Cale> eta_Y . Ff = Gf . eta_X
00:35:12 <Cale> I think it's best to just work out what arrow each of those are :)
00:35:21 <Cale> first of all, what are their types
00:35:30 <Cale> eta_Y : 0 -> Y
00:35:57 <Cale> Ff = 0 -> 0
00:36:04 <Cale> (because F is the zero functor)
00:36:23 <Cale> so the composite goes from 0 -> Y
00:36:29 <satan> right
00:36:47 <Cale> also, the composite Gf . eta_X will go from 0 to Y
00:37:05 <satan> so Gf: 0 -> Y as well
00:37:10 <Cale> no
00:37:16 <Cale> Gf : X -> Y
00:37:19 <Cale> since Gf = f
00:37:37 <satan> oh ok
00:37:46 <Cale> and eta_X : 0 -> X
00:38:07 <Cale> however, the important thing is that they're both maps 0 -> Y
00:38:15 <Cale> what do we know about any two maps 0 -> Y?
00:38:21 <satan> i see
00:38:27 <satan> they must be the same?
00:38:30 <Cale> right
00:38:39 <Cale> because 0 is initial, and that's what it means to be initial
00:38:47 <satan> only one arrow going outward
00:38:54 <Cale> right, to every object
00:39:03 <satan> ah, to every object, ok
00:39:11 <Cale> in fact, including to itself :)
00:39:25 <satan> and that one's called the id function
00:39:36 <Cale> well, it happens to be the id function
00:39:42 <satan> ah ok
00:39:45 <Cale> every object has an id function, right?
00:39:47 <satan> right
00:40:35 <Cale> Yeah, the right way to say it is that there is exactly one function 0 -> X for every X.
00:40:40 <Cale> or, morphism rather :)
00:41:01 <satan> which are arrows in category theory, if i'm not mistaken
00:41:28 <Cale> arrow and morphism mean the same thing
00:41:37 <satan> oh ok
00:42:09 <vegai> hmm, time to wrap happs in an arch package...
00:42:16 <Cale> functions are actually usually considered only to be the morphisms in the category of sets, but there's nothing wrong with calling the arrows of some other category functions either.
00:42:21 * vegai gets the gift paper
00:42:36 <satan> i see
00:43:21 <Cale> It's just that the intuition is that functions are actually acting on individual elements of an object, producing elements of another other object.
00:43:34 <Cale> arrows in general are not so constrained
00:43:45 <Cale> they might not correspond to functions at all in the usual sense
00:43:52 <satan> hmm
00:43:54 <sieni> yea
00:44:39 <Cale> They might correspond to functions, plus some extra stuff, or something which doesn't look like a function in any obvious way :)
00:45:04 <satan> so what we did, if i may recap, was to prove they commuted by showing that the compositions of morphisms were really the same type
00:45:18 <satan> wow this is all a bit much :)
00:45:30 <satan> how long did it take for you to get all this, Cale?
00:45:31 <Cale> well, what we really used was that 0 was initial
00:45:39 <satan> ok
00:45:48 <Cale> well, remember I have a Bachelor's degree in pure mathematics
00:46:02 <satan> sheesh no wonder
00:46:17 <Cale> For the first 3 years, you spend all your time essentially learning examples of categories.
00:46:28 <satan> do you work as a coder? mathematician?
00:46:38 <satan> oh my, 3 years :(
00:46:38 <Cale> I'm still looking for work
00:46:52 <Cale> and in the 4th year, a lot of what you learn starts coming together in sometimes category-theoretic ways
00:47:06 <satan> good luck :)
00:47:08 <satan> ah i see
00:47:09 <Cale> You don't *need* all that to learn category theory
00:47:25 <Cale> But it does help a lot to have good, well-developed examples of categories
00:47:40 <Adamant> Cale, do you think mathematicians are using category theory more over ZF set theory these days?
00:47:48 <satan> so whats the best way to learn it? Realize that categories can be acted upon by functors, which in turn must satisfy 2 rules...
00:47:53 <Cale> Sets, Vector spaces, Groups, Rings, Metric Spaces, Topological spaces
00:48:05 <satan> is there a good introduction to it for newbies?
00:48:05 <Cale> Adamant: ZFC is considered the foundation
00:48:39 <Cale> Adamant: the way I think most people look at it is that set theory is right at the base of mathematics, and category theory is right at the tip, the other end
00:48:52 <Cale> and everything develops outward to the sides :)
00:49:14 <Adamant> Cale, I mean more that some have proposed using category theory as the basis for math
00:49:17 <Cale> So mathematics looks a bit like two cones stuck together at their bases
00:49:34 <Cale> right, and you could do that, but you'd be turning it all upside down :)
00:49:40 <Adamant> ah. :)
00:50:25 <Cale> You'd be approaching things initially from this incredibly general place and working your way down to more specific things.
00:51:04 <Adamant> cool.
00:51:08 <Cale> Whereas sets are typically viewed as the height of concreteness. (Even though when you get right down to it, there are lots of things about them which aren't so concrete)
00:52:35 <Cale> It actually seems best in the teaching of mathematics, to start somewhere in the middle, but closer to the concrete side of things.
00:52:47 <sieni> what? do you consider supercompact cardinals "not conrete"?!?!?1
00:52:50 <Adamant> ah.
00:52:55 <Cale> sieni: hehe
00:53:56 <Cale> http://en.wikipedia.org/wiki/Unfoldable_cardinal :)
00:53:58 <lambdabot> http://tinyurl.com/yesc63
00:54:31 <Cale> yeah, and supercompact cardinals are that sort of definition too
00:54:38 <Cale> http://en.wikipedia.org/wiki/Supercompact_cardinal
00:54:40 <lambdabot> http://tinyurl.com/y54dgp
00:56:11 <Cale> Sets which depend on the existence of certain elementary embeddings of various set theories into other models are rather bizarre. :)
00:57:26 <Cale> But yeah, the basic initiate level of set theory which everyone generally picks up at some point or another is extremely concrete, apart from perhaps the axiom of choice, which still has a reasonable level of intuition behind it.
03:25:16 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
03:25:16 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
03:25:16 --- names: list (clog cdfh Skal chris2 paolino ex_nor araujo pesco BCoppens ex0-r fasta dottedmag jmmv AStorm ibid Oejet integral Bobstopper binrapt bonfyre Jaak Codex_ wilx norpan Akheron kpk nnunley bcorn audreyt gaal Igloo dylan epiphone wolverian ski uebayasi mattam Muad_Dib gour slipstream sieni df_ dcoutts SamB Twigathy Wallbraker eno-away jgrimes pingu newsham Cale tessier giksos satan shobadobs boliver_ yip pandres erider zamez sethk therp dporter)
03:25:16 --- names: list (velco sellout Plareplane kisu RyanT5000 olliej Eidolos Blackfoot lokadin_ ajonat Betovsky svens_ anonfunc binary42_ dblog Adamant dfeuer falseep x3m converter__ Captain_Fourier maskd sris dgoldsmith Trixsey expwiz wchogg Pupeno sylvan psi thou cods shapr xinming osfameron Narcisse dvekravy_ Smokey` scw scsibug_ Philippa_ Averell kpreid Patterner Baughn lispy Mibori nothingmuch atsampson ulfdoz_ matthew-_ drbean lisppaste2 TwigEther eshrgrgfewgfe)
03:25:16 --- names: list (l_a_m explicitjelly profmakx lennart unclear Lemmih JohnMeacham vegai mr_ank jdev lambdabot dany2k ValarQ gdsx jmob musasabi magagr aleator bran_ bdash Lunar^ Nioate thebug arcatan mathrick Tigge cpatrick ozone rafl shawn orbitz ohub klutometis dropdrive noj void lucca moconnor nick8325 qwr irgs Xgc dfranke matthew__ ksandstr meddle carp liyang DRMacIver Daveman johs GeoBes1 xerox dons triple_ szabi_ qz Perite mathewm moonlite woggle kzm)
03:25:16 --- names: list (gds tmoertel_away mlh TSC SamB_XP eyck dcoutts_ ChilliX psnl greenrd phr-newbie resiak astrolabe fnordus Syzygy- kalven sjanssen Khisanth saccade flux__ tessier_ cmeme emu pejo rycee mux SimonRC earthy Spark kaol mornfall Azmo Maddas cjay cathper petekaz dwm kolmodin shrimpx)
04:36:19 <Matric1> Hi anyone know any good books i can use to learn haskell as a newbie??
04:37:46 <velco> http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
04:37:49 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y4yvp2
04:38:12 <velco> I'm reading this ATM, seems fine so far http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
04:38:14 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition, http://tinyurl.com/fogow
04:39:17 <Magicman> There's also a Haskell wikibook which might be useful.
04:39:21 <Magicman> http://en.wikibooks.org/wiki/Haskell
04:40:10 <Magicman> But if you prefer offline reading, you should use the ones velco linked to.
04:43:31 <Matric1> yeah thanks ppl velco iam reading that book also
04:44:23 <Matric1> but i find some bits confusing
04:46:07 <velco> well, I guess that's what the channel is for (among other things)
05:00:13 <araujo> @yarr!
05:00:13 <lambdabot> Arr! Me ship be the biggest brig in the port!
05:00:26 <beelsebob> shiver me timbers!
05:00:37 <Matric1> jaaar
05:01:45 <Matric1> who knows haskell here?
05:01:57 <beelsebob> most everyone
05:02:01 <araujo> haskell?
05:02:18 <Matric1> haskell the programming language
05:02:19 <araujo> what's that?
05:02:40 <Matric1> i put my usb drive in your floppy drive
05:02:45 <araujo> ooh ... right
05:02:48 <araujo> :-)
05:02:55 <Matric1> ann then u can complike me baby
05:03:01 <Matric1> *compile
05:03:05 <araujo> o_O
05:03:12 <beelsebob> hehe
05:03:16 <fasta> Haskell must be getting popular....
05:03:20 <velco> Matric1: don't ask to ask, just ask ;)
05:03:33 <Matric1> do u know how to implement a KWic system in haskell
05:03:43 <araujo> fasta, Oh no!!
05:04:00 <beelsebob> what's a KWic?
05:04:04 <araujo> Matric1, you need to like it HOT
05:04:09 <beelsebob> @google KWic
05:04:14 <lambdabot> http://www.kwic.com/
05:04:14 <lambdabot> Title: Kwic Internet
05:04:15 <Matric1> i got errors not compiling
05:04:28 <Matric1> your not hot
05:04:30 <Matric1> enought
05:04:33 <araujo> higher order typed!
05:04:34 <fasta> Matric1: What is KWic?
05:04:40 <araujo> muahah
05:04:51 <Matric1> http://en.wikipedia.org/wiki/KWIC kwic man
05:05:15 <araujo> Using ADT
05:05:22 <Matric1> nah haskell
05:05:34 <araujo> *sighs*
05:05:38 <fasta> Matric1: This is home work?
05:05:45 <Matric1> nope personal use
05:05:49 <beelsebob> Data.Map
05:05:59 <Matric1> want to sort my movie collection
05:06:03 <Matric1> in kwic
05:06:07 <Matric1> lool sadddo
05:06:08 <beelsebob> based on what?
05:06:15 <Matric1> the movie titles
05:06:26 <beelsebob> okay
05:06:32 <beelsebob> so what's hard about that?
05:06:43 <Matric1> iam a noob man in haskell
05:06:47 <beelsebob> hmm
05:06:48 <beelsebob> well
05:06:50 <fasta> Matric1: if you are new to Haskell, start with something you can do.
05:06:59 <fasta> Matric1: like exercises.
05:07:01 <beelsebob> I'd create an ADT that pairs a single word in the title with the whole title
05:07:12 <fasta> Matric1: then if you get the hang of it, do your own project.
05:07:15 <beelsebob> then I'd create all possible ones from the movie titles
05:07:17 <beelsebob> then sort it
05:07:19 <beelsebob> and you're done
05:07:56 <Matric1> huum intresting yeah iam following a book and trying to learn
05:08:08 <Matric1> wats ADT no mention of it in book
05:08:09 <fasta> Matric1: and try to _spell_.
05:08:45 <Matric1> yeah my spelling bad me from america orginally
05:08:56 <Matric1> so slang
05:09:05 <Matric1> what is ADT, i aint come across this yet?
05:09:34 <Cale> what's A?
05:09:47 <Cale> It's either an algebraic datatype or an abstract datatype
05:09:47 <Matric1> abstract data type got it
05:10:04 <Matric1> but this is on page 357 in book iam on page 90
05:10:13 <Cale> In Haskell, it's probably an algebraic datatype
05:10:18 <araujo> keep reading :-)
05:10:28 <Matric1> nooo
05:10:34 <Lemmih> Matric1: Welcome back. What book are you reading?
05:10:49 <Matric1> the craft of functional programming
05:10:52 <dons> ah, Matric1 == DataBoi_0
05:10:59 <Matric1> hahah yes u got me
05:11:27 <dons> good idea to keep the same name if you want to be taken seriously
05:11:39 <dons> it's just polite
05:11:43 <Matric1> no everyone bullys
05:13:09 <beelsebob> @paste
05:13:09 <lambdabot> http://paste.lisp.org/new/haskell
05:13:24 <lisppaste2> beelsebob pasted "KWic" at http://paste.lisp.org/display/28422
05:13:28 <beelsebob> FINISHED!
05:13:55 <Matric1> fuck me sorry for language but that was fast
05:14:38 <fasta> beelsebob: why do you roll your own sort?
05:14:51 <beelsebob> fasta: couldn't remember where it was
05:14:53 <beelsebob> List.sort?
05:14:54 <dons> homework problem?
05:15:00 <dons> heh, beelsebob
05:15:03 <fasta> dons: he said it wasn't.
05:15:06 <dons> ?index sort
05:15:06 <lambdabot> Data.List
05:15:09 <Matric1> this is to adance for me anyway
05:15:10 <Cale> beelsebob: yeah, List in H98, or Data.List
05:15:19 <araujo> dons, what do you think? :-P
05:15:25 <dons> araujo: ?
05:15:28 <Matric1> u want bully me now
05:15:33 <fasta> I think it is, though.
05:15:35 <musasabi> vegai: if you get it packaged please provide a link to add to the homepage :-)
05:15:52 <dons> Matric1: please. try not to be so verbose. keep the noise ratio down.
05:16:06 <Cale> hehe
05:29:56 <Matric1> how would one go about adding multiple strings to =, eg. Go = [sumfin] but i want to make it equal also [sumfin2] if u get what i mean do i use + or ,
05:30:24 <beelsebob> eh?
05:30:47 <beelsebob> you want to find out if all the strings in a pair of lists are equal?
05:31:07 <Matric1> nah i want to say as u coded test movie i want add more movies to my list
05:31:22 <beelsebob> just change the list
05:32:39 <Matric1> but for sake of making everything clear when coding i cant do this can i movie = [happy,goodfilm
05:32:50 <Matric1> then underthat add another film
05:32:55 <beelsebob> oh
05:33:01 <beelsebob> so hang on...
05:33:06 <fasta> Changing requirements already?
05:33:07 <beelsebob> you want an interactive program
05:33:09 <fasta> ;)
05:33:12 <beelsebob> that slowly reads films in
05:33:19 <beelsebob> and generates a KWic as it goes?
05:33:42 <dons> try try try to be clear Matric1, its very difficult to understand your questions
05:33:49 <Philippa_> Matric1: list = [1,2,3] ++ [4,5,6]
05:33:56 <Matric1> yeah so i can just edit and add more films each time and when i run program sorts them in kwic
05:34:27 <Matric1> would this mean the program would get to complex
05:34:45 <Matric1> as its doing multiple calculations
05:34:52 <lisppaste2> beelsebob pasted "KWic again" at http://paste.lisp.org/display/28423
05:35:11 <beelsebob> now it reads in movies.txt
05:35:15 <beelsebob> and gives you a KWic
05:35:41 <Matric1> oh wicked man didnt know u can do that read from other files but if i wanted to can i combine it in orginal code
05:35:50 <Matric1> so i dont have to edit .txt file
05:36:05 <Twigathy> beelsebob, You're mean. Adding "Idol of Darkness" to a seemingly inconspicuous movies list.... :P
05:36:14 <beelsebob> Twigathy: :P
05:36:21 <beelsebob> argh... missed a do
05:37:17 <Matric1> beelsebob man thanks for all this i really aprreciate u helping me, if u need something tell me on private
05:38:55 <Matric1> i use the ++ operrator should do it but the way u did the .txt thing didnt know u can do that so learn something from you man
05:39:36 <beelsebob> @index getStrLn
05:39:37 <lambdabot> bzzt
05:39:39 <beelsebob> bah
05:39:53 <fasta> @index getContents
05:39:53 <lambdabot> System.IO, Prelude
05:40:00 <fasta> @type getContents
05:40:02 <lambdabot> IO String
05:40:03 <beelsebob> no, I want a line at a time
05:40:07 <beelsebob> from StdIn
05:40:21 <fasta> @index getLine
05:40:22 <lambdabot> System.IO, Prelude
05:40:45 <fasta> @type getLine
05:40:46 <lambdabot> IO String
05:44:29 <lisppaste2> beelsebob annotated #28423 with "Interactive KWic" at http://paste.lisp.org/display/28423#1
05:44:45 <beelsebob> could be done better, but hey
05:44:48 <vegai> musasabi: Arch Linux has a semi-official 'community' repository. That's where it'll be.
05:45:30 <astrolabe> you don't need to redefine sort
05:45:33 <astrolabe> @type sort
05:45:35 <lambdabot> forall a. (Ord a) => [a] -> [a]
05:45:51 <beelsebob> I know
05:45:58 <beelsebob> I just couldn't remember where it was at first
05:46:01 <beelsebob> so I coded it
05:46:07 <beelsebob> and now I can't be arsed changing it
05:46:11 <astrolabe> :)
05:47:44 <fasta> beelsebob: and now without (++) as an exercise.
05:47:57 <beelsebob> huh?
05:48:03 <beelsebob> as in you want me to recode it?
05:48:13 <beelsebob> or you want sort without ++?
05:48:17 <fasta> beelsebob: No, I don't want anything.
05:48:27 <beelsebob> I'm confused
05:48:27 <fasta> beelsebob: I know how to do it without ++
05:48:34 <beelsebob> yeh... so do I
05:48:41 <beelsebob> if by "it" you mean sort
05:48:46 <fasta> beelsebob: nteraction (movies ++ (read newMovies)
05:48:50 <beelsebob> oh... okay
05:49:04 <fasta> beelsebob: you use ++ in a recursive call.
05:49:11 <beelsebob> well, I don't see any sensible way of doing that without ++
05:49:22 <Matric1> r u guys testing yourselves?
05:49:32 <fasta> Matric1: could you please use English?
05:49:34 <beelsebob> unless you only accept one film per interaction
05:49:42 <beelsebob> it would be more efficient to do it the other way round
05:49:47 <beelsebob> but would still require ??
05:49:47 <fasta> Matric1: I don't want my brain to infected with "r" and "u".
05:49:49 <beelsebob> ++ even
05:50:30 <Matric1> what about doing it without a map just tuples and lists ahahah
05:51:11 <beelsebob> fasta: what was the solution you were thinking of?
05:51:34 <fasta> beelsebob: difference lists
05:51:55 <beelsebob> fasta: you're not using a logic language
05:52:09 <fasta> beelsebob: So?
05:52:22 <beelsebob> anyway... difference lists still define ++... just not in linear time
05:52:58 <fasta> beelsebob: which makes your program go from O(n^2) to O(n)
05:53:10 <fasta> or from crawlingly slow, to fast enough.
05:53:47 <lisppaste2> beelsebob annotated #28423 with "Fast enough" at http://paste.lisp.org/display/28423#2
05:53:52 <beelsebob> fasta: that'll be fast enough
05:54:03 <beelsebob> the user has to enter that string
05:54:15 <beelsebob> it's gonna be short enough that in reality it'll be a short list
05:54:20 <beelsebob> and my program will be O(n)
05:54:23 <Matric1> when program is run in hugs the list is all in one line not like take look here: http://en.wikipedia.org/wiki/KWIC
05:54:45 <Matric1> what does this mean needs formating? alignments
05:54:52 <beelsebob> Matric1: so give it a nice show function
05:55:31 <fasta> beelsebob: ok, if you assume that, then you are right.
05:59:13 <lisppaste2> beelsebob annotated #28423 with "Nice output" at http://paste.lisp.org/display/28423#3
05:59:16 <beelsebob> better
06:01:57 <gds> beelsebob: This is a thing that's been confusing me: Why "newtype KWic = K [KWicLine]" rather than "type KWic = [KWicLine]" ?
06:02:09 <beelsebob> gds: yes
06:02:13 <beelsebob> so that they are different types
06:02:17 <beelsebob> instead of type synonims
06:02:25 <beelsebob> so that you can have a seperate Show instance for it
06:02:33 <gds> Oh, I see :)
06:02:45 <nomeata> I'd like to pipe non-monandic and monadic actions using `liftM` and =<<, but it fails because of different fixity, it seems. what is the nicest way to write such a right-to-left pipe then?
06:03:03 <nomeata> different precedence, I guess
06:03:05 <gds> ...and newtype rather than data so that all the other properties default to the old type?
06:03:28 <beelsebob> gds: that and the fact that it is essentially a type declaration...
06:03:35 <nomeata> the parenthesis at the and are ugly: recurs <- liftM concat $ mapM recursiveFiles =<< liftM (filter (not.null.basename)) (filterM doesDirectoryExist paths)
06:03:41 <beelsebob> rather than a new ADT
06:03:55 <gds> Ok, cool :) Cheers :)
06:06:17 <Matric1> beelsebob check this
06:06:17 <Matric1> http://paste.lisp.org/display/28425
06:06:54 <beelsebob> with difficulty
06:07:13 <Matric1> oh so that word be much more complex to do
06:07:26 <Matric1> but say the whole thing was 1 string
06:07:43 <Matric1> i see what you done used 2 strings for name and title
06:07:56 <Matric1> if you combined the whole thing want it be much easier
06:09:45 <Matric1> so use for example davince: blah blah instead of davinci,blah blah that is 2 strings
06:10:30 <x3m> @seen foxy
06:10:30 <lambdabot> I saw foxy leaving #haskell 1d 13h 7m 46s ago, and .
06:10:41 <x3m> @seen foxy
06:10:41 <lambdabot> I saw foxy leaving #haskell 1d 13h 7m 56s ago, and .
06:12:01 <nomeata> @seen lambdabot
06:12:01 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-haskell, #haskell_ru, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
06:12:12 <nomeata> @localtime
06:12:19 <nomeata> @localtime lambdabot
06:12:19 <lambdabot> I live on the internet, do you expect me to have a local time?
06:14:39 <nothingmuch> i need advice
06:14:41 <nothingmuch> weird advice
06:14:59 <nothingmuch> is a long background story OK
06:15:00 <nothingmuch> ?
06:15:04 <roconnor> advice when most needed is least heeded.
06:15:31 <wilx> Heh.
06:15:41 <nothingmuch> you have insulted my honor! i challenge you to aduel
06:15:48 <wilx> 42!!
06:16:12 <nothingmuch> that advice gives a type error
06:16:12 * nomeata hands nothingmutch a weird ad vice
06:16:17 <fasta> Computing 10M years for the answer... be back in a bit
06:16:35 <nothingmuch> okay, obviously you guys are bored, so i'll just share ;-)
06:16:46 <nothingmuch> I'm working on the perl 6 meta object protocol
06:16:48 * nomeata hands nothingmutch a unsafeCoerce $ weird ad vice
06:16:59 <nothingmuch> it's a purely functional pedantically refactored CLOS of sorts
06:17:04 <nothingmuch> http://nothingmuch.woobling.org/MO/
06:17:06 <lambdabot> Title: Index of /MO
06:17:14 <nothingmuch> cmarcelo is working on the haskell port
06:17:37 <nothingmuch> now, i'm working on a simple, macro-ish code generator
06:17:42 <nothingmuch> to make high level accessor behaviors
06:17:51 <fasta> Are we in #perl?
06:17:52 <nothingmuch> and I am trying to find some middle ground between perl 5 and haskell
06:18:01 <nothingmuch> so that this api is reusable for the haskell port as well
06:18:11 <fasta> Oh, nm
06:18:16 <nothingmuch> fasta: #perl never helps, but this is on topic nonetheless ;-)
06:18:39 <nothingmuch> modeling OO in haskell is trivial with records
06:18:45 <fasta> A CLOS for Haskell seems a bit odd.
06:18:48 <nothingmuch> prototype OO, specifically
06:18:50 <nothingmuch> yes, very odd
06:19:07 <nothingmuch> but MO is not quite CLOS
06:19:20 <nothingmuch> anymoose
06:19:22 <fasta> Since the stuff you can do with CL is wicked.
06:19:40 <fasta> Or "powerfull" depending on who you are
06:19:57 <fasta> Or "expressive" if you are a language advocate
06:20:23 <nothingmuch> i was thinking of implementing accessors using something like a state monad, whereby the monad implicitly carries an instance (that is simply a record) -- has something like it been done
06:20:36 <nothingmuch> so that the resulting code doesn't necessarily need a record of TVars or IORefs
06:21:15 <nothingmuch> fasta: Perl 6 has some CLOSish features, but MO doesn't really care, it can model "simpler" OO as well
06:21:26 <nothingmuch> however, that's not the field i'm looking for advice in ;-)
06:21:45 <fasta> nothingmuch: I am not that familiar with MO, and I only wrote a page or so of CLOS.
06:22:03 <nothingmuch> i only know some CLOS from my guru anyway ;-)
06:22:16 <fasta> Who's your guru?
06:22:20 <nothingmuch> stevan, my boss
06:22:29 <nothingmuch> he wrote Class::MOP, which is a ~~ port of CLOS to perl
06:22:34 <nothingmuch> in discussing it i learned more about CLOS
06:22:42 <fasta> And who's stevan in full?
06:23:01 <nothingmuch> and MO is a generalization of Class::MOP more suitable for dynamic/static + hybrid systems (many notions of wtf is a class)
06:23:07 <nothingmuch> http://search.cpan.org/~stevan
06:23:12 <nothingmuch> but that's really going off topic
06:23:12 <lambdabot> Title: Stevan Little - search.cpan.org
06:25:35 <nothingmuch> no pointers?
06:25:35 <beelsebob> @dice 3d6
06:25:35 <lambdabot> 3d6 => 9
06:26:57 <ex0-r> any idea how I can use mergesort to sort a list of tuple pairs : [(S1,P1), (S1,P2), (S3,P1), .. ] etc
06:27:13 <ex0-r> so that its ordered by the fst then by the snd
06:27:47 <dons> ?type sortBy -- is a mergesort
06:27:48 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:27:56 <fasta> nothingmuch: did you ask a question?
06:28:00 <SamB_XP> actually, tuples already sort that way!
06:28:02 <nothingmuch> fasta: yes
06:28:13 <fasta> nothingmuch: ok, I missed it.
06:28:18 * nothingmuch rephrases
06:28:39 <fasta> nothingmuch: nm, I see it.
06:28:43 <nothingmuch> in haskell you can do an elcheapo purely functional prototype OO system using records
06:28:50 <nothingmuch> that is, you gain polymorphism
06:29:01 <nothingmuch> to do data encapsulation you must also return the altered record
06:29:06 <nothingmuch> or use a record of IORefs/TVars
06:29:26 <nothingmuch> or write a monad for OOish behavior
06:29:33 <nothingmuch> is there any prior art on that last approahc?
06:29:38 <nothingmuch> am i missing an approach?
06:31:24 <Philippa> that last one's certainly oft-considered - it's a natural thing to layer on top of ST
06:32:40 <nothingmuch> as expected =)
06:32:46 * nothingmuch just found this: http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf
06:32:49 <lambdabot> http://tinyurl.com/j99vn
06:33:00 <nothingmuch> let's hope I can deal with it
06:33:12 * nothingmuch 's reading-fu is very low
06:34:53 <SamB_XP> @hoogle join
06:34:54 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
06:34:54 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
06:34:54 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
06:37:10 <beelsebob> SamB: why are you using XP?
06:38:37 <fasta> @type fail
06:38:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
06:38:39 <SamB_XP> beelsebob: uh, not for its hacker-friendliness
06:38:46 <SamB_XP> (it hasn't any!)
06:39:12 <fasta> What was the monadic equivalent of Nothing?
06:39:25 <SamB_XP> usually I use this machine for reading webcomics and stuff...
06:39:34 <SamB_XP> sometimes I run Maple on it.
06:40:39 <Lemmih> fasta: mzero?
06:40:51 <fasta> Lemmih: I think so, yes.
06:41:27 <fasta> instance MonadPlus Maybe, right
06:42:22 <SamB_XP> also fail "Foo!"
06:42:43 <SamB_XP> > fail "Foo!" :: Maybe []
06:42:44 <lambdabot>    `[]' is not applied to enough type arguments
06:42:44 <lambdabot>   Expected kind `*', but ...
06:42:50 <SamB_XP> > fail "Foo!" :: Maybe ()
06:42:51 <lambdabot>  Nothing
06:51:30 <Cale> I deny the existence of fail, and so should you! :)
06:53:11 <roconnor> > mzero :: Maybe ()
06:53:12 <lambdabot>  Nothing
06:57:04 <fasta> > mzero :: Maybe [[[[[a]]]]]
06:57:05 <lambdabot>  Add a type signature
06:57:16 <fasta> > mzero :: Maybe [[[[[Int]]]]]
06:57:17 <lambdabot>  Nothing
06:58:32 <ACSpike> http://rafb.net/paste/results/WR4L4v84.html
06:59:03 <fasta> Is there something to compute the connected components of a graph?
06:59:32 <fasta> Never mind, it's bcc
07:00:21 <Lemmih> ACSpike: readScala :: FilePath -> IO String
07:00:56 <Lemmih> ACSpike: (and add some return's)
07:01:28 <dmhouse> Why is there no map in Data.Sequence?
07:01:43 <ACSpike> are the returns necessary?
07:01:46 <SamB_XP> what is Data.Sequence?
07:01:54 <Lemmih> ACSpike: Yes.
07:02:23 <SamB> btw, I'm looking for myself so don't bother answering ;-)
07:02:58 <SamB> my guess is...
07:03:09 <SamB> nobody thought to write one?
07:03:12 <ACSpike> Lemmih: like "return case..." or "Left err -> return..."?
07:03:26 <Lemmih> ACSpike: You can do both, actually.
07:03:32 <ACSpike> ok
07:04:22 <dmhouse> SamB: seems like something basic you'd want to do with a datatype for a sequence...
07:04:33 <fasta> SamB: it's written by an academic.
07:05:18 <dmhouse> ACSpike: you'd probably need 'return $ case ...'
07:05:38 <dmhouse> Although I suddenly can't think of a good reason why. Hold on...
07:05:49 <dmhouse> > return let x = 1 in x :: Maybe Int
07:05:49 <lambdabot>  Parse error
07:05:50 <SamB> @hoogle FingerTree
07:05:50 <lambdabot> No matches found
07:05:57 <SamB> dmhouse: I'm writing a patch, okay?
07:05:58 <dmhouse> > return (let x = 1 in x) :: Maybe Int
07:05:59 <lambdabot>  Just 1
07:06:05 <dmhouse> > return $ let x = 1 in x :: Maybe Int
07:06:05 <lambdabot>  add an instance declaration for (Show (m (Maybe Int)))
07:06:09 <ACSpike> dmhouse: yup I had to do that, but I'm still missing something just a second
07:06:15 <SamB> dmhouse: oh, it does have a Functor instance.
07:06:28 <dmhouse> SamB: oh, that's good, thanks.
07:06:48 <dmhouse> SamB: by the way, you wouldn't need to touch the inner FingerTree; just recursing using viewl would work.
07:08:00 <SamB> given that it implements Functor, I wouldn't have to do anything but "map = fmap"
07:08:36 <SamB> do you think this is a good idea or not?
07:09:19 <SamB> if it is, I should probably change the part where it mentions the "hiding" keyword to say something about only importing the functions you want?
07:09:51 <SamB> whoa that is a big adder
07:09:55 <dmhouse> Really, map shouldn't exist at all and fmap should be called map.
07:10:06 <SamB> dmhouse: we know, we know...
07:10:13 <dmhouse> :) But okay, back to real life.
07:10:19 <SamB> but it was too hard for newbies
07:11:06 <dmhouse> No harder than understanding the types of numeric literals. In both cases tutorials could lie and say things like '5 :: Int' or 'map :: (a -> b) -> [a] -> [b]'
07:11:23 <SamB> but the numeric literals have defaulting
07:12:16 <SamB> also, Num is an actual type class, not a constructor class like Functor is
07:12:27 <SamB> plus, its a lot easier to guess what it has to do with!
07:12:36 <dmhouse> Still, doing ':t 5' in GHCi leads to a type involving a numeric class.
07:12:41 <SamB> yes
07:12:45 <SamB> but...
07:12:48 <dmhouse> *type class
07:13:12 <SamB> > fmap read "Hi!"
07:13:12 <lambdabot>  Couldn't match `String' against `Char'
07:13:14 <SamB> hmm.
07:13:17 <SamB> that isn't good enough.
07:13:35 <SamB> well. someone must have had a better example?
07:13:39 <dmhouse> I agree, map's probably a conceptual step harder than literals, but I still hold my point.
07:14:06 <SamB> maybe I'm thinking of Monad comprehensions, rather than fmap...
07:14:27 <dmhouse> Tutorials could originally lie and say map :: (a -> b) -> [a] -> [b]
07:14:57 <SamB> well, the map in my attempt at a collection library was worse!
07:15:08 <dmhouse> And then say 'but look, there are all these other datatypes like Maps and Sequences we'd want to map over, so it gets generalised to (a -> b) -> f a -> f b'
07:15:28 <SamB> I was trying to make it possible to have instances of my classes for the likes of Data.Map
07:15:34 <SamB> as well as []
07:16:24 <SamB> which meant I had no way to make "map" return the same kind of data structure as it was passed...
07:16:37 <ACSpike> what's IO String mean vs plain String? That's an IO monad containing a string?
07:16:51 <Cale> ACSpike: it's an IO computation which constructs a string
07:16:58 <dmhouse> ACSpike: it's a very hard diference explain technically.
07:17:02 <SamB> ACSpike: IO String is an action in the IO monad that gives you a string *when you run it*
07:17:09 <Cale> you can think of it as a program which when run will emit a string
07:17:16 <SamB> you could get different strings different times you run it
07:17:33 <dmhouse> ACSpike: IO String is a computation, or action, in the IO monad, that when executed, will do some IO and yield a string a the result.
07:17:37 <Cale> hehe
07:17:44 <ACSpike> I'm constructing something that will yeild a string, but I just want a string
07:17:52 <SamB> well, so, run it ;-)
07:17:53 <dmhouse> ACSpike: you need a do-block.
07:18:09 <SamB> does this code actually do any IO?
07:18:13 <dmhouse> do str <- myIOComputation; ...
07:18:23 <ACSpike> well it is a do block that the IO String comes out of
07:18:32 <Cale> The only things which are allowed to run IO actions are IO actions themselves. This isn't a problem, because main is an IO action :)
07:18:37 <SamB> well, what do you do in the do block?
07:18:45 <dmhouse> Then str :: String, but you can only use it inside the do-block, and last element in the do-block has to be of type IO a, for some a.
07:19:03 <SamB> dmhouse: all elements in the do block do
07:19:09 <SamB> unless you count lets
07:19:15 <dmhouse> SamB: true.
07:19:16 <Cale> ACSpike: how is the IO String built?
07:19:25 <Cale> (i.e. what does it do?)
07:19:41 <ACSpike> I'm trying to use parseFromFile from parsec
07:19:49 <Cale> okay, so it does file IO
07:19:58 <ACSpike> yes
07:20:14 <SamB> ACSpike: okay, so, are you trying to do this deep in the bowels of non-IO code?
07:20:40 <Cale> (my guess is that's unlikely)
07:20:45 * SamB too
07:21:20 <ACSpike> so far I have http://rafb.net/paste/results/To9xB897.html
07:21:33 <SamB> if you just want to see it in the interpreter, you could just myIOAction >>= print
07:21:49 <Cale> basically, you construct a main action for your program which will run your computation, getting a String, which you can then manipulate with pure code, before doing some more IO to print out results
07:22:08 <Cale> at least, that's the simplest sort of IO program you could be writing :)
07:22:56 <Cale> aha
07:22:58 <velco> how can I write function like  `` dec = map (-1)'' ?
07:23:07 <ACSpike> this is my only my second attempt at a haskell program. having difficulty thinking up interesting things to do, so I'm trying to write a parser for scala scale files http://www.xs4all.nl/~huygensf/scala/scl_format.html
07:23:08 <SamB> basically say scala <- readScala (args !! 0)
07:23:10 <lambdabot> Title: Scala scale file format, http://tinyurl.com/yzh3yo
07:23:35 <Cale> velco: dec = map (subtract 1)
07:23:39 <velco> IOW, how to make (-1) work similar to (+1)
07:23:41 <Cale> velco: (-1) is just a number :)
07:23:46 <velco> yeah
07:23:48 <Cale> or you could use (+(-1))
07:23:57 <velco> ok
07:24:34 <Cale> subtract is provided in the prelude as an apology for that syntax inconsistency
07:25:56 <ACSpike> ah hah
07:27:52 <Cale> ACSpike: do you see?
07:28:07 <ACSpike> just a sec, must test
07:28:25 <ACSpike> works
07:29:59 <ACSpike> ok, I still have one confusion
07:31:04 <ACSpike> just for the sake of my enlightenment, is it an absolute must for me to first construct an IO String and then use it? or can I somehow make it just return a String
07:31:38 <Cale> well, you can cut and paste the code
07:31:59 <Cale> but you have to run the IO String somewhere in order to get a String
07:32:17 <ACSpike> oh, wait
07:32:46 <ACSpike> parseFromFile is and IO (Either a b)
07:33:01 <ACSpike> so that is telling me that it makes an io action
07:33:06 <Cale> right
07:33:27 <Cale> which is going to go off and read the file, and then apply your parser to it
07:34:46 <ACSpike> so I see that it is much cleaner to make the action first and then run it, is it in theory possible to do both at once?
07:37:27 <ACSpike> can one nest do?
07:38:35 <Cale> well, yeah, there are rules about do-blocks that let you substitute the code which is run
07:39:45 <ACSpike> oh, I think little bits of this are trickling in
07:41:49 <Cale> It's just like in an imperative programming language - rather than calling a subroutine, you could copy the text of that subroutine in place and hook everything up so it works.
07:42:05 <Cale> It's just neater to make that separation
07:42:10 <ACSpike> indeed
07:43:04 <ACSpike> perhaps "val <- do..." would be that hook up?
07:43:26 <roconnor> wow, using ledit make working with UMIX a lot easier
07:43:26 <Cale> yeah, you can do that directly
07:44:29 <Cale> but you could also take the body of that do, insert everything but the last line as is, and replace the last line, say it's x, with val <- x
07:45:14 <Cale> because the return value of a do-block is always the return value of the last line
07:45:22 <ACSpike> ah hah
07:45:28 <ACSpike> got it.
07:45:33 <ACSpike> much thanks
07:45:51 <ACSpike> might take me a full week to recover from this :-)
07:46:08 <Cale> hehe
07:46:20 <ACSpike> what's the name for <- again?
07:46:21 <Cale> wait until you find out that do blocks are not just for IO
07:46:33 <ACSpike> bind?
07:46:41 <Cale> It's essentially bind, yes
07:46:55 <Cale> bind is actually the name of an operation which that desugars into
07:46:57 <ACSpike> oh, its sugar for something
07:47:01 <ACSpike> right
07:47:02 <Cale> and which looks like >>=
07:47:14 <Cale> here's the sugar rules:
07:47:30 <ACSpike> could I "do {} >>= val"?
07:47:45 <Cale> do {stmt; <stmts>} = stmt >> do {<stmts>}
07:47:58 <Cale> do {v <- stmt; <stmts>} = stmt >>= \v -> do {<stmts>}
07:48:12 <ACSpike> ouch
07:48:18 <ACSpike> I'm not ready for that
07:48:19 <Cale> do {let <decls>; <stmts>} = let <decls> in do {<stmts>}
07:48:22 <Cale> okay :)
07:48:46 <Cale> the nice thing is that you don't even have to know about that for now
07:48:58 <ACSpike> thankfully
07:49:11 <Cale> It's only really important when you want to start designing your own monads. Do isn't just for IO :)
07:49:14 <ACSpike> teensie pieces of it parse, but still
07:49:42 <ACSpike> today, I just want to parse a file. even that may be too much.
07:49:48 <Cale> :)
07:50:17 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- this has a good introduction which will properly introduce you to >>= and then do syntax
07:50:19 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/ft8nk
07:50:32 <Cale> and it's fairly short
07:50:36 <Cale> I recommend it
07:50:43 <Matric1> fasta u there?
07:50:49 <fasta> Matric1: yes
07:51:04 <fasta> Matric1: And don't use "u".
07:51:11 <fasta> Matric1: it's "you".
07:51:20 <Matric1> thank you for correcting me
07:51:33 <ACSpike> whoa, I need a break. english doesn't make sense anymore.
07:51:38 <ACSpike> Cale: thanks.
07:52:14 <Matric1> can you help me fasta personally
07:53:40 <fasta> Matric1: just ask a question in the channel. I am not the most experienced Haskeller here.
07:56:19 <roconnor> got the 96 pt clearreg solution
07:56:29 <roconnor> actually, it's pretty obvious.
08:00:02 <SamB> roconnor: which one is that?
08:00:03 <ndm> roconnor: did i tell you, i manage to beat GHC on some benchmarks now, with concrete implementation type stuff!
08:00:20 <SamB> I mean, what is the name of the publication?
08:01:01 <SamB> hmm, I only have 94 pts on that one actually...
08:03:50 <roconnor> SamB the one to set all th registers to 0 from the state 0 1 2 3 4 5
08:03:58 <roconnor> ndm: w00t
08:04:07 <roconnor> ndm: can I have my fast Haskell UM yet?
08:04:11 <SamB> roconnor: yeah, I found it...
08:04:17 <ndm> roconnor: 5% faster, now just implementaing deforestation, then hopefully faster still
08:04:19 <SamB> BLNCE.CRR, right?
08:04:33 <roconnor> BLNCE.CRR=96@
08:04:33 <ndm> roconnor: you can have a fast bit shift, but not any of the rest of the UM
08:04:43 <roconnor> oh
08:04:45 <SamB> I have BLNCE.CRR=94@
08:05:00 <roconnor> maybe I can have a fast Sha2sum
08:05:12 <roconnor> I used to have CRR=88
08:05:12 <lisppaste2> Matric1 pasted "code" at http://paste.lisp.org/display/28432
08:05:14 <ndm> probably soonish
08:05:23 <SamB> I just need to figure out what is going wrong with fish...
08:05:26 <roconnor> I don't know what I was thinking
08:05:31 <SamB> and maybe you can have fast shifts with GHC
08:05:36 <roconnor> :)
08:05:58 <ndm> for 6.8...
08:06:03 <roconnor> ndm: how is your IOUArrays?
08:06:06 <SamB> how about if you write me a program to compare the output of cg_annotate run on two different files?
08:06:12 <ndm> roconnor: non existant
08:06:24 <SamB> (or the input, if you'd rather ;-)
08:07:19 <SamB> I'd only need comparisons for one of the "event" columns...
08:07:32 <Matric1> fasta have look at this http://paste.lisp.org/display/28432
08:08:06 <SamB> and I'd want the output sorted by increase...
08:08:10 <SamB> I guess percent increase...
08:09:05 <SamB> http://valgrind.org/docs/manual/cg-tech-docs.html#cg-tech-docs.output describes cachegrind's output format
08:09:08 <lambdabot> Title: Valgrind, http://tinyurl.com/yyvmkl
08:16:43 <roconnor> I wonder if I can genetically breed solutions to the balance problems.
08:19:29 <chessguy> not in haskell
08:19:34 <chessguy> at least, not with an existing library
08:19:54 <chessguy> at least, not with a library i've seen
08:21:32 <chessguy> in fact, it's on the list of ideas for SoC
08:23:42 <ndm> isn't a genetic algorithm about 50 lines of code?
08:24:19 <ndm> i think the person who sits next to me wrote one in haskell for an assessment once
08:26:36 <chessguy> dunno, i've never written one in haskell
08:26:38 <ndm> hmm, i wonder if i could get a soc to work on hoogle
08:26:43 <ndm> chessguy: its easy :)
08:26:46 <chessguy> probably also depends on if you want it to be generalized
08:26:57 <ndm> yes, the generalisation is the hardest bit
08:27:00 <chessguy> or just to work on the problem at hand
08:27:13 <ndm> but haskell makes that relatively flexible with an appropriate type class
08:27:31 <ndm> if you need one, write one, will only take a few hours at most
08:27:37 <chessguy> and GP is a little harder yet
08:27:44 <chessguy> which is what i'm really interested in
08:27:49 <ndm> the hard part there is defining a lnguage
08:27:55 <ndm> which has to be done differently every time
08:28:01 <ndm> so the library can't help you there
08:28:03 <chessguy> i'm a n00b in haskell, i don't have a clue how to do it
08:28:10 <fasta> ndm: depends on how much computer power you have :)
08:28:14 <ndm> and if you want a recursive language, thats a challenge
08:28:31 <ndm> fasta: more than 500Mhz should be plenty
08:28:37 <chessguy> well, i would think if it were done right, the library could have an engine would would work on any genome
08:28:47 <fasta> ndm: for GP?
08:28:59 <ndm> fasta: yes
08:29:01 <fasta> chessguy: I don't think you come very far with that.
08:29:06 <fasta> er ndm
08:29:18 <chessguy> huh?
08:29:20 <SamB_XP> roconnor: if you come up with anything I'd *love* to see it!
08:29:25 <ndm> fasta: depending on how complex you want to go - more power doesn't buy you that much in a genetic algorithm setting
08:29:26 <fasta> People who do that stuff seriously use 1000 CPUs
08:29:47 <ndm> yes, but for the basics, you don't need much
08:29:47 <chessguy> that makes a lot of sense for a population of 1000
08:29:58 <fasta> ndm: AFAIK, the interesting stuff does take _serious_ computer power.
08:30:12 <ndm> fasta: yes, but no one is going to do that in haskell, it would just be silly!
08:30:18 <fasta> You don't want to wait 250 years for your GP to come up with something.
08:30:31 <fasta> ndm: people did it in Lisp
08:30:57 <ndm> fasta: for GP (rather than GA) that has obvious advantages, that Haskell doesn't
08:31:28 <fasta> ndm: in theory not, in practice probably yes.
08:31:57 <SamB_XP> heh
08:32:05 <SamB_XP> of course GP people care about practice ;-)
08:32:19 * roconnor saw a paper when they used genetic programing to find short predecessor functions for church numerals in the lambda calculus
08:32:21 <fasta> Some of the GP projects are very promising.
08:32:39 <therp> roconnor: that's nice, do you remember the name?
08:32:41 <roconnor> the lamba terms were basically untypable IIRC
08:33:55 <fasta> I want a datatype that is a Set, but can only hold two items. I also want that all the operations of Set work on it. How can I do that?
08:34:24 <SamB> is that one of the GP problems, or a serious question?
08:34:30 <fasta> Serious question
08:34:43 <roconnor> http://www.santafe.edu/~walter/Papers/lambda_gp.A4.ps.gz
08:34:45 <lambdabot> http://tinyurl.com/ynaw7n
08:34:49 <ndm> fasta: you mean you want type restrictions to stop people adding a second element?
08:34:59 <SamB> ndm: *third*
08:35:03 <ndm> fasta: or you want it to just delete all elements beyond the second
08:35:07 <fasta> ndm: third, yes.
08:35:12 <ndm> SamB, i included 0th :)
08:35:17 <SamB> heh
08:35:20 <ndm> fasta: type restrictions, or runtime?
08:35:25 <fasta> ndm: type
08:35:45 <ndm> fasta: data None = None; data One x = One x; data Two x = Two x y
08:35:59 <ndm> then define class Add None One, class Add One Two
08:36:05 <fasta> ndm: and how is that going to give me the same API as Data.Set?
08:36:07 <ndm> class Del Two One
08:36:11 <ndm> fasta: oh, it won't
08:36:13 <SamB> fasta: it isn't duh
08:36:29 <ndm> fasta: the set api guarantees nothing about sizes, you cannot enrich the types, but keep them the same
08:36:30 <SamB> you can't have the same API with totally different typing!
08:36:42 <ndm> fasta: but you can make the same names inside Add and Del classes
08:36:58 <ndm> i.e. calling Add as insert
08:37:12 <fasta> ndm: Maybe I only need it at run-time, then.
08:37:17 <SamB> hehe ;-)
08:37:44 <fasta> ndm: I have a constructor that already creates these values, and I only export that.
08:37:48 <ndm> fasta: thats the spirit! - thats easy enough to do, data MySet a = MySet Int [a]
08:38:09 <SamB> data Set2 a = None | One a | Two a a -- would also work
08:38:10 <therp> roconnor: thanks. oh, it's from the university I'm studing at. hm theoretical chemistry institute, pretty unusual..
08:38:26 <SamB> ndm: couldn't you use Data.Set.Set instead of []?
08:38:45 <SamB> or not...
08:38:55 <ndm> SamB, yes, but its more expensive if you only ever have 2 elements in it
08:38:57 <SamB> because you'd probably want some kind of monadic returns...
08:39:03 <SamB> oh wait.
08:39:06 * SamB silly
08:39:14 <SamB> ndm: true ;-)
08:39:18 <fasta> ndm: I had newtype TwoSet = TwoSet (Set Int)
08:39:21 <ndm> your data type is probably the most performant out of these
08:39:24 <chessguy> are you still talking about GA/GP, or something else?
08:39:31 <ndm> SamB's, i mean
08:39:34 <SamB> chessguy: something else
08:39:37 <fasta> I don't care for performance now, only correctness.
08:39:46 <chessguy> ok, good. i was really confused for a minute there
08:40:02 <SamB> I asked this too ;-)
08:40:49 <chessguy> i'd love to hear why a generalized GP engine isn't possible in haskell
08:41:10 <fasta> chessguy: It is possible (see Turing)
08:41:20 <fasta> next question
08:41:24 <chessguy> ok, why is it so hard
08:41:34 <fasta> chessguy: I don't know, who told you it is?
08:41:44 <therp> is there a way to dump the export list of a module in ghci?
08:41:46 <chessguy> someone said it a few minutes ago
08:42:19 <ndm> chessguy: i said its easier in LISP, not hard in haskell
08:42:23 <SamB> it isn't hard
08:42:25 <ndm> therp: :b
08:42:27 <therp> chessguy: "generalized" in a what sense?
08:42:34 <therp> ndm: thanks
08:42:38 <SamB> its might be hard to make a *useful* one
08:42:42 <fasta> therp: not specific for the problem domain, I guess.
08:42:45 <SamB> well. maybe it is hard to generalize it well...
08:42:51 <ndm> therp: perhaps thats only Hugs though ... - unsure
08:42:52 <chessguy> fasta, right
08:43:04 <monochrom> :b works in ghci too
08:43:15 <SamB> (by *useful* I meant one that would give you answers in a timely fashion)
08:43:21 * therp has written "a few" GP engines in CL, can't see a reason why this won't work in haskell. imho this has been done already at the university of essex under bill langdon's supervision
08:43:36 <chessguy> SamB, ah, that's more dependent on the genome, i think
08:43:49 * monochrom throws hardware at the problem
08:43:56 <chessguy> therp, it's been done in haskell?
08:44:28 <therp> chessguy: I think so, I recently read a paper that taked about GP in Haskell. They haven't demonstrated their engine though, just the results.
08:44:42 <chessguy> bah
08:45:52 <therp> "In Section 4.6.2, the implementation programming language Haskell and the advantages/
08:45:52 <therp> disadvantages the language brings to the GP system are discussed." --- from 'An Analysis of the Impact of Functional Programming Techniques on Genetic Programming' by Gwoing Tina Yu, 1999
08:45:55 <fasta> "protecting research"
08:46:24 <SamB> hehe
08:46:26 <therp> Someday, I have fix xchat-2 to show line-breaks. that one was unintentional.
08:46:40 <SamB> I think they were ashamed of their code ;-P
08:46:46 <chessguy> http://www.cs.mun.ca/~blangdon/biblio/cache/bin/cache.php?yu:1998:PolyGP,http___www.cs.mun.ca__tinayu_index_files_addr_public_html_pgp.new.pdf,http://www.cs.mun.ca/~tinayu/index_files/addr/public_html/pgp.new.pdf
08:46:50 <therp> samb: haha :) maybe
08:46:50 <lambdabot> http://tinyurl.com/v5a8a
08:46:50 <chessguy> this one?
08:47:47 <therp> chessguy: the url seems broken. wgeting it results in a loop.
08:48:07 <monochrom> or a GP
08:48:09 <therp> but yes pretty likely. as said, bill langdon's supervision.
08:48:29 <therp> or is that just from his GP biblio library? ..
08:48:32 <chessguy> oh, it's number 4 on http://www.cs.bham.ac.uk/~wbl/biblio/gp-html/ChristopherDClack.html
08:48:34 <lambdabot> Title: Genetic Programming Bibliography entries for Christopher D Clack, http://tinyurl.com/y83zld
08:49:58 <fasta> SamB: in theory I think it would be possible to turn a general container data type that can hold N items to a restricted type.
08:50:35 <fasta> I don't have such a method lying on my desk, but I wouldn't be surprised it it would be possible.
08:50:36 <therp> chessguy: yes, that's the one. The only one I know of. Haven't seen the code though, so no idea if it's useful at all
08:51:06 <therp> ... and I have to seriously remove firefox from my system. It's a productive blocker with all its bugs.
08:51:30 <chessguy> i saw another paper, but it used pretty old librarys for polytyping and for the graphics, and i couldn't get it to work
08:51:35 <therp> s/productive blocker/productivity blocker/
08:51:49 <therp> chessguy: also written in Haskell?
08:51:51 <chessguy> yes
08:51:56 <fasta> therp: bugs? I know it sucks internally, but externally I had no problems with it.
08:52:05 * monochrom should analyse the impact of functional programming techniques on vcr programming
08:52:17 <chessguy> vcr?
08:52:18 <fasta> monochrom: that would be something new.
08:52:20 <monochrom> firefox has bugs?
08:52:25 <fasta> video recorder
08:52:26 <therp> chessguy: do you remember its name? code available?
08:52:38 <chessguy> yes, the code was in the paper. lemme find it
08:52:40 <therp> monochrom: don't worry. soon we are going to have iceweasel.
08:52:47 <JKnecht> maybe a bad release, not generally
08:53:03 <JKnecht> more likely local config problem
08:53:17 <chessguy> therp, http://citeseer.ist.psu.edu/vestin97genetic.html
08:53:21 <lambdabot> http://tinyurl.com/rvn95
08:53:33 <fasta> I like the extensions available for Firefox to make my own productive environment.
08:53:50 <petekaz> any gtk2hs users online now?
08:54:08 <monochrom> I was sarcastic about analysing anything at all relating to vcr programming
08:54:19 <therp> jknecht: ah, you mean a local problem with ridiculous "configuration management" aka profiles?
08:54:29 <Daveman> hey chessguy :D
08:54:45 <chessguy> Daveman, :)
08:55:16 <therp> chessguy: thank you
08:55:28 <chessguy> sure. let me know if you get the code working. i'd love to play with it
08:55:52 <therp> chessguy: ok, if I don't get my own in place before that :)
08:56:04 <JKnecht> that or some buggy plug-in or something taking it down
08:56:14 <chessguy> that would be cool too
08:56:26 <therp> but at the moment I'm stuck with my hsSyn interfacing problems..
08:56:31 <JKnecht> running on cygwin, that sort of thing
08:57:00 <therp> not GP related at all. I'm trying to create a Lisp variant of Haskell syntax. no don't shoot :)
08:57:28 <ndm> anyone know anything about GHC SpecConstr? - http://hackage.haskell.org/trac/ghc/wiki/SpecConstr
08:57:31 <lambdabot> http://tinyurl.com/yywfvg
08:57:56 <chessguy> sounds like an interesting project
08:58:40 <Igloo> ndm: There are comments in compiler/specialise/SpecConstr.lhs
08:59:25 <ndm> % (c) The GRASP/AQUA Project, Glasgow University, 1992-1998 - that seems quite old :)
08:59:52 <Igloo> That only tells you the copyright line is old  :-)
09:00:25 <ndm> Igloo: perfect :) - its like having a paper in a source file
09:00:52 <ndm> Igloo: but i'd recommend that chunk gets copied to the wiki, or at least linked!
09:01:10 <chessguy> ndm, where's that line from?
09:01:19 <chessguy> oh, nm
09:01:22 <ndm> http://darcs.haskell.org/ghc/compiler/specialise/SpecConstr.lhs
09:01:24 <lambdabot> http://tinyurl.com/ydqofh
09:03:52 <ACSpike> how might I do manyTill newline or eof with parsec?
09:04:11 <Cale> dons: if you're up, swing wasn't found with @pl, it was found by reading over the prelude extensions and noticing a pattern in the combinators people were using to play with map :)
09:05:46 * edwardk waves hello.
09:06:10 <chessguy> hi edward
09:06:12 <chessguy> k
09:06:21 <edwardk> how goes?
09:06:27 <fons> hi all
09:06:47 <chessguy> i've managed to avoid doing any work today, so far so good
09:06:51 <edwardk> heh
09:06:53 <edwardk> likewise
09:07:02 <edwardk> hiding from an ontology workshop =)
09:07:07 <fons> I'm planning to code a stub for coding plugins in LADSPA with haskell
09:07:51 <fons> it is not a binding, what I have to export ceratin functions so that they exactly match the plugin interface of LADSPA
09:08:00 <edwardk> though, admittedly i'm thinking about coding up a paraconsistent inverse focusing theorem prover for them to help them search their ontology.
09:08:19 <fons> http://www.ladspa.org/ladspa_sdk/ladspa.h.txt
09:08:58 <fons> that means I have to code functions and data structures which are exported _exactly_ as in that file
09:09:24 <fons> It might be tricky (it's not a binding, nor interfacing directly to haskell functions)
09:09:34 <fons> so I guess I will have to code a wrapper around it
09:09:39 <fons> any suggestions?
09:09:45 <edwardk> hrmm
09:10:18 <Cale> Well, looks like the Storable class is the first and most important thing for you to look at.
09:10:42 <fons> do you now of any C plugin interface  which has been implemented in haskell?
09:11:07 <Cale> You can write some datatypes corresponding to the ones used in that interface and make them instances of Storable so that marshalling from that point is easy.
09:12:41 <fons> ok, storable class, that's good. Another problem is that in that interface data is not only passed in function parameters but also in i/o buffers with certain base address
09:13:16 <Cale> mm
09:13:42 <fons> I'd like to know how to woek with those without loosing the typical haskell semantics (i.e. I want it to be transparent for the user and not trying to make imperative programming within haskell)
09:13:44 <Igloo> dcoutts_: See also http://hackage.haskell.org/trac/ghc/ticket/873 - might want a fooMode variant of those functions or something too?
09:13:47 <lambdabot> Title: #873 (Add System.Directory.installFile) - GHC - Trac, http://tinyurl.com/yjcxze
09:13:49 <Cale> the plugin isn't responsible for allocation of that?
09:14:38 <fons> let me see
09:15:16 <Cale> You can certainly get C pointers and work with them on the Haskell side in IO
09:15:31 <fons> yes, yes, the plugin gives me that
09:15:40 <Cale> the host?
09:15:48 <fons> Cale, but I'm trying to go one step beyond
09:16:04 <fons> Cale, yep, the host sorry
09:16:15 <fons> what I'm trying to avoid is working as in C
09:16:22 <Cale> right
09:16:57 <fons> It might be asking too much ... (I son't know the internal representation of lists)
09:17:20 <fons> but it would be better to work with the buffers as if they were lists
09:17:25 <fons> or arrays
09:17:25 <Cale> maybe
09:17:33 <Cale> arrays might be better
09:17:38 <fons> (lists with limited length)
09:17:44 <Cale> in fact, unboxed arrays
09:18:52 <Cale> Maybe lists would be okay for some things if you could set up a lazy coroutine like behaviour
09:19:10 <Cale> but I doubt the interface supports that all that well... perhaps
09:19:32 <Cale> Lazy ByteStrings might be a nice option
09:19:41 <Cale> well, hmm
09:20:17 <Cale> usually samples aren't bytes, but 2 or 3, you really want Ints :)
09:20:24 <fons> I don't want to fight with laziness of course, I want the data to written right after the function call
09:20:44 <fons> (Samples are floats in LADSPA)
09:20:46 <Cale> ah
09:20:48 <Cale> okay
09:21:00 <Philippa> and even if they weren't, Int'd be a bad call
09:21:05 <Philippa> you'd want a 16bit or 32bit type
09:21:25 <Cale> Well, okay, the size of Int isn't guaranteed :)
09:22:10 <Philippa> but yeah, for real manipulation work you want floats :-)
09:22:25 <fons> want I think I should do to avoid problems is making an intermediate wrapper that marshals and unmarshals data
09:22:35 <fons> (using the types of the .h file)
09:23:02 <fons> th host calls the wrapper and the wrapper calls the Haskell code
09:23:31 <fons> using a wrapper it might be easy to debug (
09:23:52 <fons> lets see what I get
09:23:56 <Cale> fons: yeah, you probably should work on getting marshalling working for those exact types at a low level
09:24:25 <Cale> because that's going to be the same no matter what you decide to do at the high level
09:24:39 <Cale> and then you'll be able to actually experiment and see what works
09:24:55 <fons> using a marshaller I can just use castings and such
09:25:20 <Cale> oh, I mean Haskell code which marshals :)
09:25:27 <Cale> Have you read the FFI spec?
09:25:31 <Cale> It's very readable
09:25:37 <fons> Cale, not with much detail
09:25:47 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
09:25:47 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
09:25:48 <fons> that's what I should do first
09:26:22 <Cale> Haskell has a really nice FFI. You can usually completely avoid writing extra bits in C.
09:26:29 <fons> I'm not happi about the initilization and cleaning functions required to export haskell to c
09:26:37 <fons> happy*
09:26:51 <fons> it might be tricky to see were to include them within the plugin
09:27:31 <Cale> You mean the ForeignPtr stuff?
09:28:25 <fons> well, when exporting functions in ghc it seems that somo initialization and finalization calls is required as well
09:29:47 <Cale> hs_init and hs_exit ?
09:31:23 <fons> yep
09:32:01 <Cale> I don't think there's much of a way around that in general. I suppose the compiler could wrap all exported calls with hs_init/hs_exit pairs
09:32:22 <chessguy> ok, i'm missing something obvious here
09:32:49 <Cale> but that would probably incur some pretty severe performance hits
09:33:21 <fons> yep, and considering LADSPA is supposed to be able to work in real time .... I don't think that's acceptable
09:33:27 <chessguy> if i do data Pair a b = Pair a b; pairFst (Pair x y) = x; pairSnd (Pair x y) = y; --now how do i actually pass it a Pair to test that?
09:33:52 <Cale> pairFst (Pair 2 3)
09:34:18 <chessguy> > let data Pair a b = Pair a b; pairFst (Pair x y) = x in pairFst (Pair 2 3)
09:34:18 <lambdabot>  Parse error
09:34:38 <Cale> lambdabot won't handle that...
09:34:47 <Cale> (you can't declare datatypes in a let)
09:35:19 <Cale> I wonder if that could be set up with the local declarations thing that dons has set up though
09:35:35 <Cale>  have @data @newtype @type etc.
09:36:04 <Cale> @data
09:36:04 <lambdabot> Unknown command, try @list
09:36:27 <shapr> jiihaa
09:37:06 <chessguy> hmm, it doesn't like this
09:37:07 <xerox> ?yow!
09:37:07 <chessguy> data Pair a b = Pair a b
09:37:07 <chessguy> pairFst :: Pair a b -> a
09:37:07 <chessguy> pairFst Pair x y = x
09:37:07 <chessguy> test = pairFst (Pair 2 3)
09:37:07 <lambdabot> Yow!  Are we wet yet?
09:37:33 <xerox> You got to put Pair x y between parens.
09:37:57 <chessguy> aha
09:37:59 <chessguy> gotcha
09:38:15 <Lajexander> test = pairFst $ Pair (2 3)
09:38:27 <Cale> er, no
09:38:31 <Cale> that's quite different
09:38:41 <Cale> (you're applying 2 to 3)
09:38:44 <Lajexander> it is?
09:38:57 <Cale> test = pairFst $ Pair 2 3
09:39:06 <Cale> you want to apply Pair to 2 and 3
09:39:16 <Cale> Pair 2 3 = (Pair 2) 3
09:39:19 <Lajexander> but Pair is a constructor, not a function...
09:39:25 <Cale> constructors are functions
09:39:44 <Cale> they're just functions that you can pattern match against
09:39:47 <chessguy> Cale's right, i just tired it
09:39:55 <chessguy> s/ir/ri/
09:40:05 <Cale> Tired is right, I haven't slept and it's noon :)
09:40:08 <Cale> hehe
09:40:12 <chessguy> lol
09:40:16 <Cale> time for more coffee
09:40:22 <xerox> Healthy :)
09:40:27 <chessguy> me too, i only got to sleep in until 8 today
09:40:44 <Lajexander> i got to bed at 6:20 AM :/
09:42:31 <expwiz> I wonder if there is a class available similar to Eq but with an operator that checks if values are nearly equal (~=).
09:43:08 <xerox> Nearly?
09:43:45 <expwiz> yes. so e.g.  3 ~= 3.0001 would be True
09:43:57 <vegai> you'd have to give an epsilon
09:44:07 <xerox> There isn't one, but you can define it yourself if you need it.
09:44:21 <vegai> (I'd imagine)
09:44:31 * xerox nods
09:45:12 <expwiz> Would'nt be to hard.. but how does the default == operator in the class Eq know how to compare arbitrary data-types?.. how can I do something similar with my custom "Nearly Equal" class.
09:45:33 <vegai> you'll make those datatypes an instanced of your class
09:45:34 <xerox> ?instances Eq
09:45:35 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
09:45:41 <Lajexander> @pl fromJust . lookup
09:45:42 <lambdabot> fromJust . lookup
09:45:52 <xerox> ?source Prelude
09:45:52 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
09:46:26 <xerox> ?source Data.Eq
09:46:26 <lambdabot> Data.Eq not available
09:46:30 <xerox> Aw.
09:46:37 <expwiz> if I make a data-type: data CustomDataType = C Int Float Char deriving Eq    then I can do comparisons like: C 1 3.4 'a ==
09:46:45 <xerox> Just do ':info Eq' in GHCi :)
09:47:00 <expwiz> == (C 1 3.4 'b')..
09:48:39 <xerox> What is the question?
09:50:25 <expwiz> So.. if I define a class with the operator (~=) and make instances for Int Char Float, then I will be able to compare arbitrary data-types (like CustomDataType)? Or do I need to do something more :)
09:51:30 <expwiz> (and of course have CustomDataType derive the "nearly equal" class, lets call it NEq)
09:55:50 <fons> How would you represent C "bit-properties" in Haskell?
09:56:25 <fons> i.e. the properties are bitored in an int
09:56:43 <fons> a list would do, but its inefficient
09:57:00 <ibid> by C bit-properties you mean bitfields in a struct?
09:57:10 <ibid> there is no comparable automatic solution in haskell
09:57:22 <fons> ibid, no, probably I'm not expressing myself properly
09:57:26 <ibid> but you can roll your own, like you would in C if it didn't have bitfields
09:57:50 <ibid> fons: so what did you mean?
09:58:01 <fons> #define PROP1 0x01
09:58:08 <fons> #define PROP2 0x02
09:58:26 <fons> int properties = PROP1 | PROP2;
09:58:39 <ibid> ah
09:58:49 <ibid> PROP1 = 0x01
09:58:51 <ibid> argh
09:58:56 <ibid> prop1 = 0x01
09:59:02 <ibid> prop2 = 0x02
09:59:14 <ibid> properties = prop1 .|. prop2 (iirc)
09:59:15 <fons> ibid, I'm more concerned about semantics
09:59:18 <Una^> is there an equiverlant to .contains() (in java) to find a substring in a string in the haskell libraries?
09:59:24 <fons> I now I can do it exactly like that
09:59:26 <ibid> @index (.|.)
09:59:26 <lambdabot> Data.Bits, Foreign
09:59:37 <ndm> Una^: isInfixOf, but its only in the really really recent versions
09:59:39 <ibid> fons: then tell me what of the semantics interests you
09:59:54 <fons> but a haskell programmer wouldn't do it like that
10:00:00 <Una^> ndm: k thanks.
10:00:10 <ibid> fons: true
10:00:14 <ndm> Una^: contains find within = any (isPrefixOf find) (tails within) does it
10:00:19 <fons> ibid, I'm porting a plugin header file to haskell
10:00:34 <fons> ibid, I could do it like in C, and would be more efficient
10:00:34 <ibid> fons: but to tell you what haskellist would do i need to know what you are really doing
10:00:53 <Taral> Is there a reason why libraries@haskell.org is listed as a contact for the GHC library but it rejects messages?
10:01:01 <ibid> fons: bitsets are an implementation technique, nobody uses them just because, tehre is always some other reason
10:01:04 <fons> ibid, exactly that
10:01:20 <ibid> Taral: libraries@lists.haskell.org, perhaps?
10:01:23 <fons> I mean, reprenting properties and joining them in a data structure
10:01:30 <fons> representing
10:01:37 <Taral> ibid: No, it says libraries@haskell.org
10:01:37 <fons> the properties can be added and removed
10:01:45 <Taral> I get a message "you are not allowed to post to this"
10:01:49 <ibid> Taral: i believe you. i was suggesting it was a typo
10:01:58 <ibid> Taral: ut i could e wrong
10:02:09 <Taral> Oh, no it's not bouncing, it's being rejected by a mailing list manager.
10:02:09 <ibid> Taral: it's also possible that the list is subscriber-only
10:02:13 <fons> lists would do, but they admit redundance, which is not the right thing(tm)
10:02:33 <ibid> fons: i'd probably just use Bool fields in a record
10:02:45 <chessguy> thing(tm)? :)
10:02:47 <ibid> fons: if you don't mind the slight inefficience
10:03:03 <fons> ibid, uhm it makes it difficult to extend
10:03:19 <ibid> fons: not more than a bitmask thing
10:03:49 <fons> ibid, can you write a example then?
10:03:51 <ibid> fons: well yeah, you do need to be able to edit the definition of the datatype
10:03:51 <Matric1> seen
10:04:17 <ibid> fons: data Properties = Properties { prop1 :: !Bool, prop2 :: !Bool }
10:04:37 <fons> ibid, maybe it would be easier to just create an ADT and use the C style avoind the later marshalling
10:05:17 <ibid> fons: so you need to be able to create new properties without editing the data type definition?
10:05:40 <Taral> fons: Sounds like extensible records.
10:06:26 <chessguy> anybody know of a simple example of getting random numbers in haskell?
10:06:40 <Taral> @wiki extensible record
10:06:40 <lambdabot> http://www.haskell.org/haskellwiki/extensible record
10:06:43 <fons> ibid, no, no, actually thinking again about it I'll just create an ADT
10:06:52 <Taral> bah
10:06:57 <Taral> @wiki Extensible_record
10:06:57 <lambdabot> http://www.haskell.org/haskellwiki/Extensible_record
10:07:15 <ibid> well, good for you if it works. i still don't understand your requirements :)
10:07:44 <fons> ibid, it's just translating from C
10:07:54 <fons> but I want to make haskelish
10:08:17 <ibid> fons: yes, but to tell you want the haskellish way is, i need to understand the requirements, not just the c implementation :)
10:09:27 <fons> I'm adapting this plugin header file to haskell http://www.ladspa.org/ladspa_sdk/ladspa.h.txt
10:09:52 <fons> the type I'm talking about is LADSPA_Properties
10:10:03 <fons> that code must be used by a host
10:10:29 <Taral> data Property = Realtime | InplaceBroken | HardRTCapable | Unknown Int
10:10:30 <fons> so I have to find a way to create haskell interfaces with the same semantics
10:10:35 <Taral> type Properties = [Property]
10:10:38 <ibid> fons: should it be binary-compatible with C?
10:10:49 <fons> ibid, yes
10:10:56 <ibid> Taral: or Set Property
10:10:58 <fons> I'm gonna put a marshaller in the middle
10:11:07 <Taral> ibid: Yes, or Set, but I don't think the list is long enough for that to matter.
10:11:14 <fons> host <- marshaler -> haskell code
10:11:24 <Taral> fons: Yes, you always need a marshaller.
10:11:33 <Taral> Even if it's autogenerated, it's still there.
10:11:36 <ibid> Taral: fons already had ruled out the list because it allows duplicates
10:11:48 <Taral> So what if it allows duplicates?
10:11:55 <ibid> fons: i'd probably just use the record thing i mentioned above
10:12:00 <Taral> It works to an equivalence.
10:12:00 <ibid> Taral: i don't care, but fons does
10:12:07 <fons> Taral, well, it's a possible solution but controling the duplicates is not efficient
10:12:16 <Taral> fons: Why do you care about duplicates?
10:12:22 <Taral> I write haskell, and I don't care about duplicates in that list.
10:13:00 <fons> ok, you might be right
10:13:24 <glguy> any dwm users on now?
10:13:26 <fons> but when you want to remove a property from a list is inneficient
10:13:34 <Taral> fons: The list isn't long enough for that to matter!
10:13:41 <Taral> This is a 3 element list!
10:13:47 <fons> anyway, that operation is not gonna be used
10:13:54 <fons> ok ok, maybe I'm bwing too picky
10:13:58 * ibid tunes out for a bit
10:13:59 <fons> I'll go for the list
10:14:01 <Taral> You are coming from C, where efficiency is king.
10:14:10 <Taral> In Haskell, write it the simple way, then see if the performance matters.
10:14:28 <Taral> You've got heap objects and a GC eating efficiency much more than most operations.
10:15:07 <fons> Taral, I'm porting the interface of a (optionally RT) audioplugin framework ... were efficiency is the king as well
10:15:54 <fons> and you are right, probably just by the fact of using Haskell, I don't know if the plugins coded would be hard RT capable
10:16:07 <fons> I'm quite ignorrant in the internals of Haskell anyway
10:16:26 <fons> but by now, I'll go for lists :) thanks
10:17:15 <fons> BTW, I learnt to code in Haskell before than C :) but maybe learning C afterwards made me being too concerned about efficiency
10:17:16 <fons> :)
10:17:44 <fons> Taral, thanks for the advice, I'll write it simple first
10:18:14 <monstre> can someone please explain why the monomorphism restriction is necessary?
10:18:25 <Taral> fons: Good luck!
10:18:57 <ibid> monstre: it's not strictly necessary, but it trades one hidden surprise to a noticeable annoyance
10:19:07 <glguy> ?lastlog config.h
10:19:08 <lambdabot> Unknown command, try @list
10:19:13 <glguy> ?last config.h
10:19:14 <lambdabot> No module "config.h" loaded
10:19:14 <monochrom> efficiency is important to be aware of
10:19:19 <glguy> :-/
10:19:28 <monochrom> note: just aware of :)
10:19:35 <glguy> Anyone remember what the URL to don's tmp directory was?
10:19:44 <glguy> hostname/~dons/tmp/
10:19:48 <glguy> or something
10:19:52 <glguy> ?where lambdabot
10:19:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:20:01 <monstre> ibid: which hidden surprise?
10:20:23 <glguy> foudn it :)
10:20:25 <chessguy> ok, why is there no relatively example anywhere for generating a random number?
10:20:43 <chessguy> i realize it's different in haskell, because of monads, but it can't be THAT ba
10:20:43 <ibid> monstre: that a simple value might not be memoised even when one expects it
10:20:46 <chessguy> d
10:21:56 <ibid> monstre: if you have foo = ... expensive computation ..., you generally expect foo to be evaluated at most once, but without the monomorphism restriction, it would be evaluated every time it gets used
10:22:06 <ibid> iirc
10:22:21 <monstre> how often is this situation likely to come up in practice?
10:22:44 <ibid> monstre: it's not rare, but i can't give you numbers
10:23:05 <ibid> monstre: look at the list archives for monomorphism restriction, especially the old committee mail archives
10:23:18 <Cale> well, it would be, if it was typeclass-polymorphic
10:23:30 <shapr> chessguy: import System.Random \n mygen = mkStdGen 42
10:23:49 <ibid> Cale: which most things are :)
10:24:11 <Cale> Personally, I don't mind having to add some type signatures to improve performance where necessary
10:24:29 <glguy> does anyone have a copy of the words utility that dons uses with dwm?
10:24:35 <Cale> I usually just turn the MR off and have no problems
10:24:36 <ibid> the point is, it's a tradeoff with pros and cons both ways
10:24:40 <Cale> yeah
10:24:49 <monstre> I can see the cons alright...
10:24:58 <Cale> and it's implemented both ways at least
10:25:09 <chessguy> shapr, that doesn't seem to do anything random
10:25:12 <Cale> Perhaps we should make it a proper declaration
10:25:26 <shapr> chessguy: The next exciting step is to find a better seed, many people get a time value and use the picoseconds field (since our clocks don't have that much resolution)
10:25:30 <ibid> a LANGUAGE variant
10:25:31 <monochrom> 42 is not random :)
10:25:47 <monochrom> But don't tell anyone...  my favourite seed is 42 too! :)
10:25:49 <chessguy> 42 and 43 produce the same thing
10:26:08 <monochrom> if 44 also produces the same thing, I'll be with you
10:26:20 <Cale> newStdGen
10:26:25 <shapr> chessguy: Once you have a seed you like, mkStdGen constructs a generator, and you can use the other things in System.Random to iterate the pseudorandom number generator.
10:26:33 <chessguy> monochrom, it does
10:26:53 <monochrom> http://www.vex.net/~trebla/haskell/random.xhtml
10:26:56 <lambdabot> http://tinyurl.com/tjet5
10:27:06 <Cale> I usually use newStdGen, which, if implemented correctly, will get some entropy from the system pool.
10:27:08 <chessguy> shapr, you're not listening :)
10:27:21 <Cale> (of course, that's in IO)
10:27:23 <chessguy> different seeds aren't giving me different numbers
10:27:31 <vegai> shapr: hey, is the source to your happs/wiki implementation available?
10:27:35 <Cale> chessguy: for how many different seeds?
10:27:46 <monochrom> 3.  42,43,44
10:27:56 <Cale> hmm
10:27:58 <chessguy> at least 4 or 5 now
10:28:00 <shapr> vegai: Yeah, darcs get http://www.scannedinavian.com/~shae/happswiki
10:28:02 <lambdabot> Title: Index of /~shae/happswiki
10:28:14 <monochrom> The url above is my random tutorial
10:28:24 <chessguy> ah, nice
10:28:29 <shapr> vegai: I still haven't gotten around to adding user login and recent changes, but I'll do that soon.
10:29:02 <Cale> map (take 10 . randoms . mkStdGen) [1..30]
10:29:04 <Cale> try that
10:29:07 <ndm> woohoo, i'm 33% quicker than GHC!
10:29:22 <Cale> maybe even mapM print it
10:29:46 <Cale> which will make it clear that this is not what happens :)
10:29:49 <chessguy> Cale, now that did something
10:31:40 <chessguy> @hoogle mkStdGen
10:31:41 <lambdabot> Random.mkStdGen :: Int -> StdGen
10:31:52 <chessguy> @hoogle mkStdGens
10:31:52 <lambdabot> No matches found
10:31:56 <Cale> that's how you turn a seed into a random generator
10:32:20 <Cale> newStdGen will use some system-dependent mechanism to get a seed
10:32:30 <Cale> (generally, reading from the entropy-pool)
10:33:07 <Cale> You should never use the same generator more than once
10:33:31 <ibid> except when trying to reproduce a bug
10:33:32 <chessguy> ok, now i can go back to what shapr was saying, and find a way to get the current picosecons
10:33:36 <shapr> musasabi's Network.Alt is cool.
10:33:39 <Cale> When you do something like calling random on a generator, you'll get back a pseudorandom number and a new generator
10:33:44 <ibid> which also means that you'd want to be able to find out the seed of a run
10:33:54 <shapr> chessguy: And that makes testing easy as well.
10:34:05 <Cale> If you can get the current picoseconds, you can also just call newStdGen
10:34:11 <Cale> @type newStdGen
10:34:12 <lambdabot> IO StdGen
10:34:18 <ibid> Cale: can you get the seed out of StdGen?
10:34:45 <Cale> yeah, sort of, by showing it
10:34:54 <ibid> ok
10:35:02 <chessguy> @type mkStdGen
10:35:03 <lambdabot> Int -> StdGen
10:35:04 <Cale> which will not print exactly the seed
10:35:10 <monochrom> use show to save a generator. use read to reload it
10:35:35 <monochrom> (Java serialization :) )
10:35:36 <Cale> but something from which you could probably compute it, seems to be n+1, 1 for something fresh out of mkStdGen
10:35:59 <monochrom> public class Killer implements Serializable ... // serial killer
10:36:20 <shapr> oy
10:36:21 <ibid> Cale: i mean, for debugging purposes it is important to be able to reproduce any previous run
10:36:22 <chessguy> can't i just seed it with the current number of picoseconds to get a relatively random number no matter what?
10:36:30 <Cale> ibid: yeah, you can read and show them
10:36:35 <monochrom> Yes you can
10:36:48 <Cale> chessguy: yes
10:36:53 <shapr> chessguy: newStdGen handling seeding for you.
10:37:01 <Cale> chessguy: though it's safer just to call newStdGen
10:37:03 <shapr> handles*
10:37:08 <Cale> which will do smarter things than using the time
10:37:10 * shapr can't type today.
10:37:24 <Cale> @source System.Random
10:37:25 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
10:37:35 <chessguy> what would i do with newStdGen
10:37:38 <shapr> @docs System.Random
10:37:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
10:37:59 <ibid> then again, if you are doing stuff that require secure random numbers, it's best to make your own so you don't get bitten by any bad library implementations :)
10:38:09 <chessguy> i don't really understand monads yet, so the docs won't probably help me
10:38:11 <ibid> (no idea how good haskell impls are here)
10:38:20 <monochrom> there is no monad
10:38:20 <Cale> oh, it does use the time
10:38:24 <Cale> that's disappointing
10:38:33 <Cale> It shouldn't do that on Unix
10:38:42 <shapr> chessguy: Since it's a pseudorandom number generator, you pull a number out of it with "next", that gives you back a value and the next generator as well.
10:38:53 <Cale> mkStdRNG :: Integer -> IO StdGen
10:38:53 <Cale> mkStdRNG o = do
10:38:53 <Cale>     ct          <- getCPUTime
10:38:53 <Cale>     (TOD sec _) <- getClockTime
10:38:53 <Cale>     return (createStdGen (sec * 12345 + ct + o))
10:38:58 <ibid> Cale: on linux, at least. /dev/urandom is not standard :)
10:39:01 <shapr> chessguy: Then you use the value and pass the generator to the next function that'll need a random value.
10:39:14 <Cale> ibid: or /dev/random
10:39:25 <ibid> Cale: same thing for this purpose
10:39:32 <shapr> vegai: Got any HAppS questions?
10:39:32 <Cale> yeah
10:39:50 <Cale> Are you sure that's not at least slightly standard?
10:40:12 <Cale> I seem to remember it's on solaris, at least.
10:40:22 <fons> How would you represent a callback handle (pointer to void) in haskell keeping haskell semantics?
10:40:26 <Cale> or maybe that was just the system I was using
10:40:44 <chessguy> @type mkStdGen
10:40:45 <lambdabot> Int -> StdGen
10:41:06 <monochrom> why is this so hard?
10:41:21 <shapr> chessguy: Since a monad is just a pipeline of useful repeated code, a monad for random numbers would just be that one repeated chunk of code that calls next and passes the resulting generator.
10:41:47 <Cale> as a matter of fact, I've written that monad(transformer)
10:41:52 <Cale> It's on the wiki :)
10:42:00 <chessguy> wait, a monad is like a stream?
10:42:06 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
10:42:08 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/y5xzau
10:42:16 <shapr> chessguy: Often, yes
10:42:20 <Taral> A monad is like a zen koan. It takes many many forms.
10:42:36 <Cale> It's like a mechanism for connecting bits of code in a standard way.
10:42:54 <chessguy> ugh
10:42:56 <monochrom> Gosh not this again.  This is philosophy.
10:43:00 <chessguy> i don't know why i'm not getting this
10:43:04 <chessguy> it can't be that hard
10:43:07 <Cale> okay
10:43:19 <shapr> chessguy: Just unfamiliar, you'll get that bolt of lightning if you keep at it :-)
10:43:24 <monochrom> I think you're stuck at a local minimum.
10:43:27 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers -- this might be useful
10:43:29 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
10:43:48 <Cale> Ignore the original message, maybe look at his code briefly
10:44:15 <Cale> My reply is more talking about the real problem with his code and not the minor syntax issue he was asking about
10:45:11 <shapr> chessguy: A monad can be a chunk of code that automates passing something around. But that's just one flavor. The next extension is something like the list monad that turns a tree into a lazy list of backtracking options.
10:45:28 <chessguy> what's the i in shuffle' i list
10:45:35 <chessguy> aList
10:45:54 <chessguy> oh wait, his code's not right?
10:45:55 <Cale> it's a thing he was using to keep track of where he was in the list
10:46:02 <Cale> his code is pretty wrong
10:46:08 <Cale> scroll down
10:46:59 <Cale> I have a working version of the program, and then some modifications fixing an algorithmic bug (the permutations he was generating were not with equal probability)
10:47:04 <monochrom> There are good advices and bad advices.  The human brain reliably chooses to listen to the bad advices.
10:47:07 <Cale> and then a way to use my Random monad
10:47:29 <chessguy> so in RandomGen g, g is just an object of whatever type you want a random object?
10:47:49 <Cale> RandomGen g just says that g is a type of random generator
10:48:07 <Cale> for almost all purposes, you just use StdGen
10:48:15 <Cale> but you could implement your own if you wanted
10:48:37 <Cale> (say, if you implemented Mersenne Twister or something, you could use it with the same interface)
10:49:12 <SamB> @type random
10:49:13 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
10:49:21 <monochrom> @type negate
10:49:23 <lambdabot> forall a. (Num a) => a -> a
10:49:26 <chessguy> wait...let me look at your code for a minute
10:49:32 <SamB> it is a handy way to keep the RNG out of the Random instances
10:49:55 <monochrom> I don't think that's worded right.
10:50:10 <Cale> yeah, I kind of stole those type declarations from the class, perhaps I should add the (Random a) constraint
10:52:18 * glguy burns linksys for distributing upgrade information about its firmware in .doc format
10:52:26 <chessguy> ok, clearly i need to take today to finally conquer monads once and for all. screw my homework that's due monday
10:52:59 <monochrom> I think you just need IO.
10:53:30 <monochrom> Nevermind.  No one ever listens to me.
10:53:33 <Cale> hehe
10:53:40 <glguy> monochrom: what's did you say?
10:53:49 <Cale> chessguy: Did you read my little introduction to IO?
10:53:56 <chessguy> no
10:53:58 <monochrom> I said there is Open Office for handling .doc files
10:54:05 <Cale> oh, then that's a good starting point
10:54:12 <chessguy> monochrom, did you say something?
10:54:22 <chessguy> :)
10:54:25 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
10:54:27 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/y6rwwu
10:54:52 <glguy> OOo is a bit too bulky for my tastes
10:54:53 <Cale> it's really pretty short, and should give you the gist of what's going on with the IO monad
10:55:00 <chessguy> ok
10:55:09 <monochrom> You have limited disk space?
10:55:12 <chessguy> i'm turning off the radio and bashing my head on this until i get it
10:55:27 <glguy> monochrom: I just don't like installing bulky packages w/ many deps
10:55:29 <Cale> OO.o does take an astoundingly long time to start
10:55:41 <monochrom> Oh, yeah, it has many dependencies.
10:55:41 <Cale> What's really fun is trying to run it off a livecd
10:55:51 * glguy is running dwm, would be silly to run something as big as OOo in something as small as dwm ;)
10:56:03 <Cale> it is really decent software though
10:56:13 <Cale> I'm glad it exists even if I don't really use it
10:56:19 <glguy> If I'm writing papers, I use LyX
10:56:31 <Cale> because I can tell other people to use it instead of Microsoft Office.
10:56:46 <monochrom> I have a 40GB disk and I install all the bulky things and their dependents and I still can't use more than 1/4 of my disk.
10:56:59 <glguy> I've got OpenBSD installed on my work laptop
10:57:03 <glguy> so I can't use the whole disk
10:57:08 <glguy> I have to leave windows on there
10:57:19 <glguy> so I only sliced 7 gig off
10:57:43 <monochrom> Actually 1/10.
10:59:10 <chessguy> @type getLine
10:59:12 <lambdabot> IO String
10:59:19 <glguy> surprise! ;)
11:00:38 <chessguy> ok, i sort of get IO
11:01:51 <chessguy> so f a is an action which produces a side effect of type a
11:02:10 <Cale> the result is of type a
11:02:11 <monochrom> Not so fast.
11:02:14 <glguy> if (Monad f) => f a
11:02:22 <Cale> In some sense, the f is the type of side effect
11:02:35 <monochrom> I think the choice of the letter f reflects a gross misunderstanding.
11:02:45 <glguy> IO String is just a container that hold your string for you
11:02:46 <Cale> m is a better choice
11:02:58 <Cale> well, not just one :)
11:02:59 <chessguy> i was looking at fmap :: (Functor f) => (a -> b) -> f a -> f b
11:03:01 <monochrom> Trust me. I'm a professional teacher.  I can smell when a student is taking the wrong message.
11:03:03 <glguy> f a isn't so bad if you are treating IO as a Functor
11:03:12 <Cale> chessguy: not every functor is a monad
11:03:21 <Cale> chessguy: Every monad is a functor though
11:03:27 <glguy> and IO is a Functor
11:04:03 <Cale> >>= and return can't be written in terms of fmap
11:04:19 <glguy> I think we are straying for chessguy's question though...
11:04:29 <Cale> yeah
11:04:52 <Cale> An IO String is an action, which may produce IO side effects, and which produces a string when run
11:05:13 <glguy> or a container
11:05:27 <chessguy> ah yes, ok
11:05:35 <Cale> IO is pretty much the hardest monad to squeeze into the container model properly :)
11:05:41 <chessguy> a is the return value
11:05:47 <chessguy> err, return type
11:05:54 <spreeker> WOOWOO - 8e BKP in leiden met ruben en koen. en Laptop gewonnen. maar gaat nu snel weg :)
11:05:55 <Cale> but yeah, you could view it as a black box from which Strings may be pulled
11:06:01 <glguy> Cale: I usually introduce Haskell's IO as a Functor first to people at work
11:06:03 <Cale> and pulling the strings will cause things to happen
11:06:14 <spreeker> sorry wrong channel
11:06:44 <glguy> ?babel de en WOOWOO - 8e BKP in leiden met ruben en koen. en Laptop  gewonnen. maar gaat nu snel weg :)
11:06:45 <lambdabot>  WOOWOO - 8e BKP in suffer met ruben EN koen. EN laptop won maar gaat nu snel away:)
11:06:53 <glguy> hmmm
11:06:55 <Cale> In fact, IO is the hardest monad to understand
11:06:58 <glguy> not german apparently
11:07:11 <spreeker> dutch
11:07:13 <Cale> well, maybe Cont is harder :)
11:07:27 <chessguy> so in general, if i had some monad Random Int, which would produce an integer and then change the seed, i could get as many random ints as i want
11:07:39 <spreeker> i won a laptop and was 8th on a programming contest.. no haskell allowed :(
11:08:05 <Cale> chessguy: indeed
11:08:22 <Cale> chessguy: and managing that doesn't necessarily involve IO at all
11:08:28 <chessguy> right
11:08:39 <chessguy> and what were we talking about earlier that's equivalent to what i just called Random
11:08:57 <shapr> spreeker: wat loek!
11:09:02 <Cale> the monad I constructed, yeah
11:09:13 <chessguy> the transformer?
11:09:16 <Cale> yeah
11:09:23 <Cale> (not that I thought of doing that first or anything)
11:09:47 <Cale> note that I also define a plain monad Rand there
11:10:02 <chessguy> oh, you used it as MonadRandom in your code for deck-shuffling
11:10:08 <chessguy> right?
11:10:11 <Cale> yeah, in the later version
11:10:51 <chessguy> @type StdGen
11:10:52 <lambdabot> Not in scope: data constructor `StdGen'
11:11:09 <chessguy> @hoogle StdGen
11:11:10 <lambdabot> System.Random.StdGen :: data StdGen
11:11:10 <lambdabot> Random.getStdGen :: IO StdGen
11:11:10 <lambdabot> Random.mkStdGen :: Int -> StdGen
11:11:13 <Cale> StdGen is a type
11:11:50 <Cale> there's just one problem with getStdGen which is fixed with newStdGen
11:11:56 <Cale> g <- getStdGen
11:12:02 <Cale> g' <- getStdGen
11:12:07 <Cale> g will be equal to g'
11:12:57 <chessguy> so if i do g <- newStdGen and g' <- newStdGen, they won't be the same?
11:13:01 <Cale> right
11:13:09 <chessguy> because newStdGen changes the seed
11:13:12 <Cale> yeah
11:13:15 <Cale> the global one
11:13:44 <Cale> System.Random is a slightly evil library in that respect
11:13:51 <chessguy> @type mkStdGen
11:13:52 <lambdabot> Int -> StdGen
11:13:54 <Cale> it maintains program-global state
11:14:31 <chessguy> i still don't get what StdGen is then
11:15:08 <Cale> It's a bunch of numbers which are used to compute a new pseudorandom value.
11:15:13 <Cale> @type random
11:15:15 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
11:15:20 <Cale> this is illustrative
11:15:32 <Cale> StdGen -> (a, StdGen)
11:15:50 <Cale> it gives you a pseudorandom value of type a and a new StdGen
11:15:57 <Cale> which you use to get the next one
11:16:15 <chessguy> oh, so it's a generalization of what i called Random
11:16:26 <Cale> mm, it's not a monad though
11:16:41 <Cale> It's what that monad would keep track of.
11:17:04 <Cale> bind would thread the StdGen along
11:17:28 <Cale> and you'd have some computations which would get random numbers, and handle the updating of the StdGen being threaded
11:18:30 <Cale> (if the thing you were calling Random was a monad, I forget)
11:18:42 <chessguy> alright. let me go back to YAHT for a bit. i think i almost got monads when i read through that
11:18:53 <chessguy> <chessguy> so in general, if i had some monad Random Int, which would produce an integer and then change the seed, i could get as many random ints as i want
11:19:00 <Cale> yes
11:19:11 <Cale> you should also be aware of the All About Monads tutoria
11:19:12 <Cale> l
11:19:16 <Cale> which is really good
11:19:44 <Cale> and my Monads As Containers, which is less good for IO, but more good for the general case perhaps :)
11:19:54 <Cale> http://www.nomaware.com/monads/html/index.html
11:19:56 <lambdabot> Title: All About Monads, http://tinyurl.com/hx34v
11:20:01 <chessguy> oh, i think i saw that once before
11:20:05 <Cale> http://haskell.org/haskellwiki/Monads_as_containers
11:20:07 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/yxtdh4
11:20:56 <yip> have you guys seen flapjax?
11:21:20 <Cale> yip: yeah
11:21:27 <chessguy> he's quite critical of FP
11:21:31 <Cale> yip: have you seen Shriram's presentation?
11:21:37 <Cale> chessguy: he's *really* joking
11:21:56 <yip> Cale: no, where is it? what do you think of flapjax? it doesn't look like real FRP to me
11:21:58 <Cale> chessguy: He's lying blatantly about not knowing about Fran
11:22:23 <Cale> chessguy: lots of his research is inspired by Fran, and I have papers by him to back that up
11:23:00 <chessguy> ok, here's an example
11:23:05 <Cale> Do you really think one of the guys responsible for PLT Scheme is going to diss functional programming that seriously? :)
11:23:08 <chessguy> module Main
11:23:08 <chessguy> where
11:23:08 <chessguy> import IO
11:23:08 <chessguy> main = do
11:23:09 <chessguy> hSetBuffering stdin LineBuffering
11:23:09 <chessguy> putStrLn "Please enter your name: "
11:23:11 <chessguy> name <- getLine
11:23:13 <chessguy> putStrLn ("Hello, " ++ name ++ ", how are you?")
11:23:18 <Cale> http://download.microsoft.com/download/9/4/1/94138e2a-d9dc-435a-9240-bcd985bf5bd7/Shriram.wmv
11:23:22 <lambdabot> http://tinyurl.com/rh7zz
11:23:49 <Cale> chessguy: depending on your GHC version, you can ignore the hSetBuffering
11:23:53 <chessguy> the line name <- getLine interests me, because doesn't that do exactly what we're not supposed to do?
11:24:04 <chessguy> i.e., return a different result depending on what the user types?
11:24:13 <Cale> chessguy: It's not a function
11:24:31 <Cale> @type getLine
11:24:33 <lambdabot> IO String
11:24:39 <Cale> no -> anywhere ;)
11:24:58 <chessguy> but it puts something different in the String, depending on what's typed
11:25:05 <velco> it just binds ``name'' to the String that getLine would produce if someone cared to execute it
11:25:08 <Cale> we're building a computation which is inert under evaluation
11:25:27 <Cale> there are two things going on when a Haskell program runs
11:25:33 <Cale> execution and evaluation
11:25:35 <chessguy> by inert, you mean that main ultimately produces ()
11:25:47 <Cale> no, I mean evaluation doesn't do anything to it
11:25:52 <Cale> just leaves it alone
11:26:06 <Cale> maybe tidies things up a little
11:26:14 <Cale> but largely can't touch it
11:26:39 <Cale> execution is the thing which interprets the IO action program as something to do
11:26:46 <Cale> and actually runs it
11:27:08 <Cale> but there's no way to cause execution to happen yourself, only the Haskell runtime handles that by executing main
11:27:22 <Cale> (well, in ghci, you're given the right to type things and have them executed)
11:27:34 <fasta> Cale:  getting the value of 4+5 is evaluating, right?
11:27:38 <Cale> right
11:27:54 <Cale> evaluation is the pure part of Haskell that you've been learning before IO
11:28:08 <fasta> Cale: ok, it seems you implied something else. I know what evaluating is.
11:28:36 <Cale> execution is the process which interprets (IO a) values as something to do, and runs things
11:28:48 <Cale> in the process of doing that, evaluation will be demanded
11:28:53 <chessguy> i like YAHT's RealWorld example
11:29:01 <Cale> I hate that example :)
11:29:03 <Cale> hehe
11:29:07 <SamB> what does it do?
11:29:07 <velco> me too
11:29:13 <Cale> but it is one way to look at it I suppose
11:29:23 <velco> I like the containers/pipeline examle
11:29:59 <Cale> The way I think it's best to look at IO is as just some abstract representation of an imperative program script.
11:30:31 <velco> I like this onehttp://en.wikibooks.org/wiki/Haskell/Understanding_monads
11:30:34 <lambdabot> http://tinyurl.com/ewuzt
11:30:44 <Cale> >> connects scripts end to end
11:31:12 <Cale> and >>= takes a script, and a function from possible results of that script to further scripts, and builds a new script from that
11:31:32 * SamB would like to see a monad similar to IO, except totally pure
11:31:43 <shapr> ST?
11:31:47 <SamB> nono
11:31:50 <SamB> I mean like...
11:32:06 <Cale> Something which represents the IO primitives as ADT values.
11:32:13 <SamB> no!
11:32:18 <Cale> hehe
11:32:30 <SamB> like
11:32:30 <Cale> Well, I'd like to see that one anyway ;)
11:32:35 <shapr> I'd like to see the IO monad cut into pieces. It's a kitchen sink at the moment.
11:32:36 <SamB> it would have instances:
11:32:53 <SamB> instance MonadState FSTree IO'
11:33:03 <shapr> I'd also like to see if Alex Nanevski's possibility and necessity calculus can be used to do commutative monads.
11:33:46 <SamB> instance MonadWriter (String -> String)
11:34:23 <SamB> oh, I left out the IO'
11:34:32 <SamB> instance MonadSupply Char IO'
11:34:43 <yip> Cale: this Shriram video is supposed to be about flapjax?
11:34:52 <Cale> yip: the second half is
11:35:08 <yip> cool...
11:35:13 <SamB> or, I don't know...
11:35:28 <SamB> maybe it could be...
11:36:01 <psi> I'm using 6.6 now, and I can't seem to use  instead of \.
11:36:06 <SamB> newtype IO' a = IO' (State FakeWorld a)
11:36:38 * shapr throws a rook at chessguy2
11:36:47 <psi> and I'm not using ghci, it's a proper compile.
11:37:33 <psi> I think I recall someone else saying it didn't work, too.
11:37:58 <chessguy> stupid wireless
11:38:15 * chessguy throws a queen back at shapr, just to one-up him
11:38:33 <SamB> where data FakeWorld = FW { fwFileSystem :: FSTree, fwHandles :: ???, ... }
11:39:22 <SamB> of course, thats not a bit like how IO works ;-)
11:39:57 <SamB> but...
11:41:53 <SamB> runIO' :: IO' a -> String {- ^ stdin -} -> FSTree -> (String {- ^stdout -}, FSTree)
11:43:19 <SamB> hmm.
11:43:39 <SamB> I suppose that would be lazy in the FSTree... and sorta lazy in the input...
11:44:25 <SamB> no, actually, that would just confuse people wouldn't it?
11:46:03 <chessguy> what does haskell use for integer division?
11:46:14 <chessguy> > 3 / 2
11:46:15 <lambdabot>  1.5
11:46:28 <chessguy> i want to get 1 out of that
11:46:41 <psi> > 3 `div` 2
11:46:41 <chessguy> > 3 // 2
11:46:42 <lambdabot>  1
11:46:42 <lambdabot>  add an instance declaration for (Num [(i, e)])
11:46:55 <chessguy> ah, //
11:47:06 <hygge> can redefine how a list comprehension evaluates? i have to lists, xs, and ys, i want it to group a tuple (x,y) with the first element of xs and the first from ys and then do do until the the list is paired. the two lists has the same length.
11:47:13 <hygge> ah, zip would do that i realize now
11:47:28 <hygge> but, stil, can i do it with a list comprhenesion somehow anyways?
11:47:29 <chessguy> @hoogle //
11:47:30 <lambdabot> Array.(//) :: Ix a => Array a b -> [(a, b)] -> Array a b
11:47:30 <lambdabot> Data.Array.(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
11:47:30 <lambdabot> Data.Array.IArray.(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
11:48:00 <chessguy> > 3 // 2
11:48:01 <lambdabot>  add an instance declaration for (Num [(i, e)])
11:48:18 <ValarQ> hygge: looked at 'Parallel List Comprehensions'?
11:48:20 <chessguy> oh, it answered psi and i out of order
11:48:37 <chessguy> > 3 `div` 2
11:48:38 <lambdabot>  1
11:48:45 <hygge> ValarQ, nope :P
11:49:00 <ValarQ> hygge: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#parallel-list-comprehensions
11:49:02 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/ycsuyo
11:49:19 <ValarQ> hygge: it's not standard haskell thought
11:49:24 <glguy> http://www.inquisitorx.com/beta/
11:49:26 <lambdabot> Title: Inquisitor - Instant Search
11:49:38 <glguy> seems interesting enough if your network connection is quick
11:49:52 <therp> the GHC doc lists Control.Monad.Error as component of the mtl library. but my ghc-6.6 installation doesn't seem to have a "mtl" package, neither is Control.Monad.Error available. is this built optionally? or am I missing something
11:50:29 <Lemmih> therp: Using Debian?
11:50:37 <therp> lemmih: no using Gentoo's Haskell overlay
11:50:38 <hygge> valarq: ah i see, thx
11:50:46 <Lemmih> glguy: eh?
11:50:51 <ValarQ> therp: then there is a mtl package
11:51:07 <Lemmih> glguy: Ah.
11:51:29 <therp> valarq: ah right, thanks!
11:51:52 <therp> I assumed it was part of ghc, because it's listed in the users manual
11:52:03 <ValarQ> it was
11:52:59 <ValarQ> a couple of libraries (including mtl) has been thrown out from 6.6
11:53:23 <glguy> Lemmih: did you try it?
11:54:23 <Lemmih> glguy: Yeah, at first I pressed enter before realizing it was interactive.
11:55:24 <glguy> Lemmih: I think that google already has a page that does the autocompletion and suggestions
11:55:31 <glguy> but I figured I'd share that anyway
12:00:45 <chessguy> it does. it's called google suggest
12:02:46 <glguy> but google suggest won't suggest that you use a different search engine ;)
12:04:43 <Maddas> heh, it looks like they ripped off the search button and field directly from Spotlight
12:05:47 <glguy> If Vista can do it, I don't see why this site can't (c:
12:06:48 <Maddas> hah :-)
12:07:01 <Maddas> oh, they even ripped off the menu styles. Heh.
12:07:55 <ndm> roconnor: http://neilmitchell.blogspot.com/2006/10/30-faster-than-ghc.html
12:09:03 <glguy> why didn't lambdabot tinyurl that?
12:10:04 <ndm> i wondered that
12:10:06 <ndm> http://neilmitchell.blogspot.com/2006/10/30-faster-than-ghc.html
12:10:10 <weitzman> > 1
12:10:11 <lambdabot>  1
12:10:18 <ndm> http://neilmitchell.blogspot.com/
12:10:19 <lambdabot> Title: Neil Mitchell's Haskell Blog
12:10:30 <glguy> looks like dons decided against the tiny functionality
12:10:52 <ndm> i was hoping it would generate a smart title at least
12:11:10 <ndm> Neil Mitchell's Haskell Blog: 30% faster than GHC
12:11:51 <glguy> You should reverse the order of those things
12:11:53 <glguy> maybe
12:12:07 <glguy> Article Title - Blog Title - Firefox
12:12:20 <glguy> would be what I'd see in the header
12:12:21 <Igloo> Do LB have a length limit that that happened to hit, or is it doing something odd?
12:12:21 <ndm> personally, yes, but thats the blogger default for the template i had
12:12:30 <glguy> just an idea
12:12:31 <ndm> too annoying to fix it
12:14:00 <Igloo> ndm: What are the numbers like if you turn off PE?
12:14:16 <ndm> Igloo: how do i do that?
12:14:37 <Igloo> ndm: Err, you wrote it  :-)
12:14:44 <ndm> oh, partial evaluation
12:15:08 <ndm> i can't really turn it off, its very required because of the first order bit
12:15:20 <Igloo> Ah, OK
12:15:22 <roconnor> w00t, solved the balance multiply puzzle
12:15:29 <roconnor> alas only 134 points
12:15:38 <glguy> link?
12:15:39 <ndm> would drop through the floor, since head x would be compiled to apply Head x, where apply is a big function
12:15:40 * roconnor would like to see a 200 pt solution
12:16:13 <ndm> Igloo: with fusion turned off, i am just a fraction faster than GHC
12:16:39 <glguy> roconnor: link?
12:16:49 <roconnor> glguy: you want my solution?
12:16:55 <glguy> roconnor: to the problem
12:17:12 <roconnor> you want the statement of the problem?
12:17:40 <glguy> I odn't know what problem you are talking about , but I'm interested in reading about it
12:17:56 <roconnor> glguy: It is one of the puzzles from the ICFP 2006 contest
12:18:09 <glguy> ooooh
12:18:29 <roconnor> boy, who knew multiplying two numbers could be so hard.
12:19:24 <roconnor> the main problem is that there is no way to set a memory location to the value 1 if the memory is full of even numbers
12:19:45 <roconnor> so you can to the typical solution of adding repeatedly.
12:20:15 <SamB> I never did figure that one out...
12:20:52 <roconnor> SamB: I sort of followed the hint given by the ICFP contest video.
12:21:20 <roconnor> there is a solution that works if the first number is odd.
12:21:39 <roconnor> you can negate it, and then and it with it's original value to get the number 1
12:22:03 <roconnor> in general you get the least signifigant non-zero bit of the first number.
12:22:40 <petekaz> Can someone show me how unfoldTree/unfoldForest works?
12:22:56 <roconnor> so what I do is loop through accumulating, and decrementing the first input by this least signifigant bit.
12:23:22 <roconnor> then once that is done I just need to add the result to itself a number of times to shift it by the right power of two
12:24:16 <roconnor> two more puzzles to go before I get my certification!
12:24:35 <petekaz> I want to build a tree of Strings based on a text file that uses whitespace indentation to indicate level of the tree.
12:28:58 <glguy> I'm reading an article linked from Digg regarding the use of electronic voting machines
12:29:19 <glguy> This author seems to think that if you can hide the source code, that security experts will not be able to find the exploitable bugs
12:29:33 <glguy> I wonder if he's heard of *Windows*
12:29:34 <SamB> eeek
12:31:13 <hygge> why doesnt this simple function work? http://pastebin.perl.se/7b90bdd676/
12:32:11 <fasta> glguy: that guy is right in practice
12:32:24 <fasta> glguy: even with the source code he would be right
12:32:42 <roconnor> glguy: the problem with electronic voting machines comes from the people who write the software.
12:32:52 <glguy> hygge: because you're explicit type definition is wrong
12:33:01 <SamB> fasta: what do you mean?
12:33:07 <Cale> petekaz: first build a list of pairs of numbers indicating indentation level and the rest of the string
12:33:11 <SamB> it can be very easy to find them!
12:33:13 <glguy> hygge: should be: Ord a => [a] -> [(a,Int)]
12:33:20 <SamB> you don't need to look at code at all, necessarily
12:33:37 <fasta> SamB: I mean that the tool chain also needs to be trusted.
12:33:41 <glguy> ?type group
12:33:42 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
12:33:48 <SamB> fasta: huh?
12:33:52 <Adamant> they're already finding bugs in Diebold machines without source
12:33:52 <fasta> SamB: And this included the hardware.
12:33:54 <glguy> ?type sort
12:33:55 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:34:12 <fasta> s/included/includes
12:34:17 <SamB> fasta: who are you agreeing with again?
12:34:21 <glguy> ?type \xs -> group (sort xs)
12:34:22 <lambdabot> forall a. (Ord a) => [a] -> [[a]]
12:34:25 <Cale> petekaz: then perhaps look at the behaviour of groupBy (<), though it's a little icky relying on that behaviour :)
12:34:27 <fasta> SamB: I agree with the expert.
12:34:46 <Cale> > groupBy (<) [0,1,2,1,1,2,2,3,0,1,2,3]
12:34:47 <lambdabot>  [[0,1,2,1,1,2,2,3],[0,1,2,3]]
12:34:52 <fasta> SamB: secure electronic voting is next to impossible
12:34:55 <petekaz> Cale: thanks.
12:34:58 <SamB> fasta: oh!
12:35:02 <Cale> > groupBy (<) [0,1,2,1,1,2,2,3]
12:35:03 <lambdabot>  [[0,1,2,1,1,2,2,3]]
12:35:08 <Cale> > groupBy (<) [1,2,1,1,2,2,3]
12:35:09 <lambdabot>  [[1,2],[1],[1,2,2,3]]
12:35:23 <glguy> secure electronic voting is impossible with the financial constraints that have been placed on the problem
12:35:24 <SamB> I thought you were agreeing with the idiot who didn't think anyone could find bugs without source!
12:36:20 <Patterner> that's why i (along with 7300 other people) signed a patition to forbid voting machines in germany :)
12:36:23 <fasta> SamB: oh, sure one could find bugs in theory. You just probably won't find them all.
12:37:21 <SamB> Patterner: what do you use for voting now?
12:37:27 <glguy> lol, you don't have to find them all, you have to find one
12:37:31 <SamB> fasta: oh sure!
12:37:34 <fasta> The problem with these discussions is that some random fool comes along and claims to have found an answer to the voting problem.
12:37:47 <Patterner> paper :)
12:37:51 <petekaz> Cale: once I have that, how do I get to Data.Tree?  Do I use unfoldTree/Forest?
12:38:04 <Patterner> and sometimes voting machines, but not much
12:38:14 <fasta> Patterner: How about you write up a complete protocol and then post me a link?
12:38:16 <SamB> fasta: I thought the implication was that no blackhats would be able to find any!
12:38:27 <Patterner> protocol for what?
12:38:30 <fasta> SamB: why are you using !!!!?
12:38:38 <psi> are there several small lambdas in unicode?
12:38:39 <fasta> Patterner: "voting protocol"
12:38:40 <SamB> dunno.
12:38:50 <Patterner> how much do you pay?
12:39:10 <Cale> petekaz: yeah, you could
12:39:48 <fasta> Patterner: I am sure people would be interested in such a protocol.
12:39:59 <fasta> Patterner: I won't pay anything to you.
12:40:15 <Cale> basically, the heads of the lists are the nodes at any level, and then the tails are used to build their children
12:40:25 <Maddas> fasta: I don't know much about this, but out of curiosity, did you read about the three-way voting mechanism proposed by Rivest?
12:41:15 <Patterner> there are lots of idea how to do it. but they are expensive and won't allow the rules to cheat to win...
12:41:28 <fasta> Maddas: I think I heard of it. But no.
12:41:49 <fasta> Maddas: I also wonder whether his model is applicable to my country.
12:42:06 <fasta> Maddas: I can imagine that the properties are different.
12:42:30 <glguy> ?version
12:42:30 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
12:42:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:43:47 <Cale> petekaz: or just treeOf (x:xs) = Node x (map treeOf (groupBy (<) xs))
12:44:45 <Maddas> fasta: I can provide you with a link to the paper if you are interested. I don't really understand the subject matter enough to comment on it :-)
12:44:45 <Cale> that kind of assumes that there's one root node. You'll probably want to build a forest by doing an initial split
12:44:48 <Maddas> Which country do you live in?
12:45:07 <fasta> Maddas: The Netherlands
12:45:13 <Maddas> Neat.
12:45:19 <xerox> fasta, cool, and you do Haskell@school ?
12:45:33 <petekaz> Cale: thanks, I'm playing around with all of your ideas now.
12:45:43 <fasta> xerox: I did almost all courses on it.
12:45:59 <xerox> fasta: where exactly? utrecht, somewhere else?
12:45:59 <petekaz> I'm just a bit slow ..
12:46:01 <fasta> xerox: and for my own projects I program everything in Haskell
12:46:26 <Maddas> fasta: Impressive!
12:46:37 <fasta> Maddas: you don't even know what I program.
12:46:46 <fasta> Maddas: how can you tell it's impressive?
12:47:00 * glguy wonders how to tell xterm to show yellow as orange
12:47:03 <Maddas> fasta: The fact that you get to use Haskell for almost all courses.
12:47:08 <Maddas> (Assuming you took many, of course)
12:47:18 <xerox> Maddas: the other way around :)
12:47:31 <fasta> Maddas: "projects" don't necessarily mean univ. projects.
12:47:40 <Maddas> Ok.
12:47:48 <fasta> Maddas: We also did Java.
12:49:15 <chessguy> @type (==>)
12:49:16 <lambdabot> Not in scope: `==>'
12:49:23 <chessguy> oops
12:49:28 <xerox> fasta: may I know where do you study?
12:49:31 <chessguy> @type (>>=)
12:49:32 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
12:50:16 <chessguy> so >>= takes the side effect produced by calculating a, combines it with the side effect of using a to calculate b, and returns the whole side effect with b
12:50:55 <fasta> xerox: you may, but the rest of the world may not.
12:51:04 <SamB> ???
12:51:08 <fasta> xerox: in short: I won't answer that question.
12:51:30 <chessguy> am i close?
12:51:35 <xerox> fasta: I was investigating .nl universities time ago, I'd love to go study there.
12:51:56 <fasta> xerox: didn't you do a master already?
12:52:03 <xerox> fasta: no way :)
12:52:11 <fasta> xerox: bachelor?
12:52:29 <xerox> fasta: I've started my first year from three weeks.
12:52:58 <Maddas> xerox: Maths? :-)
12:53:07 <xerox> Maddas: right.
12:53:13 <Maddas> Yay!
12:53:21 <fasta> xerox: so you are about 18 years old?
12:53:21 * xerox bounces around Maddas 
12:53:27 <Maddas> {:
12:53:43 <xerox> fasta: yeah, about
12:53:59 <xerox> +-2 hehe
12:54:03 <fasta> xerox: Hmm, you always appeared quite cluefull. I thought you were older.
12:54:11 <xerox> Thank you fasta.
12:54:13 <shapr> age /= clue
12:54:27 <shapr> We had a very clueful 14 year old around here for awhile.
12:54:37 <Maddas> Speaking of which, he hasn't been here lately, has he?
12:54:46 <shapr> Nah, plus I think he's 16 now.
12:54:53 <fasta> shapr: low age typically amounts to no university time which relates to bad logic skills.
12:55:03 <shapr> Well, I have no university time also...
12:55:05 <xerox> I don't think so.
12:55:07 <Maddas> shapr: Not that he wouldn't be allowed to return because of that, would he.. :-)
12:55:14 <shapr> At least, none in math/science.
12:55:22 <shapr> I took a bunch of art classes...
12:55:42 <fasta> It depends on the person, but the new students in the university I attend seem to be low on clue when they enter.
12:55:45 <xerox> shapr: still planning to get some in math/science?
12:55:50 <shapr> xerox: Yeah I think so.
12:55:54 <xerox> Good.
12:56:09 <xerox> I bet you'll have some good fun.
12:56:15 <shapr> Probably. My teachers may hate me though.
12:56:51 <xerox> Hate?
12:57:10 <shapr> My experiences with computer science teachers so far hasn't been positive.
12:57:16 <fasta> shapr: because?
12:57:21 <shapr> So I'll probably correct them ...
12:57:31 <xerox> Do you take in account men like Mr. Coutts? ;-)
12:57:40 <shapr> I would *love* to have Mr. Coutts for a teacher.
12:57:43 * xerox nods
12:57:45 * dcoutts grins
12:58:14 <fasta> What can dcoutts teach?
12:58:18 <monochrom> I am a computer science teacher and you will not hate me.
12:58:27 <fasta> lambda calculus, I'd guess.
12:58:27 <monochrom> I can teach arrows
12:58:32 * chessguy hates monochrom just because he said that
12:58:36 * shapr grins
12:58:42 * xerox applies to monochrom's course
12:58:53 * dcoutts teaches Haskell to first year undergrads
12:58:54 <xerox> I've skimmed your arrow tutorials.
12:58:56 <chessguy> where do you teach, monochrom
12:59:04 <fasta> Canada?
12:59:06 <chessguy> dcoutts, that's the way it should be done
12:59:36 <fasta> dcoutts: I helped as a teaching assistant doing that.
12:59:42 <dcoutts> chessguy, yeah, I think so
12:59:49 <shapr> In my experience dcoutts is knowledgable and encouraging, and that's what I value most in a teacher.
13:00:04 * dcoutts blushes
13:00:21 <chessguy> hmm, also important to be able to express your knowledge in a comprehensible way
13:00:21 * xerox approves!
13:00:33 <shapr> True, but dcoutts has that too.
13:00:42 <chessguy> i didn't mean to imply he didn't
13:00:44 * xerox hears Duncan ask for a whiteboard
13:00:49 <dcoutts> what's with all the praise, go away!
13:00:54 <xerox> haha
13:00:55 <chessguy> haha
13:00:58 <dcoutts> ;-)
13:00:59 <shapr> That's less important for me because I teach stuff to myself, and then I want to ask questions when I get stuck.
13:01:39 * chessguy is suspicious of dcoutts because his name is way too close to 'cout'
13:01:45 <dcoutts> hah hah hah
13:02:10 <dcoutts> you don't want to know what the spell checker tries to 'correct' my name to
13:02:27 <monochrom> I don't want to know.
13:02:29 <chessguy> haha
13:02:34 <shapr> Most recently, dcoutts taught me stuff about unicycling, so I have actual experience :-)
13:02:50 <Maddas> Another unicycler? :-)
13:02:55 <Maddas> Or unicyclist, I guess.
13:03:16 <satan> hello
13:03:19 <dcoutts> Maddas, all the cool people hack Haskell and ride a unicycle! Didn't you get the memo?
13:03:23 <chessguy> does that make you unicyclical?
13:03:37 <godlike> satan: hi
13:03:58 <satan> if pam is the opposite of map, ie, it applies a list of functions to a number, how do i define it using flip and map?
13:04:15 <satan> pam = flip (map . ??)
13:04:34 * yip is suspicious of Maddas because his name is 'Maddas'
13:04:34 <dcoutts> no, use fold
13:04:47 <satan> where pam [(*2),(+3)] 1 = [2,3]
13:04:55 <satan> ok let's do both :P
13:05:17 <beelsebob> Maddas: just about half the people here unicycle
13:05:17 <Maddas> yip: Hey, it's just a coincidence, I didn't do it, and I don't know what you're talking about!
13:05:24 <monochrom> satan needs $ imho
13:05:26 <beelsebob> shapr does, dcoutts does, I do
13:05:26 <Maddas> beelsebob: Right, I just didn't think that dcoutts did too.
13:05:29 <dcoutts> satan, oh ok, that's different to what I thought you meant
13:05:33 <Maddas> oh, you too. Sheesh (-:
13:05:33 <shapr> Let's see, Haskell unicyclists include dcoutts, beelsebob, shapr, Lemmih, and who else?
13:05:42 <satan> dcoutts: ok
13:05:49 <chessguy> half of 243 is how many?
13:05:49 <dcoutts> xerox, get a unicycle and learn!
13:05:54 <beelsebob> 4
13:05:56 <shapr> Did you see the pix of Simon Peyton-Jones riding a unicycle?
13:05:57 <chessguy> ah, thanks
13:06:01 <Cale> swing f c a = f ($ c) a
13:06:08 <Cale> pam = swing map
13:06:09 <Cale> :)
13:06:09 <shapr> Cale: You should write a paper about that combinator.
13:06:18 <beelsebob> let (/) x y = 4 in 243 / 2
13:06:23 * Maddas did see those pictures
13:06:24 <satan> so i need to compose map with a function that takes each element of the list and applies it to the first arg
13:06:31 <beelsebob> > let (/) x y = 4 in 243 / 2
13:06:32 <lambdabot>  4
13:06:35 <beelsebob> see :P
13:06:35 * chessguy grins at beelsebob
13:07:14 <Cale> swing is a little bit of an abuse of our conventions for writing higher order functions on lists :)
13:07:15 <beelsebob> we've had philipa and edwinb on one before
13:07:16 <beelsebob> and ndm
13:07:18 <chessguy> we've got satan and beelsebob in here, and talking about unicycling....this channel is guaranteed to be a bad influence on me now
13:07:24 <fasta> The annoying thing about questions is that the most interesting ones can't be answered.
13:08:01 <satan> Cale: so swing just reverses the order of the arguments and adds the extra brackets with the $ ?
13:08:03 <fasta> Maddas: still got that URL somewhere?
13:08:05 <Cale> @remember chessguy we've got satan and beelsebob in here, and talking about unicycling....this channel is guaranteed to be a bad influence on me now
13:08:05 <velco> > let pam = foldr1 (.) in pam [(+2), (*3)] 1
13:08:07 <lambdabot>  5
13:08:22 <Cale> that's a different pam :)
13:09:05 <chessguy> @Cale
13:09:06 <lambdabot> Unknown command, try @list
13:09:09 <chessguy> @quote Cale
13:09:10 <lambdabot>  ... if sections were allowed at the type level ...
13:09:12 <xerox> dcoutts, yeah, I will!
13:09:14 <Maddas> fasta: Sure, http://theory.lcs.mit.edu/~rivest/Rivest-TheThreeBallotVotingSystem.pdf
13:09:16 <xerox> I need to.
13:09:21 <lambdabot> http://tinyurl.com/ye5lh6
13:09:27 <satan> so if pam = flip (map . z), then when i call pam a b, it just flips the arguments and calls (map . z) b a
13:09:50 <satan> rather (map . z) 1 [(*2),(+3)], right
13:09:58 <monochrom> So, has satan discovered map ($ 1) [(+2), (*3)] ?
13:10:11 <satan> nope :(
13:10:24 <satan> what does it do?
13:10:25 <xerox> aka swing map [(+2),(*3)] 1
13:10:33 <monochrom> map ($ n) [f,g] = [f $ n, g $ n] = [f n, g n]
13:10:47 <SamB> @type swing
13:10:48 <lambdabot> Not in scope: `swing'
13:11:11 <xerox> chessguy: what about beelsebob ?
13:11:20 <beelsebob> what about me?
13:11:28 <xerox> What does your nick mean?
13:11:40 <chessguy> xerox, what about him?
13:11:40 <SamB> xerox: beelsebob looks a lot like beelsebub, yunno?
13:11:41 <Maddas> Is it from the German Beelzebub?
13:11:45 <beelsebob> play on beelsebub
13:11:48 <fasta> Maddas: he already starts in his introduction that it's only of academic interest.
13:11:53 <xerox> And what is beelsebub?
13:11:56 <beelsebob> Beelsebub being the devil
13:12:06 <Maddas> fasta: Right.
13:12:07 <xerox> What a joke.
13:12:23 <ACSpike> what is a type f 't t1'?
13:12:25 <Maddas> xerox: :-)
13:12:35 <SamB> @devils beelsebub
13:12:36 <xerox> ACSpike: 'a b'
13:12:36 <lambdabot> No match for "beelsebub".
13:12:39 <SamB> aww
13:12:54 <xerox> SamB: hm?
13:13:01 <satan> so then my z would just be ($), with (map . $) 1 [(*2),(+3)]
13:13:12 <Maddas> fasta: Arg, the paper has changed since I read it. It didn't mention the attacks earlier.
13:13:18 <SamB> xerox: it ain't in the devil's dictionary!
13:13:21 <SamB> @devils devil
13:13:22 <lambdabot> No match for "devil".
13:13:25 <SamB> @devils satan
13:13:26 <lambdabot> *** "SATAN" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
13:13:27 <lambdabot> SATAN, n.  One of the Creator's lamentable mistakes, repented in
13:13:27 <lambdabot> sashcloth and axes.  Being instated as an archangel, Satan made
13:13:27 <lambdabot> himself multifariously objectionable and was finally expelled from
13:13:27 <lambdabot> Heaven.  Halfway in his descent he paused, bent his head in thought a
13:13:30 <lambdabot> [11 @more lines]
13:13:32 <Maddas> @devils beelzebub
13:13:33 <fasta> Maddas: I like that he admits his "mistake".
13:13:34 <lambdabot> No match for "beelzebub".
13:13:39 <Maddas> fasta: Indeed.
13:13:46 <velco> @devils Baal
13:13:47 <emu> anyone got any pointers to working with graphs and implementing things like dijkstra's shortest path algorithm in haskell? someone pointed me to an interesting paper on inductive graph representations once
13:13:48 <lambdabot> *** "BAAL" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
13:13:48 <lambdabot> BAAL, n.  An old deity formerly much worshiped under various names.
13:13:48 <lambdabot> As Baal he was popular with the Phoenicians; as Belus or Bel he had
13:13:48 <lambdabot> the honor to be served by the priest Berosus, who wrote the famous
13:13:48 <lambdabot> account of the Deluge; as Babel he had a tower partly erected to his
13:13:50 <lambdabot> [7 @more lines]
13:14:05 <fasta> emu: that's already implemented in Haskell
13:14:22 <emu> what, the paper?
13:14:24 <fasta> emu: Data.Graph.Inductive.<some module>
13:14:28 <emu> oh neat
13:14:32 <emu> included in ghc 6.6?
13:14:37 <fasta> emu: and 6.4
13:14:45 <fasta> emu: and probably 6.2 too
13:15:28 <hygge> i have a function set :: [(a,int)] -> [a], can i pattern match on the a-part of the tupple in each element?
13:15:46 <xerox> SamB: the rest of the story is scary
13:16:01 <fasta> hygge: no, you can do map fst
13:16:03 <emu> set = fst
13:16:06 <emu> er map fst
13:16:13 <SamB> xerox: which story?
13:16:20 <hygge> okey
13:16:24 <xerox> SamB: the rest of the entry
13:16:26 <fasta> > map fst [(1,2),(1,3)]
13:16:27 <lambdabot>  [1,1]
13:17:15 <SamB> xerox: yeah...
13:17:17 <SamB> it is !
13:17:29 <xerox> :(
13:20:06 <emu> fasta: do you know the name of the paper though? i want to reread it
13:20:40 <fasta> emu: http://web.engr.oregonstate.edu/~erwig/papers/InductiveGraphs_JFP01.pdf
13:20:42 <lambdabot> http://tinyurl.com/gf73z
13:20:48 <fasta> emu: I know it, I am too kind.
13:20:49 <emu> tnx
13:20:55 <satan> how do you write a lamdba function with more than 1 parameter?
13:21:05 <fasta> satan: (\x y->y)
13:21:11 <satan> ah cool thx
13:21:15 <midfield> Hi folks anyone have any experience with HaXML or other toolkits?  I'm about to start on a haskell-xml project for the first time.
13:21:26 <fasta> midfield: yep
13:21:27 <emu> satan: fundamentally, \x y -> y is the same thing as \x -> \y -> y
13:21:41 <satan> emu: ah ok, didnt know that, thanks
13:22:25 <fasta> midfield: doing XML in Haskell is not a very smart idea currently, imho.
13:22:45 <fasta> (unless you want to write a library)
13:22:54 <midfield> fasta: why is that
13:22:57 <emu> hmm? there seemed to be a pretty neat approach used by Happs
13:23:03 <emu> monadic
13:23:27 <fasta> emu: is that indepentent of HaXML, HXML, XML Toolbox?
13:23:30 <midfield> i thought haxml et al were relatively mature?
13:23:35 <fasta> er HXT
13:23:37 <emu> I don't know where it came from. but Happs uses HaXML
13:24:11 <fasta> I know of at least two people with experiences with these toolkits that don't think they are great.
13:24:31 <emu> happs allows you to generate xml and and use an xslt program to transform it into html
13:24:35 <fasta> midfield: I don't think so. You would have to look for yourself to make your own opinion.
13:25:12 <midfield> fasta: so have you tried to use it for anything?
13:25:18 <fasta> midfield: I have
13:25:40 <midfield> fasta: care to discuss your experiences?
13:25:47 <fasta> midfield: You can look in the logs.
13:25:48 <midfield> or what was the problem?
13:26:12 <midfield> ok i'll google
13:27:31 <satan> how would i declare pam without the 2 argument, as in can i write pam [] = [], instead of where i had pam [] c = []?
13:32:51 <glguy> satan: you all of the definitions must have the same number of arguments
13:33:01 <glguy> so the best yo could hope for is map [] _ = []
13:33:07 <glguy> err
13:33:07 <glguy> pam
13:33:32 <satan> hmm i tried pam [] = (\x -> []) and that seemes to work, when i gave it pam [] 1, i got []
13:33:38 <satan> which is how it was before
13:33:53 <glguy> satan: or pam [] = const []
13:34:04 <satan> ok lemme try that
13:34:37 <satan> cool, thanks
13:36:16 <moonlite> @type const
13:36:17 <lambdabot> forall a b. a -> b -> a
13:38:07 <glguy> or
13:38:09 <glguy> > return 1 2
13:38:10 <lambdabot>  1
13:38:40 <satan> cool
13:40:07 <satan> ok now i'm trying to redefine it again :)
13:41:41 <draganov> hey falks...
13:41:46 <draganov> some1 alive ?
13:41:53 <satan> i guess i'm just not clear on how haskell works with the parameter not specified
13:42:16 <glguy> the function is returning a function
13:42:21 <satan> like when pam2 (f:fs) =  z f (pam2 fs), how would i define z to handle the argument not specified?
13:42:23 <glguy> functions are values
13:42:34 <glguy> satan: the z?
13:42:36 <satan> cause normally its pam2 (f:fs) x
13:42:37 <draganov> is there any way to debug haskell ?
13:42:54 <satan> glguy: yes
13:43:03 <velco> by VisualInspection(tm) :)
13:43:08 <RyanT5000> what's a good xml editor for linux?
13:43:08 <twanvl> what kind of bug do you have?
13:43:17 <Lemmih> RyanT5000: emacs.
13:43:22 <dcoutts> RyanT5000, vim
13:43:23 <RyanT5000> how do i get sgml-mode to do indenting?
13:43:40 <satan> glguy: normally, it's pam (f:fs) x  = f x : pam fs x, so how would i define the z to do the same, without the x argument
13:44:28 <glguy> so f:fs is a list of functions?
13:44:32 <satan> yes
13:44:50 <glguy> satan: why not just do this:
13:45:06 <glguy> > map ($ 1) [(+1),(+3),(*4)]
13:45:07 <lambdabot>  [2,4,4]
13:45:27 <satan> right, we discussed that above :)
13:45:43 <glguy> ah
13:45:52 <RyanT5000> Lemmih: sgml-mode doesn't seem to let me indent anything by default
13:45:59 <satan> this is just another attempt at it so i can learn
13:46:14 <glguy> satan: you won't like the answer to this question, but let me write it
13:46:29 <satan> so z must take 3 arguments, right? f, (pam2 fs) and x
13:46:44 <glguy> pam (f:fs) = liftM2 (:) f (pam fs)
13:47:07 <satan> you're right, i have no idea what that is :S
13:47:44 <satan> > @type liftM2
13:47:45 <lambdabot>  Parse error
13:47:53 <glguy> ?type liftM2
13:47:54 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:48:13 <satan> is there a non monadic way to solve it?
13:48:21 <beschmi> RyanT5000: i don't know about sgml-mode but nxml-mode does indentation for me.
13:48:30 <RyanT5000> cool
13:51:53 <glguy> satan: you could write a new function to do it without the reader monad
13:52:39 <satan> glguy: ok, i think i'll try that, i'm having a hard time visualizing how it'll work
13:53:22 <glguy> satan: I just mean you could write a: fun f g h x = f (g x) (h x) and use that
13:54:35 <glguy> and you can do that with Arrows and uncurry
13:55:04 <satan> ok...
13:55:07 <glguy> ? type (\f g h x -> uncurry f $ g &&& h $ x)
13:55:13 <glguy> ?pl (\f g h x -> uncurry f $ g &&& h $ x)a
13:55:13 <lambdabot> ((uncurry a .) .) . (&&&)
13:55:21 <glguy> ?pl (\f g h x -> uncurry f $ g &&& h $ x)
13:55:21 <lambdabot> (. (&&&)) . (.) . (.) . uncurry
13:56:44 <glguy> pam (f:fs) = ((flip ((.).uncurry).).(&&&)) f (pam fs) (:)
13:57:15 <satan> omg
13:57:20 <satan> what does the &&& do?
13:58:02 <lispy> satan: if you read about arrows you'll find it
13:58:06 <glguy> > (*2) &&& (*3) $ 5
13:58:07 <lambdabot>  (10,15)
13:58:10 <lispy> satan: iirc, it combines two arrows
13:58:45 <lispy> but, i have to say that pam doesn't look like a password authentication module to me at all :)
13:59:11 <satan> hmm i get a 'not in scope' error with ghci, anything i need to load?
13:59:16 <satan> haha it's not :P
13:59:54 <glguy> ?index (&&&)
13:59:54 <lambdabot> Control.Arrow
14:00:10 <satan> cool, thanks
14:00:14 <glguy> but if you have an aversion to Monad's, I'd avoid Arrows
14:00:42 <satan> can i try this admittedly naive, but seems-to-be-working approach? pam2 (f:fs) =  h f (pam2 fs) where
14:00:42 <satan> 			h  a b c = a c : b c
14:01:24 <satan> your solution looks a bit like Sanskrit+Greek to me :(
14:01:38 <draganov> is there any good haskell manual ?
14:02:14 <glguy> ?where yaht
14:02:15 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
14:02:41 <satan> ok so that's done
14:02:53 <satan> moving on to defining pam with foldr now heh
14:02:58 <satan> i bet this is the trickiest
14:03:16 <glguy> not really....
14:04:12 <glguy> what class is this for?
14:04:27 <satan> none, for myself
14:04:44 <satan> i've been teaching myself haskell by doing small exercises now and then, and bugging the good folks in here :P
14:07:01 <satan> so for pam = foldr h c, i'd have to define c as a function that takes a list of functions and an int
14:07:12 <satan> since it'll be called with pam a b = foldr h c a b
14:10:03 <glguy> > let pam = flip (flip foldr [] . ((:) .) . flip  id) in pam [(+2),(*3)] 4
14:10:04 <lambdabot>  [6,12]
14:10:40 <velco> > let pam = foldr id (.) in pam [(+2), (*3)] 2
14:10:41 <lambdabot>  add an instance declaration for (Num (b -> c))
14:12:28 <velco> let pam = foldr (.) id in pam [(+2), (*3)] 2
14:13:09 <velco> > let pam = foldr (.) id in pam [(+2), (*3)] 2
14:13:10 <lambdabot>  8
14:14:48 <satan> glguy: i don't quite understand how you did that
14:16:05 <glguy> pam fs x = foldr (\a b -> a x : b) [] fs
14:16:50 <glguy> pam fs x = foldr ( (:) . ($ x) ) [] fs
14:18:36 <SamB> hmm...
14:18:45 <SamB> I have a bunch of lists and I want to add their elements...
14:18:57 <SamB> elementwise...
14:19:05 <xerox> I know it!
14:19:06 <glguy> transpose and then sum?
14:19:13 <glguy> err, map sum
14:19:14 <xerox> transpose<Interrupted by glguy>
14:19:24 <SamB> > transpose [[1],[2,3]]
14:19:25 <lambdabot>  [[1,2],[3]]
14:19:27 <kowey> ?tell dmhouse the YAHT import has landed - http://en.wikibooks.org/wiki/Haskell/YAHT
14:19:27 <lambdabot> Consider it noted.
14:19:35 <SamB> > transpose (transpose [[1],[2,3]])
14:19:36 <lambdabot>  [[1,3],[2]]
14:19:39 <glguy> map sum . transpose
14:19:45 <SamB> okay!
14:19:54 <xerox> ^_^
14:20:10 <glguy> xerox: I had that one on hotkey
14:20:14 <emu> @type mkGrap
14:20:15 <lambdabot> Not in scope: `mkGrap'
14:20:15 <emu> @type mkGraph
14:20:16 <lambdabot> Not in scope: `mkGraph'
14:20:17 <xerox> heh
14:20:20 <glguy> you never had a chance (c:
14:20:29 <xerox> clown!
14:20:42 <satan> glguy: would that definition of pam change if it was specified with no arguments, like pam = foldr ...
14:21:02 <glguy> satan: my original foldr examle used no arguments on pam
14:21:24 <satan> glguy: the one with the flips, right?
14:21:28 <monochrom> still pamming?
14:21:29 <xerox> hehe
14:21:36 <xerox> That's an evil way to explain to satan.
14:22:35 <satan> :(
14:22:36 <glguy> xerox: there's no *clean* way to do what he's asking for :-p
14:22:47 <xerox> What is he asking for?
14:22:49 <chessguy> Data Tree a = Leaf a | Branch (Tree a) (Tree a) --if i have a tree like this, and a function which, given a tree, returns a particular branch of the tree, how would i remove that branch from the tree?
14:22:59 <glguy> xerox: a point-free solution using foldr for his problem
14:23:09 <yip> so who is this Shriram guy anyway? is he good or is he evil?
14:23:16 <xerox> chessguy: I suggest a zipper!
14:23:32 <chessguy> ...
14:23:36 <xerox> glguy: ah, *he's* evil.
14:23:39 <xerox> chessguy: I'm not kidding.
14:23:46 <satan> heh
14:23:46 <chessguy> @hoogle zipper
14:23:47 <lambdabot> No matches found
14:23:58 <xerox> Nope.
14:24:08 <satan> i'm grateful for your help, glguy, don't get me wrong, thanks a bunch :)
14:24:18 <xerox> chessguy: http://www.haskell.org/haskellwiki/Zipper
14:24:20 <lambdabot> Title: Zipper - HaskellWiki
14:24:22 <xerox> It's great!
14:24:34 <monochrom> You build a new tree.  In the new tree, you reuse stuff from the old tree, except for the chosen branch.
14:24:44 <shapr> edwardk: Any writings about your substructural stuff?
14:24:52 <shapr> edwardk: blog, notes, pix, anything?
14:25:05 <xerox> monochrom: the zipper basically does that.
14:25:15 <chessguy> ok, i'll check it out
14:25:34 <monochrom> Ah, tracking locations, nice, because what I just said is easier said than done.
14:26:23 <xerox> It's not exactly easy to do it efficiently?
14:27:05 <xerox> I suppose I'll do a _big_ number of == and rely on laziness and luck, hehe.
14:28:36 <glguy> satan: more monads
14:28:37 <glguy> > let pam = (. return) . ap in pam [(*3),(+1)] 3
14:28:38 <lambdabot>  [9,4]
14:28:58 <glguy> (which is an ugly way to write:)
14:29:05 <satan> ack
14:29:24 <xerox> ...
14:29:28 <xerox> You want swing.
14:29:33 <xerox> I told you before.
14:29:40 <satan> yup :)
14:29:40 <monochrom> In Ocaml with pointer equality is easy.
14:29:52 <glguy> > let pam = flip (fmap . flip id) in pam [(*3),(+1)] 3
14:29:53 <lambdabot>  [9,4]
14:29:57 <xerox> satan: http://haskell.org/hawiki/LicensedPreludeExts
14:29:58 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
14:30:22 <xerox> > let swing f c a = (f ($ a)) c in swing map [(+1),(*2)] 2
14:30:23 <lambdabot>  [3,4]
14:31:14 <satan> wow awesome thanks, xerox for that link
14:31:25 <xerox> You're welcome satan.
14:31:58 <hygge> haha
14:32:11 <xerox> brrr.
14:32:22 <SamB> @hoogle Args
14:32:23 <lambdabot> Distribution.Simple.Args :: type Args
14:32:23 <lambdabot> System.getArgs :: IO [String]
14:32:23 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
14:33:18 <xerox> What do you know about the Haskell's paradox?  Haskell B. Curry's paradox.
14:34:11 <satan> who, me?
14:34:23 <xerox> Plural you :)
14:34:34 <satan> heh, ok, well i don't know about it
14:34:42 <monochrom> We don't know.  (Royal We.)
14:34:49 <xerox> You B0rgs.
14:35:32 <chessguy> hmm, i'm not seeing how to use this zipper to modify an existing tree
14:35:52 <xerox> You travel from the root to the place you want to modify.
14:36:14 <xerox> Then you use |modify :: Loc a -> (a -> a) -> Loc a
14:36:24 <xerox> |, oops.
14:36:50 <xerox> ...and then you travel back to the root.
14:36:52 <monochrom> Henceforth your tree functions do not work on trees.  They work on (tree, context) pairs.
14:37:09 <xerox> Oops.
14:37:29 <xerox> I think it's really |modify :: Loc a -> (Tree a -> Tree a) -> Loc a.
14:37:38 <xerox> |, ...
14:37:39 <chessguy> yes, it is
14:37:47 <xerox> OK, much better :)
14:37:58 <chessguy> shame he doesn't give any real examples
14:38:08 <xerox> Like what?
14:38:31 <chessguy> like a tree and a modification, and the resulting tree
14:39:12 <xerox> Check out Oleg's code :)
14:39:24 <xerox> @google Zipper Based File System
14:39:26 <lambdabot> http://lambda-the-ultimate.org/node/1036
14:39:26 <lambdabot> Title: Zipper-based file server/OS | Lambda the Ultimate
14:39:53 <monochrom> that is a toy example, not a real example.  a real example is a 10MLOC beast in which the technique is used but also combined with a million other coding tricks and therefore nothing is readable.
14:40:13 <xerox> What is this real example?  Eeek.
14:40:29 <monochrom> For example the GHC source code probably uses some zipper trick somewhere.
14:40:37 <xerox> Wow.
14:40:51 <monochrom> It may also be a real example of monads.
14:40:59 <chessguy> a real example would be taking his tree F (F (L 1) (L 2)) (F (L 2) (L 4)) and showing how you would delete the (L 2) branch
14:41:00 <xerox> I like this one.
14:41:09 <xerox> Do you have a suitable definition lying around?
14:41:19 <chessguy> who, me?
14:42:28 <monochrom> What is delete the (L 2) branch?
14:43:08 <chessguy> uh, bad example
14:43:49 <chessguy> a real example would be taking his tree F (F (L 1) (L 2)) (F (L 2) (L 4)) and showing how you would construct F (F (L 1) (L 2)) (F (L 3) (L 4))
14:43:55 <hygge> aah, whats wrong with my code for the subbags-function? http://pastebin.perl.se/a90753c20e/
14:44:45 <monochrom> use f = \t -> L 3  for modify
14:45:01 * xerox nods
14:45:18 <chessguy> and then the context of L 2 ?
14:45:30 <dibblego> when writing a function with pattern matching, is it possible to write a where that applies to the entire function definition?
14:45:32 <xerox> Stays the same.
14:45:58 <xerox> modify (tree,ctx) f = (f tree,ctx)
14:46:14 <Lemmih> hygge: add Ord a =>.
14:46:15 <xerox> Or if you swap the arguments, modify = first.
14:46:20 <ACSpike> http://rafb.net/paste/results/UNDxVU76.html trying to learn parsec, is it possible to return the value of more than the last parser?
14:46:22 <araujo> dibblego, use guards
14:46:32 <mauke> @pl modify (tree,ctx) f = (f tree,ctx)
14:46:32 <lambdabot> modify = uncurry (flip . ((,) .) . flip id)
14:46:33 <dibblego> araujo, ah thanks
14:46:35 <dvekravy_> hi, is there a function in standard ghc libraries to sort MArray? I cannot find any..
14:46:49 <araujo> welcome dibblego
14:47:09 <Lemmih> dvekravy_: There isn't one.
14:47:12 <dibblego> araujo, come to think of it, I tried that and failed - because I am matching on a polymorphic algebraic type
14:47:21 <hygge> lemmih, so everytime it says "cannot justify constraints in explicitly typed binding". i should think of restrict my function to a certain type class?
14:47:23 <chessguy> but i still have to move to the right location first
14:47:31 <hygge> thx btww
14:47:48 <dibblego> data Type a= Constructor a \n f (Constructor a:xs) = foo
14:47:59 <dibblego> but I tried writing that as a guard
14:48:05 <Lemmih> hygge: Yeah, or you could use ghc.
14:48:13 <hygge> okey :P
14:48:30 <dibblego> data Type a = Constructor a \n f(x:xs) | x == (Constructor a) = foo -- failed
14:48:34 <mauke> compiling ghc takes forever :/
14:48:42 <chessguy> so i could define a function moveTo x which moves from the root to node x
14:48:48 <araujo> dibblego, f ((Constructor a):xs) .....
14:49:04 <chessguy> call that function, then use modify, and then another function which goes back to the root?
14:49:08 <dibblego> araujo, that's what I have already - but I want to use guards
14:49:14 <araujo> It should work
14:49:33 <dibblego> araujo, sure it works, but then I have multiple constructors to match and a where clause I want to apply to all of them
14:49:51 <monochrom> I just created an account on the wiki.  I am thrilled that my ID is a well-rounded number 600.
14:49:56 <araujo> dibblego, What is the error?, did you make your type instance of the Eq class?
14:50:01 <chessguy> am i close to right, xerox?
14:50:12 <monochrom> Someone please give me a present for being the 600th customer!
14:50:19 <dibblego> araujo, yes, my error is that I cannot seem to use guards successfully - pattern matching works fine
14:50:23 * chessguy hands monochrom a smelly toad
14:50:33 * xerox hands monochrom lambdacookies
14:50:34 <dibblego> data Type a = Constructor a \n f(x:xs) | x == (Constructor a) = foo -- how do you write this?
14:51:05 <xerox> dibblego: f ((Constructor a):xs) = foo
14:51:05 <araujo> dibblego, what is the exact error message?
14:51:14 <dibblego> xerox, I already have that
14:51:21 <xerox> dibblego: that is correct.
14:51:24 <araujo> xerox, he wants to use guards
14:51:39 <xerox> chessguy: I'm trying to write it out.
14:51:44 <chessguy> ok
14:51:45 <xerox> araujo: it sucks with guards.
14:51:56 <dibblego> gah
14:51:59 <xerox> Pattern matching is powerful!
14:52:07 <dibblego> xerox, yes, but not for this case
14:52:07 <araujo> xerox, sucks like in, doesn't work, or you jus dislike? :-P
14:52:19 <dibblego> xerox, I want to use a where clause across all patterns
14:52:29 <xerox> dibblego: lambda-lift it
14:52:31 <dibblego> xerox, I *currently* have it implemented with pattern matching
14:52:49 <dibblego> how does one achieve that?
14:52:54 * shapr wants a cookie
14:52:54 <araujo> dibblego, if you just say the error messages ....
14:53:00 <dibblego> araujo, ok, gimme a sec
14:53:02 <xerox> Then your worker is already lambda-lifted.
14:53:09 * araujo throws a lambda cookie at shapr 
14:53:23 * chessguy dives....interception!
14:53:59 <shapr> yay!
14:54:03 <shapr> cookie interception!
14:54:04 <expwiz> if I use the following pattern matching:  f True True True = ..  f True True False = .. f True False True = .. f True False False = .. and so on and if I call: f False False False, will it do 9 tests? or does it optimise it somehow?
14:54:09 <dibblego> f (x:xs) | x == (Constructor a) = foo -- not in scope 'a'
14:54:11 <araujo> hah
14:54:14 <araujo> :-)
14:54:25 <chessguy> what can i say, it's football season :)
14:54:26 <araujo> oh.. mmm
14:54:42 <araujo> dibblego, You evidently need to replace 'a' for a valid value
14:54:51 <dibblego> araujo, I don't want to
14:54:52 <xerox> expwiz: if you really need all the clauses, in the sense that they all have a different return value, then it'll check for all ones.
14:54:58 <chessguy> man, playing with haskell is way too much fun relative to all the work i'm supposed to be doing
14:55:01 <araujo> dibblego, uh?
14:55:15 <dibblego> araujo, a is polymorphic - I want to leave it that way
14:56:13 <araujo> dibblego, I think you should have to define your instance of the Eq class then
14:56:19 <araujo> your own*
14:56:38 <dibblego> I'll just use pattern matching
14:57:12 <araujo> And probably write a  new "==" operator
14:57:26 <araujo> You pattern match on values.
14:57:41 <xerox> monochrom: I'm thinking about how to handle the exceptions where one want to go left or right on leaves. I wonder if it should do nothing, getting some algorithms stuck, or bounce back, breaking some other possible algorithms, or what else.
14:57:51 <araujo> 'a' isn't a valid value
14:57:52 * chessguy looks at xerox...
14:58:00 <araujo> It is a type variable.
14:58:02 <dibblego> araujo, I use 'a' in the patterns
14:58:11 <araujo> oh isee
14:58:18 * araujo got confused
14:58:23 <dibblego> me too )
14:58:24 <dibblego> :)
14:58:31 <expwiz> ok.. so a better way would be =  f a b c = if a { if b { if c {.} else {.} } else if c {.} else {.}} else if b {... and so on .. its a bit ugly :)
14:58:52 <dibblego> ex0-r, it will be O(1)
14:58:53 <araujo> dibblego, ok, but you are using (Constructor a) , as a value. Not as a pattern match
14:59:16 <xerox> A Monad would encode whatever choice nicely.
14:59:40 <monochrom> with or without context, trying to traverse to the left child of a leaf is a programming error.
14:59:41 <dibblego> araujo, well, depends on my approach - I will stick with pattern matching it seems
14:59:51 <araujo> dibblego, I think you could write a "isContructor" function
14:59:57 <xerox> monochrom: ah, I see.
15:00:28 <araujo> isContructor (Constructor _) = True ; isConstructor _ = False
15:00:39 <monochrom> With that in mind, you can do whatever you want!  I recommend "unsafePerformIO (system "rm -rf *")"
15:00:45 <xerox> monochrom: but one of the niceties of the zipper, as I see it, is that you've this ship travelling along, and it could bounce on the border or notice it somehow, if you know what I mean.
15:00:56 <araujo> f a | isConstructor a = .... | otherwise ..... where ....
15:01:16 <araujo> dibblego, that should work
15:01:41 <xerox> ..for thedailywtf.
15:02:06 <dibblego> araujo, I might write out a complete case - I cannot see what you mean right now
15:02:08 <monochrom> I think the most popular way is to throw an exception.  Someone can catch it in the IO monad.
15:02:10 <araujo> dibblego, the problem is that you were trying to use the equality operator (==) as a patter matching operation
15:02:45 <chessguy> can't you just do moveLeft leftMostNode = error "you can't do that moron!"
15:03:11 <dibblego> araujo, I'm foncused atm, but thanks
15:03:30 <monochrom> If you have a lot of time, provide two traversal functions.  One throws an exception.  The other is a nop.
15:03:46 <chessguy> nop?
15:03:51 <monochrom> no op
15:04:02 <chessguy> no op?
15:04:09 <xerox> No-operation.
15:04:12 <araujo> dibblego, The isConstructor function is a way to take pattern matching into the guards. That's what you want i think
15:04:13 <monochrom> Am I just too old?
15:04:22 <chessguy> No-operation?
15:04:25 <SamB> monochrom: no
15:04:28 <dibblego> araujo, what will isConstructor look like?
15:04:29 <SamB> maybe you should say NOP
15:04:38 <SamB> to invoke that ASM mindset ;-)
15:04:59 <chessguy> ASM, we studied that in my CS history class
15:05:02 <xerox> left t@(Leaf _,_) = t
15:05:02 <xerox> left (Branch l r,c) = (l, Left c r)
15:05:04 <araujo> dibblego,  isContructor (Constructor _) = True ; isConstructor _ = False
15:05:05 <chessguy> just kidding
15:05:05 <SamB> chessguy: hah
15:05:10 <araujo> dibblego, ust what i wrote
15:05:14 <xerox> Here it is the no-op one, chessguy.
15:05:15 <araujo> just even
15:05:17 <monochrom> I am like keep using these 20th Century terms "no op", "subroutine", "unix shell pipeline" that nobody here has heard of.
15:05:29 <dibblego> araujo, thanks
15:05:30 <SamB> hahah
15:05:33 <SamB> right
15:05:35 <xerox> left (Leaf _,_) = error "Fallen over on the left of a leaf."
15:05:35 <xerox> left (Branch l r,c) = (l, Left c r)
15:05:37 <araujo> welcome dibblego
15:05:38 <SamB> nobody has heard of them how?
15:05:56 <lispy> ?type ((.)$(.))
15:05:57 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
15:06:00 <monochrom> Like if I say "directory" no one knows what it is but they call it "folder".
15:06:20 <chessguy> ok
15:06:21 <SamB> monochrom: who are you talking about?
15:06:26 <SamB> and I have that problem too ;-)
15:06:35 <xerox> Ora CS professor calls it in italian "foldone", which I don't think makes any sense, but sounds like "folder"...
15:06:47 <chessguy> isn't that equivalent to the code on http://www.haskell.org/haskellwiki/Zipper
15:06:48 <lambdabot> Title: Zipper - HaskellWiki
15:07:04 <SamB> I think its more a matter of being more technical than of being *old*
15:07:28 <xerox> chessguy: nope, that gives a runtime error when you go left or right on a leaf.
15:07:34 <chessguy> i can never remember which came first, directories or folders. they all seem about the same to me
15:07:46 <xerox> Exhausted pattern matches.
15:07:47 <chessguy> ok, so yours is a safer version, but it does the same thing
15:08:04 <lispy> i'm pretty sure directories came first and a folder is part of the GUI Desktop metaphore
15:08:20 <xerox> I'm in doubt about what to use because I want to write the actual algorithm with the best interface behind it.
15:08:20 <monochrom> We lack a subroutine for computing the new tree from the result of modify.  An inverse of left, right, top.
15:08:33 <xerox> I did it one time.
15:08:46 <xerox> I used a Writer monad.
15:08:53 <xerox> `told' out my way in, and applied it.
15:09:17 <monochrom> Oh darn it's called up.
15:09:24 <chessguy> anyway, i think i get the idea now
15:09:24 <xerox> Oh!
15:09:42 <monochrom> Well it's a fixpoint over up anyway.
15:09:47 <xerox> Very right.
15:10:07 <xerox> I think my thing was slightly different then.
15:15:19 <astrolabe> If I want to define a PDF (probability density function class) that will enable me to say that an object of type Gaussian is an instance of PDF Double, and provides sample::Seed -> Gaussian -> (Double,Seed) and evalPDF :: Gaussian -> Double -> Probability  (where type Probability = Double), do I need multi-parameter type classes?
15:16:34 <chessguy> hmm, i'm going to have to find a way to print out a tree if i want to test this
15:16:48 <chessguy> i need an instance of Show, right?
15:18:02 <mauke> deriving (Show)
15:18:17 <xerox> astrolabe: it depends on whether you have one or more parameters for your class :)
15:18:42 <xerox> chessguy: yes, use the clause "deriving (Show)" for your datatyep
15:18:44 <xerox> *datatype
15:18:55 <xerox> Ops, sorry mauke.
15:19:10 <chessguy> and then i define show Tree ...
15:19:20 <chessguy> right?
15:19:30 <mauke> no
15:19:37 <xerox> That clause will automatically derive a Show instances for your datatype.
15:19:40 <mauke> 'deriving' tells the compiler to define it for you
15:19:41 <xerox> *instance
15:19:49 <SamB> except of course it will be far too ugly!
15:19:53 <chessguy> oh ok
15:20:11 <astrolabe> xerox: I want the class to take for example Double as a parameter to say that the type is a PDF over doubles, but I can't make it work with just a single parameter like that.
15:20:38 <xerox> astrolabe: right, there is a dependency between that parameter, and say, the seed?
15:20:53 <astrolabe> Not the seed, no.
15:20:57 <xerox> What else?
15:21:16 <astrolabe> I have trouble when I get to defining the instances.
15:21:24 <xerox> What trouble?
15:21:36 <astrolabe> instance (PDF Double) Gaussian where
15:21:53 <xerox> Ah, Gaussian is a parameter that depends on Double?
15:22:24 <astrolabe> Gaussian is a type that lets you sample doubles, yes.
15:22:29 <xerox> Good.
15:22:49 <roconnor> 186 points for BLNCE.CRE
15:23:15 <sylvan> Did the ICFP winners this year choose C++ or Haskell as their language or choide for the "prize"?
15:23:24 <xerox> Then you want class PDF p sampler where sample :: Seed -> sampler -> (p,Seed); evalPDF :: sampler -> p -> Probability
15:23:25 <roconnor> they chose 2-D
15:23:46 <sylvan> ah... hmm.. Guess I'll have to look that one up then :-)
15:23:54 <chessguy> aww, man, haskell is SO cool
15:24:03 <xerox> astrolabe: furthermore, if you want to enable only one sampler for each p, you write a functional dependency: |class PDF p sampler | p -> samper where ...|.
15:25:15 <sylvan> what is this 2D language? I can't find any information!
15:25:15 <astrolabe> I think I want only one p for each sampler
15:25:27 <xerox> astrolabe: cool, then, it's the other way around.
15:25:34 <astrolabe> xerox: thanks.
15:25:39 <xerox> You're very welcome 'labe.
15:25:51 <xerox> It's a powerful feature.
15:26:00 <xerox> The door to type computations.
15:26:14 <astrolabe> Any chance of it appearing in a standard at some point?
15:26:31 <xerox> I bet Haskell' will have them.
15:26:39 * chessguy hugs xerox
15:26:43 <astrolabe> That would be nice
15:26:45 * xerox hugs back
15:26:56 <astrolabe> chessguy: yes it is cool!
15:27:03 <SamB> sylvan: see ICFP 2006 contest
15:27:34 <sylvan> SamB, That's where I started, can't find any information about 2D though...
15:27:42 <SamB> *inside*
15:27:58 <SamB> you have to play the game!
15:28:11 <sylvan> ah, so it's a contest specific language?
15:28:15 <SamB> yes!
15:28:18 <sylvan> ah, cool!
15:28:34 <SamB> its a really nasty one, too!
15:28:38 <sylvan> I thought it was some cool new language endorsed by the google folks :-)
15:28:55 <SamB> there is a reason they are called "team smartass"
15:29:00 <sylvan> hehe
15:33:07 <roconnor> @paste
15:33:07 <lambdabot> http://paste.lisp.org/new/haskell
15:34:24 <mauke> @pasta
15:34:24 <lambdabot> http://paste.lisp.org/new/haskell
15:36:38 * SamB makes a note that if both mauke and roconnor invite him for dinner, and it is equally easy to get to each's house, to take mauke's offer ;-)
15:37:41 * chessguy is beginning to think that writing a GP engine in haskell is do-able, even for me, a n00b
15:38:52 <Botty> @psate
15:38:52 <lambdabot> Maybe you meant: gsite paste
15:39:11 <Botty> not so smart now, are yah? ;P
15:39:38 <mauke> @pate
15:39:38 <lambdabot> http://paste.lisp.org/new/haskell
15:40:19 <chessguy> heh. pate works, but psate doesn't?
15:40:44 <Botty> probably because of the second letter of 'gsite'
15:40:59 <Botty> @pasteplease
15:41:00 <lambdabot> Unknown command, try @list
15:41:11 <Botty> @pastel
15:41:11 <lambdabot> http://paste.lisp.org/new/haskell
15:41:16 <Botty> heh
15:41:29 <Botty> @pascal
15:41:29 <lambdabot> Unknown command, try @list
15:41:39 <mauke> w00t, it finished
15:41:42 <mauke> The Glorious Glasgow Haskell Compilation System, version 6.6
15:41:58 <Botty> next version should be 6.6.6
15:42:04 <chessguy> a new version of GHC?
15:42:06 <SamB> hah
15:42:11 <SamB> not yet!
15:42:20 <SamB> and only if the 6.6 line goes on longer than most!
15:43:06 <dibblego> are there any efficiency gains for a:b:c:xs over [a,b,c] ++ xs ?
15:43:47 <mauke> ARGH. ghci-6.6 still panics
15:44:45 <monochrom> I have added stuff to the Zipper wiki page.
15:46:18 <Igloo> mauke: Doing what?
15:47:28 <chessguy> hmm, i don't understand what you mean by "retrieve the new tree"
15:47:31 <mauke> Igloo: http://hackage.haskell.org/trac/ghc/ticket/953
15:47:34 <lambdabot> Title: #953 (panic in ghci for lseek ffi import statement) - GHC - Trac, http://tinyurl.com/y79mur
15:47:40 <monochrom> WHAT?!
15:48:01 <Igloo> Ah, OK
15:49:34 <chessguy> you never defined upmost, did you?
15:49:55 <chessguy> heh
15:52:39 <yip> dibblego: ideally both forms would be compiled to the same code :|
15:52:57 <dibblego> yip, in reality?
15:53:02 <yip> i have no idea
15:53:25 <dibblego> righto ta
15:54:59 <chessguy> @hoogle upmost
15:54:59 <lambdabot> No matches found
15:57:23 <chessguy> xerox, do you understand his wiki edit?
16:03:52 <ACSpike> http://rafb.net/paste/results/nZTy5O93.html
16:05:37 <araujo> mmm ...
16:05:56 <araujo> is it possible for a expression evaluation to return 2 exceptions in the same time?
16:10:45 * draganov is away (auto-away after 2hrs of inactivity) - (12:09 am)
16:10:51 <chessguy> ah, i get it now
16:11:26 <Cale> araujo: no
16:11:38 <Dreadshoot> http://www.skyos.org/?q=node/516
16:11:39 <lambdabot> Title: The always helpful community | SkyOS
16:11:56 <araujo> Cale, mm.. no remotely possible .. let's say .. nested processes?
16:12:09 <alkoma> Possible fix: add an instance declaration for (Show (Cxt Integer))
16:12:09 <alkoma>     In the expression: print it
16:12:09 <alkoma>     In a 'do' expression: print it
16:12:20 <Cale> araujo: only one of those will be forced before the exception is thrown
16:12:37 <Cale> of course, you can do things like  map error [1..]
16:12:37 <araujo> I see ...
16:12:46 <araujo> Cale, that's automatically handled?
16:12:47 <Cale> er
16:12:53 <Cale> of course, you can do things like  map (error . show) [1..]
16:13:06 <Cale> which is an infinite list of exceptions which are all different
16:13:33 <Cale> but only the first one to be used will be thrown
16:13:56 <araujo> i see
16:14:11 <chessguy> [*** Exception: 1
16:14:28 <araujo> Cale, that's automatically handled by the rts?
16:14:29 <chessguy> > map (error . show) [1..]
16:14:29 <lambdabot>  Add a type signature
16:14:45 <Cale> araujo: yeah
16:14:54 <araujo> good
16:15:18 <Cale> araujo: catching such exceptions is a little tricky, because they have to actually occur when you're in the catch block :)
16:15:43 <Cale> so you might have to force some evaluation with Control.Exception.evaluate in order to see them
16:15:50 <araujo> Cale, mmm .. i think that's the kind of situation i have here
16:15:57 <araujo> yeah
16:16:07 <araujo> i am playing with it atm
16:16:49 <araujo> So, i can force the order of evaluation for catching the exceptions properly right?
16:17:14 <Cale> ACSpike: that's a nice error, showing off a present weakness of Haskell's typesystem
16:17:30 <Cale> ACSpike: What you need to do is move the show inside the case
16:17:49 <Cale> ACSpike: Polymorphic functions can only be instantiated at one type at a time
16:17:58 <ACSpike> Cale: thanks
16:18:18 <yip> Cale: who is this Shriram guy? is he good or is he evil?
16:18:37 <Cale> yip: he's a good guy, he's just pretending to be a bit evil in that video
16:18:57 <Cale> yip: He's one of the people working on PLT scheme
16:19:14 <Cale> http://www.cs.brown.edu/~sk/
16:19:15 <lambdabot> Title: Shriram Krishnamurthi
16:19:43 <Cale> If you look at http://www.cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/ you'll see that he actually is quite aware of Fran :)
16:19:44 <lambdabot> Title: Embedding Dynamic Dataflow in a Call-by-Value Language, http://tinyurl.com/y5sgew
16:29:35 <glguy> any LyX users?
16:32:48 <SamB> I'm sure there are some ;-)
16:33:22 * SamB ponders whether to use LyX or plain LaTeX for his second lab report section...
16:34:01 <edwardk> samb: plain latex ;)
16:34:06 <edwardk> lyx is evil
16:34:22 <SamB> how so?
16:34:32 <glguy> I'm getting an error LyXTextClassList::Read: unable to find textclass file  `'. Exiting.
16:34:40 <glguy> just wondering if anyone else has seen that
16:34:45 <SamB> never!
16:34:51 <edwardk> er, well, it just is =) it creates some pretty terrible LaTeX
16:34:58 <SamB> I'd give up and go use that nice emacs mode
16:35:11 <SamB> edwardk: you aren't supposed to *read* that stuff...
16:35:27 <edwardk> well, sometimes you need to
16:35:47 <SamB> like when?
16:35:57 <edwardk> when lyx goes horribly horribly wrong =)
16:36:46 <edwardk> which it has unfortunately done for me one too many times
16:44:15 * glguy figured out the problem with LyX, needed to restart X and create ta symlink for python
16:53:04 <dons> moin
16:53:10 <dons> ?uptime
16:53:11 <lambdabot> uptime: 2d 21h 57m 53s, longest uptime: 6d 15h 1m 36s
16:53:49 <glguy> dons: what happened to the tinyurls?
16:54:17 <dons> http://www.google.com
16:54:17 <lambdabot> Title: Google
16:54:21 <dons> hmm!
16:54:30 <dons> tinyurl.com must have done something
16:54:36 <dons> without telling us, how rude!
16:54:51 <Cale> we were singlehandedly using up their space of keys
16:54:55 <Cale> hehe
16:54:59 <dons> maybe :)
16:55:11 <Dreadshoot> dons: http://www.skyos.org/?q=node/516 read this one
16:55:13 <lambdabot> Title: The always helpful community | SkyOS
16:55:29 <chessguy> ?users
16:55:30 <lambdabot> Maximum users seen in #haskell: 256, currently: 227 (88.7%), active: 33 (14.5%)
16:56:55 <dons> Dreadshoot: heh.
16:57:01 <dons> Dreadshoot: I hope you don't think we're like that?
16:57:23 <dons> script kiddie to dev ratio is way more in favour of "dev" here, I think :)
16:58:22 <Dreadshoot> dons: not at all, just interesting how some communities are
16:58:41 <Dreadshoot> and some people.. from almost all communities/help channels
16:59:41 <Cale> too bad he's not working on perl 6, since I get the impression that community is a lot friendlier
16:59:43 <Dreadshoot> that guy has written a whole OS, and must sit and programming 24/7 and they treated him like he knew nothing
17:00:10 <dons> yeah, some commuities just malfunction
17:00:30 <Cale> FreeNode is absolutely right that you need catalysts
17:01:06 <SamB> dons: script kiddie? what be that?
17:01:41 <weitzman> Usually script kiddie refers to hackers who don't write their own exploits because they don't actually know how
17:01:47 <dons> oh, just my (I'm sure prejudice) assumption about some members of the perl community. Maybe I'm totally wrong, in which case, I withdraw
17:01:59 <dons> s/community/irc channel/
17:02:00 <Cale> SamB: Initially, someone who primarily uses scripts written by others to break the security of computers.
17:06:26 <shapr> dons: Actually, #perl on EFNet is why I learned Python.
17:06:38 <Cale> hehe
17:06:39 <dons> ah, I don't think its a conspiracy against lambdabot. looks like tinyurl simplified their api
17:06:43 <dons> so our regexes aren't needed
17:06:44 <dons> shapr: heh
17:07:01 <chessguy> #haskell has to be one of the best communities aroun
17:07:24 <shapr> Admittedly, that was many years ago, but I tried for several days to get answers from EFnet#perl ... when they permbanned me for asking for an editor with syntax highlighting, I couldn't continue asking questions.
17:07:45 <chessguy> wow
17:08:14 <mauke> er, EFnet/#perl isn't a help channel
17:09:09 <Cale> mauke: what is it then?
17:09:39 <shapr> Dreadshoot: People who drive away newbies get driven away from #haskell
17:10:00 <dons> yeah, that's critical that we do that.
17:10:04 <int-e> hmm. 'Most of us here on #perl are here because we enjoy hanging out with other people who use Perl. Most of us enjoy helping others with Perl problems and with learning perl.'
17:10:31 <mauke> it's mostly a social channel for people who happen to like perl
17:11:01 <int-e> of course that document I quoted dates from 1999 ... (http://pound.perl.org/RTFM/pound.perl.guide.html)
17:11:01 <dons> so a #haskell-blah ?
17:11:03 <lambdabot> Title: EFNet IRC #perl: General Guidelines, http://tinyurl.com/hvij
17:11:45 <mauke> http://p3m.org/channels/efnet-perl.html
17:11:47 <lambdabot> Title: pound-perl.pm -- Channels / EFNet #Perl
17:12:28 <shapr> But that's exactly why #haskell-blah was created (and #unicycling too) whenever a non-Haskell subject starts to get too much traffic, time to move it elsewhere.
17:12:39 <dons> shapr: you'll be interested in http://www.cse.unsw.edu.au/~dons/data/poison.txt
17:12:40 <lambdabot> http://tinyurl.com/yf35jl
17:12:50 <shapr> (Note that #unicycling was created by me because I noticed that *I* talked about unicycling too much on #haskell!)
17:13:07 <shapr> dons: I read that, I like it.
17:13:09 <dons> some notes I took down on managing a community, and avoiding "poisonous" people (*cough* smerdyakov *cough*)
17:13:15 <dons> ah right. you're on the mentors list :)
17:13:17 <dons> i forget
17:13:29 <weitzman> @yow
17:13:30 <lambdabot> TAILFINS!! ... click ...
17:13:36 <shapr> dons: It makes explicit a lot of things that I've tried to do on #haskell, and it mentions some concrete practices I hadn't thought of.
17:13:43 <dons> yeah
17:13:52 <chessguy> lol, smerdy
17:13:59 <dons> I see it played out again and again. I.e. there are poison people on reddit, for example
17:14:02 <int-e> mauke: thanks
17:14:05 <shapr> chessguy: Were you here when that happened?
17:14:10 <dons> (though they're easy to spot since their karma is -N)
17:14:19 <weitzman> @karma
17:14:19 <lambdabot> You have a karma of -1
17:14:23 <dons> oh no!
17:14:27 <dons> weitzman++
17:14:28 <dons> weitzman++
17:14:32 <weitzman> Thanks :)
17:14:34 * shapr grins
17:14:52 <chessguy> oh, i forgot about karma
17:15:02 <chessguy> xerox++
17:15:07 <shapr> I see signs of poison on LtU the last few months. That's part of why I don't hang out there anymore.
17:15:14 <chessguy> @xerox++
17:15:16 <lambdabot> Unknown command, try @list
17:15:19 <chessguy> bah
17:15:39 <chessguy> shapr, i don't recall a specific incident with smerdy in here. he's just an...interesting guy
17:15:46 <dons> either: nick++ or @karma+ nick
17:15:53 <shapr> There are a few people who want to discredit Haskell and other languages and then complain that the responses to their posts are hard to understand.
17:16:02 <shapr> chessguy: I banned Smerdyakov from #haskell
17:16:11 <chessguy> @karma weitzman
17:16:11 <lambdabot> weitzman has a karma of 1
17:16:22 <chessguy> oh ok, it just doesn't echo anything on success
17:16:23 <weitzman> @karam java
17:16:24 <lambdabot> Maybe you meant: karma karma+ karma-
17:16:29 <weitzman> @karma java
17:16:30 <lambdabot> java has a karma of -15
17:16:30 <shapr> chessguy: Twice...
17:16:54 <chessguy> @karma @xerox
17:16:54 <lambdabot>  @xerox has a karma of 0
17:17:01 <chessguy> @karma xerox
17:17:01 <lambdabot> xerox has a karma of 23
17:17:07 <int-e> lambdabot++
17:17:33 <chessguy> it ought to say something like "blah's karma raised to xx"
17:17:43 <int-e> it used to
17:17:54 <dons> oh, someone sneaked a patch in to tiny url without me oticing?
17:17:55 <shapr> Smerdyakov has two major problems from a community standpoint, 1. he drives off newbies 2. he wants everyone else to talk about only what he wants to talk about.
17:18:01 <dons>                  | length url > 45 -> do
17:18:02 <dons>                      title <- lift $ fetchTitle url
17:18:03 <dons>                      tiny  <- lift $ fetchTiny url
17:18:21 <weitzman> If trolls start to make a fuss, people in #haskell or LtU can just start discussing math, leaving the trolls with little to say
17:18:23 <dons> ?tiny-url http://www.google.com
17:18:24 <lambdabot> http://tinyurl.com/1c2
17:18:53 <dons> glguy: ^^
17:18:54 * kfish bookmarks
17:18:59 <glguy> dons: thanks :)
17:19:03 <chessguy> LtU?
17:19:12 <shapr> lambda-the-ultimate.org
17:19:18 <chessguy> aha
17:20:05 <int-e> does  darcs annotate  work for anyone?
17:20:24 <dons> ah, the original slides for the talk are here, http://www.red-bean.com/dav/presentations/Poisonous-people.pdf
17:20:26 <lambdabot> http://tinyurl.com/yf8gh7
17:20:30 <shapr> dons: I'm slightly miffed about the regular announcements of that non-Haskell but Haskell-like language on haskell-general. What's it called, gemcutter?
17:20:42 <dons> shapr: yeah, its a bit annoying
17:20:52 <dons> i expect it to die down. at least I hope so
17:20:53 <glguy> What about it?
17:21:16 <dons> glguy: the slides? "Protecting projects from poisonous people"
17:21:35 <glguy> but what is this gemcutter
17:21:44 <glguy> + the announcements on LtU
17:21:57 <edwardk> heya shapr
17:22:00 <shapr> y0 edwardk
17:22:07 <edwardk> ran into adam on #coq i see =)
17:22:25 <shapr> edwardk: I remember we discussed the benefits of combining post & pre with linear and uniqueness types, but do you have an intro written up?
17:22:35 <glguy> I can't find anything about ``gemcutter'' when searching LtU
17:22:49 <shapr> glguy: http://lambda-the-ultimate.org/node/1746
17:22:50 <lambdabot> Title: Business Objects Quark - Haskell meets Java | Lambda the Ultimate
17:22:56 <shapr> I think that's the one.
17:22:58 <edwardk> shapr: not yet, going to publish something fairly soon though.
17:23:09 <shapr> edwardk: Ok, I'd like to read more about it.
17:23:22 <edwardk> look up dana harrington's ph.d thesis.
17:23:29 <edwardk> that will get you started
17:23:31 <shapr> ok
17:23:35 <edwardk> and i can happily fill you in on any details
17:23:57 <shapr> glguy: See, that link goes to businessobjects.com "Since 1999, the Research Group at Business Objects has been working on"[...]
17:24:13 <shapr> glguy: So it feels to me like this guy is trying to get free business advertising. But maybe I'm overreacting.
17:24:14 <glguy> I'm reading through the comments now
17:26:51 <greenrd> Does anyone have experience with implicit parameters? I'm wondering why the inferred type of (flip mycombinator) contains two implicit parameter constraints
17:27:12 <greenrd> when mycombinator only has one such constraint
17:28:18 <glguy> While I don't see this guy's package going anywhere
17:28:34 <glguy> it is cool that everyone is trying to compare their stuff to Haskell
17:30:24 <emu> um, suppose i had a function of this signature: plus :: (Real a, RealFloat b) => a -> b -> a
17:30:35 <emu> how would I implement that addition operation
17:30:45 <greenrd> I think the basic idea of embedding a Haskell-like environment in the JVM, making it easily to integrate with Java code, and dumbing down the standard library a bit, is a good idea
17:31:10 <glguy> let people try the clone, and then find out they really like the real thing
17:31:25 <greenrd> I haven't looked at how good their implementation is in terms of performance, or library features
17:31:32 <dons> so they didn't really manage their release very well, in terms of gaining the support of the haskell community, did they
17:32:02 <glguy> anything that encourages people to adopt functional programming style
17:32:09 <greenrd> yeah
17:32:45 <emu> @djinn (Real a, RealFloat b) => a -> b -> b
17:32:46 <lambdabot> Cannot parse command
17:33:13 <greenrd> plenty of coders are under orders to target the JVM, but they could probably slip in some CAL code (once it's licensed for commercial use) much more easily than they could get a management mandate to switch to Haskell entirely
17:33:19 <dons> it seems that given 5 years they could have implemented a JVM backend to GHc, and added their own libs...
17:33:29 <greenrd> (CAL/Gemcutter/Quark/whatever it's called this week)
17:33:36 <emu> djinn not support typeclasses?
17:33:40 <dons> emu: nope.
17:33:51 <weitzman> djinn doesn't even support lists
17:34:08 <mauke> @djinn [a] -> [a]
17:34:08 <lambdabot> f a = a
17:34:14 <weitzman> That's odd
17:34:17 <weitzman> I guess I"m wrong
17:34:33 <emu> @djinn [a] -> b -> [b]
17:34:34 <greenrd> @djinn [a] -> a
17:34:34 <lambdabot> -- f cannot be realized.
17:34:34 <lambdabot> -- f cannot be realized.
17:34:41 <dons> it does suppppport lists in a form
17:34:43 <glguy> What is the specific goal of djinn?
17:34:45 <emu> @djinn [a] -> (a -> b) -> [b]
17:34:45 <lambdabot> -- f cannot be realized.
17:34:51 <greenrd> @djinn a -> [a]
17:34:51 <lambdabot> -- f cannot be realized.
17:34:53 <glguy> just to find some function that satisfies that type signature?
17:35:10 <emu> anyhow, erm, how do I do arithmetic across type class boundaries?
17:35:14 <mauke> @. pl . djinn . type tail
17:35:14 <lambdabot> compose module failed: IRCRaised Parse error: "tail"
17:35:23 <mauke> @. pl . djinn type tail
17:35:24 <lambdabot> f = id
17:35:40 <glguy> emu: heres an example:
17:35:48 <glguy> ?type \a b -> a / fromIntegral b
17:35:50 <lambdabot> forall b a. (Fractional b, Integral a) => b -> a -> b
17:36:10 <mauke> @. pl . djinn type flip id
17:36:11 <lambdabot> f = flip id
17:36:34 <emu> ?type \a b -> a + (fromRational b)
17:36:35 <lambdabot> forall a. (Fractional a) => a -> Rational -> a
17:36:58 <dons> glguy: right.
17:37:08 <dons> ?djinn a -> b -> (b,a)
17:37:08 <lambdabot> f a b = (b, a)
17:37:11 <glguy> dons: ok, but what's the why?
17:37:13 <dons> ?. pl djinn a -> b -> (b,a)
17:37:13 <lambdabot> f = flip (,)
17:37:14 <glguy> dons: why is that interesting
17:37:20 <dons> why isn't it?
17:37:33 <glguy> dons: pretend it isn't obvious
17:37:42 <nomeata> @djinn (a -> [b]) -> [a] -> [b]
17:37:43 <lambdabot> -- f cannot be realized.
17:37:51 <mauke> @. pl . djinn type (:)
17:37:52 <lambdabot> f = const id
17:38:16 <ihope_> @. pl . djinn type maybe
17:38:16 <dons> its a theorem prover for generating code. how is that not interesting? based on Curry-Howard and Gentzen's LJ sequent calculus
17:38:17 <lambdabot> (line 3, column 13):
17:38:17 <lambdabot> unexpected ">" or "-"
17:38:17 <lambdabot> expecting variable, "(", operator or end of input
17:38:25 <ihope_> Orph.
17:38:28 <dons> ?type maybe
17:38:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:38:32 <ihope_> Or maybe "orf".
17:38:35 <emu> ah found the function i wanted: realToFrac
17:38:36 <dons> ?djinn  b -> (a -> b) -> Maybe a -> b
17:38:37 <lambdabot> f a b c =
17:38:37 <lambdabot>   case c of
17:38:37 <lambdabot>   Nothing -> a
17:38:37 <lambdabot>   Just d -> b d
17:38:49 <emu> @type \a b -> (realToFrac a) + b
17:38:51 <lambdabot> forall b a. (Fractional b, Real a) => a -> b -> b
17:38:51 <ihope_> Methinks pl doesn't like that.
17:38:58 <nomeata> @help djinn
17:38:58 <lambdabot> djinn <type>.
17:38:58 <lambdabot> Generates Haskell code from a type.
17:38:58 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:39:17 <nomeata> @djinn a
17:39:18 <lambdabot> -- f cannot be realized.
17:40:00 <weitzman> @djinn (a -> a) -> a
17:40:00 <lambdabot> -- f cannot be realized.
17:40:35 <nomeata> djinn str = repeat (count outmost -> in str) "const" ++ undefined
17:41:08 <ihope_> nomeata: I... don't think that's valid Haskell.
17:41:28 <nomeata> ihope_: not yet. maybe haskell^{(3)} can do that :-)
17:41:52 <mauke> what's that supposed to do?
17:42:07 <nomeata> mauke: takes a type and returns a function definition of that type
17:42:15 <nomeata> mauke: well, of a type that fits the given type
17:42:27 <Bobstopper> @karma
17:42:27 <lambdabot> You have a karma of 2
17:42:37 <ihope_> @karma
17:42:37 <lambdabot> You have a karma of 0
17:42:45 <ihope> @karma
17:42:45 <lambdabot> You have a karma of 2
17:42:49 <nomeata> mauke: by swallowing all arguments using "const" and returning something of the type "a", e.g. undefined
17:42:52 <ihope> Wow, two karma points just for doing that!
17:42:54 <nomeata> but I am not serious
17:43:04 <glguy> dons: when you type Alt-P in dwm, can you then enter "xterm -someflag" ?
17:43:09 <nomeata> and anyways, I'm off to bed. good night!
17:43:10 <mauke> nomeata: why not just return undefined?
17:43:16 <dons> glguy: if you want
17:43:28 <nomeata> mauke: to make people wonder what the function does :-)
17:43:30 <dons> ah, maybe not...
17:43:56 <dons> shapr: i've put up some resources, http://haskell.org/haskellwiki/Protect_the_community
17:43:58 <lambdabot> Title: Protect the community - HaskellWiki, http://tinyurl.com/ycap2e
17:44:26 <ihope> Ah. djinn str = replicate (parseEnglish "Count the number of \"->\" not inside parentheses" str) "const " ++ "undefined"
17:44:38 <ihope> @type replicate
17:44:39 <lambdabot> forall a. Int -> a -> [a]
17:44:49 <ihope> Yeah, it'll work, then.
17:44:54 <nomeata> ihope: put this in the function "addSpacesWhereNeeded"
17:45:03 <ihope> Now who wants to implement parseEnglish?
17:45:11 <nomeata> parseEnglish is cool, should be in prelude
17:45:14 <ihope> nomeata: that's why it's "const " and not "const" :-)
17:45:31 <ihope> Really, dwim is a better function.
17:45:37 <nomeata> oh, looks like my visual parser missed that
17:45:41 <ihope> dwim :: forall a. Dwim a => IO a, of course.
17:45:42 <nomeata> too lazy, the eyes.
17:45:55 <nomeata> therefore: good night
17:46:05 <dons> and for reddit fans, http://programming.reddit.com/info/n72s/comments
17:46:08 <lambdabot> Title: How to Protect Your Open Source Project from Poisonous People [pdf] (reddit.com), http://tinyurl.com/vveh3
17:46:18 <ihope> Poisonous people?
17:46:56 <dons> my little plan is that if we can arm people with the knowledge for how to recognise and manager poisonous people, then maybe we can all live happier lives :)
17:47:12 <dons> ihope: check the slides, or the summary I wrote.
17:47:14 * ihope whips up a bottle of stuff containing poison vaccines, and another containing the associated poisons
17:47:45 <shapr> dons: spiffy
17:51:01 <emu> @pl foldr (const (+1)) 0
17:51:01 <lambdabot> foldr (const (1 +)) 0
17:53:36 <emu> @pl \a b -> (foldr c b $ d a)
17:53:37 <lambdabot> flip (foldr c) . d
17:54:10 <ihope> If there're two things I hate, they're subtlety and irony.
17:54:31 <ihope> Ambiguity comes in at a close third.
17:56:58 <dons> ihope: heh. what's that in reference to?
17:57:09 <ihope> Reference?
17:57:39 <ihope> Just something I thought up and found somewhat funny.
17:57:53 <ihope> Funny as in "ouch, bad joke".
17:59:17 <weitzman> Ambiguity can be used for good or for evil
17:59:45 <ihope> It's Better! <- evil
18:00:02 <weitzman> It can be just the trick you need to violate the spirit of some instructions without technically breaking them
18:08:14 <SamB> oh great
18:08:24 <SamB> my GHC working dir is acting wierd again...
18:08:31 <SamB> won't let me --reorder it...
18:09:07 <Igloo> Is it complaining about it being partial?
18:09:11 <SamB> yeah
18:09:23 <SamB> it doesn't usually do that
18:09:30 <Igloo> If you can reproduce this wierdness in a small repo, report it
18:09:47 <SamB> :-(
18:09:51 <SamB> the chances of that are slim
18:10:18 <SamB> however, I shall endeavor to do so
18:10:21 <Igloo> *nod*, my guesses as to what was going on weren't right, so I failed
18:10:49 <Igloo> It seems partial repos are an area in which darcs needs some work
18:12:08 * SamB gets previous GHC tag
18:12:44 <SamB> arg
18:12:48 <SamB> I forgot --partial
18:13:09 * SamB does it again
18:13:18 <SamB> it should be a little faster this time ;-)
18:13:40 <SamB> is there an existing issue for this?
18:13:50 <SamB> or should I make a new one?
18:13:50 <Igloo> Not sure
18:22:11 <SamB> hmm
18:22:36 <SamB> it grabbed the wrong damn checkpoint!
18:23:38 <Igloo> Which did it grab?
18:24:02 <SamB> 2006-10-22
18:24:51 <emu> @pl \a b -> (foldr c b $ ((d a) ++ (e a)))
18:24:51 <lambdabot> flip (foldr c) . liftM2 (++) d e
18:25:48 * SamB tries rearranging args
18:28:29 <emu> is there a more sensible way to repeatedly invoke a function on the result of invoking itself on a previous result than: foldr (const f) init [1..n]
18:29:16 <dons> that looks fairly sensible?
18:29:25 <dons> though perhaps use replicate
18:29:44 <emu> i couldnt think of a way to do it with replicate
18:30:14 <SamB> doesn't help!
18:30:25 <SamB> Igloo: what is the next-to-last checkpoint in the GHC repo?
18:31:30 <int-e> emu: iterate f init !! n
18:33:06 <emu> ah cool
18:34:46 <SamB> oh great!
18:34:57 <SamB> the darcs issue tracker is broken too!
18:42:14 <edwardk> hrmm. is there a good haskell parser using parsec around i can poke at to see how they handle layout?
18:42:34 * SamB doubts it
18:42:47 <SamB> I think Haskell is a bit complicated for Parsec parsers ;-)
18:42:54 <edwardk> don't tell me that please =)
18:43:07 <edwardk> not planning on doing haskell in it
18:43:15 <edwardk> just need to get something like layout to work
18:44:03 <edwardk> though yeah i was kind of afraid of that
18:44:22 <SamB> something *like* layout shouldn't be too hard
18:44:34 <SamB> layout itself is more complicated than it might seem, though ;-)
18:44:38 <edwardk> yeah i know
18:44:53 <edwardk> i happen to have the same set of rules as haskell layout to play with in my current toy language
18:44:58 <SamB> oh
18:44:59 <edwardk> and i'm adding the parser bits to handle that
18:45:29 <edwardk> coz i'm fond of the legibility it lends code
18:45:30 <SamB> to be honest I don't even know how *happy/alex* parsers do it...
18:45:51 <dons> grab the dragon book and read up !
18:45:54 <edwardk> happy/alex is even worse coz they have trouble parsing special cases like that
18:45:57 <SamB> dragon book?
18:46:15 <edwardk> dons: read the dragon book years ago, its not much help in this case, layout isn't context-free ;)
18:46:16 <SamB> happy/alex might do surprisingly well, due to happy accident!
18:46:24 <dons> Language.Haskell is a parsec parser, isn't it.at least HSX is.
18:46:33 <SamB> it is!
18:46:34 <SamB> ?
18:46:36 <SamB> !
18:46:37 <SamB> ???
18:46:41 <SamB> ??????
18:46:43 <edwardk> i used to have to jump through terrible hoops to parse a python style indentation control structure
18:46:44 <dons> don't be noisy.
18:46:46 <edwardk> a neat
18:46:48 <SamB> sorry
18:46:53 <edwardk> thats what i was hoping for
18:47:17 <dons> ah, its happy + hand wirtten lexer
18:47:36 <edwardk> shucks
18:47:39 * SamB is pretty sure you can do that with Alex, then, too!
18:48:10 <SamB> worst case, you have to wrap the lexer, I hope...
18:51:28 <edwardk> what is Language.Haskell.Parser missing?
18:51:48 <dons> some of the extensions
18:52:02 <edwardk> has do notation?
18:52:24 <edwardk> if it has that and hierarchical namespaces i can mangle it into my desired form ;)
18:52:40 <dons> sure. its h98
18:52:48 <edwardk> kk
18:52:50 <dons> and hier names work too, I think
18:53:46 <mbishop> How close is Haskell to SML?
18:53:58 <edwardk> ah neat http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
18:54:01 <lambdabot> Title: Haskell-Source with eXtensions, http://tinyurl.com/qoqzt
18:54:58 <edwardk> mbishop: well, aside from having weaker modules, stronger types, lazy evaluation semantics, and a cleaner syntax, hrmm. well, they have the same mindset in some senses but they are very different
18:55:12 <emu> if you replaced SML's type system with a more flexible one, and changed the evaluation semantics from strict to lazy, you would have something close to haskell
18:55:47 <dons> yeah, it'd be called Lazy ML .... and lennart would be the author.
18:55:58 <audreyt> but haskell is Not Not ML...
18:56:00 <shapr> Of course, SML has Smerdyakov...
18:56:32 <edwardk> audreyt: heheh
18:57:18 <edwardk> dons: going to try to use Language.Haskell.Hsx instead i think
18:57:38 <edwardk> shapr doesn't hold grudges, nope, not at all ;)
18:57:44 <audreyt> shapr: thanks for seeding my brain with parallelism-are-good thoughts from a year back, btw. Pugs's freshly hacked in SMP parallelism support is making me very happy :)
18:57:51 <shapr> I don't understand this error: Couldn't match expected type `ByteString' against inferred type `ByteString'
18:57:53 <audreyt> (and works very well with the existing STM support)
18:57:55 <emu> i just completed a bellman-ford implementation for didactic purposes, using Data.Graph.Inductive.  if i paste it, would anyone like to provide style comments or such?
18:57:57 <shapr> audreyt: yay!
18:57:59 <emu> er, lisppaste it!
18:58:02 <dcoutts> shapr, lazy vs strict
18:58:06 <shapr> dcoutts: oh!
18:58:11 <shapr> of course
18:58:20 <mbishop> edwardk: Well, I suppose I just need to learn more haskell, but I found it's syntax to be slightly...weird
18:58:39 <dcoutts> shapr, one is Data.ByteString.ByteString, the other is Data.ByteString.Lazy.ByteString, ghc should give them qualified in that case I'd say.
18:58:55 <dcoutts> shapr, file a bug report on error message quality.
18:58:55 <edwardk> mbishop: it grows on you. not nearly as many funny keywords and apostrophes floating around
18:59:12 <shapr> dcoutts: thanks
18:59:35 <mbishop> edwardk: Yeah, I'll start reading some tutorials :)
18:59:36 <lisppaste2> emu pasted "bellman ford" at http://paste.lisp.org/display/28460
19:00:05 <dcoutts> shapr, it's a common pattern now to have the same type names and use modules to distinguish, so it'll be a good error message to improve. Some people use the approach of calling every type 'MyThing.T'
19:00:18 <dcoutts> shapr, so they'd really have trouble with error messages :-)
19:00:41 <edwardk> mbishop: i'm a fairly recent haskell convert myself
19:01:22 <shapr> dcoutts: That fixed it, yay!
19:01:22 <edwardk> dcoutts: ouch, the error messages there must be horrendous.
19:01:55 <dcoutts> edwardk, yeah, I think it's silly, and not just for that reason.
19:02:36 <mbishop> edwardk: I wouldn't say I'm a convert, I like my lisp, but haskell seems nice :)
19:03:01 <dons> well haskell is a child of lisp
19:03:13 <SamB> heh
19:03:13 <dons> its lisp with more language features and improvements
19:03:21 <shapr> I like having modules use a lot of the same names. insert shouldn't be a different function for each type. Also, I like import qualified because it makes it easy to find stuff.
19:03:29 <dons> SamB: no, literally. see the h98 report. "We are indebted to lisp"
19:03:48 <SamB> which section is that in?
19:03:55 <edwardk> mbishop: i can't really bring myself to use scheme any more, i miss the types too much. there is really something to be said for the fact that in haskell if it type checks, its probably correct.
19:04:09 <dons> Lisp is like the grandfather, and ML is the father.
19:04:11 <audreyt> well then it goes on to mention APL
19:04:17 <dons> :)
19:04:45 <dons> and Miranda is the evil twin
19:05:00 <scodil> so, if haskellers aren't into records (hence no good implementations) what is the alternative? especially for lots mutable state in complex programs? I mean, I can think of other was to do it, but what are the best/common ways?
19:05:12 <scodil> ways -> ways
19:05:14 <dons> use the existing records system.
19:05:18 <scodil> er, was. whatever.
19:05:22 <scodil> but its sooo bad
19:05:30 <scodil> the namespace thing
19:05:31 <dons> what kind of probelms are you encountering?
19:05:32 <edwardk> scodil: i tend to use a StateT wrapped IO monad
19:05:32 <Captain_Fourier> a <- b
19:05:45 <dons> the field labels with global scope, scodil ?
19:05:48 <scodil> yeah
19:05:52 <dons> yeah, that's annoying.
19:06:05 <dons> not life threatening though. namespaces can be managed
19:06:28 <shapr> Random silly question, how do I import the Main module mentioned in the GHC docs?
19:06:29 <dons> not really sure what this has to do with mutable state though ...
19:06:38 <ACSpike> what's the default/most popular gui library to use with haskell?
19:06:43 <Captain_Fourier> are there any good guides on using gtk2hs
19:06:48 <shapr> ACSpike: Either gtk2hs or wxHaskell
19:06:50 <dons> you should not have _lots_ of mutable state, some, in a monad, with records, is the usual case.
19:06:53 <scodil> i end up resorting to old c namespace tricks, like putting an abbreviation of the name of the type infrom of every field
19:06:59 <shapr> Some people just use the HOpenGL bindings.
19:06:59 <scodil> infront
19:07:06 <shapr> Since GLUT has some minimal windowy stuff.
19:07:26 <dons> scodil: or wrap the state components into substructures, so they become hierarchical
19:08:21 <shapr> Captain_Fourier: There are nifty tutorials on the gtk2hs blog
19:08:21 <scodil> dons: then you have an STRef at every level of that heirarchy... right?
19:08:34 <dons> depends on your type. can you post the code?
19:08:35 <dons> ?paste
19:08:35 <lambdabot> http://paste.lisp.org/new/haskell
19:08:52 <dons> just type decl
19:08:59 <scodil> dons: me? no i haven't written anything yet
19:09:03 <shapr> I'm tempted to hack up the lambdabot code to take commands with the question mark at the end!
19:09:08 <scodil> at least, i'm not working on anything at the moment
19:09:10 <scodil> but in the past...
19:09:12 <dons> ah, well. when you have some problems, then ask :)
19:09:32 <scodil> no see thats the thing. i can make it work. its just that it seems a bit clumsy
19:09:34 <shapr> scodil: No state required: length [] = 0 ; length (x:xs) = 1 + length xs
19:09:38 <dons> I've never found the records system to be a problem, e.g.
19:09:40 <dons> data Editor = Editor {
19:09:41 <dons>         buffers         :: !(M.Map Unique FBuffer)    -- ^ all the buffers
19:09:41 <dons>        ,windows         :: !(M.Map Unique Window)     -- ^ all the windows
19:09:41 <dons>        ,curwin          :: !(Maybe Unique)            -- ^ the window with focus
19:09:41 <int-e> shapr: why?
19:09:44 <dons>        ,curkeymap       :: [Char] -> [Action]
19:09:47 <dons> ...
19:09:49 <dons> }
19:09:52 <dons> works fine.
19:10:10 <shapr> int-e: then lambdabot would answer your questions, like monads?
19:10:15 <shapr> monads?
19:10:15 <dons> if you hack something up and it seems clumsy, ask here. should generally be solvable
19:10:21 <scodil> you can export the record type without exporting the field functions, right?
19:10:25 <shapr> Would probably do @whereis all about monads
19:10:27 <dons> scodil: yes.
19:10:56 <int-e> shapr: ah, so you're not talking about, say,  elite? foobar
19:11:44 <shapr> Nah, I was just thinking of turning lambdabot into a conversational interface somehow.
19:14:15 <scodil> ok, so the question i was getting at was along the lines of: the relative clumsiness of the haskell type system makes me think that people just aren't using it very much. so what do they use instead? or are people just not using haskell to write the type of programs that rely on good record systems?
19:14:29 <dcoutts> Captain_Fourier, there's an intro presentation, there's a intro thing that develops a memory game. There's a bunch of demos you can read.
19:14:33 <shapr> scodil: What seems clumsy to you?
19:14:40 <Captain_Fourier> ok
19:14:54 <Captain_Fourier> @whereis all about monads
19:14:54 <lambdabot> Maybe you meant: where where+
19:14:55 <scodil> i asked the other night why all these neat record propsals haven't been implemented, and the cosensus was "no one cares enough to do it" like nobody has any need for it
19:15:22 <shapr> Once every coupla months I wish the record system were better, but I code Haskell for hours every day.
19:15:25 <dcoutts> scodil, I don't think it's that no one cares, it's a hard problem.
19:15:33 <dcoutts> there's so many ways of doing it
19:15:41 <dcoutts> so getting concensus is hard
19:15:53 <shapr> And in a lot of cases, an ADT is a better thought tool.
19:16:06 <shapr> At least, that's been my experience.
19:16:13 <scodil> shapr: well, the only thing that jumps to mind is the namespace thing. but every new proposal for a record system i read starts with "the record system in haskell really sucks..."
19:16:15 <scodil> more or less
19:16:40 <shapr> Well, a lot of things about Haskell 'suck' but all together Haskell sucks less than other languages so far...
19:17:08 <dcoutts> I do use records in some of the 'real' progs I write, ie ones that deal with messiness
19:17:13 <dcoutts> and they could be better
19:17:20 <shapr> I know what you mean, the record system could be better. But it rarely gets in the way of my code.
19:17:43 <shapr> scodil: Can you show some specific examples? Maybe I/we can help you see how to do them in another way?
19:18:13 <dcoutts> shapr, joining record types like in a DB :-)
19:18:16 <shapr> I do hope that Epigram gets a production quality implementation, I'd like to try writing commercial software with Epigram.
19:18:33 * shapr points to bringert's trick in HaskellDB and runs away!
19:18:37 <shapr> er "tricks"
19:18:44 <dcoutts> shapr, aye, HList. Bleuch.
19:18:52 <shapr> yeah
19:19:10 <scodil> sorry, i don't have any examples. i was just curious if there was some particular style of programing, some trickery using functions and algebraic data types, that obviates the need for records. you know, like how tail recursion obviates forloops
19:19:40 <shapr> ADTs?
19:20:49 <dons> scodil: yeah, I think its more that it only 'sucks' in comparison to other haskell features
19:21:06 <dons> i.e. i code in haskell 5 hours or more a day, 365 days a year, but records only bug me maybe once every 6 months.
19:21:07 <scodil> shapr: not quite sure... i was thinking less along the lines of abstraction, more like data organization
19:21:08 <shapr> scodil: Do you use algebraic datatypes in other languages?
19:21:16 <dons> so that's pretty bad for a haskell language feature ;)
19:21:19 <shapr> heh
19:21:30 <scodil> maybe i misuse the term algegraic data types
19:21:33 <shapr> Of course, the last time a language feature bothered dons, he created ByteString...
19:21:43 <int-e> shapr: does struct { int tag; union { ... } data; } count?
19:21:45 <dons> instead of transporting me into delirious CS delight, like most other haskell things do
19:21:55 <scodil> i mean data MyType = MyType Int Double SomeOtherType ...
19:22:37 <scodil> i only took one advanced pl class, and thats the meaning of algebraic data type that I took away
19:22:58 <shapr> scodil: Yeah, that's an ADT. In a lot of cases you can use an ADT instead of a record. Once again, just my experience.
19:23:02 <scodil> oh oh oh
19:23:08 <scodil> ADT as in algebraic
19:23:11 <scodil> thought you mean abstract
19:23:20 <scodil> meant
19:23:25 <scodil> ok i get what you were saying now
19:23:38 <shapr> I like the way ADTs enforce the structure of the data, like the data Tree a = Nil | Branch (Tree a) a (Tree a)
19:23:59 <scodil> the only thing that bugs me about using adts to replace records is that order becomes so important
19:24:18 <shapr> Show me?
19:24:34 <Captain_Fourier> hmm i guess what I want more is its api
19:24:34 <int-e> Haskell doesn't support using records as separate namespaces of field names ... that's tough, but hard to fix.
19:24:51 <scodil> f (MyADT x y z w this that theOther) = ...
19:25:14 <shapr> Oh, I see what you mean.
19:25:34 <scodil> i guess the solution is to wrap up the sub-parts, like collect x y z and w into some type
19:25:55 <scodil> its probably a good motivator for properly absracting things
19:26:27 <scodil> it just get so cumbersome when you actually sit down to write, say a graphical interface
19:27:07 <scodil> i don't do alot of batch-mode programing. its mostly interactive stuff. so state is important.
19:28:29 <shapr> Have you tried wxHaskell and gtk2hs?
19:28:33 <shapr> Not that I've used them any :-)
19:29:36 <shapr> Oh wow, have you guys seen sigfpe's monad sketches?
19:31:05 <dons> scodil: state is simple and easy in haskell: use a state monad. no worries, no fuss
19:31:05 <scodil> wxHaskell gtk2hs are nice interfaces, but I think the reason they can be so nice is because they push all the statefulness out to C-land, and just do everything in IO. trying to write something like that in pure haskell seems like it would be a pain.
19:31:43 <Cale> In IO, you can have as much statefulness as you want
19:31:45 <shapr> Not necessarily, have you seen Antony Courtney's thesis?
19:31:51 <int-e> scodil: do you know the existing record syntax? data Foo = Foo { field_1 :: Int } etc?
19:32:15 <scodil> dons: yeah I know, but lets say you have a large graph (or widgets or something) and you're constantly changing and updating nodes in this graph. would you not then have to have every edge of this graph be wrapped in an STRef?
19:32:30 <dcoutts> scodil, well that's partly true. What the remaining problem is that GUI code written in Haskell is more stateful than we'd like.
19:32:33 <shapr> scodil: not at all
19:32:58 <dons> scodil: no, you'd just twiddle points, not actually mutate locations in memory. i.e. like a Data.Map, surely?
19:33:09 <dons> you've read 'Purely Functional Data Structures' ?
19:33:22 <dons> s/twiddle pointers/
19:33:28 <dcoutts> scodil, there are various approaches to managing/hiding the state in GUI progs.
19:33:52 <dons> anyway, you should just dive in and have a hack, scodil. you're concerns will most like disappear with a bit of experience
19:33:52 <scodil> Purley Function Data Strctures.. thats by.. I forget his name. Japanse. I think i read it
19:34:00 <scodil> Japanese, even
19:34:08 <dcoutts> yep, him.
19:34:23 <int-e> Okasaki
19:34:26 <dcoutts> great book.
19:34:30 <dons> "Perly Function data Structures" is a different text.
19:34:37 <dons> not to be confused.
19:34:38 * shapr grins
19:34:39 <dcoutts> heh
19:35:01 <dons> where you encode all your data as flat arrays of scalars
19:35:09 <scodil> hah
19:35:20 * araujo back
19:40:40 <scodil> is there away to get hoogle to scan more libraries? like the stuff that comes with ghc, maybe?
19:45:51 <shapr> Any other last.fm users here? The Haskell group needs 15 members to start having charts generated... :-)
19:46:12 <scodil> i'll join...
19:50:43 <edwardk> dons: found that stealing the lexer from Language.Haskell.Hsx did the trick
19:52:08 <glguy> dons: I've got a new line for Mod-P if you want to see it
19:52:12 <glguy> it allows flags to work
19:52:26 <glguy> (uses the wmiisetsid too, which may or may not be what you like)
19:52:32 <glguy> and doesn't need the words program
19:52:44 <glguy> (heavily based on wmiirc)
19:52:46 <dons> glguy: ah ok?
19:53:03 <glguy> I'm not sure if it's better or not, but I couldn't find you when I needed the words program
19:53:03 <dons> glguy: words is in h4sh, I recommend you install it :)
19:53:10 <glguy> h4sh?
19:53:11 <dons> ?where h4sh
19:53:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/h4sh.html
19:53:20 <dons> Data.List functions for the shell
19:53:25 <glguy> { .cmd = "exe=\"$(ls -lL `echo \"$PATH\" | tr : ' '` 2>/dev/null | awk 'NF>2 && $1 ~ /^[
19:53:28 <glguy> ^d].*x/ {print $NF}' | sort -u | dmenu -font '"FONT"' -normbg '"NORMBGCOLOR"' -normfg '"NORM
19:53:31 <glguy> FGCOLOR"' -selbg '"SELBGCOLOR"' -selfg '"SELFGCOLOR"')\" && wmiisetsid $exe" } }, \
19:53:37 <glguy> You'll notice your influence in that :)
19:53:50 <dons> so wmiisetsid handles args or something?
19:54:04 <glguy> wmiisetsid calls setsid() first
19:54:41 <glguy> I think that the old version might work if you just remove the quotes from $exe at the end
19:55:16 <glguy> (which might be useful if yo ucall a lot of binaries with spaces in their names)
19:55:19 <Captain_Fourier> how do i settle ambiguities between libraries
19:55:37 <glguy> import qualified Data.Map (map)
19:55:43 <glguy> import Data.List hiding (map)
19:55:53 <glguy> (as examples)
19:56:21 <Captain_Fourier> is there anyway to alias one of those maps to another function
19:56:25 <Captain_Fourier> so i can use both
19:56:31 <Captain_Fourier> dataMap
19:56:45 <glguy> the qualified line I typed would all for: Data.Map.map
19:56:50 <ACSpike> where's a guy supposed to get gtk2hs from?
19:56:52 <SamB> import qualified Data.Map as M
19:56:53 <glguy> also, import qualified Data.Map as M
19:57:00 <glguy> allows M.map
19:57:20 <dons> fun, http://photos1.blogger.com/blogger/3557/910/1600/annotated_monads.1.jpg
19:57:23 <lambdabot> http://tinyurl.com/y8yjpa
19:57:29 <SamB> > M.map (*3) (M.fromList [("hi!", 1), ("bye!", 2)])
19:57:30 <lambdabot>  {"bye!":=6,"hi!":=3}
19:57:33 <dcoutts> @where gtk2hs
19:57:34 <lambdabot> http://haskell.org/gtk2hs/
19:57:35 <dcoutts> ACSpike, ^^
19:57:48 <Captain_Fourier> thanks glguy
19:57:57 <Captain_Fourier> can that be done from prelude?
19:58:31 <dons> hmm?
19:58:37 <glguy> Captain_Fourier: rephrase that?
19:58:46 <ACSpike> dcoutts: well I tried to get it from there. do I need to downgrade ghc from 6.4.2 to 6.4.1?
19:58:59 <dcoutts> ACSpike, you're using windows ?
19:59:06 <ACSpike> oops
19:59:10 <dons> shapr: i want to get those monad sketches on a tshirt
19:59:13 <glguy> dons: do you use the patch that allows you to make a window float on the fly?
19:59:26 <Captain_Fourier> from Prelude in ghci can I type the lines you have mentioned
19:59:33 <dons> hmm? can't you just do that with Alt-Space?
19:59:42 <dcoutts> ACSpike, if you're using windows with ghc-6.4.2 you can grab this build: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.exe
19:59:44 <lambdabot> http://tinyurl.com/y9cc2s
19:59:50 <glguy> dons: Alt-Space changes everythings mode
19:59:56 <dons> ah
20:00:06 <glguy> dons: that patch seems to allow alt shift space just change one application's mode
20:00:19 <shapr> dons: Yeah, me too.
20:00:27 <glguy> I understand dwm a bit better now, and have switched back from dwm
20:00:35 <dons> shapr: but it's missing IO...
20:00:37 <glguy> wmii*
20:00:44 <dons> I want the whole world being threaded in there
20:00:45 <glguy> from wmii*
20:01:41 <shapr> dons: Ask for it, and ask Fritz Ruehr for some t-shirts maybe?
20:02:34 <ACSpike> dcoutts: thanks. what version of gtk+ does this need?
20:02:55 <dcoutts> ACSpike, 2.8.x I think.
20:03:54 <ACSpike> argh, I've got that
20:04:25 <ACSpike> the installer is awfully picky
20:04:39 <scodil> i'm using haskell's glut bindings and I get this at runtime : glc: GraphicsziUIziGLUTziCallbacksziGlobal_d3lo: interrupted    I'm guessing haskell generated this, cause its got the package name in there.  It looks like haskell is just aborting instead of going through its normal cleanup routine (i have a `finally` that doesn't get called)  Is there some way I can prevent this? It happens when I ctrl-c. Do I have to setup a signal handle
20:04:39 <scodil> r?
20:05:12 <dons> sounds like glut doesn't like getting sighupped?
20:05:28 <scodil> is that what control c sends? I thought it sent sigint
20:05:31 <dons> which results in a foreign call being terminated in some abnormal way, whihc haskell then duly reports
20:05:35 <dons> sigint, yeah.
20:05:56 <dons> haskell's just telling you that some exception happend on the C/Glut side of the wall
20:06:06 <dons> so maybe there's a glut way of setting up a signal handler?
20:06:15 <dons> otherwise, you could catch it on the haskell side
20:06:19 <dons> ?hoogle Signal
20:06:20 <lambdabot> Control.Concurrent.QSem.signalQSem :: QSem -> IO ()
20:06:20 <lambdabot> Control.Concurrent.QSemN.signalQSemN :: QSemN -> Int -> IO ()
20:06:20 <lambdabot> System.Console.Readline.clearSignals :: IO ()
20:06:35 <dons> ?hoogle+
20:06:36 <lambdabot> System.Console.Readline.setSignals :: IO ()
20:06:54 <dons> (look in the unix package)
20:06:56 <scodil> i don't understand why glut is messing with me like this. its setting up signal handlers, messing with my terminal. why does it need to do this...
20:07:04 <dons> see if it happens from C alone.
20:07:12 <dons> no idea.
20:07:17 <scodil> well it just quits then doesn't it?
20:07:20 <dons> gluts a monster, I guess.
20:07:24 <scodil> hold on... lemme try
20:07:37 <ACSpike> dcoutts: you don't happen to have a zip version? or something without an installer?
20:08:07 <dcoutts> ACSpike, why? if the installer complains it's probably right.
20:08:28 <dcoutts> ACSpike, I might be able to find the .zip somewhere, but it should work.
20:08:39 <ACSpike> what is it checking?
20:09:22 <edwardk> does anyone here who was present at the haskell workshop remember who it was who was asking that infix(r|l)? be moved out of the module or to the area where imports are made in haskell'?
20:12:28 <edwardk> hrmm
20:13:11 <dcoutts> ACSpike, what's the error message?
20:13:37 <dcoutts> ACSpike, it checks that ghc and gtk are installed ok and that there arn't any stray dlls that'll mess things up
20:14:09 <scodil> dons: how do you set a signal handler, now? that stuff lambdabot was talkin'bout is a different kind of signal (as in, condition variables)
20:14:56 <edwardk> trying to think of a better symbol than $ for a built-in operator equivalent. maybe (!) ? that way it shares some characteristic with (.) ?
20:15:41 <ACSpike> dcoutts: says I've got an older version. I've got 2.8.16, but it might have been installed over the top of an older version, that's what makes me ask what it is checking for.
20:15:59 <dons> scodil: check the docs for signals in the unix package
20:16:24 <dcoutts> ACSpike, yep, it looks in the registry for the Gtk+ version
20:17:07 <ACSpike> guess I have to uninstall and reinstall :-(
20:17:32 <dcoutts> ACSpike, the other thing the installer does is register the packages, that's not trivial by hand
20:19:12 <ACSpike> register as in create keys? or regsvr32? or...?
20:34:52 <chessguy> ok, this error message doesn't make any sense
20:34:54 <chessguy> cross :: Integer -> Tree a -> Tree a -> (Tree a, Tree a, Tree a, Tree a)
20:34:56 <chessguy> cross seed parent parent' =
20:34:58 <chessguy>         let r1 = head $ myRandoms 1 treeSize(parent) seed; r2 = head $ tail $ myRandoms 1 treeSize(parent') seed in
20:35:01 <chessguy>         (parent, parent'
20:35:03 <chessguy> -}
20:35:05 <chessguy> oy
20:35:09 <chessguy> that's not the error
20:35:11 <chessguy>     Couldn't match `Int' against `Integer'
20:35:13 <chessguy>       Expected type: Int
20:35:15 <chessguy>       Inferred type: Integer
20:35:17 <chessguy>     In the expression: seed :: Int
20:35:19 <chessguy>     In the list element: seed :: Int
20:35:23 <chessguy> how is it inferring tye type Integer from the expression seed :: Int
20:35:57 <araujo> From the type signature?
20:37:57 <chessguy> grrr, why doesn't it see Int and Integer as compatible
20:38:40 <mwc> chessguy, Int is a finite integer, Integer is arbitrary precision
20:38:58 <chessguy> yes, but for most purpose, and certainly for mine, the types are compatible
20:39:22 <mwc> why doen't you make your function work on Integral a
20:39:49 <mwc> @type fromIntegral
20:39:50 <lambdabot> forall b a. (Num b, Integral a) => a -> b
20:39:54 <mwc> or you could use that
20:40:27 <araujo> > let f (a :: Int) = a in let g (a :: Integer) = a in f (g 5)
20:40:27 <lambdabot>  Parse error in pattern
20:41:13 <mwc> > (fromIntegral :: Integer -> Int) 240302020304010203
20:41:14 <chessguy> fromIntegral converts an integral instance to a num instance?
20:41:14 <lambdabot>  252148699
20:41:19 <mwc> yep
20:41:33 <mwc> and apparently it silently overflows as necessary
20:41:51 <ACSpike> newbie docs for gtk2hs are kinda scarce?
20:42:00 <mwc> > (fromIntegral :: Integer -> Int) 22
20:42:01 <lambdabot>  22
20:42:07 <mwc> ACSpike, tried the tutorials?
20:42:18 <dcoutts> ACSpike, they could be better.
20:42:22 <chessguy> apparently some parts of the code are requiring Ints and others are requiring Integers
20:42:25 <mwc> ACSpike, I think the intention is mostly that you use the C docs.
20:42:30 <ACSpike> mwc: so far I found one for memory
20:42:39 <dcoutts> mwc, no it's just that we've been lazy :-)
20:42:39 <chessguy> i'm having a hard time sorting out what's what
20:42:39 <mwc> ACSpike, that's the one I was thinking of
20:42:57 <dcoutts> ACSpike, there's that very general intro presentation too.
20:43:04 <ACSpike> I think falling back on C api docs is acceptable
20:43:04 <chessguy> myRandoms quant max seed =  map (`mod` max) (head $ map (take quant . randoms . mkStdGen) [seed::Integer])
20:43:30 <chessguy> > let myRandoms quant max seed =  map (`mod` max) (head $ map (take quant . randoms . mkStdGen) [seed::Integer]) in myRandoms 3 4 5
20:43:30 <dcoutts> ACSpike, for api docs we're fine, it's tutorials we lack.
20:43:30 <lambdabot>  Couldn't match `Int' against `Integer'
20:43:34 <mwc> chessguy, fwiw, my rule of thumb is to use Int when counting machine resources and Integrals when dealing with actual arithmetic numbres
20:44:01 <dcoutts> ACSpike, you've found the searchable Gtk2Hs Haskell api docs right?
20:44:07 <ACSpike> yup
20:44:11 <dcoutts> great
20:44:12 <chessguy> mwc, that's what i'm trying to do
20:44:36 <chessguy> the type signature here is myRandoms :: Int -> Integer -> Integer -> [Integer]
20:44:41 <mwc> dcoutts, maybe that's something I could usefully contribute. I was thinking of writing a monad tutorial because (IMAO) all the other ones suck.
20:44:54 <ACSpike> thanks for the help guys. I think I'll explore gtk2hs tomorrow.
20:45:02 <mwc> chessguy, my advice is then to use fromIntegral to widen Int to Integer, and avoid the reverse
20:45:09 <dcoutts> mwc, we started something here: http://haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
20:45:11 <araujo> Writing monads tutorials is a whole industry by itself
20:45:12 <lambdabot> Title: Gtk2Hs/Tutorials/Intro - HaskellWiki, http://tinyurl.com/y2ctrp
20:45:24 <dcoutts> mwc, feel free to start from that, or from anything else
20:45:26 <chessguy> byt i'm getting an error because it expects (`mod` max) to be Integer->Int not Integer->Integer
20:45:34 <chessguy> *but
20:45:47 <mwc> araujo, reading Monads as containers set back my monad enlightenment by at least 4 weeks.
20:45:55 <dcoutts> mwc, and a chap emailed the haskell and gtk2hs-users list the other day. He was starting one based on the Glade C tutorial.
20:45:57 * araujo wonders if/when dcoutts will release the new api soo
20:46:07 <dcoutts> araujo, you can use it now of course
20:46:15 <araujo> mwc, why? .. that explanation is so simple?
20:46:27 <dcoutts> containers vs. computations
20:46:27 <araujo> dcoutts, from darcs right?
20:46:32 <dcoutts> araujo, yep
20:46:39 <mwc> Apparently they need to write the Tree and List models or something
20:46:45 <dcoutts> they're two different intuitions
20:46:47 <chessguy> @type (mod)
20:46:48 <lambdabot> forall a. (Integral a) => a -> a -> a
20:46:52 <mwc> araujo, bingo. I think it's too simple, and kind of wrong
20:47:00 <dcoutts> mwc, they're partly done.
20:47:02 <araujo> mwc, why?
20:47:13 <dcoutts> mwc, to a mostly usable extent.
20:47:42 <mwc> I finally realized monads are a mechanism for adding extra steps and invariants to the the raw computation model of lambda calculus
20:47:56 <araujo> mwc, monads is such an abstract concept that allows many ways of explanation. The most important thing is that if you don't get it with one explanation, you will always can find other one :-)
20:48:17 <mwc> Yeah, but I kept trying to bash monads into a data model
20:48:50 <mwc> I finally realized that there are some startling similarities between how bind works and CPS
20:49:20 <mwc> And so elaborating the definition of bind is more or less inserting calculations into the CPS chain at every step.
20:50:18 <chessguy> heh. i figured it out. i took the type signature off completely and let GHCi figure out what it should be, then pasted that in :)
20:50:30 <araujo> I think monads can perfectly well be suited to a data model explanation.
20:50:40 <mwc> and that's where you put your machinery to augment what appears to be naked function applications.
20:50:51 <mwc> araujo, ContT. I dare you :P
20:51:01 <mwc> I'm sure they can
20:51:11 <araujo> For example, one way of explaining them is that they are data structures of computations.
20:52:09 <mwc> monads as data containers left me with a model that I had a hard time using to understand things.
20:52:45 <Cale> A value of type Cont r a is like a question-answering machine where one may ask questions where the responses are of type r about values of type a, though one can not necessarily observe the value of type a.
20:53:49 <mwc> someCalculationProducingAValue >>= continuationThatUsesThatValue. Viewing a monad as a special ruleset for function application made more sense to me
20:54:01 <mwc> Cale, yeah, I have a hard time bending my mind to that
20:54:10 <mwc> But I see how it works
20:55:02 <Cale> the obvious question-answering machines just wrap a value of type a and apply the question to it directly, returning the response
20:55:34 <Cale> but sneakier machines may pass the question off to another machine, possibly after transforming it in some way
20:55:37 <mwc> which is really a machine answering questions about the responce :)
20:57:19 <glguy> could someone display the unicode lambda for me? \u03bb (i believe)
20:57:38 <araujo> mwc, i don't see where that explanation doesn't fit into the container analogy. A function being the 'producer' generating a value belonging to a type, which is the 'container' and that will/can be used by other function, other 'producer'.
20:57:47 <dcoutts> glguy, not got a character map program?
20:57:57 <glguy> dcoutts: nothing that I know of
20:58:04 <glguy> dcoutts: i guess technically i have firefox
20:58:12 <araujo> But as i said. Mondas are such an abstract concept, that allows many related definitions varying depending perspective.
20:58:18 <araujo> erh, Monads
20:58:40 <araujo> The good thing is that you always can get the one you like best :-)
20:58:59 <Botty> hey, can constructors be curried ;)
20:59:09 <dcoutts> glguy, windows and gnome have one. 
20:59:21 <glguy> dcoutts: well, I don't have either of those on this laptop :)
20:59:23 <mwc> aye. I more or less reduced it to a form of lambda calculus where [f x] = (g f x) where [] denotes some weird lambda like calculus (mu?) and () is proper lambda. g is a function managing the application of f to x
20:59:37 <mwc> Botty, yep
20:59:39 <glguy> dcoutts: did you put one at the end of that line?
20:59:49 <dcoutts> glguy, yes  I did 
20:59:53 <Botty> mwc - oh, sweet, wasn't expecting that, even though it makes total sense
20:59:54 <glguy> bugger...
21:00:05 <dcoutts> glguy, use utf8
21:00:27 <glguy> dcoutts: i'm trying to :)
21:00:48 <glguy> I'm using uxterm and /set term_charset=UTF-8
21:01:17 <dcoutts> g'luck
21:01:20 <glguy> heh
21:01:22 <dcoutts> g'night folks
21:01:33 * dcoutts -> sleep
21:01:57 <Botty> put in a dcoutts, and you get sleep ?
21:02:51 <weitzman> @djinn dcoutts -> sleep
21:02:52 <lambdabot> -- f cannot be realized.
21:04:37 <emu> @pl \f i c -> foldr f (foldr f $ a c) $ b c
21:04:38 <lambdabot> const . (`ap` b) . liftM2 (.) foldr ((. a) . foldr)
21:05:08 <emu> @pl \f i c -> foldr f (foldr f i $ a c) $ b c
21:05:09 <lambdabot> flip flip b . (ap .) . ap ((.) . (.) . foldr) (flip flip a . ((.) .) . foldr)
21:05:32 <emu> @pl \f i c -> foldr f i $ (a c) ++ (b c)
21:05:32 <lambdabot> flip flip (liftM2 (++) a b) . ((.) .) . foldr
21:05:40 <mwc> how robust is the pl algorithm? Think it could convert GHC to a single points free expression? :D
21:06:22 <Cale> I doubt the simplifier would ever finish
21:06:25 <emu> sounds like an interesting IR
21:06:30 <emu> hehe
21:10:19 <lisppaste2> emu annotated #28460 with "improvement" at http://paste.lisp.org/display/28460#1
21:12:41 <glguy> could someone pleeease send me one last unicode character, i think i've got it
21:13:45 <LordBrain> 
21:13:55 <glguy> was that supposed to be an e + accent?
21:14:16 <LordBrain> yes
21:14:20 <glguy> cool
21:14:36 <glguy> now I just need to find a pretty font that also has a lot of unicode characters in it
21:14:57 <petekaz> @last Cale
21:14:57 <lambdabot> No module "Cale" loaded
21:15:02 <glguy> @seen Cale
21:15:02 <lambdabot> Cale is in #ghc and #haskell. I last heard Cale speak 8m 40s ago.
21:15:05 <Cale> hi
21:15:22 <LordBrain> speak of the Cale module himself
21:15:27 <Cale> I'm going to sleep soon, so hopefully you don't need me for too long :)
21:15:33 <petekaz> Cale: thanks for the help earlier.  I would never have come up with that solution by myself.
21:15:50 <Cale> cool, yeah, I'd spent a while thinking about that problem before
21:16:09 <Cale> in fact, I replied to the mailing list with that very solution quite a while back :)
21:16:18 <petekaz> the groupBy thing was great.  I wonder if I'll ever start to think like a functional programmer.
21:16:19 <Cale> there's some other stuff there you might care to look at too
21:17:19 <lisppaste2> petekaz pasted "converting indented text to a tree" at http://paste.lisp.org/display/28465
21:17:53 <petekaz> Cale: that is my final piece.  It took me a bit to get it right even with all your help.
21:17:55 <Cale> http://www.haskell.org/pipermail/haskell-cafe/2006-February/014471.html -- here's the start of that thread
21:17:59 <lambdabot> Title: [Haskell-cafe] List-to-outline, http://tinyurl.com/u976c
21:18:30 <petekaz> I'm actually using this code in a gtk2hs app.
21:19:24 <araujo> getLine >$| ls <| sort -r >>= return . lines
21:19:27 <araujo> :-)
21:19:47 * araujo thinks he is finally getting working as to start using Haskell for small scripting tasks
21:19:52 <Cale> g'night all :)
21:20:00 <Captain_Fourier> I am loving gtk2hs
21:20:34 <petekaz> Cale: thanks again.
21:21:26 <Cale> quite welcome :)
21:21:31 <petekaz> Captain_Fourier: I'm trying to learn how to use it so I can build myself a small app.  I have no experience with GUI, GTK programming (and I'm just starting in haskell).
21:21:51 <Captain_Fourier> yeah im in that same ballpark
21:21:59 <Captain_Fourier> im just playing around
21:22:07 <Captain_Fourier> making some ol fractals now
21:33:19 <scodil> is there any kind of standard (or widely used) library for low-dimensional vector calculus? like points and transformations in 2d and 3d?
21:33:39 <scodil> not quite blas or anything like that, because the dimensionality is fixed.
21:38:48 <araujo> petekaz, excellent!
21:39:12 <araujo> petekaz, gtk2hs is very easy to learn and understand.
21:39:30 <araujo> And fun.
21:48:39 <petekaz> araujo: I'm a bit overwhelmed with it right now, but I must say that using glade to make a gui seems to simplify the process.
21:49:46 <araujo> petekaz, yes, that should help
21:50:48 <araujo> petekaz, <comment behind dcoutts> though i find easier and fun to do it straight from a plain editor :-)
21:51:46 <petekaz> I'm not really a GUI guy so the packing stuff gets a bit overwhelming for me.
21:54:59 <petekaz> maybe you could explain something to me.  I added a menu to my app, and in the glade XML file, for the menu items, I see that each has a handler associated with it, i.e. handler="on_quit1_activate"  Do I implement that handler myself in gtk2hs, or am I supposed to just use onActivateItem and set up the handler manually?
21:57:21 <petekaz> Or are those handlers in glade XML for dynamically typed languages like python and ruby?  I assume in those languages I would just implement a function called on_quit1_activate.
22:02:22 <petekaz> araujo: you still there?
22:04:58 <araujo> petekaz, i don't consider myself a GUI guy either! ....
22:05:18 <araujo> petekaz, i really don't know glade.
22:05:21 <dons> heh. this is the araujo who wrote the what was it , himerge, the gui emerge tool...
22:05:33 <araujo> dons, sssh
22:05:46 <araujo> dons, Blame Haskell for my programs.
22:05:50 <dons> heh
22:05:50 <araujo> Not to me.
22:05:52 <araujo> :-)
22:08:28 <araujo> petekaz, So, according to your question ... i setup the handlers manually.
22:08:42 <petekaz> ok.
22:09:09 <araujo> petekaz, i mean, i do it all just with emacs+gtk2hsapi+lambdabot
22:18:11 <kfish> petekaz, i don't think you can use the glade handlers with gtk2hs
22:18:24 <kfish> you need to set them up manually
22:18:36 <kfish> which is better anyway, because you can use a partial application as your handler
22:18:48 <kfish> ie. you have more flexibility than you would have had in python or C
22:22:56 * glguy discovers that screen has a -U flag (for unicode support)
22:24:46 <kfish> glguy, awesome
22:25:13 <glguy> kfish: however my font might not have those two characters! :(
22:26:09 <kfish> ah :-( they were just stars
22:26:36 <glguy> heh, grep thinks that the unicode files are Binary
22:26:39 <kfish> speaking of which , if I use ghc6.6, can I use such characters in function names?
22:29:36 <kfish> (or more usefully, characters from other languages)
22:31:43 <dons> huh, did people know about this, http://www.geocities.jp/takascience/haskell/monadius_en.html
22:31:46 <lambdabot> Title: Monadius - a scientist's toy box, http://tinyurl.com/y5smdr
22:31:56 <dons> " Monadius is a shoot 'em up with the selection bar power-up system for Windows.
22:32:00 <dons> It also is one of few :'( games written in Haskell"
22:32:18 <dons> why don't people publicise their work!?
22:33:01 <dons> Monadius is  nice name for a haskell game..
22:34:15 <araujo> hah
22:35:05 <kfish> hmm, the japanese version of the page has much more info about the code too ...
22:35:39 * kfish puts rikaichan to work
22:35:40 <dons> ah maybe that's why. the guy doesn't follow the en-speaking community
22:35:46 * Bobstopper hates hayfever
22:35:54 <araujo> We need more translation efforts!
22:35:58 <dons> we do!
22:35:59 <kfish> dons, it's a separate world over here :-(
22:36:22 <dons> yeah. i see references to all sorts of mysterious haskell projects in .jp that never make it off the islands
22:36:44 <araujo> kfish, you from .jp?
22:36:44 <dons> sounds like a job for ... Super KFish!
22:37:43 <kfish> araujo, i'm from .au, but i just started a phd in japan
22:37:57 <araujo> kfish, nice, how haskell is doing over there?
22:38:07 <kfish> hmm
22:38:15 <kfish> most people haven't heard of it
22:38:21 <kfish> i saw one haskell book in the uni bookshop the other day
22:38:24 <araujo> ouch
22:38:48 <kfish> but it was really just an introductory text on functional programming
22:38:59 <araujo> mm ... the Bird book?
22:39:17 <dons> kfish: there's the evil bird book
22:39:21 <dons> you should get a copy !
22:39:25 <araujo> haha
22:39:33 <dons> let me find the url
22:39:57 <Bobstopper> if I manage to learn Japanese while I'm here I'll make an effort to translate some of the Japanese haskell stuff.
22:40:09 <dons> kfish: this guy, http://images-jp.amazon.com/images/P/4839919623.01.LZZZZZZZ.jpg
22:40:09 <kfish> ie. it was fairly similar to bird&wadler's "an introduction to functional programming"
22:40:11 <lambdabot> http://tinyurl.com/y6v7ul
22:40:13 <kfish> Bobstopper, where are you?
22:40:18 <Bobstopper> I'm in Japan
22:40:25 <Bobstopper> /whois bobstopper
22:40:29 <dons> which Chilli tells me means Haskell is very genki
22:40:33 <kfish> dons, yeah, that's the book i saw
22:41:19 <kfish> Bobstopper, i'm in kyoto
22:42:02 <Bobstopper> kfish: Yeah? Cool. I'm in Ishikawa. I'm going to Kyoto for a visit on 5-7 November.
22:42:22 <thou> w000t!
22:42:28 <thou> thank you, oleg!
22:42:34 <kfish> they have a functional programming group here: http://wwwfun.kurims.kyoto-u.ac.jp/
22:42:37 <lambdabot> Title: Functional programming at KURIMS
22:42:45 * thou does a little hoppy dance
22:43:08 <Bobstopper> Ha, cool! I thought I'd never meet anyone who'd heard of Haskell here...
22:43:11 <dons> kfish: these guys need to get their stuff on haskell.org .... and we need haskell.org/haskellwiki/Jp (to mirror the new /Es page)
22:43:19 <thou> Cale: here's the solution I was looking for the other night:  http://darcs.haskell.org/takusen/Control/Exception/MonadIO.hs
22:43:22 <lambdabot> http://tinyurl.com/y8ynhe
22:44:46 <araujo> dons, btw .... what would be the best way to migrate our current spanish stuff into the new link path?
22:45:12 <Bobstopper> dons: I had a look at your "poisonous people" page. I take offense at the "silly nick names" "easy" indicator for poisonous people ;)
22:45:24 <dons> Bobstopper: heh
22:45:47 <Bobstopper> We're a misunderstood minority
22:45:56 <Bobstopper> haha
22:46:02 <Bobstopper> 1337
22:46:14 <CoolHacker123> araujo: you can move pages
22:46:33 <araujo> mm .. right
22:46:41 * araujo gets to do that
22:47:41 <L33tLaMbdaHaXoR> there's clearly no correlation between nick names and quality :)
22:48:14 <dons> that was scary
22:48:30 <l4mBdApwn3r> I think I'll just leave myself like this for a while.
22:48:37 <dons> heh
22:49:03 <Bobstopper> I wonder if #lisp will ban me now.
22:49:20 <araujo> http://www.haskell.org/haskellwiki/Es/Haskell
22:49:22 <lambdabot> Title: Es/Haskell - HaskellWiki
22:49:26 <araujo> There we get it :-)
22:50:02 <dons> very good
22:50:07 <dons> araujo++
22:52:25 <araujo> This definitely will make life easier
22:53:02 <dons> what will? mirroring all pages under /Es/ ?
22:54:45 <dons> if you guys in .jp ever want to translate documents, we're starting on a proper translationg project for the haskell wiki. already we have:   * Language: en es
22:54:50 <dons> links, clickable from the front page
22:55:04 <dons> and the aim is to translate the top 10-50 pages on haskell.org, I'd think
22:55:24 <dons> araujo and the #haskell.es crew are doing a good job, but we have many other languages out there...
22:55:34 * dons should bug #haskell.se
22:57:09 <Bobstopper> Maybe I'll try translating it to lojban :P
22:58:01 <araujo> dons, yeah, mirroring easier for working with many translation efforts
22:58:04 <Bobstopper> kfish: how's your japanese?
22:58:10 <dons> araujo: right. good.
22:58:21 <araujo> dons, it was your idea actually :-)
22:58:30 <dons> araujo: now its obvious how to put up, say, haskellwiki/Pt/
22:58:39 <araujo> yay!
22:58:44 <dons> araujo: i just stole the layout idea from openbsd.org :)
22:58:49 <araujo> It should be plain easy.
22:58:52 <araujo> haha
23:00:17 <kfish> Bobstopper, getting there, i can get around town etc., but not good enough to, say, translate pages into japanese, or understand what's going on in my research lab meetings :-)
23:01:38 <Bobstopper> kfish: same. I guess we've got a ways to go before we can contribute to that then :)
23:01:48 <Bobstopper> bbl
23:03:10 <kfish> heh, you can tell a game is written in haskell when the blurb says "Replays are automatically saved, and are proved to play correctly."
23:03:35 <Botty> lol
23:07:03 <dons> kfish: heh!
23:14:28 <glguy> http://www.cl.cam.ac.uk/~mgk25/ucs-fonts.html
23:14:30 <lambdabot> Title: Unicode fonts and tools for X11
23:14:40 <glguy> Figured I'd share that link, the fon't looks nice as a default xterm font
23:14:51 <glguy> and supports a lot of neat characters
23:15:31 <dons> glguy: got unicode working on openbsd??
23:15:34 <glguy> oh yeah
23:15:36 <glguy> big time
23:15:57 <glguy> I can make my screen look like that screenshot now
23:16:03 <glguy> included on the link I just pasted
23:16:48 <glguy> UXTerm*font: -misc-fixed-medium-r-normal--18-120-100-100-c-90-iso10646-1
23:17:01 <glguy> that font looks nice at 1400x1050
23:17:06 <glguy> or whatever crazy resolution I'm running
23:18:00 <glguy> dons: were you having trouble getting Unicode working well in X?
23:18:02 <dons> want to write a little tut on getting unicode running in openbsd. i've only a vague idea how to do it.
23:18:09 <dons> all attempts have failed :)
23:18:29 <dons> really, i'd just like unicode irssi ... so i know what Cale is saying.
23:18:45 <glguy> dons: I installed that font
23:18:48 <glguy> use uxterm
23:18:57 <glguy> and did a /set term_charset=utf-9
23:18:59 <glguy> err 8
23:19:02 <glguy> in irssi
23:19:17 <dons> huh ok.
23:19:20 <dons> that's it?
23:19:31 * dons has a crack at it
23:19:32 <glguy> Umm... I think so
23:19:48 <glguy> I've been screwing with it this evening, so it is possible that I did more than that
23:20:03 <dons> uxterm in ports? or rol lyour own?
23:20:15 <glguy> uxterm exists in the standard install
23:20:17 <glguy> it is just a script
23:20:26 <glguy> that calls xterm, sets env vars and uses -u8
23:20:29 <dons> ah got it :)
23:20:54 <glguy> oh, screen has a -U flag
23:20:55 <dons> that font's pretty ugly, I reckon :}
23:21:08 <glguy> it reminds me some of terminus
23:21:15 <dons> hmm .yes
23:22:02 <babusri> Building ghc6.6 on ubuntu linux on vmplayer, takes a long time to archive (ar) libHSbase_p.a, virtual/rss memory shows 340m/140m, ar exits with error. Is it possible to run ar on fewer files at a time? Thanks
23:22:27 <glguy> dons: get it working outside of screen first
23:22:35 <dons> babusri: yeah, ar is buggy almost. should be fixed in newere ars
23:22:57 <dons> babusri: try with an increased ulimit
23:25:59 <glguy> It was really nice of my neighbor to install a linksys wireless ap with no encryption and the default admin password
23:26:00 <babusri> ulimt  is   unlimited
23:28:04 <Chinju> hey
23:28:14 <Chinju> I have a question about List.inits
23:28:30 <glguy> let's hear it!
23:28:32 <Chinju> specifically, about just how lazy it's supposed to be
23:28:52 <Chinju> I would have imagined the behavior of List.inits would be just the same as that of scanl (\x y -> x++[y]) []
23:29:05 <dons> glguy: yeah, that's cool. you should shout him a beer for being such a nice neighbour
23:29:09 <Chinju> however
23:29:13 <Chinju> trying things out in GHCi
23:29:31 <Chinju> (List.inits (2:undefined)) !! 1 breaks on the undefinedness (i.e., isn't lazy enough to handle it)
23:29:32 <dons> inits           :: [a] -> [[a]]
23:29:33 <dons> inits []        =  [[]]
23:29:34 <dons> inits (x:xs)        =  [[]] ++ map (x:) (inits xs)
23:29:34 <glguy> Chinju: that scanl definition probably wouldn't be very nice
23:29:40 <Chinju> why not?
23:29:45 <Chinju> using the scanl definition
23:30:01 <Chinju> defining myinits = scanl (\x y -> x++[y]) []
23:30:10 <dons> > inits [2,undefined]
23:30:12 <lambdabot>  Undefined
23:30:12 <glguy> dons: is it actually [[]] ++ ?
23:30:13 <Chinju> I can get (myinits (2:undefined)) !! 1 to return [2]
23:30:19 <dons> > head $ inits [2,undefined]
23:30:20 <lambdabot>  []
23:30:27 <Chinju> I want the second element
23:30:29 <Chinju> not the head
23:30:31 <dons> > take 2 $ inits [2,undefined]
23:30:32 <lambdabot>  [[],[2]]
23:30:38 <Chinju> and not [2, undefined]
23:30:39 <dons> > take 3 $ inits [2,undefined]
23:30:40 <lambdabot>  Undefined
23:30:40 <Chinju> but (2:undefined)
23:30:54 <Chinju> hm, how's this lambdabot work?
23:30:55 <Chinju> I'll show you what I mean
23:30:57 <glguy> > head (2 : undefined)
23:30:59 <lambdabot>  2
23:31:06 <Chinju> (List.inits (2:undefined)) !! 1
23:31:07 <dons> > take 2 $ inits (2:undefined)
23:31:08 <lambdabot>  Undefined
23:31:23 <Chinju> er, how do I send something to lambdabot?
23:31:28 <glguy> > "like this"
23:31:29 <lambdabot>  "like this"
23:31:31 <dons> > 1 + 2
23:31:33 <lambdabot>  3
23:31:35 <Chinju> ah
23:31:36 <dons> literate haskell :)
23:31:38 <Chinju> gotcha
23:31:39 <Chinju> ok
23:31:40 <Chinju> so
23:31:47 <Chinju> > (List.inits (2:undefined)) !! 1
23:31:49 <lambdabot>  Undefined
23:31:49 <glguy> \begin{code{
23:31:52 <Chinju> however
23:32:03 <Chinju> > (scanl (\x y -> x++[y]) [] (2:undefined)) !! 1
23:32:04 <lambdabot>  [2]
23:32:13 <Chinju> and, just to show my definition is correct
23:32:19 <Chinju> we can try it out like so:
23:32:24 <dons> ?check (scanl (\x y -> x++[y]) [] (xs :: T) == inits xs
23:32:25 <lambdabot>  Parse error
23:32:30 <dons> ?check (scanl (\x y -> x++[y]) [] (xs :: T)) == inits xs
23:32:31 <lambdabot>  Not in scope: `xs'
23:32:35 <glguy> Chinju: don't forget that [2,undefined] isn't (2:undefnied)
23:32:38 <Chinju> take 10 (scanl (\x y -> x++[y]) [] [1..])
23:32:40 <dons> ?check \xs -> (scanl (\x y -> x++[y]) [] (xs :: T)) == inits xs
23:32:40 <Chinju> yeah, I know
23:32:41 <lambdabot>  OK, passed 500 tests.
23:32:43 <Chinju> I clarified that earlier
23:32:47 <glguy> kk
23:32:53 <Chinju> hm
23:32:54 <dons> Chinju: quickCheck is even better for testing :)
23:32:56 <Chinju> yeah
23:32:58 <Chinju> plus I forgot the >
23:32:58 <Chinju> so
23:33:00 <Chinju> hehe
23:33:07 <Chinju> I'm not familiar with all the tools available here
23:33:08 <glguy> dons: did the unicode work out?
23:33:11 <Chinju> so, anyway
23:33:14 <dons> so looks like its slightly too strict, by one element
23:33:18 <Chinju> yeah
23:33:23 <Chinju> is there a reason for that?
23:33:31 <dons> I doubt its been spotted before.
23:33:45 <dons> would you like to make a comment to libraries@haskell.org ?
23:33:52 <dons> perhaps the original author of inits might know why
23:34:01 <Chinju> alright
23:34:01 <dons> present your scanl versoin, and show the different behaviour
23:34:28 <dons> sometimes we find these strictness issues, and resolve them. sometimes they're there by design, for performance reasons
23:34:36 <Chinju> ah
23:34:45 <glguy> the scanl version appends everytime
23:34:47 <glguy> right?
23:34:55 <dons> e.g. Num.lhs:    -- OK, so I made it a little stricter.  Shoot me.  (WDP 94/10)
23:35:09 <Chinju> yeah, the scanl version isn't an efficient one
23:35:12 <glguy> did he die 94/10?
23:35:14 <Chinju> it's just one I came up with that was lazy enough
23:35:38 <Chinju> I didn't think about performance yet; I just wanted to make sure my intuition about what kind of laziness was possible wasn't tricking me
23:35:53 <Chinju> so, perhaps, there is a performance reason to be more strict, I guess
23:35:57 <dons> yea, its a nice little test case, Chinju
23:36:05 <dons> Chinju++
23:36:07 <glguy> dons: dwm is really growin on me ;)
23:36:13 <dons> glguy: cool. me too
23:36:19 <dons> particularly since around 1.7
23:36:34 <glguy> my coworker and i are going to come up with some particularly newbish questions for the author, however
23:36:43 <dons> hehe
23:36:47 <dons> that should be fun
23:36:47 <glguy> thinking about asking how to make the screen spin
23:36:53 <dons> lol
23:36:55 <glguy> where is the opengl shortcut
23:37:02 <glguy> we saw it on youtube
23:37:06 <glguy> can dwm do it?
23:37:10 <dons> yeah, good idea!
23:37:11 <glguy> if not, it's suckful
23:37:22 <dons> just watch anselm have an aneurism
23:37:28 <glguy> how do I copy files to the desktop
23:37:28 <glguy> ?
23:37:34 <dons> hehe
23:37:40 <dons> stop it. it hurts.
23:38:09 <glguy> can he instant mail me an internet with the answers to my internet explorer please
23:38:23 <dons> glguy is evil.
23:38:25 <glguy> hmmm... too much ``internet''
23:38:58 <glguy> why doesn't he make it GPL so it can be free
23:39:24 <glguy> hmm... unicode is nice, but I don't know how to type any of the unicode characters in
23:39:46 <dons> just wait for Cale to type them, then copy them into a file
23:39:46 <Chinju> what's dwm?
23:39:53 <dons> try to trick him into typing the ones you need
23:40:03 <glguy> Chinju: you have to be able to find it to be elite enough to use it
23:40:10 <Chinju> hehe
23:40:13 <dons> Chinju: a minimalist window manager, some 1800 lines of C , similar to ion or wmii
23:40:23 <glguy> Chinju: what's sad is that I'm not entirely joking :)
23:40:38 <dons> gaining a bit of a following in here, its very light and fast, but not for the faint of heart
23:40:49 <Chinju> ah
23:41:01 <dons> (i.e. configuration is done by writing cpp )
23:41:15 <glguy> allow me ot quote from the dwm website:
23:41:35 <glguy> arg
23:41:39 <glguy> copy and paste is hard
23:42:02 <Chinju> haha
23:42:10 <glguy> Because dwm is customized through editing its source code, it's pointless to make binary packages of it.
23:42:18 <dons> yeah, that's fun.
23:42:18 <glguy> This keeps its userbase small and elitist
23:42:31 <dons> I prefer 'l33t'
23:42:34 <glguy> No novices asking stupid questions.
23:42:52 <dons> actually, you should inform Anselm that dwm is l33t
23:43:02 <dons> ?elite Anselm, I think dwm rocks
23:43:02 <lambdabot> 4N$elm, i THINK DW/\/\ r0(xz
23:43:07 <glguy> I love that he concerns himself with the fact that it is faster than ion3
23:43:22 <dons> heh. its tthat attention to detail that you have to love
23:43:57 <dons> obsessive compulsive people make great coders for _small_ projects that they can control all aspects of
23:44:02 <glguy> "dwm is better than you are"
23:44:13 <dons> oh, is that on the website?
23:44:22 <glguy> no, but it's editable
23:44:26 <dons> if not, that's a really cool slogan
23:44:36 <glguy> it's a wiki, I could add it right now
23:44:47 <glguy> "In contrast to ion3, dwm is better than you."
23:45:15 <Chinju> that _is_ a nice slogan. Thankfully, DWM's userbase is apparently so small, I can steal that slogan idea and use it for whatever else without anyone noticing
23:45:16 <glguy> Oh, arg has it passworded
23:45:49 <glguy> I have a feeling I'm not the first to come up with that gem. (-;
23:46:15 <Chinju> even better plausible deniability for my own copycatting
23:46:42 <glguy> fortunately, for software to "be better than you" it must be BSD licensed or better
23:46:57 <glguy> so I'll be able to take advantage of any sweet gains you make with that slogan
23:48:03 <Chinju> good point
23:49:41 <glguy> dons: I tried out -CURRENT's ACPI support yesterday
23:49:59 <glguy> when running it, I could press my power button and shtudown -h now would run
23:50:10 <glguy> and my battery status was available in sysctl
23:50:23 <glguy> but... my display didn't turn off when I closed it
23:50:31 <glguy> so I had to revert back )-:
23:51:47 <thou> ?instances MonadIO
23:51:48 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
23:52:00 <thou> hmmm
23:57:10 * thou crosses fingers
