00:00:19 <lisppaste2> gour pasted "lambdabot-darcs build fails" at http://paste.lisp.org/display/28278
00:00:49 <gour> dons: any idea ^^^ ?
00:03:04 <dons> gour: you have the latest patches?
00:03:25 <gour> dons: i pull with lambdabot-darcs ebuild
00:03:43 <dons> let me just check the latest repo...
00:04:14 <dons> have a snoop around, or try using the lambdabot from my darcs repo
00:04:20 <dons> i'm a bit busy to chase this down right now
00:04:23 <gour> ok
00:04:26 <dons> if you can't sovle it, send me a bug report via email
00:21:27 <aleator> What does "<interactive>: internal error: too many workers; runaway worker creation?" mean when ghc spits it out? (6.5 something still)
00:21:55 <dons> sounds like too many threads or something?
00:21:58 <dons> i've not seen that before
00:25:18 <aleator> comes from parMap rnf f largish_list. I'm stuck with 6.5 for a while and wonder if it is something I did or a bug that has been seen already.
00:26:11 <dons> ask on glasgow-haskell-users@
00:26:18 <dons> sounds like something interesting
00:38:27 <aleator> Ah.. It seems to have been fixed already. Good.
00:42:07 <dons> oh, looks like our chameneos submissoin got disallowed on a technicality
00:42:19 <dons> probably should look at the ghc 6.6 shootout effort soon...
01:04:40 <pandres> hello , readFile reads one line at a time?
01:05:21 <ibid> that would be an implementation detail
01:05:30 <ibid> what makes you think so?
01:06:17 <Cale> The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents.
01:06:42 <Cale> that's what the documentation says :)
01:07:00 <pandres> yep Cale , thanks, but it is still not clear, i guess ill do a test
01:07:11 <Cale> how could it make a difference?
01:07:13 <ibid> yeah, so whether it reads a character a time, a line a time or a block a time is an implementation detail that should not be visible to the user :)
01:07:19 <thou> gah
01:07:32 * thou is still trying to use bracket
01:07:54 <dons> ?docs System.IO
01:07:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
01:07:59 <dons> pandres: ^^
01:08:07 <dons> ?type getLine
01:08:08 <lambdabot> IO String
01:08:10 <pandres> ok
01:08:13 <dons> ?type readFile
01:08:13 <Cale> thou: Have you considered just not closing the connection?
01:08:14 <lambdabot> FilePath -> IO String
01:08:17 <dons> ?type hGetLine
01:08:18 <lambdabot> Not in scope: `hGetLine'
01:08:22 <thou> Cale: NO!
01:08:23 <thou> :-)
01:08:38 <thou> damnit, there's got to be a way to do this
01:08:39 <Cale> thou: If the library is properly designed, then the connection should be closed when you no longer need it.
01:08:39 <dons> thou: so what's wrong with hClose on the handle?
01:09:07 <dons> that's how I usually close sockets, after sending whatever quit message the protocol uses
01:09:30 <Cale> hClose is usually a bad thing to call on something which has had hGetContents called on it
01:09:38 <dons> oh, yes. certainly
01:09:44 <dons> if you're mixing lazy io in with this...
01:09:57 <Cale> I think he's using a database library which does lazy IO
01:10:21 <Cale> if it's properly written, then it ought to close the connection when all the elements of the datastructure are forced
01:10:35 <dons> yeah, I don't get why there's any problem...
01:10:44 <dons> we write this kind of bracket-based network code every day
01:10:49 <Cale> So you shouldn't close the connection explicitly
01:11:15 <Cale> If it doesn't do that, I'd consider that a bug :)
01:11:44 <Cale> You either have lazy IO with automatic closing, or strict IO :)
01:11:49 <dons> yeah
01:11:51 <lisppaste2> thou annotated #28273 with "This one works (deepSeq, no bracket)" at http://paste.lisp.org/display/28273#4
01:11:55 <dons> Cale: that's a good rule
01:12:18 <Cale> this is John Goerzen's HDBC?
01:12:26 <thou> yes
01:13:34 <thou> the (theoretical) problem with that is it doesn't handle exceptions at all, so if proc throws an exception, disconnect won't get called
01:13:50 <dons> you've seen the bracket/catch irc bot tutorial?
01:14:37 <dons> also, sometimes asking design question on haskell-cafe@ can get good responsess
01:14:48 <dons> there's guys out there who just love designing solutions to problems in haskell :)
01:14:54 <lisppaste2> thou annotated #28273 with "attempt at myBracket :: IO a -> (a -> IO b) -> (a -> CGI c) -> CGI c" at http://paste.lisp.org/display/28273#5
01:15:47 <thou> i keep getting type errors with *something*, no matter how much i try to use bracket
01:16:37 <thou> i rewrote it (using ghc's source as a base), and now am having trouble with the (use resource) part of the unblock call; i expect if i remove the block and unblock, it'll just give an error of something else
01:18:23 <Cale> what are the errors?
01:19:05 <Cale> first of all, does the thing work if you don't disconnect from the database?
01:19:31 <lisppaste2> thou annotated #28273 with "myBracket (without block/unblock); with errors" at http://paste.lisp.org/display/28273#6
01:20:32 <thou> Cale: yes, it works fine even disconnecting from the DB, if I use the deepSeq method; but i want to figure out how to combine the CGI and IO monads together correctly to use bracket
01:21:06 <thou> i guess it doesn't matter at all, practically, if i never call disconnect; but it bothers me that i can't figure out how to combine these things
01:21:24 <thou> and i can imagine a circumstance where using bracket + CGI would be very appropriate
01:21:29 <dons> thou: have you looked at the irc/Net monad tutorial? sounds like a similar thing...
01:21:37 <dons> and uses bracket.
01:21:42 <Cale> hmm, use :: (a -> IO b)
01:21:46 <thou> ?google irc net tutorial
01:21:51 <lambdabot> http://www.irchelp.org/
01:21:51 <lambdabot> Title: Internet Relay Chat (IRC) Help
01:21:58 <thou> no
01:22:00 <dons> ?google Roll your own Haskell irc bot
01:22:02 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
01:22:03 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
01:22:05 <Cale> er, no
01:22:07 <Cale> destroy is
01:22:11 <thou> Cale: where?
01:22:26 <Cale> so that's okay
01:22:35 <Cale> er, hang on
01:22:50 <Cale> comment out the type signature for myBracket
01:22:51 <thou> Cale: i think the problem is liftM2 is wrong
01:22:53 <Cale> and see what you get
01:23:04 <Cale> I think it's that you're adding an IO constraint
01:23:54 <lisppaste2> thou annotated #28273 with "error without type signature for myBracket ("Couldn't match kind...")" at http://paste.lisp.org/display/28273#7
01:28:02 <Cale> mm
01:29:18 <gour> nice article (together with linked Dijkstra's lecture) - http://www.codinghorror.com/blog/archives/000051.html
01:29:21 <lambdabot> Title: Coding Horror: Why I'm the best programmer in the world*, http://tinyurl.com/pb57r
01:32:00 <dons> this week's HWN is out now, stick some votes on it, http://programming.reddit.com/info/mtzj/comments
01:32:03 <lambdabot> Title: Haskell Weekly News: new Pugs, new GHC, more transactional memory (reddit.com), http://tinyurl.com/ykloff
01:32:09 <thou> dons: the trouble is that i'm trying to force bracket into the CGI monad, not the other way around.  i mean, bracket explicitly takes IO actions - it doesn't accept SomeMonadClass m => m a -> (a -> m b) ...
01:32:25 <dons> thou: write, so you need to be in a monad transformer over IO...
01:32:26 <thou> the tutorial, as most examples i've seen, uses bracket in the IO monad
01:32:30 <dons> s/right / :)
01:32:42 <thou> yes, and CGI is defined as type CGI a = CGIT (IO a)
01:32:44 <dons> of course, it _must_, since bracket is in IO.
01:32:48 <dons> ok, so lift bracket then
01:32:55 <thou> i've been trying....
01:32:56 <thou> so many ways
01:33:08 <dons> you can use MonadError to do some of this stuff too.
01:33:21 <dons> there's some examples in Lambdabot, but yeah, bracket's not easy to play with outside of IO
01:33:31 <dons> it would be nice if it was Monad a => ....
01:34:36 <pandres> hi, how can i get a IO [string ] to a filePath? i got this "readFile.getArgs"
01:35:07 <thou> pandres: FilePath == String
01:35:10 <thou> (synonym)
01:35:24 <pandres> but doesnt works
01:35:28 <thou> pandres: so you need to use getArgs inside main
01:35:33 <pandres> its IO strong
01:35:41 <thou> and then pick one of the elements (using 'head' for example) from the list
01:35:43 <dons> do [f] <- getArgs; readFile f
01:35:45 <pandres> i want to read the file from command line
01:35:51 <pandres> mm
01:35:55 <pandres> thanks
01:36:04 <dons> looks like a little IO tutorial would be a good idea, pandres :)
01:36:06 <dons> ?where yaht
01:36:07 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
01:36:10 <dons> ^^ good place to start
01:36:13 <AStorm> Ok, OCaml got me. Bye #haskell (for a while, at least)
01:36:26 <dons> we'll see how long that lasts.... ;)
01:36:32 <TSC> Funny, I came to Haskell because OCaml was too limited (:
01:36:54 <pandres> ok,lets check IO then
01:37:16 <dons> TSC, yeah, all the traffic's been the other way for the last few years
01:37:25 <thou> i just can't stand ocaml's syntax, after reading haskell
01:37:35 <Cale> Is there an ubuntu build of GHC 6.6 yet?
01:37:37 <pandres> man! 192 pages, I just want to do a script! for fun
01:37:46 <pandres> haskell has a price
01:37:58 <dons> you don't have to read the whole book....
01:38:09 <dons> but learning _some_ of the language, is good if you're going to use it...
01:39:24 <dons> pandres: here you go, nice and simple:
01:39:25 <dons> import System.Environment
01:39:26 <dons> main = do
01:39:26 <dons>     [f] <- getArgs
01:39:26 <dons>     s   <- readFile f
01:39:28 <dons>     putStrLn s
01:39:35 <dons> (you can write it even smaller, but this is just for clarity)
01:40:13 <pandres> sure, clarity first! people should see it and  get interested in haskell, for scripting..
01:40:16 <dons> pandres: when you said 192 pages, i though of the Perl Programming book, all 400 pages...
01:40:25 <dons> pandres: have you seen haskell.org ?
01:40:30 <dons> that's the _best_ place to start
01:40:32 <pandres> but in perl anything compiles!
01:40:37 <thou> hehe
01:40:58 <pandres> yes, i've even read functional pearls, long time ago
01:41:05 <dons> doesn't mean you wrote anything meaningful though. its not challenge to convince a weakly typed language that your code is correct
01:41:13 <pandres> now i want to do some parsing over the lines and dont remember anything
01:41:33 <thou> pandres: it's true, if you're used to perl, haskell will feel very weird for a while
01:41:50 <vegai> dons: Hey. Should hs-plugins be working on ghc-6.6?
01:42:07 <thou> i've been playing with it off and on, and i'm stil embarassed about how difficult i find some things
01:42:10 <dons> vegai: no.
01:43:09 <pandres> i've used haskell, but algorithms 101 and shell scripting are very different
01:43:25 <pandres> i even understand monads!
01:43:33 <pandres> but that doenst mena anything
01:44:26 <Syzygy-> pandres: Whoa! :)
01:45:05 <pandres> im a mediocre programmer, thats why i want to learn haskell, secondary efects are too much for me
01:46:16 <dons> araujo: HWN is out now.  look at archives/20061019.txt
01:46:25 <dons> pandres: that's a good reason :)
01:46:40 <dons> my brain is too small too program without lots of tool support.
01:46:41 <vegai> dons: Will it? Is it tough to fix?
01:46:52 <dons> vegai: it will, yes. its about a days work
01:47:10 <dons> its rapidly climbing up my priority list
01:47:26 <vegai> What is it? It looked like some sort of template haskell trouble, but is there something worse?
01:48:23 <ProfTeggy> Moin
01:50:04 <roconnor> Moin Moin
01:50:31 <ValarQ> g'day professor
01:51:24 <dons> HWN is out, in case people missed it... http://programming.reddit.com/info/mtzj/details (1 or 2 up mods are a good idea, so it doesn't get wiped by a random ruby lover :)
01:51:27 <lambdabot> Title: Haskell Weekly News: new Pugs, new GHC, more transactional memory (reddit.com), http://tinyurl.com/yc4uf2
01:51:32 * beelsebob poiks ProfTeggy, roconnor, ValarQ and dons   
01:51:48 <dons> ouch.
01:51:52 <ProfTeggy> Woops
01:51:53 * dons poiks beelsebob 
01:51:57 <beelsebob> OW!
01:52:03 * beelsebob pokes dolio 
01:52:06 <beelsebob> FAIL!
01:52:14 <beelsebob> stupid tabbing!
02:06:45 <joelk> It seems I can declare variables using 2-byte utf-8 characters like δ and ö, but I get a lexical error on フ (katakana "fu", 3-bytes in utf-8).
02:07:36 <dons> perhaps seek clarification on glasgow-haskell-users@ ?
02:07:42 <dons> (you're using the new ghc 6.6?)
02:07:47 <joelk> yes
02:08:08 <dons> yeah, not many people are familiar with the details of it yet.
02:08:15 <dons> best to ask on the ghc list, I reckon
02:08:20 <joelk> thanks
02:09:17 <joelk> on the other hand, I've learned more about unicode today than I would ever have otherwise. :)
02:09:34 <dons> heh
02:09:56 <dons> i suspect we're all going to have to, now ghc actually accepts utf8 src
02:12:01 <ValarQ> how is the editor-support for utf-8?
02:12:20 <joelk> To print foo in Japanese on a utf-8 terminal, try B.putStrLn . B.pack $ [227, 131, 149, 227, 131, 188]. OK, so the UTF8 package from jhc should simplify that a bit!
02:12:22 <norpan> any decent editor handles it
02:12:26 <ValarQ> im thinking about efficient ways of writings utf-8 symbols with a ordinary keyboard
02:12:41 <norpan> there are no symbols in UTF-8, you mean unicode?
02:13:35 <ValarQ> norpan: thats correct
02:13:41 <norpan> well
02:13:46 <norpan> there are various input methods
02:13:59 <pandres> ok, last question I hope, how can i get the  "one" string from the string "one/tags/2.1.4"
02:14:07 <ValarQ> how does the cjk languages handle it?
02:14:41 <norpan> most often they use latin keyborads and som kind of pinyin input method
02:15:06 <ValarQ> pinyin?
02:15:08 <dons> whoa, there's still unis teaching in Miranda. that's scandalous, http://julipedia.blogspot.com/2006/06/functional-programming-and-haskell.html
02:15:11 <lambdabot> http://tinyurl.com/uub3m
02:15:30 <pandres> i got a nice split function , but the return type is not suitable for putStr, for ex
02:17:43 <norpan> ValarQ: yes, transliteration
02:18:36 <ValarQ> norpan: how does that work in practice?
02:18:58 <norpan> you type the transliteration and get a menu of possible characters
02:20:58 <ValarQ> menus seems fancy :/
02:21:11 <pandres> ok, then the question would be : whiy this doesnt works even if the types matches (split :: String -> Char -> [String])
02:21:15 <norpan> normally you'd choose one using a digit
02:21:25 <pandres> putStrLn head split s '\n', sorry, wrong paste
02:22:12 <norpan> so, you'd type bei and get a menu and choose 北, and then type jing and get a menu and choose 京
02:22:15 <norpan> or something like that
02:24:34 <norpan> but it's understandable that those characters won't work for haskell identifiers, since they are neither upper nor lower case
02:24:38 <dons> mmm. Wozniak could be talking about haskell :)  --- A revolutionary new product won't be understandable to most people.  Don't let these people bring you down. They only know what they're exposed to. It's a type of prejudice against the spirit of invention.  Trust your intuition, that way lies happiness.
02:25:28 <joelk> ValarQ, another example. In Japanese you usually type the whole sentence, inspect the default transformation, adjust as necessary, and finally accept.
02:26:03 <norpan> but you can write very obscure code in haskell now, by using different unicode characters that have the same rendering
02:26:29 <dons> mmm!
02:26:38 <dons> that's super fun.
02:26:45 <dons> ?wiki Obfuscation
02:26:46 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
02:26:52 <dons> but without the unary encoding of identifiers....
02:26:56 <Syzygy-> Ooooh. I'm on the programming.reddit first page! o.O
02:26:57 <dons> just use a nullary encoding :)
02:27:17 <dons> oh, is there a bit of a haskell flood?
02:27:29 * dons has a suspicion that people post links from the blog section of HWN ... :)
02:27:40 <dons> ah yes, Syzygy- cool.
02:28:02 <Syzygy-> HWN?
02:28:18 <dons> ?where HWN
02:28:18 <lambdabot> http://sequence.complete.org/
02:31:15 <ValarQ> joelk: ok, sounds like an acceptable method
02:31:25 <gds> Syzygy-: It's also mirrored on planet.haskell.org
02:31:46 <Syzygy-> Yah.
02:31:53 <Syzygy-> Btw, gds: I'm the one you asked about on LJ...
02:32:17 <gds> Syzygy-: Yeah, I got your PM :) Thanks :)
02:36:32 <astrolabe> Is the 'entries' column in a GHC 'Time and Allocation Profiling Report' different from the number of times a function is evaluated?
02:37:10 <psi> ValarQ: you can use abbrev mode in emacs
02:38:40 <psi> ValarQ: so could type e.g., "lambda" and have that transformed into λ automatically
02:38:50 <ValarQ> oh
02:39:45 <gds> latex math mode does some of that...
02:39:54 <therp> ik the lambda of the font of my IRC client is typographically ugly.
02:39:55 <gds> `E becomes \exists for example.
02:41:02 <psi> ValarQ: do you use emacs? I could paste my abbrev-table.
02:42:22 <ValarQ> yes, GNU Emacs
02:43:03 <ValarQ> psi: do you use abbrev in emacs for haskell-coding?
02:43:18 <norpan> but ghc doesn't allow λ instead of \, now does it?
02:43:26 <gds> psi: I'd be interested :)
02:43:53 <psi> norpan: it doesn't? I'm pretty sure that was introduced in 6.6.
02:44:16 <dons> I thought it did. but we had sjanssen report that this wasn't the case.
02:44:24 <dons> which needs a follow up. since JaffaCake says it shoudl work..
02:44:31 <psi> ?paste
02:44:31 <lambdabot> http://paste.lisp.org/new/haskell
02:44:35 <dons> \/ forall orks too
02:44:36 <norpan> it's a conflict, because λ is also a lower-case letter
02:45:08 <dons> you need -fglasgow-exts, anyway
02:45:13 <psi> also? isn't is simply a lower case letter?
02:45:32 <psi> i though Λ was upper case lambda
02:45:45 <norpan> psi: yes, but \ is a special syntax construct
02:45:59 <norpan> and so, if we'd allow λ for \ we'd be in trouble
02:46:09 <dons> yeah, clearly adding forall or lambda as keywords needs lexer support...
02:46:21 <dons> but I don't see why there's "trouble"
02:46:27 <dons> you just have to treat them specially, like with \
02:46:44 <norpan> the trouble is that lambda is also a character
02:46:44 <dons> and any other syntax
02:46:49 <norpan> and could be part of identifier
02:47:15 <lisppaste2> psi pasted "abbrev-table" at http://paste.lisp.org/display/28283
02:47:29 <ValarQ> so haskell has to drop support for lambda-expressions... :)
02:47:30 <psi> hm
02:47:38 <psi> lisppaste did something to my characters.
02:47:51 <norpan> ∀ would be nice to have though
02:48:44 <norpan> but it's all fancy schmancy
02:48:50 <psi> ^- that's not going to work in emacs
02:48:58 <norpan> the main thing is to allow unicode inside strings
02:49:28 <ValarQ> norpan: thats true
02:49:35 <Cale> http://www.nataliedee.com/101906/nightshift-at-the-factory-factory.jpg -- heh
02:49:41 <lambdabot> http://tinyurl.com/y3xznj
02:50:30 <norpan> having nice operators is of course also nice, esp when you're implementing something from a paper
02:50:55 <norpan> ⊕⊖⊗⊘⊙⊚⊛⊜⊝⊞⊟⊠⊡
02:51:02 <musasabi> Of course one can just make emacs prettyprint everything.
02:51:38 <ValarQ> musasabi: that might be the best choice
02:52:19 <ValarQ> then you could type \ but visually get a λ depending on context
02:52:39 <norpan> scary
02:52:45 <beelsebob> psi: your random editor not supporting something is not a reason for it not to be a good thing
02:52:53 <beelsebob> get a better editor
02:53:16 <ThreeQ> are those valid operators now?
02:53:26 <norpan> i would suppose so
02:53:36 <ThreeQ> cool!
02:53:37 <norpan> otherwise somebody did a half-baked job
02:54:02 <joelk> ThreeQ, just tried  ⊕ out. Seems to work, but ghci doesn't like utf-8 input.
02:54:04 <beelsebob> having λx → x*x would be shiny
02:54:15 <beelsebob> joelk: 6.6 should like it
02:54:16 <psi> beelsebob: what?
02:54:33 <beelsebob> psi: just because emacs can't display unicode right is no reason to say that unicode is a bad plan
02:54:50 <psi> beelsebob: it *can*. I was refering to the elisp that lisppaste mangled.
02:55:09 <beelsebob> oh, I see!
02:55:16 <beelsebob> I thought you were refering to the for all symbol
02:55:29 <Cale> Prelude> let x ⊕ y = zipWith (+) x y
02:55:29 <Cale> <interactive>:1:7: lexical error at character '\138'
02:55:30 <norpan> any decent editor displays unicode
02:55:38 <beelsebob> indeed
02:55:39 <joelk> beelsebob, ghci 6.6 gives me a lexical error " ... at character '\nnn'" where nnn is the second byte of the utf-8 encoding.
02:55:43 <Lemmih> Cale: GHCi doesn't support unicode.
02:56:05 <beelsebob> joelk: interesting - there was a whole series of posts recently that culminated in "use utf-8 and 6.6 should be happy"
02:56:18 * Lemmih semi-fixed that for his GHC job interview.
02:56:30 <psi> ValarQ, gds: http://bart.sm.luth.se/~simsan-4/abbrevs.el
02:56:32 <ValarQ> (∩) = intersect -- is really nice :)
02:56:34 <Cale> hmm
02:56:44 <ValarQ> psi: thanks
02:56:47 <beelsebob> indeed
02:56:53 <Cale> So although I can define unicode named functions, I just can't test them with ghci :)
02:57:02 <norpan> psi: hey, how does that work with multiple "sigma"?
02:57:03 <beelsebob> psi: that still doesn't come out right here
02:57:10 <beelsebob> is the encoding set correctly in the html?
02:57:13 <Cale> (without first using them in my file and then naming those things without unicode)
02:57:30 <beelsebob> safari thinks it should use it's default encoding for that pace
02:57:32 <beelsebob> page*
02:57:38 <ThreeQ> does any other programming language support unicode function/operator names?
02:57:39 <beelsebob> (which is not utf-8)
02:57:51 <psi> norpan: ohh. I think that's a mistake. I simply pasted something into my emacs and applied some macros.
02:57:53 <Lemmih> ThreeQ: I think perl6 does.
02:58:04 <psi> norpan: are there actually 2 sigmas?
02:58:06 <ValarQ> beelsebob: its the webserver that doesn't identify the encoding
02:58:21 <beelsebob> fair enough
02:58:26 <norpan> psi: yeah, they use two different symbols depending on where it is in the word
02:58:28 <psi> beelsebob: well, it's not html
02:58:41 <psi> beelsebob: I just used wget and it came out fine
02:59:02 <psi> norpan: ah
02:59:08 <norpan> ς at the end of a word, and σ in the middle of a word
02:59:11 <beelsebob> I guess it just depends what your editor/displyer thinks is best as a default
02:59:12 <gds> psi: http://groups.google.com/group/gnu.emacs.sources/msg/6588aefedcaa658e?oe=UTF-8&output=gplain
02:59:14 <lambdabot> http://tinyurl.com/th2yf
02:59:20 <gds> lambdabot: Thankyou :)
02:59:24 <beelsebob> I think Safari uses ISO Latin 1
02:59:46 <gds> psi: pretty lambdas in lisp - should be fairly hackable to haskell :)
03:00:22 <gds> musasabi: Does what you were suggesting, in fact...
03:00:27 <psi> ah, yes. not quite the same, though.
03:00:27 <norpan> psi: change the ς to varsigma and you match the latex name for it :)
03:00:58 <beelsebob> rofl
03:01:04 <psi> ok :)
03:01:06 <beelsebob> I'm not writing my Haskell programs in LaTeX
03:02:02 <wolverian> Lemmih, yes, it does.
03:02:07 <wolverian> (just confirming.)
03:02:26 <gds> Any literate haskell coders in the house?:)
03:02:36 <beelsebob> quite a few
03:02:52 <beelsebob> not me though
03:02:56 <gds> :)
03:03:18 <beelsebob> unless you mean that I'm a haskell coder who is literate?
03:03:19 <beelsebob> :P
03:03:19 <musasabi> gds: I used x-symbol for that.
03:03:20 <Lemmih> Any illiterate coders in the house?
03:03:43 <norpan> ⨌
03:03:59 * gds apropos x-symbol...
03:05:21 <wolverian> heh, there's something cute in a © operator
03:05:21 <gds> Ah - cool :)
03:06:01 <ValarQ> is there any lhs to LaTeX converters that translates \ to real lambdas? ?
03:06:20 <beelsebob> wolverian: perhaps it should apply DRM :P
03:07:26 <wolverian> beelsebob, or return the gpl text :)
03:07:47 <beelsebob> hehe
03:21:37 <integral> @hoogle (Monad m) => (a -> m Bool) -> (a -> m a) -> a -> m a
03:21:38 <lambdabot> No matches, try a more general search
03:22:10 <integral> @hoogle (Monad m) => (a -> Bool) -> (a -> a) -> a -> a
03:22:11 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
03:22:22 <integral> no untilM? :-(
03:24:21 <dons> ?hoogle until
03:24:21 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
03:24:22 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
03:24:42 <dons> ?hoogle unless
03:24:42 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
03:24:42 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
03:24:42 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
03:25:07 <dons> ?hoogle guard
03:25:07 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
03:25:07 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
03:25:07 <lambdabot> Language.Haskell.TH.Guard :: data Guard
03:25:40 <dons> ?hoogle Monad m => m Bool -> (a -> m a) -> a -> m a
03:25:41 <lambdabot> No matches, try a more general search
03:26:14 <integral> more imperative combinators would be really useful out here in the RealWorld
03:26:16 <ozone> dons: do you know anything about popen() and bidirectional unix pipes?
03:30:59 <integral> ?hoogle Int -> a -> [a]
03:30:59 <lambdabot> Prelude.replicate :: Int -> a -> [a]
03:47:44 <Captain_Fourier> hmm
03:47:47 <Captain_Fourier> I love haskell
04:03:24 <lisppaste2> pandres pasted "list type" at http://paste.lisp.org/display/28286
04:04:29 <pandres> ok, I almost got my script, i got a type error in a map, if someone wants to help me her it is http://paste.lisp.org/display/28286
04:05:38 <Lemmih> How about: 'let ps = map getProd lines'?
04:06:04 <Lemmih> Or: putStrLn $ unlines $ map getProd lines
04:06:09 <pandres> interesting
04:06:10 <Captain_Fourier> i am really enjoying this language
04:06:15 <pandres> ;)
04:06:22 <edwinb> I guess you're assuming the map modifies 'lines'?
04:07:28 <Captain_Fourier> what do those $s do
04:07:47 <pandres> nope, i just got the type error and wanted to fix that, i dint asume map changes the list
04:07:53 <Lemmih> Captain_Fourier: f $ x = f x (:
04:08:04 <Captain_Fourier> thanks
04:08:08 <Captain_Fourier> that can be handy
04:08:15 <pandres> in fact, i still have the error: Couldn't match `IO' against `[]
04:08:27 <pandres> in the map lines
04:08:52 <Lemmih> pandres: Did you try one of the solutions I proposed?
04:09:07 <pandres> yes, the Or one
04:09:18 <edwinb> right... it'd need to have type IO <something> in do notation
04:09:23 <pandres> map getProd lines <- mismatch
04:09:38 <Lemmih> pandres: That one requires you to remove the first 'map getProd lines'.
04:09:41 <Captain_Fourier> so let foo a b = a +b  foo a $, is bad
04:10:16 <pandres> yes :)
04:10:27 <Captain_Fourier> hmm
04:10:38 <Captain_Fourier> i need to snap out of ocaml mode
04:10:58 <pandres> genius
04:11:02 <pandres> you are
04:11:09 <pandres> thanks
04:11:33 <Lemmih> Captain_Fourier: 'foo a ($)'  or  'foo a $ b'  would be ok.
04:12:24 * psnl grins: I'm about to use hat to debug.... hat
04:13:28 * Lemmih takes his hat off for that.
04:31:11 <pandres> man, i got a script in haskell!! my partners wont believe it
04:31:26 <pandres> it was fun,. thanks for the help
04:39:16 <astrolabe> Does anyone know what it means when 'SYSTEM' is the main cuprit in a retainer heap profile?
04:39:36 <dcoutts> shapr, re serialisation for Data.ByteString, I have some ideas but nothing concrete yet. You're most welcome to develop it to a usable state. musasabi is interested too.
04:41:26 <dcoutts> shapr, well, I do have some code too, but it needs work
05:15:03 <dons> mmm. I like JaffaCake's comments about lambda being a quiet syntax
05:15:37 <dons> hence all this \<pat> <guard> stuff has some icky flavour to it
05:16:07 <SamB> mmm
05:16:36 <dons> if its complicated enough to need a guard, you should be using a where and a proper function
05:16:41 * SamB wonders why nobody seems to have responded to his email...
05:16:54 <dons> SamB: hmm, you didn't sell it properly?
05:17:12 <SamB> hmm
05:17:14 <dons> think of email as bait to hook a developer... its got to be tasty
05:17:25 <dons> I suggest, Subject: Haskell sucks.
05:17:28 <dons> hehe
05:17:32 <SamB> hahaha
05:17:37 <profmakx> spam
05:17:40 <profmakx> *klick*
05:18:10 <dons> with a suitabliy provocative subject, "Haskell can't do this", you might even get Oleg or someone to write the code for you...
05:18:21 <dons> claiming that something is impossible is a perfect way to do this
05:18:27 <SamB> heh
05:18:37 <profmakx> reverse psychology works!
05:18:39 <dons> (students should take note of this, for encoding homework problems as "impossible")
05:18:42 <Igloo> Double points for claiming it's impossible to do it with the type system
05:18:45 <SamB> so I write an email entitled "impossible profiling task"?
05:18:50 <dons> Igloo: hehe
05:18:53 <dons> SamB: that's right!
05:19:03 <SamB> so "impossible to profile via the type system!"?
05:19:10 <dons> heh
05:19:25 <dons> well, profiling the type system is a whole other can of worms
05:19:36 <SamB> heh
05:19:38 <dons> which I'm sure Oleg has pondered
05:28:30 * resiak writes down dons's homework remark for future reference.
05:29:28 <shapr> dcoutts: mmm, code
05:29:36 <dcoutts> :-)
05:31:37 <dons> resiak: heh
05:32:22 <Stinger_> heh I remember some bash quote about that and linux
05:32:58 <Stinger_> http://www.bash.org/?152037
05:32:59 <dons> all you have to do is rephase your basic comp1A homework problem as a type system problem, and you'll get an answer
05:33:00 <lambdabot> Title: QDB: Quote #152037
05:33:18 <dons> "Help! How to sort a list" --> "Help!! How to sort a list on the type level"
05:33:29 <resiak> I must try that
05:33:41 <SamB> but, can you understand the answer and will your teacher like it?
05:33:50 <resiak> Actually, there was a problem on a set I did earlier in the week labelled "PROJECT (means I can't do it!) NOT FOR HANDING IN"
05:33:59 <resiak> It took about three lines.
05:33:59 <dons> then of course you need to desugar the resulting GADT/type class/existential/... code back into normal value level functoins.
05:34:52 <norpan> haskell sucks because you cant write a function primes that will return an infinite list of prime numbers using a helper function isPrime which cannot be defined in haskell
05:35:09 <SamB> norpan: what?
05:35:17 <SamB> sure you can!
05:35:28 <dons> oh that's just scary,Stinger_
05:35:34 <SamB> you just have to foreign import it!
05:35:35 <ozone> oh dear lord, this may actually be funny
05:35:43 <ozone> oh, that's boring
05:35:44 <SamB> and then:
05:35:54 <ozone> dons: soooo... do you know anything about popen() and bidirectional unix pipes?
05:35:58 <SamB> filter isPrime [1..] :: [Integer]
05:36:07 <norpan> bah
05:36:09 <dons> ozone, yeah sure. want some code?
05:36:09 <SamB> or something...
05:36:16 <SamB> no wait, you probably can't do that...
05:36:21 <SamB> filter isPrime [1..] :: [Int]
05:36:26 <Syzygy-> SamB: What algorithm does your isPrime use?
05:36:46 <ozone> dons: heh, does it involve lots of fork()s and dup2()s?
05:36:53 <dons> not a lot, but some.
05:37:00 <SamB> Syzygy-: I was assuming it was foreign imported from some other language, as norpan said it couldn't be written in Haskell ;-)
05:37:02 <dons> let me find you the code, its simple.
05:37:06 <Syzygy-> Ah.
05:37:15 <SamB> so it must use some super-crazy imperative algorithm!
05:37:28 <ozone> dons: thanks
05:37:40 <dons> ozone: look for 'popen' here, http://www.cse.unsw.edu.au/~dons/code/hmp3/Utils.hs
05:37:42 <lambdabot> http://tinyurl.com/y66pbf
05:37:44 <Syzygy-> Can't you implement, like, the sieve of Erastothenes rather decently in haskell?
05:37:45 <ozone> i have an APUE example here, but i am being stubborn and refuse to bow down to shitty unix apis
05:37:52 <SamB> of course, if you want a *real* infinite list, you'll have to come up with a way to martial infinitely big numbers!
05:37:59 <SamB> er.
05:38:01 <SamB> marshall
05:38:14 <dons> ozone: you basically open up all the pipes, and close one end of each, so one becomes a read pipe, and another a write pipe
05:40:53 <ozone> dons: yep, seems the same as all the other solutions i've found
05:41:18 <ozone> i really wanted to avoid fork() and dup2() as much as possible, but o well
05:57:48 * shapr boings
05:58:09 * Lemmih flops
05:58:17 <Lemmih> How's life, shapr?
05:58:26 <shapr> Life is good.
05:58:40 <shapr> I have paying Haskell work and my girlfriend is coming to visit me on Tuesday.
05:58:47 <shapr> How's life for you?
05:58:54 <shapr> And I'm about to go take my driver's test to get a license.
06:00:34 <Lemmih> Pretty good as well. Have lots of Haskell work.
06:07:19 <shapr> Are there examples of UDP network servers around?
06:08:35 <ValarQ> @pl \f -> map (id &&& f)
06:08:36 <lambdabot> map . (id &&&)
06:10:06 <roconnor> @djinn (Either a (b,c)) -> (Either a b,c)
06:10:06 <lambdabot> -- f cannot be realized.
06:10:55 <roconnor> > False <= True
06:10:56 <lambdabot>  True
06:11:24 <roconnor> @scheck (\a b c -> (a || (b && c)) <= ((a || b) && c))
06:11:25 <lambdabot>   Failed test no. 2. Test values follow.: True, True, False
06:11:52 <arjanoosting> does anyone know if there will be a new release of Happy soon, there are quite a lot of changes since 1.15 in the darcs archive it seems
06:13:12 <Igloo> Soon, yes
06:13:18 <roconnor> <= is a funny looking implies arrow
06:13:23 <roconnor> it points the wrong way
06:13:52 <roconnor> @scheck (\a b c -> (a || (b && c)) ==> ((a || b) && c))
06:13:53 <lambdabot>   Failed test no. 2. Test values follow.: True, True, False
06:13:58 <Igloo> It also gives the wrong answers
06:14:06 <roconnor> It does?
06:14:08 <arjanoosting> Igloo: you wait with uploading a new .deb until a new version is released?
06:14:46 <roconnor> <= is one possible implemenation of ==>
06:15:13 <roconnor> maybe ==> does mre
06:15:15 <roconnor> more
06:15:31 <vincenz> @scheck (\a b c -> ((a || (b && c)) ==> ((a || b) && c)) == ((a || (b && c)) <= ((a || b) && c)))
06:15:31 <lambdabot>  Couldn't match `Property' against `Bool'
06:15:33 <Igloo> arjanoosting: Haven't really thought about it yet. I'm expecting mips and mipsel ghc6 packages to finish building today, so I'll probably look at other things tonight
06:16:42 * arjanoosting is just going through all the FTBFS with ghc6 6.6 bugs and this one is fixed in the darcs archive already
06:17:17 <shapr> FTBFS == Fix The Build For Sid?
06:17:22 <Igloo> From Source
06:17:34 <Igloo> Fails To Build From Source
06:18:40 <SamB> Igloo: aren't those about the same thing?
06:19:12 <arjanoosting> If we could fix the bug by just upgrading to a new upstream version (or darcs snapshot) that would be easiest I think
06:20:27 <Igloo> New upstream version would be better; I'll try to investigate tonight
06:23:13 <arjanoosting> Igloo: ok
06:30:12 <vincenz> what is "upstream"?
06:30:45 <Igloo> Where Debian gets the software it packages from
06:31:33 <SamB> upstream is anywhere you get new versions from
06:32:12 <SamB> (or could get new versions from, if there were any)
06:32:25 <roconnor> @scheck (\a b c -> min a (max b c) == min (max a b) c::Integer)
06:32:25 <lambdabot>  Couldn't match `Integer' against `Bool'
06:32:31 <roconnor> @scheck (\a b c -> min a (max b c) == min (max a b) (c::Integer))
06:32:31 <lambdabot>  add an instance declaration for (Serial Integer)
06:32:31 <lambdabot>   In the definition of `...
06:32:36 <roconnor> @scheck (\a b c -> min a (max b c) == min (max a b) (c::Int))
06:32:37 <lambdabot>   Failed test no. 12. Test values follow.: -1, 0, 0
06:32:49 <SamB> roconnor: see my mail?
06:41:01 <ndm> woohoo! I just beat GHC on one of the Nofib benchmark tests!
06:41:38 <marcot> Hello.
06:41:41 <norpan> ndm: calculating the result in your head?
06:41:55 <ndm> norpan: running it on my desktop machine
06:42:17 <norpan> "it" being what? yhc?
06:42:54 <marcot> I've used gtk2hs with glade support some time ago, and I remember that it wasn't possible to set the signals in the glade interface.
06:43:04 <marcot> Is that right? Do I have to set it in the code?
06:43:20 <ndm> norpan: kind of, yes yhc with my optimising back end
06:44:36 <ndm> and disclaimer, only about 5% faster
06:44:50 <SamB> ndm: which one?
06:44:52 <ndm> but GHC is doing short-cut deforestation on this example, and mine isn't doing any fusion
06:44:55 <ndm> SamB, Primes
06:44:58 <SamB> oh
06:45:06 * SamB looks at his results
06:45:34 <ndm> SamB, http://darcs.haskell.org/yhc/tests/nofib/imaginary/primes/Main.hs
06:45:37 <lambdabot> http://tinyurl.com/ymvoyh
06:45:52 <ndm> and GHC 6.4.2, i should add as well, to be fair
06:46:08 <SamB> thats nice of you ;-)
06:46:09 <Igloo> ndm: Are you saying deforestatino is making it slower, OAIC?
06:46:36 <ndm> Igloo: oh no, deforestation doubles the speed of GHC, i'm saying that even with deforestation i just beat GHC
06:46:43 <Igloo> Ah
06:46:50 <ndm> disabling deforestation i'm twice as fast as GHC
06:46:51 <SamB> Igel: I bet it is the shifts!
06:46:57 <SamB> er.
06:46:58 <SamB> Igloo:
06:46:59 * Igloo files a priority critical bug: Yhc is faster!
06:47:08 <Igloo> SamB: :-)
06:47:09 <SamB> hehe
06:47:21 <ndm> thats with ghc -O2 -fvia-C
06:47:30 <SamB> or something involving inadequate inlining of things casing over primitive comparisons
06:47:39 <ndm> I will upgrade to 6.6 shortly, and see if i'm still faster
06:47:44 <SamB> see my benchmark results ;-)
06:49:50 <SamB> http://thread.gmane.org/gmane.comp.lang.haskell.cvs.ghc/17327/focus=17327
06:49:53 <lambdabot> Title: Gmane Loom, http://tinyurl.com/y4eqor
06:51:40 <arjanoosting> Igloo: could you upload libghc6-html-dev, libghc6-quichcheck etc to haskell-experimental?
06:51:42 <roconnor> SamB, so how did you change the inliner?
06:52:20 <Igloo> arjanoosting: What what arch?
06:52:38 <Igloo> Hmm, my brain really hasn't woken up today
06:52:47 <arjanoosting> i386 if possible?
06:55:13 <sjanssen> ndm: you can disable shortcut fusion?
06:56:33 <Igloo> arjanoosting: Hmm, not easily ATM
06:57:10 <arjanoosting> else the source package would do, I can build i386 from that
06:57:12 <Igloo> arjanoosting, CosmicRay: http://urchin.earth.li/~ian/new/ is everything I uploaded to NEW (source + amd64 packages)
06:57:14 <lambdabot> Title: Index of /~ian/new
06:57:36 <Igloo> (or it still be in a few mins; not all the bin debs are there yet)
06:57:37 <arjanoosting> Igloo: thanks
06:58:14 <Igloo> (I think it's even aptable, by coincidence)
06:58:50 <CosmicRay> Igloo: perfect
07:00:07 <Syzygy-> Is there some reason why > all (\(i,j) -> i==j) (zip [1..] xs) -- would be better to use than > xs == [1..(length xs)] ?
07:00:08 <Igloo> All there now
07:00:15 <CosmicRay> arjanoosting: got a few minutes to talk about haskell-devscripts?
07:00:24 <CosmicRay> arjanoosting: congrats on becoming a dd, btw
07:00:37 <CosmicRay> arjanoosting: now you will get full access to all the private debian flames, too ;-)
07:01:01 <arjanoosting> CosmicRay: sure
07:01:07 <arjanoosting> and thanks!
07:01:19 <Igloo> All the fun of your favourite public flames, but 30 degrees hotter!
07:01:54 * tmoertel needs espresso
07:02:27 <CosmicRay> arjanoosting: ok.  first off, you had asked why things were split up into separate binaries....
07:02:40 <CosmicRay> arjanoosting: the reason is that having only a single binary is not very flexible and not really very policy-compliant
07:02:50 <CosmicRay> arjanoosting: since it actually requires the build to occur in the install target.
07:02:54 <Igloo> Which things, OOI?
07:03:00 <CosmicRay> arjanoosting: it works, but it is not great
07:03:53 <arjanoosting> I noticed that everything gets build in the binary targets instead of in build
07:03:56 <CosmicRay> Igloo: there is now dh_haskell_{prep,build,install}
07:04:18 <CosmicRay> _prep defines the substvars that are used in control
07:04:21 <CosmicRay> _build does the build
07:04:24 <CosmicRay> _install does the install
07:04:51 <CosmicRay> dh_haskell does all of the above, in that order
07:05:13 <arjanoosting> i would like to generate the substvars after the install so dependencies on other libghc6 packages can be correctly generated
07:05:29 <CosmicRay> arjanoosting: so anyway, would you like to adopt haskell-devscripts?
07:05:38 <arjanoosting> I am already doing that with my own mk-haskell-depends shell script
07:05:44 <CosmicRay> arjanoosting: don't you know that from the cabal file, or you're going to do it automatically?
07:05:45 <CosmicRay> cool
07:05:55 <arjanoosting> From the installed cabal file
07:06:23 <Igloo> For dependencies we should really be generatign exact binary package deps due to cross-module inlining
07:06:31 <Igloo> But special-casing ghc6
07:07:04 <Igloo> (my debs don't do any of that yet, but I'm aiming to have it working for the next upload)
07:08:39 <arjanoosting> Igloo you mean like libghc6-html-dev (=1.1-1) instead of libghc-htlm-dev (>=1.1-1) , libghc6-html-dev (<<1.1+)
07:08:41 <CosmicRay> Igloo: well, if each libghc-*-dev has exact enough deps, it doesn't matter which version is used to build a package, right?
07:08:54 <Igloo> Yes
07:09:01 <CosmicRay> arjanoosting: I don't think that even that latter one is necessary
07:09:15 <CosmicRay> I've used libghc6-missingh-dev (>= 0.14.0) for ages in a number of my packages, and it works fine
07:09:29 <Igloo> arjanoosting: The problem is that if you change the code to fix a bug in libghc6-html-dev then it can all go wrong if some of the old code got cross-moule-inlined
07:09:48 <arjanoosting> CosmicRay: ^
07:10:09 <CosmicRay> Igloo: hrm, so I guess this would only be a problem for library packages, not binary packages, then?
07:10:15 <Igloo> Yes
07:10:20 <Igloo> Binary packages don't need any deps
07:10:36 <CosmicRay> oh, I thought we were talking build-deps here.
07:10:44 <CosmicRay> suddenly the whole conversation makes more sense ;-)
07:10:50 <arjanoosting> CosmicRay: build-deps are fine of course
07:10:50 <Igloo> No, build-deps can be as loose as you like
07:11:07 <arjanoosting> I am currently using this script https://moonshine.dnsalias.org/svn/arjan-public/debian/uulib/trunk/debian/mk-haskell-depends
07:11:09 <lambdabot> http://tinyurl.com/yfkwee
07:11:10 <CosmicRay> arjanoosting: so you have something that will automatically generate these deps, eh?
07:12:51 * Igloo plans to make update-haskell-control cleverer in the next release, add a build-time tool for the binary deps and then update all the extralibs
07:13:08 <arjanoosting> Igloo: but if I understand it correctly I should generate strict dependencies (=) in my dependency() function
07:13:53 * arjanoosting plans to add proper dependency generation to haskell-devscripts 
07:13:54 <Igloo> arjanoosting: Yes, except for ghc6 where you should generate deps as /usr/lib/haskell-utils/ghc6_vars describes
07:14:23 <arjanoosting> Hmm, why the special case for ghc6?
07:14:34 <Igloo> The idea being I'll be careful not to change the libraries within a ghc6 release, and we therefore avoid having to rebuild /everything/ whenever it is updated
07:15:00 <arjanoosting> so if it breaks we can kick you ;-p
07:15:12 <Igloo> Exactly!
07:16:46 <Igloo> I haven't got a concrete plan, but I intend to do something like: If a cabal library is provided by a package and /usr/lib/haskell-utils/$package_vars exists then generate the dep from it, otherwise generate an exact dep
07:17:33 <arjanoosting> Igloo: It seems silly to add the dependency generation to haskell-utils and haskell-devscripts, one implementation should suffice
07:18:16 <arjanoosting> Igloo: I was thinking the same thing
07:18:41 <gds> Igloo: Is the standard route for getting the latest ghc on debian-stable to use the generic binary package from haskell.org ?
07:19:11 <Igloo> gds: That's probably the easiest ATM
07:19:19 <gds> Igloo: Cool, cheers :)
07:19:27 <arjanoosting> But if inlining could break stuff that easily, strict dependecies should be the way to go I think
07:19:50 <Igloo> arjanoosting: DYM you think ghc6 deps shoudl be strict too?
07:20:10 <arjanoosting> dunno
07:20:23 * Igloo doesn't mind what people do with haskell-devscripts, but I intend to add what I need to haskell-utils
07:20:31 <arjanoosting> hehe
07:21:15 <Igloo> I also want to add magic vars like ${cabal:deps} which causes the .cabal file to be parsed etc, so I'm going to have to think about exactly what is best at some point
07:21:32 <Igloo> (syntax-wise)
07:22:09 <CosmicRay> Igloo: that would be slick.  I've been thinking lately about an automated cabal-to-debian tool, and I think the linspire folks are actually thinking along the same lines
07:22:57 * arjanoosting currently uses the file used by pkg-config, grep the depends from that file and use ghc-pkg and dpkg -S to determine the corresponding debian packages
07:23:09 <Igloo> The real problem with automated tools is we want to mangle the descriptions
07:23:30 <ndm> sjanssen: rewriting functions like iterate/map as iterate2/map2 which don't have teh shortcut annotations
07:23:52 <arjanoosting> s/pkg-config/ghc-pkg/
07:23:54 <CosmicRay> arjanoosting: so anyway, your patches to haskell-devscripts are in my darcs repo.  I could just build a new release now, but you're welcome to adopt it if you want since it sounds like you're going to be doing more work on it than I am
07:24:00 <CosmicRay> arjanoosting: what do you prefer?
07:24:01 <sjanssen> ndm: ah, okay
07:24:16 <Igloo> Currently my debian/rules, prem and postinst are all identical for all packages
07:24:41 <Igloo> And e.g. updating them to all build hugs packages should just be a matter of copying updated files int all the packages
07:25:28 <arjanoosting> CosmicRay: maybe you could release with the current patches, then I will read up on perl and adopt it
07:25:47 <CosmicRay> arjanoosting: OK.
07:27:43 * arjanoosting 's current priority is fixing all the FTBFS  so when can release etch with ghc 6.6 
07:27:50 <CosmicRay> Igloo: with haskell-devscripts, supporting hugs just means adding a hugs clause to the control file
07:28:45 <Igloo> Yeah, that's inevitably the time-consuming bit
07:29:37 <CosmicRay> arjanoosting: if you are interested in hsffig or lhs2tex as well, you're welcome to 'em ;-)
07:30:16 * arjanoosting wonders why everyone is throwing packages  at him
07:31:08 <arjanoosting> I would take lhs2tex if you don't have the time for it anymore
07:31:49 <Igloo> We're giving you gifts to celebrate you becoming a DD!
07:32:02 <arjanoosting> lol
07:33:27 <roconnor> @scheck (\a b c -> max (min a b) (c::Int) <= max a (min b c))
07:33:28 <lambdabot>   Failed test no. 2. Test values follow.: -1, -1, 0
07:34:48 <CosmicRay> arjanoosting: in all seriousness, it's because you do a good job with packaging haskell stuff, and you are in some cases more interested in my packages than I am ;-)
07:35:15 <SamB_XP> roconnor: what in the world?
07:35:24 <SamB_XP> why would that be true?
07:36:02 <arjanoosting> CosmicRay: thanks, I will take lhs2tex, and take a look at hsffig
07:36:10 <roconnor> @scheck (\a b c -> min a (max b c) <= min (max a b) (c::Integer))
07:36:11 <lambdabot>  add an instance declaration for (Serial Integer)
07:36:11 <lambdabot>   In the definition of `...
07:36:16 <CosmicRay> arjanoosting: sounds good.  I will get to work on the others.
07:36:17 <roconnor> @scheck (\a b c -> min a (max b c) <= min (max a b) (c::Int))
07:36:18 <lambdabot>   Failed test no. 111. Test values follow.: 0, 0, -1
07:36:28 <CosmicRay> I packaged up hsffig because I thought I would need it, but found hsc2hs easier.
07:36:33 <CosmicRay> so I have never even used it.
07:36:49 * arjanoosting neither
07:37:00 <roconnor> oh maybe I have it backwards
07:37:06 <arjanoosting> :-D
07:37:16 <roconnor> @scheck (\a b c -> min a (max b c) <= max (min a b) (c::Int))
07:37:17 <lambdabot>  Completed 1000 test(s) without failure.
07:37:21 <roconnor> there it is
07:37:30 <CosmicRay> Igloo: why does http://packages.qa.debian.org/g/ghc6.html say "not touching package, as requested by vorlon"?
07:37:32 <lambdabot> Title: Overview of ghc6 source package
07:38:05 <Igloo> He wants to wait until (most of) the FTBFSs are sorted out
07:38:29 <kosmikus> arjanoosting, CosmicRay: is lhs2tex-1.11 in debian by now?
07:38:31 <roconnor> @scheck (\a b c -> min a (max b c) == max (min a b) (c::Int))
07:38:32 <lambdabot>   Failed test no. 2. Test values follow.: -1, -1, 0
07:39:02 <arjanoosting> kosmikus: will do a upload tonight
07:39:17 <kosmikus> arjanoosting: nice, thanks
07:39:52 <CosmicRay> kosmikus: no, but arjanoosting is going to take it over
07:48:25 <mcgruff> Could anyone tell me which is a better starter to thorough book -- "The Haskell School of Expression: Learning Functional Programming through Multimedia" or "Haskell: The Craft of Functional Programming"?
07:51:22 <ibid> mcgruff: depends on if you want eye candy or just plain old programming
07:51:34 <ibid> (they are both very good, mind)
07:51:48 <roconnor> @scheck (\a b c -> (a || (b && c)) => ((a || b) && c))
07:51:49 <lambdabot>  Parse error
07:51:58 <roconnor> @scheck (\a b c -> (a || (b && c)) => ((a || b) && c)))
07:51:58 <lambdabot>  Parse error
07:52:04 <mcgruff> ibid: the multimedia book being the eye candy?
07:52:10 <roconnor> @scheck (\a b c -> (a || (b && c)) >= ((a || b) && c))
07:52:10 <lambdabot>  Completed 8 test(s) without failure.
07:52:21 <ibid> mcgruff: yes
07:52:22 <ropine> I used the "School of Expression" book and generally liked it--the only problem was option-wrestling with Hugs until it noticed the SOEGraphics library
07:55:04 <mcgruff> ibid: but it still covers the language thoroughly?
07:56:04 <ropine> yes
07:58:51 <ibid> mcgruff: both cover it well enough. both leave significant gaps for the "de facto standard" haskell (beyond h98)
07:59:58 <mcgruff> is there a book that provides better coverage?
08:00:57 <sehute> an atlas
08:01:03 <sehute> :P ;)
08:02:40 <ibid> mcgruff: not that i am aware of
08:02:54 <ibid> mcgruff: as an aside, do you know C?
08:03:32 <mcgruff> yes
08:03:44 <mcgruff> but i'm coming from a ruby background
08:03:59 <ibid> do you know standard C?
08:04:25 <mcgruff> ibid: yes
08:05:54 <ibid> mcgruff: you know how standard C is very restrictive, and for most real programs you need to go beyond it, yet most C books restrict themselves to standard C only?
08:07:26 <mcgruff> ibid: *nod*
08:07:54 <ibid> mcgruff: the situation is somewhat analogous
08:08:00 <ndm> hmm, i program in standard Haskell 98 all day long
08:08:18 <ndm> i've written compilers, search engines, tools a plenty, libaries
08:08:19 <ibid> h98 is more useful than ansi c :)
08:08:33 <ndm> h98 is a perfectly useful language, unless you're a type theorist
08:08:49 <vegai> ndm: and who isn't?
08:08:57 <ibid> ndm: and if you are willing to reinvent the libraries
08:09:01 <ndm> vegai: me! (but yes, thats about it)
08:09:06 <ndm> ibid: "reinvent" ?
08:09:15 <vegai> me neither ;)
08:09:39 <ibid> mcgruff: but still, there is a lot of useful stuff in the quasi-standard haskell (some of which is being standardised as haskell') that h98 does not provide
08:09:49 <ibid> ndm: well, rewrite
08:09:59 <ibid> (or steal)
08:10:06 <ndm> ? not sure what you mean?
08:10:18 <ndm> i realise that you need haskell.org libraries
08:10:28 <ndm> but the h98 language is plenty sufficient + heirarchical modules
08:10:38 <ibid> ndm: they are not h98, and some of it isn't even writable in h98
08:11:09 <ndm> ibid: i consider them h98, and the majority is, certainly all the bits i use
08:11:14 <ibid> mcgruff: mostly in the libraries, but there are also some language extensions that many people find useful
08:11:28 <SamB_XP> ndm: he means there are a lot of libraries that you need to borrow from C or write equivalents for..
08:11:42 <ibid> ndm: when i say "they are not h98", i mean that they are not specified in the h98 report
08:11:53 <ndm> SamB_XP: does he? surely h98++ needs to as well
08:11:56 <SamB_XP> which means you also need FFI at lesat
08:12:13 <SamB_XP> er, at least
08:12:16 <ndm> ibid: yes, fair point - i meant h98 the language, not h98 the libraries (which are separate)
08:12:29 <mcgruff> ibid: i think i just need to feel comfortable in the functional style first, then i'll worry about libraries and such
08:12:30 <ibid> ndm: they used to be separate, nowadays they are the same report
08:12:32 <ndm> FFI and heirachical modules are H98 adendums, so you can view them as h98 reasonaby
08:12:47 <ibid> mcgruff: yeah, the books are plenty good for a year or two :)
08:12:51 <SamB_XP> sortof, yeah ;-)
08:12:54 <ndm> ibid: but realistically, they are separate logical entities
08:13:01 <ndm> in my mind at least :)
08:13:14 <SamB_XP> ndm: yeah, they are
08:13:18 <SamB_XP> excepting the Prelude
08:13:27 <ibid> ndm: sure, from a language lawyer (which i am) POV, but from a programmer POV, not so much
08:13:41 <SamB_XP> sure they are!
08:14:01 <ndm> ibid: i would have thought haskell makes a beautiful separation between language and library, much better than other languages, from my programmer POV
08:14:01 <mcgruff> ibid: thanks much
08:14:03 <SamB_XP> there is no standard for the libraries that are actually being used, afaict
08:14:11 <ndm> there never will be
08:14:23 <SamB_XP> yeah. I suppose the only standard is the repo ;-)
08:14:26 <SamB_XP> which makes sense really
08:14:58 <SamB_XP> (the repo, and the spec for the core library as reinterpreted into the heirarchy...)
08:17:53 <ibid> ndm: btw, the hierarchical libs themselves are not addenda to h98, only the dotted-module-name syntax extension is
08:18:46 <ibid> ndm: it is my understanding that haskell' will standardize some of the hierarchical libs
08:18:48 <SamB_XP> ibid: he just indicated that he knows this and believes they never will be specified in the Report ;-)
08:19:06 <ibid> SamB_XP: yeah, noticed later (i'm cooking at the same time:)
08:19:11 <SamB_XP> ah ;-)
08:20:35 <SamB_XP> I do not see how they could avoid at least specifying the parts of the modules that were taken from the H98 modules, though
08:21:16 <ibid> that, of course
08:22:26 <SamB_XP> but I think it would be sane to use most of the library as its own spec...
08:22:33 <ndm> i think they'll punt entirely on the standardisation of libraries, personally, since whatever they do will be wrong the second they do it
08:22:39 <SamB_XP> with a good policy for changes, anyway...
08:23:27 <SamB_XP> ndm: I think they will just say things about the functions, classes, instances, and types that were taken from H98
08:23:31 <SamB_XP> and maybe a few more
08:23:50 <SamB_XP> like UTF-8 I/O, binary I/O...
08:23:53 <ndm> SamB_XP: and be wrong the second they do it?
08:23:57 <astrolabe> what is a thunk?
08:24:20 <SamB_XP> ndm: are we planning on breaking the spec on day 2?
08:24:25 <SamB_XP> why wait until day 2?
08:24:29 <astrolabe> aka 'unevaluated closure'
08:24:29 <SamB_XP> why not break it day 1?
08:24:43 <ndm> SamB_XP: "second", as in 1/60th of a minute
08:25:00 <ndm> astrolabe: an unevaluated function, i.e. "map head" - not enough arguments to evaluate, so a thank
08:25:00 <SamB_XP> oh, oops
08:25:01 <SamB_XP> hehe
08:25:05 <SamB_XP> anyway
08:25:12 <SamB_XP> I know they will punt on most of the libs
08:25:38 <SamB_XP> but they should at least carry over the parts from H98, only in their new locations
08:25:43 <ndm> i'd love them to take a shot, then i could start ranting about GHC only libraries :)
08:25:57 <SamB_XP> and probably they will mention the URL of the library repository...
08:26:03 <ndm> and really evil decisions taken in base entirely because of laziness and not caring about anything other than GHC
08:26:10 <SamB_XP> perhaps they will even endorse the use of cpp after all this time ;-)
08:26:25 <SamB_XP> ndm: oh?
08:26:26 <ndm> no! cpp is evil
08:26:51 <SamB_XP> cpp is better than having a ton of different repos with different base libraries in them!
08:26:57 <Igloo> ndm: What decisions?
08:27:06 <ndm> SamB_XP: there is on System.Posix.* module in base, not Posix, because GHC needs it in bootstrapping
08:27:08 <ibid> ndm: http://hackage.haskell.org/trac/haskell-prime/wiki/NewLibraryCandidates
08:27:12 <lambdabot> Title: NewLibraryCandidates - Haskell Prime - Trac, http://tinyurl.com/ycqrzc
08:27:13 <SamB_XP> ndm: yeah.
08:27:23 <ndm> plus it has an empty interface on windows, so is stupid broken and can't be fixed easily!
08:27:30 <SamB_XP> mmm
08:27:40 <Igloo> GHC needing it for bootstrapping is irrelevant
08:27:44 <ndm> Igloo: plus the normalise directory thingy is "return x" on Hugs, but properly implemented in GHC
08:27:47 <SamB_XP> Igloo: I don't think so!
08:27:57 <ndm> Igloo: i asked, and ranted, and was given that as the reason for it being put there...
08:28:19 <Igloo> It is. There are a number of libraries GHC needs for bootstrapping; adding a posix library to the list shouldn't cause problems
08:28:33 <SamB_XP> Igloo: well.
08:28:43 <ndm> true, its a bad reason, but it looks like it was done "as a quick hack" which has infected the base libraries
08:28:46 <SamB_XP> maybe ndm meant that GHC's core depends on it
08:28:56 <SamB_XP> that is, the GHC.*
08:28:57 <SamB_XP> modules
08:29:18 <Igloo> Ah, possibly. That's something that's on my list to untangle
08:29:30 <ndm> but the normalisePath thing, thats GHC only because the person implementing it couldn't be bothered to test it on Hugs, that really annoys me!
08:29:42 <Igloo> Isn't that aLinux-only thing rather than GHC-only, though?
08:29:58 <Igloo> (System.Posix, not normalisePath)
08:30:13 <ndm> true, but it shouldn't be in base, it should be in posix
08:30:16 <SamB_XP> ndm: I really think the use of CPP to distinguish between compilers should be allowed...
08:30:34 <ndm> SamB_XP: i'd rather it stayed "used", rather than "allowed"
08:31:00 <ndm> and its just unforgivable to change the export list from a module based on preprocessor decisions!
08:31:04 <Igloo> But pulling it out to something that needs to depend on base would require code duplication (for all impls)
08:31:16 <ndm> ?
08:31:27 <ndm> GHC depends on System.Posix.Signals
08:31:29 <SamB_XP> ndm: yeah, it is...
08:31:33 <ndm> System.Posix.Signals is in base
08:31:47 <ndm> System.Posix.Signals has a different interface on Windows vs Linux
08:32:11 <ndm> i follow that as a mathematical argument for a kneecapping :)
08:32:29 * roconnor likes state monad.
08:32:33 <SamB_XP> roconnor: good ;-)
08:33:04 <roconnor> the generic state monad isn't haskell 98 is it?
08:33:13 <SamB_XP> nope!
08:33:22 <ndm> it is, i think, just not with monad transformers
08:33:25 <SamB_XP> fundeps and MPTCs
08:33:30 <ndm> or rather, could be written in Haskell 98
08:33:46 <SamB_XP> yeah
08:33:49 <roconnor> well MoandState or whatever it is called is a MPTC
08:33:57 <SamB_XP> yeah, MonadState
08:34:01 <roconnor> could you really do it in haskell 98?
08:34:04 <ndm> yes
08:34:05 <SamB_XP> no
08:34:10 <roconnor> I mean you could do it for each instance.
08:34:13 <ndm> as long as you don't want the monad transformer stuff
08:34:16 <SamB_XP> yes
08:34:18 <roconnor> but that would suck.
08:34:20 <SamB_XP> but
08:34:26 <ndm> just the put/get basic level
08:34:35 <SamB_XP> you couldn't really use the StateT at all that way...
08:35:06 <roconnor> is there a ListT  monad transfomer?
08:35:25 <SamB_XP> @google ListT site:haskell.org/haskellwiki
08:35:30 <lambdabot> http://www.haskell.org/haskellwiki/NewMonads/MonadBase
08:35:30 <lambdabot> Title: New monads/MonadBase - HaskellWiki
08:35:58 <SamB_XP> @hoogle ListT
08:35:59 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
08:35:59 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
08:35:59 <lambdabot> Language.Haskell.TH.ListT :: Type
08:36:06 <SamB_XP> there is, actually!
08:36:13 * SamB_XP was thinking it wasn't in the library
08:37:00 <roconnor> Ah so I can build my non-deterministic state monad out of parts, if I get them in the right order.
08:37:13 <SamB_XP> ooh, I like this MonadBase idea...
08:37:50 <SamB_XP> but, I think it should have a fundep...
08:39:15 <SamB_XP> or maybe wait until the MTL is ported to use ATs...
08:40:03 * SamB_XP wonders what a reasonable mass for a car is
08:41:10 <ValarQ> reasonable for what?
08:41:38 <SamB_XP> reasonable for a take-home part of a physics exam, actually
08:42:05 <SamB_XP> but I'm pretty sure this part isn't the part where I'm not supposed to talk to others ;-)
08:42:17 <roconnor> @google mass of car in kilograms
08:42:17 <lambdabot> http://hypertextbook.com/facts/2000/YanaZorina.shtml
08:42:17 <lambdabot> Title: Mass of a Car
08:51:28 <vincenz> @google mass of star in kilograms
08:51:31 <lambdabot> http://www.einsteinyear.org/facts/physicsFacts
08:51:32 <lambdabot> Title: - Did you know?
08:54:23 <dcoutts_> @seen dons
08:54:23 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 3h 16m 8s ago.
08:54:57 <dcoutts_> anyone know how to insert line wrapping points in latex in an inline formula
08:55:31 <edwinb> I usually do that sort of thing with arrays...
08:55:48 <dcoutts_> I've got "<longish thing> = thing = <longish thing>" and it's ok to line wrap at the '='
08:55:58 <d> hi
08:56:08 <ValarQ> hello d
08:56:09 <edwinb> dcoutts_: yes, best to put it all in an array environment I think
08:56:13 <edwinb> then line breaks work
08:56:15 <dcoutts_> edwinb, it's not that significant a thing that it deserves to be a display mode thing
08:56:23 <edwinb> hmm
08:56:46 <dcoutts_> maybe I can just \< thing = \> \< thing\>
08:56:51 <edwinb> might need to exit math mode then...
08:56:53 <dcoutts_> ie break out of the math mode
08:56:55 <dcoutts_> right
08:56:58 * dcoutts_ tries that
08:58:09 <d> i couldn't think of any better place to ask, so here goes - does saying "professor at some university" in a CV imply the actual professor title, or just being a lecturer there ?
08:58:19 <edwinb> which university?
08:58:25 <d> whichever
08:58:26 <edwinb> At a UK university, yes
08:58:31 <d> ah
08:58:35 <edwinb> but not elsewhere
08:58:49 <d> well i'm translating from polish to english
08:59:04 <d> it's for a british company
08:59:25 <Igloo> I would say lecturer
08:59:36 <gds> dcoutts_: I've been using eqnarray* for hoare triples - three lines in one formula...
08:59:39 <d> mhm
09:02:39 <d> ok, i guess i'll stick with "lecturer" unless anyone knows a more fancy name for a Ph.D. teaching students and doing some research of their own ;]
09:04:32 <Stinger_> exploited student ;)
09:18:55 <dcoutts_> d, I do that, and I'm called either a PhD student or a teaching assistant
09:24:00 <d> ahm
09:24:29 <Igloo> It sounds like d actually lectures, though, which you don't?
09:25:22 <Igloo> When you say "for a Ph.D. teaching students", do you mean someone studying for a PhD, or someone who already has a PhD?
09:25:35 <d> already has
09:25:38 <d> and teaches
09:25:49 <d> phone, brb
09:26:25 <Igloo> lecturer sounds reasonable then
09:30:38 <d> Igloo yep, I decided on that one as well ;]
09:31:37 <d> ok, thanks guys, i'll be asking about haskell next time ;]
09:31:38 <d> bye
09:33:46 <araujo> Hellu
09:39:52 <br1> hello
09:42:11 <ski> evening
09:44:48 <araujo> :-)
09:46:31 <Pupeno> Is haskell.org down ?
09:47:08 <twanvl> No
09:48:02 <roconnor> ... So is False at the top of the logical lattice, or at the bottom?
09:48:19 <roconnor> maybe this is the wrong channel for this question.
09:49:10 <ndm> roconnor: shouldn't bottom be at the bottom?
09:49:40 <roconnor> I'm used to thinking it is at the top ... which make it kinda confusing.
09:49:55 <roconnor> let see, if /\ is and and \/ is or.
09:50:09 <roconnor> False is the identity for /\
09:50:15 <roconnor> so that places it at the top, right?
09:50:22 <roconnor> er
09:50:25 * roconnor thinks
09:50:53 <roconnor> @wikipedia Bounded lattice
09:50:55 <lambdabot> No Result Found.
09:51:06 <int-e> you can do it either way, but /\ is usually the infimum and it makes sense to place smaller values below larger ones
09:51:41 <int-e> so false would be at the bottom.
09:52:17 <roconnor> int-e: a yes
09:52:20 <roconnor> ok
09:52:30 <roconnor> ugh, I need to flip this in my head
09:52:50 <roconnor> logically stronger statements are lower.
09:53:22 <int-e> statements with fewer models are at the bottom?
09:55:29 <roconnor> ah
09:56:56 <sieni> yes, if you have a bunch of statements (a theory) and you add another statement, the models of the latter are a subset of the models of the former
09:57:16 <roconnor> ... but I still don't like how ==> means <=
09:57:48 <Pupeno> How can you implement a non-purely-functional interpreter on top of Haskell ? How do you 'emulate' mutation ?
09:57:50 <roconnor> well, arguable one is a operation and one is a relation.
09:57:58 <sieni> Pupeno: using monads
09:58:19 <sieni> Pupeno: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
09:58:21 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
09:58:23 <ski> Pupeno : or if you want .. by simple state-passing style
09:58:39 <Pupeno> sieni: Thank you.
09:58:42 <roconnor> ski bleck
09:58:52 <ski> roconnor : sorry ?
09:59:08 * roconnor isn't fond of state-passing.
09:59:23 <Pupeno> roconnor: why not ?
09:59:36 <roconnor> the monad abstraction is so nice ... at least with do syntax.
10:00:11 <roconnor> Pupeno: it's to easy to accidently pass a state twice.
10:00:12 * ski remembers his "aha!"-experience when he discovered one could make a purely functional interpreter of an imperative language
10:01:30 <ski> roconnor : i guess you even less like the tradition to write (forward) implication as 'C', then ..
10:01:50 <ski> (err s/forward/backward/)
10:02:57 <roconnor> ski: well, no, but I'll reconsider it now.
10:03:18 <roconnor> it does fit more nicely with <=
10:03:23 <roconnor> c=
10:03:33 <roconnor> easy to type.
10:04:07 <roconnor> the models of False are indeed a subset of the models of true
10:04:47 <ski> roconnor : it does not
10:04:55 <ski> http://en.wikipedia.org/wiki/Logical_implication#Symbolization
10:04:58 <lambdabot> http://tinyurl.com/van3t
10:06:24 <roconnor> ski why not?
10:06:52 <ski> see last paragraph of the section pointed to by the above link
10:07:09 <ski> it's like reverse set containment
10:07:26 <roconnor> ski: but that is what I said.  False -> True  and False c= True
10:08:19 <amatus> so i'm compiling hugs for sparc64 and this code doesn't look 64-bit safe at all, what gives?
10:08:23 <ski> except that traditional notation i mentioned would have it 'True C False' (or rather, the mirror of that, but i can't render the mirrored 'C' in ascii)
10:08:33 <roconnor> oh
10:08:37 <roconnor> it when that way?
10:08:40 <roconnor> that is really confusing.
10:09:22 <ski> that "horse-shoe" notation is quite old notation, though .. from what i know, it's not used very much nowadays
10:09:28 <ski> (maybe some philosophers ??)
10:09:56 <ski> icbw, but istr it was Peano who invented it
10:13:35 <pejo> amatus, unless you explicitly need a 64 bit adress space you should do fine with a 32 bit binary.
10:13:56 <jmmv> hi
10:14:13 <pejo> (General comment, I have no knowledge of whether Hugs is 64 bit clean or not).
10:17:06 <amatus> pejo, there are places in the code where void* is casted to int (32-bits by my compiler's reckoning)
10:18:45 <amatus> in prelude.h there is a type Int which is typedef'd to int, does anyone know if it's important that Int be == int or == 32-bit or able to hold a pointer or some combination of these properties??
10:19:54 <SamB_XP> the sideways-U subset-of symbol is still in use afaik!
10:20:24 <amatus> i'm going to typedef Int to 64-bits to it can hold a pointer, and try to fix all the havoc that causes
10:20:38 <SamB_XP> amatus: probably it is good if it can hold a pointer...
10:20:50 <SamB_XP> so maybe it should be intptr_t where that is available...
10:20:52 <amatus> er, i should have been more clear, a few places in the code a void* is cast to Int, which is currently 32-bits (typedef'd to int)
10:20:58 <SamB_XP> or whatever the hell they call it...
10:21:40 <SamB_XP> well, at least, when intptr_t has at least as many bits as int...
10:22:24 <amatus> does the Int type in haskell have a specific size? i assume the Int type in the C code is supposed to correspond to the haskell type
10:22:44 <ski> SamB_XP : yes, the subset symbol is still in use .. the question however was if the (similar-looking) symbol for *implication* was still in much use
10:22:53 <SamB_XP> I think int is supposed to be within two bits of the machine word size
10:22:58 <SamB_XP> er, Int rather
10:23:16 <SamB_XP> (that is, it is spec'd to be at least 30 bits)
10:23:28 <amatus> why within two bits? extra bits for carry or something?
10:23:50 <ski> tagging, in some implementations (for GC)
10:23:53 <amatus> ah, so officially it's >= 30 bits?
10:23:57 <SamB_XP> yeah
10:25:03 <SamB_XP> a lot of people assume that they won't be able to store more than that many of whatever type of thing in memory
10:25:14 <SamB_XP> so, I think it should be close to the pointer size...
10:25:57 <SamB_XP> and certainly if hugs is trying to cast things to a C type called Int, that type should be made large enough to hold those things...
10:26:43 <ndm> certainly in Yhc -O Int will be exactly 30 bits :)
10:27:07 <SamB_XP> yeah, two bits is a well respected tag size ;-)
10:27:16 <SamB_XP> and pretty generally useful
10:27:34 <SamB_XP> though I never will understand tagged floats...
10:27:51 <SamB_XP> (how in the world can those be efficient?)
10:28:46 <roconnor> Does the IEEE specify floating bit lengths?
10:28:49 <roconnor> or just rounding.
10:29:00 <SamB_XP> well.
10:29:23 <SamB_XP> it specifies two standardized formats
10:29:43 <SamB_XP> one 32-bit, one 64-bit
10:29:47 <SamB_XP> iirc
10:30:16 <SamB_XP> > sizeOf (1::Float)
10:30:17 <lambdabot>  Not in scope: `sizeOf'
10:31:39 <SamB_XP> but, I don't know what else it defines. because I've not tried to read it.
10:32:33 <SamB_XP> anyway, I think the system I was thinking of (with the 30-bit tagged floats) is Self...
10:35:01 <amatus> woah, what kind of questions can i ask lambdabot?
10:35:19 <Heffalump> lambdabot, can you make the tea?
10:35:25 <amatus> > 1 + 1
10:35:26 <lambdabot>  2
10:35:43 <amatus> does lambdabot know not to spam?
10:35:54 <amatus> like if i asked for [1..1000000]
10:36:12 <Heffalump> > [1..1000000]
10:36:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:36:18 <amatus> cute
10:37:10 <SamB_XP> amatus: what do you take us for? well-behaved people who never try to print infinite lists in the channel?
10:37:29 <SamB_XP> @vixen can you make tea?
10:37:29 <lambdabot> of course i can
10:37:39 <SamB_XP> @vixen can you play smash brothers?
10:37:39 <lambdabot> of course i can
10:37:44 <Heffalump> @vixen make the tea
10:37:44 <lambdabot> tell me more about yourself.
10:37:50 <SamB_XP> hah
10:38:06 <SamB_XP> @vixen I was wondering what it is like to be an IRC bot
10:38:06 <lambdabot> bots should be destroyed. they are so annoying
10:38:09 <SamB_XP> heh
10:38:20 <SamB_XP> @vixen I was wondering what it is like to be an alternative life form
10:38:21 <lambdabot> i like that type of music too
10:38:24 <SamB_XP> haha
10:38:33 <amatus> oh no
10:40:32 <SamB_XP> > 1500 * 30^2
10:40:33 <lambdabot>  1350000
10:41:15 <amatus> > 1500 * 2^30
10:41:17 <lambdabot>  1610612736000
10:41:33 <SamB_XP> that was actually for my physics homework
10:41:51 <sieni> SamB_XP: what? 1500 * 30^2?
10:42:24 <SamB_XP> sieni: yeah
10:42:54 <amatus> Hugs.Int seems to assume that Int == Int32, but i'm not sure
10:43:13 <SamB_XP> oh, well, fix it ;-)
10:43:38 <amatus> it has...
10:43:39 <amatus> instance Bounded Int32 where minBound = intToInt32 minBound maxBound = intToInt32 maxBound
10:43:53 <amatus> hrm... that came out weird
10:43:55 <SamB_XP> ah
10:44:10 <SamB_XP> should probably *not* do that ;-)
10:44:13 <SamB_XP> in any case
10:44:17 <SamB_XP> its not pretty!
10:44:48 <SamB_XP> too bad we have no negative literals...
10:45:19 <SamB_XP> well. I mean. it looks okay. but it is so disconcerting!
10:49:56 <int-e> I'd like to see negative literals. We could get rid of the unary minus then.
10:50:28 <SamB_XP> well. the trouble is people would be wanting to do x-1
10:50:50 <SamB_XP> and how does the lexer know how to lex that?
10:51:03 <int-e> x - 1 vs. x + -1? hmm.
10:51:28 <SamB_XP> so, does it depend on space after the minus, or on what kind of token went before?
10:51:30 <int-e> ok, people also dislike significant whitespace.
10:51:41 <amatus> > maxBound
10:51:42 <lambdabot>  Add a type signature
10:51:49 <amatus> ooo, helpfull
10:51:49 <int-e> > maxBound :: Integer
10:51:50 <lambdabot>  add an instance declaration for (Bounded Integer)
10:51:50 <lambdabot>   In the expression: ma...
10:51:57 <int-e> > maxBound :: Double
10:51:58 <lambdabot>  add an instance declaration for (Bounded Double)
10:51:58 <lambdabot>   In the expression: max...
10:51:59 <ndm> why not just eliminate unary minus totally
10:52:02 <ndm> 0-1 is just as good
10:52:07 <amatus> > maxBound :: Int
10:52:08 <lambdabot>  2147483647
10:52:12 <amatus> > maxBound :: Int32
10:52:13 <lambdabot>  2147483647
10:52:16 <amatus> > maxBound :: Int64
10:52:16 <int-e> ndm: it's inconvenient in lists of literals.
10:52:17 <lambdabot>  9223372036854775807
10:52:28 <SamB_XP> I think people would be much less angsty if it depended on whether the previous token had been a possible end-of-expression token or not...
10:52:51 <ndm> int-e: yes, but i'd rather have a simpler language with less "holes", and give up unary minus - just treat it as --1, which isn't so bad
10:59:50 <amatus> oh man, there are alot of type problems in this hugs
11:00:25 <amatus> there are functions that are defined one place using one type and another place using another... they just happend to be typedef'd to the same thing
11:00:34 <SamB_XP> amatus: eek
11:00:48 <SamB_XP> too bad C doesn't have newtypes :-(
11:00:49 <ndm> amatus: do you mean the source code to Hugs?
11:00:50 <OrangeKid> cya D:
11:00:52 <SamB_XP> ndm: indeed!
11:01:12 <ndm> ah, i know the Hugs source, its horrible - what annoys me most is the indentation
11:01:44 <SamB_XP> ndm: he wanted to 64-bit clean it ;-)
11:01:52 <ndm> lol!
11:01:58 <ndm> much better just to use Yhc :)
11:02:09 <roconnor> SamB_XP: re: too bad C doesn't have newtype.  Time to switch to Modula-3
11:02:10 <SamB_XP> it doesn't support, you know, interaction
11:02:45 <Dreadshoot> anyone uses hs-plugins in win?
11:03:02 <pejo> roconnor, too bad cvsup is the only program ever written in the language!
11:03:40 <SamB_XP> roconnor: does modula-3 support C calling convention? typeclasses?
11:03:54 <roconnor> hmmm
11:04:07 <roconnor> My modula-3 manual is back in Canada.
11:04:09 <SamB_XP> or other overloading mechanism, for that matter?
11:04:38 <roconnor> it has modules :)
11:05:37 <SamB_XP> roconnor: have you seen my mail?
11:06:45 <roconnor> Yeah, I heard things are pretty good.  You made some adjustments to your patch?
11:07:05 <SamB_XP> a little one
11:07:06 <SamB_XP> yeah
11:07:18 <SamB_XP> but it seems to make a huge difference
11:07:32 <amatus> ndm: what is Yhc?
11:07:42 <ndm> @where Yhc -- for amatus
11:07:42 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
11:07:44 <SamB_XP> enough to make me worry that I benchmarked wrong :-(
11:07:56 <SamB_XP> Yhc is yet another Haskell compiler ;-)
11:07:57 <ndm> @where+ Yhc http://www.haskell.org/haskellwiki/Yhc
11:07:57 <lambdabot> Done.
11:08:02 <ndm> amatus: ^^^
11:08:11 <ndm> amatus: a Haskell compiler that is 64 bit clean :)
11:08:11 <SamB_XP> but, it actually stands for York, not Yet another
11:08:30 <amatus> heh, my guess was Yale
11:09:31 <_frederik_> should i call my linear algebra library "vectastic" or "linear awesome"?
11:09:32 <roconnor> SamB_XP: I don't see what you changed.
11:09:32 <ndm> SamB_XP: have you touched the showing of Id's again?
11:09:48 <roconnor> Can't spell awesome without linear.
11:10:06 <_frederik_> by the way, it's nothing to do with linear types
11:10:32 <amatus> _frederik_: lincredable
11:10:32 <SamB_XP> ndm: "again"?
11:10:42 <roconnor> amatus: :)
11:10:48 <roconnor> I like that name
11:10:50 <SamB_XP> I sorta reverted the showing and fixed a couple call sites I could find...
11:10:53 <_frederik_> amatus: that sounds like a linux distribution
11:10:56 <ndm> SamB_XP: since last time it was broken, cause its broken again
11:11:00 <int-e> @spell incredible
11:11:00 <lambdabot> incredible
11:11:07 <SamB_XP> ndm: where is it broken?
11:11:14 <pejo> amatus, Yale has hacked away on Hugs, quite a lot.
11:11:36 <ndm> SamB_XP: its different, all over the place - does strId do something different now from what it used to?
11:11:44 <ndm> pejo: a while ago though, not for ages
11:11:44 <_frederik_> which one of my proposed names is least bad?
11:11:47 <amatus> pejo: i read that history of haskell paper, too bad i can't remember any of it
11:12:02 <amatus> pejo: i was happy to see one of my prof's name in it though
11:12:17 <ndm> SamB_XP: why does strId do more than (show int) did?
11:12:36 <SamB> ndm: isn't that okay?
11:12:38 <amatus> UT CS reprezent!
11:12:51 <xeqi> which one was it?
11:12:51 <ndm> SamB, not really, or at least very not idea
11:12:57 <SamB> ndm: why not?
11:13:08 <ndm> SamB, the things which depend on things being the way they are happen a lot
11:13:33 <SamB> the point of newtyping Id is to make it clearly different from Int...
11:13:43 <ndm> yes, but it needs to do the same thing (for now at least)
11:13:45 <ndm> Primitive.Primitive.Prelude.292.f vId 439 vId 440 =
11:13:47 <ndm> i just got that out
11:13:56 <ndm> with two parameters with the same name...
11:14:07 <SamB> you should document the code that is messed up, so I can see what it is supposed to do!
11:14:32 <SamB> ndm: huh?
11:14:34 <ndm> i have no idea what its supposed to do
11:14:37 <SamB> two params with the same name?
11:14:38 <ndm> from yhc -core
11:14:40 <ndm> yep
11:14:45 <ndm> both as vId
11:14:49 <SamB> eek
11:14:59 <amatus> xeqi: nelson! i didn't see you there!
11:15:17 <SamB> there ought to be an scons target to start hugs...
11:15:20 <SamB> and one to start ghci...
11:15:28 <ndm> SamB, submit a bug report :)
11:16:09 <ndm> SamB, ideally the code should do exactly the same as before, otherwise you risk breaking .hi files etc.
11:16:16 <SamB> oh?
11:16:20 <amatus> xeqi: do you have a job yet?
11:16:33 <ndm> yep, some of the variables will end up in .hi files, i think
11:16:59 <SamB> shouldn't that just mean that the names in existing .hi files will look different from the names in new .hi files?
11:17:10 <ndm> maybe, i'm not sure
11:17:17 <xeqi> amatus: nope, moved to houston and haven't found anything
11:17:22 <ndm> is there any good reason to change the variables from being shown the way they were before?
11:17:35 <SamB> maybe not
11:17:36 <ndm> since its clearly a thorny issue for something in the compiler :)
11:17:57 <ndm> i would love better names throughout, since some are not unique, but i think that needs to be tackled as a whole
11:18:00 <amatus> xeqi: do you think you could help me fix hugs?
11:18:28 <ndm> SamB, i suspect some things may be showing the unwrapped Id
11:18:56 <ndm> which can't be tracked down by the type system...
11:20:29 <SamB> ndm: ee
11:21:03 * SamB really thinks these file formats should be specced and tested if people are expecting them to work
11:21:28 <ndm> they will be :)
11:21:46 <ndm> i have a Yhc -O back end that depends on them, which is why i am always the one who spots breakage
11:21:52 <SamB> ndm: oh. get it.
11:21:55 <SamB> er.
11:21:56 <SamB> I get it.
11:22:08 <SamB> ndm: this -core output comes from where again?
11:22:18 <ndm> SamB, yhc File.hs -core
11:22:25 <br1> how do i invite lambdabot to another channel?
11:22:29 <SamB> no, I mean, what module is pretty-printing?
11:22:43 <ndm> SamB, my module on my computer
11:22:55 <ndm> SamB, not one in the standard suite
11:23:10 <SamB> ndm: no. what module is doing the pretty-printing ....
11:23:10 <gds> br1: I think you have to have lambdabot's trust first. Lots of folk ask dons :)
11:23:18 <ndm> SamB, Yhc.Core.Show
11:23:22 <SamB> okay
11:23:28 <br1> gds: ok
11:23:35 <SamB> I go fix
11:23:42 <gds> br1: But the command is "@join" IIRC ;)
11:23:53 <ndm> thats not what needs fixing, why not just keep with the old showing of id's ?
11:23:58 <ndm> to generate them?
11:24:07 <SamB> um. no.
11:24:19 <ndm> i'm unsure what we gain from showing them in a fancier way, and not as they were done before?
11:24:39 <SamB> because some things derive Show?
11:24:50 <SamB> and I don't want them to look just like Ints there?
11:25:07 <br1> gds: mhh.  join isn't in the comand list here http://www.cse.unsw.edu.au/~dons/code/lambdabot/COMMANDS
11:25:09 <lambdabot> http://tinyurl.com/y429vh
11:25:21 <ndm> well at the very least can we have exactly the same output as before?
11:25:30 <ndm> no reason to break the way things are output already
11:25:34 <amatus> ndm: would you recommend using yhe on sparc64?
11:25:37 <ndm> i realise that we want to abstract over Id's
11:25:44 <ndm> amatus: no, i very much doubt it builds...
11:25:59 <amatus> well, neither does hugs...
11:26:02 <SamB> erg. I could do that...
11:26:19 <amatus> actually.. hugs might, i just got freaked out by the compiler warnings
11:27:06 <ndm> SamB, the output is fragile and no one knows what the compiler depends on.. - i'd rather not risk changing it unless we're going to something clearly better - which i'm not convinced the new show'ing is
11:27:17 <gds> br1: It definitely works for my tame lambdabot - perhaps it's not in the official one's docs because most folk don't have permission to use it?
11:27:20 <SamB> yeah
11:27:28 <SamB> I have to put that back into NT where I got it then...
11:27:54 <br1> gds: ok.  I'll ask dons when I see him.  Thanks.
11:27:59 <gds> np :)
11:28:07 <ndm> hmm, i'd be tempted to keep strTVar in Id
11:28:13 <ndm> since thats where it belongs
11:28:20 <ndm> and perhaps add strIdLambda
11:28:23 <SamB> ndm: oh, whatever
11:28:36 <amatus> @vixen are you tame?
11:28:36 <lambdabot> i truely am
11:28:44 <SamB> but my point was that you don't want me to mess up strTVar ;-)
11:29:14 <SamB> so where do these names get put into the Core* datastructures?
11:29:37 <ndm> oh, i'm not sure about that...
11:30:05 <ndm> probably Core.Core, just checking...
11:30:46 <monochrom> Hey, Core.Core is a great name.  Is there Core.Core.Core too?
11:30:54 <ndm> getName state
11:31:04 <ndm> so whereever the symbol table gets the name from
11:32:12 <gds> br1: http://www.cse.unsw.edu.au/~dons/lambdabot/Config.hs suggests that you could also ask shapr, vincenz, Cale, etc...
11:32:14 <lambdabot> http://tinyurl.com/y683ht
11:32:20 <SamB> oh, well, thats from the case where it isn't in the symbol table already, ndm
11:32:39 <SamB> and I have to wonder how that works if you have variables named, say, "v1"...
11:32:53 <SamB> or "v132"
11:32:53 <amatus> does lambdabot do that whenever someone says a long url?
11:33:15 <ndm> SamB, hmm, unsure - give me a sec, perhaps its best if we do the whole "unique names thing" properly now...
11:33:31 <SamB> it probably is ;-)
11:33:35 <ndm> and eliminate the silly _LAMBDA one
11:33:49 <ndm> (of course, this upsets me as my code depends on it, but might be best for the long term...)
11:33:51 <amatus> @where lambdabot
11:33:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:33:53 <SamB> note that e.g. GHC has a "name" part and a "unique" part
11:34:08 <SamB> though the name part can be semi-unique itself
11:34:14 <ndm> since all Id's are unique
11:34:32 <ndm> why not just v123 for variables, V123 for type constructors?
11:34:43 <SamB> what?
11:34:48 <SamB> that is ugly.
11:34:50 <ndm> I don't see why the cleverness of strTVar is needed
11:34:52 <SamB> not debuggable either.
11:35:01 <SamB> oh, that?
11:35:06 <SamB> I have no idea what that is for.
11:35:13 <ndm> yeah, me neither
11:35:24 <ndm> i think variable names as just numbers is easy to debug, as long as we keep the code abstract
11:35:28 <SamB> except I thought it would do something different for some reason...
11:35:38 <ndm> yeah, thats what scares me...
11:35:41 <roconnor> @spell absorption
11:35:41 <lambdabot> absorption
11:35:46 <SamB> I meant, you won't know what you are looking at
11:35:47 <roconnor> @spell absorbtion
11:35:48 <lambdabot> absorption absolution absorbing abortion absorptions
11:35:50 <ndm> and perhaps _LAMBDAn should be simpler as well, in some similar scheme
11:36:00 <ndm> SamB, oh, you mean you want to differentiate different kinds of things?
11:36:03 <SamB> if you run ghc -fext-core, it outputs code that has sensible names
11:36:04 <roconnor> hmm
11:36:12 <SamB> and not-so-sensible names, too
11:36:14 <ndm> SamB, yes, me dumb, very clever point
11:36:23 <monochrom> The absorption law for abortion: x;abort = abort  :)
11:36:32 <ndm> so you mean like v123, l123, t123, depending on the type
11:36:53 <SamB> no, I mean that things that already have names should keep those
11:37:02 <SamB> (though maybe they'd need something added)
11:37:02 <hygge> hello!
11:37:18 <amatus> hi hygge
11:37:55 <SamB> like, oh, maybe an Id should really be a ByteString and a unique Int together?
11:38:15 <mux> can someone explain me how I am supposed to have threads blocking on file handles for data without blocking the whole program?
11:38:27 <mux> I thought that using -threaded could handle this but it doesn't seem so
11:38:36 <dcoutts> SamB, that's what c2hs does basically.
11:38:43 <SamB> or BS, Int, and what kind of context it comes from
11:38:50 <SamB> dcoutts: oh?
11:38:55 <dcoutts> SamB, it get's called an attribute and is used to index all kinds of maps of info.
11:39:18 <SamB> of course, for that to work we'd have to rework all the code that uses Ids
11:39:34 <dcoutts> SamB, c2hs doesn't actually use a BS, it uses a String and a hash for fast equality.
11:39:41 <dcoutts> but that;s because c2hs is much older than BS
11:39:50 <dcoutts> BS's give fast equality anyway
11:39:51 <SamB> dcoutts: I was going to skip testing the string for equality
11:39:58 <SamB> and just test the Int part
11:40:02 <dcoutts> aye
11:40:06 <SamB> since that is supposed to be unique anyway
11:40:27 <int-e> > zipWith const [1..] [1,3,5,1,2,4]
11:40:29 <lambdabot>  [1,2,3,4,5,6]
11:40:29 <ndm> SamB, i think existing names are guaranteed unique
11:40:37 <dcoutts> BS's that derive from the same place give O(1) equality anyway
11:40:42 <SamB> ndm: internally sure
11:40:44 <ndm> SamB, i wasn't going to touch programmer supplied onces, apart from variable names to arguments
11:40:52 <dcoutts> ie if you share all your id's at the lexer level
11:41:04 <ndm> SamB, but all variables inside a function need creating fresh
11:41:18 <ndm> SamB, we use full qualification to keep that true at the Core level
11:41:25 <SamB> ndm: well, the method you suggest doesn't address my concerns wrt variables in the source code that might happen to be named "v126"
11:41:27 <SamB> or whatever
11:41:47 <SamB> at least, I don't see how it does
11:41:51 <ndm> SamB, give an example of a variable you're worried will get trampled on?
11:41:59 <SamB> ndm: just look at this code!
11:42:05 <SamB> {- | Give printable string for identifier -}
11:42:05 <SamB> strIS :: IntState -> Id -> String
11:42:05 <SamB> strIS state i =
11:42:05 <SamB>    case lookupIS state i of
11:42:05 <SamB>      Just info -> show (tidI info)
11:42:06 <ndm> things like map f xs = can't really have f and xs maintained
11:42:06 <SamB>      Nothing -> 'v':strId i
11:42:18 <hygge> anyone here doesnt happen to have a Gen String-generator to QuickCheck?
11:42:32 <ndm> that only happens if the variable has no name originally
11:42:37 <SamB> I know
11:42:51 <SamB> but what if one variable has an original name of "v126"
11:42:56 <CosmicRay> Igloo: are you going to build hugs versions of the libraries?
11:43:06 <SamB> and another one has an Id whose Int is 126?
11:43:16 <SamB> but no original name?
11:43:22 <SamB> won't we get the same thing for both?
11:43:37 <ndm> perhaps @ at the front?
11:43:42 <ndm> since @ can't occur in a variable name
11:43:47 <Igloo> CosmicRay: At some point. hugs currently includes them doesn't it?
11:43:49 <SamB> @?
11:43:50 <ndm> i'm not sure what Yhc does already about that... - if anything
11:43:51 <SamB> why not $
11:43:53 <ndm> @v123
11:43:53 <lambdabot> Unknown command, try @list
11:43:57 <ndm> $ is a legal name
11:43:59 <ndm> @ isn't
11:44:01 <CosmicRay> Igloo: there are some new ones like time that hugs doesn't have
11:44:18 <SamB> oh
11:44:19 <SamB> true
11:44:29 <Igloo> CosmicRay: OK. I don't know if I'll get around to it in the etch timeframe.
11:44:56 <CosmicRay> understood.  do you know if the hugs people plan to make a new release to sync up with the ghc libs?
11:46:03 <Igloo> What do you mean by "sync up"?
11:46:18 <SamB> use the latest "base" package?
11:46:26 <SamB> and other packages too I guess?
11:46:29 <Igloo> I'm not aware of any release plans, though. They're only just released.
11:47:17 <CosmicRay> CosmicRay: well last time there was a new ghc release, hugs and nhc made new releases the same day.  they didn't add many features AFAIK, but did include the new fptools libs so that programs written for one stood a decent chance of working on the others
11:47:21 <SamB> ndm: you really should add some kind of --show-core= mode to Yhc...
11:47:29 <SamB> like GHC's --show-iface
11:47:45 <Igloo> The libraries are by and large the same between hugs and ghc, I believe
11:48:08 <SamB> nhc is dead now ;-)
11:48:12 <dcoutts> yes, eg latest hugs has Cabal-1.1.5.9.2
11:48:19 <dcoutts> nearly 1.1.6 :-)
11:48:30 <ndm> SamB, i will do, its just a whole new "way" for the compiler to interact, so have to design it properly
11:48:33 <mux> mmm, GHC has threadWaitRead and threadWaitWrite
11:48:36 <dcoutts> SamB, aye, dead for some time.
11:48:37 <ndm> SamB, but code wise its about 2 lines...
11:48:39 <Igloo> Grr, either -O0 or -g seems to have fixed arm
11:48:42 <mux> should I be using this for blocking on I/O?
11:48:52 <SamB> ndm: it doesn't need *design*
11:48:58 <Heffalump> Igloo: why grr?
11:49:07 <CosmicRay> really, ghc will work on arm now?
11:49:12 <CosmicRay> or stands a chance of working?
11:49:24 <ndm> SamB, hehe, indeed - but the flags are processed in the wrong place, which makes it a bit harder...
11:49:24 <SamB> it just needs to say "oh, you want me to translate this .yhc file into ASCII? okay, I'll do that and exit!"
11:49:29 <SamB> oh!
11:49:35 <SamB> that *would* be tricky
11:49:43 <Igloo> Heffalump: Because that means I can't debug it with those flags?
11:49:48 <SamB> oh, and it doesn't need to work anywhere but the beginning of the commandline
11:49:58 <SamB> afaik
11:50:09 <ndm> SamB, it's a shame to replicate the flag parsing facilities
11:50:12 <Heffalump> Igloo: so what flags break?
11:50:19 <Dreadshoot> @seen dons
11:50:19 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 6h 12m 5s ago.
11:50:24 <Igloo> The default flags
11:50:24 <SamB> ndm: true
11:50:28 <Dreadshoot> @seen shelarcy
11:50:28 <lambdabot> I haven't seen shelarcy.
11:50:36 <ndm> SamB, and it should also do output of .hbc files as well, once we get Yhc.ByteCode in
11:50:47 <Heffalump> which are what? -O2 and no -g?
11:50:52 <SamB> that could be --show-bytecode
11:50:57 <SamB> or --disassemble
11:51:00 <SamB> or something
11:51:11 <Igloo> I think some files are -O3
11:51:25 <Heffalump> what's the actual problem?
11:51:46 <Igloo> ../../compiler/ghc-inplace -H16m -O -fglasgow-exts -cpp -Iinclude -"#include" HsBase.h -funbox-strict-fields -package-name  base-2.0 -O -Rghc-timing -fgenerics  -fgenerics    -c GHC/Conc.lhs -o GHC/Conc.o  -ohi GHC/Conc.hi
11:51:51 <Igloo> ghc-6.6: out of memory (requested 2148532224 bytes)
11:52:09 <Heffalump> that seems like quite a large request ;-)
11:52:27 <Igloo> It also had other failures on the same file, but -C0 made it consistent (can't remember what happened)
11:52:38 <Igloo> But my debugging build has finished building base now
11:53:44 <Heffalump> what was ghc-inplace built from, hc files?
11:54:31 <Igloo> Yup
11:54:50 <SamB> Heffalump: I thought that was a shell script!
11:54:52 <Heffalump> how long did that bit take?
11:55:05 <Heffalump> SamB: what, ghc-inplace?
11:55:10 <SamB> yes!
11:55:25 <Heffalump> ok, I meant "what was the actual binary built with"
11:55:32 <SamB> yeah ;-)
11:55:33 <Heffalump> which is also the question Igloo answered
11:55:34 <SamB> so it seems
11:55:39 <SamB> yes
11:55:41 <Heffalump> so :-p
11:56:14 <SamB> ;-P
11:57:38 <Igloo> I'm not sure. It takes around 3 hours of CPU time (6 of clock time) to build ghc-inplace with everything -O0 -g (which then fails to link as it's too big)
11:58:40 <Igloo> Ah, no, the new one does break, it just happened to work that time
11:59:04 <Heffalump> oh, great
11:59:32 <Igloo> Now I just need to hope the optimised code doesn't confuse gdb/me too much  :-)
11:59:50 * ndm just wrote an optimiser that change putStrLn "Hello Neil!" to putStrLn "Helo Ni!"
12:00:08 <ski> hehe
12:00:10 <Heffalump> Igloo: YM unoptimised code?
12:00:17 <Igloo> No, optimised
12:00:24 <Igloo> If I give -O0 to everything then it doesn't link
12:00:34 <Igloo> So I only have an unoptimised RTS
12:00:38 <Heffalump> ndm: ah, so it knows you've changed your name by deed poll and decided to start communicating only by email?
12:00:58 <Heffalump> Igloo: how are you going to figure out where it goes wrong?
12:01:14 <Igloo> I'm going to run gdb and see what happens
12:01:15 <SamB> ndm: why in the world would you write such?
12:01:21 <SamB> it would fail the tests for sure!
12:01:29 <ndm> SamB, it wasn't intentional!
12:01:38 <SamB> how in the world, then!
12:01:46 <Heffalump> ni!
12:01:50 <ndm> SamB, my thing got a bit too clever about IO, and decided once you've seen one "l", thats plenty
12:02:44 <Igloo> That sounds very appropriate for a York compiler
12:02:59 <ndm> what's that supposed to mean ;)
12:03:22 <ski> ndm : don't you have a weird internal definition of 'IO' in nhc ?
12:03:27 <SamB> ndm: heh
12:03:40 <Tobsan> does anyone of you have a link to some good site describing wxHaskell
12:03:42 <ndm> ski: Yhc -O, its using an entirely different definiti8on of IO
12:03:52 <Igloo> ndm: The whole avoiding monads, everything is referentially transparent thing  :-)
12:03:59 <Tobsan> it's probably the most unlogical thing i've ever seen
12:04:06 <ski> ndm : .. ok .. and that one is ?
12:04:12 <ndm> Igloo: yep, since thats one its doing
12:04:28 <ndm> ski: data IO a = IO a
12:04:35 <ski> gah!
12:04:48 <ndm> ski: but am currently moving to type IO a = RealWorld -> (RealWorld, a)
12:04:48 <ski> even worse :)
12:04:55 <ski> ok
12:05:08 <Tobsan> anyone of you using wxHaskell?
12:05:11 <ndm> the first one was safe, before i imporved the compiler
12:05:16 <ndm> Tobsan: i use Gtk2Hs instead
12:05:22 <SamB> ski: not really
12:05:38 <SamB> it makes things a lot easier when your optimizer is worth beans!
12:05:42 <Tobsan> ndm how great...but i have to use wx...is't an assignment in school
12:05:42 <ski> ndm : istr something like 'type IO a = RealWorld -> Either SomeError a' ..
12:06:04 <CosmicRay> hrmm, cna I get some help on porting some code to GHC 6.6?
12:06:05 <CosmicRay> I have this:
12:06:07 <ndm> ski: i think thats the nhc one
12:06:10 <CosmicRay> type CommandHandler = FTPServer -> String -> IO Bool
12:06:11 <CosmicRay> type Command = (String, (CommandHandler, (String, String)))
12:06:11 <CosmicRay> instance Eq Command where
12:06:11 <CosmicRay>     x == y = (fst x) == (fst y)
12:06:11 <CosmicRay> instance Ord Command where
12:06:11 <CosmicRay>     compare x y = compare (fst x) (fst y)
12:06:15 <ski> ndm : ok
12:06:17 <CosmicRay> works fine in ghc 6.4
12:06:23 <ski> (SamB : hm ?)
12:06:25 <kowey> Tobsan: i use wxhaskell...
12:06:33 <ndm> CosmicRay: newtype?
12:06:35 <CosmicRay> in ghc 6.6, I get an error about overlapping instances for Eq Command
12:06:36 <Tobsan> kowey ok, do you see any logic in it?
12:06:49 <kowey> Tobsan: what do you mean?
12:07:13 <Tobsan> kowey how am i supposed to know what attributes a widget takes?
12:07:19 <CosmicRay> if I remove the instance for Eq Command, then the Ord instance gives a weird error about no instance for (Eq (FTPServer -> String -> IO Bool)) arising from the superclass of an instance declaration
12:07:27 <CosmicRay> I have no idea why Ord would care about Eq
12:07:43 <CosmicRay> ndm: newtype for which?  Command?
12:07:46 <ski> CosmicRay : 'Ord' inherits from 'Eq'
12:07:49 <ndm> CosmicRay: yes
12:07:49 <CosmicRay> and why did this work before but not now
12:07:49 <kowey> Tobsan: ah... you look in the API and you see what classes the widget is it... why don't you name a widget and we'll work through it together?
12:07:57 <ski> class Eq a => Ord a where ...
12:08:11 <CosmicRay> ski: ah.
12:08:21 <ndm> CosmicRay: because you used an undocumented feature not in Haskell 98, then got burnt
12:08:27 <Tobsan> kowey the thing is i want to be able to use any widget, but there's no place to find which attributes it can take
12:08:32 <CosmicRay> ndm: ah, heh.
12:08:34 <Igloo> CosmicRay: Are you giving it -foverlapping-instances?
12:08:49 <CosmicRay> Igloo: Yes, I probably am due to other modules in the same package.
12:08:51 <Tobsan> kowey and besides, i'm too tired to do it now
12:08:53 <SamB> ski: having data IO a = RealWorld -> (RealWorld, a)
12:09:02 <SamB> or, well, with IO
12:09:09 <Tobsan> kowey you know any site except the api that could help?
12:09:20 <Igloo> CosmicRay: Hmm, if you are then I'm not sure what's going on
12:09:29 <SamB> but, I mean... the data IO a = IO a won't work if your optimizer does
12:09:49 <CosmicRay> Igloo: I am indeed
12:09:56 <CosmicRay> Extensions: ExistentialQuantification, OverlappingInstances,
12:09:57 <CosmicRay>    UndecidableInstances, CPP
12:10:07 <kowey> Tobsan: off the top my head, the haddock (the API) is the best place to go... but it's really not that hard
12:10:08 <ski> SamB : .. my '<ski> even worse :)' was meant for 'data IO a = IO a' .. not that one
12:10:19 <SamB> oh ;-)
12:10:22 <SamB> okay.
12:10:30 <ski> (that one is more or less fine)
12:10:32 <SamB> what is that worse than?
12:10:38 <Tobsan> kowey ok, i'll try to understand it better then =).
12:10:47 <SamB> I mean, what are you comparing it with?
12:10:51 <ski> SamB : 'type IO a = RealWorld -> Either SomeError a'
12:10:57 <SamB> oh.
12:11:08 <kowey> Tobsan: have you seen the wikibook page, or the haskell wiki on wxhaskell? they are both quite introductory
12:11:31 <kowey> http://en.wikibooks.org/wiki/Haskell/GUI
12:11:34 <SamB> shouldn't that be data IO a = RealWorld -> Either (RealWorld, SomeError) (RealWorld, a) or something?
12:11:38 <Igloo> Oh, I see the problem. The other instance wasn't compiled with overlaps allowed, and I think it now needs to have been
12:11:49 <SamB> or, well, with an IO in there...
12:11:53 * SamB is horrible at this
12:12:01 <CosmicRay> Igloo: Ahh, in Data.Tuple you mean?
12:12:05 <ski> SamB : but (iiuc) it really is (or was) that in nhc
12:12:05 <Tobsan> kowey ty
12:12:10 <Igloo> Yup
12:12:17 <CosmicRay> that makes sense
12:12:27 <Igloo> I think you'll have to use a newtype
12:12:36 <Igloo> Or a real datatype instead of the tuple
12:12:40 <kowey> Tobsan: and http://www.haskell.org/haskellwiki/WxHaskell
12:12:41 <lambdabot> Title: WxHaskell - HaskellWiki
12:12:58 <SamB> Igloo: hmm?
12:13:12 <Tobsan> kowey ok
12:13:27 <Igloo> CosmicRay: You might want to check with the list though, (a) in case I'm wrong and (b) to make it known that you wanted to do that
12:13:36 <Igloo> SamB: "hmm?"?
12:15:18 <ndm> crap, moving to a proper IO type breaks other things :(
12:15:51 <ski> like ?
12:16:00 <ndm> full defunctionalisation
12:16:09 <Igloo> ndm: Does your optimiser do PE?
12:16:14 <ndm> Igloo: PE?
12:16:21 * Igloo is wondering how it noticed the duplicate characters
12:16:24 <Igloo> partial evaluation
12:16:24 <ndm> Igloo: it does partial evaluation
12:16:33 <Igloo> OK
12:16:46 <ndm> Igloo: but it wasn't that phase that commoned them up, that was the CSE (common subexpression elimination)
12:16:56 <SamB> ndm: is that why you switched from data IO a = IO a ?
12:16:57 <ndm> they survived the partial evaluation
12:16:58 <Igloo> Sure, but I was wondering how the CSE managed to see them
12:17:03 <ndm> SamB, yes
12:17:31 <ndm> SamB, data IO a = IO a is safe, provided the optimiser doesn't go to deep, but mine is ticklying bad bits...
12:17:36 <SamB> I suppose you were using seq to make the first part happen first?
12:17:45 <roconnor> Happy Habeas Corpus Day!
12:17:57 <SamB> well, I'd say that any good optimizer would probably mess that up
12:18:03 <SamB> at some point
12:18:05 <SamB> for instance
12:18:07 <SamB> if I write
12:18:30 <SamB> greet = putStrLn "Hello!"
12:18:36 <SamB> and then:
12:18:41 <SamB> main = greet >> greet
12:18:53 <SamB> what compiler worth beans wouldn't CSE those two greets together?
12:19:02 <SamB> if it would even *need* to do CSE!
12:20:00 <SamB> and think of getChar!
12:20:06 <monochrom> Fact is, compilers don't worth beans.
12:20:18 <SamB> well.
12:20:34 <ndm> SamB, but if you could flag the actions specially to be not commoned up, you might benefit by keeping the non-function based representation
12:20:34 <SamB> yes. but. they should be worth enough to cause trouble with "data IO a = IO a"
12:20:47 <SamB> ndm: how so?
12:21:03 <ndm> SamB, imagine a haskell compiler that didn't have to deal with higher order functions...
12:21:12 <SamB> huh?
12:22:00 <ndm> SamB, no functions as values - imagine a first order map :)
12:22:10 <SamB> can't
12:22:19 <SamB> I don't have that good a imagination
12:22:26 <ndm> well i have one :)
12:22:37 <ndm> and it can outperform GHC ever so slightly on some benchmarks
12:22:48 <ndm> but will hopefully get faster in the next few days
12:22:53 <SamB> hmm?
12:23:21 <ndm> what is confusing you? other than the idea that a first order functional language is silly :)
12:23:26 <SamB> you mean yours rewrites the code into something not unlike RML?
12:23:32 <ndm> RML?
12:23:42 <SamB> you didn't get that far in adventure?
12:23:55 <ndm> i didn't do any of the ICFP thing
12:23:58 <SamB> oh
12:24:38 <SamB> its non-polymorphic ML-like language without exceptions of any kind, actually...
12:24:52 <ndm> my reduced language is polymorphic
12:24:55 <SamB> and I'm pretty sure it is also without higher-order-functions
12:24:59 <ndm> but doesn't have higher order functions
12:25:01 <ndm> and is lazy
12:25:09 <SamB> okay, okay, so not that much like RML
12:25:22 <SamB> RML seems to have not much more than ADTs
12:25:30 <SamB> a few primitive types
12:25:38 <ndm> i have ADT's, case, let, a few primitives
12:25:45 <ndm> not much beyond that
12:25:47 <SamB> of course, non-polymorphic ADTs are a PITA
12:26:03 <ndm> i have untyped ADT's
12:26:04 <SamB> especially when you haven't the liberty of partial functions
12:26:50 <SamB> I wrote a lint program that rejects most incorrect programs, at least as long as you don't touch the "foreign" stuff ;-)
12:27:02 <SamB> (yes, I think foreign is an RML keyword)
12:30:26 <Igloo> ndm: Can you generate nofib output compatible with GHC's logs?
12:30:53 <ndm> Igloo: no, i can only do a few of the nofib suite so far - i'm working down them alphabetically :)
12:31:03 <Igloo> OK
12:31:16 <SamB> ndm: nofib-analyser is prepared for failing nofib programs
12:31:17 <ndm> Igloo: can you give me an example of the GHC log output?
12:31:20 <Igloo> What are the problems, OOI?
12:31:22 <SamB> in fact, I have quite a few failing myself!
12:31:39 <ndm> Igloo: incompleteness of some bits of the code, nothing fundamental
12:31:42 <SamB> ndm: you'd probably find more profit in looking at what nofib-analyser is looking for
12:31:51 <SamB> or is it -analyse?
12:31:56 <ndm> Igloo: plus i want to add deforestation, to beat GHC :)
12:32:28 <ndm> SamB, what does it look for?
12:32:29 <Igloo> http://urchin.earth.li/~ian/nofib.slow.4.log is one
12:33:00 <SamB> Igloo: btw, how do you run it slow?
12:33:18 <Igloo> It'll probably help to look at the analyser in concert with the log
12:33:25 <Igloo> make mode=slow
12:34:08 <SamB> how intuitive!
12:34:27 <SamB> how is that wiki page + link in README strategy going?
12:34:29 <ndm> Igloo: i should be able to produce something similar ish, any there is an analyser that compares two versions?
12:34:39 <SamB> ndm: that is what it does
12:34:45 <SamB> it doesn't support doing anything else
12:34:48 <ndm> SamB, which stats does it pluck out?
12:35:20 <Igloo> ndm: Yeah, in utils/nofib-analyse/ in a GHC tree
12:35:26 <Heffalump> isn't the reason GHC doesn't do deforestation that it is hard to control?
12:35:49 <ndm> Heffalump: "hard to control" ?
12:35:58 <SamB> ndm: http://news.gmane.org/find-root.php?group=gmane.comp.lang.haskell.cvs.ghc&article=17327
12:36:04 <lambdabot> Title: Gmane Loom, http://tinyurl.com/yhrb44
12:36:06 <Heffalump> like inlining
12:36:14 <Heffalump> difficult to do enough to have a good effect whilst not doing too much
12:36:57 <ndm> i have techniques to stop it doing too much
12:37:10 <SamB> that is output
12:37:18 <SamB> the "nofib-analysis"
12:37:19 <ndm> and the Primes in the nofib suite has 5 produce/consumer pairs in a sequence!
12:37:43 <ndm> SamB, cheers :)
12:38:02 <SamB> oh, actually gmane just renders it inline ;-)
12:38:16 * SamB is silly to not remember this
12:38:18 <pejo> Heffalump, http://tunes.org/~nef/logs/haskell/05.11.28 - 04:39:04 <JaffaCake> short-cut deforestation turned out to be a more practical solution in the end
12:38:34 <Heffalump> pejo: yes, precisely
12:38:38 <SamB> but...
12:38:48 <SamB> I think maybe we took the wrong shortcut!
12:40:28 <ndm> for GHC, with teh techniques they used, yes
12:40:37 <ndm> but perhaps generalised is the right answer in the end...
12:41:04 <SamB> hmm
12:41:33 <ndm> anyway, i'm too lazy to implement a massive rules architecture, and full deforestation is only 50 lines in my analysis engine, so wins on "neil being lazy" :)
12:41:42 <SamB> heh
12:41:49 <Heffalump> :-)
12:41:56 <SamB> so basically you took a different shortcut?
12:42:16 <SamB> you decided it was easier to just do real deforestation?
12:42:31 <ndm> i have decided it will be easier, i still have to get round to implementation...
12:42:37 <SamB> oh
12:42:50 <SamB> how do you know how many lines it is if you haven't done it yet?
12:42:59 <ndm> i wrote the algorithm on paper
12:43:14 <ndm> and can guess its ~50
12:43:37 <ndm> and compared it to shortcut deforestation, which gives worse results, and takes more code
12:43:42 <ndm> plus i can deforest booleans :)
12:43:48 <SamB> niiiice
12:44:07 <SamB> ... can you deforest *primops* returning booleans though?
12:44:45 <ndm> not yet...
12:45:09 * SamB can only think of how to do that with CPS
12:45:11 <ndm> but perhaps, i'll see if there is a need...
12:45:20 <ndm> should be possible to add, at least
12:45:32 <ndm> define a primitve as a producer, yeah, should be doable
12:45:41 <SamB> pushed the fix you wanted, I think
12:46:29 <SamB> at least, the variable names from -core don't contain spaces anymore ;-)
12:49:12 <ndm> woot :)
12:49:34 <SamB> ndm: so, how does yhc fare on "fish"?
12:50:00 <ndm> SamB, which folder is fish in?
12:50:41 <SamB> isn't it in spectral?
12:50:59 <SamB> (are you using a different alphabetical order?)
12:51:34 <ndm> SamB, i have done exactly two so far, and i'm doing alphabetical in imaginery first :)
12:51:39 <SamB> oh
12:51:41 <SamB> I see
12:52:00 <SamB> what do you do when you get to a build error?
12:53:44 <ndm> SamB, its not a case of that, its just plodding through, not even got something "stopping" me yet, just refining
12:53:48 <ndm> SamB, just trying fish now...
12:54:21 * SamB is particularly interested in total allocation
12:55:02 <ndm> it gets to the end at least...
12:55:24 <ndm> lacking various primop's
12:55:29 <SamB> oh really?
12:55:54 <SamB> what is lacking them?
12:56:55 <ndm> multiply on int's...
12:56:59 <ndm> my analysis tool
12:57:16 <ndm> its also borked showsPrec, missing one argument off, will have to look into that one closer
12:57:49 <ndm> @paste
12:57:50 <lambdabot> http://paste.lisp.org/new/haskell
12:57:59 <_frederik_> "We end with the observations that all concepts of category theory are Kan extensions"
12:58:12 <lisppaste2> ndm pasted "The optimised Core for SamB" at http://paste.lisp.org/display/28326
12:59:20 <SamB> any particular reason it has so many lets?
13:00:24 <ndm> SamB, for fun, they are essentially "free"
13:00:49 <SamB> they cost a couple spaces in indentation each, actually!
13:00:52 <ndm> well, the let is, the RHS of a let has a cost to evaluate
13:00:58 <ndm> until i rewrite my pretty printer :)
13:01:03 <SamB> four even!
13:01:25 <SamB> did you change the code to use @ instead of v?
13:02:09 <sjanssen> @v
13:02:09 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
13:02:13 <Haskell> hi ppl can anyone help me with this task have no idea wat to do or how complex long it take me
13:02:18 <Haskell> http://pastebin.com/809883
13:02:21 <Haskell> have aa look
13:02:38 <ndm> SamB, no, i map names to numbers, so the v mapping isn't preserved at all
13:03:24 <ndm> hmm, quite a few missed opportunities in there, prim_NEG 1 etc
13:05:02 <SamB> ndm: ah
13:05:53 <ndm> but easy enough to fix those things, probably just don't have the primop's implemented for those
13:09:42 <Haskell> iam offering money
13:09:44 <Haskell> http://pastebin.com/809883
13:09:47 <Haskell> have a look
13:10:01 * xerox smells spam
13:10:05 <SamB> who are you leaving the money with?
13:10:18 <Haskell> iam offering money for someone who helps me
13:10:47 <Heffalump> how much money? :-)
13:10:52 <ski> we want a shrubbery !
13:11:15 <Haskell> errm u in uk or america wat currency
13:11:26 <ski> (seriously .. pastebin.com seems very slow to respond)
13:11:41 <Haskell> yeah i think its bit mashed u know any alternatives
13:11:48 <xerox> ski mass visiting :)
13:11:51 <ski> lisppaste2: url
13:11:58 <ski> @url
13:11:59 <lambdabot>  @where <key>, return element associated with key
13:12:05 <ski> er
13:12:06 <ski> @paste
13:12:07 <lambdabot> http://paste.lisp.org/new/haskell
13:12:54 <SamB> ndm: okay, now I even use the @ symbol...
13:13:08 <dolio> Heathen!
13:13:20 <Heffalump> Haskell: where are you?
13:13:26 <SamB> dolio: huh?
13:13:27 <dolio> ? is the one true bot symbol.
13:13:32 <xerox> ?yow
13:13:33 <lambdabot> There's enough money here to buy 5000 cans of Noodle-Roni!
13:13:49 <SamB> no, I use it to distinguish *real* variable names from *fake* variable names
13:14:19 <Haskell> iam here man in uk
13:14:19 <ski> dolio : '?' is the new impostor
13:14:31 <SamB> yeah, @ is the old way anyway
13:14:38 <SamB> and I do it that way mostly
13:14:40 <dolio> :)
13:14:46 <SamB> except when I copy off someone who just used ?
13:14:50 <SamB> then I tend to ues ? too
13:14:54 <Heffalump> man in uk?
13:15:05 <SamB> even if I *didn't* just copy and paste
13:15:07 <Haskell> yeah iam in uk but i can use paypal
13:15:09 <monochrom> The only man left in uk
13:15:16 <Haskell> offering 10 quid or 20 dollars
13:15:59 <SamB> ... which kind of dollars are those?
13:16:04 <amatus> @vixen do you trust paypal?
13:16:05 <lambdabot> yes i do
13:16:05 <CosmicRay> Haskell: it appears that you are trying to cheat on homework.
13:16:09 <SamB> also, what escrow service have you entrusted with them?
13:16:11 <CosmicRay> Haskell: very lame.
13:16:16 <SamB> @vixen do you trust microsoft
13:16:17 <lambdabot> yes i do
13:16:18 <Haskell> yes this is true cosmicray
13:16:31 <CosmicRay> Haskell: what is the point of taking classes if you're not going to do the work to learn?
13:16:42 <Haskell> because i have idiots for tutors
13:16:45 <Heffalump> so what should we do with the solution once we have it?
13:16:46 <SamB> we don't like to help people cheat on homework!
13:16:47 <monochrom> what is the point of arguing this?
13:16:50 <amatus> @vixen should i trust paypal?
13:16:50 <lambdabot> i dunno, should you?
13:16:50 <Haskell> how iam meant to learn when i dont understand
13:16:51 <CosmicRay> do you seriously expect to be able to do the work professionally after you've skipped it during your class?
13:16:53 <Haskell> and desperate
13:16:57 <SamB> Haskell: your tutors aren't supposed to do your homework, either!
13:16:59 <Haskell> so desperate iam here
13:17:16 <CosmicRay> Haskell: there are plenty of fora online where you can get help with Haskell issues
13:17:29 <CosmicRay> Haskell: but you should be seeking help where you need it, not asking someone to solve the problem for you
13:17:36 <SamB> yeah!
13:17:43 <Haskell> well man life is hard here
13:17:45 <monochrom> My perspective: here is a self-proving moron who can't even spell, why bother?
13:17:47 <Haskell> i dont know were u are
13:17:53 <Haskell> and were u learn your stuff from
13:18:03 <SamB> which, incidentally, is exactly what you are supposed to do with your tutors...
13:18:12 <Cale> Haskell: want a good tutorial?
13:18:16 <CosmicRay> Haskell: it doesn't matter.  if you are cheating on your homework, do you expect life to get better?
13:18:33 <Haskell> r any of u tutors who can help me for money iam in london
13:18:33 <Cale> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
13:18:36 <lambdabot> http://tinyurl.com/p6ooc
13:18:36 <monochrom> Why are we arguing the merits of cheating?
13:18:38 <CosmicRay> Haskell: do you think that you'll be able to hold down a serious programming job after you graduate if you don't know how what you're supposed to?
13:18:42 <Heffalump> Haskell: what university has these idiot tutors?
13:18:43 <Cale> Haskell: read that pdf
13:19:00 <CosmicRay> monochrom: I've never had the opportunity to do so before ;-)
13:19:03 <Haskell> no i will graduate but i never use haskell
13:19:07 <Haskell> wtf u use haskell for
13:19:09 <SamB> I am a tutor. but I couldn't be paid enough to bother helping people cheat on their homework, on purpose...
13:19:11 <Haskell> give me a example
13:19:12 <monochrom> err... ok fine I'm with you
13:19:13 <norpan> haha
13:19:22 <Haskell> SAMB not to cheat but teahc me
13:19:30 <SamB> oh. well. what do you want to know?
13:19:37 <norpan> i wonder why they teach haskell if you're never going to use it
13:19:46 <norpan> they must be complete idiots, your professors
13:19:48 <SamB> or know about?
13:19:54 <Haskell> i want u to teach me all of haskell and i give u money per hour or sumfin iam saying if u in london
13:20:00 <CosmicRay> Haskell: I use Haskell for plenty -- working with databases, a podcast downloader, etc.  but there are plenty of reasons to learn languages, and that you think you'll use it later is only one of them
13:20:02 <monochrom> There are people who could use some help.  And then there are people who just think the world owes them.
13:20:23 <Heffalump> Haskell: what university?
13:20:28 <SamB> how much do you pay per hour?
13:20:42 <Haskell> well in english money i dunno how much u rekon is resonable
13:20:43 <CosmicRay> Haskell: for instance, most languages are imperative.  it helps you understand a lot about algorithms to work in a lazy, functional language because it makes different things easy
13:21:00 * SamB gets 7.25 USD/hour to *potentially* teach people C++
13:21:07 <CosmicRay> Haskell: even if you never use Haskell again, your skill as a programmer will be better for having learned it
13:21:49 <CosmicRay> Haskell: I was taught Lisp and Prolog at my university.  I have never used either since, but lisp especially gave me some valuable insight into ways of approaching problems.  insight that has been useful in Python and Haskell.
13:21:53 <SamB> yeah, the one student I've taught so far had some trouble with the idea of being able to set the same variable to different values...
13:21:54 <Haskell> yeah true i would like to learn it but i just got desperate got this homework due in few days dont know wat iam doing so forget it ppl iam stupid
13:22:06 <SamB> (in C++)
13:22:07 <norpan> my day job pays 26 USD/hour
13:22:09 <monochrom> I have never heard one geek saying "I pay you to go to my PE class on my behalf...  What's the use of PE classes?"
13:22:33 <monochrom> In retrospect, maybe I should have done that!
13:22:36 <SamB> monochrom: probably because they aren't stupid enough to think they could get away with that crap at highschool?
13:22:55 <CosmicRay> SamB: some universities require PE classes too
13:22:58 <xerox> "PE" being what?
13:23:00 <SamB> wow!
13:23:00 <monochrom> Say, what's the use of jogging, since we all go to work by cars?
13:23:01 <norpan> of course, i live in sweden so i have to pay 40% tax or something :)
13:23:10 <SamB> xerox: getting deadly amounts of exercise!
13:23:11 <Haskell> yo man iam in england so much different from america
13:23:13 <Haskell> trust me
13:23:42 <SamB> Haskell: what do you mean?
13:23:50 <Heffalump> Haskell: you still haven't said what university this is with the idiot tutors..
13:24:16 <monochrom> Yeah England is different of course.  They don't say "man" as frequently.
13:24:39 <SamB> they don't pay people $7.25 USD an hour to potentially help people with programming at community colleges in the UK?
13:24:55 <CosmicRay> heh
13:24:58 <Haskell> maybe i didnt mean idiot was just pissed off the tutors aint idiots, just doing his job i guess my mistake
13:24:58 <norpan> "potentially"?
13:25:07 <sjanssen> SamB: why do you keep writing "potentially"?
13:25:26 <SamB> well, if nobody comes needing help and all I do is my homework, I still get paid for those hours
13:25:35 <sjanssen> ah yes, those jobs are the best
13:25:57 <Haskell> yeah sorry ppl for all this i been such a fool
13:26:03 <integral> they do at this not-a-community-college in the uk
13:26:04 <SamB> of course, usually I get distracted with trying to work on my GHC hackery or something
13:26:19 <SamB> integral: why don't they pay in quid, instead ;-)?
13:26:49 <integral> *sigh*
13:26:58 <SamB> :P
13:27:36 <Haskell> ok buy intresting convo man iam going to read my haskell book and try and understand all this man...thansk
13:27:52 <monochrom> And don't forget to jog.
13:27:52 <SamB> hehe
13:27:55 <SamB> hah
13:28:58 <amatus> there goes a man on a mission
13:29:08 <jgrimes> :p
13:29:10 <monochrom> man
13:29:13 <Heffalump> I wonder if Max Ijacic was his name.
13:29:25 <Heffalump> (Max listed on the pastebin URL and ijacic from his hostname)
13:30:02 * SamB wonders if he did Exercise Sheet 3
13:30:34 <xerox> What would you suggest as a good reading into the world of compiling lambda calculus code?
13:30:51 <shapr> SPJ's implementing functional programming languages
13:31:05 <SamB> was that the sample file for conjure?
13:31:13 * SamB thinks it was...
13:32:13 <xerox> Thanks sha
13:32:15 <xerox> pr.
13:36:18 <Lemmih> SamB: Hacking on Conjure?
13:36:25 <SamB> no!
13:36:38 <SamB> I just think that we were using a torrent of that book for testing or something...
13:38:06 <SamB> is it still broken?
13:43:28 <norpan> i want to code more haskell
13:43:31 <Cale> by the way, remember that video by Shriram Krishnamurthi about continuation-based web APIs and functional reactive ajax programming?
13:43:43 <norpan> i'm stuck to coding c++ and java right now at a measly 26 USD per hour
13:44:03 <amatus> norpan, i want to code more haskell also
13:44:38 <Maddas> Cale: I do, in case that question was directed to no-one in particular.
13:44:38 <norpan> the worst thing about coding c++ and java is jni
13:44:41 <Cale> (this one: http://download.microsoft.com/download/9/4/1/94138e2a-d9dc-435a-9240-bcd985bf5bd7/Shriram.wmv)
13:44:42 <Cale> yeah
13:44:43 <ndm> how do i stop GHC commoning up unsafePerformIO's ?
13:44:44 <lambdabot> http://tinyurl.com/rh7zz
13:44:45 <norpan> jni is the tool of the devil
13:45:15 <SamB> ndm: huh?
13:45:19 <Cale> I've sorted out that he's *really* joking about functional programming there, especially about his claim of not knowing about Fran.
13:45:21 <SamB> why are you trying to do that?
13:45:22 <ndm> i.e. unsafePerformIO (putChar 'a') >>> unsafePerformIO (putChar 'a')
13:45:25 <Cale> http://www.cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/
13:45:27 <lambdabot> Title: Embedding Dynamic Dataflow in a Call-by-Value Language, http://tinyurl.com/y5sgew
13:45:32 <SamB> ndm: that isn't *supposed* to work...
13:45:41 <ndm> SamB, it does in my world :)
13:45:53 <Cale> That paper's main inspiration is Fran, and it talks about Fran quite a bit. Note the authors :)
13:45:57 <SamB> ndm: unsafePerformIO isn't guarenteed to be anywhere near that nice!
13:46:14 <ndm> SamB, i know! was just wondering how i do it :)
13:46:38 <Cale> ndm: look at Debug.Trace
13:46:47 <SamB> Cale: huh?
13:46:49 <Cale> @source Debug.Trace
13:46:49 <lambdabot> http://darcs.haskell.org/packages/base/Debug/Trace.hs
13:47:20 * ndm gets a crazy idea...
13:47:28 <SamB> Debug.Trace avoids that by being strict in its last argument
13:47:37 <SamB> doesn't it?
13:47:38 <Cale> {-# NOINLINE trace #-}
13:47:43 <Cale> that's also important
13:47:43 <SamB> oh, that helps too
13:48:35 <SamB> Prelude> let x = Debug.Trace.trace "hi!" ()
13:48:35 <SamB> Prelude> (x, x)
13:48:35 <SamB> (hi!
13:48:35 <SamB> (),())
13:49:04 <SamB> > trace "hi!" (trace "bye!" ())
13:49:04 <lambdabot>  Not in scope: `trace'
13:49:08 <Cale> unsafePerformIO should be renamed to simonPerformIO, as it's really pretty much impossible to completely predict what will happen unless your first name is Simon :)
13:49:16 <SamB> hehe
13:49:24 <xerox> hahaha
13:49:35 <Heffalump> simonPerformIO "unicycle"
13:49:50 <SamB> well, it is okay if you *don't* depend on it doing what you expect...
13:49:52 <ndm> no luck, i'm afraid
13:49:56 <monochrom> CSEing unsafePerformIO is perfectly fine by me.
13:50:12 <SamB> except if you run into one of those situations where it gets aborted in one thread because it completed in another!
13:50:14 <ski> (it could be called 'promisePureIO' or something similar, too ..)
13:50:23 <ndm> its definately not pure :)
13:50:27 <monochrom> For one thing, I do want to use trace or unsafePerformIO to see that CSE has been done!
13:50:37 <SamB> yeah ;-)
13:50:58 <ski> 'promisePureIO (return False)' is pure
13:51:01 <SamB> unsafePerformIO should be breakMyHeadPleaseIO
13:51:14 <ndm> or "implement low level compiler features" :)
13:51:21 <Heffalump> and FFI
13:51:22 <SamB> or:
13:51:23 <Cale> tq x = trace (show x) x
13:51:34 <Cale> use of that function can really change the behaviour of programs :)
13:51:53 <monochrom> I want to write (trace "haha" (x+1) * trace "haha" (x+1)) and I expect to see just one "haha", proving that CSE has been done.  Please, please, please, don't suppress CSE for unsafePerformIO.
13:51:59 <ski> another example of a pure interface to impure internals could be memoing
13:52:16 <Cale> yeah, and things like DiffArrays
13:52:27 <ski> right
13:53:06 <ski> (those being an instance of equivalence-class represented by an instance of it)
13:53:22 <ski> (also splay trees)
13:53:25 <ndm> :(, well my program no longer has enough letters in it
13:53:26 <Cale> DiffArrays are pretty magical in terms of the runtime complexities, but the practical performance seems poor in a lot of cases. I wonder how much room there is to optimise them.
13:54:08 <ndm> specifically Hello Neil! -> Helo Ni!
13:54:14 <SamB> ni!
13:54:27 <SamB> anyway...
13:54:32 <amatus> are you saying 'ni' to that old woman?
13:55:10 <SamB> you still have to do the "data IO a = IO a" to "data IO a = RealWorld -> (# RealWorld, a #)" switch ;-)
13:55:59 <SamB> oh but I guess you can't do unboxed tuples without typed Core...
13:56:43 <ndm> SamB, i did that, but the higher order functions annoy me...
13:56:51 <ndm> SamB, my own C back end will support this fine
13:56:53 <SamB> what HOFs?
13:57:16 <Cale> I think I'd like to see a compiler which took a different approach to implementing the IO monad :)
13:57:21 <ndm> SamB, i don't like them
13:57:27 <ndm> Cale: i have one
13:57:31 <Cale> I don't think I'd implement it that way myself
13:57:37 <ndm> Cale: data IO a = IO a
13:57:38 <SamB> Cale: I don't think ndm's is a good one though ;-)
13:57:52 <ndm> @seen liyang
13:57:52 <lambdabot> liyang is in #haskell. I don't know when liyang last spoke.
13:58:38 <Cale> It would be cool to have a datatype which reflected the IO primitives.
13:58:44 <SamB> ndm: you probably can't tell the compiler not to do CSE without typed core!
13:58:47 <funcn00b> i need some tutorials to higher order functions / currying
13:59:07 <SamB> because it kinda seems like that would need to be a type-level property
13:59:08 <ndm> SamB, true, but i can teach my compiler about that :)
13:59:19 <funcn00b> anyone has one laying around?
13:59:36 <Cale> funcn00b: hmm... there are nice general Haskell tutorials which cover that stuff
14:00:07 <SamB> > map ($ 1) [neg, id]
14:00:07 <lambdabot>  Not in scope: `neg'
14:00:12 <SamB> > map ($ 1) [negate, id]
14:00:14 <lambdabot>  [-1,1]
14:00:21 <ndm> SamB, easy :)
14:00:57 <ndm> SamB, wait til you see the benchmarks :)
14:01:05 <monochrom> Anyone who has learned C does not need a tutorial on higher-order functions, since C has two in its standard library and by definition you know them.
14:01:19 <SamB> ndm: will it totally whoop even my build of GHC?
14:01:20 <Cale> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html -- this is a really good paper
14:01:24 <lambdabot> Title: Why Functional Programming Matters, http://tinyurl.com/e4jve
14:01:36 <Cale> which has a lot of motivation for both laziness and higher order functions
14:01:38 <ndm> SamB, hopefully, yes
14:01:44 <emu> > fix (\f -> 1 : map (+1) f)
14:01:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:01:49 <Cale> and shows how you can come to write them
14:01:56 <ndm> SamB, i'd be upset if i don't win in at least 50% of the nofib benchmarks
14:02:06 <Cale> But let me repeat part of the main argument for HOFs
14:02:14 <SamB> ndm: I think I will be surprised if you run many more than 50% of them
14:02:16 <Cale> funcn00b: if you'd like :)
14:02:21 <SamB> *I* don't!
14:02:44 <Cale> funcn00b: You already know how to program things like sum, to add up a list of numbers, right?
14:02:45 <ndm> SamB, fair point :)
14:02:45 <ski> (monochrom : though using a higher-order function is not the same as defining one)
14:02:50 <ndm> SamB, we'll see :)
14:02:51 <Cale> sum [] = 0
14:02:58 <Cale> sum (x:xs) = x + sum xs
14:03:05 <SamB> ndm: I think they just plain don't work with todays libraries!
14:03:15 <Cale> and you have things like product, which is really similar
14:03:20 <Cale> product [] = 1
14:03:21 <ndm> hehe, yeah, might have to modify them a bit
14:03:27 <funcn00b> cali map (+) [Int]
14:03:27 <Cale> product (x:xs) = x * product xs
14:03:29 <emu> > foldr (+) 0 [1..10]
14:03:30 <lambdabot>  55
14:03:34 <SamB> well, if you get them to build with modern libs, send the patches!
14:03:39 <integral> ?hoogle [a] -> (a -> [a] -> b) -> b -> b
14:03:40 <lambdabot> No matches, try a more general search
14:03:46 <Cale> actually, this is a fold
14:04:00 <Cale> so you see there's a lot of similarity between sum and product
14:04:13 <Cale> they do the same thing, but with only two bits changed
14:04:20 <Cale> the 0 changed to 1
14:04:24 <Cale> and the + changed to *
14:04:27 <funcn00b> yeah... we went through stuff like that in class
14:04:38 <Cale> so what we might do is to abstract that away
14:04:44 <Cale> and make those two things parameters
14:04:56 <Cale> foldr f z [] = z
14:05:01 <funcn00b> but the problem is whenever i write code i always use a lot of $/() and never .
14:05:09 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
14:05:16 <Cale> Oh, if you're doing that
14:05:18 <monochrom> $/() is fine
14:05:21 <SamB> but
14:05:25 <Cale> just replace all but the last $ with .
14:05:26 <SamB> not exactly higher-order!
14:05:34 <funcn00b> ???
14:05:38 <Cale> hehe
14:05:40 <monochrom> When you understand Unix shell pipelining you'll understand . too
14:05:43 <emu> f1 . f2 . f3 $ args
14:05:50 <Cale> If you write something like  f $ g $ h $ x
14:05:57 <Cale> you can change that to
14:06:01 <Cale> f . g . h $ x
14:06:03 <funcn00b> i usually do that...
14:06:12 <Cale> and once you start doing that
14:06:16 <funcn00b> (the first)
14:06:18 <xerox> The last $ is bogus in the first example, imo.
14:06:20 <SamB> @free map
14:06:22 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
14:06:23 <Cale> then it becomes obvious which parameters can be removed
14:06:37 <xerox> Cale ALL of them! :)
14:06:48 <Cale> well, removed conveniently
14:06:56 * xerox repeats himself
14:06:59 <xerox> :P
14:07:00 <funcn00b> ah... im gonna poke around a little in my sudoku solver to see what works
14:07:06 <SamB> @pl is not convenient in general!
14:07:07 <lambdabot> (line 1, column 19):
14:07:07 <lambdabot> unexpected reserved word "in" or "i"
14:07:07 <lambdabot> expecting variable, "(", operator or end of input
14:07:09 <SamB> @pl is not convenient in general
14:07:09 <lambdabot> (line 1, column 19):
14:07:09 <lambdabot> unexpected reserved word "in" or "i"
14:07:09 <lambdabot> expecting variable, "(", operator or end of input
14:07:18 <SamB> @pl is not convenient, generally
14:07:18 <lambdabot> (line 1, column 18):
14:07:18 <lambdabot> unexpected ","
14:07:18 <lambdabot> expecting variable, "(", operator or end of input
14:07:23 <xerox> @pl let it be = convenient in general
14:07:24 <lambdabot> general
14:07:27 <Cale> there are things like  f x y = zipWith (+) x y which you don't want to write in a points-free style because it's awkward
14:07:29 <SamB> @pl is generally not convenient
14:07:29 <lambdabot> is generally not convenient
14:07:41 <Cale> @pl \x y -> zipWith (+) x y
14:07:41 <lambdabot> zipWith (+)
14:07:45 <xerox> :P
14:07:49 <Cale> er
14:07:55 <Cale> no
14:07:56 <monochrom> f = zipWith (+) is awkward?
14:08:00 <Cale> not that function :)
14:08:00 <xerox> zipWith (+) (f x) (g y)
14:08:05 <Cale> that one :)
14:08:07 <xerox> liftM2 ?
14:08:10 <monochrom> OK!
14:08:11 <xerox> Even ap.
14:08:17 <emu> @type zipWith (+)
14:08:18 <lambdabot> forall b. (Num b) => [b] -> [b] -> [b]
14:08:22 <unclear> n00b-code: I guess that you are in my Haskell course then.
14:08:30 <xerox> ?pl \x y -> zipWith (+) (f x) (g y)
14:08:30 <lambdabot> (. g) . zipWith (+) . f
14:08:32 <Cale> zipWith (+) is okay
14:08:34 <xerox> Ow.
14:08:41 <Cale> it's when you have nontrivial x and y :)
14:08:43 <xerox> ap (zipWith (+) . f) g
14:08:47 <n00b-code> Cale: I cant use that damn "\" either (yet)
14:08:48 <monochrom> uncurry (zipWith (+)) . (f *** g)
14:08:56 <Cale> n00b-code: well, that's not so hard
14:09:03 * xerox nods
14:09:14 <Dreadshoot> anyone uses hs-plugins in win?
14:09:25 <SamB> n00b-code: huh?
14:09:27 <n00b-code> okay... so lemme try and write sum like that
14:09:34 <SamB> what damn "\"
14:09:42 * SamB has yet do see a damn "\"
14:09:42 <Cale> all it does is construct a function with the parameters you give next to the lambda \ and returns the bit after the ->
14:09:51 <SamB> how is it different from a regular "\"?
14:10:01 <n00b-code> sum = map (\x -> x+)
14:10:04 <Cale> > (\x -> x^2 + x + 1) 5
14:10:05 <lambdabot>  31
14:10:12 <monochrom> If you understand Perl sub or Java anonymous classes, you know \
14:10:14 <Cale> n00b-code: no
14:10:21 <n00b-code> fuck
14:10:28 <Cale> sum = foldr (+) 0
14:10:34 * SamB goes to walk dog...
14:10:36 <Cale> map can't collapse lists
14:10:40 <shapr> n00b-code: Hey, watch it. This is a family channel.
14:10:45 <xerox> sum = foldr (\x y -> x + y) 0
14:10:46 <Cale> it always returns a list of the same length as the input list
14:10:49 <n00b-code> "collapse"?
14:11:03 <amatus> @vixen is this a family channel?
14:11:03 <shapr> catamorphism
14:11:03 <lambdabot> yes
14:11:09 <Cale> in sum, you have a big list, and you want to return just a single number
14:11:17 <n00b-code> my bad
14:11:28 <Cale> map doesn't affect the list structure, it returns a list of the same length
14:11:29 <shapr> Hiya amatus, who are you?
14:11:38 <Cale> with a function applied to each element
14:12:06 <Cale> map f [x1,x2,...] = [f x1, f x2, ...]
14:12:14 <shapr> amatus: I'm Shae Erisson, crazy person and programmer savante.
14:12:26 <n00b-code> sum = foldr (\x y -> x + y) 0 <-- why two arguments? does it take x and y from x:y:ys or what?
14:12:40 <Cale> What foldr "really" does
14:12:52 <Cale> is replace each : in the list with a specified function
14:13:00 <Cale> and the [] at the end with a specified value
14:13:03 <n00b-code> replaces every : with the f-operator
14:13:11 <amatus> shapr: i am david barksdale, not the gangster
14:13:14 <n00b-code> the base case, yeah
14:13:15 <Cale> foldr f z replaces (:) with f and [] with z
14:13:22 <shapr> amatus: Nice to meet you! How'd you get into Haskell?
14:13:28 <Cale> I made some handy diagrams to illustrate this :)
14:13:39 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
14:13:40 <lambdabot> Title: Fold Diagrams - CaleWiki
14:13:49 <shapr> Cale: I liked the animated GIFs that whatshisname produced.
14:13:53 <shapr> That prof at your uni.
14:13:57 <amatus> shapr: that would be hammy's fault
14:14:06 <Cale> well, the uni I was working for anyway :)
14:14:08 <shapr> Who's hammy?
14:14:16 <n00b-code> but what im having trouble with are all the functions where arguments are being left oht
14:14:19 <n00b-code> *out*
14:14:20 <shapr> Cale: What are you doing these days? Do you keep a blog?
14:14:44 <amatus> shapr: http://www.cs.utexas.edu/~ham/richards/
14:15:21 <Cale> nope :)
14:15:25 <Cale> I'm looking for work
14:15:29 <shapr> amatus: Wow, dataflow!
14:15:42 <amatus> shapr: what do you mean?
14:15:54 <lambdabot> Title: Hamilton Richards
14:16:08 <shapr> He did dataflow and FP in in the 70s and 80s.
14:16:17 <Cale> n00b-code: okay, well, that becomes easier the more you get used to thinking of functions as data
14:16:17 <amatus> lambdabot: took you long enough
14:16:23 <monochrom> Two rules.  f x y z = ((f x) y) z.  (\x -> blah x) = blah.  All you need for functions where arguments are left out
14:16:52 <amatus> shapr: he did alot of things i'm finding out
14:17:11 <shapr> I'd like to learn a real dataflow language at some point and build a real app with it.
14:17:20 <n00b-code> yeah... well, back to writing stuff
14:17:57 <n00b-gone> monochrom: thanks =)
14:18:07 <shapr> Cale: Do you want math work, or Haskell/code work?
14:18:46 <Cale> either one would be nice. I don't really expect to get math work.
14:19:12 <Cale> I would even take, say, python, or ruby work :)
14:19:49 <n00b-gone> Cale: Hughes told our class about haskell jobs in the us
14:20:38 <bringert> he was probably refering
14:20:38 <amatus> bah, my new sparc64 compile of Hugs says maxBound::Int is 2147483647
14:20:41 <bringert> eh
14:20:48 <xerox> Why you don't espect to get math work, Cale?
14:20:49 <n00b-gone> Cale: pm me if you're interested and i can tell you about what he told us
14:21:05 <Cale> Well, I also don't really want to have to move :)
14:21:08 <bringert> referring to Galois, Credit Suisse and Jane Street Capital
14:21:55 <n00b-gone> Jane Street, that's the one
14:22:02 <xeqi> or aetion
14:22:20 <bringert> are they hiring too?
14:22:32 <n00b-gone> oh wait... they did their program in oCaml, but whatever =)
14:22:39 <n00b-gone> he said they were
14:22:40 <xeqi> hmm, not sure, had a friend intern with them over the summer
14:22:46 <Cale> xerox: Well, I don't plan on being a graduate student right now.
14:23:27 <xerox> Cale, does that mean that you are not looking for such jobs, or that there aren't any?
14:26:05 <Cale> xerox: In pure mathematics? Usually mathematics jobs in the industry at least slightly require some applied math background.
14:26:28 <xerox> Agreed.
14:27:24 <Cale> I don't think there are many possibilities for getting paid to sit around and prove theorems if you're not at a university.
14:28:24 <pejo> Cale, NSA. ;)
14:28:26 <xerox> Aw.
14:28:33 <n00b-gone> Cale: where do you live?
14:28:52 <Syzygy-> Cale: Why go outside the world of acadmia?
14:28:55 <Cale> Brantford, Ontario. Commuting to Hamilton is trivial though.
14:29:19 <Cale> Syzygy-: because I want to pay down my loans and then go travel for a while before getting back to it
14:29:36 * Syzygy- hasn't had much problem getting industry jobs with pure maths background. Otoh, I complemented that with personal contacts and a hobbyist programming passion since the age of 11...
14:29:40 <Syzygy-> Cale: Good point.
14:29:57 * Syzygy- is slowly paying off his loans. On a PhD student salary. Qutie a feat...
14:31:23 <Cale> I've been programming for a long time too, so I'm basically looking for programming work. The only hard part is that I don't have a driver's license, so it makes my possibilities for commuting limited.
14:31:29 <cjeris> (grad school right after undergrad)--
14:31:57 <Cale> One could say that I'm nonabelian. :)
14:32:01 <xerox> hehe
14:32:05 <mux> Syzygy-: 11? that's already too late! ;-)
14:32:08 <Syzygy-> Cale: Bwahahaha!
14:32:08 <SamB> because you don't commute?
14:32:10 <pejo> Cale, haha
14:32:19 * cjeris whacks Cale with a free group
14:32:24 <Syzygy-> mux: So sorry... I was a gamer during my early years...
14:32:33 <mux> heh, who wasn't?
14:32:36 <Syzygy-> cjeris: Free in which category?
14:32:37 <amatus> kids these days, too much gaming
14:32:54 <Cale> I started when I was about 9.
14:32:55 <Syzygy-> amatus: Yeah. Infocom and early Sierra games from the age of 5....
14:33:01 <mux> I dropped gaming rather early, because games were taking way too much time to load on my CPC464
14:33:03 <cjeris> Syzygy: Grp
14:33:09 <SamB> mux: heh
14:33:11 <mux> so I started doing Locomotive Basic 1.0!
14:33:14 <n00b-gone> Cale: so you wont move and you dont have a drivers license...
14:33:21 <Cale> heh
14:33:46 <amatus> Syzygy-: oh, infocom, in that case you're forgiven, all i had was Who Framed Rogger Rabbit for ... 286 or something, and frogger, i got bored of those before i was 11
14:33:47 <mux> Loading block 1........... <insert a 5 minutes pause> Done
14:33:48 <n00b-gone> you go girl!!
14:33:54 <Cale> However, my father drives into Hamilton every day, so work in that city would be possible
14:34:24 <Syzygy-> amatus: My first computer was an Ericsson XT (8088 core) with brown/brown screen.
14:34:42 <mr_ank> xerox, shapr: you were talking about this book on the implementation of functional languages? http://research.microsoft.com/~simonpj/papers/slpj-book-1987/
14:34:44 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/yyqmom
14:34:52 <Syzygy-> amatus: My first own computer was an old Rabbit industrial station (80287 core) with built-in screen.
14:35:08 <cjeris> LOAD "*",8,1
14:35:10 <SamB> Syzygy-: 287?
14:35:16 <n00b-gone> can someone tell me what the FUCK microsoft has to do with haskell?
14:35:17 <SamB> how does a 287 work as a computer?
14:35:17 <mux> run "menu"
14:35:20 <amatus> my first computer could have been an 8088, i don't remember enough specifics to make a determination now
14:35:23 <Cale> and of course, if it's really necessary, there are buses :)
14:35:23 <SamB> don't you need a 286 for that?
14:35:27 <mux> mode 2 !
14:35:29 <mr_ank> n00b-gone: take a look at the link
14:35:31 <dons> mmm, http://www.alpheccar.org/en/posts/show/57
14:35:32 <monochrom> Perhaps it also contains a 286.
14:35:32 <lambdabot> Title: Haskell, PDF and Penrose Tilings
14:35:39 <SamB> monochrom: perhaps!
14:35:56 <xerox> mr_ank: right
14:36:01 <xerox> dons woohoo.
14:36:43 <amatus> Syzygy-: what i do remember though is it had a CGA graphics card, that thing was sweet
14:36:56 <Dreadshoot> dons: do you know if shelarcy is here anything?
14:37:08 <dons> Dreadshoot: not usually, but he's on the email lists
14:37:12 <xerox> dons, I'll be taking a course on tilings, periodic and aperiodic ones :)
14:37:15 <xerox> (Very soon.)
14:37:27 <mux> dons: hey, could you school me with respect to how to have threads blocking for I/O without blocking the whole program?
14:37:35 <Syzygy-> Mmmmmm, CGA....
14:37:50 <Syzygy-> SamB: 287 == 286 + FPU
14:38:12 <mux> or rather, 287 == FPU copro
14:38:15 <amatus> wasn't 287 the FPU part itself
14:38:20 <Syzygy-> Probably. Too long ago.
14:38:21 <amatus> yea, what mux said
14:38:23 * mux nods at amatus 
14:38:30 <Syzygy-> I had a 12MHz 286 with FPU anyway....
14:38:33 <SamB> yeah, I was pretty sure the 287 was just the FPU...
14:38:43 <Syzygy-> And ... I think I had 1M RAM - I was soooo happy. :)
14:38:57 <monochrom> 287 does not contain 286
14:39:04 <dons> mux, use -threaded
14:39:10 <mux> dons: I did :-)
14:39:11 * dons schools mux
14:39:16 <mux> and it's still blocking for some reason.
14:39:18 * mux unschools self
14:39:19 <mux> :D
14:39:21 <emu> i had an IBM XT which was an 8088
14:39:37 <mr_ank> Syzygy-: 80287 = add-on copro for 80286
14:39:43 <shapr> emu: I upgraded to an 8086
14:39:52 <dons> mux, and the foreign calls need to be 'unsafe'
14:39:58 <mux> hrm.
14:40:06 <monochrom> up to and including 386, the FPU x87 is a separate chip sold separately.
14:40:11 <mux> what bloody foreign calls are you talking about? :-)
14:40:11 <shapr> emu: The 8086 had a 16-bit cpu!
14:40:15 <emu> yep
14:40:26 <mux> dons: maybe I should provide a test-case to you?
14:40:32 <emu> i think we had the XT til we got a 486.  i used computers elsewhere.
14:40:47 <shapr> monochrom: Actually, that was also true of the 486SX (which we expanded to SuX) where the FPU was either disabled or a separate chip.
14:40:52 <dons> mux, ah, like, foreign import ccall threadsafe getch :: IO CInt
14:41:04 <mux> I don't have any FFI stuff
14:41:06 <dons> mux (check the FFI report for details)
14:41:14 <jgrimes> wow, if you want to kill your machine, run the penrose test app with 100 as the argument
14:41:16 <emu> i distinctly recall installing Slackware on a 486 DX-33 with 4MB of RAM, running XFree86, and wishing I had 8MB
14:41:17 <dons> mux, send a test case to haskell-cafe
14:41:22 <mux> dons: ok, thanks
14:41:32 <jgrimes> that comes with HPDF
14:41:37 <shapr> But before the x86 arch, I used a Sinclair Spectrum and a C= 64
14:41:39 <amatus> i don't think the 486 had a seperate 487... it was just SX or DX if you wanted the FPU or not
14:41:46 <mux> amatus: yep
14:41:56 <dons> has HPDF been announced to the lists?
14:42:02 <monochrom> Since 486 and onwards, the FPU is included on the same chip.  There is 486SX, which has the FPU but disabled and sold at a lower price.  (At this point, a Dilbert cartoon is appropriate.)
14:42:02 <mux> and the funny thing is that SX/DX had a whole different meaning for 80386
14:42:16 <shapr> amatus: I think you could purchase a separate FPU for the 486SX
14:42:26 <mr_ank> amatus: no, the 487 was available for the SX
14:42:27 <mux> AMD was selling those
14:42:29 <amatus> shapr: that makes no sense
14:42:32 <mux> ahh, the good old day
14:42:36 <mr_ank> http://www.cpu-world.com/CPUs/80487/index.html
14:42:39 <lambdabot> Title: CPU-World: Intel 80487, http://tinyurl.com/yce5jd
14:42:43 <emu> whats up with the haskell' effort
14:42:44 <monochrom> 386SX has a narrower bus (I forgot address or data or both) than 386DX.
14:42:45 <mux> where AMD was only selling coprocessors :)
14:42:45 <unclear> nreds ;)
14:42:49 <emu> werent they supposed to produce a report for october
14:42:52 <unclear> nerds*
14:42:53 <dons> ?where HPDF darcs get http://darcs.alpheccar.org/HPDF
14:42:53 <lambdabot> I know nothing about hpdf.
14:42:59 <dons> ?where+ HPDF darcs get http://darcs.alpheccar.org/HPDF
14:42:59 <lambdabot> Done.
14:43:06 <amatus> mr_ank: that's wack
14:43:27 <dons> emu: there was a summary, work is progressing
14:44:04 <monochrom> Yes, if you buy a 486SX, and then regret it and want your FPU back, you don't have to open up the chip and rewire it.  You can conveniently at your leisure buy a 487 chip.
14:44:20 <emu> cool, i'm reading Status' while i run testcases on some stuff
14:45:01 <shapr> dons: 500 on that url
14:45:06 <mr_ank> monochrom: wasn't there a 486 that you could pop a pentium on top?
14:45:07 * mr_ank googles
14:45:14 <mr_ank> overdrive or something
14:45:25 <shapr> mr_ank: I think that was a Mac
14:45:29 <monochrom> Hmm, I seem to recall that.
14:45:35 <mr_ank> shapr: i remember the ad
14:45:45 <shapr> mr_ank: Hm, I think you're right
14:45:52 <dons> shapr: works here, http://www.alpheccar.org/en/posts/show/57
14:45:53 <lambdabot> Title: Haskell, PDF and Penrose Tilings
14:46:02 <mr_ank> shapr: http://cpu-museum.de/?m=Intel&f=Overdrive+CPUs
14:46:03 <dons> oh, you mean the darcs url?
14:46:06 <lambdabot> http://tinyurl.com/9qzw6
14:46:19 <dons> nope, darcs works too
14:46:22 <mr_ank> they are so useless now. damn.
14:46:23 <shapr> mr_ank: I'm thinking of the overdrive expansion NuBus card that was a whole 'nother CPU, and required special drivers. It was supported by Photoshop and the like.
14:46:24 <monochrom> Actually you throw away the 486 and plug in the Pentium Overdrive instead.  I.e., Pentium Overdrive = Pentium with the 486 bus (inferior).
14:46:44 <shapr> Yeah, but the bus we have these days is about the same...
14:46:51 <mr_ank> shapr: ah! i remember that stuff
14:46:51 <shapr> We have lotsa ops and so little bandwidth.
14:47:11 <shapr> It's amazing how many 0ldsk00l geeks we have here at the same time :-)
14:47:33 <mr_ank> sniff... let's open a BBS
14:47:34 <mux> mmmm, overdrive
14:47:40 * shapr laughs
14:47:54 <mr_ank> with RIP support!
14:47:56 <shapr> It'd have to be a WWIV BBS of course.
14:47:57 <monochrom> Where is my v.24 modem?
14:48:26 <mr_ank> ATDP
14:48:28 <shapr> What were the ten levels of compression supported by that company? omicron, omap... um
14:48:34 <monochrom> I still have 5.25" diskettes
14:48:36 <mr_ank> oh i remember that
14:48:37 <shapr> +++ATH
14:48:50 <shapr> I had a few 11" diskettes for awhile.
14:49:03 * Syzygy- is not ATDP-0ldsk00l. I used ATDT.
14:49:08 * tmoertel_away still has his Apple II
14:49:17 <Syzygy-> But I did run my own BBS around 1992-ish.
14:49:22 <mr_ank> szabi_: 3rd world - I had to use ATDP for a while
14:49:24 <shapr> The father of a girl I dated had real core memory in the barn. I'd never seen the little soft iron circles before that.
14:49:38 <Syzygy-> shapr: COOOOOOOL!
14:49:58 <shapr> He almost gave it to me...
14:50:06 <Syzygy-> Hehe
14:50:17 <shapr> But I did get a slide rule from my highschool.
14:50:20 <mr_ank> you were only dating the girl for the father!
14:50:26 <shapr> hah
14:50:56 <Syzygy-> I stole my parents sliderules. Almost their entire store of it. Gave one away as a graduation gift (a neat ~10cm one), have a circular and a fullsize still around here somewhere.
14:50:59 <monochrom> I was with an ISP that had its modems misconfigured.  You would read an email or a Usenet post, and it would contain +++ATH (presumably because someone is teaching you about +++ATH).  That would trigger the ISP's modem to hang up.
14:51:07 <shapr> Today I was talking to a friend about ymodem versus zmodem and Shannon's information theory...
14:51:09 <Syzygy-> monochrom: BWAHAHAHAHA
14:51:29 <shapr> Syzygy-: Whoa, many of the circles are worth real money these days.
14:51:32 <Syzygy-> shapr: I only used them, never delved into what they did -- what's the connection to Shannon?
14:51:33 <monochrom> They probably misconfigured the time delay necessary between +++ and ATH.
14:51:34 <mr_ank> shapr: Shannon-Fano Algorithm ++
14:51:50 <shapr> mr_ank: Yeah, but that's PKZip :-)
14:51:55 <Syzygy-> afk
14:52:07 <mr_ank> i think pkzip used lz78? or lzw?
14:53:11 <shapr> Syzygy-: zmodem and Shannon connection - http://en.wikipedia.org/wiki/Turbo_codes
14:53:51 * tmoertel starts the cpu-churning rebuild of GHC 6.6 on his workstation
14:54:23 <amatus> has anyone here seen the BBS Documentary? good stuff that
14:54:38 <monochrom> map ( : "modem" ) ['x','y','z']
14:54:44 <mr_ank> amatus: i've been wanting to for a while
14:54:52 <shapr> What about kermit?
14:55:01 <monochrom> kermit is very inefficient
14:55:02 <mr_ank> kermit!
14:55:14 <mr_ank> i used it to upload stuff to my **GEEK ALERT** hp48g
14:55:14 <tmoertel> but 7-bit friendly, kermit is
14:55:38 <monochrom> By 1990 who needed 7bitfriendly?
14:55:46 <tmoertel> mr_ank: I still use my hp48sx.
14:56:08 <mr_ank> tmoertel: nice! i gave mine away a year ago or so
14:56:43 <tmoertel> mr_ank: I'll never give mine way.  The newer HP calcs don't have keys as good as the older calcs.
14:56:50 <monochrom> Sorry, forgot you guys BBSed in the 1980s
14:57:14 <amatus> mr_ank: you will enjoy it
14:59:03 <tmoertel> The GHC build process only uses a single processor.  Are their undeclared code dependencies that would break a make -jN for N > 1?
14:59:20 <djuls> lambdabot  hello
14:59:25 <djuls> lambdabot, hello
14:59:44 <bringert> @pl foldr (\x ys -> [ (x,z) : y | y <- ys, z <- colours, safeColour y x z ]) [[]]
14:59:45 <lambdabot> foldr (ap (flip . ((:) .) . (. ((y | y) <-)) . (:) . flip (,) z) ((z <- colours :) . return . flip (safeColour y) z)) [[]]
14:59:53 <bringert> that does not look right
15:00:05 <bringert> what is this: (y | y) <-)
15:00:09 <monochrom> The original is clear
15:00:29 <monochrom> pl is mistaken about |
15:00:46 <bringert> yeah, I wanted to use pl to obfuscate it and use as an example for my students
15:01:18 <monochrom> My advice: change into the do-notation, desugar the do-notation into >>='s, then pl will understand.
15:01:24 <pejo> bringert, just let your students write the code if you want it obfuscated. ;)
15:01:35 * monochrom giggles
15:01:35 <mr_ank> pejo is mean! hehehe
15:02:00 <bringert> pejo: I didn't want that kind of obfuscated
15:02:14 <SamB_XP> @. pl incomprehend foldr (\x ys -> [ (x,z) : y | y <- ys, z <- colours, safeColour y x z ]) [[]]
15:02:14 <lambdabot> compose module failed: IRCRaised Parse error: "incomprehend"
15:02:34 <dons> tmoertel: it _should_ work, -jN
15:02:47 <dons> i've certainly used it with -jN, but its not tested often, I think
15:02:58 <dons> if it doesn't, that would be worth a bug report
15:03:40 <SamB_XP> @. pl undo foldr (\x ys -> do y <- ys; z <- colours; guard $ safeColour y x z; return (x,z)) [[]]
15:03:41 <lambdabot> foldr ((=<<) . (((colours >>=) . (guard .)) .) . ap (flip . (liftM2 (>>) .) . flip safeColour) ((return .) . (,))) [[]]
15:03:51 <SamB_XP> @type foldr ((=<<) . (((colours >>=) . (guard .)) .) . ap (flip . (liftM2 (>>) .) . flip safeColour) ((return .) . (,))) [[]]
15:03:52 <lambdabot> Not in scope: `colours'
15:03:52 <lambdabot>  
15:03:52 <lambdabot> <interactive>:1:83: Not in scope: `safeColour'
15:03:56 <SamB_XP> oh right ;-)
15:04:29 <n00b-gone> what does lambdabot do with @.pl?
15:04:45 <monochrom> there is also a straightforward way to write list-comprehension as map and concat, if you want
15:04:49 <n00b-gone> @.pl foldr (+) 0
15:04:50 <lambdabot> foldr (+) 0
15:05:07 <TSC> It's just some pointless thing
15:05:22 <bringert> SamB_XP: it's question 3c from this exam: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/e4fun/oldexams/20041018.pdf
15:05:24 <lambdabot> http://tinyurl.com/y9gw33
15:05:58 <bringert> monochrom: yeah, the results of that are quite unreadable
15:07:13 <monochrom> The goal is to get lost on "executing the program and see what it does in a few examples, then guess the general"
15:07:44 <monochrom> Execution is vain.  One should apply algebraic laws and just calculate, simplify, then you'll see.
15:07:52 <dcoutts> dons, g'morning
15:08:12 <dcoutts> dons, got any time now or in the next couple hours to go through reviews ?
15:08:30 <dcoutts> I'd quite like to discuss some of them
15:09:11 <SamB_XP> @type let colours = undefined :: [()], countries = undefined :: [String] in foldr ((=<<) . (((colours >>=) . (guard .)) .) . ap (flip . (liftM2 (>>) .) . flip safeColour) ((return .) . (,))) [[]]
15:09:12 <lambdabot> parse error on input `,'
15:09:39 <SamB_XP> @type let colours = undefined :: [()]; countries = undefined :: [String] in foldr ((=<<) . (((colours >>=) . (guard .)) .) . ap (flip . (liftM2 (>>) .) . flip safeColour) ((return .) . (,))) [[]]
15:09:40 <lambdabot> Not in scope: `safeColour'
15:10:42 <monochrom> A moment ago someone was in efnet #compsci asking about the average time complexity of a simple linear search algorithm.  Have an array, look for x in it, loop from index 1 to index n.  Assuming uniform probability, what's the average number of iterations?
15:11:06 <monochrom> The asker was so asking "how to test it and get some numbers"
15:11:37 <n00b-gone> when should I use a list comprehension and when should I use filters (what is haskell programming convention)?
15:11:39 <monochrom> But of course, the denotational view gives away the answer.
15:12:02 <n00b-gone> +gremmarz
15:12:25 <monochrom> Use your mood to decide.  I do that.
15:12:52 <n00b-gone> hehe... what is a typical list comprehensive mood?
15:13:05 <n00b-gone> sad or smily face?
15:13:21 <SamB_XP> @type let colours = undefined :: [()]; countries = undefined :: [String]; safeColour = undefined :: [((),String)] -> String -> () -> Bool in foldr ((=<<) . (((colours >>=) . (guard .)) .) . ap (flip . (liftM2 (>>) .) . flip safeColour) ((return .) . (,))) [[]]
15:13:22 <lambdabot>   Couldn't match `m a' against `Bool'
15:13:22 <lambdabot>    Expected type: [((), String)] -> String -> () -> m a
15:13:28 <monochrom> You take a snapshot at the clock and the entry for the second is odd.
15:13:53 <dcoutts> n00b-gone, I would often use a list comprehension if I needed to both map and filter, or if I had multiple generators
15:14:08 <dcoutts> or if I needed to filter with a pattern match
15:14:29 <SamB_XP> arg
15:14:36 <SamB_XP> type error somewhere :-(
15:14:53 <n00b-gone> dcoutts: say you want all elements >50 from xs
15:14:56 <SamB_XP> @type guard
15:14:56 <monochrom> The GEB book is thick, but one of the messages should be drilled into programmers' heads.  The execution view doesn't tell you much.  If you ask about properties of programs, clearly you're at the meta level and the techniques of the execution level doesn't apply.
15:14:57 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:15:12 <dcoutts> n00b-gone, filter (>50)
15:15:21 <SamB_XP> @type let colours = undefined :: [()]; countries = undefined :: [String]; safeColour = undefined :: [((),String)] -> String -> () -> Bool in foldr (\x ys -> do y <- ys; z <- colours; guard $ safeColour y x z; return (x,z)) [[]]
15:15:23 <lambdabot>   Couldn't match `[((), String)]' against `(a, b)'
15:15:23 <lambdabot>    Expected type: [((), String)]
15:16:24 <dcoutts> n00b-gone, basically use the shorter and more undertandable one. So in your example compare: filter (>50) xs with [ x | x <- xs, x > 50 ]
15:16:38 <dcoutts> n00b-gone, which is shorter and more understandable ?
15:16:47 <n00b-gone> filter...
15:17:03 <dcoutts> but then say: [ foo x | Left (x,_) <- xs ]
15:17:12 <astrolabe> I prefer filter, because you can see more about what it does without reading the details.
15:17:13 <monochrom> If I express a search-and-backtrack algorithm, I use comprehension or the do-notation, e.g., http://paste.lisp.org/display/28243   This is because I actually don't care that it is a list.
15:17:37 <SamB> mmm
15:18:08 <dcoutts> n00b-gone, for some slightly trickier cases, list comprehensions can be great
15:18:08 <monochrom> If I am doing list processing instead, i.e., the listness is fundamentally inherent, I use the list combinators.
15:18:10 <astrolabe> In other words, a list comprehension is more general
15:18:51 <n00b-gone> monochrom: "fundamentally inherent"??
15:19:04 <monochrom> It's subjective.
15:19:08 <n00b-gone> ??
15:19:22 <monochrom> It's also English words.
15:19:39 <astrolabe> I think it means. the list-ness is of the essence.
15:20:02 <n00b-gone> wtf? you totally lost me...
15:20:13 <monochrom> Maybe I should write in Chinese.
15:20:55 <n00b-gone> we havent talked about any of that during class and i dont have anything to relate the expressions to...
15:21:25 <astrolabe> noob: you could always ignore it, if you don't grok it.
15:21:33 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html  has an example of treating lists and lists and therefore I use list combinators, pipelines.
15:21:36 <lambdabot> Title: The Point of Pointfree, http://tinyurl.com/jk7cd
15:21:48 <SimonRC> Where is the decorate-sort-undecorate function or similar in the standard library?  It should have type (Ord b) => (a -> b) -> [a] -> [a] but I can only find sort and sortBy?
15:21:58 <n00b-gone> astrolabe: you mean that the fact that it operates on a list is important to point out?
15:22:11 <monochrom> Who cares about classes.  You can ace them by learning things outside them.
15:22:26 <SamB> what was that replacement for comparing and equaiting?
15:22:29 <astrolabe> n00b-gone: I think that is something like what monochrom means.
15:22:29 <SamB> er.
15:22:34 <SamB> comparing and equating, rather...
15:22:50 <astrolabe> @type sortBy
15:22:51 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:23:05 <astrolabe> @type nubBy
15:23:06 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
15:23:12 <astrolabe> Is that what you meant?
15:23:22 <SimonRC> no
15:23:33 <SimonRC> I want something like:...
15:23:33 <SamB> oh, right, on. so, like, \f -> sortBy (compare `on` f) -- would be good?
15:24:09 <astrolabe> SimonRC: sorry, I was talking to SamB
15:24:31 <SimonRC> sortThe f xs = sortBy (\x1 x2 -> f x1 `compare` f x2)
15:24:43 <SamB> @type let (op `on` f) x y = f x `op` f y in on
15:24:55 <lambdabot> forall t t1 t2. (t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1
15:25:11 <SimonRC> where is the "on" funciton?
15:25:17 <SamB> it is right there ^
15:25:28 <SimonRC> oh, ok
15:25:45 <SamB> someone said something about something like that on libraries@ recently
15:25:47 <astrolabe> SimonRC: I don't understand what you function should do.
15:25:53 <SimonRC> I just thought that sortThe would be in the langage
15:25:56 <SamB> when someone sent in a patch to add "equating"
15:26:31 <astrolabe> Ah I see, sort by the pulled-back ordering.
15:26:41 <SamB> SimonRC: on is used with almost all the By functions
15:26:45 <SimonRC> astrolabe: it re-orders a list by the ordering of a function on each elemnt of the list
15:26:48 <SamB> or, rather, can be
15:27:09 <SimonRC> I prefer to define my own sortThe nubThe, etc
15:27:14 <SamB> why?
15:27:28 <astrolabe> I don't think there is such a thing in the prelude.
15:27:32 <SamB> on is a nice, simple, lightweight idiom
15:27:39 <SimonRC> hm
15:28:01 <SimonRC> maybe on should be in the prelude then, rahter than my functions
15:28:09 <SimonRC> It does appear a lot neater
15:28:14 <SimonRC> but...
15:28:38 <SamB> http://article.gmane.org/gmane.comp.lang.haskell.libraries/5227
15:28:39 <SimonRC> the function will be evaluated repeatedly, unless you explicitly decorate-sort-undecorate.
15:28:41 <monochrom> (op `on` f) = curry (uncurry op (f *** f))
15:28:41 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/yz6yrb
15:28:46 <SamB> that is the email!
15:30:14 <SamB> SimonRC: works just as well as yours, afaict
15:30:26 <SimonRC> the function will be evaluated repeatedly, unless you explicitly decorate-sort-undecorate.
15:30:36 <SamB> SimonRC: yours does exactly the same thing!
15:30:36 <SimonRC> oh, waitamo...
15:30:44 <SimonRC> that applies to both
15:31:50 <SamB> if compilers are what we say they should be, this `on` should do the same as your The functions, only in one line instead of zillions
15:32:22 <monochrom> You put too much hope into compilers!
15:32:29 <SamB> monochrom: I know
15:32:49 <SamB> but, we should make them so good if we want to get anywhere!
15:32:55 <monochrom> Fortunately, most of the time it's OK.
15:32:57 <SamB> remember what they told Ken about function calls!
15:33:20 <monochrom> What did they tell Ken about function calls?  "Functions are hard"?
15:33:24 <SamB> no.
15:33:30 <SamB> they told him they were cheap!
15:33:56 <SamB> (they weren't! but UNIX probably would be a lot worse if he had known that.)
15:33:57 <monochrom> I thought Barbie was the teller.  "Math is hard.  Let's hold functions."
15:34:11 <SamB> not *that* Ken...
15:34:26 <monochrom> I have an autograph of Ken.
15:34:36 <mux> thompson?
15:34:45 <SamB> yes, *that* ken!
15:35:00 <mux> I have a hair from the beard of ken!
15:35:02 <monochrom> Err not Ken.  Kernighan.
15:35:19 <mux> I kneel before it every day
15:35:35 <SamB> either he or dmr told ken that function calls were cheap, I think...
15:36:26 <monochrom> "function calls are cheap, you don't need to worry about tail calls"  Is that what happened?
15:37:29 <SamB> heh
15:37:37 <SamB> no!
15:37:54 <SamB> more like "function calls are cheap, feel free to use functions to give structure to your code"
15:38:04 <monochrom> such as recursion?
15:38:08 <SamB> no!
15:38:18 <SamB> such as not writing everything squashed into one big function!
15:38:28 <monochrom> recursion gives structure and interpretation to loops
15:38:49 <dylan> Has anyone done a haskell binding the slang terminal manipulation functions?
15:38:50 <monochrom> and such as not writing everything as loops
15:39:07 * SimonRC proposes the problem of sorting lists by their sums: a clasic decorate-sort-undecorate problem...
15:39:13 <SamB> and putting logic that he used in multiple places in a function, so he didn't have to do C&P programming?
15:39:21 <SamB> which is especially annoying in ed(1)
15:39:25 <SimonRC> I might like:  decorate :: (Ord b) => (a -> b) -> (((a, b) -> (a, b) -> Ordering) -> [(a, b)] -> [(a, b)]) -> [a] -> [a]
15:39:30 <SimonRC> erm, ouch
15:39:36 <SimonRC> e.g. decorate sum sortBy :: (Num n) => [[n]] -> [[n]] sorts lists by their sums
15:39:47 <SimonRC> whereas:
15:40:08 <SimonRC> decorate length sortBy :: (Num n) => [[n]] -> [[n]] sorts lists by their lengths
15:40:15 <dons> ooh, new record, 19d, 16h, 54m  17s
15:40:28 <monochrom> I have an evil idea concerning SimonRC's problem.
15:40:36 <SimonRC> and said decorations are computer once for each element of the list
15:40:38 <dons> dylan: not that I know of. no. there's many curses bindings though
15:41:07 <dylan> dons: foo. slang is a lot nicer than curses
15:41:11 * SimonRC waits in anticipation of monochrom's idea
15:41:25 <dylan> (a lot nicer = higher level of abstraction)
15:41:31 <dons> dylan: ok :) shoudn't be too hard to write a binding then?
15:41:32 <monochrom> With luck, you can avoid summing the whole of a member list.  (You sum up just enough to determine that it will have a larger sum than certain other member lists.)
15:41:37 <SamB> hmm
15:41:48 <SamB> I can't come up with a generic decoration adder...
15:41:59 <dons> dylan: I'd be interested if it really turns out to be a lot easier, http://www.cse.unsw.edu.au/~dons/code/hmp3/Curses.hsc
15:42:00 <dylan> dons: first I'll have to learn how to use it, I guess.
15:42:01 <lambdabot> http://tinyurl.com/yjyakd
15:42:02 <SamB> I mean, it would probably only work with sort...
15:42:09 <dons> dylan: to get you started ^^
15:43:08 <SimonRC> Anyway, my *original* problem would have been solved by (sortBy `on` fst), as it was in a zip-sort-unzip pattern, so futher decoration was unnecessary.
15:44:27 <dylan> dons: thanks.
15:45:02 <monochrom> I like zip-sort-unzip
15:45:48 <SimonRC> decorate dec fun = map snd . sortBy (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)
15:45:56 <SimonRC> decorate :: (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a]
15:46:02 <SimonRC> > decorate dec fun = map snd . sortBy (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)
15:46:02 <lambdabot>  Parse error
15:46:05 <SimonRC> bah
15:46:26 <SimonRC> > let decorate dec fun = map snd . sortBy (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)
15:46:26 <lambdabot>  Parse error
15:46:32 <SimonRC> > let decorate dec fun = map snd . sortBy (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id) in decorate
15:46:33 <lambdabot>  Add a type signature
15:46:46 <SimonRC> @why?
15:46:47 <lambdabot>  @where <key>, return element associated with key
15:47:02 <monochrom> You think this is matlab? :)
15:47:07 <SimonRC> @ that's *your* job
15:47:19 <SimonRC> > let decorate dec fun = map snd . sortBy (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id) in decorate :: (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a]
15:47:20 <lambdabot>  Add a type signature
15:47:24 <SimonRC> huh?
15:47:38 <monochrom> lambdabot should keep a count on its use.
15:47:54 <monochrom> When the count reaches a threshold, it replies "Use your own GHCi" XD
15:49:53 <dylan> dons: for one, there's no 'color pair' thing.
15:50:09 <dons> dylan: oh good. something more sensible?
15:50:18 <dons> (I _totally_ agree that curses sucks more than it blows)
15:51:07 <SimonRC> aha!
15:51:15 <SimonRC> I *should* have written:
15:51:25 <dylan> dons: yes, strings. "red", etc.
15:51:42 <SimonRC> decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)
15:51:45 <SimonRC> there
15:51:56 <dons> dylan: not sure if you're familiar with the haskell pretty printer combinator libraries (a bit like a reverse parsec)
15:51:58 <SimonRC> @type let decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id) in decorate
15:51:59 <lambdabot> forall a c a1 b b1 a2 b2. (Ord a1) => (a -> c) -> (((a1, b) -> (a1, b1) -> Ordering) -> [(c, a)] -> [(a2, b2)]) -> [a] -> [b2]
15:52:04 <SimonRC> feh
15:52:14 <dons> but I think we can write a good slang or curses library that uses pretty printer combinators to layout the screen
15:52:26 <dons> which would make constructing new uis really easy
15:52:34 <dons> i started on this a little with hmp3
15:52:51 <SimonRC> @type let {decorate : (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a] ;decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)} in decorate
15:52:52 <lambdabot> parse error on input `=>'
15:52:54 <dons> (there'd be a paper for the haskell workshop in it , if we get it working ... ;)
15:52:56 <SimonRC> gah
15:53:05 <SimonRC> @type let {decorate :: (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a] ;decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)} in decorate
15:53:06 <lambdabot> (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a] ;decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)} in decorate :
15:53:06 <lambdabot> : forall a b. (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a]
15:53:08 <dons> dylan: so use newtypes to define boxes in the ui, http://www.cse.unsw.edu.au/~dons/code/hmp3/UI.hs
15:53:09 <lambdabot> http://tinyurl.com/y72vnx
15:53:22 <dons> and then just layout the screen by rendering each box
15:53:30 <dons> however, Text.PrettyPrint shows the true way
15:53:50 <dons> dylan: oh, also, you might be able to resuse some of the colour handling code, http://www.cse.unsw.edu.au/~dons/code/hmp3/Style.hs
15:53:51 <lambdabot> http://tinyurl.com/y5p6cf
15:54:45 <SimonRC> > let {decorate :: (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a] ;decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)} in decorate sum sortBy [[9], [3,3], [1,1,1]]
15:54:46 <lambdabot>  [[1,1,1],[3,3],[9]]
15:54:50 <SimonRC> yay!
15:54:54 <SimonRC> > let {decorate :: (Ord b) => (a -> b) -> (((b, a) -> (b, a) -> Ordering) -> [(b, a)] -> [(b, a)]) -> [a] -> [a] ;decorate dec fun = map snd . fun (\(x1, _) (x2, _) -> x1 `compare` x2) . map (dec &&& id)} in decorate length sortBy [[9], [3,3], [1,1,1]]
15:54:56 <lambdabot>  [[9],[3,3],[1,1,1]]
15:55:06 <SimonRC> oh, wait, maybe it's backwards
15:55:14 <SimonRC> no, that;s right
16:01:20 <kpreid> can STM be used to emulate deterministic execution? that is, in addition to looks-atomic, it also looks-in-predefined-order?
16:01:41 <SamB> if you want that...
16:01:52 <SamB> wouldn't it be more appropriate to, say, not use threads?
16:02:20 <dons> ?where hsx
16:02:20 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
16:02:22 <monochrom> If there is one thread, it's deterministic.
16:04:44 <monochrom> funny name
16:04:46 <dons> kpreid: you could write your own scheduler with yield and threadDelay
16:04:57 <dons> and thus do whatever you want.
16:05:09 <kpreid> hm
16:05:56 <kpreid> the goal would be "look like single-threaded fine-grained event loop, but take advantage of them 80 cores, assuming the events are mostly independent"
16:06:35 <kpreid> hm, ah, that last bit isn't really possible
16:06:56 <kpreid> since one don't know soon enough what state the later events care about
16:07:02 <monochrom> If only you remove "predefined"
16:07:32 <monochrom> looks-in-some-sensible-order is both sufficient and necessary
16:08:03 <monochrom> but then you get that for free using STM :)
16:12:33 <shapr> dcoutts: Could I get a copy of your unfinished Binary serialization ideas code?
16:12:40 <dcoutts> shapr, sure
16:14:51 <ndm> anyone got any experience with Text.PrettyPrint.HughesPJ ?
16:14:59 <lennart> yes
16:15:07 <ndm> i want to output function style definitions
16:15:09 <ndm> so:
16:15:13 <ndm> f arguments = value
16:15:14 <ndm> or:
16:15:22 <ndm> f arguments =
16:15:24 <ndm>     value
16:15:29 <ndm> depending on how big value is
16:15:32 <ndm> how do i do that?
16:16:05 <ndm> i know there is nest and <>, but don't see how to do "either | or"
16:16:05 <lennart> sep [..., nest 4 ...]
16:16:06 <n00b-gone> anyone know how to get vim/gvim to automatically signal when closing a parentheses?
16:16:43 <dibblego> can lazy evaluation exist without proof of purity of functions?
16:16:45 <lennart> where the first ... is the 'f args =', and the second is 'value'
16:16:57 <ndm> @karma+ lennart
16:16:57 <lambdabot> lennart's karma raised to 1.
16:16:59 <ndm> thanks :)
16:17:09 <lennart> dibblego: sure
16:17:10 <dibblego> hey ndm, does Yhc compile to JVM bytecode?
16:17:26 <ndm> i can't find any tutorial stuff on the pretty printer, only the original Hughes paper, which is a bit dry...
16:17:41 <ndm> dibblego: no, it compiles to IL, and has an interpretter written in Java, but no JVM
16:17:47 <lennart> dibblego: but lazy evaluation with impure functions is a bit of a nightmare
16:18:03 <dons> n00b-gone: set showmatch
16:18:23 <dibblego> ndm, what does the interpreter interpret exactly?
16:18:32 <SimonRC> dibblego: just try playing with Debug.Trace some time to see how tough things can get
16:18:35 <n00b-gone> dons: u r teh l33t
16:18:55 <ndm> dibblego: .hbc files, haskell byte code, from Yhc
16:19:00 <dibblego> well I am sure they get tough
16:19:01 <SimonRC> Admittedly, I have had one bug that was very tricky to track down due to lazy evaluation.
16:19:34 <dcoutts> lennart, aye, for exmaple nearly all the runtime verification examples I've seen (where people are building program monitors using eg aspect-oriented techniques) it's for problems of delayed evaluation and mutability that simply don't exist in pure FP
16:19:39 <SimonRC> I kept showing the datastructure, and it was fine, but there was a mysterious "head of empty list" every time I tried to *use* said datastructure.
16:19:59 <SimonRC> Turned out to be a bad assumption in my professor's code :-#
16:20:12 <dibblego> I am trying to point the Java programmer at the fact that he/she is reinventing functional programming - one aspect is that he prefers java.io.InputStream (lazily evaluated) over the byte[] (strictly evaluated) -- I'm not sure how to word it for appeal
16:20:19 <dcoutts> lennart, eg the safe iterator, once you've got an iterator for a collection you're not allowed to modify that collection 'til you're done with the iterator
16:20:23 <SimonRC> (he assumed that all email addresses in a usenet newsgroud would have an @ in them)
16:20:56 <lennart> dcoutts: yes, it's full of pitfalls
16:20:59 <dcoutts> lennart, apparently it's a classic mistake in Java progs etc, you hand out iterators to unrelated bits of code and then it's realyl hard to think about how long those things are livs for
16:20:59 <dibblego> SimonRC, I wouldn't blame lazy evaluation for that
16:21:14 <SimonRC> strictness might have helped
16:21:22 <SimonRC> or at least given me a astack trace
16:21:25 <dibblego> sure, it probably would have detected the bug earlier
16:21:34 <SimonRC> dibblego: you could try showing them some equivalent Java and Haskell code.
16:21:56 <SimonRC> I have seen 5:1 differences between C# and Haskell (estimated).
16:22:10 <lennart> SimonRC: strictness would only have helped in the sense of giving you the error at a different time
16:22:22 <dibblego> I'm not even going to talk about haskell - just mention some aspects of functional programming
16:22:26 <SimonRC> maybe something nasty with infinite trees and Monad {}
16:22:28 <SimonRC> maybe something nasty with infinite trees and Monad []
16:22:35 <dibblego> but I have used haskell in other areas
16:23:19 <shapr> sjanssen: Is you 2-3 finger tree bytestring chunking code available?
16:23:35 <SimonRC> dibblego: Trying to promote functional programming in Java is like trying to promote a swimming style in a desert.
16:23:49 <dibblego> SimonRC, it's not for promotion
16:24:02 <SimonRC> okok
16:24:16 <dibblego> SimonRC, and I'm not doing that anyway - just appealing to a Java programmer in his language - I only briefly mention haskell, FP, etc.
16:24:17 <SimonRC> dibblego: Trying to explain functional programming in Java is like trying to explain a swimming style in a desert.
16:24:31 <dibblego> I won't explain it - just reference it - for that exact reason :)
16:24:35 <SimonRC> hmm
16:24:43 <dibblego> an avid reader would google - most would ignore it
16:24:55 <dibblego> I accept that
16:25:27 <dibblego> all my reviewers are Java programmers with little or no understanding of these topics
16:25:37 <dibblego> <quote>programmers</quote>
16:25:53 <SimonRC> You could say that the programmer is "re-inventing lazy evaluation, which is a major feature of some functional programming languages (but not Java)".
16:26:04 <dibblego> right
16:26:07 <SimonRC> ah!...
16:26:47 <SimonRC> the obvoius thing to show people when talking about lazy evaluation:
16:26:49 <SimonRC> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
16:26:53 <lambdabot> Title: Why Functional Programming Matters, http://tinyurl.com/e4jve
16:27:31 <SimonRC> a great demonstration of how infinite lists of infinite lists of functions ... (etc) can be useful
16:28:27 <Cale> yeah, laziness is somewhat crucial for getting the most out of functional programming
16:29:02 <dcoutts> dibblego, I know a researcher who works with Java. He's got a attribute grammar system. It emulates lazy evaluation to great effect. However so as not to scare the clients who are all Java programmers, they market it as 'demand driven' :-)
16:29:10 <Cale> and it's important that it be pervasive because a little bit of strictness in the wrong place can really mess up one's ability to get good use out of it.
16:29:36 <dibblego> dcoutts, really? what's the name of it?
16:30:46 <dcoutts> dibblego, I forgot to ask :-) we'd drunk quite a bit of wine at that conference :-)
16:31:13 <dons> dcoutts: heh. "demand driven". quoted!
16:31:13 <dibblego> dcoutts, I have written a bunch of lazily evaluated data structures a long time ago
16:31:40 <dcoutts> dons, ;-)
16:31:49 <dibblego> or an interface and functions over the types that evaluate lazily I should say
16:32:15 <dibblego> I might use that marketing term :)
16:32:21 <dons> I wonder if "demand driven" would have been a better marketing strategy
16:32:25 <dons> "lazy" has some bad connotations
16:32:27 <dons> oh well
16:32:43 <SimonRC> which of you has that file "Nightmare.java" on his/her blog?
16:32:43 <shapr> non-strict?
16:32:45 <dcoutts> it's a very operational point of view
16:32:50 <dcoutts> but one that I quite like
16:32:52 <dons> its a useful phrase anyway, for explaing to newbies
16:32:54 <dons> yeah
16:33:01 <dcoutts> I find it helps me to think about what's going on
16:33:13 <dcoutts> at least when trying to optimise code
16:33:26 <dibblego> SimonRC, code.google.com ?
16:33:30 <dcoutts> when it's useful to know what is going on at the machine level
16:33:31 <emu> why won't this thing work!?! because it's lazy!
16:33:53 <\z> Cale: Are you responsible for http://www.haskell.org/haskellwiki/New_monads/MonadSupply ?
16:33:55 <dibblego> lazy means it will only work if you kick it up the arse and nobody likes doing that - especially if their kids have left home
16:33:55 <lambdabot> Title: New monads/MonadSupply - HaskellWiki, http://tinyurl.com/ym95qy
16:34:00 <shapr> Anyway, someone compared scheme's streams to non-strictness, but the problem there is that you're limited to single dimensional traversal. With ubiquitous non-strictnes, you can traverse multiple dimensions of a data structure at the same time.
16:34:02 <Cale> \z yes
16:34:06 <\z> Cale++
16:34:16 <Dreadshoot> anyone uses hs-plugins in win?
16:34:17 <SimonRC> aha!  here it is:
16:34:18 <SimonRC> http://www.vex.net/~trebla/humour/Nightmare.java
16:34:20 <lambdabot> http://tinyurl.com/vdcy7
16:34:27 <shapr> That would be monochrom
16:34:29 <\z> Really clear and easy to follow.
16:34:29 <SimonRC> that is some FP-ish things in Java
16:34:38 <\z> Thanks muchly!
16:34:43 <dcoutts> shapr, aye, they could do lazy bytestrings but not fingers trees of chunks
16:34:53 <Cale> \z: Happy to hear that you're getting use out of it :)
16:35:08 <dibblego> SimonRC, you don't want see what I did - I went to a much greater extreme :)
16:35:10 <SimonRC> it uses Java catches to do case statements
16:35:13 <\z> Oh, and who is responsible for the .. deriving(Monad) magic in 6.6?
16:35:30 <Cale> That's not just 6.6
16:35:48 <SamB_XP> \z: what do you mean?
16:35:53 <SamB_XP> for newtypes?
16:35:55 <Cale> You can derive anything through a newtype which is supported on the original type.
16:35:57 <SimonRC> dibblego: I tried writing in a functional style in C# ... "Argh!  The delegates!"
16:36:00 <\z> I was reading the release notes.  Seems like it's a recent add (since 6.4.x)
16:36:05 <Cale> With newtype-deriving
16:36:15 <SimonRC> Cale: cool
16:36:15 <\z> SamB_XP: Yep.  Haven't seen it before.
16:36:21 <SamB_XP> \z: what release notes?
16:36:41 <dibblego> SimonRC, I had partial application, lazy evaluation, etc. - but failed only due to lack of tail call elimination
16:36:46 <\z> SamB_XP: http://www.haskell.org/ghc/docs/latest/html/users_guide/release-6-6.html
16:36:47 <dibblego> SimonRC, I've considered retrying in C#
16:36:48 <lambdabot> Title: 1.4. Release notes for version 6.6, http://tinyurl.com/ydwkq4
16:37:11 <dibblego> SimonRC, the basic premise is interface F<X, Y>{Y f(X x);} and I defined everything in terms of f
16:37:24 <\z> Cale: Really?  That's the only restriction?
16:37:30 <\z> That wasn't entirely clear from the manual
16:37:57 <\z> I did get the point about hand deriving Num a => Dollar a vs. Dollar a deriving (Num)
16:38:31 <Cale> It was in 5.04
16:38:38 <\z> Really?
16:38:49 <\z> Wow.  I must have missed that.
16:39:43 <\z> I remember working through mtl for a few days before I figured out how they were cross-wired.  The new monads look *MUCH* cleaner.
16:39:45 <Cale> and I don't think it was in 5.02, at least, if it was then it wasn't documented
16:39:56 <Cale> hm?
16:40:02 <Cale> Have they been changed?
16:40:32 <Cale> MonadSupply just inherits all its behaviour from MonadState
16:41:30 <Cale> I think there may be some restrictions on newtype deriving with particularly complicated classes.
16:41:38 <\z> instance (Monad m) => Monad (StateT s m) where
16:41:40 <\z> instance (MonadIO m) => MonadIO (StateT s m) where
16:41:46 <\z> instance (MonadReader r m) => MonadReader r (StateT s m) where
16:41:48 <\z> etc.
16:42:25 <\z> If I'm reading the new monads properly, they're composable without all of the added instance declarations
16:42:32 <\z> Or is that because they're just building on top of mtl?
16:42:49 <Cale> Well, I just left those instances out.
16:43:21 <Cale> Of course, you can always use lift, because of inheriting MonadTrans
16:43:21 <\z> Ah.  So to make the new monads equally flexible, they need just as many instance declarations?
16:43:34 <Cale> yeah, at least, the transformers
16:43:37 <\z> Yeah, that's probably what I was thinking of.
16:44:22 <Cale> Though usually the way that I do things, that's not much of a problem. When I use monad transformers, I always newtype anyway.
16:45:03 <Cale> and define any instances the way that I want, which gives me the opportunity to stick in things like consistency checks and such.
16:45:14 <\z> example?
16:45:21 <profmakx> > P = NP
16:45:22 <lambdabot>  Parse error
16:45:25 <profmakx> hmpf
16:45:45 <Cale> http://www.haskell.org/haskellwiki/Sudoku
16:45:46 <lambdabot> Title: Sudoku - HaskellWiki
16:46:36 <Cale> I just implemented the trivial brute-force algorithm in the end because it was so easy :)
16:46:47 <Cale> But you could use the same monad with more complex algorithms.
16:47:59 <\z> Hm...maybe I just never came across newtype-deriving.  When I started writing monads, I remember writing out the Monad instances by hand.
16:48:17 <\z> Which is an interesting exercise.  Precisely once.  ;-)
16:48:27 <Cale> Well, in general, you still have to, but the mtl gives you a good set of "large" starting points.
16:49:12 <Cale> where you could at least be saved from writing the Monad and Functor instances, if not instances of other classes.
16:49:14 <\z> Maybe that's what I'm remembering.  I remember writing a stateful monad that had two states.  I forget why, but it was an interesting learning exercise.
16:49:21 <\z> And then I realized it was just StateT State.
16:49:31 <Cale> or State (s,t) :)
16:50:17 <\z> Any plans to package up newmonads?  Or just leave them for inspiration on the wiki?
16:52:06 * SamB_XP wonders if the derivative of $mv^2$ is really $2mav$...
16:57:28 <ndm> SamB_XP: i learnt pretty printing now, so will give Yhc.Core the treatment at some point soon :)
16:57:48 <ndm> it certainly makes my code easier to read!
16:58:06 <SamB_XP> yes!
17:01:11 <musasabi> Is there a way to tell haskell to make some top-level function polymorphic without writing the overly complex type signature?
17:03:05 <kpreid> well, there's {-# OPTIONS -fno-monomorphism-restriction #-}...
17:03:22 <kpreid> or figure out how to define it with arguments
17:06:00 <musasabi> not nice for a single function definition.
17:06:09 <musasabi> Just that the type is 3x longer than the code.
17:06:44 <dons> musasabi: hmm, type alias?
17:06:58 <dons> or use typeOf script to infer the types for you...
17:08:53 <dons> hey, SoC summit group photo from inside google, http://photos1.blogger.com/blogger/4778/2884/1600/GSoCMentorSummitStairs.jpg
17:08:55 <lambdabot> http://tinyurl.com/yytxs5
17:09:14 <dons> see if you can play "Where's Don?" :)
17:11:13 <musasabi> dons: too many typevars for an alias. but I think I can live with it.
17:11:50 <dibblego> dons, I'm about to book for APLAS06
17:11:56 <dons> dibblego: me too!
17:12:03 <Cale> hehe, I got a Google t-shirt even though I didn't end up mentoring anything
17:12:06 <dibblego> the early registration date ends today :)
17:12:18 * dibblego DDOS attacks aplas.com with dons 
17:12:27 <dibblego> (or whatever it is)
17:12:29 <dons> Cale: yeah, every one who volunteered as a mentor gets one
17:12:46 <dons> Cale: is your black? are they all black?
17:13:05 <dons> e.g. http://cgi.cse.unsw.edu.au/~dons/blog/2006/10/19#tshirt
17:13:06 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/yndavz
17:13:19 <dons> (I'm just wondering what the colour field in the sign up form was for, if the tshirts are all black anyway)
17:13:37 <Cale> heh
17:13:43 <Cale> maybe it was a vote
17:19:24 <Cale> Did you ever make a combined benchmark graph of fps 0.1 vs. the latest Data.ByteString?
17:20:00 <dons> nope, the api was too different, such that i got bored half way through
17:20:05 <dons> (i.e. takePS versus P.take
17:20:48 <Cale> ah
17:23:25 <dibblego> dons, any decent hotels near UNSW? the ones on the web site look a little dodgy
17:24:57 <Igloo> What's happening near/at UNSW?
17:25:22 <dibblego> APLAS06
17:26:01 <dibblego> http://www.cse.unsw.edu.au/~aplas06/
17:26:02 <lambdabot> Title: APLAS'06
17:26:16 <Igloo> Is Australia part of Asia now?
17:26:52 <dibblego> Asia/Pacific
17:27:25 <dibblego> I think ASIAN is an acronym
17:27:36 <dons> dibblego: not near UNSW, no. but in the city there's heaps, only 20 or so mins from UNSW
17:27:45 <dons> Igloo: yeah, asia/pacific
17:27:52 <dibblego> dons, so I'm finding out - thanks
17:28:55 <dibblego> how far (walking) is Crowne Plaza?
17:29:58 <n00b-gone> need syntax help: using filter and a lambda function; how do i get all (x,y) from zip [1..10] [10..1] so that y >50 ??
17:30:19 <n00b-gone> *y > 5*
17:32:16 <Cale> filter (\(x,y) -> y > 5)
17:32:31 <TSC> I think Peter Stuckey's name is misspelt on the programme, if it's the one I'm thinking of
17:32:40 <dcoutts> @pl (\(x,y) -> y > 5)
17:32:40 <lambdabot> (> 5) . snd
17:32:54 <n00b-gone> wtf?
17:33:06 <dcoutts> (\(x,y) -> y > 5) = (> 5) . snd
17:33:26 <n00b-gone> @pl (>5) . snd
17:33:26 <lambdabot> (> 5) . snd
17:33:32 <n00b-gone> @.pl (>5) . snd
17:33:33 <lambdabot> (> 5) . snd
17:33:48 <dons> dibblego: hmm. isn't that quite a way? in Darling Harbour?
17:33:58 <dons> dibblego: getting something near Hyde Park would be more convenient, I think
17:34:00 <dibblego> dons, I'm struggling to find UNSW on whereis
17:34:04 <n00b-gone> what's it good for?
17:34:14 <dibblego> so I need the frame of reference before I even care :)
17:34:17 <Cale> The @pl command will convert a lambda expression or function declaration into points-free form (which means that the values being acted on by the function are not mentioned)
17:34:31 <Cale> It also does some simplification while it's at it.
17:34:36 <dons> its in Kensington, next to Randwick race course
17:34:52 <dons> ?pl \ f x y -> f x (f y)
17:34:52 <lambdabot> flip =<< ((.) .)
17:34:57 <shapr> Man, I want to go on sabbatical to live near UNSW.
17:35:14 <dons> ?
17:35:20 <dibblego> Anzac Pde Kensington?
17:35:20 <n00b-gone> @pl (\x -> x+2)
17:35:21 <lambdabot> (2 +)
17:35:27 <dons> dibblego: yep
17:35:31 <Cale> @pl \x y -> f x (f y)
17:35:32 <lambdabot> (. f) . f
17:35:37 <dibblego> ta
17:35:47 <dcoutts> > [ (x,y) | x <- [1..10] | y <- [10,9..1], y > 5 ]
17:35:48 <lambdabot>  Parse error
17:35:48 <n00b-gone> dons: i think you can see what level i'm at... :/
17:35:49 <dons> just follow Anzac Pde down passed the SCG, and you'll see it.
17:35:51 <Cale> @pl \x y z -> x z (y z)
17:35:52 <lambdabot> ap
17:36:00 <dcoutts> dons, no parallel list comprehensions ?
17:36:06 <dons> not in h98, no.
17:36:17 <dcoutts> and > is h98 ?
17:36:17 <dons> won't parse.
17:36:23 <dons> the parse is , yeah.
17:36:27 <dcoutts> ah ok
17:39:11 <dibblego> dons, seen this? http://www.computerworld.com.au/index.php/id;710118083;relcomp;1 NICTA "We also use the functional language Haskell for rapid prototyping and as a specification language. Its use greatly simplifies the mathematical reasoning required for the formal verification, even though the final product is not written in Haskell"
17:39:14 <lambdabot> http://tinyurl.com/yxe548
17:39:18 * SamB_XP doesn't think the GHC docs should talk about the -fffi flag - the -ffi flag is so much prettier
17:39:22 <dons> dibblego: yep
17:39:37 <Igloo> -fffi is a hideous blemish!
17:39:40 <Igloo> Err
17:39:42 <Igloo> -ffi is a hideous blemish!
17:39:43 <dons> dibblego: that's my OS lecturer talking :)
17:40:02 <dons> i prefer -ffffffii
17:40:17 <dibblego> ah right
17:40:32 <dcoutts> Igloo, make it emit a warning
17:40:33 <Cale> heh, it should just allow -(f^n)(i^m)
17:40:41 <SamB_XP> Igloo: -ffi may be a hack, but it still reads a lot better than -ffi...
17:40:44 <SamB_XP> er.
17:40:46 <SamB_XP> than -fffi
17:40:51 <SamB_XP> or -ffffffffi
17:41:02 <dcoutts> Igloo, similarly on other deprecated flags, like wtf is -syslib ? apparently an aincent alias for package ?
17:41:07 * Igloo decides to implement an FI feature
17:41:13 <dibblego> dons, which talking exactly?
17:41:27 <Igloo> dcoutts: Yeah. I have a vague plan to emit a warning for deprecated flags, but haven't got around to it yet
17:41:31 <SamB_XP> what, they didn't take out -ffi did that?
17:41:36 <dcoutts> Igloo, great
17:41:36 <dibblego> dons, you mean that quote?
17:41:37 <SamB_XP> or deprecate it?
17:41:43 <SamB_XP> the other one is too ugly
17:41:52 <dcoutts> it's consistent
17:41:58 <dibblego> dons, Heiser is your OS lecturer?
17:42:04 <Igloo> So, what should FIs do? Answers on a postcard!
17:42:06 <dons> dibblego: oh, the author is Gernot heiser, my operating systems class professor
17:42:17 <SamB_XP> that is why I don't think either one should be deprecated...
17:42:28 <dibblego> ah
17:42:29 <dcoutts> Igloo, if condion then one else other fi ?
17:42:44 <dons> I _almost_ did my honours thesis with him hacking kernels, instead of with ChiliX, hacking GHC :)
17:42:45 * SamB_XP sends Igloo a postcard to the effect that FIs should juts turn on FFI and bonk Igloo on the head
17:43:00 <dcoutts> dons, you made a good choice :-)
17:43:15 <dons> yeah, I reckon. since the OS group hacks  Haskell now anyway :)
17:43:15 <n00b-gone> foldr (max) ==> WHAT is my base case? ([]=????) -inf seems kinda impossible...
17:43:26 <dcoutts> SamB_XP, sounds like a very heavy and/or violent postcard!
17:43:40 <dcoutts> dons, hah hah, yeah
17:43:45 <SamB_XP> dcoutts: no, that was my suggested behavour for FIs
17:43:55 <n00b-gone> 0 will render it useless for negative elements
17:44:15 <dcoutts> SamB_XP, oh FI's should bonk one on the head?
17:44:21 <SamB_XP> no, just Igloo
17:44:22 <dcoutts> n00b-gone, see foldr1
17:44:27 <SamB_XP> for being such a smartass
17:44:50 <dcoutts> SamB_XP, ah, if username == "igloo" then ...
17:45:02 <SamB_XP> no. more like:
17:45:07 <SamB_XP> bonk "Igloo"
17:45:10 <n00b-gone> dcoutts: teh thankz0rz
17:45:13 <SamB_XP> enable "ffi"
17:47:30 <dibblego> dons, according to whereis, Crowne Plaza (Carr St, Coogee) is 2.83km from UNSW - that shouldn't be too bad
17:47:33 <SamB_XP> hmm, this newtype-unwrapping behaviour of the FFI seems a bit unclean...
17:47:48 <SamB_XP> because newtypes are *supposed* to be an abstraction...
17:47:57 <dcoutts> yeah, I agree
17:48:18 <SamB_XP> with the only thing in common being the *heap* representation...
17:48:20 <Igloo> Only for the Haskell typechecker
17:48:32 <SamB_XP> Igloo: I disagree
17:48:37 <dcoutts> perhaps it should be restricted to modules which can see the constructor
17:48:42 <SamB_XP> just because that is all it had to be *before* FFI...
17:48:43 <dcoutts> or done away with completely
17:49:04 <SamB_XP> I think it should be made explicit somehow!
17:49:15 <dcoutts> and why one can use Int in FFI is beyond me
17:49:39 <Igloo> Because you don't know what C type to convert it to without losing precision
17:49:47 <dcoutts> well it corresponds to HsInt
17:49:55 <SamB_XP> I suppose that is why.
17:50:05 <dcoutts> which is a C type, but people usually get it wrong
17:50:06 <SamB_XP> so you can implement things in C that use Haskell-ish types.
17:50:13 <Igloo> Yes, but that type wouldn't exist if you couldn't use Int with the FFI
17:50:17 <dcoutts> and think it corresponds to C's int
17:50:24 <SamB_XP> dcoutts: me too ;-)
17:50:34 <SamB_XP> I obviously need to use Yhc more.
17:50:42 <Igloo> If you couldn't pass Int then people would just convert to CInt, and truncate values on 64-bit arches
17:50:48 <SamB_XP> maybe Yhc should have a mode to deliberately break that?
17:51:03 <dcoutts> Igloo, as it is, people use Int and it breaks on 64bit arches anyway
17:51:06 <SamB_XP> I with "1" tag bits ;-)
17:51:07 <SamB_XP> er.
17:51:10 <SamB_XP> i.e.
17:51:19 <Igloo> It only breaks if they do it wrong, currently
17:51:23 <dcoutts> true
17:51:33 <dcoutts> we need a checker like c2hs
17:51:38 <dcoutts> and have it used more
17:51:47 <SamB_XP> mmm
17:51:55 <dcoutts> the C compiler is a poor checker of C <-> Haskell type consistency
17:51:59 <SamB_XP> yes
17:52:08 <SamB_XP> it is a bad enough checker of *C* type consistancy!
17:52:09 <dcoutts> C prototypes include promotion rules etc
17:52:19 <dcoutts> heh
17:52:24 <Igloo> We could have an   Int{-# I REALLY MEAN IT #-} pragma for foreign decls
17:52:27 <SamB_XP> I mean, C has no newtypes
17:52:34 <dcoutts> Igloo, hah hah
17:52:46 <Igloo> And then warn if it's not given
17:52:49 <SamB_XP> how about a {-# DCOUTTS #-} pragma
17:52:56 <Igloo> it wouldn't be much of a burden if real uses of Int are rare
17:53:00 <dcoutts> SamB_XP, what might that do ?
17:53:10 <SamB_XP> dcoutts: it would imply that I knew what I was doing?
17:53:16 <dcoutts> randomly add strictness / lazyness and convert to ByteStrings ?
17:53:20 <SamB_XP> heh
17:53:38 <qwr> huh, good luck using C compiler for checking something ;)
17:53:51 <SamB_XP> qwr: that is clearly a no-starter ;-)
17:53:52 <dcoutts> Igloo, with a c2hs-like checker we could just check that Int is being used to correspond to HsInt on the C side
17:54:10 <dcoutts> cabal lint
17:55:09 <Igloo> dcoutts: How would that work exactly? By type size, by name or what?
17:55:23 <dcoutts> Igloo, c2hs does this already
17:55:39 <dcoutts> Igloo, but for generating Haskell types from C ones, rather than for checking consistency
17:55:43 <Igloo> To be pedantic, you'd need to check that after some number of typedef substitutions it was HsInt
17:55:46 <dcoutts> but it's the same sort of thing
17:55:57 <dcoutts> right
17:56:06 <Igloo> But c2hs does it by type size, right? So your check done that way would always pass on x86
17:56:23 <dcoutts> c2hs has the full typedef info, so that check would be easy
17:56:23 <SamB_XP> to be truly thorough, it would need to check with all possible Haskell compilers, options, and OSes...
17:56:46 <dcoutts> checking that the type as a chain of typedef ends in HsInt
17:56:53 <SamB_XP> hmm.
17:56:58 <SamB_XP> but
17:57:05 <SamB_XP> HsInt might *be* a typedef!
17:57:11 <dcoutts> of course it is
17:57:15 <dcoutts> doesn't matter
17:58:26 <dcoutts> so the check would work, independent of the current size of C int or HsInt
17:59:23 <dibblego> dons, any idea how long a taxi from the airport to unsw would take?
18:06:02 <n00b-gone> http://paste.lisp.org/display/28339 <-- apparently x /= x
18:07:13 <dcoutts> (maxa . nega) a /= maxa . nega a
18:07:38 <Lajexander> ehm... how does this work?
18:07:44 <dcoutts> Lajexander, remember that function application binds tighter than operators
18:08:08 <dcoutts> 1 + f 2 = 1 + (f 2) not (1 + f) 2
18:08:27 <dcoutts> so that is: maxa . nega a = maxa . (nega a)
18:08:32 <Lajexander> does it make a unified function first with negmax before computing?
18:08:50 <dcoutts> it's simply a matter of syntax
18:09:26 <dcoutts> "maxa . nega a" is parsed as "maxa . (nega a)"
18:09:40 <dcoutts> because function application has the highest precedence
18:09:46 <Lajexander> yah
18:10:05 <Lajexander> but can't maxa handle that?
18:10:15 <dcoutts> so you'd need to write (maxa . nega) a
18:10:31 <dcoutts> because  maxa . nega a  means something else
18:10:33 <dcoutts> see ?
18:10:59 <lennart> but maxa $ nega a would work
18:11:24 <dcoutts> or maxa . nega $ a
18:11:34 <dcoutts> but that's probably just going to confuse you :-)
18:11:50 <Lajexander> i get the error, i don't get exactly why... but maxa takes [Int], not ([Int]->[Int])
18:12:30 <Lajexander> (so how could . work in the first case?)
18:12:40 <newsham> ioerror: the bot here has some haskell stuff built in to help test and explain stuff on irc.
18:12:43 <newsham> > 1 + 2
18:12:44 <lambdabot>  3
18:12:47 <ioerror> nice
18:12:59 <ioerror> is this the irc bot that you linked me to?
18:13:15 <newsham> > let fac n = if n == 0 then 1 else (n * fac (n - 1)) in fac 5
18:13:16 <lambdabot>  120
18:13:32 <newsham> ioerror: sort of..  thats written by th esame guy, but the tutorial is simplified.
18:14:04 <newsham> > map succ "foobar 12345"
18:14:05 <lambdabot>  "gppcbs!23456"
18:14:11 <ioerror> cool stuff, I'm looking forward to learning about all of this. Thanks for the pointers newsham
18:15:26 <lennart> > map pred "foobar 12345"
18:15:27 <lambdabot>  "enna`q\US01234"
18:15:42 <newsham> > map (pred . succ) "foobar 12345"
18:15:43 <lambdabot>  "foobar 12345"
18:16:16 <newsham> > map (* 2) [1,3..9]
18:16:18 <lambdabot>  [2,6,10,14,18]
18:16:21 <lennart> > map (pred . (^2) . succ) "foobar 12345"
18:16:21 <lambdabot>  add an instance declaration for (Num Char)
18:16:59 <lennart> map (pred . (^2) . fromEnum . succ) "foobar 12345"
18:17:14 <lennart> > map (pred . (^2) . fromEnum . succ) "foobar 12345"
18:17:16 <lambdabot>  [10608,12543,12543,9800,9603,13224,1088,2499,2600,2703,2808,2915]
18:17:40 <Lajexander> map succ "g`rjdkk"
18:17:49 <Lajexander> > map succ "g`rjdkk"
18:17:51 <lambdabot>  "haskell"
18:17:55 <Lajexander> :)
18:17:58 <lennart> :)
18:18:16 <newsham> > [succ x | x <- "g`rjdkk"]
18:18:17 <lambdabot>  "haskell"
18:18:44 <Lajexander> > map succ "btqqx\USld\US&shkk\USh\USono "
18:18:46 <lambdabot>  "curry me 'till i pop!"
18:18:55 <newsham> > [succ x | x <- "g`rjdkk", x \= 'a']
18:18:55 <lambdabot>  Not in scope: `\='
18:18:58 <Lajexander> yay!
18:18:59 <lennart> > map (foldr (.) id (replicate 5 succ) "hello"
18:19:00 <lambdabot>  Parse error
18:19:06 <newsham> > [succ x | x <- "g`rjdkk", x /= 'a']
18:19:07 <lambdabot>  "haskell"
18:19:17 <lennart> > map (foldr (.) id (replicate 5 succ)) "hello"
18:19:18 <lambdabot>  "mjqqt"
18:19:39 <Lajexander> lennart: what did that do?
18:19:50 <newsham> he put together succ 5 times (with id)
18:20:05 <arjanoosting> Igloo: do we have a working ghci on alpha yet?
18:20:12 <newsham> > map (succ . succ . succ . succ . succ . id) "hello"
18:20:13 <lambdabot>  "mjqqt"
18:20:16 <lennart> Lajexander: it made a list with 5 succ, then put them together with function composition and applied it to the string
18:20:54 <newsham> coulda skipped "id" w/ foldr1
18:20:54 <lennart> > map (foldr1 (.) (replicate 5 succ)) "hello"
18:20:55 <lambdabot>  "mjqqt"
18:21:08 <newsham> like so :)
18:21:08 <Lajexander> why the . ?
18:21:18 <newsham> (.) joins them.  its function composition
18:21:19 <lennart> it's function composition
18:21:39 <newsham> (succ . succ) is a function (\x -> succ (succ x))
18:22:00 <newsham> > (+ 1) 5
18:22:01 <lambdabot>  6
18:22:07 <newsham> > ((+ 1) . (+ 2)) 5
18:22:08 <lambdabot>  8
18:22:17 <Lajexander> @pl (\x -> succ(succ x))
18:22:18 <lambdabot> succ . succ
18:22:34 <Lajexander> >succ.succ 0
18:22:46 <Lajexander> > succ . succ 0
18:22:47 <lambdabot>  add an instance declaration for (Num (a -> b))
18:22:54 <newsham> > (succ . succ) 0
18:22:55 <lambdabot>  2
18:22:58 <Lajexander> > (succ . succ) 0
18:23:00 <lambdabot>  2
18:23:07 <Lajexander> yeah :/
18:24:00 <lennart> > map (foldr (.) id (replicate 5 cos)) 1
18:24:00 <lambdabot>  add an instance declaration for (Num [a])
18:24:20 <lennart> > foldr (.) id (replicate 5 cos)) 1
18:24:20 <lambdabot>  Parse error
18:24:24 <lennart> grrrr
18:24:34 <lennart> > foldr (.) id (replicate 5 cos) 1
18:24:36 <lambdabot>  0.7013687736227565
18:24:58 <lennart> > foldr1 (replicate 15 cos) 1
18:24:59 <lambdabot>    Expecting a function type, but found `[a]'
18:24:59 <lambdabot>    Expected type: a -> a -...
18:25:07 <Lajexander> is it possible to compile hugs/ghc/whatever under beos/haiku/zeta?
18:25:18 <SamB_XP> probably hugs
18:25:22 <lennart> > > foldr1 id (replicate 15 cos) 1
18:25:22 <lambdabot>  Parse error
18:25:27 <SamB_XP> if its a 32-bit system...
18:25:28 <lennart> grrrrrrrrrr!!!!
18:25:29 <newsham> ?hoogle [(a -> a)] -> (a -> a)
18:25:30 <lambdabot> No matches, try a more general search
18:25:38 <lennart> > foldr1 id (replicate 15 cos) 1
18:25:39 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
18:25:39 <lambdabot>    Expe...
18:25:43 <Lajexander> SamB_XP: nicccccccccccccce =)
18:25:59 <lennart> *sigh* i give up
18:26:01 <newsham> > let pipe = foldr1 (.) in (pipe (replicate 5 cos)) 1
18:26:02 <lambdabot>  0.7013687736227565
18:26:21 <lennart> > foldr1 (.) (replicate 15 cos) 1
18:26:22 <newsham> is there a std def for "foldr1 (.)" ?
18:26:23 <lambdabot>  0.7383692041223232
18:27:00 <SamB_XP> @type foldr (.) id
18:27:01 <lambdabot> forall a. [a -> a] -> a -> a
18:27:11 <SamB_XP> @hoogle [a -> a] -> a -> a
18:27:12 <lambdabot> No matches, try a more general search
18:27:25 <SamB_XP> newsham: no!
18:28:13 <lennart> newsham: it's not that useful in practice
18:28:22 <newsham> eh.. i've used it several times myself
18:28:42 <newsham> (i prefer (foldr1 (.)) . reverse
18:28:50 <newsham> because I'm a unix weenie
18:29:02 <SamB_XP> newsham: no don't use that
18:29:04 <SamB_XP> because
18:29:49 <SamB_XP> > foldr1 (.) [] 1
18:29:50 <lambdabot>  Exception: Prelude.foldr1: empty list
18:30:05 <newsham> i'm aware
18:31:08 <SamB_XP> also isn't foldl (>>>) id better?
18:31:23 <newsham> ?type (>>>)
18:31:24 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
18:31:49 <SamB_XP> @type (>>>) :: (a -> b) -> (b -> c) -> (a -> c)
18:31:50 <lambdabot> (a -> b) -> (b -> c) -> (a -> c) :: forall a b c. (a -> b) -> (b -> c) -> a -> c
18:32:00 <SamB_XP> oh, yeah, silly GHCi...
18:32:16 <newsham> *shrug* is it better?  i'm not familiar.
18:32:33 <SamB_XP> well, (>>>) is basically (flip (.)), as I'm using it here...
18:32:45 <newsham> works for me! :)
18:32:57 <SamB_XP> it has other instances
18:34:31 <Lajexander> what's a good/normal use of scan? saw it here: http://cale.yi.org/index.php/Fold_Diagrams
18:34:33 <lambdabot> Title: Fold Diagrams - CaleWiki
18:36:01 <newsham> > scanr1 (+) [1,3,9,2,8]
18:36:02 <lambdabot>  [23,22,19,10,8]
18:36:14 <newsham> > scanl1 (+) [1,3,9,2,8]
18:36:15 <lambdabot>  [1,4,13,15,23]
18:36:23 <SamB_XP> scanly looks *oh so curly*
18:36:28 <SamB_XP> er.
18:36:30 <SamB_XP> scanl
18:36:31 <newsham> sometimes you want to iterate over the accumulated value
18:37:24 <Lajexander> yeah, i get it
18:37:28 <Lajexander> thanks
18:38:44 * SamB_XP thinks it needs arrows...
18:41:14 <newsham> > let runAvg x = zipWith (/) (scanl1 (+) x) [1..] in runAvg [1,3,2,3,4,3,6,7,5,1,3,2]
18:41:15 <lambdabot>  [1.0,2.0,2.0,2.25,2.6,2.6666666666666665,3.142857142857143,3.625,3.777777777...
18:43:55 <SamB_XP> this needs fixing: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html#infelicities-lexical
18:43:58 <lambdabot> Title: Chapter 12. Known bugs and infelicities, http://tinyurl.com/ygbupd
18:43:59 <Cale> yeah, I had to curl it to make it all fit :)
18:44:15 <Cale> I hope it's obvious how it's all hooked up :)
18:44:45 <SamB_XP> Cale: it isn't obvious what direction things are going in...
18:44:49 <newsham> > let runSum = foldl1 (+) in let runAvg x = zipWith (/) (runSum x) [1..] in runAvg [1,2,3,4]
18:44:50 <lambdabot>  add an instance declaration for (Num [b])
18:44:50 <lambdabot>   In the list element: 4
18:45:08 <Cale> SamB: the intention is that things plugged into the bottom of a symbol are its parameters
18:45:24 <SamB_XP> oh
18:45:29 <SamB_XP> maybe you should say that!
18:47:23 <Cale> there you go :)
18:47:29 <SamB_XP> anyway, Section 12.1.1.1 of the GHC user's manual claims that GHC doesn't support programs written in Unicode.
18:47:54 <Cale> well, ghci still doesn't, but ghc does now :)
18:48:04 <SamB_XP> ... why doesn't GHCi?
18:48:11 <Cale> I don't know.
18:48:57 <Cale> > fix ((0:) . scanl (+) 1)
18:48:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:49:17 <Cale> Lajexander: there's a fun use of scanl :)
18:51:20 <Lajexander> @type fix
18:51:22 <lambdabot> forall a. (a -> a) -> a
18:51:35 <Cale> fix f = f (fix f)
18:51:49 <Cale> > fix (1:)
18:51:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:51:51 <Lajexander> > fix (+1) 1
18:51:52 <lambdabot>  add an instance declaration for (Num (t -> a))
18:52:02 <Cale> hmm
18:52:08 <Cale> > fix (+1) (1 :: Integer)
18:52:09 <lambdabot>  add an instance declaration for (Num (Integer -> a))
18:52:13 <Cale> oh
18:52:34 <Lajexander> why do these things always happend to me!?!?!?
18:52:40 <Cale> > fix (+1)
18:52:41 <lambdabot>  Exception: <<loop>>
18:52:45 <Cale> there we go :)
18:52:55 <Lajexander> i always get the most stupid of stupid errors
18:53:03 <Lajexander> what happened?
18:53:10 <Cale> too many parameters to fix
18:53:18 <Lajexander> "??"
18:53:31 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 10
18:53:32 <lambdabot>  3628800
18:53:37 <Lajexander> first things first; what's the purpose of fix
18:53:39 <Cale> > product [1..10]
18:53:40 <lambdabot>  3628800
18:53:53 <Cale> constructing recursive functions without giving them names
18:54:33 <Lajexander> > fix ((0:) . scanl (+) 1)
18:54:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:54:44 <Cale> or, if you want, finding the least-defined fixed point of a given function
18:55:09 <Lajexander> that sounds rather useful
18:55:34 <Cale> fix ((0:) . scanl (+) 1) = 0 : scanl (+) 1 (fix ((0:) . scanl (+) 1))
18:55:57 <Lajexander> what list is fix operating on here? fix ((0:) . scanl (+) 1)
18:56:25 <Cale> it's not, it's just building a list
18:56:42 <Cale> here's a simpler example
18:56:49 <Cale> > fix (0:)
18:56:50 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
18:57:10 <Cale> fix (0:) = (0:) (fix (0:))
18:57:26 <Cale> = 0 : 0 : fix (0:)
18:57:27 <Lajexander> what module is fix in?
18:57:29 <Cale> = 0 : 0 : 0 : fix (0:)
18:57:42 <Cale> Control.Monad.Fix somewhat unintuitively
18:57:52 <Cale> (because the monadic version of fix is also there)
18:58:15 <Cale> > fix ((0:) . map (+1))
18:58:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:58:22 <Lajexander> that
18:58:26 <SamB_XP> @dict-all skolem
18:58:26 <lambdabot> Unknown command, try @list
18:58:32 <SamB_XP> @all-dict skolem
18:58:33 <lambdabot> No match for "skolem".
18:58:33 <Lajexander> ...i do not have loaded
18:58:51 <Cale> :m + Control.Monad.Fix
18:59:39 <Cale> iterate f x = fix ((x:) . map f)
18:59:48 <Lajexander> i think i have to get through chapter 9 before i try on fix
18:59:55 <Cale> of course, that's not actually how it's written
19:00:08 <Cale> iterate f x = x : iterate f (f x)
19:00:25 <Lajexander> cool =)
19:00:49 <Lajexander> but didn't scan do something similar?
19:01:04 <Cale> yeah
19:01:56 <Cale> iterate f x = scanl f x (repeat x)
19:02:19 <Cale> or
19:02:22 <Cale> iterate f x = scanl1 f (repeat x)
19:02:54 <Cale> Interesting how there's all these nice connections :)
19:03:17 <Cale> iterate has to be one of the most implementable functions in Haskell :)
19:04:08 <Lajexander> i was just thinking: how do you stop it, but i realised that the language is lazy =)
19:04:19 <Cale> yeah
19:05:17 <Lajexander> @type map
19:05:18 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:05:37 <Cale> > map (2^) [0..10]
19:05:38 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024]
19:05:43 <Lajexander> my own little map (that doesn't work): map' f []     = []
19:05:52 <Lajexander> map' f (x:xs) = f x : map' xs
19:06:07 <Cale> you missed passing f in the recursive call
19:06:28 <Lajexander> puxx0rz
19:06:47 <Lajexander> yay!
19:10:38 <Lajexander> how hard would it be to model PA in haskell (skipping #8)
19:11:56 <Cale> Peano Arithmetic?
19:12:01 <Cale> not hard
19:12:02 <Lajexander> yeah
19:12:16 <Cale> data Nat = Zero | Succ Nat
19:12:23 <Lajexander> yeah
19:12:32 <Cale> plus Zero x = x
19:12:33 <Lajexander> but multiplication?
19:12:46 <Cale> plus (Succ x) y = Succ (plus x y)
19:13:02 <SamB_XP> not hard!
19:13:14 <SamB_XP> (unless you are coding in O'Cult!)
19:13:42 <Lajexander> ???
19:13:50 <Cale> times x Zero = Zero
19:14:03 <Cale> times x (Succ Zero) = x
19:14:10 <Cale> er
19:14:25 <Cale> times x (Succ y) = plus (times x y) x
19:14:35 <Cale> so you don't need the second base case :)
19:15:13 <Cale> one odd thing due to laziness is that infinity has a representation as a Nat, which you can fix by making Succ strict
19:15:17 <Lajexander> heh, simple...
19:15:31 <Cale> data Nat = Zero | Succ !Nat
19:15:46 <chessguy> how do you know it's odd and not even? :)
19:15:49 <Lajexander> ehm... say what?
19:15:50 <Cale> That'll ensure that every Nat is finite, but it's actually less useful
19:16:09 <Cale> infinity = fix Succ
19:16:21 <Lajexander> i've seen ! somewhere else earlier...
19:18:05 <Lajexander> so the exclamation forces Succ to not be repeated infinte times?
19:18:15 <Lajexander> *exclamation mark*
19:18:33 <Pseudonym> The exclamation mark is a strictness annotation.
19:18:34 <Cale> yeah, it forces it to evaluate its parameter when applied
19:18:47 <Cale> (up to determining the top level constructor)
19:18:50 <Pseudonym> Right.
19:19:13 <Lajexander> but can't that slow this model down a lot?
19:19:19 <Pseudonym> It can.
19:19:21 <Pseudonym> And it can speed it up.
19:19:26 <Lajexander> ?
19:19:30 <Pseudonym> And it can avoid space leaks, or it can create them.
19:19:39 <Cale> Depends on what you're doing
19:19:42 <Pseudonym> Like any tool, you have to use it intelligently.
19:20:04 <Lajexander> how could ! make create a space leak=
19:20:27 <Lajexander> intuitively only the opposite strikes me as possible
19:21:01 <Pseudonym> Well, it could force a large data structure to be made that otherwise wouldn't be made.
19:21:02 <Cale> Well, if you end up forcing the construction of things which are never needed.
19:21:51 <Cale> For example, to compare two nats with <, you only have to evaluate each of them up to the size of the smaller one.
19:22:17 <Cale> With strictness, you'd end up building the entire nat anyway, even though you don't use it all.
19:22:31 <Lajexander> yeah, right!
19:22:43 <dons> dibblego: taxi from airport is about 25 mins to UNSW, should cost around $15-20
19:23:04 <Pseudonym> No way that's AUD.
19:23:07 <Lajexander> @type ord
19:23:09 <lambdabot> Char -> Int
19:23:22 <Cale> @type fromEnum
19:23:23 <lambdabot> forall a. (Enum a) => a -> Int
19:24:04 <dons> Pseudonym: yeah?
19:24:10 <Pseudonym> Really?
19:24:14 <Pseudonym> Wow, your taxis are cheap.
19:24:14 <dons> sure.
19:24:55 <Lajexander> > ord 'a'
19:24:57 <lambdabot>  97
19:24:59 <dons> I noticed that, actually. It was something like $18US for a 5 minute journey in SF, then I get back home and airport->my house, 20 mins or so, $15AU
19:25:10 <Lajexander> right... that shit again...
19:25:30 <Lajexander> > ord '0'
19:25:32 <lambdabot>  48
19:25:51 <Cale> ord '\0'
19:25:52 <Cale> > ord '\0'
19:25:53 <lambdabot>  0
19:25:59 <Cale> > ord '\3627'
19:25:59 <lambdabot>  3627
19:26:04 <Lajexander> that's cheating
19:26:24 <Lajexander> > ord '9'
19:26:26 <lambdabot>  57
19:27:06 <Cale> > maxBound :: Char
19:27:07 <lambdabot>  '\1114111'
19:27:14 <Pseudonym> OK, that's weird.
19:27:29 <Pseudonym> The distace rate in Sydney is actually more than in Melbourne.
19:28:01 <Pseudonym> My place to the airport is about 45 min when it's not peak time, and it usually costs me over $90.
19:28:05 <dons> maybe with the airport bang in the middle of the city, airport fares tend to be low
19:28:21 <Pseudonym> Maybe.
19:28:22 <dons> $90! I've never paid more than $20 to get to the airport :)
19:28:29 <Pseudonym> Yup, $90.
19:28:52 <Lajexander> let f x = ord x >= 48 && ord x <= 57 in f a
19:28:56 <Lajexander> > let f x = ord x >= 48 && ord x <= 57 in f a
19:28:57 <lambdabot>  Not in scope: `a'
19:29:01 <dons> see, the train to the airport is $14, making the taxi definitely worth it for inner sydney destinations
19:29:03 <Lajexander> > let f x = ord x >= 48 && ord x <= 57 in f 'a'
19:29:04 <lambdabot>  False
19:29:10 <Lajexander> aight
19:29:25 <Pseudonym> Maybe it's the fact that the 20 mins isn't very far.
19:29:27 <dons> then again, the bus is only a couple of dollars, they just make it difficult to get to
19:29:33 <dons> Pseudonym: yeah.
19:29:38 <dons> 5-10 kms at most
19:29:44 <Pseudonym> Right.
19:29:56 <Pseudonym> I'm like 45km away.
19:30:00 <Pseudonym> Other side of town.
19:30:15 <Pseudonym> It's the price we pay for not having a curfew.
19:30:49 <dons> hmm. right. whereas i live with planes overhead 7am -> 11pm :}
19:30:57 <Pseudonym> Right. :-)
19:31:03 <Pseudonym> So it's distance.  Got it.
19:31:09 <dons> yeah, must be
19:31:29 <Pseudonym> 5-10km... you could almost walk it.
19:31:42 <dons> yeah, you could
19:31:44 <Pseudonym> Depends on how much baggage.
19:32:15 <dons> I've walked most of the way, to get down to Cooks River. That's about 45mins or so. Then its about 1km across the river
19:32:56 <dons> araujo: around?
19:45:38 <Dunearhp> I'm trying to find out what gui libraries/bindings are available for haskell. I only know of gtk2hs.
19:46:03 <Lajexander> wxHaskell
19:46:13 <Lajexander> we use it in school
19:46:15 <Lajexander> hang on
19:47:14 <Lajexander> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/ <-- purple field, week 6
19:47:18 <lambdabot> Title: Introduction to Functional Programming (TDA555/INN040ht) -- HT2006, http://tinyurl.com/yxsy2x
19:47:33 <Lajexander> the ppt-file shows some basic stuff
19:47:44 <Lajexander> *ppt/pdf*
19:49:15 <mathewm> is it possible to implement sequence in terms of more primitive functions? ( I want to know before I try... )
19:49:29 <dons> Dunearhp: wxhaskell and gtk2hs are good. then there's lower things like OpenGL, X11 and so on
19:49:38 <dons> check haskell.org under 'libraries and tools/graphics'
19:49:39 <mathewm> nevermind
19:50:03 <dons> mathewm: sure. sequence ms = foldr k (return []) ms
19:50:03 <dons>         where
19:50:04 <dons>           k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:50:07 <Dunearhp> thanks
19:50:10 <dons> but there's lots of other ways to do it, well, 1 anyway
19:50:39 <mathewm> I realized how to do it shortly after asking... thanks though
19:50:42 <dons> :)
19:50:56 <dons> ?. pl undo do { x <- m; xs <- m'; return (x:xs) }
19:50:56 <lambdabot> (`fmap` m') . (:) =<< m
19:51:19 <Lajexander> @type fmap
19:51:21 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
19:51:31 <Lajexander> phuxx0r
19:51:42 <Lajexander> i don't understand half of that
19:52:12 <dons> which parts of the type don't you understand?
19:52:17 <Lajexander> monads are lame
19:52:30 <dons> that's our insightful comment of the day!
19:52:37 <sjanssen> @pl foldr (\x xs -> liftM2 (:) x xs) (return [])
19:52:37 <lambdabot> foldr (liftM2 (:)) (return [])
19:52:54 <Lajexander> >:i Functor
19:53:16 <dons> use ghci. lambdabot _isn't_ a ghci session
19:53:21 <dons> ?hoogle Functor
19:53:22 <lambdabot> Prelude.Functor :: class Functor f
19:53:22 <lambdabot> Data.FunctorM :: module
19:53:22 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
19:53:46 <Lajexander> dons: he sure seems like it... mostly anyways =)
19:53:56 <dons> true.
19:55:57 <Lajexander> hey, why does fmap reverse a and b=
19:55:59 <Lajexander> ?
19:56:11 <Lajexander> (f :: * -> *) b a. (Functor f) => (a -> b)
19:56:21 <glguy> Does anyone have the dwm source files?
19:56:25 <glguy> the website seems to be down
19:56:25 <dons> yeah
19:56:31 <dons> its suckless.org now
19:56:35 <glguy> oh
19:56:39 <glguy> i'll check that first
19:56:41 <dons> big story :}
19:57:13 <glguy> I just install openbsd on my work laptop
19:57:21 <dons> cool
19:57:23 <dons> glguy++
19:57:23 <glguy> I was amazed that it supported all of the hardware
19:58:08 <dons> heh. oh, i got an email from Jonathan Gray, jsg@, about the netgear card that didn't work last week -- well there's a driver now :)
19:58:13 <Lajexander> openBSD - the OS of choice for any and all laptops!
19:58:14 <glguy> even the intel wireless device (it's a centrino)
19:58:28 <dons> yeah, centrino runs fine these days
19:58:39 <glguy> I had to manually download the ipw firmware, however
19:58:56 <dons> right
20:02:51 <Lajexander> 5:02 AM
20:02:56 <Lajexander> sleepy time =)
20:03:05 <glguy> I should have read my config.h before I started up dwm
20:03:13 <glguy> I had no idea how to open xterm :)
20:03:21 <glguy> shift alt return seems to be the default
20:03:26 <dons> heh
20:03:30 <dons> yep
20:05:28 <glguy> is there a command for "run"
20:05:35 <glguy> where I can type the name of an application
20:05:37 <glguy> and it runs it?
20:05:49 <dons> yeah, alt-p
20:05:56 <dons> should bring up the dmenu
20:06:02 <dons> I had to config my a bit thoug, for openbsd
20:06:04 <glguy> oh, I didn't install dmenu
20:06:08 <dons> want to see my configs?
20:06:20 <glguy> sure
20:06:35 <glguy> ?paste -- ?
20:06:36 <lambdabot> http://paste.lisp.org/new/haskell
20:06:50 <dons> http://www.cse.unsw.edu.au/~dons/tmp/config.h
20:07:09 <dons> note the fixes to remove bashisms (I think) from the shell code for dmenu
20:07:19 <glguy> ah, okay
20:07:21 <dons> oh, it uses 'words', a script of mine.
20:07:36 <dons> you'll want to deal with that somehow
20:07:49 <dons> $ words --help
20:07:50 <dons> Usage: "words" [OPTION...] [file..]
20:07:55 <dons> words :: String -> [String]
20:07:56 <dons> 'words' breaks a string up into a list of words, which were delimited
20:07:56 <dons> by white space.
20:07:56 <dons> :)
20:08:19 <dons> instead of the non portable IFS games anselm does, I use a haskell program, much more portable :S
20:08:40 <glguy> um, so I launched firefox from xterm...
20:08:43 <glguy> where did dwm put it
20:08:57 <glguy> hmm, on a new desktop
20:09:11 <dons> hmm. should just be the top window
20:09:17 <dons> i guess it depends on how you've got things configed
20:12:36 <tmoertel> Is GHCi working under x86_64 in 6.6?
20:12:41 <dons> should do, yeah
20:12:49 <dons> (GHC HQ has an amd64 box)
20:12:55 <glguy> I've got ghc installed on a different box
20:13:04 <glguy> is there an easy way to build ghc for this laptop?
20:13:10 <dons> same arch?
20:13:15 <glguy> both obsd snapshot
20:13:20 <dons> and x86s?
20:13:25 <glguy> aye
20:14:04 <dons> oh, you built it yourself (not the port script?)
20:14:12 <glguy> yeah, ghc 6.6
20:14:16 <dons> then copy the build tree over, and install
20:14:20 <glguy> kk
20:14:32 <dons> please don't sue me
20:14:37 <SamB_XP> heh
20:14:52 <glguy> oh, sweet, I remember deleting the ghc 6.6 source tree yesterday
20:14:55 <glguy> I thought to myself
20:14:58 <SamB_XP> heh
20:15:02 <dons> you could try copying the binaries then,
20:15:05 <glguy> "I'm not going to rebuild 6.6, this is a release version"
20:15:09 <dons> i.e. bin/ghc* and lib/ghc-6.6/*
20:15:13 <dons> into the right places
20:16:02 * tmoertel wonders why "GhcWithInterpreter = NO" is set in the Fedora Core RPM build spec for x86_64.
20:16:27 <dons> check with dcoutts. I'm pretty sure he uses ghci on the amd64
20:16:32 <dons> under gentoo, anyway
20:16:46 <dons> almost certain it works, that might just been an old flag from 6.4.1 days
20:17:46 <tmoertel> dons: OK.  I'll tweak the spec and rebuild.
20:20:13 <glguy> dons, do you know how to fix the control key in OpenBSD, whenever I press it my capslock toggles
20:20:23 <dons> yeah, ....
20:20:39 <dons> here, in .xsession:
20:20:40 <dons> # unmap CapsLock
20:20:41 <dons> xmodmap -e "remove Lock = Caps_Lock"
20:20:41 <dons> # set it to == ControlL
20:20:41 <dons> xmodmap -e "keysym Caps_Lock = Control_L"
20:20:43 <dons> xmodmap -e "keysym Caps_Lock = Control_L"
20:20:45 <dons> # and turn it on
20:20:48 <dons> xmodmap -e "add Control = Control_L"
20:20:52 <dons> so that flips caps lock to ctrl
20:21:12 <dons> oh, same line appears twice there. odd
20:21:50 <dons> glguy: that's not for the console though, if you were looking to set it in the console too, of course
20:22:02 <glguy> the console would be nice, but this is a start
20:22:21 <glguy> why do you do the keysym line twice...
20:22:51 <glguy> accident?
20:23:02 <dons> yeah
20:23:36 <glguy> and that goes in .xsession and not .xinitrc?
20:23:52 <glguy> does dwm go in .xsession also?
20:24:04 <dons> yes, in .xsession
20:24:08 <dons> to launch dwm I use...
20:24:20 <dons> exec /home/dons/bin/dwm-status
20:24:26 <dons> as the last line of .xsession
20:24:28 <dons> which :
20:24:34 * glguy never really used X11 and OpenBSD
20:24:36 <dons> while true ; do
20:24:39 <dons>   .....
20:24:39 <dons>     printf "%s : %s : %s : %s : %s Ghz : %s :%s\n" "$au" "$uk" "$us" "$ca" "$hw" "$bt" "$ut"
20:24:43 <dons>     sleep 30
20:24:45 <sjanssen> wow, is Anselm allergic to Google hits?
20:24:45 <dons> done | /home/dons/bin/dwm
20:24:46 <dons> which sets the status bar too
20:24:52 <glguy> oh
20:24:53 <dons> sjanssen: kinda nuts eh.
20:25:08 <glguy> anselm?
20:25:09 <glguy> link?
20:25:10 <dons> glguy: if you don't care about the status bar, then just: exec dwm might work
20:25:19 <dons> glguy: anselm is the dwm author/semi-crazy guy
20:27:11 <glguy> yeah, it wasn't easy to find his site
20:27:30 <glguy> freshmeat, linuxdownloads.something, &c. all linked to the old site
20:27:48 <dons> i think it was only last week he took down all the old stuff, and moved
20:28:11 <dons> maybe its a strategy to keep the dwm users 'elite' ?
20:28:24 <dons> i.e. word of mouth from people on the mailing list only..
20:32:15 <glguy> but what's the difference in .xsession and .xinitrc
20:32:31 <dons> not sure. i don't use any .xinitrc
20:33:29 <dons> heya coffeemug
20:33:33 <coffeemug> hey dons
20:33:39 <dons> how's code?
20:33:51 <coffeemug> I actually logged in to tell you that latest plugins library works on Win32 with Cygwin
20:33:59 <dons> great!
20:34:06 <coffeemug> I did some more work to remove dependencies on 6.6 libraries
20:34:10 <coffeemug> so I could test plugins
20:34:13 <coffeemug> and they work great
20:34:13 <dons> should work with mingw too i've been told: and haskell runs much faster under mingw
20:34:18 <dons> good stuff.
20:34:30 <dons> Dreadshoot: talk to coffeemug :)
20:34:44 <dons> coffeemug++
20:34:59 <coffeemug> actually the work done to create the plugins library looks awesome
20:35:14 <coffeemug> it doesn't seem to complex but as usual the devil's in the details
20:35:38 <coffeemug> it's pretty easy to get it working
20:35:44 <coffeemug> just install cygwin with ghc
20:35:44 <dons> i suppose seeing a dynamic linker written in haskell makes you realise they're fairly simple things
20:35:54 <coffeemug> check out the plugins library
20:35:56 <dons> just if you dive into a C dyn linker, it gets icky fast
20:36:01 <coffeemug> and then just ./Setup.hs configure
20:36:02 <coffeemug> build
20:36:03 <coffeemug> install
20:36:13 <dons> cool
20:36:26 <coffeemug> yeah I'm sure there was a lot of tricky stuff to work out there
20:36:42 <dons> Cale: be sure to categorise any new pages you create
20:36:48 <coffeemug> one thing that annoyed me about haskell is inability to do incremental development
20:36:50 <Cale> dons: ah
20:36:53 <coffeemug> like in lisp
20:37:01 <coffeemug> plugins appease me somewhat :)
20:37:02 <Cale> coffeemug: you can't?
20:37:03 <dons> Cale: i'm looking for the right category atm
20:37:16 <dons> coffeemug: yeah, and that's what ghci is for, btw :)
20:37:18 <coffeemug> Cale: not that I know of
20:37:29 <dons> i.e. you need an interpreter to do interpretive coding ;)
20:37:32 <coffeemug> yeah but ghci doesn't work like that really
20:37:38 <coffeemug> like
20:37:39 <Cale> Works well enough like it
20:37:45 <coffeemug> I can't modify a running program
20:37:52 <Cale> you shouldn't be able to
20:37:59 <dons> right. kinda messes with static typing ...
20:38:00 <dons> :)
20:38:04 <Cale> That's like, worse than dynamic scope.
20:38:15 * tmoertel observes that video playback is a bit "choppy" when building GHC in the background
20:38:16 <coffeemug> Cale: smalltalk and lisp people would tell you otherwise :)
20:38:18 <dons> yeah, you can of course modify a running program with hs-plugins :)
20:38:24 <dons> tmoertel: heh!
20:38:31 <dons> tmoertel: nice make  ;)
20:38:36 <Cale> maybe early lisp people who are addicted to the evils of dynamic scope :)
20:38:37 <coffeemug> dons: it doesn't mess with static typing at all, it's just that implementation would get real tricky
20:39:23 <dons> coffeemug: right. check the 'dynamic applications from the ground up' paper for the gritty details
20:39:36 <coffeemug> there's no real reason not to be able to add a function and modify an existing one at runtime
20:39:43 <coffeemug> you'd just have to verify typing at runtime
20:39:45 <dons> adding functions is easy, yes
20:39:46 <coffeemug> and that's tricky
20:39:54 <dons> its changing the shape of types that isn't so nice
20:40:02 <coffeemug> right
20:40:10 <coffeemug> well
20:40:15 <coffeemug> hs-plugins make me happy :)
20:40:28 <dons> good!
20:40:29 <coffeemug> <--- happy :-D
20:40:34 <glguy> man, a bunch of major version numbers have changed between the two snapshots that I used
20:40:50 <dons> glguy: you might be able to fake it though
20:40:55 <dons> with a crafty symlink
20:41:04 <dons> ghc tends not to use anything whose api changes
20:41:10 <Cale> Modifying an existing pure function at runtime could really mess things up
20:41:10 <glguy> it was only two
20:41:13 <glguy> libpthread and libc
20:41:18 <glguy> i just copied them over
20:41:23 <Cale> coffeemug: note that Haskell is lazily evaluated
20:41:27 <glguy> and I'll do a recompile now
20:41:32 <dons> yeah, laziness is not so helpful
20:41:41 <dons> you need to force evaluatoin to normal form if you're going to swap code out
20:41:43 <Cale> so what it means to modify an existing function is way different than in a strict language
20:41:53 <dons> otherwise you've got unevaluated pointers back into the old code still floating around
20:42:19 <Cale> Or else you start getting values which are built partially by old and new code
20:42:25 <Cale> which is actually kind of a possibility anyway
20:42:35 <dons> Cale: so its not a big problem if you have well defined 'swapping' points, and restricted global state, since you _can_ force all data before the swap
20:42:36 <Cale> but this makes it really unpredictable
20:42:44 <dons> you certainly don't want that, I think
20:43:09 <Cale> I think it's just a bad idea in any language
20:43:12 <dons> so Yi implements dynamic hotswapping by having strict fields in the state
20:43:18 <dons> and there's only a single state value anyway
20:43:21 <dons> so its always forced
20:43:29 <dons> making it trivial to swap out
20:43:53 <Cale> since your testing kind of goes out the window, you don't really know if things are working right because your code is right of because the state of the program is something made up of partially impossible values
20:44:02 <Cale> or*
20:44:19 <dons> yeah, the erlang rts goes to great pains to keep everything healthy, I think
20:44:34 <dons> (that's basically the cutting edge of hot swapping, that and the ML stuff)
20:45:13 <coffeemug> hmm
20:45:16 <coffeemug> I don't think that's true
20:45:23 <coffeemug> it's just that in "dev" mode
20:45:29 <coffeemug> when you swap an existing function
20:45:31 <Cale> Also, unless the thing is already in production, why bother?
20:45:32 <coffeemug> you force all evaluation
20:45:33 <coffeemug> that's all
20:45:40 <dons> right. you need to do that.
20:45:47 <Cale> That can still leave things in an inconsistent state thought
20:45:50 <Cale> though*
20:45:52 <dons> seems kinda heavy weight technique for developing.
20:45:59 <coffeemug> well
20:46:00 <Cale> and may be impossible
20:46:02 <dons> i'd not want to write programs like that, for reasons Cale suggested
20:46:07 <coffeemug> once you get used to incremental development
20:46:11 <dons> and with pure functional code, :reload is good enough
20:46:17 <coffeemug> it's REALLY hard to go back
20:46:21 <dons> since you don't care about reproducing a huge global state
20:46:23 <Cale> There's no state to reconstruct anyway
20:46:27 <coffeemug> yeah but
20:46:31 <coffeemug> I have to bring server down
20:46:34 <Cale> or at least, there shouldn't be
20:46:34 <coffeemug> bring it back up
20:46:36 <coffeemug> you knwo
20:46:52 <coffeemug> if code is complex, up and down takes time
20:46:55 <dons> but that shouldn't matter while developing
20:47:07 <Dreadshoot> coffeemug: did you get hs-plugins to work?
20:47:10 <dons> i guess if its huge there might be a pay off for introducing the additional complexity
20:47:11 <coffeemug> did you guys ever develop in lisp?
20:47:14 <coffeemug> Dreadshoot: yes
20:47:17 <Cale> If it's a production server, you also really shouldn't swap new code in until you know that it works.
20:47:33 <coffeemug> Cale: I'm talking about dev, not production
20:47:33 <Cale> If it's not, then who cares?
20:47:45 <dons> yeah, so lambdabot runs like that. I use hotswapping for known updates. but for dev work I just run in ghci, and test fragments on their own
20:47:50 <coffeemug> Cale: try to develop in Lisp or smalltalk for a while, you'll see
20:47:52 <Cale> Restarting your program is just one command at the ghci prompt.
20:47:57 <Cale> I have written stuff in lisp
20:48:02 <dons> I suppose if it took , say, 5 minutes to connect to the server, you would want to work around that
20:48:06 <dons> but that seems like a rare case
20:48:22 <Dreadshoot> coffeemug: can you write down in a txt how you did it?
20:48:23 <SamB_XP> even cold-swap with hs-plugins beats waiting for it to finish linking!
20:48:29 <dons> heh
20:48:35 <Cale> (actually, I found lisp to be pretty much of a pain because of the lack of static typing)
20:48:42 <dons> SamB_XP is a well known critiic of GNU ld
20:48:48 <coffeemug> Dreadshoot: it's rather simple
20:48:55 <coffeemug> get the latest code from darcs
20:48:55 <SamB_XP> also ar(1)
20:49:15 <coffeemug> and then do runghc.exe Setup.hs configure
20:49:15 <Dreadshoot> coffeemug: probably but i tried and i got an error when trying to run it
20:49:19 <coffeemug> runghc.exe Setup.hs buikd
20:49:23 <coffeemug> runghc.exe Setup.hs install
20:49:24 <SamB_XP> though really hs-plugins has an easier task
20:49:27 <SamB_XP> I think
20:49:32 <coffeemug> Dreadshoot: what error?
20:49:40 <SamB_XP> (having just a few .o files to deal with)
20:49:42 <dons> SamB_XP: ? hmm, the ghc rts still has to do a lot of what binutils does
20:49:48 <dons> i.e. relocating syms and so on
20:49:50 <Dreadshoot> i didnt do it through runghc though
20:50:03 <coffeemug> Dreadshoot: also, you need cygwin with ghc
20:50:10 <coffeemug> and ghc 6.4.2
20:50:18 <SamB_XP> dons: but it doesn't have to chase symbol dependencies around a symbol index!
20:50:20 <Dreadshoot> why do i need cygwin?
20:50:25 <SamB_XP> and a bunch of object files!
20:50:40 <coffeemug> Dreadshoot: that's how I did it, you may be able to do it without cygwin
20:50:50 <dons> SamB_XP: sure it does. well, a bit different to dlopen, but close
20:50:56 <Dreadshoot> can you use it after install without cygwin?
20:51:10 <dons> SamB_XP: i.e. how else does it find undefined syms on loading :)
20:51:13 <Cale> coffeemug: The biggest complaint I had about lisp is that most of my bugs were things which could and should have been caught by the compiler.
20:51:34 <Dreadshoot> dons: whats the installation of hs-plugins doing.. would it work to just copy it?
20:51:35 <SamB_XP> dons: well, see, one crucial difference is that hs-plugins only has a few .o files
20:51:43 <coffeemug> Dreadshoot: I will test it eventually, but you should be able to I think
20:51:44 <SamB_XP> because it has *one* per package!
20:52:02 <coffeemug> Cale: it's a matter of taste I guess but I really like lisp
20:52:06 <dons> SamB_XP: not if you load 90 lambdabot plugins as .o files though
20:52:29 <Cale> coffeemug: Which flavour of lisp do you use?
20:52:39 <SamB_XP> dons: oh, well, yeah. but I was guessing the cost to be mostly due to the -split-objs packages?
20:52:49 <dons> lisp always feels a bit old fashioned to me. its missing some key developments in language design
20:52:59 <dons> SamB_XP: ah yes.
20:53:02 <SamB_XP> dons: like compile-time errors?
20:53:08 <dons> -split-objs _really_ stresses ld
20:53:38 <dons> SamB_XP: yeah, and a lot of other things invented since 1975
20:53:43 <SamB_XP> like types?
20:53:50 <Cale> Common lisp makes you quote every function you want to pass to a HOF, and use funcall to call it inside the HOF which is annoying.
20:54:01 <SamB_XP> mmm
20:54:03 <dons> SamB_XP: three quarters of the haskell report , for example :)
20:54:03 <Cale> You can't just treat functions and data the same way
20:54:07 <coffeemug> Cale: cl + slime mostly, but that was a while ago
20:54:17 <SamB_XP> Cale: true
20:54:20 <coffeemug> Cale: yeah, but it was no biggie
20:54:25 <dibblego> lisp "is simply the most powerful language available"
20:54:28 <Cale> Yeah, I used cmucl and slime mostly
20:54:37 <dons> dibblego: heh
20:54:38 <SamB_XP> dibblego: don't go all Paul Graham on us...
20:54:46 <Cale> I prefer scheme though, I found.
20:54:55 <SamB_XP> no Blubbing, either!
20:54:56 <dons> i don't understand the cult of Paul Graham. really i don't. its a mystery
20:54:56 <dibblego> http://undefined.com/ia/2006/10/16/you-might-be-a-blub-programmer/ Finally, if you are of the illusion that LISP “is simply the most powerful language available”, you might be a Blub programmer.
20:55:00 <lambdabot> Title: Indefinite Articles » You might be a &#8220;Blub&#8221; programmer&#8230;, http://tinyurl.com/y5chp4
20:55:21 <Cale> dibblego: heh
20:55:21 <SamB_XP> dibblego: what did I only just finish telling you about blubbing?
20:55:31 <dibblego> SamB_XP, wasn't watching :)
20:55:35 <dons> i bet if i changed my name to "Paul Graham", and started blogging about haskell, we'd see a big upswing in users
20:55:42 <SamB_XP> heh
20:56:00 <coffeemug> dons: yeah
20:56:01 <SamB_XP> wouldn't they notice that you didn't have his blog?
20:56:10 <dibblego> I just finished referencing a book by one of the inudstry dieties - felt dirty
20:56:10 <coffeemug> dons: I think lately he wrote some stupid stuff
20:56:17 <dons> and people would post to digg and reddit: "Paul Graham:
20:56:20 <dons> Haskell rocks!"
20:56:22 <dons> and so on
20:56:35 <dons> he's reached the status where the author's name is in larger font than the title ...
20:56:38 <Pseudonym> You'd have to master the art of condescention first.
20:56:41 <dons> i.e. the John Grisham syndrome
20:56:56 <Pseudonym> Douglas Adams commented about that, too.
20:57:19 <Dreadshoot> coffeemug: check priv
20:57:27 <Cale> dons: you can copy his web format too, just to be extra confusing :)
20:57:34 <coffeemug> priv?
20:57:34 <dons> Cale: yeah. good idea!
20:57:55 <Dreadshoot> private msg, or #haskell-overflow, to much text here
20:58:01 <dibblego> do what Colbert did with wikipedia
20:58:02 <Cale> heh, that would be awesome, especially if you went to the trouble of legally changing your name
20:58:16 <dibblego> wikiality or whatever it is
20:58:23 <Pseudonym> You also have to thank a bunch of smart people who know nothing about the topic as thanks for looking at earlier drafts.
20:58:23 <Cale> truthiness
20:58:34 <Cale> and yeah, wikiality
20:58:45 <Pseudonym> "Thanks to Eric S. Raymond for commenting on an earlier draft of this essay on flower arranging."
20:59:17 <coffeemug> lately Paul Graham's writing have been... weird
20:59:22 <coffeemug> yet are still very popular
20:59:33 <coffeemug> people have trouble letting go of the author's name
20:59:54 <chessguy> > 5 `Mod` 3
20:59:56 <lambdabot>  Not in scope: data constructor `Mod'
21:00:01 <chessguy> > 5 `mod` 3
21:00:03 <lambdabot>  2
21:00:11 <hyrax42> what is meant by "ST: The strict state-transformer monad."
21:00:24 <hyrax42> is there a lazy one?
21:00:46 <Cale> yes
21:00:59 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST-Lazy.html
21:01:02 <lambdabot> http://tinyurl.com/yzt79w
21:01:47 <Cale> The lazy one is actually the original
21:02:22 <Cale> (I think)
21:03:17 <hyrax42> Cale: thanks
21:03:42 <hyrax42> the docs page for ST says the strict ST was defined in the paper lazy functional ST threads
21:03:53 <hyrax42> staet threads
21:04:03 <hyrax42> by none other than spj, of course
21:08:13 <coffeemug> ok guys
21:08:17 <coffeemug> time to sleep
21:08:26 <coffeemug> have a good weekend everyone
21:17:13 <chessguy> @seen dons
21:17:14 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 19m 39s ago.
21:18:41 <araujo> dons, right here!
21:21:30 <chessguy> aww, the hackage SoC idea list has been spammed :(
21:26:22 <chessguy> http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
21:26:26 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac, http://tinyurl.com/fl2dw
21:27:38 <shapr> Code is a wonderful thing.
21:28:03 <Pseudonym> I've read The Daily WTF.  It's not always.
21:28:22 <shapr> ok, fair enough
21:28:23 <chessguy> Pseudonym, what's that?
21:28:48 <Pseudonym> http://thedailywtf.com/
21:29:12 <Cale> The real WTF is why that site causes privoxy to go into some kind of 100% CPU eating infinite loop.
21:29:21 <Pseudonym> Perhaps a better way to express it like Keats: A program of beauty is a joy forever.
21:29:30 <shapr> Speaking WTF, NVidia's linux drivers have a local root exploit. They claim they have a fix, but since users see neither the original source nor the fix, no one is really sure...
21:29:59 <Cale> Do users know the exploit?
21:30:15 <shapr> Yeah, they've known it since 2004...
21:30:23 <Cale> So can't that be checked?
21:30:49 <shapr> I think the specific problem can be checked, but not whether Nvidia just fixed a special case of a general bug.
21:31:01 <Cale> hm, yeah
21:31:17 <dibblego> nvidia/linux is just a nightmare
21:31:19 <shapr> Anyway, I'm just being whiny about binary drivers...
21:33:00 <ubuntu_> Building ghc6.6 on ubuntu linux on vmplayer, takes a long time to archive (ar) libHSbase_p.a, virtual/rss memory shows 340m/140m, ar exits with error. Is it possible to run ar on fewer files at a time? Thanks
21:38:39 <Bobstopper> I'm having trouble finding a solution to this problem: I have a data type defined which I hope to have dynamically loadable via hsplugins or something similar. The data type has a field which contains an IO command to be specified by the plugin. The data type also needs to be an instance of Read and Show. So the data type needs to have readsprec defined such that it somehow looks up the appropriate plugin. But any such mapping necessari
21:38:39 <Bobstopper> ly needs to be held in a monad since it will be dynamic according to hsplugin, but this is against readsPrec's type definition.
21:38:56 <Bobstopper> Is there a way to do this without defining a special type of read function?
21:39:01 <Bobstopper> (sorry about the long description)
21:39:49 <Bobstopper> s/read function/read class/
21:40:27 <sjanssen> Bobstopper: how do you plan to show/read an IO a?
21:41:00 <Bobstopper> sjanssen: it won't be. The IO a will be held in the plugin's definition. That's why readsPrec needs to lookup the appropriate plugin to get the IO a.
21:42:00 <sjanssen> it sounds like you're pushing too much work on Read
21:42:15 <sjanssen> it's probably better to do this in two steps: parse your input, then look up a plugin
21:42:25 <Dreadshoot> anyone uses hs-plugins in win?
21:42:42 <Bobstopper> sjanssen: actually, yeah, it just occurred to me I can do that...
21:42:55 <Bobstopper> I'll have a look at that angle. Thanks.
22:13:56 <dons> Dreadshoot: I've noticed that you keep asking about hs-plugins on win, but haven't sent me any bug reports... ?
22:14:04 <dons> so I actually have no idea what problem you're having.
22:18:29 <Dreadshoot> dons: i've pasted the error
22:19:12 <Dreadshoot> runplugs.exe: user error (loadShared: couldn't load 'libwsock32.so' because addDLL: unknown error)
22:19:17 <dons> ah right.
22:19:35 <dons> i have no solution for that, other than for you to use cygwin or mingw, which have both been reported to work.
22:21:04 <Dreadshoot> i could try mingw, but i dont know how to do that.. what differs from what ive tried before
22:22:05 <dons> well, your a developer -- this is your chance to explore, learn and solve things :)
22:22:24 * tmoertel wonders how Thunderbird can use 794 MB of RAM
22:22:31 <dons> heh
22:22:32 <dons> java?
22:22:47 <dons> I know my firefox tends to go nuts when java starts up.
22:23:00 <Dreadshoot> dons: pff, there's a reason why i only develope as a hobby
22:23:07 <tmoertel> dons: I keep Java away from my computer to avoid problems like that.
22:23:10 <Dreadshoot> makes you able to choose what you wanna do and not
22:23:21 <dons> truly java must be the most heavyweight language to have ever been used for embedded code
22:24:04 <dons> I think the Java-in-Browser concept was just too ambitious for its time in the end.
22:24:23 <dons> when a lightweight interpreter for say, scheme, would have been a better choice
22:24:26 <tmoertel> well that's better... restarting Thunderbird brought the RAM usage down to a slim 467 MB
22:24:46 <dons> instead we get stuck with a 3 week hack, i.e. javascript. or as the author of Javascript said at iCFP last year: I would have just used python
22:25:11 <tmoertel> still, I would rather use JavaScript than Java
22:25:15 <ThreeQ> javascript actually isn't a bad language
22:25:44 <tmoertel> at least it has closures and first-class funs
22:25:59 <dons> it was a 3 week hack though. the author was asked to come up with a scripting language with very little notice. so its a schemish/lispish/perlish mix
22:26:20 <dons> ah well. our industry is full of hacks and bad engineering
22:27:01 <sjanssen> lately, I've noticed a lot of Haskell name dropping here and there
22:27:05 <sjanssen> good sign, I think
22:27:12 <tmoertel> thank goodness we've got marketing to cover it all up  ;-)
22:27:23 <dons> I always feel embarrassed when flying, when the video-on-demand systems for in-flight movies crash under the load of like ... 150 users ... and the pilot has to reboot the system
22:27:35 <dons> tmoertel: right :)
22:28:07 <dons> sjanssen: yeah. me too. i've noticed a bit of a vibe: lots of bloggers i've never heard of writing on haskell, and doing interesting things.
22:28:15 <tmoertel> "Attention, passengers.  This is Cap'n Billy, your pilot.  Could somebody come up here and hold the wheel?  I've gotta reboot our video system."
22:28:48 <tmoertel> It's the lens effect of Reddit.
22:28:55 <dons> that, a long with the instructions to the effect "Please don't click too often, you'll overload the system"
22:29:04 <dons> tmoertel: hmm. maybe
22:29:18 <tmoertel> del.ic.isipu.ous, too
22:29:28 <tmoertel> (sorry, I can't ever type that right.)
22:29:41 <dons> so I wonder if its because of nicely targetted RSS and so on, I just don't see the 1000s of non-haskell stuff out there, and get the impression that the whole world is talking Haskell....
22:29:47 <Pseudonym> sup.erf.luo.us
22:30:08 <dons> tmoertel: i note your coffee blog is on reddit today :)
22:30:22 <dons> timely, after yesterday's talk
22:30:46 <tmoertel> dons: yes.  it's been there before, but reddit gets enough new users that every few months articles get relisted, and the float up the ranks again.
22:30:59 <dons> yeah
22:31:21 <tmoertel> dons: I pulled a great shot earlier today.  I tried to get a photo, but in the end the urge to drink it won out.
22:31:29 <dons> for example, as a sign that things are happening in the haskell world, this guy: http://www.alpheccar.org/en/posts/show/57
22:31:30 <lambdabot> Title: Haskell, PDF and Penrose Tilings
22:31:34 <dons> do we know who he is?
22:31:41 <dons> tmoertel: heh!
22:32:10 <dons> there's been quite a number of tarticles in the last couple of months of people doing interesting things in .hs, but from outside the 'core' community. that's a good sign
22:32:28 <tmoertel> indeed.
22:32:42 * tmoertel pulls the "Penrose Tilings" source
22:32:44 <dons> and when I see things like lazy lists in perl6, and C#, ... or monads in ruby, that's indicative of something
22:33:22 <Cale> I've been listening to the same two songs over and over again all day, and I'm still not sick of them :) Mind you, each is 26 minutes long.
22:33:51 <tmoertel> Cale: Pink Floyd?
22:34:06 <Cale> Chris Potter Group
22:34:20 <Cale> It was a live concert at Parc Floral
22:34:58 <Pseudonym> Could be just about any prog band.
22:35:08 <Pseudonym> Hell, I've got a Jethro Tull album with only one song on it.
22:35:29 <Pseudonym> I don't know how they decided to split it in half.
22:35:43 <Pseudonym> (Remember when recordings had to be flipped over?)
22:36:20 * tmoertel remembers 8-track tapes
22:36:34 * Pseudonym remembers 6250 bpi tapes
22:36:56 * tmoertel remembers using audio cassettes to store data via "screech encoding"
22:36:58 <Cale> With Wayne Krantz, Craig Taborn and Nate Smith
22:37:25 <Pseudonym> Actually, not requiring the flip was an advantage of wax cylinders.
22:37:30 <Cale> Wayne Krantz is a ridiculously incredible guitarist
22:40:54 <Dreadshoot> @seen foxy
22:40:55 <lambdabot> I saw foxy leaving #haskell 5h 38m 8s ago, and .
22:49:35 <tmoertel> yay!  my GHC build is finished.
22:50:49 <dons> cool
22:50:56 <dons> did you try -jN ?
22:51:24 <tmoertel> dons: no, I was too cowardly: afraid I'd have to rebuild again if something got subtly hosed.
22:51:40 <dons> hmm:
22:51:40 <dons>   PID USERNAME PRI NICE  SIZE   RES STATE    WAIT     TIME    CPU COMMAND
22:51:41 <dons> 22003 dons      64    0  192M   24M run      -       76:22 94.87% java_vm
22:51:44 <dons> :|
22:51:44 <tmoertel> dons: and there was the matter of keeping a CPU free for video decoding.  ;-)
22:51:48 <dons> true
22:51:58 <JohnMeacham> is there a tool for helping generate type theory proof trees, that can then spit out tex?
22:52:12 <dons> $ pkill -KILL java
22:52:13 <dons> :)
22:52:24 <vegai> better put that in cron
22:52:24 <dons> JohnMeacham: twelf can do this
22:52:30 <dons> vegai: heh
22:53:05 <dons> JohnMeacham: so you code up your type system judgements in twelf, and it can then help you find various proofs on the type system, and then dump the derivations as .tex
22:53:22 <dons> seems to be gaining some ground in the haskell world (I note Oleg and CShan have moved over to twelf)
22:53:25 <JohnMeacham> ah. okay. I'll look that up.
22:53:29 * tmoertel delights in the GHCi 6.6 Prelude> prompt
22:53:40 <dons> and its been big in the ML world for a while, at least at  CMU.
22:53:57 <dons> tmoertel: oh, what's changed?
22:54:50 <vegai> ghci should define a 'help' -function that would show the API docs of any function
22:55:04 <tmoertel> dons: the fact that it isn't "GHC not built for interactive use"
22:55:12 <tmoertel> ;-)
22:55:13 <dons> ah heh :)
22:55:19 <dons> good good
22:57:25 <Dreadshoot> hmm doesnt ghc include make in win?
22:58:24 <JohnMeacham> hmm.. it just gives an error when I try to run it..
22:58:27 <araujo> Ok, we got other HWN publication in spanish :-)
22:58:34 <JohnMeacham> will look for another distribution..
22:58:36 <araujo> dons, i re-check and push
23:02:07 <dons> araujo: ok. cool darcs send to me?
23:02:33 <JohnMeacham> is eric meijer or jan-willem roorda on irc here?
23:02:34 <dons> JohnMeacham: its a theorem prover. its mostly going to output errors :)
23:02:41 <dons> don't think so
23:03:48 <JohnMeacham> hmm.. I'd like to document jhc's type system, so need to generate all those pretty proof tree tables. but it is beyond my TeX depth so was hoping to find some examples to re-use...
23:04:09 <JohnMeacham> or i can scan in my handwritten ones. the soda stains make them classy.
23:04:15 <dons> oh, perhaps find the .tex source to some haskell type systme paper you like?
23:04:24 <dons> i.e. like the new ATs paper.
23:04:43 <dibblego> goddam Sydney is in DST for APLAS isn't it!!?
23:04:48 <dons> you could just write some tex macros and away you go. of course, coding the type system up in twelf might be nicer :)
23:04:58 <dons> dibblego: for aplas, maybe.
23:05:07 <dibblego> I just booked my flight then realised I'd be an hour late !@#$@$%@#$%#%^@%^$&&^** swear words!
23:05:10 <dons> dibblego: its 4pm here now. but i suppose DST is soon.
23:05:31 <JohnMeacham> yeah. but usually tex source isn't available online.
23:06:00 <dibblego> $30 to cancel a flight
23:06:01 <dons> right. you'd have to ask spj or someone very nicely, commenting on how nice the derivations are formatted :)
23:06:04 <araujo> dons, ok
23:06:13 <dons> dibblego: you might be able to get it moved just by calling though
23:06:19 <dons> on a domestic flight that should be doable
23:06:22 <araujo> i need a little help here though: ".. as an antidote to mid-term blues, three afternoons a year .."
23:06:28 <dibblego> I'll give it a try
23:06:39 <araujo> i am not sure how to translate that part
23:06:54 <dons> araujo: hmm. so you understand the sentence?
23:07:13 <araujo> dons, well, i don't know what it means with 'mide-term blues'
23:07:29 <dons> three afternoons a year, and to make us feel happy in the middel of the university session, ....
23:07:31 <araujo> blues as in the color or the emotional state?
23:08:03 <dons> in this case, to cure the poor UK academics sadness at the workload in the middle of the uni session :)
23:08:11 <araujo> hah
23:08:14 <Dreadshoot> dons: how would you build hs-plugins with the makefile?
23:08:22 <dons> Dreadshoot: you don't use the makefile
23:08:27 <dons> that's just to run the testsuite
23:08:29 <Dreadshoot> dons: why not?
23:08:30 <araujo> ok, thanks dons
23:08:37 <dons> Dreadshoot: it uses cabal instead
23:08:41 <dons> see the readme :)
23:08:46 <Dreadshoot> cant you choose
23:08:50 <dons> nope
23:09:01 <Dreadshoot> ok
23:09:01 <dons> you could always write your own makefile lines, which just call cabal..
23:09:16 <Dreadshoot> naah i havent used makefiles before
23:10:29 <dons> araujo: does translating the HWN help your english? I know my girlfriend switched her Gmail account over to spanish, since she found that helps :)
23:11:59 <Dreadshoot> i tried MSYS and use runplugs through that, but didnt work
23:13:24 <olliej> anyone seen saulzar in the recent past?
23:15:14 <lambdabot> Hmm, my memory is a little fuzzy but it has been exactly 3 days, 1 hour and 44 minutes since I saw saulzar.
23:16:12 <araujo> dons, Done.
23:17:14 <dons> araujo: great.
23:17:20 <dons> i'll post it
23:17:20 <araujo> dons, Quite much. And i am happy to do it too, since i am not taking an english course this semester, this helps me to practice :-)
23:17:30 <dons> cool
23:18:31 <araujo> dons, i hope your girlfriend doesn't have any excuse to not using Haskell now ..... :-)
23:18:48 * tmoertel admits that the waning effects of distantly drunk espresso are no longer sufficient to maintain his unsleepful state
23:19:08 <dons> araujo: heh. good idea!
23:19:13 <tmoertel> 'night
23:19:23 <dons> night tmoertel
23:23:01 <araujo> brb
23:29:34 <vegai> http://www.knowing.net/images/SteveYeggesSwipeatExplicitTyping_7538/larsonoct19873.gif
23:29:38 <lambdabot> http://tinyurl.com/yfywno
23:30:08 <dons> yeah, I liked that.
23:31:25 <glguy_> is there anything to try if apm doesn't know how to read my battery and a/c status?
23:31:28 <glguy_> or is that something that just works or doesn't
23:32:14 <glguy_> Battery state: unknown, 0% remaining, unknown life estimate
23:32:14 <glguy_> A/C adapter state: not known
23:32:14 <glguy_> Performance adjustment mode: cool running (600 MHz)
23:32:50 <dons> you're not running apmd?
23:33:05 <dons> /etc/rc.conf: apmd_flags=""  :)
23:33:08 <Botty> why do arrows have flow right to left?
23:35:02 <glguy_> dons: no...
23:35:12 <glguy_> apmd_flags=-C
23:35:14 <glguy_> is what I have
23:35:22 <glguy_> and pgrep says
23:35:26 <glguy_> 20996
23:36:31 <dons> -C ?
23:36:34 <dons> oh, is that in 4.0 ?
23:36:50 <glguy_> i suppose, that's why my mode is: cool
23:36:57 <dons> ah
23:37:10 <glguy_> it keeps the processor at minimum speed until i have < 10% cpu time free
23:37:17 <dons> ok
23:37:21 <glguy_> it's pretty responsive
23:37:35 <dons> that's nice. didn't know we had apmd+cpuspeed connection now
23:37:54 <dons> i've just been living with:
23:37:55 <dons> alias lo='sudo sysctl -w hw.setperf=0'
23:37:56 <dons> alias up='sudo sysctl -w hw.setperf=100
23:37:59 <glguy_> lol
23:38:03 <dons> :)
23:38:04 <glguy_> that still works though
23:38:06 <glguy_> but
23:38:12 <glguy_> apm -h and -H don't need sudo
23:38:21 <dons> hmm.
23:38:29 <dons> I wonder why.
23:38:31 <glguy_> maybe wheel group
23:38:48 <dons> maybe
23:38:55 <glguy_> oh, nvm
23:39:33 <glguy_> didn't work as normal user
23:39:54 <glguy_> no, it did work
23:39:58 <glguy_> and it's -H and -L
23:40:03 <glguy_> the -L threw me
23:40:34 <glguy_> and it's wheel
23:40:41 <glguy_> apm creates a socket in /var/run/apmdev
23:40:51 <glguy_> srw-rw----  1 root  wheel  0 Oct 20 00:56 /var/run/apmdev
23:41:04 <glguy_> *end monologue*
23:41:07 <Dreadshoot> @version
23:41:07 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
23:41:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:42:25 <glguy_> i love that when I'm not logged in , the whole operating system only has 5 meg active memory
23:42:45 <dons> oh, that's a bit high :)
23:42:59 <dons> i've seen it lower than that, since I use to run it on an 8M ram mac68k :)
23:43:05 <glguy_> it's a guess since it's impossible to know
23:43:06 <dons> that's back in 2.7 days though
23:43:20 <dons> is that with X running?
23:43:22 <glguy_> i took the active now - what I've got open
23:43:24 <glguy_> oh, no
23:43:43 <glguy_> I figured out how to use wsconsctl to fix the control key
23:43:50 <glguy_> so I'm back in console
23:43:59 <glguy_> there is something seductive about the console
23:44:07 <glguy_> all I need is screen
23:44:49 <glguy_> this laptop has a gig of ram
23:44:53 <glguy_> and obsd isn't using it
23:44:59 <glguy_> so i cranked up the cachepct
23:45:17 <dons> better fork a jvm off to keep that ram fresh the..
23:45:27 <dons> don't want it getting stale
23:45:32 <glguy_> heh
23:46:12 <glguy_> do you have any idea why softdeps are  not the default?
23:46:25 <dons> oh, I think they are in -current
23:46:28 <dons> at least theo wants that.
23:46:37 <dons> since everyone runs softdeps now
23:46:45 <glguy_> i don't think they are default in -current
23:46:50 <glguy_> i just installed from snapshot
23:46:54 <glguy_> and had to add them to fstab
23:46:54 <dons> i think it was just after 4.0 was tagged he sent out a proposal to do this
23:47:01 <glguy_> hmm
23:48:00 <vegai> dons: the hs-plugin/ghc-6.6 is not something a random passer-by contributor can likely fix, is it?
23:48:19 <dons> I suspect not. But I could be surprised.
23:49:20 <vegai> is there a way to see what things look like after template haskell?
23:49:56 <dons> yeah, -ddump-* should show you
23:50:07 <dons> I think Lemmih might have even written a tool to do this?
23:50:59 <Cale> http://content.ytmnd.com/content/a/2/2/a224551a525ebf5e30cedf1f4ae16b99.gif -- ahaha
23:51:02 <lambdabot> http://tinyurl.com/kc8al
23:51:59 <vegai> Cale: check the wrinkles :)
23:52:53 <vegai> (i.e., looks like a fake, although funny)
23:52:59 <dons> heh
