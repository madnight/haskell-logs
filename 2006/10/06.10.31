00:03:15 <lispy> ?google paul graham language design
00:03:18 <lambdabot> http://www.paulgraham.com/langdes.html
00:03:18 <lambdabot> Title: Five Questions about Language Design
00:32:52 <musasabi> Am I missing something - Data.ByteString.Lazy seems to be missing breakEnd ?
00:33:39 * musasabi just needs a way to drop trailing whitespace
00:35:25 <lispy> musasabi: is there an init?
00:35:34 <lispy> actually, that wouldn't be so good
00:35:55 <lispy> reverse . dropWhile isSpace . reverse is probably really expensive
00:36:19 <musasabi> yes. not exactly cheap.
00:37:09 <musasabi> oh well I can loop and index into the bytestring and then finally use take.
00:37:30 <lispy> ah yeah, imperative, but effective
00:37:36 <Cale> also, init is O(1)
00:37:49 <lispy> Cale: but how do you know how many times to init?
00:37:59 <Cale> by looping recursively, I suppose
00:38:01 <lispy> iterate and check isSuffixOf?
00:41:11 <dons> ?seen coffeemug
00:41:11 <lambdabot> I saw coffeemug leaving #haskell 4d 4h 47m 15s ago, and .
00:41:54 <Cale> and .
00:42:08 <musasabi> dropWhileEnd :: (Char -> Bool) -> ByteString -> ByteString
00:42:08 <musasabi> dropWhileEnd p bs = L.take (w (L.length bs)) bs
00:42:08 <musasabi>     where w 0 = 0
00:42:08 <musasabi>           w k = if p (index bs (k-1)) then w (k-1) else k
00:42:24 <musasabi> works fine, but not the way I think it should be done.
00:42:36 <dons> coffeemug++ http://www.defmacro.org/ramblings/lisp-in-haskell.html
00:42:39 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/yyr8sf
00:42:45 <musasabi> dons: is there a better way?
00:44:20 * dons looks
00:44:49 <lispy> dons: nice
00:45:19 <dons> that looks ok. i suppose you could walk backwards indexing the Ptr if you want
00:47:11 <therp> how needs a lisp interpreted when GHC can take lisp stuff directly :) http://clemens.endorphin.org/liskell.png .. that thing got much bigger last weak. at the moment I'm working on a macro transformation to template haskell.
00:48:55 <dons> mm!
00:48:56 <lispy> therp: creepy!
00:48:59 <Botje> therp: how're you going to integrate pattern matching into the lisp syntax?
00:49:06 <lispy> therp: interesing type syntax
00:49:14 <therp> just a sec
00:49:44 <therp> http://clemens.endorphin.org/Factorial.lsk
00:50:06 <therp> that's the last code it can compile. the syntax can be simplified a bit. I was taking a "the most simple thing has to work" approach
00:51:00 <lispy> therp: i find the prefix of familiar things amusing
00:51:08 <lispy> therp: like (-> Int Int) is funny :)
00:51:17 <dons> therp: does it run fast?
00:51:35 <therp> botje: bindings is quite simple, "a" is var, (a b c) is a funbinder and (A b c) is a constructor pattern. give me a few minutes to make a few examples
00:51:40 <dons> how ironic, the first version of haskell (Yale Haskell) compiled to lisp... 20 years later ...
00:51:41 <Botje> therp: k
00:51:51 <therp> dons: it's native haskell. it's an in-ghc parsetree-to-haskell parsetree converter
00:52:02 <dons> yeah, i understand that.
00:52:18 <dons> ah, so its not valid lisp?
00:52:53 <therp> dons: I guess then the answer is no. I'm not handling strings very efficiently. it's like I chose the most simple parser generated from alex/happy I can get
00:52:54 <lispy> dons: nope
00:53:06 <therp> dons: no, I "invented" the syntax from scratch
00:53:09 <lispy> dons: but, it could be a new dialect
00:53:12 <dons> is the goal to have valid lisp? what is the goal, actually? :)
00:53:26 <dons> it seems REALLY cool!
00:53:47 <Botje> with enough macro sugar, it could become valid lisp.
00:53:59 <therp> dons: my goal is to have a lisp like syntax with all the goodies of haskell (strong static typing etc.)
00:54:16 <therp> dons: that includes a macro facility that is more easy to handle than template haskell
00:54:22 <dons> therp: nice! you might even be able to get a few people to help, if you put the darcs repo up somewhere?
00:54:28 <therp> dons: but I just started coding that an hour ago
00:54:32 <dons> heh
00:54:36 <lispy> therp: wow!
00:55:40 <therp> dons: until yesterday I wasn't even sure how I could get there with macros, so I hesitated a bit to push stuff things out.. and actually it's just been a week of work
00:56:14 <therp> the lexer is also totally broken, no string handling, just the most basic alex stuff. no lexer monad.. no proper error messages and so.. it's a bit premature to talk about a darcs repo :)
00:59:07 <dons> a darcs repo should be the first thing you do...
00:59:16 <dons> here, for free: darcs init ; darcs record *
00:59:19 <dons> :)
00:59:34 <lispy> well, darcs add * ; darcs record -a
00:59:49 <dolio> ?instances Random
00:59:49 <dons> ah yes
00:59:50 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
00:59:56 <dons> ?hoogle Random
00:59:57 <lambdabot> Random :: module
00:59:57 <lambdabot> System.Random :: module
00:59:57 <lambdabot> System.Random.Random :: class Random a
01:00:01 <dolio> ?instances-importing System.Random Random
01:00:02 <lambdabot> Bool, Char, Double, Float, Int, Integer
01:00:18 <dons> there's some more in lambdabot, if you need them.
01:00:31 <dolio> I was hoping for (Int, Int)
01:00:33 <lispy> dons: did you see my idea about adding arrows syntax to shells?
01:00:43 <dons> no?
01:00:48 <dons> dolio: should be easy to write.
01:00:52 <lispy> dons: do you think you could add the arrow functions via h4sh?
01:01:13 <dolio> Yeah, I tried, but GHC complained about (Int, Int) being a type synonym or something.
01:01:33 <dons> hmm?
01:01:35 <dons> let me see..
01:01:37 <therp> botje: reload the Factorial.lsk page, I added a few pattern examples. and yeah they actually work
01:01:56 <lispy> dons: goes like this, one use of arrows/monads is for dataflow and controll...and that's what piping in shell is all about too...so maybe adding arrows to the shell would give new forms of use that are really handy
01:02:36 <dons> like building cycles? i.e. pipes with two inputs and so on?
01:02:47 <dons> graph like pipes would be the obvious thing
01:03:04 <lispy> i'm not sure, i don't have a strong grasp of arrows, but i was thinking it would make redirection and pipe spliting possible
01:03:14 <Botje> therp: cool! :)
01:03:38 <lispy> dons: maybe it's just a pipe dream :)
01:04:02 <lispy> does latex have a nice way to make interaction diagrams?
01:04:12 <lispy> i guess i could do it on paper, but...bleh
01:04:14 <araujo> hello
01:04:19 <lispy> araujo: howd
01:04:19 <araujo> therp, it looks nice
01:04:22 <lispy> +y
01:04:26 <araujo> hola lispy
01:05:10 <Smokey`> does haskell have bit shifting operators by any chance?
01:05:14 <pzpz> lispy: dia -> eps ?
01:05:21 <dolio> > 2 `shiftR` 1
01:05:21 <lambdabot>  Add a type signature
01:05:30 <dolio> > 2 `shiftR` 1 :: Int
01:05:31 <lambdabot>  1
01:05:38 <dons> ?docs Data.Bits
01:05:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
01:05:48 <dons> ?hoogle bits
01:05:49 <lambdabot> Data.Bits :: module
01:05:49 <lambdabot> Data.Bits.Bits :: class Num a => Bits a
01:05:49 <lambdabot> Data.Bits.bitSize :: Bits a => a -> Int
01:05:49 <Smokey`> dons: champion :) ty
01:05:55 <pzpz> >shiftR 1 1 :: Int
01:05:57 <lispy> pzpz: i've used dia for some odd things in the past, but i think the diagram i want is more of a table than a diagram
01:06:06 <dons> pzpz: missing space.
01:06:16 <pzpz> dons: what a stupid bot.
01:06:22 <lispy> heh
01:06:32 <lispy> ?vixen don't be dumb!
01:06:32 <lambdabot> we get along well, you know?
01:06:35 <dons> heh. syntax isn't really that hard.
01:06:54 <pzpz> what else could follow a > ?
01:06:58 <dons> (its like that for a reason, so people who write funny smilies don't get annoyed, >:)
01:07:02 <pzpz> > shiftR 1 1 :: Int
01:07:03 <lambdabot>  0
01:07:25 <pzpz> does lambdabot have a max int size?
01:07:36 <int-e> > maxBound :: Int
01:07:37 <lambdabot>  2147483647
01:07:38 <dons> > maxBound :: Int
01:07:39 <lambdabot>  2147483647
01:07:46 <dons> > 666 ^ 666 -- or not ;)
01:07:47 <pzpz> it wont shift to bigint?
01:07:47 <lambdabot>  2715417592887128558260874551700217860278385210650169871782230046965783675347...
01:07:56 <pzpz> ah, oh
01:07:59 <dons> > shiftR 1 1 :: Integer
01:08:00 <lambdabot>  0
01:08:11 <pzpz> > shiftR 1 2 :: Int
01:08:12 <lambdabot>  0
01:08:29 <pzpz> i really thought I was going to break it.
01:08:31 <int-e> > maxBound :: Integer
01:08:31 <lambdabot>  add an instance declaration for (Bounded Integer)
01:08:32 <lambdabot>   In the expression: ma...
01:08:33 <lispy> Common Lisp is the only think i know of that shifts the representation if you start to overflow
01:09:20 <pzpz> how does haskell then know when to use bigint?
01:09:21 <Cale> coffeemug++
01:09:35 <lispy> pzpz: because you requested it
01:09:38 <int-e> you tell it by using the Integer type
01:10:10 <dolio> Ruby does it too, but I suspect that's copied from Lisp.
01:10:14 <Cale> Integer will internally use machine integers when the numbers are small enough, but it does additional checks and swaps over to GMP integers when the numbers are too large
01:10:55 <Smokey`> oh, wow... so Int is a two's complement Integer implementation, where as Integer would be a string-rep integer implementation?
01:10:58 <lispy> yeah, sounds familiar
01:11:04 <Smokey`> > 666 ^ 666 :: Int
01:11:05 <lambdabot>  0
01:11:08 <Cale> Smokey`: Base 2^n
01:11:08 <dons> Smokey`: unbounded integer, yeah.
01:11:09 <Smokey`> sweet :)
01:11:21 <Cale> Probably base 2^32 :)
01:11:36 <lispy> Int depends on platform
01:11:38 <int-e> > 637 ^ (2^31) :: Int
01:11:39 <lambdabot>  1
01:11:49 <lispy> in ghc, Int seems to be wordsized
01:11:58 <Cale> yeah, the only way to tell the size of Int for sure is to use minBound and maxBound
01:12:03 <lispy> so on x86_64 you get 64bits
01:12:04 <dons> in Haskell, Int is word sized (or > 2^29-1 anyway)
01:12:24 <Baughn> Only, /word/ depends on platform..
01:12:48 <lispy> Baughn: yeah, when i say word i mean the native register size
01:12:54 <dons> so yeah, you can assume it is then underlying native int size
01:13:32 * lispy plans to make a CPU with 35 bit registers so you can use tagged reps an still have 32 bit ints :)
01:13:47 <int-e> > maxBound :: Word
01:13:49 <lambdabot>  4294967295
01:14:05 <lispy> oh and Word == unsigned Int, right?
01:14:34 <Cale> Everyone log in to reddit and mod up coffeemug's article :)
01:14:57 <Cale> http://programming.reddit.com/info/oj1w/comments
01:15:00 <lambdabot> Title: Writing A Lisp Interpreter In Haskell - defmacro (reddit.com), http://tinyurl.com/vxtg4
01:15:10 <musasabi> Does anyone have Base64 encoding/decoding for ByteStrings handy?
01:15:14 <int-e> lispy: yes, they come from the FFI addendum. (Data.Word and Data.Int that is)
01:15:36 <Baughn> lispy: While you're at it, add tag-dispatching and exceptions for overflow to the ALU
01:15:45 <Cale> This is really the sort of thing we want everyone to see
01:15:55 <int-e> hmm.
01:16:01 <int-e> @hoogle Word
01:16:02 <lambdabot> Data.Word :: module
01:16:02 <lambdabot> Data.Word.Word :: data Word
01:16:02 <lambdabot> System.Win32.Types.WORD :: type WORD
01:16:08 <dons> musasabi: not that i know of, but sounds cool. possibly the pugs guys have something iek that?
01:16:19 <Bobstopper> Wow... nesting StateTs within StateTs can get pretty awkward...
01:17:16 <Cale> Bobstopper: but it's generally unnecessary
01:17:22 <musasabi> they implemented it in Perl6 it seems.
01:17:26 <lispy> Baughn: hmm...interesting, is that called typed assembly?
01:17:37 <dons> Cale: yeah. i agree. we should try to adopt anyone in the lisp community looking for a way out :)
01:17:44 <Cale> also, if you're nesting a bunch of monads, you should be newtyping and implementing your primitives with proper types
01:17:54 <Baughn> lispy: I have no idea. You could look up the old lisp machine documents, though; they did it.
01:17:55 <lispy> dons: ah, that's what you guys did with me! ;)
01:18:16 <lispy> Baughn: ah, it's a foozle
01:18:23 <dons> Cale: ha, you wrote "Mod this up" :)
01:18:29 <Cale> hehe :)
01:18:36 <dons> lispy: right!
01:18:40 <lispy> and forgot to finish it with "G"
01:18:46 <dons> now WE OWN YOU!
01:18:49 <lispy> hehe
01:19:01 <Cale> pwned
01:19:16 <Bobstopper> Cale: You mean instancing new custom-defined monads?
01:19:29 <Smokey`> hmm, curious how the haskell standard libraries dont differenciate between the native integer type, unbound integer type, and 16/32/64/128bit integer types... (guess that where packing/unpacking of data into bytestrings comes in, when you need to store data like that...)
01:19:39 <Bobstopper> How about in the situation where one library provides a monad based on StateT and I want to write another State which wraps around it?
01:19:44 <dons> Smokey`: that's what Word* and Int* are for
01:19:49 <dons> ?docs Data.Word
01:19:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
01:19:55 <dons> ?docs Data.Int
01:19:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Int.html
01:20:11 <Cale> Bobstopper: yeah, if you're using lots of monad transformers, what you really want to do is write something like  newtype MyMonad a = MM (FooT (BarT BaseMonad) a)
01:20:11 <Smokey`> hmm
01:20:11 <dons> ?kind Word8 -- for example
01:20:13 <lambdabot> *
01:20:24 <Cale>  deriving (Functor, Monad, ...)
01:20:24 <dons> there's also sized Ptr types now
01:20:50 <Cale> and then write some appropriate instances of classes and/or implement your basic primitives in terms of the transformers you have
01:21:00 <Smokey`> dons: my bad :)  I clearly wasen't looking hard enough =)
01:21:02 <Cale> this also gives you a great place to insert consistency checking
01:21:20 <Cale> and extra features you don't get for free from the transformer
01:21:34 <Bobstopper> Hmm... do you have any examples of that sort of thing in action?
01:21:36 <Cale> You do this in a new module and you don't export MM
01:21:36 <dons> oh nice, "I was putting off (and meaning to get around to) cabalising my software until I saw how easy it was
01:21:38 <Cale> sure
01:21:39 <dons> on this page. -- kowey"
01:21:46 <Cale> my Sudoku solver is a decent one :)
01:21:52 <Bobstopper> Cool, thanks.
01:22:00 <Cale> I'll grab a link
01:22:22 <Cale> http://www.haskell.org/haskellwiki/Sudoku -- right at the top
01:22:24 <lambdabot> Title: Sudoku - HaskellWiki
01:22:27 <lispy> dons: yeah, kowey is good to for the community
01:22:34 <Bobstopper> Excellent, thanks plenty.
01:22:41 <Cale> newtype Sudoku a = Sudoku (StateT (DiffUArray (Int,Int) Int) Nondet a)
01:22:41 <Cale>     deriving (Functor, Monad, MonadPlus)
01:23:09 <Cale> but I don't expose the StateT bit to the rest of the world
01:23:34 <Cale> I just use it, along with the nondet part to implement a primitive in my embedded Sudoku language called 'place'
01:23:50 <Cale> which tries to put a number in a cell, and initiates backtracking if it can't
01:24:18 <Bobstopper> Nice. I'll have a good stare at it. Thanks.
01:25:09 <lispy> Cale: have you ever created a tutorial about this stuff on the new wiki?
01:25:18 <Cale> I really should
01:25:29 <lispy> yeah
01:25:34 <lispy> it's worth at least 2 karma :)
01:25:55 <Bobstopper> oh, I forgot about that. Cale++
01:26:00 <Bobstopper> Cale++
01:26:04 <Cale> Because I don't think there's a really obvious way to learn that currently other than to have someone tell you or realise for yourself that's what you're meant to do with monad transformers these days :)
01:26:16 <dolio> Oh, I took the liberty of linking to the existing sudoku page for the ruby quiz problem on sudoku.
01:26:25 <dolio> I figured that 13 or so solutions might be enough.
01:26:28 <Cale> hehe
01:26:37 <dons> Cale: good point. we have to document everything we know, if people are to ever work it out
01:26:55 <dons> that was one of the key lessons for success i got from the Soc summit -- document everything
01:26:56 <lispy> yeah, have to distribute the congnition
01:27:22 <dons> yeah. it can't depend on word of mouth (e..g as the libraries submission process was)
01:27:22 * lispy likes the phrase "distribute your cognition"
01:27:35 <dons> i'd wear that on a tshirt!
01:27:46 <Bobstopper> does the karma stuff add karma silently?
01:27:50 <dons> ?remember lispy distribute your cognition
01:27:50 <Cale> reminds me of Alula codes.
01:27:52 <dons> Bobstopper: yup
01:27:57 <Bobstopper> ok
01:27:58 * roconnor infects lispy's cognition
01:28:02 <lispy> heh
01:28:18 <lispy> anyone have gimp skills, we could get that shirt at cafe press
01:28:39 <lispy> "distribute your cognition" on the front and "#haskell@irc.freenode.net" on the back
01:28:44 <dons> mmm!
01:28:50 <dons> I like!
01:28:51 <Baughn> Wouldn't take much work, either
01:29:17 <dons> "#haskell @ freenode" on the back woudl work for me.
01:29:24 <lispy> sire
01:29:26 <lispy> er sure
01:29:36 * Baughn nods. Anyone who knows IRC would understand.
01:29:49 <dons> ok. let's whip something up! contest ends in 24 hours!
01:29:55 <lispy> hah!
01:29:59 <lispy> i can't start to tomorrow
01:30:06 <lispy> so goodthing we have 24hours
01:30:11 --- mode: ChanServ set +o dons
01:30:49 --- topic: set to '["Design a #haskell tshirt - Distribute your cognition!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
01:30:53 --- mode: ChanServ set -o dons
01:31:01 <Cale> huh, it's almost impossible to find very much about Ebon Fisher's bionic codes art project
01:31:14 <Cale> I suppose it's been a decade or so ;)
01:32:05 <roconnor> Cale: do you think option should be part of the standard library?
01:32:11 <Cale> roconnor: yes
01:32:27 <roconnor> I wrote the same function for my backtracking search to solve the adventure puzzles
01:32:38 <roconnor> I called it choose
01:32:39 <Cale> It's an embedding of the list monad into any nondeterminism monad :)
01:32:59 <Cale> Something I'd consider fairly important :)
01:33:33 <lispy> it's something i'd like to get more experience with, that and using continuations
01:35:16 <Cale> I'd like to sort out if anything like a continuations-based webserver could be written in Haskell using an appropriate continuation monad, or whether those rely too heavily on continuations being first class, or whether you'd need an arrow or something to ensure greater decomposability
01:35:33 <Bourbaki> moin
01:35:38 <Bourbaki> dons are you awake?
01:36:20 <roconnor> Cale: would Nondet be more efficent if it was newtype [a]?
01:36:44 <Cale> roconnor: It's more efficient than lists
01:36:51 <roconnor> why?
01:37:08 <Cale> I suspect because functions are easier for GHC to optimise
01:37:23 <Cale> It's a tad slower than the list monad if optimisations are turned off
01:37:30 <roconnor> Cale: should I get rid of all datatypes in my code?
01:37:35 <Cale> hehe
01:37:39 <Cale> I wouldn't
01:37:44 <roconnor> Why not?
01:38:21 <Cale> Well, note that Nondet is seriously more inconvenient than lists for anything but implementing nondeterminism
01:38:53 <roconnor> Well, you lose pattern matching I guess.
01:38:57 <Cale> yeah
01:39:04 <roconnor> So, should GHC get rid of all datatypes then?
01:39:06 <Bourbaki> Cale do you know if theres something like mathematica or octave written in haskell?
01:39:30 * araujo off to univ!
01:39:36 <Cale> Bourbaki: the closest thing I can think of, which isn't really very close is a library for abstract algebra
01:40:05 <Bourbaki> i see a pitty
01:40:07 <Cale> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
01:40:09 <lambdabot> Title: Libraries and tools/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
01:40:11 <Bourbaki> thanks
01:40:16 <Cale> DoCon
01:40:25 <Cale> HGAL is also really interesting
01:40:34 <Bourbaki> whats that?
01:41:08 <Cale> Basically an implementation of nauty, which is a tool for computing the automorphism groups of graphs, producing canonical labellings, and isomorphism testing
01:41:20 <Cale> Fairly specialised, but a nice thing to have
01:41:35 <Bourbaki> ah well i want to have a quit testbed for my fluid solver
01:42:13 <Bourbaki> in haskell this would be quite elegant i think but rendering with hgl is a pain imho
01:43:32 <Bobstopper> Hmm... I don't think I'm grokking this concept. What's does using a newtype win you over using plain type synonyms with nested MonadTrans'?
01:43:57 <int-e> Bobstopper: you can hide instances
01:44:27 <Cale> Bobstopper: you can hide instances, and implement them however you like -- in particular, you can hide any lifts which would otherwise be required
01:44:50 <Cale> Now, in the mtl, there are a bunch of very general lifting instances which try to do this for you
01:44:53 <Bobstopper> Ohhh the lifts...
01:45:19 <Cale> but I think the better way is to just newtype and then implement whatever classes you really want -- maybe even your own
01:45:28 <int-e> Bobstopper: with type X = StateT ... you are stuck with the MonadState, Monad and whatever instances your State transformer has, while without it you can provide them or not as you see fit
01:45:45 <Bourbaki> is lifting in haskell something like shifting an element into another space?
01:45:58 <Bourbaki> that is similar to return in a monad
01:46:05 <int-e> 'lifting' has many meanings.
01:46:16 <Cale> Bourbaki: yeah, the lifts we're talking about take you from one monad, to its transformed version
01:46:18 <int-e> @type lift
01:46:20 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
01:46:24 <int-e> that's one.
01:46:33 <Cale> the important thing there is just the last bit
01:46:47 <Cale> m a -> t m a for some monad m and monad transformer t
01:47:10 <Bobstopper> Ok... I think I'm following now... The lifting thing could come in handy. Thanks again.
01:47:14 <Bourbaki> if you have a ring of lifts with structures (eg classes) on each element
01:47:31 <Bourbaki> then you can use all the operators of these classes for all elements right?
01:48:19 <Cale> um, ring?
01:48:27 <int-e> I don't understand.
01:48:28 <Bourbaki> with a ring of lifts you get a bijective function for all spaces
01:48:32 <Cale> I don't think lifts form a ring here
01:48:41 <Bourbaki> sry im a bit bad at explaining what i mean
01:48:44 <Cale> at least, not in any obvious way
01:48:51 <Bourbaki> small example
01:48:59 <Bourbaki> A -> B -> C -> A
01:49:02 <Cale> lifts tend to be injections though
01:49:19 <Bourbaki> A B C are spaces of elements with operators on it like * + - and so on
01:49:45 <Bourbaki> so by beeing able to use these lifts i can get a function from all elements into one and the other direction
01:49:50 <Bourbaki> forming a bijection
01:50:17 <Bourbaki> so i should be able to use all the operators in all the classes over A B and C on all elements of A B and C right?
01:50:39 <int-e> 'cycle' is better than 'ring' in this context.
01:50:49 <Cale> lift in Haskell isn't anywhere near that general
01:51:10 <Bourbaki> ok but i could construct it that way i think
01:51:27 <Bourbaki> this is what i wanted to do for my graph programming stuff
01:51:58 <Bourbaki> the graph can be transformed into a program and a CT diagram into a graph again with topological information and so on
01:52:33 <Cale> I never did understand what you were trying to do there ;)
01:52:57 <Bourbaki> well the idea is to show that its more or less equivalent
01:53:01 <Cale> But I will be interested in seeing it if you ever write it.
01:53:11 <Bourbaki> so if i make a change on the graph its propperly defined for the change in the program
01:53:34 <Bourbaki> i hope that ill get at least one more on the team familiar with haskell to get the graph stuff working
01:54:24 <Bourbaki> atm i write a new article for a shader book and moving so i have little time for another project
01:55:48 <roconnor> @type mapMaybe
01:55:49 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
01:56:44 <Bourbaki> has anyone of you seen the mit sketching video ?
02:00:42 <mr_ank> Bourbaki: this one? http://www.youtube.com/watch?v=NZNTgglPbUA
02:01:00 <Bourbaki> yep
02:01:19 <Bourbaki> i had the idea to combine this idea with my own graph programming idea in haskell
02:09:58 <lispy> neato
02:11:22 <Bourbaki> does anyone of you know where you can buy one of these back projecting boards?
02:18:07 <Baughn> Bourbaki: You don't necessarily need one - just use a projector + a semi-transparent whiteboard
02:18:59 <Bourbaki> Baughn yep just saw that also but there are integrated methods already that make it a lot easier they arent too expansive also about 2k euro
02:19:27 <Bourbaki> i might think about this and have a real flat tv :)
02:22:06 <Baughn> Bourbaki: No fair, making me jealous of MIT like that
02:22:52 <Bourbaki> ? im not at mit hehe
02:23:15 <Baughn> Oh, I'm not necessarily jealous of /you/. Just generally jealous.
02:23:28 <Bourbaki> heh
02:23:39 <Bourbaki> well mit also just boils with water
02:24:23 <Bourbaki> if i had that amount of money and manpower i could do alot of cool stuff too
02:24:27 <Baughn> Yes, but they have Ice-9 to cool it off when they're done
02:24:46 <Bourbaki> ice 9?
02:24:54 <Bourbaki> i have vanilla ice :)
02:26:02 <Baughn> Bourbaki: See http://unenumerated.blogspot.com/2005/11/patent-goo-self-replicating-paxil.html
02:26:05 <lambdabot> Title: Unenumerated: Patent goo: self-replicating Paxil, http://tinyurl.com/lv26d
02:28:51 <Bourbaki> interesting
02:29:13 <carp_china>  /quit
02:29:29 <Baughn> In all sorts of ways. Also suggests that the people who think real gray goo might not be all that dangerous are off their rockers.
02:41:35 <crashmatrix> Baughn, if I may ask, in what timezone do you live and... are you -really- always here or am I just being fooled? :p
02:41:53 <Baughn> crashmatrix: CET, and I'm actually an AI so time doesn't matter to me
02:42:01 <Baughn> crashmatrix: Or, okay, I just don't log off. :P
02:42:22 <crashmatrix> CET.. then you are in my timezone, i guess that's possible then =p
02:45:58 <gour> dons: you plan to tweak Yi for ghc-6.6 ?
02:46:21 <lispy> gour: last i heard he still needed to port hs-plugins to 6.6
02:46:58 <gour> lispy: i see. it would be nice to have it, so hiDE can go further ;)
02:49:39 <lispy> gour: aye, and i run a lambdabot and i want to upgrade to 6.6 but the lambdabot makes me hold back
02:49:52 <lispy> gour: because of the hs-plugins dep
02:50:25 <gour> lispy: i also cannot build lambdabot and want to try goa
02:50:48 <lispy> ?yar
02:50:49 <lambdabot> Well Ahoy! thar.
03:12:43 <gour> wonderful article about haskell - http://www.defmacro.org/ramblings/lisp-in-haskell.html
03:12:45 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/yyr8sf
03:14:38 <Bourbaki> gour is there any good lisp interpreter written in haskell?
03:15:11 <gour> Bourbaki: no idea. i jsut stumbled upon the article
03:19:12 <lispy> Bourbaki: good?
03:19:18 <lispy> Bourbaki: i think we only have toy ones
03:19:37 <Cale> gour: it's on http://programming.reddit.com/ -- mod it up if you haven't :)
03:19:40 <lambdabot> Title: reddit.com: programming - what&#39;s new online
03:19:40 <Bourbaki> basically the only feature i want to have is the dynamicness inhaskell
03:19:48 <lispy> Bourbaki: i bet you're more likely to find a nice scheme in haskell than a nice lisp (as in CL)
03:20:08 <lispy> Bourbaki: have you see Data.Typeable?
03:20:19 <lispy> Bourbaki: and Template Haskell?
03:20:29 <Bourbaki> lispy nope does it allow to interpret and complie code at runtime?
03:20:41 <lispy> Bourbaki: oh and read this http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
03:20:44 <lambdabot> Title: dagit.o » Blog Archive » Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
03:20:45 <Bourbaki> i havent had a lot of time lately to deal with haskell stuff
03:21:14 <lispy> Bourbaki: if you want to compile and eval at run-time then you'll want ghc-api
03:21:21 <Bourbaki> has anyone any info how haskell.NET is coming along?
03:21:33 <lispy> sadly no info
03:21:45 <Bourbaki> i consider this quite interesting
03:22:20 <lispy> yes, if i could use haskell as a replacement for VB.NET and VBA then i would be much happier at work :)
03:22:30 <Bourbaki> heh
03:22:37 <lispy> quite seriously
03:22:55 <lispy> i tend to use VB over C# just because i know VB a bit better
03:22:56 <Bourbaki> id like to use it in C# along with c++/CLI
03:23:15 <Bourbaki> i just had a look into c# some weeks ago and think its quite good
03:23:20 <Bourbaki> alog of nice concepts
03:23:23 <Bourbaki> er lot
03:23:32 <lispy> which one 3.0?
03:23:50 <Bourbaki> i think i had a look at .NET 2.0
03:24:05 <Bourbaki> but i mean also the general language concepts like attribute and such
03:24:09 <Bourbaki> and the reflection stuff
03:25:12 <lispy> i wrote most of a prototype in haskell and had the requirements changed on me
03:25:15 <Philippa> attributes're a wonderful idea if your language isn't performance-tied ala C++
03:25:22 <lispy> it now needs to be all VBA in Excel :(
03:25:39 <Bourbaki> Philippa i found it especially useful with the reflection stuff
03:26:13 <Bourbaki> lispy i think on the long run if m$ is doing a good job you will be able to use .net and thus whatever language you like
03:26:34 <SamB_XP> lispy: WHAT???
03:26:52 <lispy> SamB_XP: that's how i felt
03:27:16 <lispy> Bourbaki: yeah, but they don't want to know haskell exists
03:27:24 <lispy> Bourbaki: among other things
03:27:29 <lispy> (and i don't mean MS i mean my managers)
03:27:56 <Bourbaki> theres a F# language developed at the m$ research
03:28:09 <Bourbaki> its ocaml basically in .NET
03:28:33 <lispy> Bourbaki: i considered it, but it runs on a different CLR afaict
03:28:38 <Bourbaki> and from what i have seen there are quite some papers at the research sites on haskell
03:28:54 <Bourbaki> clr?
03:29:01 <lispy> the .net runtime
03:29:16 <lispy> iirc, f# runs on xlr
03:29:32 <Bourbaki> ah hm not that i know of i havent tested it yet just downloaded it the other day but you were able to load the source into C#
03:29:32 <Syzygy-> Oooooh. I'm quoted in the HWN
03:29:54 <Bourbaki> hwn?
03:29:58 <lispy> ?where hwn
03:29:58 <lambdabot> http://sequence.complete.org/
03:30:02 <Syzygy-> Haskell Weekly News
03:34:55 <lispy> dcoutts: (:[]) looks like a monster
03:34:58 <lispy> followed by
03:35:13 <lispy> Pseudonym: (:[]) looks like a ninja robot pirate monkey
03:35:18 <lispy> just a few weeks later :)
03:35:50 <gds> a ninja robot pirate monkey sounds pretty monsterous to me...
03:36:37 <lispy> i think it's funny that people are talking about (:[]) :)
03:36:40 <lispy> er...
03:36:45 <lispy> my smiley doesn't help
03:37:13 <Cale> @type ((:[]) :)
03:37:14 <lambdabot> forall a. [a -> [a]] -> [a -> [a]]
03:37:44 <Cale> You've created a monster! :)
03:38:11 <lispy> "we should have compile-time stub warnings
03:38:11 <lispy> which are as informative as possible about the task of instantiating the
03:38:11 <Cale> hehe, I like footnote 2 in the lisp interpreter article :)
03:38:12 <lispy> stub."
03:38:17 <lispy> didn't i propose that?
03:38:58 * lispy wonders if his emails in the pointless library proposal thread get to the mail list
03:39:02 <lispy> Cale: what does it say?
03:39:07 <lispy> i don't have it up anymore
03:39:24 <Cale> 2 There don't seem to be any definitive sources that suggest Haskell isn't good at something.
03:39:38 <SamB_XP> hej
03:39:46 <SamB_XP> er.
03:39:47 <ValarQ> hej SamB
03:39:48 <SamB_XP> heh.
03:40:05 <lispy> Cale: heh
03:40:12 <SamB_XP> that was a typo! I don't know what "hej" might mean
03:40:31 <ValarQ> SamB_XP: thats hello in swedish
03:40:38 <SamB_XP> ah
03:40:52 <SamB_XP> well, hello anyway ;-)
03:40:57 <Cale> I actually thought you were speaking Swedish as well :)
03:41:07 <ValarQ> i actually thought you were scandinavian there for a moment
03:41:13 <SamB_XP> I am but a poor, uneducated american!
03:41:19 <SamB_XP> I speak but one langauge, and I guess
03:41:26 <SamB_XP> I know a bit about spanish...
03:41:27 <lispy> it's true, SamB_XP could be my brother
03:41:42 <SamB_XP> well,
03:41:56 <SamB_XP> I mean, nevermind the fact that I'm in Calculus III...
03:42:09 <lispy> SamB_XP: you're in college?
03:42:11 <Bourbaki> what does calculus 3 cover?
03:42:16 <SamB_XP> yeah
03:42:22 <lispy> SamB_XP: i figured you for a graduated folk
03:42:37 <ValarQ> @what calculus 3
03:42:37 <lambdabot> I know nothing about calculus.
03:43:04 <Cale> Derivatives of functions R^n -> R^m ?
03:43:15 <SamB_XP> well, mine covers, among other things, sequences and series' and multi-variable functions
03:43:22 <lispy> calc3 was sequences and series at my school
03:43:34 <Bourbaki> uh? thats what we do in the first lecture
03:43:45 <Bourbaki> multi variative stuff is in the second
03:44:09 <lispy> series are a big topic in calculus! one lecture!?
03:44:13 <SamB_XP> heh
03:44:47 <Bourbaki> series and sequences are also done in analysis here
03:44:51 <SamB_XP> I think my class had at least one lecture every other section in the chapter!
03:44:56 <Bourbaki> no among other stuff of course
03:45:17 * lispy passes out
03:45:32 <Bourbaki> but i think you should start with topology anway cause this stuff is all so easy in topology
03:45:48 <SamB_XP> Bourbaki: here, "lecture" means the stuff the professor says in *one* class period
03:45:49 <Cale> Calc 1 was about 40% sequences, 40% differentiation and 20% or so integration. Calc 2 was mostly about series and uniform convergence, some more on integration. Calc 3 was the generalisation to R^n.
03:45:57 <SamB_XP> not a whole semester
03:46:25 <SamB_XP> Cale: they teach lame stuff here
03:46:28 <Cale> Oh, hehe, there was a good deal of stuff on continuity in there in Calc 1
03:46:50 <Bourbaki> what is calculus anyway? is it algebra and analysis mixed?
03:46:54 <Cale> and Calc 3 started off with a decent section on point-set topology
03:47:10 <SamB_XP> Bourbaki: I think it is probably "analysis"
03:47:14 <Cale> Bourbaki: basically those parts of analysis which deal with differentiation and integration
03:47:25 <SamB_XP> and in the US, a lot of algebra make-up
03:47:31 <Bourbaki> ah ok so why isnt it called analysis?
03:47:42 <Cale> It could be, it's just a little more specific
03:48:00 <Cale> So essentially derivatives, and Riemann integrals. Originally, how to calculate them.
03:48:11 <Cale> (Hence, Calculus)
03:48:16 <Bourbaki> aha ok
03:48:30 <SamB_XP> its not hard to calculate derivatives
03:48:39 <SamB_XP> but I'd love to know how to calculate integrals ;-)
03:49:06 <Bourbaki> heh who doesnt?
03:49:16 <Bourbaki> i think then you should bet into numerics rather ;)
03:49:29 <SamB_XP> and I have *no* idea why we had to wait so long to get to multi-variable functions...
03:50:12 <Bourbaki> its all quite simple and its even simpler if you know some topolgoy imho
03:50:59 <Syzygy-> And once you do know the topology, you've find the shinies and don't need to bother about the icky, differentiable stuff.
03:51:11 <SamB_XP> ooh! shinies!
03:51:18 * Syzygy- has passed through algebraic topology and ended up on the other side...
03:51:58 <ski> topologic algebra ?
03:53:23 <Syzygy-> ski: Something like that, but we call it "homological algebra", and occassionally "homotopical algebra" in order to stay away from the icky geometric topology.
03:54:05 <ski> heh
03:54:06 * Syzygy- is working on a PhD on group cohomology for finite p-groups....
03:54:24 <ski> does 'p' mean anything there ?
03:54:29 <Syzygy-> A prime.
03:54:41 <Syzygy-> So you'll have 2-groups, 3-groups, 5-groups, 7-groups, ...
03:54:53 <Baughn> 1-groups?
03:54:57 <Syzygy-> Baughn: Nope.
03:55:04 <ski> prime order ?
03:55:05 <Syzygy-> Baughn: 1 isn't prime. It's a unit.
03:55:11 <Syzygy-> ski: Prime power order.
03:55:18 <Syzygy-> So any group of order 256 is a 2-group.
03:55:25 <Syzygy-> (By Lagrange's theorem)
03:55:34 <ski> ok
03:58:06 <pejo> Syzygy, what brings you to #haskell?
04:04:03 <Syzygy-> pejo: sigfpe originally.
04:04:32 <Syzygy-> Actually, tune in to planet.haskell or blog.mikael.johanssons.org - I do a bit talking about why I started with haskell on my blog.
04:17:33 <Smokey`> WTF: where did everyone go?
04:17:41 <Smokey`> bah nvm :)
04:17:44 <Syzygy-> I still see 233 here...
04:17:59 <Cale> It was a netsplit
04:18:52 * SamB wonders what triggers that --partial problem...
04:20:42 <dons> yay, The Monad Reader is alive!!
04:20:55 <dons> swiert++
04:20:58 <dons> http://www.haskell.org/haskellwiki/TheMonadReader
04:21:00 <lambdabot> Title: TheMonadReader - HaskellWiki, http://tinyurl.com/yex6tu
04:21:23 <Syzygy-> It's ALIVE! MUHAHAHAHAHAHA! FOOOOOOLS! They never believed in it! Now they shall see The Monad Reader walk the earth!
04:21:33 * dons thinks of something to write about
04:21:59 <dons> deadline for articles is January 19th, 2007. so I wonder if we can get 5% of this channel to contribute...
04:22:06 <Bourbaki> hey dons
04:22:10 <dons> hey Bourbaki !
04:22:25 <Bourbaki> dons did you have a look at my stuff?
04:22:34 <dons> argh :/
04:22:41 <dons> you need me to?
04:22:56 <dons> is there any update you can send,?
04:23:00 <Bobstopper> Hmm... can type synonyms not be "partially applied" in type declarations or am I doing something wrong?
04:23:06 <Bourbaki> no :) but id like you to cause you said back then that youd be interested in writing such an interpreter
04:23:06 * dons feels bad about getting so side tracked
04:23:12 <dons> yeah.
04:23:18 <Bourbaki> if you dont have the time its ok
04:23:35 <Bourbaki> but i think youll be able to just quick read it
04:23:35 <dons> I think I need it to be presented in such a way that I don't have to think :}
04:23:42 <Bourbaki> i have put it on the wiki now
04:23:49 <dons> yeah. ok. so if i just review the mail you sent, then that's what you'd like?
04:24:04 <Bourbaki> basically yes
04:24:16 <dons> ok. i will do this in the morning.
04:24:24 <dons> ?todo read Bourbaki's mail!
04:24:24 <lambdabot> todo module failed: IRCRaised @todo has no args, try @todo-add or @list todo
04:24:25 <Bourbaki> thank you very much
04:24:29 <dons> ?todo-add read Bourbaki's mail!
04:24:29 <lambdabot> Entry added to the todo list
04:24:35 <dons> now i _have_ to do it
04:24:48 <Bourbaki> if you still should be interested we can do this over quite a while
04:25:02 <Bourbaki> atm i am writing another article for a book so i dont have a lot of time anyway
04:25:08 <dons> oh, a book. nice!
04:25:22 <Bourbaki> on shader stuff
04:25:29 <dons> cool
04:25:38 <dons> did everyone see http://programming.reddit.com/info/oj1w/details ?
04:25:41 <lambdabot> Title: Writing A Lisp Interpreter In Haskell - defmacro (reddit.com), http://tinyurl.com/sjuw3
04:25:45 <Bourbaki> just got my first article printed some weeks ago
04:25:47 <crashmatrix> my head hurts... (enter monads)
04:25:54 <dons> Bourbaki: cool! congrats!
04:25:58 <Bourbaki> thanks :)
04:26:04 <psnl> dons: aye
04:26:07 <dons> its such a great feeling getting that first paper out
04:26:29 <Bourbaki> its not a real paper but some small article in a quite often read book
04:26:39 <Bourbaki> shaderx if you know it
04:26:50 <Baughn> crashmatrix: I/O monads, or just monads in general?
04:26:52 <dons> and you get back reviews that are positive, so you can finally say "ok, i'm not crazy after all"
04:27:01 <dons> Bourbaki: I know a little.
04:27:08 <SamB> dons: that doesn't quite compute ;-)
04:27:15 <kfish> dons: you know you shouldn't believe all your reviewers
04:27:19 <dons> heh
04:27:19 <Philippa> mmm, I should definitely write *something*
04:27:22 <Bourbaki> :) but i want to get some real research stuff also which is why i want to do something with that graep stuff
04:27:25 <dons> Philippa: yes.
04:27:29 <dons> kfish: you too.
04:27:32 <crashmatrix> Baughn, only the IO monad yet
04:27:51 <dons> kfish: I wonder if we can extract a monad.reader article out of you by Jan?
04:27:52 <Bourbaki> and im into real time fluid solvers now for games
04:28:18 <Baughn> crashmatrix: You might experiment a bit with @undo, preferably combined with /msg
04:28:23 <dons> Bourbaki: cool. how does that work?
04:28:31 <kfish> dons: maybe, depends how cold winter gets here
04:28:44 <dons> heh. is colder better?
04:28:50 <Bourbaki> dons i am using a modified smoothed particle approach for that
04:28:54 <dons> == more likely to stay inside and write?
04:28:59 <kfish> right
04:29:15 <Bourbaki> it mixes particle systems with physical fluid solvers and collision prevention systems
04:29:22 <kfish> just like the paper i'm procrastinating on as we speak
04:29:29 <Bourbaki> its still in the paper phase cause im a bit lazy with the coding
04:30:06 <ski> crashmatrix : any particular thing you're wondering about the 'IO' monad, now ?
04:30:22 <Bourbaki> and its not using the point based difference method for the usual particle systems but something like dynamic FEM
04:30:56 * SamB thinks they ought to test darcs with semi-random command sequences in two repos, one of which is a --partial of the other, and try to darcs optimize --reorder the --partial one afterwards...
04:31:09 <Cale> crashmatrix: have you looked at my quick introduction to IO
04:31:10 <Cale> ?
04:31:14 <Bourbaki> so i can get the real partial derivatives instead of faking them
04:31:55 <dons> yay, coffeemug's tut made #1 on the programming page
04:31:56 <Cale> crashmatrix: This is rather short and hopefully should get the gist of it across: http://www.haskell.org/haskellwiki/Introduction_to_IO
04:31:59 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/ft8nk
04:32:00 <SamB> aren't particles *supposed* to collide sometimes?
04:32:36 <Bourbaki> SamB yes and no :) particles are point sized elements so its quite unlike :) but the collision is prevented through the navier stokes equation
04:32:53 <Bourbaki> so its like they have the same charge and push each other apart
04:33:07 <SamB> point-sized particles are invisible!
04:33:15 <crashmatrix> ski, no nothing specific
04:33:17 <Bourbaki> yep
04:33:19 <Banyo_lap> Hi all
04:33:21 <crashmatrix> Cale, thanks
04:33:23 <SamB> unless maybe you have a non-pinhole camera
04:33:31 <Bourbaki> what i render is the surface on the equipotential
04:33:46 <Bourbaki> that is the line around all the particles that have a certain energy
04:33:52 <SamB> ah.
04:33:57 <Bourbaki> like metaballs
04:34:02 <SamB> I see, you are trying to do splashing?
04:34:05 <Cale> hehe, by modding down the inside jokes article, I move it to #2, without that, it'd be #1 :)
04:34:15 <dons> heh
04:34:16 <Bourbaki> SamB whats splashing?
04:34:58 <SamB> what happens when you drop a rock in water?
04:34:59 <dons> Cale, these real world haskell tuts seem to rate _really_ well on reddit
04:35:09 <Cale> yeah
04:35:16 <Bourbaki> SamB ah yes something like that yes
04:35:25 <dons> i.e. the unix tools page made #1 on the _front_ page before haskell.org went down
04:35:47 <Bourbaki> im my application i want to get water into something like an rts though so you can dig dams and such
04:36:01 <Cale> heh
04:36:22 <Cale> That's funny. That was essentially a bunch of trivial one-liners wasn't it?
04:36:40 <Baughn> Cale: The second-to-last paragraph of that introduction (unsafe) might be a bit troublesome - too easily disprovable
04:36:56 <Cale> Baughn: hm?
04:37:02 <Baughn> @hoogle IO a -> a
04:37:03 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
04:37:03 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
04:37:03 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
04:37:20 <Cale> Baughn: Yeah, those should definitely be removed from hoogle ;)
04:37:47 <Baughn> Cale: Heh. I tend to think it should read "This is possible, but don't do it - we really mean it" instead. ;)
04:37:47 <ski> even the second and third ?
04:38:03 <emk> liftIO is fine...
04:38:20 <Cale> I mean the unsafe functions
04:38:50 <syntaxfree> I'm 'trying to construct a basic FP toolkit in a language that supports first-class functions, but not recursion.
04:39:08 <Cale> Baughn: I'd rather lie. unsafePerformIO is also too easy to access. It should involve setting a compiler switch :)
04:39:28 <syntaxfree> So I'm starting with a pseudo-fold, and trying to build onto that.
04:39:35 <Baughn> syntaxfree: No stack? Is recursion actually impossible, or do lexical variables keep overwriting each other?
04:39:49 <Cale> syntaxfree: is this dc? :)
04:39:56 <syntaxfree> I think lexical variables keep overwriting each other.
04:40:02 <syntaxfree> Cale: dc?
04:40:08 <Cale> I'm kidding
04:40:17 <syntaxfree> I didn't get the joke.
04:40:27 <Cale> dc is the unix desk calculator
04:40:32 <syntaxfree> Anyway, I'm trying to construct map from fold, to  no avail.
04:40:44 <Cale> it's an RPN calculator which is turing complete and has terrible terrible syntax
04:40:57 <earthy> powerful, thought.
04:41:07 <Cale> map f = foldr ((:) . f) []
04:41:10 <Baughn> syntaxfree: I might be thinking too lowlevel here, but what if you turn every local variable into a list and expand them every call?
04:41:53 <Baughn> syntaxfree: I didn't know such people still wrote such languages.. which one is it?
04:41:58 <dons> ?check \f xs -> map (f :: I -> I) (xs :: T) == foldr ((:) . f) [] xs
04:42:01 <lambdabot>  OK, passed 500 tests.
04:42:46 <syntaxfree> Baughn: I'd rather write basic recursion combinators like fold and unfold and build from there.
04:42:52 <gour> @where paste
04:42:52 <lambdabot> http://paste.lisp.org/new/haskell
04:42:55 <syntaxfree> of course, I could aso write map, etc. as loops.
04:42:56 <Cale> syntaxfree: can you roughly translate my map definition?
04:43:11 <lisppaste2> gour pasted "python eq. ?" at http://paste.lisp.org/display/29032
04:43:15 <syntaxfree> but, anyway, I did think of that, Cale.
04:43:41 <gour> hi, i'm arguing with some python guy about the http://www.defmacro.org/ramblings/lisp-in-haskell.html article
04:43:43 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/yyr8sf
04:43:58 <Cale> gour: there is no python equivalent of that, I don't think
04:44:02 <gour> is there some pythoner who can write the code from the paste in python
04:44:18 <syntaxfree> just a min. I'll paste.
04:44:21 <Baughn> gour: Python is dynamically typed. and
04:44:31 <gour> syntaxfree: ta
04:44:37 <Baughn> gour: , and such.. it might be possible to make a small interpreter, but not likely a similar one
04:44:39 <syntaxfree> there's PyPy, a Python interpreter written in Python.
04:44:44 <gour> Baughn: at least something similar
04:45:00 <gour> he posted http://paste.lisp.org/display/29031 crap
04:45:03 <dons> how does one declare sum types in python?
04:45:07 <syntaxfree> hmm. just a minute.
04:45:19 <Baughn> gour: The data statement is /all about/ typing. Python essentially doesn't have anything like it.
04:45:21 <Cale> Don't forget to define both constructors and destructors
04:45:47 <syntaxfree> how do you write foldr1 from foldr?
04:45:47 <syntaxfree> (my first map definition  worked from foldr1, but then I decided to generalize it to foldr so I could perform other tests)
04:46:23 <roconnor> @type foldr1
04:46:24 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
04:46:30 <Cale> syntaxfree: I don't think it can be done efficiently.
04:46:44 <syntaxfree> it needs a head . reverse, right?
04:46:52 <Cale> yeah
04:46:56 <gour> Cale: have you seen his paste?
04:47:08 <roconnor> @pl foldr1 f l = foldr f (head l) (tail l)
04:47:09 <lambdabot> foldr1 = (`ap` tail) . (. head) . foldr
04:47:35 <roconnor> @type (`ap` tail) . (. head) . foldr
04:47:35 <Cale> gour: that only defines constructors
04:47:36 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
04:47:49 <Cale> gour: er
04:47:56 <Cale> gour: Oh, I see
04:48:11 <gour> Cale: i'm teling him it's not complete, ie. what haskell does
04:48:16 <Cale> gour: um, what if it's not one of those things?
04:48:18 <roconnor> hmm, I guess that isn't right
04:48:31 <Cale> i.e. it's not str, list or func
04:49:21 <Cale> It'll return None
04:49:21 <kfish> dons: btw i found a new japanese haskell book today, http://www.amazon.co.jp/gp/product/4797336021
04:49:26 <Baughn> gour: It looks like a cross-cut - that is, it has (useful) functionality that the haskell statement doesn't have, but also vice versa
04:49:44 <Baughn> gour: Probably you should be comparing the full programs. Luckily it isn't a long one..
04:49:57 <dons> kfish: oh nice!
04:49:58 <lisppaste2> syntaxfree pasted "functional programming with no recursion" at http://paste.lisp.org/display/29033
04:50:00 <gour> Baughn: no, only data statement
04:50:10 <Cale> gour: actually, no, it's delegating on type
04:50:25 <syntaxfree> anyway, what I have is really random-access arrays, not lists.
04:50:25 <syntaxfree> Though I'm treating them as list for my pseudo-functional sublang.
04:50:28 <gour> Cale: ?
04:50:31 <Baughn> gour: It also includes the function dispatch part int he definition of __call__
04:50:43 <Cale> gour: where's the equivalent of the function BlaiseInt which the Haskell data declaration defines?
04:50:48 <Baughn> gour: Haskell's data /doesn't/ do that
04:50:49 <dons> kfish: can you give me enough of a translation that i can stick it on http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks ?
04:50:51 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y88o8f
04:50:53 <kfish> dons: it actually gets as far as having a chapter on monads, and then walks through a wiki implementation
04:50:57 <Cale> Or BlaiseSymbol, etc.
04:51:11 <dons> kfish: and why don't these .jp authors people CC. haskell.org? :(
04:51:18 <dons> cool.
04:51:22 <gour> Cale: i see it is missing a lot...
04:51:24 <dons> who's the author?
04:51:35 <kfish> dons: the title means "Normal Haskell" or so ... perhaps that means day-to-day, or Intermediate, not sure
04:51:55 <Cale> In the Python version there, you call the constructor with a parameter, and it just stores it, no matter what it is. It could be total junk.
04:52:12 <Cale> Also, how would this get translated into Python then?
04:52:17 <Baughn> kfish: I'm thinking "practical haskell" or "haskell for real-world problems"
04:52:21 <Cale> data Expr = A String | B String
04:52:40 <gour> Cale: everybody is welcome to join #sandbox
04:53:18 <kfish> Baughn, yeah, that sounds about right
04:53:36 * kfish invites Baughn to #haskell.jp
04:54:09 <dons> ?users #haskell.jp
04:54:09 <lambdabot> Maximum users seen in #haskell.jp: 3, currently: 3 (100.0%), active: 2 (66.7%)
04:54:24 <dons> good. we can get more though!
04:54:31 <gour> syntaxfree: join #sandbox
04:55:14 <Baughn> kfish: No way. That was a result of extreme amounts of anime, not because I can actually /read/ the language.
04:55:37 <kfish> Baughn, hehe
04:56:42 <dons> so what's the best translation of the title? i'm adding it to the wiki..
04:57:20 <kfish> yeah, probably "Practical Haskell Programming"
04:57:39 <dons> who's the author?
04:57:53 <Baughn> Rhymes nicely with "Practical Common Lisp". Anyone willing to translate the /book/? ;)
04:58:06 <kfish> the subtitle is "A primer on functional programming for [day-to-day
04:58:11 <kfish> ] programs"
04:58:14 <dons> ah good
05:00:55 <kfish> dons: I *think* Minuro Ooki, and Noshiotto Yamamoto
05:01:01 <kfish> but i'm not sure about the readings
05:01:10 <kfish> Noshiotto sounds particularly wrong
05:02:02 <kfish> as does Minuro, which should be Minero
05:02:25 <dons> ok, if you can fill in any more details here, please do: http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
05:02:27 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y88o8f
05:03:29 * dons notes that in the last 3 days we've found 2 haskell .jp textbooks, 1 in .es and 1 in .pt
05:03:33 <dons> how many more are out there?
05:03:58 <Baughn> There's at least one in .no - I'll look it up once I get rid of this flu
05:04:09 <dons> oh really? wow. yes please do.
05:04:20 <dons> its ludicours how authors don't publicise
05:04:20 <Bobstopper> I'll have to write one in lojban :P
05:04:32 <kfish> one thing i was thinking, you know how everyone writes a tutorial about monads in the course of writing about them?
05:04:40 <kfish> we should encourage people to write in their native language
05:04:40 <dons> yeah :)
05:04:47 <dons> oh, good idea.
05:04:54 <dons> at least translate it.
05:05:12 <dons> as #haskell.es has been doing for the entire haskell.org wiki
05:05:16 <kfish> because i noticed that these books that i've been seeing here are at a fairly introductory level
05:05:22 <dons> yeah
05:05:27 <kfish> which makes sense from a publishing point of view
05:05:34 <dons> the harder stuff is mostly only online
05:05:37 <kfish> right
05:05:44 <SamB> which is sad :-(
05:05:49 <kfish> and the harder stuff is what separates haskell from lesser languages
05:05:56 * Dylan attempted explaining the Reader monad to a java programmer last night.
05:06:13 <earthy> and, did you succeed? :)
05:06:25 <SamB> just tell him it is a way to avoid passing around an "environment" object
05:06:27 <dons> yeah, i'm intrigued Dylan ...
05:06:44 <Dylan> Well, the result was them going "it's magic"...
05:06:47 * Baughn once explained monads to a non-programmer. "And? What's so hard about that?"
05:06:53 <dons> :)
05:06:58 <dons> exactly!
05:06:59 * earthy grins
05:07:00 <SamB> hah
05:07:17 <SamB> yeah
05:07:36 <dons> ?remember Baughn [I] once explained monads to a non-programmer. "And? What's so hard about that?"
05:07:53 <Dylan> person a (non-programmer): Is magic good? / person b (perl programmer): Yes, of course / person c (java programmer): No, magic is bad. very bad!
05:08:07 <dons> heh
05:08:11 <SamB> it isn't magic, though, really
05:08:17 <dons> of course not.
05:08:19 <Dylan> ^ actual quotes.
05:08:29 <Philippa_> it's sufficiently advanced technology
05:08:33 <dons> but any technology suitably advanced looks like magic to java programmers
05:08:35 <Dylan> I tried to explain the Reader, but it didn't get accorss.
05:08:47 <SamB> its just the ability to say what you want to happen generally once, and then ignore it most of the time
05:08:50 <Dylan> hmm, my brain hasn't finished booting.
05:08:56 <earthy> any sufficiently advanced technology is indistinguishable from magic to those not initiated.
05:09:01 <Philippa_> Reader doesn't make much sense unless you've seen that specific usage pattern before
05:09:06 <dons> its the `blub' scenario
05:09:26 <Dylan> well, I explained the threading of state arguments through functions first
05:09:35 <Baughn> if you don't know that passing around fragments of imperative code makes no sense, it makes perfect sense
05:09:49 <SamB> it makes sense if you've been passing around something to every routine in a certain area of a program
05:10:02 <earthy> weird, how ghc's compilation generates .o, .thr_o, .thr_p_o, .thr_debug_o and .debug_o files.
05:10:07 <earthy> in the rts subdir
05:10:09 <SamB> Baughn: what does imperative code have to do with it?
05:10:22 <earthy> it does make sense, but it's still weird
05:10:32 <dons> just to help out the makefile rules
05:10:46 <Baughn> SamB: I was explaining monads in the context of the IO monad - attempting to teach programming to a non-programmer, in fact. Didn't quite work, in the end.
05:10:48 * earthy nods
05:10:59 <Binkley> whenever I try explaining monads to people I explain the IO monad
05:11:03 <Binkley> not sure whether that makes me a horrible person
05:11:17 <Dylan> I didn't really touch IO. Just Reader, Maybe and List
05:11:26 <dons> we could link libHSfoo.o ; rm *.o ; cc;  link libHSfoo.o_tr ; rm ; ...
05:11:29 <Baughn> Binkley: It does leave you open to the "But that's just a horrible workaround" argument
05:11:34 <Dylan> the last two the person actually was able to grasp
05:12:02 <Philippa_> SamB: the subcategory that is "code in the IO monad" is effectively (semantics for) an imperative language
05:12:21 <Binkley> Baughn: well, I usually start out by saying "this is how you do imperative programming in Haskell, but when you do it in Haskell, you get strong static type checking for free" :-)
05:12:27 <Dylan> I find people usually grasp Maybe (or the 'a option type in ML) pretty easily.
05:12:31 <Philippa_> State is probably easier than Reader for most people
05:12:38 <Binkley> cf. Simon PJ's "Haskell is the world's best imperative programming language"
05:12:43 <Dylan> and lists are natural. so monadic code that works on both is a good example.
05:13:02 <monstre> Question: why is "print 1 >> print $ 2" an error but not "do print 1; print $ 2"?
05:13:13 <monstre> The two should be equivalent according to the standard
05:13:19 <dons> ?type print 1 >> print $ 2
05:13:20 <lambdabot>   Expecting a function type, but found `m b'
05:13:21 <lambdabot>    Expected type: IO b
05:13:41 <Dylan> ?type (print 1) >> (print 2)
05:13:42 <lambdabot> IO ()
05:13:49 <ski> @type (print 1 >> print) 2
05:13:50 <lambdabot>   Expecting a function type, but found `m b'
05:13:50 <lambdabot>    Expected type: IO b
05:13:53 <dons> :)
05:14:01 <dons> ski++
05:14:15 <monstre> I understand why the first one is an error...
05:14:21 <dons> ?undo do print 1; print $ 2
05:14:21 <lambdabot> print 1 >> print $ 2
05:14:22 <ski> monstre : so '>>' binds harder than '$'
05:14:27 <dons> bad bot!
05:14:29 <ToRA> @type ((print 1) >> print) 2
05:14:30 <lambdabot>   Expecting a function type, but found `m b'
05:14:30 <lambdabot>    Expected type: IO b
05:14:31 <monstre> the point is, I think the translation given in the standard is wrong
05:15:02 <ski> monstre : in the second, ';' is a separator between expressions, so ';' binds weaker than '$', there
05:15:07 <dons> ?undo do print 1; (($) print 2)
05:15:07 <lambdabot> print 1 >> (($) print 2)
05:15:07 <Philippa_> ski: or as hard and with the right associativity
05:15:21 <dons> ?redo print 1 >> (($) print 2)
05:15:21 <lambdabot> do { print 1; (($) print 2)}
05:15:22 <Philippa_> monstre: which translation?
05:15:34 <dons> ?redo print 1 >> (print $ 2)
05:15:34 <lambdabot> do { print 1; (print $ 2)}
05:15:35 <Philippa_> (and odds are you're wrong and you just haven't realised it yet, 'mafraid)
05:15:58 <monstre> Philippa: the one given in language report for Haskell 98
05:16:28 <Philippa_> monstre: there are many translations in that report, try again?
05:16:34 <monstre> page 26
05:16:45 <Philippa_> for those of us who don't have a printed-out copy to hand?
05:17:09 <dons> do print 1; print $ 2 --> do (print 1) ; (($) print 2) --> (print 1) >> (($) print 2)
05:17:17 <dons> ?type do print 1; print $ 2
05:17:18 <lambdabot> IO ()
05:17:22 <dons> ?type (print 1) >> (($) print 2)
05:17:23 <lambdabot> IO ()
05:17:38 <Smokey`> Monads still confuse me, but only because I've avoided them intetnionally >_>
05:17:39 <ski> </window 2
05:17:49 <Smokey`> ugh, and my typings gone.
05:17:50 <ski> (sorry)
05:18:08 <swiert> dons: why not write something about your tutorial irc bot for TMR?
05:18:15 <Philippa_> Smokey`: you'll get the hang of them
05:18:25 <dons> swiert: I was planning on a concurrent web server of some kind?
05:18:31 <dons> so, yes, with bells on!
05:18:38 <Smokey`> Philippa_: I don't doubt it :)  I just haven't bothered to even read up on them :P
05:18:45 <monstre> according to this translation, "do {e1; e2}" means "e1 >> e2", so it would seem to me that "do print 1 >> print $ 2" becomes "print 1 >> print $ 2", i.e. an error
05:19:15 <swiert> Sounds great! I'll look forward to your submission :)
05:19:32 <ski> hm, i think that translation works on the abstract syntax level, not the concrete one
05:19:35 <Philippa_> monstre: right, but "do print 1; print $2" isn't the same
05:20:04 <Philippa_> swiert: I get the impression it's probably a good idea if Impure Thoughts goes elsewhere?
05:20:22 <monstre> sorry, I meant "do print 1; print $ 2", not "do print 1 >> print $ 2"
05:20:41 <Philippa_> yeah. Insert some parens when you do the translation
05:20:54 <swiert> Philippa_ : why? I'm open to any serious submissions....
05:21:08 <monstre> shouldn't those parens actually be in the standard?
05:21:29 <dons> monstre: i.e. "do {e1; e2}" means do { (e1); (e2) } ?
05:21:44 <dons> the compiler already knows this, so its not required.
05:21:54 <dons> sorry,
05:21:54 <Philippa_> swiert: yeah, but amongst other things the new process is going to make it a lot harder for me to get the serious bits done
05:22:04 <dons> do {e1; e2} -> (e1) >> (e2)
05:22:07 <Philippa_> and I figure you don't want to publish articles that're /just/ a barrage of bad puns
05:22:37 <monstre> dons: I think I get it now, thanks
05:22:40 <Binkley> philippa_: well, why do you assume that? ;-)
05:22:46 <Philippa_> monstre: concrete vs abstract syntax
05:23:14 <dons> yeah. its just left implicit, since the report deals in abstract syntax (using concrete syntax notation)
05:23:17 <Philippa_> Binkley: it might put off the academic crowd? :-) Point is, I generally try to have some content in there too
05:23:22 <Binkley> heh
05:23:24 <Binkley> content is overrated
05:24:15 <monstre> so I can use $ to replace parens in do blocks without worrying then?
05:24:16 <dons> Cale: the haskell tut is #2 on the front page...
05:24:34 <Philippa_> monstre: yep, in fact return $ foo is idiomatic
05:24:40 <swiert> Philippa_: it's up to you really. If you feel you have something you'd like to write about, I'd be happy to consider it. I don't think it would be wise to restrict TMR a priori in any way.
05:25:04 <monstre> alright then, thanks for the explanation
05:25:17 <Philippa_> yeah. My previously raised concerns apply too - for me at least, it's likely to result in more actual output if I go with a slightly different medium
05:25:34 <Philippa_> especially as I keep wanting to play with hypertext every time I realise I'm drawing in a small web of concepts at once
05:26:55 <dons> what does it say when a haskell tutorial can reach the #1 position on reddit?
05:27:11 <ndm> reddit is full of geeks?
05:27:16 <dons> is there a thirst for haskell knowledge? is something happening?
05:27:37 <Dreadshoot> geek theory sounds likely
05:27:38 <dons> is haskell the new ruby? :)
05:28:20 <dons> there's a lot of FP-friendly people there, that is true.
05:28:24 <psnl> dons: that #haskell can hack the system?
05:28:51 <dons> psnl: but we don't really? haskell tutorials were reaching the top spot without us even knowing about reddit.
05:28:59 * psnl suspects that its more that people want to code in haskell, but can't get their heads around it
05:29:05 <dons> yeah maybe.
05:29:17 <Smokey`> Philippa_: starting to doubt your confidence now... looking over http://www.haskell.org/tutorial/monads.html  -> yeah, I think i'm kinda in over my head, or i need a different point of view :P
05:29:18 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
05:29:30 <dons> there's a lot of lisp , scheme, python, ruby people on reddit.
05:29:43 <dons> who kind of know what haskell is about, and i guess want to to find out more
05:29:52 <Philippa_> Smokey`: Cutting a tiny amount of monadic code helps. Don't worry about building your own monads for now, that's a bit tedious in H98
05:30:04 <Philippa_> (but shockingly easy with GADTs if you're used to writing interpreters)
05:39:38 <dons> ?users
05:39:39 <lambdabot> Maximum users seen in #haskell: 256, currently: 244 (95.3%), active: 37 (15.2%)
05:40:42 <Dylan> 256. hehe
05:40:43 <pejo> A power of two!
05:41:05 <ski> The power of two is strong
05:41:42 <Bobstopper> lame coder joke: Why is Christmas spooky?
05:42:03 <Pete_I> Bobstopper, oct(31) == dec(25) :)
05:42:13 <Bobstopper> yeah :)
05:43:30 <Dylan> I wonder if there exists octal or hex clocks
05:43:50 <psnl> Dylan: I think I can make my desktop clock talk hex
05:43:55 <dons> if not, we should start making and selling them to geeks for xmas
05:44:15 <Dylan> dons: heck yeah! everyone loves the BCD clock.
05:44:15 <dblhelix> great idee! $$$
05:44:32 <pejo> Dylan, www.kleinfour.com has a link to a webshop, where htey sell a clock. (Not octal or hex though, but still mathy)
05:44:35 <Bobstopper> How about selling clocks displaying raw epoch time?
05:44:41 <Dylan> [even though BCD is wimpy]
05:45:06 <Dylan> pejo: bookmark'd
05:45:08 <dons> a nice minimalist hex clock would be really nice
05:45:12 <dons> blue leds perhaps
05:45:25 <dons> or one of those organic oleds my new watch has
05:45:42 <Dylan> you'd only need one symbol for the hour
05:46:00 <dons> well, it'd do 24 hour time too, i suppose :)
05:46:26 <dblhelix> of course :)
05:46:51 <Dylan> heh.
05:46:55 <dons> > printf "%x:%x" (23 :: Int) (59 :: Int) :: String
05:46:56 <lambdabot>  "17:3b"
05:47:03 <ski> a riven cipher clock would be nice
05:47:14 <dons> mmm 17:3b .. bed time!
05:47:43 <dblhelix> how long will it take for lambdabot to tell hex time?
05:47:46 <dons> i think it should have some kind of hex-based day mode as well
05:47:54 <Dylan> reminds me, I was calculaitng how many hours I worked, in HR's office... I do this because quicken doesn't run on linux, and it's the IT department's policy that the department doesn't use windows...
05:47:57 <dons> i.e. 16 "hexors" in a day
05:48:26 <dons> isn't there some existing proposal for a day divided into 16 segments?
05:48:55 <dons> Dylan: there' gtktimer for windows, if you really need to time our hours.
05:48:57 <Bobstopper> There's been a few for 28 hour days...
05:48:59 <dons> s/linux/
05:49:24 <Dylan> dons: no, I just need to enter the hours in quickbooks
05:49:42 <Dylan> anyway, I said "Hey, I worked from 8:00AM to 6:00PM that day. The absolute value of 8 - (6+12) would be the amount of time I worked."
05:50:26 * dblhelix wonders: are we being geeky?
05:50:33 <Dylan> and she said "That's nice. I don't know why you would think that, as it's just obvious looking at those two times you worked 10 hours..."
05:51:03 <dons> hmm, rapidly approaching top rating haskell story of all time, http://reddit.com/search?q=haskell&s=ups
05:51:05 <lambdabot> Title: search: haskell (reddit.com)
05:51:26 <dons> hmm. though the scheme one from a few days ago made it higher
05:51:59 <Dylan> okay, now to go do a week's worth of assignments in 1 hour.
05:52:16 <Dylan> ... wrong channel
05:53:19 <vegai> dons: reddit was originally written in lisp, and it seems that lispers tend to flock...
05:53:31 <dons> vegai: ah right. yes, i'd forgotten that
05:56:45 <Dylan> what's reddit written in now?
05:57:19 <earthy> python
05:59:13 <Bobstopper> http://redditblog.blogspot.com/2005/12/on-lisp.html
05:59:15 <lambdabot> http://tinyurl.com/yc7my5
05:59:27 <Bobstopper> ^^ Why they switched.
06:00:34 <dons> yeah, that's something haskell's a little vulnerable too also,
06:00:36 <dons> "If Lisp is so great, why did we stop using it? One of the biggest issues was the lack of widely used and tested libraries. Sure, there is a CL library for basically any task, but there is rarely more than one, and often the libraries are not widely used or well documented. Since we're building a site largely by standing on the shoulders of others, this made things a little tougher. There just aren't as many shoulders on which to stand."
06:00:47 <dons> we _need_ hackage and haskforge
06:01:04 <dons> cabal has helped a lot
06:01:11 <dons> but we can do even better
06:01:11 <earthy> and a community keeping stuff alive
06:01:16 <earthy> much of CPAN is dead wood as well
06:01:20 <dons> yeah
06:01:26 <integral> Is uploading a package to hackage just like using PAUSE/CPAN?
06:01:49 <dons> darcs also helps .. there's more cross-pollination now, making it easier to get help
06:02:10 <dons> integral: hackage is still alpha, i believe it in principle all works
06:02:26 <dons> but needs a task master to step up and make it happen
06:02:33 <kfish> dons: i need a personal hackage, i'm starting a new darcs project nearly every day atm
06:02:47 <Igloo> AIUI the hackage site is ready, but we don't have a good way to upload things to it currently
06:02:48 <dons> kfish: are you finishing one every day too?
06:02:55 <kfish> dons: haha, yeah right
06:03:14 <kfish> like that one i started last week called "thesis"
06:03:30 <dons> yeah. a hackage proposal to make it happen might have to itself happen by the end of the year
06:03:36 * integral would finish his Data.Memoise, but having somewhere to upload it would be nice
06:03:46 <dons> i'd not like to go into 2007 without the prospect of hackage being available
06:03:53 <dons> integral: well there's darcs.haskell.org
06:04:11 <dons> which you can ask SimonM for access to. also , files can be uploaded to the wiki
06:04:16 <dons> (and web pages hosted there of course)
06:04:23 <Igloo> Our community needs a week-long Hackathon
06:04:23 <integral> ugh.  horrible
06:04:36 <dons> Igloo: yes.
06:05:04 <earthy> organize one. :)
06:05:16 <Igloo> Are you going to that conference in Nice(?), dons?
06:05:21 <dons> the money would be the issue. there's PADL/POPL...
06:05:23 <dons> yes.
06:05:25 <dons> and rl too
06:05:29 <dons> dcoutts also I guess
06:05:32 <dons> and chak
06:05:47 <pejo> dons, for hackage - whoever who steps up can be pretty sure to have his research or spare time occupied with lots of stuff to do. Hard to find someone to volunteer for that. :-)
06:05:49 <dons> so we're the furthest away, and we'll be there.
06:05:59 <dons> pejo: right.
06:06:17 <dons> Igloo: so a POPL/PADL-based hackathon.
06:06:25 <dons> spj and simonm will be there too.
06:06:41 <dons> (there's the multicore declarative workshop)
06:07:02 <Igloo> dons: I was wondering about an Oxford one. It would save on accommodation costs, but have more travel costs
06:07:14 <dons> so we could just about have 1 every 6 months, Sept and Jan / ICFP and POPL?
06:07:59 <dons> Igloo: ah right. but once yu're spending 2k just to get there, another few hundred doesn't seem like much :)
06:08:03 <dons> so yeah, that'd work for me too
06:08:20 <Igloo> dons: But I'm spending 0 to not get there  :-)
06:08:26 <dons> heh
06:08:34 <kfish> what would hackage provide that normal distribution repositories wouldn't?
06:08:38 <Igloo> Blimey, first hotel price they give is 169 EUR  :-)
06:09:01 <dons> kfish, one haskell site to bind them all?
06:09:13 <dons> like cpan, like rubyforge
06:09:14 <integral> kfish: Isn't it more a directory of packages?  At the moment, people announce things to mailing lists, but there's no one place I can just wander over to and search for "linear algebra finite field" :)
06:09:29 <kfish> a directory i can understand
06:09:36 <dons> its also important to provide hosting for people without their own accounts
06:09:36 <kfish> ie. something like freshmeat, not like cpan
06:09:49 <kfish> yup, so something like sourceforge or berlios
06:09:53 <Dylan> what dons said is very important.
06:10:12 * integral only really wants directory + tarballs, and doesn't need any of the other bits
06:10:14 <Dylan> in ruby-land, you often find some library with a dead website
06:10:29 <Dylan> so, you can't download it.
06:10:42 <dons> yeah. that's key. the more material we can move onto haskell.org the better
06:10:47 <lesshaste> I was involved in a very boring "why haskell" argument today. When I said that Haskell had higher order types and functions the reply was that C had function pointers
06:10:48 <integral> plus once big archive is easier to get lots of mirrors for
06:10:51 <Dylan> in contrast to CPAN, where even if something is abandoned, I can still download it.
06:11:06 <dons> lesshaste: heh. but asm's got it all!
06:11:10 <Binkley> yeah, one time when I was trying to convince people that static typing was good, the response was, "but in C you can run lint!"
06:11:12 <Igloo> Oh, hmm, I'm busy the weekend after POPL
06:11:13 <lesshaste> is there a simple and quick explanation of why higher order functions are more powerful than C plus function pointers?
06:11:19 <integral> lesshaste: function pointers do not have data in them.   A proper closure has data *and* the code
06:11:22 <lesshaste> I failed to find anything convinving :)
06:11:23 <Binkley> a function pointer in C is not a first-class object
06:11:37 <Igloo> dons: It's PADL you're going to, right? Or are you going to both?
06:11:51 <lesshaste> integral, that sounds good.. can you give me an example?
06:11:52 <dons> i'd go to both. not worth travelling that far just for 1 day (is it one day?)
06:11:59 <lesshaste> Binkley, what is a first-class object?
06:11:59 <Binkley> well, maybe I mean that a function isn't a first-class object, rather
06:12:04 <dons> i'm likely to spend a couple of weeks
06:12:13 <integral> lesshaste: adder n = \x -> x + n
06:12:14 <dons> rl will be in europe too
06:12:15 <Igloo> 2, I think. And POPL 3.
06:12:22 <Binkley> lesshaste: an object that can be (1) named (2) passed to a function (3) returned from a function (4) stored in a data structure
06:12:35 <Binkley> I guess in C, function pointers have all 4 properties, but *functions* don't
06:12:47 <Binkley> there's no way to write an anonymous function in C
06:12:50 <dons> Igloo: so a Haskell infrastructure hackathon
06:12:52 <lesshaste> Binkley, ah right...
06:13:19 <Igloo> yeah
06:13:25 <dons> sounds good to me.
06:13:43 <dons> i think we can make this happen. you want to ping the relevant people for ideas?
06:13:44 <ndm> where are you proposing this hackathon?
06:13:57 <Igloo> Buying asymmetric flights isn't more expensive, right?
06:14:01 <Igloo> ndm: Oxford
06:14:06 <ndm> Igloo: cool :)
06:14:19 <ndm> kg.
06:14:23 <Binkley> igloo: depends where you're buying them from
06:14:26 <ndm> Igloo: sometimes it is, depends on which flights
06:14:27 <dons> Igloo: seems fairly easy. i'm sure it would affect numbers slightly, but then you'll also have more locals
06:14:43 <dons> anyway, the .au crowd would be flying via the uk anyway
06:14:58 <Igloo> Oh, that confuses me
06:15:22 <Igloo> dons: Affect numbers in which way?
06:15:43 <dons> oh, i meant, you get less attendees if its not in Nice, but then you get more if its in Oxford due to cost savings
06:15:55 <lesshaste> Binkley, so won't function pointers do the 4 things you need? I mean, how does it make a difference that you use function pointers and functions?
06:16:06 * Igloo thinks quality is more important than quantity anyway  :-)
06:16:10 <dons> yeah
06:16:26 <ndm> an infrastructure hackathon sounds a much better idea than a GHC one though
06:16:36 <dons> yep
06:16:40 <Igloo> I haven't looked up train prices, but I suspect it only has to be 2 or 3 days long for Oxford to be cheaper, even if you're going back to Nice to fly
06:16:50 <ski> lesshaste : i think the point is more whether one can have (first-class) functions which refer to outer local variables
06:17:04 <Igloo> ndm: The GHC one was more focused on talks about how to do it, where as this would just be getting on with it
06:17:13 <lesshaste> ski, ok.. can you explain that a little more with a haskell example?
06:17:34 <lesshaste> integral, " adder n = \x -> x + n"  <-- is that proper Haskell?
06:17:43 <dons> Igloo: yeah, so like an openbsd hackathon. a wifi server, laptops, room and code for a few days
06:17:47 <Igloo> lesshaste: Yes
06:18:00 <dons> ?let adder n = \x -> x + n
06:18:02 <lambdabot> Defined.
06:18:05 <lesshaste> Igloo, thanks
06:18:05 <dons> > L.adder 1 2
06:18:06 <lambdabot>  3
06:18:16 <Igloo> dons: I'm not sure what we'll be able to provide, I'll talk to Duncan about it
06:18:26 <ski> timesAll n xs = map times_n xs where times_n x = n * x
06:18:30 <ski>   where
06:18:31 <lesshaste> I don't know what an other local variable is
06:18:32 <ski>   times_n x = n * x
06:18:46 <Igloo> This probably all falls apart if he has other plans  :-)
06:18:48 <dons> for the openbsd ones, they book out a hotel and have a conference room setup with all the machines they need to hack on
06:18:55 <dons> our requirements would be less
06:19:03 <ski> lesshaste : 'times_n' is a function that is defined locally inside 'timesAll'
06:19:04 <dons> ok.
06:19:18 <ndm> cheaper would be better :)
06:19:28 <lesshaste> ski, ok.. so this is an example of something much more awkward to do in C?
06:20:16 <Igloo> Oh bother, I might be busy the weekend before as well
06:20:26 <ski> lesshaste : 'n' is an argument to 'timesAll' so it is a local variable of 'timesAll' .. but 'times_n' is using it even though it is defined outside 'times_n' (but 'n' is still not a global/top-level variable, since it's local to 'timesAll')
06:20:41 * dons wonders about Igloo's packed social calendar
06:20:51 <dons> for a compiler guy that is ... :)
06:21:10 <Igloo> dons: I am only busy 4 weekends of the year, I think
06:21:31 <Igloo> Unfortunately, all around that time!
06:21:40 <lesshaste> ski, this is quite subtle.. is it a very important feature of haskell?
06:21:40 * Igloo will have to work out exactly when things are
06:21:43 <ski> lesshaste : yes .. in this case, one could do the same thing with local functions in gcc .. but generally it is not safe to return such from the "outer" function, in gcc, but that is quite common in haskell ()
06:21:53 <dons> yeah, Jan is busy. but if we can organise even say 2 days, that would be worth it
06:22:02 <ski> s/()/(and other functional languages)/
06:22:56 <cjeris> lame T-shirt slogan: "#haskell: puts the # in reallyUnsafePointerEq#"
06:23:01 <lesshaste> ski, and does this relate directly to things being first-class objects?
06:23:10 <Binkley> cjeris: lol
06:23:10 <ski> lesshaste : in many (most?) cases when you use higher-order functions in haskell, you provide local functions like 'times_n' above
06:23:51 <dons> I like "Distribute your cognition" (front) and "#haskell @ freenode" (back)
06:23:58 <ski> lesshaste : partly because having functions being first-class will allow us passing around the functions to the right place
06:24:16 <cjeris> "#haskell: because the truth NEVER CHANGES."
06:24:21 <dons> heh
06:24:31 <dons> yeah "Truth is Immutable" or something
06:25:59 <ski> (lesshaste : e.g. if you couldn't pass functions as arguments, how could you pass 'times_n' to 'map' above ?)
06:27:21 <lesshaste> ski, good point...
06:27:34 <Binkley> I like "Truth is Immutable"
06:28:24 <lesshaste> ski, there should be a haskell propoganda faq for these things :)
06:28:37 <lesshaste> ski, 10 things that are much easier to do in Haskell and why
06:29:03 <Binkley> isn't that what "the evolution of a haskell programmer" is? :-)
06:29:18 <dino-> Does this sound right? Being able to call a function through a pointer isn't the same as being able to use the function interchangeably with the thing it evaluates to.
06:30:01 <ski> i don't see why anyone would confuse those two things
06:30:07 <ski> lesshaste : easier to do in Haskell instead of which language(s) ?
06:30:42 <Binkley> dino-: the more important thing is that if you have to call a higher-order function through a pointer, that implies you have to name it
06:31:06 <dino-> I said that because it seems like a common opinion that pointers to functions (like in C) can do all the magic you need.
06:31:08 <ibid> dino-: yes, that is trivially true, and not a very interesting thing to say
06:31:14 <ski> Binkley : why ?
06:31:48 <Binkley> well, anonymous functions are used pretty frequently in Haskell. I think that suggests that they're useful :-)
06:31:58 <ibid> dino-: the issue whether a function call is interchangeable with its value depends on whether the function has side effects or not; it has nothing to do with function pointers or the lack of same
06:32:17 <dino-> ok
06:32:26 <ski> Binkley : for pragmatics (readability, etc), yes
06:32:33 <lesshaste> ski, C
06:32:42 <Binkley> well, on some level this is all about readability
06:32:43 <lesshaste> Binkley, brilliant...!
06:32:48 <Binkley> if we didn't care about readability, we'd be programming in asm
06:32:50 <lesshaste> how about "You can't create  a function at run-time in C
06:32:58 <lesshaste> that seems to summarise it  nicely :)
06:33:05 <lesshaste> s/C
06:33:08 <ibid> lesshaste: very few languages allow you to do that
06:33:16 <lesshaste> ibid, you can in haskell basically
06:33:16 <ibid> lesshaste: haskell doesn't
06:33:24 <ibid> lesshaste: haskell has no eval
06:33:30 <lesshaste> ibid, no but adder 3
06:33:34 <lesshaste> creates a function
06:33:52 <Binkley> I see what you're getting at, but it's not *really* "creating a function"
06:33:54 <ibid> lesshaste: not really
06:33:56 <Baughn> lesshaste: No, it partially evaluates a function - the code to do so already exists in adder
06:34:09 <dons> > \x -> (x :: Int) -- creates a function at runtime :)
06:34:11 <lambdabot>  <Int -> Int>
06:34:14 <Binkley> what you mean is that you can return a function in a lexically scoped manner
06:34:18 <dons> (via eval)
06:34:18 <lesshaste> right.. but in terms a C programmer would understasnd it creates one
06:34:30 <ibid> lesshaste: the function adder 3 "creates" already exists somewhere in the source code
06:34:34 <lesshaste> you can't partially evaluate a function at run time :)
06:34:48 <Baughn> dons: eval? Where eval?
06:34:49 <ibid> sure you can
06:34:53 <lesshaste> ibid, in C?
06:34:55 <ibid> that's what adder does
06:35:03 <Binkley> what makes one instance of (adder 3) different from another? the lexically enclosing environment
06:35:05 <ibid> lesshaste: you didn't spcify C :)
06:35:10 <dons> ?type System.Eval.Haskell.eval
06:35:11 <lambdabot> forall a. (AltData.Typeable.Typeable a) => String -> [System.Eval.Utils.Import] -> IO (Maybe a)
06:35:14 <lesshaste> ibid, I am looking for a one-liner
06:35:19 <Binkley> when you say it creates a function, you really mean it makes a copy of the function (conceptually) with a different environment
06:35:22 <ibid> lesshaste: there isn't one
06:35:26 <ski> ibid : aren't you thinking of partial *application* ?
06:35:28 <Baughn> Binkley: Only if adder /uses/ anything in the lexical environment - otherwise there is no difference
06:35:33 <Binkley> baughn: sure.
06:35:33 <ibid> lesshaste: except "C has no nested functions"
06:35:38 <lesshaste> ibid, "you can't partially evaluate a function in C" :)
06:35:49 <ibid> ski: ... which is a form of partial evaluation
06:35:49 <lesshaste> ibid, that's nice too.
06:36:02 <ski> ibid : only in a trivial way
06:36:04 <Binkley> if adder has arity 2, then (adder 3) will use at least one thing in the environment -- the first argument
06:36:05 <Baughn> lesshaste: Actually, sure you can - you just need to write the functions correctly
06:36:12 <lesshaste> Baughn, in C?
06:36:18 <Baughn> lesshaste: Int -> Int -> Int instead of (Int, Int) -> Int
06:36:24 <ibid> lesshaste: whether you can partially evaluate a function in C depends on whether your compiler does partial evaluation or not
06:36:34 <lesshaste> ibid, does gcc?
06:36:40 <ibid> lesshaste: i don't think so
06:36:54 <Baughn> lesshaste: ..of course, that gets horribly annoying without closures, but hopefully you see my point
06:36:58 <ski> CMix does
06:37:02 <lesshaste> Baughn, yep
06:37:15 <lesshaste> how about "C doesn't have closures"
06:37:20 <lesshaste> there must be some line I can use
06:37:24 <Baughn> lesshaste: "GCC does". ;)
06:37:24 <ibid> C programmers doesn't understand that
06:37:29 <lesshaste> Baughn, damned :)
06:37:38 <ski> Baughn : no indefinite-extent ones
06:37:41 <ski> s/no/not/
06:37:47 <ibid> they understand "C does not support nested functions"; which is a big part of why C isn't as expressive
06:37:54 <ibid> (not the whole of it, certainly)
06:37:55 <lesshaste> I've sent the evolution of a haskell programmer instead :)
06:38:26 <lesshaste> ibid, can you give an example of  nested function in Haskell?
06:38:57 <ski> lesshaste : i gave 'timesAll' above
06:39:03 <lesshaste> ski, ah... got you.. thanks
06:39:08 <ibid> lesshaste: your adder can be written with one
06:39:12 <Baughn> > let a = 1 in let foo x = a + x in foo 4
06:39:13 <lambdabot>  5
06:39:28 <ibid> lesshaste: adder n = let f m = n + m in f
06:39:36 <dons> > let f = \x -> \y -> \z -> x + y + z ; g = f 2 ; h = g 3 in h 4
06:39:37 <lambdabot>  9
06:39:41 <ibid> lesshaste: of course, that's not very idiomatic :)
06:40:04 <lesshaste> yes.. I can't parse  "adder n = let f m = n + m in f" at all!
06:40:15 <Baughn> lesshaste: Looks better on multiple lines
06:40:18 <ibid> lesshaste: then you don't know haskell very well=
06:40:25 <lesshaste> ibid, of course...
06:40:25 <dons> ?pretty adder n = let f m = n + m in f
06:40:25 <lambdabot>  adder n = let f m = n + m in f
06:40:28 <dons> heh
06:40:44 <dons> adder n = f where f m = n + m -- perhaps is easier?
06:40:51 <lesshaste> dons, much.. thx
06:41:21 * lesshaste learned miranda years ago and is still pretending that that will do for haskell
06:41:31 <dons> lesshaste: there's some good tutorials that will lead you through this kind of thing
06:41:31 <ibid> lesshaste: btw, if they say "GCC allows nested functions as an extension", point out that you cannot return in general such a function from the enclosing function
06:41:34 <dons> ?where yaht
06:41:35 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
06:41:48 <lesshaste> ibid, I may have to invite you round to do this :)
06:42:00 <ibid> lesshaste: sure, but now i have to go, bbl :)
06:42:04 <lesshaste> bye
06:42:07 <Baughn> lesshaste: The idiomatic syntax would be 'adder n m = n + m', but that gets a bit redundant. ;)
06:42:19 <lesshaste> Baughn, :)
06:42:33 <dons> adder = (+) -- is better
06:43:00 <Baughn> At that point, you'll have people clamoring to just use +
06:43:16 <dons> which kind of reveals the essence of the code, and then yes, you just use +
06:43:30 <dons> let's see...
06:43:36 <dons> ?pl let f m = n + m in f
06:43:37 <lambdabot> (n +)
06:43:44 <dons> ?pl adder n = let f m = n + m in f
06:43:44 <lambdabot> adder = (+)
06:43:48 <dons> nice!
06:43:54 <Dylan> good lambdabot
06:44:08 <Baughn> lambdabot++
06:44:26 <dons> the referentially transparent refactoring super-bot strikes again!
06:45:10 <dons> ?users
06:45:10 <lambdabot> Maximum users seen in #haskell: 256, currently: 250 (97.7%), active: 42 (16.8%)
06:45:15 <dons> ooh close.
06:45:37 <osfameron> send out the press gang!
06:45:43 <dons> i've got a feeling in my waters, as kath would say
06:46:26 <Baughn> I wonder if that number is a bignum?
06:47:05 <dons> in fact, type MaxMap    = M.Map String Int -- so maybe i'm being presumptuous :)
06:47:19 <dons> > maxBound :: Int
06:47:20 <lambdabot>  2147483647
06:47:22 <dons> too low?
06:47:38 <Baughn> Too low. We must leave room for further channel expansion.
06:47:49 <cjeris> ghc doesn't use a bit for tagging like SML/ocaml?
06:47:52 <dons> 2^8 this year, yeah, well, when we get to 2^31 i'l quickly change the type sig
06:48:08 <Baughn> We're already a fourth of the way there..
06:48:12 <dons> cjeris: nope. but the haskell spec leaves that open for others to use
06:48:14 <Binkley> heh
06:48:38 <dons> it's a Spineless _Tagless_ G-machine, after all :)
06:48:57 <dons> nhc98 tags, iirc
06:49:00 <cjeris> invertebrate anonymous pimpmobile ??
06:49:05 <dons> ndm, that's right, isn't it?
06:49:19 <ndm> dons: yes, it does
06:49:37 <ndm> dons: and Yhc -O uses even more tags
06:49:39 <dons> but yhc is tag free and easy?
06:49:43 <dons> oh?
06:49:51 <dons> ah, packing?
06:49:59 <ndm> dons: Yhc uses tags as well, Yhc -O will use more tags than any other machine before it :)
06:50:06 <dons> heh
06:50:09 <ndm> packing?
06:50:25 <dons> oh, just trying to imagine magic tagging games to pack data into Ptrs
06:50:32 <ndm> yep :)
06:50:54 <ndm> Yhc -O has loads of tags, many more than even the original tagful G machine
06:51:05 <ndm> but can do scary tricks like lazy unboxing :)
06:51:16 <dons> huh. this is written up somwhere?
06:52:31 <Binkley> lazy unboxing?
06:52:49 <ndm> alas no
06:52:52 <ndm> yes, lazy unboxing
06:53:03 <Binkley> is *that* written up somewhere? :-)
06:53:11 <ndm> in GHC an int can either be strict and unboxed, or lazy and boxed
06:53:15 <Binkley> right
06:53:26 <ndm> in Yhc -O it can be both lazy _and_ unboxed once its evaluated
06:53:48 <Igloo> once it's evaluated, what does it mean to be lazy?
06:53:56 <Binkley> so something can get passed into a function as a boxed int, and then it becomes unboxed?
06:54:09 <ndm> it would never be passed as a boxed int
06:54:10 <Igloo> Oh, lazy and {unboxed once its evaluated}?
06:54:16 <ndm> yes
06:54:24 <ndm> there are no boxed int's in the machine
06:54:31 <Binkley> ok, well, a boxed whatever-you-want
06:54:34 <ndm> or boxed bools, chars, [], Nothing or anything else
06:54:56 <Binkley> you're saying that evaluation can changed the boxedness of a value?
06:54:59 <ndm> things like (:), Just etc still have to be put in boxed
06:54:59 <Igloo> ndm: So you have 31-bits for the actual Int, and lots of bit testing?
06:55:13 <ndm> Igloo: 30, but basically yes
06:55:27 <Igloo> ndm: And if the (low, presumably) bit is set then it's a pointer to a closure or something?
06:55:38 <ndm> Igloo: indeed
06:55:41 <Binkley> Ah, ok
06:55:44 <Binkley> like in ML
06:56:22 <ndm> quite possibly - haven't read up on teh ML impelementation stuff - only the Haskell stuff so far
06:56:37 <ski> (ndm : istr mercury doing something similar (but that's not lazy of course))
06:56:49 <ndm> ski: cheers, i'll take a look
06:57:13 <gour> ndm: Cale is wrestling two hours in #sandbox with that python guy over today's article about lisp interpreter in haskell
06:57:34 <ndm> gour: not again :)
06:57:44 <gour> ndm: :-)
06:58:01 <ndm> Igloo: has GHC ever thought of tricks like that, packing Int's into pointers?
06:58:41 <Igloo> ndm: No idea. It's not clear it's a performance win, though
06:59:06 <Binkley> I'm pretty sure GHC doesn't do anything like that
06:59:15 <ndm> Igloo: i don't have performance numbers to back this up yet, but i have some other design choices at the same time, which guarantee its a space win
06:59:51 <ndm> and in the absence of program level unboxed Int's, I'm pretty sure its a performance win
06:59:55 <Igloo> Sure, it's trivially a space win
07:00:18 <Igloo> Well, unless you need the full integer range
07:00:40 <ndm> its a space win for things like Bool as well
07:00:47 <ndm> and Char
07:01:02 <ndm> which is where i suspect the big space savings will happen
07:01:04 <Igloo> Yeah, there was talk on one of the lists about GHC handling Bool differently
07:01:32 <ndm> yes, i saw that - well mine handles all 0 arity constructors that way, so is more general
07:01:40 <ndm> i.e. [] is handled that way
07:06:59 <ski> (ndm : hm, i see a pic i was thinking of in "Unification in Mercury" at http://www.cs.mu.oz.au/research/mercury/information/papers.html#unif .. there's probably a paper which has more explanations, though)
07:07:01 <lambdabot> Title: The Mercury Project: Papers and Presentations, http://tinyurl.com/y3cwww
07:16:05 <dcoutts> dons, Igloo, what's all this ?
07:16:05 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:17:05 <Igloo> dcoutts: We're wondering about having a Haskell Hackathon in Oxford, one side or other of POPL/PADL
07:17:05 <dcoutts> lispy, SamB_XP, a new Gtk2Hs release is indeed in the works.
07:17:16 <dcoutts> Igloo, sounds good to me.
07:17:17 <Igloo> dcoutts: Are you interested? Free?
07:17:34 <dcoutts> I'm free before PADL, after is the beginning of term.
07:17:49 <Igloo> Right, before is more likely to work for me too
07:18:56 <glguy> Does anyone know why the 2005 version of visual haskell is hidden away in the darcs directory?
07:19:22 <profmakx> so
07:32:54 <ski> (hm "Unclean! Unclean! or Purity Issues in Declarative Constraint Logic Programming." almost sounds like a Wadler paper)
07:55:01 <dons> ?users
07:55:01 <lambdabot> Maximum users seen in #haskell: 256, currently: 240 (93.8%), active: 41 (17.1%)
07:55:07 <dons> ah well, not tonight then.
07:55:15 <dons> night all!
08:02:57 <Pete_I> 17.1% isn't much
08:14:28 <haskellfreak> how can i convert "+" in haskell to (+)    ((function))????
08:14:38 <haskellfreak> how can i convert "+" in haskell to (+)    ((function))????
08:14:40 <haskellfreak> how can i convert "+" in haskell to (+)    ((function))????
08:15:31 <ski> just write '(+)' where you want to put the function
08:15:54 <ski> hrm .. or maybe you wanted to convert a string to the plus function ?
08:15:57 <haskellfreak> i have ""+"" as a string
08:16:03 <haskellfreak> yes
08:16:07 <ski> could you provide more context ?
08:16:56 <ski> i assume you get a string from somewhere, and want to check, if it is '"+"', then you want to do something with the '(+)' function
08:17:03 <ski> is that right ?
08:17:14 <haskellfreak> yes
08:17:46 <Baughn> So, something like 'eval "+" = (+)'
08:18:11 <haskellfreak> yes
08:18:16 <haskellfreak> u imperial?
08:18:53 <Baughn> I'm socialist, not a filthy pig-dog imperialist free-marketer
08:19:01 * Baughn snickers
08:19:09 <haskellfreak> imperial college....
08:19:30 <haskellfreak> anw
08:19:35 <Baughn> Considering that there are probably several tens of thousands colleges around... what would make you think so?
08:19:36 <haskellfreak> how i do that?
08:19:49 <haskellfreak> cause we're doing eval now
08:20:00 <Baughn> haskellfreak: I just gave you the exact syntax
08:20:11 <Baughn> > eval "x" where eval "x" = (+)
08:20:11 <lambdabot>  Parse error
08:20:30 <Baughn> > let eval "+" = (+) in (eval "+") 2 3
08:20:31 <lambdabot>  5
08:20:32 <ski> 'where' doesn't work anymore in '> ' :/
08:21:07 <int-e> > let res = eval "x" where eval "x" = (+) in res -- you can always do this yourself
08:21:07 <lambdabot>  Add a type signature
08:21:09 <Igloo> ski: Did it ever?
08:21:25 <int-e> yes.
08:21:26 <ski> Igloo : yes
08:22:05 <haskellfreak> asl?
08:22:25 <Baughn> ..you really /want/ us to ignore you, don't you?
08:22:43 <haskellfreak> have i told that i am a girl
08:22:45 <int-e> back when   1 : scanl (+) 1 xxx   produced a list of fibonacci numbers (not sure what 'xxx' was exactly)
08:22:46 <haskellfreak> im french
08:22:54 --- mode: ChanServ set +o dons
08:22:58 --- kick: haskellfreak was kicked by dons (dons)
08:23:00 --- mode: ChanServ set -o dons
08:23:20 * Igloo was just considering that  :-)
08:23:23 <musasabi> justice :-)
08:23:28 <dons> he can always come back if he wants to be serious
08:24:33 * dons goes back to sleep
08:27:32 <int-e> be wary of dons, he kicks people in his sleep.
08:27:45 <chessguy> 'mornin
08:28:38 <Philippa_> besides, everyone knows that the way to get the chan licking your feet's to be bi poly switch - being french doesn't cut it :-)
08:29:02 * earthy snickers
08:29:59 <earthy> so, would that switch be an action in the category of sexuality, then? and what would the category look like? :P
08:30:23 <roconnor> I wonder, for my library trac, should I amend-record my patch or bundle multiple patches together to make modifications?
08:30:48 * int-e shoots roconnor with an arrow and pretends it was one of Cupid's.
08:30:59 <int-e> bad aim
08:31:03 <int-e> that was for earthy.
08:31:21 <Baughn> Let th
08:31:26 * roconnor <3 int-e
08:31:39 <Baughn> Let that be a lesson not to use tab-completion in love
08:31:47 <Philippa_> earthy: were you the mystery commenter on my LJ by any chance?
08:31:54 <int-e> actually I copied the nick from the wrong line.
08:33:47 <chessguy> > delete 3 [3,3,3]
08:33:49 <lambdabot>  [3,3]
08:34:03 <earthy> philippa: probably not. :P
08:34:08 <chessguy> > delete 3 [3,1,2,3]
08:34:09 <lambdabot>  [1,2,3]
08:34:28 <Baughn> > delete 3 [1,2,3]
08:34:29 <lambdabot>  [1,2]
08:35:03 <earthy> back to scrapping my boilerplate while walking over HsModule
08:37:14 <ski> evening, esap
08:37:27 <esap> evening ski!
08:37:38 <esap> what's up?
08:38:17 * ski is pondering a (possible) feature of logic programming
08:38:29 <esap> which feature?
08:38:50 <ski> it doesn't exist yet .. i'm trying to invent it :)
08:39:07 <ski> or rather, design it and it's implementation
08:39:13 <ski> s/it's/its/
08:39:13 * chessguy raises an eyebrow
08:39:21 <chessguy> a spellchecker? :)
08:39:28 <ski> hehe, no
08:39:44 <esap> inventing features for languages is hard.
08:39:53 <ski> briefly : negations that may export instantiations
08:40:06 * chessguy falls asleep instantly
08:40:13 <ski> (:
08:40:20 <ski> (chessguy : why ?)
08:40:33 <esap> export instantiations? how does that relate to logic programming?
08:40:39 <chessguy> because i'm too clueless to haveany idea what you're talking about
08:40:40 <chessguy> :)
08:41:02 <Philippa_> I'm thinking that first class modules make for a great opportunity to write your makefiles in the language in question...
08:41:27 <ski> esap : with the current negation-as-failure implementation of negation in prolog, a negation may only answer yes or no, it may not produce any output
08:41:52 <esap> ski: you mean you want a negation that will log the failure in a log file? :-)
08:41:55 <ski> (esap : i assume you know some prolog ?)
08:42:00 <ski> nono
08:42:10 <chessguy> @hoogle count
08:42:11 <lambdabot> Text.ParserCombinators.ReadP.count :: Int -> ReadP a -> ReadP [a]
08:42:11 <lambdabot> Text.ParserCombinators.Parsec.Combinator.count :: Int -> GenParser tok st a -> GenParser tok st [a]
08:42:11 <lambdabot> Test.HUnit.Base.counts :: State -> Counts
08:42:36 <Philippa_> ski: reasons for failure, stuff like that?
08:42:51 <ski> Philippa_ : that could possibly be one use, yes
08:42:55 <ski> (i think)
08:42:57 <esap> ski: I've thought a long time about various kinds of negations, including the negation-as-failure, negation-as-exception, negation-as-lack-of-resources etc.
08:42:59 <ski> esap : if you want, i could state a small example i'm using to think about it
08:43:15 <esap> ski: sure
08:43:35 <Igloo> CosmicRay: Where are we with hdbc-sqlite3 and hsffig?
08:43:35 <ski> (though should i take it here or #haskell-overflow or #prolog ?)
08:43:57 * CosmicRay blinks
08:43:57 <lambdabot> CosmicRay: You have 1 new message. '/msg lambdabot @messages' to read it.
08:44:03 <Philippa_> I'd vote overflow rather than prolog
08:44:09 <Philippa_> but gimme a mo to /join?
08:44:16 <ski> Philippa_ : the use case i have in mind currently is implication (defined through negation and conjunction)
08:44:18 * esap just joined overflow.
08:44:34 <CosmicRay> Igloo: I must admit I forgot about those.
08:44:50 <ski> Philippa_ : sure
08:45:04 * CosmicRay checks
08:45:31 <CosmicRay> I think hdbc-sqlite3 is a simple build-dep problem
08:45:39 <Igloo> Oh, the hdbc-sqlite3 problem doesn't even look ghc-related
08:45:56 <chessguy> > 3 \= 3
08:45:57 <lambdabot>  Not in scope: `\='
08:46:01 <chessguy> > 3 /= 3
08:46:02 <lambdabot>  False
08:46:10 <CosmicRay> hsffig was waiting for HXT
08:46:24 <chessguy> > filter (/= 3) [1,2,3]
08:46:25 <lambdabot>  [1,2]
08:46:57 <Igloo> CosmicRay: Is that haskell-src-exts?
08:47:20 <chessguy> @pl length $ filter (== x) xs
08:47:21 <lambdabot> length (filter (x ==) xs)
08:47:35 <chessguy> heh
08:47:35 <CosmicRay> Igloo: no, the Haskell Xml Toolkit
08:47:56 <chessguy> > let count x xs = length $ filter (== x) xs in count 3 [1,2,3]
08:47:58 <lambdabot>  1
08:48:20 <Igloo> CosmicRay: What's the package name?
08:48:34 <CosmicRay> Igloo: it wasn't in Debian, arjan oosting was going to package it.
08:48:43 <Igloo> Ah
08:49:01 <Igloo> CosmicRay: Is that a new dep of a newer 6.6-ready version?
08:49:51 <chessguy> > let count x xs = length $ filter (== x) xs in count 3 [1,2,4]
08:49:53 <lambdabot>  0
08:49:57 <Igloo> I think we're only waiting on pugs, hs-plugins, hsffig now
08:50:51 <chessguy> > 2 `div` 3
08:50:52 <lambdabot>  0
08:50:54 <CosmicRay> Igloo: yes
08:51:00 <chessguy> > 2 / 3
08:51:01 <lambdabot>  0.6666666666666666
08:51:24 <mux> > 2 `divMod` 3
08:51:25 <lambdabot>  (0,2)
08:52:11 <chessguy> is there something that will take something like 4 `op` 6, and return a Fractional 2/3?
08:52:20 <int-e> > 4 / 6 :: Rational
08:52:22 <lambdabot>  2%3
08:52:34 <CosmicRay> Igloo: I may need help on the hdbc-sqlite3 one.  I can't duplicate the problem, and it built fine on most of the autobuilders
08:52:39 <CosmicRay> but failed on alpha, mips, and mipsel.
08:52:42 <chessguy> hmm, kinda ugly
08:52:57 <Igloo> CosmicRay: Have you tried it on your alpha?
08:53:23 <int-e> > sequence [numerator, denominator] (2%3)
08:53:25 <lambdabot>  [2,3]
08:53:28 <CosmicRay> Igloo: my alpha is unfortunately sitting on the floor far back in a closet at the moment
08:54:17 <CosmicRay> (I had to consolidate some things due to our stay in an apartment)
08:54:34 <int-e> chessguy: why is that ugly?
08:54:36 <CosmicRay> It'll probably have to stay there until January or so
08:54:58 <chessguy> ehh, most people would want to see a fraction as 2/3
08:55:00 <int-e> > toRational $ 2/3 -- this is ugly.
08:55:00 <Igloo> CosmicRay: It looks like it is now being built in dist/build by cabal, whereas it was presumably built in . before
08:55:01 <lambdabot>  6004799503160661%9007199254740992
08:55:15 <Igloo> CosmicRay: You can't reproduce that with 6.6 on your normal arch?
08:55:22 <int-e> % happens to be the smart constructor for Rationals.
08:55:24 <CosmicRay> Igloo: no, I can't.
08:55:37 <chessguy> i didn't say it was wrong
08:55:43 <CosmicRay> hrm, I wonder if the problem is $(PWD) not working in the autobuilder.
08:55:45 <chessguy> just ugly, if you're writing for non-programmers
08:56:00 <CosmicRay> I have a make target that reads:
08:56:02 <CosmicRay>         runhugs -98 +o -P$(PWD)/dist/build:$(PWD)/testsrc: testsrc/runtests.hs
08:56:10 <CosmicRay> and on the alpha build log, it spat out:
08:56:15 <CosmicRay> runhugs -98 +o -P/dist/build:/testsrc: testsrc/runtests.hs
08:56:22 <Igloo> Oh, all the builds use ghc 6.6
08:56:37 <int-e> I wonder if Haskell should steal the (Python?) distinction of representation and printing. (representation would be an ascii string that can be parsed back, the print version would something more human readable)
08:56:55 <CosmicRay> I bet I should s/PWD/CURDIR/
08:57:10 <Cale> int-e: didn't that distinction exist before, in previous Preludes?
08:57:17 <Cale> Maybe the Gofer prelude?
08:57:18 <int-e> Cale: I don't know.
08:57:49 <int-e> Cale: I've never looked at pre-98 Haskell seriously.
08:58:02 <chessguy> @hoogle delete
08:58:03 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
08:58:03 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
08:58:03 <lambdabot> Data.IntMap.delete :: Key -> IntMap a -> IntMap a
08:58:06 <Philippa_> does the print version have to be mechanically readable, and if so is the distinction largely one of parsing speed?
08:58:07 <musasabi> Igloo: would GHC benefit from having a test-account on an alpha machine?
08:58:25 <Igloo> CosmicRay: hmm, that does look to be the problem, but surely that is a bug?
08:58:48 <CosmicRay> Igloo: I don't know enough about the standards to know if PWD is supposed to be guaranteed available
08:58:58 <CosmicRay> Igloo: but it is simple enough to work around.  I'll upload the new package shortly.
09:00:37 <CosmicRay> I also need to look into #395104.  I have been figuring there was some cabal change, but I haven't had the time to investigate
09:00:45 <Igloo> musasabi: We're OK at the moment thanks, but if it's running Debian I'd be interested to know what make says when Makefile contains "foo:\n\techo $(PWD)"
09:01:03 <CosmicRay> if you happen to know off the top of your head what I need to say in my .cabal file to get a directory added to the C search path at library build time, but not at library use time, that would be perfect ;-)
09:01:11 <CosmicRay> Igloo: it works on normal machines
09:01:17 <Igloo> CosmicRay: I don't know what's guaranteed either, but I'm sure it should be the same across all arches in Debian for this...
09:01:20 <CosmicRay> Igloo: it is just three of the autobuilders where it doesn't
09:01:32 <Igloo> Why only build time?
09:01:33 <CosmicRay> Igloo: I suspect it's not an arch bug, but rather an buildd configuration issue
09:02:00 <CosmicRay> Igloo: I think it's a buildd thing.  some buildds are configured oddly on purpose ($HOME not pointing to a writable location, etc)
09:02:39 <CosmicRay> new sqlite3 uploaded.
09:03:00 <musasabi> Igloo: no debian unfortunately at the moment.
09:03:27 <araujo> hola!
09:03:51 <Igloo> Hmm, I can't find either PWD or CURDIR in the info pages
09:04:16 <CosmicRay> CURDIR is in the make info pages
09:04:22 <CosmicRay> PWD comes from the environment somewhere
09:04:36 <CosmicRay> so it would not be in the make pages
09:05:29 <Igloo> Whereabouts is it?
09:05:40 <chessguy> wow, that's a new error message to me.
09:06:04 <Igloo> Why not just use `pwd`, anyway?
09:06:07 <CosmicRay> Igloo: I'm guessing the shell
09:06:09 * Igloo understands `pwd`  :-)
09:06:20 <CosmicRay> Igloo: I think I was going for $(CURDIR) and had a braino.
09:06:43 <lisppaste2> chessguy pasted "What the heck is this error?" at http://paste.lisp.org/display/29042
09:06:48 <Igloo> Anyway, see #debian-devel for confirmation of the answer
09:07:14 <CosmicRay> yup.
09:07:46 <int-e> chessguy: it means that your type signature is too general
09:08:09 <chessguy> why?
09:08:12 <int-e> chessguy: it infers that your a must equal your b. (you use (q-x) so that's right)
09:08:35 <chessguy> oh!
09:08:46 <chessguy> well a can equal b, can't it?
09:09:28 <Igloo> But you say it doesn't have to
09:09:42 <Igloo> Your type sig says I can give you an Int and a list of Integer, and it'll return an Integer
09:09:58 <araujo> @users #haskell.es
09:09:58 <lambdabot> Maximum users seen in #haskell.es: 12, currently: 12 (100.0%), active: 6 (50.0%)
09:10:01 <chessguy> aha
09:10:02 <araujo> New record!
09:10:13 <int-e> anyway, that's a rather bad error message
09:10:13 <araujo> :-)
09:10:18 <chessguy> yes, rather
09:10:34 <Igloo> araujo: And apparently Spanish Haskellers are more active than general Haskellers  :-)
09:11:09 <balayhashi> hi there ! I'm doing a function with this signature :: [a] -> [a] -> [a]  .   and i'm getting an ord problem ... -> http://rafb.net/paste/results/BU8NMi36.html . Can someone please check it out?
09:11:33 <CosmicRay> Igloo: I am mystified by #395104.  I can't find anything wrong with my package, and I don't mention that dir in .cabal
09:11:39 <CosmicRay> Igloo: do you happen to have any ideas?
09:12:15 <araujo> Igloo, haha
09:12:18 <Cale> balayhashi: if you're giving the function an explicit type, and you're comparing elements of the lists with < or >, you need to say that the type 'a' supports these operations
09:12:36 <Cale> balayhashi: so the type becomes (Ord a) => [a] -> [a] -> [a]
09:12:52 <lisppaste2> int-e annotated #29042 with "ghc 6.6 error message - much clearer" at http://paste.lisp.org/display/29042#1
09:12:52 <araujo> Igloo, i won't say that (_yet_) , but all for the whole community! :-)
09:13:00 <CosmicRay> Igloo: the generated installed-pkg-config very clearly references the dir mentioned there, but I didn't ask it to
09:13:07 <aFlag> when you use hopengl you end up having to use IORef, right? There isn't a better way to keep track of the created objects and then changing them?
09:13:44 <CosmicRay> aFlag: Control.Concurrent.MVar provides a way that is threadsafe
09:13:48 <CosmicRay> it is otherwise similar to IORefs
09:14:45 <Igloo> CosmicRay: gencabal? Ug?
09:15:05 <int-e> chessguy: did you see the annotation?
09:15:09 <CosmicRay> Igloo: yeah I know, that was before the days of cabal being able to call out to other programs.  Or at least before the days when I knew it could.
09:15:19 <chessguy> oh, let me look
09:15:45 <balayhashi> Cale : thanks . But why is that necessary?  Haskell ( ghci) can't wait  to see if my type a can support those operations?
09:16:18 <chessguy> that does look better
09:17:18 <Binkley> balayhashi: if you're going to give a type annotation at all, it has to be precise
09:17:36 <Binkley> there are proposals for ghc to support something called "partial type annotations", which would let you do what you want here, but it doesn't yet
09:18:03 <chessguy> now i've got another really ugly error message
09:18:56 <lisppaste2> chessguy annotated #29042 with "another nasty error" at http://paste.lisp.org/display/29042#2
09:19:46 <chessguy> i guess it can't figure out the type of pivotal
09:19:52 <chessguy> err, of ssIndices
09:20:08 <Binkley> look at the type of pivotal and the type of (perms xs)
09:20:28 <Binkley> do you mean for it to be (pivotal x)?
09:20:36 <Binkley> i notice that the body of ssIndices doesn't use x
09:20:52 <Cale> balayhashi: well, if you take out the type signature altogether it will infer it, but if you left it in without the (Ord a), it would mean something too general
09:21:04 <chessguy> ohh
09:21:20 <Cale> balayhashi: namely, you'd be claiming that it worked for any type at all 'a', even those which you can't compare, which isn't true.
09:21:47 <Binkley> chessguy: the error message from ghc could definitely stand to be better, though
09:21:48 <int-e> chessguy: you missed an 'x'.
09:21:57 <balayhashi> in did! you guys are right . thanks
09:22:04 <chessguy> yeah
09:22:25 <chessguy> ok, int-e: time for the real test. what does this code do? :)
09:22:34 <chessguy> or rather, what's it supposed to do
09:23:07 <chessguy> that's almost more a #math question though
09:25:39 <Igloo> CosmicRay: I suspect the problem is you aren't telling cabal to copy the package contents correctly, but I CBA to chase through what dh_haskell -a does
09:25:47 <chessguy> ugh, don't even try to answer. the code's all screwed up
09:26:13 <Igloo> CosmicRay: How come you don't do anything in teh build target
09:27:02 <Igloo> CosmicRay: My reasoning is based on the fact that libghc6-mtl-dev contains a /usr/lib/mtl-1.0/ghc-6.6/include referenced in .installed-pkg-config, so I assume it's meant to happen, BTW
09:28:13 <CosmicRay> Igloo: I have to run, could you /msg me what I should be telling cabal to do?
09:28:14 <CosmicRay> thanks
09:28:21 * CosmicRay AFKs for an hour
09:28:34 <int-e> chessguy: I don't know. right now, if the xs list has no duplicate elements, it returns a list of many 1s (if x is smaller or equal to  sum xs) or 0s (otherwise)
09:28:48 <chessguy> yeah, it's messed up. hang on
09:29:21 <ndm> @seen roconnor
09:29:21 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 57m 55s ago.
09:29:41 <ndm> roconnor: fromRight/fromLeft are the best bits in teh patch, don't you dare remove them!
09:29:48 <lisppaste2> chessguy annotated #29042 with "fixed code" at http://paste.lisp.org/display/29042#3
09:30:00 <chessguy> now it should work
09:31:10 <Binkley> chessguy: in pivotal, you write the test x >= q twice. you can refactor that so you only write it once
09:32:23 <chessguy> Binkley, oh?
09:34:03 <lisppaste2> Binkley annotated #29042 with "here's how you refactor pivotal" at http://paste.lisp.org/display/29042#4
09:34:23 <Binkley> You can probably get more concise than that
09:34:27 <Binkley> but you get the idea
09:35:34 <int-e> chessguy: hmm, I see what it does - it seems to be related to the knapsack problem - but I don't know what these numbers are good for exactly.
09:35:36 <Binkley> you might want to handle the empty list, too
09:35:38 <Binkley> but I'm not sure
09:36:10 <chessguy> hmm, i'm not familiar with any relationship to that problem. think weighted voting games.
09:36:25 <chessguy> Binkley, well it should never get that far, right?
09:36:43 <Binkley> well, what happens if you invoke ssIndices on an empty list?
09:36:57 <chessguy> well, yeah, ok
09:37:24 <Binkley> if ssIndices has "xs is nonempty" as a precondition, it's nice to document that, at the very least :-)
09:38:10 <chessguy> i'll just test for the empty list in pivotal
09:38:32 <Binkley> if it doesn't hurt to handle a case, i say handle it
09:38:39 <chessguy> indeed
09:39:23 <int-e> right, you can save a line of code in pivotal that way.
09:39:56 <chessguy> the name ssIndices is the key to figuring out what the code does. though even you might not be familiar with this analysis, int-e
09:40:36 <chessguy> it calculates the Shapley-Shubik power index for the voters a weighted voting game
09:40:45 <chessguy> s/voters/voters in/
09:42:13 <int-e> Yes, google found that for me.
09:42:45 <chessguy> i'm trying to find a way to construct a game from a given set of power indices
09:48:12 <chessguy> @type /
09:48:13 <lambdabot> parse error on input `/'
09:48:18 <chessguy> @type `/`
09:48:19 <lambdabot> parse error on input ``'
09:48:29 <chessguy> @type (/)
09:48:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:48:34 <ToRA> \o/
09:51:28 <chessguy> next it's time to do the banzhaf index
09:55:03 <chessguy> @hoogle seq
09:55:04 <lambdabot> Prelude.seq :: a -> b -> b
09:55:04 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
09:55:04 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
09:57:17 <satan> how would i do the equivalent of a nested loop in C/C++ or whatever, in haskell with 2 lists?
09:57:25 <Animosity> can anyone help me write the instance show for this binary tree?
09:57:26 <Animosity> data BinaryTree a = Empty | Node (BinaryTree a) a (BinaryTree a) deriving Show
09:57:41 <Baughn> satan: Nested recursion? Or something with map, if you can
09:58:02 <satan> Baughn: yeah i thought of map too
09:58:07 <satan> hmm
09:58:42 <Cale> Animosity: uh, if you already have deriving Show, then you have a Show instance
09:58:53 <Cale> Animosity: you can't have two show instances for the same type
09:59:30 <Cale> satan: a nested look which does what?
09:59:36 <Cale> loop*
09:59:48 <Animosity> cale: but how do i define what I want the print out of the tree to look like?
10:00:01 <satan> Cale: ok i think i have it, i'm working on that infinite series problem from last night
10:00:15 <satan> but i'm a bit stuck on how to move the coefficients to their right place
10:00:21 <Cale> Animosity: well, with deriving Show, it will look like the input code. If you remove that, you can define your own Show instance
10:00:30 <Animosity> ah i see
10:00:37 <Cale> instance (Show a) => Show (BinaryTree a) where ...
10:01:05 <Animosity> Show Empty = " (Empty) "
10:01:14 <Animosity> Show (Node l el r) = ...
10:01:17 <Cale> show
10:01:17 <Animosity> does this work?
10:01:24 <Cale> lowercase for the function name
10:01:28 <Animosity> ah
10:01:31 <Animosity> there's my problem then
10:01:36 <satan> so i have this: gc2 xs ys = map (\x -> map (*x) ys ) xs
10:01:38 <Animosity> i was getting some weird illegal binding
10:01:51 <satan> which when called with: gc2 [2,0,5,6] [0,3,2,1]
10:02:00 <satan> gives me: [[0,6,4,2],[0,0,0,0],[0,15,10,5],[0,18,12,6]]
10:02:27 <Animosity> thank you Cale got it now
10:02:35 <Cale> Animosity: no problem
10:02:38 <Cale> satan: hmm
10:02:46 <satan> which is right, but the powers don't match, since the first list should be [0,6,4,2,0,0,0], the 2nd should be [0,0,3,2,1,0,0], 3rd should be [0,0,0,15,10,5,0]
10:03:08 <satan> and then i add each list element wise and get the final answer [0,6,7,19,29,17,6]
10:03:16 <satan> which are the right coefficients
10:03:34 <satan> but how to insert the right # of zeroes before and after depending on the list's position in the loop
10:03:38 <roconnor> @hoogle lefts
10:03:39 <lambdabot> Language.Haskell.Syntax.HsLeftSection :: HsExp -> HsQOp -> HsExp
10:03:43 <chessguy> i seem to remember there was a way to get all n! sets of size n of Trues and Falses, but i don't remember how
10:03:56 <satan> i was thinking of iterate (+0) 0 a certain number of times, but again, don't know how
10:04:03 <Cale> chessguy: do you mean 2^n ?
10:04:14 <chessguy> yes, of course. sorry
10:04:19 <Cale> > sequence (replicate 3 [True,False])
10:04:21 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
10:04:35 <ndm> roconnor: please keep isLeft, fromLeft etc in your patch, they are really useful!
10:04:54 <roconnor> ndm: All I am proposing is to separate those into a different trac
10:05:02 <chessguy> > replicate 3 [True,False]
10:05:03 <lambdabot>  [[True,False],[True,False],[True,False]]
10:05:20 <satan> hmm that might work eh
10:05:20 <ndm> roconnor: thats fair enough - i just don't want them getting lost - the are the "best bits" of your patch in my opinion
10:05:21 <roconnor> ndm: everyone agrees that splitEithers (under some name) should be added.
10:05:23 <satan> > replicate 3 0
10:05:25 <lambdabot>  [0,0,0]
10:05:33 <satan> right
10:05:33 <ndm> roconnor: and i'd be tempted to force them all in at once, might make it a bit easier :)
10:05:34 <Cale> satan: I'd be more helpful on that if I wasn't sleepy. It involves slightly more thought than I'm probably capable of right now. :)
10:05:53 <satan> Cale: no worries dude, thanks, i'll plod away at it, i'm sure i'll ask tonight or tomm or something
10:05:58 <roconnor> ndm: heh.  Well, lets try to do things better than the politicans
10:05:59 <satan> did you sleep at all last night, heh?
10:06:04 <Cale> no :)
10:06:11 <satan> lol
10:06:22 <ndm> roconnor: i want to be a dictator, not a politician
10:06:23 <twanvl> > zipWith (++) (iterate (0:) []) [[0,6,4,2],[0,0,0,0],[0,15,10,5],[0,18,12,6]]
10:06:25 <lambdabot>  [[0,6,4,2],[0,0,0,0,0],[0,0,0,15,10,5],[0,0,0,0,18,12,6]]
10:06:34 <satan> what else can an out-of-work academic do eh? :P any luck with finding jobs?
10:06:37 <Cale> and I just spent a good couple of hours recruiting a new Haskellite :)
10:06:47 <ndm> roconnor: for example, i might add them to hoogle and clicking on the docs brings people to the trac page :)
10:06:55 <satan> always good, i don't remember how i entered this cult :P but here i am
10:06:59 <roconnor> ndm: well, I'm personally a fan of anarchy, so that is what we need to aim for.  Then you get to be your own little dictator. :)
10:07:18 <ndm> roconnor: i want to be dictator of everyone...
10:07:18 <chessguy> wow, it took a couple hours?
10:07:22 <Cale> satan: yeah, I'm going to send off a resume today. I just need to add a couple of things
10:07:34 <roconnor> ndm: :( you don't really mean that?
10:07:35 <satan> twanvl: hmm that seems to add them to the start
10:07:36 <Cale> chessguy: well, I gave a full intro to the language and we coded some simple things :)
10:07:50 <ndm> roconnor: beneavolent dictator ;)
10:07:54 <satan> Cale: cool, as a teacher? coder? if i may ask, of course
10:07:59 <chessguy> i would have liked to have seen that
10:08:22 <roconnor> ndm: when everyone can design standard libraries, the best ones will rise to the top
10:08:24 <Cale> satan: coder, database person
10:08:34 <twanvl> satan: just reverse the list and do it again, with the arguments of zipWith swapped, then you get the right number of zeroes at the end
10:08:42 <twanvl> There might be a better way though
10:08:42 <roconnor> ndm: the results is even better than you can do alone.
10:08:47 <satan> Cale: cool, i had that job last summer, well the whole php/mysql LAMP thing
10:08:50 <Cale> satan: and apparently some web development too
10:09:07 <ndm> roconnor: i don't have that much faith in democracy, but yes, there are certainly people who can do it better than me
10:09:16 <satan> twanvl: ahh i see, cool thanks, i'll try it
10:09:17 <roconnor> > sequence (replicate 3 [minBound .. maxBound]) : http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Bool
10:09:18 <lambdabot>  Parse error
10:09:20 <lambdabot> http://tinyurl.com/yx2dze
10:09:26 <roconnor> > sequence (replicate 3 [minBound .. maxBound]) : http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Bool
10:09:27 <lambdabot>  Parse error
10:09:29 <lambdabot> http://tinyurl.com/yx2dze
10:09:32 <roconnor> wtf
10:09:43 <roconnor> what is my irc client doing?
10:09:53 <satan> > sequence (replicate 3 [minBound .. maxBound]
10:09:53 <lambdabot>  Parse error
10:10:01 <satan> > sequence (replicate 3 [0 .. 5]
10:10:02 <lambdabot>  Parse error
10:10:06 <satan> > sequence (replicate 3 [0..5]
10:10:06 <lambdabot>  Parse error
10:10:11 <satan> bah
10:10:14 <satan> > sequence (replicate 3 [0..5])
10:10:15 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,0,4],[0,0,5],[0,1,0],[0,1,1],[0,1,2],[0,...
10:10:22 * chessguy cheers
10:10:41 <roconnor> > sequence (replicate 3 [minBound .. maxBound]) : [[Bool]]
10:10:42 <lambdabot>  Not in scope: data constructor `Bool'
10:10:53 <roconnor> > sequence (replicate 3 [minBound .. maxBound]) :: [[Bool]]
10:10:54 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
10:11:08 <roconnor> ndm: not democracy, anarchy.
10:11:17 <satan> so sequence just repeats them ad infinitum?
10:11:17 <Cale> > filterM (const [True,False]) [1,2,3]
10:11:19 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
10:11:31 <int-e> satan: I think creating these long lists is a bad idea - instead you can 'sum' the 2nd, 3rd, etc. list (which is a recursive call), then prepend 0 to the resulting list and add that to the first list.
10:11:34 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:11:35 <roconnor> ndm: just like in linux where several different entities put together different distributions
10:11:35 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
10:11:47 <roconnor> ndm: and you get to pick wich set you want to use.
10:11:54 <Cale> forms all ways to choose an element
10:11:56 <roconnor> ndm: or even make your own
10:11:59 <int-e> satan: and I'd not append the 0s at all - instead you can write a specialized version of 'zipWith' which keeps the tails.
10:12:03 <ndm> roconnor: i guess - anyway i really want fromLeft in, so will help push as much as you need
10:12:11 <satan> int-e: i'm afraid i wouldnt know how
10:12:30 <int-e> satan: which of the two? or both?
10:12:35 <roconnor> ndm: okay, once I figure out the proper way of chaning my patch, we can make a new trac
10:12:41 <satan> int-e: so what you're saying is, leave them as they are, then while adding, push the appropriate # of zeroes at the start or end, maybe i'll try twanvl's method
10:13:20 <int-e> satan: the point is that you'd only prepend O(n) zeros, not O(n^2), and it'll work nicely for infinite lists.
10:13:43 <twanvl> satan: If you just want to add the elements afterwards you don't need the zeroes at the end
10:14:15 <int-e> satan: I can give you complete code. I'm just not sure if it'd help.
10:14:50 <satan> hmm why won't i need the zeroes at the end?
10:15:07 <satan> int-e: thanks, i might just take you up on that, but i wanna try it myself
10:15:15 <int-e> you only need those to satisfy zipWith's needs.
10:15:43 <int-e> if you write your own function to add lists instead, you don't need them.
10:15:45 <satan> ok, so now from twanvl's code above, i have this: [[0,6,4,2],[0,0,0,0,0],[0,0,0,15,10,5],[0,0,0,0,18,12,6]]
10:15:57 <int-e> (where by 'them' and 'those' I mean the zeros at end)
10:16:15 <satan> right, so how do i go about adding those lists to get [0,6,7,19,29,17,6]? element wise adding...
10:16:19 <satan> int-e: right
10:16:21 <twanvl> > map sum $ transpose $ zipWith (++) (iterate (0:) []) [[0,6,4,2],[0,0,0,0],[0,15,10,5],[0,18,12,6]]
10:16:22 <lambdabot>  [0,6,4,17,28,17,6]
10:16:42 <satan> holy..
10:16:47 <int-e> satan: could you implement zipWith?
10:16:50 <roconnor> twanvl: wow
10:17:19 <satan> int-e: no i don't think so :(
10:17:29 <satan> i'm such a newbie, cant you tell? :P
10:17:38 <roconnor> I see now
10:17:58 <chessguy> replace 3 2 [1,2,3]
10:17:59 <satan> what does the transpose do? and the $ simply adds parentheses around the next function, right?
10:18:01 <chessguy> > replace 3 2 [1,2,3]
10:18:02 <lambdabot>  Not in scope: `replace'
10:18:26 <twanvl> > transpose [[1,2,3],[4,5,6],[7,8,9]]
10:18:27 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
10:18:42 <satan> oh so row, col switch
10:19:00 <twanvl> yes
10:19:04 <int-e> satan: ok, zipWith: zipWith f (a:as) (b:bs) = f a b : zipWith f as bs  -- this is the basic case - both lists are nonempty, we combine the first elements with f, them call zipWith recursively.
10:19:23 <satan> right
10:20:14 <int-e> satan: to round it up we need to deal with empty lists, too. zipWith f [] _ = []; zipWith f _ [] = []; ... this is the wrong thing for adding lists as you want it; you'd like to deal with these differently.
10:20:19 <roconnor> > map sum $ transpose $ zipWith (++) (inits (repeat 0)) [[0,6,4,2],[0,0,0,0],[0,15,10,5],[0,18,12,6]]
10:20:20 <lambdabot>  [0,6,4,17,28,17,6]
10:20:50 <satan> right
10:21:17 <int-e> satan: that's the general pattern of list recursion:  handle nonempty lists (pattern match on) (a:as) and empty lists, [], separately. hand off the work on the rest of the list (in the first call) to a recursive call.
10:21:33 <int-e> roconnor: transpose is clever, yes.
10:21:34 <satan> right, fair enough
10:21:54 <int-e> roconnor: but you still insert O(n^2) zeros, that's no good.
10:22:04 <Baughn> satan: And if you can use map or reduce (well, fold) instead, be happy
10:22:21 * roconnor wonders if he can improve his SHA2
10:22:22 <satan> cleaner than recursion? easier?
10:22:59 <Baughn> Cleaner, simpler, does the exact same thing with less code
10:23:14 <Baughn> Any loop is recursion pretty much by definition, though
10:23:15 <int-e> Baughn: sure, but how do you understand them without understanding list recursion at the low level?
10:23:25 <Baughn> Point..
10:23:52 <Baughn> satan: So.. don't use map or fold if you don't understand how they do what they do. ;)
10:24:11 <satan> Baughn: right, i think i know them and how they work, well foldl and foldr anyway
10:24:17 <roconnor> int-e: I see
10:24:28 <satan> int-e: thanks, btw :)
10:24:29 <Baughn> satan: Can you implement fold/foldr? Try it.
10:24:37 <Baughn> satan: map is simpler, but try that one as well anyway
10:24:38 <int-e> I'll be idle for half an hour or so. bbl
10:24:46 <satan> Baughn: yeah i have it somewhere
10:25:13 <Baughn> satan: It's a good idea not to use any function you couldn't write yourself if you had to
10:25:25 <Baughn> At least while you're learning
10:25:27 <satan> Baughn: thats good advice, thanks
10:25:29 <satan> right
10:30:56 <chessguy> > Sum [1,2,3]
10:30:56 <lambdabot>  Not in scope: data constructor `Sum'
10:31:00 <chessguy> > sum [1,2,3]
10:31:01 <lambdabot>  6
10:34:30 <chessguy> @type zipWith
10:34:32 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
10:35:28 <chessguy> heh. i remember when that type signature would've struck fear into my heart
10:35:29 <satan> twanvl: so that code above won't work for an infinite list though, right? the  map sum $ transpose $ zipWith (++) (iterate (0:) []) bit
10:36:05 <twanvl> It probably won't
10:36:24 <satan> how would i work it so that it would, since i'd only need to display the first 20 or whatever
10:40:31 <chessguy> > zipWith (*) [1,2,3] [4,5,6]
10:40:32 <lambdabot>  [4,10,18]
10:55:49 <int-e> actually it does work for infinite lists.
10:56:30 <int-e> hmm. ok, maybe not.
10:56:35 <int-e> sorry.
11:12:30 <chessguy> > zipWith (*) [1..] [2..]
11:12:31 <lambdabot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
11:14:21 <nominolo> gah!  Haskell + Macros (TH) = Unusable .. >:-(
11:18:19 <musasabi> nominolo: one just needs to write combinators and lots of caffeine.
11:18:37 <nominolo> LOTS of caffeine
11:18:50 <musasabi> (and sleepless nights trying to understand why TH hates users)
11:19:05 <satan> i dunno, it works with those examples but not my infinite lists
11:19:24 <nominolo> I wonder why they try to support full haskell syntax instead of just a minimal core
11:19:48 <satan> i think i know what to change, i have 2 nested loops with map, like so: ( map (\x -> map (*x) ys ) xs). maybe if I rewrote that with a foldr, it would work
11:21:37 <musasabi> nominolo: I usually just write wrappers that convert things into a more manageable things.
11:22:04 <keroppi> Haskell is easy.  Are you sure you need TH?
11:22:23 <nominolo> keroppi: yup, i want to generate boilerplate code
11:22:40 <nominolo> i want to add some automatic instance declarations
11:22:55 <nominolo> and i'd like to (sort of) stay in haskell
11:23:02 <nominolo> (ie, no code generators)
11:23:43 <nominolo> but i'm open for any suggestions
11:27:40 <musasabi> nominolo: people have done it in past with TH, but it is painful. Drift is an alternative.
11:28:01 <musasabi> (writing drift support for new types is easier than TH)
11:33:32 <nominolo> hm. i already have read the TH paper and have some stuff working - and the drift docs look pretty concise ..
11:35:10 <nominolo> but thanks for the link
11:42:09 <psnl> @pl help
11:42:09 <lambdabot> help
11:42:15 <psnl> @help pl
11:42:15 <lambdabot> pointless <expr>. Play with pointfree code.
11:42:53 <psnl>   datas <-  getChanContents chan
11:43:00 <psnl> curses
11:51:53 <newsham> hio-error
11:57:16 <Binkley> ioerror, are you also lj user="ioerror"?
12:10:36 <merritt2374> hoi everyone. could someone help me with an "undefined type constructor" error message, please?
12:10:53 <ioerror> Binkley, indeed
12:10:56 <ioerror> hey newsham
12:11:01 <ioerror> Binkley, lj user as well?
12:11:26 <araujo> merritt2374, paste somewhere
12:14:11 <merritt2374> i got a type declaration: restrictR :: Ord a => Set a -> Rel a -> Rel a -- where type Rel a = Set (a,a) and newtype Set a = Set [a] deriving (Eq,Ord). everything should be fine, but hugs gives me the error message "undefined type constructor "Set""...
12:15:39 <araujo> merritt2374, can you paste the whole code somewhere?
12:15:49 <araujo> merritt2374, that is all contained in the same module?
12:16:56 <merritt2374> the code is a module which imports a module that defines Set, and then contains "type Rel a = Set (a,a)" and the type declaration; nothing else
12:17:48 <merritt2374> actually, it's the exercise in a book and one could import most of the stuff, but it should work with such a minimal module, shouldn't it?
12:17:50 <balayhashi> if i have something like [[a]]  and i want to do add a list of [a] to that . why doesn't [a] : [[a]] works?
12:18:21 <Baughn> > [2] : [[3]]
12:18:22 <lambdabot>  [[2],[3]]
12:18:36 <basvandijk> Hi guys, is it possible to hide a Show instance from a module? Say module A exports a type T and declares an instance Show T. Now I would like to import A but hide the Show instance for T because I would like to make one myself. How can I do that? (import A hiding (Show T) doesn't work, according to the report this isn't valid syntax)
12:19:41 <lispy> more evidence that haskell's module system wants to behave like OO :)
12:19:42 <Baughn> balayhashi: Apparently it does - but that isn't exactly like your code, is it?
12:20:27 <balayhashi> baughn : lol . yeah my code must have something different , but I just don't see it tough .
12:20:35 <Binkley> possibly it's a GHC extension?
12:20:57 <balayhashi> prefixos ( h:hs ) = [h:hs] : [1,2]
12:21:23 <Binkley> ioerror: oops, got distracted. yes, I'm lj:catamorphism
12:21:47 <merritt2374> so, the whole code is "module HCtest   where   import REL    restrictR :: Ord a => Set a -> Rel a-> Rel a"  with REL being http://homepages.cwi.nl/~jve/rcrh/REL.hs
12:21:57 <Baughn> balayhashi: That looks.. odd. It's exactly equivalent to 'prefixos hs = hs : [1,2]', though
12:22:37 <Baughn> balayhashi: Which can't possibly work, since your version requires hs to be a list, and it can't be to fit in with 1 and 2..
12:23:30 <SamB> Baughn: it could possibly work
12:23:36 <Baughn> balayhashi: Oh, wait. That should be prefixos hs = [hs] : [1,2], which doesn't really help
12:23:42 <SamB> if there was a Num instance for lists
12:24:43 <SamB> hmm...
12:24:51 <SamB> maybe you want to swap the arguments to :?
12:24:56 <merritt2374> so you can get haskell to accept heterogenious lists via defining instances? that sounds interesting...
12:25:03 <Baughn> SamB: Peano arithmetic? My word...
12:25:11 <SamB> merritt2374: no
12:25:18 <SamB> they would be homogoenous
12:25:19 <int-e> SamB: polynomials. It can be done and is very confusing, because then 1 == [1]
12:25:30 <SamB> its just that you'd be dealing with wierd valies of 1 and 2
12:26:02 <merritt2374> ok
12:26:09 <balayhashi> baughn : what do you mean ? ( my version requires hs to be a list ? )
12:26:11 <SamB> er. values
12:27:54 <Baughn> balayhashi: Your first (and only) argument is (h:hs), which has to be a list
12:28:13 <Baughn> balayhashi: You then attempt to splice it to the front of a list of /numbers/. It would have to be a list of lists to work.
12:28:56 <lisppaste2> ValarQ pasted "patterns" at http://paste.lisp.org/display/29056
12:29:19 <Baughn> balayhashi: Also, foo (x:xs) = something involving (x:xs) is exactly equivalent to foo x = something involving x - it's only useful to decompose the thing if you then use the x separately from the xs
12:29:20 <ValarQ> how could one make that function shorter?
12:29:32 <balayhashi> I'm trying to do a prefixos functions that as the type [a] -> [[a]] . And it does something like -> prefixos [1,2,3] = [ [] , [1] , [1,2] , [1,2,3]] .
12:29:58 <balayhashi> i need to have h:hs ( I think ) .
12:30:22 <balayhashi> but i got stuck in to work around with : and lists .
12:30:52 <SamB> > inits [1,2,3]
12:30:53 <lambdabot>  [[],[1],[1,2],[1,2,3]]
12:30:54 <lispy> > inits [1,2,3]
12:30:55 <lambdabot>  [[],[1],[1,2],[1,2,3]]
12:31:05 <lispy> SamB: bleh!
12:31:11 <lispy> SamB: type slower!
12:31:15 <ValarQ> :)
12:31:18 <SamB> heh
12:31:58 <Baughn> balayhashi: So there you go - 'prefixos = inits' will do.
12:32:04 <ValarQ> i feel that there is some way to reuse my guards in that function...
12:32:28 <Baughn> ValarQ: You could turn the guard into a separate function, for one
12:32:40 <balayhashi> lol , well I'll have to understand inits . I'm no trying to build anything . just trying to learn
12:33:06 <int-e> hmm, inits. did anyone else ever miss a function that returns a list of reversed prefixes?
12:33:25 <SamB> map reverse . tails, anyone?
12:33:32 <SamB> oh wait.
12:33:32 <Baughn> > (reverse . inits) [1,2,3]
12:33:33 <int-e> map reverse . inits  suffers from being inefficient
12:33:34 <lambdabot>  [[1,2,3],[1,2],[1],[]]
12:33:38 <SamB> tails . reverse
12:33:38 <balayhashi> where can i find inits definition ?
12:33:43 * SamB got it backwards
12:34:02 <SamB> > (tails . reverse) [1,2,3]
12:34:03 <lambdabot>  [[3,2,1],[2,1],[1],[]]
12:34:16 <int-e> (it should be O(n), not O(n^2) in terms of list operations)
12:34:22 <Baughn> balayhashi: GHC source, for one. It might be a bit.. weedy.
12:34:33 <SamB> hmm.
12:34:35 <int-e> and I'd like it to work on infinite lists.
12:34:39 <balayhashi> what does weedy means?
12:34:42 <SamB> oooh
12:34:45 <lispy> balayhashi: i just write init to see for myself one way to do it, and i use an auxillary function and take
12:35:05 <SamB> @type scanl
12:35:06 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:35:18 <lispy> balayhashi: so for example, take 0 [1,2,3] = [], take 1 [1,2,3] = [1] and so on
12:35:23 <basvandijk> A second question about Haskell's module system. When having modules A and B: http://paste.lisp.org/display/29057 Is it possible not to export the instance Show T from A? And for my first question: how can one hide the instance Show T from A in B?
12:35:33 <SamB> > scanl (flip (:)) [] [1,2,3]
12:35:34 <lambdabot>  [[],[1],[2,1],[3,2,1]]
12:35:41 <Heffalump> basvandijk: module instances are always implicitly exported and can't be hidden
12:35:42 <lispy> SamB: nice!
12:35:49 <int-e> SamB: clever :)
12:35:56 <basvandijk> Heffalump: why is that?
12:36:01 <SamB> thank you ;-)
12:36:06 <ValarQ> Baughn: thats true, i would like to avoid a global function, but it's a big improvement
12:36:09 <lispy> > scanl (:) [] [1..3]
12:36:10 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
12:36:10 <lambdabot>    Expected...
12:36:15 <Heffalump> I think it was considered too confusing to support it. It gets discussed off and on.
12:36:19 <lispy> SamB: so does that only work for the reversed way?
12:36:24 <Baughn> balayhashi: GHC is a /compiler/. Traditionally that's black magic, but it also doubles as a semi-standard library - so you get double magic
12:36:29 <lispy> > scanr (flip (:)) [] [1..3]
12:36:30 <lambdabot>    Occurs check: cannot construct the infinite type: c = [c]
12:36:30 <lambdabot>    Expected...
12:36:36 <Heffalump> to some extent the idea of an "instance" is a kind of universal truth
12:36:39 <lispy> > scanr (:) [] [1..3]
12:36:40 <lambdabot>  [[1,2,3],[2,3],[3],[]]
12:36:43 <SamB> > scanl (flip (:)) [] [1..]
12:36:44 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[8...
12:36:47 <pzpz> if i have a prototype of  foo (x:y:xs), how can i check for a null value in y?
12:36:48 <Baughn> balayhashi: I was trying to invoke the image of hacking your way through ancient tropical forests
12:36:51 <SamB> > scanr (:) [] [1..]
12:36:52 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:37:08 <Baughn> ValarQ: I'm sure you can give it some nice, documenting name
12:37:10 <lispy> > let { i xs = i' xs 0; i' xs n | n <= length xs = take n xs : i' xs (n+1) | otherwise = [] } in i [1,2,3]
12:37:12 <lambdabot>  [[],[1],[1,2],[1,2,3]]
12:37:17 <lispy> that was my definition
12:37:23 <lispy> not elegant or efficient :(
12:37:32 <SamB> lispy: that is called "inits"!
12:37:43 <SamB> > inits [1..]
12:37:44 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
12:37:45 <lispy> SamB: is that how it's defined?
12:37:51 <SamB> I dunno
12:37:56 <lispy> SamB: i know it's inits!
12:38:03 <lispy> that's what i was trying to write :)
12:38:04 <SamB> but any way you do it is going to be inefficient
12:38:05 <int-e> > map tails . inits $ [1,2,3]
12:38:07 <lambdabot>  [[[]],[[1],[]],[[1,2],[2],[]],[[1,2,3],[2,3],[3],[]]]
12:38:08 <basvandijk> Heffalump: OK. but I would like the universal truth of an instance to stop at the module boundary :-)
12:38:16 <balayhashi> baughn : lol . well . I have found inits definition and it sure does look a bit ... weedy
12:38:22 <lispy> ?tye tails
12:38:24 <lambdabot> forall a. [a] -> [[a]]
12:38:30 <lispy> ?type tail
12:38:31 <lambdabot> forall a. [a] -> [a]
12:38:33 <Heffalump> basvandijk: well, bad luck :-)
12:38:49 <lispy> > scanl head [] [1..3]
12:38:50 <lambdabot>    Occurs check: cannot construct the infinite type: t = [b -> t]
12:38:50 <lambdabot>    Exp...
12:39:06 <SamB> inits                   :: [a] -> [[a]]
12:39:06 <SamB> inits []                =  [[]]
12:39:06 <SamB> inits (x:xs)            =  [[]] ++ map (x:) (inits xs)
12:39:52 <lispy> ah, yeah, that makes more sense
12:40:01 <merritt2374> init [x] = []
12:40:02 <merritt2374> init (x:xs) = x: init xs
12:40:04 <lispy> and they avoid the costly length
12:40:14 <SamB> oh, you checked the length?
12:40:15 <merritt2374> ah, srz
12:40:24 <SamB> that isn't going to work on infinite lists at ALL
12:40:25 <lispy> SamB: yeah, because i used take :)
12:41:29 <int-e> > takeWhile (not . null) $ iterate tail [1..3]
12:41:30 <lambdabot>  [[1,2,3],[2,3],[3]]
12:42:27 <merritt2374> but i'd still love to know, what exactly "undefined type constructor" means if the type constructor actually is defined..
12:46:11 <merritt2374> i mean, having "newtype Set a = Set [a] deriving (Eq,Ord)" and "type Rel a = Set (a,a)" should be enough to make "restrictR :: Ord a => Set a -> Rel a -> Rel a" work, shouldn't it?
12:46:11 <lispy> > takeWhile (not . null) $ iterate id [1..3]
12:46:12 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,...
12:46:21 <lispy> > takeWhile (not . null) $ iterate head [1..3]
12:46:22 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
12:46:22 <lambdabot>    Expected...
12:47:53 <ptolomy> Anyone familiar with the use of the new bytestring monadic regular expressions in the GHC lib?
12:51:40 <lispy> ptolomy: no, but they sound cool
12:52:09 <ptolomy> I was using the old regex stuff before within the Maybe monad and it was all fun but a lil slow, so I figured I'd bytestring it up. The use of =~~ is a little confusing to me, though.
12:52:53 <Animosity> does haskell support #define's or something like that for pattern subsitution?
12:53:09 <lispy> Animosity: ghc does if you compile with -cpp
12:53:26 <Animosity> thank you
12:53:31 <lispy> Animosity: i don't know how well it works compared to C though
12:53:41 <lispy> Animosity: i've only ever used it for #if ...
12:53:42 <Animosity> ok here's my problem then
12:53:46 <Animosity> maybe there's another way to do it
12:53:47 <Binkley> lispy: it works exactly the same as C
12:53:58 <Animosity> i have a tree with 7 children
12:54:07 <Binkley> Animosity: I don't really recommend using #defines in GHC
12:54:20 <Binkley> it's really meant for bizarre compiler hackery stuff; for most things, there's a Better Way
12:54:21 <Animosity> now in a funtion that takes a tree as a parameter i dont want to write the 7 arguments every time
12:54:31 <Animosity> is there a way to quickly substitute with something shorter?
12:54:39 <Binkley> sure: define a function that does what you want :-)
12:54:49 <Animosity> i dont get it
12:55:00 <Binkley> well, can you post your code? that might make it more clear
12:55:09 <Baughn> Animosity: Perhaps if you pasted examples of two such functions
12:55:27 <lispy> Animosity: if you really want the compiler to write the code, try template haskell
12:56:06 <Animosity> ah ok
12:56:12 <Animosity> thank you
12:56:38 <Binkley> you can probably do what you want without template haskell, but I can't explain it any better without seeing your code
12:56:44 <Baughn> Animosity: Using template haskell is a mistake if you could do the same with normal haskell
12:57:00 <Baughn> Animosity: So show us the code, okay? ;)
12:57:57 <Animosity> ok gimme a sec
12:58:51 <Animosity> data Tree a = Empty | (Tree a) a (Tree a) a (Tree a) a (Tree a)
12:59:01 <Animosity> insert:: Ord a=> a ->Tree a->Tree a
12:59:22 <Baughn> Animosity: Ack! paste.lisp.org!
12:59:29 <Animosity> bah dang sorry
12:59:39 <Binkley> why is your tree data type defined like that?
12:59:59 <Animosity> i have to make a 2-3-4 tree, dont want to type everything in irc
13:00:04 <Animosity> ill do it on the paste thingy tho
13:00:08 <Binkley> Ah ok.
13:00:39 <Binkley> Well, I recommend defining it like this for starters: data Tree a = Empty | Tree [Tree a] [a]
13:01:20 <Binkley> actually, the code you have wouldn't even compile as-is...
13:03:18 <Animosity> http://paste.lisp.org/display/29059
13:03:18 <Baughn> Animosity: At any rate, it might make sense two have more constructors. Say, a Two constructor, a Three constructor and a Four constructor...
13:03:26 <Animosity> yes i do have that
13:03:39 <gour> @quote wall
13:03:40 <lambdabot> wall hasn't said anything memorable
13:04:07 <gour> anyone knows l. wall's quote about closures?
13:04:36 <SyntaxNinja> w00t
13:05:05 <Animosity> the problem with 2,3,4 tree is i can't insert into a 4 node so i need to go down the tree and promote one key from a 4 node to its parent, and relink the children
13:05:26 <Animosity> thus im pattern checking for a 4 node
13:05:49 <Animosity> but i'd rather not type the full 4 node pattern every time, so im searching for a way to replace that with some kind of #define or something
13:05:57 <Binkley> http://paste.lisp.org/display/29059#1
13:06:08 <emu> either use records, or define some more constructors
13:06:24 <Binkley> yeah, I'd suggest using more constructors, really
13:06:36 <Binkley> what I wrote there will work, but this isn't the best way to define a datatype
13:06:36 <Baughn> Animosity: How about data T234 a = Empty | Node [T234 a] [a]
13:06:38 <emu> using the (crappy) CPP is a real desperate thing
13:06:49 <ropine> what Baughn said
13:07:10 <emu> or two data types
13:07:14 <emu> mutually recursive
13:07:19 <Animosity> Baughn that looks all simple but how do i do the quicksearch?
13:07:49 <Animosity> i'll have to know the length of the list, and then....how do i know how many guards to use
13:08:02 <fons> I have  a type data Signal a = NullS | a :- Signal a,  which is isomorphic to a List, Is there a fast way to translate from a list to Signal? (appart from the obvious one)
13:08:04 <Animosity> blah im haskell newb btw
13:08:20 <emu> data Node a = Two (Tree a, a, Tree a, a) | Three ...
13:08:32 <fons> maybe wrking with the internal representation of the compiler?
13:08:41 <emu> data Tree a = Empty | Node (Node a)
13:09:40 <emu> then you can match on: Node _ | Node (Two _) | Node (Two (a,b,c,d))
13:09:47 <emu> or whatever
13:10:22 <Animosity> i see
13:10:39 <Binkley> fons: not really. Why not just use a list instead? :-)
13:11:13 <fons> Binkley, cuase that is the representation used by a whole library
13:11:20 <Binkley> ah
13:11:21 <fons> (which I'm going to use)
13:11:29 <Binkley> well, writing a signal-to-list function shouldn't be too hard, right?
13:11:44 <fons> Binkley, no, of course not :P
13:11:59 <int-e> > case Nothing of Just {} -> True; Nothing -> False
13:12:00 <lambdabot>  False
13:12:04 <Binkley> the obvious way would be two lines; you can't get much faster than that :-)
13:12:20 <emu> @type {}
13:12:21 <lambdabot> parse error on input `{'
13:12:21 <fons> Binkley, I just though that is highly probable that the compiler would represent both types internally in a really similar way
13:12:22 <int-e> emu: you can use record syntax for matching anyway - Node {} will work.
13:12:25 <Binkley> fons: no
13:12:28 <fons> thought*
13:12:33 <emu> @type Node {}
13:12:34 <lambdabot> forall a. Tree a
13:12:52 <int-e> @index Tree
13:12:52 <lambdabot> Data.Tree, Data.Graph
13:13:32 <Binkley> and even if it did, you don't want to be thinking about how the compiler represents things
13:13:37 <Binkley> why use a compiler if you do?
13:13:51 <fons> BTW I'm happy to announce that the first LADSPA plugin written in haskell works!
13:13:55 <fons> :)
13:14:01 <Heffalump> fons: if you're feeling brave, see if unsafeCoerce# works :-)
13:14:09 <Binkley> shush, you :-)
13:14:09 <emu> "-- you can get a Ph.D for explaining the true meaning of the last construct" <-- in the defn of the ghc HsSyn abstract syntax tree data type
13:14:11 <Heffalump> but don't come crying to us if it breaks randomly
13:14:28 <Binkley> so what kind of plugin are you writing?
13:14:33 <fons> Binkley, to make things run fasttttt
13:14:43 <Binkley> fons: then use CCCCCCCCCCCCCCCCC :-)
13:14:52 <Heffalump> fons: also, make sure that your conversion functions use foldr and build appropriately
13:15:04 <fons> Binkley, hahahah :) well, why do people use arrays in haskell then?
13:15:13 <Binkley> fons: i don't know. I don't use them :-)
13:15:23 <fons> Binkley, when lists are so at hand and easy to use
13:15:45 <Heffalump> lists don't have a nice "nth place" update operation
13:15:45 <emu> and FiniteMaps !
13:15:52 <Heffalump> though I guess one is easy to write
13:16:32 <fons> Heffalump, yep, an effeciency issue then
13:16:35 <pejo> fons, while lists are nice, there might be compelling reasons to use a different data structure, just like in any other language.
13:16:51 <Baughn> Animosity: There's no reason to treat a two-node and three-node differently when /adding/ stuff, and similarly for removing.. actually, such code could easily generalise to N-trees
13:17:06 <Binkley> using the right data structure for the job isn't the same as trying to grovel around in compiler intermediate representations
13:17:06 <fons> pejo, I know, the question was retoric, efficiency is important
13:17:15 <Baughn> Animosity: Though you might want a cache of the list length for large values of N. ;)
13:17:17 <Binkley> often, the obvious thing to do is right
13:17:40 <fons> Heffalump, I'll have a look at unsafeCoerce#
13:17:52 <Binkley> fons: no, really, please don't
13:18:02 * Heffalump repeats his point about bravery and not complaining, quite strongly
13:18:08 <Baughn> Animosity: And your quicksearch, of course, could treat all three kinds of nodes identically
13:18:11 <Binkley> we try not to talk about that
13:18:14 <Heffalump> but if the internal representations are the same, it ought to work
13:18:46 <Heffalump> Binkley: do you object to unsafeCoerce# to convert between two types which are identical apart from a different phantom type parameter?
13:18:46 <emu> the other thing to do is have a data NodeType = Two | Three | Four and make NodeType part of the Node definition.  you'll have to enforce the n-ary constraints yourself
13:19:01 <fons> http://www.cse.unsw.edu.au/~dons/crawl/crawl.hs
13:19:02 <lambdabot> http://tinyurl.com/yjln88
13:19:03 <Binkley> Heffalump: no, but I don't see how you can assume that fons's data type and lists are going to have the same representation
13:19:20 <Binkley> and even if they did, why not just write the two-line toList function?
13:19:24 <Binkley> premature optimization is the devil
13:19:28 <Philippa_> Heffalump: I'd say it's a bad thing unless you really really /have/ to
13:19:42 <fons> Binkley, Its efficiency
13:19:45 <Heffalump> I'm just providing the answer to the question being asked, with appropriate caveats.
13:19:54 <Heffalump> rather than lying or providing a long lecture :-)
13:20:02 <fons> Binkley, I see your point
13:20:05 <Binkley> well, my answer is to bite the bullet and you'll probably find it quite tasty, to coin a phrase
13:20:05 <Heffalump> Philippa_: the phantom types thing?
13:20:20 <SamB> Binkley: which one is the bullet?
13:20:29 <Binkley> SamB: writing the two-line signal-to-list function
13:20:32 <Philippa_> Heffalump: yeah
13:20:47 <Binkley> fons: don't worry about efficiency until you know where your bottlenecks are
13:21:00 <Heffalump> if so, we do it in the darcs GADT stuff. In principle we could deconstruct and reconstruct the values, but we don't see the point.
13:21:02 <Binkley> have you compiled with profiling on yet?
13:21:04 <fons> Binkley, that is going to be one
13:21:09 <fons> here is the problem
13:21:27 <fons> I'm writing an audo plugin library in haskell
13:21:28 <Heffalump> Binkley: but knowing that certain things will be implemented efficiently or not sometimes influences choice of coding techniques or algorithms
13:21:39 <fons> (LADSPA port)
13:21:47 <CosmicRay> Igloo: still here?
13:21:47 <Heffalump> a blanket "write the code then optimise it" attitude is too simplistic
13:22:11 <fons> I want to keep two flavours, using lists and Storable arrays as IO buffers
13:22:20 <fons> each one has its adavantages
13:22:23 <Binkley> Heffalump: but it takes time to get an intuition for what things are going to be implemented efficiently
13:23:06 <Heffalump> well, fons seems to be trying to understand that
13:23:18 <fons> and at the same time I want to use LADSPA as a tool to demostrate how ForSyDe works (http://www.imit.kth.se/info/FOFU/ForSyDe/ )
13:23:20 <lambdabot> Title: ForSyDe
13:23:28 <Philippa_> Heffalump: I figure you guys know when you "really really have to"
13:23:37 <fons> ForSyDe uses the signal type I typed
13:24:10 <Binkley> Heffalump: I think that using folds/builds, like you suggested, would be better
13:24:19 <Philippa_> and really what I'd had in mind is workarounds that only need to reconstruct one value at most
13:24:24 <Binkley> although using build is still worrying more than one should have to about how the compiler works
13:24:36 <Binkley> but until I finish my type-based deforestation implementation, I shouldn't complain about that
13:24:52 <Heffalump> Binkley: foldr/build fusion will only get some of the way
13:25:45 <Philippa_> tbh what'd be nicer is a way to declare valid casts in the type (and preferably hide them from export)
13:26:15 <Philippa_> which would previously have translated into unsafeCoerce# and now into the relevant declarations in FC
13:26:25 <fons> of course I will make the two-liner first and then try how is all improved by making a fast conversion (unsafecoerce# or whatever is required)
13:26:37 <Heffalump> fons that sounds like a good plan
13:26:41 <Binkley> yeah, I agree
13:26:44 <Heffalump> but if unsafeCoerce# doesn't work there's basically nothing you can do
13:26:47 <Igloo> CosmicRay: Yes
13:26:57 <Heffalump> well, perhaps you could add some clever rules, but I can't quite see how
13:27:01 <Binkley> heffalump: sure there's something he can do...use the FFI
13:27:17 <Heffalump> Binkley: if unsafeCoerce# doesn't work, the representations aren't the same. So then he's stuffed.
13:27:32 <Binkley> Heffalump: you can write some C code that'll do whatever you want with the underlying representation
13:27:36 <Heffalump> short of persuading the compiler to actually implement his streams as lists
13:27:45 <Binkley> of course, if GHC changes its representations for things, you're made love to the regular way.
13:27:46 <Heffalump> Binkley: yes, but that won't solve the linear time cost of changing it
13:28:10 <Animosity> is there any built in way in haskell to reference the parent of a tree node?
13:28:13 <fons> actually is a 1liner "foldr Nulls :-"
13:28:15 <Heffalump> Animosity: no
13:28:20 <Animosity> thank you
13:28:24 <Heffalump> Animosity: though have you seen the "zipper" data structure?
13:28:31 <Animosity> i havent
13:28:36 <Heffalump> ok, try googling for it
13:28:47 <Animosity> will do, thanks Heffalump
13:28:52 <Philippa_> in this case using the FFI sounds rather like masturbating with a running chainsaw
13:28:55 <Heffalump> actually, hangon, the google results are unhelpful
13:29:05 <Heffalump> http://www.haskell.org/haskellwiki/Zipper looks good though
13:29:06 <Philippa_> I'm sure you can all find your own punchlines for that
13:29:07 <lambdabot> Title: Zipper - HaskellWiki
13:29:08 <Binkley> Philippa_: your kink is OK
13:29:15 <Binkley> where "your" is rhetorical
13:29:19 <Animosity> thank you sir
13:29:21 * ski did "pointer-reversal" for accessing parent nodes, recently
13:29:45 <CosmicRay> Igloo: Is there not a ./setup command that can do the right thing?
13:30:44 <CosmicRay> Igloo: I am also puzzled as to why this is happening on this one package only; my debian/ is pretty much the same across all of my haskell packages
13:32:04 <Igloo> CosmicRay: Yes, I messaged it to you
13:34:59 <SamB> hmm.
13:35:25 <SamB> -v4 is an *awful* lot more verbose than -v3
13:35:40 <Binkley> SamB: for a good time, try -v5
13:36:03 <SamB> no thanks, that one would most likely *actually* take forever
13:36:44 <Binkley> SamB: it doesn't usually *actually* take foever
13:36:47 <Binkley> just most of forever
13:37:08 <Binkley> Actually I don't know offhand what the difference between -v4 and -v5 is
13:37:15 <Binkley> I usually just use -v5.
13:37:23 <SamB> well, consider running it that way under emacs with only 256 MB of RAM. On the readline module.
13:37:35 <Binkley> SamB: that's what redirecting to a file is for
13:37:41 <lispy> from my experimenting, -v3 to -v4 was a big jump, but after that i noticed little or no difference
13:39:51 <chessguy> ok, what's the joke
13:40:07 <chessguy> all of a sudden i'm seeing good places to apply lambda functions explicitly everywhere
13:41:32 <chessguy> nobody's talking, eh?
13:42:09 <Binkley> I think Philippa stopped the conversation pretty well :-)
13:42:19 * chessguy finds the closest large object and gives Philippa a slap with it
13:42:56 <Philippa_> ...it's a good thing this isn't -blah or you wouldn't like my reply :-)
13:43:25 <Binkley> chessguy: that's not necessarily going to discourage her
13:44:08 <SamB> I don't think that -v4 should be showing code, personally...
13:44:13 <SamB> -v3 shows so little
13:44:23 <SamB> showing names of code, maybe.
13:44:31 <Binkley> what do you mean by showing code?
13:44:56 <Binkley> I mean...
13:45:02 <Binkley> there's not a lot else that it *would* show.
13:45:11 <SamB> well, have you tried -v3?
13:45:33 <SamB> it doesn't take much imagination to imagine more than -v3 and less than -v4, trust me
13:45:48 <Binkley> true, -v3 doesn't show much
13:46:00 <Binkley> i can see it being useful if the compiler is hanging up somewhere -- you can at least narrow down what phase it's in
13:46:01 <mathewm> any djinn gurus here?
13:46:18 <Philippa_> is there a way to get GHC to dump typings, btw?
13:46:26 <Philippa_> that is, the process by which the typechecker reached its result?
13:46:32 <SamB> it is running out of stack, and so I want something between those two
13:46:42 <SamB> mostly because -v4 is taking forever :-(
13:47:03 <SamB> the *process*?
13:47:10 <Binkley> philippa: -ddump-tc?
13:47:12 <SamB> that doesn't sound comprehensible
13:47:26 <Binkley> SamB: how big a stack are you giving it?
13:47:28 <pejo> SamB, ghc -v4 takes forever?
13:48:22 <SamB> pejo: on the module on which I am running it, yes
13:48:53 <pejo> SamB, even if you pipe it to a file?
13:50:09 <SamB> well, okay, not quite
13:51:33 <SamB> hmm, I still don't know where it is running out of stack...
13:51:46 <SamB> oh wait...
13:52:08 <SamB> hmm. apparantly in the middle of printing the external core to the file...
13:52:50 <Philippa_> Binkley: cool, will play with that sometime. Is it stable enough to be worth basing tools around?
13:53:12 <Binkley> Philippa: no. what kind of tools are you thinking of?
13:53:24 <Philippa_> type-level debugger
13:53:42 <Binkley> Philippa: definitely not, it's meant to be human-readable. but look at the existing type-level debugging things and see what they use
13:53:51 <Binkley> well, the answer might be that they hook into GHC (or helium)
13:54:07 <Philippa_> *nod* - I'm not aware of much
13:54:21 <Binkley> I feel like there were a couple of papers on that in ICFP 2003
13:54:26 <Binkley> or possibly Haskell Workshop 2003
13:54:35 <Binkley> btw, n00b question -- how do you add to the lambdabot quotes file?
13:54:36 <Philippa_> you might be thinking type-directed debugging?
13:54:36 <Binkley> anyone?
13:54:52 <Binkley> well, I'm talking about things that try to make type error messages more understandable
13:55:25 <ski> @help remember
13:55:25 <lambdabot> quote <nick>
13:55:26 <lambdabot> remember <nick> <quote>
13:55:26 <lambdabot> Quote somebody, a random person, or save a memorable quote
13:55:31 <Philippa_> ah. I'm thinking about things that show you the entire process and let you trace the dataflow through the inference process, stuff like that
13:55:40 <Binkley> ah, i was trying to use the "quote" command and not "remember"
13:55:40 <Binkley> thnx
13:55:57 <Binkley> http://www.cs.uu.nl/~bastiaan/research.html seems to have quite the bibliography of papers in that area
13:55:59 <lambdabot> Title: Bastiaan Heeren [ Selected Research Papers ]
13:56:00 <Binkley> don't reinvent the wheel :-)
13:56:15 <Philippa_> yeah, I've read 'em. Different task
13:56:28 <Philippa_> Bastiaan's aiming at newbie tools, I'm thinking about ones Oleg might use
13:56:56 <Binkley> Ah ok
13:57:13 <Binkley> so the papers you read didn't say anything about the implementation mechanisms they were using?
13:57:29 <Philippa_> they were reimplementing the typechecker
13:58:51 <Binkley> then the answer might be for you to hack GHC to spit out something you can use
14:00:17 <pejo> Philippa_, are you trying to trace the type inference process?
14:02:39 <pejo> (Without messing with GHC internals?)
14:03:24 <fons> Heffalump, how about cast from Data.Typeable?
14:03:37 <Heffalump> fons: doesn't that return a Maybe result?
14:03:52 <Binkley> fons: that's better, but don't you still  have to declare appropriate instances?
14:04:05 <Heffalump> I don't think cast works unless the dynamic types turn out to be the same, does it?
14:04:29 <fons> I'm checking it now
14:04:50 <Heffalump> I think it would just return Nothing.
14:04:59 <Philippa_> pejo: not right this moment, but that's the idea
14:05:06 <fons> Binkley, didn't ghc accept using deriving with typable?
14:05:20 <Philippa_> messing with internals to provide a logging infrastructure'd work for me though so long as it was maintained
14:05:31 <Philippa_> I should go AFK though
14:09:36 <Binkley> fons: yeah, maybe that could work... if you're using a recent version
14:09:38 <ptolomy> Have any #haskell t-shirts been submitted yet?
14:09:50 <Binkley> Philippa: if you want it to be maintained, the best option is to be the maintainer :-)
14:09:51 <fons> Binkley, checking it now
14:09:55 * Heffalump is still convinced that casting a signal to a list and vice-versa will just return Nothing.
14:11:09 <fons> *Signal> cast [1.0] :: Maybe (Signal Float)
14:11:09 <fons> Nothing
14:11:13 <fons> :(((
14:11:30 <Binkley> fons, what version of ghc are you using?
14:11:38 <fons> 6.6
14:11:46 <Heffalump> oh, actually, you might be able to cheat and make a Typeable instance that copies that for List.
14:11:47 <Binkley> I'm not sure if the derivable-typeclasses stuff for Typeable is in GHC or just on paper at this point
14:11:53 <Heffalump> But then I bet it uses unsafeCoerce#
14:11:58 <Binkley> or even if it is, whether it applies in this case
14:12:03 <Heffalump> Binkley: DYM "deriving Typeable"?
14:12:11 <Binkley> Heffalump: yes
14:12:20 <fons> Binkley, it is in GHC, just used it
14:12:22 <Heffalump> that's been in GHC for ages, but it just does what you'd expect, which is to produce a different TypeRep from the List type.
14:12:37 <Heffalump> at least, that's what I'd expect, given that TypeReps name constructors.
14:12:53 <Binkley> well, ok. sure. there's no reason it should *know* that some arbitary type is isomorphic to lists
14:13:12 <Heffalump> especially since the underlying representation may or may not be the same
14:13:16 <Binkley> right
14:13:27 <Heffalump> and I bet cast does do an unsafeCoerce# or moral equivalent under the hood.
14:13:29 <Binkley> isomorphic inside your head isn't the same thing as isomorphic inside the compiler
14:13:31 <Heffalump> I can't see what else it could do.
14:13:40 <SamB> cast is safe
14:13:44 <SamB> oh, wait.
14:13:51 <Heffalump> SamB: if your TypeReps are reasonable
14:13:58 <SamB> you are talking about Data.Dynamic, not cast expressions in Core. oops.
14:14:02 <Binkley> yes
14:14:20 * Heffalump would expect it to be implemented as cast a = if typeRep a == typeRep returntype then Just (unsafeCoerce# a) else Nothing
14:14:25 <Heffalump> or moral equivalent thereof
14:14:56 <Heffalump> anyway. I'm going to bed.
14:15:12 <Binkley> ni
14:18:36 <fons> in what module is unsafeCoerce?
14:19:18 <Binkley> i think you'll need -fglasgow-exts
14:19:43 <Heffalump> really? It has a nice simple type.
14:19:49 <Heffalump> I'd expect it to be in some .Unsafe module
14:19:54 <fons> Binkley, well. I should import it from somewhere as well I guess
14:19:57 <Binkley> yeah, but unsafeCoerce isn't Haskell98...
14:20:00 <Binkley> or at least I hope not!
14:20:13 <Binkley> nope, it's not
14:20:16 <Heffalump> Binkley: well, neither are a lot of things
14:20:34 <Heffalump> but I don't think you need -fglasgow-exts in clients of those things unless the types make that necessary
14:20:43 <keroppi> Right.
14:20:44 <Heffalump> I don't even think you need it to _use_ ST, though I could be wrong
14:21:32 <SamB> of course you do. you can't use ST without that damn forall!
14:21:44 <Binkley> ok, it's in Data.Dynamic
14:22:17 <Baughn> I don't really see the point of having forall if there /isn't an alternative/
14:22:30 <SamB> Baughn: huh?
14:23:01 <SamB> the point of that forall there is... um... oh, so that GHC doesn't assume anything about the type of that field?
14:23:43 <Baughn> SamB: As was pointed out to me yesterday, Haskell behaves exactly the same regardless of whether or not you use forall - the forall being implicit, apparently
14:23:57 <Baughn> SamB: There's supposed to be an "exists" as well, but there's not, so..
14:24:26 <SamB> Baughn: those are only for foralls right after the :: of a global name
14:25:02 <SamB> the only reason for foralls is higher-rank polymorphism
14:25:04 <ski> (and GADT constructors)
14:25:23 <Baughn> SamB: I see. I suppose I'll get to that eventually, then.
14:26:00 <SamB> oh, and I think they affect lexical scoping of type variables now too
14:26:40 <SamB> like, you need a forall to get lexical scoping on a type variable
14:27:54 <ski> (which is slightly strange)
14:28:24 <SamB> I think it is meant to keep h98 code working properly?
14:28:37 <ski> probably it's something like that, yes
14:29:06 <SamB> on the off chance that scoped type variables might somehow break some h98 code
14:29:48 <ski> well, local values with polymorphic type signature could be interpreted as monomorphic, i think
14:30:06 <SamB> yes, but those are exceeding rare, I'd think
14:30:13 <SamB> considering the lack of scoped type variables
14:30:13 <ski> which ?
14:30:25 <SamB> the local values with polymorphic type signatures
14:30:37 <SamB> also the lack of higher-rank types
14:31:20 <musasabi> getting haskell-prime done without all the new things that have not been tested would be good.
14:31:49 <musasabi> just getting more existing code to be standards conformant would be very nice.
14:31:53 <SamB> what is the current plan for the MTL?
14:31:56 <fons> well, unsafeCorece seems to work
14:32:07 <fons> not gonna use it by now
14:32:13 <SamB> as far as I'm concerned, you almost might as well not have Haskell' without the MTL
14:32:50 <musasabi> SamB: using mtl or being able to compile mtl?
14:32:51 <fons> BTW, why checking its results is not enough?
14:33:16 <SamB> being able to write an MTL using the typesystem provided by Haskell'
14:33:27 <fons> let l = [1,2,3] :: [Int] in unsafeCoerce#  l :: Signal Int
14:33:33 <fons> {1,2,3}
14:33:38 <Binkley> fons: well, you could ask why writing well-behaved code in a dynamically checked language isn't enough :-)
14:33:43 <musasabi> getting MPTC into Haskell' is hard but there is a very clear need.
14:33:47 <SamB> so, you basically either need fundeps or AT synonyms
14:33:50 <fons> let l = [] :: [Int] in unsafeCoerce#  l :: Signal Int
14:34:01 <fons> {}
14:34:02 <musasabi> SamB: the problem is that the fundep story has not been very stable.
14:34:03 <SamB> and AT synonyms aren't even implemented in GHC yet
14:34:17 <musasabi> and ATs are very unstable in 6.7
14:34:30 <SamB> 6.7 is barely begun, though
14:34:45 <SamB> and part of that is probably because ATs aren't totally implemented
14:34:52 <SamB> don't you think?
14:35:07 <musasabi> probably.
14:35:55 <musasabi> In my opinion getting a conservative Haskell' out and then focusing on standardising innovative things (like GADT + MPTC + AT/FD) makes most sense.
14:36:10 <SamB> hmm.
14:36:38 <mathewm> any pointers on constraint programming in haskell?
14:36:44 <SamB> so what does that give me over H98 + heirarchical names + FFI?
14:37:13 <dcoutts> @yarr!
14:37:13 <lambdabot> Splice the Mainbrace!
14:37:13 <musasabi> SamB: e.g. "instance Foo String where", higher ranked types, "forall" etc
14:37:20 <SamB> ah.
14:37:20 <Binkley> mathewm: use Mercury?
14:37:29 <SamB> so basically the obvious things we always forget aren't H98?
14:37:34 <SamB> hey wait.
14:37:37 <mathewm> Binkley: I will take a look
14:37:41 <SamB> Foo String isn't obvious.
14:37:41 <dcoutts> dons, Igloo, I can indeed book a room in the comlab. So when we have more details I can go do that.
14:38:02 <musasabi> those things that are known to work.
14:38:03 <Binkley> I haven't really used it, but it seems basically like a hybrid of Haskell and logic programming, with constraints bundled along as part of the latter
14:38:26 <ski> constraints are still somewhat experimental in mercury
14:38:29 <musasabi> I don't there is *any* stable haskell compiler release with a good story for fundeps.
14:38:44 <dcoutts> Igloo, we can use the medium-sized room next to the library. It's got lots of desks we can move about and a white board and we can probably arrange ethernet (but not wireless).
14:38:45 <Binkley> true... I don't think there's a constraint language that *isn't* experimental, though
14:38:49 <Binkley> or if there is, I'd like to know about it
14:39:41 <musasabi> SamB: which is why I don't personally like 1) standardizing something erroneous, 2) waiting a year.
14:40:34 <musasabi> of course the most recent papers look very good and may be the real answers.
14:41:45 <SamB> musasabi: yeah.
14:42:02 <Igloo> dcoutts: Ah, cool!
14:47:41 <SamB> we should have a process by which to figure out the goals of standardization
14:48:07 <Binkley> and then you should have guidelines for that process
14:48:10 <SamB> which *doesn't* involve write access to the Haskell' Trac
14:48:18 <Binkley> and then some rules for maintaining the guidelines
14:48:25 <SamB> no, silly
14:49:30 <musasabi> SamB: I think one of the guidelines is *implemented in existing compiler*.
14:49:38 <SamB> yes, that is a guideline
14:49:40 <SamB> but
14:49:48 <musasabi> of course everyone seems just to be pushing their favorite new extensions.
14:49:52 <SamB> do they have real guidelines for how long to wait?
14:50:28 <SamB> and some of the proposed changes on that wiki are just plain ridiculous
14:50:55 <musasabi> like the lambda-case people to pick up an example - I don't have a technical opinion whether that is good or bad - just that I think new features are better understood after they have been in compilers for some time.
14:51:02 <mathewm> why doesn't djinn instantiate polymorphic functions?  is it hard/impossible?
14:51:10 <keroppi> I am very conservative and I would just propose/accept a subset of GHC extensions for Haskell' for example.
14:52:38 <SamB> we should have a Wiki page for saying what, out of the things GHC implements, you want in haskell' standard, and what you don't want...
14:52:55 <keroppi> Associated types may be an exception.  I think it's worth a favour.
14:53:42 <SamB> like, it would be a list of extensions...
14:54:04 <SamB> categorized by manual section, I suppose
14:55:06 <metaperl> any OS X haskellers here?
14:55:11 <musasabi> keroppi: AT seems very nice. But would it not be better to make an appendix for them later? when they have been used more.
14:55:28 <Baughn> metaperl: Sort of. Kinda. What about it?
14:55:34 <keroppi> That is proper procedure, yes.
14:55:35 <mathewm> metaperl: me
14:55:37 <metaperl> I need ghc 6
14:55:50 <mathewm> metaperl: try port ?
14:55:52 <metaperl> the binary provided has some opendarwin deps
14:55:58 <metaperl> mathewm: what d o you mean?
14:56:12 <metaperl> compiling from source is simply not possible
14:56:15 <mathewm> metaperl: darwin ports (macports now, I think)
14:56:21 <Baughn> metaperl: It does? Works fine here - mactel, mind
14:56:26 <keroppi> I just feel kind of regret that the timing is somewhat unfortunate for AT.
14:56:33 <mathewm> metaperl: what version of OS X?
14:56:36 <SamB> and you'd put your wiki username in one of two lists depending on whether you felt it should be included, felt it should be excluded, or didn't really care
14:56:42 <metaperl> i have intel based macbook pro on 10.4.8
14:56:55 <metaperl> Baughn: where did you download?
14:57:20 <SamB> and hopefully everyone would agree
14:57:41 <SamB> and if there was dissent it could go to the Talk: page
14:57:44 <Baughn> metaperl: I downloaded ghc-6.5-20060915.tar.bz2, but am currently running the darcs version of ghc (which compiled fine, except the OpenGL package)
14:57:46 <keroppi> "mod up/down this proposal"?  XD
14:58:05 <SamB> keroppi: basically
14:58:05 <metaperl> Baughn:  you need ghc5 to compile ghc6
14:58:13 <metaperl> and you need ghc4 to compile ghc5
14:58:26 <Baughn> metaperl: ghc6 will compile ghc6 just fine, as it turns out
14:58:31 <SamB> silence would be taken to imply non-consent
14:58:36 <keroppi> (Fictional)  <dons> Please come over haskellprime.org to mod up AT!  XD
14:58:47 <mathewm> metaperl: ghc-6 can be build with any ghc from 6.0.4, or something like that
14:58:47 <SamB> what should such a page be called?
14:58:57 <SamB> no, this can't be at haskellprime.org
14:58:58 <keroppi> haskellprime.reddit.com?  XD
14:59:10 <SamB> this would be on:
14:59:12 <SamB> @wiki
14:59:12 <lambdabot> http://www.haskell.org/haskellwiki/
14:59:20 <metaperl> Ok, but what if you have no haskell... except hugs... wha can you do to build OS X ghc6 ?
14:59:22 <emu> wasnt reddit just purchaed
14:59:34 <Baughn> metaperl: Download the binary, install that, then build ghc6
14:59:48 <SamB> metaperl: same as every other platform
15:00:04 <mathewm> metaperl: I spent many hours attempting to bootstrap my own GHC from C - being the purist
15:00:09 <SamB> now, my question is what should the page be called?
15:00:17 <mathewm> metaperl: it isn't easy - just grab a binary
15:00:23 <metaperl> oh
15:00:29 <metaperl> why is hugs so easy to get?
15:00:45 <mathewm> metaperl: implementation decisions?
15:00:46 <keroppi> because everyone wants hug
15:00:50 <metaperl> lol
15:00:51 <metaperl> :)
15:01:01 <SamB> probably because hugs is written in C?
15:01:20 <keroppi> GHC is no longer written to boot from C.
15:01:54 <keroppi> I mean it can still be done on your own, but no one is streamlining it in the source anymore.
15:01:59 <mathewm> With Mac OS X's rosetta, I bet it would be possible to bootstrap from a PPC build of GHC
15:02:24 <SamB> keroppi: what do you think I should call this wiki page?
15:02:30 <Binkley> I find hugs aren't really that easy to get ;.(
15:02:39 <SamB> Haskell prime feature survey?
15:02:56 <Baughn> mathewm: ..oddly enough, that is so. Oddly because Rosetta breaks sigsegv (and other signals)
15:02:59 <SamB> Haskell prime survey?
15:03:20 <keroppi> Perhaps.  I have no good idea.
15:03:26 <mathewm> Baughn: didn't know that - but is segv a critical part of GHC ;)_
15:03:29 <SamB> ah well.
15:03:38 <SamB> I think mediawiki has decent page-moving support anyway.
15:04:06 <Baughn> mathewm: It's a critical part of most GCs, especially if you use threading. Though come to think of it, I suppose the compilation process /doesn't/, so it might just be by chance
15:04:10 <keroppi> OK how does it work?  An interested person adds an edit that says "I
15:04:19 <keroppi> 'm for AT" or "I'm against AT"?
15:04:52 <mathewm> so why does rosetta break segv?
15:04:53 <SamB> no, I'm going to put in a list of extensions from the GHC manual, then I'm going to have smarter people subdivide the list...
15:04:57 <Baughn> mathewm: That is - Rosetta leaves EIP, the exact fault location and some other registers as garbage in the signal context, which breaks read/write barriers
15:05:52 <Baughn> mathewm: It does make sense, though; translating backwards from the recompiled x86 code would be a heroic feat indeed
15:06:08 <mathewm> Baughn: ah, interesting
15:06:23 <mathewm> Baughn: I suppose EIP gets a little funny with code-translation
15:06:30 <musasabi> SamB: I think the sensible way would be to talk to the haskell-prime people, they are working hard and doing work behind backs of people is not a good way of advancing things.
15:07:02 <keroppi> Yeah
15:07:27 <SamB> musasabi: hmm. well, can't they just postpone the other stuff until haskell''?
15:07:40 <SamB> which will be haskell' when the first one is done?
15:07:54 <Baughn> mathewm: Whether that actually breaks anything or not depends on the exact GC strategy, and it seems perfectly plausible in retrospect that GHC might just not /use/ that register - I was surprised because SBCL doesn't even start under rosetta
15:08:21 <Baughn> mathewm: But it does mean there's still some performance to be squeezed from it
15:08:43 <SamB> I don't think GHC does anything special for segfaults, no...
15:08:50 <keroppi> You can still bring the suggestion "let's try to be conservative" to the haskell-prime people.
15:08:52 <SamB> I think it just tries to avoid them
15:08:55 <mathewm> Baughn: Interesting - I was just about to try PPC SBCL under it last night. Glad I decided against it ;)
15:09:10 <Baughn> SamB: So a GC stops /every/ thread until it's done?
15:09:14 <SamB> keroppi: true
15:10:01 <musasabi> Baughn: there is work on a concurrent GC, but at the moment it stops the world.
15:10:57 <Baughn> musasabi: With read-write barriers then, I guess. Is it remotely reasonable to keep the old one around for this sort of case?
15:10:58 <SamB> I believe the "concurrency" in question would just involve having every thread run the GC, though
15:11:37 <SamB> or in GHC RTS terminology, every "capability"
15:12:22 <SamB> i.e. CPU
15:12:47 <fik> @where MTL
15:12:48 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
15:12:53 <Baughn> That should still speed things up a bit, and even more so once x86 becomes a NUMA architecture..
15:13:01 <musasabi> concurrent GC = less stops for a given thread but usually slower on a uniprocessor.
15:13:35 * Baughn doesn't have one of those. Go right ahead.
15:14:19 <SamB> also a lot *harder* to implement
15:14:53 <Baughn> I'll... order pizza for you?
15:15:20 <SamB> I ... don't know how to implement that anyway?
15:15:29 <SamB> even remotely?
15:15:56 <keroppi> pizza can be ordered and also GCed remotely
15:16:39 <Baughn> Actually, that might not be a bad idea for the haskell hackathon. An feed-the-developers program.
15:16:44 <SamB> no! it may not be GCed!
15:16:52 <SamB> instead, simply allow me to eat it!
15:17:04 <Baughn> "Order pizza" is a lot more concrete than "donate to an unknown-purpose pot". ;)
15:17:46 <keroppi> SamB you're the GCer of pizza.
15:18:01 <SamB> oh, unless it is moldy.
15:18:15 <SamB> in that case just throw it in the garbage and let it be GCed
15:18:37 <Baughn> You mean you don't leave it around to experiment on?
15:27:02 <fik> what does "AT" stands for in "GADT, MPTC and AT/FD"?
15:27:28 <twanvl> Associated Types
15:35:10 * psnl wonders if there is a good way to pause a thread in haskell for a time period
15:35:21 <SamB> with AT synonyms, I think we will be able to rewrite the MTL without MPTCs or fundeps
15:36:24 <Baughn> @hoogle Int -> IO ()
15:36:25 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
15:36:25 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
15:36:25 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
15:36:44 <Baughn> psnl: threadDelay looks appropriate
15:37:05 <psnl> having just tried threadDelay, it doesn't quite do what I want
15:37:39 <fik> samb, why are you rewriting MTL?
15:37:47 <Baughn> psnl: How so?
15:38:59 * fik afk
15:40:09 <psnl> Baughn: threadDelay 10 \n putStrLn "hello" never seems to print anything, for example
15:41:27 <Baughn> psnl: Can I assume those lines are in a do-block that eventually gets executed?
15:41:27 <psnl> Baughn: my guess is that the problem lies with this line from the docs "There is no guarantee that the thread will be rescheduled promptly when the delay has expired"
15:41:35 <psnl> Baughn: yes
15:42:00 <Baughn> psnl: So, 'main = (threadDelay 10) >> (putStrLn "hi there")' does nothing at all?
15:42:08 <Baughn> psnl: Does it hang, or just exit?
15:42:46 <SamB> fik: I'm not *yet*
15:43:25 <SamB> well, I started on MonadError before I found out that AT syns weren't implemented yet
15:43:43 <musasabi> psnl: you are aware that the program exits as soon as the main thread is finished?
15:44:59 <psnl> musasabi: yes
15:45:38 <psnl> Baughn: that works, though since the threadDelay isn't in main in my code, I'm looking at that case now
15:46:33 <mbishop> Reddit is dead, we need a new social bookmarking site :/
15:46:43 <mbishop> s/bookmarking/networking/
15:47:06 <dcoutts> mbishop, who acquired it ?
15:47:23 <mbishop> dcoutts: Conde Nota or whatever, Wired's parent company
15:47:32 <dcoutts> hrm
15:47:56 <dons> yeah, i reckon we could roll our own, and have a puzzle as a barrier to being allowed to vote
15:48:15 <dons> which would keep the content LtU-level, but with the dynamism of reddit
15:48:19 <mbishop> heddit, the haskell reddit? :P
15:48:19 <dcoutts> heh heh
15:49:01 <dons> i.e. "Infer the H-M type for this expression" or something :)
15:49:15 <dons> a CAPTCHA for idiots ;)
15:49:41 <dons> ?users
15:49:42 <lambdabot> Maximum users seen in #haskell: 265, currently: 249 (94.0%), active: 33 (13.3%)
15:49:47 <dons> whoa!
15:51:00 <mbishop> me and a friend are thinking of creating a new site for social networking, nothing but xhtml and css heh
15:51:16 <mbishop> not even pictures, simple voting and comments, might end up somewhat useful :P
15:52:43 <Baughn> You will, of course, program it in assembler
15:55:07 <SamB> if by assembler you mean System FC ;-P
15:56:58 <dons> anyone want to place bets on when this channel reaches 300?
15:57:04 <dons> (we hit 200 this time last year, iirc)
15:57:47 * dcoutts bets on Autumn 2007
15:57:56 <dcoutts> beginning of the uni term
15:58:02 <dcoutts> erm, a few weeks in
15:58:10 <dons> when's autumn again? now, or this time next year?
15:58:24 <dcoutts> so, one year from now
15:58:30 * Igloo puts a bet on "while dons is asleep"
15:58:34 <dcoutts> hah
15:58:52 <satan> whats better for working with an infinite list? foldl or foldr?
15:59:00 <Igloo> foldr
15:59:02 <dcoutts> satan, foldr
15:59:02 <dons> Igloo: not if i'm over there.... but i think it will happen within 6 months
15:59:22 <Igloo> true
15:59:31 <satan> ok, how does one write a nested loop over 2 infinite lists with foldr? i know how to do it with map, but that only works for finite lists
15:59:45 <dons> zip ?
15:59:56 <Igloo> What do you want to do?
15:59:57 <dcoutts> or zipWith
16:00:09 <Baughn> satan: Have you read the story about the infinite hotel?
16:00:32 <dcoutts> the Hilbert Hotel
16:00:34 <Baughn> It's.. strangely apropos. I never thought it would actually be /useful/
16:00:42 <satan> take every element of list1, multiply by every element of list2 and create a new list everytime
16:01:02 <SamB> yeah, and the time they had to fit twice as many guests into it even though the hotel was already full?
16:01:17 * dons notes tmoertel's blog has hit reddit too, http://blog.moertel.com/articles/2006/10/31/introductory-haskell-solving-the-sorting-it-out-kata
16:01:21 <lambdabot> Title: Introductory Haskell: Solving the Sorting-It-Out Kata, http://tinyurl.com/y3l23z
16:01:21 <satan> as in, f [1..3] [4..6] should give me [[4,5,6],[8,10,12],[12,15,18]]
16:01:42 <dcoutts> satan, so list2 is not infinite
16:01:48 <satan> but if i call f [1..] [4..] it should still work
16:01:53 <dcoutts> ah ok
16:01:54 <SamB> eh, even if it was he could still get that
16:02:00 <satan> no they are both infinite, my example only works on finites because i use map
16:02:07 <dons> now i'm getting vaguely concerned that haskell is the next ruby now that "rails has peaked" ;)
16:02:07 <SamB> oh really?
16:02:16 <SamB> I bet your prototype will work fine ;-)
16:02:29 <SamB> just don't try to print the output
16:02:30 <satan> Baughn: no, sorry, i havent
16:02:30 <Igloo> dons: :-)
16:02:35 <Baughn> satan: map by itself works fine on infinites, but.. hmm, this one is interesting
16:02:40 <dcoutts> satan, you need to diagonalise I think.
16:02:42 <Igloo> dons: Who says rails has peaked, OOI?
16:02:54 <SamB> dcoutts: to read the output, sure
16:02:57 <satan> dcoutts: diagonalize?
16:03:09 <dcoutts> oh, maybe not
16:03:18 <dcoutts> SamB, yeah, only to read it.
16:03:19 <Igloo> Hmm, I should try to get GADT support into TH again so I can continue work on my rails-a-like
16:03:24 <SamB> satan: your "f" will work fine
16:03:26 <Baughn> satan: Imagine the two arrays as being the topmost row and leftmost column of a 2D table
16:03:44 <satan> ok
16:03:47 <dons> http://bitworking.org/news/Framework_2_0
16:03:49 <lambdabot> Title: Framework 2.0 | 2006-10-30 | BitWorking
16:03:56 <Baughn> satan: "Diagonalise" simply means moving through it on the diagonals - (1,1)(1,2)(2,1)(2,2)(2,3) and so on..
16:04:03 <dons> "Not only is the 'popularity' of Rails declining we are already starting to see the rise of a backlash."
16:04:22 <Pete_I> a backlash against rails?
16:04:28 <dons> yeah. a rails-a-like api would be rather timely at this point.
16:04:39 <satan> SamB: f will work fine? but it doesnt when i call it with f [1..] [2..]
16:04:42 <Pete_I> won't some people fall down the stairs?
16:05:08 <Baughn> Haskell on Hovercrafts?
16:05:16 <Igloo> dons: I have the design of one, partly on disk and partly in my head, but I need to be able to parse GADTs for the code generation
16:05:44 <dons> hmm. GADTs eh?
16:05:58 <Baughn> satan: Anyway.. diagonalisation is a nice general technique for visiting every combination of countably infinite lists, but probably is not necessary here
16:06:01 * Igloo digs it out
16:06:02 <SamB> satan: you HAVE to diagonalize it to *see* that it works fine
16:06:03 <twanvl> > map (take 4) $ take 4     $     map (\x -> map (*x) [1..]) [1..]
16:06:05 <lambdabot>  [[1,2,3,4],[2,4,6,8],[3,6,9,12],[4,8,12,16]]
16:06:23 <dons> interesting, coffeemug's tut from yesterday is officialy the most popular haskell article ever posted to reddit
16:06:30 <Igloo> dons: It doesn't actually use GADT functionality, just as a way to get names into types
16:06:34 <dons> ah ok
16:06:39 <ld106> can anyone explain what the flip function does with an example
16:07:08 <SamB> > map (take 4) (liftM2 (*) [1..] [1..])
16:07:08 <lambdabot>  add an instance declaration for (Num [a])
16:07:11 <SamB> hmm.
16:07:16 <satan> so its not necessary but i have to do it here?
16:07:22 <Baughn> > flip (/) 2 3
16:07:22 <SamB> @type map (take 4) (liftM2 (*) [1..] [1..])
16:07:23 <lambdabot>  1.5
16:07:24 <lambdabot> forall a. (Num [a], Enum [a]) => [[a]]
16:07:30 <dcoutts> [ [ x*y | x <- xs ] | y <- ys ]
16:07:36 <dcoutts> that'll work just fine
16:07:45 <Igloo> dons: e.g. in http://urchin.earth.li/darcs/ian/db/Fish.hs it declares a table called Tank with a primary key column and a column called "name" of type char(32)
16:07:57 <dcoutts> or perhaps I've got xs/ys the wrong way round
16:08:00 <Baughn> ?pl map (take 4) $ take 4     $     map (\x -> map (*x) [1..]) [1..]
16:08:00 <lambdabot> map (take 4) (take 4 (map (flip map [1..] . (*)) [1..]))
16:08:12 <ld106> so flip (/) 2 3 = 3/2
16:08:15 <Igloo> dons: Named name (SizedCharField Char23) is just Char after all the type synonyms are expanded
16:08:31 <SamB> > let xs = [2..]; ys = [3..] in map (take 4) [ x*y | x <- xs , y <- ys ]
16:08:32 <lambdabot>  add an instance declaration for (Num [a])
16:08:32 <lambdabot>   In the result of a list compr...
16:08:42 <Baughn> ld106: Yep. Actually, the type should be sufficient by itself
16:08:44 <twanvl> @pl \xs ys ->  map (\x -> map (*x) xs) ys
16:08:44 <lambdabot> map . flip (map . (*))
16:08:54 <Igloo> Err, IM String
16:09:06 <twanvl> @pl \xs ys ->  map (\x -> map (x*) xs) ys
16:09:06 <lambdabot> map . flip (map . (*))
16:09:16 <dcoutts> > let xs :: [Int]; xs = [2..]; ys = [3..] in take 4 $ map (take 4) [ x*y | x <- xs , y <- ys ]
16:09:17 <lambdabot>  Couldn't match `[a]' against `Int'
16:10:07 <SamB> Baughn: unfortunately...
16:10:14 <SamB> @type undefined :: (a -> b
16:10:15 <lambdabot> parse error (possibly incorrect indentation)
16:10:16 <SamB> erg.
16:10:27 <SamB> @type undefined :: (a -> b -> c) -> b -> a -> c
16:10:28 <lambdabot> (a -> b -> c) -> b -> a -> c :: forall a b c. (a -> b -> c) -> b -> a -> c
16:10:53 <Baughn> SamB: Well, that seems excessive
16:10:55 <Baughn> @type flip
16:10:57 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
16:12:54 <fik> SamB, I did mean: Why do the MTL needs to be rewriten?
16:13:11 <edwardk> fik: coz its probably the most useful thing in haskell? =)
16:13:25 <dibblego> if I have a module (A) that uses functions from another module (B), is it an intended use of CABAL that I Setup.hs install on module B then Setup.hs build on module A should succeed?
16:14:26 <SamB> fik: because fundeps are not favoured for standardization?
16:15:01 <edwardk> oh rewritten
16:15:02 <edwardk> doh
16:15:02 <Igloo> dcoutts: In your configs proposal, is cabal required to take the first choice if it can?
16:15:25 <dcoutts> Igloo, no
16:15:27 <Igloo> dcoutts: With ||, that is
16:15:30 <dcoutts> that's not specified
16:15:33 <SamB> dibblego: um. Cabal builds packages, not modules
16:15:35 <fik> edwardk, right.
16:15:42 <fik> SamB, understand
16:15:45 <dcoutts> Igloo, huh ? ||
16:15:54 <dcoutts> I don't see how it could make a difference
16:16:08 <dibblego> SamB, sorry - replace module with package
16:16:28 <Igloo> dcoutts: It means it might behave differently for no reason under the same conditions
16:16:39 <pzpz> exist any methods in the prelude for timing a script?
16:16:42 <dibblego> "functions from a module that is in a package built by CABAL"
16:17:02 <SamB> dibblego: hmm?
16:17:22 <dibblego> I'm just not sure of the intended use when you have packages depending on each other
16:17:32 <dcoutts> Igloo, the || is only logical or. I don't see any ambiguity there. Where it is under specified is which set of packages cabal should pick. All that is required is that they satisfy the constraints.
16:17:34 <SamB> please write something up on the pasteboard?
16:17:50 <dibblego> do you use Setup.hs install then compile the package that depends on the one you just installed?
16:18:14 <SamB> dibblego: the intention is that, first, Cabal will complain, and second that one program will build dependencies...
16:18:27 <Igloo> dcoutts: Maybe I'm misinterpreting; I'll read it again
16:18:33 <SamB> add a that before the that
16:18:34 <dcoutts> Igloo, eg currently Cabal picks the highest version of each installed version, but with more complex constraints that's not always possible.
16:18:40 <dibblego> SamB, do I tell it where that package's source is so that it can build it?
16:18:48 <SamB> dibblego: no
16:18:57 <dcoutts> Igloo, ask me if you don't grok a bit.
16:19:07 <dibblego> SamB, then how does it build it?
16:19:08 <SamB> the idea is that that nice program would read the info off of a hackage server
16:19:17 <dcoutts> Igloo, I'll try to clarify. I need to turn this into a wiki page too.
16:19:29 <Igloo> dcoutts: It's things like (foo == 1 && bar == 2) || (foo == 2 && bar == 1) that I'm worrying about; am I allowed to say that/
16:19:34 <SamB> I think the program is called "cabal-install"
16:19:52 <dibblego> I have to install a server to have a build dependency?
16:20:24 <SamB> no, you use somebody else's
16:20:32 <SamB> like probably the one on haskell.org, for starters
16:20:41 <dcoutts> Igloo, do you mean 'available(foo == 1)' or 'using(foo == 1)' ?
16:20:50 <SamB> note that this is not necessarily working at the moment
16:20:57 <dcoutts> Igloo, there is no foo == 1 syntax in the condition expressions.
16:20:59 <Igloo> dcoutts: I'll have to reread your message
16:21:20 * Igloo is just trying to get to the end of the thread first  :-)
16:21:23 <dcoutts> Igloo, so it's just predicates and boolean || &&
16:22:12 <dibblego> that's absurd
16:22:40 <dons> ?hoogle CPU
16:22:40 <lambdabot> CPUTime :: module
16:22:40 <lambdabot> CPUTime.cpuTimePrecision :: Integer
16:22:40 <lambdabot> CPUTime.getCPUTime :: IO Integer
16:22:44 <SamB> dibblego: what is absurd?
16:22:54 <SamB> its not more absurd than apt-get!
16:22:55 <dons> pzpz: ^^ also, there's an example on the 'idioms' page of haskell.org
16:23:21 <dibblego> requiring a server (that may not be around) to have a build dependency
16:23:21 <pzpz> dons: ty
16:23:23 <dcoutts> Igloo, so actually that expression (if I understand what you mean by it) is not directly expressible. They're all implications, like if using foo == 1 then build-depends: bar == 2;  if using foo == 2 then build-depends: bar == 1.
16:23:37 <dibblego> when you have the sources to both dependent and dependee
16:23:44 <SamB> dibblego: oh, that isn't required to *have* it
16:23:49 <SamB> just likely to *find* it
16:24:00 <SamB> if you need to you can always do it manually
16:24:05 <dibblego> why can I not to anything locally?
16:24:13 <dibblego> *do
16:24:16 <SamB> or you could run a local hackage server
16:24:47 <dibblego> can't I just point to files on my hard disk?
16:26:29 <SamB> or maybe you could have a local listing in a text file ala /etc/hosts
16:26:45 <SamB> (to compare hackage servers to DNS servers)
16:27:19 <SamB> anyway, you asked what they are for, and I told you some things
16:27:52 <SamB> and if you think you have ideas for more things it would be nice to use them for, thats nice, and you are perfectly free to suggest and/or implement those things ;-)
16:27:55 <dibblego> thanks
16:29:47 <SamB> in any case, it beats having to chase dependencies ten levels deep by *hand*, regardless of 'net connectivity
16:30:01 <Igloo> dcoutts: OK, what I'm missing is what the backtracking discussion is about, I think?
16:31:23 <dcoutts> Igloo, right, that's the least understood thing
16:31:28 <dcoutts> by most of us :-)
16:31:28 <SamB> I've got -fext-core working nicer...
16:31:39 <Igloo> dcoutts: When does it come up, though?
16:31:44 <SamB> or is that -fexternal-core
16:32:00 <dcoutts> Igloo, so the issue is: suppose Cabal starts off by picking the latest versions of all packages...
16:32:17 <Igloo> dcoutts: What do actual build deps look like?
16:32:21 <SamB> ah, it is -fext-core
16:32:43 <dcoutts> Igloo, then it turns out that with those versions the constraints are not satisfied.
16:32:48 <dcoutts> Igloo, ok, an example:
16:33:05 <Igloo> dcoutts: Just    foo >= v    with various choices of op, and all such constraints are anded?
16:33:18 <SamB> @paste away, dcoutts!
16:33:19 <lambdabot> http://paste.lisp.org/new/haskell
16:33:46 <Igloo> dcoutts: If so, cabal should use   head $ filter (all . map satisfies) constraint $ versions_of "foo"   shouldn't it?
16:34:32 <Igloo> IM  head $ filter (all . map satisfies constraints) $ versions_of "foo"
16:35:01 <Igloo> (where the versions are sorted in descending order)
16:35:06 <lisppaste2> dcoutts pasted "example .cabal file with tricky conditional deps" at http://paste.lisp.org/display/29072
16:35:36 <Igloo> dcoutts: Right, so the first thing in the list is 2, which doesn't watisfy all the constraints, so we filter it out
16:35:42 <Igloo> 1 does, so we use that one
16:35:55 <Igloo> I don't see why we'd ever have to backtrack
16:36:55 <lisppaste2> dcoutts annotated #29072 with "trickier example" at http://paste.lisp.org/display/29072#1
16:37:32 <dcoutts> Igloo, so it can depend on what we think we're using now
16:37:50 <dibblego> ?where hackage
16:37:50 <lambdabot> http://hackage.haskell.org/trac/hackage
16:38:16 <Igloo> dcoutts: OK, can you give me an example of why we need using?
16:38:44 <dcoutts> Igloo, configuration: using (base < 2); build-depends: fps-0.8
16:38:56 <Igloo> dcoutts: Couldn't we always replace it with another flag we set based on available?
16:39:05 <dcoutts> Igloo, you certainly can't say: configuration: available (base < 2); build-depends: fps-0.8
16:39:13 <Igloo> OK
16:39:40 <Igloo> dcoutts: OK, I think it should be evaluated top-down then
16:39:43 <dcoutts> Igloo, because I the package builder not you the package author get to decide what packages are available and which ones you're allowed to use.
16:39:53 <Igloo> Oh, but that doesn't help for version numbers
16:40:11 <dcoutts> Igloo, you have to tell me your constraints, then I'll tell you which versions you'll be using.
16:40:11 <musasabi> "configuration: available (base < 2); build-depends: fps-0.8, base < 2" ?
16:42:07 <dcoutts> Igloo, another example of available being the wrong thing is that it is going to be multi-valued. I can have several things available but what's useful for adjusting the build setting is what you're actually using.
16:42:08 <Igloo> available (base >= 2): build-depends: base >= 2
16:42:09 <jgrimes> if I calculate (sqrt 5) in a function, and then map that function over a list, is the value for (sqrt 5) saved between each application of the function?
16:42:17 <Igloo> !available (base >= 2): build-depends: base, fps
16:42:21 <Igloo> would work
16:43:10 <Igloo> dcoutts: Right, rather than using available directly you'd want to set a flag based on available, and that flag could hten be overrideen
16:43:19 <dcoutts> Igloo, yeah, that's fine.
16:43:26 <Igloo> dcoutts: So we can drop using?
16:43:30 <dcoutts> Igloo, no.
16:43:33 <Igloo> Why not?
16:43:41 <musasabi> Igloo: that needs "base < 2" there. for the case where both base-1 and base-2 are installed.
16:43:44 <dcoutts> Igloo, because it's a hard not soft constraint.
16:43:57 <Igloo> musasabi: No it doesn't, in teh second branch base-2 isn't installed
16:44:46 <musasabi> Igloo: those are just defaults - nothing prevents an user of setting them manually.
16:44:52 <dcoutts> exactly
16:45:07 <dcoutts> so we could just say let it break in that case, but it's not friendly
16:45:43 <Igloo> musasabi: Oh, you mean if it was made a flag and then overridden? In that case you're right
16:45:56 <dcoutts> I originally suggested that conditional and optional deps should be specified up front
16:46:01 <Igloo> dcoutts: I don't understand you
16:46:10 <dcoutts> Igloo, which bit
16:46:49 <musasabi> btw the multiple versions of one package kills most of this.
16:46:51 <Igloo> Hang on a tick
16:46:53 <dcoutts> The nasty thing about the current proposal is that activating configurations can change the activation of other.
16:47:06 <dcoutts> it'd be nice to specify conditional deps up front
16:47:10 <dcoutts> with some nice syntax
16:47:48 <Igloo> dcoutts: I don't see why we can't drop using, and do things like http://urchin.earth.li/~ian/conf.txt instead
16:47:54 <musasabi> dcoutts: as an alternative method - could we just omit all the auto-sensing (using/available) and implement the rest.
16:48:10 <musasabi> using can always be added later.
16:48:26 <dcoutts> musasabi, but using is needed for the simple useful cases, like fps in base
16:48:51 <dcoutts> Igloo, but as we've said I can set fps-in-base wrongly. It should not be a user configurable thing.
16:48:57 <musasabi> having to add --enable-external-fps is much better than the current two cabal files situation.
16:49:03 <Igloo> dcoutts: What do you mean, set it wrongly?
16:49:24 <dcoutts> Igloo, runghc Setup --disable-fps-in-base
16:49:36 <dcoutts> err, runghc Setup configure --disable-fps-in-base
16:49:39 <Igloo> dcoutts: You can set flags such that the build-deps are unsatisfiable if that's what you mean
16:49:51 <Igloo> But then cabal will tell you so, and you fix it
16:50:17 <dcoutts> Igloo, it's nice to separate the real hard deps from the soft ones
16:50:58 <Igloo> dcoutts: If you do nothing then that cabal file will work out the right deps for you
16:50:58 <dcoutts> this is a hard dep, it's just that it's an implication
16:51:05 <dcoutts> Igloo, true.
16:51:22 <dcoutts> Igloo, but all these flags are user visible things
16:51:39 * Igloo is perfectly happy with giving the ability the user to shoot themselves in the foot
16:52:05 <dcoutts> I think we can do proper implication deps
16:52:57 <dcoutts> build-depends: base, ((base < 2) -> fps >= 0.8)
16:53:05 <dcoutts> or something
16:53:32 <Igloo> Then you can make loops again
16:53:43 <dcoutts> build-depends: base, (base < 2 -> base > 2)
16:53:44 <dcoutts> true
16:53:46 <Igloo> I'd prefer the user can shoot themselves in the foot than cabal can return _|_!
16:54:13 <dcoutts> it's only _|_ if you pick a silly strategy to see if those deps are satisfiable.
16:54:37 <dcoutts> is there a sensible restriction ?
16:54:49 <dcoutts> eg make something monotonic
16:56:55 <Igloo> dcoutts: You could say    foo = 1 => bar = 2, bar = 1 => foo = 2   and then there's no best answer if you have all 4 installed
16:57:24 <dcoutts> Igloo, I don't know that we care how we pick between many ok answers
16:57:59 <Igloo> dcoutts: I care. And I also think we should avoid having the question
16:58:21 <dcoutts> we'll have many examples of this
16:58:27 <dcoutts> eg in installing a set of packages
16:58:38 <dcoutts> the order affects things I think
16:59:32 <dcoutts> that's the other reason for not allowing 'available' all over the place
16:59:45 <Igloo> Where aren't you allowed available?
16:59:58 <ventonegro> anyone knows what's the debian package for opengl for ghc 6.6?
17:00:22 <dcoutts> Igloo, because then I think it makes the problem of cabal-install predicting what packages will be needed much harder
17:00:47 <Igloo> dcoutts: Oh, you mean that available can only be used in flag defaults?
17:00:54 <dcoutts> Igloo, right.
17:00:59 <Igloo> dcoutts: Order of installation doesn't matter if you explicitly set all flags, right?
17:01:20 <dcoutts> Igloo, I believe so. If you set the flags before you install anything.
17:02:07 <dcoutts> Igloo, if you set them as you go along, I'm much less sure
17:03:53 * Igloo doesn't follow
17:04:37 <dcoutts> well, suppose you want to install A and B and each have flags where the default value depends on if the other is installed.
17:06:15 <Igloo> dcoutts: But if I'm setting all the flags for each package before I install it then it shouldn't matter, no?
17:06:27 <dcoutts> Igloo, I believe so
17:06:46 <dcoutts> that would correspond closely to gentoo use flags
17:06:50 <dcoutts> and they're ok
17:07:39 <dcoutts> note that they eliminated auto-use flags, where the default value of a flag could depend on the installation state of another package.
17:08:31 <dcoutts> it was impossible to do correctly apparently
17:12:32 <SamB> hmm, someone remind me what external core is for?
17:12:55 <mathewm> what is an 'indexed type'?  "Types and Programming Languages" is silent on it
17:12:57 <dons> oh, heh.
17:13:01 <dons> () :: a -> (a -> b) -> b
17:13:02 <dons> x  f = f x
17:13:09 <dons> oh my euro sym went missing
17:13:13 <SamB> hah
17:13:24 <dons> mathewm: they've been invented since TaPL came out ...
17:13:36 <mathewm> :(
17:13:36 <dons> mathewm: references on the front page of haskell.org right now, in fact
17:13:43 <Igloo> dcoutts: OK, I've replied to the thread with the right answers^W^Wmy opinions
17:13:51 <dcoutts> heh, ok thanks
17:13:52 <dons> http://haskell.org/haskellwiki/GHC/Indexed_types
17:13:54 <lambdabot> Title: GHC/Indexed types - HaskellWiki, http://tinyurl.com/ykx38g
17:13:57 <SamB> x € f = f x
17:14:04 <dons> http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html
17:14:06 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/y2d8uq
17:14:36 <dons> mathewm: but karma for checking in TaPL first!
17:14:43 <dons> mathewm++
17:14:45 <dons> :)
17:14:49 <mathewm> :)
17:16:15 <dons> someone should write an STM solution to this puzzle/story http://programming.reddit.com/goto?id=ojtc
17:16:18 <lambdabot> Title: Damien Katz: Living with a Ghost
17:16:47 <dons> hey sethk - new ip address?
17:17:02 <sethk> dons, mine?
17:17:06 <sethk> or yours?
17:17:10 <dons> yeah. new domain?
17:17:20 <dons> (i.e. new job?)
17:17:33 * dons speculates randomly and wildly
17:17:45 <sethk> ohub, yes, I'm on a contract for Qualcomm now
17:17:53 <sethk> building a wireless broadband modem
17:18:21 <dons> cool.
17:18:48 <sethk> it's kernel and device driver work, mostly, but I'll sneak in some haskell for utilities and such
17:19:02 <dons> heh nice
17:19:32 <dons> i created this page recently. if you have anything to add to it, pease feel free.
17:19:35 <dons> http://haskell.org/haskellwiki/Haskell_in_industry
17:19:39 <lambdabot> Title: Haskell in industry - HaskellWiki, http://tinyurl.com/ylh86r
17:19:46 <sethk> dons, ok, definitely.
17:20:28 <Igloo> dons: Don't we have a jobs page somewhere? Woudl make sense to link to it
17:20:38 <sethk> interesting that the subject of line numbers/file names came up, because I've been asked to add that to the tracing in the manufacturing system.
17:20:40 <dons> ah we do. yes
17:21:02 <sethk> Igloo, good idea
17:21:03 <jgrimes> if I calculate (sqrt 5) in a function, and then map that function over a list, is the value for (sqrt 5) saved between each application of the function?
17:21:13 <dons> sethk: yes. it seems to be a poor oversight that linenum tracing wasn't added waaaay back to ghc.
17:21:19 <dons> but i think it will happen now. it has to.
17:21:22 <jgrimes> that goes for any such value I guess, not just sqrt 5
17:21:43 <sethk> dons, yes, I hope you are correct, adding a preprocessing stage makes you build system brittle
17:21:55 <sethk> jgrimes, well, that question doesn't exactly have an answer
17:22:07 <Igloo> Do you mean for failures messages?
17:22:18 <sethk> Igloo, any kind of trace messages
17:22:18 <dons> there's assert of course. which can be used as a token for generating the line nums without preprocessing
17:22:21 <dons> Igloo: yes.
17:22:32 <Igloo> If so, it's tricky, as you don't necessarily want to go a single step up the function call chain
17:22:37 <sethk> Igloo, I also log things like MAC addresses used, test results, all sorts of things.
17:22:55 <dons> now also, andy mentioned that HPC will soon support this too
17:22:56 <sethk> Igloo, I'm talking about substituting in a file name and line number at compile time
17:23:00 <dons> so that's another alternative
17:23:02 <sethk> Igloo, not anything at run time.
17:23:08 <dons> you'll be able to trace back to the call site.
17:23:12 <sethk> dons, yes, I noticed that email.
17:23:35 <sethk> dons, but he said something on the order of "the next time I get frustrated, I'll add it to ghc"
17:23:46 <Igloo> sethk: Well, it you're talking about the 0-step solution, then you get told that head in Prelude is where the pattern match failure happened
17:24:02 <sethk> dons, I haven't done anything with his compiler yet.
17:24:09 <mathewm> dons: thanks for the indexed types paper reference - that clears things up nicely
17:24:14 <sethk> Igloo, no, I'm talking about something much more simple than that.
17:24:46 <sethk> Igloo, just some construct that the compiler replaces with the file name and line number at build time, similar to __LINE__ in c
17:24:46 <Igloo> sethk: Oh?
17:25:09 <sethk> Igloo, dons implemented that with a macro processor, I think (m4?) but of course that adds a step to the build
17:25:26 <dons> and you can do it with 'assert'
17:25:31 <sethk> Igloo, the current function name would be a great bonus also.
17:25:47 <dons> http://www.cse.unsw.edu.au/~dons/tmp/Location.hs
17:25:48 <sethk> dons, I'm not clear on that assert method, but it seems a bit hackish.
17:25:49 <lambdabot> http://tinyurl.com/sutst
17:25:58 <dons> it is hackish, but avoids a preprocessor :)
17:25:58 <Igloo> OK, but that wouldn't help with head, fromJust et al
17:26:06 <dons> right.
17:26:06 <sethk> dons, true.  I'll study it.
17:26:09 <dons> we need hpc for head, I think.
17:26:23 <Igloo> Does hpc know what the function call sequence was?
17:26:30 <dons> and a located error call, http://www.cse.unsw.edu.au/~dons/tmp/Exception.hs
17:26:32 <lambdabot> http://tinyurl.com/y7e7a9
17:27:00 <dons> Igloo: it can trace backwards. andy said "go backwards in time", hat style, I suppose?
17:27:09 <sethk> dons, when the function is called the string contains the name/number?
17:27:22 <Igloo> OK, cool
17:27:33 <dcoutts> Igloo, I don't understand what you mean about "cabal flag to give an error if I have not given a value explicitly for any flag"
17:27:41 <dons> yeah, the assert argment generates an exception with the linu/col number
17:27:55 <Igloo> dcoutts: If your cabal file has flags foo and bar, and I only explicitly set bar, then I want cabal to tell me off
17:27:56 <dcoutts> Igloo, do you mean the package author in the .cabal file ? on the user on the cabal configure command line ?
17:28:02 <sethk> dons, of the caller, hopefully  :)  not trace itself.
17:28:06 <dons> so you efffectively use 'assert' as the pragma, placing it where you need it
17:28:11 <dons> right. of the caller
17:28:21 <Igloo> dcoutts: So you can't sneak another flag in in version 2.1 without me noticing
17:28:36 <sethk> dons, so you assert something that is always true (or false, whichever triggers it)?
17:28:57 <dcoutts> Igloo, so you mean the user. So I have to say: runghc Setup --enable-fps-in-base ?
17:29:04 <dons> no, you just put 'assert' in, which is then applied to False later, to trigger it
17:29:22 <dons> let me give you an example:
17:29:27 <dcoutts> Igloo, I think we can easily add a flag to cabal to turn off all defaults, that avoids our problem as packagers of extra flags.
17:29:38 <Igloo> dcoutts: No, if you say --fail-on-defaulted-flags then you would also need to explicitly enable/disable/default it
17:29:54 <Igloo> Turning off defaults is equivalent
17:29:57 <dcoutts> Igloo, yeah ok. But it can't be the normal behaviour for end users.
17:30:03 <dcoutts> or it's unusable.
17:30:16 <dcoutts> but yeah, yuo and I and other packagers need that
17:30:20 <Igloo> Except I want to be able to default certain flags (e.g. I don't want to have to explciitly set the is_windows flag myself)
17:30:42 <dcoutts> Igloo, well, that shouldn't be a flag.
17:30:44 <Igloo> dcoutts: No, I want a cabal flag to do so (not to be confused with a .cabal flag!)
17:30:53 <dons> so this source: http://www.cse.unsw.edu.au/~dons/tmp/Example.hs
17:30:56 <lambdabot> http://tinyurl.com/ycb29d
17:31:02 <dons> produces:
17:31:03 <dons> $ ./a.out
17:31:04 <dons> a.out: A.hs:15:17-22: j
17:31:13 <Igloo> dcoutts: True, but more complex compositions of arches and suchlike could be. It seems silly not to have it, anyway
17:31:14 <dcoutts> Igloo, yes, I mean the same I think. runghc Setup configure --packager-foo
17:31:17 <dons> so its a located error call, without needing a preprocessor
17:31:54 <dons> i should put this on the wiki ...
17:33:16 <Igloo> I don't suppose there's anywhere comparing wiki markups, and talking about what works well or what is common or anything?
17:33:54 <dons> i suspect there must be somewhere
17:34:06 <dons> choosing MediaWiki syntax wouldn't be a bad bet
17:34:22 <dons> or just using haskell ;)
17:35:06 <Igloo> Using Haskell? You mean putting normal text in "" and using combinators?
17:35:25 <dons> oh, some kind of haskell-ish syntax anyway
17:35:55 <dons> there's a few weird things in MediaWiki that are a bit ugly, but its not too bad
17:35:55 <Igloo> I don't quite see. Haskell doesn't have "bold functions"  :-)
17:36:29 <SamB> Igloo: take Pretty
17:36:30 * Igloo splutters
17:36:42 <SamB> add something like CSS...
17:36:42 <Igloo> bold-italic is '''''? I think I'll pass
17:36:44 <SamB> tada!
17:37:32 * Igloo realises *foo* clashes with * for itemised lists. Bah.
17:38:08 <SamB> no it doesn't
17:38:15 <Igloo> Heh, there's something ironic about MediaWiki interpreting some HTML markup
17:38:18 <SamB> * for lists usually has space after it
17:38:31 <SamB> yeah, I don't like that much :-(
17:38:33 <Igloo> Hmm, true. Seems a touch ugly, though
17:38:49 <SamB> it isn't ugly in Wiki, just in parsers maybe
17:38:57 <SamB> who ever heard of bold whitespace anyway?
17:39:06 <Igloo> Stealing punctuation also seems likely to lead to backslashitis. Ho humm.
17:39:23 <keroppi> dons: there is locateError?
17:39:40 <SamB> or maybe "yes, perfect!"-itis
17:39:56 <Igloo> huh?
17:40:25 <SamB> oh, I'm just too lazy to look up the real bold notation
17:41:32 <keroppi> '''bold'''
17:44:51 <dons> keroppi: not quite 'locateError' :) locatedError
17:44:59 <dons> locateError would be very useful though
17:45:55 <sethk> what does (or would) locateError do?
17:46:04 <sethk> or is it located?
17:46:27 <dons> i'm guesing locateError would find errors in your code for you, and tell you where they are ;)
17:46:40 <keroppi> yes locatedError, where can I get one?
17:46:43 <sethk> ohub, I don't need that, I never make mistakes  :)
17:47:05 <dons> http://www.cse.unsw.edu.au/~dons/tmp/Exception.hs
17:47:07 <lambdabot> http://tinyurl.com/y7e7a9
17:47:15 <dons> usage: locatedError assert $ my code
17:47:20 * SamB wishes sentances on the Haskell' wiki were colored to indicate how seriously they should be taken
17:47:56 * Pseudonym wonders how SamB's comment should be coloured
17:48:32 * Igloo ran locateError on my code once, but it diverged
17:48:38 <sethk> samb gets to be colored American, and Pseudonym gets to be colored, well, some country using the British spelling.  :)
17:54:25 <dons> http://programming.reddit.com/info/opad/comments
17:54:31 <lambdabot> Title: Computational Thinking [pdf] (reddit.com), http://tinyurl.com/y8pema
17:54:52 <dons> nice article for outsiders trying to think like a programmer
17:55:18 <sethk> dons, I need one about _not_ thinking like a programmer  :)
17:55:24 <dons> heh
17:57:50 <dons> bah, that's what happens on reddit. 1 down vote by someone waiting for donkey pr0n and an article vanishes
17:57:57 <dons> democracy _doesn't_ work
17:58:07 <Pseudonym> I'm glad I don't read reddit.
17:59:28 <keroppi> Let the blind lead the blind.
17:59:43 <kfish> i read reddit via #haskell, seems to work quite well
17:59:46 <dons> you know, it was originally written in lisp, last year, and now they've sold it for some rumoured large figure. maybe there is an opening for a more technologically oriented site -- a social LtU
18:00:16 <Pseudonym> True, #haskell makes a good feed aggregator.
18:00:25 <kfish> dons: which only accepts submissions via 'darcs send' ?
18:00:29 <Pseudonym> All I need is for lambdabot to pick up the links and publish them in rss format.
18:00:29 <Igloo> I have a great desire to upload   package bottom; build-depends: bottom (< 0), bottom (> 0)   to hackage once it exists
18:00:45 <dons> kfish: well, not quite that bad. i was thinking that you had to fix a type error in a haskell program to register to vote
18:01:03 <Pseudonym> Reminds me of alt.sysadmin.recovery.
18:01:10 <Pseudonym> You had to circumvent the moderation system to post.
18:01:16 <dons> heh
18:01:38 <Pseudonym> There as a company once which also accepted job applications via a hidden SMTP port.
18:01:44 <Pseudonym> If you found it, you could submit your application.
18:03:22 <keroppi> alt.2600 is also marked moderated but there is no appointed moderator
18:03:28 <sethk> not sure I want to apply to that company  :)
18:16:38 * Igloo looks at DebConf train ticket prices; wow, I didn't realise there were such savings for advanced bookings (21 quid vs 110)
18:17:23 <dons> how far does 21 quid get you?
18:17:29 <Igloo> Edinburgh
18:17:49 <dons> oh, cheap!
18:18:11 <Igloo> Yeah - I think it's 40-something to get to Cambridge
18:19:30 <Igloo> Ah, that's also only valid for a particular train, but that shouldn't matter
18:20:01 <Adamant> flights are crazy cheap in the UK, right?
18:20:15 <Adamant> (inside UK)
18:20:31 <Igloo> No idea
18:21:02 <Igloo> But I don't like flying (well, mostly I don't like landing)
18:21:37 <dons> heh
18:21:48 <dons> there's good ways to land, and bad ways
18:25:53 <keroppi> There is a train designated for DebConf people?
18:26:31 <keroppi> So as to make it easy if Microsoft or RedHat wants to undermine Debian? :)
18:27:26 <dons> heh
18:30:15 <SamB> not satisfied with bus numbers?
18:30:22 <keroppi> I was at the Marktoberdorf Summer School.  1.5 hour of train from Munich.  Also near a NATO airbase.  80 bright CS students of formal methods, plus a bunch of profs, including Tony Hoare and Amir Pnueli.  It was year 2000, so SPJ was also there to introduce his Awkward Squad (yes! precisely those famous slides!)
18:30:22 <SamB> now we need train numbers too?
18:31:10 <keroppi> From time to time we heard NATO fighter jets zooming through.  We were like, "if by accident a bomb drops here, CS will be set back for 30 years, heh heh heh!"
18:31:18 <SamB> hmm
18:31:25 <SamB> the external core for Prelude is tiny
18:31:37 <SamB> %module base:Prelude
18:31:37 <SamB>   zdzn :: %forall a b . (a -> b) -> a -> b =
18:31:37 <SamB>     \ @ a @ b (f::a -> b) (x::a) ->
18:31:37 <SamB>         %case (b) x %of (tpl::a)
18:31:38 <SamB>           {%_ ->
18:31:41 <SamB>              f tpl};
18:31:45 <keroppi> (Haskell would certainly be set back for 30 years. XD)
18:33:27 <SamB> ah
18:33:32 <SamB> that is the $! function
18:34:04 <SamB> so apparantly that is the *only* function in the Prelude!
18:35:26 <Igloo> keroppi: No, just looking at the standard site
18:51:12 <dons> keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd, perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:51:41 <chessguy> lol
18:52:06 <chessguy> @remember dons keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd, perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:52:25 <chessguy> ?remember dons keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd, perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:52:34 <dons> both worked..
18:52:36 <dons> :)
18:52:52 <Cale> It should probably print something like "Remembered."
18:53:08 <SamB_XP> @quote dons
18:53:08 <lambdabot>  keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd, perl,
18:53:08 <lambdabot> gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:53:11 <SamB_XP> @quote dons
18:53:11 <lambdabot>  dons has quit ("improve @check")
18:53:13 <SamB_XP> @quote dons
18:53:14 <lambdabot>  Haskell: The language that never sells out!
18:53:15 <SamB_XP> @quote dons
18:53:16 <lambdabot>  Haskell: The language that never sells out!
18:53:17 <SamB_XP> @quote dons
18:53:17 <lambdabot>  note down this date, people, 13-09-2006. today lambdabot == skynet
18:53:34 <SamB_XP> was that based on number of users?
18:54:16 <dons> hmm. no. it was something else.
18:54:21 <dons> can't remember let me see...
18:54:33 <chessguy> did you forget to note it down? :)
18:54:45 <dons> ah, lambdaweb
18:54:57 <dons> that was the day lispy launched lambdaweb
19:16:27 <SamB_XP> what is the <weeble> category?
19:36:19 <dons> ?seen araujo
19:36:19 <lambdabot> araujo is in #gentoo-haskell, #perl6, #haskell and #haskell.es. I last heard araujo speak 5h 2m 40s ago.
19:36:36 <dons> araujo, still up for translating hwn?
19:36:49 <dons> hmm, interesting, http://www.infodrom.org/~joey/log/?200610250942
19:36:52 <lambdabot> Title: Joey's Logbook, http://tinyurl.com/yxlfwb
19:37:05 <dons> I _dont_ spend a day a week preparing HWN, its about an hour's work now.
19:37:32 <dons> DWN is more dense than HWN though
19:40:29 <kfish> dons: perhaps you spend less time because you solicit submissions (as darcs patches), whereas Joey spends a day scouting the web and mailing lists himself
19:41:20 <dons> i rarely get any darcs patches. but i do have tools that do the scouring for me, a gmane search tool that turns mailing list articles into HWN items, and a rss feed aggregator for haskell blogs
19:41:28 <dons> that reduce the time spent from 5-6 hours to 1.
19:42:32 <dons> also, the haskell community is smaller and more centralised around haskell.org
19:42:44 <dons> the stuff that happens outside, i can find via rss
19:43:16 <kfish> i do find the layout of stuff in your darcs repo easier to read than the stuff on the sequence
19:43:29 <dons> yeah, sequence's default layout isn't so nice.
19:43:41 <dons> i prefer the wordpress-style format
19:43:47 <dons> s/skin/ for sequence
19:44:31 <dons> i should suggest to CosmicRay to change it, maybe. the current default skin is too noisy for 2006
19:47:26 <chessguy> test
19:47:35 <chessguy> ok, just quit here tonight
19:47:56 <kfish> chessguy, test procedure initiated, your missiles have been launched
19:48:03 <chessguy> cool!
19:48:07 <chessguy> i've always wanted to do that
19:50:12 <dons> I prefer this format for sequence, http://www.cse.unsw.edu.au/~dons/tmp/nice.png
19:50:16 <dons> what do other people think?
19:51:12 <dons> (and compare it with the default http://sequence.complete.org/)
19:51:33 <glguy_> I like the look generally... I don't like the layout under Topic as much though
19:51:55 <dons> yeah, maybe there's newer drupal skins that improve that
19:52:05 <kfish> well, yeah, anything which doesn't try to fiddle with font sizes, and with fewer sidebars
19:52:40 <glguy_> I preferred the side bar having smaller heavier font
19:54:51 <palomer> yo my bitches
19:55:45 <glguy_> http://sequence.complete.org/node/215
19:56:41 <glguy_> I don't understand how Haskell can be touted as the perfect language, too hard for the common man
19:56:44 <glguy_> and then
19:56:54 <palomer> glguy, hallelujah!
19:57:03 <glguy_> be touted as an idea teaching language where concepts are obvious
19:57:08 <Pseudonym> It's like how communism is the perfect political philosophy.  It's just too hard for humans.
19:57:09 <palomer> it is rather hard for the common man
19:57:12 <glguy_> until obfuscated
19:58:03 <palomer> then again, using correct english is rather hard for the common man
19:58:08 <palomer> (myself included)
19:58:19 <Pseudonym> Actually, Haskell is easier.  It's just that there are more bad habits to unlearn.
19:59:03 <palomer> haskell is easier than communism?
19:59:06 <Pseudonym> I picked up Miranda pretty quickly precisely because I was a programming snob and just didn't realise it.
19:59:21 <Pseudonym> I knew on a gut level that my previous languages were crap.
19:59:32 <Pseudonym> I just couldn't articulate it.
20:00:01 <palomer> haskell is crap too
20:00:08 <Pseudonym> Surely, but it's less crap.
20:00:13 <palomer> it's just crap of a different colour
20:00:25 <dons> yeah. I agree. I knew there was something "wrong" about all the side conditions and special cases in other languages I was using, but that wasn't really crystalised till I came back to haskell
20:00:33 <palomer> from  my experience, it's as crappy as the rest of them
20:01:03 <sethk> palomer, I don't agree
20:01:36 <Pseudonym> As a mature adult, I recognise that in different applications, different languages are less crap than others.
20:01:45 <palomer> sethk, I disagree with your disagreeing
20:02:00 <Pseudonym> Haskell would be very inappropriate for the firmware that I'm writing now.  It's one of the few times I'm glad to have C.
20:02:02 <sethk> palomer, well, then, I ... I think we have infinite recursion here ...
20:02:31 <Pseudonym> Scrounging bytes and cycles is much easier.
20:03:15 <dons> don't mind palomer. he's a famously grumpy pair of pants
20:03:16 <sethk> Pseudonym, sure, but you can create an appropriate set of primitives
20:03:22 <Pseudonym> Well, true.
20:03:56 <palomer> ooooh, I'm famous now
20:04:14 <Pseudonym> The fact that I have to fit everything in 64k of flash is its own kind of fun, though.
20:04:22 <Pseudonym> It reminds me of my C64.
20:04:45 <Pseudonym> Not that the C64 had flash memory.
20:05:25 <sethk> and you couldn't really use all 64k, either, iirc
20:05:47 <Pseudonym> You could swap out the ROM.
20:05:52 <Pseudonym> Though you still had video RAM.
20:05:53 <sethk> but we're getting spoiled; my latest embedded thingy has 16 meg flash
20:06:02 <Pseudonym> That is spoiled indeed.
20:06:11 <Pseudonym> Well, I have a 32Mb MMC card.
20:06:18 <sethk> Pseudonym, right.  I worked on one box that gave up 2k to the floppy controller; but that might have been a different box, not the c64
20:06:20 <Pseudonym> The 64k is just program memory.
20:06:28 <Pseudonym> Yeah.
20:06:44 <Pseudonym> The C64 actually had two ROMs.  One was the BASIC interpreter, the other was the kernel.
20:06:48 <Pseudonym> Or "kernal" as they spelled it.
20:07:10 <Pseudonym> The floppy drive had its own CPU.
20:07:21 <Pseudonym> Smart people uploaded code to it.
20:07:56 <sethk> remembering, the floppy controller I'm thinking of couldn't have been the c64, because it had a pair of cards in a card cage.
20:08:08 <sethk> two eight inch cards, couldn't fit a floppy controller onto a single card.
20:08:27 <sethk> and originally they used 2k at 48k, instead of at 62k (morons)  :)
20:09:09 <Pseudonym> When a colleague of mind described his first computer (a ZX80), and mentioned that it had 1k of RAM, another colleague complained, "that's not even a screenful!"
20:09:36 <Pseudonym> It is if you only have 40 columns, of course.
20:26:51 <desrt> LAMBDA!!!!
20:26:56 * desrt steps out
20:35:25 <Pseudonym> BURMA!
20:35:27 <Pseudonym> Sorry, I panicked.
20:37:54 <lennart> I'm not Burmese, I'm Swiss.
20:38:13 <edwardk> Hello Swiss, I'm Cheddar.
20:39:38 * edwardk scrolls back through the c64 discussion.
20:39:55 <dibblego> I had one of those
20:40:18 * tmoertel had an Apple ][
20:40:31 <edwardk> yeah, i used to love abusing the 1541 =)
20:40:41 <dibblego> ah! the 5.25 inch drive!
20:40:54 <edwardk> something about a disk drive having a slightly higher clock speed than your main cpu is disturbing to me even now =)
20:41:07 <dibblego> my first program was 10 PRINT "HELLO" 20 GOTO 10 when I was about 12
20:41:38 <edwardk> (didn't have all the ram to refresh so the 6502 in the 1541 could run faster than the main 6510 in the c64 if you disabled 'c64 compatibility mode' =)
20:41:53 <edwardk> course then you could blank the screen on the c64 and double the clockspeed and overtake it, but still
20:42:55 <edwardk> wrote my first disassembler for the c64, after i lied and told a kid in grade school that i had already done so, and then had to make good on that claim.
20:43:00 <dons> tmoertel++ on the quickcheck kata. this whole programming dojo idea seems really nice. we should have one in sydney
20:43:22 <edwardk> programming dojo?
20:43:35 <tmoertel> dons: thanks.  the guy I was with thought QC was really cool.
20:43:58 <dons> edwardk: http://blog.moertel.com/articles/2006/10/31/introductory-haskell-solving-the-sorting-it-out-kata
20:44:01 <lambdabot> Title: Introductory Haskell: Solving the Sorting-It-Out Kata, http://tinyurl.com/y3l23z
20:44:24 <dons> yeah, qc is a bit like magic :)
20:45:20 <tmoertel> while we're on the subject, isn't an massively updated QC due Real Soon Now?
20:45:37 <dons> ?check \f g xs -> (map f . map g) xs == map ((f :: I -> I) . (g :: I -> I)) (xs :: T)
20:45:41 <lambdabot>  OK, passed 500 tests.
20:45:51 <dons> yeah. koen rumoured as much a couple of months ago
20:46:06 <dons> needs some pestering, otherwise we'll just have to update it ourselves
20:46:10 <tmoertel> I hope he wasn't just teasing   :)
20:46:28 <dons> he's a busy guy, i think that's the main issue
20:47:10 <dons> btw, have you seen HsColour for generating syntax highlighted html-haskell?
20:47:41 <tmoertel> nope.  (I've been using Emacs + htmlize-buffer)
20:48:03 <tmoertel> but, i suspect HsColor would be much better for blog integration...
20:48:09 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/10#colours
20:48:12 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/ygmkj2
20:48:31 <dons> yeah, it just dumps out css-ified, or html-fontified, code. whihc you can include into the blog src
20:49:36 <tmoertel> excellent.  I can add it as a filter into my blog (Ruby powered) and have the blog auto htmlify Haskell snippets.
20:49:58 <dons> ah yes. that would be neat
20:50:29 <tmoertel> all non-Haskell snippets, of course, will continue to receive the monotone treatment  ;-)
20:50:57 <glguy_> you could make non-Haskell code a smaller font :)
20:51:19 <dons> heh
20:51:20 <tmoertel> or perhaps wrap it in <blink>...</blink>
20:51:34 <dons> good idea!
20:51:38 <tmoertel> or <div style="display:none"> ... </div>
20:52:35 <tmoertel> hey, when are we gonna write something to compete w/ Rails?
20:52:44 <Pseudonym> I remember the day when QuickCheck found a bug in my binary search tree code.
20:52:49 <tmoertel> "Haskell on Highways"
20:52:53 <Pseudonym> I added a property to check the balance condition.
20:53:11 <dons> tmoertel: yeah, there was some talk today. we've got most of the things needed.
20:53:12 <Pseudonym> Very nice.
20:53:45 <dons> and there's things like the Ajax/Javascript generator developed as a SoC project
20:54:04 <dons> and HAppS, of course.
20:54:30 <dons> so the pieces are there, just needs a driving team to plug things together
20:54:36 <tmoertel> all we need now is the screencast   ;-)
20:54:45 <dons> heh
20:55:10 <tmoertel> dons: in all seriousness, what makes solutions "click" is a *lot* of polish and good documentation
20:55:30 <dons> yes. exactly. that's what has to happen
20:55:37 <dons> a 3 month polish effort
20:55:47 <dons> nd then some.
20:55:54 * tmoertel checks the calendar . . .
20:56:24 <dons> so one thing we're planning is to have hackage in place by jan, for an infrastructure hackathon at oxford
20:57:33 <dons> i wonder if we can convince some of the web/chalmers guys to do a 'haskell on highways' -- guys like nibro and bringert have done most of the related work already
21:00:34 <tmoertel> what do we think the essential features of a Haskell-based web framework should be?
21:02:00 <tmoertel> WASH-esque continuations?
21:03:11 * Lemmih doesn't like encoding HTML in his code nor does he like using continuations for web-applications.
21:04:56 <tmoertel> indeed, for some applications, "web continuations" are not the best approach; for others, however, they are pretty nice to have.  maybe a good framework should offer them as an option.
21:12:56 <subdie> I don't understand too much of them continuations
21:14:28 <dibblego> is there anything on the wiki on how to go about memoizing a function?
21:14:58 <Lemmih> I think continuations are wrong from an ideologically point of view. Data, presentation and flow-of-control should be kept as separate as possible.
21:15:00 <dibblego> or anywhere even
21:16:26 <kfish> isn't a lot of the thing with rails the ability to really easily map the DB object model into the application's object model?
21:16:27 <dons> on the old wiki was an article or two, dibblego
21:16:39 <dons> dibblego: google should be your friend
21:16:40 <dibblego> ?where old wiki
21:16:40 <lambdabot> I know nothing about old.
21:16:53 <dibblego> dons, should, but not having much luck
21:17:32 <dons> the old wiki is http://haskell.org/hawiki/
21:17:34 <lambdabot> Title: FrontPage - The Haskell Wiki
21:17:38 <dibblego> thanks
21:19:15 <dons> oh nice!
21:19:17 <dons> All monsters are capable of devouring values:
21:19:17 <dons>     devour :: Monster m => a -> m a
21:19:51 <sjanssen> does Andrew Pimlott hang out here?
21:19:56 <desrt> dons; Just?
21:19:58 <sjanssen> he deserves some karma
21:20:02 <dibblego> do lots of lisp people fail to understand monads?
21:20:08 <desrt> dons; return, i suppose :)
21:20:21 <subdie> I think lots of people fail to understand monads
21:20:31 <sjanssen> lol "regurgitation law"
21:20:36 <dons> sjanssen: don't think so.
21:20:44 <dons> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
21:20:47 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
21:20:51 <desrt> the #1 mistake you can make while attempting to learn monads is to think that they are something
21:20:57 <dibblego> tis just a recurring trait that I thought I was observing
21:22:16 <desrt>     slay :: SomeMonster a -> a
21:22:26 <sjanssen> this monster metaphor seems like a good one
21:22:31 <desrt> you think unsafePerformIO is more like *creating* a monster
21:24:25 <dibblego> dons, there doesn't seem to be anything re memoization on that wiki according to google
21:25:25 <dibblego> sorry, just found http://haskell.org/hawiki/MemoizingRecursion
21:25:26 <lambdabot> Title: MemoizingRecursion - The Haskell Wiki
21:26:42 <dons> http://programming.reddit.com/info/oq3m/details
21:26:45 <dons> :)
21:26:47 <lambdabot> Title: Monads are monstrous! (reddit.com), http://tinyurl.com/yc6evg
21:27:30 * desrt learned about milner today, and why ML was created
21:28:54 <glguy_> I don't understand why the /The Fourteen Types of Programmers.../ is so high up on the reddit list... the linked blog entry is next to useless
21:29:03 <dibblego> is the general "Haskell array" actually referring to Data.Array?
21:29:42 <dons> I would thin so, yes.
21:30:12 <dons> glguy_: welcome to the performance indicator of the human species. current level: 4/10
21:30:47 <dons> i don't know why popular sites make me think misanthropic thoughts, but they do
21:31:14 <glguy_> ugh, how does /glguy/ survive?  I did something to exhaust the resources on that box, but the irc client isn't timing out
21:31:17 <glguy_> I just can't log in
21:31:45 <dons> you should be able to /ghost it
21:31:56 <dons>  msg chanserv ghost paswd -- or some such
21:31:59 <glguy_> I'm using it as an indicator of when someone rebooted the box for me
21:32:02 <dons> or is it nickserv
21:32:02 <glguy_> I know how to kill it
21:32:05 <glguy_> nickserv
21:32:08 <dons> ah ok
21:32:20 <glguy_> They won't reboot the box until they can't watch movies on it
21:32:31 <glguy_> and someone who knows what the hell to do plugs in a monitor and reboots it
21:32:52 <glguy_> I'm just afraid that they can still watch movies
21:33:00 <glguy_> if irssi is still going
21:34:04 <glguy_> ?localtime glguy
21:34:19 <dons> "Like poisoned candy and release dates, this is of course a myth."
21:34:25 <dons> that is such a great article
21:35:11 <glguy_> I wish I could read the Kata Eleven blog post first
21:37:40 <sjanssen> I can't wait for the replies that explain the remaining Monster laws
21:41:28 <glguy_> is there an operating system (generally available, not necessarily free) that would allow you to move a runnign process to another machine without special support from the process?
21:41:39 <glguy_> (I recognize that such a feature might be "experimental"
21:41:49 <glguy_> or that the entire OS might be experimental)
21:42:18 <glguy_> I know that VMWare allows you to move a running operating system to a different computer
21:43:21 <sjanssen> glguy_: I think MOSIX can do this
21:45:13 <Pseudonym> Grrrr.
21:45:17 <Pseudonym> This is seriously weird.
21:45:27 <Pseudonym> My microcontroller isn't getting any interrupts.
21:45:31 <Pseudonym> None.  At all.
21:45:40 <Pseudonym> And yes, I did enable them.
21:48:07 <glguy_> ?type (=~_
21:48:08 <lambdabot> parse error (possibly incorrect indentation)
21:48:09 <glguy_> ?type (=~)
21:48:10 <lambdabot> Not in scope: `=~'
21:48:13 <glguy_> ?type =~
21:48:14 <lambdabot> parse error on input `=~'
21:48:28 <glguy_> ?type Test.QuickCheck.(=~)
21:48:29 <lambdabot> Couldn't find qualified module.
21:49:19 * glguy_ continues reading and learns that =~ is defined later
21:49:46 <dons> heh
21:50:24 <dibblego> why can't I :load Array in ghci?
21:50:38 * glguy_ needs to mirror his laptop's filesystem (the /usr parts of it, stuff that he doesn't change manually, but allows the system tools to change)
21:50:50 <glguy_> and then run system updating tools in a VM on my fast desktop
21:50:58 <glguy_> and then rsync everything to my laptop when I want to update it
21:51:08 <glguy_> instead of watching the updates crawl
21:51:15 <glguy_> on this slower processor, slower harddrive machine
21:52:52 <glguy_> I can't wait until the day when laptops have touch screens, and allow me to flick a running process' window over to a different computer
21:53:32 <dons> dibblego: Data.Array
21:53:45 <dibblego> > :l Data.Array
21:53:46 <lambdabot>  Parse error
21:53:48 <dibblego> module `Data.Array' is a package module
21:53:59 <dons> oh, :m :)
21:54:03 <dons> :l is for src files
21:54:09 <dibblego> gah
21:54:12 * dibblego slaps /me
21:54:46 <dons> ?slap dibblego
21:54:47 * lambdabot beats up dibblego
21:55:03 <dons> better now?
21:55:50 <dibblego> cheers mate
21:56:13 <dons> no worries
21:58:25 <palomer> reading fight club
21:58:26 <palomer> good book
22:04:04 <dibblego> I updated linux and therefore, ghc 6.4.1 to 6.4.2 and now lambdabot is looking for plugins-1.0 (I thought it was hs-plugins?)
22:11:27 <dons> plugins 1.0 is right
22:11:34 <dons> you need to rebuild it for ghc 6.4.2
22:11:57 <dibblego> yeah I am - being a pain
22:13:04 <dibblego> Could not find module `Distribution.Simple': it is a member of package Cabal-1.1.4, which is hidden
22:13:12 <dibblego> so I'm going to try rebuilding Cabal
22:13:20 <dons> mmm. 4 core intel chips now
22:13:27 <dons> yep
22:13:27 <Lemmih> dons: url?
22:13:34 <dons> http://www.theregister.co.uk/2006/11/01/intel_fwives_core/
22:13:37 <lambdabot> http://tinyurl.com/y94fg3
22:14:13 <dons> the timing of ghc 6.6 + smp, wrt. all the multicore chips coming out is really nice
22:14:43 <dons> mm. should try the 5-threaded hmp3 with 6.6
22:14:48 <dons> just have to find a multicore box..
22:15:24 <dons> mm. even lambdabot should benefit. it uses threads all over the place
22:15:29 <dons> should help with async requests a bit
22:18:49 <glguy_> anyone know how to set your DPI correctly (in Xfree) and not have firefox look disgusting?
22:19:35 <theoco> who here can sum up haskell for me?
22:20:00 <dons> visit haskell.org :)
22:20:11 <dons> there's many articles there that should explain things.
22:20:24 <dons> summary: its a programming language ;)
22:20:24 <dibblego> gah, when I rebuild Cabal, it hides plugins-1.0!
22:20:28 <Lemmih> > sum [ ord c | c <- "Haskell" ]
22:20:29 <lambdabot>  708
22:20:32 <dons> heh
22:20:36 <dons> Lemmih++
22:20:54 <dons> > sum . map ord $ "Haskell"
22:20:55 <lambdabot>  708
22:21:29 <dons> dibblego: plugins needs to be built with the Cabal you use . as it depends on cabal at runtime
22:21:45 <dons> so yes, you need to build Cabal _then_ plugins, not the other way aroudn
22:22:06 <dibblego> I'm just going to build everything in the whole world and press go
22:22:50 <dibblego> seems to be working now :) my strategy worked
22:23:32 <theoco> dons: Im reading the intro now :)
22:23:42 <dons> cool. then you can check out:
22:23:45 <dons> ?where yaht
22:23:45 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
22:24:04 <dons> a good introductory tutorial
22:24:07 <theoco> ty
22:24:28 <dons> > reverse . reverse $ "its good!"
22:24:29 <lambdabot>  "its good!"
22:24:50 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
22:24:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:24:53 <theoco> since learning scheme at school this semester I am finding I really like function programming languages
22:24:53 <Smokey`> Haskell is quite the mind blow and a half :P   Though I think I'm still thinking with a very C-like mentality...   Trying to figure out how I would create a new thread (which makes a window, and keeps updating it appopriately), in which I can pass data to (when need be, though when I need to send the data is unpredictable), to change what the window displays... :/  Thinking doing osme of this in C might be easier ... :/
22:25:14 <dons> theoco: excellent. haskell should be relatively easy to get used to then, if you know scheme
22:25:42 <dons> its a bit more "modern" in a few ways, being about 15 years younger than scheme
22:26:07 <dibblego> undefined reference to `DistributionziPackage_a_closure' -- isn't that from FPS?
22:26:09 <dons> Smokey`: forkIO --creates a thread.
22:26:17 <dons> dibblego: looks like a missing -package Cabal ?
22:26:37 <dons> Smokey`: so you'd forkIO $ my_update_loop
22:26:46 <Smokey`> dons: yes I know that much, but I've no idea how to pass data to/from said thread - infact I don't even know what I'm thinking :/
22:26:47 <dons> where: my_update_loop = do update ; my_update_loop
22:26:58 <dons> via Chans or MVars
22:27:06 <dons> check the 'Awkward Squad' paper
22:27:14 <dons> ?docs Control.Concurrent.Chan
22:27:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
22:27:18 <Smokey`> alrighty, I'll go check up on them :) ty
22:27:39 <dibblego> dons, which package? it is referenced from libHSplugins-1.0.a
22:28:02 <dons> DistributionziPackage_a_closure is a Cabal symbol
22:28:06 <Smokey`> must admit, if I didn't have this channel, I would be very lost in some instances (not knowing what to look for)
22:28:14 <dibblego> gah
22:28:15 <dons> dibblego: did you make clean before trying to rebuild plugins?
22:28:20 <dibblego> hm no
22:28:25 <dons> maybe its referring to symbols in the old cabal...
22:28:45 <dons> Smokey`: googling for 'concurrency' should find you the relevant material
22:28:49 <dons> (on haskell.org)
22:28:50 <dibblego> build order is FPS, Cabal, plugins
22:28:56 <Smokey`> dons: thanks again :)
22:29:02 <dons> dibblego: that'd work
22:29:11 <dons> normally you'll have a valid Cabal already
22:29:14 <dons> so i'd build that first
22:29:19 <dons> Cabal -> everything else
22:29:45 <dibblego> it probably is from an old one - but I haven't figured out how to reverse a Setup.hs install
22:30:09 <dons> runhaskell Setup.hs clean
22:31:06 <theoco> Im starting to think OOP is a lot of hype, is that totally crazy??
22:31:21 <dibblego> theoco, no
22:31:31 <theoco> good
22:31:42 <dons> it was an 80s thing. we've moved on since then
22:31:50 <dibblego> hello comrade
22:34:18 <dibblego> I didn't realise that clean backed out of install
22:34:55 <dons> it doesn't remove the install
22:34:58 <dons> but it shouldn't clash
22:35:25 <dons> it just removes the .o cache, so you can rebuild safely
22:38:07 <dibblego> why do imperative programmers keep saying "singleton"? is it really not that obvious?
22:38:58 <dibblego> same issue re undefined reference to `DistributionziPackage_a_closure'
22:38:58 <theoco> can someone suggest a good haskell compiler/interperter for *nix?
22:39:02 <dons> ghc
22:39:02 * dibblego gives up
22:39:05 <theoco> ty
22:39:08 <dibblego> theoco, ghc
22:39:09 <dons> theoco: http://haskell.org/ghc
22:39:12 <lambdabot> Title: The Glasgow Haskell Compiler
22:39:43 <dons> > concat . intersperse " " $ ["I", "am", "powererd" , "by", "GHC"]
22:39:44 <lambdabot>  "I am powererd by GHC"
22:39:45 * theoco emerge ghc :)
22:40:12 <Ulfalizer> theoco: ghc takes a while to compile. you might wanna go get a snack or something :P
22:40:28 * glguy_ wonders how long it takes Ulfalizer to eat snacks
22:40:29 <theoco> all i need now is some good techno
22:40:34 <dons> or grab a binary?
22:40:41 <glguy_> you need like 4 hours of techno :)
22:40:48 <glguy_> somafm.com
22:40:58 <dons> until then, feel free to play with lambdabot (in a privmsg perhaps)
22:40:59 <dons> > 1+2
22:41:00 <lambdabot>  3
22:41:03 <theoco> dons: it seemed to have grabbed the binary by default :)
22:41:05 <dons> > 666^666
22:41:05 <Ulfalizer> hugs is the other big haskell interpreter. it's only an interpreter though.
22:41:06 <lambdabot>  2715417592887128558260874551700217860278385210650169871782230046965783675347...
22:41:20 <Ulfalizer> dons: no binaries in portage. at least not for ghc.
22:41:24 <dons> > map (^2) [1..]
22:41:25 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
22:41:28 <Ulfalizer> last time i checked anyway
22:41:47 <glguy_> It might have grabbed what looks like a binary in order to do the bootstrap
22:42:12 <theoco> ahh
22:42:15 <desrt> > reverse (show product [1..])
22:42:16 <lambdabot>    The function `show' is applied to two arguments,
22:42:16 <lambdabot>   but its type `a -> ...
22:42:21 <desrt> bah
22:42:24 <dons> theoco: if you know scheme, http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
22:42:27 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
22:42:29 <desrt> > reverse $ show $ product [1..]
22:42:30 <dons> might be one way to learn haskell
22:42:33 <lambdabot>  Terminated
22:42:37 <desrt> >:|
22:42:52 <glguy_> desrt: wtf did you think that would do ? :)
22:42:53 <dons> you thought it was going to find the last digits of product [1..] ?
22:42:56 <desrt> "00000000000000000000
22:43:03 <desrt> obviously :)
22:43:08 <dons> now that would be shiny
22:43:11 <desrt> (i knew it wouldn't work... but damnit, it should!)
22:43:36 <Ulfalizer> i'd recommend "haskell: the craft of functional programming". it's the most newbie-friendly book i've come across, and i've found no tutorial that can compare to it.
22:43:48 <glguy_> Ulfalizer: is that book new this year?
22:43:52 <dons> its very good, yes.
22:43:54 <dons> no, glguy_
22:43:56 <Ulfalizer> no, it's old
22:44:00 <glguy_> What's the new one?
22:44:01 <dons> that's Programming in Haskell
22:44:02 <desrt> dons; that would have a chance of working if there were a 'show' function that worked on little endian hexidecimal
22:44:23 <int-e> desrt: too much magic
22:44:29 <dons> glguy_: check the 'books and tutorials' page
22:44:40 <glguy_> desrt: the compiler would have to look ahead to first determine that all you are doing is multiplying by non-zeros
22:44:53 <desrt> int-e; all you have to do is notice that multiplying by 0x100 has no chance of modifying the bottom byte and optimise that case
22:44:56 <glguy_> and then actually know that that meant osmething
22:44:59 <desrt> int-e; at which point you could output that byte
22:45:11 <Lemmih> Am I the only one who expected more humour in the 'Record puns' thread?
22:45:13 <desrt> glguy_; oh ya.  that.
22:45:19 <int-e> desrt: besides it's wrong. you can't revert infinite lists in any meaningful way
22:45:19 <dons> Lemmih: oh?
22:45:28 <desrt> int-e; that's why i say "little endian"
22:45:35 <desrt> that way you don't have to reverse it
22:45:44 <glguy_> desrt: and finally, the factorial of infinity doesn't end in zeros, it's not "defined"
22:46:01 <desrt> this is not the factorial of infinity
22:46:08 <glguy_> oh, what is it?
22:46:14 <int-e> desrt: ah. ok, that makes it less magical, and if you add a lazy multiplication primitive it'll work.
22:46:17 <desrt> the factorial of an infinite number of finite numbers
22:46:42 <desrt> int-e; only if the multiplication knows that there will be no future multiplication by 0, as glguy pointed out
22:46:45 <glguy_> the word infinite seems to have slipped back in there...
22:47:01 <desrt> glguy; if n is finite, do you accept that n+1 is finite?
22:47:21 <desrt> do you also accept that 0 is finite?
22:47:29 <desrt> if so then surely you accept that all numbers are finite
22:47:34 <desrt> and that there are infinitely many of them
22:47:34 <int-e> all natural numbers are finite.
22:47:40 <desrt> here... let me list them for you: [1..]
22:47:53 <glguy_> sweet, you still have infinitely many of these finite numbers
22:47:59 <desrt> indeed.
22:48:04 <glguy_> so...
22:48:05 <desrt> countably infinitely many
22:48:24 * int-e waits for the point
22:48:32 <glguy_> from whom?
22:48:38 <int-e> desrt.
22:48:51 <desrt> glguy_; the result of adding an infinite number of '1's to the start of a list isn't a list starting with [1,1,1,1...]
22:48:54 <desrt> it's no list at all
22:48:58 <desrt> since such a thing couldn't possibly exist!
22:49:05 <desrt> haskell doesn't seem to have a problem with this
22:49:12 <glguy_> desrt: and now you are on my side?
22:49:16 <desrt> no.
22:49:32 <desrt> i'm saying that by your argument, we ought not to be able to evaluate fix (1:) either
22:49:36 <int-e> > last $ iterate (1:) []
22:49:40 <lambdabot> Terminated
22:49:42 <glguy_> desrt: that's not what fix does
22:49:50 <desrt> > fix (1:)
22:49:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:49:54 * desrt blinks
22:49:56 <glguy_> desrt: it's adding on the end
22:49:58 <int-e> > fix (1:) <-- this does something entirely different, conceptually
22:49:58 <lambdabot>  Parse error
22:50:45 <desrt> choose your favourite way of writing an infinite list of 1s
22:50:51 <glguy_> desrt: fix (1:) is the same as ones = 1 : ones
22:50:56 <glguy_> desrt: you are adding to the end of the list
22:50:58 <desrt> glguy_; i understand
22:51:02 <dolio> > take 5 $ [1..] ++ [2..]
22:51:03 <lambdabot>  [1,2,3,4,5]
22:51:21 <desrt> the [2..] never makes it...
22:51:30 <int-e> although it might seem like the same thing - the evaluation order is different, find the 'limit' of _|_, 1:_|_, 1:1:_|_ etc.
22:51:52 <desrt> all i'm saying is that with the right multiplication optimisations in ghc it could happen
22:51:52 <int-e> where it should be noted that the 1: don't ever move.
22:51:59 <desrt> i'm not saying it has a sane theoretical basis
22:52:13 <int-e> then it won't happen in the standard libs.
22:52:20 <glguy_> it won't happen... ever?
22:52:25 <desrt> btw: the low-order 0x00 won't move either
22:52:34 <glguy_> until someone specifically optimizes the line you just entered
22:52:38 <int-e> you can write your own lib and play silly tricks with rewrite rules.
22:53:02 <desrt> i think you'd need to hack up libgmp pretty badly to get it to agree to play this silly game :)
22:53:25 <glguy_> I still maintain that "product [1..]" doesn't have a defined last digit
22:53:46 <desrt> still talking theory?
22:53:57 <glguy_> practice and theory both
22:54:20 <desrt> well, i'm afraid you have me on at least practise
22:54:25 <desrt> since currently, it most certainly does not work :)
22:54:30 <glguy_> product [1..huge number] has a defined last digit
22:54:46 <desrt> what about pi?
22:55:02 <int-e> pi has no defined last digit either
22:55:03 <glguy_> no, pi doesn't have a last digit either
22:55:14 <desrt> it's this weird infinite sum that just happens to have its first few digits stablise quickly
22:55:24 <desrt> you'd say those digits are defined
22:55:42 <desrt> product [1..] is just a weird infinite product that happens to have its last few digits stabilise quickly
22:56:03 <int-e> you *can* define the last digit of product [1..] if you like - it's coincidential that it works and doesn't seem useful, but you can do it.
22:56:31 <desrt> right.  i'm fine with that
22:56:42 <desrt> i'm not suggesting that the things i say are even vaguely useful :)
22:56:59 <int-e> and it's a non-standard definition as far as I know.
22:57:02 <desrt> seems like an awful waste of effort to produce confusing and possibly annoying results :)
22:59:12 <desrt> man... i'm in a good mood to fight
22:59:22 <desrt> did you know that there are countably many real numbers?
22:59:41 <falconair> hi, i understand that bytestring in ghc 6.6 are suppose to improve the performance of text manipulation; however, can bytestring be used for any binary data read from the disk or is it only optimized for text?
23:00:09 * lispy waves
23:00:11 <dolio> Are you from sci.math or something? :)
23:00:18 * desrt chuckles
23:00:29 <tmoertel> dons: now w/ colorized Haskell: http://blog.moertel.com/articles/2006/10/31/introductory-haskell-solving-the-sorting-it-out-kata
23:00:32 <lambdabot> Title: Introductory Haskell: Solving the Sorting-It-Out Kata, http://tinyurl.com/y3l23z
23:00:34 <desrt> i just have a bad attitude about things that are big
23:00:42 <lispy> desrt: yeah, there are uncountably many subsets of the reals with countably many elements!
23:01:01 <Ulfalizer> i guess you can't just use intuition and say that something like 1 * 1 * 1 * ... should equal 1. you need to make it well-defined, e.g. with a limit as the number of factors goes to infinity.
23:01:06 <desrt> i believe that.
23:01:47 <desrt> although maybe i shouldn't :)
23:01:50 <lispy> tmoertel++
23:02:05 <lispy> ?seen dons
23:02:05 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 15m 11s ago.
23:02:10 <dons> tmoertel: nice.
23:02:11 <lispy> ?users
23:02:11 <lambdabot> Maximum users seen in #haskell: 265, currently: 235 (88.7%), active: 17 (7.2%)
23:02:19 <dons> lispy: ^^ n.b.
23:02:20 <lispy> whoa! 17 users
23:02:28 <lispy> dons: n.b.?
23:02:36 <desrt> lispy; yes.  i think that i have to deny that what you said is true :)
23:02:36 <dons> -->  265
23:03:06 <dons> tmoertel: so is that dynamically coloured? or did you generate the coloured code offline?
23:03:08 <desrt> lispy; otherwise i give you an easy way to argue me into a contradiction :)
23:03:09 <lispy> i'm surprised only 17 are active, but i guess it is halloween in the US tonight
23:04:11 <mathewm> active
23:04:13 <mathewm> :)
23:04:59 <desrt> lispy; if reals are defined as a countably infinite string of 0s and 1s then that pretty quickly leads to an argument of bijection between the reals and the powerset of naturals
23:05:00 <lispy> desrt: stick to the rationals if you like countable things
23:05:15 <lispy> desrt: just don't let anyone close your set of rationals with approximations
23:05:27 <desrt> and if reals are countably infinite too then i have bijection between reals and naturals
23:05:37 <desrt> which now means that i have a bijection between reals and powersets of reals
23:05:48 <lispy> desrt: are you sure there is a bijection between powerset of naturals and the reals?
23:05:49 <desrt> and now i get into trouble if i let one of those things be infinite and the other not :)
23:05:56 <desrt> lispy; absolutely.
23:05:59 <lispy> desrt: i think there may be a set between them in terms of size
23:06:16 * lispy goes to get royden
23:06:21 <desrt> lispy; reals are countably infinite strings of digits
23:06:33 <desrt> lispy; let those digits be in binary
23:06:47 <dolio> Are they?
23:06:52 <desrt> now your countably infinite list of {0,1} are whether or not you include that natural number in your set
23:07:21 <tmoertel> dons: it's dynamically colored in the blog engine when I save the article text.
23:07:28 <desrt> dolio; ya
23:07:43 <lispy> desrt: are you in #math? we should move this there
23:07:44 <dons> cool. so you just wrap the code fragments in <haskell> or some such?
23:07:52 <dolio> Isn't that a bijection between the reals and the power set of naturals?
23:07:53 <desrt> lispy; i sometimes am.  not now.  i have to go to bed :)
23:07:59 <tmoertel> yup.  <typo:haskell> to be exact.
23:08:05 <desrt> dolio; yes.  it is.
23:08:06 <dons> nice
23:08:13 <desrt> 02:04 <lispy> desrt: are you sure there is a bijection between powerset of naturals and the reals?
23:08:26 <dolio> desrt: The power set of naturals has cardinality c.
23:08:27 <lispy> desrt: basically, i think you might be wrong about this powerset of naturals has a bijection to reals...i seem to recall this depending on the axim of choice
23:08:38 <desrt> dolio; no.  it doesn't. :)
23:08:54 <desrt> dolio; if i admit that then i must admit that there are uncountably many reals
23:08:55 <desrt> i refuse!
23:09:06 <dolio> It certainly doesn't have cardinality aleph0. You can prove that.
23:09:21 <desrt> dolio; i don't care for diagonalisation :)
23:09:25 <dolio> Unless you're using some non-standard set theory.
23:09:44 <desrt> my argument goes as follows: if a number exists then surely you can tell me about it
23:09:53 <desrt> [and the rest follows trivially from there]
23:10:28 * lispy goes to google it
23:10:38 <desrt> google will certainly disagree with that argument :)
23:10:40 <glguy_> Ummm.... did you guys just take the debate to #math and then paste it back here?
23:10:54 * Ulfalizer wishes he knew more about set theory
23:10:57 <glguy_> (just curious)
23:11:00 <lispy> glguy_: sorry, i'll move there now
23:11:03 <glguy_> LOL
23:11:04 <glguy_> no no
23:11:05 <lispy> glguy_: desrt didn't want to move
23:11:08 <glguy_> I don't care
23:11:08 <desrt> i'm seriously going to bed :)
23:11:19 <glguy_> I was just wondering if that was what happened
23:11:28 <Ulfalizer> there's a chapter on it in "the haskell road to logic, maths and programming", but i haven't had time to read it yet :/
23:12:22 <desrt> lispy; google gave me this: http://everything2.com/index.pl?node=power%20set
23:12:25 <lambdabot> Title: power set@Everything2.com, http://tinyurl.com/y4gc69
23:12:45 <lispy> desrt: i'm thinking of the continuum hypthesis i tihnk
23:12:45 <sieni> of course in the binary expansion, the sets whose digits are eventually zero and those whose digits are eventually one, clash, so this mapping gives you a surjection
23:12:55 <desrt> slightly more reliable resource: http://en.wikipedia.org/wiki/Cardinality_of_the_continuum
23:12:57 <lambdabot> http://tinyurl.com/y3k6a8
23:13:38 <dolio> Ah. The continuum hypothesis is that there is no set with cardinality d where |N| < d < c.
23:14:14 <dolio> Or, the generalized continuum hypothesis is that for all n, 2^aleph_n = aleph_(n+1)
23:14:27 <desrt> i don't think that's true.  not provably, anyway.
23:14:37 <dolio> Which, I suppose is true in desrt's system, since they're all aleph_0. :)
23:14:43 <desrt> certainly not without Choice.  possibly, not even with it.
23:14:49 <lispy> that's why the are hyptheseses :)
23:14:57 <lispy> and one of them is unprovable
23:15:04 <lispy> proven to be unprovable, but i forget which
23:15:19 <dolio> Yeah, the continuum hypothesis has (I think) been proven to be orthogonal to the rest of set theory.
23:15:29 <sieni> both of them have been proven independent of set theory
23:15:32 <desrt> dolio; including Choice?
23:15:35 <dolio> So you can either accept it, or reject it, and it doesn't cause contradictions.
23:15:42 <dolio> I think so.
23:15:47 <desrt> cool
23:15:52 * desrt wasn't sure about that before
23:15:55 <lispy> well, that's not the axiom of choice which is what i thought you meant :)
23:15:59 <sieni> that Con(ZF) -> Con(ZFC + AC) (Gdel, 1936) and
23:16:23 <sieni> Con(ZF) -> Con(ZFC + ~AC) (Paul Cohen, 1963)
23:16:29 <desrt> right
23:16:38 <sieni> The latter result earned Cohen a Fields medal in 1966
23:16:58 <desrt> but Con(ZF) -> Con(ZF + continuum hypothesis) and Con(ZF) -> Con(ZF + ~continuum hypothesis)?
23:17:20 <desrt> (and more importantly, same for ZFC)
23:17:21 <sieni> yes
23:17:25 <desrt> nice.
23:17:46 <lispy> ah yeah continuum hypotheses is unprovable
23:17:51 <desrt> math night in #haskell is mad awesome
23:17:57 <theoco> sleepy time now, but Ill be back
23:17:58 <desrt> we need to do this more often :D
23:18:03 <desrt> see y'all later
23:20:07 <desrt> actually... one more thing
23:20:17 <desrt> how exactly does one go about proving that a set of axioms is consistent?
23:20:43 <desrt> or, more to the point, proving that consistency is maintained across the adding of a new axiom...
23:20:45 <lispy> edwardk_: did you see the thing on LtU, "Specifying ECMAScript via ML"?
23:20:51 <lispy> edwardk_: sounds like something you'd like
23:21:22 <lispy> desrt: i forget, but the bottom line is that it's tricky and hard
23:21:29 <dolio> http://en.wikipedia.org/wiki/Forcing
23:21:37 <dolio> I think that's how they do it in many cases.
23:21:59 <Ulfalizer> what does it mean for a set of axioms to be consistent? that no axiom contradicts another?
23:22:01 <desrt> oh.  this is beyond elite.
23:22:03 <sieni> desrt: well the Gdel's result is much easier
23:22:26 <desrt> Ulfalizer; essentially, that no grounded line of reasoning in the logic can lead you to conclude falsehood
23:22:44 <Ulfalizer> ok, makes sese
23:22:46 <Ulfalizer> +n
23:22:47 <sieni> or rather contradiction
23:23:13 <desrt> sieni; well... proving that A+B and A+(~B) are both consistent pretty much is exactly the same as saying B is unprovable under A
23:23:26 <desrt> nice duality there :)
23:23:40 <desrt> i guess gödel comes at it from the other side?
23:23:53 <sieni> desrt: well, actually it would be that B is unprovable from A if and only if A+(~B) is consistent
23:24:25 <desrt> well.. i'm saying that B is neither provable or provably incorrect
23:24:33 <desrt> *nor
23:24:52 <edwardk_> lispy: yeah, i'm on the ecmascript standards discussion list. its kinda neat, but it cuts the need to do an implementation in haskell out from under me ;)
23:24:59 <sieni> desrt: Gdel uset the constructible universe: http://en.wikipedia.org/wiki/Constructible_universe
23:25:00 <desrt> i guess i should be more precise if we're talking about such things :)
23:25:01 <lambdabot> http://tinyurl.com/y43jun
23:25:28 <desrt> man
23:25:37 <desrt> wikipedia + math + 2:30AM is the reason i never make it to my early classes :(
23:25:39 <edwardk_> lispy: they finally standardized on SML/NJ and are only using continuations for the generator part.
23:26:46 <Ulfalizer> desrt: don't complain. it's 8.30 am here, and i have a lecture in 2 h :/
23:27:00 <Ulfalizer> (and i haven't slept)
23:27:12 <desrt> my lecture is 1h after 8.30.  i'll complain all i like :)
23:27:17 <sieni> desrt: but gdel's argument is approximately this: assume ZF is true and take the collection of all the sets that you absolutely have to take if you want to have a class of sets that contain the ordinals and satisfy the axioms of ZF
23:27:33 <dolio> :) It's your own fault for taking classes before noon.
23:27:36 <lispy> edwardk_: hmm...
23:27:46 <sieni> desrt: then you suddenly notice that actually this class of sets satisfy both the axiom of choice and generalized continuum hypothesis
23:27:50 <desrt> it's an interesting class
23:27:54 <Ulfalizer> you still have a chance to get 7 h of sleep, theoretically.. :P
23:27:57 <desrt> computational complexity
23:28:01 <lispy> edwardk_: i hate it when you have your heart set on making something cool, and someone releases something different but equally cool before you can finish :)
23:28:03 <edwardk_> lispy: they were originally going go to with ocaml *shudder* =)
23:28:07 <desrt> it's getting a little bit boring now... talking about resolution
23:28:20 <desrt> i wish we spent more time talking about stuff like this but it's a little bit out of scope
23:28:44 <edwardk_> lispy: is ok, the month it took for me to get a response on a core issue for my implementation kind of put me off working on it
23:29:01 <edwardk_> that and they've completely rebuilt the specification since then
23:29:18 <edwardk_> so anything i built would have had to have been rebuilt anyways
23:29:41 <desrt> man
23:29:47 <desrt> gödel was hot shit
23:30:29 <desrt> oh man... my prof told a great joke in class today
23:30:42 <lispy> edwardk_: why do they bother standardizing javascript, MS won't get around to implementing it till about 12 years after the fact
23:30:58 <desrt> there was some university that _didn't_ have gödel on their stuff
23:31:06 <desrt> but they had kleene
23:31:26 <desrt> so they used to have as their motto: the next best thing to gödeliness is klenneliness
23:31:40 <desrt> ha ha ha!
23:31:42 <lispy> heh
23:31:45 <dolio> Wow.
23:32:01 <edwardk_> lispy: i think they are hoping for a tail wagging the dog effect, and to be fair, microsoft actually has a better implementation of the proposed ecma 4 specification that netscape does in the form of microsoft jscript ;)
23:32:11 <edwardk_> s/that/than/
23:32:34 <lispy> edwardk_: don't get me started on firefox :)
23:32:53 <edwardk_> so microsoft probably has the least amount of retooling to do if ecmascript 4 goes out the door in a state close to its current design.
23:33:26 <edwardk_> its gone very far towards the jscript/actionscript model, types, templates even, interfaces, classes, etc.
23:33:43 <edwardk_> they just added a few features to gradually erode away the power of eval
23:33:57 <edwardk_> and to improve variable scoping, etc.
23:35:00 <edwardk_> if i could have just sold dave herman on the idea of \ for lambda expressions =)
23:35:09 <edwardk_> so close
23:35:13 <edwardk_> well, not really
23:35:25 <edwardk_> they know their core audience, and nothing that looks like a lambda will slip through ;)
23:37:02 <lispy> i have no idea why lambdas are not popular
23:37:10 <lispy> it seems irrational to me
23:37:46 <dolio> Because they're not called "funster". :)
23:38:00 <lispy> heh
23:43:22 <glguy_> lol: Either Trick Treat
23:43:39 <dolio> Yeah, that mail was quality.
23:44:36 <desrt> my problem is that it considers unsafePerformIO to be an instance of slaying a monster (as opposed to what most people would consider as creating one)
23:44:43 <ValarQ> glguy_: :)
23:45:21 <glguy_> and fuck people that put question marks in headlines so that they don't have to actually verify them
23:45:57 <glguy_> "Has Rails peaked?" means I actually have no idea, but I'm going to write some crap about it
23:46:33 <dolio> Heh.
23:46:41 <dolio> "No, it hasn't. End of blog."
23:46:56 <glguy_> I don't care either way if RoR lives or dies, but I do hate stupid headlines
23:47:09 <lispy> glguy_: huh?
23:47:36 <glguy_> lispy: I'm bitching about a programming.reddit.com link to a blog
23:47:58 <kfish> glguy_, that's right, none of this discussion starting wet-blanket waving pussyfooting, we need bloggers with real _conviction_ about the crap they write
23:48:18 <glguy_> There is so much Haskell stuff on that page that it might as well be another Haskell site ;) and therefore it seemed on topic
23:48:54 <lispy> glguy_: ah yeah, i marked it down because ididn't like the title either
23:49:46 <dolio> What if it's an "ask reddit" entry?
23:49:55 <dolio> Not that I understand why you'd want to do that.
23:49:57 <Ulfalizer> heh, i found a 22 character haskell solution to a lisp homework assignment a friend of mine has :)
23:50:00 <desrt> "has rails peaked?  i have proof, but it's too large to write in the margin."
23:50:19 <glguy_> heh
23:50:22 <glguy_> stfu fermat
23:50:31 <desrt> :)
23:50:36 <dolio> Same with ask slashdot.
23:50:41 <Ulfalizer> a function that given a list of lists gives all combinations with one element taken in order from each list
23:50:49 <lispy> rails was all hype, of course it peaked
23:51:08 <lispy> very good way for a small company to get its name out, regardless of what happens to rails
23:51:13 <lispy> .
23:51:16 <Ulfalizer> f []=[]   f x=sequence x  =)
23:51:37 <desrt> certainly a possible type.
23:51:43 <dolio> > sequence []
23:51:44 <lambdabot>  add an instance declaration for (Show (m [a]))
23:51:54 <lispy> ?type sequence []
23:51:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
23:52:07 <dolio> > sequence [] :: http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int
23:52:08 <lambdabot>  Parse error
23:52:10 <lambdabot> http://tinyurl.com/yxdsu8
23:52:14 <glguy_> > sequence [] :: [[()]]
23:52:15 <lambdabot>  [[]]
23:52:21 <desrt> wtf!!
23:52:21 <dolio> What the ...
23:52:28 <desrt> hahah
23:52:30 <desrt> dolio; jinx
23:52:44 <desrt> ?type sequence
23:52:45 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
23:52:54 <desrt> oh.  of course.
23:53:09 <dolio> Evidently my chat client turns double-bracketed things into wikipedia searches...
23:53:31 <glguy_> [[tubgirl]]
23:53:31 <Syzygy-> dolio: Hahaha!
23:53:40 <desrt> > sequence [Just 1, Just 2]
23:53:42 <lambdabot>  Just [1,2]
23:53:54 <desrt> > sequence [Just 1, Nothing, Just 2]
23:53:55 <lambdabot>  Nothing
23:54:01 * desrt eyebrow raise
23:54:01 <Ulfalizer> > sequence [[1, 2, 3], [6, 7, 8]]
23:54:03 <lambdabot>  [[1,6],[1,7],[1,8],[2,6],[2,7],[2,8],[3,6],[3,7],[3,8]]
23:54:06 <Ulfalizer> :)
23:54:10 <desrt> that one is boring.
23:54:23 <desrt> although it brings light to why mine does not work
23:54:45 <glguy_> > sequence [ [] , [1] ] -- just like this one
23:54:46 <lambdabot>  []
23:55:01 <desrt> but of course.  0 * 1 is still zero :)
23:55:47 * desrt hates when he builds lists of lists using the list monad and accidentally puts [] instead of [[]] as the base case
23:55:55 <dolio> [[test]]
23:55:56 <desrt> always takes me a good long time to figure out :(
23:56:40 <lispy> ?type [] :: [[Int]]
23:56:42 <lambdabot> [[Int]] :: [[Int]]
23:56:49 <lispy> ah yeah, so [] always works?
23:56:59 <desrt> ya.  of course
23:57:06 <desrt> it's the empty list of lists of lists of ints
23:57:11 <glguy_> [] is a list of no values of type a ;)
23:57:14 <desrt> you can't possibly express [] any other way
23:57:25 <desrt> [[]] for example is definitely not [] :)
23:58:02 <desrt> > []:[]
23:58:03 <lambdabot>  Add a type signature
23:58:08 <desrt> bite me.
23:58:22 <dolio> ?type (([] :: [Int]):[]:[]:[])
23:58:23 <lambdabot> [[Int]]
23:58:42 <Smokey`> hmm, anyone think they could give me some insight on how one might go about onverting [(Foo 1 2 3),(Foo 4 5 6)] into [1,2,3,4,5,6]    I think i'ma gonna go nuts with all these crazy list comprehensions i've come up with :/    Much to learn, I still have.
23:58:46 <desrt> Prelude> :t ([]:[])
23:58:46 <desrt> ([]:[]) :: [[a]]
23:58:49 <desrt> :)
23:59:10 <desrt> Smokey`; is Foo a data constructor?
23:59:11 <glguy_> lambdabot should say "stfu noob" instead of "Add a type signature" similar to how "No IO" used to be "Pervert!"
23:59:21 <Smokey`> desrt: yes
23:59:36 <desrt> use (\Foo a b c -> [a, b, c]) and >>=
23:59:53 * glguy_ wonders how >>= factors in
23:59:58 <glguy_> duh
