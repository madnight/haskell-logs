00:01:15 <thou> it works!  Control.Exception.MonadIO (gbracket) + instance declarations for CGIT and WriterT, and i now have a bracket around my IO ops that I can use in the CGIT monad
00:03:00 <thou> BUT, i still need deepSeq to make HDBC work correctly; otherwise it disconnects before fetching the results, and returns an error
00:03:46 * thou considers using takusen instead, but it seems to work w/ ghc 6.6 only?
00:05:22 <dons> thou: yeah, fair enough .the deepSeq makes sense there
00:05:44 <dons> similar to the issue of measuring and timing out computations -- you need control over eval order sometimes
00:05:53 <dons> glad you got your bracket lifted
00:05:59 <thou> i still think HDBC is broken
00:06:04 <thou> but don't know how to defend that position
00:06:33 <thou> getContents doesn't croak if I use it from the CGI monad w/ bracket
00:07:11 <thou> it doesn't close the file before trying to read from it
00:07:25 <thou> me too, i'm stoked about the gbracket.
00:08:22 <thou> hmmm
00:14:17 <Lemmih> thou: getContents works if you close stdin before using the data?
00:14:56 <thou> Lemmih: let me find the test case i had...
00:15:22 <musasabi> morning
00:16:37 <thou> Lemmih:  http://www.haskell.org/pipermail/haskell-cafe/2006-August/017298.html
00:16:39 <lambdabot> Title: [Haskell-cafe] Strictness, order of IO operations: NewCGI & HDBC, http://tinyurl.com/y28f5y
00:17:06 <thou> first test case uses HDBC; second has same exact structure, but uses  ... oops, hGetLine
00:17:11 <thou> :-(
00:17:26 <Lemmih> thou: Try with hGetContents and it will fail.
00:17:31 * thou will test with hGetContents (damn, stupid mistake)
00:17:48 <Lemmih> thou: You can use fetchRow with HDBC and it'll work like your example with hGetLine.
00:19:01 <Lemmih> Oh wait, actually you cant. Fetching the tables requires some backend specific SQL.
00:21:08 <thou> it doesn't matter so much with a list of tables (for me, at least, i won't have so many tables that deepSeq will hurt)
00:24:26 <glguy> dons: do you use xdm?
00:25:01 <dons> sure
00:25:10 <glguy> that explains why you use .xsession
00:25:15 <dons> ah right.
00:25:19 <glguy> and I use startx
00:25:21 <dons> so it does.
00:25:23 <glguy> which explains .xinitrc
00:44:40 <glguy> figuring out the firewall rules for a laptop is easy :)
00:44:54 <thou> ok
00:45:02 <thou> well, i've learned a ton on this
00:45:05 <thou> so it was worth it
00:45:22 <thou> i can now use deepSeq without feeling like I'm cheating
00:45:24 <thou> :-)
00:45:45 * thou feels stupid for using hGetLine instead of hGetContents, though!
00:46:43 <thou> i'm sure it's not the last dumb mistake like that I'll make
02:05:30 <yain> hi.
02:18:09 * araujo uploading a page for himerge
02:25:44 <araujo> haskell.org down?
02:27:46 <velco> looks like it
02:30:08 <araujo> argh
02:32:27 <dmhouse> In the list with type HTML h => [h], are all the elements necessarily of the same type?
02:32:27 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
02:32:59 <dmhouse> Would I need, e.g. [HTML h => h] for a truly polymorphic list?
02:33:07 <JohnMeacham> howdy.
02:33:37 <dmhouse> Hrm. Let's see.
02:33:48 <dmhouse> > [1, 5, "foo", True] :: Show s => [s]
02:33:49 <lambdabot>  s
02:33:49 <lambdabot>    Inferred type: [Char]
02:33:49 <lambdabot>   In the list element: "foo"
02:33:49 <lambdabot>   In the exp...
02:34:13 <dmhouse> Okay, so I probably need a newtype wrapper there.
02:34:25 <dmhouse> But will that produce a heterogeneous list?
02:40:17 <roconnor> hmmm, this fill memory balance problem is difficult.
02:50:38 <thou> dmhouse: http://homepages.cwi.nl/~ralf/HList/
02:50:39 <lambdabot> Title: Strongly typed heterogeneous collections
02:51:06 <vincenz> Interesting page: http://steve.yegge.googlepages.com/is-weak-typing-strong-enough
02:51:10 <lambdabot> Title: Stevey's Home Page - Is Weak Typing Strong Enough?Â, http://tinyurl.com/y37l7p
02:51:11 <vincenz> dmhouse: hey, been a while
02:51:40 <dmhouse> thou: that's overkill, really. I just want a list whose elements may be heteregeneous, but all instantiate HTML.
02:51:44 <dmhouse> vincenz: hi there. :)
02:51:52 <vincenz> dmhouse: do you use any dyn-typed langs?
02:51:57 <vincenz> Besides english
02:52:44 <dmhouse> vincenz: not at the moment. I've used PHP before I came to Haskell, though. Why?
02:52:54 <vincenz> Just curiousy
02:53:26 <dmhouse> If I put {-# OPTIONS_GHC -fglasgow-exts #-} at the top of my Main.hs, will that apply for all modules or do I have to place the pragma at the top of every module that requires the extensions
02:55:03 <JohnMeacham> > let x = x in x
02:55:04 <lambdabot>  Add a type signature
02:55:18 <vincenz> dmhouse: gotta put it in each .hs
02:55:26 <JohnMeacham> > let x = x; x :: Int in x
02:55:27 <lambdabot>  Exception: <<loop>>
02:55:38 <JohnMeacham> my plot! foiled!
02:56:01 <JohnMeacham> > let f x y = f y x in f 'x' 'y'
02:56:02 <lambdabot>  Add a type signature
02:56:02 <Syzygy-> dmhouse: Otherwise you'd end up having modules change behaviour depending on where they get included...
02:56:17 <JohnMeacham> > let f x y = f y x; f :: Char -> Char -> Char  in f 'x' 'y'
02:56:18 <lambdabot>  Exception: <<loop>>
02:56:32 <JohnMeacham> I am foiled.
02:56:55 <ihope> > let run (x:xs) = run xs; run [] = () in run [1..]
02:56:59 <lambdabot> Terminated
02:57:08 * ihope wins :-P
02:57:34 <JohnMeacham> > readFile "/etc/passwd"
02:57:35 <lambdabot>  No IO allowed
02:58:10 <Syzygy-> Does this mean lambdabot doesn't call you a pervert any more?
02:59:18 <ihope> > unsafePerformIO# (readFile "/etc/passwd")
02:59:19 <lambdabot>  Not in scope: `#'
02:59:29 <ihope> Hmm. Interesting.
02:59:57 <xerox> JohnMeacham!  You're alive!  :)
03:00:51 <Cale> Syzygy-: it didn't do that for very long :)
03:01:22 <Syzygy-> Cale: Almost every time so far that I've been bad to the lambdabot, it has called me a pervert...
03:01:33 <Syzygy-> Must have found the window it did so with some precision...
03:01:35 <xerox> @arr
03:01:36 <lambdabot> Aye Aye Cap'n
03:01:59 <JohnMeacham> xerox: was there doubt?
03:02:08 <roconnor> @vixin wanna come over to my place?
03:02:08 <lambdabot> nevermind about that
03:02:10 <xerox> JohnMeacham: long time no see, how was the bman?
03:02:22 <JohnMeacham> most excellent.
03:02:28 <JohnMeacham> highly recommended.
03:02:37 <xerox> Cool :)
03:03:27 <JohnMeacham> yes. I played strip jeapordy.
03:03:48 <xerox> No idea what that is.
03:03:54 <JohnMeacham> perhaps that wasn't the highlight. but OMG. it was an amazing experience.
03:04:04 <xerox> hehe
03:06:12 <Syzygy-> Strip Jeopardy?! Sounds like fun....
03:06:18 <araujo> haskell.org back!
03:06:24 <araujo> morning all
03:06:46 <JohnMeacham> of course it is fun.
03:06:58 <Syzygy-> Only, I probably will outgeek everyone if I end up at such a thing: "The universal objects corresponding to bilinear maps"
03:07:42 <JohnMeacham> no, one of the categories was star trek, my friend was awesome. he not only knew the answers, but the actors names who played the answer. and their spouses. for random bit parts.
03:08:27 <Syzygy-> Hehe
03:09:37 <xerox> Crazy :)
03:14:26 <vincenz> what about random byte parts?
03:15:39 <vincenz> w
03:37:19 <dibblego> a haskell plugin for intellij idea would rock - I have some basic syntax highlighting - might release it under BSD licence
03:37:40 <beelsebob> what's intellij???
03:37:55 <velco> a company
03:38:07 <dibblego> jetbrains is the company
03:38:13 <dibblego> intellij is a brand
03:38:35 <dibblego> it is a Java IDE that rocks - apparently there is a lisp plugin
03:40:57 * beelsebob downloads it to have a stare
03:41:04 <beelsebob> I'm not holding much hope of it beating XCode
03:47:03 <vincenz> BCoppens: how do you get your hostname set up like that
03:58:06 <vincenz> BCoppens: how do you get your hostname set up like that
03:59:02 <jmmv> hi
04:00:52 <velco> vincenz: http://freenode.net/faq.shtml#projectcloak
04:03:19 <vincenz> ah thanks
04:04:43 <Smokey`> God I love haskell...
04:05:12 <vincenz> Smokey`: what now
04:05:55 <lambdabot> Title: freenode: frequently-asked questions
04:06:24 <Smokey`> vincenz: What do you mean 'what now'?   Just makign a comment on how I love haskell :
04:06:24 <Smokey`> :/
04:06:59 <Pete_I> oh no, now everyone will be /overcome/ with enthusiasm :)
04:07:47 <Smokey`> heh, I guess next time I should know better than to make any positive comments.
04:10:39 <Pete_I> positive's better than negative :)
04:11:00 <Pete_I> 'course, any random negative comments would be shot down as trolling
04:11:27 <Pete_I> positve'd just be thought of as strange
04:12:51 <araujo> http://www.arjox.org/himerge.html
04:12:52 <lambdabot> Title: arjox
04:13:07 <araujo> suggestions welcome :-)
04:15:28 <gour> araujo: very nice
04:16:00 <araujo> gour, :-)
04:16:43 <gour> araujo: we need gtk2hs build
04:18:09 <araujo> ya
04:18:49 <araujo> Let me get the food for my cat and some caffeine for me and i could give it a try
04:18:51 <araujo> :-)
04:19:56 <vincenz> Smokey`: I was just curious what prompted the statement :)
04:22:15 <expwiz> Hi. I'm new to haskell and I'm used to object-oriented languages such as C++. I find the transition a bit difficult sometimes. Say I want to organize some kind of data in two different ways (for whatever reason), I would create two different kind of data-structures. But the same data can't be shared.. So how do I handle this problem with data "sharing"?
04:23:10 <Lemmih> I don't understand the question.
04:23:10 <Smokey`> vincenz: rewriting my ray tracer, in Haskell... it's going soo smoothly :)  not a single hickup (and i'm learning along the way), soo fast, soo elegant.
04:23:56 <vincenz> Smokey`: ah, nifty :)
04:24:00 <vincenz> Smokey`: from what language
04:24:19 <expwiz> In C++ i could have object A and put it in a list, a queue, a tree etc. and the data would be shared among the datastructures..
04:24:41 <vincenz> expwiz: in haskell you can too
04:24:50 <vincenz> but sharing is kinda a moot point when you have referential transparencey
04:25:13 <Smokey`> vincenz: C++ (not really a direct port, just writing a ray tracer in haskell that should theoretically be very similar to my C++ one...)
04:25:24 <greenrd> expwiz: The problem is not with data sharing, the problem is with data updating, right?
04:25:41 <expwiz> greenrd: yes.. propably :)
04:25:53 <greenrd> Has anyone used the Explicit Haskell Compiler?
04:26:33 <greenrd> It seems to have a surprising number of features that I would like to see or presently implement myself using source preprocessing
04:26:54 <velco> url?
04:26:59 <greenrd> Unfortunately no mention of GADT support yet
04:27:03 * vincenz nods at Smokey` 
04:27:18 <greenrd> http://www.cs.uu.nl/wiki/Ehc/WebHome
04:27:20 <lambdabot> Title: Ehc / Web Home
04:27:30 <greenrd> OK, it's actually called Essential Haskell Compiler
04:27:33 <velco> it's Essential
04:27:43 <velco> that's why couldn;t find it in google ...
04:27:45 <greenrd> but it implements an extended subset of Haskell
04:28:00 <greenrd> which allows explicit class dictionary manipulation
04:28:16 <expwiz> I can give an example: I want to organize objects spatially in some bounding volume hierarchy in order to optimize spatial operations such as collision detection. These spatial objects also have a transform, I want to organize the same objects in a transform hierarchy.. I have no idea how to do this. In C++ I can think in terms of objects and relations.. I have problems with how to think when designing haskell programs.
04:28:58 <araujo> mmm...
04:29:38 <araujo> expwiz, I like to think in terms of Types
04:30:02 <greenrd> expwiz: You could store e.g. indices into an array in your data structures, and store the "objects" themselves in the array
04:30:04 <araujo> I think that'd be the equivalent to your way of thinking here.
04:30:31 <greenrd> expwiz: Kind of a "pointery" way of doing things, but without so much unsafety
04:31:23 <expwiz> araujo: ok
04:32:22 <ThreeQ> why not just store the data themselves?
04:33:04 <expwiz> greenrd: yes. indices would probably work..
04:33:06 <ThreeQ> everything in haskell is a reference, right?
04:33:07 <greenrd> ThreeQ: The point is you could then update the objects in the array once each, rather than having to update multiple copies of them. If updates are not needed, my approach is useless.
04:33:20 <ThreeQ> oh, I see
04:35:02 <ThreeQ> yeah, I guess an array would be best here
04:37:03 <ThreeQ> you probably want STArray
04:38:22 <expwiz> ThreeQ: Ok. is it part of the standard library?
04:38:47 <ThreeQ> ?docs Data.Array.ST
04:38:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-ST.html
04:38:50 <roconnor> I don't understand why use STArrays?
04:39:02 <roconnor> I don't see any updates in this problem.
04:39:25 <ThreeQ> roconnor: the updating is the whole point, or at least that's how I'm understanding it
04:39:42 <roconnor> ThreeQ, where is the updating?
04:40:07 <expwiz> roconnor: The transform hierarchy updates the transform of child objects whenever the transform is changed
04:40:29 <roconnor> why are the transformations changed?
04:41:04 <expwiz> roconnor: the transformations change whenever an object transforms, for whatever reason.
04:41:44 <roconnor> but this is important, how can a transformation change? and in what way?  Are you doing animation?
04:41:58 <roconnor> I ask because often there is a functional way to get around these things
04:42:08 <roconnor> an approach that would never work in C++
04:42:27 <roconnor> and something that is often hard to see without experience.
04:42:41 <expwiz> roconnor: ok I understand.
04:43:21 <roconnor> so, for instance, if you are doing an antimation, you can store a function Time -> Transform at each node
04:43:35 <roconnor> and then you can have a static data structure.
04:43:58 <roconnor> oh wait
04:44:01 <roconnor> I understand now
04:44:19 <roconnor> the transforms will mean rearranging the bounding hierarchy
04:44:39 <expwiz> yes.
04:44:52 <roconnor> gosh
04:45:51 <Philippa> Smokey`: boo. Uni started again?
04:47:26 <Smokey`> Philippa: no, infact it'll be finishing in 2 weeks.
04:47:42 <Smokey`> this is purely for learning purposes.
04:48:04 <Philippa> cool
04:48:40 <Smokey`> speaking of which, if I have 'a' of type Maybe,  how would I go about checking if it is infact something?  (If a /= Nothing ... else ... ?)
04:49:00 <roconnor> >type isJust
04:49:03 <Philippa> case a of {Nothing -> foo; Just x -> bar}
04:49:03 <roconnor> @type isJust
04:49:05 <lambdabot> forall a. Maybe a -> Bool
04:49:18 <roconnor> @type isNothing
04:49:20 <lambdabot> forall a. Maybe a -> Bool
04:49:20 <Philippa> or you can use isJust, yeah
04:49:31 <greenrd> @hoogle maybe
04:49:32 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
04:49:32 <lambdabot> Maybe :: module
04:49:32 <lambdabot> Prelude.Maybe :: data Maybe a
04:49:46 <Philippa> personally I tend to do the pattern match by hand because Maybe's such a simple type though
04:49:49 <greenrd> I use the maybe function a lot
04:49:55 <greenrd> it's convenient
04:50:09 <Smokey`> sweet, thanks guys =)
04:58:32 <Baughn> @type maybe
04:58:33 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:59:25 <Adamant> @type FastAndBulbous
04:59:26 <lambdabot> Not in scope: data constructor `FastAndBulbous'
04:59:38 <Adamant> @type Also
04:59:39 <lambdabot> Not in scope: data constructor `Also'
05:00:19 <Adamant> @type also
05:00:20 <lambdabot> Not in scope: `also'
05:27:39 <Dr4g4n0v> how i can get an index in list cmprhensive while im running on the list
05:27:40 <Dr4g4n0v> [(keyword,["aa"])| keyword <-ks, i <- [0..length ks], elem keyword keywords]
05:28:09 <Dr4g4n0v> is it possible ?
05:29:26 <twanvl> You can use either parallel list comprehension (which only works in ghc), or you can use zip:
05:30:05 <twanvl> [ (keyword,["aa"]) | (keyword, i) <- zip ks [0..], keyword `elem` keywords ]
05:30:32 <Dr4g4n0v> briliant thanks :)
06:06:28 <xerox> @spell sneed
06:06:29 <lambdabot> Sneed Snead scened send saned
06:06:38 <xerox> Ah, it's not a typo.  What does it mean?
06:06:55 <lightstep> @dict sneed
06:06:55 <lambdabot> Supported dictionary-lookup commands:
06:06:55 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
06:06:55 <lambdabot> Use "dict-help [cmd...]" for more.
06:06:59 <xerox> ``With the foregoing semantics one sneed not reject the existence of Curry sentences ...''
06:07:12 <xerox> I still think that is a typo there.
06:10:59 <ndm> yeah, thats a typo
06:27:58 <roconnor> > recip 1.125
06:27:59 <lambdabot>  0.8888888888888888
06:28:27 <roconnor> > recip 1.105
06:28:28 <lambdabot>  0.9049773755656109
06:31:51 <dmhouse> I'm trying to use the type synonym 'type Breadcrumbs = forall h. HTML h => Seq h', but GHC complains about an 'Illegal polymorphic or qualified type'.
06:32:05 <Patterner> > recip chocolate muffins
06:32:05 <lambdabot>  Not in scope: `muffins'
06:32:12 <dmhouse> Any reason why that would be so? From the GHC User Manual I can't see any reason why it should be refused.
06:32:43 <dmhouse> Indeed, one of the examples they give under the 'Liberalised type synonyms' page is   type Discard a = forall b. Show b => a -> b -> (a, String)
06:32:59 <xerox> h does not appear in the left hand side?
06:33:00 <ndm> arrrggh, has anyone seen how read :: Int is implemented underneath! its horrible!
06:33:11 <dmhouse> xerox: it's existentially quantified.
06:33:30 <xerox> Scary quantifiers.
06:33:39 <lightstep> ndm, through readNum?
06:34:05 <ndm> lightstep: through readInt, readSigned etc.
06:34:21 <ndm> lightstep: just a lot of crap that isn't reading the numbers!
06:36:28 <dmhouse> xerox: not that scary.
06:37:41 <xerox> dmhouse: still raise your exception :)
06:37:57 <lightstep> ndm, readInt is not complicated
06:38:33 <lightstep> readSigned contains rarely-used features, but its purpose is to parse the same syntax as haskell
06:38:39 <ndm> lightstep: its pretty complex
06:39:05 <lightstep> only because they use list comprehensions
06:39:07 <dmhouse> Hrm, apparently, it's a valid type, but when I try to embed it into a record, it borks.
06:40:24 <xerox> dmhouse: Discard is just Show a => a -> String really, which is indeed legal.
06:40:30 <ndm> and foldl's, map's, lots of things when its a realtively simple operation to perform
06:40:44 <lightstep> compiling into .net doesn't seems like much fun
06:41:16 <ndm> compiling it into a first order language is also not massively fun!
06:41:56 <dmhouse> xerox: my type is legal, too, but when I give a field of a record that type, I get the error.
06:42:01 <lightstep> the main part of readInt is foldl1 (\n d -> n * radix + d), which is very clear. the rest is noise
06:42:04 <Smokey`> what's the closest thing to abstract classes in Haskell (I'm assuming class/instance stuff) ?
06:42:34 <Codex_> smokey: type classes.
06:43:31 <xerox> dmhouse: does it work newtyping it?
06:44:13 <ndm> lightstep: exactly, thats my point - there is an awful lot of noise
06:45:15 <psnl> ndm: would a hat bug tracker be useful?
06:45:45 <ndm> psnl: i considered that, my opinion, yes, but i think other developers would prefer "memo's" and other outdated ways of tracking bugs
06:45:49 <lightstep> yes, it's another failure of the Num heirarchy
06:46:00 <ndm> psnl: if we did, would take a second to start doing it with the google bug tracker
06:47:05 * psnl just kept a list on a piece of paper for the last big project he did, and it wasn't a success
06:47:48 <xerox> Smokey`: type classes are in fact sets of types implementing some functions. Instantiating a type in a type class you're really making the type a member of that set, and implementing the functions.
06:49:13 <lightstep> it's line declaring that a class implements an interface separately from the definition
06:49:16 <lightstep> *like
06:51:23 <ndm> psnl: i think its a great idea, i was too lazy to propose it and fight through the "why not use memos", but go for it and i'll back you up!
06:52:23 <xerox> And then you have multi-parameter type-classes and functional dependencies to go nuts.
06:54:49 <psnl> ndm: my somewhat more wimpy plan was to start one and tell you about it ;-)
06:54:55 <lightstep> yeah. like interfaces for multimethods with guards on the types, but without inheritance
06:55:16 <ndm> psnl: start one, tell the whole Hat team about it, but yes, and configure the bug reports to be sent to the mailing list
06:55:25 <ndm> psnl: would you start a google code one?
06:55:27 <lightstep> (only prolog-style deduction)
06:55:34 <psnl> I'm looking at it no
06:55:46 <ndm> psnl: if you'd rather, i'll set it up - i've done two already
07:00:03 <psnl> ndm: I'm just trying to decide what licence to use; since http://www.haskell.org/hat/copyright.html appears to be a custom job
07:00:05 <lambdabot> Title: Hat copyright
07:00:24 <ndm> psnl: just put it down as GPL, and don't worry too hard
07:00:36 <ndm> psnl: since the code won't be there, its not massively important if its wrong
07:07:00 <psnl> ndm: google thinks that sf has a project called "hat", but a) their link doesn't work and b) I can't find it withthe sf search thingy. In theory google is mailing the hat people on sf.
07:07:42 <ndm> psnl: doh! haskelltracer ?
07:07:58 <ndm> psnl: or hatdebugger - to annoy Colin ;)
07:11:12 * psnl grins; I just got a 500 from google
07:14:02 <dmhouse> psnl: screenshot! :)
07:15:22 <ex0-r> how can I use map to add together the values of the fst of tuples in a list, based on a condition?
07:15:54 <ex0-r> if fst == 12 or something, add together the snd
07:16:15 <frevidar> whats the syntax for something like this: class MyClass a b?
07:16:25 <scsibug> ex0-r, since you want a single value, a fold is what you want
07:16:33 <kpreid> ex0-r: sum . map snd . filter ((==12) . fst)
07:16:43 <velco> > foldr (+) (map fst [(x, y) | x <- [1..5], y <- [1, 2]])
07:16:44 <lambdabot>  add an instance declaration for (Num [a])
07:16:53 <velco> hehe
07:17:08 <ex0-r> ah I see
07:17:33 <kpreid> frevidar: that's acceptable multi-parameter type class syntax; what do you want?
07:17:42 <velco> > foldr (+) 0 (map fst [(x, y) | x <- [1..5], y <- [1, 2]])
07:17:43 <lambdabot>  30
07:17:59 <ndm> psnl: google code does it reasonably often
07:18:21 <roconnor> wonders if it is my router or my ISP that regularly cuts all my connections
07:20:42 <dmhouse> > sum [1..5]
07:20:43 <lambdabot>  15
07:20:52 <dmhouse> Ah, I see.
07:21:06 <dmhouse> > sum [ x | x <- [1..5], _ <- [1,2]]
07:21:07 <lambdabot>  30
07:24:33 <dmhouse> Wow, existentially qualifying record fields gets you surprisingly close to an OOP style.
07:25:20 <dmhouse> All you'd need is an (#) = flip ($) so you can do things like counter#inc#inc and you're getting really close.
07:26:05 <petekaz> kfish: thanks (re: gtk2hs question on handlers)
07:28:18 <kfish> petekaz, np
07:28:26 <kfish> the following is in the gtk2hs source:
07:28:29 <kfish> --  glade_xml_signal_autoconnect() is not supported. The C variant is not
07:28:29 <kfish> --  suitable for Haskell as -rdynamic leads to huge executable and we
07:28:29 <kfish> --  usually don't want to connect staticly named functions, but closures.
07:28:49 <petekaz> ah .. I see.
07:29:18 <dcoutts> kfish, petekaz, also there's no way to introspect to hook them up anyway
07:29:42 <petekaz> I'm very new to GTK, glade, haskell, etc ... so I was just curious what those handlers in the XML file were for.
07:29:54 <dcoutts> petekaz, yeah, just ignore them.
07:30:04 <petekaz> thanks.
07:30:27 <Dr4g4n0v> Couldn't match expected type `IO a'
07:30:27 <Dr4g4n0v> against inferred type `String -> String -> IO ()'
07:30:27 <Dr4g4n0v> In the first argument of `GHC.TopHandler.runMainIO', namely `main'
07:30:27 <Dr4g4n0v> When checking the type of the main function `main'
07:30:46 <Dr4g4n0v> guys any idea what this might be ?
07:30:52 <petekaz> dcoutts: what is the minimum to rebuild the gtk2hs sources with your latest changes?  do I need to do a configure again?
07:31:07 <Lemmih> Dr4g4n0v: Your 'main' function must have the type 'IO ()'.
07:31:29 <Dr4g4n0v> main :: String -> String -> IO()
07:31:29 <Dr4g4n0v> main tempfile infofile
07:31:29 <Dr4g4n0v> = do t <- readFile ( tempfile ++ ".html" )
07:31:29 <Dr4g4n0v> i <- readFile ( infofile ++ ".info" )
07:31:29 <Dr4g4n0v> writeFile ( infofile ++ ".html" ) ( buildHtml t i )
07:31:36 <Lemmih> Dr4g4n0v: Handle arguments with System.Environment.getArgs
07:32:35 <dcoutts> petekaz, just make should do.
07:32:47 <petekaz> thx
07:34:07 <petekaz> that didn't seem to work ... Failed to load interface for `Graphics.UI.Gtk.Windows.MessageDialog', I'll just start from scratch again.
07:35:07 <dcoutts> petekaz, yeah, make clean will fix that.
07:36:53 <ndm> dcoutts, for Gtk I'd rather you _did_ break the API's
07:37:08 <dcoutts> ndm, huh?
07:37:16 <ndm> dcoutts, and keep everything getting better and cleaner with less gunk floating around
07:37:44 * gour agrees
07:37:45 <dcoutts> ndm, sure, less gunk, I'm not sure that the example of text tag was adding moer gunk
07:38:03 <dcoutts> I think having one version with a Maybe argument isn't all that nice
07:38:23 <dcoutts> I'll tell you what is better but would completely break api
07:38:25 <ndm> dcoutts, that particular example i have no idea on, its just there are a finite number of Gtk developers, and i'd rather have them making a solid product, rather than making sure some old and disused program keeps working
07:38:44 <dcoutts> thingyNew [ attr := value ]
07:38:56 <ndm> obviously in the future that will have to change, once you are really popular, but for now, break away!
07:38:58 <dcoutts> then we get optional args and setting attributes on construction
07:39:42 <dcoutts> ndm, but that'd break every object construction since it'd add another argument
07:39:45 <dcoutts> ndm, what do you think?
07:40:04 <dcoutts> it'd allow us to eliminate many varieties of constructors, and it convenient too
07:40:13 <ndm> dcoutts, i don't know enough to answer in this case, but it sounds like a good idea :)
07:40:24 <gour> any estimate how many apps written in gtkhs?
07:40:30 <ndm> dcoutts, i.e. more uniform, more convenient - good buzz words :)
07:40:37 <dcoutts> heh
07:44:49 <gds> ndm: I'm just having a first play with yhc here... It doesn't seem to like my specifying a full path to a source file... Is this me being stupid, a feature, or a bug I can hunt? ;)
07:46:49 <ndm> gds, sounds like a bug to me, hmm, thats pretty well tested
07:47:04 <ndm> gds, feel free to hunt, or mail the mailing list - i have to go now, but back in about an hour
07:47:11 <gds> Cool :)
07:56:18 <dcoutts> Woo!
07:56:19 * dcoutts has ordered a 2.4 GHz dual core amd64 as an upgrade to his 1.8GHz single core amd64
07:56:28 <gds> :)
07:56:57 <dcoutts> it's nice when you don't have to upgrade motherboards just to use a newer cpu
07:57:01 <wilx> What's the PR for 2.4?
07:57:22 <dcoutts> 4600+
07:57:39 <Lemmih> What did it cost?
07:57:43 <dcoutts> it's the 512k L1 cache, socket 939 version
07:57:53 <dcoutts> Lemmih, Â£139.99
07:57:59 <wilx> Hmm.
07:58:03 <wilx> That's huge.
07:58:16 <wilx> I want to buy that PR 3600 EE version.
07:58:58 <dcoutts> Lemmih, it actually used to be cheaper but the socket 939 versions are getting phased out
07:59:16 <dcoutts> Lemmih, but I needed that socket version otherwise I'd have to upgrade the motherboard and memory too
07:59:43 <dcoutts> so I'll get to play with SMP GHC :-)
08:00:02 <dcoutts> and be able to build GHC in less than an hour :-)
08:00:17 <xerox> Yeah!
08:00:24 <xerox> I did it one time.
08:03:07 * Lemmih was quite happy when he built GHC in less than two hours.
08:03:44 <dcoutts> I wish we could use distcc/distghc for building ghc, then I could build it on sparc using a cluster of 35 500Mhz boxes. Building on a single 500Mhz sparc box takes about 10 hours.
08:04:30 <xerox> That would get the thing done way better.
08:05:27 <Igloo> distcc should Just Work, no?
08:06:47 <roconnor> Igloo: did you solve the fill memory problem?
08:08:18 <Igloo> Don't think so
08:08:25 <Igloo> I didn't do many of them
08:10:04 <ex0-r> does haskell have an easy function to convert stuff to strings?
08:10:13 <earthy> read
08:10:14 <ex0-r> int -> string preferably
08:10:19 <ex0-r> kk
08:10:20 <earthy> owh, sorry, show. :)
08:10:21 <Heffalump> show
08:10:23 <Heffalump> :-)
08:10:32 * earthy needs to wake up from the holiday to scotland
08:10:44 <dcoutts> Igloo, yeah, distcc would do for the c bits, but that's only part of it of course.
08:10:52 <Igloo> Right
08:11:30 <Heffalump> where did you go?
08:11:47 <earthy> Tomintoul, Glenlivet Estate
08:12:06 <Heffalump> never heard of it :-)
08:12:21 <earthy> with a dangerous distillery a 10 minute walk away ;)
08:12:48 <Heffalump> dangerous as in prone to explode, or as in leading you into temptation?
08:13:11 <gds> @google Glenlivet
08:13:11 <Dr4g4n0v> how i can access the args when im using system.enviorment
08:13:14 <Dr4g4n0v> import System.Environment ( getArgs )
08:13:14 <Dr4g4n0v> main :: IO()
08:13:14 <Dr4g4n0v> main = do
08:13:14 <Dr4g4n0v> 		args <- getArgs
08:13:14 <Dr4g4n0v> 		t <- readFile ( args!!0 ++ ".html" )
08:13:16 <lambdabot> http://www.theglenlivet.com/
08:13:16 <Dr4g4n0v> i <- readFile ( args!!1 ++ ".info" )
08:13:18 <Dr4g4n0v> writeFile ( infofile ++ ".html" ) ( buildHtml t i )
08:13:18 <lambdabot> Title: The Glenlivet
08:13:49 <earthy> hef: what about 6 whiskies before lunch?
08:13:52 <Heffalump> Dr4g4n0v: I don't follow your question. Your code looks sane to me.
08:14:21 <Heffalump> earthy: oh, are you from Glasgow? ;-)
08:14:31 <earthy> hef: nope
08:14:54 <Heffalump> all that functional programming must have infected you then
08:15:04 <earthy> it must've. :)
08:15:46 <xerox> dcoutts, phas, who's sometimes around, is working on distghc
08:17:06 <Dr4g4n0v> im getting args in main, and access those args by index, can i do this ?
08:17:17 <earthy> yes
08:17:50 <dcoutts> xerox, cool
08:17:55 <Heffalump> (using !! is often bad style in Haskell, because it takes linear time in the second argument. In this case I think it's find, though)
08:19:12 <earthy> Dr4g4n0v: you might run into problems though, if the index is too large, that is, if there aren't that many arguments
08:21:56 <earthy> heffalump: I ran into that once, transforming a list of 160 elements into a record of 160 fields
08:22:49 <earthy> using listArray I managed to speed things up quite nicely. :)
08:23:26 <earthy> otoh, you need to hit the linear cost at least once...
08:23:51 <xerox> dcoutts, you might want to prod him directly, I think in reality he's be slacking on the project!
08:24:06 <dcoutts> xerox, heh, I'm not desperate
08:24:23 <xerox> alright :)
08:24:39 <dcoutts> xerox, it'd be especially tricky since the 35 boxes I have access to are solaris and I want to build ghc for linux
08:25:01 <xerox> That makes it trickier yeah.
08:25:16 <dcoutts> ghc doesn't cross-compile
08:25:29 <xerox> So it is just impossible?
08:25:40 <dcoutts> no, not completely
08:25:53 <dcoutts> ghc could cross compile more than it does
08:26:01 <xerox> Ah!
08:26:15 <dcoutts> eg with the asm backend it could include the backends for all arches
08:26:31 <dcoutts> rather than just the arch that ghc is built on
08:26:32 <xerox> right, like the kernel does?
08:26:56 <dcoutts> well you can cross-compile the kernel by using a gcc that can cross-compile
08:26:57 <xerox> It's been quite some time since I was I contact with this stuff
08:27:17 <dcoutts> you need a toolchain for the target though
08:27:24 <dcoutts> eg C cimplier, assembler, linker etc
08:27:45 <xerox> aha, the kernel is a somewhat special case, it also has the need to know what it is being compiled for, so it contains the asm backends on his own too
08:28:19 <xerox> Every phase has to know what one is going to cross-compile to?
08:29:05 <dcoutts> some phases are target-dependent, some are independent
08:30:30 <xerox> Hm, alright.
08:41:50 <Matric1> Hi anyone know about putStr?
08:42:15 <roconnor> yep
08:42:23 <roconnor> @type putStr
08:42:28 <lambdabot> String -> IO ()
08:42:44 <Matric1> what exactly does it sort my string in line bellow
08:43:30 <roconnor> I don't think I understand the question
08:43:41 <Matric1> what does lambdabot mean?
08:43:44 <SimonRC> neither do I
08:44:01 <roconnor> the type of putStr is String -> IO ()
08:44:24 <roconnor> so it takes a String and returns an IO-action that will print the string and return nothing (ie ()).
08:44:30 <ndm> gds, back, any luck?
08:44:31 <SimonRC> Matric1: it's a Haskell-oriented IRC bot
08:44:40 <gds> ndm: Yup :)
08:44:48 <Matric1> oh i see thanks i test this out now
08:45:11 <gds> the function parseArgs...
08:45:23 <gds> case x of ... ('/':flag) -> f flag
08:45:37 <gds> possibly needs an "if not unix" around it.
08:46:18 * gds is just looking up System.FilePath to figure out how best to phrase "not unix"
08:46:24 <ndm> gds, ah yes, good point!
08:46:30 <SimonRC> Some windows programs accept - args as well as / args
08:46:41 <gds> SimonRC: it supports "-" as well.
08:47:04 <SimonRC> ah, of course, I see what you mean
08:47:14 <roconnor> nunix
08:47:16 <gds> ndm: Once I've patched it, shall I do a darcs send of some sort?
08:47:36 <gds> roconnor: catholic unix? ;)
08:47:47 <SimonRC> heh
08:48:12 <roconnor> @google nunix
08:48:15 <lambdabot> http://www.nunix.com.br/
08:48:15 <lambdabot> Title: Nunix Consultoria Ltda
08:48:33 <roconnor> that's not vatican at all ...
08:50:56 <ndm> gds, darcs send is fine
08:51:26 <ndm> gds, perhaps drop / as an argument form altogether, since /file is valid on windows
08:51:29 <gds> ndm: Cool. A default/vanilla darcs send it is :)
08:51:39 <gds> Oh - ok :)
08:51:43 <Matric1> you got any information on how i can incoperste this in my program: :: [String] -> IO () different seetings for it
08:53:10 <Lemmih> Matric1: Say again?
08:54:05 <Matric1> Basically my program is displaying the output strings in a wrong way not the way i want, but i heard using :: [String] -> IO () can fix this problem but Im unsure how i got about doing this
08:54:19 <Matric1> *go
08:55:30 <Matric1> take look at this i want lines to be displayed as in this example http://en.wikipedia.org/wiki/KWIC
08:56:35 <Lajexande1> I need a good wxHaskell tutorial
08:56:58 <Lajexande1> google gives me nothing
08:57:10 <Lajexande1> (nothing good, that is)
08:58:21 <Lemmih> Lajexande1: Maybe you need a wxWidgets tutorial.
08:59:00 <Agthos> damn internets
08:59:07 <Matric1> beelsebob u there man
08:59:09 <Lemmih> Matric1: I think you should find a simpler example.
09:01:18 <Lajexande1> Lemmih: that sounds about right
09:04:16 <Magicman> There's a small wxHaskell tutorial in the Haskell Wikibook: http://en.wikibooks.org/wiki/Haskell/GUI
09:04:24 <beelsebob> Matric1: ?
09:04:55 <Lajexande1> Magicman: thanks, just found that
09:05:03 <Matric1> remember other day u helped me make kwic belsebob
09:08:16 <Matric1> beelsebob u still there
09:23:59 <Dr4g4n0v> is there a function to build a string out of list (but without whitespace) ?
09:24:26 <Heffalump> concat?
09:26:15 <Cale> Henning Thielemann and Brian Smith seem to have very strange ideas about what Haskell should be.
09:26:23 <ndm> Cale: yes, i saw that
09:26:29 <audreyt> url?
09:26:39 <ndm> Brian seems to want to change Haskell to "the thing his editor can cope with"
09:26:45 <audreyt> oh, mail.
09:26:46 <Dr4g4n0v> 10x
09:27:04 <ndm> http://www.haskell.org/pipermail/haskell-prime/2006-October/001771.html
09:27:07 <lambdabot> Title: Indentation of If-Then-Else, http://tinyurl.com/y6mq45
09:27:14 <Cale> Henning seems to want Haskell to be some minimalist functional language core which has no syntax sugar.
09:28:00 <Lemmih> lisp?
09:28:04 <Cale> sort of
09:28:05 <dcoutts> hah hah hah
09:28:22 <Cale> If you've ever read his code, it's also incredibly bizarre, because he has very strange conventions, like only defining one datatype per module and always calling it T
09:28:24 <ndm> what i loved was the whole lets change the meaning of (.)
09:28:29 <Cale> ugh
09:28:33 <dcoutts> ndm, that was so funny
09:28:39 <Cale> Have these people even *used* Haskell?
09:28:45 <dcoutts> no one uses . for composition anyway
09:28:50 <Cale> I know that Henning has.
09:29:07 <ndm> dcoutts, with those things i'm never sure if its best to just let people rant on in their own little world, or if someone should step up with a clue stick and hand out beatings
09:29:08 <Cale> But in his own unidiomatic way :)
09:29:10 <Codex_> change (.)? Dont do it :)
09:29:21 <dcoutts> ndm, yeah, it's hard to tell :-)
09:29:35 <Cale> I think that if anything, we should change the module path separator.
09:29:55 <Cale> (and not choose . as the record path separator either)
09:29:56 <ndm> if we had a good alternative, yes, but i can't think of one...
09:30:01 <Cale> I like | personally.
09:30:08 <dcoutts> the thing about editors is misguided too. It's obviously possible for an editor to do it, it's just more work. If the compiler can do it then so can an editor.
09:30:09 <Heffalump> ;-)
09:30:35 <dcoutts> it might not be cheap and incremental and single pass, but I don't care.
09:30:36 <ndm> editors have to do online processing
09:30:40 <ndm> so much harder
09:30:50 <ndm> but still, the fact that they can't do it isn't a reason to change the language
09:31:00 <dcoutts> ndm, you'll notice that eclipse just runs a compiler in a background thread
09:31:06 <Cale> I'm having no problems editing Haskell code in vim
09:31:19 <dcoutts> ndm, it does some cunning stuff to minimse the work it does, but that's the basic model
09:31:21 <ndm> i'm happy in TextPad
09:31:31 <ndm> dcoutts, yes, i think Visual Haskell does similar things
09:31:47 <dcoutts> ndm, and so did hIDE and we didn't find major perf problems.
09:32:04 <dcoutts> even for the {- lexing problem
09:32:06 <ndm> oh, when you are shouting at Simon about the Gtk stuff?
09:32:21 <ndm> and are you going to Fun in the Afternoon?
09:32:22 <dcoutts> ndm, next month when he comes to oxford. Want to come?
09:32:48 <dcoutts> ndm, yes, that's what I was thinking of. We're going to meet in the morning with Igloo too. Want to come early and talk about cabal and gtk ?
09:32:54 <Bourbaki> moin
09:33:12 <Cale> I believe that there's been a reasonable amount of research into parsing error recovery, and how to dynamically restructure parse trees as edits take place...
09:33:24 <ndm> dcoutts, the current plan is for us guys to go in the morning from York, so wouldn't get there til the afternoon
09:33:42 <ndm> dcoutts, if there is space to stay, i might be able to come the night before
09:33:42 <dcoutts> ndm, if you can't make it that early in the morning I've got a spare room.
09:34:03 <ndm> cheers :)
09:34:15 <dcoutts> ndm, how many of you folk are there turning up?
09:34:17 <ndm> i'll see, Colin is trying to arrange a car hire, but its hard with lecturing times etc
09:34:21 <ndm> currently me and Colin
09:34:27 <ndm> Malcolm has lectures
09:34:32 <ndm> Matt has travel sickness
09:35:12 <dcoutts> ndm, well I can offer you space, I expect Colin wouldn't take up the offer ;-) Scummy PhD students.
09:35:29 <ndm> Colin has a 9:15 lecture, hence we can't set off until 10:15
09:35:36 <dcoutts> ah right.
09:35:40 <ndm> dcoutts, thanks, i'll talk to everyone and see whats happening
09:35:41 <Heffalump> PhD students aren't supposed to have spare rooms ;-)
09:35:53 <dcoutts> Heffalump, heh, yeah. Lucky me. :-)
09:36:31 <ndm> well, its good that Simon will be there, a good opportunity :)
09:36:37 <dcoutts> aye
09:36:39 <ndm> who else is giving talks at this thing?
09:36:45 <dcoutts> dunno yet
09:36:50 <dcoutts> is there a list ?
09:36:55 <ndm> i am happy to, if anyone wanted me to
09:37:09 <musasabi> If they don't like syntactic sugar they shouldn't worry about do-if-then-else as "do" is just evil syntactic sugar ;)
09:37:11 <ndm> but if we have Colin, Phil Wadler, the Simons, I'm not sure anyone will want me to :)
09:37:21 <dcoutts> I would talk about bytestrings again but I feel everyone has heard it already.
09:37:24 <Renkin> I'm taking a course in Haskell, and I'm looking at an old exam to practice, but there's a problem I can't solve..
09:37:49 <Renkin> anyone feel like helping? :)
09:38:07 <dcoutts> Renkin, Chalmers?
09:38:08 <musasabi> Renkin: just ask on the channel.
09:38:10 <Heffalump> tell us th  problem and we'll see :-
09:38:11 <Heffalump> )
09:38:11 <ndm> I can talk about Hoogle, Yhc, beating GHC in speed, Catch - what else...
09:38:17 <Renkin> dcoutts, yes
09:38:24 <Renkin> why?
09:39:12 <dcoutts> Renkin, no particular reason. btw there's a #haskell.se (just in case you didn't know already)
09:39:24 <int-e> dcoutts: about noone using '.' for composition, I hope you wer kidding?
09:39:25 <Renkin> ah, no I didn't know that
09:40:04 <dcoutts> int-e, of course! It was something someone said a while ago in a thread about records.
09:40:20 <ndm> you can't use . for records, can you?
09:40:28 <int-e> I thought so. Just making sure.:)
09:40:44 <dcoutts> ndm, no, they were suggesting something new I think
09:40:46 <int-e> ndm: people don't like significant whitespace ;)
09:40:57 <dcoutts> right
09:41:09 <dcoutts> though we have it in other contexts and mathematics
09:41:24 <Renkin> so, I have a type Env = VarId -> Maybe Int, that is a type for an environment that associates variables with values
09:41:48 <Renkin> And the task is to write a function: extendEnv :: Env -> VarId -> Int -> Env
09:42:22 <Renkin> that adds an association to the Env
09:42:24 <dcoutts> ah, nice, that's a bit cunning. Though easy once you get the idea.
09:42:35 <Renkin> yeah, it feels like that kinda problem
09:42:58 <dcoutts> The key point is that the data representation of your Env is a function.
09:43:09 <Renkin> yeah
09:43:09 <dcoutts> not a traditional tree or hash or whatever
09:43:24 <ndm> Renkin: try writing out the function, but replacing Env with the type synonym, might make it easier to see
09:43:25 <dcoutts> so you need to build a new function to be that extended Env
09:43:40 <int-e> hmm, but in effect the code will do a linear search at runtime, except for prebuilt dictionaries maybe.
09:43:51 <dcoutts> int-e, yes
09:44:13 <dcoutts> that's why it's an exam question and not a traditional implementation
09:44:13 <Renkin> I don't think the point of this problem is optimization :)
09:44:45 <int-e> dcoutts: ah, I missed that.
09:44:46 <Renkin> ndm, ok, I'll try that
09:50:04 <Renkin> hmm, more hints please? :)
09:50:30 <scodil> the functional dependency example here : http://www.haskell.org/hawiki/FunDeps  creates a new class Mult with a method named (*), but this conflicts with the (*) method of the Num class, so this is an example of straigt-up operator overloading, which you can't do in haskell, right? You'd have to skip the Prelude to make this work, no?
09:50:31 <lambdabot> Title: FunDeps - The Haskell Wiki
09:50:41 <int-e> Renkin: hmm, what are you doing? you must have some own thoughts by now
09:50:42 <Renkin> I guess I should try explaining what part of it I find hard
09:51:26 <integral> If something's got a type (a -> b), you can start by writing (\x -> ???)...
09:52:03 <Renkin> ah, right
09:52:38 <Renkin> I kinda want the union of two functions, don't I?
09:53:03 <integral> a case statement?  an if statement?
09:53:06 <Renkin> And I can't see how to do that right now.. I might just be thinking slow right now
09:53:40 <Renkin> hmm, ok. thanks. I'll get back to it
09:56:02 <dcoutts> scodil, you'd have to use the module system to distinguish
09:56:34 <dcoutts> scodil, eg you could hide the Prelude version, or more sensibly import the special one qualified
09:56:43 <scodil> well, if your transformation operator (*) is defined in terms of addition and multiplication (which it normally is) then you're SOL, right?
09:56:48 <scodil> cause you can't have both in the same scope
09:56:53 <integral> .oO( import the prelude qualified )
09:56:57 <kpreid> Renkin: not two functions, but a function which is parameterized with the next one
09:57:29 <dcoutts> scodil, you can use qualified names so that you avoid them clashing
09:57:38 <kpreid> Renkin: well, since yours returns Maybe you *could* have a union
09:57:46 <kpreid> but that's not necessary for your extendEnv
10:07:04 <Renkin> kpreid: parameterized?
10:08:51 <kpreid> Renkin: having additional parameters.
10:09:46 <Heffalump> in Haskell 98, how do I make an undefined value of the same type as the return type of the function I'm writing?
10:09:55 <Matric1> anyone know what this means: Program error: Prelude.read: no parse
10:10:19 <kpreid> Heffalump: f x = r where r = ... (undefined `asTypeOf` r)
10:10:44 <Heffalump> oh, actually, it's derived from the return type, not actually the return type
10:10:48 <Cale> Matric1: it means that read has been passed a string which doesn't parse as the type of value which read was expected to return
10:10:50 <Heffalump> the return type is IO (Maybe a) and I need an a
10:11:10 <Cale> Renkin: are you still working on your environment extension question?
10:11:17 <SamB> Heffalump: just say undefined and let the typechecker figure it out>
10:11:21 <SamB> s/>/?/
10:11:26 <Heffalump> SamB: it's ambiguous due to type classes
10:11:28 <int-e> Heffalump: let derivedType :: X a -> a; derivedType _ = undefined ; ... `asTypeOf` derivedType r
10:11:29 <SamB> oh
10:11:39 <Heffalump> (it's a dummy parameter to the type class method)
10:11:51 <SamB> oh. well. scoped type variables? ;-P
10:11:54 <Renkin> Cale: yes. I was wandering about a little but now I'm back to it =)
10:11:57 <Heffalump> hence "Haskell 98" ;-)
10:12:02 <SamB> hehe
10:12:15 <Heffalump> int-e: ah, yes, ta
10:12:17 <Cale> Renkin: so the value that you're returning is a new environment, which is a function
10:12:24 <Renkin> yes, I know that
10:12:30 <Matric1> cale what have i done wrong i want string http://pastebin.co.uk/4499 have a look
10:12:48 <kpreid> Renkin: the function you return has two cases: one where the VarId is the one it supplies the value for, and one where it isn't.
10:12:51 <SamB> Heffalump: some of those things are nasty :-(
10:12:58 <Cale> Renkin: so the thing to think about is how that function is to behave. When it is passed a VarId which is equal to the VarId which you're extending with, or when it is not.
10:13:21 <Cale> er, those sentences should be joined :)
10:13:30 <Renkin> :)
10:14:07 <Matric1> i mean works for 1 line not more than 1
10:14:11 <Renkin> yes, but I don't see how to return a function (Env) that is complete
10:14:31 <Renkin> that is, that accepts the both the added input and the old ones
10:14:56 <Cale> Matric1: well, depends on which of those reads the error occurs, but it's in the way in which you're interacting with the program, not the program itself -- either something in the file movies.txt, or one of the lines which you typed at the console is a problem.
10:15:35 <Matric1> huum if i add one movie to the list it works ok if i add 2 like one below other i get error?>
10:15:43 <Cale> Renkin: well, it has to delegate, right?
10:16:01 <SamB> so, has anyone ported the MTL to use ATs yet?
10:16:17 <Heffalump> right, fixed, ta. But ugh, how grotty :-)
10:16:45 <Cale> Matric1: You're applying read in order to get strings, so make sure that appropriate quotation marks are there in the first place.
10:16:58 <Renkin> Cale: I don't know the term delegate
10:17:17 <Cale> Renkin: that is, to pass off responsibility
10:17:24 <Renkin> ah
10:17:48 <int-e> Renkin: hmm. I think you've either missed out on 'case' and 'if' and pattern matching or you've not fully grasped the 'functions are first class values' thing.
10:18:06 <Cale> The new function you write knows only about one VarID/Value pair itself, but it also has the old environment, which knows about all the others.
10:18:12 <Renkin> Ah, I think I get it now
10:18:19 <Matric1> yep cale check this: http://pastebin.co.uk/4500
10:18:30 <Renkin> Since the function is generated as you use it, it only needs to know that specific case?
10:18:50 <Renkin> If that made sense
10:18:52 <int-e> sort of, yes.
10:19:01 <Matric1> when i have multiple lines
10:19:04 <Matric1> doesnt work
10:19:51 <Cale> Matric1: is that the contents of the file, or the user interaction?
10:20:08 <Matric1> content
10:20:09 <Renkin> I've never used case actually, but pattern matching and if. And I understand the concept of functions and values, but I cannot say I've fully grasped it yet :)
10:20:40 <Cale> Matric1: then you can't apply read to that. You're applying read to the string which is the entire file, which is not any one datastructure, so there's no appropriate type
10:20:48 <Renkin> Pattern matching I have used a lot, and I really like that concept
10:21:01 <Cale> Matric1: possibly you want to map read over the lines of the file
10:21:09 <Matric1> oh i see man so can u edit this and apply right type http://pastebin.co.uk/4499 what would be right type
10:21:20 <Cale> Renkin: case is just an expression-form for pattern matching
10:21:42 <Cale> Matric1: hm?
10:32:10 <Renkin> Right. A function never evaluates before it's applied to something?
10:32:21 <Renkin> until, even
10:32:23 <Matric1> i want it to read each new line in the txt file
10:32:41 <Heffalump> Renkin: correct
10:32:43 <Cale> right, it can't
10:33:20 <Lajexande1> anyone in here who can read the wxHaskell documentation?
10:33:32 <Matric1> why what is wrong with it
10:33:43 <Lajexande1> it doesn't explain anything
10:33:47 <Lajexande1> ok, here: http://wxhaskell.sourceforge.net/doc/Graphics.UI.WX.Controls.html#16
10:33:49 <lambdabot> http://tinyurl.com/y9rc5a
10:34:38 <Lajexande1> that's the static text function, but when I try to understand who it it works and what something of the type StaticText is i get dizzy
10:34:58 <petekaz> @seen dcoutts
10:34:58 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #gentoo-haskell and #ghc. I last heard dcoutts speak 37m 28s ago.
10:35:04 <Lajexande1> *how it works*
10:35:27 <Heffalump> Matric1: what are you actually trying to do?
10:35:45 <Cale> A value of type StaticText is basically a text label.
10:36:16 <Cale> like a label that you would see on a form before an editbox to tell the user what they are supposed to enter
10:36:31 <dcoutts> petekaz, ?
10:37:02 <Cale> Lajexande1: does that help?
10:38:11 <Lajexande1> well, not really... see I try to follow the types and that seems to get... ...quite ugly
10:38:19 <petekaz> I get a new strange error message now, is this a problem in my code?  http://paste.lisp.org/display/28500
10:38:25 <Renkin> ok, so now my problem is I can't distinguish between the two cases since I just have the type Env at the time, and not the value to be applied to i
10:38:26 <Renkin> it
10:38:46 <Renkin> (I hope I'm not getting annoying =))
10:38:48 <Cale> Lajexande1: You pass it a window, and a list of properties, and it gives you an IO action which will create the label when run.
10:39:12 <Cale> and pass you a pointer to that label so that you can refer to it in the rest of your program
10:39:15 <petekaz> dcoutts: that occurs when I try to activate an item in my treelist.
10:39:55 <Lajexande1> yeah, but if i want to understand how it really works?
10:40:02 <petekaz> dcoutts: the annotation shows the code I am using for the callback.
10:40:10 <Cale> at what level?
10:40:11 <Renkin> I'm obviously not used to functions that return functions
10:40:24 <Cale> Lajexande1: for that, you'd be better off reading the WxHaskell source code
10:41:14 <Cale> Renkin: are you used to functions with more than one paramter? :)
10:41:20 <Cale> parameter*
10:41:34 <Renkin> true :)
10:41:45 <Renkin> the problem is I'm still separating them too much, I guess
10:41:51 <dcoutts> petekaz, oh, actually, yes sorry that's not going to work as we don't set up column types for the C API.
10:41:52 <Cale> That can often help your thinking
10:42:17 <dcoutts> petekaz, we need to just provide the Haskell api for getting values from the store. I've just done that for the list version.
10:42:35 <dcoutts> petekaz, Axel is going to do it for the tree version.
10:42:37 <Cale> Because if it ever doesn't quite seem like you have enough to write the function, just remember that you also have that function's parameters too :)
10:42:46 <petekaz> dcoutts: ok, no problem.  I'll wait till you guys are done.
10:43:10 <dcoutts> petekaz, ok. Watch the darcs commits.
10:43:22 <Lajexande1> Cale: Maybe you're right... hmmm.. i'm clicking through the documentation and typing out what type StaticText 'actually' is
10:43:27 <petekaz> dcoutts: will do
10:44:25 <Lajexande1> ugly indeed:
10:44:27 <Lajexande1> type StaticText a = Object (CWxObject  (CEvtHandler  (CWindow  (CControl  (CStaticText a) ) ) ) )
10:45:00 <Cale> oh, that must be a different version from the documentation then
10:45:00 <petekaz> dcoutts: what is this new signal handling mechanism you refer to on the list?  is that in a prior message somewhere?
10:45:05 <Renkin> if I wrote extendEnv :: Env -> VarId -> Int -> Env, but used the actual form of Env..
10:45:34 <Renkin> Would it be: (VarId -> Int) -> VarId -> Int -> (VarId -> Int) ?
10:45:40 <Cale> yes
10:45:43 <petekaz> dcoutts: I like your idea of making all the constructors take attribute lists.
10:45:45 <Renkin> right
10:46:02 <Lajexande1> Cale: no, if any constructor was a type and not data i replaced it with what it said that that type was
10:46:05 <dcoutts> petekaz, it's described in a few posts to the dev list. Instead of saying: "onClicked button $ do ..." it'll be "on button clicked $ do..."
10:46:26 <Cale> Lajexande1: oh
10:46:34 <dcoutts> petekaz, this reduces the number of signal functions by half since there is both onClicked and afterClicked variants.
10:47:05 <dcoutts> petekaz, which can be reduced to just "on thing clicked" and "after thing clicked", so just one signal value.
10:47:09 <petekaz> dcoutts: I see.  I didn't subscribe to the dev list because it wasn't in gmane.
10:47:13 <Cale> Lajexande1: I think that if you're just using the library, then you can work at the level of abstraction that the thing you get back is just a reference to that object, and not worry about how it's actually implemented.
10:47:21 <dcoutts> petekaz, sure, there's no need to do so.
10:49:14 <Lajexande1> Cale: true that, but it doesn't feel satisfying just knowing how to use it
10:52:53 <frevidar> how do I ensure an argument to a function is of type "Random Float"?
10:53:10 <frevidar> (Random Float x) => x does not work
10:53:36 <Cale> frevidar: You give the function a type which looks something like  Random Float -> ...
10:53:55 <Cale> where the ... consists of the type for the rest of the parameters and the result
10:53:58 <frevidar> cale: ah, ok, silly me
10:54:11 <Cale> make sure that Random is a type constructor
10:54:29 <Cale> Or did you mean something else?
10:54:57 <Cale> The Random which is in the standard libraries is a typeclass, but you only use typeclasses to constrain type variables
10:55:24 <frevidar> cale: then I get this error, "Random" used as type, in the type "Random Float"
10:55:34 <Cale> right, then all you want is Float there
10:56:19 <Cale> (I was kind of initially assuming that you had your own parametric datatype called Random)
10:56:59 <frevidar> cale: but I want to pass a random generator that generates floats
10:57:06 <frevidar> not just one float
10:57:12 <Cale> then you want to pass a StdGen
10:57:27 <Cale> or else, maybe you mean to use some monad...
10:57:47 <Cale> I wrote a monad called Rand for this sort of thing, its source is on the wiki
10:57:57 <Cale> http://haskell.org/haskellwiki/NewMonads/MonadRandom
10:57:59 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/fs3av
10:58:21 <ex0-r> does haskell support multiple if statements, like if, else if, else if, else if , else?
10:58:37 <Cale> ex0-r: nesting is fine
10:58:52 <Cale> ex0-r: there's no special syntax for it though
10:58:58 <ex0-r> hmm
10:59:09 <ex0-r> I think I have it in the wrong syntax, java style
10:59:13 <Cale> frevidar: But the plain way to do things would be to pass a StdGen, which can be used to generate any type of value which is an instance of the Random class
10:59:20 <ex0-r> did wonder why it was complaining at me
10:59:35 <Cale> ex0-r: the usual way to lay out an if-then-else is like this:
10:59:39 <Cale> if condition
10:59:44 <Cale>    then result
10:59:48 <Cale>    else something else
11:00:08 <Cale> er, but don't write a second else of course :)
11:00:09 <Cale> hehe
11:00:16 <frevidar> cale: I just want to pass a generator that conforms with Random Float
11:00:16 <ex0-r> ah
11:00:46 <Cale> @type random
11:00:47 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
11:01:34 <ex0-r> so can I do if -> then, if -> then, if -> then, else?
11:01:47 <ex0-r> Hugs keeps bitching about unexpected ifs :P
11:02:11 <Cale> Given any type of RandomGen, g, and any randomly generatable type of value a, random will take a value of type g and generate for you a new random value of type a and a new random generator
11:02:18 <psi> ex0-r: maybe you want a case?
11:02:27 <Cale> if condition
11:02:30 <Cale>    then x
11:02:37 <Cale>    else if condition2
11:02:51 <Lemmih> ex0-r: You can do: case () of _ | a -> ...; b -> ...; c -> ...
11:02:53 <Cale>            then y
11:02:55 <ex0-r> hmm let me try again, maybe its just the compiler being retarded
11:02:59 <Cale>            else z
11:03:14 <frevidar> cale: could I just pass a (RandomGen g)?
11:03:37 <Cale> frevidar: Unless you're writing your own type of random generators, you use StdGen for g
11:04:10 <Cale> you can construct a StdGen from a seed integer using mkStdGen, or else get one conveniently in the IO monad using newStdGen
11:04:38 <Cale> a StdGen value is all you need to generate random values of any type
11:05:02 <Nat21> Hi anyone know how to take a massive string say sentences in wordpad file and use code to divide them per sentence
11:05:03 <Cale> (any type satisfying the class Random)
11:05:15 <Heffalump> Nat21: what for?
11:05:40 <Nat21> eg sort the strings and then create new order output
11:05:56 <Cale> Nat21: sure, you want to know how to do this in Haskell?
11:06:18 <ex0-r> hmm maybe using guards will make it look neater
11:06:20 <Nat21> say i got a list of lines 5 lines in notepad want to take the one string divide it to lines then sort the lines in order
11:06:23 <Nat21> yes haskell
11:07:42 <Nat21> ?
11:08:04 <Cale> Matric1: Are you familiar with IO in Haskell?
11:08:22 <Nat21> ?
11:09:08 <ex0-r> slightly offtopic but is there a good editor with syntax highlighting? I have an enormous amount brackets in this predicate and ill be damned if im going to hand count them all
11:09:19 <ex0-r> :P
11:09:19 <Lemmih> Nat21: We'll need a few more question marks before we can answer you.
11:09:22 <Cale> ex0-r: I usually use vim or emacs
11:09:35 <Nat21> i dont understand what u mean buy this?
11:09:58 <Cale> ex0-r: People on Windows seem to like TextPad. :)
11:10:16 <ndm> ex0-r: if you are a windows user, TextPad is definately the answer
11:10:27 <ndm> ex0-r: and it integrates beautifully with WinHugs :)
11:10:40 <ex0-r> ah
11:10:42 <Lemmih> Nat21: Is it homework?
11:10:43 <ex0-r> sounds perfect
11:10:49 <Cale> It's too bad that TextPad is commercial software
11:11:05 <Nat21> homework, what do you mean i dont goto school?
11:11:23 <ndm> I don't mind it being commerical, its well worth the money
11:11:38 <Nat21> I thought this forum help people with difficulties in haskell?
11:11:47 <Nat21> sorry i mean chat room
11:11:58 <Cale> channel :)
11:12:06 <Nat21> corrected
11:12:06 <Lemmih> Nat21: Ah, you're Matric1.
11:12:08 <satan> hallo
11:12:19 <vincenz> what are KWicLine's?
11:12:21 <Nat21> what do you mean Im Matric1?
11:12:32 <satan> quick basic question: what's the difference between map and fmap? they both work on lists and return lists, do they not?
11:12:44 <Cale> vincenz: Keyword in context
11:12:47 <vincenz> satan: fmap is more general
11:12:57 <satan> ok
11:13:02 <vincenz> Cale: so each word gets tagged by the line it's in
11:13:10 <ndm> satan: map is easier to understand, and forces type signatures so stops overloading, but in general fmap can always be used
11:13:11 <vincenz> map (flip KL f ) $ words f
11:13:11 <Cale> satan: I'd argue that liftM and map should be removed, and fmap should be renamed map
11:13:19 <vincenz> @type liftM
11:13:20 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
11:13:23 <Cale> satan: Some people would argue that this would confuse newbies :)
11:13:23 <vincenz> why liftm?
11:13:25 <ndm> Cale: why remove liftM?
11:13:30 <satan> lol yeah
11:13:32 <Cale> ndm: It's the same thing as fmap
11:13:43 <Cale> ndm: only restricted to monads
11:13:43 <ndm> @type fmap
11:13:45 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
11:13:46 <ndm> @type liftM
11:13:47 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
11:13:48 <satan> so fmap is more general...in that it works with more types?
11:13:53 <Cale> satan: yeah
11:13:55 <vincenz> ah
11:14:12 <satan> so it's a functor, and a functor is....
11:14:16 <ndm> Cale: that would scare me, i use map and liftM for entirely different semantic operations, i like them being different
11:14:32 <Lemmih> Nat21: I don't believe you have a serious interest in learning Haskell.
11:14:56 <Nat21> lol u keep checking me out i cant run
11:15:15 <Nat21> my java coding can smash your haskell
11:15:33 <Nat21> i officially give up u want see me again u got my details
11:15:34 <ndm> @where shootout
11:15:34 <lambdabot> http://shootout.alioth.debian.org/
11:15:39 <Cale> Nat21: you're connecting from the same host. People don't identify people by nicknames, but by hostnames.
11:15:39 --- mode: ChanServ set +o vincenz
11:15:43 <ndm> Nat21: ^^^ - prove it :)
11:15:53 --- kick: Nat21 was kicked by vincenz (Thank you, come again.)
11:15:56 <satan> ok thanks guys :)
11:15:58 --- mode: vincenz set -o vincenz
11:16:05 <ex0-r> hmm textpad seems pretty good
11:16:09 * vincenz coughs
11:16:15 <Botje> was he trolling?
11:16:20 <Botje> he wasn't doing a very good job at it :|
11:16:24 <Cale> Botje: sort of.
11:16:39 <Cale> Botje: mostly, he was trying to get people to write his homework assignment for him
11:16:48 <Botje> at least the trolls in #perl do their homework :))
11:16:51 <vincenz> and turning passive aggressive when we would not
11:17:21 <Cale> satan: for Haskell purposes, a functor is a datatype which is parametrised over what it contains (though the sense of 'contains' might be rather general)
11:17:22 <Botje> if he isn't interested in haskell, he shouldn't receive a pice of paper saying he knows it, anyway
11:18:26 <ex0-r> hmm, is it possible to do a 3 way comparison (i.e, x == y == z), without having to do x == y && x == z
11:18:40 <satan> Cale: i see, so there would be a different functor for every custom datatype then?
11:18:43 <satan> or am i wrong?
11:18:56 <ndm> all (== x) [y,z]
11:18:59 <pejo> Botje, shrug, people are "forced" to take all kind of different classes,  without any paritcular interest in them. I don't think any reasonable employer would believe they know a subject based on a single course.
11:19:06 <ex0-r> aha brilliant
11:19:18 <ex0-r> haskell is really going up in my estimations!
11:19:40 <Botje> pejo: I guess. I'm learning haskell too, out of interest.
11:19:52 <vincenz> Botje: out of curiousity, dutchspeaking?
11:19:57 <Botje> yes :)
11:20:02 <vincenz> Thought so :)
11:20:04 <vincenz> the 'je' gave it away
11:20:27 <pejo> Is the "je" in any way related to the german "chen"?
11:20:35 <nostromo> In the Politecnica University (Madrid) haskell is one half of the programming course in CS
11:21:07 <Botje> pejo: probably. the languages are close.
11:21:16 <nostromo> or it used to be, ADA the other half :)
11:21:23 <vincenz> nostromo: Dacya?
11:21:29 <vincenz> nostromo: complutense?
11:21:31 <Botje> nostromo: at the VUB (brussels) it's nothing but scheme the first year.
11:21:36 <jmmv> nostromo: wow, do you have functional programming as part of the compulsory courses?  we (in the upc at barcelona) don't :-/
11:21:37 <nostromo> no, Politecnica
11:21:38 <vincenz> Botje: Not anymore at kuleuven
11:21:45 <psi> pejo: do you know why haskell was removed at ltu?
11:21:55 <nostromo> I'm not there, it is my students who told me
11:22:24 <nostromo> schem (and the SICP book) is IMO very good for introduction
11:22:28 <jmmv> I only saw miranda as part of an optional subject and haskell was up to us to use; I'm glad I chose it :-)
11:22:36 <vincenz> nostromo: Ah ok, I have colleagues from complutense
11:22:37 <lisppaste2> madhorse pasted "ghc 6.4.2 failing with gcc 4.1.1" at http://paste.lisp.org/display/28507
11:22:38 <pejo> psi, it will reappear as a 3/4th year "advanced" course. Hopefully some more functional programmers will appear, so there will be an advanced functional programming on top of it too.
11:22:45 <nostromo> python too (starting the functional stuff and moving to OO)
11:22:46 <ndm> jmmv: we have scheme in our first year, but its not taught as functional programming
11:22:56 <Botje> vincenz: so what do they give there now? java?
11:23:18 <pejo> psi, the physicists/ee's weren't that fond of having to take it, there are other classes more important to them.
11:23:18 <vincenz> Botje: I believe so
11:23:24 <vincenz> Botje: I was still in the scheme way
11:23:27 <vincenz> \o/
11:23:30 <Botje> yay!
11:23:31 <nostromo> starting with functional saves a lot of misconceptions about state and variables
11:23:32 <vincenz> scheme is such a good language to teach
11:23:43 <vincenz> I mean it's very simple, and allows you to easily cover FPL, impl and oopl
11:23:55 <nostromo> the first two/three chapters of SICP are purely functional,
11:23:56 <Botje> and logic programming, if you follow SICP
11:24:04 <frevidar> I've got this code here:
11:24:10 <vincenz> Botje: or you have "reasoned schemer"
11:24:10 <psi> pejo: that's nice to hear. it's still my favourite course :)
11:24:43 * Botje looks
11:24:44 <frevidar> data StrategyMatrix = Array Int Float
11:24:44 <frevidar> 	data StrategyMatrix = Array Int Float
11:24:44 <frevidar> 	data StrategyMatrix = Array Int Float
11:24:44 <frevidar> 	data StrategyMatrix = Array Int Float
11:24:44 <frevidar> 	data StrategyMatrix = Array Int Float
11:24:44 <frevidar> 	data StrategyMatrix = Array Int Float
11:24:49 <frevidar> argh!
11:25:17 <vincenz> frevidar: use paste site
11:25:18 <frevidar> sorry about the spam attack
11:25:27 <frevidar> it was only suppose to be two lines
11:25:31 <ex0-r> alot of universities here in the uk teach fp (mostly haskell) as a compulsory class
11:25:52 <ndm> in York its optional
11:26:13 <ex0-r> comp at sheff
11:26:19 <frevidar> 		successor strategyMatrix changeAmount randomGen =
11:26:19 <frevidar> 			array (bounds strategyMatrix) (zipWith (\x randomAmount -> x + randomAmount) (elems strategyMatrix) (randomRs (-changeAmount,changeAmount)))
11:26:19 <frevidar> successor strategyMatrix changeAmount randomGen = array (bounds strategyMatrix) (zipWith (\x randomAmount -> x + randomAmount) (elems strategyMatrix) (randomRs (-changeAmount,changeAmount)))
11:26:28 <frevidar> argh!!!
11:26:32 <ex0-r> then again so are all the modules until 3rd year, including prolog
11:26:36 <mbishop> stop that :P
11:26:36 <nostromo> in the one I works it is C#
11:26:42 <frevidar> ok
11:26:46 <nostromo> which sort of spoils the student
11:26:54 <frevidar> ok, its suppose to be the two lines
11:26:59 <psi> pejo: will the reappeared one be essentially the same as the old one, then?
11:27:09 <nostromo> when I get the in 2nd for OO Analysis and Design, they are mostly lost
11:27:12 <ex0-r> mine wont do newer languages until they are commonplace enough
11:27:29 <frevidar> my client is messed up.
11:27:32 <ex0-r> must still think c# is a little premature
11:27:33 <nostromo> scheme is not exactly "newer" :)
11:27:35 <pejo> psi, no, more contents. Since most people take it as a first year course they don't realize how increidbly slow the course is today.
11:27:36 <ndm> mine won't do languages that are too common
11:27:44 <ex0-r> well no
11:27:48 <ex0-r> but you know what I mean
11:27:49 <ex0-r> ;)
11:28:05 <pejo> psi, and the idea is that people are supposed to understnad induction over natural numbers and a bunch of other things from their math courses before they get to their third year.
11:28:28 <mbishop> I don't particularly like C#, but it's nice to see even microsoft going the way of VM'd GC'd languages
11:28:32 <ex0-r> we have Java 1st year (both semesters), then move into Prolog & Haskell in the second
11:28:46 <ex0-r> which is nice as basic java is about as easy as it gets
11:28:53 <frevidar> it gives type errors, saying it can't match "Array i e" with "StrategyMatrix", but I want StrategyMatrix just to be sort of a synomyn for Array i e
11:29:03 <ex0-r> unless you taught VB or something utterley pointless
11:29:05 <frevidar> is the data declaration the right way to do that?
11:29:12 <Magicman> Nope, use type
11:29:26 <nostromo> problem with mainstream languages is well explained in http://www.ibiblio.org/obp/thinkCSpy/preface.html (using C++ as example)
11:29:29 <lambdabot> Title: How to Think Like a Computer Scientist: Preface, http://tinyurl.com/yxwqt8
11:29:43 <Magicman> type StrategyMatrix = --Blah
11:30:16 <psi> pejo: hm - induction over natural numbers - what is the relation to haskell?
11:30:44 <pejo> psi, recursion should be easeir to understand if you already know induction.
11:31:06 <psi> oh, maybe.
11:31:13 <xerox> co-induction I think.
11:31:16 <nostromo> psi: induction==infinite streams
11:31:20 <psi> or the other way around :)
11:31:23 <xerox> Yeah, ones = 1 : ones.
11:32:14 <nostromo> ex0-r: I'd actually prefer VB to C++ or C# or even java
11:32:22 <nostromo> at least print "Hello" works
11:32:27 <ex0-r> heh
11:32:31 <ex0-r> vb is far to limited
11:32:41 <nostromo> (or it used to work 10 years ago, last time I tried VB)
11:33:03 <nostromo> VB has recursion, not sure about closures or lexical scoping
11:33:20 <ex0-r> did it at secondary school, and had it sussed within a week or two. A month or too later it started to get annoying because I couldnt do the stuff I could in C as easily
11:33:23 <ndm> I like VB as well, its a nice language
11:33:27 <ex0-r> although for begineers, definately
11:33:36 <ex0-r> beginners even
11:34:00 <nostromo> I'm thinking about beginners all the time, to people like you I would send to the library :)
11:34:06 <ex0-r> hehe
11:34:08 <mbishop> ex0-r: begineers, the cousins of buckeneers? :P
11:34:17 <ex0-r> :D
11:35:13 <pejo> psi, either way works. But E/Y/F need some basic programming courses, but not all of them. A coordination problem in short (or budget, can't give all courses multiple times).
11:35:44 <ex0-r> I really do wish haskell would give some more insightful error messages sometimes
11:35:55 <ex0-r> or, I wish I actually new which part of my code was wrong
11:35:58 <ex0-r> either would suffice
11:36:01 <vincenz> @arg
11:36:01 <lambdabot> Avast!
11:38:42 <ndm> ex0-r: try using GHC and Hugs, if one gives a cryptic error message the other usually comes to the rescue
11:40:07 <ex0-r> its not really cryptic, im just inept
11:40:13 <ex0-r> :P
11:40:33 <lisppaste2> ex0-r pasted "n/a" at http://paste.lisp.org/display/28509
11:40:47 <ex0-r> oh wow I didnt know it did that
11:40:53 <ex0-r> heh
11:40:58 <pejo> exor, nobody will deny that the error messages could use some improvement. It's just a lot of work and not very well understood area.
11:41:15 <ex0-r> same with most languages
11:41:59 <psi> isn't helium nice for beginners?
11:42:03 <psi> i've never tried it
11:42:03 <ex0-r> im just complaining because im not used to FP yet, i'm a Java whore
11:42:42 * Botje gives ex0-r $5
11:42:45 <Botje> now dance! :p
11:43:10 <pejo> psi, still no type classes, so probably depends on what you intend to do with the language.
11:44:48 <ex0r> so, anyone fancy pointing out the blindingly obvious and giving me a hint on that paste?
11:44:52 <psi> pejo: just to learn the basics of haskell and fp
11:44:53 <ex0r> :P~
11:45:26 <nostromo> ex0r: you are using two different signatures for the same function
11:46:22 <kpreid> ex0r: you're defining winningHandAux in curried but calling it in uncurried style
11:46:51 <kpreid> the definition should look like the call
11:47:03 <kpreid> (or vice versa)
11:47:13 <ex0r> arse I havent learnt the curried bit yet
11:47:19 <ex0r> getting a tad ahead of myself
11:47:25 <kpreid> e.g. | otherwise = winningHandAux (tail trick) trump topTrick
11:47:29 <kpreid> or:
11:47:51 <ex0r> ohhh
11:47:53 <kpreid> winningHandAux :: (CardHand, CardSuit, Card)
11:47:53 <kpreid> winningHandAux (trick, trump, topTrick)
11:47:58 <kpreid> errrr
11:48:05 <kpreid> winningHandAux :: (CardHand, CardSuit, Card) -> Card
11:48:10 <ex0r> yep get you now
11:48:14 <kpreid> anyway, make one of those two changes and it'll be good
11:48:22 <kpreid> usual Haskell style is to do the first
11:49:46 <ex0r> for some bizarre reason I keep trying to write prolog style in haskell
11:50:33 <dwm> I'm having an odd problem with trying to eta reduce something..
11:50:55 <dwm> > let foo x y = 1 + max x y in foo 4 5
11:50:56 <lambdabot>  6
11:51:29 <dwm> Now, trying to remove the x y from both sides, I'm having a lot of trouble getting the '1 + max' composed properly.
11:51:54 <Heffalump> ex0r: what are you trying to do, OOI?
11:52:40 <dwm> > let foo = 1 + max in foo 4 5
11:52:40 <lambdabot>  add an instance declaration for (Num (a -> a -> a))
11:52:41 <lambdabot>   In the definition o...
11:52:59 <dwm> > let foo = (1 +) . max in foo 4 5
11:53:00 <lambdabot>  add an instance declaration for (Num (a -> a))
11:53:18 <musasabi> dwm: maybe @pl can help you
11:53:33 <dwm> musasabi: You know, I have not used that yet.
11:53:41 <ex0r> OOI?
11:53:53 <musasabi> @pl (\x y -> 1 + max x y)
11:53:54 <lambdabot> ((1 +) .) . max
11:54:12 <dwm> Double compose, wtf.
11:54:30 <musasabi> two arguments = two composes
11:54:38 <dwm> oho
11:55:01 <dwm> So, f (g x y) != (f . g) x y
11:55:13 * kpreid thinks there ought to be a compose-with-two-args function
11:55:36 <dwm> (..)  :)
11:55:39 <kpreid> (such that that equation does hold for it)
11:55:46 <kpreid> I called it .: for lack of better names once
11:55:56 <ex0r> hmm that change makes it compile fine
11:56:04 <kpreid> one could argue that that stands for one-output-two-inputs...
11:56:08 <musasabi> @type (max >>> (+ 1)
11:56:09 <lambdabot> parse error (possibly incorrect indentation)
11:56:10 <ex0r> it just doesnt like showing me the result without erroring about show
11:56:11 <ex0r> ffs
11:56:13 <musasabi> @type (max >>> (+ 1))
11:56:15 <lambdabot> forall b. (Ord b, Num (b -> b)) => b -> b -> b
11:56:15 <Heffalump> ex0r: "Out of interest"
11:56:21 <ex0r> ah
11:56:27 <ex0r> its a whist card game
11:56:30 <Heffalump> (I ask cos it looks bridge-like, which I'm interested in)
11:56:31 <Heffalump> ah, ok
11:56:38 <ex0r> well, technically it is bridge
11:56:46 <dcoutts_> @pl \x -> f (g x)
11:56:46 <lambdabot> f . g
11:56:47 <ex0r> I just call it whist because I odnt udnerstand bridge
11:56:52 <ex0r> :P
11:56:52 <dcoutts_> @pl \x y -> f (g x y)
11:56:53 <lambdabot> (f .) . g
11:57:00 <Heffalump> bridge is whist + bidding and different scoring
11:57:05 <ex0r> yeah
11:57:12 <ex0r> its kinda a halfway house between both
11:57:14 * Heffalump likes bridge
11:57:31 <ex0r> I have a scoring function, hand validation, hand arranger so fare
11:57:35 <Igloo> Why bridge rather than any other game, OOI?
11:57:42 <Heffalump> Igloo: who, me?
11:57:45 <Igloo> yup
11:57:54 <ex0r> just doing the trick bit and Hugs doesn't feel like being my bitch at the moment
11:57:57 <Heffalump> got interested in it by some people at work
11:58:13 <Heffalump> and the bidding makes it pretty interesting
11:58:35 <Heffalump> ex0r: I've got some half-finished code for doing bridge stuff, if you want it
11:58:50 <musasabi> dwm: an alternative is:
11:58:51 <dwm> Thank you for helping. I was probably going to take quite a while before getting around to examining the type of (.) in all this.
11:59:10 <musasabi> > let foo = curry (uncurry max >>> (+1) in foo 4 5
11:59:10 <lambdabot>  Parse error
11:59:17 <musasabi> > let foo = curry (uncurry max >>> (+1)) in foo 4 5
11:59:18 <lambdabot>  6
11:59:21 <ex0r> for the sake of learning i'd rather do it myself for the moment, although thanks anyway
11:59:27 <dwm> aha
11:59:59 <ex0r> does haskell (or Hugs if you like) have a trace/debug like prolog etc
12:00:09 <ex0r> need to step through this recursion
12:00:15 <dwm> Now, (un)curry, those are about making things into tuples and vice-versa?
12:00:22 <musasabi> yes.
12:00:40 <vincenz> http://giveitaname.lucumr.pocoo.org/
12:00:42 <lambdabot> Title: Give It A Name!
12:00:44 <dwm> Which fits here becuase you need to get one thing to use the single-compose on.
12:01:06 <dwm> So, that currey (uncurry.. is like 'pack into a tuple, unpack later'
12:01:43 <musasabi> they transform functions from taking a tuple into taking 2 arguments (and the reverse)
12:01:54 <thetallguy> Heffalump:  have you seen the quote at the bottom of Phil Wadler's home page?
12:02:12 <musasabi> "(a,b) -> c" <=> "a -> b -> c" basically.
12:02:49 <dwm> This is awesome. I had not paid attention yet to those currying functions and was vaguely curious about what they're for.
12:03:45 <Heffalump> thetallguy: I have now :-)
12:04:14 <thetallguy> Seems to be a theme
12:04:24 <vincenz> Itkovian: hoi
12:04:33 <vincenz> thetallguy: he's blaming microsoft too?
12:04:39 <thetallguy> ?
12:04:52 <Itkovian> hi vincenz
12:05:03 <thetallguy> vincenz: I think you must have found something else
12:05:12 <vincenz> thetallguy: I was kidding, where is his homepage
12:05:13 <musasabi> thetallguy: link?
12:05:17 <thetallguy> http://homepages.inf.ed.ac.uk/wadler/
12:05:18 * vincenz was referring to the stuff on the mac page
12:05:21 <lambdabot> Title: Philip Wadler's home page
12:05:41 <thetallguy> I was referring to my story about bridge versus other card games
12:05:46 <vincenz> oh
12:05:56 <araujo> morning
12:06:20 <dwm> Thank you.
12:12:15 <lisppaste2> ex0r annotated #28509 with "n/a" at http://paste.lisp.org/display/28509#1
12:12:27 <ex0r> :S
12:13:17 <ex0r> Show has been derived, but it still wont show it. Although the type appears to be wrong anyway, it should only be Card
12:13:23 <vincenz> ex0r: ghci?
12:13:23 <ex0r> hmm
12:13:41 <vincenz> the type is
12:13:42 <vincenz> winningHand :: CardHand -> CardSuit -> Card
12:13:47 <vincenz> it requires two parameters
12:13:50 <vincenz> you give it one
12:13:57 <ex0r> how embarassing
12:14:12 <ex0r> /clear everoyne
12:14:58 <ex0r> well, it does actually work apart from that
12:15:00 <ex0r> fantastic
12:16:17 <hygge> a list comprehension, if i got a generator "x <- [[2]]", or any generator, does it just ignore the empty list [] even though it is included in every list ? (because it is, isnt it?)
12:18:51 <ndm> > [] `elem` [[2]]
12:18:52 <lambdabot>  False
12:18:55 <frevidar> how do I force an expression to use a particular function in a particular instance?
12:19:04 <ndm> hygge: its not an element in every list, its the end of every list
12:19:26 <ndm> frevidar: (return :: a -> IO a) x -- for example
12:19:35 <FransE> Hi, why doesn't Haskell have a increment operator? E.g, 3++ .
12:19:54 <frevidar> I have "instance Strategy StrategyMatrix Int Int Float where"
12:20:12 <nomeata> Hi. Looks like I need to do something about memory management in my haskell app...
12:20:22 <frevidar> however, the function I'm using does not use the two Ints
12:20:22 <Magicman> let incr = (+1)
12:20:22 <Magicman> incr 3
12:20:28 <Magicman> No need for ++
12:20:29 <frevidar> so I get this error:
12:20:45 <Heffalump> FransE: why do you think it should?
12:21:06 <nomeata> in this code: http://latexki.nomeata.de/Generic.html  the function procGeneric reads a file to look for special characters, and if it finds any, it does not use the content any further
12:21:08 <lambdabot> Title: The Latexki Latex Wiki Wiki - Generic
12:21:13 <FransE> Heffalump: because it's easier than writing a function for it? Or?
12:21:13 <frevidar> Possible fix: add an instance declration for (Strategy StrategyMatrix position move Float)
12:21:33 <nomeata> But it seems that haskell keeps the content of the file even after it is not needed any more.
12:21:40 <frevidar> ndm: is your suggestion going to help there?
12:21:41 <nomeata> Any hint?
12:22:20 <ndm> frevidar: don't think so...
12:22:54 <FransE> Heffalump: so why do you think a ++ operator is redundant?
12:22:55 <ndm> nomeata: how short is your code? its probably got references to the source even after
12:22:56 <thetallguy> @type succ
12:22:57 <lambdabot> forall a. (Enum a) => a -> a
12:23:00 <frevidar> ndm: any idea about what I should do? or is my type class dodgy?
12:23:16 <ndm> FransE: +1 is the same number of characters as ++, and in haskell would have the same semantics
12:23:30 <ndm> frevidar: i only know haskell 98, you;'d have to ask other people about MPTC
12:23:30 <nomeata> ndm: the relevant code is 10 lines. the content is not used anywhere else, it's an IO () function
12:23:32 <hygge> ndm, but list comprehension doest do anything with it?
12:23:53 <FransE> ndm: k..
12:24:03 <thetallguy> FransE: ++ doesn't seem as important in a functional setting
12:24:06 <ndm> > [show x | x <- [[2],[]]]
12:24:08 <lambdabot>  ["[2]","[]"]
12:24:20 <ndm> hygge: [] isn't an element in the first list you gave, it is in teh list above
12:24:22 <FransE> Magicman: let incr = (+1) gives me a parse error("possibly incorrect indentation")
12:24:29 <ndm> nomeata: pastebin the code
12:24:44 <thetallguy> The C semantics don't really apply
12:24:44 <nomeata> ndm: it's already there http://latexki.nomeata.de/Generic.html
12:24:45 <lambdabot> Title: The Latexki Latex Wiki Wiki - Generic
12:25:01 <Magicman> > let incr = (+1) in incr 3
12:25:02 <lambdabot>  4
12:25:33 <thetallguy> > succ 3
12:25:34 <ndm> nomeata: it has to keep the whole source file in memory
12:25:34 <lambdabot>  4
12:25:37 <Magicman> GHCi behaves normal too.
12:25:41 <FransE> Magicman: hmm, now I see. "let" creates a scope. (I'm a haskell noob)
12:25:44 <Magicman> succ for the win :)
12:25:44 <thetallguy> > pred 3
12:25:45 <lambdabot>  2
12:25:57 <lisppaste2> nomeata pasted "W/ syntax highlighting :-)" at http://paste.lisp.org/display/28512
12:26:11 <nomeata> ndm: yes, but only until's its written out, right?
12:26:13 <ndm> nomeata: if isReadable source then pre source -- isReadable wants to read all of source, pre wants to read all of source
12:26:19 <thetallguy> > take 10 $ map succ [1..]]
12:26:19 <lambdabot>  Parse error
12:26:21 <ndm> nomeata: as soon as its written out, yes
12:26:31 <nomeata> ndm: but the memory usage stacks up
12:26:34 <thetallguy> > take 10 $ map succ [1..]
12:26:35 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
12:26:37 <ndm> nomeata: but thats the very last thing thats done!
12:26:44 <Magicman> FransE: Yep. If you just create a .hs file with "incr = (+1)" it'd work, but succ is better, since it's already defined.
12:26:49 <ndm> it must read all the memory with the isReadable
12:26:57 <ndm> and then if its a text file, must keep it all around
12:27:08 <thetallguy> > take 10 $ map (* 2)  [1..]
12:27:09 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
12:27:14 <nomeata> ndm: why does it have to keep it around after writeFile?
12:27:23 <thetallguy> ++ is only one case
12:27:31 <FransE> Magicman: where can I read about for example 'succ'?
12:27:36 <ndm> nomeata: writeFile is the last action, so it doesn't, but it does until the end of that
12:27:51 <nomeata> ndm: but it seems to be keeping it even after writeFile
12:27:55 <Heffalump> ?type succ
12:27:56 <lambdabot> forall a. (Enum a) => a -> a
12:27:58 <thetallguy> the haskell syntax makes it easy to create a huge variety of functions easily
12:28:07 <ndm> nomeata: the GHC garbage collector will never release memory back to the OS, i think
12:28:17 <Heffalump> FransE: the fact that you want ++ suggests that you think Haskell has mutable variables
12:28:29 <vincenz> > take 10 $ map (join foldl (.) id . flip repeat succ)
12:28:30 <lambdabot>    Expecting a function type, but found `a'
12:28:30 <lambdabot>    Expected type: [a]
12:28:30 <lambdabot>    ...
12:28:34 <vincenz> > take 10 $ map (join foldl (.) id . flip repeat succ) [.110]
12:28:35 <lambdabot>  Parse error
12:28:38 <vincenz> > take 10 $ map (join foldl (.) id . flip repeat succ) [1..10]
12:28:39 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> b -> a
12:28:39 <lambdabot>    ...
12:28:39 <thetallguy> > map (\x -> x * 2 -1) [1..10]
12:28:40 * nomeata has an idea and tries -O2 instead of -O
12:28:41 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
12:28:43 <Heffalump> which it doesn't except in certain restricted circumstances
12:29:02 <vincenz> > take 10 $ map (\x -> join foldl (.) id . repeat x succ) [1..10]
12:29:03 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> b -> a
12:29:03 <lambdabot>    ...
12:29:24 <ndm> nomeata: after GHC has consumed nMb to read in the file, it never releases that memory back to the OS, although it will be "free" for GHC to use
12:29:34 <FransE> Heffalump: naa, in my world foo++ makes sense; foo wouldn't be modified. foo++ would evaluate to the result, simply.
12:29:46 <nomeata> that was it. with â-Oâ, it is keep even after writeFile, and was not even  âfreeâ for internal use
12:29:48 <FransE> ndm: can you really write serious app with such a policy?
12:29:55 <FransE> s/app/apps/
12:29:56 <Heffalump> FransE: then why not write foo+1 ?
12:29:57 <thetallguy> > (foo + 1)
12:29:57 <lambdabot>  Not in scope: `foo'
12:29:57 <SamB> ndm: I wouldn't assume so much
12:30:04 <nomeata> but with â-O2â, it would re-use it internally
12:30:07 <ndm> FransE: yes, i believe its the default of almost all GC languages
12:30:15 <FransE> hehe
12:30:22 <ndm> SamB, really? i don't have any "proof", but it is a standard technique
12:30:39 * nomeata would have expected that â-Oâ means âall sane settings for normal useâ. guess I guessed wrong :-)
12:30:40 <ndm> SamB, certainly Yhc never releases memory, its usually the wrong thing to do, and Perl 5.4 didn't (which was the last one i checked)
12:30:46 <SamB> I should think that it would be more likely for the GHC RTS to release memory than for a C program to do so ;-)
12:30:49 <FransE> Heffalump: can you give a reason to why for example C++ has the '++' operator?
12:30:54 <Cale> hmm, my irc client is blinking, was someone looking for me?
12:31:06 <Cale> FransE: because C had it
12:31:10 <SamB> if it notices that there is a lot less live data than there had been
12:31:11 <ndm> SamB, i may well be wrong, but my guess would be not
12:31:21 <Heffalump> FransE: because it does a destructive update too
12:31:21 <nomeata> so, what is are recommended ghc flags for a âreal world applicationâ in haskell?
12:31:21 <FransE> Cale: so there's no good reason for the operator?
12:31:26 <Heffalump> so it's much more concise than x = x + 1
12:31:26 <SamB> I mean, remember, this is a copying collector we are talking about!
12:31:30 <Magicman> FransE: Because programmers were too lazy to type (foo = foo + 1)
12:31:32 <Igloo> ndm is right unless I missed a change
12:31:34 <Cale> FransE: I think it's generally been considered a bit of a mistake
12:31:35 <Heffalump> also, the prefix and postfix notations are useful too
12:31:36 <ndm> nomeata: -O, -O2 for "fast as possible"
12:31:39 <FransE> Magicman: isn't that good?
12:31:45 <FransE> Cale: k..
12:31:46 <SamB> it would at least be feasable to implement
12:31:47 * ndm does his little i told you so dance ;)
12:31:49 <Cale> FransE: for instance, what does x+++++x do?
12:31:55 <Heffalump> the point is that in Haskell foo = foo + 1 is normally meaningless
12:31:56 <Magicman> D'oh... Heffalump was first :p
12:31:57 <SamB> unlike with, say, Python ;-P
12:32:02 <nomeata> ndm: but in this case -O was not useable, as it kept eating memory for no reason. Is that a bug then?
12:32:08 <SamB> > let foo = foo + 1 in foo
12:32:09 <lambdabot>  Exception: <<loop>>
12:32:14 <Heffalump> so then you just need foo + 1, in which case why bother with ++
12:32:23 <int-e> Cale: does not parse.
12:32:40 <ndm> nomeata: there are things like let movement etc, as far as i can tell your code deserves to eat space - GHC -O2 must be pulling out some pretty impressive tricks to avoid that :)
12:33:00 <Cale> int-e: well, that would be good. It's not immediately obvious that it shouldn't :)
12:33:22 <Magicman> FransE: foo = 3
12:33:22 <Magicman> k = foo++;
12:33:22 <Magicman> print k + foo;
12:33:31 <Magicman> suppose that was actual code, what should it print?
12:33:35 <int-e> Cale: t.c:8: error: invalid lvalue in increment
12:33:41 <nomeata> ndm: sorry, can't follow you there. what's bad with the code?
12:33:57 <int-e> Cale: x+++ ++x does parse, however.
12:34:05 <Cale> hehe
12:34:08 <ndm> nomeata: it must hold the whole file open in memory at once, right?
12:34:16 <SamB> int-e: that sounds like it parses to me!
12:34:57 <int-e> SamB: well, hmm. right. it parses as ((x++)++)+x which is an invalid expression.
12:35:09 <nomeata> ndm: well, it shoudnât be a problem as long as itâs only one file at a time
12:35:10 <int-e> I should have said 'that fails' and not be specific ;)
12:35:27 <SamB> hehe
12:35:27 <Magicman{away}> Meh, I'm afk for a while...
12:36:12 * SamB wonders if nobody has looked at his utility because it is a weekend, or what?
12:36:18 <ndm> nomeata: oh, does GHC *all* files in memory at once?
12:36:44 <ndm> SamB, i suspect the audience for your tool is only people named Simon, who only work during the week
12:36:52 <SamB> mmmm
12:37:04 <SamB> I didn't know my name was simon ;-)
12:37:05 <int-e> Cale: C++ actually suffers from a related problem in the template syntax. x<x<y>> is invalid because >> is a token but the parser wants > >. (I've been told that this is going to be fixed or is fixed. I forgot the details.)
12:37:19 <Cale> int-e: yeah
12:37:20 * SamB makes a note that apparantly his name is Simon
12:37:26 <nomeata> ndm: with -O it seemd as it if did not free it even internally, but with -O2 it seemed to do that
12:37:27 <ndm> as soon as you submit enough GHC patches you have to change your name by depoll
12:37:30 <Cale> int-e: It seemed broken last time I used it
12:38:14 <ndm> nomeata: i think it should, no idea what optimisation is playing with that one then :)
12:38:24 <SamB> Cale: well, of course your compiler most likely is not fixed yet
12:38:40 <nomeata> but I think I need to change to byestring for that, it's pretty expesive with [Char], it seems
12:38:40 <SamB> wait, oh, 2,3,4 years ;-)
12:38:46 <Cale> SamB: hehe
12:38:47 <Heffalump> SamB: what utility?
12:39:08 <SamB> Heffalump: I wrote a utility to compare the output of two cachegrind runs
12:39:09 <nomeata> OTOH, I'm too lazy to look into that now
12:39:16 <ndm> SamB, did you see my post where i beat GHC on speed?
12:39:24 <FransE> How do I introspect the type of an expression(for learning purposes)?
12:39:24 <SamB> ndm: where did you post it?
12:39:54 <SamB> @type "Hi!"
12:39:55 <lambdabot> [Char]
12:40:05 <SamB> or in GHCi or hugs, :t "Hi!"
12:40:34 <FransE> SamB_XP_: nothing that works in ghc?
12:40:35 <astrolabe> @type a where a = a
12:40:36 <lambdabot> parse error on input `where'
12:40:43 <int-e> @type 1
12:40:44 <lambdabot> forall t. (Num t) => t
12:40:48 <Cale> where is part of declaration syntax
12:40:50 <SamB> FransE: you don't have GHCi?
12:40:59 <Cale> @type let a = a in a
12:41:00 <lambdabot> forall t. t
12:41:06 <int-e> @type let a = a where a = a in a
12:41:07 <lambdabot> forall t. t
12:41:19 <int-e> sorry :)
12:41:24 <Cale> > let 0 = 1 in 1 + 1
12:41:25 <lambdabot>  2
12:41:33 <FransE> SamB_XP_: yes I do.
12:41:36 <astrolabe> Cale: what is declaration syntax?  Part of the language or lambdabot being individual?
12:41:46 * shapr hugs Heffalump 
12:41:51 <int-e> astrolabe: haskell
12:41:54 <Cale> astrolabe: as opposed to expression syntax
12:41:58 <SamB> FransE: so, load your module in GHCi and type ":t expression"
12:42:00 <Heffalump> shapr: ?
12:42:03 <shapr> Heffalump: Hi!
12:42:08 <SamB> unless you wanted to find the type of a subexpression?
12:42:09 <Heffalump> hi :-)
12:42:15 <shapr> Heffalump: Haven't seen you around lately, busy working?
12:42:25 <Heffalump> SamB: Igloo seems to work on ghc all hours of the day and all days of the week :-)
12:42:27 <astrolabe> Cale, so why won't lambdabot swallow it?
12:42:29 <Cale> astrolabe: 'where' connects to a whole equation, and scopes over guards
12:42:31 <Heffalump> shapr: yeah
12:42:41 <Cale> astrolabe: because what you're giving it is not an equation
12:42:45 <Heffalump> what are you up to?
12:42:46 <int-e> astrolabe: because lambdabot  wants an expression.
12:42:48 <FransE> Nah, I'm just trying to figure stuff out. It appears Haskell has no function that do this, it's something specific to ghci.
12:42:59 <SamB> its quite true
12:43:30 <int-e> astrolabe: the trick to get a declaration within an expression is to use let - as shown by  let a = b where b = b in a
12:43:36 <SamB> there is a Typeable class in Data.Typeable that can allow you to find types at runtime to a limited extent...
12:43:37 <Cale> FransE: right. In fact, the compiler generally eventually erases all the types from the code, so nothing is left of them at compile time.
12:43:47 <shapr> I have work too! Haskell work even.
12:43:54 <Cale> *cough* at runtime, I should way
12:43:56 <Cale> say*
12:44:02 <Cale> I can't type, or think :)
12:44:04 <ndm> SamB, http://neilmitchell.blogspot.com/2006/10/30-faster-than-ghc.html
12:44:05 <SamB> Cale: you should see Yhc
12:44:14 <SamB> Yhc even erases them at compile time ;-)
12:44:14 <Cale> SamB: I know Yhc keeps them :)
12:44:18 <Cale> oh?
12:44:30 <Botje> somebody asked me what some major uses of haskell were
12:44:34 * astrolabe scratches his head
12:44:37 <Cale> oh, right, but they are in the bytecode?
12:44:47 <shapr> Botje: confusing newbies?
12:44:49 <SamB> oh, sure, closure types or whatever I guess
12:44:58 <SamB> or non-closure types...
12:45:00 <Cale> Probably mostly gone :)
12:45:06 <Botje> shapr: well, yeah. the 2-line quicksort kind of blows most newbies heads
12:45:09 * shapr grins
12:45:14 <SamB> but the actual source-level types are totally wiped out
12:45:22 <Igloo> shapr: Cool - are you able to say who for?
12:45:29 <Cale> Botje: well, we'd like to think it's pretty general purpose
12:45:33 <shapr> Igloo: happs
12:45:39 <Igloo> Ah, right
12:45:52 <Heffalump> shapr: cool
12:45:54 <SyntaxNinja> everyone who gets paid for Haskell, raise your hand!
12:46:00 * SyntaxNinja raises hand
12:46:02 <Heffalump> are you being forced to move back to the US?
12:46:02 * shapr raises SyntaxNinja's hand
12:46:07 * ndm raises his hand
12:46:11 <shapr> Heffalump: Been in the USA since Sept 1st
12:46:14 <Cale> I have been paid for Haskell in the past :)
12:46:15 * astrolabe sort of raises his hand a bit
12:46:18 <Heffalump> ndm: hah, student grants aren't pay!
12:46:32 * SyntaxNinja raises Igloo's hand
12:46:42 <shapr> I like the HAppS approach to webapps, you define a state type, and a state transformer in terms of GET, PUT, etc
12:46:43 <SyntaxNinja> does anyone use sip for videoconferencing?
12:46:54 <shapr> I use it for voice.
12:47:01 <Heffalump> I think the idea of forcing single-threading is completely wrong, personally :-)
12:47:05 <shapr> I call Sweden, USA, etc with ekiga via voxee.com
12:47:10 <SyntaxNinja> so a couple years ago, I was the only one raising my hand.  things are getting better :)
12:47:17 <Heffalump> shapr: oh, where you living now, then?
12:47:27 <shapr> Birmingham, Alabama
12:47:33 <SyntaxNinja> shapr: cool! i've just been messing with it, got my digicam to work as a webcam and can do video too :)
12:47:42 <Heffalump> is sympathy appropriate? ;-)
12:48:00 <ndm> Heffalump: i get plenty, tax free, plus consulting and demonstrating
12:48:01 <shapr> My family is in Birmingham, I'm glad to be here to spend time with them.
12:48:09 <Heffalump> fair enough
12:48:22 <Heffalump> I don't have any personal experience, I'd just heard Alabama is a hole.
12:48:37 <Heffalump> ndm: consulting? Sounds good...
12:48:40 <shapr> Alabama is like any other place, good and bad points.
12:48:50 <ndm> Heffalump: i'm a Mac consultant, and have never used one :)
12:49:03 <int-e> wah, what an ugly prime number generator ... my eyes!
12:49:10 <Heffalump> ndm: perfect consultant, then
12:49:37 <SamB> what do mac consultants do?
12:49:48 <ndm> personally? dashboard widgets :)
12:50:10 <SamB> what do you do with them?
12:50:23 <ndm> write them
12:50:28 <SamB> what are they?
12:50:37 <ndm> @google apple dashboard widget
12:50:41 <lambdabot> http://www.apple.com/macosx/features/dashboard/
12:50:41 <lambdabot> Title: Apple - Mac OS X - Dashboard
12:50:57 <SamB> and how do you write them without using a Mac?
12:51:08 <ndm> Firefox, reading the docs, and guess work :)
12:51:43 <ndm> developing in IE, Firefox and Opera gives a rasonable indication that they'll often work in Safari
12:53:18 <astrolabe> ndm: I thought you were doing a PhD and working on a windows gui for hat.
12:53:46 <ndm> astrolabe: and an optimising compiler, and a bytecode compiler, and hoogle, and ....
12:54:20 <therp> ndm: oh may I ask a hoogle question? where would I get the base.hoo 4.0-pre is needing?
12:54:21 * astrolabe groans
12:55:09 <ndm> therp: check out the base library, create a blank Setup.hs, setup configure, setup haddock --hoogle
12:55:25 <ndm> but the chances of you getting 4.0-pre working at the minute are nearly nothing :)
12:55:53 <ndm> and once hoogle 4 is out, i'll put base.hoo up online
12:56:03 <SamB> ndm: drift may do nice things, but don't ever try to write a derivation for it!
12:56:27 <SamB> or, well, if you do, write a real framework ;-)
12:56:33 <ndm> SamB, never tried, thankfully - managed to tweak the existing GHC Binary one to be close enough to what i wanted
12:56:49 <therp> ndm: ah ok thanks. I just tried the version in darcs, because the hoogle wiki page recommended to do so
12:57:08 <SamB> (a real framework for printing the code, I mean)
12:57:08 <ndm> therp: the wiki page is probably wrong then, i guess i should make that clear
12:57:30 <ndm> therp: i'm half way between hoogle 3 and hoogle 4 so the darcs is a bit of a mess
12:57:47 <ndm> SamB, i will do for Yhc.Core soon enough, my one for Catch is working really well
12:58:26 <SamB> that won't be so bad
12:58:58 <SamB> but when you are trying to write code to generate code *and* the code to *print* the code at the *same time*, that isn't fun :-(
12:59:48 <roconnor> SamB, so, how did you change the patch to make it work in almost all cases?
13:00:42 <SamB> roconnor: oh, I made it include the case scrutinee in the calculated ExprSize
13:00:53 <SamB> er
13:00:55 <SamB> roconnor: oh, I made it include the case scrutinee in the calculated ExprSize
13:06:07 <FransE> What's a "Standard Prelude function"?
13:06:32 <SamB> something exported by the Prelude described in the Standard, maybe?
13:06:48 <FransE> k..
13:06:58 <roconnor> SamB, ah.  I don't understand that at all, but good on you.
13:07:14 <SamB> roconnor: it was just a guess anyway :-(
13:07:19 <SamB> I have no clue what to do next
13:08:04 <SamB> hmm
13:08:16 <SamB> does anyone know what s1YU_info is?
13:08:22 <SamB> or s2dK_info?
13:08:41 * SamB is wondering in particular why they haven't got module names at the beginning
13:08:46 <Cale> FransE: http://haskell.org/onlinereport/standard-prelude.html
13:08:48 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y2wv6o
13:09:49 <Cale> FransE: It's a good idea to read through that, though it's common for people to write about half of the things in the prelude while they're learning the language :)
13:10:09 <SamB> is it usually the same half?
13:10:15 <Cale> I don't know :)
13:10:15 <SamB> or all different halfs?
13:10:20 * SamB wonders
13:10:29 <Cale> Probably a little different at least
13:10:48 <SamB> it would be interesting to see what people never or rarely rewrite out of ignorance ;-)
13:11:10 * shapr sings the coding song
13:11:20 <shapr> Ok, who has an ekiga.net account?
13:11:27 * therp has
13:11:35 <shapr> therp: What's your address?
13:11:40 <therp> therp@ekiga.net
13:11:51 <Cale> What is ekiga.net?
13:12:00 <therp> cale: a sip proxy service
13:12:02 <shapr> therp: You're offline!
13:12:16 <therp> shapr: just a second :)
13:12:37 * gour has ekiga account too - gour@ekiga.net
13:13:10 <shapr> hm, I'm not convinced I can call out...
13:13:14 <therp> shapr: just a second!
13:13:19 <Cale> huh, I'd never heard of that protocol before
13:13:51 <therp> shapr: ok now :)
13:13:53 <shapr> Cale: CosmicRay got me started with SIP after I advertised Google Talk & Skype on #haskell ... he responded with http://changelog.complete.org/posts/375-fromdrupal.html
13:13:58 <lambdabot> Title: Google Talk And Skype Are Boring, And Here's Why - The Changelog, http://tinyurl.com/yyfln3
13:14:26 <shapr> therp: I hear you just fine, and I SEE YOU!
13:15:20 <shapr> therp: ok
13:17:03 <therp> shapr: hey cool! :)
13:18:40 <chessguy> now there's an elucidating quit message
13:22:38 <shapr> therp: That was nifty :-)
13:23:03 <psi> isn't ekiga the new name for gnome meeting?
13:23:20 <therp> shapr: yes :) think so too. what distribution are you using?
13:23:21 <shapr> therp: The lag was surprisingly small for USA <-> Austria
13:23:37 <shapr> therp: I'm using ekiga 2.0.3 in debian/unstable
13:24:02 <Fey> if anyone has a few minutes over, I am in need of debugging assistance. I have here a program that was working properly a short while ago. However, I have at some point changed some minor detail and voila, now it does not work
13:24:10 <Fey> the code is at http://www.rafb.net/paste/results/MUYGw997.html
13:24:25 <therp> shapr: ah debian it is. we have really much troubles on ubuntu and never managed to get it to work with audio over alsa, so I was actually surprised to hear anyone that does not sound like a robot. hm you change the audio codec to 8kHZ?
13:24:28 <Fey> the problem is in the function solve'
13:25:40 <shapr> therp: I think the choppiness on my end came from me using a 64kpbs codec on my 256k upstream, so I switched to a 32kbps codec and it got lots better.
13:26:01 <shapr> I was using PCMU, and switched to G721
13:27:05 <shapr> therp: One problem I had with ekiga is that the 8kbps speex codecs were selected by default when I installed, so I sounded like a robot to everyone :-)
13:28:12 <ex0r> if I have a function that returns a maybe, what do I need to put when it has nothing to return?
13:28:20 <ex0r> or do I just not return anything
13:28:24 <psi> ex0r: Nothing
13:28:35 <nomeata> can this cause a deadlock:
13:28:41 <nomeata> (inp,out,err,pid) <- runInteractiveProcess "svn" options Nothing Nothing
13:28:49 <nomeata> xml <- hGetContents out
13:28:55 <nomeata> waitForProcess pid
13:29:12 <nomeata> it seems that haskell waits for svn to finish while svn waits for haskell to read more data
13:29:21 <psi> ex0r: literally, what you type is Nothing
13:31:19 <nomeata> I gather that from using âstrace -pâ: haskell program is in âwaitpidâ, while svn is in âwriteâ
13:31:24 <Heffalump> ex0r: it's syntactically impossible not to return anything
13:33:49 <ex0r> ok cheers
13:34:12 <Fey> anyone can help me out with debugging the solve function? It can be found at e'
13:34:13 <Fey> <shapr> t
13:34:29 <Fey> sorry, at http://www.rafb.net/paste/results/MUYGw997.html
13:34:37 <astrolabe> Fey, in what way does it fail?
13:34:41 <ex0r> slightly unrelated question, why does the compiler sometimes say "unexpected ;" even when there is no ; in the code
13:34:45 <Fey> it never finishes
13:34:46 <nomeata> Heffalump: not entirely true: let thing = [] in return $ not (any thing)
13:34:55 <Heffalump> nomeata: :-p
13:34:56 <ex0r> is it just a badly phrased error
13:35:08 <Heffalump> ex0r: it's due to the layout rule
13:35:18 <Fey> it is supposed to print out a table, but it does not
13:35:20 <Heffalump> it usually means you got your indentation wrong
13:35:29 <Fey> it just keeps on going (supposedly)
13:35:31 <ex0r> oh right
13:35:37 <nomeata> is hGetContens in anyway dangerous?
13:35:46 <Heffalump> nomeata: yes, if the file changes in the meantime
13:37:20 <nomeata> Heffalump: it's not a file, is the output of a program. Whatâs the alternative?
13:37:24 <Heffalump> ex0r: basically the first step in parsing Haskell is to turn multiple lines of code into code that uses { } and ;
13:37:28 <Heffalump> nomeata: I think it's safe then.
13:37:39 <Heffalump> Except that your program might leak pipes and children and file descriptors and things.
13:37:47 <shapr> Fey: When should your code stop?
13:37:47 <nomeata> Heffalump: even if I wait for that program to finish right afterwards?
13:37:56 <Heffalump> nomeata: ah, there's your deadlock
13:38:00 <Heffalump> hGetContents is lazy
13:38:14 <Heffalump> the program won't finish until you consume all its output
13:38:14 <nomeata> Heffalump: ok, thought so. So whatâs the ârightâ way to do it?
13:38:25 <Heffalump> and you won't consume all its output until you finish waiting for it, potentailly :-)
13:38:38 <Heffalump> I don't know precisely, but there must be some non-lazy way to get all the output from something.
13:38:40 <Fey> shapr: When there are no longer any blanks
13:38:50 <shapr> Fey: And how do you detect that?
13:39:05 <Fey> shapr: isSolved
13:39:13 <nomeata> Heffalump: any problem in just not waiting for the program to finish?
13:39:20 <Heffalump> nomeata: NAFAIK
13:39:47 <nomeata> sounds like a global treaty on the ban of some kind of bad weapons
13:40:41 <Heffalump> Not As Far As I Know
13:40:45 <nomeata> I know :-)
13:40:52 <Heffalump> :-p
13:40:53 <shapr> Fey: Do you have a very simple sudoku that you are sure works? If so, can you feed that into your code?
13:41:00 <Fey> yes
13:41:05 <Fey> I have several
13:41:11 <Fey> isSolved works as it should
13:43:42 <Fey> in fact, part y part I cannot find anything that is wrong
13:44:02 <Fey> and the solve function itself seems to be correct as well
13:44:08 <Fey> thus, my predicament
13:46:16 <astrolabe> Maybe you could use Debug.Trace.trace to track down the problem.
13:46:27 <Fey> oki. How do I do that?
13:47:02 <astrolabe> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
13:47:04 <lambdabot> http://tinyurl.com/y4usfz
13:47:24 <Fey> thanks
13:48:22 <astrolabe> I normally make a back-up copy of my code before I start adding in trace statements
13:49:01 <ex0r> with let/in, can the statement after in be more than one line
13:49:06 <ex0r> like an entire block
13:50:25 <lisppaste2> ex0r pasted "n/a 2" at http://paste.lisp.org/display/28514
13:50:41 <ex0r> can someone just tell me if thats formated right
13:50:47 <ex0r> it wont compile for some reason
13:51:44 <astrolabe> x1 should be under best
13:51:46 <astrolabe> and x2
13:52:44 <ex0r> hmm if I move them under best (or past if you like) i get another error instead
13:52:58 <astrolabe> I don't like past
13:52:58 <ex0r> unexpected symbol x1 -> unexpected symbol =
13:52:59 <shapr> Fey: Another piece of advice, when doing code exploring, keep your code in darcs, and record your changes whenever you make some progress. Then if your code stops working and you don't know why, you can just dump those changes.
13:53:59 <Fey> yeah
13:55:45 <astrolabe> ex0r: this isn't your problem, but you are using more '( )' than you need.
13:56:05 <SamB> ice cream was never intended for people with teeth, was it?
13:56:59 <astrolabe> ex0r: still there?
14:00:14 <lispy> yay, i just found a bug in gnu as :)
14:00:33 <SamB> why is that grounds for "yay"?
14:00:41 <lispy> it's not
14:00:57 <SamB> stop with your groundless yaying!
14:01:08 * lispy cringes
14:01:30 <astrolabe> We have 'yay' police now?
14:01:37 <SamB> no
14:01:50 <SamB> I'm just trying to get lispy to make some sense ;-)
14:01:50 <astrolabe> yay!
14:02:10 <lispy> SamB: good luck with that :)
14:07:25 <nomeata> ndm: I just noticed that some of my memory observations with the code might come from the fact that I'm running it in /tmp which is a tmpfs. No wonder the memory adds up :-)
14:10:43 <sjanssen> @keal
14:10:43 <lambdabot> you need a Zh function in Haskell
14:10:47 <ex0r> astrolabe: sorry, went for some food
14:10:49 <sjanssen> @quote
14:10:49 <lambdabot> adaptec says: [in documentation for their raid chipsets] We have a disclaimer because there may be corner cases
14:10:53 <ex0r> ill have another look
14:12:15 <astrolabe> exOr: you need those lines I mentioned precisely lined up.
14:12:43 <ex0r> ah I see
14:12:56 <ex0r> that seems a bit silly to me but im not one to argue
14:13:08 <astrolabe> (not counting the word 'let')
14:13:46 <ex0r> yeah, still getting the bad layout error though
14:13:51 <ex0r> must have a loose tab somewhere
14:14:56 <astrolabe> ex0r: I think it is a good idea not to use tabs
14:15:12 <astrolabe> But if you do, they are equal to 8 spaces I think.
14:18:28 <Botty> they're actually variable, usually multiples of 2 spaces though
14:18:33 <Botty> I prefer 4
14:19:07 <sjanssen> bah, intercalate is such an obscure word
14:19:47 <sjanssen> dons: Way to try getting that bikeshed built.  Too bad nobody listened to your advice
14:21:06 <therp> shapr: btw 500@ekiga.net is a calltest service :)
14:22:45 <lisppaste2> ex0r annotated #28514 with "n/a @" at http://paste.lisp.org/display/28514#1
14:23:09 <ex0r> ya see from this end that looks like its lined up perfectly
14:23:24 <Fey> would this be a problem with lazy evaluation?
14:23:24 <Fey> solve' :: Sudoku -> Int -> Maybe Sudoku
14:23:24 <Fey> solve' sud n | n > 9 = Nothing
14:23:24 <Fey> 	     | isSolved sud = Just sud
14:23:24 <Fey> 	     | isOkay newSud = solve' newSud 1
14:23:25 <Fey> 	     | otherwise = solve' sud (n+1)	
14:23:27 <Fey> 		where newSud = update sud (blank sud) (Just n)
14:23:49 <Fey> will the newSud be re-evaluated for every recursive call?
14:24:03 <Fey> or will it reuse the old data?
14:24:44 <astrolabe> it will be re-evaluated I think
14:26:20 <Fey> bugger, I was hoping that would be the problem
14:26:43 <sjanssen> Fey: bindings are generally evaluated only once
14:27:19 <astrolabe> once per call of the containing function
14:27:41 <psi> ex0r: try indenting the last else inside the last if
14:27:50 <sjanssen> Fey: are you asking if newSud is re-evaluated for the calls of isOkay and solve'?
14:27:58 <sjanssen> the answer there is no
14:28:11 <Fey> no, if it is re-evaluated for each recursive call of solve'
14:28:49 <ex0r> psi: it thinks the error is on ~> x2 = filter (\n -> (fst(n) == trump)) hand
14:28:51 <sjanssen> Fey: yes, it must be recalculated, because the value will be different
14:29:01 <Fey> oki
14:29:21 <Fey> then I am at a loss
14:29:42 <sjanssen> ex0r: are there tabs in that source file?
14:29:45 <Fey> all the functions in solve' are working as they should, yet when I call the whole thing I get an endless loop of some kind
14:30:02 <ex0r> there are tabs in all my code, it hasnt complained until this last bit
14:30:13 <ex0r> but then again I havent used let until now
14:30:46 <ex0r> just replaced all the tabs, same error
14:30:47 <ex0r> very odd
14:30:51 <sjanssen> ex0r: the last line is your problem
14:31:08 <sjanssen> indent it an extra level, or join it with the previous line
14:32:01 <ex0r> I did that when psi mentioned it, makes no difference :(
14:32:31 <ex0r> just keeps complaining about the x2 line being a bad layout
14:32:33 <ex0r> hrm hrm
14:33:44 <mathewm> anyone have time for a newbie codereview - using GHC as a library
14:33:55 <psi> ex0r: your paranthesises are unmatched
14:34:00 <psi> on the previous line
14:34:29 <astrolabe> I just saw that!
14:34:53 <astrolabe> ex0r: too many parentheses!  We haskellers aren't used to them
14:34:56 <ex0r> your right they are
14:34:58 <psi> I was counting in my head. Then I noticed lispaste did coloring... :)
14:35:02 <ex0r> damn java experience
14:35:02 <sjanssen> ex0r: also, parens in things like "fst(n)" are redundant
14:35:45 <psi> ex0r: f a b c (this is how you call f with 3 arguments)
14:36:05 <astrolabe> x1 = filter (\n -> fst n == fst best && snd n < snd best) hand
14:36:11 <ex0r> yeah im just stuck in the java stone age
14:36:27 <ex0r> where copious amounts of pointless para's are commonplace
14:37:21 <wilx> Heh, copious, this is the first time I hear the word.
14:37:38 <nomeata> @h copious
14:37:39 <lambdabot> Maybe you meant: help hitchcock hoogle hoogle+ hylo . v
14:37:43 <nomeata> @hoogle copious
14:37:44 <lambdabot> No matches found
14:37:51 <nomeata> hmm. canât be an important word.
14:38:22 <wilx> Heh
14:38:29 <wilx> @g copious
14:38:29 <lambdabot> Maybe you meant: gazetteer get-definition get-shapr ghc girl19 google gsite gwiki . v
14:38:40 <wilx> @google copious
14:38:42 <psnl> @help get-shapr
14:38:42 <lambdabot> http://www.copious.co.uk/
14:38:42 <lambdabot> Title: Interactive agency based in London providing web design & interactive solutions
14:38:42 <lambdabot> get-shapr. Summon shapr instantly
14:38:50 <wilx> Heh.
14:39:17 <psnl> @get-shapr No reason, just testing
14:39:18 <lambdabot> shapr!!
14:40:06 <Lemmih> @time shapr
14:40:07 <lambdabot> Local time for shapr is Sun Oct 22 16:39:45 2006
14:40:25 <psnl> that would explain it
14:41:02 <astrolabe> can anyone tell me why I thought tabs in haskell were 8 spaces?
14:41:25 <ex0r> hmm, how come it doesn't like "else Nothing" - the compiler asks why it isnt of type card
14:41:38 <ex0r> I thought the whole point of maybe was you didnt have to return the type
14:42:53 <Lemmih> ex0r: Sounds like you missed a Just.
14:42:54 <astrolabe> ex0r: what is the type of last?
14:43:12 <goltrpoat> so ive been reading SPJ's 'implementing functional programming languages: a tutorial' paper, and sort of got off on a tangent:  how would one go about generating native code in a template instantiation scenario?  first, i figured i'd have primitives generate some sort of sequential IL, then gather heap nodes in a postprocess, and do register coloring/allocation from there
14:43:17 <ex0r> last x2 will return type Card
14:43:31 <ex0r> which I presume is the right syntax
14:43:36 <goltrpoat> but then i started about input, and like.. what happens there?  do i just say that anything that involves input as an argument is not a redex?
14:43:47 <astrolabe> but you are returning last x1 from playToWin
14:44:12 <Fey> okay, how do I turn off the lazy evaluation temporarily? I am trying to run a lot of debug thingies, modifying as I go, but the damn interpreter gives me the same result as last time even though I change the code params
14:44:24 <lisppaste2> sjanssen annotated #28514 with "typical Haskell style" at http://paste.lisp.org/display/28514#2
14:44:51 <Lajexande1> i need some help understanding wxHaskell
14:44:52 <sjanssen> ex0r: that's how most Haskellers would write that code
14:44:57 <SamB> Fey: did you reload your source file?
14:44:58 <goltrpoat> eg, (@ (negate) getChar) would end up generating the IL for the getChar primitive and negate primitive, and a call/inline inbetween?
14:45:03 <Fey> yup
14:45:08 <sjanssen> modulo indenting
14:45:09 <Fey> samB: yes
14:45:19 <SamB> did you remember to save it?
14:45:20 <ex0r> sjanssen: hmm didnt think of it that way
14:45:23 * SamB sometimes forgets
14:45:28 <Fey> samb: yeah
14:45:39 <Lajexande1> anyone here ever used wxHaskell?
14:45:54 <SamB> does your code happen to coincidentally do the same thing with those parameters?
14:46:50 <Fey> nope
14:46:53 <Fey> that is quite impossible
14:47:01 <Fey> I added a base case counter
14:47:07 <Fey> which has nothing to do with the rest of the code
14:47:23 <Fey> and its not even stopping at an edge-case !
14:47:30 <Fey> its stopping right in teh bloody middle
14:47:40 <astrolabe> ex0r: so either you need to make last return a  Maybe card, or change the lines in plYToWin to finish with 'Just (last x1)' and 'Just (last x2)'
14:47:54 <Lemmih> Fey: Post your session?
14:48:15 <psi> isn't last a standard function?
14:48:17 <psi> ?type last
14:48:18 <lambdabot> forall a. [a] -> a
14:49:00 * astrolabe slaps his head
14:49:04 <greenrd> Hmm
14:49:26 <Fey> http://www.rafb.net/paste/results/XmUOI570.html
14:49:29 <greenrd> Here's a challenge: is there a way to simulate GADTs when using a Haskell compiler than doesn't support GADTs?
14:50:05 <goltrpoat> functions instead of data constructors?
14:51:12 <Fey> maybe there is something with the blank
14:51:25 <eshrgrgfewgfe> what's a GADTs?
14:51:32 <greenrd> goltrpoat: So let's take this example: data SameType x y where IdenticalType :: SameType x x - how would I implement that?
14:51:46 <ex0r> sorry I hadn't seen Just before you mentioned it
14:52:14 <greenrd> - such that exhibiting IdenticalType allows the compiler to infer that x is the same type as y
14:52:50 <Lemmih> dons: ping.
14:53:34 <greenrd> eshrgrgfewgfe: Generalised Abstract Datatype - it's a GHC language extension - my example above gives the basic idea
14:53:49 <eshrgrgfewgfe> mmm
14:53:56 <scodil> is fmap not defined for tuples in the Prelude, or am I just doing this wrong : fmap ((+) 1) (5,6)
14:54:10 <greenrd> scodil: It's not, you need to import something
14:54:16 <mauke> sorry, you can't fmap over tuples
14:54:26 <eshrgrgfewgfe> data SameType x y where IdenticalType :: SameType x x --> how do you use this thing?
14:54:28 <goltrpoat> hrm
14:54:55 <greenrd> mauke: You can in ghc 6.6
14:55:01 <greenrd> scodil: import Control.Monad.Instances
14:55:19 <mauke> whoa
14:55:26 <scodil> greenrd: i don't see that module
14:55:31 <greenrd> scodil: However, note that it will only add one to the second element. Hopefully that's what you want.
14:55:35 <greenrd> scodil: It's only in ghc 6.6
14:55:51 <scodil> ah
14:56:21 <scodil> wait why only to the second element? why would it be different than mapping for lists, or anything else?
14:56:46 <greenrd> scodil: Because tuples can be heterogenous, and ordinary Haskell lists can't
14:57:03 <scodil> oooh
14:57:06 <scodil> gotcha
14:57:06 <greenrd> scodil: Think about fmap's type - it wouldn't work over a heterogenous tuple
14:57:13 <sjanssen> scodil: because that's how Functor works
14:57:18 <SamB> also, because types are curried ;-)
14:57:41 <sjanssen> fmap always applies to the last type argument applied to the constructor
14:58:25 <scodil> is there a standard mechanism for heterongenous tuples? do you see what I'm getting at here? some kind of map-type-thing over heterogenous tuples. does it exist or should i write it?
14:59:28 <greenrd> eshrgrgfewgfe: Like a normal data type - however, the compiler knows that type x = type y on the RHS of a -> or = when you pattern match on IdenticalType
14:59:35 <greenrd> scodil: How would you write it?
15:01:27 <scodil> well it would be for specific tuples  :   tmap :: (a->b->c) -> (a,a,a)  -> (b,b,b) -> (c,c,c)
15:01:31 <scodil> defined as you'd expect
15:01:53 <greenrd> those are all homogenous though
15:01:56 <scodil> right
15:01:57 <mauke> that doesn't look like a map
15:02:22 <scodil> how does that not look like a map? think of the tuples as lists of fixed length
15:02:33 <mauke> yeah, that's zipWith
15:02:34 <greenrd> it looks like zipWith for triples
15:02:39 <scodil> oh right
15:04:34 <Lemmih> @msg dons Did I write this code http://www.cse.unsw.edu.au/~dons/code/hs-plugins/scripts/Setup-with-ghc.lhs ?
15:05:37 <Lemmih> doh.
15:09:42 <Fey> hmm
15:09:58 <Fey> The function works properly for 4 sucessful iterations
15:10:16 <Fey> after that it stops and just responds with success without advancing
15:10:19 <greenrd> @hoogle unsafeCoerce
15:10:20 <lambdabot> No matches found
15:10:22 <greenrd> @hoogle unsafeCoerce#
15:10:22 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
15:11:55 <astrolabe> debugging isn't haskells strong point at the moment.
15:13:32 <Lemmih> astrolabe: We have breakpoints and generic object viewers in GHC.
15:14:19 <greenrd> For my GADT without GADTs problem, I guess could define kludge :: EqualTypes x y -> x -> y
15:14:21 <mathewm> how do you use breakpoints?
15:14:29 <greenrd> as kludge IdenticalTypes = unsafeCoerce#
15:15:08 <greenrd> and then prepend any use of an x as a y with (kludge evidence)
15:15:09 <greenrd> ugh
15:15:18 <astrolabe> Lemmih: what are they? do you have a link?
15:15:41 <greenrd> Of course, unsafeCoerce# is probably GHC-specific
15:15:45 <beelsebob_> astrolabe: debugging is easy
15:15:52 <beelsebob_> as long as you use Haskell
15:15:55 <Lemmih> astrolabe: The good stuff didn't make it into ghc-6.6.
15:16:06 <beelsebob_> Hat supports a large superset of Haskell
15:16:12 <scodil> if you want to create an instance of a class you have to use 'data' right? you can't use 'type' or 'newtype' ?
15:16:13 <greenrd> so I could define unsafeCoerce# = undefined, but then I wouldn't be able to execute my programs, haha :)
15:16:16 <astrolabe> beelsebob_: i WISH that was true
15:16:28 <ThreeQ> scodil: newtype will work, type will not
15:16:33 <beelsebob_> astrolabe: it is true - just 99% of people here are not writing Haskell
15:16:39 <astrolabe> I can't get hat to work on my code.
15:16:45 <astrolabe> beelsebob: how so?
15:16:54 <beelsebob_> it's probably not Haskell then
15:17:00 <beelsebob_> what does hat trip up on
15:17:17 <astrolabe> It doesn't like numbers in the form 1.5e13
15:17:19 <mathewm> scodil: I thought you could use newtype
15:17:21 <scodil> I get a parse error :  newtype Vector2 a = (a,a) deriving (Eq,Show)
15:17:29 <astrolabe> thought that is a small thing
15:17:30 <beelsebob_> astrolabe: Malcolm fixed that buy
15:17:32 <beelsebob_> bug*
15:17:45 <beelsebob_> and anyway... I thought it was 1e13 - 1.5e13 was fyine
15:17:51 <expwiz> scodil: missing constructor?
15:17:58 * beelsebob_ notes also that 1e13 is an identifier under the Haskell 98 standard
15:17:58 <astrolabe> beelsebob: you're right
15:18:00 <beelsebob_> (not a number)
15:18:17 <astrolabe> ooooh is it?
15:18:21 <beelsebob_> yes
15:18:29 <astrolabe> 2) It didn't like diffArray
15:18:29 <beelsebob_> it has to have a decimal point in it to be a number
15:18:53 <beelsebob_> Data.Array.Diff is not a standard Haskell library
15:19:00 <scodil> expwiz: yeah that was it. so there would be no point in  me using a tuple, right? I should just make it data Vector2 a = Vector2 a a derving (Eq,Show)
15:19:25 <beelsebob_> astrolabe: so you see... Haskell debugging is fine - things similar to haskell debugging is not
15:19:27 <Lemmih> scodil: Yeah.
15:19:27 <astrolabe> beelsebob: Ah, is there an efficient substitute which is standard?
15:19:32 <expwiz> scodil: I'm new to haskell also, but that is what I would do :)
15:19:41 <beelsebob_> (although perhaps we should be aiming at debugging things similar to haskell)
15:19:44 <scodil> if I define (+),(-),(*) and the like for types of (a,a) why can't I declare (a,a) to be an instance of Num ?
15:19:48 <beelsebob_> astrolabe: not a clue
15:20:20 <astrolabe> beelsebob_: it didn't like data.map either.  I guess you'll say the same thing.
15:20:25 <expwiz> scodil: instance Num Vector2 where ... should work
15:20:43 <beelsebob_> astrolabe: indeed - Data.Map is not standard Haskell, although I know Malcolm is working on that
15:21:11 <beelsebob_> we're currently working on Hat 2.06 which should support a lot of the common problems people have
15:21:11 <astrolabe> beelsebob_: So standard = the stuff in the report?
15:21:14 <ThreeQ> scodil: that should work, I think
15:21:17 <scodil> yeah but then I got this Vector2 that I have to lug around.  I'd like to forgo the constructor
15:21:21 <ThreeQ> instance Num a => Num (a, a) where
15:21:26 <beelsebob_> astrolabe: yes, and Hat supports all of Haskell 98, plus a bit more
15:21:31 <astrolabe> beelsebob_: That would be really excellent!
15:21:36 <Lemmih> ThreeQ: It's not valid Haskell98.
15:21:45 <ThreeQ> ah
15:22:22 <Lemmih> ThreeQ: You can make it work with the right amount of ghc flags, though.
15:22:22 <mathewm> the haskell98 report explicitly calls 'instance C (a,a) where...' out as invalid
15:22:26 <beelsebob_> astrolabe: I know that Data.Map is on the list to be fixed in 2.06
15:23:01 <astrolabe> beelsebob_: is there an ETA?
15:23:05 <beelsebob_> even if it may be that we write a naÃ¯ve inefficient version
15:23:17 <beelsebob_> astrolabe: I think the last ETA involved trying to have something by Jan or Fex
15:23:19 <beelsebob_> Feb*
15:23:27 <astrolabe> cool!
15:23:31 <scodil> ThreeQ: thanks. thats what I was looking for
15:23:33 <beelsebob_> if you have a specific list of requirements then send them to me
15:23:43 <beelsebob_> and I can prod the list saying here's some stuff the comunity wants
15:23:51 <beelsebob_> but I can't guarentee it'll make the cut
15:25:04 * beelsebob_ goes to gen a character
15:31:17 <Fey> woohoo, I found the problem
15:34:50 <Lajexande1> I have made a sudoku solver which imports a module Sample but when I try to compile GHC tells me it cannot be found :/
15:35:41 <Lajexande1>     Failed to load interface for `Sample': ;        Could not find module `Sample': ;          locations searched: ;            Sample.hi ;            Sample.hi-boot
15:36:50 <Lemmih> Lajexande1: Did you use --make?
15:37:58 <Lajexande1> ehm... no
15:38:09 <Lajexande1> this is my first time ever compiling anything =)
15:39:59 <Lajexande1> yay! but i have a small thing i need fixing, see i said that main = readAndSolve
15:40:42 <Lajexande1> readAndSolve :: FilePath -> IO () <-- so how do i solve this?
15:41:56 <Botje> let main give the argument to readAndSolve ?
15:42:13 <unclear> Lajexande1: eyy been looking for you all day.
15:42:27 <Lajexande1> so main :: FilePath -> IO () ??
15:42:56 <Lemmih> Lajexande1: main is always :: IO ().
15:43:16 <Lajexande1> but then it can't take any arguments...
15:43:44 <Lajexande1> i'll make a paste.lisp outta this
15:43:48 <Lemmih> Lajexande1: That's right. But we have System.Environment.getArgs instead.
15:45:26 <dons> sjanssen: re. bikesheds. yeah :/
15:45:26 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:45:33 <Fey> if I have a list of 9 elements, what should I use to split that list into a list of 3 lists of 3 elements each?
15:45:35 <dons> but we at least have the patch
15:45:38 <lisppaste2> Lajexander pasted "Sudoku solver compiling trouble..." at http://paste.lisp.org/display/28519
15:45:41 <unclear> Lajexande1: PM....
15:46:36 <dons> Lemmih: i think 'twas I who wrote that Setup.hs
15:47:13 <Lajexande1> dons: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/ListDoc/
15:47:21 <lambdabot> Title: Haskell's Standard List Functions, http://tinyurl.com/ydom9r
15:47:32 <dons> ?users #haskell
15:47:33 <lambdabot> Maximum users seen in #haskell: 256, currently: 234 (91.4%), active: 49 (20.9%)
15:47:59 <dons> Lajexande1: ?
15:48:17 <dons> looks like a nice tut. should be linked to from haskell.org
15:48:48 <Lajexande1> the soloution to getting 3 lists with 3 elements each is there
15:49:00 <Lemmih> dons: Right, I thought I wrote something like it but it didn't look familiar.
15:49:27 <dons> Lajexande1: I suspect you're talking to the wrong person?
15:49:30 <Lajexande1> The page is from an old Introduction to Functional Programming held by John Hughes here at Chalmers
15:49:34 <Lajexande1> so ask him =)
15:50:09 <Lajexande1> Fey: oops... that link was for you
15:50:42 <dons> i've linked it here anyway, since it looks good, http://haskell.org/haskellwiki/Books_and_tutorials#Reference_material
15:50:45 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y9ee8z
15:50:45 <dons> :)
15:50:46 * Lajexande1 uses Gaim and Fey and dons got the same color for their names *
15:51:13 <Lajexande1> but someone... please annote: http://paste.lisp.org/display/28519
15:51:35 <astrolabe> What is with all these suduko solvers?
15:51:59 <unclear> Lajexande1: join #data06 for a sek would you.
15:52:07 <Lajexande1> astrolabe: good way to learn using lists
15:53:13 <Lajexande1> I completely suck at IO and I have no idea of how to use System.Environment.getArgs
15:54:29 <Botje> main = do
15:54:30 <ndm> Lajexande1: getArgs is pretty easy, basically do:
15:54:36 <Botje>       args <- getArgs
15:54:47 <Botje>       readAndSolve $ head args
15:54:49 <Botje> roughly
15:55:19 <ndm> or
15:55:25 <ndm> [args] <- getArgs
15:55:29 <ndm> readAndSolve args
15:55:36 <ndm> moving the pattern matching a bit
15:55:38 <Botje> what if there's more than one argument?
15:55:44 <Botje> does it still work?
15:56:30 <ndm> (args:_) <- getArgs
15:56:42 <Botje> that's what I was thinking of as alternative, yes
15:56:45 <ndm> no, it doesn't, but it also crashes explicitly rather than ignoring redundant args
15:56:49 <Botje> ah :)
15:57:12 <astrolabe> Lajexande1: Something like
15:57:14 <Botje> is [one,two,three] the correct syntax to patternmatch a list of 3 arguments?
15:57:16 <astrolabe> main = do
15:57:22 <ndm> Botje: yes
15:57:32 <ndm> Botje: exactly 3, no more no less
15:57:37 <astrolabe>    argLst <- getArgs
15:57:54 <astrolabe>    otherStuffhere argLst
16:01:52 <scodil> i don't have ghc 6.6 installed, but when I do, I'll be able to do this :  f (!x,!y) = ...    right?
16:03:30 <beelsebob> what, to force the evaluation of x and y?
16:03:47 <beelsebob> probably... but why on earth would you want to?
16:03:52 <scodil> for optimization. a heterogenous tuple that's strict in all of its elements could be optimized by the compiler to act like a small, fixed-size array.
16:03:56 <scodil> less memory
16:04:10 <beelsebob> much much more time in most cases though
16:04:23 <scodil> why?
16:04:23 <ndm> scodil: only if you add -fbang-patterns
16:04:30 <beelsebob> anyway, it would be a small fixed sized array anyway
16:04:36 <beelsebob> a fixed sized array of pointers
16:04:59 <ndm> scodil: but don't, please, unless you find that at runtime things are too slow - otherwise you're likely to get it wrong and it will go slower
16:05:25 <beelsebob> 99% of the time optimisation problems are to do with being too strict, not too lazy
16:05:26 <scodil> right, but lets say its just (Int,Int).. having the pointers in there doubles the size.
16:05:35 <Lajexande1> not in scope: getArgs
16:05:40 <scodil> ndm: i know i know
16:05:47 <SamB> beelsebob: in which language?
16:05:48 <ndm> Lajexande1: import System.Environment at the top
16:05:51 <scodil> its for small vectors of numbers though
16:05:52 <beelsebob> SamB: Haskell
16:05:59 <scodil> you would never need lazyness there
16:06:03 * SamB doesn't think so
16:06:13 <SamB> it could be as much as 70%
16:06:15 <beelsebob> why not - it could be that the numbers are *increadably* complex to compute
16:06:30 <ndm> scodil: does it double the size? in my compiler its half the size of GHC anyway
16:06:32 <beelsebob> SamB: 99.342% of statistics are made up on the spot :P
16:06:43 <beelsebob> ndm: :P
16:06:47 <SamB> but most people start lazy and add strictness only when compelled...
16:06:52 <scodil> right
16:06:56 <scodil> this is what i'm asking about
16:07:05 <scodil> i can add strictness just by throwing in some bangs
16:07:08 <ndm> beelsebob: have you seen my benchmark, 33% faster than GHC
16:07:13 <Lajexande1> is the x.o my binary?
16:07:14 <scodil> and maybe it will help, maybe not
16:07:17 <ndm> scodil: you'll gain more in size by using unboxing
16:07:18 <beelsebob> ndm: no - on which programs?
16:07:28 <ndm> Lajexande1: do ghc --make, then you'll get a proper binary
16:07:41 <beelsebob> SamB: most people *mean* to start lazy, but end up actually introducing strictness they don't notice
16:07:42 <ndm> beelsebob: http://neilmitchell.blogspot.com/
16:07:44 <lambdabot> Title: Neil Mitchell's Haskell Blog
16:07:45 <scodil> ok thats what I'm trying to get at... if I have a type (T !Int !Int) is it unboxed?
16:07:48 <SamB> beelsebob: where?
16:07:51 <Lajexande1> i did... i got a sudoku.hi and a sudoku.o
16:07:55 <ndm> scodil: with GHC, no
16:08:08 <beelsebob> SamB: as an example, my debugger is specifically designed to work because of lazyness
16:08:09 <ndm> Lajexande1: is your main module called module Main in the declaration?
16:08:14 <SamB> with -funbox-strict-fields, yes
16:08:20 <Lajexande1> module Sudoku
16:08:26 <beelsebob> I've introduced maybe 20 bugs that made it more strict than I thought it should be
16:08:30 <ndm> Lajexande1: module Main
16:08:36 <Lajexande1> *fixing*
16:08:44 <scodil> SamB: thanks
16:08:45 * ndm senses a strict-check plug coming
16:09:06 <SamB> something of beelsebob's?
16:09:09 <ndm> scodil: but i have to stress, do these things if your program is too slow
16:09:16 <ndm> SamB, Olaf - bob's supervisor
16:09:16 <beelsebob> SamB: no, Olaf's
16:09:19 <SamB> oh
16:09:48 <scodil> ndm: i get it. i was just wondering if these types of optimizations are made by the compiler
16:09:49 <ndm> beelsebob: coming to Fun in teh afternoon?
16:09:51 <beelsebob> ndm: do you use yhc to generate haskell to give to ghc?
16:10:04 <ndm> beelsebob: for now, yes, but i have my backend in development
16:10:07 <beelsebob> ndm: fun in the afternoon?
16:10:13 <Lajexande1> ndm: a.out, sudoku.hi, sudoku.o
16:10:17 <ndm> scodil: by my compiler, yes, it will automatically resize them
16:10:18 <SamB> okay, who wrote this? http://haskell.galois.com/cgi-bin/haskell-prime/trac.cgi/wiki/BinaryIO
16:10:21 <lambdabot> Title: BinaryIO - Haskell Prime - Trac, http://tinyurl.com/y8qbe4
16:10:21 <ndm> Lajexande1: a.out is the binary
16:10:23 <beelsebob> ndm: makes sens - but your stats are out slightly
16:10:28 <SamB> especially the part where it talks about fps?
16:10:34 <ndm> beelsebob: why?
16:10:38 <beelsebob> you should be discarding the slowest and fastest, and then taking the mean
16:10:42 <beelsebob> not taking the fastest
16:10:57 <SamB> which, iirc, is not really layered over System.IO...
16:10:58 <beelsebob> (and provide a standard deviation)
16:11:04 <ndm> beelsebob: wrong, my computer does many things - the fastest time is likely the one with the least contention - hence the correct one
16:11:20 <ndm> beelsebob: but it makes nearly no difference
16:11:29 <beelsebob> ndm: then use the time utility which records CPU time used by the process instead of actual time used
16:11:31 <Lajexande1> does GHC make use of SMP by default? (i can maybe run this on a remote server...)
16:11:32 <beelsebob> time passed*
16:11:44 <audreyt> Lajexande1: no you have to compile with -threaded
16:11:51 <audreyt> and then env GHCRTS=-N2
16:11:57 <audreyt> to make use of two CPUs
16:12:09 <ndm> beelsebob: the details are unimportant, they had a small deviation, nearly nothing
16:12:11 <audreyt> (and then you need to structure your program using either "par" or "forkIO".)
16:12:16 <beelsebob> ndm: fair enough
16:12:35 <Lajexande1> so shell> ghc --make -threaded GHCRTS=-N2 sudoku.hs ?
16:12:42 <audreyt> no
16:12:45 <ndm> beelsebob: anyway, i beat GHC, so woot woot :)
16:12:46 <audreyt> ghc --make -threaded sudoku.hs
16:12:51 <audreyt> env GHCRTS=-N2 ./sudoku
16:12:52 <audreyt> or
16:12:56 <audreyt> ./sudoku +RTS -N2
16:12:57 <beelsebob> ndm: true dat
16:13:19 <audreyt> it really scales linearly, I can vouch for that :)
16:13:24 <ndm> beelsebob: and hopefully my back end will beat them further, but thats harder to predict - but its definately more space efficient
16:13:50 <beelsebob> ndm: makes sense - do you already beat ghc in terms of memory usage?
16:14:23 <ndm> beelsebob: i have no easy and reliable way to tell, but i suspect so
16:14:37 <ndm> beelsebob: using my back end, i'll absolutely kill them on memory useage
16:15:15 <dons> mmm? what's this? SMP sudoku?
16:15:19 <dons> (the first of its kind??)
16:15:47 <SamB> dons: not yet, I think
16:16:13 <dons> would make a nice tut for smp ghc...
16:16:42 <dons> if someone wants to STM/SMP-ify one of the fun non-det solves
16:16:43 <frevidar> is there a haskell function that you retrieve the maximum in a list given a ordering passed as an argument?
16:16:47 <dons> rs
16:16:54 <dons> > maximum [1..10]
16:16:56 <lambdabot>  10
16:16:57 <Lajexande1> dons: our solver takes about 2 minutes when solvin a harder sudoku
16:17:03 <dons> ?oogle maximumBy
16:17:03 <lambdabot> Maybe you meant: google hoogle
16:17:07 <dons> ?hoogle maximumBy
16:17:08 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
16:17:08 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
16:17:22 <dcoutts> hia dons
16:17:27 <frevidar> ah, cool, thanks
16:17:29 <dcoutts> dons, so we're ready I think.
16:17:31 <dons> hey dcoutts. patch applied.
16:17:36 <dons> and you saw rl's patch?
16:17:51 <audreyt> is there any SIMD (MMX, altivec, etc) works on GHC?
16:17:59 <dons> in the works, yes.
16:18:12 <dcoutts> dons, yes, I saw them.
16:18:14 <audreyt> is there some URLs I can put into my OOPSLA/DLs keynote tomorrow?
16:18:41 <dons> dcoutts: ok. let me grab my coffee and see if rl is up
16:18:44 <dons> audreyt: looking...
16:18:53 <dcoutts> dons, aye
16:18:53 <dons> audreyt: and send me the url, so i can stick it in the hwn
16:19:01 <audreyt> to the slides? sure
16:19:06 <dons> yep, once they're done
16:19:21 <audreyt> they're done (same as my intel talk) just adding SIMD/MIMD slides
16:19:35 <audreyt> but sure
16:20:12 <dons> you've got the DPH link, which points to a lot of related material?
16:24:55 <dons> audreyt: for the next version of ghc, http://hackage.haskell.org/trac/ghc/ticket/594
16:24:59 <lambdabot> Title: #594 (Support use of SSE2 in the x86 native code genreator) - GHC - Trac, http://tinyurl.com/y75z3u
16:25:06 <dons> note that the x86_64 supports SSE2 already.
16:25:07 <audreyt> good, that's what I'm looking for
16:25:16 <audreyt> dons++
16:25:21 <audreyt> and is the GC already multithr in trunk
16:25:35 <audreyt> or is it still in the future?
16:26:13 <dons> not yet. that's for 6.8, see http://www.haskell.org/pipermail/glasgow-haskell-users/2006-October/011312.html
16:26:16 <lambdabot> Title: Parallel GC, http://tinyurl.com/yxn62x
16:26:24 <dons> the prototype is done
16:26:30 <audreyt> much thanks
16:26:40 <audreyt> very, very exciting
16:26:47 <dons> yes!
16:26:56 <audreyt> I noted this morning that if you have 16 CPUs, then Pugs beats perl5 in speed ;)
16:27:04 <dons> woot!
16:27:05 <audreyt> (but that's not by far the normal case at the moment)
16:27:11 <dons> soon soon ....
16:28:28 <Lajexande1> how many cores/cpu was intel saying that they were developing at the moment?
16:28:38 <dcoutts> at least 4
16:28:44 <SamB> no, 2 CPUs is far more likely
16:28:46 <SamB> ;-)
16:28:51 <Lajexande1> i think it was more like 40 or so
16:29:01 <dcoutts> Sun have 32
16:29:03 <SamB> that figure is for Lemmih's box...
16:29:06 <Lajexande1> to hit the market in a few years
16:29:08 <dcoutts> some Mips company had 16
16:29:12 <dons> dcoutts: rl's Sun has 40.
16:29:13 <dcoutts> had/has
16:29:24 <dcoutts> dons, that's CPUs, not cores per CPU
16:29:27 <dons> ah right :)
16:29:48 <dcoutts> Sun sell a $3k box with one CPU, 8 cores and 4 threads per core.
16:29:53 <dons> yeah, nice.
16:29:59 <dons> but the mips still sounds better :)
16:30:04 <dons> what was that, 16/3k ?
16:30:08 <dcoutts> and the mips thing is 16 cores
16:30:14 <mbishop> I've known a few people with quads and even one that had 8 cpus
16:30:16 <dcoutts> also $3k ish
16:30:31 <dons> audreyt: sounds like it should be renamed the pugs machien, this 16 core cheapish mips box....
16:30:57 <dcoutts> dons, though the mips is 500MHz or 600MHz and the sparc is 1GHz or 1.2 GHz
16:31:15 <dons> Hz isn't everything though
16:31:17 <dcoutts> so it's not clear which would be better
16:31:22 <dons> yeah, it'd be close
16:31:47 <dcoutts> we need native code generators for Sparc and MIPS.
16:31:54 <dons> audreyt: note that with -optc--msse3 you can get some sse out of ghc already, via gcc
16:31:56 <dcoutts> who want's to do it? :-)
16:32:10 <dons> we have one for sparc, no? that's what rl was working on.
16:32:13 <dons> adding smp stuff
16:32:35 <dcoutts> dons, is he reviving the sparc NCG? Last I heard it was bitrotted in the 6.2 -> 6.4 CMM transition.
16:32:49 <dons> he's committed into it, and used it, I think
16:32:55 <dcoutts> nice
16:32:56 <mbishop> speaking of, anyone developer here wants a dual 300MHz ultrasparc II with 128MB of RAM, for free? (you pay shipping)
16:33:00 <goltrpoat> <Lajexande1> how many cores/cpu was intel saying that they were developing at the moment?   <-- 80
16:33:06 <dons> mbishop: where are you?
16:33:14 <mbishop> dons: united states, louisiana to be specific
16:33:17 * dons hopes sydney.. doh!
16:33:21 <dcoutts> dons, tell him to tell me when he has something I can test. I've got sparc linux and sparc solaris.
16:33:21 <goltrpoat> weird number, but that's what they said they had a prototype for
16:33:25 <dons> mbishop: shapr could just about pick it up..
16:33:29 <Renkin> ok, I'm back again with my Env-function, if you guys remember =)
16:33:38 <dcoutts> dons, why is rl never here on #haskell ?
16:33:41 <Renkin> I gave up temporarely before
16:33:53 <dons> i'll ask. he's awak and sitting in the ~pls chan
16:33:55 <dcoutts> Renkin, how's it going now ?
16:34:13 <Lemmih> goltrpoat: url?
16:34:14 <mbishop> dons: shipping, even in the US, would be quite a bit (like $25-$30 USD), because that damn box is heavy :P
16:34:19 <dcoutts> dons, what irc server ?
16:34:26 <Renkin> well, I can't figure out what I have that distiguishes the two cases
16:34:29 <goltrpoat> lemmih:  not sure.. it was on slashdot a few weeks ago
16:34:38 <Renkin> so I can't do any if/case
16:34:46 <goltrpoat> ah yes.. here:  http://news.com.com/Intel+pledges+80+cores+in+five+years/2100-1006_3-6119618.html
16:34:49 <lambdabot> Title: Intel pledges 80 cores in five years | CNET News.com, http://tinyurl.com/jmtds
16:35:10 <dons> dcoutts: on irc.slashnet.org, you remember that one?
16:35:13 <ndm> Renkin: did you follow my suggestion?
16:35:19 <mbishop> I read a story about the guys from Epic talking highly about haskell, and mentioning that computers will have "80 cores"
16:35:29 <SamB> what a strange number!
16:35:35 <SamB> not being a power of two and all ;-)
16:35:40 <Renkin> ndm, yes, kinda
16:35:46 <dons> mbishop: you could ping glasgow-haskell-users@ or haskell-cafe@haskell.org
16:35:48 <goltrpoat> samb:  yeah, i'm not sure what's up with that
16:35:53 <ndm> Renkin: ok, paste it expanded out
16:35:59 <dons> i think there's probably someone in the region who'd like it.
16:36:30 <Renkin> extendEnv :: (VarId -> Maybe Int) -> VarId -> Int -> (VarId -> Maybe Int)
16:36:30 <Renkin> extendEnv e v i = (\v -> Just i)
16:36:45 <ndm> Renkin: ok, see those trailing brackets? you can expand them out
16:36:58 <goltrpoat> mbishop:  i'm in texas, i'll take it if there's no one closer that wants to just drop by and pick it up
16:36:59 <ndm> and see that \v -> ... - you can move the \v as a proper argument
16:37:21 <Renkin> hmm
16:37:25 <ndm> Renkin: once you've done those two things, it should be a little more obvious
16:37:25 <Renkin> trailing brackets?
16:37:30 <dcoutts> dons, hmm, I seem to be the only on in #pls there. Am I spelling that right?
16:37:31 <mauke> ?pl extendEnv e v i = (\v -> Just i)
16:37:31 <lambdabot> extendEnv = const (const (const . Just))
16:37:36 <ndm> ... -> Int -> VarId -> Maybe Int
16:37:56 <ndm> Renkin: in the type sig, remember -> is the right kind of associative to remove those brackets
16:38:21 <mbishop> goltrpoat: I doubt anyone will pick it up, but I might give it a little more time to see if someone does say something, probably by tomorrow or so I'll send you my paypal address if you still want it
16:38:27 <dons> dcoutts: no. #maya
16:38:38 <dons> I said it was the ~pls channel :)
16:38:55 <Renkin> const is -> ?
16:39:08 <goltrpoat> mbishop:  cool
16:39:10 <Renkin> oh, no
16:39:12 <ndm> Renkin: ignore the points free thing, since its hte points free version of something thats wrong :)
16:39:36 <mbishop> goltrpoat: doesn't have a hard drive btw, but any 1" scsi should fit, and it does include the spud to hold the drive in.
16:39:53 <mauke> ?. djinn type const
16:39:54 <lambdabot> f a _ = a
16:40:06 <goltrpoat> mbishop:  ah ok
16:40:24 <Renkin> ok, I'll study what you said for a while
16:40:35 <goltrpoat> yeah i should have a few drives lying around
16:41:50 <ndm> Renkin: if you write it out in properly expanded form, take a look at what "input" you have, you should be able to figure out how to decide what is what
16:42:10 <Botje> by way of exercise i've tried to solve ACM problem #105, could someone give some (constructive) criticism? problem at http://acm.uva.es/p/v1/105.html, solution at http://sial.org/pbot/20602
16:42:12 <lambdabot> Title: The Skyline Problem
16:42:46 <mbishop> http://laurel.actlab.utexas.edu/~cynbe/hotlist.html <-- some neat stuff, even mentions haskell :P
16:42:49 <lambdabot> http://tinyurl.com/yxb3c5
16:42:52 <Fey> I have a very confusing line here that I keep getting an error on
16:42:53 <Fey> checkBlanks :: [[Maybe Int]] -> Int -> Pos
16:42:53 <Fey> checkBlanks (x:xs) i | rowIndex > -1 = (((floor (i/3))*3) + (floor (rowIndex / 3)), ((mod i 3)*3) + (mod rowIndex 3))
16:42:53 <Fey> 		     | otherwise = checkBlanks xs (i+1)
16:42:53 <Fey> 			where rowIndex = (checkRow x 0)
16:43:44 <ndm> Botje: interact $ readSolveAndShow === interact readSolveAndShow
16:43:51 <ndm> Botje: other than that, looks really good!
16:43:55 <Fey> but I am not getting any fractions as results
16:44:16 <dons> what type is Pos?
16:44:26 <Botje> yay!
16:44:35 <dons> and your 'floor' is going to wipe any decimals, Fey, yes?
16:44:39 <lispy> in haskell is it possible to create a pure function which always returns a bigger number than it did before?
16:44:43 <Botje> one down, just last [0..] steps to go!
16:44:47 <Lajexande1> @pl (((floor (i/3))*3) + (floor (rowIndex / 3)), ((mod i 3)*3) + (mod rowIndex 3))
16:44:48 <lambdabot> (floor (i / 3) * 3 + floor (rowIndex / 3), mod i 3 * 3 + mod rowIndex 3)
16:44:50 <Renkin> ndm, what did you mean I can move the \v as a proper argument?
16:44:53 <dons> lispy, with a unique supply, yeah.
16:44:53 <lispy> i thought using counter = unsafePerformIO $ newIORef 0
16:45:06 <dons> well, you could do that. but you could just use a reader monad
16:45:10 <ndm> Renkin: f x y = \z -> q   ===>   f x y z = q
16:45:16 <lispy> and then having another function read from it, increment the IORef and then return the number...but it's always giving me 0
16:45:16 <Fey> dons: yes
16:45:30 <Fey> dons: all the results will return integers
16:45:43 <Renkin> ndm, oh, but then the return type wouldn't be a function, would it?
16:45:44 <lispy> dons: well, i want a non-monadic value, so does writer really help?
16:45:47 <ndm> lispy: i don't think that works, i have tried it before
16:45:57 <ndm> Renkin: yes it would, remember currying - those two forms are equivalent
16:46:05 <dons> lispy: ok. you're missing a NOINLINE I think
16:46:09 <ndm> Renkin: and thats the big leap that you need to make to solve this problem
16:46:19 <Renkin> I see
16:46:22 <lispy> dons: i've got that for both the counter and the function that modifies the counter
16:46:25 <lispy> i'll paste a code
16:46:27 <lispy> ?where paste
16:46:27 <lambdabot> http://paste.lisp.org/new/haskell
16:46:33 <Renkin> I'll look at that, then
16:46:37 <ndm> lispy: that is truely unsafe, i tried it before, but each thing allocates a new variable - so goes wrong as you said
16:47:44 <lisppaste2> lispy pasted "uniqueLabels?" at http://paste.lisp.org/display/28520
16:48:08 <SamB_XP_> if you used the IORef *as* the label, somehow...
16:48:15 <lispy> ndm: i think you're right, but it's so easy in lisp/scheme that i'd really like something similar here
16:48:40 <SamB_XP> lispy: what you are trying to write is not and never will be a pure function
16:49:46 <lispy> the annoying this is that to use a non-pure label generator i'll have to medify quite a bit of code
16:50:58 <sjanssen> lispy: doing anything else is making a deal with the devil
16:51:13 <lispy> sjanssen: but he...he said we were friends :(
16:51:38 <Renkin> ndm, but in your example  that f x y = \z -> q   ===>   f x y z = q,    z is not already one of the arguments
16:51:46 <Renkin> in my case it is
16:51:50 <lispy> i did notice that when uniqueLabel :: IO String this works
16:52:01 <lispy> so i think count is fine, it's just that uniqueLabel cannot be pure
16:52:03 <ndm> Renkin: free variables are free
16:52:06 <Renkin> in my case : f x y = \y -> q
16:52:10 <Renkin> ah, ok
16:52:15 <ndm> Renkin: extendEnv e v i = (\v -> Just i)   =>   extendEnv e v i = (\anything_you_feel_like -> Just i)
16:52:21 <mauke> rename one of the variables
16:52:43 <lispy> my other option is to manually thread an infinite list of names around in my code generator...
16:52:43 <sjanssen> lispy: yes, count is significantly less sinful
16:52:47 <lispy> i think i'll try that for now
16:52:53 <ndm> lispy: state monad?
16:52:56 <sjanssen> lispy: why don't you go monadic?
16:52:59 <Renkin> mauke: well, I want it to be derived from the argument
16:53:13 <mauke> Renkin: what does that mean?
16:53:17 <ndm> Renkin: you can rename either or both of the v's, and thats fine
16:53:21 <lispy> ndm, sjanssen: i have so much code that i'd have to change to go monadic...but yeah..it's what i should do
16:53:35 <Renkin> ah, you mean they're not related?
16:53:37 <Renkin> or what?
16:53:42 <mauke> yeah
16:53:51 <mauke> each \x introduces a new variable
16:54:00 <sjanssen> lispy: using the State monad shouldn't require more change than explicitly threading around your supply
16:54:03 <Renkin> hmm, ok
16:54:08 <mauke> f x y z = ... is the same as f = \x -> \y -> \z -> ...
16:54:15 <ndm> anyway, i need to sleep - bye bye
16:54:22 <Renkin> ndm: bye
16:54:25 <Renkin> and thanks
16:54:33 <lispy> sjanssen: well, changing to monadic values i have to add returns everywhere, manually threading just changes the parameter list
16:54:40 <ndm> no probs, good luck - once you figure out the trick it will seem obvious :)
16:54:52 <Renkin> mauke: well, what would  f = \x -> \x -> ... be?
16:55:13 <mauke> f _ x = ...
16:55:19 <lispy> and then the question, is...do i want to use ST or state...
16:55:21 <mauke> as you can't use the first x in the ...
16:55:31 <Renkin> ok
16:57:53 <sjanssen> lispy: for something this simple, you want State.  But, if you write your code carefully, it shouldn't take more than a dozen lines of modification to switch between the two
16:58:57 <Fey> Can anyone have a look at http://paste.lisp.org/display/28521 and tell me what I can do to get around the RealFrac error?
16:59:25 <Renkin> is polymorphism in Haskell equal to the use of type variables?
16:59:32 <mauke> use `div` instead of floor /
16:59:33 <Renkin> f :: [a] -> [a]
16:59:36 <Renkin> for example
16:59:49 <dons> hmm, new haskell textbook, or at least some bits of haskell, http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/PDF/plai-2006-01-15.pdf
16:59:53 <lambdabot> http://tinyurl.com/pmcjc
16:59:53 <Fey> mauke: oki, thanks
17:00:03 <Lajexande1> Renkin: what are you making?
17:00:18 <Renkin> this question is unrelated to what I'm making, really =)
17:00:46 <Renkin> I just wanna know if that's the case, that every function that uses type variables are polymorphic, by definition?
17:00:51 <Renkin> because that's my impression
17:02:13 <lispy> if you can parameterize the polymorpism by a parameter...i might call that parameteric polymorphism :)
17:02:51 <lisppaste2> petekaz pasted "help with typeclasses" at http://paste.lisp.org/display/28522
17:03:11 <lispy> yeah, this is quite tedious
17:03:12 <lisppaste2> petekaz annotated #28522 with "error message" at http://paste.lisp.org/display/28522#1
17:03:16 <Renkin> lispy: that didn't answer my question =)
17:03:27 <lispy> my function is recursive, so i have to change a LOT
17:03:44 <lispy> Renkin: what is polymorphism?
17:03:44 <sjanssen> lispy: go monadic!
17:03:57 <Renkin> that's my question ;)
17:04:17 <petekaz> Anyone care to help show me the error of my ways?  I'm trying to define a typeclass (I'm a newbie), but when I compile I get the rigid error message.
17:04:21 <Renkin> no, but it's a general term for functions that accepts arguments of many different types
17:04:28 <lispy> sjanssen: i'm trying...but it means changing my entire code generator :)
17:05:24 <svref> in "a && b", can it happen that b is evaluated before a?  Because I have something akin to length l > 5 && l !! 5...
17:05:34 <lispy> in fact, while i'm here i'm tempted to switch the statement generation to the Writer monad
17:05:40 <Bobstopper> There's some interesting stuff on the ghu list... I often wondered how people from other languages felt about programming languages all being in English...
17:05:53 * Bobstopper advocates converting haskell to lojban :P
17:05:56 <lispy> > False && undefined
17:05:57 <lambdabot>  False
17:06:02 <lispy> > True && undefined
17:06:03 <lambdabot>  Undefined
17:06:14 <lispy> svref: i think you're fine
17:06:27 <Renkin> yeah, that gave me a problem once
17:06:31 <sjanssen> petekaz: you can't have a list like [LaunchAction a => a]
17:06:37 <svref> lispy: but in Scheme, for example, the order of evaluation is implementation-dependant.
17:06:40 * dons advocates converting lojban to haskell
17:06:53 <Renkin> I had an expression like a && b where be generated an error, but when I tested it, I only tested with a == True
17:06:59 <mauke> petekaz: loads in ghci
17:07:05 <Igloo> b is allowed to be evaluated before a, but if a evaluates to False then the expression isn't allowed to be bottom
17:07:06 <Renkin> be=b
17:07:08 <Bobstopper> dons: :)
17:07:25 <petekaz> sjanssen: ok, I'm trying to use a typeclass like a Java interface.  I want a list of some things that are LaunchActions.
17:07:35 <Renkin> oh, || I mean, of course
17:07:42 <sjanssen> petekaz: you'll need a wrapper type
17:07:48 <petekaz> sjanssen: how do I do that?  This list of items should implement the exec method.
17:07:50 <dons> Bobstopper: you know what would be fun, a haskell -> lojban translator
17:08:19 <lispy> oh, might be a neat way to teach lojban
17:08:26 <petekaz> sjanssen: I thought LaunchAction was my wrapper type for OSAction and WebAction.
17:08:44 <Bobstopper> dons: Yeah, I don't imagine that'd be too hard. I'm not sure what purpose it'd serve though :)
17:08:56 <dons> it'd help haskell people pick it up, I think
17:08:56 <Bobstopper> other than... uh... fun as you said
17:09:01 <dons> maybe.
17:09:06 <petekaz> sjanssen: maybe I should not be using a typeclass?  I was trying to avoid making a type with a ton of constructors (one for each action)
17:09:22 <petekaz> I think I have OO on my brain.
17:10:03 <dons> petekaz: oh, there's surgery you can get to remove that
17:10:05 <Bobstopper> dons: perhaps... but the amount of lojban grammer and vocab you'd use to convert a programming language is probably going to be pretty limited and useless for using the language outside describing programming...
17:10:13 * Igloo starts hopefully the final arm build going. Rah!
17:10:25 <dons> its important your doctor has a look at it, anyway, petekaz. you don't want the OO growing
17:10:47 <dons> Igloo++
17:11:56 <petekaz> dons: I wish I could shed it, but I seem to be confused on which part of the type system I should use when designing my programs: types, newtypes, data, typeclasses, etc ... I need to find a basic haskell book.
17:12:03 <sjanssen> petekaz: you have to introduce a wrapper.  Here's a wrapper for any "Show"able type: data Showable = forall a . (Show a) => Showable a
17:12:22 <sjanssen> petekaz: but typeclasses might be the wrong thing here
17:12:34 <sjanssen> how many types of actions will you have?
17:12:53 <lispy> sjanssen: i used that trick and discovered that if you do that, you can't derive any classes for the Showable type
17:13:10 <sjanssen> lispy: yeah, you probably have to write that yourself
17:13:17 <petekaz> Well, I only really have one right now, but I was trying to think about the right way to build this assuming there could be many types of actions that I might not thikn of right now.
17:13:17 <lispy> sjanssen: yeah :(
17:14:14 <dons> petekaz: structures -> data, typeclass -> overloading, types -> aliases for other types, newtypes -> for distinguishing identical types statically, i.e. for use in typeclasses
17:14:31 <dons> you can just stick to data and typeclasses for most cases
17:14:42 * lispy is very glad he has a comprehensive test suite for this code he is refactoring
17:14:56 <petekaz> I'm having a problem designing for the large.  In OO languages, I am always thiking about abstracting out interfaces.
17:15:11 <dons> fair enough. the interfaces you'd lift into type classes
17:15:25 <dons> and state you'd encapulsate in a monad
17:15:57 <dons> monads and typeclasses are the keys to programming in the large in haskell, along with abstract types and laziness (for communicating between components)
17:20:01 <sjanssen> petekaz: what kind of operations do you want to support for an Action?
17:20:22 <petekaz> just one really ... exec
17:20:23 <shapr> dons: Thing is, lojban doesn't have an executable mapping.
17:20:54 <sjanssen> if you just want the exec method, then just use IO Bool
17:21:04 <sjanssen> remember, IO actions are first class!
17:21:26 <petekaz> but doesn't exec need an argument?
17:21:40 <petekaz> like the OSAction or WebAction to execute?
17:21:43 <shapr> dons: I have some notes from years ago that describe mappings of lambda calculus, logo, and a few other simple languages into legal lojban, but those all end up being spoken versions of the original languages.
17:22:01 <lispy> sweet, my program still passes all 652 tests!
17:22:45 <Igloo> Then your testsuite isn't comprehensive enough!
17:22:58 <lispy> heh
17:23:07 <lispy> in this case it should pass them :)
17:23:08 <Igloo> viz rule 1 of programming: There's always at least one more bug
17:24:02 <shapr> dons: It probably makes more sense to make spoken versions of a bunch of simple languages and then get user feedback as to what sucks and what doesn't
17:24:06 <Renkin> oh, here comes one revelation
17:24:40 <shapr> I'm looking for demo code for Control.Concurrent, is that sort of thing on the new wiki?
17:25:11 <lisppaste2> sjanssen annotated #28522 with "like this?" at http://paste.lisp.org/display/28522#2
17:25:13 <dons> yeah, there's some small bits
17:25:28 <dons> shapr: but more would be useful. another place is the testsuite conc/* tests
17:25:39 <dons> there's 40 or 50 threadish programs in there
17:25:46 <shapr> thanks
17:25:49 <dons> (hmm. should stick them up somewhere too...)
17:26:43 <petekaz> sjanssen: I see, so just pass around a IO action as a high-level function.
17:26:48 <dons> shapr: http://darcs.haskell.org/testsuite/tests/ghc-regress/concurrent/should_run/
17:26:50 <lambdabot> Title: Index of /testsuite/tests/ghc-regress/concurrent/should_run, http://tinyurl.com/yfdgf4
17:27:10 <lisppaste2> petekaz annotated #28522 with "how to make a launchable wrapper" at http://paste.lisp.org/display/28522#3
17:27:14 <sjanssen> petekaz: yep.  You'll only be able to support executing the action though
17:27:15 <shapr> Cool, I'll look at those.
17:28:07 <dons> Igloo: hmm, do you think I could take some of the conc tests and put them up on the wiki -- license-wise ?
17:28:16 <petekaz> sjanssen: if I were to have more than one function associated with an action, typecalsses would be the right way to go?  If so, I tried to make a wrappre, but forall is causing the compiler problems.
17:28:16 <dons> as the basis for a quick tut
17:28:56 <dons> you'd use a typeclass if you have the same functoin for more than 1 type.
17:29:07 <sjanssen> petekaz: that's an extension, you'll probably need -fglasgow-exts, or -98 on Hugs
17:29:15 <Igloo> dons: Hmm, in general probably not, as I think the testsuite contains some programs from random people
17:29:37 <Igloo> dons: In this case, they're probably from SimonM (RCS logs will tell you) and/or uncopyrightable
17:29:47 <dons> ok. i'll just use them for inspiration.
17:30:07 <Igloo> dons: Licence for the testsuite stuff is something we should look into, as it would be nice to have it split off into its own package
17:30:14 <dons> yes.
17:30:17 <sjanssen> petekaz: right, if you need to do more things on actions, the cute "type Action = IO Bool" trick won't work
17:30:55 * Igloo hmms. Thanks for making me think about this  :-)
17:30:58 <petekaz> sjanssen: : so a typeclass seems appropriated then, but why does it need an extension, how else is one supposed to do this in standard haskel?
17:31:12 <petekaz> sjanssen: isn't this the point of typeclasses?
17:31:21 <petekaz> or is my syntax just wrong?
17:31:25 <sjanssen> petekaz: probably just a big data type with a bunch of constructors
17:31:48 <petekaz> I was thinking of the case when a plugin might be loaded ...
17:32:00 <petekaz> then one could not modify a big list of constructors.
17:32:03 <sjanssen> petekaz: no, it isn't Haskell '98
17:32:20 <petekaz> I'm just so used to doing things like this in python.
17:32:23 <sjanssen> and this isn't exactly typical typeclass use
17:33:03 <dons> Igloo: at the very mimimum we should state something about what license new contirbutions to the testsuite should come under.
17:33:09 <dons> i.e. BSD as for the libraries
17:33:16 <petekaz> so if I were providing a library, what would be the right way to allow others to make arbitrary actions that implement the correct interface?
17:33:17 <SamB> petekaz: you could let it store a Dynamic or something...
17:33:24 <SamB> oh, no.
17:33:26 <SamB> existential.
17:33:32 <SamB> I guess.
17:34:06 <SamB> or just have them pass in functions...
17:34:14 <SamB> (what sort of action?)
17:35:33 <petekaz> I just have want a list of "actions" (some arbitrary type) that users can specify.  These "actions" should adhere to an interface (in the Java sense), that is, they must implement some set of functions.
17:35:58 <dons> petekaz: a typeclass, I think
17:36:09 <dons> and then use an existential type in the functions that need them
17:36:43 <dons> actually, just polymoprhic, and class-constrained. no existentials required
17:36:47 <petekaz> ok.  is there any good intros to these existential types?  I'm not a math guy.
17:37:06 <SamB> dons: if he wants to pass them around, I think he might want existentials...
17:37:12 <dons> possibly.
17:37:22 <dons> i.e. [forall a . Interface a => a]
17:37:30 <sjanssen> dons: I don't think you can do that
17:37:30 <SamB> petekaz: they basically bundle the typeclass implementations with the data
17:37:42 <dons> sjanssen: you can have lists of existentials, with a wrapper data type
17:37:48 <SamB> dons: you can't *do* that
17:37:56 <dons> data E = forall a . Interface a => a
17:37:58 <dons> [E]
17:38:01 <SamB> that, yes ;-)
17:38:12 <dons> beta reduce. its easy
17:38:19 <SamB> (because that works with a dict-passing implementation)
17:38:20 <dons> ;)
17:38:36 <petekaz> Is there a good doc on how to use the various types of types in haskell including the newer ones supported by ghc?
17:38:55 <sjanssen> petekaz: another option is to make a data type that contains all the "methods" an Action should support
17:39:32 <sjanssen> something like: data Action = Action { exec :: IO Bool, getDescription :: String}
17:40:36 <petekaz> I see.
17:40:47 <dons> petekaz, the wikibook would be one place to start
17:40:52 <dons> anyone have a url?
17:41:00 <dons> ?googe haskell wikibook existential
17:41:02 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
17:41:08 <dons> there we go
17:41:32 <satan> I get on occurs check error for the following line: foldv f a (x:xs) = (f x) `f` (foldv f a xs)
17:41:32 <Renkin> there, solved it :)
17:41:43 <petekaz> thanks.
17:41:53 <Renkin> that Env thing
17:42:54 <sjanssen> satan: you're trying to implement foldr?
17:43:09 <satan> sjanssen: yes, recursively so i can find its fixed point
17:43:21 <mauke> f x `f` looks wrong
17:43:28 <sjanssen> satan: (f x) should just be x
17:43:59 <satan> ah ok
17:44:33 <Renkin> Haskell is quite an awesome thing
17:44:44 <satan> thanks sjanssen :)
17:50:12 <scodil> functional depencies can only declare one type to be dependant on the others, no? you can't do    class (SomeOtherClass a) => NewClass a b c | a -> b c   ?
17:50:38 <sjanssen> scodil: that snippet is valid
17:51:11 <dons> scodil: they're more general, so yeah, you can have multiple types depend on multiple types
17:51:16 <sjanssen> you can have as many type variables on the left or right of the arrow as you want
17:51:37 <dons> see 7.4.7.Â Functional dependencies in the user's guide
17:51:47 <dons> http://www.cse.ogi.edu/~mpj/pubs/fundeps.html
17:51:51 <lambdabot> Title: Redirect: Web resource has moved
17:54:49 <sjanssen> you can even have multiple deps like: class OneToOne x y | x -> y, y -> x
17:56:10 <dons> yeah, you get acces to all of Prolog in effect :)
17:58:07 <mbishop> Is there a utility to time functions in haskell? as in, system time and such
17:58:23 <shapr> Useful zsh snippet: hasktags **/*hs~_darcs
17:58:28 <dons> yep. ... let me find the link ...
17:58:37 <dons> ?hoogle cpuTime
17:58:38 <lambdabot> CPUTime :: module
17:58:38 <lambdabot> CPUTime.cpuTimePrecision :: Integer
17:58:38 <lambdabot> CPUTime.getCPUTime :: IO Integer
17:59:14 <dons> mbishop: http://haskell.org/haskellwiki/Timing_out_computations
17:59:17 <lambdabot> Title: Timing out computations - HaskellWiki, http://tinyurl.com/ybwtnx
17:59:30 <mbishop> dons: thanks
17:59:38 <dons> once you've got getCPUTime and seq, its pretty easy to just time things
17:59:47 <dons> if you want to also time _out_ things, then see above
18:00:02 <sjanssen> shapr: ooh nice, I'll be using that!
18:00:38 <satan> sjanssen: i'm trying to redfine foldl in the same way as i did foldr above, but seem to be stuck
18:00:59 <sjanssen> @fptools Data.List
18:00:59 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:01:02 <dons> shapr: oh, is that to add more projects to a hasktags?
18:01:23 <sjanssen> satan: use the source, Luke!
18:01:44 <dons> ?source Data.List
18:01:45 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:01:47 <satan> sjanssen: eh? :S
18:01:51 <dons> ^^ probably the preferred cmd name
18:05:54 <lispy> so i have a function emitProgram :: Expr -> Writer [String] (), the program is the [String] and i'm in the IO monand and I want to get access to the program (to write it to the file)
18:06:09 <lispy> i tried, do (_, prog) <- listen $ emitProgram p
18:06:22 <lispy> but i get type errors...any ideas what I should be doing?
18:06:41 <lispy>     Couldn't match `IO' against `Writer [String]'
18:06:42 <lispy>       Expected type: IO
18:06:42 <lispy>       Inferred type: Writer [String]
18:07:07 <lispy> it seems like i should need to run the writer
18:07:11 <dons> how are you going to do IO inside writer?
18:07:15 <dons> without WriterT or something?
18:07:23 <lispy> no IO in the writer
18:07:24 <dons> or else returning the final program from your monad, and then dumping it in IO
18:07:44 <lispy> i just use writer to concatenate my program
18:08:17 <lispy> so then i changed it to do (_, prog) <- runWriter $ listen $ emitProgram p
18:08:19 <lispy> and now i get
18:08:24 <lispy>     Couldn't match `IO' against `(,) ((), w)'
18:08:24 <lispy>       Expected type: IO
18:08:24 <lispy>       Inferred type: (,) ((), w)
18:08:25 <sjanssen> @hoogle Writer a b -> (a, b)
18:08:26 <lambdabot> No matches, try a more general search
18:08:32 <lispy> which is equally perplexing to me
18:08:59 <mauke_> if you're in IO, the RHS of each <- must be an IO action
18:09:03 <sjanssen> @hoogle execWriter
18:09:04 <lambdabot> Control.Monad.Writer.execWriter :: Writer w a -> w
18:09:04 <lambdabot> Control.Monad.Writer.execWriterT :: Monad m => WriterT w m a -> m w
18:09:07 <lispy> oh, i need let
18:09:13 <lispy> mauke_: thanks
18:09:14 <dons> yeah, are you truing to run your writer as an action?
18:09:17 <dons> but its pure :)
18:13:09 <shapr> Oh cool, there already is a DNS server written in Haskell!
18:13:24 <shapr> Check out HaServers under http://software.pupeno.com/
18:13:26 <lambdabot> Title: Index of /
18:13:27 <shapr> Pupeno: Nifty code!
18:15:02 * Pupeno is honored to be linked by shapr. :)
18:15:29 <Pupeno> That code is far from finished, but there's a big part of the parser.
18:16:26 <shapr> I found it while looking for examples using Network.Alt.Server.DgramServer
18:21:30 <shapr> Man, there's so much to learn :-)
18:22:27 <shapr> Hm, now I need an FFI tutorial. I think I need to read the next N bytes after a Ptr.
18:24:18 <mauke_> cast to byte ptr and dereference
18:25:14 <sjanssen> @type \ptr n -> mapM (Foreign.Storable.peekElemOff ptr) [0.. n-1]
18:25:15 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> Int -> IO [a]
18:27:43 <dons> Pupeno: nice.
18:37:00 <shapr> sjanssen: thanks!
18:39:41 <Pupeno> dons: thanks.
18:45:44 <frevidar> is there a way to print out things for debuging purposes that is not in the IO Monad (I want to print a few things out to see whats going on deep in my non IO functions)
18:45:54 <kpreid> @hoogle trace
18:45:54 <lambdabot> Debug.Trace.trace :: String -> a -> a
18:45:55 <lambdabot> Debug.Trace :: module
18:45:55 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
18:50:07 <dons> yeah, 'trace' is what you want
18:50:50 <frevidar> is Debug.Trace standard or in ghc?
18:51:14 <SamB_XP> it is portable to all FFI-supporting implementations
18:51:32 <SamB_XP> or even those that only pretend to support FFI ;-P
18:53:54 <dons> frevidar: its standard
18:54:18 <SamB_XP> dons: which standard?
18:54:20 <SamB_XP> haskell'?
18:54:34 <SamB_XP> @docs Debug.Trace
18:54:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
18:54:55 <dons> its in hugs and ghc, that's enough. (and i think probably every other system too has it)
18:54:56 <SamB_XP> @docs Prelude
18:54:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:55:36 <SamB_XP> hmm, has the same "Portability" as Prelude... (namely "portable")
18:56:05 <SamB_XP> however, its "Stability" is listed as "provisional"
18:57:48 <Lajexande1> can someone please tell me a language that is somewhat used that is NOT turing complete?
18:58:02 <SamB_XP> um... regular expressions of various kinds?
18:58:08 <Lajexande1> heh
18:58:25 <Lajexande1> are those even used to compute things?
18:58:35 <dons> sure
18:58:50 <dons> there are some database 'languages' that aren't turing complete
18:58:53 <Lajexande1> i thought all you did was advanced patterna matching...
18:58:56 <dons> but are very widely used
18:59:02 <SamB_XP> that is a kind of computation!
18:59:25 <Lajexande1> dons: know of any example?
18:59:41 <mbishop> So what do most people use to interact with haskell/their editor? Is there a "prefered" editor?
18:59:48 <dons> ?google not turing complete language database
18:59:52 <lambdabot> http://programming.reddit.com/info/lagx/comments
18:59:52 <lambdabot> Title: Why do people say SQL isn&#39;t a programming language? (reddit.com)
18:59:56 <dons> mbishop: vim or emacs.
19:00:10 <dons> there you go, SQL.
19:00:42 <mbishop> dons: OK good, I already use emacs heh, I'm guessing that haskell-mode I downloaded the other day is the best thing for emacs?
19:00:48 <Lajexande1> heh.. lambdabot's da bomb =)
19:01:08 <Lajexande1> dons: is there a simple way to link ghci or hugs to vim?
19:01:12 <Bobstopper> Is English turing complete? :)
19:01:24 <dons> Lajexande1: there are some shell scripts to do this.
19:02:16 <dons> the final version of dcoutts, rl and my paper, Rewriting Haskell Strings, is now available, http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
19:02:19 <lambdabot> Title: Rewriting Haskell Strings, http://tinyurl.com/eobse
19:02:27 <dons> for those who want the low down on stream fusion for fast strings
19:03:47 <kfish> dons: onya!
19:04:23 <dons> cheers kfish
19:06:36 <Lajexande1> there's a link to an article about different languages, and their features on www.osnews.com
19:06:44 * SamB_XP is tempted to mention spears in http://en.wikipedia.org/wiki/Arrows_in_functional_programming
19:06:46 <lambdabot> http://tinyurl.com/we89y
19:07:31 <dons> SamB_XP: oh, you should mention them on the 'Almost haskell' wiki page....
19:07:39 <dons> ?gwiki Almost Haskell
19:07:40 <lambdabot> No Result Found.
19:07:51 <dons> ?google Almost Haskell site:haskell.org
19:07:53 <lambdabot> http://cvs.haskell.org/Hugs/index.html
19:07:53 <lambdabot> Title: Hugs 98
19:07:56 <dons> boo
19:08:30 <SamB_XP> I was going to say something like "Arrows have not yet been generalized to spears, due to [blah blah involving 105 laws]
19:08:42 <dons> heh
19:08:45 <SamB_XP> ?google "almost haskell"
19:08:47 <lambdabot> http://www.cs.mu.oz.au/~bjpop/hatchet.html
19:08:47 <lambdabot> Title: Hatchet, a type Checking and Inference Tool for Haskell 98
19:08:54 <SamB_XP> ?google "almost haskell" site:haskell.org
19:08:55 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/hsc2hs.html
19:08:56 <lambdabot> Title: 10.3. Writing Haskell interfaces to C code: hsc2hs
19:09:08 <dons> ?wiki Almost_Haskell
19:09:09 <lambdabot> http://www.haskell.org/haskellwiki/Almost_Haskell
19:09:28 <dons> probably spears generalise Perfunctors too
19:10:17 <shapr> heh
19:10:58 <SamB_XP> what, no Succ Bottomth Obfusticated Haskell Contest?
19:11:23 * shapr snickers
19:11:25 <dons> that'd be the Pred IOHCC
19:11:39 <shapr> Speaking of which, I should ask Sofia to bring the hard drive with the IOHCC data from Sweden.
19:11:49 <SamB_XP> they've got a Bottomth and a Zeroth and a Succ Zeroth listed on this page
19:11:58 <shapr> Otherwise it'll vanish forever
19:12:09 <dons> yes
19:19:03 * SamB_XP discovers the "renaming" keyword...
19:23:05 <dons> hmm?
19:26:22 <SamB_XP> > do{c<-"/1 AA A A;9+ )11929 )1191A 2C9A ";e.(`divMod`8).(+(-32)).ord$c};e(0,0)="\n";e(m,n)=m?"  "++n?"_/";n?x=do{[1..n];x}
19:26:22 <lambdabot>  Parse error
19:26:37 <mbishop> heh
19:26:51 <SamB_XP> @google site:haskell.org "renaming"
19:26:53 <lambdabot> http://www.haskell.org/pipermail/nhc-bugs/2001-August/000062.html
19:26:53 <lambdabot> Title: [nhc-bugs] Renaming bug?
19:27:42 <kpreid> SamB_XP: isn't that missing a where or let?
19:27:54 <SamB_XP> > do{c<-"/1 AA A A;9+ )11929 )1191A 2C9A ";e.(`divMod`8).(+(-32)).ord$c};e(0,0)="\n";e(m,n)=m?"  "++n?"_/"n?x=do{[1..n];x}
19:27:54 <lambdabot>  Parse error
19:28:03 * SamB_XP isn't sure what it is missing...
19:28:20 <kpreid> I see e(0,0)=... without a preceding where or let
19:28:51 <kpreid> well, I also don't see a definition of (?)
19:28:57 <SamB_XP> > let e(0,0)="\n";e(m,n)=m?"  "++n?"_/"n?x=do{[1..n];x} in do{c<-"/1 AA A A;9+ )11929 )1191A 2C9A ";e.(`divMod`8).(+(-32)).ord$c}
19:28:58 <lambdabot>  Parse error
19:29:04 <SamB_XP> > let e(0,0)="\n";e(m,n)=m?"  "++n?"_/";n?x=do{[1..n];x} in do{c<-"/1 AA A A;9+ )11929 )1191A 2C9A ";e.(`divMod`8).(+(-32)).ord$c}
19:29:05 <lambdabot>  "  _/_/_/_/_/_/_/    _/\n        _/        _/\n        _/\n        _/      _...
19:29:23 <SamB_XP> @. read run let e(0,0)="\n";e(m,n)=m?"  "++n?"_/";n?x=do{[1..n];x} in do{c<-"/1 AA A A;9+ )11929 )1191A 2C9A ";e.(`divMod`8).(+(-32)).ord$c}
19:29:24 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:29:34 <SamB_XP> what does the read module read?
19:29:38 <SamB_XP> @help read
19:29:38 <lambdabot> read "<foo>". Print <foo>
19:29:47 <SamB_XP> @read "\n"
19:29:55 <SamB_XP> @read "\nhi!"
19:29:55 <lambdabot>  hi!
19:29:59 <SamB_XP> @read "hi!\nhi!"
19:29:59 <lambdabot>  hi!hi!
19:30:03 <SamB_XP> oh eek.
19:30:05 <SamB_XP> no good.
19:30:16 <kpreid> @. read run repeat "a"
19:30:17 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:30:23 <kpreid> it failed because run truncated the output, I expect
19:30:30 <SamB_XP> oh...
19:30:42 <dons> ?run repeat "a"
19:30:43 * SamB_XP would have expected some other thing to do that
19:30:43 <lambdabot>  ["a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a"...
19:30:56 <dons> ?run replicate 10 "a"
19:30:57 <lambdabot>  ["a","a","a","a","a","a","a","a","a","a"]
19:30:58 <SamB_XP> @. read run repeat 'a'
19:30:59 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:31:05 <dons> ?. read run replicate 10 "a"
19:31:06 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:31:13 <SamB_XP> @. read run replicate 10 'a'
19:31:14 <lambdabot>  aaaaaaaaaa
19:31:18 <dons> ?read "foo"
19:31:19 <lambdabot>  foo
19:31:51 <kpreid> ?fix show
19:31:51 <lambdabot> Maybe you meant: faq ft id
19:31:55 <kpreid> aw :)
19:33:38 <kpreid> dons: have you thought about allowing @let data T = ...?
19:34:00 <goltrpoat> pulling a blank.. what was that trick to eliminate left recursion in something like expr ::= expr whiteSpace <var | num | (expr)> ?
19:34:13 <dons> kpreid: yeah, thought about it.
19:34:26 <dons> kpreid: problem is that you can make the typechecker diverge if you are tricksy
19:35:04 <dons> and #haskellers tend to be tricksy
19:35:26 <kpreid> well
19:35:59 <kpreid> can't you check if all definitions so far plus the new one cause obvious divergence, then reject it?
19:36:09 <kpreid> oh, hm, fuzzy
19:36:18 <goltrpoat> er.. nevermind, figured it out
19:36:24 <kpreid> well, isn't @undefine sufficient to recover?
19:38:16 <dons> no. how would it be.. once ghc has gone off on its yellow brick divergent road?
19:38:27 <dons> how do I check for divergence .... btw?
19:38:34 <dons> see if the program halts, perhaps? :)
19:38:59 <kpreid> > let f x = f x + 1 in f 0
19:39:00 <lambdabot>  Exception: <<loop>>
19:39:02 * lispy finds that now that he has monadified he's going over board and creating an assembly eDSL
19:39:04 <kpreid> er
19:39:08 <kpreid> > let f x = f (x + 1) in f 0
19:39:09 <lambdabot>  Add a type signature
19:39:10 <dons> ruling out newtypes would be enough, btw.
19:39:16 <kpreid> > let f x = f (x + 1) in f (0::Int)
19:39:16 <lambdabot>  Add a type signature
19:39:17 <dons> i.e. @data ....
19:39:19 <edwardk> lispy: heh, been working on one of those myself
19:39:24 <kpreid> ah never mind
19:39:32 <lispy> edwardk: heh, i remember
19:39:38 <kpreid> I mean, if @run can timeout things, then so can @let, surely
19:39:38 <lispy> edwardk: mine is less ambitious
19:39:41 <edwardk> decided i was taking to long?
19:39:47 <lispy> heh
19:39:48 <dons> kpreid: that's different. i'd have to wrap ghc and time it out
19:39:53 <edwardk> how so?
19:39:56 <dons> rather than just timing out an expression.
19:40:11 <lispy> edwardk: i remember you wanted your so help with register allocation
19:40:14 <dons> ?seen coffeemug
19:40:14 <lambdabot> I saw coffeemug leaving #haskell 1d 21h 53m 50s ago, and .
19:40:17 <lispy> edwardk: all that it still manual in mine :)
19:40:21 <kpreid> oh hm
19:40:23 <edwardk> well, same here
19:40:24 <kpreid> isn't @run a subprocess anyway?
19:40:27 <edwardk> the monad itself doesn't care
19:40:35 <edwardk> its just using add eax [ebx]
19:40:36 <edwardk> type stuff
19:40:51 <lispy> edwardk: ah though i am thinking i need a hof like, withReg that takes some instructions and has them all use one register as the accumulator
19:40:52 <edwardk> but you can do variables that can vary over the different register costructors
19:41:41 <dons> ?tell coffeemug ok, lookupSymbol is no threadsafe, so it shouldn't block all threads on win32, grab a new hs-plugins repo from darcs.
19:41:42 <lambdabot> Consider it noted.
19:41:52 <lispy> edwardk: i'm doing it on an x86_64 machine so no far i only care about the 64 bit regs and the al reg
19:41:57 <edwardk> i'm currently want my register transfer language to be a thin veneer
19:41:59 <edwardk> yeah same here =)
19:42:09 <edwardk> x86-64, no 32 bit code generation
19:42:18 <lispy> nice
19:42:21 <SamB_XP> :-(
19:42:25 <edwardk> though i care about the 32 bit 16 bit, mmx and sse regs
19:42:32 <edwardk> well, mostly the 32 bit and sse
19:42:33 <lispy> i'm doing this because i found a scheme compiler tutorial :)
19:42:36 <edwardk> haha
19:42:40 <edwardk> which one?
19:42:41 <SamB_XP> there are 16 bit regs there?
19:42:45 <edwardk> yeah
19:42:50 <lispy> it was on LtU recently..i'll get the url
19:42:51 <edwardk> you can still o16 any operator
19:43:05 <lispy> http://www.cs.indiana.edu/~aghuloum/
19:43:07 <lambdabot> Title: Abdulaziz Ghuloum
19:43:19 <edwardk> though you can't use 16 bit address offsets for various historical reasons
19:43:45 <SamB_XP> hysterical raisons, you say?
19:43:51 <lispy> i'm about at the point where i can add functions and if but i'm taking a break to do some much needed refactoring
19:43:58 <edwardk> yeah.
19:44:23 <edwardk> i had a usable DSL in very little code, but then i went and started typeclassing it to get it to type check my operand mixture and i broke it
19:44:38 <edwardk> and i haven't made it work since
19:44:46 <lispy> someone mentioned i should use the writer monad (maybe dons?) and so now i'm exploiting it to "emit" all my assembl
19:44:47 <edwardk> coz i got distracted by other parts of the framework
19:45:00 <edwardk> watch out, coz you can't just emit
19:45:10 <lispy> i can't?
19:45:10 <Bobstopper> am I mistaken that haskell modules would be nicer if they were structured in a relational manner rather than a hierarchial manner?
19:45:11 <edwardk> or you'll be screwed when you need to patch up
19:45:30 <lispy> edwardk: what do you mean by patch up?
19:45:31 <SamB_XP> edwardk: maybe he isn't going the code generation himself?
19:45:33 <edwardk> i wind up dealing with code fragments rather than linear code.
19:45:36 <lispy> the tutorial i'm following just say to emit
19:45:36 <SamB_XP> just ASM?
19:45:55 <lispy> ah yeah, i just generate a .s file and call as
19:46:07 <edwardk> well, lets think about how you have to handle jumps, etc. the actual value you are jumping to may be forward in your streaam
19:46:10 <SamB_XP> edwardk is too lazy to do that ;-)
19:46:11 <edwardk> ahhh
19:46:12 <edwardk> ok
19:46:18 <edwardk> i generate actual bytes =)
19:46:22 <lispy> eventually i might change from Write [String] () to something that lets me do pigeon hole optimization but not yet
19:46:28 <lispy> er peephole
19:46:47 <SamB_XP> lispy: pigeonhole theorem, peephole optimization ;-)
19:46:47 <edwardk> primarily coz i don't want to have to invoke another process
19:47:02 <edwardk> and coz i wnt to be able to use it for JITs and things like that
19:47:27 <lispy> edwardk: that might be a fun modification at some point but for now, my rts is written in C and i use as to assemble :)
19:47:40 <edwardk> though, i've started to drift away from the assembler monad, right now i want to get an interpreter working from top to bottom for my toy language and look at bootstrapping the compiler for it in itself
19:48:03 <Adamant> there is an assembler monad?
19:48:06 <edwardk> yeah, i just wanted types all the way down
19:48:06 <Adamant> bad ass!
19:48:11 <lispy> i'm hoping to implement the interpreter via just in time compilation
19:48:15 <edwardk> adamant: i'm still finishing mine, lispy also has one
19:48:24 <goltrpoat> my two hour assembler+vm deal had one as well
19:48:29 <glguy> ?babel de en Die Leute lassen sich wie die Laemmer zur Schlachtbank fuehren -- immer und immer wieder
19:48:31 <lambdabot>  The people let themselves be led like the lambs to the battle bank -- again and again
19:48:35 <goltrpoat> i don't remember if i ever finished it
19:48:42 <Adamant> that is quite invigorating
19:48:46 <jgrimes> what would an assembler monad look like?
19:48:56 <lispy> jgrimes: in my case it's Writer [String] ()
19:48:57 <goltrpoat> state monad, more or less, here
19:49:20 <goltrpoat> state being register map, memory map, data segment bounds, code segment bounds, etc
19:49:27 <jgrimes> my "assembler" monad (I never finished it) was WriterT and State
19:49:32 <edwardk> do $ section ".data"; foo <- dq [1..250]; section ".text"; main <- proc "main"; add eax [foo]; add ebx [foo .+ ebx .* 4]; ...
19:49:40 * SamB_XP uses Writer (String -> String) or something...
19:49:40 <jgrimes> er
19:49:44 <jgrimes> well, the monad was finished
19:49:49 <jgrimes> but I never finished what I was using it for
19:49:50 <SamB_XP> maybe ([String] -> [String])
19:49:55 <edwardk> er do section ..
19:49:58 <SamB_XP> not for ASM though
19:50:27 <edwardk> currently (ab)using mdo to get mutual recursion between procedures
19:50:49 <edwardk> and a special ifcc construct to handle short forward branches
19:51:06 <lispy> edwardk: so did you go with intel syntax for your asm since that's closer to haskell syntax? ;)
19:51:11 <edwardk> yeah =)
19:51:26 <edwardk> and i'm more comfortable with it
19:51:35 <goltrpoat> program = [MOV (REG R0) (IMM 0), {- user input at r0 -}, CALL userInput, {- "OS service", returns length of input in r1 -}, MOV (REG R2) (REG R1), ADD (REG R1) (IMM (-1)), JZ (CLABEL 1), etc]
19:51:37 <goltrpoat> nice and ugly
19:51:38 <SamB_XP> so like MOV EAX [EDX+ECX*2+0xf00]?
19:51:54 <SamB_XP> oh wait, 64 bit
19:52:05 <SamB_XP> so s/\bE/R/ ;-P
19:52:07 <edwardk> in my case mov rax [rdx .+ rcx .* 2 .+ 0xf00]
19:52:18 <lispy> SamB_XP: and on instructions s/l/q/
19:52:34 <jgrimes> I wish I had a 64 bit machine
19:52:37 <jgrimes> =/
19:52:37 <edwardk> using the lowercase terms that return witnesses to certain typeclasses. the uppercase terms are actual values.
19:52:38 <lispy> edwardk: you could make them instances of num :)
19:52:42 <SamB_XP> lispy: I had no l or q
19:52:56 <edwardk> lispy: no i can't otherwise people could actually use illegal address calculations
19:53:08 <lispy> SamB_XP: at  yeah, i'm hoping that type classes will sort taht out of me when/if i get to needing other registers
19:53:11 <SamB_XP> edwardk: huh?
19:53:26 <SamB_XP> I was just making shit up anyway
19:53:39 <SamB_XP> figuring that type-hackery could do wonders and whatnot
19:53:50 <edwardk> this way i can enforce the base + index*{1,2,4,8} + displacement address calculation formula
19:54:02 <edwardk> and i can enforce the silly rules about where you can use an ESP, and EBP, etc.
19:54:03 <SamB_XP> I see not how the . helps!
19:54:25 <edwardk> samb: well, i can't allow an arbitrary calculation in there.
19:54:27 <edwardk> @type (+)
19:54:28 <lambdabot> forall a. (Num a) => a -> a -> a
19:54:45 <SamB_XP> what type does your .+ have?
19:54:46 <edwardk> i need to use a much more complicated MPTC signature that enforces the structure
19:54:47 <SamB_XP> your .*?
19:56:01 <edwardk> forall a. (TAddrAdd a b c) => a -> b -> c
19:56:08 <edwardk> that way i can catch illegal combinations
19:56:44 <edwardk> so if you try to use 3 registers, or need two index registers, or need to use ESP as an index register, etc.
19:57:01 <SamB_XP> hmm
19:57:03 <edwardk> i can catch that at compile time as a type error
19:57:05 <SamB_XP> fair enough
19:57:51 <edwardk> you can always go the hard way and construct an addressing mode term yourself, but then you lose the easy monad sugar
19:58:52 <edwardk> under the hood it gets broken down into stuff like: Arith Add (Reg EAX) (MkAddress (Just EAX) (Just (EBX,2)) 0xf00)
19:59:04 <edwardk> with appropriate patches, etc.
20:00:55 <edwardk> am actually tempted to use + and * and just require the user to import the prelude hiding them, and i can provide a default instance for Num a => TAddrAdd a a a so you can still use it for conventional math
20:01:23 <edwardk> you already have to hide div, and a couple others
20:04:22 <edwardk> oh, random aside: how weird would you find the convention in a haskell-like language that you can mix up the characters we currently allow for operators and identifiers in operators and identifiers, but that the first character of the identifier determines which it acts as. that way _|_ is an identifier, but -o is an operator. (-1) is a number (- 1) is a partially applied infix operator, etc.
20:05:40 <edwardk> it would let you use things like .foo as an infix operator for selecting fields in objects. Name.Value would be valid for module deselection, and a . b could still be function composition.
20:06:54 <Adamant> pretty good. :)
20:06:58 <Adamant> http://www.willamette.edu/~fruehr/haskell/evolution.html
20:07:01 <edwardk> er i mean .foo could act like a method, it can't pretend to be a field, but a .foo () can be the application of the infix operator .foo to arguments a and (), yielding something vaguely like a syntax a c user would be happy with
20:07:04 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
20:08:45 <edwardk> anyways, thoughts? would the mandatory spacing be too terrible? or do you think i'd need a rule to break up name/operator clusters if the larger symbol isn't matched?
20:11:17 <chessguy> hard to tell without some more concrete examples
20:12:04 <edwardk> well, skim through any random chunk of code you have lying around, the stuff that would break would be where you have a.b mashed for function composition or a+b mashed together
20:12:45 <edwardk> otherwise it gives a fairly regular syntax, a bit closer to scheme with respect to what is allowed to be run together in an atom
20:12:50 <chessguy> a.b wouldn't work, but would a . b ?
20:13:02 <edwardk> a . b would give function composition
20:13:14 <ThreeQ> > [1..] >>= \n -> map sum $ transpose $ map ($ [1..n]) $ scanl (.) id $ replicate n init
20:13:15 <lambdabot>  [1,2,2,3,4,3,4,6,6,4,5,8,9,8,5,6,10,12,12,10,6,7,12,15,16,15,12,7,8,14,18,20...
20:13:18 <edwardk> a.b would be the identifier a.b which would be used in my case for hierarchical module name resolution
20:13:50 <edwardk> and (a .b) would be the partial application of the infix operator .b to one operand on its left, named a
20:13:59 <chessguy> so all your tokens are broken up by spaces
20:14:10 <chessguy> err, no
20:14:18 <edwardk> yeah, with the exception of parens, and other bracketing symbols
20:14:31 <chessguy> interesting
20:14:55 <edwardk> i like the wider class of names it gives, and the rule seems nice and orthogonal
20:15:14 <edwardk> and it really opens up the option of those .foo like method syntax hacks
20:15:34 <edwardk> a .method (x,y,z)
20:15:53 <edwardk> if i assume , is privileged like () [] {}, etc.
20:16:03 <SamB_XP> edwardk: I would
20:17:10 <chessguy> i hope you're writing the parser in haskell :)
20:17:18 <edwardk> heh, actually i am
20:18:16 * SamB_XP doesn't get the joke
20:18:33 <edwardk> not sure there was one in there
20:18:37 <Bobstopper> I'm getting "Module imports form a cycle for modules" in ghci. I thought recursive modules were ok in haskell98?
20:19:07 <SamB_XP> Bobstopper: they are
20:19:14 <x3m2> @seen foxy
20:19:14 <lambdabot> I saw foxy leaving #haskell 3d 3h 16m 31s ago, and .
20:19:15 <SamB_XP> but its a common ommition
20:19:34 <SamB_XP> the most common, I'd say...
20:19:57 <Bobstopper> So ghci doesn't support it?
20:20:04 <SamB_XP> nope :-(
20:20:13 <SamB_XP> hugs doesn't either afaik, though
20:20:33 <Bobstopper> ok, fair enough. Thanks
20:20:48 <lispy> Bobstopper: i don't know about ghci but ghc can do it
20:20:48 <SamB_XP> you are welcome
20:20:58 <lispy> Bobstopper: you just have to use those annoying, ugly bootfiles
20:20:59 <SamB_XP> lispy: that does *not* count!
20:21:22 <Bobstopper> lispy: yeah, I noticed the section in the manual..
20:21:25 <SamB_XP> it is ugly and broken!
20:21:33 <lispy> Bobstopper: in the case of ghc you have to give it a base case for the recursive mobules
20:22:06 <lispy> Bobstopper: i find that instead of figuring out what should go in a boot file i just make a 'common' module where i put the shared stuff
20:22:11 <SamB_XP> and you have to annotate imports with {-# BOOT #-}
20:22:28 <Pseudonym> BTW, to answer your question, Bobstopper: Yes, this is a bug.
20:22:33 <Bobstopper> Can anyone explain to me why it's often omitted? Does it require too much bookkeeping in the module loader or something?
20:22:38 <Pseudonym> Or rather an as-yet unimplemented feature.;
20:22:45 <SamB_XP> they are too lazy or something
20:22:52 <Pseudonym> Actually there's a technical limitation.
20:22:57 <SamB_XP> Pseudonym: oh?
20:23:06 <Pseudonym> The problem is that in haskell, you don't have to declare the types of exported things.
20:23:13 <SamB_XP> oh, that.
20:23:15 <Pseudonym> That's a bug in the spec, IMO.
20:23:23 * SamB_XP would like at least a decent warning flag for that
20:23:27 <Pseudonym> So strongly-connected components need to be type checked together.
20:23:39 <SamB_XP> they don't have a -fwarn-missing-export-signatures yet do they?
20:23:43 <edwardk> Pseudonym: yeah but its pretty convenient when you do some heavy type-hackery
20:23:47 <Pseudonym> That is, if A references B and B references A, and neither A nor B have a type declaration, then you need to check them together.
20:24:03 <Pseudonym> Now imagine that A and B are in different modules.
20:24:16 <Pseudonym> Then you need to type check different modules together./
20:24:30 <SamB_XP> yeah, thats what they are "too lazy" to implement
20:24:37 <SamB_XP> I stretch words like that ;-)
20:24:51 <Cale> Personally, I don't think it would be a great loss to just have it require that SCCs were compiled together.
20:24:56 <Pseudonym> I do.
20:24:58 <Bobstopper> Couldn't such checking be delayed until all the information is available to the type-checker?
20:25:00 <Cale> Why?
20:25:02 <Pseudonym> Separate compilation is an important feature.
20:25:13 <lispy> Cale: what is SCC?
20:25:13 <Cale> Then include more typesigs in your modules
20:25:17 <SamB_XP> Cale: how about compiled together *or* have type sigs?
20:25:17 <Pseudonym> It's what makes programmign-in-the-large possible.
20:25:20 <Cale> Strongly connected component
20:25:21 <Pseudonym> Cale: I agree!
20:25:36 <Pseudonym> However, GHC still needs the .hi-boot files even if you do that.
20:25:40 <Cale> If there aren't enough typesigs to compile separately, compile together.
20:25:46 <SamB_XP> which is *LAMELAME*
20:25:50 <Cale> Yeah, I think it should just work.
20:25:57 <SamB_XP> it should be able to parse .hs files for typesigs if available
20:26:07 <sjanssen> could GHC easily compile recursive modules if all exported functions have typesigs?
20:26:08 <lispy> well, it seems like we could at a minimum modify ghc to try to do it and then fail if you have an exported function with no signature?
20:26:14 <SamB_XP> and if not available it should say "neener neener, I need more typesigs!"
20:26:17 <Pseudonym> IMO, if you declare the types of everything that's exported, then the .hi file should just be generated from the .hs without needing anythign else.
20:26:25 <Cale> yeah
20:26:55 <Cale> SamB_XP: Or just compile the modules nonseparately
20:27:03 <Cale> and print a warning that it's doing so
20:27:05 <Pseudonym> That's the hard bit.
20:27:05 <SamB_XP> Cale: what, GHC?
20:27:14 <SamB_XP> you crazy?
20:27:19 <Pseudonym> Implementing the compilation of multiple modules together.
20:27:42 <lispy> right, and what if the module was long since compiled?  like something in a -package?
20:27:51 <SamB_XP> IMO, GHC should at least have a warnings flag to warn if you don't declare all export types
20:28:02 <SamB_XP> because haddock doesn't like that either :-(
20:28:03 <Pseudonym> Actually, the Haskell "way" would be to do it lazily.
20:28:13 <Cale> Well, how hard is it? Up to namespaces/hiding, isn't it just supposed to be equivalent to having all the definitions in the same file?
20:28:23 <Pseudonym> It's only a warning/error if you try to use something that you exported but didn't slap a type on.
20:28:26 <lispy> SamB_XP: it has something very similar, it can warn for all top level declarations that are missing signatures
20:28:36 <Pseudonym> Cale: It could make compilation intractable.
20:28:42 <Cale> Pseudonym: how?
20:28:55 <SamB_XP> lispy: that is very very different in a module that only exports 5 things but has top-level 50 definitions
20:28:56 <Pseudonym> In general, it could require the entire program in memory.
20:29:01 <Cale> You can't have cycles with libraries.
20:29:08 <SamB_XP> Cale: quite true
20:29:19 <SamB_XP> but, programs are allowed to be big!
20:29:26 <Cale> So it would just be the probably relatively small SCCs of your program.
20:30:25 <Botty> ?type foldl
20:30:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:30:47 <Cale> Usually the SCCs that one would want are only 2 or so modules, since usually they're the result of splitting a larger module into logical components.
20:30:50 * SamB_XP straggles off to bed
20:30:55 <Pseudonym> It's the "probably" and "usually" that concerns me here.
20:31:08 * SamB_XP agrees with Pseudonym
20:31:20 <Pseudonym> But seriously, we're all agreed on one point at least.
20:31:20 <Cale> Well, it would be printing a warning saying how to make compilation separate :)
20:31:29 <SamB_XP> I think the {-# SOURCE #-} things are okayish...
20:31:41 <Pseudonym> Which is that if you declare types of exported objects, you shouldn't need .hi-boot files.
20:31:42 <SamB_XP> but not the boot files...
20:31:45 <Cale> and so if it was taking too long, or too much memory, you'd just add some typesigs.
20:31:47 <lispy> ghc already uses amazing amounts of memory to compile large modules
20:31:50 <SamB_XP> aren't they hs-boot files now?
20:31:54 <Pseudonym> Whatever.
20:32:05 <Pseudonym> I don't care what they're called, they're awful.
20:32:06 <SamB_XP> yeah, whatever...
20:32:11 <SamB_XP> yeah, they are...
20:32:24 <SamB_XP> they don't even support all the features you might need...
20:32:24 <Cale> and it doesn't have to actually proceed all the way through compilation with the modules together
20:32:29 <Cale> just typechecking, no?
20:32:34 <Botty> ?type .
20:32:35 <lambdabot> parse error on input `.'
20:32:36 <Pseudonym> But actually, this is part of a larger problem.
20:32:41 <lispy> ?type (.)
20:32:42 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
20:32:48 <SamB_XP> or didn't, last I checked...
20:32:51 <Botty> ?type ($)
20:32:52 <lambdabot> forall b a. (a -> b) -> a -> b
20:32:52 <Pseudonym> Which is that Haskell's module system is under-powered.;
20:33:00 <SamB_XP> hmm?
20:33:07 <SamB_XP> at least it *has* one
20:33:12 <Pseudonym> Yes, that's true.
20:33:18 <SamB_XP> unlike, say, Lisp.
20:33:20 <Pseudonym> As a first draft, it's not bad.
20:33:21 * Bobstopper thinks that maybe restricting modules from being recursive is not the solution but an optional compile speed optimisation on the part of the user
20:33:27 <lispy> sometimes i wonder why haskell has a module system instead of something just plain better...like an object system
20:33:45 <SamB_XP> (it doesn't count as a module system if you can accidentally overwrite parts of imported symbols)
20:33:54 <Cale> Personally, I don't think the user should be outright prevented from compiling a program just because it would take longer to compile.
20:34:40 <Pseudonym> No, but the programmer should be able to control how much compile-time parallelism they can get from within the language.
20:34:45 <Cale> yeah
20:34:49 <SamB_XP> Bobstopper: no, its not the solution...
20:35:03 <Cale> and I'm saying, give them that by using added type signatures
20:35:05 <SamB_XP> its just a stopgap...
20:35:12 <Pseudonym> And the fact is, putting type declarations on exported symbols is good engineering practice which should be encouraged.
20:35:18 <SamB_XP> yes!
20:35:22 <Pseudonym> Getting faster compiles in return for that is win-win!
20:35:33 <SamB_XP> also better haddocks!
20:35:35 <Cale> Sometimes it's unwieldy
20:35:52 <Pseudonym> Example?
20:36:01 <Pseudonym> I do have one example, BTW, but I'd like to hear yours.
20:36:02 <SamB_XP> he mentioned type-hackery
20:36:14 * SamB_XP really straggles off to bed this time
20:36:19 <Pseudonym> Night.
20:36:19 <Cale> When the types get to be as long as the definitions of the functions :)
20:36:25 <SamB_XP> heh
20:36:28 <lispy> oh hm...now i need to combine writer with state
20:36:29 <Pseudonym> Example?
20:36:39 <Cale> Ask palomer :)
20:36:41 * lispy goes back to nomaware for reference
20:36:43 <Pseudonym> My example, by the way, has a solution.
20:37:00 <Pseudonym> One example that I have is types that are generated programatically, via type-level computation.
20:37:01 <lispy> oh, some of the types in OOHaskell are larger than the functions
20:37:10 <Pseudonym> class ComputeAType a b | a -> b
20:37:11 <Cale> lispy: indeed
20:37:15 <lispy> er, most of the t ypes in oohaskell
20:37:30 <Pseudonym> OK, the types in OOHaskell are in serious need of type synonyms.
20:37:48 <lispy> Pseudonym: right, and they even have a mechanism for it
20:37:52 <Pseudonym> In the case of computed types, I want to be able to write this:
20:37:55 <lispy> nominal types
20:38:01 <Pseudonym> foo :: (ComputeAType Integer b) => b
20:38:13 * lispy still never got HList to work as a library
20:38:13 <Pseudonym> That uniquely defines a type, b.
20:38:31 <lispy> i actually wonder if using HList in a library some how changes the type checker's behavior
20:38:38 <Pseudonym> Because of the fundep.
20:38:51 <Bobstopper> just to verify: am I hearing the argument right? recursive modules are potentially a bad thing in the case where modules are written without adequate type declarations. In such a case compilation may be slow. It sounds to me like a user level optimisation rather than something which should be omitted altogether?
20:39:03 <Cale> also, there are some types where you don't want to think about what the type actually is, even with synonyms (OOHaskell provides lots of these)
20:39:16 <Cale> Bobstopper: that's my position
20:39:23 <Pseudonym> Bobstopper, the problem is that GHC requries boot files even if you do the right thing and declare your types.
20:39:28 <Cale> It seems like something which the compiler should do as well as it can
20:39:42 <Pseudonym> That's my main complaint.
20:39:47 <sjanssen> Bobstopper: I don't think speed is the reason that GHC doesn't implement recursive modules.  I'd bet on lack of time and interest
20:39:49 <satan> hello, can someone tell me how this pattern matching works, haven't seen its likes before: limit (a:bs@(b:cs)) = if a - b == 0 then a else limit bs
20:40:05 <Pseudonym> satan: That's an at-pattern.
20:40:07 <lispy> satan: the @ is confusing?
20:40:09 <satan> yes
20:40:14 <Cale> Pseudonym: couldn't the relevant boot files be constructed automatically by simultaneous typechecking?
20:40:18 <satan> the limit (a:bs@(b:cs)) bit
20:40:19 <Pseudonym> > let xs@(x':xs') = [1,2,3] in (xs, x', xs')
20:40:20 <lambdabot>  ([1,2,3],1,[2,3])
20:40:32 <lispy> satan: it gives the pattern a name, the name is on the lhs of the at and the pattern is on the rhs
20:40:40 <Pseudonym> Cale: Yes, but then there's a bootstrapping problem.
20:40:59 <Pseudonym> If you're going to the trouble of typechecking a module, then you're doing half the compilation anyway.
20:41:16 <Pseudonym> And you need the types of imported objects that the module uses.
20:41:17 <Cale> so, don't throw away the types you got.
20:41:22 <lispy> do i want a WriterT or a StateT?
20:41:28 <satan> lispy: i see, so its just so you can reference them later, like how it does if a - b == 0
20:41:32 <lispy> (how do i decide?)
20:41:33 <Cale> lispy: what are you doing?
20:41:39 <satan> i thought that'd be possible with regular pattern matching too though
20:41:48 <Cale> lispy: Writer is for things like logging
20:42:04 <lispy> Cale: well, i currently use the writer monad to collect up my assembly instructions, now i want to add state so that i can generate unique label for jumsps
20:42:29 <Cale> lispy: look at my UniqueT/SupplyT :)
20:42:31 <Pseudonym> Cale: It'd be enough to be able to generate the relevant boot files after syntax analysis and a small amount of sanity checking alone, if you can.
20:42:53 <Cale> http://haskell.org/haskellwiki/NewMonads/MonadSupply
20:42:56 <lambdabot> Title: New monads/MonadSupply - HaskellWiki, http://tinyurl.com/yyxq6u
20:43:00 <Cale> http://haskell.org/haskellwiki/NewMonads/MonadUnique
20:43:03 <lispy> satan: i usually see it like this foo ys@(x:xs) = ... because now if you need the whole list it's better to say ys than (x:xs)
20:43:04 <lambdabot> Title: New monads/MonadUnique - HaskellWiki, http://tinyurl.com/yf5l9d
20:43:10 <Cale> (they're incredibly similar)
20:43:23 <satan> lispy: ohh ok, thanks
20:43:27 <Pseudonym> If you've declared your types, then you should just be able to textually export them into boot files, possibly after a little desugaring.
20:43:43 <Cale> lispy: what you should do is compose the monads you want, and then newtype the result, deriving all the instances you want
20:43:54 <Pseudonym> Like f, g :: Foo   ->  f :: Foo; g :: Foo
20:44:17 <lispy> Cale: well, do i want a WriterT or a StateT? i guess that was my question...
20:44:20 <ThreeQ> ?check \n -> (let xs = [1..n] in zipWith (*) xs $ reverse xs) == (map sum $ transpose $ map ($ [1..n]) $ scanl (.) id $ replicate n init)
20:44:21 <edwardk> heh, neat, with that funny . syntax you can actually get code that looks like: new Foo(arguments).toString()     not sure thats a glowing recommendation to a haskeller though ;)
20:44:24 <lambdabot>  OK, passed 500 tests.
20:44:39 <Cale> lispy: It sounds like you want a UniqueT Writer
20:44:48 <Pseudonym> Anyway, lunch time.
20:44:53 <Pseudonym> Enough arguing. :-)
20:45:09 <Cale> Pseudonym: well, it should use the typesignatures you provide of course
20:45:28 <Cale> Pseudonym: I just think it should struggle against adversity rather than giving up :)
20:45:57 <Pseudonym> I see where you're coming from, and for scripty-type applications, I do admit that it's very convenient.
20:46:00 <lispy> Cale: but UniqueT won't help me manage the Writer I have now, will it?
20:46:09 <Pseudonym> But for large applications, you should be rewarded for good discipline.
20:46:16 <Cale> lispy: You want both features, no?
20:46:17 <Pseudonym> At least.
20:46:22 <Cale> Pseudonym: right
20:46:24 <Pseudonym> Anyway, really lunch now.
20:46:36 <lispy> Cale: ya, iwant to keep logging the way i do and i want to also have access to a counter
20:46:41 <Cale> So I'm saying, use all the data you can to be efficient, and when you can't, then try harder :)
20:47:28 <Cale> lispy: right, so what you do is build a new larger monad which uses UniqueT over the Writer monad you're currently using
20:47:30 <edwardk> cale: then do some sort of CounterT that can wrap your Writer
20:47:36 <Cale> edwardk: right
20:47:42 <Cale> http://haskell.org/haskellwiki/NewMonads/MonadUnique
20:47:43 <edwardk> then to use the Writer you 'lift'
20:47:43 <lispy> Cale: oh, okay
20:47:45 <lambdabot> Title: New monads/MonadUnique - HaskellWiki, http://tinyurl.com/yf5l9d
20:47:45 <Cale> like that one
20:47:53 <Cale> but you don't just lift :)
20:47:59 <edwardk> or you make your instance of MonadWriter
20:48:06 <Cale> You newtype, and then write/derive the instances
20:48:07 <lispy> Cale: so right now I use Writer [String] () and so this becomes UniqueT (Writer [String]) () ?
20:48:08 <edwardk> er your class an instance of
20:48:09 <edwardk> yeah
20:48:32 <Cale> lispy: exactly, though that's a mess, so give it a name
20:48:46 <edwardk> you don't need to newtype you can just add an instance so that instance MonadWriter m => instance Monadwriter (UniqueT m)
20:49:21 <Cale> newtype CodeGen a = UniqueT (Writer [String]) a deriving (Functor, Monad, MonadUnique)
20:49:25 <lispy> Cale: now let's say (humor me here because I'm trying to understand this) that I didn't want to  use UniqueT
20:49:43 <Cale> okay
20:49:48 <Cale> then you'd probably use StateT
20:49:48 <edwardk> lispy: then use StateT
20:49:50 <lispy> Cale: and instead i wanted to directly add state, would i use StateT (Writer [String]) ()?
20:49:54 <Cale> yeah
20:50:28 <edwardk> type M a = StateT MyState (Writer [String] a)
20:50:30 <Cale> instance MonadWriter [String] CodeGen where
20:50:31 <edwardk> or something like that
20:50:55 <Cale>    tell x = lift (tell x)
20:51:05 <Cale> er
20:51:11 <lispy> what is CodeGen?
20:51:13 <Cale> newtype CodeGen a = CodeGen (UniqueT (Writer [String]) a) deriving (Functor, Monad, MonadUnique)
20:51:29 <edwardk> he was givig a name to your monad, like the M i gave it above
20:51:45 <edwardk> he likes newtype, i'm more of a type guy =)
20:51:45 <Cale> actually, it may be easier to write the other way around :)
20:51:57 <Cale> newtype is far cleaner
20:52:09 <Cale> because you don't end up writing explicit lifts all over
20:52:09 <lispy> thanks for the help
20:52:42 <lispy> i think i'll download this monad unique and give it a shot
20:52:45 <Cale> newtype CodeGen a = CodeGen (WriterT [String] Unique a) deriving (Functor, Monad, MonadUnique, MonadWriter)
20:52:49 <edwardk> well, i was just thinking you'd write instances for the MonadWriter for StateT wrapping a monadwriter
20:52:49 <Cale> I think
20:52:51 <edwardk> hrmm
20:53:03 <edwardk> can newtype derive MonadWriter?
20:53:15 <edwardk> didn't know deriving was so smart
20:53:16 <Cale> er
20:53:24 <Cale> newtype CodeGen a = CodeGen (WriterT [String] Unique a) deriving (Functor, Monad, MonadWriter [String])
20:53:26 <Cale> rather
20:53:32 <edwardk> i always did it the hard way
20:53:34 <Cale> you have to provide the parameter
20:53:34 <lispy> edwardk: it's newtype deriving, based on a ghc extension
20:53:35 <scodil> if i've got some IO function that takes lots of parameters, like a -> b -> c -> d -> IO()  , and another io action, call it x, how do i create a new io function, a->b->c->d->IO(), that is just the old one with x stuck on the end? is this something really obvious that I'm missing? As it stands i have to do  \a b c d -> (do theThing; thenTheother) Is there a general way to do this for any number of arguments a b c d...?
20:53:35 <scodil> oops i wrote that wrong
20:53:35 <scodil> \a b c d -> do theThing a b c d ...
20:53:39 <edwardk> if that works, then i'm a convert ;)
20:53:45 <Cale> newtype can derive anything implemented on the base type
20:53:59 <Cale> (with a commonly implemented extension)
20:54:24 <Cale> scodil: >>
20:54:27 <edwardk> well, i know it can derive the properties already associated witht he outermost wrapped thing
20:54:43 <Cale> x >> y is the action which performs x, throws away the result and then performs y
20:54:47 <edwardk> oh
20:54:56 <edwardk> i see, you are WriterT'ing your Unique monad
20:54:59 <edwardk> not the other way around
20:54:59 <edwardk> ok
20:55:08 <edwardk> i have no issues with what its doing then =)
20:55:11 <Cale> yeah, that's easier, because Writer's a pain to lift
20:55:15 <edwardk> *nods*
20:55:37 <Cale> yeah, I sort of changed my mind there
20:55:51 <lispy> okay so now i have your CodeGen monad
20:56:03 <Cale> make sure you have the latest one :)
20:56:03 <lispy> CodeGen (WriterT [String] Unique a)
20:56:07 <Cale> yes
20:56:18 <Cale> deriving (Functor, Monad, MonadWriter [String])
20:56:25 <Cale> and then
20:56:33 <lispy> so now where I have Expr -> Writer [String] (), i convert to Expr -> CodeGen () ?
20:56:36 <Cale> instance MonadUnique CodeGen
20:56:39 <Cale>  where
20:56:46 <Cale>    fresh = lift fresh
20:57:11 <Cale> yeah
20:57:13 <Cale> that's the idea
20:57:18 <Cale> and everything will work as usual
20:57:25 <Cale> except you have a new action fresh
20:57:30 <lispy> we have a type error on that lift
20:57:34 <Cale> mm
20:57:41 <lispy> instance MonadUnique CodeGen where
20:57:41 <lispy>   fresh = lift fresh
20:57:48 <lispy>     Couldn't match `CodeGen' against `t m'
20:57:49 <lispy>       Expected type: CodeGen Integer
20:57:49 <lispy>       Inferred type: t m a
20:57:54 <Cale> oh
20:58:16 <lispy> why does it expect an integer?
20:58:30 <edwardk> =P on your newtype
20:58:40 <Cale> er, hang on a sec :)
20:58:46 * lispy is lost :)
20:58:46 <edwardk> hehehe
20:58:52 <edwardk> one sec lispy
20:59:16 <Cale> (I'm going to actually do this)
20:59:21 <lispy> thanks for the help, i'm just in over my head :)
20:59:23 <Cale> rather than guessing
21:00:00 <Cale> oh, hehe
21:01:06 <Cale> fresh = CodeGen $ lift fresh
21:01:12 <Cale> forgot the type tag
21:01:24 <lispy> ah yeah that work
21:01:26 <lispy> s
21:01:30 <Cale> now we just need one more think
21:01:32 <Cale> thing*
21:01:46 <lispy> and now i added type Instruction = String as no it looks more like a Code generator :)
21:02:11 <araujo> hello
21:02:16 <lispy> WriterT [Instruction] looks better than WriterT [String]
21:02:28 <Cale> runCodeGen (CodeGen x) = evalUnique (runWriterT x)
21:02:55 <lispy> Cale: now if we do that will we get back the a or the [Instruction] ?
21:03:01 <lispy> Cale: because the a is meaningless
21:03:02 <Cale> that's a direct replacement for runWriter
21:03:07 <Cale> both
21:03:10 <Cale> oh, okay
21:03:33 <Cale> execCodeGen (CodeGen x) = evalUnique (execWriterT x)
21:03:55 <lispy> ah cool
21:03:59 <Cale> btw, give your new monad its own module
21:04:02 <lispy> runCodeGen :: forall a. CodeGen a -> [Instruction]
21:04:05 <lispy> right
21:04:23 <Cale> and it's good practise not to export the CodeGen dataconstructor
21:04:41 <lispy> okay, but export everything else?
21:04:45 <Cale> yeah
21:06:34 <dibblego> is Backus1977 the birth of FP?
21:06:39 <Cale> Even though it's unlikely you might also want to include evalCodeGen, defined analogously to the others
21:07:02 <Cale> (just for completeness)
21:07:04 <lispy> Cale: how is that different?
21:07:14 <Cale> exec returns just the written output
21:07:20 <Cale> eval returns just the result
21:07:24 <Cale> run returns both
21:07:45 <Cale> runCodeGen (CodeGen x) = evalUnique (runWriterT x)
21:07:45 <Cale> execCodeGen (CodeGen x) = evalUnique (execWriterT x)
21:07:45 <Cale> evalCodeGen (CodeGen x) = evalUnique (evalWriterT x)
21:07:55 <satan> hmm how would i prove that xs ++ ys = xs, where xs is an infinite list? by induction?
21:07:58 <lispy> Oh
21:08:01 <lispy> Cale: cool
21:08:13 <Cale> satan: roughly, yes.
21:08:34 <Cale> satan: if you do it in the "obvious" way, then what you'll really be doing is coinduction
21:08:40 <satan> Cale: ok, and i guess my variable would be ys?
21:08:48 <satan> oh, what's coinduction?
21:09:23 <Cale> Well, I haven't actually seen a proper formal treatment, but it's induction on the structure of types.
21:09:38 <satan> alright
21:09:46 <eshrgrgfewgfe> i suppose most people here you think that functional paradigm is a better approach to software developement than imperative or oop one? is it true?
21:09:48 <lispy> ?hoogle execWriterT
21:09:48 <lambdabot> Control.Monad.Writer.execWriterT :: Monad m => WriterT w m a -> m w
21:09:51 <Cale> So you prove that it is true for [] and for (x:xs) given that it's true for xs
21:09:59 <Pegazus> What do you think Cale?
21:10:14 <satan> ok i'll try it, thanks Cale :)
21:10:22 <Cale> Pegazus: OOP and functional programming are orthogonal to some extent
21:10:31 <lispy> i import Control.Monad.Writer but it doesn't see execWriterT that's odd
21:10:33 <Cale> Pegazus: there are OO functional languages, for instance
21:10:34 <Pegazus> orthogonal means the same or very different?
21:10:39 <Cale> unrelated
21:10:42 <Pegazus> k
21:10:44 <lispy> oh, sorry, evalWriterT
21:10:47 <lispy> ?hoogle evalWriterT
21:10:47 <lambdabot> No matches found
21:10:55 <Pegazus> mmmm i don't know :) wich one for example?
21:10:56 <Cale> lispy: You want exec
21:11:20 <lispy> Cale: i'm going off the ones you mentoined for completeness
21:11:25 <lispy> Cale: but i don't see an evalWriterT
21:11:34 <lispy> Cale: just run and exec
21:11:35 <Pegazus> what's the best approach for software engineering from your point of view?
21:11:49 <Cale> lispy: oh, that's odd
21:11:58 <lispy> ?hoogle evalWriterT
21:11:58 <lambdabot> No matches found
21:12:00 <Cale> lispy: but okay, I guess you don't provide that then
21:12:04 <lispy> :)
21:12:41 <Cale> Pegazus: OO does tend to use lots of state, often unnecessary state
21:13:19 <Cale> Pegazus: Working with mutable state makes programs harder to reason about.
21:13:52 <Cale> That's not only important when you're trying to prove things, it's also important for your own head when you're writing them.
21:14:07 <dons> and when trying to scale your code for multiple cores
21:14:11 <Cale> State introduces lots of potential for bugs.
21:14:16 <Cale> indeed
21:14:32 <Cale> So there are practical issues there now that processors are becoming more parallel
21:15:00 <dons> practical in terms of performance, not just more "abstract" concerns like bugs and reasoning
21:15:06 <Cale> But I do think that there is a place for OO and maintenance of state, and it's a powerful abstraction when used correctly, it's just quite often overkill.
21:15:09 <dons> whether your code will use all 80 cores will soon be a real issue
21:15:34 <Pegazus> lots of state, often unnecessary state --> what do you mean by this?
21:15:46 <dons> i.e. pugs now runs faster than perl5, once you've got 16 cores ..
21:15:46 <Cale> There's a really nice example of the use of state as an abstraction in the SICP lectures, and I recommend watching them :)
21:16:08 <Cale> Pegazus: okay, you know how when you write imperative or OO programs, you use lots of assignment statements
21:16:19 <Pegazus> yes
21:16:25 <Cale> Every variable that you can potentially assign to is a piece of state.
21:16:30 <Pegazus> yes
21:16:38 <dons> even though pugs is written in Haskell, and perl5 is what, C? purely due to the ease in which perl6 based on stateless haskell can be parallelised
21:16:44 <Cale> Sometimes, you can avoid the use of those variables
21:16:53 <Cale> but OO programming doesn't tend to encourage that
21:16:57 <Pegazus> what do you mean by avoid the use of those variables?
21:16:59 <lispy> Cale: so i wanted to go ahead and my code gen new type pretty general, so i wanted emit s = tell [s], which is forcing CodeGen (), any idea how i get it to be CodeGen a?
21:17:13 <Cale> well, how do you apply a function to every element of a list in C?
21:17:26 <Pegazus> just f(g(h(x))) in place of a = h(x); b = g(a); c = f(b) ?
21:17:45 <Cale> You go along it incrementing some pointer, or updating a pointer with a next pointer and applying the transformation.
21:17:46 <Pegazus> C is imperative, or structutred...
21:17:56 <Cale> C is imperative
21:17:57 <araujo> imperative
21:17:58 <Cale> So is Java
21:17:59 <lispy> oh, tell just has that type...never mind
21:18:09 <Pegazus> well, but we are talking about OOP :)
21:18:22 <Cale> okay, so how do you do it in Java?
21:18:30 <Pegazus> what do you mean apply
21:18:33 <Cale> supposing that nobody's written it for you
21:18:33 <Pegazus> map? foldr?
21:18:35 <Cale> I mean map
21:18:45 <Pegazus> i can tell you in c++ and in smalltalk :)
21:18:49 <Cale> map is the way to remove the state
21:18:59 <Pegazus> to remove? the state?
21:19:20 <Pegazus> i think it's just a more declarative way of telling what you are doing...
21:19:21 <Cale> Well, in an imperative language, map turns into a loop, with a counter variable of some sort.
21:19:31 <Pegazus> that's not really true..
21:19:35 <Cale> (not necessarily)
21:19:41 <lispy> Pegazus: have you read the paper google wrote about mapReduce? that seems like a highly relevant paper for this dicussion
21:19:41 <Cale> but people often program like this
21:19:53 <Pegazus> c++: std::transform(v.begin(), v.end(), o.begin(), TheFunction);
21:20:17 <Cale> Pegazus: so how do you write transform?
21:20:30 <Pegazus> transform is already written
21:20:33 <Cale> Is it recursive?
21:20:33 <Pegazus> so how do you write map?
21:20:37 <Cale> map f [] = []
21:20:39 <Pegazus> i don't know :)
21:20:44 <Cale> map f (x:xs) = f x : map f xs
21:20:45 <Pegazus> it works!
21:20:50 <Pegazus> i don't care how it works...
21:20:59 <Pegazus> smalltalk: thething collect: [:x | your function with x]
21:21:00 <Cale> Well, my point is at that level
21:21:01 <edwardk> pegazus:  objects in c++/java usually have some sort of fields associated with them and you tend to manipulate them by calling methods on the object that modify those fields, that state in some way, in haskell you generally avoid mutable state, its like working with an entire hierarchy of objects that all have everything declared const, and you use more methods that transform one thing into another.
21:21:17 <Pegazus> programming always at that level, is an error, as it is an error to use recursion always in haskell
21:21:26 <dons> sometimes I wonder if Pegazus is just trolling. the huge design debates he's been causing for the last year or so hmm..
21:21:27 <goltrpoat> transform is something like while (it1 != it2) { func(*it1); ++it1; }
21:21:28 <Pegazus> you have map, you have transform, you have collect and you have libraries...
21:21:31 <Cale> But yeah, there's also OO state in that objects are essentially big clumps of state
21:21:44 <goltrpoat> er.  (ot++) = func(*it1) or whatever.
21:21:56 <Cale> goltrpoat: right
21:22:00 <Pegazus> dons: i'm trying to learn :)
21:22:04 <goltrpoat> map is just transform with v.begin passed as the output iterator
21:22:05 <dons> in a year you could be so competent at haskell, you'd solve your own problems though..
21:22:17 <Pegazus> i'm planning to...
21:22:23 <dons> so what's been happening, that a year later you're still asking beginner questions? :)
21:22:25 <Pegazus> if you could advise me some good books for haskell...
21:22:26 <araujo> Pegazus, you a smalltalker?
21:22:29 <ThreeQ> Pegazus: even though you can do functional-style things in OOP languages, a lot of the advantages don't become apparent until you enforce that style across the whole program
21:22:36 <Cale> Yet Another Haskell Tutorial
21:22:45 <dons> Pegazus: you know where to find them, surely, after a year.... haskell.org
21:22:50 <Pegazus> <araujo> Pegazus, you a smalltalker? ---> i'm one that things that all languages has very good things, and the best is to mix them all...
21:22:50 <Cale> also, watch the SICP lectures, even though they're about scheme
21:23:01 <Pegazus> i like a lot of things about haskell, smalltalk, c++, prolog and others
21:23:11 <araujo> Pegazus, mix them all? ... mmm that was not my question
21:23:12 <Pegazus> i'm trying to figure out, wich is the perfect balance
21:23:25 <araujo> Pegazus, In any case, if you are a smalltalker , you will love Haskell
21:23:27 <Pegazus> i think that all of them has lot's and great flaws...
21:23:33 <Cale> Pegazus: and don't worry, Haskell gives you ways to work with state too, they're just more controlled
21:23:41 <Pegazus> i know some haskell :)
21:23:44 <Cale> Pegazus: here's a point...
21:23:52 <Pegazus> but i ask you because you have a big experience with it, and i don't
21:23:59 <Pegazus> so it's interesting to know what you think...
21:24:00 <dons> Pegazus: try learning the languages, rather than starting big debates on irc. the answers are clear if you actually learn the language first
21:24:05 <lispy> Pegazus: several people have learned haskell have felt like all programming languages suck, just haskell sucks least
21:24:07 <dons> since you'll understand the arguments in detail
21:24:16 <Pegazus> i'm learning haskell!
21:24:26 <Pegazus> and at meantime i ask this questions :)
21:24:48 <Cale> Suppose I have a function call  y = f(x) in an OO language. Suppose also that you know x, and you know the return value r which f is going to produce when applied to x. Is it safe to replace this line with y = r ?
21:24:55 <dons> broad questions like "what's the best approach for software engineering" aren't really very useful
21:25:13 <Cale> Pegazus: ?
21:25:43 <Pegazus> it's not...
21:25:44 <Cale> like, suppose that x was just constructed, and its value will be the same every time at this point in the program
21:25:45 <Pegazus> side effects....
21:25:47 <Cale> right
21:25:52 <Cale> state
21:25:56 <Pegazus> haskell has transparencial reference...
21:25:58 <Cale> f might change some state
21:25:59 <Pegazus> so?
21:26:06 <Pegazus> that's not a problem in itself...
21:26:30 <Cale> It is, because it makes it harder to understand what could be changing and what couldn't
21:26:30 <Pegazus> i agree that's true Cale!
21:26:56 <Cale> there's no way in most OO languages to say that a function can't change any state at all in the program
21:27:08 <Pegazus> that's a flaw, i agree with you...
21:27:23 <Pegazus> but for other reasons :)
21:27:32 <Cale> there's no way to say that a function cannot decide to launch missiles :)
21:27:44 <Cale> from the caller
21:27:52 <goltrpoat> cale:  well, you can place a certain number of guarantees with constness
21:27:55 <Pegazus> it depends on what you call "cannot decide to launch missiles :)"
21:28:04 <Cale> say, cannot print to the screen
21:28:13 <Cale> if that's easier to understand
21:28:13 <Pegazus> in haskell you couldn't neither if it has IO or some thing like that in it...
21:28:29 <Cale> But you can construct monads which are more stratified
21:28:29 <Pegazus> f it has IO or some thing like that in it...
21:28:29 <Pegazus> <
21:28:43 <Cale> and restrict statically the behaviours allowed
21:28:49 <dons> yeah, that's the whole point. you don't use the stateful monad if you want to constrain state....
21:29:02 <Cale> I can construct a monad on top of IO in which only reading from files in a specific directory is possible.
21:29:14 <Pegazus> <Cale> say, cannot print to the screen --> you can do that only for some functions, but the ones who need to do some IO, you can't be sure of that
21:29:25 <Cale> Pegazus: I'm saying that you *can*
21:29:56 <Pegazus> <Cale> Pegazus: I'm saying that you *can* --> you can "too" in that kind of sense, with OOP to
21:30:03 <Cale> No
21:30:06 <Pegazus> yes
21:30:07 <dons> yeah, learn the language. a basic understanding of static typing and effects makes this clear, Pegazus. it wastes our time trying to explain this.
21:30:12 <Cale> No, you can't.
21:30:14 <Pegazus> i do
21:30:17 <Pegazus> i look at the header
21:30:25 <Pegazus> if the functions there, doesn't need any IO
21:30:33 <Pegazus> then there won't be any #include <io_header>
21:30:33 <Pegazus> :)
21:30:43 <Pegazus> and i know it doesn't do any IO nor anything like that
21:31:08 <Cale> how do you know that another programmer won't come along and change that?
21:31:19 <Cale> without touching your module
21:31:20 <Pegazus> Cale
21:31:29 <Pegazus> if programmers aren't well "educated"
21:31:34 <Pegazus> all programming languages are a shit
21:31:43 <Pegazus> you can do terrible things everywhere...
21:31:43 <edwardk> Pegazus: actually most c compilers will let you compile calls to printf even if the header for it isn't included ;)
21:31:50 <Pegazus> stupidity is the powerfullest thing in the world...
21:32:02 <Cale> Pegazus: yes, and we're *all* stupid to some extent
21:32:07 <Pegazus> <edwardk> Pegazus: actually most c compilers will let you compile calls to printf even if the header for it isn't included ;) --> that's a bug... it doesn't count :)
21:32:17 <lispy> edwardk: yeah, and c defaults return values to int and i forgot to extern something in my little RTS and it caused me about 30 minutes of bugging :)
21:32:20 <Pegazus> <Cale> Pegazus: yes, and we're *all* stupid to some extent --> you are taking stupidity to the greatest extent :)
21:32:42 <edwardk> peg: its a legacy K&R thing actually
21:32:46 <Cale> If the project gets large enough, I can't keep track of the fact that some other caller to a function depends on its behaviour of not printing to the screen, for instance.
21:32:51 <Pegazus> lispy: edwardk: --> c++ doesn't allow those things
21:32:56 <Pegazus> and i don't like c neither :)
21:33:11 <Cale> and maybe most of the other callers to the function would benefit from it printing something
21:33:12 <lispy> Pegazus: just giving a real world example...it bit me just today
21:33:17 <Pegazus> Cale: you can use documentation! you can design your project...
21:33:18 <Cale> but there's one which breaks
21:33:30 <Cale> You can document yourself into inactivity
21:33:52 <Cale> There are always going to be hidden assumptions, unless you explicitly prove your entire program correct.
21:33:53 <ThreeQ> and it's better if the compiler can read the documentation, too
21:34:02 <Pegazus> yes
21:34:14 <edwardk> peg: the point is that that documentation is not machine readable. if you rely on the fact that you can always unroll some action with no side effects and someone unwittingly adds one, and 'documents' it your code will compile, and still be horribly broken.
21:34:16 <Cale> What I'm saying is that it's *better* to have the compiler check it.
21:34:29 <Cale> To be able to *express* the distinction in the language
21:34:56 <Cale> Expressiveness is not just about expressing active behaviour, it's also about expressing what things *cannot* do.
21:35:26 <Pegazus> Cale: is really impossible for a "real life" project, to express all that the functions does, and does not in a formal language
21:35:42 <araujo> Pegazus, ?
21:35:48 <Pegazus> so we must rely in human communication...
21:36:15 <Bobstopper> Pegazus: sounds like you advocate doing the work that the haskell compiler could do for you. It's similar to garbage collection saving you the effort of messing with memory alloc.
21:36:16 <Cale> Why rely solely on human communication which might not be there, when we can actually do better in many regards?
21:36:32 <Cale> Sure, you'll still need human communication
21:36:36 <Pegazus> the effort of messing with memory alloc. --> that's not an effort if you do things correctly
21:36:44 <Cale> Pegazus: yes it is
21:36:51 <Pegazus> it's not...
21:36:54 <Cale> and memory allocation is a *huge* source of bugs
21:37:08 <Pegazus> that's because it's done by ppl who doesn't know what they are doing...
21:37:09 <Cale> look at all the buffer overflow exploits in all kinds of software
21:37:14 <Cale> so what?
21:37:37 <Cale> and often these are people who *do* know what they are doing, and make a mistake
21:37:51 <Cale> the compiler doesn't check -> there's an uncaught security flaw
21:37:57 <Cale> that's stupid
21:38:04 <Pegazus> <Cale> the compiler doesn't check -> there's an uncaught security flaw --> the compiler can't check if your program is correct
21:38:06 <Cale> If the compiler can check something, it should.
21:38:12 <Pegazus> you can try to check some things, not all
21:38:16 <Pegazus> <Cale> If the compiler can check something, it should. --> i agree
21:38:29 <Cale> It can go a *lot* farther than most of the OO languages are taking it
21:38:34 <Bobstopper> Pegazus: humans suck at accounting and excel at innovation. Computers suck at innovation but excel at accounting. Mem alloc, tracking state etc are all accounting tasks. They're jobs for computers, not humans.
21:38:38 <Pegazus> but i don't see that functional languages produces a fair advantaje of this over OOP
21:38:46 <araujo> Pegazus, Every function is a self-contained sub-program in Haskell. And Haskell is so expressive, that you can't find a border line between implementation and specification. Just reading a Haskell function prototype is enough to fully understand what it does. It is beautiful.
21:38:55 <Cale> Oh it really really does. Use Haskell for a while.
21:39:03 <Cale> Here's a nice example...
21:39:06 <Pegazus> Just reading a Haskell function prototype is enough to fully understand what it does. It is beautiful. --> that's terribly false...
21:39:09 <Cale> I wrote a Sudoku solver
21:39:16 <araujo> Pegazus, Why?
21:39:28 <Cale> But before I wrote the solver, I constructed a monad in which to write sudoku solvers
21:39:28 <Pegazus> i don't want to read the full source code to understand it
21:39:38 <Pegazus> and i don't know before that what the high level functions does...
21:39:52 <Cale> The monad ensures that any solver written in it which manages to fill in the grid has produced a correct solution
21:40:09 <araujo> Pegazus, Why is it false?
21:40:18 <Cale> That is, I have a sublanguage of Haskell in which there's a piece of state
21:40:22 * shapr watches the excitement
21:40:38 <Pegazus> i can search a program written on haskell, show you the main function, and you'll surely won't be able to tell me exactly what each function does...
21:40:54 <Cale> and I control access to that state so carefully that if I prove my monad correct, I can get automatic correctness for any solver using it
21:40:57 * goltrpoat briefly wonders when people are going to stop feeding the troll
21:41:06 <lispy> shapr: you better!  because the advice Cale/edwardk gave me made it quite slick to implement if's in my code generator!
21:41:13 <shapr> yay!
21:41:14 <araujo> Pegazus, Read carefully what i wrote again
21:41:33 <Cale> Pegazus: Just use Haskell for a while, and you'll see.
21:41:39 <Pegazus> sorry...
21:41:40 --- mode: ChanServ set +o dons
21:41:44 <araujo> Pegazus, Don't try to argue, jst for the sake of arguing
21:41:44 --- kick: Pegazus was kicked by dons (dons)
21:41:46 <Pegazus> anyway, i assure all the same that's not true
21:41:50 <Cale> dons: don't
21:41:51 <lispy> it's sad that i'm writing a compiler simply because i saw a good tutorial, but this learning experience is quite good
21:41:57 <dons> ok. but this is pretty annoying
21:41:59 --- mode: ChanServ set -o dons
21:42:03 <Pegazus> O_o
21:42:09 <Bobstopper> there it is :)
21:42:10 <shapr> Yeah, this is right on the border between discussion and trolling.
21:42:12 <lispy> dons: just this time i recommend /ignore
21:42:18 <shapr> ignore never works.
21:42:19 <dons> the channel is just filled with noise, and Pegazus consistenly starts these kinds of discussoins
21:42:26 <dons> lispy: already had it on for the last 10 months....
21:42:33 <lispy> dons: hehe
21:42:43 <Cale> Pegazus: I guarantee you that if you read up on Haskell and learn it and use it for a while, then you'll notice.
21:42:43 <lispy> dons: i wondered why you never respond to my questions :)
21:42:57 <Cale> Pegazus: and all the stuff we're saying will make perfect sense to you
21:43:14 <Pegazus> AddLeaf :: Leaf -> Tree -> Tree -- what does this do araujo?
21:43:16 <satan> sorry to interrupt this, i don't think im on the right track, im trying to write 'insert b xs' with foldr where b will be inserted in order, so 'insert 5 [1,2,7,9] will give me [1,2,5,7,9]
21:43:17 <Bobstopper> Pegazus: before arguing any further, use haskell and play with the ideas yourself. You'll then know for yourself what's being said and whether it's true or all guff. It's really pointless to try to argue a subject you have no experience with.
21:43:18 <dons> if the would just learn the language, rather than dropping in to start debates on software design .... month after month ....
21:43:21 <Cale> Pegazus: and there will be whole new classes of bugs which you feel that you shouldn't have to deal with anymore.
21:43:23 <lispy> how do i make Int the default in a module?
21:43:32 <Cale> satan: recursively?
21:43:38 <Cale> oh, with foldr
21:43:41 <satan> Cale: with foldr
21:43:56 <satan> yeah from before i remember your advice about foldr just being a replacement for cons, right
21:44:04 <shapr> Pegazus: Did you hear that?
21:44:13 <satan> i mean, the function passed in being a replacement for cons
21:44:21 <Cale> right
21:44:23 <Pegazus> cons?
21:44:24 <Pegazus> what?
21:44:35 <Cale> Pegazus: the operator which adds an element to the start of a list
21:44:37 <shapr> The part about "learn or stop talking" ?
21:44:40 <Botty> heh, oh noes, satan is learning is learning haskell :O -- what will god do?
21:44:49 <satan> so i'm trying to check if it's more than the current element, then moving along
21:44:51 <Pegazus> anyway, i'm waiting for araujo to tell me what it does...
21:45:12 <satan> so sorta like, if 5 < 7, then return [7,8], but since 5 > 2, put it in to get [5,7,8]
21:45:16 <dons> it's this kind of pattern of behaviour that concerns me: 05.05.15:08:31:39 * Lemmih thinks Pegazus is just trolling.
21:45:16 <Cale> Pegazus: anyway, it's really getting hard to take you seriously around here... what have you written in Haskell so far?
21:45:22 <shapr> Pegazus: It sounds to me like you have a conclusion and you are searching for facts to support it.
21:45:27 * araujo looks around here
21:45:34 <Pegazus> what have you written in Haskell so far? --> only little things...
21:45:36 <dons> 05.05.15:08:51:11 <autrijus> er. I wasn't sure Pegazus was trolling. now I'm convinced :)
21:45:53 <araujo> Pegazus, ther eis no point if you just want to argue
21:45:55 <Pegazus> araujo: read my question please!
21:46:00 <Pegazus> i don't want to argue
21:46:19 <satan> but the initial 'a' i pass in, as in with foldr f a xs, is [], and i cant check if 8 > []
21:46:20 <Cale> Pegazus: okay, do you want a pointer to a nice tutorial? I recommend YAHT, if you haven't seen that
21:46:23 <Pegazus> i'm just wanted to know your opinions...
21:46:38 <shapr> But then you don't like our opinions.
21:46:49 <Pegazus> but they are usefull to learn new things :)
21:47:01 <satan> Botty: god has nothing to fear for a very very long time, given my rate of learning :)
21:47:11 <Botty> hehe :)
21:47:32 <Cale> Pegazus: by your responses, I think you'd be better off just trying Haskell for a while. Maybe read up on STM, since that's a really really good example of a monad used to control behaviour
21:47:35 <shapr> Pegazus: Ok, what have you learned?
21:47:37 <Pegazus> i listen to all the opinions, and then i build my own...
21:47:40 <ThreeQ> Pegazus: more useful would be actually learning the language, I think
21:47:51 <dons> Cale: see:
21:47:53 <dons> 06.05.19:12:06:29 <Philippa> Pegazus: you're in a chan where a good many people research various aspects of programming languages. Really, you're outclassed and should try learn for a whil
21:47:57 <dons> 06.04.09:00:22:49 <Pegazus> where did you learn all that? do you know a book? webpage?
21:48:00 <dons> 06.10.14:20:57:45 <Pegazus> what books or papers or thing would you advise me to read
21:48:03 <dons> 06.10.16:11:44:33 <Pegazus> any recommended books list?
21:48:04 <dons> if he hasn't found haskell.org by now well....
21:48:05 <araujo> Pegazus, The function takes a valid value belonging to the Leaf ADT, and to the Tree ADT. And it returns a valid value of the "very same" Tree ADT, which mean that you can call this function ANYWHERE from your code that accepts such a valid value.
21:48:07 <dons> 06.10.17:22:22:37 <Pegazus> any good book, webpage, tutorial, anything you can advise me
21:48:26 <araujo> Pegazus, Sorry you can't say _all_ that much with other languages from its prototype :-)
21:48:33 <araujo> Now back to continue fixing packages ....
21:48:35 <Cale> http://haskell.org/haskellwiki/Books_and_tutorials
21:48:38 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
21:48:53 <Cale> OH! I know
21:49:03 <Cale> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html -- this one Pegazus
21:49:04 <Cale> read that
21:49:06 <lambdabot> Title: Why Functional Programming Matters, http://tinyurl.com/y45xxm
21:49:12 <Pegazus> <araujo> Pegazus, Sorry you can't say _all_ that much with other languages from its prototype :-) --> you didn't tell me what the function really does...
21:49:47 <Cale> Pegazus: read that right now, and get back to us when you're done :)
21:49:48 <shapr> Pegazus: Dude, give it up.
21:49:49 <Pegazus> and i can say the same in in other languages... (and if you want to continue this discussion privmsg me because dons isn't gonna like this in the channel)
21:49:59 <Cale> Pegazus: okay?
21:50:10 <Pegazus> okay what? :)
21:50:22 <araujo> Pegazus, That's the _only_ information that cares to me . It is called function "specification". So please, read carefully what i wrote _again_ for the last time.
21:50:24 <Cale> whyfp is a whole paper of answers to your questions
21:50:26 <Bobstopper> Pegazus: read cale's link. It's a good read for the questions you're asking.
21:50:34 <Cale> It's exactly what you want
21:50:44 <Cale> and it probably says it more eloquently than we can
21:50:48 <araujo> No point to continue if you don't understand the terms anyway
21:51:22 <Pegazus> that's not the complete specification of the function araujo... it not nearly enought to know if the program is correct or not...
21:51:34 <Cale> Pegazus: if you read that paper, and demonstrate comprehension of it, then we'll take you seriously :)
21:52:11 <araujo> Cale, do we want that? :-P
21:52:16 <Cale> But honestly, you've been asking these questions for a lot longer than it took me to find answers to them for myself.
21:52:31 <goltrpoat> can i keep not taking him seriously?
21:52:33 <Cale> and you seem like you know at least a bit about programming languages
21:52:34 <Bobstopper> personally, I'd like to read a link like Cale's only for OOP instead. I just don't get what the hype about OOP is...
21:52:44 <shapr> Bobstopper: Paid advertising.
21:52:56 <Cale> Bobstopper: watch the SICP lectures on it.
21:53:16 <lispy> Bobstopper: i think OO has it's place
21:53:18 <Bobstopper> I don't remember SICP having an OOP part?
21:53:22 <Cale> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ -- 5a and 5b.
21:53:25 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
21:53:30 <Botty> oop matches many problems quite well
21:53:48 <Pegazus> Bobstopper: try Object Oriented Software Construction - Bertrand Meyer
21:53:57 <shapr> Pegazus: So, how would you summarize John Hughes paper "Why Functional Programming Matters." ?
21:54:08 <Pegazus> shapr: let me read it first :)
21:54:38 <Cale> Pegazus: okay, great, please please read it, because I think it'll answer most of the more grating questions you've been asking :)
21:54:58 <Botty> Pegazus - OO and functional programming are not exclusive.
21:55:03 <Bobstopper> Cale: Oh right. Yeah, I remember those chapters. But they're presented kind of as an alternative approach to the same problem FP solves. I'd like to see something OOP has an advantage in comparable to FP + lazy eval's modularity advantages...
21:55:10 <lispy> so did anyone know how to change the default numeric type for just one module?
21:55:34 <lispy> because i'm using some exentials i have to keep tying things like (I (12::Int)) and it's getting old :)
21:55:52 <lispy> i always want ints so i'd like to tell hasklel that
21:55:53 <Pegazus> <Botty> Pegazus - OO and functional programming are not exclusive. --> i know that very well...
21:56:15 <Cale> Bobstopper: well, the objects provided a really nice way do build that embedded language of circuits, which would be trickier to build so directly with FP, since it's directly a model of statefulness
21:56:58 <Cale> However, we do have things like monads and arrows now, but that's generally what the gist of it was there.
21:57:08 <lispy> oh i see
21:57:22 <Cale> lispy: default
21:57:42 <lispy> default (Int, Double) is what i want
21:57:54 <Cale> http://haskell.org/onlinereport/decls.html#sect4.3.4
21:57:55 <Cale> yeah
21:57:56 <lambdabot> Title: The Haskell 98 Report: Declarations, http://tinyurl.com/y9o66z
21:58:40 <Bobstopper> The circuits example was there? I thought that was in the streams section... I guess it's been too long since I watched those lectures :)
21:58:52 <lispy> hmm...it doesn't seem to help
22:00:35 <lispy> i'll try turning off the monomorphism and see what happens
22:01:32 <lispy> nothing seems to help me here
22:01:35 <satan> ok i give up :)
22:02:28 <Cale> satan: hm, sorry for ignoring you there
22:02:33 <Cale> I'll have a look at it
22:02:45 <Botty> egads, I think functional programming has imprinted itself on my head.... C is even more painful than it once was
22:02:47 <satan> Cale: no worries, that was interesting to read anyway heh
22:02:56 <Botty> I keep trying to make functions out of other functions...
22:03:15 <Cale> Botty: hehehe
22:04:52 <Cale> satan: seems somewhat impossible with just that
22:05:15 <satan> oh really? phew haha
22:05:27 <satan> lemme check if i made any mistakes typing it out
22:06:03 <satan> Lemme type out the question and pastebin it, ok
22:06:06 <satan> 1 sec
22:06:51 <Cale> It's easy, however, to write sort with foldr and insert
22:08:42 <satan> ok here it is http://nanobin.nanosouffle.net/1784
22:08:44 <lambdabot> Title: nanoPaste your Crap
22:08:58 <satan> is it? damn
22:09:26 <lispy> class Foo a where blah :: a -> Int; data Bar = forall a. (Foo a) => I a -- now I 1 gives a type error
22:09:38 <Cale> oh, hmm that's more interesting :)
22:09:41 <lispy> oh and instance Foo Bar
22:10:11 <lispy> er no instance Foo Int
22:11:22 <satan> yeah i thought so, maybe i should stick to the easier questions in the book
22:19:17 <Botty> seems like there is a fairly simple, yet not efficient, solution to that problem
22:19:34 <satan> which one, the one i pasted?
22:19:40 <Botty> yep
22:19:44 <satan> i'll take it !
22:19:45 <satan> lol
22:20:00 <Bobstopper> hmm... SICP's example of OOP looks a lot like flow-based programming.
22:20:04 <satan> seriously though, so is the insert not supposed to insert in sorted order?
22:20:12 <Botty> no, it is
22:20:26 <Cale> hmm
22:20:36 <satan> ok good
22:20:58 <int-e> hmm. writing insert as foldr feels artificial.
22:21:12 <int-e> it's possible, sure.
22:21:39 <Cale> Oh, I suppose you can actually analyse the start of the recursive case, and get something
22:21:58 <satan> ok
22:22:10 <satan> was my approach totally incorrect though?
22:22:26 <Botty> hmm, actually that's pretty contrived, never mind
22:22:32 <Botty> (the problem)
22:22:48 <Cale> It's really a very unnatural use of foldr
22:23:01 <satan> i see
22:23:15 <Botty> I was gonna have the initial value equal [b] and then when items come in, compare them to b and append to either the left or right.
22:23:30 <satan> right, exactly
22:23:35 <Cale> because you have to go to great lengths to ensure that it only inserts the element in an appropriate place, and not every place after the appropriate one :)
22:23:43 <satan> except i was only appending to the left if they were greater than it
22:23:51 <Botty> problem is this reverses one of the sides
22:23:56 <int-e> @type \f a xs -> foldr f a xs `asTypeOf` xs
22:23:57 <lambdabot> forall a. (a -> [a] -> [a]) -> [a] -> [a] -> [a]
22:23:59 <satan> Cale: right, thats where i was tripping up
22:24:40 <Botty> pretty simple to do with two filters and a concatenation
22:24:53 <Botty> (the whole function, not just f)
22:24:55 <Cale> which filters?
22:25:07 <Botty> the filter function
22:25:08 <int-e> I guess the resulting 'insert' only works for sorted lists.
22:25:18 <Cale> oh, yes, I see which two
22:25:20 <Cale> partition
22:25:31 <Cale> > partition (< 5) [1..10]
22:25:33 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
22:25:42 <Botty> oh, nice.
22:25:47 <goltrpoat> how about insert b xs = foldr (\x ys -> if (x < b) then x:ys else ys++[x]) [b] xs
22:25:52 <Cale> er, no
22:25:55 <goltrpoat> it's unstable though, and insertion sort is supposed to be stable
22:25:57 <Cale> > span (< 5) [1..10]
22:25:58 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
22:26:06 <Cale> span is what you want :)
22:26:16 <goltrpoat> thought he wanted to write it as a foldr
22:26:25 <int-e> goltrpoat: that turns part of the list around
22:26:31 <Cale> Insert would do too much if it was written with filters
22:26:39 <Cale> It would do a quicksort step
22:26:44 <Cale> though I suppose that's fine
22:26:53 <Botty> heh, yeah
22:27:10 <int-e> what I'd do would be equivalent to a bubble sort pass. that's not pretty either.
22:27:29 <goltrpoat> you just want to insert each element in the right spot, you don't care what the order of the rest of the elements is.
22:27:44 <int-e> but luckily, insert is highly underspecified.
22:27:48 <goltrpoat> > let insert b xs = foldr (\x ys -> if (x < b) then x:ys else ys++[x]) [b] xs in foldr insert [] [4,1,50,2,4,59,23,2]
22:27:49 <lambdabot>  [1,2,2,4,23,4,50,59]
22:28:02 <goltrpoat> oh.  i guess i screwed up though.
22:28:14 <dons> mmm. lego is like first order pretty printing combinators for 3d surfaces, http://www.andrewlipson.com/mathlego.htm
22:28:16 <lambdabot> Title: Andrew Lipson's Mathematical LEGO Sculptures
22:28:59 <dons> mmm http://www.andrewlipson.com/ptorus.htm
22:29:01 <lambdabot> Title: LEGO Punctured Torus
22:29:53 <dons> hmm, he uses C++ to generate the blueprints. hmm!
22:30:07 * dons smells a 3d pretty printing combinator library
22:30:11 <goltrpoat> haha
22:30:14 <satan> hmmm
22:30:28 <dons> or maybe just use 3D Pan
22:30:36 <dons> since these come straight from equations
22:31:07 <dons> e.g. http://conal.net/Vertigo/
22:31:07 <lambdabot> Title: The Vertigo GPU compiler
22:34:14 <Pegazus> hi
22:34:20 <Pegazus> i've read the whyfp...
22:35:53 <Pegazus> and now i ask you... now that i have all those programms described there, for analizis purposes, i want that each time a list is added or asked for an element, it should write the info on wich list and wich element in a log.txt file... how can you do that?
22:36:18 <Pegazus> analizis = analysis
22:36:34 <shapr> Pegazus: Yes.
22:36:50 <shapr> You can do that.
22:36:54 <Pegazus> how?
22:37:07 <shapr> First you read the Haskell introductions to learn basic Haskell.
22:37:25 <shapr> Then you read the "All About Monads" tutorial to learn about monads.
22:37:29 <shapr> Then you know the answer.
22:37:37 <dons> why not try to do it, then come back with the code?
22:37:42 <dons> it'll help you learn.
22:38:02 <dons> just asking how to do it doesn't seem to be helping much. so I say _do_ something, rather than just talking about it
22:38:24 <Pegazus> it's my last question (today) so you may be nice and answer it :)
22:38:32 <shapr> We did answer it.
22:38:35 <Smokey`> ^_-
22:38:39 <Pegazus> you didn't, but well...
22:38:56 <shapr> I got tired of spoonfeeding people on #haskell years ago.
22:39:07 <dons> you use monads, and solve it the same way you'd do in any other language. have a go.
22:39:15 <Pegazus> what way?
22:39:30 <dons> you've got no idea? better start with comp1A then.
22:39:56 <dons> use an Agile technology, and a Singleton pattern
22:40:01 <dons> on Rais.
22:40:05 <dons> rails
22:40:06 <jgrimes> :p
22:40:11 <Pegazus> so how can i do that dons?
22:40:13 <Botty> lol
22:40:21 <shapr> Pegazus: Are you serious?
22:40:21 <dons> with agility. that's the key
22:40:29 <Pegazus> i'm
22:40:32 <lispy> better make an agility check
22:40:35 <lispy> ?dice 1d20
22:40:35 <lambdabot> 1d20 => 2
22:40:36 <shapr> lispy: haha!
22:40:44 <lispy> oh, i failed...
22:40:47 <dons> heh
22:40:47 <aleator> Umm.. How about just debug.trace?
22:40:48 <lispy> no agile development for me :(
22:41:16 <Botty> you could probably use Web 2.0 to do this
22:41:27 <lispy> ah yeah, use the ajax monad
22:41:36 <Pegazus> aleator: no idea wat debug.trace is (but if it is what it's name suggests), then it's not what i want...
22:41:48 <dons> yeah, Botty I think Web 2.0 would be good. but you'll need a 7th GL
22:42:00 <lispy> heh
22:42:03 <Pegazus> my question basically, is how good haskell is designed to support requeriment changes...
22:42:32 <lispy> Pegazus: that question doesn't make any sense
22:42:54 <int-e> Pegazus: you might also have a look at http://catb.org/~esr/faqs/smart-questions.html ... most of that applies to this channel, even though #haskell is actually quite forgiving for simple or even stupid questions.
22:42:55 <Botty> it makes some sense - its like what the agile methodology proposes to do
22:43:00 <lambdabot> Title: How To Ask Questions The Smart Way, http://tinyurl.com/2wo6o
22:43:04 <dons> you should use self-organizing code whose design enhances agility
22:43:22 * shapr snickers
22:43:31 <Cale> What about Charismatic Development? Constitutional Development?
22:43:37 <Pegazus> <dons> you should use self-organizing code whose design enhances agility -> is that possible?
22:43:38 <Botty> yeah, agility depends more on you then the language, but haskell allows you more for sure
22:43:43 <Botty> sure
22:43:57 <Botty> Charismatic development sounds fun
22:44:09 <Botty> embed jokes in the source code to improve moral
22:44:11 <Smokey`> :)
22:44:43 <int-e> . o O ( "/ignore about:software engineering" ) <-- I need a smarter IRC client.
22:44:55 <Pegazus> anyway, i've to admit that i haven't thought of the nice uses of lazy evaluation the paper shows...
22:45:36 <Cale> Pegazus: basically, the major advantage of lazy evaluation is it greatly increases the number of ways you can break up a problem into parts
22:45:38 <shapr> Pegazus: Because of purity and higher order functions, Haskell supports requirement changes better than other languages, in my opinion. This is the last thing I will say to you until you have written some Haskell code.
22:45:51 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- like this use?
22:45:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:45:52 <Pegazus> all the problems that whypf says functional programming solves, can be solved with equal elegance in OOP or some other languages...
22:46:16 <Heffalump> including coroutine style code? I doubt that.
22:46:25 <int-e> programming languages don't solve software engineering problems. if they do anything, they create them.
22:46:29 <Pegazus> what's coroutine style code?
22:46:32 <Botty> OOP isn't a language
22:46:38 <Heffalump> the producer/consumer stuff
22:46:39 <Pegazus> OOP is a paradigm
22:46:42 <Pseudonym> FP isn't either.
22:46:46 <Pegazus> well kind of :p
22:46:55 <Pegazus> functional programming is another one but well
22:47:05 <Botty> yeah, I know - "equal elegance in OOP or some other languages" implies it is sort of
22:47:05 <lispy> Heffalump: actually OO has a pattern for that which works okay
22:47:05 <Pegazus> the limit is quite doubtful...
22:47:28 <Pseudonym> One thing that is true is that OO and FP are different answers to the same problem.
22:47:32 <Pegazus> Botty you are right, i miss communicated myself..
22:47:45 <shapr> Can someone remind me how apache2 decides which mimetype to give to a file? I want .hs files to show as text on my webserver.
22:47:55 <Botty> Heffalump - yeah, its generators - you implement an enumerator as the producer, and the consumer just does an enumeration on the results
22:48:03 <Pegazus> Pseudonym: i think that OO is really pointed to large scale problems, and FP to little ones...
22:48:09 <Pseudonym> I disagree.,
22:48:11 <Smokey`> shapr: conf/mime.types
22:48:13 <int-e> shapr: I think it looks at /etc/mime.types
22:48:20 <Smokey`> or etc...
22:48:21 <Botty> Pegazus: that's ok.  just bugs me when people use the term 'OOP' in other ways
22:48:21 <dons> the key is to use a hands on methodology that will wrap existing extreme pair practices to reduce confusion
22:48:24 <Smokey`> depends on platform sorry :)
22:48:48 <shapr> dons: That's great stuff :-)
22:48:48 <Botty> dons - lol
22:49:00 <shapr> dons: Watch out, microsoft will hire you.
22:49:07 <shapr> They already got Igloo!
22:49:19 <dons> True!
22:49:22 <int-e> are we playing buzzword bingo now?
22:49:45 <Cale> Pegazus: That's not true at all. Large scale problems are where functional programming becomes more important, because there's a lot to keep track of, and functional programming gives you more guarantees than OO about the behaviour of code.
22:49:45 <Pegazus> well, thanks you all for your patience :) and answers...
22:49:52 <goltrpoat> i feel that dons' input underscores the root stability inherent in modern paradigms.
22:49:54 <dons> so why isn't "Microsfot Hires Lead Haskell Developer... number 17" on the top of reddit? But one Ruby guy can stay there for days.
22:50:38 <Pseudonym> I think the main distinction is that OO is designed for programs with a relatively unchanging dynamic structure.
22:50:41 <Pegazus> Cale: it gives you some little guarantees... but at large scale that doesn't help much from my point of view... you need stronger guarantees that can only be "expressed" in natural language...
22:50:41 <dons> goltrpoat: i agree. you've pinpointed the essential characteristics of team driven languages for organising change cross-functionally
22:50:55 <shapr> The vertically oriented stability of our objectified management has taken our results to a higher order. Our non-strict requirements have pushed our stocks into normal form.
22:50:59 <Pseudonym> FP is a much more flexible glue.
22:51:00 <goltrpoat> pegazus:  i'm not sure how you can say that without having ever seen a large scale fp project.
22:51:06 <dons> hehehee
22:51:11 * Smokey` is soo confused :P
22:51:35 <Botty> Pegazus - check out frag.
22:51:50 <Pegazus> goltrpoat: i've seen some small ones that doesn't have them...
22:51:53 <Botty> its big, and its functional, well, not that big, because its functional, but it does alot
22:52:05 <Cale> Pegazus: it gives you some fairly strong, global guarantees actually
22:52:10 <dons> I suppose 2 million lines of Erlang would be big?
22:52:14 <Cale> Pegazus: something you should read...
22:52:27 <Pseudonym> Erlang is an OO language, though.
22:52:29 <dons> or 600k lines of Haskell in fptools? You could start there with those small projects
22:52:31 <Pseudonym> :-)
22:52:32 <Cale> http://research.microsoft.com/Users/simonpj/papers/stm/stm.pdf
22:52:35 <lambdabot> http://tinyurl.com/nn2jp
22:52:46 <Pseudonym> In fact, Erlang is OO as Alan Kay originally envisaged it.
22:52:51 <Cale> that paper might not be *completely* readable yet, but you should be able to get the idea of it
22:52:56 <satan> ok im back from a looong phone call, sorry, so i guess we decided that problem was too contrived? futile to attempt with foldr? should i move on?
22:53:00 <Pegazus> Cale: you don't need some global guarantes, but guarnatees that all functions does exactly what they should do...
22:53:21 <goltrpoat> shapr:  agreed.  we must keep in mind the orthogonality of product-driven development to the application of marketing terms to bottom-up infrastructure under the curry-howard isomorphism.
22:53:25 <int-e> satan: it's not futile ... it's a "wrap your head around foldr" problem.
22:53:30 <Cale> Pegazus: sometimes it's enough to just be able to express what things can and can't do
22:53:36 <int-e> satan: viewed that way it isn't even a bad problem.
22:53:37 <satan> int-e: i see
22:53:41 <Botty> such guarantees are much more easily achieved if the functions are concisely written
22:53:42 <Cale> Pegazus: FP doesn't completely eliminate bugs
22:53:42 <Pegazus> and yes, you know that the function you call can't modify anything, and the only thing it can "touch" is the return value, but that's not enought, not a much percentage of it...
22:53:53 * shapr passes out after dealing with all that hot air, be back tomorrow!
22:53:54 <int-e> satan: but actually implementing insert that way seems silly
22:53:57 <goltrpoat> haha
22:54:20 <satan> int-e: heh sure, maybe i'll make a note of all these problems that are silly and tell the author
22:54:21 <Pegazus> i agree with you that it's nice that you know a function won't touch anything. but in the long way, i don't think that helps much
22:54:33 <Pegazus> you must know that the function does exactly what is meant to do
22:54:45 <Cale> Oh, it helps a lot
22:54:53 <Botty> well, you can do that much more easily in a functional language
22:54:56 <arcatan> how OO telps with that?
22:55:01 <arcatan> *helps
22:55:10 <Cale> Because it makes it easier to break the function up into parts and prove things about it
22:55:11 <Botty> procedural languages don't lend themselves to that at all
22:55:23 <Cale> and thus *show* that it does exactly what it is meant to do
22:55:24 <dons> goltrpoat: right! it's important for customer priority that your eager practices drive the project in such a way that clarifies the business domain monadically
22:55:27 <int-e> satan: one reason why it's bad is that you have to rebuild the whole list even if you insert an element at the front.
22:55:28 <Pegazus> <Cale> Because it makes it easier to break the function up into parts and prove things about it --> it's the same in OOP...
22:55:35 <Cale> Pegazus: not at all
22:55:38 * dons votes for International-Talk-Like-An-Agile-Guru day
22:55:41 <Botty> yeah, if you prove one thing about a function, and one thing about another function, you can prove something about the composition
22:55:49 <Cale> Pegazus: have you ever tried to prove that an entire OO program is correct?
22:55:51 <goltrpoat> dons:  and yet, the question remains:  how do we effectively curry upper management?
22:56:01 <Cale> Pegazus: It's brutal.
22:56:09 <Pegazus> <Cale> Pegazus: have you ever tried to prove that an entire OO program is correct? --> not 100% formally, but yes i did it...
22:56:16 <int-e> goltrpoat: who'd want to eat that?
22:56:18 <dons> goltrpoat, you heat a pan with hot oil, then fry them with chilli, of course
22:56:22 <goltrpoat> haha
22:56:25 <goltrpoat> was waiting for that
22:56:35 <Pegazus> with functional language is a lot easier to "formally prove that kind of things"
22:56:37 <satan> int-e: ah i see, so i should check if the initial element is more than the current and then insert it there and re-add to a new list, right?
22:56:39 <Botty> Pegazus - well, rest assured the process is much simpler with functional languages
22:56:39 <Pegazus> i agree on that too
22:56:43 <Pegazus> but that's not often done...
22:56:47 <Pegazus> i know
22:56:50 <Cale> Pegazus: yes, and also to informally do so, as a result
22:56:50 <dons> man this practice of quoting lines still on the screen is really really annoying
22:57:02 <Pegazus> <Cale> Pegazus: yes, and also to informally do so, as a result --> a little, not that much...
22:57:05 <int-e> satan: not sure what that means exactly, so I'll reluctantly answer 'yes'.
22:57:07 <dons> um.
22:57:08 <Cale> Pegazus: to talk to someone specific, just use their nick
22:57:18 <satan> int-e: heh, thanks :)
22:57:23 <Cale> Pegazus: a huge great deal
22:57:25 <Botty> actually, alot
22:57:36 <Pegazus> i'm remembering what dijkstra said once...
22:57:37 <Cale> Pegazus: It's a ridiculously large benefit
22:58:08 <Pegazus> that functions names weren't important... you only (and always) need the function specification, no more, no less.... to use it...
22:58:18 <dons> I say no one is allowed to talk until they produce a type correct function to permute a list
22:58:18 <int-e> dijkstra should be happy. Haskell has no gotos (please nobody mention the Cont monad).
22:58:20 <Cale> because once you can show that two functions work, then you automatically know that they work together
22:58:23 <Pegazus> he thinked that functions with names f1,f2,f3, etc... were ok as long as you have the specification....
22:58:38 <dons> whose up for the "not voice without ghc saying so first" rule?
22:58:51 <Pegazus> <dons> I say no one is allowed to talk until they produce a type correct function to permute a list --> permute in what way exactly?
22:59:06 <dons> man my op fingers are getting itchy
22:59:08 <Botty> well, maybe dijkstra is wrong
22:59:13 <Pegazus> <Cale> because once you can show that two functions work, then you automatically know that they work together --> i can say the same about some objects...
22:59:19 --- mode: ChanServ set +o dons
22:59:22 <Cale> Pegazus: no you can't
22:59:22 --- mode: dons set +b *!*=kliaejrg@201.231.232.*
22:59:23 --- kick: Pegazus was kicked by dons (dons)
22:59:27 --- mode: ChanServ set -o dons
22:59:32 <Botty> that was pretty cold
22:59:51 <goltrpoat> ding dong.
22:59:58 <goltrpoat> the witch is dead.
23:00:06 <int-e> <silence> ... thanks dons, I guess.
23:00:11 <Xgc> Pegazus seemed to be begging for that.
23:00:11 <gour> huh
23:00:14 <araujo> hahaha
23:00:19 * Pseudonym listens to the sounds of crickets chirping
23:00:21 <dons> if anyone is terribly concerned, unban I don't mind. but I think he really was trying to provoke us.
23:00:34 <dons> check the logs  for the last 10 months.
23:00:39 <Botty> probably, but you never know
23:00:40 <Botty> oh
23:00:42 <araujo> geez, thanks dons for saving Cale from that infinite loop
23:00:48 <int-e> I was still amused, but I wasn't really paying attention.
23:00:50 <Smokey`> lol
23:00:59 <jajs> a friend of mine is writing an agile java framework called "Java on Tram" :o
23:01:02 <Cale> hey, I like refuting things
23:01:07 <dons> the first reference to 'Pegazus.*Troll' was 10/10/2005....
23:01:16 <int-e> Cale: there are better things to refute.
23:01:18 <Botty> lol
23:01:23 <Cale> heh
23:01:55 <Xgc> dons: I checked.  Every time he joined it was always an attempt to argue some point that he (seemingly) knew nothing about, without listening to the response.
23:02:00 <Cale> What's the formal definition of agile?
23:02:26 <Cale> If I want to determine if something is agile or not, what do I do?
23:02:39 <Cale> (in the programming library sense :)
23:02:41 <int-e> Moving target, hard to catch. Trolls are often agile.
23:03:00 <Botty> yes, throw things at it, and if it dodges it, its likely agile
23:03:05 <dons> just for reference, http://www.haskell.org/haskellwiki/Protect_the_community, in particular, http://www.haskell.org/haskellwiki/Protect_the_community/Notes#Identify_poisonous_people
23:03:05 <lispy> Cale: it's marketing...you can't formally define it :(
23:03:05 <Pseudonym> I'm making a left-cancellable framework called Haskell on Monorails.
23:03:07 <Cale> I know what it means as an English word
23:03:08 <lambdabot> Title: Protect the community - HaskellWiki, http://tinyurl.com/vh763
23:03:23 <Cale> but not how that English word could possibly have anything to do with software
23:03:37 <dons> Cale: i think it means "easy to change" in its purest form.
23:03:44 <Botty> to truely understand agile you have to read a few buzzword-laden books on the topic
23:03:54 <dons> Botty: does that help? :)
23:04:03 <goltrpoat> cale:  basically, the idea is that you iterate really quickly, get a bunch of functionality in without worrying too much about architecture, then refactor and keep going until it's done
23:04:07 <dons> it might be a Zen thing, i guess.
23:04:26 <jajs> Cale, look at the web page and see if it's CSS uses mozilla rounded corners :-)
23:04:32 <Cale> #haskell should work together to move Haskell-related things to the top of reddit
23:04:56 * Pseudonym points the reddit people to the "Identify poisonous people" advice
23:05:12 <int-e> Botty: does it involve doublethink?
23:05:15 <Botty> dons - interesting stuff
23:05:32 <Botty> int-e - undoubtedly
23:05:34 <Pseudonym> Agile development is zen in the sense that it's a state of mind.
23:05:45 <Botty> or rather, int-e: yes and no
23:05:53 <dons> maybe.
23:05:53 <Cale> dons: hehe, submit separate reddit entries for everything in HWN :)
23:06:00 <Pseudonym> You know the requirements are going to change, so you do it as you go.
23:06:03 <dons> Cale: heh
23:06:26 <dons> that would be a highly agile methodology
23:07:20 <Cale> Isn't the best way to deal with potentially changing requirements to design domain specific languages? Is that what people who claim to be doing agile development are doing in practice?
23:07:55 <goltrpoat> it is, but designing DSLs in c++ is not exactly a natural thing
23:07:57 <int-e> that's not agile enough, you need to be able to deal with changes of the domain.
23:08:09 <Cale> heh
23:08:26 <Cale> So you end up reinventing the general-purpose language :)
23:08:36 <satan> here's one that's a bit easier? :) What is the least fixpoint of f, where f a = [True] ?
23:08:50 <Cale> let's try it
23:08:58 <dons> yay, a haskell question!
23:09:01 <Cale> > let f x = [True] in fix f
23:09:02 <dons> satan++
23:09:02 <lambdabot>  [True]
23:09:06 <dons> go satan!
23:09:06 <satan> lol
23:09:19 <satan> what is fix f?
23:09:21 <int-e> satan: what fixpoints does f have?
23:09:23 <satan> is that built in
23:09:29 <dons> ?hoogle fix
23:09:30 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:09:30 <lambdabot> Control.Monad.Fix :: module
23:09:30 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
23:09:30 <int-e> it's in Control.Monad
23:09:31 <Cale> satan: fix f = f (fix f)
23:09:34 <int-e> it's in Control.Monad.Fix
23:09:35 <int-e> sorry.
23:09:45 <Heffalump> fix (const x) = x always, surely
23:09:58 <Cale> It computes the least fixed point of f
23:10:00 <satan> so a fixpoint is such that, f x = x, right?
23:10:04 <dons> fix f = let x = f x in x
23:10:04 <Cale> yeah
23:10:05 <int-e> satan: yes
23:10:05 <satan> like the fixed point theorem in math
23:10:19 <Botty> Cale - a language which can handle multiple DSLs would certainly allow for quite a bit of natural agility
23:10:33 <satan> ok so we need to find a function, or express f in such a way that f x  = x
23:10:36 <int-e> satan: the easy case is when there's only one fixed point.
23:10:49 <dons> ?type let f x  = x in f
23:10:50 <lambdabot> forall t. t -> t
23:10:56 <dons> ?djinn t -> t
23:10:56 <lambdabot> f a = a
23:10:57 <Botty> satan: f = (.) ?
23:11:00 <Cale> Botty: so why is everyone using Ruby instead of Scheme and Haskell?
23:11:01 <int-e> satan: and you're dealing with one of these cases.
23:11:03 <Cale> :)
23:11:07 <dons> ?. pl djinn t -> t
23:11:07 <lambdabot> f = id
23:11:09 <Botty> I mean $  or something
23:11:17 <satan> Botty: i don't know
23:11:31 <Botty> Cale - heh, the imperative paradigm is intuitive.  We've discussed this one before :)
23:11:39 <satan> int-e: ok, how would i know that? because the argument a doesnt appear in the function?
23:11:44 <Botty> or its just because everyone learns an imperative language first
23:11:51 <satan> it disregards the argument completely, right, the answer is always [true]
23:11:55 <Botty> anyway, haskell doesn't allow for true DSLs, in my opinion
23:12:07 <Cale> Botty: Haskell is the finest imperative language so far :)
23:12:08 <Botty> its better than most things in this respect though :)
23:12:19 <int-e> satan: a isn't used, so the function value is always [True] so that's the only possibility for a fixed point.
23:12:19 <dons> I think i'l write the program: main = system "ghc", and call it the "Smashcal" compiler. And it will be  an imperative language
23:12:26 <Cale> Botty: have you used Parsec?
23:12:31 <satan> int-e: right, wicked
23:12:34 <int-e> satan: and you can easily verify that f [True] = [True]
23:12:36 <Botty> Cale - yes
23:12:40 <Pseudonym> Our world is full of imperative instructions.
23:12:43 <dons> and everyone will love this new agile Smashcal imperative langauge
23:12:45 <Pseudonym> Checklists, recipes etc.
23:12:53 <satan> so to find the LEAST fixed point, would that be different, since the q asked for that
23:12:59 <Pseudonym> Micromanaging employers...
23:13:11 <int-e> satan: the least fixed point is a fixed point
23:13:11 <arcatan>  /wg 25
23:13:13 <arcatan> or not
23:13:21 <Botty> and yes, I realize that monads and do effectively maps imperative stuff onto functional, but still :)
23:13:24 <int-e> satan: and there is only one fixed point so that's the least one.
23:13:44 <satan> int-e: right, in this case, only one, thus its the least by default
23:13:59 <int-e> (which is a relief because it saves us from looking closer at what 'least' means here)
23:14:01 <satan> but say we had to find the least fixed point of foldr or something, that would be non-trivial, right?
23:14:01 <Heffalump> any strict function has _|_ as its least fixed point I assume
23:14:18 <Heffalump> normally I think fix calculates the greatest fixed point
23:14:21 <Cale> Botty: I understand why most of the industry isn't using Haskell, but the segment of it that is using off-the-wall languages is a bit of a mystery
23:14:47 <Botty> oh. like the users of python and ruby etc
23:14:50 <Botty> ?
23:14:55 <jgrimes> > (\x -> (\y -> y) (\z -> z)) (\u -> u)::Int -> Int -- Which reduction order is chosen for this?
23:14:56 <Cale> Botty: yeah
23:14:56 <int-e> satan: if _|_ is a fixed point, that is the least one. that's another very common one.
23:14:56 <lambdabot>  <Int -> Int>
23:15:15 <int-e> satan: note that for your f, f _|_ = [True] because of lazyness.
23:15:20 <Heffalump> jgrimes: by what?
23:15:25 <dons> Cale: yeah. its a bit weird. lightly-typed languages have a mind share I suspect. and so does OO. so if you have both...
23:15:37 <satan> int-e: oh so its not [true] then
23:15:43 <Botty> hmm, well, the learning curve is fairly high.  haskell takes purity to an extreme.  A functional language that loosened up a bit without sacrificing too much for the sake of the user might be effective
23:15:44 <int-e> > fix (1+) -- 1 + _|_ = _|_  so this is _|_
23:15:45 <lambdabot>  Exception: <<loop>>
23:16:00 <satan> since we could call f _|_ and it would ignore the arg and return [True] anyway, is that the idea?
23:16:02 <jgrimes> Heffalump, not sure I understand your question :/
23:16:11 <Cale> satan: yeah
23:16:22 <satan> ah ok, makes sense
23:16:42 <int-e> the really interesting cases are things like
23:16:45 <Cale> satan: in order to have a least fixed point which is nontrivial, a function must return something not entirely undefined when passed an undefined value
23:16:45 <int-e> > fix (1:)
23:16:45 <Botty> mainly i think its syntax.
23:16:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:16:47 <satan> int-e: you said, if _|_ is a fixed point etc..etc..., so how can I tell if _|_ is a fixed point for a function?
23:16:54 <int-e> > fix ((1:) . map (1+))
23:16:55 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:17:12 <Cale> > fix ((0:) . scanl (+) 1)
23:17:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:17:15 <Cale> hehe
23:17:17 <int-e> satan: simple, if f _|_ is _|_, then _|_ is a fixed point.
23:17:27 <satan> int-e: oh ok, gotcha
23:17:30 <jgrimes> there are two different reductions for that expression, and even though they lead to the same result via church-rosser property, I was wondering how it would be reduced after being evaluated as haskell
23:17:33 <int-e> satan: (_|_ = undefined, if that confuses you)
23:17:43 <Cale> note that (1:) _|_ = 1 : _|_ and not _|_
23:17:56 <Botty> allowing stuff like point-free form makes the code more concise, but means you need to know more to understand them - the types of the functions used
23:17:58 <Heffalump> jgrimes: well, Haskell reduction is outermost
23:18:01 <lispy> > 1: undefined
23:18:02 <lambdabot>  Undefined
23:18:04 <int-e> satan: or divergence or some other sort of error. Haskell's semantic doesn't usually distinguish between all these.
23:18:05 <satan> Cale: right
23:18:10 * Heffalump disappears
23:18:18 <int-e> lispy: hmm, well
23:18:23 <Cale> lispy: that's only because you're trying to print it all :)
23:18:25 <int-e> > take 2 $ show (1:undefined)
23:18:26 <lambdabot>  "[1"
23:18:34 <lispy> > head $ 1 : undefined
23:18:35 <lambdabot>  1
23:18:41 <satan> int-e: i see
23:18:48 <Pseudonym> The thing about Haskell is that every function with type a -> a has a least fixpoint.
23:18:52 <lispy> > length $ 1 : undefined
23:18:53 <Pseudonym> Sometimes that's bottom.
23:18:53 <lambdabot>  Undefined
23:19:08 <satan> oh, EVERY function with that type eh
23:19:10 <Pseudonym> And fix always finds the least fixpoint.
23:19:12 <Pseudonym> Yes.
23:19:16 <Pseudonym> > fix (1+)
23:19:17 <lambdabot>  Exception: <<loop>>
23:19:32 <satan> so i just type in fix f, where f is the function and bob's my uncle
23:19:38 <lispy> > take 10 . map length . group . fix $ show
23:19:39 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
23:19:41 <int-e> satan: the proof is constructive: fix f = f (fix f)  finds the least fixed point.
23:19:43 <Pseudonym> That's the least number omega such that omega = 1 + omega
23:19:46 <int-e> satan: yep
23:20:10 <satan> but if i was to try to solve it on paper or whatever to understand the theory, how would i do it? or is there no point to that?
23:20:21 <Pseudonym> Actually, that's a very good idea.
23:20:38 * lispy goes insane implementing all these tests for his little compiler
23:20:48 <Pseudonym> It might help if you use a different lattice to test this stuff out, though.
23:20:49 <int-e> satan: use that definition of fix and try to evaluate f based on that.
23:21:12 <int-e> for example, fix (const 1) = const 1 (fix (const 1)) = 1
23:21:26 <Cale> lisppaste2: url
23:21:27 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:21:35 <int-e> fix (1:) = 1:fix (1:) = 1:1:fix (1:) = 1:1:...
23:21:48 <satan> int-e: but won't that inner fix(const 1) on the rhs recurse endlessly
23:22:00 <lisppaste2> Cale pasted "definedness tester" at http://paste.lisp.org/display/28536
23:22:00 <satan> or is the idea that const 1 has it as an argument, ignores it and gives us 1
23:22:02 <int-e> satan: const doesn't use its second argument, so it won't
23:22:13 <satan> ok cool
23:22:28 <int-e> satan: understanding fix and understanding lazy evaluation is probably the same thing.
23:22:38 <satan> ohhh so thats how it ties in
23:22:41 <satan> man, i'm slow
23:22:48 <Cale> *Main> map def (1 : undefined : 2 : 3 : error "end!")
23:22:48 <Cale> Defined:Undefined:Defined:Defined:Undefined
23:23:14 <Cale> of course, it doesn't quite catch nontermination :)
23:23:21 <Pseudonym> Version 2.0, right?
23:23:30 <Cale> hm?
23:23:35 <Cale> maybe? :)
23:23:38 <Pseudonym> You'll be doing that in version 2.
23:23:44 <Cale> ah, yeah
23:23:49 <satan> cool, thanks for your help guys :)
23:24:13 <Pseudonym> satan: Just so you know, the proof that fix produces the least fixpoint is constructive.
23:24:20 <Pseudonym> And it's really easy to understand.
23:24:26 <satan> oh ya?
23:24:29 <Pseudonym> Yeah.
23:24:47 <Pseudonym> It's based on lattice theory, but here's what you need to know:
23:24:50 <satan> is it one of those domain theory proofs with the rectangular U's and what not
23:25:02 <Pseudonym> Yup, but you can think of it as set theory if it helps.
23:25:15 <Pseudonym> Where a rectangular U is union.
23:25:21 <satan> ok, i have so many questions about that stuff too, god :S
23:25:25 <Pseudonym> Ah.
23:25:31 <Pseudonym> Maybe we'll skip it for now, then.
23:25:40 <satan> like, partial orders? chained partial orders? pointed ones?
23:25:42 <Pseudonym> The thing here is that Haskell values fall in a lattice.
23:25:47 <satan> i read articles on it and stuff
23:25:49 <Pseudonym> bottom is the least element.
23:25:52 <satan> right
23:26:01 <Pseudonym> So you can think of Bool, for example, as:
23:26:03 <satan> so thats why its the least bound for most datatypes, right
23:26:07 <Pseudonym> bottom < False, bottom < True
23:26:12 <satan> right
23:26:25 <Pseudonym> That's the sense in which fix produces the "least" fixpoint.
23:26:29 <Cale> btw, I'm not sure if I posted this link here earlier, but this page has some books which are quite possibly of interest to Haskellers
23:26:31 <Cale> http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html
23:26:34 <lambdabot> Title: Books, http://tinyurl.com/yj25mf
23:26:58 <Pseudonym> ?google scott domain
23:27:02 <lambdabot> http://en.wikipedia.org/wiki/Scott_domain
23:27:07 <Pseudonym> Haskell values form Scott domains.
23:27:18 <goltrpoat> cale:  excellent, thanks
23:27:30 <jgrimes> Cale, nice
23:27:44 <satan> Pseudonym: ok scott domains, gotcha
23:28:24 <dfranke> Gtk is the most Greenspunned API I've ever seen.
23:28:43 <Pseudonym> Scott domains form the backbone of denotational semantics, which is what the Haskell report uses to describe Haskell's semantics.
23:28:47 <Cale> dfranke: what exactly does that mean?
23:29:01 <satan> Pseudonym: ah ok
23:29:03 <dfranke> Cale, are you familiar with Greenspun's tenth law?
23:29:15 <Cale> not really
23:29:24 <Cale> Does he have a list somewhere?
23:29:28 <Pseudonym> GTK's API is no worse than Xt, surely.
23:29:47 <dfranke> "Any sufficiently complicated C or Fortran program contains an ad-hoc, informally-specified bug-ridden slow implementation of half of Common Lisp."
23:29:52 <Pseudonym> They're equally ugly ways to do OO programming in C.
23:30:10 <Cale> ah, right
23:30:14 <dfranke> Cale, and he doesn't have any first through ninth laws.
23:30:21 <dfranke> just a tenth one.
23:30:23 <sieni> as if OO programming was ever non-ugly
23:30:27 <Cale> why is it the tenth then?
23:30:38 <dfranke> because he thought it sounded better that way.
23:30:41 <Pseudonym> sieni: And your problem with Erlang is...?
23:30:43 <Cale> heh
23:30:58 <int-e> Cale: There are many possibilities. How about "The first 9 laws are left as an excercise to the reader."?
23:31:05 <dfranke> sieni, that's not fair.  Smalltalk and Ruby aren't ugly.
23:31:08 <Cale> I should email him and demand laws 0 through 9.
23:31:33 <Pseudonym> Smalltalk is kinda ugly by today's standards,.
23:31:41 <Pseudonym> I think it's the archaic syntax.
23:31:51 <Pseudonym> ML is ugly in the same sense.
23:32:12 <dfranke> yeah, but syntactic ugliness is pretty superficial.
23:32:13 <Botty> Hah, bracket languages are especially ugly in that sense...
23:33:30 <int-e> to the uninitiated, some Haskell code looks like line noise (and I'm not talking about the IOHCC, just seeing \, ~, @, $, ., : and so on all over the place is confusing enough)
23:33:34 <Botty> then again, bracket languages are today's standard.
23:33:46 <goltrpoat> there are things i hate about smalltalk, and there are things that are very nifty about it
23:33:48 <Botty> I agree with int-e
23:33:55 <goltrpoat> (i only have very minimal experience with it though)
23:34:06 <Botty> i think smalltalk's idea is very nifty
23:34:14 <Botty> syntax not so nifty
23:34:20 <dfranke> The prettiest languages syntactically speaking are Haskell, Python, and shell.
23:34:22 <goltrpoat> i think there was a strongly typed version of it floating around somewhere, might be worth checking out
23:34:24 <kowey> has anybody looked at J syntax?
23:34:53 <Cale> dc is awesome for line-noise looking code. You can even have a variable named <newline>
23:35:02 <dons> the 'end' stuff in ruby is superficially ugly, and old fashioned. I find it a little disconcerting
23:35:11 <Eidolos> kowey: Yes! It's wild.
23:35:23 <sieni> Well, anything in python sucks more than a russian hooker with syfilis
23:35:25 <Eidolos> (and I'm a Perl aficionado)
23:35:30 <Cale> or any of the control characters :)
23:35:38 <dfranke> dons, yeah, that's one thing that bothers me about Ruby.  If you're going to have significant whitespace it's stupid to do it half-way.
23:35:39 <int-e> dc is great. :)
23:35:39 <kowey> i wonder if me looking at J is how the uninitiated look at Haskell... uhh wha?
23:35:55 <dons> dfranke: yeah. its a bit weird, isn't it.
23:36:22 <dfranke> dons, significant whitespace is one of those things that sounds wretched until you actually try it.
23:36:54 <Cale> kowey: On the contrary, upon viewing qsort for the first time in Haskell, without knowing any Haskell, it actually caused me to understand quicksort :)
23:37:06 <lispy> Cale: me too
23:37:21 <kowey> :-D
23:37:23 <Botty> the only problem with signifigant whitespace is when you have an editor that doesn't type it for you :)
23:37:23 <dons> i always just think: when i write by hand, i use signficant whitespace all the time, and then it doesn't seem so odd
23:37:47 <dfranke> actually, although Haskell was my first language that used it, I realized from using Lisp that it wasn't a bad idea.
23:37:58 <dons> heh
23:38:03 <dfranke> Because lisp is totally unreadable if it's not indented properly.
23:38:13 <lispy> I think whitespace and make both have annoying significant whitespace but python and haskell are fine :)
23:38:35 <dfranke> so since you can't get away with taking any liberties anyway, significant whitespace doesn't really have any drawbacks.
23:39:26 <Cale> I think that Haskell does meaningful whitespace better than Python
23:39:29 <kowey> i like how one of the motivations behind python whitespace was so that people couldn't have where-do-i-put-the-bracket wars
23:40:35 <jajs> i'm writing my first serious haskell program, does anyone have a suggestion on how to test a parsec parser producing an abstract syntax tree ? HUnit ? QuickCheck ?
23:40:36 <Cale> In Haskell, you can put the brackets in, but it's rather rare for people to actually do so. So it's really a nicely convenient apology to throw at people who complain about whitespace sensitivity :)
23:41:10 <lispy> jajs: yes, both should be helpful
23:41:11 <Cale> jajs: hmm, I don't know what QC properties I could come up with for that :)
23:41:14 <lispy> jajs: they are not disjoint :)
23:41:15 <Cale> maybe some
23:41:26 <lispy> jajs: er, well mutually exclusive i mean
23:41:35 <Cale> but you don't want the input strings to be completely random of course :)
23:41:41 <dfranke> Cale, most useful would be what nodes can have what parents.
23:42:00 <dfranke> Cale, and what nodes can have what number of children.
23:42:07 <lispy> Cale: well, if you were parsing numbers you want to get back what you started with in same cases, it makes a great property for parts of the grammar, i've done it to great success
23:42:21 <Cale> hmm, yeah, that's true
23:43:15 <lispy> usually when i write quick check properties for parsec i round-trip things
23:43:52 * lispy hopes that made sense
23:44:00 <Cale> yeah, you need to write a nice show instance for your AST for that
23:44:29 <lispy> yeah, sometimes i do that part by hand
23:44:29 <Cale> If that's what you mean? :)
23:44:48 <lispy> like restrict the porperty enough to where it's not a total PITA
23:45:05 <lispy> i guess it's half art
23:45:07 <Smokey`> anyone know where I can find documentation on the GHC win32 API bindings?
23:45:25 <lispy> Smokey`: if you installed a binary of ghc it should be on your computer
23:45:46 <lispy> Smokey`: for some reason i've had a hard time finding it with google though
23:46:31 <satan> how do i type the triple equal to? the one with 3 horiz lines?
23:46:47 <jajs> lispy, you mean that i should write a show instance that produce valid code ? and check if "show (parseExpr code) == code" ? that sounds nice :-)
23:47:42 <lispy> jajs: yeah, it doesn't even have to be the "real" show instance, you could make a new class, class QuickCheckShow a where qcshow a = ...
23:49:16 <satan> > let xs = head xs : tail xs in xs
23:49:17 <lambdabot>  Add a type signature
23:49:37 <satan> to xs?
23:49:47 <lispy> yeah
23:49:53 <lispy> i mean, what is that type?
23:50:19 <lispy> ?type \xs -> head xs : head xs
23:50:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:50:20 <lambdabot>    Expected type: [[a]]
23:50:20 <satan> i dunno, it says: What is the value of the following haskell expression: let xs = head xs : tail xs in xs ?
23:50:32 <satan> when i type it into ghci, i get [
23:50:33 <lispy> ?type \xs -> head xs : tail xs
23:50:34 <lambdabot> forall a. [a] -> [a]
23:50:44 <Smokey`> lispy: thanks heaps for that, just assumed it'd be online smewhere, never occured ot me it would've come with the install :)
23:51:02 <int-e> satan: that depends on xs
23:51:05 <lispy> Smokey`: yw, i know know because i've been there and frustrated too :)
23:51:23 <satan> int-e: wouldnt it just give xs? since head xs : tail xs is xs, right?
23:51:46 <lispy> > ( \xs -> head xs : tail xs) [1..2]
23:51:47 <int-e> satan: ok, let's turn it around: when does  head xs : tail xs  not equal xs?
23:51:47 <lambdabot>  [1,2]
23:51:59 <lispy> > ( \xs -> head xs : tail xs) []
23:52:00 <lambdabot>  Add a type signature
23:52:06 <lispy> > ( \xs -> head xs : tail xs) ([]::[Int])
23:52:08 <lambdabot>  Exception: Prelude.head: empty list
23:52:12 <jajs> lispy, Cale : thanks for your help
23:52:14 <int-e> satan: because most of the time, it does
23:52:19 <satan> int-e: not sure hmm
23:54:00 <satan> wait, when its an infinite list?
23:54:13 <int-e> na, it works for infinite lists.
23:54:25 <satan> nope, for some reason i thought we had tail xs : head xs
23:54:30 <satan> sorry, don't know then
23:54:40 <int-e> lispy gave it away actually
23:55:38 <lispy> satan: the clue is that head and tail are not total functions
23:55:44 <lispy> > head [] :: Int
23:55:45 <lambdabot>  Exception: Prelude.head: empty list
23:55:50 <lispy> > tail [] :: [Int]
23:55:52 <lambdabot>  Exception: Prelude.tail: empty list
23:55:58 <int-e> there are 2 cases where the result differs from xs: _|_ (the result is _|_:_|_) and [] (the result is _|_:_|_ again)
23:56:01 <satan> by total functions, you mean...
23:56:10 <int-e> the empty list should be the obvious one
23:56:22 <lispy> satan: defined for all values of the type they take
23:56:27 <satan> ok
23:57:13 <int-e> the fact that _|_:_|_ and _|_ are different is another consequence of lazy evaluation
23:57:29 <int-e> > length (take 1 undefined)
23:57:30 <lambdabot>  Undefined
23:57:35 <int-e> > length (take 1 (undefined:undefined))
23:57:36 <lambdabot>  1
23:57:42 <satan> how so? it sees the first bottom and then gives up, well depending on the function
23:57:46 <earthy> int-e: not really. it is a consequence of non-strictness
23:58:08 <int-e> earthy: ok
23:58:42 <goltrpoat> out of curiosity, why isn't there a 'puts' in MonadState that takes an injection?  there's a 'gets' that takes a projection
23:58:58 <satan> so what would the value of that expression be then?
23:59:01 <int-e> satan: I just gave an example - length . take 1  distinguishes between the two values.
23:59:12 <satan> it depends on xs...but no information about xs is given
23:59:26 <satan> int-e: right, awesome
23:59:27 <int-e> xs, unless xs is undefined or the empty list.
23:59:36 <lispy> satan: all my xs live in texas...
23:59:43 <satan> heh :)
