00:00:05 <satan> cool, there are 2 more like it, i'm gonna try em
00:00:06 <int-e> satan: I'd say that the answer can depend on xs, nothing wrong with that.
00:01:27 <Bobstopper> @pl \fp -> (writeFile fp) . show
00:01:27 <lambdabot> (. show) . writeFile
00:01:30 <satan> ok, so for this, the mpty list won't work as well:  let ys = head ys : ys in ys
00:01:49 <satan> since head ys will generate that exception
00:01:59 <int-e> yes
00:02:04 <int-e> well, hmm
00:02:07 <Smokey`> lispy: do you know where the Win32 library examples are? (I know I've seen them somewhere, but I dont see them in the docs...)
00:02:17 <int-e> you get a fun result for the empty list actually :)
00:03:38 <lispy> Smokey`: no, i didn't know we had any
00:03:46 <satan> > ( \ys -> head ys : ys) [1..2]
00:03:47 <lambdabot>  [1,1,2]
00:03:52 <satan> > ( \ys -> head ys : ys) []
00:03:52 <lambdabot>  Add a type signature
00:03:56 <int-e> > let ys = head ys : ys in map (const 2) ys
00:03:57 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
00:04:07 <lispy> ?google haskell win32 _darcs
00:04:10 <lambdabot> http://darcs.haskell.org/packages/Win32/_darcs/
00:04:11 <lambdabot> Title: Index of /packages/Win32/_darcs
00:04:17 <lispy> Smokey`: try there ^^^
00:04:27 <lispy> er well up a directory level
00:04:33 <int-e> > ( \ys -> head ys : ys) [] :: [Int]
00:04:34 <lambdabot>  Exception: Prelude.head: empty list
00:04:36 <lispy> you probably don't need to be in _darcs :)
00:04:43 <int-e> > length $ (( \ys -> head ys : ys) [] :: [Int])
00:04:44 <lambdabot>  1
00:05:03 <satan> does the $ after length just add another set of brackets?
00:05:14 <int-e> the $ is superfluous
00:05:24 <int-e> @type ($)
00:05:25 <lambdabot> forall b a. (a -> b) -> a -> b
00:05:33 <int-e> it's an infix operator actually, nothing magical
00:05:36 <lispy> satan: that's an okay way to think of it
00:05:49 <lispy> satan: but it won't always be correct :)
00:05:57 <satan> ah k, well, not to get sidetracked or anything :)
00:06:25 <satan> so what funky result will [] generate with that expression? seems to give the exception, doesnt it?
00:06:40 <int-e> well, the second case didn't, why?
00:07:07 <satan> because the head ys was counted as an element?
00:07:59 <int-e> yes, but not evaluated.
00:08:44 <int-e> it's only the head of the list that's undefined, not the whole list.
00:08:59 <int-e> (which is short, it only has one element)
00:09:58 <int-e> anyway. this is a bit subtle and often it's safe to gloss over it.
00:10:07 <satan> wow these questions are all so tricky
00:10:34 <satan> so it evaluates to an exception unless some other function lazily evaluates it?
00:10:45 <int-e> So my guess is they're not meant to be done in that much detail.
00:10:53 * lispy would like to note that one of the really cool and really unique thinks about #haskell is happening right now
00:11:05 <int-e> hmm, it's better to turn that around, it generates an exception if another function uses the value.
00:11:17 <satan> int-e: ah right, much better
00:11:24 <satan> lispy: whats that?
00:11:46 <satan> and the 3rd and final one heh:  let zs = head zs : 1 : zs in zs
00:12:17 <lispy> satan: we're using lambdabot as a teaching tool
00:12:28 <satan> > ( \zs -> head zs : 1 : zs) [1..2]
00:12:28 <lispy> satan: you're asking questions, int-e and others are trying to help
00:12:29 <lambdabot>  [1,1,1,2]
00:12:45 <satan> lispy: true, true and i'm grateful
00:12:54 <satan> but its hardly uncommon anymore, is it? i almost live here now lol
00:13:05 <int-e> > (\zs -> head zs : 1 : zs) undefined !! 1
00:13:06 <lambdabot>  1
00:13:21 <lispy> satan: it's not uncommon in #haskell, but does this happen in ##c, #java or #lisp?
00:13:30 <yts> excuse me, what's the type of
00:13:40 <yts> fb (Left a) = a
00:13:40 <yts> fb (Right b) = b
00:13:47 <Smokey`> lisppy: http://www.dcs.gla.ac.uk/~sof/hello.lhs
00:13:54 <lispy> yts: Either a a -> a
00:13:56 <Smokey`> lispy even...
00:13:59 <Cale> yts: you know that you can ask ghc that, right? :)
00:14:10 <satan> lispy: you're right, but i've never been there, but you guys are super helpful for sure
00:14:13 <Cale> (just to check :)
00:14:23 <yts> i use :type fb
00:14:27 <satan> int-e: so you indexed undefined's 1st element?
00:14:27 <Cale> yeah
00:14:39 <Cale> or just :t will do :)
00:14:42 <yts> so there is no possible to define union type
00:14:42 <gour> Smokey`: huh, comparing it with gtk2hs, it is ugly
00:14:43 <lispy> Smokey`: what is that?
00:14:48 <int-e> satan: no, the result of your function defined to undefined
00:15:00 <lispy> Smokey`: ie is so stupid it tried to open it in ghci
00:15:00 <Cale> yts: in a sense, Either a b is a kind of union, but yeah
00:15:10 <Smokey`> gour: well no shit, it's straight Win32 API, where as gtk is a wrapper around the OS-level window libraries
00:15:12 <lispy> Smokey`: so i can't really look it at it :(
00:15:15 <yts> ok, thanks ~ i see
00:15:18 <int-e> satan: and no matter what the function argument is, the result will always be a list whose 2nd element is 1.
00:15:32 <gour> Smokey`: right, but life is too short to deal with bare bones :-)
00:15:42 <Smokey`> lispy: link to an example 'hello world' program, creates a window (using Win32 PAI bindings), and writes some text.
00:15:50 <lispy> Smokey`: ah, cool
00:16:01 <satan> int-e: oh really hmm
00:16:08 <Smokey`> gour: true, but sometimes you need bare bones... (very rarely though
00:16:30 <satan> int-e: and [] won't generate an exception for head zs again
00:16:32 <int-e> satan: you can deal with that equationally, (\zs -> head zs : 1 : zs) undefined = head undefined : 1 : undefined = undefined : 1 : undefined
00:16:32 <Smokey`> gour: it's more the fact I've been dealing with Win32 API for a good 4 years, so I'm quite familiar with it, where as GTK i've dealt with for ~2 years tops... on and off
00:16:43 * gour prefer to not deal with it, if possible
00:16:46 <int-e> satan: unless the argument is used, right.
00:16:56 <int-e> satan: err
00:17:07 <int-e> satan: unless the head's value is used somewhere, yes.
00:17:19 <satan> right ok
00:17:26 <Smokey`> gour: I've recently been dealing with .NET WinForms, blessing to work with :)
00:17:31 <gour> Smokey`: is vista bringing new api?
00:17:40 <Smokey`> gour: vista will be using .NET 3.0 iirc.
00:17:43 <Smokey`> so yeah, WinForms.
00:17:48 <satan> int-e: thanks for your help
00:17:56 <int-e> you're welcome
00:18:17 <gour> Smokey`: seeing that vista license prevents one to run vmware, i say. "thank you very much!"
00:18:42 <Smokey`> gour: heh. :P  alot of licenses prevent alot of things, and alot of people don't give a shit :)
00:19:15 <gour> Smokey`: right, but i think for me it means one platform less to bother with :-)
00:19:30 <Smokey`> gour: aye, if I had the choice I wouldn't support anything but *nix :)
00:19:34 <gour> Smokey`: Mac OSX & Linux will suffice
00:20:14 <gour> Smokey`: i understand, same here, but my friend will probably not switch directly to Linux, so osx is there too
00:20:53 <gour> Smokey`: so gtk2hs || wxwidgets are not options for you?
00:21:06 <lispy> gour: how can they legally prevent that?
00:21:30 <lispy> gtk is not windowsy enough if you're trying to support that platform, IMO
00:21:53 <lispy> and wxhaskell isn't full blown wxwidgets
00:22:23 <gour> lispy: http://discuss.joelonsoftware.com/default.asp?joel.3.403176.33
00:22:25 <kzm> @seen igloo
00:22:28 <lambdabot> Title: The Joel on Software Discussion Group - Most versions of Vista will be illegal t ..., http://tinyurl.com/vbkt5
00:22:28 <lambdabot> igloo is in #darcs, #haskell and #ghc. I last heard igloo speak 6h 51m 33s ago.
00:22:38 <lispy> i was looking into making gtk2hs more native on windows but i never finished it
00:22:53 <kzm> Hmm... my bug report got changed to milestone _|_.  It sounds like bad news.  Is it bad news?
00:23:10 <kzm> Or just a funky code name for ghc 6.8?
00:24:02 <gour> lispy: that would be good for short-term. on long-run, it's better to make gtk2hs rock on linux & osx
00:24:18 <goltrpoat> gour:  "prevents one to run vmware" ?  in what sense?
00:24:44 <gour> goltrpoat: "The only versions that you'll be allowed to run this way are Windows Vista Business and Ultimate."
00:25:05 <gour> goltrpoat: from url above
00:25:07 * lispy finds himself disgusted with MS, yet again
00:26:40 <gour> my teacher (hard win32 user) is moving to osx or linux, so it is getting serious ;)
00:26:51 <goltrpoat> gour:  if you follow the link to thurrott's site, he seems to be of the opinion that no one with any reason to run vista in a VM would be running vista home basic
00:26:58 <goltrpoat> i don't see how it's an issue, in that light
00:27:50 <int-e> goltrpoat: security researchers have a strong claim though
00:27:53 <gour> well, i run xp home under vmware and it is more than enough for my win32 needs. why would i want something more in vista?
00:29:02 <gour> goltrpoat: the end-result would be i'd stop using all win stuff and solve the problem for ever
00:29:27 <lispy> but it's hard to play all the cool video games without windows
00:29:40 <lispy> and, i'll be forced to use it at work
00:29:42 * gour has need for only one win32 app, but with dotReader it will be ended (hopefully)
00:29:44 <lispy> at least until i find a new job
00:30:07 <gour> lispy: start looking for a new one, asap :-)
00:30:24 <lispy> yeah, i like the one i have, they let me use haskell sometimes :)
00:30:32 * gour has no time for gaming
00:30:56 <gour> lispy: then preach them to upgrade OS :-)
00:30:57 <lispy> i was going to game today...but this compiler that i'm writing instead of doing school work is getting in the way :)
00:31:08 <lispy> gour: our software is very tied to windows...
00:31:16 <goltrpoat> -shrug- it just seems like every time a new version of windows comes out, there's this whole alarmist choir that pops up during the year before final release
00:31:18 <lispy> gour: which is sad, because about 5 years ago it ran on unix or windows
00:32:08 <lispy> goltrpoat: i feel the same way now that i felt about xp then...the EULA is evil
00:32:10 <gour> goltrpoat: well, considering the 'freedom' put on those putting together their own PCs, it's not true
00:32:25 <goltrpoat> and generally, when it comes out, it turns out that it doesn't really give you cancer, sell your electricity to the north koreans, and eat your hotpockets.
00:32:45 <gour> here many people are doing such thing, i'm one of them, regularly upgrading my box by changing hardware
00:33:40 <gour> goltrpoat: and, fortuntely, there is choice, so no scare here :-)
00:35:28 <goltrpoat> seems like the trick to upgrading your PC is to not swap out the motherboard and the hdd with the primary partition on it at the same time
00:35:29 <goltrpoat> heh
00:36:01 <goltrpoat> apparently, if you swap out the motherboard first, boot it up, shut it down, swap out the harddrive, boot it up, shut it down, swap out everything else, it'll be ok with it
00:37:01 <goltrpoat> either that, or you just do whatever you want to it and reactivate the license.  thurrott, again, says it's the same deal as XP, but the algorithm is less strict about determining what constitutes a new machine.
00:37:53 <gour> why bother with such things?
00:38:36 <goltrpoat> dunno.  i'm not trying to convince anyone to do anything in particular.
00:40:56 <lispy> hmm...my equality tester is broken...
00:41:32 <lispy> ah, i know wyh..
00:44:50 <Bobstopper> @pl \fp -> get >>= lookup fp
00:44:50 <lambdabot> (get >>=) . lookup
00:50:16 <gour> goltrpoat: such copy-protection schemes are just botheration for legal users
00:56:26 <goltrpoat> i'd agree that copy-protection schemes are usually just a nuisance for legal users.  in this case, legal users can reactivate their license, while illegal users can't.
00:56:54 <goltrpoat> unless you're mortally terrified of the telephone, or rebuild your machine nearly from scratch once a week, i just fail to see how this is a huge concern.
00:56:59 <edwardk> i have actually had to go and return several games in the last few years due to copy-protection schemes that were just broken
00:57:26 <gour> but don't worry, vista will be cracked too,so what's the use
00:57:28 <edwardk> but the windows one is just annoying ;)
00:58:34 <gour> one copy-protection prevented me to install app on win4lin although i was legal user
00:58:54 <gour> so, just botherarion...
00:59:10 <edwardk> and in the case of the windows telephone thing, i'm not afraid of the telephone, but the indian tech support employees on the other end with their disturbingly american sounding names scare me ;)
00:59:27 <goltrpoat> edwardk:  better yet -- a publisher i've worked with shipped about 30k units of a title with the wrong serials on the box.
00:59:43 <edwardk> lovely
01:00:02 <edwardk> that had to be a support nightmare
01:00:17 <goltrpoat> hehe i'd imagine
01:02:09 <edwardk> ok, how disturbing do you think folks would find a language with an unspecified default evaluation order where you can enforce need/value semantics with an appropriate comonad or monad?
01:03:15 <edwardk> it seems i'm heading that way, i'm just leery that i'm going to wind up with the worst of both worlds
01:03:31 <edwardk> the evaluation order stuff APL folks lived with for years I guess.
01:04:44 <goltrpoat> is it by need or by value by default?
01:06:03 <edwardk> its whatever the compiler thinks it can make run faster, if you don't stick in a monad to force order or a comonad to force laziness you can't be sure of either
01:06:18 <edwardk> but it can split up your task into chunks, distribute them around or do whatever it wants
01:07:09 <edwardk> so lazy fib by default won't work, but can be run inside the lazy comonad, strict operations can be done inside a cbv monad.
01:07:22 <goltrpoat> hmm
01:07:39 <edwardk> that way those weird strided lists i want to use can be used
01:08:19 <edwardk> its also useful to try to make regions work better
01:08:30 <edwardk> coz i can try to glom together certain operations
01:08:42 <goltrpoat> it might get remarkably difficult to reason about what the code is actually doing
01:09:00 <goltrpoat> without specifying the evaluation strategies all over the place
01:09:08 <edwardk> well, the idea is if you need to know evaluation order, specify it
01:09:49 <edwardk> if not, let the compiler figure it out. most finite always convergent cases you should be happy with either
01:10:05 <goltrpoat> i'd flip it -- have it do one or the other by default, and let the user specify sections within which the compiler gets to figure it out
01:10:23 <edwardk> unfortunately i need 'neither' for most of my optimizations =/
01:10:28 <goltrpoat> ah
01:10:51 <edwardk> hence why i want it to be my default case
01:12:27 <goltrpoat> i guess the main thing that's putting me off is that figuring out how to optimize lazy code is hard as it is, without random parts of it being eager
01:12:27 <goltrpoat> hehe
01:12:37 <edwardk> heh
01:12:50 <edwardk> yeah, thats why i want an easy to use laziness comonad
01:12:56 <goltrpoat> -nod-
01:13:57 <edwardk> and a lot of the problems with optimizing lazy code has to do with its rampant memory consumption in the face of under-strictness.
01:15:00 <edwardk> my main method to work around that is to offer up uniqueness types where appropriate and let relevance/strictness analysis help avoid thunk creation
01:16:07 <lispy> Cale: are you around?
01:16:17 <edwardk> which already plays around with the evaluation order a bit. haskell offers seq which silently breaks the correctness of half of its fusion rules, anyways ;)
01:16:19 <foxy> Hi, I got a bunch of bad eta expansion messages when compiling ghc6.6 from source on linux
01:16:21 <foxy> Bad eta expand
01:16:23 <foxy>     __coerce ()
01:16:24 <foxy>     (CmmParse.zgzg {- v rq3B -}
01:16:45 <lispy> Cmm?
01:16:49 <lispy> are you using C--?
01:17:04 <foxy> dunno, just a standard ./configure ; make
01:18:12 <goltrpoat> edwardk:  don't you potentially end up with non-terminating reductions if you start trying "random" combinations of strict and non-strict?
01:19:51 <goltrpoat> i guess branch and bound comes in handy there again though
01:20:21 <edwardk> goltr: haven't found one yet, but its quite plausible.
01:20:44 <lispy> edwardk: do you remember the CodeGen monad that Cale and you helped me write?
01:20:55 <edwardk> lispy: yeah
01:21:02 <lispy> edwardk: i need to extend it now so that it can track an environment of variable bindings, what would you suggest?
01:21:10 <goltrpoat> well, the point is that with call by need, there are applicative orders that are non-terminating
01:21:24 <edwardk> you made it a StateTover a writer right
01:21:25 <edwardk> ?
01:21:31 <lispy> edwardk: yeah
01:21:38 <edwardk> just add to the contents of the state you carry around with StateT
01:21:40 <lispy> edwardk: would it help if i posted the code?
01:21:40 <goltrpoat> and adding strictness in random places breaks the leftmost innermost thing
01:21:41 <edwardk> and get and put it
01:22:07 <lispy> actually, i'm wrong
01:22:13 <lispy> newtype CodeGen a = CodeGen (WriterT [Instruction] Unique a)
01:22:13 <lispy>       deriving (Functor, Monad, MonadWriter [Instruction])
01:22:28 <edwardk> goltr: it is sound in the absence of pointed computations as far as i can see
01:23:07 <edwardk> goltr: if no reduction path can run forever, then you can avoid the non-termination property
01:23:26 <edwardk> ah
01:23:26 <goltrpoat> pointed computations?  indirections you mean?
01:24:35 <lispy> edwardk: i would imagine i need to now do something like newtype CodeGen a = CodeGen (ReaderT (WriterT [Instruction] Unique) a)
01:25:02 <lispy> edwardk: and then use reader for handling the environment
01:25:25 <edwardk> no pointed referring to the fact that an expression can evaluate out to bottom. i may diverge if my computation involves something that would evaluate out to bottom that i would never reach from a call-by-value strategy (say for instance of the value evaluation prematurely ends my program before it reaches the non-terminating body) or a call-by-need bottom that is hidden in an argument, so i'll likely run into either bottom if its pre
01:26:29 <edwardk> but if all reduction paths are finite then i'll eventually stop computing regardless of the path i choose
01:26:39 <edwardk> lispy: ah ugly.
01:26:57 <lispy> edwardk: suggestions?
01:27:51 <edwardk> newtype CodeGen a = CodeGen (WriterT [Instruction] (State Foo) a) deriving (MonadWriter, Functor, Monad)
01:28:08 <lispy> why State?
01:28:08 <edwardk> then implement the Unique monad's behavior inside of your state
01:28:12 <edwardk> and add your environment to state =)
01:28:33 <edwardk> hell
01:28:39 <lispy> but then the state is hard to think about...(at least for me)
01:28:41 <edwardk> you can write your writer as more mutable state
01:28:42 <edwardk> =)
01:29:54 <lispy> heh, stupid kind errors
01:30:38 <edwardk> type CodeGen a = State MyState a; data MyState = MyState { uniqueVar :: [[String]]; env :: Env; output :: [Instruction] }
01:30:53 <edwardk> or StateT MyState IO and store IOrefs in the MyState
01:31:57 <goltrpoat> im trying to remember what the issue what with non-terminating reduction strategies.  i thought there was another caveat, but i can't come up with an example
01:32:07 <goltrpoat> what with=was with
01:32:13 <edwardk> goltr: lots of maps and folds, etc are non-pointed given finite lists.
01:32:29 <goltrpoat> -nod-
01:34:14 <edwardk> adding fixpoints mucks it up, but all of the calculi of the lambda cube satisfy barendregt's conjecture, so they are all strongly normalizing. so every beta reduction strategy will work. so the only way i can run into a problem is in recursive functions
01:34:54 <goltrpoat> either way, reducing the whole thing with a single strategy gives you a lower bound, so you get to cull a lot of stuff out right off the bat
01:35:02 <hygge> we should have a test on haskell tomorrow, i expect questions "algebraic types". do anyone know a nice page with examples of those?
01:35:12 <hygge> questions on*
01:35:15 <edwardk> like i said, not sure once you throw recursion in the mix what happens to that formality
01:35:48 <goltrpoat> i was actually thinking of recursion, couldn't come up with a specific example though
01:36:06 <edwardk> goltr: well, to be honest the semantics of the compiler are just being unspecified so i can stride through certain calculations in cache-sized/simd-unit/gpu-pipeline sized chunks rather than be too eager.
01:36:20 <goltrpoat> (something whose reduction terminates under one strategy, but not another)
01:36:33 <edwardk> well
01:36:45 <edwardk> i'll suck as bad as either basically
01:36:53 <edwardk> if either will diverge, so likely will i
01:37:30 <goltrpoat> yeah, but if it's taking more steps than your reduction of that particular redex under a known good strategy, then chances are you should stop
01:37:30 <goltrpoat> hehe
01:37:54 <goltrpoat> actually.  i guess that's probably not always true
01:37:58 <edwardk> think of it as eager without sideeffects, so if the compiler chooses to be lazy its not so bad
01:38:17 <goltrpoat> -nod-
01:38:45 <goltrpoat> no i assumed we were still talking pure, just mixed non-strict and strict reduction
01:38:56 <edwardk> yeah
01:39:18 <goltrpoat> if you throw in side effects, you more or less have to synchronize at sequence points like c does, if you want any laziness at all
01:39:19 <edwardk> the canonical usage case would be those strided lists we talked about abusing SSE for (or at least i think we talked about)
01:39:43 <int-e> or you can get into a big mess like Unlambda
01:39:48 <goltrpoat> i don't think we talked about strided lists
01:41:54 <edwardk> ah, basically if you look at using SSE for as much as possible you run into a problem with lists in haskell. they are inherently serial to a fault. which works well for haskell, but if i want to process a list of bytes, and didn't care about evaluation order and hitting extra bottoms i could restructure a strict list of bytes into three kinds of nodes, a head node, body node and tail node, where the body node stores a single SIMD regi
01:42:28 <goltrpoat> got cut off at 'a single SIMD regi'
01:42:31 <dons> hence DPH arrays
01:42:36 <edwardk> for a strict list its a clear win, you don't follow 16 pointers, you follow one, your nodes bloat from 4 bytes to 20/32
01:42:43 <edwardk>  registers' width of bytes, 16 in this case. and the head and tail nodes serve the role of your loop entry and loop exit warmup and cooldown handling some smaller number.
01:43:07 <edwardk> yeah but dph arrays solve a slightly different problem
01:43:25 <dons> (more that you want to do this stuff on arrays)
01:43:26 <edwardk> the list case is just a 'first example' of why i want to get away from both strict and lazy =)
01:43:30 <edwardk> yeah
01:44:11 <edwardk> i want to do arrays too, but there i'm focusing on different combinators than the loop stuff you dph guys like =)
01:45:00 <edwardk> if they turn out not to pan out i can always go back and do the kinda generic loop combinator thing
01:45:47 <edwardk> anyways you can copy the head node to get a new head node when you need to take of single bytes, which isn't bad if we assume a GRIN style model where these are really carried around in registers most of the time
01:46:45 <edwardk> the loop walks through 16 bytes at a time, and the same branch elimination stuff needed elsewhere helps in theory to do more with it right in the SIMD reg.
01:46:59 <goltrpoat> -nod-
01:47:06 <edwardk> works fine for strict, but i can't use it in a true lazy setting
01:48:21 <edwardk> coz you need to do calculation value by value to get things like: fix $ \fib -> 1 : 1 : zipWith (+) fib (tail fib) to work
01:48:35 <musasabi> edwardk: how about providing a fast way and if you encounter the bottom do it the "right" way?
01:48:45 <edwardk> if you encounter a bottom you're done ;)
01:49:01 <edwardk> coz i can't tell you it was a bottom =)
01:49:14 <musasabi> depends on the kind of bottom (with dirty exception stuff)
01:49:47 <roconnor> musasabi: can exceptions detect <<loop>>?
01:50:16 <roconnor> >  fix (+1)
01:50:17 <lambdabot>  Exception: <<loop>>
01:50:19 <musasabi> roconnor: <<loop>> is an exception. But things blocking is the hard part.
01:50:29 <roconnor> cool
01:50:33 <edwardk_> arguably you could color it that if it doesn't recurse or you have a proof that the expression isn't pointed then you can use the fast method, but that doesn't cover enough cases
01:50:41 <roconnor> that will throw a wrench into semantics.
01:50:49 <edwardk_> er. what did i say before i got dropped?
01:50:51 <int-e> > last (repeat ())
01:50:54 <lambdabot> Terminated
01:51:19 <roconnor> <edwardk> coz i can't tell you it was a bottom =)
01:51:33 <edwardk_> [04:48] edwardk: if i can do it right when it is bottom then i can solve the halting problem
01:52:13 <roconnor> lemma, if GHC returns <<loop>> then the program doesn't halt.
01:52:23 <edwardk_> hahaha
01:52:27 <roconnor> s/returns/throws/
01:52:45 <beelsebob> mm... bottoms
01:52:50 <edwardk_> that only happens in a limited scenario where it hits a black hole while its still evaluating that thunk
01:53:20 <roconnor> conjecture, if a program doesn't halt, GHC returns <<loop>>
01:53:24 <pzpz> hey -- i'm currently learning haskel, and i've implemented a somewhat inefficient method of longest common specific substring. It would be great to have some people comment on idioms/styles that I'm not utilizing
01:53:24 <pzpz> http://paste.lisp.org/display/28541
01:53:25 <roconnor> s/returns/throws/
01:53:29 <edwardk_> there are plenty of divergent computations that don't involve <<loop>>ing
01:53:34 <roconnor> ;)
01:53:42 <edwardk_> roconnor: there are easy counterexamples to your conjecture
01:54:59 <int-e> > fix reverse
01:55:00 <lambdabot>  Add a type signature
01:55:04 <int-e> > fix reverse :: [Int]
01:55:05 <lambdabot>  Exception: <<loop>>
01:55:30 <edwardk_> > sum [1..]
01:55:34 <lambdabot> Terminated
01:55:53 <ThreeQ> > fix id
01:55:54 <lambdabot>  Add a type signature
01:55:58 <roconnor> edwardk_: oh yeah, well, for every counterexample you come up with, I can come up with an example where my conjecture holds. :P
01:56:02 <ThreeQ> > fix id :: Int
01:56:03 <lambdabot>  Exception: <<loop>>
01:56:10 <edwardk_> and no you can't revise the lemma to say that either GHC returns <<loop>> or lambdabot says Terminated ;)
01:56:32 <int-e> all programs terminate
01:56:35 <int-e> proof by lambdabot
01:56:38 <edwardk_> heh
01:56:38 <Syzygy-> edwardk_: How difficult is it to construct an example that halts, but lambdabot terminates?
01:56:51 <Syzygy-> > 1e15
01:56:52 <lambdabot>  1.0e15
01:57:01 <roconnor> sum [1..10^15]
01:57:01 <Syzygy-> > sum [1..1e15]
01:57:03 <edwardk_> write one that takes longer than lambdabot has to compute
01:57:05 <lambdabot> Terminated
01:57:09 <Syzygy-> Ah. There's one.
01:57:15 <edwardk_> yeah
01:57:39 <roconnor> lambdabot needs a rewrite rule to shortcut those sums.
01:57:46 <pzpz> no one's up for some fun semantic review of my code? :p
01:57:46 <edwardk_> hahaha
01:58:06 <int-e> @version
01:58:06 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
01:58:07 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:58:18 <roconnor> that would be totally awsome!
01:58:40 <edwardk_> i can just see it now, ghc gets a suite of rewrite rules worthy of an undergraduate classical analysis course
01:58:53 <roconnor> let's start with high school
01:59:14 <roconnor> then we can brag to the python people :)
01:59:32 <edwardk_> ooh, and while we're at it we should rewrite any factorial implementation to use the exponential version =)
01:59:40 <int-e> > sum $ map ((-48+) . ord) $ show $ 2^1000000
01:59:43 <lambdabot>  Terminated
01:59:49 <int-e> > sum $ map ((-48+) . ord) $ show $ 2^500000
01:59:53 <lambdabot> Terminated
01:59:57 <int-e> aww.
02:00:17 <edwardk_> er fib not fact
02:00:59 <lispy> bleh, i'm really confusing myself
02:01:12 <lispy> i want to try the ReaderT and WriterT version to help me understand it
02:01:23 <lispy> but i can't figure out how to write fresh or runCodeGen
02:01:33 <roconnor> @hoogle EnumFrom
02:01:34 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
02:01:34 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
02:01:34 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
02:02:37 <roconnor> so is sum (enumFromThen x y) -> (x+y)*(x-y) `div` 2 a safe rewrite rule?
02:03:01 <lispy> ?hoogle runReaderT
02:03:02 <lambdabot> Control.Monad.Reader.runReaderT :: ReaderT r m a -> r -> m a
02:03:04 <roconnor> @scheck \x y -> sum (enumFromThen x y) == (x+y)*(x-y) `div` 2::Integer
02:03:05 <lambdabot>  Couldn't match `Integer' against `Bool'
02:03:09 <lispy> what is r?
02:03:13 <roconnor> @scheck \x y -> sum (enumFromThen x y) == (x+y)*(x-y) `div` (2::Integer)
02:03:14 <lambdabot>  add an instance declaration for (Serial Integer)
02:03:14 <lambdabot>   In the definition of `...
02:03:26 <roconnor> @scheck \x y -> sum (enumFromThen x y) == (x+y)*(x-y) `div` (2::Int)
02:03:31 <lambdabot> Terminated
02:03:32 <lispy> ?hoogle execReaderT
02:03:32 <lambdabot> No matches found
02:03:35 <roconnor> bash
02:03:37 <roconnor> cha
02:03:39 <int-e> > let primep n = and [n `mod` p /= 0 | p <- [2..n-1], primep p] in primep 67 -- note the 'optimization' of testing only primes
02:03:40 <roconnor> grr
02:03:41 <lambdabot>  True
02:03:42 <thou> lispy:  r is the environment type you read from
02:03:55 <roconnor> Actually, the rule doesn't work in charactersitc 2. :(
02:04:22 <edwardk_> > let s5 = sqrt(5); fib k = round $ ((1+s5)/2)^k / s5 in fib 10000
02:04:23 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
02:04:57 <edwardk_> > let s5 = sqrt(5); fib k = round $ ((1+s5)/2)^k / s5 in fib 10000000
02:04:59 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
02:05:13 <edwardk_> hrmm
02:05:32 <roconnor> edwardk_: ah, a new theorem about the fib sequence.
02:05:43 <roconnor> at a certain point they all begin with the same digits
02:05:50 <int-e> roconnor: what does summing the numbers from 1 to n even mean with characteristic 2? the only sensible way I can think of allows you to do the calculation in Z and then map to the field.
02:06:16 <edwardk_> interesting, it just seems to eventually stop giving me answers larger than that number =)
02:06:40 <roconnor> int-e: or equivalantly take the numbers mod 2 and add them up mod 2
02:07:04 <roconnor> int-e: don't you agree that F_2 is a member of Num?
02:07:15 <roconnor> well, more or less
02:07:16 <int-e> > round (1/0)
02:07:18 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
02:07:22 <edwardk_> some time before the golden section to the 10000th power.
02:07:23 <edwardk_> ag
02:07:25 <edwardk_> er ah
02:07:40 <roconnor> that's pretty round
02:07:53 <edwardk_> precision problem coz i'm not using Integers
02:07:56 <edwardk_> duh
02:08:31 <int-e> roconnor: I know what you mean, I just don't think it's much of a problem in this particular case.
02:08:51 <roconnor> int-e: well, the (`div` 2) is a problem.
02:09:06 <int-e> roconnor: your summation isn't well defined
02:09:22 <roconnor> int-e: sure it is, give me an example.
02:09:56 <int-e> \sum_{i=0}^{1}i = 0+1+0+1 = 0+1 ?
02:10:15 <int-e> the two happen to have different values in Z_2.
02:11:54 <int-e> and that doesn't happen in fields with different characteristics.
02:12:15 <roconnor> sum [0..1] = 0+0+1 = 1
02:12:19 <roconnor> what's the problem?
02:13:39 <int-e> there is a problem? we have just slightly different views on the same effect.
02:14:32 <mnislaih> Lemmih: around? can you receive privs  ?
02:15:04 <Igloo> kzm: Which bug report is that?
02:16:31 <kzm> Oh, hi.
02:16:40 <kzm> The one about CPP barfing on ' (single quote)
02:17:52 <Igloo> kzm: Ah, OK. I don't think we're going to treat that as a blocker for any release in the near future
02:18:05 <Igloo> It doesn't mean it won't be fixed
02:18:05 <kzm> :-)
02:20:01 * Igloo isn't sure what a proper fix would be, short of someone writing some sort of Haskell pre-processor, though
02:20:32 <Igloo> Or maybe a BSD'd cpphs
02:21:09 <kzm> I quite like cpp, really.  Heresy, I know, but it's really simple, and does its simple things well.
02:21:22 <kzm> So if it just grokked Hs syntax a bit better...
02:21:47 <pejo> Igloo, is lgpl too strict?
02:22:10 <kzm> A "real" solution is probably TH or something, but it just seems to syntactially intrusive.  Worse is better(tm).
02:23:21 <musasabi> pejo: LGPL creates all kinds of problems with static linking and redistribution.
02:23:36 <kzm> One problem with extending cpp is of course that we really, really don't want a schism here.  Perhaps H' could mandate a Hs-syntax-aware cpp?
02:23:40 <kzm> (or no cpp at all)
02:24:19 <pejo> musasabi, isn't cpphs external to the compiler though (i.e not linked in).
02:24:28 <pejo> That was a question.
02:24:33 <musasabi> the easiest way is to avoid using ' in files with cpp.
02:24:35 <goltrpoat> edwardk:  mind if i msg you?
02:25:06 <musasabi> pejo: yes, but cpphs is not something that must be shipped.
02:26:15 <musasabi> pejo: e.g. I like the possiblity that I can host a unmodified binary build for some platform and just point people to GHC homepage - LGPL makes such things illegal.
02:29:20 <lispy> ?kind MonadReader
02:29:21 <lambdabot> Class `MonadReader' used as a type
02:30:44 <pejo> musasabi, I realize we're drifting off into law here, but to distribute, say, a binary build of glibc, isn't it sufficient to point people to the nearest source mirror for the gnu project?
02:31:01 <pejo> (unless you patch things of course, I guess you need to make the patches available then).
02:31:40 <musasabi> pejo: no. that is illegal. One has to host the source if one hosts the binary. (or provide a written offer etc)
02:32:39 <pejo> musasabi, bummer.
02:38:27 <hygge> is the lists in haskell the same as vektors?
02:39:38 <Igloo> pejo: Probably; MS people have to be paranoid about infective licences
02:41:34 <dibblego> I am running a quickcheck and it is going into an infinite loop - how can I see what values cause it?
02:41:57 <psi> hygge: they're linked lists
02:44:10 <hygge> linked, psi?
02:45:45 <xerox> hygge: do you know about cons cells?
02:45:49 <psi> hygge: it means a list where each element contains a pointer to the next one
02:46:41 <kfish> dons: do you know if it's possible with cabal to conditionally require either ghc6.6 or fps, in order to have Data.ByteString?
02:48:18 <x3m2> @seen foxy
02:48:19 <lambdabot> I saw foxy leaving #haskell 1h 7m 2s ago, and .
02:48:33 <dibblego> perhaps quickcheck is passing an infinite list - which will result in an endless evaluation - can I tell quickcheck not to do that?
02:56:31 <Igloo> kfish: It's not
02:56:47 <lispy>     The lambda expression `\ e -> ...' has one arguments,
02:56:48 <lispy>     but its type `ReaderT e (WriterT [Instruction] Unique) a' has only 0
02:56:54 <lispy> that is a very odd message to ge
02:56:58 <lispy> +t
02:57:30 <hygge> is haskell "strongly typed"?
02:58:40 <Igloo> hygge: yes
02:58:52 <Igloo> lispy: Do you mean the phrasing is odd for the 0 case?
02:59:03 <Botje> if you pound your keyboard hard enough, you get haskell :)
02:59:20 <lispy> Igloo: no, i mean i don't understand how the lambda expression can have one argument but the type differs?
03:00:01 <Igloo> foo :: ReaderT ...; foo = \e -> ...
03:00:30 <lispy> Igloo: i'm trying to create an instance of MonadReader and defining local is not working out :)
03:01:33 <lispy> hmm..for some reason local = local works
03:01:59 <Igloo> It'll work as long as yo don't try to use it...
03:02:09 <lispy> :(
03:02:21 <int-e> @type let x = x in x
03:02:22 <lambdabot> forall t. t
03:03:15 <int-e> local is strange :/
03:10:38 <lispy> ask = CodeGen $ ask; so i thought maybe local would be simialr but i get type errors
03:10:47 <lispy>       Expected type: ReaderT e (WriterT [Instruction] Unique) a
03:10:47 <lispy>       Inferred type: CodeGen e a
03:21:45 <lispy> local f (CodeGen x) = CodeGen $ local f x
03:21:49 <lispy> i think that's right
03:27:47 <kfish> Igloo, thanks
03:32:49 * SamB_XP wonders why google can't notice repeated syllables in queries
03:32:59 <lispy> SamB_XP: it does
03:33:08 <lispy> SamB_XP: well, it gives you different results at least
03:33:20 <lispy> SamB_XP: er wait, syllables?
03:33:25 <lispy> sorry, i can't read....
03:33:43 <SamB_XP> I mean, why can't it find the correct spelling if I search for, say, site:haskell.org report "renaminging"
03:33:43 * lispy was thinking of queries like "the the the" vs "the"
03:35:15 <goltrpoat> hmm?  http://www.google.com/search?hl=en&q=%22the+the%22&btnG=Google+Search
03:35:17 <lambdabot> Title: "the the" - Google Search, http://tinyurl.com/ybtvrt
03:35:35 <SamB_XP> how about a google war of "the" against "the the"?
03:36:13 * beelsebob licks everyone
03:36:48 * SamB_XP wonders why the report shows programs with multiple modules concatenated
03:37:10 <lispy> SamB_XP: well, technically that's valid
03:37:15 <lispy> SamB_XP: isn't it?
03:37:26 <SamB_XP> it depends!
03:38:00 <SamB_XP> on whether or not there is a production for one or more modules in a row...
03:38:17 <SamB_XP> certainly it would make it harder to do that thing with the implicit module head...
03:39:43 * SamB_XP tries to figure out what the hell this "renaming" thing is between Prelude and the import list in this code...
03:39:57 <SamB_XP> http://www.haskell.org/pipermail/haskell/2004-August/014387.html
03:40:00 <lambdabot> Title: [Haskell] Re: ANNOUNCE: The Succ Zero International Obfuscated Haskell Code Cont ..., http://tinyurl.com/y3b9v9
03:59:22 <lispy> alright, my compiler now does let, so it just got interesting :)
03:59:25 <lispy> (at least for me)
04:06:37 <lispy> the funny thing about building this scheme compiler is that haskell datatype for my AST is similar to sexp...so it looks like i'm writing scheme programs but I haven't even written the parser yet :)
04:08:30 <SamB> heh
04:08:46 * SamB wants to see it later ;-)
04:12:19 <roconnor> why do people use/make mailing lists instead of news groups?
04:13:22 <SamB> would their ISPs even carry the groups?
04:13:46 <SamB> anyways, if you set your list up with gmane, you can have both at once ;-)
04:13:55 <Igloo> I suspect because people get CCed a lot
04:14:29 <roconnor> doesn't usenet support having a bunch of semi-local servers that we can directly subscribe to?
04:15:00 <roconnor> Anyhow, yes, I'm thinking of dropping my mailing lists and using them through gmane instead.
04:15:48 <SamB> gmane has both at least one fairly decent web interface and a proper NNTP interface
04:16:48 <roconnor> I'm actually thinking of whitelisting all my email.
04:17:21 <roconnor> this is pressuring me to drop the use of mailing lists
04:17:43 <roconnor> I'm still going over in my head how things could work
04:18:23 <SamB> mmm
04:18:43 <SamB> afaict, all the haskell.org lists are on there
04:19:02 <roconnor> I should add the coq mailing list if it isn't there.
04:19:25 <SamB> or suggest that it be added
04:19:36 <roconnor> right
04:19:43 <SamB> sometimes it works better if the list admin does it. sometimes.
04:24:46 <jmmv> hi
04:26:49 <lispy> oh man this chapter starts with a real bummer
04:26:51 <lispy> "The compilers we have written up to the last section are a little more than
04:26:51 <lispy> a calculator. Every program they compiled was simple enough that we
04:26:52 <lispy> could have computed the result at compile time and replaced the program
04:26:53 <lispy> by its answer."
04:27:18 <lispy> and I thought I had actually done something cool!
04:27:34 <yain> what are you reading?
04:27:43 <lispy> http://www.cs.indiana.edu/~aghuloum/compilers-tutorial-2006-09-16.pdf
04:27:45 <lambdabot> http://tinyurl.com/sh4no
04:28:20 <lispy> yain: it's kinda neat, it's a compiler tutorial that begins with code generation
04:29:12 <yain> hmm, I think I saw that.
04:29:19 <yain> totally wrong approach too.
04:29:22 <lispy> it was on LtU recently
04:29:37 <lispy> really? I think it's been fun and i've learned a ton
04:29:57 <lispy> it's very hands on
04:31:03 <wolverian> HGTH-style?
04:32:27 <yain> OK, i didn't see this one, but I've seen another paper by Ghuloum about that.
04:32:51 <yain> so I guess I can safely assume it's the same stuff.
04:33:12 <lispy> maybe you read this one before? http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf
04:33:14 <lambdabot> http://tinyurl.com/mpaac
04:33:16 <yain> yes.
04:33:49 <lispy> i'm following the first one because the second seems incomplete and maybe even wrong in places
04:38:02 <lispy> ah well i should have went to bed hours ago
05:25:00 <Lajexander> @type unzip
05:25:01 <lambdabot> forall b a. [(a, b)] -> ([a], [b])
05:28:20 <Syzygy-> > unzip . zip [1..10] [2,4..]
05:28:21 <lambdabot>    Expecting a function type, but found `[(a, b)]'
05:28:21 <lambdabot>    Expected type: a1 ...
05:28:34 <Syzygy-> > (unzip . zip) [1..10] [2,4..]
05:28:35 <lambdabot>    Expecting a function type, but found `b'
05:28:35 <lambdabot>    Expected type: [a1] -> [(...
05:28:38 <Lajexander> @type foldr
05:28:40 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
05:28:46 <Syzygy-> > zip [1..10] [2,4..]
05:28:47 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20)]
05:28:52 <Magicman> > unzip $ zip [1..10] [2,4..]
05:28:53 <Syzygy-> > unzip $ zip [1..10] [2,4..]
05:28:53 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20])
05:28:54 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20])
05:29:46 <xerox> > (unzip .) . zip % [1,2,3] "yay"
05:29:46 <lambdabot>    The function `[1, 2, 3]' is applied to one arguments,
05:29:47 <lambdabot>   but its type `...
05:29:50 <xerox> > (unzip .) . zip $ [1,2,3] "yay"
05:29:51 <lambdabot>    The function `[1, 2, 3]' is applied to one arguments,
05:29:51 <lambdabot>   but its type `...
05:29:54 <xerox> Aw.
05:30:04 <xerox> > ((unzip .) . zip) [1,2,3] "yay"
05:30:05 <lambdabot>  ([1,2,3],"yay")
05:30:25 <dons> heh
05:30:53 <dons> xerox's pl-fu is high. the lambdas are with him
05:31:10 <Magicman> unzipWith = flip (.) unzip.uncurry.zipWith
05:31:19 <Magicman> Or is there a better definition?
05:32:24 * xerox bows
05:33:30 <xerox> Ah-ha! If you want to use $, since its associativity is wrong, you ought to do.
05:33:32 <xerox> > unzip . zip [1,2,3] $ "yay"
05:33:33 <lambdabot>  ([1,2,3],"yay")
05:34:11 <Syzygy-> @type (unzip . zip)
05:34:13 <lambdabot>   Expecting a function type, but found `b'
05:34:13 <lambdabot>    Expected type: [a1] -> [(a, b)]
05:35:35 <xerox> Syzygy-: \x y -> unzip (zip x y) = \x y -> unzip . zip x $ y = \x -> unzip . zip x = \x -> (.) unzip (zip x) = \x -> ((.) unzip) (zip x) = \x -> (unzip .) . zip $ x = (unzip .) . zip
05:36:18 <xerox> ?type (let (.:) = (.) . (.) in unzip .: zip)
05:36:20 <lambdabot> forall a b. [a] -> [b] -> ([a], [b])
05:36:59 <Magicman> wtf :-P
05:37:17 <Magicman> (.) . (.)
05:38:22 <therp> who's the first to make a joke about boob syntax?
05:39:04 * dcoutts prefers (:[])
05:39:13 <Bobstopper> I've often wondered if the choice of (.|.) as an operator in Data.Bits was intended to look like boobs
05:39:27 <dcoutts> (.&.) ?
05:39:31 <xerox> \f g x y -> f (g x y) by definition of (.): \f g x y -> f . g x $ y eta-reduction: \f g x -> f . g x infix to prefix: \f g x -> ((.) f) (g x) definition of (.): \f g x -> (f .) . g $ x eta-reduction: \f g -> (f .) . g  OK so far Magicman?
05:40:12 <Magicman> xerox: aye
05:41:12 <xerox> \f g -> (f .) . g infix to prefix: \f g -> ((.) (f .)) g eta-reduction: \f -> ((.) ((.) f)) definition of (.): \f -> ((.) . (.)) f eta reduction: (.) . (.)
05:41:42 <Daveman> xerox :D
05:41:48 <xerox> Hiya Daveman.
05:42:26 <Magicman> xerox: ACK
05:42:30 <Daveman> SYN
05:42:35 <Syzygy-> @type (unzip .) . zip
05:42:36 <lambdabot> forall a b. [a] -> [b] -> ([a], [b])
05:42:43 <xerox> Good!
05:42:52 * Daveman giggles
05:43:17 * Syzygy- assumes I would understand more of what xerox just wrote if I had actually taken some time with Lambdacalculus in the past...
05:43:38 <mauke> @. pl . djinn type (unzip .) . zip
05:43:39 <lambdabot> f = (,)
05:43:57 <xerox> Syzygy-: eta-reduction is: if \x -> e x then e.
05:44:04 <Syzygy-> Ah.
05:44:22 <Syzygy-> xerox: So that's how you dropped the $y and $x above?
05:44:23 <mauke> ah, so that's what it's called
05:44:30 <xerox> Exactly Syzygy-.
05:45:32 <Daveman> ;]
05:46:17 <xerox> The definition of (.) is in Haskell: (f . g) x = f (g x).  "Infix to prefix" refers to the ability of Haskell of writing a <op> b = (<op> a b) for binary operators <op>.
05:46:32 <xerox> ((<op>) a b) really.
05:46:58 <Daveman> xerox operator? :)
05:47:07 <vincenz> vegai: yes here it's better
05:47:14 <vegai> ;)
05:47:23 <dons> ?check \x y -> x + y == (+) (x::Int) (y::Int)
05:47:24 <lambdabot>  OK, passed 500 tests.
05:47:32 <vegai> vincenz: C is fun in a totally different level...
05:47:42 <xerox> Whatever binary function in fact.  For |f x y = <expr>| you could use |x `f` y = <expr>|.
05:48:29 <dons> vegai: is C ever fun though? maybe the pointer hacking -- that can be fun.
05:48:47 <dons> writing things like     while (n-- != 0)
05:48:55 <dons>         *q++ = *p--;
05:48:56 <dons>    
05:49:04 * earthy loves Duff's device
05:49:08 <earthy> that's heaps of fun
05:49:11 <dons> mmm. yes!
05:49:11 <vegai> its problems are in a level I can currently grok better than Haskell's
05:49:39 <Daveman> :D
05:49:40 <dons> but with the small fun, comes a lot of pain too.
05:49:41 <xerox> What's Duff's device?
05:49:42 <vincenz> earthy: you mean pointers of fun
05:49:44 <Daveman> haskell party!
05:49:50 <earthy> vincenz: um, yea. :)
05:49:51 <vincenz> xerox: mix a switch with a while loop
05:49:55 <earthy> xerox: http://www.lysator.liu.se/c/duffs-device.html
05:49:57 <lambdabot> Title: Tom Duff on Duff's Device
05:50:16 <vegai> perhaps I'll litter my code full with that before I change jobs
05:50:35 <xerox> Ot has got UUCP in the headers!
05:50:37 <xerox> *It
05:51:09 <earthy> yes. slightly old stuff, that. :)
05:51:55 <mauke> duff's device is older than c :-)
05:52:04 <vincenz> it comes from the simpsons
05:52:06 <xerox> "The device is legal dpANS C."
05:52:07 <earthy> mauke: duff's device is older than ISO C.
05:52:25 <xerox> Who would go around be proud of that now?
05:52:30 <mauke> earthy: yeah
05:52:50 <earthy> C itself is from 1971 or some such
05:53:15 <dons> mmmm "the Programmed IO data register of an Evans & Sutherland Picture System II"
05:53:28 <dons> excellent reference, earthy, that link.
05:54:03 <earthy> all of http://www.lysator.liu.se/c/ is good, if you're into C.
05:54:04 <lambdabot> Title: Programming in C
05:55:35 <dons> lispy: did someone watch us writing lambdaweb?? http://www.datamech.com/devan/trypython/trypython.py
05:55:39 <lambdabot> Title: Try Python with the online REPL, http://tinyurl.com/yxmexr
05:56:20 <dons> though not having any static checking of IO worries me a lot. I couldn't put an impure language online myself...
05:56:37 <dons> ?where lambdaweb
05:56:37 <lambdabot> http://lambdabot.codersbase.com
05:56:42 <xerox> dons: yes it's scary
05:57:30 <dons> the similarities between lambdadweb and the python page are a little striking
05:57:40 <dons> i guess its just coincidence?
05:57:41 <xerox> heheh
05:57:52 <xerox> Ah, it uses GOA behind the scenes.
05:57:57 <dons> ours looks nicer. :)
05:57:59 <earthy> hm. is there an online repository of the URL's pasted here?
05:58:02 <xerox> Yeah :)
05:58:18 <dons> earthy: hmm. i have the entire logs in darcs.. all 400M
05:58:27 <dons> that's both online and a repository
05:58:46 <earthy> not quite what I was looking for though.
05:58:58 <earthy> :)
05:59:05 <dons> http://www.cse.unsw.edu.au/~dons/code/%23haskell/
05:59:07 <lambdabot> Title: Index of /~dons/code/#haskell, http://tinyurl.com/j97t7
05:59:10 <xerox> dons: \web doesn't talk with the beloved lambdabot here, but to some local sister, right?
05:59:15 <dons> (I don't recommend a darcs pull without --partial, at least :)
05:59:21 <dons> xerox: right.
05:59:48 <xerox> It would be fun if all the lambdabots had one central brain.
06:00:00 <dons> fun and evil
06:00:03 <earthy> and it doesn't have the current day ;)
06:00:22 <dons> yeah, its only synced once a day. check the meme logs for live updates
06:00:45 <xerox> Write a central "daemon" (poor lambdabot, she's not a daemon!) and then lots of interface clients.
06:00:45 <mux> dons: the problem I had with -threaded was a PEBKAC
06:00:54 <mux> so I won't post on haskell-cafe :)
06:01:02 <dons> mm?
06:01:18 <dons> xerox: hmm. you could do that over irc perhaps
06:01:23 <xerox> dons: that's true!
06:01:33 <mux> dons: you know, I told you I had problems with a thread blocking the whole program
06:01:36 <dons> i.e. tunnel into an irc session with her, and use irc to handle the communication
06:01:41 <earthy> ah, good, meme at least has clickable urls
06:01:42 <dons> mux, yes.
06:01:53 <xerox> dons: yes that makes it easier to implement
06:01:54 <mux> dons: you know what PEBKAC means?
06:01:57 <dons> nope.
06:02:01 <mux> Problem Exists Between Keyboard And Chair
06:02:07 <dons> ah nice :)
06:02:08 <xerox> mux was enlightened.
06:02:32 <mux> so I thought you'd like to know so that you don't wonder why I didn't post yet
06:02:44 <dons> ok.
06:03:16 <xerox> dons: a friend involved in this python vs. ruby wars says it tries to copy http://tryruby.hobix.com/
06:03:16 <dons> yeah, I'd need to see the keyboard, or maybe the chair, before I could diagnose any further solution
06:03:18 <lambdabot> Title: try ruby! (in your browser)
06:03:42 <syntaxfree> I need some silly help installing WebFunctions.
06:03:59 <syntaxfree> Where do I put the .o, .hi, etc. files so GHC can reach them?
06:04:37 <earthy> dunno, and Robert, unfortunately, is at Philips these days.
06:05:00 <syntaxfree> Philips?
06:05:10 <earthy> but GHC is pretty good in documenting where it searches for files
06:05:16 <earthy> so maybe the GHC User's guide can help?
06:05:26 <earthy> syntaxfree: you know, the big electronics company?
06:05:34 <syntaxfree> oh. cool.
06:05:47 <dons> do you think, xerox, that ruby and python will wipe each other out, leaving haskell standing alone and unscratched?
06:06:16 <syntaxfree> Python never managed to create the aura Ruby has acquired.
06:06:20 <dons> do language wars work like that i wonder?
06:06:33 <dons> and at what point did python declare victory over perl?
06:06:52 <dons> was there any treaty signed?
06:07:05 <syntaxfree> what battle are you talking about anyway?
06:07:16 <Smokey``> ruby vs python vs perl :P
06:07:18 <dons> syntaxfree: I think you mean hype :) angles have auras (or halos), ruby has hype
06:07:19 <syntaxfree> Python in web scripting is pretty much not used.
06:07:21 * dylan programs in both python and perl.
06:07:40 <dons> s/angels/
06:07:42 * syntaxfree does his web stuff in PHP. 
06:07:50 <wolverian> syntaxfree, http://tnx.nl/php :)
06:07:55 <lambdabot> Title: PHP in contrast to Perl
06:07:57 <syntaxfree> at least until I get this WebFunctions thing sorted out :)
06:08:08 <dylan> PHP has like 3700 functions in the global namespace.
06:08:19 <Smokey``> I prefer PHP for web dev...
06:08:19 <wolverian> (the image says it all.)
06:08:30 <dons> each more fearsome than the last!
06:08:31 <wolverian> (specifically, http://tnx.nl/php.jpg)
06:08:36 <syntaxfree> PHP has no closures. It gets tiresome.
06:08:41 <earthy> syntaxfree: you do not know about Zope then?
06:08:56 <syntaxfree> I don't. I'm not too serious about web programming yet, though.
06:09:13 <syntaxfree> I've arrived to programming through strange and twisted ways.
06:09:27 <earthy> ah. ;)
06:09:32 <syntaxfree> I learned Basic as a toddler, as everyone and their brother.
06:09:48 <syntaxfree> Then, in  my undergrad years, I came to Matlab.
06:09:50 * earthy arrived at programming almost directly after getting his grubby paws on an Apple II
06:10:06 <earthy> the fascination hasn't stopped since. :)
06:10:10 <Stinger_> matlab, bleah :)
06:10:16 <syntaxfree> Then I learned to twist loops into matrix form, so my code consisted of incompreehensible sequences of matrix mutiplications.
06:10:17 * ndm learnt programming with windows .bat files
06:10:39 * Smokey`` learnt programming with UnrealScript for the original Unreal Tournament
06:10:47 <syntaxfree> Documentation consisted of stacks of paper with hollow square brackets describing matrix sizes.
06:10:48 * ndm remembers the days where goto was the ONLY control flow statement
06:11:04 <dons> I think ndm is older than he looks then.
06:11:12 <dylan> I learned to program using perl on win32. This is why I'm a gnu/linux user now. ;)
06:11:12 <syntaxfree> then I learned Scheme.
06:11:13 <Philippa_> UScript's an impressive language if you know what you're looking at
06:11:14 <syntaxfree> and Haskell.
06:11:21 <earthy> ndm: and then you learned about GOSUB? :)
06:11:26 <dons> dylan: heh.
06:11:37 <ndm> earthy: there is no GOSUB in .bat, _only_ goto
06:11:40 <Philippa_> ndm: no conditionals?
06:11:42 <dylan> perl on win98, even.
06:11:46 <earthy> ndm: true dat
06:11:56 <earthy> there is CALL though, which is almost the same
06:11:57 <Philippa_> there's call though
06:11:59 <syntaxfree> so, anyway, I can't get my head twisted around OOP.
06:12:00 <Philippa_> snap!
06:12:04 <dons> ndm, so you got hardcore tail recursion early on :)
06:12:05 <earthy> snip!
06:12:19 <Smokey``> Philippa_: I only learned the original UScript,  not the later 2k3/2k4 stuff, which seems considerably changed (or maybe I was looking at some high level abstraction functions/operators they recently implemented... either way, it looks as if it's changed considerably)
06:12:20 <ndm> Philippa_: conditionals are: if condition value - where value is exactly one expression, so to do anything real requires a goto in the value part
06:12:21 <Philippa_> ...I guess I need to get my hair trimmed soon
06:12:33 <ndm> earthy: CALL calls another batch script, it doesn't do a function call
06:12:35 <Smokey``> was literally an even mix of Java and C++.
06:12:37 <Stinger_> the thing that made me really GET oo was quake c funnily enough
06:12:45 <Philippa_> Smokey``: most of the truly impressive stuff's all the way back in Unreal
06:13:00 <Philippa_> though I should read up on what was new in 2k3/2k4. 2k7 looks to be rather interesting
06:13:01 <Renkin> ndm: solved the Env thing ;)
06:13:13 <ndm> oh, and i used peano numbers, since .bat doesn't have any
06:13:14 <syntaxfree> Perl has closures?
06:13:16 <ndm> Renkin: well done :)
06:13:31 <dylan> syntaxfree: yes.
06:13:36 <Renkin> it was a bit of a revelation, actually
06:13:41 <syntaxfree> Oh, I should move to Perl if I can't grok the WebFunctions thing.
06:13:43 <syntaxfree> I need closures.
06:13:44 <ndm> Renkin: but obvious now you've done it?
06:13:48 <Renkin> yeah
06:13:55 <earthy> ndm: you are scary
06:14:14 <earthy> (even though I once encoded numerals in unary to implement turing machines in SED...)
06:14:25 <ndm> earthy: thank you :) - and this was with no documentation at all, not even knowing what peano's were
06:14:50 <ndm> the internet has destroyed that, now everyone can have access to up to date documentation and good tools, but i got stuck with .bat and loved it!
06:15:22 * earthy was spoiled then, having access to Applesoft Basic from the outset. :P
06:15:45 <dylan> nobody ever told me what a linked list was, I just randomly implemented one and thought it was horribly inefficient...
06:15:49 * ndm had better go demonstrate functional programming - bye
06:16:19 <earthy> heck, I even learnt to write portable code before I was 15... using BASICODE
06:16:43 <dylan> actually, before I ever learned scheme or lisp, I started using closures instead of objects for most things.
06:18:18 <syntaxfree> I don't really understand what's the big wawa about objects.
06:18:31 <syntaxfree> They're basically data types with attached code, for what I've seen.
06:18:53 <earthy> subtyping is the main interesting bit
06:19:02 <Philippa_> syntaxfree: 1) *Smalltalk* OO is something else, and much of the hype came from there 2) if all you had was procedural code in older languages, and especially if you were writing simulations, it was a big leap
06:19:06 <mnislaih> anyone familiar with the FC+AT stuff in GHC knows what has become of TyApp ?
06:19:06 <Maddas> earthy: Subtyping or subclassing?
06:19:15 <Philippa_> gtg
06:19:32 <earthy> maddas: explain the difference, in your view
06:20:42 <Philippa_> subclassing typically involves inheritance
06:20:58 <syntaxfree> methinks "CLOS" is a clever pun.
06:21:30 <dylan> Actually, my friends hate me because I always insist C++, Java, etc, arn't "real" OO...
06:21:37 <Philippa_> it's worth remembering that when the OO hype started, most people were used to languages like basic, cobol, pascal or if they were lucky C
06:21:45 <Philippa_> I've caused a few arguments that way too
06:21:51 <syntaxfree> is CLOS "real" OO?
06:21:59 <Philippa_> the fun thing's when they think it's because I expect everything to be an object in a language
06:22:08 <Philippa_> whereas usually I'm more interested in things like having a notion of message
06:22:16 <dylan> CLOS is more like dispatch-based-on-type, it feels different than smalltalk.
06:22:30 <syntaxfree> what about Ruby?
06:22:32 <Philippa_> I think CLOS has more room to call itself OO than C++ does though
06:22:43 <dylan> syntaxfree: what about it?
06:22:49 <syntaxfree> is it "real" OO?
06:22:57 <dylan> syntaxfree: yeah. it's message-based.
06:23:15 <syntaxfree> maybe that explains the hype.
06:23:23 <dylan> well, perl and python are real too.
06:23:32 <xerox> dons: lots of usenet traffic is signed instead of treaties? :D
06:25:19 <syntaxfree> hrm. Does Ruby have closures?
06:25:37 <xerox> They call them blocks?
06:25:39 <dylan> syntaxfree: sort of -- yes
06:25:40 <pejo> syntaxfree, it seems pretty convenient to model things as objects though, when programming.
06:25:58 <pejo> (late aura).
06:26:01 <dylan> blocks have no scope associated with them, but you can pass them to a function that binds them with scope.
06:26:32 <dylan> or you could say blocks are a purely syntactic element, and closes use that syntax.
06:26:58 <dylan> *closures
06:27:49 <syntaxfree> hm.
06:28:09 <syntaxfree> I'd better get WebFunctions working, but where do I put .o and .hi files so GHC can reach them?
06:28:17 <dylan> ruby is also very slow and doesn't do unicode.
06:29:28 <earthy> syntaxfree: in the directories where the .hs files are?
06:30:51 <Maddas> earthy: Well, I'd think of subtypes as described by the Liskov Substitutability Principle.
06:31:02 <Maddas> But I'm no computer scientist (:
06:31:21 <syntaxfree> earthy: I've tried that, but it's a confusing tree of subdirectories and hierarchical  module names.
06:31:43 <earthy> what do you find confusing about it?
06:31:56 <earthy> Module.Named.AsSuch should be in file Module/Named/AsSuch.hs
06:32:15 <earthy> with the corresponding files Module/Named/AsSuch.hi and Module/Named/AsSuch.o
06:32:28 <earthy> where Module/ is a subdirectory of the main source directory of your program
06:32:37 <Philippa_> Maddas: there's the slight problem that subtyping relationships in OO languages tend not to give a damn about the LSP per se :-)
06:32:53 <Maddas> Philippa_: Yup :-)
06:35:03 <earthy> doesn't mean they're not subtyping relations though
06:38:23 <syntaxfree> what is a "Lexical Error"?
06:38:32 <syntaxfree> I did get the modules to import as earthy suggested.
06:41:00 <Philippa_> syntaxfree: approximately speaking, a low-level syntactic error
06:43:24 <syntaxfree> hmm. I see.
06:43:54 <syntaxfree> I think a part of OOP's success has to be explained by how technological "object"  sounds.
06:44:04 <syntaxfree> contrast "WebObjects" with "WebFunctions".
06:45:48 <dylan> to me, object == thing.
06:46:22 <syntaxfree> Object is a part of a predicate.
06:46:29 <syntaxfree> in "The door is open", "door" isn't an object.
06:47:05 <therp> is it actually possible for "let" to introduce class/instance declarations? the syntax tree construction of GHC seems to allow that
06:47:16 <ozone> syntaxfree: o yeah?  just wait until WebMonads
06:47:34 <syntaxfree> WebFunctions uses monadic transformers and all.
06:47:40 <syntaxfree> they still call it WebFunctions.
06:47:58 <ozone> category theory, for great justice
06:48:00 <syntaxfree> and worse yet, the Haskell community did have the "monad" name, but the new technology is just called "Arrows".
06:48:11 <syntaxfree> Call it "Morphisms", for great justice.
06:49:13 <Philippa_> but they're not derived from morphisms as such
06:49:22 <syntaxfree> oh. Ok, then.
06:49:30 <Philippa_> whereas they are "things that're a bit like the function arrow"
06:49:46 <ozone> Philippa_: hey, C++ abuses that "functor" word just as equally :)
06:49:58 <audreyt> I thought the correct name would be "Freyd Categories" or "Premonoidal Functor" or something
06:49:58 <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:50:24 <syntaxfree> I'm trying to parse page 12 of Freyd's "Abelian Categories" this week.
06:50:53 <syntaxfree> I'm thinking of switching over to that "Category theory for the working computer scientist" book though.
06:51:25 <audreyt> that's a pretty good read
06:51:38 <audreyt> havn't touched it in 1 year or so, but it's nice
06:51:39 <syntaxfree> which one?
06:51:46 <audreyt> CTftwCS
06:52:35 <syntaxfree> at the pace I'm reading Freyd's, I should be done in about 15 years.
06:52:56 <audreyt> linear progress is almost never the case...
06:53:38 * syntaxfree is in a completely different graduate program and has scarce time for cat theory.
06:54:24 <xerox> Hiya audreyt
06:54:37 * beelsebob licks the room
06:54:48 <beelsebob> anyone doing anything interesting today?
06:55:11 <syntaxfree> ?remember beelsebob 10:54 AM  beelsebob licks the room
06:55:29 * Bobstopper has "basic category theory for computer scientists" and understands hardly any of it :)
06:55:46 * beelsebob tries hard to ignore category theory
06:56:09 <syntaxfree> I've been fascinated by cat theory since before finding out it was useful for CS.
06:56:41 <syntaxfree> maybe it's because my abstract algebra is poor and I'm fascinated by the whole algebraic structure game.
06:56:48 <xerox> Philippa_: do you know what parts of the function arrow are taken in consideration as characteristic of the Arrows?
06:57:45 <Philippa_> xerox: yeah, see the definition of Arrow :-)
06:58:01 <xerox> Which one are you thinking of?
06:58:27 <Philippa_> the kind, composition, identity and the ability to include pure functions. And a few other bits and pieces.
06:58:45 <Philippa_> Bobstopper: it's a bit dense if you don't do anything out on paper
06:58:54 <syntaxfree> @quote beelsebob
06:58:54 <lambdabot>  10:54 AM  beelsebob licks the room
06:59:37 <xerox> Philippa_: like what has got to be done on paper?
06:59:53 <syntaxfree> cheers for paper!
07:00:59 <syntaxfree> there's a word I can't remember in english.
07:01:21 <syntaxfree> What's the name of that last molar teeth that grows when you're about 20 and sometimes has to be pulled out?
07:01:45 <dylan> wisdom teeth
07:01:54 <syntaxfree> yeah.
07:02:01 <syntaxfree> I'm getting a wisdom tooth extracted.
07:02:07 <syntaxfree> I mean, right now. Wish me luck.
07:02:08 <dylan> more often than sometimes depending on your ancestry
07:02:40 <dylan> syntaxfree: when I did that, the sleepy drugs made me confess my love to someone that I'm now engaged to. so, good luck! ;)
07:02:58 <syntaxfree> I'm already engaged :)
07:03:07 <dylan> Well, maybe you'll wake up married.
07:03:16 <syntaxfree> hehe.
07:03:22 <syntaxfree> anyway, up and out.
07:04:48 <Bobstopper> hmm. I'm 26 and haven't heard a peep from my wisdom teeth. I suspect I don't have any. I hope number of wisdom teeth isn't meant to be proportional to actual wisdom...
07:06:07 <Botje> wisdom teeth are excess wisdom pushing out of your gums :)
07:06:38 <Bobstopper> :(
07:06:51 <Bobstopper> I guess that's a yes :(
07:08:11 <FransE> Is there any difference between declaring a function and a variable? E.g, in  "x = 3", is x a function or a variable? Function I'd say..
07:08:28 <dylan> Bobstopper: it depends on the size of your jaw, genetics, and what sort of food you've eaten.
07:08:51 <Bobstopper> FransE: no difference. The type determines which it is.
07:10:05 <Bobstopper> FransE: In functional programming, functions are values like any other
07:10:35 <Smokey``> Bobstopper: chances are you won't get them if you haven't already... or if you're like me... you've already got one emerging at 18, and the rest well on their way :(
07:11:24 <Bobstopper> I've heard it's related to genetics only. How does it relate to food eaten?
07:11:50 <Bobstopper> It'd probably be a good thing if it was more dependent on jaw size; I understand crowding's one of the bigger problems with wisdom teeth...
07:12:55 <roconnor> Bobstopper: I have no wisdom teeth
07:12:56 <kpreid> FransE: in Haskell, they are Not Functions, because functions have -> in their type.
07:13:13 <Lajexander> how do instance Arbitrary Intf for this quickCheck property?
07:13:16 <Lajexander> prop_mapmap f g xs = (map f $ map g xs) == map (f.g) xs
07:13:16 <Bobstopper> roconnor: Excellent! Let's be unwise together.
07:13:32 <roconnor> no painful surgery for me \o/
07:13:38 <kpreid> FransE: also, note that even things in typeclasses aren't necessarily functions. minBound, maxBound, mzero, mempty, ...
07:13:54 <Lajexander> type Intf = (Integer -> Integer)
07:14:00 <Bobstopper> Yeah, I'm not exactly envious of people who have wisdom teeth. Just so long as it doesn't mean I'm not wise ;)
07:14:16 <roconnor> I'm not wise ... just smart
07:15:01 <roconnor> @vixin do you have wisdom teeth?
07:15:01 <lambdabot> maybe. do you?
07:15:09 <roconnor> @vixin nope
07:15:09 <lambdabot> i didn't think so
07:20:44 <vincenz> wow
07:20:47 <vincenz> http://video.on.nytimes.com/ifr_main.jsp?nsid=b270dbb7b:10e7560ebb4:-d59&fr_story=650ff1e00d0677c95caaad8c9938664384ba9652&st=1161612644589&mp=FLV&cpf=false&fvn=7&fr=102306_101042_270dbb7bx10e7560ebb4xwd58&rdm=37590.18480253884
07:20:49 <lambdabot> http://tinyurl.com/y6jgd9
07:30:26 <Lajexander> how do i get an arbitrary function (Integer -> Integer) for quickCheck use?
07:32:55 <xerox> @check \f x -> (f (x :: Integer) :: Integer) == f x
07:32:56 <lambdabot>  OK, passed 500 tests.
07:33:01 <xerox> ^_^
07:33:20 <xerox> @check \f g x -> (f (x :: Integer) :: Integer) == g x
07:33:21 <lambdabot>  Falsifiable, after 1 tests: <Integer -> Integer>, <Integer -> Integer>, -1
07:34:12 <vincenz> o.O
07:34:16 <vincenz> how does it auto generate functions
07:34:28 <xerox> By its Arbitrary instance.
07:35:39 <unclear> Lajexander: morning.
07:37:11 <Lajexander> xerox: i have this:   prop_mapmap f g xs = (map f $ map g xs) == map (f.g) xs
07:37:26 <Lajexander> and a type declaration (for Integers)
07:37:32 <Lajexander> what more do i need?
07:37:47 <xerox> A type declaration?
07:37:58 <Lajexander> prop_mapmap :: (Integer -> Integer) -> (Integer -> Integer) -> [Integer] -> Bool
07:38:07 <xerox> Then you don't need nothing else.
07:38:25 <Lajexander> but it doesn't work
07:38:29 <kpreid> @check \f g xs -> (map f $ map g xs) == map (f.g) xs
07:38:29 <lambdabot>  Add a type signature
07:38:33 <xerox> How does it not work?
07:38:52 <kpreid> @check (\f g xs -> (map f $ map g xs) == map (f.g) xs) :: (Integer -> Integer) -> (Integer -> Integer) -> [Integer] -> Bool
07:38:56 <lambdabot>  OK, passed 500 tests.
07:39:06 <Lajexander> No instance for (Show (Integer -> Integer))
07:39:19 <xerox> Are you showing something?
07:39:39 <kpreid> quickcheck does if the tests failed
07:39:49 <Igloo> Does anyone else think that (abs minBound :: Int) should raise an error?
07:39:51 <xerox> Argh.
07:40:12 <kpreid> @checl \f -> f (x::Int) == const "y" x
07:40:13 <lambdabot>  Not in scope: `x'
07:40:16 <Lajexander> xerox: how do i get it working if i dont have lambdabot?
07:40:19 <kpreid> @check \f x -> f (x::Int) == const "y" x
07:40:20 <xerox> Igloo: hehe
07:40:20 <lambdabot>  Falsifiable, after 0 tests: <Int -> [Char]>, -1
07:40:31 <kpreid> Lajexander: define an instance for (Show (a -> b)).
07:40:51 <kpreid> instance (Show (a -> b)) where show _ = "<function>"
07:40:55 <xerox> show _ = "<function>"
07:40:57 <xerox> Right.
07:41:16 <kpreid> lambdabot's show only works for Data.Typeable, but gives the additional feature of printing the type of the function, but this isn't really necessary
07:41:24 <kpreid> > newUnique
07:41:24 <lambdabot>  Not in scope: `newUnique'
07:41:30 <xerox> Aww.
07:41:42 <xerox> > Data.Unique.newUnique -- ?
07:41:42 <lambdabot>  Not in scope: `Data.Unique.newUnique'
07:41:58 <kpreid> (Uniques aren't Typeable, you see)
07:42:07 <xerox> Ah.  Go figure.
07:42:15 <Lajexander> AIGHT! but what is this "<function>" ?
07:42:25 <xerox> It is a function.
07:42:26 <kpreid> Lajexander: it doesn't matter.
07:42:54 <Lajexander> weird... it's just a string if you ask me...
07:43:00 <xerox> Yes it is.
07:43:07 <xerox> It represents a function.
07:43:21 <xerox> It ignores the actual "value" of the function, you see?
07:43:29 <kpreid> Yes, it's an arbitrary string.
07:43:44 <Lajexander> very... weird
07:43:50 <xerox> Maybe a complete mathematical programming language would offer a better interface to values of functions :)
07:45:06 <Lajexander> > show (+)
07:45:07 <lambdabot>  Add a type signature
07:45:20 <Lajexander> ehm...
07:45:43 <Lajexander> > show (+:: Integer -> Integer)
07:45:43 <lambdabot>  Parse error
07:45:50 <Lajexander> > show ((+):: Integer -> Integer)
07:45:51 <lambdabot>    Expecting a function type, but found `Integer'
07:45:51 <lambdabot>    Expected type: Inte...
07:46:02 <xerox> > (id :: Int -> Int)
07:46:03 <lambdabot>  <Int -> Int>
07:46:13 <kpreid> > show ((+) :: Integer -> Integer -> Integer)
07:46:14 <lambdabot>  "<Integer -> Integer -> Integer>"
07:46:27 <kpreid> > show ord
07:46:29 <lambdabot>  "<Char -> Int>"
07:46:38 <xerox> > ord show
07:46:39 <lambdabot>    Expecting a function type, but found `Char'
07:46:39 <lambdabot>    Expected type: Char
07:46:39 <lambdabot>  ...
07:47:06 <kpreid> > fmap ord show
07:47:07 <lambdabot>  Couldn't match `Char' against `String'
07:47:20 <kpreid> er
07:47:22 <xerox> hehe
07:48:55 <hygge> "decide :: table -> io () decide (decision s) = do putstrln s" would have worked without the "do", right?
07:49:03 <hygge> decide :: table -> io () decide (decision s) = do putstrln s
07:49:17 <hygge> ah, you know where there are capitals.. :P
07:49:26 <Lajexander> is filter (p.q) xs valid?
07:49:59 <Lajexander> or should it be filter (p && q) xs?
07:50:34 <kpreid> hygge: do x is always the same as x, except it requires the type to be a monad
07:50:44 <kpreid> Lajexander: they mean different things
07:51:21 <Lajexander> which is equivalent to filter p $ filter q xs
07:51:25 <Lajexander> ??
07:51:34 <kpreid> the latter
07:51:35 <Cale> Lajexander: well, the second unfortunately won't have the right type. The first is valid but doesn't mean the same thing as the AND of both conditions
07:51:42 <kpreid> the former is filter p $ map q xs
07:51:49 <kpreid> er, no it isn't
07:51:52 <xerox> hygge: the do syntactic sugar works like this:
07:51:53 <xerox> do { let { binds; } in ... }  =  let { binds; } in do ...
07:51:53 <xerox> do { x <- amb; ... }  =  amb >>= \x -> do ...
07:51:53 <xerox> do { amb; ... }  =  amb >> do ...
07:51:56 <xerox> do amb  =  amb
07:51:59 <Lajexander> decide...
07:52:27 <kpreid> > fmap chr ord 'a'
07:52:28 <lambdabot>  'a'
07:52:30 <Cale> @pl \x -> f x && g x
07:52:31 <lambdabot> liftM2 (&&) f g
07:52:54 <Lajexander> @type liftM2
07:52:55 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:52:58 <Cale> You might want to write something like:
07:53:09 <Cale> f &&& g = f x && g x
07:53:11 <Cale> somewhere
07:53:19 <Lajexander> @type &&&
07:53:20 <lambdabot> parse error on input `&&&'
07:53:25 <hygge> hhmm xerox!
07:53:25 <Lajexander> oh
07:53:46 <xerox> Cale, don't overload Control.Arrow!
07:53:53 <xerox> hygge: yeah!
07:54:01 <xerox> ?type (&&&)
07:54:03 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:54:12 <hygge> so, if i just have one function to structure, there's no point in using the do?
07:54:25 <kpreid> I just realized that fmap is equivalent to (.).
07:55:04 <kpreid> hygge: yes.
07:55:23 <hygge> i wonder why my teacher did it then :P
07:56:25 <Cale> xerox: I'm betting that he isn't using Arrows at the moment :)
07:56:38 <Cale> but sure, use <&> for it or something :)
07:57:22 <metaperl> any ghc os x users here?
07:57:57 <xerox> Cale, I wanted to suggest them then! :)
07:58:00 <Itkovian> metaperl: I am
07:58:09 <Itkovian> still at 6.4 though
07:58:14 <metaperl> Itkovian: did youbuild from scratch?
07:58:32 <metaperl> the binary at haskell.org has /opt dependancies
07:58:37 <metaperl> the 6.6 one
08:01:02 <Itkovian> metaperl: no, I always get the binary distribution, my powerbook is overloaded as it is, without having to build ghc :-)
08:01:15 <metaperl> oh
08:01:29 <Itkovian> if it has a /opt dependency, that's bad, but can;t you symlink
08:01:34 <Itkovian> to the actual file?
08:02:55 <metaperl> Itkovian: interesting idea. I just threw a fit and deleted everything :)
08:06:18 <Itkovian> hehe
08:06:33 <Itkovian> should not take you too long to unpack it again
08:07:25 <metaperl> it's looking for libreadline.5.1.dylib ... my fink has 5.0
08:07:44 <metaperl> I just setup fink hugs... should be good enough to study Craft of FP
08:28:52 <therp> neato, my lisp-like haskell syntax frontend starts to gain form
08:45:28 <lray80de> Hi from the bulgarian eastcoast. Am relativly new on haskell and got stuck with the following problem: How can I merge 2 lists with the form [(char,int)] to [(char, int, int)]. e.g. [('t',0),('e',1)] merge [('t',2),('e',4),('s', 5)] to [('t',0,2),('e',1,4)]
08:46:24 <shapr> lray80de: What about making turning [(char,int)] into [(char,[int])] ?
08:46:58 <Lajexander> lray80de: check out the functions zip and unzip
08:47:27 <Lajexander> lray80de: http://haskell.org/hoogle
08:47:29 <lambdabot> Title: Hoogle
08:47:47 <lray80de> I know, with unzip, I can change it to ["tes",[something]...]
08:50:17 <lray80de> mmhhh... that's nice. knew about svon, but hoogle... great! Thnx for this hint.
08:51:34 <xerox> > map (fst . head &&& map snd) . groupBy (\(a,_) (b,_) -> a == b) . sort $ [('t',0),('e',1),('t',2),('e',4),('s', 5)]
08:51:35 <lambdabot>  [('e',[1,4]),('s',[5]),('t',[0,2])]
08:51:37 <xerox> Here it is.
08:53:31 <xerox> hehe, not exactly, you'll say.
08:53:52 <lray80de> give me another minute to understand it, please.
08:53:57 <xerox> Well, one can filter out unwanteds anyway.
08:54:42 <xerox> Sorry, too dense?
08:55:59 <lray80de> okay, you are sorting it, grouping it, and map it for the head...
08:56:09 <lray80de> ...gimme another 3 minutes to check it in ghci. ;-)
08:59:43 <Lajexander> lray80de: you using hugs as well? hugs tend to give nicer error messages than ghci =)
09:02:27 <Bourbaki> moin
09:04:22 <lray80de> Lajexander: The Debian-Pckages is just loaded down. :_)
09:04:42 <Bourbaki> dons still awake?
09:05:27 <Bourbaki> does anyone happen to know if theres something like mathlab or such for haskell?
09:07:45 <lray80de> how would I have to manage if I want to have it like [(char,int)] -> [(char,int)]->[(char,[int])]... so that [('a',3),('b',4),('a',5)] and [('a',2),('z',3),('a',5),('b',3)] would get to [('a',
09:08:27 <lray80de> how would I have to manage if I want to have it like [(char,int)] -> [(char,int)]->[(char,[int])]... so that [('a',3),('b',4),('a',5)] and [('a',2),('z',3),('a',5),('b',3)] would get to [('a',[3,2]),('b',[4,3]),('a',[5,5])]
09:09:02 <bill20r3> shapr?
09:09:20 <velco> lray80de: make a function to join a single element. pass it to zipWith
09:10:46 <shapr> bill20r3: what?
09:11:19 <bill20r3> remember me, with the Kinesis questions last week?
09:11:30 <shapr> Yes?
09:11:32 <bill20r3> I figured out what the macro-memory chip is, thought I'd come tell you.
09:11:38 <bill20r3> http://www.sparkfun.com/commerce/product_info.php?products_id=313
09:11:41 <lambdabot> Title: Spark Fun Electronics, http://tinyurl.com/yeagnw
09:11:42 <shapr> Oh cool!
09:11:50 <bill20r3> $.95 beats $50, by a lot.
09:12:10 <shapr> Truly :-)
09:12:11 <bill20r3> anyway, I just put it in, and it works fine, just make sure to reset the memories first thing.
09:12:23 <shapr> That's all you had to do?
09:12:31 <bill20r3> yeah, it was easy.
09:12:46 <bill20r3> the 'upgrade' is just that chip, no firmware changes or anything.
09:13:04 <shapr> Wow cool. My bigget recent wish is that kinesis made a bluetooth (or at least able to run on its own batteries) variant of their contoured keyboard.
09:13:12 <shapr> biggest*
09:13:28 <shapr> I have a Nokia 770, and I'd like to strap it between the fingerbowls to make a laptop :-)
09:13:40 <bill20r3> mine is that they weren't $200+, so I could get one for home too.
09:14:24 <shapr> I purchased two when I broke my first one, and transplanted part of that first one when I broke my second one. I'm now running half US and half Swedish keyboard.
09:14:55 <shapr> Er, I purchased a second one when my first one broke (due to a violent headbutt in the depths of extreme frustration, oops).
09:15:00 <bill20r3> aouch.
09:15:03 <xerox> Cybersurgery.
09:15:41 <bill20r3> there are 2 slots, so get 2 chips.
09:15:56 <shapr> bill20r3: Hey, did I already tell you about my "I am not a koala" key layout I'm using on the kinesis?
09:16:14 <bill20r3> no, who thought you were a koala?
09:16:34 <shapr> Whovever put the shift key under my pinky.
09:17:26 <shapr> My left arm blew out for nine months or so, at least partially because I was using my pinkies to do control, alt, shift, etc.
09:17:37 <shapr> When I got a kinesis I moved all of the modifier keys to my thumbs.
09:18:32 <shapr> The way I see it, thumbs should be used for chording, not pinky fingers.
09:18:45 <shapr> Plus it improves my typing speed.
09:18:53 <bill20r3> my pinkies still get pretty sore from my kb at home.
09:18:54 <xerox> It really makes sense, looking at the shape of the hands.
09:19:02 <bill20r3> I should really spring for another kinesis.
09:19:16 <bill20r3> I could write it off my taxes too.
09:19:20 <shapr> yeah!
09:19:36 <xerox> They cost quite a bit, though.
09:19:50 <bill20r3> most "normal" typists dont use control a lot, but geeky types hit it all the time.
09:20:40 <shapr> 'emacs pinky'
09:20:51 <Lajexander> lray80de: did you solve it?
09:21:04 <shapr> bill20r3: Anyway, thanks for the info.
09:21:10 * shapr gets back to coding.
09:21:25 <lray80de> working on the function. need some longer because of lack of knowledge. :-)
09:21:46 <bill20r3> no problem shapr, spread it around if you know any other kinesis users, $50 is way too much.
09:21:52 <bill20r3> seeya later.
09:22:04 <Philippa_> one way around emacs pinky - use part of the palm instead
09:22:07 <Philippa_> bah, bad timing
09:24:57 <Lajexander> lray80de: check out lookup and fromJust (you get it with import Maybe)
09:43:49 <lray80de> Lajexander: Tried the following, but it's not working right now: jaroGetTranspositions :: [(Char, Int)] -> [(Char,Int)] -> Int jaroGetTranspositions [] _ = 0 jaroGetTranspositions _ [] = 0 jaroGetTranspositions ((c1:i1):xs) l2 = i1 + (fromJust(lookup c1 l2)) + (jaroGetTranspositions xs l2)
09:45:02 <lray80de> okay, got it.
09:45:13 <lray80de> c1:i1 should be c1,i1
09:49:55 <Renkin> is the where clause in functions just a lexical thing, or does it improve efficiency?
09:50:27 <Renkin> if I do   where something = function_calls  where something is used a lot in a function
09:50:48 <Renkin> or in the function, rather
09:52:18 <Philippa_> then yes, it'll improve efficiency
09:52:25 <Renkin> ok, thanks
09:52:28 <Renkin> good to know :)
09:52:30 <Philippa_> at least, in every sane implementation
09:52:48 <Philippa_> (hypothetically, a legit haskell implementation could use a call-by-name evaluation strategy)
09:53:09 <Renkin> I'm not sure what that means
09:54:29 <Renkin> oh wait, I do :)
09:54:56 <Renkin> but I'm supposing GHC counts as a sane implementation?
09:58:29 <Renkin> I suppose, even
09:59:32 <shapr> god morgon!
09:59:43 <Renkin> god morgon i stugan
10:00:04 <vegai> god kvll
10:00:10 <Renkin> jo, snarast
10:00:43 <Cale> Renkin: yeah
10:00:55 <Cale> GHC is sane in that regard :)
10:01:07 <Renkin> alright :)
10:01:18 <Renkin> are you saying there's a better Haskell 98 implementation?
10:01:24 <Cale> nope :)
10:01:26 <Renkin> that can compile native code
10:01:28 <Renkin> ah, ok
10:01:44 <Cale> There are others, but all the major ones use lazy evaluation
10:02:04 <Cale> (whereas all the standard guarantees are nonstrict semantics)
10:02:12 <Renkin> I thought laziness was part of the Haskell definition
10:02:17 <Cale> Not quite
10:02:19 <Renkin> ah
10:02:28 <Cale> Just the effects of laziness -- what the programs actually compute
10:02:35 <Renkin> oh, ok
10:02:52 <Renkin> laziness makes it really cool, anyhow :)
10:03:28 <ValarQ> Renkin: short visit in #haskell.se
10:03:29 <Cale> So an implementation is allowed to try to be clever and evaluate something strictly for a while if it thinks it will help, so long as it won't spend forever when that thing is nonterminating.
10:03:44 <Renkin> ValarQ: yes, few people and no answer =)
10:04:03 <lisppaste2> fons pasted "LADSPA plugin interface" at http://paste.lisp.org/display/28560
10:04:26 <fons> Hi all
10:04:29 <Cale> hello
10:04:38 <fons> I'm trying to port LADSPA to haskell
10:04:43 <Cale> yeah :)
10:05:09 <fons> which implies porting this header http://www.ladspa.org/ladspa_sdk/ladspa.h.txt
10:05:26 <fons> as you see in the paste I already specified types
10:05:41 <fons> and now I would like to export them to the C marshaler I'm coding
10:05:45 <Renkin> Cale: yeah, I was pretty amazed when I first saw how fast you could get the 10000:d fibonacci number and things like that, with an easy function
10:06:01 <Renkin> but I guess that's what makes the binaries very large when you compile?
10:06:03 <fons> I went trhough the FFI
10:06:12 <Lajexander> lray80de: PM
10:06:34 <fons> but this case I guess it's a bit special cause I'm not really exporting functions but an interface
10:06:49 <fons> (the funcions should be added by the plugin programmers by using the interface)
10:06:56 <fons> ANy advices about how to go?
10:07:14 <Cale> Renkin: the thing that makes the binaries large is that they're statically linked against the Haskell runtime
10:07:16 <lray80de> ? - will try "delete" from the List-Module. :_)
10:07:45 <lray80de> Lajexander : ? - will try "delete" from the List-Module. :)
10:08:02 <Renkin> Cale: I see
10:08:12 <Lajexander> lray80de: join #data06
10:08:21 <Renkin> Is there a way to separate it from the runtime?
10:08:32 <Cale> Renkin: GHC has support for dynamic linking on OS X, I'm not sure about how things are going on other platforms.
10:08:54 <fons> My plan right now is to export the types on that file
10:08:55 <Renkin> alright. I guess that's fairly easy for me to look up
10:09:03 <shapr> fons: Turn it into a typeclass, or maybe export constructors but not a type that represents the interface?
10:09:37 <fons> shapr, if I make a type class I can export it easily?
10:11:18 <Renkin> what's an disadvantage with lazy evaluation? that's a question on an old exam I'm looking at
10:11:26 <Renkin> a
10:11:35 <shapr> Yes. You probably want to make the typeclass a more Haskellesque representation of LADSPA.
10:13:15 <shapr> Renkin: Most people don't understand lazy eval well enough to fix space leaks :-)
10:13:43 <lray80de> Lajexander: Don't understand. But am using "delete" right now... looks terrible, but works. :o)
10:14:59 <Renkin> shapr: ok :) so a disadvantage could be that it's hard to know what's going on beneath the surface
10:15:57 <fons> shapr, thats a good idea
10:16:40 <musasabi> lazy evaluation makes some semantics harder.
10:17:21 <musasabi> and can make things more complicated when values have to be serialized etc
10:17:29 <musasabi> and error handling.
10:21:33 <fons> Can anyone point me to am example of a haskell program exporting functions and types through the FFI?
10:23:32 <fons> or an example of shared library coded in haskell?
10:24:09 <palomer> I'm back!
10:24:19 * palomer waits for the cheers and jeers
10:25:17 <sjanssen> @palomer
10:25:17 <lambdabot> Brump!
10:25:31 <sjanssen> I'm not sure whether that's a cheer or a jeer.
10:31:26 <palomer> anything happened while I was gone?
10:32:14 <Lajexander> i bought candy
10:32:40 <palomer> was it good?
10:32:49 <Philippa_> fons: hs-plugins
10:33:41 <Lajexander> nah... they didn't have any of those white crayons
10:33:57 <fons> thanks a lor Philippa_
10:34:02 <fons> lot
10:36:49 <dcoutts_> would someone with ghc-6.6 mind checking if "HsTime.h" exists anywhere in their ghc-6.6 install? e.g. under /usr/lib/ghc-6.6/
10:37:55 <Lajexander> i have a list and want to se if the elements are all equal, what function should i use?
10:38:14 <SyntaxNinja> > [1,2,3] == [1,2.3]
10:38:16 <lambdabot>  False
10:38:17 <Igloo> dcoutts_: /usr/lib/time-1.0/ghc-6.6/include/HsTime.h is in libghc6-time-dev
10:38:19 <SyntaxNinja> hehe
10:38:45 <dcoutts_> Igloo, did you build that with Cabal ?
10:38:48 <Igloo> Yes
10:38:51 <SyntaxNinja> Lajexander: probably sort + ==
10:39:05 <Lajexander> Syntax: danke
10:39:22 <mauke> @type and . (tail >>= zipWith (==))
10:39:24 <lambdabot> forall a. (Eq a) => [a] -> Bool
10:41:39 <Lajexander> (\\) = foldl (flip delete) <-- WTF? could someone please explain how this works?
10:41:54 <mauke> @type delete
10:41:55 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:42:19 <Lajexander> @type flip
10:42:20 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
10:42:41 <Cale> Lajexander: The first parameter to (\\) is the list to remove things from
10:42:46 <Cale> it starts with that list
10:42:57 <Lajexander> yeah
10:42:59 <Cale> as the initial value
10:43:14 <Cale> and then proceeds to delete each of the things in the *second* list from it
10:45:01 <Lajexander> why flip?
10:45:01 <palomer> Cale!
10:45:07 <Cale> > foldl (\xs x -> "(flip delete " ++ xs ++ " " ++ show x ++ ")") "[1,2,3,4,5]" [2,3,5]
10:45:08 <lambdabot>  "(flip delete (flip delete (flip delete [1,2,3,4,5] 2) 3) 5)"
10:45:14 <Cale> palomer: hi!
10:45:27 <mauke> Lajexander: do you know what flipd does?
10:45:29 <palomer> what's happened in haskell world in the last 3 months?
10:45:37 <Lajexander> mauke: yeah
10:46:08 <emu> nothing ever changes
10:46:09 <Cale> palomer: GHC 6.6 has been released, and we have a ByteString library where natural looking programs are starting to beat C programs :)
10:47:12 <Cale> (because of high-level optimisation techniques which dons and dcoutts worked very hard on getting right :)
10:47:15 <palomer> any big API changes in 6.6?
10:47:54 <Cale> There's Data.Sequence, Data.Foldable, Data.Traversable, Control.Applicative
10:48:01 <mauke> the function monad is somewhere else now
10:48:17 <Cale> It's in Control.Monad.Instances
10:48:26 <palomer> Traversable sounds like Functor
10:48:35 <Cale> There's an XHtml library
10:48:43 <palomer> any language changes?
10:48:46 <Cale> palomer: but Functor doesn't traverse things in an ordered way
10:48:52 <Cale> Impredicativity
10:48:58 <Cale> (boxy types)
10:49:21 <palomer> that's in the type system, no?
10:49:24 <Cale> yeah
10:49:28 <Cale> bang patterns for strict parameters
10:49:29 <palomer> I'm talking linguistic changes
10:49:46 <Cale> that is a linguistic change, isn't it?
10:49:55 <Cale> The type system is part of the language :)
10:50:11 <Cale> Haskell wouldn't function at all without types
10:50:28 <palomer> hrmph
10:50:31 <palomer> fair enough
10:50:35 <Cale> (What would show do? :)
10:50:49 <palomer> though when I speak of language, I'm thinking of syntax (and to a lesser extent semantics)
10:51:24 <Cale> GADTs can now use record syntax
10:51:52 <Cale> which lets you do things which look a whole lot like OO programming
10:52:48 <palomer> I have emotional issues towards GADTs
10:53:05 * shapr boings cheerfully
10:53:21 <Philippa_> heh
10:54:04 <tora> Cale: is there an example of that somewhere?
10:54:27 <Cale> yeah, on the old wiki...
10:54:45 <tora> cool cheers
10:54:46 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
10:54:48 <lambdabot> Title: Existentially quantified record constructors - The Haskell Wiki, http://tinyurl.com/y29ory
10:54:48 * edwinb runs away from the things which look like OO programming
10:54:49 <Cale> http://www.haskell.org/hawiki/GADT_20with_20record_20syntax
10:54:51 <lambdabot> Title: GADT with record syntax - The Haskell Wiki, http://tinyurl.com/scqak
10:55:31 <Cale> (the first is a better example of how to do OO-like things with it)
10:56:39 <emu> what do people think of module functors (like in SML) becoming part of Haskell?  or is it somewhat obviated by type classes?
10:57:39 <Cale> emu: somewhat... lots of people want something to be done to the module system, but what exactly to do is unclear
10:58:20 <edwinb> I gather the Haskell designers felt that type classes did the same thing
10:58:21 <Cale> It seems like module functors would produce a lot of overlap with typeclasses, but maybe that's not so horrible
10:58:42 <Cale> They're translatable into one another.
10:58:54 <Philippa_> hs-boot files look suspiciously like signiatures
10:58:57 <Cale> But some things are more convenient in one or the other
10:59:15 <Philippa_> like overloading? ;-)
10:59:31 <Cale> hehe, yeah
10:59:36 <emu> one thing i disliked about SML's modules and signatures was the repetition of information
10:59:40 <Cale> using multiple classes in one expression is easy
11:00:08 <Cale> Another thing is the whole lie in the standard about cyclic dependencies being allowed
11:00:51 <Philippa_> emu: yeah, though the export list of a haskell module is all but a signiature too once you've done type inference
11:00:57 <emu> yep
11:01:00 <Cale> My view (I was arguing the other day about this) is that GHC should be able to handle them, and just bite the bullet and compile (or at least typecheck) things together when there aren't enough user-provided type signatures to do it separately.
11:01:08 <emu> but you only need to specify the type once, if at all.
11:01:13 <emu> i know it's necessary at some points though
11:01:32 <emu> i believe there's a proof in SML that functions in a module need explicit types, in the HM type system
11:01:58 <Cale> (and probably emit a warning saying that separate compilation is being lost because you didn't provide typesignatures on such and such values)
11:01:59 <Philippa_> Cale: if it lets me do some of the filthy things I've thought of using recursive module dependencies, I'm all for it
11:02:25 <Philippa_> In the cases in question I can handle a loss of separate compilation
11:02:52 <Cale> right, it should just work first of all, and secondly provide a means to speed things up
11:03:21 <Cale> not prevent the user from compiling because the performance would be suboptimal :)
11:05:56 <fons> shapr, thanks a lot for sugesting classes, the exports to C can now be made in a really elegant way
11:06:29 <fons> class Ladspa where ....
11:07:21 <fons> class Ladspa a => LadspaMarshaler a where ...
11:09:11 <astrolabe> Can anyone guess what might be causing hat make to give the following errors?  ./Hat/EHM2Alt.hs:316:32: Not in scope: `Hat.Ix.grange'
11:09:12 <astrolabe>  
11:09:12 <astrolabe> ./Hat/EHM2Alt.hs:331:29: Not in scope: `Hat.Ix.gindex'
11:09:12 <astrolabe>  
11:09:12 <astrolabe> ./Hat/EHM2Alt.hs:342:29: Not in scope: `Hat.Ix.ginRange'
11:17:13 <jajs> York and Edinburgh seem to be nice places for haskell-related programming
11:18:42 <tibbe> OT: anyone here live in Zurich?
11:28:33 <dcoutts_> jajs, and Oxford! :-)
11:30:05 <swiert> and Nottingham!
11:31:40 <kolmodin> and Gteborg..!
11:32:37 <Lajexander> gtet is the shit =)
11:33:56 <pejo> Heh, is there anyone in this channel who is at a university that doesn't do any kind of fp?
11:34:10 <pejo> Hm. That wasn't what I meant. I know there are plenty of people not at universities.
11:34:38 <sieni> so what did you mean?
11:35:36 <pejo> Of those who are at universities, how many would end up in here if there was nothing related to fp?
11:35:54 <mauke> 2
11:36:57 <jajs> dcoutts, and what about Cambridge ?
11:37:12 <dcoutts_> jajs, they mostly do ML there I think
11:41:10 <shapr> fons: yay
11:41:17 <cjay> at my uni I had to learn some ML in first semester, but it was replaced completely by java. there is no fp left here, as far as I know.
11:43:57 <therp> the vienna university of technology (=my university) made haskell programming mandatory for some branches of the CS major
11:44:19 <Wallbraker> same at Chalmers in Sweden
11:44:44 <Lajexander> Our haskell course at Chalmers is the first thing we do when we start at CS
11:45:13 * vegai has a healthy dose of envy.
11:45:19 <Lajexander> Though, I didn't have Hughes :/
11:45:56 <therp> but we also have plenty of java.. *sigh*
11:45:58 <Wallbraker> He had a guest lecture in our fp course.
11:46:13 <Lajexander> Wallbraker: Vem r du?
11:46:51 <shapr> Jag r Shae. Och jar bor i USA.
11:47:12 <Wallbraker> Lajexander: Jakob Bornecrantz, gick fortsttnings r ifrn lindholmen frra ret nu konsultar jag t Nokia i finland
11:47:12 <Lajexander> Wallbraker: --> #data06 ; vran egen svennekanal p freenode
11:47:37 <Lajexander> ah, ballt
11:48:07 <Lajexander> *snabbmakaron + pesto + ketchup-dags*
11:48:28 <Wallbraker> Tog en liten pause i pluggandet, blev lite vl trt p det hela efter Milj skiten
11:49:43 <enacted> The world has a java addiction.
11:49:58 <syntaxfree_afk>  pejo: Im in an university, in the masters program, actually,  but they don't do any kind of FP.
11:49:58 <syntaxfree_afk> Of course, it's a graduate program in economics.
11:50:26 <Wallbraker> enacted: Indeed, working with at Nokia...
11:50:36 <tibbe> Wallbraker: still hanging out here? :)
11:51:38 <Wallbraker> tibbe: Well I configured my Irssi set just the way I want it and if I remove the haskell channel all the other channels will move around...
11:51:53 <tibbe> heh
11:53:25 <cjay> Wallbraker: you could disable autoclosing ;)
11:54:08 <Wallbraker> cjay: still be a problem if/when the server where I run irssi goes down.
11:54:10 <syntaxfree_afk> It's a question of marketing.
11:54:10 <syntaxfree_afk> Geeks love caffeine.
11:54:10 <syntaxfree_afk> "Java"...
11:54:10 <syntaxfree_afk> Haskell should have been called "Theobromine" or something.
11:54:11 <syntaxfree_afk> Maybe just "tea"
11:54:36 <Wallbraker> syntaxfree_afk: Haha
11:55:56 <Wallbraker> Its not so much the Geeks as the Managment, there are two big buzz words, Java and .Net, so when the managment ask the geeks what they want to program in the choise the lesser of two evils
11:56:33 <enacted> I'd actually rather use C# than Java, but I'd prefer neither.
11:56:55 <syntaxfree_afk> "Monad" is a cool buzzword.
11:56:57 <enacted> It's like choosing which shoe to have someone defecate in.
11:57:57 <Wallbraker> enacted: question of taste... It also helps java that J2EE is such a accepted standard and it can run on many platforms
11:58:00 <syntaxfree_afk> In any case, it's more of a network effects problem than a buzzword problem proper.
11:58:00 <syntaxfree_afk> At Nokia, people prolly use Java because most cell phones run java apps.
11:58:04 <palomer> what happened to Control.Monad.State?
11:58:24 <enacted> I'm not talking from a pragmatic perspective, but rather simply a matter of taste in terms of language preference.
11:58:41 <palomer> myself, I prefer to defecate in boots
11:58:58 <enacted> Clearly no one that wasn't developing on/with Mono would care much for .NET for anything that needed to run off of a Microsoft platform.
11:59:30 <Wallbraker> syntaxfree_afk: Its not a phone I'm working on, its a SmsGateway. Which shuffles about 350000 sms/month.
11:59:45 <Wallbraker> phone app*
12:00:42 <syntaxfree_afk> hm. why java, then?
12:00:55 <Wallbraker> application servers I think...
12:01:09 <syntaxfree_afk> I bet you can write your own modules in Malbolge and just link them against the main program anyway.
12:01:29 <Wallbraker> Indeed I probably could.
12:01:49 <palomer> aoe
12:02:32 <palomer> ok, hoogle agrees with me
12:02:35 <syntaxfree_afk> Malbolge is VERY portable.
12:02:37 <palomer> Control.Monad.State should exist
12:03:17 <Wallbraker> syntaxfree_afk: its probably the whole J2EE standard, JMS, Beans and the lot.
12:03:54 <palomer>     Could not find module `Control.Monad.State': <--has haskell gone mad??!?
12:04:51 <glguy> palomer: Did you compile GHC on your own? and now you can't find Control.Monad.STate in your installation?
12:05:13 <palomer> I did apt-get install ghc6
12:05:26 <glguy> palomer: OK, look for an extralibs package
12:05:33 <glguy> extralibs contains the MTL package
12:05:38 <glguy> which is where State resides
12:08:38 <palomer> can't find extralibs
12:09:13 <glguy> Well... when you do, that's where you'll find State
12:09:25 <Igloo> Install libghc6-mtl-dev
12:10:07 <glguy> What distribution has all of the extralibs broken out into separate packages?
12:10:43 * monochrom  haskell
12:11:35 <glguy> what character is that? I don't seem to have it in any font so far?
12:12:19 <velco> a heart
12:12:46 <Cale> 
12:12:47 <monochrom> U+2661 "white heard suit"
12:13:12 <Cale> 
12:13:49 <Cale>  would make a good operator symbol
12:14:03 <monochrom> sometimes
12:14:12 <mbishop> only club and spade show up for me, must be missing some fonts heh
12:14:24 <int-e> and   ...
12:14:41 * glguy wishes he was on his latop, which would show all of these characters
12:14:53 <jmmv> hi
12:14:54 <int-e> three different diamond signs ...
12:14:55 <Cale> Right, I should have used 
12:15:04 <monochrom> Install Ubuntu!
12:15:13 <Cale> Or just more fonts :)
12:15:40 <glguy> I'll leave Ubuntu to the Linux users
12:15:47 <monochrom> Install Windows!
12:15:51 <SimonRC> unicode coverage in most fonts sucks
12:16:04 <sieni> Install a FORTRAN IV compiler!
12:16:14 <SimonRC> BTW, how well does Haskell support unicode?
12:16:15 <glguy> My laptop has OpenBSD, and a font that has a TON of unicode characters
12:16:15 <sieni> The last Real Programming Language (TM)
12:16:21 <Cale> SimonRC: that's why you need your font library to steal things from similar fonts when the characters don't exist
12:16:23 <glguy> some ucs-misc font
12:18:21 <glguy> Does anyone here use LaTeX and know how to get it to use old-style digits aka text-figures?
12:18:54 <Cale> don't use $$
12:19:12 <Cale> It'll use text figures in non-math mode
12:19:36 <Cale> You could also put them in an \mbox{}
12:19:48 <Cale> or possibly \hbox{}
12:19:48 <SimonRC> I know Char is a unicode character, but does/will Haskell allow stuff like variables called , or using  for \, or  for ->,  for <=,  for | (for guards)?
12:20:24 <Cale> SimonRC: GHC is gaining support for unicode
12:20:37 <Cale> SimonRC: I think it at least allows unicode characters in source files now
12:20:45 <Cale> GHCi still doesn't
12:20:46 <roconnor> SimonRC: variables ought to be in italics ;)
12:20:52 <Cale> (on the prompt)
12:21:08 <psi> Cale: I tried  in 6.6. it didn't work.
12:21:16 <Cale> psi: yeah, it's a symbol name
12:21:30 <Renkin> how would I make a function gen :: IO [Int] that generates an infinite list of random integers?
12:21:39 <glguy> Cale: do I need to specify a non-default font for your suggestions to worki?
12:21:41 <roconnor> @hoogle gen
12:21:42 <lambdabot> Test.QuickCheck.Gen :: data Gen a
12:21:42 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
12:21:42 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
12:21:42 <psi> Cale: what does that mean?
12:21:51 <roconnor> @hoogle genRandom
12:21:51 <lambdabot> No matches found
12:21:54 <Cale> Renkin: gen = do g <- newStdGen; return (randoms g)
12:22:07 <monochrom> If you write a linear algebra library in Haskell, you can use  for eigenvalues
12:22:08 <psi> that it works as variable name?
12:22:14 <sjanssen> psi: some special characters do work though, like forall
12:22:14 <roconnor> @types randoms
12:22:16 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
12:22:20 <roconnor> ah
12:22:30 <Renkin> Cale: thanks. I don't get IO very  well yet
12:23:15 <monochrom> You can write in Greek and Chinese in comments.
12:24:05 <Cale> psi: I think so, or else an infix op (which would be ugly)
12:24:24 <Renkin> What do I need to import?
12:24:29 <Renkin> For Gen
12:24:31 <Cale> System.Random
12:24:38 <Renkin> ok
12:25:04 <palomer> libghc6-mtl-dev simply install ghc6
12:25:50 <palomer> installs, rather
12:26:03 <monochrom> palomer is back?!
12:26:11 <mux> !
12:26:15 <mux> @palomer
12:26:16 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
12:26:20 <psi> Cale: right. 'main = let  = 42 in print ', for instance.
12:26:26 <palomer> ghc6-libsrc - Library Sources of GHC, the Glasgow Haskell Compilation system <---could this be what I want?
12:26:28 <palomer> monochrom!
12:26:34 <psi> Cale: works, for instance*
12:27:45 <Cale> Has anyone got a decent Ubuntu package for GHC 6.6?
12:27:49 <Igloo> palomer: Which version of GHC, and what arch?
12:28:02 <palomer> ghc6.6
12:28:07 <palomer> x86
12:28:11 <palomer> debian/unstable
12:28:13 <Igloo> libghc6-mtl-dev is a separate package, then
12:28:38 <palomer> Note, selecting ghc6 instead of libghc6-mtl-dev
12:29:57 <palomer> and apt-cache show libghc6-mtl-dev comes up empty
12:31:04 <Igloo> Either you're out of date or the package haven't reached the mirrors yet, then
12:31:20 <lispy> hmm..the libraries@ list seems broken
12:31:29 <lispy> emails come through in arbitrary order for me
12:32:16 <lispy> and i'm really surpsied with all the surpurfulous(sp?) commenting about naming that one one commented on my suggestion for 'unsplit' (instead of the confusing 'join')...which makes me think my email didn't even come through in the last couple days
12:32:24 <palomer> ok, apt-get update fixed all that
12:32:33 <lispy> yay, apt!
12:32:37 <palomer> superfluous
12:32:44 <lispy> palomer: thanks
12:32:53 <palomer> np
12:33:02 * lispy tries to commit that one to memory
12:33:14 <fons> shapr, uhm I was happy too soon ... I got a problem implementing the class due to the polymorphic parameters
12:33:20 <shapr> uh oh
12:33:42 <shapr> palomer: The working packages seem to have reached my mirrors.
12:33:53 <palomer> Text.Html is gone!
12:33:56 <x3m2> @seen foxy
12:33:56 <lambdabot> I saw foxy leaving #haskell 10h 52m 40s ago, and .
12:33:58 <lispy> but more ot the point, on the libraries@ list, my email client can't seem to keep threads together and i very frequently see the replies to things before i see the OP
12:34:02 <palomer> shapr, yeah, an update fixed everything
12:34:50 <fons> shapr, if you have a look at http://paste.lisp.org/display/28560
12:35:12 <fons> shapr, the type descriptro has 2 parameters
12:35:18 <fons> Descriptor I meant
12:35:38 <fons> I'm trying to translate that type to a class
12:37:32 <Lajexander> @hoogle group
12:37:33 <lambdabot> List.group :: Eq a => [a] -> [[a]]
12:37:33 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
12:37:33 <lambdabot> System.Console.Readline.beginUndoGroup :: IO ()
12:38:01 <shapr> fons: I don't understand the problem really, but I think either multiparameter typeclasses or functional dependencies will fix it.
12:38:24 <fons> functional dependencies?
12:39:06 <fons> shapr, what I want to do is turning the Descriptor type into a class
12:40:33 <monochrom> Hmm next time palomer asks "I have corrected my type signature but ghc is still giving the same error message", a good heuristic is "have you saved?"
12:40:40 <SimonRC> @SimonRC
12:40:40 <lambdabot> Unknown command, try @list
12:40:43 <SimonRC> :-(
12:43:11 <palomer> monochrom, I haven't asked that yet!
12:43:20 <palomer> don't get too cozy, though; it's a coming
12:43:47 <monochrom> hee hee hee
12:43:51 <int-e> lispy: I saw a mail from you, but no reply
12:44:51 <int-e> lispy: and personally I won't jump in - Haskell has some weird names already, most notably 'nub', one more won't do much harm.
12:46:00 <xerox> Type classes are relations on types, right?
12:46:35 <xerox> Cale?
12:46:38 <Cale> xerox: that's how I treat them
12:46:46 <xerox> Good.
12:46:56 <xerox> And functional dependencies make them functions.
12:47:07 <monochrom> multiple parameter type classes are imagined as relations
12:47:18 <xerox> Yes sorry, I meant multi parameter ones.
12:47:26 <xerox> A single parameter type class is a set of types.
12:47:33 <monochrom> But I think there is something more general coming.
12:47:58 <xerox> What are you thinking of?
12:48:30 <monochrom> Associate types or some name like that
12:48:57 <audreyt> associated types (or type families). it's already in GHC head
12:49:09 <Renkin> what's a higher-order function, exactly?
12:49:22 <monochrom> You know, that work on unifying ML modules and Haskell type classes and fundeps and ...
12:49:54 <monochrom> A function that may take functions as parameters or give functions as results.
12:50:16 <palomer> do I have to install any debian package for Text.Html?
12:50:23 <palomer> or has Text.Html been deprecated?
12:50:25 <Renkin> alright
12:50:56 <palomer> what is the world coming too??!?
12:51:25 <Renkin> isn't there a Text.XHtml, too?
12:51:31 <audreyt> palomer: it's in extralibs
12:51:43 <audreyt> I _think_ debian should pack extralibs as part of ghc metaport reeally
12:51:44 <Renkin> XHtml sounds less deprecated :)
12:51:48 <audreyt> but they somehow doesn't do that
12:51:49 <glguy> palomer: Your distribution is causing all of these issues (or at least your use of your distribution)
12:51:54 <audreyt> Renkin: no, both are in extralibs
12:51:59 <Renkin> ah
12:53:23 <Cale> I wonder how compatible Text.XHtml.Transitional is
12:53:35 <palomer> oh why oh why have the libraries been fragmented?
12:53:57 <audreyt> palomer: Cabalization
12:54:06 <audreyt> decouple library release from GHC releases
12:54:14 <audreyt> good idea, hurts people ;)
12:54:19 * palomer is hurt
12:54:25 <lispy> int-e: yeah, the name of join is less of a concern than the way the mail list is behaving to my reader :(
12:54:26 <audreyt> the HQ offseted it by having bindists autobundle extralibs as usual
12:54:30 <audreyt> but you are not using bindist, are you :)
12:54:31 <palomer> Network.cgi isn't in libghc6-network-dev :(
12:55:18 <int-e> lispy: well, it seems fine here (using mutt)
12:55:51 <palomer> where oh where is Network.cgi ?
12:55:54 <glguy> lispy: is this discussion in -cafe? or the other list?
12:55:56 <palomer> Network.CGI
12:56:21 <lispy> glguy: it was on libraries@ iirc
12:56:31 <lispy> glguy: that's the only one that seems to confuse gmail
13:00:38 <palomer> has Network.CGI been replaced with WASH.CGI?
13:01:18 <glguy> lispy: so what word was decided on instead of "join"?
13:01:49 <glguy> 'intercalate' ?
13:02:23 <palomer> libghc6-http-dev: Depends: ghc6 (< 6.4.2-999) but 6.6-1 is to be installed <-- !
13:02:41 <xerox> audreyt: what do the associated types look like in GHC?
13:02:41 <xerox> audreyt: is that System F with equality coercions?
13:02:48 <audreyt> xerox: yes, it's system Fc
13:03:49 <lispy> glguy: yeah :(
13:04:15 <lispy> glguy: but that's okay, i'll just do unsplit = intercalate in my modules :)
13:04:33 <glguy> heh
13:04:34 <lispy> and then unsplit . split will makes sense (modules the appropraite arguments)
13:04:47 <glguy> I'm just glad that it wasn't called "join" (c:
13:04:48 <lispy> (er modulo)
13:04:50 <palomer> how do I find out which  submodules are under Network?
13:05:36 <xerox> audreyt: do you know if darcsgetting the repo, is it buildable in a straightforward way on OSX/Intel?
13:08:34 <xerox> I'm curious to see that.
13:18:24 <palomer> ok, someone help me find Network.CGI or I'll shoot!
13:19:40 <Philippa_> Network.CGI.Compat?
13:21:03 <palomer> it can't find CGI
13:21:06 <palomer> let alone CGI.Compat
13:21:13 <palomer> what replaced it?
13:21:21 <Philippa_> no idea
13:22:01 <Philippa_> it's in a package cgi, do you have that installed?
13:22:23 <palomer> I have libghc6-network-dev
13:23:06 <palomer> can't find package cgi
13:33:19 <dreamEye> I get the error  "prelude read: no parse" at runtime
13:34:03 <monochrom> > read "hello" :: Int
13:34:05 <lambdabot>  Exception: Prelude.read: no parse
13:34:09 <monochrom> Like that?
13:34:14 <dreamEye> how I can get the source code line printed with the message?
13:34:25 <dreamEye> yes
13:34:31 <monochrom> Oh ha oops can't.
13:34:45 <dreamEye> I use read in many places
13:34:47 <dreamEye> why?
13:35:12 <xerox> Because Haskell's declarative.
13:35:19 <dreamEye> why I have "incomplete patter match" with line number and "prelude read: no parse" withour?
13:35:23 <monochrom> Guess you'll have to do it the Holmes way.
13:35:24 <dreamEye> without
13:36:22 <dreamEye> the trace way?
13:37:21 <monochrom> The eliminate-the-suspects way.
13:37:43 <dreamEye> may be a deep mathematical reasons why GHC does this in this way, but this is funny for ordinary programmers
13:38:05 <monochrom> Nothing deep.  Just nobody gets around to implement it.
13:38:21 <sjanssen> dreamEye: it's tricky to give a stack-trace-like error message in a lazy language
13:38:23 <Renkin> when I put "free (Just s) = s" in the where clause of a function, am I actually defining a local function, or is it more like a macro thing?
13:38:39 <Renkin> is it even good practise?
13:38:43 <Philippa_> it's a local function, and it behaves a lot like a macro
13:38:45 <xerox> `free' is a function from Maybe a to a.
13:38:47 <Philippa_> but then functions do
13:38:49 <dreamEye> note even with debug level 1^10000?
13:39:01 <sjanssen> Renkin: best practice there is to use fromJust
13:39:02 <Philippa_> or rather, bindings do
13:39:02 <Renkin> Philippa_: ok, yeah
13:39:16 <Renkin> sjanssen: oh, didn't know there was one =)
13:39:22 <xerox> Best practice is probably to define total functions most of the time.
13:39:26 <sjanssen> Renkin: but in GHC with -O, that defn. will probably be inlined
13:39:43 <Renkin> ok
13:40:12 <Renkin> I'll just use fromJust here, I guess
13:40:21 <monochrom> "read: parse error" is something characteristic to toy programs, for various reasons.
13:40:25 <dreamEye> sjanssen in dont need a stack trace, I just wanted the line number
13:41:15 <xerox> Lemmih: what about your breakpointer?
13:41:59 <dreamEye> it is not a toy program, is a multithreaded  program with STM
13:42:11 <sjanssen> dreamEye: use readsPrec and handle your errors properly
13:42:28 <shapr> I think someone did do stack traces for Haskell, but nobody could understand them.
13:42:44 <sjanssen> @type readsPrec
13:42:45 <lambdabot> forall a. (Read a) => Int -> ReadS a
13:42:49 <monochrom> hee hee
13:43:12 <xerox> Anybody knows what the various branches of GHC on darcs.haskell.org are?
13:43:23 <monochrom> I think I can agree that "ordinary programmers" write toy programs.
13:43:37 <dreamEye> hiw readSprec can help on that?
13:44:19 <palomer> even haskell-mode has changed
13:44:21 <dreamEye> how, sorry
13:44:23 <palomer> everything is broken!
13:44:32 <palomer> I leave for asia for 3 months, and everything breaks
13:44:34 <xerox> ghc-6.6, ghc-cmm, ghc-fc-test, ghc-fc, ghc-fc2, ghc-ndp, ghc-nightly.
13:44:45 <monochrom> Don't go to Asia next time. :)
13:45:03 <monochrom> See this is why I just don't use the debs at all.
13:45:16 <xerox> Those are darcs repositories.
13:45:20 <xerox> http://darcs.haskell.org/
13:45:22 <lambdabot> Title: Index of /
13:45:29 <Cale> Renkin: when you put something in a where clause, it's just like putting it in a let
13:45:55 <xerox> audreyt: what branch does have the coercion stuff?
13:46:13 <Cale> (so yeah, it's a local binding)
13:46:29 <sjanssen> @where paste
13:46:29 <lambdabot> http://paste.lisp.org/new/haskell
13:46:57 <lisppaste2> sjanssen pasted "dreamEye: try something like this" at http://paste.lisp.org/display/28575
13:47:02 <Renkin> what do I import to get fromJust?
13:47:23 <sjanssen> Renkin: Data.Maybe
13:47:35 <Renkin> ok, thanks
13:47:36 <sjanssen> @hoogle fromJust -- this is a useful tool to meet
13:47:37 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- this is'
13:47:51 <sjanssen> bah, somebody should make that accept comments
13:48:01 <Renkin> nice
13:48:08 <Renkin> @hoogle fromJust
13:48:08 <lambdabot> Maybe.fromJust :: Maybe a -> a
13:48:14 <Lemmih> xerox: whta about my breakpointer?
13:48:43 <xerox> Lemmih: maybe it could be handy for dreamEye's situation, I don't know its status though
13:49:00 <dreamEye> thanks lisppaste2
13:49:52 <dreamEye> ops, thanks sjanssen
13:50:38 <Lemmih> xerox: breakpoints wouldn't really help dreamEye more than assertions.
13:50:53 <dreamEye> currently I use exceptions to deal with that
13:51:02 <xerox> Hm.
13:52:00 <dreamEye> but this alternative may be more readable
13:55:25 <sjanssen> xerox: I think the ghc-fc branches are defunct, as they've been merged into the current development branch
13:55:55 <xerox> OK, good.
13:56:01 <xerox> I'm using ghc/, thanks.
13:56:20 <araujo> morning!
13:56:53 <sjanssen> and, let ndp = "nested data parallelism" in ghc-ndp
14:00:19 <vincenz> When do you think 6.6 will be pushed into distros
14:00:43 <Igloo> It already is being
14:00:49 <vincenz> Which ones?
14:01:04 <Igloo> Debian, gentoo at least
14:01:07 * vincenz nods
14:01:17 <vincenz> I take it that ubuntu will take the downstream from debian
14:01:27 <Igloo> I assume FC and darwinports are underway or done too
14:01:37 <Igloo> No idea
14:01:50 <Igloo> Presumably, though, as that's what they've done in the past
14:04:02 * vincenz nods
14:04:36 <mbishop> 6.6 is in debian unstable for sure
14:05:17 <cjay> still not in gentoo
14:06:24 <therp> cjay: ghc 6.6 is in the haskell overlay
14:06:40 <xerox> ghc-6.5.20060608: unknown package: regex-compat  pfui!
14:06:42 <bringert> Igloo: how does the faq get into the GHC manual?
14:06:51 <bringert> is it slurped from the wiki?
14:06:51 <xerox> make: *** [stage1] Error 1
14:07:39 <SamB> mmm, yummy faq...
14:07:52 <Igloo> bringert: No idea OTTOMH
14:07:52 * SamB sluuuuuurp
14:07:53 <bringert> hmm, it seems it doesn't
14:07:58 <bringert> wtf
14:08:04 <bringert> I just saw it a minute ago
14:08:08 <bringert> no there is no faq
14:08:12 <bringert> now
14:08:58 <bringert> I must have been looking at 6.4
14:09:10 <bringert> forget I ever said anything
14:09:15 <SamB> hehe
14:09:26 * SamB shlurps more faq
14:09:53 * monochrom slurps bringert
14:14:37 <bringert> hey
14:15:11 <bringert> I'd better leave now
14:15:22 <bringert> before this gets scary
14:15:38 <monochrom> haha
14:20:31 <Igloo> SamB: This cachegrind-analyse - is it GHC specific at all?
14:21:09 <SamB> Igloo: not really
14:21:13 <SamB> but I wish it was
14:21:19 <Igloo> Huh? Why?
14:21:49 <SamB> well, it doesn't seem to do such a great job on GHC compiled things atm...
14:22:03 <Igloo> I'm just thinking it might make more sense to package it up as a cabal package rather than having it hidden deep in the GHC repo, so people can use it for other things as well
14:22:04 <SamB> all those things with made-up-by-the-compiler names...
14:22:16 <Igloo> Ah, hmm
14:22:47 <Igloo> I wonder how hard it would be to get sensible names generated
14:22:59 <SamB> huh
14:23:02 <SamB> interesting idea
14:24:06 <Igloo> Inlining would be a pain, though. Maybe something related to SCCs could be worked out
14:25:23 <SamB> really I would love to use those
14:25:33 <Igloo> Incidentally, if you want to work out where the names come from by hand then keep the -ddump-simpl or -v9 output
14:26:21 <SamB> except when I tried plain-old profiling with -auto, I got identical output for stuff with both my patched GHC and the unpatched one...
14:26:36 <SamB> meaning that the SCCs are messing up optimizations...
14:26:59 <SamB> and when you are trying to debug the inliner that is no good :-(
14:27:08 <Igloo> Right, that makes sense
14:27:42 <SamB> I'm sorta hoping one or both of the simons will try that tool and say "yuck!" and come up with a much better idea ;-)
14:28:11 <SamB> or even come up with ideas to improve the tool
14:28:17 <Igloo> heh
14:29:08 <SimonRC> In case you haven't seen this before:   http://beust.com/weblog/archives/000375.html
14:29:09 <lambdabot> Title: Otaku, Cedric's weblog: A programming language for 2010
14:29:39 <SimonRC> Summary: For speed, we can nick stuff from Haskell.
14:31:33 <SamB> is he sure he doesn't want to write games in epigram ;-P?
14:32:21 * dcoutts pokes xerox 
14:32:28 <dcoutts> xerox, so, when will you be in London ?
14:32:36 <dcoutts> are your plans any clearer ?
14:32:43 * xerox scratches head
14:32:46 <dcoutts> how many days are you here ?
14:32:47 <xerox> I was thinking about that right now.
14:32:52 <dcoutts> oh good :-)
14:33:36 <xerox> I think tomorrow will be clear if I'll be there or not.  Last time I found the plane tickets the day before, but this time I hope to get them before.
14:35:51 <dcoutts> xerox, yeah, it's much cheaper to buy plane tickets early
14:35:58 <dcoutts> or indeed train tickets
14:36:26 <xerox> I wanted to work the plan out in the weekend, but it'll wait 'till tomorrow.
14:36:51 <xerox> I'm not sure the person who's hosting me is really hosting me, that is :)
14:38:33 <monochrom> They usually delegate the hosting job to an old lady.
14:38:53 <xerox> I'm sure she's a young lady :)
14:39:39 <xerox> (That's where the things get difficult.)
14:42:27 <moonlite> i'm planning on adding a Map to my program with the keys being (String,[Type]) (where data Type = TInt|TDouble...)
14:42:43 <moonlite> is it stupid to use a tuple with a str,list as a key?
14:43:01 <moonlite> performance-wise that is
14:43:39 <astrolabe> moonlite: that is quite a slow way to do it.
14:43:52 <audreyt> xerox: it' sstraightforrward builddable. the trunk has coerrcion.
14:44:06 <astrolabe> moonlite: but the prelude gives you some help
14:44:07 <xerox> audreyt: it breaks here :-/
14:44:20 <astrolabe> @type lookUp
14:44:21 <lambdabot> Not in scope: `lookUp'
14:44:25 <moonlite> astrolabe: if i let the key be a string and use (show tuple)?
14:44:29 <audreyt> xerox: oy. I tried maybe 3 weeks ago
14:44:35 <xerox> audreyt: alright
14:44:37 <astrolabe> @type lookup
14:44:38 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
14:44:55 <astrolabe> moonlite: use this ^^^^^^^^^
14:45:11 <xerox> Howdy astrolabe.
14:45:11 <moonlite> astrolabe: instead of Data.Map?
14:45:13 <moonlite> what?
14:45:26 <moonlite> that would be O(n) instead of O(log n) right?
14:45:33 <astrolabe> moonlite: ah no
14:45:43 <astrolabe> sorry I thought you were just starting.
14:45:54 <astrolabe> use Data.Map of course
14:46:19 <moonlite> Data.Map (String,[Type]) Function
14:46:24 <moonlite> that is my planned map
14:46:39 <moonlite> ie, the key being a tuple with a list in it
14:46:59 <moonlite> that's where im asking if will end up with performance problems, from the keys being to large
14:47:02 <astrolabe> Do tuples inherit Ord?
14:47:33 <moonlite> ah that's how they do it
14:47:37 <moonlite> but if not
14:47:50 <moonlite> i could just use Data.Map String Function
14:48:11 <moonlite> and store the key with (show tuple) right?
14:48:34 <moonlite> i'll just test this instead i think. :)
14:48:42 <moonlite> thanks for your time astrolabe :)
14:48:45 <astrolabe> It doesn't sound very nice :)
14:48:49 <astrolabe> sorry I wasn't much help
14:48:50 <moonlite> i know
14:49:13 <moonlite> ut unfortunately the only natural key i can come up with is this string together with a list of Type
14:49:55 <astrolabe> You could put them in a datatype, and define Ord on it.
14:51:01 <glguy> Anyone else ever worked on a project that they hated so much that they actually got headaches working on it?
14:51:14 <moonlite> hm, thats true, i'll do that if performance becomes an issue
14:51:20 <moonlite> thx a lot
14:52:43 <astrolabe> glguy: no.  How can it be that bad?
14:52:44 <glguy> astrolabe: just to answer your previous question: compare (a,b) (c,d) | e == Eq = compare b d | otherwise = e where e = compare a b
14:52:58 <glguy> I don't know how it's actually defined, but that does the same thing
14:53:21 <glguy> actually, I thnk that Ordering is an instance of Monoid
14:53:22 <glguy> so
14:53:39 <glguy> compare (a,b) (c,d) = compare a c `mplus` compare b d
14:54:37 <astrolabe> glguy:  I meant could you derive it, but I wasn't at all clear.  I didn't realise defining it would be so simple.
14:55:06 <glguy> astrolabe: (a,b) is automatically an instance of Ord if a and b are
14:55:33 <glguy> using the above-given logic
14:55:53 <glguy> astrolabe: the project is just becoming more and more ofa huge hack
14:55:58 <glguy> and it sucks
14:56:46 <astrolabe> I hate that.  There is a point of no return.
14:57:24 <astrolabe> I assume it's not haskell :)
14:57:28 <glguy> nope, it's not
15:04:50 <palomer> whew
15:04:55 <palomer> I have some work ahead
15:04:56 <palomer> my my
15:05:08 <palomer> how I've been undisciplined
15:17:30 <Lajexander> i still dont understand how to solve this (from my textbook):
15:18:14 <Lajexander> using functions defined already wherever possible, write definitions of functions to:
15:18:14 <Lajexander>  test wherther the values of a function f on inputs 0 to n are all equal
15:18:50 <Lajexander> so basically check if all values in map f [0..n] are the same
15:19:08 <astrolabe> what is the problem?
15:19:28 <Botje> 00:07 -!- [1]damg [n=damg@p54ADEB6B.dip.t-dialin.net] has quit [" HydraIRC -> http://www.hydrairc.com <- Leading Edge IRC"]
15:19:30 <lambdabot> Title: HydraIRC [Main Site Index]
15:19:31 <Botje> 00:11 -!- chris2 [n=chris@p549D1D7A.dip0.t-ipconnect.de] has quit ["Leaving"]
15:19:32 <Botje> ARGH
15:19:37 <Botje> apologies, damn mouse
15:19:51 <Botje> Lajexander: have you considered fold(l|r) ?
15:19:53 <Lajexander> i don't know how to do it! == can't be folded, though that would have been nice
15:20:12 <Botje> sure it can
15:20:16 <Lajexander> @type (==)
15:20:17 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:20:21 <astrolabe> Lajexander: would it help to observe that they're all equal, iff and only if all of them are equal to the first?
15:20:41 <Lemmih> ?scheck \f n -> all (== f 0) (map (f::Int->()) [1..n])
15:20:42 <lambdabot>  Completed 10 test(s) without failure.
15:21:21 <Lajexander> Lemmih: I have no idea of what you just did
15:21:35 <psi> astrolabe: if and only if and only if? :)
15:21:43 <astrolabe> psi: I noticed that :)
15:22:44 <Lemmih> Lajexander: I checked if 'f 1-to-n' equals 'f 0'.
15:22:48 <Lajexander> aren't there some standard function i can use? no lambda expressions allowed
15:23:08 <astrolabe> Lajexander: would it help to observe that they're all equal, if and only if all of them are equal to the first?
15:23:54 <Lajexander> astrolabe: it probably would, but that would be pretty much what Lemmih did
15:24:48 <astrolabe> Well, you didn't understand that, and it uses lambda expressions, but that is the basic idea yes.
15:25:23 <astrolabe> @type all
15:25:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:25:30 <Lajexander> heh
15:25:40 <Lajexander> i had no idea that existed =)
15:25:59 <astrolabe> If it didn't, you could define it.
15:27:18 <astrolabe> @type (== 7::Int)
15:27:19 <lambdabot> parse error on input `::'
15:27:25 <Lajexander> oh... any p =  or . map p;  all p =  and . map p
15:28:11 <Lajexander> so... all (== f 0) . map f $ [0..t]
15:28:25 <Lajexander> *t = n*
15:28:38 <monochrom> I am not sure of the relative precedences of . and $
15:29:17 <Lajexander> I usually write like that and it almost always works =)
15:29:19 <astrolabe> $ is as weak as can be I think
15:30:40 <astrolabe> > let f = (+4) in all (== f 0).map f $ [0..5]
15:30:41 <lambdabot>  False
15:30:50 <astrolabe> :)
15:31:32 <Lajexander> > let f = (\x -> 1) in all (== f 0).map f $ [0..5]
15:31:33 <lambdabot>  True
15:31:42 <Lajexander> aight :)
15:35:38 <Renkin> competition in unreadable code? :)
15:35:57 <astrolabe> :p
15:36:32 <Chinju> hey
15:36:52 <Chinju> I have a question/problem with the latest Windows GHCi, and I was wondering if perhaps anyone could help me out
15:37:09 <astrolabe> Ask and find out.
15:37:14 <Chinju> indeed
15:37:26 <Chinju> so with the last GHCi, I never got Ctrl+C/Ctrl+Break to work quite right
15:37:34 <Chinju> I couldn't press them while a computation was ongoing
15:38:06 <Chinju> and if I pressed them at a prompt, GHCi would exit [maybe that's the intended behavior? I don't remember it being that way]
15:38:07 <Chinju> anyway
15:38:13 <Chinju> having just upgraded to the latest version
15:38:16 <Chinju> things have gotten worse
15:38:26 <Chinju> specifically, if I press Ctrl+C/Ctrl+Break while a computation is ongoing
15:38:30 <Renkin> switch to Linux and see if it helps? =)
15:38:34 <Chinju> GHCi will hang, and I'll have to kill it from the task manager
15:38:55 <Chinju> heh, yeah, well, I was hoping for an easier solution than that
15:39:24 <Chinju> surely someone else here uses Windows and could perhaps share if they have similar or different experiences?
15:40:02 <Renkin> I used GHCi with Windows like a month ago, and I don't remember it behaving like that
15:40:05 <Chinju> yeah
15:40:08 <Renkin> I have no idea what it could be, though
15:40:15 <Chinju> I had GHCi working fine a few months ago too
15:40:18 <Chinju> so I don't know what has changed
15:40:46 <Renkin> try an older version of GHC?
15:40:54 <Renkin> or do you desperately need the latest?
15:41:11 <Chinju> no, not really
15:41:16 <Chinju> but then, I don't desperately need Ctrl+C either
15:41:24 <Renkin> I'm using 6.4 something
15:41:33 <Renkin> heh, ok :)
15:42:53 <SamB> go chec the trac for tickets about that?
15:42:56 <SamB> er.
15:42:59 <SamB> *check
15:43:13 <cjeris> In the desugaring of do-notation, like "mother s >>= \m -> father m >>= \gf -> father gf", the body of each lambda expression is the entire expression to its right, correct?
15:43:37 <Lemmih> cjeris: Yes.
15:43:37 <monochrom> Yes
15:43:52 * cjeris is trying to puzzle out how to translate the State monad into SML
15:44:27 <Chinju> hm
15:44:37 <Chinju> are there any other control characters besides Ctrl+C and Ctrl+Break that GHCi does things with?
15:44:42 <SamB> cjeris: watch!
15:44:44 <Chinju> I'd like to see what its behavior is on them, if so
15:45:19 <monochrom> mother s >>= fun m -> father m >>= fun gf -> father gf   (* why is this somehow a mess? *)
15:45:35 <SamB> @undo do m <- mother s; gf <- father m; father gf
15:45:35 <lambdabot> mother s >>= \ m -> father m >>= \ gf -> father gf
15:46:23 <Renkin> Chinju: maybe there's an answer in the FAQ? if you haven't tried that already
15:46:32 <Chinju> Renking: I looked around a bit and found nothing
15:46:37 <Chinju> *Renkin
15:46:37 <cjeris> oh, clever.  lambdabot has still more neat tricks.
15:46:39 <cjeris> @botsnack
15:46:39 <lambdabot> :)
15:47:57 <Chinju> I mean
15:47:59 <Chinju> there is something in the FAQ
15:48:01 <Chinju> about Ctrl+C on Windows
15:48:06 <Chinju> under a Cygwin shell
15:48:11 <Chinju> but the fix they suggest doesn't work for me
15:48:16 <Chinju> plus, things don't work even outside a Cygwin shell
15:48:20 <Chinju> so, that's that
15:50:08 <moonlite> My program is running in a monad (type Result a = StateT Program Err a) and i perform some Map.lookups in the code. Map.lookup runs fail if it doesn't find the actual key, now i want to run som debug code (my own fail really) if lookup doesn't find the key and according to the manual it seems to be possible.
15:50:28 <moonlite> Data.Map.lookup says this in the reference: "The function will return the result in the monad or fail in it the key isn't in the map. Often, the monad to use is Maybe, so you get either (Just result) or Nothing."
15:50:35 <moonlite> so how do i do this?
15:51:21 <Renkin> Chinju: I'd try with an older version to see if the problem is related to that
15:51:29 <moonlite> (ie do a lookup in the Maybe monad and then return the value if found or fail with a message in the Err moad if not)
15:51:53 <Chinju> yeah; I guess I'll go hunting back till the last version that works, and then check the release notes to see what could have changed
15:51:54 <Renkin> or if it comes from something else
15:52:02 <Chinju> and if I can't find something that works
15:52:07 <Chinju> it must be my fault
15:52:24 <Chinju> something I changed on my Windows settings, I mean
15:52:25 <Renkin> always blame Windows :)
15:52:41 <Renkin> or just something Windows did on its own ;)
15:52:46 <Chinju> yeah, that's even better
15:54:14 <astrolabe> moonlite: is fail in Maybe the same as Nothing?
15:55:03 <moonlite> astrolabe: yep
15:56:04 <astrolabe> moonlite: inside a do:     value <- lookup key map     ?
15:56:44 <moonlite> then it fails in the StateT Program Err a-monad im using
15:57:05 <astrolabe> oh, and you want it to fail with Nothing?
15:57:16 <moonlite> yeah and the patternmatch on that
15:57:29 <moonlite> then
15:57:39 <moonlite> so i can fail with some meaningful message
15:58:07 <astrolabe> lookup key map :: Maybe ValType   ?
15:58:39 <moonlite> @type Data.Map.lookup
15:58:40 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
15:58:44 <astrolabe> or just check it against Nothing, and let type inference sort it out
15:58:50 <moonlite> oh
15:59:47 <moonlite> Couldn't match `StateT Program Err Function' against `Maybe a'
15:59:58 <moonlite> hm
16:00:07 <moonlite> thats not very inforative, hold
16:01:27 <lisppaste2> moonlite pasted "my test" at http://paste.lisp.org/display/28580
16:01:43 <moonlite> is that what you mean?
16:02:11 <lisppaste2> moonlite annotated #28580 with "error" at http://paste.lisp.org/display/28580#1
16:04:34 <astrolabe> Is lookupfunction the same as lookup?
16:05:23 <moonlite> oh stupid of me
16:05:46 <moonlite> lookupFunction s = gets $ functions_ >>= Map.lookup s
16:06:13 <moonlite> functions_ is a part of the state record and it is a record
16:06:17 <moonlite> functions_ is a part of the state record and it is a map
16:06:42 <astrolabe> moonlite: sorry too hairy for me at this time of night.
16:07:03 <moonlite> ok
16:07:12 <moonlite> lots of thanks anyway
16:07:26 <astrolabe> I don't know where all the people who know what they are talking about have gone :)
16:07:34 <moonlite> :)
16:07:38 <moonlite> to sleep maybe?
16:07:44 <shapr> It's just 6pm!
16:07:59 <astrolabe> shapr: back in the USA?
16:08:01 <moonlite> 01 am here
16:08:22 <astrolabe> shapr knows what he's talking about.  Hassle him!
16:08:25 <shapr> I do?
16:08:29 <shapr> I'm not convinced...
16:08:32 <astrolabe> fraid so.
16:08:50 <astrolabe> @quote shapr
16:08:50 <lambdabot>  GHC has more flags than the UN
16:08:54 <astrolabe> see
16:08:59 <dcoutts> hah hah hah
16:09:00 <sjanssen> moonlite: so, lookupFunction is in the StateT Monad, right?
16:09:00 <Chinju> whoa
16:09:08 <moonlite> sjanssen: yes
16:09:12 <dcoutts> shapr, that's a nice quote :-)
16:09:15 * shapr grins
16:09:22 <dcoutts> shapr, and it's true too.
16:09:35 <sjanssen> moonlite: and how do we get values out of a monad?
16:09:45 <shapr> Too bad SPJ took my quote out of the History of Haskell paper: "<shapr> Haskell separates Church and state."
16:09:56 <dcoutts> shapr, heh
16:10:16 <astrolabe> sjanssen: unsafeIO?
16:10:22 <moonlite> sjanssen: umm, this is in the borde of my knowledge
16:10:26 <moonlite> byt lift maybe?
16:10:29 <moonlite> -y+u
16:10:45 <sjanssen> moonlite: you need to use monadic bind (<- in do notation)
16:11:11 <moonlite> yeah, but it will fail there
16:12:18 <shapr> astrolabe: The USA is making it hard to get back into the system, driver's license want insurance, insurance wants license, they both want Social Security card, SS wants name change papers... it's exciting.
16:12:29 <lisppaste2> moonlite annotated #28580 with "original code" at http://paste.lisp.org/display/28580#2
16:12:54 <astrolabe> shapr: a desperate desperado on the run?
16:13:04 <edwardk_> sounds like a lot of work to become a living breathing american citizen after a while abroad
16:13:48 <mwc> shapr, hahahah, that's one of the funnier things i've heard today
16:14:31 <sjanssen> moonlite: just do your case expression on f' after the bind
16:14:34 <mwc> shapr, come to Canada... You don't even need to go to your immigration hearing
16:14:56 <moonlite> sjanssen: i tried that now. and it also fails. will annotate that message also
16:16:31 <lisppaste2> moonlite annotated #28580 with "next try..." at http://paste.lisp.org/display/28580#3
16:18:21 <sjanssen> moonlite: does lookupFunction return a Maybe value wrapped in a StateT?
16:18:30 <sjanssen> because that's what your error message is
16:18:42 <sjanssen> erm, that's what your error message seems to indicate
16:19:20 <moonlite> lookupFunction is (lookupFunction :: String -> Result Function)
16:19:41 <moonlite> and Result = type Result a = StateT Program Err a
16:20:07 <sjanssen> moonlite: well there you go, you're trying to match against a Maybe when there's no Maybe there
16:20:35 <moonlite> and that's the whole question really
16:20:43 <moonlite> how do i add the maybe
16:20:58 <sjanssen> you do it in the body of lookupFunction
16:21:23 <moonlite> so that lookup fails in the Maybe monad and not in the Err-monad (so i can patternmatch it and make my own fail with an interresting message
16:21:34 <moonlite> ah
16:22:03 <sjanssen> you probably have something like: "return myResult", that becomes "return (Just myResult)"
16:22:19 <moonlite> hm, that shoul ddo it
16:22:21 <moonlite> heh
16:22:23 <dons> morning
16:22:49 <moonlite> you all have been insanely helpful. thanks a lot!
16:23:07 <astrolabe> morning dons
16:24:35 <lispy> helpful?  #haskell? hmm....i have been away awhile ;)
16:27:00 <dcoutts> g'morning dons
16:27:24 <SamB> lispy: have not!
16:35:55 <lisppaste2> moonlite annotated #28580 with "Still problems" at http://paste.lisp.org/display/28580#4
16:36:11 <moonlite> unfrtunately i still have problems with the same thing.
16:36:46 <glguy> Does anyone know if ViM's .lhs format perfers LaTeX-style or '>'-style?
16:36:53 <dons> .lhs i think
16:37:02 <dons> at least, i have a patch that will help, if the default doesn't
16:37:04 * glguy blinks
16:37:24 <moonlite> ufortunately i don't know what type signature to put on lookupFunction, since i'm now adding the maybe-onad
16:37:39 <dons> http://www.cse.unsw.edu.au/~dons/tmp/lhaskell.vim
16:37:41 <lambdabot> http://tinyurl.com/huef3
16:37:47 <glguy> dons: when editing a .lhs file, does ViM prefer '>' or \begin{code}
16:37:50 <glguy> is what I was asking
16:38:21 <dons> it doesn't care?
16:38:22 <fons> does anyone know if multiparameter classes are proposed for the next standard?
16:38:27 <dons> fons: they are.
16:38:29 <glguy> dons: OK, cool
16:38:30 <SamB> they are?
16:38:32 <dons> ?where haskell-exts
16:38:33 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
16:38:47 <SamB> I thoguht they were mostly on the "leave out" heap?
16:38:54 <fons> so I guess its something ... almost standard now
16:38:55 <dons> SamB: how are we going to write StateT ?
16:39:01 <SamB> ATs?
16:39:07 <dons> fons: right. it works everywhere
16:39:13 <dons> SamB: maybe.
16:39:20 <SamB> @where ATs
16:39:21 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/AssociatedTypes
16:39:38 * SamB tries to rewrite MTL with ATs
16:39:41 <dons> if you have MPTCs you need either FDs or ATs. that's the debate
16:39:49 <glguy> dons: can I install this .vim file in my ~ dir?
16:39:56 <lisppaste2> sjanssen annotated #28580 with "how about this" at http://paste.lisp.org/display/28580#5
16:40:00 <SamB> wait, so ATs need MPTCs to use?
16:40:03 * SamB forgot
16:40:07 * glguy has never customized ViM like this
16:40:13 <dons> glguy: in your .vim/after/syntax/ dir
16:40:21 <glguy> ah, cool
16:40:24 <dons> SamB: no.
16:40:25 <SamB> wait, that is wrong page
16:40:27 <sjanssen> SamB: I don't think they actually need MPTC
16:40:36 <dons> you need either ATs or FDs to make MPTCs useful
16:40:48 <SamB> @google site:trac.haskell.org Associated Types
16:40:49 <lambdabot> No Result Found.
16:40:53 <SamB> @google site:darcs.haskell.org Associated Types
16:40:55 <lambdabot> http://darcs.haskell.org/papers/at-ng/at-ng.bib
16:41:04 <dons> at-ng eh?
16:41:08 <SamB> @google site:darcs.haskell.org Associated Types Type Families
16:41:11 <lambdabot> http://darcs.haskell.org/ghc/compiler/types/Coercion.lhs
16:41:14 <SamB> arg.
16:41:19 <SamB> @google site:darcs.haskell.org Associated Types Type Families inurl:trac
16:41:20 <lambdabot> No Result Found.
16:41:23 <SamB> hmm.
16:41:45 <moonlite> sjanssen: it compiles. \o/
16:41:48 <SamB> @google site:hackage.haskell.org/trac/ghc Associated Types
16:41:50 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
16:41:50 <lambdabot> Title: TypeFunctionsStatus - GHC - Trac
16:41:53 <SamB> ah
16:42:36 <moonlite> and it also works
16:42:42 <moonlite> sjanssen: thx a lot!
16:42:54 <sjanssen> you're welcome
16:43:30 <SamB> @doc
16:43:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:43:37 <moonlite> i'll buy you dinner if you at any time are in gothenburg ;)
16:43:49 <dons> ooh, agile test driven presentation of haskell, http://blog.nayima.be/2006/10/22/the-xp-day-program-pt-5/
16:43:52 <lambdabot> Title: Thinking for a Change  Blog Archive  The XP Day Program. pt. 5, http://tinyurl.com/ymemx5
16:43:58 <ThreeQ> is there a better way to say "map toUpper"?
16:44:07 <dons> nope
16:44:36 <ThreeQ> ah
16:44:40 <ThreeQ> I guess it seems like there should be
16:45:06 <SamB> @google site:haskell.org callcc done right
16:45:06 <dons> hmm?
16:45:07 <lambdabot> http://haskell.org/hawiki/ListTDoneRight
16:45:08 <lambdabot> Title: ListTDoneRight - The Haskell Wiki
16:45:13 <SamB> arg
16:45:23 * SamB can never find that when he wants it...
16:50:06 <dons> lispy++
16:50:23 <dons> ?remember lispy I'm partial to: data Intercalate
16:51:18 <dons> ?remember JohnMeacham This friday, at your local theater: "BEWARE! the catamorph from the VOID!"
16:55:53 <SamB> hmm.
16:56:09 <SamB> can I state that an AT has to be in a given typeclass?
16:56:53 <Bobstopper> That made me laugh too :)
16:57:04 <sjanssen> bah, intercalate
16:57:18 <SamB> I liked the "data Intercalate" suggestion ;-)
16:57:27 <sjanssen> is it just me, or is that an outrageously obscure word?
16:57:40 <SamB> it is not just you
16:57:40 <dcoutts> it's not just you
16:58:03 <SamB> I would have thought it was some gobbledygook made up by perlists or something
16:58:17 <dcoutts> as someone else pointed out it's only used in Oxford and Cambridge to mean taking a year out
16:59:15 <fons> shapr, I'm sorry to bother you again
16:59:21 <glguy> ! LaTeX Error: \usepackage before \documentclass.
16:59:28 <glguy> Does anyone else get that when using lhs2TeX?
16:59:31 <fons> I've been trying to model my problem with a typeclass
17:00:01 <fons> http://paste.lisp.org/display/28560
17:00:21 <fons> but I don't really see how
17:01:50 <dons> dcoutts: oh, interesting. its actually not obsolete? it's still used?
17:03:02 <dcoutts> dons, just because a word is being used at Oxford and Cambridge doesn't mean it's not obsolete ;-)
17:03:45 <dons> so this is where everyone else has a "gap year", our Oxford and Cambridge friends "intercalate" fun !
17:04:01 <dcoutts> how many Oxbridge dons does it take to change a light bulb?
17:04:18 <dons> heh, I don't know -- how many?
17:04:20 <dcoutts> Change!!??
17:04:27 <dons> hehe
17:04:44 <SamB> you mean they'd just buy a new one?
17:04:46 <kpreid> fons: I wasn't looking at your problem earlier, but just from that paste I'd guess: class Plugin id hd where lookupDescriptor :: Integer -> Descriptor id hd
17:05:02 <Bobstopper> Well clearly the problem with intercalate is that it's a rare English word which isn't culturally sensitive. I propose a culturally sensitive solution by using a culturally sensitive language. What say we use jorneFiZo'e ? :P
17:05:18 <dcoutts> dons, it usually refers to taking a year out, but not exactly on purpose.
17:05:29 <dons> ah right. interesting
17:05:51 <dcoutts> ie due to illness or not doing very well
17:06:47 <fons> kpreid, ok, that makes sense, how about the descriptor type?
17:07:16 <fons> kpreid, It doesn't make sense to create a class out of it
17:07:24 <kpreid> fons: so leave it as is?
17:07:52 <fons> or does it
17:08:03 <kpreid> well, you could
17:08:14 <kpreid> if you added that Integer parameter to every field's type
17:08:32 <fons> that's a bit wierd I think
17:09:00 <kpreid> oh hm
17:09:13 <kpreid> you *could*:
17:09:48 <Chinju> I'm gonna try this again, just hoping for wild luck: does anyone here use GHCi on Windows?
17:09:53 <kpreid> class Descriptor d id hd where uniqueId :: d -> Integer; implementationData :: d -> id; ...
17:10:17 <fons> that's what I tried ....
17:10:23 <fons> but hugs complains
17:10:27 <kpreid> fons: I don't know whether that's a good idea or not though
17:10:41 <fons> I'll just leave it as it was
17:10:42 <kpreid> I'll guess you'd need fundeps...
17:10:48 <kpreid> what was the complaint?
17:10:57 <dons> Chinju: people do yes.
17:11:05 <dons> Chinju: what probelms are you having?
17:11:15 <dons> also, you might consider WinHugs
17:11:23 <lispy> what is the name of sleep in haskell?
17:11:25 <Chinju> dons: Problems getting Ctrl+C to work, which is odd, since it used to
17:11:28 <fons> ERROR "Ladspa.hs":43 - Ambiguous type signature in class declaration
17:11:28 <fons> *** ambiguous type : LadspaPlugin a b c => a -> Integer
17:11:28 <fons> *** assigned to    : uniqueID
17:11:30 <lispy> ?hoogle Int -> IO ()
17:11:31 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:11:31 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
17:11:31 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
17:11:42 <lispy> threadDelay works in single thread?
17:11:59 <kpreid> lispy: sleep usually does too, no?
17:12:30 <lispy> kpreid: well, since i'm not using anything from Control.Concurrent and definitely not threads, i don't know why i should expect anything with thread in the name to work
17:12:58 <dons> Chinju: http://haskell.org/haskellwiki/Windows
17:12:59 <lambdabot> Title: Windows - HaskellWiki
17:13:00 <kpreid> lispy: because you have one thread, not zero.
17:13:07 <dons> "  * GHCi on cygwin: When running GHC under a Cygwin shell on Windows, Ctrl-C sometimes doesn't work.
17:13:10 <dons>     A very good workaround is to use the rlwrap program to invoke ghci : In addition to proper
17:13:13 <dons>     Ctrl-C, you also get emacs (or vi) key bindings and command history across sessions.
17:13:17 <dons> "
17:13:29 <lispy> oh...
17:13:32 <lispy> i should use that...
17:13:42 <lispy> ctrl-c is completely brain dead on windows
17:14:12 <Chinju> dons: thanks, I'll see if that helps
17:14:23 <kfish> dcoutts, dons: My goodness old chap, these commas aren't doing particularly well. Best intercalate them in this here list representation wherein betwixt they'll recuperate. Jolly good show.
17:14:23 <fons> kpreid, any ideas about the error?
17:14:41 <dcoutts> :-)
17:15:07 <lispy> 1 second = 10000 microseconds ?
17:15:49 <kpreid> fons: assuming you renamed Descriptor in my example to LadspaPlugin, "class LadspaPlugin d id hd | d -> id, d -> hd where ..."
17:15:52 <dons> kfish: charming!
17:15:53 <lispy> i don't know why they used a prefectly good name like intercalate for that when it's obviously the perfect name for a Bottom type
17:16:07 <dcoutts> micro = 10^-3 doesn't it ?
17:16:22 <kpreid> dcoutts: -6
17:16:27 <kpreid> fons: I don't know that Hugs supports that though
17:16:28 <kpreid> -3 is milli
17:16:31 <dcoutts> ah yes
17:16:38 <fons> kpreid, whats "| d -> id, d -> hd" ?
17:16:39 <kpreid> milli, micro, nano, pico
17:16:45 <Pseudonym> ? one metre in micrometres
17:16:49 <Pseudonym> ?google one metre in micrometres
17:16:52 <lambdabot> http://www.zoo.co.uk/~z0001246/visnum.html
17:16:56 <Pseudonym> Huh.
17:16:59 <Pseudonym> ?google one metre in microns
17:17:02 <lambdabot> http://www.biocrawler.com/encyclopedia/Micrometre
17:17:03 <kpreid> fons: functional dependencies. that there is only one id and hd per d.
17:17:04 <Chinju> rlwrap doesn't seem to be helping me much, alas
17:17:08 <Pseudonym> Oh, you need numbers.
17:17:12 <Pseudonym> ?google 1 metre in micrometres
17:17:13 <lambdabot> 1 meter = 1,000,000 micrometers
17:17:16 <Pseudonym> There we are.
17:17:16 <lispy> 0,000 001 [ millionth ]  microsecond [ sssss ]
17:17:22 <lispy> er, that paste was wasted
17:17:32 <Pseudonym> ?google 1 metre in millimetres
17:17:34 <lambdabot> 1 meter = 1,000 millimeters
17:17:51 <lispy> but yeah, seems to be 10^-6
17:18:40 <lispy> Module `Control.Concurrent' does not export `theardDelay'
17:18:44 <lispy> oh
17:18:45 <lispy> hehe
17:18:46 <lispy> n/m
17:19:30 * lispy was really worried for a second, "WHere did my THEARD....go...nevermind..."
17:19:41 <fons> kpreid, :S I think I'll avoid that
17:20:13 <kpreid> fons, yes, records are simpler and apparently sufficient
17:22:36 <lispy> i don't seem to have rlwrap
17:32:53 <Bobstopper> If I want to write a GUI intended to run on multiple platforms including Unix and Windows, would experienced people suggest I use wxwidgets over gtk2hs?
17:33:04 <Bobstopper> s/wxwidgets/wxhaskell/
17:33:26 <dcoutts> Bobstopper, I'd use Gtk2Hs over wxHaskell
17:33:33 <dcoutts> but then I develop Gtk2Hs :-)
17:33:46 <Bobstopper> heheh :) What would your rationale be for that?
17:33:52 <Bobstopper> other than bias :)
17:33:57 <dcoutts> Gtk2Hs works on all the platforms wxHaskell works on plus a few more
17:34:21 <dons> i think gtk2hs is also more likely to be maintained into the future
17:34:27 <dcoutts> and in particular it has the same api and semantics on each one
17:34:34 <dons> wxHaskell mighe have reached its peak a couple of years ago.
17:34:49 <Bobstopper> Cool, that helps a lot, thanks.
17:34:57 <dcoutts> I had a wxHaskell prog that broke completely when moving from one platform to another
17:35:12 <dons> huh. due to wxWidgits semantics not being portable?
17:35:14 <dcoutts> because wxWidgets is a layer on top of existing gui libs
17:35:23 <lispy> dons: that should be changing
17:35:36 <dcoutts> and though they do fairly well, it's actually really really hard to keep the same semantics on all of them
17:35:48 * Bobstopper wonders when somebody will port wxfruit to gtkfruit :P
17:35:59 <dons> mmm. nice idea
17:36:01 <dcoutts> Bobstopper, yeah, I wonder that too
17:36:03 <lispy> well, i found that wxhaskell isn't as...um...all encompassing as it could be
17:36:06 <dcoutts> someone should
17:36:22 <dcoutts> another reason: we've got more stuff
17:36:24 <lispy> i think, it works well for 80% of stuff, and then you run into a brick wall
17:36:33 <dcoutts> like cairo and the new tree view stuff and glade
17:37:19 <Bobstopper> my understanding is that fruit is probably not going to be suitable for practical purposes until AFRP manages to sleep non-busily...
17:37:27 <lispy> dcoutts: that reminds me, i tried to follow the glade examples for gtk2hs once and when it was my turn to use glade i only get frustrated :(
17:37:32 <lispy> dcoutts: i couldn't actually figure it out
17:37:42 <dcoutts> lispy, you mean using the glade prog itself ?
17:37:47 <kfish> Bobstopper, you don't want to be writing normal gui systems without glade ... too much pain
17:37:47 <lispy> dcoutts: yup
17:37:52 <SamB> hmm...
17:37:58 <dcoutts> Bobstopper, yes, that's a problem. It has to be able to sleep.
17:37:58 * SamB doesn't get ATs
17:38:00 <Bobstopper> glade is indeed a big reason I'd prefer gtk2hs. I was mostly concerned about the size of the gtk libraries during deployment.
17:38:22 <SamB> it doesn't want to let me use a passed-in type to implement an AT!
17:38:25 <dcoutts> Bobstopper, well wxWidgets isn't any better there. It needs a bunch of dlls too.
17:38:38 <lispy> my biggest complaint with gtk on windows is simply the non-native aspects
17:38:48 <dcoutts> Bobstopper, a minimal set of Gtk+ dlls is a few megs compressed.
17:38:54 <Bobstopper> is it safe to use threading inside gtk2hs? (I understand it's not in wxhaskell)
17:39:01 <dcoutts> Bobstopper, somewhat.
17:39:03 <kfish> Bobstopper, if you stick to glade/gtk/gdk/glib/pango, that's about all there is ... maybe +cairo
17:39:16 <dcoutts> cairo rocks.
17:39:21 <kfish> Bobstopper, once you hit the Gnome button in glade though, all library hell breaks loose
17:39:42 <Bobstopper> :) I'll be leaving the gnome button alone
17:39:44 <dons> is anyone doing the ruby puzzles http://www.rubyquiz.com in haskell? seems like it might make a good side-by-side tutorial/propaganda...
17:39:46 <lambdabot> Title: Ruby Quiz
17:39:55 <dcoutts> lispy, we're waiting for some of the last most obvious rendering issues to be fixed. I think they're fixed in the latest 2.10.x
17:40:03 <Bobstopper> thanks all for your advice
17:40:55 <dcoutts> lispy, remember that every other windows toolkit is 'emulated' too. They all do their own drawing. The only thing that is native is notepad.
17:42:08 <Bobstopper> eh? I was sure I saw gtk2hs in debian before...
17:42:57 <dcoutts> Bobstopper, I can never keep track if it's in debian. You can build from source fairly easily though.
17:43:42 <dcoutts> there will be a new release soon too
17:43:46 <Bobstopper> Yeah, that's no problem. I was just surprised.
17:44:24 <lispy> dcoutts: but lasttime i used gtk2hs even file dialogs looked like the linux ones on windows
17:44:33 <dcoutts> lispy, that's true.
17:44:48 <lispy> dcoutts: if i tried to use that for something at work our windows-only saps would freak out
17:44:51 <dcoutts> that's probably the worst one
17:44:52 <dcoutts> heh
17:45:25 <lispy> yeah, i was gonna fix it, but then they told me to just write the gui parts in our existing software
17:45:33 <dcoutts> ah ok
17:45:40 <dcoutts> well if you ever find time... :-)
17:45:42 <SamB> oooookay...
17:45:54 <SamB> ErrorAT.hs:17:0:
17:45:54 <SamB>     Type synonym `MError' should have 1 argument, but has been given 1
17:45:54 <SamB>     When checking the class method:
17:45:54 <SamB>       throwError :: forall a. MError m -> m a
17:45:54 <SamB>     In the class declaration for `MonadError'
17:45:56 <SamB> na
17:46:09 <SamB> oh, oops, selected too much...
17:46:14 <dcoutts> lispy, we can 'fix' it at the Gtk2Hs layer if it doesn't look like the Gtk+ devs are going to do it at the Gtk+ layer.
17:46:22 <sjanssen> dons: http://www.rubyquiz.com/quiz87.html that one looks like a chance for some kind of crazy TimeTravel monad
17:46:23 <lambdabot> Title: Ruby Quiz - Negative Sleep (#87)
17:47:02 <dons> sjanssen: mmm!
17:47:20 <dcoutts> lispy, we can provide a file dialogue module that provides the lowest common denominator between the Win32 API and Gtk+ API
17:47:43 <dons> sjanssen: yes -- i see some monadic magic majesty in that puzzle
17:48:06 <dcoutts> lispy, so you wouldn't get the more advanced features of the Gtk+ file dialogue but it'd look better on win32
17:49:59 <lispy> dcoutts: right, my plan was to use the Win32 stuff to popup a file dialog
17:50:09 <lispy> dcoutts: but the Win32 stuff needed quite a bit of work to do that
17:50:14 <dcoutts> lispy, ah right.
17:50:23 <lispy> dcoutts: i was working on it for a while, but as the requirements changed i lost interest
17:50:41 <lispy> i learned about hsc2hs which was cool
17:50:48 <dcoutts> sure, well if you ever regain interest we'll gladly accept the patches :-)
17:51:10 <dcoutts> hsc2hs is indeed cool, almost as cool as c2hs
17:51:24 <lispy> what is the advantage to c2hs?
17:51:42 <dcoutts> it checks that your binding is consistent with the C api
17:51:59 <lispy> neat
17:52:06 <dcoutts> it generates ffi imports with the correct types, based on the C header files
17:52:28 <lispy> i wonder if that would help with my little COM problem...it seems that comlib is broken and i think i've now proven that the C level wrappers don't have the bug
17:52:30 <dcoutts> so you say {# call gtk_foo_bar #} and it generates all the stuff with the right types.
17:52:32 <SamB> @google site:hackage.haskell.org type functions
17:52:35 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsStatus
17:52:36 <lambdabot> Title: TypeFunctionsStatus - GHC - Trac
17:52:59 <dcoutts> brilliant for checking that you've done it right, and it picks stuff up when the C people change their api.
17:53:07 <SamB> @docs Control.Monad.Error
17:53:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
17:53:18 <lispy> i wrote an equivalent program in C that uses the wrappers instead of calling COM function directly...
17:53:25 <lispy> dcoutts: neat
17:53:38 <lispy> my C  program doesn't have a problem but my haskell oen does
17:53:47 <lispy> so, i think that says that something is wrong on the Haskell side
17:53:50 <dcoutts> I know nothing about comlib
17:53:58 <lispy> but i've checked things like the mashalling code and it all looks fine
17:54:05 <dcoutts> I try to keep as far away from COM as I can :-)
17:54:07 <lispy> and it only has issues with one datatype
17:54:16 <lispy> dcoutts: yeah, i can understand :)
17:54:19 <dcoutts> I used to do COM programing in C++ for money. eew.
17:54:33 <dcoutts> f'ing BSTRings
17:54:56 <lispy> dcoutts: oh, yeah how do you print them? wprinf("%ws") or wprinf("%s") ?
17:55:13 <Deformative-II> Question:  what language likely has the fastest init times?
17:55:27 <dcoutts> Deformative-II, assembly ;-)
17:55:29 <SamB> hugs!
17:55:31 <lispy> Deformative-II: did you check the great pl shoot out, they have an entry for that
17:55:45 <lispy> Deformative-II: i believe they call it hello-world
17:55:53 <dcoutts> lispy, don't know, don't care :-) (it's so liberating)
17:55:57 <sjanssen> dons: how do you get fancy Haskell snippets in your blog?
17:56:03 <lispy> dcoutts: hehe
17:56:10 <SamB> oooh!
17:56:12 <SamB> I know!
17:56:15 <SamB> screen ;-)
17:56:24 <Deformative-II> O.o
17:56:38 <sjanssen> s/get/generate
17:56:50 <sjanssen> s/fancy/colored
17:57:20 <lispy> sjanssen: iirc, he uses hscolor
17:57:41 <lispy> sjanssen: in fact, he has a blog entry or a website page about it
17:58:15 <dcoutts> sjanssen, I've got a derivative of hscolour that I use for the Gtk2Hs code snippets on the website
17:58:29 <dcoutts> sjanssen, which also generates hyperlinks to haddock docs
17:58:48 <dons> sjanssen: with HsColour -css
17:59:06 <dons> yeah, there's a blog entry about it :)
17:59:36 <dons> and a custom syntax.css file
18:00:15 <sjanssen> dons: so you generate the html, then dump that into your blog?
18:00:29 <sjanssen> or do you have some handy blosxom-fu to automate that?
18:00:57 <dons> yep, I do: HsColor -css A.hs > x ; then :r x into my blog entry
18:01:07 <dons> no magic required.
18:01:20 <dons> just include the stuff between the <pre></pre> tags in the 'x' file, into the blog src
18:01:21 <Botje> :r !HsColor -css A.hs
18:01:31 <Botje> is one step shorter :)
18:01:32 <dons> Botje++
18:01:53 <dons> (the extra step is usually I want to check the rendering first)
18:02:04 <dons> i.e. HsColour -css A.hs | w3m
18:02:32 <Botje> yeah
18:02:33 <Botje> anyway
18:02:35 <Botje> sleepytime
18:02:39 <lispy> ?seen cale
18:02:39 <lambdabot> cale is in #ghc and #haskell. I last heard cale speak 4h 16m 26s ago.
18:02:41 <Botje> class in 5 hours :(
18:02:46 <sjanssen> what I'd really like to do is write blog posts in literate Haskell, then have some tool automagically generate HTML for me
18:02:55 <Cale> hi
18:03:09 <lispy> Cale: i wanted to say thanks for your help with the CodeGen monad
18:03:14 <Cale> cool
18:03:15 <lispy> Cale: i've extended it quite a lot now
18:03:17 <Cale> :)
18:03:21 <lispy> Cale++
18:03:31 <chessguy> @karma Cale
18:03:32 <lambdabot> Cale has a karma of 15
18:03:35 <dons> sjanssen: you could post process your blog entries with only a little bit of work, I think
18:03:38 <goltrpoat> one of these days, i'll figure out why the hell i'm taking 106 reduction steps to compute fac 3
18:03:42 <chessguy> wow, is that all?
18:03:47 <lispy> newtype CodeGen e a = CodeGen (ReaderT e (WriterT [Instruction] Unique) a)
18:03:53 <dons> i.e. filter out your literate fragments, typeset them in hsColour, then splice the result back in
18:04:08 <lispy> Cale: i added ReaderT so i could manage the variables and function bindings
18:04:15 <monochrom> goltrpoat is probably using Church numerals when computing fac 3. :)
18:04:20 <goltrpoat> haha
18:04:43 <Cale> lispy: yeah, reader is great for that :)
18:04:56 <lispy> Cale: learning to instance MonadReader took me a while
18:05:08 <lispy> Cale: one thing i had to do was to make it CodeGen e a
18:05:12 <lispy> otherwise it wouldn't type cehck
18:05:13 <goltrpoat> it might not be helping that True and False are defined as CAFs, but still, 106 is just ridiculous
18:05:35 <lispy> Cale: then just figuring out how to write ask and local took me a couple hours :)
18:05:42 <monochrom> what is the code for fac?
18:06:43 <goltrpoat> er.
18:07:01 <goltrpoat> hitting backspace in a java client inside a browser is probably not the best idea when the client doesn't have focus.
18:07:17 <monochrom> Haha, poor you.
18:07:49 <lispy> i absolutely hate that backspace is the backbutton in some browers
18:07:59 <lispy> stupid key combo evar
18:08:15 * lispy gives up on typing
18:08:22 <lispy> as you can tell it's caused me to never use backspace again :)
18:08:33 <goltrpoat> hehe
18:09:37 * SamB wonders if Firefox stores running Java applets in the fbcache?
18:09:48 <SamB> though personally I think a better to solution is to not install the JRE
18:10:03 <lispy> SamB: yeah
18:10:18 <Cale_> lispy: yeah, either that or fix the environment type
18:10:26 <Cale_> goltrpoat: what's your program to compute it? (fac 3)
18:10:41 <goltrpoat> anyway, fac looks like fac n = if (n==0) 1 (n*fac(n-1))  (cond-style ifs).  then main = fac 3.  i think it's just being too indirection-happy
18:10:45 <lispy> Cale_: when i tried to fix the env type i was getting kind errors
18:11:27 <goltrpoat> good god that's annoying.
18:11:27 <goltrpoat> hehe
18:11:41 <lispy> Cale_: but that only matters for newtype, all the support code for using it assumes a particular env, so it ends up not mattering
18:12:29 <Cale_> goltrpoat: if is a function?
18:12:40 <goltrpoat> i think i was saying that i've removed indirection nodes for newly created application nodes and data constructor nodes
18:12:46 <goltrpoat> if is a function, yeah
18:12:50 <lispy> scheme syntax seems to be quite a bit differen than lisp
18:12:56 <Cale_> does it just reduce to case?
18:13:09 <goltrpoat> it reduces to a built-in primitive
18:13:35 <Bobstopper> lispy: how so? single namespace?
18:14:18 <goltrpoat> so if p x y translates to (app (app (if p) x) y), and then "if" is evaluated by pulling p, x and y off the spine
18:15:12 <goltrpoat> hmm.  maybe my if is broken.
18:16:12 <lispy> Bobstopper: i don't remember lisp having much (if any) syntax with square brakets...seems to be pretty common is scheme
18:16:23 * SamB isn't having much success with his attempts to AT-ify the mtl...
18:19:22 <Bobstopper> lispy: probably just read-macros, no?
18:19:55 <lispy> Bobstopper: well, they seem to get used in lets and conds
18:20:09 <lispy> (let ([fmls (lambda-formals expr)]
18:20:10 <lispy> [body (lambda-body expr)])
18:20:13 <lispy> like that
18:20:48 <SamB> * []
18:20:48 <SamB> Error in KERNEL::UNBOUND-SYMBOL-ERROR-HANDLER:  the variable [] is unbound.
18:20:48 <SamB>    [Condition of type UNBOUND-VARIABLE]
18:21:17 <lispy> SamB: sbcl?
18:21:34 <SamB> cmu!
18:21:37 <lispy> ah
18:21:40 <lispy> close enough! :)
18:21:44 <SamB> yes ;-)
18:21:53 <SamB> but...
18:21:58 <Bobstopper> lispy: oh right. Perhaps scheme allows [] as a synonym for () to distinguish bracket pairs...
18:22:00 <SamB> guile says a similar thing
18:22:18 <lispy> right, well damned near anything is a variable in lisp
18:22:30 <SamB> well, guile is scheme!
18:22:41 <lispy> does this work? (setf [] '(1 2 3))
18:22:55 <lispy> oh, that guile
18:22:57 <lispy> :)
18:23:01 <SamB> heh
18:26:09 <Irrelevant> evening all
18:26:31 <Cale> hi
18:26:33 <lispy> good evening
18:27:12 <monochrom> Lisp allows (x (y (z]   ; I lose count of the parentheses so I just say "close them all"
18:27:25 <Irrelevant> recursive list definitions just clicked in my head. that's quite trippy.
18:27:35 <Cale> :)
18:27:45 <araujo> hellu
18:27:48 <Cale> > fix ((0:) . scanl (+) 1)
18:27:49 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:28:20 <Irrelevant> I was thinking more like
18:28:29 <SamB> monochrom: ... that doesn't seem to work for me ...
18:28:36 <emu> monochrom: no, no lisp has allowed that for 25 years
18:28:54 <emu> if you're not using Emacs or vim to track the parenthesis, you're weird
18:29:00 <lispy> i was just going to say...i've never seen that
18:29:19 * lispy is a reformed lisper
18:29:22 <monochrom> I do not say I do that today.
18:29:22 <SamB> some people even have the parenthesis totally invisible these days!
18:29:23 * araujo jumps and throws sugar lambdas at every direction
18:29:32 <lispy> hell, i'm starting to forget lisp syntax it's been so long :)
18:29:34 <emu> monochrom: so you did lisp 25 years ago? :P
18:29:36 * SamB catches some of them in his mouth
18:30:01 <araujo> :-)
18:30:19 <monochrom> I was probably taught 15 years ago by someone who did Lisp 25 years ago.
18:30:41 <emu> parentheses in lisp are just a concrete representation of the abstract syntax tree
18:31:46 <Irrelevant> *ahem*
18:31:51 <Irrelevant> I was thinking more like...
18:31:56 <Irrelevant> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
18:31:57 <monochrom> There was no emacs at school, and I did not hear of emacs.  (No Internet access either.)  There was no vim, just vi.  I was not weird, just deprived because I was living in the Dark Age.
18:31:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
18:32:32 <Irrelevant> i don't even know where to begin with "fix ((0:) . scanl (+) 1)"
18:32:36 <SamB> there is an emacs mode where the parens are not there, but are replaced by shading
18:32:42 <dons> > fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
18:32:43 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:33:07 <emu> yes, there's general emacs packages for hiding parts of files and such
18:33:13 <Cale> Irrelevant: well, the definition of fix would be a good place to state
18:33:14 <SamB> emu: not that!
18:33:16 <Cale> start*
18:33:21 <emu> though personally i prefer to see the structure, and use structure manipulation commands
18:33:23 <Cale> fix f = f (fix f)
18:33:24 <Irrelevant> Cale, true.dat
18:33:29 <SamB> it shows the structure
18:33:34 <SamB> it just doesn't show any parens
18:33:36 <emu> in fact, one of these days, i'm gonna hack out some commands to operate more cleanly on haskell structure
18:33:52 <SamB> it just shows the nesting structure
18:34:50 <Irrelevant> Cale, "$"? does that create a memoised version of the arg? **guessing from typesig**
18:35:03 <Cale> Irrelevant: no, it's just plain function application
18:35:05 <dons> ?type ($)
18:35:07 <lambdabot> forall b a. (a -> b) -> a -> b
18:35:12 <Cale> Irrelevant: it's just a convenient way to avoid parens
18:35:14 <dons> i.e. f $ x = f x
18:35:18 <monochrom> f$x is shorthand for f x
18:35:30 <mlh> heh
18:35:40 <Irrelevant> er. shorthand. I'm sure it'll make sense in due course.
18:35:50 <dons> > let f ? x = f x in fix ? \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
18:35:51 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:36:04 <araujo> Irrelevant, sense?, it is the sweetest operator :-)
18:36:06 <emu> f x $ g y  ==  (f x) (g y)
18:36:10 <SamB> Irrelevant: its just a function with an infix name and extremely low precedence
18:36:27 <Irrelevant> samB, ahh, now it makes sense
18:36:28 <fons> how can I obtain a Null StablePtr?
18:36:32 <emu> vs f x g y  == (((f x) g) y)
18:36:40 <lispy> fons: nullPtr?
18:36:42 <Irrelevant> I'd better avoid using it for now, tho, so as to not annoy my lecturers
18:36:49 <lispy> fons: not sure if that is stable...
18:36:51 <fons> nullPtr has type Ptr
18:36:57 <fons> not Stable
18:37:00 <lispy> ?type castPtr
18:37:02 <lambdabot> Not in scope: `castPtr'
18:37:08 <lispy> ?hoogle castPtr
18:37:09 <lambdabot> Foreign.Ptr.castPtr :: Ptr a -> Ptr b
18:37:09 <lambdabot> Foreign.Ptr.castPtrToFunPtr :: Ptr a -> FunPtr b
18:37:09 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
18:37:17 <Irrelevant> earlier conversation: <me> "what about using fold?" <them> "damnit, you're not supposed to know that already!"
18:37:20 <SamB> StablePtrs aren't
18:37:25 <lispy> fons: ah, there you go
18:37:25 <SamB> (they aren't pointers, that is)
18:37:55 <emu> I hate when teachers prevent you from using your knowledge
18:38:13 <lispy> emu: i find it even easier to just hate unconditionally
18:38:17 <SamB> heh
18:38:44 <SamB> personally, I would try to just play along ... if it wasn't a programming class.
18:38:57 <fons> uhm, ok lispy I now know why the library doesn't have the null StablePtr
18:38:57 <emu> [ hate x | x <- all ], oh my, unrestricted set comprehension?
18:39:20 <fons> just because you cannot export functions which return StablePtr, first you have to cast
18:39:24 <Irrelevant> $ looks like the sort of thing one would particularly use for point-free definitions etc
18:39:26 <SamB> I mean, no fair using theorems you haven't covered yet in the homework...
18:39:28 <lispy> fons: hmmm
18:39:39 <fons> The FFi specification is weel written but it is not intuitive at all
18:39:45 <lispy> fons: given what i know about castPtr that's silly
18:39:46 <SamB> or, well, maybe not no fair
18:40:18 <SamB> I suppose it depends on the class...
18:40:22 <lispy> iirc, it just changes the phantom type
18:41:27 <SamB> lispy: StablePtrs aren't Ptrs, not by a long shot
18:41:49 <scodil> what are they then?
18:41:59 <lispy> SamB: stop filling me with knowledge! maybe i like to be wrong...did you veer think of that?
18:42:10 <SamB> they are indexes into the stable pointer table?
18:42:20 <scodil> are they?
18:42:22 <scodil> why the question?
18:42:24 <lispy> data Intercalate!
18:42:28 <SamB> hah
18:42:41 <SamB> thats a funny thing to ... intercalate...
18:42:58 <lispy> i liked data BikeShed too
18:43:06 <SamB> scodil: in GHC's implementation, yes.
18:43:19 <dons> Maybe we should just have Data.BikeShed for all future libraries@ proposals
18:43:24 <SamB> heh
18:43:35 <SamB> what about Data.BoatHouse...
18:43:40 <dons> heh
18:43:53 <Igloo> data BikeShed would be an awful name - it would clash with every other proposed addition!
18:43:58 <dons> heh
18:43:59 <lispy> heh, it would just be full of alternative namse for things, it would have definitions like join = intercalate, unsplit = intercalate;...
18:45:06 <SamB> so, what do you think of the serious proposed names?
18:45:42 <monochrom> Lake House
18:45:44 <dons> I think intercalate is obfuscated and reenforces a particular stereotype of haskell programmers .... despite being a nice word
18:45:55 <SamB> I meant for the datatype ;-)
18:46:09 <lispy> oh, Void has my Vote
18:46:12 <dons> oh, it should certainly be data Void
18:46:18 <dons> we have 1 year of Djinn as precdent
18:46:24 <dons> ?djinn-env
18:46:24 <lambdabot> data () = ()
18:46:24 <lambdabot> data Either a b = Left a | Right b
18:46:24 <lambdabot> data Maybe a = Nothing | Just a
18:46:24 <lambdabot> data Bool = False | True
18:46:24 <lambdabot> data Void
18:46:26 <lambdabot> type Not x = x -> Void
18:46:33 <SamB> dons: you don't like Absurd?
18:46:38 <dons> not really
18:46:39 <lispy> not really
18:46:50 <goltrpoat> Brokeded?
18:46:55 <dons> but feel free to type alias.
18:46:57 <SamB> goltrpoat: WTF?
18:46:58 <lispy> is Undefined taken?
18:47:06 <goltrpoat> samb:  perfect.
18:47:09 <SamB> hah
18:49:59 <monochrom> What is intercalate and what stereotype does it suggest?
18:50:22 <lispy> intercalate is concate . intersperse
18:50:47 <lispy> monochrom: is nub obvisous?
18:50:51 <lispy> obvious...
18:51:00 <lispy> man, my typos are pretty obvisous
18:52:18 <monochrom> "nub" is not obvious to me.  But I'm ESL, my ignorance of words means nothing.
18:53:07 <dons> Haskell Weekly News out now, http://sequence.complete.org/hwn/20061024
18:53:26 <jgrimes> sweet
18:53:30 <monochrom> I eagerly read the News.  For the quotes. :)
18:53:40 <dons> oh! I forgot the quotes!!
18:53:43 <dons> doh!
18:53:51 <dons> double edition of quotes next week
18:54:10 <monochrom> Darn
18:54:24 <monochrom> the blogsphere noise is the next best thing
18:54:25 <dons> I thought i was forggeting something
18:54:31 * dons updates my process script
18:55:17 <dons> araujo: you can get started on the spanish translation
18:55:21 * Irrelevant observes that this nick is registered on nickserv
18:55:24 <emu> "nub" is a funny name.  i remember looking around for "removeDuplicates" before hitting on "nub" by accident.  i guess you could take it to mean "the most essential part [of a list], nothing extra"
18:55:33 * Irrelevant can't remember if that was him
18:56:30 <monochrom> The most essential part of a list is its length, since it's the only thing preserved by the list functor.
18:56:35 <araujo> dons, on my way to it :-)
18:56:48 <emu> and by list i meant set
18:56:56 <dons> araujo: also, can you upload to the Haskell wiki too, once you're done?
18:57:38 <dons> i.e. create http://www.haskell.org/haskellwiki/HWN/es/2006-10-24, upload your text (and fmt for the wiki), and then finally link from http://haskell.org/haskellwiki/HWN/es
18:57:42 <lambdabot> Title: HWN/es/2006-10-24 - HaskellWiki, http://tinyurl.com/y9qs3t
18:57:53 <araujo> dons, sure
18:58:02 <araujo> dons, i thought you had a script or something though
18:58:06 <dons> nope :)
18:58:11 <dons> but I coudl write one I suppose.
18:58:16 <araujo> hell, ok :-)
18:58:29 * Irrelevant notes that this nickserv has no recoverpass
18:59:50 <SamB> Irrelevant: wait six months, ask staff?
19:00:17 <Irrelevant> I can't even remember if i was the one who registered this nick here
19:00:28 <Irrelevant> it could be some other person entirely
19:00:52 <Irrelevant> "Last Seen Address: n=KCGEdKXn@218-214-24-203.people.net.au"
19:00:55 <Irrelevant> ok, probably not me
19:00:57 <SamB> heh
19:01:06 <SamB> yeah, probably not ;-)
19:01:06 * Irrelevant (is .uk)
19:01:15 * SamB sees
19:01:24 * SamB is .net or .com
19:01:35 <SamB> sometimes .edu, I guess
19:01:48 <SamB> ocassionally I might be .org
19:02:05 <dons> ?quit grab this week's quotes
19:02:26 <SamB> how ... primitive.
19:02:38 <dons> send me a @flush patch ...
19:02:38 <emu> lol
19:02:48 <dons> not really, I need to update once a week anyway
19:02:57 <dons> and the HWN day is also lambdabot resync day
19:02:57 <SamB> oh, right, I remember now ;-)
19:03:27 <SamB> you should have said "quotes and reboot day" ;-)
19:03:30 <lispy> grr...my window with irc in it keeps dying
19:03:41 <lispy> but when it does it just sits there like no one is talking
19:05:46 * Irrelevant tinkers with "data InfOrd = Middle | Before InfOrd | After InfOrd
19:05:46 <Irrelevant> "
19:06:15 * Irrelevant wonders if there's already something in the prelude to do that
19:06:15 <dons> ?uptime
19:06:18 <lambdabot> uptime: 1m 25s, longest uptime: 6d 15h 1m 36s
19:06:18 <Pseudonym> ?free fst
19:06:20 <lambdabot> ( f ($fst x) = $fst y   &&   g ($snd x) = $snd y ) => f (fst x) = fst y
19:06:27 <Pseudonym> Oh, you didn't grab the new version.
19:06:35 <dons> I was asked to?
19:06:37 * Pseudonym thought that happened automagically on Saturdays?
19:06:46 <dons> I don't check unless provoked
19:06:50 <Pseudonym> Ah, OK.
19:06:55 * Pseudonym provokes dons
19:06:55 <dons> (Saturdays -> Tuesdays)
19:06:59 <dons> yow!
19:07:13 <Pseudonym> ?free dons :: Saturdays -> Tuesdays
19:07:14 <lambdabot> dons = dons
19:07:19 <Pseudonym> Makes sense.
19:07:21 <lispy> type Saturdays = [Day]
19:07:43 <lispy> but how do you enforce that it's just saturday in that list?
19:08:23 <fons> Does anyone know how can foreign export declaration be used within type classes? The FFI addendum clearly says
19:08:38 <fons> it accepts those declarations
19:08:43 <Irrelevant> the point being that /\(a, b :- InfOrd) \/(c :- InfOrd) a < c < b
19:09:22 <fons> (I really need an example of FFI or a tutorial and the one offered in haskell.org doesn't seem to be online anymore, the link is broken)
19:09:28 * Irrelevant talks to himself, making absolutely no point whatsoever, and sounding completely fragmented 'cos he's really slow at ASCIImath (also haskell)
19:09:32 <dons> ?paste the code you're trying to work on, fons
19:09:33 <lambdabot> http://paste.lisp.org/new/haskell
19:09:58 <SamB> Irrelevant: I don't have a clue what you just said
19:10:07 <SamB> but it reminds me of dependant typing for some reason
19:10:26 <Irrelevant> samB: /\ is forall, \/ is exists, :- is is-member
19:10:40 <SamB> oh.
19:10:52 <SamB> I though exists was supposed to be a backwards E?
19:10:53 <Irrelevant> in english, any two InfOrd values will have another one between them
19:11:12 <Irrelevant> ( /\ looks like a big pointy-and, \/ like a pointy-or)
19:11:20 <lisppaste2> fons annotated #28560 with "Begining the marshalling" at http://paste.lisp.org/display/28560#1
19:11:33 <Irrelevant> samB, it is, but that's not ASCII
19:11:35 <fons> dons, there you go
19:12:05 <Irrelevant> this is similar to using big-cup and big-cap for n-ary intersect & union
19:12:07 <goltrpoat> \forall a, b \in InfOrd. \exists c. a < c < b :)
19:12:21 <Irrelevant> tex also works :P
19:12:28 <dons> ?where djinn
19:12:29 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
19:13:38 <monochrom> Is omega an InfOrd?  Is omega+1 an InfOrd?
19:13:52 <Irrelevant> anyway, such a type is useful for things like operator precedence tables, 'cos you can always squeeze another one in the middle without having to move all the others. not that I intend to use it for anything like that, I just find the concept interesting
19:14:03 <fons> lispy, you were right regarding STablePtr, a exportable function "is supposted" to be able to return it
19:14:26 <skew> does anybody know exactly what a StablePtr is?
19:14:34 <Irrelevant> and Haskell's the first language i've encountered where it's reasonably sane to overload the comparison operators to do such a thing
19:14:36 <fons> so I don't really know why the module doesn't provide a null pointer directly, it doesn't make sense
19:14:46 <lispy> skew: yeah, it's something i don't understand :)
19:14:46 <Irrelevant> monochrom, omega?
19:14:49 <SamB> (a, b  InfOrd): (c  InfOrd): a < c < b
19:14:52 <goltrpoat> irrelevant:  still need to make sure it's a total ordering, no?
19:14:54 <goltrpoat> samb:  good lord.
19:14:55 <Irrelevant> egad!
19:14:56 <dons> ?hoogle nullPtr
19:14:57 <lambdabot> Foreign.Ptr.nullPtr :: Ptr a
19:15:04 <monochrom> Nevermind, I thought you really meant infinite ordinals.
19:15:13 <lispy> ?hoogle castPtr
19:15:14 <lambdabot> Foreign.Ptr.castPtr :: Ptr a -> Ptr b
19:15:14 <lambdabot> Foreign.Ptr.castPtrToFunPtr :: Ptr a -> FunPtr b
19:15:14 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
19:15:27 <lispy> seems like castPtrToStablePtr should do it?
19:15:28 <Irrelevant> monochrom, you can't honestly expect me to use the right terminology :P
19:15:46 <monochrom> OK, so what is between Before Middle and Middle?
19:15:58 <Irrelevant> After (Before Middle)
19:16:09 <fons> skew, its a pointer to an object in Haskells heap which won't be freed till you make it explicit
19:16:15 <skew> lispy: I was reading some stuff in the Commentary, which suggests there are special StablePtr records in the heap
19:16:17 <scodil> is it generally the case that for all the standard container types, that if a function of that container doesn't return Maybe a, then it throws an error if the container is empty? Lists, Maps, etc...
19:16:32 * palomer scolds haskell for not evaluating in the order I want!
19:16:41 <skew> fons: I've got that, part, I'm wondering what it looks like in the heap.
19:16:48 <monochrom> Do you have a complete set of axioms saying how to determine a<b for InfOrd's?
19:16:49 <SamB> palomer: you aren't supposed to know when that happens
19:16:51 <fons> lispy, yes it should, but why not include it directly as a helper function
19:16:54 <SamB> unless you are, say, profiling?
19:17:04 <skew> If any of you follow ghc-haskell-users, you might have seen my evil heap-inspecting function?
19:17:32 <SamB> skew: it won't look like something will it?
19:17:38 <goltrpoat> monochrom:  might be able to get away with a partial ordering, depending on the application
19:17:41 <SamB> its basically an index into a table...
19:17:42 <lisppaste2> Irrelevant pasted "InfOrd (NB: terminology abuse)" at http://paste.lisp.org/display/28588
19:17:43 <palomer> SamB, if I'm sTracing I will!
19:17:51 <fons> skew, probably like any other Ptr pointer ... but not tracked by the garbage collector (and you make that explicit when calling newSTablePtr)
19:17:53 <palomer> err, make that tracing
19:17:57 <palomer> sTrace is my little variant
19:18:17 <SamB> fons: stop spreading disinformation about StablePtrs
19:18:42 <palomer> or else!
19:18:46 <fons> SamB, :| yep, I'll better shut up
19:18:58 <skew> I should be able to tell you about the heap representation in a little bit
19:19:19 <skew> addressOf a = a `seq` unsafeCoerce# (Box a) :: Ptr ()
19:19:41 <goltrpoat> i keep getting electric shocks from my laptop.  i find this unsettling.
19:19:52 <skew> goltrpoat: are you trying to use unsafePerformIO?
19:20:00 <fons> SamB, actually I just met the StablePtr
19:20:01 <scodil> hah
19:20:17 <goltrpoat> skew:  i am not trying to do anything, at this very moment.
19:20:48 <goltrpoat> oh.  did i just miss the joke.
19:20:51 <Irrelevant> \forall x \in InfOrd: Before x < x < After x, f(Before x) < f(x) < f(After x)
19:20:59 <Irrelevant> (where f = Before | After)
19:21:12 <scodil> i had a polaroid dvd player that, whenever you pressed the skip chapter button, would shock you and then reboot
19:21:16 <Irrelevant> I think
19:21:23 <Irrelevant> the bit before the comma, anyway
19:21:36 <Irrelevant> I can't remember the formalisation of the details offhand
19:22:00 <goltrpoat> scodil:  i had a guitar with a neck pickup that would randomly shock the absolute living crap out of you once a month or so.
19:22:01 <fons> dons, did you have a look at the paste? I'd be really tahnkful if you could have a look at it, I don't seem to be able to find a tutorial on FFI anywhere
19:22:13 <palomer>           do {sTrace $ "pup " ++ (concat $ map show gamma) ;error $ "free variable " ++ a} <--it should print "pup" at some point, right?
19:22:47 <skew> whoa, castPtrToStablePtr (Ptr a) = StablePtr (unsafeCoerce# a)
19:23:02 <coffeemug> hey guys
19:23:23 <SamB> skew: faking!
19:23:25 <SamB> its faking!
19:23:33 <palomer> sTrace x = trace x $ return ()
19:23:36 <SamB> its like if you were to cast an int to a void* in C
19:23:45 <skew> ah, "Moreover, 'castPtrToStablePtr' may
19:23:45 <skew> -- only be applied to pointers that have been produced by
19:23:47 <skew> -- 'castStablePtrToPtr'."
19:24:15 <skew> ok, that makes a lot more sense. and newStablePtr depends on makeStablePtr#
19:24:17 <palomer> http://www.rafb.net/paste/results/tgKGHg74.html
19:24:17 <SamB> I expect the docs for castStablePtrToPtr also admonish you to never dereference the Ptr?
19:24:32 <skew> yep
19:24:33 <SamB> its really only there for being able to pass StablePtrs through C code
19:24:52 <Cale> palomer: the return () was optimised away
19:25:16 <goltrpoat> ooh.  it appears that ive figured out why fac 3 is taking 106 reduction steps.  fac 0 ends up reducing two ifs, even though it should be one.
19:25:34 <fons> SamB, but can't you export StablePtrs directly to C?
19:26:08 <SamB> fons: but what if the API was imported already with Ptrs?
19:26:19 <palomer> grar!
19:26:26 <palomer> Cale, how do I fix it?
19:26:29 <fons> SamB, yep, that makes sense
19:26:32 <Irrelevant> whups...
19:26:46 <skew> looks like a StablePtr contains a small integer
19:26:52 * Irrelevant notices a nasty empty triangle in his play-by-mail go game
19:26:59 <SamB> skew: hopefully!
19:27:03 * Irrelevant is tempted to fill it in
19:27:14 <Irrelevant> (you KNOW when you've been dangoed!)
19:27:27 <fons> SamB, could you please point me to an example of use of "foreign export" ?
19:27:29 <palomer> see, it's not cool when haskell optimizes out a trace
19:27:31 <palomer> don't you guys think so?
19:27:50 <SamB> Philippa_: btw, that was a rhetorical question
19:27:57 <SamB> you didn't have to answer it...
19:28:16 <goltrpoat> oh, guess i'm wrong.  it reduces 'if' twice because the predicate isn't in HNF the first time around
19:28:22 <SamB> I *know* they are right ;-)
19:29:04 <monochrom> Still, I expect just 12 steps per iteration, there are 3 iterations, shouldn't exceed a hundred.
19:29:27 <SamB> though, truth be told, C being strict, void might as well have a value -- it wouldn't really give you anything except the ability to tail-call void-returning functions more easily
19:30:13 <goltrpoat> monochrom -- well, main = fac 0 computes in 16 reductions, that's somewhat reasonable, since my True and False are CAFs, and the ifs are functions
19:30:25 <goltrpoat> fac 3 taking 106 iterations is nuts though.
19:31:13 <palomer> back in my day, fac 3 took a week! and sometimes it would simply return a syntax error
19:31:21 <monochrom> hahaha
19:31:28 <goltrpoat> hahah
19:32:04 <monochrom> What is CAF?
19:32:14 <goltrpoat> constant applicative form
19:32:22 <palomer> canadian air force
19:32:57 <goltrpoat> bah.  damn backspace.
19:32:58 <coffeemug> ?seen dons
19:33:00 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 18m 2s ago.
19:33:12 <Irrelevant> #haskell-overflow?
19:33:15 <monochrom> I want to know how fac 0 takes 16 steps.
19:33:15 <goltrpoat> monochrom -- a supercombinator that isn't a lambda abstraction, basically
19:33:28 <palomer> ok, if someone fixes my last paste, I'll send them a box of chocolates on next valentines day
19:33:36 <Irrelevant> monochrom, lots of under-the-bonnet silliness?
19:34:08 <goltrpoat> i don't know, there's something dumb going on.  the number of steps for fac n is 16+30n, heh.
19:34:13 <goltrpoat> at least it's increasing by a constant amount though.
19:34:20 <goltrpoat> anyway, gotta run.. bbiab
19:34:35 <monochrom> wacky
19:35:42 <scodil> is there a cleaner way to do this :  if predicate then someIO else return () ?  something like if without the else?
19:36:30 <palomer> @hoogle ifM
19:36:31 <lambdabot> Network.Socket.throwSocketErrorIfMinus1_ :: Num a => String -> IO a -> IO ()
19:36:31 <lambdabot> System.Directory.createDirectoryIfMissing :: Bool -> FilePath -> IO ()
19:36:31 <lambdabot> Foreign.C.Error.throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
19:36:42 <palomer> @hoogle when
19:36:43 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
19:36:43 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
19:36:45 <foxy__> @seen dons
19:36:46 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 21m 49s ago.
19:36:50 <scodil> perfect. thanks
19:36:51 <palomer> use when
19:37:04 <monochrom> Why do people look for "if without the else"?  But anyway it's "when predicate someIO"
19:37:09 <foxy__> dons: what do I need to do to get hs-plugins to compile with ghc6.6?
19:37:41 <Bobstopper> What can I use to find the directory of the currently executing program in haskell (eg the directory component I might expect returned with getProgName)?
19:37:43 <palomer> man, I have an itch to go to japan
19:37:46 <palomer> frustration does that to me
19:37:55 <SamB> monochrom: well, I wouldn't have been surprised if "if without the else" actually *worked*
19:38:12 <palomer> first person to solve my problem gets a mention when I win  my nobel prize
19:38:16 <Bobstopper> palomer: unless you're Japanese, Japan might frustrate you even more :)
19:38:25 <palomer> I'm not japanese, and it doesn't!
19:38:42 <palomer> ties are decided by drawing straws
19:40:26 <coffeemug> foxy: hs-plugins don't work with 6.6 at the moment
19:40:41 <coffeemug> foxy: supposedly they should be ported within the next couple of weeks or so
19:40:52 <foxy> ah, okies
19:46:42 * SamB wonders what is taking so long with compiling Data.Tuple...
19:47:30 <Bobstopper> palomer: I can't reproduce your problem :(
19:47:33 <Irrelevant> well, you've gotta compile (,), (,,), (,,,), (,,,,), ...
19:47:39 <SamB> true
19:47:47 <Irrelevant> \:P
19:47:53 <SamB> I bet the typeclass instances cost more though
19:47:58 <SamB> especially Read and Show...
19:48:25 <SamB_XP> @instances-importing Data.Tuple Show
19:48:26 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
19:48:32 <SamB_XP> @instances Data.Tuple Show
19:48:34 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
19:48:36 <SamB_XP> @instances Show
19:48:38 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
19:48:50 <SamB_XP> @hoogle ,
19:48:51 <lambdabot> Data.Map.findMax :: Map k a -> (k, a)
19:48:52 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
19:48:52 <lambdabot> Data.Map.elemAt :: Int -> Map k a -> (k, a)
19:48:56 <SamB_XP> @hoogle (,)
19:48:57 <lambdabot> Data.Map.findMax :: Map k a -> (k, a)
19:48:58 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
19:48:58 <lambdabot> Data.Map.elemAt :: Int -> Map k a -> (k, a)
19:49:03 <ThreeQ> ?type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
19:49:04 <lambdabot> forall t30 t29 t28 z y x w v u t s r q p o n m l k j i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z ->
19:49:05 <lambdabot>  t28 -> t29 -> t30 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30)
19:49:11 <Irrelevant> eeeeegad
19:49:20 <ThreeQ> whoa
19:49:25 <SamB_XP> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1  1 1 1  1 1 1 1  1 1 1 1  1 1 1  1 1
19:49:26 <lambdabot>     add an instance declaration for (Show (a,
19:49:26 <lambdabot>               ...
19:49:32 <ThreeQ> ?type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
19:49:33 <lambdabot> forall t79 t78 t77 t76 t75 t74 t73 t72 t71 t70 t69 t68 t67 t66 t65 t64 t63 t62 t61 t60 t59 t58 t57 t56 t55 t54 t53 t52 t51 t50 t49 t48 t47 t46 t45 t44 t43 t42 t41 t40 t39 t38 t37 t36 t35 t34 t33 t32
19:49:34 <lambdabot> t31 t30 t29 t28 z y x w v u t s r q p o n m l k j i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z ->
19:49:34 <lambdabot> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 ->
19:49:34 <lambdabot> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> (a, b, c, d, e, f, g, h, i, j,
19:49:36 <lambdabot> k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57,
19:49:37 <SamB_XP> > (,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1  1 1 1  1 1 1 1  1 1 1 1  1 1 1  1 1
19:49:39 <lambdabot> t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72, t73, t74, t75, t76, t77, t78, t79)
19:49:41 <lambdabot>    The function `(,,,,,,,,,,,,,,,,,,,,)' is applied to 29 arguments,
19:49:43 <lambdabot>   bu...
19:49:44 <Irrelevant> . . .
19:49:49 <SamB_XP> > (,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1  1 1
19:49:50 <lambdabot>     add an instance declaration for (Typeable7 ((,,,,,,,,,,,,,,,,,,,,) a
19:49:51 <lambdabot>  ...
19:49:56 <SamB_XP> > (,,,,,,,,,,,,,,,,,,,,) 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
19:49:57 <lambdabot>     add an instance declaration for (Typeable7 ((,,,,,,,,,,,,,,,,,,,,) a
19:49:57 <Irrelevant> I think that's quite enough of that
19:49:57 <lambdabot>  ...
19:50:07 <SamB_XP> oh, wait...
19:50:11 * SamB_XP sees problem
19:50:47 <SamB_XP> > (,,,,,,,) 1 1 1 1 1 1 1
19:50:48 <lambdabot>  add an instance declaration for (Typeable7 ((,,,,,,,) a))
19:50:53 <SamB_XP> > (,,,,,,) 1 1 1 1 1 1
19:50:55 <lambdabot>  Add a type signature
19:51:03 <SamB_XP> what???
19:51:09 <SamB_XP> oh.
19:51:10 <SamB_XP> > (,,,,,,) 1 1 1 1 1 1 1
19:51:12 <lambdabot>  (1,1,1,1,1,1,1)
19:51:25 <SamB_XP> how dull :-(
19:51:45 <dibblego> > type (,)
19:51:45 <lambdabot>  Parse error
19:51:48 <dibblego> ?type (,)
19:51:49 <lambdabot> forall b a. a -> b -> (a, b)
19:51:54 <SamB_XP> > typeOf (,)
19:51:55 <lambdabot>  Add a type signature
19:52:14 <SamB_XP> > typeOf ((,) :: () -> () -> ((),()))
19:52:16 <lambdabot>  () -> () -> ((),())
19:53:08 <SamB_XP> okay, some crazy girl named Ashley thinks that void has a value
19:53:13 <SamB_XP> in C
19:53:25 <SamB_XP> someone please refute her mail?
19:53:33 <dibblego> does the type () have a value?
19:53:40 <Irrelevant> > ()
19:53:42 <lambdabot>  ()
19:53:43 <SamB_XP> inded it does!
19:53:43 <dons> SamB_XP: is a strange person
19:53:46 <SamB_XP> er, indeed.
19:53:47 <Irrelevant> ?type ()
19:53:48 <lambdabot> ()
19:53:51 <Irrelevant> rather
19:53:58 <dibblego> maybe she is confused with ()
19:54:11 <dons> > enumFromTo minBound (maxBound :: ())
19:54:12 <lambdabot>  [()]
19:54:16 <SamB_XP> she is specifically arguing that void is like ()...
19:54:29 <dons> I'm not sure Ashley Yakely is female, btw..
19:54:30 <Irrelevant> SamB_XP, in some compilers, it's actually aliased to int or char, IIRC
19:54:35 <Irrelevant> but don't quote me on that
19:54:35 <dibblego> it is in some sense
19:54:36 <Irrelevant> ever
19:54:39 <SamB_XP> Irrelevant: heh
19:54:49 <SamB_XP> well, the standard says otherwise ;-)
19:54:53 <dibblego> a C function that returns void implicitly updates registers
19:55:42 <SamB_XP> dons: oh well, just don't point him at those IRC logs if it is a him...
19:56:32 <ThreeQ> is there any function f such that f "x" "axbbbxcc" = ["a","bbb","cc"]?
19:56:45 <dibblego> ThreeQ, I wrote one
19:56:56 <ThreeQ> but none in the standard libraries?
19:57:07 <Irrelevant> split(), if you were using perl :P
19:57:12 <fons> no prolymorphic parameters are accepted in "foreign export"?
19:57:19 <fons> polymorphic
19:57:19 <SamB_XP> they were just going to add something like "join"
19:57:20 <ThreeQ> irrelevant: yes, exactly
19:57:26 <fons> foreign export ccall "descriptor_ptr" descriptorPtr :: Int -> IO (StablePtr (Descriptor id hd))
19:57:27 <benben> On which platform ghc generates native code without through gcc?
19:57:29 <ThreeQ> it's a pretty useful function
19:57:36 <coffeemug> dons: hey
19:57:52 <dibblego> ThreeQ, actually I wrote f 'x' "axbbbxcc" = ["a","bbb","cc"] -- note, not "x"
19:58:09 <dibblego> lispy wrote that function - so he told me
19:58:34 <Botty> I'm surprised that they didn't write a prelude function for that and write "words" and "lines" with it
19:58:44 <dibblego> me too
19:59:03 <SamB_XP> probably they did but couldn't figure out what to call them ;-P
19:59:15 <Botty> split
19:59:32 <SamB_XP> but what about the partial-inverse?
19:59:39 <Botty> and have it take a two strings, the first every char is a splitter.  either that or a list of strings...
20:00:00 <Cale> palomer: er, I recommend using Debug.Trace
20:00:03 <ThreeQ> unsplit?
20:00:26 <ThreeQ> join is better but it's already taken :)
20:00:33 <SamB_XP> we know ;-)
20:00:41 <Cale> palomer: oh, you are :)
20:00:43 <SamB_XP> I mentioned this on the list thread ;-)
20:01:05 <Cale> palomer: try   trace x `seq` return ()
20:01:19 <Cale> or, even better
20:01:36 <Cale> palomer: Control.Concurrent.evaluate (trace x)
20:01:40 <dibblego> does unlines (lines a) == a for all a?
20:02:05 <Cale> of course, this is just a little silly, if you're in IO
20:02:30 <ThreeQ> ?check \a -> unlines (lines a) == a
20:02:32 <lambdabot>  Falsifiable, after 3 tests: "\995338\78933\947277"
20:02:34 <Cale> > lines "\n\na\n\nb\nc"
20:02:36 <lambdabot>  ["","","a","","b","c"]
20:02:37 <glguy> does anyone know a good place to get an boot floppy image for when you blow away your bootloader?
20:02:42 <dibblego> that's what I thought
20:02:56 <Cale> > unlines (lines "\n\na\n\nb\nc")
20:02:58 <lambdabot>  "\n\na\n\nb\nc\n"
20:03:03 <dibblego> if it did hold, is there a name for that relationship between two functions?
20:03:19 <Cale> unlines would be a left inverse for lines
20:03:26 <Cale> I don't know why that quickcheck failed
20:03:35 <dibblego> because I don't think it does hold
20:03:37 <Cale> > unlines (lines "abc")
20:03:39 <lambdabot>  "abc\n"
20:03:43 <Cale> ah, that's why
20:03:55 <Botty> ouch
20:04:00 <Irrelevant> dibblego, inverse
20:04:12 <Botty> its cuz it took the easy method and used concatMap as opposed to the fold1
20:04:14 <Irrelevant> also, both fns would have to be bijective
20:04:15 <Botty> foldr1
20:04:24 <Cale> f is called the inverse of g if f . g = g . f = id
20:04:39 <Cale> f is a left inverse for g if f . g = id
20:04:50 <Cale> and a right inverse if g . f = id
20:04:57 <dibblego> yes maybe I should have said
20:05:08 <dibblego> unlines (lines a) == a && lines (unlines a) for all a?
20:05:13 <Irrelevant> (but that's a different matter, and often ends up w/ you using the word "onto" as an adjective. which makes my grammar-fascist aspect harakiri)
20:05:14 <dibblego> which I assume is an inverse
20:05:24 <Cale> dibblego: yeah
20:05:38 <palomer> Cale, shouldn't ghc know not to optimize out my trace?
20:05:39 <Cale> Irrelevant: surjective
20:05:40 <Cale> :)
20:05:56 <Irrelevant> Cale, and you expect me to remember which way round those are?
20:06:04 <Cale> palomer: traces are only evaluated if the things they're attached to are
20:06:07 <Botty> > unlines(lines "abc\n\ndefg\n\r\nhi")
20:06:09 <lambdabot>  "abc\n\ndefg\n\r\nhi\n"
20:06:19 <Irrelevant> > unlines (lines "")
20:06:21 <lambdabot>  ""
20:06:24 <Irrelevant> hm
20:06:29 <dibblego> I think lines and unlines can be written to be the inverse of each other
20:06:33 <Irrelevant> > unlines (lines "a")
20:06:34 <lambdabot>  "a\n"
20:06:38 <Irrelevant> there we go
20:07:17 <Irrelevant> dibblego, yes
20:07:32 <Botty> > unlines(init lines "a")
20:07:33 <lambdabot>    The function `init' is applied to two arguments,
20:07:34 <lambdabot>   but its type `[a] -...
20:07:52 <Botty> > unlines(init (lines "a"))
20:07:54 <lambdabot>  ""
20:08:13 <Botty> uhh
20:08:26 <Botty> > init lines "a"
20:08:28 <lambdabot>    The function `init' is applied to two arguments,
20:08:28 <lambdabot>   but its type `[a] -...
20:08:35 <Botty> > init (lines "a")
20:08:37 <lambdabot>  []
20:08:42 <Botty> > lines "a"
20:08:42 <Irrelevant> lines = split "\n"; unlines = concat . intersperse "\n"
20:08:44 <lambdabot>  ["a"]
20:09:04 <Irrelevant> i think those'd be inverses
20:09:14 <dibblego> ?type split
20:09:16 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:09:23 <Botty> probably, if you had proper splits and intersperse funcs
20:09:42 <Irrelevant> intersperse is part of Data.List. split... aye, there's the rub
20:09:51 <Botty> > init (unlines (lines "a"))
20:09:53 <lambdabot>  "a"
20:09:57 <Botty> yey
20:10:03 <Bobstopper> Q on gtk2hs & glade - does the glade specification get loaded at compile time or run time?
20:10:31 <Botty> ?check \a -> init (unlines (lines a)) == a
20:10:33 <lambdabot>  Exception: Prelude.init: empty list
20:11:23 <Botty> ?check \a -> init ("gooble" :: unlines (lines a)) == "gooble" :: a
20:11:24 <lambdabot>  unlines (lines a)       Inferred type: [Char],     In the expression: "goob...
20:11:41 <Botty> ?check \a -> init ("gooble" ++ unlines (lines a)) == "gooble" ++ a
20:11:42 <lambdabot>  Falsifiable, after 0 tests: ""
20:11:44 <dibblego> I think you mean ++
20:11:46 <Botty> yeah
20:12:10 <Botty> can i have it not test a case....
20:12:19 <dibblego> init ("gooble" ++ unlines (lines ""))
20:12:21 <dibblego> > init ("gooble" ++ unlines (lines ""))
20:12:23 <lambdabot>  "goobl"
20:12:27 <Botty> yeah
20:12:56 <monochrom> Falsified after 0 tests?  Boy that's fast.
20:13:34 <Botty> ?check \a -> init (unlines(lines ("gooble" ++ a))) == "gooble" ++ a
20:13:36 <lambdabot>  OK, passed 500 tests.
20:13:38 <Botty> woot
20:13:47 <dibblego> "after the nth test" or "after n+1 tests"
20:16:23 <coffeemug> did anyone actually get ghc to build on windows?
20:18:18 <coffeemug> how do I install MinGW
20:18:23 <coffeemug> it's about a billion packages
20:18:29 <coffeemug> and it's very unclear which ones are necessary
20:18:31 <coffeemug> and which ones aren't
20:18:56 <Smokey`> coffeemug: eh, just get the binary installation?
20:20:23 <coffeemug> I'd love to
20:20:32 <coffeemug> but I don't think there's a single binary installation with everything
20:22:08 <Irrelevant> are there any more esoteric operators like $ which're useful to know about?
20:22:26 <emu> function application is esoteric?
20:22:28 <Botty> $ isn't exactly esoteric
20:22:44 <Botty> there's the related operator, function composition,  the . operator
20:22:57 <SamB_XP> emu: I see what he means, though...
20:23:03 <Irrelevant> well, it's not strictly necessary, and brings a certain perl-like aspect to the language... hence "esoteric"
20:23:10 <SamB_XP> heh
20:23:14 <Irrelevant> I did know (.) already :P
20:23:15 <SamB_XP> it isn't perl-like at all ;-)
20:23:30 <SamB_XP> I don't think you'll run into anything else like that, no ;-)
20:23:34 <Irrelevant> it's got dollar signs, and it lets you omit parentheses. that's perl-like.
20:23:41 <SamB_XP> unless you count $!
20:23:49 <Irrelevant> I do. what is $!?
20:23:56 <emu> > zipWith ($) [(1+),(1-)] [1,2]
20:23:57 <lambdabot>  [2,-1]
20:24:05 <SamB_XP> strict version of $
20:24:10 <Irrelevant> fine.
20:24:25 <SamB_XP> > const 1 $ undefined
20:24:26 <lambdabot>  1
20:24:29 <SamB_XP> > const 1 $! undefined
20:24:31 <lambdabot>  Undefined
20:24:46 <foxy> coffeemug: gcc-core, mingw32-make, mingw, mingw-runtime, mingw-utils, msys, msys-autoconf, msys-automake, msysDTK, msys-libtool
20:25:02 <Botty> I think <=> should be a synonym for compare.  Forgot what language has this, but i think its neat
20:25:09 <Irrelevant> msys? you poor, poor bsod
20:25:16 <Irrelevant> Botty, perl has it
20:25:49 <Irrelevant> it's called the spaceship operator, IIRC (also "numeric cmp", 'cos cmp does for strings what <=> does for numbers)
20:26:15 <Botty> ah, yeah, i remember that its called that
20:26:19 <coffeemug> arghhh
20:26:23 <coffeemug> I think I have to be rood
20:26:26 <coffeemug> root
20:26:43 <Botty> hah, windows has root?
20:26:51 <Irrelevant> (re my "poor bsod" comment, in my experience, msys seems to be cygwin & mingw32's inbred bastard child)
20:26:52 <SamB_XP> it doesn't look anything like an N64 controller....
20:27:08 <Irrelevant> (ie not something to touch, ever)
20:27:34 <Irrelevant> coffeemug, is WinHugs so bad really?
20:28:33 <foxy> Irrelevant, msys + mingw has no cygwin dependency and is actually quite good
20:28:54 <SamB_XP> foxy: I don't think he meant the "bastart child" stuff that literally
20:28:59 * SamB_XP goes to bed now
20:29:53 <Irrelevant> I mean, my most direct experience with anything called msys was the msys shell, which seems to be trying to do something that cygwin does, IME, badly, and doing an even worse job of it
20:30:07 <coffeemug> well
20:30:20 <coffeemug> my goal was to use Haskell to build an app that will run on windows desktop
20:30:34 <Irrelevant> ah, so yuo actually need to compile
20:30:36 <coffeemug> and quite recently I found out that a lot of stuff in it doesn't work on windows
20:30:54 <coffeemug> like threading is effectively broken
20:31:15 <dnox> coffeemug: why build ghc on win, just use the .msi installer?
20:31:15 <coffeemug> so I was going to build GHC and try to debug the RTS
20:31:31 <coffeemug> dnox: becuase I need to debug some stuff
20:31:36 <coffeemug> that's broken on windows
20:31:43 <dnox> coffeemug: like?
20:32:03 <dnox> foxy: did you manage to install hs
20:32:15 <dnox> foxy: did you manage to install hs-plugins on win without cygwin?
20:32:32 <coffeemug> dnox: for example, if I try to run a program that uses hs-plugins through ghci it crashes
20:32:49 <coffeemug> also if one thread tries to load a plugin while another is waiting on user input, the application locks up
20:32:53 <dnox> ohh yep heard about that
20:33:05 <coffeemug> these are two pretty big things for me (especially the second one)
20:33:24 <dnox> you still didnt install hs-plugins outside of cygwin?
20:33:54 <coffeemug> hs-plugins installs without cygwin fine
20:34:22 <dnox> did you try it? i did, it installs for me.. but doesnt work
20:34:31 <coffeemug> on win?
20:34:32 <coffeemug> it works
20:34:36 <coffeemug> in limited conditions :)
20:34:47 <coffeemug> the funny thing is, I looked through the code and I have a pretty good guess why ghci craps out with hs-plugins
20:34:50 <dnox> did you install it without cygwin?
20:34:58 <coffeemug> well, I did it through cygwin
20:35:02 <coffeemug> but it doesn't use cygwin to run
20:35:11 <coffeemug> but I can't get ghc to build
20:35:16 <coffeemug> to fix the problem :)
20:38:19 <coffeemug> I think that if GHC team wants windows developers
20:38:30 <coffeemug> they should definetly make the damned thing easy to build and debug
20:38:52 <Pseudonym> I think that it requires windows developers to make the thing easy to build and debug.
20:38:55 <Pseudonym> Chicken, meet egg.
20:39:03 <coffeemug> for example, providing a workstation file for Visual Studio Express (which is free)
20:39:19 <coffeemug> Pseudonym: there *are* windows devs
20:39:32 <coffeemug> it's not like nobody develops on windows
20:40:27 <coffeemug> how do I tell ghc the output folder for building stuff?
20:43:51 <foxy> dnox: I had it working with 6.5 but not with 6.6
20:44:37 <dnox> foxy: yep it dont work for 6.6 yet, could you help me to get it working?
20:44:49 <foxy> dnox, I can try...
20:44:57 <dnox> cool
20:45:15 <dnox> take it in #haskell-overflow so we dont have to spam here?
20:46:15 <foxy> ok
20:53:50 <foxy> coffeemug: I've got hs-plugins compiled under ghc6.6
20:54:26 <coffeemug> foxy: great
20:54:30 <coffeemug> foxy: how'd you do that?
20:54:40 <coffeemug> could you post your instructions on the wiki?
20:55:14 <foxy> @where wiki
20:55:15 <lambdabot> I know nothing about wiki.
20:56:00 <Cale> haskell.org
20:56:01 <Cale> :)
20:56:49 <foxy> coffeemug, I haven't tested it yet, but 1) add "Typeable.h" to the "includes" line of plugins.cabal; 2) change all AltData.* imports to Data.* imports; 3) remove AltData.* from exposed packages in plugins.cabal
20:57:36 <coffeemug> that sounds cool
20:57:46 <coffeemug> not too hard once you figure out what to do
20:57:54 <Bobstopper> What can I use to find the directory of the currently executing program in haskell (eg the directory component I might expect returned with getProgName)?
20:57:54 <coffeemug> I think I'll stick with the 6.4 build
20:58:14 <coffeemug> and move when dons integrates the changes into his repos
20:58:19 <coffeemug> you should definetly send him the patches
21:00:04 <dons> coffeemug: did you work out the buffering/threading issue?
21:01:19 <coffeemug> hey dons
21:01:26 <coffeemug> yeah I did, I made the app single threaded :-D
21:01:36 <foxy> dons, is there an hs-plugins repo that I can patch against?
21:01:57 <coffeemug> btw, I have a feeling I know why ghci on win32 craps out when you try to load a plugin
21:02:03 <coffeemug> I looked at linker.c very briefly
21:02:27 <coffeemug> and it looks like when it tries to compare module names to check if they're already loaded it uses a case sensitive comparison
21:02:30 <coffeemug> which is right on unix
21:02:41 <coffeemug> but I bet that's what causes the screwup on windows
21:02:53 <coffeemug> I'm trying to build ghc to fix that
21:03:04 <coffeemug> just going through the monsterous process of getting mingw
21:04:21 <dons> coffeemug: i made the call to lookupSymbol threadsafe, btw. did that help at all?
21:04:32 <dons> foxy: just patch against the main repo
21:04:45 <coffeemug> dons: it's in darcs?
21:05:05 <coffeemug> I'm going to get latest and rebuild when I get the chance to see
21:05:24 <dons> yep, in darcs
21:05:38 <coffeemug> dons: why do you think that has anything to do with blocking on readLine?
21:06:29 <dons> well, calling lookupSymbol will block everything. but I guess your issue is the other way around?
21:06:46 <dons> we worked out it was the buffering anyway, right?
21:06:53 <coffeemug> no
21:07:13 <coffeemug> bufferring just prevented a thread from showing stuff
21:07:18 <coffeemug> the app still locks though
21:07:26 <coffeemug> basically if I do readLine
21:07:30 <coffeemug> in thread A
21:07:35 <coffeemug> it blocks on IO
21:07:37 <dons> did we check if the calls to readLine were threadsafe?
21:07:47 <coffeemug> then i do _load in another thread
21:07:53 <coffeemug> thread B
21:08:06 <coffeemug> and thread B blocks in _load until thread A gets some input and unblocks
21:08:09 <coffeemug> that's the issue
21:08:12 <coffeemug> in a nutshell
21:08:20 <dons> right. so you could do anything in threadB and it would block?
21:08:39 <coffeemug> what do you mean by anything?
21:08:39 <dons> or does it have to be Io in thread B?
21:08:48 <coffeemug> will, not all IO blocks
21:08:50 <coffeemug> sockets are fine
21:08:56 <coffeemug> it's just _load that blocks
21:09:04 <coffeemug> specifically with hsplugins
21:09:08 <dons> I think load has to block anyway..
21:09:15 <dons> since you're loading (or swapping) code in the runtime
21:09:26 <dons> you don't want other threads continuing to run in the old code as you swap it
21:09:52 <coffeemug> dons: that's understood
21:09:57 <coffeemug> well
21:09:58 <coffeemug> sort of
21:10:06 <coffeemug> I mean
21:10:13 <coffeemug> if I'm trying to do a high performance web server
21:10:19 <coffeemug> I don't want my other threads to block
21:10:22 <dons> yeah
21:10:30 <dons> you'll just have to be careful about the code hotswapping
21:10:49 <coffeemug> so if thread A is loading a plugin and is interested in symbol blah which all other threads don't care about
21:10:53 <coffeemug> no need to block everyone
21:10:58 <coffeemug> but in my case that's not the issue
21:11:09 <coffeemug> it's basically OK that all threads are blocked
21:11:20 <dons> ok.
21:11:27 <coffeemug> but what's not ok is that _load cannot process until thread A with readLine returns
21:11:28 <dons> and we know it works fine outside of win32
21:11:41 <coffeemug> well
21:11:52 <coffeemug> I don't know if you can guess what the issue is without a win32 machine
21:12:10 <coffeemug> I'm going to try to plunge into GHC code
21:12:15 <coffeemug> and see where that leads me :)
21:12:23 <coffeemug> just gotta get the stupid build working
21:12:27 <dons> ok
21:16:26 <coffeemug> I gotta tell ya man
21:16:30 <coffeemug> downloading mingw is something
21:16:37 <coffeemug> it has about 50 different files
21:16:41 <coffeemug> each one you have to download manually
21:16:45 <coffeemug> what a crappy experience
21:16:59 <coffeemug> GHC should really build on windows without all of this crap
21:17:52 <foxy> @where hs-plugins
21:17:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
21:19:06 <dons> it does build on windows without mingw, afaik
21:20:22 <coffeemug> well
21:20:24 <coffeemug> if it does
21:20:30 <coffeemug> I'd love to see the instructions :)
21:20:43 <foxy> dons, I'm getting an Invalid repository for hs-plugins
21:20:56 <foxy> dons, GHC needs either cygwin or msys
21:21:09 <foxy> coffeemug, the instructions are in the ghc documentation
21:21:58 <JohnMeacham> the ghc you are using to compile ghc would come with the appropriate mingw
21:23:13 <dons> the above is a web page, what does the actual repo do?
21:24:06 <foxy> dons, what is the repo url?
21:25:41 <coffeemug> this is what I'm looking at
21:25:41 <coffeemug> http://www.haskell.org/ghc/docs/latest/html/building/winbuild.html
21:25:46 <lambdabot> Title: 12. Instructions for building under Windows, http://tinyurl.com/ctmp3
21:26:11 <coffeemug> ok, gonna get off
21:26:19 <coffeemug> have a good night everyone!
21:30:53 <Irrelevant> is there a standard function = (\f x -> f x x) ?
21:31:23 <mauke> @pl \f x -> f x x
21:31:24 <lambdabot> join
21:31:34 <mauke> @index join
21:31:34 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:32:34 <Cale> You'll need the Control.Monad.Reader instance for that to work.
21:32:46 <Cale> (Which is in Control.Monad.Instances in GHC 6.6)
21:34:29 <Irrelevant> ?t join
21:34:29 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:34:36 <Irrelevant> ?type join
21:34:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
21:34:42 <foxy> dons: what is the hs-plugins darcs repo url?
21:34:54 <Irrelevant> that's no good, that's only for monads
21:35:00 <mauke> functions are monads
21:35:04 <Irrelevant> er?
21:35:12 <mauke> surprise!
21:35:44 <Irrelevant> > join (*) 3
21:35:44 <int-e> @instances-importing Control.Monad.Reader Monad
21:35:45 <lambdabot>  9
21:35:46 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:35:48 <Cale> functions aren't monads, the type constructor for functions from a particular type is a monad :)
21:36:22 <mauke> ok, if m is a monad, what do you call m a?
21:36:37 <int-e> a monad action?
21:36:43 <Irrelevant> .oO( \forall a: a \in Monads ...)
21:36:54 <mauke> "functions are monad actions."
21:37:15 <Cale> yeah, monadic computations or actions
21:37:38 <Cale> Here, the monad is essentially just the Reader monad, with less wrapping
21:38:30 <Cale> basically, the actions are functions which will be passed some environment in order to compute their value.
21:38:49 <Cale> > (do x <- (1+); y <- (2*); return (x + y)) 5
21:38:51 <lambdabot>  16
21:39:01 <Cale> > (1 + 5) + (2 * 5)
21:39:02 <lambdabot>  16
21:39:37 <Irrelevant> er
21:39:37 <Cale> now, what does join do?
21:39:47 <mauke> *Main> (1 +) + (2 *) $ 5
21:39:47 <mauke> 16
21:39:53 <Irrelevant> -.-
21:39:56 <Irrelevant> o.o
21:39:57 <Irrelevant> -.-
21:40:12 <Cale> mauke: monoid instance?
21:40:18 <Smokey`> I swear, you could learn haskell simply by reading this channel :)
21:40:31 <Cale> join x = do { y <- x; v <- y; return v }
21:40:34 <mauke> Cale: instance (Num a, Monad m, Eq (m a), Show (m a)) => Num (m a)
21:40:38 <vegai> Smokey`: no, sorry :/
21:40:39 <Cale> mauke: ah
21:40:42 <int-e> oh, I wonder what -.- could mean as an infix operator.
21:40:59 <hyraxfourtwo> Smokey`, that's more or less how I did it
21:41:01 <mauke> join = (>>= id)
21:41:38 <Cale> indeed, but I'm taking this particular approach because in light of the above, it should make it clearer why join has the interpretation it does in this monad :)
21:42:10 <Cale> so suppose we're "running"  (join x) z
21:42:13 <mauke> it makes totally sense if you think about what (>>=) does with functions :-)
21:42:17 <Irrelevant> er, forget i asked, ok
21:42:48 <Irrelevant> i'm not getting any totally sense, whether made by it or not ;P
21:42:53 <Cale> so x is passed the environment z, computing a result y, which is passed the environment z, computing a result v which is returned
21:43:13 <Cale> and so the end result is x z z
21:43:21 <Irrelevant> xyzzy!
21:43:50 <mauke> @pl \x y z -> z y
21:43:50 <lambdabot> const (flip id)
21:44:20 <Irrelevant> what exactly is @pl doing, there?
21:44:29 <Irrelevant> there seems to be a lot of magic involved
21:44:40 <Cale> lots of term rewriting
21:44:41 <mauke> it removes \ and lets
21:44:57 <Irrelevant> beh
21:45:22 <Irrelevant> i must say, my wandering thru this channel has been very enlightening/opaque in turns
21:45:56 <Irrelevant> (I say wander, I've been active for three hours... maybe i should take a break :P)
21:46:02 <Cale> hehe
21:46:33 <Cale> I learned Haskell mostly by lurking here and solving other people's homework problems :)
21:46:39 <Irrelevant> damnit... my bagels've gone mouldy ><
21:48:09 <mauke> join f x = f x x;  (f >>= c) x = f x `c` x;  (c `ap` f) x = x `c` f x;  liftM2 c f g x = f x `c` g x
21:48:13 <mauke> I hope I got that right
21:48:45 <mauke> and liftM f g = f . g, of course
21:49:02 <Irrelevant> of course
21:49:36 <int-e> the infix `c` are confusing (me).
21:49:51 <mauke> c is for combining two values
21:50:00 <hyraxfourtwo> ?pl \f g x y -> f x `g` f y
21:50:00 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
21:50:05 <hyraxfourtwo> jesus
21:50:08 <Irrelevant> sod it. there's nothing salvagable on these.
21:50:16 * Irrelevant bins teh bagels >.<
21:50:20 <int-e> mauke: I can read the code (by desugaring it), but I'd never write it that way.
21:50:21 <Irrelevant> hyraxfourtwo, whoa...
21:50:46 <int-e> except for the liftM2, that makes sense.
21:50:59 <int-e> funny.
21:51:06 <mauke> >>= and ap are just special cases of liftM2 (where one of the filters is id)
21:51:11 <hyraxfourtwo> ?pl \f g -> (\x y -> f x `g` f y)
21:51:12 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
21:51:29 <hyraxfourtwo> ?pl \f -> (\x y -> f x `compare` f y)
21:51:29 <lambdabot> flip =<< (((.) . compare) .)
21:51:30 <Cale> I use ap and join
21:51:31 <Irrelevant> and to think I kicked off this whole conversation 'cos I was wondering if (^2) could be written as (foo (*)) for some foo
21:51:43 <mauke> yeah, join (*)
21:52:14 <hyraxfourtwo> I need to get my own lambdabot
21:52:39 <mauke> or liftM2 (*) id id, but that's silly :-)
21:52:42 <Irrelevant> mauke, yeah, we worked that out already
21:52:46 <Irrelevant> :P
21:53:05 <ThreeQ> hyraxfourtwo: http://lambdabot.codersbase.com/?
21:53:06 <Irrelevant> but it seems slightly unnecessary to import Monad when that's all I'm trying to do
21:53:07 <lambdabot> Title: Lambdabot Web Interface
21:53:30 <hyraxfourtwo> ThreeQ, nice
21:53:33 <mauke> come on, monads are fun for the whole family
21:53:55 <dons> foxy, http://www.cse.unsw.edu.au/~dons/code/hs-plugins
21:53:57 <Irrelevant> family -- set of sets, in this case?
21:53:57 <lambdabot> Title: Index of /~dons/code/hs-plugins, http://tinyurl.com/tmsrm
21:55:03 <hyraxfourtwo> sections of (.) are a headache for me
21:55:32 <mauke> @type \f -> foldr (flip id) f . replicate 2
21:55:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = a -> t
21:55:34 <lambdabot>    Expected type: (a -> t) -> a -> a -> t
21:56:04 <hyraxfourtwo> ?type id
21:56:05 <lambdabot> forall a. a -> a
22:00:00 * hyraxfourtwo -> bed
22:03:03 <emu> forall bed?
22:03:56 <hyraxfourtwo> nah
22:04:09 <hyraxfourtwo> but for a bed
22:04:10 <Irrelevant> forall hyraxfourtwo?
22:04:14 <hyraxfourtwo> and to be proved very soon
22:04:36 <hyraxfourtwo> Irrelevant, I think there's just one, so trivially yes
22:04:40 <Irrelevant> \forall hyraxfourtwo \exists bed : hyraxfourtwo \mapsto bed
22:14:17 <foxy> what would cause this error: "<no location info>: file name does not match module name `Main'" as I'm building a library not an .exe
22:14:42 <skew> do you have a "module Foo ..." header at the top of the file?
22:15:02 <thou> #haskell++
22:15:03 <skew> otherwise it's implicitly trying to be module Main. And then GHC complains if that doesn't match the filename
22:15:20 <foxy> skew I'll check (it's hs-plugins)
22:15:49 <skew> oh, there could be all sorts of wierdness there
22:15:59 <skew> dons: hey dons, have you fixed up hs-plugins for 6.6?
22:17:53 <skew> I just got it to crashing.
22:18:16 <foxy> skew that's what I'm doing... 1) remove AltData.* from plugins.cabal, 2) add Typeable.h to includes in plugins.cabal 3) for I in `find . -name *.hs` ; do cat $I | sed s/AltData/Data/ > $I ; done
22:18:33 <skew> darcs pull?
22:18:44 <skew> I did that a while ago, and mailed dons a patch
22:19:18 <skew> but it's still necessary to fix up the .hi parser to understand the 6.6 format
22:19:36 <skew> or perhaps change to code to use the GHC API
22:25:29 <dnox> how do you unpack tar.tar, -xvf or something?
22:26:05 <glguy> tar.tar is usually a windows bug
22:26:10 <glguy> and not an actual filetype
22:26:26 <glguy> unless you mean somename.tar
22:26:31 <glguy> then it's tar -xf
22:26:34 <Irrelevant> "tar xvf $file" is the normal way of untarring, if that's what you mean
22:27:03 <Irrelevant> if you get errors about timestamps or something, try "tar xvmf" (iirc)
22:27:21 <dnox> its in windows
22:27:28 <dnox> i guess i could remove the first tar
22:27:36 <glguy> dnox: it's probaby a tar.gz
22:27:43 <Irrelevant> it shouldn't make the first bit of difference
22:27:45 <glguy> dnox: if you fix the filename, winzip can open it
22:27:51 <glguy> Irrelevant: it does to windows
22:27:58 <glguy> err
22:28:00 <dnox> i got no problem to open it, but i wanna do it with tar
22:28:00 <glguy> winzip rather
22:28:03 <Irrelevant> foo.tar.tar vs foo.tar?
22:28:09 <glguy> Irrelevant: yeah
22:28:11 <dnox> they are foo.tar.tar now
22:28:13 <Irrelevant> both should open according to your file assocs
22:28:26 <Irrelevant> 'cos only stuff after the last dot counts as exn
22:28:28 <glguy> Irrelevant: foo.tar.tar is a IE butchered tar.gz usually
22:28:34 <dnox> i get "tar: This does not look like a tar archive"
22:28:34 <Irrelevant> oh, right
22:28:35 <dnox> okay
22:28:39 <glguy> Irrelevant: and the fact that it's not a tar but a gz breaks winzip
22:28:43 <Irrelevant> whee
22:28:51 <glguy> dnox: change the last tar to a gz
22:28:51 <Irrelevant> this is what magic numbers are for
22:28:55 <dnox> strange though since i got some other tar.gz files in the same folder
22:29:08 <glguy> dnox: do you use firefox also?
22:29:22 <dnox> naah
22:29:58 <glguy> then i don't know why you have both, but the .tar.tar is a result of IE not parsing filenames correctly
22:30:57 <glguy> dnox: and the file can be opened with tar using: tar zxf
22:31:21 <glguy> if that doesn't do it, it's also usualy to have tar.bz2 files: tar jxf
22:31:54 <glguy> if you have the "file" command
22:32:00 <glguy> it can tell you what format the file is
22:32:29 <dnox> ok, i used xzvf now and it worked after i renamed them
22:42:09 <Irrelevant> @pl \(c:cs) -> toUpper c : cs
22:42:09 <lambdabot> ap ((:) . toUpper . head) tail
22:42:18 <Irrelevant> heh
22:42:34 <Irrelevant> @pl \f x -> f x x
22:42:35 <lambdabot> join
22:43:04 <glguy> similar to : liftM2 (:) (toUpper . head) tail
22:44:49 <Pseudonym> These things make a bit more sense if you express them in terms of:
22:44:56 <Pseudonym> unpackList (c:cs) f = f c cs
22:44:58 <_velco>  
22:45:17 <Pseudonym> Then you get: unpackList ((:) . toUpper)
22:45:28 <Pseudonym> Even better:
22:45:37 <Pseudonym> caseList [] c z = z
22:45:46 <Pseudonym> caseList (x:xs) c z = c x xs
22:46:37 <Irrelevant> er... isn't that fold* with a different argument order?
22:46:46 <Pseudonym> No.
22:46:46 <glguy> fold* is recursive
22:47:21 <Pseudonym> This is the constructor-free version of a lsit.
22:47:33 <Pseudonym> In fact it isn't quite constructor free because the type is recursive.
22:47:54 <Pseudonym> nil c z = z
22:48:01 <Irrelevant> you lost me at "lsit". never mind, I think I'm in over my head.
22:48:01 <Pseudonym> cons x xs c z = c x xs
22:48:05 <Pseudonym> caseList = id
22:48:27 <Irrelevant> (even if you did mean lisT
22:48:28 <Irrelevant> )
22:48:34 <Pseudonym> No matter.
22:48:56 <dibblego> @paste
22:48:57 <lambdabot> http://paste.lisp.org/new/haskell
22:49:25 <lisppaste2> dibblego pasted "why does this take so long to execute? the cost function?" at http://paste.lisp.org/display/28595
22:50:15 <andrei> Hi; I have a question. I have a class B, and a type Blah = Blah [Int] Float, now I want to make Blah and instance of B. Now B has a function that must take all 3 parameters (Blah [Int] Float); to do this right now I use a class with multiple parameters, but multi-parameter classes are an extension which makes me wonder if this particular case actually needs them. Is there a nicer way of doing this?
22:50:42 <glguy> dibblego: first of all, | otherwise = 1 + cost xs -- is a bad idea
22:50:56 <dibblego> glguy, why?
22:51:03 <Pseudonym> andrei, you've lost me.
22:51:05 <Pseudonym> @paste
22:51:05 <lambdabot> http://paste.lisp.org/new/haskell
22:51:07 <dmead> boogidy boo
22:51:14 <dibblego> glguy, I copied it out of a book - but I think I changed that part
22:51:18 <Pseudonym> Could you please paste what you have so far?
22:51:55 <andrei> Pseudonym, sure :)
22:52:05 <dibblego> glguy, I think the book had cost = length . filter (/= Copy)
22:52:22 <glguy> dibblego: is that faster?
22:52:27 <dibblego> glguy, no
22:52:41 <dibblego> it takes so long that I give up and CTRL-C it
22:52:43 <glguy> how long is the list usually?
22:52:51 <dibblego> longer than the samples
22:52:52 <Pseudonym> dibblego, assuming no other errors, I'm guessing that making cost linear in the size of the list makes the algorithm quadratic.
22:53:04 <dibblego> Pseudonym, I was thinking something like that myself
22:53:07 <Pseudonym> Where it would be linear if cost were a constant.
22:53:35 <Pseudonym> Given that, it'd make more sense to track the cost of an [Edit] along with the [Edit].
22:53:57 <dibblego> righto, I'll think about how to do that
22:54:10 <Pseudonym> dibblego: Make a type.
22:54:16 <Pseudonym> data EditList = EditList Int [Edit]
22:54:20 <glguy> data Edits = Edits [Edit] Int
22:54:22 <Pseudonym> Change the relevant type signatures.
22:54:29 <dibblego> ah ok thanks
22:54:30 <Pseudonym> And then let the type checker find all your bugs for you.
22:55:11 <lisppaste2> andrei pasted "multi-parameter class" at http://paste.lisp.org/display/28596
22:55:22 <andrei> Pseudonym, There we go  :)
22:55:53 <Pseudonym> OK, with you so far.
22:56:02 <araujo> heya
22:56:03 <andrei> So.. is there a nicer way of doing this?
22:56:12 <int-e> dibblego: hmm, I think that algorithm is exponential.
22:56:15 <Pseudonym> Well, it depends what you want to do.
22:56:30 <dibblego> int-e, wouldn't surprise me
22:56:39 <dibblego> int-e, it takes an extraordinary amount of time as the data grows
22:57:12 <Pseudonym> andrei: Presumably the reason you've got a typeclass is you want to make code that uses "something" generic.
22:57:21 <int-e> dibblego: you have to memoize the best cost (what the transform function does) to make it run fast.
22:57:35 <Pseudonym> Is that fair to say/
22:57:37 <andrei> Pseudonym,  Yup
22:57:37 <Pseudonym> ?
22:57:40 <Pseudonym> Right.
22:58:00 <Pseudonym> Are you allowed to say what this actually is, without the "Blah"s and "something"s?
22:58:02 <dibblego> int-e, why doesn't the runtime do that for me?
22:58:29 <glguy> because memoization doesn't always make things run faster
22:58:30 <andrei> Pseudonym, It wouldn't make a difference at all (they're different genome representations for a library I'm writing for evolutionary computation)
22:58:37 <Pseudonym> Ah, OK.
22:58:37 <glguy> so it's up to you to do it
22:58:44 <lisppaste2> metaperl pasted "help needed getting import to work" at http://paste.lisp.org/display/28597
22:58:52 <Pseudonym> So what is "B" really?
22:59:23 <dibblego> is there a standard function for memoization? or do I need to use an array or something?
22:59:24 <metaperl> can someone recommend a strategy for getting my import stmt to work: http://paste.lisp.org/display/28597
22:59:29 <andrei> Pseudonym, It's a genome, having some chromosomes and weights, just provides a nice way to be able to write most of the code so that it works across abstractions
22:59:37 * Pseudonym nods
22:59:45 <Pseudonym> Can you assume that a genome is always a list?
22:59:47 <Pseudonym> Probably not.
22:59:55 <Pseudonym> There are circumstances where a tree also makes sense.
22:59:57 <andrei> Pseudonym, Nopes, it takes a few strange and interesting forms
23:00:14 <int-e> dibblego: use an array or create a list of lists (that is actually not as bad as it sounds because you only need to access neighbouring elements)
23:00:52 <Pseudonym> The only thing I can suggest given what you have here, andrei, is that a fundep might not go astray.
23:01:11 <metaperl> Pseudonym: andrei left the chat room
23:01:12 <dibblego> is there a function memoize :: (a ->b) -> a -> b ?
23:01:17 <int-e> dibblego: no.
23:01:19 <Pseudonym> Yeah, I just noticed.
23:01:47 <Pseudonym> dibblego: As an exercise, think about why not.
23:01:57 <dibblego> Pseudonym, I think I can already figure that out
23:02:06 * Irrelevant has a suspicion
23:02:21 <Pseudonym> memoize :: (Ord a) => (a -> b) -> (a -> b) -- this makes a certain amount of sense
23:02:22 <int-e> dibblego: memoization in Haskell is usually done by creating a big shared data structure that, once evaluated, contains all the values, and then let lazy evaluation do the rest.
23:03:13 <Pseudonym> That works particularly nicely for finite domains.  It's like the flyweight pattern in Gang of Four.
23:03:27 <dibblego> why Ord?
23:03:48 <Pseudonym> dibblego: How would you memoise fix :: (a -> a) -> a ?
23:03:56 <glguy> Ord allows you to store with a map
23:04:11 <dibblego> wouldn't you just need Eq for that?
23:04:13 <andrei> Pseudonym, Sorry, internet connectiviy issues
23:04:18 <int-e> dibblego: you need at least be able to tell if you've already evaluated a value or not. That gives you (Eq a) - (Ord a) is required to give it a chance of being efficient.
23:04:19 <Pseudonym> No problem.
23:04:21 <glguy> ?type M.lookup
23:04:23 <lambdabot> Couldn't find qualified module.
23:04:25 <Pseudonym> The only thing I can suggest given what you have here, andrei, is that a fundep might not go astray.
23:04:34 <glguy> ?type Data.Map.lookup
23:04:35 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
23:04:38 <glguy> ^^
23:04:51 <goltrpoat> memoizeWithRange range@(i1,i2) f = ((listArray range) (map f [i1..i2])) !), or something
23:04:51 <Pseudonym> class B chromosome bases weight | chromosome -> bases weight where
23:04:55 <Pseudonym>    -- etc etc
23:04:57 <dibblego> int-e, what is (Eq a) - (Ord a) ?
23:05:08 <glguy> the end of one sentence
23:05:11 <goltrpoat> and the non-range list version
23:05:12 <glguy> and the beginning of the next
23:05:15 <andrei> Pseudonym, Thanks; I'll look into it
23:05:21 <int-e> dibblego: the - was a dash
23:05:30 <metaperl> how do you add a directory for import to search with Hugs?
23:05:34 <Irrelevant> I think part of the problem with a memoize fn is that, if the original fn is recursive, it won't use the memos.
23:05:43 <Pseudonym> Because the type of Blah uniquely determines the other two parameters in the typeclass.
23:05:57 <Pseudonym> Incidentally, does it make sense for weights to be non-Floats/Doubles?
23:06:08 <andrei> Pseudonym, Yup
23:06:17 <Pseudonym> Bearing in mind that an Int can be stored losslessly in a Double on a 32-bit machine.
23:06:25 <goltrpoat> irrelevant:  hmm?
23:06:56 <Irrelevant> memoedFibs = memoize fibs where { fibs 0 = 1; fibs 1 = 1; fibs n = fibs(n-1) + fibs(n-2) }
23:07:01 <goltrpoat> irrelevant:  i remember alan bowden's example that actually used fib and the ((map f [0..]) !!) trick
23:07:19 <Irrelevant> memoedFibs still runs at the exact same speed the first time
23:07:39 <goltrpoat> sec
23:07:46 <andrei> Pseudonym, Yeah, that's why I felt that there must be a better way, I'll look a fundeps
23:07:52 <goltrpoat> here:  http://www.kimbly.com/blog/000263.html
23:07:57 <andrei> Pseudonym, Thanks for the help :)
23:08:02 <Irrelevant> while, if you write the memos into the def (say, fibs = 1 : 1 : zipWith (+) fibs (tail fibs)), it's much faster
23:08:15 <Pseudonym> No problem.
23:08:32 <Pseudonym> And I can't stress enough the usefulness of meaningful names for typeclass parameters in this case.
23:08:46 <Pseudonym> "a" makes sense for a single-parameter typeclass.
23:09:02 <andrei> Pseudonym, I know, the actual code has meaninful names :)
23:10:53 <goltrpoat> irrelevant:  this relies on fibs being evaluated in succession, so it's specific to the (n+k) pattern and friends..  no harm in generalizing it for those, though
23:11:21 <dons> foxy, skew: just removing the AltData stuff won't be enough will it?
23:11:30 <dons> the package formats and .hi files have changed, that's the main issue
23:11:34 <dons> so our parser has to be updated
23:12:16 <Irrelevant> goltrpoat, pardon?
23:12:23 <goltrpoat> see link
23:12:51 <Irrelevant> yeah... I'm not sure if I see why that's memo'ed, but I guess it could be
23:13:16 <dibblego> Irrelevant, me neither - I'm still staring at it
23:13:42 <Irrelevant> I think it's the output of (map fib' [0 ..]) that's memoed
23:14:19 <int-e> dibblego: btw, that's a quite degenerate edit distance problem, due to the Kill operation.
23:14:45 <dibblego> int-e, why does that make it degenerate?
23:15:10 <int-e> dibblego: because it makes the maximum edit distance 1+the length of the target string (ys)
23:15:23 <Irrelevant> goltrpoat, I'm not sure what you mean about the fibs being evaluated in succession - the recursive nature of the definiton there would ensure that fib(n-k) is eval'ed before fib(n) forall n,k
23:15:26 <int-e> dibblego: Kill, then insert target string.
23:16:21 <dibblego> int-e, I don't understand that - after a Kill, nothing should happen
23:16:40 <int-e> ok, insert target string, then kill
23:16:48 <dibblego> "abcdef" -> "abc" is [Copy, Copy, Copy, Kill]
23:17:49 <int-e> Ah. Copy doesn't cost anything.
23:18:15 <goltrpoat> irrelevant:  i think the point is that fib n = ((map fib' [0..]) !! (n-1)) + ((map fib' [0..]) !! (n-2)), so (map fib' [0..]) is evaluated up to n-1, which fib (n+1) will reuse
23:18:28 <Irrelevant> yes.
23:18:35 <Pseudonym> Oh, andrei, I have another suggestion, and that's to use phantom types.
23:19:27 <goltrpoat> irrelevant:  and since all we care about is not recomputing fib (n-1) for every fib n as we run through the ns, mission accomplished
23:19:52 <Irrelevant> I'm not sure what you're getting at -- you still need to include reference to the memos in the definition of your original fn (in this case, reference to fib in fib')
23:20:17 <Irrelevant> so memoize() wouldn't work in this case
23:21:25 <Irrelevant> if fib' didn't call fib, it'd calculate fib'(n-1) from scratch every time
23:21:41 <andrei> Pseudonym, Thanks, I'll look at that as well
23:21:50 <Pseudonym> Cool.
23:21:57 <andrei> Pseudonym, I don't know what either fundeps or phantom types are so I'll have to read up :)
23:22:02 <Pseudonym> Ah, right. :-)
23:22:05 <Pseudonym> Look on the haskell wiki.
23:22:14 <Pseudonym> Some of the stuff from the old wiki may not be moved over yet.
23:22:21 <Pseudonym> http://haskell.org/hawiki/FunDeps
23:22:23 <lambdabot> Title: FunDeps - The Haskell Wiki
23:22:25 <Pseudonym> http://haskell.org/hawiki/PhantomTypes
23:22:27 <lambdabot> Title: PhantomTypes - The Haskell Wiki
23:22:36 <andrei> Yup, that's what I'm reading
23:22:39 <andrei> Thanks :)
23:22:40 <Pseudonym> Cool. :-)
23:22:43 <glguy> any suggestions for a lightweight alternative to gkrellm? (xosview is out as it doesn't run on openbsd anymore)
23:23:08 <Pseudonym> gkrellm sounds like a bad D&D villain.
23:23:26 <lispy> any one here experienced with x86_64 or gdb?
23:23:31 <lispy> Pseudonym: yeah
23:23:50 <goltrpoat> irrelevant:  fib 0 = 0; fib 1 = 1; fib n = memoize (fib $ n-1) + memoize (fib $ n-2)  ?
23:24:20 <goltrpoat> i mean, you won't memoize it transparently, sure
23:24:25 <int-e> why would you memoize numbers?
23:24:31 <Irrelevant> goltrpoat, I mean, you can't take a non-memo'ed fn, that's already defined, and then pass it to
23:24:43 <Irrelevant> memoize :: (a->b) -> a -> b
23:24:45 <goltrpoat> er.  crap, sorry.  brackets are backwareds.
23:24:50 <goltrpoat> backwards, as well.
23:24:53 <Pseudonym> More to the point, why would you memoise THAT version of fib?
23:24:55 <lispy> > let { e 0 = True; e n = o (n-1); o 0 = False; o n = e (n-1) } in e 25 -- my scheme compiler compiled this but it crashes for n > 11
23:24:56 <lambdabot>  False
23:25:17 <lispy> and for 0 <= n < 12 it works great
23:25:24 <Pseudonym> goltpoat: That version doesn't do what you expect?
23:25:36 <goltrpoat> that version wouldn't typecheck
23:25:42 <Pseudonym> I don't think you want to memoise the two recursive calls separately.
23:25:47 <goltrpoat> i meant (memoize fib) in the last case
23:25:55 <goltrpoat> oh, point.
23:25:55 <Pseudonym> Right.
23:26:05 <Irrelevant> Pseudonym, I was using that one as an example of where memoizing after-the-fact would be an abject failure
23:26:12 * Pseudonym nods
23:26:25 <goltrpoat> agreed, you can't do it transparently
23:26:47 <Irrelevant> so... we're both arguing the same point, then?
23:26:59 <goltrpoat> looks like it
23:27:00 <Irrelevant> hurrah!
23:27:06 <goltrpoat> heh
23:27:06 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Fibonacci.hs
23:27:11 <Pseudonym> FWIW
23:27:11 <Irrelevant> have a cookie!
23:27:17 <lambdabot> http://tinyurl.com/g2436
23:29:45 * goltrpoat gets back to wondering why main = if True then 1 else main is taking 14 steps to reduce
23:30:51 <goltrpoat> (ive given up on fac 3, after spending half an hour reducing it by hand.  if it wants to take 106 steps, i'm not going to argue with it)
23:30:53 <int-e> hmm. main = case True of True -> fromInteger 1; False -> main
23:31:15 <goltrpoat> int-e:  it's a toy compiler i threw together last night
23:31:28 <goltrpoat> no case right now.
23:31:41 <goltrpoat> and definitely no fromInteger.
23:31:45 <int-e> sorry I thought it was Haskell ;)
23:33:07 <goltrpoat> untyped right now, which is why the above compiles :)
23:39:01 <goltrpoat> i guess i'll forget about it for now, since rewriting if as case and turning it into a keyword should remove a ton of applications nodes
23:48:11 <Irrelevant> *** Term           : ordinal
23:48:11 <Irrelevant> *** Type           : Int -> [Char]
23:48:11 <Irrelevant> *** Does not match : Integer -> String
23:48:13 <Irrelevant> hm
23:48:32 <ulfdoz_> Int != Integer
23:48:36 <Irrelevant> I know.
23:48:57 <Irrelevant> I find it odd that it hadn't generalised it to Num a
23:49:02 <Irrelevant> or suchlike
23:49:23 <Irrelevant> instead of being so unusually specific as to actually say "Int"
23:49:56 <Irrelevant> ?type (!!)
23:49:58 <lambdabot> forall a. [a] -> Int -> a
23:50:01 <ulfdoz_> Perhaps some interference with default type of numbers?
23:50:03 <Irrelevant> aye, there's the rub
23:50:26 <Irrelevant> bang, bang, polymorphism is dead
23:51:34 <goltrpoat> there go my hopes of having a list with more than 2^30-1 elements.
23:51:53 <Irrelevant> yes. quite.
23:52:07 <Irrelevant> 2^30? 2^31, shurely?
23:52:13 <goltrpoat> 30, oddly enough
23:52:24 <goltrpoat> the range is [-2^29..2^29-1]
23:52:40 <Irrelevant> hm. i'd've thunk, for a 32-bit int, that should be [-2^31..2^31-1]
23:52:44 <goltrpoat> i don't know if it's using a bit to tag something or other
23:52:50 <Irrelevant> or something
23:52:54 <Irrelevant> who knows
23:52:54 <goltrpoat> but http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AInt
23:52:57 <lambdabot> http://tinyurl.com/y8jbn2
23:53:41 <int-e> > maxBound :: Int
23:53:43 <lambdabot>  2147483647
23:53:47 <int-e> @type genericLength
23:53:48 <goltrpoat> ookay
23:53:49 <lambdabot> forall i b. (Num i) => [b] -> i
23:53:58 <int-e> goltrpoat: note the 'at least'
23:54:10 <goltrpoat> oh.  sorry, didn't see that
23:54:43 <Irrelevant> looks like your hopes of big lists may still have some lifein them after all! ^^
23:54:52 <goltrpoat> splendid.
23:54:59 <int-e> goltrpoat: the idea was probably to allowed tagged representations for ints (with 2 bits reserved for the tag)
23:55:09 <goltrpoat> that's what i figured, yeah
23:56:07 <goltrpoat> although, if the idea is to allow tagged representations for mark and sweep or whatever, i'm not sure what happens to Float
23:56:56 <TSC> maxBound for Int is 9223372036854775807 here
23:57:02 * TSC makes a big list
23:57:13 <goltrpoat> that's a pretty big list.
23:58:44 <ulfdoz_> nearly Turing-Machine capable. :)
23:58:58 <Cale> Some people (particularly some people who were on the standardisation commitee for Haskell) hate polymorphism
