08:11:57 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
08:11:57 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
08:11:57 --- names: list (clog cods waern beelsebob wchogg Trixsey lightstep Deformative-II kpreid fasta sris sek dfeuer jtoy madpickle nisse|hsk dolio rindolf Carillon russo_ Nioate_ metaperl dottedmag cptchaos triplah chris2 therp emk xinming__ jak arjanb gour twanvl der_eq BCoppens Syzygy-_ araujo jgrimes lhz Jaak paolino xerox Oejet iblechbot hn slipstream sethk klutometis ThreeQ kercyr ikegami-- Adamant hyrax42 svens_ mauke int-e StoneNote ex_nor Philippa_)
08:11:58 --- names: list (fnordus cwenner MarcWeber superjudge_ astrolabe perspectival crem_ MikeJS Tigge flux__ sceadu shawn foxy Patterner Godeke_ shapr Cale Plareplane roconnor qz lisppaste2 maayhem wilx earthy eno Pupeno dgoldsmith ski ramkrsna lambdabot giksos mGem thetallguy cmeme defcon8 cschneid GeoBesh eyck nothingmuch SimonRC noj lokadin_ triple_ edwinb matthew-_ Eidolos yip @Igloo Revision17 chrisb_ tmoertel_away deadbeef TSC ibid _frederik_ ulfdoz)
08:11:58 --- names: list (zamez tessier_ mlh_ norpan xinming gaal nnunley johs Kahdloc khaladan liyang dany2k Khisanth Lemmih jarmen arguile Daveman audreyt wolverian Betovsky kilimanjaro scsibug tessier ricebowl Twigathy sjanssen vegai Baughn joe_k mattam bdash mornfall epiphone boliver__ kzm__ carp carp_ sellout kaol szabi_ scw ValarQ cathper integral mathrick bran_ dfranke SamB Korollary woggle petekaz newsham saccade profmakx kosmikus juhp Spark Codex_ arcatan)
08:11:58 --- names: list (moonlite sieni df_ dcoutts lispy TwigEther lucca irgs tic aleator gds ksandstr_ dylan ozone nattfodd bartw Lunar^ cpatrick pingu drbean kpk orbitz ohub dons mux kzm dwm kalven rycee Thomas2_ resiak qwr Azmo_ kolmodin shrimpx pejo wli emu dcoutts_ psnl gdsx jmob nomeata musasabi magagr)
08:12:17 <Igloo> It should
08:12:25 <nisse|hsk> lol so why isn't it??
08:12:48 <fasta> ok, that's nice, it doesn't help me though, as that already has been worked around in Emacs.
08:13:20 <roconnor> @type error
08:13:22 <lambdabot> forall a. [Char] -> a
08:13:35 <roconnor> nisse|hsk: I think you want fail instead of error
08:13:41 <roconnor> @type fail
08:13:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
08:13:50 <nisse|hsk> hmm
08:14:46 <nisse|hsk> how do i use fail?
08:14:54 <nisse|hsk> i want to check if a bool is false
08:14:59 <roconnor> checkReadSud sud = unless (isSudoku sud) (fail "error..")
08:15:07 <nisse|hsk> oh ok
08:15:11 <nisse|hsk> i'll try it
08:15:43 <nisse|hsk> nope
08:15:43 <roconnor> > unless False (fail "boom")::Either String ()
08:15:45 <lambdabot>  Left "boom"
08:16:32 <roconnor> nisse|hsk: how do you use checkReadSus
08:16:59 <nisse|hsk> do sud <- readFile file
08:16:59 <nisse|hsk> let rs = lines sud
08:16:59 <nisse|hsk> let sudoku = stringToSudoku rs
08:16:59 <nisse|hsk> checkReadSud sudoku
08:16:59 <nisse|hsk> return sudoku
08:17:57 <roconnor> looks good
08:18:11 <roconnor> are you sure isSudoku works?
08:18:18 <nisse|hsk> yeah i've checked it
08:18:27 <roconnor> hmmm
08:18:37 <nisse|hsk> works fine if i feed it with data that's not loaded from file
08:19:24 <roconnor> what happens when you replace (isSudoku sud) with False
08:20:03 <nisse|hsk> nothing
08:20:08 <yip> anyone remember where the best darcs repository is for lemmih's SDL bindings?
08:20:11 <nisse|hsk> still dosn't give error
08:20:43 * roconnor is short on ideas
08:21:02 <nisse|hsk> damn
08:28:18 <nisse|hsk> nice. i think i'm on to the problem
08:28:54 <nisse|hsk> if i try checkReadSud with an example sudoku it gives me this:
08:28:54 <nisse|hsk> ERROR - Unresolved overloading
08:30:47 <nisse|hsk> the function that has the do in it expects a IO output
08:30:51 <nisse|hsk> so hmm
08:38:25 <deadbeef> http://bandcamp.tv/linux-demotivators/
08:38:26 <lambdabot> Title: This one time @ bandcamp.tv
08:49:09 <blsecres> is anyone successfully using the --user flag to ghc on Mac OS X?  I'm running 6.4.1 and it appears to ignore the contents of ${HOME}/.ghc/package.conf
08:49:16 <rindolf> <<< Stack space overflow: current size 8388608 bytes. >>>
08:52:21 <Lemmih> blsecres: GHC shouldn't need a flag to read the user package config file.
08:52:22 <shapr> @users
08:52:44 <lambdabot> Maximum users seen in #haskell: 241, currently: 218 (90.5%), active: 30 (13.8%)
08:53:13 <Lemmih> yip: darcs.haskell.org/~lemmih/hsSDL
08:53:26 <yip> Lemmih: thanks!
08:53:33 <yip> Lemmih: btw, how is hIDE coming along?
08:53:33 <blsecres> Lemmih: it doesn't appear to be picking it up and I can't figure out if or where it's attempting to be read from
08:54:03 <Lemmih> yip: I don't see myself hacking on hIDE anytime soon.
08:54:25 <Lemmih> blsecres: Run running ghc with -v.
08:54:56 <yip> Lemmih: :(
08:56:04 <blsecres> It's only reading the system package.conf unless I use the -package-conf flag
08:57:35 <shapr> lambdabot: @hello
08:57:37 <lambdabot> Maybe you meant: help hylo tell
08:59:38 <nisse|hsk> omfg this is driving me crazy!!
09:00:57 <blsecres> ghc seems no be ignoring the GHC_PACKAGE_PATH environment variable as well
09:04:10 <Lemmih> blsecres: Weird. My ghc-6.4.1 reads my local config file just fine.
09:04:48 <Lemmih> blsecres: Where exactly is your local package config located?
09:04:49 <blsecres> Lemmih: did you build your ghc or are you running the binary download?
09:05:05 <blsecres> Lemmih: ${HOME}/.ghc/package.conf
09:05:13 <Lemmih> That's wrong.
09:05:44 <Lemmih> It should be ~/.ghc/i386-linux-6.4.1/package.conf
09:05:57 <Lemmih> Or well: $HOME/.ghc/arch-os-version/package.conf
09:12:11 <Lemmih> Igloo: Any news on GHC-6.6?
09:12:51 <Igloo> Not yet; I'll probably talk to the Simons about it tomorrow
09:13:11 <yip> Igloo: please release that baby soon!
09:13:11 <Lemmih> shapr: Did you discontinue the uploads?
09:13:42 <blsecres> Lemmih: thanks, I apparently misread the documentation.
09:14:06 <fasta> I don't mind it if you wait with the release.
09:14:56 <fasta> OTOH, having access to ghc-6.6 on other computers would be nice too... but sysadmins are almost always slow with the upgrade.
09:19:39 <fasta> Can I do import Data.Map (foo);import qualified Data.Map (bar)?
09:20:14 <Lemmih> Yes.
09:20:32 <nisse|hsk> roconnor: omg one iq point to me.... i typed the wrong command this whole time
09:20:39 <nisse|hsk> that's why it didn't work
09:21:00 <nisse|hsk> i typed "readFile file.ext" instead of readSudoku ^^
09:21:53 <xerox> (nisse|hsk: one good advice is to keep the pure computational parts from the I/O ones.)
09:21:54 <fasta> Hmm, that makes the module system a lot more useful.
09:22:06 <nisse|hsk> lol
09:22:16 <nisse|hsk> well i know that now xerox :)
09:22:25 <nisse|hsk> learn by doing :)
09:22:38 <xerox> Have fun :)
09:23:26 <defcon8> xerox, what is a coot?
09:23:40 <fasta> @dict coot
09:23:41 <lambdabot> Supported dictionary-lookup commands:
09:23:42 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
09:23:42 <lambdabot> Use "dict-help [cmd...]" for more.
09:24:00 <fasta> @all-dicts coot
09:24:02 <lambdabot> *** "Coot" gcide "The Collaborative International Dictionary of English v.0.48"
09:24:02 <lambdabot> Coot \Coot\ (k[=oo]t), n. [Cf. D. koet, W. cwtair; cwta short,
09:24:02 <lambdabot>   bodtailed + iar hen; cf. cwtau to dock. Cf. {Cut}.]
09:24:02 <lambdabot>   1. (Zool.)
09:24:02 <lambdabot>    (a) A wading bird with lobate toes, of the genus {Fulica}.
09:24:04 <lambdabot> [13 @more lines]
09:24:10 <fasta> @more
09:24:11 <lambdabot>      The common European or bald coot is {Fulica atra} (see
09:24:11 <lambdabot>      under {bald}); the American is {Fulica Americana}.
09:24:12 <lambdabot>    (b) The surf duck or scoter. In the United States all the
09:24:14 <lambdabot>      species of ({[OE]demia} are called coots. See
09:24:16 <lambdabot>      {Scoter}. "As simple as a coot." --Halliwell.
09:24:18 <lambdabot> [8 @more lines]
09:24:27 <xerox> @google "I wish I were a coot"
09:24:32 <lambdabot> http://www.jwz.org/gruntle/nscpdorm.html
09:24:33 <lambdabot> Title: nscp dorm
09:24:35 <xerox> (It's a citation.)
09:24:50 <xerox> (Nice to read if you don't know the story.)
09:25:11 <fasta> Heh, that word is pronounced the same in Dutch
09:32:55 <fasta> Does any of you understand what http://sigfpe.blogspot.com/ is exactly about?
09:32:58 <lambdabot> Title: A Neighborhood of Infinity
09:33:22 <fasta> I have not looked very serious at it, though.
09:45:34 <emk> Is it possible to write something like "deriving (Eq, Pretty)"?
09:45:58 <emk> ...or otherwise get some simple types to be pretty-printable without a lot of code?
09:46:15 <Cale> emk: Show?
09:46:37 <emk> I'm trying to look at some deeply nested trees, which are pretty ugly with Show...
09:46:43 <Cale> that's not quite the same as Pretty, but it's the closest thing which is derivable
09:46:45 <wilx> DrIFT?
09:51:57 <twanvl> You could also convert your data to a Data.Tree, and use drawTree
09:52:42 <emk> DrIFT looks like it does what I need, but it's pretty heavyweight. Thanks for the pointer.
10:00:28 <SamB> emk: yeah
10:00:43 <SamB> I tried to do something in DrIFT once, but it was a PITA
10:00:46 <emk> Are there good docs for Text.PrettyPrint.HughesPJ, or should I just go read the paper?
10:01:02 <fasta> Anything standard for the following? myLiftM4LookAlike f a1 a2 a3 a4 = do _1<-a1 _2<-a2 _3<-a3 _4<-a4 f _1 _2 _3 _4
10:01:06 <SamB> having to write your own pretty-printing code is no fun
10:01:17 <emk> SamB: If I
10:01:32 <emk> 'm going to write it, I should at least make it look like the language I'm parsing.
10:01:34 <fasta> emk: I used it without the paper
10:01:36 <Lemmih> fasta: liftMn
10:01:48 <SamB> emk: huh?
10:01:50 <fasta> Lemmih: nah, that does something else
10:02:10 <SamB> fasta: you left out all the semis
10:02:25 <fasta> SamB: well, I copied it from Emacs to irssi
10:02:29 <fasta> SamB: sorry
10:02:44 <SamB> fasta: huh
10:02:55 <emk> SamB: If I can't get a quick&dirty pretty-printing using 'deriving Pretty', then I'm going to write a really nice pretty-printer that dumps my trees using a lot of syntax...
10:03:09 <Lemmih> fasta: liftM4 + join?
10:03:20 <fasta> @type join
10:03:25 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
10:03:32 <fasta> Lemmih: right
10:03:37 <fasta> Lemmih: thank you
10:03:50 <SamB> emk: oh, yeah, well, I'd much rather have a printer for Haskell already done, and just have to generate the ASTs
10:04:20 <SamB> or at least some utility functions
10:04:37 <fasta> Hmm, or not
10:04:40 <SamB> and I don't think any of those libraries can take advantage of the layout rule, either!
10:05:18 <emk> SamB: Well, I'm pretty-printing the AST for a toy language, so anything reasonable will work.
10:05:35 <fasta> It works
10:05:45 <SamB> emk: I'm still ranting about how I don't like DrIFT ;-)
10:06:11 <fasta> emk: Lisp has those things built-in, I wish we had those in Haskell too.
10:06:24 <fasta> Well, implementing them is pretty trivial, I'd say.
10:06:26 <SamB> because I don't like what you have to do to implement a new "deriving" in DrIFT
10:06:48 <metaperl> This reminds me of this years ICFP contest problem -- only look at how useful it is: http://programming.reddit.com/info/k9dx/comments
10:06:50 <lambdabot> Title: Compiling complex ASCII tables to HTML tables (reddit.com), http://tinyurl.com/feclh
10:07:17 <SamB> metaperl: is that related to 2d?
10:07:25 <SamB> in your thinking?
10:07:27 <hyrax42> will it every be possible to add "deriving" classes ourselves?
10:07:37 <SamB> hyrax42: who knows?
10:07:56 <hyrax42> there's loads of work in the generics stuff... I guess it's all still too experimental
10:08:14 <SamB> well, I mean, I think you can if you run it through a custom patched version of DrIFT first...
10:08:22 <SamB> but that doesn't quite count
10:08:34 <hyrax42> yeah, I meant without any preprocessors
10:08:42 <hyrax42> and using the same syntax
10:08:50 <hyrax42> deriving (Eq, Show, MySillyClass)
10:09:08 <SamB> well, I think it might use the same syntax, but it is a preprocessor...
10:09:22 <hyrax42> oh I didn't realise that
10:09:27 <SamB> it wouldn't be hard to add deriving-via-TH, but it would be very hard to port...
10:09:47 <hyrax42> TH strictly GHC only for forseeable future?
10:10:02 <kosmikus> yes
10:10:15 <SamB> well, I'm not very good at seeing the future, so I will say "yes" also ;-)
10:11:00 <hyrax42> k
10:11:43 <russo_> hey guys is there a way to test if a constructor is of a certain datatype? I keep getting ERROR - Cannot Infer instance
10:12:29 <russo_> i.e. can i test if y is an interger in a boolean statement for example?
10:12:36 <russo_> or something like that
10:12:56 <kosmikus> ?
10:13:33 <russo_> because i'm working with custom datatype and there maybe multiple types for a given variable and i was curious if i could get haskell to check the type of the varriable in an if statement
10:14:02 <SamB> russo_: Data.Typeable might be helpful
10:14:22 <russo_> SamB: what doees that do?
10:14:33 <kosmikus> ah, you want run-time type tests. are you sure you need this?
10:14:39 <SamB> @type Data.Typeable.typeOf
10:14:40 <lambdabot> forall a. (Typeable a) => a -> TypeRep
10:14:52 <SamB> > typeOf "Hello!"
10:14:56 <lambdabot>  [Char]
10:15:33 <SamB> russo_: but, is there more to the error?
10:15:45 <russo_> no i know but its because i wrote it wrong
10:15:48 <russo_> hmm let me try that
10:16:19 <SamB> honestly, I think you'll need more than that to get anywhere with what you want to do...
10:16:28 <SamB> (or less)
10:16:30 <russo_> hmm
10:16:59 <russo_> see i just have a datatype that can take variables or intergers
10:17:12 <SamB> mmm
10:17:12 <russo_> so i need to check if its an interger or a variable
10:17:23 <SamB> why don't you just use an ADT?
10:17:29 <SamB> with two constructors?
10:17:31 <russo_> variables are also constructors like X Y Z
10:17:38 <SamB> that is:
10:17:59 <SamB> data Thing = Var Var | Int Integer
10:18:11 <SamB> and then case over that?
10:18:30 <russo_> thats what i have now so i just want to check if thing is a Var or an Int
10:18:36 <SamB> ah
10:18:36 <Cale> case
10:18:39 <SamB> yes
10:18:45 <Cale> case myThing of
10:18:52 <Cale>    Var v -> ... v ...
10:19:00 <Cale>    Int k -> ... k ...
10:19:37 <russo_> case myThing.typof?
10:19:42 <russo_> typeof*
10:19:51 <russo_> like that?
10:20:03 <Cale> huh?
10:20:15 <SamB> russo_: no, forget about Data.Typeable
10:20:18 <Cale> no, you pattern match on the constructors
10:20:19 <SamB> you don't need it
10:20:31 <SamB> that is for much, much more complicated programs than yours ;-)
10:20:41 <SamB> also it won't tell you which constructor you have
10:21:13 <russo_> hmm
10:21:23 <russo_> so wait i'm still lost what would the syntax of case be then?
10:21:37 <russo_> case myThing of? or what?
10:21:41 <kosmikus> what Cale said
10:21:46 <SamB> > case Just 1 of Just n -> concat (repeat n "hi!"); Nothing -> ""
10:21:47 <lambdabot>    The function `repeat' is applied to two arguments,
10:21:47 <lambdabot>   but its type `a -...
10:21:52 <SamB> erm
10:21:57 <SamB> > case Just 1 of Just n -> concat (replicate n "hi!"); Nothing -> ""
10:21:59 <lambdabot>  "hi!"
10:22:31 <Cale> Of course, in actual code, you lay that out like I gave above
10:23:01 <russo_> oh i just did a google search
10:23:03 <Cale> or you may write functions which pattern match their arguments, like:
10:23:06 <russo_> i think i understand now :)
10:23:11 <Cale> f Nothing = ""
10:23:24 <Cale> f (Just n) = concat (replicate n "hi!")
10:23:40 <Cale> So here, the type was Maybe Int
10:23:57 <Cale> and   data Maybe a = Nothing | Just a
10:24:44 <musasabi> I wonder why making efficient mutable datastructures with STM is so hard.
10:25:06 <musasabi> "TVar (Map k v)" seems to beat anything else.
10:25:23 <edwardk> musasabi: yeah =/
10:25:32 <edwardk> musasabi: tvars are slow
10:25:41 <yip> we need c++ stl ported to stm
10:25:48 <Cale> Well, that also has the issue that you can't have two separate threads mutating different parts of the map.
10:26:17 <Cale> So there's a tradeoff, I suppose
10:26:22 <musasabi> Cale: but with a realistic number of threads mutating the map takes much less time even with retrying transactions.
10:26:42 <Cale> Seems reasonable.
10:26:42 <edwardk> thats what i ran into with my hash stuff
10:27:43 <SamB> so what happens one one thread begins to add something to the map and then another one comes along?
10:27:54 <SamB> er, s/one one/when one/
10:28:16 <musasabi> I think it is because the STM implementation is not optimized for a large number of TVars.
10:28:22 <edwardk> samb: then STM kicks in, and when the other attempts to commit something where the state of the tvars it uses has been changed since it started, it fails
10:29:04 <edwardk> and goes back and retries
10:29:58 <SamB> so if you wrote something to the TVar before commiting would that make the other thread block earlier?
10:30:22 <SamB> or should I say instead of retrying?
10:31:32 <edwardk> you can't write to the tvar until the end of your transaction when you commit all of those changes go in
10:31:55 <edwardk> well, you can write to the tvar but the rest of the world doesn't see it until the end of your transaction
10:33:05 <SamB> would it be less efficient or more pathological if the rest of the world began to block trying to read that TVar until the transaction was committed?
10:33:31 <musasabi> SamB: it would introduce potential deadlocks.
10:33:38 <SamB> oh.
10:34:14 <musasabi> SamB: T1 has written V1. T2 has written V2. T1 wants to read V2 and is blocked. T2 wants to read V1 and is blocked.
10:34:43 <SamB> could it at least lower the priority of the thread temporarily?
10:35:26 <newsham> hmm.. reading the sel4-model.pdf paper that was just released..  "several small parts of the capability management code have to be implemented once for each kernel object type, even though their behavior is always the same."  ..
10:35:32 <edwardk> basically long stm transactions are doomed to failure. they compose but they will often never make forward progress in realistic situations and can be readily starved.
10:35:49 <newsham> anyone know why that is?  couldnt they have used a unifying type class or something to hide the different types?
10:35:55 <edwardk> so adding more tvars into the mix in your data structure makes it more and more likely that your transaction will fail
10:36:06 <edwardk> hence why i think the single tvar structures work best because
10:36:24 <edwardk> they can do all of their operations lazily and then make the one swift tvar change at the end of the transaction
10:36:45 <edwardk> the others have operations intermingled with the tvar swaps and MUCH longer actual transaction times as a result
10:37:44 <edwardk> at least thats my feel for the issue
10:38:19 <sjanssen> I wonder if a tree with a larger fan out would be more efficient
10:38:23 <SamB> hey, couldn't my idea work *if*, upon deadlock, a random transaction was restarted?
10:39:22 <edwardk> well right now they restart transactions when the conditions that led to them aborting changes, but that doesn't address the starvation conditions
10:39:45 <sjanssen> edwardk: a balanced binary tree shouldn't have to touch that many TVars, right?  O(log n) grows pretty slowly
10:40:17 <SamB> oh, wait, I just remembered that inserting something in a Map is lazy ;-)
10:40:21 <SamB> my idea is pointless
10:40:39 <sjanssen> Map insertions aren't actually lazy
10:40:46 <SamB> oh?
10:41:12 <russo_> ugh i keep getting mixed type could someone help me this is probably a really simple question if i have data A = B | C data D = E | F and data G = A | D then why can't i say that G=B
10:41:16 <edwardk> sjannsen: O(log n) is a lot bigger than 1 though =)
10:41:19 <musasabi> Map insertions are fast enough.
10:41:24 <sjanssen> SamB: data Map k a  = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
10:41:39 <SamB> sjanssen: oh?
10:41:42 <SamB> hrmm.
10:42:01 <musasabi> Map code runs 20x faster for insertions than the STM alternative (which can be made a little faster).
10:42:20 <edwardk> that about fits with my experience
10:42:32 <sjanssen> so as soon as your next insertion or lookup forces the top constructor, your entire map will be evaluated
10:42:44 <SamB> in that case, it seems a shame that, if two updates of the map were attempted at the same time, the second one would have to restart from the beginning only when the first one committed...
10:43:20 <ihope> reverse xs = reverse' xs []; reverse (x:xs) ys = reverse xs (x:ys); reverse [] ys = ys -- how fast is this?
10:43:55 <ihope> (And pretend everything except the first reverse says reverse'.)
10:43:59 <sjanssen> ihope: should be about as fast as it gets
10:44:07 <musasabi> But if the transactions are kept very small things can be made faster.
10:44:09 <zeeeee> hi all, how do i convert an Int to a Float?
10:44:18 <edwardk> sjanssen: it seems like its setting the tvar then running the tree, assigning the result to a tvar doesn't force right? its just when you go and inspect the tree that it goes and collapses your insertion
10:44:37 <SamB> zeeeee: fromIntegral
10:44:41 <edwardk> ihope: look into john hughes way do handle list reversals, andy gill used it during his code refactoring demo at the haskell workshop this year
10:44:45 <edwardk> er way to
10:44:51 <ihope> Certainly faster than reverse (x:xs) = reverse xs ++ [x] :-)
10:44:55 <newsham> > (fromIntegral (1 :: Int)) :: Float
10:44:57 <lambdabot>  1.0
10:45:02 <edwardk> using ++ apparently is faster if done right
10:45:05 <sjanssen> edwardk: right, the TVar will contain a thunk that will be evaluated the next time you look at the tree
10:45:25 <SamB> sjanssen: oh good ;-)
10:45:29 <edwardk> sjanssen: thats what i meant. swapping that single thunk is fast
10:45:46 <SamB> yes. it does not take long to build the thunk for inserting!
10:45:57 <musasabi> hmm. I can get to 3x difference if doing just one operation/transaction.
10:46:24 <sjanssen> musasabi: is this code online anywhere?
10:46:25 * SamB wonders how you profile STM
10:46:26 <edwardk_> see what i mean about lots of tvar changes being really really bad? =)
10:46:36 <musasabi> sjanssen: I can put it online.
10:46:52 <zeeeee> thanks SamB
10:47:04 <SamB> sjanssen: I never liked the idea of building datastructures out of TVars
10:47:19 <SamB> it seemed fraught with peril and potential inefficiency
10:47:27 <SamB> and confusion and such
10:47:49 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/stm-sl/
10:47:52 <lambdabot> Title: Index of /u/ekarttun/haskell/stm-sl, http://tinyurl.com/eo2fo
10:48:55 <sjanssen> anyway, I think writing a map-like data structure that supports concurrent updates efficiently is an open problem in general
10:49:02 <sjanssen> not just in STM and Haskell
10:49:12 <ihope> Is this any better than that above? reverse xs = reverse' xs []; reverse' (x:xs) ys = reverse' xs ((x:) $! ys); reverse' [] ys = ys
10:49:34 <lispy> with oohaskell you get duck typing for free....
10:49:47 <edwardk_> lemme see if i can find the really fast one
10:50:03 <sjanssen> ihope: reverse' (x:xs) ys = reverse' xs $! x:ys; is probably better than that
10:50:35 <ihope> Does seqing (x:ys) really do anything?
10:50:42 <SimonRC> sjanssen: I believe that type of structure is called a "database table". ;-)
10:51:01 <musasabi> that code could benefit from a faster rlevel.
10:51:05 <SimonRC> ihope: IIRC seq only goes far enough to determine the constuctor being used
10:51:25 <SimonRC> you might want deepSeq, maybe
10:51:37 <ihope> Yeah, I know what those do.
10:51:47 <sjanssen> SimonRC: ihope definitely doesn't want deepSeq in this case
10:52:26 <sjanssen> maybe the $! I proposed is redundant.  I don't know where ghc will leave that cons application as a thunk or not
10:52:32 <sjanssen> s/where/whether
10:53:06 <sjanssen> SimonRC: your database comment is a good point, perhaps I should learn what databases do
10:53:18 <SamB> what about file-sharing networks?
10:53:32 <SamB> granted, they don't guarentee reliability or anything nice like that
10:54:52 <edwardk_> http://www.brics.dk/RS/01/39/BRICS-RS-01-39.pdf  mentions the hughes list thing but it does so in ML
10:54:54 <lambdabot> http://tinyurl.com/nwwm2
10:58:02 <ihope> So could we have some infixa or something, where something like "infixa 4 ***" says that "x *** y *** z" means "(x *** y) && (y *** z)"?
10:58:48 <ihope> We could have all the relations be infixa, so we could compare three things for equality using "x == y == z" or see if one thing is between two other things using "x < y < z".
10:59:19 <lispy> ihope: i wonder if you could do it with template haskell
10:59:37 <fasta> Problems like this makes me like Scheme. If Haskell was only built on top of Scheme....
11:00:23 <fasta> ihope: You can use lists + a fold  for that problem now
11:00:50 <ihope> Built on top of Scheme?
11:00:59 <fasta> Generally, the syntax is not _that_ important anymore to me.
11:01:32 <fasta> ihope: yes, you can extend Scheme to infinity in a sane way.
11:01:48 <fasta> ihope: the same with Smalltalk, btw.
11:02:01 <ihope> Well, Scheme has, um, whatchamacallits.
11:02:02 <lispy> same with haskell really :)
11:02:15 <lispy> have you seen some of the extensions like hlist and oohaskel?
11:02:18 <ihope> So does, say, Python.
11:02:22 <lispy> pretty crazy the extensions
11:02:35 <fasta> lispy: I don't think it's the same.
11:02:54 <lispy> fasta: have you read looked at them?
11:02:59 <lispy> if not, don't be so sure :)
11:03:03 <lispy> plus there is template haskell
11:03:11 <sjanssen> ihope: you might be able to do that with some typeclass hacking
11:03:33 <lispy> program i'm writing at work reads in Tests.hs and uses template haskell to generate a unit test frame work from a bunch of test cases
11:04:01 <lispy> fasta: the haskell type system plus a few common extensions is turing complete
11:04:06 <fasta> lispy: Python: no, hlists and oohaskell a bit.
11:04:08 <fasta> lispy: I know
11:04:08 <lispy> fasta: which means you can do crazy stuff
11:04:17 <fasta> lispy: like C++...
11:04:47 <ihope> Turing-complete type system?
11:04:50 <ihope> Oog.
11:04:56 <SamB> fasta: except that you don't have to write type signatures for everything and its brother in Haskell
11:05:27 <ihope> Oh, right. CPS reverse, is it?
11:05:34 <fasta> SamB: if you are doing higher-ranked types you still need to do that.
11:05:42 <SamB> fasta: true
11:05:52 <fasta> SamB: there's no free lunch :)
11:06:05 <SamB> you mean, there aren't free higher-ranked types
11:06:18 <fasta> Ok
11:06:38 <ihope> reverse xs = reverse' xs id; reverse' (x:xs) f = reverse' xs ((x:) . f); reverse' [] f = f []
11:06:48 <ihope> What's that do for a person?
11:07:47 <ihope> Oh, say...
11:08:07 <ihope> @type let reverse xs = reverse' xs id; reverse' (x:xs) f = reverse' xs (f . (x:)); reverse' [] f = f [] in reverse
11:08:09 <lambdabot> forall a. [a] -> [a]
11:08:19 <ihope> > let reverse xs = reverse' xs id; reverse' (x:xs) f = reverse' xs (f . (x:)); reverse' [] f = f [] in reverse [1,2,3]
11:08:20 <lambdabot>  [1,2,3]
11:08:25 <ihope> Quite the reversal.
11:08:29 <ihope> > let reverse xs = reverse' xs id; reverse' (x:xs) f = reverse' xs (f . (x:)); reverse' [] f = f [] in reverse [1..]
11:08:33 <lambdabot> Terminated
11:08:46 <ihope> Hmm, a list length check thingy.
11:10:08 <ihope> > let reverse xs = reverse' xs id; reverse' (x:xs) f = reverse' xs ((x:) . f . (x:)); reverse' [] f = f [] in reverse [1,2,3]
11:10:09 <lambdabot>  [3,2,1,1,2,3]
11:10:13 <ihope> Score!
11:10:39 <edwardk_> more of a palindrome than a reverse no? =)
11:11:23 <ihope> Aye.
11:11:59 <lispy> ?let palindrome = \xs -> reverse' xs id; reverse' (x:xs) f = reverse' xs ((x:) . f . (x:)); reverse' [] f = f []
11:12:01 <lambdabot> Defined.
11:12:12 <lispy> > L.paindrome [1..3]
11:12:13 <lambdabot>  Not in scope: `L.paindrome'
11:12:18 <lispy> > L.palindrome [1..3]
11:12:20 <lambdabot>  [3,2,1,1,2,3]
11:12:36 <lisppaste2> zeeeee pasted "I can't grok type errors!" at http://paste.lisp.org/display/27156
11:12:51 <lispy> ?scheck \xs -> L.palindrome xs == (reverse xs) ++ xs
11:12:52 <lambdabot>  Add a type signature
11:12:56 <ihope> @type let reverse foo bar xs = reverse' foo bar xs id; reverse' foo bar (x:xs) f = reverse' foo bar xs (foo x . f . bar x); reverse' _ _ [] f = f [] in reverse
11:12:57 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> (a -> [a1] -> [a1]) -> [a] -> [a1]
11:12:59 <lispy> ?scheck \xs -> L.palindrome xs == (reverse xs) ++ (xs::[Int])
11:13:01 <newsham> ?check \x -> let p = palindrom (x :: [Char]) in p == reverse p
11:13:04 <lambdabot>  Completed 623530 test(s) without failure.
11:13:05 <lambdabot>  Not in scope: `palindrom'
11:13:17 <zeeeee> can anyone help me out with the error i pasted?
11:13:43 <newsham> ?check \x -> let p = palindrome (x :: [Char]) in p == reverse p
11:13:43 <lambdabot>  Not in scope: `palindrome'
11:13:52 <lispy> newsham: L.palindrome
11:13:54 <newsham> ?check \x -> let p = L.palindrome (x :: [Char]) in p == reverse p
11:13:56 <lambdabot>  OK, passed 500 tests.
11:14:27 <newsham> how long do definitions stay registereD?
11:14:33 <ihope> composite_strategy (\x -> x * x) - fromInt 5 5 1000
11:15:00 <astrolabe> @type fromIntegral
11:15:02 <lambdabot> forall b a. (Num b, Integral a) => a -> b
11:15:04 <kpreid> zeeeee: you're running into binary -
11:15:11 <kpreid> zeeeee: (-5)
11:15:21 <ihope> Hmm, yeah.
11:16:10 <kpreid> zeeeee: that type error means you're using a function type where a number (instance of Num) is expected
11:17:16 <astrolabe> and fromIntegral n is a Num, which you can't divide by (I think)
11:17:47 <lispy> > 1 / fromIntegral 2
11:17:49 <lambdabot>  0.5
11:17:59 <lispy> ?type fromIntegral
11:18:00 <astrolabe> eh how did you do that?
11:18:02 <lambdabot> forall b a. (Num b, Integral a) => a -> b
11:18:23 <lispy> ?type (/)
11:18:24 <lambdabot> forall a. (Fractional a) => a -> a -> a
11:18:47 <lispy> i never really thought about it before, but it does seem odd that it works
11:19:25 <newsham> > 1 / 2.0
11:19:26 <lambdabot>  0.5
11:19:39 <newsham> > (fromIntegral 2) :: Float
11:19:41 <ihope> fromIntegral n can act as any number type.
11:19:41 <lambdabot>  2.0
11:19:52 <fasta> Ok, there's one feature I would really like to have: being able to get the type of a function that's not at the top-level.
11:20:00 <ihope> A Fractional is a Num too, right?
11:20:11 <ihope> fasta: like what?
11:20:16 <newsham> fasta: yah...
11:20:32 <newsham> ihope:   let myfunc x = x + 2 in myfunc 3  <- sometimes you wanna know :t myfunc
11:20:41 <fasta> ihope: f a = f' where f' = 3
11:21:06 * ihope nods
11:21:09 <fasta> Otherwise you need to refactor all your code to raise them to the top level.
11:21:11 <ihope> Well, those can change, you know.
11:21:20 <ihope> id x = y where y = x
11:21:22 <astrolabe> @type (\x -> 1/fromIntegral x)
11:21:23 <lambdabot> forall b a. (Fractional b, Integral a) => a -> b
11:21:24 <zeeeee> well if i leave out the fromIntegral i get a different error
11:21:24 <fasta> "those"?
11:21:25 <ihope> What type does y have?
11:21:31 <kpreid> hmmm
11:21:40 <ihope> fasta: the types of those things.
11:21:50 <ihope> zeeeee: don't leave out the fromIntegral.
11:21:53 <astrolabe> zeeee: sorry, please ignore me
11:22:10 <astrolabe> my head hurts
11:22:15 <kpreid> ?type let myfunc x dummy = x + 2 `asTypeOf` dummy in myfunc 3
11:22:17 <lambdabot> forall a. (Num a) => a -> a
11:22:42 <ihope> ?type let myfunc x dummy = x + 2 `asTypeOf` dummy in myfunc
11:22:43 <lambdabot> forall a. (Num a) => a -> a -> a
11:23:14 <kpreid> I think something like that will work
11:23:57 <zeeeee> kpreid: i can't figure out where this function type is coming from...b is not a function
11:24:08 <kpreid> er
11:24:19 <kpreid> ?type \dummy -> let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3
11:24:21 <lambdabot> forall a. (Num a) => a -> a
11:24:24 <kpreid> *that's* what I meant
11:24:42 <kpreid> it has the type <extracted type> -> <original expression type>
11:25:03 <kpreid> where the extracted type is the type of whatever you tag with "`asTypeOf` dummy"
11:25:06 <ihope> zeeeee: the problem is 'composite_strategy (\x -> x*x) -5 5 1000'
11:25:23 <ihope> What you want is 'composite_strategy (\x -> x*x) (-5) 5 1000'.
11:25:46 <kpreid> ?type let _ = let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3 in dummy
11:25:48 <lambdabot> Not in scope: `dummy'
11:25:48 <lambdabot>  
11:25:48 <lambdabot> <interactive>:1:61: Not in scope: `dummy'
11:25:52 <ihope> Otherwise it'll think you mean '(composite_strategy (\x -> x*x)) - (5 5 1000)'.
11:26:01 <kpreid> ?type let dummy = undefined; _ = let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3 in dummy
11:26:02 <lambdabot> forall a. a
11:26:33 <zeeeee> ihope: ahh, i see, thanks
11:26:39 <lispy> how is that different from
11:26:45 <lispy> ?type let dummy = undefined in dummy
11:26:47 <lambdabot> forall a. a
11:26:56 <kpreid> lispy: it isn't, unfortunately
11:27:14 <zeeeee> what's wrong with my explicit type for this function?
11:27:17 <kpreid> ?type \dummy -> let let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3 in ()
11:27:19 <lambdabot> parse error on input `in'
11:27:36 <kpreid> ?type \dummy -> let {let {myfunc x = x + 2 `asTypeOf`} dummy in myfunc 3} in ()
11:27:38 <lambdabot> parse error on input `}'
11:27:40 <zeeeee> does the message mean i need an Enum?
11:27:40 <ihope> zeeeee: what error are you getting now?
11:27:57 <ihope> Oh.
11:28:00 <zeeeee> ihope: well, it's the one i pasted before
11:28:03 <ihope> What type does it infer?
11:28:13 <kpreid> ?type \dummy -> const () $ let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3
11:28:15 <lambdabot> forall a. (Num a) => a -> ()
11:28:25 <kpreid> there we go. only -> () as extra
11:28:32 <lispy> ah, right
11:28:38 <zeeeee> ihope: composite_strategy :: (Enum a, Integral b, Fractional a) => (a -> a) -> a -> a -> b -> a
11:28:42 <kpreid> fasta: gimme another example!
11:29:06 <lispy> ?instances Fractional
11:29:07 <lambdabot> Double, Float
11:29:10 <lispy> ?instances Enum
11:29:11 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
11:29:13 <ihope> Well, the problem is that [x..y] doesn't work unless x and y are the same instance of Enum.
11:30:06 <fasta> kpreid: hmm, that's a nice trick. Not that I completely see how it works.
11:30:36 <kpreid> fasta: I make a function argument which is required to be the same type as the internal expression
11:30:43 <lispy> asTypeOf is cheating in someways i guess...it's for dynamic typing? is that right?
11:31:11 <kpreid> ?type (\dummy -> const dummy $ let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3) undefined
11:31:13 <lambdabot> forall a. (Num a) => a
11:31:17 <kpreid> perfect!
11:31:40 <kpreid> ?type ($ undefined) $ \dummy -> const dummy $ let myfunc x = x + 2 `asTypeOf` dummy in myfunc 3
11:31:43 <lambdabot> forall a. (Num a) => a
11:31:51 <kpreid> ?pl ($ undefined) $ \dummy -> const dummy
11:31:52 <zeeeee> ihope: thanks for the explanations
11:31:52 <lambdabot> const undefined
11:31:54 <integral> @type asTypeOf
11:31:55 <lambdabot> forall a. a -> a -> a
11:32:17 <lispy> > 1 `asTypeOf` 'a'
11:32:18 <lambdabot>  add an instance declaration for (Num Char)
11:32:32 <lispy> ?type 1 `asTypeOf` 'a'
11:32:35 <lambdabot>   No instance for (Num Char)
11:32:35 <lambdabot>    arising from the literal `1' at <interactive>:1:0
11:32:42 <kpreid> lispy: `asTypeOf` is just const with an extra-restrictive type
11:33:21 <fasta> asTypeOf::a->a->a;asTypeOf = const ?
11:33:25 <lispy> ?type const
11:33:27 <lambdabot> forall a b. a -> b -> a
11:33:32 <kpreid> fasta: yes
11:33:43 <fasta> kpreid: and that solved the problem I had?
11:34:00 <shapr> I haven't seen any new traffic on haskell-cafe in days... does that mean gmane.org isn't getting mail from haskell.org?
11:34:02 <kpreid> no, a complex gimmick involving it did :)
11:34:21 <kpreid> fasta: could you provide another example of an expression to extract a type from the middle of?
11:34:27 <lispy> shapr: yes
11:34:35 <lispy> shapr: i've seen things as recently as 8am
11:34:40 <shapr> foo
11:34:58 <shapr> fasta: Also, sigfpe is just applying Haskell to spiffy math stuff.
11:35:28 <xerox> shapr: his post are awesome.
11:35:47 <fasta> shapr: ok, I found it amazing that he came up with all that stuff, but apparently he only applies it.
11:36:02 <fasta> Not that that is a simple thing.
11:36:05 <SimonRC> Since Hoogle wasn't helpful to me ... is there a function that takes in a list of items and outputs an alist saying how many of each item there is?
11:36:29 <SimonRC> something like: (Eq a) => [a] -> [(Int, a)]
11:36:34 <lispy> ?hoogle [a] -> [(Int, a)]
11:36:35 <xerox> > map (head &&& length) . group . length $ [1,3,5,2,3,1,4,5,2,2,3,4,5]
11:36:36 <lambdabot> No matches, try a more general search
11:36:36 <lambdabot>  Couldn't match `[a]' against `Int'
11:36:43 <xerox> > map (head &&& length) . group . sort $ [1,3,5,2,3,1,4,5,2,2,3,4,5]
11:36:46 <lambdabot>  [(1,2),(2,3),(3,3),(4,2),(5,3)]
11:36:47 <xerox> Sorry.
11:36:49 <fasta> kpreid: no, maybe later
11:37:32 <SimonRC> xerox: yuk, but it works
11:37:39 <xerox> It's nice :)
11:37:54 <lispy> yeah, the arrows make it even simpler :)
11:37:56 <SimonRC> It would be about 5 characters in J
11:38:01 <SamB> SimonRC: I think you have the Int and the a reversed
11:38:12 <xerox> hehe
11:38:23 <SimonRC> OST, there is probably already a J operator to do it, so 2 chars
11:38:27 <lispy> > map (\xs -> (head xs, length xs)) . group . sort $ [1,3,5,2,3,1,4,5,2,2,3,4,5]
11:38:28 <lambdabot>  [(1,2),(2,3),(3,3),(4,2),(5,3)]
11:38:33 <xerox> > map (head &&& length) . group . sort $ "the quick fox jumps over the lazy dog"
11:38:35 <lambdabot>  [(' ',7),('a',1),('c',1),('d',1),('e',3),('f',1),('g',1),('h',2),('i',1),('j...
11:38:40 <SimonRC> yep
11:39:08 <SimonRC> &&& is so handy
11:39:28 <kpreid> > M.toAscList $ M.fromListWith (+) (zip [1,3,5,2,3,1,4,5,2,2,3,4,5] (cycle 1))
11:39:29 <lambdabot>  add an instance declaration for (Num [a])
11:39:31 <lispy> ?pl \xs -> (head xs, length xs)
11:39:32 <lambdabot> liftM2 (,) head length
11:39:47 <kpreid> > M.toAscList $ M.fromListWith (+) (zip [1,3,5,2,3,1,4,5,2,2,3,4,5] (repeat 1))
11:39:49 <lambdabot>  [(1,2),(2,3),(3,3),(4,2),(5,3)]
11:39:54 <xerox> (***) is too!
11:39:56 <kpreid> SimonRC: how's that?
11:40:43 <xerox> hehe
11:42:03 <kpreid> also, I'm disappointed there's no M.unfold
11:42:31 <shapr> Fix it!
11:42:32 <SimonRC> kpreid: in a special case:    f &&& g = \x -> (f x, g x)
11:42:56 <xerox> (a.k.a. the (->) arrow.)
11:43:05 <kpreid> SimonRC: sorry, I meant, I have another solution
11:49:51 <lispy> geez...i had to build tetex to get darcs to build, which i need to get a library which i need to build a library i want to use...
11:50:09 <lispy> so many levels of indirection...and waiting
11:50:24 <lispy> of course, i need all these thngs like darcs and tetex anyway...but still why do i have to wait now :)
11:50:29 <russo_> hey guys if i'm using cases then how do i do a default case eg. if none of the cases before hand are fullfilled
11:50:47 <lispy> _ -> error "default case"
11:51:03 <Igloo> You don't need tetex just to build darcs
11:51:04 <lispy> remember that '_' as a pattern matches anything
11:51:26 <lispy> Igloo: i'm too lazy to re-run configure
11:51:33 <lispy> and i need tetex anyway...
11:51:43 <russo_> k thanks lisppaste2
11:51:52 <russo_> lispy: * :)
11:51:59 <weitzman> lisppaste2++
11:54:06 <newsham> cant you just do  "default -> error "default case" "?
11:54:38 <lispy> > let foo x = case x of default -> show "default" in foo 1
11:54:39 <lambdabot>  Parse error
11:54:47 <lispy> > let foo x = case x of _ -> show "default" in foo 1
11:54:49 <lambdabot>  "\"default\""
11:55:11 <lispy> guess i didn't need the show :)
11:56:01 <lispy> newsham: perhaps you're thinking of 'otherwise' in guards?
11:56:05 <lispy> ?type otherwise
11:56:07 <lambdabot> Bool
11:56:12 <lispy> > otherwise
11:56:14 <lambdabot>  True
11:56:38 <newsham> > let foo x = case x of d -> d in foo 1
11:56:40 <lambdabot>  1
11:56:51 <newsham> > let foo x = case x of d -> "default" in foo 1
11:56:52 <lambdabot>  "default"
11:56:59 <newsham> > let foo x = case x of default -> "default" in foo 1
11:56:59 <lambdabot>  Parse error
11:57:02 <weitzman> > case False of True -> 1
11:57:04 <lambdabot>  Non-exhaustive patterns in case
11:57:05 <newsham> > let foo x = case x of default_ -> "default" in foo 1
11:57:06 <lambdabot>  "default"
11:58:07 <newsham> ok, so most any word except "default"  :)
11:58:26 <lispy> default must be a reserved vord
11:59:00 <sjanssen> yes, default is a reserved word
11:59:24 <newsham> where's it used?
11:59:56 <sjanssen> newsham: it lets you change how numeric defaulting works
12:01:13 <sjanssen> it isn't used very often
12:02:45 <SamB> newsham: why don't you use _?
12:04:40 <newsham> just saying you could use a word (like "default", although not exactly like "default")
12:11:13 <edwardk_> newsham: yeah, but then the compiler has to do more work to figure out you really don't care about that variable. _ signals that intent to both the user and the compiler very cleanly
12:12:33 <explicitjelly> hi
12:12:37 * Lemmih would use _default or _other.
12:13:03 <explicitjelly> if i do something like sin (pi/n), then n can't be Int, right?
12:13:16 <xerox> ?type (/)
12:13:17 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:13:26 <xerox> ?type pi
12:13:27 <astrolabe> > sin(pi/(3::Int))
12:13:27 <lambdabot>  add an instance declaration for (Floating Int)
12:13:28 <explicitjelly> and i must use sin (pi / fromIntegral n), right?
12:13:28 <lambdabot> forall a. (Floating a) => a
12:13:40 <xerox> ?instances Floating
12:13:41 <lambdabot> Double, Float
12:13:48 <xerox> Yes.
12:14:06 <explicitjelly> this makes my code slightly more ugly...
12:14:07 <astrolabe> How's it going xerox?
12:14:12 <xerox> astrolabe: better.
12:14:22 <astrolabe> good
12:14:35 <explicitjelly> why isn't / defined such that Floating/Int is possible?
12:15:28 <xerox> astrolabe: ...and tomorrow I'll be enrolling(?) to the university!
12:15:38 <astrolabe> Well... you need to have a class definition for '/'
12:15:44 <zeeeee> hi all, is there a HOOD or Observe.lhs for ghc6?
12:15:46 <astrolabe> xerox: excellent :)
12:16:17 <xerox> explicitjelly: the problem is that the type is a -> a -> a, with a constraint on the type variable a.  I.e. the type of the arguments and the outcome are the same.
12:16:25 <astrolabe> zeeee: there is hat, but I haven't to it to work.
12:16:42 <astrolabe> on a decent sized program.
12:16:42 <zeeeee> astrolabe: ah, hat-observe...i'll look into it, thanks
12:16:58 <zeeeee> astrolabe: what do you mean? it works on small programs but fails for larger?
12:17:15 <explicitjelly> xerox, ah, ok
12:17:42 <astrolabe> zeeeee: I've only tried it on 2 big programs, and it failed, but I don't know why.
12:17:46 <xerox> explicitjelly: I think it's a feature, though.
12:17:54 <explicitjelly> xerox, yes, seems like.
12:17:59 <xerox> astrolabe: i'm quite happy :)
12:18:17 <explicitjelly> xerox, I suppose I could define a (Fractional a) => (Int b) => a -> b -> a myself?
12:18:24 <xerox> explicitjelly: sure.
12:18:39 <SimonRC> explicitjelly: but you could not call it (/)
12:18:52 <explicitjelly> xerox, well, I don't need it that often, so I'll pass, but good to know. thanks!
12:19:01 <xerox> ?type (. fromItegral) . (/)
12:19:03 <lambdabot> Not in scope: `fromItegral'
12:19:06 <xerox> Pffft.
12:19:11 <xerox> ?type (. fromIntegral) . (/)
12:19:13 <lambdabot> forall a b. (Integral a, Fractional b) => b -> a -> b
12:19:45 <explicitjelly> SimonRC, could not?
12:20:03 <xerox> Well, you _can_, hiding the one from the Prelude, but it's not someting you _want_ to do.
12:20:53 <explicitjelly> ah, so it would replace the one from the Prelude...
12:36:58 <matthew-_> any haskelldb admins around?
12:38:26 <lisppaste2> hn pasted "pattern match and print" at http://paste.lisp.org/display/27164
12:39:53 <glguy> hn you are using x and not defining it
12:40:18 <glguy> also, [[rows a]] probably doesn't do what you are expecting
12:40:18 <Lemmih> matthew-_: admins?
12:40:32 <matthew-_> Lemmih: err, maintainers.
12:40:56 <Lemmih> @seen bringert
12:40:57 <lambdabot> I saw bringert leaving #haskell.se and #haskell 1d 20h 28m 7s ago, and .
12:41:07 <matthew-_> devels, anyone who knows what I should do with a patch I've made to HDBC in HaskellDB
12:41:25 <lisppaste2> glguy annotated #27164 with "adjusted pattern match" at http://paste.lisp.org/display/27164#1
12:41:29 <lispy> has anyone cabalize HList or OOHaskell?
12:42:25 <xerox> shapr: I was *really* hoping for actual code in the last sigfpe's post.
12:43:01 <henke> did my pase get through? (I got disconnected when I pasted)
12:43:18 <glguy> henke: did you paste as hn?
12:43:23 <henke> yes
12:43:29 <glguy> http://paste.lisp.org/display/27164#1
12:43:33 <henke> oh, my name changed..
12:44:15 <glguy> henke: I would recommend using "maybe" to output a number or a '.' based on the Maybe Int
12:44:21 <glguy> ?type maybe
12:44:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:44:50 <glguy> > maybe '.' intToDigit (Just 1)
12:44:52 <lambdabot>  '1'
12:44:52 <henke> what is meant by '.'?
12:45:02 <glguy> > maybe '.' intToDigit Nothing
12:45:04 <lambdabot>  '.'
12:45:14 <glguy> it's the dot you mentioned on your post
12:45:23 <henke> aha!
12:45:58 <glguy> > [maybe '.' intToDigit a | r <- [[Just 1, Just 2],[Nothing, Just 3]] , a <- r]
12:45:59 <lambdabot>  "12.3"
12:46:19 <henke> so my patternmatch wasn't so gret heh :P
12:46:23 <lennart> xerox: enforcing the linearity in Haskell would be tricky
12:46:42 <xerox> lennart: that's right, what could we use instead?
12:46:51 <glguy> henke: the function "rows" is only used to return the [[Maybe Int]] from your data type
12:46:55 <glguy> not to pattern match
12:47:12 <lennart> xerox: if we had a linear type system, maybe
12:47:15 <henke> okey..
12:47:36 <xerox> lennart: is any working system with linear type available at the present?
12:48:08 <lennart> xerox: well, there's clean's uniqueness types
12:48:08 <Philippa_> one of the problems I always have with things like linear types and strictness annotations is they always seem all but orthogonal to types per se - I want to write "this type, and it's linear" of a value. And then I want a generic mechanism for such things...
12:48:13 <lennart> maybe that would do
12:48:48 <lisppaste2> zeeeee pasted "HAT build error" at http://paste.lisp.org/display/27166
12:48:48 <xerox> lennart: do you know anyone grokking Clean? Or maybe you do yourself? We could ask him to talk with sigfpe :)
12:48:54 <lennart> xerox: it would be cool to put sigfpe's idea into code
12:48:55 <Philippa_> I don't know how much edwardk's implemented, but he's got a nice-if-obvious theoretical result for a sort of substructural PTS
12:49:03 * xerox nods vigorously
12:49:25 <lennart> xerox: i can't say i grok clean's type system, no
12:50:03 <lennart> Philippa_: mmmm, substructural PTS, that's something I'd like
12:50:30 <Philippa_> lennart: apparently the "obvious" thing just works, and preserves all properties
12:50:41 <Philippa_> or at least, all lack-of-behaviour ones
12:50:49 <lennart> Philippa_: oh really, that's cool
12:51:08 <Philippa_> makes intuitive sense to me, apparently the logicians pretty much proved it for us a while back too
12:51:09 <lennart> maybe i need to write a new PTS implementation then
12:51:53 <shapr> I dare you to call a substructural type system obvious anywhere outside of #haskell.
12:51:57 <Philippa_> mmm. My current pet project that's going nowhere involves a System Fc implementation, I should see just how much can be retained translating a program in the CoC to it
12:52:24 <Philippa_> remind me how to add quotes to the bot? :-)
12:52:35 <xerox> '@remember nick important thing'
12:52:43 <newsham> anyone here use Isabelle/HOL?  (know of a chat channel for it?)
12:52:46 <Philippa_> @remember shapr I dare you to call a substructural type system obvious anywhere outside of #haskell.
12:53:01 <Philippa_> oh, is it ? rather than @ now?
12:53:03 <xerox> newsham: my cs professor, hehe
12:53:05 <Philippa_> ?remember shapr I dare you to call a substructural type system obvious anywhere outside of #haskell.
12:53:09 <xerox> It's okayt Philippa_
12:53:10 <lennart> Philippa_: I wonder how close you can get to Fc in CoC
12:53:15 <xerox> lambdabot simply doesn't answer
12:53:16 <shapr> @quote shapr
12:53:16 <lambdabot>  Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
12:53:22 * shapr grins
12:53:23 <newsham> i have some basic questions...
12:53:26 <shapr> I like that quote.
12:53:30 <ihope_> @quote ihope
12:53:30 <lambdabot>  Laziness is free, but it doesn't always pay off.
12:53:36 <shapr> newsham: Oh, I can answer those!
12:53:38 <shapr> ihope_: I like that quote!
12:53:45 <ihope_> I don't get it.
12:53:47 <lennart> Philippa_: I have a translation (kinda), but it needs strong sums, so it's not logically sound
12:54:26 <ihope_> @quote ihope
12:54:26 <lambdabot>  Oops, I forgot that Djinn doesn't do GADT's.
12:54:34 <lennart> heh
12:54:35 <Philippa_> yeah, it seems intuitively doable to me but I don't want to know how painful it is - and I'm not expecting separate compilation
12:54:47 <ihope_> @quote lambdabot
12:54:47 <lambdabot>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
12:55:19 <Philippa_> would any of the well-known (FCVO "well-known", shapr) extensions give you a sound translation?
12:55:28 <newsham> shapr:  i built isabelle from freebsd ports, when I run proofgeneral I get an xemacs window but it doesnt have the features advertised in the tutorial....
12:55:36 <lennart> Philippa_: Is the substructural PTS stuff written up?
12:55:48 <newsham> not being an emacs guru or having used isabelle before i'm at a loss.
12:56:41 <klutometis> @vixen my kingdom or a horse?
12:56:42 <lambdabot> yes
12:56:46 <Philippa_> lennart: ask edwardk
12:56:47 <klutometis> @vixen good
12:56:47 <lambdabot> good good
12:56:56 <lennart> Philippa_: I will
12:57:17 <Philippa_> he might be willing to post a sketch somewhere if you need something citable
12:57:25 <klutometis> @vixen Now is the winter of our discontent?
12:57:26 <lambdabot> nevermind about that
12:57:30 <klutometis> @vixen ok
12:57:31 <lambdabot> just ok?
12:57:36 <klutometis> @vixen no
12:57:37 <lambdabot> no?
12:57:55 <Adamant> @vixen dance, monkey!
12:57:55 <lambdabot> tell me more about yourself.
12:58:01 <lennart> ok, i'd better pack my computer.  we are landing soon
12:58:12 <xerox> lennart: you're on a plane?
12:58:13 <Philippa_> seeya
12:58:24 <lennart> yes
12:58:28 <xerox> Wow.
12:58:34 <xerox> Well, have fun :)
12:58:43 <lennart> Lufthansa has Internet on board.
12:58:47 <lennart> Wireless. :)
12:59:13 <lennart> For a fee, of course.
12:59:15 <norpan> hey, i'm on a train
12:59:28 <norpan> wireless acess is included in my first class ticket
12:59:34 <lennart> cool
12:59:36 <norpan> but on a plane is cooler
12:59:37 <xerox> ahahah
12:59:43 <xerox> #haskell is moving
12:59:44 <newsham> shapr: were you joking or can you help? :)
12:59:51 <Philippa_> I'll be paying more attention to stuff like that when ccooke drags my Zaurus back
13:00:16 <henke> glguy: I didn't understand: [maybe '.' intToDigit a
13:00:20 <ihope_> #haskell is moving?
13:00:44 <norpan> indeed
13:00:49 <henke> okey, so a should be all the values in my sudoku ie THE sudoku
13:01:02 <norpan> next stop skvde
13:02:26 <henke> but what about maybe '.' intToDigit a ?
13:03:03 <xerox> henke: do you understand what the function |maybe| does?
13:04:04 <SimonRC> @type maybe
13:04:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:04:17 <henke> nope
13:04:24 <xerox> henke: ok, look at its type
13:04:43 <henke> ok
13:04:44 <xerox> henke: you feed it a value of type b, and a function from a to b, then you feed it a value of type Maybe a.
13:05:00 <xerox> henke: if the value of type Maybe a is a Nothing, maybe returns its first argument
13:05:33 <xerox> henke: if the value of type Maybe a is a (Just x), maybe returns the value of the application of the function (its second argument) to the x
13:05:46 <ihope_> It replaces Nothing with its first argument, and Just with its second argument.
13:06:00 <xerox> In code: |maybe x _ Nothing = x| |maybe _ f (Just x) = f x|.
13:06:19 <ihope_> A lot like foldr, which replaces (:) with its first argument and [] with its second.
13:09:16 <glguy> henke: I'm back now, but it looks like you're in good hands (c:
13:09:51 <SimonRC> Idea: class (x :: * -> *) => MonadRun m x | m -> x where run :: m a -> x a -> m
13:10:22 <chessguy> > map (:) [1..10]
13:10:23 <lambdabot>  Add a type signature
13:10:28 <xerox> SimonRC: that's a type error
13:10:32 <SimonRC> run would be (similar to) foldr for [], maybe for Maybe, runST for ST
13:10:33 <henke> yeah, really, getting great help all the time =)
13:10:37 <chessguy> > map (:) 0 [1..10]
13:10:37 <lambdabot>    The function `map' is applied to three arguments,
13:10:37 <lambdabot>   but its type `(a -...
13:10:47 <chessguy> @type map
13:10:47 <SimonRC> xerox: indeed...
13:10:48 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
13:11:00 <SimonRC> Idea: class (x :: * -> *, Monad m) => MonadRun m x | m -> x where run :: m a -> x a -> m
13:11:01 <chessguy> > map (:) [] [1..10]
13:11:02 <lambdabot>    The function `map' is applied to three arguments,
13:11:02 <lambdabot>   but its type `(a -...
13:11:09 <glguy> chessguy: foldr
13:11:24 <xerox> SimonRC: that's again a type error.
13:11:24 <chessguy> oh, duh
13:11:25 <SimonRC> run would turn   m a into a
13:11:29 <SimonRC> xerox: oh
13:11:30 <SimonRC> hmm
13:11:31 <chessguy> > foldr (:) [] [1..10]
13:11:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:11:53 <SimonRC> I really need type-level lambdas
13:12:00 <glguy> > maybe Nothing Just (Just 1)
13:12:02 <lambdabot>  Just 1
13:12:06 <xerox> SimonRC: it's -> m that doesn't make sense
13:12:09 <glguy> > maybe Nothing Just Nothing
13:12:10 <lambdabot>  Add a type signature
13:12:21 <SimonRC> xerox: oh, yeah
13:12:22 <glguy> > maybe Nothing Just Nothing :: Maybe ()
13:12:24 <lambdabot>  Nothing
13:12:29 <SimonRC> Try: class (x :: * -> *, Monad m) => MonadRun m x | m -> x where run :: m a -> x a -> a
13:12:59 <xerox> SimonRC: since m is a Monad, its kind is * -> *, but x is not of kind *. Kind error now.
13:13:20 <xerox> SimonRC: eeek, nothing.
13:13:23 <xerox> Nevermind.
13:14:20 <chessguy> @type foldr
13:14:21 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
13:15:10 <araujo> morning!
13:15:20 <SimonRC> ATM, the way of "getting the value out" of a monad is monad-specific
13:15:32 <xerox> SimonRC: you might simply go for class (Monad m) => MonadNonOneWay m where reify :: m a -> a -- or something like that.
13:15:45 <xerox> SimonRC: yep, that's because there are one-way monads.
13:16:07 <Philippa_> and other monads where you can only sensibly get a concrete value out given some inputs
13:16:32 <SimonRC> xerox: nono, reify would need additional argument(s).
13:16:40 <xerox> SimonRC: why?
13:17:03 <SimonRC> For Maybe, you need to konw what to do with Nothing
13:17:13 <skew> runReader :: Reader r a -> r -> a, runState :: State s a -> s -> a -> (a,s), etc.
13:17:13 <SimonRC> for [], you need to know how to fold the list
13:17:48 <SimonRC> for state/reader/writer monads, you need to know what starting state to use
13:17:49 <SimonRC> etc
13:18:20 <xerox> Right.
13:18:25 <glguy> foldr is just something cool you can do with [a], it don't really have anything to do with [a] being a Monad... does it?
13:18:42 <SimonRC> glguy: not at the moment
13:19:00 <xerox> glguy: there's surely a foomorphism word for them, generalized to arbitrary bars and baz, believe me.
13:19:03 <Philippa_> give or take the r, fold is something you can do with any algebraic datatypes
13:19:04 <SimonRC> flodr is just the obvoius way of turning [a] into a
13:19:04 <Philippa_> -s
13:19:15 <Philippa_> xerox: catamorphism
13:19:19 <xerox> There you go.
13:19:23 <Philippa_> it's the absolute classic example
13:19:31 <glguy> xerox: sure, I just don't see it being related to [a] as a Monad, I'm not saying that there isn't a generalization
13:19:34 <SimonRC> I know that too
13:20:33 <Philippa_> I don't know if there's a "sensible" categorical description for a generalised fold-inna-monad
13:20:45 <xerox> ?hoogle foldM
13:20:46 <lambdabot> Monad.foldM :: Monad a => (b -> c -> a b) -> b -> [c] -> a b
13:20:46 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:20:46 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
13:21:17 <Philippa_> but folds-in-monads are a shockingly powerful model in general. Even when you stop writing interpreters and do something else :-)
13:21:51 <glguy> foldM uses lists as a container, not as a monad tho
13:22:07 <chessguy> is there a difference between map and fmap?
13:22:14 <xerox> ?wiki Monads_as_Containers
13:22:15 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
13:22:16 <xerox> hehe
13:22:27 <glguy> xerox: a sideeffect of monads also being functors
13:22:37 <chessguy> i don't think that's very clear
13:22:49 <xerox> chessguy: nope, except the latter's type being more general than the former's.
13:22:57 <glguy> the emphasis on foldM is on the monad that it's applied to, no tthe list that contains them
13:23:00 <xerox> (Is that an horrible usage of genitive?)
13:23:00 <Philippa_> chessguy: map is the fmap on lists
13:23:28 <chessguy> what is fmap on ?
13:23:30 <skew> an 'orrible?
13:23:32 <xerox> Functors.
13:23:37 <Philippa_> glguy: I'd say it's "in" a monad and applied "to" a list. YMMV.
13:23:48 <chessguy> ok, thanks
13:24:16 <glguy> the focus of foldM is "in" the Monad?
13:24:33 <glguy> I'm talking about the "focus" of the concept, not the computation itself
13:24:52 <skew> sequence has something more to do with lists as monads
13:24:57 <Philippa_> I'd say the focus is that it's a fold in a monad. If you want to focus on the difference from fold then sure...
13:25:20 <glguy> either way, it's a useful function :)
13:25:26 <Philippa_> skew: it does? Isn't sequence just folding >> across a list?
13:25:42 <glguy> sequence_ is
13:25:54 <xerox> ?index sequence
13:25:54 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:25:57 <xerox> ?source Control.Monad
13:25:58 <Philippa_> d'oh, of course
13:25:58 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
13:26:13 <xerox> sequence ms = foldr k (return []) ms
13:26:13 <xerox> 	    where
13:26:13 <xerox> 	      k m m' = do { x <- m; xs <- m'; return (x:xs) }
13:26:14 <skew> Philippa_: it's something like that, but the type is [m a] -> m [a], so it's transposing the monads
13:26:32 <Philippa_> skew: but it has nothing to do with the list monad specifically still
13:26:51 <Philippa_> and there's only one monad involved - I know what you mean by "transposing the monads" but the phrasing's misleading
13:26:52 <xerox> What has to do with the list monad specifically?
13:27:14 <xerox> (Besides concatMap?)
13:27:25 <glguy> return?
13:27:34 <xerox> Err..
13:27:58 <skew> well, a "proper" map m1 (m2 a) -> m2 (m1 a) lets you combine monads m1 and m2. I'm not sure if sequence works like that.
13:28:01 <glguy> List as a Monad refers to its non-determinism behavior
13:28:50 <glguy> List as a Functor refers to it being a container of values that you can apply some function to each of
13:28:55 <glguy> at least that how I understand it
13:29:08 <xerox> ?type \amb -> amb >>= \amb' -> return (amb' `asTypeOf` amb)
13:29:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
13:29:09 <lambdabot>    Expected type: a
13:29:12 <xerox> Boom.
13:29:54 <glguy> xerox: return amb' `asTypeOf` amb  ?
13:30:09 <glguy> since amb is a monad and amb' in the value inside?
13:30:11 <Philippa_> glguy: the return in foldM is for the monad, it's not list's return or it'd be a manual boxing
13:30:23 <glguy> right
13:31:01 <xerox> ?type \amb -> amb >>= \amb' -> amb' >>= \x -> return (return x `asTypeOf` amb') `asTypeOf` amb
13:31:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m (m a)
13:31:14 <xerox> Hmmm.
13:34:57 <sris> anyone coding haskell on mac here? :)
13:35:43 * earthy is
13:35:45 <earthy> why?
13:35:51 * glguy is
13:36:00 <sris> what editor do you use?
13:36:05 <earthy> vim
13:36:15 <glguy> vim
13:36:19 <xerox> Emacs.
13:36:30 <glguy> editor, no OS :-p
13:36:33 <glguy> not*
13:36:45 <earthy> glguy: vim is almost as bad as emacs in that regard
13:37:00 <glguy> I completely disagree, but we can leave it at that if you like
13:37:03 <sris> id like to use vim, i just havent learnt it ;)
13:37:29 <earthy> sris: just for your information, S. D. Swiestra uses BBEdit
13:37:34 <earthy> as does A. Dijkstra
13:37:45 <earthy> to edit their haskell code with
13:37:45 <sris> anyone used TextMate?
13:37:59 <earthy> should work just fine.
13:38:07 <earthy> dunno if it has a haskell syntax highlighter though
13:38:18 <glguy> I tried installing it and noticed that it didn't have built in haskell syntax highlighting
13:38:33 <xerox> Well, it has, in a separate bundle.
13:38:34 <glguy> so I kicked it to the curb! ;)
13:38:35 <xerox> But it sucks.
13:38:36 <roconnor> ugh, SamB's UM needs a little work
13:38:37 <glguy> ah, ok
13:38:51 <sris> i see, i just got my mac yesterday and investigating the opertunities
13:39:17 <glguy> My VM runs about as fast on my computer as edwardks... but only on my windows computer (wrote it in C#) on my mac with mono the performance is terrible
13:39:31 <glguy> (as edwardks did on my computer in cygwin)
13:39:34 <psi> sris: carbon emacs is capable, and huge.
13:39:47 * glguy has carbon emacs installed for SLIME
13:40:01 <roconnor> I guess thats why he wrote a C version
13:40:03 <psi> I think the installation exceeds 100 MB.
13:40:14 <xerox> That's true
13:40:25 <emk_> Yay! Parser combinators are cool. I just thought I'd share that.
13:40:28 <psi> But who cares, I guess.
13:40:38 <xerox> emk_: yeah!
13:40:46 <earthy> emk: deterministic parser combinators are even nicer. ;)
13:41:14 <earthy> http://www.cs.uu.nl/wiki/HUT/ParserCombinators
13:41:16 <emk_> I'm using Text.ParserCombinators.Parsec, which appears to be deterministic unless you ask it not to be...
13:41:18 <lambdabot> Title: HUT / Parser Combinators, http://tinyurl.com/hun72
13:41:35 <earthy> emk: true enough
13:41:49 <araujo> earthy, port beedit to Linux!
13:41:55 <araujo> bbedit*
13:42:06 <earthy> araujo: why would I do that? I grew up on vi...
13:42:12 <earthy> and love vim
13:42:15 <glguy> Does BBEdit support Haskell highlighting?
13:42:21 * araujo uses both vim/emacs
13:42:32 <earthy> glguy: it does
13:42:42 <glguy> cool, do you know how to turn it on?
13:42:49 <earthy> google for the right plist
13:43:23 <emk_> In particular, "args <- parens (commaSep expression)" is just plain elegant, compared to any other parser language I've seen.
13:43:43 <earthy> you haven't seen many, then. :)
13:43:55 <araujo> i gotta say though i'd like to use a Haskel editor
13:44:02 <earthy> yi
13:44:08 <emk_> earthy: Well, not nice ones, at least.
13:44:10 <earthy> should investigate that. ;)
13:44:17 <araujo> yi? .. nah
13:44:20 <araujo> hIDE more likely
13:44:33 <araujo> But the development still continue
13:45:30 <klutometis> @babel de en Habe nun, ach! Philosophie, Juristerei und Medizin, Und leider auch Theologie Durchaus studiert, mit heiem Bemhn.
13:45:32 <lambdabot>  Property now, oh! Philosophy, lawyers' tricks and medicine, and unfortunately also theology quite study, with heiem Bemhn.
13:46:42 <SimonRC> heh
13:47:14 <earthy> that translation sucks
13:47:33 <glguy> maybe the guy that wrote the original german just sucks at german?
13:47:39 <earthy> no. ;)
13:47:43 <klutometis> glguy: lol
13:48:54 <glguy> @babel en de People united! Oh how do your spaghetti burn it thus so?
13:48:55 <lambdabot>  Leute vereinigt! OH- wie Ihr Isolationsschlauch, brennen ihn folglich so?
13:49:07 <defcon8> http://www.spapo.com/s050.html
13:49:09 <lambdabot> Title: SPASSPOST = SPAPO, titel
13:49:09 <shapr> I really want to write a TMR article that's expounds on Okasaki's ideas that laziness just high level self-modifying programs.
13:49:30 <shapr> newsham: It's likely I can help you with xemacs, but not right now.
13:49:37 <norpan> your sentence missing a verb
13:49:48 <earthy> 'By now I have studied philosophy, lawyer's trickery, and medicine, and unfortunately also theology quite thoroughly
13:49:51 <earthy> '
13:51:14 * earthy laughs at the spasspost site
13:51:50 <shapr> I want more HAppS examples!
13:51:55 * roconnor was wondering why my haskell VM was so slow
13:52:09 * roconnor forgot to turn on optimisations
13:52:22 <earthy> that'd slow things down, yes. :P
13:52:30 <glguy> shapr: I think we'd all be pleased to see more documentation of any form :)
13:52:53 <musasabi> shapr: anything special?
13:53:34 <earthy> documentation is like sex: when it's good, it's very very good. when it's bad, it's better than nothing.
13:53:42 <shapr> musasabi: Well, I had to red the source to figure out what lookS does.
13:53:43 <glguy> if it isn't the great refactorer himself! :-D
13:54:10 <glguy> lookS gets a input value from the request and the number is the maximum number of characters to read... right?
13:54:27 <glguy> (I thought tha that was covered in the tutorial)
13:55:22 <musasabi> it takes a name of field and a maximum size.
13:56:15 <shapr> Yeah
13:56:23 * shapr tries to organize his thoughts...
13:57:12 <roconnor> ugh, the adventure game is a memory pig.
13:57:18 <shapr> I think I should finish this wiki hack first, but I do have a few questions.
13:57:43 <mathewm> I need a haskell -> human translator...
13:57:51 <mathewm> "Irrefutable pattern failed for pattern (g', [card])" ?
13:58:03 <lispy> i tried to turn oohaskell into a library...but the examples don't compile with my library version...hmmm
13:58:12 <roconnor> earthy: Someone said that documenting code is bad, because it just become out of date and full of lies
13:58:45 <shapr> Most of the HAppS examples are 'top level' examples, putting HAppS somewhere between CGI & Zope as abstraction/complexity goes. Do you think HAppS will end up with some way to have multiple concurrent plugins that are all executed by a top level?
13:58:52 <thetallguy> Anyne know if there is an existing library function that returns the same answer as   digits = length . (show :: Int -> String)  ?
13:59:01 <earthy> roconnor: true enough. even then, some documentation is better than no documentation. especially if you don't have access to the sources
13:59:24 <shapr> HAppS is way better than a CGI program, but I haven't seen any examples using it as a pluggable webapp server.
13:59:36 <thetallguy> That is, the number of digits in an integer
14:00:11 <SimonRC> thetallguy: you could do something sick with logarithms?
14:00:27 <mathewm> hmm :( I though fail in the Maybe monad turned into Nothing
14:00:29 <roconnor> thetallguy, you could write your own function.
14:00:45 <skew> thetallguy: ceil . logBase 10 ?
14:01:01 <lispy> ?pl \n -> length (show n :: Int -> String)
14:01:01 <shapr> musasabi: Do you think HAppS will end up being totally pluggable like Plone? Or will it stay at the abstraction level of ruby on rails?
14:01:01 <lambdabot> (line 1, column 29):
14:01:02 <lambdabot> unexpected ">"
14:01:02 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
14:01:08 <lispy> ?pl \n -> length (show n)
14:01:08 <lambdabot> length . show
14:01:32 <xerox> lispy: the Very Kool thing about pl-ify, is that it is only a _syntactic_ transformation!
14:01:48 <shapr> musasabi: In any case, HAppS kicks butt =)
14:02:01 <mathewm> HAppS does kick butt!
14:02:15 <musasabi> HAppS already has multiple concurrently executing plugins.
14:02:18 <mathewm> I am glad it builds against 6.6 now
14:02:27 <lispy> xerox: i always forget that it doesn't use type info
14:02:28 <musasabi> That is e.g. how sessions work.
14:02:40 <shapr> musasabi: Oh.. is there an example of that?
14:02:48 <thetallguy> SimonRC: sick or slick?
14:03:00 <Philippa_> shapr: were you perhaps more interested in live updating and/or configuring of them?
14:03:28 <SimonRC> thetallguy: maybe slick, though I was originally thinking sick
14:03:45 <thetallguy> Thanks guys, I am writing my own function, but did not want to do so if it already existed.
14:03:46 <SimonRC> length . show is still probably faster
14:04:04 <musasabi> shapr: are you meaning having two top-level applications in e.g. /foo and /bar and using the same state/parts of the state?
14:04:44 <thetallguy> SimonRC: that was my guess as well.
14:04:55 <thetallguy> But it may depend on the integer.
14:05:31 <thetallguy> If using Integral, it might well not be.
14:05:37 <thetallguy> and big numbers
14:06:03 <zarvok> > let digits = ceiling . logBase 10 in digits 0
14:06:05 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
14:06:20 <zarvok> for this reason I like the length . show one :)
14:06:56 <xerox> ?type ceiling
14:06:59 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:07:48 <xerox> > let digits 0 = 1; digits n = ceiling (logBase 10) in (digits 0, digits 12345)
14:07:49 <lambdabot>  add an instance declaration for (RealFrac (a -> a))
14:07:49 <lambdabot>   In the definition o...
14:07:53 <xerox> Aw.
14:07:58 <xerox> > let digits 0 = 1; digits n = ceiling (logBase 10 n) in (digits 0, digits 12345)
14:08:00 <lambdabot>  (1,5)
14:08:07 <Botty> ?type String
14:08:09 <lambdabot> Not in scope: data constructor `String'
14:08:16 <xerox> > let digits 0 = 1; digits n = ceiling (logBase 10 n) in digits -12345
14:08:18 <lambdabot>  add an instance declaration for (Num (a -> b))
14:08:25 <Botty> hmm, is String not in the prelude?
14:08:25 <xerox> > let digits 0 = 1; digits n = ceiling (logBase 10 n) in digits (-12345)
14:08:27 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
14:08:31 <xerox> Yuck.
14:08:39 <xerox> > let digits 0 = 1; digits n = ceiling (logBase 10 (abs n)) in digits (-12345)
14:08:41 <lambdabot>  5
14:08:50 <zarvok> nice
14:09:16 <xerox> Botty: String is a type.
14:09:19 <xerox> @kind String
14:09:21 <lambdabot> *
14:09:33 <xerox> @type "foo"
14:09:34 <lambdabot> [Char]
14:09:37 <Botty> right
14:09:40 <earthy> @kind "foo"
14:09:42 <lambdabot> parse error on input `"'
14:09:45 * earthy grins
14:09:46 <xerox> @kind 1
14:09:48 <lambdabot> *
14:09:49 * xerox grins evilly
14:10:09 * Botty looks slightly confused that kind always says "*"
14:10:16 <therp> @kind M x
14:10:18 <lambdabot> Not in scope: type constructor or class `M'
14:10:18 <lambdabot>  
14:10:18 <lambdabot> <interactive>:1:2: Not in scope: type variable `x'
14:10:20 <xerox> @kind Control.Monad.Monad
14:10:22 <lambdabot> Class `Monad' used as a type
14:10:32 <Philippa_> @kind []
14:10:32 <earthy> @kind []
14:10:33 <lambdabot> * -> *
14:10:34 <lambdabot> * -> *
14:10:36 <xerox> @kind Control.Monad.RWS.RWST
14:10:38 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:10:40 <xerox> OK? :)
14:10:43 <Philippa_> xerox: evil :-)
14:10:56 <zarvok> ?type Control.Monad.RWS.RWST
14:10:58 <lambdabot> forall a (m :: * -> *) s w r. (r -> s -> m (a, s, w)) -> Control.Monad.RWS.RWST r w s m a
14:11:11 <xerox> ReaderWriterStateMonadTransfomer
14:11:17 <mathewm> Are there any good strategies to catch 'irrefutable pattern failed' before encountering them?
14:12:19 <therp> mathewm: return a maybe monad for the matches and foobar _ = Nothing for failed matches?
14:13:07 <Botty> > let digits 0 = 1; digits b n = ceiling (logBase b (abs n)); bDigits = digits 2; dDigits = digits in bdigits (5)
14:13:07 <lambdabot>  arity mismatch for 'digits'
14:13:25 <Botty> > let digits 0 = 1; digits b n = ceiling (logBase b (abs n)); bDigits = digits 2; dDigits = digits 10 in bdigits (5)
14:13:25 <lambdabot>  arity mismatch for 'digits'
14:13:26 <xerox> Botty: you need to generalize the first case as well
14:13:39 <Botty> ohh
14:13:51 <Botty> > let digits b 0 = 1; digits b n = ceiling (logBase b (abs n)); bDigits = digits 2; dDigits = digits 10 in bdigits (5)
14:13:52 <lambdabot>  Not in scope: `bdigits'
14:14:02 <xerox> Haskell is case-sensitive :)
14:14:04 <Botty> > let digits b 0 = 1; digits b n = ceiling (logBase b (abs n)); bDigits = digits 2; dDigits = digits 10 in bDigits (5)
14:14:05 <lambdabot>  3
14:14:06 <therp> hm please use a private interactive session
14:14:06 <Botty> :)
14:15:01 <mathewm> compiler warnings are my friends...
14:16:34 <sjanssen> matthewm: do you know of -fwarn-incomplete-patterns ?
14:16:41 <Botty> therp - yes I suppose i shouldn't participate until I stop making mistakes
14:16:49 <mathewm> just looking at that in the ghc users guide now
14:16:54 <xerox> Botty: it happens to everybody
14:16:56 <mathewm> thanks
14:17:00 <thetallguy> The length implementation of digits is also wrong, for negative numbers.
14:17:05 <Botty> yeah, i was being sarcastic :)
14:17:26 <xerox> hehe
14:17:59 <Botty> thetallguy - are you counting the negative sign then?
14:19:04 <mathewm> heh - all this time I have been using 'otherwise' in my case statements!  It works but....
14:19:35 <Botty> digits b n | n < 0 = 1 + (digits b (abs n))
14:20:05 <Botty> more like digits b n | n < 0 = 1 + (digits b -n)
14:24:14 <lisppaste2> mathewm pasted "How is this incomplete?" at http://paste.lisp.org/display/27171
14:25:19 <skew> mathewm: GHC doesn't try to understand that b /= King and b == King are exclusive, for example
14:25:31 <glguy> use otherwise
14:25:43 <skew> it also has some trouble with GADTs
14:26:19 <mathewm> Thanks!
14:26:27 <mathewm> I see
14:30:17 <shapr> musasabi: No, I mean more like a website where I can plugin a wiki, forum, etc
14:31:37 <musasabi> shapr: thus at the top-level you want to have something that switches between the components based on URLs?
14:32:41 <shapr> Yeah, that sounds right.
14:33:06 <shapr> It would seem to me that would require that each component have either their own state dir, or their own state files in the app dir.
14:33:33 <yip> anyone familiar with the ghc build process?
14:33:51 <nomeata> @seen ndm
14:33:52 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 3h 24m 14s ago, and .
14:34:06 <musasabi> data TopState = TS { s1 :: S1.State, s2 :: S2.State, ... }; app rq h ("c1":rest) = withS1 (S1.app rq h rest); app rq h ("c2":rest) = withS2 (S2.app rq h rest); ...
14:34:08 <mathewm> yip: I have done some building...
14:34:25 <musasabi> shapr: that could be automatized with some care.
14:34:29 <shapr> musasabi: And I'd like to have top level navigation that's wrapped around each component view. Basically, I want Plone :-) but if there's a better way, I want to hear about it.
14:34:53 <musasabi> I don't have a CMS with HAppS ;)
14:35:28 <yip> mathewm: i'm using the linux binary version, i'm wondering how i can have "make install" install to a directory of my choosing.
14:35:30 <Philippa_> is there any problem with letting shapr just write a top-level dispatch app?
14:35:34 <shapr> I wonder if alexj is even interested in a CMS plugin.
14:35:36 <Philippa_> to put it another way, are higher-order apps possible?
14:35:58 <weitzman> yip: I'm better there's a --prefix option
14:35:59 <sjanssen> yip: ./configure prefix=foo; make install
14:36:04 <weitzman> s/better/betting
14:36:10 <sjanssen> s/prefix/--prefix
14:36:28 <yip> no, i want to eventually install to /usr, so i have --prefix=/usr in the configure script
14:36:47 <yip> in most autoconf setups, you can do "make DESTDIR=foo install"
14:36:48 <mathewm> I am not sure, does the binary distro come with a Makefile even?
14:36:53 <yip> mathewm: yes
14:37:13 <musasabi> Philippa_: depends on the app. Currently it involves handwriting code like in my example.
14:37:36 <musasabi> Philippa_: this is because the apps need to be able to define e.g. command line arguments that can be collected for main, and other typeclass stuff.
14:37:49 <sjanssen> yip: so you want to install somewhere, test the installation, and then install to /usr ?
14:38:01 <yip> sjanssen: yes, this is actually for a package script
14:38:05 <Philippa_> and the typeclass fu involved in doing that automagically's hairy to say the least
14:38:20 <nomeata> There was some talk about a haskell implemented wiki one or two weeks ago. Here is one now: http://www.joachim-breitner.de/blog/archives/180-Latexki,-a-Wiki-for-LaTeX-in-Haskell-and-Python.html
14:38:24 <lambdabot> Title: Latexki, a Wiki for LaTeX in Haskell and Python - nomeata's mind shares, http://tinyurl.com/erh8d
14:39:48 <shapr> There are several wikis in Haskell, and writing a simple one with HAppS is pretty easy too.
14:39:50 <mathewm> yip: so you want to put the binarys in some temporary directory, though they will ultimately live in /usr ?
14:40:01 <musasabi> But I think it is currently 2 lines/component + ~10 lines static overhead.
14:40:20 <yip> mathewm: yes
14:40:36 <nomeata> Ok, make that "here is another one now"
14:41:09 <shapr> nomeata: LaTeX support is new to Haskell wikis :-)
14:41:25 <mathewm> yip: well, I don't think the paths get into any binaries  - so use the tmpdir for your prefix and fixup the strings manually?
14:41:49 <nomeata> probably. that also means literate haskell, but I yet have to put the wiki's code into latex files.
14:42:04 <yip> mathewm: the paths get into the "launch scripts"
14:42:27 <klutometis> @karma klutometis
14:42:28 <lambdabot> You have a karma of 0
14:42:30 <mathewm> yip: yeah, but a search-and-replace will do you
14:42:33 <Botty> I always thought it'd be kinda cool to use a wiki as a code revision system :P
14:42:45 <shapr> Botty: Yeah, me too.
14:42:46 <mathewm> yip: also, the paths get into the package configuration files
14:43:08 <yip> mathewm: hm...
14:43:19 <Botty> probably work best for something like haskell
14:43:48 <shapr> nomeata: Hey, this sounds perfect for TMR
14:43:50 <nomeata> Botty: well, this is the other way around: the wiki uses SVN as a data storage
14:43:57 <nomeata> TMR?
14:44:00 <Botty> make it so you can't commit an edit unless the code still passes unit tests (though, this allows you to obfusicate stuff)
14:44:10 <Botty> nomeata - yeah, either way
14:44:42 <shapr> The Monad.Reader
14:44:46 <nomeata> Botty: you mean like a pre-commit hook?
14:44:57 <Botty> the point is, source code you can edit in your browser
14:45:02 <Botty> nomeata - yep
14:45:16 <yip> mathewm: a search-and-replace feels like a really bad hack :|
14:45:25 <Botty> though then you have to decide who writes the unit tests
14:45:32 <nomeata> shapr: well, if you want to use it, great!
14:45:47 <nomeata> haskell syntax highlighting for the haskell sources is on the list too :-)
14:45:47 <Botty> and the normal user wouldn't be able to refactor
14:45:59 <mathewm> yip: we could patch up the makefiles to allow what you ask; but the "installed" version wouldn't work because none of the paths would be right
14:46:19 <shapr> nomeata: Malcolm's HsColour should work
14:46:43 <yip> mathewm: every other autoconf program i've seen has support for a DESTDIR in the makefile
14:46:48 <nomeata> shapr: I think I looked into that, but only briefly, as I wanted to get it working first. But something like that, yes.
14:46:53 <shapr> nomeata: Do you have the ability to display LaTeX wiki pages as inline graphics?
14:47:08 <mathewm> is this for sym-link farms, or a temporary depot for installation?
14:47:31 <shapr> Oops, I'm looking at the wrong wiki...
14:48:06 <shapr> Or is ikwiki.nomeata.de the correct wiki?
14:48:13 <nomeata> shapr: no, at least not yet. should be no problem to produce a png from the pdf though, if you mean that
14:48:20 <nomeata> lkwiki ist the old one, latexki the rewrite
14:48:27 <nomeata> lkwiki has content, latexki code :-)
14:48:31 <shapr> Where is the new wiki?
14:48:57 <nomeata> latexki.nomeata.de
14:49:06 <shapr> The Latexki link on your blog post points to ikwiki
14:49:39 <nomeata> ouch
14:49:40 <nomeata> :-)
14:49:45 <nomeata> got myself confused
14:49:53 <nomeata> fixed now
14:50:52 <yip> mathewm: temporary directory for making a package
14:51:44 <mathewm> yip: RPM-like - I see; sounds like a feature request :)
14:52:25 <yip> mathewm: for now the best option i guess seems like a search-and-replace :\
14:53:52 <klutometis> do you actually process the LaTeX, nomeata ; and if so:
14:53:52 <klutometis> do you guard against DOS, etc?
14:53:52 <mathewm> yip: you might be able to use DESTDIR in the subdirectories (compiler, ghci...)
14:54:07 <nomeata> klutometis: no, at least not yet
14:54:38 <nomeata> I'm thinking about a latex wrapper that runs in a chroot or something, but so far only nice people have used the (old) wiki
14:54:48 <yip> mathewm: i'm actually using the binary version though
14:55:42 <klutometis> nomeata: I ran into a similar problem for WikiTeX; no easy solutions forthcoming
14:56:10 <klutometis> chroot works best, I suppose, if you can isolate tex on its own partition
14:57:09 <nomeata> I have this in the texmf.cf:
14:57:10 <nomeata> shell_escape = f
14:57:20 <nomeata> openout_any = p
14:57:23 <nomeata> openin_any = p
14:57:30 <nomeata> this provides at least a little bit protection
14:57:59 <klutometis> exactly; those are standard
14:58:14 <nomeata> not on debian I think, I once filed a bug requesting for these
14:59:24 <klutometis> ah; main_memory, I thought, and some other options in texmf.cnf
14:59:32 <klutometis> might guard against DoS
15:00:11 <klutometis> there are some attacks, though, that will fill up one's hd
15:01:00 <nomeata> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=316154
15:01:05 <lambdabot> Title: #316154 - texmf.cfg: Close possible security problem - Debian Bug report logs, http://tinyurl.com/o9nad
15:01:09 <nomeata> debian has openin_any = a as standard
15:01:24 <shapr> oops
15:05:47 <nomeata> is there a library for diff'ing text files in haskell?
15:05:53 <nomeata> *for haskell
15:11:11 <henke> I use putStr to print out a list (made by list comprehension), how can I get a new line for every 9th character?
15:13:00 <lispy> anyone played the the OOHaskell source?
15:13:05 <nomeata> henke: split the list in a list of list with 9 elements, and then use map on that.
15:13:21 <lispy> i'm trying to build it as a library but instances are missing when i use it as package
15:13:26 <henke> aha
15:14:34 <nomeata> henke: is that a scastical aha? feel free to ask for more details, nothing wrong with that.
15:16:34 <user317> how do i convert double to cdouble?
15:16:44 <user317> and back
15:17:02 <wolverian> nomeata, scastical? sarcastic?
15:17:08 <wolverian> (just curious if that's a real word, heh)
15:17:10 <henke> ok :) How do I split the list into a list och list with 9?
15:17:40 <nomeata> wolverian: sarcastic, typo on my side.
15:17:59 <wolverian> thanks
15:18:16 <nomeata> henke: that's a function missing in the standard haskel libraries in my optinion, but is a good exercise for beginners
15:18:46 <henke> No it wasn't, I just had to hoogle for map and see if I could solve the problem first
15:18:50 <nomeata> henke: look at splitAt and use recursion for a "standard" solution
15:19:43 <user317> henke, spitat9 lst = (take 9 lst) : (splitat9 (drop 9 lst))
15:19:44 <henke> nomeata: oh, so I can't do it with just list comprehension?
15:20:16 <nomeata> henke: well, not inside it. you can use that function on a list comprehension then, of course
15:20:51 <nomeata> if you want to impress people steal from http://haskell.org/haskellwiki/Blow_your_mind:
15:20:54 <lambdabot> Title: Blow your mind: - HaskellWiki, http://tinyurl.com/jh68t
15:21:36 <user317> so, anyone know how to convert to and from CDouble?
15:21:39 <nomeata> splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt 2)
15:21:41 <nomeata> >splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt 2)
15:21:50 <nomeata> >L.splitBy n [1..10]
15:22:05 <lispy> nomeata: you need a space
15:22:09 <nomeata> > splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt 2)
15:22:10 <lambdabot>  Parse error
15:22:11 <nomeata> > L.splitBy n [1..10]
15:22:12 <lambdabot>  Not in scope: `n'
15:22:17 <nomeata> @def splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt 2)
15:22:17 <lambdabot> Maybe you meant: define definitions bf let
15:22:25 <nomeata> @define splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt 2)
15:22:26 <lambdabot> (line 1, column 4):
15:22:26 <lambdabot> unexpected "="
15:22:26 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
15:22:32 <lispy> > read (show (1.2) ) :: CDouble
15:22:33 <lambdabot>  Not in scope: type constructor or class `CDouble'
15:22:54 <nomeata> @define splitBy = \n -> takeWhile (not . null) . unfoldr (Just . splitAt 2)
15:22:55 <lambdabot> (line 1, column 2):
15:22:55 <lambdabot> unexpected "="
15:22:55 <lambdabot> expecting space or simple term
15:23:14 * nomeata takes lambdabot to some dark ally with privacy
15:23:29 <ThreeQ> http://lambdabot.codersbase.com/
15:23:30 <lambdabot> Title: Lambdabot Web Interface
15:25:44 <nomeata> @let splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt n)
15:25:45 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
15:25:51 <nomeata> > L.splitBy 5 [1..42]
15:25:53 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
15:25:58 <nomeata> > L.splitBy 5 [1..12]
15:25:59 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12]]
15:26:15 <nomeata> but I still think that this should be a Prelude function
15:27:14 <dfranke> Anyone know any MIT faculty interested in Haskell?
15:27:30 <dfranke> I'm filling out a grad school application and there's a section asking whom I want on my admissions committee.
15:27:57 <henke> nomeata: ok, so L.splitBy is a function, but what do I need to import to use it?
15:30:30 <mathewm> @pointless  mor a b = head . (filter isJust) $ [a,b]
15:30:31 <lambdabot> mor = ((head . filter isJust) .) . (. return) . (:)
15:30:51 <mathewm> is there not a Maybe 'or' ?
15:31:36 <nomeata> henke: you just put that after "@let" in your code
15:32:22 <nomeata> the "L." and "@let" is just IRC syntax
15:33:09 <glguy> L. is a qualified name
15:33:36 <nomeata> glguy: right, but if he puts the definition in the code, he does not have to worry about that
15:33:36 <glguy> like Data.List.sort
15:33:42 <glguy> sure
15:33:51 <glguy> I was just making sure that he knew it was valid haskell
15:33:54 <glguy> and not irc syntax
15:34:01 <ThreeQ> mathewm: liftM or . sequence?
15:34:03 <ThreeQ> ?type liftM or . sequence
15:34:05 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
15:34:22 <henke>  ok, still a bit confused
15:34:34 <glguy> sequence takes a list of actions that return a bool
15:34:40 <mathewm> ThreeQ: but I don't have bools
15:34:41 <glguy> and gives you an action that returns a list of bools
15:34:45 <glguy> or acts on bools
15:34:54 <mathewm> Maybe Int `mor` Maybe Int
15:35:10 <glguy> > Nothing `mplus` Just 1
15:35:11 <lambdabot>  Just 1
15:35:54 <mathewm> I want the short-circuit   either a or b (or nothing)
15:36:08 <glguy> mathewm: ^^
15:36:12 <mathewm> mor (Nothing) (Just 1) = Just 1
15:36:24 <glguy> mathewm: scroll up a couple lines
15:36:26 <sjanssen> @hoogle mor
15:36:27 <lambdabot> Distribution.Extension.NoMonomorphismRestriction :: Extension
15:36:27 <lambdabot> Distribution.Extension.PolymorphicComponents :: Extension
15:36:27 <lambdabot> System.Win32.Mem.copyMemory :: Ptr a -> Ptr a -> DWORD -> IO ()
15:36:38 <henke> nomeata: so "L." is an arbitrary list? and what doeas "@let" stand for?
15:36:39 <mathewm> mplus, aye?
15:36:47 <glguy> mathewm: for lists it's msum
15:36:56 <glguy> > msum [Nothing, Just 1, Just 2, Nothing]
15:36:58 <lambdabot>  Just 1
15:37:01 <sjanssen> henke: L. is a module qualifier
15:37:14 <mathewm> thanks!
15:37:19 <mathewm> I knew it had to be in there...
15:37:21 <glguy> also:
15:37:27 <nomeata> henke: @let tells lambdabot to define something
15:37:28 <glguy> > catMaybes [Nothing, Just 1, Just 2]
15:37:30 <lambdabot>  [1,2]
15:37:42 <nomeata> henke: and to not confuse other lambdabo users, it puts the definition in the L module
15:38:25 <nomeata> henke: in your own code, you can just write  splitBy n = takeWhile (not . null) . unfoldr (Just . splitAt n) and then use this "map (....) $ splitBy 9 [....]"
15:39:52 <henke> okey, thanks! I'll try it
15:40:22 <glguy> unfoldr (liftM2 (>>) (guard.not.null) (Just . splitAt n))
15:41:19 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [1..10]
15:41:21 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
15:42:20 <nomeata> @type guard
15:42:21 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:43:04 <mathewm> I wish exceptions in ghc gave line-numbers :(
15:43:27 <glguy> nomeata: as follows:
15:43:31 <glguy> > guard False >> Just 1
15:43:33 <lambdabot>  Nothing
15:43:35 <glguy> > guard True >> Just 1
15:43:37 <lambdabot>  Just 1
15:46:10 <glguy> > map guard [False, True] :: [Maybe Int]
15:46:11 <lambdabot>  Couldn't match `Int' against `()'
15:46:25 <glguy> > map guard [False, True] :: [Maybe ()]
15:46:27 <lambdabot>  [Nothing,Just ()]
15:46:58 <glguy> > map guard [False, True] :: [[()]]
15:46:59 <lambdabot>  [[],[()]]
15:47:23 <nomeata> > map guard [False, True] :: [Either () ()]
15:47:24 <lambdabot>  add an instance declaration for (Error ())
15:47:32 <glguy> ?instances MonadPlus
15:47:33 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
15:47:46 <nomeata> > map guard [False, True] :: [Either String ()]
15:47:48 <lambdabot>  [Left "",Right ()]
15:48:34 <glguy> fail "just about the only thing that uses this argument" :: Either String ()
15:48:40 <glguy> > fail "just about the only thing that uses this argument" :: Either String ()
15:48:42 <lambdabot>  Left "just about the only thing that uses this argument"
15:49:04 <nomeata> so in IO applications, I could use guard a little bit like assert in python
15:49:24 <nomeata> to make sure certain parts are only run when some assertion is true
15:49:31 <glguy> I believe so
15:50:37 <glguy> I don't know what modules defines the monadplus instances of IO though...
15:52:34 <glguy> Ah, Control.Monad.Error
15:52:49 <glguy> Prelude Control.Monad Control.Monad.Error> guard False >> print "test"
15:52:55 <glguy> *** Exception: user error (mzero)
15:53:28 <nomeata> > mzero
15:53:29 <lambdabot>  add an instance declaration for (Show (m a))
15:53:37 <nomeata> > mzero :: []
15:53:39 <lambdabot>    `[]' is not applied to enough type arguments
15:53:39 <lambdabot>   Expected kind `?', but ...
15:53:45 <glguy> > mzero :: [()]
15:53:46 <lambdabot>  []
15:53:50 <nomeata> > mzero :: [Int]
15:53:52 <lambdabot>  []
15:53:59 <glguy> > mzero :: IO ()
15:53:59 <nomeata> > mzero :: IO ()
15:54:00 <lambdabot>  No IO allowed
15:54:00 <lambdabot>  No IO allowed
15:54:01 <glguy> :(
15:54:11 <nomeata> > mzero :: Either String Int
15:54:13 <lambdabot>  Left ""
15:54:56 <nomeata> There should be more Monads to play around with, for better understanding of monads.
15:55:08 <glguy> ?instances Monad
15:55:09 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:56:46 <nomeata> most of them are not "simple" like Maybe and [], are they?
15:57:20 <glguy> State is pretty easy
15:57:29 <glguy> Either String is pretty easy
15:58:33 <nomeata> I like the definition of mplus in the haskell docs:
15:58:34 <nomeata> mplus :: m a -> m a -> m a
15:58:34 <nomeata> an associative operation
15:58:54 <glguy> nomeata: what more could you say
15:59:05 <glguy> mplus is pretty abstract on its own
16:00:02 <nomeata> I don't know, I was hoping for the docs to give me insight :-)
16:00:33 <nomeata> so, is any mathematical monoid an "instance" of MPlus?
16:00:53 <nomeata> *monoid with one
16:01:05 <xerox> ?type mempty
16:01:06 <lambdabot> Not in scope: `mempty'
16:01:08 <xerox> ?type mappend
16:01:10 <lambdabot> Not in scope: `mappend'
16:01:13 <xerox> ?docs Data.Monoid
16:01:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
16:01:46 <glguy> ?instances Monoid
16:01:47 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
16:02:05 <glguy> > [1,2] `mappend` [3,4]
16:02:06 <lambdabot>  [1,2,3,4]
16:04:40 * lispy sits back to see if anyone can explain his oohaskell problem
16:05:37 <nomeata> (1,'a') `mappend` (2,'c')
16:05:39 <nomeata> > (1,'a') `mappend` (2,'c')
16:05:40 <lambdabot>  add an instance declaration for (Monoid Char)
16:05:40 <lambdabot>   In the definition of `hys...
16:05:59 <nomeata> > (1,"a") `mappend` (2,"c")
16:06:00 <lambdabot>  Add a type signature
16:06:08 <nomeata> > (1,"a") `mappend` (2::Int,"c")
16:06:09 <lambdabot>  add an instance declaration for (Monoid Int)
16:06:09 <lambdabot>   In the definition of `tbo'...
16:06:20 <glguy> > ("a","b") `mappend` ("c","d")
16:06:22 <lambdabot>  ("ac","bd")
16:06:37 <nomeata> strange, why is Int no Monoid?
16:06:39 <glguy> instance (Monoid a, Monoid b) => Monoid (a, b)
16:06:56 <nomeata> mempty = 0 and mappend = (+) should work fine, shoudn't it?
16:07:01 <xerox> Int is bounded
16:07:07 <nomeata> ok, so Integer
16:07:16 <xerox> Alright
16:07:31 <glguy> it would be easy to define if you needed it :)
16:07:35 <nomeata> maybe because it could be mappend = (+) or (*), and both make sense
16:08:06 <glguy> > () `mplus` ()
16:08:08 <lambdabot>  Couldn't match `m a' against `()'
16:08:12 <glguy> > () `mappend` ()
16:08:13 <lambdabot>  ()
16:08:23 <glguy> > mempty :: ()
16:08:24 <lambdabot>  ()
16:08:45 <glguy> now *that* is useful ;)
16:08:56 <glguy> ?type msum
16:08:58 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
16:09:05 <glguy> ?hoogle [m a] -> m a
16:09:07 <lambdabot> Prelude.head :: [a] -> a
16:09:07 <lambdabot> Prelude.last :: [a] -> a
16:09:07 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
16:09:16 <glguy> is there an msum for monoid?
16:09:23 <nomeata> mconcat
16:09:34 <nomeata> > mconcat [replicate 10 ()]
16:09:35 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
16:09:37 <glguy> I was going to say that as a joke
16:09:43 <glguy> I didn't realize that thta twas actually it ;)
16:09:59 <nomeata> but it's not doing what I expected it would
16:10:03 <nomeata> @type mconcat
16:10:05 <lambdabot> Not in scope: `mconcat'
16:10:12 <nomeata> @type Monoid.mconcat
16:10:13 <lambdabot> Couldn't find qualified module.
16:10:14 <lispy> yeah, seems like we should be able to re-instance things on a per module basis
16:10:26 <nomeata> @type Data.Monoid.mconcat
16:10:28 <lambdabot> forall a. (Data.Monoid.Monoid a) => [a] -> a
16:10:28 <lispy> so that Integer could be a monoid for both (+) and (*)
16:10:42 <glguy> > mconcat ["a","b","c"]
16:10:43 <lambdabot>  "abc"
16:10:53 <glguy> OH
16:10:58 <glguy> > mconcat $ replicate 10 ()
16:11:00 <lambdabot>  ()
16:11:08 <nomeata> oh, of course
16:11:18 <nomeata> never mind my [] around replicate :-)
16:18:09 <glguy> As noted, there is no requirement for monoids to be any kind of container. More formally, monoids have kind *, but instances of MonadPlus, as they're Monads, have kind * -> *.
16:18:16 <glguy> quote from Wikibooks
16:18:27 <glguy> I found it interesting enough to share
16:23:12 <hyrax42> mconcat = foldr mappend mempty?
16:23:48 <sjanssen> @fptools Data.Monoid
16:23:49 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
16:23:51 <glguy> that's what I'm getting out of it
16:24:09 <hyrax42> @help fptools
16:24:10 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
16:24:10 <sjanssen> hyrax42: by default, yes
16:24:21 <hyrax42> hm
16:24:25 <hyrax42> that's url of source?
16:24:26 <sjanssen> instances may override that behavior
16:24:27 <hyrax42> that's handy
16:24:28 <sjanssen> yes
16:25:03 * shapr boings
16:26:01 <sjanssen> ooh, the Monoid instance for Ordering looks quite handy.  I'll have to remember that one
16:26:11 <glguy> ?instances Ordering
16:26:12 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
16:26:22 <glguy> ?type LT
16:26:24 <lambdabot> Ordering
16:26:33 <sjanssen> glguy: data Ordering = LT | EQ | GT
16:26:35 <glguy> > mconcat [LT,GT]
16:26:36 <lambdabot>  LT
16:26:47 <glguy> > mconcat [GT,LT]
16:26:49 <lambdabot>  GT
16:27:00 <sjanssen> @type mconcat . zipWith compare
16:27:00 <glguy> > mempty :: Ordering
16:27:02 <lambdabot> Not in scope: `mconcat'
16:27:02 <lambdabot>  EQ
16:27:15 <glguy> > EQ `mappend` LT
16:27:17 <lambdabot>  LT
16:27:25 <sjanssen> @type Data.Monoid.mconcat . zipWith compare
16:27:27 <lambdabot>   Expecting a function type, but found `b'
16:27:27 <lambdabot>    Expected type: [a1] -> [a]
16:28:09 <sjanssen> @type (Data.Monoid.mconcat .) . zipWith compare -- one more time
16:28:11 <lambdabot> forall b. (Ord b) => [b] -> [b] -> Ordering
16:29:05 <glguy> sjanssen:
16:29:14 <glguy> > [1,2,3,5] `compare` [1,2,3,4]
16:29:16 <lambdabot>  GT
16:29:33 <shapr> Is it possible to post to a google group from gnus?
16:29:59 * shapr discovers the problem
16:31:18 <sjanssen> glguy: hmm?
16:31:34 <glguy> sjanssen: I think that the function you just described is exactly how compare works on lists
16:31:43 <sjanssen> glguy: exactly ;)
16:32:31 <weitzman> > compare (Left []) (Right False)
16:32:32 <lambdabot>  Add a type signature
16:32:44 <weitzman> > compare (Left True) (Right True)
16:32:46 <lambdabot>  LT
16:32:52 <weitzman> That's interesting
16:33:02 <weitzman> > compare True False
16:33:03 <lambdabot>  GT
16:33:20 <weitzman> Truth beats falsity
16:33:37 <sjanssen> weitzman: [] :: a -- the type needs to be monomorphic to find which instance of Ord to use
16:33:59 <weitzman> > compare (Left ([] :: [Int])) (Right False)
16:34:01 <lambdabot>  LT
16:35:21 <weitzman> > compare (Left 2) (Left 1)
16:35:22 <lambdabot>  Add a type signature
16:35:42 <weitzman> > compare (Left (1::Int)) (Left (1::Int))
16:35:43 <lambdabot>  Add a type signature
16:36:04 <weitzman> Ah, need to specify the either type
16:36:05 <weitzman> Same thing
16:36:27 <weitzman> > compare ((Left 1) :: Either Int Bool) (Left 0)
16:36:30 <lambdabot>  GT
16:36:53 <weitzman> @instances-importing Ord
16:36:55 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
16:37:10 <weitzman> > compare LT GT
16:37:11 <lambdabot>  LT
16:37:54 <weitzman> > compare (Just 2) Nothing
16:37:56 <lambdabot>  GT
16:38:36 <henke> got stuck again, [map putStr g|[g] <- (splitat9 [maybe '.' intToDigit a | r <- x, a <- r])] gives *** Type           : String -> IO ()
16:38:41 <Botty> > let removeOp n list val = if val == n then list else (list:val); remove n = foldl (removeOp n) [] in remove 5 [1,2,5,3,5]
16:38:41 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
16:38:42 <lambdabot>    Expected...
16:38:52 <henke> *** Does not match : Char -> IO ()
16:40:31 <nomeata> > map putStrLn (splitat9 [maybe '.' intToDigit a | r <- x, a <- r])
16:40:33 <lambdabot>  Not in scope: `x'
16:40:55 <sjanssen> henke: so g :: String ?
16:41:52 <henke> sjanssen: x is the origin
16:42:21 <nomeata> @type \x ->  map putStrLn (splitat9 [maybe '.' intToDigit a | r <- x, a <- r])
16:42:23 <lambdabot> Not in scope: `splitat9'
16:42:32 <nomeata> @type \x ->  map putStrLn (L.splitat 9 [maybe '.' intToDigit a | r <- x, a <- r])
16:42:33 <lambdabot> Couldn't find qualified module.
16:42:53 <nomeata> lambdabot's type can't use L.?
16:42:58 * mux hearts ICFP contest organizers
16:43:15 <nomeata> @type \x ->  map putStrLn (splitAt 9 [maybe '.' intToDigit a | r <- x, a <- r])
16:43:17 <lambdabot>   Couldn't match `[String]' against `([a], [a])'
16:43:17 <lambdabot>    Expected type: [String]
16:43:34 <henke> nomeata: I've defined splitat9 (or, you did it for me an hour ago)
16:44:03 <nomeata> henke: right, I'm just noticing that lambdabot can not use the definition inside @type, it seems.
16:44:24 <nomeata> henke: is x a list of list of Ints?
16:44:42 <nomeata> henke: and what does the maybe function do?
16:45:17 <henke> the x is a list of lists of Maybe
16:45:28 <nomeata> > map putStrLn (L.splitAt 9 [maybe '.' intToDigit a | r <- [[Nothing]], a <- r])
16:45:29 <lambdabot>  Not in scope: `L.splitAt'
16:46:02 <nomeata> > map putStrLn (L.splitBy 9 [maybe '.' intToDigit a | r <- [[Nothing]], a <- r])
16:46:03 <lambdabot>  No IO allowed
16:46:05 <henke> the maybe function converts some Just1-9 and Nothings to digits 1-9 and '.'
16:46:28 <nomeata> ok, so that code should do what you want, I think.
16:46:36 <nomeata> > map (++"\n") (L.splitBy 9 [maybe '.' intToDigit a | r <- [[Nothing]], a <- r])
16:46:37 <lambdabot>  [".\n"]
16:47:08 <Botty> hmm, how do i add an item to the end of the list
16:47:14 <nomeata> > let x = [map Just [1..12]] in  map (++"\n") (L.splitBy 9 [maybe '.' intToDigit a | r <- x, a <- r])
16:47:14 <Botty> list : val doesn't work
16:47:16 <lambdabot>  ["123456789\n","abc\n"]
16:47:29 <nomeata> but why not this:
16:48:20 <nomeata> > let x = [map Just [1..12]] in  map (++"\n") $ L.splitBy 9 $ map (\a -> maybe '.' intToDigit a) $ concat $ concat x
16:48:21 <lambdabot>  Couldn't match `[a]' against `Maybe a1'
16:48:51 <nomeata> > let x = [map Just [1..12]] in  map (++"\n") $ L.splitBy 9 $ map (\a -> maybe '.' intToDigit a) $ concat x
16:48:52 <lambdabot>  ["123456789\n","abc\n"]
16:49:16 <nomeata> @pl \x -> map (++"\n") $ L.splitBy 9 $ map (\a -> maybe '.' intToDigit a) $ concat x
16:49:17 <lambdabot> map (++ "\n") . L . splitBy 9 . map (maybe '.' intToDigit) . join
16:50:47 <nomeata> good night everyone
16:59:38 <Botty> > [1,2,3] : 4
16:59:39 <lambdabot>  add an instance declaration for (Num [[a]])
16:59:50 <Botty> > 4 : [1,2,3]
16:59:52 <lambdabot>  [4,1,2,3]
16:59:55 <Botty> :(
17:00:03 <hyrax42> [1,2,3] = 1:2:3:[]
17:00:29 <hyrax42> > []:[]
17:00:30 <lambdabot>  Add a type signature
17:00:31 <Botty> yes, but how do i add a value to the end of a list?
17:00:36 <hyrax42> ++
17:00:44 <hyrax42> [1..3] ++ [4]
17:00:46 <Botty> ahah
17:00:47 <Botty> thanks
17:00:53 <hyrax42> but the thing you add has to be a list
17:01:00 <hyrax42> so you need to put [] around it
17:01:10 <Botty> yeah.  I tried ++ before but i forgot the []
17:01:58 <hyrax42> adding a single element to the end of a list repeatedly is typically bad though
17:02:01 <hyrax42> just fyi
17:02:28 <glguy> > reverse (4 : reverse [1..3])
17:02:29 <lambdabot>  [1,2,3,4]
17:02:31 <Botty> hmm ok
17:02:46 <Botty> ahah, I'll just foldr
17:03:32 <glguy> > foldr (:) [4] [1..3]
17:03:33 <lambdabot>  [1,2,3,4]
17:04:19 <hyrax42> hm
17:12:37 <henke> can I use foldr to insert a \n at the end of every list in splitat9 st = (take 9 st) : (splitat9 (drop 9 st))
17:13:14 <zeeeee> hi all, is there a function (applyN n f x) that will apply f a total of n times, passing the output of the previous application to the input of the next, starting with input x?
17:13:16 <henke> or will it be type error since st is a list of Ints
17:16:01 <Cale> henke: seems like a type error to me
17:16:29 <Cale> zeeeee: iterate f x !! n
17:16:44 <Cale> > iterate (+1) 0
17:16:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:16:50 <Cale> > iterate (+1) 0 !! 12
17:16:51 <lambdabot>  12
17:17:22 <zeeeee> Cale: thanks!
17:21:02 <yip> mathewm: you still here?
17:22:12 <Valina> hallo
17:22:37 <dolio> > iterate ((/2) . ap (+) (2/)) 1
17:22:38 <lambdabot>  [1.0,1.5,1.4166666666666665,1.4142156862745097,1.4142135623746899,1.41421356...
17:22:55 <Valina> ?
17:23:25 <Valina> non c'e' nessuno?
17:23:55 <ThreeQ> > sqrt 2 - (iterate ((/2) . ap (+) (2/)) 1 !! 5)
17:23:57 <lambdabot>  2.220446049250313e-16
17:24:14 <Valina> ke fate?
17:24:28 <ThreeQ> > map ((sqrt 2) -) $ iterate ((/2) . ap (+) (2/)) 1
17:24:29 <lambdabot>  [0.41421356237309515,-8.578643762690485e-2,-2.453104293571373e-3,-2.12390141...
17:24:42 <yip> jow does ghc package.conf work together with distro package management?
17:24:47 <glguy> ?yow
17:24:47 <lambdabot> On the road, ZIPPY is a pinhead without a purpose, but never without a
17:24:48 <lambdabot> POINT.
17:25:01 <ThreeQ> @pl zippy
17:25:01 <lambdabot> zippy
17:25:41 <Valina> che stanza e' questa?
17:25:45 <Valina> :(
17:30:04 <klutometis> @help yhjulwwiefzojcbxybbruweejw
17:30:05 <lambdabot> V RETURNS!
17:30:21 <yip> how do i use GHC api? :m GHC gives me error: Could not find module `GHC': It is a member of package ghc-6.5.20060930, which is hidden
17:30:21 <klutometis> @help v
17:30:22 <lambdabot> let v = show v in v
17:30:47 <SamB> yip: -package ghc ?
17:30:53 <ThreeQ> ?v "x"
17:30:54 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
17:31:23 <ThreeQ> ?t fix show
17:31:23 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
17:31:28 <ThreeQ> ?type fix show
17:31:29 <lambdabot> String
17:31:36 <Lemmih> yip: Expose it?
17:31:36 <ThreeQ> > fix show
17:31:38 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:31:57 <yip> SamB: Loading package ghc-6.5.20060930 ... ghc-6.5.20060930: can't load .so/.DLL for: HSghc (libHSghc.so: cannot open shared object file: No such file or directory)
17:32:07 <SamB> yip: hmm
17:32:27 <SamB> perhaps it is not properly installed?
17:32:41 <yip> i really don't have that file anywhere
17:35:24 <sjanssen> yip: any chance you're on an Intel Mac?
17:35:26 <yip> it's not in the archive ghc-6.5.20060930-i386-unknown-linux.tar.bz2
17:35:34 <sjanssen> nevermind
17:36:13 <yip> are the ghc binaries maybe compiled without GHC api support? do i have to compile ghc from source?
17:36:33 <sjanssen> I seem to remember an error like that before running ranlib on some of GHC's .a files
17:37:39 <yip> i don't seem to have any file with a name even close to this file
17:37:56 <klutometis> since ghc is required to compile ghc, by the way,
17:38:06 <klutometis> how did the first compiler escape the circular dependency?
17:38:24 <yip> hugs
17:38:36 <Lemmih> yip: You should have a libHSghc.a
17:38:37 <SamB> is that a statement or a guess?
17:38:48 <klutometis> aha; though the problem of firste compilation isn't specific to ghc, I suppose
17:38:48 <SamB> Lemmih: telling him that will not help!
17:38:57 <yip> Lemmih: nope, don't have that guy
17:39:05 <Lemmih> SamB: It won't?
17:39:18 <SamB> Lemmih: he already knows that he *should* have it
17:39:50 <yip> ghc-6.5.20060930-i386-unknown-linux.tar.bz2
17:39:52 <Lemmih> He does?
17:40:25 <yip> i downloaded this file from haskell site, it doesn't contain libHSghc.so or libHSghc.a or *ghc*.so or *ghc*.a
17:42:51 <SamB> how are those tarballs built anyway?
17:42:55 <Lemmih> Hm, I'd poke Igloo if I were you.
17:43:07 <yip> SamB: they appear to be automatic nightly builds
17:43:18 <yip> i'm gonna try compiling ghc from source
17:43:48 <yip> what is src-extralibs for?
17:44:25 <sjanssen> yip: source for libraries that used to come with GHC but won't with the 6.6 release
17:44:28 <klutometis> yip: I eventually had to compile from source, btw
17:44:34 <klutometis> yip: time-consuming, but not too bad
17:45:54 <yip> do i want these extralibs?
17:46:48 <sjanssen> yip: you probably want at least one or two of them
17:47:08 <yip> i can pick and choose?
17:48:19 <sjanssen> I think the build system tries to build all the libs in ghc/libraries.  So you can opt to remove some of them . . . I think
17:48:27 <newbcoder> is there a make replacement writte in haskell?
17:58:56 <lisppaste2> henke pasted "print sudoku" at http://paste.lisp.org/display/27181
18:00:05 <kpreid> henke: you want mapM_ putStr
18:00:58 <henke> how does it work?
18:03:55 <kpreid> look at the types!
18:04:31 <newbcoder> is there a list of system apps being written in haskellsomewhere?
18:04:37 <newbcoder> i would like to use haskell as my default scripting language
18:05:26 <sjanssen> newbcoder: what do you mean by "system apps"
18:05:32 <kpreid> what's a system app?
18:05:40 <newbcoder> err i meant scripts
18:06:00 <Fey> Hello. I am looking for someone with a mild sense of patience to help me out with a beginners question
18:06:01 <glguy> that's dons thing
18:06:04 <glguy> using bytestring
18:06:10 <glguy> writing common unix utilities
18:06:14 <kpreid> newbcoder: you might find this interesting: http://haskell.org/haskellwiki/Simple_unix_tools
18:06:17 <lambdabot> Title: Simple unix tools - HaskellWiki, http://tinyurl.com/hekpb
18:06:35 <kpreid> Fey: just ask the channel
18:06:41 <sjanssen> newbcoder: Linspire (a Linux distribution company) is using Haskell for all their internal tools
18:07:39 <Fey> I am having some trouble with a do statement. I am trying to use do e <- readFile x ; p <- lines e ; return (stuff p)
18:08:15 <sjanssen> Fey: "<-" means monadic bind, because the result of "lines e" isn't in the IO monad you can't write that
18:08:33 <sjanssen> Fey: do ...; let p = lines e; ... should work though
18:09:18 <Fey> thank you
18:09:31 <kpreid> Fey: do e <- readFile x; return (stuff (lines p))
18:09:43 <kpreid> or do e <- readFile x; return . stuff . lines $ p
18:09:52 <glguy> some of the Haskell programmers on Project Euler got around that issues by replaceing let p = lines q with p <- return (lines q)
18:10:14 <kpreid> er, use the same variable, obviously :)
18:10:17 <glguy> that issue *
18:10:22 <sjanssen> glguy: I'd consider using let to be better style
18:10:27 <kpreid> or: readFile x >>= (return . stuff . lines)
18:10:29 <glguy> sjanssen: ditto
18:11:01 <glguy> kpreid: or just liftM?
18:11:54 <kpreid> hm, yes
18:12:43 <glguy> liftM (stuff . lines) $ readFile x -- for anyone that needed an example
18:13:30 <sjanssen> @. pl undo do e <- readFile x ; let {p = lines e} ; return (stuff p)
18:13:31 <lambdabot> (line 1, column 27):
18:13:31 <lambdabot> unexpected "{"
18:13:31 <lambdabot> expecting natural, identifier or "in"
18:14:57 <sjanssen> bah! @pl needs to use a real Haskell parser
18:17:14 <Adamant> Haskell makes my brain taste like burning
18:17:47 <sjanssen> @remember Adamant Haskell makes my brain taste like burning
18:18:02 <Adamant> :)
18:18:13 <Adamant> @quote Adamant
18:18:13 <lambdabot>  Haskell makes my brain taste like burning
18:19:19 <sjanssen> so, Ralph Wiggum, what is hurting your brain?
18:22:23 <Adamant> nothing really, I'm just tired and cranky and still trying to learn when I should be sleeping.
18:22:56 <Adamant> on the bright side though, I haven't bent my wookie yet
18:30:14 <lisppaste2> Botty pasted "Ways to make this simpler/more elegant/more idiomatic?" at http://paste.lisp.org/display/27185
18:30:46 <Botty> mainly in the simplify command
18:31:49 <Botty> and yes I know evaluate will do everything simplify does and more - i plan to add variables...
18:33:53 <dibblego> > [1..] !! 3
18:33:54 <lambdabot>  4
18:37:11 <kpreid> ?check uncurry (==) . (([0..] !!) &&& id)
18:37:12 <lambdabot>  Exception: Prelude.(!!): negative index
18:37:55 <kpreid> ?check \x -> x > 0 ==> (uncurry (==) . (([0..] !!) &&& id)) x
18:37:57 <lambdabot>  OK, passed 500 tests.
18:38:07 <kpreid> ?scheck uncurry (==) . (([0..] !!) &&& id)
18:38:08 <lambdabot>  Exception: Prelude.(!!): negative index
18:38:16 <sjanssen> Botty: won't "Add [C 1]" loop forever in simplify?
18:39:04 <Botty> nope
18:39:27 <kpreid> Botty: simplify (Add es) | (length es == 1) = es !! 0
18:39:27 <kpreid>  can better be written as simplify (Add [e]) = e
18:39:28 <Botty> simplify (Add es) | (length es == 1) = es !! 0
18:40:13 <Botty> cool
18:40:15 <kpreid> similarly simplify (Add es) | (es == []) = C 0  should be  simplify (Add []) = C 0
18:40:20 <sjanssen> Botty: are you sure about that?  I think it will
18:40:24 <kpreid> simplify (Add es) = simplify (Add (remove (C 0) es)) -- *will* loop
18:40:47 <sjanssen> Botty: also remove is similar to the library function called filter
18:41:15 <Botty> oh yeah, forgot about filter, thanks
18:41:53 <Botty> kpreid - good point.  makes me wonder why it works fine 0_0
18:41:58 <Botty> oh yeah
18:42:10 <Botty> nevermind. figured out why my test worked
18:42:51 <Botty> is there any way to combine the add/mul code?  they are pretty much the same except mul's identity is C 1
18:43:11 <Botty> Neg and Inv share stuff to
18:44:41 <dylan> bah. ratpoison has easy to remember key bindings, and but ion3 is more useful (but with not-like-screen bindings...)
18:44:51 <dylan> err, ignore that. wrong channel
18:47:58 <yip> dylan: try wmii
18:48:17 <dylan> yip: don't feel like configuring it, and it's still not like screen.
18:48:47 <dylan> using 9p is pretty cool, though.
18:52:41 <kpreid> Botty: you could have Expr = ... | Call Function [Expr] instead of Expr = ... | Add [Expr]
18:52:54 <kpreid> data Function = Add | Mul | ...
18:53:03 <kpreid> identity Add = 0
18:53:08 <kpreid> identity Mul = 1
18:53:26 <kpreid> Function is perhaps the wrong name
18:53:32 <kpreid> call it AssocOp instead
18:53:36 <Botty> hmm, good idea though
18:54:03 <Fey> I still do not fully understand how the do part works. I now have frequency [ (9, return Nothing)
18:54:04 <Fey> 		 , (1, do n <- choose (1, 9)
18:54:04 <Fey> 				return (Just n))
18:54:04 <Fey> 		
18:54:04 <Fey> ]
18:54:27 <Fey> but obviously I'm doing something wrong
18:54:37 <Fey> And most likely the same thing wrong that I did last time
18:58:18 <dibblego> I tried to write length in Java, but it performs horribly - I assume it is the tail recursive call
18:58:40 <kpreid> Fey: in what way is it failing? if it's a syntax error, then check the indentation of the second line of the do block
18:59:01 <kpreid> as I received it, it looks like the second line has one space too few
18:59:18 <Fey> I'm getting the last generator in do  {...} must be an expression
19:01:18 <sjanssen> Fey: yes, most likely an indentation problem
19:02:08 <sjanssen> "return ..." isn't being recognized as part of the "do"
19:02:15 <Botty> kpreid - ok, so lets say I'm writing the new version of "simplify (Add []) = C 0; simplify (Mul []) = C 1" what do i do?
19:02:51 <Botty> wait, nevermind
19:02:57 <Botty> I think i figured it out
19:03:28 <Fey> but even if I put it all on the same line I get the same error
19:03:53 <kpreid> Fey: yes, that means that what it *thinks* is the last line isn't an expression
19:04:00 <sjanssen> Fey: then you probably need a semicolon after the n <- ... line
19:04:48 <Fey> semicolon did it
19:04:51 <Fey> Thank you again :)
19:19:56 <SamB> hmm, my hugs lacks Data.Map
19:20:03 <SamB> I think its time to upgrade
19:21:54 <dropdrive> I have main = print $ (slow 100000) `par` (slow 123456) where slow n calculates n!  If I compile this correctly, should it use two processors?
19:23:03 <chessguy> what is $
19:24:41 <mwc> dropdrive, wasn't `par` part of the parallel haskell that ran on the PVM? Last I saw, that was bitrotted
19:24:58 <mwc> plus, most clusters these days have switched over to MPI
19:25:35 <mwc> chessguy, low associativity functino application. useful for avoiding parenthetical nesting
19:25:37 <dropdrive> mwc: That's the thing...I couldn't tell whether par or any of that stuff was working or not...
19:26:21 <dropdrive> chessguy: So print 1+2 is actually (print 1)+2 (error) but print $ 1+2 is print (1+2)
19:28:07 <sjanssen> mwc: par is useful again in GHC 6.6
19:28:16 <dropdrive> mwc: So is there a simple example of parallel program that doesn't use bitrotted code?
19:28:18 <mwc> yes, I see that, I checked hte manual
19:28:29 <mwc> parallel haskell can be run on SMP or GPH
19:28:33 <mwc> so just GPH is broke :)
19:28:54 <mwc> dropdrive, that's what it says here: http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
19:28:57 <lambdabot> Title: 7.15. Parallel Haskell, http://tinyurl.com/zqwkf
19:30:29 <sjanssen> dropdrive: I think you'll want a seq in there somewhere, but yes, GHC 6.6 allows programs like that to run in parallel
19:32:02 <dropdrive> sjanssen: Okay, thanks.  (I was using a 6.5 snapshot.)
19:32:47 <sjanssen> should work in 6.5 too, if you didn't know
19:37:46 <lisppaste2> dropdrive pasted "par?" at http://paste.lisp.org/display/27187
19:38:56 <dropdrive> sjanssen: compiled properly, should my paste take advantage of an SMP system?
19:44:48 <sjanssen> dropdrive: not sure if that's exactly right . . . the par combinator is kind of confusing
19:45:05 <sjanssen> I think you also need to run your program with ./myprogram +RTS -N 2
19:45:48 <sjanssen> I'd look at the nfib example at the link mwc posted and make my code look like that
19:46:32 <Lemmih> It doesn't work for me.
19:50:06 <Patterner> cool. tweaking the hugs98 ebuild and voila: -- Hugs Version September 2006
19:57:23 <cybercobra> ?type Bool
19:57:24 <lambdabot> Not in scope: data constructor `Bool'
19:59:42 <glguy> ?kind Bool
19:59:43 <lambdabot> *
19:59:57 <sjanssen> @where paste
19:59:57 <lambdabot> http://paste.lisp.org/new/haskell
20:00:10 <glguy> ?type False
20:00:11 <lambdabot> Bool
20:00:13 <glguy> ?type True
20:00:14 <lambdabot> Bool
20:00:22 <sjanssen> hmm, lisppaste is down?
20:03:17 <dropdrive> sjanssen: compile with +RTS -N2 or run with +RTS -N2?
20:03:39 <sjanssen> run with +RTS -N2
20:03:43 <sjanssen> and compile with -threaded
20:03:51 <sjanssen> I've actually got a working example I can show you
20:04:58 <dropdrive> sjanssen: please =)
20:05:25 * araujo getting a friend of him into Haskell
20:06:26 <araujo> "I am trying to understand this thing ..."
20:06:28 <araujo> hah
20:07:01 * araujo remembers his first days with Haskell when he hears this kind of comments
20:07:45 <dylan> I was lucky to start learning haskell by osmosis.
20:08:43 * glguy remembers "How do I get the String out of IO String"
20:08:58 <weitzman> @hoogle IO String -> String
20:09:00 <lambdabot> No matches, try a more general search
20:09:07 <weitzman> @hoogle IO a -> a
20:09:09 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:09:09 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
20:09:09 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
20:09:20 <weitzman> Strange that hoogle didn't find it when I said "String"
20:09:37 <sjanssen> dropdrive: http://cse.unl.edu/~sjanssen/par_factorial.hs
20:11:49 <sjanssen> weitzman: oh god . . . Hoogle could start hundreds of newbies on the path to the dark side
20:12:40 <sjanssen> we should probably ask ndm to make queries of the form IO a -> a return something like "DON'T DO THAT!"
20:12:57 <weitzman> main = case (unsafePerformIO (print "One\n"), unsafePerformIO (print "Two\n")) of ((),()) -> "Done"
20:13:25 <weitzman> Would that print anything? I shall test
20:13:51 <weitzman> @index unsafePerformIO
20:13:52 <lambdabot> System.IO.Unsafe, Foreign
20:14:08 <weitzman> Yep
20:14:10 * edwardk waves hello.
20:14:10 <weitzman> Things print
20:15:05 <dolio> weitzman: What if you do ~((),()) ?
20:15:29 <weitzman> No printing
20:15:34 <int-e> hmm? isn't that just _ with a forced type?
20:15:34 <dolio> :)
20:15:45 <weitzman> I worry that _ wouldn't force the printing
20:16:03 <weitzman> Oh, yeah, dolio's
20:16:44 <weitzman> So once you've written a pure function that prints a list of strings in order...
20:16:53 <weitzman> You're well on your way to being productive with Haskell!
20:16:55 <dibblego> how do you argue in favour of pure functional against say OCaml users?
20:17:03 <dolio> You can probably do ((),_) to only print the first, as well.
20:17:10 <dolio> Etc.
20:17:39 <edwardk> dibblego: STM, DPH, etc.
20:17:50 <dibblego> edwardk, what is that exactly?
20:18:19 <int-e> weitzman: is there any reason not to use seq?
20:18:47 <weitzman> weitzman: There are probably a few reasons, at least one of them being that I don't quite know what seq does
20:18:51 <sjanssen> edwardk: I agree.  GHC's STM design is one of the best advertisements for Haskell I've ever seen
20:18:53 <weitzman> Gah, I'm talking to myself again
20:19:05 <dibblego> ?STM
20:19:05 <lambdabot> Unknown command, try @list
20:19:17 <dibblego> wtf are those acronyms?
20:19:23 <int-e> weitzman: I wasn't here then.
20:19:24 <weitzman> STM = software transactional memory
20:19:33 <dibblego> what is DPH?
20:19:34 <dolio> Software Transactional Memory, Distributed Parallel Haskell?
20:19:53 <sjanssen> dibblego: Software Transactional Memory -- a framework for writing threaded programs that share state
20:20:18 <dolio> Oh, my bad. Data Parallel...
20:20:29 <edwardk> data parallel haskell
20:20:39 <edwardk> sorry was afk
20:20:58 <edwardk> another good advertisement is the performance of data.bytestring.lazy
20:21:15 <weitzman> I don't think I would argue performance with the OCaml people
20:21:21 <edwardk> oh and take 20 $ [1..]
20:21:27 <weitzman> Haskell seems to lead to confusing issues with memory usage
20:21:28 <edwardk> weitzman: fair nuff
20:21:35 <int-e> weitzman: anyway, there was a thread about this on haskell-cafe last week ... starting at http://www.haskell.org/pipermail/haskell-cafe/2006-September/018476.html
20:21:37 <lambdabot> Title: [Haskell-cafe] Expressing seq, http://tinyurl.com/zffo7
20:21:52 <dibblego> I am just using my feeble understanding to argue in favour of referential transparency - I am convinced it's right, but I lack the terminology and mathematical background
20:22:33 <weitzman> int-e: Thanks for the link. I will now commence my "seq" training
20:22:57 <edwardk> dibblego: just poke fun at their syntax, thats a mature way to win the argument ;)
20:23:42 <dibblego> edwardk, I am not actually arguing with a OCaml user - more like with a friend playing devil's advocate - pretending to be in favour of OCaml and observing "state" changing (I argue it is only time that is changing)
20:25:48 <Cale> dibblego: Well, the nice thing about referential transparency is that it's possible to understand the behaviour of your programs by doing substitutions
20:26:12 <Cale> But once you add state/time into the picture, that's no longer possible.
20:26:50 <weitzman> With state, it's possible to understand the behavior of your programs using state machines
20:26:56 <Cale> You have to use a much more complicated model for what is going on, which has an environment, and where the evaluation order of everything matters deeply.
20:27:17 <weitzman> State machines aren't that bad
20:27:22 <dibblego> don't monads simply pretend to pass that "state" as a function argument - making it not state at all?
20:27:43 <Cale> They're a lot worse than being able to write down equations and make substitutions, and simplify things based on rules that you know
20:27:48 <int-e> dibblego: not in ocaml. which was the point, wasn't it?
20:27:56 <dibblego> int-e, right
20:29:03 <weitzman> Using pure functions is an abstraction technique, so I think you would argue for or against it as you would any other abstraction technique
20:29:29 <dibblego> I think it is more than that
20:30:16 <dibblego> I think it is inherent in software
20:30:23 <Cale> Disallowing state (or confining it to specific regions) is not simply a form of abstraction, it's a way of increasing the number of guarantees you can make about the behaviour of your programs.
20:31:06 <dibblego> that the "file system" or "database" might be considered global "state" is in fact, a huge problem - and not only that, it is incorrect (don't you deploy on some other "file system" or "database"?)
20:31:06 <weitzman> You can make guarantees with state
20:31:12 <weitzman> Not at a language-level, maybe
20:31:18 <Cale> weitzman: yes, but not as many
20:31:32 <Cale> mutable state itself is an abstraction, but it's one which comes with a fairly heavy price
20:33:07 <Cale> It does let you decompose programs in some new ways, but it also comes with a lot of pitfalls in the form of additional ways in which bugs can be introduced, the additional notions of identity and aliasing, and the need to consider time.
20:33:26 <Korollar1> What does mutable state abstract over?
20:33:49 <Korollar1> or pure functions for that matter
20:34:17 <weitzman> I can write a module that uses mutable state but still has well-defined semantics for what it does when you send it various messages in various orders
20:34:36 <Cale> Korollary: in each case, the specific examples of those things :)
20:34:53 <Korollary> I don't see it.
20:36:20 <weitzman> In software, usually by "abstraction" we mean some kind of interface with a contract
20:36:21 <Cale> Well, you might have a bank account which has a value in it, the amount of money currently available.
20:36:43 <Cale> That's a specific example of a state variable, which is expected to change over time.
20:38:45 <Cale> The function square, which squares an integer is a good example of a pure function. The idea of allowing these things to be constructed and named which take values and produce other values based entirely on the input.
20:39:20 <Cale> Er, that wasn't a sentence. The idea of allowing these things to be constructed and named which take values and produce other values based entirely on the input, is the abstraction of pure functions.
20:40:11 <Cale> The idea of allowing these things to be constructed and named which have a value that may change over time is the abstraction of state variables.
20:41:23 <Cale> There are lots of things which we can describe as state variables and as pure functions in the ordinary world.
20:43:17 <weitzman> I think the argument in favor of pure functions would ultimately boil down to this: It's easier to formally reason about pure functions
20:43:24 <Cale> indeed
20:43:33 <Cale> That's mostly it.
20:43:36 <weitzman> But "it's easier to formally reason about" doesn't seem like a bulletproof argument to me
20:43:54 <weitzman> Particularly if you're writing code to solve an actual real-world problem
20:43:57 <int-e> it's true but it's still hard :)
20:44:13 <Cale> This isn't a cut-and-dried problem
20:44:28 <weitzman> Industry seems perfectly happy with buggy software
20:44:37 <Cale> There are cases where you have state and you really need to work with it.
20:44:44 <Cale> In fundamental ways, even
20:45:11 <Cale> So in Haskell, we have various monads -- IO deals with most of the really fundamental state problems.
20:45:35 <weitzman> Plus, despite all the potential theoretical problems that might come up, programmers don't actually clobber state for no reason when they can help it
20:46:34 <Cale> Well, I think that arguing that bugs associated with state are not a problem is not the way to argue there
20:46:54 <Cale> The bugs associated with state *are* a problem, but sometimes, you really still want state.
20:47:17 <dibblego> I don't see it like that
20:47:24 <weitzman> I naively believe that programmers are well-intentioned, and that abstractions are just a tool we use to help them reason organize and reason about their work
20:47:30 <dibblego> you want "to observe it as if it were state for convenience"
20:47:56 * weitzman removes the extra word from his last sentence
20:48:57 <dibblego> we observe the universe changing "state" for convenience - really it is time that provides this illusion for us
20:49:06 <glguy_> requiring programmers to explicitly define the tubes that their state flows through helps prevent them from making terrible structural decisions easily ;)
20:49:22 <weitzman> The other day in my compiler course, as we were discussing a typing system for modules, my professor made the following observation:
20:49:53 <weitzman> "We use modules because all other programmers write bad code, and we want to protect our great code from their bad code"
20:50:19 <dibblego> so true
20:50:34 <dibblego> s/protect/isolate
20:51:19 <Cale> Yes, and as an extension of that, to be able to make statements about the module as a whole which would be impossible to make internally to the module.
20:51:29 <weitzman> But assuming all other programmers didn't write crappy code, we wouldn't need modules
20:51:32 <Botty> I thought we used modules to export only certain functions
20:51:39 <Botty> ;P
20:51:41 <Cale> Botty: and this is why :)
20:52:26 <weitzman> It's like the communist utopia of code
20:52:28 <glguy_> information-hiding
20:52:31 <weitzman> Nobody owns the code. No boundaries
20:53:02 <Cale> For example, if I have a module, and I create a datatype, and I don't export the constructor, but instead only export carefully constructed ways of building values of my type, I might be able to prove various assertions about every constructible value of the type, from outside the module, which I can't prove in the presence of that all-purpose constructor.
20:53:41 <weitzman> That's just a convenience issue, though
20:53:59 <weitzman> You could theoretically prove the correctness of a Turing-machine that parses XML
20:54:03 <Cale> I think it's more than just convenience.
20:54:03 <weitzman> I just wouldn't recommend it...
20:54:41 <Cale> Well, in a sense, programming at all is a convenience.
20:54:45 <Botty> I think the main reason we use modules is to nicely divide up code into logical groupings so we can reason about it
20:54:50 <dolio> That kind of thing is important for FPS, isn't it?
20:55:10 <Cale> Botty: well, there's that, and there's the hiding issue, and they are sort of orthogonal
20:55:22 <Botty> yes
20:55:23 <Cale> But we've happened to put them together
20:55:54 <Botty> also no discussion of modules is complete without a mention of reuse :P
20:56:27 <int-e> There's also the fact that with a module done we can forget about most of its intricate details and move on.
20:56:43 <glguy_> before you can have re-use you must have use
20:57:00 <weitzman> But it all comes down to human convenience: "reuse" "reason about" "We can forget ... details"
20:57:13 <int-e> sure. humans are not perfect.
20:57:15 <Cale> weitzman: that's all that anything in programming comes down to
20:57:28 <weitzman> And I would not hold it against anyone if they used state, wrote a working program, and could reason about it
20:57:34 <glguy_> programming is an admission that we are not perfect :)
20:57:43 <Cale> because we could just build the chips in the first place to do the jobs we wanted
20:57:51 <Cale> and programming is just a convenience
20:58:03 <glguy_> or a hobby?
20:58:38 <weitzman> In the framework of programming-as-convenience, I think you would have to argue that Haskell is more convenient than OCaml, not that it's abstractly "better"
20:58:47 <weitzman> And that's a completely different argument
20:58:50 <Botty> programming languages are certainly convenience - we could be flipping toggles
20:59:25 <weitzman> Java++
20:59:32 <Cale> Well, what makes a programming language "better"? I don't think that anyone here has claimed that Haskell is better than O'Caml yet.
20:59:37 <weitzman> My karma may fall, but I still like Java
20:59:44 <glguy_> Haskell is better than O'Caml
20:59:55 <Botty> weitzman - sure.  we had this issue when discussing 'better' .net languages.  C# people would say "how can your language be better? It compiles to IL its the same thing only different syntax"
21:00:15 <Cale> It doesn't mean too much on its own, you need to have a context which says what "better" means.
21:00:19 <weitzman> Well, dibblego was trying to argue in favor of referential transparency
21:00:33 <int-e> If Haskell were perfect it wouldn't need an FFI.
21:00:33 <dibblego> I think it is an intrinsic property of the universe
21:00:43 <glguy_> C# is "better" than VB.NET... VB.NET makes stupid assumptions and is disgustingly verbose
21:00:43 <Cale> The arguments for and against referential transparency are simple.
21:00:44 <Botty> I think referential transparency is nifty
21:00:47 <glguy_> :-p
21:00:49 <dibblego> it is only the illusion of time that gives us some notion of "changing state"
21:00:56 <int-e> (Lisp's biggest failing, IMHO. CL has a lot of stuff but no FFI)
21:00:57 <Botty> glguy_ - yeah we were discussing Boo
21:01:09 <glguy_> Boo?
21:01:32 <Botty> yep its like the bastard child of C# and python with a bit of secret sauce tossed in
21:02:11 <Botty> horrible name though
21:02:12 <weitzman> I would say that mathematics has a concept of time
21:02:23 <int-e> hmm. "failure"
21:02:24 <weitzman> Thus we categorize algorithms by their complexity
21:02:24 <Cale> Referential transparency makes your language easy to reason and make guarantees about, and it helps programmers avoid wide classes of bugs associated with changing state. The downside is that there are abstractions which you can build with state that you can't build in a referentially transparent system.
21:02:35 <Botty> weitzman - yeah when you use the letter 't'
21:02:40 <dibblego> Cale, I don't agree with that down side
21:02:52 <Botty> complexity is not dependant on time
21:02:54 <Cale> However, there are abstractions which you can build with laziness that you can't build without it.
21:02:57 <dibblego> Cale, the only reason "you can't build" them is because they are flawed
21:03:03 <Cale> dibblego: Not always
21:03:09 <dibblego> Cale, such as?
21:03:20 <Cale> Let's say the network.
21:03:31 <dibblego> that's exactly in favour of my argument
21:03:37 <weitzman> Complexity may not be dependent on seconds, but for example, we don't take uncomputable functions seriously
21:03:43 <weitzman> Because we don't have infinite time
21:03:51 <dibblego> I see no problem with passing the network as a function argument
21:03:55 <weitzman> But you can do some interesting math if you pretend you have infinite time
21:04:06 <Cale> dibblego: so what are your primitives?
21:04:14 <dibblego> Cale, 1 and 0
21:04:17 <Cale> How do you write a character over the network?
21:04:24 <glguy_> 101011010
21:04:26 <dibblego> a sequence of 1 and 0
21:04:30 <Cale> Or establish a connection?
21:04:34 <dibblego> TCP is busted
21:04:34 <glguy_> 11100010
21:05:03 <weitzman> Network protocols already have an inherent concept of time, so at the very least you would need a function in the language to wait and a function to get the time
21:05:13 <dibblego> who even said we need to establish a connection? a flawed protocol called TCP?
21:05:15 <Cale> Well, network connections are things which by their very nature, vary over time
21:05:30 <Cale> Okay, let's use another example
21:05:39 <dibblego> sure, I've been through a list of examples :)
21:05:40 <Cale> The user sits down at the computer and moves the mouse.
21:06:00 <dibblego> no, time moved, the mouse didn't
21:06:12 <weitzman> Now we're getting into some Zen stuff
21:06:14 <dibblego> but ok
21:06:18 <Cale> Both time and the mouse moved.
21:06:19 <glguy_> they both changed?
21:06:22 <Botty> what, can tcp not be implemented in haskell?
21:06:22 <dibblego> no they didn't
21:06:27 <dibblego> only time
21:06:28 <weitzman> If a tree falls in the woods and nobody is there...
21:06:31 <Cale> uh, no
21:06:36 <dibblego> an ant that can only observe the mouse would see no change
21:06:51 <dibblego> a bigger ant that observed the mouse move relative to some frame of reference is another story
21:07:05 <glguy_> whoa, where did this ant come from?
21:07:06 <dibblego> the mouse itself "changed" in time
21:07:17 <dibblego> glguy, all mice have ants within them
21:07:17 <Cale> The definition of "the mouse moved" is that there are a pair of times t and t' such that t is not equal to t' and the mouse position at time t is not the mouse position at time t'.
21:07:44 <dibblego> Cale, that statement has a flaw
21:07:48 <dibblego> tell me the "position"
21:07:49 <Cale> No, it's a definition.
21:07:54 <dibblego> by only referring to the mouse
21:08:06 <dibblego> you cannot
21:08:09 <glguy_> the position of the mouse is not important
21:08:10 <Cale> hm?
21:08:17 <weitzman> It's a fundamental disagreement over whether the mouse changed or the world changed, and it's not a very useful disagreement
21:08:19 <dibblego> glguy, sure it is, space and time are the same thing
21:08:21 <Botty> how the hell did this become a discussion of relativistic principles....
21:08:29 <dibblego> weitzman, I think it is extremely important
21:08:45 <glguy_> mice don't perceive motion, they perceive that the mouse ball rotated, or that the surface underneath changed
21:08:57 <dibblego> glguy, so the frame of reference is the surface underneath
21:09:11 <dibblego> we are now talking about the "mouse" and "the surface underneath"
21:09:12 <Cale> glguy_: some of them anyway :)
21:09:35 <Cale> Okay then
21:09:36 <dibblego> Botty, Galileo is my hero :)
21:09:56 <Cale> The change in the mouse position, sent by the mouse to the computer by a signal is the state variable.
21:10:01 <Cale> Tell me how to remove it.
21:10:15 <Cale> In practical terms.
21:10:35 <dibblego> pass the mouse as a function argument
21:10:45 <Cale> that solves nothing
21:10:47 <glguy_> *practical* terms :)
21:10:50 <dibblego> or its position relative to some frame of reference
21:10:54 <dibblego> that is practical
21:10:59 <dibblego> that is what monads do from what I see
21:11:02 <Cale> what's the type of the mouse, and what are the operations on that type?
21:11:08 <glguy_> how about passing in a function that takes a time and returns the mouse position?
21:11:23 <Cale> glguy: or a lazy list of deltas, sure
21:11:26 <Botty> cool, a language that deals with physical objects! I want to pass my !@#$ through it!
21:11:29 <Cale> this is a practical idea
21:11:34 <dibblego> this all assumes that a mouse is a legitimate hardware device
21:11:35 <Cale> but let me give you an example
21:11:48 <weitzman> On a more practical note: How do Haskell and signals mix anyway?
21:11:49 <dibblego> which I do not necessarily accept
21:11:51 <glguy_> dibblego: mice are in the flawed category like TCP?
21:11:52 <Cale> Suppose we have a system which is supposed to keep track of a bank account.
21:12:01 <dolio> Isn't the canonical example a bank account with two users?
21:12:03 <dibblego> that referential transparency and mice are in contradiction does not necessarily invalidate referential transparency
21:12:06 <Cale> dolio: indeed
21:12:15 <dibblego> glguy, I haven't analysed enough to say
21:12:23 <Cale> People interact with the system, and the bank account's value is correspondingly updated.
21:12:38 <Cale> *One* way to implement it is to use a state variable.
21:13:01 <Cale> We could also use a lazy stream of updates, and corresponding values.
21:13:08 <weitzman> Changing the state variable will get better cache performance than changing the whole world all the time :)
21:13:14 <Cale> However
21:13:23 <Cale> Suppose there are two users of the system
21:13:41 <Botty> frankly, I think the whole "the program is a calculation" paradigm is flawed for most programming tasks.  Then again I just learned haskell
21:13:44 <dibblego> the IO monad is just emulating the passing of the universe as a function argument - of course it's practical
21:13:46 <Cale> and their changes come in as lazy streams
21:13:53 <Cale> and we have to merge those
21:14:00 <Cale> but the merge is not a function
21:14:03 <dibblego> every program is a calculation given the universe as a function argument
21:14:04 <Botty> still, I think it'll just make you bend over backward to fit classical stuff into this idea
21:14:17 <Cale> dibblego: no it isn't
21:14:32 <Cale> dibblego: that's a flawed explanation of what the IO monad is doing
21:14:41 <dibblego> I see no difference
21:15:31 <Botty> I have to admit I'd like to see what the printout of the universe would look like
21:15:37 <Cale> You can't actually implement it that way, is one reason.
21:16:03 <weitzman> Botty: Once you have the printout of the universe, you have to decide whether or not you can use it to tell the future
21:16:28 <weitzman> More deep philosophical questions that programmers probably aren't very interested in
21:16:40 <dibblego> you can't actually implement it in what way?
21:16:43 <Botty> nah, I thought of that one when i was 8 years old
21:16:49 <Cale> A better way to look at it is that a value of type (IO a) is an actual procedure which may run and cause and depend on side effects (but evaluation of the procedure doesn't cause that), before returning a value of type a.
21:17:03 <glguy_> To be clear, what question are you two presently discussing?
21:17:18 <weitzman> Botty: Well, determinism or no determinism is still an issue of debate, what with it being impossible to prove one way or the other
21:17:20 <dibblego> Cale, I think that is not a better way
21:17:38 <Cale> It's fine, because it better reflects what's really going on.
21:17:43 <weitzman> Although quantum physics people might say that the universe obeys probabilistic laws
21:17:44 <Botty> weitzman: yes, i'd prefer determinism because it rules out a god
21:17:45 <dibblego> Cale, to you at least
21:17:57 <weitzman> But then god might be flipping the coin!
21:17:58 <Cale> Well, in any actual implementation
21:17:59 <dibblego> Cale, against, the illusion of time creates a convenient perspective of reality
21:18:25 * weitzman has exited the discussion
21:18:28 <dibblego> *again
21:18:30 <Botty> weitzman - yeah, that's my point.  non-determinism or probability stuff allows the hand of god to play nice with physics
21:18:40 <glguy_> dibblego: do you believe in the time-cube?
21:18:40 <Cale> Time occurs in every model of the universe I tend to use.
21:18:47 <Cale> I don't believe in reality though.
21:18:58 <dibblego> I have to go, sorry, continue another time
21:18:59 <Botty> really now
21:19:24 <glguy_> "Educators are lying bastards.
21:19:24 <glguy_> -1 x -1= +1 is WRONG, it is
21:19:24 <glguy_> academic stupidity and is evil."
21:20:08 <Cale> glguy_: In one sense, I agree with that, and in another, I disagree.
21:20:14 <glguy_> "4 Earth Quadrants simultaneously rotate inside 4 Time Cube Quarters to create 4 - 24 hour days within one Earth rotation. "
21:20:41 <dolio> I've never been able to figure out what the time cube guy thinks his actual theory is.
21:21:21 <dolio> Every time I read it, it sounds like "the earth has 4 time zones," but he obviously thinks it's more important than that.
21:21:24 <glguy_> dolio: never been able to read much further than what I've pasted here
21:21:27 <Cale> When you figure it out, he's not really saying all that much, and the utility of his model is questionable.
21:21:54 <Cale> All he's really claiming is that the Earth has four "sides", in the same way that a box does.
21:22:33 <Cale> Each of these sides will experience 24 hours during one rotation of the Earth, and he considers these to be separate, for some reason.
21:22:36 <glguy_> "6 sides constitutes a sextet -- not a Cube. Teaching that a Cube has '6 sides' with no top & bottom, induces an evil curse that pervades all academic institutions. "
21:23:44 <Cale> Yeah, he doesn't include the top and bottom of the cube as "sides".
21:23:57 <glguy_> duh, consider the word "sides"
21:24:01 <Cale> right
21:24:04 <glguy_> ;)
21:24:28 <glguy_> can't very well be a side if it on the *bottom*, that's a floor!
21:24:58 <glguy_> Cale: If I showed him a cube, and then set it spinning on one of its corners...
21:25:08 <glguy_> do you think his mind would explode?
21:25:27 <Cale> Either that, or he would call you a heathen.
21:25:36 <glguy_> hmmm, quite likely
21:25:37 <Fey> HEATHEN!
21:25:52 <dolio> He'd probably just inform you that you've been educated stupid.
21:26:30 <glguy_> or... what if I took one of his cubes, hid it behind my back... turned it a few times, and asked him to find the "top"
21:26:31 <Cale> So, does the Earth go around the Sun, or the Sun around the Earth?
21:26:40 <glguy_> Cale: neither
21:26:47 <glguy_> Cale: only time changes
21:26:50 <Cale> heh
21:26:52 <Botty> Cale: both
21:26:54 <araujo> There is no time.
21:27:00 <glguy_> there is no spoon
21:27:02 <dolio> The former is easier.
21:27:07 <Cale> This is a good question to ask people
21:27:27 <Cale> Because often the response you'll get is that the Earth goes around the Sun.
21:28:27 <Cale> These are people who wake up every day, and have the Sun pass over their heads, and they obviously have not thought enough about the things they've been told to realise that the opposite might be true in some contexts.
21:28:27 <dolio> Although I guess accounting for the wobbling of the sun might be a pain.
21:29:15 <glguy_> Hmmm, I thought that the Earth revolved around *me*
21:29:20 <glguy_> and that the sun did too
21:29:39 <glguy_> and that it does so because I wait for it to
21:30:06 <wenet> Hey, is there possible someone could help me how to create a generator who gives an Sudoko output (generator -> Sudoku) not IO Sudoko or alike? Thanks in Advance! Haskell newbie.
21:30:06 <Cale> truth is entirely conventional
21:30:27 <Cale> wenet: sure
21:30:28 <glguy_> when in reality, you people are all just components of my irc client
21:30:39 <glguy_> this program is pretty sweet
21:30:54 <Cale> wenet: http://www.haskell.org/haskellwiki/Sudoku -- here are a whole bunch of solvers
21:30:55 <lambdabot> Title: Sudoku - HaskellWiki
21:31:12 <Cale> wenet: you could probably use any one of them to construct a generator
21:31:22 <glguy_> wenet: how about a (StdGen a => a -> Sudoku)
21:31:47 <dolio> ?instances StdGen
21:31:48 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:31:51 <glguy_> or is that StdGen -> Sudoku
21:31:55 <dolio> ?instances RandomGen
21:31:56 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:32:35 <glguy_> data StdGen = StdGen Int Int    -- Imported from System.Random
21:32:39 <Cale> RandomGen is the class, and StdGen the datatype
21:32:45 <glguy_> instance RandomGen StdGen       -- Imported from System.Random
21:33:53 <glguy_> Cale: do you know what dibblego's model is?
21:33:58 <wenet> Thanks, will take a peek at the webpage and thanks everybody else, I will give it a try! But if someone can give me a more specefic answer on how to buld this generator.
21:34:09 <wenet> glguy> no not really...
21:34:42 <Cale> glguy_: no, not really
21:34:58 <wenet> aa, sorry..
21:35:08 <Cale> wenet obviously has a way to tell the next thing which I'm going to say
21:35:22 <wenet> :)
21:35:26 <glguy_> maybe next time we should just accept his assertion that only time matters and find out
21:36:43 <glguy_> the last couple times he's started explaining it he never got past arguing the arrow of time
21:39:48 <Cale> http://www.qwantz.com/
21:39:51 <Cale> ahaha
21:40:24 <dmwit> Check the source for two alternative punch-lines!
21:40:24 <dmwit> =)
21:44:15 <glguy_> when he said brute-force
21:44:24 <glguy_> I figured he meant since he was a dinosaur
21:44:40 <glguy_> that he could bully the person to declare him intelligent ;)
21:45:06 <dmwit> RAWR!!
21:45:13 <dmwit> Am I intelligent now?
21:45:15 <dmwit> =D
21:45:41 <Botty> I've always thought the dinosaur in the last frame of the comic needs to take a piss really bad
21:46:04 <Botty> and its a female dino :P
21:46:43 <glguy_> and what's at the edge of those limits? ... A place where owls rule the world like they don't even care?
21:48:05 <moconnor> Can someone take a look at my haskell program?  It takes 4hrs to finish but the Ruby version takes about 2mins.  I'm just learning Haskell so I'm not sure where I've gone wrong, 4 hrs vs 2 mins seems wrong to me.  http://www.rafb.net/paste/results/ddavSJ51.html
21:48:22 <glguy_> I'm impressed that you waited 4 hours
21:48:44 <glguy_> it reminds me of when people would bring their computers in for repair and tell me that it took "2 days" to boot up
21:48:53 <glguy_> I could never imagine waiting that long
21:49:12 <glguy_> this looks like a project euler problem
21:49:25 <moconnor> glguy_: I went to dinner :)
21:49:28 <dolio> :) When I first solved 127 on mathschallenge, I just set it to run and went to bed.
21:49:34 <dolio> It took like 2 hours.
21:49:40 <sjanssen> moconnor: did the program gobble up lots of memory as it ran?
21:49:41 <glguy_> shameful! ;)
21:49:46 <moconnor> sjanssen: yes it does
21:50:36 <glguy_> moconnor: is this problem 23?
21:50:43 <moconnor> problem 23 of what?
21:50:49 <moconnor> I got this from Ruby Quiz.
21:50:54 <glguy_> oh,ok
21:51:15 <moconnor> http://www.rubyquiz.com/quiz57.html
21:51:17 <lambdabot> Title: Ruby Quiz - Weird Numbers (#57)
21:51:24 <glguy_> your divisors code is probably pretty slow
21:51:45 <moconnor> glguy_: the real slow down is in semiperfect_p
21:51:52 <glguy_> nub on a large list is slow
21:51:55 <sjanssen> moconnor: is this the exact same algorithm as the Ruby version?
21:52:40 <moconnor> That list I'm running nub and filter on would grow to 2^31 in the worst case, which is why I try to knock it down
21:52:50 <moconnor> sjanssen: it's the best I could do given my knowledge of Haskell.
21:52:57 <moconnor> sjanssen: IOW, I tried to make it the same.
21:53:05 <moconnor> sjanssen: But this is my 1st Haskell program.
21:53:48 <moconnor> sjanssen: So in semiperfect_p I have a helper function "sp" in which I pass a list of sums.  That plays the role that the sums hash does in the Ruby version (which is linked to from the Haskell code)
21:54:29 <sjanssen> moconnor: using a list instead of a sum could very well be a problem
21:54:36 <Cale> The code spends 95% of the time in semiperfect_p
21:54:49 <Cale> and 62% of the allocation happens there
21:55:04 <moconnor> sjanssen: It's a list of sums.  Not a signle sum.  Perhaps I wasn't clear.
21:55:12 <Cale> let me add some SCCs
21:55:19 <moconnor> Cale: What's an SCC?
21:55:19 <hyrax42> SCC?
21:55:29 <Cale> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/profiling.html
21:55:32 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/qtwbd
21:55:37 <glguy_> every time you call is_sp you have to rebuild the ext_sums list
21:55:56 <Cale> It's a cost centre annotation
21:57:24 <glguy_> infact, I don't quite see why you need to call nub at all
21:57:30 <glguy_> since all you are doing with the result is calling any on it
21:57:33 <moconnor> My first version of this program was much much slower.  The truly naive version of semiperfect_p takes the powerset of a list of divisors and then does a sum on every list and checks if the sum == n.  Which was very bad, I couldn't even test the first 1000 numbers.
21:57:45 <Cale> yep ext_sums is the problem
21:58:06 <Cale> 95% of the time is actually in ext_sums in particular
21:58:10 <moconnor> glguy_: I called nub solely to get the uniqueifying effect of hashes, to bring it closer to the Ruby version.
21:58:18 <moconnor> glguy_: thinking that might be why the Ruby version was faster
21:58:28 <glguy_> map head . group . sort is definitely better than nub
21:58:38 <glguy_> I don't know if there is an even better way to express that
21:59:20 <sjanssen> glguy_'s suggestion of using sort halfs the execution time for weird 1000
21:59:42 <glguy_> sjanssen: what if you don't use sort or nub
21:59:44 <Cale> Where is sums changing here?
22:00:10 <Cale> everything just passes sums along
22:00:16 <Fey> I have an instance arbitrary set up and it is working. I do however not fully understand how to use it. Could anyone help me out here with the syntax I should have in order to get an instance?
22:00:18 <moconnor> Cale: I had a version where I had "map (+ x) sums" in place of "ext_sums x sums" everywhere and it was even slower.  The nub $ filter (<= n) or just to try and knock out excess list elements, since in that list grows exponentially by the number of divisors of n.
22:00:19 <glguy_> last line of sp
22:00:20 <Cale> so it might as well not be a parameter
22:00:39 <glguy_> cale what about sp xs $ sums ++ (ext_sums x sums)
22:00:52 <moconnor> Cale: "sums ++ (ext_sums x sums)"
22:00:54 <sjanssen> glguy_: that is much slower
22:00:55 <Cale> ah, I see
22:00:58 <Cale> yeah
22:01:26 <Cale> first of all, accumulation is bad if you can avoid it
22:02:24 <Cale> semiperfect_p n = any (== n) (map sum) (combinations (divisors n))
22:02:35 <Cale> er
22:02:49 <sjanssen> is it safe to make everything Int instead of Integer here?
22:02:50 <Cale> semiperfect_p n = any (== n) . map sum . combinations $ divisors n
22:03:18 <moconnor> combinations is part of Haskell?
22:03:27 <glguy_> where combinations is filterM (const [True,False]) ?
22:03:33 <Cale> combinations [] = [[]]
22:03:34 <Cale> combinations (x:xs) = combinations xs ++ map (x:) combinations xs
22:03:55 <moconnor> that's just powerset
22:04:04 <moconnor> That was the first thing I tried.
22:04:15 <Cale> er, blah
22:04:19 <Cale> combinations (x:xs) = combinations xs ++ map (x:) (combinations xs)
22:04:20 <sjanssen> very slight speedup moving from Integer to Int
22:04:44 <Cale> this provides a relatively dramatic speedup
22:05:04 <Cale> my rewrite/simplification
22:05:04 <moconnor> jesus
22:05:11 <moconnor> I must've done something wrong with my powerset, you're right.
22:05:27 <Cale> I'm already at 7912 after about 30 seconds
22:05:33 <glguy_> > let combinations xs = [] : [a:b | (a:as) <- tails xs, b <- as] in combinations [1..3] -- does this work?
22:05:34 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
22:05:34 <lambdabot>    Expected...
22:05:44 <Cale> 9272
22:05:46 <Cale> done
22:05:48 <Cale> okay
22:05:55 <Cale> so that's one way :)
22:05:59 <glguy_> > let combinations xs = [] : [a:b | (a:as) <- tails xs, b <- combinations as] in combinations [1..3] -- does this work?
22:06:00 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
22:06:03 <Cale> write it so that it's obvious what it does :)
22:06:33 <moconnor> my original version of semiperfect_p was:
22:06:34 <moconnor> semiperfect_p n = length (filter (== n) divisor_sums) > 0
22:06:34 <moconnor>     where divisor_sums = map sum (powerset $ divisors n)
22:06:34 <glguy_> Cale: I like it that way because there is no appending
22:06:42 <moconnor> with:
22:06:42 <moconnor> powerset [] = [[]]
22:06:42 <moconnor> powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
22:06:50 <Cale> > filterM (const [False, True]) [1,2,3]
22:06:51 <dolio> Having combinations just compute the sums rather than the actual lists might be faster.
22:06:52 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
22:07:05 <dolio> If you're just using the sums.
22:07:11 <dolio> For big sets, at least.
22:07:15 <Cale> moconnor: length is bad
22:07:23 <Cale> moconnor: you'll force the whole list that way
22:07:49 <Cale> moconnor: not . null . filter (== n) $ divisor_sums
22:07:55 <Cale> would be faster
22:08:06 <sjanssen> after incorporating Cale's changes we've gone from 8 sec. to 0.13 sec.
22:08:09 <Cale> because null only has to find one element to return false
22:08:28 <glguy_> > let combinations xs = 0 : [a+b | (a:as) <- tails xs, b <- f as] in f [1..3] -- does this work?
22:08:29 <lambdabot>  Not in scope: `f'
22:08:41 <glguy_> > let f xs = 0 : [a+b | (a:as) <- tails xs, b <- f as] in f [1..3]
22:08:42 <lambdabot>  [0,1,3,6,4,2,5,3]
22:08:59 <Cale> > let combinations = filterM (const [False, True]) in combinations [1,2,3]
22:09:00 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
22:09:29 <Cale> > let combinations = filterM (const [False, True]) in map sum (combinations [1,2,3])
22:09:30 <moconnor> Cale: So what's the take away from this (your final solution)?  I kind of feel cheated in that what appear to be a few minor alterations result in a huge speed up.  I'm not quite groking the underlying mechanics as to what is slow and what is fast.  Is that something you can relate?
22:09:30 <lambdabot>  [0,3,2,5,1,4,3,6]
22:09:44 <Cale> moconnor: think in terms of demand
22:09:57 <Cale> and do profiling to find what's bad
22:10:15 <Cale> How do you compute the length of the list?
22:10:31 <moconnor> You look at every element and count them.
22:10:31 <Cale> Well, you have to build all the conses in it
22:10:34 <Cale> right
22:10:51 <glguy_> > map sum $ mapM (\x -> [0,x]) [1..3]
22:10:52 <lambdabot>  [0,3,2,5,1,4,3,6]
22:10:59 <Cale> you don't necessarily look at the elements themselves, but in some cases, you'll be forced to, in order to build the rest of the list
22:11:15 <ThreeQ> @pl (\x -> [0,x])
22:11:16 <lambdabot> (0 :) . return
22:11:16 <Cale> but in any event, you're going to take O(n) time
22:11:18 <sjanssen> weird 10000 takes 65 seconds to complete on my computer
22:11:33 <glguy_> > any ((3==) . sum) $ mapM (\x -> [0,x]) [1..3]
22:11:34 <lambdabot>  True
22:11:43 <Cale> if you write
22:11:47 <Cale> length xs > 0
22:11:53 <Cale> to determine if xs is empty or not
22:12:00 <Cale> which is bad
22:12:00 <glguy_> shock!horror!
22:12:15 <Cale> This is because integers themselves are not decomposable
22:12:24 <Cale> I can't stop after the first (+1)
22:12:47 <Cale> because I don't really know that the end result will be greater than 0
22:12:58 <Cale> so what we do is use null
22:13:01 <Cale> null [] = True
22:13:06 <Fey> I am having some difficulty using my arbitrary class. I have it working, but I do not know how the proper syntax goes to generate an instance. Can anyone help me with the syntax?
22:13:09 <Cale> null (_:_) = False
22:13:20 <moconnor> Cale: so your solution only computed as much of the list as it needed until (== n) was true?  Rather than computing the whole list just so I could see if it was empty or not (by doing an O(n) iteration over it).
22:13:24 <Cale> This doesn't force the whole list to be built
22:13:30 <Cale> right
22:13:39 <Cale> the other thing I did, the more major change
22:13:51 <sjanssen> Fey: instance MyClass MyType where myMethod = foo
22:14:01 <Cale> was to replace your semiperfect_p with something easier to understand the performance of
22:14:17 <Cale> any (==n) will bail out at the first sign of true
22:14:31 <Cale> map sum has predictable performance
22:14:58 <Cale> and combinations is a fast generator of combinations, though there are exponentially many of them, getting the first few is fast
22:15:27 <Cale> so if there is an n, and it happens to be close to the start of the list, this will terminate quickly
22:15:54 <Cale> and we know it doesn't use lots and lots of memory
22:15:57 <Fey> sjanssen: I have the instance set up. I can get something out by using (arbitrary::Gen x) but I cannot seem to get anything useful out. That is, I cannot get a generated type out of it. Its merely because I do not know how to use the arbitrary instance
22:16:11 <Cale> because what do we have to keep track of?
22:16:23 <Cale> well, the position in the list of divisors
22:16:52 <Cale> after each sum is tested, it's thrown away
22:17:13 <moconnor> Cale: thanks so much for looking at that for me and then explaining it.  I was really stuck in a different head frame.  What you're saying makes much sense.
22:18:08 <moconnor> Cale: I was seeing powerset and saying, "Oh that is is always 2^N" but it doesn't build the whole list and suck it into memory at once the way it would in Ruby.  So I ditched that method and cooked up the monster I pasted.
22:18:28 <moconnor> not realizing what was really happening.
22:18:33 <Cale> right, lists *are* loops :)
22:18:55 <sjanssen> Fey: look at the docs for Test.QuickCheck, especially generate
22:19:05 <Fey> okay. Thanks
22:19:08 <moconnor> Cale: thanks so much!
22:19:15 <Cale> no problem
22:20:54 <Cale> g'night all
22:38:36 <hyrax42> @type filterM
22:38:38 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:44:00 <hyrax42> @fptools Control.Monad
22:44:01 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
22:53:24 <Botty> hah, why is either left or right? seems like bringing in needless terminology.  its rather confusing i'd say
22:54:05 <Botty> actually, I don't know why you'd use either rather than bool
22:55:36 <sjanssen> Botty: how do you express "Either String Int" with a Bool?
22:57:07 <Botty> oh, well I guess i didn't understand what it did
22:57:14 <Botty> nevermind then
22:57:23 <Botty> what's teh difference with pairs then?
22:57:31 <Botty> how about a pair and a bool
22:58:21 <sjanssen> you could simulate Either with a pair and a Bool, but that's a bit hackish
22:58:29 <Botty> alright
23:00:12 <Fey> alrght, i'm off. Thanks alot for the help guys
23:00:35 <weitzman> > let uniqueCombinations [] = []; uniqueCombinations (x:xs) = (map ((,) x) xs) ++ (uniqueCombinations xs) in uniqueCombinations [1,2,3,4]
23:00:36 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
23:00:49 <weitzman> Is there some clever way to do that with the list monad or something?
23:02:57 <glguy> weitzman, unique pairs?
23:03:32 <weitzman> Indeed
23:03:52 <glguy> > [(a,b) | (a:as) <- tails [1..4], b <- as] -- might work
23:03:53 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
23:03:57 <weitzman> I wrote that function earlier, but Cale's clever code to list all subsets made me curious
23:05:10 <glguy> > (init . tails) [1..4] >>= \as -> tail as >>= \b -> return (a,b)
23:05:11 <lambdabot>  Not in scope: `a'
23:05:11 <mwc> anybody done a speed test between Happy and Parsec?
23:05:13 <weitzman> [a | (a:b:_) <- []]
23:05:18 <weitzman> > [a | (a:b:_) <- []]
23:05:20 <lambdabot>  Add a type signature
23:05:26 <weitzman> > [a | (a:b:_) <- []] :: [Int]
23:05:26 <glguy> > (init . tails) [1..4] >>= \as -> tail as >>= \b -> return (head as,b)
23:05:27 <lambdabot>  []
23:05:28 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
23:05:30 <weitzman> Interesting
23:06:13 <weitzman> Except it's not just for number
23:06:15 <weitzman> *s
23:06:36 <weitzman> Given [a, b, c, d] -> [(a, b), (a, c), ...]
23:06:57 <weitzman> Specifically, I was enumerating all pairs of squares within some area in a game board
23:08:48 <weitzman> And then feeding a massive expression to a SAT-solver
23:09:27 <weitzman> The world has one more Sudoku solver :)
23:09:42 <mwc> Sat?
23:10:04 <weitzman> Boolean satisfiability solver
23:10:13 <weitzman> For propositional logic statements
23:10:39 <glguy> the general case is NP-complete
23:11:08 <weitzman> As luck would have it, the worst-case does not reflect the case in many real-world applications
23:11:52 <weitzman> Current SAT-solvers can handle hundreds of thousands to millions of variables and clauses in conjunctive normal form
23:12:21 <weitzman> Except on really nasty problems, like NP-complete ones
23:12:34 <glguy> ?
23:12:44 <glguy> the SAT problem itself is NP-Complete
23:12:55 <weitzman> True, but that's a worst-case bound
23:13:05 <glguy> no, it's the class of problem that it is
23:13:07 <weitzman> Actual performance depends on the characteristics of the input
23:13:09 <glguy> it isn'ta bound
23:13:22 <weitzman> Well, ok. The worst case performance is exponential
23:13:27 <glguy> yeah
23:15:11 <cybercobra> what's the 'null' value in Haskell?
23:15:23 <glguy> cybercobra, in what context?
23:15:37 <weitzman> I'm generating about 12,000 clauses with 800-ish variables, and the solver finishes in very few milliseconds
23:15:43 <cybercobra> glguy: value meaning the lack of any meaningful value
23:15:44 <Botty> hehe, for a split second I thought you guys were talking about an NP-Complete SAT problem.  that would suck!
23:15:54 <glguy> Maybe is often used to represent a computation that can fail to return a value
23:16:17 <ThreeQ> mzero is the closest thing to null I can think of
23:16:23 <cybercobra> glguy: eh, nm.
23:16:55 <ThreeQ> > mzero::[Int]
23:16:55 <glguy> Botty, the SAT-problem *is* NP-Complete
23:16:56 <lambdabot>  []
23:17:01 <ThreeQ> > mzero::Maybe Int
23:17:03 <lambdabot>  Nothing
23:17:26 <weitzman> My favorite sat problem is 2-CNF
23:17:44 <weitzman> That one's much easier to solve than most of the others
23:18:06 <Botty> glguy - well, to me the acronym SAT means Standardized Assessment Test, or the thing you take in the US to get into colleges
23:18:30 <weitzman> Strange out allowing one more variable in each clauses causes you to go from linear-time to exponential
23:18:30 <Botty> so it'd be rather mean if there was an NP-Complete problem on there
23:18:37 <weitzman> s/out/how
23:18:56 <cybercobra> Botty: actually, SAT the test isn't an acronym anymore
23:19:09 <mwc> Botty, I was thinking they were designnig a general SAT solving algorithm, for the test :)
23:19:19 <Botty> haha
23:19:24 <Botty> cybercobra: really
23:19:59 <weitzman> If you like programming contests, you could write a SAT-solver in Haskell and enter it in the international contest
23:19:59 <skew> weitzman: like changing your geometry from right-angled squares to right-angled pentagons makes NP problems solvable with a computer of polynomial radius.
23:20:05 <weitzman> Usually the entries are in C++
23:20:31 <cybercobra> Botty: "...formerly called the Scholastic Aptitude Test and Scholastic Assessment Test"
23:20:31 <mwc> skew, right angled pentagons?
23:21:07 <Botty> cybercobra - oh, well i guess i got the acronym wrong.  They should have a question about that in it
23:21:23 <skew> mwc: in hyperbolic geometry
23:21:35 <Botty> weitzman - that could be pretty challenging.  Especially on the Verbal section
23:21:36 <mwc> ahhhh
23:22:03 <weitzman> http://www.satcompetition.org/ <- The current champion is open source, so the ground is level if you want to try to beat it next year
23:22:07 <lambdabot> Title: SAT Competitions
23:22:45 <mwc> well, as soon as we get a space-time transgeometrificator running, we'll be able to beat those stupid quantum computers
23:23:52 <cybercobra> or we can just destroy the universe, thus making all problems irrelevant ;-)
23:24:41 <Botty> that'd be pretty funny if a haskell-based AI decided that.  A minor fault into the computation by calculation thing, eh?
23:25:46 <Botty> hehe, the AI finally finds the way to come to an end result....
23:25:49 <Botty> ;)
23:27:57 <Botty> would make more sense for a prolog based AI maybe
23:33:18 <skew> has anyone here read about "PMC" on the Haskell list?
23:33:49 <skew> It looks pretty nice, I'm writing up some alternate syntax proposals
23:36:34 <skew> You know, if we want to get more Haskell users, could we possibly arrange that Perl 6 \subseteq Haskell', say as a very wierd DSEL?
23:45:00 <dolio> Losing \x y z -> ... would probably rub people the wrong way.
23:46:21 <skew> That's one big change I suggest
23:46:45 <skew> actually, I think it cleans things up a bit to use space to separate succesive patterns and -> to introduce a result
23:47:20 <skew> otherwise, -> X is sometimes like the -> X from the calculus in the papers, an sometimes like -> lift (X)
23:47:53 <Botty> I always get caught doing a = instead of -> in those
23:48:10 <weitzman> I definitely prefer the Haskell syntax for lambdas over all other equivalent syntax I've encountered. Small enough to stay out of the way
23:48:49 <dolio> I didn't read the proposal in detail yet.
23:48:54 * edwardk waves hello.
23:48:59 <skew> hi
23:49:08 <dolio> One nice thing in there is multi-line lambdas. I've heard people request those before.
23:49:16 <dolio> Or, potentially nice, at least.
23:49:33 <edwardk> i always forget how exhausting a desktop linux install can be
23:50:36 <weitzman> (fn args => impl) isn't so bad in SML, except it can't handle curried functions
23:50:57 <skew> mult-line lambda might be nice. Using layout for the cases of a top-level definition seems like a really good idea
23:50:59 <weitzman> SML makes me so sad. It's extremely close to being a usable language
23:51:42 <skew> It's pretty annoying repeating the name of a function
23:52:23 <mwc> what's a multiline lambda? Don't existing layout rules a;;pw ot
23:52:26 <mwc> *allow it
23:52:40 <mwc> gotta hate it when your right hand transposes over one key width
23:52:52 <weitzman> O
23:53:01 <weitzman> , sire [ep[;e cam read ot of tjeu tru
23:53:01 <dolio> It'd be a lambda that does multiple pattern matching based on layout.
23:53:12 <dolio> Rather than \x -> case x of ...
23:53:57 <mwc> ahhhh
23:55:08 <dolio> So you could do something crazy like: fact = y $ \{_ 0 -> 1 ; f n -> n * f (n-1) }
23:55:58 <mwc> that makes me cry
23:56:03 <dolio> :)
23:56:14 <dolio> I don't know how useful it'd be in practice.
23:56:29 <skew> how about allowing that at the top level, like fact {0 = 1; n = n * fact (n-1)}
23:56:48 <skew> so you can just indent argument lists rather than retyping the function name
23:57:41 <mwc> I think that would have layout issues
23:57:48 <mwc> foo [] y = ...
23:57:54 <mwc>     x [] = ...
23:58:02 <mwc> I think that second line is tacked onto the first
23:58:45 <skew> yeah, I'm suggestiong that the function name in a top-level declaration could introduce a layout group
23:59:00 <skew> it doesn't work so well for defining infix functions.
23:59:05 <mwc> Hmm, I'd think that would make the lexer require feedback from the parser.
23:59:22 <mwc> and that makes me angry
23:59:41 <skew> no, it just needs to realize it's seeing an identifier at the outermost layout level
23:59:52 <mwc> Hmmmmm...
