00:00:01 <lispy> satan: so you need to call foldr with a function (a -> [a] -> [a]) in order to get foldr to give you a list
00:00:18 <satan> right, fair enough
00:00:24 <satan> i did try, but it didnt work
00:00:42 <lispy> but i think i made a mistake
00:00:48 <lispy> ?type foldr
00:00:50 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
00:00:55 <lispy> hmm...no
00:01:32 <lispy> > foldr (const id)  [1..10] [2..20]
00:01:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
00:02:26 <satan> so my function should take an element and a list and check if the element is the head of the list, then return the list minus that head, if it is
00:02:33 <lispy> > foldr (\x y -> [y]) [1..10] 0
00:02:34 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
00:02:34 <lambdabot>    Expected...
00:03:26 <lispy> satan: i'm not sure how to solve this
00:03:38 <satan> oh ok
00:03:51 <satan> i've been trying to approach it in a logical fashion heh
00:04:24 <satan> remdups = foldr f [] where f = \x xs -> if x == head xs then x: reverse (init (reverse xs)) else x:xs
00:04:36 <lispy> > foldr (\x y -> if x `elem` y then [] else [x]) [1..10] [2..20]
00:04:38 <lambdabot>  [2]
00:04:47 <satan> that was my attempt but it doesnt run, gives me an exception for not having checked for the empty list
00:05:27 <lispy> > folder (\x y -> (x:))
00:05:28 <lambdabot>  Not in scope: `folder'
00:05:33 <lispy> > foldr (\x y -> (x:))
00:05:34 <lambdabot>  Add a type signature
00:05:40 <lispy> er
00:05:55 <lispy> ?type foldr (\x y -> (x:))
00:05:56 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a] -> [a]
00:06:11 <lispy> satan: so that's anoher way to get a list that i didn't think of before
00:06:36 <satan> right, just slap on x to the head of the list
00:08:06 <lispy> > foldr (\x y -> (x:)) id [1..10] [2..20]
00:08:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
00:08:48 <lispy> > foldr (\x y -> (x:)) id [1..10] [1..10]
00:08:50 <lambdabot>  [1,1,2,3,4,5,6,7,8,9,10]
00:09:04 <satan> hmmm
00:09:17 <albertlee> i have a task to build a database fulltext index & search program , should I try haskell or lucene?
00:09:32 <lispy> > foldr (\x y -> if x `elem` y then (y:) else (x:y:)) id [1..10] [1..10]
00:09:33 <lambdabot>    The operator `:' [infixr 5] of a section
00:09:33 <lambdabot>     must have lower precede...
00:09:39 <thou> albertlee: i think you'll have a hard time beating lucene
00:09:46 <skew> albertlee: what about both?
00:09:50 <thou> albertlee: nothing to do w/ Java vs. Haskell...
00:09:59 <skew> oh, lucene is Java?
00:10:00 <thou> but yes, you could call lucene from haskell
00:10:12 <thou> yeah
00:10:21 <lispy> > foldr (\x y -> if x `elem` y then (y) else (x:y)) id [1..10] [1..10]
00:10:22 <thou> but you could still glue it together
00:10:22 <lambdabot>  Couldn't match `[a]' against `t -> t1'
00:10:27 <thou> somehow
00:10:42 <thou> but lucene rocks, it's really a sweet piece of software
00:11:10 <skew> A C version might be easier to interface. Perhaps Ferret?
00:11:27 <thou> maybe lucene is being ported to C
00:11:33 <albertlee> my boss dont want java run on the server
00:11:34 <thou> haven't looked for a while
00:11:41 <thou> yeah, there's that
00:11:44 <workbean> I've seen a few projects to port it to C. Not very active though.
00:11:53 <skew> well, then you probably can't run Lucene - except maybe if you build with gcj?
00:11:54 <albertlee> and a lib named Xapian
00:12:43 <workbean> that's what the chandler guys did
00:13:39 <satan> lispy: i'm still trying here :)
00:14:34 <lispy> satan: yeah, i'm not sure what to tell you
00:14:58 <satan> yeah no worries dude, thanks for trying
00:15:10 <satan> i'm just learning myself, are you new to this too?
00:15:32 <lispy> satan: been using haskell a while, but this puzzle is new to me
00:15:46 <satan> the book is called 'Introduction to Functional Programming using Haskell' if you want to try solving similar problems heh
00:16:02 <satan> really eh...hmm ok maybe i'm not that bad after all :)
00:16:52 <lispy> > foldr (\x y -> if x `elem` (tail y) then (tail y) else (x:y)) [1..10] [1..10]
00:16:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
00:17:34 <lispy> > foldr (\x y -> if x `elem` (tail y) then (tail y) else (x:y)) [1,1,2,2,3,4,4,4,5,6,7,8,9,10] [1,1,2,2,3,4,4,4,5,6,7,8,9,10]
00:17:35 <lambdabot>  [1,1,2,2,3,4,5,6,7,8,9,10]
00:17:56 <Cale> satan: what are you working on?
00:17:59 <lispy> satan: seems that was a bit closer maybe?
00:18:09 <satan> that's generating it, i guess
00:18:12 <lispy> Cale: use foldr to remove adjacent duplicates
00:18:28 <satan> Cale: eliminating adjacent duplicates using foldr or foldl
00:18:46 <satan> so remdups [1,2,2,3,3,3,1] = [1,2,3,1]
00:19:08 <lispy> > foldr (\x y -> if x `elem` y then y else (x:y)) [1,1,2,2,3,4,4,4,5,6,7,8,9,10] [1,1,2,2,3,4,4,4,5,6,7,8,9,10]
00:19:09 <lambdabot>  [1,1,2,2,3,4,4,4,5,6,7,8,9,10]
00:19:27 <lispy> so i wonder why the tail helps with those 4's
00:19:58 <satan> hmmm
00:20:10 <lispy> > foldr (\x y -> if x `elem` (tail y) then (tail y) else (x:(tail y))) [1,1,2,2,3,4,4,4,5,6,7,8,9,10] [1,1,2,2,3,4,4,4,5,6,7,8,9,10]
00:20:12 <lambdabot>  [1,5,6,7,8,9,10]
00:20:15 <lispy> heh
00:20:27 <lispy> duplicates gone!
00:20:41 <Cale> however
00:20:52 <satan> but they didnt leave one value behind
00:20:54 <Cale> > foldr (\x y -> if x `elem` (tail y) then (tail y) else (x:(tail y))) [1,1,1,2,3,3,2,1,2,3]
00:20:55 <lambdabot>  Add a type signature
00:20:58 <lispy> Cale: for some interpretations of the spec it works :)
00:21:02 <satan> and 1 is still there?
00:21:06 <satan> haha
00:21:38 <Cale> > foldr (\x y -> if x `elem` (tail y) then (tail y) else (x:(tail y))) [1::Int,1,1,2,3,3,2,1,2,3]
00:21:39 <lambdabot>  <[Int] -> [Int]>
00:21:47 <Cale> oh, pasted wrong :)
00:21:51 <Cale> > foldr (\x y -> if x `elem` (tail y) then (tail y) else (x:(tail y))) [] [1,1,1,2,3,3,2,1,2,3]
00:21:53 <lambdabot>  Exception: Prelude.tail: empty list
00:21:59 <satan> thats what i got too
00:22:14 <Cale> > foldr (\x xs -> case xs of [] -> [x]; (y:ys) -> if x == y then xs else x:xs) [] [1,1,1,2,3,3,2,1,2,3]
00:22:15 <lambdabot>  [1,2,3,2,1,2,3]
00:22:36 <goltrpoat> > let catdups x rest = if (rest == []) then return x else if (x == head rest) then rest else (x:rest)
00:22:37 <lambdabot>  Parse error
00:22:53 <goltrpoat> eh?  works in ghci
00:23:03 <satan> hmm that works
00:23:06 <goltrpoat> (foldr catdups [] works)
00:23:42 <satan> Cale: i think mine was close to what you had, but the syntax was all wrong
00:24:06 <satan> if x matches head of y, then skip it and move on, otherwise attach x to y
00:24:22 <satan> thanks :)
00:24:35 <Cale> ooh, the extra Haskell parser must be broken with regard to nested ifs
00:24:50 <goltrpoat> looks like it
00:24:58 <Cale> that's bad
00:25:18 <Cale> @help note
00:25:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:25:25 <Cale> @help messages
00:25:26 <lambdabot> messages. Check your messages.
00:25:34 <Cale> @help message
00:25:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:25:35 <ThreeQ> @help tell
00:25:36 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
00:25:37 <Cale> hmm
00:25:40 <Cale> tell!
00:25:45 <lispy> satan: so one important thing to remember is that looking at the type of foldr got us very close quickly, reasoning from type is helpful :)
00:26:01 <goltrpoat> > let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest)
00:26:02 <lambdabot>  Parse error
00:26:08 <satan> lispy: you're right, i'll remember that, thanks
00:26:11 <Cale> @tell dons The parser in @eval is broken with regard to nested ifs.
00:26:12 <lambdabot> Consider it noted.
00:26:15 <goltrpoat> something's broken there as well
00:26:29 <goltrpoat> if inside case?
00:26:40 <lispy> Cale: better give him some example code
00:26:44 <Cale> oh, no, you didn't finish your let
00:26:55 <goltrpoat> whoa
00:27:01 * lispy goes to sleep
00:27:15 <Cale> let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest) in catdups 1 [1,1,2,3,4]
00:27:20 <Cale> > let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest) in catdups 1 [1,1,2,3,4]
00:27:21 <lambdabot>  [1,1,2,3,4]
00:27:26 <Cale> > let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest) in catdups 1 [21,1,2,3,4]
00:27:28 <lambdabot>  [1,21,1,2,3,4]
00:27:29 <goltrpoat> > let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest) in foldr catdups [1,1,2,3,4,3,3,3,4]
00:27:30 <lambdabot>  Add a type signature
00:27:36 <goltrpoat> > let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest) in foldr catdups [1,1,2,3,4,3,3,3,4] :: [Int]
00:27:38 <lambdabot>    Expecting a function type, but found `[Int]'
00:27:38 <lambdabot>    Expected type: [Int]
00:27:38 <lambdabot> ...
00:27:44 <Cale> @tell dons Ignore that. :)
00:27:44 <lambdabot> Consider it noted.
00:27:45 <goltrpoat> whee.
00:27:57 <goltrpoat> oh crap
00:27:59 <goltrpoat> > let catdups x rest = case rest of [] -> return x; _ -> if (x == head rest) then rest else (x:rest) in foldr catdups [] [1,1,2,3,4,3,3,3,4]
00:28:01 <lambdabot>  [1,2,3,4,3,4]
00:28:13 <goltrpoat> that.. took an inordinate amount of time.
00:29:11 <satan> what does the _ do?
00:29:15 <Cale> The way to look at these things is that you're writing a replacement for cons, which is allowed to look at the element it's 'consing' onto the result and whatever was produced by the rest.
00:29:30 <Cale> satan: match anything, binding no variables
00:29:45 <satan> ah i see
00:29:51 <satan> so, a bit like the _ in Prolog?
00:29:54 <Cale> yeah
00:29:59 <jmob> this reminds me of lisp homework
00:30:36 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
00:30:39 <lambdabot> Title: Fold Diagrams - CaleWiki
00:30:41 <goltrpoat> except _ is just by convention, you could as well say ifSomeOtherValueWeDontCareAbout -> ...
00:31:01 <Cale> no
00:31:07 <Cale> It's actually a special pattern
00:31:25 <satan> wow did you make that, Cale ?
00:31:30 <goltrpoat> hmm.. if the value isn't used, what's the difference?
00:31:31 <Cale> satan: yeah
00:31:37 <Cale> well, sure, you could do that
00:31:40 <satan> thanks to all who helped, lispy , cale and goltrpoat btw
00:31:45 <Cale> but _ is not a variable name
00:31:49 <goltrpoat> oh, right
00:31:59 <satan> it's like a catchall, right?
00:32:03 <Cale> yeah
00:32:15 <Cale> and you can use more than one of them
00:32:35 <Cale> > let f [] = False; f (_:_) = True in f [1,2,3]
00:32:36 <lambdabot>  True
00:33:08 <Cale> This makes it completely obvious that applying f to the list will not evaluate any of its elements
00:33:16 <Cale> Just the top level cons
00:33:21 <Cale> (or nil)
00:33:42 <Cale> > let f [] = False; f (_:_) = True in f (undefined:undefined)
00:33:44 <lambdabot>  True
00:33:51 <satan> right, cause it doesnt care
00:34:02 <satan> but if you were to try to work with the undefined, it'd crash
00:34:07 <Cale> right
00:34:12 <satan> ok cool
00:34:19 <satan> this Bottom stuff is making sense :)
00:34:49 <satan> ok thats enough Haskell for one day for me, i'm out for the night
00:34:49 <Cale> same if you put variables in there like (x:xs) and then not used them, but it's often nice to make that clear by not naming them in the first place
00:35:05 <dmead> boink
00:35:05 <satan> right, easier to read/maintain etc
00:35:21 <Cale> yeah
00:47:51 <roconnor> does -Wall complain about named and unused variables?
00:50:33 <Lemmih> named variables?
00:51:35 <roconnor> \x -> 5
00:51:50 <roconnor> \_ -> 5
00:52:10 <Lemmih> Aren't all variables named per definition?
00:52:34 <roconnor> \_ -> 5 has an anonymous variable. (that's what I would be tempted to call it).
00:52:39 <Lemmih> ('_' isn't a variable, btw)
00:52:47 <roconnor> what is it?
00:52:53 <skew> a pattern
00:52:53 <jmob> A pattern.
00:52:59 <roconnor> oh
00:53:09 <skew> or, a hole in a pattern
00:53:41 <roconnor> sorry
00:53:41 <skew> erlang lets you name them, like \_x -> <body - no x bound>
01:14:19 <aleator> Gah. I'm getting bonked by the gc. Simple task. Read 30 files: each contain key, value maps (2000 elements each), calculate average values for each key. It takes fifteen minute pauses between every 100 keys..
01:19:47 <Elendal> ?slap me
01:19:48 * lambdabot smacks Elendal about with a large trout
01:20:12 <skew> aleator: how?
01:20:15 <dmead> isnt it supposed to be "big large trout"
01:21:03 <Lemmih> ?slap dmead
01:21:03 * lambdabot beats up dmead
01:21:09 <dmead> =p
01:25:37 <aleator> skew: Well, I split lines to words, read to get numbers, stuff the key/value pairs into a list and then do sort-group-average.
01:27:10 <skew> maybe the sort is too big?
01:27:16 <skew> you don't have the keys in order?
01:27:46 <aleator> They're ordered in each file, but not across the files.
01:28:20 <skew> so you are concatenating 30 files in memory, using String = [Char], and trying to sort it?
01:29:14 <aleator> Basically yes ;). I do extract the interesting parts of the files as numbers though.
01:29:33 <skew> how about taking advantage of the sorting in each file, then combining
01:30:07 <skew> like, using a merge rather than append and sort
01:30:37 <skew> if these are integers you could keep a running total by key
01:31:12 <aleator> Hmm.. Maybe.. But it seems to get stuck even without sorting.. Just by reading stuff and doing "return (stuff:moreStuff)".
01:32:00 <skew> if that "return" is a -> IO a, then writing that forces it to read the whole file before it can start any processing
01:33:10 <aleator> I'm doing the reading by "x<-hGetLine; stuff<-process x; return (x:stuff)". So it shouldn't.
01:33:25 <skew> oh, ok
01:33:28 <aleator> ack "x<-hGetLine; stuff<-process x; return (stuff:moreStuff)".
01:33:35 <skew> that looked like you were reading the rest of the file
01:33:41 <skew> what does process x do?
01:34:11 <aleator> that's approximately "read.(!! 1).words"
01:35:15 <skew> you mean (x,stuff)?
01:35:51 <skew> this sounds way too complicated for the problem you described
01:36:45 <frobar> why doesn't  do { x <- [1, 2, 3]; mapM Just x }  work while  do { x <- (do Just [1, 2, 3]); mapM Just x }  does? i thought the semantics were the same.
01:37:24 <skew> no
01:37:54 <skew> ?type mapM
01:37:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
01:38:06 <skew> ?type mapM Just
01:38:08 <lambdabot> forall a. [a] -> Maybe [a]
01:38:19 <skew> mapM Just x has to be an action in the Maybe monad
01:38:34 <skew> [1,2,3] is not of any type Maybe x
01:38:42 <skew> the left one tries to be in the list monad
01:39:03 <aleator> skew: Right. So, how to make it simple? 30 files, key, value pairs on each line, each key at most once in the file, separated by tabs, need average value and std.deviation of values for each key.
01:39:26 <skew> maybe values on a line?
01:40:24 <aleator> ?
01:40:25 <frobar> ah, i thought  x <- foo  was just a shorter way of writing  x <- return foo; didn't realize the list monad played in there
01:40:56 <skew> x <- foo = x <- return foo = x <- return (return foo) = x <- return (return (return foo)) ... ?
01:41:18 <ThreeQ> ?undo do { x <- foo; return x }
01:41:19 <lambdabot> foo >>= \ x -> return x
01:41:22 <ThreeQ> ?undo do { x <- return foo; return x }
01:41:23 <lambdabot> return foo >>= \ x -> return x
01:41:39 <frobar> skew: yeah, i didn't think that far :)
01:41:46 <skew> let x = foo is pretty much shorthand for x <- return foo
01:54:17 <therp> hm, compiling ghc just killed my box. linux appearently has grave problems with out-of-memory situations
02:08:51 <frobar> ?undo do x <- [1, 2, 3]
02:08:51 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
02:09:12 <frobar> ?undo { do x <- [1, 2, 3]; return x }
02:09:13 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
02:09:22 <frobar> ?undo do { x <- [1, 2, 3]; return x }
02:09:23 <lambdabot> [1, 2, 3] >>= \ x -> return x
02:10:31 <frobar> does lambdabot use hugs, ghc, some internal implementation or a mixture?
02:13:31 <frobar> ?undo do { x <- [1, 2, 3]; return [1] }
02:13:32 <lambdabot> [1, 2, 3] >>= \ x -> return [1]
02:16:35 <frobar> ?undo do Just x
02:16:35 <lambdabot> Just x
02:17:20 <frobar> ?undo do Foo bar
02:17:21 <lambdabot> Foo bar
02:25:28 <frobar> ?undo do { x <- fd fe gfd bv; ji ji kxl }
02:25:29 <lambdabot> fd fe gfd bv >>= \ x -> ji ji kxl
02:26:09 <frobar> it would be neater if it used >> as well :)
02:27:12 <frobar> ?undo do { <- <- <-; <- }
02:27:13 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
02:30:27 <frobar> ?undo do { x <- do { y <- [1, 2, 3]; return y }; return x }
02:30:27 <lambdabot> [1, 2, 3] >>= \ y -> return y >>= \ x -> return x
02:50:03 <musasabi> Did gtk2hs have some of the simple tree view ideas integrated?
02:51:44 * musasabi just wants his displayInTreeviewWidget :: TreeView -> [String] {- header names -} -> [[String]] {- data -} -> IO ()
02:56:57 <musasabi> I think someone had the high level layer on top of gtk2hs ?
03:27:49 <jmmv> hi
03:33:58 <gds> jmmv: Hey :)
04:00:50 <ForgeAus> hey all :)
04:08:39 <goltrpoat> there's something phenomenally dreary about writing a gui library
04:12:07 <ndm> goltrpoat: why not just use Gtk2hs?
04:12:23 <goltrpoat> not my call
04:12:54 <ndm> what Gui library are you writing?
04:13:04 <ndm> not only are they tedious, but really hard to get right!
04:13:14 <goltrpoat> contract stuff.  a client wants more or less a full gui from scratch.
04:13:29 * ndm hits client with a clue stick
04:13:33 <goltrpoat> haha
04:13:46 <goltrpoat> well, it's for a game, so gtk or wxwidgets wouldn't make a huge amount of sense
04:13:59 <ndm> OpenGL?
04:14:04 <goltrpoat> directx
04:14:21 <ndm> yeah, every game seems to write its own UI
04:15:00 <flux__> I think there are atleast guis written on opengl, I'd imagine some directx-ones exist too
04:15:14 <goltrpoat> there are a couple of middleware solutions for game ui stuff floating around, but apparently they're not terribly good
04:15:29 <SamB_XP> yeah, so, you think yours will be better?
04:16:10 <goltrpoat> define better
04:16:25 <goltrpoat> if 'better' means closer to what the client wants, then yes, it'll be better :)
04:17:34 <Muad_Dibber> so if you define better as " better for your wallet" then also yes? :)
04:17:50 <goltrpoat> you could say that as well
04:18:06 <SamB_XP> hmm
04:18:29 <SamB_XP> so if they were going to use middleware they wouldn't be hiring you?
04:18:57 <goltrpoat> correct.  they evaluated two, i think, middleware solutions, and decided they'd rather farm it out
04:20:10 <SamB_XP> so SPJ wants me to rebuild my libraries from scratch to run nofib for a before & after picture of my patch...
04:23:41 * SamB_XP pleads "too slow CPU"
04:24:17 * SamB also cancels his truly unconflicted patch
04:27:30 <emk> Data.Map is my happy friend. I have an interpreter with nested scopes, and it's so nice to not have to build a list of symbol tables--instead, I can just update one purely functional one.
04:27:52 <yip> goltrpoat: use an architecture based on functional reactive programming :D
04:29:04 <SamB> emk: yes, that is indeed nice ;-)
04:29:27 <SamB> though really you can most likely do the same thing in most imperative languages...
04:29:49 <SamB> (you just have to copy the mapping explicitly)
04:32:04 <goltrpoat> yip:  haha
04:32:09 <goltrpoat> i'll just ship a copy of Fran
04:32:26 <goltrpoat> wonder how that'd go over
04:33:19 <yip> i actually think that a Fruit-style gui would work really well for a game gui. you have to render the entire gui anyway every frame, and scripting it would be so much easier
04:33:32 <yip> it's a project that i plan on attempting when i have some time
04:36:16 <ndm> SamB, swings and roundabouts is a phrase SPJ has used before
04:36:41 <ndm> SamB, if you do one optimisation it can often make some programs slower
04:39:39 <Igloo> Cale: I'm not going to hack the .debs, if that's what you mean, but if you hack something locally then the worst that can happen is ghc won't work AFAICS
04:39:59 <Igloo> Cale: If you just forcibly install it then apt will probably get upset, though
04:42:24 <xerox> ?users
04:42:29 <lambdabot> Maximum users seen in #haskell: 256, currently: 224 (87.5%), active: 24 (10.7%)
04:45:30 <SamB> ndm: I just want to know what they *are*
04:46:00 <ndm> SamB, items on a kiddies play parks - roundabouts are circular and go round, they are now illegal since they tend to chew up kids under neath
04:46:12 <ndm> SamB, swings are tied above, and go back and forth
04:46:48 <SamB> okay
04:46:50 <SamB> I know those then
04:47:01 <alar> I have my program running out of swap space
04:47:09 <ndm> i suspect his metaphor is that they both go back and forth and round and round, never getting anywhere
04:47:22 <alar> the program is simpe main = interact myfun
04:47:42 <alar> is it space leak in interact function or my fault?
04:47:45 <Igloo> Roundabouts are illegal? Wow
04:48:09 <ndm> i think so, either illegal or you can't get planning permission and have to remove them, which amounts to the same thing
04:48:20 <araujo> morning!
04:48:29 <ndm> look at any play park, there will be a big empty hole where the rioundabout used to be (I liked roundabouts!)
04:50:02 <Igloo> AOL
04:50:04 <roconnor> I thought roundabouts were a type of road configuration.
04:50:15 <ndm> they are as well
04:50:43 <ndm> but in teh context of swings, it refers to the playground
04:50:47 <araujo> http://www.tiobe.com/tpci.htm
04:50:49 <lambdabot> Title: TPCI - TIOBE Programming Community Index
04:51:01 <araujo> Let's work harder!
04:53:27 <gour> araujo: why? lua is behind :-)
04:55:04 <roconnor> what is this D language, and why is it in the chart?
04:55:14 <araujo> yay! , people is cooperating with the spanish translations!
04:55:28 <araujo> roconnor, yes, that was surprising to me too
04:55:42 <araujo> D is a C-like language offering some kind of OO model.
04:56:04 <araujo> gour, that's why i say it ... i already can see lua getting the top first
04:56:26 <araujo> gour, We are behind Maple (wtf?!)
04:56:59 <gour> araujo: better not to think about the ones above. even ruby made it int o#13 :-(
04:57:01 <Muad_Dibber> if I remember correctly D is a research language for both aspect oriented OO and distributed OO
04:57:05 <Muad_Dibber> but I can be wrong
04:57:28 <ndm> you are, its like C, with optional GC and a bit cleaner
04:57:40 <araujo> On the good side ..  statically PL looks doing by far better than dynamic ones.
04:57:54 <ndm> or at least the popular one, i guess there have been plenty of projects called D
04:58:51 <Muad_Dibber> ndm, ah, I am wrong..the article I read is an *extension* to that D. so bleh :)
04:59:20 <gour> araujo: static langs are doing so good, and haskell as first-class representative so poor :-/
04:59:57 <araujo> gour, Well, check the functional languages.
05:00:09 <araujo> That's other bad sign. They are in the bottom.
05:00:38 <araujo> But i _do_ think that will definitely change
05:01:16 <gour> araujo: and delta is very 'promising' :_(
05:02:23 <araujo> "In summary, I think both Lua and F# have a great future."
05:02:38 <araujo> Yeah, i think Lua will make it too
05:02:42 <araujo> Not sure about F#
05:02:57 <goltrpoat> "The ratings are based on the world-wide availability of skilled engineers, courses and third party vendors."
05:03:03 <goltrpoat> i wonder what their definition of "skilled engineers" is
05:03:28 <jmmv> in my university, for example, functional languages used to be "presented" to the students a while ago...  now, we don't see them in the whole course, so there are no new users for them
05:03:29 <araujo> More people using it.
05:04:06 <roconnor> So D's langauge specification is a closed-source compiler?
05:04:15 <araujo> No, i think that's open
05:04:37 <araujo> It is a rather new language too.
05:04:41 <int-e> woops. why do they combine lisp and scheme in one category but give all the various C dialects their own?
05:05:26 <int-e> Ok, CL has its own category again. What's Lisp then?
05:05:54 <araujo> They must be using "Lisp" to refer any other dialect of it
05:06:05 <goltrpoat> D is actually relatively nice, from what ive seen
05:08:24 <goltrpoat> bedtime
05:14:06 <roconnor> ndm: there is a firefox plugin!
05:14:38 <ndm> roconnor: for Hoogle? yes, i know - for something else?
05:14:50 <roconnor> for hoogle
05:15:03 <ndm> yep, its in the top right hand corner of www.haskell.org/hoogle
05:15:13 <ndm> if you visit with firefox
05:16:02 <wilx> Heh, interesting graph.
05:16:54 <wilx> What was the decline of Java's percentage and increase of percentage of other languages between Feb-04 and Jun-05?
05:18:32 <ndm> roconnor: there are also instructions for how to make it a "quick search" in Firefox, so the url "h map" does a hoogle search - i use that mainly
05:19:32 <roconnor> hmm, maybe it doesn't work with mozilla
05:20:14 <ndm> no idea about mozilla
05:20:28 <ndm> but the sidebar should work fine, there is special hoogle code just for the mozilla sidebar stuff
05:23:33 <lisppaste2> therp pasted "another ghc in ghci try" at http://paste.lisp.org/display/27895
05:23:58 <therp> are there ghc hackers around that give me a hint what might be the cause?
05:26:59 <roconnor> why are people searching for where with hoogle?
05:31:12 <ndm> i have no idea, but they did
05:31:33 <ndm> and hence hoogle tries to be nice to them
05:32:06 <roconnor> @hoogle where
05:32:06 <lambdabot> Prelude.where :: keyword
05:32:07 <lambdabot> Language.Haskell.TH.Ppr.where_clause :: [Dec] -> Doc
05:32:07 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
05:32:16 <roconnor> @hoogle hoogle
05:32:16 <lambdabot> No matches found
05:32:39 <Igloo> therp: Doesn't the error tell you?
05:32:58 <Igloo> therp: That file is full of unboxed tuples
05:33:20 <roconnor> ndm: execpt that where links to the old wiki
05:33:41 <therp> igloo: right, but why is that a problem for the bytecode generator?
05:35:24 <Igloo> I'm not sure. It could well just be that no-one's written the code
05:35:43 <therp> ah I guess the problem is that bytecode can never deal with unboxed types because unboxed means "processor native" entities..
05:36:01 <ndm> roconnor: ah, yes, thats a bigger problem with the old wiki going away
05:36:25 <ndm> roconnor: very good point, there is a new keywords wiki on the new site that has better info on it
05:37:05 <ndm> moving shouldn't be hard, but i was hoping to wait for Hoogle 4, but will have to do that sooner i guess
05:37:24 * roconnor wonders if whitespace is a keyword in haskell
05:37:25 * ndm wonders if he's broken Hoogle 3 too badly to patch it up for this
05:37:49 <roconnor> I remember tyring to explain to someone that whitespace associates to the left.
05:38:18 <ndm> anyway, must dash, have a squash game :)
05:54:31 <roconnor> @localtime monochrom
06:06:38 <fasta> I have a function returning this type: [(Node, gr a b, (b1, b1) -> b1)] When I replace that with Foo b1, with type Foo b1 =  [(Node, (DynGraph gr)=>gr a b, (b1, b1) -> b1)] I get an odd type error message regarding "rigid type variables" that don't match. Why can't I just do this?
06:08:23 <int-e> because the scope of the DynGraph gr =>  is wrong ...
06:09:40 <fasta> I should put the constraint outside of the tuple? Why? It's not like a b are mentioned anywhere else in the tuple.
06:09:53 <int-e> type  Foo b1 = Dyngraph gr => [(Node, gr a b, (b1, b1) -> b1)]  is worth a try, maybe. type Foo gr b1 = [(Node, gr a b, (b1, b1) -> b1)]  used as DynGraph gr => Foo gr xxx  will definitely work.
06:11:42 <int-e> you'd get a list full of possibly different gr instances. Is that what you want? (putting aside the question if that works ... my knowledge is shaky in this area)
06:11:50 <fasta> Without extensions: Illegal polymorphic or qualified type: forall (gr :: * -> * -> *) for the first part.
06:12:17 <fasta> int-e: no, I want the instances to be the same.
06:13:05 <fasta> int-e: I could give them an explicit type, but that would only constrain it unneccecarily.
06:13:56 <fasta> er unnecessarily
06:14:40 <int-e> I think making gr an argument of Foo is the way to go.
06:15:05 <fasta> int-e: I think it's rather stupid that that's needed.
06:15:13 <int-e> I know that having to put the DynGraph gr => everywhere is inconvenient.
06:15:20 <int-e> but I see no way around it.
06:15:35 <fasta> int-e: ok, well, you can't help flaws in the language
06:15:55 <int-e> If there is a trick to accomplish this, I'd like to hear about it :)
06:18:24 <fasta> int-e: type Layer b1 gr a b =  [(Node, gr a b, (b1, b1) -> b1)] this works
06:18:36 <fasta> int-e: but with the the a and b not there, it doesn't.
06:18:36 <kpreid> fasta: you can't put it inside because, if I understand correctly, that implies the quantification is inside as well, which means something different
06:21:29 <fasta> kpreid: I don't think it means something else in logic, when variables a and b are not mentioned in the other components of the tuple.
06:22:05 <kpreid> I'm not up on Curry-Howard so I can't comment on that
06:22:21 <kpreid> but consider that nesting of quantifiers does make a difference
06:22:59 <int-e> sure, (exists a . b) /\ (exists a . c) means something different than exists a . (b /\ c) (a is free in b and c)
06:23:21 <int-e> and Foo x =>  is an existential quantification.
06:23:51 <int-e> I think.
06:24:57 <xerox> ∃x∈Foo s.t. ...
06:24:58 <int-e> @type (1,1)
06:24:59 <lambdabot> forall a b. (Num a, Num b) => (a, b)
06:25:21 <int-e> @type let x = 1 in (x,x)
06:25:22 <lambdabot> forall a. (Num a) => (a, a)
06:25:48 <fasta> I think I like the logic notation more, since IIRC in some places a forall actually means an exists in GHC.
06:33:32 * edwardk waves hello.
06:34:01 <profmakx> moin edwardk
06:35:38 <edwardk> how goes?
06:56:10 <mwc> Yay! GHC 6.6 is compiling
06:56:29 * mwc pulls out "Fellowship of the Ring."
06:58:36 <br1> mwc: ehwre?
06:59:45 <mwc> br1: where?
07:00:23 <br1> In which platform are you compiling ghc?
07:00:29 <LPhas> Someone could help me finding docs about GHC's dynamic loader?
07:00:30 <mwc> Linux i686
07:00:54 <LPhas> mainly GHC's dynamic loader's implementation.
07:01:09 <mwc> LPhas: hs-plugins?
07:01:11 <br1> LPhas: no idea, maybe start at hsplugin page
07:01:23 <mwc> I think dons is the authority on hs-plugins
07:01:24 <LPhas> i started with hsplugin papers
07:02:23 <LPhas> but on them you read that hs-plugins uses GHC's dynamic loader, wich on *nix uses dlopen()
07:02:44 <LPhas> so now i need to understand both GHC'dynamic loader and dlopen()
07:03:07 <LPhas> but i cannot find docs wich explain the implementation
07:03:59 <Patterner> mwc: 6.6 compiled on x86_64, so i'm quite sure you'll end with a successful compilation :)
07:04:06 <Patterner> mwc: in a couple of weeks
07:04:10 <psnl> is there a integer divison in haskell?
07:04:23 <roconnor> @pl map (\n -> map (+n) [0..]) [0..]
07:04:23 <lambdabot> map (flip map [0..] . (+)) [0..]
07:04:40 <mwc> well, dlopen/dlsym/dlclose are pretty primitive. You open an object file linked a certain way, look up the address of a symbol defined in it, call it, and close the file
07:04:44 <mwc> psnl: div
07:04:45 <roconnor> @pl \l -> map (\n -> map (+n) l) l
07:04:45 <lambdabot> map =<< flip (map . (+))
07:04:45 <mwc> @type div
07:04:47 <lambdabot> forall a. (Integral a) => a -> a -> a
07:04:51 <LPhas> Prelude> :t div
07:04:51 <LPhas> div :: (Integral a) => a -> a -> a
07:04:56 <psnl> mwc: ta
07:05:01 <roconnor> @type \l -> map (\n -> map (+n) l) l
07:05:02 <lambdabot> forall a. (Num a) => [a] -> [[a]]
07:05:44 <LPhas> mwc: yeah but i have to describe this process in details
07:06:17 <Lemmih> LPhas: You most likely have to look at the source.
07:06:30 <mwc> Patterner: I know what you mean. I once built GHC on ppc/os x
07:06:38 <mwc> That took about 10 hours on a 1.5 Ghz G4
07:06:43 <LPhas> Lemmih: sigh
07:06:43 <Lemmih> The internals of GHC aren't exactly well documented.
07:06:46 <pejo> Lphas, as for dlopen() and friends - the manpages for some BSD are usually very well written, and could be read online somewhere.
07:07:00 <thebug> @yow
07:07:01 <lambdabot> Hello, GORRY-O!!  I'm a GENIUS from HARVARD!!
07:07:04 <LPhas> pejo: thx
07:07:55 <LPhas> Lemmih: i'm not exactly an "abitue" of reading GHC's code. You can give me an hint on how find the appropriate lib?
07:08:42 <Lemmih> LPhas: lib?
07:09:46 <LPhas> Lemmih: ok, "part of the code of ghc", "file"
07:10:56 <int-e> abitue?
07:11:34 <Lemmih> LPhas: Check out ObjLink.lhs and Linker.c
07:12:53 <LPhas> Lemmih: ouch, it's in C? well, btw thx.
07:13:18 <mwc> LPhas: the runtime system stuff will be in C
07:13:37 <mwc> and I imagine there's some haskell patina over that
07:21:21 <lisppaste2> rahikkala pasted "confusion with monads, I think" at http://paste.lisp.org/display/27898
07:21:44 <kpreid> Is there something like elemM :: (a -> m Bool) -> [a] -> m Bool, or do I need to define my own?
07:21:44 <rahikkala> ^ newbie help needed
07:22:57 <kpreid> rahikkala: ST doesn't do nondeterminism like the list monad itself does. you could use ListT
07:23:16 <kpreid> actually, no, that wouldn't do what you want
07:24:02 <kpreid> I don't think there is a monad that does what you're thinking of
07:24:10 <rahikkala> I see
07:24:49 <kpreid> what I'd do is try to optimize the non-state-involving one
07:24:50 <velco> rahikkala: the thing on the right if <- must return the monad ytpe
07:24:59 <LPhas> wow
07:25:09 <LPhas> the GHC's dynamic linker is really complex
07:25:11 <LPhas> :P
07:25:18 <LPhas> it... call's dlopen
07:26:19 <Lemmih> Of course it does.
07:26:35 <rahikkala> Hmm
07:26:35 <mwc> I suppose it could mmap the file, then do its own linking
07:26:47 <mwc> But why would you bother?
07:27:50 <Lemmih> LPhas: There's a bit more to it when it's linking bytecode.
07:32:44 <fasta> Is Control.Monad.Writer the "same" as Control.Monad.Reader, except that you can only write to it, where with Reader you can only read from it?
07:34:40 <Lemmih> fasta: Yep.
07:34:43 <mwc> fasta: basically yes
07:35:06 <mwc> fasta: and you'll want to use (a -> a -> a) as your monoid...
07:35:20 <fasta> mwc: ?
07:35:46 <mwc> the writer monad accumulates information at each step using a monoid
07:35:56 <fasta> mwc: How can you know what I want, while I don't even intend to use Writer in the very near future.
07:35:59 <fasta> ?
07:36:58 <omairt2001> i need some help on a haskell problem can any1 help me?
07:37:43 <mwc> fasta: as I understand it, the other popular one is [a], which uses ++
07:37:50 <ndm> omairt2001: ask away
07:37:51 <mwc> that can get slow, or so I've read somewhere
07:37:53 <Lemmih> omairt2001: Ask and you shall receive.
07:38:06 <fasta> mwc: Again: what question are you answering?
07:38:43 <mwc> fasta: you asked about Monad.Writer, I was giving you some general info about it that I accumulated
07:39:19 <omairt2001> how do i write a recursive function that computes xy mod n for any n sqrt maxint, without arithmetic overow.
07:39:34 <omairt2001>  x^y
07:39:42 <fasta> mwc: ok, thank you for trying then, but I think I understand the issues with (++) giving problems and its relation to Monoid well.
07:40:18 <ndm> omairt2001: use Integer and you'll never have any overflow
07:40:28 <Lemmih> omairt2001: Homework?
07:40:34 <omairt2001> yep
07:40:36 <fasta> Lemmih: sounds like it
07:40:45 <omairt2001> tried but keep failing for large numbers
07:40:54 <kpreid> omairt2001: use Integer, not Int
07:41:07 <omairt2001> im supposed to use Int
07:41:23 <kpreid> oh, I see.
07:41:23 <fasta> omairt2001: is the assignment online?
07:41:50 <omairt2001> yeh
07:42:02 <omairt2001> http://www.doc.ic.ac.uk/~ajf/Teaching/Haskell/Backups/Haskell2005/Lab2.pdf
07:42:05 <lambdabot> http://tinyurl.com/y2kgst
07:42:15 <omairt2001> its the function modPow
07:43:24 <ndm> Laboratory work is a continuously assessed part of the examinations
07:43:26 <ndm> and is a required part of the degree assessment.
07:43:53 <ndm> omairt2001: given that text on the questions, it might be best if you ask all questions at your lecturers/demonstrators, so they know what help they can and cannot give you
07:44:29 <omairt2001> ok thnk u
07:48:12 <ndm> @seen dcoutts
07:48:13 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 6h 56m 35s ago.
07:48:31 <psnl> ndm: is there a hat darcs repo now?
07:48:44 <ndm> psnl: yep, are you on the hat mailing list?
07:49:01 <ndm> psnl: darcs get --partial http://darcs.haskell.org/hat
07:49:03 <lambdabot> Title: Index of /hat
07:49:16 <psnl> yey
07:49:38 <ndm> psnl: i also sent off a proposal to move all the files around, put them in sensible places etc, so things may have a big reorganisation some time shortly
07:59:51 <glguy> check out the response I got from the manager of Aurigma's image uploader tool when I told him that his java version was spitting out bad Guids
07:59:54 <glguy> That is not a bug. Image Uploader for Java generates the GUID as a simple sequence of random values. We will make the changes to use only the characters which are used in Win GUIDs but only in future versions. I don’t think it is so big problem.
08:03:16 <dylan> it's not a bug, it's a feature!
08:04:01 <ndm> glguy: can't you use the Windows GUIDGEN tool? that uses your MAC address to stop getting clashes as well, so a lot more reliable
08:04:11 <glguy> The guids generated by this tool are even more unlikely to collide with other guids
08:05:04 <glguy> I need to use the guids that this tool generates to group multiple image uploads
08:05:04 <fasta> What does "local" do in Reader?
08:05:17 <glguy> fasta: modifies the environment
08:05:21 <glguy> and executes an action
08:05:26 <glguy> inside that modified environment
08:05:41 <fasta> glguy: so, if I only want to execute another action, I just do >> ?
08:05:45 <glguy> ?type local
08:05:47 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:05:49 <glguy> fasta: right
08:06:33 <glguy> fasta: unless you are using do-notation, of course
08:06:37 <glguy> then you just need a new line
08:06:44 <fasta> glguy: right
08:07:21 <fasta> glguy: Basically I have a Foo -> Reader Bar Foo function that I want to apply by feeding the last Foo back to the function.
08:09:36 <glguy> fasta: if you want to sequence actions together
08:09:41 <glguy> and carry a value along
08:09:52 <glguy> I think you'd want to use a State transformer
08:10:32 <fasta> glguy: I don't want to change the Bar type
08:10:42 <fasta> glguy: Only the Foo changes.
08:11:28 <glguy> fasta: I understand, I was proposing something like StateT Foo (Reader Bar) ()
08:12:20 <fasta> glguy: hmm, I never used monad transformers for a practical thing...
08:13:33 <roconnor> I used StateT blah IO in my UM implementation.
08:14:55 <glguy> fasta: otherwise you are going to have to run each Reader separately
08:15:20 <glguy> fasta: because Foo -> Reader Bar Foo is a function that returns an action, not an action itself
08:16:03 <fasta> glguy: yes, I saw that I would need to use runReader more than my liking. I will look at StateT
08:17:00 <glguy> fasta: your other option would be to use an RWS and just use () as your writer
08:18:20 <mwc> I've actually used StateT g (State h) in some things
08:18:51 <glguy> me too
08:29:14 <int-e> > [1..] >> mzero
08:29:14 <fasta> glguy: How can I get the value in the (Reader Bar) from a function having type StateT <etc>?
08:29:15 <lambdabot>  Add a type signature
08:29:20 <int-e> > [1..] >> mzero :: [Int]
08:29:24 <lambdabot> Terminated
08:29:43 <fasta> glguy: within the monad, that is?
08:29:46 <int-e> tss. tss. so much for a >> mzero == mzero
08:29:54 <glguy> fasta: use evalStateT
08:30:25 <glguy> to remove the StateT shell and get your Reader Bar
08:30:29 <fasta> glguy: no, I mean within the function
08:30:36 <glguy> oh
08:30:44 <glguy> fasta: lift ask
08:30:51 <fasta> Ok
08:32:26 <fasta> glguy: and why can I use "get" to get the state?
08:32:57 <glguy> fasta: I don't think I understand your question
08:33:22 <fasta> glguy: Nm, StateT is an instance of MonadState
08:34:27 <fasta> glguy: My question was: how to get the value of type Foo within a function of type StateT Foo <etc>?
08:34:44 <fasta> glguy: which I think I answered myself in the next line
08:34:55 <glguy> and then you figured out to use "get" and "gets"?
08:35:05 <glguy> OK, cool (-;
08:35:21 <fasta> glguy: oh, I don't know about "gets"
08:35:36 <glguy> ?type get
08:35:37 <glguy> ?type gets
08:35:41 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
08:35:42 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
08:35:58 <glguy> gets allows you to apply a function to the state value before you get your result
08:36:12 <glguy> similarly, Reader has ask and asks
08:36:57 <fasta> glguy: Hmm, I don't think that is a very handy function, and only bloats the API. I could be wrong of course.
08:37:22 <glguy> fasta: I rarely find myself using get
08:37:52 <ProfTeggy> glguy, instead you use  gets id  ?  ;-)
08:37:55 <glguy> gets allows you to use the state more transparently
08:38:16 <glguy> ProfTeggy: :-p
08:40:17 <fasta> Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj}
08:40:37 <fasta> I get this when I don't have a type annotation for my function.
08:40:46 <fasta> Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
08:40:53 <fasta> This is it in whole.
08:41:11 <glguy> wow :)
08:41:11 <fasta> When I add the type annotation, all is well.
08:41:46 <fasta> I didn't know GHC invented stuff :P
08:42:33 <glguy> NPR is holding a "friend-raiser"
08:42:51 <fasta> And what is NPR?
08:42:51 <glguy> I'm choking on rainbows X-\
08:42:59 <glguy> National Public Radio
08:48:45 <araujo> anybody knows how to avoid emacs of writing a file~ file?
08:49:04 <xerox> araujo: join #emacs, say ,backup or something.
08:49:14 <xerox> `,backup' on a line per se.
08:49:34 <araujo> let's see
08:49:35 <xerox> (Or `,,backup' in the middle of a line.)
08:50:09 <araujo> thanks xerox
08:50:13 <xerox> My pleasure.
08:50:24 <mwc> yay, I think the GHC 6.6 build has moved onto phase 2 :)
08:50:38 <xerox> It'd be cool if lambdabot had pluggable interfaces, or in particular, fsbot's one to a Data.Map String [String] :)
08:56:29 <musasabi> What caused "internal error: stg_ap_pp_ret" ?
08:56:32 <fasta> Do this to see GHC 6.5 Urk! testL = do lift ask :)
08:57:06 <glguy> ?type lift ask
08:57:07 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) r. (MonadTrans t, MonadReader r m) => t m r
09:11:34 <Lemmih> ?let testL = do lift ask
09:11:35 <lambdabot> Urk! Inventing strangely-kinded void TyCon:     ZCt{tc a202}     (* -> *) -> ...
09:11:46 <Lemmih> Neat.
09:12:47 <glguy> ?type let testL = do lift ask in testL
09:12:48 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) r. (MonadReader r m, MonadTrans t) => t m r
09:13:02 <kpreid> @remember ghc Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
09:14:03 <x3m> > let num=show(sum[n^n|n<-[1..1000]]) in drop ((length num)-10) num
09:14:06 <lambdabot>  "9110846700"
09:17:38 <glguy> > sum (map (join (^)) [1..1000]) `mod` (10^10)
09:17:39 <lambdabot>  9110846700
09:17:52 <mwc> @type join
09:17:53 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
09:18:41 <kpreid> @type fmap return -- something I recently had reason to use
09:18:42 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Functor f, Monad m) => f a -> f (m a)
09:18:52 <kpreid> @type join . fmap return
09:18:54 <lambdabot> forall a (m :: * -> *). (Functor m, Monad m) => m a -> m a
09:22:30 <mwc> > (join . fmap return) (return 4 :: [Int])
09:22:32 <lambdabot>  [4]
09:23:41 <mwc> join . fmap return should be an id-like function for monadic values, correct?
09:23:47 <kpreid> yes
09:24:31 <kpreid> join . liftM return removes the Functor restriction
09:24:54 <glguy> id removes the Monad restriction
09:30:13 <mwc> oh right, sometimes I forget Mondad /< Functor
09:31:08 <glguy>  /<?
09:31:41 <mwc> Not a subset of
09:32:33 <glguy> but only because Haskell doesn't enforce that property
09:32:55 <mwc> Right, I mean in Haskell, the monad instances aren't functor instances
09:34:36 <kpreid> Is being able to use 'newtype Foo a = IO a deriving Monad' (or other type classes) a GHC extension?
09:39:34 <sjanssen> kpreid: it's an extension
09:42:00 <mwc> @type (\f ma -> ma >>= \a -> return $ f a)
09:42:02 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> a1) -> m a -> m a1
09:42:26 <glguy> ?type fmap
09:42:28 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
09:42:32 <glguy> ?type liftM
09:42:34 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
09:42:59 <mwc> That would seem to be a reasonable default implementation for fmap for any monad... wonder why Monad isn't a subclass of Functor
09:43:39 <glguy> I believe that it is just so that you don't have to define a Functor instance if you don't intend to use it
09:43:48 <lispy> mwc: it could be, but was separated for historic reasons, iirc
09:43:52 <br1> I'd say it's a bug
09:44:33 <mwc> too bad a subclass can't provide a default implementation for an ancestor class's function
09:44:54 <sjanssen> there is a chance that class (Functor m) => Monad m where ... will appear in Haskell'
09:47:32 <br1> How long till 6.6 makes it into the shootout?
09:52:09 <ndm> does the new GHC FC stuff give a better treatment of unsafeCoerce?
09:52:24 <weitzman> Is 6.6 out?
09:52:34 <ndm> and if i was to write a program with unsafeCoerce littered as every other lexeme, would GHC be happy?
09:52:42 <therp> weitzman: yes
09:52:43 <weitzman> w00t
09:59:04 <br1> what's ghc fc?
10:00:00 <thetallguy> fc?
10:00:36 <swiert> system f with type coercions?
10:00:42 <swiert> Just a guess.
10:01:11 <thetallguy> http://www.cse.unsw.edu.au/~chak/papers/SCP06.html
10:01:12 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/y3kswc
10:01:43 <nomeata> To demonstrate haskell's brevity for complex taskts, I want to use this example:
10:01:49 <nomeata> > filter (\n -> not (any (\d -> n `mod` d == 0) [2..(n-1)])) [2..]
10:01:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:02:32 <nomeata> But is there a even shorter, but yet beginner-friendly way to get the list of prime numbers?
10:04:29 <mwc> There might be a more efficient way that uses recursive definitions... can you have it check for divisibility only by the previously generated primes?
10:04:35 <mwc> or would that be too complicated for your example?
10:04:56 <xerox> > let primes = 2 : 3 : [n | n <- [5,7..], all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)] in primes
10:04:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
10:05:02 <nomeata> well, the mark is set: if it still fits in half a line it might be a candidate
10:05:10 <glguy> > let seive (x:xs) = x : seive [a | a <- xs, a `mod` x /= 0] in take 10 $ seive [2..]
10:05:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
10:05:37 <nomeata> that one is good
10:05:51 <xerox> But mine discards even numbers.
10:06:18 <swiert> primes = sieve [2 . . ]
10:06:27 <swiert> sieve (p : ns ) = p : sieve (filter (notdiv p) ns )
10:06:43 <glguy> ?type notdiv
10:06:44 <lambdabot> Not in scope: `notdiv'
10:06:45 <glguy> ?type notDiv
10:06:46 <lambdabot> Not in scope: `notDiv'
10:06:53 <nomeata> I'll take mine as an example how with haskell, you can write down what you think it is (basically the definitions of primes), and then I'll show the seive as the optimized version.
10:07:26 <swiert> Lambert Meertens has a nice functional pearl on this stuff.
10:07:52 <ndm> Colin Runciman did some insane lazy wheel sieve stuff, which is impressive
10:08:59 <xerox> > head $ drop 20 $ iterate (map (sum . map (read . return) . show)) $ iterate (3*) 1
10:09:03 <lambdabot>  [1,3,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
10:09:46 <nomeata> > take 20 $ iterate (map (sum . map (read . return) . show)) $ iterate (3*) 1 -- what are you hiding?
10:09:48 <lambdabot>  [[1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
10:11:04 <nomeata> what is better style, (:[]), or return? :-)
10:11:08 <int-e> > drop 2 $ take 20 $ iterate (map (sum . map (read . return) . show)) $ iterate (3*) 1
10:11:12 <lambdabot>  [[1,3,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,18,9,9...
10:11:24 <int-e> I like (:[])
10:11:40 <weitzman> Using return to create lists is mean to newbs
10:11:55 <br1> :[] for me
10:12:01 <glguy> I only use return when I am using [] as a Monad
10:12:42 <int-e> @index singleton
10:12:42 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set
10:12:45 <weitzman> @hoogle a -> [a]
10:12:47 <lambdabot> Prelude.repeat :: a -> [a]
10:12:47 <lambdabot> List.intersperse :: a -> [a] -> [a]
10:12:48 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
10:12:54 <weitzman> Doesn't find return
10:12:56 <weitzman> Alas
10:13:04 <int-e> Data.List should have one, too, I think (singleton I mean)
10:13:30 <weitzman> > singleton 3
10:13:31 <lambdabot>  Not in scope: `singleton'
10:13:37 <weitzman> > Data.List.singleton 3
10:13:37 <lambdabot>  Not in scope: `Data.List.singleton'
10:13:38 <int-e> > S.singleton 3
10:13:39 <lambdabot>  {3}
10:13:47 <weitzman> S?
10:13:49 <weitzman> That's odd
10:13:53 <int-e> S = Data.Set
10:13:59 <weitzman> Cool
10:14:01 <int-e> @version
10:14:02 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
10:14:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:14:19 <int-e> see http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
10:14:21 <lambdabot> http://tinyurl.com/h7nko
10:14:35 * nomeata is off, cu
10:14:44 <ndm> weitzman: it doesn't really that return is monadic, version 4 will find return
10:15:08 <ndm> * really -> realise
10:15:43 <therp> for ghc, '#' is used to surround unboxed constants and to mark functions that deal with unboxed types (while the latter I presume is by convention than by extention) right?
10:15:48 <roconnor> ndm: How do you deal with map (\n -> map (+n) [0..]) [0..]  ?
10:16:07 <ndm> @paste
10:16:07 <lambdabot> http://paste.lisp.org/new/haskell
10:16:13 <Igloo> therp: Using # as a letter is an extension to the lexical syntax
10:16:30 <Igloo> therp: But roughly speaking, yes
10:16:46 <fasta> How do I set the initial value of Bar in StateT (Reader Bar) Foo?
10:17:03 <mwc> fasta: you pass it as a parameter to run/eval/execStateT
10:17:09 <glguy> fasta: evalStateT m startValue
10:17:10 <mwc> @type evalStateT
10:17:11 <lambdabot> forall a (m :: * -> *) s. (Monad m) => StateT s m a -> s -> m a
10:17:47 <ndm> roconnor: just calculating it...
10:18:02 <roconnor> :)
10:18:05 <roconnor> ndm-bot
10:18:24 <ndm> would be faster if i'd just typed it in to my program...
10:18:34 <fasta> How do I set the initial value of Bar in StateT Foo (Reader Bar) Foo?
10:18:41 * roconnor wonders how ndm finds time to do all his stuff.
10:19:02 <roconnor> fasta: it is passed in at runStateT iirc
10:19:09 <lisppaste2> ndm pasted "for roconner, specialisation" at http://paste.lisp.org/display/27905
10:19:13 <roconnor> @type Monad.State.runStateT
10:19:15 <lambdabot> Couldn't find qualified module.
10:19:16 <glguy> fasta: call: runReader on the result of evalSTateT
10:19:17 <mwc> Well, you use evalStateT to "strip off" the StateT from the inner monad
10:19:22 <mwc> Then you run the inner computation
10:19:24 <fasta> runStateT :: (s -> m (a, s))
10:19:29 <ndm> roconnor: that was a really easy example :)
10:19:36 <roconnor> good
10:19:50 <roconnor> I ask, because the inner map has a variable as a parmeter
10:20:04 <ndm> yep, it does free variable lifting
10:20:04 <roconnor> obviously you are not going to make all infinity of instances.
10:20:14 <roconnor> what does that mean?
10:20:20 <fasta> glguy: Ok, I see. Thanks
10:20:31 <ndm> treat "map<+n>" as just a name string, not separate <+ lexemes
10:20:46 <ndm> i.e. n is free in that inner lambda, so it lifts it up, and passes the free variables around
10:20:47 <roconnor> fasta: oops, sorry.  yes listen to glguy.
10:21:01 * shapr boggles
10:21:40 <glguy> roconnor: I should put that in ?quote ;-)
10:21:51 <roconnor> :)
10:22:04 <roconnor> ndm: hmmm,  I wish we had a whiteboard
10:22:26 <roconnor> can I ask the type of map<+n>?
10:22:30 <roconnor> does that make sense?
10:23:02 <ndm> roconnor: yep, its :: Int -> [Int] -> [Int]
10:23:12 <ndm> roconnor: if you're ever near York, UK, I have whiteboards here
10:23:14 <roconnor> right
10:23:43 <roconnor> then you also make a map<map<+m>> for the second map?
10:24:02 <roconnor> ndm: I thought yhc was developed by *former* york students.
10:24:19 <glguy> what's this <> business?
10:24:34 <ndm> roconnor: no, since the inner one isn't passed map, its passed f (after lambda floating)
10:24:39 <chessguy> > 18446744073709551616 :: Int
10:24:39 <roconnor> glguy: ndm's yhc implemention compiles away higher order functions.
10:24:40 <lambdabot>  0
10:24:44 <chessguy> > 18446744073709551616 :: Integer
10:24:46 <lambdabot>  18446744073709551616
10:24:53 <ndm> glguy: just extra syntactic names, think templates in C++/Java
10:25:07 <roconnor> ndm, what is f?
10:25:10 <ndm> roconnor: there was a former york student, but he's not done anything in ages
10:25:28 <ndm> roconnor: introduced by lambda lifting, already done automatically by Yhc standard
10:25:37 <ndm> roconnor: lambda's may only appear at the top level
10:26:31 <ndm> the transformation in step 1 is a well known one, which Yhc already performs, and i think GHC does too
10:26:44 <ndm> its after that my weird things come in
10:27:09 <roconnor> @lambda-lift map (\n -> map (+n) [0..]) [0..]
10:27:09 <lambdabot> Unknown command, try @list
10:27:14 <roconnor> aww
10:27:26 <xerox> lambdabot, the refactorer.
10:27:32 <xerox> We need an MtG card like that.
10:27:53 <pejo> roconner/ndm, you can't reasonably remove all higher order functions at compile time though?
10:28:01 <ndm> pejo: you can :)
10:28:12 <fasta> glguy: Ok, I got it working, but now I first put a value in a reader then compute something. This something I pass to evalStateT, but then to instantiate that reader I need to pass the "a value" again to that reader. Not really optimal
10:28:33 <roconnor> so after lamba lifiting we map (\n -> map (+n) [0..]) [0..] becomes ...?
10:28:42 <roconnor> s/we //
10:28:50 <pejo> ndm, some followup on the work by Chin?
10:29:03 <ndm> pejo: nope, my new work
10:29:20 <ndm> pejo: do you have a reference for the work by Chin? (googling chin might not get me very far...)
10:29:31 <mwc> Is it safe to strip ghc libs or executables?
10:29:34 <kpreid> fasta: you're giving the state and reader the same value?
10:29:44 <pejo> ndm, oh. Hm. Not in the office at the moment, let me think for a while.
10:29:54 <ndm> roconnor: step 2
10:29:58 <fasta> kpreid: No
10:30:11 <ndm> pejo: or just any bits of the name/languages/techniques so i can refine the search
10:30:24 <fasta> kpreid: The reader inside the StateT and another Reader computation.
10:30:33 <ndm> roconnor: f n = map (+n) [0..]
10:30:34 <ndm> main = map f [0..]
10:30:35 <pejo> ndm, got any scribbles/aritcles/etc about your work?
10:30:50 <ndm> pejo: not really, not the function removal stuff
10:30:53 <ndm> @where catch
10:30:54 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
10:31:17 <ndm> pejo: that starts to go towards it in section 1.2 of the most recent paper ^^ - but only very lightly
10:31:43 <fasta> kpreid: Never mind, it's impossible for you to understand without seeing the code.
10:32:39 <roconnor> ndm: so you end up with f n = map<+n> n [0..] and main = map<f> ?
10:33:17 <ndm> roconnor: the last step is all the code you need to run it, and could actually be compiled with GHC
10:36:06 <roconnor> ah, didn't see the paste until now
10:36:33 <pejo> ndm, http://www.comp.nus.edu.sg/~chinwn/publ.html, it's stuff from the early 90's.
10:36:36 <lambdabot> Title: Publications
10:36:41 <roconnor> ndm: could be compiled with GHC modulo the tokens problem?
10:37:05 <ndm> roconnor: yep, and the tokens were just picked that way to make it easier to read (in reality mine uses _n tags)
10:37:31 <ndm> pejo: thanks, will read up on some of that
10:38:14 <roconnor> ndm: does this always work?
10:38:41 <ndm> roconnor: no, but when it doesn't you can use Reynold's style defunctionalisation, which does always work (but is not Hindley Milner type safe)
10:38:50 <pejo> ndm, "A Static Checker for Safe Pattern Matching in Haskell"?
10:38:52 <ndm> however, in practice, its pretty good
10:38:55 <ndm> pejo: yep
10:40:12 <rictic> I'd like to do a unicode literal in a GHC source file, but I'm getting scrambled output.  Any advice?
10:43:31 <rictic> "(∆˚" when printed becomes �
10:43:58 <rictic> Er, "∆˚" when printed becomes that
10:45:35 <rictic> More detail:
10:45:35 <rictic> english:~/projects/SK $ runhaskell sk.hs | od -c
10:45:35 <rictic> 0000000    ( 006 332   A   :   k   )  \n
10:45:36 <rictic> 0000010
10:47:20 <roconnor> roconnor@faris:/tmp$ cat Main.hs
10:47:21 <roconnor> main = putStr "\x236a"
10:47:21 <roconnor> roconnor@faris:/tmp$ ./a.out | xxd
10:47:21 <roconnor> 0000000: 6a                                       j
10:47:24 <roconnor> :(
10:47:41 <roconnor> @docs GHC.Unicode
10:47:42 <lambdabot> GHC.Unicode not available
10:48:35 <roconnor> > maxBound :: Char
10:48:42 <lambdabot>  '\1114111'
10:51:23 <roconnor> rictic: use http://www.cse.ogi.edu/~hallgren/Programatica/tools/base/lib/UTF8.hs to translate to a UTF-8 encoding
10:51:26 <lambdabot> Title: UTF8.hs, http://tinyurl.com/y8tmt7
10:52:58 <rictic> roconnor: that's perfect, thanks!
10:53:22 <rictic> roconnor: now I can use the forall symbol in my output; much more pleasant   (:
10:54:12 <roconnor> we should make that into a nice module that new IO primitives.
10:54:18 <roconnor> that has new IO ...
10:55:13 <roconnor> putStrUTF8 etc.
10:55:24 <mwc> Anybody else notice happy-1.15 won't build with ghc 6.6
10:56:59 <roconnor> Anyone been able to build ghc HEAD with ghc  6.6?
10:58:21 <Igloo> mwc: happy from darcs does
11:00:05 <mwc> Igloo: no worries, just repacking it... I prefer parsec anyways
11:13:33 <shapr> jmob: No, I don't work for Nokia. I hack on the Nokia 770 sources for other reasons.
11:13:55 <mwc> hello shapr
11:15:27 <mwc> how's code?
11:15:37 <Philippa> for approximately the reasons I may be hacking on Sharp Zaurus sources soon :-)
11:15:48 <shapr> mwc: Code is quite nifty.
11:16:20 <shapr> I've been hacking on a wiki for HAppS and I'll probably hack up a web forum next.
11:16:27 <mwc> Beauty
11:17:04 <Philippa> yeah, I'm half surprised I never bothered to turn flippi into a forum
11:17:13 <Philippa> though I guess doing it well makes you think about users, logins etc
11:17:36 <shapr> The main reason I'm doing it is that a friend of mine asked me to build a website for her with a laundry list of features.
11:17:58 <shapr> And she's done so many nice things for me in the past I just couldn't say no. But I could say I want to use Haskell =)
11:18:26 <Philippa> :-)
11:25:33 <lispy> http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf
11:25:39 <lambdabot> http://tinyurl.com/mpaac
11:26:10 <Canar> shapr: doing the back end in haskell instead of php?
11:26:15 <Canar> or something similar?
11:28:08 <shapr> Canar: Yup, building the whole website with Haskell.
11:28:45 <shapr> y0, dm in da house!
11:29:57 <Canar> is haskell well-suited to that task, compared to PHP and C and whatnot?
11:30:10 <Canar> (please forgive my noobidity)
11:30:27 <shapr> I think that Haskell is far more suited to webdev than C.
11:30:29 <mwc> Canar: arguably, C would be a bad idea
11:30:46 <mwc> as for PHP, I hear it has strange function names, and it's a pain to scale
11:30:56 <lispy> php code is hard to write
11:31:07 <shapr> PHP is hard to read also.
11:31:18 <lispy> it looks easy, but then you realize it does strange things when you run it
11:31:26 <shapr> I hacked on Drupal a bit and decided that I could get rid of the more than half the code if I were using Haskell.
11:31:34 <therp> lispy: so true
11:31:35 <lispy> shapr: nice
11:31:36 <glguy> PHP makes it easy to write lousy webapps
11:32:10 <lispy> so that link above describes building a scheme compiler inside out
11:32:12 <therp> the binding effects lasting from "for" are purely insane in PHP
11:32:22 <lispy> you start at the AST and generate assembly and build out in both directions
11:32:29 <lispy> at each step you have a 'working' compiler
11:32:41 <shapr> But the case of Drupal, that's because stuff like the menus are built with something that works like higher order functions. In PHP it's hard to write HOFs.
11:32:54 <Canar> hm, neat.
11:33:31 <lispy> it's not the best paper, but if you want to learn more about compiler construction it's a good tutorial
11:34:40 <lispy> one thing they do is describe a tagging scheme for 'immediate' values which i find annoying
11:34:56 <lispy> tagged ints are one of the things that absolutely drives me nuts about ocaml
11:34:57 <shapr> Haskell doesn't have an html templating plugin anywhere, so PHP is still better at processing xml/html. But that won't last long =)
11:35:17 <lispy> wasn't there a haskell source extensions to deal with taht?
11:35:37 <shapr> Yes, HaRP/HSP/etc but I want something more like Zope Page Templates.
11:35:50 <shapr> Wherease HSP is more like ASP/JSP.
11:36:14 * lispy has 0 experience with Zope, HSP, HaRP, etc ;)
11:36:23 <shapr> The advantage of ZPT is that all the code calls happen in attributes, so any xml capable editor can be used to edit the pages.
11:36:32 <lispy> only a bit of php to learn that it's nightmarish at times
11:36:42 <lispy> neat
11:37:02 <glguy> PHP doesn't encourage a separation of presentation and logic at all
11:37:11 <mwc> In fact, doesn't it encourage the mixing of them
11:37:24 <mwc> by more or less inlining the HTML in the php?
11:37:37 <glguy> writing PHP code is as bad was writing ASP3 code
11:38:09 <lispy> scala lets you mix xml with scala code
11:38:16 <shapr> ZPT does encourage separation of code and presentation.
11:38:50 <lispy> not a feature i'll be using in my term project, but it actually sounds like it could be useful sometimes
11:38:55 <mwc> lispy: I know what you mean. When you cosnider how efficient mlton is and that it uses C-like representation, Ocaml's tagging boggles the mind
11:39:33 <lispy> mwc: well, and i think ghc for example uses a spineless taggless representation...
11:39:46 <lispy> hmm...does that mean Int32's are unboxed?
11:39:48 <mwc> I wish I knew what spineless meant
11:39:54 * lispy too
11:40:08 <xerox> Without spine.
11:40:10 <mwc> But Spineless, Tagless G-machine sounds cool
11:40:26 <lispy> xerox: thanks for the 'clarification' ;)
11:40:34 <xerox> Anytime.
11:40:39 <mwc> But my invertebrate, unmarked, H-machine should pwn it
11:40:48 <ndm> spineless: f a b c is f (a,b,c), not (((f a) b) c)
11:41:04 <xerox> Cool.
11:41:11 <ndm> i.e. vector application
11:41:13 <mwc> so that just means it uncurries the functions?
11:41:14 <xerox> C is spineless then.
11:41:25 <ndm> yes, uncurries basically, where possible
11:41:29 <mwc> cool
11:42:05 <jgrimes_> I thought spinlessness had to do with graph reduction/construction?
11:42:10 <jgrimes_> spinelessness, even
11:42:26 <xerox> Constructivistisms.
11:42:29 <lispy> ndm: so that reduces the amount of closures and function calls needed?
11:42:51 <ndm> lispy, yes, massively!
11:42:59 <lispy> cool
11:43:22 <ndm> jgrimes_, it does, it means it builds one graph for f with 3 arguments in one step, instead of 3 graphs
11:44:47 <lispy> ndm: so is yhc also taggless and spineless?
11:45:16 * lispy notes that reading this paper gives him the urge to dust off his C parser and try to finish building a C99 compiler
11:45:40 <lispy> the grammar was so bad for C99 that i started and gave up there :)
11:45:46 <lispy> looking at this paper that was my mistake
11:46:08 <lispy> i should make an internal rep and work there extending the grammar as needed for testing
11:46:09 <jgrimes_> gcc doesn't even fully implement c99 does it?
11:46:20 <lispy> jgrimes_: probably by now
11:46:37 <lispy> jgrimes_: but i thought starting in haskell and only supporting C99 would make that whole bit easier
11:46:48 <jgrimes_> doesn't look like it
11:46:49 <jgrimes_> http://gcc.gnu.org/c99status.html
11:46:57 <ndm> lispy: tagged, i believe, as is GHC, I think
11:47:06 <mwc> lispy: you might be able to handle it in Parsec
11:47:23 <mwc> that gives you a lot of lookahead
11:47:24 <ndm> lispy: i am less sure exactly what tagged means, and the details associated with it
11:47:27 <lispy> mwc: ya, i just didn't know much parsec at the time and the C99 spec is long :)
11:47:33 <mwc> but parsing C is a nightmare...
11:47:48 <lispy> ndm: okay, i thought GHC used a spineless, tagless G-machine...
11:47:54 <ndm> alegedly tagged vs tagless makes little difference, but don't quote me on that
11:48:14 <mwc> lispy: have a look at SPECTER
11:48:16 * lispy puts ndm's words in HWN ;)
11:48:16 <ndm> i thought so too, but the guy who wrote the Yhc backend thinks otherwise
11:48:26 <lispy> mwc: what is SPECTER?
11:48:29 <mwc> lispy: or rather, SPECS
11:48:37 <lispy> mwc: what is it?
11:48:39 <xerox> > iterate (uncurry (:) . foldl (\(p,xs) x -> (x,p+x:xs)) (0,[])) [1]
11:48:41 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
11:48:53 <mwc> it's a paper describing an alternate syntax for C++ that's LALR parsible and much more consistent
11:48:58 * lispy has a copy of the final C99 spec he got from google, even though that's probably technically illegal
11:49:22 <mwc> http://en.wikipedia.org/wiki/Significantly_Prettier_and_Easier_C++_Syntax
11:49:24 <lispy> mwc: is it equivalent in terms of the language it defines?
11:49:25 <lambdabot> http://tinyurl.com/yesqvs
11:49:40 <lispy> oh,  i wasn't going to even try C++
11:49:44 <lispy> that's much worse than C :)
11:49:48 <mwc> lispy: yeah, they claim it represents 100% of the syntactic nuances of C++
11:49:58 <lispy> mwc: cool!
11:50:01 <mwc> right, but you should be able to reduce it to C
11:50:21 <lispy> i'm not sure that the C subset of C++ is C99 though...
11:50:33 <lispy> that could take a lot of reasoning to figure otu :)
11:50:35 <mwc> Well, it's a starting point
11:50:41 <lispy> not that i have time for it anyway
11:50:45 <lispy> just a fleeting interest
11:50:51 <mwc> ]void (*set_new_handler(void (*)(void)))(void); becomes func set_new_handler : (^(void->void) -> ^(void->void));
11:51:04 <lispy> mwc: yes, and and despite my resistance, it's a good idea
11:51:06 <svref> Is there some way to have emacs make :module commands given to GHCi be persistant across C-c C-l loads?
11:51:26 <pejo> C++ and C99 dont' agree on some things, for sure. But stuff is probably available as extensions in gcc.
11:51:57 <lispy> mwc: oh, so they do change the concrete syntax
11:52:14 <_velco> SPECS is very nice
12:00:14 <ibid> C has never been a subset of C++
12:00:23 <kpreid> uncurry (liftM2 (,)) -- better way to write this? or a name for it?
12:00:47 <dolio> ?type uncurry (liftM2 (,))
12:00:48 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => (m a1, m a2) -> m (a1, a2)
12:01:08 <fasta> kpreid: not that I know of
12:01:30 <dolio> ?type (&&&)
12:01:32 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:01:38 <kpreid> I'm actually using it with Maybe
12:01:52 <br1> ? type (,)
12:01:57 <br1> ?type (,)
12:01:59 <lambdabot> forall b a. a -> b -> (a, b)
12:02:11 <fasta> svref: You can define a module with those modules and then reload that?
12:02:18 <roconnor> @seen shapr
12:02:18 <lambdabot> shapr is in #ScannedInAvian, #haskell-blah and #haskell. I last heard shapr speak 6m 36s ago.
12:02:44 <fasta> svref: (and of course you could learn Emacs Lisp and implement it)
12:04:04 <lispy> ibid: i call it the C subset of C++, which is my personal short hand for the nearly C part of C++
12:04:19 <svref> fasta: my hope would be to include hidden symbols of multiple packages, ala ":module + *Traffic.Data", but I don't think the "dummy module" appraoch will do this.
12:04:37 <lispy> svref: what sort of traffic work are you doing?
12:04:47 <ibid> lispy: you are not alone. and there is nothing wrong with it, as long as you and anybody you discuss it with know that it's not literally true
12:04:56 <svref> the doomed-to-failure kind.  :)
12:04:57 <lispy> ibid: :)
12:05:23 <lispy> svref: how so?  I'm curious because i work for a company which produces simulation software for macro and micro traffic simulations
12:05:40 <ibid> the C++ committee seems to consider some of the stuff in C99 bad
12:05:46 <svref> lispy: a simulator that assesses the lane positioning choice of bicyclists on traffic throuput
12:06:08 <lispy> svref: do you integrate this with any existing simulation software?
12:06:13 <lispy> svref: vissim for instance?
12:06:29 <svref> lispy: nope.
12:06:34 <svref> Love to talk to you about it
12:06:38 <fasta> svref: I don't understand why you would want to access hidden symbols in the first place.
12:06:58 <svref> fasta: because I have a bug.
12:07:08 <lispy> svref: yeah, i don't know much about traffic personally, but i'm learning bits and pieces from working with the source code
12:07:14 <fasta> svref: You mean there's a bug in other peoples libraries?
12:07:22 <svref> fasta: no, in mine
12:07:39 <fasta> svref: if they are your own, why not load those libraries, fix it and go on?
12:08:42 <svref> Because to actually pick at the bug I have to unravel 19 levels of nested closures, which requires a lot of recompile.  That recompile then necessitates qutie a bit of command-recall to get my test-case in scope again.
12:08:58 <lispy> svref: i dunno if this is all that related, but vissim has a 'driver behavior' plugin sort of system...from what i understand there is an API and you can use dlls (meaning haskell is an option)
12:09:57 <svref> lispy: okay, I'm writing that down.  Is driver behavior all that variable?
12:10:12 <kpreid> svref: "quite a bit"? do you know that :module can be given multiple module names?
12:10:38 <lispy> svref: i don't know a lot of details...but since the behavior is defined in sort of external code i would imagine youu can do mostly whatever you want
12:10:46 <lispy> svref: i could find out more if you like
12:11:14 <svref> kpreid: that helps
12:11:48 <svref> lispy: lemme google it on my own time...If I need help, well, you seem to be here mighty often.
12:11:50 <CosmicRay> does anyone have references for algorithms on rendering, say, 1048576 as 1.0M and 92 as 1m32s ?
12:11:56 <CosmicRay> they don't have to be in haskell
12:12:28 <lispy> svref: yes, good luck finding info on google, from what i understand there is very little info on the web about vissim.  I'd be happy to help though a syou mention.
12:12:36 <lispy> svref: about to go to lunch myself :)
12:12:47 <kpreid> svref: also check if :def is useful (defining ghci commands)
12:12:51 <svref> yeah, time for that as well, but first I must kill this BUG!
12:13:02 <thou>  CosmicRay you could check how linux' 'ls -lh' does it (for file sizes)
12:13:27 <CosmicRay> thou: good point.
12:13:42 <Igloo> Wouldn't it be quicker just to write your own, though?
12:14:28 <thou> yeah
12:16:59 <CosmicRay> thou: 488-line human.c in coreutils 5.97
12:17:06 * CosmicRay had hoped for something less complex ;-)
12:17:42 <svref> CosmicRay: so write it in 1 line of haskell...
12:20:22 <Igloo> It sounds like a handy cabal package
12:20:46 <fasta> Is Cabal working already?
12:20:55 <Igloo> Cabal is, yes
12:21:05 <fasta> Well, that I can do cabel-get <foo-package>
12:21:12 <CosmicRay> Igloo: I plan to put it in MissingH, along with my just-finished module for tracking progress of a long process (including estimating the amount of time until completion), and my soon-to-be-written generic console status bar code
12:21:16 <Igloo> cabal-get isn't AFAIK, no
12:21:43 <fasta> Igloo: so the use of Cabal now is that package maintainers can make packages easily?
12:21:50 <Igloo> Well, if you do I might put it in a sensibly named package  :-)
12:22:38 <fasta> CosmicRay: tracking progress?
12:22:49 <Igloo> fasta: Well, that's one use, yes
12:23:01 <CosmicRay> fasta: say, of a download of a directory of files.
12:23:08 <fasta> CosmicRay: oh, ok.
12:23:29 <CosmicRay> fasta: my module can keep track of the progress of the download of each individual file, even in multithreaded situations, as well as the overall progress, and produce a speed and ETA of any of these at any given instant
12:24:00 <fasta> CosmicRay: the same as apt does when downloading packages, nice
12:24:17 <CosmicRay> fasta: exactly, and my coming-soon status bar module will be based on apt as well.
12:24:33 <edwardk> heh, was playing around with my substructural lattice. if you think of monads providing strictness to a lazy language, you can also view laziness as a comonad in a strict language. extract = force, duplicate = lift, coextend lets you turn a function that takes a lazy argument and returns an eager argument into a calculation that takes a lazy argument and returns a lazy argument.
12:24:45 <svref> how come the return type of (do putStrLn "foo" ; return [1..10]) is reported as IO [t] and not IO [Int]?  And why, when I type it to the toplevel, doesn't it print out [1,2,3,4,5,6,7,8,9,10]?
12:24:49 <edwardk> kind of a reversal of moggi's computational lambda calculus
12:25:20 <edwardk> (been going through the lattice a pair of nodes at a time, got to strict<->lazy)
12:25:35 <edwardk> not all that deep, just amusing
12:25:50 <roconnor> svef: return doesn't print stuff.
12:27:38 <svref> roconnor: apperantly not.
12:28:27 <br1> edwardk: That sounds very interesting.  unfortunatelly my theoretical background is small
12:28:43 <roconnor> svref: I would expect the return type to be (Num t) => IO [t]
12:28:58 <roconnor> svref: I would expect the return type to be (Num t, Enum t) => IO [t]
12:29:45 <fasta> CosmicRay: Do people actually buy your GPL code for proprietary projects?
12:29:58 * shapr yodels clearly
12:30:05 <shapr> roconnor: You screamt?
12:30:25 <CosmicRay> fasta: I haven't had anyone do so yet
12:30:32 <CosmicRay> fasta: but it would be great if someone did ;-)
12:30:49 * shapr is getting paid to write BSD3 code
12:31:10 <mwc> Even more impressive
12:31:11 <shapr> edwardk: Hey that's a cool idea, you gotta blog it.
12:31:42 <shapr> edwardk: Have you seen whatshisname's calculus that cuts monads into opportunity and necessity? musasabi pointed it out to me.. I can find url if you want.
12:31:51 <mwc> shapr, I'm surprised if they're paying you to write code and letting it be open sourced, it wouldn't at least be GPL to protect it from rival competitors
12:31:52 * shapr boings furiously
12:32:09 <roconnor> shapr: I'm editing my article.  I expect to finish it this weekend or sooner, modulo comments from the editor ;)
12:32:25 <shapr> mwc: It's Haskell code, those who are smart enough to read and understand it are unlikely to steal it ;-)
12:33:01 <fasta> The more people that use the code the less bugs it will contain. At some development rate it's better to put a BSD license on it, I think.
12:33:19 <shapr> I sent a long crazy email off to Kragen Sitaker about possible uses of software defined radio. I'm tempted to turn it into a blog entry.
12:33:27 <edwardk> shapr: yeah alex nanevski, talked to him a bit about how it fit into my stuff at the ICFP.
12:33:41 <shapr> Oh was he at ICFP? I wish I'd met him.
12:34:00 <shapr> Hey, I got invited to be on the CUFP committe, is that insane or what?
12:34:05 <edwardk> yeah, he thought i had to be a philosophy major coz i knew who nuel belnap was =)
12:34:12 <shapr> Never heard of him
12:34:21 * shapr googles
12:34:42 <edwardk> look up display logic and gaggle theory
12:35:11 <fasta> [annoying google]Are you googling at MSN ;) [/annoying google]
12:35:13 <kosmikus> shapr: congratulations. who's CUFP chair next year?
12:35:28 <shapr> Kathleen Fisher.
12:35:38 <kosmikus> ok, good.
12:35:39 <shapr> I wonder who the heck suggested *me* for the CUFP committee?
12:35:57 <shapr> I figure I'd be an excellent participant, but I don't even know what the committee does!
12:36:09 <pejo> shapr, administration. ;)
12:36:11 <shapr> oh
12:36:16 <edwardk> paperwork =)
12:36:24 <fasta> shapr: maybe you can collect all the $$$.
12:36:40 <kosmikus> as far as I recall, CUFP used to be invitation-only for presentations in the past years. so you probably have to suggest other people to invite and give talks.
12:36:53 <shapr> fasta: Hah, they included the profit CUFP made last year and lemme tell you, there's not even enough for three of those dollar signs.
12:37:10 <kosmikus> fasta: there's no $$$ in organizing conferences ...
12:37:14 <fasta> @where CUFP
12:37:15 <lambdabot> I know nothing about cufp.
12:37:26 <roconnor> @docs Control.Monad.RWS
12:37:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS.html
12:37:30 <ValarQ> fasta: better collecting €€€ ;)
12:37:56 <pejo> fasta, www.galois.com/cufp
12:38:23 <fasta> Oh, the commercial users conference. Nice
12:38:52 <fasta> @where+ cufp  www.galois.com/cufp
12:38:53 <lambdabot> Done.
12:38:58 <fasta> @where cufp
12:38:59 <lambdabot> www.galois.com/cufp
12:39:20 <shapr> yay
12:39:26 <shapr> @karma+ fasta
12:39:27 <lambdabot> fasta's karma raised to 2.
12:39:40 <shapr> For administration
12:39:44 <fasta> heh
12:39:53 <shapr> It's important to do that sort of thing :-)
12:40:03 <roconnor> @type Control.Monad.Arrow.first
12:40:04 <lambdabot> Couldn't find qualified module.
12:40:11 <roconnor> @docs Control.Monad.Arrow
12:40:12 <lambdabot> Control.Monad.Arrow not available
12:40:19 <roconnor> @docs Control.Arrow
12:40:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
12:40:21 <shapr> roconnor: Arrow isn't in monad
12:40:28 <shapr> @type Control.Arrow.first
12:40:29 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
12:41:01 <newbcoder> anyone have a good resource on haskell + opengl ?
12:41:48 <fasta> newbcoder: There was a tutorial on it recently on planet.haskell.org
12:42:06 <fasta> newbcoder: other than that it's basically the same as C + opengl, IIRC.
12:42:37 <shapr> newbcoder: Syzygy- wrote a tutorial.
12:44:38 <hygge> hello!
12:45:09 <hygge> can i somehow use putstr and the esacpe char to clear the screen in hugs?
12:46:34 <CosmicRay> hygge: google for vt100 terminal codes, perhaps
12:46:48 <hygge> okej
12:46:49 <hygge> :)
12:47:00 <CosmicRay> or, if you're on unix, the poor man's way is: system "clear"
12:47:26 <sjanssen> hygge: just type :! clear
12:47:50 <sjanssen> assuming you're at the interactive prompt
12:48:45 <hygge> i want to do it from a script!
12:48:47 <hygge> :P
12:49:08 <CosmicRay> then use the system command I gave
12:49:23 <hygge> aha! :)
12:50:05 <shapr> Hey, I just had a great idea...
12:50:33 <shapr> or at least a cheesy idea..
12:51:19 <thetallguy> put bacteria in milk and wait?
12:51:22 <shapr> I'd like to have shapr@freenode.net forward to some other address.
12:51:25 <shapr> thetallguy: hah!
12:51:33 <shapr> thetallguy: Hey, aren't you the tall guy I had lunch with at Haskell Workshop?
12:51:44 <thetallguy> That depends
12:51:52 <newbcoder> lol
12:51:54 <thetallguy> on whether you had a good lunch or not.
12:52:06 <thetallguy> Clifford Beshers, Linspire, Inc.
12:52:13 <shapr> Yes, that's who I meant :-)
12:52:16 <thetallguy> lol
12:52:18 <xerox> shapr: the network provides such an addresS?
12:52:23 <shapr> No, but it should.
12:52:34 <shapr> Either that or we should provide that for #haskell regulars
12:52:39 <nomeata> @pl let reverse (a:st) = reverse st ++ [a] in reverse
12:52:39 <lambdabot> fix ((`ap` tail) . (. head) . (. return) . flip . ((++) .))
12:52:43 <xerox> shapr: wasn't TallOak the onet at AH?
12:52:45 <shapr> I'd often like to send email to xerox@#haskell or something
12:53:01 <xerox> There is MemoServ in fact.
12:53:01 <shapr> xerox: Yeah, but thetallguy is someone else.
12:53:10 <shapr> Yeah, but it doesn't have RSS or something.
12:53:47 <xerox> That's a strange integration...
12:54:10 <shapr> I'm not always on irc :-)
12:54:20 <shapr> (though most people probably don't believe me when I say th)
12:54:41 <xerox> Then lambdabot @tell is what covers best your needs...
12:54:56 <shapr> Yeah, but some people rarely show up on #haskell and I still want to contact them.
12:55:23 <shapr> Salut cinema
12:55:34 <cinema> shapr, salut !
12:55:47 <cinema> shapr, I'm impressed
12:56:09 <shapr> Pourquoi?
12:56:10 <xerox> shapr: idea! Use dons's simple-bot tutorial code to build a memoserv2rss.hs
12:56:33 <cinema> shapr, your french accent is perfect
12:56:51 <shapr> It is? Did I meet you at ICFP or Haskell Workshop?
12:57:23 <shapr> I thought I only spoke Swedish and a bit of Dutch at ICFP?
12:57:33 * mwc gives up trying to craft a french message.
12:57:35 <cinema> shapr, In fact no. I was at ICFP last year, and didn't come this year
12:57:40 <shapr> quelle dommage...
12:57:41 <mwc> at this point, I can't do anything but read it
12:58:01 <cinema> next year ICFP will be in Europe...
12:58:01 <shapr> I met a dutch woman day before yesterday while unicycling.
12:58:31 <mwc> In 'bama?
12:58:51 <shapr> Yeah, in Birmingham.
12:59:20 <shapr> She didn't have much of an accent, but after a coupla sentences I had to say "Spreek u nederlands?"
12:59:21 <edwardk> heh, while you are amused to have met a dutch person, think how comparatively surprised she must have been to meet a unicycling american who knew dutch! =)
12:59:29 * ihope loads up cmd and goes over to GHC
12:59:50 <ihope> Really, I wonder why GHC isn't in PATH.
13:00:31 <ihope> Oh, a period there instead of a backslash.
13:00:34 <shapr> edwardk: Well, I told her I don't really know Dutch, but that I speak a decent amount of Swedish.
13:00:38 <edwardk> heh
13:01:14 * ihope fixes
13:01:15 <shapr> It was fun and entertaining. I don't often meet expatriates in Birmingham. At least, not outside of the university.
13:01:33 <ihope> There.
13:02:57 <edwardk> yeah, quite the opposite here, i have representatives of most parts of europe and it turns out someone from each inhabited continent within 100 feet of my current office. ;)
13:03:48 <xerox> @yow
13:03:49 <lambdabot> I smell a RANCID CORN DOG!
13:04:11 <shapr> @y0w!
13:04:11 <lambdabot> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!!
13:04:58 <xerox> Today I bought sacher torte, double cream, and pure chocolate with chili.
13:05:08 <xerox> I think that's too much for one day.
13:05:24 <ihope> ./Modules.hs: file name does not match module name `Main'
13:05:55 * ihope pings in a direction that is not directly away from dons
13:07:55 <dmead> are let expressions generally considered good practice?
13:08:19 <shapr> dmead: They're an explicit source of laziness.
13:08:46 <dmead> ahh
13:09:00 <dmead> yea they make things seems clearer as well
13:09:04 <dmead> brb
13:09:32 <xerox> dmead: I think of let { bindings } in expression as emphasizing the bindings importance over the expression, and expression where { bindings } the other way around.
13:09:48 <glguy> as let and where do different things, I can't see how would can be worse than the other
13:10:01 <shapr> Not worse, just different :-)
13:11:28 <xerox> Different?
13:13:51 <glguy> let ... in ... creates a single expression
13:14:06 <glguy> where applies to a function declaration
13:14:13 <glguy> and across the guards of that declaration
13:14:15 <Philippa> xerox: I see it as strictly recommended reading order
13:14:33 <ihope> Not necessarily a function declaration.
13:14:42 <ihope> > let x = y where y = 3 in 3
13:14:43 <lambdabot>  3
13:14:44 <ihope> Erm.
13:14:49 <ihope> > let x = y where y = 3 in x
13:14:51 <lambdabot>  3
13:14:52 <Philippa> that's not necessarily emphasis until you start doing a writing style analyses, sometimes a where encourages you to spend more time looking at the details because the rest's so simple
13:14:53 <ihope> No functions.
13:15:05 <Philippa> where is "introduce concepts by usage then define them", I guess
13:15:09 <glguy> ihope: you decared x and that allows you to use a where
13:15:26 <ihope> Except that it's secretly 'show (3 :: Integer'.
13:15:58 <xerox> Philippa: good analysis.
13:16:10 <SamB> ihope: um
13:16:17 <SamB> > show (3 :: Integer)
13:16:18 <lambdabot>  "3"
13:16:20 <ihope> And I'm secretly good at typos.
13:16:23 * SamB doubts it
13:16:40 <ihope> SamB: that's show (show (3 :: Integer)) :-P
13:16:49 <glguy> SamB: because yours is secretly: show (show (3 :: integer))
13:16:49 <SamB> no it isn't!
13:17:08 * SamB contends that all these expressions have a print stuck in front
13:17:11 <shapr> ooh, ghc6.6 debs?
13:17:23 <glguy> SamB: print sends to std out
13:17:30 <SamB> glguy: yes it does!
13:17:32 <glguy> SamB: and is just putStrLn . show anyway :-[
13:17:35 <glguy> :-p *
13:17:37 <xerox> = print
13:17:39 <ihope> And lambdabot sends to IRC.
13:17:44 <SamB> yes I know
13:17:51 <ihope> And... hmm.
13:17:57 <dmead> xerox: they both do the same thing right?
13:17:59 <SamB> I had to convince dons that the same thing would work for quickCheck ;-)
13:18:10 <xerox> dmead: you can define print = putStrLn . show.
13:18:26 <dmead> xerox: i just need something to make my code clearer =)
13:18:30 <SamB> xerox: most people who define print do it that way, too ;-)
13:18:53 <xerox> I think it *is* actually defined like that.
13:18:58 <xerox> @index print
13:18:58 <lambdabot> System.IO, Prelude
13:19:02 <xerox> @source System.IO
13:19:02 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
13:19:09 <xerox> dmead: what is your code?
13:19:10 <SamB> it would perhaps be possible to define it other ways
13:19:14 <ValarQ> ?users #Haskell.es
13:19:14 <lambdabot> Maximum users seen in #Haskell.es: 1, currently: 0 (0.0%), active: 0 (NaN%)
13:19:17 <SamB> and still comply with the standard
13:19:23 <xerox> print           :: Show a => a -> IO ()
13:19:23 <xerox> print x         =  putStrLn (show x)
13:19:30 <SamB> however, there really isn't much point
13:19:33 <dmead> xerox: i
13:19:36 <dmead> woops
13:19:37 <SamB> so afaik nobody does ;-)
13:19:43 <dmead> xerox: im working on a theorem prover
13:19:51 <dmead> and i've got massive function passing in some places
13:19:53 <xerox> wow.
13:19:57 <SamB> (it would have to do the same thing anyway ;-)
13:20:17 <dmead> so i just cleaned it up by using some let statements instead of needing lots of ((())))
13:20:25 <dmead> it started to look like lisp =[
13:20:58 <SamB> I learned how to use screen(1) today ;-)
13:21:04 <xerox> #haskell is a good code optimizer.
13:21:26 <SamB> dmead: sometimes that happens ;-)
13:21:51 <dmead> ;)
13:22:09 <SamB> but at least, in Haskell, (x) and x mean the same thing ;-)
13:22:20 <therp> @remember xerox #haskell is a good code optimizer.
13:22:39 <SamB> @quote xerox
13:22:39 <lambdabot>  #haskell is a good code optimizer.
13:22:44 <SamB> @quote xerox
13:22:44 <lambdabot>  > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
13:22:51 <dmead> hehe yea
13:22:59 <dmead> i like it better than ml too
13:23:10 * SamB was just checking to make sure that lambdabot was working right and not missing quotes
13:23:10 <dmead> ML functions can only have one parameter
13:23:24 <fasta> Can you do C-h k C-u C-k in the newest Haskell mode and see what happens?
13:23:37 <SamB> dmead: oh, I thought you meant that #haskell was better than haskell-cafe@haskell.org ;-)
13:23:39 <xerox> Ah, I had one by roconnor.
13:23:42 <ihope> Just like Haskell! :-P
13:23:43 <dmead> lol what
13:23:48 <SamB> when you said "ml"
13:23:49 <dmead> oh lol
13:23:56 <dmead> ah
13:24:00 <dmead> no i meant the language
13:24:08 <dmead> the parens in ML don't mean anything
13:24:12 <fasta> I am observing buggy behaviour here.
13:24:19 <dmead> you can just plaster them anywhere
13:24:36 <SamB> well, they presumably mean the same thing as in math
13:24:49 <SamB> (that is: this is a subexpression!)
13:24:57 <dmead> right right
13:24:58 <Tom_> hi, can someone tell me the name (meaning) of the @ - character, so i can look it up?
13:25:06 <dmead> as?
13:25:09 <kpreid> Tom_: as-pattern
13:25:16 <Tom_> thanks
13:25:18 <dmead> you don't need @
13:25:20 <dmead> use x:xs
13:25:24 <dmead> or y:ys
13:25:24 <dmead> etc
13:25:32 <SamB> @ can be useful
13:25:34 <xerox> @remember roconnor <roconnor> xerox: I'm dumber than a turning machine.
13:25:36 <xerox> haha.
13:25:36 <SamB> especially with record types
13:25:39 <glguy> xxs@(x:xs)
13:25:45 <xerox> Good.
13:25:49 <dmead> ahh
13:26:00 <therp> shouldn't that be turning, or is that the joke?
13:26:11 <therp> shouldn't that be turing, or is that the joke?
13:26:12 <therp> damn! :)
13:26:12 <SamB> therp: he meant to say "turing"
13:26:14 <dmead> thats the joke
13:26:19 <dmead> oh
13:26:20 <dmead> yea
13:26:21 <xerox> therp: you're obviously joking.
13:26:22 <dmead> turing
13:26:22 <nomeata> thebug: shoun't that be shoudn't that be turing
13:26:23 <roconnor> damn
13:26:31 <nomeata> hmpf. should have gon to therp
13:26:32 <roconnor> @quote me
13:26:32 <lambdabot> me hasn't said anything memorable
13:26:35 <roconnor> @quote roconnor
13:26:36 <lambdabot>  <roconnor> xerox: I'm dumber than a turning machine.
13:26:44 <roconnor> @quote roconnor
13:26:45 <lambdabot>  life lesson from today: 1 closure is nice, 500 000 closures sucks
13:26:52 <dmead> someone get me a delorean
13:26:54 <dmead> so i can be nerd cool
13:26:58 <dmead> =(
13:27:16 <SamB> dmead: what meanith thou?
13:27:31 <dmead> didn't you see back to the future?
13:27:38 <Adamant> @quote dons
13:27:39 <lambdabot>  sometimes this channel is weird
13:27:41 <SamB> oh, I don't suppose anyone knows if it is safe to compile GHC with -j2?
13:27:46 <dmead> (im going off topiccc)
13:27:46 <xerox> Appropriate.
13:27:52 <dmead> =p
13:27:58 <xerox> SamB - I did, and it worked, sometime ago.
13:28:05 <xerox> In fact I did -j3 I think.
13:28:13 <dmead> ghc compiles to bytecode?
13:28:15 <dmead> or machine
13:28:22 <SamB> I don't want to hog Lemmih's CPUs that much!
13:28:35 <xerox> Dual core!
13:28:46 <dmead> quad core =(
13:29:09 <glguy> dmead: the end-result of using GHC is machine code
13:29:13 <SamB> dmead: machine, except GHCi
13:29:15 <glguy> gcc helps it get to that point
13:29:22 <dmead> ahh
13:29:43 <dmead> and its really running machine code?
13:29:53 <SamB> uh huh
13:29:55 <dmead> theres not a layer of bytecode getting run as well?
13:30:04 <shapr> @quote
13:30:04 <lambdabot> malig says: quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
13:30:13 <SamB> unless you are running something in GHCi! in which case you have an unholy mixture of machine code and bytecode ;-)
13:30:21 <dmead> gotcha
13:30:21 <dmead> hot
13:30:34 <dmead> yea i guess ghci is just for debugging with ghc librarys?
13:30:41 * SamB detaches the compilation and starts to
13:30:43 <SamB> er.
13:30:44 <SamB> top
13:30:48 <thetallguy> dmead, there's a RunTimeSystem
13:31:01 <dmead> hmm
13:31:07 <dmead> should i not be using hugs?
13:31:35 <SamB> hugs is okay
13:31:38 <SamB> it loads faster
13:31:48 <dmead> kk
13:31:49 <glguy> hugs is better if you don't understand ghci's error messages
13:31:57 <SamB> because it has a really speedy compiler
13:32:10 <dmead> from what i've seen so far ghci is just like SML
13:32:12 <SamB> once, I had to use both GHCi *and* hugs to figure out some type errors...
13:32:16 <fasta> Hugs requires more type annotations.
13:32:18 <dmead> SMLNJ i mean
13:32:30 <SamB> (I was replacing a type synonym with a newtype)
13:32:37 <fasta> If you only do Haskell 98 stuff, I would recommend Hugs, I think.
13:32:38 <dmead> ah
13:33:02 <dmead> yea i wanna compile my prover down to machine code when it's done
13:33:03 <mwc> SamB, I did it with -j2 on a PPC/darwin machine a while back, and it died, 6.4 I think
13:33:08 <SamB> GHCi lets your code run faster if you compile some of your modules before running
13:33:21 <SamB> mwc: well so far the output of tload looks encouraging
13:33:50 <SamB> I've got the load average up to 2.00
13:34:12 <SamB> whoa...
13:34:14 <SamB> 2.16?
13:34:40 <mwc> Load average doesn't have anything to do with cpu load
13:35:05 <SamB> doesn't it?
13:35:08 <mwc> it's something to do with the number of processes being scheduled or somtehing
13:35:13 <mwc> it's quite strange and not what you'd expect
13:35:20 <pejo> SamB, number of processes in the run queue that are waiting to be scheduled
13:35:29 <nomeata> I'd guess number of running (not sleeping) process at a certain time
13:36:18 <mwc> For single CPU systems that are CPU-bound (where there are on average no processes in uninterruptible sleep), one can think of load average as a percentage of system utilization during the respective time period. For systems with multiple CPUs, the number needs to be divided by the number of CPUs in order to get a percentage.
13:37:44 <SamB> mwc: but it is more fun not to divide ;-)
13:37:53 <dmead> boo division
13:37:57 <SamB> because that way you can say you have 200% CPU usage!
13:40:00 <dmead> it wont automatically scale to 50% for one core being at max and the other at idle?
13:40:41 <SamB> hmm.
13:40:53 * SamB is having trouble with stage2
13:41:04 <shapr> I beat the guy at the end.
13:41:09 <dmead> stage2 of?
13:41:20 <SamB> shapr: send me your patch!
13:41:23 <dmead> pac man?
13:41:25 <roconnor> @seen greend
13:41:26 <lambdabot> I haven't seen greend.
13:41:33 <shapr> Yeah, where is Robin?
13:41:34 <SamB> no! GHC building!
13:41:45 <dmead> =(
13:41:54 <dmead> i let portage worry about that
13:42:26 <SamB> that doesn't work so well for a "before and after" benchmarking...
13:42:37 <SamB> also doesn't work on Debian
13:43:35 <ihope> Oh, uh, right.
13:43:46 <ihope> GHC doesn't like lambdabot.
13:43:46 <pejo> SamB, isn't it rather easy to get it to build from source packages, if that is your wish?
13:44:09 <SamB> pejo: that also doesn't work too well for "before and after" benchmarking...
13:44:13 <ihope> "./Modules.hs: file name does not match module name `Main'"
13:44:33 <pejo> SamB, oh, you want multiple versions usable at the same time.
13:44:55 <SamB> http://news.gmane.org/find-root.php?group=gmane.comp.lang.haskell.cvs.ghc&article=17205
13:45:00 <lambdabot> Title: Gmane Loom, http://tinyurl.com/yd2ebn
13:45:43 <shapr> Has anyone tried to build HaXml with the ghc6.6 debs?
13:45:50 <shapr> HaXml 1.13.2 specifically?
13:46:27 <SamB> ... did I mention I'm building with GHC 6.6?
13:46:45 <ihope> There's a GHC 6.6 now?
13:47:01 <SamB> ... you hadn't heard?
13:47:02 <dmead> indeed
13:47:10 <shapr> doh, user error
13:47:34 <dmead> poop
13:47:38 <dmead> 6.6 still isnt in portage
13:47:41 <dmead> =/
13:49:23 <SamB> dmead: got the Haskell overlay?
13:49:30 <dmead> negative
13:49:33 <dmead> wheres that at?
13:49:39 <xerox> #gentoo-haskell
13:49:47 <xerox> Or was it #haskell-gentoo?
13:49:53 <xerox> It reminds me of the let/where thing.
13:49:56 <dmead> lol
13:49:57 <dmead> =
13:49:58 <dmead> =p
13:50:04 <dmead> its gentoo-haskell
13:50:20 <SamB> huh...
13:51:09 <dmead> http://shadowdane.shackspace.com/cats_files/astronaut.jpg
13:51:11 <lambdabot> http://tinyurl.com/y7qgew
13:51:11 <dmead> yes.
14:00:14 <shapr> musasabi: HAppS.cabal.ghc66 complains that it can't find mtl-any, do you get that problem on your ghc6.6 install?
14:00:30 <SamB> hmm
14:00:36 <SamB> typecheck/TcRnDriver.lhs:1098:33:
14:00:36 <SamB>     Couldn't match expected type `Dependencies'
14:00:36 <SamB>            against inferred type `HscTypes.WhetherHasFamInst'
14:02:00 <SamB> for some reason this only crops up in stage2...
14:02:10 <SamB> stage1 built fine...
14:02:42 <glguy> has anyone here used Nemerle
14:05:43 <CosmicRay> hmm, why is this invalid:
14:05:48 <CosmicRay> class Renderable a where
14:05:48 <CosmicRay>     toRenderable :: (Floating b, Ord b) => a -> b
14:05:54 <CosmicRay> instance (Integral a, Ord a) => Renderable a where
14:05:54 <CosmicRay>     toRenderable = fromIntegral
14:06:03 <musasabi> shapr: no. mtl should be shipped with ghc.
14:06:06 <CosmicRay> it complains that this is an illegal instance declaration
14:06:15 <musasabi> shapr: did you run Setup configure?
14:06:28 <SamB> CosmicRay: um.
14:06:29 <CosmicRay> yet even the prelude has things like Integral a => Real (Ratio a) as instances
14:06:31 <SamB> oh. right.
14:06:32 <shapr> musasabi: Sorry user error, I need to install libghc6-mtl-dev
14:06:39 <SamB> oh.
14:06:54 <SamB> aren't you supposed to have a type constructor in the instance head?
14:07:15 <shapr> I use a stick!
14:07:50 <CosmicRay> hrm, you can have an Int as an instance....
14:09:01 <Cale> SamB: doesn't that?
14:09:10 <CosmicRay> ah, never mind, I can get what I want with fromRational . toRational
14:09:19 <SamB> "a" is not a type constructor!
14:09:24 <Cale> SamB: oh, the other one
14:09:27 <Cale> I see :)
14:09:36 <CosmicRay> or maybe not.
14:09:37 <xerox> CosmicRay: you can't get pi :)
14:09:40 <SamB> the class isn't supposed to have an instance head
14:09:48 <Cale> (I should read the entire conversation before responding :)
14:10:10 <SamB> > toRational pi
14:10:12 <lambdabot>  884279719003555%281474976710656
14:10:24 <xerox> Cough.
14:10:34 <SamB> > (fromRational . toRational) pi == pi
14:10:35 <lambdabot>  True
14:10:43 <SamB> see! it is lossless!
14:10:45 <xerox> The proof is too difficult for me now, Cale might know it though.
14:10:53 <ValarQ> xerox: sure you can, as long as you don't need it's value
14:11:04 <SamB> xerox: Are you going to tell me that pi is not pi?
14:11:33 <Cale> what, that pi is irrational?
14:11:45 <xerox> I'm telling you that fromRational . toRational is not an identity.
14:11:46 <shapr> I like this new "[X of N]" compiling thing that GHC6.6 does.
14:11:52 <xerox> Cale: exactly.
14:11:54 <Cale> toRational pi just produces a rational approximation to pi
14:12:03 <Cale> > toRational (pi :: Float)
14:12:05 <lambdabot>  13176795%4194304
14:12:05 <SamB> Cale: what do you think pi is?
14:12:12 <ValarQ> shapr: whats that?
14:12:17 <glguy> ?type pi
14:12:19 <lambdabot> forall a. (Floating a) => a
14:12:32 <Cale> of course, the floating point representation is again just an approximation :)
14:12:33 <SamB> at whatever type is the default, I mean
14:12:39 <shapr> ValarQ: [ 1 of 67] Compiling HAppS.Util.ByteStringCompat ( src/HAppS/Util/ByteStringCompat.hs, dist/build/HAppS/Util/ByteStringCompat.o )
14:12:51 <ValarQ> shapr: oh, that thingie
14:13:06 <xerox> Ah, that's how it works.
14:13:06 <SamB> @scheck \x -> (fromRational . toRational) x == x
14:13:08 <lambdabot>  Add a type signature
14:13:09 <xerox> Howdy monochrom.
14:13:11 <glguy> heh, we don't know what pi is, but we know what pi is not
14:13:11 <Cale> pi is a real number, which might be represented as a particular set of rationals.
14:13:14 <ValarQ> shapr: i thought you meant some new language-extension, heh :)
14:13:15 <roconnor> > (fromRational . toRational) (10**(-300)) == (10**(-300)::Double)
14:13:15 <SamB> @scheck \x -> (fromRational . toRational) x == (x :: Double)
14:13:16 <lambdabot>  True
14:13:17 <lambdabot>  add an instance declaration for (Serial Double)
14:13:17 <lambdabot>   In the definition of `c...
14:13:25 <SamB> @scheck \x -> (fromRational . toRational) x == (x :: Float)
14:13:26 <lambdabot>  add an instance declaration for (Serial Float)
14:13:26 <lambdabot>   In the definition of `vs...
14:13:29 <SamB> @check \x -> (fromRational . toRational) x == (x :: Double)
14:13:31 <lambdabot>  OK, passed 500 tests.
14:13:34 <psi> I wonder when debian sid'll get ghc 6.6.
14:13:36 <monochrom> jihad xerox. err I mean jiihaa
14:13:38 <SamB> @check \x -> (fromRational . toRational) x == (x :: Float)
14:13:40 <musasabi> I just wish HAppS would compile faster.
14:13:40 <lambdabot>  OK, passed 500 tests.
14:13:46 <xerox> Yuck.
14:14:18 <ValarQ> psi: does it have 6.4 yet?
14:14:24 <xerox> monochrom: see what unholy thing they are doing? (fromRational . toRational $ x) == x !
14:14:29 <psi> ValarQ: yes
14:14:29 <glguy> sweet, that quit message rendered correctly in my irssi
14:14:32 <nomeata> @check \x -> (toRational . fromRational) x == (x :: Rational)
14:14:33 <lambdabot>  Falsifiable, after 16 tests: (-3)%5
14:14:33 <ValarQ> psi: impressive
14:14:41 <shapr> psi: I'm using the ghc6.6 debs from haskell-unsafe, works for me.
14:14:47 <psi> ValarQ: I think it has for quite a while...
14:14:54 <SamB> xerox: notice how floating-point representations can only actually represent rationals?
14:15:05 <monochrom> Why is it unholy?
14:15:15 <shapr> musasabi: Do you have a dual-core or some other sort of speedy machine/
14:15:21 <xerox> SamB: yeah :(
14:15:26 <psi> shapr: ah, cool.
14:15:35 <monochrom> "real" is a subset of rationals, obviously.
14:15:45 <SamB> xerox: you would prefer that:
14:15:48 <SamB> > pi == pi
14:15:50 <lambdabot>  True
14:15:51 <SamB> not terminate?
14:16:15 <xerox> I suppose that's why one goes for _symbolic_ calculations.
14:16:15 <monochrom> Hmm who would ask "x==y" ever?
14:16:33 <shapr> psi: deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable
14:16:36 <lambdabot> Title: Index of /archive/i386, http://tinyurl.com/ybj7tt
14:16:58 <SamB> monochrom: well...
14:17:00 <musasabi> shapr: I fire the build and do something else while it compiles. And use GHCI for testing.
14:17:20 <shapr> How long does it take to build HAppS for you?
14:17:31 <SamB> seeing as Eq is a superclass of Ord, and Ord is a superclass of Num, and Num is a superclass of Fractional, and Fractional is a superclass of Floating...
14:17:34 <psi> shapr: thanks, but I'm using ppc. they had very few packages for that, apparently.
14:17:36 <shapr> I have a 2.4GHz P4 with 1Gb of ram.
14:17:36 <glguy> is HaXml in a darcs repo?
14:17:46 <shapr> glguy: yup, but you don't want that version :-)
14:18:03 <glguy> shapr: what version do I want?
14:18:08 <shapr> glguy: At least, not unless you're doing development on a new product that you're writing yourself.
14:18:12 <SamB> lemmih has a 3.0 GHz P4 or two
14:18:28 <SamB> (if it is just one, it has two cores)
14:18:28 <shapr> HaXml 1.13.2 is what existing apps want.
14:18:47 <glguy> shapr: I want to install HAppS 0.8.4
14:18:49 <monochrom> Well it's an instance of Eq but you shouldn't use it.
14:18:51 <glguy> shapr: and develop on that
14:19:05 <lispy> glguy: haxml devl branch isn't stable, but it's close
14:19:08 <shapr> HaXml 1.14 broke backwards compatibility and added a bunch of neat stuff, with XmlContent being the niftiest.
14:19:18 <shapr> Nowadays HaXml 1.17 is the latest, iirc
14:19:23 <musasabi> shapr: too long. Should upgrade the machine (2ghz athlon xp + 512mb ram)
14:19:26 <lispy> shapr: sounds right
14:19:45 <shapr> musasabi: doubling your ram will really help
14:20:01 <shapr> I know because I just did that :-)
14:20:15 <musasabi> I know. Just lazy with upgrading.
14:20:17 <monochrom> 2ghz is already sweet enough.  Now make it 2gb too.
14:20:26 <shapr> Yeah, I want to upgrade to 2GB
14:20:37 <lispy> hmm...so i don't yet need COM but i bet i will...so it's very tempting to switch away from VH and try to fix the com library to work with generic ghc6.6
14:20:52 <shapr> Life with GHC is happier when you have more ram.
14:20:56 <monochrom> OOOHHH!  So, "I'm too lazy to change components under the hood, let me just order a new Dell." :)
14:20:57 <lispy> shapr: amen
14:21:12 * roconnor takes a break from editing
14:21:13 <shapr> musasabi: And it's cheap to buy more ram
14:21:33 <lispy> yeah, trade programmer productivity (expensive) for hardware (cheap), yay!
14:21:34 <musasabi> I hope that HaXml would finally make a stable release with the new API so that we could upgrade.
14:21:45 <monochrom> It's convenient to buy a new Dell.  Just click away on the web page!
14:21:53 <glguy> hmm, HaXml might not compile with GHC 6.6
14:21:58 <shapr> It does
14:22:03 <glguy> 13.2?
14:22:04 <lispy> glguy: which haxml/
14:22:07 <lispy> glguy: ya
14:22:22 <shapr> glguy: runghc Setup.hs configure && runghc Setup.hs build
14:22:25 <lispy> glguy: well, with the VH i have it compiles
14:22:36 <monochrom> What's new and nice about HaXml?
14:22:41 <shapr> XmlContent
14:23:04 <monochrom> Is it just a data structure?
14:23:28 <musasabi> glguy: Get HaXml 1.13.2 and use Cabal to build it like shapr explained.
14:23:37 <glguy> it's running now
14:23:45 <glguy> so what is the ./configure for
14:23:49 <glguy> was that pre-cabal?
14:24:15 <lispy> glguy: must be
14:24:20 <musasabi> it was an alternative that was not upgraded for 6.6
14:24:21 <glguy> ah, okay
14:24:40 <glguy> I never know if I'm to use setup.hs or configure and make
14:25:20 <monochrom> If I see Setup.hs I try that first.
14:25:49 <glguy> HaXml has a lot of build errors :)
14:25:51 <glguy> err
14:25:52 <SamB> sometimes cabal seems to end up running ./configure?
14:25:52 <glguy> warnings
14:26:27 <lispy> SamB: i think cabal can run autoconf and some of that stuff
14:26:34 <lispy> SamB: for sophisticated projects
14:27:23 <kolmodin> it can be made to run anything
14:27:33 <musasabi> combining Cabal and autoconf is an evil and complex art.
14:27:37 <kolmodin> and will run ./configure on unix systems if it exists
14:28:34 <shapr> @remember musasabi combining Cabal and autoconf is an evil and complex art.
14:29:36 <musasabi> mainly various cabal versions having different bugs, and windows without autoconf.
14:29:39 <kolmodin> it depends on what you want to do
14:29:58 <kolmodin> yes, windows lacking autoconf makes things harder
14:30:14 <shapr> hi bill
14:30:14 <bill20r3> shapr?
14:30:19 <bill20r3> heya.
14:30:20 <shapr> How's code?
14:30:30 <bill20r3> uh, are you a bot?
14:30:31 <monochrom> windows needs autoconf?
14:30:34 <lispy> but windows can have autoconf via msys
14:30:46 <bill20r3> shapr, you have a kinesis keyboard?
14:30:47 <lispy> bill20r3: be nice to the bots
14:30:54 <musasabi> lispy: but that is very inconvenient for the windows users.
14:30:55 <shapr> bill20r3: No. I'm not a bot. Yes, I have a kinesis keyboard.
14:31:00 <shapr> bill20r3: Who the heck are you?
14:31:02 <bill20r3> which model?
14:31:11 <lispy> musasabi: aye
14:31:16 <monochrom> What is a kinesis keyboard?
14:31:20 <lispy> musasabi: but so is windows ;)
14:31:31 <SamB> lispy: but they don't *know* that
14:31:36 <bill20r3> shapr, some guy trying to figure out which eeprom chip the ergo's use, I want to upgrade my Essential.
14:31:36 <lispy> SamB: ah....
14:31:48 <shapr> Actually, I have a frankenstein model. It started out being a contoured US model, but now it's half a Swedish keyboard.
14:31:53 <SamB> they think computers are *always* that mysterious
14:32:06 <bill20r3> shapr, msg ok?
14:32:17 <lispy> file system semantics? who needs those?
14:32:17 <shapr> I can't help you much with kinesis eeproms.
14:32:36 <bill20r3> does yours have the ability to program key-macros?
14:32:46 <shapr> I don't think so. I got one without that.
14:32:49 <monochrom> s/windows/imperative programming/
14:32:59 <shapr> bill20r3: How did you find me on irc?
14:33:00 <bill20r3> ahh, so you have the same model as me.  I'll leave you alone.  thanks for your time.
14:33:01 <SamB> monochrom: windows is worse, though
14:33:04 <SamB> because it is so GUI
14:33:09 <bill20r3> shapr, google found some irc logs.
14:33:16 <shapr> Ok, just curious.
14:33:19 <bill20r3> I did a /whois, and there you were.
14:33:23 <shapr> As always
14:33:30 <shapr> I live on IRC!
14:33:32 <bill20r3> take care, thanks.
14:34:12 <SamB> heh. using google to find people on IRC!
14:34:25 <lispy> google: bringing together strangers
14:34:42 <lispy> http://estalker.google.com/ is great for that
14:37:13 <roconnor> yhc is in google code?  I thought Haskell wasn't supported.
14:37:22 <SamB> ???
14:37:32 <psi> lispy: page not found?
14:37:34 <glguy> roconnor: better take your passwords out of your public Haskell code!
14:37:49 <SamB> roconnor: it is a free service for open source projects
14:38:02 <roconnor> glguy: ??
14:38:25 <glguy> roconnor: lots of Digg posts lately about people finding secrets in public code
14:38:27 <lispy> psi: heh
14:38:39 <glguy> roconnor: I was just joking that if you were surprised to find Haskell code online
14:38:40 <lispy> secrets?
14:38:42 <roconnor> oh, maybe the code search is the thing that is limited.
14:38:52 <glguy> it might be because you had passwords in your code :)
14:38:57 <glguy> sorry, a bit of a strech
14:39:14 <SamB> who put passwords in public code ???
14:39:26 <glguy> SamB: aparently a lot of people do
14:39:41 <SamB> could you give an example ?
14:39:47 * roconnor stops making passwords from the SHA2 initial values.
14:40:38 <glguy> SamB: search on Digg
14:40:41 <glguy> SamB: it was a recent post
14:40:44 <glguy> if you are interested
14:42:07 <roconnor> http://www.google.com/codesearch?hl=en&lr=&q=password%3D%22&btnG=Search
14:42:10 <lambdabot> Title: password=" - Google Code Search, http://tinyurl.com/y3765a
14:42:10 <roconnor> redatced!
14:43:35 <glguy> I wonder when they started doing that :)
14:43:46 <cjeris> heh, somebody woke up
14:44:37 <roconnor> glguy: it's the Censory Engine
14:45:36 <monochrom> This is just sad.
14:45:38 <lispy> what did redacted mean before the icfp contest?
14:46:28 <SamB> @web1913 redacted
14:46:30 <lambdabot> No match for "redacted".
14:46:46 <SamB> @wordnet redacted
14:46:46 <lambdabot> Unknown command, try @list
14:47:59 <lispy> whoa
14:48:07 <lispy> something i installed recently foobared my $PATH
14:48:12 * lispy hates at windows
14:50:18 <roconnor> @wikipedia redacted
14:50:21 <lambdabot> No Result Found.
14:50:24 <roconnor> @wikipedia redaction
14:50:27 <lambdabot> No Result Found.
14:50:37 <roconnor> dude
14:50:42 <roconnor> http://en.wikipedia.org/wiki/Redaction
14:51:09 <lispy> ah
14:51:17 <SamB> @wikipedia broke a while back, I think
14:51:19 <lambdabot> No Result Found.
14:51:20 <lispy> Redaction generally refers to the editing of text to turn it into a form suitable for publication, or to the result of such an effort.
14:51:49 <SamB> I notice a lot of black ink on that paper
14:52:13 <lispy> crap....is there anyway to restore your $PATH on windows?
14:52:45 <roconnor> lispy: SET PATH=[---REDACTED---]
14:52:50 <lispy> heh
14:53:00 <lispy> i don't even know how i killed it
14:53:09 <lispy> it was right yesterday
15:02:58 * shapr has a hissy fit
15:21:05 <Fey> ohoy there. When I get Instance of Num Bool required for definition of ... what is wrong? the code is and [ (isJust x) < 9 && (isJust x) > 1 || x == Nothing | x <- row]
15:21:44 <lispy> > 1 and 2
15:21:45 <lambdabot>  add an instance declaration for (Num (([Bool] -> Bool) -> t -> a))
15:21:45 <lambdabot>   In t...
15:21:57 <lispy> > and [1,2]
15:21:58 <lambdabot>  add an instance declaration for (Num Bool)
15:21:58 <lambdabot>   In the list element: 2
15:22:22 <monochrom> isJust x is a boolean.
15:22:30 <Fey> hmm
15:22:44 <Fey> boy is my face red :)
15:22:54 <Fey> I seem to have it confused with fromJust
15:23:25 <Fey> thanks a lot monochrom
15:24:44 <lispy> Fey: i bet you can do that same thing easier
15:24:59 <Fey> how so?
15:25:14 <lispy> > do { x <- Just 3; return x < 9 && x > 1 }
15:25:15 <lambdabot>  Couldn't match `Maybe t' against `Bool'
15:25:20 <lispy> > do { x <- Just 3; return $ x < 9 && x > 1 }
15:25:22 <lambdabot>  Just True
15:25:43 <lispy> basically by taking advantage of the maybe monad
15:26:01 <Fey> I see
15:26:04 <Fey> I will try that.
15:26:06 <lispy> without seeing more of your code i'm not sure, just tossing out an idea
15:26:09 <Fey> Thanks
15:26:13 <lispy> np
15:26:20 <lispy> > do { x <- Nothing; return $ x < 9 && x > 1 }
15:26:21 <lambdabot>  Nothing
15:27:06 <xerox> > let fey = maybe (liftM2 (&&) (1<) (<9)) False in (fey 0,fey 5)
15:27:07 <lambdabot>    Expecting a function type, but found `Bool'
15:27:07 <lambdabot>    Expected type: a1 -> a...
15:27:09 <xerox> Aw.
15:31:05 <lispy> xerox: i bet ap would work there
15:31:08 <lispy> ?type ap
15:31:09 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:31:39 <lispy> ?typle liftM2 ap
15:31:41 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m (a -> b)) -> m1 (m a) -> m1 (m b)
15:31:53 <lispy> or not :)
15:32:15 <lispy> ?. pl undo do { x <- Nothing; return $ x < 9 && x > 1 }
15:32:15 <lambdabot> liftM2 (&&) (< 9) (> 1) `fmap` Nothing
15:32:52 <xerox> :)
15:33:20 * dmhouse has just read No Silver Bullet
15:33:21 <lispy> > let fey = liftM2 (&&) (<9) (>1) in (liftM fey 0, liftM fey 5)
15:33:22 <lambdabot>  add an instance declaration for (Show (m Bool), Show (m1 Bool))
15:33:30 <lispy> dmhouse: yes, what did you think?
15:33:47 <lispy> > let fey = liftM2 (&&) (<9) (>1) in (fey 0, fey 5)
15:33:49 <lambdabot>  (False,True)
15:33:55 <xerox> OK.
15:34:17 <dmhouse> Odd how an essay from 1987 points so accurately toward agile and a non-BDUF development process.
15:34:35 <lispy> BDUF?
15:34:48 <shapr> big design up front
15:35:07 <shapr> as typified by the waterfall process
15:35:12 <lispy> ah
15:35:32 <lispy> dmhouse: not sure i got that out of it, but i only read about the first 1/2
15:35:44 <dmhouse> lispy: that's in the latter half. :)
15:36:13 <monochrom> what essay is that?
15:36:23 <monochrom> Err nevermind, I see.
15:36:34 <dmhouse> It speaks of growing, rather than building, software, top-down design and early prototyping.
15:36:35 <monochrom> Who's the author?
15:36:44 <lispy> ah, yes i read to AI and needed a break
15:36:50 <dmhouse> Frederick P. Brooks, Jr., of Mythical Man-Month fame.
15:36:55 <lispy> http://www-inst.eecs.berkeley.edu/%7Emaratb/readings/NoSilverBullet.html
15:36:58 <lambdabot> Title: No Silver Bullet:, http://tinyurl.com/yah7vu
15:37:30 <dmhouse> One of the sentiments I agree with is that specifying software is harder than writing software.
15:39:40 <monochrom> Well that's obviously an illusion and spreading that myth is going to cause lots of idiosyncratic software.
15:40:21 <lispy> hmm...i can't build wxhaskell for some reason
15:40:29 <dmhouse> monochrom: you disagree? Why?
15:40:40 <monochrom> I don't think I have time to answer.
15:43:30 <monochrom> Let me briefly answer the second part.  Write the program first, then use whatever it incidentally or accidentally achieves or not achieves to dictate its purpose?  Sounds like how many idiosyncratic syntaxes such as that of Fortran arise.  "Gee, it's so much easier for me to write the parser IF ONLY column 6 tells me whether the line is a comment or not!"
15:45:01 <monochrom> Knuth et al, on the other hand, recognized the nicety of context-free grammars for programmers, so they took that as an a priori specification and worked towards a capable parser.
15:45:46 <dmhouse> I don't follow you. I just said that finding and formalising the requirements for a system is often harder than writing the actual algorithms to fulfill those requirements.
15:47:12 <monochrom> I am just elaborating on the second part, "spreading that myth is going to cause lots of idiosyncratic software".
15:47:23 <lispy> dmhouse: i think monochrom took a leap or two from there (reasonably so)
15:48:01 <monochrom> Did I forget to declare I was just talking about the second part?
15:48:04 <lispy> dmhouse: if it's hard to spec things out, and we just wander around implmeentation space we make make something that isn't well thought out
15:48:07 <madhorse> (mientras no tengamos claro la cuestión de copyrights en Implementaciones)
15:48:12 <madhorse> sorry
15:48:36 <dmhouse> lispy: just because it's hard to specify doesn't mean we shouldn't specify.
15:48:48 <lispy> but i think there are other directions to go too right? like maybe we should be worried about how hard it is to spec things and try to make that easier
15:49:32 <lispy> maybe i'm just confused :)
15:49:44 <monochrom> All in all, I think "missing the forest for the trees" is a far more important warning than any other pro or con arguments on software processes.
15:49:48 <dmhouse> That's one advantage of iterative development. You delay planning what you're going to write until the moment when you know most about the problem domain.
15:50:17 <lispy> we should use CPS planning :)
15:51:17 <dmhouse> Iterative development is the methodological version of lazy evaluation.
15:51:51 <monochrom> Iterative development is fine.  Iterative development is the Kleene closure of the waterfall.
15:51:58 * lispy notes that unless he can get wxhaskell to compile for ghc6.6 he may not use it
15:53:40 <dons> hello from calirfornia!
15:53:40 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:53:48 <lispy> anyone tried to compile wxhaskell with 6.6 yet?
15:53:51 <lispy> dons: hey
15:54:00 <lispy> dons: welcome to my time zone
15:54:27 <dons> cheers lispy
15:55:02 <dons> nice and warm here.
15:55:07 <dons> using google wireless :)
15:55:10 <lispy> dons: cool
15:55:28 <lispy> dons: yeah, oregon is unusually warm this year
15:55:28 <thetallguy> where in CA?
15:55:34 <lispy> dons: like, record highs lately
15:55:58 <dons> mountain view, thetallguy
15:56:10 <shapr> I can't believe it's not butter.
15:56:11 <dons> outside san fran
15:56:17 <dons> heya shapr
15:56:37 <lispy> dons: oh, the natives don't like "san fran" :)
15:56:48 <dons> oh ok
15:56:51 <thetallguy> It's warm in San DIego, too.
15:56:52 <dons> (good to know)
15:57:03 <lispy> oh wait
15:57:06 <lispy> maybe it was frisco
15:57:14 <lispy> it was watching eddy izzard
15:57:16 <dmhouse> dons: SoC summit?
15:57:19 <dons> yup
15:57:24 <dmhouse> How's it going?
15:57:25 <lispy> and he called it that and they booed hand histed at him :)
15:57:26 <shapr> g'day dons
15:57:46 <shapr> dons: I was going to ask you something... I wish I could remember what...
15:57:51 <lispy> yeah, now that i think aout it "san fran" is probably okay and "frisco" was bad :)
15:57:56 <dons> dmhouse: oh, just arrived. sharing a room with a guy from abiword. caught the train up with a guy from blender. lots of fun
15:58:24 <dmhouse> shapr: you should have use ?ask him when it was in your mind! :) </shameless-plug>
15:58:29 <shapr> heh
15:58:44 * lispy shousd find that clip
15:58:46 <dmhouse> *should have used ?ask when ...
15:59:00 <dons> so far 1/3 knew what haskell was :)
15:59:11 <dons> but now 3/3 know ;)
15:59:19 <lispy> hehe
15:59:26 <lispy> dons: you wash those unwashed masses!
15:59:31 * shapr laughs
15:59:34 <shapr> Go Dons!
15:59:44 * dons washes
16:00:03 <dons> already had an interesting discussion about porting abiword to haskell :)
16:00:11 <dons> (memory management of the C++ is a nightmare, apparently)
16:00:29 <lispy> no way!
16:00:42 * lispy stopped using abiword because it used to corrupt his documens
16:00:44 <Igloo> dons: If neither google search nor google mail is reimplemented in Haskell by the time you leave, we'll all consider you a failure
16:00:44 <shapr> I'm shocked!
16:00:49 * shapr snickers
16:00:49 <dmhouse> Well, that's tautological. Anything with 'memory management', not to mention 'C++', it guaranteed to be nightmarish.
16:00:55 <dons> Igloo: ok, i am so warned.
16:01:22 <Igloo> (if you get both done, I'll buy you a cookie)
16:01:47 <dcoutts> dons, I thought you were on a plane somewhere :-)
16:01:56 <dons> dcoutts: already here :)
16:01:56 <dcoutts> where in the world is dons we wonder
16:02:00 <dcoutts> ah right
16:02:15 <dons> in sunny mountain view, using google's free community wifi
16:02:27 <dons> (at least i think i am... hmm)
16:02:41 <dons> using someone's free wifi, anyway
16:02:43 <stepcut> hehe
16:03:09 <lispy> dons: find out if they use haskell internally at all
16:03:19 <dons> i'll try
16:03:30 <lispy> i know they use python
16:03:35 <lispy> and maybe even lisp
16:03:38 <lispy> because of norvig
16:03:52 <dmhouse> Team Smartass, who were Google people, used at least some Haskell in the ICFP.
16:04:26 <dmhouse> And they use functional paradigms for performance sakes in the search (MapReduce).
16:04:34 <dons> araujo: good to see the .es stuff moving along
16:04:34 <lispy> ah yup
16:05:35 <dmhouse> From Steve Yegge's rants, it seems that teams have a pretty free reign in Google... I'd wager that if you found a tech lead who liked the language, you'd get a group using it.
16:05:42 <Maddas> lispy: They had an intern translate lisp code written by norvig to java :-)
16:05:59 <lispy> Maddas: did they fire the intern? ;)
16:06:39 <shapr> Has anyone heard of reconfigurable antennas?
16:06:55 <shapr> I've gotten into this crazy email discussion with Kragen...
16:07:15 * lispy wonders if he found a bug in ghc6.6 already
16:07:22 <Maddas> lispy: (Erm, at least that's what I read somewhere... I wonder if it's just an urban myth :-))
16:07:30 <lispy> anyone with windows and ghc6.6 want to try something for me?
16:07:41 <lispy> it's simple
16:07:58 <lispy> er...actually it's not that simple i guess
16:07:59 <lispy> arg
16:08:19 <dmhouse> 6.6 final is out!?
16:08:21 <lispy> wx/src/Graphics/UI/WX/Types.hs:94:0:
16:08:21 <lispy>     Bad interface file: out/wx/imports/Graphics/UI/WXCore/Types.hi
16:08:22 <lispy>         Something is amiss; requested module  wx:Graphics.UI.WXCore.Types differs from name found in the interface file wxcore:Graphics.UI.WXCore.Types
16:08:33 <dmhouse> Wow, how did I miss _that_ announcement?
16:08:35 <Igloo> lispy: Is that a clean build?
16:08:38 <lispy> dmhouse: seems to be that way, or at least binaries are showing up
16:08:52 <lispy> Igloo: clean build of the wxhaskell source
16:09:01 <lispy> Igloo: but, i haven't rebuilt the wxwidgets
16:09:06 <dmhouse> lispy: find -name '*.hi' -o -name '*.o' -exec rm '{}' \;, then go again
16:09:24 <Igloo> lispy: You haven't rebuilt the C++ libs, you mean?
16:09:30 <lispy> Igloo: correct
16:09:39 <Igloo> lispy: Are there any .hi files in the tarball?
16:09:42 <lispy> Igloo: last time i upgraded ghc rebuilding the C++ was not needed
16:09:49 <Igloo> lispy: Right, it's not
16:09:51 <lispy> Igloo: i dont' think so
16:10:15 <Igloo> If that's reproducible then see if you can make a minimlal testcase
16:10:40 <JohnMeacham> c'mon ride the lambda. let's ride it.
16:11:04 <yip> how does wxHaskell work?
16:11:19 <lispy> Igloo: doesn't appear to be any
16:11:40 <lispy> Igloo: well, right now all i have to do to reproduce it is type 'make clean; make'
16:11:46 <lispy> Igloo: or just make for that matter
16:11:56 <lispy> Igloo: as in, it happens straight from the wxhaskell source
16:13:00 <lispy> as a test i deleted the offending .hi file and did a make and same error
16:14:03 <lispy> Igloo: do you have any advice about building a minimal test case for this?
16:14:17 <lispy> Igloo: the wxhaskell build is fairly complicated, IMO
16:15:27 * Igloo isn't familiar with it
16:18:34 <lispy> i think the haskell source is at least partially generated from some eifel(sp?) source
16:19:25 <monochrom> eiffel?
16:19:56 <lispy> monochrom: yeah, that looks like a much better spelling :)
16:21:17 <lispy> Igloo: for now i'm just going to make a bug report, making a smaller test case is a bit over my ability
16:21:34 <Igloo> OK
16:22:21 * ihope joins #haskell.es
16:22:36 <ihope> So far, I have no idea what anybody's talking about.
16:24:02 <dmead> i like chocolate
16:24:13 <dmead> there, problem solved
16:24:18 <ihope> Me gusta chocolate.
16:30:22 <hygge_> hmm, i've got a problem here. anyone awake? ;)
16:30:33 <monochrom> No.
16:30:56 <hygge_> :P
16:31:15 <shapr> not me
16:31:35 <monochrom> I so like to speak for everyone
16:33:11 <araujo> dons, yay!
16:33:17 <hygge_> http://pastebin.perl.se/d522502fcb/
16:33:38 <araujo> dons, people is starting to help translating!
16:34:05 <hygge_> i want to make this random thing work...
16:34:14 <twanvl> You can't use let like that
16:34:49 <hygge_> no.. :p
16:35:00 <hygge_> but that shows my idea
16:35:12 <hygge_> hmm
16:35:12 <monochrom> let object = if n==1 then "hej" else ""
16:35:30 <hygge_> ah
16:35:31 <Igloo> Is there a good topological sorting library for Haskell?
16:36:02 <twanvl> Since you are already in the IO monad, you can just use randomRIO
16:36:11 <hygge_> hm okey
16:36:23 <twanvl> ?hoogle topSort
16:36:24 <lambdabot> Data.Graph.topSort :: Graph -> [Vertex]
16:36:24 <lambdabot> Data.Graph.Inductive.Query.DFS.topsort :: Graph gr => gr a b -> [Node]
16:36:24 <lambdabot> Data.Graph.Inductive.Query.DFS.topsort' :: Graph gr => gr a b -> [a]
16:37:47 <Igloo> ta
16:38:18 <araujo> dons, We got a doubt about the current copyright. Do we need to fulfill some requirement for doing the translation with it? (e.g., to point to the original version, let know the author about the translation .. )
16:38:36 <araujo> dons, And what exactly should we do with that _material_ belonging to the old wiki yet?
16:39:52 <Igloo> araujo: What are you translating?
16:40:23 <hygge_> monochrom, twanvl, it stil wont work :/ http://pastebin.perl.se/db382b27c9/
16:40:34 <araujo> Igloo, http://haskell.org/haskellwiki/Haskell.es
16:40:35 <lambdabot> Title: Haskell.es - HaskellWiki
16:40:54 <araujo> Igloo, Mainly the SpecialPopularPages section.
16:41:09 <twanvl> hygge_: add a type signature
16:41:14 <araujo> Besides that, we are adding new stuff too.
16:41:15 <hygge_> okey
16:41:30 <Igloo> araujo: Anything from the new wiki you can just translate
16:42:02 <araujo> Igloo, Good.
16:42:14 <lispy> ghc
16:42:15 <Igloo> Oh, hmm, you might need to acknowledge the copyright of the original
16:42:18 <lispy> oops
16:42:30 <monochrom> You won't like it, but try randomRIO (1 :: Int, 6).  Too hard to explain why you need to do this.
16:42:42 <Igloo> Perhaps just put a small note at the bottom that it's a translation of the other page
16:42:43 <araujo> Igloo, We are just translating the pages 'as-is'
16:43:09 <araujo> Igloo, that's a good idea. Probably with a link pointing to the original article
16:43:23 <hygge_> http://pastebin.perl.se/30e6e002d9/
16:43:56 <monochrom> Please do as I say.
16:44:13 <hygge_> aha
16:44:19 <hygge_> didnt see you wrot
16:44:21 <hygge_> e*
16:44:35 <monochrom> No one ever see what I write.
16:44:48 <hygge_> aah :P
16:44:53 <hygge_> but thanks, it worked now!
16:44:54 <hygge_> hmm
16:45:32 <monochrom> The short story is that things like 1, 6 may be Int, Integer, Float, Double, ...  so the Invisible Hand doesn't know which one you prefer.
16:45:48 <hygge_> aha
16:47:09 <hygge_> i have a data type that only has three simple constructors... is it hard to make it a part of the random class and to use randomrio on it? :p i guess i cant use it in the way as i do with ints, but does it work if i make it a memember of ord too?
16:48:41 <Igloo> Oh, hmm, I need something more cunning than the result of a topSort as I need to cope with failures in the middle
16:49:13 <monochrom> It is easy.
16:49:39 <monochrom> It's easy as One Two Three. :)
16:49:51 <hygge_> :)
16:50:19 <hygge_> okey
16:50:26 <lispy> Igloo: what are you sorting?
16:50:35 <Igloo> cabal packages
16:50:41 <kpreid> hygge_: to make an instance of Random you need to define the methods random and randomR (the 'minimal complete definition')
16:50:52 <hygge_> hmm
16:50:55 <hygge_> okey
16:50:57 <hygge_> sounds tough
16:50:59 <kpreid> hygge: you can implement them using toEnum
16:51:17 <lispy> Igloo: have you seen the algorithms that SMART uses? it's supposed to be a 'smart' replacement for things like apt and yum...maybe they have some useful ideas?
16:51:23 <hygge_> my data is simply data object = empty | diamond | monster
16:51:25 <hygge_> my data is simply data Object = Empty | Diamond | Monster
16:51:29 <kpreid> and Random Integer
16:51:38 <hygge_> okey
16:51:57 <Igloo> I don't need anything particularly smart, I'm just wondering how best to write something simple
16:52:14 <kpreid> hygge_: derive Enum and Bounded from your datatype, then use those to define the Random
16:52:38 <Cale> Igloo: did you see that comment about changing the libc6 dependency on ghc6 to chop off the part of the version after the - ?
16:53:05 <Igloo> Cale: Yeah, but I guess you missed my response  :-)
16:53:16 <Igloo> I'm not going to hack the debs if that's what you were asking
16:53:17 <hygge_> okey
16:53:32 <dcoutts> Igloo, failures in the middle ?
16:54:05 <hygge_> kpreid, im falling asleep now so i'il look into it tomorrow :P
16:54:05 <Igloo> dcoutts: If mtl doesn't build then we shouldn't try to build fgl
16:54:28 <dcoutts> Igloo, if there's any failure, don't we just stop ?
16:54:43 <Igloo> No, because I want to know if quickcheck also doesn't build
16:54:56 <Igloo> (this isn't for cabal itself)
17:00:26 <lispy> ?fptools hdirect
17:00:26 <lambdabot> hdirect not available
17:00:31 <lispy> ?fptools
17:00:31 <lambdabot>  not available
17:00:55 <lispy> The HaskellDirect sources are available via the Haskell CVS, as module fptools/hdirect.
17:01:07 <lispy> so where wolud that be these days?
17:01:54 <dcoutts> http://www.onlamp.com/pub/a/onlamp/2006/10/12/asynchronous_events.html
17:01:55 * dcoutts thinks this ^^ should be easy in Haskell
17:01:57 <lambdabot> Title: ONLamp.com -- Developing High Performance Asynchronous IO Applications, http://tinyurl.com/wsf3z
17:02:24 <dcoutts> it's talking about an SMTP relay that has loads of concurrnet open connections
17:02:40 <dcoutts> to throttle incomming connections to deter spammers
17:02:53 <lispy> ?where fptools
17:02:53 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
17:03:04 <lispy> bleh, i don't want the cvs
17:03:11 <lispy> ?where fptools fgl
17:03:12 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
17:03:25 <lispy> ?fptools fgl
17:03:26 <lambdabot> fgl not available
17:06:36 * lispy wishes windows had the 'open' command from osx
17:09:53 * lispy finally figures out how to fetch it uses cvs
17:18:08 * edwardk waves hello.
17:19:40 <lispy> hey
17:20:43 <dmead> hihi
17:21:32 * dons waves at edwardk 
17:21:46 <edwardk> dons: ever get a chance to see if that email worked?
17:22:08 <dons> edwardk: oh sorry. just got off the plane. still trying to get through my mail
17:22:20 <edwardk> not worried about it
17:22:25 <edwardk> just curious
17:22:29 <dons> thanks for reminding me though
17:25:10 <edwardk> filter : ~exists a:*.~(~(a*~b)*~(exists n:Nat. List a n * ~(exists m : Nat. m <= n * List a m))) -- existentials are fun.
17:25:24 <dmead> =)
17:25:25 <edwardk> er i need to change the * symbol in there to &
17:29:35 <edwardk> trying to see if i can use my weird CPS calculus' exists for traditional existential purposes still.
17:31:27 <edwardk> if so then exists with negation without forall is strictly more powerful. seems to work. the resulting translation is very close to what people do anyways, they lambda lift to pack all of the arguments in at once when they can effectively using the (,) (->) adjoint relationship, but not so explicitly. i can just make that adhoc decision more concrete.
17:32:32 * edwardk shuts up and returns to puttering
17:34:05 <hygge_> whats the function in haskell to replace an element x in a list of xs to another value?
17:34:21 <hygge_> in my case, a char in a string to another char
17:34:45 <dons> map would do it.
17:35:09 <hygge_> hm
17:35:12 <dons> > map (\c -> c == 'x' then '#' else c) "hasxekxxeklxx"
17:35:12 <lambdabot>  Parse error
17:35:20 <dons> > map (\c -> if c == 'x' then '#' else c) "hasxekxxeklxx"
17:35:21 <lambdabot>  "has#ek##ekl##"
17:35:32 <edwardk> > map (\x -> if x == 'a' then 'b' else x) ['a'..'c']
17:35:33 <lambdabot>  "bbc"
17:35:47 <hygge_> ah
17:36:01 <hygge_> there are no regexps?
17:36:11 <lispy> edwardk: is that Coq?
17:36:16 <dons> there are, but you don't use thme for this kind of thing, hygge_
17:36:20 <edwardk> lispy: mine? not quite.
17:36:24 <dons> have a look at Data.List
17:36:27 <dons> ?docs Data.List
17:36:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
17:36:32 <edwardk> lispy: thats my somewhat absurd intermediate syntax more or less
17:36:34 <dons> hygge_: in fact. memorise Data.List :)
17:36:40 <lispy> edwardk: ah
17:37:12 <edwardk> you could probably write that almost verbatim in coq if it had ~ and non-termination though, if you replaced exists with sigma.
17:37:20 * lispy tries to build old cvs fptools just so he can try to figure out what is the most recent hdirect
17:37:37 <lispy> crap
17:37:46 <lispy> keep getting errors about mk/config.h.in
17:37:51 <lispy> i have no idea what that's all about
17:38:31 <edwardk> trying to figure out a good syntax to name which arguments should be defined implicitly in that though, since you shouldn't have to pass in an explicit type named a, etc.
17:38:37 <lispy> hrm...
17:38:38 <hygge_> okey :P
17:38:46 <lispy> i don't think i want this copy of hdirect at all
17:41:03 <hygge_> gtg!
17:41:05 <hygge_> bye
17:41:29 <edwardk> hrmm: Not (Sigma (MkVar "a") Star (Not (Not (Tensor (Not (Tensor (Var (MkVar "a")) (Not (Var (MkVar "b"))))) (Not (Not (Sigma (MkVar "n") (Var (MkVar "Nat")) (Not (Not (Tensor (List (Var (MkVar "a")) (Var (MkVar "n"))) (Not (List (Var (MkVar "b")) (Var (MkVar "n")))))))))))))) -- i think i need a pretty printer =)
17:41:54 <edwardk> whats a good pretty printer combinator library?
17:44:07 <stepcut> edwardk: are you aware of this one: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
17:44:09 <lambdabot> http://tinyurl.com/yz5hnw
17:44:52 <lispy> that one is good, but sometimes inefficient
17:45:02 <lispy> my guess is it won't bite you though in this case
17:45:07 <Igloo> dcoutts: Isn't Distribution.Compat.FilePath meant to be revealed?
17:45:17 <lispy> whoa, what is IOExts called now?
17:45:29 <edwardk> thats the one whose docs i'm skimming now in detail. i read the old wadler paper on this stuff too way back when. just curious what folks are using in practice
17:45:46 <Igloo> dcoutts: Oh, the packages.conf.in is out of sync with the .cabal file
17:45:46 <dcoutts> Igloo, it is, isn't it? where are you looking ?
17:45:52 <dcoutts> ah, bugger
17:46:06 <dcoutts> the keeping in sync issue needs to die
17:46:06 <Igloo> Viva 6.6.1!
17:46:12 <stepcut> Igloo: :p
17:46:17 <Igloo> Yes, but for that we need configurations in cabal  :-)
17:46:21 <dcoutts> yep
17:46:22 * Igloo passes the buck
17:46:25 <dcoutts> heh
17:46:52 <Igloo> (we could do hidesous things to the .cabal file as an alternative)
17:47:44 <Igloo> ((and in fact need to do such hideous things anyway in the ghc-base package as GHC.Prim is magic))
17:49:49 <lispy> was IOExts renamed Control.Exception or something?
17:50:50 <Igloo> It was split up into bits of various modules, I think
17:51:29 <lispy> this seems like a real dead-end way to do this
17:51:47 <Igloo> ?
17:51:57 <lispy> well, i want to fix H/Direct
17:52:07 <lispy> so i'm trying to figure out what happened to it
17:52:14 <lispy> i know you can get a crippled version with VH
17:52:31 <lispy> but, i was hoping to get the pre-crippled version building
17:52:57 <lispy> so i'm looking at the 0.21 release from the h/direct site at the moment, and no clue how to upgrade it to modern libraries
17:53:18 <lispy> i guess i could get rid of IOExts and see what it complains about
17:53:34 <Igloo> That's probably the easiest way
17:53:55 <lispy> and i need to turn off these infernal ghc-timing options in the make file :)
17:54:52 <yip> how exactly does wxHaskell get haskell to call c++ libraries?
17:54:55 <lispy> yes getting rid of that module helps, because i know here to find trace
17:55:19 <lispy> yip: from what i see they autogenrate code to do it from bindings for a different language
17:55:25 <lispy> yip: outside fo that, i'm clueless too
17:55:56 <Igloo> I only remember it includes making a .so, as that caused a sticky point with Debian
17:57:35 <dmead> suicide is painlesss
17:57:38 <dmead> it brings on many changesss
17:57:50 <dmead> and I can take or leave it if I pleaaaassseee
17:58:58 <shapr> ?
17:59:19 <shapr> dmead: If you want to recite research papers, it's okay.... but song lyrics are sort of off topic :-P
17:59:32 <dmead> =[
17:59:32 <shapr> dmead: You can do that all you want on #haskell-blah
17:59:58 <dmead> =]
18:02:35 <lispy> okay, where is newSTArray these days?
18:04:36 <Igloo> You want the generic newArray, or whatever it's called, from the MArray interface
18:06:30 <lispy> okay
18:06:36 <lispy> ?hoogle newArray
18:06:36 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:06:37 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:06:37 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
18:07:41 <lispy> ah yup, that did the trick
18:07:44 <lispy> thanks
18:21:57 <dons> mm. cool. new camera works straight out of the box on openbsd
18:22:13 <lispy> nice
18:22:15 <lispy> dons: what did you get?
18:22:53 <dons> olympus mju 600
18:23:21 <Igloo> As a USB mass storage device?
18:23:33 <dons> here you go, tired photo of me in hotel room after 14 hour flight, http://www.cse.unsw.edu.au/~dons/images/gsoc/pa140001.jpg
18:23:34 <lambdabot> http://tinyurl.com/yxooon
18:23:43 <dons> Igloo: yep, just mount -t msdos /dev/sd0i
18:23:51 <lispy> dons: do you know what I# would be?
18:23:55 <dons> scsi over usb
18:24:03 <dons> lispy: ?
18:24:14 <lispy> HDirect.lhs:1103:15: Not in scope: data constructor `I#'
18:24:18 <lispy> heh
18:24:23 <lispy> kinda blurry :)
18:24:26 <dons> hehe
18:24:30 <dons> first photo :P
18:24:39 <dons> i feel a bit blurry though
18:24:45 <lispy> heh
18:25:01 <lispy> just wondering what I# refers to
18:25:10 <lispy> I also see Int#
18:25:12 <dons> is it a Int constructor?
18:25:14 <lispy> ?hoogle Int#
18:25:14 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
18:25:20 <dons> silly hoogle
18:25:22 <lispy> but hoogle doesn't like it :)
18:26:06 <lispy> do you know which module Int# should be in? maybe I# is there as well
18:26:53 <lispy> import GlaExts ( Int(..), Int# )
18:28:12 <lispy> import GHC.Base ?
18:28:37 <lispy> ah yes that was it
18:28:41 <lispy> guess where i got that?
18:28:46 <lispy> i googled your UM and looked at the source :)
18:28:49 <lispy> and then guessed
18:35:27 <dons> heh
18:35:38 <dons> i wonder if you could find it in google's code search
18:35:40 <dons> w/in 34
18:35:45 <lispy> i tried but had no luck
18:35:52 <lispy> oh in code search?
18:35:53 <lispy> hmm...
18:35:58 <lispy> didn't try there
18:36:16 <lispy> ?hoogle mkTyCon
18:36:17 <lambdabot> Data.Typeable.mkTyCon :: String -> TyCon
18:36:17 <lambdabot> Data.Typeable.mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
18:36:59 <dons> lispy: its pretty good for harvesting haskell hackers mail addresses
18:37:11 <dons> you just search for a regex matching emails, and the word 'haskell' ...
18:37:34 <lispy> heh
18:37:45 <lispy> that might explain why i'm getting more spam
18:38:04 <lispy> now i get a type error
18:38:09 <lispy> this could be a real slow down :)
18:38:19 <lispy> couldn't match a TypeRep to a TyCon
18:38:23 <lispy> i swear I've been here before
18:38:54 <lispy> maybe putzing with the old source isn't as good an idea as i thought
18:39:21 <lispy> instance Typeable ComError where
18:39:21 <lispy>    typeOf _ = mkAppTy comErrorTc []
18:40:07 <lispy> mkAppTy (mkTyCon "ComError") []
18:40:10 <lispy> > mkAppTy (mkTyCon "ComError") []
18:40:10 <lambdabot>  Couldn't match `TypeRep' against `TyCon'
18:40:16 <lispy> yay, lambdabot agrees
18:44:08 <dmead> ahh
18:44:09 <dmead> poo
18:44:12 <dmead> i have a question
18:44:17 <dmead> about types
18:44:25 <SamB> oooooo! types!
18:44:29 <dmead> i forget if the term is destructible or muteable
18:44:31 * SamB likes types
18:44:33 <dmead> =p
18:44:59 <SamB> we talk about "mutable" things and "destructive update"
18:45:09 <dmead> ahh right
18:45:11 <dmead> hmm
18:45:21 <dmead> nevermind
18:45:24 <dmead> i have more cogitating to do
18:46:27 <dmead> but battlestar is on...
18:46:29 * dmead is so ned
18:46:32 * dmead is so nerd
18:46:43 <SamB> heh
18:47:06 <SamB> I haven't got the problem of having TV shows on... I have no cable, so almost nothing is ever on...
18:48:13 <dolio> Even with cable there's not a lot on.
18:50:26 <glguy> speaking of spam earlier, I want to me the loser (or maybe just see a picture) who gets an email for "Clneap Vvkagra!!!" and buys it (making the spam worth sending in the first place)
18:50:34 <glguy> meet*
18:53:57 <SamB> dolio: yeah, but there might at least be one thing on maybe 50% of the time
18:54:23 <dolio> Yeah. You could watch Seinfeld like 6 times a day, I guess.
18:54:47 <hyrax42> ?hoogle (# Int, Int #) -> Int#
18:54:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> Int, Int'
18:55:14 <SamB> dolio: no, I didn't mean the *same* thing
18:55:17 <hyrax42> hm
18:55:21 <dolio> :)
18:55:31 <hyrax42> ?index Int#
18:55:31 <lambdabot> bzzt
18:55:46 <SamB> > filter even [1..10]
18:55:48 <lambdabot>  [2,4,6,8,10]
18:56:06 <dolio> > 42 :: Int#
18:56:06 <lambdabot>  Parse error
18:56:25 <hyrax42> well it's not important now
18:56:29 <hyrax42> I was getting ahead of myself
18:56:37 <dolio> ?kind Int#
18:56:38 <lambdabot> Not in scope: type constructor or class `Int#'
18:56:49 <SamB> maybe half the time, after applying filter (not . noGood), there is something left on cable...
18:56:50 <hyrax42> ?kind Int
18:56:52 <lambdabot> *
18:56:54 <dmead> >5
18:57:02 <hyrax42> > 5
18:57:03 <lambdabot>  5
18:57:08 <dmead> why doesn't lambdabot respond to me =(
18:57:14 <hyrax42> needs a space, methinks
18:57:20 <dmead> > 5
18:57:21 <lambdabot>  5
18:57:23 <dmead> ahhh
19:05:43 * lispy decides enough hacking for one night, time to go home
19:25:52 <dons> araujo: I wonder if eventually haskell.es should just be a translated mirror of the front page of haskell.org?
19:26:13 <SamB> ... translated by magical internet elves?
19:26:35 <dons> yeah, check out the change log. we've got a spanish mirror underway :)
19:26:38 <dons> http://haskell.org/haskellwiki/Haskell.es
19:26:39 <lambdabot> Title: Haskell.es - HaskellWiki
19:26:41 <hyrax42> do you guys use (***) (&&&) second first etc. from Control.Arrow frequently?
19:26:51 <dons> hyrax42: not very. but sometimes they're fun
19:26:55 <glguy> only in #haskell :)
19:27:15 <SamB> I might import Control.Arrow just for those ocassionally
19:27:18 <hyrax42> cos I just replaced \(a, Just b) -> (a, b) with second fromJust
19:27:30 <SamB> I'd say thats reasonable ;-)
19:27:32 <hyrax42> or id *** fromJust
19:27:45 <hyrax42> which makes it more readable in context
19:27:56 <hyrax42> was just wondering how frequently the arrow functions are used
19:28:15 <SamB> though I might point out that the error message from fromJust might be less useful
19:29:06 <hyrax42> > fromJust Nothing
19:29:07 <lambdabot>  Add a type signature
19:29:22 <hyrax42> > fromJust Nothing :: Int
19:29:22 <lambdabot>  Exception: Maybe.fromJust: Nothing
19:29:22 <hyrax42> that?
19:29:22 <SamB> yeah
19:29:30 <SamB> as opposed to
19:29:44 <hyrax42> well the list fromJust is mapped over is filtered with isJust first
19:29:47 <hyrax42> so I'm safe in this case
19:29:56 <hyrax42> but you're meaning what?
19:29:57 <SamB> > (\(a, Just b) -> (a, b)) ((), Nothing::Maybe Int)
19:29:59 <lambdabot>  Non-exhaustive patterns in lambda
19:30:03 <SamB> hmm.
19:30:16 <SamB> usually gives a line/column range for that ;-)
19:30:31 <hyrax42> oh yeah I see you're meaning
19:30:43 <hyrax42> *your!
19:30:51 <hyrax42> eugh I must be itred
19:30:52 <hyrax42> tired
19:31:02 <SamB> but, for complete functions it makes total sense 100% of the time, but may lead to undesired dependencies...
19:31:21 <SamB> contact the maintainer(s) of the project you are working on ;-)
19:31:28 <hyrax42> how you mean
19:31:45 <SamB> well, maybe some implementations of Haskell don't come with Control.Arrow?
19:31:53 <hyrax42> oh
19:32:01 <SamB> probably not too big a deal though
19:32:03 <hyrax42> GHC does, and it's my project
19:32:04 <hyrax42> so I'm safe
19:32:06 <hyrax42> and hugs does
19:32:10 <hyrax42> since I'm testing in hugs for quick loading
19:32:21 <SamB> I don't remember that using any extensions anyway, though
19:32:31 <hyrax42> multiparam type classes
19:32:39 <SamB> oh, it does?
19:32:56 <SamB> Control.Arrow itself?
19:32:58 <hyrax42> class Arrow a e ...
19:33:00 <hyrax42> ?
19:33:19 <SamB> @type (>>>)
19:33:20 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
19:33:32 <SamB> no, thats a one parameter typeclass!
19:33:50 <hyrax42> woops
19:34:04 * hyrax42 still not great with terminology and gets confused
19:34:22 <hyrax42> ?kind StateT
19:34:24 <lambdabot> * -> (* -> *) -> * -> *
19:34:25 <SamB> well, the "class Arrow a e ..." does *look* like one
19:34:49 <SamB> however, I don't think that the actual class declaration has an "e" there
19:34:49 <hyrax42> ?hoogle Arrow
19:34:50 <lambdabot> Control.Arrow :: module
19:34:50 <lambdabot> Control.Arrow.Arrow :: class Arrow a
19:34:50 <lambdabot> Control.Arrow.ArrowMonad :: a () b -> ArrowMonad a b
19:34:58 <hyrax42> yeah you're right
19:36:10 <hyrax42> ?type get
19:36:11 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
19:36:19 <hyrax42> that's multiparamter right?
19:37:57 <SamB> yes
19:38:05 <SamB> MTL uses those a LOT
19:38:23 <SamB> almost every class in the MTL is an MPTC
19:38:27 <SamB> with fundeps
19:43:17 <fpierre08> can any1 help me with my code ? i am getting this error : Couldn't match `t -> t1' against `[Char]' [http://rafb.net/paste/results/fDCpUF87.html]
19:44:50 <glguy> fpierre08: you are trying to call getXth with a string
19:45:03 <glguy> err
19:45:27 <glguy> why are you using getXth instead of !!?
19:45:46 <fpierre08> glguy : instead of ? lol
19:46:19 <glguy> ? signifies a question, !! is an operator
19:46:34 <fpierre08> ow
19:46:41 <ThreeQ> > [1,2,3,4,5] !! 3
19:46:43 <lambdabot>  4
19:46:50 <fpierre08> well one reason would be the fact that i am really new to haskell
19:47:01 <fpierre08> first attempt is right now....
19:47:13 <ThreeQ> also you should make a datatype for cards
19:47:13 <fpierre08> so i am only starting to get familiar with the functions
19:47:22 <dons> fpierre08: you can find new functions like this with 'hoogle', http://haskell.org/hoogle
19:47:24 <lambdabot> Title: Hoogle
19:47:25 <dons> also, :
19:47:29 <ThreeQ> like
19:47:30 <dons> ?hoogle [a] -> Int -> a
19:47:31 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
19:47:37 <fpierre08> so !! will return a specific element of a list?
19:47:45 <dons> (so if you know roughly what the type is, you ccan find a function with that type)
19:47:45 <ThreeQ> data Suit = Diamond | Heart | Spade | Club
19:47:49 <dons> fpierre08: yep
19:47:54 <glguy> fpierre08: however unlike your function, it is 0-based indexing
19:48:02 <ThreeQ> then you can use those instead of the numbers
19:48:09 <ThreeQ> like a C enum, if you're familiar with that
19:48:39 <fpierre08> yeah i am familiar to enum :)
19:48:44 <fpierre08> i see
19:48:48 <fpierre08> tnx :)
19:48:58 <fpierre08> lemme try !!
19:48:59 <SamB_XP> deriving (Eq, Ord, Enum, Show), perhaps?
19:50:18 <ThreeQ> and for values you could do something like:
19:50:35 <ThreeQ> data CardValue = Ace | King | Queen | Jack | NumValue Int
19:51:01 <ThreeQ> the NumValue thing will actually make a constructor that takes an Int and returns a value of type CardValue
19:51:45 <ThreeQ> so you can put "Queen" or "Jack" or "NumValue 10" for example
19:51:54 <ThreeQ> these are all CardValues
19:52:15 <hyrax42> application layout question: when using quickcheck, where do you put your properties?
19:52:15 <SamB_XP> why does the word "psychobabble" come to mind?
19:52:28 <SamB> hyrax42: in .hs files!
19:52:30 <hyrax42> in same file near function?  in same file at end?  in separate file?
19:52:40 <SamB> same file works fine!
19:52:51 <fpierre08> ThreeQ : tnx... although if you allow me to be honest.... i am not sure i understand the advantage of creating a data type?
19:53:04 <hyraxfourtwo> samB two can play this game
19:53:07 <hyraxfourtwo> ;)
19:53:12 <glguy> fpierre08: instead of using (Int,Int,Int) for storing Rank, Suit, and something, should might create a Card type Card Rank Suit Something
19:53:29 <SamB_XP> hyrax42: what, you also have an XP box and a Linux box?
19:53:54 <ThreeQ> data Card = Card { getFace :: Rank, getType :: Suit }
19:53:56 <hyraxfourtwo> ok but would you put the properties right after the given function or at the end... I'm thinking near makes function's purpose clearer but far clutters things less
19:54:07 <hyraxfourtwo> SamB_XP, XP and OS X
19:54:09 <ThreeQ> now you don't have to write selectors
19:54:15 <SamB_XP> hyraxfourtwo: oh
19:54:39 <SamB_XP> hyraxfourtwo: on a KVM?
19:54:58 <hyraxfourtwo> nah, oldskool
19:54:58 <ThreeQ> fpierre08: also it helps you and the haskell type checker make sure you're doing something meaningful
19:54:58 <hyraxfourtwo> two desks + wheely chair
19:54:58 <hyraxfourtwo> ;)
19:55:03 <SamB_XP> I haven't got enough room for that way!
19:55:14 <SamB_XP> or monitors, for that matter!
19:55:18 <hyraxfourtwo> well computer desk + writing desk
19:55:21 <hyraxfourtwo> jsut laptop is on writing desk
19:55:29 <hyraxfourtwo> I also have kvm but haven' tused it in a while
19:55:33 <fpierre08> ThreeQ : i see! so it's not only effeciant on level of coding but also easier for the interpreter if i understand correctly?
19:55:36 <SamB_XP> not enough $ for lappy
19:55:46 <hyraxfourtwo> les iBooks, ces pas chers
19:55:49 <ThreeQ> fpierre08: right
19:55:51 <hyraxfourtwo> ces sont*
19:56:19 <fpierre08> ThreeQ : k =) going to try to change my code... brb
19:56:20 <hyraxfourtwo> anyway, any input on where to put my properties?
19:56:27 <glguy> fpierre08: it also makes it more likely that someone else will be able to read your code
19:58:05 <SamB_XP> hyraxfourtwo: same file unless they start to be annoying, I guess...
19:58:15 <hyraxfourtwo> but end or?
19:58:19 <SamB_XP> a lot of people stick them at the bottom...
19:58:22 * hyraxfourtwo should read more other people's code
19:58:35 <SamB_XP> but if you'd rather mix them go ahead!
19:58:45 <hyraxfourtwo> if you're gonna derive Ord on Suit, you should put them in the right order
19:59:02 <hyraxfourtwo> are derived instances for enumerated types assumed ascendign or descending?
19:59:13 <glguy> asc
19:59:36 <hyraxfourtwo> so data Suit = Club | Diamond | Heart | Spade -- for most games
20:00:47 <hyrax42> w00t
20:00:49 <hyrax42> positions :: Position -> [Position]
20:00:52 <hyrax42> finally!
20:01:18 <hyrax42> gives all board positions reachable in one move from the current position
20:01:42 <hyrax42> of course...
20:01:49 <hyrax42> positions pos = map (makeMove pos) $ moves pos
20:01:54 <hyrax42> is rather anticlimactic
20:02:37 <kpreid> is there something less general than Data.Monad.mappend with the same effect on Ordering?
20:03:00 <hyrax42> ?docs Data.Monad
20:03:00 <lambdabot> Data.Monad not available
20:03:07 <hyrax42> ?docs Data.Monoid
20:03:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
20:03:19 <kpreid> Er, Data.Monoid, yes.
20:03:31 <hyrax42> what is the effect on Ordering?
20:04:49 <kpreid> the first unless it is EQ, in which case the second
20:05:25 <SamB> > mconcat [EQ,LT,GT]
20:05:26 <lambdabot> Terminated
20:05:28 <kpreid> it is such that "instance (Ord a, Ord b) => Ord (a,b) where compare (aa,ab) (ba,bb) = compare aa ba `mappend` compare ba bb" would work
20:05:33 <SamB> > mconcat [EQ,LT,GT]
20:05:35 <lambdabot> Terminated
20:05:50 <SamB> > mappend EQ LT
20:05:51 <lambdabot>  LT
20:06:03 <SamB> > mappend EQ (mappend LT EQ)
20:06:04 <lambdabot>  LT
20:06:15 * SamB wonders WTH is wrong with mconcat?
20:06:28 <SamB> > mempty :: Ordering
20:06:29 <lambdabot>  EQ
20:07:11 <kpreid> anyway, I'm defining an instance something like the above, and I'm wondering if there's something that is in fact more appropriate than mappend for that purpose
20:07:27 <kpreid> > mappend LT GT
20:07:28 <lambdabot> Terminated
20:07:41 <SamB> eek
20:07:51 <kpreid> > mappend GT LT
20:07:52 <lambdabot> Terminated
20:07:56 <kpreid> that's not right...
20:08:09 <hyrax42> I was just wondering the other day when one would ever use the Ordering instance of Monoid
20:08:14 <SamB> that doesn't happen on Lemmih's GHC 6.6...
20:08:53 <kpreid> nor ghci 6.4.2
20:09:17 <kpreid> > mappend LT GT `seq` 1
20:09:18 <lambdabot> Terminated
20:09:36 <hyrax42> weird
20:09:38 * SamB wonders why nobody has asked him what he is doing on Lemmih's computer
20:09:43 <hyrax42> works in my ghci 6.4.2 as well
20:09:53 <hyrax42> SamB: evil things?
20:09:57 <kpreid> > compare LT GT
20:09:58 <lambdabot> Terminated
20:09:58 <SamB> well.
20:10:07 <kpreid> > [LT..]
20:10:08 <lambdabot>  Parse error
20:10:24 <SamB> insofar as trying to run a "before and after" benchmark comparison on a patch for GHC's inliner is "evil"
20:10:35 <kpreid> > enumFrom LT
20:10:36 <lambdabot>  [LT,EQ,GT]
20:10:46 <SamB> > [LT ..]
20:10:48 <lambdabot>  [LT,EQ,GT]
20:10:55 <kpreid> ah
20:11:20 <hyraxfourtwo> LT.. parses as a qualified name?
20:11:28 <SamB> > id LT.. id
20:11:29 <lambdabot>  Not in scope: `LT..'
20:11:35 <SamB> ... yes
20:11:42 <SamB> an infix qualified name
20:11:49 <SamB> an *ugly* name
20:12:23 <hyraxfourtwo> ?let (.) = (*)
20:12:24 <lambdabot> Defined.
20:12:31 <hyraxfourtwo> > 1 L.. 2
20:12:33 <lambdabot>  2
20:12:48 <hyraxfourtwo> icky
20:13:20 <hyraxfourtwo> SamB, what diid you mean about "before and after" comparison being bad?
20:13:22 <kpreid> ?let (_|) = "bucket"
20:13:29 <lambdabot>  Parse error
20:13:29 <SamB> see, this is why you should always have alphabetical alternatives for your infix-ops-named-just-like-the-ones-in-Prelude
20:13:48 <kpreid> ?let (_I) = "bucket"
20:13:50 <lambdabot> Defined.
20:13:56 <kpreid> ? L._I
20:14:00 <hyraxfourtwo> or the inliner being evil ratehr
20:14:02 <kpreid> > L._I
20:14:04 <lambdabot>  "bucket"
20:14:17 <hyraxfourtwo> haha
20:14:21 <SamB> I wasn't implying that any of that was evil
20:14:52 <SamB> just saying that that was why I am on Lemmih's computer ;-)
20:15:16 <SamB> of course, I'm only sshing in
20:15:17 <hyraxfourtwo> ohhh missed the "insofar" and completely lost the context
20:15:21 <SamB> heh
20:15:44 <hyrax42> I thought you were saying the inliner somehow made it hard to benchmark things
20:15:51 <SamB_XP> heh
20:16:18 <SamB_XP> no. I'm supposed to benchmark code compiled with and without this patch applied to the compiler...
20:16:21 <SamB_XP> (using nofib)
20:16:32 <SamB_XP> or, rather, nofib is the code...
20:17:22 <SamB_XP> right now I'm rsyncing my working directory to Lemmih's box, since I've given up on getting it to build from HEAD...
20:17:30 <fpierre08> k... so tried creating data types for card and suit..... get an error stating malformed LHS to type of declaration... [http://rafb.net/paste/results/MviXJ879.html] can any1 help me understand ?
20:19:11 <hyrax42> nofib is
20:19:16 <kpreid> fpierre08: the name of a datatype must start with an uppercase letter
20:19:23 <kpreid> fpierre08: lowercase is reserved for type variables
20:19:24 <fpierre08> ow
20:19:27 <fpierre08> k
20:19:41 <SamB_XP> hyrax42: nofib is what?
20:19:49 <hyrax42> oh woops
20:19:55 <hyrax42> I was meant to say what you just said
20:20:17 <fpierre08> tnx :)
20:38:02 <Cale> > zip3 [1..52] (take 52 (cycle [1..13])) (concatMap (replicate 13) [1,2,3,4])
20:38:04 <lambdabot>  [(1,1,1),(2,2,1),(3,3,1),(4,4,1),(5,5,1),(6,6,1),(7,7,1),(8,8,1),(9,9,1),(10...
20:39:31 <fpierre08> cale : so that function creates the list i have for cards ?
20:39:34 <Cale> yep
20:40:12 <Cale> actually...
20:40:27 <Cale> zip3 [1..52] (cycle [1..13]) (concatMap (replicate 13) [1,2,3,4])
20:40:31 <Cale> that'll do the same
20:40:44 <Cale> since that [1..52] will run out after 52 cards :)
20:40:56 <fpierre08> so instead of having the entire thing listed, i should be putting that function instead?
20:41:02 <Cale> you could
20:41:27 <fpierre08> and it wouldn't cahnge anything to the rest of the program ?
20:41:31 <Cale> right
20:41:42 <Cale> I think it gives a better idea of what that list actually is :)
20:41:54 <fpierre08> that's pretty cool!
20:42:17 <Cale> even better would be to use deriving Enum on your datatypes and actually use the suits and values
20:43:17 <Cale> er, you might have to write an instance for CardValue, actually...
20:44:03 <hyrax42> zipWith3 Card [1..52] (take 52 (cycle [Two..Ace])) (concatMap (replicated 13) [Club..Spade]
20:44:48 <fpierre08> well about data types... i'm still trying to figure out how to use !! with this code... can i actually do something like "card !! inndex2" ?
20:44:50 <hyrax42> or some such
20:45:33 <fpierre08> that would then change the approach to randomly selecting the cards then right hyrax ?
20:46:00 <SamB> zipWith3 Card [1..52] (cycle [Two..Ace]) (concatMap (replicate 13) [Club..Spade]
20:46:49 <Cale> lisppaste2: url
20:46:49 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:46:56 * SamB goes to bed
20:47:02 <SamB> rsync is still going...
20:47:06 <hyrax42> oh ya take 52 not needed
20:47:27 <hyrax42> ah laziness and magic
20:47:32 <Lemmih> SamB: Is it slow?
20:47:34 <SamB> hyrax42: also you had a d after replicate ;-)
20:47:44 <hyrax42> SamB: never did
20:47:44 <SamB> Lemmih: huh?
20:47:46 <hyrax42> you can't prove it
20:47:57 <SamB> the problem is my upload is only about 40k
20:48:02 <SamB> er, 50k
20:48:10 <Lemmih> Ah,
20:48:13 <SamB> anyway, I go to bed...
20:48:31 <SamB> -- I'll start it building in the morning
20:49:18 <SamB> I tried already but it kept having type errors or scope errors...
20:49:55 <fpierre08> zipWith3 Card [1..52] (cycle [Two..Ace]) (concatMap (replicate 13) [Club..Spade] could i replace it by : zipWith3 Card [1..52] (cycle [CardValue]) (concatMap (replicate 13) [CardSuit] ?
20:50:52 <hyrax42> fpierre08: no
20:50:57 <lisppaste2> Cale pasted "cards" at http://paste.lisp.org/display/27934
20:50:58 <hyrax42> as CardSuit is a type
20:51:13 <hyrax42> not an actual list
20:51:20 <hyrax42> I mean [CardSuit]
20:51:32 <hyrax42> same for [CardValue]
20:52:01 <hyrax42> you could somewhere define cardValues = ... and cardSuits = [Club..Spade]
20:52:05 <hyrax42> and then use those
20:52:32 <Cale> (look at my paste :)
20:53:06 <fpierre08> looking @ it right now Cale ! tnx :)
20:53:26 <fpierre08> hyrax: so the same way cale defined Cards ?
20:53:47 <fpierre08> hm
20:55:40 <hyrax42> wait why do you want [(Int,Card)]?
21:00:01 <fpierre08> hyrax : if i understood correctly what cale is doing, since he is doing an enum, the int will simply be what will get the card value and Card will be the Suit
21:00:21 <fpierre08> hyrax / cale : am i anywhere close?
21:00:33 <Cale> fpierre08: I'm defining Enum so that you can write things like [Ace .. King]
21:00:40 <Cale> to get the full range of cards
21:00:56 <fpierre08> yeah.. so that why u did : cards :: [(Int, Card)]
21:01:01 <Cale> as an added side effect, you get a nice way to get the integer value of a card
21:01:17 <fpierre08> Int was because of the Enum and Card was because of the suit ? no ?
21:01:38 <lisppaste2> hyrax42 annotated #27934 with "instance Enum Card" at http://paste.lisp.org/display/27934#1
21:01:50 * hyrax42 thinks that is a better solution than the zipped list
21:02:07 <hyrax42> > 51 `divMod` 13
21:02:09 <lambdabot>  (3,12)
21:02:10 <ThreeQ> [a..b] is syntactic sugar for enumFromTo a b, which has a domain of any Enum
21:02:21 <hyrax42> missing a 1+ in there I think
21:03:00 <fpierre08> hyrax : a little too deep for me :$
21:03:14 <hyrax42> but with that instance you could right
21:03:35 <hyrax42> cards = [(Card Club Ace)..(Card Spade King)]
21:03:50 <hyrax42> Cale: correct me if I'm wrong!
21:05:05 <Cale> hyrax42: if you have an Enum instance for Card, yes
21:05:21 <hyrax42> Cale: see up, I just defined it
21:05:31 <hyrax42> though I *am* off by one
21:06:15 <hyrax42> are n+k patters allowed inside tuples?
21:06:40 <hyrax42> > let (a, b-1) = 51 `divMod` 13 in (a,b)
21:06:40 <lambdabot>  Parse error in pattern
21:06:49 <hyrax42> guess not
21:07:00 <hyrax42> > let a-1 = 2 in a
21:07:01 <lambdabot>  Not in scope: `a'
21:07:19 <hyrax42> > let (a+1) = 2 in a
21:07:20 <lambdabot>  Parse error in pattern
21:08:48 <hyrax42> oh you can't match n+k in a let?
21:08:52 <ThreeQ> lambdabot's parser is broken
21:09:17 <ThreeQ> Prelude> let (a+1) = 2 in a
21:09:18 <ThreeQ> 1
21:09:39 <hyrax42> - doesn't work though
21:11:09 <lisppaste2> fpierre08 pasted "!! ?" at http://paste.lisp.org/display/27938
21:11:11 <hyrax42> I mean n-k
21:11:16 <fpierre08> Cale : so using your ur part of the code... i'm now back to square one.... how can i use "!!" in order to be able to obtain a random card ?
21:11:52 <Cale> fpierre08: http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers -- check this out
21:11:57 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
21:12:22 <hyrax42> fpierre08: fyi show (show ..) will proably not do what you want
21:12:27 <hyrax42> > show (show 5)
21:12:28 <lambdabot>  "\"5\""
21:14:04 <fpierre08> hm.. k.. tnx hyrax
21:14:13 <fpierre08> Cale : how did you fall on that?!
21:14:59 <Cale> fpierre08: I wrote the answer to the guy's question there
21:15:05 <Cale> seems similar to yours :)
21:19:22 <fpierre08> Cale : what is mapM_ ?
21:20:03 <Cale> have you yet used monads much?
21:20:09 <Cale> Or at least the IO monad?
21:20:47 <fpierre08> never
21:20:49 <Cale> mapM_ f xs will apply f to each element of xs, getting an action to be run, and then runs all the actions in turn, discarding their results
21:21:30 <fpierre08> my classes before this... were intro to programming (c++) and Programming language 1 (Java)
21:21:31 <Cale> without the _, that is, with just mapM, the action constructed would construct a list of the results instead
21:21:39 <Cale> okay
21:21:58 <Cale> working with random numbers in Haskell involves some knowledge of how IO is handled
21:22:35 <Cale> So one thing I'd recommend you read first is http://www.haskell.org/haskellwiki/Introduction_to_IO
21:22:38 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/ft8nk
21:22:58 <Cale> which is a very quick intro to how IO is treated
21:25:24 <fpierre08> k
21:25:51 <hyrax42> is that Bulat's thing
21:25:52 <hyrax42> or
21:25:54 <hyrax42> ah no
21:26:02 <hyrax42> good !
21:26:07 <hyrax42> was gonna say
21:26:15 <Cale> no, it's mine :)
21:26:28 <Cale> I have a habit of passing out references to things which I've written :)
21:26:40 <hyrax42> well Bulat's is a good deal longer and more with the innards
21:26:50 <hyrax42> so I thought it would be  alittle inappropriate
21:27:01 <hyrax42> or an explanation of how the innards might work
21:27:36 <hyrax42> type IO = State RealWorld
21:27:45 <hyrax42> or some such
21:27:48 <Cale> I really don't like that description of the IO monad
21:28:07 <Cale> because there's no appropriate type RealWorld which could be used.
21:28:32 <hyrax42> how do you prefer to describe it then?
21:28:39 <hyrax42> ?hoogle RealWorld
21:28:40 <lambdabot> Control.Monad.ST.RealWorld :: data RealWorld
21:28:44 <hyrax42> !
21:28:46 <hyrax42> ;)
21:29:12 <Cale> More abstractly: a value of type (IO a) is simply an action, which if ever performed, would produce a value of type a
21:29:32 <Cale> Like a program which spits out a value of type a when it's run.
21:30:00 <Cale> and then return and >>= are just ways to combine such programs into larger ones.
21:30:18 <Cale> It then doesn't matter how the compiler implements the IO type.
21:30:19 <hyrax42> well I think that's how everyone ends up thinking of it when using it
21:30:23 <Cale> yes
21:30:31 <Cale> and that's actually closer to the truth, I think
21:30:50 <hyrax42> I like the characterisation of a Haskell implementation
21:31:00 <hyrax42> it's only job is to ensure that main :: IO () runs
21:31:07 <Cale> hehe
21:31:22 <hyrax42> and do as little as possible in the process
21:31:42 <Cale> Control passes back and forth between what I'd call execution, and evaluation.
21:32:00 <hyrax42> though I saw there is support for main :: Show a => IO a in 6.5?
21:32:10 <hyrax42> hmm
21:32:38 <Cale> Execution is the carrying-out of IO actions, and in order to determine which IO action should be carried out, due to bind, evaluation may have to occur.
21:32:54 <hyrax42> nice way to think of it
21:32:58 <Cale> evaluation is completely side-effect free
21:36:03 <hyrax42> I don't do enough darcs records
21:36:46 <hyrax42> ok it's bedtime for me
21:37:13 <fpierre08> gn hyrax! tnx for the help
21:37:28 <hyrax42> heh not sure how much it actually helped
21:37:31 <hyrax42> but your wellcome
21:37:35 <hyrax42> welcome
21:37:38 <hyrax42> and goodnight
21:38:15 <fpierre08> it did! i have a lot to learn so trust me it's pointing me in the right path! n tnx
21:42:45 <fpierre08> Cale : i think i'm too tired to understand anything more ... been reading the same paragraph from ur IO intro 4 times now :$
21:43:02 <fpierre08> Cale : tnx for the help tonight!
21:43:04 <Cale> fpierre08: get some sleep and return to it in the morning ;)
21:43:17 <Cale> You're quite welcome :)
21:43:31 <fpierre08> working in the morning but when i come back then i will ! :)
22:53:35 <ThreeQ> anyone alive in here?
22:53:59 <ThreeQ> i'm having typeclass troubles :/
22:57:40 <Cale> what's up?
22:58:52 <lisppaste2> ThreeQ pasted "why doesn't list typecheck?" at http://paste.lisp.org/display/27940
22:59:44 <ThreeQ> "Could not deduce (Htmlable (HTML [b1]) [b]) from the context (Htmlable a b)"
22:59:49 <ThreeQ> "Could not deduce (Htmlable a b1) from the context (Htmlable a b)"
23:00:46 <ThreeQ> I have a vague understanding of what's wrong, but no clue how to fix it
23:01:08 <Cale> possibly by adding typesignatures
23:01:24 <Cale> or maybe by adding a functional dependency, if possible
23:01:57 <Cale> well, there's still errors, with the fundep, but it clears those up
23:02:03 <Cale> class Htmlable a b | a -> b where
23:02:20 <ThreeQ> what does that do?
23:02:33 <Cale> that means that a determines b uniquely, which lets the compiler infer b from a based on the instances available
23:03:10 <ThreeQ> ah, makes sense
23:03:11 <ThreeQ> thanks!
23:03:28 <Cale> oh, the only thing wrong after that is your typesignature for page
23:03:36 <Cale> page :: HTML [()]
23:04:58 <ThreeQ> yeah, I figured that part out :)
23:06:44 <Cale> Functional dependencies are an extension, but a very common one.
23:43:26 <phr-newbie> @pl \x -> (f x) + (g x)
23:43:26 <lambdabot> liftM2 (+) f g
23:43:32 <phr-newbie> hmm
23:43:44 <phr-newbie> ?type liftM2
23:43:45 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:58:47 <phr-newbie> @hoogle liftM2
23:58:47 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
23:58:48 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
