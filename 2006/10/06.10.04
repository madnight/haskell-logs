00:00:08 <joelk> Well, I'll paste what I did. Take a look and tell me how to make it simpler!
00:00:10 <lisppaste2> joelk pasted "multApply!" at http://paste.lisp.org/display/27320
00:01:53 <hyrax42> huh
00:02:03 <hyrax42> dons, is that the "build" trick you mentioned?
00:02:43 <dons> no?
00:02:47 <hyrax42> ok
00:02:49 <hyrax42> just curious
00:03:58 * macron is back
00:04:10 <hyrax42> type constructors are curried?
00:04:34 <weitzman> @kind Either
00:04:35 <lambdabot> * -> * -> *
00:04:39 <weitzman> @kind Either Bool
00:04:41 <lambdabot> * -> *
00:04:45 <hyrax42> oh I knew that
00:04:55 <hyrax42> thanks
00:05:06 <dons> hyrax42: ok, clarified 'clean' a bit.
00:05:14 <dons> you pondering ReaderT ?
00:06:08 <hyrax42> well I've used ReaderT etc. just I always explicitly put the (univerally quantified?) 'a' type variable in
00:06:14 <hyrax42> at least I think I did
00:06:31 <hyrax42> just caught me off guard
00:07:13 <dons> ok, I clarified that a bit too now.
00:07:33 <hyrax42> k
00:11:42 <dons> ?uptime
00:11:43 <lambdabot> uptime: 4d 8h 17m 40s, longest uptime: 4d 20h 30m 23s
00:11:47 <dons> ?users
00:12:26 <lambdabot> Maximum users seen in #haskell: 241, currently: 208 (86.3%), active: 24 (11.5%)
00:13:22 <Bobstopper> Does anyone know if there are problems with running haskelldb on ghc 6.4.2? They conflict on debian...
00:15:17 <hyrax42> @type bracket
00:15:19 <lambdabot> Not in scope: `bracket'
00:15:25 <hyrax42> ?type System.IO.bracket
00:15:27 <lambdabot> Not in scope: `System.IO.bracket'
00:15:32 <hyrax42> ?index bracket
00:15:33 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
00:15:43 <hyrax42> ?type Control.Exception.bracket
00:15:44 <dons> ah, better state where it is.
00:15:45 <lambdabot> forall c a b. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
00:15:55 <hyrax42> haha
00:16:08 <hyrax42> well the imprt is there
00:16:15 <hyrax42> I was just guessing
00:16:40 <hyrax42> one thing that conufsed me is in the run-up to the full code
00:16:47 <dons> yeah?
00:16:48 <hyrax42> loop st = runReaderT run st
00:16:52 <hyrax42> the run is free
00:16:57 <dons> ah
00:16:58 <hyrax42> and has no context
00:17:00 <hyrax42> till you get lower
00:17:01 <hyrax42> down
00:17:06 <dons> oh it is.
00:17:08 <dons>  oops
00:17:22 <dons> well spotted
00:17:40 <hyrax42> ha well it had me searching the whole document for " run " to make sure I wasn't missign something obvious
00:18:58 <dons> ok, fixed.
00:19:04 <dons> (I just explain what 'run' does)
00:19:47 <hyrax42> yeah
00:19:50 <hyrax42> saves the double take
00:20:19 <hyrax42> is there any reason why the <haskell> form in the wiki doesn't link to docs of more things?
00:20:29 * hyrax42 doesn't want to image the php hackery needed to make taht work
00:20:32 <dons> yeah, seems like on the Prelude stuff is generated.
00:20:35 <dons> only
00:20:41 <dons> probably we could fix this.
00:20:46 <hyrax42> one day
00:20:48 <hyrax42> but not today
00:20:49 <hyrax42> ;)
00:20:59 <dons> right
00:23:54 <hyrax42> ah, this code answers a question I had
00:24:19 <hyrax42> on how to close sockets wher eyou just have the handle from connectTo
00:24:45 <hyrax42> which is just hClose... I guessed but wasn't certain
00:24:58 <dons> yep
00:27:46 <hyrax42> @type Control.Exception.bracket_
00:27:48 <lambdabot> forall c b a. IO a -> IO b -> IO c -> IO c
00:30:01 <hyrax42> could you include along with an external transcript, the transcript of what gets written to stdout (in the final case, at least)
00:30:36 <dons> yep ok.
00:30:47 <dons> that's a good idea
00:31:27 <hyrax42> ok
00:31:38 <hyrax42> well it loosk good
00:31:49 <hyrax42> I learned a bunch of useful stuff
00:31:55 <hyrax42> hope I helped
00:32:10 <hyrax42> but now it's 3.30am and I should really be dreaming of lambdas
00:32:29 <hyrax42> (or at least will be, given how much haskell sutff I was reading today)
00:32:39 <dons> thanks heaps!
00:32:41 <hyrax42> wasn't able to read the uptime part
00:32:53 <hyrax42> will do tomorrow though
00:33:10 <hyrax42> you're in .au right?
00:33:14 <hyrax42> ?localtime dons
00:33:17 <lambdabot> Local time for dons is Wed Oct  4 17:32:53 2006
00:33:30 <dons> i'll probably just release it tonight anyway
00:33:47 <Bobstopper> Hey hey, aussies rock :)
00:33:55 <hyrax42> you might want to time it with peak US browsing time
00:33:57 <hyrax42> ;)
00:34:13 <hyrax42> which is in 6-9 hours I think
00:34:14 * macron is back
00:34:15 <dons> yeah. that's a good idea
00:34:18 <dons> will do so.
00:34:22 <hyrax42> everyone browses first thing at work
00:34:22 <hyrax42> hehe
00:34:29 <hyrax42> ok, now good night!
00:34:35 <dons> cheers, night!
01:09:28 <dons> anyone else around who'd like to comment on http://haskell.org/haskellwiki/Roll_your_own_IRC_bot ?
01:09:32 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
01:10:13 * araujo back
01:10:28 <dons> hey
01:11:30 <araujo> dons, good, this will make my job of coding anirc client easier
01:11:32 <araujo> :-)
01:14:59 <dons> :)
01:16:41 <dons> joelk: http://haskell.org/haskellwiki/Polyvariadic_functions
01:16:44 <lambdabot> Title: Polyvariadic functions - HaskellWiki, http://tinyurl.com/hffez
01:17:33 <joelk> Thanks!
01:19:47 <joelk> In this case though, it's not a polyvariadic function, but a higher-level function that handles functions with an arbitrary number of args.
01:20:21 <joelk> Are those two more similar than I'm thinking?
01:21:09 <dons> i think your case is a simple version of the general polyvariadic case.
01:21:15 <dons> maybe
01:21:52 <joelk> but in the call multApply f xs, each of those functions takes a fixed number of args, there are no polyvariadic functions.
01:23:48 <joelk> anyway, I posted to haskell-cafe, hoping for enlightenment!
01:37:38 <joelk> dons, wow... ok, that variadic list builder on Oleg's page sure looks a lot like my function applier.
01:52:08 <ThreeQ> dons: in the IRC bot tutorial, why do you say (PortNumber (fromIntegral port)) instead of just (PortNumber port)?
01:52:17 <dons> oh, its a hugs compat issue
01:52:25 <dons> hugs comes with an older Network lib
01:52:30 <dons> with a Word16 port number
01:52:31 <ThreeQ> oh
01:52:44 <dons> so there's that one line to help out hugs users
01:52:55 <dons> hey, cool. someone posted to reddit, http://programming.reddit.com/
01:52:58 <lambdabot> Title: reddit.com: programming - what&#39;s new online
01:53:03 <ThreeQ> that was me :)
01:53:07 <dons> ah :)
01:53:10 <dons> ThreeQ++
01:53:45 <dons> everyone get voting!
02:04:00 <dons> ok, we're at #3. vote! http://programming.reddit.com/info/ktep/details
02:04:03 <lambdabot> Title: Roll your own Haskell IRC bot (reddit.com), http://tinyurl.com/jym32
02:06:32 <dons> ooh. #2 ...
02:09:35 <Itkovian> it requires another account to be created :-(
02:10:47 <dons> yeah, pretty easy to do though, if you'd like.
02:10:57 <dons> just a username and passwd
02:17:38 <joelk> dons, as usual, thanks for the pointers. good night
02:34:56 <musasabi> I think I found a problem with Data.ByteString.Lazy.
02:35:14 <dons> oh?
02:35:48 <musasabi> dons: when reading from a socket I have request with N bytes. Thus I'd like to do splitAt n. But splitAt blocks until the lazy string is n+1 bytes long.
02:36:09 <dons> oh hmm.
02:36:31 <musasabi> same with take.
02:37:31 <dons> let's see what dcoutts thinks. he looked into this non blocking stuff recently
02:38:07 <musasabi> dons: try e.g. Data.ByteString.Lazy.take 3 (fromChunks [read "\"foo\"",error "Hii"])
02:39:18 <dons> > take 3 ("foo" ++ error "Hi")
02:39:19 <lambdabot>  "foo"
02:39:25 <dons> ah. interesting
02:40:22 <musasabi> It is quite important for a network protocol where we need to read packets of length N and the client blocks until we respond (thus the whole thing just hangs).
02:40:36 <dons> right.
02:40:45 <dons> now I'm wondering why we haven't seen this before.
02:40:58 <dons> oh, maybe because we used to expose hGetN
02:41:27 <musasabi> And with disk things the extra eagerness is rarely a problem in practice.
02:41:49 <musasabi> I am using hGetContents for the IO part.
02:42:06 <dons> you could try commenting out,
02:42:06 <dons> --      hGetN,                  -- :: Int -> Handle -> Int -> IO ByteString
02:42:07 <dons> --      hGetContentsN,          -- :: Int -> Handle -> IO ByteString
02:42:07 <dons> --      hGetNonBlockingN,       -- :: Int -> Handle -> IO ByteString
02:42:19 <dons> and seeing if that'll work.
02:42:30 <dons> but looks like we'll have to work out why its asking for the extra char
02:43:46 <musasabi> Something that would work with 6.6 would be extra-nice since that is what HAppS has to work with.
02:44:03 <dons> yeah.
02:44:15 <dons> well, you can always inline hGetN or hGetnonBlockingN, if needed
02:47:07 <musasabi> Found the problem.
02:47:17 <musasabi> will paste it to web. 5min.
02:47:30 <musasabi> or would you prefer a patch?
02:50:03 <dons> a patch is good too
02:50:10 <dons> even better, in fact
02:51:42 <dons> yay, #1 :)
02:51:55 <dons> http://programming.reddit.com/
02:51:58 <lambdabot> Title: reddit.com: programming - what&#39;s new online
02:52:28 <musasabi> hmm. is "<" and "==", better than "compare" for Int64 ? (just optimizing) ?
02:52:41 <dons> take that Paul Graham!
02:52:50 <dons> hmm. should end up as the same thing
02:52:58 <musasabi> ok
02:56:22 <roconnor> @hoogle [Bool] -> Bool
02:56:24 <lambdabot> Prelude.and :: [Bool] -> Bool
02:56:24 <lambdabot> Prelude.or :: [Bool] -> Bool
03:07:00 <dcoutts> musasabi, good work! off by one error eh?
03:07:29 <roconnor> :type when
03:07:38 <roconnor> @type when
03:07:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:07:43 <dcoutts> musasabi, if it's a trivial bug fix patch we may yet be able to get it into 6.6
03:08:32 <dcoutts> musasabi, it is certainly our intention to have hGetContents work in the way you describe, to make it suitable for use in network stuff.
03:12:03 <musasabi> dcoutts: I have the fix, just running the tests.
03:16:54 <dcoutts> musasabi, great
12:06:24 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
12:06:24 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
12:06:24 --- names: list (clog paolino jtoy_ mnislaih hawking pandres cptchaos dgoldsmith esap Itkovian mascht xinming bringert moonlite sris spreeker wchogg yip saccade newbcoder jgrimes Nshag gour fasta lhz twanvl foxy jzhang araujo meren ValarQ Syzygy-_ weitzman Patterner mjl69 xerox ramki dfeuer psi mGem szabi_ dottedmag pyronicide Carillon_ hyrax42 beschmi psykotic iblechbot der_eq GeoBesh slipstream-- Narrenschiff madpickle Xgc jak_ arjanoosting \z chris2 Prip)
12:06:24 --- names: list (nick8325 russo zzctb BCoppens kpreid therp l_a_m ikegami-- nothingmuch johs arjanb Skal _Alek_ roconnor qz Mibori _velco Muad_Dibber eno macron dmwit ThreeQ ibid Jaak svens dechunker lennart kosmikus juhp Spark Codex_ profmakx kaol mornfall ricebowl wolverian audreyt khaladan gaal glguy edwinb arcatan Pupeno takuan cods Philippa_ wilx drbean sellout cwenner Bobstopper Revision17 Kahdloc binary42 Tigge ashleyb mathrick Lunar^ converter Betovsky)
12:06:24 --- names: list (lollan Trix rahikkala Maddas tic dvekravy Eidolos lisppaste2 carp liyang ohub TSC ChilliX cjay Narcisse giksos ex__nor Godeke moconnor mattam scsibug dfranke epiphone explicitjelly Korollary Nioate_ Adamant fnordus flux__ sceadu Cale earthy ski lambdabot cmeme cschneid eyck SimonRC noj Igloo chrisb_ tmoertel_away deadbeef _frederik_ ulfdoz zamez tessier_ mlh_ norpan nnunley dany2k Khisanth Lemmih arguile kilimanjaro tessier Twigathy sjanssen)
12:06:24 --- names: list (Baughn joe_k bdash boliver__ scw cathper integral bran_ SamB woggle petekaz newsham sieni df_ dcoutts lispy TwigEther lucca irgs aleator gds ksandstr_ dylan ozone nattfodd bartw cpatrick pingu kpk orbitz dons mux kzm dwm kalven rycee Thomas2_ resiak qwr Azmo_ kolmodin pejo emu dcoutts_ psnl magagr musasabi nomeata jmob gdsx shrimpx)
12:26:28 <MarcWeber> Anyone working with vim to write haskell code? I'd like to share some scripts.
12:28:31 <dylan> MarcWeber: Share with me! ;-D
12:29:38 <hawking> and me!
12:29:47 <cjay> put it in the wiki
12:30:40 <dylan> hmm, Î» looks nothing like a lambda
12:31:44 <MarcWeber> dylan. Wait 2 minutes.
12:31:59 <cjay> looks strange in my font, too
12:32:04 <cjay> but it is a lambda
12:32:22 <dylan> it should be made shorter or something.
12:33:48 <dblhelix> @seen SyntaxNinja
12:33:49 <lambdabot> I saw SyntaxNinja leaving #haskell 2h 46m 32s ago, and .
12:34:08 <dylan> MarcWeber: and you should probably put this on the wiki, as cjay said
12:34:10 <wilx> It looks nicely lambdaish here.
12:34:31 <dylan> Friend of mine actually asked "What's the lambda icon in your bookmarks?"
12:34:55 <dylan> (he reads / speaks a little greek)
12:35:16 <roconnor> the C++ UM sees to leak memory
12:35:29 <roconnor> either that or is it normal for the adventure game to take 800 Megs?
12:36:39 <MarcWeber> dylan, cjay. I's organizend as some kind of lib.. (autoload).  So perhaps it would be difficult. I've to alter one function. I'll compress it and  I'll send it to you. We can discuss on how to put it onto the wiki then.
12:37:25 <dylan> MarcWeber: well, I imagine you'd upload it somewhere and link from the wiki.
12:39:06 <bartw> roconnor adventure does tend to use alot of memory
12:39:15 <bartw> but the UM probably has a leak somewhere
12:39:31 <bartw> or does not handle very small allocs gracefully
12:40:07 <sjanssen> MarcWeber: what kind of code do you have?
12:40:37 <MarcWeber> Module an function completion.
12:40:45 <sjanssen> oh neat
12:40:54 <dylan> MarcWeber: What about indentation? ;)
12:40:56 <sjanssen> have you considered just making a darcs repo?
12:41:02 <MarcWeber> So you can write i<tab CMS<your abbrev> to get import Control.Monad.State
12:41:17 <sjanssen> I bet there's plenty of other scripts we can gather
12:41:30 <MarcWeber> sjansen I want to publish it in the near future. But to be honest, I'm lacking time and need some ideas.
12:41:39 <dylan> Dons has an indenter script I've been trying to get at for a bit. ;)
12:42:17 <dylan> MarcWeber: does this use the new intelligent completion of vim7?
12:42:35 <MarcWeber> dylan Sure.
12:42:55 <musasabi> autoindention + ghci with vim would be very nice.
12:43:47 <MarcWeber> Just type gC<your abbrev> or getCon to complete to get Content. Really nifty. It does have one drawback. It doses't recognize export restrictions.. So it just scans all imported files up to level x .. ;-) But it working great. Let me install apache on my server..
12:44:46 <MarcWeber> You can also press gf on a imported module to jump to it or get a list of possibilities.
12:48:58 <roconnor> @hoogle gc
12:48:58 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
12:48:59 <lambdabot> Data.Typeable.gcast :: (Typeable a, Typeable b) => c a -> Maybe (c b)
12:48:59 <lambdabot> Data.Typeable.gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
12:49:08 <roconnor> @hoogle IO ()
12:49:09 <lambdabot> Control.Concurrent.yield :: IO ()
12:49:10 <lambdabot> Distribution.Simple.defaultMain :: IO ()
12:49:10 <lambdabot> System.Mem.performGC :: IO ()
12:50:09 <kolmodin> have a look at hinotify, a newly released lib: http://article.gmane.org/gmane.comp.lang.haskell.general/14345
12:50:12 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/kpdpc
13:13:12 <MarcWeber> dylan, sjanssen, cjay http://mawercer.de/vl.zip. unpack it somwhere and move the autoload directory into .vim/
13:14:18 <nomeata> ?paste
13:14:19 <lambdabot> http://paste.lisp.org/new/haskell
13:14:50 <lisppaste2> nomeata pasted "Reversable Classes" at http://paste.lisp.org/display/27349
13:14:55 <sjanssen> MarcWeber: do you know darcs?  I bet if you stuck this in a darcs repo you'd start getting patches . . .
13:15:21 <nomeata> Hi. I try to create a function that deeply "reveres" everything, to play around with type classes.
13:15:29 <nomeata> the pasted code gives me:
13:15:42 <nomeata>     Illegal instance declaration for `Reversable (a, a)'
13:15:46 <nomeata>         (The instance type must be of form (T a b c)
13:15:48 <nomeata>          where T is not a synonym, and a,b,c are distinct type variables)
13:15:50 <nomeata>     In the instance declaration for `Reversable (a, a)'
13:15:54 <nomeata> what am I doing wrong?
13:16:09 <SamB> mmm
13:16:16 <sjanssen> nomeata: you probable mean "instance (Reversable a, Reversable B) => Reversable (a, b)"
13:16:20 <MarcWeber> sjanssen: Sure I know.. I'll put it into darcs till tomorrow.
13:16:26 <SamB> sjanssen: eek
13:16:39 <SamB> maybe you mean...
13:16:43 <nomeata> sjanssen: not really, as then the result would be (b,a) which is not (a,b), and thus does not fit "rev :: a -> a"
13:16:43 <MarcWeber> http://rafb.net/paste/results/L8XPF141.html <- this is my ftplugni haskell.vim file
13:17:00 <sjanssen> nomeata: ah yes
13:17:09 <nomeata> I mean, I wish I could do that, but I'd like to start with the simpler case of both types the same
13:17:19 <sjanssen> nomeata: well, you might try -fglasgow-exts with GHC or -98 with hugs
13:17:41 <nomeata> indeed that helps
13:17:42 <SamB> isntance (Reversable a b, Reversable c d) => Reversable (a, c) (d, b)
13:17:42 <MarcWeber> naiveD
13:17:49 <SamB> er, s/isntance/instance/
13:18:22 <sjanssen> yeah, you're going to need MPTC (and probably fundeps) if you want to do this right
13:18:32 <SamB> (along with "class Reverable a b | a -> b, b -> a")
13:19:00 <nomeata> I get     No instance for (Reversable (a, b))...
13:19:05 <nomeata> but I just defined an instance...
13:20:36 <nomeata> ah, nevermind, I tried it with (1,2), but I did not have Reversable for Ints yet
13:21:46 <nomeata> nice, with -fallow-undecidable-instances I can define rev for all types
13:21:51 <nomeata> rev = id
13:22:05 <SamB> ???
13:22:27 <nomeata> as a fallback
13:22:27 <sjanssen> nomeata: undecidable instances should be avoided at all costs
13:22:38 <SamB> yes yes
13:22:44 <nomeata> instance Reversable a where rev = id
13:23:06 <nomeata> shoudn't that be the last line, so I can reverse anything, even if it contains Chars, Ints or functions?
13:24:09 <MarcWeber> dylan, sjanssen, cjay autoload/vl/dev/haskell/modules_list_cache_jump.vim is the file to start reading.
13:24:32 <SamB> I remember once me and adept wrote essentially the same patch at roughly the same time (modulo naming and corner-cases) in our hurry to get rid of a use of overlapping instances... don't remember if they were decidable or not...
13:25:01 <SamB> nomeata: arguably reversing an Int should switch the bit-order!
13:25:28 <nomeata> hmm. when I do rev $ Left "bla" , haskell complains that it does now what which instanste to use
13:25:36 <nomeata> but rev $ ( Left "bla" )::(Either [Char] [Char]) works
13:26:06 <sjanssen> @type Left "bla" -- this is not monomorphic
13:26:07 <lambdabot> forall b. Either [Char] b
13:26:47 <nomeata> an haskell can't tell from the fact that I am using "rev" on it that it has to be 'Either a a', with equal types?
13:26:50 <SamB> nomeata: might work better if you didn't use overlapping, undecidable instances ;-)
13:26:51 <sjanssen> nomeata: Haskell can't know which instance to use until all type variable have been eliminated
13:27:04 <nomeata> but true, it could be 'Either a something', which matches my fallback...
13:27:06 <sjanssen> nomeata: probably not
13:27:33 <nomeata> I'm just experimenting how far I get here with my haskell knowledge so far
13:29:46 <SamB> hmmm
13:29:57 <SamB> not allowed cyclic superclasses :-(
13:30:28 <nomeata> instance (Reversable b, Functor a) => Reversable (a b) where	rev = fmap re
13:30:38 <nomeata> that's cool. a fallback for stuff like Maybe
13:30:47 <SamB> nomeata: please
13:30:50 <SamB> stop
13:30:52 <SamB> now!
13:31:37 <nomeata> *Main> rev $ Just (Just "ti t'nsi ,nuF",Just " s'ti tuB")
13:31:38 <nomeata> Just (Just "But it's ",Just "Fun, isn't it")
13:40:07 <dylan> MarcWeber: cool, I'll look into it when I get home
13:40:14 <nomeata> Main> rev Node {rootLabel = "root", subForest = [ Node {rootLabel = "blub", s>
13:40:15 <nomeata> Node {rootLabel = "toor", subForest = [Node {rootLabel = "alb", subForest = []},Node {rootLabel = "bulb", subForest = []}]}
13:41:32 <nomeata> would there be a way to make _any_ n-tuple an instance of Reversable?
13:44:36 <SamB> you'd need to mess with Generics at the least...
13:44:46 <SamB> (to do anything the sort)
13:45:59 <glguy> I'm trying to think of a less useful thing than a generalization for reversing tuples
13:48:21 <MarcWeber> dylan, sjanssen, cjay : If you find any errors/problems.. (There will be many).. Don't hesitate to drop me a mail
13:49:07 <cjay> ok, I'll try it out after eating :)
13:50:16 <Lemmih> @seen Kzzch
13:50:16 <lambdabot> Kzzch is in #haskell. I don't know when Kzzch last spoke.
13:50:36 * glguy doesn't remember Kzzch ever speaking
13:50:41 <SamB> Reverse> rev ("Hello!", 1::Int)
13:50:41 <SamB> (-2147483648,"!olleH")
13:51:08 <dylan> MarcWeber: email address is in the archive somewhere?
13:51:27 <SamB> glguy: especially considering that in nomeata's scheme all the type parameters need to be the same?
13:52:03 <glguy> The point of a tuple is that it's a generic data type that you can use for whatever you need to store multiple pieces of information
13:52:20 <glguy> the only time that the order of that data matters is the default Ord instance
13:53:05 <glguy> on occasion it matters for uncurried functions
13:53:09 <MarcWeber> dylan: Yeah. see autoload/vl/dev/haskell/*
13:53:21 * dylan nods
13:53:23 <glguy> but I can't see how a generalization would ever be useful for more than a poor mans encryption scheme
13:53:47 <glguy> especially if it is a recursive operation
13:53:59 <nomeata> It's not supposed to be useful
13:54:03 <nomeata> :-)
13:55:28 <chessguy> @type Bool
13:55:29 <lambdabot> Not in scope: data constructor `Bool'
13:55:32 <chessguy> @type Boolean
13:55:34 <lambdabot> Not in scope: data constructor `Boolean'
13:55:55 <kosmikus> @kind Bool
13:55:57 <lambdabot> *
13:56:07 <glguy> ?type True
13:56:08 <lambdabot> Bool
13:56:29 <chessguy> kind?
13:57:00 <kosmikus> the type of a type
13:57:10 <chessguy> ok
13:57:20 <kosmikus> @kind []
13:57:21 <lambdabot> * -> *
13:57:35 <kosmikus> chessguy: * is for types that have values
13:57:37 <glguy> everyone's favorite:
13:57:44 <Lemmih> @kind (->) -- this is when it starts getting funny.
13:57:45 <lambdabot> ?? -> ? -> *
13:57:45 <glguy> ?kind Control.Monad.RWS.RWST
13:57:47 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
13:57:48 <kosmikus> chessguy: [] is a function that takes value-types to value-types
13:58:15 <chessguy> ok, you're over my head now :)
13:58:27 <chessguy> but i know what i need to for the moment
13:58:38 <kosmikus> ok :)
13:58:41 <musasabi> @seen shapr
13:58:41 <lambdabot> I saw shapr leaving #haskell and #haskell.se 1d 15h 20m 27s ago, and .
13:59:42 <dmwit> Oy, Python is definitely not lazy.
14:00:31 <ivant> hello everybody!
14:01:51 <Lemmih> Hiya ivant.
14:02:02 <SamB> dmwit: way to state the obvious!
14:02:02 <ivant> can some one suggest me a good article on fixed point, Y combinator and friends? I bumped into a need of recursive function types and feel that "fix" is a solution there
14:02:44 <Cale> y f = f (y f)
14:03:12 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 10
14:03:13 <lambdabot>  3628800
14:03:43 <Cale> > fix ((0:) . scanl (+) 1)
14:03:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:04:23 <ivant> Cale: I understood the basics, but I don't have a feel of how to use it when "a" is a function in fix :: (a -> a) ->a
14:05:38 <glguy> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 5
14:05:39 <lambdabot>  120
14:06:09 <glguy> ?type (\f x -> if x == 0 then 1 else x * f (x-1))
14:06:10 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
14:06:13 <Cale> well, the basic idea there is that the first parameter in the function you pass it is the recursive case of the function you're constructing
14:06:44 <Cale> If f was a factorial function, then (\f x -> if x == 0 then 1 else x * f (x-1)) would be a factorial function
14:06:47 <Cale> er
14:06:53 <Cale> If f was a factorial function, then (\x -> if x == 0 then 1 else x * f (x-1)) would be a factorial function
14:08:15 <Cale> So if we take the fixed point of the function which, takes a function f and produces that function, namely (\f x -> if x == 0 then 1 else x * f (x-1)), then we can hope that it would be factorial
14:08:30 <Cale> In general it might not converge, but in this case, it certainly does
14:09:12 <ivant> Ok, so here is the problem I have:
14:09:28 <Cale> > iterate cos 0
14:09:29 <lambdabot>  [0.0,1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035...
14:09:39 <Cale> > drop 20 $ iterate cos 0
14:09:40 <lambdabot>  [0.7389377567153445,0.7391843997714936,0.7390182624274122,0.7391301765296711...
14:10:25 <Cale> eventually, the sequence converges to a fixed point of cosine
14:10:47 <Cale> (well, it never quite gets there, but the approximations keep getting better)
14:10:52 <x3m> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 5.4
14:10:54 <lambdabot>  Exception: stack overflow
14:11:32 <dmwit> > fix cos 0
14:11:33 <lambdabot>  add an instance declaration for (Floating (t -> a))
14:11:43 <dmwit> > fix cos
14:11:45 <lambdabot>  Exception: <<loop>>
14:12:07 <ivant> I try using QuickCheck, and I have a recursive data-structure: data A = A Int | B A | C A, and I want to create two Generators: one which creates a tree with all the constructors and the other which creates the tree without constructor C
14:13:20 <Cale> in a similar way, we can compute approximations to the factorial function by iterating (\f x -> if x == 0 then 1 else x * f (x-1)) on the undefined function
14:13:48 <Cale> > map (iterate (\f x -> if x == 0 then 1 else x * f (x-1)) undefined !! 7) [0..6]
14:13:50 <lambdabot>  [1,1,2,6,24,120,720]
14:13:56 <Cale> > (iterate (\f x -> if x == 0 then 1 else x * f (x-1)) undefined !! 7) 7
14:13:57 <lambdabot>  Undefined
14:13:57 <ivant> so I create two functions: genAll :: Gen A, genAll = oneof [liftM C genAll, genWithoutC genAll]
14:14:46 <Cale> okay, I'm not terribly familiar with QC, but I get what you're going for
14:15:23 <glguy> > (/) `ap` sum `ap` genericLength $ [1,3,7,10] -- just for my own understanding
14:15:24 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
14:15:24 <lambdabot>    Expected...
14:15:30 <ivant> and genWithoutC :: Gen A -> Gen A, genWithoutC subGen = oneof [liftM A arbitrary, liftM B subGen]
14:15:32 <glguy> > return (/) `ap` sum `ap` genericLength $ [1,3,7,10] -- just for my own understanding
14:15:34 <lambdabot>  5.25
14:16:10 * glguy wants to figure out the overloaded function for iI Ii syntax to make that
14:16:13 <ivant> so how do I really get a generator which "generates tree without C's in its recursive structure"?
14:16:19 <glguy> iI (/) sum genericLength Ii
14:16:45 <ivant> I can't say "genWithoutC genWithoutC", because I'd need a recursive function type of genWithoutC then
14:17:03 <SamB> ivant: fix genWithoutC?
14:17:11 <ivant> and I have a gut feeling that fix may help me
14:17:15 <Cale> ivant: hm?
14:17:24 <Cale> You can define generators recursively
14:17:51 <sjanssen> ivant: how about: genWithoutC = oneOf [liftM A arbitrary, liftM B arbitrary]
14:17:54 <ivant> Cale, sorry?
14:18:10 <sjanssen> I don't see what subGen is supposed to be doing there
14:18:12 <SamB> sjanssen: erg
14:18:13 <chessguy> @type folder
14:18:14 <lambdabot> Not in scope: `folder'
14:18:16 <chessguy> @type foldr
14:18:18 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
14:18:25 <SamB> sjanssen: did you miss the "recursive" bit?
14:18:34 <Cale> chessguy: did you see my fold diagrams?
14:18:37 <sjanssen> @hoogle arbitrary
14:18:38 <lambdabot> Test.QuickCheck.arbitrary :: Arbitrary a => Gen a
14:18:38 <ivant> sjassen: nope, wrong, arbitrary would give me "C" down in the generated tree
14:18:38 <lambdabot> Test.QuickCheck.Arbitrary :: class Arbitrary a
14:18:38 <lambdabot> Test.QuickCheck.coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
14:18:53 <sjanssen> SamB: oh right, typo there
14:18:55 <ivant> and it is not what I want
14:18:59 <Cale> ivant: Can you call generators like functions?
14:19:22 <ivant> Cale: "Gen a" is a monad
14:19:28 <sjanssen> SamB: general principle was correct
14:19:43 <Cale> genWithoutC = do x <- genWithoutC; oneOf [liftM A x, liftM B x]
14:19:45 <Cale> like that?
14:20:00 <SamB> Cale: did you miss the genAll above?
14:20:04 <Cale> You might want a base case :)
14:20:16 <ivant> Cale: actually, I don't know yet, I'm just starting to use QuickCheck
14:20:42 <sjanssen> I think this is right: genWithoutC = oneOf [liftM A arbitrary, liftM B genWithoutC]
14:20:49 <Cale> or is that what the liftMs are for?
14:20:52 <Cale> ah I see
14:20:54 <Cale> yeah
14:21:06 <Cale> er, why arbitrary in the first component?
14:21:14 <ivant> but I want to pass a generator into genWithoutC which should be used on the deeper levels of my tree structure
14:21:20 <Cale> genWithoutC = oneOf [liftM A genWithoutC, liftM B genWithoutC]
14:21:21 <sjanssen> Cale: A contains an Int
14:21:24 <Cale> oh
14:21:29 <Cale> Oh, okay
14:21:40 <Cale> then yeah
14:21:46 <chessguy> if i have a list of lists and i want to see if each of the lists in it is the same size, how would i do that?
14:21:49 <ivant> sjanssen: no, I want to reuse this function for different generators of subtree
14:22:15 <kpreid> chessguy: (foldl1' (==) . map length) lists
14:22:22 <Cale> let ls = map length xs in and $ zipWith (==) ls (tail ls)
14:22:34 <kpreid> Er, that's not right. Sorry.
14:22:42 <SamB> ivant: how about genWithoutC' gen = oneOf [liftM A arbitrary, liftM B gen]
14:22:48 <ivant> probably SamB is right suggesting "fix genWithoutC", but actually I want to understand how can I know for sure when I use it
14:22:50 <chessguy> what's $
14:22:55 <Cale> application
14:22:59 <Cale> f $ x = f x
14:23:05 <chessguy> ...
14:23:06 <Cale> but $ has low precedence
14:23:12 <SamB> and genWithoutC = fix genWithOutC'
14:23:36 <glguy> ?type ($)
14:23:38 <lambdabot> forall b a. (a -> b) -> a -> b
14:23:39 <ivant> SamB: this is what I have as "genWithoutC"
14:23:43 <ivant> :-)
14:23:58 <Cale> let ls = map length xs in and (zipWith (==) ls (tail ls))
14:24:01 <Cale> if you want :)
14:24:13 <ivant> SamB: yep, that's what I "feel", but I can't explain this feeling
14:24:23 <ivant> that's why I'm asking
14:24:52 <ivant> asking for some articles :-)
14:24:54 <SamB> fix f = x where x = f x
14:25:00 <chessguy> i don't get it. why are you using ==
14:25:11 <sjanssen> ivant: you can write that without fix like: genWithoutC = genWithoutC' genWithoutC
14:25:20 <sjanssen> if that makes more sense to you
14:26:30 <ivant> sjanssen: hmm, it didn't occur to me, the feeling for "fix" was stronger :-)
14:27:03 <glguy> I "feel" like going home
14:28:47 <ivant> Cale: zipping with tail is cool, I'll remember this trick :-)
14:29:19 <glguy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs -- classic example
14:29:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
14:29:41 <chessguy> so how would I use that in something like hasEqualLists :: [[Int]]; hasEqualLists x =.....
14:30:36 <ivant> glguy: yes, I seen this, but and $ zipWith (==) is even more cool
14:30:48 <nomeata> chessguy: a simple solution might also be: hasEqualLists  = all (\l -> length l == (length $ head xs))
14:30:51 <glguy> ivant: what about zipWith ($)
14:31:07 <nomeata> @pl  all (\l -> length l == (length $ head xs))
14:31:07 <lambdabot> all ((length (head xs) ==) . length)
14:31:29 <chessguy> ugh. you're all talking gibberish
14:31:30 <nomeata> hasEqualLists = all ((length (head xs) ==) . length)
14:31:41 <ivant> glguy: I wonder, what list types do you need then
14:32:03 <nomeata> which is basically the direct translatoinof "all sublists have the same length as the first sublist"
14:32:22 <ivant> @type zipWith ($)
14:32:23 <lambdabot> forall b b1. [b1 -> b] -> [b1] -> [b]
14:32:28 <glguy> > zipWith id [(+1),(+2),(+3)] [4,8,16]
14:32:29 <lambdabot>  [5,10,19]
14:32:54 <glguy> > ap [(+1),(+2),(+3)] [4,8,16]
14:32:56 <lambdabot>  [5,9,17,6,10,18,7,11,19]
14:32:56 <ivant> @type \as -> zipWith ($) as (tail as)
14:32:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
14:32:58 <lambdabot>    Expected type: [a]
14:33:15 <ivant> glguy: heh, no way to zipWith ($) with own tail
14:33:38 <glguy> ivant: but that was obvious from it's type
14:34:16 <glguy> > let xs = 1 : zipWith id (repeat id) xs in take 10 xs
14:34:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
14:34:59 <ivant> > fix (1:)
14:34:59 <glguy> > let xs = 1 : zipWith id (iterate ((*2) .) (*2)) xs in take 10 xs
14:35:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:35:01 <lambdabot>  [1,2,8,64,1024,32768,2097152,268435456,68719476736,35184372088832]
14:36:03 <ivant> > fix (\n -> if n==1 then 1 else n*2) 1
14:36:03 <lambdabot>  add an instance declaration for (Num (t -> a))
14:36:11 <ivant> > fix (\n -> if n==1 then 1 else n*2)
14:36:13 <lambdabot>  Exception: <<loop>>
14:37:30 <chessguy> grr, i can't get any of your solutions to work
14:38:15 <chessguy> >let hasEqualLists  = all (\l -> length l == (length $ head xs)) in hasEqualLists [[1],[2,3]]
14:38:20 <nomeata> true, there is a error in mine
14:38:25 <chessguy> > let hasEqualLists  = all (\l -> length l == (length $ head xs)) in hasEqualLists [[1],[2,3]]
14:38:26 <lambdabot>  Not in scope: `xs'
14:38:37 <nomeata>  let hasEqualLists xs = all ((length (head xs) ==) . length) xs in  hasEqualLists [[1],[2,3]]
14:38:47 <nomeata> > let hasEqualLists xs = all ((length (head xs) ==) . length) xs in  hasEqualLists [[1,2],[2,3]]
14:38:48 <lambdabot>  True
14:38:50 <nomeata> > let hasEqualLists xs = all ((length (head xs) ==) . length) xs in  hasEqualLists [[1],[2,3]]
14:38:51 <lambdabot>  False
14:39:01 <nomeata> @pl \xs ->  all (\l -> length l == (length $ head xs)) xs
14:39:01 <lambdabot> all =<< (. length) . (==) . length . head
14:39:21 <damkor> Hi there
14:39:33 <glguy> > let notRagged xs = and (zipWith (==) xs' (tail xs')) where xs' = map length xs in notRagged [[1,2],[3,4]]
14:39:35 <lambdabot>  True
14:40:10 <nomeata>  let hasEqualLists = all =<< (. length) . (==) . length . head in  hasEqualLists [[1],[2,3]]
14:40:12 <nomeata> > let hasEqualLists = all =<< (. length) . (==) . length . head in  hasEqualLists [[1],[2,3]]
14:40:13 <lambdabot>  False
14:40:19 <damkor> I'm been coming for a few days asking questions about happy that no one answers/can answer, do you know any Happy specific channel?
14:40:22 <beschmi> MarcWeber, i started working on something similar for emacs (module and identifier completion, display/insert type for toplevel definition)
14:40:27 <nomeata> to me, pointless style sometimes seems to be a cryptographic compression algorithm
14:40:49 <glguy> > let notRagged = and . (ap (zipWith (==)) tail ) . map length in notRagged [[1,2],[3,4]]
14:40:51 <lambdabot>  True
14:41:05 <glguy> > let notRagged = and . ap (zipWith (==)) tail . map length in notRagged [[1,2],[3,4]]
14:41:07 <lambdabot>  True
14:41:16 <beschmi> MarcWeber, it uses a haskell programm with ghc-api that communicates with emacs using an unix domain socket
14:41:43 <beschmi> MarcWeber,  http://beschmi.cloaked.no-ip.org/shim/
14:41:45 <lambdabot> Title: Index of /shim
14:42:10 <ivant> damkor: I used happy about half a year ago, you can try asking a question, but I cannot promise I know the answer :-)
14:42:28 <damkor> ok, let's give it a try :)
14:42:40 <damkor> I'm trying to use a GLR parser with happy
14:42:55 <damkor> and I'm combining Alex and Happy together
14:43:15 <damkor> my scanning monad is a StateT with a Writer inside
14:43:25 <damkor> I want to use the same monad for parsing
14:43:50 <damkor> when I add the %lexer line to the parser, the generated files cannot be compiled
14:43:54 <ivant> damkor: I already feel that you know much more about Happy than I do :-)
14:44:14 <damkor> ok, np ;)
14:46:12 <ivant> damkor, you can try asking at haskell-cafe@haskell.org
14:47:30 <damkor> I'll try that, thanks ivant
14:50:42 <dibblego> dons, after I CTRL-C in the lambdabot console, I am no longer able to use that console -- it simply doesn't echo my keystrokes
14:51:49 <Taral> is there an updated set of haddock docs for ghc HEAD?
14:54:20 <svref> > [Just 5, Nothing] \\ [Nothing]
14:54:21 <lambdabot>  [Just 5]
14:54:24 <dfranke> anyone here attending grad school in the UK and familiar with the differences between US vs. UK admissions processes?
14:54:57 <dfranke> I'm thinking about Cambridge for grad school and all this about "2i honors" means absolutely nothing to me.
14:55:07 <svref> how come lambdabot understands \\ but my ghci complains "Variable not in scope: '\\'"?
14:55:13 <glguy> import Data.List
14:56:26 <svref> glguy: thank you
14:58:09 <glguy> dfranke: maybe they use base 36 and that means 81
14:58:15 <glguy> dfranke: and you need 81 honors
14:58:30 <glguy> and doesn't the UK use "honours"?
14:58:42 <dfranke> glguy: dang.  I was hoping it meant imaginary honours and I could just make up whatever I wanted.
14:58:49 <ski> (roconnor : shouldn't 'abort False :: False -> False' be the same as 'id False :: False -> False' ?)
14:59:13 <glguy> dfranke: I bet your interpretation woudl be good too
14:59:30 <svref> is it true that refutable patterns don't throw catchable exceptions?
15:00:31 <svref> and if its true, what good are they?
15:02:02 <svref> Like in let (x:xs) = find'mumble list in ____
15:03:08 * svref crickets chirping
15:04:59 <glguy> > let (x:_:_) = [1] in x
15:05:00 <lambdabot>  Irrefutable pattern failed for pattern (x : _ : _)
15:05:06 <glguy> that's not a refutable pattern
15:05:40 <svref> glguy: really?
15:05:45 <glguy> look at the error message
15:06:14 <glguy> I thought that a refutable pattern was like:
15:06:20 <svref> ah, okay, let me repost my first message run through sed "s/refutable/irrefutable/g"  :)
15:06:32 <glguy> > do { (x:_:_) <- [1]; return x}
15:06:33 <lambdabot>  add an instance declaration for (Num [a])
15:06:33 <lambdabot>   In the list element: 1
15:06:33 <lambdabot>   In...
15:07:20 <glguy> > do { (x:_:_) <- [[1]]; return x}
15:07:22 <lambdabot>  []
15:07:29 <glguy> that's what I meant
15:07:51 <svref> hm... never seen do {...} before...
15:07:51 <glguy> > [x | (x:_:_) <- [[1]]] -- aka
15:07:52 <lambdabot>  []
15:08:11 <glguy> because:
15:08:36 <MenTaLguY> hello
15:08:41 <glguy> > fail "refutable pattern" :: [()]
15:08:42 <lambdabot>  []
15:08:46 <MenTaLguY> I've got a rather dumb question (I think)
15:09:01 <glguy> about the casing of your nick?
15:09:09 <fasta> glguy: yeah
15:09:10 <glguy> j/k ;)
15:09:29 <MenTaLguY> No, I think I've got that worked out already: caseof MenTaLguY = lame
15:09:31 * MenTaLguY grins
15:10:20 <fasta> > map toLower "MentaLguy"
15:10:22 <lambdabot>  "mentalguy"
15:10:31 <MenTaLguY> my real question is just a dumb thing about types -- I want to be able to write the type of a function which takes an argument of some type a and whose result is the same type
15:10:38 <MenTaLguY> of function, I mean
15:10:59 <MenTaLguY> i.e. something like (a -> (a -> (a -> ...)))
15:11:02 <glguy> can't
15:11:04 <MenTaLguY> without the infinite regression
15:11:22 <ski> newtype Eater a = Eat (a -> Eater a)
15:11:24 <musasabi> newtype R a = R (a -> a)
15:11:29 <ski> eater :: a -> Eater a
15:11:30 <musasabi> newtype R a = R (a -> R a)
15:11:47 <ski> eater a = Eat eater
15:11:48 <ivant> MenTaLguY: you'd probably want to learn about "fix" which resides in Control.Monad.Fix
15:12:27 * svref 's brain explodes.  Ew.
15:12:31 <MenTaLguY> I don't think this is quite related to fix
15:12:39 <MenTaLguY> types aren't first-class in Haskell
15:12:43 <norpan> fix fix fix
15:13:00 <MenTaLguY> (if they were, I guess you could adopt some sort of fix approach to expressing the type)
15:13:14 <ski> MenTaLguY : why do you want to be able to write the type of that function ?
15:13:25 <MenTaLguY> (but that also means a type system rich enough to effectively have type lambdas which is comptuationally weird)
15:13:32 <ivant> MenTaLguY: today I avoided creation of a recursive function type by using fix
15:13:51 <MenTaLguY> hmm.
15:13:56 <ivant> I needed something like (((.... -> a) -> a) -> a)
15:13:58 <ski> ivant : care to tell ?
15:13:59 <dibblego> why would someone choose Bird literate style over latex literate style? they seem equivalent except one has the ability to do clever things with latex
15:14:22 <glguy> bird == > style?
15:14:24 <ivant> ski: I asked lots of questions about fix half an hour ago here
15:14:40 <ski> mhm
15:14:41 <svref> > head $ foldr min [10,9..0]
15:14:41 <lambdabot>    Expecting a function type, but found `a'
15:14:42 <lambdabot>    Expected type: [a]
15:14:42 <lambdabot>    ...
15:14:46 <ivant> and we came to conclusion, that "fix" was the right thing to do there
15:14:55 <ski> > head $ foldr1 min [10,9..0]
15:14:56 <lambdabot>  add an instance declaration for (Num [a])
15:14:57 <lambdabot>   In an arithmetic sequence: [1...
15:15:03 <glguy> foldr doesn't return a list
15:15:04 <glguy> in that case
15:15:12 <ski> > foldr1 min [10,9..0]
15:15:13 <lambdabot>  0
15:15:16 <dibblego> glguy, right
15:15:18 <ivant> ski: I needed to pass a function to itself
15:15:38 <dibblego> glguy, both Bird and Latex emphasise comments and explicitly markup code
15:15:56 <glguy> dibblego: bird style is much cleaner when you are viewing the actual file, and not running it through LaTeX though
15:16:00 <glguy> dibblego: that's why I use it
15:16:26 <dibblego> glguy, at best, it is only *just* cleaner - do you think that aditional cleanliness is really worth it?
15:16:28 <glguy> dibblego: but if you are doing to actually create a pdf or whatnot, I think latex style would be beter
15:16:52 <glguy> dibblego: assuming it's not going ot be run through latex, it's a lot cleaner
15:16:59 <dibblego> there is probably a Bird -> Latex function somewhere anyway
15:17:06 <dibblego> glguy, ok thanks
15:17:30 <MenTaLguY> anyway, I think my question's been adequately answered
15:17:33 <sjanssen> TeX style is easier to type in an editor that doesn't actually support Bird style
15:17:35 <glguy> dibblego: I like ti because I can show people code, and they don't even recognize that what I've showed compiles :)
15:17:37 <MenTaLguY> thanks guys
15:18:10 <dibblego> sjanssen, I haven't yet discovered a reasonable editor for haskell - I still use jedit, so until that changes, I am not affecte
15:18:10 <dibblego> d
15:18:36 <glguy> since vim already continues haskell comments
15:18:49 <glguy> I imagine that it would not be challenging to have vim extend the > sections
15:18:50 <sjanssen> dibblego: jedit sticks the '>' on lines for you?
15:18:56 <profmakx> by
15:18:56 <profmakx> /win	cl	
15:19:19 <dibblego> sjanssen, no, that's my point -- assuming vi/emacs is out of the question, I am left with little choice
15:19:27 <sjanssen> oh, right
15:19:41 <sjanssen> vim doesn't handle the '>' right either.  Does emacs?
15:19:53 <dibblego> nfi
15:20:28 <svref> Suppose I have a list of (Int,Int), l.  How do I find the pair with the smallest non-negative first number?
15:20:47 <svref> Suppose I have a list of (Int,Int).  How do I find the pair with the smallest non-negative first number?
15:21:10 <sjanssen> @hoogle minimumBy
15:21:11 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
15:21:11 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
15:21:27 <glguy> minimum will find the smallest first number anyways
15:21:28 <glguy> so
15:21:39 <glguy> minimum . filter ((>= 0) . fst)
15:22:25 <MarcWeber> I just noticed that the base package is missing in darcs dependencies
15:22:27 <glguy> or: minimumBy (comparing (abs . fst))
15:22:32 <glguy> err
15:22:36 <glguy> definitely not abs
15:22:36 <kpreid> @hoogle comparing
15:22:37 <lambdabot> No matches found
15:22:37 <glguy> :)
15:22:43 <glguy> comparing is something in 6.6
15:22:52 <glguy> but you can just write: comparing f a b = f a `compare` f b
15:23:28 <kpreid> @pl \g f a b -> f a `g` f b
15:23:28 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:23:50 <MarcWeber> beschmi My problem: I'm not interested in emacs.. But perhaps you haskell program, might be used, too?
15:24:20 <glguy> MarcWeber: your finger is stuck on the ',' key
15:24:38 <glguy> (c:
15:25:34 <lispy> ?seen dons
15:25:34 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 7h 44m 58s ago.
15:26:02 <lispy> ?seen xerox
15:26:03 <lambdabot> I saw xerox leaving #haskell-overflow, #haskell-blah, #haskell.it and #haskell 2h 8m 28s ago, and .
15:26:05 <lispy> ?seen stepcut
15:26:05 <lambdabot> I saw stepcut leaving #haskell 21h 16m 47s ago, and .
15:26:10 <sjanssen> @seen your_ugly_face
15:26:10 <lambdabot> I haven't seen your_ugly_face.
15:26:35 <beschmi> MarcWeber: yes, that's why i posted the link. Just saw some comments about perhaps using haskell to look for module completions in your code
15:27:20 <glguy> ?pl \b a -> off a b
15:27:20 <lambdabot> flip off
15:28:14 <MarcWeber> beschmi I'm currently compiling emacs because of that..
15:30:23 <lispy> ?pl \b a -> (off a b) glguy
15:30:23 <lambdabot> flip flip glguy . flip off
15:30:27 <lispy> ah
15:30:43 <lispy> i wanted 'flip off glguy' :)
15:32:21 <Lemmih> @pl \a -> off a glguy
15:32:21 <lambdabot> flip off glguy
15:35:03 <glguy> ?pl id flip s f t $ id u
15:35:03 <lambdabot> s t f u
15:35:16 <greenrd> Anyone here looked at "CAL for Haskell programmers"?
15:35:40 <fasta> greenrd: no, I only looked at the GUI screenshot.
15:35:48 <greenrd> heh
15:36:01 <ulfdoz> Ach, plötzlich wieder anders überlegt?
15:36:04 <ulfdoz> ECHAN, sorry
15:36:18 <greenrd> I don't understand one of their examples about strictness annotations ("plinging")
15:37:12 <greenrd> They have a length function, which recurses over the list (they don't use a fold), and accumulates an integer
15:37:12 <glguy> Ich habe eine Käsewurst in meinen ledernen Hosen
15:37:28 <greenrd> they say that making the accumulating parameter strict makes the function use constant space
15:37:29 <greenrd> huh?
15:38:40 <lispy> greenrd: right, because you use the accumulator whenever you recurse right?
15:38:40 <glguy> greenrd: length xs = f xs 0 where f (_:ys) acc = f ys $! (acc+1); f [] acc = acc
15:38:59 <lispy> greenrd: and every time it's needed the value must be computed (because it's strict)
15:39:13 <lispy> greenrd: so instead of building up some partial sum you're building up one value
15:39:30 <greenrd> I don't understand this, because surely when the value of length ['a', 'b', 'c'] is needed, it's an integer so it must be fully evaluated
15:39:41 <greenrd> so you don't end up with partial sums building up in memory
15:39:44 <lispy> greenrd: right, but when is it needed?
15:39:48 <glguy> greenrd: rather than: length (_:xs) = 1 + length xs; length [] = 0
15:40:42 <lispy> > foldl (+) [1..10000000000]
15:40:43 <lambdabot>  add an instance declaration for (Num [a])
15:40:46 <MarcWeber> From which version on is Text.Html included in base package? I've 2.0 installed.. But can't compile darcs because of this.
15:40:52 <lispy> > foldl1 (+) [1..10000000000]
15:40:55 <lambdabot> Terminated
15:41:00 <lispy> > foldl1' (+) [1..10000000000]
15:41:04 <lambdabot> Terminated
15:41:08 <lispy> > foldl1' (+) [1..10000000]
15:41:12 <lambdabot> Terminated
15:41:15 <greenrd> heh
15:41:24 <lispy> bad example :)
15:41:57 <lispy> > foldl1' (+) [1..1000000]
15:41:59 <lambdabot>  500000500000
15:42:00 <lispy> > foldl1 (+) [1..1000000]
15:42:02 <lambdabot>  Exception: stack overflow
15:42:14 <glguy> > drop 1000000 [0..]
15:42:16 <lambdabot>  Exception: stack overflow
15:42:24 <greenrd> interesting
15:42:41 <lispy> the problem here is that the fold doesn't need the value it's computing so in the lazy fold you get this (1 + 2 + ...) building up, in the later case you only build up one value
15:42:59 <lispy> er later sohuld have been strict
15:43:34 <MarcWeber> lispy: So when is the first one prefered over ' ?
15:43:56 <lispy> MarcWeber: good question
15:44:01 <lispy> MarcWeber: i don't have an answer
15:44:04 <glguy> foldl' and foldr are generally prefered
15:44:09 <glguy> preferred*
15:44:35 <MarcWeber> So why not just use foldl instead of '? .. /me wonders why
15:45:11 <glguy> there are few cases that foldl is better than foldl'
15:45:45 <greenrd> well, sometimes laziness is better, sometimes strictness, I guess, you can't say one is better for all situations
15:45:46 <Cale> I think it makes sense to have strictified versions of programs have ' and have lazy defaults
15:46:02 <lispy> usually, once you loose laziness you can't get it back, so it's good to have a lazy version just in case
15:46:37 <sjanssen> glguy: can you name any actual cases that foldl is more useful than foldl' ?
15:47:05 <dcoutts> yes
15:47:13 <lispy> sjanssen: let's say it's expensive to compute the function that you're folding with
15:47:13 <dcoutts> last
15:47:26 <lispy> sjanssen: and you only need the first few elements of the fold
15:47:35 <greenrd> lispy: lose, not loose ;)
15:47:36 <lispy> er, that's not right
15:47:44 <sjanssen> dcoutts: touche
15:47:46 <lispy> greenrd: oooo my keeeys...
15:47:56 <MarcWeber> anyway: libraries/base/Data/List.hs seems to define both (foldl1 and fold1') equally.. So where does ghc make the difference? Can ghc notice the ' magically?
15:48:56 <sjanssen> MarcWeber: foldl1 calls out to foldl, foldl1' calls foldl'
15:49:32 <MarcWeber> sjanssen: Right. The 1 is missing. I should have read this more carefully..
15:49:56 <dibblego> when writing modules that do not contain a main, it is only the .o that is of interest, so that if you do write a main, you compile it against the .o ?
15:50:33 <lispy> they defined foldl as the primitive, but i think i would have defined foldl f d xs = foldl1 f (d:xs)   :)
15:50:39 <MarcWeber> dibblego: Yeah. You also need some kind of additional info kept in .hi files
15:53:25 <SamB> dibblego: no, the .hi file is really really important too...
15:54:04 <dibblego> ok so you compile against both the .hi and .o then
15:54:12 <dibblego> but is that the general idea?
15:54:31 <SamB> yeah, well, you compile against the .hi and link against the .o, but you've got it basically right ;-)
15:54:46 <dibblego> right, thanks :)
15:55:02 <SamB> .hi contains the types and inlining info and cool stuff like that, .o contains machine code...
15:55:27 <greenrd> lispy: ah, I get it - I was doing strictness analysis without realising it, something which you cannot assume the compiler/interpreter will do ;)
16:04:46 <dibblego> is there another file extension besides .lhs for distinguishing the two different literate styles?
16:04:57 <SamB> dibblego: no
16:05:00 <dibblego> bummer
16:05:12 <SamB> preferably don't do lhs at all
16:05:19 <SamB> haddock doesn't like it much
16:05:28 <SamB> (its okay for emails though)
16:05:49 <dibblego> who is haddock?
16:05:58 <SamB> haddock is a documentation tool
16:06:05 <SamB> rather like javadoc or doxygen
16:06:21 <Botty> who needs docs when its literate haskell :)
16:06:31 <greenrd> you can just use lhs2TeX or cpphs to de-literate-ise code if you have a tool that doesn't like literate code
16:06:34 <sjanssen> I'm not convinced that `last' is a good use for foldl.  foldl (flip const) undefined (repeat 1) eats memory when compiled without optimisations
16:06:35 <dibblego> ok, maybe I'll reconsider
16:06:47 <sjanssen> I wouldn't rely on such a defn. of last in the real world
16:07:01 <dibblego> it seems they should all convert between each other, which leaves "readability" as the only criteria to choose
16:07:26 <SamB> sjanssen: lots of stuff eats memory when unoptimized in some implementations...
16:07:52 <sjanssen> SamB: right.  They call it "buggy" stuff ;)
16:08:03 <SamB> eh.
16:08:18 <SamB> more along the lines of "Why are you compiling without -O?"
16:11:46 <dibblego> my 5 year old discovered ghci on his edubuntu machine the other day
16:12:00 <SamB> what did he do with it?
16:12:00 <dibblego> and he also discovered instant messenging
16:12:09 <dibblego> now he asks me questions while I am working
16:12:11 <dibblego> > 2 + 2
16:12:13 <lambdabot>  4
16:12:16 <dibblego> not much more :)
16:12:18 <greenrd> cool
16:12:18 <SamB> heh
16:12:24 <dibblego> but he likes that kind of stuff
16:12:25 <SamB> you have to start somewhere!
16:12:42 <SamB> I use GHCi for that kind of thing sometimes too
16:12:44 <SamB> like...
16:12:51 <dibblego> I argue that he is more capable of programming than my former colleagues
16:12:56 <greenrd> haha
16:13:24 <SamB> heh
16:13:26 <lispy> dibblego: oh right, we must have worked at the same place?
16:13:38 <Botty> yeah, wish i had a computer with a lang when i was 5.  I started at the old age of 8...
16:13:39 <dibblego> lispy, International Bullshit Machine Corporation?
16:13:49 <SamB> like...
16:13:50 <lispy> dibblego: hahah, actually i did work there for a bit
16:14:12 <dibblego> I used to work on the Java 1.5 implementation
16:14:27 <dibblego> in a big monkey cage
16:14:33 <lispy> dibblego: i tried working on this project called adieu...
16:14:55 <dibblego> never heard of it
16:15:04 <SamB> *Range> let y = 0.83+-0.01
16:15:04 <SamB> *Range> let t = sqrt (y / 4.9)
16:15:04 <SamB> *Range> t
16:15:04 <SamB> 0.4115599687066541+-2.479366898758384e-3
16:15:09 <lispy> dibblego: http://www.alphaworks.ibm.com/tech/adieu
16:15:19 <SamB> see, GHCi is a wonderous calculator ;-)
16:15:33 <lispy> cool
16:15:37 <lispy> :t (+-) ?
16:15:46 <dibblego> looks fun
16:15:55 <SamB> *Range> :t (+-)
16:15:55 <SamB> (+-) :: (Real a) => a -> a -> Range a
16:16:09 <lispy> and then Range a is Num a?
16:16:15 <dibblego> SamB, yeah I use ghci for a calculator - that's how my son got into it - he kept stealing my physical calculator (and my 3 year old destroys everything that is left out)
16:16:26 <dibblego> so I said "you know, you have a calculator on your computer?"
16:16:27 <SamB> *Range> :i Range
16:16:27 <SamB> data Range a = Range a a        -- Defined at Range.hs:5:5
16:16:27 <SamB> instance Eq a => Eq (Range a)   -- Defined at Range.hs:5:5
16:16:27 <SamB> instance (RealFrac a, Floating a) => Floating (Range a)
16:16:27 <SamB>         -- Defined at Range.hs:52:0
16:16:28 <SamB> instance (RealFrac a, Floating a) => Fractional (Range a)
16:16:30 <SamB>         -- Defined at Range.hs:46:0
16:16:32 <SamB> instance RealFrac a => Num (Range a)    -- Defined at Range.hs:34:0
16:16:34 <SamB> instance RealFrac a => Show (Range a)   -- Defined at Range.hs:7:0
16:16:48 <lispy> SamB: very nice
16:17:01 <SamB> of course, I'm missing all the trig functions
16:17:11 <dibblego> I'll show ya something funny
16:17:24 <SamB> I know I *could* do them, though I haven't a clue what to do for the partial inverses...
16:17:26 <sjanssen> once I started writing bindings to an interval arithmetic library.  Never finished it though
16:17:26 <lispy> dibblego: i was working an adieu for a while before i realized i couldn't read the source code :)
16:17:49 <dibblego> hnmorris@gmail.com: hav you tort if i can cum to skwos tonit
16:18:04 <dibblego> that reads: "have you thought if I can come to squash tonight?"
16:18:14 <lispy> heh
16:18:20 * lispy figured it was spam
16:18:23 <SamB> sjanssen: mere bindings!
16:18:31 <SamB> why mere bindings?
16:18:47 <dibblego> lispy, I wrote a alphaWorks/developerWorks publication but I can't find it
16:18:59 <SamB> it is so much more fun to write ones own fantastically inefficient interval arithmatic library, especially if you don't mention the term "interval arithmatic"
16:19:23 <dibblego> http://www.alphaworks.ibm.com/tech/junitx http://www.ibm.com/developerworks/library/j-unitx/
16:19:24 <SamB> I think I posted this on lisppaste once
16:19:38 <SamB> @google site:paste.lisp.org "Range.hs"
16:19:39 <lambdabot> No Result Found.
16:19:42 <lispy> dibblego: yeah, i ended up just writing an HCI journal paper about Adieu because i couldn't managed to modify it (I wasn't even able to intentionally break it...)
16:19:44 <dibblego> look at my ugly head
16:19:45 <SamB> @google site:paste.lisp.org "module Range"
16:19:48 <lambdabot> http://paste.lisp.org/display/26179/xml
16:20:05 <SamB> http://paste.lisp.org/display/26179
16:20:33 <SamB> lambdabot: come on!
16:20:35 <SamB> show the title!
16:20:40 <SamB> you can do it!
16:20:47 <lispy> dibblego: you're in australia?
16:20:54 <dibblego> lispy, yes
16:21:04 <dibblego> Brisbane now (just north of Gold Coast)
16:21:15 <SamB> lispy: could you break the build at least?
16:21:15 <sjanssen> SamB: there's no way to control the rounding mode from pure Haskell
16:21:21 <SamB> sjanssen: oh.
16:21:36 <lispy> SamB: no, i spent a couple days trying to find a build and gave up loooking for it :)
16:21:42 <SamB> well. this was just for physics, physics students don't need such accuracy ;-)
16:21:43 <lispy> SamB: it was all in javascript and nonsense
16:21:51 <SamB> lispy: oh
16:22:04 <SamB> how was it started?
16:22:12 <lispy> i think there was a script
16:22:16 <lispy> someone else installed it
16:22:21 <lispy> and i think it ran automatically
16:22:34 <SamB> you should have added an "exit" to that
16:22:45 <lispy> so i went into some of the files and added line noise
16:22:48 <lispy> the damned thing still ran
16:22:52 <lispy> then i was afraid
16:24:03 <ihope> > read ('"' : repeat '1') :: String
16:24:08 <lambdabot> Terminated
16:24:54 <resiak> > take 5 $ read ('"' : repeat '1') :: string
16:24:55 <lambdabot>  string
16:24:55 <lambdabot>    Inferred type: [a]
16:24:55 <lambdabot>   In the expression: (take 5) $ (read ('"...
16:24:59 <lispy> > fix show
16:25:01 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:25:03 <resiak> Feh.
16:25:32 <resiak> I guess that's not going to work :)
16:25:35 <nomeata> > take 5 $ read ('"' : repeat '1') :: String
16:25:36 <sjanssen> @yhjulwwiefzojcbxybbruweejw
16:25:39 <lambdabot> Terminated
16:25:39 <lambdabot> Just 'J'
16:25:55 * resiak looks at sjanssen.
16:25:57 <SamB> sjanssen: what is the point of that command?
16:26:04 <SamB> and where does it come from?
16:26:04 <lispy> > map length $ group $ take 10000 $ fix show
16:26:05 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,1809]
16:26:22 <lispy> > filter (/= 1) $ map length $ group $ take 10000 $ fix show
16:26:23 <lambdabot>  [3,7,15,31,63,127,255,511,1023,2047,4095,1809]
16:26:51 <lispy> the backslashes grow at an exponential rate!
16:27:12 <sjanssen> resiak, SamB: a while ago, @eval had a variable that was "v = show E", where E was the expression that you gave it
16:27:32 <sjanssen> the channel stumbled onto this function and was quite confused
16:27:33 <SamB> sjanssen: yes
16:27:43 <sjanssen> because when you reference that variable you get crazy results
16:27:48 <SamB> now it is "omgallkindsofgoobeldygook"
16:28:00 <sjanssen> SamB: no, it's randomly generated now
16:28:06 <SamB> sjanssen: yes
16:28:13 <SamB> thats what I meant ;-)
16:28:21 <sjanssen> haha, I didn't even see the words in there
16:28:48 <sjanssen> @hoogle Dynamic -> a
16:28:49 <lambdabot> No matches, try a more general search
16:29:01 <SamB> @hoogle Data.Dynamic.Dynamic -> a
16:29:02 <lambdabot> No matches, try a more general search
16:29:06 <SamB> @hoogle Dynamic
16:29:06 <lambdabot> Data.Dynamic :: module
16:29:06 <lambdabot> Data.Dynamic.Dynamic :: data Dynamic
16:29:06 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
16:29:19 <SamB> sjanssen: that fromDynamic looks useful ;-)
16:32:14 <kpreid> @type fromDyn
16:32:15 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
16:33:11 <sjanssen> aww, dons took away Data.Dynamic :(
16:33:41 <kpreid> > fromDyn
16:33:42 <lambdabot>  Add a type signature
16:34:08 <kpreid> > fromDyn (2 :: Int) (toDyn 1 :: Int)
16:34:09 <lambdabot>  Couldn't match `Dynamic' against `Int'
16:34:15 <kpreid> > fromDyn (2 :: Int) (toDyn (1 :: Int))
16:34:16 <lambdabot>  Couldn't match `Dynamic' against `Int'
16:34:17 <sjanssen> nope, I'm just dumb
16:34:29 <kpreid> > (flip fromDyn) (2 :: Int) (toDyn (1 :: Int))
16:34:30 <lambdabot>  1
16:34:45 <kpreid> sjanssen: and he addded Data.Generics!
16:35:38 <dons> > toDyn 'x'
16:35:39 <lambdabot>  <<Char>>
16:35:55 <sjanssen> > let v = show e; e = fmap head (fromDynamic $ toDyn v :: Maybe String) in v
16:35:57 <lambdabot>  "Just 'J'"
16:36:18 <zarvok> dons: I love the fps/adventure quote in the HWN
16:36:19 <dibblego> is otherwise considered a "literal"?
16:36:30 <SamB> dons: it would be cooler if it could check for a Show instance...
16:36:34 <dons> zarvok: hehe ;)
16:36:36 <zarvok> it was forwarded around the icfp team here, like four people sent it to me
16:36:38 <kpreid> no. it's lowercase.
16:36:41 <dons> > otherwise
16:36:43 <lambdabot>  True
16:36:58 <dibblego> so then there is a distinction between a "literal" and a "constant function"?
16:37:00 <dons> zarvok: heh!
16:37:15 <SamB> dibblego: huh?
16:37:15 <kpreid> dibblego: otherwise is a variable
16:37:33 <SamB> dibblego: oh, you mean pattern matching?
16:37:35 <dibblego> otherwise is a constant Bool afaik
16:37:41 <lispy> dons: hey dons
16:37:47 <SamB> dibblego: duh
16:37:50 <dibblego> no, I mean otherwise is a constant function and not a literal, while True is a literal
16:37:51 <lispy> dons: arg, to the bytestring parser!
16:38:01 <lispy> dons: i'm giving up on it for now (it's that bad!) :)
16:38:04 <SamB> dibblego: I dunno
16:38:11 <dcoutts> lispy, too limited ?
16:38:16 <SamB> maybe True isn't a literal either
16:38:22 <dibblego> that there is an explicit distinction is what I am asking, and kpreid's point is that yes there is one
16:38:28 <SamB> lispy: whats the problem?
16:38:28 <lispy> dcoutts: nope, no speed increase, HUGE increase in memory
16:38:30 <dibblego> I read that True is a literal somewhere
16:38:36 <SamB> you need more functionality from the library?
16:38:40 <dcoutts> lispy, compared to ?
16:38:42 <dons> lispy: and you've profiled?
16:38:44 <lispy> dcoutts: parsec
16:38:48 <lispy> dons: yeah
16:38:49 <dons> seems odd
16:39:01 <dcoutts> lispy, interesting. what are you parsing ?
16:39:09 <SamB> lispy: tell us about the annoyances you experienced!
16:39:23 <lispy> all i really got out of profiling was that my float parser was poor...fixed it but it didn't make much difference
16:39:27 <SamB> also please tell us you were using sufficient optimization flags
16:39:33 <lispy> well, right now i have to work with a classmate
16:39:42 <lispy> SamB: of course :)
16:39:44 <SamB> oh poooooh!
16:39:49 <dcoutts> lispy, parsec is good about using less memory by not retaining backtracking points. the linspire bytestring parser can backtrack anytime so retains more backtracking points.
16:39:53 <lispy> SamB: i may not be a optimization guru, but i didn't start yestarday ;)
16:39:59 <dibblego> this editor thinks a .hs file is XML for some reason
16:40:12 <lispy> dcoutts: am i using the linspire one?
16:40:16 <SamB> lispy: everyone is sometimes idiotically forgetful. or at least a lot of 'em are.
16:40:26 <lispy> SamB: aye...
16:40:33 <dcoutts> lispy, dunno, which one are you using? the one xerox pointed you to ?
16:40:39 <SamB> lispy: that includes me of course ;-)
16:40:39 <lispy> dcoutts: aye
16:40:44 <dcoutts> lispy, then yes.
16:40:48 <lispy> dcoutts: i see
16:40:55 <lispy> dcoutts: i need no backtracking :)
16:41:05 <lispy> so that could be part of the problem
16:41:08 <dcoutts> lispy, that probably explains it
16:41:17 <lispy> let me post a data file real quick
16:41:22 <dcoutts> lispy, they used that for parsing 30mb debian control files with good memory improvements
16:42:11 <lispy> http://paste.lisp.org/display/27364
16:42:22 <lispy> hmm
16:42:25 <lispy> that's a small one
16:42:29 <dcoutts> lispy, if your gramar is LL(1) then parsec would be able to do that linearly without saving any backtracking admin info
16:42:36 <lispy> the nodes and colums vary from parse to parse
16:42:52 <lispy> dcoutts: my grammar doesn't have a single try in it
16:42:57 <dcoutts> right
16:43:15 <dcoutts> the linspire parser essentially inserts try everywhere
16:43:16 <lispy> bleh, lisppaste line wrapped it
16:43:25 <SamB> lispy: you could almost parse that with Alex...
16:43:27 <lispy> anyway, have to go at the moment
16:43:35 <lispy> bbiab
16:43:37 <dcoutts> lispy, port parsec to bytestring :-)
16:44:35 <SamB> what is this for? a trip planner for IF?
16:48:51 * SamB thinks the #haskell stats should include winking smilies
16:53:39 <SamB> okay, so, I sent some patches to the Yhc list for review and noone has said a thing...
16:54:01 <br1> Hi.  I'm a bit lost with ghc's graph libraries.  I understand from the docs that there are several graph implemantations.  IS this right?
16:54:27 <SamB> considering that they've all had most of a daytime (being in the UK), do you think I ought to just push them?
16:54:47 <dons> br1: there is Data.Graph in the base package, and Data.Graph.Inductive, in the fgl package
16:54:54 <dons> ?docs Data.Graph.Inductive
16:54:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
16:54:59 <dons> ?docs Data.Graph
16:54:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
16:56:56 <waern> dcoutts, did you get any response from SyntaxNinja about cabal-devel messages? Should I send the patch directly to you?
16:57:32 <dcoutts> waern, we staled on that, yes, send it to me. Sorry about that.
16:57:51 <waern> dcoutts, oki, no problem
17:03:11 <SamB> dons: do you think I should just push? its been, like, 23 hours...
17:03:52 <SamB> I have no idea what ndm was doing up so late last night...
17:05:03 <waern> dcoutts, mail sent
17:08:09 <dons> SamB: hmm. I'd wait. what's the hurry?
17:08:32 <SamB> mmm
17:15:20 * Lemmih can't wait to get his Google t-shirt.
17:16:06 <dons> :)
17:21:29 <dibblego> ?hoogle (!)
17:21:30 <lambdabot> Did you mean: (!)
17:21:30 <lambdabot> Prelude.undefined :: a
17:21:30 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:21:35 <dons> ?hoogle !
17:21:36 <lambdabot> Array.(!) :: Ix a => Array a b -> a -> b
17:21:36 <lambdabot> Prelude.! :: keyword
17:21:36 <lambdabot> Data.Array.(!) :: Ix i => Array i e -> i -> e
17:21:49 <dibblego> my lambdabot doesn't like it
17:22:04 <dibblego> lambdabot> A Hoogle error occured.
17:22:27 <dons> do you have hoogle in the root directory?
17:22:48 <dibblego> nup
17:22:59 <dibblego> guess it's another one I need to ln -a
17:23:00 <dons> better move it from dist/build/*/hoogle then
17:23:02 <dibblego> *ln -s
17:23:13 <dons> remember that your build failed for some reason, we didn't establish why
17:23:21 <dons> so the install phase didn't run
17:23:21 <dibblego> I thought it worked
17:23:30 <dons> wasn't there a problem installing?
17:23:39 <dibblego> oh wait, I figured it out
17:23:47 <dibblego> it put all those executables in /usr/local/bin
17:23:53 <dibblego> I had to run as root
17:24:01 <dibblego> I couldn't figure how to make it not do that
17:24:10 <dons> it should dump them in the root directory
17:24:19 <dons> i have no idea why it wouldn't do that.
17:24:25 <dons> oh maybe i do: do you have an old cabal?
17:24:25 <dibblego> well, for whatever reason, it tries to put it in /usr/local/bin
17:24:37 <dibblego> how do I find the version?
17:24:47 <dons> $ ghc-pkg list Cabal
17:24:48 <dons> /home/dons/lib/ghc-6.4.2/package.conf:
17:24:48 <dons>     Cabal-1.1.4
17:25:03 <dibblego> Cabal-1.1.3
17:25:15 <dons> could be that. i'm not 100% sure though
17:25:20 <dibblego> ok, nevermind thanks
17:25:20 <dons> i've not heard of this bug
17:25:25 <dibblego> did you get my console problem?
17:25:40 <dibblego> after CTRL-C at lambdabot's console, I can no longer use that console
17:25:45 <dons> i saw that, not seen it. more info would be requried. (i.e. terminal settings, which term you're using and so on)
17:25:50 <dibblego> right
17:26:00 <dibblego> I'll try to pin it down further if I get a moment
17:26:05 <dibblego> might be my fault in the end
17:26:29 <dons> I wrote another tut you might want to check, dibblego, http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
17:26:31 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
17:26:35 <dibblego> yeah I saw that one - very good
17:26:45 <dibblego> I was going to say there is not enough docs for the intermediate steps
17:26:59 <dibblego> I find myself reading the same stuff over and over, because there is no next small step
17:27:06 <dibblego> it was linked from reddit.com
17:27:23 <dons> what do you mean by intermediate level?
17:27:28 <dibblego> we need more of those intermediate kind of docs
17:27:34 <dons> beyond the YAHT and other tutorials, and less than research papers?
17:27:38 <dibblego> well, it doesn't say "this is a list and that is a function" - it is beyond that
17:28:23 <dibblego> there is no intermediate next step to something like HAppS
17:28:35 <dons> right
17:28:36 <hyrax42> @fptools Data.Ix
17:28:37 <lambdabot> http://darcs.haskell.org/packages/base/Data/Ix.hs
17:28:45 <dons> so maybe "Roll your own web server" next week..
17:28:47 <dibblego> brb
17:30:29 <dons> ?seen shapr
17:30:29 <lambdabot> shapr is in #haskell and #haskell.se. I last heard shapr speak 2h 11m 58s ago.
17:32:50 <MarcWeber> When setting up darcs. Do I have to configrue apache in special way? darcs get tells me: darcs: www.mawercer.de/vim/_darcs/inventory: openBinaryFile: does not exist (No such file or directory)
17:33:14 <sjanssen> MarcWeber: http://
17:33:15 <MarcWeber> libcurl: couldn't resolve host
17:33:24 <MarcWeber> sjanssen: There is no difference.
17:33:54 <MarcWeber> But you can access the file using firefox
17:33:59 <sjanssen> that's odd
17:34:24 <sjanssen> you shouldn't have to change configuration.  You don't even need directory read permissions
17:35:44 <MarcWeber> Its' my darcs installation
17:35:46 <hyrax42> @hoogle Ix a => (a,a) -> Int -> a
17:35:47 <lambdabot> No matches, try a more general search
17:35:55 <MarcWeber> Its working on the server
17:36:01 <sjanssen> MarcWeber: yeah, I was able to darcs get it
17:36:08 <hyrax42> @hoogle Ix a =>
17:36:09 <lambdabot> Prelude.undefined :: a
17:36:10 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:36:10 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
17:36:29 <hyrax42> @hoogle Ix a => Int -> (a,a) -> a
17:36:30 <lambdabot> No matches, try a more general search
17:39:15 <MarcWeber> I can't compile darcs at the moment because of "Could not find module `Text.Html'"
17:39:45 <MarcWeber> which should be in base (see hoogle). I've got 2.0 but no Text.Html
17:40:00 <sjanssen> MarcWeber: you're using GHC 6.6?
17:40:09 <dons> is it in the html package now?
17:40:15 <dibblego> dons, excellent idea
17:40:22 <MarcWeber> 6.5.2
17:40:24 <dons> I doubt darcs has been ported to 6.6 yet.
17:40:32 <dons> 6.5.2??
17:40:45 <MarcWeber> ghc-6.5.20060917 from gentoo-haskell
17:41:13 <dibblego> dons, consider the "real world" applications - you have addressed network sockets, there is also, databases, files and probably a couple of others - HTTP on top of a network socket is an excellent idea
17:41:28 <sjanssen> MarcWeber: you probably need extra-libs and you might have to hack the makefile to add additional -package flags
17:41:30 <dibblego> that each document exists in isolation is a good intermediary step
17:41:42 <dons> dibblego: right. that would be a good strategy
17:41:48 <dibblego> I can infer "how to use a network socket" from your IRC bot document for example
17:42:00 <dibblego> but from lambdabot, I wouldn't even try
17:42:06 <MarcWeber> dons, Can you try   ghc-pkg describe base | grep Text.H    ?
17:42:20 <MarcWeber> I wont to know wether the module is situated there.
17:42:37 <dons> $ ghc-pkg describe base | grep Text\.H
17:42:37 <dons>                  Text.Html Text.Html.BlockTable Text.ParserCombinators.ReadP
17:42:51 <dons> with ghc  6.4.2 though
17:42:53 <MarcWeber> dons: Which version?
17:42:57 <MarcWeber> base-xx?
17:43:06 <dons> would be 1.0
17:43:18 <MarcWeber> Ah. Then I'll install 1.0 Thanks
17:43:42 <dons> whereas it is empty with base 2.0 and ghc 6.6
17:43:48 <dons> since its moved into the html package, iirc
17:44:58 <dons> ?where+ hinotify http://haskell.org/~kolmodin/code/hinotify/
17:44:59 <lambdabot> Done.
17:45:41 <sjanssen> is installing multiple versions of base even possible?
17:45:52 <MarcWeber> What does testlang-base contain? Is it equal to base?
17:46:51 <dons> sjanssen: not sure. seems like it would be possible to hide base 1.0 at least, and get at it with -package base-1.0
17:47:11 <hyrax42> @index requot
17:47:11 <lambdabot> bzzt
17:47:17 <hyrax42> @index remquot
17:47:17 <lambdabot> bzzt
17:47:23 <MarcWeber> sjanssen: I need darcs
17:47:25 <hyrax42> @index quotrem
17:47:26 <lambdabot> bzzt
17:47:46 <hyrax42> @hoogle Integral a => a -> (a,a)
17:47:47 <lambdabot> Control.Monad.RWS.execRWS :: RWS r w s a -> r -> s -> (s, w)
17:47:47 <lambdabot> Control.Monad.RWS.evalRWS :: RWS r w s a -> r -> s -> (a, w)
17:48:01 <hyrax42> @hoogle Int -> (Int,Int)
17:48:02 <lambdabot> No matches, try a more general search
17:48:08 <hyrax42> @index quot
17:48:09 <lambdabot> Prelude
17:48:36 <mauke> @hoogle Int -> Int -> (Int, Int)
17:48:37 <lambdabot> No matches, try a more general search
17:48:40 <hyrax42> oh quotRem
17:48:41 <hyrax42> damn it
17:48:48 <hyrax42> @hoogle quotRem
17:48:48 <lambdabot> Prelude.quotRem :: Integral a => a -> a -> (a, a)
17:49:03 <hyrax42> and also the nuber of arguments really wans't helping
17:49:58 <ihope> @hoogle Int# -> Int# -> (# Int#, Int# #)
17:49:59 <lambdabot> Hoogle Error: Parse Error: Unexpected character '> -> Int> '
17:50:02 <ihope> Oy.
17:50:09 <ihope> @hoogle Foo#bar
17:50:09 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>bar'
17:50:18 <ihope> Hmm.
17:50:54 <ihope> @hoogle Int%23 -> Int%23 -> (%23 Int%23, Int%23 %23)
17:50:55 <lambdabot> Hoogle Error: Parse Error: Unexpected character '%23 -> Int'
17:50:55 <syntaxfree> what is Int#?
17:50:56 <dons> doesn't like #. hoogle buglet fixed in newer hoogles
17:51:09 <dons> it was ndm being weird
17:51:12 <dons> ?kind Int#
17:51:14 <lambdabot> Not in scope: type constructor or class `Int#'
17:51:20 <ihope> @index quotRem#
17:51:21 <lambdabot> bzzt
17:51:23 <dons> ?kind GHC.Base.Int#
17:51:24 <lambdabot> #
17:51:41 <dons> syntaxfree: the type of unboxed, raw ints
17:51:58 <ihope> Unboxed types ftw :-)
17:51:58 <syntaxfree> hmm.
17:52:03 <syntaxfree> "unboxed""?
17:52:10 <ihope> No thunks around them.
17:52:13 <ihope> ...I think.
17:52:14 <dons> not 'boxed' on the heap
17:52:25 <ihope> They act oddly.
17:52:30 <dons> so not accessed via an indirection into the heap
17:52:37 <dons> and not lazy either
17:52:50 <dons> just a raw 32 bit value
17:52:58 <dons> well, word-sized, in this case
17:53:11 <ihope> So can polymorphic functions handle unboxed types, or not?
17:53:23 <dons> nope. they've a completely different _kind_
17:53:30 <dons> so you can't mix and match them.
17:53:35 <dons> ?type ($) -- for example
17:53:37 <lambdabot> forall b a. (a -> b) -> a -> b
17:53:48 <dons> only works on boxed, normal haskell types
17:53:59 <dons> types of kind *
17:54:05 <ihope> It seems that unsafeCoerce# can handle them, though.
17:54:08 <dons> ?kind forall a. a
17:54:09 <lambdabot> *
17:54:10 <ihope> But id can't,
17:54:15 <dons> yeah, unsafeCoerce# is wird
17:54:16 <hyrax42> ?kind (# , #)
17:54:18 <lambdabot> parse error on input `,'
17:54:27 <dons> ?kind (# (), () #)
17:54:28 <hyrax42> 'tis not a constructor?
17:54:29 <lambdabot> (#)
17:54:41 <dons> unboxed tuples are even weirder
17:54:58 <dons> ?kind (# Int , Bool #)
17:54:59 <lambdabot> (#)
17:55:09 <hyrax42> what about say UArray
17:55:16 <hyrax42> the #'s are all hidden from view?
17:55:16 <dons> ?type (# 1 , False #)
17:55:18 <lambdabot> forall t. (Num t) => (# t, Bool #)
17:55:22 <dons> hyrax42: yep
17:55:24 <ihope> You know, if const undefined and unsafeCoerce# work differently type-wise, they should really have different types.
17:55:50 <dons> yeah, unsafeCoerce# is kind polymorphic. useful but magic super special fun
17:56:01 <hyrax42> hm
17:56:21 <hyrax42> I'm guessing you use this stuff a lot in fps?
17:56:24 <x3m> dons: is it maybe 0.9.10 of hs-plugins they have ported for win and not 1.0 rc0?
17:56:34 <dons> oh, unboxed values aren't terribly scary. they're used in fps, yes.
17:56:42 <dons> x3m, yes, quite possibly
17:56:53 <ihope> FPS?
17:57:02 <dons> though 1.0 should also just work (tm)
17:57:19 <dons> ?what FPS
17:57:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
17:57:45 <ihope> Ah, yes. Seeing that url reminded me for some reason :-P
17:57:59 <dons> it did? good!
17:58:20 <ihope> I guess my mind associates ByteStrings more strongly with you than with "FPS".
17:58:41 <dons> heh
17:58:58 <dibblego> ByteString brings up a contradiction for me - since a Byte to a String requires a character set in my perhaps flawed mental model
17:59:24 <hyrax42> @index connectTo
17:59:24 <lambdabot> Network
17:59:41 <dcoutts> dibblego, you can have strings of anything, not jsut strings of chars
17:59:48 <dibblego> dcoutts, right
18:00:01 <dibblego> dcoutts, assuming the String Theorists are right :)
18:00:02 <dcoutts> though by default string on it's own tends to mean strings of characters
18:00:05 <dcoutts> heh
18:00:25 <dons> hyrax42: thanks for the help with the tut yesterday, btw. it was very useful
18:00:40 <hyrax42> oh you're most welcom
18:00:42 <hyrax42> e
18:00:45 <dons> hyrax42: and now, 74. Roll your own IRC bot (3,418 views)  :)
18:00:51 <hyrax42> hehe
18:01:05 <hyrax42> it was at 16 when I saw it
18:01:13 <dons> the hwn issues only get around 500 reads
18:01:25 <hyrax42> wait how do you know how many view
18:01:25 <hyrax42> s
18:01:39 <dons> the average guy out there really needs new ideas written in terms of things they already know
18:01:52 <dons> oh, on haskell.org. wiki pages are counted
18:01:57 <hyrax42> ohhh ok
18:02:02 <sjanssen> it seems whenever I attempt to install a package with Cabal, I get "ghc-pkg: invalid package identifier:", and the file ".installed-pkg-config" is empty
18:02:05 <sjanssen> what am I doing wrong?
18:02:11 <hyrax42> well it made reddit front page, and is top 10 in programming.reddit
18:02:29 <dons> yeah, it was #1 for most of the last 10 hours
18:02:33 <dons> so that's nice.
18:02:45 <dons> oh, it even made reddit itself. cool
18:02:46 <dibblego> soon we will have all these bots in #haskell
18:02:57 <dons> dibblego: nah, they're all joining #tutbot-testing
18:03:04 * dibblego joins
18:03:06 <dons> been fun watching people connect and play around
18:03:12 <dibblego> :)
18:03:27 <hyrax42> gah
18:03:33 <hyrax42> I need my laptop back
18:03:40 <hyrax42> no haskell-mode on this stupid place
18:03:54 <dibblego> should put lambdabot in there
18:04:47 <hyrax42> @where haskell-mode
18:04:48 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
18:05:55 <hyrax42> damn it I didn't even save my .emacs
18:07:08 <dcoutts> dons, aye, I read the tutorial. it's very nice. Introducing monad transfomers that quickly is nice :-)
18:07:38 * dcoutts -> bed
18:08:31 <dons> hehe
18:08:45 <dons> i say just throw them in and let the reader figure it out
18:12:03 <SamB> hehe
18:13:18 <Adamant> what is boxing in Haskell?
18:13:35 <SamB> what do you mean, "in haskell"?
18:13:47 <Adamant> with reference to Haskell
18:13:52 <dolio> As opposed to the sport.
18:13:57 <SamB> the same thing as in Lisp!
18:16:50 <glguy> ?fptools Text.ParserCombinators.ReadP
18:16:50 <lambdabot> http://darcs.haskell.org/packages/base/Text/ParserCombinators/ReadP.hs
18:19:51 <hyrax42> runhaskell won't run a file but if the module is called Main?
18:20:13 <hyrax42> runhaskell is runghc in this case
18:20:52 <dons> runhaskell 1.hs works for me.
18:21:03 <hyrax42> hm
18:21:12 <hyrax42> I renamde module from Client to Main and it worked
18:21:21 <hyrax42> not filename, buthe modulename?
18:21:39 <dons> ah, the module name may have to be, yes.
18:21:49 <dons> unles you use -main-is Foo.main, I suspect
18:21:59 <hyrax42> hm
18:26:52 <Pseudonym> ?remember VerityStob Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
18:27:42 <hyrax42> ok this has been bothering me a while
18:27:51 <hyrax42> when I try to run haddock on some files
18:28:09 <hyrax42> it complains about not knowing about library functions or where to link to for them
18:28:20 <hyrax42> is there no way to make it link them automatically to haskell.org/..
18:31:22 <SamB> dons: I don't suppose GHC comes with a haddock interface file?
18:31:33 <dons> not that I know of.
18:31:39 <SamB> who would know?
18:31:43 <dons> Igloo.
18:32:04 <SamB> okay, Igloo: can you make GHC come with a haddock interface file?
18:32:09 <SamB> since it most likely does not?
18:32:19 <SamB> (perhaps several?)
18:32:19 <dons> you want the libraries, or ghc itself?
18:32:32 <SamB> dons: for the libraries
18:32:42 <dons> since just buiding the haddocks for the libs should produce your interface files
18:32:46 <SamB> hmm
18:32:50 <dons> they may even be online
18:32:54 <SamB> mmm
18:32:58 <hyrax42> what's a haddock interface file
18:33:21 <dons> a binary file containing a db of haddock info, a bit like a tags file
18:33:24 <SamB> hyrax42: it is the solution to your problem
18:33:32 <hyrax42> ah
18:33:38 <hyrax42> I guessed as much
18:33:49 <hyrax42> but do they tell haddock to link to haskell.org or?
18:34:05 <SamB> if they are built right!
18:34:22 <liyang> Debian's ghc6-doc has them. (gzipped, annoyingly.)
18:34:27 <SamB> eek
18:34:31 <SamB> those idiots
18:34:53 * Igloo thought they were generated automatically. I haven't done anything special that I can think of, and the debs have them
18:35:01 <SamB> Igloo: oh
18:35:06 <SamB> so why are they gzipped?
18:35:08 <liyang> They are generated automatically.
18:35:09 <Igloo> You'll presumably need to build the library docs, though
18:35:20 <liyang> Debian's scripts gzips large docs by default, I think.
18:35:21 <Igloo> Because they're in /usr/doc and larger than 4k or something
18:35:27 <liyang> yah.
18:35:27 <SamB> thats stupid
18:35:33 <SamB> that should only happen for textfiles!
18:35:37 <liyang> Makes sense if they're text.
18:35:41 <liyang> er, yes.
18:35:44 <SamB> (or maybe they should be installed in /usr/lib?)
18:35:51 <Igloo> Makes sense for ps, dvi and various others too
18:35:58 <SamB> hmm
18:36:03 <liyang> Not PDF though.
18:36:06 <SamB> ps isn't text?
18:36:22 <SamB> I thought it was. Nevermind it being unreadable.
18:36:44 <hyrax42> ps is text
18:37:01 <Igloo> ps isn't always text, there's a binary encoding too
18:37:09 <hyrax42> 10 10 moveto 20 20 rlineto...
18:37:19 <hyrax42> oh ok
18:37:25 <SamB> Igloo: so, can we put those in /usr/lib instead of /usr/doc?
18:37:44 <SamB> Igloo: there is?
18:38:00 <Igloo> There is.
18:38:30 <dibblego> where's that doc on point-free?
18:38:48 <Igloo> If that's where they're meant to be. I never knew what they were, so just left them alone figuring I'd get a bug report if someone cared  :-)
18:38:53 <dibblego> ?where pointfree
18:38:53 <lambdabot> I know nothing about pointfree.
18:38:55 <liyang> It's not clear where base.haddock should go... I mean, it's a meta-file about the generated HTML output. It makes sense for them to go together.
18:38:58 <dibblego> ?where pointless
18:38:58 <lambdabot> I know nothing about pointless.
18:39:03 <dibblego> ?where point-free
18:39:04 <lambdabot> I know nothing about point-free.
18:39:09 <dibblego> ?where anything
18:39:09 <lambdabot> I know nothing about anything.
18:39:17 <Adamant> ?where nothing
18:39:18 <lambdabot> I know nothing about nothing.
18:39:21 <liyang> Igloo: could you override the auto-gzipping?
18:40:00 <dons> Igloo: patch for Data.ByteString.Lazy sent, that we talked about yesterday
18:40:00 <dibblego> ?pointfree is http://www.haskell.org/haskellwiki/Pointfree
18:40:01 <lambdabot> Unknown command, try @list
18:40:08 <Igloo> I think so
18:40:14 <Igloo> dons: Ta
18:40:31 <SamB> also it would be nice if those could link to haskell.org docs, at least for released versions (do they?)
18:41:15 <Igloo> So when would you use base.haddock? Only when building haddock docs for other packages that depend on it?
18:41:35 <SamB> that would be essentially any package, you know, ideally
18:41:41 <liyang> Igloo: building gtk2hs-doc for example.
18:41:53 <SamB> haddock is always complaining that it can't find those things
18:42:09 <Igloo> So the answer to my question is "yes"?
18:42:11 <SamB> and not linking them
18:42:21 <SamB> yes, so, basically you'd want that whenever you ran haddock at all ;-)
18:42:37 <liyang> At the minute I zcat it to a temporary directory and use that.
18:42:57 * SamB thinks Cabal should really manage all of this stuff
18:42:59 <Igloo> OK, so they probably shouldn't be in /usr/share/doc if users aren't meant to read them
18:43:17 <Igloo> I guess we should declare somewhere in /usr/lib their home
18:43:24 <SamB> indeed they would be quite unreadable ;-)
18:43:36 <liyang> But I have to do some path mangling (with haddock, thankfully) because haddock expects the base.haddock and the HTML files to be in the same directory or something.
18:43:46 <liyang> s/with/within/
18:43:47 <Igloo> Oh, hmm
18:45:38 <SamB> not nice!
18:46:56 <SamB> especially since you probably didn't want to refer to the html files on your system anyway!
18:46:58 <dons> hmm. I wonder if we can turn some of these into lambdabot plugins, http://www.google.com/ig/directory?synd=open/
18:46:59 <lambdabot> Title: Homepage Content Directory
18:47:12 <SamB> certainly not with the local paths!
18:47:37 <SamB> or, well, almost certainly
18:48:21 <dons> add a text message plugin to lambdabot , perhaps? :)
18:48:48 <dibblego> is it possible to somehow override show for Char/String to not include the quotes in the result?
18:48:52 <SamB> @tell dons that lambdabot already has a text message plugin, 'kay?
18:48:52 <lambdabot> Consider it noted.
18:49:11 <liyang> Igloo: actually looking at it now, it's not so bad. I just needed a make HADDOCK="haddock --read-interface=/path-to-base-html,tmpdir/base.haddock" line. I probably need to do that in any case, if I want the HTML paths to be relative.
18:49:13 <dons> doesn't go to my mobile phone...
18:49:14 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:49:38 <dons> I see 4 or 5 useful things there.
18:49:53 <dibblego> or is it better to write myshow?
18:50:03 <dons> if we could have a generic interface to these google widget thingamies, we'd get some cool things pretty cheaply
18:51:00 <hyrax42> ?instances MonadPlus
18:51:01 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
18:52:15 <br1> ?instances Ix
18:52:16 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
18:52:49 <dons> ?instances-importing Data.Ix Ix
18:52:50 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
18:53:03 <br1> thanks
18:55:52 <dibblego> ?index factorial
18:55:52 <lambdabot> bzzt
18:56:36 <dibblego> ?hoogle factorial
18:56:36 <lambdabot> No matches found
18:57:00 <dibblego> can you undefine a function in ghci?
18:58:10 <dons> :reload does that
18:58:49 <Pseudonym> You can use let in ghci.
18:58:56 <newsham> hey dons.  just saw your IRC tutorial.  pretty nifty!
18:59:20 <Pseudonym> Prelude> let fac n = product [1..n]
18:59:20 <Pseudonym> Prelude> fac 10
18:59:21 <Pseudonym> 3628800
18:59:38 <newsham> > let fac n = product [1..n] in fac 10
18:59:39 <lambdabot>  3628800
18:59:44 <dons> newsham: cheers.
19:00:48 <newsham> was wondering if there would be nifty quickcheck things that could be added to it (irc tutorial) but it doesnt do anything really "dangerous" so not a lot of properties to check.
19:01:50 <dons> yeah. adding new commands could be checked. thoug we'd want to make the eval function pure, in that case.
19:02:08 <dons> ?check \s -> id s == (s :: T) -- for example
19:02:09 <lambdabot>  OK, passed 500 tests.
19:02:46 <newsham> quickcheck 2nd paper had stuff about quickchecking stateful code.
19:03:07 <dibblego> that ?check thing is part of quickcheck right?
19:03:09 <newsham> precondition/post condition checking as well as model checking
19:03:29 <dons> dibblego: its a binding to quickCheck, yes.
19:04:10 <dibblego> ?check \x -> x + 2 == \x -> 2 + x
19:04:11 <lambdabot>  add an instance declaration for (Num (a -> a))
19:04:29 <dibblego> ?check \x -> x + 2::Int == \x -> 2::Int + x
19:04:30 <lambdabot>  Parse error
19:04:37 <newsham> its really helpful seeing various 'real programs' written in haskell..  cause some of the more complicated features arent really covered much in the various tutorials.
19:04:53 <newsham> like monad transformers and using lift in them.
19:05:03 <dons> so, what next then?
19:05:16 <dons> something with GADTs? or concurrency?
19:05:23 <newsham> what next?  keep up the great work!  ;-)
19:05:27 <newsham> dont have any bright ideas.
19:05:28 <dons> a compiler?
19:05:38 <dons> trying to think of something useful to write about for next week.
19:05:39 <newsham> there's already a tutorial for compilers (scheme in 48hrs)
19:05:47 <newsham> its pretty decent imo
19:05:50 <dons> yeah
19:06:18 <newsham> how about something gui-ish?  i'd love to see some wxgtk stuff in action
19:06:30 <dibblego> I just learned about superfactorial and superduperfactorial
19:06:42 <dons> ah right. guis. hmm
19:06:48 <dons> yeah, that's a good idea
19:06:53 <dibblego> yes guis is an excellent idea
19:07:06 <dons> a pretty clock or a tetris game might be fun to write
19:07:08 <dibblego> a very basic one
19:07:14 <newsham> simple things like bitmap editors, mandelbrot/julia set explorers, etc.. would be pretty small
19:07:24 <dibblego> disconnected from things like files, etc.
19:07:55 <Pseudonym> Scheme in 48 hours.  Bleah.
19:08:00 <Pseudonym> Write Haskell in 48 hours./
19:08:05 <Pseudonym> ?quote Pseudonym
19:08:05 <newsham> here's a tiny bitmap editor i did in python http://www.thenewsh.com/~newsham/x/machine/bmap.py
19:08:05 <lambdabot>  If Hofstadter had said this, it would have been much funnier.
19:08:08 <Pseudonym> ?quote Pseudonym
19:08:09 <lambdabot> http://tinyurl.com/g79xv
19:08:09 <lambdabot>  Well, personally, I don't think dumb people should be let near a programming language.
19:08:14 <Pseudonym> Hmmm.
19:08:16 <Pseudonym> Where's that quote
19:08:20 <Pseudonym> ?quote Pseudonym
19:08:20 <lambdabot>  Lazy evalution is really, really trippy.
19:08:20 <dons> write your own ruby in 20 minutes?
19:08:33 <Pseudonym> Where's that quote
19:08:38 <Pseudonym> ?quote Pseudonym
19:08:38 <lambdabot>  If Hofstadter had said this, it would have been much funnier.
19:08:44 <Pseudonym> Dammit.
19:08:48 <dons> someone should submit a regex patch to @quote...
19:08:53 <Pseudonym> Yeah.
19:09:00 <newsham> i would love a small program for visualizing spectral data from NOAA buoys ;-)
19:09:05 <newsham> (maybe i should write one)
19:09:15 <newsham> err.. in haskell that is (wrote one in python a while ago)
19:09:20 <Adamant> ?quote lambdabot
19:09:20 <lambdabot>  lambdabot hasn't said anything memorable
19:10:04 <newsham> http://currents.soest.hawaii.edu/buoy/index.html <- example of spectral data visualized, here its static though..
19:10:06 <lambdabot> http://tinyurl.com/fmy7z
19:10:07 <newsham> cant navigate the data
19:10:09 <Pseudonym> I suspect that the RNG in ?quote isn't very R.
19:10:16 <Pseudonym> Finally!
19:10:21 <Pseudonym> The Scheme programming language is optimised for writing small
19:10:22 <Pseudonym>            brain-dead tutorial compilers for.
19:10:29 <SamB> ?quote
19:10:29 <lambdabot> monochrom says: All numbers just sit there doing nothing.
19:10:31 <dons> heh
19:10:36 <SamB> ?quote
19:10:36 <lambdabot> TimToady says: learning Haskell itself is easy--I've done it several times already
19:11:07 <newsham> "if nobody's quoting you maybe you havent said anything worth quoting"
19:11:25 <Adamant> @quote Adamant
19:11:25 <lambdabot>  Haskell makes my brain taste like burning
19:11:48 <Adamant> self-reference!
19:12:01 * Adamant ducks
19:12:08 <newsham> this sentance is not self referential.
19:12:44 <SamB> newsham: and this sentance is not true!
19:12:50 <Pseudonym> This sentance misspells at least two words.
19:12:59 <newsham> everything I say is a lie!  except that.  and that (and that, and that)
19:13:01 <SamB> heh
19:13:12 <Adamant> but this sentance mispells mispells
19:13:34 <dons> ?spell but this sentance mispells mispells
19:13:35 <lambdabot> but this sentance mispells mispells
19:13:48 <SamB> Adamant: you need to work on your mispelling
19:14:00 <dons> ?spell sentance
19:14:00 <lambdabot> sentence sentience stance sentenced sentences
19:14:05 <Pseudonym> On the contrary, it misspelled "sentence" as "misspells".
19:14:12 <newsham> ?quote
19:14:13 <lambdabot> your_mom says: Oh, that felt good.  Can you do it again?
19:14:26 <Adamant> ?quote fear
19:14:27 <lambdabot> fear hasn't said anything memorable
19:14:33 <Adamant> @fear
19:14:34 <lambdabot> Maybe you meant: faq keal learn read
19:14:35 <dons> yeah, i noticed someone injected a couple of dodgy quotes
19:14:43 <SamB> dons: hmm?
19:14:47 <dons> or bodgy ones. not sure which.
19:14:49 <SamB> oh. that.
19:14:55 <SamB> ?quote
19:14:55 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
19:14:55 <lambdabot> squad, but he declined.
19:15:02 <Pseudonym> ?remember your_mom Will you stop telling dumb jokes about me please?
19:15:33 <SamB> ?quote
19:15:33 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
19:15:37 <SamB> ?quote
19:15:37 <lambdabot> delicious-malicious-test says: @quote dmt
19:15:43 <SamB> @quote dmt
19:15:44 <lambdabot> dmt hasn't said anything memorable
19:15:44 <dons> like that
19:15:52 <SamB> ?quote
19:15:52 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
19:16:00 <SamB> ?quote
19:16:01 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
19:16:04 <newsham> let's stop saying "don't quote me" because if no one quotes you you probably havent said a thing worth saying
19:16:04 <SamB> ?quote
19:16:04 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
19:16:11 <Adamant> @(elite . keal) hello
19:16:12 <lambdabot> . ke4L) |-|E11o
19:16:22 <dons> Adamant: lucky...
19:16:39 <SamB> heh
19:16:45 <SamB> @. elite keal hello
19:16:45 <lambdabot> T|-|3 fr4cta| Iz 5 iRRA+I0NA15
19:16:55 <weitzma1> @keal What does this do?
19:16:55 <lambdabot> what are epsilons?
19:16:58 <SamB> the fractal is 5 irrationals?
19:17:11 <weitzma1> @help keal
19:17:11 <lambdabot> keal. Talk like Keal
19:17:11 <dons> SamB: yes!
19:17:21 <dons> and if you didn't know that, well, there's no hope.
19:17:24 <weitzma1> @keal How does keal talk?
19:17:24 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
19:17:30 <dons> heh
19:17:50 <Pseudonym> "Here's a nickle, kid. Go buy yourself a real programming language."
19:18:06 <Pseudonym> Err... nickel.
19:18:09 <sjanssen> @keal -- let's hope we get "pork steak tastes like dick"
19:18:10 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
19:18:17 <sjanssen> eh, that's good too
19:18:35 <dons> yeah, i like that one.
19:18:44 <Adamant> @. elite keal elite
19:18:45 <lambdabot> 1aMad48o+ t0oK 5 To 8 WHOl3 zecONdz +0 reTurn []
19:21:16 <Adamant> hmm. lambdabot having her own quotes would be bad, right?
19:21:25 <Pseudonym> ?quote lambdabot
19:21:27 <lambdabot>  Nobody brings small problems into a laundromat.
19:21:34 <lambdabot> Bah, lies and slander. I would never take that long.
19:21:35 <SamB> why would that be bad?
19:21:43 <Pseudonym> ?quote lambdabot
19:21:44 <lambdabot>  Done.
19:21:46 <Pseudonym> ?quote lambdabot
19:21:47 <lambdabot>  tERmIN473d
19:22:00 <newsham> ?quote lambdabot ?quote lambdabot
19:22:01 <lambdabot> lambdabot ?quote lambdabot hasn't said anything memorable
19:22:07 <Adamant> ?remember lambdabot @quote lambdabot
19:22:20 <Adamant> that would be bad, right?
19:22:30 <SamB> @quote lambdabot
19:22:30 <lambdabot>  Beer, it's so much more than just a breakfast drink!
19:22:30 <lambdabot> It won't work, human.
19:22:33 <SamB> @quote lambdabot
19:22:34 <lambdabot>  Beer, it's so much more than just a breakfast drink!
19:22:35 <SamB> @quote lambdabot
19:22:35 <lambdabot>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
19:22:36 <sjanssen> Adamant: lambdabot doesn't respond to her own messages
19:22:36 <SamB> @quote lambdabot
19:22:37 <lambdabot>  fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
19:22:38 <SamB> @quote lambdabot
19:22:38 <lambdabot>  why on the earth whould I slap dons with a wet trout
19:22:39 <SamB> @quote lambdabot
19:22:39 <lambdabot>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
19:22:40 <Adamant> ah.
19:22:41 <SamB> @quote lambdabot
19:22:42 <lambdabot>   lambdabot hasn't said anything memorable
19:22:44 <SamB> @quote lambdabot
19:22:45 <lambdabot>  lambdabot hasn't said anything memorable
19:22:46 <SamB> @quote lambdabot
19:22:47 <lambdabot>  Occurs check: cannot construct the infinite type: a
19:22:48 <SamB> @quote lambdabot
19:22:49 <lambdabot>  lambdabot hasn't said anything memorable
19:22:50 <SamB> @quote lambdabot
19:22:51 <lambdabot>  fOra11 (t :: (* -> *) -> * -> *) (/\/\ :: * -> *) A. (/\/\oNAd+R4nz0rz t, MoN4D /\/\) => 7 ((->) a) (M a)
19:22:52 <SamB> @quote lambdabot
19:22:53 <lambdabot>  lambdabot hasn't said anything memorable
19:22:55 <SamB> @quote lambdabot
19:22:55 <lambdabot>  Beer, it's so much more than just a breakfast drink!
19:23:00 <SamB> @quote lambdabot
19:23:01 <lambdabot>  ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
19:23:02 <SamB> @quote lambdabot
19:23:03 <lambdabot>  why on the earth whould I slap dons with a wet trout
19:23:04 <SamB> @quote lambdabot
19:23:05 <lambdabot>  why on the earth whould I slap dons with a wet trout
19:23:06 <SamB> @quote lambdabot
19:23:07 <lambdabot>  Of course i'm female
19:23:08 <lambdabot> Here, let me help you.
19:23:08 <SamB> @quote lambdabot
19:23:09 <lambdabot>  <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=UTF8&s=books  <
19:23:10 <lambdabot> lambdabot> http://tinyurl.com/root7
19:23:12 <lambdabot> SamB: You're an eager one, aren't ya?
19:23:16 <lambdabot>  @quote lambdabot
19:23:17 <cjay> lol
19:23:18 <SamB> dons: stop it!
19:23:24 <lambdabot> Happy now?
19:23:26 <dons> I'm not doing anything.
19:23:30 <lambdabot> SamB: How about letting a girl rest for a second?
19:23:33 <dons> there are multiple ops for lambdabot, remember.
19:23:37 <SamB> yes I know
19:23:39 <SamB> I was just guessing
19:24:51 <lambdabot> Well, you guessed wrong.
19:25:19 <Adamant> you guys are cracking me up.
19:25:39 <lambdabot> Guys? I'm FEMALE.
19:26:35 <Adamant> sorry for being insensitive, lambdabot
19:27:43 <lambdabot> Sexist _and_ speciesist.
19:27:55 <sjanssen> @where paste
19:27:55 <lambdabot> http://paste.lisp.org/new/haskell
19:28:15 <Adamant> @where lambdabot
19:28:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
19:29:27 <chessguy> you guys really need a life :)
19:30:06 <lambdabot> This from someone named "chessguy".
19:30:20 <dons> heh
19:30:34 <chessguy> lambdabot, you have a problem with chess?
19:30:55 <Pseudonym> Does lambdabot have a chess plugin?
19:31:12 <Pseudonym> ?help chess
19:31:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:31:18 <chessguy> @hoogle chess
19:31:19 <lambdabot> No matches found
19:31:21 <lisppaste2> sjanssen pasted "Cabal question: why does this Setup.hs fail?" at http://paste.lisp.org/display/27372
19:31:23 <chessguy> bah, stupid bot
19:31:35 <Pseudonym> There you go.  Job for someone.
19:32:21 <chessguy> i wish i had time to do chess programming these days
19:35:01 <Lemmih> sjanssen: Let me give that a try.
19:37:19 <weitzma1> > 40 / (2^19)
19:37:20 <lambdabot>  7.62939453125e-5
19:37:38 <weitzma1> Hmm. I think I may have made a stupid mistake recently
19:38:04 <Lemmih> sjanssen: defaultMain works fine for me.
19:38:05 <weitzma1> Involving an underestimation of how big 40/(2^19) is
19:38:11 <weitzma1> I need to memorize my powers of 2
19:38:13 <weitzma1> Damn
19:38:28 <Lemmih> sjanssen: GHC-6.4.1, Cabal-1.1.5
19:38:44 <sjanssen> Lemmih: okay.  My system *is* a bit funny -- GHC 6.5 on an Intel Mac
19:38:57 <sjanssen> thanks for looking at it though
19:39:15 <lennart> weitzma1: all you need to remember is that 2^10 is about 10^3 :)
19:39:21 <weitzman> I know that one
19:39:32 <weitzman> But I assumed that if you multiply that by 2 enough times, it gets a lot bigger
19:39:39 <weitzman> > 2^20
19:39:40 <lambdabot>  1048576
19:39:41 <lennart> it does
19:39:47 <Pseudonym> 2^20 is therefore about 10^6
19:39:53 <weitzman> Yeah
19:39:59 <weitzman> I'm going to remember that henceforth
19:40:00 <Pseudonym> And 2^19 is about 5*10^5
19:40:34 <Pseudonym> 40 / 2^19 would therefore be about 8e-5
19:40:35 <weitzman> @remember math 2^20 ~= 10^6
19:40:57 <Pseudonym> Which is pretty close.
19:41:23 <weitzman> The problem with written tests is that you can't let computers think on your behalf
19:41:30 <Pseudonym> And remember that pi seconds is a nanocentury.
19:41:39 <dons> heh
19:42:03 <dons> ?google pi seconds in centuries
19:42:04 <lambdabot> pi seconds = 9.95531902 x 10^-10 centuries
19:42:08 <dons> mmm
19:42:54 <Pseudonym> Hmmm.  That rule of thumb seems to be out by a factor of ten.
19:43:19 <dons> depends on the size of your thumb
19:43:33 <Pseudonym> I use a slide rule of thumb.
19:44:25 <Pseudonym> > 1e-12 * 60 * 60 * 24 * 365.25 * 100 / pi
19:44:26 <lambdabot>  1.0045096064233594e-3
19:45:28 <Lemmih> sjanssen: GHC-6.5.20060831, Cabal-1.1.5.9.2 also works.
19:45:52 <Pseudonym> Err...
19:46:41 <Pseudonym> > 1e-9 * 60 * 60 * 24 * 365.25 * 100 / pi
19:46:42 <lambdabot>  1.0045096064233594
19:46:42 <Pseudonym> That's it.
19:46:49 <Pseudonym> So it's good to within 0.5%
19:49:04 <dons> nice
19:49:28 <Pseudonym> ?google bumper sticker computer science
19:49:30 <lambdabot> http://www.geocities.com/krishna_kunchith/misc/bscs.html
19:49:30 <lambdabot> Title: Bumper-Sticker Computer Science
19:52:38 <Pseudonym> Wow, here's a rule of thumb that is truly, truly obsolete.
19:52:46 <Pseudonym> One some machines indirection is slower with displacement, so the most-used member of a structure or a record should be first.
19:53:20 <Pseudonym> The odd thing is, the advice is still good, but the reason is completely wrong.
19:53:39 <Pseudonym> The most-used members of a structure should be first so they fit in the same cache line.
19:53:48 <dons> heh
19:53:53 <dons>  displacement?
19:53:58 <Pseudonym> Quite.
19:54:12 <dons> ?foldoc displacement
19:54:13 <lambdabot> No match for "displacement".
19:54:21 <Pseudonym> Oh, that's an addressing mode.
19:54:28 <dons> yeah, I figured.
19:54:39 <Pseudonym> 4(%edi) could potentially be more expensive than (%edi)
19:54:52 <Pseudonym> Which it isn't, actually.
19:55:11 <Pseudonym> Because addition of small constants are REALLY easy to schedule.
19:55:35 <Pseudonym> Especially since loading from 4(%edi) doesn't alter the value of %edi.
19:56:22 <svref> > [(0,0)] == []
19:56:23 <lambdabot>  False
19:57:01 <svref> > [id]==[]
19:57:02 <lambdabot>  add an instance declaration for (Eq (a -> a))
19:57:02 <lambdabot>   In the definition of `arn...
19:57:46 <svref> If I have type [a] and want to see if its empty, but can't make 'a' an instance of 'Eq', how do I test for empty list?
19:57:56 <weitzman> > null []
19:57:58 <lambdabot>  True
19:58:23 <svref> > null [id]
19:58:24 <lambdabot>  False
19:58:29 <svref> sweet
19:58:30 <svref> Thanks
20:09:45 <Bobstopper> @pl \f xs = mapM f xs >>= return . concat
20:09:46 <lambdabot> (line 1, column 7):
20:09:46 <lambdabot> unexpected "="
20:09:46 <lambdabot> expecting pattern or "->"
20:10:07 <Bobstopper> @pl \f xs -> mapM f xs >>= return . concat
20:10:07 <lambdabot> flip flip (return . join) . ((>>=) .) . mapM
20:10:22 <dons> ?pl mapM f xs >>= return . concat
20:10:22 <lambdabot> join `fmap` mapM f xs
20:10:57 <Bobstopper> oh ok
20:11:13 <dons> g >>= return . f --> f `fmap` g
20:11:52 <dons> hey, do we have any #haskellers in San Francisco?
20:12:16 <Bobstopper> I see, thanks
20:12:36 <dons> ?type init `fmap` getContents
20:12:38 <lambdabot> IO [Char]
20:12:43 <dons> ?type init `liftM` getContents
20:12:45 <lambdabot> IO [Char]
20:12:49 <dons> ?type init `lift` getContents
20:12:51 <lambdabot>   The infix expression `init `lift` getContents'
20:12:51 <lambdabot>   requires `lift' to take two arguments,
20:13:07 <dons> ?hoogle lift
20:13:07 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
20:13:07 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
20:13:07 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
20:33:11 <lispy> sorry i had to leave earlier
20:33:23 <lispy> i _just_ finished with that meeting
20:33:24 <lispy> arg
20:33:56 <lispy> dons: from what dcoutts was saying, the bytestringparser i was using is just all wrong for my grammar
20:34:09 <lispy> which could explain the poor performance
20:34:44 <Bobstopper> is there any known problems with running ghc under wine?
20:34:56 <lispy> under wine?
20:35:04 <Bobstopper> yessum
20:35:05 <lispy> why would you do that? it runs natively in linux :)
20:35:19 <Bobstopper> yeah, but I want to compile haskell programs for windows from linux :)
20:35:26 <dylan> lispy: perhaps to test if something works in windows with a windows install?
20:35:26 <lispy> ah
20:35:53 <lispy> dylan: i wouldn't use it as  windows test...just because i wouldn't trust it to be accurate
20:35:58 <lispy> dylan: but i see now
20:36:09 <lispy> Bobstopper: i bet dlls are a tricky spot
20:36:20 <lispy> Bobstopper: they seem to be tricky with ghc in real windows
20:36:29 <Bobstopper> Yeah, so I've heard
20:39:32 <Bobstopper> oh well, it mostly seems to work. Just having trouble compiling and installing missingh under wine.
20:39:46 <Bobstopper> also ghci doesn't seem to be able to set buffering
20:39:54 <Bobstopper> (and consequently dies)
20:40:09 <lispy> i tried to install missingh at work and i can't remember if i succeeded
20:40:20 <lispy> (on windows at work that is)
20:41:20 <dons> Bobstopper: if you get it working, you should write a little FAQ on it
20:41:31 <dons> seems like a very useful thing: generating windows binaries on unix
20:41:45 <Bobstopper> oh right. does the error "MissingH.cabal:1: Invalid syntax (no colon after field name)" while running winbuild sound familiar? MissingH.cabal only contains the words "File not found"
20:41:47 <dons> you can just create a wiki page documenting what you had to do
20:41:58 <Bobstopper> Yeah, I might do that
20:42:01 <dons> yeah, sounds like an old cabal version? or an old .cabal file.
20:42:40 <dylan> cross-compiling to windows is almost impossible with GCC.
20:43:03 <dylan> at least when you throw in WxWidgets or SDL
20:43:16 <Bobstopper> oh ok. so it would be a case of finding the .cabal find for missingh and updating it? (sorry, I haven't yet played with cabal so I don't know what's involved)
20:43:48 <dylan> so, if ghc / haskell can do it, it's even better PR. ;)
20:46:03 <dons> dylan: were you looking for my vim indenter source? or do you have it already?
20:46:10 <dons> i'm not working on it, but if you want to ...
20:46:40 <skew> does anyone know what's been happening with GpH/GdH?
20:46:55 <dons> skew: I saw a new paper come out
20:47:08 <skew> I found a great quote today (re PR and GdH)
20:47:13 <skew> "The latter paper compares Erlang, GdH and C++ for engineering a medium-scale (14K lines of C++, 4K lines of Erlang, and 0.5K lines of GdH) telecoms component.
20:47:19 <dons> and GHC itself does mostly GpH now (sort of)
20:47:27 <dons> wow nice.
20:47:36 <dons> skew: url? sounds like a good HWN quote
20:47:41 <skew> http://www.macs.hw.ac.uk/~trinder/GdHSummary0506.html
20:47:45 <lambdabot> http://tinyurl.com/enudf
20:47:58 <skew> some of Phil Trinder's stuff - He seems to still be working with GdH
20:48:00 <dylan> dons: I needs it! I needs the precious!
20:48:04 <dons> ghc with ndp is practically GpH from what I understand
20:48:12 <dons> dylan: well its online! and always has been. let me urlfiy
20:48:18 <skew> ndp has something to do with gph?
20:48:32 <dylan> dons: Ah. I thought it wasn't online. I'm story for my ignorance.
20:48:41 <skew> I thought one was about data parallelism and the other par and skeletons
20:48:57 <dons> skew, not really. but nested data parallel haskell is certainly related to GpH, but works with ghc as is.
20:49:18 <dons> ?where dph
20:49:18 <lambdabot> http://www.cse.unsw.edu.au/~chak/project/dph
20:49:25 <skew> it sounds like par actually doesn something useful on an SMP box with 6.6
20:49:32 <dons> I'm hoping this is where parallel haskell is heading.
20:50:00 <dons> yeah, smp ghc is a big step forward
20:50:01 <gmh33> I'm happy!
20:50:02 <gmh33> lol
20:50:11 <skew> Was the recent paper "Managing Heterogeneity in a Grid Parallel Haskell."?
20:50:21 <dons> ah maybe thatis it.
20:50:33 <dons> check the 'Parallel' category on the research papers wiki
20:50:35 <gmh33> I kinda sorta figured out monads, almost I think maybe
20:50:37 <dons> (haskell.org)
20:50:41 <skew> It's a bit scary that their implementations talk about patching GHC 4.
20:50:42 <gmh33> at least the basic idea
20:50:43 <dons> gmh33: cool. Just Maybe?
20:50:58 <gmh33> dons: well I can someone of use them now
20:51:02 <dons> :)
20:51:08 <gmh33> I read through part one of "all about monads"
20:51:31 <gmh33> I think people who start trying to learn haskell should read the "haskell for c programmers" first then yaht up to monads, then all about monads
20:51:34 <skew> And how their distribution stuff is made so much easier by the graph reduction foundation of the runtime
20:51:42 <gmh33> the first one helps a lot with understanding the notation
20:51:50 <gmh33> yaht is great for actually using ghc/hugs
20:52:03 <gmh33> and all about monads explains monads in a very clear way :D
20:52:11 <hyrax42> hrm
20:52:27 <hyrax42> dons, how can one simultaneously read and write on a socket
20:52:31 <dons> dylan: http://www.cse.unsw.edu.au/~dons/tmp/vim/
20:52:31 <lambdabot> Title: Index of /~dons/tmp/vim
20:52:35 <hyrax42> i.e. I need a nonblockign read of some kind
20:52:46 <dons> ?hoogle Blocking
20:52:46 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
20:52:47 <lambdabot> System.IO.hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
20:52:48 <hyrax42> or possibly a second thread?
20:52:56 <dons> just use another thread
20:52:59 <gmh33> I was reading all about monads at work (yay free time)
20:53:02 <gmh33> for the past 3 days
20:53:02 <dons> and compile with -threaded so you get non blocking io
20:53:12 <dons> hyrax42: so, forkIO myreader
20:53:13 <hyrax42> was hoping that wasn't the ansewr
20:53:16 <gmh33> and I just tried out some monad-y goodness with IORefs in ghci : )
20:53:24 <hyrax42> dons, oh, simple as that?
20:53:27 <dons> where myreader is some loop that writes out stdin to the socket.
20:53:34 <dons> for example.
20:53:38 <dons> hyrax42: yeah. should be pretty simple
20:53:52 <dons> it's just a Handle, you can hPrint, hPut or whatever you wish
20:54:08 <hyrax42> so something like that forkIO myreader; mywriter?
20:54:13 <dons> yep
20:54:13 <hyrax42> in a do
20:54:14 <hyrax42> that is
20:54:17 <dons> so the main thread runs the writer
20:54:22 <gmh33> monads aren't nearly as challenging to use as they seem at first :D
20:54:23 <dons> and the child thread does the reader
20:54:24 <hyrax42> kk
20:54:37 <dons> hyrax42: and -threaded will ensure that IO calls to read do not block all the threads
20:54:37 <hyrax42> and what if they need to talk
20:54:40 <hyrax42> then I get headaches?
20:54:49 <Korollary> gmh33: It's a big conspiracy theory.
20:54:50 <dons> you mean, communicate to each other?
20:54:53 <hyrax42> yeah
20:55:04 <gmh33> Korollary: I think it's a way to intimidate people from using this language >_>;
20:55:04 <hyrax42> ?index forkIO
20:55:05 <lambdabot> Control.Concurrent
20:55:05 <dons> hyrax42: use an MVar or Chan or some other simple concurrency primitive
20:55:20 <hyrax42> ?docs Control.Concurrent
20:55:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
20:55:26 <gmh33> "monads are hard and confusing!" D:
20:55:33 <dons> yep. check there. and then the 'Awkward Squad' paper for more
20:55:42 <chessguy> yes, and water's wet
20:55:44 <dons> i think i might do a concurrency/forkIO tut
20:55:57 <dons> since its so easy and clean in haskell, and so ugly most other paces
20:56:02 <dons> l
20:56:03 <gmh33> anywho, I'm very happy and excited now : )
20:57:17 <hyrax42> ?index finally
20:57:18 <lambdabot> Control.Exception, Distribution.Compat.Exception
20:57:19 <gmh33> after my 1/2 week break from haskell (giving my brain a break) finally putting the effort into learning about monads makes me happy
20:57:41 <gmh33> anyway, goodnight all
20:58:11 <Korollary> nite
21:05:14 <dons> sjanssen: do you want to send me any thoughts on your SoC experience (saw the mail?)
21:13:02 * Lemmih wonders how to use algebraic data types in postgres.
21:14:20 <dons> heh. at least you didn't say 'generalised ..."
21:14:43 <dons> ?uptime
21:14:44 <lambdabot> uptime: 5d 5h 20m 42s, longest uptime: 5d 5h 20m 42s
21:14:49 <dons> ?users
21:14:50 <lambdabot> Maximum users seen in #haskell: 241, currently: 202 (83.8%), active: 27 (13.4%)
21:20:30 <Bobstopper> http://www.haskell.org/haskellwiki/GHCUnderWine
21:20:34 <lambdabot> Title: GHCUnderWine - HaskellWiki, http://tinyurl.com/o944m
21:21:37 <dons> Bobstopper++
21:21:49 <dons> maybe msg glasgow-haskell-users@hsakell.org about it, to get some feedback
21:22:04 <dons> I think the ghC hq will be intersted to know this actually works
21:22:10 <monochrom> Wow, Win32 GHC on top of Wine on top of Linux?  Sounds like a tour de force
21:22:13 <Bobstopper> Will do
21:22:16 <dylan> dons: perhaps for forkIO tuts, consider taking examples from the POE cookbook (http://poe.perl.org/?POE_Cookbook)  or Twisted (no linky), with a note that forkIO is actually concurrent, and simpler than those two async frameworks?
21:22:18 <lambdabot> Title: POE: POE Cookbook
21:22:21 <hyrax42> dons, what is the type of forever
21:22:41 <hyrax42> ?type let forever a = a >> forever a in forever
21:22:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:22:46 <dons> dylan: ah good idea!
21:23:02 <dylan> I know from experience that concurrency in haskell is a lot easier than POE and Twisted. (Of those, twisted is the more confusing...)
21:23:09 <dons> ?pl forever a = a >> forever a
21:23:09 <lambdabot> forever = fix (ap (>>))
21:23:29 <dylan> haskell is more approachable for network servers than erlang, too.
21:23:31 <dons> dylan: yeah. yet at least Twisted gets a lot of noise (though seems awkward and blurgy)
21:23:33 <dylan> (in my opinion)
21:23:35 <hyrax42> ?type fix (ap (>>))
21:23:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:24:06 <hyrax42> where does the b come from
21:24:14 <dylan> I never really understood how erlang servers worked. That could be because of a high level of abstraction, but...
21:24:30 <dons> hyrax42: since it never returns, it has some arbitrary type.
21:24:55 <hyrax42> that we never find out?
21:24:56 <dons> dylan: yeah I like this idea.
21:25:11 <dons> hyrax42: well you can always specify it as () if it bothers you :)
21:25:34 <dons> say, IO () -> IO ()
21:25:39 <dons> to really restrict the type
21:25:51 <hyrax42> but that can be inferred
21:25:56 <dons> right
21:26:00 <skew> hyrax42: whatever type inference against the context wants it to be
21:26:09 <dons> so m a -> m a is probably simplest
21:26:23 <hyrax42> hm ok
21:26:51 <skew> forever shouldn't be returning so it doesn't matter, but the free return type is really nice on things like fail :: String -> IO a
21:27:00 <lisppaste2> dylan pasted "hopefully simple use of ReaderT + IO + STM" at http://paste.lisp.org/display/27376
21:27:17 <dons> mm. some STM would be good.
21:27:20 <dylan> ^ this would be the least trivial thing I've done in haskell yet.
21:27:33 <dylan> I did it before seeing the irc tutbot.
21:28:18 <dylan> (I had to figure out how to get ReaderT to work with IO, I couldn't figure out the right way to phrase the question...)
21:28:26 <dons> :)
21:28:39 <hyrax42> ?paste
21:28:39 <lambdabot> http://paste.lisp.org/new/haskell
21:28:54 <dons> dylan: yeah, throwing in some STM would be cool
21:29:02 <dolio>  Your tutorial is fairly popular on reddit, dons.
21:29:02 <lisppaste2> hyrax42 pasted "what's wrong?" at http://paste.lisp.org/display/27377
21:29:10 <hyrax42> getting weird compile error
21:29:40 <dons> dolio: 4,187 views so far :)
21:29:51 <dylan> dons: if there's any way I can help, being the "I don't know haskell!" guinea pig, let me know. :)
21:30:04 <dolio> 47 points.
21:30:04 <dons> dylan: ok. will do. i'll see if I can hack this up by this time next week
21:30:16 <hyrax42> dylan, are there examples you have in mind?
21:30:17 <glguy> dons: How do I get the String out of IO String?
21:30:18 <dolio> Apparently after 92 up-votes and 45 down-votes.
21:30:20 <dolio> Quite polarizing.
21:30:24 <dons> thanks glguy
21:30:36 <hyrax42> I could do with stretching
21:30:48 <dons> dolio: yeah. it was weird. it was running at 30 up, 2 dn, then the US woke up
21:30:54 <hyrax42> could somoen look at the comple errors I'm getting?
21:31:00 <dons> seems like the euro crowd digs haskell code a bit more :)
21:31:14 <hyrax42> passthrough.o: In function `s2Wo_info':
21:31:14 <hyrax42> (.text+0xd9c): undefined reference to `Network_connectTo_closure'
21:31:16 <hyrax42> and so on
21:31:24 <dons> missing -package network
21:31:28 <hyrax42> ah
21:31:29 <dons> or just use --make
21:31:45 <hyrax42> --make: magic
21:31:55 <dons> ghc should probably try to catch that error and print it with some helpful advice
21:32:13 <glguy> and risk a lower ?users?
21:32:31 <dons> heh
21:32:34 <glguy> we need to get people hooked, and keep them addicted
21:32:41 <dylan> Apparently that server I wrote can exhibit a bit of a DoS, sendMsg can block. If it blocks, it's likely that any thread that send a broadcast will block
21:32:56 <glguy> and to ensure withdrawl symptoms if they stray
21:33:03 <dons> ok. how about ghc forks a tutbot instance to connect to #haskell when there's a type error?
21:33:09 <hyrax42> awesome, I my little passthrough thingy worked
21:33:45 <dylan> @hoogle canBlock
21:33:45 <hyrax42> if only I had experience o fnetwork coding in another language to know if this was easyor not
21:33:46 <lambdabot> No matches found
21:33:51 <dylan> @hoogle willBlock
21:33:52 <lambdabot> No matches found
21:35:27 <hyrax42> does Network.accept block?
21:35:43 <weitzman> @type Network.accept
21:35:44 <lambdabot> Network.Socket.Socket -> IO (GHC.IOBase.Handle, Network.BSD.HostName, Network.Socket.PortNumber)
21:35:44 <Lemmih> hyrax42: Yes.
21:36:15 <hyrax42> ?index bracket
21:36:15 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
21:37:24 <weitzman> !hoogle Socket -> Maybe a
21:37:31 <weitzman> @hoogle Socket -> Maybe a
21:37:32 <lambdabot> No matches, try a more general search
21:38:16 <dons> everyone writing bots or something? :)
21:38:22 <dons> hehe
21:39:13 <dons> its nice to see that 9 people have managed to run the tutbot and actually connect to the default channel
21:39:22 <dons> 9 new haskell users, I wonder?
21:39:44 <hyrax42> means the had to either have haskell installed or install it
21:39:45 <hyrax42> it's a start
21:39:49 <dons> yeah
21:39:57 <hyrax42> what sort of other exaples will you attempt
21:40:11 <hyrax42> I would like to try something or other
21:40:17 <dons> some hard concurrency problem, I think. and people were asking about gui stuff
21:40:21 <hyrax42> to get some more real experience wiht haskell
21:40:31 <dons> a tiny web server might be fun to write
21:40:32 <hyrax42> in "real world"
21:40:59 <hyrax42> isn't gui a bit of a :/
21:41:27 <dons> they're not my thing. but you can do some nice things with gtk2hs, so it would be a nice advert
21:42:08 <dylan> I would like an ncurses tutorial. That's a gui, right? ;)
21:42:22 <dons> ah, now that i could write.
21:42:35 <dons> perhaps add a curses frontend to tutbot
21:43:19 <dons> "multithreaded, purely functional curses apps in 20 minutes"
21:43:25 <dons> ;)
21:44:04 <dons> one nice thing is that  you can use a pretty printer to render the curses screen
21:44:39 <dylan> that only does updates when required?
21:45:16 <ozone> dons: when are you leaving?
21:47:18 <hyrax42> ?index curses
21:47:18 <lambdabot> bzzt
21:47:30 <hyrax42> ?where curses
21:47:31 <lambdabot> I know nothing about curses.
21:47:37 <hyrax42> ?where ncurses
21:47:37 <lambdabot> I know nothing about ncurses.
21:50:58 <hyrax42> well that exercise proved far more useful than the couple hours I spent wading through java source
21:51:02 <dons> ozone: next Friday
21:51:20 <dons> dylan: right. you just sleep on the monad state, refreshing when it changes
21:51:32 <dons> (that's how hmp3 works)
21:54:08 <Patterner> *sniff* "No greencard found."
21:58:10 <Korollary> dons++
21:58:24 <Korollary> for the bot tutorial
21:58:34 <weitzman> I think my karma keeps going down
21:58:36 <weitzman> @karam
21:58:36 <lambdabot> Maybe you meant: karma karma+ karma-
21:58:39 <weitzman> @karma
21:58:39 <lambdabot> You have a karma of 0
21:58:43 <weitzman> Oh, it's reached 0
21:59:02 <Korollary> weitzman: have you been mutating state ?
21:59:04 <weitzman> Must have reset or something
21:59:11 <weitzman> I've been saying
21:59:12 <weitzman> Java++
21:59:15 <weitzman> @karma
21:59:15 <lambdabot> You have a karma of -1
21:59:30 <hyrax42> ?karma
21:59:31 <lambdabot> You have a karma of 1
21:59:35 <hyrax42> huh
22:00:02 <Korollary> I think java++ retaliates
22:00:09 <dons> weitzman: that'll learn you.
22:04:02 <sjanssen> dons: I say every statement that includes "unsafePerformIO" and doesn't include "dangerous" or "don't use it" should result in an automatic karma reduction
22:05:26 <hyrax42> ok bedtime
22:05:49 <weitzman> I've given up on sleeping. I've tried it once or twice over the last few days, but it doesn't work
22:05:57 <dibblego> lol
22:06:02 <dibblego> I use Valerian
22:06:09 <dibblego> I cannot sleep after sport
22:06:19 <dibblego> and I play late at night sometimes (like tonight will be)
22:07:39 <dons> sjanssen: hehe. good idea :)
22:07:57 <weitzman> Recently I've kept staying up late an waking up early, but for some reason I still haven't been falling asleep in any reasonable amount of time
22:08:22 <lispy> heh
22:08:26 <weitzman> I'm going to miss the academic life
22:08:40 <lispy> hmm...
22:08:43 <lispy> is that possible? ;)
22:09:16 <weitzman> One of my coworkers this summer used to come in around 4pm and stay into the wee hours
22:09:30 <dons> yeah, we've got a few like that here too
22:09:36 <dons> i'm not sure its healthy..
22:10:09 <lispy> i come it at 10-10:30 pretty regularly...and i'm getting sick of staying late...so i'm trying to change that
22:10:15 <lispy> i hate getting home at dark :(
22:10:47 <weitzman> I need to move to one of those countries where you get 3 months off
22:11:38 <Pseudonym> I know someone who has a six-day week.
22:11:56 <Pseudonym> In the sense that he divides the hours in a week into six equal blocks.
22:12:04 <skew> how about a 2 hour sleep cycle?
22:12:13 <Pseudonym> His is the only work week that beats fast.
22:12:35 <Pseudonym> Many people work out of phase, he works out of frequency.
22:13:23 <Pseudonym> Actually, he's got his own wikipedia page:
22:13:25 <Pseudonym> http://en.wikipedia.org/wiki/Kevin_Robert_Elz
22:14:13 <skew> Some people classmates were trying that, but I never heard how it turned out.
22:15:19 <Korollary> There was a post on kuro5hin by somebody on that
22:15:21 <lispy> i don't see it described on the wiki
22:15:24 <Pseudonym> You'll notice, by the way, that there are no pictures of kre on his work web site.
22:15:26 <ozone> Pseudonym: oh, him :)
22:15:29 <Botty> There are a number of funky sleep patterns you can have
22:15:31 <Pseudonym> Yes, him. :-)
22:15:43 <Pseudonym> AFAIK there's only one known picture of him.
22:15:54 <Botty> polyphasic stuff is just crazy, I naturally tend towards a biphasic cycle
22:15:54 <ozone> skew: all the fellows i know who've tried it haven't had it work out very well for them...
22:15:56 <weitzman> Is he one of those tinfoil people?
22:16:02 <Pseudonym> And it's attached to a disk platter at the university of melbourne CS department.
22:16:05 <dons> ah him!
22:16:15 <Pseudonym> No, he's not a tinfoil person.
22:16:20 <Pseudonym> He just doesn't really do people.
22:16:25 <Botty> six-day week doesn't sound like polyphasic though
22:16:27 <ozone> one of the last bastions of freedom on today's intarweb!
22:16:27 <Pseudonym> I'm surprised he's a lecturer.
22:16:36 <lispy> i wish i did more people...especially female people...
22:16:38 <Pseudonym> Sounds too much like daylight.
22:16:52 <Korollary> lispy: /s/especially/exclusively ?
22:17:06 <lispy> Pseudonym: how do i find his schedule? it doesn't show up on the wiki page
22:17:17 <lispy> Korollary: beggars can't be choosers ;)
22:17:32 <Pseudonym> lispy: By having worked in the same building as him.
22:17:33 <Botty> 0_o lol
22:17:40 <dons> mmm. rumoured to have a work contract which allowed him time off whenever cricket was being televised
22:17:41 <Pseudonym> Admittedly, he might not be doing it any more.
22:17:58 <lispy> Pseudonym: yeah, i just wanted to read about it...i don't really get it
22:18:24 <Pseudonym> I have a Robert Elz story, which I will tell on haskell-blah.
22:18:46 <ozone> are you still doing haskell work these days, Pseudonym?
22:18:48 <lispy> so his days are 28 hours?
22:18:55 <Pseudonym> lispy: Yup.
22:19:04 <Pseudonym> Nope, not doing haskell work.
22:19:27 <Botty> I thought the average natural day (I think it was called circadian or something) was 25 hours
22:19:36 <ozone> i've been suckered into C++ land
22:19:47 <ozone> everything here is possible, but fugly
22:20:07 <monochrom> fugly is a good word to describe that :)
22:21:14 <weitzman> From my interviewing so far, it looks like there's no way for me to entirely escape C/C++ and still have an interesting job
22:21:24 <weitzman> An unfortunate tradeoff
22:21:36 <Korollary> welcome to the industry
22:21:54 <ozone> could be worse, you could be coding in java :)
22:22:01 <weitzman> Every line of C++ written today is a crime against humanity
22:22:25 <Korollary> No, it isn't.
22:22:36 <skew> weitzman: ghc -fvia-C -keep-hc-files?
22:22:36 <Botty> weitzman - nah, just most
22:23:06 <weitzman> Ok, I'm sure there's a legitimate use for C++ somewhere...possibly
22:23:12 <weitzman> I just don't know what it is yet
22:23:26 <weitzman> Nor do I know where to find a spec-compliant C++ implementation
22:23:40 <Korollary> Why are you people so hung up on spec compliance anyway
22:24:36 <Botty> Well, this is a haskell channel.  Some people are likely attracted by the ideal of approaching perfection.
22:24:47 <ozone> weitzman: VS2005 and g++4 are both decent enough
22:24:59 <weitzman> If my dream of no more C++ is ever going to be achieved, there needs to be a migration route. That'll be a lot easier if people can agree on what C++ is
22:25:22 <glguy> weitzman: so when you write Haskell code, do you make sure that it is Haskell98 compliant?
22:26:10 <weitzman> Variation among haskell compilers is much less than among C++ compilers
22:26:15 <Korollary> I write g++ dialect of C++. Whatever else is out there is irrelevant. There's no way in hell what I am writing is 'portable' and C++ is the least of the hurdles.
22:26:30 <weitzman> #ifdef __SOME_RANDOM_COMPILER__ ...
22:26:35 <skew> but g++ basically documents what they accept
22:26:58 <weitzman> Or __SOME_RANDOM_OS___
22:27:00 <weitzman> I don't care
22:27:07 <weitzman> I don't like that kind of stuff
22:27:18 <weitzman> If __64_bit__
22:27:21 <skew> try targeting 2.95.5, for great fun like for (unsigned char c = 0; c < 255; ++c) /* stuff */ going into an infinite loop with -O...
22:28:52 <Korollary> I had to #ifdef something for a different version of g++ only once. As I said, that's nothing, not even worth mentioning to your psychologist. On the other hand, I would love to set some functional specs on fire.
22:30:28 <lispy> yes
22:30:41 <lispy> i'd like to set on fire some of the people that are supposed to be writing the functional spec :)
22:31:11 <lispy> they leave it to me...the implementor...then argue that it's wrong but cannot clearly state what is missing or incorrect
22:31:16 <lispy> and then ask me to fix it
22:36:49 <newsham> http://www.google.com/codesearch?hl=en&lr=&q=putStrLn
22:36:53 <lambdabot> Title: putStrLn - Google Code Search, http://tinyurl.com/qq73y
22:37:57 <Korollary> interesting
22:38:56 <newsham> lang:"haskell" didnt quite work
22:39:27 <Korollary> it's not in the dropdown
22:39:38 <Korollary> wtf is Limbo??
22:39:41 <newsham> dropdown?
22:39:55 <dibblego> > let factorial 0 = 1; factorial n | n > 0 = n * factorial (n - 1); superfactorial 0 = 1; superfactorial n | n > 0 = factorial n * superfactorial (factorial n - 1) in superfactorial 2
22:39:56 <lambdabot>  2
22:39:58 <Korollary> in advanced code search
22:40:00 <newsham> limbo is a bell labs language.. runs on a virtual machine
22:40:02 <dibblego> > let factorial 0 = 1; factorial n | n > 0 = n * factorial (n - 1); superfactorial 0 = 1; superfactorial n | n > 0 = factorial n * superfactorial (factorial n - 1) in superfactorial 3
22:40:06 <lambdabot> Terminated
22:40:07 <newsham> used in similar applications as java (ie. mobile code)
22:40:08 <dibblego> what is broken?
22:40:19 <weitzman> Limbo is the language used in Inferno, isn't it?
22:40:24 <newsham> yup
22:41:08 <Korollary> dibblego: superfactorial keeps calling itself.
22:41:18 <Korollary> err
22:42:01 <Korollary> it must be trying factorial (-1) and failing the pattern match
22:42:26 <dibblego> it exhausts the call stack
22:42:35 <dibblego> *** Exception: stack overflow
22:43:15 <Korollary> strange
22:43:18 <dibblego> I think the pattern match still matches for guards - it just fails because it has no guard to match
22:43:24 <Korollary> if super 2 terminates, why won't super 3?
22:43:27 <dibblego> I read that somewhere I think
22:43:34 <dibblego> that's my question
22:44:06 <dmwit> Because superfactorial (factorial n - 1)
22:44:07 <dmwit> calls
22:44:07 <Korollary> super 3 is fac 3 * super (fac 3 - 1)
22:44:09 <Korollary> err
22:44:10 <Korollary> yes
22:44:12 <dmwit> superfactorial 4
22:44:13 <dmwit> ...
22:44:14 <Korollary> it keeps going up
22:44:30 <monochrom> Oh haha, miss that one too
22:45:41 <dibblego> doesn't it call super 5?
22:45:52 <dmwit> Doesn't matter -- it's still going up.
22:45:55 <dibblego> super 3 calls super 5
22:46:02 <dibblego> right I see that - just making sure I'm seeing what you are
22:46:08 <Korollary> yes, which in turn calls super 60 - 1, etc.
22:46:27 <dmwit> yah
22:47:43 <Korollary> conclusion: recursion is hard! let's iterate.
22:48:00 <dibblego> > let factorial 0 = 1; factorial n | n > 0 = n * factorial (n - 1); superfactorial 0 = 1; superfactorial n | n > 0 = factorial n * factorial (n - 1) in superfactorial 3
22:48:01 <lambdabot>  12
22:48:08 <dibblego> > let factorial 0 = 1; factorial n | n > 0 = n * factorial (n - 1); superfactorial 0 = 1; superfactorial n | n > 0 = factorial n * factorial (n - 1) in superfactorial 4
22:48:09 <lambdabot>  144
22:48:17 <dibblego> that's wrong
22:48:42 <dmwit> > 24 * 6
22:48:43 <lambdabot>  144
22:48:48 <dibblego> is that right?
22:48:52 <dibblego> wikipedia disagrees
22:48:57 <dmwit> Superfactorial x = x! * (x - 1)! ?
22:49:09 <dibblego> no, it claims that 288 is the next in the sequence
22:49:44 <Korollary> You need to multiply all of them down to 1, not just fac n * fac (n-1).
22:49:53 <dibblego> > let factorial 0 = 1; factorial n | n > 0 = n * factorial (n - 1) in factorial 1 * factorial 2 * factorial 3 * factorial 4
22:49:55 <lambdabot>  288
22:50:31 <Korollary> observe that super 5 = 5! * super 4.
22:50:38 <dmwit> superfactorial x = product [factorial n | n <- [1..x]]
22:51:01 <dibblego> Korollary, yeah I've observed that
22:51:51 <dmwit> > let factorial 0 = 1; factorial n | n > 0 = n * factorial (n - 1); superfactorial 0 = 1; superfactorial x = (factorial x) * (superfactorial (x - 1)) in superfactorial 4
22:51:52 <lambdabot>  288
22:52:06 <dmwit> Korollary: nice.
22:52:36 <dibblego> yeah that's what I meant, thanks
22:53:12 <Korollary> I bet somebody got a PhD thesis out of this superfactorial nonsense.
22:53:23 <dibblego> lol
22:53:43 <dibblego> does it reflect anything in nature at all?
22:54:07 <Korollary> most of mathematics is in your head.
22:55:02 <Pseudonym> Type systems don't appear in nature either
22:55:05 <Korollary> But you never know what will be in the next episode of Numb3rs
22:55:23 <Korollary> Game Theory!
22:56:24 <dibblego> I will do a thesis on superduperduperfactorial
22:57:11 <Korollary> Math is hard! - Barbie, ca 1960(?)
22:58:05 <dibblego> bye
22:58:05 <dmwit> Just generalize to the createafactorial :: Int -> Int -> Int, which does createafactorial n (n - 1) * createafactorial (n - 1) n
22:58:07 <dibblego> thanks for the help
22:58:14 <dmwit> Bye!
22:58:17 <dibblego> ah good idea
22:58:22 <dibblego> I'll do that next time
23:15:29 <satan> hello all
23:15:39 <Korollary> hi there
23:15:43 <satan> can i use list comprehension to make a function that works like zip?
23:16:04 <satan> i tried this: myzip2 m n = [(i,j) |  i <- m !! 1 , j <- n !! 1] but it doesnt work
23:17:18 <satan> i mean, i know it only gets the first pair, i wanted to test it, but it complains about there being no instance for Num [a]
23:17:30 <satan> i tried calling it with myzip2 [1,2,3] [4,5,6]
23:17:57 <satan> > myzip2 m n = [(i,j) |  i <- m !! 1 , j <- n !! 1]
23:17:57 <lambdabot>  Parse error
23:18:23 <satan> eh weird, it compiles fine here
23:19:01 <Korollary> well, if you use a list comprehension, you'll get (1,5) and (1,6) as well as (1,4)
23:19:16 <ThreeQ> > (\m n -> [(i,j) |  i <- m !! 1 , j <- n !! 1]) [1, 2, 3] [4, 5, 6]
23:19:17 <lambdabot>  add an instance declaration for (Num [a])
23:19:17 <lambdabot>   In the list element: 6
23:19:20 <satan> right
23:19:47 <ThreeQ> a <- in a list comprehension doesn't have the meaning you think
23:20:00 <satan> what i'm really trying to do is write zip with foldr of the form myzip = foldr f a, where i'm trying to make f this function
23:20:04 <ThreeQ> i <- list means "take i from any of the values in list"
23:20:10 <satan> oh i see
23:20:17 <ThreeQ> so saying i <- list !! 1 doesn't really work
23:20:29 <ThreeQ> it's not really assignment
23:20:35 <satan> ohhh ok
23:20:54 <satan> i just tried it at the prompt and it seemed to give me what i wanted
23:21:01 <satan> > [4,5,6] !! 2
23:21:02 <lambdabot>  6
23:21:08 <satan> thats why
23:21:43 <ThreeQ> I'm not sure you can write zip as a list comprehension very nicely
23:22:01 <ThreeQ> as least, if you can, I have no idea how :)
23:22:09 <satan> maybe trying to write it as a list comprehension is wrong, but i'm trying to write it with foldr :S
23:22:53 <ThreeQ> oh, I don't think zip is expressible in terms of foldr unless you actually construct the list
23:22:54 <dons> zip requires parallel list comprehensions
23:23:07 <dons> normal list comprehensions are maps and filters, parallel ones are zips
23:23:17 <satan> hmm i see
23:23:53 <satan> so if i had myzip = foldr f a where f = ((++) . g), a = [], g = ...
23:24:15 <dons> > filter (\x -> x `mod` 2 == 0) [1..10] == [ x | x <- [1..10], x `mod` 2 == 0 ]
23:24:17 <lambdabot>  True
23:24:22 <satan> and thats where g would take the 2 arguments and return a list like [(a,b]] which could be concatenated into giving the final answer
23:24:37 <dons> then, zip [1..10] [2..20] == [ (x,y) | x <- [1..10] | y <- [1..20] ]
23:26:00 <satan> so that will give me [(1,1), (2,2)...] and so on eh
23:26:22 <satan> wicked, it works
23:26:42 <satan> ok so how am i supposed to know that zip requires parallel list comprehensions :S
23:27:00 <ThreeQ> > [ (x,y) | x <- [1..10] | y <- [1..20] ]
23:27:01 <lambdabot>  Parse error
23:27:08 <lispy> i wish zip had a variant in the Prelude that passed the 'extra' elements through like identity...I tend to have that version laying around and find it quite handy
23:27:33 <dons> satan: by reading the defintion of list comprehensions in the haskell language report?
23:27:44 <dons> ?where h98
23:27:44 <lambdabot> http://haskell.org/onlinereport/
23:27:50 <satan> dons: ah ok, thanks
23:27:53 <satan> so much to read :)
23:28:00 <ThreeQ> hmm, lambdabot doesn't like parallel list comprehensions :(
23:28:18 <dons> yeah. it uses an h98 parser, unfort.
23:28:32 <dons> but parallel comprehensions are a glasgow ext (and may not even make it into haskell')
23:28:38 <lispy> ?type unfort
23:28:40 <lambdabot> Not in scope: `unfort'
23:28:57 <lispy> hm..that's a good function name too...just not sure what the type sohuld be
23:29:19 <lispy> i doubt they show up very often
23:29:28 <lispy> i can't think of a single case where i've used one in a program
23:29:41 <lispy> but...maybe i'm bisased
23:29:48 <satan> ok now to get use this with foldr and see if it works
23:30:10 <lispy> foldr?
23:30:20 <lispy> that's another one i rarely have a use for
23:30:20 <satan> yes i'm trying to rewrite zip using foldr
23:30:28 <dons> well, any time you used [ .. | x <- zip a b ] , you could have used a parlallel comp. but maybe that's not enough to justify yet more syntax
23:30:39 <lispy> oh hmm...actually i think i just tought of a use though
23:31:55 <lispy> ah yes
23:32:03 <lispy> if i use a foldr then i wouldn't have to reverse the list
23:32:15 <lispy> this could help speed up my parser
23:32:35 * lispy tries to remember this for tomorrow
23:34:36 <lispy> i tend to reverse my lists and then foldl but i guess that's roughly equivalent to using foldr
23:34:57 <satan> sounds bout right heh
23:34:59 <ThreeQ> also foldr won't force the list to be evaluated
23:35:16 <lispy> ThreeQ: yes, that is nice is some cases
23:35:18 <dons> lispy: you talking about bytestrings?
23:35:32 <dons> then you _definitely_ want to foldr, rather than reverse...
23:35:36 <lispy> dons: actually i stopped using the bytestrings but it would apply there as well
23:35:37 <dons> since that's just a down loop over the array.
23:35:52 <lispy> well, my list was String
23:36:05 <lispy> the digit parser returns an Char
23:36:17 <lispy> and y used many1 digit
23:36:33 <lispy> so i had String which needed to be converted to a number
23:36:40 <lispy> in some cases i could use readInt
23:36:45 <lispy> but, not for the part after the .
23:36:53 <lispy> because i needed the leading zeros
23:37:49 <dons> lispy: do we know any #haskellers in SanFran?
23:37:52 <lispy> i had been doing (foldl1' (\x y -> x/10 + y) digits)/10 where digits :: [Double]
23:38:11 <lispy> dons: not really...i'm actually in oregon
23:38:17 <dons> yeah i know. :)
23:38:23 <lispy> ah :)
23:38:24 <ThreeQ> i'm in berkeley which is close
23:38:28 <dons> but i know #haskellers in brisbane and melbourne... so maybe ...
23:38:50 <lispy> ThreeQ: that is close
23:38:57 <lispy> ThreeQ: how do you like berkeley?
23:38:59 <dons> anyway, i'm going to be in SF in 2 weeks. i wonder how many #haskellers we could find on such notice
23:39:07 <lispy> ah cool
23:39:11 <lispy> in 2 weeks...
23:39:21 <lispy> is there a conference?
23:39:21 <ThreeQ> it's... a bit rainy, right now
23:39:24 <ThreeQ> heh
23:39:34 <lispy> heh, corvallis hasn't started raining yet, but it should have by now
23:39:36 <dons> lispy: yeah, the SoC summit at google
23:39:43 <lispy> dons: Ah, nice
23:39:53 <lispy> wish i had an excuse to drive/fly down and say hi
23:40:04 <lispy> but it's like 8+ hours by car
23:40:09 <dons> yeah
23:40:26 <dons> ThreeQ: I see the article did quite well after you posted it yesterday :)
23:40:37 <ThreeQ> yeah, it did
23:40:38 <ozone> lispy: you're in berkeley?  i might be there later this month
23:40:49 <lispy> ozone: oh no, i'm in Corvallis
23:40:55 <ozone> or rather, i'll be there, it's just a matter of when
23:40:57 <lispy> ozone: you mean ThreeQ :)
23:41:00 <ThreeQ> although I'm not sure it was a good idea to submit to to general reddit at the same time
23:41:05 <ozone> oh, that's who i meant
23:41:08 <ThreeQ> that's probably where most of the downmods came from
23:41:08 <ozone> right :)
23:41:11 <dons> ThreeQ: yeah, that might explain some of the downs
23:41:33 <dons> ThreeQ: it started way up, like 30 /3 , but then the downs started and its back to 50/50
23:41:49 <dons> i mean, 100/50
23:41:52 <lispy> dons: so dcoutts was telling me that the linspire bytestring parser i tried to use is setup to make backtracking easier...and that probably explains the explosion in memory usage
23:42:03 <dons> ah
23:42:05 <dons> interesting
23:42:16 <ThreeQ> still #6 on programming.reddit though
23:42:24 <ThreeQ> which is what actually matters
23:42:37 <lispy> bytestring has a lot of subtlties i'm unaware of and i'm sure that contributed as well
23:42:40 <dons> 4,414 views so far too.
23:42:42 <Bobstopper> hmm. ifdefs seem to cause ghc to fail when running under wine. I get lexical errors for lines with #ifdefs. If I try to put in a -cpp flag (I assume that's what handles ifdefs) I get a bunch of assembler message errors. Any hints on what I might be doing wrong?
23:43:06 <dons> up to #55 on haskell.org (the unix tools one made it to 61. 4,018 views)
23:43:14 <lispy> Bobstopper: do you use cabal?  if so put CPP as one of the extensions
23:43:21 <dons> lispy: oh, subtleties?
23:43:27 <dons> you mean, complexity wise?
23:43:40 <lispy> well, it seems like there are some things you shouldn't do with bytestring
23:43:45 <lispy> to avoid copying and such
23:43:54 <dons> right. same with [a], though.
23:43:57 <lispy> and i don't really know any of them :)
23:44:06 <Bobstopper> lispy: that will avoid the assembler message erors as well?
23:44:15 <dons> ah you're suppose to look for the O(n) ops -- and then not use them :)
23:44:25 <dons> its in the docs. I wonder how i could make that kind of thing clearer
23:44:34 <lispy> Bobstopper: probably not, but just thinking that way we'd know that the right flags are passed to enable the c pre-processor
23:44:46 <Bobstopper> ok
23:44:54 <lispy> dons: i didn't read much i just went for function definitions :)
23:45:01 <lispy> dons: i was in a hurry...
23:45:05 <lispy> bad lispy
23:45:07 <Bobstopper> well, I was getting these errors under missingH which was using cabal.
23:45:43 <lispy> dons: for now i think its safest to stick to parsec
23:45:59 <MarcWeber> I'd like to add an arcticle on haskell wiki about vim and haskell on haskell.org. Where is the right location to start editing/ put it?
23:46:31 <lispy> dons: if we built and optimized a parsec ontop of bytestring and i knew it was good then i'd be happy to plug it in...but not knowing if it's the parser or my use of it really confounds the optimization process
23:47:21 <lispy> dons: oh and one thing i had trouble figuring out was how to write a function String -> ByteString
23:47:54 <ozone> dons: when will bytestring be O(1) for all operations?
23:47:57 <ozone> and if not, why not?
23:48:09 <lispy> it ended up buing something like toBS = pack . map (toEnum . fromEnum)
23:48:10 <MarcWeber> "Libraries and Tools -> Editors" or "Wiki arcticles"?
23:48:37 <lispy> MarcWeber: i'd probably look for editor information if i was trying to find info about using vim
23:49:09 <lispy> dons: i only wanted such a function to test my parsers
23:49:13 <MarcWeber> So the first one ..
23:49:18 <lispy> dons: but it still would have been handy
23:49:24 <lispy> MarcWeber: yeah seems reasonable
23:49:31 <lispy> MarcWeber: i wouldn't sweat it too much
23:49:47 <lispy> MarcWeber: if believes it's in the wrong place, hopeflly they will reor
23:49:50 <lispy> er reorg
23:50:56 <dons> lispy, that's called 'pack'
23:51:01 <dons> ozone: hehe
23:51:13 <MarcWeber> lispy: Thanks for this advice. I'll announce at haskell-cafe, too
23:51:14 <lispy> dons: right, but getting from String -> [Word8] is the hard part
23:51:17 <dons> ?type Data.ByteString.Char8.pack
23:51:18 <lambdabot> String -> Data.ByteString.Base.ByteString
23:51:25 <monochrom> All bytestring operations are clearly O(2^64).
23:51:27 <lispy> hmm...
23:51:34 <dons> ?type Data.ByteString.pack
23:51:35 <lambdabot> [Word8] -> Data.ByteString.Base.ByteString
23:51:39 <lispy> Ah
23:51:43 <lispy> that's the pack i found
23:51:54 <dons> String/Char stuff is in the .Char8 version
23:52:16 * lispy is slow :)
23:52:22 <lispy> i didn't even notice
23:52:23 <dons> ?remember ozone when will bytestring be O(1) for all operations?
23:52:44 <lispy> monochrom: that's a good point
23:52:53 <monochrom> hee hee
23:53:06 <lispy> took me a minute to see what you meant though ;)
23:54:42 <lispy> friend of mine is already using the library for hinfo that lennart published :)
23:54:52 <lispy> talk about fast assimilation
23:56:18 <dons> not that lennart though. kolmodin
23:56:35 <dons> seems like it could have some fun uses.
23:56:46 <dons> what is the inotify stuff used for typically?
23:57:23 <lispy> ah
23:57:40 <lispy> my friend wrote a battery monitor for his laptop
23:57:46 <dons> we have two lennarts of distinction and repute :)
23:57:53 <lispy> and it reads out of /proc or somewhere
23:58:13 <lispy> ah the lennies of haskell
23:58:40 <lispy> so i think current he uses concurrency to keep polling it every second or so
23:58:51 <lispy> this will let him use an event based algorithm
23:59:11 <dons> yeah. that's nice.
23:59:19 <dons> would work for lambbdabot's darcs plugin
23:59:23 <lispy> yeah, he should publish it
