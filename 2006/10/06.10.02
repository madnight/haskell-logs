00:00:09 <mwc> As it stands now, there's a fixed set of tokens where it initiates layout
00:00:30 <skew> Besides, we should switch to parser combinators or GLR or something if the tools get in the way of a nice grammar
00:00:32 <mwc> skew, it's not the outermost level. theoretically, the outermost level contains your module declaration
00:00:48 <mwc> so it's the 1st nested level
00:01:05 <skew> right, and I guess you might want to do this in where bindings and so on
00:01:16 <mwc> yeah, that too
00:01:50 <skew> for other things in the grammar, why are things like "type", "default" and "class" completely reserved when they can only appear as top-level declarations
00:02:06 <skew> at least "as" is only special inside an import specification
00:02:22 <dons> ?yow!
00:02:23 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
00:02:40 <dons> ?uptime
00:02:41 <lambdabot> uptime: 2d 8h 8m 35s, longest uptime: 4d 20h 30m 23s
00:02:52 <mwc> skew, hiding too. Dunno. Probably since they were part of the standard. as and hiding were probably added later, and they didn't want to upset exisiting code
00:03:38 <skew> It's very easy to write a parser with Parsec that only considers a word special in a certain place in the grammar
00:03:48 <mwc> yeah
00:03:55 <mwc> string "as"
00:04:32 <skew> so it seems sort of like all these restrictions are just there to help our tools
00:04:59 <mwc> makes syntax highlighting easier I suppose ;)
00:14:57 <dons> ?seen shapr
00:14:58 <lambdabot> shapr is in #haskell and #ScannedInAvian. I last heard shapr speak 7h 44m 59s ago.
00:15:18 <dons> ?users
00:15:36 <lambdabot> seen module failed: IRCRaised thread killed
00:15:41 <klutometis> @girl19
00:15:42 <lambdabot> I'm in Moscow, Russia
00:16:33 <shapr> dons: You called?
00:16:55 <klutometis> @protontorpedo
00:16:56 <lambdabot> lazy makes macro not needed?
00:18:05 <dons> shapr: you booked your plane, or heard back from the travel people?
00:18:06 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
00:18:12 * dons just got back from the beach :D
00:18:41 <shapr> Neither, I've been distracted, I'll do it tomorrow morning.
00:18:55 <dons> fair enough. i wonder why they havne't gotten back to me yet
00:19:31 <skew> going to Australia?
00:19:56 <shapr> Nah, San Francisco
00:20:10 <skew> found a job?
00:20:16 <shapr> dons and I will represent haskell.org at the SoC Summit
00:20:16 <Pseudonym> Bleah.  What's in San Francisco?
00:20:31 <Pseudonym> Ah, fair enough.
00:20:42 <shapr> The attendee list is really fun.
00:20:58 <skew> I haven't heard much about what other things happend in SoC
00:21:04 <Pseudonym> That's the first time I've ever heard a list described as "fun"./
00:21:24 <dons> shapr: they'll be an announcment tomorrow, I think
00:21:31 <dons> if i can finish polishing it up.
00:22:14 <kosmikus> shapr, dons: that's great news. when is it?
00:22:38 <dons> 2 weeks or so.
00:22:44 <kosmikus> have fun
00:22:54 <dons> hopefully.
00:22:57 <kosmikus> why not?
00:23:23 <dons> :) should be very exiciting. lots of cool open source guys will be there
00:23:55 <kosmikus> right.
00:24:08 <kosmikus> lots of future Haskell programmers, you mean.
00:24:12 <dons> ;)
00:24:15 <dons> fingers crossed
00:24:16 <shapr> Lots of nifty people will be at the summit. Anthony Towns, Erich Schubert, Ian Clarke, Thomas Waldmann, Fyodor Vaskovich, Bart Massey are the names I recognize.
00:24:27 <dons> maybe we should get a bucket of lambda candies to hand out
00:24:44 <shapr> And Chris DiBona
00:25:18 <shapr> I'd like to solicit ideas for improving SoC from #haskell and the mailing lists.
00:25:32 <dons> yeah, that'l be in the announcement tomorrow
00:26:01 <Pseudonym> They should make it Haskell-only.
00:26:09 * shapr grins
00:26:31 <skew> how much Haskell do they use at google?
00:27:11 <Pseudonym> As a guess, I'd say almost exactly none in production.
00:27:24 <skew> this story suggests at least one VP is tired of hearing people suggest lisp and smalltalk http://www.flownet.com/gat/jpl-lisp.html
00:27:27 <Pseudonym> But certain people no doubt use it a lot in their 20% projects.
00:27:46 <dons> yeah. like the icfp winners, from google
00:27:50 <Pseudonym> Though having said that, they use DSLs quite a bit.
00:28:07 <Pseudonym> I'd be willing to wagerr that a few special-purpose compilers there are written in haskell.
00:30:02 <lmbdwr> lo all
00:31:20 <skew> hi
00:32:11 <dolio> Hmm... I must have Visual Studio installed in order to install this font...
00:32:19 <shapr> Oh hey, I was thinking about lisp macros and self modifying code... Haskell already does self modifying code, it's called laziness.
00:32:31 <shapr> skew: That's fun to read.
00:33:07 <Pseudonym> Gotta go.  Nytol!
00:33:19 * shapr reaches the unpleasant news section
00:33:22 <skew> I was thinking about binding and macros - in E they argue that macros shouldn't be able to mess up the binding structure too much, so maybe you should only be able to do as much as you can with lambdass
00:33:56 <kosmikus> moin
00:35:07 <shapr> Okasaki's discussion of laziness as self modifying code is really pushing my thinking in strange directions the last few days.
00:36:03 <scsibug> shapr: are you reading this from his data structures book, or somewhere else?
00:36:25 <shapr> Yes, his data structures book.
00:36:34 <shapr> I bought it after Haskell Workshop.
00:36:51 <roconnor> shapr: laziness, or circular programming?
00:36:54 <skew> It sounds like I should read it more then. I picked it up just to have lots of the nice algorithm descriptions in one place
00:36:58 <scsibug> I haven't finished reading it yet, but yes, it definitely makes you think in new ways
00:37:13 <roconnor> because laziness is just a different evaluation strategy
00:37:57 <shapr> What's circular programming?
00:38:12 <roconnor> @wiki circular programming
00:38:13 <lambdabot> http://www.haskell.org/haskellwiki/circular programming
00:38:21 <roconnor> okay, I need to stop using @wiki
00:38:21 <shapr> I've definitely programmed in circles before, but I don't think that's what you mean :-)
00:38:44 <roconnor> \x -> let (a,b) = (f a x) in b
00:38:56 <roconnor> that is a canonical example of circular programming
00:39:06 <roconnor> when the result of a function is used as the input.
00:39:57 <shapr> Oh
00:40:07 <shapr> No, I don't think that's what Okasaki is talking about.
00:40:19 <roconnor> I suppose it is the same a recursion, except a is usually a data type rather than a function type.
00:40:33 <shapr> skew: Great url, got anymore like it?
00:40:44 <klutometis> anybody do haskell CGI, btw?
00:40:53 <klutometis> seems like a violent, unnecessary undertaking
00:41:03 <shapr> What, haskell cgi?
00:41:07 <klutometis> yeah
00:41:19 <shapr> Why not use HAppS, Hope, or some other higher level Haskell web app framework?
00:41:32 <shapr> WASH is common, for example.
00:41:33 <klutometis> thanks; that's what I was looking for
00:42:09 <skew> shapr: I don't think so, but the Coq tutorial is great fun.
00:42:47 <klutometis> shapr: I'd come across Laitenberger's library; and cgi-compat
00:42:54 <klutometis> but they're pretty low-level
00:43:57 <shapr> I've been using HAppS for the last few days, it's really nice.
00:43:58 <dons> klutometis: check haskell.org, under 'libraries and tools'
00:44:05 <dons> there's a section on web programming
00:44:23 <skew> shapr: how did you figure out how to use it? Has it grow docs since I last looked?
00:44:44 <shapr> It's much higher level than CGI, but not as high level as Zope/Plone or J2EE (so big and slow you drown).
00:45:01 <shapr> I don't know if it's grown docs, but the primary HAppS developer is on #haskell =)
00:45:10 <skew> shapr: have you ever looked at Coq?
00:45:15 <shapr> So I just hacked around and only asked questions when I was really beating my head against the wall.
00:45:51 <shapr> skew: No, but I really want to get into program extraction from proof assistants. Sadly I can't spare the time to do anything but pursue contract work.
00:46:05 <klutometis> i was mainly interested in using haskell as a web service
00:46:12 <klutometis> but Haskell-SOAP doesn't seem to exist
00:46:44 <klutometis> but the higher level web frameworks may do the trick
00:46:44 <skew> shapr: and can use HAppS for that?
00:47:00 <shapr> I have the solution to the "Lisp will be rejected" (or Haskell, Erlang etc) problem. Run your own company and solve your clients problems with the language of your choice. If you're good at it, your language is accepted. If not, you'll end up using Java.
00:47:14 <shapr> klutometis: There is a Haskell-SOAP.
00:48:02 <klutometis> shapr: still looking; google brings up soap operas
00:48:06 <shapr> skew: Yes, I can use HAppS to pursue contract work. Most of my contract work is to build websites with Zope/Plone but that cancerous mass of source code is making me crazy.
00:48:08 <klutometis> an unfortunate acronym if you ask me
00:48:44 <shapr> @google filetype:hs soap
00:48:47 <lambdabot> http://darcs.haskell.org/hxt-typesafe/examples/hunit/HUnitExample.hs
00:48:56 <klutometis> Haifa looks like it may work
00:49:02 <shapr> I get 23 hits.
00:49:05 <klutometis> hmm
00:50:50 <klutometis> HAIFA apparently supports a superset of web-services not limited to SOAP
00:50:54 <klutometis> beautiful
00:55:26 <roconnor> @what hafa
00:55:26 <lambdabot> I know nothing about hafa.
00:55:29 <awarth> hey guys
00:55:30 <roconnor> @what haifa
00:55:31 <lambdabot> I know nothing about haifa.
00:55:40 <awarth> does anyone here know about haskell's strictness annotations?
00:55:55 <roconnor> a little
00:56:10 <awarth> so, do you mind giving me a quick explanation?
00:56:17 <awarth> for instance, where can I use them? anywhere?
00:56:22 <roconnor> anywhere
00:56:38 <awarth> i.e., anywhere a type is expected, can I write a ! in front of it
00:56:44 <roconnor> the easiest way to use them is to run (f $! x)
00:57:00 <awarth> and whatever expression I write will be forced implicitly?
00:57:02 <roconnor> oh, you mean strictness on data constructors?
00:57:09 <skew> awarth: you can write ! in front of the type of a field of a constructor
00:57:32 <awarth> so if you do that, do expressions that have to get that type get forced automatically?
00:57:37 <awarth> (implicitly?)
00:57:57 <skew> no, putting something into that field of that constructor forces it
00:58:18 <roconnor> awarth: it means everytime the data type is constructed, it is forced.
00:58:48 <roconnor> skew's answer is better
00:59:13 <awarth> hmm, i think i get it.
00:59:18 <awarth> but can i say something like this:
00:59:30 <awarth> f :: !Int -> !Int
00:59:31 <awarth> ?
00:59:36 <skew> also, GHC 6.5 implements "Bang Patterns" - http://haskell.galois.com/cgi-bin/haskell-prime/trac.cgi/wiki/BangPatterns
00:59:39 <lambdabot> Title: BangPatterns - Haskell Prime - Trac, http://tinyurl.com/sykvv
00:59:40 <awarth> meaning that f is a strict function from Int to Int?
00:59:49 <skew> where you could write f !x = ... x ...
01:01:17 <awarth> thanks, guys, I'll read about this stuff.
01:01:22 <awarth> i appreciate the help!
01:02:13 <shapr> Everyone enjoys #haskell except for SML fetishists.
01:04:23 <skew> We don't have many partisans of untyped languages either. Which reminds me, have you see my typing work? http://www.ugcs.caltech.edu/~brandon/
01:04:24 <lambdabot> Title: Brandon's Stuff
01:10:57 <shapr> You've mentioned it to me, but I haven't had time to look at it.
01:15:09 * lispy wants to talk with someone that uses a theorem prover assistant or automated theorem prover
01:15:54 <lispy> at first they sounded really useful..
01:16:02 <lispy> then just really confusing and hard to work with
01:17:15 <lispy> it seems that people use Coq to 'prove a theorem' (still not sure what they mean, since they talk about proving 1+1=2) and ask it to generate code for that theorem
01:17:22 <musasabi> morning
01:17:24 <lispy> which makes me wonder why bother with Coq?
01:17:32 <lispy> musasabi: morning
01:18:30 <musasabi> doctor said it would take a month for the foot to heal :-(
01:19:23 <lispy> musasabi: did you break something?
01:20:28 <dons> sounds nasty
01:21:21 <lispy> dons: do you know much about these theorem prover systems?  what they are good for?
01:22:23 <dons> proving theorems?
01:22:42 <dons> did you see the haskell kernel api verified for various properties in isabelle?
01:22:50 <skew> also for writing code.
01:23:13 <dons> that kind of thing-- properties you can't check in the haskell type system, perhaps
01:23:36 <musasabi> dons: sprained it nastily. no broken bones but after using it hurts for hours.
01:23:49 <dons> musasabi, how'd you do that?
01:24:11 <lispy> dons: hmm...i'llgoogle it
01:24:12 <musasabi> shapr: you can ask quick HAppS questions more if you want. btw if you are going over the things haddock doc patches always welcome.
01:24:28 <lispy> musasabi: sprains can be just as bad (maybe worse?) than breaks it seems
01:24:32 <dons> lispy: check the 'os kernel' sectoin of the haskell.org research papers wiki
01:24:38 <shapr> I'm about to sleep now, but tomorrow I'll have more HAppS questions.
01:24:54 <lispy> dons: okay
01:25:12 <dons> also there's a section on verification of haskell code
01:25:17 <dons> which points to other such systems
01:25:28 <musasabi> dons: well I was coding Haskell... and then N came come and I wanted to go to the front door and the evil carpet was in the way...
01:25:36 <musasabi> @localtime shapr
01:25:41 <lambdabot> Local time for shapr is Mon Oct  2 03:25:16 2006
01:25:50 <musasabi> hmm. that is not Sweden.
01:26:05 <musasabi> *came home
01:26:13 <shapr> I live in Alabama now.
01:26:15 <skew> lispy: in Coq at least, you can write code much like you would in epigram, but you can also apply various automated tactics for constructing bits with no computational content
01:26:37 <dons> evil carpet heh. poor musasabi
01:27:20 <lispy> dons: this one? http://cgi.cse.unsw.edu.au/~rafalk/pubs/vstte06.pdf#search=%22haskell%20os%20kernel%20isabell%22
01:27:22 <lambdabot> http://tinyurl.com/gn3gl
01:27:53 <lispy> skew: eh?
01:28:01 <lispy> so here is what i want to do
01:28:13 <lispy> write down the things we think are axioms of darcs patch theory
01:28:24 <lispy> and try to derive the some of the laws we have now
01:28:28 <dons> hmm. maybe. i was thinking this one, http://www.cse.unsw.edu.au/~chak/papers/DEKC+06.html
01:28:29 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/zkuqh
01:28:32 <lispy> and try to check for inconsistencies
01:29:06 <lispy> dons: thanks
01:29:09 <skew> hmm, proving things about Haskell code per-se would take some work formalizing Haskell
01:29:32 <dons> yeah
01:29:40 <skew> but you could do like they did in the microkernel stuff, and translate definitions into functions in your theorem prover, and then prove stuff about those functions
01:29:43 <dons> there's also Agda, for proving things about Core
01:30:03 <lispy> i don't want to prove anything about our haskell code
01:30:12 <lispy> i want to prove that patch theory is sound
01:30:25 <skew> for example, if you just want to check that the GADT stuff has properties you like, you can define equivalent types in Coq (and probably many other systems), and then prove things about them
01:30:37 <dons> lispy: oh!
01:30:43 <dons> i've got some ideas for that already...
01:30:46 <dons> let me find the page :)
01:30:52 <lispy> :)
01:30:58 * lispy found the magic words
01:31:30 <dons> here, http://www.cse.unsw.edu.au/~pls/thesis-topics/theoryofpatches.html
01:31:32 <lambdabot> Title: Thesis Topic : A Formal Theory of Patches in Isabelle/HOL, http://tinyurl.com/j65ju
01:31:44 <dons> you can come to UNSW and do your honours thesis on it :)
01:32:18 <dons> just a sketch there, and a couple of links.
01:32:49 <lispy> heeh
01:32:55 <lispy> is that for undergrads?
01:32:58 <dons> yep
01:33:01 <dons> good ones
01:33:06 <lispy> ambitious...
01:33:11 <lispy> yeah our ungrads do much less
01:33:15 <lispy> i mean...much
01:33:34 <lispy> i could work on darcs for a masters project/thesis :)
01:33:37 <dons> we like to try to get good ones for our group :)
01:33:49 <dons> the last guy we had was the Frag hacker
01:34:00 <lispy> right
01:34:12 <lispy> Fragger
01:34:28 <lispy> it's where you hop across a quake3 map trying not to get hit by a...missle
01:34:41 <dons> heh
01:34:58 <lispy> cool, well, i'll use that sketch as a starting point
01:35:11 <lispy> any idea why they picked isabell as the ATP?
01:36:15 <dons> oh, we have some Isabelle experts down here.
01:36:42 <lispy> all of them have horrible syntax...
01:36:55 <lispy> just makes my skin crawl after using haskell
01:37:02 <dons> :) yeah. like twelf. urgh
01:37:16 <skew> lispy: http://www.cs.berkeley.edu/~adamc/papers/CertVerICFP06/
01:37:18 <lambdabot> Title: Modular Development of Certified Program Verifiers with a Proof Assistant, http://tinyurl.com/mmwy2
01:38:19 <lispy> skew: thanks
01:38:29 <skew> They seem to be using Coq as a dependently-typed programming language
01:38:30 <lispy> i should sleep now...but i'll save these links
01:38:36 <lispy> yeah
01:39:15 <Bourbaki> moin
01:39:18 <lispy> i want a system that reasons based on rules and gives me back new results or tells me i'm contradicting myself
01:39:36 <lispy> but we'll see...i should play with these a bit...maybe i just need to use prolog :)
01:39:51 * lispy &
01:40:01 <skew> From the little I've seen, with Coq it's more like you try for a while to prove something, and then give up
01:40:10 <skew> at least when it's unprovable
01:44:02 <musasabi> *came home
01:44:09 <musasabi> agh. irssi history...
02:07:36 <musasabi> Is the HaXml >= 1.14  XmlContent documented somewhere?
02:11:44 <musasabi> ah. the separate -devel page has it.
02:39:39 <dblhelix> @pl (\x f -> f . (x :))
02:39:40 <lambdabot> flip (.) . (:)
02:54:40 <musasabi> vegai: the issue of HAppS.Agents.Users for very recent GHC HEAD is fixed in the darcs version. It was about the interpretation of foralls in type declarations.
02:56:40 <musasabi> "type Foo a b c = forall d e f. ..." seems like a popular thing ti cause problems.
02:56:56 <musasabi> *to
02:57:16 <mwc> existential types?
02:58:16 <musasabi> mwc: not really. forall:ed type parameters for parts of a type that are not used by a computation.
02:58:48 <mwc> ahh, I was thinking that looked like the declaration for an existential type
03:08:55 <vegai> musasabi: darcs version of HAppS?
03:11:10 <musasabi> yes
03:13:27 <musasabi> That is API compatible with the latest release at the moment and should be quite stable.
03:34:10 <earthy> hm. question. given an ms access mdb file, what would be the best interface? HSQL, Takusen, HaskellDB or CoddFish?
03:34:49 <musasabi> hdbc or haskelldb probably depending on what you want.
03:35:04 <earthy> well, I'm going to have to do operations per tuple
03:35:13 <earthy> I'm not very interested in joins and stuff
03:42:03 <earthy> okay, looking at hdbc and haskelldb, I'd prefer haskelldb, for it has stronger support for the tuples in the db
03:43:54 <alar> @where Takusen
03:43:54 <lambdabot> I know nothing about takusen.
03:45:57 <alar> @google CoddFish
03:46:07 <lambdabot> http://wiki.di.uminho.pt/wiki/bin/view/PURe/CoddFish
03:59:18 <mwc> @seen Cale
03:59:19 <lambdabot> Cale is in #haskell and #ghc. I last heard Cale speak 5h 38m 25s ago.
04:03:26 <int-e> he's awake ;)
04:03:49 <SimonRC> hi
04:04:55 <Cale> mwc: yeah? I'm awake but I should get going
04:05:19 <dblhelix> anyone know of an elegant way to control haddock's --title option from a .cabal file?
04:06:29 <yip> Cale: i've compiled ghc from source and now there is a file ./compiler/libHSghc.a
04:15:55 <SamB> yip: is this at all surprising?
04:16:19 <SamB> as Lemmih so astutely put it last night, you *should* have *had* that file already
04:16:48 <SamB> poked Igloo yet?
04:18:57 <mwc> Cale, oh, just confirming you're at Macmaster?
04:19:00 <yip> SamB: no
04:19:24 <yip> SamB: it wasn't completely expected
04:19:47 <yip> SamB: it could have been that the latest snapshot that i have is broken
04:19:57 <yip> SamB: but apparently only the pre-built binary version is broken
04:20:31 <roconnor> :type orElse
04:20:39 <yip> @seen Igloo
04:20:40 <roconnor> @type orElse
04:20:40 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 16h 29m 36s ago.
04:20:41 <lambdabot> Not in scope: `orElse'
04:20:45 <roconnor> @type mplus
04:20:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
04:22:18 <SamB> yip: it is much more likely for something to be accidentally left out of the tarballs, I think, than for it not to be built
04:22:34 <roconnor> > lex "abc def"
04:22:35 <lambdabot>  [("abc"," def")]
04:22:48 <yip> SamB: either way, it's incomplete
04:22:49 <roconnor> > lex " def"
04:22:50 <lambdabot>  [("def","")]
04:22:51 <SamB> because, well, people building it out of darcs tend to notice things not being built
04:23:04 <roconnor> > lex "\" def\""
04:23:05 <lambdabot>  [("\" def\"","")]
04:23:38 <SamB> or, maybe what I mean is that the people who are most interested in such cutting-edge things are likely to build from darcs
04:25:50 <yip> makes sense
04:26:26 <yip> but isn't ghc6.6 already passed the "release candidate" stage? things like missing files should not happen :o
04:29:08 <syntaxfree> Has someone thought of making a continuum monad yet?
04:29:17 <syntaxfree> s/yet/already.
04:37:22 <SamB> how about a Star Trek monad?
04:37:55 <yip> SamB: btw, has the GHC api changed at all? i get problems with GHC.init function, it doesn't seem to exist
04:38:15 <syntaxfree> no, really, a continuum monad should prove useful for certain kinds of knowledge domains.
04:38:55 <syntaxfree> I'm not really certain of how to spec it, though.
04:39:27 <dons> yip: I see in the latest ghc release candidate, Igloo says "Also, please note that the GHC API has changed since the last RC as a
04:39:30 <dons> result of some feedback from the Hackathon, so you may want to check
04:39:33 <dons> that any applications using it still work."
04:40:32 <syntaxfree> what are functional dependencies, after all?
04:41:12 <yip> dons: interesting, but GHC.init appears to be a function that all programs would need to use. so if it has changed then all applications using it will not work :o
04:41:24 <dons> perhaps the name has changed?
04:41:37 <dons> check the commit log
04:41:39 <dons> or the src
04:41:58 <dons> syntaxfree:
04:42:01 <dons> ?wiki Research_papers/Type_systems#Functional_dependencies
04:42:01 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Functional_dependencies
04:42:08 <syntaxfree> ok!
04:42:10 <syntaxfree> thanks.
04:42:49 <kzm> Does ByteString and FPS export the indexing type?  And if not, shouldn't they?
04:43:02 <SamB> ???
04:43:22 <dons> ?type Data.ByteString.index
04:43:24 <lambdabot> Data.ByteString.Base.ByteString -> Int -> Word8
04:43:29 <syntaxfree> I haven't used ByteString, but wouldn't the indexing type be just Int?
04:43:41 <dons> it is, for strict bytestrings
04:43:43 <syntaxfree> yeah, what I thought.
04:43:49 <dons> ?type Data.ByteString.Lazy.index
04:43:50 <lambdabot> Data.ByteString.Lazy.ByteString -> Int64 -> Word8
04:43:53 <syntaxfree> ahh, I see.
04:44:04 <dons> kzm? it's not a polymorphic type.
04:44:23 <syntaxfree> so, ByteString is Word8-only? No Unicode schmunicode?
04:44:29 <kzm> It's nice to be able to switch BS implementations without updating all my type signatures.
04:44:58 <dons> you could define a type alias, type Index = ....
04:45:03 <kzm> Wasn't there a SoC thing to add Unicode? (shcmuni- or not)
04:45:09 <dons> yes. :)
04:45:11 <kzm> Yes, that's what I tend to do.
04:45:14 <earthy> syntaxfree: how would you put unicode codepoints in 1 byte?
04:45:28 <dons> and we now have Storable a => Vector a
04:45:37 <kzm> I just wanted to suggest that it be part of the library, so users won't have to worry about it.
04:45:38 <dons> implementing the bytestring api, over Storabels
04:45:41 <syntaxfree> not in one byte, but using Word32 or whatever?
04:45:47 <dons> kzm: yeah. hmm. i'll think about this.
04:45:56 <dons> syntaxfree: see above. and talk to sjanssen about his work on this.
04:46:13 <musasabi> utf-8 over normal (lazy) bytestrings might be the way to go.
04:46:49 <syntaxfree> Just a thought.
04:47:02 <syntaxfree> Far from me to pressure someone working for free into doing what I want :)
04:47:04 <musasabi> then again most of the time I am interested in a byte-level or the grapheme level - very rarely code points.
04:49:48 <kzm> Wasn't a gzip-decoding lazy fps announced recently, btw?
04:52:01 <musasabi> yes.
04:52:10 <therp> fps?
04:52:24 <kzm> therp, fast packed strings (Data.ByteString nowadays)
04:52:35 <therp> ah thanks
04:53:02 <kzm> I'm stuck at gunzip -c file | myprog ... - but I think that works okay for me for now.
05:09:08 <xerox> ?yow!
05:09:09 <lambdabot> Now, let's SEND OUT for QUICHE!!
05:10:50 <Thomas2_> can anyone explain those to me? I just don't get it
05:12:04 <gds> They're just for fun.
05:12:15 <gds> If you're on a linux box, try playing with "fortune"
05:12:32 <x3m> dons: came up with any new ideas to hs-plugins/win yet?
05:13:39 <Thomas2_> I've been reading fortune for years
05:13:48 <Thomas2_> I just don't get the BLAH BLAH the BLAH ones!!!
05:13:54 <gds> There's a fortune file called "zippy"
05:13:59 <xerox> Thomas2_: http://en.wikipedia.org/wiki/Zippy_the_Pinhead
05:14:02 <lambdabot> http://tinyurl.com/r3pk4
05:14:47 <syntaxfree> I'm trying to think of some way to incorporate Haskell into my dissertation.
05:15:59 <therp> syntaxfree: if your major is anthropology that might be hard :)
05:16:26 <syntaxfree> I'm going to grad school in economics.
05:16:38 <gds> xerox: impressive - I've gone this long without knowing about that :)
05:16:55 <syntaxfree> Anyway, there is some previous work in Simon's paper on contract pricing.
05:21:24 <yip> @hoogle HasBounds
05:21:25 <lambdabot> Data.Array.IArray.HasBounds :: class HasBounds a
05:23:36 <yip> has HasBounds changed in ghc?
05:28:05 <kpreid> @seen dons
05:28:06 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 42m 9s ago.
05:29:43 <ndm> anyone here have an account on darcs.haskell.org? I'm trying to log in, and am having some difficulty
05:33:14 <Igloo> yip: Yes
05:33:22 <Igloo> ndm: WFM
05:33:51 <ndm> Igloo: i've never done it before, are all haskell.org accounts working on darcs.haskell.org, or do you need a separate account?
05:33:56 <yip> Igloo: hello Igloo! i think there is a problem with the linux binary releases of ghc 6.5
05:34:05 <Igloo> ndm: You need a separate account
05:34:05 <yip> Igloo: they don't seem to have the ghc api
05:35:02 <Igloo> Hmm
05:35:10 <ndm> Igloo: separate again from a CVS account for haskell.org?
05:35:36 <Igloo> CVS accounts aren't separate frmo haskell.org accounts, are they?
05:35:49 <Igloo> Yes, anyway
05:36:26 <ndm> i have no idea :) i have both neil and ndm haskell accounts, not entirely sure for what...
05:37:26 <Igloo> neil@darcs.haskell.org and ndm@haskell.org exist
05:37:45 <ndm> Igloo: i think neil is someone else, ndm is me
05:37:53 <Igloo> neil:x:1006:1006:Neil Mitchell,,,:/home/neil:/bin/bash
05:38:44 <ndm> what, neil darcs.haskell.org
05:38:49 <ndm> hmm, so whats my password!
05:39:18 <xerox> 'x' :)
05:40:07 <ndm> Igloo: thank you, i got in :)
05:40:38 <ndm> @karma+ Igloo
05:40:38 <lambdabot> Igloo's karma raised to 10.
05:41:35 <sek> :w
05:41:42 <sek> oups, wong window
05:48:00 <yip> anyone know about happy 1.15 not compiling with ghc 6.5?
05:49:42 <yip> has the array api changed?
05:50:16 <musasabi> yes
05:50:24 <musasabi> yip: I think darcs has patches for that.
05:50:36 <yip> yeah, darcs also fails to compile
05:50:57 <musasabi> darcs version of Happy that is.
05:51:11 <Igloo> darcs darcs should also work
05:54:07 <yip> problem with darcs darcs is that i can't get it without darcs :)
05:55:01 <yip> also, i can't seem to find any information about happy darcs repos at happy website
05:55:52 <wilx> Because they are sad...
05:56:01 <wilx> Ok, bad joke.
05:56:30 <Igloo> http://darcs.haskell.org/happy/
05:56:32 <lambdabot> Title: Index of /happy
05:57:27 <ndm> Igloo: my darcs pull from the Yhc repo seems to be going non-termination wards....
05:57:58 <yip> happy darcs doesn't have any instructions on how to install :o
05:59:19 <dons> make install, iirc
05:59:38 <yip> do i first need to do a regular make?
06:00:00 <dons> ./configure ; make ; make install ; is the usual process
06:00:14 <dons> check the README (there should be one (?))
06:00:15 <yip> no autoconf files here
06:00:20 <yip> README doesn't mention anything
06:00:35 <ndm> hi dons, have you been to google yet?
06:00:43 <dons> next week
06:00:50 <dons> though still waiting on ticket confirmation...
06:01:03 <ndm> ask the ICFP team if they used hoogle to do their haskell programming ;)
06:01:12 <dons> heh ok.
06:01:31 <dons> and if i find they're running lambdabot?
06:01:45 <ndm> that would be impressive
06:01:56 <ndm> a decentralised massively parallel lamdabot
06:02:11 <dons> heh
06:02:12 <ndm> perhaps when you do arithmetic on google.com, it actually fires it off as a lambdabot query
06:02:21 <dons> hah!
06:02:36 <dons> one way to find out...
06:02:44 <dons> ?google map (+1) [1..10]
06:02:48 <lambdabot> http://home.online.no/~sigurdhu/12MAP_scales.htm
06:02:48 <lambdabot> Title: Garmin GPS 12 MAP and GPS III (PLUS): Map Page scales
06:02:50 <dons> doh!
06:03:27 <dons> google's calculator tool is clearly deficient ;)
06:03:50 * earthy grins
06:04:06 <earthy> > as a haskell interpretation metacharacter in google... that'd be cool
06:04:06 <lambdabot>  Parse error
06:04:53 <dons> :)
06:05:27 <frevidar> has anyone used fc++ here? I've got a snipet of code that behaves unusually I think: here it is: http://cpp.sourceforge.net/?show=20316
06:05:28 <lambdabot> Title: #C++ Pastebin
06:06:37 * dons `ap` sleep 
06:06:43 <frevidar> the output given in the comments is not what I expect at all
06:07:14 <marcot> Hello. Is there a HDBC tutorial?
06:07:37 <marcot> I'm trying to read its API, but APIs are not a very didatic doc.
06:08:20 <marcot> I don't get the point of the Statement data type.
06:09:36 <int-e> > map sum . tail . reverse . tails $ [7,5,3]
06:09:38 <lambdabot>  [3,8,15]
06:13:14 <frevidar> int-e: the output its giving is 1
06:13:21 <frevidar> as in, an "int 1"
06:13:45 <int-e> frevidar: Yes, but you're using C++ ;)
06:14:03 <frevidar> I know
06:14:17 <frevidar> and I'm not sure if its my compiler or if fc++ is broken
06:16:01 <frevidar> I like haskell, but things like wxwidgets haven't got complete up to date support in haskell.
06:16:12 <frevidar> so I figured fc++ would be a good way to mix the two
06:16:19 <musasabi> kcachegrind works very nicely with Haskell :-)
06:16:27 <xerox> Gtk2Hs!
06:16:36 <xerox> (Or F# maybe, if you're into .NET stuff?)
06:16:46 <frevidar> is there anything else like fc++
06:17:25 <frevidar> or does anyone know why my code is being dodgy?
06:20:31 <camster> I'd like to be able to do software transactional "memory" with flat files, in the sense that if you only permit two filesystem operations: a) read contents of file, b) replace contents of file, then your files behave a little bit like an IORef String, or a TVar String. Could this idea ever work?
06:21:12 <xerox> camster: this might be of interest to you http://lambda-the-ultimate.org/node/1036
06:21:14 <lambdabot> Title: Zipper-based file server/OS | Lambda the Ultimate
06:21:30 * camster proceeds with web browser
06:22:07 <xerox> Be aware, megaolegs of fun await there.
06:24:09 <musasabi> I think I finally understood many of my STM performance problems ^_^
06:24:34 <musasabi> nothing like looking at profiling with Haskell-agnostic toold.
06:27:07 <sek> let (x = \(IO s) -> s) in x $ readFile "file"     why wont this work?
06:27:53 <camster> The Zipper-based file/OS looks suitably mind-bending. I can't but help feel like it's slight overkill having to implement your own operating system though!
06:28:14 <camster> At least their slides refer to it as an OS.
06:28:17 <Lemmih> marcot: A Statement is a compiled query.
06:29:01 <marcot> Lemmih: hum... But can I execute a query without it, just using run?
06:29:46 <Lemmih> marcot: Yes, 'run' will create and execute the statement for you.
06:30:09 <marcot> Do you know where can I get examples of the usage of hdbc?
06:31:03 <marcot> Lemmih: so I'll never need to worry about Statement?
06:31:34 <Lemmih> marcot: Not really.
06:32:40 <marcot> Lemmih: thanks.
06:38:09 <kpreid> sek: IO is a type, not a constructor, so you can't match on it
06:38:18 <kpreid> that's why the code doesn't work
06:38:29 <kpreid> why you shouldn't *want* it to work is a different thing
06:43:43 <sek> how can i read a file into a string then?
06:44:45 <kpreid> with readFile and >>= or do
06:44:53 <sek> ah, ok
06:50:59 <roconnor> shouldn't ReadS be a monad?
07:06:02 <sek> kpreid, sorry, just to clarify, i got it working with do with: do x<-readFile "file"; putStr x     but whats the >>= equivalent
07:06:17 <sek> my monadic knowledge tends to null
07:06:22 <xerox> readfile >>= \x -> putStr x
07:06:24 <kpreid> @undo  do x<-readFile "file"; putStr x
07:06:25 <lambdabot> readFile "file" >>= \ x -> putStr x
07:06:50 <kpreid> @. pl undo  do x<-readFile "file"; putStr x
07:06:51 <lambdabot> putStr =<< readFile "file"
07:07:02 <kpreid> sek: lambdabot knows
07:07:08 <sek> i see. thanks!
07:07:19 <kpreid> =<< is just >>= with the arguments reversed
07:07:31 <xerox> The rules are:
07:07:31 <xerox> do { let { bindings }; ... }  =  let { bindings } in do ...
07:07:31 <xerox> do { x <- amb; ... }  =  amb >>= \x -> do ...
07:07:31 <xerox> do { amb; ... }  =  amb >> do ...
07:07:34 <xerox> do amb  =  amb
07:07:41 <earthy> and >>= is just one formulation of the basic operator for monads
07:07:45 <xerox> I.e. it is only a sintactic transformation.
07:13:53 <marcot> I'm trying to compile a code that uses HDBC with ghc --make -package HDBC-postgresql -fglasgow-exts -Wall -debug -O2 -i.:haskell -o haskell/urban haskell/Main.hs, but I'm getting the error:
07:14:00 <marcot> Could not find module `Database.HDBC.PostgreSQL.Connection':
07:14:01 <marcot>   it is hidden (in package HDBC-postgresql-1.0.1.0)
07:14:01 <marcot>   (imported from haskell/Connection.hs)
07:14:20 <marcot> How do I use hdbc package?
07:14:50 <Lemmih> Just import Database.HDBC.PostgreSQL
07:19:00 <sek> hmm, can i have a main function that doesnt result in IO() work, but which reads from a file, does something to what it read and returns this as one of my own data types?
07:19:07 <marcot> Lemmih: thanks.
07:19:36 <Lemmih> sek: No.
07:19:49 <Lemmih> sek: There's no escape from the IO monad.
07:19:59 <sek> crap
07:20:00 <sek> :p
07:20:54 <sjanssen> sek: but here's a simple program that reads a file and the prints it to the screen: main = do f <- readFile "filename"; putStr f
07:21:15 <sjanssen> should be easy to put your "do something" step in there
07:21:38 <sek> sjanssen, yeah, i got that working just a min ago. My plan is to read a file, parse it and returned the parsed data type to another file, which will translate it and then output it
07:22:16 <sek> but i guess i will have to read it from the other file, parse it with the imported parsing function from the initial file and then traslate and otput it
07:22:42 * earthy mumbles 'as if unsafePerformIO isn't an escape'...
07:23:00 <sjanssen> earthy: shhhh! ;)
07:23:22 <sek> which kindof ruins my plans as i have a couple of files that translate and output, but only one file that parses
07:23:32 <earthy> sek: why?
07:23:48 <earthy> just split it somewhat differently
07:24:02 <earthy> have a couple of files that translate, and one that parses, collects translations and outputs...
07:24:15 <sek> hmm, i guess
07:24:17 <sjanssen> sek: so you have functions of type: "MyDataType -> IO ()"
07:24:36 <sjanssen> is that right?
07:24:52 <earthy> MyData -> IO () can easily be turned into  MyData -> [IO ()]
07:25:13 <sjanssen> and you want to read in your data, parse it, and then pass the parsed data to several functions that transform and print it?
07:25:14 <earthy> and [IO ()] can be turned into IO [()]
07:25:15 <earthy> ;)
07:25:27 <sek> sjanssen, well i think i will have to, i was hoping of having main :: String -> IO() in the translators, and main :: STring -> Mydata in the parser
07:25:49 <mauke> whoa, why do you have two main functions?
07:25:53 <earthy> ;)
07:26:10 <sek> maybe another good point, heh
07:26:15 <dylan> Nothing wrong woth parse :: String -> IO MyData
07:26:25 <sek> i am doomed by imperative language structures
07:26:26 <earthy> sek: why would you want to return IO () rather than, say  [String]? or even some datatype that has Show defined for it?
07:27:02 <earthy> sek: you are doomed by seeing types as hindrance rather than help. :)
07:28:09 <Igloo> ls
07:28:11 <Igloo> Bah
07:28:45 <sjanssen> sek: from what I've gathered, it sounds like you are using multiple modules each with their own main function, right?  You probably want just one module, with a bunch of helper functions, and then one main function that calls all your helpers
07:28:58 <sek> yes
07:30:33 <sek> i think for now ill keep the main function in the parser file. This will work for now, not sure how this will be implemented with the rest of the code thats already there, but then again, thats not my problem, hehe
07:31:22 <roconnor> > sqrt 125
07:31:23 <lambdabot>  11.180339887498949
07:33:50 <roconnor> > arccos 0.5
07:33:51 <lambdabot>  Not in scope: `arccos'
07:33:55 <roconnor> > acos 0.5
07:33:57 <lambdabot>  1.0471975511965976
07:34:11 <roconnor> > acos 0.5 * 180/pi
07:34:13 <lambdabot>  59.99999999999999
07:36:55 <roconnor> (sin  (-5/6*pi),cos (-5/6*pi))
07:37:00 <roconnor> > (sin  (-5/6*pi),cos (-5/6*pi))
07:37:02 <lambdabot>  (-0.49999999999999994,-0.8660254037844387)
07:37:16 <roconnor> -2*sqrt 3
07:37:22 <roconnor> > -sqrt 3
07:37:24 <lambdabot>  -1.7320508075688772
07:37:44 <roconnor> > -(sqrt 3)/2
07:37:46 <lambdabot>  -0.8660254037844386
07:40:34 <roconnor> > acos (2/sqrt 5)
07:40:35 <lambdabot>  0.4636476090008062
07:42:10 <roconnor> > acos (2/5*sqrt 5)
07:42:12 <lambdabot>  0.4636476090008059
07:42:17 <roconnor> > acos (2/5/sqrt 5)
07:42:18 <lambdabot>  1.3909428270024184
09:10:34 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
09:10:34 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
09:10:34 --- names: list (clog_ madpickle Binkley chessguy Nshag edwinb pyronicide jajs glguy wchogg dottedmag alar binary42 Pupeno iblechbot Mibori jtoy slipstream obseleron sad0ur macron sek mgeo kpreid mGem_ lennart xerox triple_ sris Prip dvekravy dolio Itkovian dozer der_eq arjanb giksos perspectival Carillon BCoppens chris2 roconnor arjanoosting Syzygy- Patterner Tigge jgrimes foxy ProfTeggy lmbdwr gour ex__nor twanvl Godeke MisterC Jaak cwenner anonfunc)
09:10:34 --- names: list (moconnor MikeJS svens mauke mattam converter Philippa scsibug Bobstopper dfranke astrolabe user317 shapr Xgc x3m crem Botty Eidolos epiphone psi explicitjelly nick8325 Korollary wilx ashleyb clog Trixsey Nioate_ ThreeQ ikegami-- Adamant hyrax42 fnordus flux__ sceadu Cale qz lisppaste2 earthy dgoldsmith ski ramkrsna lambdabot thetallguy cmeme defcon8 cschneid GeoBesh eyck nothingmuch SimonRC noj lokadin matthew-_ yip @Igloo Revision17)
09:10:34 --- names: list (chrisb_ tmoertel_away deadbeef TSC ibid _frederik_ ulfdoz zamez tessier_ mlh_ norpan gaal nnunley johs Kahdloc khaladan liyang dany2k Khisanth Lemmih arguile Daveman audreyt wolverian Betovsky kilimanjaro tessier ricebowl Twigathy sjanssen vegai Baughn joe_k bdash mornfall boliver__ kzm__ carp carp_ sellout kaol scw ValarQ cathper integral mathrick bran_ SamB woggle petekaz newsham saccade profmakx kosmikus juhp Spark Codex_ arcatan)
09:10:34 --- names: list (sieni df_ dcoutts lispy TwigEther lucca irgs tic aleator gds ksandstr_ dylan ozone nattfodd bartw Lunar^ cpatrick pingu drbean kpk orbitz ohub dons mux kzm dwm kalven rycee Thomas2_ resiak qwr Azmo_ kolmodin shrimpx pejo emu dcoutts_ psnl gdsx jmob nomeata musasabi magagr)
09:11:46 <musasabi> hello
09:12:13 <dozer> thangs Igloo - grepping now
09:12:14 <musasabi> irssi. every single day. I should install something against that.
09:12:26 <dozer> thanks Igloo - grepping the code now
09:16:20 <dozer> found one, but that's not fixed the problem :(
09:17:37 <dozer> my foolishness - Module vs module
09:24:52 <psi`> did anyone ever get the following from their UMs: LOADPROG off (high)
09:25:25 <mux> I don't remember seeing that
09:25:31 <mux> when running what?
09:25:33 <glguy> psi`: I think that that means you are not setting yoru execution finger correct
09:25:35 <glguy> ly
09:25:38 <mux> codex? sandmark? what's inside the codex?
09:25:42 <psi`> mux: both
09:25:48 <psi`> I get it then it halts.
09:25:50 <glguy> for example, if you are incrementing the execution finger after you set it
09:25:51 <mux> in the self-check then
09:26:02 <mux> read um-spec.txt carefully!! :)
09:26:07 <psi`> glguy: ah, I am.
09:27:52 <glguy> mux: I didn't think that the um-spec.txt was very clear about if the execution finger should be incremented after LOADPROG
09:28:03 <glguy> it does state that it should be incrememnted after every operation
09:28:03 <mux> it is
09:28:12 <mux> I clearly remember reading about it
09:28:17 <mux> let me check
09:28:19 <psi`> I thought the same, glguy
09:28:39 <dcoutts> yip, pong
09:28:45 <SyntaxNinja> arjanoosting: OK I emailed the DAM
09:28:47 <glguy> "The execution finger is placed to indicate the platter of this array that is described by the offset given in C"
09:28:49 <mux>  Before this operator
09:28:49 <mux>   is discharged, the execution finger shall be advanced to the next
09:28:49 <mux>   platter, if any.
09:28:50 <glguy> but
09:28:56 <mux> that's clear enough to me
09:29:14 <glguy> before this operator is discharged the execution finger shall be advnaced to the next platter if any
09:29:17 <mux> before handling the next insn, you need to increment the execution finger
09:29:32 <glguy> so if discharged means executed, then its correct,but if it means completed..
09:29:38 <glguy> and advanced
09:29:41 <glguy> then its not
09:29:45 * dcoutts is back in .uk
09:29:52 <glguy> and since I didn't think that discharged was a techincal term
09:29:57 <glguy> it seems open to interpretation
09:30:00 <mux> at least, I interpreted it so that I needed to increment first, so it worked :-P
09:30:02 <glguy> (until sandmark complains)
09:30:20 * mux needs to finish the adventure game
09:30:38 <mux> I have a working keypad etc, but with the uploader/downloader it becomes nightmarish :)
09:30:59 <glguy> I did the keypad by hand
09:31:04 <glguy> and then I got to the outside world
09:31:14 <glguy> and realized what the actual challenge was
09:31:26 <glguy> mux: you know about the switch command... right :)
09:31:45 <yip> dcoutts: hi, do you have any news about the issues of ghci 6.6 and gtk2hs?
09:31:53 <mux> gl	what?!
09:31:56 <dcoutts> yip, yep
09:32:03 <yip> really? :D
09:32:07 <dcoutts> yip, darcs pull and it should all work
09:32:07 <mux> omg, there's some things I need to look apparently :p
09:32:13 <glguy> mux: help switch , in adventure, this allows you to ahve computer readable output
09:32:21 <dcoutts> yip, but you'll need to unrecord that one patch you added
09:32:31 <mux> I figured the real aim was to pilot the game through a program
09:32:34 <yip> dcoutts: when did this happen? i am using gtk2hs darcs from a few hours ago
09:32:36 <psi`> bah, my sandmark seems to go into an infinite loop before the stress test.
09:32:49 <mux> but if we need to pilot it with the BASIC thingie with roman numerals, omg
09:33:05 <glguy> mux: the goal is to write a program to solve it, but you can get the output in different formats
09:33:08 <dcoutts> yip, oh really? then something's borked
09:33:52 <dcoutts> yip, did you unrecord that one patch you added ?
09:34:07 <yip> dcoutts: i'm using a totally clean checkup
09:34:20 <yip> dcoutts: ghc 6.5 snapshot from yesterday
09:34:27 <yip> checkout even
09:34:29 <dcoutts> yip, ok, let me check
09:34:55 <dcoutts> yip, I mean the gtk2hs repo I mean, you added a patch that conflicts with the current repo
09:35:20 <dcoutts> yip, so did you unrecord that one? or did you do a fresh checkout of the gtk2hs repo ?
09:35:21 <yip> dcoutts: yeah, i deleted my repos, and did a fresh darcs get of gtk2hs a few hours ago
09:35:26 <dcoutts> ok
09:36:15 <glguy> Does anyone know of any Arrow-based parsers?
09:37:40 <Lemmih> @google parrows
09:37:41 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/PArrows/
09:37:41 <lambdabot> Title: PArrows
09:37:46 <dcoutts> glguy, yes, the uuparser stuff, though I don't think it uses arrow syntax
09:37:56 <glguy> reading now, thankyou
09:38:12 <glguy> I'm not too worried about the arrow syntax
09:39:07 <dozer> is there a type equivalent of $, so I could say "Maybe $ MyMonad foo" or should I just add brackets?
09:39:23 <glguy> dozer: You'll need parenthesis
09:39:43 <dozer> ok, bracketing away
09:42:09 <sjanssen> dozer: you can actually define a type synonym that works like $ with GHC extensions
09:42:13 <Igloo> dcoutts: I'm told there is a conditionals design for cabal sorted now - do you know where it is?
09:42:32 * dcoutts points inside his head
09:42:48 <Igloo> I see  :-)
09:42:54 <dcoutts> Igloo, it's mostly of described in a couple emails
09:43:09 <dcoutts> from more than a month ago, on cabal-devel
09:43:19 <dcoutts> I could/should write it up
09:43:43 <arjanoosting> SyntaxNinja: thanks! Maybe it will help
09:45:25 <dozer> @hoogle Maybe a -> (a -> b) -> Maybe b
09:45:26 <lambdabot> No matches, try a more general search
09:45:45 <SyntaxNinja> arjanoosting: keeping fingers crossed :)
09:45:58 <psi`> oh, my UM works now. I added if (dst != src) in the load operation :)
09:45:58 <SyntaxNinja> dcoutts: do it!
09:46:11 <dcoutts> SyntaxNinja, right'o.
09:46:22 <arjanoosting> SyntaxNinja: on both hands! :-)
09:46:50 <SyntaxNinja> arjanoosting: makes it hard to type, but it's worth it.
09:47:10 <dozer> @hoogle M a -> (a -> b) -> Maybe b
09:47:10 <lambdabot> No matches, try a more general search
09:47:26 <dozer> @hoogle M a -> (a -> b) -> M b
09:47:26 <lambdabot> No matches, try a more general search
09:47:40 <dozer> @hoogle m a -> (a -> b) -> m b
09:47:41 <integral> @type fmap
09:47:41 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
09:47:42 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
09:47:42 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
09:47:46 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
09:48:28 <sjanssen> dozer: use fmap or liftM
09:48:33 <sjanssen> @type liftM
09:48:34 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
09:55:20 <SyntaxNinja> dcoutts: so, are you not getting my emails?
09:56:04 <dcoutts> SyntaxNinja, I missed a couple because I wasn't checking one account when I was away and I think you sent to that one. Should be fine now.
09:56:27 <dcoutts> SyntaxNinja, in fact I'll probably get it now (after the 1500 other spam mails)
09:57:10 <SyntaxNinja> OK
09:57:48 <Bourbaki> moin
10:01:24 <Bourbaki> dons: ?
10:44:54 <dcoutts> yip, what goes wrong for you building gtk2hs ? it works fine for me here with ghc-6.5.20060917
10:50:31 <lispy> dons: what was our fix for Module 'Foreign.ForeignPtr' does not export 'finalizeForeignPtr'?
10:50:52 <lispy> oh, right i think we didn't fix this
10:51:01 <lispy> i think it turns out the ghc with visual haskell lacks that function
10:51:15 <lispy> shoot...i wanted to use fps
10:51:25 <glguy> I don't think dons has returned from the beach yet
10:51:28 <glguy> ?seen dons
10:51:29 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 4h 44m 52s ago.
10:51:32 <glguy> oh
10:51:33 <glguy> I'm wrong
10:52:24 <lispy> ah
10:56:07 <yip> dcoutts: it builds, but it doesn't work with ghci
10:56:31 <lispy> ah yup, i see an email in my inbox that says i've been down this road and discovered the same thing...no finalizeForeignPtr with visual haskell
10:56:42 <yip> dcoutts: *** Exception: user error (initGUI: Gtk2Hs does not currently support the threaded RTS
10:56:50 <dcoutts> yip, that's correct.
10:56:55 <deadbeef> all models featured on our site are at least 18 years of age
10:56:56 <yip> dcoutts: see http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/2/
10:57:00 <lambdabot> Title: Gtk2Hs » Blog Archive » Writing multi-threaded GUIs, http://tinyurl.com/j7dxw
10:57:10 <yip> dcoutts: Please relink your program without using the '-threaded' flag.)
10:57:24 <lispy> deadbeef: accidental paste? ;)
10:57:28 <deadbeef> haha
10:57:29 <deadbeef> yes
10:57:33 <dcoutts> yip, which is hard, since ghci is now linked with -threaded
10:57:59 <glguy> deadbeef: just doing a little research?
10:58:02 <yip> dcoutts: do you know why they changed ghci in this way?
10:58:22 <dcoutts> yip, various reasons
10:58:40 <x3m> anyone used hs-plugins in win?
10:58:53 <yip> dcoutts: :)
10:59:22 <lispy> so, is it possible to upgrade my Foreign module without installing a new ghc?
11:04:09 <dcoutts> lispy, no
11:05:07 <yip> dcoutts: that blog post mentions a possible fix for gtk2hs to allow support for -threaded. do you think i have a chance at implementing such a fix?
11:05:40 <dcoutts> yip, there is no fix for having it work with -threaded at the moment
11:05:59 <glguy> he's asking if it is reasonable for him to write that fix, i believe
11:07:30 <SamB> yip: good luck, is all I can say!
11:07:36 <SamB> I looked at it and it seems hard!
11:09:45 <dcoutts> yip, a fix needs serious work in the ghc runtime system, so you don't have much chance
11:09:49 <dcoutts> sadly :-(
11:10:30 * ndm cries about lack of threading
11:10:33 <SamB> unless you have what it takes (time, inclination, skill, and intermediate tasks) to master the RTS)
11:10:37 <SamB> er.
11:10:40 <SamB> s/)$//
11:10:48 <SamB> ndm: hi!
11:11:01 <ndm> SamB: hi, it seems i did commit your warnings patch by mistake :)
11:11:09 <SamB> ndm: true
11:11:21 <SamB> it isn't exactly the end of the world if people start heading those warnings...
11:11:27 <ndm> indeed
11:11:47 <ndm> i was going to leave it out til we were down to a reasonable number, but never mind
11:12:12 <SamB> I've been working on straightening out what things are supposed to be Ids
11:12:17 <SamB> (using a newtype)
11:12:21 <ndm> neat
11:12:28 <ndm> a good plan
11:12:45 <ndm> anotehr little tidy up you might want to hit at roughly the same time is converting massive tuples to records
11:13:00 <ndm> i started on it previously, but failed, mainly because there were no explicit type signatures
11:13:02 <SamB> I'd want to do those one at a time, I think...
11:13:12 <ndm> yeah, definately
11:13:43 <SamB> these pseudo-monads are going to need similar treatment
11:13:50 <SamB> oh, and I might hit Info even before that
11:13:59 <ndm> yep, those might be harder, since they are slightly more general than monads
11:14:18 <ndm> not for any good reason, just happened so, but will require a bit more massaging than just converting to >>= then to do
11:14:28 <ndm> anyway, fancy having commit access?
11:14:30 <SamB> anything with per-field comments is probably going to get priority ;-)
11:14:41 <SamB> oh, commit access?
11:14:44 <ndm> yep
11:14:48 <SamB> so I can break the build with the best of them?
11:14:52 <ndm> indeed :)
11:15:04 <SamB> good thing we have those buildbots
11:15:06 <ndm> although still send anything you're not entirely sure on via the mailing list
11:15:12 <ndm> yep, they save the day loads of times!
11:15:31 <ndm> but just typesig cleanups, and anything which is just a refactoring, commit directly
11:15:42 <SamB> okay
11:15:49 <ndm> oh, and anything related to Dynamic via Tom/the mailing list, since thats massively complex
11:15:53 <ndm> do you have a public key?
11:15:59 <SamB> mmm
11:16:03 <SamB> yes
11:16:08 <ndm> send it to me
11:16:15 <lispy> dcoutts: hmm...that's not the answer i wanted :)
11:16:15 <SamB> SSH?
11:16:30 <ndm> it should say ssh-dsa or something at the beginning
11:16:34 <ndm> so yeah, i guess ssh
11:16:52 <SamB> okay, I figured you probably meant that rather than GPG
11:16:55 <ndm> will take about a week to do, since we've only just moved to haskell.org, and are still ironing out teething problems
11:17:11 <ndm> i know nearly nothing about these keys and such, keep getting people over to help me :)
11:17:25 <psi> Sam's message on the UMIX system is cute. "PS what is a monad"
11:17:37 <glguy> i noticed that too
11:18:18 <SamB> okay, so the one that says ssh-dss at the beginning?
11:18:30 <ndm> yeah, that sounds right
11:18:55 <glguy> the one that ends in .pub, not the id_dsa :)
11:19:16 <ndm> yep, indeed, ssh-dss is what the others have
11:20:19 <ndm> SamB: received, will set it up once we've got over the teething problems - need some feedback from Simon first - will mail you once its done
11:20:20 <SamB> glguy: yes I know not to send my private key, which is helpfully in a non-textual format
11:20:37 <SamB> or, wait, no
11:20:45 <SamB> but it says PRIVATE at the top
11:20:52 <SamB> and at the bottom
11:21:30 <SamB> what is the ~/.ssh/identity file?
11:21:36 <SamB> thats the one that is in binary, anyways
11:21:49 * glguy doesn't have a binary ssh-key
11:22:02 <SamB> must be some old thing
11:22:06 * weitzman tried having one, but the server he uses wouldn't allow it
11:22:23 <dcoutts> lispy, heh, sorry. :-). the base package is tied very closely to ghc itself.
11:22:25 <glguy> SamB: identity is SSH-version1
11:22:29 <SamB> ah
11:22:59 <glguy> id_dsa is the way of the future :-p
11:23:02 <SamB> so what is with having id_rsa and id_dsa?
11:23:11 <glguy> dsa and rsa are different algorithms
11:23:20 <weitzman> dsa is a signature-only algo
11:23:33 <SamB> so what is the rsa one good for?
11:23:39 <weitzman> It can sign or encrypt
11:23:41 <glguy> it used to be stronger
11:23:49 <glguy> also, it used to be under patent
11:24:01 <glguy> dsa is faster
11:24:31 <weitzman> DSA lets you hide encrypted information in your signature, if you're into that kind of thing
11:24:41 <SamB> why would you want to use your private key to encrypt and give attackers a go at known-text attacks?
11:24:43 <glguy> dsa had some flaws if specific parameters were used (making it easy to crack)
11:25:05 <glguy> SamB: You don't encrypt with a private key...
11:25:09 <glguy> you sign with one
11:25:31 <SamB> oh, so, flaws in old dsa implementations is the only reason?
11:25:41 <glguy> rsa was around first
11:26:07 <glguy> dsa was so that people wouldn't have to use rsa, but the original dsa key gens had flaws
11:26:19 <SamB> ah
11:26:51 <weitzman> Crypto algorithms are having it touch lately
11:27:01 <weitzman> Is there any hash algorithm that hasn't been partially broken?
11:27:07 <weitzman> *tough
11:27:35 <glguy> sha-256 is doing alright, isn't it?
11:27:53 <musasabi> RIPE-MD family might be good if you are concerned about SHA.
11:27:56 <weitzman> I guess if you stick a high-enough number after any of them, they're good
11:28:13 <dwm> I'm having an import cycle problem. I have A importing B, B imports C, C imports A. And now I need some function from C in A.
11:28:51 <dwm> And ghc is complaining.
11:29:14 <glguy> dwm: can you refactor the shared functions into a module D?
11:29:22 <glguy> that C and A both depend on?
11:29:57 <dwm> Not sure, just started looking at this source a couple days ago (darcs).
11:30:07 <dwm> But probably given enough analysis.
11:30:17 <dwm> That's the way this stuff is resolved, I take it.
11:30:26 <marcot> Hello. I'm trying to select with hdbc, and retrieve the data with fetchRow, but it's always returning nothing.
11:31:02 <glguy> I think that circular dependencies in modules are an indicator that your modules are too tightly bound..
11:31:24 <marcot> When I go into the database and run the same query it returns the results.
11:31:33 <dmhouse> glguy: I run into circular dependencies quite frequently. I probably over-modularise, though.
11:32:49 <weitzman> Hey, in a lazy language it might be possible to gracefully load code with circular dependencies
11:32:58 <weitzman> That's different
11:33:07 <SamB> you can do it in C too!
11:33:26 <weitzman> I'm thinking of global variable type stuff
11:33:38 <weitzman> In C you can evaluate functions in global varaibles
11:33:44 <weitzman> *can't
11:33:52 <weitzman> Which I've always found annoying
11:33:57 <SamB> oh, those don't count as graceful in lazy languages though
11:34:10 <SamB> global bindings, sure...
11:34:28 <weitzman> I'm thinking of a sad experience I once had trying to use someone's DSL that was embedded horribly into Java
11:34:46 <weitzman> And some field ended up circularly-referencing itself as null
11:35:13 * yip doesn't have what it takes to master the RTS :'(
11:36:40 <weitzman> But you could have two Haskell expressions in separate modules reference each other without arbitrarily having one load first and calling the other null
11:37:41 <glguy> but if the modules are that tightly bound, why are they separate modules?
11:37:49 <marcot> Lemmih: do you know what it possibly could be?
11:38:20 <marcot> ?paste
11:38:20 <lambdabot> http://paste.lisp.org/new/haskell
11:38:40 <weitzman> Depending on the language you're using, a circular reference might be a good idea
11:39:17 <weitzman> For example, in Java you can say "string".match("regular expression")
11:39:31 <lisppaste2> marcot pasted "PSQL and GHCi" at http://paste.lisp.org/display/27223
11:39:37 <weitzman> Which is just convenient, even if you now have strings and regular expressions mutually aware of each other
11:39:39 <marcot> Am I doing something wrong?
11:40:14 <weitzman> (except technically regular expressions work on CharSequence, but you could have CharSequence.match() if you really wanted)
11:42:38 <weitzman> In Java is usually considered acceptable to have circular references within packages but not between packages. I guess in Haskell you would have to put the entire package onto a single module
11:43:08 <wolverian> what's the nice looking l-system application in haskell?
11:43:16 <wolverian> (I think it wasn't haskls)
11:46:25 <glguy> weitzman: "string".match(regex) is just bad design... shouldn't it be regex.match("string")?
11:47:11 <Lemmih> marcot: You have to execute the statement.
11:47:51 <Lemmih> marcot: Place an 'execute statement' before you fetch the row and you should be fine.
11:48:11 <marcot> Lemmih: thanks.
11:48:17 <marcot> It worked fine.
11:48:21 <Lemmih> marcot: You can also use 'quickQuery' which will prepare and execute the query for you.
11:48:32 <dmhouse> glguy: depends how you look at things.
11:48:43 <Lemmih> @seen Cosmicray
11:48:44 <lambdabot> I saw Cosmicray leaving #haskell-blah, #darcs and #haskell 9d 21h 12m 45s ago, and .
11:49:06 <dmhouse> glguy: I'd say string.match(regex), as you're matching the string with the regex, but it works conceptually the other way around too. Personal preference.
11:49:36 <glguy> "string".match(regex) means that you put regex logic into the strign implementation, which has nothing to do with regexs
11:50:52 <glguy> similar to doing something like "string".sendOnTcpSocket(socket)
11:58:13 <dozer> http://www.rafb.net/paste/results/3cUlgt12.html
11:58:28 <dozer> I've been stairing at this for ages now and can't figure out what is wrong arround line 22
11:59:21 <dylan> glguy: what about ",".join(["foo", "bar"])? ;)
11:59:57 <glguy> dozer: should like 22: prj nxt be Just (prj nxt)?
12:00:12 <glguy> dozer: or rather return (prj nxt)?
12:00:49 <glguy> hmm, nvm, that just loops back in
12:00:53 <glguy> OH
12:01:02 <glguy> line 23 can't be there
12:01:12 <dozer> glguy: no - prj is in the current monad
12:01:12 <glguy> bah
12:01:14 <glguy> ignore me
12:01:24 <glguy> I'm still coming to grips with what your code is doing :)
12:01:52 <glguy> what does "Runcible" mean?
12:02:09 <dozer> it is the name of our AI rules language
12:02:28 <dozer> for manipulating OWL
12:02:55 <dozer> unfortunately, I seem to be a rubbish haskell programmer :(
12:09:45 * SamB wonders how to push to the Yhc repo?
12:10:30 * Lemmih puts his money on 'darcs push'.
12:10:41 * Igloo backs 'darcs send'
12:12:08 <SamB> well, what would the path be?
12:14:09 <mux> heh, the ANSI mode for the adventure game is cute
12:17:01 <psi> hehe, I haven't found that yet.
12:17:57 <Uvanta> hi everyone
12:18:21 <psi> hi Uvanta
12:18:39 <VolvoQ> hi Uvanta and psi
12:18:51 <Uvanta> it's been really a long time since last time i visited here with an awkward nickname, Gs30ng
12:18:59 <dcoutts> SyntaxNinja, I could do with your opinion on the meaning of cc-options and ghc-options.
12:19:22 <dcoutts> SyntaxNinja, we have an issue in the network package where it needs -DCALLCONV=ccall to be defined
12:20:06 <dcoutts> SyntaxNinja, it's not clear if that should be added in cc-options or ghc-options. It doesn't get passed to cpphs/ghc-E if it's added in cc-options. do you think it should ?
12:20:16 <Uvanta> Haskell recalled me about how cool it is and now i'm running GHCi
12:20:43 * SamB has type errors so impenetrable, he needs to use *two* compilers to figure them out
12:20:54 <dcoutts> SyntaxNinja, cc-options is usually for gcc flags right? and not all gcc flags can be passed to cpp, so we'd have to filter just the -D* flags. ugly.
12:21:29 <SamB> shouldn't there just be a cpp-options field?
12:21:54 <Uvanta> and i feel a little bit embarrassed with the way of GHCi, not allowing some expressions like "inc x where inc = (+ 1)" which was allowed in Hugs iirc
12:22:13 <Uvanta> i should do it with "let ~ in"
12:22:28 <Uvanta> like, "let inc = (+ 1) in inc x"
12:23:06 <SamB> like CPPFLAGS for make
12:23:30 <Uvanta> is this a difference of policy(or something like that) between GHC and Hugs?
12:23:58 <SamB> Uvanta: I didn't know you could do that in Hugs...
12:24:25 <SamB> I notice hugs doesn't catch trivial infinite loops like GHC does
12:25:16 <Uvanta> oh... then i actually didn't "iirc"
12:25:24 <dcoutts> SyntaxNinja, this is the issue that's causing problems for some ghc-extralibs packages
12:28:20 <Uvanta> SamB //
12:28:22 <Uvanta> Hugs> inc 3 where inc = (1 +)
12:28:22 <Uvanta> 4
12:30:10 <Uvanta> this doesn't work with GHC
12:30:19 <SamB> Uvanta: yes I know
12:30:26 <SamB> who knows why
12:30:33 <SamB> but you cant do:
12:30:34 <xerox> Uvanta: this is because <foo> where <bar> is not an expression.
12:30:42 <SamB> Prelude> let x = 1
12:30:48 <SamB> in hugs, either, so...
12:31:13 <shapr> ?users
12:31:18 <SamB> to each his own REPL extensions?
12:31:26 <shapr> SyntaxNinja: Did you send me a postcard?
12:31:30 <lambdabot> Maximum users seen in #haskell: 241, currently: 219 (90.9%), active: 37 (16.9%)
12:32:11 <Uvanta> xerox // that's shocking!
12:32:30 <Uvanta> i thought both let~in and where is syntactic sugars in same domain
12:32:52 <xerox> Uvanta: check the online report for reference.
12:33:56 <Uvanta> and actually both of them can be used similarly in Haskell programming, so i just believed them to be same ... i was a fool at all the time.
12:36:31 <Uvanta> SamB // you mean Hugs computes "inc 3 where inc = (1 +)" depending on its own extensions?
12:37:19 <Uvanta> then what if ... there's no extension loaded and only Prelude is there, "inc 3 where inc = (1 +)" will cause an error in Hugs, or something like that?
12:38:56 <xerox> Uvanta: the difference between Hugs and GHCi, as I can see it with the data you gathered, is that hugs treats interactive statements as top-level expressions, while GHCi as expressions (you can think of the GHCi prompt as an interactive `do' block.)
12:41:40 <Uvanta> Erm, then ... please forgive my stupid question, not having read the Haskell 98 report, since i'm not so good at English, but isn't there much mention about how should it be command-line-interactively interpreted, in Haskell 98?
12:42:31 <Uvanta> ... and that's the reason why GHCi and Hugs treat same expression in different way?
12:47:35 <Lemmih> Uvanta: Yes, the Haskell98 report doesn't mention how interactive environments should behave.
12:48:22 <Uvanta> Thanks for information
12:51:16 <fasta> Found another inconsistency in Haskell: a (Just b) = b;a = id
12:51:54 <Uvanta> I'm just looking up about Haskell, since i've been informed about the regional seminar on "Practical Functional Programming" scheduled in October 14
12:51:55 <glguy> Uvanta: your where example doesn't work because you can't say: inc 3 where inc = (1+), but you can say let f = inc 3 where inc =(1+) in f
12:52:24 <glguy> fasta: care to elaborate?
12:52:34 <Uvanta> ?!?! that's something i didn't even think about
12:52:36 <lambdabot> Unknown command, try @list
12:52:47 <fasta> glguy: just try it, the number of arguments don't match up.
12:53:02 <glguy> Uvanta: where operates on a function binding, not the toplevel
12:53:20 <fasta> glguy: while I can see it's correct, I think they made the choice that it's probably a programmer error.
12:53:25 <glguy> fasta: try what specifically?
12:53:36 <Uvanta> glguy // you mean i can use 'where' only with defining functions?
12:53:39 <fasta> Put this in a module: a (Just b) = b;a = id
12:54:29 <emu> > let a (Just b) = b; a = id in a (Just 1)
12:54:31 <lambdabot>    Varying number of arguments for function `a'
12:54:31 <lambdabot>   In the definition of `q...
12:54:37 <glguy> fasta: you can't define "a" like that
12:54:48 <fasta> glguy: I know, but that's inconsistent.
12:54:58 <fasta> glguy: it's Haskell 98, though.
12:55:03 <glguy> fasta: you should not be allowed to define "a" like that
12:55:23 <glguy> fasta: link me to the part of haskell98 that allows for that
12:55:26 <fasta> glguy: you could debate that. I will not now.
12:55:38 <fasta> glguy: It's Haskell 98 that it's not allowed.
12:55:52 <emu> hmm, how can you prove the consistency of haskell using a logical system less powerful than haskell?
12:55:53 <glguy> for the very reason that lambdabot told you
12:56:42 <fasta> emu: as there do not exist ultimate proofs, you can't really.
12:56:49 <SamB> emu: tis impossible!
12:56:53 <emu> woohoo
12:56:59 <SamB> or, well, maybe not.
12:57:03 <emu> yea, i know, trick question
12:57:05 <SamB> but it won't tell you much.
12:57:14 <SamB> one of those two!
12:57:39 <SamB> the sort of consistency referred to above is a subjective kind anyway
12:57:46 <emu> in interpretation
12:58:46 <fasta> SamB: right
12:59:11 <fasta> I know it's consistent with something else.
12:59:16 <glguy> fasta: your example isn't consitent in the type of "a"
12:59:43 <fasta> glguy: there's nothing wrong with the type.
13:00:27 <SamB> fasta: sure there is!
13:00:32 <glguy> oh well... seems like a lousy example to me, and like you said, we don't need to argue ti now
13:00:37 <SamB> oh, wait, yours...
13:00:47 <SamB> fasta: where did you give an example?
13:00:50 <SamB> > let a (Just b) = b; a = id in a (Just 1)
13:00:51 <lambdabot>    Varying number of arguments for function `a'
13:00:51 <lambdabot>   In the definition of `c...
13:00:58 <fasta> a (Just b) = b;a = id
13:00:59 <SamB> > let a (Just b) = b; a x = id x in a (Just 1)
13:01:00 <lambdabot>    Occurs check: cannot construct the infinite type: a = Maybe a
13:01:00 <lambdabot>    Expe...
13:01:38 <fasta> Ehh, ok, maybe not...
13:02:13 <fasta> Oh, well, the type checker is not smart enough. ;)
13:02:23 <fasta> Eh, not
13:02:35 <SamB> fasta: heh
13:02:43 <SamB> the type checker knows its business!
13:02:44 <fasta> SamB: you had me there for three seconds ;)
13:03:04 <glguy> fasta: your function "a" attempts to use an infinitely recursive type
13:05:24 <fasta> a (Just _) = Nothing
13:05:25 <fasta> a x = id x
13:05:41 * fasta remembers to test his example first next time :)
13:06:03 <emu> you're using it like a sum type, without having a sum type
13:07:10 <xerox> fasta: id x = x.
13:07:12 <fasta> I just _love_ this error message: *** Exception: Prelude.(!!): index too large
13:07:25 <xerox> ?quote Cale
13:07:25 <emu> Integer index?
13:07:26 <lambdabot>  ... if sections were allowed at the type level ...
13:07:28 <xerox> ?quote Cale
13:07:29 <lambdabot>  [more monad clarity] monads as food gathering in post-industrial America
13:07:32 <xerox> ?quote Cale
13:07:33 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
13:07:37 <xerox> ^- fasta
13:08:00 <glguy> ?type (!!1)
13:08:03 <lambdabot> forall a. [a] -> a
13:08:08 <glguy> shock! horror!
13:08:18 <glguy> \o/
13:08:18 <fasta> xerox: yes, I am sure I am not the first.
13:08:47 <fasta> Using list size indexed types is a bit over the top for me
13:09:02 <fasta> Maybe next year :)
13:09:24 <xerox> Maybe in Epigram.
13:09:38 <glguy> > head []
13:09:40 <lambdabot>  Add a type signature
13:09:41 <glguy> ?type head
13:09:43 <lambdabot> forall a. [a] -> a
13:09:47 <glguy> \o/
13:10:00 <glguy> ?hoogle [a] -> a
13:10:02 <lambdabot> Prelude.head :: [a] -> a
13:10:02 <lambdabot> Prelude.last :: [a] -> a
13:10:02 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
13:10:10 <fasta> Do you think programming in Epigram is a good idea?
13:10:55 <fasta> They have a pay as you go model, IIRC, which appeals to me.
13:12:07 <glguy> in a language like epigram, how to you read numbers in from the console
13:12:15 <glguy> since each number has a different type
13:12:31 <fasta> I am channel op in #epigram :)
13:12:49 <glguy> good then you can help me to understand easily :)
13:13:20 <SamB> hmm
13:13:31 <fasta> glguy: I am a channel op since there was nobody in #epigram. :)
13:13:48 <SamB> I'm having trouble with one of the renameDecls function in Yhc's Rename module...
13:13:56 <glguy> with great power comes great responsibility
13:14:15 <SamB> I can't get figure out where this type error is coming from...
13:14:29 <xerox> fasta: Freenode has some kind of (loosely enforced?) policy about #channels, i.e. they ought to be "official", leaving ##channels for "non official" groups.
13:14:45 <SamB> but this one is supposedly official
13:14:59 <fasta> xerox: I know
13:15:00 <SamB> and really it is about as official as anything but the report is, I suppose
13:15:01 <emu> what makes it official
13:15:17 <SamB> (and addendums, etc.)
13:15:18 <glguy> sanctioned by the gods
13:15:26 <SamB> well, its linked from the site right?
13:15:33 <emu> the site is a wiki
13:15:40 <fasta> I know everyone in #freebsd bitched about the change to ##freebsd
13:15:54 <fasta> I also know that I don't care about those remarks :)
13:16:39 <emu> so ##haskell is the unofficial, alternative haskell community?
13:18:00 <SimonRC> I think the idea is that, say, Guido can have absolute power in #python, but might be just another user in ##python, etc
13:18:31 <glguy> power corrupts but absolute power is kind of fun
13:18:33 <fasta> uhm, shouldn't any call to error kill your program?
13:18:47 <fasta> Because in my code it doesn't happen.
13:18:49 <glguy> fasta: only if it is evaluated
13:19:01 <glguy> > length [error "not evaluated"]
13:19:05 <lambdabot>  1
13:19:09 <fasta> glguy: the Exception is being shown
13:19:15 <fasta> glguy: er Exceptions
13:19:20 <fasta> er are
13:19:28 <glguy> ah, well exceptions can be caught, are you doing that?
13:19:32 <fasta> glguy: no
13:19:33 <SimonRC> Exceptions and errors are differnt things, aren;t they?
13:19:48 <fasta> SimonRC: a call to error raises an exception, I think.
13:20:02 <SimonRC> confusing
13:20:04 <fasta> SimonRC: or it only prints that it's an exception.
13:20:14 <fasta> SimonRC: while in fact the exception system is unrelated.
13:20:23 <fasta> SimonRC: indeed confusing
13:21:00 <glguy> has anyone here read the paper: Arrows, like Monads, are Monoids?
13:25:07 <fasta> Heh, I had two of by one errors :)
13:25:10 <fasta> er off
13:27:44 <SamB> it would be really nasty if you had two of those in different directions such that something usually worked, but sometimes crashed horribly...
13:27:50 <SyntaxNinja> shapr: no, didn't send you a post card. sorry.  probably ralf :)
13:29:45 <fasta> SimonRC: directions?
13:29:52 <fasta> SamB: directions?
13:31:14 <glguy> ?tell Cale I was reading through http://apocalypse.org/~antony/work/pubs/genuinely-functional-guis.pdf and wondering if the first examples with the mouse reminded me of last nights "discussion"
13:31:14 <lambdabot> Consider it noted.
13:32:11 <SamB> fasta: you know, one of the +1 variety and one of the -1 variety
13:32:22 <shapr> SyntaxNinja: Oh, that would explain it.
13:32:43 <fasta> SamB: yes, but in the same list would be a bit hard to realize?
13:33:54 <shapr> SyntaxNinja: Especially since what I got doesn't even look like a postcard, and has no text. It appears to be a piece of cardstock where someone drew one of those artist's woodel pose models and added my address and stamps.
13:34:08 <shapr> glguy: I read that paper.
13:35:38 * glguy finds Wadler's paper on Monad Comprehensions quite fun and is inspired to pick up edwardk's work in adding the -fmonadcomprehension flag
13:36:01 <fasta> Why did they drop it in the first place?
13:36:10 <glguy> to make it easier on the newbs
13:36:14 <shapr> newbie confusion
13:36:39 * fasta runs ghc --no-n00b
13:36:59 * glguy dreams of arithmeticmean xs = [a / b | a <- sum, b <- genericLength]
13:37:08 <glguy> errr s/xs//
13:39:37 <SyntaxNinja> shapr: yeah, that's ralf.
13:41:15 <musasabi> > liftM2 (/) sum genericLength [1..10]
13:41:16 <lambdabot>  5.5
13:41:22 <glguy> yep
13:41:27 <damkor> I hace a question about monads, it's an Alex related question
13:41:35 <damkor> I have a question about monads, it's an Alex related question
13:41:41 <shapr> SyntaxNinja: I forgot to give you your postcard while I was there :-(
13:42:03 <shapr> damkor: You don't have to repeat the whole line to fix one letter.. :-)
13:42:10 <damkor> ok, sorry
13:42:19 <glguy> monad comprehension syntax seems more declarative than do-notation
13:42:28 <shapr> hola damkor, como est as?
13:42:35 <shapr> damkor: But really, what's your question?
13:42:59 <damkor> (have we met before?) ok, i'll get to the point
13:43:04 <shapr> I still think the Spanish prefix notation for  and  just totally roxx.
13:43:06 <damkor> when using the monad wapper
13:43:10 <SyntaxNinja> shapr: send it :)
13:43:45 <damkor> alex creates a monad named Alex, that looks like Alex a = Alex (InputState -> (InputState,a))
13:44:22 <damkor> at a given point, it does something like tok <- getInputMonad (or something like that),
13:44:37 <SamB> damkor: Alex doesn't actually create it
13:44:44 <SamB> it just copies that from some file
13:45:18 <SamB> anyway... where does the question part come in?
13:45:54 <damkor> yes, I know. Anyway, my point is that the function getInput is supposed to return an AlexInput
13:46:10 <damkor> how is that possible? (that's the question)
13:47:00 <damkor> getInput is a function that returns an function
13:47:13 <damkor> (inside the alex monad, i think)
13:47:32 <SamB> what does AlexInput look like?
13:48:53 <damkor> type AlexInput = (InputPosn, Char, String)
13:49:39 <SamB> hmm
13:49:40 <damkor> well, maybe I'm doing everything the wrong-and-complicated way
13:50:02 <damkor> I was just trying to get alex not to stop at the first lexical error
13:50:06 <SamB> oh
13:50:16 <damkor> I don't want it to return more that one error message
13:50:31 <damkor> sorry, I said just the opposite that I wanted to say
13:50:42 <SamB> you do want it to return more than one error message?
13:50:50 <damkor> that's right
13:51:08 <SamB> if you can do that...
13:51:11 <SamB> it will be hard.
13:51:19 <SamB> or not useful.
13:51:32 <damkor> well, the fact is that I already did it
13:51:36 <SamB> oh?
13:51:43 <damkor> then I realized i should have used a writer monad
13:51:52 <SamB> what did you do?
13:52:54 <damkor> I changed the bind definition, so that it concatenates the error messages
13:52:54 <SamB> anyway, I think Alex docs explain how to use a Monad of your own...
13:53:16 <damkor> not exactly, the docs just give you a starting point
13:53:51 <damkor> but I couldn't find any example that looked like this thing I want to do
13:53:55 <SamB> where by "explain" I mean they show what you have to tell Alex and what Alex will expect of your Monad
13:54:36 <damkor> they only say: You have to declare this data type, this two functions, then you do all the rest of it on your own
13:54:45 <damkor> you can redefine some basic properties of the monad
13:54:59 <SamB> the rest is practicality ;-)
13:55:04 <damkor> but that didn't seem to be enough in my case
13:55:14 <damkor> and i had to change some other functions
13:55:23 <damkor> so not to lose the error messages
13:55:38 <damkor> the problem is that, if you rewrite these other functions
13:55:55 <damkor> you have to tell alex not to use any wrapper at all
13:56:00 <SamB> oh sure
13:56:05 <SamB> thats quite normal
13:56:09 <damkor> because the functions it includes collide with yours
13:56:12 <SamB> a mature lexer won't use a wrapper
13:56:24 <SamB> unless it is very lucky
13:56:28 <damkor> : )
13:57:06 <damkor> do you know any web site that goes deeper in using alex+happy (glr if possible) combining monads to parse and scan
13:57:09 <damkor> ?
13:57:12 <SamB> web site?
13:57:15 <SamB> no.
13:57:15 <damkor> doc
13:57:23 <SamB> I'd say "look at programs"
13:57:42 <SamB> actually, I think I will say it
13:57:45 <SamB> look at programs
13:57:58 <damkor> :) most of the programs I've found do use happy, but they don't use alex
13:58:04 <SamB> oh?
13:58:19 <SamB> what is GLR?
13:58:26 <damkor> Generalized LR
13:58:44 <damkor> it's kinda useful when parsing ambiguous grammars
13:58:59 <Uvanta> help me guys. first of all, an encouraging news, which is already mentioned but i'll say again for you who missed it. a seminar on "Practical Functional Programming" featuring Haskell is scheduled on October 14 in here, South Korea.
13:59:00 <SamB> oh, happy feature isn't it?
13:59:13 <damkor> it generates a forest intead of a unique parsing tree, and you can get several parsing trees for that forest
13:59:35 <SamB> I thimk the Happy docs should go into more detail on that...
13:59:41 <SamB> it sounded WAY too magical
14:00:04 <astrolabe> Sounds good uvanta
14:00:11 <Lemmih> Uvanta: Neat.
14:00:15 <glguy> hmmm, steam is hot
14:00:21 <Uvanta> This is the first time seminar|conference|offline meeting on FP-related topic in here Korea
14:00:25 <SamB> glguy: yes, this is normal
14:01:08 <glguy> and when it condenses on your hand, all the energy that was used to change states originally is released... on your hand
14:01:29 <damkor> it's great I live that close to Korea that I can get there on foot
14:01:34 <Uvanta> and the manager of this seminar, who first suggested it and now collecting ideas for it, needs help
14:02:06 <damkor> (just joking, no offense)
14:02:52 <Uvanta> i think anybody who have attended that kinds of stuffs can help him(and consequently me who will attend it and learn more about FP) by giving him advice
14:03:25 <SamB> has he emailed the haskell or haskell-cafe list?
14:05:18 <Uvanta> SamB // the plan of the seminar is yet being discussed and we haven't even decided where to hold it
14:05:35 <SamB> Uvanta: can't help you with that one ;-)
14:06:04 <Uvanta> well, True. :) in this case i want ...
14:07:02 <Uvanta> well, for example, is there any small-scaled seminar on this topic that we can, say, benchmark?
14:07:20 * SamB doesn't know about such things
14:07:37 * SamB has yet to meet a Haskell user
14:07:58 <astrolabe> I've seen some power point slides around somewhere
14:08:31 <musasabi> you might want to ask the people respobsible for Haskell workshop @ ICFP.
14:09:00 <xerox> astrolabe: I've got a paper for you, well, maybe you are interested.
14:09:01 <astrolabe> http://research.microsoft.com/~simonpj/Papers/haskell-retrospective/index.htm
14:09:03 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell, http://tinyurl.com/jlg6h
14:09:15 <shapr> You should also look for any info on the CUFP meetings.
14:09:21 <shapr> "Commercial Users of Functional Programming"
14:09:22 <xerox> astrolabe: check out the phd thesis of the Google guy organizing the BADMath :)
14:09:45 <xerox> (Bay Area Discrete Math Day.)
14:10:33 <shapr> A seminar named "Practical Functional Programming" may also want to mention the companies that are making money with mainly from Haskell such as Galois, Aetion, BlueSpec, and indirectly such as Linspire, Credit Suisse, Intel, Xilinx, etc
14:11:40 <musasabi> and if it is about general FP then mentioning Erlang might make sense
14:12:21 <shapr> You may want to ask John Hughes for permission to reprint "Why Functional Programming Matters" for the attendees who don't have any FP knowledge.
14:12:57 <shapr> Good point, Erlang is probably the most profitable FP language.
14:13:34 <dbremner> shapr - hi
14:13:39 <shapr> OCaml has lots of ethusiastic users in the scientific and commercial communities, though it probably isn't used for as much commercial programming as Erlang.
14:13:46 <shapr> Hiya dbremner, how's life?
14:13:59 <dbremner> shapr - up and down, yourself?
14:14:10 <shapr> dbremner: Exactly that.
14:14:22 <Uvanta> shapr // that paper is quite nice, unless we don't need the infernal process of English-Korean translation
14:14:43 <shapr> Uvanta: Can you give us more info on the seminar/meeting? Is there a call for papers or other general outline?
14:14:57 <araujo> hi hi lambda'ers!!
14:15:30 <Uvanta> shapr // there is, but you'll probably don't want that, when it is all in Korean language.
14:15:50 <shapr> That's true, I cannot read Korean.
14:15:54 <dbremner> shapr - have you heard about this? www.netflixprize.com
14:16:12 <shapr> I can handle English, Swedish, some French, some German and a tiny bit of Dutch.
14:16:45 <shapr> dbremner: Oh that's cool!
14:19:26 <x3m> anyone used hs-plugins in win?
14:22:05 <dbremner> Uvanta - there's this Korean functional language. http://ropas.snu.ac.kr/n/
14:22:39 <Uvanta> oh my god
14:22:41 <Uvanta> ropas
14:22:55 <Uvanta> that site is famous for Korean programmers as a hell
14:23:19 <lisppaste2> zeeeee pasted "Is three a cleaner way to write this function?" at http://paste.lisp.org/display/27237
14:24:32 <Uvanta> containing many references for programming, with poor translation quality
14:24:36 <Uvanta> and being famous
14:24:57 <glguy> zeeeee: the last case statement could be: try1 `mplus` try2 `mplus` tryApply
14:25:02 <Uvanta> = being a black hole of search engines when programming-related topics are typed in Korean
14:25:13 <Uvanta> = begginer programmers visit there
14:25:17 <Uvanta> = frustrate
14:26:10 <Uvanta> = putting higher and higher barriers between experts and newbies
14:26:15 <Uvanta> for this, that site is famous
14:26:21 <chessguy> anybody familiar with the fudgets library?
14:27:28 <glguy> zeeeee: you there?
14:27:41 <shapr> hey Taral, how's code?
14:29:14 <chessguy> nobody's used fudgets?
14:31:29 <musasabi> fudgets is very old.
14:32:10 <zeeeee> glguy: sorry, i forgot that the thing auto-pastes to this channel
14:32:30 <xerox> lisppaste2: url
14:32:30 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:32:39 <chessguy> well, i'm trying to use some code which uses that library
14:32:40 <araujo> Uvanta, is that nML pure?
14:33:02 <Uvanta> araujo // pardon?
14:33:06 <chessguy> i'm not sure if it will work with hugs or not
14:33:15 <Taral> hey shapr
14:33:16 <araujo> Uvanta, if it is purely functional ....
14:33:16 * lispy revels in having Data.ByteString
14:33:19 <Taral> code is... not happening.
14:33:30 <glguy> zeeeee: oh, well, lots of your nested cases can be replaced with fmap and msum
14:33:31 <zeeeee> glguy: so the second way is probably better, right? even though it's longer, it seems 'cleaner' for some reason. i haven't learned about monads yet, but i'll look into mplus
14:33:34 <Taral> I keep trying to understand jhc and failing :)
14:33:37 <lispy> now i just need a version of parsec that understand data.bytestring
14:33:43 <zeeeee> glguy: what do you mean?
14:33:53 <lisppaste2> glguy annotated #27237 with "lots of fmap and msum" at http://paste.lisp.org/display/27237#1
14:34:04 <dcoutts> lispy, there are some about, nothing quite as full as parsec yet
14:34:32 <lispy> dcoutts: okay, i'll google it
14:34:46 <zeeeee> glguy: awesome
14:34:48 <lispy> dcoutts: i doubt i need full parsec
14:34:50 <zeeeee> glguy: thanks
14:35:00 <zeeeee> i'll have to read up on those now :)
14:35:11 <lispy> but parsing a 47mb file takes 15 minutes and 100+mb of ram, maybe i can cut that down
14:35:13 <lisppaste2> glguy annotated #27237 with "even better" at http://paste.lisp.org/display/27237#2
14:35:18 <Uvanta> araujo // sorry, i don't know much about nML, but if you want, i'll read that Korean documents, and tell you about it, so please wait
14:38:55 <Uvanta> araujo // doesn't seem like a purely functional lang. see http://ropas.snu.ac.kr/~kwang/320/01/nml-intro.pdf (which is in English)
14:38:58 <lambdabot> http://tinyurl.com/enyzn
14:39:50 <lispy> ?type (//)
14:39:52 <lambdabot> forall e i. (Ix i) => Array i e -> [(i, e)] -> Array i e
14:40:05 <lispy> Uvanta: i don't think araujo is an Array :)
14:42:19 <Uvanta> lispy // the suffix "//" is widely used in Korea when calling somebody else
14:42:37 <glguy> welcome to #haskell :)
14:43:19 <zeeeee> glguy: did you mean snd instead of second?
14:43:32 <SamB> Uvanta: we usually just use a ":"
14:43:33 <Uvanta> does "//" look awkward?
14:43:40 <glguy> > second (+1) (1,2)
14:43:42 <lambdabot>  (1,3)
14:43:45 <glguy> zeeeee: ^^
14:43:51 <SamB> Uvanta: I'm sure it looks nice in korean ;-)
14:43:53 <glguy> ?index second
14:43:54 <lambdabot> Control.Arrow
14:44:00 <glguy> zeeeee: ^^
14:44:13 <psi> > first (+1) (1,2)
14:44:14 <zeeeee> glguy: how did you check the program you wrote back to me so quickly? things like replaceVar had yet to be defined
14:44:15 <lambdabot>  (2,2)
14:44:31 <glguy> zeeeee: I didn't run ghc on it
14:44:32 <zeeeee> glguy: or did you not run it through haskell, and simply applied changes to it :)
14:44:34 <Uvanta> well, it's a suffix appears when a auto-complete a nickname
14:44:45 <zeeeee> glguy: i wish i could do that
14:44:53 <SamB> Uvanta: ah
14:44:59 <lispy> Uvanta: i just like to tease people, don't mind me :)
14:45:04 <glguy> zeeeee: I'm not making any guarentees that it is correct, but the spirit is
14:45:27 <lispy> dcoutts: you don't happen to have a link to a parser built on data.bytestring do you?
14:45:57 <dcoutts> lispy, xerox posted a url the other day
14:46:11 <dcoutts> I don't recall it myself
14:46:40 <glguy> w00t, ghc6.6rc1 finished building
14:46:44 <glguy> and it only took all day
14:46:48 <lispy> okay, i'll check the logs
14:46:49 <lispy> ?where logs
14:46:50 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
14:46:57 <xerox> What are you looking for?
14:47:19 <lispy> xerox: a parsec on top of data.bytestring
14:47:23 <xerox> http://darcs.haskell.org/~paolo/darcs/ByteStringParser/
14:47:24 <lispy> parsing large files here
14:47:26 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser, http://tinyurl.com/hyly7
14:47:30 <lispy> thanks!
14:47:40 <xerox> Hope it's enough :)  Patches are very welcome!
14:47:51 <SamB> lispy: not exactly Parsec, but it can do things at least!
14:48:04 <lispy> right
14:48:16 <lispy> i'll see how well i can mash it together
14:55:13 <lispy> xerox: i created a .cabal file and setup.lhs interested in a patch for those?
15:01:12 * shapr boings
15:01:14 <shapr> ?users
15:01:19 <lambdabot> Maximum users seen in #haskell: 241, currently: 217 (90.0%), active: 34 (15.7%)
15:01:55 * Lemmih is active from afar.
15:02:09 * shapr is far from active
15:02:16 <glguy> You know what's more fun that being popular?
15:02:20 <glguy> Learning to program!
15:03:01 * shapr luvs programming
15:03:20 <glguy> hear hear!
15:03:28 <lispy> ?yar!
15:03:29 <lambdabot> I'll keel haul ya fer that!
15:05:53 * Lemmih wonders why his kick-ass server can't serve more than 20 wiki pages/s.
15:07:02 <shapr> Lemmih: Should I stop uploading?
15:07:20 <Lemmih> shapr: No, keep it coming.
15:07:36 <Lemmih> PHP is the problem, me thinks.
15:07:46 <shapr> Seems likely. PHP is slow and insecure.
15:07:55 <lispy> Lemmih: maybe you need a web proxy thingy...
15:08:45 <lispy> i've heard the faster the webserver can stop handling a request the faster it will run...so you can place a 'proxy' between the server and the internet...the proxy has to deal with slow connections to clients and the real server is always finishing requests ASAP
15:09:00 <glguy> PHP ftl
15:09:05 <lispy> heh
15:09:10 <lispy> PHP--
15:09:26 <glguy> php is the visual basic of garbage languages
15:11:07 * glguy &
15:11:29 <shapr> hiya nanavati_ravi, how's code?
15:11:45 <Lemmih> shapr: Can Hope be used as a wiki and/or forum?
15:13:06 <shapr> Hope has a comment plugin that could probably be turned into a forum without much trouble.
15:14:33 <shapr> But I'd like to try writing a forum with HAppS
15:16:12 <zeeeee> hi all, i just discovered a new syntax goodie today: the @ sign for args. what is this called? where might i find more such features, short of trying to decipher the language reference? after consulting several tutorials, there was never any mention of this. (it was also hard to google)
15:16:58 <shapr> I call it naming part of the pattern match. I don't know the full name.
15:17:13 <shapr> Also, the language reference just isn't that scary when you have #haskell as a resource =)
15:17:56 <shapr> So my advice would be to read the language reference and implement programs that exercise each feature as much as possible.
15:18:04 <shapr> Whenever you run into problems, ask here on #haskell
15:20:14 <shapr> Lemmih: Only 800MB to go on the upload
15:20:29 <Lemmih> Yay!
15:34:01 <yip> holy shit c++ is verbose
15:34:17 <shapr> I've only looked at C++ source a few times.
15:34:21 <sjanssen> zeeeee: they're called "as patterns"
15:34:32 <shapr> Want to paste some c++ source and its matching haskell translation?
15:34:40 <sjanssen> yip: have you ever seen Java?
15:34:41 <sjanssen> @yow
15:34:42 <lambdabot> I'm a GENIUS!  I want to dispute sentence structure with SUSAN
15:34:42 <lambdabot> SONTAG!!
15:34:52 <yip> sjanssen: i stay away from java
15:35:01 <yip> sjanssen: but i'm using c++ now
15:36:44 <Uvanta> i'm now reading the pages you guys gave me, and thanks for your nice advice for the seminar
15:36:47 <Uvanta> bye everyone
15:39:21 <stepcut> do the standard GHC libraries have chroot ?
15:40:05 <Lemmih> I don't think so.
15:40:29 <stepcut> ok, I'll code one up and submit it to missingh :)
15:45:57 <Lemmih> Hiya SyntaxNinja.
15:46:10 <SyntaxNinja> hi Lemmih
16:04:57 <shapr> Well, I've seen fleeting interest in Haskell before, but that must be a record.
16:06:38 <Lemmih> (:
16:47:25 <SamB> hmm, how can I tell if I have an account on darcs.haskell.org?
16:47:58 <glguy> You could try logging in with your key :)
16:48:06 <SamB> glguy: but what username?
16:48:19 <Igloo> There are no accounts that look obviously like you
16:48:27 <SamB> okay
16:48:28 --- mode: Igloo set -o Igloo
16:48:43 <shapr> Why is Data.Map.lookup monadic?
16:48:53 <SamB> shapr: in case of failure
16:48:55 <SamB> for instance
16:48:55 <Igloo> It can fail
16:49:05 <shapr> oh
16:49:12 <Igloo> It used to return Maybe a
16:49:17 <SamB> > M.lookup M.empty 1 :: Maybe ()
16:49:18 <lambdabot>     add an instance declaration for (Num (Data.Map.Map (Data.Map.Map k a) ...
16:49:20 <SamB> hmm
16:49:27 <SamB> > M.lookup 1 M.empty :: Maybe ()
16:49:28 <lambdabot>  Nothing
16:49:39 <SamB> > M.lookup 1 M.empty :: [()]
16:49:40 <lambdabot>  []
16:49:53 <glguy> ?type M.lookup
16:49:55 <lambdabot> Couldn't find qualified module.
16:50:04 <glguy> ?type Data.Map.lookup
16:50:06 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
16:50:08 <shapr> Anyone know how to fix XEmacs errors like (11) (warning/warning) Error caught in `font-lock-pre-idle-hook': (error No such face haskell-default-face)  ?
16:50:10 <SamB> > M.lookup 1 M.empty :: (a->())
16:50:11 <lambdabot>  Add a type signature
16:50:16 <SamB> > M.lookup 1 M.empty :: (Bool->())
16:50:17 <lambdabot>  <Bool -> ()>
16:50:28 <SamB> > (M.lookup 1 M.empty :: (Bool->())) True
16:50:29 <lambdabot>  Exception: Data.Map.lookup: Key not found
16:50:50 <SamB> > M.lookup 1 M.empty :: Either String ()
16:50:51 <lambdabot>  Left "Data.Map.lookup: Key not found"
16:51:00 <SamB> @instances Monad
16:51:01 <glguy> so it uses fail?
16:51:01 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:51:08 <SamB> glguy: exactly!
16:51:46 <glguy> > M.lookup 1 M.empty :: State () ()
16:51:47 <lambdabot>  add an instance declaration for (Show (State () ()))
16:51:59 <glguy> > runState (M.lookup 1 M.empty :: State () ())
16:52:00 <lambdabot>  <() -> ((),())>
16:52:08 <SamB> so, the convenience of returning Maybe with the flexibility of returning Either (and more!)
16:52:29 <SamB> or something like that
16:53:11 <glguy> > M.lookup 1 M.empty :: IO ()
16:53:12 <lambdabot>  No IO allowed
16:53:16 <glguy> :-D
16:53:17 <SamB> heh
16:53:26 <SamB> no more cries of "hentai!"
16:53:57 <shapr> ?
16:54:17 <SamB> okay, okay, so she said "Pervert!"
16:54:34 * shapr blinks cluelessly and goes back to coding
16:54:56 <SamB> shapr: for a bried period the "No IO allowed" message was replaced with cries of "Pervert!"
16:55:01 <shapr> heh, ok
16:55:04 <SamB> er, s/bried/brief/
16:55:15 <carp> morning
16:55:24 <SamB> they tell me I'm messed up for thinking that made sense
16:55:33 <shapr> Goood morning Mistah Decorative Oriental Fishy!
16:55:48 <shapr> Oh Great Bottom Feeder! He who cleans our Streams!
16:55:53 <shapr> Aaanyway..
16:56:03 <lispy> how do i convert [Char] -> [Word8]?
16:56:14 * shapr used to know...
16:56:17 <lispy> i thought fromIntegral . ord, but that dosen't seem to be right
16:56:22 <glguy> ?hoogle Char -> Word8
16:56:24 <lambdabot> No matches, try a more general search
16:56:24 <shapr> I think GHC.Base has a cast.
16:56:43 <glguy> ?hoogle Char -> Int
16:56:44 <lambdabot> Char.digitToInt :: Char -> Int
16:56:44 <lambdabot> Char.ord :: Char -> Int
16:56:47 <SamB> toEnum . fromEnum!
16:56:57 <SamB> @type toEnum . fromEnum
16:56:58 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
16:57:18 <lispy> SamB: thanks
16:57:44 <SamB> though, probably fromIntegral . ord should work fine too
16:57:49 <SamB> @type fromIntegral . ord
16:57:50 <lambdabot> forall b. (Num b) => Char -> b
16:58:12 <SamB> (as long as you import Data.Char first)
16:58:50 <syntaxfree> is it possible to declare that every instance of Num is also an instance of some other class I'm defining?
16:59:14 <SamB> syntaxfree: ... there is no use in it without overlapping typeclasses
16:59:16 <carp> greetings from China
16:59:35 <SamB> er s/typeclasses/instances/
16:59:48 <SamB> probably you need undecidable ones too...
16:59:49 <syntaxfree> there's an example in Jones (1995) of a type class "Dual".
17:00:16 <Chinju> hey
17:01:03 <lisppaste2> syntaxfree pasted ""subclass" example" at http://paste.lisp.org/display/27243
17:01:03 <Botty> http://q-lang.sourceforge.net/about.html  not to be blasphemous, but from whats on that page Q has better syntax than haskell imho...
17:01:04 <lambdabot> Title: About Q
17:01:54 <syntaxfree> SamB: there it is.
17:01:56 <Chinju> I have a silly question
17:02:18 <Chinju> T just recently installed GHC on a new Windows computer
17:02:20 <syntaxfree> I have silly questions all the time, and most of the time I get great answers.
17:02:25 <syntaxfree> Shoot.
17:02:29 <Chinju> and I'm having difficulty making Ctrl+C work [I told you it was silly]
17:02:36 <Chinju> in GHCi, I mean
17:02:45 <syntaxfree> oh.
17:02:48 <Chinju> yeah
17:02:51 <Chinju> barely touching on Haskell at all
17:02:57 <syntaxfree> maybe you want rlwrap or something. I don't know if it works with Windows though.
17:03:02 <syntaxfree> @google rlwrap windows
17:03:05 <lambdabot> http://ftp.uni-kl.de/pub/windows/cygwin/release/rlwrap/
17:03:05 <lambdabot> Title: Index of /pub/windows/cygwin/release/rlwrap
17:03:11 <syntaxfree> @google rlwrap
17:03:15 <lambdabot> http://utopia.knoware.nl/~hlub/rlwrap/
17:03:15 <lambdabot> Title: rlwrap, Emacs midi-input and p5httpd
17:03:19 <shapr> Why doesn't Map have a Read instance?
17:03:23 <Chinju> what's rlwrap?
17:03:40 <Chinju> I feel like I never had any craziness about GHCi and Ctrl+C before, on my previous Windows installation, so I wonder what's changed
17:03:43 <SamB> shapr: doesn't it?
17:03:48 <SamB> @instances Read
17:03:49 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
17:03:56 <SamB> hmm, you are right!
17:04:00 <SamB> dunno!
17:04:11 <SamB> @instances Show
17:04:12 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
17:04:15 <SamB> oh, wait
17:04:24 <SamB> @instances-importing Data.Map Read
17:04:25 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
17:04:37 <shapr> Data.Map.Map does have a Show instance, but not a Read instance.
17:04:39 <syntaxfree> SamB: bordering on the annoying, you're saying that it's impossible to make every instance of a class an instance of anotheer class?
17:04:58 <SamB> syntaxfree: no. I'm saying its not at all standard.
17:05:09 <syntaxfree> oh. I see.
17:05:16 <syntaxfree> anyway,  what would the syntax be?
17:05:21 <SamB> and I happen to avoid those features
17:05:26 <SamB> oh, the syntax would be the obvious one
17:05:34 <SamB> its the semantics that aren't so clear
17:05:51 <syntaxfree> @type negate
17:05:53 <lambdabot> forall a. (Num a) => a -> a
17:06:02 <SamB> instance Foo a => Bar a where ...
17:06:20 <syntaxfree> It happens that the "dual" of any numeric type is its "negate".
17:06:21 <giksos> shapr: Data.Map.Map has a Read instance in the 6.5 library
17:06:26 <syntaxfree> ok!
17:06:32 <syntaxfree> Thank you very much :)
17:08:14 <SamB> giksos: so WTH wasn't it there before?
17:08:54 <giksos> well, someone realized it was missing - there was a talk about it in the mailing list
17:09:31 <shapr> giksos: Cool, thanks.
17:09:34 <SamB> they should have *TESTS* for these things
17:09:48 <shapr> Yup, want to write 'em?
17:10:10 <sjanssen> SamB: what sort of test would catch whether Data.Map.Map has a read instance?
17:10:38 <Chinju> hm, so, I was just hoping that perhaps someone here has had similar difficulties getting Ctrl+C to work properly with GHCi on Windows, and could maybe help me out
17:10:52 <Chinju> specifically
17:11:04 <syntaxfree> a class declaration can't impose some function definitions for all of its instances, right?
17:11:07 <Chinju> if I use Ctrl+C at the evaluation prompt, it'll just close GHCi
17:11:19 <giksos> http://www.haskell.org/pipermail/libraries/2005-October/004443.html
17:11:22 <lambdabot> Title: [Haskell] Read Instances for Data.Map and Data.Set, http://tinyurl.com/hxtje
17:11:23 <Chinju> and if I try to use it while a nonterminating computation is going on, it will just get ignored
17:11:50 <Chinju> while what I'd like is the behavior I used to have, where I could use it to break a nonterminating computation and return to the evaluation prompt
17:13:14 <Chinju> so, it's a silly problem with very little connection to actual Haskell, but hopefully someone might have had a similar experience and could help me out
17:14:31 <giksos> Chinju: wish I could, but I'm on linux :( Maybe you should write to the mailing list
17:15:56 <Chinju> yeah, I might give that a try
17:16:44 <giksos> shapr: here is an instance of Read you could use till you get 6.6: http://www.haskell.org/pipermail/haskell/2005-October/016667.html
17:16:46 <lambdabot> Title: [Haskell] Read Instances for Data.Map and Data.Set, http://tinyurl.com/l8dbq
17:20:36 <x3m> dons: came up with any new ideas how to get hs-plugins to work?
17:20:57 <shapr> giksos: I just stole the 6.6 instance, thanks.
17:21:24 <giksos> :)
17:22:01 <syntaxfree> can class declarations include some function definitions that are valid for every instance of the class?
17:22:45 <syntaxfree> (for example, does the definition of Eq include (/=) = not . (==) ? )
17:23:20 <dolio> Yeah, you should be able to do that.
17:23:49 <dolio> And then people can override your defaults with more efficient implementations if they want to.
17:23:50 <Chinju> syntaxfree: I think those only will exist as defaults, though
17:23:51 <Chinju> yeah
17:24:00 <Chinju> not necessarily just more efficient
17:24:08 <Chinju> actually differing definitions are possible as overrides
17:24:24 <Chinju> e.g.
17:24:59 <Chinju> well, hold on for an example
17:25:28 <sjanssen> syntaxfree: watch out for cyclic definitions
17:25:29 <dolio> Well, I guess they could act differently, too, but aren't most defaults based on laws that the other things are supposed to obey?
17:25:46 <Chinju> well
17:25:49 <Chinju> most, sure
17:25:54 <Chinju> but not all, and there's no checking
17:25:55 <Chinju> for example
17:25:59 <Chinju> in the Show class
17:26:07 <sjanssen> if we defined "class Eq a where (==) = not . (/==); (/=) = (==)" the compiler won't warn us when instances don't override enough of the methods
17:26:08 <Chinju> there's a default definition of showList
17:26:13 <Chinju> that does the usual thing
17:26:34 <Chinju> but it's overridden for Chars, to print strings in a different manner
17:26:45 <dolio> Ah, yeah, that's true. There's no 'laws of showing' in that case, I guess. :)
17:26:52 <Chinju> yeah
17:31:20 <zeeeee> hi all, i'm getting "ERROR "/usr/lib/hugs/packages/base/Data/List.hs" - Garbage collection fails to reclaim sufficient space". this sometimes comes up when i try (re-)loading a file after having done something silly involving infinite structures; somehow it goes away after a while. is there any way to have the garbage collector collect faster? :)
17:32:01 <Lemmih> Try running :gc at times.
17:33:20 <zeeeee> Lemmih: thanks
17:33:24 <Chinju> hm, the opening message for this channel said Haskell was the language of ICFP winners for three years running
17:33:46 <Chinju> wasn't 2D the language of choice for discriminating hackers this year? [Jokingly so, of course, but still]
17:34:21 <sjanssen> Chinju: Haskell, among other languages, was used by the winning team
17:34:57 <sjanssen> so we don't claim the "discriminating hackers" title anymore, but we can make a slightly weaker claim
17:35:13 <Chinju> ah
17:35:19 <Chinju> where can I find out information on what the winning team used?
17:35:21 <yip> we still put the funk in funktion though
17:35:21 <sjanssen> I wonder if #2d has "The language of choice for discriminating hackers" in it's topic
17:35:32 <dons> heh
17:35:48 <Chinju> hehe
17:36:00 <zeeeee> sjanssen: what determines which language gets that title?
17:36:13 <dons> Chinju: some detais are here, http://sequence.complete.org/hwn/20060927
17:36:40 <dons> zeeeee: scoreboard, http://icfpcontest.org/scoreboard.shtml
17:36:41 <lambdabot> Title: ICFP Programming Contest, 2006 : Scoreboard
17:36:55 <zeeeee> sjanssen: wouldn't hs deserve it if it was used by the winning team?
17:37:23 <Chinju> the winning team used many languages
17:37:30 <Chinju> and got to choose which one to proclaim
17:37:37 <dons> this year the teams were able to nominate a particular language to honour
17:37:43 <Chinju> they chose 2D, one of the languages invented for the competition
17:38:09 <zeeeee> ah
17:44:40 <ThreeQ> is there a show instance for functions anywhere?
17:45:13 <sjanssen> ThreeQ: Text.Show.Functions I think
17:46:01 <sjanssen> that only shows "<<function>>" or something like that
17:46:06 <ThreeQ> oh, boring
17:46:18 <sjanssen> > ord -- there's also this code somewhere in lambdabot
17:46:20 <lambdabot>  <Char -> Int>
17:46:29 <lisppaste2> ThreeQ pasted "show instance for functions" at http://paste.lisp.org/display/27247
17:46:42 <sjanssen> > head -- but it fails more often than not because the functions must be monomorphic
17:46:43 <lambdabot>  Add a type signature
17:47:07 <ThreeQ> seems like somebody must have written something like that before
17:47:56 <dolio> Someone on the mailing list wrote Show/Eq for functions of a form something like 'Bounded a, Bounded b => a -> b'
17:48:44 <ThreeQ> something like this, I mean: http://paste.lisp.org/display/27247
17:48:57 <dolio> Eq would require Eq b, as well.
17:49:12 <ThreeQ> *Main> reverse :: [Int] -> [Int]
17:49:13 <ThreeQ> [2,-1,5] |-> [5,-1,2]
17:49:22 <SamB> @scheck \f -> f ()
17:49:24 <lambdabot>  Add a type signature
17:49:27 <SamB> @scheck \f -> f () :: Bool
17:49:28 <lambdabot>   Failed test no. 2. Test values follow.: {()->False}
17:49:30 <sjanssen> ThreeQ: that doesn't give you all the information though, just a handful of cases
17:49:31 <ThreeQ> *Main> (+) :: Int -> Int -> Int
17:49:31 <ThreeQ> 31 |-> 19 |-> 50
17:49:39 <ThreeQ> right, but it's more useful than nothing
17:49:51 <dolio> Right, well, with Bounded arguments and results (or possibly Enum), you can actually print out the entire function.
17:49:53 <ThreeQ> gives a sense for what the function does
17:49:56 <ThreeQ> ooh
17:50:07 <SamB> dolio: see my @scheck invocation?
17:50:09 <sjanssen> ThreeQ: SamB has a point too.  Using SmallCheck instead should give you prettier results
17:50:33 <ThreeQ> where do you get smallcheck?
17:50:43 <SamB> @where smallcheck
17:50:44 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.1.tar
17:50:59 <SamB> or you could steal lambdabot's version
17:51:55 <ThreeQ> is there a difference?
17:52:05 <SamB> lambdabot's has IO disabled
17:52:13 <SamB> and I think I added an instance or two to it
17:52:48 <SamB> er, that is, the typeclass instance that allows you to check IO properties is commented out
17:53:00 <SamB> but you can uncomment it
17:53:05 <ThreeQ> heh
17:53:17 <SamB> there might be a few other things commented out too
17:55:37 <dons> wow, Christian Maeder has a 1000 module haskell program.
17:55:53 <skew> handwritten?
17:56:02 <glguy> welcome back
17:56:21 <dons> skew: doesn't say. he just says that the new RC works with this 1000 module project
17:56:24 <dons> thanks glguy
17:56:49 <dons> ?remember simonpj You may not like this but this should work..
17:58:01 <cybercobra> ?type List
17:58:03 <lambdabot> Not in scope: data constructor `List'
17:58:27 <glguy> ?kind []
17:58:29 <lambdabot> * -> *
17:58:48 <cybercobra> List isn't the name of anything builtin, right?
17:59:01 <SamB> cybercobra: right
17:59:46 <cybercobra> good
18:00:55 <dibblego> what's that branch of mathematics that talks about id and not?
18:01:01 <dibblego> ?type not
18:01:03 <lambdabot> Bool -> Bool
18:01:14 <cybercobra> Boolean Logic?
18:01:43 <dibblego> I could grep my IRC logs but I'll bet 'not' and 'id' has been said a lot
18:02:07 <dibblego> someone told me about it once - I think it was dons
18:02:11 <cybercobra> lambda calculus?
18:03:01 <glguy> dibblego: have you read http://apocalypse.org/~antony/work/pubs/genuinely-functional-guis.pdf
18:03:04 <lambdabot> http://tinyurl.com/maobc
18:03:33 <dibblego> glguy, no I haven't
18:03:40 <kpreid> dibblego: not perfect fits, but: propositional calculus? combinator logic?
18:03:42 <dons> glguy: just got an email from marc espie asking for a ghc update to the ports tree
18:03:51 <dons> since he wants to run pugs.
18:03:52 <dons> hmm
18:03:59 <glguy> dons: ok, fine, I'll work on it
18:04:03 <dons> oh, hehe.
18:04:05 <dibblego> kpreid, sounds familiar, I'll grep it thanks
18:04:17 <kpreid> oh, hi dons. did you get my message? :)
18:04:18 <dons> glguy: I wasn't implying that. just thought you might be interested :)
18:04:32 <dons> kpreid: ah yes. i'll look at this. good idea
18:05:06 <glguy> dibblego: The paper discusses dealing with GUI state functionally, I thought you'd be interested in what it had to say
18:05:11 <glguy> dibblego: a quote: "The Fruit programming model is built around two central concepts: signals
18:05:14 <glguy> and signal transformers.
18:05:15 <dibblego> glguy, yeah looks good - thanks
18:05:26 <glguy> dons: I'll play with it tonight if you like
18:05:39 <glguy> dons: if you already started I can leave it alone though
18:07:33 <glguy> dons: or is it so easy that it's not even worth discussing?
18:07:48 <dons> no, its non-trivial
18:07:54 <dons> since the ports that depend on ghc must also build
18:08:09 <dons> last time i checked, the main issue was thtat the ghc doc generation depends on tools we don't have
18:08:21 <glguy> hmm...
18:08:34 <dons> (we can go back to just pulling the doc bundle off the website though)
18:08:34 <glguy> what version are you wanting to update it to? 6.4.2? 6.6?
18:08:39 <dons> 6.4.2
18:08:45 <glguy> kk
18:09:06 <dons> i was vaguely thinking of having a python-ish ghc subdir with both 6.2.2 and 6.4.2
18:09:14 <dons> but that proved hard enough that i didn't get it done
18:09:31 <dons> i'll stick up what I have, and you can peek at it if you like
18:09:36 <glguy> kk
18:10:34 <glguy> the Makefile seems to suggest that the python dependancy is a regression test thing
18:10:58 <glguy> dependency*
18:11:53 <glguy> dons: I forget... how do we bootstrap on OpenBSD (ports specifically)
18:12:43 <glguy> (from C every time?)
18:13:50 <dons> yep. heaps faster build that way
18:14:05 <dons> (the only other option is to distribute a previously built ghc binary)
18:14:38 <dons> so we generate a .hc file tarball for a 4.0 box
18:14:48 <dons> host that, then write a port script that builds from that C source
18:15:02 <dons> and one .hc tarball needs to be generated per arch
18:16:49 <lispy> dons: i'm using data.bytestring with a bytestring parser now!
18:16:58 <dons> cool!
18:17:01 <dons> code online?
18:17:12 <lispy> dons: but...having a few odd problems (that i think may just be a stale compile)
18:17:20 <lispy> dons: it's xerox's bytestring parser
18:17:28 <lispy> dons: i just added a bit more parsec to it
18:17:49 <lispy> dons: http://darcs.haskell.org/~paolo/darcs/ByteStringParser/ByteStringParser.hs
18:17:53 <lambdabot> http://tinyurl.com/m3ucc
18:18:34 <lispy> i'm also not sure how much this will improve performance...i now suspect that the real memory hog in my program is the sheer number of datatypes i create
18:19:13 <lispy> ah, yup
18:19:21 <lispy> recompiled from scratch
18:19:26 <lispy> and that fixed my last bug
18:19:34 <lispy> now time to do the performance test
18:21:19 <dons> cool
18:24:54 <lispy> i think they secretly released a new version of visual haskell
18:25:04 <lispy> i downloaded it today and it was posted yestarday :)
18:25:10 <lispy> never saw an announcement though
18:25:20 <lispy> but the great thing was that it came with Data.ByteString
18:25:49 <glguy> new version?
18:25:50 <dons> oh, good news.
18:26:20 <SamB> lispy: sometimes people release with no announcements!
18:26:29 <SamB> sometimes they release, go to bed, and announce at some later time!
18:26:59 <glguy> lispy: where is the new version??
18:27:12 <lispy> http://darcs.haskell.org/vshaskell
18:27:16 <lambdabot> Title: Index of /vshaskell
18:27:26 <lispy> glguy: that seems to be the official place
18:27:32 <dibblego> gah it needs Visual Studio
18:27:43 <glguy> http://www.haskell.org/visualhaskell/ ?
18:27:45 <lambdabot> Title: Visual Haskell
18:28:07 <dibblego> is Visual Studio open sourced yet? :)
18:28:13 <SamB> heh
18:28:43 <lispy> dibblego: i wish...quite a few things i'd like to...let's say...'tweak'
18:29:06 * SamB thinks lispy wants to go through it with a sledgehammer
18:30:48 <lispy> :)
18:30:54 <glguy> lispy: where did you download the new version from?
18:31:05 <lispy> glguy: there is a .msi in that url
18:31:28 <glguy> lispy: Ah, so they didn't even change the filename or the webpage?
18:31:29 <lispy> glguy: either http://darcs.haskell.org/vshaskell/VSHaskell71.msi
18:31:33 <lambdabot> http://tinyurl.com/ny7sk
18:31:40 <lispy> or
18:31:41 <lispy> http://darcs.haskell.org/vshaskell/VSHaskell80.msi
18:31:44 <lambdabot> http://tinyurl.com/pmpgn
18:32:44 * araujo looks in
18:33:08 <sjanssen> I wish Vim's synhl for .lhs was a bit more robust
18:33:09 <sjanssen> sight
18:33:11 <glguy> lispy: unannouned is right :)
18:33:15 <sjanssen> s/sight/sigh
18:33:27 <lispy> oh dear...so switching to data.bytestring didn't help program at all...in fact it now crashes instead of completing...
18:33:51 <lispy> runs out of memory i think
18:34:25 <dons> sjanssen: what's the problem?
18:34:30 <dons> maybe i've got some tweaks here that fix it..
18:35:10 <sjanssen> dons: it's barfing on ghc/deSugar/Check.lhs
18:35:32 <dons> let me see..
18:35:54 <lispy> my program reads in thousands of records from a file and then sums them and spits out a new averaged record
18:36:02 <dons> sjanssen: looks ok here?
18:36:03 <sjanssen> dons: the first code section isn't detected as code
18:36:07 <lispy> the summing function i use is a strict fold
18:36:15 <lispy> but, still my program blows up in memory usage
18:36:21 <sjanssen> it works if I comment out the \section line
18:36:23 <dons> sjanssen: ah i've a .lhs syntax patch for vim for that.
18:36:30 * dons hunts
18:37:10 <dons> oh, are you using vim 7? or 6.
18:37:28 <sjanssen> 7.0.17
18:37:45 <dons> ah that might be it. some of the syntax highlighting scripts broke in 7
18:38:03 <dons> (i just checked - i'm using the default .lhs highlighter)
18:38:16 <dons> seems i commented out my custom ones some time back
18:38:27 <dons> i'll post them anyway, maybe they'l work for you
18:38:37 <sjanssen> okay, thanks
18:39:28 <dons> oh, here's one http://www.cse.unsw.edu.au/~dons/tmp/lhaskell.vim
18:39:31 <lambdabot> http://tinyurl.com/huef3
18:40:10 <lispy> i think my datastructures take more memory parsed than unparsed...so maybe i need to lazily parse them and construct the final value...
18:40:39 <dons> sjanssen: and another one, http://www.cse.unsw.edu.au/~dons/tmp/lhaskell.vim.2
18:40:42 <lambdabot> http://tinyurl.com/gsqy8
18:41:24 <dibblego> anyone use haskell in eclipse?
18:41:35 <dons> sjanssen: and an underlying haskell.vim 'after' file, http://www.cse.unsw.edu.au/~dons/tmp/haskell.vim
18:41:37 <lambdabot> http://tinyurl.com/qzrnh
18:41:53 <dons> (adds some nicer cpp and RULES stuff)
18:42:06 <dons> hmm. probably should create a repo and readme for this stuff
18:42:13 <dons> so we can coordinate our efforts
18:42:59 <dons> sjanssen++ -- lambdabot patches
18:43:44 <lispy> oh, new lambdabot features?
18:44:20 <dons> * Make @redo handle non-lambda expressions on the RHS of (>>=)
18:44:52 <sjanssen> @redo x >>= f -- wrong without the patch
18:44:52 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 7}) "Unterminated end-of-line comment"
18:44:58 <sjanssen> @redo >>= f
18:44:59 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
18:45:06 <sjanssen> @redo x >>= f
18:45:07 <lambdabot> f
18:45:10 <dons> not updated yet.
18:45:22 <dons> ?uptime
18:45:22 <lambdabot> uptime: 3d 2h 51m 18s, longest uptime: 4d 20h 30m 23s
18:46:37 <lispy> dons: i saw you fixed the unsafeIOToST bug too :)
18:47:47 <lispy> dons: so my program actually uses more memory with the new data.bytestring parser...
18:48:01 * dons shakes head in disbelief at the unsafeIOToST hole
18:48:08 <glguy> what was the hole?
18:48:09 <dons> lispy: oh interesting.
18:48:32 <lispy> dons: my theory is that it's just holding more in memory at once and not actually requiring more
18:48:33 <dons> glguy: we'd exposed unsafeIOToST with some non-audited extensions to the trusted lambdabot base, including ST
18:48:42 <dons> which isn't a good idea ;)
18:48:43 <sjanssen> lispy: are you taking small slices out of a large string?
18:48:50 <lispy> no
18:48:55 <lispy> i process the whole file
18:48:56 <glguy> dons: so unsafeIOToST could be used to attack lambdabot ?
18:49:09 <dons> you could use it to perform IO from a runST fragment
18:49:17 <glguy> yuck
18:49:20 <lispy> glguy: maybe, but i couldn't actually find much besides 'print' that was callable
18:49:27 <glguy> ahh
18:49:31 <lispy> readFile and writeFile were not in scope
18:49:33 <dons> luckily haskell is so hard to use, no one but sjanssen worked this out ;)
18:49:44 <dons> yeah, so that helped
18:49:54 <dons> the IO stuff wasn't visible anyway
18:50:12 <SamB> > readFile
18:50:12 <lispy> i wanted to create a file titled, "dons, unsafeIOToST lets you create files.txt"
18:50:13 <lambdabot>  <[Char] -> IO [Char]>
18:50:21 <dons> oh, the Prelude...
18:50:29 <glguy> dons: what is the reason that "runST $ mySt" doesn't work?
18:50:30 <dons> > writeFile
18:50:32 <lambdabot>  <[Char] -> [Char] -> IO ()>
18:50:34 <dons> lispy?
18:50:48 <dons> > runST
18:50:49 <lambdabot>  Not in scope: `runST'
18:50:53 <dons> glguy: ?
18:51:07 <SamB> @hoogle ST s a -> a
18:51:08 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
18:51:15 <sjanssen> glguy: it's because of the rank-2 types in runST
18:51:16 <lispy> dons: it was my way of reporting the bug :)
18:51:19 <SamB> > runST .
18:51:19 <lambdabot>  Parse error
18:51:26 <lispy> dons: i failed in the end though
18:51:45 <SamB> > unsafeIOToST
18:51:45 <dons> lispy: but writeFile should have been in scope anyway? via the Prelude.
18:51:45 <lambdabot>  Not in scope: `unsafeIOToST'
18:52:00 <SamB> lispy: writeFile is certainly in scope
18:52:09 <dons> hands up if you think the prelude should have a pure subset
18:52:12 <sjanssen> > typeOf writeFile
18:52:14 <lambdabot>  [Char] -> [Char] -> IO ()
18:52:25 <dons> Prelude.Pure and Prelude.Skanky
18:52:26 <SamB> ideally or in terms of fun?
18:53:08 <dons> it would be nice to be able to ensure a safe, non-IO base of haskell98 is available via the module system.
18:53:19 <glguy> sjanssen: is that a bug that stops ($) from working with runST a bug, or a fact of how things work?
18:53:19 <dons> though we'd need tool support to check that kind of thing
18:53:26 <sjanssen> chopping up the Prelude into small modules sounds like a good idea
18:53:36 <dons> the runST $ issue with ghc is solved in 6.6, btw
18:53:43 <lispy> SamB: then there is no excuse for my incompetence...not sure why i couldn't get it to work
18:53:47 <dons> impredicativity yo!
18:53:48 <sjanssen> we could have Prelude.IO; Prelude.List; Prelude.Monad; etc.
18:53:52 <dons> yeah
18:54:00 <skew> glguy: more a question of research progress.
18:54:00 <sjanssen> then Prelude exports all those
18:54:39 <skew> letting you instantate polymorphic functions with types containing foralls makes type inference harder
18:55:12 <SamB> @google split
18:55:15 <lambdabot> http://www.splitusa.com/
18:55:15 <lambdabot> Title: Split USA
18:55:17 <SamB> @hoogle split
18:55:17 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
18:55:18 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
18:55:18 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
18:55:23 <SamB> -- was a typo...
18:56:14 <lispy> i'm surprised no one responded to my desperate plea for help with OOHaskell
18:56:43 <glguy> OO is for java programmers!
18:56:46 <glguy> boo, hiss!
18:56:54 <lispy> okay, running my program with the old parser just to be sure it doesn't get axed by the RTS for eating too much memory
18:57:37 <lispy> glguy: but if i can use oohaskell i won't have to use something like scala or java for my oo class :)
18:57:46 <dons> lispy: did you contact the authors?
18:57:53 <lispy> just haskell-cafe
18:58:02 <lispy> but i know oleg reads haskell-cafe
18:59:37 <lispy> hmm...the parser is using the strict version of bytestring
18:59:41 <lispy> i wonder i f that's a problem
18:59:55 <shapr> I got to meet Oleg in Portland. That was way cool.
19:00:20 <lispy> yes, yes it was
19:00:34 <lispy> well, damn, i want to debug this but i need to go
19:00:40 * lispy shakes a fist in the air
19:01:30 <lispy> > 256 / 77
19:01:32 <lambdabot>  3.324675324675325
19:01:58 <profmakx> > let pi = 3 in pi
19:02:01 <lambdabot>  3
19:02:34 <dons> ?let pi = 3
19:02:35 <lambdabot> Defined.
19:02:38 <dons> > L.pi
19:02:39 <lambdabot>  3
19:02:42 <dons> :)
19:02:50 <dons> > L.pi == pi
19:02:51 <lambdabot>  add an instance declaration for (Floating Integer)
19:02:59 <dons> > L.pi ==  fromIntegral pi
19:03:00 <lambdabot>  Add a type signature
19:07:17 <Cale> > L.pi ==  realToFrac pi
19:07:18 <lambdabot>  add an instance declaration for (Fractional Integer)
19:07:18 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
19:08:26 <Cale> glguy: yes, that is very much related to that discussion :)
19:08:26 <dolio> > fromIntegral L.pi == pi
19:08:27 <lambdabot>  False
19:09:08 <Cale> er
19:09:12 <Cale> @type L.pi
19:09:14 <lambdabot> Couldn't find qualified module.
19:09:19 <Cale> > L.pi
19:09:20 <lambdabot>  3
19:09:22 <Cale> oh
19:09:23 <Cale> heh
19:10:51 <kpreid> > L.pi == floor pi
19:10:53 <lambdabot>  True
19:11:31 <SamB> wow
19:11:46 <SamB> I finally got my Yhc to typecheck again
19:13:17 <lispy> Cale: tell me what you know about automated theorem provers!
19:13:30 <lispy> you have 30 seconds because i'm supposed to be meeting someone now :)
19:14:24 <lispy> Cale: can you give them a bunch of axioms and optionally theorems and try to find out what is true and what is not?  For example, if you come up with a new mathematical structure and wanted to explore it...
19:14:25 <SamB> hah
19:14:48 <SamB> lispy: it won't tell you all that is true and false, obviously!
19:14:57 <lispy> right
19:15:07 <SamB> it can't even decide whether something is true or false
19:15:24 <lispy> hmmm
19:15:43 <lispy> well, that's not very useful :)
19:15:53 <SamB> well, it might be able to *try*!
19:16:29 <SamB> but as I read in GEB, 'tis impossible to do for any sufficiently powerful formal system
19:16:51 <Cale> lispy: You can try, but with most interesting systems, searching through proofs of length n is exponential in n, and it's impossible to bound proof length on the statement desired
19:17:13 <lispy> ah
19:17:25 <Cale> Well, I should perhaps qualify "interesting" a bit
19:17:49 <lispy> i had a crazy idea to try and teach darcs patch theory to an ATP and see if it could point out inconsistencies
19:18:05 <SamB> mmm
19:18:11 <SamB> it might be able to, for all I know!
19:18:15 <lispy> but the ATPs i found seem like they are geared toward generating code from types
19:18:19 <Cale> hmm
19:18:30 <lispy> like Coq and isabelle
19:18:31 <Cale> Well, yeah
19:19:12 <SamB> did anyone get a ruling as to whether a proof of CSS's working constituted a violation of the DMCA?
19:19:13 <Cale> There are some projects which are sort of more related to mathematical systems...
19:19:34 <lispy> Cale: do tell! (down to 10 seconds ;)
19:19:45 <SamB> thats a *long* 30 seconds
19:19:46 <Cale> http://au.metamath.org/index.html
19:19:49 <lambdabot> Title: Metamath Home Page
19:19:52 <lispy> SamB: yeah
19:20:07 <lispy> SamB: the other party was just leaving work it turns out
19:20:10 <Cale> It's not automatic though
19:20:13 <lispy> but i think they are here now
19:20:16 <lispy> Cale: thanks for the link
19:20:24 <Cale> It's all human guided and machine-checked
19:20:35 <lispy> or not...
19:20:44 <lispy> that would be fine
19:21:08 <Cale> The longest path back to an axiom from 2 + 2 = 4 is 132 levels deep
19:21:12 <Cale> heh
19:21:22 <SamB> Cale: are you *sure*?
19:21:31 <Cale> SamB: that's what it says
19:21:31 <SamB> I bet I could go *farther*!
19:21:39 <Cale> in their proof
19:21:45 <lispy> would prolog be a good system to use?
19:21:50 <SamB> heh
19:21:56 <lispy> build a 'knowledge base' of darcs patch theory
19:22:01 <Cale> the complete proof of 2 + 2 = 4 involves 2,109 subtheorems
19:22:04 <lispy> and then run example situations past it?
19:22:10 <skew> I've been learning Coq.
19:22:27 <Cale> Which is why I think metamath is a little silly :)
19:22:32 <shapr> A first step towards darcs patch theory might be to run it past QuickCheck.
19:22:37 <skew> Mostly typing in stuff from tutorials, now from Xavier Leroy's poplmark submission.
19:22:54 <Cale> lispy: do you have a reason to believe it's inconsistent?
19:22:55 <shapr> That won't prove correctness unless you do proof by exhaustion, but it might point out flaws in the latest theory.
19:23:07 <skew> I'm thinking I'll try to formalize some stuff about principal typings.
19:23:31 <lispy> Cale: not really, we know it's broken, but not necessarily inconsistent
19:24:29 <hyrax42> patch theory is brokeN?
19:24:32 <hyrax42> um n
19:25:03 <SamB> lispy: broken how?
19:25:49 <Tman> what does tail do exactly?
19:26:11 <SamB> > tail [1..]
19:26:12 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
19:26:26 <skew> tail (x:xs) = xs, tail [] raises an exception
19:26:54 <SamB> okay, I go to bed now while Yhc runs its tests...
19:26:54 <Tman> neato
19:26:55 <Tman> thanks
19:27:40 <SamB> hopefully I will have commit access in the morning... but probably I won't want to commit all of this even if I do...
19:27:55 <hyrax42> > tail []
19:27:56 <lambdabot>  Add a type signature
19:28:05 <hyrax42> > talk [] :: [()]
19:28:06 <lambdabot>  Not in scope: `talk'
19:28:13 <hyrax42> > tail [] :: [()]
19:28:15 <lambdabot>  Exception: Prelude.tail: empty list
19:28:52 <Tman> > zip [1..] [3..]
19:28:53 <lambdabot>  [(1,3),(2,4),(3,5),(4,6),(5,7),(6,8),(7,9),(8,10),(9,11),(10,12),(11,13),(12...
19:29:05 <Tman> now I understand
19:31:17 <hyrax42> everything?
19:32:24 <sris> Does it make sense to write something like: newtype T = Someconstructor [Aoldtype]
19:32:32 <SamB> I've made 45 patches today...
19:33:30 <sjanssen> sris: sure
19:34:04 <sris> erh. wasn't the answer i was hoping for :D
19:34:19 <SamB> sris: why not?
19:34:25 <sris> i just dont understand what im trying to do ;)
19:34:32 <SamB> most people call the constructor T too, though
19:35:22 <SamB> okay now for real
19:36:27 * SamB -> bed
19:45:10 <syntaxfree> I call the constructor something shorter.
19:45:34 <syntaxfree> sris: you do understand the differences between data, type and newtype?
19:45:39 <syntaxfree> (took me forever to figure newtype out)
19:46:03 <sris> newtype, im not sure
19:46:21 <syntaxfree> newtype is like data, but it doesn't allow multiple data constructors.
19:46:23 <syntaxfree> say,
19:46:25 <sris> im just brutefocing myself to missery atm
19:46:30 <Cale> newtype implements the new type with the same implementation as an existing type
19:46:44 <syntaxfree> data RGB = Red | Green | Blue | RGB (Word8, Word8, Word8)
19:46:52 <Cale> if you have
19:46:52 <syntaxfree> newtype RGB = Red | Green ... is illegal.
19:47:09 <Cale> data D = D Integer
19:47:15 <Cale> newtype N = N Integer
19:47:26 <syntaxfree> data Measure = M Float is equivalent to newtype Measure = M Float.
19:47:27 <Cale> then N undefined = undefined
19:47:35 <Cale> but D undefined is not the same as undefined
19:47:43 <syntaxfree> except for the quirky case Cale is exposing :)
19:47:56 <Cale> well, that's the fundamental difference
19:48:05 <Cale> data is lifted, newtype isn't
19:48:12 <syntaxfree> :)
19:48:20 <syntaxfree> I was told that newtype is somehow more efficient.
19:48:27 <Cale> yes, in general
19:48:56 <Cale> At runtime, (N 5) will be the same in memory as 5
19:49:09 <Cale> but (D 5) will be a box with a pointer to 5
19:49:27 <Cale> well, really a pointer to code which when evaluated, returns 5 :)
19:49:53 <sris> im probably to tired for this, it's all so out of context sp it doesnt help me much actually ;)
19:49:54 <Cale> (but will do so immediately, in this case)
19:50:03 <syntaxfree> it's a difference as to how the  compiled program handles the type, but not to the type-theoretical entity?
19:50:12 <sris> but i vaguely get the idea of newtype
19:50:24 <Cale> sris: what is the problem you're trying to sort out? I sort of got here late :)
19:50:26 <sris> probably something else i dont understand
19:51:00 <Cale> newtype T = Someconstructor [Aoldtype] -- this is okay
19:51:08 <sris> Cale, well, that's the problem, im not really sure ;)
19:51:16 <Cale> hm?
19:51:32 <sris> Well it's an assignment, so i shouldn't be asking to much about it ;)
19:51:47 <sris> I just wanted to know if i really didnt understand newtype
19:52:02 <Cale> newtype is used when you really just want a new type in the type system which is going to be equivalent to some existing type as to implementation, but you want to control things with the "tag" it gives you
19:52:23 <syntaxfree> Cale: you are allowed to redefine functions for the new type, right?
19:52:28 <sris> i see
19:52:30 <syntaxfree> say, newtype Measure = M Float
19:52:36 <syntaxfree> but then
19:52:37 <Cale> syntaxfree: indeed
19:52:47 <syntaxfree> instance Num Measure where (M a) + (M b) = M (min (a+b) 1 )
19:52:54 <Cale> If you're writing a module, one really nice trick for data abstraction is to make a newtype and then don't export the constructor tag
19:53:14 <Cale> So then you get control over how values of that type are built
19:53:26 <sris> Im not sure if i understand what the constructor is doing
19:53:39 <Cale> The constructor isn't doing anything at runtime
19:53:48 <Cale> it's purely a compile-time thing
19:53:55 <sris> What do you use it for? pattern matching?
19:54:02 <Cale> it expresses the permission to build a value of that type
19:54:16 <syntaxfree> sris: in my limited experience, it's better to try to understand what things *mean*, not what they *do*.
19:54:30 <Cale> newtype Money = Dollars Integer
19:54:37 <syntaxfree> the gee-whiz factor in Haskell is in how declarative it gets.
19:54:39 <sris> syntaxfree, sounds good ;)
19:54:43 <Cale> If I stick this in a module called Mint
19:54:51 <Cale> and I export the type Money
19:54:56 <Cale> but not the constructor Dollar
19:55:00 <Cale> Dollars
19:55:14 <Cale> then only the Mint can make Money :)
19:55:28 <chessguy> what a farce :)
19:55:48 <Cale> The rest of the program can only get values of type Money which are produced by the module Mint
19:55:49 <syntaxfree> I find it hard to find good symbolic names for infix operators.
19:55:54 <syntaxfree> The best-looking symbols are taken.
19:56:04 <syntaxfree> ->, |, etc. etc.
19:56:11 <Cale> <+>
19:56:34 <syntaxfree> is (<given>) an allowed infix operator name?
19:57:00 <Cale> infix operators have to entirely be composed of symbol characters
19:57:12 <Cale> (or else be ordinary names enclosed in backticks)
19:57:14 * syntaxfree gets a 300-key unicode keyboard.
19:57:26 <Cale> just get scim
19:57:30 <syntaxfree> backticks are ugly, and I wanted equation-looking code ;)
19:57:30 <Tman> what does next do
19:57:32 <Tman> ?
19:57:33 <syntaxfree> scim?
19:57:41 <Cale> ∈ ⊕ ⊗
19:57:44 <Cale> ∫
19:57:51 <syntaxfree> ?
19:57:52 <Cale> ∂f/∂x
19:58:03 <Taral> I take it it's an input method for math symbols
19:58:07 <Cale> If your IRC client is unicode, that will make sense :)
19:58:30 <syntaxfree> I set it to UTF-8.
19:58:33 <syntaxfree> Try again?
19:58:33 <Cale> It's a general input method for all sorts of languages
19:58:45 <syntaxfree> (I reckon the âf/âx was a \partial)
19:58:47 <Cale> ⊗ ∫ ⊕ ∂
19:58:51 <Cale> yeah
19:58:52 <syntaxfree> OOOH.
19:59:16 <syntaxfree> gah, lhs2tex is bound to choke at that without explicit substitution rules.
19:59:19 <Cale> I got that by typing: \ot \int \op \pa
19:59:37 <syntaxfree> and the reason I want good-looking code is to produce a good-looking paper anyway.
19:59:55 <Cale> you only have to type enough to get the character you want :)
20:00:01 <Cale> ∈
20:00:10 <Cale> that's \i
20:00:16 <Cale> (or \in)
20:00:43 <Cale> You install scim, and the additional tables, and then set it on LaTeX table mode :)
20:01:14 <Cale> You may want to actually get the source and edit the LaTeX table though, since it contains a few errors and some glaring omissions.
20:01:29 <Cale> (I should really submit a patch)
20:06:08 <sris> What if i have an existing type T, would newtype T = Foo [T] make sense?
20:06:44 <sjanssen> sris: no
20:06:46 <syntaxfree> are there any unsigned numeric data types in the prelude?
20:07:03 <sjanssen> syntaxfree: not in the Prelude, but look in Data.Word
20:07:22 <sris> but newtype T = Foo [Bar.T] would?
20:07:40 <sris> if the type T is defined in the module Bar
20:07:58 <sjanssen> sris: right
20:08:20 <sris> and T and Bar.T would be equivalent?
20:08:40 <sjanssen> no
20:08:50 <sris> no?
20:08:57 <sjanssen> first off [Bar.T] means a list of Bar.T's
20:08:57 <lisppaste2> syntaxfree pasted "an unsignedness strategy" at http://paste.lisp.org/display/27255
20:09:03 <syntaxfree> I don't know if that's a good idea.
20:09:12 <syntaxfree> I  basically want to enforce that Measure is between zero and one
20:09:34 <syntaxfree> so all basic operations with Measure are squashed.
20:09:42 <sjanssen> sris: second, newtypes are actually wrappers around a type
20:10:01 <sris> meaning?
20:10:18 <sjanssen> they're usually useful when you want to ensure some sort of invariant.  (check syntaxfree's recent paste for a decent example)
20:10:20 <sris> Because i think i want T to be a list of Bar.T's ;)
20:10:35 <sjanssen> sris: then use "type T = [Bar.T]"
20:10:50 <sjanssen> type == type synonym; newtype == data type wrapper
20:17:40 <syntaxfree> in abstract mathematics, what's a simple algebraic structure closed under sum and product operations?
20:18:00 <chessguy> umm, i think that's a field, isn't it?
20:18:16 <chessguy> better asked in #math though
20:18:24 <syntaxfree> what's the closest thing in Haskell to a field?
20:18:24 <glguy> A field is any set of elements that satisfies the field axioms for both addition and multiplication and is a commutative division algebra.
20:18:34 <syntaxfree> (Probably a type class)
20:19:19 <dolio> Rings are probably all you need for being closed under sum and product.
20:19:39 <dolio> Less than that if you don't need inverse/identity for sum.
20:19:59 <glguy> A ring in the mathematical sense is a set S together with two binary operators + and * (commonly interpreted as addition and multiplication, respectively) satisfying the following conditions:
20:20:11 <glguy> which I won't be pasting :)
20:20:17 <glguy> http://mathworld.wolfram.com/Ring.html
20:20:19 <lambdabot> Title: Ring -- from Wolfram MathWorld
20:20:34 <dolio> And the Num typeclass is close to specifying a ring.
20:20:38 <dolio> Although, not exactly.
20:20:45 <syntaxfree> I'm writing a research-y (not intended for publication really, trying to get Haskell known in my field, mostly) paper defining a probability algebra in abstractish terms.
20:21:24 <syntaxfree> I'm debating declaring probabilistic spaces to be an instance of Monoid.
20:21:43 <syntaxfree> (where mappend is conditional probability and mconcat is probability of disjoint union)
20:53:57 <hyrax42> what are the expected axioms of a monoid instance
20:54:15 <hyrax42> left/right identity with mempty
21:07:08 <zeeeee> hi all, a general question on haskell program design. i'm writing a lambda calculus reducer. i have a data structure Expr for the simple abstract syntax. i made it instantiate Show, and overrode showsPrec, so that instead of, say, "Lambda (Var x) (App (Var f) (Var x))" this would print "\x.f x". is overriding showsPrec a good approach? (after googling i've also come across suggestions of using Text.PrettyPrint, but i could barely find any
21:07:08 <zeeeee> info on this module.)
21:10:17 <zeeeee> another question is: does it matter (in terms of either design or perf) whether i implement my (recursing) printing function as showsPrec, show, or something else? also, should does it matter whether i use: a++b++c, concat, printf, or these nifty things, which seem to be macros (not sure, i'm new to haskell): http://www.haskell.org/pipermail/haskell-cafe/2005-July/010890.html http://www.haskell.org/pipermail/haskell-cafe/2005-July/010854.h
21:10:18 <zeeeee> tml
21:10:21 <lambdabot> Title: [Haskell-cafe] Best way to build strings?, http://tinyurl.com/jncvq
21:12:08 <skew> I'd suggest defining the pretty-printer as something other than Show, so you can use Show to see the structure of terms if you need to debug the pretty-printer.
21:12:11 <glguy> Is the Jacobi Method ever used to determine linear dependency and the linear combination of a set of vectors?
21:13:33 <glguy> I guess once you determine that a set is linearly dependent... you could assume one of the variables and solve for the rest in terms of the assumed variable...
21:13:49 <zeeeee> skew: ok, so i should just define a ShowS, right? what is the "precedence" for in showsPrec, etc., functions? and is Text.PrettyPrint not the right tool?
21:16:19 <skew> you might want to use some pretty printer
21:16:47 <skew> the easiest thing to do is define a function to strings, using ++ to put things together
21:17:26 <skew> if you want pretty indentation or better complexity, use a pretty printer library. PPrint is pretty nice too.
21:20:00 <zeeeee> skew: but wouldn't ++ be slow?
21:20:10 <skew> only if you have terms nestes very deeply
21:20:29 <skew> show is just for you to look at things, right?
21:20:57 <zeeeee> skew: i guess that's my question :)
21:21:14 <zeeeee> skew: i wasn't sure what show is used for
21:21:30 <skew> I think terms will be too big for you to understand well before they get deep enough that ++ would be slow
21:21:44 <araujo> anybody knows some tutorial for making haskell libs?
21:22:00 <zeeeee> skew: why would anyone ever override show, then?
21:22:18 <zeeeee> skew: (that was a tangent question)
21:22:30 <skew> ++ copies the left argument, so associating like (((a ++ b) ++ c) ++ d) ++ e is bad, but associating like a ++ (b ++ (c ++ (d ++ e))) (the default) is fine.
21:23:11 <zeeeee> skew: interesting, so in fact that's equivalent to concat [a,b,c,d,e]?
21:24:25 <zeeeee> what's precedence for in showsPrec et al?
21:29:46 <skew> precedence follows the precedence levels in Haskell expressions
21:30:09 <skew> I think with derived show instances it only matters for infix constructors
21:31:41 <skew> showsPrec should put in parentheses if it is using an operator that would need parentheses when used in an expression with another operator of the precedence level passed as an argument
21:34:42 <lispy> Cale: sorry i disappeared.
21:35:13 <lispy> SamB: there are some classes with merges that are not um...handled
21:35:36 <lispy> SamB: and apparently no one really knows how to handle them
21:36:42 <syntaxfree> there seems to be some analogy between type classes and categories.
21:36:50 <syntaxfree> I can't quite put it in  precise terms, though.
22:10:27 <glguy> poke n = zipWith ($) (replicate n id ++ [const 0] ++ repeat id)
22:10:39 <glguy> anyone care to golf this?
22:10:42 <dons> that's a nice little function
22:10:47 <dons> ?pl poke n = zipWith ($) (replicate n id ++ [const 0] ++ repeat id)
22:10:48 <lambdabot> poke = zipWith id . (++ (const 0 : repeat id)) . flip replicate id
22:11:06 <dons> wow, @pl did some interesting things there
22:11:28 <dons> ?type let poke n = zipWith ($) (replicate n id ++ [const 0] ++ repeat id) in poke
22:11:29 <glguy> poke n = zipWith (\a b -> if' (a == n) 0 b) [0..]
22:11:30 <lambdabot> forall b. (Num b) => Int -> [b] -> [b]
22:11:31 <lispy> ?type zipWith ($) (replicate n id ++ [const 0] ++ repeat id)
22:11:32 <glguy> or something?
22:11:33 <lambdabot> Not in scope: `n'
22:11:42 <lispy> ?type \n -> zipWith ($) (replicate n id ++ [const 0] ++ repeat id)
22:11:43 <dons> ?type let poke = zipWith id . (++ (const 0 : repeat id)) . flip replicate id in poke
22:11:44 <lambdabot> forall b. (Num b) => Int -> [b] -> [b]
22:11:45 <lambdabot> forall b. (Num b) => Int -> [b] -> [b]
22:12:39 <lispy> > (\n -> zipWith ($) (replicate n id ++ [const 0] ++ repeat id)) 4 [1,2,3,4,5]
22:12:41 <dolio> glguy: zipWith id
22:12:42 <lambdabot>  [1,2,3,4,0]
22:12:46 <dolio> 1 character shorter
22:12:54 <lispy> why does it poke a zero?
22:13:50 <glguy> dolio: your function is short, but doesn't poke zeros in my list :)
22:14:01 <dolio> Hmm...
22:14:02 <glguy> lispy: because the n'th element has (const 0) called on it
22:14:06 <lispy> ?pl \n a -> zipWith ($) (replicate n id ++ [const a] ++ repeat id)
22:14:07 <lambdabot> (zipWith id .) . (. ((++ repeat id) . return . const)) . (++) . flip replicate id
22:14:11 <zeeeee> hi all, how do i get ghci or hugs to print a string "raw", without quoting things like \\ and \n?
22:14:18 <dolio> zipWith id (repeat id) [1..]
22:14:24 <glguy> poke n = zipWith (\a b -> if' (a == n) 0 b) [0..]
22:14:24 <dolio> > zipWith id (repeat id) [1..]
22:14:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:14:27 <zeeeee> when i enter "\\" it prints "\\" not \
22:14:29 <dolio> > zipWith ($) (repeat id) [1..]
22:14:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:14:35 <lispy> > fix show
22:14:36 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:14:47 <sjanssen> I like how a bunch of the tickets in GHC's Trac have _|_ as the milestone
22:14:56 <glguy> > let poke n = zipWith (\a b -> if' (a == n) 0 b) [0..] in poke 2 [1..5]
22:14:57 <lambdabot>  Not in scope: `if''
22:15:10 <glguy> what's the if' that lambdabot uses?
22:15:13 <lispy> ((zipWith id .) . (. ((++ repeat id) . return . const)) . (++) . flip replicate id) 4 a "eeeeeee"
22:15:17 <lispy> > ((zipWith id .) . (. ((++ repeat id) . return . const)) . (++) . flip replicate id) 4 a "eeeeeee"
22:15:18 <lambdabot>  Not in scope: `a'
22:15:32 <lispy> glguy: it's if' b t e = if b then t else e
22:15:47 <glguy> lispy: then why did I get "Not in scope: `if''
22:15:54 <lispy> > ((zipWith id .) . (. ((++ repeat id) . return . const)) . (++) . flip replicate id) 4 'a' "eeeeeee"
22:15:56 <lambdabot>  "eeeeaee"
22:15:59 <lispy> glguy: right
22:16:06 <lispy> glguy: it's not real :)
22:16:13 <glguy> bah
22:16:13 <lispy> only lambdabot knows about it
22:16:28 <lispy> but, i've wanted it as part of the prelude many times
22:16:33 <dolio> > (\n -> zipWith id (replicate n id ++ [const 0] ++ repeat id)) 3 [1..5]
22:16:33 <lispy> same with case
22:16:33 <zeeeee> anybody?
22:16:34 <lambdabot>  [1,2,3,0,5]
22:16:43 <lispy> > "foo"
22:16:44 <lambdabot>  "foo"
22:16:48 <glguy> @let if' b t e | b = t | otherwise = e
22:16:50 <lambdabot> Defined.
22:16:55 <RyanT5000> is there a good syntax for running a State monad on a sub-state of the main state?
22:16:58 <glguy> > L.if' True 'a' 'b'
22:17:00 <lambdabot>  'a'
22:17:03 <RyanT5000> e.g.: let's say i have a State (a, b) ()
22:17:03 <glguy> > L.if' False 'a' 'b'
22:17:05 <lambdabot>  'b'
22:17:14 <glguy> > let poke n = zipWith (\a b -> L.if' (a == n) 0 b) [0..] in poke 2 [1..5]
22:17:16 <lambdabot>  [1,2,0,4,5]
22:17:17 <RyanT5000> how do i run something on just the a?
22:17:31 <RyanT5000> (e.g.: run a State a () on it)
22:17:33 <lispy> zeeeee: putStr "foo"
22:17:50 <glguy> RyanT5000: modify (first myf)
22:17:53 <zeeeee> lispy: thanks!
22:18:04 <lispy> zeeeee: there is also putStrLn
22:18:26 <glguy> RyanT5000: could you be a little more specific?
22:19:01 <lispy> RyanT5000: yeah, i have no idea what you're asking :)
22:19:11 <RyanT5000> alright, just a sec, let me reformulate my question
22:20:06 <weitzman> Dear people involved in Haskell': It would be sweet if you could use (if) to get a function that acts like an if statement
22:20:40 <dolio> glguy: Looks like it works to me.
22:21:15 <glguy> > L.if' ('a' == 'a') {- then -} "true" {- else -} "false"
22:21:16 <lambdabot>  "true"
22:21:18 <lispy> weitzman: unfortunately, haskell' is all about bringing existing, conservative and established extensions into the haskell spec...
22:21:31 <lispy> weitzman: so they don't entertian cool but untried ideas
22:21:56 <weitzman> It wouldn't exactly be an extension to the type system
22:22:06 <glguy> weitzman: example?
22:22:36 <RyanT5000> flip runState (0, 5) $ do get >>= put . ((,) 0) . (+1) . snd
22:22:39 <RyanT5000> ok so i *could* do that
22:22:44 <weitzman> Oh, so now I have to justify my random demands?
22:22:47 <RyanT5000> i want to make it much simpler
22:23:00 <weitzman> That's unfortunate, because I didn't have an example in mind
22:23:07 <RyanT5000> basically, in general terms, i'm operating in a State c ()
22:23:18 <glguy> > let if' b | b = const | otherwise = flip const in if' True 'a' 'b'
22:23:19 <RyanT5000> i have a function c -> a, and i have a function a -> c -> c
22:23:19 <lambdabot>  'a'
22:23:25 <glguy> > let if' b | b = const | otherwise = flip const in if' False 'a' 'b'
22:23:27 <lambdabot>  'b'
22:23:33 <weitzman> I just thought it was odd that "if" could only be used with "then"
22:24:23 <glguy> weitzman: instead of being used with?
22:24:30 <sjanssen> I think Haskell' just needs to introduce a function like if'
22:24:35 <sjanssen> no need for extra syntax
22:24:46 <glguy> why, when it's so easy to define yourself?
22:24:53 <edwardk> ift'?
22:24:53 <zeeeee> hi all, i'm trying to write a parser for a simple grammar (lambda calculus). where can i find a small/similar such parser to learn from by example? e.g. any simple parsers for sexps or balanced parens?
22:24:54 <edwardk> er
22:24:56 <edwardk> if'?
22:25:03 <glguy> > let if' b | b = const | otherwise = flip const in if' False 'a' 'b'
22:25:04 <lambdabot>  'b'
22:25:12 <weitzman> There are a lot of things in haskell that would be easy to define yourself, but are pre-defined anyway
22:25:13 <lispy> zeeeee: yes
22:25:21 <lispy> ?google 48 hour scheme
22:25:23 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
22:25:24 <dolio> There was talk about rebindable if syntax on one of the mailing lists a while back. Doesnt' that mean there's some underlying function that it gets mapped to?
22:25:24 <lambdabot> Title: Write Yourself a Scheme in 48 hours
22:25:25 <lispy> zeeeee: ^^^^
22:25:29 <sjanssen> glguy: for completeness.  Most of the other datatypes in the Prelude have analogous functions: maybe, either, foldr
22:25:39 <zeeeee> lispy: thanks!
22:25:44 <lispy> zeeeee: np
22:25:57 <RyanT5000> i'd like to do a get, then a projection, then a state transform, then a reverse projection, then a put
22:26:13 <weitzman> @hoogle [a] -> b -> (a -> b) -> b
22:26:15 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
22:26:15 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
22:26:15 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
22:26:24 <Pseudonym> Scheme is a source language designed for writing simple, brain-dead compilers for.
22:26:27 <RyanT5000> does anyone even understand what i'm *asking* yet?
22:26:41 <RyanT5000> lol, i just spent 8 hours checking legal citations for accuracy, my brain is a bit fried
22:27:05 <glguy> > let if' b t e = guard b >>= maybe e (const t) in if' False 'a' 'b'
22:27:06 <lambdabot>  Couldn't match `Maybe a' against `()'
22:27:23 <lispy> RyanT5000: so you want to update a datatype inside the state monad?
22:27:26 <RyanT5000> yeah
22:27:31 <RyanT5000> just part of it
22:27:32 <glguy> > let if' b t e = maybe e (const t) (guard b) in if' False 'a' 'b'
22:27:33 <lambdabot>  'b'
22:27:54 <RyanT5000> (e.g.: one field of a record)
22:28:02 <sjanssen> the only problem with introducing a "bool :: Bool -> a -> a" function is that we expect bool True x y = x; which is contrary to the argument order of maybe and either
22:28:05 <lispy> RyanT5000: if you want to just update part of it i recommend the record syntax...unfortunately i think you have to write a different do-block for each field
22:28:28 <lispy> RyanT5000: i have something like this at work so not handy...but it's ugly because i have to write a different do block for each field
22:28:46 <RyanT5000> huh
22:29:14 <RyanT5000> i'm kinda surprised there's no stock function for doing this
22:29:42 <lispy> is the object you're updating in the state?
22:29:42 <RyanT5000> @hoogle (a -> b) -> (b -> a -> a) -> State b c -> State a c
22:30:11 <RyanT5000> yeah
22:30:17 <RyanT5000> the state is the record
22:30:33 <RyanT5000> i have a state transformer for the field
22:30:35 <sjanssen> @djinn (a -> b) -> (b -> a -> a) -> a -> a
22:30:47 <lispy> do { o <- get; let v = f (myfield o); put ( o {myfield = v) }
22:30:48 <glguy> RyanT5000: you are just modifying a tuple in the state, right?
22:31:00 <weitzman> > 1
22:31:03 <RyanT5000> well, it's actually a record, not a tupple
22:31:18 <glguy> RyanT5000: but in your original question it was a tuple?
22:31:20 <lispy> RyanT5000: like that?
22:31:24 <RyanT5000> yes
22:31:29 <lambdabot> No matches, try a more general search
22:31:31 <lambdabot> f a b c = b (a c) c
22:31:35 <lispy> oh, yes to who?
22:31:39 <lambdabot>  1
22:31:46 <lispy> lambdabot: stop lagging!
22:31:49 <sjanssen> @pl f a b c = b (a c) c
22:31:51 <lambdabot> f = flip flip id . (ap .) . flip (.)
22:31:54 <lispy> ?vixen bit slow today?
22:31:55 <lambdabot> yes
22:31:56 <RyanT5000> yeah, lispy, like that
22:32:13 <lispy> RyanT5000: yeah, i don't know an easy way because of the o { myfield = ... } part
22:32:25 <RyanT5000> well yeah, but let's say i had an update function defined
22:32:31 <lispy> RyanT5000: as far as i know you can't just do that bit with a function, unless maybe you break out the template haskell
22:32:34 <glguy> wouldn't it be better to write the record updating function outside of the State Monad and just combine it with modify?
22:32:46 <RyanT5000> yeah, but modify doesn't really cut it
22:32:54 <lispy> ?type modify
22:32:55 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
22:33:03 <sjanssen> how about a combination of gets and modify?
22:33:05 <lispy> oh right because modify would update the whole object instead of the field?
22:33:06 <glguy> RyanT5000: it would cut it when combined with your custom record updating function
22:33:12 <glguy> no?
22:33:29 <lispy> ah, i think glguy is right
22:33:34 <RyanT5000> well, for one, i'd rather use a sub-state-transformer, rather than a sub-function
22:33:49 <glguy> RyanT5000: then it should still call a sub-function
22:33:56 <RyanT5000> for two, i'd need to use a let because the output of the projection function needs to get used in two places
22:34:09 <glguy> RyanT5000: and you can use the sub-state-transformer to do that
22:34:16 <RyanT5000> yeah
22:34:17 <RyanT5000> i realize it can be done
22:34:21 <sjanssen> @type \selector updater -> gets selector >>= \v -> modify . updater v
22:34:23 <lambdabot> forall a s s1 (m :: * -> *) a1. (MonadState s ((->) a1), MonadState s1 m) => (s -> a) -> (a -> a1 -> s1 -> s1) -> a1 -> m ()
22:34:25 <RyanT5000> in fact, it can be done without *that much* trouble
22:34:57 <RyanT5000> sjanssen: yeah that's practically what i want
22:35:01 <RyanT5000> i guess i'll just write it :)
22:35:07 <sjanssen> except I wrote it wrong
22:35:08 <lispy> don't forget the reader monad
22:35:09 <RyanT5000> this was just an issue of wanting to use something that i assumed must exist already
22:35:15 <lispy> > join (*) 2
22:35:16 <RyanT5000> what does reader monad do?
22:35:17 <RyanT5000> lol
22:35:17 <lambdabot>  4
22:35:21 <lispy> it can duplicate an argument
22:35:33 <RyanT5000> i'm woefully uneducated when it comes to monads
22:35:40 <lispy> > ap (+) 1 2
22:35:41 <lambdabot>  add an instance declaration for (Num (a -> a))
22:35:46 <lispy> > ap (+1) 1 2
22:35:48 <lambdabot>  add an instance declaration for (Num (a -> b))
22:35:55 <lispy> > ap (+1) (*) 2
22:35:56 <lambdabot>    Occurs check: cannot construct the infinite type: t = (t -> t1) -> b
22:35:56 <lambdabot>   ...
22:36:02 <lispy> heh, i forget how ap works :)
22:36:05 <sjanssen> @type \sel upd -> modify (\v -> upd (sel v) v)
22:36:06 <lispy> ?type ap
22:36:06 <glguy> > do { s <- sum; n <- genericLength; return (s / n) } [1,3,7,10]
22:36:07 <lambdabot> forall s t (m :: * -> *). (MonadState s m) => (s -> t) -> (t -> s -> s) -> m ()
22:36:07 <lambdabot>  Parse error
22:36:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:36:13 <glguy> > (do { s <- sum; n <- genericLength; return (s / n) }) [1,3,7,10]
22:36:14 <lambdabot>  5.25
22:36:22 <sjanssen> RyanT5000: there you go
22:36:27 <weitzman> > ((+ 1) >>= (* 2)) 4
22:36:28 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> b
22:36:29 <lambdabot>    Expec...
22:36:51 <weitzman> > ((+ 1) >>= return (* 2)) 4
22:36:53 <lambdabot>  8
22:37:02 <weitzman> The reader monad doesn't do much interesting stuff
22:37:06 <edwardk> ap basically lets you generalize liftMn
22:37:06 <RyanT5000> yeah, that all works, but it's not as clean as i like; i'm just going to write modifySub
22:37:23 <lispy> weitzman: i was mostly teasing
22:37:42 <glguy> ?type (do { s <- asks sum; n <- asks genericLength; return (s / n) })
22:37:43 <lambdabot> forall i (m :: * -> *). (Fractional i, MonadReader [i] m) => m i
22:37:49 <glguy> ?type (do { s <- sum; n <- genericLength; return (s / n) })
22:37:51 <lambdabot> forall i. (Fractional i) => [i] -> i
22:38:44 <sjanssen> @type liftM2 (/) sum genericLength
22:38:45 <lambdabot> forall i. (Fractional i) => [i] -> i
22:38:51 <edwardk> liftM2 f x1 x2  == return f `ap` x1 `ap` x2   and so on
22:38:54 <lispy> > ap (+) (+1) 1
22:38:56 <lambdabot>  3
22:39:05 <lispy> > ap (+) (*2) 1
22:39:06 <lambdabot>  3
22:39:15 <glguy> > join (*) 2
22:39:17 <lambdabot>  4
22:39:29 <weitzman> @type join
22:39:31 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
22:39:39 <weitzman> @type concat
22:39:40 <lambdabot> forall a. [[a]] -> [a]
22:39:49 <cybercobra> cool
22:39:58 <lispy> ?type join :: [[a]] -> [a]
22:40:00 <lambdabot> [[a]] -> [a] :: forall a. [[a]] -> [a]
22:40:10 <glguy> > (*2) `fmap` (+1) $ 5
22:40:12 <lambdabot>  12
22:40:25 <lispy> er
22:40:29 <lispy> 12?
22:40:33 <lispy> oh
22:40:38 <glguy> (*2) . (+1) $ 5
22:40:42 <lispy> i would have expected the multiplication to come first
22:40:52 <cybercobra> > (*2) . (+1) $ 5
22:40:54 <lambdabot>  12
22:41:13 <lispy> ?type fmap
22:41:15 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
22:41:29 <weitzman> @instances-importing Functor
22:41:30 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:42:02 <weitzman> > fmap (+ 1) (Just 1)
22:42:04 <lambdabot>  Just 2
22:42:32 <lispy> oh man, i make heavy use of liftM for the maybe monad at work
22:42:48 <lispy> i have records where every field is optional
22:42:54 <weitzman> > fmap (+ 1) (Left 1)
22:42:54 <lispy> but i want to be able to add records
22:42:55 <lambdabot>  Left 1
22:43:03 <weitzman> > fmap (+ 1) (Right 1)
22:43:04 <lambdabot>  Add a type signature
22:43:07 <lispy> so to add them, i have to liftM2 (+) on every field
22:43:20 <weitzman> > fmap (+ 1) ((Right 1) :: Either Int Int)
22:43:22 <lambdabot>  Right 2
22:43:27 <glguy> > evalState (fmap (+1) (return 2)) ()
22:43:28 <lambdabot>  3
22:43:37 <weitzman> Does fmap for Either just map the second arg?
22:43:43 <weitzman> Or rather, things on the right
22:43:45 <glguy> weitzman: right, only maps on right
22:43:58 <weitzman> Interesting. Is there some clever reason?
22:44:03 <glguy> since Left is a Nothing with a values attached
22:44:07 <lispy> > fmap (+1) ((Left "bite me" :: Either String Int)
22:44:08 <lambdabot>  Parse error
22:44:09 <glguy> Left represents failure
22:44:17 <weitzman> Ah, when you use it as an error
22:44:18 <weitzman> Yeah
22:44:19 <lispy> > fmap (+1) ((Left "bite me" :: Either String Int))
22:44:20 <lambdabot>  Left "bite me"
22:44:43 <glguy> > fail "bitten" :: Either String ()
22:44:44 <lambdabot>  Left "bitten"
22:44:54 <glguy> > fail "bitten" :: Maybe ()
22:44:56 <lambdabot>  Nothing
22:45:10 <lispy> > fail "arg!" :: [Int]
22:45:12 <lambdabot>  []
22:45:26 <weitzman> > fail "hello" :: Int -> Bool
22:45:27 <lambdabot>  <Int -> Bool>
22:45:36 <ptolomy> Eesh.
22:45:38 <weitzman> > (fail "Hello") 1 :: Bool
22:45:39 <lambdabot>  Exception: Hello
22:45:52 <ptolomy> The Reddit has been cruel.
22:46:08 <glguy> link?
22:46:16 <ptolomy> http://programming.reddit.com/info/klla/comments
22:46:20 <lambdabot> Title: How would you replace a field in a CSV file with Haskell? (reddit.com), http://tinyurl.com/f3ksd
22:46:21 <ptolomy> but perhaps in a constructive way.
22:46:48 <lispy> ?seen dons
22:46:49 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 35m 6s ago.
22:47:02 <lispy> dons: are you nearby?
22:47:18 <zeeeee> hi all, i'm trying to write a parser for a simple grammar (lambda calculus). i'm reading a tutorial on using parsec, but would things be much simpler if i just used readParen, lex, etc. instead?
22:47:33 <glguy> considering that Haskell has Regexs in Data.ByteString on 6.6, this shouldn't be a problem forever
22:48:27 <lispy> zeeeee: are readParen and lex part of parsec?
22:49:06 <zeeeee> lispy: no they aren't, i'm asking if parsec is overkill for my purposes
22:49:25 <lispy> zeeeee: how do you feel about monads?
22:49:42 <zeeeee> lispy: i don't know anything about them yet
22:50:05 <lispy> zeeeee: i'm getting more and more experienced with parsec, so i don't feel like it's overkill...but if you're not comfortable with monads or parsec maybe it's a bit much
22:50:36 <lispy> zeeeee: if you prefer the more traditional parser generation techniques there is happy and alex
22:50:53 <lispy> zeeeee: but maybe if you understand readParen best then maybe implementing it at a low level like that is best
22:51:39 <lispy> CSV is a bad idea
22:51:44 <lispy> i don't see why people insist on using it
22:51:57 <lispy> it's non-standard so it means different things to different people
22:52:17 <lispy> and it has hackish rules for encoding data
22:52:45 * lispy gets pretty annoyed at CSV actually
22:52:55 <joelk> does Foreign.Storable.sizeOf just compile to a constant depending on the type of its argument?
22:52:59 <dons> lispy: ?
22:53:13 <lispy> dons: hi
22:53:14 <sjanssen> joelk: it should, yes
22:53:27 <dons> yep, it does.
22:53:43 <lispy> dons: i wondered if you have a minute to hypothesize on ways to improve my program that (the one that runs out of memory)
22:54:01 <dons> ok. do you have a .prof somewhere?
22:54:10 <lispy> no i don't and i'm not at the machine
22:54:16 <lispy> but i could describe the behavior
22:54:29 <dons> could you mail that to me instead
22:54:36 <lispy> :)
22:54:42 <dons> i'm about to head out, and without a .prof i'll need to sit and think
22:54:46 <lispy> okay
22:54:53 <lispy> well, a quick question then
22:54:59 <dons> sure
22:55:15 <lispy> do you think switching to a data.bytestring.lazy would help when the parsec based parser doesn't have the same problem?
22:55:19 <zeeeee> lispy: that's the thing, i can find (long) tutorials on parsec/happy/etc but none on readParens/lex/etc
22:55:40 <joelk> so I can use, eg. nextElem :: Ptr a -> Ptr a; nextElem p = p `plusPtr` sz where sz = sizeOf . unsafePerformIO . peek $ p
22:55:49 <dons> lispy, nope, I don't think .lazy will be any benefit. i can't be sure though without seeing the code
22:56:12 <sjanssen> joelk: you could, but surely there is a better way
22:56:14 <lispy> dons: okay, next time i'm at work i'll send you some relevants bits
22:56:42 <lispy> ?type readParens
22:56:44 <dons> ok.
22:56:44 <sjanssen> @hoogle advancePtr
22:56:44 <lambdabot> Not in scope: `readParens'
22:56:45 <lambdabot> Foreign.Marshal.Array.advancePtr :: Storable a => Ptr a -> Int -> Ptr a
22:56:55 <sjanssen> joelk: for starters, you could use that instead
22:56:56 <lispy> zeeeee: what is this readParens you speak of?
22:57:01 <joelk> sjanssen, is there? that way you can inc a pointer from anywhere. All the information for the size is in the type Ptr a
22:57:50 <lispy> dons: oh, if you're still here....can i use the lazy readFile with the strict bytestrings?
22:57:54 <sjanssen> joelk: where there's an unnecessary unsafePerformIO, there's a better way
22:57:55 <joelk> well, I'll be... that's what I was looking for...
22:58:16 <dons> lispy: hmm. no. you can only strictly read the file with strict bytestrings
22:58:25 <dons> (how big are you files??)
22:58:26 <lispy> okay
22:58:27 <joelk> the unsafePerformIO never actually happens though, because the compiler just see's the type of sizeOf's arg, right?
22:58:35 <lispy> dons: this test case is 47 megs...
22:58:50 <sjanssen> and if advancePtr didn't exist, I'd write something like "getPtrType :: Ptr a -> a; getPtrType = undefined"
22:59:05 <joelk> of yeah...
22:59:19 <lispy> dons: i'm pretty sure the data takes up less memory unparsed...but i consume all of it and generate a smaller set of records from a much larger parsed set...that's why i wonder if laziness would help
22:59:31 <joelk> er, /oh/ yeah...
22:59:37 <sjanssen> joelk: You're right, the unsafePerformIO won't happen, but that code is guaranteed to throw any reader of that code for a loop
22:59:49 <joelk> true.
23:00:14 <dons> lispy: possibly strict fields on your data type might be useful
23:00:19 <dons> but i'm only speculating
23:00:34 <dons> 47 megs shouldn't be a problem if you're sensible
23:00:37 <lispy> dons: yeah, they are all Maybe Int or Maybe Double
23:00:48 <dons> you might want to look at a strict Maybe type instead then
23:00:50 <dons> let me find you one
23:00:53 <lispy> all fields are optional :(
23:00:56 <joelk> sjanssen, thanks.
23:01:30 <dons> data MaybeS a = NothingS | JustS !a
23:01:41 <lispy> hmm
23:01:51 <dons> or even, data (:*:) a b = !a :*: !b deriving(Eq,Ord,Show,Read)
23:02:08 <lispy> i tried data Foo = Foo { bar :: !Maybe Double } -- but this gave a parse error
23:02:09 <dons> should help with unpacking the bytestring constructor
23:02:16 <lispy> well, not parse, but strictness error
23:02:16 <dons> !(Maybe Double)
23:02:21 <lispy> Ah
23:02:44 <dons> but you'd want newtype Foo = Foo (MaybeS Double) -- I think
23:02:48 <lispy> what do you mean unpacking teh bytestring constructor?
23:02:56 <dons> s/Double/
23:03:10 <dons> I was thinking of MaybeS ByteString for some odd reason
23:03:29 <lispy> ah, i do store one string per record but it's 3 characters so I just use String
23:03:47 <dons> maybe you're copying too much information out of the bytestring
23:03:59 <dons> that would be better left as a substring pointer into the original source file
23:04:04 <lispy> hmm...
23:04:17 <lispy> i only copy out what it takes to parse numbers
23:04:20 <dons> or, you might need to explicitly copy chunks of the bytestring, so the GC can free the original input
23:04:27 <lispy> so i copy out some digits and convert to double or int
23:04:35 <lispy> hm...maybe
23:04:38 <dons> you could just call readInt, no?
23:04:40 <lispy> i should have to prof this a bit
23:04:43 <dons> yes.
23:04:48 <lispy> ?type readInt
23:04:49 <dons> let's talk more when you've got some numbers
23:04:50 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
23:04:53 <lispy> yeah
23:04:58 <lispy> don't want to take up your time :)
23:05:00 <lispy> thanks
23:05:00 <dons> ?type Data.ByteString.Char8.readInt
23:05:01 <dons> ?type Data.ByteString.Char8.readInteger
23:05:01 <lambdabot> Data.ByteString.Base.ByteString -> Maybe (Int, Data.ByteString.Base.ByteString)
23:05:03 <lambdabot> Not in scope: `Data.ByteString.Char8.readInteger'
23:05:04 <lispy> i appreciate the help
23:05:14 <dons> seems like a nice problem though
23:05:37 <lispy> yeah, it's mostly a csv file
23:05:38 <mwc> @seen Cale
23:05:38 <lambdabot> Cale is in #haskell and #ghc. I last heard Cale speak 3h 4m 9s ago.
23:05:41 <dons> the best way for me to help is for you to make the code available somewhere I can grab, along with an input file.
23:05:44 <lispy> that needs a flexible parser
23:05:51 <dons> that's not always possible though, of course.
23:05:55 <dons> yeah
23:06:07 <lispy> dons: right, i think as long as i give you a subpart of the project no one wil care
23:06:19 <lispy> i mean we make throw away parsers for this sort of data file all the time
23:06:23 <dons> yeah
23:06:44 <lispy> i'll shoot you something tomorrow
23:06:45 <lispy> thanks
23:17:37 <zeeeee> lispy: i meant readParen
23:18:02 <lispy> ?type readParen
23:18:04 <lambdabot> forall a. Bool -> ReadS a -> ReadS a
23:18:27 <lispy> zeeeee: i think you want to avoid ReadS
23:18:58 <lispy> zeeeee: but, if not i bet the Haskell98 report discusses how to use it
23:19:03 <zeeeee> lispy: why?
23:19:42 <lispy> it just seems messy and weird to me
23:20:11 <lispy> zeeeee: oh, gentle intro describes making custom instances of Read, so i bet that would help too
23:20:35 <lispy> ?type lex
23:20:37 <lambdabot> ReadS String
23:22:10 <lispy> zeeeee: but feel free to ignore my advice and do what feels right
23:30:25 <syntaxfree> "Now, you might be smart enough to program in Haskell if you've received a MacArthur Genus award." (Larry Wall on the latest State of the Onion)
23:30:30 <syntaxfree> http://www.perl.com/pub/a/2006/09/21/onion.html
23:30:37 <lambdabot> Title: perl.com: The State of the Onion 10, http://tinyurl.com/mjs6c
23:58:03 <dolio> "Plus I think the lead developer of Pugs actually wrote some monads, which is an accomplishment in and of itself."
