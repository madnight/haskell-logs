00:10:40 <AI_coder> Um, guys NK just tested a nuclear bomb.
00:12:35 <dmead> uh oh
00:14:01 <dmead> http://hardware.slashdot.org/article.pl?sid=06/10/09/0333202&from=rss
00:14:05 <lambdabot> Title: Slashdot | North Korea Says It Has Conducted Nuclear Test, http://tinyurl.com/esd9v
00:14:15 <Lemmih> Why does it matter?
00:14:33 <roconnor> AI_coder: was it really a nuke?
00:14:52 <dmead> yea read slashdot
00:14:55 <dmead> :(
00:15:46 <AI_coder> roconnor: Bad things are coming.
00:15:55 <roconnor> In other, less reported news, NK has developed functional programming technology.
00:16:55 <dmead> in related news, north korea has discovered computers ;s
00:17:04 <ValarQ> :-O
00:17:16 <ValarQ> run for the hills!
00:18:19 <orbitz> bad thigns aren't relaly coming
00:18:21 <orbitz> they don't hav eoil
00:18:23 <orbitz> nobody cares about them
00:18:27 <orbitz> theyl just fizzle out
00:18:30 <AI_coder> http://aslwww.cr.usgs.gov/Seismic_Data/telemetry_data/INCN_24hr.html
00:18:33 <lambdabot> Title: ASL DCC INCN TELEMETRY DATA, http://tinyurl.com/qnfkb
00:18:36 <AI_coder> http://earthquake.usgs.gov/eqcenter/recenteqsww/Maps/region/Asia.php
00:18:41 <lambdabot> Title: USGS Earthquake Hazards Program Â» Asia Region, http://tinyurl.com/mw4v6
00:18:48 <AI_coder> That one is for real.
00:33:01 <AI_coder> http://can-ndc.nrcan.gc.ca/recent/980528_e.php
00:33:03 <Bourbaki> tudelu
00:33:05 <lambdabot> Title: Pakistani Nuclear Test of 28 May 1998, http://tinyurl.com/rn5kk
00:33:23 <AI_coder> Although campared to a real one the difference is there, perhaps that was just a mine full of tnt.
00:35:43 <ValarQ> Bourbaki: 'lo
00:47:01 <Bourbaki> is there anything like the ai reposity for haskell?
00:48:04 <dmead> ai repository?
00:48:27 <Bourbaki> its a collection of standard ai stuff written in lisp
00:49:10 <dmead> ah
00:49:13 <dmead> no i don't think so
00:49:52 <Bourbaki> http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/0.html
00:49:54 <lambdabot> Title: Topic: lang/lisp/, http://tinyurl.com/anyy6
00:50:25 <Bourbaki> i still think that haskell is a nice language for a lot of ai thingies because its so concise
00:50:43 <roconnor> there is always vixen
00:50:58 <Bourbaki> whats that?
00:51:18 <roconnor> @vixen how is the AI feeling this morning?
00:51:18 <lambdabot> however you want
00:52:05 <lambdabot> how is the HUMAN feeling this morning?
00:52:25 <Bourbaki> eliza bot?
00:52:44 <roconnor> like eliza, but more sexy.
00:52:53 <Bourbaki> hehe
00:52:55 <norpan> @vixen do you know eliza?
00:52:55 <lambdabot> i think i know
00:54:11 <Botty> @vixen what are you wearing?
00:54:12 <lambdabot> nothin but my ol tank top and a pair of shorts :)
00:54:32 <Bourbaki> how hard is it to write a parser in haskell that yields all possible sentence structures of a sentence given a certain grammar?
00:54:41 <Botty> @vixen wow you're pretty clever
00:54:42 <lambdabot> am i? i'm glad you think so at least
00:54:53 <norpan> Bourbaki: that won't be a parser though
00:54:54 <roconnor> Bourbaki: is the grammar context free?
00:55:08 <Botty> sounds more like a generator bourbaki
00:55:25 <Bourbaki> roconnor yes
00:55:26 <Bourbaki> sec
00:55:45 <roconnor> Bourbaki: sounds like a job for Parsec
00:55:48 <Bourbaki> http://ai-depot.com/Articles/49/Semantics.html
00:55:51 <lambdabot> Title: Natural Language Semantics, http://tinyurl.com/m9zom
00:56:26 <Botty> heh, yeah, I invented that when I was 10.  invented ebnf along with it
00:56:44 <Botty> had pages and pages of ebnf like stuff in an attempt to define english
00:57:06 <Bourbaki> well this works out quite well
00:57:15 <Botty> even got a little bit into semantics
00:57:22 <Bourbaki> and with a little help it also handles ambiguity quite good
00:57:38 <Bourbaki> and it follow the pragmatic credo
00:58:06 <Bourbaki> roconnor so parsec can do this already? the surface structure extraction that is
00:58:27 <norpan> no, parsec does parsing
00:59:37 <roconnor> norpan: doesn't parsing mean yeilding all possible structures given a certain grammar?
00:59:39 <Bourbaki> so there is no grammar tree builder?
00:59:50 <Bourbaki> parsing just means that you accept the sentence
01:00:20 <profmakx> what you want to build is an enumerator
01:00:27 <profmakx> for the language given by the grammar
01:00:28 <profmakx> i suppose
01:00:49 <Botty> though, I've realized by now grammars such as the ones used for programming languages are unfit for language interpretation
01:00:51 <Bourbaki> i dont want to generate sentences i just want all the fitting grammar trees
01:01:06 <Bourbaki> Botty do you know nsm?
01:01:16 <Botty> never heard of it, so no
01:01:22 <profmakx> ah now I get it
01:01:31 <Bourbaki> natrual semantics metalanguage
01:02:03 <Bourbaki> my idea is to extend this older article with the nsm idea and have a small dictionary where all other entries in the dict are made of these elements
01:03:12 <Botty> hmm, sounds cool
01:03:54 <Bourbaki> i have written this in lisp once if thered be a grammar tree extracting thingy id consider writeing it in haskell again
01:05:34 <roconnor> @what Parsec
01:05:34 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
01:06:26 <Botty> I haven't done anything with language parsing in a while, but my current plot is basically to categorize the words into parts of language with a dictionary as well as spelling analysis.  For example, I'd like to be able to write 'catty' and have it interpret this as like-a-cat.  Then, using some algorithm which likely has many tweakable parameters (GA can be applied here), the probability of various trees are ascertained.
01:07:14 <roconnor> oh wow, parsec works on context-sensitive grammars
01:07:36 <Bourbaki> Botty have a look at ontoligies and nsm
01:07:39 <Cale> roconnor: yep
01:08:08 <lispy> roconnor: actually, aren't all programming languages CFG+?  because you have things like variables?
01:08:20 <flux__> botty, have you taken a look at GLR parsing?
01:08:41 <Cale> highly context sensitive -- you can even have the initial part of the input describe a parser to use to parse the rest :)
01:08:41 <goltrpoat> botty:  would you like to be able to also write 'patty' and have it interpret that as like-a-pat?
01:08:44 <flux__> (although you're still propably right about the unfitness of such parsing to natural languages)
01:08:59 <roconnor> lispy: yes, but usually one deals with the context senstives stuff afterwards
01:09:00 <Botty> goltrpoat - yes, depending on the context
01:09:22 <roconnor> Cale: sounds great for parsing SGML
01:09:37 <Botty> flux_ - no, I haven't looked at GLR - I'll look it up
01:09:40 <roconnor> you can parse the SGML declaration, and then parse the rest of the document.
01:09:58 <ValarQ> Cale: like a unix shebang :)
01:10:03 <roconnor> I should write an naive SGML parser using parsec.
01:10:05 <Botty> While were on the topic of parsing, I wonder if it's p[ossible to generate a parser on example
01:10:06 <flux__> botty, glr handles ambigious grammars
01:11:12 <Botty> ah. from the wikipedia article it looks like its a similar concept.
01:12:05 <Bourbaki> if you have a function like () -> a in haskell is that a function that has 0 input parameters?
01:12:53 <Syzygy-> @type 2
01:12:54 <lambdabot> forall t. (Num t) => t
01:13:05 <Syzygy-> @pl () -> Integer
01:13:06 <lambdabot> (line 1, column 4):
01:13:06 <lambdabot> unexpected ">" or "-"
01:13:06 <lambdabot> expecting variable, "(", operator or end of input
01:13:35 <Syzygy-> Bourbaki: My intuition would tell me that a function of type ()->a would be "isomorphic" to a constant of type a.
01:13:58 <Bourbaki> yes
01:14:08 <lispy> Bourbaki: what language has a function like () -> a?
01:14:16 <Bourbaki> i just want to bake all the stuff into a function that can be called without any parameter
01:14:19 <goltrpoat> lispy:  ml
01:14:21 <int-e> > \() -> 23
01:14:22 <lambdabot>  Add a type signature
01:14:22 <Bourbaki> lisp has
01:14:34 <Syzygy-> > \() -> 23 :: Integer
01:14:35 <lambdabot>  <() -> Integer>
01:14:56 <Syzygy-> > \() -> 23 :: Integer $ 15
01:14:57 <lambdabot>  Parse error
01:14:57 <lispy> Bourbaki: the reason i ask is because in ocmal that would be a function of no parameters
01:15:04 <Syzygy-> > \() -> 23 $ 15
01:15:05 <lambdabot>  add an instance declaration for (Num (a -> b))
01:15:14 <lispy> Bourbaki: but in haskell it would be a function of one constant parameter :)
01:15:19 <Bourbaki> lispy have a look at the article i posted here
01:15:27 <lispy> i don't see it
01:15:32 <Bourbaki> the idea is that you have the surface structure and bake the functions into it
01:15:43 <Bourbaki> and then you yield a function you can execute with no parameters
01:15:44 <Bourbaki> sec
01:16:01 <Bourbaki> http://ai-depot.com/Articles/49/Semantics.html
01:16:04 <lambdabot> Title: Natural Language Semantics, http://tinyurl.com/m9zom
01:16:45 <lispy> oh, yeah those lambdas take no parameters
01:17:12 <Bourbaki> so \() is valid for this?
01:17:20 <Bourbaki> and the type of this is ()?
01:17:26 <Syzygy-> Bourbaki: Do you have any reason whatsoever to differ between "function without parameters" and "constant"?
01:17:48 <Bourbaki> the thing is that the function will execute what the sentence says
01:17:58 <Bourbaki> and thus it cant be a constant
01:18:12 <lispy> Bourbaki: doing this in haskell you'd just not worry about parameters
01:18:22 <Bourbaki> if you think the function as a constant it would still have to be callable without any parameter
01:18:42 <Bourbaki> well i did that in my i ging thingy i wrote in haskell
01:19:01 <Bourbaki> but it looks crap if you have a function that just takes a parameter that is never used just to call it
01:19:22 <Cale> There's no reason to do that.
01:19:32 <lispy> pickup verb = \object -> \agent -> \_ -> agent (pickup object)
01:19:48 <Cale> There's basically no reason to have a function which takes a value of type () as a parameter
01:19:51 <lispy> that's on interpretation (very literal)
01:19:57 <int-e> well, haskell has 'real' constants
01:19:58 <goltrpoat> () -> a makes sense in ocaml, since it's strict, so the construct simulates laziness
01:20:06 <Cale> right
01:20:40 <Cale> but here, it's lazy already, so you're just adding a potential extra layer of indirection for nothing
01:20:40 <lispy> pickup verb object agent = agent (pickup object)  -- less literal
01:20:43 <Bourbaki> lispy but the parameters are determined by the sentence
01:20:51 <goltrpoat> agreed
01:21:13 <Bourbaki> so there is no way to do it this way in haskell?
01:21:34 <Bourbaki> at least to me its feeling awkward to pass a parameter that is not needed
01:21:56 <Cale> Bourbaki: I don't understand why you want to pass () as a parameter to it in the first place.
01:22:04 <lispy> Bourbaki: yeah and i'm not sure how the list is used with all those funcalls
01:22:09 <int-e> it makes no sense to do it that way in Haskell.
01:22:09 <Bourbaki> Cale i want to pass an empty lamda list
01:22:17 <Cale> why?
01:22:25 <int-e> But if you must do it that way, you can. It's just not syntactically convenient.
01:22:33 <Bourbaki> that is i want to call a function f without a parameter because the function contains all information already to do the action
01:22:37 <int-e> there are no lambda lists.
01:22:50 <lispy> #'(lambda () (list (funcall agent)
01:22:52 <Bourbaki> lets say you yield just one surface structure
01:22:54 <lispy>                           'pick_up (funcall object))))
01:23:02 <lispy> that doesn't make a lot of sense in haskell
01:23:05 <Cale> Bourbaki: why isn't f a value?
01:23:20 <Bourbaki> then you get one function wich represents the action the sentence semantics tells the agent
01:23:34 <Bourbaki> Cale can i call a value without giveing it a parameter?
01:23:51 <Cale> If f has another parameter, then obviously you have to pass it another one
01:23:52 <int-e> the constants are lazy already
01:24:06 <Bourbaki> it has no parameter though
01:24:10 <lispy> you return a function which returns a list like [agent, pickup, object], but pickup is not evaluated and agent and object are
01:24:13 <Cale> then it's not a function
01:24:18 <int-e> you can force a value by using it in a case expression.
01:24:22 <Cale> It's a value of some non-function type
01:24:24 <Bourbaki> but there are functions that have no parameters
01:24:33 <int-e> no.
01:24:33 <Bourbaki> er no ... :)
01:24:54 <Syzygy-> Bourbaki: In a pure functional paradigm, there is no distinction between no-parameter-functions and values.
01:24:55 <Cale> By a function, I mean "something of type a -> b, for some types a and b"
01:24:56 <Bourbaki> ok so how do i wrap an action in haskell that i can call without useing a parameter?
01:24:59 <int-e> Bourbaki: you'll have to change your mental model about this - haskell does not conform to it.
01:25:14 <int-e> Bourbaki: you make it lazy. oops, it already is. done.
01:25:17 <Cale> Bourbaki: you don't do anything
01:25:34 <Cale> > let xs = 1 : xs in take 10 xs
01:25:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
01:25:40 <Bourbaki> but what lispy said is the tree structure
01:25:47 <Bourbaki> and this is not the action yet
01:25:57 <int-e> actions happen in IO
01:26:01 <Cale> look, I just defined a value (even recursively!) without a parameter
01:26:19 <xerox> Values of type |forall a. (Monad m) => m a| are usually called actions.
01:26:22 <Bourbaki> but you cant execute this
01:26:27 <Bourbaki> youd need an interpreter
01:26:33 <Cale> what would it mean to "execute" it?
01:26:38 <Cale> execute what?
01:26:38 <Bourbaki> that interprets the symbols
01:26:50 <Bourbaki> did you have a look at the article?
01:26:56 <int-e> but in fact you can pass constant IO actions around and use them several times ... their type is IO a
01:27:02 <Bourbaki> the idea is to apply the head of the structure to the rest
01:27:07 <Syzygy-> @hoogle IO a
01:27:08 <lambdabot> System.exitFailure :: IO a
01:27:09 <lambdabot> Control.Exception.evaluate :: a -> IO a
01:27:09 <lambdabot> Network.withSocketsDo :: IO a -> IO a
01:27:09 <Bourbaki> and then you come up with a function
01:27:27 <Bourbaki> in lambda calculs youd end up with a lambda function with no variables left
01:27:46 <Syzygy-> Bourbaki: And such a lambda function IS the value of the calculation.
01:27:58 <Syzygy-> Since functions with no variables are values.
01:28:19 <Bourbaki> yes but in lisp i can store it as a function like in the lambda calculus and call it later
01:28:25 <Bourbaki> and then this will be executed
01:28:36 <int-e> yes, you can take an IO a value and use it later in the IO monad
01:28:38 <Cale> Bourbaki: in Haskell, it won't be evaluated until it's needed anyway
01:29:04 <Syzygy-> This is pretty closely related to how to put points back in pointless theories - given a nice enough category (CCC is nice enough), there is a unique initial object, and the set of morphisms from this object to any other is a good concept for the "points" in that object...
01:29:07 <Cale> Is the evaluation of the function supposed to have side effects?
01:29:12 <lispy> ah yeah it does return a tree not a haskell list...i hadn't picked up on that
01:29:32 <int-e> Cale: that's my guess currently, hence the talk about IO a.
01:29:48 <Bourbaki> Cale yes
01:29:54 <lispy> Cale: have you done much scheme or lisp?
01:30:03 <lispy> Cale: it's generating data which is in turn code
01:30:16 <Cale> lispy: a bit. I wrote the assignments for one of my courses in lisp
01:30:18 <lispy> i don't know how to do that in any language but lisp...
01:30:38 <Cale> lispy: huh? What about Haskell?
01:30:58 <lispy> Cale: yes, i guess you can do it in TH
01:31:04 <lispy> but it's harder :)
01:31:20 <Cale> Oh, you mean literal code which will be interpreted
01:31:25 <lispy> yeah
01:31:31 <lispy> it's really common idiom in lisp
01:31:42 <lispy> they call it symbolic computation
01:31:45 <Cale> What's the point of it here?
01:32:06 <lispy> to generate functions
01:32:28 <int-e> you can compose combinators in Haskell ...
01:32:31 * int-e shrugs
01:32:32 <Cale> why not just generate them normally?
01:32:39 <lispy> so i think the translation to haskell will involve some new data types to hold the construction
01:32:54 <lispy> Cale: because the idiom in lisp works really well :)
01:33:01 <Bourbaki> so i cant store something like the function it self in haskell?
01:33:05 <lispy> just like using lazy functions in haskell
01:33:12 <Cale> Bourbaki: yeah
01:33:21 <Cale> Functions in Haskell are first-class values
01:33:29 <Bourbaki> aha ok
01:33:44 <Cale> and can be put in lists, built up and passed around by functions, etc.
01:33:53 <Bourbaki> but isnt there something like the lambda calculus in lisp for haskell where i can store this?
01:33:54 <lispy> you may even be able to do it in haskell using just higher order functions and ignore this mess with data is code and code is data
01:34:11 <lispy> haskell is lambda calculus
01:34:21 <Bourbaki> lispy i think that is good though taht you can switch data and code
01:34:22 <xerox> ...with sugar on top.
01:34:22 <Cale> actually, it's not quite lambda calculus
01:34:29 <int-e> Bourbaki: there is generally no need for this. You can create a function of type () -> a and it'll make no sense at all.
01:34:36 <Cale> It's lambda calculus with half a dozen extensions
01:34:43 <Cale> (even at the core)
01:35:02 <Bourbaki> but lambda calculus allows you to have functions with no parameters doesnt it?
01:35:03 <xerox> The more the extensions, the bigger the fun.
01:35:29 <Cale> Bourbaki: in pure lambda calculus, every function can always take another parameter
01:35:31 <Bourbaki> like this lamdba ( ) (fn ... )
01:35:45 <Cale> In typed lambda calculus, there are non-function values.
01:36:05 <Cale> but no functions without parameters
01:36:35 <Cale> Of course, you might, say, have the unit type, which has only one value
01:36:47 <Cale> and the function might take that as its parameter
01:37:03 <Cale> but it's not very interesting :)
01:37:24 <Bourbaki> hm
01:37:26 <Cale> > let f () = 5 in f ()
01:37:28 <lambdabot>  5
01:37:32 <Cale> @type  let f () = 5 in f
01:37:34 <lambdabot> forall t. (Num t) => () -> t
01:37:34 <int-e> it would be interesting in a strict language ...
01:37:50 <Bourbaki> but thats what i wanted to have
01:37:50 <lispy> this is something i haven't see in CL before: (defstruct (rule (:type list)) lhs -> rhs)
01:38:05 <Bourbaki> so i can use () to do what i did in the article with lisp right?
01:38:21 <Cale> you could, but it's not necessary to have () as a parameter
01:38:38 <Cale> you can just define the value without it, and it's essentially the same
01:38:49 <Cale> (as a constant)
01:39:01 <lispy> Bourbaki: yeah, haskell doesn't have #'funcall, so what will you do about that?
01:39:03 <Bourbaki> sec let me show some code where i had the problem
01:39:38 <lispy> (the answer my friend is blowing in the wind)
01:40:30 <Bourbaki> http://rafb.net/paste/results/LJZLjH34.html
01:40:48 <Bourbaki> the last call hexagramm 0
01:42:06 <roconnor> Bourbaki: yeah, just get rid of all the parameters
01:42:19 <lispy> hmm....your coding style is unconventional for haskell...so what is wrong in that paste?
01:42:31 <roconnor> flipCoin = do
01:42:31 <roconnor> 	val <- rollDice 2
01:42:31 <roconnor> 	return (coinVal val)
01:42:37 <roconnor> that will work fine
01:42:39 <roconnor> etc
01:43:02 <Bourbaki> ah ok thanks :)
01:43:10 <Cale> yeah, why is x mentioned there?
01:43:38 <roconnor> Bourbaki: if it helps, in some sense IO Foo is shorthand for RealWorld -> (RealWorld,Foo), so it is already a function.
01:43:40 <Bourbaki> where?
01:43:44 <lispy> in fact, if youcompile with -Wall ghc would complain about it :)
01:43:57 <Cale> Bourbaki: why is it a parameter to flipCoin?
01:44:29 <Cale> It seems like they're all passing around this x which is never used in the end
01:44:31 <Bourbaki> because i thought i had to give it a parameter
01:44:34 <Cale> oh
01:44:39 <Cale> yeah, you don't :)
01:44:39 <lispy> looks like flipCoin, line, shap and hexagramm all have that extra x
01:44:47 <Bourbaki> its the same with the () thingy i just asked
01:44:52 <lispy> yeah, you're lucky day :)
01:44:52 <Cale> you can define a constant IO action
01:45:06 <Bourbaki> AHA! thanks thats all i asked for :)
01:45:06 <lispy> s/you're/your/
01:45:17 <Bourbaki> so i can do the same thingy with the agent sementic thingy
01:45:38 <roconnor> Bourbaki: Boy, there is lots of fun haskell things to tell you about this code.
01:46:35 <Bourbaki> like :)?
01:47:02 <lispy> foo x = let str | ... could be changed to foo x | ltype = ... where ltype = ...
01:47:12 <lispy> then you wouldn't need that extra level of let
01:47:21 <roconnor> Bourbaki: To learn about classes and instances, you can make IGingCoin an instance of Random.
01:48:06 <Bourbaki> hm
01:48:06 <roconnor> Then you will be able to write flipCoin = getStdRandom random
01:48:44 <lispy> Bourbaki: also, you should learn about pattern matching
01:49:11 <roconnor> Of course, the total code will be about the same, because when you define IGingCoin as an instance of Random, you will probably call rollDice.
01:49:24 <roconnor> but the result will be niftier
01:49:46 <lispy> shapeShapeName "KienKien" = "KIEN / DAS SCH"; shapeShapeName "blah" = "foo"; and so on
01:50:08 <lispy> (but maybe you prefer the guards because it's less typing)
01:50:31 <roconnor> I have to go, but I'm sure someone here will be glad to teach you the Haskell idoims that you are missing.
01:50:43 <Bourbaki> not atm though :)
01:50:48 <Bourbaki> thanks alot anyway
01:50:55 <lispy> Bourbaki: you much have done a lot of ML programming in the past?
01:50:57 <Bourbaki> atm i need to write some other stuff in c++ :)
01:50:58 <roconnor> Of course, what you have written is fine for an beginner.
01:51:04 <Bourbaki> lispy no i did lisp
01:51:08 <lispy> hmm..
01:51:10 <lispy> ah
01:51:17 <lispy> yeah that would explain all the let's too
01:51:51 * lispy needs to sleep
01:51:57 <lispy> Bourbaki: good luck learning haskell
01:52:08 <lispy> Bourbaki: i'm glad i switched from lisp to haskell
03:39:57 <musasabi> hmm. Was there a way of doing modifyOrPutMVar_ :: MVar a -> (Maybe a -> IO a) -> IO () ?
03:44:04 <musasabi> With block, it may be possible I think.
03:48:37 <musasabi> modifyOrPutMVarPure_ :: MVar a -> (Maybe a -> a) -> IO ()
03:48:37 <musasabi> modifyOrPutMVarPure_ mvar fun = block (tryTakeMVar mvar >>= putMVar mvar . fun)
03:48:55 <int-e> @index block
03:48:56 <lambdabot> Control.Exception
03:50:59 <musasabi> I think it has the right semantics, otherwise e.g. readMVar would be broken.
03:51:25 <int-e> but it doesn't really deal with multiple threads, just with exceptions.
03:51:51 <jrmole> anyone around know parsec fairly well?
03:54:20 <musasabi> int-e: so what do you think are the semantics of this: do mv <- newMVar 1; forkIO (readMVar mv); writeMVar mv 2; takeMVar mv; ?
03:54:33 <musasabi> grah. that has an error.
03:55:15 <musasabi> int-e: so what do you think are the semantics of this: do mv <- newMVar 1; forkIO (readMVar mv); swapMVar mv 2; takeMVar mv; ?
03:55:32 <musasabi> hmm. that is correct too.
03:57:06 <int-e> the other thread may read 1 or 2; the original thread will read 1. that's ok. the assumption of readMVar is that putMVar can't block, as I understand it.
03:57:19 <int-e> sorry, the original thread will read 2.
04:03:01 <int-e> consider: do mv <- newMVar 1; forkIO (readMVar mv); forkIO (putMVar mv 3); swapMVar mv 2; takeMVar mv ... now you can't predict the final version of the mvar anymore. it could be 1 (readMVar reads, the rest proceeds, readMVar writes), 2 (putMVar before swapMVar) or 3 (putMVar comes last)
04:03:33 <SamB> doesn't putMVar block?
04:03:48 <SamB> what is the one that blocks?
04:03:50 <int-e> if the MVar isn't empty.
04:04:12 <SamB> oh, right
04:04:16 <int-e> takeMVar blocks if the MVar is empty, putMVar blocks if its full.
04:04:20 <int-e> it's
04:04:32 <SamB> the idea of swapMVar is that you are supposed to do something with the retrieved value, I think ;-)
04:04:43 <int-e> readMVar and swapMVar aren't atomic.
04:04:44 <SamB> I haven't a clue what use it is, though
04:04:47 <SamB> oh.
04:05:02 <musasabi> http://youzen.b2.fi/~musasabi/a.hs
04:05:33 <jrmole> does anyone have an example parsing floating point numbers (including negative) in parsec?
04:05:44 <int-e> musasabi: yes I think that can return 1.
04:07:32 <int-e> musasabi: but I can't be sure.
04:08:40 <int-e> . o O ( block (IO io) = IO $ blockAsyncExceptions# io )
04:09:00 <Igel> jrmole: wait a sec
04:09:20 <SamB> jrmole: of course someone has
04:09:43 <SamB> probably Blah.Blah.Blah.Parsec.TokenParser does too
04:09:57 <musasabi> mmh. Just adding a mutex MVar solves the problem.
04:10:05 <jrmole> they don't seem to accept negatives
04:10:10 <SamB> oh
04:10:17 <jrmole> or the form .3 (as opposed to 0.3)
04:10:18 <SamB> well, that is easy to fix
04:10:27 <SamB> that isn't so easy
04:10:30 <Igel> jrmole: http://paste.lisp.org/display/27644
04:10:30 <SamB> I might have something...
04:10:46 <Igel> all you have to do is add support vor negatives
04:11:12 <int-e> musasabi: but all blockAsyncException does is set a flag in the TSO, which means other threads shoukd be unaffected ...
04:12:32 <int-e> musasabi: so I'm pretty confident that 1 is a possible final result for a threaded RTS.
04:12:37 <jrmole> Igel, thanks, that's much better than how i was doing it :)
04:12:39 <Igel> jrmole: and, of course, you have to adept the constructor i've been using
04:12:48 <jrmole> yeah
04:12:49 <musasabi> int-e: yes, seems so after reading ML archieves.
04:12:50 <Igel> jrmole: np :)
04:13:08 <int-e> musasabi: yep, adding a real mutex will help of course :)
04:14:27 <SamB> jrmole: I could have sworne I had code for this...
04:16:04 <SamB> jrmole: clearly you will need to add support for numbers with no digits before the .
04:16:13 <jrmole> yeah, i'm working on that
04:16:26 <SamB> you'll need two alternatives, I'll warrant
04:17:08 <jrmole> at least
04:17:41 <Igel> jrmole: you could just add something like "sgn <- char '-' <|> return" just after the "do" in my code
04:17:55 <Igel> and then of course change the return to:
04:18:14 <Igel> return $ read (sgn ++ p ++ q)
04:18:48 <SamB> signedFloat = (char '-' >> liftM negate float) <|> float
04:18:58 <Igel> which i didn't do because i handled negative numbers with Text.ParserCombinators.Parsec.Expr
04:19:26 <jrmole> ah, that's pretty nice
04:20:11 <SamB> and then you'd have two alternatives in float, one to handle numbers with digits before the ., one to handle those without...
04:20:24 <SamB> you might need a "try" in the latter
04:20:25 <Igel> SamB where do i find the float parser?
04:20:39 <SamB> Igel: you find it in jrmole's code ;-)
04:20:52 <SamB> after he writes it
04:21:22 <Igel> ok i thought i'd missed it in the parsec package :)
04:22:21 <SamB> > read "1.0" :: Rational
04:22:23 <lambdabot>  Exception: Prelude.read: no parse
04:22:31 * SamB wishes it would
04:22:32 <Igel> jrmole: try this: http://paste.lisp.org/display/27646
04:22:59 <SamB> does that even typecheck?
04:23:07 <Igel> > read "1.0" :: Double
04:23:09 <lambdabot>  1.0
04:23:11 <araujo> morning!
04:23:17 <jrmole> no, return "" and char '-' have different types
04:23:22 <jrmole> i'm working on something similar to that though
04:23:24 <SamB> jrmole: exactly as I thought
04:23:45 * dcoutts_ darcs tags Cabal-1.1.6
04:23:53 <Igel> jrmole how about string "-" ?
04:24:25 <jrmole> i was thinking (char '-' >> return (-1)) <|> (return 1)
04:25:05 <Igel> jrmole that won't work if you want read to actually parse the double
04:25:24 <jrmole> sure it will, i can just multiply by that parser's result
04:25:35 <vincenz> > sequence [[1,2,3], [4,5,6], [7,8,9]]
04:25:37 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
04:25:38 <Igel> ok
04:27:06 <Igel> well, good luck anyway, i'm going now
04:28:23 <jrmole> thanks
04:28:24 <vincenz> > let merge3 (a:as) (b:bs) (c:cs) = a:b:c:merge3 as bs cs in let hamming = 1:merge3 (map (2*) hamming) (map (3*) hamming) (map (5*) hamming) in hamming
04:28:26 <lambdabot>  [1,2,3,5,4,6,10,6,9,15,10,15,25,8,12,20,12,18,30,20,30,50,12,18,30,18,27,45,...
04:30:06 <vincenz> hello AD
04:30:09 <vincenz> hello ADEpt
04:30:12 <SamB> jrmole: of course, its easier if you use Alex ;-)
04:30:18 <jrmole> yeah
04:30:27 <jrmole> but i like parsec for other reasons
04:30:30 <jrmole> for example, being pure haskell
04:30:33 <SamB> but Parsec no like seperate lexers
04:30:47 <jrmole> i thought it supported them now?
04:30:54 <SamB> how?
04:31:06 <SamB> it *can* work with them, but it doesn't seem pretty
04:31:21 <Itkovian> vincenz: hi.
04:31:38 <vincenz> hello Itkovian
04:32:21 <Itkovian> vincenz: sorry I wasn't able to chat at ACES, but (though it may have looked differently) I was actually busy discussing research that has a much higher priority than parsing trace files
04:32:55 <Itkovian> howcome you IMEC people usually only stay one day?
04:33:12 <vincenz> No problem :)
04:33:21 <vincenz> I do not know to be honest, I know some IMEC people were there to present a poster
04:33:27 <vincenz> as for myself, I came to meet someone specific
04:34:21 <SamB> what could have higher priority than parsing trace files ;-P?
04:34:29 <ADEpt> vincenz:
04:38:39 <SamB> ADEpt: hi
04:38:47 <SamB> bye also
04:38:53 <SamB> to school I go
04:39:09 <ADEpt> SamB:
04:39:17 <ADEpt> SamB: long time, no see :)
04:47:26 <TSC> Is there a handy library function for generating random numbers from a normal distribution?
05:08:46 <CrewdenX> TSC: i'm not well versed in haskell, but randomRIO seems to work.  check the code privmsg'd.
05:17:28 <TSC> CrewdenX: Thanks, but isn't that a uniform distribution
05:17:53 <TSC> I might have to use it to generate a normal distribution
05:18:21 <CrewdenX> "and returns a random value uniformly distributed in the closed interval [lo,hi]"
05:18:27 <CrewdenX> that's what the report says.
05:18:49 <CrewdenX> what do you mean by uniform then?
05:19:01 <TSC> Normal as in Gaussian distribution
05:20:05 <CrewdenX> sounds familiar, but i don't know what that is.
05:21:02 <TSC> The bell-shaped curve distribution
05:21:22 <CrewdenX> ok
05:23:47 <CrewdenX> why does wolfram redirect me from Gaussian Distribution to Inverse Gaussian Distribution.   Are they the same thing despite the naming?
05:24:54 <int-e> you're looking for 'Normal Distribution' I guess
05:25:55 <TSC> http://article.gmane.org/gmane.comp.lang.haskell.cafe/11511
05:25:59 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/f39pb
05:26:13 <TSC> I found one small library for Normal distributions
05:55:03 * araujo back
06:02:00 <yip> is there like a c2hs tutorial for idiots?
06:16:28 <bortzmeyer> What's the snd result in NUmeric.readHex?
06:16:34 <bortzmeyer> Prelude Numeric> readHex "89"
06:16:34 <bortzmeyer> [(137,"")]
06:16:39 <bortzmeyer> It does not seem documented?
06:16:54 <yip> > readHex "a"
06:16:56 <lambdabot>  [(10,"")]
06:17:02 <yip> > readHex "a9g"
06:17:03 <lambdabot>  [(169,"g")]
06:17:06 <integral> > readHex "123zzz"
06:17:07 <lambdabot>  [(291,"zzz")]
06:17:19 <falseep> > 8*16+9
06:17:20 <lambdabot>  137
06:17:43 <roconnor> @vixen Happy Thanksgiving!
06:17:43 <lambdabot> cool
06:18:06 <bortzmeyer> OK, so readHex returns the rest of the string, what it could not parse?
06:18:28 <roconnor> bortzmeyer: yep
06:18:43 <roconnor> this is the general nature of the ReadS structure.
06:19:08 <bortzmeyer> Any way to suppress it? I would like an error is the string is not completely parsable.
06:22:29 <integral> case readHex x of { [(_, str)] | str /= "" -> error ...; ... }
06:22:48 <bortzmeyer> integral: thanks, good idea
06:22:58 <integral> maybe
06:24:12 * gds discovers, at great length, on his local lambdabot that "@undefine funcname" doesn't just undefine the function "funcname"...
06:24:13 <lambdabot> gds: You have 1 new message. '/msg lambdabot @messages' to read it.
06:24:21 <gds> Oooh :)
06:31:14 <roconnor> OMG: http://www.haskell.org/onlinereport/pragmas.html
06:31:15 <lambdabot> Title: The Haskell 98 Report: Compiler Pragmas, http://tinyurl.com/h29cn
06:36:33 <integral> If I want to use a hash table, is Data.HashTable the best thing to use?
07:00:49 <yip> for ghc 6.6, do i want happy 1.15 or darcs happy?
07:02:51 <int-e> I've successfully compiled it with 1.15
07:07:23 <marcot> Hello there. I've written a class with fundeps, and an instance with the type (String, Int, Int, [(String, String)] (). It's used with a function that returns IO b, where b is the last argument ( () ).
07:07:53 <yip> int-e: no good, Array API changes in ghc
07:08:22 <int-e> yip: oh. I read the question the wrong way :)
07:08:31 <marcot> Sorry the type is (String, Int, Int, Maybe Int) ()
07:08:41 <int-e> I've not tried compiling happy 1.15 with ghc 6.6
07:08:48 <marcot> The compiler complains that there's no instance for (String, Int, Int, Maybe a) b
07:09:00 <marcot> When I call the function in a do expression.
07:09:54 <int-e> you'll have to fix either a or b I guess.
07:09:55 <marcot> The problem I think is that in the instance I write Maybe Int.
07:10:05 <marcot> And in the call I use Nothing.
07:10:14 <marcot> And it asks for an instance for Maybe a
07:10:23 <marcot> But it needs to be Maybe Int in the instance.
07:10:26 <roconnor> marcot: can you write it without the do notation?
07:10:36 <roconnor> using >>= and return
07:11:10 <marcot> But even when I use it in the last statement of the do expression, what makes the compiler identifies that the return is (), it complains about Maybe a /= Maybe Int.
07:11:18 <marcot> Because I call it with Nothing.
07:11:44 <roconnor> marcot: have you tried (Nothing::Maybe Int)
07:12:24 <marcot> roconnor: it works with this.
07:12:35 <marcot> But it's kind of ugly...
07:12:42 <marcot> Don't you think?
07:13:18 <explicitjelly> (it's like raaaaiiaaain, on your wedding daaaaay...)
07:13:42 <roconnor> marcot: You can make your own NoInt :: Maybe Int; NoInt = Nothing
07:14:14 <marcot> Yes, it's a better form
07:14:15 <roconnor> or perhaps there is another place you can put a type annotation
07:14:26 <marcot> But still Nothing will be better.
07:14:41 <roconnor> perhaps you can give a type annotation to your function that you are defining
07:21:22 <marcot> roconnor: this is harder. I've done noInt = Nothing
08:04:33 <Igloo> Can someone wiki-literate revert the accent-removal on http://www.haskell.org/haskellwiki/HaWiki_migration please? (the last change as of now)
08:04:36 <lambdabot> Title: HaWiki migration - HaskellWiki, http://tinyurl.com/fdokn
08:06:36 <ndm> Igloo: explain exactly what you want, and it can be done
08:07:14 <Igloo> ndm: Go to page history and look at Oleg's diff
08:07:47 <ndm> Igloo: you want all that reverting
08:07:59 <Igloo> Except the actual adding of Oleg to the list, yes
08:08:00 <ndm> ?
08:09:00 <vincenz> He adds his name in the beginning
08:11:58 <ndm> Igloo: reverted his change entirely
08:12:33 <ndm> Igloo: take a look at the history to see what i did
08:13:14 <Igloo> OK, so should I add him?
08:13:43 <ndm> Igloo: yes, i guess
08:14:57 <Igloo> OK, done, thanks!
08:16:38 <ndm> Igloo: for reference (since you're likely to be doing lots of wiki work) you go history, click on the revision you want to revert to (23:13, 8 October 2006  in this case), then click Save
08:18:41 <Igloo> Where do I find "Save"?
08:20:01 <ndm> "Edit this Page", "Save Page"
08:20:21 <Igloo> Ah, I see. OK, thanks
08:21:40 <Igloo> mediawiki doesn't have advisory locks, right?
08:24:31 <ndm> correct
08:24:40 <ndm> we got really lucky, someone edited a few seconds after :)
08:53:13 <jamiie> hello, anyone about?
08:53:37 <int-e> @users
08:53:45 <lambdabot> Maximum users seen in #haskell: 256, currently: 242 (94.5%), active: 20 (8.3%)
08:54:02 <ndm> jamiie: yes
08:55:23 <jamiie> I'm looking for help with some simple IO
08:56:01 <jamiie> I just picked up haskell and I can't quite figure out how to pull data out of IO monads
08:56:17 <wilx> You do not.
08:57:14 <jamiie> Specifically - I'm building a bloom filter with : dict = readFile "/usr/share/dict/words" >>= return . lines >>= return . makeBloom
08:58:15 <jamiie> But every time I match something against the filter, the file is reread and the filter rebuilt before matching. I don't understand how to divorce the data I want out of this file from the fact that it comes from a changeable file.
08:58:18 <ndm> do {x <- readFile "filename"; return $ makeBloom $ lines x}
08:58:39 <ndm> then to use it
08:58:55 <ndm> do {data <- myfunc; use data here, only read once}
08:59:49 <jamiie> I'm not convinced thats any different from what I was doing before, but I'll give it a go
09:00:43 <kpreid> do data <- readFile "file"; function <- makeBloom data; <use function>
09:01:05 <ndm> jamiie: the first bit isn't, the second bit is
09:07:24 <therp> is there actually some 80 chars/line limit in ghc sources?
09:08:27 <ndm> therp: no
09:08:50 <ndm> therp: oh, GHC may want it that way, as a coding convention, but theres no technical limit
09:08:51 <therp> ndm: because it seems that a non-existing limit is sometimes respected; sometimes not.
09:09:05 <therp> ndm: ah, yes I meant as coding convention
09:09:15 <glguy> 80char / line is just good coding practice
09:09:22 <therp> I just noticed because I wanted to print Parser.y with a2ps
09:13:52 <Igloo> < 80 char per line is strongly prefered, yes
09:14:40 <earthy> there's good cognitive reasons for that, even
09:26:32 <jamiie> ndm: works, thanks for the help. I can see why this works, but not how to extend it. Is there any way to create this dictionary at the top level, so that it is available to the whole module, without having to construct it more than once?
09:27:13 <jamiie> This is intended for use from ghci, so I cant just pass the dictionary down along the chain of computation
09:27:18 <ndm> jamiie: create it in main, then pass it onwards to all the appropriate methods
09:27:38 <ndm> ok, then create a function, withDictionary
09:29:10 <ndm> make all of your functions take a dictionary as the first argument
09:29:18 <ndm> and have withDictionary do the loading and passing
09:29:33 <ndm> withDictionary f = do {dict <- loadDictionary; f dict}
09:29:43 <ndm> then you just type:
09:29:54 <ndm> withDictionary $ myfunction, at the start of every lie
09:30:12 * musasabi senses a reader monad
09:32:44 <jamiie> but after that line has been evaluated if I then make another query using withDictionary then the dictionary would be recreated. Which is the problem. I understand how to pass things around within a normal program but not in interactive programs
09:34:10 <ndm> ah, you can define a top level function, wrapped in unsafePerformIO
09:34:18 <ndm> then the CAF will be saved, and the dictionary not created
09:34:29 <ndm> mydictionary = unsafePerformIO loadDictionary
09:34:35 <ndm> then pass mydictionary as the argument
09:34:41 <jamiie> I could always write : do dict <- loadDictionary; replLoop        to fake it out using a nested interpreter, but this seems unneccesarily ugly
09:34:53 <ndm> nah, the unsafePerformIO is what you want
09:35:15 <ndm> Haskell can't realise that your dictionary is the same every time
09:35:26 <ndm> by using unsafePerformIO, you communicate that to Haskell, so perfectly safe
09:35:33 <jamiie> Alright, I'll go for that. Doesn't seem to really violate trasparency as the dicts not going to change
09:35:43 <jamiie> Thanks for your help
09:35:45 <ndm> indeed
09:36:08 <jamiie> Ah, need to learn to type faster to get points in first
09:36:27 <jamiie> Thanks again
10:10:25 <svref_> dag nabbit, I feel like I *need* a function that returns true if two objects have the same address in memory.  Is this truly not possible in Haskell?
10:11:35 <monochrom> It may be possible in GHC.
10:11:47 <svref_> but is a bad idea...?
10:12:09 <monochrom> I would love to see why you think you need it.
10:12:29 <svref_> Okay, I've got a traffic simulation.
10:13:18 <svref_> The road description is a linked list of Data Feature = Straight ...lane layout... | LaneMapper ...how lanes change at merges, etc...
10:13:58 <svref_> the LaneMapper items have functions as datum, so I can't easily declare Feature to be a member of Eq.
10:14:35 <svref_> The Street features ... some are the same but not identical...
10:14:51 <svref_> Hm, guess I could look at the lenght of the list...
10:15:08 <svref_> Right!
10:15:09 <sjanssen> svref_: assign unique identifiers as you generate the streets?
10:15:20 <pejo> Out of curiosity - wouldn't "leaking" adresses to programs mess up the garbage collector horribly?
10:15:58 <svref_> every other damn gc'd language has a "pointer equal" function....
10:16:09 <sjanssen> pejo: yes, there are problems with garbage collection and getting raw addresses
10:16:38 <svref_> But if Haskell is cloning objects w/o permission, that would be Bad.
10:16:43 <pejo> svref, well, sounds like you're looking for object identity, rather than adress.
10:16:52 <svref_> true
10:17:00 <kolmodin> doesn't the gc move things around too? what if that happens during the pointer identity check?
10:17:04 <pejo> svref, why wouldn't a copying garbage collector be allowed to clone your objects?
10:17:22 <bringert> isn't there a reallyUnsafePointerEq# or something
10:17:40 <sjanssen> bringert: I think so, but I've heard it's really unsafe
10:17:53 <kolmodin> not only unsafe, but reallyUnsafe... that sounds really unsafe
10:18:10 <svref_> pejo: well as I read things, it currently is allowed to.  It just makes implementing the equality function as C's "==" a broken algorithm.
10:18:11 <monochrom> reallyreallyreallyUnsafe.....#####  :)
10:18:44 <sjanssen> svref_: pointer/identity equality isn't a very nice function
10:18:53 <svref_> ok
10:18:54 <monochrom> For a quick fix you can use it. Don't worry about really unsafe.
10:19:22 <sjanssen> for example, consider this fragment: MyConstructor x == MyConstructor x
10:19:43 <sjanssen> where == is the ptr equality operator
10:19:44 <monochrom> For a proper refactoring I would use unique identifiers given out by some kind of state monad.
10:20:08 <sjanssen> what if the compiler decides to float out the common expression and form: let e = MyContructor x in e == e
10:20:09 <wilx> @index Unique
10:20:09 <pejo> svref, do you want to ignore the functions as datum in the LaneMapper, or do you want a function comparison too?
10:20:10 <lambdabot> Data.Unique
10:20:54 <svref_> pejo: irrellevant at this point, since I realize now that my "unique identifier" is the distance in the list from [].
10:21:01 <bringert> sjanssen: what's the problem with that?
10:21:02 <Cale> If you're comparing pointers that way, you're probably doing something wrong. There are tools for making things like weak references and such.
10:21:28 <Cale> If all you want are unique id's, then you ought to use a monad for supplying them to your algorithm.
10:21:31 <sjanssen> bringert: the two code fragments will return different things.  Non identical in the first case, and identical in the second
10:21:42 <monochrom> Alternatively but equivalently, the road network is read from a file, and in that file you include unique identifiers already.  (It's equivalent because that means you get them from the IO monad, which is a kind of state monad.)
10:22:12 <bringert> right, I just assumed that anyone using poiter equality would follow it with a normal == if false
10:22:46 <svref_> So I'm guessing some implementations of Haskell are very good for distributed programming...
10:23:05 <sjanssen> bringert: sure there are workarounds, but it's still a bit nasty
10:23:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
10:23:14 <lambdabot> http://tinyurl.com/zrcmg
10:23:16 <svref_> because objects can be locally cached copies of objects
10:23:26 <bringert> fastEq x y = x `unsafePtrEq` y || x == y should be safe right?
10:23:54 <bringert> sjanssen: right, it's not something you should use for everyday stuff
10:24:37 <svref_> well I'm going to stick to everyday stuff until I know better.  :)
10:24:48 <Cale> bringert: you can use StableNames for that sort of comparison
10:35:46 <lispy> is it possible with cabal to pass cpp defines to the build?
10:35:51 <lispy> i should clarify
10:36:07 <lispy> is the following possible: ./Setup.lhs build -DFOO
10:36:24 <lispy> or do i need to do this in the cabal file?
10:42:14 <roconnor> @hoogle inline
10:42:15 <lambdabot> Distribution.Extension.InlinePhase :: Extension
10:42:15 <lambdabot> Network.Socket.OOBInline :: SocketOption
10:52:35 <roconnor> kun idereen nederland spreken?
10:57:44 <lispy> ?babel ne en kun idereen nederland spreken?
10:57:44 <lambdabot> babel module failed: IRCRaised Error: Language ne not supported
10:57:44 <roconnor> > exp (-pi*i)
10:57:45 <lambdabot>  Not in scope: `i'
10:57:51 <lispy> ?babel ee en kun idereen nederland spreken?
10:57:52 <lambdabot> babel module failed: IRCRaised Error: Language ee not supported
10:57:56 <lispy> ?babel de en kun idereen nederland spreken?
10:57:58 <lambdabot>  kun idereen nederland spreken?
10:58:02 <lispy> hmm..
10:58:09 <Magicman> nl
10:58:10 <roconnor> nl?
10:58:14 <lispy> ?babel nl en kun idereen nederland spreken?
10:58:16 <lambdabot>  can idereen speak the Netherlands?
10:58:24 <Magicman> Does everyone speak Dutch.
10:58:25 <lispy> heh, i got that mouch from it
10:58:27 <roconnor> obviously I can't spell idereen
10:58:31 <lispy> i wondered what idereen meant
10:58:37 <lscd> lispy: eh. iemand = anyone
10:58:48 <roconnor> iemand
10:58:49 <lispy> ah
10:58:50 <roconnor> crap
10:58:54 <Magicman> idereen = misspelling of iedereen; which is everyone.
10:58:55 <roconnor> I suck at this langauge
10:59:03 <roconnor> I mean iemand
10:59:11 <lscd> roconnor: join #debian-nl
10:59:23 <roconnor> ... which is obviously why I need help.
10:59:34 <lscd> i'm another newbie at dutch, but they're very friendly
10:59:49 <lscd> (it's where i learned the word 'iemand' too)
10:59:50 <roconnor> but maybe babel is all I need
10:59:51 <monochrom> Does it have type classes?
11:00:08 <lscd> roconnor: depends, what are you trying to do?
11:00:15 <roconnor> @babel nl en geef de ligginng aan van ...
11:00:16 <lambdabot>  indicate the ligginng of...
11:00:20 <roconnor> @babel nl en geef de ligging aan van ...
11:00:21 <lambdabot>  indicate the position of...
11:00:25 <dmhouse> Dutch is really similar to German. The German for 'someone' is 'jemand'.
11:00:38 <roconnor> lscd: I was trying to figure out what ligging meant
11:00:47 <roconnor> lscd: I guessed it meant location.
11:00:48 <lscd> dmhouse: yep.  i remember the german in terms of the dutch there
11:01:05 <lscd> no idea, that's beyond  my dutch still :)
11:01:32 <roconnor> lscd: babel translated it as position.
11:01:35 <roconnor> good enough for me
11:02:43 <lscd> yeah - if all you want to do is understand a bit of dutch, babelfish goes a long way (and if you're really lazy and want to put a few hours in sometime, http://learndutch.org/Lesson1/LearnDutch.html gave me a fairly decent passive understanding
11:02:45 <lambdabot> Title: Lesson 1 Introduction
11:03:17 <roconnor> babelfish does dutch?
11:03:33 <lscd> yep
11:03:35 <pejo> lscd, do you speak german since before?
11:03:38 * lispy uses babelfish a lot at work to translate german source code to english :)
11:04:03 <roconnor> lscd: I took dutch lessons for a year, a year ago.  I'm pretty assamed that I got iemand confused with iedereen.
11:04:08 <lscd> pejo: i speak a bit of german; enough to ask directions, not enough to talk, and nearly useless for irc since none of you can direct me to the nearest restaurant
11:04:15 <lscd> roconnor: eh... weekly?
11:04:34 <roconnor> I'm not so ashamed of misspelling iedeeren.  I was never very good at spelling in english either.
11:04:41 <roconnor> lscd: 6 hours a week or so.
11:05:16 <lscd> roconnor: eh - well, i took nearly that much french and italian for school for many years without really picking up any (i picked up bits later, but eh)
11:06:09 <roconnor> lscd: yeah, but I live in the netherlands. :)
11:06:43 <lscd> roconnor: i live in ticino, the italian part of switzerland - for my first 6 years here, i spoke barely enough italian to pass my italian-language classes (taught in english, at an english-speaking school)
11:07:05 <roconnor> lscd: ah, so you know waht it is like.
11:07:08 <lscd> yep
11:07:19 <roconnor> it's the vocabulary that gets me. ... So many words.
11:07:28 <roconnor> such as ligging
11:07:55 <lscd> yeah - there are a couple of things that help with that
11:08:37 <lscd> reading and listening to the radio/etc have helped me a lot with understanding german vocab; for actually being able to actively use it, what seems to work best is going out and speaking it and trying not to care that you sound .. very unfluent
11:08:46 <lispy> dcoutts_: aroundp?
11:08:54 <roconnor> lscd: why do you talk with?
11:09:04 <roconnor> er
11:09:04 <lscd> there's this one guy at my university who spoke no italian a year ago, and is at least on par, if not better than me at it at this point
11:09:07 <lscd> who?
11:09:07 <roconnor> who do you talke with.
11:09:28 <dcoutts_> lispy, aye
11:09:32 * roconnor 's brain isn't really connecting well with keyboard.
11:09:38 <lscd> anyone available; with german, i've been abusing my german-speaking classmate's ears, etc :)
11:09:54 <lscd> and eh, trying to make a little small talk at shops and so forth helps a bit
11:10:26 <lscd> probably the best thing for my actually being able to converse in italian is this little kurdish fast-food place i go to, since i actually talk to the people running it, in italian, most times i visit
11:10:28 <lispy> dcoutts_: i'm trying to hunt down that bug with the linking
11:10:46 <lispy> dcoutts_: would you be interesting in seeing the output of setup.hs build -v6?
11:10:56 <deadbeef> today i asked for the subject of my thesis
11:11:17 <deadbeef> the prof proposed me to improve the SLD resolution algorithm through the RETE algorithm
11:11:46 <roconnor> @babel nl en Bepaal de baan die x doorloopt.
11:11:48 <deadbeef> to reduce the complexity of the many-to-many pattern matching part
11:11:49 <lambdabot>  Stipulate the job which x passes through.
11:11:59 <roconnor> wow, stipulate
11:12:04 <lispy> dcoutts_: or v9 or whatever (currently trying to compile with -v6 to see if that gives enough info without giving too much)
11:13:13 <dcoutts_> lispy, aye, send it to cabal-devel
11:13:22 <lispy> dcoutts_: okay
11:14:27 <lispy> ?arr
11:14:27 <lambdabot> Drink up, me 'earties
11:15:22 <lispy> ya know, i bet i could find a minimal test case for this
11:15:46 <lispy> hm..what is something that doesn't garbage collect well and requires tons of memory?
11:16:05 <lispy> besides emacs
11:16:09 <lispy> i need this  in haskell code :)
11:17:10 <monochrom> foldl (+) 0 [1..10000000]
11:17:35 <monochrom> Or mapAccumL
11:18:05 <lispy> ah perfect
11:18:08 <lispy> thanks
11:18:24 <monochrom> On GHC, the space behaviour of mapAccumL varies by the garbage collector. :)
11:19:04 <monochrom> Using the default settings, blows up.  I fudge the number of generations, O(1).
11:21:40 <xerox> @babel en it fudge
11:21:42 <lambdabot>  fondente
11:21:53 <Magicman> :D
11:22:14 <xerox> I doubt it...
11:23:04 <therp> what does the haskell report mean by "unlike the algebraic datatypes, the newtype constructor N is unlifted." - what does lifted mean? I have seen that in a few function names.. liftIO, but what's the general meaning?
11:23:43 <xerox> therp: it could mean that it remains isomorphic to the type it wraps.
11:24:48 <monochrom> Consider the Bool type.  It has three values from our perspective.  True, False, bottom.
11:25:18 <therp> xerox: newtype requires explicit coercions, so that does exclude isomorphism doesn't it?
11:25:41 <monochrom> Suppose I define data More = Mucho Bool.  It has four values: bottom, Mucho bottom, Mucho True, Mucho False.
11:26:34 <monochrom> The three values Mucho bottom, Mucho True, Mucho False are from Bool itself, as you can see.  There is an extra bottom too.  This is lifting.
11:27:12 <monochrom> However, if you go newtype Same = S Bool, you don't have the extra bottom.
11:27:41 <therp> ah ok, do that's why it's called lifting because you get an extra layer below?
11:27:48 <monochrom> YES!
11:27:57 <therp> :) thanks monochrom
11:28:31 <monochrom> Since the values of Same are just S bottom, S True, S False, we say it's isomorphic to Bool.
11:30:01 <therp> I suppose when I have "newtype N = N int; foo (N i) = 42" and I evaluate "foo _|_" the reason I get 42 and not _|_ is because (N i) in the pattern match of foo is treated semantically as Int, right?
11:30:51 <monochrom> That gets me thinking.  Is it really that way?  What happens to foo _|_?
11:30:52 <therp> so it's only a syntactic coercion I'm seeing with newtype, done completely by the compiler
11:31:10 <int-e> for that newtype, N _|_ = _|_
11:31:24 <int-e> yes
11:31:32 <therp> monochrom: the haskell report 4.2.3 tells that. foo _|_ and foo (N _|_) gives 42.
11:31:49 <dcoutts_> therp, it's because you don't force the argument at all
11:31:51 <monochrom> Nice!
11:32:12 <int-e> hmm, I wonder. does that work in jhc?
11:32:12 <monochrom> Err pattern matching forces the argument.  But perhaps except newtype.
11:32:30 <therp> dcoutts: this is a function binding, and (N _|_) is a pattern, hence it would force a match if N would be a algebraic datatype
11:32:43 <dcoutts_> even if you never use any of the components ?
11:32:56 <dcoutts_> and it's only a single constructor
11:33:00 <kosmikus> yes
11:33:14 <dcoutts_> so it'd be different if I said:
11:33:18 <dolio> You'd need to make it irrefutable to avoid it, no?
11:33:20 <monochrom> "null" is an example.
11:33:20 <dcoutts_> data N = N !Int
11:34:16 <therp> doutts: http://www.haskell.org/onlinereport/decls.html#sect4.2.3 - there are a few examples
11:34:28 <lambdabot> Title: The Haskell 98 Report: Declarations, http://tinyurl.com/gjfyc
11:34:29 <monochrom> The values of that are: bottom, N 0, N 1, N 2, ....  just missing N bottom, but there is still bottom.
11:34:39 <kosmikus> dcoutts_: yes, data N = N !Int is different from newtype N = N Int
11:34:40 <dcoutts_> wow, yes it really is different to data N = N !Int
11:34:48 * dcoutts_ just tried it
11:34:52 <dcoutts_> I had no idea
11:35:13 <monochrom> The denotational lattice way is a very powerful way of explaining everything!
11:35:16 <dcoutts_> I thought newtype was just a representation optimisation to Data with a single strict field
11:35:35 <dcoutts_> I didn't realise the semantics were actually different
11:36:14 <araujo> I think the difference is about one being isomorphic (newtype), right?
11:37:06 <dolio> Is the difference then (in a manner of speaking) that data N = N !Int has _|_ but not (N _|_), whereas newtype ... has (N _|_) but not _|_?
11:37:15 <monochrom> The difference is how many different kinds of bottoms you can get :)
11:37:31 <monochrom> Right dolio, that's my understanding.
11:38:15 <monochrom> Every Haskell programmer should spend a year of sabbatical to learn lattice theory.
11:38:28 <monochrom> Perhaps that's why Haskell is not mainstream. :)
11:38:33 <xerox> haha
11:38:52 <kosmikus> so, everyone should be happy with OCaml then
11:39:44 <monochrom> That is not necessarily true.  OCaml prescribes a year of sabbatical on subtype theory.  I am not sure which evil is less.
11:40:10 <CosmicRay> monochrom: ocaml prescribes a year of sabbatical on writing portable makefiles.  we have cabal.
11:40:13 <dolio> Stick with SML, then. :)
11:40:27 <CosmicRay> I seriously used OCaml for a year and still never figured that out.
11:40:35 <monochrom> SML Functors are funky.
11:41:09 <lispy> dcoutts_: okay, i sent in everything i know with a minimal test case to reproduce it
11:41:20 <kosmikus> SML is really nice.
11:41:22 <roconnor> @hoogle Functor
11:41:23 <lambdabot> Prelude.Functor :: class Functor f
11:41:23 <lambdabot> Data.FunctorM :: module
11:41:23 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
11:41:27 <monochrom> Anyway I aced all of them so I think they're all trivial so I don't understand why everyone does not understand any of them!
11:41:28 <marcot> Hello there.
11:41:29 <CosmicRay> kosmikus: nicer than ocaml?
11:41:43 <roconnor> marcot: hi
11:41:46 <CosmicRay> kosmikus: because, really, ocaml felt like some language that hadn't changed much since the 80s
11:42:01 <CosmicRay> kosmikus: I mean, the standard library couldn't even open a file read/write.
11:42:02 <marcot> I'm calling two print in a do expression, one under the other. Then I call a function, and inside it there's another print.
11:42:04 <glauber_sp> guys, Do you have e-books about these topics you are talking? I want to learn algebra, types seen from algebra, algebraic specification of ADT, and so on =)
11:42:12 <marcot> It's printing only the first and the third print.
11:42:21 <marcot> Is there a kind of buffer for print?
11:42:31 <marcot> roconnor: =D
11:42:42 <roconnor> marcot: by default there is line buffering.
11:43:01 <marcot> I can't understand why it's not showing the second one. If I use putStrLn it shows.
11:43:16 <roconnor> that is strange
11:44:43 <marcot> Yes, very.
11:44:53 <roconnor> @paste
11:44:54 <lambdabot> http://paste.lisp.org/new/haskell
11:45:11 <roconnor> you can paste your code
11:45:20 <kosmikus> CosmicRay: nice not necessarily from a practical pov, but it's really very clean and neat.
11:45:51 <dolio> glauber_sp: I've heard this is good, although I have yet to read any of it: http://www.math.uwaterloo.ca/~snburris/htdocs/ualg.html
11:45:54 <lambdabot> Title: A Course in Universal Algebra, http://tinyurl.com/geezy
11:46:02 <dolio> There's some lattice theory in there, i tseems.
11:46:08 <marcot> It's kind of hard to separate the part of the code that's doing this.
11:46:16 <marcot> I'll try to do an small example here.
11:46:21 <kosmikus> CosmicRay: OCaml has a very efficient implementations and quite a few add-ons, some of them are useful, others not so much, but they make the language far less homogeneous and consistent as a whole compared to SML (all imho)
11:46:25 <dolio> And it has 36 whole illustrations, if the cover is speaking the truth.
11:47:51 <lisppaste2> marcot pasted "print problem" at http://paste.lisp.org/display/27669
11:48:03 <marcot> The last line of output is:
11:48:16 <marcot> antes
11:48:22 <marcot> And then:
11:48:29 <marcot> urban: Prelude.head: empty list
11:49:47 <roconnor> urban?
11:49:54 <monochrom> I cannot explain why only antes and not depois.
11:50:08 <marcot> urban is the name of the program.
11:50:14 <marcot> binary.
11:50:28 <marcot> I think the error is in show geom1.
11:50:29 <glauber_sp> dolio, I'll take a look on the pdf later, thanks =D
11:50:37 <marcot> But it's not a very logical thing.
11:50:51 <monochrom> No, show geom1 has no problem.
11:50:56 <roconnor> marcot: it does seem like a buffering problem.
11:51:10 <marcot> roconnor: got any idea about it?
11:51:11 <glauber_sp> guys, another n00b question: is there any free news server to acess news:comp.specification.* ?
11:51:23 <monochrom> "head $ head geom" focus on this.  The error message says "head" afterall.
11:51:30 <roconnor> marcot: I suspect head $ head $ geom is what is failing.
11:52:12 <marcot> But why isn't it showing depois?
11:52:30 <monochrom> Alright, "antes is the last thing printed" this is just obscured by buffering, ignore this fact.  "Prelude.head: empty list" this clearly points to "head".
11:52:43 <roconnor> marcot: because of both line buffering, and haskell's strange evaluation order, when a program fails, it can appear to fail at random places.
11:53:07 <marcot> but I want it to print the query and the values so I can debug.
11:53:15 <roconnor> marcot: you cannot really trust the output too much to guide you where the error is.
11:53:19 <monochrom> flush buffer
11:53:34 <monochrom> throw in Debug.trace
11:53:36 <roconnor> @hoogle flush
11:53:36 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
11:53:37 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
11:53:37 <lambdabot> IO.hFlush :: Handle -> IO ()
11:53:45 <roconnor> hFlush stdout
11:54:00 <monochrom> prove your program correct
11:54:09 <monochrom> (just kidding on the last one :) )
11:54:13 <marcot> I don't know what is Debug.trace.
11:54:51 <lscd> marcot: when I started with haskell, i always wanted to print stuff like that out - but it turns out that a combination of ghci, quickcheck, and unit testing tends to let me track stuff down pretty quickly, and in the case of the latter two, tell me when i accidentally broke something later as well
11:56:06 <marcot> hum..
11:56:26 <monochrom> I normally print this stuff to stderr, i.e., hPrint stderr geom1.  Much less bufferring.
11:56:27 <marcot> In this case there's database access envolved, so something may crash or not depending on what's in the database...
11:56:51 <marcot> hFlush stdout didn't change the result..
11:56:57 <lscd> marcot: fair enough; you can still quickcheck and/or unit test it though
11:57:01 <monochrom> Yeah although you still want to see the query string before you check the database, so your quest still stands, how to print stuff.
11:57:38 <monochrom> I wonder what's the Query monad.
11:57:44 <marcot> lscd: sure... print is not the better debug mode...
11:57:47 <lscd> create the query string independently of the function that you'll call to actually do the query?
11:58:02 <marcot> type Query a = Database -> IO a
11:58:04 <marcot> Very simple.
11:58:17 <lscd> marcot: yeah - the best debug mode i'm aware of is the smalltalk debuggers, though i hear the ocaml ones are good; haskell is still pretty weak here
11:59:08 <marcot> =(
11:59:56 <monochrom> where did you insert hFlush stdout?
12:00:32 <marcot> before the quickQuery
12:00:59 <marcot> Now I commented the return line.
12:01:08 <marcot> [[SqlString "POLYGON((0 0,0 1,3 1,3 0,0 0))"]]
12:01:10 <marcot> And printed geom
12:01:20 <marcot> so head $ head geom is not wrong.
12:02:10 <monochrom> > head $ head [[True]]
12:02:12 <lambdabot>  True
12:03:25 <marcot> I'm trying to see if there's something wrong with toMulti.
12:03:32 <marcot> But no.
12:03:43 <marcot>     print $ toMulti $ fromSql $ head $ head geom
12:04:23 <marcot> MULTIPOLYGON(((0 0,0 1,3 1,3 0,0 0)))
12:05:39 <marcot> But return $ toMulti $ fromSql $ head $ head geom make the problem.
12:05:55 <monochrom> If you restore the return line now, what happens?
12:06:55 <marcot> "antes"
12:06:56 <marcot> urban: Prelude.head: empty list
12:06:57 <marcot> Same thing.
12:06:58 <marcot> =(
12:09:22 <monochrom> Perhaps the problem is not in geom_function.
12:09:44 <marcot> monochrom: maybe after it?
12:09:53 <emk> Hello! I'm studying monad transformers with GHC, and I'm kind of stuck.
12:10:25 <marcot> But when I change the return line to return "ok" it goes foward on the code and gives an sql error just when i tries to use the result ("ok").
12:10:31 <emk> Is there any way to expand a type name like "ErrorT e (State s) a" and get the fundamental types?
12:12:15 <monochrom> Suppose you return "MULTIPOLYGON(((0 0,0 1,3 1,3 0,0 0)))" ?
12:12:43 <emk> i.e., s -> (Error e a,s) or something else at that level?
12:16:02 <emk> Googling "expand type names" (and several other phrases) doesn't seem to yield anything, and neither :type nor :kind does the right thing.
12:16:38 <jmmv> hi
12:16:39 <marcot> monochrom: good tip, let me try it.
12:17:03 <emk> jmmv: Hi!
12:17:53 <jmmv> what might be the best way to propagate errors?  Control.Exception?  The thing is that I'm currently using booleans and maybe's all around to detect errors and propagate errors up, but this is quite annoying...
12:18:26 <emk> jmmv: You can always just use ioError (or even error), and catch it in the IO monad.
12:18:37 <monochrom> Maybe, Maybe as a monad, Control.Monad.Error, Control.Exception
12:19:00 <jmmv> oh, I though error couldn't be caught
12:19:03 <monochrom> In increasing order of hackiness.
12:19:10 <emk> ?type ErrorT e (State s) a
12:19:12 <lambdabot> Not in scope: data constructor `ErrorT'
12:19:12 <lambdabot>  
12:19:12 <lambdabot> <interactive>:1:7: Not in scope: `e'
12:20:04 <jmmv> alternatively I could use exitWith (ExitFailure 1) all around... but uggh
12:20:14 <emk> ?kind ErrorT
12:20:16 <lambdabot> Not in scope: type constructor or class `ErrorT'
12:20:29 <emk> ?kind Control.Monad.Error.ErrorT
12:20:30 <lambdabot> * -> (* -> *) -> * -> *
12:21:21 <marcot> Do you know a good monad tutorial?
12:21:57 <lispy> ?where nomaware
12:21:57 <lambdabot> I know nothing about nomaware.
12:22:25 <lispy> marcot: read 'tackling the awkward squad'
12:22:36 <lispy> ?google tackling the awkward squad haskell
12:22:38 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
12:22:39 <lambdabot> Title: Simon Peyton Jones: papers
12:22:53 <marcot> What a name.
12:22:56 <lispy> marcot: they start from very simple and completely explain the IO monad
12:23:11 <marcot> hum..
12:23:15 <marcot> very nice, thanks.
12:23:28 <lispy> yw
12:23:29 <marcot> But I don't understand a bit of the name, I think my english is not good enough.
12:24:20 <sh10151> it doesn't reflect the content
12:24:40 <sh10151> it is idiomatic and rather silly
12:26:40 <marcot> I know, I was just joking..
12:28:14 <jmmv> emk: hmm thanks, I think ioError alongisde userError will do the trick
12:31:38 <jmmv> monochrom, so you think that using Maybe all around is better than using some kind of exceptions/errors?
12:32:21 <CosmicRay> jmmv: depends on what you're doing, but Either can also be useful
12:33:15 <emk> jmmv: Maybe and Either can both be very useful, especially if want to be able to catch the errors outside of the IO monad.
12:33:40 <monochrom> Using Maybe as a monad, the code looks the same as using the Error monad or the IO monad.  It's all do-blocks.
12:33:43 <jmmv> at the moment I'm reading a config file, ensuring its contents are correct (which means: check that some specific vars exist and that their contents are correct) and doing some other stuff later on with this config
12:34:17 <CosmicRay> jmmv: Dunno if it's useful for you, but MissingH.ConfigParser already does config file stuff, and it has quite a few examples of error monad usage.
12:34:34 <jmmv> let me check
12:35:43 <xerox> Another neat solution is using Config.hs and hs-plugins.
12:35:53 <jmmv> monochrom, that's the "problem"... there are so many nested do-blocks now that it's somewhat hard to follow
12:36:32 <monochrom> I like nested blocks.  Beats monolithic spaghetti.
12:36:38 <jmmv> (as you might have guessed, I'm a quite new to haskell ;)
12:38:47 <jmmv> just take a look at this, for example: http://www.netbsd.org/~jmmv/Sandbox.hs  (and don't get too horrified ;)
12:39:00 <marcot> How do I get HDBC Exceptions?
12:39:30 <marcot> I'm reading the hdbc api but I have no experience in exception treatment in haskell.
12:39:33 <CosmicRay> marcot: http://darcs.complete.org/hdbc/doc/Database-HDBC.html#v%3AcatchSql
12:39:36 <lambdabot> http://tinyurl.com/qll6l
12:40:17 <CosmicRay> marcot: That function takes two parameters: some action to do, and a function to run if there was an exception.  If there was an exception, then the exception itself is passed to the function.
12:40:31 <CosmicRay> you can also use handleSqlError if you want to just propogate them up as I/O errors.
12:40:40 <CosmicRay> marcot: does that make sense?
12:40:48 <marcot> CosmicRay: sure..
12:40:50 <marcot> Thanks.
12:41:24 <CosmicRay> an example: catchSql (quickQuery dbh "SELECT COUNT(*) from foo" []) (\e -> {- do something with exception e -} )
12:42:06 <CosmicRay> the ODBC exception type is at http://darcs.complete.org/hdbc/doc/Database-HDBC.html#t%3ASqlError
12:42:09 <lambdabot> http://tinyurl.com/z2way
12:42:09 <CosmicRay> s/ODBC/HDBC/
12:42:21 <CosmicRay> the values for its three fields will be specific to each database, however.
12:43:16 <CosmicRay> jmmv: examples I spoke of here: http://gopher.quux.org:70/devel/missingh/html/MissingH-ConfigParser.html#9
12:43:19 <lambdabot> http://tinyurl.com/h27w5
12:44:13 <gour> CosmicRay: will hdbc support extension-api?
12:44:22 <jmmv> thanks
12:44:25 <CosmicRay> gour: I have no idea what that is; can you enlighten me?
12:45:21 <CosmicRay> jmmv: BTW, a description of what ConfigParser does and an example of its file format is here: http://gopher.quux.org:70/devel/missingh/html/MissingH-ConfigParser.html#1
12:45:24 <lambdabot> http://tinyurl.com/z7hot
12:45:36 <marcot> CosmicRay: thanks, I'll try it here.
12:46:07 <gour> CosmicRay: ability to create user-defined functions, aggregates...
12:46:52 <jmmv> quite interesting
12:46:56 <CosmicRay> jmmv: also, you may be interested in some other functions in MissingH, such as http://gopher.quux.org:70/devel/missingh/html/MissingH-Path.html#v%3Abrackettmpdir
12:46:59 <lambdabot> http://tinyurl.com/z3tdx
12:47:22 <gour> CosmicRay: i am mostly thinking about sqlite back-end
12:47:26 <CosmicRay> and safeSystem in MissingH.cmd
12:47:54 <CosmicRay> gour: I am not terribly familiar with that, but are you referring to functions that are stored in the DB itself?  Like PostgreSQL's PLpgsql?
12:48:09 <CosmicRay> gour: with postgresql, at least, you create them with regular queries, so that would be fine with HDBC
12:48:33 <CosmicRay> I've done a bit of work with triggers with sqlite, I think, and it worked out fine
12:49:24 <gour> CosmicRay: see eg. http://sqlite.org/capi3.html, section 2.3
12:49:25 <lambdabot> Title: C/C++ Interface For SQLite Version 3
12:49:39 <CosmicRay> gour: what part of it?
12:49:48 <CosmicRay> oh
12:49:51 <CosmicRay> section 2.3.
12:49:52 <CosmicRay> I'm blind.
12:50:38 <CosmicRay> gour: if I read this write, this is a function written in C that can be called from a SQL query?
12:51:17 <gour> CosmicRay: yes, other languages support the same mechanism, perl, php, pythong, java, ruby
12:51:19 <ihope> So you guys are saying that Word is as good as Word#?
12:51:42 <CosmicRay> gour: I don't plan to write it myself, but patches would be accepted ;-)
12:51:56 <gour> CosmicRay: i understand :-)
12:52:01 <CosmicRay> gour: one thing I have thought about, and haven't found any great solution for, is how to permit special functions on a per-db basis.
12:52:19 <CosmicRay> gour: each DB has its own internal data type, and I don't want to turn Connection into Connection a
12:53:07 <gour> CosmicRay: i have to become more familiar with hdbc itself to get some useful idea
12:53:48 <CosmicRay> the packages are split up with this sort of thing in mind for the future
12:53:59 <CosmicRay> the catch is putting private data of an arbitrary type in a Connection
12:54:08 <CosmicRay> we'd almost have to make Connection a typeclass instead of a record.
12:54:21 <CosmicRay> but then that gets annoying for people that would like to have lists of connections of various types, etc.
12:55:17 <jmmv> are the missingh libraries intended to be eventually included into the base libs?
12:55:29 <Lemmih> jmmv: No.
12:55:50 <jmmv> ok
12:55:50 <CosmicRay> jmmv: not specifically, though there are a handful of functions in missingh that have made it into the base libraries.
12:56:03 <CosmicRay> I submit them to the GHC people where appropriate.
12:56:19 <therp> the report uses _|_ for evaluation that do not terminate, right? bottom aka undefined
12:56:28 <jmmv> aha, so ConfigParser is yours! :)
12:56:42 <CosmicRay> jmmv: yes, I'm guilty of that ;-)
12:57:28 <CosmicRay> this is the second time a wrote ConfigParser actually -- I wrote it in OCaml first, to have something that was compatible with Python's ConfigParser
12:58:26 <CosmicRay> so you can find a ConfigParser with pretty much the same interface and same file format in three languages
12:58:53 <jmmv> pretty neat
12:59:29 <jmmv> I haven't got to the point of reading the config file yet (just using a hardcoded Map for now), but this seems to fit my idea of the config file quite well
13:00:11 <CosmicRay> yup.  I liked it because it can be very simple (flat file, no sections, with comments), or can scale to multiple sections, defaults, and interpolation
13:00:38 * jmmv is installing MissingH
13:01:32 <jmmv> hmm, dinner time; bbl
13:02:55 * CosmicRay also notes that ConfigParser can modify and write config files.
13:03:49 <gour> CosmicRay: so extension api is not trivial...
13:04:10 <CosmicRay> gour: yeah, callbacks into Haskell are also not a part of FFI that I've studied yet
13:05:36 <gour> CosmicRay: what do you think about eg. bindings for libgda/gnomedb and putting hdbc-like layer over it?
13:06:23 <CosmicRay> gour: that would make sense.  Those are similar to ODBC, right?
13:07:19 <gour> CosmicRay: well, i cannot say for sure, but libgda-2.0 brings some nice abstractions and gnome-db provides db-related widgets
13:15:25 <glguy> Every time I look at 10pt Tahoma anti-aliased text, it makes me smile so big I could cry (-,:
13:15:59 <marcot> Good night, guys.
13:19:28 <SamB> cool, my patch was accepted ;-)
13:21:00 <SamB> roconnor: try your code with latest GHC from darcs ?
13:27:55 <svref> Is there some equivalent to C language's "return x" statement, where you can escape out of a deeply nested computation and return a value from a named outer block?
13:28:27 <xerox> I think you can get that effect within the Cont monad.
13:29:48 * svref 's head explodes
13:30:06 <xerox> I think it's simple enough.
13:30:09 <sylvan> svref: You mean like a "goto"? We don't take kindly to gotos around these here parts...
13:31:00 <svref> sylvan: return is a structured goto that is not considered harmful.
13:31:09 <kolmodin> sylvan: :)
13:31:18 <norpan> gotos for exception handling is ok
13:31:25 <SamB> sylvan: what do you call that there "tail recursion"?
13:31:26 <norpan> at least in my book
13:31:39 <sylvan> ad hoc return, breaks, continue, etc. are gotos in disguise..
13:31:45 <dfranke> sylvan: I think he means more along the lines of lisp's 'block'
13:32:31 <svref> sylvan: perhaps you'd like Pascal...
13:32:35 <sylvan> Maybe I'm misunderstanding then... Do you want to exit the computation somewhere arbitrarily in the middle?
13:32:41 <yip> function application in haskell is goto :D
13:32:47 <SamB> so has anyone tried recompiling their bitshift-using programs with the latest GHC yet to see how much faster they are?
13:33:40 <dfranke> You could do it with something that's almost-but-not-quite a Maybe monad.
13:34:04 <svref> maybe I could bang it into shape to use the maybe monad
13:34:23 <dwm> Or Either if you want something more serious to happen, eh?
13:34:27 <svref> studying http://www.nomaware.com/monads/html/contmonad.html
13:34:29 <lambdabot> Title: The Continuation monad, http://tinyurl.com/jmvbc
13:35:54 <dfranke> ?hoogle Either
13:35:55 <lambdabot> Prelude.Either :: data Either a b
13:35:55 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
13:37:35 <gaal> say, in http://www.haskell.org/haskellwiki/New_monads/MonadBase, with overlapping instances couldn't we simply write instance MonadBase a a where liftBase = id -- or maybe need a forall there
13:37:39 <lambdabot> Title: New monads/MonadBase - HaskellWiki, http://tinyurl.com/r8qx2
13:37:43 <SamB> hmm
13:37:52 <SamB> does anyone happen to know where the inliner is?
13:38:23 <dwm> Hm. What about the Error monad? Just doing some reading, quickly. I haven't used it yet.
13:38:44 <dwm> http://www.nomaware.com/monads/html/errormonad.html
13:38:47 <lambdabot> Title: The Error monad, http://tinyurl.com/hgna5
13:39:47 <roconnor> SamB: why does it make a difference to use the latest darcs code?
13:40:42 <roconnor> SamB: think I can just get away with core GHC?
13:41:46 <roconnor> SamB: how latest is latest?
13:45:02 <monochrom> Tomorrow's GHC backported today!
13:45:08 <glguy> what would be a better definition for: lookup r $ zip [1..] deck
13:45:29 <glguy> it's like a (!!) that fails with a Nothing
13:45:35 <monochrom> hmm does lookup r give a list?
13:45:36 <glguy> (1 based indexing aside)
13:45:58 <glguy> ?type Data.List.lookup
13:46:00 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
13:46:06 <glguy> example:
13:46:14 <xerox> > findIndex (=='2') "the quick fox did something"
13:46:15 <lambdabot>  Nothing
13:46:22 <xerox> > findIndex (=='s') "the quick fox did something"
13:46:22 <lambdabot>  Just 18
13:46:26 <glguy> that might work
13:46:36 <glguy> oh
13:46:37 <glguy> no
13:46:38 <xerox> > findIndices (=='h') "the quick fox did something"
13:46:40 <lambdabot>  [1,23]
13:46:46 <glguy> I want to know what character is at position r
13:46:50 <glguy> that's what my code does
13:46:55 <glguy> and Nothing if that is out of bounds
13:47:36 <roconnor> Mon Oct  9 04:09:06 CEST 2006  Samuel Bronson <naesten@gmail.com>
13:47:36 <roconnor>   * Inline shift in GHC's Bits instances for {Int,Word}{,8,16,32,64}
13:47:38 <glguy> like: f n default xs = (xs ++ (repeat default)) !! n
13:47:45 <xerox> > elemIndex 3 "foo bar baz"
13:47:45 <lambdabot>  add an instance declaration for (Num Char)
13:47:50 <roconnor> SamB, how does it work?
13:47:52 <xerox> > elemIndex 'a' "foo bar baz"
13:47:53 <lambdabot>  Just 5
13:47:57 <xerox> Yuck.
13:48:19 <glguy> > lookup 2 [(1,'a'),(2,'b'),(3,'c')]
13:48:21 <lambdabot>  Just 'b'
13:48:37 <glguy> > lookup 2 $ zip [1..] "abc"
13:48:39 <lambdabot>  Just 'b'
13:48:42 <xerox> That's probably optimal.
13:48:51 <monochrom> Yeah
13:49:07 <xerox> If you want, (. lookup) . zip [1..] ;)
13:49:13 <glguy> heh
13:49:23 <glguy> I just thought "return $ fromMaybe x $ lookup r $ zip [1..] deck" might be hard to understand
13:49:57 <monochrom> Um, if you use fromMaybe anyway, why not !!
13:50:11 <glguy> > "abc" !! 10
13:50:13 <lambdabot>  Exception: Prelude.(!!): index too large
13:50:18 <glguy> monochrom: ^^
13:50:31 <monochrom> And "fromMaybe Nothing" what will that be?
13:50:42 <xerox> (fromJust barfs, monochrom.)
13:50:52 <monochrom> OOOOHHHH!!!!!
13:50:54 * monochrom hides
13:50:56 <xerox> fromMaybe = flip maybe id -- if I'm getting it right
13:51:12 <glguy> yeah, it returns x on Nothing
13:51:24 <monochrom> OK very nice.
13:51:39 <roconnor> configure: error: Happy version 1.15 or later is required to compile GHC.
13:51:47 <roconnor> um
13:51:52 <roconnor> where do I get that?
13:52:12 <monochrom> http://www.haskell.org/happy/
13:52:14 <lambdabot> Title: Happy: The Parser Generator for Haskell
13:54:06 <roconnor> ah, aptitude install happy
13:54:34 <glguy> is there a better way to say: f x | x `elem` [1,3,7] = a x | x `elem` [4,6,10] = b x | otherwise = c x
13:56:33 <monochrom> short of f 1 = a x; f 3 = a x; f 4 = b x; ...   :)
13:57:02 <monochrom> I think what you have is very readable.
13:57:31 <glguy> It made sense to me, I just wondered if it was common (c:
13:57:59 <roconnor> glguy: you could give the expression x `elem` [1,3,7] a name in a where clause.
13:58:06 <roconnor> if that is helpful
13:58:12 <glguy> I like that idea
13:59:00 <monochrom> And the name will be...  drum roll...  is1or3or7 ?
13:59:16 <roconnor> :)
13:59:18 <glguy> isChance x = x `elem` [7,22,36]
13:59:45 <roconnor> glguy: you can even do isChance = x `elem` [7,22,36]
13:59:49 <glguy> I was cleaning up my monopoly "sim" code from Project Euler to show a friend as a simple Haskell examlpe
13:59:59 <monochrom> I need to dig up that Dijkstra writing that says names should be meaningless.  That will clear up a few things.
14:00:10 <glguy> roconnor: good point, x is already in scope
14:00:37 <glguy> monochrom: how do you mean?
14:00:47 * roconnor wonders how long GHC take to build
14:01:02 <SamB> not *all* names should be meaningless ;-)
14:01:13 <glguy> roconnor: If I start it at lunch then it's usually done when I leave work
14:01:41 <roconnor> oh god
14:01:51 <roconnor> I suppose I can run it overnight
14:02:17 * roconnor no longer likes SamB's idea of trying the latest darcs version of GHC.
14:02:17 <glguy> roconnor: that is on my:
14:02:21 <glguy> hw.model=AMD Athlon(TM) XP1700+ ("AuthenticAMD" 686-class, 256KB L2 cache)
14:02:48 <glguy> so depending on your processor your speed will obviously vary
14:03:08 <roconnor> right
14:03:29 <roconnor> then I will do this on the the university machine
14:03:35 <SamB> well, I patched it on a 450 MHz PII ;-)
14:03:45 <SamB> granted, I did not pull the latest first
14:04:02 <SamB> and I only rebuilt in "libraries/base"
14:04:17 <SamB> also I added
14:04:19 <SamB> SplitObjs = NO
14:04:24 <SamB> to my mk/build.mk
14:04:30 <roconnor> SamB, I think a possibly useful test would be to write sha2sum with my sha2 library, and run a speed comparision.
14:04:45 <roconnor> although I'm not sure exactly how much time is spent shifting bits.
14:05:13 <roconnor> I'm really trying to get dons UM to be more readable.
14:05:20 <SamB> basically, I wanted to let you know that I've got the "shift" operator to inline
14:05:26 <SamB> I used a hammer
14:05:40 <roconnor> SamB, Do you think alway inlining shift is a good idea?
14:06:09 <SamB> well, if it turns out to worsen performance in some cases somehow, I'm sure we'll come up with something ;-)
14:06:35 <SamB> like maybe implementing shiftR and shiftL instead, and {-# INLINE #-}ing those
14:08:49 <yip> dcoutts: hello
14:09:32 <glguy> was this the Dijkstra writing you were referring to? http://www.cs.utexas.edu/users/EWD/transcriptions/EWD01xx/EWD155.html
14:09:36 <lambdabot> Title: E.W. Dijkstra Archive: Context Dependent Names (EWD 0155), http://tinyurl.com/nxfts
14:11:10 * roconnor is depressed about the state of programming
14:11:22 <SimonRC> Suddenly... *click*
14:11:27 <SamB> roconnor: you mean because it takes so long to recompile GHC?
14:11:47 <SimonRC> ... IORefs and/or STRefs are first-class variables.
14:12:00 <SimonRC> No need for many of the uses of LISP macros.
14:12:05 <SimonRC> Now that's cool.
14:12:11 <roconnor> SamB, no, that bounds checks should have been optimized away when a constant is passed in.
14:12:33 <SimonRC> (Assuming the use of an imperative programming style.)
14:12:49 <SamB> roconnor: they would have been if GHC hadn't for some reason refused to inline the workers for shift...
14:13:47 <roconnor> SamB, I wonder, do you think that GHC is inlining things in the wrong order?
14:14:06 <SamB> roconnor: it just plain didn't do it
14:14:07 <glguy> I know this is ugly, but I'm strangely attracted to the use of =<< (c:   c <- lift . specialCases =<< gets . advance =<< lift roll
14:14:20 <SimonRC> @type roll
14:14:21 <lambdabot> Not in scope: `roll'
14:14:24 <SimonRC> :-S
14:14:29 <roconnor> If it inlines shiftRL# into shift first
14:14:29 <glguy>          roll = do
14:14:29 <glguy>             a <- getRandomR diceBounds
14:14:29 <glguy>             b <- getRandomR diceBounds
14:14:29 <glguy>             return (a+b)
14:14:39 <roconnor> then maybe shift looks to big to inline.
14:14:45 <SamB> roconnor: could be...
14:14:48 <roconnor> but if it inlined shift first
14:15:00 <roconnor> and then inlined shiftRL#
14:15:05 <roconnor> everything would look small
14:15:11 <glguy> roll = join (liftM2 (+)) (getRandomR diceBounds)
14:15:13 <roconnor> just a thought.
14:15:22 <roconnor> I'm not sure how to test this idea
14:15:35 <glauber_sp> @help
14:15:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:16:03 <SamB> roconnor: first it inlined shift, then it pulled something out of the instance dict, and for some reason it refused to inline that.
14:16:07 <SamB> or maybe I missed a step.
14:16:32 <roconnor> SamB, can you follow the -ddump-inlines?
14:16:47 <SamB> not without reading the source ;-)
14:17:33 <SamB> Considering inlining
14:17:33 <SamB>     DataziBits.zdwshift{v r43} active: True
14:17:37 <SamB> ...
14:17:38 <SamB> 			       ANSWER = NO
14:17:40 <roconnor> okay, if you say it inlined shift before inlining shiftRL#, I will believe you.
14:17:54 <SamB> that is where it gets stuck
14:18:27 <SamB> see, it won't inline the method
14:18:38 <roconnor> It would be better to understand why it isn't inlined.
14:18:48 <roconnor> SPJ said it was too big
14:18:51 <SamB> also, I might point out that it can't inline a primop ;-)
14:19:00 <yip> @seen dcoutts
14:19:00 <SamB> yeah, I'm looking at that now...
14:19:01 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 17m 27s ago.
14:19:56 <roconnor> I can believe it is too big.  It is a little complex before the branching is eliminated.
14:20:02 <SamB> yeah
14:20:50 <SamB> oh, wait, shiftRL# isn't a primop...
14:20:59 <roconnor> nope
14:21:05 <SamB> hrmm.
14:21:19 <SamB> well, as I said, I did use a hammer for this job ;-)
14:21:45 <roconnor> you systems people, ... always looking for a quick fix.
14:21:48 <roconnor> ;)
14:22:45 <SamB> if someone actually used a variable shift amount...
14:24:08 <SamB> if *you* can come up with a better way, maybe using NOINLINE to keep shiftRL# and such from being inlined until after shift and friends have had a chance...
14:24:14 <SamB> ... go ahead ;-)
14:24:41 <roconnor> wait what?
14:25:01 <roconnor> are you saing that shiftRL# is inlined first?
14:25:05 <SamB> well.
14:25:08 <SamB> it might be.
14:25:16 * SamB looks at interface files
14:25:38 <SamB> I keep forgetting that it isn't a primop
14:25:40 <roconnor> presumablly this information is encrypted in the -ddumpt-inlinings
14:25:52 <SamB> nah
14:26:10 <SamB> I'm fairly sure that it is in the interface file, if anywhere
14:28:42 <SamB> in mine, yeah, it seems to be inlined first
14:28:50 <roconnor> ah ha
14:28:55 <SamB> that is, in my 6.4 installation
14:29:55 <roconnor> still, although it might work if it inlines in the other order, it still feels like the wrong approach
14:30:23 <yip> SamB: do you know anything about c2hs?
14:30:30 <roconnor> the fact that I'm passing in a constructor / closed term, sould activate some potential optimisation regardless of the complexity of the function.
14:30:32 <SamB> yip: not a whole lot
14:30:46 <yip> SamB: ok, then i guess i need to talk to my main man dcoutts :|
14:31:35 <SamB> well, the inliner is too idiotic to tell that it has some SWEEET builtin rules to apply if only it inlines that function ;-)
14:33:14 <kaffeewoller> hi. can you point me to some tutorial for true beginners? i mean, i really just heard that haskell is a nice thing.
14:34:00 <kaffeewoller> and i am totally new to programming at all
14:34:08 <SamB> the haskell.org frontpage doesn't have any listed?
14:34:19 * SamB hasn't been a Haskell newbie in a long time
14:35:23 <SamB> maybe...
14:35:28 <SamB> @wiki Introduction
14:35:29 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
14:35:38 <SamB> might that be useful?
14:36:08 <kaffeewoller> yes, sure it will! this is what i wanted, thanks
14:36:46 <SimonRC> kaffeewoller: If you ever do a course on a more "conventional" programming language, your Haskell experience may have odd effects.
14:37:01 <yip> guys, please keep an eye out for dcouttz, and if he comes around give me a hollar... thanks!
14:37:10 <yip> positive effects :)
14:37:16 <SimonRC> Like extreme moaning, bigotry, fervour, etc.  ;-)
14:38:07 <SamB> kaffeewoller: he's just warning you that most languages are so much worse to code in that you will not like to use them
14:38:15 <SimonRC> welll...
14:38:23 <SimonRC> they are *different*.
14:38:38 <SimonRC> People converting the other way have similar problems.
14:39:04 <SimonRC> Though I have rarely been told that Java is clearly a superior language to Haskell.
14:39:23 <SamB> well, more like trouble understanding Haskell than all those other things
14:39:28 <SamB> perhaps moaning
14:40:24 <SimonRC> I liked (in a silly kind of way) how SADOCP introduces mutable variables as an advanced feature near the end.
14:40:37 <SimonRC> * SAIOCP, IIRC
14:41:08 <Adamant> SICP?
14:41:17 <kaffeewoller> i understand!
14:41:34 <SimonRC> Adamant: yeah, that book
14:41:49 <Adamant> yeah. mutable variables screw up modeling bigtime
14:42:21 <SimonRC> But aren't too bad if you know what you're doing.
14:42:33 <Adamant> right.
14:42:59 <SimonRC> And the fact that IORefs/STRefs are first-class in Haskell is quite nice.
14:43:12 <Adamant> knowing a Lisp makes learning Haskell easier, I think
14:43:26 <Adamant> although I'm still wrapping my head around monads.
14:43:33 <SamB> well at least it makes it easier to pronounce (:)
14:43:41 <SamB> ;-)
14:43:43 <SimonRC> heh
14:43:53 <SimonRC> I tend to call () "nil".
14:44:10 <Adamant> the only thing I don't like about Haskell so far, is that it has precidence rules.
14:44:17 <SimonRC> really?
14:44:18 <yip> () has always bothered me whenever i see it
14:44:20 <SimonRC> I find that handy
14:44:24 <SamB> well, at least they aren't rules per se
14:44:31 <Adamant> they're pretty sane
14:44:33 <yip> it seems that () has no reason for existing, so it should not exist
14:44:35 <SamB> they are declarations ;-)
14:44:35 <Adamant> but they are there.
14:44:38 <SamB> yip: sure it does
14:44:45 <SamB> it is good to pass to things that want as
14:44:46 <SimonRC> yip: oh boy are you wrong there
14:45:06 <SamB> also it is great where in C you'd have a void return type (for imperative things)
14:45:11 <SimonRC> yes
14:45:31 <yip> you mean IO ()?
14:45:35 <SimonRC> I was irritated in C# not to be able to refer to the type of the class in type signitures.
14:45:36 <SamB> yeah
14:45:38 <SimonRC> yip: yes
14:45:55 <SamB> or with Parsec, etc etc
14:46:48 <yip> well, you shouldn't have to do IO (), there should be two types of IO, one that performs action and returns value, and one that only performs action. data ReturnIO a = ...; data OnlyIO = ...
14:46:48 <SimonRC> I wanted an abstract class where the return type of some methods was equal to the *runtime* type of the object they were being called on.
14:47:06 <SamB> yip: that wouldn't >> right
14:47:07 <SimonRC> yip:   Control.Monad.ST
14:47:18 <yip> SamB: that's why you don't have >>
14:47:20 <SamB> SimonRC: you not listen
14:47:22 <SimonRC> yip: oh wait, misreadit
14:47:28 <SamB> yip: you do though
14:47:32 <SamB> because IO is a Monad
14:47:49 <yip> such a system with distinction between ReturnIO and OnlyIO would ensure that returned values are never ignored
14:48:02 <yip> maybe you are right in that you would no longer have a monad
14:48:05 <SamB> yip: a fairly silly thing to do
14:48:16 <SamB> especially silly to only do it for Monad
14:48:18 <SamB> er, IO
14:48:31 <SamB> but anyway.
14:48:52 <SamB> If you think special casing all the monads for not returning is practical...
14:49:05 <SamB> (or for returning no value, rather...)
14:49:09 <SimonRC> Ignoring of return values is only a real problem when they indicate error conditions, which should be dealt with in other wayis in Haskell anyway.
14:49:48 <yip> SimonRC: a value is returned for a reason. if you ignore it, then either the function is broken or your code is broken
14:49:57 <SamB> yip: not necessarily
14:50:08 <SamB> it might be a value that is sometimes useful
14:50:12 <SamB> but not always needed
14:50:17 <SimonRC> indeed
14:50:26 <SimonRC> See (again) Parsec.
14:50:27 <yip> then the function should be split up
14:50:37 <SimonRC> How?
14:50:44 <SamB> duplicating code is an improvement?
14:51:00 <yip> it's not duplicating code, it's seperating functionality that may be useful in isolation
14:51:15 <SamB> listen, if you wanted that value, you wouldn't have just dropped it on the floor now would you?
14:51:15 <SimonRC> split up into what, though?
14:51:42 <SamB> say you want to use an MVar but you don't care to put anything in it...
14:51:56 <yip> i believe that the type system can help catch errors of ignoring return values where they shouldn't be ignored. and it's not just about errors, it's about maybe misunderstanding how to use the function
14:52:13 <SamB> are you going to depend on the people who wrote the threading library to have been as prone to duplicating code as you are?
14:52:19 <roconnor> I often use sequence_, and that runs sequence, and drops its value (I assume).
14:52:30 <SamB> roconnor: I assume it does not ;-)
14:52:37 <SimonRC> lazy eval helps greatly here
14:52:45 <Igel> hi there, i've got a problem transforming a 2-dimensional array in a list of its rows
14:52:49 <Igel> i tried
14:52:49 <roconnor> @hoogle sequence_
14:52:50 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
14:52:55 <SamB> roconnor: otherwise why wouldn't you just use sequence?
14:53:01 <roconnor> @fp Prelude
14:53:01 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:53:01 <Igel> intersperse "\n" $ [ line | line <- [ concat (show array!(x,y)) | x <- [1..n^2] ], y <- [1..n^2] ]
14:53:20 <Igel> so a nested " [ ... ] " expression
14:53:29 <SamB> yip: there really are a bunch of functions you might not need values from
14:53:32 <shapr> musasabi: awake?
14:53:33 <Igel> but it gives the following error:
14:53:40 <yip> SamB: how about an example?
14:53:45 <Igel> not in scope: 'y'
14:53:55 <SamB> hmm
14:53:59 <Igel> any ideas?
14:54:28 <SimonRC> Igel: the two parts of the second half of the outer comprehension are the wrong way round
14:54:47 <SimonRC> the sencond half of a comprehension is understood from left to right, so you need...
14:55:00 <Igel> so the y<- needs te be before the line<- ?
14:55:12 <SimonRC> [ line | y <- [1..n^2], line <- [ concat (show array!(x,y)) | x <- [1..n^2] ]]
14:55:16 <SamB> yip: I don't remember where they are off the top of my head
14:55:16 <SimonRC> Igel: yes
14:56:17 <roconnor> SamB: okay you are right
14:56:20 <yip> SamB: i agree that in practice () is very useful and conveniant. it just doesn't feel very "statically typed" to me
14:56:27 <SamB> well, except if you want to takeMVar a MVar (), which you are using as a mutex
14:56:48 <roconnor> SamB, none the less sequence_ uses (>>) which discards its value.
14:56:49 <musasabi> shapr: pong
14:56:57 <SamB> really, I think practicality in terms of being able to write the code must always be a consideration ;-)
14:57:08 <shapr> musasabi: Why doesn't this work? app GET _ requrl@['w':'i':'k':'i':'/':rest] = sresult 200 $ show requrl
14:57:27 <xerox> s/[/(/ s/]/)/ ?
14:58:06 <musasabi> shapr: app GET _ ("wiki":rest) = sresult 200 $ show rest
14:58:07 <roconnor> shapr: why the list of a list?
14:58:20 <SamB> yip: and really 90% of the bugs of this kind in C would be due to ignoring error returns, and 90% of the rest are probably involve declaring a variable to hold the return value but forgetting to set the variable in the call...
14:58:27 <shapr> musasabi: Thanks, I'll try that.
14:58:35 <shapr> roconnor: I thought it was necessary.
14:58:42 <roconnor> ok
14:58:51 <SamB> yip: you wont see either of those in Haskell much
14:59:40 <yip> i agree
15:00:39 <SamB> and that leaves us with the other 1%, which are probably "I'm still writing this code, damnit!", or something like that...
15:00:57 <musasabi> SamB: one can do all sorts of fun bugs with Haskell too.
15:01:24 <SamB> musasabi: we are talking about errors with ignored return values
15:03:15 <shapr> Aw, I just missed CosmicRay, I wanted to ask him about SIP providers that do incoming phone numbers.
15:05:44 <musasabi> SamB: one can do variations of that with e.g. ignoring exceptions.
15:06:06 <Igel> SimonRC, i still don't get it working
15:06:11 <Igel> by now i got:
15:06:14 <Igel>  [ line | y <- [1..n^2], line <- (concat [ (show (array!(x,y))) | x <- [1..n^2] ]) ]
15:06:44 <Igel> the error message is: "couldnt match [Char] against Char"
15:07:03 <Igel> referring to the very first "line" statement
15:07:08 <SamB> musasabi: yeah, but that requires actual work ;-)
15:07:29 <SamB> whereas ignoring return values merely requires a lapse of vigilance
15:07:32 <Igel> looks like "line" is a Char
15:07:39 <Igel> but i don't get why
15:07:53 <Igel> because its a concatenation of Chars
15:08:10 <SamB> > [x | x <- 1]
15:08:11 <lambdabot>  add an instance declaration for (Num [a])
15:08:12 <lambdabot>   In a list comprehension: x <-...
15:08:19 <SimonRC> what happens if you evaluate just that expression?
15:08:27 <SamB> Igel: see, the thing to the right of the error is supposed to be a *list*
15:08:38 <SamB> er, rather "arrow" than "error"
15:08:53 <SimonRC> SamB: oops, yes, quite right.
15:09:08 <SimonRC> try [ line | y <- [1..n^2], let line = (concat [ (show (array!(x,y))) | x <- [1..n^2] ]) ]
15:11:45 <SamB> roconnor: okay
15:11:47 <Igel> SimonRC: thanks, that works just fine
15:11:48 <Igel> :)
15:12:12 <SamB> I found some stuff to help me interpret the "Considering inlining" messages
15:12:35 <SimonRC> How to get rid of a dynamic-typing weenie:  Ask them how to implement "read" in their language (or any other polymorphic function that dispatches solely on return type).
15:12:50 <roconnor> SamB I need to head to sleep now
15:12:53 <SamB> in like the CoreUnfolding constructor defined in coreSyn/CoreSyn.lhs
15:12:54 <shapr> lennart: How much time do you spend in planes? It seems like you spend every other month in Sweden / USA.
15:13:00 <SamB> roconnor: okay then ;-)
15:13:14 <roconnor> I hope to hear about it tomorrow
15:13:27 <SimonRC> How to get rid of SimonRC: wait until 22:13 UTC.
15:13:30 * SimonRC goes to bed.
15:14:25 <Philippa> SimonRC: thanks for the laugh - I like the way you think!
15:26:47 * SamB wonders if anyone will complain about shift being inlined...
15:26:56 <Igel> is there anything wrong with the expression
15:26:57 <Igel> data SDKField n = (Ix n) => SDK n (Array (n, n) (Maybe n))
15:26:59 <Igel> =
15:27:00 <Igel> ?
15:27:06 <sjanssen> grrr!  I don't like it when shift is inlined
15:27:14 <sjanssen> ;)
15:27:49 <Igel> because ghci keeps saying "could not deduce (Ix n) from the context ..."
15:28:30 <xerox> Yeah, you don't want the constraint there, Igel.
15:28:49 <sjanssen> Igel: does GHC complain about the data declaration, or somewhere else?
15:29:09 <Igel> sjanssen: no, only in functions using it
15:29:25 <Igel> xerox: but there is no way to get an Array without this constraint
15:29:37 <Igel> and i don't feel like writing it in every single declaration
15:29:46 <xerox> Let the compiler infer them?
15:29:48 <sjanssen> Igel: you'll have to repeat the Ix i constraint in each function signature
15:29:59 <SamB> sjanssen: well, see, it has like four branches in most of the versions I've seen...
15:30:06 <sjanssen> constraints on data decls are nearly useless
15:30:31 <SamB> sjanssen: I'd say they *are* useless, personally
15:30:35 <Igel> so what are they used for, then?
15:30:54 <sjanssen> Igel: they only constrain the type of the constructor
15:31:02 <SamB> or rather, worse than useless, because they are allowed but don't do what you'd want them to do...
15:31:29 <Igel> i mean, you see, that the data type is *useless* if n is no instance of Ix
15:31:46 <sjanssen> so you can't *construct* a non-bottom SDKField without satisfying the constraint
15:32:36 <Igel> even the (only) function constructing an SDKField needs (Ix n)
15:33:44 <sjanssen> Igel: not exactly
15:33:56 <Igel> what do you mean?
15:33:57 <sjanssen> because there's bottom to consider
15:35:07 <sjanssen> @type undefined -- I could constrain this to the type SDKField a
15:35:09 <lambdabot> forall a. a
15:36:33 <Igel> a yes
15:36:51 <Igel> i need to get rid of this strict-evaluation-thinking :)
15:36:54 <Igel> thanks
15:39:58 <Igel> > undefined == undefined
15:39:59 <lambdabot>  Add a type signature
15:40:09 <Igel> > undefined :: Bool == undefined :: Bool
15:40:10 <lambdabot>  Parse error
15:40:35 <Igel> > (undefined :: Bool) == (undefined :: Bool)
15:40:37 <lambdabot>  Undefined
16:10:06 <SamB> hmm
16:10:28 <dcoutts> yip, c2hs?
16:11:01 <yip> dcoutts: hi, yeah, i am interested in making bindings for this library in a similar way to gtk2hs and i was wondering if you could help me since i am totally stuck
16:11:02 <SamB> the When C is Better section in http://haskell.org/haskellwiki/Introduction needs to mention that quickSort is not a very good choice for linked lists, too, I think...
16:11:04 <lambdabot> Title: Introduction - HaskellWiki
16:13:11 * shapr kazoings
16:14:37 <SamB> shapr: why kozoingest thou?
16:14:50 <SamB> er, *kazoingest
16:14:54 <dcoutts> yip, read the c2hs tutorial and then look at some c2hs examples, eg the cairo bindings (part of gtk2hs)
16:15:34 <dons> ?users #haskell
16:15:35 <lambdabot> Maximum users seen in #haskell: 256, currently: 224 (87.5%), active: 29 (12.9%)
16:15:43 <yip> dcoutts: yeah i've been reading this stuff, i guess i'll read some more
16:16:17 <dcoutts> hia dons
16:17:02 <dcoutts> dons, btw I plan to spend some time tomorrow afternoon looking at review comments, you might get some patches sent
16:17:13 <lisppaste2> dibblego pasted "is there an existing function(s) to achieve this?" at http://paste.lisp.org/display/27682
16:17:14 <shapr> SamB: I'm havin fun with HAppS. After years of doing Python/Zope/Plone with occasional bits of PHP & ASP, HAppS is oh so pleasant!
16:17:34 <yip> shapr: does HAppS have file uploads yet?
16:17:59 <dibblego> shapr, care to elaborate on "pleasant"? I got the hello world up yesterday, but got lost after that - need to read up more
16:18:03 <shapr> I don't know, haven't tried that yet, I'm just hacking together a wiki right now. I could try doing file uploads of page content as well.
16:18:22 <shapr> dibblego: Have you done the tutorial?
16:18:23 <sjanssen> dibblego: intersperse
16:18:37 <dibblego> shapr, yes that's what I mean - I couldn't understand much after getting hello world working
16:18:41 <dibblego> sjanssen, thanks, I'll take a look
16:18:53 <shapr> I've extended the tutorial with one example by combining the change_state and xslt examples. Now I'm writing a wiki for the example after that.
16:18:58 <dibblego> shapr, something about states and monads and transformers :)
16:19:27 <sjanssen> > concat $ intersperse "," ["one", "two", "three"]
16:19:29 <lambdabot>  "one,two,three"
16:19:47 <dibblego> sjanssen, ta
16:20:20 <shapr> I've not looked into the depths of HAppS much, I'm approaching it from the perspective of someone who needs to build a website for a client (which I do).
16:20:36 <dons> dcoutts: ok. i was going to look at them today
16:20:43 <dibblego> shapr, I'd be very curious to know of your progress
16:21:15 <shapr> I need to build a website for a client with integrated PayPal support and it needs to be done in less than a month.
16:21:22 <dcoutts> dons, today I'm thinking of which bits to present in a talk tomorrow :-)
16:21:41 <dibblego> shapr, do you feel as if you are taking a risk?
16:21:44 <dcoutts> dons, and which bits to defer to a second talk later in term
16:21:44 <rufus> sorry cale i can't /msg you
16:21:45 <rufus> but
16:21:49 <rufus> BAN his ass in #math!
16:21:53 <shapr> if I can't get this website working with HAppS, I'll go with the evil but familiar Plone.
16:21:55 <rufus> i was banned by doing the same shit except i did it by accident
16:21:58 <rufus> he keeps doing it over and over
16:22:30 <rufus> also unban me plz i got measujre theory q's :)
16:22:41 <dibblego> shapr, do you have a blog?
16:22:44 <dons> rufus: this isn't the appropriate place..
16:23:06 <shapr> dibblego: Nah, no risk. If I can get the website mostly working in HAppS this week, then the next three weeks will give me time to do it right.
16:23:31 <shapr> dibblego: http://www.scannedinavian.com/hope/
16:23:52 <shapr> I was originally planning on doing the website with Hope, and I may still end up sticking pieces of Hope on top of HAppS, we'll see how it goes.
16:24:00 * rufus pokes cale
16:24:18 <shapr> rufus: Dude, take it off of #haskell
16:24:34 <Cale> rufus: what?
16:24:58 <rufus> 16:21] <rufus> sorry cale i can't /msg you
16:24:58 <rufus> [16:21] <rufus> but
16:24:58 <rufus> [16:21] <rufus> BAN his ass in #math!
16:24:58 <rufus> [16:21] <shapr> if I can't get this website working with HAppS, I'll go with the evil but familiar Plone.
16:24:58 <rufus> [16:21] <rufus> i was banned by doing the same shit except i did it by accident
16:24:58 <rufus> [16:21] <rufus> he keeps doing it over and over
16:25:09 <shapr> rufus: Either identify with nickserv or create a new nickname if that one isn't yours, then you won't spam #haskell
16:25:11 <dibblego> /kick rufus
16:25:15 <rufus> also unban me i got legit q's about measure theory lol
16:25:16 --- mode: ChanServ set +o shapr
16:25:20 <Cale> rufus: sorry, what?
16:25:21 <rufus> dude who is this knob
16:25:23 <rufus> 16:21] <rufus> sorry cale i can't /msg you
16:25:23 <rufus> [16:21] <rufus> but
16:25:23 <rufus> [16:21] <rufus> BAN his ass in #math!
16:25:23 <rufus> [16:21] <shapr> if I can't get this website working with HAppS, I'll go with the evil but familiar Plone.
16:25:23 <rufus> [16:21] <rufus> i was banned by doing the same shit except i did it by accident
16:25:23 <rufus> [16:21] <rufus> he keeps doing it over and over
16:25:24 --- kick: rufus was kicked by shapr (Kicked by shapr)
16:25:44 <shapr> He doesn't listen.
16:26:01 <Itkovian> yeah!
16:26:04 <Itkovian> kick some ass!
16:26:10 <shapr> I can see why he was banned from #math
16:26:12 <Cale> I don't understand what he was trying to communicate there
16:26:30 <dibblego> that he has an attention problem
16:26:31 <Cale> If he was recommending that I ban someone from #math, he didn't specify who
16:26:46 <shapr> Yeah, he doesn't do input or output well.
16:27:05 <rufus> err sorry
16:27:08 <rufus> i'll paste again
16:27:08 <rufus> 16:21] <rufus> sorry cale i can't /msg you
16:27:08 <rufus> [16:21] <rufus> but
16:27:08 <rufus> [16:21] <rufus> BAN his ass in #math!
16:27:08 <rufus> [16:21] <shapr> if I can't get this website working with HAppS, I'll go with the evil but familiar Plone.
16:27:10 <rufus> [16:21] <rufus> i was banned by doing the same shit except i did it by accident
16:27:12 <rufus> [16:21] <rufus> he keeps doing it over and over
16:27:13 <shapr> NO
16:27:16 <rufus> can you read it this time
16:27:16 <Itkovian> holy fuck
16:27:18 --- kick: rufus was kicked by shapr (Kicked by shapr)
16:27:25 <Itkovian> clearly, we could :-)
16:27:30 <Cale> rufus I can read it
16:27:31 <rufus> i'm trying to get something done
16:27:31 <Itkovian> dude
16:27:33 --- kick: rufus was kicked by shapr (Kicked by shapr)
16:27:42 <rufus> you guys are the ones making a goddamn game out of it
16:27:45 <Cale> rufus: but it doesn't say anything useful
16:27:47 --- mode: ChanServ set +o dons
16:27:49 --- kick: rufus was kicked by shapr (Kicked by shapr)
16:27:52 <Itkovian> haha
16:27:57 <Cale> uh, hang on
16:27:59 <shapr> Now if only I could remember how to ban...
16:28:01 <Itkovian> fun at 1:30 AM
16:28:03 <Cale> what's he actually trying to say?
16:28:06 * rufus sighs
16:28:07 <dons> i'll get it, shapr
16:28:09 <rufus> cale i can't /msg you
16:28:10 --- kick: rufus was kicked by shapr (Kicked by shapr)
16:28:12 <dibblego> /ban *@cc102e10.inre.asu.edu
16:28:13 <shapr> dons: thanks
16:28:14 <Itkovian> Cale: don't ask
16:28:17 <rufus> dude
16:28:17 --- mode: dons set +b *!*i=dawg@*.inre.asu.edu
16:28:17 --- kick: rufus was kicked by dons (dons)
16:28:22 <Cale> er, okay
16:28:28 --- mode: ChanServ set -o dons
16:28:35 <Itkovian> @karma +shapr
16:28:35 <lambdabot> +shapr has a karma of 0
16:28:41 <Itkovian> argh
16:28:52 <shapr> I ban so rarely that it takes me several minutes to figure out the syntax.
16:29:01 <Itkovian> @karma shapr
16:29:02 <lambdabot> shapr has a karma of 22
16:29:09 <Itkovian> @karma shapr +1
16:29:10 <shapr> Yay!
16:29:10 <lambdabot> shapr has a karma of 22
16:29:16 <Itkovian> hmm
16:29:21 <shapr> I think it's @karma+ shapr
16:29:21 <dons> shapr, hehe. after Cale's stalker i ended up writing macros for doing it :}
16:29:23 <Itkovian> @karma shapr +
16:29:24 <lambdabot> shapr has a karma of 22
16:29:28 <dons> shapr++
16:29:33 <shapr> Cale's stalker??
16:29:52 <Cale> heh, just some idiot which got pissed off with me for banning him from #math one time
16:29:59 <Igel> @karme shapr
16:29:59 <Itkovian> @karma+ shapr
16:30:00 <lambdabot> shapr has a karma of 23
16:30:00 <lambdabot> shapr's karma raised to 24.
16:30:03 <Cale> QPT/Jason Pawloski, if you know him
16:30:09 <Cale> He's a bit of a famous troll.
16:30:10 <Itkovian> sigh
16:30:10 <shapr> I knew Cale was cool, but I didn't know he had cute women stalking him or something.
16:30:21 <Cale> No, no cute women
16:30:48 <shapr> I had some cute women stalking me, but that's really off topic for #haskell...
16:31:08 <Philippa> *snigger*
16:31:34 <Philippa> see, if it were me the first thing you'd know is the knife in your back ;-)
16:31:46 * beelsebob_ poiks Philippa 
16:31:55 <shapr> Well, they weren't trying to kill me...
16:32:05 <Philippa> beelsebob_: what's up?
16:32:11 <beelsebob_> typing problems
16:32:17 <beelsebob_> I need classes... but I can't have them
16:32:38 <shapr> Still, it's pretty scary when women find you several hours drive away from your house. And it's happened to me with two different women.
16:32:47 <dons> #math must be a wacky place
16:33:05 <shapr> dibblego: Do you have any specific questions about HAppS?
16:33:22 <dibblego> shapr, no, I just need to learn haskell more so that the tutorial makes sense, but thanks
16:33:51 <shapr> Ok, feel free to ask me when you get there.
16:34:17 <dibblego> ta
16:34:37 <dons> dibblego: are you Tony M ? :)
16:34:47 <dibblego> dons, that's me, why is that?
16:35:15 <dibblego> dons, not the QC that was all over the tv a while back :)
16:35:52 <vegai> I remember someone doing the SoE makeChange function with a one-liner
16:35:59 <vegai> do I remember correctly? Can it be done?
16:36:33 <vegai> (so that it was quite concise too)
16:40:41 <Igel> thanks once more for helping a noob :)
16:40:43 <moonlite> is sequence static? If so can it be defined lazily?
16:40:46 * Igel is going to bed
16:40:47 * vegai ponders.
16:41:23 <dcoutts> yip, aye?
16:42:24 <shapr> moonlite: Static?
16:42:36 <yip> dcoutts: the library i'm working with is c++, so i'm making a c wrapper around it so i can make haskell bindings. only problem is that the library uses STL a lot and i have no idea what the best way to wrap these are. ideally a function like void foo(std::list<int>); should be translated into haskell foo :: [Int] -> IO ()
16:43:01 <yip> dcoutts: but i have no idea how to design the C api, and then how to get c2hs to work like this
16:43:07 <shapr> I don't think sequence affects laziness, I think the monad instance will be the place to look for strictness.
16:43:09 <dcoutts> yip, hmm, nasty.
16:43:25 <moonlite> shapr: hm, wrong word? i'm meaning as in the opposite of lazy
16:43:50 <dcoutts> yip, probably easiest to go via C arrays, Haskell can marshal Haskell lists to C arrays ok.
16:44:07 <Philippa> moonlite: with monads, >>= doesn't necessarily mean strict sequencing - and the function sequence is defined in terms of >>=
16:44:11 <moonlite> ah strictness
16:44:13 <yip> dcoutts: yeah... but what about things like hash map?
16:44:20 * vegai notices scanl...
16:44:31 <Philippa> it can't safely be defined lazily on strict monads
16:45:05 <shapr> moonlite: Ã¤r det static pÃ¥ svenska?
16:45:21 <dcoutts> yip, so do you need to convert the whole data structure between C++ and Haskell, or can the C++ objects be manipulated abstractly without converting all the data and just applying operations ?
16:45:28 <moonlite> shapr: nej, blandade ihop uttryck bara. :)
16:45:33 * shapr vet inte hur man talar om funktionella programmering pÃ¥ svenska...
16:45:44 * moonlite same
16:45:53 <dcoutts> yip, if it really needs to be converted then you need to use some kind of intermediate format
16:46:20 <shapr> It's hard to find Swedish speakers in Birmingham Alabama.
16:46:24 <moonlite> obviously i don't know the english lingo either :)
16:46:27 <yip> dcoutts: it needs to be converted
16:46:32 <dcoutts> yip, eg for a mapping you could use two arrays, one of keys, one of values
16:46:59 <yip> dcoutts: i suppose
16:47:32 <yip> dcoutts: if i go for such approach then i will get an "intermediate" haskell function that has 2 lists, and then i will need to wrap this haskell function with my final haskell function that converts a haskell map into two haskell lists?
16:47:34 <dcoutts> yip, there's no automagic way of converting complex C/C++ data structures
16:48:17 <dcoutts> yip, yes exactly, you have the haskell function that provides the high level data type and then does the marshaling to the low level
16:48:39 <dcoutts> yip, eg the Haskell one might be a list of pairs, or a Data.Map for example
16:49:56 <yip> dcoutts: ok thanks, just one other thing that's not clear. i have a c struct that is "opaque", i need to only pass it back into the library functions, but i can't seem to make a haskell type for it
16:50:15 <yip> dcoutts: it's like: struct FooBar { void *p; };
16:50:23 <yip> dcoutts: the p actually points to a c++ object
16:50:32 <dcoutts> yip, typically you just use a pointer to the opaque thing
16:50:45 <syntaxfree> http://www.janestcapital.com/ocaml.htmlhttp://www.janestcapital.com/ocaml.html
16:50:48 <lambdabot> http://tinyurl.com/zhvaj
16:50:53 <yip> dcoutts: thing is, my c function is like: int create_foo_bar(FooBar*);
16:50:54 <dcoutts> yip, eg Gtk2Hs does this for all its Gtk objects
16:50:57 <syntaxfree> I was looking at haskell-cafe on gmail and that came up.
16:51:15 <yip> dcoutts: i want this function to turn into haskell function createFooBar :: IO FooBar
16:51:17 <SamB> yip: so you newtype FooBar () and then have a Ptr FooBar
16:51:22 <dcoutts> yip, since it's a struct containing the pointer then you should marshal the struct explicitly
16:51:38 <dcoutts> yip, use c2hs's pointer hook, that makes it easy
16:51:51 <dcoutts> yip, and make it an instance of Storable
16:52:40 <lispy> ?seen palomer
16:52:40 <lambdabot> I haven't seen palomer.
16:52:45 <yip> dcoutts: hm...... ok thanks i'll see what i can do!
16:54:03 <yip> btw if anyone is interested this library i am working with is ogre 3d graphics engine =]
16:54:16 <yip> i think it would be really cool if we could use this from haskell
16:54:34 <yip> dcoutts: and it even can work with gtk! :D
16:54:53 <dcoutts> yip, cool
16:58:45 * SamB wonders how long before someone complains about shift being always inlined...
17:00:19 <lispy> heh
17:00:28 <lispy> SamB: when would it be a bad thing?
17:01:03 <SamB> lispy: when the second argument was not a constant
17:01:38 <SamB> because then GHC wouldn't be able to decide which of four cases applied...
17:04:18 <lispy> SamB: well, can you trick ghc into doing the wrong thing with your new code?
17:05:24 <dcoutts> dons, am I going mad, or did padl chaneg where their hosting? why did I think it was going to be in Minnesota in the US?
17:05:38 <dcoutts> their/they're
17:05:44 <dons> hmm? you're going crazy?
17:05:53 <dons> Nice!
17:06:29 <dons> remember that this year it was in Charleston. you were thinking of that (?)
17:06:45 <SamB> lispy: not "wrong", per-se, but it would have to put in all four cases, including three branches...
17:06:58 <moonlite> this (http://pastebin.com/803689) seemed like a pretty elegant implementation of a word scrambler, but it dies from stack size overflow which im guessing is from some strictness and the repeat. Is it because i use the list outside of the IO context that "rs" is strictly evaluated?
17:07:32 <dons> stack overflows are almost always due to lazy accumulators in recursive code
17:07:35 <dons> (or foldl)
17:07:51 <Igloo> dcoutts: Did you look up PADL 2006?
17:07:55 <SamB> dons: did you see that my patch went in?
17:08:00 <dcoutts> Igloo, perhaps I did
17:08:01 <dons> SamB: yep. good.
17:08:18 <dons> dcoutts: you booking tickets already or something?
17:08:34 <SamB> I wonder if anyone actually uses shift with really variable arguments...
17:08:34 <dcoutts> Igloo, hmm no that was somewhere else, I dunno.
17:08:41 <newsham> http://markbyers.com/moinmoin/moin.cgi/ShortestSudokuSolver
17:08:46 <lambdabot> Title: ShortestSudokuSolver - Mark Byers' Website, http://tinyurl.com/hu8jf
17:08:50 <Igloo> Expensive mistake to make, anyway  :-)
17:08:51 <dcoutts> dons, well no need for where it is now, that's easy.
17:09:18 <dons> yep
17:11:17 <lispy> Igloo: do you work on the win32 ghc stuff at all?
17:11:35 <Igloo> Yes
17:11:49 <shapr> \users
17:11:58 <lispy> Igloo: did you see my bug about the default rts heap size being different than what the manual says?
17:12:01 <dons> ?users
17:12:04 <lambdabot> Maximum users seen in #haskell: 256, currently: 226 (88.3%), active: 35 (15.5%)
17:12:09 <dons> shapr: ^^
17:12:09 <dons> :)
17:12:17 * shapr grins
17:12:20 <Igloo> Didn't SimonM close that?
17:12:25 <shapr> 256 is a good record to have.
17:12:27 <dons> > 2^8
17:12:28 <lambdabot>  256
17:12:30 <dons> > 2^9
17:12:31 <lambdabot>  512
17:12:38 <lispy> Igloo: ah, i didn't check, but i had a new question about it
17:12:39 <yip> be nice if lambdabot would report the maximum active users seen in here
17:12:50 <dons> yip: yeah. :)
17:12:54 <dons> i've seen 47
17:13:20 <lispy> Igloo: if i try to set the max heap higher than the physical ram, will it cause the program to always terminate on startup? I have noticed that if i set it higer than 1024M on my machine (with 1GB ram) that the program bails on startup
17:13:23 <dons> hey, we've now beat last year's record too, http://www.cse.unsw.edu.au/~dons/irc/
17:13:23 <lambdabot> Title: Haskell IRC Activity
17:13:41 <shapr> Yay!
17:13:48 <Igloo> lispy: What flag are you using?
17:14:12 <lispy> -M1024M and -K256 (or maybe the -K was more resonable...)
17:14:26 * Igloo knows something goes wrong related to the H and M RTS flags on Windows, but AFAIK no-one has looked into exactly what
17:14:39 <lispy> mm...alright
17:14:51 <dcoutts> Igloo, yes, I've seen some odd behaviour there
17:14:52 <Igloo> That sounds like a bug, anyway
17:15:16 <lispy> Igloo: ideally i'd like it to just use as much heap as the machine has ram for before complaining :)
17:15:28 <lispy> Igloo: but maybe that's just me :)
17:15:44 <Igloo> It should default to unlimited, I believe
17:16:00 * shapr smiles every time he sees "Thank you shapr!" on http://www.cse.unsw.edu.au/~dons/irc/
17:16:01 <lambdabot> Title: Haskell IRC Activity
17:16:06 <dons> ?pl scrambler is s = snd $ unzip $ sort $ zip is' s
17:16:06 <lambdabot> scrambler = const (snd . unzip . sort . zip is')
17:16:25 <lispy> Igloo: ah, i should look at the bug then see what SimonM put because it's definitely capping me at 256 by default
17:19:39 <Igloo> lispy: With 6.4 or 6.5?
17:20:01 <lispy> this is with 6.5
17:20:04 <lispy> i just found the ticket
17:20:09 <lispy> http://hackage.haskell.org/trac/ghc/ticket/923
17:20:13 <lambdabot> Title: #923 (What is the real default heap size on windows?) - GHC - Trac, http://tinyurl.com/l4e8g
17:20:40 <emk> Is there a good way to get ghci to expand type synonyms?
17:20:41 <lispy> hmm...but ghc --version doesn't say which build just 6.5
17:20:50 <lispy> and the ticket says the bug was fixed in 6.6
17:22:10 <lispy> i guess the VH version of ghc is a bit behind and maybe doesn't include the fix for this
17:24:17 <ezraburgh> on that ~dons/irc page, what time zone is used?
17:24:53 <shapr> I am so falling behind on my irc traffic, I'm ranked 7th for 2006!
17:24:54 <lispy> ?localtime dons
17:24:56 <lambdabot> Local time for dons is Tue Oct 10 10:24:33 2006
17:25:06 <dons> whatever time zone that tunes.org is in.
17:25:16 <dons> (the logs are pulled from there)
17:25:18 <shapr> I only need another 2300 lines to catch up to xerox!
17:25:21 <dons> heh
17:25:57 <dons> shapr: you've still got the all time stats wrapped up
17:26:14 * lispy is shocked by his placement
17:26:22 <lispy> how did i get to be 9
17:26:27 <lispy> ?seen palomer
17:26:28 <lambdabot> I haven't seen palomer.
17:26:30 <SamB> too high, or too low?
17:26:30 * shapr grins
17:26:31 <lispy> and where is palomer these days
17:26:37 <lispy> too high
17:26:40 <dons> looks like he got bored
17:26:57 <lispy> bored with asking Cale for help? ;)
17:27:18 <lispy> seems like he used to always hbe here asking Cale how to write his program...
17:27:25 <Cale> hehe
17:27:25 <shapr> Wow, I really can rest on my laurels when it comes to all time stats...
17:27:51 <shapr> Not even lambdabot can beat me yet.
17:28:23 <lispy> ah, 15 over all, not shabby
17:28:24 <shapr> 5651 different nicknames seen so far.
17:28:50 <ezraburgh> geoip says tunes.org is in WA, USA.
17:28:53 * SamB beats shapr viciously
17:29:02 * shapr is flat
17:29:31 <shapr> dons: Now, can we get this sort of thing for GHC and other darcs repos?
17:29:44 <dons> the stats?
17:30:02 <dons> like http://www.cse.unsw.edu.au/~dons/images/commits/community/  ?
17:30:04 <lambdabot> Title: Haskell Community Project Activity, http://tinyurl.com/phosp
17:31:00 <shapr> Yeah, but I want to see who's put the most lines of code into various projects. I suspect dons would rank quite high there too.
17:31:10 <dons> hmm. right. coudl be done.
17:31:13 <emk> ?kind Control.Monad.Error.ErrorT
17:31:14 <lambdabot> * -> (* -> *) -> * -> *
17:31:25 <dons> just have to munge the darcs changes into a format to run through pisg
17:31:31 <dons> and then we'd get pretty graphs and quotes and so on
17:31:38 <Igloo> shapr: I'd rather see who's taken the most lines of code /out/  :-)
17:31:42 <dons> heh
17:31:54 <shapr> heh
17:31:54 <SamB> ooooooo
17:31:55 <justinhj3> hi all
17:32:04 <SamB> harder to measure by far!
17:32:16 <SamB> (do you count lines they added in the first place?)
17:32:18 <dons> +10 \n -3
17:32:18 <shapr> hiya justinhj3, how's code?
17:32:19 <dons> not so hard?
17:32:30 <dons> darcs already tells us
17:32:36 <justinhj3> could anyone tell me how to compile a haskell module with the soe graphics package
17:32:49 <justinhj3> with ghc
17:33:08 <shapr> On windows?
17:33:20 <justinhj3> yeah
17:33:35 <justinhj3> i'm working through the haskell school of expression
17:34:16 <shapr> I don't know how to do it on windows, sorry.
17:34:41 <dons> perhaps use the new gtk2hs version of SOE?
17:34:44 <shapr> On linux, "ghc --make Foo.hs -o Foo"
17:34:49 <lispy> justinhj3: i'd recommen using cabal to build
17:35:00 <dons> yeah, maybe the same on windows.
17:35:08 <shapr> And you may need to include "-package soe" or whatever package has the SOE modules.
17:35:08 <justinhj3> cabal? that's new to me
17:35:10 <dcoutts> dons, I think I may just use your slides for my talk tomorrow :-)
17:35:11 <dons> cabal seems overkill, lispy, for a little tut/demo
17:35:34 <lispy> well, bofer i always used makefiles
17:35:36 <dons> dcoutts: yeah, fair enough. where are you giving the talk?
17:35:43 <lispy> so to me it seems like a natural upgrade :)
17:35:50 <dcoutts> dons, just to the rest of my research group
17:35:57 <shapr> bofer?
17:36:02 <lispy> heh
17:36:03 <shapr> before, aha
17:36:07 <lispy> sorry, very laggy today
17:36:10 <dons> dcoutts: i'll be giving a similar talk at the inaugural SAPLING meeting after aplas (sydney area prog lang something something..)
17:36:13 <dcoutts> dons, I'll do another talk later in term all about the fusion stuff in the paper
17:36:20 <SamB> dons: so how much slower than C is your UM now?
17:36:28 <dons> SamB: 4x wasn't it?
17:36:29 <lispy> shapr: right now i type to the end of the sentence before i see anything...
17:36:34 <SamB> dons: I said *now*
17:36:40 <dcoutts> dons, cool
17:36:48 <dons> SamB, why would it have changed?
17:36:51 <SamB> oh, wait, you don't use shifts except in startup...
17:36:55 * SamB silly
17:37:03 <SamB> okay, so how much uglier than C is your UM now?
17:37:06 <dcoutts> dons, btw, is the latex source of your slides available if I want to tweak stuff ?
17:37:09 <dons> I thought I rolled my own uncheed shifts anyway
17:37:14 <dons> dcoutts: yep. let me find it.
17:37:18 <SamB> dons: yeah, I forgot ;-)
17:37:21 <dcoutts> dons, thanks muchly
17:37:45 <lispy> nucheed?
17:37:45 <dons> dcoutts: for the longish fps talk? on the old fusion stuff?
17:38:00 <lispy> er uncheed
17:38:02 <dons> unche[ck]ed
17:38:06 <shapr> lispy: We should use jabber.
17:38:10 <lispy> Ah
17:38:16 <dcoutts> dons, well the first half is all about the representation. I'll not use the old fusion bits.
17:38:24 <dons> ok
17:38:46 <emk> OK, after spending an hour or so poking at the GHC manual and Google, I'm feeling fairly stupid. :-( Is there any way to get GHCI (or lambdabot) to expand type synonyms, so I can see complex types written out in all their gory details? Any leads you can provide would really help me understand monad transformers!
17:39:15 <lispy> i love windows...some window just popup an was typing and because i was typing i made it disapper but i have no idea what it was about
17:39:42 <emk> Yeah, I know GHC does a lot of work internally to hide complex types in user output, but once, I want to see them. :-)
17:40:01 <lispy> emk: have you tried :i ?
17:40:05 <ThreeQ> does :i work?
17:40:20 <shapr> I was thinking about the advertising & packaging industry recently (you know, those guys who make money selling music that was created by others), and I realized that our (grand?)kids won't legally be able to explore our music collection unless the laws change. I seriously doubt music encryption/licensing software will work (fifty?) twenty years later.
17:40:48 <emk> :i looks up the definition of whatever I pass it, and prints this: type ErrorState e s a = ErrorT e (State s) a
17:41:06 * dcoutts -> sleep
17:41:10 <dons> dcoutts: darcs repo here, ....
17:41:15 <dons> if you hang on two seconds...
17:41:17 * ezraburgh shivers at shaprs point
17:41:18 <dcoutts> dons, ok
17:41:25 <emk> But that just looks like my source again, and there's several complicated types that haven't been expanded.
17:41:54 <lispy> shapr: the easy fix for me is to not have children.  But I will enjoy the national ID cards we're getting in May 2008
17:42:10 <shapr> lispy: we are?
17:42:18 <dcoutts> lispy, just say no!
17:42:22 <emk> lispy: So I'm guessing that not the right approach.
17:42:33 <shapr> Speaking of which, I may have to change my name back...
17:42:34 <lispy> emk: you may actually need the source then...i admin, i've never ttried this
17:42:41 * ezraburgh bids adieu
17:42:44 <shapr> Because of Homeland Security.
17:42:48 <dcoutts> lispy, I renewed my pasport recently so I can avoid an ID card 'til 2015
17:43:00 <justinhj3> lispy: is that in the uk you're getting id cards
17:43:11 <lispy> justinhj3: US
17:43:12 <SamB> shapr: so how about some COPYRIGHT VIOLATION.
17:43:16 <emk> Hmm. I suppose Hugs also takes great care to always use type synonyms in user output, too.
17:43:19 <shapr> lispy and I are both US citizens.
17:43:32 <justinhj3> lispy: I'm in US, hadn't heard anything
17:43:40 <SamB> justinhj3: passports
17:43:44 <dcoutts> lispy, the US isn't seraiouly introducting ID cards is it ?
17:43:45 <justinhj3> ic
17:43:51 <lispy> shapr: i don't know the details, i heard this on a documentary last night and i haven't loked it up yet
17:43:52 <SamB> get it soon or put it in the microwave!
17:44:05 <lispy> dcoutts: the documentarry said manditory, May 2008
17:44:09 <SamB> (yes this will look bad)
17:44:15 <dcoutts> wrap your passport in tin foil :-)
17:44:24 <shapr> lispy: If you find more details, I *really* want to know.
17:44:32 <SamB> dcoutts: that doesn't work when you have to openm it!
17:44:33 * lispy goes to look it up
17:45:12 <shapr> I think we should make RFID chaff tags that give a random but valid response each time they're scanned.
17:45:16 <dcoutts> SamB, but you only have to open it for official entry points where you already have to show your passport
17:45:32 <SamB> dcoutts: yes, but you don't know who might have staked those out
17:45:51 <lispy> shapr: http://www.epic.org/privacy/id_cards/
17:45:53 <lambdabot> Title: EPIC - National ID and REAL ID Act
17:45:55 <dons> dcoutts: http://www.cse.unsw.edu.au/~dons/code/talks/fps-intro/, though its taking a while to push all the patches
17:45:57 <lambdabot> Title: Index of /~dons/code/talks/fps-intro, http://tinyurl.com/j84o8
17:46:05 <dcoutts> dons, thanks v. much.
17:46:36 <falconair> i'm hoping someone can help me understand functional reactive programming, I've tried to read some papers but they don't make any sense (I'm basically a functional lang newbie) ... is FRP appropriate for the following scenario: a 'relational' database which allows its query language to operate on _real-time_ data (continously updated data, streaming data, etc.)?
17:46:40 <SamB> how does one get a passport, I wonder...
17:47:04 <shapr> SamB: Goto the post office.
17:47:18 <shapr> Get form, fill out, return with form & photo.
17:47:29 <justinhj3> and about $60
17:47:59 <shapr> falconair: FRP is probably better for that sort of thing than a relational database.
17:48:08 <lispy> shapr: this documentary also details some of the powers bush gained in the patriot act that are insane...i really need to find out if this stuff is real (and take it out of #haskell)
17:48:11 <shapr> falconair: Yampa is all about signal functions.
17:49:03 <shapr> Yeah, the Patriot Act is terrifying. As is the recent military something act (not yet 100% passed) where people who are only suspected of stuff can be detained for long periods of time.
17:49:18 <falconair> shapr: i read the "financial contracts" paper which uses behaviors...then last weekend i started reading Antony Courtney's PhD thesis on Yampa...which is based on arrows and i got lost again :(
17:49:21 <Philippa> that one effectively suspends habeas corpus
17:49:42 <shapr> It's sad to say, but the time of witchhunts has returned. Last time it was McCarthyism, now it's the War on Terror.
17:50:05 <shapr> falconair: Learn arrows first.
17:50:21 <justinhj3> war on terror and the war on drugs
17:50:21 <falconair> shapr: and I have to learn Monads before I learn arrows??
17:50:25 <shapr> Then read the Yampa papers before you read his thesis.
17:50:36 <shapr> No you don't have to, but it'll make your life easier.
17:50:41 <shapr> But monads are way easy to learn.
17:50:50 <Philippa> justinhj3: ITYM bad people with bad drugs. CIA selling? No problem.
17:50:54 <shapr> They just take the significance of a type and turn it into a pipeline.
17:52:00 <falconair> shapr: one thing i don't understand is how concurrency is involved with FRP/Yampa ... threads have to be involved somehwere...where do threads and locks end and FRP/Yampa begin?
17:52:17 <SamB> Philippa: you think the CIA would sell good drugs ?
17:52:34 <justinhj3> i think they have the best
17:52:37 <dylan> heh, locks only keep honest code honest. ;)
17:52:38 <shapr> falconair: In your opinion, how does continuation passing compare to threads?
17:52:43 <justinhj3> ok so I found this page http://www.haskell.org/ghc/docs/6.4.2/html/libraries/HGL/Graphics-SOE.html
17:52:47 <lambdabot> http://tinyurl.com/m4t62
17:52:57 <yip> falconair: in theory, the FRP/Yampa engine can manage threads totally independantly
17:53:00 <justinhj3> but I can't seem to figure out the -package format for the library
17:53:10 <SamB> try HGL ;-)
17:53:22 <lispy> shapr: mind coming over to #haskell-blah?
17:53:22 <Philippa> SamB: no, but good drugs in this sense're the ones that're legal
17:53:24 <dylan> (or use --make)
17:53:28 <emk> lispy: Argh. GHC is really sneaky, and works quite hard to keep me from seeing inside types. It looks like I have to either expand them by hand, or hack the compiler itself. Thanks for your help!
17:53:31 <shapr> sure
17:53:40 <Philippa> anyway, topicality
17:53:43 <lispy> emk: good luck
17:53:43 <falconair> yip: FRP/Yampa manage threads or they are built on top of threads?
17:53:45 <Philippa> much as I'm bad about it
17:53:46 <justinhj3> i've tried HGL-3.1 but it's not in there
17:53:48 <justinhj3> I get  Could not find module `SOEGraphics':
17:54:09 <emk> lispy: It's good to know that I'm not just missing something obvious. :-)
17:54:32 <dons> justinhj3: http://article.gmane.org/gmane.comp.lang.haskell.general/14132
17:54:36 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/r4xck
17:54:43 <dons> justinhj3: that's the new version of SoE using gtk2hs, instead of hgl
17:54:48 <falconair> shapr: my understanding is that continuations can be used to build very light weight threads...I don't understand how continuation passing style can execute more than one computation at a time (unless it is explicitly yielded by the programmer)
17:54:59 <dons> justinhj3: you might have more luck
17:55:09 <yip> falconair: in theory, it's possible for a FRP/Yampa to take a signal function, and automatically figure out how it's different components can be run in multiple threads. but actually implementing such an engine is probably not trivial, and i don't think it's been attempted
17:55:35 <justinhj3> dons: oic
17:56:02 <emk> And :info is quite useful.
17:57:42 <yip> falconair: the thing is that FRP/Yampa isn't imperative. you don't have a sequence of actions that are performed one after the other. so the concept of having threads where each one independantly performs a sequence of actions one after the other doesn't apply as well
17:58:00 <falconair> yip, shapr: another thing, I also started reading another PhD thesis about SuperGlue, which is supposed to be similar to FRP (but based on objects with state)...that thesis talks about linking data models to their gui representation in a declarative manner....so I could have my 'real-time' database with automatically generated GUI...all form this framework of signals and signal functions?
17:58:17 <emk> (Monad transformers are a wee bit scary.)
17:58:42 <falconair> yip: so if I actually wanted to implement such a system in either Haskell or F# ... could it be done or is it still theory?
17:59:00 <Agaths> has anyone ever run SOEGraphics and the SOE examples with GHC not Hugs?
17:59:09 <justinhj3> hi agaths
17:59:15 <justinhj3> I'm trying to figure out the same thing right now
17:59:37 <dons> Agaths: see http://tinyurl.com/r4xck
17:59:39 <lambdabot> Title: Gmane -- Mail To News And Back Again
17:59:46 <dons> windows+ghc+soe seems to have bitrotted a bit
17:59:58 <dons> so instead the new gtk2hs version of soe is preferred, I think
18:00:08 <dons> and does work with ghc on windows (and linux of course)
18:00:23 <justinhj3> dons: kind of ironic since Hudak apologises it only works on windows in the book
18:00:28 <dons> heh
18:00:39 <dons> yeah, its been relatively unmaintained since a long time now
18:00:42 <Agaths> I was thinking of Linux but it's nice to have portability
18:00:45 <yip> falconair: i'm not convinced that FRP/Yampa is ready for serious use. i think that there are major performance problems. solving these problems requires implementing optimizations that can properly detect state changes and apply them in an efficient way, instead of current implementations which do way too much copying of data
18:00:50 <shapr> falconair: I think that objects with separate state is a bad idea. I'm much happier with a single global state.
18:00:58 <dons> yip: though Frag seems to do quite fine..
18:01:23 <yip> dons: frag doesn't have a lot of state. just a few (x, y, z) triplets for coordanites of player and enemies
18:01:24 <dons> depends on the application I suppose
18:01:27 <dons> yeah
18:01:42 <dons> well, it has huge texture libs and things, but they're handled outside of yampa
18:02:02 <falconair> ok, here's another one (sorry for jumping around so much) ... are 'Incremental Algorithms" related to FRP?  (let me get a reference to incremental algorithms)
18:02:04 <yip> yep. i think that FRP/Yampa could be very fast, it just needs domain specific optimization techniques
18:02:56 <dons> Igloo: I wonder if ghc could spot linker errors and suggest --make :)
18:03:23 <dons> seems like missing -package foo is an faq
18:03:34 <falconair> http://lambda-the-ultimate.org/node/1070 <<=="Incremental Algorithms On Lists" by Johan Jeuring and another paper by Umut Acar
18:03:35 <vegai> Agaths: something wrong with hugs and SOE?
18:03:36 <lambdabot> Title: incremental algorithm help | Lambda the Ultimate
18:05:08 <Agaths> vegai: not really, just trying to understand why it shouldn't work with both
18:05:28 <Agaths> it's the kind of question that would get under my skin after a while
18:05:32 <dons> the original soe uses some nasty low level things, iirc
18:05:36 <shapr> falconair: Yeah, there is some relation because Yampa's whole idea is that signal transformers are never allowed to get hold of the signal itself. They're limited to combining basic signal transformer bits that are already known to be safe.
18:07:35 <falconair> that's one of the problems I have, there are metaphors of signals and circuits but I can't wrap my head around it yet :) ... i wish Peter Van Roy included a chapter on this stuff in his massive book (I've seen a couple of examples of FRP by him but I like his descriptions and the 'kernel' method of PLT)
18:07:54 <shapr> Have you read up on dataflow programming?
18:08:17 <shapr> Dataflow is roughly spreadsheets.
18:08:26 <falconair> shapr: i have read a little, yes...I think I understand futures...more or less
18:13:10 <falconair> is there any university in the New York area that teaches this stuff?  I haven't been able to find anything on the web...it is not easy to try to understand all this stuff by reading papers (when my undergrad degree didn't even include a day of functional programming/lambda calculus/category theory/whatever)
18:13:55 <dons> CMU?
18:14:16 <dons> depends on defn of 'area' I suppose :)
18:14:19 <falconair> UMICH
18:14:40 <falconair> dons: oh, i thought you meant which undergrad I was talking about :)
18:14:58 <dons> no, I meant, CMU, you could learn as much PL theory as you could possibly need
18:15:12 <falconair> well, I have a full time job...so any place i can take a train, drive either after work or on the weekend
18:15:27 <dons> fair enough
18:16:02 <falconair> does CMU offer such classes on sat/sunday?
18:17:02 <lennart> Yale is more in the NY area than CMU
18:17:17 <shapr> falconair: I don't have any kind of degree at all. I did get close to finishing a degree in art... but for the rest I just hung out on #haskell and read research papers.
18:17:46 <shapr> You too can become a productive member of the CS research community with no formal education!
18:17:54 <falconair> shapr: the biggest problem I have is that I'm an idiot
18:17:57 <falconair> :)
18:18:03 <shapr> So am I
18:18:14 <shapr> But it's not about inherent potential, it's about working hard to learn stuff.
18:19:14 <falconair> hahaah, interestingly, just by coincidence the author of the Yampa thesis worked at my old company, (different building), he was nice enough to offer to help me understand this stuff but I left the comapny...i thought there might be a course i could take
18:19:24 <shapr> If you put in the effort to learn this sort of thing, you will figure it out. None of it is hard, it's just a lot of detail.
18:21:17 <falconair> I'm actually more interested in making use of it in the industry, i work in New York's financial industry...after reading this stuff, I can't tell you how inefficient everything seems...
18:21:42 <shapr> everything in industry or everything you just read?
18:21:57 <dons> falconair: using yampa in a financial setting, in particular?
18:22:42 <falconair> the systems in the industry seem inefficient, overly complicated...the people there are often extremely smart...but very few of them seem to know anything outside of c/c++/java/c#
18:22:54 <shapr> Yampa would work just fine in a industrial setting, but I agree with yip that you'd need to *fully* understand Yampa before using it. Otherwise you'll run into some sort of problem and be unable to fix it yourself.
18:23:27 <dons> falconair: you saw the round up of the recent commerical users of FP conference?
18:23:55 <falconair> i didn't read any of the papers, at least one of them was from wallstreet
18:24:38 <dons> right.
18:24:48 <Agaths> I kept seeing these Google ads for functional programming on Wall Street... Jane Street Capital I think it was
18:25:48 <dons> more details here http://sequence.complete.org/hwn/20060927
18:25:49 <falconair> i don't understand why some of you guys (gals?) don't use your knowledge in this field...it is not just about making money, building something for wall street usually means that you will have an easier time getting money, you will have VERY interesting problems to solve, and if something works on wall street, it'll work any where
18:25:49 <Adamant> yup. search for Haskell and that shows up
18:26:15 <Adamant> well, I think some people don't like the fact they use O'Caml
18:26:28 <shapr> falconair: I already have things I'm interested in doing.
18:26:34 <falconair> 'easier time getting money' means 'easier time getting funded for your projects'
18:26:42 * shapr shrugs
18:26:58 <shapr> I work on stuff on my own time and I usually make enough money to eat. What else do I need?
18:27:14 <dons> the number of commerical haskell hackers is definitely growing though
18:27:22 <dons> plenty of people in this channel even
18:27:36 * lispy raises a hand
18:27:39 <dons> (often by starting side projects that are just "prototypes" -- that end up just working)
18:27:55 * lispy notes this sounds very familiar
18:28:06 <dons> i think almost daily now i receive mail from commerical haskell hackers looking for advice
18:28:07 <Adamant> dons, how much does Haskell suffer from Lisp/Smalltalk syndrome, where companies just refuse to allow it?
18:28:11 <dons> hmm, consulting hmm....
18:28:28 <dons> Adamant: i've not heard of "refusal"
18:28:32 <lispy> i completely rewrote the backend of my software last friday is 2.5 hours and reduced the memory over head by at least an order of maginitude...all thanks to how wonderful haskell is
18:28:38 <Adamant> because the programmers are too tough to replace?
18:28:49 <falconair> shapr: i guess that's a difference in outlook, better productivity means actual economic growth, we're talking about saving the world here!! ;)
18:28:58 <shapr> Most of the companies I deal with have little or no money and just want something that works. They don't care how it works, they just want it to work.
18:29:02 <dons> all you need to do is send a mail to haskell@haskell.org, to get 100 willing haskell programmers looking for work
18:29:18 <dons> the programmer supply problem isn't real, I think. there's way more haskell programmers than jobs atm.
18:29:29 <shapr> falconair: I save the world in my own way. I share what I know on #haskell and on my blog and I organize opportunities for others to learn more.
18:29:47 <SamB_XP> indeed
18:29:49 <shapr> falconair: And there's The Monad.Reader where I try to organize articles to teach high end commercial programmers this stuff.
18:29:51 <lispy> that's very grass roots of you
18:30:10 <lispy> maybe we should start haskell user groups
18:30:12 <SamB_XP> nobody learns Haskell because they think there are jobs to be had for the taking...
18:30:18 <lispy> or fp user groups
18:30:19 <falconair> shapr: i know, you just helped me with yampa, i was (half) kidding ;)
18:30:32 <SamB_XP> they learn Haskell because they think it is cool ;-)
18:30:36 <lispy> user groups seems to work for linux
18:30:40 <SamB_XP> or wierd
18:30:41 <scsibug> I've been thinking about starting a local fp group in the area (DFW/Texas), but I fear I'd be the only one there ;)
18:30:42 <Adamant> falconair, I've got no problem with Wall Street making cash, but I don't associate financial trading with "saving the world"
18:31:04 <Adamant> providing liquidity can be good
18:31:18 <lispy> scsibug: yeah, i'd probably be the only person in corvallis (there are some grad students but they are too busy to make it) but if i went to portland i bet ic ould find people
18:31:20 <shapr> falconair: TBH, I'd probably be working for Wall Street if I could get to work every day at 8am and consistently do what other people want me to do.
18:31:27 <falconair> i do think that the new york area could use some sort of 'haskell tutorial'  it could done on a for-profit basis or for free, but there is a definite need!   save us jeebus!
18:31:40 <shapr> But I can't even consistently do what *I* want me to do, much less do what others ask...
18:32:02 <lispy> joel on software doesn't even use haskell and he likes the language
18:32:08 <lispy> so what is the disconnect there?
18:32:12 <shapr> Speaking of which, I should be hacking on HAppS...
18:32:13 <dons> weird huh
18:32:22 <shapr> No, I *want* to hack on HAppS...
18:32:28 <dons> shapr: HACK!
18:32:34 <dons> less talk, more code!
18:32:39 * dons tries to motivate shapr
18:32:43 <lispy> same with steve yegge, he seems to either like lisp or haskell (hard to tell with him) but he seems to always be bitching about coding in Java
18:32:44 * shapr hacks!
18:32:44 <SamB_XP> dons: you have ops, yes?
18:32:51 <dons> SamB_XP: yup
18:32:58 <Adamant> IO, IO, it's off to work we go!
18:33:02 <dons> hehe
18:33:04 <SamB_XP> you have plenty of motivational power then ;-)
18:33:09 <SamB_XP> Adamant: heh
18:33:09 <dons> heh
18:33:21 <shapr> Ok, here's my hacktivation... I'm going to hack together a minimal HAppS wiki in the next four hours...
18:33:25 --- mode: shapr set -o shapr
18:33:36 <dons> ok. talk to you in 4 hours then shapr.
18:33:42 <dons> and i want to see that wiki
18:33:46 <lispy> heh
18:33:52 * dons wears supervisor's hat
18:34:02 <shapr> I'm sure I'll be here asking questions in the meantime :-)
18:34:17 <falconair> shoot, i gotta run, if any one here wants to setup a user gorup for haskell in the NYC area let me know (shahbazcATgmail) ...thanks folks!
18:34:26 <lispy> if i were that disciplined we'd have the lambdatutbot too
18:34:29 * shapr cranks up the music and dives into the code.
18:34:49 <lispy> falconair: i'm not in NYC...
18:34:53 <lispy> falconair: or i'd help
18:35:09 <falconair> viva la revolution! ;)
18:35:14 <lennart> falconair: yes a NYC haskell group would be fun
18:35:40 <dons> there was the recent DC group set up. (though it was lisp+haskell, iirc)
18:36:10 <falconair> well, i'm stepping away from my computer, i already gave my email, if there are NYCers here, I'll be happy to help in any way ....bye
18:36:12 <dons> we could learn something from perl here. they seem to have groups for ever major city , and plenty of minor ones
18:36:33 <dylan> perl monger meetings are often not about perl.
18:36:57 <dons> just general programming stuff, right?
18:37:17 <dons> (i was invited to give a talk to a sydney perl group, about haskell, for example :)
18:38:06 <lispy> heh
18:38:15 <lispy> yeah, i don't think it has to be all haskell all the time
18:38:22 <lispy> but it does get people into it
18:38:29 <lispy> and works to get everyone trying it out
18:38:44 <lispy> and once people are setup with a haskell dev env, it's very low cost to just do it here and there
18:38:54 <lispy> i think that's a lot of how perl got big
18:39:00 <lispy> but, i'm not old enough to be sure
18:39:04 <dons> hmm. yes.
18:39:20 <dons> that's something: setting up a haskell dev enivronment, for exploration and learning
18:39:30 <Xgc> Any takers for a COBOL/Haskel UG?
18:39:38 <Xgc> s/l/ll
18:39:41 <lispy> Oh, COBOL?
18:39:42 <lispy> sweet
18:39:42 <lennart> COBOL, eh?
18:39:43 <lispy> i'm in
18:39:51 <dons> should be a little tut, also on rolling a new haskell project , with cabal , darcs et al
18:39:55 <Adamant> is there a "Haskell in Small Pieces"?
18:40:09 <Adamant> something like Lisp in Small Pieces
18:40:24 <dons> maybe? there's so many haskell tuts out there one of them must be close :)
18:40:28 <lispy> dons: yes the cabal site needs to have 'templates' you just throw in your code, edit one or two lines and you have a cabalized dev env setup
18:40:33 <SamB_XP> I thought Haskell was *already* in small pieces?
18:40:43 <dons> lispy: hmm!
18:40:53 <dons> lispy: a tool that builds a cabal package for you....
18:40:58 <lispy> sure
18:41:03 <dons> given a project name and a list of src files.
18:41:07 <lispy> it would be what, 8 lines of haskell? :)
18:41:11 <dons> right
18:41:34 <lispy> might be better to provide it in haskell, perl, python and sh just incase the have trouble getting ghc installed :)
18:41:43 <dons> cabal-wrap-presents Main.hs -project "my cool project"
18:42:14 <dons> leaves you with a darcs repo, with the cabal stuff filled in
18:42:19 <dons> and some haddock docs and so on
18:42:20 <lispy> or, cabal-setup initialize --with-darcs
18:42:51 <lispy> or we could do like Peter Seibel's lisp in a box
18:42:55 <dons> might help some of the fringe users more easily make their code available to the rest of us
18:42:56 <ThreeQ> there should be something like http://tryruby.hobix.com/ for haskell
18:42:58 <lambdabot> Title: try ruby! (in your browser)
18:43:05 <dons> yeah, we're working on that ThreeQ
18:43:06 <lispy> you get a lisp interpreter, emcas and SLIME plus an excellent book
18:43:10 <dons> ?where lambdaweb
18:43:11 <lambdabot> http://lambdabot.codersbase.com
18:43:26 <ThreeQ> yeah, like that, but with the tutorial box thing
18:43:31 <dons> yep
18:43:35 <lispy> ThreeQ: yes, mostly waiting no me at this point...
18:43:37 <dons> that's what lispy was talking about earlier
18:43:43 <ThreeQ> oh, awesome
18:43:50 <lispy> i need to hack in support for multiline stuff in lambdabot
18:43:57 <lispy> then the rest falls together i think
18:44:16 <dons> yeah, we have the web interface to safe haskell set up. now just need the wrappers
18:44:27 <dons> lispy: might be easier to just tweak a runplugs to multiline-runplugs
18:44:42 <lispy> you're probably right
18:44:47 <dons> and then add EvalMulti.hs, then in lambdaweb  disable Eval, and use EvalMulti instead
18:45:04 <lispy> lambdabot --restricted --multieval
18:45:12 <dons> yeah
18:45:24 <dons> i might hack this up on the plane if i get time
18:45:34 <lispy> and then force them to use main :: ST () ?
18:46:06 <lispy> then it's just like writing a real haskell program but we make then use ST instead of IO
18:46:12 <lispy> or a fake IO might be cool
18:46:14 <ThreeQ> you could write a SafeIO monad
18:46:14 <ThreeQ> yeah
18:46:19 <ThreeQ> hide the prelude io stuff
18:46:42 <lispy> dons: what do you think? too heavy for a tutorial?
18:47:05 <erider> good night all
18:47:15 <lispy> erider: night
18:47:32 <dons> i'm not sure main :: IO stuff is necessary
18:47:39 <dons> we can just let them do pure stuff
18:47:48 <dons> at least to start with anyway
18:47:58 <dons> if we find that we need to allow io online, we can create a SafeIO monad
18:48:02 <lispy> okay, well we need some sort of main :: a or something just so we agree on an entry point right?
18:48:42 <ThreeQ> wouldn't it be a repl?
18:48:49 * lispy still needs access to the lambdaweb darcs repo
18:48:58 <dons> why not just a repl?
18:49:04 <ThreeQ> I guess function definitions are kind of awkward
18:49:12 <lispy> to do a tutorial don't we need to allow them to define more than one function?
18:49:27 <ThreeQ> you could have a repl pane and a definitions pane
18:49:27 <dons> maybe. that's harder to do , of course.
18:49:28 <lispy> i imagine they write a whole file worth during the tutorial
18:49:40 <dons> i suppose with @let we can let them define things
18:49:43 <lispy> not all at one go, but over time
18:50:13 <lispy> in fact, for one tutorial i imagine we take them through some of the key prelude functions hiding the prelude definiions and asking them to write it from scratch
18:50:17 <dons> or maybe they run hugs on their machine, and submit fragments for checking in lambdabot, which retuns icfp style "keys" for points :)
18:50:30 <lispy> heh
18:50:47 <lispy> i think allowing them to work completely from the web is a good way
18:50:52 <lispy> people that just want to 'try it out' can
18:50:55 <dons> yeah i agree.
18:51:53 <lispy> writing the prelude from scratch (or at least key functions) serves two great peruposes, 1) it teaches you what is already there 2) those are some really good functions to help learn the idea of FP
18:52:29 <lispy> and i think the tutorial should provide grading
18:52:34 <dons> yep
18:52:36 <lispy> so that's another reason to want an entry point
18:53:01 <lispy> i need to write this all up on my wiki or in a readme or something
18:53:02 <Botty> 3) It's elegant as hell for being a sort of core.  I'd expect it to be all nasty but its not
18:53:09 <lispy> i wish i could do this for my oo class...
18:53:27 <lispy> Botty: heh, yeah, isn't that cool?
18:53:36 <Botty> yep
18:54:00 <Botty> practically self documenting even to a noob
18:54:42 * Botty looks up definition.  nah, more like newb
18:56:19 <emk> lispy: Yeah, Prelude is surprisingly pleasant reading. Has anyone done a nice version using lhs2TeX yet?
18:58:09 <dons> theres a colour version here http://www.cse.unsw.edu.au/~dons/data/Prelude.html
18:58:11 <lambdabot> Title: Haskell 98 Prelude, http://tinyurl.com/qqdjb
18:58:18 <dons> but  a latex version with foralls might be fun :)
18:58:52 <dwm> 4) Chicks dig the Prelude
18:59:11 <emk> Oooh, shiny color Haskell. :-)
18:59:16 <dylan> do chicks dig latex versions with foralls?
18:59:58 <dons> dylan: i reckon so
19:00:02 <Adamant> you put the latex on the chics, not the foralls
19:00:20 * Adamant ducks
19:00:25 <Botty> @vixen what do you think of a latex version of the prelude with foralls?
19:00:26 <lambdabot> i don't know, what?
19:00:35 <dylan> replacing "on" with "in" would take this conversation to a new low.
19:00:44 <dons> ?vixen so do chicks dig universal quantification?
19:00:44 <lambdabot> whoa whoa whoa, one question at a time!
19:00:44 <Elendal> Hi, i am doing an assignment in haskell and I want to know if I can avoid calling same code twise: http://pastebin.ca/195784 can anybody help?
19:00:47 <Philippa> Adamant: I believe in is more common than on...
19:01:02 <emk> Elendal: Let me take a look.
19:01:36 <Pseudonym> Elendal, time to learn about where clauses.
19:01:37 <edwardk> unless you are into body paint.
19:01:39 <Botty> Elendal - split the code you call twice into a new function?
19:01:44 <Pseudonym> Oh, and guards.
19:01:49 * dylan notes his fiancee doesn't like haskell, and has a strange liking of scheme *because* of the parenthesis'...
19:01:52 <emk> Elendal: A where clause, a let declaration, or a helper function.
19:02:03 <Pseudonym> foo x y = if c then e else t
19:02:07 <Pseudonym> Can be refactored as:
19:02:08 <Pseudonym> foo x y
19:02:13 <dwm> I was thinking of something the other day.. and this may be a silly Q..
19:02:13 <Pseudonym>   | c   -> e
19:02:17 <Pseudonym>   | otherwise -> t
19:02:25 <edwardk> dylan: its not too late, she can be saved... well, no, she's a lost cause. I'm sorry man.
19:02:26 <Pseudonym> Sorry, = not ->
19:02:40 <dwm> Why does >>= take an (a -> m b) and not an (m a -> m b) ?
19:02:49 <lispy> dylan: she's a lost cause and i need her phone #...
19:02:50 <Pseudonym> The other thing is you can give expressions a name:
19:02:54 <Elendal> ok ok, let's try that
19:02:58 <syntaxfree> I still have a liking of scheme because of the parenthesis and the extreme regularity of syntax.
19:03:16 <Pseudonym> foo x y = ... someExpression ... someExpression
19:03:17 <syntaxfree> I still have a tendency to write things like f = \x y -> x + y
19:03:17 * lispy nods at syntaxfree 
19:03:20 <Pseudonym> transform to:
19:03:25 <Pseudonym> foo x y = ... e ... e
19:03:26 <Adamant> syntaxfree, that is my only complaint with Haskell as well.
19:03:29 <Pseudonym>   where e = someExpression
19:03:49 <dons> something like:
19:03:50 <Philippa> Haskell's is still pretty regular
19:03:50 <dons> getOfSame hand x
19:03:51 <dons>     | length r == x = r
19:03:51 <dons>     | otherwise     = getOfSame (removeHightCard hand) x
19:03:51 <dons>     where f c = getRank c == getRank (getHighCard hand)
19:03:53 <dons>           r   = filter f hand
19:03:57 <syntaxfree> I like Haskell syntax.
19:04:04 <dylan> lispy: Haha. No, she's my little autolisp/scheme/perl hacker. ;)
19:04:11 <emk> Well, no syntax certainly makes it easier to cleanly specify how hygienic macros work.
19:04:14 <lispy> dylan: :)
19:04:16 <dons> Elendal: the key is to use 'where' to record the result of the filter once, and then just reuse that result
19:04:18 <Philippa> most of the time there're ~two choices and they correspond to big sensible choices about how to present something
19:04:23 <Philippa> (let vs where, for example)
19:04:26 <syntaxfree> I find it easier to write code that writes code with Scheme.
19:04:29 <Elendal> Thanks!
19:04:53 <emk> Elendal: Good luck!
19:04:54 <dylan> Scheme always feels like playing.
19:05:22 <Pseudonym> BTW, bonus marks for the nice accumulator recursion.
19:05:26 <emk> dylan: That's not necessarily a bad thing. :-) Haskell is curiously amusing, too.
19:05:37 <dylan> haskell feels fun too.
19:05:38 <lispy> does meacs have a mode to build via cabal? (basically emacs-cabal integration?)
19:05:39 <Adamant> Philippa, Haskell has the nicest "conventional" syntax I have seen so far
19:05:47 <Adamant> I agree with you on that.
19:06:02 <dylan> the only functional language I've not felt fun in is erlang, and that's because it reminds me of prolog.
19:06:06 <lispy> s/meacs/emacs/
19:06:15 <emk> Are there any good tutorials on Template Haskell? The last time I Googled I didn't come up with much.
19:06:20 <Philippa> syntaxfree: fair enough. TH isn't too bad to work with, though
19:06:26 * lispy just found out it's errlang not urlang
19:06:46 <syntaxfree> What's fun about Haskell syntax is how math-looking it is.
19:06:54 <Pseudonym> It's a nice erlanguage.
19:06:56 <lispy> emk: i have a very small snippet of what i've been able to figure out on my blog
19:06:58 <edwardk> syn: agreed
19:07:01 <syntaxfree> f x y = a / y where a = x + y
19:07:15 <lispy> emk: but it's not very good, i think if i had read a tutorial on TH it would be cleaner :)
19:07:44 <edwardk> emk: most of us learned it by trying to use it to do something
19:07:50 <syntaxfree> > let { f x y = a / y where a = x + y } in f 2 3
19:07:51 <lambdabot>  1.6666666666666667
19:07:57 <shapr> Is it my imagination or does Text.Html have no support for textareas?
19:08:08 <dons> syntaxfree: why the { } ?
19:08:09 <lispy> emk: try this for a starter: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
19:08:10 <emk> dylan: I like Prolog's unification variables, but backtracking is an exponential-time hack. So Oz is nicer: Unification, and the backtracking is replaced by more general constraint solving.
19:08:13 <lambdabot> Title: dagit.o Â» Blog Archive Â» Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
19:08:18 <dons> > let f x y = 1 / y where a = x + y in f 2 3
19:08:19 <lambdabot>  0.3333333333333333
19:08:31 <dylan> emk: that's not what I dislike about prolog.
19:08:32 <dons> well, modulo typos :)
19:08:42 <edwardk> i have a fairly horrible chunk of template haskell for generating a 16s complement type-level integer library if you want to find out about various TH hacks
19:08:43 <shapr> Oh, user error...
19:08:47 <SamB_XP> dons: maybe they make it easier to read?
19:08:48 <emk> Haskell's syntax is nicely mathematical, but when I feed it through lhs2TeX, it's gorgeous.
19:09:05 <emk> lispy: I'm looking at it now.
19:09:06 <Pseudonym> emk: Didn't you know, there's only one algorithm in Prolog: Exponential backtracking search.
19:09:24 <syntaxfree> the manual for lhs2TeX is humongous and under-helpful.
19:09:32 <Pseudonym> Seriously, if you hate backtracking in Prolog, try Mercury.
19:09:50 <Pseudonym> Just don't try too much higher-order programming.  You'll get a severe headache.
19:09:51 <syntaxfree> I want the latex-math substitutions, but with a "code" fixed-width  font.
19:10:20 <lispy> well, one thing i wonder about my TH usage is how to simplyf this:
19:10:22 <lispy> mkCheck name = [| putStr (name ++ ": ")
19:10:23 <lispy>                >> quickCheck $(varE (mkName name)) |]
19:10:25 <dons> lispy, why isn't your blog on planet haskell?
19:10:33 <lispy> dons: it is or at least it was
19:10:35 <syntaxfree> my blog has some Haskell tutorials.
19:10:38 <syntaxfree> They're all in portuguese.
19:10:38 <dons> oh. ok.
19:10:46 <lispy> dons: i update infrequently though
19:10:47 <shapr> Gwahr, Text.Html isn't consistent!
19:10:58 <lispy> dons: i still need to blog about lambdaweb and haskell-workshop
19:11:01 <SamB_XP> shapr: explain!
19:11:10 <lispy> ?seen Gwahr
19:11:10 <lambdabot> I haven't seen Gwahr.
19:11:11 <emk> Mercury's OK, but it's basically just a type-system slapped over Prolog with ugly syntax. Useful if you're trying to prove the absence of backtracking, but otherwise less interesting than some of the other Prolog descendants.
19:11:16 <syntaxfree> http://www.navarro.mus.br/diego/blog/2006/09/13/tutorial-dois-pesos-duas-medidas/
19:11:21 <lispy> shapr: i don't think Gwahr has been here in a while ;)
19:11:21 <lambdabot> Title: Tutorial: dois pesos, duas medidas Â» diego navarro, http://tinyurl.com/r4bp4
19:11:30 <Pseudonym> Well, it's Prolog's syntax.
19:11:32 <dons> syntaxfree, you should set up #haskell.pt  and a haskell.org.pt page :) now that we have #haskell.es and Haskell.es
19:11:32 <SamB_XP> lispy: you silly
19:11:38 <syntaxfree> http://www.navarro.mus.br/diego/blog/2005/10/20/uma-introducao-ao-haskell-usando-cobras-autofagicas/
19:11:40 <Pseudonym> But actually, the mode system is more valuable than the type system.
19:11:43 <lambdabot> Title: uma introduÃ§Ã£o ao Haskell usando cobras autofÃ¡gicas Â» diego navarro, http://tinyurl.com/egobu
19:11:46 <SamB_XP> that is an exclamation of frustration, you silly lispy
19:11:49 <syntaxfree> dons: I'm actually a brazilian.
19:11:56 <Pseudonym> You can actually think of it as ML with output variables rather than Prolog with types.
19:11:59 <lispy> syntaxfree: cool, but i don't speak your language :(
19:12:00 <shapr> SamB_XP: textfield :: String -> Html and textarea :: Html -> Html , textfield has an automatic name = first arg, and text area doesn't.
19:12:01 <syntaxfree> I could manage haskell.org.br; I just can't fund it.
19:12:12 <lispy> silly lispy, exclamations are for kids
19:12:40 <emk> Pseudonym: There's a really nice general isomorphism between functions and relations.
19:12:40 <syntaxfree> lispy: the code snippets should give you an idea of what it's about.
19:12:54 <Pseudonym> emk: Yes, but syntax matters.
19:13:02 <lispy> well, i know from my limited spanish it's about money and years
19:13:03 <syntaxfree> http://www.navarro.mus.br/diego/blog/2005/10/26/magica
19:13:06 <lambdabot> Title: mÃ¡gica! Â» diego navarro, http://tinyurl.com/f3qb8
19:13:15 <syntaxfree> lispy: it's about prison years.
19:13:27 <Pseudonym> If syntax didn't matter so much, I'd be using scheme.
19:13:36 <syntaxfree> look at the Data.Either extensions.
19:13:45 * syntaxfree is into   Haskell for the laziness, not for the syntax.
19:14:07 <Pseudonym> I'm in it for the type system, actually.
19:14:08 <lispy> syntaxfree: why is this useful? f & g = g . f
19:14:22 <syntaxfree> this discussion always comes up.
19:14:37 <Pseudonym> Especially since we already have f >>> g
19:14:44 <emk> Pseudonym: Oz lets you use function and relation syntax interchangeably. It's fairly civilized, and concurrent logic languages add some entertaining complications without breaking equational reasoning. ;-)
19:14:52 <syntaxfree> becausn application  order is more intuitive than composition order.
19:14:56 <lispy> ?type flip (.)
19:14:57 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
19:15:06 <SamB_XP> emk: don't you have to pick one for a given function and use that?
19:15:11 <syntaxfree> I could say (&) = flip (.), but I wanted to make it explicit.
19:15:15 <dons> syntaxfree: i know. i'm suggesting a language translation page, like http://www.haskell.org/haskellwiki/Haskell.es
19:15:17 <lambdabot> Title: Haskell.es - HaskellWiki
19:15:19 <Pseudonym> ?type (>>>)
19:15:20 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
19:15:28 <SamB_XP> syntaxfree: how is that not explicit?
19:15:30 <syntaxfree> it's a mini-language for a prison system.
19:15:35 <SamB_XP> that is about as explicit as you can get!
19:15:42 <syntaxfree> well, I didn't want to explain control.arrow yet :)
19:15:44 <lispy> SamB_XP: but not in a tutorial
19:15:55 <dons> syntaxfree: i.e. like producing some pages in portugese translated from the most popular tuts on the haskell wiki :)
19:16:05 <SamB_XP> (&) = flip (.) -- does not use Control.Arrow
19:16:16 <syntaxfree> a prisoner is data Ficha = Ficha {    nome :: String,
19:16:16 <syntaxfree>                         pena :: Either Pena Pena }
19:16:19 <Pseudonym> > (*1) >>> (+2) $ 5
19:16:21 <lambdabot>  7
19:16:24 <syntaxfree> then you have things like
19:16:26 <Pseudonym> > (*4) >>> (+2) $ 5
19:16:27 <lambdabot>  22
19:16:50 <syntaxfree> escapeAttempt  Ficha, communityWork Ficha, etc.
19:16:52 <syntaxfree> and I want them in order.
19:17:02 <syntaxfree> (escapeAttempt & communityWork) ficha
19:17:14 <syntaxfree> so the last function acts on the result of the previous function.
19:17:14 <lispy> so no obvious way to simplify "$(varE (mkName name)" when name :: String?
19:17:47 <syntaxfree> Then you can put events in chronological order.
19:17:52 * lispy is so used to (.) order that the order of (&) is actually harder to think about :)
19:17:55 <dons> $(var name), where var s = varE (mkName s) ?
19:18:10 <lispy> dons: i was hoping for some TH tricks
19:18:20 <lispy> like ,name or something
19:18:24 <lispy> but that's lisp
19:18:33 <dons> oh, maybe there is some syntax for that.
19:18:38 <SamB_XP> doubt it
19:18:40 <dons> seems to ring a bell... check the TH paper
19:18:46 <lispy> which one?
19:18:47 <SamB_XP> heh
19:18:58 <dons> doesn't x' or 'x or something have a meaning in TH (under utilised?)
19:18:58 <lispy> the last time i looked at a TH paper it didn't match the current state of things
19:19:02 <syntaxfree> lispy (.) is more mathematical.
19:19:02 <dons> or am i dreaming again
19:19:15 <lispy> i thought i saw ``Foo once but i couldn't get it to work
19:19:20 <syntaxfree> but (&) makes more sense in this DSL-ish context.
19:19:22 <dons> ah maybe that's it.
19:19:41 <syntaxfree> I've had the longest debates about (&) here.
19:19:47 <lispy> syntaxfree: taht's good
19:20:11 <lispy> syntaxfree: i don't pass judgemnt on the use of (&), just found it surprising
19:20:39 <emk> SamB_XP: You can use either the function or relation syntax interchangeably, as far as I know (they're just syntactic sugar), but it's nicer to be semi-consistent. :-)
19:20:40 <lispy> not something i would do necessarily but interesing all the same
19:20:44 <lispy> and you seem to have thought this out quite a bit
19:20:48 <dons> i prefer identifiers encoded in unary strings of ?
19:20:54 <lispy> hehe
19:20:58 <lispy> dons: sounds pretty :)
19:21:02 <syntaxfree> well, it's meant to be used by prison guards :-P
19:21:03 <SamB_XP> ??????
19:21:07 <SamB_XP> ?????????????????????????????????????
19:21:09 <SamB_XP> ?????
19:21:15 <dons> > let (?) = 1 ; (??) = 2 ; (???) = (+) in (???)(?)(??)
19:21:17 <shapr> !
19:21:18 <lambdabot>  3
19:21:22 <SamB_XP> ??????????????????????????
19:21:25 <emk> syntaxfree: Yeah, do tell.
19:21:42 <dons> > let (?) = 1 ; (??) = 2 ; (???) = (+) in (?)???(??)
19:21:43 <lispy> > let (!) = 1; (!!) = 2; (!!!) = (+) in (!!!)(!!)(!)
19:21:44 <lambdabot>  3
19:21:45 <lambdabot>  3
19:22:45 <lispy> do we have any haskell friendly blog software?
19:22:51 <lispy> i really hate wordpress
19:23:03 <lispy> it's broken and gives me grief...actually part of why i don't blog much
19:23:06 <lispy> i hate figting it
19:23:08 <dons> hope?
19:23:20 <lispy> i really wish i could use mediawiki markup + geshi highlighting
19:23:26 * lispy looks at home
19:23:28 <lispy> iser hope
19:23:33 <lispy> is that by bringert?
19:23:38 <dons> ?quit resync
19:23:39 <dons> yep
19:24:28 <lispy> not as pretty as wordpress
19:24:34 <dons> ?uptime
19:24:35 <lispy> what is the text entry like?
19:24:59 <lispy> oh correctly highlighted haskell is nice to see
19:25:01 <lambdabot> uptime: 42s, longest uptime: 6d 15h 1m 36s
19:25:27 <edwardk> dons: 'Foo and ''Foo matter
19:25:37 <shapr> lispy: Still, wordpress wasn't written in ~ two months and Hope was.
19:25:45 <emk> lispy: Thanks for the blog link!
19:25:46 <edwardk> they refer to different constructors data and type or vice versa
19:25:59 <edwardk> since mkname can only access variables
19:26:07 <edwardk> its a bit of a hack
19:26:14 <shapr> Also, I'm thinking of sticking the goodness of Hope ontop of the goodness of HAppS
19:26:26 <emk> Do you have strong opinions about the relative virtues of HUnit and QuickCheck?
19:26:29 <lispy> edwardk: so do you know if i could use one of them in my example?
19:26:39 <lispy> emk: i haven't used HUnit
19:26:51 <lispy> emk: but one thing that's nice about HUnit is that the tests go in the module
19:26:58 <edwardk> example?
19:26:58 <emk> lispy: Does QuickCheck make you happy, in general?
19:27:01 <lispy> emk: so you don't have to expose the functions that you want to test
19:27:23 <lispy> emk: yes, very and i 've since extended my framework so that i can set the number of tests per property so ic an effectively have unit tests
19:27:25 <satan> hello all
19:27:25 <shapr> Is there something wrong with a form action attribute that has "name/othername" ?
19:27:36 <satan> how do i specify an empty list of type [Bool]?
19:27:39 <lispy> edwardk: this example
19:27:41 <lispy> mkCheck name = [| putStr (name ++ ": ")
19:27:42 <lispy>                >> quickCheck $(varE (mkName name)) |]
19:27:49 <lispy> edwardk: name :: String
19:27:52 <emk> satan: [] :: Bool
19:27:58 <emk> ?type [] :: Bool
19:27:59 <lispy> emk: i would like to experiment with small check
19:27:59 <lambdabot>   Couldn't match `Bool' against `[a]'
19:27:59 <lambdabot>    Expected type: Bool
19:28:08 <lispy> emk: i think in general small check would be better/easier
19:28:18 <shapr> QuickCheck c'est love!
19:28:19 <emk> ?type [] :: [Bool]
19:28:20 <lambdabot> [Bool] :: [Bool]
19:28:30 <satan> emk: thanks
19:28:30 <emk> satan: Ah, that's what you want.
19:28:33 <lispy> emk: for one it would infer the correct number of tests to run where quickcheck requies me to say
19:28:54 <emk> small check is generally nice?
19:29:01 <lispy> very
19:29:08 <lispy> ?scheck True
19:29:10 <lambdabot>  Completed 1 test(s) without failure.
19:29:17 <lispy> ?check True
19:29:18 <lambdabot>  OK, passed 500 tests.
19:29:19 <edwardk> lispy: won't work there. they are for when you want to reference something like "Just" or "Maybe"
19:29:23 <satan> emk: i see, so an expression with 2 empty lists, one of type [Bool] and one of type [Char] would be something like g [] [], where each is of the specified type
19:29:25 <lispy> emk: see the difference there :)
19:29:34 <lispy> edwardk: okay
19:29:50 <lispy> i need to make a bridge between the H98 parser and TH
19:29:51 <shapr> musasabi: ayh?
19:29:54 <lispy> that would help make haskell more lispy
19:29:55 <shapr> @timein musasabi
19:29:56 <lambdabot> Local time for musasabi is Tue Oct 10 05:29:34 2006
19:29:58 <emk> satan: g ([] :: [Bool]) ([] :: [Char])
19:30:02 <dons> ?time shapr
19:30:03 <edwardk> there might be another syntax for variables, but i always used varE $ mkName foo like you did
19:30:08 <lambdabot> Local time for shapr is Mon Oct  9 21:29:42 2006
19:30:10 <satan> emk: ah ok, thank you
19:30:34 <emk> Or if the type of g's arguments is know, Haskell will work it out for you automatically:
19:30:48 <lispy> emk: smallcheck also starts from the smallest test case it can generate and grows from there in hopse that it finds you a minimal test case of breakage
19:30:51 <emk> g :: [Bool] -> [Char] -> ???
19:31:04 <lispy> emk: i have found that quickcheck finds bugs i wouldn't have though to check for because it doesn't know my assumptions
19:31:09 <satan> emk: right, thats what i had
19:31:36 <emk> lispy: That's cool! I'll have to take a look.
19:31:59 <lispy> emk: quickcheck has found probably 25 bugs so far before they ever caused a problem...the one time i started using something with a quickcheck case i spent an hour debugging, wrote a quiccheck case and fixed it within the next 20 min
19:32:39 <lispy> emk: automated property checking is a really wonderful way to test, but it's not exclusive to hand coded tests ala HUnit or similar
19:32:56 <lispy> emk: that's why i hacked my suite to let me specificy the number of tests to do
19:33:23 <lispy> oh i meant "something without a quickchec case"
19:33:35 <dons> araujo: around?
19:33:47 <shapr> QC could subsume unit testing.
19:33:48 <lispy> bleh,i should go home
19:33:57 <lispy> edwardk: thanks for looking at the TH code
19:34:02 <emk> lispy: Oh, I'm a huge believer in testing--I also hack in various SmallTalk descendents, which do no compile-time testing. So I basically never trust code without solid unit tests of some sort.
19:34:15 <lispy> emk: ah good
19:35:12 <lispy> shapr: does hope do lists?
19:35:20 <lispy> shapr: looks like it does most of the wiki markup i care about
19:35:29 <lispy> oh heh
19:35:34 <lispy> missing features lists lists
19:35:54 <lispy> and it's probably pretty hackable
19:36:02 <lispy> yes, i should look installing it
19:36:27 <emk> lispy: On the other hand, since I'm so used to testing everything, I have little personal need for strong types. I'm mostly interested in types for helping compilers prove certain transformations correct.
19:36:42 <emk> Not to prove my own code correct.
19:36:59 <Korollary> Do your coworkers like your tests, too?
19:37:36 <emk> Yeah, and I like theirs. It's nice to work in a shop that believes in good test coverage. :-)
19:37:38 <lispy> i think code inspection/review + aumotmated property testing + strong typing gives you basically bug free code
19:38:04 <lispy> of course somethings things happen but usually only at the boundaries when you work with other programs
19:38:25 <lispy> most of my bugs are related to working with excel and finding its limitations
19:38:44 <lispy> today i found out formulas are limited to something like 1024 characters
19:38:54 <lispy> this cause a redesign on the haskell side :)
19:39:02 <emk> lispy: Well, it gets rid of all the easy bugs. It still leaves compiler bugs, weird OS failures, and all the other horrors. That's where we spend 90% of our debugging time on a shrinkwrap product.
19:39:21 <Adamant> write a HaskellOS!\
19:39:32 <Adamant> and verify the compiler!
19:39:35 <lispy> heh, yeah we have a kernel and a file system now :)
19:40:17 <edwardk> adamant: been done, its called house, and there a few verified compilers, but i don't think you want to write in coq or c minor ;)
19:40:18 * lispy leaves for real to get some exercise
19:40:21 <emk> Oh, and "bugs" caused by a failure to understand the ultimate problem, and all the horrible details of the solution.
19:40:36 <Adamant> logic error
19:40:40 <Adamant> (human)
19:40:59 <satan> are there any built in haskell types that are not derived from Eq ?
19:41:22 <Adamant> edwardk, what's stopping, say, GHC, from being verified?
19:41:39 <Korollary> satan: [Int] is not
19:41:42 <emk> One of all more recent compiler bugs: MSVC++ 6 performed tail-call elimination, even if a pointer to a local variable had escaped into a global variable (third party code with ultra-heavy optimizations; not our fault).
19:41:53 <Adamant> since it's written in Haskell, and I thought functional languages were pretty easy to verify
19:41:59 <edwardk> at last check the language lacks formal semantics for large chunks of it =)
19:42:00 <satan> Korollary: i see, hmm
19:42:20 <Adamant> ah. so you'd need a formal BNF grammar and such?
19:42:23 <edwardk> so you would be verifying what exactly =)
19:42:37 <edwardk> not the grammar, that part is easy, but a denotational and operational semantics for, say, the core.
19:42:45 <Adamant> ah.
19:42:49 <dons> Adamant: verifying compilers is a huge task. think of what kind of proofs you'd need for 300,000k of ghc code
19:42:54 <edwardk> the grammar is pretty well codified by the report
19:43:07 <dons> that being said, people do actually verify compilers written in functional languages,
19:43:16 <dons> but i don't know of any production compiler done that way
19:43:23 <lispy> the ML community verifies, iirc
19:43:23 <Adamant> ah.
19:43:33 <emk> dons: At that scale, any human-written proof will contain bugs. And if you automate your proofs and your proof-checking, then your axioms will have bugs.
19:43:34 <dons> more interesting these days is perhaps certifying compilers
19:43:34 <edwardk> yeah, my favorite is the CoC compiler for coq written in coq.
19:43:35 <gmh33> the MLton compiler ?
19:43:38 <lispy> at least they have a full denotational semantics for some version of ML
19:43:53 <dons> that produce a proof the code produced does what you say it does. independent of whether the compiler has bugs
19:43:56 <Botty> imho if there are 300,000 lines of haskell in a project, something has gone very wrong
19:43:57 <dons> if the compiler has bugs, the proof fails
19:44:14 <dons> Botty: how big do you think gcc is :)
19:44:20 <satan> Korollary: i want an expression that behaves differently for types drawn from Eq and those that arent drawn from it, thats why i was asking
19:44:21 <Adamant> gcc is a monster.
19:44:28 <Botty> gcc is C/C++ though
19:44:31 <Botty> i think...
19:44:33 <Adamant> and everything else
19:44:40 <dons> it is, and is around 1M loc
19:44:41 <emk> dons: Yeah, I've talked to some of certified compiler people. You still need to set up all the axioms for your domain (which can be really hard), and those may contain errors.
19:44:45 <Botty> that doesn't matter.  C/C++ is effectively unbounded
19:44:49 <Adamant> C/C++/Ada/Obj-C/Obj-C++/etc.
19:44:51 <dons> emk: yep.
19:45:12 <Pseudonym> And gcc is cross-platform.
19:45:17 <Pseudonym> One of the few C/C++ compilers that is.
19:45:24 <Korollary> satan: That's not possible. If the type signature says Eq a in the context, all types that it operates on are in Eq.
19:45:24 <edwardk> emk: yeah, but done right you wind up with a much smaller trusted core, so its still worth pursuing for fairly rigid designs
19:45:39 <emk> dons: Still, they've managed to eliminate about 90% of the human verification work (at fairly enormous coding cost), which is nothing to sneeze at.
19:45:46 <dons> actually, just checking ghc/compiler, comes to   165,666 lines+comments total
19:45:52 <dons> so ghc itself is around 100k then.
19:46:00 <Adamant> not only is it cross platform, it can output to archs that it can't host itself on
19:46:11 <Botty> dons - that's a little bit more like it.  Still a bit on the fat side, but hey
19:46:11 <satan> Korollary: i see, perhpas i phrased my question wrong
19:46:27 <SamB_XP> dons: and the comments are even harder to check than the code
19:46:29 <emk> dons: On the other hand, it apparently took an MIT grad student all summer to write a certified GCD function, so the coding costs are non-trivial.
19:46:31 <dons> Botty: a lot of archs, multiple backends, multiple language extensions, dead code and so on. 20 years of work
19:46:42 <gmh33> MLton is >140k..
19:47:03 <Botty> yeah..
19:47:26 <gmh33> but it a whole program optimizing compiler
19:47:27 <Adamant> CoyotoOS is interesting.
19:47:29 <satan> Korollary: the function last :: [a] -> a differs from last' :: (Eq a) => [a] -> a, so i guess i want an expression e that responds differently to last e and last' e
19:47:33 <Adamant> they want to do a fully verified OS.
19:47:44 <Adamant> writing their own language to do so.
19:48:29 <Adamant> hope they pull it off, a verified OS would be of enormous value for certain applications.
19:48:31 <emk> Adamant: Of course, a large fraction of OS costs are caused by misunderstandings between the drivers and the (inevitably buggy and underdocumented) hardware.
19:48:40 <SamB_XP> ... the hardware will be buggy, I just know it!
19:48:40 <emk> s/OS costs/OS bugs/
19:48:43 <edwardk> adamant: well, i'm not holding my breath based on the alarming pace they took with eros ;)
19:48:59 <Adamant> edwardk, I can understand that.
19:49:00 <SamB_XP> oh rats, emk said it first
19:49:36 <emk> SamB_XP: Hardware is typically a lot buggier than software, because it takes so long to fix hardware bugs. Usually the driver team just works around a few dozen known problems in software, and forgets to update the data book, even if they bothered to write one.
19:49:49 <Adamant> emk, hardware can be verified more easily than software, IIRC
19:50:11 <SamB_XP> Adamant: but, they still might have bugs in the formal spec...
19:50:19 <Adamant> AMD did formal verification of their FPU, which is why they didn't get bit by the Pentium FPU bug
19:50:35 <Adamant> SamB_XP, definitely
19:50:43 <emk> Adamant: In theory, perhaps. But with a multi-month turnaround on the prototypes, and occasional physics issues, well, you should hear the stories my hardware friends tell.
19:50:45 <SamB_XP> Adamant: which FPU?
19:50:46 <Adamant> verification just raises the bar quite a bit
19:51:06 <Adamant> SamB_XP, the one AMD did contempory to the Penitum
19:51:34 <Adamant> K586?
19:51:36 <emk> CPUs actually tend to be fairly good, but they have a zillion different kinds of verification working for them.
19:51:39 <SamB_XP> and they were copying of Intel?
19:51:50 <Adamant> SamB_XP, no
19:52:02 <Adamant> they verified their FPU, and Intel didn't
19:52:05 <SamB_XP> ... where would they have got this bug from, then?
19:52:20 <Adamant> SamB_XP, the point was they didn't get a bug
19:52:22 <emk> But look at PCI boards, USB hardware, or (shudder) graphics cards, and you'll go insane.
19:52:25 <SamB_XP> wouldn't they have had one of their own?
19:52:34 <Adamant> when they had a FPU of relatively equal complexity
19:53:11 <Adamant> SamB_XP, I'm not following.
19:53:13 * SamB_XP has to wonder how often the hardware might have a bug, but code around it in microcode
19:53:30 <Adamant> SamB_XP, that's what chip makers are doing now
19:53:33 <SamB_XP> Adamant: I'm saying, wouldn't AMD's FPU have had a *different* bug if they had had a bug?
19:53:38 <emk> First rule of hardware hacking: The hardware has bugs. Second rule of hardware hacking: The data book is useless pack of filthy lies told by sadists.
19:54:01 <gmh33> emk: ouch, my pride
19:54:10 <Adamant> SamB_XP, right
19:54:21 <Adamant> but the point is, there were no bugs in the AMD FPU
19:54:27 <SamB_XP> yes
19:54:43 <Adamant> and there were bugs in the Intel FPU, which was not formally verified
19:54:58 <Adamant> which cause the Pentium recall
19:54:59 <emk> Adamant: Didn't AMD have some other bugs though, ones that could be exploited to enter supervisor mode?
19:55:09 <gmh33> The P4 sucks >_>;
19:55:11 <Adamant> emk, not that I know of.
19:55:15 <emk> ghm33: You make hardware?
19:55:17 <SamB_XP> bah, security bugs!
19:55:27 <gmh33> emk: no, I'm just studying computer engineering
19:55:31 <emk> http://www.vbulletin.com/forum/showthread.php?t=37951
19:55:36 <lambdabot> http://tinyurl.com/lbweh
19:55:38 <Adamant> emk, currently, the AMD64 microcode is unencrypted
19:56:04 <emk> Adamant: Anyway, there's one of the AMD supervisor-mode bugs.
19:56:37 <emk> gmh33: Well, may your work be less buggy than that of your predecessors. :-)
19:56:41 <dons> Haskell Weekly News issue 44 is out, http://sequence.complete.org/hwn/20061010
19:57:14 <Adamant> emk, interesting
19:58:11 <Adamant> I know people have been working on the AMD64 microcode.. if someone reverses it, you could probably create a very hard to detect rootkit
19:58:15 <emk> dons: Oooh, a monad transformer tutorial!
19:58:37 <Adamant> Intel encrypts their microcode.
19:59:19 <emk> Looks like an updated relative of "Monad transformers and modular interpreters" at first glance...
19:59:29 <gmh33> emk: anything for you
19:59:39 <dibblego> can one instance of lambdabot join more than one network?
20:00:08 <dons> not yet.
20:00:13 <Pseudonym> Don't takl to me about hardware, please.
20:00:13 <dibblego> ok
20:00:21 <Korollary> ok
20:00:21 <shapr> Couldn't microcode be used to reprogram a CPU?
20:00:22 <Pseudonym> I've spent a week trying to get an AVR chip to program.
20:00:28 <Adamant> shapr, yes
20:00:30 <shapr> Sort of like an FPGA?
20:00:45 <SamB_XP> shapr: no
20:00:49 <Pseudonym> There's microcode and microcode, though.
20:00:54 * shapr blinks
20:00:57 <emk> ghm33: Of course, us software types really shouldn't talk about bugs in any case. Major glass house issues...
20:01:03 <Pseudonym> Modern CPUs are basically RISC cores with a microcode interpretation layer.
20:01:04 <Adamant> sort of. it lets you string together micro-ops to make the ISA
20:01:26 <SamB_XP> emk: except we can fix ours without starting a new production run!
20:01:45 <gmh33> emk: hardware is advanced way way ahead of software at this point..
20:01:45 <emk> SamB_XP: Which means we have a lot less excuse.
20:01:51 <SamB_XP> hardware people must be more vigilant!
20:01:55 <gmh33> emk: I guess that's the real sad part D:
20:01:58 <shapr> gmh33: I'm not convinced.
20:02:04 <SamB_XP> because we are stuck with hardware.
20:02:06 <Pseudonym> On the contrary, hardware has advanced in a direction that software doesn't want to go.
20:02:14 <SamB_XP> Pseudonym: mmmm
20:02:16 <SamB_XP> true!
20:02:17 <emk> gmh33: Us software types are so no ready for 80 hardware threads...
20:02:24 <Pseudonym> emk: I am!
20:02:30 <Pseudonym> Haskell is almost ready.
20:02:32 <Adamant> but it's not generally reprogrammable like a FPGA or CLPD is
20:02:38 <shapr> imho, a decent advance in hardware would be dies quilted with CPUs and L2 cache.
20:02:38 <gmh33> Pseudonym is a erlang programmer :P
20:02:39 <Pseudonym> All we need is transactional caches, and we're there.
20:02:42 <SamB_XP> Pseudonym: but.... that *is* the direction hardware is advancing in!
20:03:05 <shapr> Pseudonym: Hasn't Henry Baker already written about transactional caches?
20:03:06 <SamB_XP> well, maybe not the transactional caches
20:03:09 <Pseudonym> Hardware designers want 80 hardware threads and only a compare and swap primitive to tie them together.
20:03:11 <SamB_XP> I don't know
20:03:25 <Pseudonym> We want STM in hardware.
20:03:30 <gmh33> I'm only a sophomore  undergrad, so I'm better at programming than with hardware as of yet :P
20:03:33 <SamB_XP> Pseudonym: yeah. well. okay. so we need to chastise them severely with a rubber STM
20:03:33 <emk> Pseudonym: Yeah, Haskell gets a huge fraction of the way there. And judging from the latest STM papers, we don't even need transactional caches.
20:03:36 <SamB_XP> or something
20:03:53 <Pseudonym> BTW... anyone here researching hardware designs?
20:03:59 <Pseudonym> I have a request.
20:04:01 <Adamant> how does Haskell perform on concurrency currently?
20:04:26 <emk> Adamant: Dunno, but the APIs should scale quite well, modulo issues with lazy eval.
20:04:44 <emk> Even invisible destructive updates come at a cost in the parallel world.
20:04:45 <Pseudonym> The amount of effort that goes into reorder buffers these days is insane.
20:04:48 <SamB_XP> TVars are a bit expensive, from what I hear... but then agian I never liked the idea of building datastructures out of them...
20:04:51 <Pseudonym> All that work just to get precise interrupts.
20:05:10 <Pseudonym> If we had transactional caches, then interrupts could simply result in rolling back the transaction.
20:05:17 <Pseudonym> Think about that for a moment.
20:05:24 <SamB_XP> Pseudonym: hmm
20:05:35 <emk> Pseudonym: Yeah, I know re-order buffers are on the hit list. SGI's already produced some hardware with very weird memory-ordering behavior.
20:05:36 * SamB_XP thinks about a cache twice as big as its nominal contents
20:05:51 <Pseudonym> SamB: Nope.
20:06:00 <SamB_XP> Pseudonym: how not?
20:06:06 <SamB_XP> how else is it going to roll back?
20:06:10 <Pseudonym> You write to your cache, and if the transaction gets aborted, you just conveniently forget to write the contents out to RAM.
20:06:16 <SamB_XP> oh
20:06:32 <SamB_XP> that sounds ever so much easier, you could probably get it with a microcode update ;-P
20:06:44 <Pseudonym> There is some trickiness.
20:06:58 <Pseudonym> I think you need new kinds of memory buffer, for example.
20:07:02 <Pseudonym> Sorry, barrier
20:07:03 <SamB_XP> hmm
20:07:04 <Pseudonym> Not buffer
20:07:07 <emk> Pseudonym: Of course, hardware designers would really prefer to give us zillions of slowish compute engines with local memory, as in a GPU.
20:07:27 <SamB_XP> emk: and we could use those
20:07:30 <emk> Of course, they'd give us a teraflop to make us feel better. :-)
20:07:35 <SamB_XP> for some things
20:07:51 <Pseudonym> No, they'd give us a theoretical teraflop which is unrealisable in practice.
20:08:08 <SamB_XP> Pseudonym: it would be great for rendering graphics!
20:08:35 <shapr> Oh cool, my flagrant whining on http://lwn.net/Articles/203562/ turned up a 100% open platform - http://balloonboard.org/ No binary blobs of firmware are required!
20:08:41 <emk> Pseudonym: Yeah, but wait a year or two. If we're willing to go way, way multicore, we'll get there.
20:08:57 <gmh33> boo @ kind errors D:
20:09:12 <shapr> I think teracore will work fine, that's what the quilted dies I describe are all about.
20:09:15 <SamB_XP> basically all we have to do is come up with insanely parallel algorithms
20:09:16 <Pseudonym> My problem here is that very little research has been done on exactly how these massively multicore CPUs are supposed to interact.
20:09:22 <SamB_XP> which is the hard part
20:09:36 <Pseudonym> Which is why I think transactional caches need more research.
20:09:47 <Pseudonym> And if you have a transactional cache, you may not need a reorder buffer.
20:09:49 <shapr> You've seen the hexagon & square patterns on old linoleum floors yeah? What about having the squares be CPUs and the hexagons cache/ram, and have each border be a link to the next component?
20:09:50 <gmh33> Pseudonym: which is why Intel announced a 90(?) core thingy they've been developing :P
20:10:06 <gmh33> btw, can someone tell me what's wrong with this ?
20:10:07 <gmh33> data Number = TheNum Integer
20:10:07 <gmh33> data Expr a b c = TheExpr (Number Integer) (String String) (Number Integer)
20:10:13 <emk> Pseudonym: Oh, just give them all point-to-point links in a hypercube lattice, and let the programmers figure out how to route stuff.
20:10:20 <SamB_XP> I don't think anyone (except maybe Sun and a few others) is going to make that kind of CPU until massively threaded algorithms are more common...
20:10:53 <Pseudonym> I'm not making a chicken until I see an egg, dammit.
20:10:58 <emk> SamB_XP: And those algorithms won't be common until we have the programming languages to express them cleanly.
20:11:05 <SamB_XP> emk: yeah.
20:11:13 <shapr> I think it's silly to thread algorithms anyway. I prefer incremental algorithms that are iterated until you run out of time.
20:11:15 <SamB_XP> but we'd still need to come up with the algorithms...
20:11:38 <SamB_XP> shapr: no, thats for schoolwork!
20:11:40 <Pseudonym> Maybe what we need first is a massively multicore CPU with hardware MPI.
20:11:43 <shapr> I think it's already known how to turn an algorithm into its incremental version.
20:11:47 <emk> SamB_XP: Haskell is actually a large fraction of the way there. It's just that it's not exactly the easiest language to learn.
20:12:00 <shapr> What's hard about Haskell?
20:12:03 <dylan> haskell is easy to learn. ;)
20:12:05 <shapr> emk: I think the hardest thing about Haskell is C!
20:12:08 <SamB_XP> emk: we *still* would need to actually come up with the *algorithms* themselveS!
20:12:22 <Adamant> the hardest thing about Haskell so far is monads.
20:12:26 <Adamant> to me.
20:12:37 <gmh33> Adamant: no it isn't
20:12:38 <gmh33> :P
20:12:39 <SamB_XP> monads aren't any harder than C
20:12:45 <Adamant> and the fact you have to use the IO monad off the bat without fully understanding what it does
20:12:46 <shapr> Adamant: Monads just turn the significance of a type into a pipeline with the same significance.
20:12:47 <SamB_XP> just pretend they are easy and move on
20:13:04 <emk> shapr: Well, Haskell basically makes you do math. Which is a good thing, but the average working programmer appears to be slightly shaky on the 'for' loop...
20:13:16 <shapr> Here's Intel's recent teracore thingy - http://www.pcper.com/article.php?aid=302
20:13:18 <lambdabot> Title: PC Perspective - IDF 2006: Terascale Processing Brings 80 Cores to your Desktop
20:13:21 <gmh33> SamB_XP after you pretend that long enough, they actually are :P
20:13:27 <gmh33> or just read "All About Monads"
20:13:30 <gmh33> that does a good job of it
20:13:45 <audreyt> though http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html is arguably easier to grok
20:13:45 <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:13:47 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
20:13:48 <Adamant> emk is correct. mathematical literacy is increasingly rare in our societies, and it's become more and more rare among programmers
20:14:12 <SamB_XP> hmm
20:14:15 <SamB_XP> this is indeed sad
20:14:18 <Pegazus> mathematical literacy?
20:14:23 <emk> If your programming language is as hard as math, it's considerably harder than average, whatever its other virtues.
20:14:30 <SamB_XP> Pegazus: the ability to read, write, and understand maths
20:14:33 <SamB_XP> aka math
20:14:37 <mlh> Pegazus: I think he means numeracy :-)
20:14:38 <shapr> emk: If most programmers had to write Haskell that was up to the current community standards then a) there would be far fewer professional programmers and b) they would get the same amount of working applications released as are released now.
20:14:45 <SamB_XP> mlh: nononono!
20:14:49 <SamB_XP> not numeracy
20:14:58 <Pegazus> mmm ok...
20:15:00 * mlh gets his coat
20:15:01 <SamB_XP> mathemeticians are, I think, bad at that anyway...
20:15:01 * shapr hugs audreyt 
20:15:21 * audreyt ponders about methylmatical literacy
20:15:27 <audreyt> shapr: *hug*
20:15:34 <SamB_XP> methylmatical?
20:15:35 <shapr> w00
20:15:36 <Pseudonym> Group hug!
20:15:38 <Adamant> better living through mathematical chemistry!
20:15:41 <Pegazus> why does the "each language" people "hates" each other?
20:15:50 <shapr> methylphenidate! w00!
20:15:58 <Pseudonym> shapr: I'm not sure about that.  If most programmers were like most Haskell programmers, only cool software would be written.
20:16:07 <Pegazus> all ppl think their language is the best one...
20:16:08 <Pseudonym> There'd be all those enterprise CRM systems languishing without maintainers.
20:16:13 <shapr> Pegazus: Because 'for each' divides things, and 'map' works with them all!
20:16:19 <SamB_XP> Pseudonym: hmm. that wouldn't be so great.
20:16:23 <emk> shapr: Haskell is very good language for writing programs quickly, but it tends to fall behind good lambda-friendly scripting languages (like Ruby) in stateful domains.
20:16:25 <shapr> Pseudonym: Sure, but *all* software is cool!
20:16:30 <SamB_XP> I mean, I like to get bank statements every month too...
20:16:31 <Pegazus> divides things? what do you mean?
20:16:33 <SamB_XP> shapr: hah
20:16:34 <shapr> emk: Gezeik!
20:16:42 <Pseudonym> shapr: I'll pretend you didn't say that because I like you.
20:16:46 <shapr> emk: javla skit!
20:16:51 <Philippa> emk: it's really not too bad if you use the ST monad
20:16:56 <Philippa> or IORefs
20:16:59 <shapr> Pseudonym: But seriously, software is extremely cool if you write it in a cool way.
20:17:16 <Philippa> and potentially rather better in domains that're stateful in interesting ways
20:17:22 <Pseudonym> I guess you get your fun where you can.
20:17:27 <emk> shapr: Of course, if you disagree with my assertion, you're welcome to launch a Haskell-based startup and use Haskell to wipe everybody else off the map. :-)
20:17:34 <dylan> Let me tell you about this ruby program I tried using -- raggle, an ncurses RSS reader. It redraws so slow the screen disappears for several seconds, and *then* crashes.
20:17:38 <Pseudonym> But there are many areas of development that I find it impossible to get enthused about.
20:17:39 <Philippa> plus you get a lot more safety than in the dyntyped scripting languages
20:17:40 <Pegazus> i think that a good mixture of all those language would be really good...
20:17:54 <SamB_XP> dylan: hmp3 is much better ;-)
20:17:54 <shapr> emk: and I'll raise you a web application...
20:18:06 <dylan> hmp3 isn't a feed reader.
20:18:18 <SamB_XP> dylan: a small problem in an otherwise lovely program!
20:18:23 <shapr> emk: The only advantage of Ruby/Python/etc is community size.
20:18:34 <SamB_XP> you could probably fix that in a couple of days
20:18:38 <gmh33> ruby makes a decent CGI script language :P
20:18:51 <Adamant> Ruby is a nice language. just slow.
20:18:52 <emk> Philippa: I wrote an imperative quicksort in the ST monad the other day (out of sheer perversity). Despite my best attempts it was ugly--but perhaps not unfixably so, with appropriate language support.
20:18:56 <shapr> gmh33: Have you tried HAppS?
20:19:14 <gmh33> no, I've just written some ruby code for a college project
20:19:25 <shapr> emk: Seriously though, can you give some real datapoints on how exactly Ruby is better for a stateful domain?
20:20:23 <emk> shapr: Re your earlier comment: Well, Ruby also cleans up because it has good support for metaprogramming, so you can do lots of nice Lispish stuff. And that can be a productivity win (I loathe boilerplate code, even in Haskell).
20:20:26 <shapr> I believe that monads are a heck of a lot easier to learn and use than objects.
20:20:31 <gmh33> one of my favorite languages is actually Eiffel <_>;
20:20:44 <Philippa> emk: there's a known proposal for syntactic sugar that'd do exactly what you want, and you can also decompose the task rather nicely in Haskell in ways that'd be daft in many imperative languages
20:20:51 <shapr> emk: Yeah, but that's a general comment, I want specifics!
20:21:00 <Philippa> (TH!)
20:21:04 <edwardk> i love eiffel. if it wasn't for the crufty syntax and covariant rule i'd be all over it ;)
20:21:06 <emk> shapr: One sec while I dig up some slides...
20:21:14 <Adamant> shapr, learning objects is probably easier than monads for most programmers.
20:21:35 <Adamant> I think there's a reason Squeak et al. are OO
20:21:46 <shapr> Adamant: I disagree! I picked up both OOP and monads completely on my own. Objects don't make as much sense.
20:21:48 <gmh33> Adamant; because objects are just fancy functions and variable sets
20:21:52 <sjanssen> Adamant: because OO was fashionable when they were invented?
20:22:06 <Adamant> sjanssen, Smalltalk pretty much invented OO
20:22:19 <gmh33> I thought that was Modula
20:22:25 <Adamant> so, it wasn't "fashionable", because it didn't exist before it.
20:22:33 <Adamant> Simula was somewhat OO
20:22:46 <emk> shapr: There's some nice Ruby metaprogramming here: http://media.rubyonrails.org/presentations/pursuitofbeauty.pdf
20:22:49 <lambdabot> http://tinyurl.com/ehetl
20:22:56 <shapr> Objects have lots more rules, aren't as general, don't compose as well / don't separate concerns as well, and have extra un-necessary rules as well.
20:23:06 <gmh33> I believe Simula influenced Smalltalk
20:23:11 <gmh33> then again, so did LISP lol
20:23:14 <dons> someone should write an article about the beauty of haskell, and compare with the beauty of ruby
20:23:18 <emk> But instead of hacking syntax (like Lisp), it's based on runtime transformations of the object model.
20:23:22 <dons> pity i don't know ruby well enough to make a fair article
20:23:25 <Adamant> Smalltalk was written in Lisp, originally.
20:23:35 <emk> dons: Oh, Haskell has great beauties.
20:23:43 <dons> though I don't like these "end" blocks. very 1970s imo.
20:23:54 <gmh33> Adamant: the first version was written in basic :P
20:23:54 <shapr> emk: Still, metaprogramming is something that Haskell does also. I want some code to compare!
20:24:03 <gmh33> but it wasn't full fledged smalltalk
20:24:08 <gmh33> it was just an implimentation of the concept
20:24:10 <Pegazus> I believe that monads are a heck of a lot easier to learn and use than objects. --> can you teach me how to use them in 5 minutes?
20:24:18 <shapr> I think that Ruby's OO model is better than Python's OO model, but its syntax is worse. Explicit END is a waste of time.
20:24:21 <shapr> Pegazus: Sure!
20:24:42 <shapr> Pegazus: Monads just take the significance of a type and turn it into a pipeline.
20:24:50 <emk> shapr: You just get very different sorts of niftiness when you go to opposite ends of the typing spectrum. And Haskell's niftiness is a lot more relevant to the aforementioned 80-core machines.
20:24:59 <shapr> Pegazus: Do you want the five minute lecture?
20:25:07 <shapr> It tends to take six or seven minutes though :-/
20:25:08 <Adamant> shapr, I'd like to hear it. :)
20:25:29 * shapr always underestimates how long things take
20:25:38 <dons> wiki done yet, shapr ?
20:25:49 <Adamant> if it's 10 minutes, it'll still be fine.
20:25:51 <shapr> Um, not quite =)
20:25:52 <gmh33> I need to refigure out this typing thing lol
20:25:53 <Adamant> dons, shh!
20:25:56 <dons> i long for the days when i overestimate consistently
20:26:03 <Adamant> :)
20:26:05 <shapr> heh
20:26:07 <dons> when it does happen (e.g. hmp3) i am soo happy
20:26:08 <emk> In a concurrent world, state is the original sin of computer science.
20:26:11 <Pegazus> <shapr> i do...
20:26:11 <dons> but it doesn't always happen
20:26:25 <Pegazus> shapr: i do
20:26:26 <Pseudonym> I'm taking bets now.  2 karma points on seven minutes.
20:26:26 <dons> ?remember emk In a concurrent world, state is the original sin of computer science.
20:26:29 <dons> thanks emk.
20:26:40 <deadbeef> nuclear tests in north korea
20:26:53 <dons> deadbeef: more? or same as yesterday?
20:26:54 <Adamant> why not 0xDEADBEEF?
20:26:57 <shapr> Pegazus, Adamant: I have to finish this wiki first, but after that my lecture will just be a regurgitation of http://www.nomaware.com/monads/html/index.html
20:27:00 <lambdabot> Title: All About Monads, http://tinyurl.com/hx34v
20:27:18 <deadbeef> dons: i think it's yesterday's
20:27:19 <deadbeef> (9 oct)
20:27:22 <Pegazus> that would take more than 5 minutes...
20:27:43 <shapr> Pegazus: Not really.
20:27:47 <emk> shapr: That's an excellent tutorial.
20:28:08 <shapr> Pegazus: You just look at what a type *mean*, then you see how that is useful in a pipeline. Then you're done.
20:28:13 <shapr> s/mean/means
20:28:15 <gmh33> yeah, all about monads is quite good
20:28:25 * lispy thinks tackling awkward squad is a good IO monad tutorial
20:28:35 <Pegazus> a pipeline? i don't understand still what a monad is...
20:28:38 <shapr> data Maybe a = Nothing | Just a means "something can return a value or fail"
20:28:44 <lispy> i think nomaware is comprehensive but not a good intro
20:28:58 <shapr> In a pipeline, that means you have a bunch of operations that can fail, and if anyone of them fails, the whole pipeline fails.
20:29:03 <gmh33> lispy: I like how it explains how to build one first
20:29:06 <emk> Philippa: You mentioned a proposal for syntactic sugar for monads. I'd be very interested to see it.
20:29:09 <Pegazus> i know how to use maybe...
20:29:22 <shapr> Basically it abstracts away from a bunch of nested if-then-else statements.
20:29:26 <Pegazus> but still i don't know what a monad is :) and why is it so great...
20:29:33 <Philippa> emk: it's not for monads per se, it's actually for a more general abstraction that monads're an instance of
20:29:43 <Philippa> the sugar's called "Idiom Brackets"
20:29:54 <emk> Oooh, I'll go take a look. Thanks!
20:29:54 <gmh33> Ravens lose time to sleep lol
20:30:03 <shapr> Pegazus: A monad is an abstraction that hides stuff that you don't want to see right now. Objects are also an abstraction, but they're different.
20:30:05 <lispy> awkward squad develops the motivation for the IO monad and even explains what it means in terms of pseudo-operational semantics
20:30:23 <Pegazus> what's the difference?
20:30:46 <Pegazus> lately i usually find that differents things are the same ones :)
20:30:53 <lispy> objects are about responsibility, message passing, behavior and encapsulation
20:30:53 <shapr> The difference is that objects are like a bunch of balls holding their own state, and they all go poke each other when stuff is happening.
20:31:03 <gmh33> datatypes confuse me at times :/
20:31:08 <Pegazus> so?
20:31:14 <Pegazus> what are monads?
20:31:19 <shapr> Monads are a pipeline where stuff flows through from the beginning to the end.
20:31:46 <Pegazus> and... what can you use it for?
20:31:53 <gmh33> Monads are really complex mathematic there .. CATEGORY THEORY run!
20:31:59 <shapr> All the same things that you can use objects for.
20:32:08 <gmh33> theory*
20:32:25 <Pegazus> k
20:32:28 <SamB> Pegazus: computations!
20:32:30 <shapr> But the monadic approach to something is often simpler than the object approach.
20:32:34 <SamB> that probably return values
20:32:35 <emk> Philippa: McBride and Patternson's paper?
20:32:38 <Pegazus> thats sounds like a function to me...
20:32:42 <lispy> well, some things objects do more naturally than monads
20:32:45 <Pegazus> why is it simpler?
20:33:20 <shapr> Because the monad rules make things simpler.
20:33:25 <Pegazus> what are the monad rules?
20:33:28 <Philippa> emk: should have something, yeah
20:33:30 <gmh33> the short answer is better abstraction
20:33:36 <SamB> state isn't stuck all through everything ;-)
20:33:37 <Pegazus> why?
20:33:38 <Pegazus> how?
20:34:12 <Philippa> you only get the state you ask for, so all the side-effects that bite you in the arse're ones you expected
20:34:16 <shapr> The monad laws are left identity, right identity, and associativity.
20:34:17 <lispy> Pegazus: at some point you will realize you have to try out monads for yourself to understand them...you may be there already
20:34:26 <emk> For the Lisp hackers in the audience: What macros let you do for syntax, monads let you do for control flow.
20:34:32 <Pegazus> i want to try out monads...
20:34:37 <Pegazus> it's just i don't have time atm :)
20:34:42 <Pegazus> i also have to try haskell...
20:35:01 <SamB> ... and then you decide that higher-order lazy functions might as well be macros...
20:35:03 <lispy> emk: hmm...i'm not sure about that, i think laziness + monads is what you mean
20:35:19 <Pegazus> macros has nothing to do with higher-order lazy functions O_o
20:35:22 <shapr> I tried to explain OOP to a boss of mine who had only done COBOL, after a frustrating half hour, I finally told him that objects are like functions that never stop running, so they can hang onto their state.
20:35:27 <SamB> Pegazus: sure they does!
20:35:42 <Pegazus> O_o
20:35:55 <weitzman> shapr: wow
20:35:57 <emk> Pegazus: If you not a Lisp macro geek, don't try to understand the metaphor. I've just been explaining monads to Lispers lately.
20:36:07 <Adamant> emk - that helps!
20:36:09 <shapr> From that same viewpoint, monads are a pipeline that means the same thing as the type the monad is based on.
20:36:11 <Pegazus> k
20:36:12 <SamB> anyway, I'm talking about *lisp* macros
20:36:32 <shapr> weitzman: Wow what?
20:36:49 <lispy> ?photoprotontorpedo
20:36:50 <lambdabot> Unknown command, try @list
20:36:57 <lispy> ?protontorpedo
20:36:57 <lambdabot> is haskell more powerful than any jedii?
20:36:58 <weitzman> shapr: Your boss is impressive
20:37:02 <sjanssen> hahahaha
20:37:04 <Pegazus> <lambdabot> is haskell more powerful than any jedii? --> never
20:37:18 <dons> heh
20:37:19 <shapr> weitzman: Impressive how so?
20:37:24 <Pegazus> the haskell side is faster... more temptative...
20:37:30 <Pegazus> more powerfull?, never...
20:37:31 <weitzman> shapr: In a bad way
20:37:35 <emk> lispy: Well, at least some monads seem to do something useful even without lazy eval--there's plenty of explicit lambdas in the second arguments to >>=, so even a Scheme compiler could get pretty far.
20:37:53 <dons> there's monads for C++ and Ruby and Scheme already, iirc?
20:38:06 <Pegazus> monads for C++? interesting
20:38:10 <lispy> java yes, c++ maybe
20:38:10 <dons> probably not as nice though, without the do syntax, i suppose.
20:38:23 <weitzman> C++ has plenty of syntax hacks
20:38:25 <dons> and in the C++ case, just not nice.
20:38:27 <lispy> they would be terrible simple as objects would they not?
20:38:37 <emk> dons: Well, they got lambda working recently, using unbelievably vile template hackery and operator overloading.
20:38:44 <dons> heh
20:38:54 <dons> i see lambdas going in to the C++ standard even
20:39:12 <dons> though from what i understand, its broken from the start (unsafe, anyway)
20:39:13 <SamB> hehehe
20:39:16 <Pegazus> _1 + _2 * _3->string::size
20:39:17 <dons> since closures don't work right.
20:39:20 <Pegazus> that's lambda
20:39:29 <SamB> hasn't that worked for a while?
20:39:37 <Adamant> lispy, thanks!
20:39:40 * SamB -> bed
20:39:41 <Pegazus> sorry: _1 + _2 * _3->*string::size
20:39:44 <emk> dons: Every language should have lambdas. This is my final decision; don't bother trying to appeal it. ;-)
20:39:55 <lispy> Adamant: you're welcome but i don't know what for...
20:40:02 <Adamant> Awkward Squad is a nice paper
20:40:08 <lispy> Ah, yes it is
20:40:17 <lispy> it's my new weapon for newbies
20:40:31 <lispy> "here go read this and IO String won't scare you any more"
20:40:32 <emk> Adamant: The monad diagrams in Awkward squad are terrific.
20:40:39 <shapr> I collected a bunch of monad implementations in various languages - http://lambda-the-ultimate.org/node/1136
20:40:41 <lambdabot> Title: Collection of links to monad implementations in various languages. | Lambda the  ...
20:40:46 <dons> emk: oh, I agree.
20:41:33 <shapr> Clean, Haskell, Java, Joy, OCaml, Perl, Prolog, Python, Ruby, Scheme, C++, Scala, XSLT, Miranda, and Tcl
20:41:38 <emk> The diagrams make what >>= does very clear.
20:42:24 <lispy> and also type IO a = World -> (World, a) -- or however it goes helps too
20:42:58 <Cale> hehe, where's that Larry Wall quote from?
20:43:09 <Cale> (the one in HWN)
20:43:12 <lispy> ?quote LarryWall
20:43:12 <lambdabot>  ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
20:43:27 * shapr grins
20:43:29 <lispy> that one?
20:43:45 <dons> ?quote LarryWall
20:43:45 <lambdabot>  ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
20:43:49 <dons> ?quote LarryWall
20:43:49 <lambdabot>  ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
20:43:51 <dons> boo
20:44:04 <dons> ?remember LarryWall Perl is turning into Haskell. Someone shoot me.
20:44:05 <Cale> dons: presumably you would know?
20:44:10 <emk> Of course, Larry Wall also said that Lisp looked like fingernail clippings in a bowl of oatmeal, so he may have strange ideas of beauty.
20:44:21 * shapr laughs
20:44:32 <dons> the quote was from #perl6
20:44:33 * lispy thinks John Goerzen must be british from his sense of humor
20:45:01 <emk> Haskell, on the other hand, looks like a fatal accident in the punctuation factory.
20:45:12 <dons> emk is on fire today
20:45:18 <lispy> heh
20:45:19 <dons> ?remember emk Haskell, on the other hand, looks like a fatal accident in the punctuation factory
20:45:52 <lispy> man i should have kept up on the python cvs reader thread
20:45:58 <lispy> i tried to do this a few months ago actually
20:46:21 <lispy> when my python implementation ate all my ram to hold a tiny file in memory i just threw it away and grabbed haskell
20:46:26 <lispy> the improvement was astonishing
20:46:39 <shapr> cvs? or csv?
20:46:40 <emk> Of course, you don't hear me complaining about punctuation when I'm using lhs2TeX...
20:46:44 <lispy> csv
20:46:54 <Cale> Verity Stob: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
20:46:57 <lispy> easy typo :)
20:47:05 <shapr> Cale: haha!
20:47:07 <emk> Cale++
20:47:08 <lispy> heh
20:47:23 <reilly> there is something beautiful in a language where the AST and text representations are so harmonious
20:47:23 <emk> And I speed as a Lisp geek, here...
20:47:31 <reilly> meaning lisp
20:47:54 <lispy> yeah, but lisp ain't all that...
20:48:00 <lispy> oh it's good
20:48:11 <lispy> but, the lack of type checking is a big deal
20:48:13 <emk> reilly: Really, just having first-class extensible syntax which is documented (hint, hint, Template Haskell) is a big win.
20:48:13 <Pseudonym> Lisp is great if you don't mind your code looking like data.
20:48:31 <lispy> Pseudonym: a good lisper forgets the difference
20:48:36 <shapr> Reminds of my recent blog post that got started as a reply on slashdot, but I just didn't bother putting it up there. Reason being that I knew the only people who would respond intelligently to amortized algorithms comments on slashdot are already here on #haskell!
20:48:46 <dons> heh
20:48:52 <Pseudonym> A bad lisper also forgets the difference, though.
20:48:52 <reilly> lispy: agreed on both
20:49:47 <shapr> I think the biggest problem with programming languages is that people often forget that everything is imperfect.
20:49:48 <reilly> i'm not familiar with template haskell
20:49:56 <dons> so i think know after going through 4 wireless cards, i may have finally found one in sydney that will work with open source out of the box
20:49:59 <shapr> @quote hakko
20:49:59 <lambdabot>  most programmers have a lot of religious issues about their work, yes.
20:50:06 <dons> luckily i've only paid for 1/4
20:50:10 <lispy> i think lisp taught me a lot of really improtant things, but now that i have haskell i wouldn't say i miss it...although if you took away my haskell i'd have a hard time choosing between the warts of python and the antiquity of lisp
20:50:10 <shapr> dons: Atheros?
20:50:23 <dons> nah, Atheros was flakey / not supported
20:50:25 <dons> ralink
20:50:28 <shapr> lispy: Why choose? Make your own!
20:50:35 <dons> (they actually gave docs to openbsd, so looks promising)
20:50:42 <dons> but took a while to find the ralink card
20:50:49 <shapr> oooh
20:50:51 <Cale> lispy: What do you think of scheme?
20:50:53 <shapr> Never heard of ralink, where do I get one?
20:50:54 <dons> The problem with atheros is there are too many new chipets coming out
20:51:07 <shapr> oh
20:51:09 <lispy> Cale: i think i've never used it, but in the above comment i would list it as a lisp
20:51:09 <dons> so you can get a 511 that's got some arbitrary chipset inside
20:51:12 <glguy> dons: so no joy w/ your wifi?
20:51:17 <dons> and you won't know until you plug it in.
20:51:23 <shapr> dons: sucks
20:51:29 <dons> glguy: not with last week, or monday. but i think i've got a winner now.
20:51:34 <shapr> These days the package should really list the chipset.
20:51:35 <dons> the ralink guys actually talk about their linux support
20:51:46 <dons> and how they gave their docs to Theo et al.
20:51:52 <Cale> lispy: yeah, it's just that it fixed most of the things which annoyed me about common lisp (apart from the lack of typing)
20:51:53 <emk> Oddly, I have to give a shout-out to the Ruby metaprogrammers here: On average, using other people's Lisp macros is about as pleasant as using their underwear. But in last year's Ruby hacking, I liked about 80% of the metaprogramming stuff floating around the net. They hit some kind of sweet spot a step or two below full macros, and people seem to screw it up less.
20:51:53 <shapr> I got a freebie wifi hub a coupla days ago, it's ancient.
20:51:54 <dons> so... hope it arrives today.
20:52:20 <dons> yeah, all the old stuff based on prism / orinocco just works.
20:52:27 <shapr> dons: You could buy a GNU USRP and use the Haskell 802.11 implementation.
20:52:29 <dwm> Reading about the "Blub paradox" in _Why Haskell Matters_ was instructive to me, speaking of people being religious or whatever about their favorite languages.
20:52:35 <lispy> emk: yeah, wearing other people's underwear is unhygenic :)
20:52:36 <dons> shapr: heh
20:52:37 <shapr> Wouldn't be high speed exactly....
20:52:49 <emk> lispy: Argh! Argh! Fie on you!
20:52:51 <reilly> lispy: good pun
20:53:07 <svref> lispy: ow
20:53:26 <shapr> dwm: Yes, the real answer is that one hundred years from now programmers will be using something better, and NOBODY has that thing right now! So let's try to steal some goodies from the future!
20:53:35 <reilly> lispy is an uncommon schemer, it seems
20:53:49 <shapr> reilly: The nick gives it away.
20:53:59 <lispy> oh my spam folder just exceeded 2k messages (and messages > 30 days get deleted automatically)
20:54:25 <lispy> 2002 messages
20:54:25 <emk> shapr: I've got to give Haskell credit, there. It's a lot closer to the language of 20 years from now than I think (say) Paul Graham's Arc will ever be.
20:54:30 <lispy> hot dig ity
20:54:47 <reilly> shapr: the nick exposes his preferred lisp dialect?
20:55:03 <lispy> i bet Arc will run on Hurd and you can use it between matches of duke nuke 'em forever
20:55:07 <dons> huh, google really picks up the new HWN issues quickly
20:55:18 <dons> that was about 30 mins before it appeared in the haskell blog feed google produces
20:55:33 <lispy> dons: you can tell the google bot how often to index and when, someone probably did that
20:55:38 <dons> ah maybe
20:56:14 <lennart> only 2k spam?
20:56:17 <jcreigh> lispy: Really?
20:56:18 <emk> shapr: If only because Haskell is the only language which has been willing to lock state in a tiny little box and try to find functional solutions to everything, which is the only approach that will keep scaling now that clock speeds have stalled.
20:56:18 * lispy wonders which will be released first, Vista, Duke Nuke 'em forever or GNU/Hurd
20:56:43 <lennart> my bet is on Vista
20:56:48 <dons> heh
20:56:53 <dons> or haskell' :)
20:56:56 <lispy> lennart: don't be so sure :)
20:56:57 <lennart> haha
20:57:13 <lispy> jcreigh: really to which? the spam?
20:57:18 <Cale> and when DNF comes out, will it run on Vista or Hurd?
20:57:29 <lennart> win98
20:57:37 <jcreigh> lispy: I didn't know there was a way to talk to Googlebot other than robots.txt
20:57:38 <lispy> i have the catch all of several domains, plus email addies i've had for years all forwarding to my gmail
20:57:42 <lispy> so it backs up pretty quick
20:57:54 <lispy> jcreigh: i think there is a form you can fill out
20:58:13 <dwm> lennart: heh
20:58:39 <lispy> if they do ever release DNF it will be a big deal :)
20:58:45 <thetallguy> In what context did Larry Wall utter that quote?
20:58:52 <lispy> ?users
20:58:55 <lambdabot> Maximum users seen in #haskell: 256, currently: 221 (86.3%), active: 30 (13.6%)
20:59:11 * lispy thought haskell seemed to be active but is shocked by only 30 active
20:59:12 <lennart> oh, I'm approaching 1GB in my spam folder :)
20:59:24 <lispy> lennart: but how often does it empty?
20:59:29 <lennart> never
20:59:31 <wolverian> thetallguy, on #perl6, talking about the --> operator in perl6 and the similarity to haskell's ->
20:59:56 <wolverian> if I guessed which quote you meant right
21:00:00 <dons> thetallguy: yep. what wolverian said.
21:00:01 <lispy> lennart: google automatically deletes my messages when they reach 30 days so i don't know how many i've had total
21:00:05 <Cale> -> as in case expressions?
21:00:12 <glguy> lambda expressions?
21:00:30 <thetallguy> Beautiful.
21:00:32 <lispy> or in the type system?
21:00:37 <wolverian> Cale, as in signatures. --> in perl6 delimits the signature and the return value.
21:00:38 <lennart> lispy: this is my spamassasin spam.  i can't count the spam blocked by grey filtering, which is a lot
21:00:44 <wolverian> (well, it's a part of the signature.)
21:01:00 <wolverian> s,value,type,
21:01:01 <lispy> lennart: ah, yeah spamassassin is nice
21:01:12 <lispy> lennart: baysian seems to be quite good too though
21:01:17 <lennart> lispy: I use 3 spam filters
21:01:33 <lennart> i get about 1000 spams per day so i need filters :)
21:01:34 <lispy> lennart: i spamassassin all the mail before it gets to gmail
21:01:37 <Cale> It's really interesting to have all these perl people getting serious exposure to Haskell :)
21:01:41 <lispy> lennart: so i bet that helps the baysian
21:01:48 <lispy> lennart: oh geez
21:01:58 <wolverian> Cale, most of all larry! :)
21:02:21 <glguy> once they get Perl6 written in Haskell, it's a shame that they have to rewrite it all in Perl6
21:02:39 <lennart> glguy: maybe they will fail :)
21:02:43 <dons> seems like a lot of work....
21:02:45 <Cale> glguy: that's okay, by the time they're done, they'll be the same language
21:02:49 <dons> kind of like hugs still being in C, right?
21:03:23 <dons> i suspect the haskell impl will stick around as the reference impl.
21:03:30 <glguy> Cale: so you think they'll just able to write a simple text parser to transform the source into perl6 code? (c:
21:03:35 <dons> at least, that's what I'd do.
21:03:54 <dons> glguy: run it through pugs, perhaps? :)
21:04:05 <dons> in reverse
21:04:24 <glguy> heh
21:04:30 <dibblego> how do you make [] of type [[]] ?
21:04:37 <dons> > [] :: [[Int]]
21:04:38 <lambdabot>  []
21:04:40 <glguy> [[]] isn'ta type
21:04:46 <dons> ?kind [[]]
21:04:47 <lambdabot>   `[]' is not applied to enough type arguments
21:04:47 <lambdabot>   Expected kind `*', but `[]' has kind `* -> *'
21:04:58 <dibblego> I think I've confused the buggery outta myself
21:05:03 <dons> well, kind worked there anyway :)
21:05:07 <dons> ?kind ([]) ([])
21:05:08 <lambdabot>   `[]' is not applied to enough type arguments
21:05:08 <lambdabot>   Expected kind `*', but `[]' has kind `* -> *'
21:05:11 <dons> nah
21:05:12 <lispy> glguy: no but it is polymorphic which is what i think dibblego wanted to exploint
21:05:40 <glguy> lispy: then he doesn't need to specify
21:05:42 * lispy isn't sure though
21:05:46 <dons> > [] : [[a]]
21:05:46 <lambdabot>  Not in scope: `a'
21:05:52 <dons> > [] :: [[a]]
21:05:52 <lambdabot>  Add a type signature
21:05:56 <dons> yeah yeah
21:06:06 <dibblego> I have two functions: Eq a => [a] -> a -> [[a]] and [[a]] -> a -> [a] and I want them to be symmetric, but quickcheck is failing for the empty list
21:06:07 <lispy> > [] :: forall a. [[a]]
21:06:07 <lambdabot>  Parse error
21:06:18 <dwm> I was actually wondering why it doesn't make sense for Pugs to be the VM. I have not done any reading about the issues, I admit.
21:06:21 <dons> it won't find a Show instance
21:07:00 <lispy> yeah, the perl hackers i know treat pugs as a big practical joke
21:07:14 <dons> ?
21:07:19 <syntaxfree> lispy: are there perl hackers?
21:07:22 <dibblego> (\x y -> (f1 (f2 x y) y) == x) is failing for null x
21:07:25 <syntaxfree> I thought perl was a quick hack.
21:07:28 <lispy> sort of like, "Wow, look at the gall of those haskell people.  Anyway, back to working on the *real* perl6"
21:07:36 <lispy> well, perl users
21:07:41 <dons> dibblego: ?
21:07:49 <syntaxfree> why would they?
21:07:58 <dibblego> dons, I should say it is returning False
21:08:02 <wolverian> lispy, it's partly because of the performance, and partly because of the desire to get perl6 on parrot.
21:08:11 <wolverian> lispy, however, no-one on #perl6 treats pugs that way. :)
21:08:14 <dons> lispy: hehe. well when the real perl6 written in perl gets done, they can celebrate....
21:08:29 <lennart> dibblego: so figure out why it fails
21:08:35 <syntaxfree> lispy: interestingly, Larry Wall takes every chance he can to say Haskell is only for people with 180 IQs.
21:08:36 <dibblego> f1 :: Eq a => [a] -> a -> [[a]] and f2 :: [[a]] -> a -> [a] I want (\x y -> (f1 (f2 x y) y) == x) to fail for null x
21:08:40 <dibblego> lennart, I am trying
21:08:42 <lispy> does pugs really have bad performance?
21:08:50 <dibblego> er, I *don't* want it to fail
21:08:58 <lispy> syntaxfree: that that just means he doesn't get haskell
21:09:07 <dons> Randal Schwarz's recent pugs / perl6 article was full of praise of haskell and pugs
21:09:11 <lispy> because i'd say haskell makes life simpler :)
21:09:18 <dons> I've only seen good news stories about pugs recently
21:09:21 <dibblego> > [] == [[]]
21:09:22 <lambdabot>  Add a type signature
21:09:24 <lennart> dibblego: apply f2 to [] and y and see what it gives you
21:09:28 <syntaxfree> lispy: Guido van Rossum doesn't get Haskell.
21:09:42 <syntaxfree> in fact, GvR seems to think the only thing that matters about programming languages is syntax.
21:09:44 * lispy doesn't get python
21:09:44 <lennart> > length []
21:09:45 <dibblego> lennart, []
21:09:45 <lambdabot>  0
21:09:52 <lispy> i've found that it has some warts that really frustrate
21:09:53 <syntaxfree> Python is like good Perl.
21:09:53 <lennart> > length [[]]
21:09:55 <lambdabot>  1
21:10:07 <dibblego> hrm
21:10:18 <lispy> i used to think that python was a clean language, then i looked a little past the syntax and found some cobwebs
21:11:00 <syntaxfree> GvR has gone as far as saying "looping is a higher-level construct than recursion".
21:11:22 <dwm> Perhaps it's not a bad idea to have Parrot written in Haskell.
21:11:23 <syntaxfree> Apparently pure-functional programming is an exercise in masochism Ã  la Malbolge.
21:11:23 <lispy> looking in haskell is built on recursion
21:11:26 <lennart> syntaxfree: well, for Haskell GvR is right
21:11:35 <lispy> er looping not looking
21:11:50 <lispy> ?type iterate
21:11:52 <lambdabot> forall a. (a -> a) -> a -> [a]
21:12:10 <syntaxfree> bizarrely, I can connect to IRC, various IMs, an internet radio, but can't open websites.
21:12:26 <Cale> syntaxfree: misconfigured proxy?
21:12:34 <dons> lennart: heh
21:12:42 <lispy> hmm..what is a def'n of iterate again?  im thinking something with fix but i'm not sure
21:12:50 <syntaxfree> I don't think so. Everything was fine 15 minutes ago.
21:13:07 <dibblego> a proxy written in an imperative language
21:13:07 <dibblego> ?
21:13:12 <lennart> iterate f x = x : iterate f (f x)
21:13:13 <Cale> iterate f x = x : iterate f (f x)
21:13:16 <syntaxfree> s/construct/concept./
21:13:21 <lispy> ah right
21:13:26 <syntaxfree> GvR claims that looping is recursion for smart folks.
21:13:31 <Cale> you get to hear it in stereo :)
21:13:31 <wolverian> anyway, the effort to define and build perl6 is a community one, so I don't really get the hate in the matter. and in any case, larry has said that there probably won't be _the_ perl6. the spec is completely independent of the implementation.
21:14:04 <lispy> wolverian: maybe the perl hackers i know are being silly then
21:14:10 <wolverian> lispy, of course they are.
21:14:13 <lispy> (wouldn't surprise me :)
21:14:22 <wolverian> every community has its fools :)
21:14:41 * lispy notes that his village has been missing one for a while now :)
21:14:49 <dibblego> what about the community of non-fools?
21:14:53 <syntaxfree> there is some psychological sense of inferiority when some free jazz-listening haskell weirdos reimplement your bread-and-butter language in 15 days : )
21:15:05 <dons> hehe
21:15:06 <syntaxfree> dibblego: remember, "fool" is a relative concept.
21:15:12 <syntaxfree> dibblego: hence Sturgeon's law.
21:15:20 <lispy> syntaxfree: heh, pugs wasn't really created in 15 days was it?
21:15:24 <dibblego> syntaxfree, indeed :)
21:15:25 <wolverian> well, it wasn't a full implementation... but yes :)
21:15:32 <lispy> damn
21:15:46 * lispy can't create jack squat in 15 days :)
21:16:21 <syntaxfree> I'd like to see a gallery of actual pictures of people in this channel.
21:16:33 <syntaxfree> The haskell hackers I've seen are pretty odd-looking.
21:16:38 <syntaxfree> sp Wadler.
21:16:43 <lispy> heh
21:16:51 <lispy> everyone at the haskell-workshop seemed normal to me
21:16:54 * Agaths looks normal
21:17:06 <syntaxfree> then again, you are a haskell hacker.
21:17:07 * dibblego looks for someone normal
21:17:11 <syntaxfree> :)
21:17:19 <lispy> some of them even look stylish like they could get chics no problem (and the female ones were cute)
21:17:41 <syntaxfree> stylish and sexually attractive are ortogonal  to odd.
21:17:48 <syntaxfree> ortogonal or orthogonal?
21:17:51 <wolverian> ...the stylish ones are after the boys, no? :)
21:17:52 <lispy> th
21:17:59 <lispy> heh
21:18:19 * lispy is just saying...haskell hackers are not all freaks :)
21:18:36 <lispy> in fact it seems that most are pretty normal
21:18:43 <lispy> at least the ones that get out and go to a conferece
21:19:24 <syntaxfree> I mean, youtube got sold for 1.650.000.000 dollars.
21:19:48 <syntaxfree> Geekiness ==> Bling bling.
21:20:07 <lispy> that's just crazy
21:20:26 <syntaxfree> what's just crazy?
21:20:35 <dylan> a geek is not measured by how he or she looks, but by the quality of their puns.
21:21:25 <dons> hwn news up on reddit.com, stick some votes on it so it doesn't disappear, http://programming.reddit.com/info/lj1p/details
21:21:28 <lambdabot> Title: Haskell weekly news, 06-10-10: inotify bindings, monad transformers, and darcs t ..., http://tinyurl.com/hfn53
21:21:45 <syntaxfree> what is reddit?
21:22:05 <dons> a PL news aggregator of sorts
21:22:07 <lispy> bleh, it requires an account
21:22:16 <lispy> and i'm a neo-luddite
21:22:20 <syntaxfree> like digg?
21:22:30 <dibblego> http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html split [] delim = [""] seems wrong to me - I think it should be split [] delim = [] ?
21:22:34 <lambdabot> http://tinyurl.com/fhss7
21:22:35 <dons> lispy: please :) its sitting on 1up, 1dn, which means currently its dissappeared
21:22:43 <lispy> i still can't believe i made it on HWN without even trying :)
21:22:54 <dons> lispy: takes about 2 seconds to get an account - no emails or such
21:22:56 <emk> Yow, there's a lot of good papers in the Haskell world.
21:23:46 <syntaxfree> if there's one good thing the so-called web 2.0 brought it's speedy sign-ups.
21:24:00 <syntaxfree> www.rssfwd.com is the best.
21:24:13 <lispy> i clicked it but nothing happens
21:24:23 <lispy> the arrow turns red and then clicked again and it turns grey
21:24:34 <dons> no. just click it once so its red.
21:24:39 <lispy> oh...weird
21:24:49 <dons> ok. good. we're back on the front page.
21:24:52 <satan> eh..can someone tell me when the following holds? [ x | x <- xs, y <- ys] = [x | y <- ys, x <- xs] ?
21:25:09 <lispy> try scheck?
21:25:15 <syntaxfree> well, y is irrelevant.
21:25:16 <satan> if there isnt a y in the expression, what difference does the y <- ys make?
21:25:24 <satan> ahh ok
21:25:27 <dons> ?check \xs ys -> [ x | x <- xs, y <- ys] == [x | y <- (ys :: T), x <- (xs :: T)]
21:25:28 <lambdabot>  Falsifiable, after 9 tests: [0,5,4,2], [4,5,3,-3]
21:25:35 <Cale> it makes quite a difference
21:25:35 <dons> ?scheck \xs ys -> [ x | x <- xs, y <- ys] == [x | y <- (ys :: T), x <- (xs :: T)]
21:25:41 <lambdabot> Terminated
21:25:44 <dons> too hard for scheck
21:25:58 <Cale> > [ x | x <- [1,2,3], y <- [1,2]]
21:25:59 <lambdabot>  [1,1,2,2,3,3]
21:26:03 <satan> i tried it with some examples, but didnt quite understand the behaviour
21:26:12 <Cale> > [ x | y <- [1,2], x <- [1,2,3]]
21:26:13 <lambdabot>  [1,2,3,1,2,3]
21:26:24 <Cale> > [ (x,y) | x <- [1,2,3], y <- [1,2]]
21:26:25 <lambdabot>  [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2)]
21:26:33 <Cale> > [ (x,y) |  y <- [1,2], x <- [1,2,3]]
21:26:34 <lambdabot>  [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2)]
21:26:37 <satan> so its taking the cross product, of sorts, even though y isnt showing up in the list itself
21:26:46 <satan> right
21:26:54 <syntaxfree> what is scheck?
21:26:57 <satan> so when are they equal? for that to hold...
21:27:32 <Cale> y would have to be length 1, or all the elements of x would have to be equal
21:27:47 <Cale> ys rather
21:27:51 <Cale> and xs
21:28:34 <satan> ah ok, thanks Cale
21:29:41 <Cale> ?scheck \xs ys -> [ x | x <- xs, y <- ys] /= [x | y <- (ys :: T), x <- (xs :: T)]
21:29:42 <lambdabot>   Failed test no. 1. Test values follow.: [], []
21:30:02 <dons> good idea Cale.
21:30:04 <Cale> ?scheck \xs ys -> xs /= [] ==> [ x | x <- xs, y <- ys] /= [x | y <- (ys :: T), x <- (xs :: T)]
21:30:06 <lambdabot>   Failed test no. 623531. Test values follow.: [-1], []
21:30:20 <dons> ?check \xs ys -> [ x | x <- xs, y <- ys] /= [x | y <- (ys :: T), x <- (xs :: T)]
21:30:21 <lambdabot>  Falsifiable, after 0 tests: [0], []
21:30:25 <Cale> ?scheck \xs ys -> length xs > 1 && length ys > 1 ==> [ x | x <- xs, y <- ys] /= [x | y <- (ys :: T), x <- (xs :: T)]
21:30:28 <emk> This paper is really quite good: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
21:30:29 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
21:30:29 <lambdabot>  Exception: stack overflow
21:30:36 <Cale> interesting
21:30:54 <lispy> dons: i dont' see HWN on their list at all
21:30:59 <lispy> but this caught my eye
21:31:01 <lispy> http://www.wpi.edu/News/Transformations/2002Spring/steel.html
21:31:03 <lambdabot> Title: WPI - Transformations: The "Deep Mystery" of Melted Steel, http://tinyurl.com/9f6nk
21:31:12 <Cale> that's exactly the sort of thing which should not create a stack overflow
21:31:15 <lispy> guess it's not really haskell centric though :)
21:31:15 <dons> lispy: reload, front page here, http://programming.reddit.com/
21:31:19 <lambdabot> Title: reddit.com: programming - what&#39;s new online
21:32:26 <sdfsdaf> > let { i m [] = m; i m (x:xs) = i (m++[x]) xs } in take 10 (i [] [1..])
21:32:30 <lambdabot> Terminated
21:32:39 <lispy> heeh, " If Neat Freaks use Java, and Slobs use Ruby, who uses ML?  "
21:32:50 <lispy> yes, indeed, who is using ML then?
21:32:51 <sdfsdaf> how to make it work?
21:33:09 <lispy> what is your base case?
21:34:11 <sdfsdaf> I'm trying to write a function that returns the shortest list in a list of lists which contains possibly infinite list(s)
21:34:12 <lispy> let { i m [] = m; i m (x:xs) = i (m++[x]) xs } in i [] [1..3]
21:34:15 <lispy> > let { i m [] = m; i m (x:xs) = i (m++[x]) xs } in i [] [1..3]
21:34:16 <lambdabot>  [1,2,3]
21:34:59 <lispy> > let { i m [] = m; i m (x:xs) = i (m++[x]) xs } in take 10 $ i [] [1..3]
21:35:00 <lambdabot>  [1,2,3]
21:35:09 <lispy> hmm...
21:35:15 <lispy> not sure why the first case didn't terminate
21:35:34 <lispy> unless i is somehow strict in the second argument
21:35:55 <Bobstopper> I've fixed the problems with running ghc under wine :D
21:36:07 <lispy> > let { i m [] = m; i m (x:xs) = i (m++[x]) xs } in take 1 $ i [] [1..]
21:36:11 <lambdabot> Terminated
21:36:24 <shapr> What's the deforested version of foldr (+++) (map pagelink pages) ?
21:36:33 <shapr> concatMapWith or something?
21:36:54 <lispy> shapr: no idea
21:37:16 <shapr> I know there's a way to merge the fold and map chunks there...
21:37:27 <dons> concatMap f             =  foldr ((++) . f) []
21:37:33 <lispy> ?type (+++)
21:37:34 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
21:37:54 <shapr> lispy: I'm using (Text.Html.+++)
21:38:06 <lispy> ?type Text.Html.(+++)
21:38:08 <lambdabot> Couldn't find qualified module.
21:38:11 <dons> ?check \f xs -> concatMap (f :: Int -> T) xs == foldr ((++) . f) [] (xs :: T)
21:38:17 <lambdabot> Terminated
21:38:25 <shapr> ?type (Text.Html.+++)
21:38:26 <lambdabot> forall b a. (Text.Html.HTML b, Text.Html.HTML a) => a -> b -> Text.Html.Html
21:38:32 <dons> ?check \f xs -> concatMap (f :: Int -> [Bool]) xs == foldr ((++) . f) [] (xs :: T)
21:38:38 <lambdabot> Terminated
21:38:43 <lispy> shapr: thanks, i always seem to make that mistake
21:38:53 <dons> ?check \f xs -> concatMap (f :: Bool -> [Bool]) xs == foldr ((++) . f) [] (xs :: [Bool])
21:38:57 <dons> boo
21:38:58 <shapr> Me too for a long time...
21:38:58 <lambdabot> Terminated
21:39:27 <lispy> > let { i m [] = m; i m (x:xs) = i (m++[x]) xs } in head $ i [] [1..]
21:39:31 <lambdabot> Terminated
21:39:37 <lispy> why is i behaving that way?
21:40:10 <Cale> it's tail recursive
21:40:13 <lispy> oh, (++) is strict?
21:40:20 <Cale> no
21:40:21 <sjanssen> @type \pagelink pages nil -> foldr (\x xs -> pagelink x Text.Html.+++ xs) nil pages
21:40:23 <lambdabot> forall a a1. (Text.Html.HTML a1) => (a -> a1) -> [a] -> Text.Html.Html -> Text.Html.Html
21:40:27 <lispy> Cale: and taht breaks laziness?
21:40:37 <Cale> lispy: i m [] will never match
21:40:46 <lispy> oh, duh
21:40:50 <Cale> you're just reducing the infinite list to another infinite lists
21:40:53 <Cale> list*
21:41:04 <lispy> yeah it seems pretty easy now :)
21:41:12 <lispy> soon as you mentoined that it will never match
21:41:19 * lispy has been slow lately
21:41:25 <Cale> Tail recursion is generally bad for laziness
21:41:28 <shapr> Yay! My extremely minimal wiki is working!
21:41:33 <lispy> guess i had a good hint when i asked what the base case was :)
21:41:39 <shapr> I have edit, show, and list pages.
21:41:49 <lispy> shapr: cool
21:41:51 <lispy> shapr++
21:41:53 <Cale> because it means that you have to go all the way to the bottom of a structure before you can return anythin
21:41:54 <Cale> g
21:43:07 <lispy> hmm..so i want to say somethnig like, 'fix on a tail-recursive function is bottom' but that's not true because you might hit a base case
21:44:18 <Cale> Tail recursive functions of lists traverse the entire list with which they are provided
21:44:24 <dibblego> ?hoogle [a] -> [Int] -> [[a]]
21:44:25 <lambdabot> No matches, try a more general search
21:44:54 <lispy> dibblego: what do you want? repate?
21:44:58 <dons> shapr: cool!
21:44:58 <lispy> er repeat
21:45:04 <dibblego> lispy, split
21:45:24 <lispy> dibblego: ah
21:45:39 <dibblego> f "abc,def,ghi" [3,6] = ["abc", "def", "ghi"]
21:45:59 <lispy> i have something like splitOn :: [a] -> [a] -> [[a]] at work but can't fetch it for you from here
21:46:12 <dibblego> what does that do?
21:46:14 <shapr> As soon as I've uploaded the binary, I'll show off my wiki!
21:46:14 <lispy> (there is an Eq a => in there)
21:46:25 <dibblego> Eq => [a] -> a -> [[a]]
21:46:34 <lispy> splitOn "-" "N-W" => ["N", "W"]
21:46:36 <dibblego> that's exact;y what I've been trying to write
21:46:42 <dibblego> but it's broken
21:46:47 <dibblego> I have to start again
21:47:03 <lispy> are you sure [a] -> a -> [[a]] makes sense?
21:47:03 <dibblego> I based it on http://julipedia.blogspot.com/2006/08/split-function-in-haskell.html
21:47:07 <lambdabot> http://tinyurl.com/fhss7
21:47:09 <dibblego> but now I think that is broken
21:47:16 <Cale> > break (==',') "abc,def,ghi"
21:47:17 <lambdabot>  ("abc",",def,ghi")
21:47:20 <dibblego> I'm pretty sure it does
21:47:34 <lispy> dibblego: you split based on the second argument?
21:47:36 <dibblego> ?type break
21:47:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:47:43 <lispy> ?type span
21:47:44 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:47:47 <lispy> i thinki used span instead of break
21:48:04 <lispy> dibblego: several implementations were given on haskell cafe lastmont or so
21:48:09 <lispy> dibblego: depending on how you wan to split
21:48:13 <dibblego> lispy, in that code, there is split [] delim = [""] -- I think this is wrong
21:48:30 <dibblego> split [] delim should be []
21:48:40 <lispy> ah
21:49:17 <lispy> god, i started getting blog spam
21:49:20 <lispy> lame!
21:49:25 <dibblego> I didn't see anything on haskell-cafe
21:49:26 <Cale> dibblego: it depends
21:49:42 <Cale> dibblego: What's the result of split "abc," "," ?
21:49:53 <lispy> dibblego: okay, hang on then, i'll search my gmail
21:50:09 <dibblego> ["abc", "", ","]
21:50:09 <Cale> or ',' depending on type
21:50:17 <Cale> hm?
21:50:31 <Cale> are you sure?
21:50:35 <dibblego> no
21:50:48 <Cale> why the empty field, and then the "," ?
21:50:49 <dibblego> the main problem came when I wrote "unsplit" then tried to write quickchecks
21:51:29 <dibblego> and prove that (split (unsplit x y) y) == x for all x and y
21:51:51 <dibblego> I have a contradiction somewhere - I am not sure where
21:52:23 <dibblego> unsplit a b = concat $ intersperse [b] a
21:52:38 <dibblego> I think I need a break
21:53:38 <dibblego> does it even make sense for (split (unsplit x y) y) == x for all x and y?
21:54:16 <dons> maybe, like lines/unlines could have been
21:54:19 <dons> or words/unwords
21:54:30 <dibblego> "could have been" -- they are not?
21:54:44 <dons> for example, in Data.ByteString, prop_joinsplit c xs = L.join (pack [c]) (L.split c xs) == id xs
21:55:09 <dons> ?check \xs -> unwords (words xs) == id xs
21:55:10 <lambdabot>  OK, passed 500 tests.
21:55:20 <dons> ?check \xs -> unlines (lines xs) == id xs
21:55:22 <lambdabot>  Falsifiable, after 1 tests: "\306431"
21:55:31 <dons> ?check \xs -> unlines (lines xs) /= id xs
21:55:32 <lambdabot>  Falsifiable, after 0 tests: ""
21:55:36 <dibblego> hrm, maybe it is my quickcheck then
21:55:38 <dons> not what I meant :)
21:55:52 <lisppaste2> lispy pasted "various splits" at http://paste.lisp.org/display/27701
21:55:57 <dons> well, check your property. how does it handle the sep char at the  end of the line, for example?
21:55:59 <dibblego> thanks lisppaste2
21:56:08 <lispy> dibblego: there are some of the implementations that come up in the email thread
21:56:19 <dibblego> dons, you mean Cale's example?
21:56:25 <dibblego> split "abc," ','
21:56:38 <dibblego> er lispy
21:56:55 <lispy> dibblego: common miscompletetion i'm used to it :)
21:57:05 <dibblego> lispy, I figured that :)
21:57:27 <dons> ?check \xs -> unlines (lines (xs ++ "\n")) /= id (xs ++ "\n")
21:57:28 <lambdabot>  Falsifiable, after 0 tests: ""
21:57:37 <dons> ?check \xs -> unlines (lines (xs ++ "\n")) == id (xs ++ "\n")
21:57:38 <lambdabot>  OK, passed 500 tests.
21:57:43 <dons> the sep-at-end issue
21:58:19 <dons> > unlines ["haskell", ""]
21:58:20 <lambdabot>  "haskell\n\n"
21:58:30 <dons> > lines "haskell\n\n"
21:58:31 <dibblego> split "abc," ',' == ["abc", ""]
21:58:31 <lambdabot>  ["haskell",""]
21:59:11 * lispy prefers splitOn :: Eq a => [a] -> [a] -> [[a]]
21:59:20 <lispy> it's more like spliting on a subseq
21:59:37 <lispy> the version i have at work is fully debugged...so i wish i could hand it to you from here
21:59:47 <lispy> i should make my 'utility' functions available on the web
21:59:53 <dibblego> wouldn't that function just call this function?
21:59:54 <lispy> they are really orthogonal to my work
22:00:27 <lispy> what would happen ifi called splitOn "foo" "afoobfoocfoo" ?
22:00:34 <lispy> how would you generate that from your split?
22:00:48 <dibblego> what would your current splitOn do?
22:00:49 <Korollary> hi mathewm
22:00:55 <mathewm> hey there
22:01:09 <lispy> dibblego: ["a", "b", "c"]
22:01:21 <lispy> maybe with an extra "" at theend, i can't remember
22:01:25 <dibblego> oh I was looking at the arguments wrong way around
22:01:48 <lispy> dibblego: ah yeah i gave it in whatever it's called order
22:01:59 <lispy> the argument which is most likely to vary is given last
22:02:12 <lispy> usually you have a set splitting param and you splits many things
22:02:12 <dibblego> it would have to search the list once per character
22:02:47 <dibblego> I think both functions are needed
22:02:50 <lispy> with mine you can do (map (splitOn "foo") listofstrings) to split a bunch of strings
22:02:57 <dibblego> there is also Eq a => [a] -> [a] -> [[a]]
22:03:04 <lispy> that's what mine is :)
22:03:47 <lispy> which lets you implement Eq a => a -> [a] -> [[a]] by split a = splitOn [a]
22:03:50 <dibblego> where splitOn "abc" "12a345b678c9" == ["12", "345", "678", "9"]
22:04:01 <lispy> Ah
22:04:10 <lispy> so split on any one of
22:04:12 <lispy> gotcha
22:04:14 <dibblego> right
22:11:26 <emk> Yeah, that new monad transformers paper is the best intro I've seen yet.
22:12:50 * lispy goes off to install hope
22:13:32 <lispy> ?where hope
22:13:32 <lambdabot> http://hope.bringert.net/
22:14:29 <lispy> okay, we need darcs://
22:14:47 <lispy> i'm getting sick of cutting and pasting darcs urls off of webpages
22:15:03 <lispy> i want to just click on it and have my webbroweser ask me where to place the repo
22:16:18 <dons> write a browswer plugin for darcs urls then.. :)
22:16:29 <dons> maybe just a config setting would work?
22:17:06 <lispy> i'm not sure
22:17:18 <hyrax42> doesn't work if they're not link-tagged
22:17:23 <sdfsdaf> is it possible to make this AppendList implementation support infinite lists?
22:17:23 <sdfsdaf> http://www.haskell.org/hawiki/DerivingFromSpecifications
22:17:24 <lispy> i don't know much about making ff do things
22:17:26 <lambdabot> Title: DerivingFromSpecifications - The Haskell Wiki, http://tinyurl.com/mqcle
22:17:27 <shapr> lispy: cabal-install has almost all the hope deps
22:17:33 <hyrax42> unless you go with greasemonkey
22:17:43 <lispy> shapr: cool
22:23:13 <lispy> oh hm...haxml is broken
22:23:41 <lispy> maybe it's just the make file that is broken
22:23:46 <lispy> the cabal build seems to be fine
22:24:36 <shapr> hej bringert!
22:24:43 <shapr> Just talar vi om Hope
22:24:50 <lispy> bringert: hey
22:24:53 <shapr> och jag lÃ¤r mig HAppS
22:25:06 <shapr> um "Just nu"
22:25:10 * shapr Ã¤r lite somnig
22:25:20 <bringert> good morning
22:25:23 <lispy> bringert: i still don't have a darcs.haskell.org account :( but i think i might mirror lambdaweb on my server
22:25:38 <lispy> bringert: about to install hope at the moment :)
22:25:40 <shapr> lispy: Why don't you have an account?
22:25:51 <bringert> lispy: good luck!
22:25:53 <lispy> shapr: probably because i asked the busiest person i could for one :)
22:26:01 * bringert goes to take a shower
22:26:04 <lispy> shapr: simonm i dont' think has had time to think about it
22:26:06 <shapr> oh
22:27:08 <shapr> Now to figure out how to slap a wiki syntax to HTML renderer on top of all this...
22:27:42 <lispy> shapr: you could borrow from hope
22:27:52 <shapr> Yeah, either Hope or Flippi, not sure which is easier.
22:27:54 <lispy> shapr: and then contribute back :)
22:28:05 <lispy> which would save me time
22:28:11 <lispy> since i want to add some more wiki to hope
22:28:28 <lispy> and make it call out to geshi instead of hscolor so i get more languages
22:28:55 <shapr> Ok, try http://www.scannedinavian.com:8000/wiki/FrontPage
22:28:59 <lambdabot> http://tinyurl.com/zser8
22:29:22 <lispy> cool!
22:29:28 <lispy> you have your first wiki spam!
22:29:42 <shapr> I do?
22:29:45 <lispy> yeah
22:29:48 <shapr> haha
22:29:48 <lispy> reload :)
22:30:02 <shapr> I haven't thought about how to do RecentChanges yet
22:30:13 <shapr> But listing pages works just fine.
22:30:38 <lispy> now you have some more conventional spam
22:31:03 * shapr laughs
22:31:38 * shapr creates a page about lispy
22:31:42 <lispy> ah i see, no wiki transformations yet
22:31:48 <shapr> No, nothing at all.
22:32:05 <shapr> It's designed to be step four in the HAppS tutorial, so it just saves and shows pages.
22:32:56 <lispy> ah
22:33:00 <lispy> well, it seems to work well
22:33:08 <shapr> So, should I add wiki syntax to html rendering, or should I stick on user sessions so I can learn how that works?
22:33:09 <shapr> hmm
22:33:18 <lispy> er
22:33:25 <lispy> did someone print $ fix $ show?
22:33:43 <shapr> ?
22:33:48 * ThreeQ did
22:33:59 <shapr> You mean those zillion backslashes on the FrontPage?
22:34:07 * lispy has a function to compute powers of two from fix show
22:34:17 <lispy> > fix show
22:34:18 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:34:22 <shapr> cute :-)
22:34:30 <ThreeQ> lispy: it was featured in the hwn
22:34:39 <lispy> haha
22:34:40 <lispy> cool
22:34:43 <shapr> Anyway, this is not bad for a few hours hacking.
22:34:51 <lispy> shapr: not bad at all
22:35:06 <Pseudonym> So... where's FLM?
22:35:13 <shapr> I'm getting there :-)
22:35:45 <shapr> My favorite thing about HAppS so far is how fast it is.
22:35:46 <bringert> shapr: hope's wikitext to html stuff is now a separate library
22:35:53 <shapr> yay!
22:35:55 <bringert> all to make hope mor of a pain to build
22:35:55 * shapr boings
22:35:59 * shapr laughs
22:36:02 <lispy> heh
22:36:11 * lispy is building haskelldb
22:36:24 <bringert> http://darcs.bringert.net/hmarkup/doc/
22:36:56 <dibblego> I have found the contradiction
22:37:00 <bringert> lispy: if you want to hack on hope, you might want to start looking at the session stuff
22:37:05 <shapr> bringert: That's not listed on either the Hope blog or your projects page.
22:37:07 <shapr> hey jewel
22:37:08 <bringert> it needs to be fixed
22:37:21 <lispy> bringert: ah, really i want better wikimarkup, but that's good to know too
22:37:37 <lispy> bringert: i've come to really hate wordpress
22:37:43 <lispy> it's evil
22:37:44 <shapr> bringert: Oh, did I tell you about the bug where the gallery is being viewed while someone else uploads a picture? It results in the uploaded picture not arriving for whatever reason.
22:38:23 <bringert> lispy: the session stuff is a bit braindead, the session table is never purged, and anonymous users get sessions, so the table grows pretty big
22:38:36 <shapr> I just set my session timeouts to half an hour.
22:38:39 <jewel> hiya shapr
22:38:55 <bringert> and there is no index on the session key, cause haskelldb doens support that yet
22:39:36 <lispy> hmm..
22:39:38 <bringert> shapr: I think you did. I can't see why that would happen. strange
22:39:41 <lispy> why doesn't haskelldb support that?
22:39:51 <bringert> nobody has implemented it
22:40:10 <bringert> should be pretty easy
22:40:59 <bringert> shapr: I'm pretty bust atm, so I'm relaying on hope user's to send patches for the time being
22:41:09 <shapr> ok
22:41:13 * bringert goes to grab breakfast
22:41:20 <lispy> bringert: thanks!
22:41:31 <shapr> I'm hoping for a profitable fusion of Hope and HAppS.
22:42:07 * shapr builds hmarkup
22:42:26 <lispy> heh, i was just trying to build that :)
22:42:32 <lispy> turns out i needed xhtml still
22:42:45 <lispy> cabal + darcs is crazy
22:42:46 <shapr> I have XHtml, but I've been using Text.Html
22:42:48 <shapr> time to switch!
22:42:49 <lispy> like crazy cool
22:43:05 <shapr> Yeah, I agree. I'd like to see a bit more integration though.
22:44:12 <lispy> yeah, hopefully hackage will integrate with darcs
22:44:37 <lispy> so that it can automatically update some sort of 'incoming' which can then be verified and turned into unstable
22:44:43 <bringert> shapr: will you run hope on happs then?
22:45:05 <bringert> I've been hacking on Haskell Web Server by the way
22:45:11 <bringert> added CGI
22:45:18 <lispy> okay, all the dependencies are installed except one little detail with haskelldb
22:45:27 <shapr> I'm going to try mixing Hope and HAppS, don't know how it'll turn out.
22:45:50 <bringert> and a module system, and rewrote large parts
22:45:51 <bringert> http://www.cs.chalmers.se/~bringert/darcs/hws-cgi/
22:45:54 <lambdabot> Title: Index of /~bringert/darcs/hws-cgi, http://tinyurl.com/jwjwp
22:46:30 <shapr> bringert: Have you announced it on haskell-general?
22:46:43 <bringert> nope
22:46:45 <satan> i'm trying to convert [(x,y) | x <- [1..10], odd x, y <- [1..10]] to a combinatory style, and i think i have something but it gives me an error: No instance for (Show (a -> [b -> (a, b)] -> [b -> (a, b)]))
22:46:52 <lispy> bringert: does it matter which HSQL plugin i install? I usually use mysql (historical reasons)
22:46:53 <bringert> I've used it for teaching so far
22:47:15 <bringert> lispy: not really, it should work with any of them
22:47:22 <lispy> nice
22:47:23 <shapr> I'd suggest either announcing it or asking dons to put it into HWN, lots of people will find it valuable.
22:47:35 <bringert> hope.bringert.net uses HSQL MySQL
22:47:48 <bringert> shapr uses PostgreSQL I think
22:47:49 <shapr> I use PostgreSQL for Hope
22:47:54 <shapr> xerox uses FlatDB
22:47:58 <dons> everyone should announce every new project to haskell@, imoi.
22:48:01 <sjanssen> satan: looks like you're attempting to show a function, which is impossible
22:48:21 <satan> sjanssen: ah ok
22:48:30 <dons> > \x -> (x :: Int) -- or is it !? :)
22:48:31 <lambdabot>  <Int -> Int>
22:48:32 <sjanssen> satan: you've probably got a small typo somewhere, impossible to tell without seeing the code
22:48:41 <satan> should i pastebin?
22:49:03 <sjanssen> sure, why not
22:49:04 <lispy> oh no...
22:49:15 <lispy> i don't have mysql.h
22:49:22 <shapr> Man, I need a deb of fps/ByteString, these days *everything* uses it.
22:49:26 <satan> ok http://nanobin.nanosouffle.net/1734
22:49:29 <lambdabot> Title: nanoPaste your Crap
22:49:53 <lispy> oh yeah, i modified haxml to use fps
22:50:01 <lispy> i need to get taht integrated into the main stream haxml
22:50:04 <shapr> Yeah!
22:50:11 <shapr> That would speed up HAppS even more.
22:50:14 <lispy> HUGE improvement in preformance for me
22:50:31 <lispy> on the memory footprint improvement was at least an order magnitude in my use case
22:50:52 <shapr> At some point someone will figure out how to substitute Data.ByteString for String in GHC itself, and then it'll all work out just fine.
22:50:59 <lispy> haxml wants to always pretty print the output, but sometimes that just sucks
22:51:18 <shapr> Send patches to Malcolm, he's friendly.
22:51:38 <lispy> currently the problem is that i hacked a version that doesn't have  _darcs because it was from a tarball
22:51:54 <shapr> Diff it against the darcs repo?
22:51:55 <lispy> so i need to patch taht together and get upgraded to the state of the dev branch
22:52:03 <shapr> diff handles directories.
22:52:08 <lispy> hmm...
22:52:13 <lispy> that could be a nice way to go
22:52:28 <lispy> maybe by the end of the week i can do that
22:52:36 <lispy> i also extended the code generator
22:52:46 <lispy> i found that the datatypes it generated were a PTA to work with
22:52:47 <shapr> Did you hack HaXml 1.13?
22:52:52 <lispy> so i created constructor functions
22:52:55 <lispy> yeah 1.13 exactly
22:53:15 <lispy> it automatically generates mkFoo and fills in all the Maybes with Nothings
22:53:36 <lispy> so most of the datatypes it generates can be easily constructed in a few lines of code
22:53:46 <shapr> I'd really like to get a ByteSting-using 1.13 version, that's what most things use these days.
22:53:51 <shapr> The dev version is 1.17 or something.
22:54:09 * shapr swears viciously at his ISP
22:54:12 <lispy> okay, i'll make sure you're included when i make that patch
22:54:18 <shapr> incompetents!
22:54:30 <lispy> so that even if it's not accepted you'd have access to the changes
22:54:30 <hyrax42_> @fptools Control.Monad.Trans
22:54:30 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Trans.hs
22:54:47 <lispy> basically i just usuper the pretty printer and make it generate lazy bytestrings
22:54:52 <hyrax42_> @fptools Control.Monad.RWS
22:54:52 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/RWS.hs
22:55:08 <lispy> okay how do i get mysql.h on debian?
22:55:16 <shapr> apt-cache search mysql dev
22:55:17 <shapr> ?
22:55:32 <hyrax42_> ugh
22:55:35 <lispy> libmysql++-dev ?
22:55:39 * shapr doesn't know
22:55:39 <hyrax42_> what is the pragma to set command-line options in the file
22:55:47 <hyrax42_> {- #OPTIONS ... -}?
22:55:49 <shapr> yup
22:55:51 <dons> close.
22:55:54 <shapr> {-# OPTIONS -cpp -fallow-overlapping-instances -fglasgow-exts #-}
22:56:05 <hyrax42_> oh {-# ok
22:56:07 <hyrax42_> thanks
22:56:55 * lispy finds libmysqlclient-dev
22:58:10 <lispy> hmm...
22:58:13 <lispy> that's not it
22:58:41 <dibblego> try libmysql++-dev
22:59:31 <lispy> that one needs me to romev things want
22:59:52 <dibblego> I don't think that's it anyway
22:59:54 * lispy tries it anyway
22:59:58 <lispy> heh
23:00:04 * lispy might be in trouble :)
23:00:11 <dibblego> only from apt-file search
23:00:15 <dibblego> there is no mylsq.h
23:00:17 <dibblego> *mysql.h
23:00:51 <lispy> hmm...this seems bad
23:00:59 <lispy> apt is complinaing about corrupt files on update
23:01:04 <shapr> yikes
23:01:08 <shapr> apt-get check
23:01:19 <shapr> apt-get -f install
23:01:23 <Bobstopper> would there be any disadvantage if haskell/ghc's libraries were made categorical rather than hierarchical?
23:01:24 <lispy> well, it's the files it's trying to download that are corrupt
23:01:43 <lispy> check is happy
23:01:53 <lispy> -f install is happy
23:02:43 * bringert goes to supervise a haskell lab ession
23:03:37 * lispy deletes the corrupt files on his drive and retries the update
23:04:48 <shapr> Ya know, this whole virtual server thing is starting to get on my nerves.
23:05:04 <shapr> It's only $15 a month for my virtual server, but the guys running it have regular problems.
23:05:20 <dibblego> shapr, which guys?
23:05:22 <shapr> First the drive got corrupted, then they had some other outages, now the memory seems to be going bad.
23:05:25 <shapr> tektonic.net
23:05:52 <shapr> On the good side they're insanely cheap for the bandwidth and they offer a Debian virtual server.
23:05:57 <shapr> On the bad side...
23:06:13 * lispy watches in fear as mysql upgrades to version 5
23:06:37 <dibblego> have you looked at linode?
23:06:53 <shapr> No, but I'll check 'em out.
23:07:04 <shapr> hey skew
23:07:05 <satan> sjanssen: did you get a chance to have a look?
23:07:16 <lispy> well, my software seems to still be working
23:07:37 <dibblego> shapr, never used them, but heard good things
23:07:53 <skew> hi shapr. Coq is fun!
23:08:01 <lispy> ah yup, upgrading that fixed my missing file problem
23:09:19 <shapr> dibblego: If they're more reliable than tektonic, I'll probably switch.
23:09:47 <dibblego> shapr, ask slava in #concatenative - he uses linode
23:09:58 <lispy> slava?
23:10:03 <lispy> that name is familiar
23:10:06 <shapr> author of Factor
23:10:09 <lispy> sounds like a lisper
23:10:12 <shapr> and jEdit
23:10:15 <lispy> Ah!
23:10:16 <shapr> and other stuff too
23:10:16 <lispy> right
23:10:24 <lispy> cool hacker
23:10:30 <shapr> Slava Pestov
23:10:32 <shapr> Yeah, he is.
23:10:38 <skew> I think he was most recently mentioned in connection with some reddit thing the other day
23:11:44 <bdash> shapr: linode is ok, but their IO limiting can be an annoyance at times unless you keep an eye on things... obviously it completely depends what you're using it for :)
23:11:46 <shapr> I was paying $70 a month to colo my own server. That was nice.
23:12:19 <shapr> tektonic gives gobs of bandwidth for $15 a month. I've never gotten close to using half of it.
23:13:33 <shapr> On the downside, I get only 128mb of ram, and Zope can use that all by itself.
23:20:04 <satan> hmm i seem to be getting lists of lists, when i want just one list
23:20:12 <satan> can someone tell me how to fix this? http://nanobin.nanosouffle.net/1735
23:20:14 <lambdabot> Title: nanoPaste your Crap
23:20:56 <satan> the 2nd list is meant to be equivalent to the list comprehension above
23:21:47 * Lemmih is quite happy with his hosting arrangement.
23:22:23 <shapr> Yeah, but yours kicks serious ass.
23:22:28 <shapr> It can't be cheap.
23:22:37 <Lemmih> satan: concatMap makeTuples.
23:23:12 <satan> Lemmih: wow sweet thanks dude
23:23:26 <Lemmih> 49 euro + 19% VAT, not too expensive I think.
23:23:34 <satan> Lemmih: how would i do it with just map, though? i tried map ((++) . makeTuples) but it didnt work...
23:24:04 <Lemmih> satan: You can't.
23:24:29 <satan> Lemmih: ah alright
23:24:51 <Lemmih> satan: You could do it with a fold.
23:25:12 <satan> Lemmih: right, thats the next step :)
23:25:55 <bringert> funny, I'm not getting any questions today
23:25:59 * bringert is supervising a lab session
23:26:18 <bringert> maybe they all hate me after I forced them to build a wiki
23:26:25 <Pseudonym> bringert, where's the "any" key?
23:26:26 * shapr laughs
23:26:45 <bringert> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/e4fun/labs/wiki/description.html
23:26:48 <lambdabot> Title: Wiki lab, http://tinyurl.com/gglph
23:26:51 <shapr> bringert: They're scare you'll make them build amazon.com this time.
23:27:00 <bringert> I thought it was a fun exercise
23:27:11 <Pseudonym> Imagine their faces when you sell it for a billion dollars to Google.
23:27:23 <bringert> they made one per lab group
23:27:31 <bringert> so I'll get 20 billion
23:27:32 <Pseudonym> So... we can replace shapr by an undergrad?
23:27:36 <shapr> yikes!
23:27:48 <pejo> bringert, truly an entrepreneur!
23:27:51 <bringert> can we do it the other way around?
23:27:56 <shapr> I like it!
23:28:04 <shapr> I'd love to be an undergrad at Chalmers.
23:28:50 <Pseudonym> I must say, yes, the thought of heckling such truly smart people is quite appealing.
23:29:11 <lispy> i don't know how to configure Hope/Config.hs
23:29:29 <shapr> I was once in a meeting room at LuleÃ¥ university and the whiteboards had lots of monad code on them, so I added notes about arrows.
23:29:37 <shapr> I figured they'd be amused the next day.
23:29:54 <bringert> lispy: I don't hink you have to these days
23:30:03 <lispy> bringert: hmmm...
23:30:08 <shapr> What about base_url and stuff?
23:31:01 <hyrax42_> ?type assert
23:31:02 <lambdabot> Not in scope: `assert'
23:31:12 <hyrax42_> ?type Control.Monad.Exception.assert
23:31:13 <lambdabot> Couldn't find qualified module.
23:31:16 <hyrax42_> ugh
23:31:24 <hyrax42_> ?type Control.Exception.assert
23:31:26 <lambdabot> forall a. Bool -> a -> a
23:31:40 <hyrax42_> ?docs Control.Exception
23:31:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
23:31:50 <lispy> so set hopeHomepage
23:31:59 <lispy> what about hopeWebmasterEmail?
23:32:10 <lispy> and theme and Subtitle and Title?
23:32:11 <bringert> shapr: baseUrl is no more
23:32:29 <bringert> lispy: those are kept in the database these days
23:32:33 <lispy> Ah
23:32:44 <bringert> baseUrl is figured out from the CGI environment
23:32:53 <shapr> ah
23:33:07 <lispy> unknown package: exif, so i missed something
23:33:17 <bringert> is there an out of date install instruction somewhere?
23:33:33 <shapr> haskell-exif
23:33:35 <lispy> i'm using the readme
23:33:49 <lispy> well, i don't really want exif because i'm not using halbum
23:33:54 <shapr> lispy: You should really try cabal-install, xerox put all the hope packages into the default repo
23:33:54 <lispy> i disabled halbum
23:34:01 <lispy> Module_tag?
23:34:09 <bringert> lispy: this one http://www.cs.chalmers.se/~bringert/darcs/hope/INSTALL ?
23:34:13 <lambdabot> http://tinyurl.com/kyyer
23:34:25 <lispy> bringert: yeah
23:34:35 <bringert> lispy: you need to remove the -package exif flag from the makefile if you don't want to use it
23:34:43 <bringert> not done automagically
23:34:52 <bringert> remove -package gd while you're at it
23:35:31 <lispy> ah, i didn't think to look in the makefile :)
23:37:40 <lispy> oh weird, i know i installed HSQL-MySQL but it's telling me it cannot find Database.HasklelDB.HSQL.MySQL...hmeebet i need to edit something again
23:38:33 <lispy> no dice
23:39:37 <shapr> HSQL.MySQL is not HaskellDB.HSQL.MySQL
23:39:59 <shapr> You need both of those.
23:40:04 <lispy> so maybe i missed something in the haskelldb step
23:40:27 <shapr> iirc, you need HaskellDB, HaskellDB.HSQL, HaskellDB.HSQL.MySQL
23:40:36 <lispy> yup
23:40:37 <skew> haskelldb has a bunch of subdirs you need to also go build in, to get various drivers
23:40:39 <lispy> i see now
23:41:02 <skew> I wonder, is there any way to write stuff back to a database with haskelldb? I didn't see it in the docs
23:41:36 <shapr> Yes, you can.
23:42:24 <skew> ah, insertQuery?
23:42:38 <lispy> ah good, now hope is compiling
23:43:05 * skew bounces happily
23:43:10 <matthew-_> skew: you just do insert db
23:43:32 <skew> somehow I missed that the last time around.
23:43:37 <matthew-_> heh.
23:43:54 <skew> I've been writing database stuff in C at work for a while now
23:44:27 <shapr> imho the truly sexy part of HaskellDB is higher order queries.
23:44:32 <matthew-_> lucky lucky you!
23:44:34 <skew> I thought I could do it more typefully and an order of magnitude shorter with HaskellDB, but I couldn't find insert.
23:44:38 <shapr> That's just the coolest thing since sliced bread.
23:45:05 <skew> higher-order queries? or just queries parameterized on queries?
23:45:20 <shapr> Well, parameterized...
23:45:37 <skew> that's good too
23:45:45 * shapr thinks about that
23:45:59 <shapr> Actually, I think you can do higher order queries.
23:46:08 <skew> I suppose you could process query results into another query, but I'm not sure what that might be good for
23:46:41 <matthew-_> well, I guess it would end up as nested selects
23:46:45 <skew> another big question - does HaskellDB possibly work around the lameness of MySQL 4 with multiple queries?
23:46:51 <shapr> Long ago when I worked on a trust management app, it would have been useful.
23:46:56 * lispy restarts emacs to help reduce memory usage
23:47:01 <matthew-_> skew, works fine with postgres
23:47:19 <skew> that's an excellent point
23:47:33 <shapr> 65,000 lines of Visual Basic and gobs of multipage SQL queries. Multipage without \n or unnecessary whitespace...
23:47:38 <skew> I didn't recall any non-lame reasons for using ancient MySQL
23:47:49 <matthew-_> I tend to wonder why people use MySQL when they could use a database
23:48:07 <shapr> Because they hyperventilate with excitement when someone says 'faster'?
23:48:25 <skew> well, it's a step up from a bunch of hash tables
23:48:36 <matthew-_> mmmm. But most of the time, mysql is only if you do simple queries and use the myiasm database engine
23:48:50 <Pseudonym> It's a step up from Berkeley DB.
23:49:05 <skew> and when those constant factors hit you right in the rack space...
23:49:08 <shapr> When I worked at an ISP in Seattle in 1999 we used MySQL because it was about twice as fast as PostgreSQL and the boss was convinced that we'd never need transactions anyway.
23:49:12 <matthew-_> if you use the innodb engine so that you get these minor features called "transactions" and/or do complex joins, postgres is faster anyway
23:49:40 <shapr> I got to build MySQL and Python on IRIX 5.2 .... oh the joy...
23:49:59 <matthew-_> goodness! What machine is that?
23:50:07 <shapr> SGI
23:50:10 <lispy> grr....
23:50:12 <Adamant> Silicon Graphics
23:50:16 <shapr> We had Indy, Indigo, etc
23:50:18 <lispy> i'm getting dependencies between old versions of xhtml
23:50:19 <matthew-_> I have an Indy and Indigo2 here
23:50:29 <matthew-_> I put linux on them both...
23:50:29 <shapr> I think we had an Elan as well.
23:50:35 <matthew-_> ahh.
23:50:42 <lispy> ./Network/NewCGI.hs:1:0: unknown package: xhtml-2006.8.29
23:50:59 <matthew-_> yeah, that's another Dons module
23:51:02 <shapr> IRIX had some really cool stuff... it had excellent OpenGL support since SGI designed OpenGL themselves =)
23:51:02 <skew> matthew-_: parameterized queries in HaskellDB would probably compile down to some reasonable SQL anyway
23:51:04 <Pseudonym> I'm beginning to think that MySQL missed its calling as a local cache for a distributed database.
23:51:11 <shapr> Other than that it was a pain in the butt.
23:51:37 <skew> matthew-_: especially if you're just passing in some guarding and grouping operations
23:51:56 <shapr> lispy: xhtml is another bringert module
23:52:05 <skew> "HaskellDB: putting the algebra in relational algebra"
23:52:07 <matthew-_> shapr: sorry, yes
23:52:27 <shapr> I like "HaskellDB the database unwrapper" since I made up that quote =)
23:52:32 <skew> or so I hope...
23:52:35 <matthew-_> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml/
23:52:37 <lambdabot> Title: Index of /~bringert/darcs/haskell-xhtml, http://tinyurl.com/ebwqc
23:52:52 <skew> I'll have to hack in a "TINY" type to work with our schema.
23:53:25 <shapr> Should I sleep or should I try to hack HMarkup into HAppS wiki?
23:53:49 <skew> This might possibly be more amusing than doing a random Coq course's homework (http://www.cs.berkeley.edu/~adamc/itp/)
23:53:50 <lambdabot> Title: Interactive Computer Theorem Proving
23:53:52 <lispy>     conflict: module `Text.XHtml' is present in multiple packages: xhtml-2006.8.29, xhtml-2006.9.13
23:54:07 <shapr> Hide/remove the older package?
23:54:16 <shapr> I thought cabal did that automagically?
23:54:25 <lispy> $ ghc-pkg list | grep xhtml
23:54:25 <lispy>     (xhtml-2006.8.29), xhtml-2006.9.13
23:54:33 <shapr> skew: Isn't that Smerdyakov's website?
23:54:39 <shapr> Why yes it is...
23:54:40 * lispy is sort of mystified on this one
23:54:42 <skew> his course, anyway
23:54:48 <lispy> dons: so did you fix the lambdabot spaceleaks?
23:54:58 <dons> only a little
23:55:00 <lispy> dons: i see some strictify patches
23:55:06 <shapr> I'm still sad I didn't get to talk to him in Portland. I hope he's easier to talk to in person.
23:55:19 <ValarQ> dons: does lambdabot support ssl?
23:55:22 <skew> I don't think I've talked to him at all.
23:55:30 <shapr> Not on #haskell either?
23:55:32 <skew> It's easy enough to read his papers.
23:55:36 <lispy> i have no idea why i'm getting this erro
23:55:37 <dons> ValarQ: nope.
23:55:50 <lispy> dons: any thoughts why i'd get that conflict when one version is hidden?
23:56:32 <lispy> i tried to uninstall one and that just broke things
23:56:36 <lispy> maybe i have to use the old one
23:56:43 <lispy> because something else already uses it
