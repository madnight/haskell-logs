00:00:01 <lispy> isort of made up the line count from memory though
00:00:07 <flux__> are there x11-bindings for haskell?
00:00:09 <lispy> but i remember it was good
00:00:14 <dmead> negative
00:00:18 <dmead> =/
00:00:19 <flux__> if not, writing those can be quite a task already
00:00:27 <skew> Botty: I'm sure you can deliver data straight to the visual cortex without all that annoying noise from being compressed through the optic nerve...
00:00:32 <Botty> Pseudonym - heh, nah, just an arbitrary max realism
00:00:34 <Smokey`> http://www.indigorenderer.com/ <-- friend of mine's ray tracer... doing rather well for itself, all things considered :) (though it is C++)
00:00:35 <lambdabot> Title: Indigo renderer
00:00:44 <Pseudonym> What is this "realism" of which you speak?
00:00:47 <Pseudonym> Do you mean reality?
00:00:49 <Smokey`> has some stunningly 'photo-realistic' images.
00:00:52 <lispy> Smokey`: i think this is it http://www.shortest.de/view/dynamic+window+manager
00:00:53 <Botty> yeah
00:00:53 <flux__> hmph, pda says 'meeting in 30', off to work ->
00:00:56 <lambdabot> Title: suck less, http://tinyurl.com/kfwgc
00:01:01 <Pseudonym> Sorry, this gets me.
00:01:08 <Pseudonym> I used to work in visual effects.
00:01:14 <Pseudonym> "Photo-realism" is a meaningless term.
00:01:21 <Pseudonym> If you want realism, take a photo.
00:01:30 <dmead> yea
00:01:40 <dmead> thats like saying music from a speaker can sound like live music
00:01:44 <lispy> dwm is only a single binary, it's source code is intended to never exceed 2000 SLOC
00:01:45 <Smokey`> lispy: thanks, looks like a promising foundation
00:01:45 <dmead> it just wont
00:01:47 <Botty> heh
00:01:49 <lispy> i was way off on the lines of code
00:01:58 <Pseudonym> dmead: Precisely.  Alan Parsons would disagree with that assertion, for example.
00:02:12 <dmead> yea?
00:02:23 <Pseudonym> Live music can't sound like a really good studio mix, and stereos can't sound like really good live music.
00:02:24 <dmead> how could you
00:02:45 <dmead> live music and sound from a speaker are existentially different
00:02:54 <Pseudonym> The next person to use the term "photo-realism" should explain what a real talking ant looks like.
00:03:01 <dmead> lol
00:03:09 <Botty> Pseudonym: checkout Smokey's link.  get stuff like that going realtime, and I'd say that's good enough
00:03:14 <Botty> people won't demand more
00:03:18 <Pseudonym> But it's not good enough.
00:03:30 <Pseudonym> I've seen Pixie.  I've used it.  I work on a rival open source project.
00:03:36 <Pseudonym> And it's not good enough.
00:03:53 <skew> Pseudonym: the links from the gallery are cool
00:03:58 <Pseudonym> They are cool.
00:04:01 <Botty> nah, he linked to indigorenderer.
00:04:07 <Pseudonym> But they're not good enough for arbitrary values of "enough".
00:04:16 <skew> Pseudonym: I'm not so much interested in the pictures, as that a bunch of fluid dynamics people seem to have somehow decided to use Pixie as their visualizer
00:04:20 <Pseudonym> Indigo renderer isn't good enough too.
00:04:36 <Smokey`> lol
00:04:36 <dmead> indigo needs HDR
00:04:41 <Smokey`> dmead: indigo has HDR
00:04:45 <dmead> oh
00:04:47 <Botty> well, that fire stuff is intense.   get that going realtime and you'll make a killing on fps games
00:05:13 <dmead> yea the gallery looks pretty
00:05:16 <Pseudonym> One other thing that people who don't work in visual effects don't realise is how UN-realistic movies are.
00:05:19 <Smokey`> it's ap urely spectral renderer... you just need to supply the HDR content (textures, env maps, etc),
00:05:22 <Smokey`> a purely*
00:05:25 <dmead> ah
00:05:35 <dmead> did you see HDR in the source engine?
00:05:39 <lispy> Smokey`: if you do the scene graph idea, let me know, i want one pretty badly so i'd be willing to try it out and help (time permitting)
00:05:53 <Pseudonym> Real lighting people carry lights, scrims, gobos, black cloths, bounce cards and so on so they can make light behave unrealistically.
00:06:10 <Pseudonym> Because it looks better on film than real light.
00:06:52 <skew> Interesting, can you work that into a strange physics in a renderer?
00:07:13 <Smokey`> lispy: If I done anything in relation to computer graphics, i'll probably start becomming a bit of a natzi in relation to the libraries I use... (e.i., i'd make my own OpenGL bindings, EGL implementation, etc...) :P
00:07:14 <Pseudonym> Of course.
00:07:24 <Pseudonym> In a renderer, you can have a negative light, that takes away photons.
00:07:32 <Smokey`> I have a habbit of reinventing the wheel, even if only 'slightly' improved...
00:07:34 <skew> goopy light, oozing under doors, draping over furniture
00:08:03 <Pseudonym> I've done pictures where the shadow is cast from a different location than the light.
00:08:17 <lispy> Smokey`: part of why i want a scene graph for haskell is because i don't think direct calls to HOpenGL is a good idea for since a nice abstract language...so in some sense i agree...i don't like using HOpenGL
00:08:30 <lispy> Smokey`: otoh, i see no reason to rewrite it when i could just abstract it
00:08:39 <skew> Pseudonym: I mean replacing the basic inverse square law and stuff with something that generally looks better
00:08:42 <Pseudonym> It's precisely the non-physical hackability that makes high-end renderers attractive.
00:08:45 <Pseudonym> skew: Sure.
00:08:55 <Pseudonym> That's easier than getting it physically "right".
00:09:05 <skew> like, how much of "good lighting" you can capture, so people don't have to fiddle with it so much e.g for level editors and stuff
00:09:06 <Smokey`> lispy: I can't recall what it was that made me think this, but when I looked over HOpenGL, it looked a bit dodgy in relation to some strange functions, and alterations I saw.
00:09:08 <Pseudonym> BTW, there is a place for physical correctness.
00:09:27 <skew> Pseudonym: what renderer do you work on anyway?
00:09:28 <Pseudonym> If you're doing architectural simulations, you really want to know whether you need to put more lights in the building or not.
00:09:32 <Pseudonym> skew: Aqsis.
00:09:46 <lispy> Smokey`: yes, they renamed a lot of things and due to the way the types were created a lot of types have to be explicit
00:09:57 <skew> Pseudonym: not on the web?
00:10:03 <lispy> Smokey`: which is no fun
00:10:09 <skew> odd, not in Yahoo anyway
00:10:10 <Pseudonym> skew: http://www.aqsis.org/
00:10:59 <skew> weird, maybe just transient outage
00:11:03 <Smokey`> hmm, fair enough.
00:13:29 <Smokey`> I'm leaning towards the path tracer right now... I don't quite understand haskell enough to develop a fully fleged lib/module/whatever you call it in haskell :)  so I'm thinking the path tracer would force me to learn quite alot. :)
00:13:42 <Botty> when i messed around with .net opengl stuff I had to write my own wrapper - the tao wrapper was miserable
00:14:03 <Pseudonym> This was my first attempt: http://andrew.bromage.org/test3.png
00:14:05 <Smokey`> ugh. the only reason I have for using .NET is winforms :)
00:14:11 <lispy> Smokey`: cool, well whatever you choose, i'm sure it will be cool so make sure and hit me up when you have something to show off :)
00:14:19 <Pseudonym> The maths of the white spikes is actually quite interesting.
00:14:24 <Botty> heh, yeah I don't really use .net anymore
00:14:38 <Smokey`> and even then, i just get the win32 handle and pass it into my graphics engine lib (unmanaged)
00:14:50 <Smokey`> lispy: for sure :)
00:14:56 <Ringer> Hello all. I am beginner in Haskell. Help my please to connect Haskell module with C++
00:15:31 <skew> Ringer: FFI, and remember extern "C" on the C++ side
00:15:38 <lispy> Ringer: do you use C-like C++ or are you using classes and such?
00:15:58 <skew> connecting to reall classes would be "interesting"
00:16:25 <ThreeQ> ?where ffi
00:16:26 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:16:34 <lispy> Ringer: because, afaik, haskell doesn't hookup real well with classes.  But it does connect easily with standard C functions
00:16:49 <Ringer> i use classes, and use FFI
00:16:56 <lispy> hsc2hs is good to use BTW
00:17:40 <Ringer> meny linker errors acur, such as unresolved external simbol
00:17:51 <lispy> ?where paste
00:17:52 <lambdabot> http://paste.lisp.org/new/haskell
00:18:05 <lispy> Ringer: can you paste your errors and code at that url?
00:18:07 <Ringer> sorry for my bed inglish ^)
00:18:18 <lispy> Ringer: with full examples, people will help you better :)
00:18:22 * lispy has to sleep soon
00:21:35 <flux__> the water-video I told about earlier: http://www.youtube.com/watch?v=jj8Vzr8VN10
00:21:44 <flux__> (featuring some smoke)
00:21:46 <flux__> (and fire)
00:22:01 <flux__> doing that realtime would be _cool_
00:22:30 <Ringer> lispy: haskell dont work with C++ at all?
00:22:54 <lispy> Ringer: you can make it work
00:23:08 <Smokey`> flux__: wow, that's impressive :)
00:23:09 <lispy> Ringer: but, usually you have to create a C wrapper around your C++
00:23:42 <lispy> Ringer: so, think more like, you exchanged some data between C++/Haskell and then the other side does some work and returns some daat
00:24:28 <Ringer> lispy: i creat wrapper
00:24:30 <lispy> Ringer: maybe it would help if you start with a simple C program and make it talk to Haskell then work up to C++ after you get something working
00:25:03 <lispy> without seeing your code and the errors it's hard to say what you should do differently :)
00:25:30 <Carillon> anyone here a haskell expert?
00:25:40 <Smokey`> Carillon: One would hope so :)
00:26:58 <Pseudonym> Was that your question?
00:27:10 <lispy> expert?
00:27:40 <Carillon> i have a question on applicability.  i hit a brick wall with lisp in processing certain kinds of text, and was thinking that maybe haskell would let me see the problem more clearly.
00:27:45 * lispy is comfortable with a number of haskell concepts but would say he's just a beginner
00:29:02 <lispy> Carillon: lisp is pretty expressive, do you know why you hit a brick wall?
00:30:28 <Carillon> specifically, i'm trying to find patterns of tabular data within text.  i have it working, but i've been adding so many weird cases (mismatched tabulars, headers, headers with separators, parsing css) that the code has gotten really crazy...i feel like starting from scratch and before i go off half-cocked with haskell, i was thinking that someone might say either "don't go here", or "haskell is the coolest for managing that sort of t
00:30:28 * lispy shouldn't stay up any longer and goes to sleep
00:30:56 <Smokey`> 'night lispy :)
00:31:07 <lispy> Carillon: looks like irc cut you off half way
00:31:10 <lispy> Smokey`: night
00:31:16 <albertlee> what's your time zone ?
00:31:23 <lispy> ?localtime lispy
00:31:25 <lambdabot> Local time for lispy is Thu Oct 12 00:30:59 2006
00:31:30 <dmead> have you ever done ML carillon?
00:31:46 <Carillon> ahh, my message didn't go all the way through?
00:31:50 <albertlee> ?localtime albertlee
00:31:53 <lambdabot> Local time for albertlee is 10/12/06 23:31:29
00:32:00 <dmead> i see it
00:32:03 <lispy> the last we saw was: "haskell is the coolest for managing that sort of t
00:32:08 <albertlee> it's wrong for me....
00:32:24 <lispy> albertlee: it depends on what your irc client replies
00:32:31 <dmead> carillon?
00:32:47 <Carillon> dmead: no, i'm only familiar with lisp/scheme and c/c++.  i've also done alot of perl
00:32:55 <dmead> ahh
00:33:12 <dmead> i'd say that haskell would be better
00:33:14 <dmead> or ml
00:33:32 <dmead> but i'm not really familiar with any pattern matching techniques in lisp
00:34:03 <Korollary> If the text is so gnarly, I suppose you could use a real grammar.
00:34:04 <lispy> Carillon: look at parsec
00:34:16 * lispy goes to bed for real
00:34:25 <dmead> goodnight =p
00:35:00 <Carillon> dmead: that's the idea that i get.  but i think i should understand why before making another committment...afterall, i actually need to get this thing "done" to a certain extent.
00:35:11 <dmead> right
00:35:19 <Carillon> parsec?...hmm, never heard of it.
00:35:21 <dmead> i'd do what lisp said
00:35:27 <dmead> its a language parser in haskell
00:35:28 <Smokey`> it's a haskell library.
00:35:35 <ThreeQ> ?where parsec
00:35:36 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
00:35:55 <ThreeQ> it's really neat
00:36:02 <dmead> but then again you know perl
00:36:10 <dmead> and that'd probably be way faster
00:36:18 <dmead> then learning haskell and then parsec
00:36:45 <ThreeQ> you can build a parser using haskell combinators that ends up looking a lot like a BNF
00:36:52 <Korollary> Perl has parser libs too. Every language out there has one.
00:37:15 <ThreeQ> but yeah, if you're munging text, why not perl?
00:37:16 <Carillon> yeah, well perl was what i prototyped this thing in in the first place.  but then it got quickly unweildy.  i wrote 12k lines of perl code, and could hardly understand what i wrote afterwards.
00:37:29 <dmead> heavy
00:37:35 <Korollary> That's where haskell could do better.
00:38:02 <Smokey`> Carillon: Might be a good idea to lay out how you're going to structure your program, before you write it... taking into consideration the goals/limitations your program will have :)
00:38:05 <Korollary> Declarative and typed.
00:38:33 <Carillon> so then i started using lisp with regexps to map the data to lists which helped for awhile, but then i kept getting instances where my table-list (a list of expected tabular data) was either running over or under (wide margins)
00:39:30 <dmead> what sort of stuff are you parsing?
00:39:32 <lisppaste2> aleator pasted "How to make this more clear/compact?" at http://paste.lisp.org/display/27813
00:40:19 <aleator> I got into contest wether I can make executable code more clear than someones pseudocode.. Silly me.
00:41:30 <dmead> any of you guys in ACM?
00:41:30 <Carillon> smokey: you might be right.  i never developed a good architecture going in, but, even after working on it for so long, i keep breaking my model.
00:42:17 <ThreeQ> hmm, so you're parsing html?
00:42:18 <Carillon> dmead: parsing of corporate documents (emails) passing between accountants
00:42:24 <skew> aleator: sls?
00:42:29 <dmead> ah
00:42:31 <ThreeQ> ah
00:42:50 <dmead> what do you need to do with them?
00:43:00 <skew> perhaps the Utrecht error-repairing combinators would be useful?
00:43:07 <skew> or maybe some kind of probablistic  parser
00:43:44 <Carillon> dmead: parse, store (data warehouse), compare and report..
00:43:55 <aleator> skew: stochastic local searcher of some such. Take a function and vector, permute the vector and see if you can get the function return less than for original value..
00:44:14 <dmead> ah
00:44:24 <dmead> and these are messages in english?
00:44:31 <dmead> not forms or whatnot?
00:45:45 <roconnor> @seen ndm
00:45:46 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 16h 5m 56s ago, and .
00:46:01 <roconnor> @localtime ndm
00:46:06 <dons> ~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~/win 2
00:46:09 <dmead> as i understand it, parsing a natural language has not yet been proven possible
00:46:12 <Carillon> dmead: no, multi-language, and numerous formats (there's a "format", but it's definitely not form-like...more like a more-or-less accepted standard for communication of details)
00:46:26 <dmead> ah
00:47:09 <dmead> i'd say that requiring the users to communicate via a form with specific fields would be far easier than trying to do any kind of natural langauge processing
00:47:21 <Carillon> dmead: hehe.
00:47:33 <dmead> unless you're getting paid a whole lot
00:47:38 <dmead> then by all means =)
00:48:02 <Carillon> dmead: trying to get [think of a large number] of people to do anything is hard. ;)
00:48:20 <skew> aleator: ranges doesn't seem like a very good name
00:48:35 <skew> is there some greek letter you are already using?
00:49:00 <dmead> =]
00:51:19 <Carillon> anyway, thanks for the tips.  still trying to figure out whether i have a language problem or a lack-of-brainpower problem...
00:51:51 <Cale> Carillon: definitely have a look at Parsec anyway
00:52:11 <dmead> yea, and get your  using to follow a strict standard
00:52:15 <dmead> *users
00:52:18 <Cale> It'll at least beat using regular expressions
00:52:56 <Cale> http://www.cs.princeton.edu/~appel/papers/modalmodel.pdf -- I love the title of this paper
00:52:58 <lambdabot> http://tinyurl.com/kazc3
00:53:03 <dons> hehe
00:53:11 <dons> i think they scored with that title.
00:53:29 <skew> it looks like a pretty nice paper too
00:53:30 <dons> who cares what's in the paper, with a title like that!
00:53:59 <dons> oh nice, the ghc 6.6 announce has bubbled up to the top of reddit. looks like ghc has some fans out there. yay!
00:54:12 <skew> with those ideas, it looks like it might just be possible to reason about machine code stuff
00:54:13 * vegai upmods.
00:54:14 <Syzygy-> ghc has reached 6.6?
00:54:26 <dons> yep
00:54:43 <vegai> ah, it's in programming.
00:54:58 <Syzygy-> Whoa. SMP concurrency? I WANT!
00:55:08 <vegai> I wonder what's the sense in reddit not putting submissions to the root automatically
00:55:21 <dons> oh, random readers mod down programming stuff
00:55:23 <vegai> what belongs there, then?
00:55:25 <Carillon> cale: thanks.  for the link to that paper...this looks like a good read.
00:55:26 <dons> just cause its hard
00:55:31 <dons> vegai: oh, general news of the world?
00:55:33 <Syzygy-> I suppose it isn't in gentoo quite yet?
00:55:36 <vegai> my HAppS submission did pretty well..
00:55:53 <dons> yeah, things have done well, but you can also get a lot of mod downs
00:56:03 <dons> so i'm not sure what the best approach is.
00:56:25 <dons> mmm. larry wall sez: "I upgraded to GHC 6.6 and my program ran 60 times faster"
00:56:39 <dons> (program running in pugs on ghc's rts)
00:56:59 <vegai> there's the problem that perhaps half of the new features-list is things that no-one outside haskell circles has heard of or understands what they mean..
00:57:11 <pejo> Cale, very modest title, indeed.
00:57:12 <dmead> yea
00:57:12 <dons> ah well. "concurrency" means something right ;)
00:57:18 <dons> (hence is put it at the top of the list :)
00:57:21 <dmead> 6.6 isn't in in portage yet
00:57:30 <dmead> yea
00:57:32 <Syzygy-> Check.
00:57:38 <dmead> does that mean haskell language threads?
00:57:49 <dmead> or it'll run on an smp system
00:58:22 <dons> it means haskell language threads will run on multiple os threads, on multiple processors
00:58:29 <dmead> cool
00:58:36 <dons> take that ruby!
00:58:48 <Cale> Nice, impredicative polymorphism :)
00:58:50 <dons> bam! biff! zoink! batman noises!
00:58:58 <dmead> ruby is a fad
00:59:42 <Syzygy-> @tell dcoutts Is there an ETA on ghc 6.6 in gentoo portage - and can I do anything to help?
00:59:42 <lambdabot> Consider it noted.
00:59:46 <tonySoprano> hello! i'm wondering if there is a good tutorial for gtk2hs... does anyone know a tutorial i could use?
01:00:01 <dons> ?where gtk2hs
01:00:02 <lambdabot> http://haskell.org/gtk2hs/
01:00:09 <dons> there's some demos/tuts there, I think
01:00:23 <dons> tonySoprano: check with dcoutts in a few hour, he'l know the full story
01:01:00 <dmead> dont need no credit card to ride this train!
01:01:03 <dons> vegai: the haskell web apps article is also quite interesting. did you see it?
01:01:10 <Ringer> lispy: I send private messages for you, do you read it?
01:01:28 <vegai> dons: No..
01:01:31 <dmead> lispy uses a terminal i think
01:01:41 <tonySoprano> who or what is dcoutts?
01:01:46 <vegai> but now I do. http://mult.ifario.us/
01:01:47 <dons> this guy, http://mult.ifario.us/
01:01:48 <lambdabot> Title: mult.ifario.us
01:01:48 <lambdabot> Title: mult.ifario.us
01:01:53 <vegai> oops.
01:02:01 <dons> tonySoprano: he is the gtk2hs maintainer, who hangs out here
01:02:03 <pejo> Ringer, he went to bed, I think.
01:02:15 <dons> tonySoprano: he's also written several of the gtk2hs tuts
01:02:21 <tonySoprano> ah, okay
01:02:56 <lisppaste2> skew annotated #27813 with "tweaks" at http://paste.lisp.org/display/27813#1
01:03:06 <tonySoprano> i found one about writing a memory game, but i don't think it is very useful
01:03:12 <vegai> dons: I'm thinking of a journal implementation in HAppS
01:03:28 <dons> vegai: sounds like a good idea
01:03:36 <dons> like wordpress but better?
01:03:49 <Ringer> pejo: :)
01:04:21 <vegai> that would be a lofty goal, yes. Except that I cannot compete with wordpress in HAppS
01:04:39 <dons> heh ok
01:04:45 <dons> i can but hope
01:04:54 <dons> (oh, and you've seen hope?)
01:04:56 <dons> ?where hope
01:04:57 <lambdabot> http://hope.bringert.net/
01:04:59 <vegai> ...but only because PHP is much better supported with ISPs :)
01:05:06 <dons> boo on isps
01:05:08 <vegai> yeah, I've seen it
01:06:16 <dons> ?localtime lispy
01:06:17 <lambdabot> Local time for lispy is Thu Oct 12 01:05:52 2006
01:06:38 <dmead> ?localtime dmead
01:06:40 <lambdabot> Local time for dmead is Wed Oct 11 19:45:24
01:06:50 <dmead> hmm
01:06:54 <dmead> my stuff is way messed up
01:07:05 <dons> i think you might be living in the past?
01:07:13 <dons> or else in samoa.
01:07:22 <dons> hawaii maybe?
01:08:50 <roconnor> @google what time is it in hawaii
01:08:53 <lambdabot> http://www.timeanddate.com/worldclock/city.html?n=103
01:08:53 <lambdabot> Title: Current local time in Honolulu - Hawaii - U.S.A.
01:09:02 <roconnor> bah
01:09:10 <roconnor> google says to me: Hawaii, US â€” Current local time: 10:08 PM on Wednesday, October 11
01:09:28 <roconnor> 19:45:24 is quite a bit off
01:09:39 <Syzygy-> roconnor: o.O That would mean that Hawaii is precisely 12 hours away from Central European...
01:09:44 <roconnor> I claim that isn't the local time anywhere on earth
01:10:01 <dons> what time is it in apia?
01:10:10 <dons> ?google what time is it in apia
01:10:22 <dons> very important to know for paper submission purposes
01:10:25 <lambdabot> search module failed: IRCRaised thread killed
01:10:39 <roconnor> and when you have eliminated the impossible, whatever remains, however improbable, must be the truth.
01:10:51 <roconnor> dmead: must therefore live in space.
01:11:03 <dmead> lol
01:11:07 <roconnor> his high relative velocity has been slowing down his clock.
01:11:09 <dons> oh, apia, samoa, Wednesday, October 11, 2006 at 9:10:34 PM
01:11:19 <dmead> exactly
01:11:27 <dons> so looks like dmead is roughly in new zealand, yesterday?
01:11:32 <dmead> lol no
01:11:36 <dmead> east coast
01:11:48 <dmead> my clock settings are messed up from my last update
01:11:50 <dons> ?localtime foxy__
01:11:53 <dons> ?localtime foxy
01:11:56 <dons> will set us right.
01:11:58 <lambdabot> Local time for foxy is Thursday, 12 October 2006 9:11:37 p.m.
01:12:18 <vincenz> hiya dons
01:12:19 <dons> ah, so no, not in nZ at all. but not in .au either. new caledonia, yesterday, perhaps?
01:12:25 <dons> hey vincenz
01:12:40 <dmead> =p
01:18:57 <dblhelix> anyone any clue on why Reader r a isn't implemented as ReaderT r Identity a? and Writer not in terms of WriterT? etc... efficiency?
01:23:08 <JohnMeacham> grumble. the new Monoid instance for (a -> b) is really messing things up....
01:24:33 <dblhelix> JohnMeacham:  why? (just id and (.), right?)
01:26:01 <JohnMeacham> yes. but now I have several hundred mconcat and mappends I have to check by hand because they all just silently change behavior without notice.
01:26:53 <JohnMeacham> and it is not so easy to check by hand either, being in the center of a complex expression it is not always clear what instance it is using... I wonder if there is a way I can get the compiler to complain if it ever uses that instance...
01:26:55 <dblhelix> JohnMeacham: I've to admit I'm not sure how things were before... what exactly has changed?
01:28:06 <JohnMeacham> it used to be id and (.) now it is (const mempty) and (\f g x -> f x `mappend` g x)
01:28:39 <JohnMeacham> so behavior silently changes... which is very bad.
01:29:23 <dblhelix> JohnMeacham: what motivated the change?
01:29:41 <JohnMeacham> not sure. it surprised me.
01:29:58 <arjanb> it seems related to addition of Control.Applicative
01:30:21 <skew> JohnMeacham: how about throwing in a different a->b instance with a sufficiently scary flag
01:30:51 <skew> I think providing a duplicate instance under -fallow-overlapping instances would complain in ambigous cases
01:31:12 <JohnMeacham> it will complain when I declare the instance I think.
01:31:26 <JohnMeacham> hmm.. perhaps I will try the overlapping instance thing..
01:31:27 <skew> then move up to -fallow-incoherent-instances
01:32:17 <dmead> im gonna go nuts
01:32:26 <dmead> :s
01:32:31 <skew> "It is fine for there to be a potential of overlap; an error is only reported if a particular constraint matches more than one"
01:32:49 <dmead> two list operations are really tedious to make expressive
01:33:27 <skew> so perhaps you don't even need any flag
01:36:43 <JohnMeacham> hmm.. looks like incoherent instances might work.
01:40:16 <roconnor> is there a clear explaination about what is broken about fundeps?
01:44:00 <JohnMeacham> thanks for the suggestion, that saved me a heck of a lot of headache.
01:49:47 <therp> dons: yesterday you suggested that loading ghc into ghci might help to interactively hack on ghc. you didn't mean loading the shared library, but something like Prelude> :load compiler/main/Main.hs, right?
01:51:26 <dons> yep
01:52:43 <therp> the only thing I found in connection with that is http://www.cse.unsw.edu.au/~sseefried/seafood/archives/000033.html
01:52:44 <lambdabot> Title: seafood: Loading GHC into GHCi, http://tinyurl.com/fousu
01:53:37 <therp> doing the :load described above results in a lexical error, as Main.hs includes cpp directives. there ain't a flag to tell ghci to preprocess the source loaded, right?
01:53:53 <therp> oh I'm sorry, just :set -cpp
02:28:38 <JohnMeacham> @seen dons
02:28:39 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 11m 20s ago.
02:30:50 <dons> yeah?
02:37:00 <roconnor> what #ifdef do I use to switch on GHC 6.6 or later?
02:39:06 <dons> #ifdef _GLASGOW_HASKELL_ >= 606 ?
02:39:12 <dons> or is it 660
02:39:42 <dons> 606.
02:40:52 <roconnor> dons:  presumably that is #if _GLASGOW...
02:41:23 * mux nods
02:41:32 <dons> yeah, #if __GLASGOW_HASKELL__ >= 605 for example
02:41:44 <dons> i need some sleep :)
02:42:01 <mux> liftM dons sleep
02:42:03 <roconnor> #if __GLASGOW_HASKELL__ >= 606
02:42:03 <roconnor> import GHC.Exts
02:42:03 <roconnor> #elseif
02:42:03 <roconnor> inline = id
02:42:03 <roconnor> #endif
02:42:12 <mux> it's #elif
02:42:16 <roconnor> oh
02:45:09 <jmmv> hi
02:49:41 <roconnor> hi
02:49:52 <mux> whoa, a new female committer
02:49:53 <mux> cool
02:50:01 <mux> oops, wrong chan
02:50:02 <musasabi> morning
02:51:41 <musasabi> vegai: good luck with the journal thing :-)
02:54:14 <roconnor> do I need a flag to use the preprocessor in GHC?
02:54:17 <vegai> musasabi: Thanks :) Has anyone else told you about similar plans?
02:55:42 <musasabi> vegai: shapr has the wiki, but I am not aware of any journal thing.
02:55:52 <roconnor> ?fptools Data.Bits
02:55:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
02:59:19 <bringert_> dcoutts: do you have kolmodins mobile phone number?
03:02:11 <mwc> So, what news of GHC 6.6... dcoutts was teasing me that it was out today
03:03:05 <mux> oh, it's out?
03:03:27 <mwc> Doesn't seem to be
03:03:48 <mwc> oh yep, there it is
03:03:52 <mwc> www.haskell.org/ghc
03:04:04 <mwc> wonder why there's nothing in the topic?
03:04:09 * mwc prods shapr 
03:07:52 <roconnor> I get a lexer error at #if
03:07:54 <roconnor> :(
03:09:09 <mux> your file is not being processed by cpp maybe?
03:31:56 <jmuk> are there any (easy) way to output non-ASCII characters in GHC-6.6?
03:34:16 <dons> well, you can write bytes, so you can write anything :)
03:34:21 <dons> > '\6666'
03:34:23 <lambdabot>  '\6666'
03:34:28 <jmuk> ah,
03:34:35 <jmuk> putStr '\6666'
03:34:55 <jmuk> outputs other character.
03:35:12 <dons> now, from what I remember, the standard io code just prints the lower 8 bits
03:35:35 <jmuk> I agree
03:35:40 <dons> so to print more, you'd need to write a putUnicode :: Char -> IO (), that prints the 4 underlying bytes, or what have you
03:35:55 <dons> check on haskell-cafe@, there are some experts on this kind of thing around
03:36:19 <jmuk> thank you
03:36:53 * Lemmih usually steals the code from jhc.
03:36:54 <jmuk> In fact, I wrote functions such like charToUTF8Chars :: Char -> [Char]
03:37:19 <dons> yeah, the jhc unicode.hs would be a good start
03:37:38 <jmuk> But I wants such functions in standard libraries...
03:37:49 <jmuk> dons: thank you
03:39:24 <dcoutts> bringert, I do, or you could just ask kolmodin :-)
03:45:30 <dcoutts> shapr, interesting ByteString patch for HaXml. Thanks for sending it.
03:45:50 <dcoutts> from the email:
03:45:52 <dcoutts> These versions use lazy bytestrings instead of pretty printer docs.
03:45:52 <dcoutts>         For the project I'm on that was at least an order of magnitude
03:45:53 <dcoutts>         reduction in peak memory required.  The RTS would kill my program when
03:45:55 <dcoutts>         it used 1GB of memory, now it takes about 100megs.
03:46:06 <dcoutts> which is another nice result
03:49:15 <Ringer> where to find simple samples of making C libraries in haskell?
03:49:52 <norpan> Ringer: what do you mean? interfacing with C libraries?
03:50:39 <Syzygy-> dcoutts: You seem to be the maintainer for ghc in gentoo, right?
03:50:41 <dons> dcoutts: mm. nice. was that from lispy though? or shapr?
03:50:55 <Ringer> I want to use haskell module from C++
03:51:23 <dcoutts> dons, from lispy, shapr forwarded the patch to me
03:51:37 <dcoutts> Syzygy-, one of 5, yes.
03:51:58 <norpan> Ringer: ah, then i have no good examples
03:52:07 <dons> Ringer: there's some small examples here, using C only, http://www.haskell.org/haskellwiki/Wc. for the full story you should read the ffi report (and there's a demo or two on haskell.org, as well as the 'Awkward Squad' paper)
03:52:09 <lambdabot> Title: Wc - HaskellWiki
03:52:20 <Syzygy-> dcoutts: Will ghc 6.6 come to portage soonish? Can I do anything to help put it there?
03:52:23 <dons> C++ is harder, you have to call into it via a C wrapper, I think
03:52:53 <dcoutts> Syzygy-, there's lots you can do to help! join #gentoo-haskell and we can talk about it
03:53:05 <norpan> dons: he just said he want to use haskell modules from c++
03:53:07 <dcoutts> Syzygy-, at this stage it's amost all about testing
03:54:03 <dons> norpan: oh sorry, i read it the other way around
03:54:21 <Ringer> norpan: cool! would you send me the samples?
03:54:22 <dons> Ringer: that's harder then . look at the 'FFI Addendum' (can be done)
03:54:36 <norpan> Ringer: i just said i don't have any :)
03:54:49 <dons> basically you use 'foreign export' in your haskell module to export the functions to C
03:54:55 <dons> then call them in C from C++
03:54:58 <Ringer> oh, I see :)
03:55:04 <dons> e.g.
03:55:05 <dons>   hs_init(&argc, &argv);
03:55:08 <dons>  my haskell fun()
03:55:12 <dons>   hs_exit();
03:55:13 <dons>   return 0;
03:55:33 <dons> would be C to call "my haskell fun", a foreign export from a haskell module
03:57:37 <roconnor> mux: how do I get my file processed by cpp in a vaguely portable way?
03:58:16 <Ringer> my haskell module:
03:58:17 <Ringer> module AISystem where
03:58:17 <Ringer> import Foreign
03:58:17 <Ringer> foreign export stdcall "fac" fac :: Int -> Int
03:58:17 <Ringer> --main = putStrLn "hello world"
03:58:17 <Ringer> fac :: Int -> Int
03:58:18 <Ringer> fac 0 = 1
03:58:20 <Ringer> fac n = n * fac( n - 1 )
03:59:12 <dons> you'll want fac to be CInt -> CInt , I think.
03:59:18 <dons> in order to be portable , anyway
03:59:34 <dons> that looks fine though. now check the details on calling haskell from C in the FFI report
03:59:48 <dons> (when you compile this, it'll create a .h file to be used on the C side)
04:02:39 <roconnor> @where cabal
04:02:40 <lambdabot> http://www.haskell.org/cabal
04:03:35 <roconnor> oh can I use .cpphs
04:03:37 <Ringer> dons: src/AISystemGHC.hs:5:36: Not in scope: type constructor or class `CInt'
04:05:43 <Ringer> this is the console output:
04:05:45 <Ringer> ghc -static -fffi -c src/AISystemGHC.hs -fglasgow-exts
04:05:45 <Ringer> ghc -static -fffi -c src/AISystemGHC_stub.c -fglasgow-exts
04:05:45 <Ringer> ghc -static -fffi -c src/libAISystem.cpp src/AISystemGHC_stub.o -fglasgow-exts
04:05:45 <Ringer> ghc -static -fffi src/libAISystem.o src/AISystemGHC.o -I./include -lHSbase -fglasgow-exts
04:05:45 <Ringer> c:/ghc/ghc-6.4.1/libHSrts.a(Main.o)(.text+0x1d):Main.c: undefined reference to `__stginit_ZCMain'
04:05:45 <Ringer> c:/ghc/ghc-6.4.1/libHSrts.a(Main.o)(.text+0x43):Main.c: undefined reference to `ZCMain_main_closure'
04:07:40 <dons> ?index CInt
04:07:40 <lambdabot> Foreign.C.Types, Foreign.C
04:08:01 <dons> the undefined refs are because you're trying to create an executable without a 'main' function
04:08:13 <dons> you need instead to create a library archive, no/
04:08:14 <dons> ?
04:08:39 <dons> (I recommend using Cabal if possible to build your haskell library)
04:09:42 <Ringer> dons: yes you right, I try to make library
04:10:21 <Ringer> dons: what is Cabal?
04:10:33 <roconnor> hmm, ghc doesn't seem to recognise the .cpphs extenstion
04:11:53 <dons> ?where cabal
04:11:54 <lambdabot> http://www.haskell.org/cabal
04:12:05 <dons> its a tool for building haskell libraries in a portable way
04:12:41 <dons> roconnor: just adding extensions:          CPP   should be enough?
04:12:49 <dons> no need for .cpphs files?
04:13:11 <roconnor> dons: But I want to cabalize this project
04:13:27 <dons> that's what cabal expects. .hs files + extension: CPP in the .cabal file
04:13:29 <roconnor> or maybe I don't understand waht you mean
04:13:38 <roconnor> ok
04:13:59 <dons> so you only need to tweak the .cabal file
04:14:47 <SamB> ... and rename the .cpphs files ...
04:15:56 <roconnor> okay, I have a list of exposed modules
04:16:09 <roconnor> Data.Diget.SHA2 appears in this list
04:16:19 <roconnor> how do I get CPP to be applied to just this file?
04:16:22 <dons> you building a library or an executable?
04:16:36 <mux> roconnor: sorry, I have no idea what's the canonical way to cpp files with haskell
04:16:38 <dons> oh, if you want _just_ that file, add: {-# OPTIONS -cpp #-} to the top of that file
04:16:42 <Ringer> dons: how to compile library without cobal, with only ghc command prompt?
04:16:46 <mux> you could have your own Makefile and od it by hand though
04:17:02 <roconnor> dons: okay, and hugs will understand that?
04:17:18 <dons> I think so. if in doubt, use extensions: CPP, and let hugs decide
04:18:09 <roconnor> I have {-# OPTIONS_GHC -funbox-strict-fields #-} at the top of my file
04:18:16 <roconnor> how do I add OPTIONS -cpp ?
04:18:23 <roconnor> on another line
04:18:26 <dons> yeah, next line.
04:18:26 <roconnor> in the same comment?
04:18:30 <roconnor> ok
04:18:36 <dons> well, if its only in OPTIONS_GHC, hugs won't see it
04:19:03 <roconnor> does hugs have a -funbox-strict-fields?
04:19:14 <dons> doubt it.
04:19:21 <roconnor> okay, two lines then
04:19:49 <dons> for those who didn't see it earlier, http://programming.reddit.com/ (top link)
04:21:13 <Igloo> It's better to have all the extensions listed in the .cabal file if possible, although for CPP it's not as important as some
04:21:22 <mux> dons: cool!
04:21:28 <Igloo> It would still be nice for stats gathering, though
04:21:33 <mux> I'll see about getting the FreeBSD port for GHC updated ASAP
04:22:57 <Ringer> ?index IO
04:22:57 <lambdabot> System.IO, Prelude
04:26:53 <Ringer> dons: how to compile library without cobal, with only ghc command prompt?
04:29:01 <vegai> and I'll try to see the ghc package in Arch Linux updated asap...
04:29:55 <vegai> perhaps I could wrestle it from the alive, warm hands of the current developer :P
04:29:56 <dons> Ringer: check the Cabal web page, or find some Haskell package to use as an example
04:45:17 <musasabi> Chars may apparently be invalid unicode characters :-(
04:45:24 <roconnor> ?fptool Data.Word
04:45:25 <lambdabot> http://darcs.haskell.org/packages/base/Data/Word.hs
04:46:08 <norpan> musasabi: they may? which ones?
04:46:46 <musasabi> D800-DFFF (no characters there)
04:47:02 <mauke> > chr 0xffef
04:47:04 <lambdabot>  '\65519'
04:47:36 * musasabi wonders whether those are a bug or something that should be supported.
04:47:44 <roconnor> I suppose GHC 6.6's GHC.Exts.inline doesn't really work for type class functions.
04:48:14 <Igloo> Should haddock be able to cope with files beginning with a #?
04:48:15 <int-e> checking for these invalid ranges seems to be expensive ... does Data.Char have functions for that?
04:48:19 <Igloo> s/files/lines/
04:48:47 <Igloo> Oh, that's not the problem after all. *sigh*
04:50:45 <int-e> > generalCategory $ chr 0xDFFF
04:50:47 <lambdabot>  Surrogate
04:51:05 <int-e> > generalCategory $ chr 0xFFEF
04:51:06 <lambdabot>  NotAssigned
04:57:47 <mux> this Hans Reiser story is amazing :)
04:58:04 <mux> you guys heard about it I suppose?
05:00:39 <vegai> amazing?
05:00:42 <cjay> amazing? it is a sad thing and i hope he did not do it
05:01:13 <mux> amazing probably wasn't the correct term -- incredible is more what I meant
05:01:24 <vegai> sensational?
05:01:45 <mux> maybe; it's hard to tell when you're not a native speaker
05:02:00 <vegai> I'm not :)
05:02:07 <vegai> Anyway...
05:02:58 <profmakx> amazing is almost certainly not the correct term -.-
05:07:40 <therp> mux: I don't think that this should be discussed among geeks. I also find it a bit inappropriate that this appeared on /.. Too personal imho.
05:09:58 * roconnor gives up trying to get GHC.Exts.inline to inline rotate.
05:10:33 <lisppaste2> therp pasted "loading ghc components into ghci" at http://paste.lisp.org/display/27827
05:11:09 <therp> can someone give me a hints whats wrong here? I suspect that there is some include file missing, but actually I don't see any error messages for that
05:11:31 <beelsebob> http://foldl.com/
05:11:32 <lambdabot> Title: foldl.com
05:12:14 <pejo> roconner, hacking away on the inliner?
05:12:31 <SamB> GHC.Exts.inline ?
05:12:53 <roconnor> pejo: I couldn't immediately see how to change GHC's inliner to inline rotate.
05:13:21 <roconnor> So I was trying this new inline function to see if I could get it to inline in Data.Digest.SHA2.
05:13:29 <roconnor> but I can't even get that to work.
05:13:57 <roconnor> and I refuse to make Data.Digest.SHA2 start doing things like uncheckedShiftL#
05:14:06 <SamB> roconnor: never fear!
05:14:11 <roconnor> that wouldn't be portable at all.
05:14:13 <SamB> someone will figure it iout
05:14:17 <SamB> er, *out
05:14:26 <roconnor> who? ndm?
05:14:51 <SamB> what?
05:14:56 <SamB> why do you mention ndm?
05:15:17 <roconnor> ndm said he was working on some constant chasing analysis in yhc.
05:15:36 <SamB> oh
05:15:37 <roconnor> I don't quite understand what he is upto.
05:15:43 <SamB> well that won't help us will it?
05:15:58 <roconnor> no, I guess not
05:16:14 <roconnor> unless yhc starts producing faster code that ghc.
05:16:26 <roconnor> ... granted I've never used yhc.
05:17:42 <earthy> hm...
05:18:24 <roconnor> anyhow,
05:18:27 * roconnor cries
05:18:34 <vegai> they seem to have somewhat different goals than ghc
05:19:05 <beelsebob> roconnor: yhc does produce faster code than ghc
05:19:15 <beelsebob> or at least that's what neil's latest experiment did
05:19:17 <Igloo> GHC.Exts.inline should inline a class method if it knows which instance is going to be chosen
05:19:52 <yip> > map fib [1..] where fib 1 = 1; fib n = n + fib (n-1)
05:19:52 <lambdabot>  Parse error
05:20:46 <roconnor> Igloo: I totally failed to get inline to do anything.
05:20:58 <int-e> > let x = map fib [1..] where fib 1 = 1; fib n = n + fib (n-1) in x -- but that's not what you want, is it?
05:20:59 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
05:21:15 <Igloo> roconnor: Is the inlining visible to the compiler (i.e. in the same module or in a .hi file)?
05:21:37 <roconnor> more or less
05:21:48 <roconnor> let me say that what I want to inline is visible in the .hi file.
05:22:02 <Igloo> err?
05:22:33 <rahikkala> Is there a good explanation of how to work with n-dimensional arrays anywhere? AFAICT I could figure it out if I could use a list as an array index, but I can't, and I don't know how to return n-tuples (or whether that's possible at all)
05:22:43 <lisppaste2> roconnor pasted "inlining in ShaData" at http://paste.lisp.org/display/27829
05:23:07 <roconnor> so, the naive thing to do is ``inline rotate''
05:23:20 <emk> OK, a silly Haskell style question. Let's say I have an AST, and a type inference engine. Once I've figured out the types, I'd like to attach them somehow to the AST. Do I need attach type vars to my AST up front, do the type analysis, and then build a new AST by replacing the type vars with their inferred values?
05:23:20 <roconnor> but what does rotate refer to?
05:24:01 <emk> (I know this question makes little enough sense, and YHC's approach to this problem is fairly cryptic.)
05:25:07 <roconnor> rotate is a function takes the dictionary caleld $f15 and projects out the rotate function.
05:25:24 * emk goes off to look at JHC's approach
05:25:25 <mauke> @instances Ix
05:25:26 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
05:25:28 <roconnor> so, I suspect inline rotate just inlines the projection fuction
05:25:40 <roconnor> which was going to be inlined anyways
05:25:45 <dons> roconnor: you need -O ?
05:26:19 <roconnor> what I really want is called rotate3 in GHC/Word.hi to be inlined.
05:26:25 <roconnor> dons: I'm doing -o3
05:26:27 <roconnor> er
05:26:29 <roconnor> -O3
05:26:31 <dons> ok
05:27:05 <roconnor> beelsebob: think I should use Yhc instead of ghc?
05:27:16 <musasabi> How is the emacs compiling support for GHC (can it automatically direct to the places in source with errors?)
05:27:20 <mauke> rahikkala: the dimensionality is part of the array's type
05:28:12 <rahikkala> mauke: :/
05:28:23 <mauke> what are you trying to do?
05:29:34 <beelsebob> roconnor: dunno - what are you trying to do?
05:29:43 <beelsebob> neil's C backend for yhc might just end up being faster
05:29:50 <rahikkala> mauke: I'm trying to solve a problem that's somewhat similar to n-dimensional attacking queens
05:30:56 <cge> How does fix work in practice? I can't figure out how fix ([1]++) == repeat 1, but fix (1*) loops forever.
05:31:02 <beelsebob> roconnor: I guess the biggest question is does yhc support all the libraries/extensions you need
05:31:07 <roconnor> beelsebob: I'm have a virtual machine, and a crypto hash function.
05:31:24 <mauke> fix f = let x = fix f in x
05:31:30 <beelsebob> roconnor: give it a try, ping ndm and see if you can get the C backend code and build it using that
05:31:30 <roconnor> I use extensions such as Word32, Word64 ...
05:31:31 <mauke> er, no
05:31:35 <mauke> fix f = let x = f x in x
05:31:54 <beelsebob> roconnor: dunno if it supports that, but those would probably be pretty easy to add - so ping neil
05:32:22 <cge> mauke: I know. But how does that work within Haskell? What happens so that it actually gives an answer in some places?
05:32:26 <roconnor> fix f = f (fix f) ?
05:32:55 <mauke> > let x = 1 : x in x
05:32:57 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:32:58 <rahikkala> mauke: In this case, all I actually really need is a way to mark tiles on a chess-hyperboard occupied or unoccupied, and check whether they're occupied... my plan was to use STUArray
05:33:19 <mauke> cge: that works because the first element of 1 : x is always 1 and doesn't depend on x
05:34:06 <mauke> the next element has to look at x but at that point we already got a 1, so we return it and loop back into x
05:34:07 <norpan> fix (1:)
05:34:10 <mauke> or something
05:34:20 <cge> mauke: I see
05:34:23 <cge> mauke: thanks
05:34:58 <int-e> > let 0 |* x = 0; x |* 0 = 0; x |* y = x * y in fix (0*)
05:34:59 <lambdabot>  Exception: <<loop>>
05:35:03 <int-e> > let 0 |* x = 0; x |* 0 = 0; x |* y = x * y in fix (0|*)
05:35:04 <lambdabot>  0
05:35:07 <int-e> > let 0 |* x = 0; x |* 0 = 0; x |* y = x * y in fix (|*0)
05:35:08 <lambdabot>  Exception: <<loop>>
05:35:50 <dons> > fix (:1)
05:35:51 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
05:35:51 <lambdabot>    Expected...
05:36:00 <norpan> fix f = f (f (f (f (f ...))))
05:36:00 <roconnor> I like how it doens't actually run forever, it just says it would if it weren't lazy.
05:36:19 <dons> heh
05:36:19 <roconnor> > fix (1:)
05:36:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:36:30 <dons> > fix (++[1])
05:36:32 <lambdabot>  Exception: <<loop>>
05:36:50 <mauke> rahikkala: and the number of dimensions is variable?
05:41:00 <rahikkala> mauke: It's constant and actually known at compile-time
05:46:13 <cge> @hoogle group
05:46:14 <lambdabot> List.group :: Eq a => [a] -> [[a]]
05:46:14 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
05:46:14 <lambdabot> System.Console.Readline.beginUndoGroup :: IO ()
06:02:38 * rahikkala ends up implementing it the C way (I've been experimenting with this problem in several languages): With a one-dimensional array and a mapping between indexes into said one-dimensional array, and coordinates in the n-dimensional space I'm working in
06:08:30 <ozone> uh oh
06:08:53 <ozone> pants off
06:08:59 <dons> you're scaring me ozone
06:09:35 <ozone> dons: are you sancho?
06:09:39 <ozone> you are not sancho
06:09:58 * dons hides from crazy ozone
06:10:15 <ozone> when are you leaving for SoC thing?
06:10:26 <dons> in the morning
06:10:39 <ozone> oh wow.  have a good flight!
06:10:45 <dons> so, bed time! mmm i can taste the jet lag already
06:10:55 <ozone> meh, just sleep on the plane
06:11:13 <ozone> if there's any crying babies, just bring a sledgehammer...
06:11:14 <dons> yeah, i'll try this time. i seem to remember a certain flight next to a certain ozone with not much sleep ...
06:11:51 <dons> sledgehammer, ok. /me ticks off todo list
06:12:01 <ozone> what the hell?  somebody's using windows GHC in wine?
06:12:05 <ozone> crazy bastards
06:12:07 <emk> Ah, so that's how most of the (non-GHC) Haskell compilers reattach the results of type inference to the AST: They give unique identifiers to all top-level, let-, and where-bound variables, build a map from those identifiers to types, and then recompute the types of the other AST nodes as needed during transformation to an intermediate language.
06:12:10 <Lemmih> Have fun, dons.
06:12:16 * emk is enlightened
06:12:22 <dons> emk: scary
06:12:38 <ozone> dons: the real question is whether there'll be lots of hot asian chicks at APLAS
06:12:42 <ozone> i say, probably not
06:12:50 <dons> yay for compilation by transformation!
06:12:58 <emk> dons: If there's a better way to do it, I'm happy to take a look at that, too. :-)
06:13:00 <dons> ozone: well, we can  but hope, right?
06:13:24 <dons> emk: does Appel's book say anything on the matter?
06:13:42 <emk> Compiler Construction in ML?
06:13:45 <dons> Lemmih: cheers. i'll try to make lots of notes/convert lots of python devs :}
06:13:54 <dons> emk yup
06:14:06 <ozone> dons: where's that larry wall quote from?
06:14:19 <dons> the HWN one?
06:14:21 <emk> Well, in ML, you could always cop out and add a mutable "type" field to your AST nodes.
06:14:40 <ozone> yeah
06:14:48 <dons> ozone: from the #perl6 channel a few weeks ago
06:14:53 <dons> only spotted it recently
06:15:06 <kfish> ozone, wtf?
06:15:23 <ozone> kfish: "Larry Wall: Perl is turning into Haskell. Someone shoot me."
06:15:31 <dons> seems like Larry is the most quoted haskell hacker these days, even in ghc announces he gets quoted, http://programming.reddit.com/info/lr5w/comments :)
06:16:15 <kfish> heh
06:16:33 <emk> dons: Enforced purity tends to take lots of obvious tricks off the table. I kinda wish somebody would write an intro-level book on writing compilers in Haskell, just so I could
06:16:36 <lambdabot> http://tinyurl.com/eg38m
06:16:38 <emk> learn the new tricks.
06:16:59 <dons> I really thought i'd never see: "According to Larry Wall .... upgrading GHC ... " in the same sentence
06:17:27 <dons> emk, well there's the haskell compiler construction stuff spj et al wrote in the early 90s
06:17:37 <dons> and all those ghc papers..
06:18:41 <dons> ok. night all!
06:18:48 <emk> dons: Thanks!
06:20:54 <ozone> night don, fly well!
06:21:26 <musasabi> dons: is there a reason that you use custom pack in fps code rather than contributing a patch to pokeArray?
06:22:38 <musasabi> (or dcoutts )
06:23:06 * emk has read a score of Haskell papers in the last week, and his brain is full
06:23:09 <wolverian> patching dcoutts? :)
06:23:44 <musasabi> patching dcoutts to patch base.
06:38:05 <x3m2> why isnt ghc 6.6 released for win?
06:39:34 <ndm> x3m2, there is a windows installer, buts its built by someone else - i can give you teh preview link thats gone out for testing
06:39:45 <Patterner> unix people know how to compile the source
06:39:54 <ndm> x3m2: http://haskell.org/ghc/dist/6.6/ghc-6-6.msi
06:40:10 <x3m> okay
06:41:03 <x3m> Patterner: no, unix people got no real life, sitting inside and reading manuals and confing their system instead of going out
06:41:37 <Patterner> why "no"? those things fit together wonderfully :)
06:42:25 <x3m> "emerge ghc" yeah, thats hard
06:44:29 <Patterner> well, you have to manage to open an xterm first
06:44:48 <int-e> and use sudo or su ...
06:44:53 <int-e> that's hard :)
06:45:12 <x3m> indeed
06:45:16 <int-e> noone should be forced to memorize the two letter abbreviations for useful commands.
06:45:20 <Smokey`> x3m: hah, most the people I know who use *nix, go out more than the ones that dont :)
06:46:08 <int-e> it's soooo much easier to click through a menu of several levels with a mouse. it's called usability, I believe.
06:47:01 <ndm> int-e: menus are so "old style", the Word 2007 is soooo much better
06:47:21 <x3m> Smokey`: well there is a reason why they are called geeks ;)
06:47:38 <int-e> ndm: what did they invent this time?
06:47:56 <ndm> int-e: tabs and context sensitive galleries, its actually really really nice
06:48:36 <Smokey`> I personally prefer linux from many perspectives (especially in relation to a platform to develop 'for'), however when it comes to an OS to develop 'on', I seriously prefer windows, w/ VS .NET, and cygwin for haskell/java
06:49:35 <x3m> VS really is kickass
06:51:40 <musasabi> Is there really no andI# :: Int# -> Int# -> Int# ?
06:52:48 <Smokey`> x3m: I agree :) VS 7 was a bit sketchy, but 8 is rather solid :)
06:53:21 <musasabi> SamB: how do you handle rotare without Word# literals if the bit ops don't like Int# ?
06:53:32 <ndm> i thought 6 was beautiful, and if you try running 1, its insanely quick to compile
06:53:35 <int-e> there is and# ... Data.Bits uses int2Word# x# `and#` int2Word# y#
06:53:37 <SamB> musasabi: huh?
06:53:48 <int-e> and a word2Int# around that
06:54:00 <musasabi> lots of word2Int# then.
06:54:14 <SamB> those aren't the troublesome ones
06:54:38 <int-e> they should be noops anyway
06:55:14 <SamB> yeah
06:57:05 <musasabi> icky code: word2Int# (((r `uncheckedShiftRL#` 10#) `and#` int2Word# 0x3FF#) `or#` int2Word# 0xD800#)
06:59:21 <lisppaste2> SamB pasted "rotate worker for Word8" at http://paste.lisp.org/display/27834
07:00:09 <int-e> not bad
07:44:03 <Syzygy-> Why does this generate a parse error?   if (t+eps) > maxTick then eps $= (-e)
07:44:14 <Syzygy-> Oh wait...
07:44:36 <Syzygy-> Why does this generate a parse error?   if (t+e) > maxTick then eps $= (-e)
07:44:47 <Syzygy-> t and e are Floats, eps is an IORef storing a float.
07:44:53 <ndm> does -e work?
07:44:54 <Syzygy-> maxTick was defined to be a Float.
07:45:02 <ndm> - is a bit screwed in haskell...
07:45:56 <Syzygy-> Nope. it doesn't...
07:46:06 <Syzygy-> However, the error seems to occur on the first line afterwards.
07:46:24 <Syzygy-> Oh bugger.
07:46:30 <Syzygy-> if .. then needs an else.
07:48:11 <roconnor> heh, yhc doesn't have a -O flag
07:48:37 <ndm> roconnor: not yet :)
07:48:46 <ndm> roconnor: but i'm working on it
07:48:59 <roconnor> ndm: oh, so the optimer isn't available yet?
07:49:06 <ndm> roconnor: no
07:49:19 <roconnor> so basically there is no way that yhc will make my UM faster.
07:49:23 <roconnor> at the moment.
07:49:25 <ndm> no :(
07:49:28 <ndm> not yet
07:49:34 <roconnor> ok
07:49:40 <ndm> but i am hoping that on the short example you have had on teh list, i'll beat GHC
07:49:47 <ndm> pre your tweaks, certainly
07:50:22 <roconnor> ndm: how do you do it?
07:50:34 <ndm> roconnor: specialisation, partial evaluation, no inlining
07:50:49 <ndm> roconnor: advanced static analysis
07:50:51 <roconnor> isn't partial evaluation basically a form of inlining?
07:50:56 <ndm> no
07:51:03 <ndm> in a short answer :)
07:51:11 <ndm> at least my approach has nothing in common with inling
07:51:18 <roconnor> okay
07:51:22 <ndm> inlining is about moving the body of the code to the caller
07:51:38 <ndm> my approach moves the context of the caller into the body of the callee
07:51:42 <ndm> so the opposite
07:51:43 <earthy> partial evaluation is about applying the code to arguments known at compile time
07:52:06 <ndm> for example, you can't inline map as its recursive
07:52:14 <ndm> however you can partially evaluate it easily enough
07:52:18 <roconnor> but you end up doing a beta/delta-reduction.
07:52:29 <ndm> i do Neil(TM) reduction
07:52:45 <ndm> its unique
07:52:54 <ndm> for example, my optimiser doesn't have higher order functions
07:53:14 <ndm> i.e. map in my code is first order
07:53:30 <roconnor> presumably you have a core-like functional language?
07:53:35 <ndm> yep
07:53:42 <ndm> core-like
07:53:44 <Igloo> first order in what sense?
07:53:47 <vincenz> shapr: PINGg
07:53:49 <ndm> but no higher order functions
07:53:54 <ndm> Igloo: no higher order functions
07:54:06 <Igloo> So what does map look like?
07:54:08 <ndm> Igloo: i.e. a function is not a first class citizen, and cannot be passed around
07:54:27 <roconnor> not higher order functions!
07:54:37 <roconnor> okay
07:54:40 <vincenz> shapr: ping
07:55:06 <ndm> Igloo: the functional argument is put into the code of map, i.e. map head is rewritten to map_head x = case x of [] -> [], (x:xs) -> head x : map_head xs
07:55:08 <roconnor> but you still have lambdas and applications?
07:55:13 <ndm> roconnor: no
07:55:23 <roconnor> so it isn't core like at all :)
07:55:25 <roconnor> @where yhc
07:55:26 <lambdabot> http://www.haskell.org/haskellwiki/Yhc
07:55:30 <ndm> roconnor: "Core like"
07:55:46 <earthy> yhc doesn't like me
07:55:48 <ndm> roconnor: the initial Core does have top level lambda's, the final version doesn't
07:55:51 <Igloo> Ah, OK
07:56:00 <ndm> earthy: do you love Yhc?
07:56:09 <Igloo> So you do something like a disfunctionalisation pass, or whatever the term is?
07:56:11 * earthy wanted to see what yhc was like
07:56:17 <ndm> earthy: and if you have a specific issue, please report it to yhc -at- haskell.org
07:56:19 <ndm> Igloo: yes
07:56:26 <ndm> defunctionalisation
07:56:36 <earthy> owh, it's just that it doesn't want to find the GHC installed GMP.Framework
07:56:36 <roconnor> okay, no lambdas
07:56:43 <ndm> but clever defunctionalisation, Reynold's style is not fast enough
07:56:58 <ndm> earthy: what OS?
07:57:03 <Igloo> Not fast enough, or produces code that isn't fast enough?
07:57:11 <roconnor> ndm: so this is a combinator language?
07:57:13 <ndm> produces code that isn't fast enough
07:57:15 <ndm> roconnor: no
07:57:28 <Igloo> Is that new research then?
07:57:33 <ndm> and isn't type safe, if thats something you care about
07:57:35 <ndm> yes
07:57:37 <roconnor> ndm: there is no theory behind this language at all?
07:57:40 <Igloo> Cool
07:57:49 <ndm> roconnor: yes, lots of theory, i have pages and pages of it!
07:57:53 <earthy> ndm: Mac OS X, what else. (Framework should've given that away ;))
07:57:54 <ndm> roconnor: but not that any one else has
07:58:05 <roconnor> how is it not a combinator language?
07:58:19 <ndm> earthy: hehe, we have at least 3 OS X build bot machines, but there was some issues with libgmp, do you ahve darwinports?
07:58:23 <ndm> earthy: or fink?
07:58:37 <earthy> neither ;)
07:58:39 <ndm> roconnor: it has case, application (fully saturated only), top level functions
07:58:51 <roconnor> right
07:59:02 <ndm> earthy: if you have libgmp, and its possible to find on your system, in some reasonably sensible place, tell us and we'll update the config scripts to check there
07:59:22 <ndm> earthy: if its not anywhere sensible, then you should be able to pass some flag to say where it is, but i have no idea what, so hit the mailing list
07:59:31 <ndm> roconnor: what do you mean by "combinator"?
07:59:42 <earthy> I do have libgmp though, but it's in /Library/Frameworks/GMP.Framework/
07:59:54 <earthy> and obviously, the flags are not documented ;)
08:00:03 <earthy> as yhc is under development ;)
08:00:05 <roconnor> ndm: good question.
08:00:30 <ndm> earthy: the documentation is a wiki, so its actually pretty well documented
08:00:50 <ndm> http://www.haskell.org/haskellwiki/Yhc/Building#Scons_Options
08:00:55 <ndm> but i can't see a GMP one
08:01:10 <earthy> that page is not refered to in the readme.txt in the sources...
08:01:11 <roconnor> I guess I imagine a tree of applications, and rewrite rules that operated on fully applied functions, but I only have a vague idea.
08:01:19 <roconnor> @google combinator
08:01:41 <ozone> earthy: you can use install_name_tool to change where the executable expects to find libgmp
08:01:48 <ozone> (hi btw, it's been a while :)
08:01:52 <lambdabot> Title: Yhc/Building - HaskellWiki, http://tinyurl.com/y2px6u
08:02:00 <earthy> ozone: I know about install_name_tool
08:02:02 <ndm> earthy: we have a readme? oh dear, i can't imagine how out of date that is...
08:02:10 <lambdabot> search module failed: IRCRaised thread killed
08:02:11 <earthy> ouch. :)
08:02:19 <ozone> oh, you need libgmp in /usr/local/lib/ ?
08:02:22 <earthy> yes, you have a readme. :)
08:02:33 * ndm deletes the readme
08:02:35 <earthy> ozone: no, the compilation process needs to find libgmp.h
08:02:44 <earthy> (or rather, gmp.h)
08:02:46 <ozone> heh, just install it manually
08:02:48 <ndm> earthy: is that a standard location to install it?
08:02:51 <earthy> yeah, yeah, I know
08:03:06 <ozone> ok then, looks like you don't need my help :)
08:03:12 <earthy> ndm: it is for the GHC 6.4.1 installer for Mac OS X. :)
08:03:33 <earthy> ozone: I could've used that info last week. Took me 2.5 hours to find that out ;)
08:03:48 <ndm> earthy: the build script will be updated in about 10 mins :)
08:03:53 <earthy> ndm: :)
08:04:23 <ndm> earthy: are the libgmp.a and gmp.h directly under that directory?
08:04:26 <earthy> really, the whole reason for checking yhc was to see if it is faster compiling a file with 1 function and 1 datatype
08:04:36 <roconnor> ndm: okay so you have this Core language.  And you do optimisations by transformations on this language?
08:04:45 <ndm> earthy: much much faster, is the answer
08:05:01 <ndm> roconnor: yes, the core language at the begining has functions as values, but not at the end
08:05:32 <earthy> ndm: yea, but the lib is called GMP
08:05:38 <earthy> rather than say libgmp.dylib
08:05:46 <ndm> earthy: GMP. anything ?
08:05:52 <ndm> and whats teh header called?
08:05:57 <earthy> GMP
08:05:59 <earthy> is the lib
08:06:04 <earthy> Headers/gmp.h is the header
08:07:14 <roconnor> And your partial evaluator ends up duplicating core expressions (and modifying one copy)?
08:07:18 <Mpenzi> Hello, does anyone have an implementation of sets in haskell?
08:07:36 <roconnor> Mpenzi: what do you mean by sets?
08:07:37 <earthy> Data.Set ?
08:07:42 <roconnor> Mpenzi: there is Data.Set
08:07:51 <ndm> earthy: pull now, and give it another go
08:07:55 <roconnor> which are really finite sets
08:08:02 <ndm> roconnor: yes, you could say that
08:08:11 <Mpenzi> roconnor: I meant the basic math set operations such as in, union, difference etc. etc.
08:08:23 <Mpenzi> roconnor: I was just trying to see the implementation of it since I want to understand how it is done
08:08:33 <roconnor> Data.Set has those operations on finite sets
08:08:44 <earthy> some of them are also in Data.List
08:08:49 <Mpenzi> Ah
08:09:02 <Mpenzi> Ok, is there a place to see the source for those?
08:09:26 <roconnor> ndm: Do you do anything to prevent a possible exponential explosion in size from partial evaluation?
08:09:31 <sjanssen> @fptools Data.Set
08:09:36 <ndm> roconnor: yes
08:09:50 <roconnor> ndm: this is what I am very interested in.
08:09:50 <sjanssen> is lambdabot alive?
08:10:08 <Mpenzi> sjanssen: sorry i'm kinda new at haskell
08:10:16 <ndm> roconnor: have you read Mark Jone's paper on specialising dictionary transformations? he makes a convincing argument, with statistics, that exponential blow up doesn't happen in practice
08:10:16 <earthy> Mpenzi: the Haskell report has some implementations on Data.List
08:10:16 <jgrimes_> > 2 + 2
08:10:28 <Mpenzi> earthy:  ah let me search for it
08:10:37 <sjanssen> Mpenzi: well, lambda bot was supposed to give you a URL of the Data.Set source, lemme find that
08:10:37 <ndm> roconnor: i use recursion and a fixed pointing stack, the exact details are too confusing to explain, and not written anywhere, sadly
08:10:43 <ndm> roconnor: although i will document it
08:10:48 <Mpenzi> sjanssen: ah :)
08:10:53 <roconnor> ndm: that's what they all say :)
08:10:54 <earthy> or you could look at http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/Data/Set.hs?rev=1.29;content-type=text%2Fplain
08:11:05 <ndm> roconnor: give me time :)
08:11:13 <ndm> earthy: any luck with Yhc and the new build script?
08:11:19 <sjanssen> earthy: the CVS stuff is likely to be quite stale
08:11:27 <earthy> Copying patch 282 of 722...
08:11:31 <Mpenzi> ah thanks earthy
08:11:40 <ndm> earthy: --partial :)
08:11:48 <earthy> sjanssen: doesn't matter if he wants to see an example of an implementation, does it?
08:11:56 <sjanssen> http://darcs.haskell.org/packages/base/Data/Set.hs
08:11:59 <roconnor> ndm: okay, we need to build a sha2sum or sha1sum.  I think these make heavy use of rotate.
08:12:10 <earthy> ndm: good one. :)
08:12:11 <Mpenzi> thanks again sjanssen
08:12:14 <sjanssen> earthy: sure . . . but why browse a CVS repository that is no longer used?
08:12:20 <ndm> earthy: and i'm just patching the documentation...
08:12:38 <earthy> sjanssen: because I suck at going to the sources? :)
08:12:54 <earthy> (I usually have a tree on my local machine... that doesn't work for others though :))
08:13:20 <roconnor> http://citeseer.ist.psu.edu/context/223726/219811
08:13:31 <roconnor> M. P. Jones. Dictionary-free overloading by partial evaluation.
08:13:41 <roconnor> ndm: this is what you are talking about
08:14:16 <ndm> roconnor: yep, but what i do is more powerful, and more general (subsumes that)
08:14:29 <ndm> roconnor: but thats definately a good place to start reading
08:17:46 <earthy> Checking for C header file gmp.h... yes
08:17:46 <earthy> Checking for mpz_t integ; mpz_init (integ) in C library gmp... no
08:17:51 <ndm> roconnor: as soon as i have something to show you, i will
08:18:28 <ndm> earthy: give me a sec, just reporting it
08:18:34 <earthy> no probs ;)
08:18:43 <earthy> just reporting back to you ;)
08:18:49 <ndm> cheers :)
08:18:57 <ndm> is it really just /Library/Frameworks/GMP.Framework/GMP
08:19:00 <ndm> for the libary?
08:19:20 <ndm> (our build guru thinks that seems very odd)
08:19:58 <ndm> earthy: ^^
08:20:03 * roconnor feels like implementing Integer with Int
08:20:23 <ndm> roconnor: my initial yhc -O implementation will almost certainly do that :)
08:20:25 <earthy> ndm: yes, that is very odd
08:20:35 <ndm> earthy: but yes, it is like that?
08:20:58 <roconnor> ndm: ? you are using GMP?
08:21:02 <earthy> file /Library/Frameworks/GMP.framework/Versions/A/GMP
08:21:03 <earthy> /Library/Frameworks/GMP.framework/Versions/A/GMP: Mach-O dynamically linked shared library ppc
08:21:06 * earthy nods
08:21:25 <ndm> fair enough... - he's updating it now
08:21:40 <ndm> roconnor: Yhc does, Yhc -O won't until the second version
08:22:00 <roconnor> that doesn't sound so optimial :)
08:22:25 <roconnor> actually, there is a coq development that implements integers from fixed sized words.
08:22:32 <roconnor> I should just extract the haskell from that.
08:22:40 <roconnor> provably correct!
08:23:39 <ndm> earthy: pushed
08:24:31 <ndm> roconnor: indeed, but one thing at a time - my aim is to win on lists etc., then move on to Int's/Integers next
08:25:23 <earthy> and then it couldn't find the header file anymore...
08:26:33 <ndm> reporting it onwards...
08:26:49 <earthy> LIBS=[env["lib
08:26:50 <earthy> gmp"]]+yhilibs
08:26:53 <earthy> looks weird to me
08:27:08 <ndm> i don't look at the build code :)
08:27:13 <earthy> but I don't know scons :)
08:27:18 <earthy> wise of you ;)
08:27:31 <ndm> earthy: try again, new patch
08:32:41 <roconnor> springer-link can go f*** itself.
08:33:06 <vegai> what's that?
08:33:40 <roconnor> http://www.springerlink.com/content/u0w1121626576367/
08:34:23 <earthy> gotcha. -lGMP is passed. that won't work, as that will try to link libGMP.dylib
08:34:53 <andrew_j_w> is the exact name of the library just GMP?
08:34:59 * earthy nods
08:35:01 <earthy> weird, huh?
08:35:05 <andrew_j_w> extremely
08:36:09 <andrew_j_w> I'm not sure how we're supposed to link against that library
08:36:16 <andrew_j_w> lib*.dylib is added by the compiler, not us
08:36:21 * earthy knowd
08:36:24 <earthy> knows, even
08:36:35 <ndm> Igloo: is the GMP distributed by GHC 6.4.1 on Mac suitable for linking with programs requiring normal GMP library?
08:37:02 <earthy> that's Wolfgang Thaller's stuff. :) I'd say it isn't, really
08:38:00 <Igloo> ndm: It's quite old, so you should probably use a more up-to-date one if possible
08:38:25 <Igloo> Oh, assuming it's the one that's in the source tarball, that is
08:40:37 <earthy> linking to it, btw, is a matter of specifying the full path to the dylib explicitly to the compiler
08:40:48 <earthy> ugly, I know
08:41:18 <andrew_j_w> yes, and not very portable either
08:41:22 <earthy> unfortunately, I kinda need to run
08:43:43 <ndm> earthy: can you email the yhc list, so we can email you back to get in contact
08:43:59 <ndm> earthy: just a message saying "i'm earthy and i can't compile Yhc is enough"
08:43:59 <earthy> 's okay
08:48:10 <musasabi> lack of qualified type variables in Haskell98 is such a pain.
08:49:33 <Igloo> But type variables can't be exported
08:50:41 <musasabi> mallocNewForeignPtrBytes (n * sizeOf theResultType)
08:51:01 <earthy> right. off to the UK. :)
08:51:30 <svref> Is it usual/unusual/forbidden to have two files defining things in the same module?
08:53:19 <Igloo> earthy: ?
08:54:36 <lispy> svref: iirc, the standard does not forbid it, but in practice i don't think you can do it...but i may be thinking of the other case where you have multiple modules in one file
08:55:17 <svref> hm, guess I'll read up on sub-modules then.  :)
08:56:01 <int-e> you can however, import a module and export all its symbols again.
08:57:18 <int-e> so you can have module X (module X.A, module X.B) where { import X.A; import X.B }
08:58:46 <svref> int-e: aha, that looks like the way to go
08:59:46 <int-e> instead of exporting mopdule X.A you can also list all its symbols, or just those you want to export.
09:03:34 <psi> does the new ghc also accept real arrows instead of ->? i.e, Î»x â†’ x * x.
09:04:43 <lispy> hmm....your lambda came through, but the rest was junk
09:04:58 <int-e> looks fine here.
09:05:05 <lispy> ÃŽÂ»x?\206' x * x.
09:05:07 <lispy> that's what i see
09:05:12 <psi> :)
09:05:32 <lispy> cool that the lambda worked though
09:05:46 <int-e> (except that the lambda in my font looks awful but I can't really blame psi for that)
09:05:53 <glguy> lispy's lambda worked for me but not psi's
09:06:11 <wilx> Psi's worked fine here.
09:06:14 <araujo> morning!
09:06:19 <wilx> Not so much lispy's.
09:06:29 <lispy> i once had an emacs had that turned (lambda (x) ...) into (ÃŽÂ» x) ... )
09:06:31 <wilx> (mIRC with UTF-8 support turned on.)
09:06:48 <psi> I'm using UTF-8.
09:07:00 <glguy> irssi with UTF-8 heree
09:07:01 <lispy> bleh, that's not quite what i typed
09:07:16 <int-e> hmm. ÃŽÂ» == Î» ?!
09:07:22 <lispy> (ÃŽÂ» (x)
09:07:26 <lispy>  crap
09:07:33 <lispy> now my emacs is hosed :)
09:07:38 * lispy restarts
09:07:47 <Igloo> You're double-utf8in, lispy
09:07:58 <glguy> I don't think that my font has the -> unicode char
09:08:20 <psi> â†’â†â†‘â†“ â†”â†— â‡â‡‘â‡’â‡“ â‡”â‡—
09:08:54 <psi> pretty much everything seems to work in emacs-snapshot on debian.
09:09:11 <svref> What do I name the file with Module Traffic.Units so that Emacs' C-c C-l finds it properly?
09:09:23 <psi> I don't recall installing any particular fonts.
09:10:26 <lispy> psi: i'm using emacs, but then i'm using screen and some terminal too...so that always confounds things :(
09:10:50 <lispy> svref: usually i would put that in Traffice/Units.hs
09:10:55 <lispy> er Traffic
09:11:25 <psi> lispy: ah. have you tried rxvt-unicode (or urxvt, whatever it's called)?
09:11:29 <wilx> Screen should be able to handle UTF-8.
09:12:24 <svref> hm...well ALL my modules (even the ones not beginning with "traffic." are currently in a directory called "traffic".  I'll try upcasing the "t" and see what happens.
09:12:55 <lispy> psi: rxvt is a pain on osx
09:13:23 <lispy> wilx: screen may be fine then
09:13:32 <wilx> But you must turn it on :)
09:13:36 <lispy> ah
09:14:04 <wilx> C-A : utf8
09:14:11 <wilx> C-a : utf8
09:14:23 <lispy> psi: but when i use linux, rxvt is my terminal of choice
09:14:41 <wilx> Or some option into .screenrc that I do not remember.
09:14:57 <lispy> hmm...yeah it just told me it will use utf8
09:15:08 <lispy> C-z : utf8 for me
09:15:19 <lispy> icouldn't use emacs in screen with C-a taken :)
09:15:30 <svref> eeeexcelent
09:15:40 <wilx> Yeah, the escape sequence can differ.
09:16:02 <wilx> lispy, exactly! I hate that, but I never got to it to change it :)
09:16:09 <wilx> Maybe I should do it now.
09:16:13 <lispy> heh
09:16:14 <glguy> I'm not sure if the unicode characters are breaking PuTTY or irssi... or screen
09:16:28 <lispy> glguy: in the past it was putty
09:16:34 <lispy> glguy: but supposedly newer putty does it
09:17:06 <wilx> Well, irssi afaik does not enable it by default either.
09:17:19 <wilx> Heh, so many places where you have to set it :)
09:18:00 <glguy> Î <- does this show up correctly for anyone else?
09:18:25 <glguy> hmm, it looks right here when I input it, but not when it is sent to channel
09:18:38 <jmmv> is it an I with a ^ over it?
09:18:42 <glguy> lambda
09:19:23 <glguy> Î»x lambda x?
09:19:40 <jmmv> now I see it
09:19:40 <glguy>  glguy> \u03bbx lambda x?
09:19:46 <glguy> that's what I see when I type that
09:20:17 <wilx> I see nice lambda.
09:20:28 <wilx> The first line is not lambda here.
09:20:40 <glguy> the first line isn't lambda here either
09:20:45 <glguy> but i typed one
09:20:47 <glguy> (pasted rather)
09:21:34 <glguy> ah, IRSSI has a setting TERM_CHARSET
09:22:21 <glguy> Î» x
09:22:25 <glguy> now I see it :)
09:22:45 <wilx> Lambda!
09:22:53 <wilx> Î» x
09:22:59 <lispy> sadly only psi's lambda has worked here :(
09:23:30 <glguy> does anyone see an arrow here: â†’
09:23:36 <wilx> ã¯ã„ï¼
09:23:51 <psi> glguy: yup
09:24:00 <glguy> darn, this font doesn't support them
09:24:04 <psi> that's not the same lambda I used, though.
09:24:14 <svref> x-chat sees no arrow
09:24:29 <glguy> it'll be a shame when I have to change fonts to use cool new haskell supported arrows
09:24:51 <svref> who cares about arrows?  The funk character I'd like to see is lambda.
09:25:14 <psi> I'm defining abbrevs in emacs for all greek chars currently :)
09:25:42 <svref> glguy: have you heard of the "fontset" concept?  Basically instead of one font, there's a "path" of fonts, and it searches them in order until one has the character you're looking for.
09:25:50 <svref> glguy: gnome uses it, IIRC
09:26:07 <glguy> svref: I connect via PuTTY in Windows
09:26:19 <glguy> I don't use Linux for anything more than playing with Xgl
09:26:39 <svref> glguy: simpson bully voice: "Haaa haa!"
09:27:10 <profmakx> nelson...
09:27:14 <profmakx> <nelson.wav />
09:29:52 <psi> yay: Ïˆ Î» Î¸ Ï€ -- I only have to type the names for emacs to insert the unicode character.
09:30:19 <wilx> psi lambda psi pi?
09:30:40 <psi> the third is Theta
09:31:01 <glguy> â–’H Î» Î¸ â–’@
09:31:04 <glguy> that's what I saw
09:31:14 <resiak> I-umlaut I-with-a-hat-followed-by-double-right-pointy-bracket, I-with-a-hat-followed-by-a-cedilla-character, I-with-an-umlaut is what I saw
09:31:27 <wilx> Heh.
09:33:01 <psi> this character is snazzy: Î¾
09:33:27 <wilx> I see it but I do not remember what is its name :)
09:33:33 <int-e> Î¾ xi
09:33:49 <int-e> Î¶ is also nice (zeta)
09:34:01 <glguy> Îž
09:34:09 <int-e> Îž Xi (capital)
09:34:15 <int-e> :)
09:34:18 <psi> int-e: I see yours differently
09:34:19 <glguy> for some reason I can't see the Xi
09:34:31 <glguy> either of them, but they are in my font
09:34:36 <glguy> unicode is ftl
09:35:10 <int-e> unicode would be great a) if there was only one encoding and b) everyone used it.
09:35:21 <glguy> but instead... ftl
09:36:56 <glguy> Îž <- this worked though... wonder why
09:37:05 <glguy> oh, until it came back
09:37:07 <glguy> nvm
09:37:15 <int-e> looked fine here.
09:37:20 <glguy> grr
09:37:27 <int-e> (if it was a capital xi)
09:37:31 <glguy> yeah
09:37:46 <glguy> I think that IRSSI wants its ass beaten
09:39:10 <musasabi> Is it possible to export a constructor but to omit the name of the type?
09:39:39 <glguy> Why would you want to do that?
09:40:00 <musasabi> module Foo (Bar, OtherModule.Bar(SomeThing)) where ...
09:40:05 <wilx> What about exporting just mkType just the name of the type without its constructors?
09:40:21 <wilx> *and*
09:41:06 <musasabi> wilx: "module Something(Type) where" exports type without constructors.
09:43:07 <wilx> Hmm, I do not understand why would you want to export just the constructor?
09:45:32 <musasabi> wilx: I have "type T = Generic.T MyType" and want to export the Generic.T:s constructor as well as T. Renamed Generic.T to solve the problem.
09:48:00 <wilx> Hmm, complicated. :)
09:52:17 <roman> hi..
09:52:49 <roman> lets say I have do x <- Monad.liftM2 (+) (Just 1) (Just 2); how do I putStr that x?
09:52:58 <roman> ie. how to combine Maybe monad in a IO monad
09:56:07 <roconnor> @type maybe
09:56:43 <mauke> do print (Monad.liftM2 (+) (Just 1) (Just 2))
09:57:19 <roconnor> maybe mzero return x will turn x from a Maybe a into an IO a
09:57:46 <mauke> > 42
09:58:03 <roman> ah... return
09:58:17 <int-e> @type maybe (return ()) print
09:58:37 <roman> can you write that using "x <- ..." for me?
09:58:38 <roconnor> maybe (return()) print :: (Show a) => Maybe a -> IO ()
09:59:00 <araujo> > return (Just 5) :: IO (Maybe Int)
09:59:23 <roconnor> do x <- maybe Monad.mzero return $ Monad.liftM2 (+) (Just 1) (Just 2)
09:59:27 <Igloo> roman: You can't mix them the way I think you want to
09:59:45 <roman> ah
10:00:37 <Igloo> All the statements in a do block must belong to the same Monad
10:00:49 <roman> yes.. thats why I wondered how to do it
10:00:56 <roman> so I have to layer it using return
10:03:04 <roconnor>     No instance for (Control.Monad.MonadPlus IO)
10:03:06 <roconnor> hmmm
10:03:10 <roconnor> someone told me otherwise.
10:03:25 <roman> a friend showed me how to combine these using arrows
10:03:30 <roman> (Kleisli arrow)
10:06:05 <dolio> You'll probably have trouble finding an mzero for IO.
10:07:50 <dolio> And the way it's actually implemented might cause problems.
10:08:46 <dolio> (putChar 'a' >> mzero) `mplus` (putChar 'b') would have to be sure to not print an 'a'.
10:12:12 <roconnor> dolio: I didn't think IO was a monad plus.
10:15:51 <dolio> Exceptions and catch might act similar, but I don't think it'd keep the a from being printed.
10:26:45 <dolio> Whoa, Hans Reiser was arrested?
10:26:57 <spiffy> yep
10:27:06 <spiffy> charged with murder.
10:27:10 <dolio> Wow.
10:28:13 <ValarQ> oh
10:31:26 <araujo> hi
10:31:28 * araujo off to eat
10:50:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar-Easter.html -- whoa
10:51:50 <glguy> whoa?
10:52:01 <Cale> Just that it's fairly specific :)
10:52:30 <glguy> the unix calendar utils have specific easter date finding algorithms also
10:52:38 <Cale> ah
10:52:56 <glguy> so I'm used to it, but I would be shocked otherwise ;)
10:53:38 <Cale> sundayAfter :: Day -> Day
10:53:53 <Cale> No obvious generalisation there ;)
10:55:07 <glguy> but then it would not belong in the Easter module ;)
10:56:53 <shapr> @yow !
10:58:00 <glguy> @yow --!
10:58:07 <glguy> @you
10:58:08 <glguy> ?
10:58:13 <glguy> @yow
10:58:17 <glguy> @version
10:58:25 <shapr> lambdabot: @hello
10:58:58 <glguy> \o/
10:59:08 <jgrimes_> lambdabot hasn't been responding :(
10:59:21 <glguy> \o/
10:59:22 <glguy>  |
10:59:24 <glguy>  ^
10:59:58 <shapr> Is that a mermaid?
11:00:44 <dolio> A dude with very short legs?
11:00:56 <shapr> probably...
11:01:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Main.html -- huh?
11:02:11 <dmead> \o/
11:02:22 <albertlee2> hmmm
11:02:33 <albertlee2> ?localtime albertlee2
11:02:44 <shapr> @seen vincenz
11:14:58 <monochrom> w00t! 6.6 is out!
11:15:02 <dima_> is there a changelog for 6.6?
11:15:14 * monochrom puts aside his thesis in favour of playing 6.6
11:15:49 <monochrom> Darn it was out yesterday already.
11:16:09 <dima_> i found 6.6 announcement by luck on digg :)
11:16:47 <monochrom> I subscribe to the haskell mailing list, so I get the annoucement. but evidently I don't read it everyday.
11:16:58 <kaol> aww... too late to be included in the next Debian release.
11:17:06 <dima_> kaol, nope
11:17:09 <dima_> the freeze moved
11:17:27 <monochrom> the freeze moved just to wait for us? :)
11:17:42 <jgrimes_> dima_, here are the release notes http://haskell.org/ghc/docs/6.6/html/users_guide/release-6-6.html
11:17:52 <dima_> ah, thank you
11:18:11 <kaol> if it won't have to go through NEW, then perhaps
11:19:23 <kaol> even then, it would have to be packaged within days, since it would still take 10 days after that until it gets into testing
11:20:14 <dima_> well, the freeze is estimated to be somewhere end october to november beginning
11:20:30 <dima_> no date announced
11:28:39 <yip> you guys seem to like darcs for source control of your project's code. what do you guys use for bug tracking?
11:29:03 <yip> maybe we should start a haskell bug tracker project? :D
11:29:06 <xerox> . o O (The type system.)
11:30:08 <monochrom> haha
11:32:45 <monochrom> Nice! The LANGUAGE pragma is nice!  Now I can turn on extensions more fine-grained.
11:33:01 <xerox> What's that!
11:33:41 <sjanssen> monochrom: I hadn't seen that yet
11:33:46 <sjanssen> that is way cool
11:34:07 <lispy> monochrom: is that a new GHC pragma?
11:34:09 <monochrom> {-# LANGUAGE MultiParamTypeClasses #-}  instead of {-# OPTIONS_GHC -fglasgow-exts #-}
11:34:33 <lispy> Oh
11:34:36 <lispy> pretty
11:34:46 <bringert> monochrom: well, I'm not sure it actually is fine grained
11:34:52 <monochrom> It is currently newly introduced by GHC but the hope is that since it's so nice other compilers will adopt it and it becomes portable.
11:34:57 <Igloo> monochrom: That just turns on -fglasgow-exts currently
11:35:09 <lispy> monochrom: about {-# LANGUAGE Haskell' #-} ?
11:35:13 <monochrom> -_-
11:35:14 <lispy> er what about
11:35:44 <lispy> bringert: i have some code which doesn't type to ensureDB, if you have time i would like you to look at it, email is best?
11:36:13 <monochrom> OK but you know what, whenever I write -fglasgow-exts I add a comment that says "this is for multiple parameter type class".  May as well say it in code.
11:36:22 <bringert> lispy: I'm not sure if I have time, but I can give it a quick glance. email is good
11:36:36 <shapr> jiihaa
11:36:39 <monochrom> It is the same reason we like static strong typing.
11:36:46 <lispy> bringert: okay, it will come your way, if you don't get to it for n days where 3 < n < 10 then that's okay
11:36:52 <monochrom> shapr: it's spelt "jihad"
11:36:57 <shapr> nuhuh
11:37:11 <shapr> In Swedish the j is spoken like a y in English, so that's Swedish for "yeehaa"
11:37:11 <Igloo> monochrom: Yeah, adding separate flags is fairly high up my todo list
11:37:24 <monochrom> jiihaa
11:37:26 <bringert> lispy: less than 3 is not ok?
11:37:26 <Igloo> At least partly because I'm fairly sure half my cabal package extension lists are wrong
11:37:27 <shapr> right!
11:37:40 <lispy> bringert: well, i won't notice
11:37:51 <lispy> bringert: won't look at it till the weekend :)
11:38:06 <bringert> I'll probably get to it next week
11:38:15 <bringert> unlss it's really easy
11:39:35 <bringert> I'm getting married on Saturday
11:39:44 <jgrimes_> :O
11:40:09 <shapr> congrats bringert!
11:40:19 <bringert> thanks shapr
11:40:27 <shapr> You better put at least a coupla pix online in your halbum =)
11:40:39 <jgrimes_> bringert: congratulations :)
11:41:15 <araujo> bringert, a lambda weeding?
11:41:16 <bringert> shapr: I've been meaning to set up a personal blog, but I haven't gotten around to it
11:41:48 <bringert> araujo: what would that be? something with abstraction?
11:41:54 <araujo> bringert, haha
11:42:57 <swiert> bringert: Many congrats!
11:43:09 <bringert> lispy: ah, I think I know. I gave you a bad type signature
11:43:15 <lispy> bringert: congrats!
11:43:19 <bringert> swiert: thanks!
11:43:27 <lispy> bringert: but catch dictates a bad type...
11:43:28 <bringert> swiert actually knows my wife to be
11:43:32 <swiert> I didn't know you and Angela were tying the knot.
11:43:38 <lispy> bringert: unless we can catch just the db exception (my preferred approach)
11:43:55 <bringert> lispy: try ensureDB :: Database -> (Database -> CGI a) -> CGI a
11:44:10 <bringert> and use catchCGI or whatever I called it
11:44:11 <lispy> bringert: how do you lift the catch?
11:44:22 <lispy> but will catchCGI catch a db exception?
11:44:40 <bringert> yeah, it catches any exception in the cgi monad
11:44:40 * lispy makes a note to try it
11:44:44 <lispy> Ah
11:45:00 <lispy> bringert: so far i don't have a good way to test this either, thore than to wait for the problem
11:45:18 <bringert> lispy: restart the mysql server while the fcgi is running
11:45:52 <bringert> swiert: we were planning to for a while, but we set a time pretty recently
11:46:56 <bringert> lispy: the catch should maybe print a log message
11:47:12 <lispy> bringert: right, but i can't test that :(
11:47:20 <lispy> bringert: my apache won't log when using fcgid
11:47:28 <bringert> oh
11:47:35 <bringert> write to a file then
11:48:09 <lispy> i could try that
11:48:19 <lispy> hopefully do that this weekend
11:48:23 <bringert> appendFile is nice
11:48:24 <lispy> while you're getting hitched ;)
11:48:49 <swiert> bringert: Ok - I didn't even know you guys were engaged...
11:48:55 <swiert> I was feeling a bit stupid.
11:49:00 <bringert> lispy: I get married, you write to log files
11:49:05 <bringert> swiert: why?
11:49:13 <swiert> "unattentive to my environment" Daan would say.
11:49:30 <swiert> Any honeymoon plans.
11:49:30 <bringert> I don't think daan should say that...
11:49:46 <bringert> angela will go to a workshop
11:49:48 <bringert> :-)
11:50:15 <monochrom> clever
11:50:35 <swiert> When did you set the date?
11:50:42 <bringert> the glamourous lifr of the phd student...
11:50:47 <monochrom> See, someone should plan their honeymoon to coincide with ICFP...
11:51:04 <bringert> swiert: not sure, early september
11:51:10 <bringert> Ibefore icfp
11:51:16 <bringert> I think
11:51:20 <bringert> :-)
11:51:58 <bringert> swiert: how's life back home?
11:52:15 <swiert> bringert: busy.
11:52:22 <swiert> I have a deadline tomorrow...
11:53:08 <bringert> swiert: so you hang ouy on irc instead...
11:53:10 <bringert> out
11:53:37 <swiert> bringert: actually I use irc to communicate with my co-authors.
11:53:40 <swiert> :)
11:53:45 <bringert> ah
12:08:04 <roconnor> ndm: this dictionary-free type class implemenation reminds me of jhc
12:08:08 * roconnor still reading
12:13:46 <ndm> whenever i start haskell IRC i get a message:
12:13:50 <ndm> [ERROR]	You need to be an operator in #haskell to do that.
12:14:03 <ndm> any idea what i am doing? Using Chatzilla
12:14:24 <ndm> I get one error message for each of the haskell channels i join
12:14:47 <roconnor> ndm: this dictionary-free type class implemenation reminds me of jhc
12:14:57 <roconnor> but I'm not done reading
12:15:01 <ndm> roconnor: yep, reminds me of that too
12:15:23 <ndm> roconnor: in fact, i am pretty sure that Jhc's is equivalent, but passing types at runtime - so has slight differences
12:15:37 <ndm> but plus some standard optimisations probably results in the same thing
12:16:54 <ndm> roconnor: i should probably point you at Catch as well
12:16:56 <ndm> @where Catch
12:17:15 <roconnor> Now that system Fw has been replaced, GHC can probably do a dictionary-free passing too ... I think
12:17:17 <ndm> Lambdabot says: http://www-users.cs.york.ac.uk/~ndm/projects/catch.php
12:17:30 <ndm> http://www-users.cs.york.ac.uk/~ndm/downloads/paper-a_static_checker_for_safe_pattern_matching_in_haskell-future.pdf
12:17:47 <ndm> roconnor: that paper, ignore all but the Core language, which is what I will be using - in particular take a look at path's
12:17:52 <roconnor> ndm: oh man, i forgot you are also the author of hoogle.
12:17:58 <ndm> paths/selectors (can't remember my terminology)
12:18:02 <ndm> yep :)
12:18:18 <SamB> ndm: does chatzilla have a "raw log" feature?
12:19:09 <ndm> SamB, yes, just found it - will turn that on and see what it says
12:19:31 <roconnor> hoogle is so amazing.  I only wish whelp were that good.
12:19:48 <roconnor> whelp is the equivalent search engine for coq
12:19:51 <ndm> roconnor: wait til Hoogle 4, it totally kicks Hoogle 3 to the curb :)
12:20:06 <roconnor> but right now whelp just gives me SQL errors.
12:20:22 <SamB> ndm: on recycling day or on trash day?
12:20:38 <ndm> SamB, trash day :)
12:37:44 <sylvan> I'm trying to find a good random number generator with the following properties: Very fast, uses very little memory, and most importantly, has fairly uniform distribution (this is for visual stuff, so it just needs to "look" uniform if you plot 10k points or something)... I don't care about period length... Suggestions?
12:38:02 <therp> hm what about the usual mersene twister?
12:38:19 <monochrom> the Random module
12:38:20 <sylvan> uses a bunch of extra memory though?
12:38:26 <therp> s/mersene/mersenne/
12:39:31 <sylvan> what does the Random module use?
12:41:05 <Cale> Probably a modulo generator
12:41:38 <Cale> and some system entropy to get a seed, I think
12:42:08 <monochrom> I don't know what it uses.  But I know how to test it for the criteria you have listed.
12:43:24 <Cale> You can easily use the System.Random interface and plug in a new type of generator later if the existing one doesn't suit you.
12:43:49 <sylvan> sorry, this is not Haskell related, but this channel tends to drift off into general CS discussions every now and then and people here know a lot of stuff so I thought I'd give it a shot. This will be implemented on very tight resources, so my main requirements is "very few ALU ops, very little memory".
12:43:53 <Cale> You just have to implement the RandomGen class for your new generator
12:44:14 <sylvan> I'll stop hijacking the channel now!
12:44:46 <Cale> So I'd probably use StdGen until I discovered that was inadequate.
12:44:50 <Cale> (In Haskell, at least)
12:45:50 <Cale> http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
12:46:18 <Cale> You could implement that if you're using another language which doesn't have a reasonable random number generator in its library.
12:46:43 <Cale> (or you need an exceptionally long period)
12:46:48 <monochrom> linear shift register
12:47:19 <monochrom> linear shift register may be faster than linear congruential (most popular) because of bitwise operations instead of divisions.
12:47:34 <sylvan> I am, HLSL, with some extensions (XBox360 hardware), hopefully I'll find something with "visually pleasing" random numbers that can be generated quickly, but with a very short period or something (>100000 is enough for me)
12:48:20 <monochrom> XBox360 has tight resource?  I thought the ads said "the most powerful computer in the world!"  :)
12:48:45 <shapr> Yeah, but it runs Windows XB
12:48:47 <dolio> Nah, man, those are playstations.
12:48:48 <monochrom> Gosh do you ever know the truth until you program...
12:48:54 <dolio> Export controlled because they're supercomputers!
12:49:22 <sylvan> monochrom, yeah but it needs to be faster than just reading it from a texture :-)
12:49:36 <shapr> Speaking of which, I wish Sony would sell PS3s without that stupid DRM and hypervisor protection.
12:50:07 <shapr> Like, sell me a PS3 WITHOUT the HD/Blu-thingy
12:50:35 <Cale> x_(n+1) = (a x_n + b) mod m, where a = 1664525, b = 1013904223 and m = 2^32.
12:50:51 <yip> sylvan: can you do shader programs in raw assembly on xbox 360, or do you have to use HLSL?
12:51:06 <sylvan> yip, you can more than that, you can code micro instructions!
12:51:12 <monochrom> I still like my linear shift register idea
12:51:16 <sylvan> asm is too high level man!
12:51:24 <yip> sylvan: hm.... what?
12:51:26 <roconnor> ndm: what do I want to read about catch?
12:51:31 <monochrom> @remember sylvan asm is too high level man!
12:51:41 <Cale> sylvan: try that :)
12:51:50 <sylvan> monochrom, so that's my legacy? Dammit!
12:51:56 <ndm> roconnor: the core language, in particular the path/sel stuff
12:52:05 <ndm> roconnor: give me a sec and i'll tell you which sections
12:52:09 <sylvan> anyway, monochrom, I tried googling for linear shift registers in relation to random numbers and came up blank..
12:52:22 <sylvan> Cale, will do!
12:52:31 <Cale> sylvan: it's not terribly great
12:52:50 <Cale> sylvan: but if you're just using it for visual effects, it should be okay, I think
12:52:53 <monochrom> OH!  linear feedback shift register
12:53:13 <yip> sylvan: you are going to be doing >100000 iterations in a shader program?
12:53:15 <ndm> roconnor: section 1.2 only
12:53:23 <ndm> (of course, feel free to read it all ;)
12:53:24 <sylvan> it should be fairly uniform, which is the main thing I'm worried about
12:53:43 <ndm> roconnor: that is essentially my Core language for my new compiler
12:53:50 <sylvan> yip, maybe I'll run 100000 vertices through them and feed in the index as seed?
12:53:56 <Cale> one thing about it which is bad is that it produces alternately odd and even results.
12:54:14 <Cale> but that may not matter so much :)
12:54:18 <sylvan> Cale, yeah that doesn't bother me too much.
12:54:34 <sylvan> This will end up in a floating point (0..1) range anyway
12:56:11 <shapr> musasabi: ping
12:57:02 <Cale> sylvan: http://en.wikipedia.org/wiki/List_of_pseudorandom_number_generators
12:57:12 <sylvan> thanks
13:00:50 <musasabi> shapr: pong
13:03:17 <shapr> musasabi: I'm confused about how users works. Starting from a more basic level, session keeper holds stateful information per connection?
13:03:49 <musasabi> shapr: no not related to connections. Have you looked at examples/user.hs ?
13:04:33 <shapr> Yes, I've hacked around on it, but I don't understand what the returned number means.
13:05:13 <musasabi> number?
13:05:32 <shapr> When I GET sk/$NUMBER I can see the username and password, but I'm not sure how I would use that to implement something like "You are logged in as $USER" at the bottom of wiki pages.
13:06:13 <musasabi> shapr: the number is just the key for the session. You are free to store it in any way you want for the client (either URL or cookie work fine)
13:06:25 <shapr> oh
13:07:43 <musasabi> you probably want a "data WikiUser" and then use "Users WikiUser"
13:08:07 <musasabi> with WikiUser containing the information you want to store about users.
13:09:49 <xerox> What if ones trasposes the isomorhism between code and data (a-la lisp) to code and types?
13:10:29 <shapr> Then you get Oleg
13:10:49 <xerox> And xerox was illuminated.
13:11:26 <SamB> do you mean "achieved enlightenment"?
13:12:10 <xerox> Right.  I read those zen stories in in Italian, sorry.
13:14:16 * CosmicRay still trying to figure out how to write a link to newProgress' in haddock
13:14:21 <CosmicRay> 'newProgress\'' doesn't seem to work
13:14:25 <CosmicRay> even though the docs imply it would
13:14:27 <CosmicRay> any ideas?
13:14:33 <SamB> xerox: hehe
13:14:50 <SamB> it was understandable, but it wasn't the usual turn of phrase ;-)
13:17:06 <shapr> CosmicRay: You think any publisher would be interested in a real consumer level Haskell book? I'm thinking about haskell-v8 and wondering...
13:17:26 <CosmicRay> shapr: I don't know.  it's still pretty niche
13:17:38 <monochrom> Is haskell-v8 a drink?
13:17:38 <CosmicRay> I've been thinking that if I ever get the time, I'd start over on a manuscript and see where I get it
13:17:46 <CosmicRay> then I could either shop it around or publish it myself
13:17:51 <CosmicRay> monochrom: http://darcs.complete.org/haskell-v8
13:18:01 <CosmicRay> a on-again, off-again attempt to write  better haskell tutorial
13:18:23 <roconnor> ndm: you specialize away higher-order functions!
13:18:26 <shapr> It's pretty cool to see your name on this Linux book, and I realize I'd really like to see my name as coauthor on a Haskell book of this sort :-)
13:18:32 <int-e> consumer level? learn haskell in 30 days? haskell for dummies?
13:18:41 <ndm> roconnor: yep :) - i do much more than that in the new version
13:18:49 <ndm> roconnor: but yes, its an extension of that
13:18:51 <roconnor> ndm: you are crazy! :)
13:18:59 <ndm> roconnor: yep :)
13:19:03 <araujo> Haskell on 24hrs. (including monads!)
13:19:21 <roconnor> how does that work with Cont Monad.
13:19:34 <shapr> CosmicRay: btw, congrats on fatherhood :-)
13:19:35 <ndm> probably not that well, but for most stuff it works quite well
13:19:53 <ndm> and i can fall back to Reynolds Style defunctionalisation where it doesn't work
13:20:04 <CosmicRay> shapr: thanks!
13:20:36 <monochrom> v8 is an allegory to a powerful engine?
13:21:06 <monochrom> "Haskell - the V8 of Computer Programming"
13:21:42 <shapr> PHP - the rotary 3 cylinder engine of computer programming.
13:21:56 <CosmicRay> monochrom: yup
13:21:56 <CosmicRay> monochrom: it's sort of like my free software magazine article... where I said Haskell manipulates functions as easily as perl manipulates strings ;-
13:21:57 <CosmicRay> shapr: haha
13:22:00 <araujo> Be careful, V8 got too many criticism too :-P
13:22:27 <shapr> I'd rather use a Stirling engine.
13:22:41 <araujo> unicycle!
13:22:44 <CosmicRay> araujo: don't worry, haskell is environmentally friendly!  frewer discarded caffeinated beverage cups because programmers don't have to work so late into the night!
13:22:58 <araujo> CosmicRay, yay!
13:23:03 * roconnor is having a bad Haskell week
13:23:12 * CosmicRay is hacking on missingh this week.
13:23:19 <araujo> CosmicRay, i like caffeine though ...
13:23:21 * shapr is hacking on HAppS
13:23:29 <CosmicRay> I'm writing a generic progress tracker module.  the sort of thing that can give you an estimated time remaining on a large job.
13:23:30 * araujo hacking on ghci
13:23:38 <CosmicRay> then I will update hpodder to be multithreaded.
13:23:40 <monochrom> I think real programmers bring their own ceramic coffee mugs
13:23:48 <CosmicRay> shapr: I have actually been getting patches for hpodder from people.
13:23:55 <araujo> well, if screwing up the ghci code with some extra features can be called hacking that is it
13:24:01 <CosmicRay> I think 2 people have decided that they better start learning haskell because of it.
13:24:05 <CosmicRay> which I totally didn't expect.
13:24:07 <shapr> musasabi: So, does session keeper hold state local to a particular IP or what?
13:24:10 <shapr> CosmicRay: wow!
13:24:25 <monochrom> What is hpodder?
13:24:26 * glguy has two ceramic coffee mugs on his desk in case of emergencies!
13:24:32 <CosmicRay> monochrom: a podcast downloader
13:24:36 <CosmicRay> monochrom: written in haskell
13:24:48 <monochrom> nice
13:25:13 <SamB> to think that a non-haskellite would use such a thing!
13:25:28 <CosmicRay> monochrom: it follows CosmicRay's rule of a useful tool: do one thing, do it well, and do it simply.
13:25:44 <CosmicRay> geez, I should go work for Apple if I didn't think that do it simply means give it an intuitive command-line interface ;-)
13:25:56 <CosmicRay> http://darcs.complete.org/hpodder/doc/hpodder.pdf
13:26:14 <shapr> Hey, have you seen bringert's hask-home ?
13:26:35 <CosmicRay> OOOOOOOOOO!!!!!!!!
13:26:38 <CosmicRay> That is WHAT I NEED!
13:26:49 <CosmicRay> I hate releasing software.
13:26:59 <CosmicRay> if I'd get off my lazy ass, I'd blog about how much I hate releasing software.
13:27:14 <monochrom> You could podcast your software instead.
13:27:15 <SamB> is it a service that releases your software automatically at random intervals?
13:27:16 <CosmicRay> you get the code done, and packaged up, and then dammit, it's another 15 minutes of work to update webpages, freshmeat, etc.
13:27:33 <CosmicRay> SamB: nono, please don't confuse it with Windows Update
13:27:39 <dima_> hmm, during my C++ months I fully forgot the basics of Haskell :>
13:27:40 <SamB> heh
13:27:57 <SamB> when else would an automated release service do releases?
13:27:57 <CosmicRay> dima_: think lazy and it'll all come back ;-)
13:28:12 <CosmicRay> SamB: when I run "hrelease" or whatever
13:28:13 <monochrom> OK, so what's the solution?
13:28:13 <dima_> CosmicRay, nah, I even forgot how to define data types :)
13:28:17 <roconnor> ndm: I suppose you believe that disk space is cheap. :)
13:28:17 <SamB> think "templates that don't have such odd syntax"
13:28:32 <CosmicRay> it should see from my project what the version number is, where the website is, and upload it everywhere it needs to go, announce it everywhere it needs to be announced, etc.
13:28:38 <ndm> roconnor: i take it you haven't got to the end of the Mark Jones paper?
13:28:48 <ndm> roconnor: my .exe's are always smaller than GHC's
13:29:06 <CosmicRay> ESR wrote something like that, but it's tied to RH, and since ESR wrote it, has a 20-page manual but does almost nothing
13:29:06 <monochrom> Soon you'll hate writing software too.  You will then create "hprogrammer"...
13:29:10 <CosmicRay> hehe
13:29:24 <CosmicRay> someone on /. was predicting that computers would write programs within 20 years.
13:29:38 <roconnor> ndm: even with so many copies of map?
13:29:38 <CosmicRay> I don't know.  imagination is hard to replicate.
13:29:40 <monochrom> He's optimistic.  I'm giving it 50 years.
13:29:48 <ndm> roconnor: yes
13:29:57 <CosmicRay> computers can do science, but asking a computer to do art...  well, that's not so easy.
13:30:05 <CosmicRay> and I think that programming is at least as much an art
13:30:16 <monochrom> Don't replicate imagination.  Beat it.  Use Moore's Law and exhaustive search to beat human creativity.
13:30:38 <SamB> first, write the program to keep moore's law true!
13:30:41 <CosmicRay> it is like music -- highly mathematical and yet expressive beyond pure math
13:31:32 <monochrom> Humans never improve --- actually dumbing down.  Computers always become faster and cheaper.  There is a crossing point.
13:31:52 <roconnor> ndm: how does that happen?
13:32:00 <SamB> I have yet to see one that is what I would call "smarter"
13:32:35 <ndm> roconnor: each map is smaller than, i manage to eliminate loads of unneeded stuff (dictionaries and other bits), and there aren't that many higher order uses, and i generate small code
13:32:38 <CosmicRay> monochrom: I don't think humans are dumbing down, though I grant you that western TV is
13:32:47 <CosmicRay> monochrom: but even so, fast doesn't equal intelligent
13:32:50 <monochrom> No, will never be smarter.  But who needs to be smart?
13:33:03 <ndm> roconnor: i don't have enough detailed measurements to prove that claim though, but for sample programs 50Kb (me) vs 1Mb (GHC) is typical
13:33:05 <CosmicRay> and fast doesn't equal imaginative
13:33:12 <roconnor> ndm: you should try compiling FewDigits.
13:33:14 <SamB> Americans watch too much TV and are therefor DUMB. (On average.)
13:33:28 <ndm> roconnor: what is that?
13:33:39 <xerox> monochrom is a computer.
13:33:42 <glguy> CosmicRay: western tv? as opposed to the high quality japanese shows? :)
13:33:46 <CosmicRay> in a world where everyone was told that the world was flat, and say that you programmed a 1500s-era computer with a physics model based on your world view, how would you expect the computer to have the imagination to conclude that the world is round?
13:33:47 * monochrom is a computer
13:33:48 <roconnor> well, I don't really have a program to go with the library.
13:33:58 <ndm> roconnor: will probably be a while yet
13:34:02 <roconnor> http://r6.ca/FewDigits
13:34:09 <SamB> glguy: at least in those shows the people look like people!
13:34:16 <xerox> ?remember monochrom * monochrom is a computer
13:34:23 <roconnor> I represent real numbers as a function
13:34:32 <roconnor> so all operations on real numbers are higher order.
13:34:51 <xerox> How does it work to represent real numbers as functions?
13:35:00 <ndm> roconnor: probably not very well, but we'll see
13:35:10 <monochrom> I represent natural numbers as functions, and real numbers as functions over natural numbers.  I'm higher-order than thou!
13:35:11 <xerox> 5  ~~>  const  5 ?  :)
13:35:32 <roconnor> fix 5
13:35:42 <SamB> > fix 5
13:35:46 <xerox> Type error?
13:35:59 <SamB> not precisely
13:36:01 <roconnor> cannot unify Int with Int -> Int
13:36:07 <SamB> more of a "missing instance" error
13:36:12 <roconnor> oh
13:36:19 <xerox> Instance!?
13:36:25 <int-e> No instance for (Num (a -> a))
13:36:25 <SamB> also a "missing lambdabot" error
13:36:38 <xerox> Ah-ha.
13:36:49 <xerox> But alright, what do you mean, anyway, roconnor?
13:37:13 <roconnor> what do I mean about what?
13:37:25 <xerox> "Representing real numbers as functions."
13:37:47 <roconnor> well there are a contiuum number of functions.
13:37:49 * monochrom writes a Prelude based on Church numerals...
13:37:57 <roconnor> so it is natural to represent real numbers with functions.
13:38:13 <monochrom> Yeah the cardinality is just right.
13:38:21 <xerox> Beats me.
13:38:26 <SamB> it depends on the type of the functions!
13:38:40 <roconnor> Say Rational -> Rational for example.
13:38:46 <roconnor> That's what I use
13:38:48 <SamB> there are only four complete functions Bool -> Bool, for instance
13:38:53 <monochrom> A real number can be represented by a Cauchy sequence.  A sequence is a function...
13:38:58 <roconnor> but Integer -> Integer could work too.
13:39:11 <xerox> I have heard of Cauchy sequences.
13:39:26 <monochrom> A Cauchy sequence of rationals.  Nat -> Rational
13:39:40 <xerox> Right.  /me investigates more
13:39:47 <roconnor> that is a common choice of representation
13:39:52 <int-e> you could use lists, hmm.
13:40:02 <xerox> The definition seem short enough.
13:40:08 <monochrom> with some requirement on the rational numbers participating in the sequence, so you'll need smart constructors to preserve the invariant too.
13:40:11 <roconnor> int-e: another common choice
13:40:46 <xerox> What requirement?
13:40:47 <roconnor> monochrom: smart constructors are sort of useful, but the condition is undecidable :(
13:41:11 <roconnor> monochrom: so you either only allow a subset of reals, or allow an unsafe constructor.
13:41:22 <xerox> Yuck!
13:41:22 <roconnor> xerox: the requirement that the sequence converge.
13:41:46 <SamB> how do you test the conversion of a function to which you do not have the source code?
13:41:50 <monochrom> forall e>0. exist N. forall m>N, n>N. abs(f m - f n) < e
13:41:53 <SamB> er, convergence
13:42:08 <roconnor> monochrom: usually fast converging cauchy sequences are used
13:42:54 <xerox> What are examples of such sequences that respect that theorem?
13:42:58 <monochrom> Can't test for convergence.  But you can export the smart constructors only, so that all functions created are convergent by construction.
13:43:40 <monochrom> 1, 1.4, 1.41, 1.414, 1.4142, ...  converges to sqrt(2)
13:43:40 <roconnor> forall n m. abs (f m - f n) < 1/m + 1/n, for example, or forall n m. abs (f m - f n) < 2^^-m + 2^^-n is more common.
13:44:06 <xerox> Interesting!
13:44:36 <monochrom> Theorem:  In R, Cauchy sequences = convergent sequences.
13:44:57 <roconnor> monochrom: but no set of smart constructors will allow all convergent sequences.
13:45:30 <monochrom> Oh haha but on a computer you just need computable real numbers anyway.
13:45:48 <roconnor> monochrom: same problem still applies.
13:45:59 <xerox> hehe
13:46:02 <SamB> monochrom: do you have a test for computability?
13:46:11 <int-e> you'd have to embed all methods of proving convergence in the logic provided by your smart constructors
13:46:21 <monochrom> No Turing-computer can allow all real numbers.
13:46:43 <xerox> What a choice to call it real.
13:46:49 <roconnor> No physical object can allow all real numbers.
13:47:01 <xerox> Your brain?
13:47:17 <roconnor> xerox: I'm dumber than a turning machine.
13:47:18 <SamB> duh no
13:47:19 <monochrom> Hmm I don't know about physical objects.  Time looks real so far.  Of course we may be surprised later.
13:47:25 <SamB> brain can only remember a few digits
13:47:26 <roconnor> Turing
13:47:28 <roconnor> see
13:47:49 <xerox> haha
13:47:54 <Cale> Not all real numbers are definable, in the sense that there are more real numbers than there are logical expressions which can specify particular real numbers.
13:48:01 <xerox> @remember roconnor <roconnor> xerox: I'm dumber than a turning machine.
13:48:12 <roconnor> ha
13:48:14 <roconnor> no lambdabot
13:48:20 <SamB> turning machine aka lathe?
13:48:22 <xerox> I'll add it later.
13:48:27 <roconnor> damn
13:48:59 <SamB> @tell dons to reboot lambdabot ;-P
13:49:02 <xerox> So times looks real.
13:49:27 <roconnor> arguably we need to add the partial real numbers.
13:49:50 <SamB> but time could just have infintesimal quanta!
13:50:24 <Cale> How do we know that time isn't better modeled by the rational numbers? We really don't, it's just convenient to use real numbers because they have nice properties analytically.
13:50:44 <monochrom> I would rather integrate than sum.
13:50:49 <xerox> I think I noticed a paper some time ago, it was about reconsidering wether one *really* needs the real numbers in most situation.  It was interesting.
13:51:27 <Cale> The real numbers become extremely important once you start talking about sets of numbers.
13:51:30 <monochrom> Yes, it's actually a lazy overkill choice most of the time.
13:51:32 <roconnor> yeah my friend was talking about a book/paper titled something like: Physics without numbers.
13:51:40 <Cale> They're not very important before that.
13:51:45 <xerox> hehe, discordant opinions.
13:52:26 <xerox> @google physics without numbers
13:52:34 <Cale> Every set of real numbers which is bounded above has a least upper bound.
13:52:36 <xerox> Hrrrrrmmmpff.
13:52:47 <Cale> That's really the statement which sets the reals apart from the rationals.
13:53:00 <Cale> (or one of a bunch of equivalent ones)
13:53:17 <xerox> And what is this least upper bound that ever exist?
13:53:29 <Cale> another real number :)
13:53:36 <monochrom> Depends on the set in question.
13:53:48 <xerox> But it ever exists.
13:54:02 <xerox> Sorry for the question, but why?
13:54:06 <Cale> Consider the set of rational numbers x such that x^2 < 2
13:54:43 <monochrom> Suppose you have to define sqrt(2) using rational numbers and axioms.  Cale steals my thunder but it's lub{ x | x^2<2 }.
13:54:44 <Cale> In the set of rational numbers, this set is bounded above, for instance, 2 is greater than every element of that set.
13:55:01 <Cale> But there is no least upper bound.
13:55:13 <Cale> You can find smaller and smaller ones.
13:55:22 <nomeata> Hi. Is there a way to re-open the stdout channel?
13:55:33 <xerox> Cale: I am familiar with that, at least so far.
13:55:50 <monochrom> Not that I know of, nomeata.
13:55:53 <roconnor> Cale: The LUB principle isn't recursively realized.
13:56:03 <xerox> And I have the vague idea that you actually use this "(dedekind?) cuts" to *define* those numbers.
13:56:07 <Cale> roconnor: hm?
13:56:08 <monochrom> But who cares about stdout?  Join us for a discussion of the real numbers!
13:57:02 <Cale> xerox: yeah, the Dedekind cuts approach to defining reals is probably my favourite way (at least, for the concrete constructions)
13:57:24 <xerox> Those cuts are cute.  But what happens next?
13:57:50 <roconnor> Cale: given a predicate on a set of recursive reals, the lub isn't always a recursive real. ... although I haven't seen the proof.
13:57:54 <Cale> (more specifically, I like this one: http://planetmath.org/encyclopedia/DedekindCuts.html which is a simplified version of the way Dedekind really did it)
13:57:57 <xerox> (Random question, can you define pi as a dedekind cut?)
13:58:00 <monochrom> So, if you want to define sqrt(2) by cut:  { x | x^2<2 }, {x | x^2 >= 2}
13:58:06 <Cale> roconnor: right
13:58:37 <roconnor> I have a blog post:  How Dedekind Screwed Up a Hundred Years of Mathematics
13:58:39 <xerox> I was on planetmath as we were talking, adds to the tabs.
13:58:45 <Cale> roconnor: hm?
13:58:47 <monochrom> pi is a lot of tedium if you want to get to the level of cuts.
13:59:07 <xerox> I'm satisfied with that answer for now.
13:59:10 <roconnor> http://r6.livejournal.com/74079.html
13:59:17 <xerox> As I don't like tedium :)
13:59:26 <monochrom> I would cut corners and establish infinite series and then pi as an infinite series.
13:59:38 <Cale> I'd define integrals :)
13:59:39 <nomeata> well, with re-opening stdout I meant making it all go to a file
13:59:47 <monochrom> Oh!  Yeah integrals instead.
13:59:55 <xerox> Integrals.  Again this night :)
13:59:55 <roconnor> Cale: although it isn't about his cuts
14:00:02 <Cale> pi = 2 * (integral from -1 to 1 of sqrt(1 - x^2) dx)
14:00:21 <ndm> roconnor: i saw your blog post, and commented :)
14:00:21 <monochrom> But anyway pi as a cut is like Parsec as GHC core.
14:00:42 <roconnor> Actually cauchy reals and dedekind reals are two different notions of reals.  both are useful in different places
14:00:56 <Cale> They're completely equivalent though.
14:01:12 <Cale> In fact, the usual way I think of the reals is just as a complete ordered field.
14:01:21 <xerox> Isn't there a theorem about that?
14:01:30 <Cale> and one can prove that any two complete ordered fields are isomorphic
14:01:36 <xerox> That one.
14:01:46 <roconnor> Cale: they are not recursively equivalent.
14:01:54 <integral> Can you prove one exists without using one of those constructions?
14:01:55 <monochrom> Oh haha.  Another cheap analogy.  cauchy and dedekind are like ghc and jhc
14:01:59 <Cale> So in some sense, the actual construction one uses is completely irrelevant
14:02:07 <xerox> monochrom: wow :)
14:02:19 <roconnor> Cale: don't forget archemedian.
14:02:31 <prj> hm... could anyone help me with this? http://nopaste.php-q.net/246318
14:02:32 <Cale> Nope, that's implied by the rest.
14:02:37 <xerox> Cale, but I believe it is *very* good to have one.
14:02:41 <monochrom> You have "Haskell" and then you have several implementations of "Haskell" demonstrating that the specification is realizable.
14:02:57 <Cale> If you have a nonarchimedean ordered field, it's not complete.
14:03:05 <SamB> also that maybe the recursive modules are a bit much work
14:03:10 <xerox> monochrom: not so cheap, this analogy, then!
14:03:20 <Cale> monochrom: exactly.
14:03:27 <sylvan> Speaking of JHC... I'm intrigued by the concept of region inference, but haven't really found any information about it. I've seen regions with user annotations, but not how inference works. Anyone happen to have a good resource on that?
14:03:32 <roconnor> Cale: it's implied!
14:03:34 <roconnor> hmm
14:03:45 <roconnor> maybe it isn't implied constructively....
14:03:46 <sjanssen> prj: are you intentionally using the list monad?
14:03:50 <glguy> prj: you are using "return" when you shouldn't be
14:04:03 <SamB> sylvan: is that even implemented yet?
14:04:05 <glguy> prj: In Haskell, "return" has nothing to do with "return" in C
14:04:07 <prj> my experience with haskell so far is about 5 hours
14:04:12 <prj> aha, interesting
14:04:13 <monochrom> Computer programming has really brought mathematics into light.
14:04:20 * xerox nods
14:04:27 <roconnor> monochrom: !
14:04:30 <sylvan> SamB, the website seems to imply a preliminary version is implemented, but it's not "done" yet... AFAICT
14:04:30 <monochrom> Computer science is a better philosophy than philosophy.
14:04:38 <SamB> sylvan: ah
14:04:58 <SamB> yeah, my philosophy teacher isn't very good at philosophy...
14:04:58 <Cale> I'm about as far from being a constructivist as possible :)
14:05:02 <monochrom> (In the same sense that OS/2 is a better Windows than Windows.)
14:05:20 <monochrom> OK now I'm showing my age.
14:05:23 <SamB> monochrom: it isn't anymore now!
14:05:24 <xerox> hahaha
14:05:31 <Cale> In the sense that I don't care at all which axioms one uses, as long as one is explicit.
14:05:33 <roconnor> Cale: you can't be that far.  You use haskell.
14:05:57 <xerox> You use haskell to please your constructionivistisms?
14:05:59 <Cale> So go ahead and use the axiom of choice if you like it. I happen to enjoy that sort of mathematics myself :)
14:06:10 <glguy> prj: also, it's pretty slow to apend to the end of a list over and over
14:06:16 <SamB> Cale: if I take "the moon is made of cheese" as an axiom... you won't care?
14:06:20 <glguy> prj: if you are doing to do that for large values
14:06:36 <Cale> SamB: right, as long as you're clear that it's an axiom that you're making
14:06:38 <monochrom> It's a very useless axiom.  So what if the moon is edible.
14:06:40 <prj> glguy: not concerned with performance of the thing atm, just trying to learn it.
14:06:47 <glguy> k
14:06:57 <SamB> monochrom: it is very useful for long-term lunar research missions!
14:06:59 <SamB> probably!
14:07:01 <xerox> SamB, yes, as first, and then BREAK your theory in little contradictory pieces.
14:07:16 <prj> glguy: i realize now what i did wrong with return, still it's not working as i want it to, i'd actually just need a list in the form of [1,2,3] from those values.
14:07:17 <roconnor> excluded_middle :: Either a (forall b. a -> b)
14:07:29 <SamB> hmm
14:07:31 <glguy> prj: I'm trying to post a response
14:07:42 <prj> glguy: thanks
14:07:42 <glguy> prj: do notation is only used when working in a monad
14:07:44 <SamB> it is true that an argument must have non-contradictory axioms...
14:08:03 * roconnor starts using excluded_middle in his haskell programs, so long as he is clear that he is using it.
14:08:06 <glguy> prj: can i prvmsg you?
14:08:10 <prj> glguy: sure
14:08:22 <Cale> SamB: no, it can, but it's not interesting if it does
14:08:30 <xerox> roconnor: aren't excluded_middle = Left undefined and Right undefined the same thing?
14:08:37 <Cale> Because if P and not P, then Q, for any statements P and Q.
14:08:37 <SamB> well, okay, so you can't use it to argue anything then
14:08:58 <Cale> (at least in classical logic)
14:09:01 <SamB> and Cale, I'm really not sure I buy that argument.
14:09:09 <Cale> Do you want me to prove it? :)
14:09:16 <SamB> no.
14:09:34 <SamB> because to prove it you'd probably use laws of logic I'm not too sure about either.
14:09:42 <xerox> Let's! :)
14:10:02 <roconnor> xerox: clearly not, a case analysis will show they have different behaviour.
14:10:18 <SamB> so excluded_middle = undefined?
14:10:39 <SamB> or is it the excluded "Middle" constructor for the Either types?
14:10:49 <roconnor> SamB: yes, but not terribly useful now is it. ;)
14:11:08 * roconnor groans
14:11:28 <Cale> Suppose that P and not P. Then if not Q, then surely P. But by contrapositive, that's not P implies Q. Similarly, if not Q, then not P, but by contrapositive, that's P implies Q.
14:11:29 <ski> 'excluded_middle' can be defined in SML/NJ :)
14:11:59 <Cale> Well, actually, you only need one of those :)
14:12:09 <Cale> Suppose that P and not P. Then if not Q, then surely P. But by contrapositive, that's not P implies Q. But not P, so Q.
14:12:35 <SamB> hmm
14:13:07 <roconnor> Cale: what is this contrapositive nonsense ;)
14:13:25 <Cale> (P implies Q) if and only if (not Q implies not P)
14:13:34 <SamB> well, I suppose the really nonsensicle propositon is "P and not P"
14:14:02 <roconnor> contrapositive :: (forall z. a -> z) -> (forall z. b -> z) -> b -> a
14:14:13 * roconnor will start using that in his Haskell too :)
14:14:21 <roconnor> oops
14:14:28 <roconnor> contrapositive :: ((forall z. a -> z) -> (forall z. b -> z)) -> b -> a
14:14:34 <roconnor> higher order to the max!
14:14:36 <Cale> We're not using the same formal logic as type systems like Haskell's do.
14:14:47 <Cale> We're using classical logic.
14:15:07 <Cale> They're both completely relevant.
14:15:08 <ski> fun excluded_middle () : ('a,'a cont) either = callcc (fn k => throw k (Left (callcc (fn ka => throw k (Right ka)))))
14:15:09 <roconnor> :)
14:15:23 <SamB> yeah, Haskell's type system doesn't include "not"
14:15:30 <Cale> right
14:15:49 <SamB> which makes things a lot simpler
14:16:07 <roconnor> ski: wheeee
14:16:08 <SamB> and is also very useful because who knows WTH a value of type "not String" is
14:16:13 <ski> ('excluded_middle' is basically the same as 'is' .. just looked at from another point of view)
14:16:22 <ski> (s/'is'/'id')
14:16:22 <xerox> Yuck.,
14:16:26 <xerox> Phew.
14:16:30 <roconnor> not String = forall z. String -> z
14:16:45 <SamB> heh
14:16:48 <Cale> Well, it wouldn't have a value
14:16:53 <ski> SamB : it's a continuation that accepts a string, of course
14:16:58 <Cale> (we'd hope)
14:17:05 <SamB> Cale: hmm.
14:17:06 <lisppaste2> glguy pasted "collatz" at http://paste.lisp.org/display/27858
14:17:13 <xerox> Hope?
14:17:29 <Cale> Though I suppose that perhaps in some systems, contradictions wouldn't be so bad.
14:17:34 <SamB> so how would the converse function work?
14:17:42 <Cale> SamB: values are proofs of the propositions that types represent
14:17:48 <Cale> String has a proof
14:18:01 <Cale> So we'd sort of hope that not String didn't.
14:18:02 <xerox> Oh that's right.
14:18:03 <SamB> see, this is why there is no "not"
14:18:14 <SamB> because you can't pass around a proof that there are no strings!
14:18:27 <ski> sure you can
14:18:43 <xerox> But they may well be existant some other not-table type.
14:18:43 <SamB> how?
14:18:47 <roconnor> error "there is no spoon" :: not Spoon
14:18:49 <Cale> Well, you can (sometimes) have types which have no values. Just not in Haskell.
14:18:52 <ski> and when you call it on a string, you've discovered a (local) inconsistency, and hence you can derive anything
14:19:07 <xerox> @quote roconnor error "there is no spoon" :: not Spoon
14:19:13 <ski> k :: String -> a , s :: String |- k s :: a
14:19:30 <SamB> heh
14:19:32 <xerox> `|-' is "entails" ^
14:19:33 <xerox> ?
14:19:35 <ski> yes
14:19:50 * SamB emails that to dons
14:19:57 <Cale> In Haskell, every type has at least one value in it, namely bottom.
14:20:03 <roconnor> Cale: in Haskell the type forall z.z comes pretty close to having no values.
14:20:14 <Cale> It still has bottom in it. :)
14:20:15 <roconnor> but yes, there is bottom.
14:20:40 <xerox> Do we need bottom?
14:21:01 <ski> depends on how strong recursion you want
14:21:05 <Cale> Yeah, if we want laziness, bottom is an important case to consider.
14:21:09 <SamB> well, if you want to call it forall# z.z, maybe it won't have bottom
14:21:17 <SamB> or something like that
14:21:43 <SamB> the presence of a # is obligatory for that to be allowable ;-)
14:21:46 <xerox> We could well even have some other kind of recursion?  Weaker?  Stronger?
14:22:08 <ski> weaker
14:22:12 <Cale> You can avoid treating bottom in discussions of strict languages, because once the computation of a value doesn't terminate, you're cooked.
14:22:20 <xerox> I heard of transfinite induction.
14:22:26 <roconnor> Cale: actually coq is lazy and has no bottom.
14:22:57 <SamB> Cale: or terminates badly!
14:23:00 <roconnor> ski is right.  coq doesn't have all total recursive functions.
14:23:06 <Cale> SamB: sure, same thing :)
14:23:15 <Cale> (at least from this perspective)
14:23:19 <SamB> well, "doesn't finish"
14:23:20 <SamB> sure
14:23:34 <xerox> This last thing is stated in the Haskell report I think.
14:23:37 <roconnor> although coq can fake general recursion.
14:23:40 <Cale> Well, sure, you can also reduce the computational expressiveness of your language
14:23:43 <ski> xerox : which ?
14:24:04 <ski> roconnor : nontermination monad ?
14:24:05 <xerox> Finish badly as undefined
14:24:12 <roconnor> ski: that's right
14:24:17 <xerox> A paragraph on "error" I think
14:25:08 <Cale> It seems to me that coinduction is just a special case of transfinite induction
14:25:32 <xerox> Wow.  I had a try with edwinb at AngloHaskell to explain to me coinduction.
14:26:19 <roconnor> Cale: I don't think I'd say that.
14:26:37 <roconnor> co-induction doesn't (always) terminate like transfinite induction does.
14:26:43 <Cale> You're just using a peculiar ordering on your set.
14:26:56 <Cale> What do you mean by "terminate"? :)
14:26:57 <xerox> What I gathered is that an inductive type constructs, and a coinductive one always let you rely on the presence of a type constructor.
14:27:22 <Cale> transfinite induction works on orders isomorphic to omega or, well, any ordinal :)
14:28:09 <roconnor> Cale: I mean after a finite number of reduction, there are no more reductions.
14:28:15 <Cale> reductions?
14:28:24 <roconnor> Cale: any decreasing sequence of ordinals is finite.
14:29:00 <roconnor> Cale: reductions, steps, whatever you want to call it.
14:29:20 <roconnor> er yes, plural.
14:29:39 <ski> (having continuations without (some form of) linearity will probably make a language impure, btw)
14:30:16 <SamB> ski: what you say? Cont done right is impure?
14:30:27 <SamB> (or wrong, for that matter?)
14:30:39 <ski> no, done right, it shouldn't be, i believe
14:30:51 <roconnor> SamB, continuations are done wrong in ML, they have the wrong type :)
14:31:01 <ski> roconnor : in what sense ?
14:31:14 <roconnor> Cont r a = ((a->r)-r).
14:31:23 <ski> that's wrong
14:31:34 <ski> that's the continuation monad (different thing)
14:31:35 <roconnor> is it?
14:31:42 <roconnor> how so
14:31:56 <SamB> the continuation monad is different from continuations how?
14:32:00 <ski> that is more or less double negation (wrt 'r', here)
14:32:12 <roconnor> xerox: coinduction is easy:  x = 1:x. tada
14:32:21 <SamB> ... Haskell not support negation!
14:32:23 <Cale> roconnor: I'm saying that for any instance of coinduction, it's possible to well order your values such that induction will apply to them.
14:32:23 <ski> 'a -> r' there corresponds to a "continuation"
14:32:30 <xerox> roconnor: and why isn't that induction?
14:32:31 <SamB> oh
14:32:52 <edwardk> samb: how do you mean it doesn't support negation?
14:32:54 <Cale> roconnor: that's corecursion
14:33:02 <roconnor> xerox: because there is no decending measure on the recursion.
14:33:03 <ski> SamB : think : replace 'r' by '_|_' ("absurd" formula)
14:33:05 <edwardk> samb: T -> _|_ is ~T logically
14:33:06 <SamB> edwardk: have you seen a "not" typefunction lately?
14:33:21 <edwardk> if you want to think of the type system as a logic.
14:33:27 <SamB> oh.
14:33:27 <Cale> roconnor: hm?
14:33:36 <edwardk> so any function that accepts a value and doesn't return is a negation.
14:33:37 <xerox> ed kicks in!
14:33:45 <roconnor> induction, recursion, not much of a difference.  Recursion is the functional realization of the logical property of induction.
14:33:58 <ski> edwardk : right
14:34:36 <edwardk> thats how you can see continuations (~T) as a dual for values (T) with ~ an intuitionistic negation
14:34:39 <SamB> edwardk: so, for instance, forever is a negative?
14:34:42 <SamB> or not?
14:34:45 <SamB> because it might return?
14:34:46 <edwardk> @type forever
14:35:16 <SamB> @type let forever p = p >> forever p in forever
14:35:20 <SamB> oh right
14:35:22 <SamB> dead bot.
14:35:27 <SamB> anyway the type is
14:35:40 <SamB> Monad m => m a -> m b
14:36:03 <ski> callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
14:36:04 <ski> ^^ 'a -> m b' there is the continuation
14:36:18 <SamB> ski: erm
14:36:18 <Cale> roconnor: Suppose, for instance, that we want to prove that every element of that list is 1. We can use transfinite induction to do it quite nicely.
14:36:35 <SamB> hmm.
14:36:45 <roconnor> xerox: I should be a bit more clear, primitive (or structural) recursiion is the realization of induction.  general recursion covers structural recursion structural corecrusion and everything in between.
14:36:51 <SamB> ski: is that useful for anything?
14:37:03 <ski> SamB : the monad 'Cont' ?
14:37:08 <SamB> because it doesn't look like that function knows anything about b
14:37:13 <Cale> I don't think it's a good idea to confuse induction and recursion.
14:37:31 <SamB> oh, right...
14:37:33 <ski> SamB : it doesn't .. that's the point .. you can use that to make a "nonlocal jump"
14:37:34 * SamB figures it out
14:37:38 <JohnMeacham> is 'yi' supposed to compile out of the box on ghc 6.6?
14:37:47 <roconnor> Cale: depends what you mean by every. ;)
14:37:49 <SamB> ski: is that the right way or the wrong way?
14:38:09 <ski> SamB : both, in a way :)
14:38:36 * SamB would @google MonadCont done right at this point
14:38:46 <edwardk> basically you have to be careful coz of the type system in haskell. coz _|_ is a member of every type, every type can be viewed as partial, so the type signature doesn't tell you whether or not the evaluation of that function is pointed. Can forever ever return?
14:39:06 <SamB> edwardk: well. it depends on the monad...
14:39:11 <ski> SamB : it's represented inside the 'Cont' monad to make it pure .. otherwise it would be impure .. i'm arguing (somewhat) that with linearity, you could skip the 'Cont' monad and have raw pure continuations
14:39:19 <SamB> I suppose it doesn't really return...
14:39:19 * xerox goes to sleep, interesting night, but quite heavy on the brain
14:39:21 <xerox> Goodnight.
14:39:22 <SamB> per se...
14:39:44 <SamB> ski: how could you do that and still have linearity?
14:39:50 <roconnor> Cale:  I can also write a recursive function to take the nth element from the list.
14:40:15 <ski> SamB : do what ?
14:40:15 <Cale> sure
14:40:36 <Cale> and you could inductively prove that it in fact does give 1. :)
14:40:56 <edwardk> basically all ~T means is that T -> _|_, so if the function happens to never return then its ~T, unfortunately the type system of stock haskell doesn't let you say that directly. However you could say that by defining a type with no constructors, and making a function that returns that type. then that functions by definition can not successfully return and can be viewed as a negation.
14:41:05 <roconnor> see, they are the same thing
14:41:17 <Cale> It would be more cumbersome than using coinduction, but at the end of the day, they would be equivalent.
14:41:26 <roconnor> induction, prove a base case, and show successive cases preserve the rpoof.
14:41:36 <ski> edwardk : alas, you could still use 'undefined'
14:41:53 <edwardk> undefined and error can be viewed as continuations, they never return to their caller.
14:42:03 <roconnor> structural recursion: supply a base case, and provide functions to supply sucessive cases from a previous case.
14:42:20 <ski> (hmm .. maybe a 'Absurd#' type ?)
14:42:23 <SamB> ah
14:42:26 <SamB> http://www.haskell.org/hawiki/ContinuationsDoneRight
14:42:28 <Cale> By induction, I mean the sort which works on any well-founded set.
14:43:02 <xerox> {},{{}},{{},{{}}},{{},{{},{{}}}},...
14:43:07 <xerox> Ordinals or naturals?
14:44:08 <SamB> {{{{{{}}}}}} -- what is that?
14:44:32 <roconnor> the set containing the set containing the set ... containing the empty set.
14:44:43 <JohnMeacham> her name is lambda and she dances on the sand.
14:44:43 <ski> edwardk : still, you'd want to have double negation elimination .. (possibly one can hack it with TheHunter's (impure !) monadic reflection in haskell)
14:45:17 <edwardk> ski: well, adding double negation elimination gives you a classical logic, not intuitionistic.
14:45:27 <xerox> ski: if it was using implicit parameters, it'll not work anymore in ghc head :D
14:45:38 <ski> edwardk : well, i was heaving for linear :)
14:45:51 <ski> ): xerox
14:46:04 <ski> (s/heaving/heading/)
14:46:10 <monochrom> If you understand {} and, for all x, {x}, then by induction you understand {{{{{{}}}}}}.  :)
14:46:27 <SamB> oh, I'm just making fun of xerox's question or something.
14:46:29 <xerox> I.P. considered harmful.
14:46:59 <ski> impredicativity ?
14:47:34 <roconnor> induction principle?
14:48:05 <roconnor> xerox's new paper: Recursion Considered Harmful.
14:48:18 <roconnor> actaully, maybe I should write that.
14:48:22 <int-e> but will you also understand {{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}} ?
14:48:29 <SamB> int-e: no.
14:48:32 <monochrom> Yes.
14:48:35 <edwardk> well, even there, ~~T does not imply T. Normally the lambda calculus is constructive. A -> B says that given an object of type A i can construct an object of type B. so ((T -> _|_) -> _|_) -> T isn't sound. Given a function that takes a function which given a T doesn't return  can avoid returning I can't get back a T. Now haskell is a little weaker. _|_ is a member of every type. therefore as a logic haskell is degenerate. Every proposition/type has a pro
14:48:38 <SamB> because it is too hard to count the brackets on that
14:48:39 <ski> edwardk : something like 'catch :: ((a -o _|_) -o _|_) -o a'
14:48:50 <SamB> to see if they even match up, for instance
14:48:56 <int-e> monochrom: doubt it ;)
14:49:17 <SamB> PrimCode> length "{{{{{{{{{{{{{{{{{{{{{{{}}}}}}}}}}}}}}}}}}}}}}}}"
14:49:17 <SamB> 47
14:49:17 <xerox> Ahah.
14:49:17 <monochrom> -o is the linear logic candy?
14:49:19 <int-e> SamB: exactly :)
14:49:25 <xerox> Mismatched paren.
14:49:33 <SamB> xerox: no! bracket!
14:49:36 <edwardk> ski: you just reinvented shift and reset =)
14:49:46 <xerox> error "there is no bracket" :: not Bracket
14:49:49 <ski> edwardk : i'm pretty sure 'catch' is derivable in linear logic
14:49:55 <monochrom> I understand that so much, I knew you had a typo and I guessed what you mean instead of taking you literally!
14:50:13 <ski> edwardk : no, just pure continuations .. not "composable/delimited/sub- continuations"
14:50:15 <int-e> It wasn't a typo.
14:50:30 <SamB> int-e: should have said (sic)!
14:50:34 <monochrom> Darn. So much for human mutual-understanding.
14:50:44 <edwardk> ski: in classical linear logic. in intuitionistic, no.
14:50:44 <ski> monochrom : yes, '-o' is pronounced "lolli" :) .. it's a kind of implication, you could say
14:50:51 <SamB> heh
14:50:51 <ski> edwardk : yes
14:50:56 <monochrom> Well now how do you know that "sic" is not a typo of something else too?
14:50:57 <SamB> ski: that is funny!
14:51:18 <SamB> monochrom: because it stands for "the foregoing is not a typo"?
14:51:34 <monochrom> This now gets us into the modal logic of "I assure you I mean (I assure you I mean (I assure you I mean (..."
14:51:48 <SamB> heh
14:52:23 <edwardk> ski: remember, girard uses a classical linear logic, so you have to be careful with his ideas as a type theory
14:52:49 <dons> ?uptime
14:52:53 <ski> i think many things (if not all) can be carried over
14:52:57 <roconnor> fix (\x - {x})
14:53:00 <Cale> roconnor: Here's a way to prove things about, say, lists in Haskell. Define the values [] and _|_ to both have length 0 (note that this is a mathematical definition and not something that you'd implement with a Haskell function, of course), and let x:xs have length one more than the length of xs, if xs is finite, and let any infinite list have length omega.
14:53:01 <roconnor> fix (\x -> {x})
14:53:21 <edwardk> anytime they mention proof nets its crazy talk and you don't get an object in hand. ;)
14:53:24 <ski> (edwardk : btw, possible cut-off on next-to-last : ".. Every proposition/type has a pro")
14:53:34 <edwardk> oh sorry
14:53:41 <monochrom> proof nets are crazy
14:53:43 <edwardk> has a proof _|_
14:53:49 <roconnor> Cale: that is one possible interpretation.
14:53:54 <ski> monochrom : well, at least they are strange
14:54:12 <dons> ?uptime
14:54:18 <Cale> Then if we have that a property P holds for all lists of length less than alpha, then it holds for lists of length alpha as well, then we have that it holds for all lists.
14:54:37 <ski> dons : down
14:54:37 <edwardk> hence why haskell's type system can never be used as a theorem prover in the coq sense, just like cayenne's can't, because both admit _|_ as a proof of all types/propositions
14:54:40 <lambdabot> uptime: 37s, longest uptime: 6d 15h 1m 36s
14:54:44 <dons> ski: up
14:54:47 <ski> (ah, she got better :)
14:54:49 <dons> ;)
14:54:54 <dons> ?users
14:55:03 <ski> @remember roconnor error "there is no spoon" :: not Spoon
14:55:05 <nomeata> what's the difference between liftM and fmap for, say, IO?
14:55:08 <lambdabot> Maximum users seen in #haskell: 256, currently: 238 (93.0%), active: 4 (1.7%)
14:55:10 <ski> @remember JohnMeacham her name is lambda and she dances on the sand
14:55:20 <dons> ?type liftM
14:55:22 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
14:55:24 <dons> ?type fmap
14:55:25 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
14:55:29 * ulfdoz claims to be active
14:55:33 <ski> edwardk : yes
14:55:38 <xerox> Cale, my cousin was telling me about transfinite induction applicable on reals if one really wanted it.
14:55:50 <ski> nomeata : nothing
14:56:06 <nomeata> so why are there two names?
14:56:18 <swiert> Transfinite induction always reminds me of Buzz Lightyear.
14:56:19 <ski> since 'Monad' doesn't subclass 'Functor'
14:56:19 <Cale> xerox: oh, indeed
14:56:27 <swiert> To infinity! And beyond!
14:56:28 <Cale> xerox: you just have to well-order the reals
14:56:39 <nomeata> ok, but types that instance both do the same with these functions?
14:56:41 <ski> (nomeata : like it should (imsnho))
14:56:45 <Cale> xerox: but to do that, you will end up using the axiom of choice :)
14:56:50 <ski> nomeata : yes, they ought to
14:56:51 <int-e> nomeata: they should
14:57:00 <Cale> and you won't know what your well-ordering actually is.
14:57:02 <int-e> nomeata: although if a programmer wants to they can be different
14:57:04 <xerox> Cale oh.  Again that axiom.
14:57:12 <Cale> (in the sense that it will not be computable)
14:57:20 <xerox> Right, I remembered the favour of the quirk.
14:57:29 <edwardk> nomeata: you can add map to that list too
14:57:44 <ski> (not for 'IO', though)
14:58:33 <edwardk> what monads are there that you know that use one mapping for fmap and the other for liftM?
14:58:37 <Cale> Possibly the first place where one uses transfinite induction in the usual course of learning mathematics is to prove that every vector space has a basis.
14:58:48 <Cale> We did that one in Linear Algebra 1 :)
14:59:05 <xerox> Wow!
14:59:17 <xerox> I wonder if we will come across that.
14:59:20 <int-e> edwardk: I know none. And I hope there aren't any.
14:59:27 <edwardk> int-e: good =)
14:59:27 <roconnor> R is a vector space over Q: Quick find a basis.
14:59:48 <Cale> Answer: apply my theorem, and you have one :)
15:00:20 <astrolabe> Cale: How does that work?
15:00:22 * roconnor also has a blog post about the axiom of choice
15:00:23 <Cale> It's uncountable. You can insist that any independent subset of R/Q is included though.
15:01:05 <Cale> For instance, I can insist that 1, pi, and sqrt(2) are elements.
15:01:29 <roconnor> astrolabe: every vector space has a basis, R is a vector space over Q, therefore it has a basis.
15:01:38 <Cale> One nice thing that one can do with such a basis is to consider the linear transformation which swaps any two of the basis vectors.
15:01:48 <astrolabe> roconner: I mean how does the proof work?
15:01:55 <Cale> http://planetmath.org/encyclopedia/EveryVectorSpaceHasABasis.html
15:01:58 <lambdabot> Title: PlanetMath: every vector space has a basis, http://tinyurl.com/vn5zj
15:02:04 <astrolabe> ta
15:02:21 * roconnor has never seen a representation of such a basis.
15:02:22 <Cale> that uses Zorn's Lemma, which is another form of the axiom of choice.
15:02:25 <int-e> astrolabe: see also http://mathworld.wolfram.com/HamelBasis.html
15:02:27 <lambdabot> Title: Hamel Basis -- from Wolfram MathWorld
15:02:53 <Cale> roconnor: Well, it's represented in terms of a choice function.
15:03:09 <roconnor> Kronecker is spinning in his grave.
15:03:27 <Cale> Which is quite alright with me.
15:03:31 <roconnor> oops, past by bed time
15:03:39 <Cale> Kronecker was a bit of a jerk. :)
15:03:48 <roconnor> true
15:04:11 <astrolabe> very nice
15:10:13 <shapr> @users
15:10:14 <lambdabot> Maximum users seen in #haskell: 256, currently: 236 (92.2%), active: 14 (5.9%)
15:11:49 <ski> roconnor : hmm .. that looks similar to skolemization
15:21:00 <glguy> ?version
15:21:00 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
15:21:01 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:22:49 <gene9> lambdabot
15:29:32 <yip> "but if this is the state-of-the-art in functional program optimisation then we are in big trouble."
15:29:52 <sjanssen> I think that statement is a bit pessimistic
15:30:27 <monochrom> where is it?
15:31:05 <sjanssen> monochrom: http://r6.livejournal.com/96722.html
15:31:05 <yip> http://r6.livejournal.com/96722.html
15:31:06 <lambdabot> Title: r6: Functional Optimisation
15:31:07 <lambdabot> Title: r6: Functional Optimisation
15:33:19 <sjanssen> it was just a little bug, it was noticed, and SamB fixed it (partially)
15:42:25 <SamB> what is a betadelta boundary?
15:49:35 <SamB> dons: did you add that quote?
15:49:36 * dons -> off to the US. see you guys in 24 hours or so! be sweet to lambdabot
15:49:44 <dons> SamB: yep, roconnor did
15:49:48 <sjanssen> dons: have a nice trip!
15:50:21 <SamB> ack. /me should have killed that second email before it was let onto the list
15:51:52 <dcoutts> have fun dons!
15:52:02 <Cale> SamB: I managed to find this paper which uses Greek letters to name stages of compilation, but I wouldn't exactly call that standard usage.
15:52:04 <Cale> http://www.cs.indiana.edu/proglang/dynamo/tr490.ps
15:53:07 <lambdabot> http://tinyurl.com/vz8rc
15:53:52 <SamB> could someone tell me whether that second set of patches that got through there counts as "not conflicting"?
15:56:56 <SamB> (the one in http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/17193 )
15:56:59 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/y7tf84
16:01:34 <ndm> dons: have fun, be sure to mention hoogle ;)
16:11:19 <dibblego> http://foldoc.org/foldoc.cgi?query=function "A procedure is a function which returns no value but has only side-effects. The C language, for example, has no procedures, only functions. ANSI C even defines a type, void, for the result of a function that has no result." -- is it me or is this a contradiction?
16:11:22 <lambdabot> Title: function from FOLDOC
16:12:33 <monochrom> I don't like abusing the word "function" either.
16:12:55 <dibblego> well, it says "The C language, for example, has no procedures"
16:12:56 <ski> if the former is accepted, methinks the latter should'nt be
16:13:14 <monochrom> But language being what it is, a culture can choose their words, which may conflict with the choice made by another culture.
16:13:23 <dibblego> then it goes on to say it has type void (and therefore, does have procedures)
16:13:42 <dibblego> ignoring the usual abuse of the term function
16:14:11 <monochrom> It comes down to whether there exists a value of type void.
16:14:34 <dibblego> well any "function" that uses type void is implicitly a procedure
16:14:54 <ski> s/uses/"returns"/
16:15:06 <zention> a procedure normally modifies the values supplied
16:15:23 <dibblego> or it might modify a file/database/network socket
16:15:57 <zention> yeah it could modify a global
16:16:10 <ski> iirc, in Ada a procedure can only modify an arg if it's 'out' or 'in out' ..
16:16:13 <monochrom> Suppose I write "f :: Int -> IO ()".  I think we don't have a problem calling it a side-effecting function, since it returns the value (), even though this value has little use.  The C story is different.
16:16:20 <dibblego> still, I think that statement is pretty broken
16:16:58 <monochrom> You are right.  But I have long stopped debunking these things.
16:17:19 <ski> (interesting .. http://r6.ca/homework.html)
16:17:34 <ski> (title : Formal Proofs for Assignments)
16:18:20 <monochrom> Haha, I may give 0 too.
16:18:57 <ski> may i ask for what reason(s) ?
16:19:19 <monochrom> Wait, computer-verified, not computer-generated?
16:19:27 <ski> right
16:20:11 <ski> "I did employ the Tauto tactic which infers propositional tautologies. Since this is a course on set theory not propositional logic, I feel using such automation is reasonable."
16:20:17 <monochrom> OK full marks if you hand in an electronic form so I can run it through Coq and see for myself.
16:20:55 <monochrom> I reserve the right to deduct 1/10 or 2/10 because it's soooo looooonnnngggg.
16:21:16 <monochrom> Oh propositional logic is not supposed to be done by humans.
16:21:18 <ski> ("Also I did not automatically search to find a proof. Such a procedure is extremely intractable (undecidable), and in general any assignment calling for a proof that could be found this way would be an insult to the student.")
16:21:49 <ski> mhm
16:23:20 <monochrom> This TA lives in the 19th century.
16:23:35 <dibblego> many do
16:25:13 <monochrom> But cut your TA some slack.  If most programmers today still don't know that tail recursion does not use up stack space, most mathematicians today still don't know that proof verification is reliable.  Perpetuating outdated myths is as common as stupidity.
16:26:50 <monochrom> Basically a human being takes a snapshot of the state of the world when he's 20, and then for the next 60 years he's going to just pretend the world stays the same that way.
16:26:52 <int-e> and how many programming language implementations are still out there where tail recursion does eat stack space?
16:26:52 <dibblego> the source of it is the teaching institutions
16:28:00 <dibblego> 7
16:28:09 <monochrom> What's the difference between education and brainwashing?  I pose that to the channel, and I happily go to dinner.
16:28:44 <dibblego> monochrom, that's exactly what I was thinking during reading that article
16:29:07 <dibblego> the writer makes the mistake of thinking that the stated objectives are real and not a facade
16:30:02 <dolio> int-e: A lot?
16:31:30 <dolio> At least 3 of people's favorites.
16:33:05 <shapr> Education is something you to yourself for your own benefit, brainwashing is something that is done to you for the benefit of others.
16:33:54 <dibblego> how do you educate yourself if you are surrounded by disinformation?
16:34:07 <dibblego> it's an aweful paradox
16:34:11 <dibblego> *awful
16:36:21 <Pseudonym> Brainwashing can be for your own benefit.
16:36:26 <Pseudonym> Like those self-help books.
16:36:38 <dibblego> lol
16:38:15 <int-e> woops. icc (9.0) just optimized a nonterminating C program into a terminating one ...
16:38:41 <int-e> it's very simple, too: void x() { x(); } int main() { x(); }
16:39:19 <dolio> Your main doesn't return an int. :)
16:39:50 <int-e> you mean it has no return statement, but the end of main() is never reached ...
16:40:07 <dolio> Yeah, I meant the former.
16:40:17 <dolio> I suppose C doesn't concern itself with such trivial things.
16:40:32 <int-e> gcc with -O2 optimizes tail calls.
16:40:35 <dolio> It will just guess what you want to return if it ever gets there.
16:42:11 <int-e> so does icc if it doesn't eliminate the whole function ;)
16:42:31 <dolio> I was thinking Python, Ruby and Java for languages without tail call optimization.
16:42:36 <dolio> Or does Python have it?
16:42:49 <dolio> I wasn't sure about Perl, either.
16:42:52 <qwr> stackless python maybe has
16:44:14 <int-e> python doesn't.
16:45:51 <int-e> perl doesn't either and eats all available memory.
16:46:07 <dolio> I imagine PHP doesn't, as well.
16:46:36 <dibblego> C#?
16:46:40 <dolio> Although I can't picture people using that for general purpose programming.
16:46:41 <dibblego> I'll bet that doesn't
16:46:55 <dolio> Though I've seen some claim to.
16:47:45 <dolio> I don't know. .net might have tail call optimization.
16:47:51 <dolio> It'd be difficult to write F# otherwise.
16:51:55 <lispy> http://www-inst.eecs.berkeley.edu/%7Emaratb/readings/NoSilverBullet.html
16:51:57 <lambdabot> Title: No Silver Bullet:, http://tinyurl.com/yah7vu
16:52:20 <lispy> iirc, F# uses a modified .NET CLR
16:52:29 <lispy> called XLR or such
16:52:39 <dolio> Ah, okay.
16:52:50 <lispy> i have no idea what they modified though
16:52:59 <lispy> my guess is they mostly modified the type system
16:53:00 <dibblego> someone in dalnet #C# claims there is tail call optimisation
16:53:25 <lispy> and iirc, F# can link to normal .NET so who knows...
16:55:52 <qwr> http://blogs.msdn.com/shrib/archive/2005/01/25/360370.aspx
16:55:54 <lambdabot> Title: Shri Borde's WebLog : Tail call performance on x86, http://tinyurl.com/w9jco
16:57:24 <ndm> dibblego: there is
16:57:39 <dibblego> ndm, righto
16:57:42 <ndm> dibblego: or at least, there is support in the underlying IL bytecodes for tail calls (unlike Java)
16:58:03 <ndm> lispy: ILX, I think
16:58:10 <dibblego> ndm, I just finished reading http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4726340 :)
16:58:12 <lambdabot> Title: Bug ID: 4726340 RFE: Tail Call Optimization, http://tinyurl.com/ybx6ht
16:58:31 <ndm> lispy: not sure they modified the type system at all, was mainly extra instructions at the bytecode level for the common functional stuff, i think
16:59:48 <ndm> Yhc can generate .NET bytecode, hence i know these things :)
17:05:56 <lispy> ndm: cool, i just saw a foot note about it :)
17:06:27 <lispy> ndm: oh but wait a sec
17:06:36 <lispy> ndm: do you have to do any weird stuff to get the types to work out?
17:06:43 <lispy> ndm: at least in the case of ghc that's a hurdle
17:06:49 <lispy> ndm: according to spj
17:06:54 <ndm> lispy: Yhc is untyped by then
17:07:05 <ndm> lispy: we don't really support linking in with other .NET code
17:07:28 <lispy> then what is the value of running on .NET?
17:08:04 <ndm> for fun :)
17:08:15 <lispy> (or maybe it's the first step in an interesting direction...)
17:08:23 <lispy> ndm: fair enough :)
17:08:28 <ndm> quite possibly, someone just showed up one day with a patch :)
17:08:35 <lispy> heh
17:08:52 <ndm> never heard from them before or since, can't even remember who it was
17:09:01 <ndm> same as with the Java port, guy did the same thing...
17:09:02 <lispy> that's funny
17:09:19 <ndm> yep, i think it means Yhc has a lower barrier to entry than GHC
17:09:32 <ndm> although probably says bad things about our "developer retention" as well...
17:09:35 <lispy> does yhc have performance comparrible to ghc and support turing complete type classes?
17:09:40 <chessguy> hmm, is short-circuit evaluation the same thing as lazy evaluation?
17:09:53 <ndm> lispy: not yet, and no
17:10:03 <lispy> chessguy: they are related sort of
17:10:04 <ndm> lispy: although i am working on the first :)
17:10:17 <lispy> chessguy: i mean, you use short-circuit to by pass normal application order
17:10:19 <Igloo> ndm: I'd be interested to know how true that is in practice. A lot of the barrier for GHC is just psychological, I think
17:10:34 <lispy> chessguy: in lazy eval you don't usually need short-circuit because it's evaluate on demand
17:10:46 <chessguy> but most languages support short-circuit evaluation, whereas most languages aren't lazy, right?
17:10:52 <musasabi> Released HAppS version 0.8.4.
17:10:58 * shapr cheers
17:11:01 <lispy> chessguy: yes, exactly
17:11:01 <ndm> Igloo: anyone can compile Yhc, i wouldn't even dare to try compiling GHC
17:11:05 <Igloo> GHC is also bigger etc, of course, and has higher compile times, and so on
17:11:19 <lispy> chessguy: compare lisp with it's macros that allow 'special-forms' to, say, haskell
17:11:19 <chessguy> bah, my instructor is saying they're the same thing
17:11:26 <Igloo> ndm: Because you think it would be difficult to compile or because it would take a long time?
17:11:29 <ndm> Igloo: indeed, but the instructions for building (on Windows certainly) are horrible - on Yhc its about 3 commands long
17:11:37 <lispy> chessguy: one thing you see is that in lisp a special form just means that the evaluation order is non-standard
17:11:37 <chessguy> i should point out that she's clueless, but it's not worth the effort
17:11:39 <ndm> Igloo: because the instructions take up 2 printed pages
17:11:54 <ndm> Igloo: any set of instructions that long has at least 5 ambiguities and 2 errors, at a guess
17:11:54 <lispy> chessguy: and you need that sometimes in an eager language
17:12:08 <ndm> Igloo: and it requires Mingw, and a spare day
17:12:43 <lispy> chessguy: well, i dunno, in this case the net effect is the same
17:12:47 <chessguy> this class is so irritating. it's supposed to be about "principles of programming languages", but everything we're talking about is really restricted to imperative programming
17:12:56 <Igloo> ndm: OK, on Windows there's all the bygwin/msys installation etc to fight through, that's true
17:12:57 <shapr> surprise!
17:13:00 <lispy> chessguy: but, short-circuit isn't general, lazy eval is
17:13:11 <musasabi> Yhc is interesting but most real code unfortunately depends on things that it doesn't support.
17:13:16 <chessguy> lispy, right, but it's really inaccurate to say they're the same
17:13:20 <Igloo> ndm: The actuall GHC compilation is just http://www.haskell.org/ghc/docs/latest/html/building/sec-building-from-source.html with 2 argumetns to configure though, I think
17:13:22 <lambdabot> Title: 4. Building from source, http://tinyurl.com/y5oybm
17:13:28 <ndm> musasabi: i know, but we are slowly working on that
17:13:41 <Igloo> ndm: What does nhc need? Just a Haskell compiler?
17:13:46 <lispy> chessguy: right, you might say that short-circuit behaves as a restricted subset of lazy eval
17:13:48 <Igloo> Gah, s/nhc/yhc/
17:13:56 <musasabi> Then again GHC 6.6 type system doesn't support all the things either ._>
17:14:02 <ndm> Igloo: thats a lie, OpenAL is broken and if you have the libarires installed it borks totally, and you need an obscure configure flag
17:14:03 <musasabi> *._.
17:14:15 <Igloo> ndm: OpenAL isn't in GHC core any more
17:14:29 <ndm> Igloo: GHC, C compiler, darcs, svn, scons, python
17:14:30 * musasabi wants System Fc
17:14:41 * lispy has tried to build ghc on debian and osx and failed all attempts
17:14:52 <Igloo> ndm: You can install all that in 3 commands?
17:15:01 <musasabi> lispy: at least on debian i386 it is quite easy
17:15:03 <ndm> Igloo: good, having broken libraries around by default made me sad - thats what happened when i did write a patch for GHC
17:15:10 <Igloo> ndm: Does C ompiler imply msys/cygwin?
17:15:21 <lispy> musasabi: i have amd64 but i don't remember the problem
17:15:27 <ndm> Igloo: alas no, but once you have the dependancies, then you can - and i provide windows binaries for all of them
17:15:33 <chessguy> lispy, the problem is, if the other students in this class hear something about 'lazy eval' later, they're going to say 'oh, i know what that is...'
17:15:42 <ndm> Igloo: no, Visual Studio (we don't support GCC on Windows yet, but its a known bug)
17:16:39 <Igloo> OK, maybe your binary packages make it easier, but other than that the two seem comparable to me
17:16:57 <ndm> on windows, its much easier than GHC
17:17:03 <ndm> on Linux, probably comparable
17:17:09 <ndm> in terms of set up
17:17:40 * Igloo hasn't tried building yhc on Windows (or at all), but based on teh deps you list the two seem comparable to me
17:17:40 <ndm> but for us a build is a 5 minute job, and you can still run Yhc with WinHugs (and I do!) which makes development easier
17:17:55 <Igloo> Right, that's certainly a benefit
17:18:11 <ndm> the MingW stuff is just badly packaged etc - installing Python is "clicky clicky", installing MingW is "pain pain"
17:18:20 <Igloo> :-)
17:18:29 <br1> :D
17:18:43 <lispy> oh yeah, installing mingw is way more confusing than it really is
17:19:07 <lispy> finally i just downloaded and installed some of the binaries out of desparation and it just worke
17:19:09 <br1> I think that the best way to get migw is to install cygwin
17:19:13 <Igloo> The amount of confusion is _|_?
17:19:19 <lispy> which pissed me off that they have so much useless text on their site :)
17:20:05 <ndm> indeed, once you find the right link its not too bad
17:21:39 <ndm> Igloo: does anyone on the GHC team actually do their development in Windows?
17:21:58 <Igloo> I'm not sure if SPJ does
17:22:15 <Igloo> Windows is /much/ slower than Linux on the same hardware
17:22:33 <Igloo> (for GHC devel)
17:22:38 <ndm> Windows is pretty, so I forgive it :)
17:23:11 <Igloo> I'm not sure how much of that is cygwin/msys' fault
17:23:57 <ndm> i would blame most of it on msys
17:24:13 <ndm> its really slow, i found, but i guess depends what you do with it
17:24:38 <Igloo> SimonM was talking about one factor being file access being slow, but again that could be file access through the msys/cygwin libraries
17:25:44 <lispy> ndm: i think all other major OSs with a windowing system look much better than windows... :)
17:25:46 <ndm> indeed, the extra layer of abstraction
17:26:05 <ndm> and i assume that MingW is badly written, since they can't design a website competently
17:26:31 <lispy> heh
17:26:41 <lispy> and they are forced to develop in C
17:26:42 <Igloo> I think cygwin is supposed to be slower than msys too, but I live with that as I can SSH to cygwin and for the most part not touch the GUI or have to reach over to the laptop
17:27:21 <ndm> if one of the main GHC developers was working on Windows full time, the Windows/GHC stuff might get better quite a bit quicker
17:28:04 <Igloo> What stuff? The dev setup wouldn't be improved necessarily, as the GHC Windows dev would just do it one time
17:28:21 <ndm> i guess
17:28:35 <ndm> maybe if you forced someone to go through the setup process once a day
17:28:40 <ndm> or develop on multiple machines
17:29:06 <ndm> i have 4 separate Windows machines i develop Yhc on, hence its quite a smooth process to set one up for Yhc devel
17:29:14 <Igloo> But wouldn't you prefer them to fix compiler bugs?
17:29:29 <ndm> you can even compile Yhc without a C compiler, if you don't want to execute the resulting bytecode, or use the snapshot release
17:29:30 <Igloo> It's only worth doing if there are actually Windows developers not coming to GHC because of it
17:29:43 <ndm> i don't think you'll find out til you fix the bugs
17:29:48 <ndm> * difficulties
17:29:53 <Igloo> And those developers are probably better able to fix it than the Linux developers who currently work on GHC
17:30:24 <ndm> a small thing at the begining will put some one off, once they are "inside the project" they're more likely to do the big thinks like that
17:31:39 <Igloo> Getting GHC to compile with VH is probably a more interesting prospect for an interested person
17:31:44 <ndm> anyway, we in the Yhc project have a nice build guru who doesn't actually know Haskell, which is a nice separation
17:32:09 <ndm> that would be good, and the first step towards throwing away Mingw
17:33:32 <shapr> Is there an especially efficient way to do toLower on ByteString values?
17:33:45 <dcoutts> map toLower
17:33:51 <shapr> ok, thanks.
17:36:18 <Cale> Isn't it nice when the especially efficient way of doing something is the obvious way?
17:44:47 <lispy> Igloo: i've wondered about that, building ghc in VH
17:44:58 <yip> damn why can't python be more like haskell :/
17:45:01 <dcoutts> Cale, do you know how hard we worked to make it that way? :-)
17:45:11 <lispy> Igloo: but, VH just uses cabal, which means cabal would have to be significantly extended?
17:45:45 <dolio> Because Guido van Rossum doesn't like functional programming?
17:46:02 <Cale> dcoutts: yeah :)
17:46:04 <Igloo> Oh, I meant VS, not VH
17:46:17 <lispy> Igloo: ah
17:46:40 <lispy> Igloo: yeah, it would be really cool if it worked with the 'free' MS compiler tools as well
17:46:56 <Igloo> Which are those?
17:46:59 <lispy> working easily with whatever people have is always a nice perk
17:47:27 <lispy> Igloo: i don't know much about it because i can get a 'free' copy of VS through school or at work, but i guess they give away just the compiler stuff now
17:47:38 <lispy> Igloo: you don't get any ide (but there is an opensource one)
17:49:25 <Igloo> Ah, OK
17:50:01 <br1> You do get an IDE.  It's 'streamlined' but complete. I understand that it doesn't support plugins, though, so no VH.
17:50:35 <lispy> br1: ah
17:50:40 <hoopy> what is VH?
17:50:57 <lispy> hoopy: plugin to use ghc with visual studio, you even get type checking in the editor
17:51:01 <Cale> I wonder if there's a way we can get GvR to learn Haskell properly :)
17:51:07 <lispy> ?where visualhaskell
17:51:07 <lambdabot> I know nothing about visualhaskell.
17:51:08 <hoopy> really.
17:51:26 <hoopy> > map (**) [1,2,3]
17:51:28 <lambdabot>  Add a type signature
17:51:34 <lispy> hoopy: yeah, http://darcs.haskell.org/vshaskell iirc
17:51:38 <lambdabot> Title: Index of /vshaskell
17:51:43 <Cale> Perhaps someone will have to write a python implementation in Haskell or something :)
17:51:49 <int-e> hoopy: that's a list of functions
17:51:51 <Bobstopper> Where should I look to learn how to deal with structs in Haskell's FFI?
17:52:01 <int-e> @type map (**) [1,2,3]
17:52:02 <lambdabot> forall a. (Floating a) => [a -> a]
17:52:03 <hoopy> somebody is writing a perl implementation in haskell
17:52:07 <Cale> Bobstopper: Storable, I think
17:52:11 <hoopy> i know nothing about haskell
17:52:13 <Cale> hoopy: yep, Pugs :)
17:52:13 <lispy> Bobstopper: are the structs in C or are they on the hasklel side?
17:52:14 <hoopy> i would like to learn it
17:52:20 <Bobstopper> in C
17:52:31 <lispy> Bobstopper: hsc2hs and like Cale said, Storable
17:52:38 <Bobstopper> cool, thanks
17:52:45 <hoopy> i'm assuming it really helps to have a computer science background when learning haskell
17:52:55 <lispy> Bobstopper: in fact, for you, it's probably worthwhile to take a look at the System.Win32 source
17:53:00 <lispy> Bobstopper: it's easy to learn from
17:53:13 <Cale> hoopy: Haskell's often taught as the first programming language in some CS courses.
17:53:18 <Bobstopper> ok, I might do that, thanks
17:53:42 <Cale> (especially around Europe and in Australia)
17:53:57 <lispy> yeah, i wouldn't say it's happening in the US :)
17:54:17 <Bobstopper> Yeah, Haskell was my first language in university in Australia. It took me 8 years to pick it up again though :)
17:54:20 <Cale> Yeah, I wonder why that is?
17:54:26 <lispy> MIT has taught scheme in the first couple years and maybe still does...but that's all i've really hard about
17:54:30 <Pseudonym> Which university?
17:54:31 <p-f> Cale: in Sherbrooke (quebec), they're teaching c++ as the first programming language - and the language used for the (only) functional programming class that we have is scheme
17:54:52 <Bobstopper> Pseudonym: me? University of Western Australia
17:54:56 <Pseudonym> Ah, right.
17:54:57 <Pseudonym> Cool.
17:55:20 <Cale> p-f: scheme is not so bad. C++ is a really strange thing to do first though.
17:55:20 * Pseudonym used to teach Haskell at University of Melbourne, thought we might know each other or something
17:55:20 <lispy> p-f: similar to my school, C -> Java -> Java -> ... -> Java -> lisp/haskell/prolog -> Java -> ...
17:55:37 <dolio> My school taught C++ first as well, I think.
17:55:55 <p-f> there was a teacher that wanted to use Haskell for the functional programming class actually, but he's retired now
17:56:06 <lispy> p-f: and sometimes there is a course that allows YourChoice or forces C, but there are only one or two in the whole ciriculum like that and it's quater based
17:56:16 <Bobstopper> I was one of those frustrated students when I was learning Haskell first time around - I wanted to be a sysadmin so I just wanted to learn C. Now I hate C and wish I'd paid more attention to the programming courses :)
17:56:19 <Cale> I mean strange not in the sense that it's especially uncommon, but in the sense that the decision to do that seems like it would have rationale that was shaky at best.
17:56:32 <hoopy> missouri state university states in their course description for computer science that they teach a functional programming language, they don't specify which one
17:56:39 <p-f> Bobstopper: heh, it's the other way around for me - I want to learn Haskell and other neat things like it but I'm stuck with C++/Java classes
17:57:13 <Bobstopper> Haha maybe in 8 years you'll want to be a sysadmin :D
17:57:15 <Cale> In any event, there's something wrong with a CS curriculum if they care what language you use after first year.
17:57:18 <lispy> p-f: enjoy grad schoool :)
17:57:47 <p-f> oh well, at least we get neat AI classes in second year :)
17:58:00 <lispy> Cale: not really, they feel obligated to turn out a lot of ready to go java devs
17:58:15 <lispy> Cale: and you can see why industry wants that
17:58:22 <lispy> Cale: so i blame industry
17:58:24 <Cale> lispy: Universities shouldn't be so influenced by market pressure.
17:58:38 <dolio> Requiring that people use C for a course in operating systems with a lot of basic unix programming isn't totally out there.
17:58:39 <p-f> they don't really have a choice; our program is coop (four internships in three years) and 3/4 of them require C++, the rest requires java
17:58:45 <lispy> Cale: well, if we're talking about the US everything is about business here
17:58:51 <Cale> I'd want them to teach courses where the material will still be relevant in 30 years.
17:58:55 <Bobstopper> I must say, although I had no real appreciation for programming in first year, after learning Haskell for first semester, Java in second semester seemed verbose and a pain to work with. So maybe it does put the seed of appreciation for functional programming in newbies...
17:58:56 <Cale> Look at the SICP course.
17:58:57 <lispy> Cale: it even shows up in romantic relationships :)
17:59:17 <br1> Here in Uruguay it's: Pascal -> Modula 2 -> C -> C++ -> Java -> Haskell/Prolog -> Java/C# -> ...
17:59:28 <p-f> ah yes, SICP
17:59:39 <p-f> I'm "taking" that class at the moment :)
17:59:59 <Cale> I highly recommend watching the video lectures, if only to realise how much knowledge has been ignored in the last 20 years.
18:00:02 <p-f> (the olde video lectures + the book)
18:00:22 <Cale> (at least, by the industry)
18:00:23 <shapr> Cale: I think the problem is that there are widely differing goals for CS students. Many (most?) of them just want to make money. Few of them are learning CS because they enjoy it.
18:00:35 <Bobstopper> I love the SICP course. I even brought my burnt copies of the lectures with me to Japan :)
18:01:10 <p-f> once you get past the way the lecturer's eyebrows wiggle when he speaks, you notice a lot of incredible concepts being discussed *grin*
18:01:21 <Cale> shapr: that's why you shove a whole bunch of really mathematical courses right to the start of the curriculum and force all the people who do not want to be computer scientists to drop out and go to the very finest community colleges where they can learn to make money :)
18:01:40 <shapr> The first tip in the The Pragmatic Programmer is "Care about your craft." After that, everything else comes naturaly.
18:01:41 <Bobstopper> They need to make universities academic institutions again. It seems they're becoming technical training schools these days
18:01:54 <shapr> Bobstopper: true that
18:01:56 <int-e> Cale: this? http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
18:02:00 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
18:02:01 <p-f> Cale: unfortunately the just-in-it-for-the-money'ers aren't failing the introductory math classes here (so far anyways, but we're only at midterm right now)
18:02:03 <Cale> int-e: yes
18:02:10 <br1> I like "Concepts, Techniques, and Models of Computer Programming" better than SICP
18:02:15 <zention> I had to use gopher at Uni
18:02:37 <Bobstopper> It'd be much easier for lecturers if every time students complained that the course material wasn't "practical enough" they could just say "if you're not interested in theory, what are you doing at uni?". But the employer climate seems to be pushing for uni degrees even when they're irrelevent. Ah well.
18:02:38 <shapr> I almost finished an Art degree at university.
18:02:49 <ski> (br1 : aka CTM)
18:02:52 <shapr> Never took any computer courses though.
18:03:20 <dcoutts> Bobstopper, if employers were pushing for uni degrees that'd be great
18:03:22 <shapr> Bobstopper: And employers want degrees even when the applicant knows more than enough to do the job.
18:03:33 <p-f> oh well, maybe one day I'll get a PhD and become a teacher and actually change the way things are taught *cough*
18:03:41 <Cale> Yeah, I think that when I eventually get around to getting a PhD and becoming a professor, I'll take a pretty hard line about that :) I don't think I'll teach CS though, but we'll see.
18:03:46 <dcoutts> p-f, I was doing that today
18:03:47 <shapr> My lack of a degree has caused me real trouble in job interviews.
18:03:49 <int-e> Bobstopper: Heh, some of our lecturers here did that. (And they're right.)
18:04:34 <dcoutts> shapr, my experience is that employers can't distinguish good from bad programmers very well
18:04:38 <Cale> I think that watering things like mathematics down really just makes things harder in the long run. I really really hate the highschool curriculum around here.
18:04:40 <araujo> shapr, that's the sad thing of our society too.
18:05:02 <shapr> dcoutts: I agree. Part of the problem is that you can't tell much about a programmer unless you pair program with them.
18:05:06 <p-f> speaking of university, I have a linear algebra test on saturday, so I should probably go and practice a bit to see if there's anything I haven't understood properly
18:05:07 <Cale> (which is about the same as the highschool curriculum throughout the US and Canada, and many other parts of the world, when it comes to mathematics)
18:05:20 <dcoutts> shapr, reading their code helps
18:05:22 <Cale> p-f: cool, what topics?
18:05:27 <shapr> true
18:05:40 <dylan> hmm, when compiling fps 0.7, I get a C error: "warning: cast to pointer from integer of different size"
18:05:41 <Igloo> dcoutts: That may well be so, but I don't think there are anywhere near enough good programmers to satisfy the market
18:05:42 <zention> as does the time to produce robust solution
18:05:52 <dcoutts> Igloo, that's true
18:06:15 <dcoutts> Igloo, but I don't think they're very good at noticing the good ones from the bad
18:06:22 <int-e> dylan: hmm, what architecture?
18:06:26 * Bobstopper wants to go back to uni and research for a living
18:06:28 <dylan> int-e: amd64. :)
18:06:29 <p-f> Cale: so far we've seen a bit of vector [sub]spaces, triangular decomposition, the usual complex polynomials and we've slightly touched the subject of canonical/homogeneous (pardon the spelling, I'm roughly translating from french) solutions
18:06:33 <dcoutts> well, excelent vs medeocre
18:06:43 <dylan> sizeof(int) != sizeof(void *)
18:07:04 <Cale> p-f: spelling is fine :)
18:07:11 <p-f> Cale: cheers
18:07:35 <Igloo> dcoutts: Yeah, I'm not arguing with that, although I don't have much first hand knowledge as I haven't been in a position to know how good people who did/didn't get hired are
18:07:39 <p-f> thing is we have four other classes, and whenever we need to cut somewhere, we cut in the linear algebra studying...so pretty much everyone is going to fail
18:07:42 <SamB_XP> @spell canonical
18:07:43 <lambdabot> canonical
18:07:47 <SamB_XP> huh
18:07:57 <int-e> @spell excellent
18:07:57 <p-f> I think I'll cut my semesters down to four classes from now on
18:07:57 <lambdabot> excellent
18:08:01 * SamB_XP thought you spelled that differently for some reason
18:08:02 <int-e> @spell mediocre
18:08:03 <lambdabot> mediocre
18:08:10 <dcoutts> Igloo, I'm only basing my opinion on my experience coding for a year at one company. Others may be better.
18:08:15 <SamB_XP> @spell dcoutts
18:08:16 <lambdabot> courts scouts dugouts Scout's dockets
18:08:21 <Cale> p-f: if you want a rather good book in linear algebra, I recommend Hoffman & Kunze
18:08:21 <dcoutts> hah
18:08:54 <Cale> @spell Cale
18:08:55 <lambdabot> Cale
18:09:02 <int-e> @spell me
18:09:02 <lambdabot> me
18:09:04 <int-e> ;)
18:09:08 <Cale> @spell int-e
18:09:09 <lambdabot> int-e
18:09:09 <p-f> Cale: thanks, I was looking for one actually - I only have an old edition of Anton's Elementary Linear Algebra, and it doesn't focus much on the topics that we're seeing
18:09:12 <Igloo> dcoutts: Oh, I've certainly seen lots of bad programmers get hired, but I don't know if there were better programmers who also applied
18:09:21 <Igloo> s/get/who have been/
18:09:27 <zention> well it is like trying to work out who a good lawyer is
18:09:27 <dcoutts> Igloo, within the engineering group the quality of code or management skill was not really related to their position
18:10:02 <dylan> hmm,
18:10:25 <dylan> umask 077 makes ./Setup.hs install things with the wrong perms.
18:10:26 <dcoutts> Igloo, yeah, I've no idea how you'd figure out from an interview how good someone was at programming
18:10:43 <dcoutts> dylan, report it as a bug.
18:10:55 <zention> it is done on personality and presentation just like anything else
18:11:08 <dylan> dcoutts: where?
18:11:23 <dcoutts> dylan, the cabal bug tracker
18:11:25 <dcoutts> @where Cabal
18:11:26 <lambdabot> http://www.haskell.org/cabal
18:11:26 <dylan> is there a cabal mailing list?
18:11:30 <dylan> ah, thanks
18:11:35 <Igloo> dcoutts: I think uni interviews do well, although it's not exactly the same skillset they were interviewing for
18:11:36 <dcoutts> dylan, yep there's one of those too
18:11:52 <dcoutts> Igloo, true and true
18:12:12 <dcoutts> I'm just glad I don't have to recruit
18:13:23 <Igloo> The hardest problem with interviewing programmers is testing ability, not knowledge of $language or whatever
18:13:30 <shapr> dcoutts: Is it faster to map toLower and then pack, or pack and then fps.map toLower ?
18:13:57 <dylan> I have found a bug with hackage.
18:14:11 <dylan> http://hackage.haskell.org/trac/hackage/newticket <-- I'm told to use username: guest and password: haskell
18:14:12 <Igloo> shapr: I'd expect the former
18:14:15 <lambdabot> http://tinyurl.com/yzk5qq
18:14:16 <dylan> doing so doesn't work.
18:14:23 <dcoutts> shapr, I think the latter
18:14:25 <dcoutts> :-)
18:14:27 <shapr> I wish that programmer hiring would start with a month of half pay where the interviewers would pair program with the applicants.
18:14:31 <Igloo> shapr, dcoutts: might be interesting to benchmark that sort of thing
18:14:34 <dcoutts> shapr, pack then B.map
18:14:58 <shapr> thanks
18:15:03 <dcoutts> Igloo, it should fuse when you B.map . B.pack
18:15:15 <dcoutts> or if it doesn't in this version it should in the next
18:15:27 <Igloo> shapr: Yeah, sadly infeasible though. And doing it for ~ a day means you tend to hire the person who's used the language longer/more recently
18:15:48 <skew> and inline toLower, to get something that's working on unboxed chars
18:16:11 <shapr> That shouldn't be infeasible. The long term benefits of such a hiring process would make themselves known in about six months.
18:16:18 <Igloo> dcoutts: Hmm, OK, but I don't see why that should be faster than a deforested map before packing. I can believe they're the same, though
18:16:23 <shapr> Or how about, the process would be worth the reward.
18:16:48 <Igloo> shapr: But you pretty much can't hire people who currently work somewhere else
18:16:50 <dcoutts> Igloo, we currently can't fuse pack with a list producer
18:17:02 <shapr> Good point.
18:17:04 <dcoutts> Igloo, but can fuse B.map with a B.pack
18:17:10 <skew> shapr: that's not unlike taking interns
18:17:20 <Igloo> dcoutts: Don't you have a list producer anyway?
18:17:29 <dcoutts> Igloo, if we move to using Streams for list fusion then the two ways should be the same
18:17:33 <shapr> Hm, yeah. That must be why so many interns get hired.
18:17:44 <dcoutts> Igloo, huh? no, pack is an array producer
18:17:49 <dcoutts> and a list consumer
18:17:55 <Igloo> dcoutts: But what's the argument to pack?
18:17:56 <dcoutts> and we can't fuse the list side of it
18:18:09 <dcoutts> we can't fuse pack with a list producer
18:18:11 * Igloo demands benchmarks! And graphs!
18:18:26 <skew> the map might fuse onto a list producer
18:18:34 <dcoutts> true
18:18:46 <dcoutts> shapr, so it mgiht depend on the context :-)
18:19:32 <shapr> I'm trying to do a case insensitive lookup on a Data.Map ByteString ByteString
18:19:34 <dcoutts> though as I said, if we move to useing stream fusion everywhere then it should make no difference if it's B.map . B.pack or B.pack . List.map
18:20:17 <dcoutts> shapr, I think B.map . B.pack
18:20:24 <shapr> ok, thanks.
18:21:05 <Igloo> must...resist...spending...time...writing...benchmark...
18:21:12 * shapr snickers
18:21:19 <dcoutts> heh
18:21:31 <dcoutts> Igloo, it does depend on which version of fps you're using
18:21:44 <dcoutts> since the fusion systems are totally different
18:21:45 <shapr> I would like a benchmarking something like QuickCheck where you put in the N equal chunks of code and then it puts out pretty graphs to say which is faster.
18:22:34 <Igloo> dcoutts: My intuition tells me that map first should never be slower, so I'd be interested to know if that's wrong with any version
18:23:27 <dcoutts> the point is that map f . pack could fuse to packWith f where as pack . map f is not fusable
18:23:36 <skew> Igloo: map first having reasonable performance depends on fusing with the list producer
18:23:54 <skew> you know B.map f . pack will fuse
18:24:40 <skew> and if it does fuse, then I think it comes down to whether it's more efficient to intermix the function with gather up values from cons cells scattered all over ram, or gather the values first and then map
18:24:45 <sjanssen> I don't think pack is a good producer in the current fusion framework
18:24:47 <Igloo> Oh, true, if you don't have a good producer at the very right then map first will be bad
18:24:52 <sjanssen> dcoutts: is that right?
18:24:57 <dcoutts> sjanssen, that's true
18:25:04 <dcoutts> in the streams framework it is
18:25:14 <sjanssen> I vote for ByteString.pack . List.map f
18:25:19 <dcoutts> heh
18:25:34 <skew> and I suspect that if the mapped function is not utterly trivial you might have some register pressure
18:25:43 * dcoutts thinks it doesn't matter :-)
18:25:48 <Igloo> The mapped function is utterly trivial
18:25:57 <dcoutts> Igloo, heh, no
18:26:05 <dcoutts> Igloo, do you know how slow toLower is ?
18:26:11 <shapr> This is the second time I've used ByteSTring, so I'm still learning.
18:26:20 <dcoutts> Igloo, we had to rewrie it to make our benchmark competitive with C
18:26:30 <Igloo> Really? Wow
18:26:35 <sjanssen> are we talking about strict or lazy bytestrings?
18:26:40 <skew> ah, also if GHC is somehow smart enough to vectorize the code working over bytestring you might win
18:26:48 <dcoutts> Igloo, all the Char.property functions are really really slow because the use unicode character properties
18:26:52 <Igloo> dcoutts: Do you know what the problem was?
18:26:57 <Igloo> Oh, of course
18:27:07 <dcoutts> as I recall it's a factor of 10ish
18:27:07 <shapr> I've never used Lazy ByteString, is there a wiki article about the differences?
18:27:26 <dcoutts> shapr, it's cooler, that's the primary difference ;-)
18:27:30 <sjanssen> shapr: type LazyByteString = [ByteString]
18:27:39 <sjanssen> the interface is exactly the same
18:27:44 <shapr> ohh, like ropes?
18:27:48 <shapr> or ShowS ?
18:27:59 <shapr> You amortize the ops?
18:28:03 <sjanssen> shapr: yeah, without fancy tree structures for concatenation
18:28:10 <sjanssen> no amortization
18:28:18 <skew> Igloo: for example, if dons snuck in a {-# RULES ByteString.map toLower x == ByteString.fancyVectorizedToLower x #-}
18:28:37 <shapr> Does ShowS count as amortized?
18:28:45 <shapr> skew: hah
18:28:46 <dcoutts> skew, trust me, we didn't :-)
18:28:58 <sjanssen> shapr: I wouldn't say ShowS is amortization
18:29:02 <dcoutts> shapr, for example with strict ByteString, reading a file needs to bring the whole thing into memory.
18:29:05 <shapr> ByteString.Nvidia.nestedDataParallelToLower
18:29:19 <shapr> sjanssen: Why not?
18:29:36 <dcoutts> shapr, with lazy bytestring we can have just 32k chunks at a time
18:29:59 <Igloo> ShowS is just more efficient. Ammortisation is about spreading the cost around, but not actually reducing it.
18:29:59 <shapr> dcoutts: nifty!
18:30:10 <dcoutts> shapr, so it's like [Char] in that way, that you can hae long/infinite streams and process them in constant space
18:30:49 <skew> Igloo: or, pushing around the execution time in a way that makes the data structure sound good..
18:30:55 <skew> like lying with accounting
18:31:25 <shapr> I think amortization really does increase efficiency by only executing what is truly necessary.
18:31:27 <sjanssen> amortization is the Enron of accounting?
18:31:31 <sjanssen> bah
18:31:36 <sjanssen> Enron of algorithms
18:31:50 * shapr shrugs
18:31:54 <skew> some of the lazy amortization stuff helps
18:32:04 <shapr> I'll probably be forced to write a TMR article about amortization just so I'll understand it all.
18:32:15 <skew> the stuff that really seems like "amortization" to me is when you total up the execution time
18:32:27 <sjanssen> seriously though, amortization is a perfectly legitimate technique
18:32:33 <ski> amortization is useful for soft real-time, and responsiveness, yes ?
18:32:44 <dcoutts> shapr, read Osaki's book or thesis, it's a great explanation of amortisation and amortised analysis
18:32:49 <shapr> No, the opposite really.
18:32:57 <shapr> dcoutts: I've got it, thus my recent interest.
18:32:58 <ski> (s/Osaki/Okasaki/)
18:33:06 <skew> like "well, that third insert took log n time, put if we slice up that log n and spread it around, we see that any sequence of operations takes linear time"
18:33:17 * dcoutts can never remember how to spell Okasaki's name
18:33:28 <sjanssen> skew: it really isn't shady like that
18:33:48 <skew> it's not shady, but I think it's more on the analysis side, proving you have certain time bounds
18:33:52 <dcoutts> it's clever stuff, it really can make overall execution time lower
18:33:55 <shapr> Okasaki's book really kicks butt.
18:34:07 <skew> I guess you could call stuff like datastructural bootstraping amortization on the desing side
18:34:17 <ski> butt-kicking for goodness !
18:34:22 <shapr> desing?
18:34:23 <shapr> oh design
18:34:31 <dcoutts> but the cost can get distributed over the series of ops in a highly non-uniform way
18:35:22 * dcoutts -> sleep
18:36:04 <shapr> @time dcoutts
18:36:06 <lambdabot> Local time for dcoutts is Fri Oct 13 02:34:17
18:36:12 <shapr> ah
18:41:50 <Lemmih> Good morning, #haskell.
18:42:09 <shapr> Good morning Lemmih!
18:42:58 <dylan> Good morning Vietnam!!
18:43:18 <shapr> foozl
18:44:32 <dylan> Sorry. it's a force of habit... that's how I respond to the wave of "good mornings" at work.
18:46:10 <shapr> dylan: me too
18:46:14 <shapr> But I work ALONE
18:46:19 * shapr boings
18:46:34 <shapr> Did you know that hours of Haskell hacking tends to improve the overall mood?
18:46:41 <dylan> I'm an IT department. Being eccentric is part of the job.
18:46:46 <shapr> I do so love getting the chance to do a good job with a good tool.
18:47:02 <SamB_XP> dylan: a whole department?
18:47:07 <skew> or even just reading about cool things while writing bad code
18:47:34 <shapr> hah
18:47:34 <skew> like "oh, someday I'll use HaskellDB and ByteString and it will be just as fast, but cool and elegant"
18:47:46 <dylan> SamB_XP: Basically, yes. There's the Operations Manager & IT, but when people talk about the IT department it is usually equiv. to me.
18:47:55 <skew> or, I really really enjoyed "Scrap your boilerplate: revolutions"
18:47:58 <SamB_XP> ah
18:48:18 <dylan> SamB_XP: I get to make department-wide edicts, too.
18:48:21 <skew> defining the data type of which gfoldl is the catamorphism, and going from there
18:48:25 <skew> so pretty
18:49:41 <dylan> I can't use haskell, though... as my boss already worries about not being able to find perl (or python or any non-java non-.NET language) coders should I have a nervous breakdown or die or move.
18:50:23 <shapr> Go self employed, then charge your boss less money to write the same applications in half the time with Haskell.
18:50:26 <SamB_XP> he is worried about finding perl programmers?
18:50:27 <skew> I see you forestalled jokes about perl with the parenthetical aside
18:50:38 <SamB_XP> you did tell him where they hang out, right?
18:50:42 <shapr> With the huge amount of left over time you can get other jobs, or just sit outside and relax.
18:50:48 <dylan> shapr: I did that for the last 4 years, and I am happily non-self-employed now.
18:50:58 <shapr> oh
18:51:00 <skew> dylan: with the Haskell and all?
18:51:03 <dylan> I still do random stuff on the side, though.
18:51:09 <vininim> don't worry, I can take over if it pays good.
18:51:17 <dylan> skew: not with haskell, no. But still, I got to choose the tools. :)
18:51:23 <shapr> Speaking of which, do you live on the beach so I can come visit you? ;-)
18:51:23 <skew> or at least doing things quickly and relaxing?
18:51:41 <dylan> skew: yes. it was relaxing.
18:51:47 <dylan> paying taxes wasn't.
18:51:58 <dylan> also having to find work constant wasn't nice either.
18:51:58 <shapr> dylan: Seriously though, my sister lives near you so I may drop by and put a lambda bumper sticker on your car when you least expect it.
18:52:09 <dylan> shapr: Hah.
18:52:29 <dylan> shapr: I would kidnap you to attend one of the LUG-PIG meetings.
18:52:39 <shapr> Great name
18:53:18 <dylan> PIG == programmer interest group, really an excuse to hang out with people that know something other than their package management system. :P
18:53:28 <shapr> At some point soon my sister is sending me tickets so I can fly down there, so I'll tell you when I know more.
18:53:36 <dylan> Cool.
18:54:00 <shapr> And I don't really have any lambda bumper stickers... does cafepress do bumper stickers?
18:54:16 <shapr> I do have a car for the first time in seven years, I now required Haskell bumper stickers.
18:54:48 <shapr> require*
18:55:12 <shapr> I want some of audreyt's Powered by PhD stickers too.
18:55:22 <Igloo> Honk if you love Monads!
18:55:30 * shapr snickers
18:56:35 <chessguy> i'm glad i don't have any major programming projects left for school, because i'd wanna do them in haskell, which nobody at my uni has heard of
18:57:07 <chessguy> so i just use it to brute-force stuff for my math classes instead
18:57:24 <monochrom> haha
18:57:30 <ice799> zarvok, RES.cmu.edu
18:57:31 <ice799> ?
18:57:34 <ice799> i mean, really.
18:58:17 <zarvok> I am, indeed, at home.
18:58:39 <monochrom> I love monads and arrows.
18:59:09 <monochrom> I don't have a car. can't honk.
18:59:24 <ice799>  /me gives monochrom a car
18:59:26 <ice799> oh
18:59:29 <ice799> my client broke
18:59:35 <ice799> thats too bad
18:59:39 <ice799> i wanted to give you a car.
18:59:44 <monochrom> you have an extra space
18:59:47 <ice799> yeah i know
18:59:53 <ice799> that space bar is just so big
18:59:57 <ice799> and my fingers just so nimble
18:59:57 * monochrom honks
19:00:09 * chessguy honks his nose
19:01:06 <hoopy> that underwater camera isn't really that bad of a deal
19:01:21 <zarvok> is there a good arrows tutorial somewhere?
19:01:31 <hoopy> oops wrong channel
19:02:07 <ice799> zarvok, check out google.com
19:02:14 <ice799> zarvok, i think you can search for stuff on it
19:03:15 <chessguy> ice799, wow what a novel concept
19:03:28 <ice799> chessguy, what a sweet nick
19:03:35 <zarvok> heh, allow me to clarify.  Which tutorial on arrows would people recommend?
19:03:39 <chessguy> why thank you
19:06:54 <Canar> is there anywhere i can find a nice example of binary output in haskell? i've been trying to write a little function to output a sinewave in 16-bit/44100Hz raw PCM that i can work on to support more functions, but I'm kinda stuck. functional programming is new to me.
19:08:09 <shapr> zarvok: Paterson's Fun of Programming chapter is good.
19:09:02 <zarvok> Canar: You might check out the Data.ByteString docs.  They have a tutorial if I recall correctly, and are much faster (better?) than the built ins
19:09:04 <zarvok> @where fps
19:09:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:09:11 <zarvok> check there
19:09:15 <zarvok> shapr: thanks, I'll check it out
19:09:35 <Canar> Data.Bytestream, eh? Thanks for the pointer, zarvok
19:09:46 <zarvok> err
19:09:55 <zarvok> Data.ByteString.  Close :)
19:09:56 <Canar> ByteString
19:09:57 <Canar> blah
19:10:02 <Canar> :)
19:12:34 <Cale> If you have an extremely recent GHC release, then Data.ByteString is included.
19:13:11 <Cale> (GHC 6.6 was released yesterday)
19:13:41 * Cale wonders when there will be a debian/ubuntu package for it :)
19:14:00 <Cale> I should probably add the Haskell-experimental repository to my list.
19:14:44 <Igloo> Are you on the Debuan Haskell list?
19:14:50 <Cale> nope
19:15:09 <SamB_XP> the Debuan Haskell list? ;-P?
19:15:25 <Igloo> http://urchin.earth.li/mailman/listinfo/debian-haskell
19:15:30 <lambdabot> Title: debian-haskell Info Page, http://tinyurl.com/uxdrq
19:15:56 <Cale> aha, there we go :)
19:27:33 <Cale> hmm, libc6 version conflict installing those
19:27:43 <satan> hello all, i'm trying to redefine takeWhile using foldr
19:27:46 <Cale>   ghc6: Depends: libc6 (>= 2.3.6-6) but 2.3.6-0ubuntu20 is to be installed
19:27:57 <Cale> satan: okay
19:28:08 <satan> but i don't know how to stop on finding an element that doesnt match
19:28:36 <satan> as in, if my function is twf, then twf even [2,4,6,1,5,6] returns [2,4,6,6]
19:28:48 <satan> while it should just return [2,4,6] to be correct
19:29:20 <Cale> yeah, you've written filter, perhaps
19:29:35 <satan> since foldr is right associative, it starts at the last element, which is confusing me perhaps
19:29:39 <satan> yes i think so :(
19:30:08 <Cale> no, it starts at the beginning :)
19:30:18 <Cale> it replaces each (:) in the list with the function you supply
19:30:22 <satan> oh
19:30:29 <Cale> and the [] at the end with the value you supply
19:30:30 <satan> right
19:30:33 <satan> right
19:30:49 <Canar> okay... where do i find the data.bytestring docs?
19:30:57 <Cale> first of all, let's write takeWhile in an ordinary recursive way
19:31:04 <satan> right, i did that
19:31:06 <Cale> takeWhile p [] = ...
19:31:10 <Cale> takeWhile p (x:xs) = ...
19:31:21 <satan> this is what i wrote: tw p (x:xs)= if p x then x: tw p xs else []
19:31:35 <Cale> Canar: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
19:31:38 <lambdabot> http://tinyurl.com/y58jn8
19:31:44 <Canar> thanks Cale
19:31:55 <satan> and it seems to work, the recursive one i wrote, i mean
19:32:07 <Cale> Canar: the sublibraries are also documented, but you'll have to go up a level to see them, I think
19:32:13 <Cale> satan: okay
19:32:43 <Cale> so what does the function you pass to foldr do?
19:33:09 <satan> http://nanobin.nanosouffle.net/1743
19:33:12 <lambdabot> Title: nanoPaste your Crap
19:33:13 <Cale> It combines the first element of the input list with the solution to the subproblem consisting of the rest of the list.
19:33:19 <satan> it checks if ...
19:33:24 <satan> right
19:33:59 <Cale> So, if the element it's passed satisfies the predicate, then the result should be just to cons that onto the solution for the remainder
19:34:13 <Cale> (which is passed to it as a parameter
19:34:14 <Cale> )
19:34:21 <Cale> and if not, well, then the list is empty
19:34:25 <Cale> right?
19:34:32 <satan> correct
19:35:04 <Cale> foldr (\x xs -> if p x then x : xs else []) ...
19:35:20 <Cale> and in the case that the input list is empty, well, we return the empty list
19:35:24 <Cale> foldr (\x xs -> if p x then x : xs else []) []
19:35:26 <satan> hmmm
19:36:21 <Cale> Note the similarity between this and the recursive program you wrote.
19:36:26 <satan> right
19:36:45 <satan> ok i'll try it again
19:37:18 <satan> thanks for your help, Cale i wish there was some way to thank you heh, you've helped me a lot
19:37:26 <Cale> this turns into a filter if instead of resulting in the empty list in that 'else' there, you put xs instead
19:37:27 <satan> i'll be back in a bit
19:38:23 <Cale> satan: you're quite welcome
19:39:48 <Cale> Igloo: would it be safe to override the libc6 version dependency? It seems like a pretty minor version change, but who knows what's been done to the library :)
19:41:22 <Cale> Igloo: er, hmm... it seems like other packages have been doing that in order to be compatible with both debian and ubuntu. Namely, replacing the dependency on libc6 (>= 2.3.6-6) with (>= 2.3.6)
20:00:21 * SamB_XP wonders why his physics teacher has posted the solutions to problems we aren't supposed to have turned in yet...
20:00:34 * SamB_XP unscrupulously prints them out
20:00:59 <SamB_XP> his handwriting might be a problem though...
20:03:21 <SamB_XP> oh rats
20:03:34 <SamB_XP> my mom turned off her computer and the printer is on that :-(
20:03:45 <SamB_XP> oh well... I'll do that tomorrow I guess...
20:04:22 <ThreeQ> is anyone else using ghc 6.6 on os x ppc?
20:05:17 * scsibug is
20:05:27 <ThreeQ> scsibug: does backspace work in ghci for you
20:05:43 <scsibug> hah, no, it does not
20:06:01 <ThreeQ> argh
20:06:08 <scsibug> all my emacs key bindings are mucked up
20:06:56 <scsibug> ya, this needs to be fixed asap ;)
20:07:09 <SamB_XP> ... building without readline is it?
20:07:34 <scsibug> looks like it, although I deleted my 1GB build directory a few hours ago :(
20:09:37 <scsibug> I could have sworn it all worked when I built 6.4.2 though, on the same machine
20:10:54 <SamB_XP> it is quite possible!
20:11:32 <scsibug> I'm about to start my ghc build again with a newly-built copy of readline, and we'll see if that works
20:11:38 <ThreeQ> maybe ghci wants a newer version of readline now?
20:11:56 <ThreeQ> yeah
20:12:11 * ThreeQ builds readline 5.2
20:13:04 <scsibug> ThreeQ: are you building GHC with ALUT or OpenAL?
20:13:28 <ThreeQ> scsibug: whatever the default is
20:13:44 <ThreeQ> I just ./configure; make; sudo make install'd
20:13:53 <scsibug> k, i'd been disabling those, but maybe they work in 6.6 now...cool
20:14:42 <zention> someone has finally added a vertical split to screen
20:14:56 <scsibug> ThreeQ, you may want to take a look at this, as far as getting GHC to use the proper readline: http://hackage.haskell.org/trac/ghc/ticket/766
20:15:00 <lambdabot> Title: #766 (GHC 6.4.2 won't build on Mac OS X) - GHC - Trac, http://tinyurl.com/yaql8u
20:17:40 <ThreeQ> scsibug: thanks!
20:18:26 <scsibug> What machine are you on?  (dual 2.3 g5 here)
20:19:40 <kpreid> Anyone care to prettify this?
20:19:41 <kpreid> a `finally` b = do c <- liftM return a `catchError` (\e -> do b; return (throwError e)); b; c
20:25:11 <ThreeQ> that's odd...
20:25:13 <ThreeQ> Main.hs:19:0:
20:25:13 <ThreeQ>     Bad interface file: ../../compat/Distribution/InstalledPackageInfo.hi
20:25:13 <ThreeQ>         mismatched interface file versions: expected 6060, found 6
20:25:47 <ThreeQ> is it safe to just change the version, do you think?
20:25:55 <ThreeQ> this didn't come up the first time I built it...
20:25:57 <ThreeQ> seems unrelated
20:26:41 <ThreeQ> oh, maybe I should try building with ghc-6.4.1 instead of ghc-6.6
20:27:50 <scsibug> Audrey's package for osx/intel has a "post-install script that fixes readline..."
20:28:27 <ThreeQ> in the .pkg?
20:29:07 <scsibug> it's a straight tar.bz2, no osx shenanigans
20:29:16 <ThreeQ> oh
20:31:50 <scsibug> looks interesting, I'll post it in a second and save you the download
20:32:29 <lisppaste2> scsibug pasted "audreyt's ghc post-install" at http://paste.lisp.org/display/27872
20:34:53 <ThreeQ> that's just installing a newer version of readline locally...
20:35:08 <ThreeQ> from a directory in the package
20:46:17 <scsibug> ya, i suppose she had already linked against that during her build
20:59:12 <Canar> is there anywhere i can find more simple haskell programs like http://www.haskell.org/hawiki/CatInHaskell and http://www.haskell.org/hawiki/CodeExamples ?
20:59:14 <lambdabot> Title: CatInHaskell - The Haskell Wiki
21:00:14 <Pseudonym> Canar: http://www.haskell.org/haskellwiki/Category:Tutorials
21:00:18 <lambdabot> Title: Category:Tutorials - HaskellWiki, http://tinyurl.com/y2jucx
21:00:18 <Pseudonym> There's some cool stuff there.
21:00:25 <Pseudonym> "Roll your own IRC bot" is especially nice.
21:00:53 <lambdabot> Usurper.
21:00:58 <Pseudonym> Shut up lambdabot,.
21:02:13 <Canar> hm, thanks Pseudonym, that's pretty much what i was looking for... the implementations of cat blew my imperative mind
21:04:26 <JohnMeacham> sweet. for the first time in a long time, jhc has no horrible bugs I am putting off fixing. still missing features, and unknown bugs. but this is good.
21:04:39 <Lemmih> yay
21:04:42 <Pseudonym> Clearly you haven't tested it enough.
21:04:45 <JohnMeacham> used once analysis or region inference. that is the question.
21:06:00 <JohnMeacham> Well, it is more that I knew several things were broken for a long time, but for various reasons thought they would be too annoying to fix because it would involve pervasive changes, so piled workarounds on top of them. I finally said screw it, I'm gonna fix those. and I did. and it was annoying. but that's okay, it cleaned things up a lot.
21:06:44 <Korollary> You did a good deed today, son.
21:06:55 <Pseudonym> JohnMeacham++
21:10:30 <JohnMeacham> yeah. mainly, I had to change the fundamental representation of type constructors. if you have something like 'newtype Foo = Foo (Int -> Int)  then what is the type of a Foo applied to an Int? without knowing what is inside a newtype, you can't figure it out. so I had to either pre-expand every newtype (which was bad because it messed with rule matching, made the intermediate code uglier and didn't play well with recurs
21:10:31 <JohnMeacham> ive newtypes) or pass a data table around everywhere I mihht want to take the type of an application... I decided to bite the bullet and add a field to LitCons containing its type expansion, even though it involved changes to thousands of lines of code. (though, crafty regexes made it not as bad as it could have been)
21:10:59 * Korollary pours JohnMeacham a hard drink
21:11:06 <audreyt> JohnMeacham++
21:11:09 <Pseudonym> Isn't that illegal?
21:11:17 <audreyt> not on IRC
21:11:29 <Pseudonym> No, I mean applying an argument to a newtype.
21:11:34 * Korollary is sad that he's going to miss audreyt's talk at amzn later this month.
21:11:36 <Pseudonym> @let newtype Foo = Foo (Int -> Int)
21:11:36 <lambdabot> Invalid declaration
21:11:42 <Pseudonym> Dammit/
21:11:56 <audreyt> Korollary: oh, you're @amazon.com?
21:12:06 <JohnMeacham> I also need to bring unboxed types to first class status in the type system. they are treated somewhat ad-hocly now, but a more advanced PTS can handle them natively. that is not immediately important though, but might be once I start mucking with the type checker.
21:12:19 * Korollary nods
21:12:58 <Pseudonym> *Main> :t (Foo id) 3
21:12:58 <Pseudonym> Couldn't match `Foo' against `t -> t1'
21:13:02 <Pseudonym> That's what I expected.
21:13:17 <JohnMeacham> oh, in jhc core, the newtype's are discarded at the term level, but kept at the type level. so you can just apply a 'Foo' to an Int in jhc core and it should do the right thing.
21:13:19 <JohnMeacham> now it does.
21:13:28 <Pseudonym> Ah.
21:13:35 <Pseudonym> Now, see, I think this is actually a fault in GRIN.
21:13:43 <audreyt> Korollary: I wonder how I managed to let them talk me into giving two talks :)
21:13:49 <Pseudonym> IMO it should keep type information.
21:13:58 <Pseudonym> It's not like it costs much.
21:13:59 <JohnMeacham> hrm? this is well before grin, and is exactly what ghc does.
21:14:15 <Pseudonym> Really?
21:14:18 <JohnMeacham> well, actually I maintain more type information than ghc does in this case.
21:14:22 <Pseudonym> So... what if the newtype is recursive?
21:15:01 <audreyt> JohnMeacham: the GHC core now uses a `Cast` node instead of discarding the newtype head I believe
21:15:43 <JohnMeacham> I do a loop breakers analysis and choose a minimum set of newtypes to promote to concrete types. I am not exactly sure what ghc does with them, but I have read enough  comments in the code griping about them that they are tricky there too :)
21:15:59 <Korollary> audreyt: we voted on them, and there was a tie.
21:16:15 <audreyt> Korollary: so I heard, but I also heard it wasn't a tie until the very last day
21:16:39 <audreyt> and somehow a bunch of lambdapeople showed up and voted on the Pugs talk
21:16:44 <audreyt> and then it became a tie :)
21:16:58 <Korollary> yes, we informed each other at the SeaFunc meeting
21:16:59 <JohnMeacham> yeah, I think that is just for recursive newtypes, like I do. I used to do explicit casting everywhere, but it really inhibts or complicates optimizations. and I lose no type information this way actually, the newtypes are still kept at the type level, but the term level reflects reality, that they do have isomorphic representations.
21:17:08 <Pseudonym> I find "Cast" nodes easier to believe, because they wouldn't break Core lint quite as badly.
21:17:40 * Pseudonym nods
21:17:41 <JohnMeacham> ghc can discard all newtypes safely (except for recursive ones)
21:17:47 <Pseudonym> Yes.
21:17:52 <Pseudonym> Fair enough.
21:17:58 <JohnMeacham> jhc can't because it needs them to choose the right type class methods.
21:18:32 <Pseudonym> And GHC doesn't because it's based on System F?
21:19:40 <JohnMeacham> no, because it uses a wholely different implemenattion of type classes. jhc and ghc (+ gadts) are both perfectly capable of implementing each others method in theory.
21:20:03 <Pseudonym> Ah, OK.
21:21:01 <JohnMeacham> ghc completely desugars classes away right at the begining, and can discard newtype information right then. jhc does a case scrutinization of the actual type passed around in core so it needs to reflect its "true" type.
21:21:50 <audreyt> Korollary: SeaFunc = SeaLUG' right?
21:26:12 <JohnMeacham> I actually want to integrate subtyping into my PTS. not sure how easy that will be though.
21:27:47 <JohnMeacham> are there any PTS experts around? how important is it for them to be injective? mine is functional, but not injective.
21:28:27 <dolio> edwardk might be able to answer that sort of question.
21:29:19 <JohnMeacham> it is almost, but not quite, powerful enough to express mixed strict and lazy code. the main issue is what is the kind of (Int -> Int)? * or #? (as in, is _|_ a member of it?) I don't see an easy solution other than creating two types of pi. which I really don't want to do.
21:29:31 <JohnMeacham> but some sort of subtyping might get me out of the rut.
21:31:30 <chessguy> what's PTS?
21:31:46 <JohnMeacham> pure type systems, a generalization of the lambda cube.
21:31:49 <hyrax42> wow... this was annoying:
21:31:53 <hyrax42> ?type let f pl = ((maybe True (pl/=).fst).snd) in f
21:31:55 <lambdabot> forall a a1 b. (Eq a) => a -> (a1, (Maybe a, b)) -> Bool
21:32:04 <JohnMeacham> they are cool. :)
21:32:05 <hyrax42> ?type let f pl = ((maybe True ((pl/=).fst)).snd) in f
21:32:07 <lambdabot> forall a a1 b. (Eq a) => a -> (a1, Maybe (a, b)) -> Bool
21:32:09 <dolio> I guess he's not around at the moment (and apparently my nick list has disappeared from my client). :)
21:32:50 <hyrax42> oh you can drop the outer parens in the excerpt
21:33:14 <shapr> Golly Haskell can be compact and hard to read... even after years of reading it.
21:33:32 <hyrax42> associativity of (.) always throws me off
21:33:45 <hyrax42> shapr: sorry, if that was referring to what I wrote
21:33:58 <shapr> No, referring to something inside HAppS actually.
21:34:10 <hyrax42> oh that code I glanced at at some point
21:34:37 <hyrax42> was pretty terse
21:34:42 <hyrax42> non-descriptive variable names
21:34:45 <hyrax42> no type signatures
21:34:53 <shapr> Well, it has lots of type sigs now.
21:34:56 <hyrax42> oh ok
21:35:05 <shapr> And I know exactly what the code does. I just don't understand what it's doing.
21:35:21 <potyka> :)
21:35:21 <hyrax42> but iirc you're lucky if you get a variable name with more than 2 letters
21:35:57 <shapr> @paste
21:35:58 <lambdabot> http://paste.lisp.org/new/haskell
21:36:22 <dylan> @docs System
21:36:22 <lambdabot> System not available
21:36:30 <lisppaste2> shapr pasted "some sort of accumulator?" at http://paste.lisp.org/display/27876
21:37:06 <hyrax42> type problems are annoying until you fix ti
21:37:10 <hyrax42> them
21:37:18 <hyrax42> then you're just happy because you know it works
21:37:56 <shapr> Those three lines look like value recursion or something, could someone clueful explain them to me?
21:39:25 <Pseudonym> It looks to me just like a foldl insert into a map.
21:39:41 <hyrax42> what does the hash do in that case
21:39:44 <hyrax42> ", "#
21:39:44 <hyrax42> ?
21:39:50 <shapr> unboxed string, I think.
21:39:59 <Pseudonym> > "Hello world"#
21:39:59 <lambdabot>  Parse error
21:40:09 <Pseudonym> Oh, that's right, no GHC exts.
21:40:10 <shapr> the upa is ByteString.unsafePackAddress
21:40:32 <Pseudonym> GHC.Prim.Addr@
21:40:35 <Pseudonym> GHC.Prim.Addr#
21:40:39 <hyrax42> ?docs ByteString
21:40:40 <lambdabot> ByteString not available
21:40:57 <hyrax42> not sure what upa actually does
21:40:58 <hyrax42> ?where fps
21:40:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:41:04 <shapr> @docs GHC.Prim.Addr#
21:41:04 <lambdabot> GHC.Prim.Addr# not available
21:41:24 <Pseudonym> @kind GHC.Prim.Addr@
21:41:25 <lambdabot> parse error on input `@'
21:41:26 <Pseudonym> @kind GHC.Prim.Addr#
21:41:27 <lambdabot> #
21:42:41 <hyrax42> oh ok
21:42:55 <shapr> konichiwa jmuk
21:43:02 <Pseudonym> AFAICT it's pretty much this:
21:43:10 <jmuk> hello,
21:43:16 <dolio> It appears to take an assoc list to a map, where values with duplicate keys become comma separated strings.
21:43:21 <Pseudonym> combineHeaders :: [(String,String)] -> Map String String
21:43:23 <hyrax42> shapr: so it
21:43:25 <hyrax42> oh
21:43:28 <shapr> jmuk: Have you gotten your Google t-shirt?
21:43:30 <hyrax42> what dolio just said
21:43:32 <Pseudonym> combineHeaders = foldl' w empty
21:43:39 <jmuk> shapr: not yet
21:43:41 <Pseudonym>     where w m (k,v) = insert k v m
21:43:44 <Pseudonym> With stuff added.
21:43:51 <shapr> I got my t-shirt, it looks nice.
21:44:11 <hyrax42> long or short t?
21:44:29 <shapr> It's a short sleeved t-shirt.
21:44:31 <jmuk> Wow, I am waiting it...
21:44:42 <shapr> dolio, Pseudonym: thanks.
21:49:15 <hyrax42> ?hoogle assert
21:49:15 <lambdabot> Control.Exception.assert :: Bool -> a -> a
21:49:16 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
21:49:16 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
21:56:08 <hyrax42> ?fptools Control.Monad
21:56:08 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
22:10:15 <hyrax42> note to self: comments/documentation aids readability of code
22:10:33 <hyrax42> :/
22:12:46 <dolio> No way, that's all hype.
22:13:22 <dolio> Just make your variable/function names like 8 words long each describing what they do.
22:14:14 <hyrax42> dolio: or that
22:14:23 <dolio> :)
22:14:48 <hyrax42> M-/ can help
22:14:50 <hyrax42> a little
22:15:07 <hyrax42> anyway quick question
22:15:16 <lispy> hyrax42: sorry
22:15:19 <lispy> hyrax42: not allowed :(
22:15:30 <hyrax42> for haddock docs, should I escape single quotes that are intended to be apostrophes
22:15:36 <hyrax42> lispy: :(
22:16:05 <lispy> hyrax42: ya
22:16:11 <lispy> \'this is quoted\'
22:16:20 <lispy> oh
22:16:28 <hyrax42> 'this' will generate a link to the @this@ function?
22:16:28 <lispy> but i think if there is a space it assumse you mean quotes
22:16:43 <lispy> hyrax42: right
22:16:56 <lispy> but 'this won't generate a link to the @this@ function
22:16:57 <hyrax42> if I could actually *run* haddock, I'd be able to just test and see
22:17:12 <lispy> what happens if you try to run it?
22:17:25 <hyrax42> complains about lack of docs for standard lib functions
22:17:42 <lispy> just warnings ?
22:20:39 <hyrax42> lispy: just warnings, but then there are no links to the lib functions/types/classe
22:21:13 <lispy> hyrax42: ah yeah, i just ignore that
22:21:23 <hyrax42> but I want them linked :(
22:21:36 <lispy> i have no idea how to get haddock to do that
22:21:44 <hyrax42> well i brought it up before
22:21:57 <hyrax42> someone mentioned you need a generated interface file for them
22:22:41 <hyrax42> but I haven't looked into it more
22:22:46 <hyrax42> will let you know if I solve it
22:25:54 <lispy> haddock could use some work
22:26:02 <lispy> older versions would give you a link to the parent module
22:26:09 <lispy> current version lacks this and it drives me nuts
22:26:23 <lispy> but i guess it's not even a 1.0 yet
22:27:05 <hyrax42> ugh
22:27:11 <hyrax42> haskelldoc mailing list full of spam
22:27:16 <gour> have you seen http://www.oreillynet.com/ruby/blog/2006/10/ruby_declared_mainstream.html ?
22:27:19 <lambdabot> http://tinyurl.com/y7tst2
22:27:33 <lispy> gour: oreilly spam?
22:27:43 <hyrax42> huh?
22:27:49 <gour> on http://www.tiobe.com/tpci.htm list, haskell is #47
22:27:52 <lambdabot> Title: TPCI - TIOBE Programming Community Index
22:28:13 <hyrax42> lispy: http://www.haskell.org//pipermail/haskelldoc/2005-February/thread.html
22:28:15 <lambdabot> Title: The HaskellDoc February 2005 Archive by thread, http://tinyurl.com/yhbnln
22:28:16 <hyrax42> that kind of spam
22:28:27 <gour> lispy: not intentionally
22:29:09 <lispy> gour: i just mean, ruby gets declared mainstream, but by oreilly so who cares :)
22:29:24 <hyrax42> oh lispy I thought you were asking me about what type of spam
22:29:26 <hyrax42> on the list
22:29:28 <hyrax42> woops
22:29:33 <lispy> ah
22:29:50 <gour> lispy: tiobe is oreilly ?
22:31:00 <lispy> gour: ah, the first link was an oreilly.net link
22:31:24 <gour> lispy: yes, but just reports from another one. take a look...
22:31:42 <lispy> what is SAS, i've never even heard of it
22:33:07 <lispy> this language? http://support.sas.com/ctx/samples/index.jsp?sid=188&tab=code
22:33:11 <lambdabot> Title: SAS Sample 188 : Scanning for words in a string, http://tinyurl.com/y86er8
22:33:12 <goltrpoat> some data modelling/analysis dealy, looks like
22:33:17 <lispy> funny it would be so high and i've never heard of it
22:34:35 <lispy> huh, out of the top 10 i would say about half are static typed and half i would call dynamic typed
22:34:38 <lispy> that's interesting
22:34:49 <lispy> i would have expected dynamic languages to be en vogue at the moment
22:35:18 <lispy> after all you can finally stop worrying about types and just get work done...
22:36:38 <gour> statically languages are making 60.9%
22:37:30 <goltrpoat> what dynamic languages are en vogue right now?
22:37:45 <goltrpoat> i'd say most languages that are "en vogue" are either statically typed, or advertise as being statically typed
22:37:56 <lispy> goltrpoat: i keep hearing so much praise for ruby, python and the like
22:38:10 <goltrpoat> oh.  point
22:39:16 <lispy> perhaps it has nothing to do with dynamic typing though
22:39:47 <lispy> although that silver bullet article made some interesting points about how much we really gain from high level languages
22:40:27 <lispy> we gained a lot initially, but refining them to actually make people more productive is very hard and it's easy to make them harder to learn by filling them with features and cool ideas
22:41:30 * lispy upgrades his windows install of ghc
22:53:25 <albertlee> if a function type IO() , all the function use it must be IO ()  ? is it true?
22:54:24 <Cale> albertlee: yes, basically
22:54:41 <Cale> though if something was of type IO (), I wouldn't call it a function at all
22:54:58 <Cale> the only things which are functions are things of type a -> b for some types a and b.
22:56:50 <lispy> albertlee: if the function has type IO () it can internally use something of type IO a, but no value can escape from the function
22:56:57 <lispy> albertlee: take main for example
22:57:04 <lispy> albertlee: it has type main :: IO ()
22:57:20 <lispy> albertlee: but you can open a files which would have some type like IO Handle
22:57:30 <lispy> albertlee: but main can't return an opened file
22:59:08 <Cale> Let's try to emphasise proper terminology here: main isn't a function, it's an action, which you can think of as a sequence of steps to be carried out.
22:59:28 <Cale> (each of which may choose to do some I/O)
23:00:06 <Cale> an IO Handle is an action which results in the production of a Handle
23:00:24 <Cale> You can't write a function of type IO a -> a though.
23:00:44 <albertlee> thank you  I get more clear
23:01:51 <Cale> To access the Handle produced by it, say it's readFile "data", you'd do something like this:
23:02:02 <Cale> er
23:02:08 <Cale> readFile "data" is an IO String :)
23:02:19 <Cale> okay, let's go with that :)
23:02:30 <Cale> We want to use that String in some way
23:02:37 <Cale> So we'd have to run the action
23:02:47 <albertlee> oh~  and I if want a GUI program, and the same data file should be use multi time , what's the proper way?
23:02:48 <Cale> but we can only do this inside of another action
23:03:15 <lispy> Cale: but IO a is a function of type World -> (a, World)
23:03:29 <Cale> lispy: not by the spec it's not
23:04:06 <Cale> It might be, internally, where World is some token produced by the compiler, and enforced in clever ways to be unique.
23:04:48 <Cale> (and which somehow encapsulates the state of the whole machine)
23:05:13 <Cale> but it really doesn't matter how the IO monad is implemented by the compiler
23:05:44 <Cale> there's nothing in the exposed structure which could tell you one way or the other what's going on behind the scenes there
23:06:11 <Cale> albertlee: if I understand you correctly, you'd just open the file a bunch of times with openFile
23:06:57 <Cale> do hdl <- openFile "/path/to/file" ReadMode
23:07:17 <Cale>    xs <- hGetLine hdl
23:07:26 <Cale>    print (reverse xs)
23:07:30 <Cale> for instance :)
23:07:51 <Cale> Obviously, in a GUI program, you'd do something other than printing the first line of the file to the console :)
23:08:27 <Cale> But you're allowed to open the file a whole bunch of times for reading, producing a bunch of handles.
23:08:53 <Cale> that illustrates how to run an action to get the value it produces
23:09:09 <Cale> a simpler example would perhaps be
23:09:19 <Cale> main = do x <- getLine
23:09:32 <Cale>           print x
23:10:42 <Cale> the thing on the right hand side of an "<-" always has to be of type IO a, (or in general, m a for some monad m), and the thing on the left of the <- then becomes type a.
23:11:03 <Cale> and is bound for the remainder of the block, or until it is shadowed by another variable binding.
23:11:27 <Cale> In this case,  getLine :: IO String
23:11:29 <jmob> Anyone have a recommendation for distributed Haskell?
23:11:30 <Cale> so x :: String
23:11:50 <lispy> jmob: what is distributed haskell?
23:13:10 <jmob> lispy: some sort of RPC solution that would allow me to describe how to execute something in parallel, beit over multiple local CPUs or over a network
23:16:50 <lispy> jmob: so you want MPI?
23:17:13 * lispy doesn't understand why RPC would be helpful here
23:17:21 <lispy> and it sounds like you don't want to share memory
23:17:36 <hyrax42> on the graph reduction in GHC:
23:17:44 <hyrax42>  if I assert (isJust x) $ ... fromJust x ...
23:17:56 <lispy> hyrax42: i thought i said you couldn't ask questions ;)
23:18:02 <hyrax42> lispy: :(
23:18:22 <jmob> lispy: I don't know what I want, I want to run programs on multiple CPUs and on multiple network nodes
23:18:26 <hyrax42> well for not-lispy: would the Maybe a that is x be found just once?
23:18:35 <lispy> hyrax42: :)
23:18:52 <hyrax42> or should I use a let?
23:19:11 <lispy> hyrax42: i'd use a let, depending on the compiler to do all that seems sort of iffy
23:19:21 <lispy> hyrax42: or maybe even pattern matching
23:19:32 <lispy> Just x -> ... x ...
23:19:35 <hyrax42> well the matfch would fail
23:19:40 <hyrax42> oh
23:19:45 <hyrax42> let the match failing be my error?
23:20:01 <lispy> Nothing -> error "oops" -- lots of options
23:20:13 <lispy> jmob: it's an interesting questions
23:20:30 <lispy> jmob: haskell has shared memory threads, see concurrent haskell and STM
23:20:58 <hyrax42> hooray
23:20:59 <lispy> jmob: but i think the two models of concurrency that you want are different enough that you may need to combine multiple libraries
23:21:05 <hyrax42> another use for my "takeTillFirst" function
23:21:35 <lispy> takeTillFirst = head . takeWhile . dropWhile ?
23:21:40 <lispy> (not literalyl)
23:21:50 <lispy> or oh
23:22:03 <hyrax42> all the ones up to and *including* the first where predicate holds
23:22:08 <lispy> it's actually pretty much takeWhile right?
23:22:17 <lispy> oh okay
23:22:30 <hyrax42> takeTillFirst even [1,3,5,6,7,8,9,10] = [1,3,5,6]
23:22:57 <lispy> jmob: usually when people run code on a cluster they are using MPI
23:23:28 <lispy> jmob: it's well known and i don't think you have to do a lot which is special to take advantage of it
23:24:03 <shapr> mobarak?
23:24:19 <lispy> shapr: good evening
23:24:34 <shapr> hiya lispy
23:24:38 <hyrax42> ?fptools Prelude
23:24:38 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
23:24:50 <jmob> shapr: ...hrmm?
23:25:07 <hyrax42> Data.List
23:25:08 <shapr> You're a friend of Mr Lefkowitz, aren't you?
23:25:16 <hyrax42> ?fptools Data.List
23:25:17 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
23:25:36 <shapr> Ah yes, I remember...
23:26:13 <jmob> shapr: An acquaintance perhaps, I've conversed with him at PyCon
23:27:22 <jmob> shapr: I believe the "crew" from #python/#twisted stromed a Korean restaurant in DC at one point
23:29:14 <shapr> Do you have a website or blog?
23:30:14 <jmob> shapr: not really
23:30:16 <shapr> Google doesn't find one for you by your full name.
23:30:41 * hyrax42 thinks there should be a format character for show instances in printf
23:31:35 <jmob> shapr: My online presence has diminished since starting a full time job.
23:32:01 <lispy> jmob: i know that feeling
23:32:11 <jmob> shapr: I play with deadbeefbabe.org occasionally... but the most interesting thing there is probably deadbeefbabe.org/mines
23:32:18 <Korollary> lispy: dude.
23:32:29 <lispy> Korollary: duuuuude
23:32:34 * Korollary passes out
23:32:45 <thou> wasted
23:32:47 <jmob> shapr: I never thought anyone would be interested in my ramblings :)
23:33:55 <lispy> Korollary: where's my car?
23:34:29 <Korollary> lispy: whoa?
23:35:15 <shapr> Dude, where's my car?
23:35:25 <shapr> jmob: Ramblings are often worth publishing.
23:36:23 <jmob> shapr: I'm very interested in type systems lately, and I'm in love with Haskell/Erlang
23:36:47 <jmob> lispy: I'm still finishing a degree too
23:36:57 <lispy> jmob: me too!
23:37:09 <jmob> lispy: Why are you on IRC!
23:37:19 * lispy shrugs
23:37:26 <lispy> internet addicition?
23:37:32 <jmob> I know *I* should be studying.
23:37:34 <shapr> I'd like to finish a degree. I do have enough credits for a master's degree at the university that's a few blocks from here.
23:37:58 <lispy> shapr: at my grad school you have to do continuous enrollment to get a grad degree
23:38:10 <defcon8> do you get credits from passing exams or something?
23:38:10 <shapr> I just want an undergrad degree.
23:38:23 <lispy> shapr: meaning..if your school is similar those credits may be null and void...
23:38:25 <shapr> You get credits by successfully completing courses.
23:38:44 <lispy> shapr: oh, you said masters...so i thought...
23:38:51 <shapr> lispy: That would suck. I spent six years taking every class I could that wouldn't lead to a degree.
23:38:59 <shapr> (not on purpose though)
23:39:33 <jmob> I'm working on a bachelors, almost there
23:39:45 <astrolabe> > seq [1..] 3
23:39:47 <lambdabot>  3
23:39:49 <defcon8> is bechalors better than a degree?
23:39:54 <defcon8> I mean undergrad
23:40:05 <defcon8> do they have honours degrees in america?
23:40:13 <astrolabe> To what extent does seq evaluate the [1..] here?
23:40:26 <jmob> defcon8: undergrad degree is a bachelors in th eUS
23:40:27 <Korollary> head only afaik
23:40:33 <defcon8> and what is honours/
23:40:34 <jmob> s/eU/U/
23:40:54 <Korollary> I mean, the fact that [1..] has a head, but not necessarily the value 1. I think.
23:40:54 <jmob> defcon8: you can graduate with honors, but it usually doesn't mean much, except a bullet on your resume
23:40:55 <astrolabe> Korollary thanks
23:41:15 <defcon8> so the first four years is only for a bechalors?
23:41:19 <defcon8> bachelors*
23:41:25 <jmob> defcon8: yes
23:41:26 * astrolabe goes away to think about strictness
23:41:28 <lispy> defcon8: "4" yes
23:41:44 <Korollary> astrolabe: google for strict haskell and deepseq. It's got a good explanation.
23:41:51 * lispy took 5.5 to earn two bachelors at the same time
23:42:09 <jmob> defcon8: ~130 credit hours usually, 2-4 credit hours per class, how every many years that takes, I've been in school for 5.5 years
23:42:23 <lispy> only 130?
23:42:27 <jmob> defcon8: a 40 hour a week job has slowed me down
23:42:30 <lispy> i think my school requires 182 for engineers
23:43:11 <lispy> not that it mattered for me...
23:43:17 <defcon8> jmob, crap :|
23:43:21 <jmob> lispy: I 128 is the university minimum for a degree, not sure about engineering, I knocked a lot of credits with test scores and AP classes.
23:43:38 <ThreeQ> people sometimes graduate in fewer than 4 years though
23:43:47 * defcon8 is thinking of going to glasgow university
23:43:53 <defcon8> instead of cambridge
23:44:00 <defcon8> bah, I dunno
23:44:17 <jmob> http://slashdot.org/article.pl?sid=06/09/20/1552236
23:44:19 <defcon8> I think I can get the grades, but cambridge may be ghey about where I've gotten my education from
23:44:21 <lambdabot> Title: Slashdot | University of Virginia Student Graduates in One Year, http://tinyurl.com/qxgyc
23:44:39 <defcon8> you only need 4 A's in highers and 3 A's in advanced highers :D
23:45:25 <defcon8> glasgow is where ghci came from, I guess :|
23:46:21 <jmob> defcon8: go to Glasgow and get an independant study (or honors project) working on GHC, they you can fix GHC so that it works better on Intel Macs
23:48:00 <defcon8> well, I think living in glasgow is a start, which I do
23:48:12 <defcon8> but I dunno
23:48:17 <defcon8> I should try for cambridge, I think
23:48:36 <lispy> defcon8: sure and if you did want to work on ghc isn't cambridge where the Simons live?
23:49:06 <defcon8> simons?
23:49:51 <jmob> shapr: Do you work for Nokia?
23:50:14 <jmob> shapr: ...or develop applications for maemo?
23:50:31 <Pseudonym> Doesn't everyone in Finland work for Nokia, possibly indirectly?
23:50:53 <Korollary> or Absolut?
23:51:00 <Pseudonym> Oh, true!
23:51:04 <defcon8> vodka!
23:51:18 * Pseudonym imagines an ABSOLUT NOKIA advert would probably sum up the country
23:51:19 <satan> how would i remove duplicates from a list using foldr?
23:52:06 <Pseudonym> Oh, hang on.  Absolut is Swedish.
23:52:24 <Pseudonym> So it'd be ABSOLUT ERICSSON
23:52:48 <Pseudonym> But Sweden also has ABBA.  And Saab.
23:52:59 <Pseudonym> And hats with horns.
23:53:33 <Korollary> I think there's Finlandia Vodka ?
23:53:39 <thou> satan: you don't want to use filter?
23:53:46 <Pseudonym> Oh, yes, Finland has Sibelius.
23:53:47 <lispy> satan: sounds like homework :)
23:54:07 <lispy> defcon8: simon peyton jones and simon marlow both work on ghc
23:54:07 <satan> thou: nope, it says to use foldr or foldl
23:54:10 <Pseudonym> Or had, rather.
23:54:26 <satan> lispy: its from this book on haskell i've been using to teach myself haskell
23:54:33 <satan> i'm doing all the exercises
23:54:38 <lispy> satan: suppose the list were sorted
23:54:54 <lispy> satan: and foldr lets you look at adjacent elements
23:54:58 <lispy> satan: any ideas now?
23:55:16 <satan> if they're equal, drop the one of the right and move on to the remainder of the list
23:55:49 <lispy> satan: so can you assume sorted?
23:55:55 <satan> hmm it actually says to remove adjacent duplicates using foldr, so it'll work
23:56:04 <lispy> nice
23:56:07 <satan> nope, not sorted, but adjacent duplicates only
23:56:26 <satan> so [1,2,2,3,3,3,1] should give [1,2,3,1]
23:56:37 <lispy> hmmm...but then the type?
23:56:38 <jmob> satan: why can't you sort it yourself? Decorate, sort, remove dupes, un-decorate.
23:56:43 <lispy> ?type foldr
23:56:44 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
23:56:58 <satan> jmob: decorate?
23:57:12 <satan> won't it just be, removeDupes :: [a] -> [a]
23:57:13 <lispy> satan: zip inputlist [0..]
23:57:30 <lispy> satan: then you know which index they were at before sorting
23:57:42 <jmob> > zip [4 5 6 9 2] [1 ..]
23:57:43 <lambdabot>  add an instance declaration for (Num (t -> t1 -> t2 -> t3 -> a))
23:57:44 <lambdabot>   In the...
23:58:01 <lispy> satan: that's a good type (actually Eq a => [a] -> [a]) but how do you get foldr to return a list?
23:58:08 <satan> ok, so this is for removing ALL dupes, not just adjacent ones, right
23:58:13 <Pegazus> what's the most elegant way to multiply 2 matrix A and B represented as [[Int]]
23:58:16 <satan> use the cons operator in there somewhere
23:58:27 <lispy> satan: but look at the type
23:58:32 <lispy> ?type foldr
23:58:34 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
23:58:35 <satan> foldr ((:) . g) [] inputList or whatever
23:58:38 <jmob> > zip [4,5,6,9,2] [1..]
23:58:40 <lambdabot>  [(4,1),(5,2),(6,3),(9,4),(2,5)]
23:58:41 <lispy> suppose b = [a]
23:58:47 <satan> ok
23:58:53 <jmob> ...there's the syntax.
23:59:02 <lispy> forall a. (a -> [a] -> [a]) -> [a] -> [a] -> [a]
23:59:51 <satan> ok
