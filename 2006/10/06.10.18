00:12:31 <roconnor> Why do we need testing and stable for cabal?  Shouldn't the package dependencies tell you what will and will not work together?
00:23:06 <Pseudonym> Because Haskell programs are notoriously buggy and unstable, obviously,.
00:23:40 <Adamant> what's best practice for ensuring bug free Haskell code?
00:23:59 <Adamant> unit tests are probably a good idea.
00:24:26 <kfish> Adamant, "don't put any bugs in in the first place" is the best method
00:24:27 <ibid> Adamant: research requirements well, make a good design, translate the design into good haskell code and test, test and test
00:24:36 <Adamant> not doing things that screw up type checking is another.
00:24:49 <Pseudonym> Making small functions that can be independently tested is a good plan.
00:24:51 <ibid> Adamant: (it's not different from how it works with other languages:)
00:25:00 <Pseudonym> Especially since you can put a type declaration on all of them.
00:25:03 <Adamant> hmm, well then, I am asking more generally
00:25:16 <roconnor> Write the code in Coq and extract Haskell from it (wait do you want to to be fast too?)
00:25:29 <Adamant> I know using strong typing is a good idea, so is unit testing
00:25:51 <therp> I would say hire good programmers is the best bug prevention method.
00:25:51 <Pseudonym> Hiring Haskell programmers gets you 90% of the way there.
00:25:55 <Adamant> roconnor, short of complicated proofs. ":)
00:26:11 <Adamant> Pseudonym, I want to become a Haskell programmer. :)
00:26:34 <Adamant> well, let me rephrase that
00:26:42 <roconnor> Adamant: heh, complicatd proofs are the best way of removing bugs, if only it because it has slowed you down and make you inspect every bit of code.
00:26:46 <roconnor> ;)
00:27:02 <roconnor> @where Hunit
00:27:03 <lambdabot> http://hunit.sourceforge.net/
00:27:05 <Adamant> if you're going to create code with proofs, what is the way to get maximum bang for your buck?
00:27:12 <roconnor> @where quickcheck
00:27:12 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
00:27:23 <roconnor> Those are two useful tools.
00:27:54 <Adamant> i.e. most "important" bugs gone with the least amount of manual proofchecking
00:28:26 <Pseudonym> One of the best lessons I ever learned from a boss is to visually check the _intent_ before compiling.
00:28:47 <Pseudonym> Compilers can find syntax and type errors, but not intent errors.
00:29:36 <Adamant> has anyone applied fuzzing to Haskell? is it even useful?
00:30:12 <roconnor> well, I imagine Haskell isn't supposed to have the buffer overflow of c-style languages...
00:30:24 <Adamant> right, but fuzzing can find crashers.
00:30:46 <roconnor> you might be able to find incomplete pattern matches
00:31:09 <Adamant> that would be something.
00:31:45 <roconnor> I suppose one could try to use GADTs to help safely decide when pattern clauses are unreachable
00:32:36 <Adamant> GADT's?
00:32:43 <roconnor> @where GADT
00:32:43 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
00:34:51 <Adamant> cool.
00:35:00 <Adamant> thanks for all the info. :)
01:14:54 <cwenner> in comment of a haskell assignment i was asked to revise my definition of a function which returns the first object in a list for which a function returns true, or a default value otherwise (i.e. (a -> Bool) -> a -> [a] -> a). I reduced it to tryFindOne f d xs = head (dropWhile (not f) xs ++ [d]) but the way it was phrased, it seems there's something even simpler. Could someone give me a pointer without revealing 
01:16:55 <ibid> yes, there is a very simple solution. hint: use guards and pattern matching
01:17:19 <ibid> (the function should return true for the first element in a list?)
01:17:49 <audreyt> @pl \def f list -> maybe def id (find f list)
01:17:49 <lambdabot> (. find) . (.) . flip maybe id
01:17:54 <audreyt> there you go...
01:18:00 <ibid> (btw, don't talk about objects in a haskell context (unless you're doing using IORefs or something similar)
01:18:11 <ibid> )
01:18:16 <audreyt> cwenner: tryFindOne f d xs = maybe d id (find f xs)
01:18:33 <ibid> audreyt: "without revealing"?
01:18:49 <audreyt> I didn't parse that part...
01:18:54 <audreyt> my apologies.
01:20:01 <ibid> of course, even your solution isn't the simplest one, i think :)
01:20:02 <lispy> what about objects in the context of OOHaskell? ;)
01:20:22 <cwenner> i tried guards and pattern matching initially, that solution was apparantely too complicated. well thanks audrey, i'll try to focus on the existence of a maybe and a find and ignore the rest
01:20:29 <ibid> lispy: i think that qualifies under "something similar" :)
01:21:57 <lispy> ibid: er...OOHaskell is nothing like an ioref...
01:22:03 <lispy> ibid: if that's what you mean by simialr
01:22:03 <cwenner> although find belongs to the List module. He did speak in the context of Prelude
01:22:05 <ibid> lispy: in this case it is :)
01:22:31 <lispy> actually, i can't get OOHaskell to work
01:22:34 <lispy> for some reason reason
01:22:58 <ibid> lispy: i wouldn't talk about objects if they don't have identity, and for identity you need some sort of mutable store (either IORef or a monad hiding a map)
01:23:01 <lispy> if the code is all side by side when you compile then it works, but if you put HList or OOHaskell into its own library it stops type checking
01:23:34 <audreyt> ibid: you consider the term "value objects" oxymoron then?
01:24:11 <ibid> audreyt: in what context?
01:24:22 <audreyt> in CLR or Java
01:24:45 <kzm> What is a 'value object'?
01:24:56 <audreyt> "An object whose conceptual identity is based on a combination of values of its properties."
01:25:25 <kzm> Sounds like a value to me.
01:25:26 <ibid> audreyt: CLR? in java it's part of the language jargon so i don't comment; but in general, yes
01:25:35 <kzm> Is the memory address one of its properties? :-)
01:25:41 <audreyt> no it is not :)
01:25:59 <audreyt> thing is, I think of objects as a closure with many named "apply" functions...
01:26:19 <audreyt> and so the idea of identity is orthognal. but maybe it's a heretical view :)
01:26:45 <kzm> I think objects = value + identity is fairly standard.
01:27:08 <ibid> the OO definition i was taught is object = identity + behavior + state
01:27:34 <ibid> but in any case, outside any particular language jargon, i would not use the term "object" unless there is some identity involved
01:28:37 <ibid> a value object (an object with immutable state) would be a degenerate case
01:28:49 <kzm> I know at least one person who calls this 'object based' and requires inheritance as well for 'object oriented'.
01:28:58 <kzm> Might be local terminology.
01:29:15 <ibid> kzm: the fact is that OO is even worse defined term than FP :)
01:29:36 <ibid> kzm: the definition i gave seems to be the consensus of my local OO gurus
01:29:37 <kzm> You'd still be able to have multiple objects with the same value - and be able to tell the difference, no?
01:29:54 <ibid> kzm: not if the identity is a function of the value
01:29:56 <kzm> Right: just identity and state is just a struct.
01:30:26 <kzm> Well - will you not be able to take the object's address?
01:30:56 <ibid> kzm: depeds on the context. not all languages have an address-of operator
01:31:38 <kzm> Okay.  I'm not familiar enough with this territory.
01:32:06 * ibid tries to be an expert in programming languages :)
01:32:19 <kzm> Usually, languages which support mutable state tend to have different kinds of equality, though - value and identity, for instance.
01:32:29 <kzm> I forget how many Lisp has.
01:32:31 <kzm> :-)
01:32:42 <kzm> = eq eql equal ...
01:32:52 <ibid> true
01:33:05 <kzm> equl eqel eqqal eqquual...
01:33:08 <ibid> but the identity need not be the address
01:33:26 <kzm> I agree.
01:33:29 <ibid> consider for example implementations with a copying garbage collector - the address changes, the identity doesn't
01:34:01 <kzm> What happens if you create two value objects, give them the same value (and thus identity) and mutates one of them?
01:34:03 <musasabi> It seems that the GHC 6.6 MSI (Windows) is shipping with old Cabal instead of the new one (or I have messed something up in a very weird way), can anyone confirm this?
01:34:18 <kzm> Presumably value objects are immutable for that reason?
01:34:30 <ibid> kzm: then you either have demons flying out of your nose or they are not value objects :)
01:34:37 <kzm> musasabi, oh, no, not again! :-P
01:35:12 * kzm checks his nose for demons, and updates his lecture notes.
01:36:01 <musasabi> kzm: hmm?
01:36:22 <lisppaste2> amiddelk pasted "Anyone care to explain why these parentheses matter?" at http://paste.lisp.org/display/28185
01:36:27 <kzm> musasabi, 6.4.1 shipped with a dysf^H^H^H^Hreduced functionality Cabal.
01:37:12 <musasabi> kzm: well 6.6 *should* have shipped with proper cabal.
01:37:49 <kzm> No argument there.
01:37:51 <ibid> kzm: are they readable somewhere?
01:38:13 <kzm> ibid, the demons in my nose, you mean? :-)
01:38:30 <kzm> (the lecture notes are virtual ones.  Sorry)
01:38:30 <ibid> kzm: them too, but i was referring to the lecture notes:)
01:38:41 <ibid> virtual being in your head?
01:38:46 <kzm> Right.
01:38:57 * kzm sneezes.  Damned pitchforks.
01:39:00 <musasabi> http://youzen.b2.fi/~musasabi/a.txt
01:40:34 <kzm> musasabi, what?  I get 1.1.6 on Linux (6.6 binary snapshot)
01:40:46 <musasabi> hmm. 1.6 is not that wrong. But it seems to have some weird functionality difference to the *nix version -> Debug.
01:40:54 * amiddelk points at his paste: http://paste.lisp.org/display/28185. With GHC-6.4.2 the same types are inferred for x and y, but with ghc-6.6 the type for x is different (and is kind of weird?)
01:41:09 <kzm> amiddelk, I looked, but have no explanation.
01:41:32 <musasabi> kzm: true. have to debug this more.
01:43:23 <dblhelix> amiddelk, kzm: I think it's safe to say that it's not "kind of weird", but just plain wrong, right?
01:56:58 <amiddelk> dblhelix: yes, I wonder if this is "intended" behaviour, or if it is a bug. That's why I posted it here, because I want to know if I should make a bug report
02:01:55 <musasabi> hmm wine problems:
02:01:56 <musasabi> Failed: C:\ghc\ghc-6.6\gcc -BC:\ghc\ghc-6.6\gcc-lib/ -E -undef -traditional -v -I C:/ghc/ghc-6.6\include -I C:/ghc/ghc-6.6\include\mingw -D__HASKELL1__=5 -D__GLASGOW_HASKELL__=606 -D__HASKELL98__ -D__CONCURRENT_HASKELL__ -Dmingw32_BUILD_OS=1 -Di386_BUILD_ARCH=1 -Dmingw32_HOST_OS=1 -Di386_HOST_ARCH=1 -x c src/Text/XML/HaXml/Combinators.hs -o C:\windows\temp\ghc8_2\ghc8_2.hscpp fd:-1: hClose: invalid argument (Bad file descriptor)
02:31:55 <Sara|Uni> hi there, just started trying out haskell 2 days ago - and have an error msg I don't understand, can someone help?
02:33:04 <ThreeQ> ?where paste
02:33:04 <lambdabot> http://paste.lisp.org/new/haskell
02:33:04 <Sara|Uni> !help
02:33:28 <ThreeQ> you can use that link to paste the relevant code
02:34:09 <lisppaste2> Sara pasted "Error msg I don't understand" at http://paste.lisp.org/display/28189
02:34:22 <Sara|Uni> http://paste.lisp.org/display/28189
02:34:26 <Sara|Uni> oh
02:34:46 <Sara|Uni> didn't have to paste the link here at all ;)
02:34:53 <ThreeQ> :)
02:35:11 <ThreeQ> oh, try indenting the guard lines further
02:35:35 <ThreeQ> so that they go past the starting character of convertToBlock'
02:35:57 <Sara|Uni> argh
02:36:03 <Sara|Uni> didn't know that!
02:36:05 <Sara|Uni> thaks
02:36:07 <Sara|Uni> thanks
02:36:10 <ThreeQ> sure
02:36:10 <ThreeQ> oh
02:36:20 <ThreeQ> and there's a problem with the type too
02:36:25 <Sara|Uni> yeah, can see that now
02:36:30 <ThreeQ> Num -> Integral -> Integral -> [Integral] isn't a valid type
02:36:38 <ThreeQ> because all those are names of classes, not types
02:37:02 <Sara|Uni> yeah, changed everything to Integer
02:37:14 <ThreeQ> you can say convertToBlock :: (Num a, Integral b) => a -> b -> b -> [b]
02:37:15 <Sara|Uni> thanks a ton
02:37:18 <ThreeQ> or you could do that too
02:37:57 <Sara|Uni> btw is there a function that given a number (say decimal) gives me the same number to another base
02:38:17 <Sara|Uni> couldn't find one at http://www.zvon.org/other/haskell/Outputglobal/index.html
02:38:20 <lambdabot> Title: Haskell, http://tinyurl.com/fuqg8
02:38:49 <ThreeQ> well technically the number isn't in any base
02:38:54 <ThreeQ> but if you want to output it in a different base
02:38:59 <ThreeQ> ?type showHex
02:39:00 <lambdabot> forall a. (Integral a) => a -> ShowS
02:39:08 <ThreeQ> ?type showOct
02:39:09 <lambdabot> forall a. (Integral a) => a -> ShowS
02:39:13 <ThreeQ> ?type showIntAtBase
02:39:15 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> ShowS
02:39:34 <ThreeQ> you can turn a number into a hex or octal or any base string
02:39:41 <ThreeQ> > showHex 1234
02:39:43 <lambdabot>  <[Char] -> [Char]>
02:39:51 <ThreeQ> > showHex 1234 :: String
02:39:52 <lambdabot>    Expecting a function type, but found `[Char]'
02:39:53 <lambdabot>    Expected type: Strin...
02:40:00 <ThreeQ> hmm
02:40:06 * ThreeQ has no clue what the ShowS type is
02:40:09 <Sara|Uni> :)
02:40:14 <Sara|Uni> was wondering that myself
02:40:27 <ThreeQ> > showHex 1234 ""
02:40:28 <lambdabot>  "4d2"
02:40:36 <ThreeQ> > showHex 1234 "blah blah "
02:40:37 <lambdabot>  "4d2blah blah "
02:40:47 <ThreeQ> oh, okay
02:41:07 <ThreeQ> you give it a string argument, and it prepends
02:41:19 <ThreeQ> I'm not sure how that's useful, but there you go
02:41:24 <Sara|Uni> thanks :)
02:41:30 <Sara|Uni> I guess I'll stick to my function for now
02:41:34 <ThreeQ> alright :)
02:41:45 <Sara|Uni> I have a given block length... so I think that's ok for now
02:42:00 <ThreeQ> none of the real haskell gurus are awake, I guess
02:42:28 <ThreeQ> now I'm curious about the point of ShowS
02:42:44 <ThreeQ> oh, it's right here in the docs
02:42:45 <ThreeQ> "This allows constant-time concatenation of results using function composition."
02:46:31 <araujo> morning!
02:59:37 <musasabi> Does {-# INLINE make {-# SPECIALIZE superfluous?
03:06:32 <musasabi> (that is if a polymorphic function is tagged {-# INLINE should it be specialized too?)
03:13:44 <Sara|Uni> Hi there, given an Integer, how can I convert it to Int?
03:15:16 <ValarQ> fromIntegral maybe?
03:15:39 <Sara|Uni> nope
03:15:48 <ValarQ> > (fromIntegral (20::Integer))::Int
03:15:50 <lambdabot>  20
03:15:54 <Sara|Uni> tried that already :(
03:16:12 <ValarQ> seems to work
03:16:29 <Sara|Uni> ....wait a sec.... you tell it which types you want? ...smart
03:16:56 <Sara|Uni> so if I want to use it with map...
03:17:09 <Sara|Uni> how do I tell it to expect an Integer and return an Int?
03:17:26 <ValarQ> > (map fromIntegral ([20,5]::[Integer]))::[Int] -- like this?
03:17:27 <lambdabot>  [20,5]
03:17:31 <Sara|Uni> map chr.fromIntegral xs
03:18:00 <musasabi> map (chr . fromIntegral) xs
03:18:21 <Sara|Uni> ah nice
03:18:31 <Sara|Uni> VOL INUF ENOITCRP LAMARGO,GNIM\GSjCn\844UOY T?
03:18:40 <ValarQ> Sara|Uni: what?
03:18:42 <Sara|Uni> think I didn't crack the rsa code yet...
03:18:44 <Sara|Uni> ;)
03:18:48 <ValarQ> oh
03:27:09 <fasta> What a wonderful error message: Parse error in pattern <line:column>
03:27:36 <Sara|Uni> ah! got it!
03:27:46 <Sara|Uni> "I LOVE FUNCTIONAL PROGRAMMING,\844nCj\GST YOU\NUL\NUL\NUL\NUL?"
03:27:50 <xerox> Does it look exactly like "<line:column>" or are there actual numbers, fasta?
03:28:07 <Sara|Uni> whats \844nCj\GST
03:28:30 <fasta> xerox: no, there are actual numbers.
03:28:43 <fasta> xerox: It's in an if expression which looks trivially correct.
03:28:49 <xerox> > map (:[]) "\844ncj\GST"
03:28:50 <lambdabot>  ["\844","n","c","j","\GS","T"]
03:28:58 <xerox> You see, Sara|Uni?
03:29:16 <Sara|Uni> ok, more precicely, whats \844
03:29:18 <Sara|Uni> whats \GS
03:29:40 <xerox> > map ord "\844\GS"
03:29:41 <lambdabot>  [844,29]
03:29:52 <xerox> The 844th and 29th chars (:
03:30:00 <fasta> xerox: The problem was that I didn't have a "do" 5 lines below in the else branch.
03:30:05 <Sara|Uni> kk, had a typo in the nrs of the encrypted text
03:30:13 <fasta> xerox: (which makes it a bad error message)
03:30:48 <dcoutts> Sara|Uni, ah, you're doing the optional part already? :-)
03:30:52 <Sara|Uni> ?
03:30:54 <Sara|Uni> what?
03:31:03 <Sara|Uni> eh... yeah, done now
03:31:07 <dcoutts> of the FP practical
03:31:11 <Sara|Uni> yes
03:31:20 <dcoutts> :-)
03:31:21 <xerox> ox.ac.uk hehe!
03:31:36 <xerox> Good idea to come to #haskell ;)
03:31:46 <Sara|Uni> so who's watching me?
03:31:56 * dcoutts runs the FP practicals
03:31:59 <Sara|Uni> well... want to learn haskell fast - why not ask smart people ;)
03:32:04 <fasta> @users
03:32:04 <dcoutts> good idea
03:32:11 <Sara|Uni> @users
03:32:13 <Sara|Uni> !users
03:32:22 <lambdabot> seen module failed: IRCRaised thread killed
03:32:26 <dcoutts> hah
03:32:37 <lambdabot> seen module failed: IRCRaised thread killed
03:32:43 <dcoutts> poor lambdabot
03:32:46 <Sara|Uni> sry
03:32:54 <Sara|Uni> just curious
03:33:04 <dcoutts> it's not your fault
03:33:06 <fasta> Even the type system can't help him now.
03:33:34 <Sara|Uni> soooo... code cleanup now...
03:33:54 <dblhelix> is lambdabot ill?
03:34:12 <dblhelix> fasta: ...can't help *her* now...
03:34:28 <fasta> dblhelix: *it*
03:34:36 <SamB_XP> her!
03:34:42 <fasta> *IT*
03:34:54 <xerox> *HER*
03:34:59 <dcoutts> http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:35:01 <lambdabot> Title: lambdabot, http://tinyurl.com/kv4n5
03:35:03 <fasta> *IT*!
03:35:07 <profmakx> .-
03:35:15 <dblhelix> fasta: http://trappist.elis.ugent.be/~kehoste/haskell-blah_lambdabotContest.html
03:35:18 <lambdabot> Title: #haskell-blah: Everything but Haskell - Lambdabot contest, http://tinyurl.com/y949tc
03:35:42 <fasta> dblhelix: that's too funny
03:36:27 <yaarg> haha
03:41:41 <fasta> Would that be the first time someone made a drawing of a channel bot?
03:42:57 <Sara|Uni> another question: say I've got a tuple (a,b,c) - how can I select only one component, e.g. b
03:43:26 <integral> proj_2 (_,x,_) = x ?
03:43:54 <Sara|Uni> hm, maybe I should find a different reference
03:44:17 <Sara|Uni> does someone know a good reference for haskell? (online)
03:44:40 <profmakx> depends on the value of reference i guess
03:44:51 <SamB_XP> @google "haskell 98 report"
03:44:53 <profmakx> #haskell is a good one if enough people are threr ;)
03:44:54 <lambdabot> http://www.haskell.org/onlinereport/
03:44:54 <lambdabot> Title: The Haskell 98 Language Report
03:44:58 <Sara|Uni> http://www.zvon.org/other/haskell/Outputglobal/index.html that's the one I'm using right now
03:44:59 <lambdabot> Title: Haskell, http://tinyurl.com/fuqg8
03:45:03 <ValarQ> @where Hierarchical Libraries
03:45:04 <lambdabot> I know nothing about hierarchical.
03:45:07 <ValarQ> hmm
03:45:08 <SamB_XP> @doc
03:45:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
03:49:04 <fasta> I always call that function snd3
03:49:36 <Sara|Uni> Main> :t proj_2
03:49:36 <Sara|Uni> ERROR - Undefined variable "proj_2"
03:49:48 <fasta> Sara|Uni: you should define
03:49:50 <fasta> Sara|Uni: it
03:49:53 <Sara|Uni> kk
03:50:01 <norpan> @type snd3
03:50:02 <lambdabot> Not in scope: `snd3'
03:50:47 <norpan> or make your own datatype instead of anonymous tuples
03:52:05 <gds> @let snd3 (_,x,_) = x
03:52:06 <lambdabot> Defined.
04:09:44 <Sara|Uni> ?paste
04:09:44 <lambdabot> http://paste.lisp.org/new/haskell
04:10:30 <Sara|Uni> would someone look at my code and comment on the style if I pasted it?
04:10:41 <Sara|Uni> or is that evil dcoutts? :)
04:11:52 <Cale> Sara|Uni: go for it
04:12:06 <Cale> oh, is it an assignment?
04:13:12 <lisppaste2> Sara pasted "It's working, but what about the style?" at http://paste.lisp.org/display/28193
04:13:30 <Sara|Uni> not one that's graded or so
04:13:45 <dcoutts> Cale, yeah it's an assignment, but I'll be marking it, so it's ok ;-)
04:14:12 <Cale> the 'then' and 'else' part of an 'if' are usually aligned
04:14:14 <dcoutts> and yes, this first one isn't counted, it's just a practice
04:14:27 <xerox> crackRSA, woo.
04:14:33 <Sara|Uni> ;)
04:15:58 <Cale> (unless they came to you like that :)
04:16:39 <Sara|Uni> the first if then else was given (euclid)
04:16:46 <dcoutts> Sara|Uni, for trivial things like proj_2, I'd normally just write it at the place it's used like (\(_,x,_) -> x)
04:16:52 <dcoutts> it's not usually worth naming
04:17:06 <Sara|Uni> what does the trailing \ mean?
04:17:20 <Cale> \ is lambda
04:17:20 <dcoutts> or let (_,thing,_) = euclid e phi in thing
04:17:30 <dcoutts> > (\(_,x,_) -> x) (1,2,3)
04:17:32 <lambdabot>  2
04:17:33 <Cale> > (\x -> x^2) 5
04:17:34 <Sara|Uni> true, that's nicer
04:17:35 <lambdabot>  25
04:18:04 <Sara|Uni> maybe I should be doing the lamda calc. course after all ;)
04:18:44 <Sara|Uni> *lambda
04:20:52 <Sara|Uni> anything else that looks pretty ugly?
04:20:56 <foxy_> Where can I get a debian package of ghc6.6?
04:21:57 <fasta> Sara|Uni: efficiency wise you could use difference lists instead of (++), but I don't think that will improve your grade.
04:22:24 <Sara|Uni> difference lists?
04:22:26 <Cale> does determineFactors have a specific meaning in your head? It could be merged with search.
04:22:39 <Sara|Uni> I'm not working on a grade... I just want to learn clean haskell
04:22:51 <Cale> It looks clean enough stylistically :)
04:22:52 <fasta> Sara|Uni: clean Haskell is not always fast Haskell
04:23:01 <Cale> actually, usually it is :)
04:23:08 <fasta> Sara|Uni: yes, it looks good.
04:23:16 <Cale> (though that's a certain kind of cleanliness :)
04:23:17 <Sara|Uni> thanks for the help ;)
04:23:31 <fasta> Cale: if you use good producers, yes, but that requires compiler knowledge.
04:24:09 <Cale> or at least, knowledge about lazy evaluation
04:24:19 <Sara|Uni> oooh, am late - byebye ... will probably be here around more often now ;)
04:24:37 <fasta> Well, (++) is not going to be efficient, with or without lazyness.
04:24:58 <fasta> It's better to just write everything with mappend, and then later optimize the Monoid instance
04:25:12 <fasta> Well, that's how I see it now.
04:25:42 <Cale> (++) is fine if the left list is small
04:25:55 <Cale> or if it's not used recursively
04:27:57 <fasta> Cale: true
04:28:09 <Cale> the (++) in (xs ++ ys) only takes O(min(k,length xs)) time to evaluate, where k is the number of elements used from the result.
04:32:46 <fasta> Cale: If I only "use" the odd indices are you saying it's k/2?
04:35:04 <Cale> ah, I should have said where k is the number of conses used :)
04:36:41 <Cale> the actual heads of those conses are of course completely unaffected by the whole process.
04:48:58 * beelsebob giggles at the people on the cocoa-dev mailing list and an implementation of "Higher order messaging"
04:49:15 <beelsebob> (which is actually an implementation of slightly abstracted C function pointers)
04:49:34 <mwc> beelsebob, hahaha, I haven't havked with cocoa in a long time
04:49:36 <mwc> got a link
04:49:57 <beelsebob> um... dunno... probably in the archives, but it's all in my email
04:50:00 <beelsebob> let me dig it up
04:51:22 <beelsebob> ah... it's actually the Obj-C maling list
04:51:27 <beelsebob> but same difference
04:51:27 <beelsebob> http://lists.apple.com/archives/objc-language/2006/Oct/msg00032.html
04:51:30 <lambdabot> Title: Higher Order Messaging, http://tinyurl.com/sm4ax
05:13:09 <mwc> HOF's without closures sort of lose their utility
05:13:23 <mwc> There's always C++'s fobj approach, but that's hackish
05:16:09 <beelsebob> indeed
05:45:28 <Syzygy-> @hoogle [a] -> [[a]]
05:45:29 <lambdabot> List.inits :: [a] -> [[a]]
05:45:29 <lambdabot> List.tails :: [a] -> [[a]]
05:45:29 <lambdabot> List.group :: Eq a => [a] -> [[a]]
05:54:40 <xinming_> anyone here uses haskell overlay in gentoo?
05:54:43 <xinming_> !!! Manifest file not found: '/data/portage/local/layman/haskell/dev-haskell/cabal/Manifest'
05:54:54 <dcoutts> xinming_, we don't keep manifests in the overlay
05:55:10 <dcoutts> either make them yourself or use FEATURES="-strict"
05:55:13 <xinming_> I got this error, I don't know if this is right place to ask... But please don't be angry with my question. :-)
05:55:20 <dcoutts> s'ok
05:55:30 <xinming_> dcoutts: How do I make the Manifest?
05:55:43 <dcoutts> ebuild dev-haskell/foo/foo.ebuild digest
05:56:21 <xinming_> dcoutts: thanks
05:57:32 <xinming_> I don't wish to use '-strict' and also don't wish to add a line in package.use, So, I would generate digest myself, BTW, why isn't this in gentoo portage? Since you can hard mask it.
05:58:13 <dcoutts> xinming_, we test stuff in the overlay before putting it in portage
05:58:30 <dcoutts> xinming_, if you want to know more ask in #gentoo-haskell
05:58:38 <xinming_> dcoutts: thanks
06:05:10 <metaperl_> languages used for ICFP are listed: http://www.boundvariable.org/teams.shtml#1346
06:05:11 <lambdabot> Title: ICFP Programming Contest, 2006 : Teams
06:05:41 <ACSpike[Work]> hello
06:08:00 <roconnor> mmm, secret google languages
06:14:40 <Itkovian> Sara|Uni: the final type of fromIntegral a, where a is an Integer is derived by the type system, when it tries to match up the types in your expressions. It should work
06:14:46 <Itkovian> ow fuck
06:15:08 <Itkovian> annoying when the scroll bar is way up and you think you are replying to something just said
06:15:13 * Itkovian feels dumb again
06:15:14 <profmakx> *g*
06:16:03 * Smokey` crawls up in the warm, safe corner of #haskell ... away from all the C++ nastyness
06:16:45 <Itkovian> Smokey`: have you been disinfected?
06:17:27 <Smokey`> Itkovian: hehehe :)
06:18:09 <Smokey`> I have the 'stupidity vaccine', stops me form being infected from the nastyness that is the C++ spec.
06:18:26 <Smokey`> (despite the fact I use C++ more than any other language... I just decide to not do alot of stupid things w/ it)
06:18:58 <profmakx> he said the C word -.-
06:19:03 <profmakx> multiple times
06:21:08 * musasabi gives profmakx some soothing lambdas.
06:21:26 <br1> C++ is not that bad
06:21:40 <profmakx> thanks musasabi
06:21:44 <Smokey`> br1: C++ is like a nuke... it's fine, unless it's in the wrong hands.
06:21:56 <Itkovian> a nuke is never fine
06:22:22 <profmakx> in fact i am experimenting with ogre right now, so one could somehow say i am using C++ one way or the other
06:22:54 <sieni> Itkovian: open the door, it's the fbi
06:23:11 <br1> Smokey` then it's your coworkers you have to hate
06:23:13 <Smokey`> fine, s/nuke/baseball bat/
06:23:19 <br1> ogre the 3d engine?
06:23:41 <Itkovian> sieni: ow shit
06:23:45 <profmakx> yes br1
06:24:17 <br1> I used irrlicht recently and that sucks
06:24:27 <profmakx> i know, so i dont use it
06:24:42 * Smokey` cries
06:24:51 <Smokey`> how can people possibly think 'for(;;)
06:24:53 <Smokey`> ' is normal
06:24:57 <br1> I had to bc it was for a class
06:25:08 <profmakx> but what i need at the moment is some competent rendering engine
06:25:19 <profmakx> because i want to try FRP with games ;)
06:25:32 <br1> for(;;) it's fine
06:25:53 * Smokey` knocks br1 and drags him out of the room
06:26:05 <profmakx> o.O
06:26:06 <Syzygy-> I like the synonym while(true) though
06:26:12 <br1> breaking in the middle of the loop is common in my code
06:26:13 <Smokey`> Syzygy-: as do
06:26:19 <Smokey`> ..I... >_>
06:26:23 <profmakx> while(1) {}
06:26:26 <br1> it's common in knuth's too.  he has an article
06:26:53 <Syzygy-> ooooh, yummy. I'm doing something computationally idiotic.
06:26:54 <br1> the problem with while(true) is that vc++ complains in higher warn levels
06:27:00 <Smokey`> br1: The thing I hate about for(;;) is the fact it evaluates '' to true.
06:27:40 <Itkovian> br1: then that is vc++'s problem
06:27:41 <Syzygy-> NaÃ¯ve algorithm to enumerate all 6072 elements of the linear group L_2(23) from generators.
06:27:43 <flux__> br1, uh.. why?
06:27:56 <Cale> #define ever (;;)
06:27:56 <flux__> br1, in the case if you don't have a break or return in the loop?
06:28:24 <Syzygy-> Cale: Ickit!
06:28:54 <br1> Smokey` You are right about that
06:29:02 <br1> flux: Come again?
06:29:22 <profmakx> arhhh groups
06:29:27 <profmakx> </homer>
06:29:39 <flux__> br1, it whines about while (1) {} but not about while (1) { break; } ?
06:30:10 <br1> I think it just whines.  It's idiotic, yes.
06:31:10 <Smokey`> I can understand while(true) { break; } not generating a warning,  but while(true) { if(foo) break; }, should generate a warning...
06:31:33 <br1> why?
06:31:36 <profmakx> hm
06:31:54 <profmakx> its undecidable in general if such a loop breaks isnt it?
06:32:08 <br1> well, yes
06:32:09 <Smokey`> because while(true) { break; } is garenteed to end the loop.  where as with an if statement, there's no way the compiler can garentee the loop will ever end (despite you knowing otherwise)
06:32:21 <br1> but while(somepred()) is too
06:32:34 <Smokey`> hmmm
06:32:57 <Smokey`> well, now you know why I hate the C++ spec :)
06:33:15 <Smokey`> it allows stupid people, to do very very stupid things. (which of course, they will...)
06:33:36 <br1> I don't follow
06:33:48 <br1> undecidable stuff is over language specs
06:34:01 <br1> s/over/above/
06:34:17 <Smokey`> mmm
06:35:53 <br1> profmakx: Can you have savegames and frp in the same game?
06:36:25 <Smokey`> I guess I just dislike the mass amounts of idiots I have to deal with, regarding C++ :)   #Haskell is like a sanctuary :)
06:36:50 <br1> he
06:37:10 <profmakx> well br1 i havent gotten too deep into the subject as of now
06:37:39 <br1> Where I live C++ is so unused that I get to teach everybody my way ;)
06:38:14 <Smokey`> br1: Aslong as you teach them well :)
06:38:48 <br1> profmakx: I would like to use haskell for a game engine becase classes allow polymorphic families of objects.  I think you can integrate a physics engine better, also.
06:39:16 <br1> yeah, I keep count of the people I've "boostizado".
06:39:33 <br1> That's similar as bautism in spanish
06:39:33 <profmakx> yes br1 thats my goal
06:39:36 <profmakx> mitterm
06:39:37 <profmakx> arx
06:39:38 <profmakx> mid-term
06:39:39 <br1> s/as/to/
06:39:46 <profmakx> but i will have to learn a lot before that ;)
06:39:57 <br1> hehe
06:39:58 <br1> me too
06:40:40 <profmakx> so i will try using ogre for rendering
06:40:51 <profmakx> and do game logic elements and the like in haskell
06:41:38 <br1> I've a question related to this
06:41:56 <br1> in a game engine there are lots of resources that aren't memory and are so not in the GC realm
06:42:01 <br1> like texture memory
06:42:17 <br1> I like using C++'s deterministic destrction for that stuff
06:42:34 <br1> is there a set of combinators or monad or something to get that feature in haskell?
06:42:54 <dcoutts> withResource $ ...
06:43:21 <dcoutts> withResource $ \resource -> ...
06:43:57 <br1> well, yes, but that only that cares of local objects
06:44:09 <br1> if I have object dependencies
06:44:18 <profmakx> perhaps you take a look at frag how it handles that
06:44:23 <br1> like smart pointers as members
06:44:29 <br1> in c++
06:45:11 <br1> I should, but this is more general in scope
06:45:41 <norpan> ForeignPtrs with destructors?
06:45:43 <br1> What I would like is to have something like ref counting in haskell
06:46:41 <br1> yes
06:46:54 <br1> well, not necesarilly Foreign
06:48:49 * dons lands back on the other side of the pacific
06:49:48 <Smokey`> dons: where were you?
06:51:34 <dcoutts> hia dons
06:52:11 <br1> norpan: Reading the docs I came to the conclusion that ForeignPtrs have finalizers and not destructors, so it's not what i need.
06:52:47 <dcoutts> br1, what's the difference ?
06:53:13 <br1> finalizers run when a gc is triggered
06:53:21 <br1> maybe never
06:53:35 <dons> dcoutts: hey, I see Martin blogged about our darcs/abiword talk. how'd you find that blog ?
06:53:39 <dons> Smokey`: Sydney now.
06:53:47 <dcoutts> dons, it's on planet gnome
06:53:53 <dons> ah right
06:54:04 <hygge> is there a variant of getChar that require the user to press an enter after he has given a char?
06:54:18 <hygge> that *not* require that i mean :P
06:54:30 <Igloo> hSetBuffering stdin NoBuffering (or similar)
06:54:34 <dcoutts> hygge, use no buffering on your handle
06:54:42 <hygge> hmm
06:55:00 <dons> getLine ?
06:55:19 <dcoutts> Igloo, the compsoc folks have taken to bugging me rather than you to book comlab rooms
06:55:23 <hygge> i wrote wrong first, dons  :P
06:55:35 * dcoutts -> comlab
06:56:02 <Igloo> Heh; well, you are actually still a student there  :-)
06:56:53 <dcoutts> they've got a Red Hat chap comming to talk, I'll see if I can persuade him to get Red Hat to send us Fedora CDs for all our first years :-)
06:57:49 <hygge> hello sris
06:58:15 <sris> hi hygge
06:58:42 <sris> hygge, all good?
06:59:44 <sris> hygge, have you missed me?
07:01:57 <hygge> everything's nice... labtime in haskell atm.
07:02:03 <hygge> :P
07:02:09 <hygge> wzup up in lund?
07:02:15 <sris> i screwd up my haskell exam some days ago :D
07:02:21 <hygge> ah :/
07:02:41 <sris> stupid teacher didt write valid haskell, so i fugured it was a trick quiestion, whih it, of course, wasn't :D
07:02:45 <hygge> what do you study? i just saw your host. i actully come from skane too.
07:02:51 <hygge> ah :P
07:02:59 <sris> i studdy computer science at LTH
07:03:13 <hygge> not the civ.ing program then?
07:03:16 <sris> yes
07:03:24 <hygge> you do?
07:03:43 <sris> hum.. well haha
07:03:57 <sris> im to tired for this, yes i study the civ.ing program :D
07:04:28 * dblhelix embraces -fno-mono-pat-binds
07:05:23 <sris> i dont know what i study :D "civilingenjör i datorteknik" :D
07:16:15 <jmmv> hi
07:16:24 <profmakx> hi jmmv
07:19:35 <beelsebob> mwc: you might want to go back to that thread - they apparently just don't understand what it means for something to be higher order
07:23:32 <profmakx> hmm
07:23:43 <profmakx> am i the only one who thinks singletons are braindamage?
07:26:52 <Patterner> who needs singletons when you have global variables?
07:26:58 <fasta> profmakx: no
07:27:09 <profmakx> ogre uses them quite extensively
07:27:14 <fasta> profmakx: even Java people discovered that it's not smart.
07:27:28 <profmakx> and i try to understand why ;) but ill ask the ogre people about that -.-
07:27:52 <fasta> profmakx: "It works, there is no design." ;)
07:28:11 <fasta> "Design? What are you talking about?"
07:28:21 <fasta> Or "Go away!"
07:28:39 <profmakx> "Go away" ;)
07:29:23 <hygge> is there any command to import everything that the other module imports too?
07:30:03 <Lemmih> hygge: In ghci?
07:30:44 <profmakx> "Introduction to procedural programming in Java" wtf?
07:31:00 <profmakx> i think i will go and eat some of musasabis soothing lambdas
07:31:04 <profmakx> or dried frog pills
07:33:31 <hygge> Lemmih: yeah
07:35:19 <mwc> beelsebob, that was my read on it
07:40:55 <vegai> hs-plugins for ghc-6.6. Is it a-coming?
07:41:25 <vegai> dons: pingeling
07:50:01 <dcoutts_> hygge, :m + Foo Bar
07:56:08 <br1> profmakx: Sorry to hear about the singletons.  It's really hard to find good c++.
07:58:13 <vincenz> br1: yeah, it can only be bought under the counter
07:58:54 <br1> hahaha
07:59:33 <br1> peter dimov, of boost fame, was writing a game, but it wasn't open source
08:01:27 <hygge> dcoutts_: okey :) can i do that using the 'import' in my scripts to, or something similair?
08:33:28 <cwenner> hygge: that would be poor style. either that module should make those inners visible, or you should import the libraries you'd like to use explicitely. the external module should be a closed box with exception of it's exports
08:34:20 <lisppaste2> Azmo pasted "type constraint working in 6.4.1 but not in 6.6  why?" at http://paste.lisp.org/display/28204
08:35:57 <Pegazus> what's the best advanced haskell book out there?
08:36:22 <Igloo> Azmo: The problem is the type sig after "h i"
08:36:52 <Azmo> i suppose so, but i need it for the type constraints to be correct. how could i specify it otherwise?
08:36:53 <roconnor> @seen ndm
08:36:53 <lambdabot> ndm is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when ndm last spoke.
08:37:05 <ndm> @seen roconnor
08:37:06 <lambdabot> roconnor is in #ghc and #haskell. I last heard roconnor speak 12s ago.
08:37:21 <ndm> roconnor: i have now generated haskell code, am trying to benchmark it now :)
08:37:23 <roconnor> I wanted to mention about unsafeCoerce
08:37:29 <ndm> go on
08:37:35 <roconnor> I changed all the instances of () to (()->())
08:37:43 <Pegazus> can't anyone advise me any advanced haskell book to read?
08:37:45 <roconnor> and now my example runs under gh.
08:37:46 <roconnor> ghc.
08:37:47 <Igloo> Azmo: Remove that sig and put "forall a . " before "(Storable"
08:38:47 <ndm> roconnor: i actually managed to prod some of my examples through the type checker, just working on a few more now
08:38:57 <Azmo> wow. works. thanks :]
08:39:50 <ndm> roconnor: without resorting to unsafeCoerce, although will have to for a few examples i have
08:40:02 <br1> Pegazus: The wiki and research papers?
08:40:16 <roconnor> okay
08:41:10 <Pegazus> not that advanced :p
08:41:59 <br1> The wiki is understandable
08:42:10 <Pegazus> :p
08:43:49 <br1> I really liked King's thesis
08:45:54 <br1> try that if you like graph algorithms
08:53:22 * mwc hates writing toplevels without parsec
08:54:45 <hyrax42> haha I was just thinking of coming and putting in a random praise for parsec
08:55:32 <gds> @karma+ parsec
08:55:32 <lambdabot> parsec's karma raised to 1.
08:56:05 <hyrax42> only 1?
08:56:15 <gds> apparently so...
08:56:22 <hyrax42> did the karma get reset or something
08:57:27 <shapr> @karma
08:57:27 <lambdabot> You have a karma of 24
08:57:37 * shapr boings
08:58:12 <hyrax42> ?karma
08:58:13 <lambdabot> You have a karma of 1
08:58:19 <hyrax42> hhe
08:58:26 <hyrax42> ?hoogle match
08:58:27 <lambdabot> Language.Haskell.TH.match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
08:58:27 <lambdabot> Data.Graph.Inductive.Graph.match :: Graph gr => Node -> gr a b -> Decomp gr a b
08:58:27 <lambdabot> Language.Haskell.TH.Match :: Pat -> Body -> [Dec] -> Match
08:58:28 <shapr> @karma+ hyrax42
08:58:28 <lambdabot> hyrax42's karma raised to 2.
08:58:43 <hyrax42> what is the regex lib called
08:58:48 <hyrax42> ?hoogle regex
08:58:48 <lambdabot> Text.Regex :: module
08:58:49 <lambdabot> Text.Regex.Regex :: data Regex
08:58:49 <lambdabot> Text.Regex.Posix.regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))
08:58:55 <hyrax42> there we go
08:59:05 <hyrax42> ?docs Text.Regex
08:59:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
09:00:29 <hyrax42> hm
09:00:43 <hyrax42> why does regcomp return in IO?
09:01:22 <hyrax42> oh it's FFI
09:10:26 <Igloo> dcoutts_: Is there a reason cabal packages on gentoo don't split objects?
09:19:45 <hyrax42> hmmm
09:20:05 <hyrax42> I have an itch to learn Text.PrettyPrint.HughesPJ
09:25:37 <glguy> anyone know where the FilePath that lhs2tex uses is?
09:25:57 <hyraxfourtwo> usuatlly FilePath = String?
09:26:00 <hyraxfourtwo> it's different?
09:26:19 <hyraxfourtwo> oh never mind
09:26:23 <hyraxfourtwo> what is lhs2tex
09:26:33 <hyraxfourtwo> ?where lhs2tex
09:26:33 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
09:27:53 <glguy> has anyone built lhs2tex with ghc-6.6
09:35:39 <arjanoosting> glguy: I am trying now
09:36:26 <DRMacIver> At the risk of getting shouted at, is it possible to set ghc so it ignores layout and requires explicit grouping?
09:36:54 <hyraxfourtwo> woah lhs2tex looks really nifty
09:37:05 <hyraxfourtwo> explains a lot of these nicely formatted papers, too
09:38:22 <cwenner>  
09:38:24 <cwenner> Active documents: you can use Haskell to generate parts of the document (useful for papers on Haskell).
09:38:28 <cwenner> that feature is nice
09:38:53 <arjanoosting> glguy: just remove the "-package lang" in config,mk
09:40:44 <arjanoosting> err in config.mk.in
09:43:57 <glguy> I also had to go through and remove a lot of the name collisions between Data.Char and various files
09:46:53 <araujo> hi hi!
09:47:01 * araujo flips and throws sugar lambdas
09:47:53 <hyraxfourtwo> can haddock and lhs2tex play nice together
09:47:54 <hyraxfourtwo> ?
09:48:20 <dmhouse> shapr: ping
09:54:32 <Lemmih> DRMacIver: No.
09:54:51 <DRMacIver> Sigh. I was afraid of that.
09:55:23 <Lemmih> Why would you want it to?
09:56:52 <DRMacIver> Strong philosophical objections to significant whitespace.
09:57:13 <DRMacIver> (Which I'm not inclined to debate here, having done it to death elsewhere)
09:57:15 <br1> hi, araujo
09:57:20 <dmhouse> DRMacIver: then use {;}.
09:57:26 <ibid> DRMacIver: you can write your code without layout, though
09:57:34 <dmhouse> DRMacIver: using {;} everywhere will pretty much get GHC to ignore your layout anyway.
09:57:47 <DRMacIver> Yeah, I know. I intend to do that.
09:58:01 <DRMacIver> It just makes me vaguely nervous. :)
09:58:29 <br1> the chances that you make a mistake and it typechecks are low
09:58:31 <ibid> DRMacIver: write a simple program that checks that every layout-inducing keyword is followed by an opening brace
10:00:31 <dmhouse> Is it possible to traverse over the first n elements of a Data.Map.Map?
10:00:58 <dmhouse> As the Ord constraint on the key type (and the fact that Maps internally are balanced trees) implies that that makes sense.
10:01:15 <ibid> dmhouse: you can convert to an ordered list
10:01:24 <ibid> dmhouse: i would hope that it is built lazily
10:01:38 <dmhouse> Cool, that should do it.
10:01:49 <araujo> hola br1
10:01:59 <dmhouse> Coupled with deforestation, that's pretty much what I want.
10:03:08 <jgrimes> but deforestation leads to soil erosion and flooding
10:03:14 <jgrimes> :p
10:03:48 <dmhouse> :)
10:04:07 <ibid> not to mention less carbon dioxide eating biomass
10:04:15 <ibid> encouraging global warming
10:05:22 <dmhouse> What kind of data structure am I looking at if I want the ability to sequence its elements, semi-fast lookup and semi-fast appending?
10:05:57 <ibid> pure data structure?
10:05:58 <araujo> what kind of elements?
10:05:59 <br1> lookup by which criteria?
10:06:06 <dmhouse> br1: index.
10:06:09 <ibid> if impure then an extensible array is good
10:06:38 <dmhouse> I'd prefer pure.
10:07:01 <ibid> then i'd say an IntMap-like thingy
10:07:07 <br1> okasaki has a tree that would serve you
10:07:16 <dmhouse> An Array won't really do it because the keys aren't enumerable.
10:07:16 <int-e> Data.Sequence ?
10:07:35 <int-e> *wonders*
10:07:44 <ibid> dmhouse: Data.Map :)
10:07:56 <int-e> -- | /O(log(min(i,n-i)))/. The element at the specified position
10:07:58 <int-e> index           :: Seq a -> Int -> a
10:08:15 <dmhouse> Sequence looks good.
10:08:18 <int-e> -- | /O(log(min(n1,n2)))/. Concatenate two sequences.
10:08:20 <int-e> (><)            :: Seq a -> Seq a -> Seq a
10:08:21 <int-e> :)
10:08:48 <DRMacIver> Hm. Well, that answers a question I'd been wondering about. :)
10:08:50 <dmhouse> Lookup isn't that much of a priority, the ability to sequence elements is more important.
10:09:06 <DRMacIver> (Whether concatenating sequences was the performance hit it is in ML)
10:10:04 <ibid> DRMacIver: depends on which sequences :)
10:10:30 <dcoutts_> Igloo, no reason, we're just not specifying it to cabal yet, it's just a change that needs doing
10:10:38 <dmhouse> DRMacIver: what's the ML efficiency?
10:11:06 <DRMacIver> dmhouse: I think it's O( min(n1, n2) )
10:11:20 <DRMacIver> Wait, I'm confused.
10:11:21 <DRMacIver> Ignore me.
10:11:31 <dmhouse> Ignore or /ignore? :)
10:11:35 <dcoutts_> Igloo, similarly, cabal configure should have an -O --optimise flag which should turn on optimisations for compilers that have such a notion. With ghc that should probably mean -O and -split-objs
10:11:35 <DRMacIver> Just ignore for now. :)
10:11:41 <dmhouse> Hehe. Okay. :)
10:12:01 <musasabi> dmhouse: how about "(Data.Map Integer val,Integer)" ?
10:12:03 <dcoutts_> Igloo, so people building for use (-O) rather than debugging get split objs by default
10:12:04 <DRMacIver> (By the way, hi. We've met under my alter ego of Kit)
10:12:25 <dcoutts_> Igloo, then perhaps we can get people not to stick -O in the 'ghc-options:' field
10:12:31 <dmhouse> DRMacIver: yeah, I recognised your name. Good to see you in this channel. :)
10:12:40 <dcoutts_> as it's a user choice not a developer one
10:13:07 <dcoutts_> though the developer knows what special optimisation flags to use I guess
10:13:41 <dmhouse> musasabi: what's the second element for?
10:14:16 <DRMacIver> dmhouse: Well various friends of mine have been telling me to try haskell for ages, so I finally got around to browsing the tutorial.
10:14:27 <DRMacIver> There were sufficiently many 'Oooh' inducing features to persuade me it was worth a try...
10:14:33 <dmhouse> DRMacIver: Cool. Which tutorial?
10:14:44 <DRMacIver> The gentle introduction on haskell.org
10:15:08 <dmhouse> Ah, righty. That's the one that often scares the newbies off but if you've got ML etc. under your belt you're pretty much the target audience.
10:15:09 <musasabi> dmhouse: to know what key you need to use to append.
10:15:29 <DRMacIver> Yeah, I already know functional languages are cool and wonderful. :)
10:15:37 <DRMacIver> I just needed convincing about Haskell.
10:16:11 <DRMacIver> (I've not finished reading it yet. Too much actual work to do)
10:16:33 <dmhouse> DRMacIver: well, good luck. If you've got any questions, #haskell has a great group of guys at hand.
10:16:42 <DRMacIver> Thanks. :)
10:16:43 <hyraxfourtwo> I'll second that!
10:16:59 <hyraxfourtwo> dmhouse = davidhouse right?
10:18:55 <Azmo> @hoogle hWaitForInput
10:18:55 <lambdabot> IO.hWaitForInput :: Handle -> Int -> IO Bool
10:19:14 <defcon8> is ocaml used more oiver haskell by companies?
10:19:49 <hyraxfourtwo> defcon8, since they're both used approximate 0% overall, not sure it makes a big difference
10:19:52 <dmhouse> hyraxfourtwo: right.
10:19:58 <defcon8> right :|
10:19:59 <hyraxfourtwo> dmhouse, you were away for a while?
10:20:00 * dmhouse has to dash.
10:20:10 <dmhouse> hyraxfourtwo: from where?
10:20:14 <hyraxfourtwo> from irc
10:20:33 <hyraxfourtwo> as in you weren't in here in sept or so?
10:20:39 <dmhouse> Not really. Perhaps I was just on ad awkward times. :)
10:20:40 <hyraxfourtwo> I remember you helpign me ot a bunch before the summer
10:20:44 <dmhouse> Anyway, I really have to go.
10:20:46 <hyraxfourtwo> kk
10:20:48 <hyraxfourtwo> take care
10:20:48 <dmhouse> Ah, that's cool. :)
10:20:49 <defcon8> I wonder why they aren't used :|
10:21:11 <hyraxfourtwo> and defcon8, I think a company that uses either will know about the other
10:21:52 <hyraxfourtwo> ok I have to get moving too
10:23:02 <DRMacIver> There are definitely companies which use OCaml almost exclusively (ok, 'companies'. I know of one, but assume there to be more).
10:23:09 <DRMacIver> Presumably similar can be said of OCaml.
10:23:10 <DRMacIver> err
10:23:12 <DRMacIver> Haskell
10:23:16 <hyraxfourtwo> Jane's whatever thingy?
10:23:24 <DRMacIver> But both are rather in the minority. :)
10:24:54 <DRMacIver> hyraxfourtwo: I'm thinking of Merjis. Although I can't seem to find much evidence to back up my claim about their usage habits. :)
10:25:37 <DRMacIver> They're not really a software company thouhg.
10:25:56 <hyraxfourtwo> well there is some company on wallstreet that uses ocaml
10:26:08 <ventonegro> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
10:26:23 <ventonegro> this means that the bind function takes only one arg, right?
10:26:24 <hyraxfourtwo> and they buy up adwords on stuff like haskell and lisp
10:26:26 <hyraxfourtwo> iirc
10:26:37 <hyraxfourtwo> ventonegro, depends
10:26:40 <DRMacIver> Yeah, I think I remember hearing about them. I thought for some reason that they used a bunch of different languages though.
10:26:46 <hyraxfourtwo> it tqakes 1 arg and returns a funciton of 1 arg
10:26:51 <hyraxfourtwo> or it takes 2 args and returns a result
10:27:09 <hyraxfourtwo> oh wait
10:27:11 <hyraxfourtwo> sorry
10:27:16 <hyraxfourtwo> didn't see the extra parens
10:27:32 <ventonegro> hyraxfourtwo, yeah :-)
10:27:44 <DRMacIver> Besides, it taking 2 args and returning a result isn't really an accurate description of currying. :)
10:27:56 <DRMacIver> It takes one argument, returns a one argument function and applies it to the second one.
10:28:01 <hyraxfourtwo> DRMacIver, yes yes
10:28:04 <DRMacIver> (Or does Haskell do something clever I'm not aware of here?)
10:28:05 <hyraxfourtwo> ok I must must go
10:28:14 <hyraxfourtwo> no, the "usual"
10:28:28 <ventonegro> so, can anyone parse this for me?
10:28:34 <ventonegro> bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)
10:28:52 <ventonegro> why has bind 2 args?
10:30:05 <glguy> ?type (>>=)
10:30:06 <ventonegro> this is from http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
10:30:08 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
10:30:10 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
10:30:52 <ventonegro> glguy, is this for me?
10:31:08 <glguy> ventonegro: Monadic bind takes two arguments
10:31:15 <glguy> so if they are implementing bind themselves
10:31:17 <Azmo> does anyone know why "hWaitForInput" and "hReady" says that "stdin" is ready when it is actually not?  e.g when switching to and from the window in which the program runs, they return True, but it blocks when trying to the get a character.
10:31:22 <glguy> then it would make sesne that the function takes two arguments
10:31:29 <ventonegro> glguy, yes, they are implementing bind
10:31:50 <ventonegro> glguy, but at this point in the text, they're not using >>= yet
10:32:02 <ventonegro> it's another bind
10:32:03 <glguy> >>= is bind
10:32:08 <ventonegro> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
10:32:44 <Syzygy-> ?type (>>)
10:32:46 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
10:32:53 <glguy> ventonegro: the function that you just described takes 2 arguments too
10:33:08 <glguy> ventonegro: and would be similar to (=<<)
10:33:19 <ventonegro> glguy, what are the args?
10:33:19 <Syzygy-> ?type (=<<)
10:33:21 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
10:33:43 <ventonegro> i thought that (Float -> (Float,String)) is 1 arg and ((Float,String) -> (Float,String)) is the result
10:33:54 <matthew__> can you alias params to a func in Haskell? like capturing the decomposed and composed form?
10:34:00 <glguy> ventonegro: a -> b -> c is the same as   a -> (b -> c)
10:34:07 <matthew__> eg fun (a, b)@total ?
10:34:12 <ventonegro> glguy, even with the brackets?
10:34:26 <Syzygy-> ventonegro: Adding right-associating brackets is redundant.
10:34:28 <glguy> ventonegro: -> is right associative
10:34:36 <ibid> ventonegro: returning a function taking n arguments is the same as taking n+1 arguments yourself
10:34:47 <ventonegro> so, in:
10:34:50 <ventonegro> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
10:35:04 <ventonegro> the brackets are ignored?
10:35:06 <glguy> not all
10:35:09 <ibid> not all of them
10:35:15 <sris> ?type (($)$($))
10:35:16 <lambdabot> forall a b. (a -> b) -> a -> b
10:35:16 <ibid> one pair is
10:35:22 <glguy> bind :: (Float -> (Float,String)) -> (float,String) -> (Float,String)
10:35:29 <sris> ?type ($)
10:35:29 <ibid> yeah
10:35:30 <lambdabot> forall b a. (a -> b) -> a -> b
10:35:33 <dmhouse> ventonegro: (a -> b) -> c is not the same as a -> b -> c, but the latter is the same as a -> (b -> c).
10:35:42 <ventonegro> aaahhh
10:36:00 <ventonegro> that's what's been killing me :-)
10:36:16 <ventonegro> anyone knows the precise rule?
10:36:25 <glguy> -> is right associative
10:36:28 <dmhouse> It's a case of what's called 'associativity'.
10:36:37 <ibid> ventonegro: the rule is that a -> b -> c means a -> (b -> c)
10:36:44 <ventonegro> glguy, ok, got it
10:36:55 <ventonegro> thanks
10:37:04 <sris> ?type ([]>>=) (\_ -> [(>=)])
10:37:06 <lambdabot> forall a. (Ord a) => [a -> a -> Bool]
10:37:07 <dmhouse> If you have a R b R c, where R is some operator like ->, then if R is 'left-associative', then that means (a R b) R c, but if it's 'right-associative', it means a R (b R c).
10:37:14 <ventonegro> dmhouse, i know what it is, thanks :-)
10:37:22 <dmhouse> Good good. :)
10:37:38 <ventonegro> back to my tutorial!
10:43:08 <dmhouse> ?spell signiture
10:43:10 <lambdabot> signature signatures signatory signore signature's
10:43:11 <Syzygy-> ibid: Sorry for polluting planet.haskell - somehow I got a double post from my latest. Should go away by the next synch (i.e. in something like 18 minutes)
10:43:22 <Syzygy-> dmhouse: Oooooh!
10:43:33 <dmhouse> I hate that word. I can never remember if it's signAture or signIture.
10:43:47 <dmhouse> In fact, I think that word might be the only reason I use ?spell. :)
10:43:53 <Syzygy-> Heh
10:43:58 <Syzygy-> ?spell syzygy
10:43:58 <lambdabot> Suzy Suzuki stagy stogy Suzy's
10:44:02 <Syzygy-> ...
10:44:05 <Syzygy-> ?spell monad
10:44:06 <lambdabot> monad
10:44:12 <Syzygy-> ?spell monomorphism
10:44:13 <lambdabot> mono morphism mono-morphism homomorphism metamorphism homeomorphism
10:44:21 <Syzygy-> ?spell homeomorphism
10:44:22 <lambdabot> homeomorphism
10:44:42 <Syzygy-> ?spell homeomorphic
10:44:43 <lambdabot> homeomorphic
10:44:51 <ibid> Syzygy-: don't worry about doubles. wince when you whole blogging history appears :)
10:44:58 <ibid> your
10:45:05 <Syzygy-> Right.
10:45:14 <Syzygy-> (dumping the entire blogging history'd be painful)
10:45:16 <ibid> (this is called planet flooding and is a very popular sport in debian)
10:45:37 <ibid> (as in, happens often. not as in, people try to do it)
10:45:59 <Syzygy-> Oh yeah. Looked over my site stats a while ago. Have a disproportionate amount of hits from planet.debian since I got added to the planet.haskell-feed...
10:46:00 <glguy> dumping the entire bloggin history?
10:46:18 <ibid> glguy: well, ten or twenty latest as if they were new
10:46:55 <ibid> see russel coker about halfway down of http://planet.debian.org/
10:46:56 <lambdabot> Title: Planet Debian
10:47:04 <ibid> well, a little less than half
10:47:13 <glguy> k
10:47:49 <ibid> glguy: it is probably a planet bug but i don't know if it has been found or not
10:48:26 <Syzygy-> "algebra and where it all began" <= search term that brought someone to one of my sites.
10:49:25 <ibid> i get people searching for a certain infamous finnish pedophile
10:49:32 <Syzygy-> o.O
10:50:06 <ibid> (i wrote about seeing his sentence in the morning paper a couple of years ago)
10:50:32 <ibid> (knew him when i was a kid. no, i wasn't molested:)
10:54:02 <ibid> here's an interesting google search from last week: my own english book
10:54:09 <ibid> (led to my site)
11:07:00 <CosmicRay> Igloo: is there a place where I can download libghc-*-dev, the exact versions that you uploaded to sid, in order to start updating my own packages?
11:09:47 <musasabi> Why does Control.Monad.Error define the IO instance of MonadError to work with IOError and not Exception? :-(
11:10:48 <musasabi> @hoogle m a -> (Exception -> m a) -> m a
11:10:49 <lambdabot> No matches, try a more general search
11:10:59 <musasabi> @hoogle (Exception -> m a)
11:11:00 <lambdabot> Control.Exception.throw :: Exception -> a
11:18:43 <vincenz> zarvok: any idea on when the framework will be published
11:20:02 <astrolabe> When I do retainer profiling, almost all of the space is retained by SYSTEM.  What does this mean?
11:20:39 <zarvok> vincenz: next week, with luck
11:20:46 <zarvok> vincenz: did you see we put the paper online?
11:22:41 <zarvok> http://icfpcontest.org/press/tr-06-163.pdf
11:23:07 <zarvok> I don't know if you'd seen it before, it was distributed at ICFP but not made available otherwise
11:23:32 <vincenz> ah no, lemme look
11:23:37 <mwc> I have a standard tree. data Tree a = Nil | Node (Tree a) a (Tree a). Let's say I have a function leftTie v r = fix (\l -> Node l v r) that generates a cycle in the tree structure
11:23:51 <mwc> Anybody know how in general to detect trees with cycles?
11:24:15 <integral> can you?
11:24:17 <ibid> no way to do it, unless you pepper nodes with identifiers
11:24:18 <Syzygy-> Take it's Euler characteristics? :P
11:24:28 <profmakx> trees dont have cycles
11:24:32 <mwc> Well, my C intuition is to build a set of the node addresses and check for conflicts
11:24:43 <mwc> profmakx, right, so it's not really a tree, but something like it
11:24:52 <integral> mwc: yes, but you don't have "node addresses" since all values that are equal are interchangeable
11:24:54 <Syzygy-> Not a tree but a Tree... :P
11:25:04 <mwc> integral, precisely the source of my vexation
11:26:08 <mwc> ocaml of course provides a physical equality test that could do the same thing, and that's basically pointer equality. The pointer value is effectively a tag on each node
11:26:23 <mwc> so I'm inclined to believe at this point ibid is right, and it's impossible iwthout identifiers.
11:26:46 <mwc> But this channel surprises me often
11:26:50 <integral> .oO( solve the halting problem, and apply the test to halting to a naive walk of the tree )
11:28:28 <mwc> integral, thought of that too... not much of a solution
11:29:17 <twanvl> There is an unsafe solution
11:29:19 <sjanssen> mwc: there are some GHC extensions that offer something like pointer equality
11:29:28 <sjanssen> but that is a bit nasty
11:29:56 <mwc> sjanssen, I figured there would be. I could also go so far as to look into the Foreign stuff for pointer fetching. I was hoping there was some amazing functional algo to do it
11:32:45 <sjanssen> seems to me that any function that allows you to detect cycles would break referential transparency
11:32:45 <sylvan> mwc, switch your graph representation to something which can detect cycles. E.g. Indexed nodes and adjacency arrays.
11:32:58 <musasabi> There is reallyUnsafePointerEq
11:33:19 <musasabi> But avoiding that if possible is nice.
11:33:26 <mwc> sjanssen, yep, that was my conclusion. So I'll follow sylvan's advice
11:33:32 <mwc> @hoogle pointer
11:33:32 <lambdabot> No matches found
11:33:36 <musasabi> StableNames are usually good enough for detecting cycles.
11:34:41 <sjanssen> hmm, I seem to remember reading that reallyUnsafePointerEq is really unsafe . . .
11:37:29 <ibid> no kidding
11:42:18 <JohnMeacham> anyone know who is in charge of the haskell.org mailing lists? mail to haskell-admin seems to go unanswered.
11:44:30 <ibid> the lists in general, or a specific list?
11:47:03 <Taral> I just want to say...
11:47:05 <Taral> I HATE OCAML.
11:47:28 <profmakx> thx Taral
11:47:39 <profmakx> its those destructive comments that make my life easier
11:47:59 <vincenz> Taral: WHAT HAPPEED
11:48:04 <vincenz> erm
11:48:06 <vincenz> What happened?
11:48:44 <ropine> Just hate computers.  It's simpler.
11:48:55 <Taral> vincenz: I have to worry about stupid things like "tail recursion".
11:49:19 <Taral> And the references are everywhere and make people lazy.
11:49:38 <Taral> profmakx: Glad to help.
11:49:56 <mwc> Factoring for tail recursion is a major pita
11:50:18 <mwc> I hate Ocaml because it makes my eyes bleeed
11:50:21 <Taral> Yes, yes it is.
11:50:27 <Taral> I can't use fold_right without worrying about stack space.
11:50:37 <Taral> Even "map" is dangerous.
11:50:54 <Taral> There's no standard library function for function composition.
11:51:01 <Taral> How do these people get away with calling it a functional language?
11:51:15 <mwc> Taral, beyond that, it apparently doesn't liked curried functions
11:51:22 <mwc> it throws a warning for partial application
11:51:28 <Taral> Ha ha ha.
11:51:33 <Taral> I think I'll turn that warning off.
11:52:00 <Taral> If the partial app is bad, it'll get caught by the typechecker.
11:52:11 <sjanssen> throws a warning for partial application?  That's absurd!
11:52:16 <mwc> I think ocaml was born from a misguided impulse to appeal to the naive users of C
11:52:41 <Taral> mwc: Yeah, it's kind of like C with strong types.
11:52:41 <mwc> partial application, for instance, requires a closure and associated "inefficiency"
11:52:49 <Taral> *snort*
11:53:13 <Taral> yes, and references are there to prevent "excess copying".
11:53:28 <mwc> mutable fields
11:53:31 <JohnMeacham> like, who can create a new list.
11:53:56 <mwc> I get the feeling they're intending any nontrivial data structure is intended to be used imperatively
11:53:58 <Taral> I would love to take this stuff and port it to haskell... but it's full of references and stuff. :(
11:54:29 <ropine> isn't that what IORef is for? :-)
11:54:32 <Lemmih> JohnMeacham: I know SimonM is administrating some of the lists.
11:54:34 <JohnMeacham> Taral: I HATE ocaml as well. it is like at one of the worst places in the design space of functional languages.
11:54:43 <Taral> JohnMeacham: Thank you.
11:54:45 <JohnMeacham> Lemmih: cool. thanks.
11:54:46 <int-e> ropine: that's a good way to write awful Haskell code.
11:56:04 <mwc> I've noticed that you can suck on a wintergreen tums just like a mint
11:56:09 <mwc> a slimy, chalky mint.
11:56:22 <mwc> But seriously, avoids the chalky garbage in the mouth
11:59:31 <mwc> Taral, if it makes you feel better, I'm being forced to do stuff in C++
11:59:46 <Taral> mwc: Nope. :P
12:00:08 <Taral> mwc: I'm dealing with a C parser in ocaml.
12:00:17 <profmakx> class function {};
12:00:17 <Taral> It's the worst of everything.
12:00:20 <profmakx> *shudder*
12:00:26 <ropine> no, the worst of everything would be a C++ parser
12:00:26 <mwc> Well, parsing C in anything is brutal
12:00:33 <Taral> C++, if used carefully, can actually be used as an improved C.
12:00:42 <mwc> Right, but it's still C
12:00:48 <Taral> True.
12:01:02 <mwc> I miss HOF and efficient tail recursion guarantees and...
12:01:02 <Taral> The only reason I use C is to be able to specify the in-memory format of my data structures.
12:01:06 <gds> and /everyone/ associated with the project has to be equally careful.
12:01:14 <Taral> If someone would add that to another functional language, I'd use it.
12:01:34 <ropine> you may end up having to link to C++ libraries written by people who aren't using it so carefully
12:01:45 <Taral> ropine: Yes, unfortunately.
12:01:48 <Taral> I do like STL.
12:01:57 <Taral> I wrote a project in C++ once just for STL.
12:02:07 <mwc> I keep bumping into situations I need to return a function for or whatever. So then I'm gonna end up needing to wrap a closure manually wiht a function object. And then I stop caring and hack a bit out.
12:02:14 <mwc> Taral, indeed, the STL is pretty nice
12:02:27 <mwc> It would make a good library for SML
12:02:42 <Taral> I like that the algorithmic guarantees are made explicit.
12:02:48 <Taral> So you don't have to wonder what kind of sort you're getting.
12:02:56 <ibid> there is a proposal for lambdas being considered for C++0x
12:03:01 <Taral> And almost all STLs now have an introsort implementation.
12:03:01 <mwc> I like how it's easy to use correctly
12:03:06 <Taral> ibid: EWWWWW!
12:03:10 <mwc> ibid, doesn't matter unless they're returnable
12:03:15 <mwc> and that means you need closures
12:03:15 <ropine> a few years ago, when I mentioned C++ templates to more experienced programmers, they would shudder and moan about bloat; have the implementations gotten better about that?
12:03:23 <Taral> ropine: Yes.
12:03:43 * ropine googles "Introsort"
12:03:45 * cjeris prefers ocaml to sml because he hates trying to remember in which spots a library function is uncurried
12:04:07 <ibid> mwc: they are returnable per se, but it isn't decided yet how references to local variables are handled
12:04:19 <ibid> mwc: and yes, it would be a closure
12:04:23 <CosmicRay> cjeris: have you used haskell?
12:04:34 <mwc> ibid, that's the issue ain't it.. They'd need to basically have the compiler generate function objects
12:04:49 <mwc> but then you have to deal with shared ownership
12:04:59 <cjeris> CosmicRay: yes, but i don't know it very well yet. the functional language i know best is ocaml.  unfortunately my compilers course this semester demands sml.
12:05:01 <ibid> mwc: want to read the proposal?
12:05:05 <mwc> ibid, sure
12:05:37 <cjeris> meanwhile for money i am stuck with perl 5 (not so bad) and coldfusion (projectile barf).
12:05:38 <Taral> cjeris: Haskell pwns.
12:05:58 <mwc> ibid, I think you could specify that references can be carried into a function object only by two semantic routes: a) shared ownership managed by smart pointer, or b) transfer of ownership to closure
12:06:04 <Taral> I convinced a company back in 2000 to switch to python.
12:06:06 <ibid> mwc: actually, two proposals. i have only read one of them
12:06:17 <Taral> The project I wrote used higher-order transformations and metaprogramming.
12:06:19 <cjeris> Taral: this has already become clear to me.  i just haven't had an excuse to use it for something big enough to learn it properly yet.
12:06:25 <Taral> Of course, I didn't know those names back then.
12:06:29 <emu> SML is not so bad for stuff like that
12:06:37 <mwc> cjeris, my university's registrar does their website in CF. They haven't fixed the freakin T2022A form filler since 2003.
12:06:58 <emu> my main problem with it is that it doesn't deal well with large records in programmability
12:07:01 <ibid> mwc: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf and http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf
12:07:04 <lambdabot> http://tinyurl.com/y53js8
12:07:05 <cjeris> coldfusion might not be so bad if i could write a back end targeting it... :p
12:07:35 <emu> there's no syntax like: v {field=newstuff}
12:08:03 <mwc> oh wow, stroustrup signed off on the second paper
12:08:07 <mwc> I'll read that one first
12:08:20 <cjeris> emu: and whoever came up with 'andalso' and 'orelse' needs to have their bronchi yanked out with hooks.
12:08:26 <mwc> emu, I was almost certain there was
12:08:37 <emu> haha
12:08:39 <emu> yea
12:08:39 <mwc> cjeris, actually, I don't mind those names too badly
12:08:51 <emu> mwc: i coulda sworn i went looking really hard for such and never found it
12:08:53 <mwc> I mean, making them names instead of symbols improves readability
12:09:01 <cjeris> s/improves/severely damages/
12:09:07 <emu> mwc: you can pattern match {field=pattern,...} which is nice
12:10:10 <emu> haskell does suffer a bit from apl-envy i think
12:10:38 <AStorm> Hello guys.
12:11:10 <AStorm> Is there some nice Haskell vs Erlang vs OCaml vs <insert your favourite FP lang> comparison around?
12:11:20 <mwc> cjeris, foo () andalso bar() is more readble than foo () && bar (). What's even better is: if foo () then bar () else 0
12:11:21 <AStorm> Possibly as little biased as possible.
12:11:25 <mwc> now that's readable
12:11:43 <mwc> Erlang is a broken Haskell
12:11:49 <mwc> s/broken/lobotomized
12:11:54 <AStorm> Or vice-versa :P
12:12:03 <AStorm> That's why I'd love a direct comparison.
12:12:05 <cjeris> mwc: personal taste.  i like short.  of course, i liked trying to learn J.
12:12:05 <mwc> it still looks pretty, but it's not good for anything anymore
12:12:15 <Taral> neat, automatic iterators.
12:12:33 <AStorm> mwc: except concurrent programming? :P
12:12:49 <mwc> I can't get over its lack of static typing
12:13:30 <AStorm> Uh, I could get over that with Python. What else? :P
12:13:36 <AStorm> Any nice table?
12:13:42 <emu> erlang is strict
12:13:58 <sjanssen> it is odd that a language designed for fault-tolerant applications isn't statically typed
12:14:21 <AStorm> It isn't strict to me, looks lazy from the docs.
12:14:27 <cjeris> ML sorely needs type classes though.  i was doing something in SML last night that was basically a ghetto state monad.  thought about trying to express it as a real one using a functor and decided it would screw up too many other things i needed.
12:14:30 <gds> laziness is *lovely* - efficient infinite data structures :)
12:14:35 <emu> yes, definitely, cjeris
12:14:38 <AStorm> But it is probably untyped.
12:14:55 <emu> also mutually recursive modules, though i think someone took care of that
12:15:22 <shapr> @tell dmhouse pong
12:15:22 <lambdabot> Consider it noted.
12:15:29 <shapr> hello #haskell1
12:15:34 <AStorm> To reiterate: is there any nice comparison table?
12:15:39 <emu> #haskell1 - 1?
12:15:51 <emu> > sqrt -1
12:15:53 <lambdabot>  add an instance declaration for (Num (a -> a))
12:15:55 <shapr> Should have been "Hello #haskell!"
12:16:06 <AStorm> emu: that should return a complex number
12:16:09 <cjeris> val #haskell1 : { haskell1: 'a, ... } -> 'a
12:16:16 <emu> > sqrt (fromIntegral -1)
12:16:17 <lambdabot>  add an instance declaration for (Floating (a -> b))
12:16:18 <lambdabot>   In the definition o...
12:16:21 * Taral beats cjeris.
12:16:31 <Taral> @type sqrt
12:16:33 <lambdabot> forall a. (Floating a) => a -> a
12:16:40 <AStorm> Now that's wrong.
12:16:43 <Taral> > sqrt (-1.0)
12:16:47 <lambdabot>  NaN
12:16:47 <AStorm> It should work on complex numbers.
12:16:53 <AStorm> :>
12:16:57 <emu> what's this NaN!
12:17:03 <AStorm> @hoogle sqrt
12:17:04 <lambdabot> Prelude.sqrt :: Floating a => a -> a
12:17:13 <AStorm> emu: Not-a-Number
12:17:26 <AStorm> Which is wrong, of course, because it's i
12:17:44 <AStorm> of type Complex
12:17:51 <shapr> AStorm: Erlang is focussed on distributed programming and is dynamically checked, Haskell is statically checked and is focussed on type systems, purity, nifty research, etc, Ocaml is statically checked and is focussed on C-like speed with the sanity of a decently functional language, what other languages do you want to compare?
12:18:09 <AStorm> shapr: thanks :>
12:18:16 <emu> exactly
12:18:40 <sylvan> AStorm, IMO you should stop with "Haskell is pure, the others aren't". That one thing means Haskell > *
12:18:52 <AStorm> Not really anymore, just something to show to somebody :P
12:19:00 <cjeris> AStorm: and J is a sort of functional language for certified crackheads.
12:19:13 <emu> a neat thing about CL is that if you plug in (log -1) it gives you pi*i (in floating point complex number, however)
12:19:58 <cjeris> 1
12:20:17 <cjeris> erk, sorry.  stupid kvm.
12:20:24 <sjanssen> > log (-1) :: Complex Double
12:20:25 <lambdabot>  0.0 :+ (-3.141592653589793)
12:20:26 <mwc> cjeris, I've always thought J is the language for people who think implementing a UM in an excel spreadsheet would be a good idea
12:20:35 <emu> ah thats what i wanted to see hehe
12:20:40 <AStorm> > sqrt (-1) :: Complex Double
12:20:42 <lambdabot>  -0.0 :+ 1.0
12:20:59 <AStorm> Now it's correct. But the default definition is of course incorrect :>
12:21:10 <emu> yea you have to override it
12:21:34 <AStorm> I think somebody just assumed people don't know how to handle complex numbers :>
12:21:42 <cjeris> mwc: different kind of crackhead, i think.
12:22:11 <twanvl> Complex is often not what you want by default, if you do, there is always the default declaration
12:22:16 <sjanssen> AStorm: no, we just can't have the result type of sqrt depend on the value of it's argument
12:22:18 <emu> frankly i think the default should be the mathematically correct choice, or as close as possible to it, but i guess that's just personal
12:22:38 <AStorm> sjanssen: unfortunately, because of the typing system? Isn't Complex a Num?
12:23:46 <mwc> Right, but which one?
12:23:51 <emu> > sqrt (-1) :: Complex Integer
12:23:52 <lambdabot>  add an instance declaration for (RealFloat Integer)
12:23:52 <lambdabot>   In the expression: ...
12:24:05 <emu> heeh
12:24:22 <mwc> emu, mathematically speaking, the complex generalize the reals, so Complex Integer isn't really that useful
12:24:37 <mwc> all you could really do with it is +, -
12:24:48 <mwc> and multiply by another int
12:24:53 <mwc> which is really a vector space in the end
12:24:53 <sjanssen> Complex Float is a better example
12:25:35 <sjanssen> AStorm: yes, it's the type system.  Try to write the type for a function that returns a Complex if the argument is negative, and a Double otherwise
12:26:00 <AStorm> Hmm, you'd have to split negative numbers from Num
12:26:09 <sjanssen> you can't, because you can't talk about the values of things in a type declaration
12:26:10 <AStorm> NegNum which is a subclass of Num? :>
12:26:53 <AStorm> Of course it's a workaround.
12:27:11 <sjanssen> introducing more classes won't help you
12:27:30 <AStorm> Other than that, Num a, b:: a -> b  should be enough
12:27:44 <AStorm> If Complex is a Num
12:27:44 <moonlite> i'm getting "No instance for (MonadState Program m)" where Program is just a data type (a haskell record), this seems strange. any idea why as to why this could happen? I can post the code somewhere if needed
12:28:22 <AStorm> moonlite: no main declaration?
12:28:41 <mwc> @hoogle MonadState
12:28:42 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
12:28:57 <mwc> moonlite, have you restricted m to be a monad?
12:29:11 <sjanssen> moonlite: perhaps you need to give (more) type signatures.
12:29:20 <sjanssen> or, perhaps you've written a type signature that is too general
12:29:26 <emu> Float isnt the reals either
12:29:36 <moonlite> hm
12:29:38 <emu> why does Float make more sense than Integer?
12:29:41 <emu> they're both subsets
12:30:19 <emu> aren't complex numbers a superset of the reals?
12:30:21 * cjeris wonders yet again why he is so dumb
12:30:23 <mwc> correct
12:30:25 <moonlite> i'll try some more type signatures
12:30:28 <mwc> and integers are a subset
12:30:29 <AStorm> emu: ye they are
12:30:56 <mwc> Haskell just represents them as a number-like type on top of a number type
12:31:02 <AStorm> Complex integers are just weird.
12:31:21 <mwc> AStorm, yeah, but Cauchy's INtegral Formula rocks
12:31:40 <sjanssen> > log (-1) :: Complex (Complex Double)
12:31:41 <lambdabot>  add an instance declaration for (RealFloat (Complex Double))
12:31:41 <lambdabot>   In the exp...
12:31:55 <AStorm> Nope, Complex Complex is stupid :>
12:32:04 <emu> i^2!
12:32:06 <emu> er
12:32:09 <emu> ;)
12:32:25 <AStorm> i^2! = NaN
12:32:34 <mwc> emu, at the very least, you'd need to have a complex number be able to do anything a real can
12:32:43 <mwc> so you can't go and define a sin or log function for COmplex INt
12:32:50 <AStorm> Because (-1)! is undefined.
12:32:55 <emu> yep yep
12:33:08 <emu> > log (0 :+ 1)
12:33:09 <lambdabot>  0.0 :+ 1.5707963267948966
12:33:28 <mwc> right, imaginary side ain't an integer
12:33:43 <emu> the input is an integer, the output is nto
12:33:44 <sjanssen> the reason that we have instance (RealFloat a) => Complex a ... is because signum uses (/)
12:33:46 <mwc> so you don't have a properly typed function
12:33:53 <AStorm> It's actually ~1.5*i
12:34:00 <sjanssen> and the instance for Fractional uses realFloat in it's definition
12:34:20 <Dreadshoot> i^2! is -1
12:34:34 <AStorm> -1! = -1? WTF?
12:34:35 <Dreadshoot> (i^2)! = complexinf
12:34:46 <mwc> You can't take the factorial of a negative number
12:34:49 <emu> negative factorials?
12:34:55 <mwc> you can generalize the factorial to the gamma function
12:34:55 <Dreadshoot> 2 aint negative
12:34:59 <emu> well you could define some weird function heh
12:35:06 <mauke> does this code look sane? http://rafb.net/paste/results/cGOLnU77.html
12:35:12 <mwc> emu, you can, it's the Gamma functoin
12:35:21 <AStorm> Dreadshoot: i^2 is negative :>
12:35:23 <mwc> @wiki Gamma function
12:35:24 <emu> heh, silly operators
12:35:24 <lambdabot> http://www.haskell.org/haskellwiki/Gamma function
12:35:31 <emu> he meant (i^2)!
12:35:37 <Dreadshoot> ajonat_: yes
12:35:38 <emu> which binds more, ! or ^?!
12:35:48 <Dreadshoot> AStorm: even yes, but 2 aint
12:35:56 <emu> right or left assoc
12:36:11 <AStorm> Dreadshoot: Nope, go read about complex numbers.
12:36:17 <AStorm> i is an imaginary unit
12:36:38 <Dreadshoot> AStorm: i dont need to, i allready know it. its better if you go and read about complex numbers
12:36:50 <AStorm> i^2 = -1
12:36:55 <AStorm> So, i = sqrt(-1)
12:36:59 <AStorm> Go figure :>
12:37:02 <Dreadshoot> I^2! = I^(2!) = -1
12:37:07 <emu> i^(2!) is -1
12:37:10 <AStorm> That's the deiniion of the unit.
12:37:19 <AStorm> So, ^ binds weaker? Dammit :P
12:37:19 <emu> this is a silly syntactical argument
12:37:24 <Dreadshoot> AStorm: you are parsing it wrong
12:37:28 <AStorm> Blah.
12:37:31 <emu> obviously (i^2)! is more interesting and relevant
12:38:31 <musasabi> Is running callgrind on a GHC compiled executable supposed to take 900mb of ram?
12:39:09 <AStorm> You mean valgrind? Yes.
12:39:35 <musasabi> ok.
12:40:29 <sjanssen> why?
12:41:19 <AStorm> 1. debugging ghc libs are _huge_
12:42:07 <AStorm> 2. valgrind messes with ghc's garbage collector
12:42:47 <kolmodin> ?paste
12:42:48 <lambdabot> http://paste.lisp.org/new/haskell
12:44:19 <basvandijk> Hello, I would like to replace the Main.hs file at http://www.haskell.org/haskellwiki/GHC/As_a_library with a new version that works with GHC-6.6. How do I upload my file to the wiki?
12:44:21 <lambdabot> Title: GHC/As a library - HaskellWiki, http://tinyurl.com/kffsp
12:44:38 <lisppaste2> moonlite pasted "state" at http://paste.lisp.org/display/28228
12:45:53 <sjanssen> moonlite: could you annotate with the exact error messsage?
12:46:06 <moonlite> sure
12:46:48 <lisppaste2> moonlite annotated #28228 with "error" at http://paste.lisp.org/display/28228#1
12:49:13 <sjanssen> moonlite: does adding "functions :: State Program [Function]" remove that first error?
12:51:06 <moonlite> sjanssen: yes it does!
12:52:37 <shapr> AStorm: For me, Haskell is the best language available. But it depends on what is important to you, and what fits your head.
12:53:15 <moonlite> sjanssen: thx a lot!
12:53:45 <musasabi> aborted callgrind when it grinded at 1.8gb (appears to work, but need machine with lots of ram)
12:55:05 <ptolomy> if I have a [Double] and I want to apply a function (Double -> Double -> Double) to every adjacent element, is there a nifty way to do that? I've just been defining a function that matches (a:b:xs), and I feel like there is a better way.
12:55:38 <AStorm> foldr or foldl?
12:56:01 <velco> to adjiacent elts
12:56:05 <AStorm> @type foldr
12:56:07 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
12:56:38 <AStorm> With a starting element, of course.
12:56:41 <velco> he means from [a, b, c, d, ...] obtainign, say, [a + b, b + c, c + d, ...]
12:56:41 <resiak> > let xs = [0..4] in map (uncurry (+)) $ zip xs (tail xs)
12:56:43 <lambdabot>  [1,3,5,7]
12:56:44 <ptolomy> Right.
12:56:47 <AStorm> Now that's map.
12:57:07 <ptolomy> as in bezier interpolation.
12:57:38 * ptolomy stares at resiak's code.
12:57:49 <ptolomy> Oh.
12:57:53 <resiak> Hell,
12:57:59 <ptolomy> Neat.
12:58:05 <resiak> > let xs = [0..] in zipWith (+) xs (tail xs)
12:58:06 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:58:11 <ptolomy> I always forget that technique.
12:58:21 * resiak smacks himself upside the head for missing that
12:58:26 <AStorm> > let xs = [0..] in foldr (+) (head xs) (tail xs)
12:58:30 <lambdabot>  Exception: stack overflow
12:58:33 <AStorm> Hmm :>
12:58:50 <AStorm> Whoops ;-)
12:58:51 <resiak> AStorm: That means "sum xs"
12:58:59 <AStorm> I know :P
12:59:37 <ptolomy> let xs = [0..10] in zipWith (+) xs (tail xs)
12:59:41 <ptolomy> > let xs = [0..10] in zipWith (+) xs (tail xs)
12:59:43 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
13:00:18 <mauke> ?type (tail >>=) . zipWith
13:00:20 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
13:00:24 <AStorm> Simple and efficient
13:00:56 * resiak stares
13:01:08 * shapr boggles
13:01:14 <shapr> What am I boggling at anyway?
13:01:14 * mauke gobbles
13:01:15 * velco gazes
13:02:25 <AStorm> let xs = [0..16] in (tail >>=) . zipWith
13:02:32 <AStorm> Whoops.
13:02:34 <AStorm> > let xs = [0..16] in (tail >>=) . zipWith
13:02:35 <lambdabot>  Add a type signature
13:02:56 <AStorm> > let xs = [0..16] in ((tail >>=) . zipWith) :: [Integer] -> [Integer]
13:02:57 <lambdabot>  Couldn't match `a -> a -> c' against `[Integer]'
13:03:05 <AStorm> Hmm, wrong order.
13:03:20 <AStorm> ?type zipWith . (tail >>=)
13:03:22 <lambdabot> forall b c a. ([a] -> [a] -> b -> c) -> [[a]] -> [b] -> [c]
13:03:30 <velco> > let xs = [0..16] in (tail >>=) . zipWith xs
13:03:31 <lambdabot>  Couldn't match `[a] -> b' against `[c]'
13:03:34 <AStorm> No, that's perverse.
13:03:56 <AStorm> > let xs = [0..16] in zipWith . (tail >>=) xs
13:03:57 <lambdabot>    Expecting a function type, but found `[a]'
13:03:58 <lambdabot>    Expected type: [a1] -> ...
13:04:06 <sjanssen> > filterM (const [True, False]) "abcd"
13:04:07 <lambdabot>  ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","d...
13:04:31 <mauke> > let xs = [0 .. 16] in ((tail >>=) . zipWith) (+) xs
13:04:33 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31]
13:05:07 <AStorm> > let seqZip = ((tail >>=) . zipWith)
13:05:07 <lambdabot>  Parse error
13:05:13 <AStorm> > seqZip = ((tail >>=) . zipWith)
13:05:14 <lambdabot>  Parse error
13:05:14 <resiak> Hmm, why doesn't my ghci like mauke's expression...
13:05:20 <AStorm> Hates me :>
13:05:27 <mauke> resiak: :m +Control.Monad.Reader
13:05:40 <resiak> weird stuff.
13:05:43 <AStorm> Yes, for >>=
13:05:46 * resiak tries to figure out how it works.
13:05:51 <AStorm> ?type >>=
13:05:52 <lambdabot> parse error on input `>>='
13:05:55 <mauke> no, for instance Monad ((->) e)
13:05:56 <AStorm> ?type (>>=)
13:05:57 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
13:06:12 <AStorm> Yes yes, required by >>= :>
13:06:14 <mauke> AStorm: you need "in" if you want to use let
13:06:27 <AStorm> mauke: I know, wanted to define L.seqZip :>
13:06:45 <mauke> @let seqZip = ((tail >>=) . zipWith)
13:06:46 <lambdabot> Defined.
13:06:53 <AStorm> Huh.
13:07:05 <AStorm> > L.seqZip (+) [-1..]
13:07:06 <lambdabot>  [-1,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51...
13:10:20 <emu> > ['a'..'z']
13:10:21 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
13:10:49 <emu> > take 5000 . cycle $ ['a'..'z']
13:10:50 <lambdabot>  "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvw...
13:10:59 <AStorm> > L.seqZip (++) ['a'..'z']
13:11:01 <lambdabot>  Couldn't match `[a]' against `Char'
13:11:02 <emu> > sort . take 5000 . cycle $ ['a'..'z']
13:11:03 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:11:17 <AStorm> emu: trying to crash the bot? ;-)
13:11:20 <emu> hehe
13:11:27 <emu> > sort . cycle $ ['a'..'z']
13:11:31 <lambdabot> Terminated
13:11:51 <shapr> @dice 5d5
13:11:51 <lambdabot> 5d5 => 22
13:12:05 <xerox> The Goblin dodges the attack, shapr.
13:12:07 <shapr> For ShadowRun usage it should show all the results.
13:12:09 <AStorm> @dice idi
13:12:09 <chessguy> > (1,2,3,4,5)
13:12:10 <lambdabot> unexpected "i": expecting number
13:12:11 <lambdabot>  (1,2,3,4,5)
13:12:13 <AStorm> Hmm..
13:12:15 <emu> > take 10 . sort . cycle $ ['a'..'z']
13:12:16 <chessguy> > (1,2,3,4,5,6)
13:12:19 <lambdabot> Terminated
13:12:20 <lambdabot>  (1,2,3,4,5,6)
13:12:28 <AStorm> @dice (sqrt(-1)::Complex Double)d10
13:12:29 <lambdabot> unexpected "(": expecting number
13:12:30 <xerox> emu: you can't sort an infinite list.
13:12:31 <dolio> Imaginary sided dice?
13:12:34 <AStorm> Boohoo.
13:12:35 <emu> xerox: yea =)
13:12:45 <resiak> > ("why", "are", "you", "evaluating", "constant", "tuples?")
13:12:47 <lambdabot>  ("why","are","you","evaluating","constant","tuples?")
13:13:01 <emu> > ["when", "you", "could", "use", "lists?"]
13:13:02 <lambdabot>  ["when","you","could","use","lists?"]
13:13:03 <resiak> I don't mean "constant"
13:13:11 <chessguy> hmm. my hugs and ghci can't display 6-tuples, but they can display tuples up to size 5
13:13:22 <AStorm> Yes, they can't.
13:13:27 <xerox> ?instances Show
13:13:28 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
13:13:36 <dolio> Yeah, they added up to 15-tuples in 6.6.
13:13:37 <AStorm> Write your own better Show.
13:13:52 <dolio> I think it's 15, at least.
13:13:55 <sjanssen> dolio: 'tis my favorite feature ;)
13:14:04 <chessguy> so how can lambdabot do it, if it doesn't have (a,b,c,d,e,f,...)
13:14:11 <kpreid> IMO, it's a flaw in Haskell
13:14:16 <AStorm> chessguy: it does :>
13:14:23 <AStorm> ?type Show
13:14:24 <lambdabot> Not in scope: data constructor `Show'
13:14:27 <AStorm> Whoops
13:14:29 <AStorm> ?type show
13:14:30 <lambdabot> forall a. (Show a) => a -> String
13:14:35 <kpreid> 'They' should have either added a way to generalize instances over tuples or left out arbitrary-sized tuples.
13:14:38 <dolio> :)
13:14:39 <AStorm> ?type (1,2,3,4,5,6)
13:14:41 <lambdabot> forall a b c d e f. (Num a, Num b, Num c, Num d, Num e, Num f) => (a, b, c, d, e, f)
13:15:10 <chessguy> whatever, screw this, i'm using a list
13:15:53 <AStorm> Extend show yourself, quite simple.
13:16:15 <chessguy> i don't have time to mess with that right this minute
13:17:04 <dolio> kpreid: Yeah, that is kind of ugly.
13:24:43 <dolio> Geeze: "100% zsh IRC client"
13:29:46 <chessguy> does haskell have a notion of subtraction of lists?
13:29:57 <chessguy> e.g. [1,2]-[1]=[2]
13:30:03 <sjanssen> @hoogle //
13:30:04 <lambdabot> Array.(//) :: Ix a => Array a b -> [(a, b)] -> Array a b
13:30:04 <lambdabot> Data.Array.(//) :: Ix i => Array i e -> [(i, e)] -> Array i e
13:30:04 <lambdabot> Data.Array.IArray.(//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
13:30:21 <sjanssen> @type Data.List.(//)
13:30:23 <lambdabot> Couldn't find qualified module.
13:30:50 <chessguy> % [1,2] // [2]
13:30:57 <chessguy> > [1,2] // [2]
13:30:58 <lambdabot>  Couldn't match `Array i e' against `[a]'
13:31:06 <mauke> > [1,2] \ [2]
13:31:07 <lambdabot>  Parse error
13:31:17 <mauke> > [1,2] \\ [2]
13:31:18 <lambdabot>  [1]
13:31:22 <chessguy> aha
13:31:39 <sjanssen> ah yes
13:32:36 <dolio> > [2,2,2] \\ [2]
13:32:37 <lambdabot>  [2,2]
13:33:15 <chessguy> @type Data.List.(\\)
13:33:16 <lambdabot> Couldn't find qualified module.
13:33:21 <chessguy> @hoogle \\
13:33:21 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
13:33:26 <sjanssen> @type (Data.List.\\)
13:33:28 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:33:43 <dolio> > [2,2,2] \\ [2,2]
13:33:45 <lambdabot>  [2]
13:33:51 <mauke> smrt
13:34:05 <chessguy> hmm, i want to do something like [[a,b] | a<-[1..3],b<-[1..3]\\a,a+b==5]
13:34:27 <mauke> > [[a,b] | a<-[1..3],b<-[1..3]\\a,a+b==5]
13:34:28 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
13:34:28 <lambdabot>    Expected...
13:34:37 <dolio> \\ [a]
13:34:39 <mauke> > [[a,b] | a<-[1..3],b<-[1..3]\\[a],a+b==5]
13:34:40 <lambdabot>  [[2,3],[3,2]]
13:34:50 <mauke> > [[a,b] | a<-[1..3], b = 5 - a]
13:34:51 <lambdabot>  Parse error
13:34:52 <chessguy> oh, duh
13:35:05 <mauke> > [[a,b] | a<-[1..3], b <- [5 - a]]
13:35:06 <lambdabot>  [[1,4],[2,3],[3,2]]
13:35:32 <chessguy> bah, hugs doesn't know what \\ is
13:35:44 <mauke> import Data.List
13:35:45 <chessguy> ah
13:35:46 <chessguy> got it
13:52:44 <AStorm> ?type (\\)
13:52:46 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:52:53 <AStorm> What does that do?
13:53:07 <xerox> > [1..10] \\ [5..10]
13:53:09 <lambdabot>  [1,2,3,4]
13:53:11 <AStorm> Removes non-matching items?
13:53:18 <AStorm> Uh, matching items?
13:53:19 <xerox> Subtraction.
13:53:24 <AStorm> Yep.
13:53:53 <AStorm> > [1,1,2,3,4,4,5,6] \\ [1,2,3,4]
13:53:55 <lambdabot>  [1,4,5,6]
13:54:08 <AStorm> aha.
13:55:23 <AStorm> Is there some operator Eq a:: [a] -> [a] -> [a] that removes every item from first list that matches any item of the second one?
13:56:14 <araujo> @hoogle [a] -> [a] -> [a]
13:56:15 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
13:56:16 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:56:16 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:56:25 <AStorm> Hmm.
13:56:56 <AStorm> Nope.
13:57:22 <SamB> um...
13:57:30 <SamB> @hoogle difference
13:57:31 <lambdabot> Data.IntMap.difference :: IntMap a -> IntMap b -> IntMap a
13:57:32 <monochrom> @hoogle (\\)
13:57:32 <lambdabot> Data.IntSet.difference :: IntSet -> IntSet -> IntSet
13:57:32 <lambdabot> Data.Map.difference :: Ord k => Map k a -> Map k b -> Map k a
13:57:33 <lambdabot> Did you mean: (\\)
13:57:33 <lambdabot> Prelude.undefined :: a
13:57:33 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:57:43 <SamB> @type List.difference
13:57:44 <monochrom> Yes I did mean (\\)
13:57:45 <lambdabot> Not in scope: `List.difference'
13:57:51 <monochrom> @hoogle List.(\\)
13:57:51 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\)'
13:57:57 <monochrom> @hoogle List.(\\\\)
13:57:57 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\\\)'
13:58:02 <SamB> @type (\\)
13:58:02 <monochrom> @hoogle List.\\
13:58:03 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:58:04 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
13:58:19 <monochrom> Godawful
13:58:20 <SamB> monochrom: how about we just take this (\\) here?
13:58:38 <dolio> > let f a b = a \\ (intersect a b) in f [1,1,2,3,4,4,5,6] [1,2,3,4]
13:58:39 <lambdabot>  [5,6]
13:58:43 <SamB> I think ndm fixed that already but lambdabot doesnt't have the fixed version
13:58:57 <SamB> well.
13:59:13 <monochrom> What is meant by "take this (\\) here"?
13:59:20 <SamB> the part about @hoogle (\\) saying "do you mean: (\\)"
13:59:24 <SamB> anyway...
13:59:30 <AStorm> dolio: looks ugly and evil :>
13:59:32 <AStorm> Also slow :>
13:59:33 <SamB> > "hello" \\ "hi"
13:59:34 <lambdabot>  "ello"
14:00:00 <monochrom> I think I don't understand English anymore.
14:00:20 <SamB> monochrom: I'm all out of order and stuff
14:00:21 <SamB> so...
14:00:24 <SamB> don't go by me!
14:00:57 <therp> as far I understand you get parallel graph reduction for free in Haskell, is that correct?
14:00:57 <SamB> therp: ... what?
14:01:06 <monochrom> Yes but nobody is exploiting it.
14:01:10 <SamB> that must be some... strange varient...
14:01:26 <SamB> it might not be very efficient...
14:01:52 <therp> samb: ok let's say, you get concurrency for free. shouldn't that be possible with pure functional programming?
14:01:59 <SamB> therp: it is
14:02:30 <SamB> but I don't know of an up-to-date Haskell implementation that supports that...
14:02:48 <ropine> in theory one could design a purely-functional language in which every time the compiler encountered "f (g x, h y)" it would execute g and h in parallel
14:02:52 <SamB> and also I'm not sure you get much more than you pay for
14:03:05 <SamB> (i.e. perhaps free concurrency isn't worth much anyway)
14:03:17 <ksandstr> they say the latest ghc has support for SMP concurrency, if you annotate your code with `par` appropriately. haven't tried that since it's not in debian testing yet, but...
14:03:20 <SamB> (in the context of a general purpose language, I mean)
14:03:38 <ropine> but this would only be a win if, on average, the time saved by running stuff in parallel was greater than the time lost by forking off threads
14:03:51 <SamB> yeah
14:04:13 <SamB> also it only works if you already had multiple cores ;-)
14:04:14 <dolio> let f a b = filter (`notElem` b) a in f [1,1,2,3,4,4,5,6] [1,2,3,4]
14:04:19 <dolio> > let f a b = filter (`notElem` b) a in f [1,1,2,3,4,4,5,6] [1,2,3,4]
14:04:21 <lambdabot>  [5,6]
14:04:27 <SamB> dolio: isn't that the same as (\\)?
14:04:37 <AStorm> dolio: anything faster?
14:04:40 <dolio> No, (\\) only removes the first.
14:04:44 <AStorm> SamB: no, it removes all elements matching.
14:04:46 <SamB> oh really?
14:04:55 <therp> samb: I was thinking of grid computing, because I have just seen that term on planet.haskell.org
14:05:03 <AStorm> dolio: at least it isn't ugly :>
14:05:26 <SamB> currently if you want decent parralism you need to pay at least a little ;-)
14:05:52 <therp> samb: pay in.. money/code style/..?
14:05:52 <shapr> therp: Check out Manuel Chakravarty's nested data parallel arrays
14:06:08 <dolio> I guess. My first one is just "remove the intersection of a and b from a".
14:06:26 <shapr> Transparent parallelism is the great dream of pure FP, but hasn't gotten much closer in the last fifteen years because the average person didn't have any parallel hardware.
14:06:28 <shapr> Only now is that changing.
14:06:43 <SamB> well, you at least need to write a little explicit code for the parallism
14:06:59 <SamB> right now
14:07:15 <shapr> You don't need any explicit code with the NDP arrays. They're automatically unrolled. But they don't yet run on ghc-smp. ChilliX is working on that.
14:07:18 <SamB> unless you find some whiz-bang library for your application that already does
14:07:27 <SamB> shapr: ooooooh
14:07:33 <SamB> finally those will be *useful*?
14:07:37 <shapr> Very much so.
14:07:48 <shapr> That sort of thing is already being done with shader languages like Cg
14:07:54 <SamB> what next? will they be documented in the GHC manual then?
14:08:34 <SamB> and, like, exported with a decent module name?
14:08:46 <shapr> I think ghc-smp is only thread level parallel right now, but I haven't kept up with it. Where did you read about par being used with ghc-smp?
14:09:04 <SamB> I was assuming par forked off at least one thread?
14:09:09 * shapr doesn't know
14:09:44 <shapr> In GdH etc I think par worked sort of like ($) and just said "this is an opportunity for parallel execution"
14:09:54 <SamB> oh
14:10:23 <SamB> which module is it in?
14:10:24 <monochrom> <joke>I won't hold my breath for transparent concurrency.  Gosh, we have gigs of RAM and we are not quite at transparent memory management yet!  People still want to malloc and free by hand.  I am just grateful I can see transparent translation of algebraic expressions into register loads and stores in my lifetime.  I think most people agree that's enough progress for one generation.</joke>
14:10:44 <shapr> Still, AMD is talking about their four core dies, and Movidis already sells sixteen core MIPS systems. I can barely wait till we get consumer level systems with sixteen cores.
14:10:45 <SamB> heh
14:11:11 <ChilliX> SamB,shapr: yes, par work with ghc-smp, see http://haskell.org/haskellwiki/GHC/Concurrency
14:11:12 <SamB> monochrom: well, I'm not in that generation -- C is older than I am isn't it?
14:11:13 <lambdabot> Title: GHC/Concurrency - HaskellWiki, http://tinyurl.com/t6xef
14:11:16 <SamB> I'm only 20!
14:11:17 <ChilliX> (under the Multiproc heading)
14:11:21 <shapr> I'm only 35!
14:11:30 <monochrom> I'm only 37!
14:11:32 <shapr> go ChilliX!
14:11:34 <shapr> w00!
14:11:44 <shapr> ChilliX: Any ETA on the NDP arrays on top of ghc-smp?
14:11:48 <ChilliX> re data parallelism, there is some docu since two days ago: http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
14:11:50 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
14:12:00 <shapr> yay!
14:12:05 <SamB> ChilliX: I meant in the HTML ;-)
14:12:17 <SamB> the only documentation I have seen so far was a paper
14:12:30 <SamB> which I probably read years ago
14:13:10 <ChilliX> shapr: eta is difficult, spj wants something serious running by the end of the year
14:13:24 <shapr> Is anyone giving out ssh logins to a 2+ core system? I'd love to try this stuff :-)
14:13:30 <ChilliX> currently we are fighting with fusion vs GHC's otrher optimisations
14:13:37 <SamB> shapr: well. Lemmih gave me one
14:13:43 <SamB> but it was for GHC hacking...
14:13:55 <shapr> I gave away my dual Athlon when I left Sweden...
14:14:06 <shapr> ChilliX: Sounds exciting
14:14:14 <SamB> it seems to be a genuine 2-core machine
14:14:45 <SamB> because I can get two processes going at nearly 100% CPU usage
14:15:10 <SamB> and anyway, I'm building GHC's libraries on it right now ;-)
14:15:32 <ChilliX> (most of the work on SMP-ising the array libraries is btw by Roman Leshchinksiy who is a researcher in our group at UNSW)
14:15:51 <shapr> cool
14:15:58 <ChilliX> (plus SPJ fixing truck loads of optimisation problems)
14:16:03 <SamB> ChilliX: this is just for the PArrays isn't it?
14:16:54 <ChilliX> SamB: I don't think we currently have PArrays, we have UArrs (unlifted arrays)
14:17:03 <ChilliX> smp is for those
14:17:21 <ChilliX> which is sufficient, becuse everything else is compile ddown to those
14:17:23 <shapr> I think NDP arrays will be extremely popular when four core x86 systems are standard.
14:17:29 <velco> JALH?
14:17:30 <SamB> ChilliX: what is this, then?
14:17:32 <SamB> /home/samb/ghc/libraries/base/GHC/PArr.hs
14:17:50 <ChilliX> this is an *unoptimised* array library
14:18:01 <ChilliX> its what we have in mind as the *final* API
14:18:06 <SamB> yeah.
14:18:08 <SamB> I know.
14:18:23 <shapr> ChilliX: I'm looking forward to this, it kicks butt!
14:18:26 * shapr boings
14:18:28 <ChilliX> but that requires a program transformation from PArr arrays to UArrs, which we will work on next year
14:18:33 <SamB> except hopefully you aren't planning on keeping the API *there*?
14:18:39 <ChilliX> no
14:19:07 <ChilliX> shapr: well, let's hope we get all these technical challanges out of the way
14:19:48 <mauke> is there a way to share a private variable between all methods in an instance declaration?
14:19:55 <ChilliX> after all, GHC has to turn purely functional high-level array code in superfast C-like loops and keep all the threads business happy
14:20:23 <shapr> I think it'll work out.
14:20:27 <ChilliX> :)
14:20:28 * SamB thinks it would be super cool if that API could be implemented efficiently *outside* GHC somehow...
14:20:35 <ChilliX> shapr, you are great :)
14:20:44 <ChilliX> outside?
14:20:47 <SamB> probably a few extensions away, though ;-P
14:21:04 <monochrom> there are private variables?
14:21:26 <SamB> as in, in library code? that could work on any implementation with the right type system extensions and such?
14:21:42 <SamB> monochrom: what?
14:21:43 <mauke> argh, you can't just slap a "where" at the end :/
14:21:49 <chessguy> ok, here's a cool riddle. i just solved it in haskell in 22 lines, wondering who can do it in less. find a 9-digit number divisible by 9, such that if you remove the 9th digit, you get an 8-digit number, divisible by 8, such that if you remove the 8th digit, you get a 7-digit number divisible by 7, and so on. it must use all the numbers from 1 to 9 exactly once each
14:22:00 <ChilliX> SamB: that won't work, see the brief impl outline at http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
14:22:02 <mauke> monochrom: as in "local to a bunch of functions"
14:22:03 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
14:22:11 <monochrom> concat is your friend.  22 lines into 1.
14:22:20 <chessguy> bah
14:22:22 <SamB> ChilliX: how do you know you can't do that with type system stuff?
14:22:53 <ChilliX> SamB: we need to have a program transformation, we currentyly call code vectorisation (but which is also known as flattening)
14:23:07 <SamB> yes I know
14:23:15 <ChilliX> it is like CPS conversion or something, where you need to take AST and rewrite that quite badly
14:23:19 <monochrom> Can I find out by myself and hardcode it in the program?
14:23:19 <SamB> I read the paper ;-)
14:23:29 <ChilliX> so, maybe some more ellaborate verasion of Template Haskell would let you do that
14:23:32 <ChilliX> ah, ok :)
14:23:33 <chessguy> monochrom, that wouldn't be any fun
14:23:44 <chessguy> well, it might be fun, but not fun with haskell
14:24:16 <shapr> Man, I wish I could write lambdas in shell scripts.
14:24:34 <Taral> Oh, god.
14:24:40 <monochrom> Where is the 9th digit?
14:24:41 <Taral> So I've determined that I need to build a postdominator tree. :(
14:24:51 <chessguy> the least significant one
14:25:05 <chessguy> so 123456789 becomes 12345678
14:25:10 <shapr> Taral: In OCaml?
14:25:21 <ChilliX> Well, even if ndp isn't ready for general concumption, I am just testing the overlap check for type-indexed data types (aka associated data types) and then that's basically ready for everybody to try (wll, I need to write some docs)
14:25:23 <SamB> ChilliX: iirc GHC can already do the flattening to some extent?
14:25:23 <Taral> Yes.
14:25:45 <Taral> Thankfully, I think the CFG generator numbers the nodes in preorder, so I can use that.
14:26:21 <ChilliX> SamB: there is a partial impl, but we'llstart from scratch.  We got a better method now that can deal better with higher-order functions: http://www.cse.unsw.edu.au/~chak/papers/LCK06.html
14:26:22 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/ygng9v
14:26:45 <SamB> ChilliX: neat!
14:27:32 <chessguy> mine takes about 2 minutes to evaluate
14:27:37 <chessguy> at least in winHugs
14:27:39 <Taral> ChilliX: What are you working on?
14:27:59 <SamB> Taral: we are talking about the NDP flattening transformation in GHC
14:28:14 <Taral> ndp?
14:28:30 <chessguy> heh. 15 seconds in ghci
14:28:31 <ChilliX> Taral: type-indexed types (aka associated types)
14:29:13 <SamB> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
14:29:15 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
14:29:21 <ChilliX> Taral: well, I am hacking type-indexed types right now, but we have this project about ndp, which we have been talking about right now (its with Roman Leshchinksiy in Sydney and the Simons)
14:29:47 <Taral> what does ndp stand for?
14:29:54 <ChilliX> nested data parallelism
14:30:21 <ChilliX> so, data parallelism, where you can have data parallel computations within other data parallel computations
14:30:37 <Taral> ah
14:30:53 <SamB> oh, and here I was always thinking it was the *data* that was nested ;-)
14:31:06 <ChilliX> This paper explains how we integrate this into Haskell: http://www.cse.unsw.edu.au/~chak/papers/CKLP01.html
14:31:07 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/sduvq
14:31:52 <AStorm> Are there any SIMD libraries for Haskell?
14:32:07 <AStorm> I mean utilising hardware SIMD support.
14:32:18 <SamB> ... not yet
14:32:44 <AStorm> Hmm...
14:32:58 <SamB> at least, not unless these compilers are a lot smarter than they look...
14:33:05 <SamB> (GHC and GCC)
14:33:09 <Taral> Why doesn't anyone post their text source files instead of formatted postscript?
14:33:10 <Taral> :(
14:33:17 <mathewm> I am looking at Epigram and wondering what haskell extensions might exist to implement/answer-to dependent types ( anything in GHC already?)
14:33:24 <SamB> Taral: those are also available!
14:33:35 <Taral> Yes, but they're not posted.
14:33:37 <SamB> its just that they are in a state of flux!
14:33:46 <SamB> and probably in various repositories...
14:33:49 <ChilliX> Taral: text as in LaTeX?  That's usually a mess.
14:33:56 <Taral> Yes, but it's text.
14:34:01 <SamB> like http://darcs.haskell.org/packages/ndp/
14:34:02 <AStorm> SamB: I meant something non-automatic :>
14:34:03 <lambdabot> Title: Index of /packages/ndp
14:34:16 <dolio> chessguy: Do you have an answer I can check mine against?
14:34:19 <Taral> SamB: I meant of the paper, not of the code.
14:34:22 <SamB> oh!
14:34:39 <SamB> you can't read ps files?
14:34:45 <Taral> I can, it's just annoying.
14:35:01 <ChilliX> Taral: reading LaTeX source, isn't fun, either, believe me
14:35:08 <SamB> (hint: they are supposed to be rendered into raster form first, not consumed through "cat", "less", "vi", or "emacs"
14:35:12 <Taral> ChilliX: Probably, but I can post-process LaTeX into text.
14:35:21 <ChilliX> nope, not for that stuff
14:35:33 <ChilliX> well, not any better than ps2ascii can do it for you
14:35:39 <AStorm> Process LaTeX into PDF.
14:35:43 <SamB> probably worse!
14:35:58 <SamB> ps2ascii has the benefit of not having to deal with TeX syntax or macros
14:37:57 <shapr> mathewm: functional dependencies.
14:38:22 <mathewm> shapr: oh...
14:39:50 <mathewm> so, epigram seems to claim dependent types can lead to safe-gaurds against broader logic errors; I am not making a similar connection with functional deps.
14:40:09 <SamB> GADTs and ATs are also related...
14:40:23 <mauke> argh
14:40:34 <mauke> hc-6.4.2: panic! (the `impossible' happened, GHC version 6.4.2): ByteCodeFFI.mkMarshalCode_wrk(x86) L_
14:40:39 <mathewm> what is an AT?
14:40:51 <SamB> ATs are Associated Types
14:40:58 <SamB> I don't think there is a singular ;-P
14:41:07 <sjanssen> matthewm: we can attempt to do more computation at the type level -- fundeps give us a way to do type computation
14:41:13 <ChilliX> heh..AT
14:41:28 <dolio> Well, a class could have a single AT.
14:41:45 <SamB> maybe.
14:41:59 <mathewm> is there a good synthesis document on these topics?
14:42:00 <mauke> why does ghc hate me :(
14:42:16 <mathewm> what are you doing to get 6.4.2 to crash?
14:42:35 <mauke> loading Onyx.hs in ghci, which contains a few FFI calls
14:42:42 <mathewm> that often happens when you use an improperly initialized structure in the ghc implementation
14:42:46 <Taral> Aww, he quit. I solved his problem in 13 lines (including empty lines)
14:42:53 <ChilliX> mathewm: not really (synthesis document)
14:43:02 <dolio> Taral: What answer did you get?
14:43:11 <mathewm> ChilliX: thanks
14:43:13 <Taral> 381654729
14:43:26 <dolio> Ah, same here.
14:43:40 <sjanssen> matthewm: check out Oleg's posts on the Haskell ML for examples of pushing the type system to do more work
14:43:41 <dolio> 9 lines (including blanks).
14:43:43 <dolio> :)
14:43:57 <dolio> ?paste
14:43:57 <lambdabot> http://paste.lisp.org/new/haskell
14:44:37 <lisppaste2> dolio pasted "chessguy's problem" at http://paste.lisp.org/display/28242
14:45:17 <Taral> dolio: 9 too, once I took out the unnecessary monad.
14:45:51 <Taral> dolio: Cute.
14:46:03 <Taral> I based it on:
14:46:04 <Taral> main = print $ filter (filt 9) $ map read $ perms "123456789"
14:47:10 <Taral> @pl \a b -> a + b * 10
14:47:11 <lambdabot> (. (10 *)) . (+)
14:47:14 <Taral> @pl \a b -> b * 10 + a
14:47:15 <lambdabot> (. (10 *)) . (+)
14:47:18 <Taral> @pl \a b -> 10 * b + a
14:47:18 <lambdabot> (. (10 *)) . (+)
14:47:21 <Taral> @pl \a b -> a + 10 * b
14:47:21 <lambdabot> (. (10 *)) . (+)
14:47:25 <Taral> weird!
14:48:28 <Taral> Okay, goes a bit faster with the foldr instead of the read
14:54:05 <jgrimes> so even though we can use things like greek letters in haskell now, capital greek letters get treated as data constructors?
14:54:13 <jgrimes> well, in ghc
14:55:16 <norpan> that sounds resonable
14:55:22 <jgrimes> =/
14:55:44 <AStorm> Taral - normal and mathematically equivalent :>
14:57:48 <jgrimes> I wanted to use Î£ and Î  for sums and products. =/
14:58:34 <SamB> aww!
14:58:47 <SamB> should be operators!
14:59:01 <SamB> or, rather, regular letters...
14:59:05 <dolio> > let ? = sum in ? [1,2,3,4]
14:59:06 <lambdabot>  Parse error
14:59:23 <lisppaste2> monochrom pasted "9 digits" at http://paste.lisp.org/display/28243
14:59:54 <SamB> @tell dons I have another patch stuck in the cvs-ghc moderation queue
14:59:54 <monochrom> How do I leave a note for cheesguy?
14:59:55 <lambdabot> Consider it noted.
14:59:57 <AStorm> Maybe proper logical operators too? :>
15:00:17 <SamB> @tell cheesguy monochrom wants to leave you a note ;->
15:00:18 <lambdabot> Consider it noted.
15:00:58 <AStorm> > let ? = sum in (?) [1,2,3,4]
15:00:58 <lambdabot>  Parse error
15:01:05 <AStorm> Ugh?
15:01:07 <monochrom> @tell chessguy http://paste.lisp.org/display/28243
15:01:07 <lambdabot> Consider it noted.
15:01:09 <AStorm> Should work.
15:01:23 <monochrom> I spelt chessguy wrong :)
15:01:27 <dolio> > let (?) = sum in (?) [1,2,3,4]
15:01:29 <lambdabot>  10
15:01:30 <SamB> monochrom: yes I know ;-)
15:01:52 <monochrom> OK so my solution is shorter and also faster :)
15:01:55 <SamB> which is why I have no qualms about leaving embarrassing notes about you for that nick ;-)
15:02:06 <jgrimes> AStorm, that would be nice too
15:02:16 <dolio> @tell chessguy http://paste.lisp.org/display/28242
15:02:16 <lambdabot> Consider it noted.
15:02:22 <monochrom> Well since the wrong nick doesn't exist, no one will find out
15:02:31 <SamB> dolio: he spelt it right when he left the message...
15:02:41 <SamB> only when he was asking how did he spell it wrong!
15:02:42 <dolio> That was my solution.
15:02:46 <SamB> oh.
15:02:50 <SamB> hehe
15:03:01 * SamB didn't notice the 2 vs the 3
15:04:05 <monochrom> Cool stuff.
15:04:24 <dibblego> data Foo a = Bar a -- how do I make a of type class (say Eq)?
15:04:36 * monochrom loves [a] as a search monad
15:05:28 <monochrom> Also this problem benefits from building the solution bottom-up so you can do early abortion of dead ends.
15:05:32 <SamB> dibblego: you say "Eq a =>" everywhere
15:05:42 <lisppaste2> mauke pasted "ghci bug" at http://paste.lisp.org/display/28245
15:05:57 <dibblego> SamB, I cannot declare it on the data type?
15:06:03 <mauke> can anyone reproduce this bug?
15:06:16 <SamB> dibblego: maybe you could, but it probably wouldn't do what you want
15:06:34 <SamB> because most likely you will be wanting to actually call (==) on things
15:06:35 <dibblego> I just want to be of a certain type class
15:06:48 <SamB> and that won't let you
15:07:04 <SamB> (or, rather, won't help you)
15:07:05 <dibblego> why not?
15:07:14 <dolio> Yeah, constraints on data doesn't propogate like you'd want it to, right?
15:07:21 <SamB> dolio: indeed
15:07:27 <Cale> @source Control.Monad
15:07:27 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
15:07:33 <dolio> data (Eq a) => Foo a...
15:07:36 <dibblego> data Foo Int = Bar Int -- I can do that
15:07:55 <dolio> Trying to make Foo an instance of: class (Eq a) => Baz a...
15:07:56 <SamB> basically the reason is that the dictionary-passing implementations won't store the dictionaries in constructors...
15:08:12 <AStorm> dibblego: derives (Eq)
15:08:47 <dolio> You still need instance (Eq a) => Baz ..., since Eq a => won't be remembered for Foo a.
15:08:53 <SamB> dolio: I think the problem is that you have too many as
15:09:10 <mauke> please, it's just 4 lines
15:09:10 <SamB> switch to another letter for your datatype ;-)
15:09:32 <dolio> Yeah, my example is probably wrong.
15:10:12 <dolio> mauke: Same problem here.
15:10:29 <dibblego> is there a fast packed bit string?
15:10:56 <chessguy> heh. it's pretty sad when the same evaluation with the same code takes 15 seconds to run in ghci and 2 minutes to run in Hugs
15:10:56 <lambdabot> chessguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:11:03 <chessguy> woohoo!
15:11:50 <SamB> some wiseass also left a message for cheesguy ;-)
15:11:51 <sjanssen> dibblego: UArray i Bool automatically packs the bits into bytes
15:12:04 <SamB> sjanssen: into bytes or into words?
15:12:08 <dibblego> @hoogle UArray
15:12:08 * shapr yodels
15:12:09 <lambdabot> Data.Array.Unboxed.UArray :: data UArray i e
15:12:09 <lambdabot> Data.Array.Diff.DiffUArray :: type DiffUArray
15:12:09 <lambdabot> Data.Array.IO.castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
15:12:19 <sjanssen> SamB: oh, might be words.  Can't really remember
15:12:24 <chessguy> nice, a 6-line solution and a 10-line solution
15:12:35 <shapr> @yodel hoogle
15:12:35 <lambdabot> Unknown command, try @list
15:12:37 <SamB> anyway it bitpacks the Bools
15:12:47 <SamB> one way or another
15:12:56 <SamB> it doesn't really matter too much, its slowish anyway...
15:13:19 <dibblego> perhaps I could just defined data Bit = ON | OFF
15:13:26 <chessguy> kudos to dolio for the best solution so far
15:13:47 <dolio> I rather like monochrom's, really.
15:13:48 <sjanssen> SamB: right, because there's no interface to access the bits without using indexing, which is expensive
15:14:23 <dibblego> mauke, I reproduce it - ghc 6.4.1 debian/ubuntu
15:15:07 <Axioplase> Hi !
15:15:57 <Axioplase> Eternal beginner question : why "let foo = do x <- 1; return x" wouldn't work, whereas "let foo = do x <- [1]; return x" does ? (testing in ghci, hence the let)
15:16:36 <norpan> because the thing on the right side of <- has to be a monad
15:16:42 <AStorm> Uh, return does something entirely else.
15:16:49 <AStorm> Not what you think it does.
15:17:07 <AStorm> It unwraps a datatype from an action by executing it.
15:17:25 <AStorm> Or something like that :P
15:18:00 <Botty> takes off the monad wrapper
15:18:02 <Axioplase> humm.. and an array is considered a monad ?
15:18:04 <mauke> no, return wraps a value in a monadic container
15:18:14 <mauke> [] (list) is a monad
15:18:14 <AStorm> Uh, vice versa, yep.
15:18:40 <Axioplase> haa... now I now that [] is a monad, I quite get it...
15:18:44 <Botty> >[1..]
15:18:55 <Botty> > [1..]
15:18:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:19:19 <Botty> > do x <- 1; x
15:19:20 <lambdabot>  add an instance declaration for (Show (m b))
15:19:21 <AStorm> > [-1,-2,-3,-5,-7,-11,...]
15:19:22 <lambdabot>  Parse error
15:19:24 <AStorm> > [-1,-2,-3,-5,-7,-11,..]
15:19:24 <lambdabot>  Parse error
15:19:26 <AStorm> > [-1,-2,-3,-5,-7,-11..]
15:19:27 <lambdabot>  Parse error
15:19:36 <AStorm> Hmm, it's not all that intelligent ;-)
15:19:39 <AStorm> > [-1,-2..]
15:19:41 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
15:20:06 <Botty> > [-1,-2,-4...]
15:20:07 <lambdabot>  Parse error
15:20:10 <chessguy> is the [] monad what figures out stuff like that?
15:20:13 <Botty> yeah, can only do steps
15:20:18 <shapr> It's Enum
15:20:29 <chessguy> @where Enum
15:20:30 <lambdabot> I know nothing about enum.
15:20:31 <mauke> > enumFrom 2
15:20:33 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
15:20:35 <AStorm> @hoogle Enum
15:20:36 <lambdabot> Prelude.Enum :: class Enum a
15:20:36 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
15:20:36 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
15:21:03 <int-e> > enumFromThenTo 5 7 14
15:21:05 <lambdabot>  [5,7,9,11,13]
15:21:05 <Botty> @type [1...]
15:21:07 <lambdabot> parse error on input `]'
15:21:19 <int-e> > [5,7..14]
15:21:21 <lambdabot>  [5,7,9,11,13]
15:21:29 <Botty> @type [1..]
15:21:30 <lambdabot> forall a. (Num a, Enum a) => [a]
15:21:51 <AStorm> How would one construct an infinite list of prime numbers? (might be that mod n congruency, even though it's not all that accurate)
15:21:55 <shapr> You can build all the sequences you want with lazy lists.
15:22:07 <Botty> > let foo = do x <- 1; x in foo
15:22:08 <lambdabot>  add an instance declaration for (Show (m b))
15:22:13 <shapr> > take 5 fib where fib = 0 : 1 : zipWith (+) fib (tail fib)
15:22:14 <lambdabot>  Parse error
15:22:15 <mauke> what was the sieve trick for that?
15:22:25 <shapr> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in take 5 fix
15:22:26 <lambdabot>    Expecting a function type, but found `[a]'
15:22:26 <lambdabot>    Expected type: [a]
15:22:26 <lambdabot>   ...
15:22:27 <shapr> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in take 5 fib
15:22:28 <lambdabot>  [0,1,1,2,3]
15:22:31 <AStorm> modulo n congruency is that trick :>
15:22:56 <Botty> _ can't be used as an operator, can it? (subscript)
15:23:10 <int-e> > let sieve (n:ns) (p:ps) | p*p == n = sieve (filter (\n -> n`mod`p /= 0) ns) ps | otherwise = n:sieve ns (p:ps); primes = 2:3:sieve [5,7..] (tail primes) in primes
15:23:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:23:22 <AStorm> Huh, funky :D
15:23:28 <mauke> > let primes = 2 : sieve primes; sieve (p : ns) = p : sieve (filter (\n -> n `mod` p /= 0) ns) in primes
15:23:29 <lambdabot>  Exception: <<loop>>
15:23:33 <mauke> :(
15:23:54 <mauke> d'oh
15:24:27 <mauke> > let primes = 2 : sieve [3, 5 ..]; sieve (p : ns) = p : sieve (filter (\n -> n `mod` p /= 0) ns) in primes
15:24:28 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:24:31 <AStorm> Now that's excellent mod n sieve :>
15:24:34 <AStorm> ?type sieve
15:24:36 <lambdabot> Not in scope: `sieve'
15:25:15 <AStorm> What is it?
15:25:36 <mauke> sieve (p : ns) = p : sieve (filter (\n -> n `mod` p /= 0) ns)
15:25:36 <AStorm> Ah, wait, you've just defined it recursively :P
15:25:49 <int-e> > let sieve (n:ns) (p:ps) | p*p == n = sieve (filter (\n -> n`mod`p /= 0) ns) ps | otherwise = n:sieve ns (p:ps); primes = 2:3:sieve [5,7..] (tail primes) in primes !! 10000
15:25:51 <lambdabot>  104743
15:26:12 <AStorm> @let sieve (p:ns) = p : sieve $ filter (\n -> n `mod` p /= 0) ns
15:26:13 <lambdabot> Couldn't match `[a]' against `[a] -> t'
15:26:23 <AStorm> @let sieve (p:ns) = p : sieve (filter (\n -> n `mod` p /= 0) ns)
15:26:24 <lambdabot> Defined.
15:26:28 <Cale> > let combs = filterM [True, False] in combs [1,2,3]
15:26:29 <lambdabot>  Couldn't match `a -> m Bool' against `[a1]'
15:26:35 <Cale> > let combs = filterM (const [True, False]) in combs [1,2,3]
15:26:37 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:26:37 <AStorm> @type L.sieve
15:26:39 <lambdabot> Couldn't find qualified module.
15:26:44 <AStorm> ?type L.sieve
15:26:46 <lambdabot> Couldn't find qualified module.
15:26:57 <AStorm> Hmm...
15:27:37 <Axioplase> Ok, now an easy one.. how could I (naively, not with evil hs features), write a function "inc" so that inc() -> 0, then inc() -> 1, and so on... ? (ie how to write a counter/reference)
15:28:21 <chessguy> hey dolio?
15:28:26 <dolio> Yeah?
15:28:41 <chessguy> care to give any explanation as to how your algo works?
15:29:02 <dolio> Okay, well...
15:29:03 <AStorm> Axioplase: that's not a function, that's a monad
15:29:07 <Botty> Axioplase - sounds like you want a lazy generator
15:29:28 <AStorm> @hoogle generate
15:29:29 <lambdabot> Test.QuickCheck.generate :: Int -> StdGen -> Gen a -> a
15:29:29 <Botty> except not because sounds like you mean a function that has state... which is a monad...
15:29:30 <lambdabot> System.Win32.Mem.hEAP_GENERATE_EXCEPTIONS :: HeapAllocFlags
15:29:37 <AStorm> @hoogle generator
15:29:38 <lambdabot> Language.Haskell.Syntax.HsGenerator :: SrcLoc -> HsPat -> HsExp -> HsStmt
15:29:45 <AStorm> Blah.
15:29:49 <dolio> chessguy: f turns [d1,d2,d3...,dn] into the number dn..d3d2d1.
15:29:53 <Botty> I mean generator as in a lazy infinite list
15:30:04 <Axioplase> Botty: yep.. maybe... but I want to know how to write it, not what lib to use...
15:30:25 <chessguy> ok, that's easy
15:30:47 <chessguy> ah, using point=free programming
15:30:49 <Botty> uh, yeah lazy infinite lists are part of the language
15:31:05 <AStorm> > [1..]
15:31:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:31:09 <Botty> > let inc = [0..] in inc
15:31:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:31:10 <Botty> yeah
15:31:18 <AStorm> > [1..] !! 10000
15:31:20 <lambdabot>  10001
15:31:39 <chessguy> drop 1000 $ [1..]
15:31:42 <chessguy> > drop 1000 $ [1..]
15:31:43 <lambdabot>  [1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,...
15:31:54 <chessguy> > head . drop 1000 $ [1..]
15:31:56 <lambdabot>  1001
15:32:08 <dolio> chessguy: g n finds all lists like the above such that 1) the list represents an n digit number, 2) each digit is used at most once, 3) n divides the number 4) the tails are appropriately divisible as well.
15:32:19 <dolio> chessguy: Which works like so:
15:32:44 <fpierre08> is there anything similar to "struct" in haskell?
15:32:51 <dolio> chessguy: 1) Find all such lists for (n-1) "g (n-1)"
15:32:53 <mauke> fpierre08: yes, data
15:32:55 <AStorm> fpierre08: a datatype? :>
15:33:00 <sieni> fpierre08: for example a tuple
15:33:04 <Axioplase> Botty: well.. either I don't think as I should, either I still need somewhere to tell where in my list I am (or to store the end of the lsit after reading the head)
15:33:16 <AStorm> But remember, it's data, can't be used to keep state.
15:33:20 <fpierre08> tnx :)
15:33:23 <AStorm> (unlike a C struct)
15:33:38 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html to the rescue
15:33:40 <lambdabot> http://tinyurl.com/y44crg
15:33:49 <chessguy> ohhhh, i think i get it
15:33:52 <dolio> chessguy: 2) for each of those "k <-", pick a digit d from the available candidates, which is [1..9] with the digits in k removed "\\ k"
15:33:53 <dons> hey all
15:33:55 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:34:13 <chessguy> hi dons
15:34:14 <dolio> chessguy: 3) Test that (d:k) is divisible by n
15:34:33 <chessguy> very nice
15:35:06 <int-e> which is the 1st digit?
15:35:20 <mauke> n `mod` 10
15:35:29 <chessguy> int-e: Find a 9-digit number divisible by 9, such that if you remove the
15:35:29 <chessguy> least significant digit (LSD), you get an 8-digit number, divisible by
15:35:29 <chessguy> 8, such that if you remove the LSD, you get a 7-digit number divisible
15:35:29 <chessguy> by 7, and so on. It must use all the numbers from 1 to 9 exactly once
15:35:29 <chessguy> each.
15:35:54 <hyraxfourtwo> > let combs = filterM (const [False,True]) in combs [1,2,3]
15:35:56 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
15:36:20 <fpierre08> k.. so what if i had a struct (called "blah") where i had name = "andre" and average = 90.00 .. in a struct i would access it as blah.name and blah.average... how would i do that with data ?
15:36:52 <fpierre08> hmm.. <AStorm> But remember, it's data, can't be used to keep state.
15:36:53 <mauke> data Blah = Blah { name :: String, average :: Double } deriving (Eq, Show, Read)
15:36:54 <hyraxfourtwo> data Blah = Blah { name :: String, average :: Int }
15:37:01 <Botty> Axioplase - the most likely way of remembering where you are is passing around portions of the list
15:37:04 <SamB> hyraxfourtwo: um
15:37:06 <fpierre08> so does that mean my question isn't possible ?
15:37:11 <SamB> Int is not in Fractional...
15:37:11 <fpierre08> hm
15:37:13 <fpierre08> k
15:37:17 <hyraxfourtwo> SamB oops!
15:37:26 <mauke> fpierre08: then you'd use name blah and average blah to extract the values
15:38:08 <fpierre08> so if i were to want to print... i would do "print name blah"?
15:38:17 <hyraxfourtwo> print (name blah)
15:38:20 <hyraxfourtwo> or print $ name blah
15:38:23 <chessguy> int-e, it's been done in 6 lines, very beautifully i might add, by dolio
15:38:38 <Axioplase> Botty: so.. I still don't get how to write inc() so that it returns naturals one per one each time...
15:38:48 <fpierre08> i c.. :) tnx
15:39:00 <mauke> fpierre08: print name blah would pass two arguments to print, 'name' and 'blah'
15:39:07 <mauke> which doesn't compile
15:39:27 <hyraxfourtwo> Axioplase, that requires keeping state
15:39:27 <Botty> Axioplase - that's because its impossible
15:39:31 <hyraxfourtwo> see for example
15:39:33 <int-e> chessguy: so if I have 12345 and delete the 5th digit, do I get 1234 or 2345?
15:39:38 <chessguy> 1234
15:39:43 <hyraxfourtwo> ?wiki MonadSupply
15:39:43 <lambdabot> http://www.haskell.org/haskellwiki/MonadSupply
15:39:48 <Botty> functions can't keep their own state.
15:39:52 <hyraxfourtwo> doh
15:40:14 <fpierre08> mauke : tnx
15:40:21 <hyraxfourtwo> http://www.haskell.org/haskellwiki/NewMonads/MonadSupply
15:40:24 <lambdabot> Title: New monads/MonadSupply - HaskellWiki, http://tinyurl.com/gqxun
15:41:01 <hyraxfourtwo> Axioplase, oops, I meant http://www.haskell.org/haskellwiki/New_monads/MonadUnique
15:41:04 <lambdabot> Title: New monads/MonadUnique - HaskellWiki, http://tinyurl.com/yj7dk4
15:41:11 <Axioplase> hyraxfourtwo: thanks
15:42:06 <Axioplase> I guess I'm not yet ok with the syntax enough to understand the meaning of the code ^^
15:42:44 <Botty> yeah, that's fairly advanced code
15:43:38 <Botty> a function that does what you want really doesn't make sense in the haskell world - even with the supply stuff you still pass in a variable to store the state
15:45:21 <lisppaste2> mauke pasted "inc" at http://paste.lisp.org/display/28249
15:46:17 <int-e> > let next as (b:bs) = (b, bs++as):next (b:as) bs; next _ _ = []; step (ds,n) p = do (d,ds') <- next [] ds; let { n' = n*10+d }; guard (n' `mod` p == 0); return (ds', n') in map snd $ foldM step ([1..9],0) [1..9]
15:46:19 <lambdabot>  [381654729]
15:46:37 <lisppaste2> mauke annotated #28249 with "wait, that's better" at http://paste.lisp.org/display/28249#1
15:46:52 <chessguy> that is the right solution
15:47:57 <chessguy> don's solution seems much more natural
15:48:08 <chessguy> err, dolio's
15:48:35 <chessguy> http://paste.lisp.org/display/28242
15:48:48 <int-e> my `next` should use list comprehension instead of do
15:50:58 <int-e> yes, that looks natural and somewhat inefficient (which doesn't really matter).
15:51:21 <chessguy> it evaluates instantaneously
15:51:48 <dolio> Well, it does build numbers from lists multiple times.
15:51:58 <dolio> So that's not great.
15:52:18 <astrolabe> When I do retainer profiling, almost all of the space is retained by SYSTEM.  What does this mean?
15:52:58 <int-e> it also removes digits from [1..9] multiple times. but it doesn't get much faster than instantenous :)
15:53:13 <SamB> astrolabe: good question!
15:53:21 <chessguy> well, i'd rather have a solution that's very readable and fairly efficient than one which is extremely efficient but hard to follow. this isn't an obfuscation exercise
15:53:31 <SamB> @google site:haskell.org/haskellwiki "retainer profiling" "SYSTEM"
15:53:32 <lambdabot> No Result Found.
15:53:35 <SamB> @google site:haskell.org/haskellwiki "retainer profiling"
15:53:36 <lambdabot> No Result Found.
15:53:43 <SamB> @google site:haskell.org/haskellwiki retainer
15:53:45 <int-e> chessguy: I wasn't obfuscating, I was reusing code :)
15:53:45 <lambdabot> No Result Found.
15:53:50 <SamB> @google site:haskell.org/haskellwiki profiling
15:53:52 <lambdabot> http://www.haskell.org/haskellwiki/Yhc/HeapProfiling
15:53:52 <lambdabot> Title: Yhc/Heap profiling - HaskellWiki
15:53:54 <dolio> It might start to matter if we were doing this with 1000-digit base-1000 numbers. :)
15:53:58 <SamB> @google site:haskell.org/haskellwiki ghc profiling
15:53:58 <chessguy> int-e, i didn't say you were
15:54:00 <lambdabot> http://haskell.org/haskellwiki/GHC/FAQ
15:54:00 <lambdabot> Title: GHC/FAQ - HaskellWiki
15:54:05 <SamB> oh well...
15:54:47 <astrolabe> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html#retainer-prof
15:54:50 <lambdabot> Title: 5.4. Profiling memory usage, http://tinyurl.com/y3x5pu
15:58:23 <chessguy> dolio, do you understand how monochrom's solution works?
15:58:39 <dolio> Hold on, let me look at it.
15:59:43 <dolio> Yeah, I think so.
16:00:21 <int-e> chessguy: pretty much the same as mine, only different ;)
16:00:24 <dolio> In 'f c ds n', c is the number you're testing for divisibility against...
16:00:31 <dolio> ds is a list of candidate digits.
16:00:46 <dolio> n is the number you're producing.
16:01:06 <dolio> So, you pick digit from you candidates "d <- ds"
16:01:22 <dolio> Compute the result of adding that digit to the end of the number.
16:01:35 <dolio> ensure that c divides the new number.
16:01:53 <dolio> And then continue on for (c+1).
16:02:08 <dolio> The 'f c [] n' case tests when you've used all your digits.
16:02:31 <chessguy> so it backtracks?
16:03:04 <chessguy> wait, no
16:03:12 <dolio> Sort of.
16:03:13 <int-e> the list monad backtracks
16:03:19 <int-e> sort of :)
16:03:41 <mauke> it fakes backtracking by computing all possible solutions at once
16:06:03 <int-e> but due to lazy evaluation at runtime it's actually backtracking (i.e. the control flow mimics backtracking)
16:13:30 <lisppaste2> fpierre08 pasted "simple" at http://paste.lisp.org/display/28250
16:13:57 <fpierre08> could any1 help me with this paste?
16:14:33 <astrolabe> what is the problem?
16:14:44 <int-e> fpierre08: its' if ... then ... else. also, a function application doesn't need ()
16:15:22 <fpierre08> so all i'm really missing is "then" ?
16:15:23 <dolio> randomRIO expects a range (low,high), as well, not ().
16:15:40 <mauke> putStrLn ("number is " ++ if randomNum `mod` 2 /= 0 then "odd" else "even")
16:15:47 <mauke> fpierre08: and your indentation is borken
16:16:01 <mauke> for weird reasons you need to indent 'else' more than 'if'
16:16:18 <fpierre08> i see
16:16:27 <astrolabe> why is that?
16:16:35 <astrolabe> oh yes
16:16:37 <astrolabe> nm
16:16:44 <mauke> because it'll insert a ';'
16:16:50 <int-e> the grammar wants it that way. I think there's a Haskell' item for that.
16:16:53 <fpierre08> so what if i wanted to leave the range as infinite ?
16:16:56 <fpierre08> not possible ?
16:17:32 <astrolabe> You can't draw a uniform random integer on a computer I don't think.
16:17:39 <int-e> fpierre08: no, that's not possible.
16:18:16 <mauke> randomNum <- randomIO :: IO Int should work, though
16:18:17 <kpreid> uniform, no. infinite range, sure
16:18:53 <astrolabe> kpreid: right, just give it finite support for instance :)
16:20:28 <fpierre08> % isn't recognized by haskell?
16:20:56 <fpierre08> is that why u used 'mod' mauke?
16:21:05 <astrolabe> @type (%)
16:21:05 <dolio> > 1%2
16:21:07 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
16:21:07 <lambdabot>  1%2
16:21:11 <mauke> % is recognized but it means "ratio"
16:21:19 <fpierre08> i see
16:21:22 <mauke> > 10 % 16
16:21:23 <lambdabot>  5%8
16:21:37 <int-e> it's defined in Data.Ratio
16:21:47 <dons> ?hoogle %
16:21:48 <lambdabot> Ratio.(%) :: Integral a => a -> a -> Ratio a
16:21:58 <dons> fpierre08: you can use hoogle to find things :)
16:22:19 <int-e> but it's not the modulo operation you know from C.
16:22:29 <SamB> heh
16:22:34 <SamB> try `mod` for that
16:22:41 <int-e> circle closed :)
16:22:47 <mauke> due to aids
16:22:49 <SamB> or, well, `rem`
16:24:19 <lisppaste2> pierre08 annotated #28250 with "new error" at http://paste.lisp.org/display/28250#1
16:24:51 <fpierre08> can any1 explain to me what the compiler means by that ?
16:25:07 <fpierre08> i have a feeling it's saying that it could cause an error if value is 0
16:25:33 <int-e> you want  randomNum `mod` 2   `` is a way to turn a normal function into an infix operator
16:25:53 <int-e> right now it sees randomNum applied to two arguments, mod and 2
16:26:12 <int-e> and that's what it says.
16:26:29 <fpierre08> i see
16:27:12 <kpreid> @let posRandom = let f x = (do (r, g') <- gets (randomR (0,3)); put g'; case r of 0 -> return x; 1 -> f (x * 2); _ -> f (x * 2 + 1)) in f 0
16:27:13 <lambdabot> Add a type signature
16:27:28 <kpreid> @let posRandom = let f x = (do (r, g') <- gets (randomR (0,3)); put g'; case r of 0 -> return x; 1 -> f (x * 2); _ -> f (x * 2 + 1)) in f 0 :: State StdGen Integer
16:27:30 <lambdabot> Defined.
16:27:41 <kpreid> > runState posRandom (mkStdGen 7)
16:27:42 <lambdabot>  Not in scope: `posRandom'
16:27:49 <kpreid> > evalState L.posRandom (mkStdGen 7)
16:27:51 <lambdabot>  2
16:27:53 <kpreid> > evalState L.posRandom (mkStdGen 8)
16:27:55 <lambdabot>  1349
16:27:57 <kpreid> > evalState L.posRandom (mkStdGen 9)
16:27:58 <lambdabot>  1
16:28:01 <kpreid> > evalState L.posRandom (mkStdGen 10)
16:28:03 <lambdabot>  6
16:28:50 <kpreid> > map (evalState L.posRandom . mkStdGen) [11..]
16:28:52 <lambdabot>  [20,1,3,3,0,125,0,11,1,7,54,1,27,2,7,247,0,1,0,7,0,444,0,2,63,3,2,1,43,5,1,1...
16:29:15 <dcoutts> Lemmih, you about ?
16:29:34 <dcoutts> Lemmih, I was wondering if we can clean off the *.hide repos from darcs.haskell.org
16:32:04 <Cale> fpierre08: randomNum `mod` 2 == 1
16:32:13 <Cale> fpierre08: or just use  odd randomNum
16:32:40 <Cale> > map odd [0..10]
16:32:41 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False]
16:35:05 <fpierre08> there's an odd function ?! lol
16:35:25 <int-e> there are many odd functions.
16:35:28 <mauke> that's odd
16:35:43 <lennart> there's even an even function
16:35:57 <fpierre08> lolol
16:36:14 <fpierre08> this language is full of suprises
16:36:14 <fpierre08> lol
16:36:21 <fpierre08> surprises*
16:36:36 <mauke> .oO( flip id )
16:36:48 <int-e> @type flip flip
16:36:49 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
16:37:32 <lennart> @djinn b -> (a -> b -> c) -> a -> c
16:37:32 <lambdabot> f a b c = b c a
16:38:01 <lennart> @type flip flip flip
16:38:02 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
16:38:26 <lennart> @djinn (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
16:38:26 <lambdabot> f a b = a b (\ c d e -> c e d)
16:38:50 <lennart> @type flip flip flip flip
16:38:51 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
16:38:59 <mauke> @. pl . djinn type flip flip flip flip
16:39:01 <lambdabot> f = flip flip flip
16:40:17 <lennart> cool, so flip flip flip flip = flip flip flip
16:41:22 <int-e> > nub [1,2,1,3,1,2,1]
16:41:23 <lambdabot>  [1,2,3]
16:41:39 <lennart> @type flip (flip flip flip)
16:41:40 <lambdabot> forall b c a b1 c1. b -> (b -> ((a -> b1 -> c1) -> b1 -> a -> c1) -> c) -> c
16:42:09 <lennart> @. pl . djinn type flip (flip flip flip)
16:42:10 <lambdabot> f = flip flip flip . flip id
16:42:34 <mauke> @. pl . djinn type flip flip flip flip flip
16:42:35 <lambdabot> f = flip flip flip
16:50:00 <lispy> ?hoogle castPtr
16:50:00 <lambdabot> Foreign.Ptr.castPtr :: Ptr a -> Ptr b
16:50:01 <lambdabot> Foreign.Ptr.castPtrToFunPtr :: Ptr a -> FunPtr b
16:50:01 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
16:50:16 <lispy> ?source Foreign.Ptr
16:50:16 <lambdabot> http://darcs.haskell.org/packages/base/Foreign/Ptr.hs
16:50:26 <lispy> okay, sweet, i didn't expect that to work :)
16:50:29 <lispy> lambdabot++
16:50:54 <mauke> does that work?
16:51:00 <lispy> yeah
16:51:07 <lispy> ?source GHC.Ptr
16:51:07 <lambdabot> GHC.Ptr not available
16:51:11 <mauke> I thought you had to do @karma+
16:51:14 <lispy> but that didn't...
16:51:21 <lispy> ?karma mauke
16:51:21 <lambdabot> mauke has a karma of 3
16:51:25 <lispy> mauke++
16:51:26 <lispy> ?karma mauke
16:51:27 <lambdabot> mauke has a karma of 4
16:51:39 <lispy> but i think ++ is kinda  picky
16:52:08 <lispy> well, i wanted to see how castPtr is implemented
16:52:21 <lispy> but i think it's hiding in GHC.Ptr
16:52:23 <lispy> wherevere that is
16:52:41 <mauke> isn't it a phantom type?
16:52:52 <SamB_XP> mauke: well.
16:52:56 <SamB_XP> yes.
16:53:01 <lispy> mauke: that's what i want to be sure about
16:53:06 <SamB_XP> but. not as phantom as a lot of things.
16:53:07 <lispy> if it's just a phantom type then i'm good to go
16:53:31 <SamB> data Ptr a = Ptr Addr# deriving (Eq, Ord)
16:53:32 <mauke> my sword is glowing blue
16:53:36 <SamB> see?
16:53:37 * lispy is trying to track down a bug in comlib
16:53:40 <SamB> phantom
16:53:53 <SamB> it just holds an Addr#
16:53:58 <SamB> @kind Addr#
16:54:00 <lambdabot> Not in scope: type constructor or class `Addr#'
16:54:02 <lispy> SamB: so castPtr (Ptr a) = (Ptr a) ?
16:54:07 <SamB> @kind GHC.Exts.Addr#
16:54:08 <lambdabot> #
16:54:26 <SamB> -- |The 'castPtr' function casts a pointer from one type to another.
16:54:26 <SamB> castPtr :: Ptr a -> Ptr b
16:54:26 <SamB> castPtr (Ptr addr) = Ptr addr
16:54:27 <SamB> yes
16:54:36 <lispy> thanks
16:54:53 <SamB> might as well be unsafeCoerce# ;-)
16:55:47 <lispy> which tells me that this basically does nothing to the data:
16:55:49 <lispy> unmarshallIUnknown :: Bool -> Ptr b -> IO (IUnknown a)
16:55:50 <lispy> unmarshallIUnknown finaliseMe x = return (Unknown (castPtr x))
16:56:12 <lispy> it really just wraps it in the IUnknown constructor and then puts it into the IO monad
16:56:49 <lispy> which is good...one less function to worry about :)
16:57:13 <SamB> its probably only that way to fit with the FFI tool?
16:57:27 <lispy> i'm not sure
16:57:32 <lispy> probably
16:57:44 <lispy> so, i have this minimal C++ example of what i want to do in terms of COM
16:57:47 * SamB wonders what the Bool is for
16:57:56 <lispy> but the equivalent haskell code does not work
16:58:06 * SamB would use the C++ ;-)
16:58:08 <lispy> SamB: it used to be used in a previous version of the library
16:58:13 <fpierre08> just taking a chance here.... is there a function for factorials? (since there's one for even/odd ! lol)
16:58:36 <lispy> SamB: the C++ took hours to write and it's just bare bones to proof of concept
16:58:50 <lispy> fpierre08: yes, \n -> product [1..n]
16:59:14 <chessguy> let fact 0 = 1; fact n = n * fact (n-1) in fact 32
16:59:24 <chessguy> > let fact 0 = 1; fact n = n * fact (n-1) in fact 32
16:59:26 <lambdabot>  263130836933693530167218012160000000
16:59:39 <lispy> > let fact n = product [1..n] in fact 32
16:59:40 <mauke> > (product . enumFromTo 1) 32
16:59:40 <lambdabot>  263130836933693530167218012160000000
16:59:41 <lambdabot>  263130836933693530167218012160000000
16:59:48 <lispy> :)
16:59:58 <lispy> i bet you could come up with more ways :)
17:00:03 <chessguy> TMTOWTDI
17:00:14 <lispy> ?google haskell factorial evolution
17:00:18 <sjanssen> chessguy: that version is O(n) in stack usage
17:00:19 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
17:00:19 <lambdabot> Title: The Evolution of a Haskell Programmer
17:00:54 <lispy> inpractice the version with 'product' preforms well
17:01:00 <lispy> > let fact n = product [1..n] in fact 100
17:01:02 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
17:01:15 <lispy> > let fact 0 = 1; fact n = n * fact (n-1) in fact 100
17:01:16 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
17:01:18 <fpierre08> tnx :)
17:01:20 <lispy> > let fact 0 = 1; fact n = n * fact (n-1) in fact 1000
17:01:22 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
17:01:25 <lispy> hmm..
17:01:27 <lispy> > let fact 0 = 1; fact n = n * fact (n-1) in fact 10000
17:01:30 <lambdabot>  2846259680917054518906413212119868890148051401702799230794179994274411340003...
17:01:32 <lispy> heh
17:01:40 <lispy> oay, i expeted to get "terminated"
17:01:55 <chessguy> that's a big number :)
17:01:55 <mauke> > let fact 0 = 1; fact n = n * fact (n-1) in fact (-1)
17:02:00 <lambdabot>  Exception: stack overflow
17:02:05 <atsampson> can you lazily evaluate just the most significant digits of the number? ;)
17:03:37 <lispy> atsampson: not using Int or Integer
17:03:48 <lispy> atsampson: because the value is strict...
17:03:58 * Igloo wonders if the report actually requires that
17:04:00 <lispy> atsampson: but you might be able to using a lazy representation
17:04:03 <dibblego> use a [Bool]
17:04:09 <lispy> Igloo: probably not
17:04:44 <dons> ?users
17:04:44 <lambdabot> Maximum users seen in #haskell: 256, currently: 219 (85.5%), active: 35 (16.0%)
17:04:59 <lispy> dons: how was google?
17:14:15 <dons> fun!
17:14:25 <dons> i'll write up a blog entry on it soonish
17:14:32 <lispy> cool
17:16:42 <Igloo> When will googÎ»e be launched, then?
17:17:00 <dibblego> how is a L replaceable by a Î» ?
17:17:05 <dibblego> or l
17:17:11 <dons> heh
17:17:20 <dibblego> a psychologist could answer that prolly
17:17:27 <Igloo> phoentically?
17:17:34 <dibblego> not for me
17:17:40 <dibblego> I read that as "google"
17:17:57 <dons> l -> lambda, seems obvious
17:18:07 <dibblego> well I don't have any such association
17:18:10 * Igloo thinks he's missing the point
17:18:22 <Igloo> ("he" being me)
17:18:52 <dibblego> I once read an article about how you can eliminate most vowels and people still read what you write
17:19:14 <dons> worked for the ancient egyptians
17:19:27 <Igloo> And modern Hebrew, AFAIK
17:19:43 * SamB thought that was *ancient* hebrew!
17:19:44 <atsampson> a6y, you can r4e m2t of the l5s e6y and s3l be c8y c12e
17:19:46 <dibblego> > filter isVowel "I once read an article about how you can eliminate most vowels and people still read what you write" where isVowel =
17:19:46 <lambdabot>  Parse error
17:19:57 <Igloo> Does modern Hebrew require vowels?
17:20:26 <Pseudonym> http://www.dotcsw.com/doc/softshadows.html
17:20:29 <lambdabot> Title: Soft Shadows with RenderDotC
17:20:29 <Pseudonym> And that's the interface.
17:20:31 <SamB> atsampson: no, you can't
17:20:35 <Pseudonym> Whoops.
17:20:48 <Pseudonym> Everyone look at the cool computer graphics!
17:21:08 <dibblego> @hoogle a -> [a] -> Bool
17:21:10 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
17:21:10 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
17:21:32 <Botty> > filter isVowel "I once read an article about how you can eliminate most vowels and people still read what you write" where isVowel l = l == 'a' || l == 'e' || l == 'i' || l == 'o' || l == 'u' || l == 'y'
17:21:32 <lambdabot>  Parse error
17:22:10 <dibblego> filter (\x -> a `elem` "aeiou") "I once read an article about how you can eliminate most vowels and people still read what you write"
17:22:14 <mauke> > let isVowel = (`elem` "aeiou") in filter isVowel "I once read an article about how you can eliminate most vowels and people still read what you write"
17:22:15 <lambdabot>  "oeeaaaieaouoouaeiiaeooeaeoeieaaouie"
17:22:19 <dibblego> filter (\x -> x `elem` "aeiou") "I once read an article about how you can eliminate most vowels and people still read what you write"
17:22:20 <Botty> lol
17:22:28 <dons> notElem ? :)
17:22:32 <Botty> > let isVowel = (`notelem` "aeiou") in filter isVowel "I once read an article about how you can eliminate most vowels and people still read what you write"
17:22:33 <mauke> > let isVowel = (`elem` "aeiou") in filter (not . isVowel) "I once read an article about how you can eliminate most vowels and people still read what you write"
17:22:33 <lambdabot>  Not in scope: `notelem'
17:22:34 <lambdabot>  "I nc rd n rtcl bt hw y cn lmnt mst vwls nd ppl stll rd wht y wrt"
17:22:35 <dibblego> ?type notelem
17:22:37 <lambdabot> Not in scope: `notelem'
17:22:40 <dibblego> ?type notElem
17:22:41 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:22:42 <lispy> heh
17:22:45 <lispy> programming in real-time
17:22:48 <dibblego> filter (\x -> x `notElem` "aeiou") "I once read an article about how you can eliminate most vowels and people still read what you write"
17:23:05 <Botty> > let isVowel = (`elem` "aeiou") == False in filter isVowel "I once read an article about how you can eliminate most vowels and people still read what you write"
17:23:06 <lambdabot>  Couldn't match `Char -> Bool' against `Bool'
17:23:06 <dibblego> > filter (\x -> x `notElem` "aeiou") "I once read an article about how you can eliminate most vowels and people still read what you write"
17:23:07 <lambdabot>  "I nc rd n rtcl bt hw y cn lmnt mst vwls nd ppl stll rd wht y wrt"
17:23:16 <dibblego> woohoo!
17:23:19 <Pseudonym> > let isVowel c = c `elem` "aeiouAEIOU" in filter (not . isVowel) "I am in awe at thesis"
17:23:20 <lambdabot>  " m n w t thss"
17:23:20 <dibblego> mauke won
17:23:31 <Pseudonym> > let isVowel c = c `elem` "aeiouAEIOU" in filter (not . isVowel) "I am in awe at the thesis"
17:23:32 <lambdabot>  " m n w t th thss"
17:23:37 <dons> Pseudonym: nice ;)
17:24:32 <Pseudonym> > let isVowel c = c `elem` "aeiouAEIOU" in filter (not . isVowel) "So is it bona fide?  You adjudge."
17:24:33 <lambdabot>  "S s t bn fd?  Y djdg."
17:24:37 <lispy> now write a one liner which takes each word, fixes the start and end letter and permutes (randomly) the order of the inner letters
17:24:55 <Pseudonym> > words "Hello world"
17:24:57 <lambdabot>  ["Hello","world"]
17:24:59 <Pseudonym> That helps.
17:25:00 <mauke> no IO allowed
17:25:15 <dibblego> anyway, so back to the point, most people can read that :)
17:25:41 <mauke> here's my latest hello world program (.hsc): #const printf("main = putStr \"Hello, world!\\n\"\n-- ")
17:25:50 <mauke> I like it :-)
17:26:43 <dons> heh
17:27:18 <SamB> how does it work?
17:27:24 <SamB> and WTH language is that?
17:27:42 <Pseudonym> Not ture!  You can asylane tihs hisehtopys by the slpmie eneidepxt of rnisreveg the ianretnl lrettes.
17:28:01 <mauke> it's haskell with small extensions
17:28:11 <mauke> see http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
17:28:14 <lambdabot> Title: 10.3. Writing Haskell interfaces to C code: hsc2hs, http://tinyurl.com/yb4cx4
17:31:47 <lispy> Pseudonym: when i saw it they did a more random permutation instead of just fixing one way to permute them
17:31:54 <lispy> Pseudonym: which gives a more readable result
17:32:19 <Pseudonym> The thing you need is for the consonants to be in roughly the right order.
17:32:34 <lispy> ah
17:33:14 <Pseudonym> In many cases, especially if you don't use a lot of long words (note that my sentence earlier did), the chances of that are pretty good.
17:33:30 <Pseudonym> Assuming the permutation is random, as you say.
17:39:04 * dons feels inexplicably happy :)
17:39:16 <dons> ?yow!
17:39:16 <lambdabot> -- I have seen the FUN --
17:39:19 <thou> that's nice!
17:39:22 <Pseudonym> I can say something depressing if that would help.
17:39:37 <dons> no no, this is a good feeling :) yay!
17:39:56 <dons> I think .... maybe ... it is because I've got my first real espresso in a week.
17:40:02 <Igloo> heh
17:40:54 <SamB> dons: you mean starbucks doesn't sell them?
17:41:09 * Igloo is unhappy, but at least it is explicable
17:41:29 <thou> inexplicably happy is ok; inexplicably unhappy is not
17:41:39 <newsham> > fix (\f x -> if x == 0 then 1 else (x * (f (x - 1)))) 5
17:41:41 <lambdabot>  120
17:41:51 <Pseudonym> Starbucks sells soy decaf recaf mocha mediocra flappuccinos, not real coffee.
17:41:54 <thou> well, at least it's frustrating
17:42:06 <dibblego> how do you find the type of a function defined to lambdabot using @let ?
17:42:12 <newsham> lots of people seem to think its real coffee
17:42:17 <dons> SamB: I tended to avoid the starbucks coffee, and the usual US-style percolated stuff is nasty
17:42:17 <sjanssen> @pl (\f x -> if x == 0 then 1 else (x * (f (x - 1))))
17:42:18 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
17:42:37 <dons> but I probably could have got a decent espresso at starbucks, yeah.
17:42:39 <int-e> lispy: another point is that it helps a lot if the 'skyline' of a word is unaffected. 'sliknye' tends to read better than 'sinykle'
17:42:43 <SamB> oh
17:42:48 <Pseudonym> In Australia, most coffee is Italian-style.
17:42:57 <Pseudonym> It's actually quite hard to get French-style.
17:43:00 <dibblego> especially at Park Road, Milton
17:43:02 * SamB doesn't drink coffee to know whether starbucks has espresso or not
17:43:12 <Pseudonym> Which, as I understand it, is what Seattle-style is based on.
17:43:20 <newsham> > fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
17:43:20 <lambdabot>  Not in scope: `if''
17:43:25 <dibblego> Park Road is full of ferraris and ducatis and people being Italian in coffee shops
17:43:28 <dons> yeah, its the Italian-style espresso that I missed.
17:43:39 <Pseudonym> I used to live a block from Lygon Street.
17:43:51 <Pseudonym> I'm shocked that I didn't get caffeine poisoning.
17:43:52 <dons> right. coffee central
17:44:13 <dibblego> @let x = "x"
17:44:15 <lambdabot> Defined.
17:44:18 <dibblego> @type L.x
17:44:19 <lambdabot> Couldn't find qualified module.
17:44:24 <dibblego> ?type L.x
17:44:26 <lambdabot> Couldn't find qualified module.
17:44:33 <SamB> hmm. who wants to write some wiki material?
17:44:33 * tmoertel is getting the caffeine-deprivation shakes just listening to Pseudonym and dons talk about coffee
17:44:35 <dibblego> can it be done?
17:44:35 <dons> the fish in sydney harbour have very high caffeine levels, i've read. due to all the cafes
17:44:39 <SamB> http://haskell.org/haskellwiki/UnsafePerformIO needs material!
17:44:43 <lambdabot> Title: Unsafe functions - HaskellWiki, http://tinyurl.com/vq7r5
17:44:43 <SamB> well, rather...
17:44:48 <SamB> @wiki unsafe functions
17:44:49 <lambdabot> http://www.haskell.org/haskellwiki/unsafe functions
17:44:55 <SamB> wait...
17:45:04 <SamB> that should use + I think
17:45:06 <SamB> not space
17:45:18 <Pseudonym> The original Grinders store has a wonderful sign in the window: "We don't mind if you don't speak Italian. We speak a good broken English."
17:45:21 <SamB> no...
17:45:25 <SamB> underscore...
17:46:04 <Pseudonym> Grinders is a huge business now.
17:46:12 <int-e> @pl if' a b c = fromMaybe c (guard a >> Just b)
17:46:12 <lambdabot> if' = (flip fromMaybe .) . (. Just) . (>>) . guard
17:47:17 <newsham> > fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
17:47:18 <lambdabot>  Not in scope: `if''
17:47:25 <newsham> whats the ns?
17:47:48 <int-e> > fix (ap (flip ((flip fromMaybe .) . (. Just) . (>>) . guard) 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
17:47:50 <lambdabot>  120
17:48:00 <newsham> thats much clearer
17:48:19 <int-e> @pl fix (ap (flip ((flip fromMaybe .) . (. Just) . (>>) . guard) 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
17:48:20 <int-e> [02:47:28] <lambdabot>  120
17:48:21 <lambdabot> fix (ap (flip (flip fromMaybe .) 1 . (. Just) . (>>) . guard . (0 ==)) . ap (*) . (. subtract 1)) 5
17:48:34 <dons> SamB: here you go. espresso, right off my coffee table, http://www.cse.unsw.edu.au/~dons/images/coffee.jpg  :)
17:48:36 <lambdabot> http://tinyurl.com/y3674b
17:48:38 * dons plays with new camera
17:49:04 * tmoertel fires back: http://community.moertel.com/ss/space/espresso
17:49:07 <lambdabot> http://tinyurl.com/vpao6
17:49:24 <SamB> dons: I don't think I am able to drink jpgs
17:49:34 <dons> mmm. nice tmoertel
17:49:39 <SamB> and my browser doesn't support application/x-matter-transport
17:49:48 <Pseudonym> Oh, lovely.
17:49:50 <SamB> or whatever the MIME type for that is
17:49:55 <Pseudonym> That looks... damn.  I need coffee.
17:50:13 <Pseudonym> ?coffee long macchiato
17:50:13 <lambdabot> Unknown command, try @list
17:50:15 <thou> dons: it's weird, the markings on the table and the shadows on the saucer made me think that the  picture was taken through a window, or some other odd reflections / multiple exposure thing was happening
17:50:20 <Pseudonym> Someone please write the plugin?
17:50:47 <dons> thou: no no. they're marks on the table from other cups. :}
17:51:11 <dons> too many hot coffee cups on the table without saucers
17:52:56 <astrolabe> I've got a function which I think I call once.  In a 'Time and Allocation Profiling Report', it says it has 10 'entries', but if I put a Debug.Trace.trace in it, it only prints once.  What's going on?
17:53:31 <SamB> uh, where did you put the Debug.Trace.trace?
17:54:33 <astrolabe> in my function definition I had 'func arg1 ... argn = trace "hello" (do ...) where ...
17:54:50 <thou> hi, i'm trying to run the example 'hello world' example from the cgi-compat NewCGI docs, using the latest darcs code for haskell-cgi. http://www.cs.chalmers.se/~bringert/darcs/cgi-compat/doc/api/Network-NewCGI.html
17:54:52 <SamB> that ought to work!
17:54:55 <lambdabot> http://tinyurl.com/y44tpy
17:55:07 <thou> i'm getting an overlapping instances for MonadCGI (CGIT IO) error
17:55:11 <astrolabe> haskell is getting all weird on me!
17:55:20 <thou> using GHC 6.4.2
17:56:21 <thou> Imported from Network.CGI.Monad: instance (Control.Monad.Trans.MonadTrans t, MonadCGI m, Monad (t m)) => MonadCGI (t m)
17:56:47 <thou> Imported from Network.CGI.Monad: instance (Monad m) => MonadCGI (CGIT m)
17:56:55 <thou> In the definition of `cgiMain': cgiMain = output "Hello World!"
17:57:30 <thou> ghc -o t --make -O t.hs -package xhtml -package cgi-compat
17:58:09 <thou> any idea where to look for that?
17:58:28 <lispy> C has some odd conventions that can be really handy
17:58:42 <lispy> for example, "foo" "bar" is treated the same as "foobar"
17:59:15 <thou> doesn't haskell do that to if you use -cpp option?
17:59:30 <lispy> never needed it in haskell
17:59:36 <lispy> but that could be handy
17:59:51 <lispy> > "blah" "blah"
17:59:51 <lambdabot>    The function `"blah"' is applied to one arguments,
17:59:52 <lambdabot>   but its type `[Ch...
18:00:05 <lispy> definitely doesn't do it by default :)
18:01:30 <thou> hmmm, i thought it was a function of the preprocessor, but i guess not
18:02:02 <thou> now that i think of it, it wouldn't work - lots of macros depend on that
18:02:06 <SamB> heh
18:02:12 <SamB> lispy: ++?
18:02:46 <thou> any ideas on overlapping instances for MonadCGI in the basic test proggy for NewCGI?
18:03:14 <shapr> -fallow-overlapping-instances
18:03:35 <thou> bjorn says there's not "much that can go wrong with Hello World" but I seem to be proving him wrong
18:03:46 <thou> lemme try that
18:04:08 <thou> shapr: that got past it
18:04:14 <lispy> SamB: well, in my case it was useful because i was modifying someone's C macro to include printfs
18:04:31 <lispy> SamB: as i was able to jus "blah debug" #somemacroparam
18:04:45 <lispy> SamB: if it were haskell then yeah, ++ would be nice :)
18:06:02 * shapr tries to dig out a clue...
18:18:15 <greenrd> I am trying to write a function with the following type: Data e => (a -> e -> (a, e)) -> (forall d. Data d => a -> d -> (a, d))
18:18:27 <greenrd> where Data is the class from Data.Generics
18:19:13 <dons> mmm. fun type
18:19:22 <greenrd> I need this function to use gmapAccumT, I think
18:19:24 <SamB> greenrd: could you explain it a little?
18:19:52 <greenrd> well, I'm trying to use gmapAccumT
18:19:59 <SamB> also.
18:20:06 <Pseudonym> Oh, dons, I have a new freetheorems.
18:20:11 <SamB> why can't it just be (const (,))?
18:20:13 <greenrd> I have a function which operates on a specific type (call it e)
18:20:21 <Pseudonym> It gets pulled on Saturday, right?
18:20:42 <SamB> @type const (,)
18:20:43 <lambdabot> forall a b b1. b1 -> a -> b -> (a, b)
18:21:05 <greenrd> I need to convert it into a generic function which works on all types d which are instances of Data
18:21:28 <greenrd> so that I can supply that generic function to gmapAccumT
18:21:34 * SamB thinks (,) is such a function
18:21:40 <greenrd> unfortunately I can't find any examples of the use of gmapAccumT
18:21:56 <SamB> at least, it has the type you have on the right of the arrow...
18:22:02 <fpierre08> so does haskell have pointers?
18:22:04 <greenrd> But my function does not accept Ints.
18:22:20 <SamB> @type Data.Generic.gmapAccumT
18:22:21 <lambdabot> Couldn't find qualified module.
18:22:22 <Pseudonym> fpierre08: No, but it does have references as part of the FFI.
18:22:22 <dons> ?hoogle Ptr
18:22:23 <greenrd> I need a function which accepts *any* type.
18:22:24 <lambdabot> Foreign.Ptr :: module
18:22:24 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
18:22:24 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
18:22:33 <greenrd> (that is an instance of Data)
18:22:36 <SamB> @type gmapAccum
18:22:37 <lambdabot> Not in scope: `gmapAccum'
18:22:39 <Pseudonym> That shouldn't really be called a pointer.
18:22:40 <SamB> @type gmap
18:22:42 <lambdabot> Not in scope: `gmap'
18:22:44 <SamB> @hoogle gmap
18:22:45 <lambdabot> Data.Graph.Inductive.Graph.gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
18:22:46 <lambdabot> Data.Generics.Basics.gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
18:22:46 <lambdabot> Data.Generics.Basics.gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
18:22:53 * SamB discovers he forgot to switch to @hoogle :-)
18:23:04 <greenrd> @hoogle gmapAccumT
18:23:04 <lambdabot> Data.Generics.Twins.gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
18:23:34 <fpierre08> so then pass by ref is still possible right?
18:25:17 <dons> fpierre08: you want to pass references to mutable objects?
18:26:31 <dons> (you can pass references, and mutate objects, yes, but that's pretty ugly and nasty, except for particularly algorithms and applications that require mutable data. in general, you never need a mutable Ptr type in Haskell programs)
18:27:27 <SamB> but, if you want to implement a BF with the traditional danger factor ;-)
18:28:35 * lispy is completely baffled by this bug
18:28:58 <dons> yeah, haskell provides all the danger of legacy programming languages, if you ask for it especially
18:29:06 <dons> hey coffeemug
18:29:11 <coffeemug> hey dons
18:29:14 <coffeemug> how's it going
18:29:21 <dons> coffeemug: i've enjoyed some of your recent blog posts, keep up the good work
18:29:22 <fpierre08> dons : for now not really trying to pass anything.. just trying to learn haskell by comparing it to what i know in C
18:29:38 <coffeemug> dons: next two are on Haskell :)
18:29:40 <dons> coffeemug: good. just spent a week in SF, which was nice.
18:29:43 <dons> coffeemug: oh goody!
18:30:04 <int-e> fpierre08: Haskell doesn't usually copy anything, because the pretty much everything is immutable. It's very different from C in that regard.
18:30:06 <coffeemug> dons: one is going to be about building a lisp interpreter with haskell
18:30:11 <coffeemug> I'm almost done with that one
18:30:12 <dons> fpierre08: well, the jump from C is big -- that's 30 years of programming language research to cover :)
18:30:21 <dons> coffeemug: ah great. that sounds really nice
18:30:24 <coffeemug> another one will be on building a web server and a web app
18:30:32 <coffeemug> which I'm in the process of doing :)
18:30:37 <coffeemug> SF is a really nice place
18:30:53 <fpierre08> dons : lol! yeah i noticed...
18:30:53 <dons> excellent. a web server sounds very nice. let me know if you want a code review or feedback
18:31:05 <dons> saves me writing my own web server tutorial ... :)
18:31:09 <coffeemug> much prettier than the southern part of CA
18:31:36 <coffeemug> actually if you could take a look at some of the code, that'd be great
18:31:39 <coffeemug> you'd probably cringe
18:31:48 <coffeemug> but we all have to start somewhere :)
18:31:54 <dons> yeah, SF is a lot more like Sydney or Melbourne, than other cities in the US i've been too
18:32:04 <lispy> dons: neat
18:32:04 <greenrd> coffeemug: You're the guy using STM?
18:32:05 <dons> sure. i'm happy to look at the code
18:32:10 <int-e> fpierre08: the downside of stuff being immutable is that modifying data means creating a new copy of your data (or at least of the part that you changed - other parts may be shared.) This fact makes references occasionally useful. But it's more of a last resort.
18:32:38 <coffeemug> greenrd: I'm not sure what you're referring to
18:32:48 <coffeemug> greenrd: I've looked at STM but am not using it
18:32:56 <greenrd> oh, then you're not, sorry
18:33:00 <coffeemug> dons: this is the code for lisp interpreter http://sources.defmacro.org/blaise/
18:33:02 <lambdabot> Title: Index of /blaise
18:33:16 <fpierre08> int-e : i c ! So in some sense that means that Haskell could use a lot more memory then a c program would ?
18:33:28 <coffeemug> dons: and this is the code for the web server I'm working on now: http://sources.defmacro.org/weblocks
18:33:30 <lambdabot> Title: Index of /weblocks
18:33:40 <dons> fpierre08: not necessarily. sometimes it uses less, since it can share results, rather than copying them
18:33:51 <fpierre08> k
18:33:51 <lispy> fpierre08: right, but usually it throws away things before you ever notice...and it's garbage collector runs much more efficiently than malloc/free
18:33:56 <dons> for example, since we know strings are immutable, you can take substrings without copying
18:33:56 <coffeemug> you can always email me your comments when you get some time to look at the code
18:34:00 <dons> yep
18:34:19 <dons> coffeemug: ah darcs good. i'll try to have a look today then
18:34:25 <dons> coffeemug: what kind of deadline did you have?
18:34:26 <SamB> it helps to have the strings represented by address, offset, and length...
18:34:41 <dons> yeah :)
18:34:41 <SamB> NUL termination doesn't make for good sharing potential ;-)
18:35:04 <dons> yeah, \0 termination is a design flaw
18:35:11 <SamB> well
18:35:11 <coffeemug> dons: no deadlines
18:35:12 <Botty> yeah, pretty dumb
18:35:12 <dons> you have to recompute the length again and again
18:35:24 <coffeemug> I'm actually running into two separate problems now
18:35:29 <SamB> you have to admit it was nicer than fixed-size strings!
18:35:32 <coffeemug> one is that I can't build hs-plugins on windows
18:35:47 <coffeemug> because of cygwin's make system, probably
18:35:53 <dons> hmm. try mingw. should work.
18:35:57 <dons> with ghc 6.4.x
18:36:06 <coffeemug> 6.6 won't work?
18:36:24 <SamB> maybe he meant you need something newer than 6.4 itself?
18:36:27 <dons> hs-plugins needs to be ported to 6.6, there's some changes to the package format that breaks the dependency chaser in hs-plugins
18:36:44 <SamB> dons: oh really!
18:36:46 <coffeemug> ah
18:36:49 <dons> you need a ghc >= 6.4 and <= 6.4.2 :)
18:36:55 <coffeemug> that sucks :)
18:37:02 <SamB> ... what if I had 6.4.3?
18:37:05 <dons> it'll get ported soon, its not a huge job, a day or so
18:37:16 <dons> a 6.4.3 would be ok. hence 6.4.x :)
18:37:53 <coffeemug> another issue I'm having is a problem with HTTP
18:38:01 <dons> oh?
18:38:06 <coffeemug> for some reason browsers other than Opera ignore Connection: close
18:38:14 <dons> oh, tabs in .hs src. bad form :)
18:38:30 <dons> hmm, strange. perhaps check with bringert?
18:38:33 <dons> ?seen bringert
18:38:34 <lambdabot> I saw bringert leaving #ghc, #haskell.se and #haskell 3h 3m 2s ago, and .
18:38:43 <coffeemug> I think it may have to do with lazyness
18:38:46 <coffeemug> of hGetContents
18:38:49 <coffeemug> or something like that
18:38:52 <dons> could be, yes.
18:39:00 <coffeemug> but not sure, could be not Haskell related at all
18:39:04 <shapr> musasabi mentioned dcoutts' ByteString serialization, is that Serialize.hs in lambdabot?
18:39:06 <coffeemug> we'll see :)
18:39:07 <dons> strict, or else non blocking io, is better on network sockets.
18:39:18 <shapr> er, Serial.hs that is
18:39:23 <dons> shapr: no I do my own lambdabot-style serialisation (generates darcs-friendly binary files)
18:39:39 <chessguy> > let pairup l [x,y] = l:[(x,y)]; pairup l (x:y:zs) = l:[(x,y)]:(pairup l zs) in pairup [a,b,c,d]
18:39:40 <lambdabot>  Not in scope: `d'
18:39:47 <chessguy> > let pairup l [x,y] = l:[(x,y)]; pairup l (x:y:zs) = l:[(x,y)]:(pairup l zs) in pairup [1,2,3,4]
18:39:48 <lambdabot>  Couldn't match `[(a, a)]' against `(a, a)'
18:39:50 <dons> coffeemug: so if I just send darcs patches with comments, you can pick and choose as you wish?
18:39:50 <coffeemug> you mean using unsafe primitives?
18:39:52 <shapr> Google doesn't turn up other options for ByteString serialization, do you know of any?
18:40:12 <coffeemug> dons: sure, if that's easier for you
18:40:20 <dons> coffeemug: no no, using one of the strict string types, or else, setting the socket to non blocking. but best ask bringert and have a specific case.
18:48:48 <coffeemug> dons: darcs send should work now
18:49:33 <dons> cool
18:51:17 <dons> ?bot
18:51:28 <dons> ok, I can see the bot listening to me...
18:51:41 <greenrd> Wow, this really doesn't make sense
18:51:44 <dons> should really work out why it doesn't handle netsplits so well, oh well.
18:51:46 <chessguy> @paste
18:51:57 <chessguy> oh, whoops
18:52:06 <SamB> um...
18:52:08 <SamB>  infixr 5 :^:
18:52:08 <SamB>  data Tree a =  Leaf a  |  Tree a :^: Tree a
18:52:15 <SamB> this isn't haskell98 is it?
18:52:25 <int-e> it isn't, right
18:52:34 <SamB> so...
18:52:39 <int-e> infix type constructors are an extension.
18:52:54 <SamB> why does the documentation for "class Read" say:
18:53:02 <SamB> For example, given the declarations
18:53:02 <SamB>  infixr 5 :^:
18:53:02 <SamB>  data Tree a =  Leaf a  |  Tree a :^: Tree a
18:53:02 <SamB> the derived instance of Read in Haskell 98 is equivalent to
18:53:12 <SamB>  {- blah blah Haskell code -}
18:54:07 <SamB> ... if that code is not Haskell 98?
18:55:16 <dons> fixing the bot ....
18:56:03 <Pseudonym> ?version
18:56:03 <dons> ?uptime
18:56:06 <chessguy> @paste
18:56:14 <Pseudonym> ?somethingreallexpensive
18:56:24 * chessguy slaps Pseudonym a few times
18:56:28 <Pseudonym> Fill up the queue!
18:56:29 <dons> heh. just have to wait on silly old freenode..
18:56:29 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
18:56:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:56:35 <lambdabot> uptime: 43s, longest uptime: 6d 15h 1m 36s
18:56:39 <lambdabot> http://paste.lisp.org/new/haskell
18:56:49 <lambdabot> Unknown command, try @list
18:56:59 <coffeemug> hmm
18:57:21 <coffeemug> it's interesting how happs code is structured just like mine in many ways, but is much much more haskellish :)
18:57:29 <dons> heh
18:57:53 <dons> coffeemug: maybe take some notes on how you wrote things, and how you find haskell experts write things. would be a useful tut on its own
18:58:16 <SamB> @docs Prelude#t:Read
18:58:17 <lambdabot> Prelude#t:Read not available
18:58:17 <dons> e.g. don't use tabs, and then anything else you notice (and i'll send in some wibble patches along these lines)
18:58:21 <SamB> @docs Prelude
18:58:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
18:58:52 <lisppaste2> chessguy pasted "pairUp" at http://paste.lisp.org/display/28264
18:59:05 <SamB> int-e: look at http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Read and see if I'm not right to think it should say something else?
18:59:08 <lambdabot> http://tinyurl.com/ycm9b9
18:59:55 <coffeemug> dons: the thing with tabs is that I don't even use them, I just use emacs haskell mode
19:00:09 <coffeemug> and whatever indentation it puts for me
19:00:47 <coffeemug> I'm pretty sure it's all spaces, so the stuff you're seeing may come from older files I wrote in Visual Haskell
19:00:54 <dons> ah bad emacs mode. the emacs mode guys should stop this tab nonsense
19:01:06 <dons> anyone use emacs who knows if the newest emacs mode still inserts tabs?
19:01:15 <dons> coffeemug: ah right.
19:01:21 <SamB> is there a "newest" emacs mode?
19:01:29 <coffeemug> emacs mode has been stuck for a while
19:01:34 <dons> well, there was one released a month ago or so, wasn't there?
19:01:40 * SamB thought it was forked several ways!
19:01:45 <dons> yeah maybe
19:01:47 <coffeemug> I think documentation there is screwed
19:01:55 <coffeemug> dons: what do you use?
19:02:13 <dons> vim, with extended syntax highlighting, and some external haskell utilities
19:02:23 <dons> (i.e. like hasktags and lambdabot bindings)
19:02:43 <coffeemug> right
19:02:47 <coffeemug> of course it had to be VIM :)
19:02:50 <dons> (and 'typeOf', a script for inferring type decls)
19:05:31 <coffeemug> hmm, what does turning off bufferring on a socket do for reading?
19:05:39 <hyraxfourtwo> the emacs mode inserts tabs?
19:05:51 <coffeemug> hyraxfourtwo: no, spaces
19:06:52 <hyraxfourtwo> coffeemug, yea I thougth so
19:07:01 <hyraxfourtwo> didn't read the whole exchange so got worried a sec
19:07:22 <coffeemug> tabs was my old code :)
19:07:25 <chessguy> grrr, how do you tell what cases are needed to be exhaustive
19:08:17 <lisppaste2> chessguy annotated #28264 with "pairUp revisited" at http://paste.lisp.org/display/28264#1
19:08:36 <dons> chessguy: well, ghc -Wall should tell you anyway
19:08:53 <dons> doesn't it print the missing alternatives? It does, with -Wall, I think
19:09:23 <chessguy> mmm, can i load the -Wall option from within the interpreter
19:09:26 <hyraxfourtwo> you're missing the case(s) of fewer than two elements in the second argument
19:09:54 <hyraxfourtwo> and you have a type error
19:10:05 <dons> chessguy: yeah, :set -Wall
19:10:45 <dons> $ ghci
19:10:46 <dons> GOA> :set -Wall
19:10:46 <dons> GOA> let f [] = []
19:10:46 <dons> <interactive>:1:4:
19:10:46 <dons>     Warning: Pattern match(es) are non-exhaustive
19:10:48 <dons>              In the definition of `f': Patterns not matched: _ : _
19:10:50 <dons> for example,
19:11:31 <chessguy> with -Wall on, i get     Warning: Defaulting the following constraint(s) to type `Integer'
19:11:31 <chessguy>              `Num a' arising from the literal `1' at <interactive>:1:11
19:11:31 <chessguy>              In the list element: 1
19:11:31 <chessguy>              In the second argument of `pairUp', namely `[1, 2, 3, 4]'
19:11:31 <chessguy>              In the definition of `it': it = pairUp [] [1, 2, 3, 4]
19:11:31 <chessguy> *** Exception: C:/Program Files/WinHugs/Primes.hs:(5,0)-(6,25): Non-exhaustive
19:11:31 <chessguy> atterns in function pairUp
19:12:11 <coffeemug> hmm
19:12:15 <hyraxfourtwo> ahhh the closest thing in java to a typeclass is an abstract class
19:12:26 <hyraxfourtwo> that should help if i need to explain it to someone
19:12:53 <hyraxfourtwo> or an interface, I suppose
19:13:39 <chessguy> adding the case pairUp l [x] didn't help
19:13:54 <chessguy> do i need to give a case for if l is []?
19:13:55 <hyraxfourtwo> chessguy, l is of type [(a,a)] it looks to me
19:14:17 <monochrom> Make it an interface.
19:14:34 <hyraxfourtwo> or even [[(a,a)]] possibly
19:14:41 <chessguy> hyraxfourtwo, where do you get that from?
19:14:51 <hyraxfourtwo> your use of (:)
19:14:57 <hyraxfourtwo> ?type (:)
19:14:58 <lambdabot> forall a. a -> [a] -> [a]
19:15:21 <hyraxfourtwo> oh ignore me
19:15:30 <chessguy> don't mind if i do :)
19:15:35 <SamB> hyrax42: I think we know the type of (:), thank you ;-)
19:16:05 <hyraxfourtwo> ok but chessguy you state that l is of type [a]
19:16:07 <hyraxfourtwo> in the signature
19:16:20 <hyraxfourtwo> then you use it as
19:16:34 <chessguy> oh yes
19:16:41 <hyraxfourtwo> l:
19:16:48 <hyraxfourtwo> goddamn it why won't copy/paste work
19:16:50 <chessguy> the first [a] should be [[a]]
19:17:09 <hyraxfourtwo> oh there's an annotation
19:17:17 <hyraxfourtwo> ok we might not be talking bout the same thing
19:17:32 <SamB_XP> that is rarely good!
19:17:56 <chessguy> grr, i need to start this from scratch
19:19:24 <dons> SamB_XP: there you go. mail filtered
19:19:37 <monochrom> All the worlds software problems are solved by starting from scratch.
19:19:38 <SamB_XP> I wanted it unfiltered!
19:19:41 <hyraxfourtwo> chessguy, why are you having two arguments
19:19:44 <monochrom> s/worlds/world's/
19:19:47 <hyraxfourtwo> I'm not sure I understand the goal
19:19:54 <dons> SamB_XP: fitered like List.filter ;)
19:20:03 <SamB> oh ;-)
19:20:06 <SamB> thats good then
19:20:19 <chessguy> hyraxfourtwo, i want to convert something like [1,2,3,4] to [[1,2],[2,3],[3,4]]
19:20:26 <hyraxfourtwo> ok that's what I thought
19:20:31 <hyraxfourtwo> then you only want one argument
19:20:32 * SamB remembers having once forgot which way round the predicate went for filter ;-)
19:20:43 <chessguy> yes, but i can't figure out how to do it without passing in an empty list
19:21:03 <monochrom> zipWith (\x y -> [x,y]) l (tail l)
19:21:16 <dons> SamB_XP: i can't see how to change the file size limit though
19:21:24 <lisppaste2> hyrax42 annotated #28264 with "fixed?" at http://paste.lisp.org/display/28264#2
19:21:28 <dons> but you're on a white list now, so if you send stuff under the limit, it should get through at least :)
19:21:36 <SamB> dons: I noticed!
19:22:03 <SamB> thats why I'm talking about the limit at all, presumably!
19:22:05 <monochrom> > let l = [1,2,3,4] in zipWith (\x y -> [x,y]) l (tail l)
19:22:07 <lambdabot>  [[1,2],[2,3],[3,4]]
19:22:10 <dons> presumably.
19:22:25 <int-e> hyraxfourtwo: pairUp [x] = [x] -- or [] -- has to be [[x]]
19:22:35 <hyraxfourtwo> ah yea
19:22:36 * SamB looks for his conjure list admin url
19:22:36 <hyraxfourtwo> woops
19:22:56 <hyraxfourtwo> and monochrom's answer beats it by a long way
19:23:12 <hyraxfourtwo> ?pl \x y -> [x,y]
19:23:12 <lambdabot> (. return) . (:)
19:23:20 <int-e> > init $ map (take 2) (tails [1,2,3,4])
19:23:21 <lambdabot>  [[1,2],[2,3],[3,4],[4]]
19:23:39 <int-e> > init . init . map (take 2) . tails $ [1,2,3,4]
19:23:41 <lambdabot>  [[1,2],[2,3],[3,4]]
19:23:41 <hyraxfourtwo> that gets overlapping subsequences
19:24:29 <int-e> > unfoldr (\xs -> (guard . not . null) xs >> (Just . splitAt 2) xs) [1,2,3,4]
19:24:30 <lambdabot>  [[1,2],[3,4]]
19:24:48 <SamB> dons: go to the "general options" section
19:24:51 <dons> mmm. /me is glad to have a zero-binary-blob OS, http://news.com.com/Exploit+code+released+for+Nvidia+flaw/2100-1002_3-6126846.html
19:24:54 <lambdabot> Title: Exploit code released for Nvidia flaw | CNET News.com, http://tinyurl.com/y8lk86
19:24:57 <dons> SamB: ok. looking
19:25:00 <SamB> search for "maximum length"
19:25:26 <dons> ah here we go
19:26:21 <hyraxfourtwo> int-e, did you test that before trying it here?
19:26:32 <SamB> having administered the conjure list during its short useful lifetime (and nominally a good deal beyond that), I have learned a thing or two about mailman ;-)
19:26:48 <dons> ok, SamB increased to 250k on cvs-ghc
19:26:51 <int-e> hyraxfourtwo: not today. I remembered it though.
19:26:51 <hyraxfourtwo> how is confure doing
19:27:06 <chessguy> ok, working now. thanks all
19:27:08 <hyraxfourtwo> int-e, hmm ok
19:27:26 <SamB> hyraxfourtwo: I think Lemmih said something about having broken it?
19:27:28 <dons> how common are binary blob drivers in linux these days?
19:27:32 <SamB> or was it someone else?
19:27:35 * SamB forgets...
19:27:39 <SamB> its been so long!
19:27:46 <hyraxfourtwo> ok
19:27:53 <hyraxfourtwo> so non-funcitonal?
19:28:04 <int-e> hyraxfourtwo: the question of splitting lists into sublists of equal length comes up quite often.
19:28:07 <SamB> so I was given to believe
19:28:14 <SamB> it never was terribly functional to start with, though
19:28:33 <hyraxfourtwo> int-e, I guess so.  Just that solution is almost obfuscated!
19:28:52 <hyraxfourtwo> although I guess I have never used the unfolds
19:28:58 <int-e> hyraxfourtwo: only almost? now I'm disappointed :)
19:29:14 <hyraxfourtwo> int-e, ok, it's fully incomprehensible to me
19:29:28 * SamB brags about his results so far: http://news.gmane.org/find-root.php?group=gmane.comp.lang.haskell.cvs.ghc&article=17327
19:29:28 <hyraxfourtwo> since I don't knowwhat splitAt does, nor just how unfoldr goes about doing its business
19:29:33 <lambdabot> Title: Gmane Loom, http://tinyurl.com/yhrb44
19:29:45 <SamB> that is about my inliner patch
19:29:46 <int-e> > splitAt 2 [1,2,3,4,5,6]
19:29:47 <lambdabot>  ([1,2],[3,4,5,6])
19:29:51 <SamB> it has benchmarking results!
19:30:06 <int-e> hyraxfourtwo: it's a combined  take  and  drop.
19:30:07 <coffeemug> hmm
19:30:12 <coffeemug> I've achieved nothing today
19:30:14 <coffeemug> excellent :)
19:30:35 <hyraxfourtwo> ?type splitAt
19:30:36 <lambdabot> forall a. Int -> [a] -> ([a], [a])
19:30:47 <magnus-> Does it happen to you guys that you find yourself inside the wrong monad?
19:31:10 <SamB> magnus-: what do you mean?
19:31:12 <dons> magnus-: hmm, sometimes, if you didn't plan for the design, and chose a too restricgive monad?
19:31:24 <dons> but usually that's just a matter of then changing the monad type constructor
19:31:30 <dons> i.e. ReaderT -> StateT, for example
19:31:33 <chessguy> ok, i've definitely gotta turn -Wall off now
19:31:43 <SamB> heh
19:32:43 <magnus-> samB: For example you're in a monad for renaming and moving files, and you one day realize you want to print a warning message if a file you create already exists... but you can't because the monad doesn't support it
19:33:31 <SamB> no
19:33:36 <SamB> I don't have any monads for that ;-)
19:33:38 <int-e> hyraxfourtwo: with splitAt, you can write this:   pairUp [] = []; pairUp xs = let (piece, rest) = splitAt 2 xs in piece : pairUp rest
19:33:47 * SamB would have probably been in IO to start with
19:34:12 <SamB> or at least in an instance of MonadIO
19:34:17 <hyraxfourtwo> > splitAt 2 [1]
19:34:18 <lambdabot>  ([1],[])
19:34:29 <hyraxfourtwo> > splitAt 5 []
19:34:30 <lambdabot>  Add a type signature
19:34:34 <SamB> oh, but, you might be able to print warning messages with WriterT?
19:34:37 <hyraxfourtwo> > splitAt 5 [] :: [()]
19:34:37 <lambdabot>  Couldn't match `[()]' against `([a], [a])'
19:34:46 <int-e> it's ([],[])
19:34:49 <magnus-> Afaik the code used to be IO but then another monad was used instead to provide security checks for all file operations
19:34:53 <hyraxfourtwo> > splitAt 5 [] :: ([()],[()])
19:34:55 <lambdabot>  ([],[])
19:35:10 <magnus-> MonadIO? WriterT?
19:35:17 * magnus- looks up
19:35:23 <dons> no, i'd be in IO to start with
19:35:23 <dons> magnus-: you created a specific monad for renaming and moving files?
19:35:23 <dons> how does that work? did you newtype and lift over IO?
19:35:26 <monochrom> VerySafeMonadIO   :)
19:35:37 <hyraxfourtwo> haha
19:35:40 <magnus-> dons: Actually the darcs project did, and I'm trying to fix a bug
19:35:46 <hyraxfourtwo> ?index MonadIO
19:35:46 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:35:54 <hyraxfourtwo> ?hoogle MonadIO
19:35:54 <lambdabot> Control.Monad.Trans.MonadIO :: class Monad m => MonadIO m
19:36:09 <int-e> safelyDiscardIO :: IO a -> (); safelyDiscardIO _ = ()
19:36:36 <magnus-> int-e: lol :)
19:37:17 <monochrom> Heh heh heh
19:37:38 <monochrom> @remember int-e safelyDiscardIO :: IO a -> (); safelyDiscardIO _ = ()
19:37:55 <magnus-> Maybe I'll just file a bug report instead of trying to fix the bug myself...
19:38:18 <monochrom> file a bug report. then try to fix the bug.
19:38:23 <SamB> magnus-: that is a good idea in general
19:38:31 <SamB> people will give you all sorts of helpful advice
19:38:56 <SamB> you could assign it to yourself, even, if you want!
19:40:24 * magnus- filing report
19:40:59 <monochrom> documenting things makes open-source work!
19:44:09 <OrangeKid> i lost my copy :(
19:45:58 <coffeemug> dons: any chance hs-plugins will switch its build system to cabal?
19:46:08 <OrangeKid> i still dont understand how gci is supposed to do anything other than mathematics :/
19:46:16 <OrangeKid> what is it called i forget the name
19:47:00 <dons> coffeemug: it has done so. please us hs-plugins 1.0r1
19:48:08 <SamB> OrangeKid: lost your copy of what?
19:48:16 <SamB> ghc?
19:48:35 <dons> SamB: um.. see the user name...
19:48:38 <coffeemug> dons: ah, thank you
19:48:45 <SamB> oh wow!
19:48:53 <coffeemug> I didn't want to use the rc, but I will for this :)
19:48:55 <SamB> hello crazy person!
19:49:19 <dons> coffeemug: yeah, i should just rename the rc to 1.0
19:49:27 <chessguy> @keal
19:49:27 <lambdabot> just seeing how offtopic i could get everyone
19:49:45 <dons> we're in the presence of a legend, it seems.
19:49:57 <SamB> he was in #zsnes talking all kind of crazy stuff about MKendora earlier
19:50:22 <coffeemug> on unsw.edu site I only see 1.0rc0
19:50:32 <coffeemug> is that the same as r1?
19:50:37 <dons> ah, sorry, yes, 1.0rc0
19:50:47 <dons> I forgot to count my zeroes before they hatched
19:51:29 <SamB> I'm afraid I might have mentioned Haskell while he was still in the channel...
19:51:43 <dons> ah heh.
19:52:00 * dons doesn't mind. /op is always close at hand
19:52:12 <SamB> someone asked whether multi-core systems were good
19:52:22 <SamB> I said it depended whether you liked functional programming
19:52:29 <dons> heh good quote
19:53:08 <coffeemug> dons: I get unexpected end of file when I try to get the tarball
19:53:16 <SamB> the other person misinterpreted that as meaning that a dual core system doesn't work for programming, so I said I meant that it would be good if you liked Haskell...
19:53:39 <dons> coffeemug: hmm. try again?
19:53:48 <coffeemug> I did
19:54:04 <dons> SamB: oh wow. imperative people are thinking multicore just will break programming, forever?
19:54:05 <coffeemug> I thought it has to do with cygwin but I could easily unzip previous versions
19:54:10 <araujo> hellu
19:54:10 <dons> coffeemug: oh, looking. let me see..
19:54:16 <dons> hola araujo
19:54:21 <araujo> hola dons :-)
19:55:02 <dons> araujo: oh, I meant to ask, looks like the translation project is going well. are all the translated pages being linked to from Haskell.es ?
19:55:11 <lisppaste2> SamB pasted "snippet from #zsnes" at http://paste.lisp.org/display/28265
19:55:44 <SamB> dons: I have no idea!
19:55:49 <dons> Also, it might even be worthwhile putting a "Language: en es" link at the bottom of the english versions of translated pages, so the .es versions are easier to find.
19:55:55 <coffeemug> it's a tar.tar file :)
19:55:59 <dons> hmm?
19:56:02 <SamB> you could ask Link`sAdventure if you want, dons
19:56:11 <dons> wget http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-1.0-rc0.tar.gz
19:56:13 <lambdabot> http://tinyurl.com/y5fwdu
19:56:22 <coffeemug> it's not zipped
19:56:28 <coffeemug> just untarring it works
19:56:29 <coffeemug> sorry :)
19:56:38 <dons> oh, windows doing something weird ?
19:56:48 <dons> I recommend, tar xzf hs-plugins-1.0-rc0.tar.gz
19:56:51 <coffeemug> no
19:56:55 <Dreadshoot> anyone playing with hs-plugins on win?
19:57:02 <coffeemug> the file on the webpage had a .tar.tar extension
19:57:03 <dons> Dreadshoot: meet coffeemug
19:57:09 <dons> coffeemug: ??
19:57:21 <Dreadshoot> dons: i hope he aint empty
19:57:23 <coffeemug> dons: arggh, sorry
19:57:26 <SamB> .tar.tar!
19:57:32 <coffeemug> dons: something is really weird going on with my setup
19:57:36 <coffeemug> my apologies
19:57:59 <dons> Dreadshoot: coffeemug is looking at hs-plugins on windows with mingw, I think
19:58:15 <dons> that, and cygwin, have been reported as working
19:58:27 <Dreadshoot> okay, to solve the posix problem?
19:58:38 <dons> there shouldn't be a posix problem (?)
19:58:44 <dons> if you're using 1.0rc0 , that is
19:59:04 <Dreadshoot> when was that released, tried a month ago
19:59:16 <dons> 1.0rc0 ihas been out for months
19:59:26 <Dreadshoot> well then that was what i used
19:59:27 <dons> and has been confirmed to work with mingw
20:00:13 <coffeemug> src/AltData/Typeable.hs:452:0:
20:00:13 <coffeemug>     parse error (possibly incorrect indentation)
20:00:37 <coffeemug> does that have to do with the fact that I'm compiling with 6.6?
20:00:55 <dons> yes.
20:01:04 <dons> you absolutely cannot use 6.6 with hs-plugins at this point
20:01:15 <dons> it just won't work, even if you get passed the (first) Typeable.hs issue
20:01:21 <coffeemug> ok, let's move back to 4.4 :(
20:01:24 <Dreadshoot> dons: i wonder what that Consultants stuff is all about, that said it was ported to win
20:01:26 <coffeemug> 6.4
20:01:27 <dons> 6.4.2 should be fine.
20:01:33 <dons> Dreadshoot: yes, it has been
20:01:44 <coffeemug> dons: is there something windows specific in hs-plugins?
20:01:51 <dons> some small bits, yes.
20:01:57 <dons> to do with paths and symbol names, iirc
20:02:05 <coffeemug> if I were to deploy an app compiled with it to a non-cygwin non-mingw platform, will that work?
20:02:11 <coffeemug> or it requires cygwin dlls?
20:02:19 <dons> it doesn't require cygwin
20:02:20 <SamB> dons: what is wrong with Typeable.hs?
20:02:31 <Dreadshoot> dons: whats that supposed to mean, "it has been ported to win, but noone is able to run it"?
20:02:37 <dons> hmm?
20:02:44 <dons> people are running it under win
20:02:54 <Dreadshoot> with alot of extra libs
20:02:55 <dons> conal eliott, for one, wrote a paper using it on windows
20:03:04 <Dreadshoot> oh, url?
20:03:05 <dons> no, shouldn't need any extra libs
20:03:17 <Dreadshoot> i mean, that you need mingw and stuff
20:03:18 <dons> Dreadshoot: have you tried? do you have a bug report?
20:03:21 <dons> mingw, yes.
20:03:32 <dons> but this is typical if you are to have a working haskell environment on windows
20:03:38 <dons> since you need the gnu tools anyway
20:03:45 <Dreadshoot> umm why
20:03:50 <dibblego> how many hours are wasted resolving problems introduced by the = operator?
20:03:51 <dons> for Cabal, I think.
20:03:53 <SamB> mingw is just for building?
20:04:07 <Dreadshoot> i dont think you need mingw for cabal
20:04:12 <dons> well, you need gcc, ar, ld, ranlib(?) and then C libs
20:04:24 <SamB> dons: only for building or also for running?
20:04:41 <dons> I'd imagine there are libs also needed for running, but I don't use windows so can't say for sure
20:04:47 <Dreadshoot> dons: well yes but those are included in the ghc package, mingw aint
20:04:54 <SamB> well I expect it needs msvcrt.dll
20:04:56 <dons> Dreadshoot: do you have a bug report?
20:05:09 <araujo> dons, yeah
20:05:15 <SamB> Dreadshoot: what mean you?
20:05:21 <SamB> I was pretty sure it *was*
20:05:22 <araujo> dons, it goes well. We have some volunteers too!
20:05:29 <Dreadshoot> dons: nope, and im doing a 3d project atm
20:05:32 <dons> araujo: yes, i've seen.
20:05:37 <dons> araujo: well done.
20:05:51 <dons> araujo: we should motivate some of the other language guys. like the russians.
20:05:55 <araujo> dons, we are slowly translating pages. We also hope to release new work too. (me wants to talk about monads)
20:06:01 <Dreadshoot> samb: what i mean? if you download ghc for win, you get gcc and that stuff included, you dont get mingw
20:06:12 <araujo> dons, oh, somebody sent an email about russian in the haskell cafe
20:06:21 <araujo> i meant, russian translation.
20:06:22 <dons> maybe in a week or two you should tell people about how the project is going, list all the things that have been translated, and tell people using other languages to follow the same model as you
20:06:26 <SamB> Dreadshoot: the difference between "gcc and that stuff" and "mingw" being?
20:06:32 <dons> i.e. so we can have Language: en es ru pt ....
20:07:00 <Dreadshoot> samb: i allready said it 2 times now, one is included into the ghc for win package, one aint
20:07:12 <araujo> dons, I suppose the wiki is open to as any languages as translations initiative comes up?
20:07:17 <dons> araujo: one thing, i was thinking if many many pages are going to be translated, they should probably all live under haskellwiki/Espanol/ or something like that
20:07:17 <SamB> Dreadshoot: my point is that stuff *is* mingw!
20:07:22 <dons> araujo: yeah
20:07:23 <SamB> at least, in the vernacular
20:07:35 <SamB> technically mingw... um... isn't anything?
20:07:45 <SamB> but that makes no sense, so, the vernacular it is!
20:07:46 <araujo> dons, Good thing. Yeah, i can write a small report.
20:07:47 <dons> araujo: since if we have multiple versions of pages, in many languages, it will get messy using the top level namespace
20:07:50 <Dreadshoot> i doubt that, mingw might use gcc, but gcc aint mingw at all
20:08:06 <SamB> Dreadshoot: well *that* gnu toolchain is the one called mingw
20:08:17 <dons> araujo: I think if we can document how to go about namingand translating pages, that will help other people trying to do the same thing
20:08:21 <kfish> dons: es.haskell.org ?
20:08:25 <SamB> despite the fact that mingw is a bit different from the gnu toolchain
20:08:38 <araujo> dons, i agree
20:08:56 <Dreadshoot> samb: but do i get that whole toolchain, or do i have to download external stuff that aint included in the ghc(win) package to use mingw
20:09:19 <SamB> Dreadshoot: you really should be fine...
20:09:24 <SamB> dons: isn't that right?
20:09:31 <araujo> dons, so we would have stuff like: http://haskell.org/haskellwiki/Espanol/Introduccion
20:09:34 <lambdabot> Title: Espanol/Introduccion - HaskellWiki, http://tinyurl.com/yaccbz
20:09:35 <SamB> or well, I guess dons doesn't know
20:09:41 <dons> araujo: yeah, I think that's a good idea
20:09:50 <dons> or haskell.org/haskellwiki/Es/*
20:09:55 <dons> not sure which is better
20:10:00 <araujo> mm ...
20:10:02 <SamB> I personally don't have GHC installed on windows, because I can't program worth pennies in that OS...
20:10:02 <dons> kfish: yeah, that might be good too
20:10:04 <araujo> I can go with Es
20:10:16 <araujo> dons, Our main page is Haskell.es
20:10:28 <dons> araujo: since then we can have the whole tree mirroed under haskell.org/haskellwiki/{es,jp,ru...}
20:10:30 <araujo> We then can link from there to the Es/* stuff
20:10:33 <SamB> ... also my harddrive is filled with Anime and stuff
20:10:48 <araujo> dons, yes, i see the point
20:10:50 <dons> araujo: I wonder if the main Haskell.es page should be actually haskell.org/haskellwiki/Es/Haskell ?
20:11:06 <dons> and should be a translated mirror of the main haskell.org page?
20:11:11 <dons> so that the links work and so on
20:11:11 <araujo> dons, I think it'd be better, to follow the pattern.
20:11:49 <araujo> dons, i have been thinking about ... well .. i am not sure if we are enough people as to keep such a pace with the whole community :-)
20:12:16 <dons> araujo: sure. I understand. just having the most popular stuff (and the more static pages) done, is reasonable
20:12:18 <araujo> we are atm trasnalting pretty much random stuff , mainly from the popular pages
20:12:29 <araujo> translating ...
20:12:31 <dons> yep. I think that's fine. anything with more than say, 10k hits would be fine.
20:12:40 <araujo> Yeah.
20:13:09 <araujo> I am very positive though, and there has been lot of interest among spanish speakers.
20:13:48 <araujo> dons, i will start implementing the new link convention.
20:14:05 <Dreadshoot> dons: "runplugs: user error (LoadShared: couldn't load 'libwsock32.so' bacause addDLL: unknown error)" there you have the error
20:14:17 <araujo> And i can talk about all these translation efforts in the report too. So people can have an idea how/where to start at.
20:14:18 <dons> right. that's what happens without mingw, I think.
20:14:32 <Dreadshoot> yep
20:14:55 <dons> araujo: yes. if you could document and recommend to use haskell.org/Lang/* and then any other conventions you have used, that would be useful
20:15:10 <dons> maybe even put this on a new page, haskell.org/Translating
20:15:33 <dons> sorry, haskell.org/haskellwiki/Lang/  or haskell.org/haskellwiki/lang
20:15:42 <coffeemug> brb
20:16:40 <Dreadshoot> dons: got url for that paper on hs-plugins for win, or a tutorial how to install it with mingw or something?
20:17:49 <araujo> dons, Cool
20:18:08 <araujo> dons, that actually could even be the place where i post these reports ....
20:18:59 <dons> Dreadshoot: no, its not a paper on hs-plugins. the guy used hs-plugins, for a 2d graphics program, under win.
20:19:30 <Dreadshoot> well whatever, a mail or something so i can ask him
20:20:46 <slime_mold> isn't List.nub is slower than (Set.toList . Set.fromList)?
20:21:17 <slime_mold> if I don't care the order
20:21:37 <sjanssen> slime_mold: asymptotically, yes
20:21:46 <Lemmih> dcoutts: I think we can. HIDE is pretty much gone.
20:22:33 <dons> Dreadshoot: ah ok, google for Conal Elliot
20:22:44 <int-e> slime_mold: or just  map head . group . sort (probably faster than going through Set?)
20:23:28 <int-e> slime_mold: I'm assuming that there aren't too many duplicate elements, Set will win big otherwise.
20:24:02 <dons> Dreadshoot: conal.net
20:25:12 <slime_mold> I'll try it. Thanks sjanssen.
20:26:00 <sjanssen> or, if your domain is suitably small, you can use accumArray tricks to get it even faster
20:26:26 <Dreadshoot> yep found it
20:26:50 <Dreadshoot> i wonder if there's anyone here who knows how to install it with mingw
20:39:03 <coffeemug> ghc 6.6 comes with a lot of useful libs
20:39:07 <coffeemug> that I have to install manually
20:39:08 <coffeemug> :(
20:39:28 <Dreadshoot> did you manage to install hs-plugins?
20:47:07 <moconnor> Is getting ad hoc polymorphism the only reason to use type classes?  I'm new to Haskell and I find myself often a) creating a type class, b) making a single instance and filling in the methods and then c) realizing I have once instance, so just ditching the typeclass and making the methods functions.
20:47:24 <moconnor> s/once/only one/
20:47:44 <dons> its one of the reasons. there's several others (expressing type based proofs, playing OO games, ....)
20:47:57 <dons> they were deveoped as a way to make ad hoc polymorphism less ad hoc though
20:50:01 <moconnor> So, I often have a data structure and then a lot of functions to manipulate that data structure.  In a language an OO language I'd have a class that encapsulated my data structure and lots of instance methods.  Is it kind of a wash how you do the same thing in Haskell?  i.e. having a data structure and a bunch of functions, vs. having a data structure which is an instance of a typeclass w/ said methods?  The latter seems like a bad f
20:50:44 <Cale> moconnor: a bad what?
20:51:00 <moconnor> a bad fit.
20:51:06 <Cale> why is that?
20:51:07 <sjanssen> moconnor: you should use type classes as you might use subclassing/interfaces in OO
20:52:05 <Cale> typeclasses give you a really general way to specify interfaces, even to the point of involving multiple different types which interact in some way
20:52:13 <coffeemug> dons: doing this really sucks with 6.4
20:52:21 <coffeemug> dons: I'm missing a whole bunch of libraries
20:52:32 <coffeemug> dons: I couldn't install them with old cabal because some libraries use new features
20:52:37 <coffeemug> so I installed new cabal
20:52:43 <dons> right. its best to use 6.4.2
20:52:46 <coffeemug> now I'm trying to install Time library
20:52:49 <coffeemug> it says Win32 missing
20:52:50 <dons> since then you get new cabal and new everything else
20:52:57 <sjanssen> ie. it's worthwhile to have a type class when you might want to write functions that work with many data types, rather than hardcoding a specific type
20:53:00 <coffeemug> I install new Win32 library
20:53:07 <dons> don't use 6.4 if at all possible, use 6.4.2
20:53:16 <coffeemug> I did
20:53:46 <coffeemug> so right now win32 depends on bytestring, I install fps, try to install win32 again and it tells me ByteString.Base is missing
20:53:55 <coffeemug> which it shouldn't be since I got the latest fps source from darcs
20:54:12 <lennart> moconnor: yes, if you only have one instance there is no point in having a class.  just make it an (abstract) type
20:54:35 <int-e> coffeemug: maybe you have to add fps to the required packages in the cabal file?
20:54:58 <moconnor> Thanks for the explanations.  I think it's b/c I'm just writing toys and so I have yet to build up enough to make typeclasses pay off.  So I end up doing what lennart just said.
20:56:08 <coffeemug> int-e: ahh, it's missing it by default?
20:57:56 <dons> coffeemug: maybe?
20:58:16 <dons> you might be using a win32 that assumes ByteString is in the base package
20:58:51 <dons> basically, your troubles are that you need to use a lib that hasn't been ported to 6.6 yet, so you've got to roll back to an earlier version.
20:58:56 <dons> oh, what are you going to do with hs-plugins, btw?
21:00:00 <lispy> having bytestring in the base package makes it hard to craft .cabal files, imo
21:00:24 <dons> to craft backwards-to-6.4 compatible ones
21:00:32 <lispy> right
21:00:36 <dons> but that's what conditional cabal is for..
21:00:41 <lispy> or just use a library that assumed fps
21:00:42 <dons> which is in the works
21:01:06 <lispy> nice
21:01:16 <lispy> because cross platform cabal is a pain too :)
21:04:19 <coffeemug> hmm
21:04:29 <coffeemug> can I build latest base library with 6.4.2?
21:05:26 <dons> I wouldn't... I'd just add an fps dep to the depends field of the .cabal file in any library that needs it
21:05:39 <dons> should be fairly easy to deal with
21:05:55 <coffeemug> time library uses Data.Fixed
21:05:59 <coffeemug> from the latest base
21:06:25 <dons> I'm not sure time will even run back in 6.4.2. Maybe you can avoid hs-plugins till its ported to 6.6 ?
21:06:31 <dons> I'm sorry i've not had time to do that sooner.
21:06:44 <coffeemug> heh, don't apologize :)
21:07:02 <coffeemug> I could probably hack the server not to use time
21:07:10 <coffeemug> shouldn't be a problem for now
21:07:13 <dons> well, if you can avoid hs-plugins, everthing else should just work out of the box, right?
21:07:17 <dons> with 6.6
21:07:22 <coffeemug> when do you think hs-plugins will work on 6.6?
21:07:34 <dons> sometime in the next 3 weeks or so
21:07:41 <dons> i've got a huge amount of stuff going on
21:08:05 <coffeemug> is there some sort of a time library for 6.4?
21:08:14 <dons> seems to just be the case these days: length work > hours day
21:08:25 <dons> you could just use the normal System.Time
21:08:33 <dons> the new time library isn't essential, afaik.
21:08:36 <dons> ?hoogle Time
21:08:37 <lambdabot> System.Time :: module
21:08:37 <lambdabot> Time :: module
21:08:37 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [(String, String)] -> String, String -> String -> String -> String -> String -> TimeLocale)
21:10:00 <coffeemug> dons: yeah, that's cool
21:10:03 <coffeemug> I can use this
21:10:12 <coffeemug> dons: btw, the new time library has a problem, I think
21:10:26 <coffeemug> dons: when you do formatting %S formats seconds with a decimal
21:10:32 <coffeemug> so it looks like 24.5985645
21:10:39 <coffeemug> which is unacceptable in most situations
21:10:52 <coffeemug> and I coudn't find a way to format seconds into two digits (24)
21:10:58 <coffeemug> no big deal to postprocess the string
21:11:00 <coffeemug> but you know :)
21:12:58 <dons> fromIntegral sec ?
21:13:13 <dons> > round 24.5985645
21:13:14 <lambdabot>  25
21:13:16 <dons> or some such
21:13:27 <dons> > floor 24.5985645
21:13:28 <lambdabot>  24
21:19:11 <coffeemug> no no
21:19:16 <coffeemug> I'm talking about formatting
21:19:35 <coffeemug> when you do formatString "%h:%m:%s"
21:19:45 <coffeemug> formatTime I mean
21:19:46 <dons> ah ok. you could always use printf. or else talk to the author if it appears to be a bug?
21:19:53 <coffeemug> or some function like that
21:19:58 <svref> in LISP, a function ... -> Bool tends to have a name ending in "p", e.g. "listp", "numberp".  There isn't any similar convention in H., right?
21:20:09 <int-e> > map (\x -> (ceiling x, round x, truncate x, floor x)) [-1,-0.75..1]
21:20:11 <lambdabot>  [(-1,-1,-1,-1),(0,-1,0,-1),(0,0,0,-1),(0,0,0,-1),(0,0,0,0),(1,0,0,0),(1,0,0,...
21:20:19 <coffeemug> yeah, I will
21:20:23 <monochrom> right, svref
21:20:32 <coffeemug> it was pretty easy to find a workaround
21:20:33 <dons> > printf "%d:%d:%d" (10 :: Int) (27 :: Int) (floor 2.54343 :: Int) :: String
21:20:34 <lambdabot>  "10:27:2"
21:20:36 <coffeemug> but I will anyway
21:21:04 <dons> svref: we use types, not naming conventions :)
21:21:18 <dons> since its harder for the compiler to check naming conventions ;)
21:21:41 <dons> that being said, predicates to higher order functions are often named 'p'
21:22:01 <dons> or even,
21:22:02 <dons> filter pred (x:xs)
21:22:02 <dons>   | pred x         = x : filter pred xs
21:22:03 <dons>   | otherwise      = filter pred xs
21:22:07 <dons> (straight from the Prelude)
21:22:13 <coffeemug> all right, time to sleep
21:22:20 <coffeemug> more haskell stuff tomorrow :)
21:22:24 <coffeemug> thanks for everybody's help on this
21:22:33 <dons> night coffeemug
21:22:38 <coffeemug> good night dons
21:24:46 <lispy> ya know, books are useful
21:34:20 <thou> ?paste
21:34:21 <lambdabot> http://paste.lisp.org/new/haskell
21:34:59 <dons> hmm, http://www.crunchboard.com/job/1138
21:35:01 <lambdabot> Title: CrunchBoard - The Job Board for the Tech Industry
21:35:14 <dons> Website Lime Wire, EXTRA CREDIT: Lisp, Haskell, or any other functional programming language
21:35:41 <dons> should be a mod +100  if you have Haskell, imo ;)
21:36:59 <monochrom> ha
21:37:06 <lispy> just what i want to be, a "Senior Back-end" in a corporate setting
21:37:42 <dons> now i wonder if 'scalabe' here means highly parallel?
21:38:04 <dons> anyway, know FP as extra credit is very nice to see.
21:38:06 <int-e> scalable: does look good, even under a magnifying glass.
21:38:30 <monochrom> that's fractal
21:38:36 <dons> we can only hoe to see "Requirements: FP" soon.
21:38:56 <dons> yeah, scalable: looks good, even when monstrously large
21:39:01 <dibblego> should be where I work I'd imagine
21:40:50 <lisppaste2> thou pasted "using bracket inside CGI monad" at http://paste.lisp.org/display/28273
21:41:23 <lispy> thou hath pasted
21:41:27 <thou> hi, would anyone have a look at that paste?  is there any code I can look at to explain how to do what I want?  explained in comment at top of paste
21:41:34 <dibblego> what's the type class for getting "the next in the series"? like Ord or something
21:41:55 <monochrom> Enum
21:42:01 <int-e> lispy: thou hast?
21:42:02 <dibblego> that's the one - thanks
21:42:25 <thou> int-e: it sounds wrong either way
21:44:15 <lispy> thou: oh, bringert told me how to do that last week about this time...it was eithre wednesday or thursday
21:44:21 <lispy> thou: so check the logs
21:44:32 <lispy> thou: because i can't remember and i didn't find time yet :)
21:44:34 <thou> lispy: cool, i will
21:44:39 <thou> ok :-)
21:44:52 <dons> > succ 1
21:44:53 <lambdabot>  2
21:44:56 <dons> > pred 2
21:44:57 <lambdabot>  1
21:45:27 <lispy> > succ 1.1
21:45:28 <lambdabot>  2.1
21:45:40 <lispy> > suc 1%1
21:45:41 <lambdabot>  Not in scope: `suc'
21:45:47 <lispy> > succ 1%1
21:45:48 <lambdabot>  2%1
21:46:05 <thou> >succ fars
21:46:12 <thou> >succ "fars"
21:46:20 <lispy> nede a space after >
21:46:22 <thou> > succ "fars"
21:46:23 <lambdabot>  add an instance declaration for (Enum [Char])
21:46:23 <lambdabot>   In the definition of `iiy...
21:46:24 <lispy> > succ "fars"
21:46:24 <lambdabot>  add an instance declaration for (Enum [Char])
21:46:25 <lambdabot>   In the definition of `iid...
21:46:48 <thou> hmm, my toilet humor isn't as funny after four mistakes :-(
21:47:05 <lispy> heh
21:47:34 <lispy> thou: consider yourself lucky, my toilet doesn't tell jokes :(
21:49:57 <dons> why aren't pugs releases announced on haskell@ ?
21:49:59 <dons> audreyt: ?
21:50:15 <dons> oh, I suppose darcs releases aren't either. hmm
21:53:33 <lispy> darcs releases are mostly secret
21:53:47 <monochrom> darc secret!
21:54:20 <dons> they are. but they should go to haskell@, like all other haskell projects
21:54:23 <lispy> they get announced on darcs-devel and probably darcs-users but i don't realy see them anywhere les
21:54:39 <dons> i try to grab them for HWN, but pugs i hardly ever see
21:55:04 <lispy> in fact, i had to complain loudly to ubuntu just to get them to upgrade from a buggy 1.0.5 which is very old these days...and i'm still not sure they did it
21:55:37 <dibblego> 1.0.8 (release) on ubuntu
21:56:05 <lispy> dibblego: dapper?
21:56:10 <dibblego> yep
21:56:13 <lispy> nice
21:56:18 <lispy> they did listen!
22:16:26 <dibblego> does Yhc compile to the JVM?
22:19:30 <Cale> I don't think it does
22:19:34 <Cale> it would be news to me
22:19:48 <Cale> It compiles to its own form of bytecode
22:26:12 <dolio> I thought ndm mentioned that it did.
22:26:28 <dolio> They got patches to produce both jvm and clr bytecode, or something.
22:26:32 <dolio> From random sources.
22:27:13 <dolio> But they don't let you use the associated libraries or anything.
22:27:43 <Cale> hmm
22:28:27 <jgrimes> I know they have a runtime for the bytecode written in C#
22:28:59 <dibblego> yeah ndm mentioned .NET
22:29:16 <hyraxfourtwo> that wouldn't be the same as compliing to CLR though
22:29:25 <dibblego> I was just flipping through http://citeseer.ist.psu.edu/schinz01tail.html
22:29:54 <hyraxfourtwo> ok that's all I have
22:29:59 <jgrimes> but then again, there is a set DotNet modules for the compiler
22:30:04 <jgrimes> but I don't know what they do
22:30:05 <jgrimes> :)
22:30:12 <dibblego> mr_ank, if you like maths, you'll like #haskell :)
22:30:17 <satan> how do i find out and list the maximum number of possible trees of size n for a data type BTree a = Leaf a |  Fork (BTree a) (BTree a)?
22:30:27 <mr_ank> dibblego: i haven't been around here in ages.
22:30:45 <satan> i tried to solve the recurrence relation to see if that'd help
22:31:07 <dibblego> I wonder if ndm has thought about it and what his conclusions are
22:31:24 <lisppaste2> thou annotated #28273 with "Try without bracket" at http://paste.lisp.org/display/28273#1
22:32:18 <thou> lispy: i think i'm out of luck; i'll have to ask bringert and/or jgoerzen next time i have the chance
22:32:34 <dolio> <ndm> we don't really support linking in with other .NET code
22:32:44 <dolio> <ndm> quite possibly, someone just showed up one day with a patch :)
22:32:48 <dolio> <ndm> same as with the Java port, guy did the same thing...
22:32:58 <jgrimes> cool
22:33:27 <thou> i'm afraid even using bracket won't work, because the CGIResult will still not be "needed" until after the bracket is done, so disconnect will still be called before the call
22:34:08 <thou> maybe using seq or evaluate would fix it
22:38:01 <dons> and now the world's ugliest irc bot, http://www.zsh.org/mla/users/2006/msg00582.html :)
22:38:31 <dolio> Oh yeah, I was looking at that earlier today.
22:39:04 <dolio> Of all the languages to write an irc client in...
22:40:38 <dons> particularlly just a week after writing http://haskell.org/haskellwiki/Roll_your_own_IRC_bot  :)
22:40:41 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
22:42:20 <lisppaste2> thou annotated #28273 with "Exception.evaluate: still not enough" at http://paste.lisp.org/display/28273#2
22:42:46 <dolio> Yeah, your entire article appears to be shorter than just the code for his client.
22:42:53 <dons> thou: I haven't been following, but are you trying to force an exceptoin inside a bracket?
22:43:04 <dons> in which case you'll need to fully evaluate the value, i.e. deepSeq
22:43:24 <thou> i don't know what i'm trying to do anymore.  :-)
22:43:41 <thou> i tried deepSeq a long time ago when i was hoping to tackle this
22:43:46 <thou> maybe i should try it again
22:47:32 <thou> i'm trying to evaluate result of an HDBC query before executing, somethign like:  let cgidb action = lift (handleSqlError action >>= evaluate) in do { dbh <- cgidb (connectODBC "DSN=dbh"); result <- proc dbh; cgidb (disconnect dbh); return result }
22:47:35 <audreyt> dons: wasn't aware there's such a tradition of announcement
22:47:36 <lambdabot> audreyt: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:47:37 <audreyt> will do so
22:47:41 <thou> maybe that 'evaluate' needs to use deepSeq
22:49:14 <Cale> thou: hmm, why is it that you're forcing evaluation there?
22:49:43 <thou> it disconnects before it does the query (inside (proc dbh))
22:49:55 <dons> audreyt: I think that in general all haskell projects should at least make their major announcements also to haskell@haskell.org
22:50:04 <thou> i thought it was a bug in HDBC, but john said no:  http://www.haskell.org/pipermail/haskell-cafe/2006-October/018735.html
22:50:06 <lambdabot> Title: [Haskell-cafe] Re: Strictness, order of IO operations: NewCGI & HDBC, http://tinyurl.com/y5yttv
22:50:38 <thou> if it were lazy file IO with getContents, it works; but when i replace that with HDBC calls, it fails
22:50:46 <dons> I know that now the language is being used wider and wider afield, its getting harder to track everything, but i'm fairly sure haskell@ would be interested to know that pugs still proceeds merrily on its way :)
22:50:55 <dons> s/the language/haskell/
22:51:09 <Cale> interesting, I wouldn't expect it to use lazy IO
22:51:19 <thou> in his follow-up message to that one, he says to use bracket instead.  but i can't get it to work with CGI
22:51:58 <Cale> thou: although if you're trying to get it to do something, then the thing to be forcing evaluation on would be result
22:52:52 <gour> have you read http://www.codeproject.com/useritems/csharp3-concepts.asp ?
22:52:54 <lambdabot> Title: Concepts behind the C# 3.0 language - The Code Project - C# Programming, http://tinyurl.com/y5bkz9
22:53:31 <Botty> gour - yeah, interesting.  funny how it copies stuff from a slew of nice languages but makes it horrid
22:53:41 <thou> Cale: still not working
22:53:59 <thou> is there a defacto standard deepSeq module?  old hawiki DeepSeq page is empty
22:54:10 <gour> Botty: yes, one can just wonder and ask: "why not haskell?"
22:54:55 <thou> haskellwiki says "try full text search" but doesn't tell me how to do that
22:55:04 <dons> gour: yeah, funny hey :)
22:55:13 <dons> thou: yeah, here's one..... /me looks
22:55:34 <dons> ?google DeepSeq.lhs
22:55:36 <lambdabot> http://urchin.earth.li/icfpcontest/2004/sub/tools/shared/DeepSeq.lhs
22:55:40 <dons> that'll do
22:55:43 <thou> thanks
22:55:53 <dons> it's pretty easy to write yourself, too.
22:56:04 <Botty> gour - well, I'm not so enamored with haskell that I think it's ideal.  Something more like a composite of paradigms, perhaps at the very core functional, yet appearing to be a composition at the surface is probably best
22:56:05 <dons> since its just an inductive seq on the type structure, via type classes
22:56:37 <Botty> This is kinda-sorta the feeling of C#, except that its hacked ontop of the old stuff
22:56:49 <Botty> Can't blame them for trying though
22:56:55 <thou> could DeepSeq be written automatically in Template Haskell?
22:56:59 * thou doesn't know much about TH
22:57:11 <dons> Botty: yeah, they get points for wanting to improve things, and knowing where to look to find the cutting edge
22:57:16 <gour> Botty: well, i am - took look & do something with many langs (mostly imperative), but haskell is really different & refreshing one
22:57:19 <dons> thou: yeah
22:57:29 <gour> s/do/did
22:58:43 <Botty> yeah, its nice, and certainly a good perspective shift, however a mathematical view does not well (intuitively) adapt itself to all models.
22:59:50 <gour> i'd say if there is no strong mathematical view, then something smells
23:00:07 <gour> finally, computers are about computation
23:00:30 <dons> yeah, if you can't understand what the language is doing, how do you know when you've a bug? and how do you establish the absence of bugs...
23:00:48 <Botty> hmm, yes, if only people used their computers for computation... ;)
23:00:55 <dons> and finally, adding "hard" features gets a bit scary. multi core parallel deadlock free programs anyone
23:01:06 <Botty> (most people, that is)
23:01:18 <gour> Botty: using or programming?
23:01:28 <Botty> using
23:01:37 <gour> we are talking about programming ;)
23:02:03 <Botty> true, and alot of programming for user applications isn't really about computation, more construction
23:03:08 <gour> i still have to learn lot about haskell, but it helps me to focus on thinking about the problem, not about the language itself, ie. not being on the way
23:03:24 <gour> Botty: example?
23:03:54 <Botty> User interfaces, web stuff, etc.  most of the code is just presentational
23:04:35 <Botty> sure, its computation, but it doesn't really compute anything, just constructs something, constructs an interface with the user
23:04:53 <Botty> kinda hard to describe, I'm not even sure if I'm right :)
23:05:58 <Botty> gour - I dunno, I'm a haskell newb too, and mostly I have to take a problem and fit it to haskell idioms.  Probably because I'm used to imperative languages, however, in my opinion imperative languages are more natural.
23:07:01 <Botty> a child can understand a list of actions with conditions, whereas a mathematical, functional view takes many people years to comprehend (elementary through middle school)
23:07:34 <gour> Botty: because we became used to them. we cannot get free of thinking in terms of loops etc. however, after some time - paradigm shift - you'll see that problems can be solved much differently, ie, more simple
23:07:40 <Botty> Not that it needs to take that long, that's just the crappyness of the school system
23:07:44 <dons> a list of actions modifying a global state, is different to a list of pure actions.
23:07:47 <gour> right
23:07:58 <dibblego> how do you get the first n elements of a list?
23:08:00 <Botty> oh, yes, I understand that.  I really like haskell
23:08:04 <xerox> dibblego: take
23:08:08 <Pseudonym> > take 3 [1..10]
23:08:09 <lambdabot>  [1,2,3]
23:08:13 <dibblego> oh ta
23:08:15 <xerox> Hola Pseudonym.
23:08:19 <Pseudonym> G'day.
23:08:22 <dons> yeah, map washingUp dishes
23:08:31 <dons> it's just how humans think
23:08:37 <Botty> lol
23:08:42 <gour> dons: try with a loop ;)
23:08:52 <dibblego> @hoogle a -> [a] -> Int
23:08:53 <lambdabot> No matches, try a more general search
23:08:59 <Botty> more like "Wash dish 1, wash dish 2, wash dish 3"
23:09:00 <dons> for (i = 0; i < MAX_DISHES; i++) { washdishes(dishes[i]) ; }
23:09:01 <dibblego> @hoogle [a] -> a -> Int
23:09:01 <lambdabot> No matches, try a more general search
23:09:11 <dibblego> @hoogle Eq a => [a] -> a -> Int
23:09:12 <lambdabot> No matches, try a more general search
23:09:21 <dons> now the loop is nothing like how we actually think about it
23:09:22 <emu> map wash . cycle $ dishes
23:09:22 <dibblego> find the first occurence of an element in a list?
23:09:31 <xerox> fetch dishes >>= wash-machine
23:09:37 <Botty> dons - heh, I'm not arguing for C, I hate C.
23:09:41 <dibblego> ?type elem
23:09:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:09:46 <dibblego> ?type index
23:09:48 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
23:09:51 <Pseudonym> for (std::sink<dish>::const_iterator ii = mySink.begin(); ii != mySink.end(); ++i) { ii->wash(); }
23:09:58 <dons> mmmm
23:10:01 <xerox> dibblego: elemIndex elemIndices too.
23:10:01 <dibblego> ?type [a] -> a -> [Int]
23:10:02 <lambdabot> parse error on input `->'
23:10:05 <dibblego> phew thanks
23:10:09 <dibblego> ?type elemIndex
23:10:11 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
23:10:18 <dibblego> ?type elemIndices
23:10:19 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
23:10:29 <dons> at some point C++ became a language for benchmarking parser generators, and not for programming....
23:10:29 <gour> dons: well if you have a wife then she will tell you about MAX_DISHES
23:10:46 <dons> heh
23:10:50 <Botty> actually, humans think in an object oriented way - apply the wash operation to the dish collection
23:10:55 <Botty> ;)
23:11:01 <emu> is there a parser generator that can handle C++
23:11:10 <dolio> mapM wash dishes :)
23:11:15 <dons> yeah, that's a map.
23:11:30 <dons> i.e:   wash dishes
23:11:51 <dons> ^^ "apply the wash operation to the dish collection"
23:11:51 <Botty> I know, but do people think, oh I'll just map my wash operation? no.
23:12:00 <Botty> ;P
23:12:18 <Botty> terminology differences, yes.
23:12:25 <dons> depends on whether you want to look at the wash operation on a dish, or the operation on dishes as a group
23:12:50 <thou> might want foldM instead?
23:12:54 <gour> do { wash_dishes; } until {i say you're finished}
23:13:08 <dons> thou: but the result of washing a dish isn't passed to the next dish.... or is it ;)
23:13:20 * thou is picturing a full dish drainer
23:13:26 <dons> i guess it is a fold, since by the end you're washing with the water full of the "results" of washing the first dishes
23:13:32 <gour> ha ha
23:13:45 <dibblego> > let f n = take (elemIndices '.' n !! 0) in f "0000.xml"
23:13:46 <lambdabot>  Add a type signature
23:13:52 <dibblego> why do I need a type signature?
23:14:01 <dons> fold (\water dish -> wash water dish) soapywater dishes
23:14:09 <Botty> dour - but how do you output the clean dishes?
23:14:29 <dons> it's a fold, so you accumulate both dirty water and a list of dishes
23:14:30 <dolio> Isn't the state of the water contained in the sink monad?
23:14:44 <Botty> lol
23:14:45 <dons> it should be, yeah
23:16:30 <dibblego> ?where lambdabot
23:16:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:20:05 <xerox> dons: haha right
23:20:14 <xerox> @remember dons fold (\water dish -> wash water dish) soapywater dishes
23:21:08 <sjanssen> that's a foldl, right?
23:21:26 <xerox> Yep.
23:21:55 <sjanssen> better make it foldl' then, so we don't build up a giant thunk of dirty dishes
23:22:22 <xerox> But that's exactly what ever happens.
23:22:37 <sjanssen> heh
23:22:39 <dons> should probably be: let (dirtyWater, cleanDishes) = foldl' (\water dish -> water `wash` dish) soapyWater dirtydishes
23:22:54 <lisppaste2> thou annotated #28273 with "Using deepSeq?  no dice." at http://paste.lisp.org/display/28273#3
23:23:22 <thou> would someone who knows deepSeq mind checking that paste?  it still breaks, unless I comment out the DB.disconnect
23:24:43 <sjanssen> thou: you probably want dbResult `deepSeq` return dbResult
23:24:57 <thou> sjanssen: let me try it, thanks
23:25:10 <svref> Is it possible to get a backtrace after a fatal error?
23:25:33 <dons> yeah, with profiling, you can inspect the call stack
23:25:51 <svref> e.g. Hugs?
23:25:55 <dons> or use asserts , and get line /col numbers printed.
23:26:00 <dons> profiling in ghc
23:26:02 <thou> sjanssen: that works
23:26:05 <thou> now to figure out why ....
23:26:18 <dons> since you need to force the result before returning it, thou
23:26:34 <dons> (return just wraps up the result, evaluated or otherwise), remember
23:26:50 <thou> return $ seq res res
23:26:52 <dons> i.e. return (<unevaluated dbResults>)
23:26:58 <thou> so that's wrong ^^^
23:27:01 <dons> no good.
23:27:04 <thou> k
23:27:17 <dons> tha's return (<unevaluated seq res res>)
23:27:24 <thou> yeah, i can see that now
23:27:26 <dons> you mean, res `seq` return res
23:27:26 <sjanssen> seq x x is essentially a no-op
23:27:44 <xerox> ?where hnop
23:27:44 <lambdabot> http://semantic.org/hnop/
23:28:58 * xerox brews some powerful tea.
23:29:25 <dons> ah, someone did manage to get some photos from the GSoC conference, from inside google, http://flickr.com/photos/boredzo/sets/72157594331666527/ despite security...
23:29:27 <lambdabot> Title: GSoC Mentor Summit 2006 - a photoset on Flickr, http://tinyurl.com/y77fw2
23:29:35 <xerox> Yeehee!
23:29:46 <dons> though looks like they still had to stop dtaking photos early on
23:30:02 <sjanssen> what, does somebody tackle you if you pull out a camera?
23:30:20 <dons> the security guy, yeah
23:30:40 <dolio> An office linebacker?
23:30:58 <dons> so this is my one and only from inside http://www.cse.unsw.edu.au/~dons/images/sf/pa150009.jpg :)
23:30:59 <lambdabot> http://tinyurl.com/y5tnlh
23:32:40 <xerox> dons hehe.
23:33:14 <dons> random photos of SF here, http://www.cse.unsw.edu.au/~dons/images/sf/, though no thumbnails or other nicities :)
23:33:15 <lambdabot> Title: Index of /~dons/images/sf
23:33:19 <xerox> dons looks like those platform they have for techtalks.
23:34:45 <xerox> Starving <3 Students
23:35:04 <dons> heh
23:36:29 <xerox> Kiss 'N Ride?!
23:37:10 <dons> i've no idea what that means? maybe they're taxis that you can just hop into?
23:37:19 <dons> any US people know what "Kiss N Ride" means?
23:37:43 <Botty> uh, sounds like a sexual allusion to me
23:38:11 <sjanssen> which image are we talking about?
23:38:12 <dons> yeah ... but at a train statoin... http://www.cse.unsw.edu.au/~dons/images/sf/pa170002.jpg
23:38:13 <lambdabot> http://tinyurl.com/y34suu
23:38:18 <Pseudonym> Mmmm... ghirardeli..
23:38:33 <Pseudonym> Proof that American chocolate isn't all crap.
23:38:42 <Botty> wierd, i dunno
23:38:50 <xerox> 3^3 numbers!
23:38:53 * dons has a $50 pile of ghiradelli on the table here. also some Scharffen Berger
23:38:54 <sjanssen> I don't have any insight into that
23:39:37 <Botty> http://www.google.com/search?q=%22Kiss+%27N+Ride%22
23:39:38 <lambdabot> Title: "Kiss &#39;N Ride" - Google Search, http://tinyurl.com/y46hbp
23:40:52 <dons> ah, "the area where parents line up in their cars to drop off and later pick up their kids"
23:41:55 <xerox> What is "Ghirardelli" ?
23:42:03 <Botty> chocolate brand
23:42:08 <Pseudonym> Nice chocolate.
23:42:08 <xerox> Ah-ha.
23:42:11 <dons> famous chocolate maker in SF
23:42:25 <dons> invented some part of the modern chocolate making process, iirc
23:42:35 <Pseudonym> About the same level of niceness as Guylian.
23:43:02 <xerox> Now how comes Haskell people are chocolate experts?
23:43:20 <dons> Pseudonym: you can get ghiradelli at david jones these days, I think
23:43:28 <Pseudonym> Yeah.
23:43:38 <Pseudonym> You can also get Michel Cluizel there.
23:43:39 <dolio> Because they have good taste?
23:43:52 <Pseudonym> Cluizel makes the world's most potent chocolate.
23:43:56 <Pseudonym> 99% cocoa mass
23:44:00 <dons> ooh, sounds nice.
23:44:03 <Pseudonym> Forget your Lindt 85%.
23:44:14 <Botty> sounds like bakers chocolate
23:44:15 <dons> i know they have a 99% "black" or some such at the Lindt cafe in sydney
23:44:19 <Pseudonym> I reckon 99% is about the most you can get and still call it "chocolate".
23:44:24 <Pseudonym> Lindt has a cafe?!
23:44:25 <Pseudonym> Woo!
23:44:30 <dons> (also where they have cakes coated with gold leaf)
23:44:31 <Maddas> Heh, somebody else knows Lindt chocolate? :-)
23:44:37 <Botty> The high percentage stuff keeps my up at night
23:44:40 <dons> yeah, its _amazing_, the lindt cafe
23:44:43 <Pseudonym> Does Sydney have a Koko Black?
23:44:50 <xerox> Pseudonym: at the local Fair Trade shop I can get 100% bio chocolate mass.
23:44:52 <Botty> Lindt is good, just had some earlier today, which is why i'm still up...
23:44:54 <dons> hmm, haven't heard of it
23:44:57 * Maddas didn't know Lindt had stores all over the place
23:45:01 <xerox> Err, cocoa mass, I think.
23:45:03 <Maddas> (Assuming it is the same Lindt, which it probably is)
23:45:07 <dons> I think Sydney has the world's only Lindt cafe
23:45:14 <Maddas> Ah.
23:45:22 <dons> ?google lindt cafe
23:45:25 <lambdabot> http://www.eatability.com.au/au/sydney/lindts_cafe.htm
23:45:25 <lambdabot> Title: Lindt Cafe, Sydney, NSW, Sydney Cafe Review - Eatability
23:45:29 <dons> there you go
23:45:30 <Pseudonym> Yeah, Koko Black is only in Melbourne.
23:45:34 <Pseudonym> ?google koko black
23:45:36 <lambdabot> http://www.kokoblack.com/
23:45:36 <lambdabot> Title: kokoblack
23:46:26 <Botty> Seriously, unless it's purely placebo, cocoa effects me more than caffeine
23:46:36 <dons> apprently the saudi royal family bought some 20k worth of gifts from the lindt cafe, a few months ago, i remember reading in the SMH
23:46:42 * Maddas didn't notice that
23:47:14 <Maddas> But then again, I rarely eat chocolate containing much cacao.
23:47:22 <Maddas> (Simply because it's expensive; I love it)
23:48:01 <Maddas> (Not the chocolate bars, the pralines)
23:48:14 <Pseudonym> Oh, Lindt owns Ghirardelli.
23:48:18 <dolio> Doesn't cocoa contain caffeine?
23:48:20 <Pseudonym> OK, I can buy that.
23:48:22 <dons> oh, huh!
23:48:33 * xerox looks outside at the rain...
23:48:37 <Botty> dolio - hah, maybe that would explain that
23:48:45 <dolio> :)
23:48:54 <dons> that's probably why we're finding ghirardelli more widely now
23:49:01 <xerox> http://www.erowid.org/chemicals/chocolate/chocolate_chemistry.shtml
23:49:03 <lambdabot> Title: Erowid Chocolate Vault : Chemistry, http://tinyurl.com/8wum6
23:49:07 <dons> (like when cadbury bought green&blacks last year, now you can get it at Coles)
23:49:24 <Stinger_> green&blacks?
23:49:28 <Botty> only .1% caffeine though
23:49:39 <dons> ?google green and blacks chocolate
23:49:42 <lambdabot> http://www.greenandblacks.com/
23:49:55 <Stinger_> rebuilding X at the moment, cant open firefox :)
23:49:57 <xerox> Rrrr, all this chocolate sites.
23:50:06 <xerox> _That's_ what you browse all the time, ah!
23:50:06 <Maddas> xerox: heh, neat!
23:50:26 <xerox> ;-)
23:50:31 <Pseudonym> Chocolate is clearly my porn of the day.
23:51:02 <dons> yeah, there are some really nice blocks here, http://www.greenandblacks.com/uk/categories.php?pageid=27&cid=6
23:51:06 <dolio> Well, according to the wiki, "A typical 28-gram serving of a milk chocolate bar has about as much caffeine as a cup of decaffeinated coffee."
23:51:06 <lambdabot> Title: Green & Blacks Chocolate, http://tinyurl.com/ylkt4l
23:51:07 <xerox> A piece of chocolate would now give me the force to leave for uni...
23:51:09 <gour> chocolate is drug, contains caffeine & causes depression - enjoy ;)
23:51:10 <dons> the 'maya gold' is stunning
23:51:32 <dolio> So if you're eating stuff that's 99% cocoa, that's probably a significant amount of caffeine.
23:51:40 <xerox> Ow.
23:51:42 <Pseudonym> Green & Blacks hasn't appeared in Victoria yet.
23:51:42 <dolio> Oops, I'm an idiot.
23:51:49 <dolio> Decaffeinated coffee.
23:51:53 <Pseudonym> Probably only a small matter of time.
23:51:59 <dons> Pseudonym: oh, that's a pity. we have it in IGAs and Coles. so shouldn't be too long
23:52:15 <Botty> gour - more like the reverse.  Its got stimulants
23:52:34 <xerox> Anyway, this tea I'm drinking probably has got enough :)
23:52:47 <xerox> Are you keen on tea brandings too? (:
23:52:51 <dons> Pseudonym, its getting almost as easy to find as lindt or guylian
23:52:57 <gour> Botty: yes - short run. depression - long run, the same as with other intoxicants
23:53:00 <xerox> It's FTGBOP.
23:53:13 <Botty> yeah, if you get addicted
23:53:37 <Botty> even then you can recover from addiction
23:53:56 * Maddas never got addicted to chocolate.
23:54:11 <xerox> http://www.teafountain.com/teagrades/
23:54:12 <lambdabot> Title: Tea Grade Definitions and Tea Production Processes
23:54:21 <xerox> FTGFOP1 (Finest Tippy Golden Flowery Orange Pekoe First Grade Leaves).
23:54:25 <dons> Pseudonym: my girlfriend used to have a part time job in the oxfam shop up here, which was the only distributor of green and blacks before cadbury bought it. so that was nice ... any "broken" blocks got passed on to me for testing purposes
23:54:25 <Maddas> (And I never felt *more* depressed after eating chocolate, as far as I recall)
23:54:46 * xerox stares at dons!
23:54:48 <Pseudonym> Nice!
23:54:59 <Maddas> xerox: Heh. I don't know much about tea, but I sure find all these commercially sold teas with strange aromas terrible :-)
23:55:01 <Pseudonym> I wish I had a SO with connections like that.
23:55:10 <Pseudonym> My wife is a perfume retailer.  The best she gets is testers.
23:55:10 <xerox> Maddas: that's true (:
23:55:26 * Maddas has some presumably good Lapsang Souchong he has yet to try.
23:55:32 <Pseudonym> Which make great gifts, but it's not as good as nice chocolate.
23:56:05 * Maddas has relatives who own tea estates (:
23:56:12 <xerox> I'll leave you with this video. It is interesting, he talks about optimizations, mentions Newton's method, and goes on with something advanced I think. http://www.msri.org/communications/vmath/VMathVideosSpecial/tapia/tapia2
23:56:15 <lambdabot> http://tinyurl.com/y5ralw
23:56:20 <Pseudonym> My brother had a boss who had a brother who had a plantation in Sri Lanka.
23:56:28 <Pseudonym> This boss knew Arthur C. Clarke personally.
23:56:33 <Maddas> heh.
23:56:59 <xerox> 2001: A Space Odyssey?
23:57:13 <Pseudonym> Do you know another Arthur C. Clarke?
23:57:15 * gour does nto est chocolate. better make cakes and/or use carob chocolate
23:57:22 <xerox> Nope.
23:57:33 <xerox> Well, have fun, bye bye.
23:57:46 * Maddas leaves too
23:57:52 <Maddas> gour: (:
23:58:29 <gour> Maddas: http://www.yogitea.com/HerbGlossary/HerbGlossary.asp?ID=68
23:58:32 <lambdabot> Title: Yogi Tea - Herb Glossary with green tea, organic herbal tea, and the natural hea ..., http://tinyurl.com/yxuxlc
23:59:47 <gour> @where paste
23:59:48 <lambdabot> http://paste.lisp.org/new/haskell
