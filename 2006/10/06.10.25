00:01:04 <emu> now when I call other functions in the State monad, all I need to do is be sure I "put" any state changes before calling?
00:01:47 <roconnor> > let foo False = 0; foo True = 1; foo _ = 2 in foo (fix (&&True))
00:01:48 <lambdabot>    Warning: Pattern match(es) are overlapped
00:01:49 <lambdabot>        In the definition...
00:02:01 <roconnor> I know
00:02:04 <roconnor> what's the answer!
00:02:17 <skew> _|_
00:02:26 <skew> oh, wait
00:02:48 <skew> nah, foo is still strict
00:02:56 <emu> @type fix (&&True)
00:02:58 <lambdabot> Bool
00:03:02 <dave_m> Isn't (&&) strict in its first argument?
00:03:20 <dons> kind of defeats the purpose of a build system, firefox 2.0 sez: "Running configure and make with the default options will not give you a good working build. "
00:03:46 <skew> ./configure --enable-html?
00:04:04 <emu> where's the --less-bloat option
00:04:08 <dons> heh
00:04:21 <dons> but firefox _is_ the less bloat version ;)
00:04:27 <dons> scary, I know.
00:04:30 <roconnor> @hoogle fix
00:04:31 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
00:04:31 <lambdabot> Control.Monad.Fix :: module
00:04:31 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
00:04:33 <emu> or the --use-system-editor
00:04:47 <x3m> dons: why dont you write a haskell book? :)
00:04:55 <dons> i will, next year :)
00:05:04 <emu> first, we need a Haskell type-setting program
00:05:08 <dave_m> Do people actually use the full Mozilla? I remember at one point they were talking about building in an IRC/IM/talk client
00:05:12 <dons> have to finish my phd first, before my supervisor terminates me with extreme type errors
00:05:18 <x3m> aha ok
00:05:21 <emu> I used to use "Mozilla" but never the side-apps
00:05:28 <roconnor> > fix (+1)
00:05:29 <lambdabot>  Exception: <<loop>>
00:05:31 <emu> chatzilla seems to b e pretty popular
00:05:34 <roconnor> > fix (&&True)
00:05:34 <skew> "Exteme Type Errors"
00:05:35 <lambdabot>  Exception: <<loop>>
00:05:59 <dave_m> fix isn't going to work on strict functions
00:06:15 <roconnor> it works fine, it produces loop
00:06:18 <x3m> dons: test
00:06:27 <emu> > fix (&&False)
00:06:28 <lambdabot>  Exception: <<loop>>
00:06:29 <dave_m> > fix (True ||)
00:06:31 <lambdabot>  True
00:06:36 <dons> x3m?
00:06:42 <dave_m> > fix (False &&)
00:06:44 <lambdabot>  False
00:06:47 <emu> yep
00:06:55 <x3m> just fixed the script, it did bold on first letter by default
00:07:09 <roconnor> > case undefined of () -> True
00:07:10 <lambdabot>  Undefined
00:07:30 <emu> > case undefined of _ -> True
00:07:33 <lambdabot>  True
00:07:39 <emu> slick elimination
00:08:01 <roconnor> I'm trying to think how case statements with Void would work.
00:08:17 <emu> > if undefined then True else True
00:08:18 <lambdabot>  Undefined
00:08:36 <dave_m> I thought the point of Void was that no case statement involving it would ever be evaluated
00:08:42 <roconnor> case (undefined::Void) of {} vs case (undefined::Void) of {_ -> 5}
00:08:47 <dons> > case Just undefined of Just _ -> True
00:08:48 <lambdabot>  True
00:09:01 <roconnor> dave_m: so what does case (undefined::Void) of {_ -> 5} return?
00:09:04 <skew> case (x::Void) {} :: a
00:09:19 <roconnor> I suppose it ought to return 5.
00:09:27 <Lor> The former is much prettier, and everyone using coq is already used to it.
00:09:36 <dave_m> right, but the point is that you aren't supposed to ask
00:10:07 <skew> ah, but in Haskell you have bottoms in Void, it's not empty after all
00:10:21 <dave_m> that is, the only non-bottom value of [Void] is []
00:10:42 <dons> yeah, RealWorld# could be used, I uppose. strict and no values.
00:11:00 <int-e> you also have [_|_], [_|_,_|_] and so on, and an infinite list.
00:11:06 <roconnor> dave_m: but I did ask.  Following the Haskell 98 report case (undefined::Void) of {_ -> 5} means 5
00:11:38 <Lor> It should be a bang-pattern.
00:12:19 <int-e> Oh, and the finite lists ++ _|_. That's quite a few values to play with.
00:12:22 <dave_m> True enough. That's why I'd prefer to define magic :: Void -> a as magic a = s `seq` undefined
00:13:00 <skew> why not just as const undefined?
00:13:19 <dave_m> skew: so that it's strict
00:13:28 <dave_m> it makes no practical difference
00:13:40 <roconnor> int-e: so (a:b) is an needed pattern for [Void]?
00:13:52 <emu> is there a proper way to include +Infinity :: Float literally
00:14:05 <dave_m> > 1/0
00:14:07 <lambdabot>  Infinity
00:14:11 <emu> yea thats what i been doing
00:14:13 <skew> dave_m: the strict way probably gives better errors
00:15:15 <dave_m> skew: I think so, too.
00:16:48 <dave_m> roconnor: depends on what you're doing.
00:17:33 <dave_m> Would Void be an instance of Eq and Ord?
00:17:52 <roconnor> I think that is appropriate
00:18:10 <roconnor> but not bounded.
00:18:48 <int-e> Enum works though
00:18:58 <dave_m> In that case, we can talk about Set Void. Since it's strict, the only non-bottom value is the empty set.
00:19:45 <int-e> > length $ sort [undefined]
00:19:46 <lambdabot>  Add a type signature
00:19:51 <int-e> > length $ sort [undefined :: Int]
00:19:53 <lambdabot>  1
00:20:28 <roconnor> > length $ sort [undefined,undefined :: Int]
00:20:30 <lambdabot>  Undefined
00:20:52 <roconnor> How you you feel about an optimizer that optimized that from Undefined to 2?
00:22:53 <int-e> bad.
00:23:17 <dave_m> well, length isn't strict in the list elements, and you expect sort to keep the number of elements constant
00:23:30 <int-e> well, it depends actually.
00:23:39 <dave_m> the problem is that the optimization doesn't reflect the strictness of sort
00:23:41 <int-e> it's possible to implement sort in Haskell so that this works.
00:24:44 <int-e> but the standard implementation doesn't work that way and I feel that changes in strictness should be up to the library implementor, not the compiler.
00:25:25 <dave_m> it is?
00:26:18 <roconnor> int-e: so you wouldn't want to optimize bubble sort to quicksort?
00:26:32 <int-e> roconnor: I'd be unhappy if the compiler does that, yes.
00:26:48 <roconnor> int-e: is there anything you would like your optimiser to do?
00:28:02 <dave_m> wouldn't a non-strict sort require a non-strict comparison operation?
00:28:14 <dave_m> optimisers shouldn't change the strictness properties of functions, unless you give explicit permission
00:29:30 <int-e> roconnor: bubble and quick sort behave differently depending on the Ord instance, unless that is a linear order.
00:29:40 <roconnor> dave_m: but length $ sort [undefined,undefined :: Int] isn't a function, it is a value.
00:30:16 <dave_m> int-e: is that distinct from a total order?
00:30:32 <int-e> dave_m: no.
00:30:50 <dave_m> roconnor: your proposed optimization is equivalent to replacing sort with id
00:31:18 <dave_m> int-e: Ord defines a total order. Otherwise, we wouldn't have compare :: a -> a -> Ordering
00:31:37 <roconnor> dave_m: I'm not proposint replacing sort with id, I'm proposing replacing (length $ sort [undefined,undefined :: Int]) with 2
00:31:46 <int-e> roconnor: I think the compiler should not change the operations that are prescribed by the program; so it should compare the same elements of the lists ... it can change their order, I'm happy with that.
00:32:16 <int-e> roconnor: and it can do CSE up to a certain level (ghc actually does too much CSE in some cases)
00:32:31 <roconnor> ``compiler should not change the operations that are prescribed by the program''  Does this mean no optimisations at all?
00:32:32 <dave_m> I assume the general optimisation is to replace "length . sort " with "length".
00:32:43 <dave_m> Those two functions have different strictness
00:33:06 <roconnor> dave_m: ah, that does seem like a better optimization.
00:33:15 <int-e> roconnor: it can reorder them. there's a lot of optimisation potential on the way from haskell to the bare hardware.
00:33:31 <int-e> roconnor: but changing algorithms is too much.
00:33:40 <dave_m> Right, but it doesn't preserve strictness. Some programs will run with the optimisation that wouldn't run otherwise
00:34:00 <int-e> roconnor: all that is my personal opinion of course, and I'm a sort of control freak when it comes to coding. ymmv
00:34:14 <dave_m> int-e: what are your feelings about deforestation?
00:35:00 <roconnor> ``Some programs will run with the optimisation that wouldn't run otherwise'' is that so bad.  Isn't it similar to a program running in 3 hours instad of 3 billion years?
00:35:02 <int-e> dave_m: good question. I don't view data construction as an operation I guess.
00:35:58 <dave_m> true enough. Making a function less strict is usually harmless. Making it more strict causes problems.
00:36:19 <int-e> ok, I guess not changing the operations is not actually what I want. but changing the flow of the algorithm ... the comparisons done by a sort ... no.
00:36:36 <int-e> I realize that's vague.
00:36:53 <dave_m> if they produce the same output on all possible input, I would have no problems swapping one for the other
00:37:30 <dave_m> granted, that's no good if you're trying to demonstrate the performance of bubblesort vs quicksort
00:38:02 <int-e> I'd rather see the better algorithm in the libraries then.
00:38:09 <kfish> hmm, where would i find charset conversion functions in haskell?
00:38:17 <int-e> the compiler is the wrong level for this stuff.
00:38:46 <kfish> eg. when lambdabot finds a page written in EUC-JP, it blats the title onto #haskell.jp as garbage, ie. without conversion
00:38:55 <roconnor> int-e: ah good, where is the right level!
00:39:19 <int-e> roconnor: the library. you'll notice how Data.List.sort is not a bubble sort ;)
00:39:39 <dave_m> kfish: I don't know of anything in the standard libraries
00:39:46 <roconnor> int-e: how does that help for optimizations like deforestation?
00:40:15 <dave_m> kfish: There may be a wrapper around iconv somewhere
00:40:24 <roconnor> int-e: there are all sorts of optimizations that have the potentional to run arcoss modules boundaries
00:40:33 <kfish> dave_m, cheers
00:40:35 <int-e> roconnor: Hmm, ghc's rules are pretty clever. (see Data.Bytestring)
00:41:56 <int-e> roconnor: but deforestation is a boundary case for me.
00:42:32 <dave_m> I don't think anyone was suggesting that the compiler convert a bubblesort into a quicksort in the first place
00:43:18 <dave_m> The point was that "length . sort" is equivalent to "length" when the former returns a non-bottom result
00:43:20 <int-e> roconnor: from a language perspective, you're dealing with data construction (constructor calls) and deconstruction (case) which are the fundamental operations of Haskell, so the compiler will have to optimize it because the programmer certainly can only do that up to a certain point.
00:43:44 <int-e> dave_m: how should a compiler know?
00:43:59 <int-e> dave_m: and it isn't, because it's not true for [_|_, _|_]
00:44:27 <dave_m> That's why I said when "length . sort" returns non-bottom
00:44:46 <int-e> right.
00:44:47 <roconnor> int-e: no the thing with deforestation is that you are interfaceing function between two separately developed modules.  The user cannot break the interface to peform the optimization themselves.
00:45:06 <dave_m> In GHC, you would specify a rewrite rule. More generally, a dependently typed system could show that sort leaves the length of a list unchanged
00:45:28 <roconnor> You can have modularity (leading to fewer bug) or you can optimize your code by hand and break modulairty.
00:45:56 <roconnor> This is why the optimizations have to be done at some other level.
00:48:18 <dave_m> roconnor: Have you read Boquist's "Code Optimisation Techniques for Lazy Functional Languages"?
00:48:26 <dave_m> http://www.cs.chalmers.se/~boquist/phd/index.html
00:48:29 <lambdabot> Title: Abstract, http://tinyurl.com/wozk2
00:50:04 <dave_m> his optimiser manages to do deforestation without any specific deforestation code
00:50:47 <int-e> roconnor: anyway, deforestation is not changing algorithms. it's the 'optimize bubble sort to quicksort' example that really scares me, because it changes the algorithm. And changing strictness (making functions less strict) is another thing that feels dirty to me, so I'd rather not see it from a compiler.
00:51:34 <musasabi> morning
00:51:52 * roconnor tries to come up with an optimization that GHC does that turns an exponential algorithm into a polytime algorithm.
00:53:01 <int-e> roconnor: btw, in case you're curious, my bad CSE example is this: http://hackage.haskell.org/trac/ghc/ticket/947 ... it turns an O(sqrt(n)) space behaviour into an O(n) space behaviour.
00:53:05 <lambdabot> Title: #947 (ghc -O space leak: CSE between different CAFs) - GHC - Trac, http://tinyurl.com/ws6vv
00:53:41 <Cale> http://en.wikipedia.org/wiki/Image:Euclidean_algorithm_running_time_X_Y.png
00:53:42 <roconnor> there are about a billion useful optimizations that make functions less strict.
00:53:43 <lambdabot> http://tinyurl.com/yy5w9g
00:55:06 <roconnor> int-e: yes, there is effectively no space control in haskell code.
00:55:40 <dibblego> I have a function that accepts a list that must be a length of at least one; I see I have three choices 1) data AtLeastOneList a | AtLeastOneList a [a] -- pass this instead 2) f [] = error "list must have length >= 1" 3) return Just a | Nothing instead of a , any more choices? and how do I choose which one?
00:56:47 <dave_m> dibblego: head and tail go with option 2
00:57:08 <dibblego> dave_m, I don't understand your point
00:57:20 <dibblego> oh now I do
00:57:34 <dibblego> the implementation of head and tail you mean select 2
00:58:02 <dave_m> dibblego: I was citing precedent for your second option
00:58:07 <dibblego> right thanks
00:58:43 <dave_m> dibblego: if you're confident that the function will only be called with non-empty lists, option #2 is the way to go
00:58:47 <dibblego> I was thinking I had to use head and tail to implement option 2 at first
00:58:50 <roconnor> Haskell 98 doesn't give space semantics I guess.
00:59:14 <Syzygy-> > head []
00:59:15 <lambdabot>  Add a type signature
00:59:20 <Syzygy-> > head [] :: [Int]
00:59:22 <lambdabot>  Exception: Prelude.head: empty list
00:59:28 <dibblego> right
00:59:29 <dave_m> it just puts an extra proof obligation on whoever calls the function
01:00:00 <dibblego> option 1 is much the same but is enforced by the compiler
01:00:08 <dave_m> There are techniques for enforcing that in the type system, but they're probably overkill
01:00:30 <roconnor> option 1 is bad.
01:00:39 <dibblego> why?
01:00:40 <roconnor> well, a little bad
01:00:49 <dibblego> why?
01:00:59 <roconnor> because you need to translate the type to lists when interfacing with other list functions.
01:01:04 <roconnor> that will take O(n) time.
01:01:07 <dave_m> option 1 works better with a newtype. Oleg Kiselyov has some writing on that subject
01:01:57 <int-e> roconnor: he only destructures the head of the list, not the whole list
01:01:58 <dibblego> f :: AtLeastOneList a -> [a] can be done pretty easily
01:02:11 <roconnor> dibblego: yes but f take O(n) time
01:02:20 <dibblego> why?
01:02:26 <dave_m> No, it's only O(1)
01:02:30 <roconnor> oh wait
01:02:36 <dibblego> AtLeastOneList = (:)
01:02:37 <roconnor> ah, my bad
01:03:06 <dave_m> better to go with a newtype, though. The conversion functions are O(0).
01:03:20 <dibblego> ok, I don't know newtype that well
01:03:39 <int-e> but newtype doesn't work with tuples :/
01:03:55 <int-e> oh
01:03:57 <roconnor> okay 1 isn't as bad as I thought, but I'm still partial to #3.
01:04:10 <int-e> do you mean a newtype with a smart constructor?
01:04:16 <roconnor> It allows the user to decide if they want to catch the error or not.
01:04:20 <dibblego> "Oleg Kiselyov has some writing on that subject" -- Number Parameterized Types?
01:04:32 <roconnor> although I'd use a generic monad instead of maybe.
01:04:33 <dave_m> yes, newtype NonEmptyList a = NEL [a]
01:04:54 <int-e> makeNEL [] = error ""; makeNEL as = NEL as
01:05:05 <sieni> is there a topic besides uigurian folk dances that oleg doesn't have any writing about?
01:05:10 <dave_m> then you have isNonEmpty :: r -> (NonEmptyList a -> r) -> [a] -> r
01:05:46 <roconnor> int-e: makeNEL a as = NEL (a:as)
01:05:55 <dave_m> that works too
01:06:03 <int-e> or makeNEL :: MonadPlus m => [a] -> m (NEL a)
01:06:08 <roconnor> otherwise you are just moving around the problem instead of solving it.
01:06:10 <Cale> I like the Maybe option.
01:06:11 <dave_m> The full idea is in "Lightweight Static Capabilities", http://okmij.org/ftp/papers/lightweight-static-capabilities.pdf
01:06:14 <lambdabot> http://tinyurl.com/y38r2n
01:06:27 <roconnor> [a] -> NEL a is just as bad as option 2
01:06:41 <int-e> roconnor: it shifts the point of error.
01:06:56 <roconnor> okay, maybe it is slightly better than option 2
01:06:59 <int-e> roconnor: although in Haskell ... that isn't really true :)
01:07:00 <kosmikus> options 2 and 3 are both fine with me. depends on the situation, really.
01:07:01 <dibblego> [a] -> Maybe NEL a
01:07:30 <roconnor> (Monad m) -> [a] -> m (NEL a)
01:07:36 <kosmikus> introducing a new datatype or even newtype is a bit too much, maybe.
01:07:51 <roconnor> using newtype is never too much :)
01:07:58 <dibblego> I'll read about newtype in YAHT
01:07:59 <int-e> what bikeshed are we building anyway?
01:08:18 <dave_m> much easier to go with a partial function, unless you have a lot of functions that take non-empty lists
01:08:25 <dave_m> and pass them around
01:09:53 <dave_m> Here's a shorter example, http://okmij.org/ftp/Haskell/types.html#branding
01:09:56 <lambdabot> Title: Haskell Programming: Types, http://tinyurl.com/uof2p
01:10:13 <dave_m> He's talking about eliminating Array bounds checks, but the idea works for non-empty lists as well
01:11:05 <dave_m> Again, it's overkill for a single list function
01:20:55 <dons> hehe, Conor McBride, "So, taking Void to be the colour of the empty bikeshed ..."
01:21:29 <dave_m> Wouldn't Void be the color of the bikes in the empty bikeshed?
01:22:14 <int-e> hmm hmm. void :: Warranty -> IO Void
01:22:34 <lispy> hehe
01:23:32 <dave_m> Interestingly, iraqiNukes :: [Void]
01:24:04 <dons> nthKoreanNukes :: Either Void [Nuke]
01:24:08 <lispy> dave_m: now if that were true why did the US attack them?
01:24:34 <lispy> dave_m: don't worry, i'm teasing
01:24:49 <dave_m> actually, that's a common question in the US
01:25:12 <lispy> dave_m: are you a USian too?
01:25:20 <dave_m> yes, and I am up way too late
01:25:25 * lispy too
01:25:31 <lispy> (on both accounts)
01:26:24 <lispy> but that doesn't stop me
01:26:43 <dave_m> it's stopping me, though. Good night, all
01:27:49 <lispy> night
01:29:33 <Lajexander> heh, this is exam week at school, so on saturday we'll have a "Clear Memory Pub"
01:29:44 <dibblego> a newtype can only have one constructor argument - how will that help my data AtLeastOneList a | AtLeastOneList a [a] ?
01:30:08 <int-e> dibblego: [10:04:11] <dave_m> yes, newtype NonEmptyList a = NEL [a]
01:30:38 <dibblego> int-e, I don't see how that will help
01:30:46 <int-e> dibblego: the idea is to have a smart constructor to create it, that will never accept empty lists. it's not perfect - it doesn't help the compiler.
01:30:55 <dibblego> int-e, ah ok thanks
01:31:53 <dons> dibblego: when are you giving your talk, btw?
01:32:00 <dons> how long do I have to get the review done :)
01:32:03 <dibblego> what talk?
01:32:13 <lispy> what about data NEL a = One a | Cons a (NEL a) ?
01:32:27 <dibblego> it's just an article that I will publish on our website
01:32:44 <dibblego> as soon as you can - but don't feel pressure
01:32:58 <int-e> dibblego: what is that weird data syntax anyway?
01:33:16 <int-e> lispy: that's bad if you want to translate back and forth betwenn 'normal' lists
01:33:17 <dibblego> int-e, my noobness :)
01:33:31 <dibblego> data AtLeastOneList a = AtLeastOneList a [a]
01:33:41 <int-e> lispy: and non-empty lists.
01:34:05 <dons> dibblego: ah right.
01:34:20 <int-e> dibblego: I think this is ok actually. It does help the compiler and should be inlined in most cases so it's just as fast as the newtype.
01:34:59 <dibblego> int-e, YAHT claims performance problems because of the pointer
01:35:13 <lispy> if you're just going to convert between empty list and non-empty list what is the real value of this non-empty list?
01:35:37 <int-e> dibblego: but the cons cell (:) you would have otherwise has those pointers, too.
01:36:07 <int-e> lispy: shifting the errors to another point in the program.
01:36:20 <dibblego> lispy, let the client resolve the issue
01:36:23 <int-e> lispy: that would be a reason for me at least.
01:36:37 <dibblego> lispy, I hate error - I think it's horrible
01:36:46 <lispy> int-e: okay, that's the first time i've heard a reason for it that i have to think about :)
01:36:57 <lispy> dibblego: what do you mean let the client resolve the issue?
01:37:28 <dibblego> lispy, if the client has an empty list, then they have a contradiction with the function that accepts a type AtLeastOneList -- they need to resolve it
01:39:02 <int-e> lispy: basically you can force the caller to explicitely state an assertion that the list is nonempty, instead of making it implicit in calling your function.
01:40:05 <lispy> ESC will be nice, i bet it will handle many of these
01:40:24 <int-e> lispy: btw, I'm not sure if I would do that. but it's a reason to think about.
01:40:32 <lispy> i find that the time post/pre-conditions really bite me is when i didn't think about them
01:40:47 <dons> we shoudl get the ESC src out and finish it off
01:40:49 <dons> where's the repo?
01:40:52 <int-e> what is ESC?
01:41:13 <dons> extended static checking, Dana Xu, paper at the Haskell Workshop this year
01:41:19 <int-e> I think dons really wants to fix hs-plugins for ghc 6.6 ;)
01:41:25 <lispy> dons: what Xu (is that how you spell it?) had at the workshop was just a prototype that assumed a type correct program and then called an external theorem prover
01:41:33 * dons really wants to fix hs-plugins for ghc 6.6
01:41:49 * lispy notes that int-e has jedi mind powers
01:42:00 * dons can feel the force
01:42:30 <lispy> iirc, Xu said it was maybe a couple years out actually
01:42:48 <lispy> just because they want to see how much it can do in practice and so on
01:44:38 <lispy> since there is some undecibability to deal with
01:44:39 <dons> hmm.
01:44:39 <lispy> basically, if it says "No problems" then no problems,  if it says "Maybe" then you don't know
01:44:39 <dons> maybe the isabelle tools from the L4 kernel work will be available sooner
01:44:39 <lispy> either way, ghc 7.0 will be interesting times in haskell land
01:44:39 <dons> I'm looking forward to 6.8's parallel gc on multicores
01:44:39 <lispy> by then we ought to have ATs, HPC, maybe ESC and some other goodies
01:44:39 <lispy> oh yeah, that too
01:44:40 <dons> truly non stop haskell
01:45:03 <lispy> now if only it didn't have such a huge learning curve
01:45:14 <dons> yeah, i can't think of a language growing so quickly
01:45:21 <lispy> i mean, when its all said and done, you know that's a HUGE reason it doesn't get wide acceptance
01:45:31 <dons> these are really high-end features that seem to appear on an almost weekly basis
01:45:45 <dons> yeah, theorems are hard
01:45:52 <dons> types are too hard for most people...
01:46:28 <lispy> building a compiler myself lately i'm realizing why so much of haskell isn't in the backend and code generation...there's not much you can do to code generation before you're kinda done.  But you can add theorems and prove things all day long in the front end
01:46:36 <dons> heh, headline on .au newspaper (talk about sterotypes) "Beer lost in truck smash
01:46:54 <lispy> heh
01:47:34 * lispy only knows one .au beer and that's Fosters and i've heard its analogous to our coors and so won't touch it :)
01:47:46 <dibblego> Foster's is Canadian
01:47:53 <dons> its not drunk in .au, afaik
01:47:57 <lispy> hehe
01:48:01 <lispy> stupid adverts
01:48:07 <dons> dibblego: it is?
01:48:12 <dibblego> you can buy it "if there is any out the back"
01:48:26 <dibblego> yes it was bought by a Canadian company in the 90's (vague recollection)
01:48:30 <dons> ah
01:48:31 <Bobstopper> 26 years in Aus and the only place I've ever seen Fosters is on American TV.
01:48:52 <lispy> so what is good beer in Aus?
01:48:58 <dibblego> I haven't seen anyone drinking it since the early-mid 90;s
01:49:03 <lispy> here it's all about microbrew
01:49:04 <Bobstopper> does anyone know how to set the cell renderer of a ComboBox?
01:49:16 <Bobstopper> I wouldn't know - I don't drink the crap :)
01:49:23 <dibblego> XXXX is 5 minutes from my work
01:49:33 <dibblego> but that's a Queenslander beer (every other state hates it)
01:49:35 <lispy> quadruple equis?
01:49:41 <Bobstopper> (my question is related to gtk2hs btw)
01:49:47 <dons> lispy: there's lots! though the microbrew scene isn't so big. Coopers is popular in inner sydney (comes all yeasty)
01:49:48 <dibblego> Toohey's or anything from CUB up the east coast
01:49:51 <kfish> dibblego, i think fosters is still owned by fosters: http://www.fosters.com.au/enjoy/beer.htm
01:49:52 <lambdabot> Title: Beer
01:49:58 <lispy> Bobstopper: i bet its something like renderer := foo
01:49:59 <kfish> onya lambdabot
01:50:11 <dons> hehe
01:50:17 <dons> that's cool
01:50:17 <Bobstopper> lispy: ok, I'll look for something like that. Thanks.
01:50:18 <dibblego> kfish, I might have to revisit what I am talking about
01:50:18 <roconnor> > case (undefined::Bool) of { x -> True }
01:50:20 <lambdabot>  True
01:50:45 <kfish> dibblego, better to let it pass
01:50:55 <kfish> in any case, afaik fosters is brewed under license in various parts of the world
01:51:08 <lispy> Bobstopper: gtk2hs and wxhaskell seem to both use lists of properties so you'll see things lke [ text := "my message", visible := True ]
01:51:13 <kfish> i wouldn't be surprised if not much is brewed in .au at all :-)
01:51:48 <Bobstopper> lispy: Yeah, I'd seen that. I just hadn't come accross anything like that for ComboBoxes yet - though I wasn't looking for it.
01:51:53 <lispy> Bobstopper: and that's my extent of knowledge with gtk2hs :)
01:52:22 <lispy> Bobstopper: i'll try tho new haskell search
01:52:37 <lispy> http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-TreeList-CellRenderer.html#t%3ACellRenderer
01:52:41 <lambdabot> http://tinyurl.com/t72k6
01:52:49 <lispy> http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-TreeList-CellRenderer.html#t%3ACellRenderer
01:52:50 <lambdabot> http://tinyurl.com/t72k6
01:52:51 <lispy> oops
01:53:04 <lispy> cellRendererSet :: CellRendererClass cr => cr -> Attribute cr val -> val -> IO ()
01:53:27 <lispy> oh sohot
01:53:28 <Bobstopper> Yeah, but after I've got a CellRenderer, how do I get a ComboBox using it?
01:53:30 <lispy> that's a Treelist
01:53:59 <lispy> theer is a toCellRenderer?
01:54:46 <lispy> Bobstopper: realisticly we probably need dcoutts
01:54:53 <lispy> ?seen dcoutts
01:54:54 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 6h 39m 37s ago.
01:55:07 <Bobstopper> Hmm... I don't think that's what I want. I've got a CellRenderer object and a ComboBox object. I need the ComboBox object to use the CellRenderer object for rendering stuff.
01:55:13 <Bobstopper> Yeah, I think so...
01:55:23 <Bobstopper> thanks anyhoo!
01:55:38 <lispy> yw, wish i knew more
01:55:48 <lispy> and i really mean that because i'd like to use haksel lfor guis :)
01:56:20 <lispy> why is the ComboBox module under MenuComboToolBar?
01:56:29 <Bobstopper> I'd like to know that too :)
01:56:47 <lispy> oh it's in the GObjectClass
01:56:53 <lispy> the combobox is
01:57:02 <lispy> and we saw something about GObjectCLass on that cell render page
01:58:08 * Bobstopper gets confused by MVC designs
01:58:11 <Bobstopper> anyway, bbl
01:59:58 <TSC> Is there an already defined way to, say, add tuples so that (1,1) + (2,3) == (3,4) ?
02:00:09 <dons> yeah
02:00:13 <lispy> ?type (****)
02:00:14 <lambdabot> Not in scope: `****'
02:00:15 <dons> now, let me see..
02:00:17 <lispy> ?type (***)
02:00:19 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:00:40 * lispy can't remember how either
02:01:02 <lispy> > liftM2 (+) (1,1) (2,3{
02:01:02 <lambdabot>  Parse error
02:01:03 <lispy> > liftM2 (+) (1,1) (2,3)
02:01:04 <lambdabot>  add an instance declaration for (Monad ((,) a))
02:01:05 <lambdabot>   In the definition of `m...
02:01:11 <int-e> > curry ((uncurry (+)) *** (uncurry (+))) (1,1) (2,3)
02:01:13 <lambdabot>  (2,5)
02:01:23 <int-e> not quite, eh?
02:01:43 <dons> ?pl curry ((uncurry (+)) *** (uncurry (+)))
02:01:44 <lambdabot> curry (uncurry (+) *** uncurry (+))
02:01:46 <dons> boo
02:01:58 <lispy> dons: it got the wrong answer anyway
02:02:15 <lispy> dons: it seems to have added inside the tuples
02:02:24 <int-e> it did
02:02:45 <TSC> Maybe I'll do it by hand (:
02:02:51 <dons> > (toUpper *** toLower) ('a','A')
02:02:52 <lambdabot>  ('A','a')
02:02:56 <int-e> TSC: yes, that will be good ;)
02:02:59 <lispy> maybe &&&?
02:03:30 <lispy> ?type ap
02:03:33 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
02:03:43 <lispy> ?type (&&&)
02:03:43 <int-e> @type (+) *** (+)
02:03:44 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:03:45 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
02:05:18 <TSC> applyToPair :: (a -> b) -> (a,a) -> (b,b)
02:05:19 <TSC> applyToPair f (a,b) = (f a, f b)
02:05:23 <TSC> That will do for me
02:05:25 <dons> he
02:05:31 <dons> but you must use arrows!
02:05:45 <ValarQ> :)
02:05:49 <TSC> There are arrows!
02:05:52 <TSC> a -> b
02:05:55 <TSC>   ^^
02:05:57 <ThreeQ> ?pl f (a, b) = (f a, f b)
02:05:58 <lambdabot> f = fix ((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)))
02:06:06 <ThreeQ> oh my
02:06:15 <TSC> I'll stay with pointy form
02:06:16 <dons> lambdabot scares me sometimes
02:06:33 <lispy> whoa
02:06:34 <lispy> fix?
02:06:42 <lispy> oh
02:06:46 <ValarQ> thats a nice function
02:06:46 <dons> i think it must have bound the results?
02:06:47 <lispy> pl doesn't l ike =?
02:06:55 <dons> ah yes. that's it
02:07:02 <dons> recursive bindings
02:07:10 <ThreeQ> oh whoops
02:07:18 <lispy> ?pl \f (a,b) -> (f a, f b)
02:07:19 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
02:08:39 <lispy> ?type (+) (&&&)
02:08:41 <lambdabot> forall (a :: * -> * -> *) b c c'. (Num (a b c -> a b c' -> a b (c, c')), Arrow a) => (a b c -> a b c' -> a b (c, c')) -> a b c -> a b c' -> a b (c, c')
02:08:50 <lispy> ?type ((+) &&&)
02:08:51 <lambdabot> forall b c'. (Num b) => (b -> c') -> b -> (b -> b, c')
02:09:06 <lispy> ?type (+) &&& (+)
02:09:08 <lambdabot> forall b. (Num b) => b -> (b -> b, b -> b)
02:09:32 <lispy> ?type ((+) &&& (+)) 3
02:09:34 <lambdabot> forall b. (Num b) => (b -> b, b -> b)
02:09:46 <dons> hmm, interesting "Invalid URL passed. Possible shell exploit attempted!"
02:09:52 <dons> sometimes my rss reader plays funny games
02:13:19 <int-e> @pl \(a, b) -> ((+) *** (+)) >>> (($ a) *** ($ b))
02:13:20 <lambdabot> uncurry (((((+) *** (+)) >>>) .) . (. flip id) . (***) . flip id)
02:14:07 <int-e> @pl \(a, b) -> (($ a) *** ($ b)) . ((+) *** (+))
02:14:08 <lambdabot> uncurry (flip flip ((+) *** (+)) . ((.) .) . (. flip id) . (***) . flip id)
02:15:07 <int-e> @pl \(a,b) (c,d) -> (a+c, b+d)
02:15:09 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
02:15:22 <profmakx> pl is evil
02:15:24 <ThreeQ> ?pl \a -> ($ a)
02:15:24 <lambdabot> flip id
02:15:42 <int-e> ($) = id
02:15:51 <ThreeQ> ?type ($)
02:15:53 <lambdabot> forall b a. (a -> b) -> a -> b
02:15:56 <int-e> up to the type
02:15:59 <ThreeQ> oh, it is!
02:17:02 <lispy> > (\(a, b) -> ((+) *** (+)) >>> (($ a) *** ($ b))) (1,2) (3,4)
02:17:03 <lambdabot>  (4,6)
02:17:17 <lispy> wow, that's complicated
02:19:14 <lispy> i wonder if it would just be easier to use complex numbers
02:19:31 <lispy> > (1 :+ 2) + (3 :+ 4)
02:19:32 <lambdabot>  4.0 :+ 6.0
02:19:34 <int-e> > (\(a, b) -> ((a +) *** (b +))) (1,2) (3,4)
02:19:36 <lambdabot>  (4,6)
02:19:47 <int-e> @pl \(a, b) -> ((a +) *** (b +))
02:19:48 <lambdabot> uncurry ((. (+)) . (***) . (+))
02:19:58 <int-e> now that is beginning to look reasonable.
02:20:03 <lispy> yeah
02:20:27 <lispy> i forget, why does haskell only have complex numbers over the reals?
02:20:40 <int-e> @type (. (+))
02:20:40 <lispy> why not the complex rationals or integers?
02:20:42 <lambdabot> forall a c. (Num a) => ((a -> a) -> c) -> a -> c
02:20:46 <Lor> The arrow instances for plain functions are darn useful.
02:21:29 <lispy> they're numbers too!
02:21:38 * lispy goes into a frenzie
02:22:23 <lispy> ?type f &&& g >>> arr (\ (y, z) -> y + z)
02:22:25 <lambdabot> Not in scope: `f'
02:22:25 <lambdabot>  
02:22:25 <lambdabot> <interactive>:1:6: Not in scope: `g'
02:22:33 <lispy> ?type \f g -> f &&& g >>> arr (\ (y, z) -> y + z)
02:22:34 <lambdabot> forall b c' (a :: * -> * -> *). (Arrow a, Num c') => a b c' -> a b c' -> a b c'
02:23:23 <lispy> > (\f g -> f &&& g >>> arr (\ (y, z) -> y + z)) (arr 1) (arr 2)
02:23:24 <lambdabot>  add an instance declaration for (Show (a b c))
02:23:37 <Lor> Just about all function combinators could (imho should) be made into arrow combinators, with functions as a particular instance.
02:24:39 <lispy> > (\f g -> f &&& g >>> arr (\ (y, z) -> y + z)) 1 2
02:24:40 <lambdabot>  add an instance declaration for (Num (a b c'))
02:25:36 <lispy> i really don't get that function
02:26:55 <int-e> > (\f g -> f &&& g >>> arr (\ (y, z) -> y + z)) (+1) (*3) 4
02:26:57 <lambdabot>  17
02:27:51 <int-e> looks a bit like liftM2
02:27:57 <lispy> why does it take sections (or how did you know it did)?
02:28:00 <int-e> > liftM2 (+) (+1) (*3) 4
02:28:01 <lambdabot>  17
02:28:19 <lispy> that must be the reader?
02:29:09 <JaffaCake> dons: how about a link from ghc's WorkingConventions page to your library policy page?
02:29:21 <dons> i already linked the other way :)
02:29:24 <dons> but it could go both ways
02:29:41 <JaffaCake> something like "if you are considering changes to standard libraries, then see [this page]"
02:29:47 <dons> ah yes.
02:29:52 <dons> yep. good idea.
02:30:05 <JaffaCake> ok, will do
02:32:15 <JaffaCake> done
02:32:40 <dons> great
02:33:05 <dons> re. Trac, I wonder if it is possible to make sub-namespaces, so we can reuse the existing Trac install for other haskell projects
02:33:49 <dons> so anyone could get bug tracking on their haskell project
02:33:50 <JaffaCake> we can reuse the install, but you have to create a new instance
02:34:02 <JaffaCake> I can create new instances pretty easily
02:34:17 <JaffaCake> indeed we already have several
02:34:18 <dons> ok.
02:51:14 <Bobstopper> aha... judging by http://www.mail-archive.com/haskell@haskell.org/msg19111.html it looks like what I'm trying to do with the cell renderers isn't yet supported in gtk2hs. I'll try the other option suggested. FYI if you're interested, lispy :)
02:51:16 <lambdabot> Title: Re: [Haskell] Problem with comboBox, http://tinyurl.com/yy3bpn
02:54:37 <roconnor> int-e: my friend put it best when he said that evalutating a bottom value is a programming error, therefore these programs should be excluded from the domain when considering whether to apply an optimization.
02:55:06 <roconnor> I believe this implies that it is mostly safe to make functions less strict.
02:56:05 <roconnor> at least safe from a semantic point of view.
02:57:25 <Cale> well, it does make the semantics of the language harder to describe
02:59:38 <roconnor> how about: ``the result of evaluating bottom is undefined''
02:59:57 <roconnor> or ``notwithstanding the rest of this report, the result of evaluating bottom is undefined''
03:02:58 <Cale> hmm
03:03:27 <Cale> I suppose that sort of works
03:04:21 <Cale> Relying on any behaviour which resulted from an optimisation making things more defined would make your programs non portable though
03:05:09 <Cale> and subject to future bugs introduced as a result of changing the optimisation passes in the compiler
03:05:55 <Cale> I sort of agree with you, but I can also see why you'd want to be careful about it
03:14:36 <Sara|Uni> hello there!
03:15:04 <Sara|Uni> stupid question -- I can't seem to find a "left shift" as an operator
03:15:09 <Sara|Uni> doesn't that exist for haskell?
03:15:32 <SamB> @docs Data.Bits
03:15:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
03:15:53 <SamB> Sara|Uni: look there ;-)
03:18:28 <dons> > 1 `shiftL` 4
03:18:29 <lambdabot>  Add a type signature
03:18:31 <dons> > 1 `shiftL` 4 :: Int
03:18:33 <lambdabot>  16
03:18:39 <araujo> morning
03:19:01 * SamB is barely awake, so not likely at his most helpful ;-)
03:19:17 <Sara|Uni> hmmm
03:19:39 <dons> Sara|Uni: welcome! are you the Sara who's written a few mails to the haskell mailing list?
03:19:42 <Cale> takeWhile (/= 0) . iterate (`shiftL` 1) $ 1
03:19:46 <Cale> > takeWhile (/= 0) . iterate (`shiftL` 1) $ 1
03:19:48 <lambdabot>  Add a type signature
03:19:48 <Sara|Uni> nope, haven't sorry
03:19:51 <Cale> > takeWhile (/= 0) . iterate (`shiftL` 1) $ 1 :: Int
03:19:52 <SamB> at least my eyes are beginning to stay open ;-)
03:19:53 <lambdabot>  Couldn't match `Int' against `[a]'
03:19:59 <Cale> > takeWhile (/= 0) . iterate (`shiftL` 1) $ (1 :: Int)
03:19:59 <SamB> Sara|Uni: you don't have to apologise
03:20:00 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
03:20:25 <dons> Sara|Uni: also, for finding functions Hoogle is useful, http://haskell.org/hoogle
03:20:27 <lambdabot> Title: Hoogle
03:20:31 <Sara|Uni> well, thanks samB
03:20:45 <urtie> @hoogle (a -> Bool) -> [a] -> Bool
03:20:46 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
03:20:46 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
03:20:47 <araujo> anybody knows a good paper for reading about changing global (variables) states?
03:20:55 <Sara|Uni> it's in my bookmarks now
03:20:58 <dons> araujo: hmm. one of the early state monad papers?
03:21:03 <Sara|Uni> my documentation didn't include shift :/
03:21:09 <araujo> dons, such as?
03:21:10 <dons> ?hoogle shift
03:21:11 <lambdabot> Data.Bits.shift :: Bits a => a -> Int -> a
03:21:11 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
03:21:11 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
03:21:12 <Cale> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
03:21:14 <lambdabot> http://tinyurl.com/y8kr9v
03:21:15 <dons> ah. good hoogle :)
03:21:33 <SamB> Cale: I already mentioned that
03:21:34 <Sara|Uni> thanks for the info
03:22:00 <dons> araujo: hmm. the early monad papers, talking about how to do imperative programming
03:22:15 <Cale> yes you did, I'm tired :)
03:22:15 <dons> e.g. State in Haskell
03:22:27 <dons> and others http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Monads
03:22:29 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/ybgllq
03:22:57 <dons> I wish there were more Haskell bloggers. Cale, why don't you write blog articles ? :)
03:23:09 <dons> I'm tired of the boring ruby articles...
03:23:25 <dons> gimme some _hard_ problems solved with nice code, any day.
03:23:28 <SamB> Cale: :-)
03:23:35 <dons> ?localtime Cale
03:23:37 <lambdabot> Local time for Cale is Wed Oct 25 06:18:54
03:23:38 <dons> ?localtime SamB
03:23:40 <lambdabot> Local time for SamB is Wed Oct 25 06:23:29
03:23:43 * SamB looks for yawny emoticon
03:23:43 <Cale> My blog is intentionally left blank :)
03:23:59 <dons> boo
03:24:02 <SamB> D-|
03:24:07 <Cale> http://cgibbard.livejournal.com/
03:24:23 <SamB> the | represents the barely-open eyes ;-)
03:24:43 <dons> hey, at least there's a photo!
03:25:12 * SamB thought Cale had a wiki, not a blog
03:25:28 <Cale> I do
03:25:31 <dons> heh, it even got a comment.
03:25:37 <dons> "Hello Mr. Blank.  .."
03:26:01 <Cale> http://cale.yi.org/index.php/Main_Page
03:26:35 <Cale> I should perhaps make a point to contribute to my own website.
03:26:48 * araujo searches
03:26:55 <SamB> heh
03:27:05 <SamB> that sounds really funny ;-)
03:28:04 <dons> i guess the issue is that new Cale articles dont' get into the blogosphere
03:28:19 <Sara|Uni> Well, ok, another one:
03:28:30 <Cale> Words like blogosphere are exactly the reason they don't :)
03:28:36 <Sara|Uni> Can you tell me a resource that lists how functions are defined?
03:28:36 <dons> Cale: :P
03:28:45 <Sara|Uni> eg. I'd like to know how they compute sqrt
03:28:49 <Cale> hmm
03:28:54 <Cale> @source Prelude
03:28:55 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
03:28:59 <dons> ?where yaht
03:28:59 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
03:29:05 <dons> ^^ is a good tutorial to start with
03:29:17 <Cale> hmmm
03:29:20 <dons> (you looking for a haskell introductory tutorial?)
03:29:26 <Cale> @source GHC.Float
03:29:27 <lambdabot> GHC.Float not available
03:29:35 <Sara|Uni> I'm not searching for a tutorila
03:29:35 <dons> Sara|Uni: or you mean you want to see the library source?
03:29:37 <Sara|Uni> tutorial
03:29:50 <Sara|Uni> see... my sqrt-fct takes about 1k to 2k reductions
03:30:03 <Cale> sqrtDouble   (D# x) = D# (sqrtDouble# x)
03:30:03 <Sara|Uni> but the built in one takes ... dunno maybe 30 to 50
03:30:10 <Cale> looks primitive
03:30:15 <dons> ah, I see.
03:30:16 <Sara|Uni> dons: library source
03:30:29 <dons> Sara|Uni: yeah, the library source. you can find it with the @source command, as Cale did.
03:30:32 <dons> ?source Data.Bits
03:30:33 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
03:30:35 <Cale> the built in one is probably calling a function defined in some C library
03:30:43 <Sara|Uni> hehe
03:30:44 <Sara|Uni> nasty
03:30:59 <dons> yeah, that'd be a call into GMP, Cale.
03:31:11 <dons> or maybe just a C function, hmm.
03:31:22 <Cale> I didn't know GMP did floating point things
03:31:26 <Cale> but possibly
03:31:41 <dons> yeah, or could be a C fragment in the runtime
03:31:51 <SamB_XP> dons: sqrt is *not* in Data.Bits
03:32:05 <Cale> dons: it seems that @source chokes on GHC.*
03:32:11 <dons> Cale: yep.
03:32:27 <SamB_XP> yeah, probably because they aren't haddock-visible?
03:32:43 <dons> Cale: the annoying thing about wiki vs rss/blog, is that I can't subscribe ..
03:33:03 <dons> so my little harvester for building HWN entries is blind to Cale-world
03:33:49 <Cale> http://cale.yi.org/index.php?title=Special:Recentchanges&feed=rss
03:33:52 <lambdabot> http://tinyurl.com/sm635
03:33:59 <dons> very good.
03:34:16 <Cale> heh, I'm running MediaWiki
03:34:17 <dons> not quite planet.haskell.... but it'll do
03:34:45 <Cale> though basically the one thing you can count on is that new content I create hardly ever goes there :)
03:34:55 <dons> heh
03:36:32 <araujo> ok, thanks dolio
03:36:33 <araujo> ahg
03:36:35 <araujo> dons,
03:36:47 <araujo> i think that State tuto will help
03:47:50 * araujo off to univ
03:49:54 <roconnor> <Cale> Relying on any behaviour which resulted from an optimisation making things more defined would make your programs non portable though
03:50:25 <roconnor> I agree, the problem is that requiring that strictness of functions is invarient prevents various optimisations.
03:50:37 <Cale> right
03:50:39 <Cale> I know :)
03:50:46 <roconnor> So I think these optimisations ought to be allowed, but you should, of course, not rely on them to make your program terminate.
03:51:11 <SamB_XP> well, the compiler should urge you to test your program with them off ;-)
03:51:13 <Cale> It's just that people might test their code and have it work in one compiler, and not in another
03:51:27 <SamB_XP> like, punch you if you refuse ;-)
03:51:45 <Igel> hi there
03:51:49 <Cale> hi
03:51:52 <flux-_> so, the compiler could produce diagnostics "this and this optimization was used, test your program with them disabled to ensure portability"?
03:51:57 <Igel> i got a question about pattern matching
03:52:04 <Cale> okay
03:52:09 <Igel> is it possible to apply pattern matching to type constructors?
03:52:16 <Igel> i got a data structure like
03:52:34 <Igel> data Meier = Meier | Pasch Int | Zahl Int
03:52:42 <roconnor> Cale: oh no, haskell development would be like web development.
03:52:44 <Igel> and i want to implement Ord
03:52:46 * SamB_XP doesn't read german
03:52:52 <Igel> so Meier > Pasch > Zahl
03:53:10 <Igel> but:
03:53:23 <Igel> Pasch n <= Pasch m <=> n <= m
03:53:26 <Igel> and
03:53:34 <Cale> hehe, you could write them in the opposite order and add deriving Ord
03:53:35 <Igel> Zahl n <= Zahl m <=> n <= m
03:53:40 <SamB_XP> yeah
03:53:44 <dons> or write your own Ord instance
03:53:56 <Cale> instance Ord Meier where
03:54:01 <int-e> data Meier = Zahl Int | Pasch Int | Meier deriving Ord  should do the right thing I think.
03:54:08 <int-e> am I wrong?
03:54:17 <Cale> int-e: yes
03:54:21 <Cale>   Meier < x = True
03:54:22 <Igel> int-e: i'll just test it
03:54:23 <Igel> wait a sec
03:54:58 <Cale> but you can pattern match against data constructors
03:55:06 <int-e> anyway, being able to define your own Ord instance is useful :)
03:55:25 <Cale> er
03:55:33 <Cale> Meier > x = True, rather :)
03:55:54 <Cale> and you can write things like
03:55:55 <Igel> int-e: it works perfectlsy
03:55:56 <int-e> you mean >=, Cale
03:55:58 <Igel> thanks
03:56:01 <Cale> I do
03:56:11 <Cale>   (Zahl n) >= (Zahl m) = n >= m
03:56:26 <Cale> but yeah, deriving Ord is a lot nicer :)
03:57:27 <Igel> Cale: i had it like this before
03:57:36 <Igel> but it took 6 lines of code
03:57:38 <Igel> ;)
03:58:36 <Igel> http://paste.lisp.org/display/28657
03:59:14 <Igel> and regarding the similarity of the lines dealing with Zahl and Pasch, i was wondering, if it could be distinguished via pattern matching
03:59:33 <Igel> x n <= x m = n <= m
03:59:46 <Igel> for x <- [Pasch,Zahl]
04:00:20 <int-e> no.
04:00:39 <Igel> ok
04:00:49 <Igel> but deriving (Ord) is a lot nicer anyway
04:03:18 <SamB_XP> Igel: that is nice math, but Haskell is not as smart as mathemeticians ;-)
04:04:05 <SamB_XP> also it isn't valid Haskell syntax
04:04:26 <Igel> i know it isnt the correct syntax
04:04:37 <Igel> it was only about the idea :)
04:05:14 <Igel> anyway, i'm still learning haskell
04:05:19 <SamB_XP> yeah
04:05:54 <Igel> and it is the only language i learned where i see a chance of being able to do such pattern matching^^ :)
04:06:50 <Igel> i mean even [ m n | m <- [Pasch,Zahl], n <-[1..6] ] is valid syntay, isn't it?
04:07:11 <int-e> yes.
04:07:12 <Igel>  /s/syntay/syntay
04:07:15 <Igel>  /s/syntay/syntax
04:07:59 <int-e> and it works because Pasch and Zahl have the same type
04:08:36 <Igel>  :: Int -> Meier
04:08:57 <roconnor> Pasch and Zahl aren't patterns, but they are functions in that list comprehension case.
04:09:16 <roconnor> It is confusing because sometimes constructer names are patterns, and sometimes they are functions.
04:09:32 <Ulfalizer> is there some function in hugs or ghc for finding what classes an object is a member of?
04:09:40 <Ulfalizer> +out
04:10:02 <dmhouse> Ulfalizer: :info might do it
04:10:10 <Igel> can't lambdabot do that? :)
04:10:10 <roconnor> Prelude> :i Integer
04:10:16 <roconnor> instance Enum Integer   -- Imported from GHC.Num
04:10:16 <roconnor> instance Eq Integer     -- Imported from GHC.Num
04:10:19 <roconnor> ...
04:10:22 <dmhouse> Igel: it can do the reverse.
04:10:22 <Ulfalizer> ah, thanks
04:10:24 <dmhouse> ?instances Eq
04:10:25 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
04:10:59 <Igel> ok
04:11:01 <therp> is there a way to use an Eq object in pattern matching? I would like to replace a match against String with a match against FastString but don't want to do explicit == checks all the time.
04:11:16 <dmhouse> therp: guards.
04:11:21 <dons> FastString?
04:11:24 <dmhouse> Or use the literal string in the pattern.
04:11:26 <dons> or byteString?
04:11:30 <Igel> anyway: i'm gonna go eat something now
04:11:35 <Igel> thanks all of you
04:11:38 <therp> dons: FastString as in GHC FastString
04:11:49 <dmhouse> > let x "foo" = True; x _ = False in x "blah"
04:11:50 <dons> therp: but no, you can't pattern matchin on bytestrings or faststrings, they're opaque
04:11:51 <lambdabot>  False
04:12:12 <Lor> Why doesn't haskell have views yet?
04:12:21 <dmhouse> > let x s | s = "foo" = True | otherwise = False in x "blah"
04:12:22 <lambdabot>  Parse error
04:12:28 <dmhouse> > let x s | s == "foo" = True | otherwise = False in x "blah"
04:12:30 <lambdabot>  False
04:12:38 <therp> dmhouse: I though of guards, but that's rather explicit too. I wanted to retain the nice funname "somelit" = def style
04:12:38 <dmhouse> Of course, in this instance it simplified:
04:12:39 <Lor> GHC supports a gazillion extensions, but views (as an idea) have been around for over ten years...
04:12:52 <dmhouse> > let x = (=="foo") in x "blah"
04:12:54 <lambdabot>  False
04:13:23 <dmhouse> therp: the two methods I showed work pretty well
04:13:24 <therp> hmm, what's (=="foo") ?
04:13:28 <dmhouse> A section.
04:13:35 <therp> ah right!
04:13:44 <dmhouse> (=="foo") is another way of writing \s -> s == "foo"
04:14:02 <dons> Lor: pattern guards give us enough, it is felt.
04:14:12 <dons> maybe thta's changing with the emergence of bytestring
04:14:14 <therp> I know, I just didn't recognize it visually
04:14:20 <dons> where Views would actually be useful
04:14:39 * dcoutts concurs
04:15:01 <dons> there hasn't previously been a widely used type lacking pattern matching, which woudl benefit from Views, until now
04:15:01 <dmhouse> It's been proposed for Haskell' that prefix string matches be allowed, akin to n+k patterns.
04:15:16 <SamB_XP> eww
04:15:19 <dons> dmhouse: it has? didn't see that.
04:15:28 <dcoutts> dons, there was inductive graphs
04:15:39 <dons> mm. yeah. that's a good case.
04:15:42 * SamB_XP votes -1 unless there are views involved, in which case he votes +1
04:17:14 <dmhouse> http://article.gmane.org/gmane.comp.lang.haskell.prime/1744
04:17:19 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/y5eoe6
04:17:54 <dcoutts> dons, if we want, we can actually make a packed string type with O(1) cons.
04:18:04 <dcoutts> it'd be a tad more expensive
04:18:13 <dcoutts> in terms of memory use.
04:18:21 <dons> oh?
04:18:32 <dcoutts> just build in the StringBuilder idea
04:18:32 <dons> string builder or some such?
04:18:37 <dons> right
04:18:48 <dcoutts> but not as a separate datatype
04:19:06 <dcoutts> and do prepend rather than append
04:19:42 <dcoutts> the cost of course is in keeping the free space and the extra length and IORef
04:20:20 <dons> right
04:20:28 <dcoutts> it'd be an extra shared word, and extra unshared word and whatever free space
04:21:16 <dmhouse> ?tell shapr his HAppS wiki is down.
04:21:17 <lambdabot> Consider it noted.
04:21:24 <dcoutts> and to guarantee O(1) all the time it'd need to be lazy bytestrings
04:21:38 <dcoutts> so that instead of copying old chunks, you just make a new chunk
04:22:42 <roconnor> help, stack overflows!
04:22:47 <roconnor> \o/
04:23:29 <Cale> roconnor: in what code?
04:23:45 <roconnor> Hard to tell. I have my suspect
04:23:57 <roconnor> @paste
04:23:57 <lambdabot> http://paste.lisp.org/new/haskell
04:24:28 <lisppaste2> roconnor pasted "suspicous code" at http://paste.lisp.org/display/28658
04:25:39 <jmmv> hi
04:25:42 <Cale> The $! there ought to prevent a stack overflow
04:25:48 <Cale> jmmv: hi
04:25:58 <int-e> > let t n | n == 0 = 0 | otherwise = succ $! t (n-1) in t 1000000
04:26:00 <lambdabot>  1000000
04:26:01 <SamB_XP> oh
04:26:23 * SamB goes to define "on" in Data.List, because perfectionists will not be tolerated
04:27:04 <int-e> 'on' is too short :/
04:27:13 <SamB> what do you mean?
04:27:26 <SamB> it is a lot shorter a name than its definition!
04:27:43 <dmhouse> SamB: what does it do?
04:27:50 <ndm> roconnor: just about to fix your bug report
04:27:57 <Cale> SamB: define equating as well, while you're at it
04:28:04 <dmhouse> SamB: could clash with a future keyword.
04:28:08 <SamB> oh, wait, didn't somebody do equating?
04:28:09 <Cale> though I don't think they belong in Data.List
04:28:16 <int-e> I mean the name. It's too generic and too short - I'd expect collisions with existing code.
04:28:17 <SamB> where is that?
04:28:20 <dmhouse> And comparing?
04:28:21 <SamB> I could put it there.
04:28:28 <dmhouse> SamB: what's 'on'?
04:28:38 <int-e> I sort of liked the 'attach' name.
04:28:48 <SamB> i.e. equating = ((==) `on`)
04:28:58 <dmhouse> Oh, my attach combinator. Yeah, I'd say attach is the best name.
04:28:59 <SamB> comparing = (compare `on`)
04:29:00 <Cale> roconnor: the easiest way to tell where a stack overflow is occurring is by executing the code on paper (or in your head, if possible) -- if you see the expression building up to a ridiculous size, then that's quite likely the problem
04:29:07 <SamB> "attach"????
04:29:12 <SamB> on is much much much better
04:29:27 <roconnor> Cale: yeah, I added that $! because I thought that was my source of the stack overflow.
04:29:46 <Cale> roconnor: it could have been without the $!
04:29:57 <roconnor> but I still have a stack overflow :(
04:30:01 <dmhouse> attach f g x y = f x `g` f y
04:30:08 <Cale> provided that your input tree is extremely deep
04:30:11 <roconnor> It is only primitive ops that can cause a stack overflow, right?
04:30:20 <Cale> hmm
04:30:26 <roconnor> Cale: my input tree has depth 2^20
04:30:29 <dmhouse> You're 'attaching' f on to g, in the sense that you plug g's arguments through f first.
04:30:40 <SamB> I think "on" makes more sense...
04:30:50 <velco> or "shove"
04:30:52 <SamB> but let me see
04:30:55 <dmhouse> It'd make discussing the combinator hard.
04:31:17 <roconnor> Cale: because the program is mostly code that I haven't written; however that code only uses data types.
04:31:17 <SamB> you have a quote key for a reason
04:31:33 <roconnor> So I assume that it can never cause a stack overflow.
04:31:33 <SamB> let me see, though
04:31:51 <dmhouse> Reminds me of a group I saw that named a server 'up'. Something to do with upgrades. But then when up was down...
04:32:00 <Cale> roconnor: I'm not so sure that's a good assumption
04:32:45 <SamB> > let attach f g x y = f x `g` f y in sortBy (show `attach` comparing) [1..100]
04:32:46 <lambdabot>  Not in scope: `comparing'
04:32:52 <SamB> > let attach f g x y = f x `g` f y in sortBy (show `attach` compare) [1..100]
04:32:53 <lambdabot>  [1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,22,23,24,25,26,27,28,29,3,30,31...
04:33:01 <Cale> roconnor: try this: foldl const () [1..10000000]
04:33:03 <SamB> what a lousy sort ;-)
04:33:10 <dmhouse> :)
04:33:16 <SamB> dmhouse: it doesn't look very nice
04:33:19 <SamB> or sensible
04:33:47 <SamB> > let attach f g x y = f x `g` f y; on = flip attach in sortBy (comparing `on` show) [1..100]
04:33:48 <lambdabot>  Not in scope: `comparing'
04:33:53 <SamB> > let attach f g x y = f x `g` f y; on = flip attach in sortBy (compare `on` show) [1..100]
04:33:55 <lambdabot>  [1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,22,23,24,25,26,27,28,29,3,30,31...
04:34:14 <SamB> heh
04:34:18 <SamB> I keep saying "comparing"
04:34:26 <Cale> comparing and equating are nice
04:34:28 <SamB> as if I think I am programming in Inform 7 ;-)
04:34:35 <SamB> yes they are
04:34:44 <Cale> I don't think I'd use `on` in the general case all that much
04:34:52 <SamB> maybe not
04:35:02 <dmhouse> Useful to deifne nonetheless.
04:35:05 <dmhouse> *define
04:35:11 <roconnor> Prelude>  foldl const () [1..10000000]
04:35:11 <roconnor> *** Exception: stack overflow
04:35:15 * SamB supposes he will just have to remember the definition and use it whenever he wants something that does that
04:35:19 <roconnor> Okay, let me think about this.
04:36:09 <dmhouse> roconnor: Use a strict fold?
04:36:31 <roconnor> dmhouse: the question is can a stack overflow be caused without primops
04:36:54 <roconnor> Cale: um, where is your foldl pictures?
04:36:55 <SamB> roconnor: can anything happen without primops?
04:37:21 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
04:37:24 <lambdabot> Title: Fold Diagrams - CaleWiki
04:37:47 <roconnor> SamB, I must admit I use print to get things going.
04:38:06 <SamB> I'm positive the Handle code uses primops somewhere
04:38:33 <Cale> @let sieve :: (a -> a -> Bool) -> [a] -> [a]; sieve p [] = []; sieve p (x:xs) = x : filter (not . p x) (sieve p xs)
04:38:35 <lambdabot> Defined.
04:38:48 <Cale> > L.sieve (==) [1,2,1,1,2,3,4,1,2,1,5]
04:38:50 <lambdabot>  [1,2,3,4,5]
04:38:53 <SamB> @bindings
04:38:54 <lambdabot> Unknown command, try @list
04:39:05 <Cale> > L.sieve (\x y -> y `mod` x == 0) [2..]
04:39:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:40:58 <Cale> perhaps it shouldn't have the (not .)
04:41:05 <Cale> @let sieve :: (a -> a -> Bool) -> [a] -> [a]; sieve p [] = []; sieve p (x:xs) = x : filter (p x) (sieve p xs)
04:41:06 <lambdabot> <local>:14:41:     Multiple declarations of `L.sieve'     Declared at: <local...
04:41:11 <Cale> er
04:41:19 <Cale> @help let
04:41:20 <lambdabot> let <x> = <e>. Add a binding
04:41:29 <Cale> @unlet sieve
04:41:30 <lambdabot>  Parse error
04:41:32 <Cale> hmm
04:41:33 <Cale> :)
04:41:36 <roconnor> Cale: I'm a bit surprised that this is all allocated on the stack and not the heap.
04:42:23 <roconnor> Prelude> foldl const () (replicate 10000000 ())
04:42:23 <roconnor> *** Exception: stack overflow
04:42:26 <int-e> > foldl const () [1..10000000]
04:42:31 <lambdabot> Terminated
04:42:39 <int-e> > foldl const () [1..1000000]
04:42:42 <lambdabot>  ()
04:43:22 <Cale> @help commands
04:43:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:43:28 <Cale> @list
04:43:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:43:39 * roconnor gives in a increases the stack size
04:43:41 <Cale> aha
04:43:45 <Cale> @undefine sieve
04:43:46 <lambdabot> Undefined.
04:43:51 <Cale> @let sieve :: (a -> a -> Bool) -> [a] -> [a]; sieve p [] = []; sieve p (x:xs) = x : filter (p x) (sieve p xs)
04:43:52 <lambdabot> Defined.
04:44:05 <Cale> nub = sieve (/=)
04:44:06 <Cale> :)
04:44:38 * SamB should have made himself lunch
04:44:46 <Cale> > L.sieve (not . (flip mod)) [2..]
04:44:47 <SamB> okay, I have to go to school
04:44:48 <lambdabot>    Expecting a function type, but found `b'
04:44:48 <lambdabot>    Expected type: a -> Bool
04:44:48 <lambdabot> ...
04:45:09 <Cale> er...
04:45:19 <SamB> can someone else make a ticket for "equating"?
04:45:23 <Cale> @pl (\x y -> y `mod` x == 0)
04:45:24 <lambdabot> flip flip 0 . ((==) .) . flip mod
04:45:45 <int-e> > let primes = let sieve (n:ns) (p:ps) | p*p == n = sieve (filter (\n -> n`mod`p /= 0) ns) ps | otherwise = n:sieve ns (p:ps) in 2:3:sieve [5,7..] (tail primes) in primes
04:45:47 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:47:26 <Cale> hey, that's nice :)
04:48:06 <int-e> it's reasonably fast :)
04:49:03 <roconnor> ocaml runs faster than ghc :(
04:49:32 <dcoutts> it's not as cool :)
04:49:33 <int-e> I'd write a tail recursive decode_church.
04:49:46 <velco> I was just wondering why shootout binary-trees is faster in Haskell than in GCC
04:50:10 <dcoutts> faster memory management ?
04:50:30 <velco> I even removed deletion fro the C version ;)
04:50:33 <velco> maybe
04:50:39 <dcoutts> malloc isn't know for its speed
04:51:07 <int-e> and C has to explicitely free the stuff
04:51:28 <SamB> could have replaced it with sbrks and +=s
04:51:40 <SamB> if you don't need to free stuff
04:51:55 <roconnor> int-e: the ocaml code doesn't have a tail-recursive decode_church.
04:51:58 <int-e> they want deallocation
04:52:06 <int-e> (SamB)
04:52:13 <SamB> how do they know?
04:52:19 <SamB> looking at the code is cheating ;-)
04:52:23 <int-e> read the problem description.
04:52:34 <int-e> "allocate, walk, and deallocate many bottom-up binary trees"
04:52:43 <SamB> oh.
04:52:57 <SamB> I suppose if you don't deallocate the memory usage will be too insane
04:53:08 <int-e> I guess
04:55:15 * SamB goes to school now
04:58:09 <roconnor> um, I'm getting the feeling that profiling might not be compatable with unsafecoerce
04:58:20 <roconnor> $ ./betaetared 20 2
04:58:20 <roconnor> Segmentation fault
05:00:23 <dcoutts> roconnor, profiling changes the heap cell layout
05:00:50 <roconnor> I'm trying to find the source of my stack overflow, and general slowness
05:09:01 <roconnor> *l*
05:09:22 <roconnor> COST CENTRE                    MODULE               %time %alloc
05:09:22 <roconnor> unsafeCoerce                   Betaetared            29.7   37.7
05:09:37 <roconnor> I didn't realize unsafeCoerce was such an expensive function.
05:10:11 <roconnor> @hoogle undefined
05:10:12 <lambdabot> Prelude.undefined :: a
05:10:12 <lambdabot> Control.Exception.UndefinedElement :: String -> ArrayException
05:11:07 <roconnor> okay, profiling has told me nothing useful.
05:12:59 <roconnor> int-e: how do I make decode_church tail recursive?
05:14:40 <int-e> roconnor: decode_church x = decode_church' x 0; decode_church' (Abs _ t) n = decode_church' t n; docode_church' (App _ t) n = decode_church' t $! succ n; decode_church' (Var _) n = n
05:15:22 <roconnor> int-e: Ah, I was close.  Thanks.
05:15:23 <fons> hi all
05:15:34 <roconnor> well, that speeds things up like a billion fold
05:16:03 <roconnor> I should fix the ocaml code too to be fair
05:16:50 <int-e> roconnor: does it get rid of the stack overflow?
05:17:13 <roconnor> int-e: yes
05:17:24 <roconnor> *sigh* I odn't understand why my code didn't work
05:17:24 <int-e> good :)
05:18:18 <int-e> I think it has to collect all applications to succ (on the stack, apparently) before it can evaluate them.
05:18:51 <roconnor> shoudln't my $! have gotten rid of that?
05:19:02 <int-e> well, it doesn't have to, but combining succ $ succ [unknown terms] to 2+ [unknown terms] is hard.
05:19:21 <int-e> no. you still end up with an unevaluated succ that has to evaluate its argument first.
05:19:41 <int-e> I think the $! didn't have any effect at all.
05:19:45 <roconnor> ah
05:19:47 <int-e> succ is strict.
05:20:04 <roconnor> So I guess tail recursion is the only way
05:22:34 * roconnor attempts to edit ocaml code
05:26:24 * roconnor feels dirty
05:27:40 <JKnecht> snooty booger
05:39:30 <roconnor> okay, now GHC kicks ocaml's ass
05:39:47 <dmhouse> roconnor: 'now'?
05:40:00 <roconnor> now that I have a tail-recursive decode_church function.
05:40:03 <profmakx> ocamls ass is fat enough
05:41:00 <dmhouse> roconnor: ooh, how did you manage that one?
05:41:34 <dmhouse> Oh, I see int-e's comment.
05:42:12 * roconnor needs a deriving (foldl')
05:43:27 <int-e> roconnor: I guess you could convert to a list of 1-s and add a foldl' (+) 0 ...
05:43:27 <roconnor> ndm: would you likeme to remove the __ from my test code I send you, or will you have yhc fixed before then.
05:43:56 <ndm> roconnor: have you seen the mailing list? i'm trying to figure out what hte fix is, wait til i've got that done, then i'll let you know
05:44:34 <dmhouse> int-e: that'd still be O(n) space performance to build the list, right?
05:47:08 <int-e> dmhouse: it's O(n) anyway. but it gets the accumulation for free and I'd hope that ghc is clever enough to avoid actually building the list.
05:47:14 <Cale> dmhouse: no
05:47:26 <int-e> dmhouse: oh, space, no it's not.
05:47:26 <Cale> er, depends on what n is
05:47:47 <dmhouse> Cale: tree depth, I guess.
05:48:01 <Cale> It's O(log n) space if n is tree depth
05:48:14 <roconnor> ocaml: real    0m20.930s       GHC: real    0m3.154s
05:49:08 <Cale> roconnor: how does converting lazily to a list of 1's and then using foldl' (+) 0 do?
05:50:22 <int-e> roconnor: that means: replace the succ in the original code by (1:), replace the 0 by [] and then use foldl' (+) 0   to sum up everything.
05:52:02 <Cale> It's often nicer to convert to lists and then use foldl' than converting the thing to tail recursion explicitly
05:52:18 <Cale> though there's probably at least a slight performance difference
05:52:52 <int-e> I'd be really curious to know if ghc is clever enough to optimize away that difference.
05:54:52 <roconnor> ndm: What I'll do is just rename uses of __ to Prelude.undefined
05:54:59 <roconnor> and send you that
05:55:16 <roconnor> a search and replace is easy for now
05:55:21 <ndm> roconnor: i wouldn't bother, i'm gonig to be fixing that bug today, and working on Yhc all day
05:55:28 <ndm> roconnor: just send the original and i'll file it away
06:22:20 * araujo jumps and throws shuriken lambdas
06:28:03 * ndm blocks them with guards (but no if statements, they're so old fasioned)
06:30:28 <Cale> Yeah, we want if expressions, not if statements :)
06:31:05 <dcoutts> I had a student yesterday asking me what the difference between guards and if expressions was
06:31:10 <dcoutts> and which was better to use
06:34:08 <ndm> your answer?
06:34:29 <Igloo> Use case!
06:34:30 <flux-_> bet it was something zen-like? please?
06:34:31 <syntaxfree> my answer?
06:34:49 <syntaxfree> the answer is 42, I'm told.
06:34:55 <ndm> the York Haskell course doesn't even teach case (or monads, for that matter)
06:36:00 <syntaxfree> is it a first programming course?
06:36:21 <syntaxfree> the only thing that makes Scheme more appropriate than Haskell for a first course is the fun of metaprogramming.
06:36:37 <Igloo> Is   extern RtsSymbolVal rtsSyms[] = { ... }   OK in C, or does the extern mean rtsSyms is declared elsewhere?
06:37:32 <dcoutts> ndm, we don't cover case either
06:37:39 <ndm> Igloo: i think it means its defined elsewhere
06:37:52 <ndm> Igloo: but not entirely sure
06:38:09 <ndm> dcoutts, but i bet you cover monads :)
06:38:13 <dcoutts> nope
06:38:14 * Igloo is a bit confused as to why the compiler let me do it
06:38:22 <ndm> its not a first course, its a 3rd year one
06:38:31 <ndm> Igloo: surely if you have an extern, you can't give it a value at that point?
06:38:37 <dcoutts> ours is the first thing they do
06:38:42 <Igloo> That's why I'm confused
06:38:43 <syntaxfree> oh. monads should fit in just fine if they already have experience with functional languages.
06:38:53 <Igloo> Maybe I just want no qualifier at all
06:38:57 <syntaxfree> Scheme to Basic Haskell (sans monads and with black-box IO) is a snap.
06:39:30 <flux-_> sans something significant, I'd say :)
06:40:20 <dcoutts> flux-_, zen like? heh. I told him the difference and said that as for which one to use, it was a matter of taste, which one you felt read better.
06:40:27 <flux-_> dcoutts, ;-(
06:40:42 <flux-_> hmm.. I wonder if djinn would be useful in lifting functions in to/out from the IO-monad..
06:41:34 * Igloo sighs; over 1000 lines of diff against 6.6 already
06:41:47 <dcoutts> Igloo, for the .deb ?
06:42:23 <Igloo> Yup
06:43:30 <dcoutts> any important ones we should be using in the gentoo ebuild ?
06:43:46 <dcoutts> I've not noticed any real breakage yet
06:44:44 <dcoutts> (apart from the self-inflicted kind)
06:44:57 <Igloo> Fixes for mips(el), arm, unregisterised GHCi and dyn loading GHCi
06:49:35 <dcoutts> Igloo, cheers. I'll bear that in mind.
06:50:11 <Igloo> Oh, also a fix for alpha
06:51:10 * araujo likes 'if' for short-two-branches functions
06:51:30 <araujo> Mainly with point-free
06:52:07 <syntaxfree> flip if' is often useful when using bind notation.
06:52:34 <dcoutts> where are our catamorphism and anamophism brackets eh?
06:58:11 * araujo sees how dcoutts makes it sound "too complex for mere mortals"
06:58:18 <dcoutts> heh
06:58:24 <dcoutts> it's just fold and unfold
06:58:56 <dcoutts> catamorphism and anamophism are silly names made up by category theory people
06:59:06 <araujo> ya :-}
06:59:36 <dcoutts> and I can never remember which is which, fold and unfold is much easier to remember and explain
06:59:40 <araujo> they make you sound 'important' for sure ... you talk to your students like that right?
06:59:41 <araujo> :-}
06:59:58 <dcoutts> araujo, no, I don't talk to them like that :-)
07:00:03 <araujo> fold is catamorphism
07:00:11 <dcoutts> glad you can remember
07:00:19 <araujo> first time i hear about anamorphism though
07:00:26 <araujo> is it unfold?
07:00:27 <dcoutts> it's the other way around
07:00:31 <dcoutts> right
07:00:35 <araujo> Interesting ....
07:00:40 <dcoutts> oh, hmm
07:00:41 <syntaxfree> @google visual basic programmers love anamorphisms
07:00:43 <lambdabot> http://lambda-the-ultimate.org/classic/message9257.html
07:00:43 <lambdabot> Title: LtU Classic Archives
07:00:50 <syntaxfree> there you are :)
07:01:30 <dcoutts> araujo, yep unfold is the list anamorphism
07:01:39 <araujo> dcoutts, good
07:01:44 <syntaxfree> by no one lesser than Erik "Bananas" Meijer.
07:01:49 <Lor> The page doesn't exist. :P
07:01:54 <dcoutts> but I'd just generalise the meaning of unfold to be for any structure
07:01:57 <araujo> dcoutts, Talk to your students like that
07:02:00 <araujo> :-}
07:02:02 <dcoutts> araujo, no.
07:02:10 <dcoutts> they wouldn't approve
07:02:13 <araujo> haha
07:02:20 <dcoutts> instead I'll hand out linux cds :-)
07:02:28 <araujo> haha
07:03:00 <syntaxfree> it's the hylomorphisms that worry me.
07:03:01 <x3m> @seen foxy
07:03:01 <lambdabot> I saw foxy leaving #haskell-overflow and #haskell 1d 3h 58m 18s ago, and .
07:03:16 <dcoutts> syntaxfree, that's just fold after unfold.
07:03:34 <ptolomy> So I write a lot of software that is very concerned with business logic.. a big zoo of classes and subclasses and interfaces, and I'm trying to figure out how I would design such a program in haskell.  For example, a simulated financial market: multiple types of orders, multiple types of commodities, most of which have only minor differences and inherit.
07:03:39 <dcoutts> just say no to silly names
07:03:40 <araujo> syntaxfree, you are not the only one for sure
07:03:48 <ptolomy> Any thoughts on this all-too-vague quandry?
07:04:06 <syntaxfree> rather, when hylomorphisms cancel out smartly and when you get lotsa useless computation.
07:04:33 <dcoutts> syntaxfree, they fuse when they compose
07:04:36 <syntaxfree> @google haskell's overlooked object system
07:04:44 <lambdabot> http://www.cwi.nl/~ralf/OOHaskell/
07:04:44 <lambdabot> Title: Haskell's overlooked object system
07:05:01 <syntaxfree> ptolomy: that has a good comparison of OO and FP.
07:05:24 <syntaxfree> dcoutts: yes, but when does the compiler do it?
07:05:40 <dcoutts> syntaxfree, you need rules to make it happen. It's not magic.
07:06:03 <syntaxfree> dang. I like magic and hate rules.
07:06:06 <dcoutts> ptolomy, you can use classes to express the similarities between different types.
07:06:24 <dcoutts> syntaxfree, it's magic when someone else writes the rules ;-)
07:07:22 <ptolomy> dcoutts, but I can't keep a list or array of things that implement a typeclass, right?
07:07:33 <dcoutts> ptolomy, that needs existentials
07:07:37 <dcoutts> so yes
07:07:44 <syntaxfree> dcoutts: i'd rather that the computer makes the rules itself.
07:08:03 * ptolomy hmmms.
07:08:21 <dcoutts> syntaxfree, you want it to make up the proofs too? :-)
07:08:31 <dcoutts> syntaxfree, and write the ICFP papers ;-)
07:08:36 <vincenz> dcoutts: and review em
07:08:42 <dcoutts> good idea!
07:08:47 <ptolomy> I'm going to write a simulated exchange in haskell, then post it to the Cafe and see what results.
07:09:56 <syntaxfree> dcoutts: I'm just an economist.
07:10:44 <dcoutts> syntaxfree, well, you'll be glad to know that people are working on it
07:10:53 <dcoutts> so it'll all appear as magic
07:11:00 <syntaxfree> I kinda envy those people.
07:11:07 <syntaxfree> Alas, I'm  in the wrong profession.
07:11:13 <dcoutts> you already get quite a bit of list fusion by magic
07:11:32 <dcoutts> not enough mind you
07:11:33 <ndm> Yhc -O has proper fusion, for more types than just list
07:12:00 <dcoutts> ndm, how about arrays ? :-)
07:12:12 <syntaxfree> hmm. So Yhc is "better" in some aspects, despite not having the pythonish Big Library that ghc does.
07:12:13 <ndm> dcoutts, alas, not for arrays
07:12:40 <ndm> syntaxfree: Yhc -O is Yhc + Catch, and no one but me has that, so its unfair to call it Yhc
07:12:54 <vincenz> you'd need the polyhedral model to fuse arrays
07:12:57 <dcoutts> ndm, and not for ADTs that present sequence like interfaces.
07:13:11 <ndm> dcoutts, how do you mean?
07:13:29 <vincenz> dcoutts: you have that?
07:13:29 <dcoutts> ndm, eg 2-3 finger trees implementing sequences
07:13:38 <dcoutts> vincenz, yes, via rules
07:13:39 <syntaxfree> there are a lot of *DT acronyms.
07:13:50 <vincenz> dcoutts: rules on what
07:13:58 <syntaxfree> what are algebraic data types, abstract data types, general algebraic data types, etc?
07:14:07 <vincenz> abstract data types
07:14:09 <ndm> dcoutts, we'd have to see
07:14:11 <dcoutts> vincenz, but the elimination rule does depend on a manual proof for that ADT
07:14:25 <dcoutts> ndm, so you're using general fusion right?
07:14:35 <vincenz> dcoutts: heh, I do something similar for sequences in imperative code
07:14:43 <dcoutts> ndm, wasn't there a problem there with _|_'s and such ?
07:15:07 <ndm> dcoutts, not the way i do it
07:15:10 <dcoutts> vincenz, but you have to do the fusion manually each time.
07:15:36 <vincenz> not quite
07:15:46 <dcoutts> ndm, oh? do you have it described somewhere ?
07:16:03 <ndm> dcoutts, of course not :)
07:16:09 <dcoutts> ndm, heh
07:16:35 <ndm> dcoutts, i will one day...
07:16:46 <dcoutts> ok, great. I'm interested.
07:17:10 <dcoutts> ndm, and I thought you blogged everything! :-)
07:17:30 <ndm> dcoutts, not nearly a fraction of what i do!
07:19:42 <ndm> dcoutts, i classify everything of the form func x y = case x of ... as a consumer in x
07:20:00 <ndm> dcoutts, i classify everything that generates something concrete as a consumer
07:20:07 <ndm> stick them together, and then its sipmle
07:20:09 <dcoutts> as a generator
07:20:29 <ndm> yep, generates = generator
07:20:36 <roconnor> is there a OPTIONS_YHC pragma?
07:21:01 <dcoutts> ndm, so it's a bit like inlining and some case optimisation
07:21:14 <ndm> roconnor: yes
07:21:20 <dcoutts> ndm, but your inlining is more guided by looking for places where the elimination will happen
07:21:27 <ndm> dcoutts, yes, i guess
07:21:48 <dcoutts> ndm, and that copes with recursion ok ?
07:21:53 <ndm> dcoutts, and it doesn't inline as such, it composes, so writes out the producer but with the specialiser in place
07:21:56 <ndm> dcoutts, yes :)
07:22:14 <sjanssen>  dcoutts: there's fusion code for finger trees?
07:22:39 <roconnor> ndm: er, do you want me to inlcude -underscore, or -98 in the pragma?
07:22:52 <ndm> roconnor: i'm fixing the bug right htis second :)
07:22:59 <dcoutts> sjanssen, not a whole thing that's usable. But it's pretty simple. You just have a read/write elimination rule.
07:23:12 <roconnor> well, are you fixing it by making haskell 98 the default, or just making the -98 flag work?
07:23:28 <dcoutts> sjanssen, one we make the stream stuff more generic, arrays, lists, bytestring, sequences should plug in easily.
07:23:38 <sjanssen> dcoutts: sure, sure
07:23:52 <dcoutts> sjanssen, you're right that we need to make sure we don't get O(n^2) conversion functions/rules
07:24:50 <dcoutts> so we probably need a class of things that can be converted to streams
07:24:51 <sjanssen> dcoutts: yeah, did you see the scheme I sketched out?
07:25:02 <dcoutts> sjanssen, I'm not sure that I did.
07:25:33 <dcoutts> just like we have fromIntegral which uses a class to convert between instances
07:25:43 <ndm> roconnor: i am fixing the -underscore flag, then i'll make -98 default, and remove the underscore flag (turn it always on)
07:25:45 <sjanssen> http://darcs.haskell.org/~sjanssen/streamfusion/Data/Fusion/Stream.hs
07:25:48 <lambdabot> http://tinyurl.com/y8ahsx
07:27:24 <roconnor> @hoogle Yhc.Primops
07:27:25 <lambdabot> No matches, try a more general search
07:27:29 <roconnor> :)
07:27:36 <dcoutts> sjanssen, interesting.
07:30:33 <ndm> roconnor: just pushed a patch, requires you to use -underscore
07:30:43 <ndm> roconnor: will wait for malcolms response before i make this the default
07:32:53 <sjanssen> dcoutts: making a stream class will require MPTCs
07:35:06 <sjanssen> reasonable MPTCs though, nothing overlapping as far as I can see
07:35:47 <satan> hello
07:35:54 <roconnor> > 1.773 / 3.154
07:35:56 <lambdabot>  0.562143310082435
07:36:18 <satan> what does it mean when they say something is unique up to isomorphism?
07:37:08 <sjanssen> dcoutts: I've also been thinking about a scheme to systematize unfusing rules
07:37:23 <CrewdenX> satan:  unique to one form?
07:37:31 <CrewdenX> satan: what context is this in?
07:37:47 <nomeata> satan: probably that you can rename the elements to get the exact same something
07:38:09 <satan> CrewdenX: Nat is unique (up to isomorphism), from category theory
07:38:19 <satan> nomeata: ah i see
07:38:43 <CrewdenX> satan: Nat ?
07:39:02 <satan> CrewdenX: Natural numbers
07:39:12 <CrewdenX> satan: ok.
07:39:56 <satan> thanks :)
07:46:56 <roconnor> ndm: does YHC define __YHC__ for the cpp?
07:47:19 <ndm> roconnor: yes, i think so
07:47:55 <dcoutts> sjanssen, lets talk about it later. I've got to go teach Java & OOP.
07:48:04 <dcoutts> booo! hiss!
07:48:07 <dcoutts> ahem.
07:48:23 * roconnor tries to figure out how #elif works
07:48:36 <roconnor> can I do
07:48:41 <roconnor> #ifdef __GLASGOW_HASKELL__
07:48:47 <roconnor> #elif __YHC__
07:48:50 <roconnor> #else
07:48:53 <roconnor> #endif
07:48:56 <ndm> i think so, yes
07:49:01 <CrewdenX> roconnor: #elif defined(__YHC__)
07:49:04 <dcoutts> roconnor, #elif defined(__GHC__)
07:49:06 <roconnor> or do I need to do ... #elif defined
07:49:07 <dcoutts> hah
07:49:08 <roconnor> bah
07:49:14 <roconnor> crappy cpp language
07:49:37 <dcoutts> #ifdef X  =  #if defined(X)
07:49:48 <roconnor> why not #elifdef?
07:49:55 <dcoutts> dunno, but there isn't
07:50:03 <roconnor> crappy cpp language
07:50:04 <CrewdenX> roconnor: probably because #ifdef wasn' needed to begin with.
07:50:38 <roconnor> ... can't we just add unsafecoerce to the standard library :)
07:51:44 <ndm> roconnor: it is
07:51:47 <ndm> @hoogle unsafe
07:51:47 <lambdabot> Language.Haskell.TH.unsafe :: Safety
07:51:48 <lambdabot> System.IO.Unsafe :: module
07:51:48 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
07:51:51 <ndm> @hoogle unsafeCoer
07:51:52 <lambdabot> No matches found
07:51:59 <ndm> roconnor: import Foreign
07:52:20 <roconnor> will that work under Hugs, Yhc and GHC?
07:52:34 <ndm> maybe :)
07:54:55 <roconnor> ndm: I only see unsafePerformIO in Foreign.
07:56:06 <ndm> roconnor: ah, thats what i was thinking of
07:56:12 <ndm> f :: a -> IO b
07:56:17 <ndm> g :: b -> IO c
07:56:21 <ndm> fg :: a -> IO c
07:56:25 <ndm> fg is defined as?
07:56:36 <ndm> does it not exist as a combinator?
07:57:54 <ndm> I would hoogle for it, but i know hoogle is broken on monads...
07:58:15 <Igloo> It's (g =<<) . f
07:58:38 <roconnor> @pl  (g =<<) . f
07:58:38 <lambdabot> (g =<<) . f
07:58:49 <roconnor> @pointful  (g =<<) . f
07:58:49 <lambdabot> Unknown command, try @list
07:58:54 <ndm> cheers, i was hoping for a standard thing, but never mind
08:05:10 <lightstep> is clean's strictness analyser still better than ghc's?
08:08:45 <syntaxfree> isn't clean an entirely different language?
08:08:49 <roconnor> lightstep: want me to ask down the hall?
08:09:45 <ndm> lightstep: clean has strictness in its types, so it has more info to play with
08:10:27 <syntaxfree> unsafePerformIO is such an uglie.
08:10:59 <syntaxfree> it offends my very sense of what's beautiful, true and pure about the world.
08:11:23 <Lor> How about top-level IO?
08:11:52 <lightstep> ndm, ghc also does: http://www.haskell.org/ghc/docs/latest/html/users_guide/sec-bang-patterns.html
08:11:56 <lambdabot> Title: 7.8. Bang patterns, http://tinyurl.com/yywtt4
08:12:12 <ndm> lightstep: as of very recently, but not in teh types
08:12:51 <syntaxfree> are cpp templates like type classes?
08:13:57 <Igloo> They are used for some of the same things
08:14:00 <lightstep> syntaxfree, type classes are somewhat like traits templates, but with both fields and methods
08:14:25 <syntaxfree> I know Haskell fairly well, and have next to  no idea of cpp.
08:14:30 <lightstep> ndm, why does it matter? if enough of the template is strict, the function is strict
08:14:56 <lightstep> templates are simpler than type classes
08:15:13 <ndm> lightstep: yes, but hte types can say things about the recursiveness, and what is strict vs what is head strict, tail strict, strict down certain fields etc
08:19:19 <syntaxfree> HTE types?
08:21:29 <ndm> @seen SamB
08:21:29 <lambdabot> SamB is in #perl6, #darcs, #ghc and #haskell. I last heard SamB speak 3h 26m 13s ago.
08:21:59 <ndm> @tell SamB, Yhc now can view Core files with -viewcore, and has the core files outputted using a pretty printer - be happy :)
08:22:00 <lambdabot> Consider it noted.
08:23:06 <syntaxfree> @tell syntaxfree he's the greatest man alive
08:23:07 <lambdabot> You can tell yourself!
08:23:13 <Syzygy-> Haha
08:23:23 <Syzygy-> @tell syntaxfree he's the greatest ego alive
08:23:24 <lambdabot> Consider it noted.
08:23:26 <Syzygy-> :)
08:24:27 <syntaxfree> I'm the greatest megalomaniac alive.
08:24:28 <lambdabot> syntaxfree: You have 1 new message. '/msg lambdabot @messages' to read it.
08:24:39 <syntaxfree> @messages
08:24:40 <lambdabot> Syzygy- said 1m 17s ago: he's the greatest ego alive
08:24:53 <roconnor> lightstep, No, I mean down the hall in my building, where the clean developers are
08:27:17 <lightstep> they let a haskell developer work there too?
08:29:01 <lightstep> actually, i'm a bit surprised that clean is still alive. i haven't heard buzz around it for a year or so
08:29:33 <roconnor> lightstep: er, I'm not sure.  Perhaps they are the former clean developers down the hall.
08:33:35 <ptolomy> > (iterate (\x -> 1 + (1/x)) 1)!!100
08:33:43 <lambdabot>  1.618033988749895
08:33:49 <ptolomy> Woo.
08:34:30 <chessguy> hmm, i've never seen this notation before: data Tree a = Node a [Tree a]
08:34:34 <chessguy> what's that mean?
08:34:46 <Maddas> @pl \x -> 1 + (1/x)
08:34:48 <lambdabot> (1 +) . (1 /)
08:34:50 <Bourbaki> moin
08:35:03 <Bourbaki> dons are you awake?
08:35:05 <mattam> chessguy: list of Tree's
08:35:10 <chessguy> oh! duh, it's just a non-binary tree
08:35:16 <chessguy> sorry, ignore me
08:36:52 <chessguy> i thought it was sugar for something else
08:37:13 <ptolomy> > (iterate ((1+).(1/)) 1) !! 50
08:37:14 <lambdabot>  1.618033988749895
08:37:17 <ptolomy> Neat.
08:42:57 <marcot> Hello there.
08:43:07 <marcot> Is there a way to access widget propierties with gtk2hs?
08:43:31 <syntaxfree> > scanl (-) $ (iterate ((1+).(1/)) 1)
08:43:32 <lambdabot>  add an instance declaration for (Num [a])
08:43:55 <syntaxfree> @type  (iterate ((1+).(1/)) 1)
08:43:56 <lambdabot> forall a. (Fractional a) => [a]
08:44:06 <syntaxfree> @type scanl
08:44:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:44:15 <araujo> marcot, of course , check the api docs
08:44:27 <syntaxfree> > scanl (-) 0 $ (iterate ((1+).(1/)) 1)
08:44:29 <lambdabot>  [0.0,-1.0,-3.0,-4.5,-6.166666666666666,-7.766666666666666,-9.391666666666666...
08:45:40 <syntaxfree> methinks of inventing a Haskell-like language with very very little syntactic sugar.
08:45:42 <syntaxfree> Diet Haskell.
08:45:48 <marcot> araujo: I'm trying to find in the gtk2hs code where RcStyle is definde.
08:45:53 <Syzygy-> Heh
08:46:04 <chessguy> what's wrong with syntactic sugar?
08:46:14 <Syzygy-> chessguy: It makes you fat... :P
08:46:17 <Syzygy-> And diabetic
08:46:18 <syntaxfree> It obscures the true workings of things.
08:46:45 <syntaxfree> I'm particularly opposed to do notation, though comprehensions are nice and living without [lists] would be ugly.
08:46:53 <sfultong> has anyone used regex for haskell pattern matching?  I read somewhere that it is possible somehow
08:47:02 <syntaxfree> I'm in favor of bringing back monad comprehensions.
08:47:17 <bringert> @google haskell harp
08:47:19 <lambdabot> http://sources.gentoo.org/viewcvs.py/gentoo-x86/dev-haskell/harp/
08:47:19 <lambdabot> Title: [gentoo-x86] Index of /dev-haskell/harp
08:47:20 <marcot> In Graphics/UI/Gtk/Widget.chs.pp there's RcStyleClass and RcStyle data type.
08:48:05 <sfultong> thanks
08:48:07 <bringert> sfultong: you mean like this: http://www.cs.chalmers.se/~d00nibro/harp/
08:48:09 <lambdabot> Title: Haskell Regular Patterns
08:48:14 <marcot> But when I grep in the code I can't find any other occurrences of it.
08:48:25 <marcot> marcot@juquinha:~/dados/texto/codigo/haskell/gtk2hs-0.9.10$ grep -R RcStyleClass *
08:48:25 <marcot> gtk/Graphics/UI/Gtk/Abstract/Widget.chs.pp:widgetModifyStyle :: (WidgetClass self, RcStyleClass style) => self
08:48:25 <marcot> marcot@juquinha:~/dados/texto/codigo/haskell/gtk2hs-0.9.10$
08:48:40 <chessguy> > (2^65)-1
08:48:42 <lambdabot>  36893488147419103231
08:48:51 <chessguy> > ((2^65)-1)::Int
08:48:52 <lambdabot>  -1
08:49:02 <chessguy> > ((2^65)-1)::Integer
08:49:04 <lambdabot>  36893488147419103231
08:49:27 <mjl69> > [x | x <- [1..10], even]
08:49:28 <lambdabot>    Expecting a function type, but found `Bool'
08:49:28 <lambdabot>    Expected type: Bool
08:49:28 <lambdabot>  ...
08:50:01 <chessguy> > [x | x <- [1..10], (x % 2) == 0]
08:50:02 <lambdabot>  []
08:50:13 <mjl69> > [x | x <- [1..10], mod x 2 == 0]
08:50:16 <lambdabot>  [2,4,6,8,10]
08:50:25 <chessguy> > [x | x <- [1..10], (x `mod` 2) == 0]
08:50:26 <lambdabot>  [2,4,6,8,10]
08:50:26 <chessguy> duh
08:50:33 <marcot> @hoogle RcStyleClass
08:50:35 <lambdabot> No matches found
08:50:46 <marcot> @hoogle RcStyle
08:50:48 <lambdabot> No matches found
08:50:54 <syntaxfree> > [ x | x<-[1..100], even x]
08:50:56 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
08:51:00 <Syzygy-> > let % = `mod` in [x | x <- [1..10], x % 2 == 0 ]
08:51:02 <lambdabot>  Parse error
08:51:07 <mjl69> > zip [x | x <- [1..10], mod x 2 == 0] [x | x <- [1..10], mod x 2 != 0]
08:51:09 <lambdabot>  Not in scope: `!='
08:51:13 <Syzygy-> > let % = mod in [x | x <- [1..10], x `%` 2 == 0 ]
08:51:15 <lambdabot>  Parse error
08:51:18 <mjl69> oh what's not equal
08:51:21 * earthy grins
08:51:24 <Syzygy-> =/=
08:51:24 <chessguy> =/
08:51:30 <Syzygy-> maybe?
08:51:36 <chessguy> > 3 =/ 2
08:51:37 <lambdabot>  Not in scope: `=/'
08:51:38 <velco> > let (%) =  mod in [x | x <- [1..10], x % 2 == 0 ]
08:51:40 <lambdabot>  [2,4,6,8,10]
08:51:41 <syntaxfree> > let a % b = mod a b in [x | x<-[1..10], x % 2 == 0
08:51:41 * chessguy sighs
08:51:41 <lambdabot>  Parse error
08:51:45 <Syzygy-> > 3 =/= 2
08:51:45 <syntaxfree> ;)
08:51:47 <lambdabot>  Not in scope: `=/='
08:51:49 <Syzygy-> Nope.
08:51:55 <Syzygy-> > not 3 == 2
08:51:57 <lambdabot>  add an instance declaration for (Num Bool)
08:51:57 <chessguy> > 3 /= 2
08:51:58 <lambdabot>  True
08:52:00 <earthy> > let (%) = mod in [ x | x <- [1 .. 10], x % 2 == 0 ]
08:52:01 <Syzygy-> Ah.
08:52:02 <lambdabot>  [2,4,6,8,10]
08:52:03 <chessguy> oh, i was close
08:52:15 <Syzygy-> earthy: There it is.
08:52:17 * earthy suggest /msg lambdabot to syzygy-
08:52:30 * syntaxfree suggests GHCi ;)
08:52:43 <mjl69> > [x | x <- [1..10], mod x 2 /= 0]
08:52:45 <lambdabot>  [1,3,5,7,9]
08:52:51 * Syzygy- has both, but they don't give me your input as well. And you not my input.
08:52:52 <earthy> ah, but /msg lambdabot works on every single computer with IRC in the world
08:52:57 <earthy> whereas ghci doesn't. :)
08:53:09 <mjl69>  > zip [x | x <- [1..10], mod x 2 == 0] [x | x <- [1..10], mod x 2 /= 0]
08:53:20 <Syzygy-> earthy: If I can IRC, then I can SSH, then I can get to either my server or my workstation, which both have ghci
08:53:30 <mjl69> > zip [x | x <- [1..10], mod x 2 == 0] [x | x <- [1..10], mod x 2 /= 0]
08:53:32 <lambdabot>  [(2,1),(4,3),(6,5),(8,7),(10,9)]
08:53:38 <mjl69> hehe
08:54:00 <chessguy> cute
08:54:27 <mjl69> how do you make it into one list again?  I forgot everything.
08:54:40 <chessguy> it is one list
08:54:54 <integral> > [(x, y) | x <- [1..10], mod x 2 == 0 | y <- [1..10], mod y 2 /= 0]
08:54:55 <lambdabot>  Parse error
08:55:10 <integral> lambdabot doesn't use GHC extensions?
08:55:47 <chessguy> > [(x, y) | x <- [1..10], y<- [1..10], mod x 2 == 0, mod y 2 /= 0]
08:55:48 <lambdabot>  [(2,1),(2,3),(2,5),(2,7),(2,9),(4,1),(4,3),(4,5),(4,7),(4,9),(6,1),(6,3),(6,...
08:58:15 <chessguy> well, that was a conversation-stopper
09:01:11 <glguy> ?seen dons
09:01:12 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 2h 56m 2s ago.
09:01:36 <earthy> mjl69: maybe you meant:
09:01:37 <earthy> > join $ zipWith (:) [ x | x <- [1..10], even x] [ [y] | y <- [1..10], not $ even y]
09:01:39 <lambdabot>  [2,1,4,3,6,5,8,7,10,9]
09:02:19 <earthy> oh well, time to go
09:02:56 <glguy> > join $ transpose [[2,4..10],[1,3..9]]
09:02:58 <lambdabot>  [2,1,4,3,6,5,8,7,10,9]
09:03:14 <dolio> > [ (x,y) | (x,y) <- join zip [1..10], mod x 2 == 0, mod y 2 /= 0 ]
09:03:16 <lambdabot>  []
09:03:35 <dolio> Ah, of course not.
09:04:06 <glguy> > join (liftM2 zip) [1..10]
09:04:07 <lambdabot>  add an instance declaration for (Num [a])
09:04:07 <earthy> ah, see, my mind let me down as well
09:04:07 <lambdabot>   In an arithmetic sequence: [1...
09:04:24 <xerox> > [(1,1)..(10,10)]
09:04:25 <lambdabot>  add an instance declaration for (Enum (a, b))
09:04:25 <lambdabot>   In an arithmetic sequence...
09:04:27 <xerox> Aw.
09:04:42 <glguy> > range ((1,1),(10,10)
09:04:42 <lambdabot>  Parse error
09:04:43 <glguy> > range ((1,1),(10,10))
09:04:44 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
09:05:13 <xerox> That's not join zip [1..10]
09:05:35 <glguy> I don't know what the goal is
09:06:13 <dolio> Would [(1,1)..(10,10)] be join zip [1..10]?
09:06:30 <glguy> if you could do the former
09:06:30 <xerox> In some world :)
09:06:37 <dolio> That's not all (1,1) <= (a,b) <= (10,10). :)
09:28:12 <therp> is there any shorter way to test for upper caseness than char `elem` ['A' .. 'Z']?
09:28:29 <mjl69> earthy: sorry, had to run off and do some work.  That is what I was trying to remember.
09:29:46 <mjl69> >(1,2):(3,4)
09:30:02 <kowey> therp: isUpper char ; you'll have to import Data.Char, though
09:30:04 <mjl69> > (1,2):(3,4)
09:30:05 <lambdabot>  Couldn't match `[(a, b)]' against `(a1, b1)'
09:30:29 <mjl69> > 1:(3,4)
09:30:30 <lambdabot>  Couldn't match `[a]' against `(a1, b)'
09:30:43 <mjl69> > 1:2:3
09:30:45 <lambdabot>  add an instance declaration for (Num [a])
09:30:55 <mjl69> > 1:2:3:[]
09:30:57 <lambdabot>  [1,2,3]
09:31:30 <mjl69> > (1,2):(3,4):[]
09:31:33 <lambdabot>  [(1,2),(3,4)]
09:46:08 <roconnor> > 12.952/13.128
09:46:09 <lambdabot>  0.9865935405240707
09:50:03 <roconnor> maybe I shouldn't use IRC as my calculator
09:50:33 <xerox> @google 15 gallons in milliliters
09:50:34 <lambdabot> 15 US gallons = 56,781.177 milliliters
09:51:47 <mjl69> I used to use GHC as a calculator all the time.  but then IRC can be used from a phone, so it work out well there.
09:52:23 <roconnor> GHC is a great calculator
09:52:43 <roconnor> well GHCi is
09:52:52 <ValarQ> @google 1 hogsheads in liters
09:52:53 <lambdabot> 1 hogsheads = 238.480943 liters
09:53:50 <ValarQ> @google 2 winebottles in magnums
09:53:53 <lambdabot> http://www.leeners.com/bottlewine.html
09:53:55 <ValarQ> heh
09:54:29 <esap> @google 1 adjunction in functors
09:54:31 <lambdabot> http://en.wikipedia.org/wiki/Adjoint_functors
09:56:25 <SyntaxNinja> kosmikus: you owe me email :P
10:00:33 <ski> esap : hehe
10:04:33 <emu> > 1 + sqrt 2
10:04:34 <lambdabot>  2.414213562373095
10:05:55 <ski> > let phi = (1 + sqrt 5) / 2 in (1/phi,phi,phi^2)
10:06:03 <lambdabot>  (0.6180339887498948,1.618033988749895,2.618033988749895)
10:07:02 <guerra> is there a good programmin ambient for haskell?
10:08:29 <emu> let phi = (1 + sqrt 5) / 2 in fix (\f -> phi : (phi * (tail f)))
10:08:35 <emu> > let phi = (1 + sqrt 5) / 2 in fix (\f -> phi : (phi * (tail f)))
10:08:36 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
10:08:37 <lambdabot>    Expected...
10:08:53 <emu> > let phi = (1 + sqrt 5) / 2 in fix (\f -> phi : (phi * f))
10:08:54 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
10:08:54 <lambdabot>    Expected...
10:09:10 <emu> > let phi = (1 + sqrt 5) / 2 in fix (\f -> phi : map (*phi) f)
10:09:43 <lambdabot>  [1.618033988749895,2.618033988749895,4.23606797749979,6.854101966249685,11.0...
10:15:25 <roconnor> > 5^5
10:15:27 <lambdabot>  3125
10:24:24 <SyntaxNinja> dons: just FYI, mountain view is not san francisco ;)
10:24:41 <SyntaxNinja> but maybe you flew into san fran
10:32:10 <marcot> Hello.
10:32:29 <marcot> How do I get the foreground color of the style of a widget in gtk2hs?
10:32:54 <marcot> I can get the RcStyle with widgetGetModifierStyle, but how can I get the foreground from it?
10:33:05 <araujo> marcot, i bet you can find all that info from the api doc
10:33:18 <dcoutts_> marcot, I'm not sure you can set style properties
10:33:29 <dcoutts_> and anyway they're mostly for themes
10:33:32 <marcot> araujo: I bet you can't...
10:33:38 <araujo> :-P
10:34:11 <psnl> ndm: what do you have the Bool type defined as in the C code in hat?
10:34:11 <marcot> dcoutts_: that's because I'm drawing in a DrawWindow with gdkDrawable functions, and they need a GC as a parameter.
10:34:14 <marcot> =D
10:34:28 <ndm> psnl: absolutely no idea! never looked at the C side of it!
10:35:01 <marcot> dcoutts_: When I do newGC draw_window, it's getting a GC with defaults values, not with the themes values.
10:35:04 * psnl is playing hunt-the-#define
10:35:29 <dcoutts_> marcot, well you can use a custom GC of course
10:35:37 <marcot> dcoutts_: The foreground color is always black, even if my theme foreground color is white.
10:35:53 <dcoutts_> marcot, set the GC foreground
10:35:54 <marcot> dcoutts_: Sure, this is a way out, but I would prefer to use the themes colors.
10:36:27 <dcoutts_> marcot, ah, I see. No we've not bound the stuff that lets you query the current theme style.
10:36:47 <dcoutts_> but you can easily set your own colour of course
10:37:08 <marcot> dcoutts_: hum... ok. I know how to set my color with a kind of ugly code:
10:38:22 <dcoutts_>     gc <- Gtk.gcNewWithValues pixmap Gtk.newGCValues {
10:38:22 <dcoutts_>         Gtk.foreground = Gtk.Color red green blue
10:38:22 <dcoutts_>       }
10:38:47 <marcot> dcoutts_: that was how I was doing.
10:39:05 <dcoutts_> marcot, if you want nicer code, use cairo.
10:39:53 <marcot> dcoutts_: is it better for this kind of stuff?
10:40:17 <dcoutts_> depends on what you're doing
10:40:36 <marcot> dcoutts_: I'm just drawing some lines..
10:41:44 <dcoutts_> yep, cairo is good for that :-)
10:42:05 <dcoutts_> it does smooth anti-aliased graphics
10:42:12 <marcot> =D
10:42:20 <marcot> But is it cleaner in the code?
10:42:29 <dcoutts_> yes
10:42:41 <dcoutts_> look at one of the demos
10:44:18 <marcot> dcoutts_: It seems to be nice.
10:47:16 <kosmikus> SyntaxNinja: which one? I had some technical problems problems recently, so I may have missed or overlooked it?
10:48:35 <SyntaxNinja> kosmikus: i re-forwarded it to you about an hour ago
10:58:48 <kosmikus> SyntaxNinja: I can't find anything that I've got from you today.
11:05:52 <SyntaxNinja> bugger
11:06:01 <SyntaxNinja> I know _some_ people are getting my email
11:08:37 <SyntaxNinja> my dns is messed up, I got one bounce, but that's it. maybe the others will go through. i'll watch out for bounces.
11:10:05 <emu> is there a good way to find an element in a Data.Sequence?  I see this "viewl" function which returns a ViewL with a Traversable instance.  Not sure how to make use of that though.  I wrote a structurally recursive function on ViewL but it seems like there should be a better way.
11:11:04 <emu> I'm using Data.Sequence as a queue which first checks to be sure the element isn't already in the queue when adding it.
11:11:13 <ndm> emu: lookup? is that in there?
11:11:20 <ndm> i can't check because hoogle doesn't index Sequence yet
11:11:20 <emu> not that i saw
11:11:27 <ndm> @docs Data.Sequence
11:11:28 <lambdabot> Data.Sequence not available
11:11:45 <dcoutts_> emu, you can use find
11:11:53 <dcoutts_> find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:12:10 <dcoutts_> Data.Foldable.find
11:12:30 <dcoutts_> or elem
11:12:33 <emu> ah cool.
11:12:40 <emu> yes, i figured there should be some fold on that
11:13:03 <dcoutts_> emu, I'm not sure Data.Sequence is the best kind of queue.
11:14:13 <emu> well Data.Queue is marked deprecated
11:14:20 <dcoutts_> take a look at the edison libs, I think you can find a dqueue with O(1) amortised bounds
11:14:23 <emu> "The data structure in Data.Sequence is a faster queue"
11:14:56 <emu> well, I'm keeping it abstracted so I can drop in something later I suppose
11:15:07 <dcoutts_> emu, are you sure you don't want a heap or a priority queue ?
11:15:31 <emu> it's a weird queue.  I want order of insertion to be preserved, but only if the element isn't there already
11:15:46 <dcoutts_> hmm, perhaps you just want a set and a sequence
11:15:53 <emu> possibly
11:16:07 <dcoutts_> then you get log n testing if it's already in the queue rather than linear
11:17:05 * dcoutts_ -> home
11:17:58 <emu> tnx
11:18:09 <sjanssen> emu: you can adapt Data.FingerTree to have both set and queue operations in a single data structure
11:19:28 <kosmikus> SyntaxNinja: maybe the problem is still on my side. but apparently, I had mail problems only until Monday ...
11:19:44 <SyntaxNinja> kosmikus: Igloo didn't get an email I sent too, and I know I got one other bounce.
11:19:58 <SyntaxNinja> kosmikus: I emailed the dns folks, just have to wait for them to fix it I guess
11:21:02 <emu> sjanssen: that's not in the GHC docs though?
11:21:20 <sjanssen> emu: yeah, it isn't in the standard libs
11:21:40 <sjanssen> you're probably better of with a separate set and queue
11:38:09 <jmmv> hi
12:04:42 <palomer> haskell makes me all warm and fuzzy inside
12:04:44 <palomer> I don't know why
12:11:30 <lovecoder> Hi, I'm an ignoramus.  I need help.  My brain is struggling to understand Haskell
12:13:01 <lovecoder> I've been going through a tutorial, and I'm seeing this example in the chapter under "Recursive Functions".  I keep looking at this example again and again, but can't make heads or tails of it.
12:13:15 <Botje> put it on the pastebot, don't paste it in here
12:13:15 <Botje> ?paste
12:13:17 <lovecoder> Actually, I can't find the rest of the body either.
12:13:17 <lambdabot> http://paste.lisp.org/new/haskell
12:13:31 <Botje> or just paste the url :)
12:13:33 <lovecoder> ok
12:14:24 <roconnor> recursion is confusing at first.
12:14:45 <lisppaste2> lovecoder pasted "Tutorial Example" at http://paste.lisp.org/display/28682
12:15:29 <sjanssen> lovecoder: do you understand what [1..n] means?
12:15:44 <integral> That doesn't use recursion...
12:15:51 <lisppaste2> lovecoder annotated #28682 with "Tutorial Example" at http://paste.lisp.org/display/28682#1
12:16:21 <integral> lovecoder: you're missing a space before the 0 on the first line of the annotation
12:16:22 <sjanssen> ewww n+k patterns!
12:16:28 <lovecoder> yes, I understand that part, but not the annotated part
12:16:38 <integral> not using a n+k pattern makes the code shoter!
12:16:39 <mauke> whoa, there's a special asterisk operator in unicode?
12:16:51 <integral> There's a haskell compiler that groks that unicode?
12:16:52 <sjanssen> lovecoder: is that what is confusing you, the (n+1) on the left side of the = ?
12:16:56 <Botje> woah. paste.lisp.org++
12:17:05 <Botje> "context in irc" and annotations are seriously cool.
12:17:16 <sjanssen> integral: the latest ghc handles some unicode
12:17:28 <lovecoder> sjanssen: yes, the (n+1) on the left side is confusing me
12:17:34 <integral> sjanssen: oh cool.
12:17:45 * integral is currently stuck with a ghc-6.6 that thinks its ghc-6.5 *sigh*
12:17:57 <sjanssen> lovecoder: this is a rarely used, and much maligned Haskell feature
12:17:58 <lovecoder> i think it's a virus that is short circuiting my brain, like the one they designed in star trek to destroy the borg
12:18:41 <mauke> think of it as factorial m = let n = m - 1 in ...
12:18:57 <lisppaste2> sjanssen annotated #28682 with "without n+k" at http://paste.lisp.org/display/28682#2
12:19:04 <lovecoder> integral: i'm using hugs, but the tutorial is from Graham Hutton from the University of Nottingham
12:20:03 <lisppaste2> sjanssen annotated #28682 with "desugaring of n+k" at http://paste.lisp.org/display/28682#3
12:20:48 <Botje> lovecoder: do you understand #2 ?
12:21:00 <Botje> that's the normal definition
12:22:58 <lovecoder> Botje, yes, I understand #2
12:23:15 <Botje> well
12:23:24 <Botje> the factorial (n + 1) gets matched against eg factorial 5
12:23:26 <Botje> so (n + 1) == 5
12:23:35 <Botje> so for that to be true, n must be 4
12:24:02 <Botje> it's tricksy and probably unnecessarily complex, but it's nice to have, I can imagine.
12:24:22 <sjanssen> lovecoder: if you want to understand how the original example is transformed to simpler code, checkout paste #3
12:24:24 <lovecoder> ok, so this is different from the pattern matching of types that i learnt earlier in the tutorial?
12:25:02 <Cale> lovecoder: are you talking about n+k patterns?
12:25:09 <Cale> then yes, it's quite different
12:25:12 <sjanssen> lovecoder: if you mean pattern matching of constructors, then yes, they are different
12:25:12 <lovecoder> sjanssen: ok, meditating on #3, brb...
12:25:38 <Cale> right, and the things you normally pattern match on are called data constructors
12:25:50 <Cale> + is not a data constructor of the Integer type
12:26:02 <Cale> so normally you wouldn't be allowed to pattern match on it
12:26:13 <sjanssen> though, one could imagine that Integer is just a string of +1 or -1, that's the motivation behind n+k patterns
12:26:18 <Cale> but there's a special provision in the language to allow you to do so (which lots of people love to hate)
12:26:19 <integral> hrm.  n+k == S^k(n) if you had peano numbers, with S as a constructor
12:26:39 <Botje> pfft, church numerals ftw
12:26:41 <Cale> right, it makes more sense in the natural numbers
12:27:12 <Cale> The goal with n+k patterns was to make working with Integers more like working with Nats.
12:27:25 <lovecoder> ok, so it's different than datastructure patterns
12:30:46 <sjanssen> yep
12:34:49 <lovecoder> hmmm... i think i'm beginning to make some sense of annotation #3... so the gaurd is x >= 1 and the recursive part is (n + 1) * factorial n and n is defined as n = x - 1 ... simple enough, it's recursing down from the starting number towards 1 and it is all being accumulated
12:37:14 <lovecoder> grrr... still lost... ok, let's try it like this...
12:37:52 <lovecoder> integral: help me on understanding n+k == S^k(n) ??
12:38:43 <integral> you should ignore me.  I was just commenting on how special the feature is.
12:39:04 <lovecoder> oh, ok :-)
12:40:03 <Botje> lovecoder: S^k(n) k applications of S on n, where S n = n + 1
12:40:15 <lovecoder> desugaring the n+k part, how is "where n = x - 1" desugared from "(n + 1)", or maybe... how would annotation #3 look like, if I wrote (n + 2) ??
12:40:39 <integral> Botje: no, S n doesn't equal n + 1,  I was thinking of it as the constructor in: data Nat = O | S Nat
12:40:59 <Botje> that's what it represents, anyway :P
12:49:08 <lovecoder> ok, is there any other tutorial page out there on this subject that i can read?
12:52:46 <lovecoder> if this is rare, maybe the author should remove it from a beginners tutorial, or put it closer to the end, the first 5 chapters were a breeze to read, but i've been stuck on chapter 6 now for a couple of days
12:54:30 <Botje> lovecoder: $DEITY picked you as the person to do this :)
12:55:41 <wagle> is there an up-to-date GUI programming environment?
12:57:59 <Lemmih> wagle: Such as GTK or like an IDE?
12:58:38 <wagle> Lemmih, GTK...
12:59:06 <Lemmih> I'd say GTK is pretty up-to-date.
12:59:29 <wagle> for haskell?  ok
13:00:09 <psi> ?where gtk2hs
13:00:10 <lambdabot> http://haskell.org/gtk2hs/
13:00:31 <wagle> cool..  thanks
13:00:34 <dave_m> what's the status of wxHaskell these days?
13:00:42 <swiert> lovecoder: n+k patterns are discussed on page 45.
13:01:50 <fasta> Are Cryptol by Galois and http://www.haskell.org/crypto/ different things?
13:01:51 <lambdabot> Title: The Haskell Cryptographic Library
13:02:21 <musasabi> fasta: yes, different things.
13:02:33 <fasta> musasabi: confusing, I'd say
13:02:43 <fasta> musasabi: thanks
13:02:58 <fasta> musasabi: Cryptol presumably is not open source?
13:03:50 <musasabi> fasta: afaik not open source. Ask the Galois people for details.
13:21:14 <psi> I wonder why emacs says something about haskell keymap when I run C-c C-l for the first time
13:21:20 <lovecoder> swiert:  ah, i forgot about that section, i remember going through it and wondering why introduce the special case of (n + k) ?
13:22:22 <psi> i've seen it in math before
13:22:27 <psi> i think it's merely confusing
13:24:16 <swiert> lovecoder: sure - I can imagine there's quite a lot to digest.
13:28:47 <Cale> lisppaste2: url
13:28:48 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:29:12 <lisppaste2> Cale pasted "while" at http://paste.lisp.org/display/28689
13:29:32 <Cale> that function should probably be somewhere (MonadState seems likely)
13:29:57 <Cale> I'm not 100% sure that it should be "the" while though
13:30:05 <Cale> perhaps whileS or some such
13:32:41 <dave_m> Perhaps there's a word for it. Someone check the OED
13:33:25 <wagle> Cale you;ve defined repeat ... until ...
13:34:00 <Cale> wagle: yes
13:35:10 <dave_m> then "repeatUntil" or "untilS" might be better
13:36:41 <sjanssen> @hoogle while
13:36:42 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
13:36:42 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
13:36:42 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
13:36:54 <dave_m> @hoogle until
13:36:55 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
13:36:56 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
13:37:28 * lispy notes that if associated types fill the same role as typical functional dependencies but do so more naturualy and directly that he doesn't think he'll use FDs anymore
13:37:28 <sjanssen> we ought to have something like "whileM :: (Monad m) => m Bool -> m () -> m ()"
13:38:06 <sjanssen> lispy: it will be a while before ATs are in a released compiler, I think
13:38:11 <wagle> i've seen a while in a prelude like file somewhere..  wasnt like cale's though
13:38:20 <sjanssen> not to mention Hugs compatibility
13:38:36 <dave_m> @hoogle unfoldM
13:38:37 <lambdabot> No matches found
13:38:38 <lovecoder> omg, i just found a web page that says there is a "Ban n+k patterns" movement?!
13:38:46 <Cale> lovecoder: yep :)
13:39:25 <lispy> lovecoder: http://www.mail-archive.com/haskell@haskell.org/msg01261.html ?
13:39:28 <lambdabot> Title: n+k patterns, http://tinyurl.com/yn53lb
13:40:37 <lovecoder> Actually, I got it from this page:  http://www.willamette.edu/~fruehr/haskell/evolution.html
13:40:40 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
13:41:14 <Cale> yeah, I was thinking that might be the one you saw :)
13:41:20 <wagle> ./packages/hugsbase/Hugs/Prelude.hs:until          :: (a -> Bool) -> (a -> a) -> a -> a
13:41:20 <wagle> ./packages/hugsbase/Hugs/Prelude.hs:until p f x     = if p x then x else until p f (f x)
13:41:20 <dave_m> people have been complaining about n+k since 1993? I have to stop thinking of Haskell as a "new" language
13:41:29 <lovecoder> I guess the movement must be gaining momentum, haven't decided which side I'm on :-)
13:42:04 <lovecoder> lol
13:42:08 <dave_m> wagle: until can't fully replace Cale's while, b/c you can
13:42:22 <dave_m> ...can't convert m Bool to Bool
13:42:33 <xerox> For some Monad m you can.
13:42:40 <Cale> hmm
13:42:45 <dave_m> right, but while was defined for any monad
13:42:52 <Cale> it doesn't have our favourite fac
13:43:05 <sjanssen> lovecoder: there is a good chance that n+k patterns won't be in the next Haskell standard
13:43:14 <lispy> dave_m: i read one of the laws or rules somewhere that a PL won't be popular until someone has spent about 15 years slaving over it trying to make it good and get people's attention
13:43:33 <Cale> > let fac n = fix ((0:) . scanl (+) 1) !! n in fac 45
13:43:35 <lambdabot>  1134903170
13:43:46 <wagle> when haskell is obsolete, it will become popular
13:43:57 <dave_m> lispy: Does, say, Java fit that pattern? Or C#?
13:44:07 <lispy> dave_m: java yes
13:44:12 <int-e> Cale: fac?!
13:44:21 <lispy> dave_m: and C# is just MSs version of java :)
13:44:23 <Cale> er, no fib
13:44:25 <ski> (forall m. Monad m => m Bool) -> Bool
13:44:28 <Cale> hehe, I'm not thinking :)
13:44:34 <dave_m> true enough. How old is Java, anyway?
13:44:48 <lispy> dave_m: java and haskell are pretty much the same age iirc
13:44:50 <int-e> > let fac n = scanl (*) 1 [1..] !! n in fac 45
13:44:52 <lambdabot>  119622220865480194561963161495657715064383733760000000000
13:44:55 <Cale> yes
13:45:06 <dave_m> right, but Java was popular 5-10 years ago
13:45:09 <Cale> hmm
13:45:19 <wagle> haskell started around 1988, java release around 1995
13:45:27 <Cale> int-e: I only got 4 hours of sleep :)
13:45:45 <int-e> Cale: Heh and I thought you were trying to be funny :)
13:46:02 <lispy> Cale: so what you're saying is that you can't write factorial in your sleep? ;)
13:46:03 <Cale> It's inexcusable, really :)
13:46:21 <Cale> however, I'm going to get a coffee :)
13:46:54 <lispy> java is older than '95
13:47:02 <lispy> esp. if you count oak
13:47:13 <lispy> (which is fair if you count haskell 1.0)
13:47:29 <wagle> "oak" == "java" --> False
13:47:48 * dave_m is trying not to think about how he would do a type-level factorial
13:47:53 <wagle> i'm counting haskell 0.8
13:48:07 <xerox> dave_m: that's fun!
13:48:20 <wagle> which i think had n+k patterns..  8/
13:48:35 <Cale> lispy: I suppose it's really that I can't tell the difference between fac and fib in my sleep :)
13:48:49 <Cale> lispy: I can still implement both :)
13:48:49 <dave_m> one major difference between Java and Haskell is that one was pushed by a major software corporation
13:49:24 <lispy> Cale: it's okay, you made a mistake and we have a public record.... :)
13:49:27 <thou> does Sun count as a major software corp?
13:49:28 <Cale> heh
13:49:33 <wagle> sun's more a hardware corp
13:49:40 <Cale> lispy: Perhaps I should consciously make more
13:50:08 <Cale> lispy: There seems to be a bunch of people (especially those in #math) who somehow have got the impression that I'm perfect and infallible.
13:50:25 <Cale> (while this could not be farther from the truth)
13:50:30 <dave_m> they're a major corporation and they make software
13:50:36 <thou> :-)
13:51:04 <lovecoder> i think i almost got it, tell me if i'm there... whenever there is an (n + k) on the left hand side, with k >= 1, it says that this applies to all n >= k ... on the right hand side, it is implied that n = n - 1 ... am i going off on a tangent?
13:51:21 <wagle> microsoft makes mice, so they are a major hardware corp?
13:51:38 <lispy> wagle: they make the xbox too
13:51:44 <wilx> Well...Sun makes OS and major programming language. Are they still not sw corp?
13:51:44 <lispy> wagle: "make"
13:52:10 <lispy> i'd say the xbox is more significant hardware than some hardware companies make
13:52:37 <dave_m> IBM has also promoted Java heavily
13:52:54 <wagle> oh well..
13:53:07 <wilx> Back to Eureka 7.
13:53:07 <lispy> dave_m: another reason to distrust java? ;)
13:53:10 <lovecoder> sjanssen: plz check what i understand so far, a few lines above ... :-)
13:53:16 <thou> dave_m: i didn't mean to clobber your point, which was very valid
13:53:25 <nomeata> Is it possible to make ghc accept nice unicode characters in the source code? · for the function compositoin, × for multiplication, → in a lambda, a real lambda etc?
13:53:30 <thou> java had lots of promotion from some big pockets
13:53:44 <lispy> > let f (n+1) = show n in f 4
13:53:45 <lambdabot>  Parse error in pattern
13:53:50 <thou> i was just trying to make a joke at sun's expense
13:53:53 <sjanssen> lovecoder: n = x - k -- where x is some variable the compiler generates for you
13:54:07 <dave_m> actually, the popularity of Java has probably made it harder to improve the language. Backward compatibility and all
13:55:05 <lispy> oh wow, n+k patterns are sort of evil
13:55:07 <sjanssen> nomeata: some of those things work
13:55:13 <dave_m> I shudder to think what Haskell would be like if it had that level of penetration
13:55:16 <lispy> > let { f (n+1) = show n } in f 4
13:55:16 <lambdabot>  Parse error in pattern
13:55:25 <lovecoder> sjanssen: yes, i see
13:55:26 <lispy> that works in ghci
13:55:41 <sjanssen> lispy: I know the problem
13:55:52 <lispy> Prelude> let { f (n+1) = show n } in f 4
13:55:52 <lispy> "3"
13:55:59 <sjanssen> lispy: the haskell-src library doesn't parse n+k
13:56:02 <nomeata> > let f = λ x → x × x in (f · f) 2
13:56:02 <lambdabot>  Illegal character ''\187''
13:56:20 <lovecoder> ok, that does it, hopefully i can forget about n+k now and move on with understanding the rest of the recursion chapter!! :-)
13:56:31 <sjanssen> nomeata: have you tried any of this stuff in GHC 6.6?
13:56:47 <nomeata> sjanssen: no, I’m waiting for a fixed ghc package in debian to install it
13:56:55 <nomeata> what ghc is lambdabot running on?
13:56:58 <lispy> n+k implies n >= k, that seems a little harsh
13:57:25 <sjanssen> nomeata: ah.  As I understand it, certain Unicode stuff works, like the upside down A accepted instead of forall
13:57:27 <lispy> and no (n-k) patterns
13:57:29 <emu> i'm writing an Arbitrary instance for some quick checks, is there a way to see an example randomly generated test case besides running verboseCheck?
13:57:30 <dave_m> there's a list somewhere of what Unicode characters GHC accepts
13:57:51 <Dreadshoot> anyone installed hs-plugins in mingw?
13:58:27 <lovecoder> lispy: is that not the case?  i thought  n+k implies n >= k ??  or did you mean that that is the case, and it's a hard restriction ?
13:59:08 <lispy> lovecoder: it is the case and i see it as a bit restrictive
13:59:15 <nomeata> dave_m: can you give me a pointer where I can find it?
13:59:31 <wagle> lovecoder, i think n is a variable and k is a constant
13:59:32 <lovecoder> another page i found somewhere says someone wants a c*n+k pasttern too, i don't know if i'd like to see that in my beginner's tutorial
13:59:34 <dave_m> nomeata: unfortunately, I can't seem to find it
13:59:52 <nomeata> neither can I
14:00:18 <ValarQ> isn't it bad enough to have n+k patterns?
14:00:21 <nomeata> and google is not smart enough to search for “haskell →”
14:00:46 <dave_m> One of the Simons posted a list somewhere.
14:00:54 <lispy> ?\200\234haskell ?\206'?\200\235 is an odd search
14:00:54 <lambdabot> Unknown command, try @list
14:01:31 <lispy> but actually, google supports unicode searches
14:01:44 <lispy> i was doing them the other day as an experiment
14:01:49 <lispy> worked great for me
14:01:52 <nomeata> lispy: but not for single character it seems. my → was ignored
14:01:52 <lovecoder> lispy: oh ok, thanks!
14:02:33 <sjanssen> lisppaste2: url
14:02:33 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
14:02:53 <lispy> Prelude> let { f (n+1) = show n } in f 0
14:02:53 <lispy> "*** Exception: <interactive>:1:6-21: Non-exhaustive patterns in function f
14:03:08 <lisppaste2> sjanssen pasted "from Lexer.x -- let's hope lisppaste doesn't mangle this" at http://paste.lisp.org/display/28694
14:03:23 <sjanssen> bah, it doesn't show up correctly
14:03:49 <nomeata> dave_m:  this one? http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
14:03:51 <wagle> sjanssen, need to define f 0 =
14:03:53 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
14:03:56 <sjanssen> the source can be found here: http://darcs.haskell.org/ghc/compiler/parser/Lexer.x
14:03:59 <lambdabot> http://tinyurl.com/ya6bs8
14:04:15 <sjanssen> or you can look at the actual docs.  Whatever floats your bout ;)
14:04:18 <dave_m> I thought I had seen something in the GHC docs or release notes, but I could be wrong
14:04:46 <lispy> wagle: if you meant to tel me to define f 0, i was just doing an example to show (n+k) implies n >= k
14:04:49 <wagle> sjanssen, its aassumed that n >= 0
14:05:25 <wagle> lisppaste2, show me where n < 0
14:05:26 <sjanssen> wagle: hmm?
14:06:12 <lispy> Prelude> let { f (n+1) = show n } in f 0
14:06:15 <lispy> "*** Exception: <interactive>:1:6-21: Non-exhaustive patterns in function f
14:06:16 <wagle> sjanssen, i'm confused..  i thought i was responding to your paste when i wasnt
14:06:18 <lispy> that one?
14:06:51 <wagle> lispy, f (n + 1) defines f for positive arguments
14:07:00 <lispy> i know
14:07:09 <lispy> but i think it's restrictive
14:07:14 <lispy> that's all
14:07:18 <lispy> end of sttory :)
14:07:18 <dave_m> So a naive factorial defined using n+k patterns won't loop if you pass it a negative number?
14:07:21 <wagle> has nothing to do with comparing n to k
14:07:42 <lispy> > let f n = n in f (-4)
14:07:44 <lambdabot>  -4
14:07:54 <nomeata> nice, it has all the unicode characters, besides · and ×. it even supports …
14:08:02 <nomeata> I’m looking forward to ghc6.6
14:08:06 <wagle>  let { f (n+1) = show n } in f (-4)
14:08:09 <sjanssen> dave_m: it will return _|_, which is indistinguishable from looping forever ;)
14:08:12 <wagle> > let { f (n+1) = show n } in f (-4)
14:08:13 <lispy> but making that (n+1) suddenly makes it stop matching n < 1
14:08:13 <lambdabot>  Parse error in pattern
14:08:16 <profmakx> isnt ghc 6.6 already out?
14:08:27 <nomeata> yes, but not gtk2hs for ghc
14:08:44 <sjanssen> nomeata: you can probably define (·) as an alias for (.)
14:08:53 <dave_m> sjanssen: that depends on how patient you are. If my program has a bug, I'd rather know sooner than later
14:10:15 <lispy> for example, pred (n+1) = n, only works for n > 0, maybe that's okay if you only have naturals, but mabye i meant all nums
14:10:30 <nomeata> > let (·) = (.) in (id · id ) 1
14:10:30 <lambdabot>  Illegal character ''\183''
14:10:35 <wagle> so you want overlapping patterns instead?
14:10:58 <dave_m> Haskell's always had overlapping patterns
14:11:12 <dave_m> think, f 0 = True; f _ = False
14:11:20 <lispy> pred (n+1) = n; pred n = n - 1
14:11:25 <lispy> that seems a little silly
14:11:25 <sjanssen> nomeata: the haskell-src parser probably doesn't support Unicode
14:11:36 <wagle> > let { f (n+1) = show n ; f 0 = "boo!" } in f (-4)
14:11:37 <lambdabot>  Parse error in pattern
14:11:55 <dave_m> lambdabot doesn't like n+k patterns
14:13:42 <sjanssen> nomeata: actually, the problem is higher than that.  Lambdabot doesn't interpret it's input as UTF-8
14:13:49 <lispy> and this is without considering lennart's original question, what if i supply a new local definition of (+)?
14:14:03 <ValarQ> nomeata: the dev version works very well with ghc6.6
14:14:31 <dave_m> IIRC, n+k is defined to use Prelude.-
14:14:54 <dave_m> With GHC, you can probably change that with rebindable syntax
14:15:31 * SamB wonders if there is a combinator library for drawing ASCII-art trees?
14:15:37 <dave_m> n+k is not my favorite part of the language, but I never use it, so it doesn't bother me
14:15:38 <lispy> dave_m: http://www.mail-archive.com/haskell@haskell.org/msg01275.html
14:15:40 <lambdabot> Title: Re: n+k patterns, http://tinyurl.com/yhfkzp
14:16:25 <dave_m> ah, but see http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
14:16:26 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/yarpwy
14:16:36 <lispy> dave_m: well, that's an argument to remove it from the language (no one seems to use it in practice, it confuses people in some cases and it adds complexity to implementations)
14:17:14 <dave_m> true enough. If I were implementing Haskell, I'd feel more strongly about it
14:18:02 <SamB> so, how should I print out a binary tree...
14:18:36 <dave_m> there are a few papers on about printing binary trees. I usually steal Daan Leijen's code from DData.Set
14:18:50 <psi> the docs for the parsec function <|> says that first parser mustn't consume input - does that mean that the two alternatives must differ in the first character?
14:19:05 <dave_m> psi: yes, unless you use "try"
14:19:33 <psi> ah
14:19:34 <SamB> (this kind of thing is why lexers are popular, probably)
14:20:01 <lispy> SamB: lexers, bah humbug! ;)
14:20:05 <velco> > let pt = [1] : [1 : (zipWith (+) x (tail x)) ++ [1] | x <- pt] in take 3 pt
14:20:06 <lambdabot>  [[1],[1,1],[1,2,1]]
14:20:43 <velco> > let pt = [1] : [1 : (zipWith (+) x (tail x)) ++ [1] | x <- pt] in take 6 pt
14:20:44 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1]]
14:20:47 <lispy> is that a fib sequence?
14:20:49 <lispy> hmm...
14:21:00 <dave_m> speaking of parsing, anyone here tried Frisby?
14:21:00 <dolio> It's Pascal's Triangle.
14:21:09 <lispy> ah, so it is
14:22:19 <SamB> dolio: I tried it a while back
14:22:26 <SamB> but I gather it has changed a lot since
14:22:42 <SamB> so my impressions are most likely completely invalidated
14:22:53 <dolio> Tried what?
14:23:02 <SamB> oh
14:23:03 <SamB> sorry
14:23:08 <SamB> I meant dave_m :-(
14:23:16 <dolio> Heh.
14:23:17 * SamB wonders how he got mixed up
14:23:31 <dave_m> off-by-one error
14:23:40 * SamB almost suspects x-chat of having drawn dave_m's text next to dolio's nicm
14:23:43 <SamB> er. nick.
14:26:40 <dave_m> Since PEGs subsume regular expressions, I thought it might be good for a Markdown processor
14:27:27 * SamB really wonders how you'd get decent ascii art for binary trees...
14:27:27 <dave_m> On further thought, though, it may not be powerful enough
14:27:40 <dave_m> SamB: vertical or horizontal?
14:27:54 <SamB> I was thinking the leaves would be at the right
14:28:09 <SamB> the "left" branches at the top
14:28:37 <dave_m> check out the source for the sets in DData, http://www.cs.uu.nl/~daan/ddata.html
14:28:52 <dave_m> specifically, the "showTree" function
14:29:09 <dave_m> I don't know if that made it into Data.Set
14:29:19 <SamB> the docs look the same
14:29:31 <dave_m> @hoogle showTree
14:29:32 <lambdabot> Data.IntMap.showTree :: Show a => IntMap a -> String
14:29:32 <lambdabot> Data.IntSet.showTree :: IntSet -> String
14:29:32 <lambdabot> Data.Map.showTree :: (Show k, Show a) => Map k a -> String
14:29:50 * edwardk waves hello.
14:29:54 <dave_m> I guess it did make it. Check the source code for showTree. It's fairly general
14:30:51 <edwardk> dave_m: finally got around to reading the paper that your control.comonad stuff took a lot of its examples from, neat stuff (both your package and the paper)
14:30:59 <dave_m> > Data.IntSet.showTree $ Data.IntSet.fromList [1..5]
14:31:00 <lambdabot>  Not in scope: `Data.IntSet.fromList'
14:31:41 <dave_m> edwardk: thanks
14:31:49 <mux> @where gstreamer
14:31:49 <lambdabot> I know nothing about gstreamer.
14:32:06 <mux> does anyone know if there are haskell bindings for gstreamer available somewhere?
14:32:08 <edwardk> been wrestling with a bunch of comonads lately from a different perspective
14:32:15 <dave_m> I should post that comonad transformer code I have lying around
14:32:21 <edwardk> wooo
14:32:24 <edwardk> that i would like to see
14:32:45 <edwardk> what transformers have you got?
14:33:09 <mathewm> star scream
14:33:13 <edwardk> none of mine can really be expressed in haskell, coz they all deal with substructural types
14:33:14 <edwardk> hhahaha
14:33:21 <dave_m> context, reader, and writer
14:33:26 <edwardk> makes sense
14:33:44 <edwardk> all of the ones that straddle the monad/comonad boundary
14:34:40 <mux> @seen dcoutts_
14:34:41 <lambdabot> dcoutts_ is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 3h 17m 34s ago.
14:34:51 <edwardk> are you still playing with them, or have they kind of faded into the background for you?
14:35:21 <dave_m> I go through cycles
14:35:27 <edwardk> fair enough
14:37:19 <dave_m> I did come up with a way to make any comonad into an instance of Applicative
14:37:28 <edwardk> oh?
14:37:45 <edwardk> i spent a lot of time on trying to come up with a usable notion of coapplicative that fit them
14:37:51 <edwardk> and didn't get very far
14:37:56 <edwardk> there turned out to be an issue
14:38:04 <edwardk> at least in a haskell like context
14:38:59 <dave_m> I suspect that comonads won't turn out to be useful in source code the way monads are
14:39:12 <edwardk> well, it seems to me they express entirely different concepts.
14:39:47 <dave_m> Essentially, if w is a comonad, then T w a = forall b. w b -> (a,b) is Applicative
14:39:49 <edwardk> I find them amazingly useful for describing additional properties you want to allow your types to have temporarily, in terms of extra laziness, controlled contraction, etc.
14:40:12 <edwardk> ah
14:40:55 <edwardk> and if you change your perspective to a linear type system, then the 'unrestricted' modality is a comonad that permits contraction and weakening.
14:40:59 <dave_m> when I found that, I realised that the comonadic code I was playing with was mostly Applicative code written in an awkward fashion
14:41:09 <edwardk> similarly 'relevant' is a comonad in a linear type system
14:41:27 <edwardk> yeah
14:41:40 <edwardk> there aren't many good use cases for them in the haskell type system
14:42:08 <edwardk> because you are already so far 'down' in the substructural type space, at least so it seems.
14:42:14 <dave_m> agreed
14:42:24 <edwardk> you can view laziness as a comonad in a strict language, but we're already lazy
14:42:54 <edwardk> you can view removal of various restrictions as a comonad, but we don't have those restrictions to remove.
14:43:04 <dave_m> do you need a full comonad for that? it seems like a functor would be enough
14:43:11 <dave_m> that = laziness
14:43:12 <edwardk> laziness?
14:43:26 <edwardk> well, in my case i'm using a comonad coz i have a nice family of them that commute
14:43:36 <edwardk> and it gives a nice symmetry with my strictness monad =)
14:43:36 <dave_m> well, there's that
14:43:49 <edwardk> coz my default evaluation order is currently undefined
14:44:37 <edwardk> so by careful saying that i get the worst properties of value and need evaluation, with the ability to claim the abilities of either by placing myself in an appropriate context.
14:44:43 <Cale> I don't think that the space of comonads has been completely mined for ideas, though you might be right. I also think we may eventually see some more interesting uses for adjunctions.
14:44:58 <edwardk> yeah
14:45:23 <edwardk> i haven't found many good uses for comonads in haskell. it seems like they'd be really useful in introducing laziness to strict languages though
14:45:43 <SamB> *Huffman> putStr . showTree False . snd . huffman . map swap $ countLetters "n+k is not my favorite part of the language, but I never use it, so it doesn't bother me"
14:45:43 <SamB>       +--'t'
14:45:43 <SamB>    +--+
14:45:43 <SamB>    |  |  +--'s'
14:45:43 <SamB>    |  +--+
14:45:45 <SamB>    |     |  +--'v'
14:45:47 <SamB>    |     +--+
14:45:48 <edwardk> there they serve the same role, but then you already have the even-odd kind of delay/force laziness
14:45:49 <SamB>    |        +--'y'
14:45:51 <wagle> edwardk, what language do you use comonads in?
14:45:53 <SamB> +--+
14:45:55 <SamB> |  |  +--'o'
14:45:57 <SamB> |  +--+
14:45:59 <SamB> |     +--'n'
14:46:01 <SamB> +
14:46:03 <SamB> +--' '
14:46:05 <int-e> akh
14:46:07 <SamB> nice...
14:46:09 <SamB> cohaskell, duh
14:46:10 <edwardk> wagle: in my case i'm writing one to play with lots of substructural types
14:46:11 <edwardk> heh
14:46:14 <int-e> paste!
14:47:18 <int-e> SamB: anyway, who said that?
14:47:30 <SamB> int-e: said what?
14:47:42 <Cale> Can the stream-processing applications of comonads be rewritten using only applicative functors?
14:47:44 <int-e> the n+k pattern comment. I want to know who I agree with ;)
14:47:50 <dave_m> I'm not familiar with substructural types.
14:48:11 <edwardk> dave_m: well, one place to start is with linear logic, another is with uniqueness typing
14:48:40 <dave_m> so what does "substructural" mean in that context?
14:48:52 <SamB>  <dave_m> n+k is not my favorite part of the language, but I never use it, so it doesn't bother me
14:49:07 <edwardk> well, the idea is that if you remove some of the rules of logic, then the curry howard isomorphism still holds.
14:49:16 <dave_m> I thought that quote sounded familiar
14:49:21 <SamB> heh
14:49:25 <edwardk> so its a 'substructural' logic in the sense that some of the rules are missing.
14:49:28 * SamB forgot it was in there
14:49:42 <SamB> I was just using it to test my huffman tree building algorithm
14:50:02 <SamB> or rather my implementation of the one in Sorting and Searching
14:50:04 <edwardk> so if you say that given a, and a -> b, you can't reference a after you apply the function, then you get a 'affine' logic, etc, then you can build a lambda calculus in which variables can be used only once from that.
14:50:14 <dave_m> edwardk: gotcha. I've read a little about linear logic
14:51:01 <dave_m> but I haven't had the insight where I understand why you need two "and" operators
14:51:20 <SamB> which... doesn't seem to work
14:52:03 <edwardk> i've been researching different ways to describe the minimum set of properties an object has to have to play its role in a given lambda calculus expression, so that I can construct principal types that can infer over a lattice of possible substructural type annotations, obviating the need to write down whether the type is linear, unique, etc in most cases. hindley milner for linear logic basically.
14:52:14 <edwardk> and well, for more general logics than linear.
14:52:24 <dave_m> sounds cool
14:52:54 <edwardk> dave_m: the difference comes down to what terms you need to use up to get your pair. lets think about the way linear logic works for a sec.
14:53:06 <dave_m> okay
14:53:33 <Syzygy-> There are times when I wonder how much of the discussion in here is actually a component of someone working on a PhD thesis or a publishable original research article.
14:53:47 <edwardk> dave_m: on one hand, i could use up a bunch of linear resources to get a, and a different bunch of linear resources to get b. in which case i can have a and b simultaneously. we say then I have a tensor b.
14:53:51 <edwardk> that is our first 'and'
14:54:17 <edwardk> in that context i can have both things at the same time.
14:54:28 <dave_m> Syzygy-: how long until someone cites #haskell in a paper?
14:54:37 <edwardk> we can view it if we use linear propositions as resources as there being a 'world' in which i can have both a and b at the same time
14:54:37 <velco> heh
14:55:07 <dave_m> edwardk: sounds good so far
14:56:36 <nomeata> > length "\&"
14:56:38 <lambdabot>  0
14:56:59 <dave_m> that doesn't seem right
14:57:28 <wagle> > "\&" == ""
14:57:29 <edwardk> ok, now, i might have to use up one set of resources in one of two different ways, but i haven't done so yet. so in the future a decision has to be made, and in that future i control the decision, so i can obtain either a or b, but not both, but the decision is mine.
14:57:30 <lambdabot>  True
14:58:12 <nomeata> might be an interesting way to confuse people
14:58:20 <edwardk> that is a with b. its like having an option to buy either one.
14:58:52 <dave_m> edwardk: okay
14:59:20 <edwardk> but when you commit to one or the other, you lose the other alternative. i only have money to buy a beer or a soda, but i haven't committed yet. so its kind of like a set of optional futures.
14:59:20 <wagle> > '\&'
14:59:21 <lambdabot>  Illegal escape sequence
14:59:38 <edwardk> so i still have the option to have either, but i can only have one not both, thats 'additive conjunction' and is your second 'and'
14:59:41 <dave_m> I haven't seen the \& escape sequence before. what's the rationale?
15:00:21 <wagle> dave_m, i havent either
15:00:39 <edwardk> now, this is somewhat different from another idea 'additive disjunction' where i have a function that i can call which will give me back either an a or a b, but i don't know what i'm going to get back.
15:01:02 <dave_m> right, because you make the decision
15:01:24 <edwardk> so if i'm reasoning about whether or not i can reach a world in which I have an A. I have to honestly answer that I don't know. unlike the additive conjunction case i don't control the decision.
15:01:30 <nomeata> > "\12312"
15:01:31 <lambdabot>  "\12312"
15:01:34 <nomeata> > "\123\&12"
15:01:35 <lambdabot>  "{12"
15:01:45 <nomeata> to end escape sequences
15:01:55 <dave_m> nomeata: ah. clever
15:02:34 <nomeata> and it workds as expected:
15:02:34 <nomeata> > "\&\&\&\&\&" == replicate 5 "\&"
15:02:35 <lambdabot>  Couldn't match `Char' against `[Char]'
15:02:38 <dave_m> edwardk: right, that makes sense
15:02:45 <edwardk> so so far we have three ideas, two states we can have at the same time, a pair of states that are mutually exclusive that i control, and a pair of states that are mutually exclusive that I don't control. there is one more case thats harder to get your head around, and requires multiple simultaneous goals.
15:02:50 <nomeata> > "\&\&\&\&\&" == concat $ replicate 5 "\&"
15:02:51 <lambdabot>    Expecting a function type, but found `a'
15:02:51 <lambdabot>    Expected type: [Char]
15:02:51 <lambdabot>   ...
15:03:18 <nomeata> :t replicate
15:03:29 <dave_m> @type replicate
15:03:31 <lambdabot> forall a. Int -> a -> [a]
15:03:40 <nomeata> @type concat.replicate
15:03:42 <lambdabot>   Expecting a function type, but found `b'
15:03:42 <lambdabot>    Expected type: Int -> [[a]]
15:03:49 <nomeata> @type concat.(replicate 5)
15:03:50 <lambdabot> forall a. [a] -> [a]
15:03:54 <Eidolos> @type "\&"
15:03:56 <lambdabot> [Char]
15:04:08 <nomeata> > "\&\&\&\&\&" == (concat . replicate 5) "\&"
15:04:09 <lambdabot>  True
15:04:27 <nomeata> oh, $ has higher precedence than == it seems
15:04:43 <nomeata> > "\&\&\&\&\&" == (concat $ replicate 5 "\&")
15:04:44 <lambdabot>  True
15:05:00 <dave_m> ($) has a very low precedence
15:05:13 <nomeata> or lower, whichever is the right one :-)
15:05:25 <nomeata> I’d prefer to say earlier and later
15:05:31 <wagle> > "" == (concat $ replicate 5 "\&")
15:05:33 <lambdabot>  True
15:05:41 <nomeata> but then, that’s confusing if you mix lazy and eager...
15:05:51 <nomeata> darn, wagle blew my cover :-)
15:05:51 <edwardk> but the you can get there by playing with dualities and have it make sense. that last connective is called a par b. which is kind of like getting back a bunch of functions that i can use to get the answer, but not knowing if i'll like the answer until i get it. =/ so its like having more control than the additive disjunction case. given 2 copies of a par b   in other words, (a par b) tensor (a par b)  i can exhaust all alternatives and get both an a and 
15:06:11 <nomeata> > cycle []
15:06:11 <lambdabot>  Add a type signature
15:06:16 <nomeata> > cycle ""
15:06:17 <lambdabot>  Exception: Prelude.cycle: empty list
15:07:10 <edwardk> so if i have a function i know will give me an a or a b depending on whether i pass it true or false, and will give me whatever i didn't get the first time if i were able to use it again, then given two copies of it, i could get both things.
15:07:49 <dave_m> could you also use it to get the same thing twice?
15:07:51 <edwardk> even if i didn't know which call i would get the things from.
15:07:58 <nomeata> @let bi = (replicate 2)
15:07:59 <lambdabot> Defined.
15:08:21 <nomeata> @let (o-o) = L.bi.cycle
15:08:21 <lambdabot>  Parse error in pattern
15:08:43 <nomeata> @let (°-°) = L.bi.cycle
15:08:43 <lambdabot>  Illegal character ''\176''
15:08:49 <edwardk> well, i could 'pull the same lever' by calling each of the copies of the function with true each time, in which case i will get back (a tensor a) plus (b tensor b) coz i know i'll get two of something, and they'll be the same thing, but i don't know which i'll get.
15:08:53 <nomeata> darn. I want a bicyle operator.
15:09:12 <nomeata> @let dxo = L.bi.cycle
15:09:13 <lambdabot> Defined.
15:09:14 <dave_m> right, that makes sense
15:09:19 <edwardk> coz you can think of our perspective as being in the past making a decision about something that hasn't happened yet
15:09:19 <kpreid> @let (0-0) = L.bi.cycle
15:09:20 <lambdabot>  Parse error in pattern
15:09:27 <nomeata> ok, that looks a bit like a bicycle
15:09:27 <kpreid> @let o-o = L.bi.cycle
15:09:28 <lambdabot> <local>:4:0:     Conflicting definitions for `o'     In the definition of `L.-'
15:09:41 <nomeata> either only letters or only symbols
15:09:54 <edwardk> and if you view linear logic as a logic of what might happen in the future, then i think it makes perfect sense
15:09:59 <kpreid> it's the parentheses that aren't allowed
15:10:29 <nomeata> well, you need the parentheses to define a infix operator consisting of symbols
15:10:49 <dave_m> unfortunately, "o" isn't a symbol
15:10:53 <nomeata> right
15:11:02 <nomeata> @let (*-*) = L.bi.cycle
15:11:03 <lambdabot> Defined.
15:11:14 <edwardk> now, i like to control contraction and weakening separately, so i work in logics that give me more control than linear. but you can view then as just adding a bunch of axioms to a linear logic that say things like given the presence of this comonad (!) I can take !A and duplicate it or extend it, etc.
15:11:14 <dave_m> how about @-@?
15:11:26 <edwardk> just like the comonads you know and love
15:11:28 <nomeata> that nice, two
15:11:32 <dave_m> right
15:11:44 <edwardk> so if an unlimited number of As an get me one B then they can get me an unlimited number of Bs, etc.
15:11:54 <dave_m> sure
15:12:02 <edwardk> so all of the comonad properties drop out
15:12:19 <edwardk> relevance does the same thing.
15:12:24 <dave_m> there's a similar pattern in modal logic
15:12:27 <edwardk> yeah
15:12:32 <edwardk> possibility as a comonad
15:12:37 <nomeata> @let bi l e = zip l (cycle e)
15:12:38 <lambdabot> <local>:5:0:     Multiple declarations of `L.bi'     Declared at: <local>:2:0...
15:12:58 <edwardk> you can remove the possibility by saying it 'has happened' and changing your perspective to that moment in time, thereby removing the <> modality
15:13:22 <edwardk> coz most modal logics deal with necessity and possibility in a forward looking manner
15:13:42 <edwardk> and the structure is identical coz <> is a comonad =)
15:13:51 <edwardk> at least in most modal logics
15:14:20 <nomeata> @let bi l e = zip l (cycle e)
15:14:21 <lambdabot> Defined.
15:14:40 <nomeata> > 'O' L.bi.cycle 'o'
15:14:41 <lambdabot>    The function 'O' is applied to one arguments,
15:14:41 <lambdabot>   but its type `Char' ha...
15:14:52 <sfultong> >  until ((== 5) . fst) (\(x, y) -> (x + 1, y >> (putStrLn $ show x))) (0, putStrLn "begin")
15:14:53 <lambdabot>  No IO allowed
15:14:53 <nomeata> > 'O' L.*-* 'o'
15:14:54 <lambdabot>  Not in scope: `L.*-*'
15:15:17 <nomeata> > let (*-*) in 'O' *-* 'o'
15:15:17 <lambdabot>  Parse error
15:15:30 <nomeata> > let (*-*) = L.bi.cycle in 'O' *-* 'o'
15:15:31 <lambdabot>  Couldn't match `[a]' against `Char'
15:15:33 <edwardk> er.. gotta run, be back in 10
15:16:47 <nomeata> > let (*-*) = L.bi.cycle in ")-" *-* "-("
15:16:48 <lambdabot>  [(')','-'),('-','('),(')','-'),('-','('),(')','-'),('-','('),(')','-'),('-',...
15:17:02 <nomeata> almost a bicycle factory
15:17:27 <nomeata> @let bi l e = zipWith (++) l (cycle e)
15:17:28 <lambdabot> Couldn't match `(a, a1)' against `[a2]'
15:17:30 <nomeata> @undefine bi
15:17:31 <lambdabot> Undefined.
15:17:41 <nomeata> @let bi l e = zipWith (++) l (cycle e)
15:17:42 <lambdabot> Defined.
15:17:45 <nomeata> > let (*-*) = L.bi.cycle in ")-" *-* "-("
15:17:46 <lambdabot>  Couldn't match `[a]' against `Char'
15:18:42 <nomeata> > let (*-*) = L.bi.cycle in [")-"] *-* ["-("]
15:18:43 <lambdabot>  [")--(",")--(",")--(",")--(",")--(",")--(",")--(",")--(",")--(",")--(",")--(...
15:19:15 <nomeata> > let (*-*) = L.bi.cycle in [@\-"] *-* ["-@"]
15:19:15 <lambdabot>  Parse error
15:19:21 <nomeata> > let (*-*) = L.bi.cycle in ["@\-"] *-* ["-@"]
15:19:21 <lambdabot>  Illegal escape sequence
15:19:26 <nomeata> > let (*-*) = L.bi.cycle in ["@\\-"] *-* ["-@"]
15:19:27 <lambdabot>  ["@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\...
15:19:36 <nomeata> ok, enough biking for today
15:22:12 <int-e> > concatMap concat . sequence $ [["I want a "],["red","blue","green","yellow","pink","gray","black","white"],[" bikeshed! "]]
15:22:14 <lambdabot>  "I want a red bikeshed! I want a blue bikeshed! I want a green bikeshed! I w...
15:24:54 <dibblego> wtf is with bikesheds lately?
15:25:19 <int-e> we couldn't agree on a proper name for  intercalate ;)
15:25:34 <sjanssen> > let intercalate x xs = concat $ intersperse x xs in intercalate " bikeshed, " ["red","blue","green","yellow","pink","gray","black","white", "bleh!"]
15:25:36 <lambdabot>  "red bikeshed, blue bikeshed, green bikeshed, yellow bikeshed, pink bikeshed...
15:25:37 <glguy> they decided against intercalate?
15:25:55 <sjanssen> oh, I really hope intercalate isn't the decided word
15:26:05 <glguy> I really hope that join isn't
15:26:11 <int-e> I don't think there was any clear decision. (But I hope HE WHO MAKES THE PATCH gets to decide)
15:26:28 <sjanssen> glguy: yeah, join is taken by Control.Monad, so it's a no-go
15:26:33 <int-e> join would be stupid, because it exists in Control.Monad. :)
15:26:41 <glguy> that came up in the discussion
15:26:51 <glguy> didn't seem to phase some people
15:27:27 <dave_m> we could rename "join" to "mu". it would help make Monads scarier
15:27:48 <int-e> but then what would I do with my Mu module?
15:28:15 <int-e> oh, that doesn't even define 'mu' ... funny.
15:28:38 <dave_m> once we get that Unicode source working, we'll just call it μ.
15:28:59 <int-e> is that a capital letter or not?
15:29:05 <glguy> There's a reason that APL's decendent doesn't use symbols
15:29:15 <int-e> My Mu is a type constructor (well, a newtype)
15:29:15 <dave_m> and we'll change "return" to "η"
15:29:43 <glguy> sweet, my irc client displayed the eta correctly :)
15:29:55 <int-e> I don't mind unicode aliases but I think the standard lib stuff should also have pure ASCII names.
15:30:14 <int-e> Oh well. Another bikeshed :)
15:30:34 <glguy> I wouldn't mind if the unicode stuff was only something that lhs2TeX did
15:30:53 <dave_m> I was just kidding. Those are terrible ideas.
15:30:54 <int-e> dibblego: btw in case you didn't know it: http://www.bikeshed.org/
15:30:56 <lambdabot> Title: Why Should I Care What Color the Bikeshed Is?
15:31:24 <int-e> (bikeshed.org is funny with javascript. a new background color is chosen every time you reload it ;)
15:33:01 <dibblego> someone has said what I have wanted to say for a long time!
15:33:16 <dibblego> "the amount of noise generated by a change is inversely proportional to the complexity of the change" -- so true
15:33:32 <dave_m> actually, I've wondered about the impact of Haskell Unicode source on Greek programmers, who might want λ to be available for variables
15:35:36 <int-e> hmm. uυ∪
15:36:22 <psi> dave_m: you can use λ for variables now
15:37:00 <psi> dave_m: λ instead of \ doesn't work
15:37:05 <dave_m> which Haskell implementations support that?
15:37:13 <psi> ghc
15:37:20 <dave_m> GHC 6.6 translates λ to \
15:37:21 <psi> dunno about the rest
15:37:26 <int-e> Ok, so I'll call Mu Μ ... hopefully noone confues it with M.
15:37:40 <psi> dave_m: it doesn't, actually
15:37:48 * SamB_XP thinks people should just program in English
15:38:00 <SamB_XP> hmm, what do greek mathemeticians do anyway?
15:38:08 <dave_m> Oh? They said it would.
15:38:11 <glguy> Ascii was good enough for Jesus, and it's good enough for you!
15:38:17 <SamB_XP> hahaha
15:38:37 <lennart> English was good enough for Jesus too
15:38:40 <dave_m> Pff. Everyone knows Jesus used EBCDIC
15:39:04 <dave_m> It was the olden days, after all
15:39:06 <SamB_XP> right...
15:39:07 <sieni> lennart: of course, why would he otherwise have written the king james bible?
15:39:16 <lennart> exactly
15:40:07 <dave_m> how'd he get his dialogue to appear in red? ANSI codes?
15:40:08 <lennart> Personally I have a weakness for BCD/PTT-6 encoding.
15:41:08 <lennart> you don't see it much anymore...
15:41:26 <int-e> that's probably a good thing :)
15:41:40 <lennart> i've only ever seen it in some old olivetti terminals
15:42:06 <int-e> but of course we couldn't live without an encoding mess and came up with half a dozen (or so) ways to encode Unicode.
15:42:15 <psi> dave_m: probably mirc codes. i guess my client filters them because i didn't see anything.
15:42:52 <dave_m> psi: I meant Jesus. Some bibles print his speech in red
15:43:04 <psi> dave_m: oh! heh.
15:43:14 <dave_m> gotta run
15:44:26 <sjanssen> int-e: the endianness issue really grinds my gears.  Why should we have both UTF-16BE and LE?
15:44:41 <int-e> sjanssen: because we can?
15:44:50 <sjanssen> bleh
15:44:55 <glguy> sjanssen: why do you care what color the bikeshed is?
15:44:56 <glguy> ;)
15:45:39 <glguy> it'd be fun to write a document that could be read in either LE or BE
15:45:45 <sjanssen> glguy: I really don't care what color (endianness) the bikeshed is.  It just needs do be one damn color (endianness)
15:46:10 <glguy> sjanssen: it's both in an attempt to kill it
15:46:10 <int-e> sjanssen: But rainbows are pretty!
15:46:22 <glguy> sjanssen: and bring everyone back to ascii
15:46:56 <AvengerX> Hi, can anyone give me a hand with basics of a 'simple socket listener and reader' with Haskell?
15:47:18 <AvengerX> I know already I'd use the Network module, but dunno even how to call it. :)
15:47:20 <sjanssen> glguy: perhaps we should try that with Java
15:47:38 <AvengerX> I think I'd need just a basic sample of what would do the trick..
15:47:54 <sjanssen> become luminaries in the Java community, and then insist that the next version of Java *must* have gotos
15:48:06 <glguy> sjanssen: both must have and must not have!
15:49:26 <sjanssen> AvengerX: http://cgi.cse.unsw.edu.au/~dons/blog/2006/10/04
15:49:28 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/ve7sg
15:49:40 <AvengerX> ty sjanssen
15:50:08 <SamB_XP> sjanssen: no real good reason, okay?
15:50:20 <SamB_XP> for UTF-16 supporting both endiannesses
15:50:40 <SamB_XP> probably they just threw it together after people started using 16-bit encodings for files
15:50:41 <glguy> when I wrote up the UTF-16 standard, I just couldn't make up my mind
15:51:01 <SamB_XP> glguy: what?
15:51:05 <SamB_XP> you wrote the standard?
15:51:10 <SamB_XP> and you didn't just go with BE?
15:51:20 <SamB_XP> (aka network byte order?)
15:51:22 <glguy> split personalities
16:00:59 <AvengerX> way thanks sjanssen. this is just -the- thing! :)
16:01:12 <sjanssen> AvengerX: thank dons, he wrote it!
16:01:15 * dibblego considers writing an intelliJ IDEA plugin for haskell
16:04:08 <dibblego> I reckon it would seriously rock
16:09:42 <astrolabe> why would there be C pre-compiler directives (eg #if defined) in a file of haskell code?
16:10:06 <SamB_XP> why do you *think*?
16:10:20 <Botje> government regulations?
16:10:26 <SamB_XP> maybe because we don't have lisp-style reader macros for that?
16:11:03 <astrolabe> I imagine it gets fed through a C pre-compliler.  Really I was after information about whether there was a standard way for that to happen.
16:11:22 <lennart> usuall with -ccp flag to the compiler
16:11:28 <lennart> -cpp
16:11:35 <astrolabe> thankyou
16:14:41 <Patterner> m4 <foo.hs4 >foo.hs
16:16:37 <sfultong> is there a function I can use to cons to IO []?
16:18:03 <dolio> ?type fmap (:)
16:18:05 <lambdabot> forall (f :: * -> *) a. (Functor f) => f a -> f ([a] -> [a])
16:18:11 <twanvl> liftM (something:)
16:18:45 <sfultong> ah! silly me... liftM comes to the rescue once again
16:19:19 <sfultong> liftM has to be most useful function in prelude
16:21:15 <psi> it's in the prelude?
16:21:23 <psi> not here
16:21:26 <sfultong> oh... maybe not
16:24:13 <lispy> fmap is in the prelude and it's usually a dropin replacement for liftM
16:24:52 <sfultong> yeah, and I think I should be using it instead
16:29:14 <dcoutts> there's a slight difference in types, fmap needs the thing to be an instance of Functor, liftM needs Monad. But every Monad should and can be made an instance of Functor.
16:30:54 <sfultong> mmm
16:32:06 <lispy> ?hoogle ap
16:32:07 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
16:32:07 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
16:32:07 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
16:33:34 <lispy> is this right? liftM2 f a b = liftM f a `ap` b
16:34:17 <mauke> not sure, but it's return f `ap` a `ap` b
16:34:43 <lispy> ah
16:34:48 <lispy> then i think both work
16:34:50 <mauke> @type \f a b -> liftM f a `ap` b
16:34:52 <lambdabot> forall (m :: * -> *) a b a1. (Monad m) => (a1 -> a -> b) -> m a1 -> m a -> m b
16:35:29 <lispy> ?type \f a b -> return f `ap` a `ap` b
16:35:31 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
16:35:58 <lispy> ?lp \f a b -> return f `ap` a `ap` b
16:35:58 <lambdabot> Maybe you meant: . bf ft help id let map pl slap v wn
16:36:02 <lispy> ?pl \f a b -> return f `ap` a `ap` b
16:36:03 <lambdabot> liftM2
16:36:13 <dons> moin
16:36:22 <lispy> ?pl \ f a b -> liftM f a `ap` b
16:36:23 <lambdabot> liftM2
16:36:29 <lispy> dons: moin
16:37:04 <lispy> i bet there are many times when i could have used ap and did something ad-hoc instead
16:37:32 <lispy> ?pl \f a b c -> liftM2 f a b `ap` c
16:37:32 <lambdabot> ((ap .) .) . liftM2
16:37:50 * lispy expected liftM3
16:37:55 <lispy> ?type liftM3
16:37:57 <lambdabot> forall r (m :: * -> *) a3 a2 a1. (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:38:18 <lispy> ?pl \f a b c -> return f `ap` a `ap` b `ap` c
16:38:19 <lambdabot> ((ap .) .) . liftM2
16:38:52 <lispy> ?index liftM3
16:38:53 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:39:01 <lispy> ?doc Control.Monad
16:39:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
16:39:47 <dolio> It's probably not in pl's table of useful functions.
16:39:51 <lispy> oh, that should be liftM3
16:40:00 <lispy> return f `ap` x1 `ap` ... `ap` xn
16:40:01 <lispy> is equivalent to
16:40:01 <lispy> liftMn f x1 x2 ... xn
16:40:20 <lispy> (according to that page)
16:41:03 <lispy> i find liftM2 to be really handy with the Maybe monad
16:41:44 <lispy> esp. if you have a data structure with 'optional' fields modeled as Maybe a
16:42:09 <lispy> if you want to define addition on your structure, liftM2 (+) field1 field2 is pretty handy
16:42:52 <lispy> nicer than dealing with all the options where field1 or field2 is Nothing
16:43:05 <mauke> I prefer lifting (+) itself
16:44:14 <lispy> isn't that what you call the trick i just described?
16:44:15 <emu> @type choose
16:44:17 <lambdabot> Not in scope: `choose'
16:44:23 <lispy> lifting (+) into the Maybe monad
16:44:41 <mauke> no, lifting Maybe into Num
16:45:04 <lispy> ah, yeah that could have been handy too
16:45:31 <lispy> instance Num a => Maybe a where ... ?
16:45:34 <lispy> er
16:45:46 <lispy> instance Num a => Num (Maybe a) where ?
16:45:55 <sfultong> I definitely need to get better with using monads
16:46:02 <mauke> lispy: http://paste.lisp.org/display/28401
16:47:00 <lispy> mauke: ah, well that seems a bit crazy :)
16:47:12 <lispy> mauke: because it allows some things i would consider errors
16:47:22 <lispy> like "1 2 3" => "1"
16:47:43 <Cale> sfultong: liftM isn't in the Prelude, but fmap is, and it does the same thing and is more general
16:48:06 <lispy> Cale: get some rest :)
16:48:07 <emu> @pl flip replicateM
16:48:08 <lambdabot> flip replicateM
16:48:17 <mauke> lispy: I think it's cool
16:48:24 <dons> ?users #haskell
16:48:25 <lambdabot> Maximum users seen in #haskell: 256, currently: 225 (87.9%), active: 40 (17.8%)
16:48:26 <lispy> Cale: i'm just teasing because i think dcoutts and i already said most of that :)
16:48:41 <dons> looks like the strictness issue on @users is solved
16:48:48 <Cale> lispy: I was just scanning the scrollack
16:48:50 <Cale> b*
16:48:56 <dons> but the bot is leaking nonetheless
16:49:03 <dons> should profile one of these days..
16:49:12 <lispy> dons: what was the strictness on users problem?
16:49:29 <Cale> dons: I've also found it does a fairly poor job of determining when it's been disconnected
16:49:36 <dons> oh, over time it would take longer and longer to compute @users, due to lazy chains of thunk built up every time someone said anything :)
16:49:45 <dons> Cale: it does, that's right.
16:49:46 <lispy> dons: ah
16:50:09 <dons> did people see, http://scienceblogs.com/goodmath/2006/10/haskell_and_scheme_which_one_a.php#more
16:50:12 <lambdabot> http://tinyurl.com/y4neqs
16:50:42 <palomer> you're all nuts!
16:51:08 <chessguy> thunk, eh? is that the technical term?
16:51:16 <dons> it is.
16:51:22 <dons> from Algol
16:51:36 <dons> ?foldoc thunk
16:51:38 <lambdabot> *** "thunk" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
16:51:38 <lambdabot> thunk
16:51:38 <lambdabot>  
16:51:38 <lambdabot>     <programming> /thuhnk/ 1. "A piece of coding which provides an
16:51:38 <lambdabot>     address", according to P. Z. Ingerman, who invented thunks in
16:51:40 <lambdabot> [39 @more lines]
16:51:42 <Cale> oops, missing parens in fold :)
16:51:55 <vincenz> @join #scheme
16:51:59 <mauke> http://catb.org/~esr/jargon/html/T/thunk.html
16:52:01 <lambdabot> Title: thunk
16:52:24 <chessguy> heh
16:53:09 <lispy> dons: i think i see a typo already in that article.../me checks
16:53:27 <lispy> yup
16:53:30 <lispy> fold init reducer l:ls =  reducer l (fold init reducer ls)
16:53:40 <lispy> (need parens around the l:ls)
16:53:49 <lispy> oh
16:53:52 <dons> I guess he doesn't yet appreciate letting the compiler do the work?
16:53:53 <lispy> hehe, hey Cale :)
16:54:15 <chessguy> very interesting article on scheme vs. haskell
16:54:20 <Cale> lispy: now who's repeating the other's remarks? :)
16:54:25 <dons> ?users #scheme
16:54:25 <lambdabot> Maximum users seen in #scheme: 118, currently: 118 (100.0%), active: 9 (7.6%)
16:54:32 <dons> ?users #haskell
16:54:33 <lambdabot> Maximum users seen in #haskell: 256, currently: 226 (88.3%), active: 43 (19.0%)
16:55:14 <dons> schemes really most common in the US, isn't it? And you're more likely to find Haskell is northern and western europe, and .au
16:55:27 <chessguy> it is just a blog, after all
16:56:00 <dolio> Some scheme guy on reddit replied that you can do pattern matching using macros in scheme.
16:56:01 <dons> aren't blogs all there is these days?
16:56:06 <dons> dolio: hehe!
16:56:21 * dcoutts wonders if he should blog
16:56:57 <dons> dcoutts: please do. its one of the only marketing tools we have ;)
16:57:00 * lispy would blog more if he didn't hate wordpress
16:57:05 <dcoutts> dons, heh :-)
16:57:07 <jgrimes> I tried blogging. I guess I just don't have enough to say.
16:57:16 <dons> yeah, it helps if you have things to say.
16:57:21 <dcoutts> dons, what are we trying to market ?
16:57:27 * Igloo would spend too much time on writing blog posts if I blogged
16:57:32 <dolio> Although it's more like haskell's case than equational definitions.
16:57:38 <palomer> people still use scheme?
16:57:43 <dons> types? correctness? the lambda revolution?
16:57:44 <palomer> didn't that die with the 90s?
16:57:55 <chessguy> they still teach with scheme
16:57:59 <dcoutts> palomer, some folk from MIT havn't got over that yet
16:58:09 <lispy> palomer: in another decade they'll be angry and bitter like all the lispers :)
16:58:19 <dons> they do. in the US? and haskell in the Haskell-Zone i pointed to above.
16:58:21 <palomer> well someone should go over there and tell them. They could steal their genesis tapes while they're at it
16:58:24 <chessguy> it's part of my current principles of programming languages class coming up
16:58:26 <dons> lispy: heh
16:58:33 <dons> chessguy: scheme? that's a pity.
16:58:37 <chessguy> yes, it is
16:58:46 <dons> how will they teach types? or anything invented since 1985?
16:58:50 <lispy> palomer: it's the land of confusion
16:58:59 <chessguy> it's also the only mention of any functional language i'll formally get
16:59:15 <dcoutts> dons, nah, types restrict what you can write ;-)
16:59:26 <palomer> I don't see what's functional about scheme
16:59:34 <chessguy> all the typing examples are done in c/c++/java/perl
16:59:40 <chessguy> mostly c++
16:59:45 <dcoutts> eew
16:59:49 <dcoutts> that's not a type system
16:59:56 <chessguy> oh, and some ada and pascal
16:59:57 <dons> chessguy: did you say perl? and C++ doesn't even have a semantics..
17:00:02 <dons> the mind boggles
17:00:09 <chessguy> yeah, it's ridiculous
17:00:29 <chessguy> i asked her about haskell and she had to go look it up to explain to me that it's a functional language
17:00:37 <dons> chessguy: why not attend the course, but secretly take notes on these slides instead, http://cgi.cse.unsw.edu.au/~cs3161/
17:00:43 <palomer> c++ has a semantics, it's just undefined in certain places
17:01:07 <dons> chessguy: where's this? in the US?
17:01:15 <chessguy> yes, penn state university
17:01:21 <dons> oh, hmm.
17:01:22 <chessguy> satellite campus
17:01:33 <chessguy> head of the department is even an MIT grad
17:01:34 <jgrimes> the only mention of functional languages in our curriculum occurs in the "programming languages" course
17:01:49 <dons> well, scheme is still big in the US, even if research output on scheme seems to have slowed a lot
17:01:50 <jgrimes> the rest is java and C
17:01:50 <chessguy> yup, same thing
17:01:53 <Patterner> we had Prolog as the exotic language...
17:02:03 <Patterner> and FORTRAN for real work :)
17:02:04 <dons> so did we!
17:02:09 <dons> but we had Haskell as the core language.
17:02:17 <SamB_XP> ???
17:02:20 <chessguy> yes, we're going to talk about prolog as our (only) example of declarative programming
17:02:25 <wolverian> I've said this before, but our introduction to FP course uses haskell. yay!
17:02:28 <sfultong> dons: where did you go to school?
17:02:29 <chessguy> fortran...lol
17:02:33 <SamB_XP> Haskell next to fortran?
17:02:35 <dons> sfultong: unsw, sydney
17:02:37 <lispy> Monads can be extremely difficult to understand, and even experts can have trouble when they need to mix different kinds of monadic actions. (For example, using a state monad to allow you to write some efficient state-based algorithm, mixed with I/O.)
17:02:39 <dons> wolverian: where are you?
17:02:44 <wolverian> dons, helsinki, finland
17:02:44 <emu> @pl liftM2 (,)
17:02:45 <lambdabot> liftM2 (,)
17:02:49 <dons> wolverian: ah of course.
17:03:47 <wolverian> dons, of course? :)
17:04:16 <dons> helsinki is practically haskell central for education these days :)
17:04:31 <dons> well, at least we have a ot of #haskellers there
17:04:43 <chessguy> dons, that class looks really interesting
17:04:45 <wolverian> yeah. I missed the meeting a while back.
17:05:24 * chessguy bookmarks it
17:05:38 <dons> chessguy: yeah, CMU teaches a similar course, on top of ML. with the same emphasis on proofs and types
17:05:48 <dons> as the foundation of programming languages
17:05:55 <lucca> 15-211?
17:05:56 <dons> ?where plbook
17:05:56 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
17:06:08 <lucca> hm, no
17:07:31 <wolverian> of course I'd rather have seen haskell being used as the introductory language in general instead of java.
17:07:31 <sjanssen> dons: is Haskell part of an intro course at UNSW?
17:09:06 <dibblego> is there such thing as a bounded enum, where I can pass the minimum bound (and let it go to infinity)?
17:09:48 <chessguy> i think haskell and c++ should be taught side by side. it would give you a good idea of the contrasts
17:10:04 <dibblego> I don't think imperative programming should be taught until people are adults
17:10:06 <edwardk_> dibblego you can make one, you can just say Enum, and let it run, Bounded implies both above and below though i think
17:10:17 <dibblego> edwardk_, yeah I thought of that
17:10:28 <dons> sjanssen: it was. that changed last year :/
17:10:33 <dibblego> does Bounded have a succ method?
17:10:35 <dons> its still used in one of the intro courses
17:10:47 <dons> and then reappears in 3rd year for a couple or 3 courses.
17:11:01 <chessguy> it's hard too, because so many employers expect you to come out knowing java/c++
17:11:02 <dibblego> Bounded is not a more specific type of Enum
17:11:04 <edwardk_> dib:enum does
17:11:08 <chessguy> they could care less about haskell
17:11:18 <dibblego> chessguy, s/employers/many employers
17:11:23 <SamB_XP> chessguy: it would be hard for them to do so
17:11:25 <edwardk_> dib: bounded just says you will have a sup and inf
17:11:34 <SamB_XP> chessguy: considering most of them probably haven't heard of Haskell
17:11:35 <dons> depends on whether the school sees itself as a vocational training college, or a place of learning ;)
17:11:35 <chessguy> right
17:11:43 <edwardk_> @type maxBound
17:11:44 <lambdabot> forall a. (Bounded a) => a
17:11:48 <sjanssen> chessguy: there's no reason you can't learn both
17:11:49 <edwardk_> @type min@bound
17:11:51 <lambdabot> Pattern syntax in expression context: min@bound
17:11:52 <edwardk_> er
17:11:54 <edwardk_> @minBound
17:11:55 <lambdabot> Unknown command, try @list
17:11:59 <edwardk_> wow i can't type
17:12:01 <SamB_XP> dons: where do they keep these "places of learning"?
17:12:03 <edwardk_> @type minBound
17:12:04 <chessguy> exactly. but if they don't train the students what the employers want, they don't get a good reputation
17:12:05 <lambdabot> forall a. (Bounded a) => a
17:12:05 <SamB_XP> I'd like to attend one
17:12:06 <sjanssen> s/both/each
17:12:11 <dons> SamB_XP: on the moon, I've heard.
17:12:16 <SamB_XP> aw nuts
17:12:20 <dibblego> SamB, I work for one
17:12:22 <SamB_XP> I can't afford to go to the moon
17:12:30 <lispy> CS is in a weird place in the world
17:12:46 <palomer> yo my bitches
17:13:00 <edwardk_> dons: i'm trapped in a 'vocational' setting =/
17:13:19 * SamB_XP looks around in an attempt to discern the individuals to which palomer is referring
17:13:34 <chessguy> i'm sitting here in a software engineering class right now, hoping to God i don't wind up in an environment where i have to do this stuff
17:13:49 <edwardk_> i am tempted to provide a handout at the end of this semester that shows how you can do every program we did all semester in java each in one line of haskell.
17:13:52 <palomer> my bitches know who they are
17:14:02 <chessguy> .lol
17:14:08 <palomer> right, my bitches?
17:14:13 <SamB_XP> edwardk_: every single one?
17:14:15 <SamB_XP> 80 char?
17:14:16 <edwardk_> and use it to either encourag my students to continue on in comp sci or break them
17:14:19 <SamB_XP> none are sig sized?
17:14:25 <SamB_XP> (what about imports?)
17:14:27 <edwardk_> samb: not 80 char for most, but some =)
17:14:40 <SamB_XP> sig sized is like 4x76, I think
17:14:52 <Patterner> Four punch cards
17:15:02 <edwardk_> sig sized is doable i think.
17:15:12 <SamB_XP> Patterner: nobody is silly enough to use punched cards for email
17:15:16 <SamB_XP> or news
17:15:23 <SamB_XP> so..
17:15:28 <SamB_XP> NO! not four cards!
17:15:50 <edwardk_> heh punch card email sounds like fun
17:17:15 <Pseudonym> It sounds worse than SMS.
17:17:29 <SamB_XP> nono
17:17:39 <SamB_XP> you can fit more than five characters on a punchcard ;-P
17:18:03 <edwardk_> heh, maybe i'll make one of my comp sci classes write it. use a spare hollerith card reader i have in my basement, let em go at it, learn how to control the serial port, etc.
17:18:17 <edwardk_> would need more than one card reader though
17:18:30 <edwardk_> and i don't have a machine to punch with
17:19:29 <lispy> it would have been really hard to write my first year CS class's assignments in 1 line of haskell
17:19:44 <SamB_XP> you should make them figure out how to make a robot do it
17:19:47 <SamB_XP> ;-P
17:19:59 <lispy> we had an applet that had to take a list of grades as input from a webpage and print your grade
17:19:59 <SamB_XP> lispy: what did your first year CS class teach?
17:20:03 <SamB_XP> oh.
17:20:07 <edwardk_> alas, i don't set the curriculum for this particular class
17:20:15 <SamB_XP> that is indeed sad :-(
17:20:15 <lispy> and another applet had to be a calculator with buttons and stuff
17:20:21 <SamB_XP> how can they *DO* that to you?
17:20:26 <liyang> MIPS assembly!
17:20:30 <SamB_XP> lispy: applets!
17:20:31 <SamB_XP> ick.
17:20:37 <edwardk_> ok, by the end of the semester they'll have a few 4-5 liners.
17:20:39 <lispy> SamB_XP: this was 1998
17:20:44 <SamB_XP> okay
17:20:53 <SamB_XP> they don't teach applets anymore do they?
17:20:56 <SamB_XP> applets are dumb
17:21:00 <edwardk_> sam: hey at least he gets to do applets, i get to make them write command line code in java. the worst of both worlds =)
17:21:14 <lispy> SamB_XP: applets are dumb, i think now they get to write applications
17:21:27 <lispy> but it's things like an OO solitare game
17:21:32 <SamB_XP> edwardk_: but they don't have to hardcode GUI stuff
17:21:38 <lispy> using BigIntegers to keep the score (just to show off that they exist)
17:21:46 <SamB_XP> lispy: ick
17:21:58 <SamB_XP> do any of them write in Scala and somehow decompile to Java?
17:22:16 <lispy> teaching OO right off the bat just seems dumb
17:22:23 <lispy> SamB_XP: heh, i doubt it
17:22:26 <SamB_XP> they don't do that at my school
17:22:27 <edwardk_> next time i want to go back and do servlets and web programming, that way you can avoid introducing all the crap the java boilerplate mkes you introduce until hey know what a function is, etc.
17:22:47 <SamB_XP> they are supposed to teach the C-ish stuff in the first semester...
17:22:54 <edwardk_> then once they have the idea of a server page, i can bring in servlets, and larger classes
17:22:56 <lispy> OO in java seems like an extension to procedural...so it seems like you'd want to help them get procedural down before you throw the OO at them
17:23:02 <edwardk_> and show direct benefits of each concept as they are introduced
17:23:04 <SamB_XP> (oh, they use C++ here)
17:23:24 <edwardk_> lispy: exactly.
17:23:56 <SamB_XP> oo seems like a lot to throw at anyone who doesn't particularly want it
17:24:08 <lispy> i think the biggest hurdle in learning OO is realizing that the class definition doesn't get executed as a program from start to finish
17:24:10 <edwardk_> yeah. =/
17:24:22 <SamB_XP> lispy: o rly?
17:24:30 <lispy> at least that was the thing which didn't click for me when i was learning it
17:24:33 * SamB_XP tickles his Python interpreter
17:24:46 <SamB_XP> lispy: are you *sure*?
17:24:46 <lispy> once i got that down i could start writing OO code
17:24:49 <edwardk_> thats something i've hard a hard time explaining to folks, or rather getting them to believe me ;)
17:24:56 <edwardk_> sam: =P
17:25:12 <SamB_XP> ;-P
17:25:13 <lispy>  /ignore SamB_XP
17:25:14 <lispy> oops
17:25:15 <lispy> ;)
17:25:17 <edwardk_> sam: no fair changing the language. we could go to simula and remove all of the extraneous concepts while we're at it.
17:25:32 <SamB_XP> what? you mean like classes?
17:25:58 <lispy> eh, i think OO has its purpose and places, i just hate lopsided languages
17:26:03 <SamB_XP> yeah
17:26:09 <SamB_XP> Java has *no* choice
17:26:16 * lispy recalls kingdom of nouns
17:26:21 <SamB_XP> either Objects or *nothing*
17:26:24 <SamB_XP> yeah, I read that
17:26:27 <edwardk_> samb: yet you like your python interpreter? =)
17:26:32 <lispy> SamB_XP: you can choose to make a singleton ;)
17:26:51 <SamB_XP> well, the Python interpreter lets you just write code, and nevermind that the things you are manipulating happen to be "objects"
17:26:58 <SamB_XP> or, well, Python does.
17:27:15 <lispy> python takes a simplistic approach to life
17:27:22 <lispy> but, it's kinda meh
17:27:27 <SamB_XP> I mean, you don't need to start with a class
17:27:32 <lispy> it's so much easier to write code than to understand it
17:27:33 <SamB_XP> you don't even need a "main" function
17:27:37 <SamB_XP> yeah
17:27:39 <SamB_XP> thats true
17:28:15 <lispy> i think if i did any long term programming in python i'd look for a python type checker :)
17:28:39 * lispy checks for it now
17:28:52 <Eidolos> coughrubycough
17:29:09 <SamB_XP> lispy: well, they have this RPython thing
17:29:13 <edwardk_> yeah no good milner syle type checking for those evil imperative languages. funny how much time i spent working on just such things before i saw the light.
17:29:25 <dons> now I'm scared. i type haskell into google and get....
17:29:29 <dons> drum roll....
17:29:30 <dons> "Functional programming
17:29:31 <dons> Have you tried JavaScript?
17:29:31 <dons> The solution to every problem."
17:29:40 * Patterner cries into her bismuth and brimstone tea
17:30:01 <lispy> dons: hehe, that's a joke from thedailywtf
17:30:09 <dons> ah!
17:30:11 <SamB_XP> dons: I get that a lot at the top of my gmail
17:30:12 <lispy> dons: following the link is worth it
17:30:13 <edwardk_> I get "Haskell for Less, Looking for Haskell? Find exactly what you want today. www.ebay.com" =)
17:30:15 <SamB_XP> I don't get it though
17:30:17 <dons> bizarre
17:30:23 <SamB_XP> I don't see what the article has to do with FP
17:30:28 <Patterner> GHC for just $19.99 if you buy now!
17:30:37 <dons> Patterner: cool!
17:30:40 <SamB_XP> ooooooh
17:30:46 <lispy> http://www.ilowe.net/software/typecheck/
17:30:49 <lambdabot> Title: Type-checking module for Python
17:30:54 <SamB_XP> shiny bling bling iced-out chrome lambda box!
17:31:16 * SamB_XP pictures silver raised lambda on black ;-)
17:33:35 <Bobstopper> dons: was that consensus thing I sent you of any use?
17:33:42 <edwardk_> lispy: ok, now type inference ;)
17:33:54 <lispy> edwardk_: gotta start somewhere :)
17:34:01 <dons> Bobstopper: still need to read it through, i only got it late last night
17:34:14 <dons> Bobstopper: but i've put it on the wiki, so it should be read widely
17:35:06 <edwardk_> lispy: the irony of all of this is of course that my obsession with writing compilers started because i wanted to infer the types of lvalues in assignments in imperative languages so i wouldn't have to repeat myself with lovely noun-based code like. MyClass<X,Y,Z> foo = new MyClass<X,Y,Z>() =)
17:35:40 <dons> lispy: run-time typechecking though
17:35:49 <edwardk_> dons: ugh
17:35:55 <Bobstopper> dons: ok, tah
17:36:06 <mauke> I have a C++ lib that lets you do MyClass<X,Y,Z> *foo = mem.alloc();
17:36:10 <dons> i..e Bob Harper's principle that dynamic typing is just a degenerate case of static typing, since you can always add dynamic typing to a static language, but you can't go the other way
17:36:46 <edwardk_> dons: yeah.
17:37:16 <edwardk_> mauke: ok, but now i don't want to have to give the return type of the function or the types of its arguments... hrmm starts to look like haskell. =)
17:38:10 <edwardk_> or ml or anything else type inferable
17:38:16 <dibblego> is the prop_ prefix for quickcheck a convention or is it used somehow?
17:38:22 <dons> dibblego: convention
17:38:29 <dons> there is a tool that detects them, but its not widey used
17:38:30 <dibblego> ah thanks
17:38:50 <emu> can someone explain why: inn (Data.Graph.Inductive.Graph.mkGraph [(0,())] [(0,0,0)] :: Gr () Int) 0  returns []?
17:39:15 <dons> if ever a library need better docs, it is fgl
17:39:19 <mauke> edwardk_: template<BOOST_PP_ENUM_PARAMS(i, typename X)> detail_alloc::spork_##i<BOOST_PP_ENUM_PARAMS(i, X)> alloc(BOOST_PP_ENUM_BINARY_PARAMS(i, X, &x)) {return detail_alloc::spork_##i<BOOST_PP_ENUM_PARAMS(i, X)>(BOOST_PP_ENUM_PARAMS(i, x)); } :-)
17:39:26 <Cale> dons: not to mention better function names
17:39:42 <dons> lispy: isn't Erwig your boss or something?
17:39:50 <dons> lispy: go and tell him to write more docs!
17:39:55 <edwardk_> mauke: and you wonder why i defected =)
17:40:19 <edwardk_> wow i used to LIKE writing code like that
17:40:26 <mauke> but seriously, template<typename T> operator T () { ... } is way cool
17:40:48 <mauke> it's the closest thing to context-based overloading C++ has
17:40:51 <edwardk_> mauke: i admit
17:40:52 <emu> basically, I constructed a graph with 1 node that has a cyclic edge pointing to itself.  then I asked for the list of incoming edges.
17:42:31 <vincenz> @join #scheme
17:43:43 <dons> vincenz: do the scheme guys like it there?
17:43:51 <dons> should it stay there permanently?
17:47:58 <astrolabe> I'm getting an error I don't understand.
17:48:07 <araujo> hellu hellu
17:48:12 <vincenz> Hey Riastradh
17:48:13 <coffeemug> what error?
17:48:39 <astrolabe> I get it with GHC proper, but testing with GHCi, I get 'Not in scope: 'Hat.Ix.grange'
17:49:05 <astrolabe> but if I type     :t Hat.Ix.grange    , it knows about it.
17:49:24 <dons> :m + Hat.Ix perhaps?
17:49:42 <vincenz> dons: what is :+
17:50:08 <astrolabe> um could you say some more please dons
17:50:18 <coffeemug> look in the docs
17:50:24 <coffeemug> :m +Module
17:50:26 <dons> ?hoogle :+
17:50:26 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':+'
17:50:27 <coffeemug> loads the module :)
17:50:31 <coffeemug> adds the moudle, I mean
17:50:43 <coffeemug> it's a ghci command
17:50:55 <vincenz> @hoogle (:+)
17:50:57 <lambdabot> Did you mean: (:+)
17:50:57 <lambdabot> Prelude.undefined :: a
17:50:57 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
17:51:18 <coffeemug> different :
17:51:22 <coffeemug> +
17:51:32 <coffeemug> he mands :module +Module command in ghci
17:51:43 <coffeemug> not (+) in Haskell
17:51:46 <coffeemug> means
17:52:10 <astrolabe> If I type dons' line, it appears to do something, but then if I  :l test.hs   I get the same error anyway.
17:53:02 <int-e> test.hs will have to import the module itself then
17:53:09 <coffeemug> do you import the module in test.hs?
17:53:18 <astrolabe> I'll try that, thanks
17:55:15 <dibblego> where can I read about how to implement Test.QuickCheck.Arbitrary for my type?
17:56:59 <dons> dibblego: the QuickCheck papers, and the source
17:57:05 <dons> ?source Test.QuickCheck
17:57:06 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
17:57:08 <dons> should make it clear
17:57:14 <astrolabe> I was importing Hat.Data.Array anyway, which I think should have imported Hat.Data.Ix.  Especially since ':t' could see it.  Anyway, doing it dons' way gives me a monomorphism restriction error, which I see as an improvement :)
17:57:15 <dibblego> let's hope thanks :)
17:57:19 <dons> the papers are on the 'Research papers' subsection of the wiki
17:57:30 <x3m> anyone installed hs-plugins with mingw?
18:01:42 <astrolabe> can anyone give me a clue as to why ghci might know the type of Hat.Ix.grange, but also say it isn't in scope?
18:02:37 <Igloo> :m + Hat.Ix
18:02:54 <dibblego> if I have a function from Arbitrary a => t -> a and I need to write an instance of Arbitrary for t, can I do it in terms of a easily?
18:03:10 <astrolabe> Igloo, that seems to be the solution, but I'm trying to understand the problem
18:03:32 <Igloo> astrolabe: ghci knows about everything that's exposed, but only has the things you ask for in scope
18:05:30 <astrolabe> So here, I'm importing Hat.Array, which exports Hat.Ix, why doesn't this make Hat.Ix.grange in scope?
18:06:08 <dons> maybe Hat.Array doesn't reexport grange?
18:06:09 <Igloo> Is Hat.Array compiled?
18:06:36 <Igloo> IIRC it will do if it's interpretted, but I might be confusing that with internal functions
18:06:45 <astrolabe> module Hat.Array
18:06:45 <astrolabe>   (module Hat.Ix,Array(),garray,aarray,ha
18:07:02 <Igloo> Things will be exports as Hat.Array.foo, though
18:07:35 <astrolabe> oh, this is frustrating.  Thanks for your help though.
18:08:31 <astrolabe> My real problem isn't with ghci, but with plain ghc where I get the same error.
18:09:37 <astrolabe> It seems to be fixed by importing Hat.Ix directly, but I'm trying to diagnose why it doesn't work, so I can get hat to work without having to hack the files it generates.
18:10:34 <Igloo> The only way to get M.f in scope is to import something as M
18:10:48 <Igloo> (apart from Prelude and the current module)
18:10:59 <astrolabe> Oh, are you saying that if Hat.Ix is imported via Hat.Array, then the function will be called Hat.Array.grange?
18:11:16 <SamB_XP> you could just import M
18:11:19 <Igloo> Yes
18:11:49 <astrolabe> Thanks very much guys.  I'd give you all a hug if I weren't british.
18:12:04 <SamB_XP> heh
18:12:52 <Igloo> :-)
18:13:12 <dons> very sensible.
18:17:36 <dons> hmm, SyntaxNinja's blog post is interesting. http://blog.syntaxpolice.org/isaac/index.cgi/technology/onInfrastructure.html
18:18:41 <lambdabot> http://tinyurl.com/tjg3t
18:20:22 <SamB_XP> dons: it isn't resolving!
18:20:30 <SamB_XP> what is the IP address?
18:21:46 <Lemmih> SamB_XP: http://planet.haskell.org/
18:21:48 <lambdabot> Title: Planet Haskell
18:22:48 <dibblego> data NonEmptyList a = NonEmptyList { first :: a ,remainder :: [a] } deriving (Eq, Show) -- how would an instance of Arbitrary look for this type?
18:23:11 <dons> it would mirror the list instance, I'd imagine
18:23:31 <dibblego> the list one can generate [] I believe
18:23:39 <dons> so similar to
18:23:41 <dons> instance Arbitrary a => Arbitrary [a] where
18:23:41 <dons>   arbitrary          = sized (\n -> choose (0,n) >>= vector)
18:23:41 <dons>   coarbitrary []     = variant 0
18:23:41 <dons>   coarbitrary (a:as) = coarbitrary a . variant 1 . coarbitrary as
18:23:52 <dons> you might even use that, and then filter empty lists..
18:23:52 <dibblego> right
18:24:05 <dons> but set the size to be (1,n) I'd imagine
18:24:44 <coffeemug> arghh
18:24:51 <coffeemug> unknown package: lang-1.0
18:24:53 <dibblego> what exactly does arbitrary and coarbitrary do?
18:25:15 * Igloo was thinking about having QC keep hold of the tree of choices it could make, with each branch point indicating whether there were any untried choices below it
18:25:30 <Igloo> thus avoiding the repetition it seems prone to
18:25:36 <dons> coffeemug: lang? you building something very old?
18:25:52 <dibblego> ?type choose
18:25:54 <lambdabot> Not in scope: `choose'
18:26:02 <dibblego> ?type Test.QuickCheck.choose
18:26:04 <lambdabot> forall a. (Random a) => (a, a) -> Test.QuickCheck.Gen a
18:26:23 <dons> ?source Test.QuickCheck
18:26:23 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
18:26:27 <dons> will be useful.
18:26:40 <dibblego> yeah trying to figure it out from that
18:26:50 <dibblego> > Test.QuickCheck.choose(1,2)
18:26:51 <lambdabot>  Not in scope: `Test.QuickCheck.choose'
18:26:59 <dibblego> > Test.QuickCheck.choose (1,2)
18:27:00 <lambdabot>  Not in scope: `Test.QuickCheck.choose'
18:27:30 <coffeemug> dons: no, just doing a regular build
18:27:35 <coffeemug> I don't know where it found all this stuff
18:27:55 <dons> you're not trying to build hslibs are you?
18:28:16 <coffeemug> yeah, it looks like it's trying to build hslibs
18:28:20 <coffeemug> is it not supposed to? :)
18:28:42 <dons> not these days.
18:29:03 <coffeemug> did I do something that made it build it?
18:29:13 <coffeemug> I just first set mk.build to buildextralibs=1
18:29:19 <coffeemug> and then turned the off and just did make again
18:29:22 <coffeemug> that's it, really
18:29:47 <Igloo> What are you compiling?
18:29:57 <coffeemug> ghc 6.4.2 on windows
18:30:01 <syntaxfree> I'm trying to learn WebFunctions, but I need better docs than the phd thesis
18:30:10 <Igloo> What are you compiling it with?
18:30:16 <coffeemug> msys and mingw
18:30:24 <Igloo> I mean, what version of GHC?
18:30:41 <coffeemug> I have 6.4.2 installed
18:31:20 <syntaxfree> @seen herk
18:31:20 <lambdabot> I haven't seen herk.
18:31:20 <syntaxfree> @google herk #haskell
18:31:20 <lambdabot> http://www.cs.uu.nl/wiki/Students/RobertVanHerk
18:31:20 <lambdabot> Title: Students / Robert Van Herk
18:31:31 <Igloo> That should work, then
18:32:10 <coffeemug> yeah
18:32:20 <coffeemug> brb
18:32:23 * Igloo doesn't know what buildextralibs=1 is suppose to do, but the string buildextralibs doesn't appear in the tarball
18:33:54 <dons> i've never seen it
18:36:20 <coffeemug> ok
18:36:23 <coffeemug> last time I'm trying
18:36:27 <coffeemug> if this doesn't work
18:36:31 <coffeemug> I give up
18:36:41 <dons> hmm.
18:36:50 <Igloo> Did you give the appropriate options to configure, BTW?
18:37:06 <Igloo> And why are you building 6.4.2 rather than 6.6 OOI?
18:37:17 <dons> don't do anything you're not asked to do. so no extra build flags, no extra libraries dumped in the `pwd` .. :)
18:37:28 <coffeemug> well, I followed the build docs
18:37:41 <dons> which ones?
18:37:46 <coffeemug> I'm building 6.4.2 because hs-plugins has issues with 6.6
18:37:56 <dons> check the README file
18:38:04 <coffeemug> http://www.haskell.org/ghc/docs/latest/html/building/winbuild.html
18:38:05 <coffeemug> thes
18:38:06 <coffeemug> e
18:38:07 <lambdabot> Title: 12. Instructions for building under Windows, http://tinyurl.com/ctmp3
18:38:08 <dons> it should have the correct instructions.
18:38:26 <dons> hmm. its possible the Windows instrs are out of date (sounds like it, if they recommend buildextralibs..)
18:38:43 <coffeemug> ok, so let me ask you something
18:38:49 <coffeemug> I downloaded the source tarball
18:39:03 <coffeemug> question #1, do I need to do autoreconf?
18:39:22 <coffeemug> it looks like I don't, it only needs to be done if I get sources from darcs
18:39:23 <dons> do you have a configure file?
18:39:35 <dons> if so, then no. autoreconf is only needed for darcs, iirc
18:39:41 <Igloo> That page doesn't mention buildextralibs
18:39:44 <coffeemug> ok
18:39:46 <coffeemug> question #2
18:40:01 <coffeemug> there are instructions online to have a certain build.mk to make the build quicker
18:40:02 <Igloo> But does have th econfigure options I was thinking of: --host=i386-unknown-mingw32 --with-gcc=c:/mingw/bin/gcc
18:40:19 <coffeemug> and I found two different versions
18:40:23 <dons> coffeemug: check the README first
18:40:31 <dons> that comes in the src tarball
18:40:54 <syntaxfree> econ figure.
18:41:31 <coffeemug> readme doesn't say anything really
18:41:48 <coffeemug> I can try and build it with regular build.mk
18:41:52 <coffeemug> but I don't want to wait four hours :
18:41:53 <coffeemug> :)
18:43:02 <dons> but we have a document on this..
18:43:04 <dons> let me see..
18:43:21 <dons> you can always look at build.mk.sample
18:43:36 <coffeemug> I found this guy
18:43:37 <coffeemug> http://www.haskell.org/ghc/docs/6.4.2/html/building/quick-start.html
18:43:39 <dons> ah, seems to have moved to the wiki, http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking
18:43:40 <lambdabot> Title: 6. Quick start for GHC developers, http://tinyurl.com/v3qnd
18:43:42 <lambdabot> Title: Building/Hacking - GHC - Trac, http://tinyurl.com/y567ol
18:44:00 <coffeemug> and this one
18:44:01 <coffeemug> http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking
18:44:04 <lambdabot> Title: Building/Hacking - GHC - Trac, http://tinyurl.com/y567ol
18:44:07 <coffeemug> the two give different instructions
18:45:05 <dons> no one said build systems are easy :) ever looked at the mozilla build system?
18:45:15 <Igloo> One is for 6.4.2 and the other is (hopefully) current
18:45:18 <emu> is there any way, with QuickCheck, to get ahold of the actual object which falsified a test? it prints out nicely but I want to do some operations on it
18:45:28 <dons> anyway, you should only need a couple of the -Onot or -fasm flags, if you want a fast build
18:45:29 <Igloo> dons: I refuse to believe it's uglier than ghc's  :-)
18:45:42 <dons> Igloo: it's a close race
18:46:25 <dons> emu: you could write your own wrapper for the tests , and do something with the failing test
18:46:37 <dons> start with the QuickCheck src
18:47:05 <coffeemug> yeah, build systems are usually crap
18:47:16 <coffeemug> that's why I strongly believe in ant (even though I hate writing build scripts in xml)
18:47:22 <coffeemug> at least the damned thing works all the time
18:47:28 <coffeemug> anyway
18:47:47 * Igloo hopes to beautify GHC's at some point, but ETOOMANYTHINGSTODO
18:47:48 <coffeemug> does the following look good (sorry for flooding)
18:47:50 <coffeemug> SRC_HC_OPTS     = -H32m -O -fasm -Rghc-timing
18:47:50 <coffeemug> GhcStage1HcOpts = -O0 -DDEBUG
18:47:50 <coffeemug> GhcLibHcOpts    = -O -fgenerics
18:47:50 <coffeemug> GhcLibWays      =
18:47:50 <coffeemug> SplitObjs       = NO
18:49:26 <coffeemug> ?
18:49:52 <dons> hehe, "I just want to say: I admit that call-by-need is probaby cool. Monads are cool too, but maybe not to the extent people wet their pants over them"
18:50:22 <dons> this guy is funny, http://theonlywinningmove.blogspot.com/2006/10/scheme-death-knell.html
18:50:24 <lambdabot> http://tinyurl.com/yd3uzv
18:50:43 <dons> coffeemug: yeah, looks ok.
18:51:14 <coffeemug> the cool thing about monads
18:51:20 <coffeemug> is that first you don't understand them at all
18:51:23 <coffeemug> then you struggle for a year
18:51:24 <dolio> dons: You destroyed his server.
18:51:32 <dons> ok. so maybe i should rewrite the scheme scientific american tuts in haskell
18:51:53 <dons> dolio: hmm!
18:51:55 <coffeemug> then you finally get it and kind of cringe because you think it's a cool hacky way to get around purity
18:51:57 <dons> yeah, Internal Server Error
18:52:16 <coffeemug> and then you start really getting and actually change your mind and start appreciating the abstraction they offer you
18:52:24 <coffeemug> and that's the step I'm at
18:52:24 <dons> coffeemug: and then you write a back tracking concurren sudoku solver, and it clicks :)
18:52:37 <coffeemug> I wonder what's the next step :)
18:52:53 <dons> and its like "Ah! I can abstract over computation order. Wow!"
18:53:28 <Pseudonym> The reason why Schemers don't understand monads is because Scheme does everything that Haskell does without the safety guarantees.
18:53:28 <coffeemug> don't spoil it for me man
18:53:31 <coffeemug> I didn't get there yet :)
18:53:44 <dons> well that's sad. the guy's server really seems to have crashed
18:54:02 <Pseudonym> But the safety guarantees are precisely the cool part.
18:54:02 <dons> web server written in the wrong language, i suppose
18:55:06 <emu> i'm writing a program with the State monad atm.  I think of it as forcing me to think and formalize my state and transitions.
18:56:26 <coffeemug> yeah
18:56:37 <coffeemug> that's actually pretty cool because you create a state object
18:56:44 <coffeemug> think about the state you need
18:56:48 <coffeemug> not just blindly use it
18:58:43 <emu> my initial interpretation of monads was similar to the "state passing interpretation"
18:59:08 <Pseudonym> My first was monads-as-containers.
18:59:33 <Pseudonym> If you come at it from that POV, it's obvious why you can't convert an IO a to an a.
19:03:00 <coffeemug> well
19:03:04 <coffeemug> the thing with haskell papers
19:03:18 <coffeemug> when I was new to Haskell, I still tried to understand monads by reading about them
19:03:26 <coffeemug> and I could kind of understand most of the syntax
19:03:33 <coffeemug> except the algebraic datatypes
19:03:40 <coffeemug> so when someone said something like IO a
19:03:44 <coffeemug> it's like
19:03:51 <coffeemug> what in the world does that mean
19:04:11 <dons> I don't think you're supposed to learn the basics by reading research papers ;) but you're welcome to try
19:04:27 <coffeemug> just because you normally don't write in Java or C (or Lisp) something like SomeType OtherType
19:04:40 <dibblego> algebraic datatypes rock
19:04:42 <coffeemug> dons: there weren't too many other resources (still aren't) at the time I started
19:04:44 <dons> it just happens we have a lot of research papers, and not as many textbooks. for most languages its usually the other way around
19:04:48 <dibblego> try implementing Maybe in Java
19:04:53 <coffeemug> oh yeah
19:04:59 <coffeemug> every single day at work
19:05:04 <coffeemug> I wish there was a Maybe in Java
19:05:08 <coffeemug> but alas :(
19:05:13 <emu> lol, implicit Maybe.. null
19:05:14 <Pseudonym> Java already has Maybe.  "Nothing" is spelled "null".
19:05:31 <Pseudonym> What it doesn't have is a non-Maybe reference.
19:05:33 <emu> algebraic datatypes are for more than monads of course
19:05:35 <coffeemug> Pseudonym: aha, and the safety of Maybe is "NullPointerException"?
19:05:45 <Pseudonym> coffeemug: Of course!
19:05:49 <dibblego> Java does not have Maybe
19:05:54 <emu> Java has Kinda
19:06:21 <dibblego> with runtime failure as a best case
19:06:35 <coffeemug> in Haskell I can control cases when I may not have a value in a safe way
19:06:38 <coffeemug> in Java I cannot
19:06:43 <emu> every day I am thankful I don't have to mess much with Java
19:06:49 <coffeemug> I can litter my code with (if blah != null)
19:06:57 <dibblego> me too, even though I work for a J2EE consultancy :)
19:07:04 <coffeemug> and pray I don't get a NullPointerException at runtime
19:07:06 <coffeemug> that's about it
19:07:17 <dons> ok, so what's the most interesting, popular short tutorial for a hyped language out there? something for ruby say? or python?
19:07:23 <dibblego> coffeemug, yep, every method that accepts one or more reference types should do that - or run through a Proxy to do it
19:07:27 <dons> that could be profitably rewritten in haskell, in a day or two?
19:07:31 <dons> any suggestions?
19:07:56 <dons> and coffeemug, how's the tut going?
19:07:58 <coffeemug> dons: yeah, it's a good strategy
19:08:05 <dibblego> coffeemug, I was just discussing Java's dynamically typed value just 20 minutes earlier and this exact issue
19:08:11 <coffeemug> dons: I kinda got busy coding (and building ghc) so I got stuck in the middle
19:08:29 <lispy> coffeemug: you're coding ghc?
19:08:34 <lispy> coffeemug: from scratch?!?
19:08:44 <coffeemug> aha :)
19:08:56 <coffeemug> dons: if you want to see what it looks like right now, here's the url: http://sources.defmacro.org/in-progress/ramblings/lisp-in-haskell.html
19:09:00 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/ujxvg
19:09:11 <coffeemug> it's work in progress though, so please don't advertise it until I'm done with it
19:09:20 <coffeemug> and it makes it into "defmacro stable" :)
19:09:34 <dons> i wonder if ruby is small enough that i could implement it in haskell in a day or two..
19:09:50 <lispy> coffeemug: cool, i'm writing a little scheme compiler at the moment (but i'm stopped to work on thinsg that have to get done :()
19:10:11 <lispy> dons: smalltalk is
19:10:19 <emu> slick, Graphviz module =)
19:10:28 <vincenz> emu:
19:10:30 <vincenz> ?
19:11:02 <lispy> dons: a professor of mine says he wrote a full smalltalk interpreter in something like less than 200 lines of java
19:11:20 <emu> smalltalk is a pretty simple language
19:11:30 <emu> like scheme in that sense
19:11:37 <lispy> it's called smallworld
19:11:40 <dons> ok. interesting
19:12:27 <Riastradh> coffeemug, how would you implement side effects and mutable data in that interpreter?
19:12:28 <lispy> i wonder about python in haskell too
19:12:40 <lispy> we could just implement all the other popular languages in haskell :)
19:12:57 <liyang> Like Perl6.
19:13:09 <coffeemug> Riastradh: what do you mean?
19:13:16 <lispy> in fact, that might be kinda cool, to have compilers (or interpreters where appropriate) for C, Java, C#, Python, Perl6, Ruby, Smalltalk and so on all in haskell :)
19:13:45 <lispy> heh, hcc
19:13:50 <lispy> haskell compiler collection
19:14:02 <Riastradh> (Glasgow compiler collection...?)
19:14:16 <lispy> or glorious compiler collection
19:14:25 <Riastradh> coffeemug, how would you implement a primitive RPLACA / SET-CAR! or RPLACD / SET-CDR! ?
19:14:31 <dons> Riastradh: the eval function is in IO, type BlaiseResult = StateT Context IO Expr
19:14:39 <dons> is that what you meant?
19:14:51 <lispy> BlaiseResult?
19:15:04 <Riastradh> dons, actually, I'm referring more to the type of lists.
19:16:00 <dons> coffeemug: so is that article done? it says "draft"? could i stick it on reddit (seems not to have been widely published?)
19:16:15 <coffeemug> dons: no, I'm only up to half
19:16:23 <dons> ah ok.
19:16:27 <dons> well, finish it !
19:16:27 <coffeemug> that's why it's just in datcs in-progress
19:17:05 <coffeemug> dons: will do
19:17:10 <coffeemug> any minute
19:17:12 <coffeemug> now :)
19:17:23 <lispy> when/if i finish my scheme compiler i should publish it
19:17:56 <lispy> (I may turn it into some other language compiler first though)
19:18:04 <edwardk_> lispy: heh
19:18:38 <lispy> next on the todo is proper tail recursion
19:18:49 <edwardk_> lispy: i started out writing a javascript compiler and i'm now working on a compiler for weird substructural things that put people to sleep, so it'll probably happen ;)
19:18:58 <lispy> but at the moment i don't want to think about how to crawl around in one of the ASTs and figure out if it's tail recursive
19:19:23 <lispy> edwardk_: heh
19:19:28 <TSC> lispy: Haven't other people already figured that out?
19:19:37 <lispy> TSC: yeah
19:19:48 <lispy> TSC: and now it's my turn to understand it..
19:19:53 <TSC> Ah (:
19:20:15 <lispy> i have a tutorial that explains exactly what it means and roughly what the generated code should be but i have yet to figure out how to make it all line up
19:20:38 <lispy> it's been really good to follow this tutorial
19:21:15 <lispy> so i learned that the code for a tail recursive function just has the arguments of each successive call over top of the old arguments and then a jmp (instead of a call) back to the function
19:22:03 <lispy> so it just keeps running in place with updated values but throwing away the previous stack
19:22:05 <edwardk_> yeah, then tail-call-optimization just generalizes that for calling other functions than yourself
19:22:22 <Riastradh> (I'm thinking about that code in comparison to <http://mumble.net/~campbell/tmp/Scheme.hs>, by the way.  But I'm tired and intruding in the conversation and unlikely to contribute anything useful, so I apologize for jumping in, and I'll find something else to do now.)
19:22:52 * syntaxfree hates the Meijer notation.
19:23:12 <edwardk_> syntaxfree: the squiggol stuff?
19:23:21 <edwardk_> (| x |) etc?
19:23:28 <syntaxfree> the [(b,+]) stuff.
19:23:43 <syntaxfree> I even opened an ana and closed a cata there.
19:23:55 * syntaxfree thought Squiggol was a different language.
19:24:10 <edwardk_> heh, i don't mind (| |) for catamorphism, but after anamorphisms it gets bad
19:24:29 <edwardk_> syntaxfree: well, they kind of borrowed its name for that school of writing
19:24:45 <syntaxfree> hmm.
19:24:59 <syntaxfree> how close is Haskell to Bird-Merteens calculus?
19:25:35 <dons> syntaxfree: pretty close
19:25:43 <dons> |-----| about this close
19:25:54 <edwardk_> gah checking logs
19:26:09 <lennart> add a few squiggles to haskell and remove bottom
19:26:14 <lispy> Riastradh: cool, i think that one is an interpreter
19:26:51 <edwardk_> lennart: that a quote?
19:27:01 <SamB_XP> dons: that looks like almost an inch!
19:27:02 <Riastradh> lispy, no, not really.  It's a very thin compiler -- it is essentially a transcription of denotational semantics (= compilation) into Haskell, not operational semantics (= interpretation).
19:27:11 <Bobstopper> @seen dcoutts
19:27:11 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 1h 32m 50s ago.
19:27:31 <lispy> Riastradh: it turns scheme into haskell?
19:27:50 <SamB_XP> Riastradh: um. Haskell almost *is* denotational semantics.
19:27:54 <Riastradh> No, it doesn't generate Haskell code; it generates an object in a monad.
19:28:04 * SamB_XP still wants to see connotational semantics
19:28:09 <Riastradh> SamB_XP, yes, that's why the code is not very much different from section 7.3 of R5RS.
19:28:44 <lispy> Riastradh: why is it not an interpreter?
19:29:05 <SamB_XP> lispy: don't listen to riastradh, it sounds just like one to me
19:29:20 <SamB_XP> its just one of the nice-looking kind, not the ugly-looking kind
19:29:24 <Riastradh> lispy, a denotational semantics is a map from a syntactic domain to a semantic domain -- a transformation from program terms to their meaning.
19:29:46 <chessguy> which doesn't exist for haskell yet, sadly enough
19:30:00 <Riastradh> A semantic function is, very importantly, guaranteed to terminate, and it is compositional.
19:30:28 <SamB_XP> chessguy: we are far to lazy to make one
19:30:43 <SamB_XP> oh, and people keep adding features which makes it even harder
19:30:45 <Riastradh> An operational semantics, on the other hand, is a state machine where states are program states, or states of the world at times of execution, the last of which contains the answer of the program.
19:30:46 <dons> ok guys, feel free to put up solutions to the ruby quiz puzzles in better looking Haskell, http://haskell.org/haskellwiki/Haskell_Quiz :)
19:30:48 <lambdabot> Title: Haskell Quiz - HaskellWiki
19:31:03 <syntaxfree> Bird-Merteens calculus has no bottom?
19:31:49 <Riastradh> Scheme.hs maps program terms (i.e. Lisp objects) into the semantic domain of Haskell, yielding objects in the `Command' monad.  One can then execute these commands with program states to yield answers.
19:32:07 <syntaxfree> for additional obscurity, Haskell should drop informative function names and use bananas and lenses instead.
19:32:27 <SamB_XP> syntaxfree: apparantly we gave up on not taking over the world?
19:32:35 <SamB_XP> so I think we aren't doing that?
19:32:56 <syntaxfree> It'd be like a Malbolge that actually does something useful.
19:33:00 * syntaxfree laughs hysterically.
19:33:12 <SamB_XP> I don't remember what that is
19:33:21 <syntaxfree> @google malbolge
19:33:22 <Riastradh> The tricky part, though, is that analysis of the syntactic structure is, in fact, a command itself, because it depends on the state of the Lisp program -- specifically, the store, specifying the contents of locations of Lisp subobjects.
19:33:24 <lambdabot> http://www.lscheffer.com/malbolge.html
19:33:25 <lambdabot> Title: Malbolge re-direct page
19:33:49 <SamB_XP> Riastradh: I told you it was an interpreter!
19:34:09 <Riastradh> (And this is what I see lacking in coffeemug's evaluator.)
19:34:39 <syntaxfree> "Although the language has been out for many years, the most complex known program (until now) is 'hello, world', available in several versions."
19:34:41 <Riastradh> SamB_XP, well, the interpreter is encoded in Haskell -- it's implied in the `runCommand' function.  The whole thing is structured as a compiler, though.
19:34:51 <lispy> actually, i should probably take the lisp parser i wrote and hook it up withe compiler i wrote...
19:34:57 <SamB_XP> Riastradh: uh huh
19:35:02 <lispy> it would make programming in my language a lot easier
19:35:12 <SamB_XP> heh
19:35:23 <SamB_XP> why would you want to use a lisp parser with your language?
19:35:27 <SamB_XP> is your language a lisp?
19:35:38 <lispy> source -> AST |----gap---| IntermediateRep -> Assembly
19:35:39 <SamB_XP> (if so, wth didn't you already get it hooked into a lisp parser?)
19:35:58 <lispy> that's what i have right now :)
19:36:14 <SamB_XP> isn't the gap an expensive place?
19:36:28 <lispy> SamB_XP: well, so far it's based on scheme (the code generation) but i could map subsets of many languages on to that representation, right?
19:37:06 <SamB_XP> what is the Haskell function to read trinary?
19:37:07 <lispy> i just have, lets, function application, lambdas and several types of basic values
19:37:11 <SamB_XP> @hoogle radix
19:37:12 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
19:37:15 <SamB_XP> @hoogle base
19:37:16 <lambdabot> Text.Html.base :: String -> HtmlAttr
19:37:16 <lambdabot> Test.HUnit.Base :: module
19:37:16 <lambdabot> Text.Html.basefont :: Html
19:37:25 <SamB_XP> @hoogle showBase
19:37:26 <lambdabot> No matches found
19:37:29 <lispy> oh and primitive functions and variables
19:37:42 <SamB_XP> @hoogle a -> Int -> ShowS
19:37:43 <lambdabot> Prelude.showsPrec :: Show a => Int -> a -> ShowS
19:37:54 <SamB_XP> @hoogle a -> Int -> Int -> ShowS
19:37:55 <lambdabot> No matches, try a more general search
19:38:04 <SamB_XP> @hoogle Int -> ReadS
19:38:05 <lambdabot> No matches, try a more general search
19:38:07 <SamB_XP> @hoogle Int -> ReadS a
19:38:08 <edwardk_> lispy: we're in very similar stages in our compiler writing =)
19:38:09 <lambdabot> Text.ParserCombinators.ReadPrec.readPrec_to_S :: ReadPrec a -> Int -> ReadS a
19:38:09 <lambdabot> Prelude.readsPrec :: Read a => Int -> ReadS a
19:38:18 <SamB_XP> @hoogle Int -> Int -> ReadS a
19:38:20 <lambdabot> No matches, try a more general search
19:38:26 <SamB_XP> @hoogle Int -> Int -> String -> a
19:38:28 <lambdabot> No matches, try a more general search
19:38:29 <sjanssen> SamB_XP: it's something like readInt -- in Numeric
19:38:34 <SamB_XP> @hoogle readInt
19:38:35 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:38:36 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:38:36 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
19:38:41 <lispy> edwardk_: cool, i should have you look at my code and critque it :) (Actually i was thinking of sending it to haskell-cafe asking for opinions)
19:38:54 <SamB_XP> @hoogle readIntBase
19:38:56 <lambdabot> No matches found
19:38:58 <SamB_XP> @hoogle readInt
19:38:59 <lambdabot> Numeric.readInt :: Integral a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:38:59 <lambdabot> Numeric.readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
19:38:59 <lambdabot> Text.Read.Lex.readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
19:39:11 <SamB_XP> sorry for flooding the channel...
19:39:14 <SamB_XP> @google hoogle
19:39:16 <lambdabot> http://haskell.org/hoogle/
19:39:17 <lambdabot> Title: Hoogle
19:40:54 <dons> SamB_XP: you're getting to be an old hand now, remember the privmsg..
19:40:55 <edwardk_> lispy: would happily do so
19:41:22 <SamB_XP> dons: notice that I just went to the web interface for hoogle?
19:41:32 <SamB_XP> yes I realize I could have typed the URL in by hand
19:41:54 <SamB_XP> I am thinking the function I was looking for just ain't
19:42:21 <sjanssen> SamB_XP: you want to read a number in base 3?
19:42:31 <SamB_XP> sjanssen: how did you guess?
19:42:43 <sjanssen> SamB_XP: did you not see readInt
19:42:45 <sjanssen> ?
19:43:01 <SamB_XP> oh.
19:43:03 <SamB_XP> sorry.
19:43:10 <SamB_XP> it takes so many functions I was thrown
19:43:27 <SamB_XP> X-(
19:44:30 <syntaxfree> Lambdabot should have a feature that converts Squiggol notation into Haskell.
19:48:17 <SamB_XP> > readInt 0 -> (`elem` "012") (flip (-) ord '0' . ord) "01001200211"
19:48:18 <lambdabot>  Parse error
19:48:26 <SamB_XP> > readInt 0 (`elem` "012") (flip (-) ord '0' . ord) "01001200211"
19:48:28 <lambdabot>  Couldn't match `Char -> Int' against `Char'
19:48:57 <SamB_XP> > readInt 3 (`elem` "012") (flip (-) ord '0' . ord) "01001200211"
19:48:59 <lambdabot>  Couldn't match `Char -> Int' against `Char'
19:49:08 <SamB_XP> @type (flip (-) ord '0' . ord)
19:49:09 <lambdabot>   Couldn't match `Char -> Int' against `Char'
19:49:10 <lambdabot>    Expected type: Char -> Int
19:49:20 <SamB_XP> @type flip (-) ord '0'
19:49:22 <lambdabot>   Couldn't match `Char -> Int' against `Char'
19:49:22 <lambdabot>    Expected type: Char -> Int
19:49:38 <SamB_XP> > readInt 3 (`elem` "012") (flip (-) (ord '0') . ord) "01001200211"
19:49:40 <lambdabot>  [(20920,"")]
19:49:45 * SamB_XP sighs
19:49:48 <SamB_XP> too tired for this
19:51:04 <syntaxfree> the hawiki should have a "Best  lamdabot fights" section.
19:51:22 <syntaxfree> it's like one of those rotating fist boxing machines.
19:51:32 <SamB_XP> hah
19:51:40 <SamB_XP> they tend to be very boring
19:55:38 <syntaxfree> what's the haskell equivalent of the "product" functor in Squiggol?
19:56:36 <sjanssen> > product [1..3] -- like this?
19:56:38 <lambdabot>  6
19:56:48 <syntaxfree> nope. the product functor.
19:57:08 <sjanssen> I'm afraid I'm unfamiliar with Squiggol
19:57:30 <syntaxfree> D || D = { (d, d') | d in D, d' in D'}
19:57:52 <syntaxfree> (f || g) (x, x') = (f x, g x')
19:57:54 <lambda_the_insig> like a cross-product?
19:57:57 <sjanssen> > liftM2 (,) [1..3] [4..6]
19:57:59 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
19:58:19 <syntaxfree> yes, but it's a functor, so it's also a relation on types.
19:58:30 <syntaxfree> not only on functions.
19:59:13 <coffeemug> whoohooooo
19:59:15 <syntaxfree> cf. Meijer (1991) page 7
19:59:17 <coffeemug> looks like I got a good build
19:59:20 <coffeemug> of ghc
19:59:23 <coffeemug> :-D
19:59:28 <syntaxfree> 11:58 PM  coffeemug: looks like I got a good build
19:59:31 <syntaxfree> been going to the gym?
19:59:38 <dons> coffeemug: good.
19:59:50 <coffeemug> I am zipping this up and buring it on give separate cds
19:59:51 <dons> ah, seems to be back up. fun http://theonlywinningmove.blogspot.com/2006/10/scheme-death-knell.html
19:59:54 <coffeemug> just in case :)
19:59:58 <lambdabot> Title: The Only Winning Move: Scheme Death Knell?, http://tinyurl.com/yd3uzv
20:00:35 <dons> its kind of ranty, and makes me smile. e.g. "I think Haskell is a fad" :)
20:01:11 <syntaxfree> Python's leader Guido van Rossum seems to think Haskell  is just a matter of contrived syntax, offering no real advantage over Python.
20:01:22 <dons> good on him.
20:01:59 <x3m> coffeemug: you built it without cygwin now?
20:02:12 <dons> you always quote guido at us, syntaxfree. why?
20:02:13 <dons> $ grep -i 'syntaxfree.*guido'  * | wc -l
20:02:13 <dons> 11
20:02:14 <dons> :)
20:02:15 <coffeemug> dons: that's pretty funny
20:02:26 <coffeemug> x3m: I tried without cygwin before
20:02:30 <lispy> http://infohost.nmt.edu/~val/kitchen.html
20:02:30 <coffeemug> not sure what's different now
20:02:32 <lambdabot> Title: The Honeywell H316 Kitchen Computer
20:02:34 <coffeemug> except the build.mk
20:02:38 <dons> e.g. 06.09.04:19:02:36 <syntaxfree> Guido van Rossum is a complete idiot about functional programming. He seems to think it's a matter of syntax ;)
20:02:49 <syntaxfree> Guido is the world's anti-Haskell leader ;)
20:03:24 <Adamant> Haskell has some very good concepts
20:03:34 <Adamant> but unfortunately, it still has ugly syntax
20:03:46 <lispy> forget the honeywell kitchen computer, i want the model in the photos...
20:03:49 <Adamant> just less ugly syntax than many other languages
20:03:52 <coffeemug> syntax is in the eye of the beholder
20:03:55 <palomer> man I'm tired
20:03:57 <coffeemug> I got used to haskell syntax
20:03:58 <syntaxfree> Squiggol syntax now!
20:04:00 <coffeemug> now it seems beautiful to me
20:04:02 <dons> discussions about syntax should be banned.
20:04:02 <syntaxfree> Monad comprehensions too!
20:04:04 <coffeemug> same with lisp, really
20:04:04 <x3m> coffeemug: didnt get it to work without cygwin?
20:04:16 <Adamant> dons: so is that an endorsement of Lisp?
20:04:17 <coffeemug> x3m: no, it's without cygwin
20:04:17 <Adamant> ;)
20:04:19 <coffeemug> just with msys
20:04:20 <syntaxfree> Lisp has its own brand of stark beauty.
20:04:34 <dons> Adamant: its an endorsement of discussions about semantics
20:04:34 <palomer> haskell syntax does the same thing as the haskell type system: it makes life hard for us
20:04:38 <x3m> coffeemug: oh, hs-plugins without cygwin also?
20:04:54 <lispy> ?palomer
20:04:55 <lambdabot> (_|_)
20:05:03 <Adamant> @quote dons
20:05:03 <lispy> hmm...
20:05:04 <lambdabot>  boegel, stop polluting the quote-space please
20:05:11 <palomer> ?palomer
20:05:11 <lispy> ?quote Adamant
20:05:12 <lambdabot> That's nuts!
20:05:12 <lambdabot>  Haskell makes my brain taste like burning
20:05:16 <palomer> ?palomer
20:05:16 <lambdabot> I have news for you, it's pointless
20:05:25 <palomer> when did I say that?
20:05:47 <lispy> ?keal
20:05:47 <lambdabot> Keal was so happy with T, coded in basic so run on anything, and does lot
20:05:52 <sjanssen> hahaha
20:06:01 <sjanssen> those always make me laugh
20:06:09 <lispy> keal was crazy
20:06:27 <syntaxfree> ?lispy
20:06:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:06:28 <Adamant> keal sounds like he would be a blast if you got him on IRC while drunk
20:06:28 <dons> he reappeared just briefly last week
20:06:41 <palomer> lispy has a command?
20:06:44 <lispy> dons: no way?
20:06:49 <palomer> you cheapened it!
20:06:50 <palomer> bastard
20:07:00 <lispy> palomer: no, it confused lispy for list
20:07:06 <lispy> ?list
20:07:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
20:07:19 <dons> ?seen OrangeKid
20:07:20 <lambdabot> I haven't seen OrangeKid.
20:07:42 <lispy> ?keal
20:07:42 <lambdabot> ghc need to have plugin that allow copy paste in xp
20:07:47 <palomer> phew
20:07:55 <palomer> ok, world order has been maintained
20:08:05 <palomer> we need keal back
20:08:11 <lispy> ?keal
20:08:11 <lambdabot> T seems to be haskell, except with a decent interface at this point
20:08:25 <lispy> wonder why i'm not getting a quote about math having a bug
20:08:26 <lispy> ?keal
20:08:27 <lambdabot> there is no way to prove the failsafe exists
20:08:37 <dons> so had a couple of names
20:09:14 <dons> oh, he actually spoke lsat week!
20:09:15 <dons> 06.10.18:19:46:08 <OrangeKid> i still dont understand how gci is supposed to do anything other than mathematics :/
20:09:28 <dons> I missed that!
20:09:54 <lispy> i think the lovely woman in those photographs is actually a CS researcher
20:10:23 <syntaxfree> dons: that was my very first impression of scheme.
20:10:28 <dons> heh
20:10:43 <syntaxfree> "Oh, geeze, a 20Mb download and it's just an RRPN calculator."
20:10:50 <lispy> ah, she's a linux kernel dev
20:11:01 <palomer> lispy, which photographs?
20:11:15 <lispy> http://infohost.nmt.edu/~val/kitchen.html
20:11:16 <lambdabot> Title: The Honeywell H316 Kitchen Computer
20:11:32 <palomer> lovely and linux go together like haskell and realworld
20:11:35 <syntaxfree> She is hardly lovely.
20:12:07 <palomer> she has an underbite!
20:12:10 <palomer> and poor posture
20:12:13 <Pseudonym> syntaxfree, how can you say taht?  You don't know her.
20:12:17 <Pseudonym> She may be a lovely person.
20:12:22 <palomer> and big arms
20:12:29 <syntaxfree> "Lovely woman in the photographs".
20:12:49 <syntaxfree> the polka dot dress is a fetish thing, maybe.
20:12:57 <Pseudonym> BTW, if she can hack the kernel, that does me regardless of what she looks like.
20:13:06 <lispy> hehe, if you read the captions the know the dress was on purpose :)
20:13:39 <syntaxfree> I know it was.
20:13:43 <syntaxfree> It's like a fetish porn essay.
20:13:45 <palomer> hacking kernels is not enough to do me
20:14:28 <palomer> she should have spent the money on a chiropractor
20:14:37 <dons> I think syntaxfree reads some weird porn then
20:14:48 <syntaxfree> I don't read porn. I'm almost married.
20:15:06 <palomer> marred men read porn
20:15:09 * lispy wants to comment but just leaves it there....
20:15:09 <palomer> married women too
20:15:20 <syntaxfree> Well, maybe it's because I'm not married yet.
20:15:36 <syntaxfree> Why read porn when you can watch it, anyway?
20:15:57 <palomer> the book is always better than the movie
20:16:00 <palomer> that's why
20:16:20 <palomer> besides, certain kinds of porn simply can't be filmed
20:16:21 <sjanssen> "The purely functional stuff is crap and is actually an argument against Haskell, in my opinion." -- this guy just doesn't get it
20:16:32 <palomer> I once read a book where a robot had sex with an amoeba
20:16:47 <lispy> sjanssen: url?
20:16:52 <syntaxfree> what is a "cpo"?
20:17:04 <dons> sjanssen: yeah, its great fun!
20:17:07 <lispy> syntaxfree: 1/3 of a robot?
20:17:08 <sjanssen> lispy: http://theonlywinningmove.blogspot.com/2006/10/scheme-death-knell.html -- dons posted it maybe 15 min. ago
20:17:10 <lambdabot> Title: The Only Winning Move: Scheme Death Knell?, http://tinyurl.com/yd3uzv
20:17:24 <sjanssen> dons: was this posted to reddit?  Can I go argue about it?
20:17:26 <dons> i think impure language guys are freaked by purity. its good marketing
20:17:29 <syntaxfree> * gratuitous observation about Guido van Rossum here *
20:17:32 <lispy> c3po....on nevermind...
20:17:39 <dons> sjanssen: the response was, yes.http://programming.reddit.com/info/nq1k/comments
20:17:41 <lambdabot> Title: Haskell and Scheme: Which One and Why? (reddit.com), http://tinyurl.com/y83lp6
20:18:03 <dons> note that's the pro-haskell response that was posted.
20:18:26 <dons> but its so funny, it hardly needs critiquing.
20:18:39 <dons> since he ends up admitting that haskell is cool
20:19:09 <syntaxfree> dons: it seems to be all syntax debates.
20:19:17 <syntaxfree> No real debate about dynamic x strong typing.
20:19:36 <dons> its the entry point to the language, i guess
20:19:44 <syntaxfree> or metaprogrammability x laziness (not that these are incompatible, it's just that each one is a strong point for each language)
20:20:22 <lispy> wth? "I think the only actual reason that people switch to Haskell and so on is just to jump a train."
20:20:25 <lispy> what does that mean?
20:20:29 <dons> i think though, the fundamental issue is that haskell is newer, and growing faster. it will replace scheme in many domains in the years to come, I think.
20:20:45 <syntaxfree> Haskell has this really cool aura coming from deep cat theory.
20:20:47 <dons> as a child of scheme, it learns from its mistakes, and adds 20 years of language research
20:20:54 <syntaxfree> It also got a big big boost with Pugs.
20:20:56 <palomer> haskell and so on helps you to jump a train, duh!
20:21:04 <chessguy> and it's a lot of fun to say 'monads' :)
20:21:14 <SamB_XP> cat theory?
20:21:23 <SamB_XP> do you have any idea how badly understood cats are?
20:21:28 <SamB_XP> any idea at all?
20:21:30 <syntaxfree> chessguy: unfortunately, the new, more general concept is just called "arrow"
20:21:32 <lispy> arguments that language x trumps language y is bunk
20:21:44 <lispy> why do people post trash like that?
20:21:46 <chessguy> arrows are more general than monads?
20:22:06 <SamB_XP> wait until you see spears!
20:22:15 <SamB_XP> but *don't* hold your breath
20:22:55 <syntaxfree> the new, more general concept should have an off-the-wall name like "Toopreyes"
20:23:06 <syntaxfree> then Ruby will copy toopreyes.
20:23:11 <vegai> reddit's kod: "Haskell and Scheme? I'll take both, thanks."
20:23:14 <syntaxfree> @google anatomy of a programming fad
20:23:17 <lambdabot> http://hope.cs.rice.edu/twiki/pub/WG211/M3Schedule/foozles.pdf
20:24:32 <vegai> I don't know... if it was my choice, I'd have "Programming 101" in Scheme and the rest in Haskell
20:25:08 <syntaxfree> my school taught "Introduction to Computer Science" in Scheme and then "Data Structures" in C.
20:25:13 <syntaxfree> I never took Data Structures.
20:25:16 <SamB_XP> hehe
20:25:20 * syntaxfree is an economist.
20:25:40 <SamB_XP> well, how fortunate for you that you at least didn't have to take data structures
20:25:44 <SamB_XP> C is lousy at those
20:25:54 <syntaxfree> my school invented Lua.
20:26:02 <sjanssen> I've never bought into this macro/extensible syntax thing.  Sure, you can define all the nice syntax from Haskell in Scheme, but who will understand your code that uses all these obscure macros?
20:26:29 <syntaxfree> sjanssen:  it's bottom-up programming.
20:26:41 <vegai> sjanssen: if they're obscure, the programmer is lousy. And the programmer can be lousy in any language
20:26:45 <sjanssen> syntaxfree: could you elaborate?
20:26:47 <syntaxfree> Haskell supports a bottom-up style in some form, but it requires a lot more formal thinking.
20:26:59 <SamB_XP> vegai: obscure means also "little-known"
20:27:05 <SamB_XP> not just "hard to understand"
20:27:11 * SamB_XP goes to bed now
20:28:00 <syntaxfree> @google bottom-up programming
20:28:03 <lambdabot> http://www.paulgraham.com/progbot.html
20:28:04 * syntaxfree goes to bed now
20:28:04 <lambdabot> Title: Programming Bottom-Up
20:28:07 <vegai> arrows are obscure. Monads are obscure.
20:28:19 <sjanssen> vegai: so, these arguments like "Scheme can do pattern matching with some macro library" are kind of bunk then, right?
20:28:31 <vegai> sjanssen: they are.
20:28:57 <syntaxfree> yes. pattern-matching in Lisp will be just syntactic sugar.
20:29:09 <vegai> their value is only proof-of-concept
20:29:26 <syntaxfree> whereas Haskell pattern-matching is about unleashing data constructors
20:29:39 <vegai> if one ends up doing Haskell in Scheme, perhaps it'd be a good idea to just use Haskell then :)
20:30:15 <syntaxfree> Scheme is dynamically typed.
20:30:32 <syntaxfree> It might emulate Haskell syntax, but that's all it is, emulated syntax.
20:30:54 <syntaxfree> Pattern-matching syntactic sugar for a dynamic language misses the point of pattern-matching in Haskell.
20:30:54 <vegai> yep. It'd be just silly, really
20:33:33 <lispy> vegai: ya, i usually tell people, when you're programming in Y and wishing it worked like X, just stop using Y and start using X :)
20:33:40 <vegai> from reddit: "OCaml's syntax is less scary than Scheme (more like Haskell). " I just cannot see that.
20:34:00 <vegai> aye..
20:34:11 <vegai> but that post sure is a good troll :)
20:37:59 <syntaxfree> "letrec" is uglier than ugly.
20:38:16 <syntaxfree> I keep thinking "I wish GNU R had closures and lambdas".
20:38:35 <syntaxfree> But GNU R has thousands of complex statistical functions it'd take me 10 years to reimplement.
20:38:40 <syntaxfree> So I'm mostly stuck with it.
20:39:08 <int-e> maybe you can metaprogram it, write a preprocessor?
20:39:14 <lispy> gr....this guy is conflating call-by-name with call-by-need
20:40:02 <syntaxfree> int-e: it's like a statistical package that became a full-fledged interpreted programming language.
20:40:06 <syntaxfree> it even has higher-order functions.
20:40:19 <syntaxfree> (um, it does have closures of sorts. But no lambdas)
20:40:19 <dons> syntaxfree: why not write a binding to R then?
20:40:24 <dons> that's kind of the point of the FFI
20:40:38 <lispy> binding to R would be interesting
20:40:45 <syntaxfree> R has also advanced graphing capabilities.
20:40:45 <lispy> R is very much lisp under the hood
20:41:14 <lennart> SamB: digitToInt
20:41:16 <lispy> haha
20:41:19 <lispy> "So anyway - lots of the stuff that's supposedly cool about Haskell is...well, cool, but maybe not as cool as we're often led to believe."
20:41:22 <tmoertel_away> I think that R does have lambdas:  (function(x) x + 1)(3) ==> 4
20:41:28 <lispy> and i thought this guy was just saying that haskell was the debil
20:41:38 <syntaxfree> for what I've seen,  R is pretty much Fortran under the hood.
20:41:40 <int-e> lispy: who is 'this guy' you were refering to?
20:41:49 <lispy> http://theonlywinningmove.blogspot.com/2006/10/scheme-death-knell.html
20:41:52 <lambdabot> http://tinyurl.com/yd3uzv
20:41:55 <syntaxfree> tmoertel: um, cool. Now I just need to write map, filter, etc.
20:42:30 <int-e> lispy: funny. did he really write "Internal Server Error" ;) (I'll try again later)
20:42:33 <tmoertel> syntaxfree: R has equivalents, but if you want to be R-esque, you should look into the vector operations.
20:42:37 <lispy> int-e: i'm actually wondering if he mistakenly said said call-by-need where he meant call-by-name (and vice versa) in a few places
20:42:42 <lispy> int-e: heeh
20:42:52 <lispy> int-e: yea, i think the server is getting hammered at the moment?
20:42:58 <syntaxfree> tmoertel: I use vector operations to the end.
20:43:02 <syntaxfree> I started programming with Matlab.
20:43:13 <syntaxfree> My code used to be endless chains of matrix multiplications.
20:43:17 <syntaxfree> No explicit loops whatsoever.
20:43:31 <syntaxfree> Somehow, I thought that'd make it more efficient. Now I can't read half of what I wrote.
20:44:33 <lispy> okay, so his point is just that scheme is good, haskell is okay too, so can't we all just get along?
20:44:49 <syntaxfree> * random mention of Guido van Rossum *
20:44:58 <syntaxfree> don't jump at that guy, GvR is the real enemy.
20:45:22 <syntaxfree> He has real mindshare in the programming language crowd, and he'll jump at Haskell at every opportunity.
20:45:38 <vincenz> Hmm
20:45:44 <vincenz> I am sorry to say that the article by graham
20:45:45 <syntaxfree> Perl's Larry Wall will often jab at Haskell saying you need a 350 IQ to program in it, but that's different from what GvR does.
20:45:49 <vincenz> "progbot.html"
20:45:51 <vincenz> makes NO SENSE
20:45:53 <dons> please stop talking about Guido syntaxfree
20:46:04 <syntaxfree> will do.
20:46:06 <dons> i don't see how it contributes anything new.
20:46:28 <syntaxfree> It was a discussion about unfounded critiques of Haskell.
20:46:39 <sjanssen> Wall has to respect Haskell -- it finally got Perl 6 off the ground
20:46:41 <syntaxfree> It's definitely on the topic. But anyway, I'm sleepy.
20:46:55 <dons> syntaxfree: btw, Larry Wall: Perl is turning into Haskell. Someone shoot me. Take Lisp, you know it's the most beautiful language in the world -- at least up until Haskell came along.  ;)
20:47:37 <sjanssen> dons: Larry Wall, the originator of Perl, is obviously a leading expert on beautiful languages ;)
20:47:48 <vegai> sjanssen: *shudder*
20:48:06 <dons> :)
20:48:18 <lispy> okay, i just read the best explanation of what's wrong with HCI on this PG page: http://paulgraham.com/langdes.html
20:48:20 <lambdabot> Title: Five Questions about Language Design
20:48:22 <lispy> point #2
20:48:31 <lispy> generalize it to all computer-human interaction
20:48:39 <sjanssen> but hey, never look a gift horse in the mouth
20:48:42 <lispy> and you have one of my grips with HCI in a nut shell
20:48:57 <syntaxfree> Later.
20:51:36 * tmoertel wishes that "-" was a legal identifier character in Haskell
20:52:29 <lispy> tmoertel: ah yeah, that was nice in lisp
20:52:44 <lispy> do-some-stuff
20:52:52 <lispy> that's a nice function same in lisp
20:53:10 <syntaxfree_aslee> In R, "." is a legal identifier character.
20:53:13 <tmoertel> that's the one thing I would change to make Haskell "more beautiful" :)
20:53:17 <lispy> esp. for dvorak typists that don't have to reach for the - character
20:53:27 <syntaxfree_aslee> my.function
20:53:38 <emu> lisp allows most any character in symbols
20:53:54 <emu> and yea, i keep trying to M-f and M-b around in variable names, sigh
20:53:54 <syntaxfree_aslee> . is for tuples though, right?
20:53:57 <lispy> emu: actually it does assuming you use the right escaping
20:54:07 <tmoertel> thisIsKindOfClunkyAndUgly, but-this-is-much-easier-on-the-eyes
20:54:13 <lispy> |This is a lisp identifier|
20:54:20 <emu> as.is.this
20:55:01 <tmoertel> but, alas, that ship has sailed . . .
20:55:05 <emu> doesn't the case-sensitivity of haskell identifiers pose some issues for foreign language programs?
20:55:11 <emu> (foreign to USA that is)
20:55:33 <altan> Some newbie trouble: following tutorials and a book I bought, I can't seem to use the assignment operator in ghci. I get "parse error on input `='".
20:55:44 <altan> (this is when saying, x = 4 etc.)
20:55:46 <emu> let a = 1
20:55:47 <dons> let f x = x
20:55:48 <tmoertel> let x = 4
20:55:53 <dons> jinx!
20:55:58 <syntaxfree_aslee> you can't just say "x = 4" in ghci.
20:56:01 <tmoertel> wow, in *stereo*, and then some
20:56:07 <syntaxfree_aslee> that's the proper form for saved code, though.
20:56:11 <altan> ah, I thought of the "let", but I'm not quite sure of let's implications right yet
20:56:17 <altan> is hugs different from ghci in this sense?
20:56:21 <emu> well "assignment" is not quite the right term
20:56:24 <dons> yes, hugs doesn't support let.
20:56:26 <emu> yes, altan
20:56:32 <dons> in the interactive prompt
20:56:34 <int-e> "Continuations - if you know what they are - I don't need to explain them. If you don't know what they are - you don't want to know." -- Larry Wall
20:56:41 <x3m> hugs isnt l33t
20:56:51 <dons> so in hugs the only way to declare new bindings is via the source file
20:56:53 <altan> the book uses Hugs, is it better to continue with Hugs instead for learning?
20:56:54 <altan> ah
20:57:01 <dons> int-e, hmm. nice.
20:57:02 <edwardk_> i like that wall quote, stealing it =)
20:57:07 <emu> frankly i never bothered with hugs
20:57:14 <x3m> hugs is l33t
20:57:24 <dons> hugs is a bit too 20th century for my taste ;)
20:57:29 <emu> maybe the error msgs are nicer
20:57:39 <x3m> how can you change the default dir which ghc looks in(win)?
20:57:42 <emu> i'm accustomed to decrypting SML/NJ msgs
20:58:00 <x3m> or if you can add several dirs where ghc looks in
20:58:01 <edwardk_> emu: it might pose a problem if people actually had unicode characters to work with before now in a usable compiler. now we'll see if folks try writing in ghc in other languages and what shakes out
20:58:36 <lispy> was that wall quote supposed to be sort of an CPS example :)
20:59:04 <lennart> someone needs to port hugs to java
20:59:12 <emu> for example, how would you distinguish between type names and variable names in a language like Japanese
20:59:23 <tmoertel> lennart: would you call it "jugs" ?
20:59:35 <lennart> not a bad idea ;)
20:59:41 <tmoertel> seems like that name could get one into trouble   ;-)
20:59:53 <lennart> or attract more users
21:00:01 <tmoertel> not to mention the mascot . . .
21:00:58 <lennart> seriously, hugs on java would be cool.  think of all those cell phones...
21:00:59 <dons> oh my
21:01:02 <dons> yeah.
21:01:18 <dons> yhc on java might be doable too, with only a little effort
21:01:44 <lennart> maybe that would be easier
21:01:52 <tmoertel> for mobile phones, wouldn't you have to target a subset of the normal JVM?
21:01:53 <lispy> is yhc the one ndm talks about?
21:02:01 <lispy> if so, i think it already can compile to jvm
21:02:22 <lispy> but maybe you want the whole compiler on the mobile device?
21:02:43 <dons> doesn't it generate .Net code?
21:02:43 <mgoetze> hullo... how can i get 64-bit random numbers?
21:02:45 <lispy> and jhc can target the nokia, iirc (ask shapr)
21:02:54 <lennart> tmoertel: i think the jvm is complete.  but the libraries are limited
21:03:01 <dons> mgoetze: System.Random
21:03:07 <lispy> randomR (minBound::Int64, maxBound)
21:03:11 <lispy> something like that
21:03:20 <lispy> and Int64 is probably in Data.Int
21:03:32 <mgoetze> ghci sez: "No instance for (Random Int64)"
21:03:42 <lennart> you need to add one :)
21:03:52 <dons> yeah, map it from the Integer instance, perhaps
21:04:05 <mgoetze> > (take 5 $ randoms (mkStdGen 1))::[Int64]
21:04:06 <dons> ah, no. Bounded :)
21:04:06 <lambdabot>  [7917908265643496962,-1017158127812413512,-1196564839808993555,1285246787679...
21:04:17 <mgoetze> funny, lambdabot can do it
21:04:19 <dons> there you go.
21:04:24 <mgoetze> so why can't ghci? :(
21:04:44 <dons> lambdabot has an instance
21:05:10 <dons> here, with free cookies,
21:05:11 <dons> instance Arbitrary Int64 where
21:05:12 <dons>   arbitrary     = sized $ \n -> choose (-fromIntegral n,fromIntegral n)
21:05:12 <dons>   coarbitrary n = variant (fromIntegral (if n >= 0 then 2*n else 2*(-n) + 1))
21:05:38 <dons> oh, Arbitrary. you want Random. /me looks some more ...
21:05:39 <mgoetze> well, i wasn't planning to add irc functionality to my program to interface with lambdabot :) besides, it would probably be a bit too inefficient for monte carlo simulations
21:05:59 <dons> instance Random Int64 where
21:06:00 <dons>   randomR = integralRandomR
21:06:00 <dons>   random  = randomR (minBound,maxBound)
21:06:41 <dons> mgoetze: but you might want to look at the mersenne twister bindings. i had to use them for our monte carlo simulator, as randoms became a bottlneck
21:07:29 <lennart> dons: I have a mersenne twister in Haskell
21:07:43 <mgoetze> well, right now i'm just prototyping, i already assumed that i would need to write my own prng eventually
21:07:54 <mgoetze> lennart: how long is it, and can i have it? :)
21:08:06 <lennart> lemme check
21:08:34 <dons> binding to this is also pretty easy, http://www.cse.unsw.edu.au/~dons/tmp/mtrandom.c
21:08:36 <lambdabot> http://tinyurl.com/y89xht
21:09:08 <dons> oh, but no 64 bit function, you'd have to hack that up or steal it
21:09:27 <lennart> it's a 100 lines. i'll put it in my darcs repository.  hang on
21:09:41 <dons> lennart++
21:10:38 <int-e> lispy: I got to that scheme death knell article. I think he's a bit confused by the call by need and call by name thing, too. He says it best: "I dunno - I can't prove it but I think there's something cheesy about this."
21:11:20 <dons> int-e, so you think that might be a bit hand-wavy?
21:11:28 <int-e> lispy: I just agree with one thing - monads are overrated. They're useful, but they're a fairly simple pattern even if it occurs very frequently.
21:11:34 <int-e> dons: yes :)
21:12:06 <mgoetze> i don't really need 64 bits for the monte carlo part, though... those are just for generating the zobrist hashes
21:12:07 <lennart> http://www.augustsson.net/Darcs/MT/
21:12:12 <lambdabot> Title: Index of /Darcs/MT
21:12:15 <dons> "cheesy" is usually not a very convincing rhetoric device
21:12:37 <int-e> dons: he pretty much admits that he isn't very convincing :)
21:12:56 <mgoetze> thanks lennart
21:13:39 <mgoetze> i could probably even generate the random numbers elsewhere and then hardcode them into the program, but that's ugly of course :)
21:13:57 <lennart> it's not super efficient.  ghc doesn't do a good job with the ST monad inside it :(
21:15:24 <lennart> but's a a neat example of how you can encapsulate a piece of stateful computation in a pure interface
21:16:10 <lennart> with no dirty tricks, of course
21:16:14 <lennart> just runST
21:16:59 <dolio> ?instances MonadPlus
21:16:59 <glguy> anyone running NetBSD?
21:17:00 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
21:17:14 <lennart> glguy: I used to
21:17:22 <lennart> but now i have a macbook
21:17:34 <dons> glguy: i've it running on a 68k
21:17:43 <glguy> dons: do you have 6.6 running on it?
21:17:47 <dons> nope
21:17:48 <glguy> or is ghc i386 only
21:17:49 <coffeemug> phew
21:17:53 <dons> glguy: heh. no.
21:18:04 <glguy> 68k is relly old?
21:18:07 <coffeemug> dons: you mentioned the tutorial
21:18:11 <dons> 1992, glguy
21:18:12 <coffeemug> and while ghc was compiling
21:18:15 <coffeemug> I added two more sections
21:18:20 <dons> good!
21:18:32 <coffeemug> on parsing using Parsec, and on lots of features like pattern matching and other stuff
21:18:39 <lennart> a 1992 68k might have trouble with ghc.  hbc should be ok :)
21:18:46 <dons> 33 MHz of vintage 90s processing POWER!
21:18:53 <dons> yeah, getting stage1 built is about 30 hours or so
21:18:53 <coffeemug> just four more sections to go
21:19:04 <dons> hugs runs fine, of course
21:19:05 <coffeemug> I skipped stage1 though :)
21:19:11 <mgoetze> dons: so how much slower is System.Random than binding to the mersenne twister c code?
21:19:25 <coffeemug> if I'm lucky I'll finish the tutorial some time next week
21:19:48 <dons> mgoetze: hmm. don't have numbers, but randoms were taking up some 20% of the running time of my monte carlo simulator, its something like 2% now
21:20:00 <x3m> coffeemug: what tutorial?
21:20:11 <lennart> coffeemug: I just read your LISP interpreter essay.  have you had any feedback on that?
21:20:30 <mgoetze> dons: what kind of stuff were you simulating?
21:20:30 <coffeemug> this is why I was reluctant to give out the URL :)
21:20:36 <dons> lennart: i think he's looking for feedback.
21:20:40 <coffeemug> if you look at the url it starts with "sources"
21:20:43 <dons> mgoetze: polymer chemistry
21:20:53 <dons> so giant vats of molecules swimming around
21:20:54 <coffeemug> it's just a branch of the website
21:21:05 <coffeemug> where I push stuff that I'm writing at the moment
21:21:13 <coffeemug> it's not on the root of defmacro.org
21:21:19 <dons> coffeemug: you want to get lennart's feedback, if he's offering ... ;)
21:21:20 <coffeemug> which means I'm not finished yet
21:21:33 <coffeemug> oh, absolutely, I'm looking for feedback
21:21:49 <x3m> coffeemug: did you build hs-plugins in msys?
21:21:56 <coffeemug> especially since I'm just starting out with haskell and I bet most of my code looks crappy to people who are more experienced
21:22:10 <coffeemug> x3m: you don't need msys to build hs-plugins, it just builds on windows iwth Cabal
21:22:21 <lennart> i wasn't really offering.  just curious
21:22:30 <x3m> coffeemug: yeah sure it does, but it doesnt work
21:22:42 <coffeemug> lennart: didn't get any feedback because I didn't publish it yet (since it's not done)
21:22:48 <lennart> ah
21:22:59 <coffeemug> but if you have any, you're very welcome to it to me
21:23:00 <x3m> coffeemug: or maybe you can tell me how you managed to build in on win with cabal
21:23:02 <coffeemug> here, or via email
21:23:14 <coffeemug> x3m: it builds but doesn't work for you?
21:23:18 <coffeemug> x3m: it worked for me
21:23:36 <coffeemug> it doesn't work with ghci due to a minor bug in Linker.c, hopefully I'll get to fix it soon
21:23:49 <coffeemug> but if you compile your program with ghc, it works
21:23:59 <x3m> coffeemug: well as i said, it didnt for me, could you write down how you did.. how you setup the config file and so on?
21:24:17 <coffeemug> but I didn't do anything special
21:24:24 <coffeemug> just get the latest from darcs
21:24:29 <coffeemug> go into the directory
21:24:31 <coffeemug> and do the usual
21:24:39 <coffeemug> runghc Setup.hs --configure
21:24:41 <x3m> doh, just say no if you dont want to, you obviously didnt do as i did
21:24:44 <coffeemug> runghc Setup.hs build
21:24:54 <coffeemug> runghc Setup.hs install
21:25:01 <coffeemug> that's all I did
21:25:11 <coffeemug> I'm not sure what else to write
21:25:47 <dons> which ghc version? which OS version?
21:25:57 <coffeemug> WinXP, GHC 6.4.2
21:26:17 <x3m> "runghc: cannot find ghc"
21:26:29 <coffeemug> x3m: you need to put ghc on your path
21:26:46 <x3m> how?
21:27:03 <coffeemug> just set it in the PATH environment variable
21:27:09 <x3m> ok
21:27:22 <coffeemug> right click on My Computer, properties, advanced, env-vars
21:27:27 <coffeemug> and add it there
21:27:31 <coffeemug> to the path
21:28:08 <x3m> set path=%path%;c:\ghc\ghc-6.4.2\bin this should work i suppose
21:28:25 <dons> i hope you guys are writing this down for haskell.org/haskellwiki/Windows
21:28:30 <dons> since it comes up waaay too often
21:28:35 <dons> build your community!
21:28:59 <mgoetze> can i put guards inside a where clause?
21:29:30 <dons> yes
21:29:58 <mgoetze> good... but i just decided that pattern matching is a better solution anyway... :)
21:30:03 <dons> main = print x
21:30:03 <dons>     where x | 1 == 1 = True
21:30:06 <dons> for example.
21:31:36 <Cale> x3m: I haven't written any really substantial mathematics libraries
21:31:47 <pzpz> anyone have any favorite tutorial pages?
21:32:10 <vincenz> yaht
21:32:12 <vincenz> @where yaht
21:32:13 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
21:32:22 <vincenz> afaik they've also been wikified
21:32:31 <dons> pzpz: start on http://haskell.org and click the 'Books and tutorials' link :)
21:32:33 <lambdabot> Title: Haskell - HaskellWiki
21:32:55 <pzpz> dons: books cost too much. school already owns me :\
21:33:15 <dons> they're mostly available for free online
21:33:21 <pzpz> trying to implement a program i did in ruby. choking on permutations :p
21:33:35 <dons> Cale: got a 1 line permute function handy?
21:34:51 <glguy> There was a news report that one of the causes of declining gas-mileage in cars was that people were getting fatter
21:35:49 <pzpz> i could do it with two variables. I'm just not sure how to handle non parameter variables.
21:36:04 <Cale> 3 lines, plus another 3 for interleave, including type signatures :)
21:36:14 <pzpz> i want only _one_ parameter :\
21:36:22 <glguy> a 1-liner permutations would be either ugly or inefficient
21:36:30 <mgoetze> perms [] = [[]]; perms (x:xs) = concat (map (inserts x) (perms xs)) where inserts x [] = [[x]], inserts x (y:ys) = (x:y:ys):(map (y:) (inserts x ys))
21:36:36 <mgoetze> ok, it's a long line :)
21:37:28 <slime_mold> btw, why doesn't ghci allow where-clause?
21:37:39 <glguy> it does
21:37:47 <coffeemug> eh, got kicked off
21:37:47 <glguy> slime_mold: let f = a where a = 1 in f
21:37:51 <coffeemug> I'm off to sleep
21:37:53 <coffeemug> x3m: any luck?
21:37:58 <Cale> splits [] = []
21:37:58 <Cale> splits [x] = [([],x,[])]
21:37:58 <Cale> splits (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- splits xs]
21:37:58 <Cale> perms' [] = [[]]
21:37:58 <Cale> perms' xs = xs : [zs ++ vs | (us,v,vs) <- splits xs, ys <- perms' us, zs <- inte rleave v ys]
21:38:13 <Cale> that's, I think, one of the faster ones I've found
21:38:23 <slime_mold> > a where a = 1
21:38:23 <lambdabot>  Parse error
21:38:48 <coffeemug> anyway, I'm out
21:38:50 <Cale> er
21:38:52 <glguy> slime_mold: where is part of a declaration
21:38:53 <Cale> sorry
21:38:57 <slime_mold> but I can do this in Hugs anyway
21:38:59 <Cale> interleave          :: a -> [a] -> [[a]]
21:38:59 <Cale> interleave x []     =  []
21:38:59 <Cale> interleave x (y:ys) =  [x:y:ys] ++ map (y:) (interleave x ys)
21:39:00 <coffeemug> x3m: if you have more questions, email me at coffeemug@gmail.com
21:39:12 <coffeemug> gn
21:39:28 <Cale> It's odd that it has such good performance given the amount of code involved :)
21:39:31 <dons> slime_mold: oh, can't use 'let' in hugs. you'll need to load the declaration from a file, or use ghci
21:39:39 <Cale> I'd expect something close to optimat to be short
21:40:58 <Cale> hmm, mgoetze's version is fairly close
21:41:00 <pzpz> these are pretty intense for my level of experience: p
21:41:03 <pzpz> let me absorb.
21:41:19 <Cale> It would be better to expand that definition out a bit :)
21:41:31 <Cale> perms [] = [[]]
21:41:32 <Cale> perms (x:xs) = concatMap (inserts x) (perms xs)
21:41:32 <Cale>     where inserts x [] = [[x]]
21:41:32 <Cale>           inserts x (y:ys) = (x:y:ys):(map (y:) (inserts x ys))
21:41:36 <pzpz> ghci isn't liking "interleave"
21:41:46 <Cale> I gave a definition there
21:41:53 <dons> you'll want to load these definitions from a file, pzpz
21:41:58 <pzpz> oh, i'm stupid.
21:42:04 <pzpz> i am --
21:42:06 <mgoetze> Cale: yeah i'd write it more like that but he asked for a one-liner ;)
21:42:10 <pzpz> :l <file.
21:42:19 <pzpz> i didn't see the interleave :)
21:43:20 <Cale> the one with interleave is stolen from an old Haskell report
21:43:35 <pzpz> that has to be the ugliest list comprehension i've ever seen.
21:43:47 <mgoetze> mine is totally original work ;)
21:43:51 <Cale> actually, maybe not directly
21:44:04 <Cale> actually, I think this is the one that was in the report:
21:44:08 <Cale> permutations        :: [a] -> [[a]]
21:44:08 <Cale> permutations []     =  [[]]
21:44:08 <Cale> permutations (x:xs) =  [zs | ys <- permutations xs, zs <- interleave x ys ]
21:44:08 <Cale>     where interleave          :: a -> [a] -> [[a]]
21:44:08 <Cale>           interleave x []     =  [[x]]
21:44:09 <Cale>           interleave x (y:ys) =  [x:y:ys] ++ map (y:) (interleave x ys)
21:44:16 <chessguy> spammer!
21:44:19 <x3m> "runghc Setup.lhs --configure" Setup.lhs: No command given (typ --help)
21:44:22 <chessguy> someone nuke him!
21:44:33 <Cale> the splits function seems to help though
21:45:22 <mgoetze> damn, the report stole my implementation
21:45:26 <mgoetze> i'm going to sue them :)
21:45:32 <Cale> also, some of these work with laziness and some don't
21:45:37 <x3m> Cale: i was mostly thinking if you did any small lib for common math stuff like: fac/ghc/lcm/fib/perm.. and so on
21:45:57 <glguy> ?type lcm
21:45:58 <lambdabot> forall a. (Integral a) => a -> a -> a
21:46:11 <Cale> mgoetze: your implementation doesn't work on [1..]
21:46:15 <mgoetze> well at least the interleave function... main body is different
21:46:52 <Cale> x3m: well, those are easy enough to write that I usually just write them wherever they're needed
21:47:03 <x3m> okay
21:47:21 <mgoetze> Cale: why would you want that, though? :)
21:47:43 <x3m> yeah they might not be so hard, i just want to learn abit of optimal/how to write proper haskell code
21:48:02 <Cale> mgoetze: it indicates that it will behave properly on very large input
21:48:29 <Cale> also, that it will run in a small amount of space
21:49:29 <mgoetze> Cale: very large and infinite aren't quite the same :) didn't give much thought to space, though
21:50:27 <x3m> Cale: have you seen this one: http://www.willamette.edu/~fruehr/haskell/evolution.html was pretty fun
21:50:30 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
21:50:48 <int-e> oh yes :)
21:51:12 <chessguy> that page has been around for a while
21:51:58 <x3m> probably
21:56:03 <Cale> x3m: yeah :)
21:56:54 <Cale> mgoetze: well, they aren't, but in practical terms, they're pretty close -- working on the infinite case means that your function doesn't demand too much of its input in order to produce a small amount of its output
21:57:02 <Cale> which is important for performance
22:02:06 <altan> Argh, I'm still stumbling with "=" and "let" in Hugs
22:02:18 <altan> Neither "x = 1" or "let x = 1" works.
22:02:57 <lispy> http://paulgraham.com/langdes.html the point about OO programming, "2. Object-Oriented Programming." is spot on
22:02:59 <lambdabot> Title: Five Questions about Language Design
22:03:10 <Cale> altan: hugs doesn't let you make bindings at the prompt
22:03:22 <Cale> altan: you're expected to save things into a file and load it
22:03:35 <chessguy> unless you do let x = 1 in ...
22:03:40 <Cale> It'll then evaluate expressions for you
22:03:54 <lispy> chessguy: aparantely hugs doesn't support that
22:04:01 <chessguy> oh, really?
22:04:02 <altan> Oh. I don't really understand the point of an interactive interpreter yet then, but I'm sure there's a reason
22:04:17 <Cale> chessguy: no, you're right, I think lispy missed the 'in'
22:04:21 <chessguy> works just fine for me
22:04:25 <Cale> altan: think of it as a debugger
22:04:25 <lispy> ah
22:04:41 <chessguy> i was gonna say, i was pretty sure it did
22:04:45 <lispy> altan: it's for experimenting and prototyping, but it's not for making declarations
22:05:19 <lispy> altan: it is very useful, but it's not as powerful as, say, lisp's interactive system
22:05:37 <altan> I see. I'm used to python/ruby/scheme's interactive modes, that's why. Hudak's Multimedia book doesn't seem to explain much about how to use the code provided
22:07:40 <lispy> altan: it's very helpful if you want to try out some functions
22:07:41 <Cale> There are good reasons for this related to the sorts of things that Haskell lets you do, like make arbitrary mutually recursive definitions
22:07:58 <lispy> altan: findout how they work, how to glue them together and then write that down in your file and reload it :)
22:08:53 <lispy> Cale: well, lisp allows that too, it's just that it complains that some function you mentioned doesn't exist and then doesn't worry about it after that
22:09:09 <altan> Yup, that's what I'll be doing I guess. I'm pretty excited to be learning Haskell, I've toyed with what basic FP ideas Python supports and I want to go further
22:10:49 <lispy> haskell certainly works well for FP
22:12:24 <pzpz> perl6 has some neat functional aspects ^_^
22:12:39 <sjanssen> > isPrefixOf "INTERCAL" "INTERCALATE" -- coincidence? I think not!
22:12:40 <lambdabot>  True
22:13:13 <lispy> what is intercal?
22:13:22 <sjanssen> @google intercal programming language
22:13:26 <lambdabot> http://bears.ece.ucsb.edu/personnel/astornet/humor/humor45.html
22:13:27 <lambdabot> Title: The Intercal Programming Language
22:13:33 <lispy> > "INTERCAL" `isPrefixOf` "INTERCALATE"
22:13:35 <lambdabot>  True
22:13:48 <lispy> humor?
22:13:50 <lispy> uhoh
22:14:06 <int-e> PLEASE REFRAIN FROM COMING FROM
22:14:09 <sjanssen> lispy: one of those evil joke languages
22:14:18 <int-e> darn
22:14:19 <int-e> ABSTAIN
22:14:56 <mgoetze> at least we all hope it's only a joke
22:15:19 <sjanssen> I don't think it is
22:15:26 <sjanssen> or am I outrageously dense?
22:15:31 <int-e> intercal is cute.
22:15:32 <mgoetze> i think the COME FROM idea is really neat, though
22:15:37 <Cale> It's implemented. I think there's even an implementation where you get concurrency by coming from the same place twice :)
22:15:42 <mgoetze> much better than GOTO, anyway
22:15:46 <int-e> Cale: yes :)
22:15:50 <lispy> haha
22:16:15 <Cale> COMEFROM + GOTO = AOP
22:16:32 <int-e> and they added ONCE to get inter-thread communication.
22:17:17 <lispy> PLEASE GIVE UP
22:17:25 <Cale> Malbolge is worse. I'm impressed that someone wrote a Hello World in Malbolge.
22:17:40 <int-e> I'm impressed somebody wrote a cat in Malbolge :)
22:17:44 <lispy> Cale: maybe they tranlated it from a more sane language?
22:17:44 <Cale> hehe
22:18:14 <Cale> lispy: actually, the first halfway-successful hello world was constructed by a genetic algorithm
22:19:05 <Cale> I don't think the problem of translating from a saner language has been solved
22:19:29 <Cale> It's not even 100% clear that the language is Turing complete, but it probably is, in some really obscure way
22:20:42 <pzpz> i am horribly inefficient in haskell atm.
22:22:34 <mgoetze> how do i get nonnested tuples like (a,b,c1), (a,b,c2) instead of ((a,b),c1), ((a,b),c2) if i want to do something like map ((,) (a,b)) [c]?
22:22:36 <Cale> I think it would be funny to design a language where all the operations were pseudorandomized via some Blum-Blum-Shub RNG with a nicely large key.
22:23:09 <Cale> mgoetze: map ((,,) a b)
22:23:20 <mgoetze> ah, merci
22:24:25 <Cale> That would make programming anything in the language as hard as factoring the key :)
22:24:48 <Cale> well, basically :)
22:25:48 <mgoetze> Cale: uh, no that doesn't quite do it
22:25:56 <Cale> hm?
22:26:12 <Cale> > map ((,,) 1 2) [1..10]
22:26:14 <lambdabot>  [(1,2,1),(1,2,2),(1,2,3),(1,2,4),(1,2,5),(1,2,6),(1,2,7),(1,2,8),(1,2,9),(1,...
22:26:52 <sjanssen> @. pl djinn (a, b) -> c -> (a, b, c)
22:26:52 <lambdabot> f = uncurry (,,)
22:27:43 <dons> good bot
22:27:51 <mgoetze> Cale: oh, maybe i oversimplified... let's try (,,,) :)
22:28:16 <sjanssen> @. pl djinn (a, b) -> (c, d) -> (a,b,c,d)
22:28:17 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (,,,))
22:28:30 <sjanssen> @yow!
22:28:31 <lambdabot> YOW!!  What should the entire human race DO??  Consume a fifth of
22:28:31 <lambdabot> CHIVAS REGAL, ski NUDE down MT. EVEREST, and have a wild SEX WEEKEND!
22:28:44 <mgoetze> Cale: that's what i get for being too lazy to state that my problem involved quads, not triplets ;) thanks
22:29:51 <lispy> does the comma thing generalize?
22:30:17 <lispy> > (,,,,,,,,) 1 2 3 4 5 6 7 8 9
22:30:18 <lambdabot>  (1,2,3,4,5,6,7,8,9)
22:30:37 <pzpz> how can i append tuples as an array? ie. tuples a,b = [a,b]
22:30:44 <sjanssen> @. pl djinn (a, b,c) -> (d, e, f) -> (a,b,c,d,e,f)
22:30:45 <lambdabot> (line 1, column 23):
22:30:45 <lambdabot> unexpected "="
22:30:45 <lambdabot> expecting variable, "(", operator or end of input
22:30:53 <sjanssen> pzpz: you can't, generally
22:31:14 <lispy> well, suppose they have the same type :)
22:31:35 <lispy> pzpz: so you want tuple to list?
22:31:51 <pzpz> trying to recursively generate tuples and append them to a list.
22:32:10 <lispy> well....you could have [(a,b)] pretty easily
22:32:34 <lispy> [(1,2), (3,4)]
22:32:36 <lispy> like that
22:32:43 <lispy> but that's probably not what you want?
22:33:36 <lispy> > let tupappend (x,y) xs = x:y:xs  in tupappend (1,2) [3..5]
22:33:37 <lambdabot>  [1,2,3,4,5]
22:33:41 <lispy> there is also that
22:34:42 <pzpz> lispy: well, given something like, foo 5 [2..4], i want ot generate [ (5,2), (5,3), (5,4) ]
22:35:03 <pzpz> don't spoil it for me though, I just need hints :p
22:35:14 <int-e> map
22:35:32 <pzpz> i'm trying map now, .. map (:x) (y:ys), but that borks.
22:36:22 <sjanssen> pzpz: remember that (:) is used to construct lists, you'll need to use (,) to make a tuple
22:36:40 <lispy> pzpz: can you write it without map?
22:36:53 <lispy> pzpz: i mean, could you write this recursively?
22:37:54 <lispy> so for example, suppose you had a list of one element: foo n [x] = ?? what would you put?
22:37:59 <pzpz> lispy: potentially -- each idiom i try though I run into a lack-of-knowledge barrier and I try another idiom :)
22:38:15 <lispy> pzpz: let's do it the simple way first and then rewrite to use map
22:38:15 <pzpz> (n,x) ?
22:38:21 <lispy> close
22:38:30 <lispy> what is the type of foo?
22:39:27 <pzpz> foo :: int [int] -> (int,int)   ?? (havn't really learned how to do this yet... this is bs)
22:39:47 <pzpz> i suppose you could substitute int for a'
22:40:11 <lispy> okay, so foo takes an int, a list of int and returns?
22:40:18 <lispy> (let's forget the notation for now)
22:40:23 <pzpz> tuple
22:40:29 <lispy> just one?
22:40:56 <pzpz> when you define [x], is that a list of one element?
22:41:12 <lispy> in a pattern yse
22:41:14 <pzpz> =   (n, (head x))
22:41:18 <liyang> ( It's a pity you can't write `sections' on tuple constructors, i.e. (n,) :: a -> (N, a), though you can write (,) n :: a -> (N, a) instead. )
22:41:35 <Cale> [x] as a value is a list with one element, as a type, it's the type of lists containing elements of type x
22:41:45 <Cale> for example, [Integer] is the type of lists of integers
22:42:05 <pzpz> Alright.
22:42:06 <sjanssen> liyang: but then we'd want sections on lists.  WILL IT EVER END!?!
22:42:15 <Cale> [1,2,3] :: [Integer]
22:42:43 <pzpz> lispy: i'd assume it'd return an array of tuples then
22:42:47 <liyang> sjanssen: keep the madness comin', I say.
22:43:02 <lispy> pzpz: a list actually not an array
22:43:15 <pzpz> is there a difference in haskell?
22:43:19 <lispy> yes
22:43:29 <Pete_I>  what is it?
22:43:33 <lispy> you won't meet array in haskell for a while
22:43:48 <pzpz> i'll take your word for it.
22:43:50 <pzpz> :)
22:43:56 <liyang> A list in Haskell is more like a linked list in C/Java. Best not to stretch the analogy too far though.
22:44:02 <lispy> pzpz: so in haskell notation we'd say, foo :: Int -> [Int] -> [(Int, Int)]
22:44:34 <lispy> pzpz: that means it takes an int and a list of ints and gives back a list of tuples of ints
22:44:57 <lispy> pzpz: okay, so a little while ago you said foo n [x] = (x, n), do you see the problem now?
22:45:40 <pzpz> foo n [x] = [ (n,x) ] ?
22:45:52 <lispy> very good
22:45:58 <lispy> (looks like i reversed them on accident)
22:46:12 <lispy> pzpz: so now you can solve it for lists of length one
22:46:13 <pzpz> figured.
22:46:32 <lispy> pzpz: so now we can write a pattern like this foo n (x:xs), do you know what that means?
22:46:39 <pzpz> yes
22:47:09 <pzpz> i've had that for a while now -- and on my recursive attempt got stuck at:
22:47:10 <lispy> pzpz: then you know how to take that x and create a list of tuples
22:47:50 <pzpz> mixin x (y:ys) = (x,y):<stuckpoint>
22:48:03 <lispy> ah yeah, you're right there
22:48:07 <pzpz> mixin x (y:ys) = [(x,y)...] doesn't seem right
22:48:11 <lispy> if this were a black hole you'd never make it back out :)
22:48:48 <pzpz> since i'd have [(x,y) [(w,z) [...
22:48:56 <Cale> pzpz: I'm not 100% sure what you're writing, but I'm willing to bet that whatever it is, it'll involve mixin x ys
22:49:19 <pzpz> Cale:  of course, but I'm not sure how to build the array from it
22:49:28 <Cale> what are you trying to do?
22:49:32 <lispy> pzpz: look at it this way, you already have a function which does what you want, you just need to call it :)
22:49:41 <pzpz> i'm stuck at the point of combining the recursive call with the tuple
22:49:46 <liyang> Cale: you've just given the game away, I think. :)
22:49:52 <Cale> pzpz: what does mixin do?
22:50:16 <liyang> applies (,) n to each element of the list. :)
22:50:19 <pzpz> foo 5 [1..4] = [ (5,1), (5,2), (5,3) (5,4) ]
22:50:21 <lispy> Cale: mixin :: Int -> [Int] -> [(Int, Int)]
22:50:23 <Cale> ah, okay
22:50:50 <Cale> so suppose you know what mixin x ys is, how do you get mixin x (y:ys) ?
22:51:06 <dons> on why reddit is better than digg, http://programming.reddit.com/info/nq1k/comments/cnvoi?context=5   :D
22:51:10 <lambdabot> Title: Haskell and Scheme: Which One and Why? (reddit.com), http://tinyurl.com/y73ytn
22:52:25 <pzpz> Cale: not following you
22:52:41 <dons> reddit's got just enough of a smart FP community hanging around it to keep it interesting, and hold back the tide of VB.Net# agile programmers
22:52:45 <lispy> pzpz: okay, lets say you only had the version that works on a list of length 1
22:52:58 <liyang> i.e. suppose you have know foo 5 [2..4] == [ (5,2), (5,3), (5,4) ], how would you get foo 5 [1..4] ?
22:53:03 <Botty> hehe, agile
22:53:25 <lispy> pzpz: and then i handed you foo n [x,y] and asked you how you'd use the foo on lists of length 1 to solve it?
22:53:32 <liyang> Botty: disfunctional, I prefer. ;)
22:53:38 <Cale> hehe, using 'agile' as an insult is awesome
22:53:45 <dons> heh
22:54:33 <dons> I propose we poison the word henceforth, by using it as a secret FP insult. who's with me??
22:55:14 <Botty> actually, I noticed that haskell has made me better at C, not because of the idioms, because getting them to fit would be a hack at best.  It's stretched my syntax bounds such that C is well within them.  Also, since C is so imperfectionistic in comparison, I feel free to hack stuff up imperfectly.  Good for getting stuff done faster.
22:55:25 <Cale> dons: I agree :)
22:55:47 <pzpz> lispy: split up the list into single elements?
22:56:12 <lispy> pzpz: foo n [x] = [(n, x)]; and i gave you foo n [x,y] and asked you to only use foo to solve it
22:56:17 <lispy> pzpz: correct
22:56:24 <lispy> pzpz: and then put the results back together right?
22:56:34 <liyang> pzpz: it involves the : operator. :)
22:57:02 <lispy> pzpz: and to show you how to put lists together let's rewrite that first line
22:57:16 <lispy> foo n [x] = (n, x) : []
22:57:23 <pzpz> (foo x) : (foo y)
22:57:27 <pzpz> not exactly following you --
22:57:28 <lispy> > (1,2) : []
22:57:29 <lambdabot>  [(1,2)]
22:57:33 <lispy> pzpz: oh, you're so close
22:57:37 <Cale> > 1 : [2,3,4,5]
22:57:39 <lambdabot>  [1,2,3,4,5]
22:57:44 <lispy> pzpz: so the thing on the rhs of (:) needs to be a list
22:57:54 <pzpz> understandable
22:58:01 <pzpz> > 1 : []
22:58:03 <lambdabot>  [1]
22:58:17 <lispy> pzpz: but the thing on the lhs cannot be a list (well, you can have a list of lists...but yeah)
22:58:23 <Cale> Every list is either [], or it's x : xs, where xs is a list.
22:58:24 * liyang is waiting until the answer converges to map.(,) ...
22:58:38 <lispy> liyang: what about zip?
22:59:06 <liyang> lispy: it's longer? ^^;
22:59:20 <lispy> pzpz: foo n [x,y] = (n, x) : ??
22:59:29 <pzpz> Cale: it doens't need to be x:xs, does it?
22:59:53 <Cale> pzpz: I mean for some element x and some list xs
23:01:01 <pzpz> > let zam x = map (+1) x in zam [1..4]
23:01:03 <lambdabot>  [2,3,4,5]
23:01:10 <pzpz> yah, i see what you're saying.
23:01:48 <pzpz> (n,x):(foon (y))
23:01:57 <pzpz> bah -- coffee shop is closing :\
23:02:00 <pzpz> gotta mose home
23:02:05 <liyang> pzpz: you got it. :)
23:02:10 <lispy> pzpz: close, foo n [y]
23:02:25 <liyang> oh yeah. ^^
23:02:38 <lispy> pzpz: or, foo n xs = zip (repeat n) xs
23:02:43 <pzpz> i'vmixin x [] = []
23:02:48 <liyang> And you don't need brackets around foo n [y], but it doesn't hurt.
23:02:49 <pzpz> mixin x (y:ys) = (x:y):(mixin [ys])
23:03:06 <pzpz> oops -- left out x
23:03:10 <lispy> ys is already a list so you can drop the brakets now
23:03:22 <lispy> and you meant , instead of one of the :s
23:03:49 <pzpz> that's very true :)
23:03:57 <pzpz> kk -- thanks a bunch. gotta get home.
23:04:04 <lispy> yw
23:04:20 <liyang> :t map . (,)
23:04:34 <liyang> @t map . (,)
23:04:35 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
23:04:39 <lispy> nice
23:04:41 <liyang> @type map . (,)
23:04:43 <lambdabot> forall a a1. a1 -> [a] -> [(a1, a)]
23:04:55 <liyang> <_<
23:05:08 <xerox> > intersperse '1' "000"
23:05:09 <lambdabot>  "01010"
23:06:29 <lispy> > concat $ intersperse "\n" ["blah", "boo", "bar"]
23:06:31 <lambdabot>  "blah\nboo\nbar"
23:06:40 * lispy wishes that was how unlines worked
23:06:53 <lispy> > unlines ["blah", "boo", "bar"]
23:06:54 <lambdabot>  "blah\nboo\nbar\n"
23:07:12 * lispy thinks it would be nice if lines . unlines = id
23:07:24 <lispy> or maybe it's unlines . lines
23:07:37 <liyang> that'd be more like `join' or something, right?
23:07:50 <xerox> @check \xs -> lines . unlines $ xs == xs
23:07:51 <lispy> ?scheck \s -> (lines . unlines) s == s
23:07:52 <lambdabot>  Couldn't match `[String]' against `Bool'
23:07:52 <lambdabot>  add an instance declaration for (Serial Char)
23:07:53 <lambdabot>   In the definition of `qap...
23:08:19 <lispy> ?check \s -> (lines . unlines) s == (s::[String]"
23:08:20 <lambdabot>  Improperly terminated string
23:08:22 <liyang> (`join' of Perl and various other languages.)
23:08:22 <lispy> ?check \s -> (lines . unlines) s == (s::[String])
23:08:26 <lambdabot>  OK, passed 500 tests.
23:08:45 <lispy> ?check \s -> (unlines . lines) s == (s::String)
23:08:46 <lambdabot>  Falsifiable, after 0 tests: "\722817\365918"
23:08:57 <lispy> zero tests?
23:08:59 <lispy> it just knew
23:10:03 <lispy> ?check \s -> (unlines . lines) s == (s::String)
23:10:04 <lambdabot>  Falsifiable, after 2 tests: "\495962"
23:10:22 <Cale> I think the keyword is after
23:10:39 <lispy> > unlines . lines "\495962"
23:10:40 <lambdabot>  Character constant out of range
23:10:46 <Cale> so it passed 0 tests before failing
23:10:52 <lispy> > unlines . lines "495962"
23:10:53 <lambdabot>    Expecting a function type, but found `[String]'
23:10:53 <lambdabot>    Expected type: a -...
23:10:58 <lispy> > unlines . lines $ "495962"
23:11:00 <lambdabot>  "495962\n"
23:13:15 <Pete_I> liftM2 isn't prelude is it?
23:13:25 <lispy> it's Control.Monad
23:13:30 <lispy> ?hoogle liftM3
23:13:31 <lambdabot> Monad.liftM3 :: Monad a => (b -> c -> d -> e) -> a b -> a c -> a d -> a e
23:13:31 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
23:13:43 <Lemmih> @help index
23:13:43 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
23:13:53 <Pete_I> cool
23:14:07 <Cale> Perhaps we should actually have a datatype called BikeShed somewhere in the libraries
23:14:36 <Cale> heh, Data.BikeShed
23:14:43 <liyang> data Zero too, perhaps? =]
23:14:52 <Cale> paint :: Colour -> BikeShed -> BikeShed
23:15:39 <lispy> Cale: i thought that was the cleverness of suggesting BikeShed for the name of Void/Absurd/Zero...all functions which take a BikeShed argument are undefined :)
23:16:08 <lispy> (not that i was that clever, just thought that t's what the person who did suggest it was thinking)
23:17:28 <Cale> too bad that it's not really a zero object
23:17:41 <lispy> so when i was reading PGs article about language design, i realized he made some arguments for erlang without saying it by name
23:17:47 <Cale> actually, that's a good thing :)
23:17:58 <Lemmih> ?check \s -> (s::String) `isPrefixOf` (unlines . lines) s
23:17:59 <lambdabot>  OK, passed 500 tests.
23:18:55 <Pete_I> pointless notation looks like it gets pretty ugly
23:19:44 <lispy> it can
23:20:07 <lispy> but for simple things where there is just one thread of data it's nice
23:20:13 <dons> ?pl \x y -> x + 1
23:20:13 <lambdabot> const . (1 +)
23:20:14 <dons> good
23:20:23 <dons> @pl \ x -> x * x
23:20:23 <lambdabot> join (*)
23:20:25 <dons> also good
23:20:32 <dons> @pl \f g (a,b) -> (f a, g b)
23:20:33 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
23:20:35 <dons> well.
23:20:39 <lispy> hehe
23:20:54 <Pseudonym> The fact is, it's like anything in software.
23:20:58 <dons> @pl \h f g x -> f x `h` g x
23:20:59 <lambdabot> liftM2
23:21:00 <lispy> @pl \f g h (a, b, c) -> (f b, g a, h c)
23:21:00 <Pseudonym> You use the tool for the job.
23:21:01 <lambdabot> (line 1, column 13):
23:21:01 <lambdabot> unexpected ","
23:21:01 <lambdabot> expecting letter or digit, operator or ")"
23:21:01 <lambdabot> ambiguous use of a non associative operator
23:21:01 <dons> good too
23:21:09 <dons> @pl \a (b,c) -> a c b
23:21:09 <Pseudonym> And you maximise maintainability.
23:21:10 <lambdabot> (`ap` snd) . (. fst) . flip
23:21:16 <dons> ab it of a strech, perhaps
23:21:20 <Pseudonym> Sometimes that means point-free, sometimes it doesn't.
23:21:23 <dons> yeah
23:21:37 <dons> @pl \x y -> compare (f x) (f y)
23:21:38 <lambdabot> (. f) . compare . f
23:21:42 <dons> might have someone pondering..
23:22:36 <lispy> why did mine have a parse error?
23:22:39 <lispy> @pl \f g h (a, b, c) -> (f b, g a, h c)
23:22:40 <lambdabot> (line 1, column 13):
23:22:40 <lambdabot> unexpected ","
23:22:40 <lambdabot> expecting letter or digit, operator or ")"
23:22:40 <lambdabot> ambiguous use of a non associative operator
23:23:40 <lispy> @pl \f g h (a, b) -> h (f b, g a)
23:23:42 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .) . flip ((.) . (.))) .) . (.) . flip . ((,) .)
23:24:02 <dons> it uses a custom parser :)
23:24:08 <dons> so TheHunter might have been a bit lazy there
23:24:24 <lispy> ah, TheHunter did that?
23:24:31 <lispy> isn't s/he an old C programmer?
23:24:50 <lispy> iirc, that's where i ran into TheHunter the most
23:25:09 <dons> he is a young Haskell programmer, moved to the midwest last year to do a math degree (from .de)
23:25:21 <dons> not a C programmer that i know of.
23:25:29 <lispy> ah
23:25:53 * lispy has cobwebs in the brain
23:25:58 <sieni> stupid meetings
23:26:39 <lispy> sieni: very
23:27:00 <liyang> @type ***
23:27:01 <lambdabot> parse error on input `***'
23:27:09 <liyang> @type Control.Arrow.***
23:27:11 <lambdabot> parse error on input `Control.Arrow.***'
23:27:15 <lispy> ?type (***)
23:27:17 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:27:26 <liyang> ah, nevermind.
23:27:51 <liyang> @type \ (f :: a -> c) (g :: b -> d) -> f *** g
23:27:53 <lambdabot> forall c d b b'. (b -> c) -> (b' -> d) -> (b, b') -> (c, d)
23:30:54 <lispy> let (*-*) = L.bi.cycle in ["@\\-"] *-* ["-@"]
23:30:57 <lispy> > let (*-*) = L.bi.cycle in ["@\\-"] *-* ["-@"]
23:30:58 <lambdabot>  ["@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\\--@","@\...
23:31:21 <Botty> hehe, bi.cycle
23:31:31 <lispy> yeah, just reading the scroll back
23:31:54 <lispy> > L.bi in bi
23:31:55 <lambdabot>  Parse error
23:32:01 <lispy> > L.bi
23:32:02 <lambdabot>  Add a type signature
23:32:09 <lispy> i wonder what it does
23:32:13 <lispy> > L.bi 1
23:32:14 <lambdabot>  add an instance declaration for (Num [[a]])
23:32:18 <lispy> > L.bi [[1]]
23:32:20 <lambdabot>  Add a type signature
23:32:34 <lispy> > L.bi ([[1]]::[[Int]])
23:32:36 <lambdabot>  <[[Int]] -> [[Int]]>
23:32:56 <lispy> > L.bi ["hi"] ["bye"]
23:32:58 <lambdabot>  ["hibye"]
23:33:17 <lispy> > L.bi ["hi","how are you"] ["bye"]
23:33:19 <lambdabot>  ["hibye","how are youbye"]
23:34:04 <lispy> > L.bi ["hi","how are you"] ["bye", "good day"]
23:34:05 <lambdabot>  ["hibye","how are yougood day"]
23:34:17 <lispy> oh weird
23:34:30 <Botty> oh, so its like concatenate pointwise
23:34:50 <Botty> with some strange stuff, hmm
23:34:51 <lispy> > L.bi ["hi","how are you", "3"] ["bye", "good day"]
23:34:53 <lambdabot>  ["hibye","how are yougood day","3bye"]
23:35:02 <lispy> oh
23:35:04 <Botty> ah, interesting
23:35:07 <lispy> it cycles the second list
23:35:19 <lispy> and appends to the elemest of the first
23:35:40 <Botty> > L.bi ["foo"] ["bar", "ble"]
23:35:42 <lambdabot>  ["foobar"]
23:35:50 <Botty> yep
23:36:11 <lispy> let mybi xs ys = zipWith (++) xs (cycle ys) in mybi ["hi","how are you", "3"] ["bye", "good day"]
23:36:15 <lispy> > let mybi xs ys = zipWith (++) xs (cycle ys) in mybi ["hi","how are you", "3"] ["bye", "good day"]
23:36:16 <lambdabot>  ["hibye","how are yougood day","3bye"]
23:37:07 <lispy> well, that was a fun little puzzle
23:37:11 * lispy wanders off
23:47:01 <roconnor> > [(), () .. ()]
23:47:02 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
23:47:13 <roconnor> > [0,0 .. 0]
23:47:15 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:47:33 <roconnor> that's unexpected
23:47:58 <roconnor> > [0 .. 0]
23:48:00 <lambdabot>  [0]
23:48:09 <roconnor> > [() .. ()]
23:48:11 <lambdabot>  [()]
23:48:24 <roconnor> why is [0,0 .. 0] an infinite list?
23:50:09 <dolio> Well, I think I've completed the solitaire cipher.
23:50:47 <x3m> "Find the sum of all the numbers less than 10^8 that are both palindromic and can be written as the sum of consecutive squares." can this be written easily in haskell somehow?
23:51:34 <dolio> Is that from mathschallenge?
23:51:52 <dons> dolio: want to put your cipher soln on haskell.org?
23:51:58 <dons> http://haskell.org/haskellwiki/Haskell_Quiz
23:52:00 <lambdabot> Title: Haskell Quiz - HaskellWiki
23:52:29 <dolio> Yeah, I'll try. I have no experience editing wikis, though.
23:52:50 <dons> very simple. just wrap the code in <haskell> </haskell> tags
23:53:02 <dons> and create an account, just a name and a passwd is required.
23:53:27 * roconnor wonders what the specification for enumFromThenTo is.
23:54:10 <x3m> dolio: yes it is, i wrote it in c++, i get the wrong answer though, but i get the correct answer for 10^3
23:54:50 <x3m> dolio: does it matter?
23:55:08 <Cale> consecutive in which sense?
23:55:24 <Cale> pairs, or arbitrary runs?
23:55:44 <sieni> like a^2 + (a+1)^2?
23:55:46 <dolio> x3m: What number is it. I may have done it already.
23:55:53 <x3m> dolio: 125
23:56:45 <dolio> Ah, no, I haven't, it seems. Sorry.
23:57:19 <x3m> http://cpp.sourceforge.net/?show=21163 this is my c++ code that i wrote very fast so its probably not optimal
23:57:21 <lambdabot> Title: #C++ Pastebin
23:57:23 <dolio> Doesn't seem like it'd be too bad, though.
23:57:42 <sieni> isn't that like easy as pie? just list the sums of consecutive squares less than 10^8 and filter the list by palindromicity and sum the result
23:57:58 <xerox> dons: tomorrow I'll be visiting Google London, I'll tell you if they have a screen like the one in CA ;)
23:58:46 <dons> hey, nice. looking for a job?
23:58:47 <int-e> roconnor: http://haskell.org/onlinereport/basic.html#enum-class
23:58:50 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes, http://tinyurl.com/y3259c
23:59:10 <sieni> ahh not just two squares
23:59:25 <Cale> still not so bad
23:59:36 <kzm> > [ x^2 + (x+1)^2 | x <- [0..20]]
23:59:37 <xerox> dons: "SoC students from all the world, come here!" where here = lots of spots around the earth
23:59:38 <lambdabot>  [1,5,13,25,41,61,85,113,145,181,221,265,313,365,421,481,545,613,685,761,841]
23:59:46 <kzm> filter isPalindromic?
23:59:49 <dons> xerox: ah right.
