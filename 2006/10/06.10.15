00:01:31 <Botty> uhhh, how do I implement the +/-/* operators if I can't implement fromInteger/fromInt? I guess this is why everyone uses functions or funny ^+^ ops for their vectors
00:02:13 <Botty> I guess I'll just make those arbitrary functions never to really be used
00:02:25 <Botty> seems wrong though
00:08:24 <Cale> well, you can't reuse the names + and * because those are for Num
00:09:06 <Cale> so mostly people implementing such classes name their operations differently (since you generally don't want to import the prelude hiding those :)
00:09:26 <Botty> Has anyone every considered a polymorphic system in which the parameter contracts (like "This only accepts Num") are simply operations required to exist for that type.  This could be inferred from the usage of the type, or rather clumsily explicitly declared.  I suppose common groups of operations could be formed to make this more elegant
00:09:35 <Botty> heh, yeah
00:09:37 <Cale> The situation would be different if Num was further broken up
00:10:03 <Cale> Then you could have +, but not *
00:10:21 <Botty> yeah. classes like "Multiplicable", heh
00:10:25 <Cale> (well, unless * was made more general, which might not be a good thing)
00:10:56 <Botty> I think its cool to stick +, -, and * together, but slapping on fromInteger is not cool
00:11:08 <Cale> Well, it makes sense
00:11:29 <Botty> I suppose most number systems have a direct conversion from integer, but still
00:11:31 <Cale> every ring R has a natural homomorphism Z -> R
00:11:44 <Cale> and fromInteger is supposed to be that one :)
00:12:10 <Botty> well, fromInt is worse then
00:12:11 <Cale> It just avoids having 'zero' and 'one'
00:12:16 <Cale> fromInt is silly, yeah
00:12:23 <Cale> and it doesn't exist
00:12:29 <dibblego> why is fromInt silly?
00:12:50 <Cale> because Int is really the integers modulo 2^n for some n
00:12:52 <Botty> dibblego: need look no farther than the ring stuff cale mentioned
00:13:01 <dibblego> Botty, care to paste a back log?
00:13:25 <Cale> <Botty> I think its cool to stick +, -, and * together, but slapping on fromInteger is not cool
00:13:25 <Cale> <Cale> Well, it makes sense
00:13:25 <Cale> <Botty> I suppose most number systems have a direct conversion from integer, but still
00:13:25 <Cale> <Cale> every ring R has a natural homomorphism Z -> R
00:13:25 <Cale> <Cale> and fromInteger is supposed to be that one :)
00:13:29 <Botty> 'every ring R has a natural homomorphism Z -> R' - sorry, didn't see that you'd just came in
00:14:20 <dibblego> fromInt is from Enum right?
00:14:23 <Botty> fromInt does exist, unless you mean existance in some other meaning
00:14:24 <Cale> Instead of fromInteger we could have opted to just have zero, one :: (Num a) => a
00:14:39 <Botty> oh, well that would have been nice
00:14:45 <Cale> Botty: hm? Not in the Prelude
00:14:53 <Cale> @type fromInt
00:14:55 <lambdabot> Not in scope: `fromInt'
00:15:01 <Botty> http://www.cse.unsw.edu.au/~dons/data/Prelude.html
00:15:02 <Cale> @hoogle fromInt
00:15:03 <lambdabot> Title: Haskell 98 Prelude, http://tinyurl.com/qqdjb
00:15:03 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
00:15:03 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
00:15:06 <Botty> it is in this one
00:15:21 <Botty> maybe I should stop using this pretty-printed hugs prelude
00:15:32 <Cale> Oh, that's the Hugs prelude from 1999
00:15:42 <Cale> fromInt used to exist :)
00:16:01 <Botty> oh, well good to see that they fix their mistakes round here
00:16:16 <Cale> we also make new ones
00:16:29 <Cale> Haskell 1.4 was saner than Haskell 98 in a lot of ways
00:18:00 <Cale> and that Hugs prelude from 1999 isn't quite Haskell 98, but I don't think it corresponds to any particular standard
00:18:31 <Botty> yeah, i noticed some hugs specific stuff near the end
00:20:55 <Cale> http://haskell.org/onlinereport/standard-prelude.html
00:20:57 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y2wv6o
00:21:03 <Cale> someone really should colour it :)
00:22:06 <Botty> yeah, its the only reason I bookmarked the other one instead
02:00:17 <lisppaste2> wabbit pasted "amixer output" at http://paste.lisp.org/display/27990
02:26:46 <jmmv> hi
02:33:58 <roconnor> hi
02:44:49 <roconnor> what's the easiest way to perform rot13 on text
02:59:06 <ThreeQ> > map (chr . (+ ord 'a') . (`mod` 26) . (+13) . subtract (ord 'a') . ord . toLower) "test message blah blah"
02:59:07 <lambdabot>  "grfgazrffntraoynuaoynu"
03:00:37 <roconnor> map (chr . (+ ord 'a') . (`mod` 26) . (+13) . subtract (ord 'a') . ord . toLower) "grfgazrffntraoynuaoynu"
03:00:40 <roconnor> > map (chr . (+ ord 'a') . (`mod` 26) . (+13) . subtract (ord 'a') . ord . toLower) "grfgazrffntraoynuaoynu"
03:00:41 <lambdabot>  "testnmessagenblahnblah"
03:01:02 <ThreeQ> sorta works...
03:01:07 <roconnor> :)
03:03:07 <jrmole> i know this comes up periodcially, but is there a good way to get errors like "(Array.!): undefined array element" to give a line number?
03:03:50 <fasta> jrmole: yes, by using macros is a way. Darcs uses this for fromJust, IIRC.
03:08:04 <ThreeQ> let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c alphabet)
03:08:30 <ThreeQ> > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c alphabet) "test message blah blah"
03:08:32 <lambdabot>  "grfg zrffntr oynu oynu"
03:08:45 <ThreeQ> > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c alphabet) "grfg zrffntr oynu oynu"
03:08:47 <lambdabot>  "test message blah blah"
03:09:22 <sieni> > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in "furrfu"
03:09:23 <lambdabot>  Parse error
03:09:27 <sieni> oops
03:09:38 <sieni> > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c alphabet) "furrfu"
03:09:40 <lambdabot>  "sheesh"
03:24:39 <roconnor> now uppercase too
03:25:54 <roconnor> @hoogle interleave
03:25:54 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
03:25:55 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
03:26:08 <roconnor> @hoogle [a] -> [a] -> [a]
03:26:09 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
03:26:09 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
03:26:09 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
03:27:01 <roconnor> let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c (alphabet ++ (map toUpper alphabet)) "Furrfu"
03:27:04 <roconnor> > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c (alphabet ++ (map toUpper alphabet)) "Furrfu"
03:27:05 <lambdabot>  Parse error
03:27:15 <roconnor> > let alphabet = zip ['a'..'z'] (drop 13 $ cycle ['a'..'z']) in map (\c -> fromMaybe c $ lookup c (alphabet ++ (map toUpper alphabet))) "Furrfu"
03:27:16 <lambdabot>  Couldn't match `(Char, Char)' against `Char'
03:27:50 <roconnor> @hoogle a -> b -> (a,a) -> (b,b)
03:27:51 <lambdabot> No matches, try a more general search
03:30:15 <Syzygy-> @hoogle (a -> b) -> (a,a) -> (b,b)
03:30:16 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:32:35 <roconnor> > let a = concat $ transpose [['a'..'z'],['A'..'Z']] in let b = zip a (drop 26 $ cycle a) in map (\c -> fromMaybe c $ lookup c b) "Furrfu"
03:32:36 <lambdabot>  "Sheesh"
03:33:07 <roconnor> too long
03:33:52 <roconnor> @type maybe
03:33:53 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:33:57 <roconnor> @type fromMaybe
03:33:59 <lambdabot> forall a. a -> Maybe a -> a
03:39:09 <roconnor> apparently the easiest thing to do is goto rot13.com
03:39:12 <roconnor> er
03:39:14 <roconnor> go to
03:39:17 <roconnor> heh
03:39:35 <roconnor> too much QVICK basic programming.
03:42:19 <roconnor> > map (\c -> fromMaybe c $ lookup c (concat [[(a,b),(b,a)] | [a,b]<-transpose [['a'..'z'],['A'..'Z']]]) "Furrfu"
03:42:19 <lambdabot>  Parse error
03:42:27 <roconnor> > map (\c -> fromMaybe c $ lookup c (concat [[(a,b),(b,a)] | [a,b]<-transpose [['a'..'z'],['A'..'Z']]])) "Furrfu"
03:42:29 <lambdabot>  "fURRFU"
03:42:37 <roconnor> oops
03:42:44 <roconnor> right, the rot13
04:24:41 <halcyon> hi
04:24:49 <roconnor> hi
04:25:37 <halcyon> i'm having problems with the numerical types in Haskell. How can i typecast from an Int to a Double ?
04:26:05 <Lemmih> > fromIntegral (10::Int) :: Double
04:26:06 <lambdabot>  10.0
04:26:31 <halcyon> ah, thanks, i only tried fromInteger
04:54:17 <ACSpike> what does => mean in types? is it defining the type a name that follows?
04:55:05 <musasabi> class context
04:55:11 <musasabi> context => type
04:55:46 <ACSpike> ok, I think that is what I wanted to say, but lacked the words :-)
04:56:16 <musasabi> e.g. "Show a => a -> String": forall types A such that A is an instance of Show a function from A to String.
04:58:39 <ACSpike> what about this one "const :: const :: a -> b -> a"
04:59:32 <musasabi> that looks invalid (double "::") ?
05:00:25 <musasabi> "const :: a -> b -> a; const x y = x"
05:00:51 <ACSpike> ok, I reading the prelude tour
05:06:33 <Bobstopper> That's bizarre... though I've never before heard of the Sapir-Whorf hypothesis, I heard it twice in the last hour from two completely unrelated sources
05:06:44 <Bobstopper> it must be taking over the world
05:09:52 <dcoutts> dons, very interesting summary. thanks.
06:08:28 <lennart> You can do that too, but not with that syntax
06:08:28 <lambdabot> lennart: You have 1 new message. '/msg lambdabot @messages' to read it.
06:09:01 <lennart> ooops, never mind my message. :)
06:18:35 <spiffy> I think i just had my "Monad Ahah!" moment
06:21:33 <ndm> i had mine yesterday
06:21:33 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:26:51 <bartw> what did you read to get that moment ?
06:27:14 <Syzygy-> spiffy: Coool.
06:28:59 <spiffy> bartw: Nothing really. I just found a situation where it made sense to use a monad.
06:37:00 <mnvl> a haskell tutorial for someone who can program a lot of other languages, and wants to start progrmming, rather than reading, straight away??
06:37:57 <bartw> haskell for c programmers
06:38:01 <bartw> i liked it
06:38:54 <mnvl> if you liked it, it must be good
06:39:00 <ValarQ> i believe the "Hitchhikers Guide to Haskell" is what you look for
06:39:09 <mnvl> thx, this looks like what i'm looking for bartw
06:39:48 <Etni3s> <- needs help with io stuff..
06:39:51 <Etni3s> *** Term : mkDefaultEnv
06:39:51 <Etni3s> *** Type : (a,[b])
06:39:51 <Etni3s> *** Does not match : IO Environment
06:39:51 <Etni3s> --
06:39:51 <Etni3s> mkDefaultEnv :: IO Environment
06:39:52 <Etni3s> mkDefaultEnv = (examplePath,[])
06:39:54 <Etni3s> --
06:39:56 <Etni3s> type Environment = (String, [Item])
06:40:12 <bartw> try the pastebin
06:40:18 <Etni3s> sorry
06:40:24 <ValarQ> @paste
06:40:24 <lambdabot> http://paste.lisp.org/new/haskell
06:40:51 <lisppaste2> Etni3s pasted "io error" at http://paste.lisp.org/display/28000
06:40:52 <arjanb> it shoud be:  mkDefaultEnv = return (examplePath,[])
06:41:01 <Etni3s> oh ok
06:41:46 <Etni3s> thanks
06:47:29 <Lemmih> Etni3s: Why do you want mkDefaultEnv to be an IO action?
06:48:34 <Etni3s> the way i designed the function that calls mkDefaultEnv requires it to be an IO action
06:48:57 <Etni3s> of course, nothing is set in stone
07:23:27 <glguy> slow morning, eh?
07:24:47 <wilx> 1624
07:31:53 <greenrd> I think I've found a strange bug in ghc 6.6
07:33:29 <Lemmih> yes?
07:33:33 <greenrd> It is importing the prelude even though I've told it not to (with -fno-implicit-prelude)
07:34:51 <greenrd> but this only happens in certain cases
07:35:31 <ndm> it might be rebindable syntax that is importing the prelude, i.e. for the desugaring
07:35:40 <greenrd> Well, here's the thing.
07:36:02 <greenrd> I have a simple test case, and with --make the test case doesn't exhibit the bug, but without --make, it does.
07:36:17 <greenrd> And the test case doesn't import anything.
07:39:22 <roconnor> show (Lambda s e) = "-"++s++"]"++(show e)
07:39:57 <roconnor> show (App e1 e2) = "["++(show e2)++"<"++(show e1)
07:40:13 <roconnor> show (Var s) = show s
07:40:19 <glguy> ?type shows
07:40:21 <roconnor> er
07:40:21 <lambdabot> forall a. (Show a) => a -> ShowS
07:40:24 <roconnor> show (Var s) = s
07:41:04 <glguy> roconnor: show (Lambda s e) = '-' : shows s (']' : show e)
07:41:23 <roconnor> ah better
07:41:40 <roconnor> but then I ought to define shows instead
07:41:42 <int-e> showsPrec _ (Lambda s e) = ('-' :) . shows s . (']' :) . shows e
07:42:06 <roconnor> I want to try out this new notation for the lambda calculus
07:42:25 <roconnor> I need lambda terms
07:42:57 <int-e> errrrr.
07:43:18 <int-e> Not shows s - showString s (or just (s ++))
07:43:36 <int-e> > (shows "" "", showString "" "")
07:43:37 <lambdabot>  ("\"\"","")
07:43:52 <Lemmih> xerox!
07:43:54 <xerox> roconnor: what is this new syntax for LC?
07:43:58 <xerox> Howdy Lemmih.
07:44:21 <roconnor> @paste
07:44:21 <lambdabot> http://paste.lisp.org/new/haskell
07:45:04 <greenrd> Now this is really weird
07:45:09 <lisppaste2> roconnor pasted "Slow show for lamba calculus" at http://paste.lisp.org/display/28009
07:45:17 <int-e> hmm [-s]["s"<"s"<"x"
07:45:36 <greenrd> I can reproduce the bug by generating a preprocessed file with ghc -cpp -E, and then compiling the generated .hspp file
07:45:49 <greenrd> But if I rename the .hspp file to a .hs file, the bug goes away!
07:46:02 <roconnor> greenrd: I'm supposed to ping you.
07:46:09 <int-e> or [-s][s<s<x then ... is that readable?
07:46:10 <ndm> @seen pejo
07:46:11 <lambdabot> pejo is in #haskell. I last heard pejo speak 16h 18m 55s ago.
07:46:30 <greenrd> roconnor: Oh? What about?
07:47:24 <ndm> @tell pejo I invented my own algorithm from scratch, that can even deforest Bool's, just doing the easiest thing in my intermediate language
07:47:25 <lambdabot> Consider it noted.
07:48:35 <roconnor> int-e: that isn't my intended syntax, prehaps I got my show wrong.
07:49:00 <roconnor> int-e: what lambda expression were you trying?
07:49:27 <int-e> (\s -> s s) x
07:49:48 <roconnor> that would be [x<-s][s<s
07:49:54 <roconnor> I thikn
07:49:57 <roconnor> thikn
07:50:16 <roconnor> grr
07:50:19 <roconnor> t h i n k
07:50:23 <roconnor> stupid fingers
07:50:47 <roconnor> application is postfix
07:51:16 <int-e> ah.
07:51:44 <roconnor> I was inspired by automath's postfix application.
07:52:22 <roconnor> I thought one might be able to get some clever mixing of lambdas and applications.
07:54:30 <jmmv> humm... I see that yhc's faq says that it should be compilable with a c compiler alone, but I just tried to build it and it uses ghc along the process...
07:55:40 <ndm> jmmv: yes, it does currently, but once its bootstrapping (not yet), it will be able to use only a C compiler
07:55:41 <fasta> jmmv: so?
07:55:56 <jmmv> ah, ok
07:56:02 * ndm goes and updates the FAQ
07:58:30 <glguy> heh, when I go on google and search for: yhc haskell compiler, google asks, "Did you mean GHC Haskell compiler?"
07:59:23 <fasta> glguy: When I do that it doesn't happen.
07:59:45 <glguy> search for exactly this:
07:59:46 <glguy> yhc haskell compiler
07:59:48 <ndm> i get that "correction"
08:00:00 <ndm> i guess GHC is too popular, for the moment...
08:00:05 <fasta> I don't get that correction.
08:00:14 <glguy> fasta: are you using the .com?
08:00:20 <glguy> or are you a different .tld?
08:00:37 <fasta> glguy: it gets automatically referred to .nl.
08:00:53 <glguy> ah, I bet that has something to do with it...
08:00:55 <fasta> I know I can bypass it.
08:01:14 <fasta> "Oh, we need to bypass the security grid".
08:01:22 <jmmv> ndm: also, something that the faq does not answer (nor the web, afaict)... what is yhc's goal?  (when compared to ghc)
08:01:47 <jmmv> well... with goal I mean how does/will differ form ghc
08:01:57 <ndm> jmmv: portable, fast to compile, integrated debugging (hat) support
08:02:20 <ndm> jmmv: i am also working on an optimiser for it, which has the goal of faster at runtime, but thats less part of the Yhc project
08:03:50 <jmmv> great
08:04:03 <ndm> hopefully there is something in that list to interest everyone :)
08:04:05 <fasta> ndm: also extensions, btw?
08:04:12 <ndm> fasta: patches welcome :)
08:04:21 <jmmv> sure... specially the first two items for me
08:04:25 <ndm> fasta: not an explicit goal, but something that would be nice
08:04:34 <jmmv> building ghc under netbsd is a pita and an extremely long process
08:05:09 <ndm> yep, we have Yhc builds fired off for every darcs push, i think the build time is about 20 mins at the most
08:05:27 <ndm> will be dropped massively once Yhc can compile Yhc, since most of that time is running GHC
08:08:08 <jmmv> does that time include building the libraries?
08:09:27 <ndm> yep, but we don't build full haskell.org libraries, so not a fair comparison
08:09:53 <jmmv> heh
08:10:51 <jmmv> oh, btw... something unrelated: the faq says "if you use sensible libraries... build filepaths by ++"; which library are you referring to?  because that's what I'm doing exactly right now in a project...
08:10:54 <dmhouse> Afternoon everone.
08:11:09 <dmhouse> ?where FilePath
08:11:10 <lambdabot> http://darcs.haskell.org/~lemmih/FilePath
08:11:19 <dmhouse> jmmv: don't build filepaths using ++.
08:11:29 <dmhouse> ndm: is that the correct FilePath URL?
08:11:31 <ndm> jmmv: takes 30 seconds to build 53 libraries at the moment
08:11:35 <ndm> dmhouse: no, thats the old one
08:11:56 <ndm> jmmv: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php - use that library instead
08:11:59 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/hagza
08:12:37 <jmmv> excellent, bsd3 licensed :)
08:12:47 <dmhouse> ?where+ FilePath http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
08:12:47 <lambdabot> Done.
08:12:52 <dmhouse> ?where FilePath
08:12:52 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
08:13:22 <ndm> jmmv: where does it say that?
08:13:35 <ndm> oh, at the top, i remember :)
08:14:07 <lennart> roconnor: are you there?
08:17:25 <jmmv> ndm: so for simplicity, I'm supposed to bundle that in my application, right?
08:18:02 <ndm> jmmv: for now, probably easiest yes, but i am intending to get it into base, so eventually you'll just do import System.FilePath, no need to ship an extra module
08:19:43 <jmmv> ndm: the thing is that I'd started my own FilePath module tailored to my simple program... but heck, this one is much better ;-)
08:19:58 <ndm> jmmv: thank you :)
08:23:49 <roconnor> lennart: here
08:24:37 <lennart> roconnor: when you say that djinn fails on your example, do you mean that it fails to find something of the type you want?
08:25:07 <roconnor> lennart: no, I mean it crashes when it tries to take the head of an empty list
08:25:31 <roconnor> (there is no inhabitant of the type I want)
08:25:51 <lennart> oh?  when I ran it, it just said that the function could not be realized.
08:25:52 <jmmv> ndm: just curious, don't you have unit tests for that?
08:25:59 <roconnor> oh
08:26:05 <roconnor> not what I get with lambdba
08:26:08 <roconnor> lambdabot
08:26:12 <ndm> jmmv: FilePath?
08:26:16 <lennart> maybe it's an older version
08:26:16 <jmmv> yep
08:26:27 <roconnor> @djinn --version
08:26:27 <lambdabot> Cannot parse command
08:26:30 <roconnor> heh
08:26:33 <roconnor> okay
08:27:00 <ndm> jmmv: http://www-users.cs.york.ac.uk/~ndm/projects/filepath/System-FilePath.html - see the haddock, all the code bits at the bottom are unit tests
08:27:02 <lambdabot> http://tinyurl.com/y2nu44
08:27:30 <roconnor> is dons in charge of lambdabot?
08:27:44 <ndm> roconnor: yes
08:27:53 <jmmv> ops, thought they were examples at first sight ;)
08:28:16 <roconnor> @tell dons that @djinn is out of date and crashes on some questions.
08:28:17 <lambdabot> Consider it noted.
08:28:58 <ndm> jmmv: they are both, examples and quickcheck properties, in the source code, extracted and tested
08:30:11 <dmhouse> roconnor: which ones?
08:38:19 <araujo> morning!
08:49:26 <hygge> hello
08:50:52 <hygge> im working with a small function, "replace". i would like it to replace a string within my string with something else, like replace "go" "bu" "hugo" -> "hubu". any ideas how to do this? i managed to write it to just replace a char using map...
08:52:07 <Lemmih> hygge: You could use 'isPrefixOf'
08:52:22 <vegai> http://geekz.co.uk/schneierfacts/
08:52:27 <lambdabot> Title: Everybody Loves Eric Raymond - Bruce Schneier Facts
08:53:10 <hygge> Lemmih: hmm, and check it with recursion?
08:55:29 <Lemmih> hygge: Yeah.
08:59:20 <jmmv> ndm, hmm, you say that filepath is "pure haskell 98", but hugs +98 (the default) will not load it... it fails in one of the base libraries, but anyway
09:00:53 <ndm> jmmv: thats just Hugs being silly, Control.Monad has funny not Haskell 98 features in it (which filepath doesn't use), so despite it being a haskell 98 compatibel module, you need to specify -98 just to get normal modules loading
09:01:21 <jmmv> ew
09:01:32 <ndm> jmmv: GHC has a concept of each file being H98 or not, hence FilePath is H98 just Control.Monad isn't in Hugs copy, although it can be (and will be in Yhc's distro)
09:03:32 <Igloo> What uses the extensions in Control.Monad?
09:05:06 <mnvl> is there a way to compile haskell into C code which will compile w/o any library dependencies other than standard libc??
09:05:09 <ndm> Igloo: that was my guess, its one of the modules FilePath imports and that looks like the evil one
09:05:31 <ndm> mnvl: i have one, but its not ready for release yet - I think GHC might be persuaded with some flags
09:05:51 <jmmv> ERROR "/home/jmmv/local/lib/hugs/packages/base/Text/ParserCombinators/ReadP.hs":156 - Syntax error in type expression (unexpected `.')
09:05:54 <jmmv> it ends up like this
09:05:55 <mnvl> hmm
09:06:14 <Igloo> GHC won't give you portable C, if that's what you want
09:06:18 <jmmv> newtype ReadP a = R (forall b . (a -> P b) -> P b)
09:06:22 <jmmv> and that line says that
09:06:35 <mauke> maybe it doesn't grok forall
09:06:43 <Igloo> jmmv: Use -98
09:06:46 <ndm> jmmv: ah, yes, its the forall it can't cope with, just add -98
09:10:57 <jmmv> System.FilePath> joinPath ["foo/", "bar", "/baz" ]
09:10:57 <jmmv> "foo/bar//baz"
09:11:05 <jmmv> ndm: is that extra / in the result intended?
09:13:58 <ndm> jmmv: just thinking, no, its not
09:14:32 <jmmv> my custom joinPaths had the same problem ;)
09:14:41 <ndm> mine shouldn't...
09:15:44 <ndm> jmmv: its an assumption of mine that /baz is not passed to joinPath
09:16:10 <ndm> jmmv: since /baz is an absolute path, rooted, and shouldn't be used in a combination list
09:16:41 <ndm> i.e. joinPath ["foo/","bar","c:\file"] doesn't make sense
09:16:57 <jmmv> aha, true
09:16:58 <ndm> jmmv: what are you trying to acheieve?
09:17:27 <ndm> i should document that though
09:17:34 <roconnor> dmhouse: ((((a -> b,b -> a) -> c,c -> (a -> b,b -> a)) -> (a -> (b -> c,c -> b),(b -> c,c -> b) -> a),(a -> (b -> c,c -> b),(b -> c,c -> b) -> a) -> ((a -> b,b -> a) -> c,c -> (a -> b,b -> a))))
09:17:48 <jmmv> hmm let me think where I saw that specific use case
09:19:09 <jmmv> ndm: ah, yes.  I have a list of (dir, mountpoint) elements, but mountpoint is "relative" to a sandbox (absolute once you've chrooted)
09:19:16 <Una^> How come fromInt is missing in my version of hugs, but works on my uni's version?, do I need to import something?
09:19:38 <mauke> @index fromInt
09:19:38 <lambdabot> bzzt
09:19:38 <ndm> Una^: fromInt is really really old, use fromInteger toInteger functions, and tell your Uni to upgrade!
09:19:52 <jmmv> ndm: so if the user specifies ("/usr/bin", "/bin") and a root of /tmp/root, the program will end up joining /tmp/root and /bin to determine what the real mount point is
09:19:54 <Una^> ndm: ok will do thanks :)
09:20:59 <hygge> whats the name of that function again that does: f 3 "hejhojboj" = ["hej","hoj","boj"] ?
09:21:11 <Igloo> Una^: Use fromIntegral
09:21:29 <roconnor> hygge: I'm not sure it exists.
09:21:43 <hygge> ah :/
09:21:53 <ndm> jmmv: root_path </> tail (splitDirectories snd_item)
09:22:08 <ndm> hygge: use splitAt, and its a simple recursive definition
09:22:37 <Una^> Igloo: thanks that works.
09:23:05 <hygge> hm, ndm, splitAt gives me a tuple?
09:23:38 <ndm> hygge: yep, the first half of which is one answer, the second half goes through to the recursive case
09:24:51 <hygge> hmm
09:26:17 <jmmv> ndm: so could the joinPath method catch these incorrections and raise errors?  it's too easy to make a mistake even with proper documentation, and it won't surface unless you try the app in windows
09:26:47 <ndm> jmmv: yes, its certainly not "the right thing" that it does now, i've emailed myself a note to "fix" it tomorrow in some way
09:27:01 <jmmv> cool :)
09:27:13 <ndm> jmmv: its very complex writing a FilePath module, loads of bizare corner cases and weird invariants!
09:27:36 <roconnor> @seen zervok
09:27:37 <lambdabot> I haven't seen zervok.
09:27:42 <roconnor> @seen zarvok
09:27:42 <lambdabot> zarvok is in #haskell. I don't know when zarvok last spoke.
09:27:53 <jmmv> ndm: maybe Boost.Filesystem could give you some more test cases
09:28:03 <roconnor> @localtime zarvok
09:28:05 <lambdabot> Local time for zarvok is Sun Oct 15 12:27:30 2006
09:28:07 <ndm> jmmv: good point, will take a look
09:32:35 <astrolabe>  Is there an easy way to force ghc to recompile all my code?
09:32:48 <dcoutts> rm *.o
09:32:50 <dcoutts> :-)
09:32:59 <int-e> -no-recomp
09:33:11 <rahikkala> touch *hs
09:33:12 <astrolabe> dcoutts :p
09:33:17 <astrolabe> int-e thanks
09:33:24 <int-e> (which turns off the recompilation check ... the option name is highly unintuitive)
09:33:39 <Igloo> It's -fforce-recomp now
09:33:46 <roconnor> thank god
09:33:47 <dons> good morning
09:33:47 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:33:47 <int-e> oh, good.
09:34:10 <glguy> dons: do you know how to tell ports(7) that ghc is installed without installing the version in ports?
09:34:33 <dons> hmm. yeah, remove the GHC dep from whatever port you're trying to build
09:34:44 <dons> i.e. edit the Makefile and remove the MOD_GHC line (or whatever it is)
09:34:50 <dons> then whatever's in the env will be picked up
09:35:13 <glguy> There isn't a way to make a faked install?
09:35:32 <dons> i can't think of one, but you could do it. the ports tree is pretty flexible
09:35:53 <glguy> maybe I'm thinking of Gentoo
09:39:17 <dcoutts> glguy, there's a way to 'inject' a dep in gentoo, yes
09:50:31 <emk> @hoogle openFile
09:50:32 <lambdabot> IO.openFile :: FilePath -> IOMode -> IO Handle
09:54:26 <sris> why isnt lazy evalution available in all languages ;)
09:56:04 <araujo> Because not all languages are purely functional :-)
09:56:28 <SamB> well, first you need something like a closure
09:57:13 <SamB> and then you need confidence that your variables aren't going to all have totally different values when your closure is lazilly evaluated...
09:57:56 <dcoutts> many languages don't care about that
09:58:12 <dcoutts> they can emulate lazy evluation and just let variable change
09:58:17 <SamB> well, yes
09:58:28 * roconnor wonders what the highest scores on the balance puzzles are
09:58:33 <SamB> I was talking about lazy evaluation that you might possibly be able to *use*
09:58:40 <dcoutts> eg in java you do it with cluky anonymous classes
09:58:45 <SamB> for instance, you could use lambdas in Python...
09:58:51 <Maddas> SamB: What do you mean with that? Side-effects which are visible in closures isn't special to lazy evaluation, is it...
09:58:54 <dcoutts> but my point is, people do do this and just let stuff change
09:59:00 <int-e> roconnor: balance didn't give better scores to shorter solutions
09:59:12 <Igloo> roconnor: Individually, you mean?
09:59:20 <dcoutts> all these complex java methods, callbacks, observers etc are often doing demand driven stuff
09:59:24 <dcoutts> with mutable everything
09:59:26 <SamB> but never do it from a for loop, unless you want to pass in the loop variable as a defaulted keyword arg...
09:59:39 <roconnor> int-e: I believe balance gives more points for shorter solutions
09:59:43 <roconnor> it's been doing that for me
09:59:50 <roconnor> Igloo: yes individually
09:59:51 <sieni> and then there are languages like ml, where you have to specify that something is a reference if you want it to be mutable
09:59:54 <int-e> really?
09:59:55 <int-e> hmm.
10:00:04 <roconnor> Puzzle: swapmem
10:00:07 <Maddas> sieni: Not really, data structures are also mutable.
10:00:09 <roconnor> Certification point value: 10 - 40
10:00:13 <roconnor> I have a 36 point solution.
10:00:21 <Maddas> (Or maybe you didn't refer to the same thing as I thought with your lats "it"
10:00:22 <Maddas> )
10:00:23 <SamB> so basically anything which even pretends to have closures can be used for clunky lazy evaluation...
10:00:24 <roconnor> the highest scores may not be obtainable.
10:00:27 <int-e> I'm mixing up problems. balance is that weird 4 + 2 register machine, right?
10:00:28 <araujo> dcoutts, isn't that too error prone?
10:00:39 <Igloo> There's at least one problem where I know the highest score is not attainable
10:00:40 <araujo> or too buggy ... it sounds scary to me.
10:00:46 <roconnor> int-e: correct.  balance is a worse language than ocult
10:00:59 <SamB> even C, if you bundle a struct of the bound "variables" with a function pointer
10:01:05 <roconnor> Igloo: how do you know?
10:01:18 <Maddas> SamB: Ah, I misunderstood your first sentence. I agree :-)
10:01:21 <int-e> Then why did I think it's BLACK, the plink problem?
10:01:24 <int-e> Oh well.
10:01:34 <jmmv> ndm, ok, successfully migrated my program to System.FilePath :-)
10:01:56 <roconnor> yes, BLACK gives constant scores for puzzles
10:01:56 <ndm> jmmv: cool :)
10:02:11 <Igloo> By reasoning about it
10:02:33 <roconnor> Igloo: do you know the map from lenght to points?
10:02:53 <Igloo> No
10:03:04 <Igloo> But I know I made the shortest solution and didn't get full points
10:03:48 <SamB> Maddas: well, if you pass a closure to map(), you don't care if the variables won't be the same later on... because you are passing it *now* and it is being evaluated *very soon*
10:04:13 <SamB> (before you get to change those variables, anyway)
10:04:25 <roconnor> Igloo: interesting.
10:04:36 * Igloo wonders where my solutions are
10:04:59 <SamB> whereas if you, oh, added it as a callback to a Deferred, you'd have to be careful of those variables changing...
10:05:04 <Maddas> Right.
10:05:54 <SamB> (a Deferred being an artifact of the fairly nice Twisted asynchronous programming framework -- Twisted, the framework for your Internet)
10:06:08 * SamB apologizes for probably out-of-date slogan ;-)
10:06:46 <dolio> What's with the dude on the haskell' list posting links to other functional languages/papers he likes?
10:06:52 <mauke> @index toDyn
10:06:52 <lambdabot> Data.Dynamic
10:07:02 <SamB> dolio: maybe they have features he wants in Haskell'?
10:07:21 <Igloo> roconnor: Ah, 97 for clearreg I think it was
10:07:42 <dolio> I guess, but in the one case, at least, it sounds like "I'm working on a language that will be better than haskell" or something. :)
10:08:51 <dolio> Although I did enjoy the concurrency paper he linked to when I read it a while back.
10:08:52 <roconnor> you know you have the shortest solution?
10:09:59 <Igloo> Hmm, now I think about it, possibly not
10:10:03 <Taral> :( Still no debian ghc 6.6 packages :(
10:10:21 <Igloo> You might be able to do something cunning with the PC
10:12:19 <roconnor> :)
10:12:27 <roconnor> I think balance is hard to reason about
10:12:49 <roconnor> esp with that strange negative program counter wraping behaviour
10:13:06 <dolio> The language from ICFP?
10:13:06 <hygge> ndm: stil there? :)
10:14:03 <ndm> hygge: yep
10:14:04 <SamB> roconnor: "I think"
10:14:05 <SamB> ?
10:14:13 * SamB *knows*
10:14:19 <hygge> i solved it using SplitAt... it toke me a while though... here is how i did it: http://pastebin.ca/204076
10:14:27 <SamB> roconnor: what strange negative wrapping behaviour?
10:14:35 * SamB never tried running programs backwards
10:15:27 * SamB should write a balance VM with a nice mousy text-based UI
10:15:28 * Taral manually builds 6.6 :(
10:15:34 <SamB> or something like that
10:15:40 <SamB> Taral: manually????
10:15:48 <SamB> that is going to take forever!
10:15:59 <SamB> you are *much* better off using the Makefiles!
10:16:08 <roconnor> , a negative instruction speed has a curious behavior. At each step, the new instruction pointer computed is (((IS + IP) mod 232) mod length(CODE)), not ((IS + IP) mod length(CODE)).
10:16:09 <Taral> *snicker*
10:16:17 <roconnor> that is 2^32
10:16:26 <hygge> bold
10:16:28 <Taral> roconnor: What are you talking about?
10:16:30 <hygge> lel
10:16:39 <roconnor> Taral: ICFP contest
10:16:42 <ndm> hygge: http://pastebin.ca/204079 - a better neater version
10:18:17 <SamB> Taral: btw, I really don't think embedding more semantic information in the language is going to help the compiler figure out that if a constant of unlifted type is passed into a function that cases over the result of a comparison of that argument with another constant primitive, it can get rid of one arm of the case...
10:18:52 <SamB> s/unlifted/primitive/
10:18:54 <int-e> > let cut n = unfoldr (\l -> (guard . not . null) l >> Just (splitAt n l)) in cut 3 "abcdefgh" -- somewhat obscure version.
10:18:55 <lambdabot>  ["abc","def","gh"]
10:19:10 <Taral> No?
10:19:47 <SamB> well.
10:19:49 <roconnor> SamB, I believe Taral's suggestion would be to export the function uncheckedShift : Word32 -> forall (x:Int) -> (0 <= x) -> (x < 32) -> Word32
10:19:55 <Taral> Yes.
10:19:56 <SamB> how do you think it would help?
10:20:07 <SamB> oh.
10:20:09 <nick8325> Taral: there are debian packages at http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
10:20:10 <Taral> Except it wouldn't be "unchecked".
10:20:10 <SamB> hrmm.
10:20:11 <lambdabot> Title: Haskell Unsafe, http://tinyurl.com/y4lmhv
10:20:13 <Taral> It would be a fast shift.
10:20:28 <Taral> The proof obligations are exposed at the type level instead of embedded in conditionals.
10:20:40 <SamB> hmm.
10:21:00 <SamB> doesn't dependant typing have a high cost somewhere or otheR?
10:21:11 <Taral> Not if the dependent types are propositional.
10:21:28 <roconnor> SamB, we have had trouble removing unneccesary parameters.
10:21:31 <Taral> Propositional types have no functional data, and are removed entirely after type erasure.
10:21:42 <SamB> oh
10:21:44 <roconnor> unneccessary for computation, but necessary for type checking.
10:21:53 <roconnor> but it is hard to tell them apart
10:22:01 <Taral> hard to tell what apart?
10:22:16 <roconnor> Taral: parameters that are only necessary for type checking purposes.
10:22:31 <Taral> Well, the system I imagined marks them with a different kind.
10:22:34 <SamB> roconnor: I'd say a good clue would be whether they are used in the function?
10:22:35 <Taral> Like the Set and Prop kinds in coq.
10:23:13 <roconnor> Taral: but the length of a list is a nat, and is in Set.
10:23:20 <SamB> I agree that the way GHC does it now is pretty silly
10:23:26 <Taral> Oh, I see!
10:23:30 <SamB> but changing the language seems unlikely to help
10:23:51 <roconnor> but sometimes lengths of lists are passed as parameters to enforce various dependent type properites, you could imagine.
10:23:53 <phr-newbie> @pf \x -> f x == x0
10:23:54 <lambdabot> Maybe you meant: bf pl
10:23:59 <SamB> s/is pretty silly/seems pretty silly/
10:24:04 <roconnor> but these lengths are never used in the computation.
10:24:05 <phr-newbie> @lf \x -> f x == x0
10:24:06 <lambdabot> Done.
10:24:11 <phr-newbie> @pl \x -> f x == x0
10:24:12 <lambdabot> (x0 ==) . f
10:24:29 <Taral> roconnor: Yes, I see what you mean. You'd have to do a pass where after dependencies are checked, they're removed, and then a round of dead-code/unused-argument elimination is done.
10:24:34 <roconnor> laziness should prevent these terms from being evaluated.
10:24:45 <roconnor> but not prevent them from being allocated.
10:24:58 <SamB> Taral: your way requires changing a bunch of code, doesn't it?
10:25:00 <hygge> ndm: http://pastebin.ca/204087
10:25:01 <Taral> Yup!
10:25:04 <roconnor> Taral: I understand it is a hard problem :(
10:25:06 <Taral> Hell, it requires a new language.
10:25:26 <ndm> hygge: no, "" :: [Char], [] :: [a], so less polymorphic
10:25:27 <SamB> see, this is why it is not "the fix"
10:25:35 <Taral> It's a long term fix.
10:25:43 <hygge> ndm: ah :)
10:25:44 <SamB> well, it isn't *the* fix
10:25:44 <ndm> hygge: restricts you to strings only, not lists of int's etc
10:25:52 <hygge> i see :)
10:25:53 <Taral> SamB: Every other "fix" is a poor compromise.
10:25:54 <SamB> it doesn't magically fix everything ;-)
10:26:09 <SamB> probably!
10:27:36 <SamB> oh, but the thing is...
10:28:42 <SamB> the Data.Bits interface specifies that if you shift all the bits out, you are supposed to end up with 0...
10:28:50 <SamB> not a type error!
10:29:34 <SamB> at least, I think it does...
10:29:57 <roconnor> SamB, shift can still be build upon uncheckShift the way it is done now.
10:30:28 <SamB> roconnor: that doesn't get rid of those "ifs" or "cases", does it?
10:30:57 <roconnor> SamB, no but the user would get to call uncheckedShift themselves if they can prove they can avoid the check.
10:31:04 <SamB> hmm.
10:31:09 <SamB> so how would they prove it?
10:31:15 <roconnor> it depends
10:31:33 <SamB> and wouldn't it be nicer for the compiler to do that?
10:31:35 <roconnor> in this case 0 <= 7 and 7 < 32 have a trivial proof.
10:31:46 <SamB> yeah.
10:31:51 <roconnor> (assuming a decent definition of <= and <
10:32:18 <roconnor> so it would be uncheckedShift x 7 () () probably
10:32:56 <roconnor> And hopefully the compiler removes the unit types and objects.
10:32:57 <SamB> but, who wants to write code like that?
10:33:15 <roconnor> Conner McBride.
10:33:26 <dcoutts> heh, true
10:33:30 <SamB> who is he?
10:33:46 <roconnor> maybe dcoutts can answer that.
10:33:47 <dcoutts> the man who will tell you that general recursion isn't true!
10:34:01 <dcoutts> and he's right of course :-)
10:34:10 <SamB> okay
10:34:17 <roconnor> @where Epigram
10:34:17 <lambdabot> http://www.e-pig.org/
10:34:20 <SamB> how is it "not true"?
10:34:57 <roconnor> SamB, you can check out "A View From The Left"
10:35:00 <SamB> hmm
10:35:04 <roconnor> I think that is the canonical paper on Epigram.
10:35:06 * SamB may have seen that
10:35:12 * SamB probably has
10:35:13 <dcoutts> via the curry-howard isomorphism, programs are related to proofs
10:35:18 <SamB> yes, I know.
10:35:23 <dcoutts> so when you interpret general recursion as a proof rule...
10:35:38 <SamB> but I'd much rather just write `shiftL` or `shiftR`...
10:35:40 <dcoutts> well, it's not a very helpful one since it allows you to prove eferything
10:35:53 <dcoutts> eferything/everything
10:35:57 <SamB> ??
10:35:59 <SamB> oh.
10:36:00 <SamB> right.
10:36:10 <SamB> @type let x = x in x
10:36:11 <dcoutts> forall T. _|_ :: T
10:36:12 <lambdabot> forall t. t
10:36:49 <dcoutts> with general recursion, every type is inhabited (by _|_)
10:36:59 <SamB> hmm.
10:37:32 <SamB> thats interesting!
10:37:49 <dcoutts> the curry-howard isomorphism relates programs, types and proofs by making statements about wether types (as sets) are empty or not
10:38:02 <ndm> dcoutts, unless you prove separately the absence of _|_, i.e. you don't necessarily have to do this in the type system
10:38:02 <dcoutts> the programs are proofs of the emptyness or otherwise of the types
10:38:03 * SamB wonders what happens if you try to do a recursive let involving a variable of unlifted type on both sides?
10:38:14 <dcoutts> ndm, sure
10:38:49 <ndm> of course, try telling that to a dependant types person...
10:38:56 <dcoutts> so if every type is inhabited, then all statements you can make in the system are true
10:39:01 <dcoutts> and thus not very helpful
10:39:27 <musasabi> SamB: ghci complains:
10:39:28 <musasabi>     Recursive bindings for unlifted types aren't allowed: a = b, b = a
10:39:38 <SamB> but none of this is needed for a humble UM or cryptographic hash implementation...
10:39:41 <dcoutts> to be able to have a non-trivial system where you can make statements that mean anything, you need for there to be types with no values
10:39:56 <SamB> musasabi: nice ;-)
10:39:58 <SamB> @ghc
10:39:59 <lambdabot>  Can't represent Oxford brackets
10:40:01 <SamB> @ghc
10:40:01 <lambdabot>  GHC internal error
10:40:08 * SamB wonders if that is in there yet...
10:40:38 <mwc> what's an Oxford bracket?
10:40:45 <SamB> dcoutts: so why would you want to make false statements again?
10:40:50 <dcoutts> http://en.wikipedia.org/wiki/Curry-Howard_isomorphism#The_type_inhabitation_problem
10:40:54 <lambdabot> http://tinyurl.com/yawrec
10:41:01 <SamB> and how could you make them if the type wasn't inhabited?
10:41:17 <dcoutts> SamB, the theorem would be false
10:41:29 <SamB> wouldn't you have to comment them out then?
10:41:44 <dcoutts> the type is the theorem, the program having that type is a proof of the theorem
10:41:55 <SamB> but you can't *write* the program...
10:42:25 <dcoutts> sure, if there is no proof of the theorem, then the theorem is probably false :-)
10:43:00 <dcoutts> or rather if you can proove that there can be no proof
10:43:07 <dcoutts> that the type is empty
10:43:51 <dcoutts> SamB, if everything you can state in the system is true, then it's not a very interesting system.
10:44:16 <SamB> hmm
10:44:37 <SamB> I still don't think you can write a decent UM in epigram
10:44:45 <dcoutts> why not ?
10:44:46 <roconnor> the type 35 < 32 has no inhabitents
10:45:07 <SamB> does epigram have Ptrs or IOUArrays?
10:45:09 <roconnor> this is what prevents me from compiling uncheckedShift x 35 () ()
10:46:06 <dcoutts> SamB, their focus is not on writing effecient programs at the moment
10:46:11 <SamB> well, see.
10:46:26 <roconnor> SamB, I belive Epigram could have IOUArrays, although this is unproven, and would make a good research project.
10:46:26 <SamB> that is *not* going to help much then ;-)
10:46:31 <Taral> Ugh.
10:46:33 <Taral> Language/Haskell/TH/Syntax.hs:46:0:
10:46:33 <Taral>     Warning: Module `Data.PackedString' is deprecated:
10:46:41 <Taral> You'd think that before a release someone would go through and clean up all of these.
10:46:43 <SamB> what about UOME arrays?
10:47:24 <dcoutts> SamB, though I think they do have someone working on a compiler, and it can take advantage of the type info to eliminate bounds checks etc
10:47:26 <SamB> Taral: is it abstract not?
10:47:32 <SamB> er. , or not?
10:47:33 <dons> Taral: its just a warning. it means nothing.
10:47:38 <dcoutts> well the code never had bounds checks in the first place
10:47:45 <Taral> It's just unpretty. :P
10:47:48 <musasabi> Taral: that doesn't break anything.
10:47:52 <dons> compile with -w then
10:47:58 <musasabi> Taral: there are many broken things in the release also.
10:48:24 <SamB> acceptance tests are lacking
10:48:50 <dcoutts> dons, thanks for the report from the google SoC conference, interesting reading.
10:48:57 <Taral> The kernel people started taking out the "harmless warnings" because there were enough of them to cover up real problems.
10:49:05 <Taral> Perhaps that might be a good idea for ghc?
10:49:17 <Taral> As well as a less verbose build output.
10:49:18 <roconnor> the advantage of uncheckedShift with dependent types is that in addition to supporting trivial proofs, you can also have a very complex reason why your check is safe.  It would be able to support that where the complier could never figure it out.
10:49:19 <SamB> Taral: perhaps.
10:49:21 <dcoutts> people do try
10:49:33 <dons> Taral: you know how to patch ;)
10:49:38 <Taral> Yes, yes.
10:49:42 <Taral> "Don't bitch, fix it."
10:49:48 <Taral> <- lazy
10:50:01 <Taral> It took me until now to finally break down and compile ghc 6.6.
10:50:03 <dons> the solution, and feel free.. , is to port TH to use ByteString.
10:50:04 <SamB> well, getting rid of the commandlines may *not* be such a good idea...
10:50:17 <Taral> SamB: Why not?
10:50:22 <dons> dcoutts: sure. let me know if you have any more questions, and i can clarify on the mailing lists
10:50:23 <dcoutts> dons, or for someone to get Data.PackedString working :-)
10:50:24 <SamB> Taral: they might be important!
10:50:28 <dons> dcoutts: or that.
10:50:32 <Taral> If so, then you can enable them.
10:50:55 <SamB> well. feel free ;-)
10:50:55 <SamB> that shouldn't be very hard to do!
10:51:47 <SamB> just find where they have the rule to build .hs files, add an @ (I think), and make it say what is being built...
10:52:32 <musasabi> dons: it needs unicode...
10:52:35 <Taral> And turn off the <<ghc: ...>> output somehow. Not sure how that's being turned on.
10:52:53 <SamB> oh, you can do that in your mk/build.mk file
10:53:24 <Igloo> Warnings should be fixed, not disabled
10:53:29 <SamB> I think
10:53:33 <SamB> Igloo: agreed
10:53:46 <SamB> -Rghc-timing to turn it *on*
10:54:02 <Taral> Igloo: Yes, I'm advocating trimming the build output further by removing command lines and ghc summary lines.
10:54:11 <Taral> Makes warnings stand out more.
10:54:30 * Igloo strongly objects to removing the command lines
10:54:36 <Taral> Igloo: Why?
10:54:41 <SamB> then the warnings would need to all include the source/module name, though...
10:54:45 <Igloo> Makes it harder to investigate problems
10:54:47 <Taral> You can turn it back on if you want it.
10:54:54 <Igloo> You shouldn't have to
10:55:01 <SamB> it shouldn't be off by default...
10:55:17 <ndm> well its an absolute pain building Hugs libraries, there is no way to spot build errors - the reason that Hugs May 2006 ships with an incomplete base library!
10:55:26 <Taral> The average person building ghc doesn't care about the command lines.
10:55:39 <Taral> If you're hacking on it, you have a custom build.mk anyway, so the command lines will be on.
10:55:40 * SamB thinks that the warnings from mk/build.mk.sample should be, though
10:55:44 <SamB> or, er.
10:55:48 <SamB> should be ON
10:55:53 <SamB> by default
10:56:05 <Taral> more warnings, less command lines and GC.
10:56:20 <Igloo> The average person shouldn't need to build GHC themselves
10:56:38 <Taral> Igloo: Then why am I building ghc right now?
10:56:46 <musasabi> tell us.
10:56:48 <Igloo> Because you are impatient
10:57:33 <SamB> Igloo does not think the average person should be a GHC hacker?
10:57:33 <psnl> ndm: around? quick question for you?
10:57:41 <ndm> psnl: go on
10:57:43 * edwardk waves hello.
10:57:56 <psnl> hello all,
10:58:11 <Taral> If I were impatient, I'd have been using ghc-cvs this whole time. :P
10:58:29 <psnl> ndm: in your posting about hat-gui to the hat mailing list, you talk about tieing together the tools
10:58:47 <ndm> if GHC had proper buildbots and snapshots, then you'd be able to get a precompiled release every night...
10:58:48 <Igloo> SamB: Taral was dividing GHC users into "people hacking on it" and "average people", so with that definition average people are not GHC hackers
10:58:55 <ndm> psnl: yep, in hat-gui
10:59:01 <psnl> ndm: how is that going/ going to work/etc ?
10:59:03 <SamB> Igloo: oh ;-)
10:59:03 <Taral> Yup.
10:59:08 <Taral> All my fault.
10:59:18 <ndm> psnl: each tool has an API, then hat-gui can use all the API's
10:59:22 <Igloo> ?
10:59:29 <Taral> Igloo is right that people have less reason to be compiling ghc than to be compiling a linux kernel (for example)
10:59:36 <SamB> ndm: you are assuming that somehow these buildbots would be able to *build* every night ;-)
10:59:49 <Igloo> I wasn't blaming you for anything, just explaining the terms we were using as I'd understood it
10:59:50 <Taral> In general, distribution maintainers and porters compile ghc. Oh, and insane people like me.
11:00:01 <ndm> SamB, if you break the build, you have to buyt everyone a drink - a simple algorithm for keeping the build alive
11:00:03 <Taral> ("all my fault" = humor)
11:00:14 <Igloo> Ah, OK  :-)
11:00:17 <SamB> ndm: I don't think I'm old enough to buy anyone a drink!
11:00:19 <Taral> (Add liberal smilies to my text.)
11:00:27 <hygge> quick question, when have started a "do", im automaticly in the IO world?
11:00:35 <Taral> I'm mostly griping while waiting for ghc to compile.
11:00:37 <jmmv> Taral, or those who use source-based packaging systems (bsds, gentoo...)
11:00:39 <Igloo> ndm: There are precompiled releases every night already
11:00:49 <Taral> jmmv: Those are usually packaged source, with builder scripts.
11:00:55 <ndm> Igloo: but not packages for each release, no windows installer exactly as per release etc.
11:01:29 <Igloo> That's orthogonal to buildbot, though
11:01:32 <ndm> Igloo: your nightly builds /= your release builds
11:01:38 <Taral> Igloo: So when should I start looking for a 6.6 debian package?
11:01:39 <SamB> we should have a tinderbox-style page, I think...
11:01:48 <ndm> indeed, i just use buildbot == nightly build
11:01:51 <SamB> you know to show what is broken on what systems...
11:01:52 <psnl> ndm: I'm trying to nial down my project requirements, since while the dept doesn't mind e doing lots of moving work, they wouldn't give spectacularly good marks for it
11:02:25 <ndm> ah, now buildbot does give the tinderbox style stuff
11:02:27 <Igloo> Taral: I've got about 10mins of download to go, then sign some things, then upload everything, then the buildds need to build it
11:02:41 <edwardk> Hrmm. if you had no restrictions of backwards compatibility and wanted a form of syntactic sugar for printf ('%':'d':xs) = ... to get something where you didn't have to keep separating your characters, what would you choose?
11:02:42 <Taral> Yay!
11:02:46 <ndm> psnl: i guessed that, what do you want to do, to get the good marks?
11:02:47 <Taral> Download?
11:02:56 * Taral cancels his ghc build. :P
11:03:12 <scsibug> hygge: not necessarily, you are simply in monad land
11:03:13 * Igloo is downloading my alpha build from the alpha
11:03:23 <Taral> Oh, you test on an alpha, cool!
11:03:26 <ndm> psnl: integrating the existing tools in a GUI has some merit, but i guess if you want high marks you need some sort of new tool?
11:03:27 <psnl> ndm: so I'm thinking about working on tieing the tools together, which would include some thought and design and other stuff
11:03:43 <ndm> psnl: yes, then the moving around stuff would just be a requirement to get that done
11:03:50 <hygge> scsibug: okey.
11:04:01 <ndm> psnl: you need a clear API/tool split before you start on the integration, i assume?
11:04:14 <psnl> yeah, but I wouldn't mind working on that
11:04:24 <ndm> indeed
11:04:33 <Taral> Igloo: Tell me when it's uploaded -- I'll pull it from incoming.
11:04:47 <ndm> i am trying to convince people to write new tools as API's, and convert some of the existing ones, and do some of the API work
11:04:50 <Igloo> Taral: Well, I did a few test builds on various arches leading up to the release, but the alpha build is because alpha broke a while ago
11:05:03 <ndm> psnl: as i guess thats not an issue if other people do it, since your work will be the integration
11:05:27 <Igloo> Taral: You're on alpha?
11:05:39 <psnl> ndm: I'll also try to do a new tool, but I don't have any ideas that are  wonderful
11:05:40 <Taral> no, amd64
11:06:07 <psnl> ndm: cool, I'll run that past Paul
11:06:09 <ndm> psnl: yeah, me neither
11:06:20 <Igloo> OK
11:06:21 <ndm> psnl: cool, let me knwo the results
11:07:15 <ndm> off now for dinner, hmm, bacon - bye
11:07:59 * SamB does another profile of spectral/fish
11:08:21 <psnl> bye
11:10:57 <SamB> well, too really
11:11:00 <SamB> er, two
11:11:15 <SamB> oh arg
11:11:17 <SamB> I need -P
11:11:26 <SamB> I think...
11:11:53 <SamB> oh, much faster with >/dev/null
11:14:52 <SamB> hmm...
11:15:13 <Taral> I hate C.
11:15:16 <Taral> I hate it a lot.
11:15:17 <vegai> does irssi (or lambdabot..) have a command to count the number of people in a channel
11:15:25 <Taral> I hate it especially for the esoteric type syntax.
11:15:36 <araujo> ?users
11:15:41 <lisppaste2> SamB pasted "fish profile diff" at http://paste.lisp.org/display/28015
11:15:43 <araujo> ?users #haskell
11:15:51 <lambdabot> seen module failed: IRCRaised thread killed
11:15:57 <vegai> Yauch.
11:16:07 <SamB> @seen araujo
11:16:08 <lambdabot> seen module failed: IRCRaised thread killed
11:16:08 <lambdabot> araujo is in #gentoo-haskell, #perl6, #haskell and #haskell.es. I last heard araujo speak 17s ago.
11:16:28 <vegai> Oh well..
11:16:41 <vegai> I'll approximate and say that there's about a thousand people here :P
11:16:47 <Taral> 232
11:16:54 <SamB> heh
11:17:08 <SamB> the user list only shows 232 users...
11:17:12 <Taral> compared to 5 in #haskell'
11:18:29 <roconnor> @seen
11:18:30 <lambdabot> Lately, I have seen araujo, hygge, igloo, lisppaste2, ndm, psnl, roconnor, samb, taral and vegai.
11:18:38 <roconnor> @users
11:18:39 <lambdabot> Maximum users seen in #haskell: 256, currently: 229 (89.5%), active: 38 (16.6%)
11:18:49 <araujo> mmm....
11:19:04 <araujo> weird, i though tit worked with ?users too
11:19:14 * Igloo had forgotten about #haskell'
11:19:41 <Taral> It's very idle.
11:19:41 <SamB> ?users
11:19:42 <lambdabot> Maximum users seen in #haskell: 256, currently: 228 (89.1%), active: 37 (16.2%)
11:19:51 <araujo> ?users
11:19:52 <lambdabot> Maximum users seen in #haskell: 256, currently: 228 (89.1%), active: 37 (16.2%)
11:19:56 <araujo> ?users #haskell
11:19:57 <lambdabot> Maximum users seen in #haskell: 256, currently: 228 (89.1%), active: 37 (16.2%)
11:19:58 <SamB> wierd!
11:20:00 <araujo> :-P
11:20:16 <SamB> something must have confused it
11:20:26 <vegai> fascinating.
11:20:34 <SamB> _|_ in its datastructures or something
11:21:17 <araujo> ?users
11:21:17 <lambdabot> Maximum users seen in #haskell: 256, currently: 229 (89.5%), active: 37 (16.2%)
11:21:26 <araujo> ?users #users
11:21:27 <lambdabot> Maximum users seen in #users: 1, currently: 0 (0.0%), active: 0 (NaN%)
11:21:55 <araujo> ?users #erlang
11:21:55 <lambdabot> Maximum users seen in #erlang: 1, currently: 0 (0.0%), active: 0 (NaN%)
11:22:21 <SamB> @users #perl6
11:22:21 <lambdabot> Maximum users seen in #perl6: 148, currently: 130 (87.8%), active: 8 (6.2%)
11:22:26 <phr-newbie> @pl \x -> x*x
11:22:26 <lambdabot> join (*)
11:22:27 <Igloo> dcoutts, dons: Where did that report go?
11:22:37 <SamB> @where stats
11:22:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
11:22:40 <phr-newbie> ?type join
11:22:42 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
11:23:11 <dcoutts> Igloo, soc-mentors list
11:23:17 <Igloo> Ah, OK
11:23:33 <glguy> > (do { a <- (*); a }) 4
11:23:33 <[I]nfecT> hey guys im having this error in my code and i have no idea how to get it fixed.. ive played around for hours... Occurs check: cannot construct the infinite type: a = (a1 -> a1 -> a1) -> ta In the expression: face !! 2 In the second argument of `(==)', namely `(face !! 2)'
11:23:34 <lambdabot>  16
11:23:36 <[I]nfecT> my line is: if (((sum face) div 5)==(face !!2)) then
11:23:50 <glguy> [I]nfecT: use `div`
11:23:56 <[I]nfecT> ah k
11:24:51 <glguy> sum face `div` 5 == face !! 2       will work as well as the version with lots and lots of parenthesis
11:29:55 <Taral> @pl (\m n -> m >>= (\x -> n >> return x))
11:29:56 <lambdabot> (. ((. return) . (>>))) . (>>=)
11:30:11 <Taral> @pl (\x -> n >> return x)
11:30:11 <lambdabot> (n >>) . return
11:59:10 <ventonegro> is libglade preferred when using gtk2hs?
11:59:51 <fasta> Suppose you have a State monad where you have one "read only" variable, should you change it to StateT with an inner Reader monad? I did it, and it makes the semantics of my program more explicit, but whether it's "better"?
12:00:34 <roconnor> it's better because you won't accidently change the value
12:01:06 <glguy> and it might be more clear to someone else reading your source what you intentions were for that value
12:01:07 <SamB> fasta: what kind of "better"?
12:01:51 <fasta> SamB: "better" as in that someone with lots of experience with FP reads it and sees: Oh, what a nice design.
12:02:05 <SamB> oh
12:02:05 <araujo> ventonegro, dcoutts recommends it ... though i didn't feel comfortable with it ... :-)
12:02:10 * SamB has no clue!
12:02:42 <SamB> just pretend you have a lot of experience ;-)
12:02:52 <glguy> using libglade allows for better separation of functionality and design , imho
12:03:09 <ventonegro> araujo, why not?
12:04:04 <araujo> ventonegro, i found funny to use without it ....
12:04:04 <SamB> hmm...
12:04:08 <fasta> SamB: well, I used to look at all these Monad code with: why bother? I used State monad and saw it actually solved a problem. The benefit for Reader seems lower.
12:04:23 <SamB> how in the world am I losing "HasNoCafRefs"...
12:04:55 <SamB> fasta: so try it!
12:05:05 <fasta> SamB: I already implemented it
12:07:31 <dolio> Well, now you know there aren't any cases where you accidentally modify the read only state.
12:07:39 <dolio> So that's nice, I guess.
12:08:57 <fasta> In other programming languages people put that concept in the syntax as an annotation. Maybe that's better.
12:09:14 <fasta> OTOH, you can't have syntax for every nice idea in the world.
12:09:42 <dolio> Like const/final?
12:09:47 <fasta> dolio: right
12:10:09 <dolio> Well, all identifiers in haskell are like that.
12:10:40 <fasta> dolio: When you start using Monads the line blurs
12:13:17 <emu> how's ghc 6.6 holding up
12:13:42 <fasta> > liftio ask
12:13:43 <lambdabot>  Not in scope: `liftio'
12:13:47 <fasta> > lift ask
12:13:48 <lambdabot>  add an instance declaration for (Show (t m r))
12:13:52 <glguy> liftIO
12:14:15 <fasta> Hmm, that gave an urk a few days ago?
12:15:20 <glguy> ?version
12:15:21 <lambdabot> lambdabot 4p245, GHC 6.5 (OpenBSD i386)
12:15:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:15:29 <glguy> lambdabot: isn't running 6.6 yet
12:15:49 <[I]nfecT> glguy do you mind taking a look at this last error im having: http://pastebin.com/807148
12:16:23 <psi> how is Network.CGI used?
12:16:25 <glguy> pastebin is crazy slow
12:16:29 <glguy> use:
12:16:30 <glguy> ?paste
12:16:31 <lambdabot> http://paste.lisp.org/new/haskell
12:16:31 <glguy> ?
12:16:33 <[I]nfecT> k
12:18:12 <glguy> it just loaded
12:18:47 <lisppaste2> [I]nfecT pasted "parse error" at http://paste.lisp.org/display/28016
12:19:54 <Lemmih> psi: From cgi or network?
12:19:59 <glguy> [I]nfecT: first of all I think you are misusing
12:20:00 <glguy> do
12:20:10 <[I]nfecT> ah
12:20:10 <glguy> and return
12:20:16 <[I]nfecT> ok
12:20:23 <[I]nfecT> what do you suggest
12:20:37 <glguy> return doesn't work like the return in Java or C
12:20:50 <glguy> return is for using Monads
12:21:05 <[I]nfecT> ah k
12:21:36 <glguy> [I]nfecT: and I'm pretty sure you are approaching this function the wrong way, what exactly are you trying to do?
12:22:17 <[I]nfecT> trying to build a "cheap" poker algorithm to check for straights, flushes, etc etc
12:22:19 <psi> Lemmih: I'm not sure how CGI works in general. I figured I could learn by looking at how it's done in Haskell.
12:22:43 <[I]nfecT> face is a list of 5 values
12:23:00 <[I]nfecT> funique is the face uniqueness that i get from another function
12:23:58 <glguy> [I]nfecT: for example, if you wanted to check for flush
12:24:11 <glguy> (\x -> minimum x == maximum x) [1,2,3,4,5]
12:24:15 <glguy> (\x -> minimum x == maximum x) [1,1,1,1,1]
12:24:25 <Lemmih> psi: Well, 'runCGI $ output "Hello world"' would be a simple CGI program.
12:24:28 <glguy> rather than checking individual elements
12:25:13 <[I]nfecT> ah k
12:25:20 <glguy> or the more efficient...
12:25:24 <psi> Lemmih: am I missing something from the documentation? the only functions I see are wrapper, pwrapper and connectToCGIScript, and they are not documented at all.
12:25:30 <glguy> (\x -> and (zipWith (==) x (tail x))
12:25:41 <Cale> What are these numbers you're returning with the zeroth element of face?
12:25:49 <[I]nfecT> lol ya haskell is VERY new for me
12:25:52 <mauke> @hoogle [a] -> Bool
12:25:53 <lambdabot> Prelude.null :: [a] -> Bool
12:25:53 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
12:25:53 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
12:25:59 <[I]nfecT> so im a bit struggling
12:26:13 <Lemmih> psi: Check out http://www.cs.chalmers.se/~bringert/darcs/cgi-compat/doc/
12:26:16 <[I]nfecT> but glguy i understand the fact that it may be "bad" coding right
12:26:18 <lambdabot> http://tinyurl.com/vysqa
12:26:35 <Lemmih> psi: That package has replaced the old Network.CGI.
12:26:47 <[I]nfecT> but lets say in trying to correct this error... how would you go about it?
12:26:58 <[I]nfecT> (not by changing the full code)
12:27:04 <sieni> [I]nfecT: probably the code might actually work if you remove the "do":s and "return":s
12:27:14 <[I]nfecT> k
12:27:22 <sieni> (modulo indentation that can always screw things up in Haskell)
12:27:40 <psi> Lemmih: oh, but it's not yet included in ghc?
12:27:45 <glguy> [I]nfecT: I haven't bothered searching for the error in your nested ifs
12:28:01 <fasta> What was that command in lambdabot to define persistent functions?
12:28:06 <glguy> I think you should try to find a clearer way to express what you are trying to do first
12:28:09 <Cale> [I]nfecT: another thing is that most of the parens you're using aren't actually needed
12:28:16 * glguy reboots, brb
12:28:29 <sieni> glguy: that does not help much with a syntax error, right?
12:28:30 <[I]nfecT> ya... i know hehe
12:28:41 <Lemmih> psi: It's shipped with ghc-6.6.
12:28:58 <psi> ah, cool.
12:29:06 <Igloo> It's an extralib if you're talking about cgi
12:29:45 * SamB tries to get decent profiles of the three programs that had significantly increased allocation...
12:31:19 <fasta> [I]nfecT: Maybe Lisp is better for you, as you can't have too many parentheses?
12:31:30 <psi> I wish debian's ghc for ppc came with ghci :/
12:31:40 <[I]nfecT> really? ah
12:31:42 <[I]nfecT> perhaps
12:31:56 * glguy back
12:31:57 <fasta> [I]nfecT: Oh, I wasn't being entirely serious.
12:32:06 <Cale> no, you can have too many parentheses in lisp
12:32:07 <Igloo> psi: The next one hopefully will
12:32:09 <[I]nfecT> Functionnal programming for me is new.. so i have to get used to the concepts
12:32:35 <lisppaste2> Cale annotated #28016 with "trivially prettyprinted" at http://paste.lisp.org/display/28016#1
12:32:35 <sieni> > ((+) 7 8) -- You can do lispish stuff in Haskell as well!!!1!
12:32:36 <lambdabot>  15
12:32:37 <glguy> sieni: my argument was that he's going to want to scrap that code anyway, so there was no sense in fixing it
12:33:25 <psi> Igloo: that's nice to hear. do you know when it'll be released?
12:33:41 <Igloo> Not for several days or weeks
12:33:47 <fasta> Cale: my statement was not entirely accurate nor serious
12:33:51 <sieni> glguy: Well, does not help much learning a language if one doesn't know how to make some piece of code to compile?
12:34:05 <Cale> [I]nfecT: barring actually changing the code in a meaningful way, that's how your code would normally be laid out
12:34:17 <glguy> sieni: learning a language is more than getting things to compile, it is understanding how to forulate your problem in the language
12:34:34 <fasta> Cale: how did you get that pretty printed?
12:34:40 <fasta> Cale: Emacs mode?
12:34:57 <Cale> fasta: by hand in the html form I was submitting with :)
12:34:58 <[I]nfecT> Cale it's true but in fact you have to think different for every language because they do different things
12:35:03 <Cale> Things to notice are that 'if' doesn't require parens around the condition, and that 'then' and 'else' are lined up
12:35:07 <fasta> Cale: Impressive :)
12:36:52 <Cale> but there's obviously something wrong with this, since there are a lot of !!'s, which is always a bad sign, and a lot of the code looks pretty similar to other parts of the code :)
12:37:00 <ndm> SamB, does that mean your tweak slowed down some programs?
12:37:10 <sieni> glguy: O RLY?
12:37:17 <SamB> ndm: not exactly
12:37:19 <glguy> YARLY!
12:37:23 <SamB> at least, not on this monster of Lemmih's
12:37:44 <SamB> http://paste.lisp.org/display/27967
12:38:32 <sieni> NO WAI!
12:38:38 <Cale> You've been adding to that paste for almost a day :)
12:38:40 <Etni3s> http://tapes.ieattapes.com/uploads/Bush_O_RLY.jpg
12:38:43 <lambdabot> http://tinyurl.com/r2vgu
12:38:58 <SamB> Cale: no!
12:39:15 <SamB> it looks like I was only adding to it for about four hours...
12:39:39 <ndm> SamB, oh, regarding your Yhc comment, could you expand on it a bit - not entirely sure what you were meaning
12:39:50 <Cale> SamB: oh, there's nothing new there, sorry :)
12:40:03 <SamB> ndm: I mean, why are we making it show like Int?
12:40:24 <SamB> that could get pretty confusing...
12:40:24 <ndm> SamB, because its used to be shown as the name of an anonymous lambda
12:40:40 <ndm> the important property is that each unqiue "thing" shows differently
12:40:42 <Cale> SamB: did you ever get a good profile for fish_p?
12:40:58 <ndm> another important thing is to have no spaces in the output, or its not a valid looking identifer
12:41:14 <SamB> wouldn't it make more sense to use that code in the one module that encodes it into letters and numbers?
12:41:17 <ndm> showing as an Int isn't that important, but showing with a space (as in "Id n") is a biit bad
12:41:41 <ndm> SamB, possibly, that does sound sensible
12:41:52 <SamB> or maybe use some other function instead of show in those places that want something other than Id n?
12:41:53 <Cale> [I]nfecT: What do the 8,7,4, and 3 mean, which you're returning?
12:41:58 <ndm> SamB, or have a Id -> String method in Id
12:42:20 <ndm> exactly, i.e. make it clear that its not a "render to the screen", but something else
12:42:29 <ndm> ok, that sounds a reasonable idea
12:43:12 <[I]nfecT> Cale, im doing my own system... 8 being the user/computer got a royal flush, straight flush, three of a kind, and goes like this in order of importance
12:43:43 <SamB> it looks like the function I mean is in NT...
12:43:54 <Cale> Have you got to the part about datatypes in the tutorial?
12:44:12 <SamB> strTVar
12:44:26 <lennart> [I]nfecT: you should make an enumeration type and use that instead of numeric constants
12:44:41 <lennart> ah, Cale is ahead of me as usual :)
12:44:52 <ndm> haven't looked at that bit, anyway, the fix i did was required to get it back to how it was before, so needed
12:44:55 <SamB> so what should I call that if I put it in Id instead?
12:45:20 <ndm> but i accept that its probably better to not use the show instance in this case, and fix up the user, rather than the show definition
12:45:39 <Cale> data Hand = TwoPair | ThreeOfAKind | Straight | Flush | FullHouse | FourOfAKind | StraightFlush | RoyalFlush
12:45:40 <ndm> pick a name, any name
12:45:47 <glguy> ?paste
12:45:48 <lambdabot> http://paste.lisp.org/new/haskell
12:45:54 <ndm> perhaps strId
12:45:57 <[I]nfecT> ahhh
12:46:12 <ndm> i.e. convert an id to a string, but not for person consumption
12:46:12 <Cale>    deriving (Eq, Ord, Enum, Show, Read)
12:47:02 <[I]nfecT> Cale and glguy let me paste the whole program.. btw i got passed the error i gave you guys, but i got another one now haha
12:47:14 <fasta> What command is bound to '?' in lambdabot?
12:47:18 <[I]nfecT> ?paste
12:47:18 <lambdabot> http://paste.lisp.org/new/haskell
12:47:36 <psi> Lemmih: I can't get the "Hello World!" example from the docs to compile. It complains about "Overlapping instances for MonadCGI (CGIT IO)".
12:47:44 <fasta> (or does it automatically see when something is Haskell code?)
12:47:52 <lisppaste2> [I]nfecT pasted "proggie" at http://paste.lisp.org/display/28017
12:48:11 <SamB> ndm: well, really its okay for people too
12:48:14 <Cale> fasta: > is used to get it to evaluate Haskell expressions
12:48:32 <SamB> I just don't think it would make much sense in the middle of the output of some derived Show instance...
12:48:32 <fasta> ?let testL = do lift ask
12:48:33 <lambdabot> Urk! Inventing strangely-kinded void TyCon:     ZCt{tc a1Q5}     (* -> *) -> ...
12:48:39 <Cale> fasta: ? is nothing in particular, but along with @ (either one works) it marks the start of command names
12:48:41 <lisppaste2> glguy pasted "short poker hand snippet" at http://paste.lisp.org/display/28018
12:48:43 <fasta> Cale: ? also does something
12:49:03 <ndm> SamB, yes, i really wish there was a deriving Raw, that was Show as defined by deriving and could not be overriden
12:49:04 <fasta> @ let testL = do lift ask
12:49:11 <fasta> @let testL = do lift ask
12:49:11 <lambdabot> Urk! Inventing strangely-kinded void TyCon:     ZCt{tc a1Q5}     (* -> *) -> ...
12:49:16 <fasta> Hmm, never mind
12:49:23 <Cale> glguy: nice :)
12:49:29 <ndm> and automatically derived for all instances, without touching anything, for debugging support
12:50:40 <SamB> ndm: even cooler if it could also work on unlifted types somehow magical!
12:51:02 <ndm> unlifted?
12:51:09 <Cale> [I]nfecT: Look at glguy's paste :)
12:51:19 <SamB> i.e. primitive
12:51:24 <SamB> @kind Int#
12:51:25 <lambdabot> Not in scope: type constructor or class `Int#'
12:51:28 <SamB> hmm.
12:51:32 <SamB> @kind GHC.Exts.Int#
12:51:33 <lambdabot> #
12:51:36 <[I]nfecT> damn
12:51:37 <[I]nfecT> lol
12:51:43 <[I]nfecT> i fell like a fucking douche
12:51:58 <ndm> ah
12:52:23 <[I]nfecT> thats sweet glguy
12:52:42 <SamB> ndm: okay, so where are Ids being shown?
12:52:57 <ndm> SamB, no idea, remove the show instance and you'll find out quickly ;)
12:53:28 <glguy> [I]nfecT: thanks, just check out some of the list operations.  for a problem like this, you shouldn't need (!!)
12:53:56 <[I]nfecT> yea :\
12:54:12 <ventonegro> @hoogle Maybe a -> a
12:54:13 <lambdabot> Maybe.fromJust :: Maybe a -> a
12:54:13 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
12:54:13 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
12:54:25 <glguy> also, I hate "if", so I don't ever(?) use it...
12:54:32 <Cale> Which is good, because !! is slow (though I suppose your hand is only ever going to be 5 or so cards)
12:54:48 <fasta> [I]nfecT: and a State monad would be nice too for your code.
12:55:00 <Cale> but if you're going to use 'if', then line up the 'then' and 'else' :)
12:55:56 <Cale> As soon as you start nesting ifs, it's usually better to use guards
12:56:08 <[I]nfecT> ah k
12:56:15 <SamB> often before ;-)
12:57:28 <fasta> Cale: do you feel the same for monadic code (i.e. using guard)
12:57:38 <fasta> ?
12:58:08 <SamB> that is legal?
12:58:29 <SamB> oh. oh.
12:58:34 <SamB> function called guard.
12:58:55 <glguy> do I have the person who you are talking to on ignore?
13:00:24 <ventonegro> @index lifyIO
13:00:24 <lambdabot> bzzt
13:00:37 <int-e> @where logs
13:00:37 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
13:00:37 <ventonegro> @index liftIO
13:00:37 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:02:26 <mnvl> a one-element list is indistiguishable from the same element not in a list??
13:02:28 <roconnor> > 16+4+1-32
13:02:29 <lambdabot>  -11
13:02:45 <glguy> ?
13:02:51 <glguy> mnvl: ?
13:03:04 <mauke> mnvl: only in perl
13:03:45 <mnvl> well can you pattern match a one element list?
13:04:01 <int-e> > let f [x] = x in f [2]
13:04:02 <lambdabot>  2
13:05:41 <glguy> > let (x:[]) = x in f [2]
13:05:42 <lambdabot>  Not in scope: `f'
13:05:46 <glguy> > let f (x:[]) = x in f [2]
13:05:47 <fasta> > "glguy: you would probably have me on ignore"
13:05:48 <lambdabot>  2
13:05:48 <lambdabot>  "glguy: you would probably have me on ignore"
13:05:56 <mauke> haha
13:05:57 <glguy> fasta: i saw you type that
13:06:19 <Etni3s> you saw him type it? O_O
13:06:29 <fasta> Oh, then I don't know.
13:06:38 <glguy> Etni3s: yeah, I'm a stalker
13:06:41 <Etni3s> :)
13:07:01 <lisppaste2> psi pasted "Network.NewCGI problems" at http://paste.lisp.org/display/28020
13:07:09 <int-e> I think glguy was just confused by SamB writing three lines in a row.
13:07:15 <psi> does anyone know anything about that?
13:08:16 <tewk> Any debian haskell users, I'm trying to build pugs using http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
13:08:18 <lambdabot> Title: Haskell Unsafe, http://tinyurl.com/y4lmhv
13:09:09 <glguy> anyone running Ubuntu 6.10 and have GHC 6.6 yet?
13:09:13 <int-e> psi: is CGIResult monadic already?
13:09:21 <int-e> psi: (I don't know, I'm guessing)
13:09:29 <svref> I'm having trouble figuring out what strings are legal Haskell identifiers
13:10:50 <psi> int-e: no, I don't think so.
13:10:53 <ndm_> svref: [a-z][_'0-9a-zA-Z], pretty much
13:11:22 <svref> ndm_: but also all kinds of swearing, like (!!) and (&&)...that's what I'm interested in
13:11:30 <psi> CGI is a monad
13:11:37 <ndm_> svref: those are operators, different from the normal strings
13:12:12 <ndm_> svref: any swear character you can think of pretty much
13:12:43 <ndm_> svref: apart from @
13:13:15 <svref> ndm_ but I can't mix swearing with civil conversation in the same identifier, can I?
13:13:26 <svref> e.g. m&& can't be an operator
13:13:31 <ndm_> svref: no
13:13:40 <svref> &m&?
13:13:57 <ndm_> svref: no, swear or don't, nothing in btween
13:14:05 <svref> &^(*!(*
13:14:10 <svref> heh
13:14:18 <ndm_> ()[]{} are not valid swear characters
13:14:26 <ndm_> and ,
13:14:33 <ndm_> and ;
13:14:39 <svref> $%^*&!!
13:14:40 <ndm_> and @
13:14:43 <int-e> #$%^&*-+=<>: are valid
13:14:44 <ndm_> that however is
13:14:52 <ndm_> int-e: |
13:15:06 <int-e> / too
13:15:14 <ndm_> \ as well
13:15:22 <roconnor> > 16 + 8 + 2 - 32
13:15:22 <int-e> > let (?) = 1 in (?)
13:15:23 <lambdabot>  -6
13:15:24 <lambdabot>  1
13:15:27 <int-e> ?!
13:15:28 <lambdabot> Maybe you meant: . v
13:15:59 <int-e> the list is long actually. '.' is still missing.
13:16:08 <ndm_> hoogle has a list in it
13:16:15 <ndm_> which i got out of the Haskell report
13:16:49 <int-e> but \ ?
13:16:56 <int-e> oh, right.
13:16:58 <ndm_> @index \\
13:16:58 <lambdabot> bzzt
13:17:02 <ndm_> @index (\\)
13:17:03 <lambdabot> bzzt
13:17:06 <ndm_> @hoogle \\
13:17:06 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
13:17:09 <ndm_> @hoogle \\\\
13:17:10 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\\\'
13:17:21 <ndm_> of course, hoogle messes it up, but Data.List.\\
13:17:25 <int-e> > let a /\ b = a && b in True /\ False
13:17:27 <lambdabot>  False
13:17:30 <ndm_> @type (Data.List.\\)
13:17:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:17:39 <svref> its so cute when lambdabot says 'bzzt'.
13:17:49 <mnvl> how do you test if at least one element of a list is true?
13:17:55 <ndm_> or
13:18:18 <ndm_> @type or
13:18:20 <lambdabot> [Bool] -> Bool
13:18:20 <glguy> mnvl: ndm_ is telling you "or"
13:18:21 <glguy> :)
13:18:40 <mnvl> thx
13:18:45 <int-e> @type any id
13:18:46 <lambdabot> [Bool] -> Bool
13:28:10 <jajs> hello, is there a way to change an unique field in a record ? like ocaml's syntaxe { foo with field = value } ?
13:28:29 <int-e> foo { field = value }
13:28:52 <jajs> int-e, thanks...
13:31:13 <ACSpike> I seem to meet "Couldn't match `Char' against `String'" quite often and I'm still not sure of the fix
13:31:37 <int-e> @type ('a', "a")
13:31:38 <lambdabot> (Char, [Char])
13:31:38 <glguy> A String is a list of Chars
13:32:47 <mauke> the fix is figuring out if you need a Char or a list of Chars
13:33:00 <ACSpike> the whole message http://rafb.net/paste/results/IHwWyz92.html
13:34:58 <int-e> map show ...  creates a list of strings. putStrLn wants one string.
13:35:12 <mnvl> does anybody have ghc set up on solaris who could compile something for me?
13:35:54 <int-e> depending on what you want, you can use  concatMap  instead of map or  mapM_ putStrLn  instead of  putStrLn .
13:35:58 <ACSpike> int-e: the source http://rafb.net/paste/results/obgD5767.html
13:36:23 <ACSpike> argh, nevermind
13:36:41 <mauke> @index iterate
13:36:41 <lambdabot> Data.List, Prelude
13:37:13 <int-e> unlines should work, too, right.
13:37:25 <ACSpike> yeah, it works
13:37:47 <ACSpike> I just don't know which way is up
13:38:55 <glguy> ^
13:38:56 <glguy> |
13:39:12 <ACSpike> maybe
13:39:16 <int-e> glguy: that's making assumptions about how it's displayed ;)
13:39:33 <glguy> int-e: yup
13:43:49 <[I]nfecT> `div` operation rounds of the lowest integer?
13:45:03 <dolio> > (-1) `div` 3
13:45:05 <lambdabot>  -1
13:45:39 <dolio> Seems so.
13:45:54 <Patterner> > (-2) `div` 3
13:45:56 <lambdabot>  -1
13:46:10 <dolio> > (-1) `quot` 3
13:46:11 <lambdabot>  0
13:46:39 <[I]nfecT> shit
13:46:39 <[I]nfecT> lol
13:46:47 <Patterner> > 0 `div` 0
13:46:48 <lambdabot>  Exception: divide by zero
13:46:57 <[I]nfecT> i need the div to be exact :\ is there a function that does that?
13:47:19 <mauke> yes, %
13:47:24 <[I]nfecT> thats modulo
13:47:26 <mauke> no
13:47:28 <SamB> ndm_: there should be some kind of automated test that Yhc Core has valid Haskell syntax...
13:47:31 <[I]nfecT> ah
13:47:35 <[I]nfecT> `div` returns how many times the first number can be divided by the second one
13:47:37 <[I]nfecT> ah k
13:47:38 <psnl> [I]nfecT: > 10/34
13:47:42 <psnl> damn
13:47:47 <psnl> > 10/34
13:47:48 <ndm_> SamB, alas, there would be if it was valid Haskell98, but its not
13:47:48 <lambdabot>  0.29411764705882354
13:47:51 <mauke> > 10 % 34
13:47:53 <lambdabot>  5%17
13:47:55 <ndm_> SamB, although i am working on it...
13:48:00 <SamB> ndm_: what prevents it from being valid?
13:48:04 <glguy> ?scheck (\x y -> y == 0 || x `div` y == truncate (fromIntegral x / fromIntegral y)) :: Int -> Int -> Bool
13:48:06 <lambdabot>   Failed test no. 4. Test values follow.: -1, 2
13:48:11 <SamB> syntactically?
13:48:19 <glguy> ?scheck (\x y -> y == 0 || x `div` y == floor (fromIntegral x / fromIntegral y)) :: Int -> Int -> Bool
13:48:20 <lambdabot>  Completed 100 test(s) without failure.
13:48:29 <ndm_> SamB, the dictionary transformation on monads (and higher kinded types) requires rank2 types, which can't be infered
13:48:44 <dolio> ?type (%)
13:48:46 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
13:48:50 <ndm_> SamB, syntactically its not, but its pretty close and could be made so quite easily
13:49:40 <SamB> ndm_: so write the test *now* and fix it *after*
13:49:49 <ndm_> SamB, how do you fix that?
13:50:01 <SamB> hmm?
13:50:24 <ndm_> SamB, it requires types to be taken through the copmiler, and support for rank-2 types at all levels
13:50:34 <SamB> I said syntactically!
13:50:41 <ndm_> ah, well it used to be
13:50:50 <ndm_> turns out its not as useful as i thought
13:50:55 <SamB> well.
13:51:01 <SamB> it would at least keep it from breaking!
13:51:02 <ndm_> and it makes name resolution for modules that use Yhc.Core much harder
13:51:13 <SamB> oh?
13:51:14 <ndm_> i will write some Yhc.Core tests
13:51:34 <ndm_> its all to do with module names being in the names, i.e. on the lhs
13:51:40 <ndm_> i.e. Prelude.map f x = ...
13:51:47 <ndm_> while in Haskell the Prelude. gets dropped
13:51:52 <SamB> ah
13:52:10 <ndm_> in due time i'll move Yhc -O into Yhc, then have the tests incorporate all this stuff, but will be a while
13:52:13 <SamB> its not required except for non-names
13:52:44 <SamB> that is, except for tuples and lists, you could say Prelude.this, Prelude.that...
13:52:55 <SamB> and functions
13:53:09 <ndm_> hmm, not sure what you mean
13:53:21 <SamB> oh, wait.
13:53:25 <SamB> not in definitions...
13:53:28 <ndm_> there are also dictionaries, which get names like Prelude.Prelude.Show.Nat.Show
13:53:28 <SamB> hehe
13:53:44 <ndm_> and which need some name encoding to make them haskell 98, and i'd rather not do the encoding unless i have to
13:54:01 <SamB> that name isn't necessarily unique...
13:54:08 <svref> Can someone tell me why my Monad thinking is stupid and newbieish?: http://osaurus.us/~dm/tmp/Pipe.hs
13:54:11 <ndm_> it is, because of some way its generated
13:54:23 <SamB> well than why does it have to be so long?
13:54:28 <ndm_> no idea :)
13:54:31 <SamB> GHC uses much shorter ones...
13:54:55 <ndm_> yes, but thats how Yhc does it, and i've no idea why, so its dangerous to change until the code is rewritten properly
13:55:03 <SamB> mmm
13:55:05 <SamB> point
13:55:15 <mauke> svref: that looks like Functor/fmap
13:55:27 <mauke> > fmap negate (Just 42)
13:55:29 <lambdabot>  Just (-42)
13:55:33 <ndm_> oh, there is also the 1 element tuple, which has no Haskell syntax
13:55:44 <ndm_> that is particularly annoying!
13:55:46 <svref> > fmap negate [1..3]
13:55:47 <lambdabot>  [-1,-2,-3]
13:56:15 <mauke> for monads, fmap == liftM
13:56:33 <svref> what is liftM again?
13:56:34 <SamB> whats it for!
13:56:40 <dolio> ?type flip liftM
13:56:42 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
13:57:01 <mauke> liftM f mx = do { x <- mx; return (f x) }
13:57:12 <roconnor> Igloo: hmm, I have an 88 pt solution for clearreg
13:57:20 <mauke> @undo do { x <- mx; return (f x) }
13:57:21 <lambdabot> mx >>= \ x -> return (f x)
13:57:41 <mauke> @. pl undo do { x <- mx; return (f x) }
13:57:41 <lambdabot> f `fmap` mx
13:57:44 <mauke> haha
13:57:48 <SamB> ndm_: speaking of tuples, do you have any idea why someone would try to pass an Id in for the arity of a tuple constructor token?
13:57:53 <ndm_> SamB dictionary transformations
13:58:04 <SamB> oh
13:58:11 <SamB> should use records instead!
13:58:15 <ndm_> SamB, because they are crazy...
13:58:36 <ndm_> no, the dictionary transformation is best to used tuples, since records have to be desugared anyway
13:59:13 <SamB> oh, yeah, your Core has no types anyway so it wouldn't make much much more readable...
13:59:28 <ndm_> indeed
13:59:41 <ndm_> i would love for Core to have types, but its not possible at the moment
13:59:47 <SamB> why?
14:00:15 <ndm_> because the types are thrown away too early
14:00:22 <SamB> heh
14:00:27 <SamB> way to state the obvious!
14:00:32 <glguy> "My uncle, Jamal, say he is tri-sexual. He will try anything sexual."
14:01:02 <ndm_> the typechecker assigns types, but the transformations don't keep them
14:01:17 <SamB> mmm
14:01:31 <SamB> you'd need some kind of Core Lint, I suppose...
14:01:40 <ndm_> yep
14:01:42 <SamB> as well as a bunch of work to keep the types valid
14:01:43 <ndm_> and lots of clever typing stuff
14:01:48 <ndm_> yes, way too much work to do now
14:01:58 <ndm_> after we have a proper type checker, maybe one day we'll have it sorted
14:02:07 <SamB> I thought you had some particular reason or something ;-)
14:02:08 <ndm_> for now just wait for the future...
14:02:23 <ndm_> reason for what?
14:02:53 <SamB> why it was UNPOSSIBLE
14:03:21 <ndm_> not totally unpossible, just an awful lot of work!
14:03:30 <SamB> like, say, that the types needed type-system feature XYZ or something
14:03:31 <ndm_> like in the years, almost
14:03:39 <SamB> that would somehow be too hard
14:03:40 <ndm_> they need rank 2 types
14:04:27 <dolio> Heh: "we have added to our BugTrac system field where you should describe weather at the moment of bug - this will greatly simplify our debugging work"
14:04:48 <SamB> hmm. what is with this Yhc.Core.Show?
14:05:06 <ndm_> thats just the show instances
14:05:08 <SamB> it looks like either an uglyprinter or an inefficient prettyprinter...
14:05:22 <SamB> the code is definately not pretty
14:05:25 <ndm_> probably both, i don't know how to do pretty printing using proper combinator
14:05:38 <ndm_> its on my list of things to learn...
14:05:43 <SamB> you are under the impression that it is somehow hard?
14:05:58 <ndm_> it requires me to 1) pick a library, 2) learn it
14:06:25 <ndm_> it really is on my todo list, just not got to it yet
14:06:30 <SamB> use the one that comes with the libraries?
14:06:32 <ndm_> feel free to fix Yhc.Core.Show
14:06:34 <dolio> There are so many more papers on haskell parser combinators than pretty printing combinators.
14:06:48 <ndm_> i will do it eventually though
14:06:57 <dolio> Makes it more difficult to learn the latter. :)
14:07:02 <SamB> @hoogle SDoc
14:07:03 <lambdabot> No matches found
14:07:05 <SamB> @hoogle Doc
14:07:06 <lambdabot> Text.PrettyPrint.HughesPJ.Doc :: data Doc
14:07:06 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
14:07:06 <lambdabot> Language.Haskell.TH.PprLib.to_HPJ_Doc :: Doc -> Doc
14:07:06 <ndm_> i have a similar language in my Phd, which needs a proper thingy
14:07:22 <SamB> @docs Language.Haskell.TH.PprLib.Doc
14:07:23 <lambdabot> Language.Haskell.TH.PprLib.Doc not available
14:07:28 <SamB> @docs Language.Haskell.TH.PprLib
14:07:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-PprLib.html
14:07:32 <SamB> wait...
14:07:34 <SamB> wrong one
14:07:46 * SamB wishes hoogle had ModuleRank technology...
14:07:57 <SamB> @hoogle Pretty
14:07:58 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
14:07:58 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
14:08:02 <SamB> @hoogle Pretty Doc
14:08:03 <lambdabot> No matches, try a more general search
14:08:20 <SamB> @google site:http://haskell.org/ghc/docs/latest/html/libraries pretty doc
14:08:23 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index-Z.html
14:08:27 <SamB> erg
14:08:33 <SamB> @google site:http://haskell.org/ghc/docs/latest/html/libraries pretty hsep
14:08:34 <lambdabot> No Result Found.
14:08:39 <ndm_> SamB, someone previously mentioned adding that, if someone gives me a module ranking, i'll add it :)
14:09:01 <SamB> ndm_: it should use the import statements in popular Haskell programs!
14:09:26 <shapr> @yow !
14:09:27 <lambdabot> DON'T go!!  I'm not HOWARD COSELL!!  I know POLISH JOKES ... WAIT!!
14:09:27 <lambdabot> Don't go!!  I AM Howard Cosell! ... And I DON'T know Polish jokes!!
14:09:39 <ndm_> SamB, yes, i considered that, i might well - although that might give silly results, since a relatively small sample
14:09:41 <SamB> @hoogle hughespj
14:09:41 <lambdabot> Text.PrettyPrint.HughesPJ :: module
14:09:48 <SamB> okay, thats the one
14:09:54 <SamB> @doc Text.PrettyPrint.HughesPJ
14:09:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
14:10:01 <SamB> read THAT ;-)
14:10:27 <ndm_> does it have support for indentation grouping stuff?
14:10:59 <SamB> you mean like hang?
14:11:12 <SamB> > hang 4 (text "Hi!")
14:11:13 <lambdabot>  Not in scope: `text'
14:11:15 <SamB> hmm.
14:11:27 <SamB> not in scope I guess...
14:11:39 <ndm_> yes, i guess thats what i want
14:13:02 <SamB> oh, sorry, I meant nest I think
14:13:43 <SamB> Prelude Text.PrettyPrint.HughesPJ> nest 4 (text "Hi!")
14:13:43 <SamB>     Hi!
14:13:56 <ndm_> cool, ok will have a look at the tomorrow
14:14:00 <SamB> anyway, those are basically the same combinators GHC uses
14:14:09 <ndm_> i realise my output looks crap, and is complex :)
14:14:16 <SamB> hence the PJ
14:14:21 <SamB> I didn't even look at the output yet!
14:14:25 <ndm_> yeah, i knew :)
14:14:36 <ndm_> the output is reasonable, but sometimes "goes a bit wrong"
14:14:59 <ndm_> ideally i'd want to flip between case x of {a;b;c} and case x of idented, as appropriate
14:15:04 <ndm_> but i guess thats beyond that
14:15:53 <SamB> yeah
14:16:13 <SamB> for some reason that is *NOT* a feature of any of the libraries I've seen...
14:16:44 <ndm_> hmm, ah well
14:16:56 <SamB> just go for indented and email libraries@ about it?
14:17:03 <ndm_> yep
14:17:13 <ndm_> or just go for indented and get over it
14:18:00 <dolio> It's probably possible. A fair part of that paper was about recognizing when breaking up lines was appropriate.
14:18:12 <SamB> I think you should email the libraries@ list
14:18:44 <SamB> you can say that I also thought it would be good when I was looking at Pugs' Haskell output...
14:19:11 <SamB> who knows, maybe you *can* do it with that library and I somehow missed the way?
14:24:49 <ndm_> i'll read the paper tomorrow, and see what it says, see if there is anything
14:27:51 <dolio> Seems like you'd need Doc -> Doc -> Doc which chooses either the first or second argument, as appropriate.
14:27:55 <dolio> But I don't see that in there.
14:28:57 <ThreeQ> ?type flip fmap
14:28:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
14:37:12 <dcoutts> araujo, you're supposed to be reccommending using glade with gtk2hs! :-)
14:38:42 <ThreeQ> why do you have to wrap monads for them to be instances of Applicative?
14:47:11 <SamB> @instances-importing Control.Monad.Applicative Applicative
14:47:12 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:47:25 <SamB> @hoogle Applicative
14:47:26 <lambdabot> No matches found
14:47:29 <glguy> lambdabot isn't runninga recent enough GHC for Applicative
14:47:33 <SamB> oh
14:47:39 <SamB> @stats
14:47:45 <SamB> @uptime
14:47:48 <lambdabot> Unknown command, try @list
14:47:48 <lambdabot> uptime: 2d 23h 54m 16s, longest uptime: 6d 15h 1m 36s
14:47:51 <glguy> ThreeQ: for the same reason that Monads must explicitly also be instances of Functor
14:48:02 <SamB> lambdabot: you are without excuse!
14:49:18 <ThreeQ> glguy: that's because of overlapping instances, right?
14:51:48 <glguy> ThreeQ: I don't know the exact reason
14:51:57 <glguy> I just know its the same reason :)
14:52:01 <ThreeQ> :)
14:52:31 <mnvl> what does fmap do
14:52:33 <int-e> The restriction that the instance must have an outermost type constructor has to do with decidability.
14:52:58 <glguy> mnvl: fmap is a generalized map
14:53:15 <glguy> mnvl: it applies a function to every element in a container
14:53:34 <glguy> > fmap (*2) [1..4]
14:53:35 <lambdabot>  [2,4,6,8]
14:53:41 <glguy> > fmap (*2) (Just 3)
14:53:42 <lambdabot>  Just 6
14:53:49 <int-e> @instances ()
14:53:51 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:55:23 <mnvl> thx boss
14:56:00 <ThreeQ> if I remember correctly, it's because if you have "instance Monad m => Functor m where ...", and then try to instance Functor for some specific monad, there will be two separate instances for that monad
14:57:12 <ThreeQ> and it can't figure out which one to use
14:57:13 <SamB> also H98 doesn't like the former at *all*
14:57:13 <int-e> that's the other reason, it's both undecidable and leads to overlapping instances.
14:57:38 <SamB> oh, int-e said that already huh?
14:57:50 <ThreeQ> what does undecidable mean?
14:57:58 <SamB> it can't decide
14:58:03 <ThreeQ> ha
14:58:07 <int-e> that you can't prove that the typechecker always terminates, basically.
14:58:13 <SamB> because there is no terminating decision algorithm
14:58:32 <greenrd> How do I use the Text.Regex.Posix high-level API?
14:58:48 <SamB> basically it means you can make the typechecker run a Turing Machine...
14:59:01 <greenrd> I don't understand the constraints on (=~) , they're too complicated
14:59:13 <SamB> @hoogle =~
14:59:13 <greenrd> and the API documentation is not much help
14:59:14 <lambdabot> No matches found
14:59:20 <SamB> @hoogle (=~)
14:59:21 <lambdabot> Did you mean: (=~)
14:59:21 <lambdabot> Prelude.undefined :: a
14:59:21 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:59:41 <greenrd> Is hoogle updated for the ghc 6.6 APIs?
14:59:47 <SamB> ndm_: what in the world does it ask me if I meant what I said and then go on to tell me about totally unrelated things for?
14:59:51 <ndm_> greenrd: no
15:00:30 <ndm_> SamB, it interprets it as a type (which makes it kind of weird), and tries to suggest something better
15:00:33 <glguy> Are the new library function in GHC 6.6 going to become part of the standard Haskell libraries?
15:00:46 <glguy> or are they designed as GHC specific
15:00:50 <SamB> ndm_: why does it suggest the exact same thing?
15:00:51 <ndm_> it noticed you didn't use any capital letters, so tried to suggest something
15:01:03 <ndm_> of course, when it gets confused, that all goes wrong...
15:01:04 <SamB> and doesn't it know that infix types start with :?
15:01:39 <ndm_> i have no idea what it knows and what it doesn't...
15:01:47 <ndm_> Hoogle 4 already has that bug fixed
15:01:54 <SamB> ndm_: also, how am I supposed to get ycr files?
15:02:15 <ndm_> SamB, yhc -corep , or build the libraries with scons core=1
15:02:23 <SamB> ahhh
15:02:29 <SamB> is that documented somewhere?
15:02:35 <ndm_> probably not...
15:02:49 <ndm_> i have an intention to tidy up the Core library stuff at some point soon, split it into a proper library
15:02:56 <SamB> uh huh
15:03:01 <ndm_> and the documentation is a series of blog posts, so needs redoing
15:03:17 <SamB> I'll say!
15:03:30 <SamB> series' of blog posts are not the best form of documentation!
15:03:36 <ndm_> i know :)
15:03:42 <dcoutts> though it's fun to follow that way :-)
15:03:46 <SamB> slightly better than commit messages
15:03:51 <ndm_> i'm the main user at hte mo, hence all the info is in my head, exactly where its needed!
15:03:58 <SamB> yeah ;-)
15:03:58 <ndm_> but definately needs cleaning up a bit
15:07:37 <shapr> d00d
15:11:08 <SamB> d00d what?
15:12:08 <astrolabe> d00d d00d
15:21:56 <hyrax42> ?docs Data.Sequence
15:21:57 <lambdabot> Data.Sequence not available
15:22:13 <hyrax42> lies
15:22:15 <hyrax42> lies!
15:25:30 <SamB> is there some kind of a tutorial on debugging the simplifier?
15:26:23 <araujo> dcoutts, hahaha
15:26:34 * dcoutts grins
15:27:50 <hyrax42> woah 6.6 brought quite a bit
15:28:21 <mnvl> how do you find out if a given edge belongs to a Graph?
15:28:32 <hyrax42> ?docs Data.Graph
15:28:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Graph.html
15:28:45 <mnvl> yeah but i don't see it there
15:28:56 <hyrax42> (`elem` (edges gr)) would work, though not ideal
15:29:08 <hyrax42> (wasn't doing it for your benefit, but for mine!)
15:29:14 <mnvl> oh, k
15:29:46 <hyrax42> hm
15:29:51 <hyrax42> looks like the elem thing is al you can do
15:30:13 <hyrax42> gah!
15:30:16 <hyrax42> I just reinvented a wheel
15:30:31 * hyrax42 just wrote a basic Data.Tree
15:31:22 <mnvl> ok thanx
15:31:50 <hyrax42> hm or not
15:31:59 <hyrax42> lacks a mapTree among others :?
15:33:05 <LiquidEngineer> 6.6 is out?
15:33:16 <hyrax42> LiquidEngineer: yup
15:33:23 <LiquidEngineer> wow
15:33:27 <hyrax42> hmm maybe Traversable does the map thing
15:33:30 * hyrax42 goes to read new docs
15:33:31 <LiquidEngineer> Mac binary?
15:34:30 <hyrax42> ?index pure
15:34:30 <lambdabot> Control.Arrow
15:34:50 <hyrax42> LiquidEngineer: dunno
15:34:59 <hyrax42> someone yesterday said they had one for PPC
15:35:07 <nick8325> hyrax42: Tree is an instance of Functor, so fmap will work
15:35:18 <hyrax42> nick8325: ah you are magic
15:35:20 <hyrax42> thanks!
15:35:35 <LiquidEngineer> Oooh!
15:35:40 <LiquidEngineer> There is a mac binary distro
15:36:02 <hyrax42> why
15:36:09 <hyrax42> don't feel liek waiting 8 hours to build?
15:36:13 * LiquidEngineer has seen OS projects that have binary windows but no binary mac distrubtions because of a lack of interest.
15:36:17 <hyrax42> whyever not?
15:36:19 <LiquidEngineer> My computer is old
15:36:28 <hyrax42> ;)
15:36:37 <LiquidEngineer> 867 MHz G4
15:36:41 <hyrax42> hehe
15:36:44 <hyrax42> 1.33 here
15:36:46 <hyrax42> ZOOOM
15:36:49 <LiquidEngineer> It literally took overnight to compile and then didn't work
15:36:54 <hyrax42> I had that happen once
15:37:06 <LiquidEngineer> once I get a new macbook I'll do everything off fink
15:37:08 <hyrax42> but the working version was still there (I use darwinports)
15:37:10 <hyrax42> so I just reverted
15:37:27 <LiquidEngineer> I *was* using darwin ports
15:37:33 <LiquidEngineer> it failed on me the first time I tried to install
15:37:38 <hyrax42> yeah, but there was a dud version at some point
15:37:39 <LiquidEngineer> so I was like "screw this, binary time."
15:37:47 <LiquidEngineer> 6.4.2
15:37:52 <hyrax42> _something
15:38:39 <hyrax42> my active version is 6.4.2_2+darwin_8
15:38:48 <hyrax42> I have 4 inactive versions installed... great
15:41:01 <LiquidEngineer> ah
15:43:47 <SamB> ndm_: were the .ycr files supposed to be human readable?
15:44:19 <ndm_> SamB, no way! they used to be at one point, now they are binary
15:44:25 <SamB> oh.
15:44:35 <LiquidEngineer> OMG.
15:44:39 <LiquidEngineer> Tab completes.
15:44:49 <LiquidEngineer> Who implemented that, and are they married?
15:44:51 <hyrax42> ?
15:44:58 <hyrax42> oh in ghci?
15:45:00 <SamB> ndm_: what are these for again?
15:45:06 <LiquidEngineer> hyrax42: yes
15:45:10 <hyrax42> woiw
15:45:13 <hyrax42> noice
15:45:28 <LiquidEngineer> You can't marry them.  I called dibs.
15:45:59 <ndm_> SamB, they are the Yhc Core file in binary, which can be read by the Yhc.Core API
15:46:20 <SamB> what is the point of them being in binary though?
15:46:22 <ndm_> SamB, have updated all the documentation http://haskell.org/haskellwiki/Yhc/API/Core
15:46:24 <lambdabot> Title: Yhc/API/Core - HaskellWiki
15:46:30 <ndm_> SamB, faster to read/write by 50 times
15:46:48 <ndm_> much smaller as well
15:46:48 <SamB> so?
15:47:00 <ndm_> why make them textual?
15:47:11 <SamB> well. if they are much smaller...
15:47:22 <ndm_> my program used to take a minute, now it takes 2 seconds, i want binary files!
15:47:35 <SamB> okay, okay
15:47:40 <SamB> you have a point, I suppose
15:47:48 <SamB> except what does your program use to parse?
15:48:02 <ndm_> I'm happy for there to be a concrete syntax, and a translator to/from binary
15:48:12 <ndm_> Yhc parses the intiial haskell, then its binary all the way
15:49:07 <SamB> if it is in binary why do you care if there are spaces in identifiers?
15:50:04 <ndm_> because the pretty printer looks really weird
15:50:24 <ndm_> and it makes the Core substantially less Haskell like, which is the aim we are working towards
15:50:29 <SamB> hmm
15:51:25 <dcoutts> ndm_, did you see the Q about foldl/foldr on the haskell list today? could Dr Haskell make informed suggestions about when it's better to use foldl vs. foldl' vs. foldr ?
15:51:52 <ndm_> dcoutts: i thought about that, doesn't the decision depend in part on the type?
15:52:01 <dcoutts> the first level heuriistic is that if you're generating a list then foldr might be more appropriate and if you're making an Int then foldl' is probably better
15:52:21 <dcoutts> ndm_, yes, it depends on the strictness of the type
15:52:28 <ndm_> dcoutts: dr haskell lacks type info :(
15:52:37 <dcoutts> strictness of the constructers in the type
15:52:39 <SamB> hmm.
15:52:42 <dcoutts> ndm, oh, that's a shame
15:52:56 <hyrax42> ndm: are you the main yhc guy or?
15:53:05 <ndm> hyrax42, i am one of the Yhc guys
15:53:13 <hyrax42> are you at York?
15:53:26 <dcoutts> hyrax42, he's the loudest cheerleader ;-)
15:53:28 <SamB> ndm: have you got a test for core output being parseable yet?
15:53:29 <ndm> i own certain bits of it, including Press & Publicity, hence i appear more important in Yhc than I am :)
15:53:40 <ndm> hyrax42, yep, at York
15:53:51 <hyrax42> ey oop :p
15:53:53 <ndm> SamB, you mean by a Haskell interpretter?
15:54:11 <SamB> ndm: I meant whether the stuff Yhc writes can be read and pretty-printed ;-P
15:54:27 <ndm> SamB, the pretty printed stuff probably can't be read in
15:54:32 <SamB> no, no
15:54:39 <SamB> whether the .ycr files will parse
15:54:49 <ndm> they are binary, so yes, they parse with the binary parser
15:54:57 <SamB> oh yeah?
15:55:08 <ndm> it uses derived binary instances, so read/write is a property we get for free
15:55:13 <SamB> oh wait
15:55:25 <ndm> i use a version of Drift and Binary
15:55:37 <SamB> these command invocations should be put in boxes...
15:55:47 <SamB> it would be easier to read them that way.
15:56:31 <SamB> or at least in whatever you use instead of boxes on haskellwiki
15:56:52 <ndm> feel free to edit to whatever is easiest to read
15:58:00 * beelsebob licks Ndm
15:58:25 * ndm gets scared
15:58:36 * ndm or prays for a k vs l typo
15:58:58 <beelsebob> lol
15:59:37 <ndm> beelsebob: any progress on the hat-delta API?
16:00:01 <beelsebob> ndm: no, I've got to get the RDT working, and there's actually several implementation problems we hadn't expected
16:00:19 <beelsebob> I'm making it make nice indexes of the file
16:01:09 <ndm> ok, fair enough - it will be a while before i get to hat stuff anyway
16:01:18 <beelsebob> heh
16:14:45 <emk> You know, I really like monads. The more I mess with them, the more I'm convinced they're the Right Thing for a large class of problems.
16:16:07 <astrolabe> I don't like the way IO tends to leak into alot of my code when I take the path of least resistance.
16:19:46 <araujo> monads rulez!
16:20:06 <hyrax42> > succ 'a'
16:20:08 <lambdabot>  'b'
16:20:55 <int-e> astrolabe: hah, maybe IO should have a longer name, like ThinkTwiceBeforeYouUseIO
16:20:59 <Cale> astrolabe: then you're not really taking the path of least resistance :)
16:21:36 <Cale> The easiest way to write things is usually to get the I/O over with as quickly as possible, and push all the work into pure code.
16:21:53 <Cale> But I suppose it does depend on what you're writing
16:24:30 <araujo> Don't use the monad ... Become the monad
16:25:21 <astrolabe> hmmm I might well be doing it badly.
16:26:40 <astrolabe> I've decided I need to add logging for diagnostics to some of my code, and it's going to change a lot of functions' types.
16:26:52 <araujo> Cale, i usually find easier to get the pure code done first.
16:27:03 <Cale> araujo: right
16:27:17 <Cale> I really just mean that the I/O part should be small
16:27:47 <sieni> a monad is actually just a thread on steroids
16:27:48 <Cale> astrolabe: hmm... you might also try to separate the code into parts where you might want to log things
16:27:58 <sieni> or at least that's how I think about it
16:28:10 <astrolabe> cale: how do you mean?
16:28:29 <sieni> nighty nite
16:28:31 <Cale> Well, it depends on what you're logging
16:28:39 <ThreeQ> astrolabe: you could use a writer monad
16:28:59 <astrolabe> ThreeQ: I was considering that, but it might change a lot of my code.
16:29:14 <Cale> if it's the progress of some pure computation, then you could separate the computation into stages, and capture the results after each
16:30:41 <astrolabe> Cale you mean a string of functions composed together?  I'm not sure whether it natuarally has that form.
16:30:56 <Cale> yeah
16:31:39 <astrolabe> part of it at least is a map, and I'll want to see what is going on inside the mapped function.
16:32:54 <hyrax42> ?type Debug.trace
16:32:55 <lambdabot> Couldn't find qualified module.
16:33:05 <hyrax42> ?hoogle trace
16:33:06 <lambdabot> Debug.Trace.trace :: String -> a -> a
16:33:06 <lambdabot> Debug.Trace :: module
16:33:06 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
16:33:17 <hyrax42> hm
16:33:28 <Cale> you also have to be aware that by logging things, you can sometimes change the performance properties of your code
16:33:37 <hyrax42> :/
16:33:48 <Cale> because you might force some things to be evaluated earlier than they're really needed in order to log them
16:34:20 <astrolabe> Cale: true.  I was hoping I could calculate a string, and then if I don't use it the compiler might be able to optimise it away?
16:34:22 <Cale> Yeah, there is Debug.Trace if you're just debugging things :)
16:34:39 <Cale> astrolabe: if you don't need it, the runtime will optimise it away even
16:34:52 <Cale> Since things are only computed based on demand
16:35:06 <astrolabe> The reason I'm doing it is because I've put trace into my code and removed it a dozen times.  I thought I might as well do something permanent.
16:35:59 <Cale> hmm, yeah, you might also define your own trace function and just swap it out for the identity function based on whether you're debugging :)
16:36:13 <Taral> I just called part of my C parser "abomination_unto_God".
16:36:19 <astrolabe> That's a thought.
16:36:20 <Taral> Can anyone imagine why?
16:36:50 <astrolabe> Did it work on the sabbath?
16:37:35 <Taral> No, that's merely a minor sin.
16:40:53 <lennart> astrolabe: Is your tracing just there for debugging?
16:40:57 <int-e> hmm, abominations in C. digraphs, trigraphs, and the fact that case labels aren't restricted to the outermost level of a switch block. hmm.
16:41:28 <SamB> int-e: heh
16:41:34 <SamB> you totally forgot to mention GOTO
16:41:37 <Taral> The first two are preprocessor issues, thankfully, and the second comes in handy.
16:41:39 <Taral> er, third.
16:41:43 <Taral> No, it's this syntax:
16:41:45 <int-e> goto is occasionally useful.
16:41:57 <Taral> void f(double a[restrict static 3][5]);
16:42:03 <SamB> well, those case label things are on the same level...
16:42:11 <int-e> I know Duff's device is also occasionally useful.
16:42:42 <Taral> or... double a[n][n*m+300]
16:42:49 <Taral> but that's not as bad as...
16:42:59 <Taral> double a[restrict *]
16:43:00 <Taral> WTF?
16:43:13 <int-e> restrict?!
16:43:16 <Taral> Yes.
16:43:25 <Taral> This is ISO/IEC 9899:TC2, a.k.a. C99+
16:43:34 <astrolabe> lennart: The program calculates the probabilities of a set of possibilities using a quite complicated expression.  It gives counter-intuitive answers sometimes, and I keep thinking the program has a bug when it doesn't.  So I thought I should create a file I could look at to help me decide why it is saying what it is saying.  Not necessarily debugging as such.
16:43:34 <Taral> (C99, 2005 update)
16:43:35 <lennart> Taral: is a[restrict static 3] legal?
16:43:37 <Taral> yes.
16:43:48 <SamB> WTF!
16:43:49 <Taral> I'm quoting from the standard here!
16:43:50 <int-e> 6.7.3.1 somewhere *reading*
16:43:57 <Taral> No, 6.7.5 now
16:43:59 <Taral> Declarators
16:44:08 <int-e> 6.7.3.1  Formal definition of restrict
16:44:16 <Taral> oh, that's not where this shows up though
16:44:17 <int-e> (hmm, ok the numbering can be off)
16:44:23 <Taral> 6.7.5 Declarators
16:44:51 <Taral> 6.7.5.3 footnote 21 page 121
16:45:01 <lennart> astrolabe: Sounds a bit like debugging.  I'd probably use something like Debug.trace and a Bool to turn it on/off.
16:45:29 <Taral> Ugh.
16:45:33 <Taral> "t f(t (t));
16:45:34 <astrolabe> lennart: and not worry about the impurity?
16:45:34 <Taral> "
16:46:22 <hyrax42> haha
16:46:24 <Taral> anyway, I finally ended up writing:
16:46:25 <Taral> declarator_suffix = parens parameter_types <|> brackets abomination_unto_God
16:46:28 <Taral> and having done with
16:46:51 <hyrax42> real lambdas in code
16:46:53 <hyrax42> that's great
16:48:19 <lennart> astrolabe: When "debugging", i.e., creating output that isn't the real purpose of the computation, I don't worry too much. :)
16:48:33 <astrolabe> lennart: thanks
16:49:13 <lennart> astrolabe: But you can never tell anyone I said that. ;)
16:49:29 <astrolabe> Your secret is safe with #haskell
16:51:38 <SamB> is it really?
16:51:50 <SamB> I think cmeme doesn't know that!
16:51:57 <astrolabe> Why aren't there separate monads for I and O?
16:52:38 <astrolabe> SamB: :)
16:53:03 <SamB> astrolabe: um, because, um, the world!
16:53:19 <SamB> there is no IWorld# and OWorld#!
16:53:25 <Cale> hm?
16:53:25 <SamB> only the RealWorld#!
16:53:31 <Cale> You could have them be separate
16:53:40 <astrolabe> But I might want to express the fact that I'm only writing to the world.
16:53:45 <Cale> and then liftings into the IO monad
16:54:03 <SamB> oh, well, I suppose you could
16:54:04 <Cale> The RealWorld# thing is just an implementation hack :)
16:54:20 <SamB> but it seems silly to me somehow...
16:54:22 <Cale> I don't think it's good to take it too seriously :)
16:54:29 <SamB> Cale: yes.
16:54:37 <SamB> that was a joke argument, sort of
16:56:01 <astrolabe> I suppose I could write my own
16:56:18 <Taral> AGGGGGGGGGG
16:56:25 <Taral> Abstract declarators are eating my brain!
16:56:31 <SamB> okay, so, why are <haskell> tags so lightly highlighted?
16:56:36 <SamB> on haskellwiki?
16:56:39 <SamB> does anyone know?
16:57:14 <int-e> Taral: that's a fun syntax, I wonder why I've never seen that.
16:57:38 <Taral> Because it's an abomination unto God.
16:58:08 <int-e> int x[volatile 43]  should be valid, too, then.
16:58:18 * Taral dies.
16:58:49 <int-e> I wonder if C++ has this feature, too.
16:59:01 <Taral> One has to be careful reading too much into the grammar.
16:59:05 <glguy> int-e, Taral: what are you guys referring to?
16:59:31 <int-e> ISO C.
16:59:39 <Taral> According to the grammar, you can write "int volatile short double restrict inline d;"
17:00:28 <Taral> I don't want to write this parser.
17:00:37 <Taral> But the c2hs parser has too many dependencies. :(
17:00:50 <Taral> And there are no other C parsers that I could find.
17:00:57 <dcoutts> I've found a few
17:01:02 <Taral> Where?
17:01:03 <int-e> you forgot static and extern I think?
17:01:07 * int-e chuckles.
17:01:18 * Taral bashes int-e over the head with an abstract declarator.
17:01:24 <dcoutts> look for Jim Roskind's C and C++ grammars
17:01:35 <dcoutts> I've been working on a Haskell port to happy
17:01:41 <Taral> dcoutts: Those have no semantic actions.
17:01:51 <dcoutts> Taral, yes
17:02:00 <Taral> I want:
17:02:11 <Taral> parseC :: String -> TranslationUnit
17:02:25 <dcoutts> Taral, have you looked at the c2hs parser
17:02:28 <dcoutts> it does this
17:02:30 <Taral> See above.
17:02:37 <int-e> . o O ( parseC _ = undefined "behaviour" )
17:02:39 <Taral> Although having attempted this, I might reconsider.
17:02:47 <SamB> "too many dependencies"?
17:02:56 <Taral> Yes, it didn't look easy to extract.
17:03:03 <SamB> oh
17:03:07 <SamB> that kind of dependencies
17:03:22 * glguy was looking through [I]...'s source code from the poker hand deal earlier and noticed lots of the equivalent of...
17:03:30 <glguy> do { a <- f; let b = a; ...
17:03:51 <dcoutts> Taral, the c2hs C parser is easy to extract
17:04:02 <dcoutts> well, fairly easy
17:04:12 <Taral> Well, like I said... I'm looking at it again.
17:04:16 <Taral> C parsers are obviously not easy.
17:04:18 <dcoutts> much easier than writing one from scratch
17:04:52 <dcoutts> I've been looking at improving the c2hs one, but it already can parse loads of real world code
17:04:58 <dcoutts> like all the gtk headers
17:05:40 <Taral> Yeah.
17:05:45 <Taral> Well, it's not headers I need... it's code.
17:05:55 <erider> who in here is a vim user?
17:06:05 <Taral> caduceus doesn't handle enough C for me
17:06:07 <Taral> erider: me
17:06:08 <dcoutts> Taral, same thing, since headers can contain code
17:06:16 <Taral> dcoutts: Okay, I'm looking again.
17:06:17 <glguy> vim ftw
17:06:19 <dcoutts> Taral, c2hs does whole translation units
17:06:26 <Taral> They depend on a lot of stuff in ../../base -- annoying
17:06:35 <erider> Taral: do you like it better then emacs
17:06:56 <Taral> erider: Yes.
17:07:15 <dcoutts> Taral, not that much, it can be pulled out. It's things like identifiers. You can change that to just String or something.
17:07:17 * dcoutts -> sleep
17:07:22 <Taral> URG
17:07:26 <Taral> parseC :: String -> Position -> CST s CHeader
17:07:30 <Taral> it all runs in some crazy monad
17:07:45 <dcoutts> Taral, yeah, and take out that monad too, it's not really used
17:08:03 <Taral> something about a name supply?
17:08:20 <dcoutts> that's for identifiers
17:08:26 <dcoutts> but again it's not necessary
17:08:44 <dcoutts> if you use soemthing else for identifiers
17:09:12 <dcoutts> it's currently using this atribute stuff which needs a name supply so it can tag each thing with a number for quicker lookups later
17:09:24 <Taral> Um... I don't have the source for CParser.hs?
17:09:36 <dcoutts> it's generated from CParser.y
17:09:47 <dcoutts> using happy, the parser generator
17:09:58 <dcoutts> and similarly CLexer.x using alex
17:10:04 <Taral> That's not in the tarball.
17:10:12 <dcoutts> @where happy
17:10:13 <lambdabot> http://www.haskell.org/happy/
17:10:16 <dcoutts> @where alex
17:10:16 <lambdabot> http://www.haskell.org/alex/
17:10:19 <Taral> yes yes
17:10:25 <Taral> but the .y file is not in the c2hs tarball.
17:10:35 <dcoutts> oh, well get it from darcs
17:10:50 <Taral> Yup.
17:10:56 <Taral> Still, tsk on them for skipping it.
17:11:02 <dcoutts> true
17:11:10 <dcoutts> right, sleep now.
17:11:12 <Taral> nini
17:11:14 <dcoutts> g'night folks
17:11:19 <dcoutts> good luck Taral :-)
17:11:32 <Taral> Thanks!
17:27:04 <emk> Literate Haskell embarasses me into writing very, very good code.
17:27:18 <Taral> LOL
17:27:25 <SamB> how?
17:27:29 <SamB> it is so ugly?
17:28:08 <emk> SamB: No. It's just that anything less than excellent code looks bad when typeset so nicely.
17:28:17 <SamB> oh ;-)
17:28:26 <Taral> emk: Do you write good documentation to go with the good code?
17:28:33 <SamB> you mean lhs2tex or something like that?
17:29:42 <emk> Taral: Well, I have a 3-page bibliography for a 20-page lhs2TeX document, so it's definitely documented. Whether the docs are good, I'm not the one to judge. :-)
17:29:54 <emk> SamB: Yeah, lhs2TeX produces some pretty nice output.
17:29:57 <Taral> emk: Any docs is better docs than mine :)
17:30:35 <int-e> hmm, misleading docs are worse than no docs at all.
17:30:42 <emk> Spaghetti Haskell is a truly scary experience, at least to this novice Haskeller...
17:31:25 <shapr> I've seen some. I read a suffix arrays paper written in Haskell...
17:31:44 <emk> I mean, 20-line functions are rude enough in Java/C++/Ruby/etc. It's terrifying to find them in higher-order Haskell code, with lots of single-character variable names and no comments.
17:32:44 <Botty> heh, 20-line functions aren't bad in imperative languages. in functional languages they are plain scary though
17:33:09 <kpreid> I've got a 45-line function here.
17:33:23 <kpreid> It's in do-notation, does that count as imperative language? :)
17:33:24 <emk> Oh, and trying to understand bad Haskell isn't truly fun without dubious combinators and an overripe monad or two.
17:33:39 <emk> kpreid:  How many levels of nesting?
17:34:02 <kpreid> oh, that's 45 lines with some interspersed literate comments
17:34:12 <kpreid> emk: the maximum indent is 18
17:34:25 <shapr> Check this out, it compares 'expressiveness' of Haskell vs other languages. - http://citeseer.ist.psu.edu/booth96are.html
17:34:32 <emk> I hope that's 18 spaces, and not 18 levels of nesting!
17:34:39 <kpreid> yes, spaces
17:34:46 <shapr> The only way things come out even close to even is to require implicit line ending operators, etc
17:35:09 <kpreid> and feel free to judge the dubiousness of these combinators:
17:35:25 <kpreid> map2M f (a, b) = do a' <- f a; b' <- f b; return (a', b')
17:35:26 <kpreid> map2M2 f (a, b) (c, d) = do ac <- f a c; bd <- f b d; return (ac, bd)
17:36:23 <emk> kpreid: Random variations of mapM don't really count as nasty, particularly if there's a nice pattern to how they're used.
17:36:32 <shapr> Can't you do map2M with `ap` ?
17:36:54 <kpreid> maybe?
17:37:09 <shapr> @type ap
17:37:09 <kpreid> ?type ap
17:37:10 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
17:37:11 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
17:37:34 <kpreid> ?type let map2M f (a, b) = do a' <- f a; b' <- f b; return (a', b') in map2M
17:37:35 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m a) -> (b, b) -> m (a, a)
17:37:56 <kpreid> they don't seem related to me
17:37:59 <shapr> I think you have to use ap twice maybe?
17:38:18 <kpreid> but you can't express the (b -> m a) part with ap
17:39:07 <kpreid> note this is (map-over-2-tuple)M, not mapM2
17:39:49 <kpreid> (I would like to have a better expression of these combinators, yes; I only don't see how to apply ap for the purpose)
17:40:00 <emk> The thing I miss most in Haskell is subtyping...
17:40:50 <lennart> emk: got any specific examples?
17:40:57 <kpreid> in case you're wondering, all this is for a fancy equality function, which is why combinators for operating on pairs are interesting
17:41:18 <kpreid>      identities <- map2M2 shallowOrDerivedIdentity pair (unzip sofar)
17:41:19 <kpreid>      if uncurry (==) identities then return (Just True) else
17:42:13 <emk> lennart: Well, sometimes I'll have a nice data declaration with a couple of constructors, but one of the constructors is more interesting and supports a few functions that the others don't.
17:43:09 <emk> lennart: Similarly, every constructor for every node in my AST has a SourcePos field, which I need to keep declaring over and over...
17:43:22 <lennart> emk: yes, that can be annoying
17:43:39 <emk> At least with type classes, I can hide all that duplication behind a single pos function.
17:44:15 <kpreid> emk: both of those can be done by splitting up the data type, I think
17:44:37 <kpreid> data Node = Node SourcePos NodeVariant; data NodeVariant = A | B | C ...
17:44:44 <emk> When I tried to solve the same problem in OCaml, I was far more frustrated.
17:45:54 <emk> kpreid: Yeah, but it replaces one ugly workaround with another. It's too bad that subtyping interacts so badly with the other cool type-system features in Haskell.
17:47:30 <lennart> emk: I think the nominal subtyping in O'Haskell works ok with type classes.
17:47:43 <emk> All in all, though, I'm deeply impressed by Haskell's type system.
17:48:19 <emk> lennart: Thanks for the pointer! I'll have to take a look.
17:48:48 <emk> Type systems seem to be finicky beasts--you can't just mix together all the features you want.
17:49:20 <lennart> emk: you're right, features interact.  sometime nicely, sometime badly
17:50:14 <emk> lennart: It's true with any aspect of language design, but type systems seem more involved (with more tradeoffs) than most.
17:52:27 <emk> I need to take another look at the Haskell type system extensions based on constraint handling rules. That may be an interesting formulation...
17:54:24 <emk> http://www.comp.nus.edu.sg/~sulzmann/chameleon/
17:54:28 <lambdabot> Title: Chameleon, http://tinyurl.com/y8cd7n
18:01:51 <emk> Ah, O'Haskell uses a constraint solver.
18:02:11 <emk> Why am I not suprised?
18:02:31 * araujo working on his web site
18:03:03 <Botty> emk - so does helium (just read about it a few minutes ago, so figured i'd mention it)
18:03:36 <emk> Constraint-based languages are really fascinating.
18:04:44 <Botty> Heh, would be crazy if you could have a language where you specify the constraints and it creates a program which meets them.  Using a solver, hopefully not just a GA or something
18:05:06 <Pseudonym> Already been done.
18:05:10 <emk> Mozart/Oz has a really sophisticated model for controlling searches, but you can't really extend the data types the constraints operate over without hacking the implementation.
18:05:27 <Pseudonym> There are systems where you supply the constraints, then supply what values you know are going to be provided at run-time.
18:05:39 <Botty> huh, cool
18:05:41 <Pseudonym> Then it generates a plan to solve the constraints.  This plan is a program.
18:06:03 <Botty> hmm, does prolog work this way?
18:06:09 <Pseudonym> No.
18:06:15 <Botty> ok
18:06:35 <Pseudonym> Prolog can't really be called a constraint-based language, though there are extensions.
18:07:13 <Pseudonym> Mercury kind of works like this because of its mode and determinism system.
18:07:26 <emk> The ancient CHR stuff, on the other hand, gives you nice data type extensibility but a weaker model of searches... Good luck implementing branch and bound on to top of a CHR implementation.
18:07:29 <Pseudonym> You can think of a Mercury program as a Prolog program which knows what variables will be instantiated.
18:07:47 <Botty> huh. cool
18:08:00 <Pseudonym> And it can use that to generate efficient code, even to the point of detecting if some code is deterministic.
18:11:21 <emk> Pseudonym: Backtracking search really isn't interesting without some kind of automatic inference engine.
18:12:15 <emk> Because backtracking search takes O(2^N) time, you really want your runtime system and declarations to go to heroic lengths to before adding 1 to N.
18:13:06 <emk> And even when you do branch, it's advantageous to control exactly how you partition the space of candidate solutions.
18:16:09 <shapr> Pseudonym: Speaking of searching, have you seen "Increased Bit-Parallelism for Approximate String Matching" ? http://www.cs.uta.fi/~helmu/pubs/wea04.pdf
18:19:44 <emk> lennart: The O'Haskell typing papers are really interesting. Thanks for the pointer!
18:19:57 <shapr> Pseudonym: In summary, it shows how to speed up Myers approximate matching on short patterns by either searching for several patterns at once, or processing several text positions at once.
18:24:51 <Pseudonym> Oh, interesting.
18:25:09 <Pseudonym> I'll take a look.
18:28:20 <shapr> It sounds like the kind of thing that would interest you :-)
18:29:40 <Pseudonym> Me like bit twiddling.
18:36:10 <dfranke> Woot!  GHC 6.6 built in 76.5 minutes.
18:42:35 <dfranke> Athlon 64 X2 4400+.
18:44:15 <cjay> with bootstrapping?
18:45:52 <dfranke> no
18:46:05 <dfranke> I had 6.4.2 and then just ran make -j3
18:46:47 <dfranke> also, the source tree was on an encrypted drive if that makes a significant difference.
18:48:13 <shapr> dfranke: That's spiffy, have you tried ghc-smp on that same system?
18:48:47 <dfranke> uh, is that something separate?
19:00:26 <hyrax42> ?hoogle [a] -> [[a]]
19:00:27 <lambdabot> List.inits :: [a] -> [[a]]
19:00:28 <lambdabot> List.tails :: [a] -> [[a]]
19:00:28 <lambdabot> List.group :: Eq a => [a] -> [[a]]
19:07:58 <Fey> What have I done wrong with this statement? do e <- readSudoku x
19:07:58 <Fey> 			let p = solve e
19:07:58 <Fey> 			return printSudoku p
19:07:58 <Fey> do e <- readSudoku x
19:07:58 <Fey> 			let p = solve e
19:07:58 <Fey> 			return printSudoku p
19:08:15 <Fey> except for the double ctrl v that is
19:08:49 <stepcut> you probably don't need the return
19:09:06 <Fey> aye, but even without the return I am still getting an error
19:09:09 <kpreid> what's the type of readSudoku?
19:09:19 <araujo> readSudoku x >>= return . solve >>= printSudoku
19:09:28 <araujo> i'd read it like that
19:09:58 <Fey> the type is FilePath -> IO Sudoku
19:10:01 <glguy> liftM solve (readSudoku x) >>= printSudoku
19:10:05 <Cale> what's the type of solve?
19:10:20 <araujo> solve looks like a pure function
19:10:22 <Fey> Sudoku -> Maybe Susoku
19:10:38 <Cale> and printSudoku?
19:11:12 <Fey> Sudoku -> IO ()
19:11:33 <glguy> Maybe Sudoku /= Sudoku
19:12:08 <Fey> I'm using fromJust to fix that
19:12:08 <araujo> printSudoku :: Maybe Sudoku -> IO ()
19:12:09 <Cale> Fey: so there's the type mismatch
19:12:19 <araujo> that's probably what you want
19:12:30 <glguy> araujo: ew
19:13:06 <araujo> Fey, so you can use it like i wrote above
19:13:06 <Fey> what I have troubles with is the type IO Sudoku
19:13:12 <Fey> I do not fully understand what that is
19:13:27 <Fey> since in some cases I can use it as the type Sudoku
19:13:29 <Fey> but not always
19:13:42 <araujo> ?
19:13:45 <glguy> araujo: then you'd have to switch the function to be called "possiblyPrintSudoku" which seems like you aren't separating your concerns well enough
19:14:10 <araujo> glguy, good .. i think that's what he wants anyway
19:14:25 <glguy> araujo: no, my point was that that is not what he wants
19:14:26 <araujo> Fey, i don't get what you say
19:14:41 <araujo> glguy, it is , according to his code
19:14:48 <Fey> When I perform the IO and read in a Sudoku, I get as a result an IO Sudoku
19:14:58 <glguy> araujo: if what he wanted was what he had, he would not be asking questions
19:15:10 <araujo> glguy, he is asking because he is a bit confused
19:15:27 <Fey> now, sometimes I can use that as a Sudoku, as in the do x <- readSudoku example
19:15:35 <araujo> Fey, have you read about IO?
19:15:41 <glguy> araujo: regardless, it would not be appropriate for the type signature of print sudoku t obe Maybe Sudoku -> IO ()
19:15:49 <araujo> it'd be good if you could have a nice backgound before
19:15:59 <Fey> but sometimes I also get a type mismatch when I try to use it in more typical statement setups, such as printSudoku(readSudoku)
19:16:10 <glguy> Fey: you get to use the value inside an IO type by binding it
19:16:14 <araujo> glguy, i can't see why not, considering it is what he wants
19:16:22 <glguy> Fey: using do-notation, that would be something like:
19:16:36 <glguy> do { sudoku <- readSudoku; printSudoku sudoku }
19:16:39 <Fey> so do x is a binder?
19:16:40 <araujo> Fey, that's because an IO is a one way monad
19:16:49 <araujo> Fey, you can't take values out of it
19:17:05 <araujo> Or at least, you shouldn't :-)
19:17:09 <Fey> :)
19:17:30 <Fey> shouldn't seems to summarize most of my code at this hour :)
19:17:35 <araujo> Fey, Evey time you do an IO operation, you ned to keep the IO type "around" .. in other words, you can't get rid of it
19:17:50 <Fey> okay, but how do I use it then?
19:17:59 <glguy> do { sudoku <- readSudoku; printSudoku sudoku }
19:18:10 <Fey> How can I keep the IO "around" while still matching the type I want?
19:18:13 <glguy> ^^ readSudoku :: IO Sudoku
19:18:22 <glguy> ^^ printStudo :: Sudoku -> IO ()
19:18:26 <araujo> Fey, You have to use the bind operators (>>, >>=) like the code i wrote above, or use the 'do' syntax
19:19:18 <Fey> I'm trying to use that actually
19:19:40 <araujo> Fey, For example, following your type signatures, and modifying printSudoku as i said, you can do that
19:19:45 <araujo> readSudoku x >>= return . solve >>= printSudoku
19:20:28 <lisppaste2> glguy pasted "sudoku example for Fey" at http://paste.lisp.org/display/28041
19:20:30 <araujo> Think of the '>>=' as an operator preserving the IO type and using its value
19:20:32 <Fey> well, that gives me an IO (Maybe Sudoku)
19:20:58 <araujo> Fey, No, it should give you a IO () , which is the return type of printSudoku
19:22:07 <Fey> is >>= right associative?
19:22:10 <glguy> Fey: did you look at that paste?
19:22:12 <Fey> yup
19:22:38 <araujo> Fey, left
19:22:41 <glguy> Fey: it's left-associative
19:22:55 <araujo> ((readSudoku x >>= return . solve) >>= printSudoku)
19:23:00 <araujo> It is read like that
19:23:36 <glguy> which should always be written as: liftM solve (readSudoku x) >>= printSudoku
19:24:47 <araujo> That means something like: readSudoku applied to x , returns value to the function 'solve'. 'solve' applied to x, returns value to the function 'return' which puts the value into the IO type (notice how the value needs to be inside the IO monad, which return is for) , and finally returns the value to printSudoku ,
19:25:42 <Fey> ahh, so its like a pipe sort of?
19:25:48 <araujo> Yay!
19:25:56 <araujo> You got it :-)
19:26:10 <Fey> it pipes the actual stuff I want from the IO operation into the function after?
19:26:30 <Cale> yeah
19:26:36 <araujo> Yeah, and you put back the value (with return) into the pipe
19:26:45 <araujo> That's a pretty nice analogy btw
19:26:54 <Fey> and then return will reconstruct it as IO and send it over to print?
19:26:59 <araujo> yay!
19:27:03 <Cale> (x >>= f) is the action which when run will run x, get its result, pass that to f, which will give another action to run, and then return the result of that.
19:27:10 <Cale> so it's like:
19:27:15 <Cale> x >>= f = do
19:27:18 <Cale>    v <- x
19:27:22 <Cale>    f v
19:27:41 <weitzman> @undo a >>= b
19:27:41 <lambdabot> a >>= b
19:27:48 <weitzman> @redo a >>= b
19:27:48 <Cale> or if you want,
19:27:48 <lambdabot> do { _ <- a; b}
19:27:57 <araujo> Fey, you already got the idea, you can think of return like : "wrap this into the IO so i can continue the operations with this value through the pipe"
19:28:04 <Cale> x >>= f = do { v <- x; w <- f v; return w }
19:28:45 <Cale> but in fact, it's >>= which is actually primitive, and do-notation is defined in terms of it :)
19:28:51 <Fey> so all monads use this sort of value progression?
19:29:09 <glguy> it's what makes a monad a monad :)
19:29:17 <araujo> Fey, And since the IO monad is a one-way monad (you can't/shouldn't take values out of it) , you practically will always need the functions to use 'return' (that's why 'solve' needs to be composed with 'return')
19:29:30 <Fey> I see
19:30:18 <Cale> hmm
19:30:29 <Cale> you can use let :)
19:30:37 <glguy> and liftM
19:31:37 <Fey> okay, I don't think I should be looking at the liftM type signature for quite some time
19:31:48 <araujo> This is really another nice analogy.
19:32:10 <araujo> Fey, i recommend to get used to the bind operators first
19:32:17 <araujo> (>>=, >>)
19:32:27 <glguy> liftM just takes a pure function, and makes it one that operates on the monad
19:32:41 <glguy> in this case, Sudoku -> Maybe Sudoku
19:32:46 <Cale> Fey: liftM for a general monad is quite a lot like map is for lists
19:32:51 <Cale> If that helps :)
19:32:53 <araujo> @where all about monads
19:32:53 <lambdabot> I know nothing about all.
19:32:53 <glguy> becomes: IO Sudoku -> IO (Maybe Sudoku)
19:32:57 <araujo> argh ...
19:33:06 <Fey> ahh
19:33:15 <araujo> @where monads
19:33:15 <lambdabot> http://www.nomaware.com/monads/html/index.html
19:33:20 <araujo> Fey, check
19:33:23 <Cale> liftM takes a function of type (a -> b), and an action of type (m a) and produces an action of type (m b)
19:33:36 <Fey> but I still do not understand how monads look though. So I cannot compare it mentally to a list
19:34:04 <Fey> oh wait, this is something like the lambda chaining in scheme?
19:34:14 <glguy> Fey: map takes a function that operates on a value, and turns it into an function that operates on a list of that value
19:34:17 <araujo> Fey, check the above site, i think you already grasped at it pretty much though
19:34:21 <glguy> Fey: map is just liftM on lists
19:34:42 <glguy> :type (*2)
19:34:49 <glguy> :type map (*2)
19:34:52 <glguy> ?type (*2)
19:34:52 <Cale> I actually prefer to use fmap over liftM
19:34:53 <lambdabot> forall a. (Num a) => a -> a
19:34:54 <glguy> ?type map (*2)
19:34:55 <lambdabot> forall a. (Num a) => [a] -> [a]
19:34:59 <Cale> they do the same thing, but fmap is more general
19:35:14 <glguy> I use liftM when I'm also using >>=
19:35:23 <glguy> and fmap otherwise
19:36:26 <Cale> I think fmap should be the only such function, and it should be renamed to map :)
19:36:54 <araujo> hah
19:36:58 <glguy> should concat be eschewed in favor of join?
19:37:06 <Cale> perhaps :)
19:37:08 * glguy likes the idea ;)
19:37:23 <Cale> in fact, certainly
19:37:25 <glguy> and then lets bring back monad comprehensions!
19:37:36 <Cale> yeah, they're apparently coming back in GHC
19:37:40 <Cale> if not the standard
19:37:42 <Fey> glguy, I'm still getting the last generator in do (...) should be an expression from your pastebin
19:37:55 <Cale> Fey: that's often an indentation problem
19:38:05 <Fey> IS there a strict sequence for do statements?
19:38:05 <shapr> Is there a standard Cabal way of building and running separate unit tests?
19:38:33 <araujo> none i know of
19:38:46 <glguy> http://paste.lisp.org/display/28041 did I indent this incorrectly?
19:38:50 <Cale> Now that GHC 6.6 is out, I wonder if the Haskell community going to smash the Shootout benchmarks again :)
19:38:56 <Cale> is*
19:39:22 <Cale> glguy: it's fine
19:39:26 <Fey> I think you have it correvt
19:39:37 <Cale> Fey: hm?
19:39:46 <Cale> Fey: strict sequence?
19:39:49 <Fey> I am using notepad currently which may or may not cause problems with this
19:40:14 <Cale> The evaluation order with do-notation depends on the monad. Some monads are strict, and some are lazy.
19:40:19 <Fey> as in, what is the syntactic bind for the do sequence?
19:40:41 <Fey> as in a := <a> | <b> etc
19:40:50 <glguy> Fey: my paste could be written on one line as: liftM solve readSudokuFromFile >>= maybe (putStrLn "Nothing") printSudoku
19:41:03 <Cale> there is a strict syntax. You could look in the Haskell Report for it
19:41:38 <Cale> http://haskell.org/onlinereport/exps.html#sect3.14
19:41:42 <lambdabot> Title: The Haskell 98 Report: Expressions, http://tinyurl.com/y9wv2l
19:42:08 <Cale> it describes the syntax after desugaring the indentation rule
19:42:23 <Cale> so there are braces and semicolons there
19:42:40 <Cale> If that's what you're asking for?
19:42:55 <Fey> Because in scheme you for instance have to use <if> <then> <else>, you cannot go with <if> <then> only
19:43:14 <glguy> ?type when
19:43:16 <skew> ?type Control.Monad.when
19:43:16 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:43:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:43:28 <glguy> skew: jynx!
19:45:17 <glguy> which is just: \b f -> if b then f else return ()
19:46:21 <glguy> ?type unless
19:46:22 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:47:02 <shapr> musasabi: ping?
19:50:52 <Cale> Fey: same here :)
19:51:11 <Cale> Fey: unless you were perhaps confused by the use of 'let' without 'in' inside a do-block?
19:52:08 <skew> Fey: an if without else would make sense as a special part of do syntax, but it doesn't seem to add a whole lot
19:52:40 <glguy> especially since that functionality can be described with a function within the language like when
19:53:08 <ThreeQ> ?type when
19:53:09 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:53:33 <glguy> when feelingLucky (print lotteryNumbers)
19:54:02 <hyrax42> ?hoogle Map k a => Int
19:54:02 <skew> I think a variant of case would be nicer
19:54:03 <lambdabot> Network.Socket.maxListenQueue :: Int
19:54:03 <lambdabot> Network.Socket.sOL_SOCKET :: Int
19:54:03 <lambdabot> Network.Socket.sOMAXCONN :: Int
19:54:18 <skew> case M act of ... => act >>= \k -> case k of ....
19:54:19 <hyrax42> oops
19:54:25 <hyrax42> ?hoogle Map k a -> Int
19:54:26 <lambdabot> Data.Map.size :: Map k a -> Int
19:54:26 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
19:54:26 <glguy> hyrax42: I don't htink that's what you meant
19:54:31 <hyrax42> no it wasn't
19:54:39 <hyrax42> ?docs Data.Map
19:54:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
19:54:43 <hyrax42> size is O(1) iirc
19:54:45 <hyrax42> ?
19:55:04 <hyrax42> yup yup
19:55:23 <glguy> ?fptools Data.Map
19:55:23 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
19:55:48 <hyrax42> glguy: it's listed in docs
19:56:01 <glguy> I was just looking at it'sdefinition
19:56:02 <glguy> size t
19:56:03 <glguy>   = case t of
19:56:03 <glguy>       Tip             -> 0
19:56:03 <glguy>       Bin sz k x l r  -> sz
19:56:27 <hyrax42> what type of trees are they... lemme lookie
19:56:58 <glguy> source says "  Size balanced trees. "
19:57:35 <hyrax42> strictness in data constructors only gets the thing to "whnf" right?
19:57:47 <hyrax42> doesn't cause it to evaluate all the way?
19:58:13 * hyrax42 really needs to read up on strictness
19:58:33 <glguy> the keys are strict because they have to be evaluated anyway to correctly build the search tree
19:58:55 <glguy> so sense in wastingresources on laziness you can't use
19:59:25 <hyrax42> but e.g. for the subtress
19:59:33 <hyrax42> oh wait same thing goes
19:59:49 <hyrax42> hm
19:59:52 <hyrax42> still need to read up on it
20:00:04 <glguy> I think that only the top level is strict
20:00:09 <glguy> it's not a deep strict
20:03:56 <skew> Hi, has anybody here used hs-plugins much?
20:04:57 <araujo> sort of here
20:05:30 <hyrax42> dons
20:05:32 <hyrax42> :p
20:05:34 <skew> I've been trying to hack on it to use the GHC API, but just to get it building for the HaskellDB dyn driver - I've never really used it before
20:11:44 <dons> re.
20:16:20 <hyrax42> ?docs System.Time
20:16:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
20:16:28 <araujo> hello dons !
20:25:58 <hyrax42> what's the power operator
20:26:06 <hyrax42> ?hoogle (^)
20:26:07 <lambdabot> Did you mean: (^)
20:26:07 <lambdabot> Prelude.undefined :: a
20:26:07 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
20:26:13 <hyrax42> ?hoogle (**)
20:26:14 <lambdabot> Did you mean: (**)
20:26:15 <lambdabot> Prelude.undefined :: a
20:26:15 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
20:26:25 <hyrax42> ?hoogle pow
20:26:26 <lambdabot> No matches found
20:26:37 <hyrax42> ?docs Prelude
20:26:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
20:26:51 <lispy> > 3^4
20:26:52 <lambdabot>  81
20:26:55 <lispy> > 2.5**8.9
20:26:57 <lambdabot>  3480.695863935399
20:28:01 <hyrax42> cheers
20:29:35 <ThreeQ> > (3%4)^^2
20:29:36 <lambdabot>  9%16
20:29:48 <lispy> heh, i hadn't seen that version yet
20:29:58 <lispy> ?type (^^)
20:29:59 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:30:09 <lispy> ?type (^)
20:30:11 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:30:13 <lispy> ?type (**)
20:30:14 <lambdabot> forall a. (Floating a) => a -> a -> a
20:30:29 <lispy> (3%4)^2
20:30:32 <lispy> > (3%4)^2
20:30:34 <lambdabot>  9%16
20:30:46 <ThreeQ> I have no idea what the point of (^^) is
20:30:48 <lispy> > (3.4)^2
20:30:50 <lambdabot>  11.559999999999999
20:31:34 <ThreeQ> oh, this is the point:
20:31:40 <ThreeQ> > (3%4)^^-1
20:31:41 <lambdabot>  Not in scope: `^^-'
20:31:48 <ThreeQ> > (3%4)^^(-1)
20:31:50 <lambdabot>  4%3
20:31:52 <lispy> and shouldn't it be (**) :: forall a b. (Num a, Floating b) a -> b -> b ?
20:32:13 <ThreeQ> > (3%4)^(-1)
20:32:15 <lambdabot>  Exception: Prelude.^: negative exponent
20:32:22 <lispy> ah
20:34:23 <ThreeQ> lispy: how would you implement that using +, -, *, negate, abs, signum, and fromInteger?
20:35:05 <ThreeQ> (^) works on arbitrary nums because all it has to do is repeatedly multiply
20:35:26 <lispy> ThreeQ: um....fromIntegral ;)
20:35:30 * lispy gets the point
20:35:40 <ThreeQ> ah, but not all Nums are Integral :)
20:36:07 <moconnor> Can only the classes from the Prelude (Eq, Show, Read, ...) be used with the "deriving" keyword?  If not what requirements does my type class have to meet to be derivable?  I couldn't find an easy to grok answer on haskell.org.
20:36:08 <weitzman> > signum -3
20:36:09 <lambdabot>  add an instance declaration for (Num (a -> a))
20:36:14 <weitzman> @type signum
20:36:15 <lambdabot> forall a. (Num a) => a -> a
20:36:22 <ThreeQ> > signum (-3_
20:36:23 <lambdabot>  Parse error
20:36:27 <ThreeQ> > signum (-3)
20:36:29 <lambdabot>  -1
20:36:32 <glguy> ?type fromIntegral
20:36:33 <lambdabot> forall b a. (Num b, Integral a) => a -> b
20:36:48 <weitzman> > signum 0
20:36:50 <lambdabot>  0
20:36:52 <lispy> moconnor: as near as i can tell, yes only prelude classes...otoh you can use drift to define arbitrary algorithms for deriving
20:37:25 <weitzman> It there some particularly good reason signum returns the same type as the argument?
20:37:55 <weitzman> As opposed to some new datatype Sign = Neg | Pos | Zero, or Int or whatever
20:37:59 <ThreeQ> weitzman: so it can satisfy the rule abs x * signum x == x
20:38:20 <moconnor> lispy: thanks
20:38:39 <lispy> moconnor: yw
20:38:40 <ThreeQ> more complicated numbers could have more complicated sorts of sign
20:39:11 <glguy> > signum (0 :+ 1)
20:39:13 <lambdabot>  0.0 :+ 1.0
20:39:21 <glguy> > signum (1 :+ 1)
20:39:23 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
20:39:30 <weitzman> Oh my
20:39:48 <weitzman> Well, I guess the complex numbers count
20:39:53 <weitzman> Not that I've ever needed them
20:39:56 <lennart> the sign is really the angle for complex numbers
20:40:57 <glguy> so, for vectors, abs would be magnitude and signum would return the unitvector
20:40:58 <glguy> right?
20:41:21 <weitzman> Well, I like to pretend that complex numbers and vectors are interchangable
20:41:26 <weitzman> So I'm going to say, sure, why not
20:41:49 <glguy> and by unit vector I mean normalized vector
20:42:07 <lennart> yeah, that seems reasonable
20:42:33 <ThreeQ> well C is a vector space of dimension 2
20:42:37 <ThreeQ> so it's the same sort of thing
20:43:00 <lennart> to make things more consistent the abs function should return a scalar
20:43:10 <weitzman> @type abs
20:43:12 <lambdabot> forall a. (Num a) => a -> a
20:43:21 <weitzman> So vectors don't fit into Num
20:43:24 <weitzman> Alas
20:43:37 <lennart> many things don't fint into Num :(
20:43:41 <lispy> signum shouldn't be in Num
20:43:41 <lennart> like real numbers
20:43:42 <weitzman> Maybe Num needs to be generalized
20:43:48 <glguy> > abs (1 :+ 1)
20:43:49 <weitzman> Num a b
20:43:49 <lambdabot>  1.4142135623730951 :+ 0.0
20:43:57 <lispy> well, Num would be better as a Ring and then signum wouldn't make sense :)
20:44:20 <Cale> Yeah, signum is really kind of a silly thing to put in Num
20:44:23 <weitzman> I'm not convinced signum makes sense as it is
20:44:41 <Cale> The rest of Num is okay
20:44:50 <lennart> there are many ways you could organize the numbers (et al).  the current one isn't the best
20:45:18 <Cale> I don't want some convoluted system which does lots of automatic conversion
20:45:26 <lennart> Me neither!
20:45:48 <Cale> I think the property that all conversions between numeric types are explicit is good.
20:46:06 <lennart> You'll have no objections from me. :)
20:46:13 <hyrax42> ?docs Text.ParserCombinators.Parsec
20:46:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
20:46:33 <lennart> But something I think is really broken is requiring Eq and Show to be super-classes of Num
20:47:00 <Cale> oh, definitely
20:47:21 <glguy> la la la la, I don't hear you saying that Haskell is imperfect
20:47:39 <dibblego> ?where aplas
20:47:40 <lambdabot> I know nothing about aplas.
20:47:43 <ThreeQ> wait, why IS Show a super-class of Num?
20:47:46 <dibblego> dons, you about?
20:47:47 <lennart> All languages suck.  Haskell just sucks less than most. :)
20:48:07 <hyrax42> ?hoogle Either a b -> b
20:48:08 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
20:48:19 <Cale> I sort of understand the rationale there, but I think that hurts more than it helps. Better just to force extra typeclass constraints on functions which really need pattern matching against numbers and such.
20:48:20 <lennart> ThreeQ: Show is a super-class because some people thought it was handy for debugging. :(  No real reason.
20:48:42 <ThreeQ> bah
20:48:51 <hyrax42> there's no fromRight?
20:48:58 <lennart> Show didn't use to be a superclass of Num
20:49:41 <weitzman> > (Right 3) >>= id
20:49:42 <lambdabot>  add an instance declaration for (Num (Either a b))
20:49:44 <Cale> There's rather shaky rationale for a few things, and now there are people who've started to like various misfeatures.
20:49:44 <lennart> @djinn b -> Either a b -> b
20:49:45 <lambdabot> f a b =
20:49:45 <lambdabot>   case b of
20:49:45 <lambdabot>   Left _ -> a
20:49:45 <lambdabot>   Right c -> c
20:50:11 <user317> how do i look up the implementation of something?
20:50:14 <hyrax42> that's not the right type
20:50:19 <hyrax42> silly djinn
20:50:30 <hyrax42> oh
20:50:34 <Cale> user317: what in particular?
20:50:37 <hyrax42> @dfinn Either a b -> b
20:50:38 <lambdabot> -- f cannot be realized.
20:50:39 <Cale> user317: a prelude function?
20:50:41 <lennart> hyrax42: why isn't that the right type?
20:50:47 <hyrax42> I dont' want a total function
20:50:52 <Cale> http://haskell.org/onlinereport/standard-prelude.html
20:50:55 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y2wv6o
20:51:01 <hyrax42> just something to get rid of the Right
20:51:02 <user317> Cale, foldr
20:51:11 <dons> dibblego: only just
20:51:13 <lennart> *gasp* a non-total function?!?!
20:51:31 <Cale> foldr f z [] = z
20:51:31 * lispy waits to see if hyrax42 will get banned ;)
20:51:31 <dibblego> dons, any idea how much of APLAS06 will be FP languages?
20:51:44 <hyrax42> > fromJust Nothing
20:51:45 <lambdabot>  Add a type signature
20:51:47 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
20:51:56 <hyrax42> > fromJust Nothing :: Int
20:51:57 <lambdabot>  Exception: Maybe.fromJust: Nothing
20:52:03 <dons> dibblego: the paper list should be online? check there.
20:52:10 <dibblego> dons, just trying to assess if it's worth going
20:52:14 <dons> i'd expect a fair few fp papers
20:52:20 <dibblego> dons, righto
20:52:26 <lennart> yeah, I try to stay away from fromJust :)
20:52:31 <Cale> user317: it's in the standard prelude, so you can also just look at that page I linked to
20:52:43 * glguy envisions a Haskell without non-total-functions
20:52:48 <glguy> no head, tail
20:52:54 <glguy> fromJust, etc
20:53:01 <Cale> no general recursion :)
20:53:04 <glguy> or, &c. rather :)
20:53:11 <lispy> meh, i'd just define them myself ;)
20:53:55 <user317> thanks Cale
20:53:57 <glguy> i guess technically head is a total function, its just that on a null list the result is error "message"
20:54:13 * weitzman envisions a Haskell where all functions are information-preserving, thus being compilable to power-efficient reversible circuits
20:54:30 <Cale> :)
20:54:49 <Cale> low heat-generation :)
20:54:56 <skew> dons: one big problem I ran into is that ModuleName has a package component in 6.6, and I'm not sure how to deal with that
20:55:18 <dons> right, we'll have to parse it and use it to look up symbols
20:55:31 <dons> we had to do a similar thing when package names got version numbers
20:56:23 * shapr hacks out unit tests
20:56:42 * lispy tries to avoid homework
20:56:53 <lispy> reading about OO every week gets old fast :(
20:56:58 <dylan> y'know, the only reason I avoided using darcs was I didn't think it'd be any better than arch (which emotionally scarred me)
20:57:13 <lispy> dylan: haha
20:57:17 <lispy> arch--
20:57:33 <dons> so you've seen the light, dylan ?
20:57:34 <dylan> most of my ~/wc/ is darcs now.
20:57:38 <dons> hehe
20:57:40 <lispy> yay!
20:57:52 <dylan> The only problem with svk is ~/.svk/
20:58:02 <weitzman> Darcs has scarred me, and I haven't even used it to do anything but check out some code as a test
20:58:15 <weitzman> Darcs is unfriendly both to Windows users and humans
20:58:23 <dylan> Windows users arn't humans. ;)
20:58:26 <weitzman> I, being one of each, was disappointed
20:58:29 <lispy> how to create a repository with a file in it with darcs: mkdir myrepo; cd myrepo; touch foo; darcs add foo; darcs record.  I have absolutely no idea how to do the same thing with arch after 4 hours of playing with it one day :)
20:59:05 <dylan> the only small issue is the complexity of my dotfiles setup has exploded.
20:59:20 <dons> seems odd, weitzman ? did you document what went wrong, or didn't behave as expected?
20:59:45 <weitzman> I mentioned it in passing in #haskell
20:59:50 <lispy> weitzman: it's true that darcs is a second class citizen on windows
21:00:01 <dons> yeah, lack of windows devs, as per usual
21:00:04 <lispy> weitzman: were you using the commandline or tortoise darcs?
21:00:06 <dylan> But in a good way... I have ~/wc/conf/{main,xmain,priv,xpriv} for public config files, public config files for X, private config files (ones with passwords), and private config files for X stuff (only gaim currently).
21:00:12 <weitzman> Command line
21:00:22 <lispy> dons: yeah, current unstable doesn't even seem to be building on windows :(
21:00:27 <dylan> I can't get any work done on windows, anyway
21:00:29 <weitzman> I was able to rename the putty executables as necessary, which I shouldn't need to, but then it seemed to me that darcs wasn't working
21:00:34 <dons> this is a chance, again, for windows users to step up and help out open source...
21:00:34 <weitzman> In particular because it prints an error message
21:00:43 <weitzman> Which, according to the web, is meaningless
21:00:46 <lispy> dons: and it took me most of today just to find that out because setting up mingw to build darcs took ages
21:00:49 <weitzman> And it prints nothing
21:00:53 <weitzman> Even though it's downloading stuff
21:01:30 <lispy> weitzman: do you remember how long ago this was?
21:01:39 <weitzman> Maybe...a week? Two weeks?
21:01:51 <weitzman> It eventually prints something
21:01:56 <lispy> oh hmm...1.0.8 works pretty good for me at work...
21:01:56 <weitzman> But first it creates some file
21:02:04 <weitzman> And while downloading that file, it prints nothing
21:02:09 <weitzman> So I assumed it wasn't working
21:02:18 <weitzman> I would always kill it
21:03:48 <weitzman> Also, I recall reading that ssh with passwords doesn't work on windows in darcs
21:06:05 <RyanT5000> ssh in any form on windows is so ridiculously annoying
21:06:24 <RyanT5000> it was one of the first things that made me happy when i switched to linux
21:06:48 <lispy> putty is fine
21:06:57 <lispy> and winscp is good
21:06:58 <RyanT5000> not from the command line
21:07:11 <weitzman> Nobody uses the windows command line anyway :)
21:07:16 <lispy> oh well, that's not really ssh's fault...windows forgot to have decent command line :)
21:07:26 <RyanT5000> yeah, i wasn't blaming ssh :P
21:08:12 <weitzman> I saw a presentation on PowerShell that was pretty impressive, although when I tried to use it I quickly learned that it doesn't work too well with batch files that try to change environment variables
21:08:44 <RyanT5000> basic shell scripting needs to be effectively built into the OS
21:08:46 <weitzman> At the time I was working on something with a complex build system that didn't quite work in PowerShell
21:08:54 <Cale> That was one of my major reasons for dropping windows from my machine altogether. Whenever I booted into windows, I felt cut off from the world, or if I was away from my computer, annoyed at the fact I couldn't access it.
21:09:07 <weitzman> Cale: Remote desktop?...
21:09:10 <RyanT5000> and by "basic" i don't mean the degenerate malformed appendage windows has
21:09:25 <Cale> weitzman: this was in 2000
21:09:32 <glguy> Cale: going back to head and tail, it seems their types could be [a] -> Maybe a and [a] -> Maybe [a]... a little less convenient, sure, but an appropriate use of Maybe :)
21:09:36 <weitzman> Cale: Before windows XP?
21:09:52 <Cale> yeah, and also, how do you access such a thing from a unix terminal?
21:10:03 <Cale> glguy: yeah
21:10:07 <weitzman> rdesktop works in linux, although it's not a command line program
21:10:09 <lispy> Cale: i keep a copy of windows around incase i need IE or want to test something on windows or play a video game...otherwise, it's just frustrating
21:10:24 <glguy> windows comes with telnet server
21:10:35 <glguy> and ssh can be installed
21:10:58 <Cale> I usually install putty on every windows machine I touch
21:11:52 * glguy has putty on his usb thumbdrive w/ his ssh key
21:12:45 <glguy> for machines I don't trust, I use skey :)
21:13:18 <weitzman> If you don't trust the machine, you should just put knoppix on the thumb drive
21:13:25 <weitzman> Problem solved!
21:13:52 <glguy> nail, meet sledgehammer
21:14:35 <glguy> I'm still working out a way to SSH from my nintendo ds
21:14:41 <glguy> or looking for
21:14:42 <glguy> rather
21:17:06 <hyrax42> > tail []
21:17:06 <lambdabot>  Add a type signature
21:17:14 <hyrax42> > tail [] :: [()]
21:17:15 <lambdabot>  Exception: Prelude.tail: empty list
21:17:29 <glguy> should be called unsafeTail!
21:18:06 <Pseudonym> Wow, all those years of compactifying fibonacci has paid off for me, finally.
21:18:11 <Pseudonym> chebyshev :: Double -> [Double]
21:18:11 <Pseudonym> chebyshev x = ch
21:18:11 <Pseudonym>   where ch = 1 : scanl (\a b -> 2*x*a - b) x ch
21:18:17 <Pseudonym> Now THAT'S neat.
21:18:35 <lispy> Pseudonym: what does a chbyshev polynomial have to do with fibs?
21:18:48 <Pseudonym> Look at the code.
21:18:54 <lispy> Pseudonym: oh you mean because you can use scanL?
21:18:55 <Pseudonym> Compare with:
21:18:57 <Pseudonym> Yeah.
21:19:04 <lispy> cool :)
21:19:08 <glguy> > take 10 $ fix ( (1:) . scanl (+) 1)
21:19:10 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
21:19:36 <lispy> > take 10 $ fix (1:)
21:19:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
21:19:47 <Pseudonym> > let { chebyshev x = let ch = 1 : scanl (\a b -> 2*x*a - b) x ch in ch } in [ chebyshev x !! 2 | x <- [-1.0,-0.9..1] ]
21:19:48 <lambdabot>  [1.0,0.6200000000000001,0.28000000000000025,-1.9999999999999796e-2,-0.279999...
21:19:56 <Pseudonym> > let { chebyshev x = let ch = 1 : scanl (\a b -> 2*x*a - b) x ch in ch } in [ chebyshev x !! 2 | x <- [-1.0,-0.8..1] ]
21:19:57 <lambdabot>  [1.0,0.28000000000000025,-0.2799999999999998,-0.6799999999999997,-0.91999999...
21:20:03 <Pseudonym> Err.
21:20:11 <Pseudonym> > let { chebyshev x = let ch = 1 : scanl (\a b -> 2*x*a - b) x ch in ch :: [Float] } in [ chebyshev x !! 2 | x <- [-1.0,-0.8..1] ]
21:20:13 <lambdabot>  [1.0,0.2800001,-0.27999997,-0.67999995,-0.91999996,-1.0,-0.9200001,-0.680000...
21:20:16 <Pseudonym> Yeah, that.
21:34:09 <hyrax42> wassat
21:39:06 <dons> Pseudonym: nice!
21:39:23 <dons> all these years of approaching the minimal fib were good for something
21:39:36 * dons things maybe we should have a wiki page of all the wacky/fun fibs we've written in here
21:43:42 <glguy> I'm watching "The Bridge" as linked from Digg. Does anyone know if Hubbard invented Scientology to be a scam? or if people just used it as one after he died?
21:44:17 <dons> oh ,that's an interesting idea.
21:44:32 <dons> he was kooky enough for it not to have been a scam, i suppose
21:44:54 <dons> then again, plenty of these things start as scams from 0
21:45:26 <Cale> He had said, before he started Scientology, that creating a religion would be a great way to make a lot of money.
21:45:54 <Pseudonym> There's a supposed quote from him that he intended it to be a scam.  Or performance art.
21:46:09 <Pseudonym> However, I think it's very clear that he thought that modern psychology was bunk.
21:46:18 <Pseudonym> Given when he thought that, he was partly correct.
21:46:37 <Pseudonym> The discovery of brain chemistry imbalances has pushed the state of the art quite some distance.
21:46:54 <Cale> Then you have things like the Church of Moo, which started out as a joke website, until the guy Floyd who ran it discovered that he had actual followers :)
21:46:58 <Pseudonym> So at least that part of it, I think, was genuine.
21:47:28 <glguy> the flying spaghetti monster has believers too :)
21:48:27 <dons> i follow the church of boy on a stick (and slither too). maybe slither mostly , in fact
21:48:42 <Cale> hehe
21:48:47 <glguy> "cookies on dowels!"
21:48:52 <Cale> yeah, that's an absolutely awesome comic
21:49:09 <Cale> I also rather like Pokey the Penguin :)
21:49:19 <Cale> It's far more bizarre though :)
21:49:22 <kfish> Pokey forever!
21:50:54 <ozone> kfish: have you seen alien loves predator yet?  one of the better web comics :)
21:51:37 <Cale> Perry Bible Fellowship is also pretty funny, and offensive :)
21:51:41 <kfish> ozone: i'm a phd student now, i don't have time for web comics LOL
21:51:55 <glguy> PBF is pretty awesome
21:52:40 * ThreeQ <3 xkcd
21:53:38 <ThreeQ> also achewood
21:55:05 <Botty> IU'm a devotee of the Invisible Pink Unicorn (Blessed be Her Holy Hooves)
21:58:33 <Pseudonym> I'm a Discordian pope, but then so are you.
21:58:55 <Botty> hehe
21:59:19 <shapr> Hail Eris!
22:00:34 <Pseudonym> My pineal gland tingled when the new planetoid was named.
22:03:42 <foxy> anyone here use dhcp on a debian box?
22:07:26 <Pseudonym> ?hoogle (Floating a) => a -> Int -> a
22:07:27 <lambdabot> Data.Graph.Inductive.Monad.newNodesM :: GraphM m gr => Int -> m (gr a b) -> m [Node]
22:07:39 <Pseudonym> Not what I expected.
22:07:50 <Pseudonym> ?hoogle Double -> Int -> Double
22:07:51 <lambdabot> No matches, try a more general search
22:08:08 <Pseudonym> ?type significand
22:08:09 <lambdabot> forall a. (RealFloat a) => a -> a
22:08:18 <Pseudonym> ?hoogle (RealFloat a) => a -> Int -> a
22:08:19 <lambdabot> Prelude.scaleFloat :: RealFloat a => Int -> a -> a
22:08:19 <lambdabot> Data.Graph.Inductive.Monad.newNodesM :: GraphM m gr => Int -> m (gr a b) -> m [Node]
22:08:22 <Pseudonym> Bingo/
22:08:34 <Pseudonym> > scaleFloat 2 1.0
22:08:35 <lambdabot>  4.0
22:08:47 <hyrax42> > scaleFloat 3 1.0
22:08:49 <lambdabot>  8.0
22:09:01 <hyrax42> it shifts the exponent?
22:09:18 <Pseudonym> Yes.
22:09:26 <shapr> foxy: I use it as both client and server.
22:10:27 <foxy> shapr: my windows box is working but my new linux installation isn't getting a response from the cable modem dhcp server, I was wondering whether there are any obvious things to do?
22:12:50 <shapr> First check firewall settings, if nothing obvious shows up, use wireshark to sniff the packets.
22:15:44 <foxy> firewall on client? (not configured)
22:30:23 <svref> what's haskellese for '\n'?
22:31:15 <Pseudonym> > '\n'
22:31:17 <lambdabot>  '\n'
22:31:31 <svref> > show '\n'
22:31:33 <lambdabot>  "'\\n'"
22:31:40 <svref> show "\n"
22:31:47 <svref> > show "\n"
22:31:49 <lambdabot>  "\"\\n\""
22:32:12 <svref> argh!
22:32:32 <svref> What I really want to know is, what character does GLUT associate with RETURN?
22:32:55 <dons> \010 ?
22:32:58 <dons> i.e. \n ?
22:33:08 <svref> So \n is really like in C?
22:33:27 <svref> Its hard to tell when its being helpfully backquoted all the time...
22:33:30 <dons> yep
22:33:38 <dons> \n is \n :)
22:33:43 <dons> > ord '\n'
22:33:44 <lambdabot>  10
22:33:50 <dons> > chr 10
22:33:52 <lambdabot>  '\n'
22:35:16 <hyrax42> gah stupid fglasgow-exts
22:35:24 <hyrax42> I think I'll alias ghc to include it
22:37:42 <lispy> is there a way to write fibs from powers of two?
22:38:06 <Pseudonym> I don't understand the question.
22:38:40 <lispy> given a sequence twos = [1,2,4,8,16,..] is there a way to generate [1,1,2,3,5,8...]
22:38:56 <lispy> if so i know even crazier ways we can generate fibs :)
22:39:08 <Pseudonym> Yes, but the most efficient methods involve forgetting the input sequence
22:39:16 <lispy> heh
22:39:32 <lispy> const fibs!
22:40:05 <dons> ah i think i know what lispy is up to...
22:40:26 <dons> since he has a special powers of two generator..
22:40:54 <lispy> > const (fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs))) (map length . group . fix $ show)
22:40:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:41:00 <lispy> there we go!
22:41:09 <lispy> special powers generator...hmm
22:41:17 <lispy> that could be fun
22:41:57 <dons> hehe
22:42:05 <lispy> yes, i quite love generating powers of two from show
22:42:07 <lispy> it's just so cool
22:42:15 <dons> yeah, just need to get fibs out of it now
22:42:20 <lispy> > map length . group . fix $ show
22:42:21 <dons> the numbers appear like magic :)
22:42:24 <lambdabot> Terminated
22:42:31 <lispy> > take 10 . map length . group . fix $ show
22:42:32 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
22:44:02 <lispy> ?type scanl
22:44:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
22:44:29 <lispy> > take 10 $ fix $ scanl (+) 1
22:44:30 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
22:44:39 <lispy> that one is even easier!
22:45:11 <lispy> > take 10 $ fix $ scanl (+) 0.5
22:45:13 <lambdabot>  [0.5,1.0,2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0]
22:45:21 <lispy> hmm...
22:45:29 <lispy> > take 10 $ fix $ scanl (+) 0.2
22:45:31 <lambdabot>  [0.2,0.4,0.8,1.6,3.2,6.4,12.8,25.6,51.2,102.4]
22:45:35 <lispy> neat!
22:45:43 <lispy> the powers of 0.2 ;)
22:46:02 <glguy> not quite
22:46:02 <lispy> > take 10 $ fix $ scanl (+) 0.1
22:46:04 <lambdabot>  [0.1,0.2,0.4,0.8,1.6,3.2,6.4,12.8,25.6,51.2]
22:46:10 <lispy> glguy: i know
22:46:10 <glguy> > 0.2 ^^ 2
22:46:12 <lambdabot>  4.000000000000001e-2
22:46:18 <glguy> > 0.2 ^ 2
22:46:19 <lambdabot>  4.000000000000001e-2
22:46:36 <Pseudonym> > let fib n = sum [ product [n-k+1..n] `div` product [1..k]| k <- [0..n] ]
22:46:37 <lambdabot>  Parse error
22:46:44 <Pseudonym> > let fib n = sum [ product [n-k+1..n] `div` product [1..k]| k <- [0..n] ] in map fib [0..]
22:46:45 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
22:46:50 <Pseudonym> Errr...
22:46:53 <Pseudonym> Hmm.
22:46:53 <lispy> hehe
22:47:28 <lispy> > take 10 $ fix $ scanl (+) 0.3333333
22:47:29 <lambdabot>  [0.3333333,0.6666666,1.3333332,2.6666664,5.3333328,10.6666656,21.3333312,42....
22:47:46 <lispy> > take 10 $ fix $ scanl (+) 7
22:47:47 <lambdabot>  [7,14,28,56,112,224,448,896,1792,3584]
22:48:12 <lispy> > take 10 $ fix $ sum . scanl (+) 7
22:48:13 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b]
22:48:14 <lambdabot>    Expected...
22:48:16 <lispy> gah
22:48:35 <lispy> scanl is neat but the name makes no sense to me
22:48:36 <lispy> or
22:48:39 <lispy> oops
22:50:07 <lispy> bleh, i have to read 4 chapters in the next hour...grrr stoopid pro-crastination
22:55:22 <Pseudonym> > let fib n = sum [ product [k+1..n-k] `div` product [1..n-2*k] | k <- [0..n`div`2] ] in map fib [0..]
22:55:23 <Pseudonym> That's it.
22:55:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:55:56 <Pseudonym> > let fib n = sum [ product [k+1..n-k] `div` product [1..n-2*k] | k <- [0..n] ] in map fib [0..]
22:55:58 <lambdabot>  [1,2,3,5,7,11,16,25,38,60,94,150,239,384,617,995,1605,2593,4190,6775,10956,1...
22:56:02 <Pseudonym> What a difference the div 2 makes.
22:59:48 <Blackfoot> i'm new to haskell as of a day ago.
23:00:08 <Blackfoot> i'm trying to write a function that takes a list and prints out it's factorials
23:00:47 <Pseudonym> OK
23:00:54 <Pseudonym> Do you know how to compute a single factorial?
23:01:00 <Blackfoot> but i'm getting an error on a line that says it expects a [] and is getting an IO
23:01:11 <Pseudonym> OK, what's the line?
23:01:13 <lispy> ?check \f xs -> (tail (scanl (const f) undefined xs)) == map (f::Int -> Int) (xs::[Int])
23:01:15 <Blackfoot> yes, i have part working
23:01:15 <lambdabot>  OK, passed 500 tests.
23:01:25 <Blackfoot>         putStrLn ("Factorial of " ++ ((show x) ++ (" is " ++ (show fact))))
23:01:34 * lispy just turned scanl into map
23:01:48 <Blackfoot> that's from the error message, and it's evaluation to a IO type, which makes sense
23:01:50 <lispy> ?scheck \f xs -> (tail (scanl (const f) undefined xs)) == map (f::Int -> Int) (xs::[Int])
23:01:56 <lambdabot> Terminated
23:01:58 <Blackfoot> but i don't understand why it expects a []
23:02:15 <dons> we need to see more code to diagnose the error
23:02:30 <lispy> dons: so we implemented foldl with scanl and now map...so we just need scanl :)
23:02:34 <dons> ?type \x fact -> putStrLn ("Factorial of " ++ ((show x) ++ (" is " ++ (show fact))))
23:02:35 <lambdabot> forall a a1. (Show a, Show a1) => a -> a1 -> IO ()
23:02:38 <Blackfoot> ok, np. i didn't want to flood the channel accidentally
23:02:41 <Pseudonym> ?where paste
23:02:41 <lambdabot> http://paste.lisp.org/new/haskell
23:02:45 <dons> yeah, just paste it
23:02:46 <Pseudonym> Blackfoot: Go tehre.
23:02:47 <Pseudonym> there
23:02:49 <dons> at the above link
23:02:57 <Blackfoot> putFactorial [] = []
23:02:57 <Blackfoot> putFactorial (x:xs) = do
23:02:58 <Blackfoot>   let fact = factorial x
23:02:58 <Blackfoot>   putStrLn ("Factorial of " ++ show x ++ " is " ++ show fact)
23:02:59 <Blackfoot>   putFactorial xs
23:03:07 <dmead> =)
23:03:08 <dmead> =(
23:03:09 <dons> also, its better form to write: putStrLn $ "Factorial of " ++ ....
23:03:09 <dmead> :O
23:03:14 <Pseudonym> Do you know what putStrLn does?
23:03:23 <dons> or even, printf "Factorial of %d is %d" x fact
23:03:38 <Pseudonym> Ah, I see.
23:03:39 <Pseudonym> OK.
23:03:47 <Pseudonym> Do you know what the type of putFactorial is supposed to be?
23:03:50 <Blackfoot> i haven't seen the use of printf, i've just see putStrLn from the tutorial
23:03:55 * dmead has totally messed up his gentoo install
23:03:56 <dmead> =(
23:04:02 <Blackfoot> although i know the function from other languages
23:04:44 <Blackfoot> putFactorial is the last statement in main
23:04:59 <dons> putFactorial [] = return ()
23:05:07 <Blackfoot> but, no, i'm not sure what type its' supposed to be
23:05:20 <dons> well, there's a few things going wrong here. you're mixing IO when you needn't
23:05:34 <dons> so as a result, everything needs to be in IO. i'l let Pseudonym clarify
23:05:37 * dons sleeps
23:05:48 <Pseudonym> Night dons.
23:05:56 <Blackfoot> haha, ok. thanks for the summary :)
23:06:07 <Pseudonym> Right, if that's what you wanted, then do what dons said.
23:06:08 <Pseudonym> However.
23:06:28 <Pseudonym> The main thing here is that you'er conflating two things in the one function.
23:06:40 <Pseudonym> Do you actually want to print "Factorial of 1 is 1"?
23:06:44 <lispy> ?type let putFactorial = putStrLn ("Factorial of " ++ show x ++ " is " ++ show fact) in putFactorial
23:06:46 <lambdabot> Not in scope: `x'
23:06:46 <lambdabot>  
23:06:46 <lambdabot> <interactive>:1:73: Not in scope: `fact'
23:06:52 <Blackfoot> yes, for each element in the lsit
23:06:54 <Blackfoot> list
23:07:01 <Pseudonym> OK, then.
23:07:03 <Pseudonym> I guess it's right. :-)
23:07:15 <Pseudonym> But a Haskeller probably wouldn't express it that way.
23:08:10 <Blackfoot> i originally tried to map a function that took a single digit to a list
23:09:03 <Blackfoot> i'm all ears on how to do it properly
23:09:21 <lispy> > (\n -> (n, product [1..n])) [1..10]
23:09:22 <lambdabot>  add an instance declaration for (Num [a])
23:09:23 <lambdabot>   In an arithmetic sequence: [1...
23:09:31 <dibblego> can you annotate a function with "stuff" that is discovered at runtime?
23:09:38 <lispy> > map (\n -> (n, product [1..n])) [1..10]
23:09:39 <lambdabot>  [(1,1),(2,2),(3,6),(4,24),(5,120),(6,720),(7,5040),(8,40320),(9,362880),(10,...
23:09:42 <Pseudonym> Right.
23:09:44 <lispy> Blackfoot: like that?
23:09:48 <Pseudonym> map is the interesting function here.
23:09:53 <Pseudonym> ?type map
23:09:54 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
23:10:01 <Pseudonym> map takes a function and applies it to a list.
23:10:04 <Pseudonym> map (+1) [1,2,3]
23:10:07 <Pseudonym> > map (+1) [1,2,3]
23:10:08 <lambdabot>  [2,3,4]
23:10:11 <Pseudonym> > map (*3) [1,2,3]
23:10:12 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
23:10:20 <Pseudonym> > map (*3) [1,2,3]
23:10:21 <lambdabot>  [3,6,9]
23:10:24 <Pseudonym> Like that.
23:10:33 <lispy> > map show [1,2,3]
23:10:34 <lambdabot>  ["1","2","3"]
23:10:35 <Blackfoot> right ok
23:10:38 <Pseudonym> So if you have a factorial function:
23:10:43 <Pseudonym> @let fac n = product [1..n]
23:10:44 <lambdabot> Defined.
23:10:50 <Pseudonym> Then you can map it to a list:
23:10:57 <Pseudonym> > map L.fac [1,2,3,4,5]
23:10:59 <lambdabot>  [1,2,6,24,120]
23:11:08 <Pseudonym> (The L, by the way, is a lambdabot thing.)
23:11:21 <Pseudonym> When you @let in lambdabot, it puts the definition in a module.
23:11:27 <Blackfoot> oh interesting, i haven't seen the [1..n] notation
23:11:31 <Pseudonym> The L. is a module qualification.
23:11:33 <Pseudonym> > [1..10]
23:11:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:11:36 <lispy> > [1..4]
23:11:37 <lambdabot>  [1,2,3,4]
23:11:42 <lispy> > [1,3..]
23:11:43 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
23:11:43 <Blackfoot> ok, handy
23:12:17 <lispy> in fact, we could jus say, odds = [1,3..]
23:12:28 <lispy> evens = [2,4..]
23:12:36 <Pseudonym> The thing is, the version which does I/O is actually less useful.
23:12:39 <dibblego> primes =[?
23:12:42 <dibblego> :)
23:12:43 <Blackfoot> and the .. is still lazyily evaluated?
23:12:49 <dibblego> Blackfoot, yes
23:13:00 <lispy> dibblego: you can do the seive
23:13:21 <Pseudonym> > primes = sieve [2..]  where sieve (p:ps) = p : sieve (filter (\n -> n `mod` p /= 0) ps)
23:13:21 <lambdabot>  Parse error
23:13:31 <lispy> Pseudonym: no where allowed
23:13:32 <Pseudonym> Erm.
23:13:48 <Pseudonym> > let sieve (p:ps) = p : sieve (filter (\n -> n `mod` p /= 0) ps) in sieve [2..]
23:13:49 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:13:55 <Blackfoot> so is there a way to print out the pairs as a side effect during the evaluation?
23:13:55 <dibblego> nice
23:13:59 <Pseudonym> No.
23:14:03 <Pseudonym> No side effects allowed.
23:14:10 <lispy> Blackfoot: we can make pairs
23:14:16 <Pseudonym> But there's a monad-type map that also does the trick.
23:14:23 <lispy> > \n -> (n, L.fac n) 2
23:14:24 <lambdabot>    The function `(n, L.fac n)' is applied to one arguments,
23:14:24 <lambdabot>   but its typ...
23:14:29 <wolverian> there's trace too
23:14:39 <lispy> > (\n -> (n, L.fac n)) 2
23:14:41 <lambdabot>  (2,2)
23:14:44 <lispy> > (\n -> (n, L.fac n)) 10
23:14:45 <lambdabot>  (10,3628800)
23:15:17 <Pseudonym> main = mapM_ (\(n,facn) -> putStrLn $ "The factorial of " ++ show n ++ " is " ++ show facn) (map fac [1..10])
23:15:21 <Pseudonym> Errr...
23:15:27 <Blackfoot> ah, i haven't learned that syntax yet
23:15:35 <Pseudonym> main = mapM_ (\(n,facn) -> putStrLn $ show facn) (map  [1..10])
23:15:39 <Pseudonym> main = mapM_ (\(n,facn) -> putStrLn $ show facn) (map fac [1..10])
23:15:44 <Pseudonym> Or somethign.
23:15:44 <Blackfoot> how is the $ used?
23:15:54 <Pseudonym> Oh, $ is low-precedence application.
23:16:00 <lispy> f $ x = f x
23:16:17 <Pseudonym> Function application binds tighter than anything except parentheses.
23:16:23 <lispy> > show $ 1
23:16:25 <Pseudonym> But $ binds looser than anything.
23:16:25 <lambdabot>  "1"
23:16:25 <Blackfoot> oh so it says "grab everything else on the line before you evaluate it"
23:16:32 <Pseudonym> Kind of.
23:16:41 <lispy> > show $ 1 + 1
23:16:43 <lambdabot>  "2"
23:16:43 <Pseudonym> f $ a b = f (a b)
23:16:47 <lispy> > show 1 + 1
23:16:48 <lambdabot>  add an instance declaration for (Num String)
23:17:14 <Blackfoot> ok cool
23:18:16 <lispy> > join (,) 4
23:18:18 <lambdabot>  (4,4)
23:18:20 <Blackfoot> i haven't gotten to the monad stuff yet, so i was just using putStrLn
23:18:53 <lispy> Blackfoot: ironically, you were forceing yourself to use monads :)
23:19:01 <lispy> ?type putStrLn
23:19:02 <lambdabot> String -> IO ()
23:19:05 <lispy> IO is a monad
23:19:30 <lispy> so putStrLn takes a String and turns it into an empty tuple in the IO monad
23:19:54 <Blackfoot> ok
23:20:19 <lispy> for now it may just be easiest to let ghci (or hugs) print things for you
23:20:38 <lispy> and not worry about using putStrLn until you understand monad
23:20:43 <lispy> but that's up to you
23:21:01 <lispy> Blackfoot: and we can recommend tons of monad tutorials :)
23:21:43 <Blackfoot> i'm reading through the "Yet Another Haskell Tutorial" on http://haskell.org/haskellwiki/Learning_Haskell
23:21:46 <lambdabot> Title: Learning Haskell - HaskellWiki, http://tinyurl.com/fac2k
23:22:07 <lispy> Blackfoot: what is your background?
23:22:08 <Blackfoot> is that a good one?
23:22:17 <lispy> probably, although i don't know personally
23:22:20 <Blackfoot> this came up by way of excersize 3.10
23:23:03 <Blackfoot> get a list of numbers from the user, print out the number and it's factorial after all number have been input
23:23:13 <lispy> what languages do you know before learning haskell? (this gives me a feel for your functional programming background)
23:23:23 <lispy> ah, wow
23:23:28 <Blackfoot> functinoal? scheme
23:23:31 <lispy> so they get to the IO pretty quick
23:23:46 <lispy> okay
23:23:52 <Blackfoot> the rest? c(++), perl, ruby, etc
23:23:54 <lispy> i started in lisp :)
23:24:06 <lispy> you're no stranger to higher order functions?
23:24:13 <Blackfoot> correct
23:24:21 <lispy> i've heard that if you're coming from another functional language the gentle intro isn't bad
23:24:42 <lispy> but if you're coming from, say, java then it's misnamed :)
23:24:46 <Blackfoot> i think i'm just confused about the types, especially the monad/IO stuff
23:25:46 <lispy> monads are a big deal in haskell, but once you get them you'll be able to do pretty much anything
23:26:01 <lispy> i remember thinking they were confusing
23:26:06 <lispy> now they're so simple!
23:26:40 <lispy> Blackfoot: i like "tackling the awkward squad" as a tutorial/paper that explains the need and development of the IO monad
23:26:54 <dibblego> which branch of mathematics is the id function an essential part of?
23:26:58 <lispy> when you finish reading the first half of that the IO monad won't have any mystery left
23:27:00 <dibblego> type theory? lambda calculus?
23:27:11 <lispy> dibblego: id :: a -> a ?
23:27:19 <dibblego> lispy, yes
23:27:28 <lispy> dibblego: i can't think of a branch of math that wouldn't need it
23:27:33 <lispy> dibblego: it's everywhere
23:27:48 <dibblego> lispy, like where? I can't google it
23:27:56 * lispy is confused
23:27:59 <Botty> I think I must be missing something, because monads don't seem complicated at all
23:28:10 <lispy> Botty: good
23:28:19 <lispy> Botty: they really aren't but they can seem that way when you don't know them
23:28:33 <Botty> yeah, just like functional programming in general
23:28:36 <lispy> dibblego: id = identitiy function...
23:28:46 <Blackfoot> yes, i've only read the word monad so far
23:28:53 <Botty> the actual language has nothing specific for monads, right? except the do notation that is
23:29:13 <lispy> Blackfoot: a monad is an abstraction to help with data flow or seqencing
23:29:17 <Blackfoot> so, i got the example working by using dons' suggestion, return ()
23:29:23 <Botty> and I suppose the prelude if you count it as part of the language
23:29:36 <Blackfoot> and hopefully i'll understand it as i continue in the tutorial, but i'll be sure to read that doc on monads
23:29:50 <lispy> Botty: right, if you count some of the monad classes as part of the language then yeah it has a lot of support...but if you consider that an add-on then just the do notation i guess
23:30:08 <Botty> alright, good
23:30:14 <lispy> Blackfoot: return is the function to 'inject' a value into a monad (you can think of monads like containers)
23:30:26 <dibblego> what about when you declare a function as say String -> IO () ?
23:30:27 <lispy> Blackfoot: for example, lists are monads
23:30:32 <lispy> > return 1 :: [Int]
23:30:33 <lambdabot>  [1]
23:30:35 <Blackfoot> and what role does 'do' have
23:30:53 <ValarQ> Blackfoot: it's just sugar
23:30:59 <lispy> Blackfoot: do is syntatic sugar to make certain things easier
23:31:17 <lispy> > do { x <- [1]; show x }
23:31:19 <lambdabot>  "1"
23:31:27 <ValarQ> Blackfoot: do { x <- foo; bar }  translates to  foo >>= \x bar  for example
23:31:28 <lispy> >undo do { x <- [1]; show x }
23:31:30 <lispy> ?undo do { x <- [1]; show x }
23:31:30 <lambdabot> [1] >>= \ x -> show x
23:31:36 <Botty> I'm disapointed that liftM# can't just be liftM though. that would be nice
23:32:04 <Botty> probably require some more sophisticated pattern matching stuff tho
23:32:06 <lispy> Blackfoot: i'd show you how that works with IO Int but lambdabot won't let me do IO
23:32:16 <Blackfoot> ok. yea, i haven't seen any of that syntax, so i guess it's back to the books
23:32:20 <lispy> > do { x <- return 1; print x }
23:32:21 <lambdabot>  No IO allowed
23:32:35 <Botty> huh, that sucks
23:33:00 <lispy> Botty: you could probably do a general liftM
23:33:05 <lispy> ?type printf
23:33:06 <lambdabot> forall r. (PrintfType r) => String -> r
23:33:23 <lispy> Botty: looing at printf i can't tell how it takes multiple parameters
23:33:36 <ThreeQ> Blackfoot: it helps to think of a function, say, "String -> IO Integer" as a function that takes a string, and returns an IO action, which, if it were ever run, would give you an Integer
23:33:41 <lispy> Botty: but somehow with a bit of type hackery it does
23:33:49 <Botty> huh, cool
23:33:57 <ThreeQ> you can't actually run any IO actions, but you can stick them together
23:34:31 <ThreeQ> and you attach your huge ball of IO you've composed to the "main" function
23:35:16 <ValarQ> lispy: we could still use many other monads for demos
23:35:20 <ThreeQ> then when the program runs, the ball is slowly un-stuck, evaluating whatever is necessary along the way
23:35:30 <ValarQ> IO is quite heavy to start with anyway
23:35:35 <lispy> ValarQ: yeah, list, maybe, either, writer, reader and so on
23:35:55 <lispy> ValarQ: but, it gets hard to show things like Writer when you only have one line at a time :)
23:36:04 <ValarQ> > do {x <- [2]; return (x*5)}
23:36:05 <lambdabot>  [10]
23:36:24 <lispy> > do { x <- [1..10]; return (x*5) }
23:36:26 <lambdabot>  [5,10,15,20,25,30,35,40,45,50]
23:36:32 <ValarQ> > do {x <- [2]; y <- return (x*5); return (y-8)}
23:36:34 <lambdabot>  [2]
23:36:43 <Botty> hey, is it possible to do something like currying that supplies a middle parameter? eg. (Int -> String -> Int) to (Int -> Int)... Knowing how the parameters work, i can guess the answer is no, but you never know.
23:36:53 <lispy> > do { x <- [1..3]; y <- [1..3] return (x,y) }
23:36:54 <lambdabot>  Parse error
23:36:58 <lispy> > do { x <- [1..3]; y <- [1..3]; return (x,y) }
23:37:00 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
23:37:11 <Cale> Botty: well, you can use things like flip
23:37:22 <lispy> Botty: arrows are probably what you want
23:37:27 <Cale> Botty: but at that point, it's probably best just to use a lambda
23:37:31 <Botty> oh, hadn't thought about that
23:37:47 <ValarQ> Cale: hello mr Gibbard
23:37:50 <Botty> wow, that's obvious
23:37:56 <Cale> hi
23:38:26 <lispy> ?pl flip flip flip flip
23:38:27 <lambdabot> flip flip flip
23:38:27 <Cale> "I'm blind!"
23:38:40 <lispy> ?type flip flip flip
23:38:42 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
23:38:57 <lispy> ?pl flip . flip . flip
23:38:58 <lambdabot> flip
23:39:01 <skeh> what exactly does Eq x accomplish?
23:39:24 <lispy> skeh: my explanation or the correct explanation?
23:39:27 <Cale> skeh: in a type? It says that elements of type x can be compared for equality
23:39:54 <skeh> thank you
23:40:06 <lispy> Foo x => x -> ... -- i read that as, for all x such that x is a Foo..
23:40:31 <lisppaste2> Pseudonym pasted "Fibonacci numbers again" at http://paste.lisp.org/display/28049
23:40:32 <Cale> I tend to think of Foo as a predicate
23:40:39 <Cale> rather than a collection of things
23:40:46 <Pseudonym> lispy: I dare you to work that one out.
23:40:48 <Cale> but those are fairly similar :)
23:41:02 <lispy> Pseudonym: arge, waiting for it to load
23:41:18 <lispy> Pseudonym: oy!
23:41:41 <Botty> x implements Foo in....
23:41:45 <hyrax42> ?fptools Data.Tree
23:41:45 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
23:41:46 <Pseudonym> Let me know if you want a clue.
23:41:55 <vincenz> Yay for reading papers
23:41:58 <lispy> Pseudonym: what am i figuring out?
23:42:04 <Pseudonym> How the hell it works.
23:42:08 <lispy> heh
23:43:11 <lispy> Pseudonym: i just remembered i need to do my study questions NOW ;)
23:43:17 <Pseudonym> :-)
23:43:41 * lispy actually has 4 chapters to read and do 15 questions for each and get to work on time in the morning :)
23:43:57 <lispy> and so your problem is eeeeivl ;)
23:44:09 <Pseudonym> Go do that then.
23:44:42 <Botty> Hmm, has anyone messed with making a system which takes a function, a return value, all its parameter values but one, and returns a/many value(s) for the missing parameter?  In effect, a method of reversing functions.
23:45:21 <thetallguy> ?type iterate
23:45:22 <lambdabot> forall a. (a -> a) -> a -> [a]
23:45:29 <lispy> Pseudonym: bleh, it's a book on OO design...too boring to read 4 chapters/week :)
23:45:47 <Pseudonym> Actually, one of the lines there is redundant.
23:45:56 <lispy> Botty: that sounds like prolog
23:45:58 <Blackfoot> ThreeQ: ok, i'll keep that in mind. big sticky balls :)
23:46:19 <lisppaste2> Pseudonym annotated #28049 with "Removing a redundant test" at http://paste.lisp.org/display/28049#1
23:46:39 <Pseudonym> That's better.
23:46:42 <ThreeQ> the important thing is that you're never actually doing the IO, you're just composing it
23:46:49 <Blackfoot> out of curiosity, what do you guys use haskall for? outside projects? work?
23:46:53 <lispy> Pseudonym: ah yeah, i thought so
23:47:09 <Botty> lispy - prolog might do that.  I haven't messed with it in a while (when I did mess with it, it was only one day).  Would be amazingly cool in haskell though
23:47:15 <lispy> Blackfoot: work, school and darcs when i can find time
23:47:31 <lispy> Botty: you can do prolog using the type system :)
23:47:32 <Pseudonym> Blackfoot: Prototyping stuff for work, and for play.
23:48:02 <Blackfoot> is work web stuff, science, or telco, (etc)?
23:48:45 <lispy> Blackfoot: for me, i work at a traffic simulation company...but i don't get to use haskell when i'm working on the simulation software, but i use it for everything else that ic an
23:48:57 <Blackfoot> wow cool
23:49:21 * lispy has dreams of re-writing the sim software in haskell :)
23:52:52 <lisppaste2> Pseudonym annotated #28049 with "Even more compact" at http://paste.lisp.org/display/28049#2
23:53:36 <lispy> Pseudonym: oh, this new version looks very familiar
23:53:41 <Pseudonym> Does it?
23:53:47 <lispy> yeah
23:53:49 <AI_coder> Who likes maths debating?
23:54:04 <Pseudonym> AI_coder: As a matter of fact, I'm doing precisely that now.
23:54:08 <AI_coder> I do. So much maths to debate, so little time. The thing about maths debating is this: You can do it by yourself. You can do it with a group. You can do it with friends. You can do it anywhere without requiring any special equiptment.
23:54:37 <Cale> AI_coder: that's really not all that funny
23:54:39 <AI_coder> Three cheers for maths debating! Maths debating gets me harder than a integral calculus.
23:54:43 <lispy> Pseudonym: seems like there is a famous sequence that gets used  in some primality stuff that uses that 4*n+1 and 2*n+1...but i dunno, maybe i'm grasping at nothing
23:55:31 <AI_coder> For example, how big is infinity? Maths debating over the size of infinity is a very tricky task, as you can no doubt imagine. You need to stand your ground; make sure you maintain a firm grasp (of reality and the topic at hand) and not get too carried away with it. Infinity is a very large number, that's a fact, but can you quantify it emperically?
23:55:43 --- mode: ChanServ set +o Cale
23:55:47 --- kick: AI_coder was kicked by Cale (Cale)
23:55:53 <Blackfoot> ha
23:55:58 --- mode: Cale set -o Cale
23:56:02 * Pseudonym was frantically trying to work out how to op himself
23:56:09 <Pseudonym> I never use the privs.
23:56:22 <Cale>  /msg chanserv op #haskell
23:56:26 <Pseudonym> Right.
23:56:30 --- mode: ChanServ set +o Pseudonym
23:56:31 <Blackfoot> ok, thanks for the help again. time for me to head out
23:56:32 <Pseudonym> Got it.
23:56:35 <Cale> or if your client has it /cs op #haskell
23:56:52 <ThreeQ> bye!
23:56:55 * lispy laughs to himself as he hits some random keystroke in emacs by accident and finds himself writing an email all the sudden
23:57:18 --- mode: Pseudonym set -o Pseudonym
23:57:20 <Pseudonym> Right.
23:57:28 * Pseudonym will make commands for that later
23:57:54 <ValarQ> #Haskell got the weirdest trolls...
23:57:55 <lispy> oh, math debater is supposed to sound like masterbater...crap that is a bad joke
23:57:56 <Pseudonym> lispy: Where have you see this algorithm before?
23:58:12 <jody> lispy, you're just mad you din't think of it 1st
23:58:22 <lispy> jody: you're right...
23:58:25 <lispy> very angry
23:58:40 <lispy> Pseudonym: i think i was looking at how they do that distributed primality testing
23:58:47 <Pseudonym> Ah, right.
23:58:50 <lispy> is it a Lucas serious?
23:58:52 <lispy> er series
23:59:12 <jody> Many a mathematician has maths debated, alone and with other mathematicians, over an emperical quantification of infinity. Don't be put off by this fact: when it comes to maths debating, it doesn't take long for your average amateur to become a seasoned veteran with a bit of determination and effort.
23:59:13 <Pseudonym> A Lucas series is the same as a Fibonacci series, only using different base cases.
23:59:30 <bsdmonkey> Infinity, by its very nature, can't be measured in any mathematical way, therefore leaving any debate moot.
23:59:42 <Pseudonym> Infinity is a notation, not a quantity.
23:59:48 <lispy> Pseudonym: ah, okay then that's probably not what i was thinking of
23:59:54 <Pete_I> jody, lispy's right. it's a bad joke.
