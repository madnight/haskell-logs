00:00:50 <Lemmih> Have any of you guys tried to build QuickC--? I'm having difficulties locating the 'notangle' tool.
00:04:05 <dons> isn't it an sml noweb-ish program?
00:04:20 <dons> (i.e. an unlit?)
00:05:07 <dons> i think it might actually need just noweb, my portscript for QC-- has: BUILD_DEPENDS+= ::lang/lua-ml ::devel/mk ::devel/noweb
00:05:22 <dons> http://www.eecs.harvard.edu/~nr/noweb/
00:05:24 <lambdabot> Title: Noweb home page
00:06:23 <Smokey`> ?hoogle map
00:06:24 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
00:06:24 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
00:06:24 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
00:07:58 <Lemmih> dons: Thanks.
00:08:49 <fons_> can the @ alias be used with records?
00:09:41 <Lemmih> fons_: Yes, I believe so.
00:09:55 <fons_> maybe I'm not using it properly
00:10:08 <fons_> run sampleN (Instance{_self=hd,_run=f})@ins input ...
00:10:33 <Lemmih> ins@(Instance{...})
00:10:51 <fons_> Lemmih, thanks, I should go to bed ;)
00:11:45 <Smokey`> oh sweet, there's a hoogle plugin for firefox :)  That's just made my day
00:12:03 <Smokey`> saved me a total of 5 mins ;)
00:18:31 <palomer> I can't decide if pugs are butt ugly or cute
00:19:16 * hellish can't tell whether to interpret that as a pun
00:19:40 <palomer> it's a pun?
00:20:22 <hellish> Pugs is the leading Perl 6 interpreter written in Haskell.
00:21:26 <palomer> Many of the features mentioned in the previous answer are specifically aimed at making well-written Perl 6 code even more readable and maintainable than well-written Perl 5 code.
00:21:41 <palomer> even more readable and maintainable  then perl 5 code?
00:21:50 <TSC> Lofty goal!
00:22:08 <Lemmih> dons: Are you using lua4.0 or lua5.0?
00:22:29 <palomer> does perl6 have those silly @ signs before the variable names?
00:34:47 <dons> Lemmih: I think it was 5.0 , but its bee a while
00:34:54 <dons> hellish: hmm?
00:35:03 <dons> it is the leading perl6 implementation, no?
00:35:15 <dons> maybe there should be a comma in there :)
00:38:57 * Lemmih is having tons of problems with qc--.
00:45:58 <desrt_> ok.  i got my parser going
00:46:00 <desrt_> but it's REALLY REALLY slow
00:46:27 <desrt> i was wondering if perhaps someone could look at it and tell me what i could change to make it go faster?
00:46:30 <Baughn> desrt: Use try a lot? (Gimme source!)
00:46:37 <desrt> yes.  lots of try.
00:46:51 <Baughn> Right. You know how try works, right?
00:47:06 <desrt> http://desrt.mcmaster.ca/parser/
00:47:09 <lambdabot> Title: Index of /parser
00:47:11 <desrt> no.  i don't.
00:47:41 <_velco> omg
00:47:42 <Baughn> It stores the current state of the parser. If the try-containing expression fails, it restores the current state of the parser before returning the failure
00:47:58 <desrt> wow.  that seems excessive
00:48:14 <Baughn> It's the minimum necessary. Though it's probably optimized a lot.
00:48:20 <desrt> my parser sucks for a few more reasons on top of that...
00:48:29 <desrt> like its inability to deal with whitespace
00:48:44 <desrt> also note that currently variable and number parsing are broken
00:48:52 <desrt> (variable can be only single characters and numbers may only be "1")
00:49:08 <_velco> desrt: the main problem is that you grammar is left recursive and not suitable for parsec
00:49:20 <desrt> that's what i thought!
00:49:24 <desrt> but someone told me that it wouldn't matter
00:49:26 <desrt> lies.
00:49:37 <Baughn> It doesn't, as such - it still /works/
00:49:44 <desrt> well.  it sucks :)
00:49:55 <_velco> it matters, because it causes exxessive backtracing
00:50:07 <desrt> so what i did was really the best that i could do...
00:50:14 <Baughn> You might want to do things like, say, instead of (try letterm), surround the initial string in letterm with try
00:50:31 <_velco> desrt: eliminate left recursion
00:50:36 <desrt> erm
00:50:44 <desrt> don't i have to change my language to do that?
00:50:45 <_velco> desrt: in expressions
00:50:54 <_velco> no the language, only the grammar
00:51:12 <desrt> uhm
00:51:35 <Baughn> desrt: So you get "expr = letterm <|> ifterm <|> absterm ..."
00:51:56 <desrt> right.  the problem with that is that several terms start with exprs
00:51:58 <Baughn> desrt: The point is to minimize the amount of code running inside a try
00:52:28 <desrt> once i've parsed the expr i don't know what branch i ought to be in
00:52:28 <Baughn> desrt: Well, if you rewrite /all/ the exprs to fail without consuming input - by sticking try at appropriate places - that won't matter so much
00:52:47 <_velco> ugh
00:52:56 <desrt> right... but try("let") instead of try("let " "in" ...) isn't much better
00:53:03 <_velco> rewriting expressios grammar in non left-recursive form is in every textbook
00:53:15 <Baughn> Point here is to minimize the amount of state try has to remember, and thus backtracking.. although avoiding left-recursive form would help even more
00:53:40 <desrt> ok
00:53:42 <desrt> i want to try that
00:53:54 <desrt> but i'm afraid i don't understand how that works
00:54:26 * desrt attempts to find out
00:54:33 <Baughn> If you understand how rewriting on non-left-recursive form works, do that instead. It's far more efficient in the first place.
00:54:57 <desrt> i guess it will cause my grammar to not reflect my AST?
00:55:00 <_velco> or use operator precedence for expressions
00:55:18 <desrt> it seems odd that it's this difficult to parse something so simple :p
00:55:20 <Baughn> ..actually, if it's really left recursive it should end up in an infinite loop. You said it just runs slowly?
00:55:35 <desrt> i prevented the infinite loop
00:55:40 <_velco> desrt: it's not difficult, you've chosen a weak method
00:55:48 <desrt> if you look at my chaining, when it gets to the end all that is left is a rule that _requires_ ()
00:56:05 <desrt> so it must read at least one '(' before looping back
00:57:26 <desrt> _velco; recommendation?
00:57:38 <_velco> rewriting the grammar or using happy
00:57:48 <desrt> happy, eh?
00:58:00 * Baughn accidentally googled for "happy"
00:58:05 <Bobstopper> Hmm... I just signed up to reddit. I don't get the voting system - on the one hand, voting a topic down seems to be intended to adjust the personal scoring so it's easier to find articles that interest you. On the other hand, it's also used to mod down articles for everyone. These seem like orthogonal ideas. I don't know whether I should vote down or not...
00:58:26 <velco> http://www.haskell.org/happy/
00:58:27 <lambdabot> Title: Happy: The Parser Generator for Haskell
00:58:40 * desrt is there :)
00:58:51 <x3m> foxy: there?
00:59:11 <desrt> i guess i want alex too
01:05:49 <vegai> uh-oh: http://programming.reddit.com/info/o96l/comments
01:05:53 <lambdabot> Title: Ask Reddit: OCaml or Haskell? (reddit.com), http://tinyurl.com/y68y79
01:06:09 <dons> seems to be getting a caning on the reddit frontpage though
01:06:20 <dons> mbishop: probably shouldn't have posted it to the main reddit page
01:08:35 <mbishop> meh
01:08:43 <Pete_I> dons, do you /ever/ sleep?
01:08:50 <dons> ?localtime dons
01:08:51 <mbishop> reddit has been going downhill for a while
01:08:53 <lambdabot> Local time for dons is Sun Oct 29 19:08:28 2006
01:09:11 <dons> mbishop: victim of its own success, eh?
01:09:26 <vegai> mbishop: really? I haven't noticed yet
01:09:47 <dons> at least the programming subreddit seems to stay fairly reasonable. the main page is pretty nuts though
01:10:45 <dons> the main reddit page shows what happens when you give in to mob rule: popularism and dumbed down content
01:11:16 <foxy> x3m: pong
01:12:44 <dons> it might be fun to create a fork of reddit, where you must submit a type correct program before you can vote
01:12:52 <dons> that'd keep the standard high
01:12:56 <Smokey`> lol dons.
01:14:01 <foxy> @yar
01:14:02 <lambdabot> Yo ho ho, and a bottle of rum!
01:15:39 <roconnor> I was thinking of exercising this new procedure for library proposals by proposing splitEithers
01:20:28 <desrt> happy gives ironically poor error messages
01:21:19 <bdbit> hi
01:22:35 <x3m> foxy: got some time to help with hs-plugins?
01:26:40 <bdbit> http://paste.lisp.org/display/28909
01:27:13 <bdbit> I disagree with the inferred type, Fractional Int seems to be too lenient
01:27:29 <bdbit> and I'd like to know why multiple lines of "do" don't work when I try it
01:27:59 <foxy_> x3m: having connection difficulties...
01:28:54 <dons> hehe. qwe1234 has woken up
01:29:05 <araujo> hah geez
01:29:06 <bdbit> @localtime dons
01:29:08 <lambdabot> Local time for dons is Sun Oct 29 19:28:44 2006
01:29:54 <int-e> > foldr (either (first . (:)) (second . (:))) ([],[]) [Left 1, Right 2, Left 3]
01:29:56 <lambdabot>  ([1,3],[2])
01:30:08 <araujo> I just wrote some functions in Haskell from an assignment , and they have corrected me the exercises. I was doing it wrong :-}
01:30:17 * araujo scared
01:30:31 <int-e> did they work?
01:30:35 <x3m> foxy: oh.. cant use irc?
01:30:39 <bdbit> > do let x = 1 + 2 in x; let y = 2 * 3 in y
01:30:40 <lambdabot>  add an instance declaration for (Num (m b))
01:30:40 <lambdabot>   In the definition of `y': y...
01:30:43 <bdbit> duh.
01:30:58 <araujo> int-e, hah. they corrected the exercises and prove i was doing it wrong actually
01:31:08 <araujo> :-}
01:31:49 <araujo> It was like .. "hey, wait a minue, this is not the result is supposed to gi .... wait ... oh i was doing the exercise wrong in my notebook ..."
01:35:29 <araujo> Haskell is like the teacher i never had.
01:35:39 <int-e> bdbit: it'd be helpful to paste the error messages, too.
01:36:10 <int-e> bdbit: anyway the 'print' calls have to line up - probably a layout problem?
01:36:43 <int-e> bdbit: possibly caused by a bad tab size.
01:38:40 <araujo> ok, another test, if it works, i will hand sugar lambdas with syrup
01:39:53 * araujo jumps and throws sugar lambdas at everyone
01:40:44 <int-e> messy, yuck!
01:41:00 <roconnor> int-e: We should probably propose a version that doesn't use first and second.
01:41:27 <int-e> roconnor: but it's soooooo cute
01:41:45 <araujo> Isn't it scary that you can write two semesters projects in just one day?
01:42:09 <roconnor> it is cute.  but it brings with it a dependency. ... I suppose we could try to move first and second to the prelude too
01:46:39 <int-e> splitEithers = foldr (either left right) ([],[]) where left  a (l, r) = (a:l, r) ; right a (l, r) = (l, a:r)    isn't too bad.
01:47:50 <int-e> araujo: yes
01:53:30 <desrt> does anyone know how i can tell happy to parse ' ' (where that is the space that occurs inside a function application)?
01:53:43 <desrt> i say
01:53:45 <bdbit> int-e: multiple print statements work now. the parser actually said the layout was wrong, but apparently that wasn't true
01:53:46 <desrt> %right APPLY
01:53:49 <desrt>      | Expr Expr %prec APPLY          { Application $1 $2 }
01:53:54 <desrt> but still i get shift/reduce conflicts :(
01:53:57 <roconnor> int-e: which module does it go in?
01:54:02 <bdbit> but the result is shown in float like "15179.999999999998"
01:54:18 <bdbit> I would like to have it calculated and shown purely in Int
01:55:40 <Heffalump> bdbit: you are probably using / somewhere
01:55:44 <bdbit> Heffalump: I am
01:55:45 <Heffalump> @type '/'
01:55:47 <lambdabot> Char
01:55:51 <Heffalump> doh
01:55:52 <bdbit> @type /
01:55:53 <Heffalump> @type (/)
01:55:53 <lambdabot> parse error on input `/'
01:55:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
01:55:58 <bdbit> heh
01:55:59 <Heffalump> what kind of division do you want?
01:56:06 <bdbit> Int -> Int -> Int
01:56:14 <Heffalump> yes, but how do you want 5/3 to be calculated?
01:56:15 <int-e> roconnor: Data.Either would be most obvious?
01:56:26 <roconnor> oh, there is a Data.Either
01:56:30 <bdbit> Heffalump: there'll never be a fractional outcome
01:56:33 <Heffalump> you should probably use `div`, anyway.
01:56:41 <int-e> yes, it exports one type and one function. great stuff *g*
01:56:42 <int-e> @index either
01:56:43 <lambdabot> Data.Either, Prelude
01:56:44 <bdbit> C(n,k) can't be anything else than Natural
01:56:46 <Heffalump> @type div
01:56:47 <lambdabot> forall a. (Integral a) => a -> a -> a
01:56:51 <bdbit> Heffalump: thanks...
01:56:54 <Heffalump> > 5 `div` 3
01:56:56 <roconnor> @docs Data.Either
01:56:56 <lambdabot>  1
01:56:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
01:57:25 <roconnor> ah, no wonder I've never used it.  It has like one function
01:57:33 <bdbit> Heffalump: that's what I wanted :D
01:57:41 <roconnor> and it is in the Prelude
01:57:45 <int-e> and that function is reexported by the prelude. :)
01:58:40 <int-e> @index catMaybes
01:58:40 <lambdabot> Data.Maybe
01:58:47 <roconnor> Okay, now we need quickcheck properties
01:58:53 <roconnor> hmmm
01:00:14 <int-e> @help check
01:00:15 <lambdabot> check <expr>
01:00:15 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
01:00:43 <Heffalump> check 1==2
01:00:43 <Baughn> @check 2 = 3 + 1
01:00:44 <lambdabot>  Parse error
01:00:49 <Heffalump> @check 1==2
01:00:51 <lambdabot>  Falsifiable, after 0 tests:
01:00:58 <Heffalump> 0!
01:00:58 <Baughn> @check 2 == 3 + 1
01:01:00 <lambdabot>  Falsifiable, after 0 tests:
01:01:09 <Heffalump> @check \x -> x+x == x
01:01:10 <lambdabot>  Add a type signature
01:01:15 <Heffalump> @check \x -> x+x == (x :: Int)
01:01:17 <lambdabot>  Falsifiable, after 0 tests: 1
01:01:18 <velco> @check x = x
01:01:19 <lambdabot>  Parse error
01:01:19 <roconnor> (Left x) `mem` a ==> x `mem` (fst (splitEithers a))
01:01:23 <velco> @check x == x
01:01:23 <Heffalump> 0 tests??
01:01:24 <lambdabot>  Not in scope: `x'
01:01:30 <roconnor> (Right x) `mem` a ==> x `mem` (snd (splitEithers a))
01:01:32 <Baughn> @check (x+y)*(x+y) = x*x + 2*x*y + y*y
01:01:32 <lambdabot>  Parse error
01:01:35 <dibblego> should be "the 0th test"
01:01:37 <Baughn> @check (x+y)*(x+y) == x*x + 2*x*y + y*y
01:01:38 <lambdabot>  Not in scope: `y'
01:01:40 <dibblego> or "1 tests"
01:01:40 <roconnor> and the reverse
01:01:58 <roconnor> x `mem` (fst (splitEithers a)) ==> (Left x) `mem` a
01:02:01 <int-e> filter (either True False) = map Left . fst . splitMaybes
01:02:03 <Heffalump> @check \x -> ((-x) `div` 2) == ((x :: Int)`div` (-2))
01:02:04 <lambdabot>  OK, passed 500 tests.
01:02:06 <int-e> err, Eithers
01:02:15 <roconnor> x `mem` (snd (splitEithers a)) ==> (Right x) `mem` a
01:02:19 <Baughn> @check \x -> \y -> (x+y)*(x+y) == x*x + 2*x*y + y*y
01:02:20 <int-e> @type isLeft
01:02:20 <lambdabot>  Add a type signature
01:02:21 <lispy> ?type mem
01:02:21 <lambdabot> Not in scope: `isLeft'
01:02:23 <lambdabot> Not in scope: `mem'
01:02:40 <xerox-> We need #haskell-playground
01:02:57 <Heffalump> @eval (\x -> ((-x) `div` 2) == ((x :: Int)`div` (-2))) (2^31)
01:02:59 <dibblego> type #haskell-playground = #haskell
01:03:52 <dons> Heffalump: @run
01:03:58 <roconnor> all that is needed is the ordering specification
01:04:29 <roconnor> oh and the number of occurences.
01:04:47 <Heffalump> > (\x -> ((-x) `div` 2) == ((x :: Int)`div` (-2))) (2^31)
01:04:48 <lambdabot>  False
01:04:50 <roconnor> but the number of occurences must be correct because of the polymorphsim
01:04:54 <lispy> or type #haskell-playground = /msg lambdabot
01:05:24 * lispy expects to have a pounding headache tomorrow
01:05:35 <dibblego> on the turps?
01:05:38 * lispy chants his mantra, "water"
01:05:50 <lispy> turps?
01:05:57 <dibblego> alcohol
01:06:00 <lispy> ah yeah
01:06:09 <dibblego> turps == mineral turpentine
01:06:24 <lispy> halloween isn't for a couple days, but tonight is the night for halloween parties
01:06:49 <lispy> and i had plenty of party :)
01:09:55 <Heffalump> if 'ghc-pkg list' says I have a package foo, should I be able to find foo in the package file it says it is listing?
01:10:42 <dibblego> "seems to me like functional purity solves a problem better solved by remembering what your program is doing" -- is that guy joking?
01:10:51 <int-e> @check either (const True) (const True) :: (Either () () -> Bool)
01:10:53 <lambdabot>  add an instance declaration for (Arbitrary (Either () ()))     In the defin...
01:10:56 <int-e> :/
01:11:45 <int-e> roconnor: why don't you just specify the left and right parts of the result in terms of an appropriate filter?
01:12:20 <int-e> roconnor: that subsumes the element tests and the length test.
01:12:28 <integral> dibblego: No, it really is easier remember what a 100,000 line Ada program is doing
01:14:19 * lispy can't remember what a 7 line shopping list is doing
01:14:25 <araujo> @pl (\ c -> isDigit c || isAlpha c)
01:14:25 <lambdabot> liftM2 (||) isDigit isAlpha
01:14:46 <lispy> lambdabot: c'mon....that's a cop out
01:14:48 <araujo> > liftM2 (||) isDigit isAlpha 'C'
01:14:49 <lambdabot>  True
01:14:59 <araujo> mmm...
01:15:04 <lispy> araujo: that depends on Reader having an instance for function
01:15:29 <lispy> iirc (-> r)
01:15:58 <bdbit> can somebody try to translate this to Haskell, please? http://rpaste.com/pastes/531
01:16:14 <bdbit> (it's ruby with comments where it is not universally understandable)
01:16:36 <lispy> dblog: what language is that?
01:16:39 <lispy> ah ruby
01:16:42 <xerox-> ((->) r) lispy, or (r ->) if type level sections were allowed
01:17:26 <roconnor> int-e: ah, smart
01:17:46 <lispy> xerox-: okay, i think i confused ((->) r) for (-> r)
01:18:23 <roconnor> int-e: I suppose we could also rewrite the function as the specification :P
01:19:22 <int-e> roconnor: now that would be cheating.
01:19:39 <int-e> roconnor: the idea would be two have two independent implementations, not to equal ones.
01:19:47 <int-e> *two*
01:20:04 <roconnor> separate but equal
01:20:41 <Heffalump> @hoogle Double -> Int
01:20:42 <lambdabot> No matches, try a more general search
01:21:04 <roconnor> okay, that just leaves documenation
01:21:05 <int-e> @type round
01:21:09 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:21:37 <int-e> @type (floor, ceiling)
01:21:38 <lambdabot> forall a b a1 b1. (RealFrac a, Integral b, RealFrac a1, Integral b1) => (a -> b, a1 -> b1)
01:22:19 <bdbit> Have you guys noticed Firefox *2* is out? http://www.mozilla.com/en-US/firefox/
01:22:20 <lambdabot> Title: Firefox - Rediscover the Web
01:23:46 <int-e> four days ago or so.
01:24:03 <bdbit> I missed it :/
01:28:25 <bdbit> Is anyone considering my ruby example?
01:33:17 <qwr> bdbit: the first one looks like simple recursive function and second just a simple function
01:33:56 <bdbit> qwr: Yah, that's what I am thinking as well, but I doubt I can implement it in Haskell
01:34:06 <bdbit> @type index
01:34:07 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
01:34:10 <bdbit> ouch.
01:37:55 <Botty> its fairly difficult to convert from procedural to functional - basically you have to convert the procedural code back to the "What it does" concept, and then back down to the functional implementation.
01:39:10 <Botty> good names for vars/funcs help too
01:39:19 <Botty> in the first step at least
01:39:20 <beelsebob_> really?
01:39:32 <beelsebob_> why not just create the imperative constructs in a functional language
01:39:42 <Botty> could do that, but what's the point
01:39:44 <int-e> bdbit: that code is strange - k=5 is effectively hard-coded into the ibc function.
01:39:54 <Botty> i think bdbit wan'ts an idiomatic functional implementation
01:40:04 <beelsebob_> Botty: it would convert procedural code to functional...
01:40:25 <beelsebob_> I think what you meant is that it's fairly difficult to convert from procedural code to *good* functional code
01:40:31 <Botty> but not pretty functional :)
01:40:32 <Botty> right
01:40:40 <bdbit> int-e: yes, the starting value for k is always 5
01:41:03 <bdbit> int-e: I had another function which had variable k, but I don't need it, my k is always 5 throughout the program (because I am tackling 5 card hands)
01:41:17 <int-e> and the purpose of the C(n,k)-1-  in both functions eludes me.
01:41:29 <Botty> yeah, what's C?
01:41:39 <int-e> binomial coefficient.
01:42:54 <bdbit> int-e: this algorithm is the one that James McCaffrey uses in this Article: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dv_vstechart/html/mth_lexicograp.asp?frame=true&hidetoc=true
01:42:57 <lambdabot> http://tinyurl.com/t8fzq
01:43:42 <bdbit> ( C(n,k)= ) choose n k = div (fac n) (fac k * fac(n-k))
01:43:50 <bdbit> n over k
01:44:24 <Botty> oh ok
01:44:57 <roconnor> C n k = product [k+1..n] `div` product [1..k]
01:45:22 <roconnor> wait, is that right?
01:45:36 <roconnor> C n k = product [k+1..n] `div` product [1..(n-k)]
01:45:44 <qwr> bdbit: the first cbi function in haskell: http://linux.ee/~mzz/cbi.hs
01:45:45 <bdbit> http://paste.lisp.org/display/28914
01:46:00 <bdbit> this is my try for ibc, it's still syntactically incorrect, though
01:46:01 <qwr> bdbit: it may be buggy and its quite literal translation
01:46:23 <bdbit> roconnor: yes, it can be optimized this way
01:47:55 <bdbit> qwr: very literal, indeed
01:48:15 <bdbit> what's the syntax for arrays?
01:48:27 <bdbit> or, how would that snippet be phrased correctly?
01:48:49 <qwr> bdbit: i used list instead of arrays
01:49:03 <int-e> bdbit: annotated
01:49:04 <bdbit> qwr: I was told arrays are faster
01:49:19 <bdbit> int-e: annotated?
01:49:26 <int-e> bdbit: I annotated your paste.
01:49:31 <bdbit> int-e: what does that mean?
01:49:48 <Botty> look at the paste, and you will see a sexy version
01:49:56 <bdbit> ahhh
01:49:58 <bdbit> :D
01:50:36 <bdbit> wow.
01:50:58 <bdbit> int-e: thanks, I'll have a while to chew on that ;D
01:52:40 <int-e> bdbit: it's not faithful to the ruby code. the C(n,k)-1-  is missing, and I think I turned the list around.
01:52:54 <bdbit> it'll take me a while, even
01:53:14 <bdbit> int-e: ow, I'll *have* to understand it before I use it, then
01:53:29 <int-e> bdbit: but it's a bijection between combinations and integers.
01:54:17 <Botty> one confusing part when i read this was "(\a -> c a k <= n)" -- I'd write it (\a -> (c a k) <= n) for clarity
01:54:20 <bdbit> int-e: how can it be when the C(n,k)-1- is missing?
01:54:21 <int-e> bdbit: or more precisely, of k-element sets of natural numbers (including 0) and the natural numbers.
01:54:47 <bdbit> ah you told me, you turned the list around
01:55:05 <bdbit> ow, that's gonna be tricky
01:55:09 <int-e> bdbit: that C(n,k)-1- bit just turns around the indices ... 0 becomes C(n,k)-1, and C(n,k)-1 becomes 0.
01:55:30 <bdbit> int-e: that's what it's for... I want 0,1,2,3,4 to be index 1
01:55:34 <bdbit> (or 0)
01:55:58 <int-e> well, ibc maps [2,1,0] to 0.
01:56:11 <int-e> ok, I'll hack up versions that reverse the lists.
01:56:39 <bdbit> int-e: I'd appreciate it more, if you explained what all of these things do, then I can restructure it myself
01:59:18 <int-e> bdbit: ok, added another annotation.
01:59:39 <mattr> question for you all
01:59:48 <mattr> I want to get started with GADTs
01:59:59 <mattr> any suggestions on how to learn?
02:00:08 <mattr> with minimum time and confusion :)
02:00:26 <bdbit> int-e: ow, now it's incorrect
02:00:52 <bdbit> it should be [0,1,2] [0,1,3] [0,1,4] [0,2,3] [0,2,4] etc.
02:00:56 <bdbit> if n = 4
02:01:43 <int-e> bdbit: the mapping is an application of the formula Sum_(i=k to n) C(i,k) = C(n+1, k+1)
02:01:46 <araujo> morning
02:03:02 <bdbit> ow.. there's other things broken... c 52 5 does a division by zero
02:03:06 <bdbit> which should absolutely not happen
02:03:42 <bdbit> I think I'll stick wich my version of c n k :D
02:03:49 <int-e> huh?
02:04:05 <int-e> let c n 0 = 1; c n k = c (n-1) (k-1) * n `div` k in c 52 5
02:04:08 <int-e> > let c n 0 = 1; c n k = c (n-1) (k-1) * n `div` k in c 52 5
02:04:09 <lambdabot>  2598960
02:04:22 <bdbit> int-e: http://paste.lisp.org/display/28914#3
02:04:30 <mattr> > 5
02:04:32 <lambdabot>  5
02:04:40 <mattr> > "Thanks bot"
02:04:42 <lambdabot>  "Thanks bot"
02:04:54 <int-e> bdbit: well, yes. you defined the function without the base case
02:05:12 <int-e> bdbit: the second let created a new binding for 'c'. try: let c n 0 = 1; c n k = c (n-1) (k-1) * n `div` k
02:05:56 <int-e> bdbit: on a single line
02:07:09 <bdbit> int-e: oh.
02:07:11 <int-e> bdbit: anyway, the order requirements explain the n-1- and C(n,k)-1- stuff. you can add them again; the first version I pasted is probably better suited for that.
02:07:15 <bdbit> int-e: sorry then
02:08:49 <int-e> bdbit: but conceptually I like the order [0,1,2],[0,1,3],[0,2,3],[1,2,3],[0,1,4],[0,2,4] better.
02:09:05 <int-e> bdbit: because n doesn't affect the formulas then.
02:09:07 <bdbit> int-e: it seems pretty unordered to me.. I like binary counting
02:09:35 <bdbit> int-e: and I can't use it for cards then... with the strictly incrementing order I can index combinations of cards, that's what I am trying to do
02:10:08 <int-e> bdbit: no, they're quite regularily ordered, it enumerates all subsets with maximum element 3, then all with maximum element 4, then with 5, and so on. and it applies the same scheme recursively
02:10:12 <bdbit> because 3 8 19 28 7 is the same as 3 7 8 19 28. but if I had to put that in the order 3 19 8 7 28 for it to work, things would get VERY confusing, I doubt it would even work
02:10:53 <bdbit> int-e: ah, ok. that's not what I'd want for this application though
02:11:09 <int-e> bdbit: I don't understand, the individual lists are all ordered.
02:11:45 <bdbit> int-e: actually, you're correct. I searched so long for this algorithm that I didn't give it a second glance
02:11:51 <bdbit> but how would the partition work then?
02:12:03 <bdbit> why did this guy implement the algo the way he did? >_>
02:12:21 <int-e> you can take the list of cards and sort it, [3,7,8,19,28], feed it to ibc, get 102236, feed that to cbi 5, and get [3,7,8,19,28] back.
02:13:15 <bdbit> int-e: I now see it's correct, but it eludes my understanding
02:13:36 <int-e> bdbit: two guesses a) it's cut&paste code, b) there is some magic requirement on the order of indices in the rest of the code.
02:14:02 <bdbit> int-e: the code I pasted in ruby was written by me, while reading the MSDN article
02:14:18 <int-e> bdbit: which I haven't looked at (nor do I really want to)
02:14:27 <bdbit> and this guy supposedly came up with the algorithm first. But maybe I misunderstood him to start with
02:14:45 <int-e> bdbit: the indexing trick certainly isn't new.
02:14:51 <Botty> it's msdn - to be taken with a bit of salt
02:15:15 <Botty> well, maybe a few kilos of salt...
02:15:20 <int-e> bdbit: I believe I have discovered it myself once. It's definitely described in TAoCP (where exactly, I forgot).
02:15:26 <bdbit> this article was actually recommended to me by a guy in #math, he gave me the wikipedia article ;>
02:16:50 <bdbit> int-e: I think your understanding of the problem exceeds mine by at least an order of magnitude
02:17:07 <bdbit> only thing I'm trying to do is index 5 card combinations ...
02:18:01 <int-e> bdbit: anyway. assume you are encoding n-element sets. your largest element is a. you want to put the sets with smaller largest elements first, and you want to have no gaps.
02:19:44 <int-e> bdbit: there are exactly C(a', (k-1)) sets with maximum element a'. Summing this for a'=k to a, you get Sum(a'=k-1 to a-1) C(a', k-1)  sets that must come before all subsets with maximum element a.
02:21:08 <int-e> bdbit: that sum is C(a, k), so you base the sets with maximum element  a  there, i.e. you encode the remaining (k-1)-element set, and add the resulting index to C(a, k)  (sorry, I changed n to k midway)
02:21:35 <bdbit> that's okay, k is more understandable to me anyway
02:22:03 <int-e> bdbit: if your set is ordered, 0 <= a_1 < a_2 < ... < a_k, you add C(a_k, k) + C(a_(k-1), k-1) + ...
02:22:10 <bdbit> int-e: thanks for explaining. but I guess I'll not get it anyway without having it visualized
02:22:19 <int-e> bdbit: in short: ibc as = sum $ zipWith c as [1..] ;-)
02:22:41 <bdbit> I'll just praise functional programming and take your code as a module
02:23:04 <int-e> bdbit: okay, I'll leave it at that then.
02:23:17 <bdbit> @karma+ int-e
02:23:17 <lambdabot> int-e's karma raised to 21.
02:23:21 <bdbit> let's regard it as finished for now :D
02:23:35 <bdbit> thanks so far
02:23:35 <dons> hmm. is it possible http://haskell.org is down?
02:23:51 <bdbit> dons: seems so
02:23:51 <int-e> bdbit: to his credit he does have some references
02:24:21 <bdbit> int-e: I actually don't care the least bit about this guy, the MSDN library, or any "side effects" of this algo :D
02:24:38 <bdbit> I'm just thankful I don't really *have* to understand it all
02:24:57 <bdbit> although I'm troubled figuring how to understand the Haskell code without understanding the algo
02:25:00 <int-e> bdbit: the 'lexicographic' bit is what makes the algorithm more messy.
02:25:16 <bdbit> int-e: you've convinced me I actually don't need that part
02:28:12 <bdbit> int-e: by taking your first version I'll have to order my combinations descending, right?
02:28:47 <int-e> bdbit: yes.
02:29:00 <int-e> bdbit: I do like the second one better :)
02:29:13 <bdbit> int-e: is it faster or more concise or anything?
02:29:30 <int-e> bdbit: more natural.
02:29:38 <bdbit> it seems slower though.
02:29:56 <bdbit> most natural for me would be the lexicographical ordering
02:30:06 <int-e> even if compiled?
02:31:34 <bdbit> int-e: I don't understand your reversal logic
02:31:50 <bdbit> ah
02:32:06 <int-e> takeWhile is a loop.
02:32:18 <bdbit> well I can't say which one will be faster compiled, it'll probably be optimized to the same code anyway
02:32:32 <bdbit> although I could feel the ordering being an "additional step"
02:32:49 <int-e> bdbit: ok, that part could be optimized better.
02:32:59 <int-e> bdbit: the takeWhile stuff I mean.
02:33:12 <bdbit> int-e: I was on the brink of understanding takeWhile. I guess I do, partly
02:33:46 <bdbit> takeWhile just executes (c a k ) until n is > n
02:34:00 <bdbit> and then takes a from (c a k) and returns it, right?
02:34:23 <bdbit> ah now, It's being put into the list the last element of which is returned
02:34:33 <bdbit> but I don't quite get the \a -> c a k notation
02:34:56 <bdbit> @type takeWhile
02:34:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:35:19 <int-e> > takeWhile (<10) [1,5,2,9,3,13,4,17,5]
02:35:21 <lambdabot>  [1,5,2,9,3]
02:35:30 <bdbit> it's just a selecT
02:35:32 <bdbit> ?
02:35:40 <bdbit> oh, now
02:35:45 <bdbit> no... it's a takeWhile :D
02:36:09 <bdbit> ok I guess I understand it.
02:36:33 <int-e> it should probably be done with a binary search or something like that instead :/
02:36:48 <bdbit> int-e: it doesn't matter, I'll make a table of it anyway.
02:36:52 <int-e> c a k is a monotonous function.
02:37:12 <jmmv> hi
02:37:15 <bdbit> c a k is going to be a table for my use
02:37:24 <bdbit> jmmv: hi
02:37:50 <int-e> bdbit: I mean the last $ takeWhile stuff.
02:38:52 <bdbit> int-e: I don't know what a binary search table is, anyway
02:39:16 <bdbit> I guess I'll have to visit some CS lectures to ever get that kind of stuff
02:39:45 <Syzygy-> Ooooook.
02:39:49 <Syzygy-> This is dangerous.
02:40:08 <Syzygy-> I read through the definition of a triple (=monad) in Toposes, Triples and Theories, and understood surprisingly much of it...
02:40:18 <bdbit> I hate "Ook". I'd rather program in pure BF, than Ook!
02:41:07 <Syzygy-> bdbit: That was more of a reluctant "OK" than a real Ook.
02:41:16 <bdbit> oh
02:41:16 <bdbit> :D
02:52:15 <int-e> bdbit: http://paste.lisp.org/display/28914#4 ... not sure how much faster it is but it should help a bit.
02:52:45 <int-e> bdbit: actually that 51 there should be 52.
02:53:52 <bdbit> int-e: I'd rather think the 51 is correct, because it's a 0-based index
02:54:10 <int-e> bdbit: no, 52 is correct. the number must be at least 1 larger than the largest index.
02:54:16 <bdbit> int-e: oh.
02:54:23 <int-e> bdbit: my mistake.
02:54:35 <Axioplase> Hi !
02:54:42 <ValarQ> hello Axioplase
02:54:42 <Botty> hmm, why is ghc balking on a "foreign import ccall" statement?
02:55:05 <int-e> Botty: that needs -fffi to compile (or -ffi now?)
02:55:14 <Botty> oh, thanks
02:55:21 <Axioplase> What would be a very simple API to draw lines ? (and maybe export to any graphic format)
02:56:27 <Botty> HGL
02:56:32 <Botty> ?where HGL
02:56:32 <lambdabot> I know nothing about hgl.
02:56:36 <Botty> bag
02:56:38 <Botty> bah
02:56:50 <Botty> http://haskell.org/graphics/index.html
02:57:27 <int-e> @where+ HGL http://haskell.org/graphics/index.html
02:57:28 <mattr> what type of lines?
02:57:28 <lambdabot> Done.
02:57:54 <Axioplase> Botty: yeah, I just found out this page, thanks
02:58:13 <bdbit> int-e: ow, I just let you do work that's not really necessary.
02:58:26 <mattr> For jobs like that, if you don'e need animation, writing to a file format that can then be rendered into lines by somthing else works best
02:58:41 <bdbit> int-e: ibc is the much more important function. cbi is only used when initializing the index. it doesn't matter if that takes 4 seconds or 10.
02:58:43 <mattr> For example, write to a .dot file if you need a graph.
02:58:48 <int-e> bdbit: don't worry about it. I'm interested in this.
03:00:32 <Syzygy-> ?where HopenGL
03:00:33 <lambdabot> http://haskell.org/HOpenGL/
03:00:35 <Syzygy-> Ah.
03:02:28 <int-e> bdbit: otherwise I'd probably have left it at the first version :)
03:02:58 <bdbit> int-e: hehe :D
03:03:52 <bdbit> what looping constructs are there in Haskell?
03:03:59 <bdbit> the gentle intro seems to not touch that at all
03:04:23 <int-e> hmm. fold*, map, takeWhile, dropWhile ... explicit recursion.
03:04:52 <int-e> there are no loops. or, as Cale (I think) put it: 'Lists are our loops.'
03:04:57 <bdbit> int-e: what would be an elegant way to say "10^6 times do <code>"
03:05:16 <int-e> replicateM_ (10^6) code
03:05:23 <int-e> @type replicateM
03:05:24 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
03:05:27 <int-e> @type replicateM_
03:05:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
03:06:35 <int-e> so there are  replicateM(_), mapM(_), sequence(_), foldM, too. forM(_) if you have ghc 6.6 (or recent 6.5). note: (_) denotes an optional _.
03:07:05 <int-e> lots of loop-ish stuff, and they're all pure functions.
03:07:16 <bdbit> fine :D
03:07:32 <ValarQ> whats the use of evaluating something 10^6 times? :)
03:07:54 <bdbit> > take 10 $ repeat 1
03:07:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
03:08:03 <bdbit> take 10 $ 1
03:08:07 <bdbit> > take 10 $ 1
03:08:08 <lambdabot>  add an instance declaration for (Num [a])
03:08:23 <bdbit> > repeat 10 1
03:08:24 <lambdabot>    The function `repeat' is applied to two arguments,
03:08:24 <lambdabot>   but its type `a -...
03:08:26 <int-e> ValarQ: monte carlo simulation comes to mind
03:08:29 <dons> ?type mapM_ print [1..10^6]
03:08:30 <lambdabot> IO ()
03:08:34 <Bobstopper> maybe you want to read a file known to be of a format exactly 10^6 times so you use replicateM_ (10^6) getChar :P
03:08:42 <int-e> Bobstopper: ouch
03:08:48 <bdbit> ValarQ: I want to see which version of int-e's code is more performant
03:08:50 <dons> or, forM_ [1..10^6] print
03:09:17 <int-e> introducing forM_ broke some of my code ;)
03:09:33 <ValarQ> bdbit: is it a pure function?
03:09:34 <Bobstopper> ?type forM_
03:09:34 <bdbit> @type repeat
03:09:35 <lambdabot> Not in scope: `forM_'
03:09:36 <lambdabot> forall a. a -> [a]
03:09:40 <bdbit> ValarQ: yes
03:09:46 <bdbit> ValarQ: gonna get cached?
03:09:50 <int-e> forM_ is a flipped mapM_
03:09:51 <bdbit> repeat 1
03:09:54 <bdbit> duh
03:09:57 <Bobstopper> ah
03:10:00 <ValarQ> bdbit: theres a high probablility
03:10:05 <bdbit> ValarQ: ouch.
03:10:27 <bdbit> > repeat 1
03:10:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:10:28 <Botty> hmm, yeah, how do you do such repition performance testing in haskell... hmm
03:10:43 <ValarQ> bdbit: thats one of the advantages with pure functions :)
03:10:54 <int-e> you introduce artificial data dependencies.
03:11:02 <bdbit> ValarQ: does that automatically mean I can leave those lookup tables at the door?
03:11:03 <int-e> or better, true data dependencies.
03:11:08 <Botty> ah yeah, same way IO monad works
03:11:24 <int-e> exactly. in the hope that noone ever discovers time travel.
03:11:55 <ValarQ> bdbit: i guess that depends on the compiler
03:12:14 <bdbit> ValarQ: I'm using GHC
03:12:35 <bdbit> > replicate 5 1
03:12:36 <lambdabot>  [1,1,1,1,1]
03:12:48 <ValarQ> bdbit: then yes
03:13:46 <int-e> @type foldM_
03:13:48 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
03:13:52 <ValarQ> doesn't seem to be any page on Haskell.org about memoization :/
03:13:54 <int-e> @type foldM
03:13:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
03:14:46 <bdbit> int-e: replicateM_ is not in scope (using GHC 6.4.2)
03:14:51 <Botty> ?where memo
03:14:52 <lambdabot> I know nothing about memo.
03:14:58 <Botty> ?where memoization
03:14:58 <lambdabot> I know nothing about memoization.
03:15:01 <Botty> sigh
03:15:03 <Botty> ;p
03:15:06 <int-e> http://haskell.org/hawiki/MemoisingCafs maybe
03:15:08 <lambdabot> Title: MemoisingCafs - The Haskell Wiki
03:16:14 <int-e> http://haskell.org/hawiki/MemoizingRecursion
03:16:14 <lambdabot> Title: MemoizingRecursion - The Haskell Wiki
03:16:23 <int-e> anything in the new wiki?
03:16:32 <dons> ?uptime
03:16:33 <lambdabot> uptime: 5d 9h 11m 48s, longest uptime: 6d 15h 1m 36s
03:16:44 <dons> bdbit: its in Control.Monad
03:16:50 <dons> ?hoogle replicateM_
03:16:51 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
03:16:52 <bdbit> dons: how do I include that?
03:16:56 <bdbit> import Control.Monad?
03:17:02 <dons> "import Control.Monad", yep
03:17:07 <int-e> yes. or, in ghci, :m +Control.Monad
03:17:08 <bdbit> fine, thx
03:17:17 <int-e> for quick tests.
03:17:53 <bdbit> int-e: ghci has a help system anyway :D but I have great trouble finding what I want on haskell.org, especially the Gentle tutorial as I haven't looked into much else
03:19:38 <bdbit> ok, the return value of replicateM_ is not an IO, how can I just run replicateM_ in main?
03:19:59 <bdbit> like ... "main = 1 + 2"
03:20:03 <int-e> m () ... the m is IO in your case
03:20:07 <dons> yeah it is. its polymorphic in the monad
03:20:11 <dons> Monad m => Int -> m a -> m ()
03:20:24 <dons> is polymorphic over all monads
03:20:26 <bdbit> oh
03:20:30 <dons> ?instances Monad
03:20:31 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:20:36 <dons> of whihc there are a few
03:20:46 <int-e> @type let main = replicateM_ 20 (putStrLn "Hello, world!") in main
03:20:47 <lambdabot> IO ()
03:20:49 <bdbit>     Expecting a function type, but found `IO a'
03:20:51 <bdbit> it tells me this :/
03:21:18 <int-e> @type let main = replicateM_ 20 putStrLn "Hello, world!" in main
03:21:20 <lambdabot> ()
03:21:45 <int-e> anyway, a mistake like this could produce such an error I think
03:22:08 <bdbit> I already made sure I use it with $
03:22:19 <int-e> darn, how did my code just typecheck?
03:22:23 <bdbit> main = replicateM_ (10^6) $ cbi2 5 ((c 52 5)-1)
03:22:45 <dons> ?type replicateM_ 20 putStrLn "Hello, world!"
03:22:47 <lambdabot> ()
03:22:53 <bdbit> that doesn't work and I don't know why
03:22:55 <dons> oh, could be a lambdabot wibble
03:22:57 <int-e> ?type replicateM_ 20 putStrLn
03:22:58 <lambdabot> String -> ()
03:23:23 <dons> ah! Monad (-> a) in scope
03:23:34 <dons> ghci sez,     No instance for (Monad ((->) String))
03:23:41 <dons> but we've one available
03:23:45 <bdbit> I'm pretty very surprised lambdabot works so well anyway
03:23:51 <dons> heh, why? :)
03:24:06 <int-e> ?type replicateM 20 putStrLn
03:24:08 <lambdabot> String -> [IO ()]
03:24:11 <int-e> right.
03:24:14 <int-e> ow :)
03:24:17 <bdbit> I've coded bots my self.. no functional ones though ;D (pun intended)
03:24:23 <dons> heh
03:24:55 <Botty> heh, whoever started calling such languages "functional" was a genius
03:25:04 <dons> ?type replicateM_ (10^6) print
03:25:05 <lambdabot> forall a. (Show a) => a -> ()
03:25:13 <bdbit> so, how do I get that line to execute?
03:25:17 <dons> ?type replicateM_ (10^6) (print 'x')
03:25:18 <lambdabot> IO ()
03:25:37 <dons> that line looks ok, so bdbit i guess its something to do with the type of cbi2 5 ((c 52 5)-1)
03:26:22 <bdbit> actually int-e changed the definition
03:26:26 <bdbit> I didn't notice.
03:26:43 <int-e> bdbit: how about this:  main = print . sum . map sum $ [cbi2 5 52 i | i <- [0..10^6]]
03:27:22 <int-e> bdbit: that a) has no chance to share the cbi2 calls and b) forces all of the results. c) produces very little output so that it should be measurable
03:28:28 <int-e> (note that 52 C 5 is about 2.59 million - 10^7 won't work)
03:28:38 <bdbit> int-e: good idea, I guess. but that's what I just wanted to say, too
03:30:26 <bdbit> Stack space overflow: current size 8388608 bytes.
03:30:26 <bdbit> Use `+RTS -Ksize' to increase it.
03:30:27 <bdbit> ouch!
03:30:33 <int-e> ah!
03:30:41 <int-e> use foldl' (+) 0   instead of sum.
03:30:49 <int-e> at least the first one
03:30:50 <bdbit> both times?
03:30:58 <int-e> the second one shouldn't matter
03:31:25 <int-e> @index foldl'
03:31:25 <lambdabot> Data.List
03:31:54 <bdbit> so I've got to import Data.List?
03:31:57 <int-e> yes
03:32:08 <int-e> @index sum'
03:32:09 <lambdabot> bzzt
03:32:33 <bdbit> lol
03:32:58 <bdbit> I hope the slowness is due to the foldl' and map sum
03:33:02 <Syzygy-> Btw. On a previous theme...
03:33:19 <int-e> @index bee
03:33:20 <lambdabot> bzzt
03:33:51 <Syzygy-> > let ! _'_ __ = 4; (!') = `!` in '!'!''!'
03:33:52 <lambdabot>  Parse error
03:33:57 <Syzygy-> > let ! _'_ __ = 4; (!') = `!` in '!' !' '!'
03:33:57 <lambdabot>  Parse error
03:34:01 <Syzygy-> Oh bugger.
03:34:20 <Syzygy-> > let ! _'_ __ = 4 in ! '!' '!'
03:34:20 <lambdabot>  Parse error
03:34:24 <Syzygy-> Ah...
03:34:29 <Syzygy-> > let ! _' __ = 4 in ! '!' '!'
03:34:29 <lambdabot>  Parse error
03:34:33 <bdbit> int-e: your optimization seems pretty good... 2.771s vs. 9.037s on 2 GHz
03:34:41 <int-e> Syzygy-: uhm, ! is an infix operator
03:34:43 <Syzygy-> Nevermind that then...
03:34:45 <Syzygy-> It is?
03:34:51 <Syzygy-> @type !
03:34:52 <lambdabot> parse error on input `!'
03:34:57 <Heffalump> @type (!)
03:34:59 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
03:35:02 <Syzygy-> Ooops.
03:35:09 <Syzygy-> I thought only !! was already defined...
03:35:29 <int-e> Syzygy-: but that's not what I meant.
03:35:29 <Heffalump> (!) is only defined if you use arrays
03:35:50 <Heffalump> but int-e's point is that any punctuation character is an infix operator, never mind whether it's already defined or not
03:35:53 <bdbit> main = replicateM_ (10^5) $ cbi 5 ((c 52 5) - 1)
03:35:54 <int-e> Syzygy-: your expression was: <let> <infix op> <id> <id> <=> <4>
03:35:55 <Syzygy-> Ah.
03:36:00 <Heffalump> ! is infix because it starts with !, not because Data.Array defines it
03:36:01 <bdbit> Couldn't match `IO a' against `[()]'
03:36:15 <int-e> Syzygy-: etc. that doesn't parse, the infix operator must go in the middle or be used as (!).
03:36:20 <Syzygy-> Ah.
03:36:36 <Syzygy-> So I could do things like let a !' b = 4 in '!' !' '!'
03:36:47 <Heffalump> I doubt you are allowed to use '
03:36:52 <Syzygy-> > let a !' b = 4 in '!' !' '!'
03:36:52 <lambdabot>  Improperly terminated character constant
03:36:56 <Syzygy-> Yah.
03:37:04 <Syzygy-> > let (!') a b = 4 in '!' !' '!'
03:37:04 <lambdabot>  Improperly terminated character constant
03:37:04 <Heffalump> > let a ! b = 4 in '!' ! '!'
03:37:06 <lambdabot>  4
03:37:20 <Heffalump> > let a !! b = 4 in '!!' !! '!!'
03:37:20 <lambdabot>  Improperly terminated character constant
03:37:32 <Heffalump> huh?
03:37:36 <int-e> bdbit: cbi is no IO action, you need something to use the result ... and then you'll measure the execution time of that because the cbi 5 ((c 52 5) - 1) will be evaluated once and shared.
03:37:38 <Syzygy-> Heffalump: This springs from a much earlier discussion about seriously obfuscated code with 's
03:37:44 <Syzygy-> Heffalump: '!!' isn't a character.
03:37:51 <Heffalump> oh yeah :-)
03:37:58 <Syzygy-> > let a !! b = 4 in '!'!!'!'
03:37:59 <lambdabot>  4
03:38:05 <bdbit> int-e: that's what I'm trying to verify now. I wanna see it with my own eyes. Because that would mean I don't have to do lookup tables ;D
03:38:14 <Syzygy-> > let _ !! _ = 4 in '!'!!'!'
03:38:15 <bdbit> int-e: how could I use the result?
03:38:16 <lambdabot>  4
03:38:31 <bdbit> the way you did?
03:39:31 <bdbit> I'd like to do it without "disabling the caching" ^^
03:39:40 <int-e> bdbit: hmm. except for measuring performance that problem never occurs ...
03:39:58 <int-e> bdbit: there is no caching, there is only sharing of 'obviously' equal results.
03:40:13 <bdbit> int-e: what's the difference?
03:40:35 <int-e> bdbit: no tables are built.
03:41:06 <bdbit> that means if I use it in different places, it'll be evaluated again?
03:41:32 <int-e> bdbit: if you want to see the effect, try print . sum . map sum $ replicate (10^6) (cbi2 5 52 (c 52 5 - 1))
03:41:39 <int-e> bdbit: yes, it means that.
03:41:46 <bdbit> ow.
03:41:56 <bdbit> that means I _will_ have to build lookup tables
03:42:00 <int-e> yes.
03:49:42 <int-e> The automatic memoization in Haskell is a big misunderstanding, I wonder where it originated.
03:51:47 <int-e> Toplevel *constants* are effectively memoized, maybe that's the source. The reason for this though is again sharing - all code that uses that constant has a reference to the same initially unevaluated thunk and that sharing is never given up.
04:08:19 <Heffalump> @hoogle Int -> Char -> String -> String
04:08:20 <lambdabot> No matches, try a more general search
04:08:35 <Heffalump> is there some kind of padding function?
04:08:43 <Igloo> No
04:09:51 <velco> > let pad n a lst = lst ++ replicate (n - (length lst)) a in pad 10 '.' "abcd"
04:09:53 <lambdabot>  "abcd......"
04:10:05 <Heffalump> velco: yes, I'm capable of writing one myself :-)
04:10:18 <Heffalump> though I actually wanted the padding at the left
04:10:19 * Igloo prefers    take n (lst ++ repeat a)
04:10:22 <velco> ^5 !
04:10:29 <Igloo> Padding at the left is a pain, though
04:10:43 <Heffalump> well, your trick doesn't work without lots of reverses
04:11:00 <Igloo> No, that's why padding at the left is a pain
04:11:09 <Heffalump> I do however have a perfectly working function, and did from about 20 seconds after your 'No' answer :-)
04:11:32 <Heffalump> also, yours isn't correct if you don't want to truncate things that are already longer
04:11:40 <Igloo> True
04:14:24 <dons> > printf "%5s" "foo"
04:14:25 <lambdabot>  Add a type signature
04:14:27 <dons> > printf "%5s" "foo" :: String
04:14:29 <lambdabot>  "  foo"
04:14:48 <dons> > printf "%-15s" "foo" :: String
04:14:49 <lambdabot>  "foo            "
04:15:20 <dons> > printf "%-2s" "foofoofumfumbooboomoomoo" :: String
04:15:21 <lambdabot>  "foofoofumfumbooboomoomoo"
04:15:28 <dons> interesting
04:19:11 <bartw> ellow
04:45:16 <Axioplase> hum.. does ghci give a short explanation of what functions do ? because sometimes, the type ain't enough... (ie: what does "sequence" do ?)
04:47:05 <musasabi> @type sequence
04:47:06 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
04:47:10 <psi> Axioplase: i don't think it can do that
04:47:26 <psi> Axioplase: have hoogle open while you program, perhaps
04:48:04 <musasabi> transform a list of (values in a monad) to a (list of values) in a monad.
04:48:53 <Axioplase> psi: yeah.. I think I'll write down a script for my editor... I use it a lot in OCaml with <C-k>, which shows the corresponding ref page.
04:49:22 <psi> Axioplase: do you use emacs? i have a script for emacs that hoogles the word or type at point
04:49:39 <musasabi> psi: want to link that to the wiki?
04:49:56 <psi> sure
04:51:28 <Axioplase> psi: no, I use the *good* editor ^^
04:54:00 <int-e> oh the subtlety.
04:54:01 <psi> musasabi: do you think i should put it in the haskell mode page?
04:57:06 <musasabi> psi: I think that would be a good idea.
04:58:01 <Axioplase> How do I convert Ints to Doubles ?
04:58:41 <musasabi> > let x :: Int -> Double; x = fromIntegral in x 4
04:58:42 <resiak> @hoogle Int -> Double
04:58:43 <lambdabot>  4.0
04:58:43 <lambdabot> No matches, try a more general search
05:21:57 <psi> musasabi: i put it up now
05:22:07 <psi> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:22:11 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/yyqy4v
05:35:51 <vegai> has anyone written a plotter/symbolic calculator in haskell yet?
05:47:14 <roconnor> how does the transformation to supercombinators work?
05:49:17 <therp> simon p. jones' book has a chapter about compilation to supercombinators if I remember that correctly.
05:49:35 <therp> s/book/implementation of functional programming languages book/
05:49:47 <therp> it's available online
05:49:56 <psykotic> isn't it just lambda lifting + hoisting?
05:50:26 <psykotic> unless you're interested in compiling to a fixed set of supercombinators (e.g. SK)
05:50:30 <therp> no idea, still waiting on my bedshelf to be read.
05:50:48 <therp> I think the chapter is about SK in particular
05:52:16 <xerox3> dcoutts: ping
05:52:22 <xerox3> dcoutts_: ping :)
05:52:24 <dcoutts> hia xerox3
05:52:25 <roconnor> S and K aren't *super*cominators ;)
05:52:52 <roconnor> I was thinking about my problem with shifting and rotating by a constant.
05:53:21 <roconnor> I am wondering if the compiler doesn't optimize the bounds checking away, souldn't the graph reduction do it anyways?
05:53:27 <psykotic> afaik doesn't super just refer to the fact that they're top-level?
05:53:29 <xerox3> dcoutts: oh you can't see my query right? freenode...
05:53:39 <xerox3> I just wonder what's the plan
05:53:58 <roconnor> But I need to understand the type of graphs that my code produces I guess
05:54:10 <dcoutts> xerox3, so what time tomorrow were you thinking of starting off ?
05:54:25 <xerox3> anytime,let's find the best one
05:55:12 <dcoutts> xerox3, well start earlyish as I've got teaching 2-6pm
05:55:20 <xerox3> we were wanting to go to university right? lectures are in the morning here
05:55:32 <xerox3> hehe, great
05:55:38 <xerox3> by here I meant italy
05:55:43 <dcoutts> aye :-)
05:55:53 <dcoutts> xerox3, did you decide if you were going to get the bus or the train ?
05:55:58 <int-e> roconnor: maybe it ends up being 'cheap to recompute, we'll rather unbox it all'.
05:56:05 <xerox3> dcoutts: i think bus is alright
05:56:24 <xerox3> i've found where it starts from.  in front of the google office :)
05:57:05 <dcoutts> xerox3, http://www.oxfordbus.co.uk/espress1.shtml
05:57:08 <lambdabot> Title: oxford espress home page
05:57:24 <dcoutts> xerox3, oh? where is that ?
05:57:51 <xerox3> victoria station!
05:58:09 <xerox3> they've got their office behind buckingham palace
05:58:16 <dcoutts> heh
05:58:35 <xerox3> and they've doubled in size in 4 months
05:58:43 <xerox3> i wonder how much it costs to them.
05:59:37 <roconnor> int-e: unbox it all?  Does it have to be inlined for that?
06:01:38 <xerox3> dcoutts: i'm watching the times, many in the morning
06:01:49 <dcoutts> xerox3, yeah, there are lots
06:02:06 <int-e> roconnor: hmm. I don't know.
06:02:28 <xerox3> dcoutts: if we are not in a hurry any would be fine I think
06:02:37 <xerox3> wait, I don't know how much it takes
06:02:47 <dcoutts> it's about an hour and a bit
06:02:59 <dcoutts> xerox3, I've pm'ed you my home number, do you see it ?
06:03:30 <dcoutts> xerox3, my mobile reception in my flat is very very bad so it's much better to call my house line number
06:05:05 <dcoutts> xerox3, got it ?
06:05:10 <xerox3> dcoutts: do you see my answers?
06:05:16 <fons> hi all
06:05:32 <dcoutts> xerox3, no, because your nick is not registered so I can pm you but not the other way around.
06:05:35 <xerox3> then how did you answer my question! you read my mind.
06:05:42 <dcoutts> hah hah hah
06:05:46 <xerox3> yay
06:06:03 <xerox3> i'll call you up when i'm on the bus ok?
06:06:07 <dcoutts> sure
06:06:20 <xerox3> great, i'll go back to socialize now :)
06:06:28 <dcoutts> xerox3, any estimate of what time ? 7am 11am ? :-)
06:06:39 <xerox3> dcoutts: what do you prefer?
06:06:57 <dcoutts> xerox3, I don't usually get up before 9 or 10am :-)
06:07:05 * dcoutts is a lazy _|_
06:07:11 <xerox3> haha
06:07:21 <xerox3> perfect, it'll be after 10 am
06:07:49 <dcoutts> ok
06:07:54 * roconnor got up an hour early today
06:07:58 <xerox3> do I read right that there is one every 20 mins after 8:10?
06:12:16 <dcoutts> xerox3, yes.
06:12:43 <xerox3> fine.
06:12:49 <xerox3> oh, I didin't tell you
06:13:20 <xerox3> when I was giving the lightning talk about my project, i've asked how many people knew haskell, and two hands (and a half) were raised
06:14:59 <xerox3> i've been talking briefly about cairo and cabal-get, and at the time i was explaining the work done with the former, after mentioning that the demo program i made was used as practical by my mentor at Oxford university, for first year students, it turned out that one of the guys that raised the hand previously was such a student!\
06:16:51 <xerox3> gotta get out and wanderin london again
06:17:12 <xerox3> i've got plenty of mathematical people, strangely enough, to talk with this afternoon :)
06:17:23 <xerox3> i'll tell you later, bye!
06:17:32 <dcoutts> xerox, heh, nice
06:19:59 <ndm> @seen roconnor
06:20:00 <lambdabot> roconnor is in #ghc and #haskell. I last heard roconnor speak 12m 5s ago.
06:20:34 <ndm> roconnor: i spoke with my supervisor, he agrees i should shove out a release of Yhc -O sometime in the next 2 weeks, so you'll be able to play with it soon enough (and get the source)
06:20:35 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:21:04 <roconnor> ok
06:21:17 <ndm> dons: as soon as i search multiple packages properly, they will do :)
06:21:23 <ndm> @tell dons as soon as i search multiple packages properly, they will do :)
06:21:24 <lambdabot> Consider it noted.
06:21:38 * roconnor stops hacking ndm's computer
06:22:00 <ndm> roconnor: the code is publically available, its just impossible to configure and compile for anyone but me :)
06:25:02 <vegai> hmm, can't I use let with lambdabot's check
06:25:10 <vegai> @check let f x = sqrt $ 1 - sqrt x; g x = sqrt x; h x = 1 - sqrt x; in f = g . h
06:25:10 <lambdabot>  Parse error
06:25:18 <vegai> or is there some other error there
06:25:25 <ndm> @check True
06:25:27 <lambdabot>  OK, passed 500 tests.
06:25:34 <ndm> @type let f x = sqrt $ 1 - sqrt x; g x = sqrt x; h x = 1 - sqrt x; in f = g . h
06:25:36 <lambdabot> parse error on input `='
06:25:48 <ndm> vegai: it doesn't parse :)
06:25:52 <vegai> yeah... hmm
06:26:01 <int-e> @check let f x = sqrt $ 1 - sqrt x; g x = sqrt x; h x = 1 - sqrt x; in f == g . h
06:26:02 <lambdabot>  add an instance declaration for (Eq (a -> a))     In the definition of `zji...
06:26:16 <vegai> oh right, the = vs ==
06:26:35 <vegai> @check let f x = sqrt $ 1 - sqrt x; g x = sqrt x; h x = 1 - sqrt x; in f x == (g . h) x
06:26:36 <lambdabot>  Not in scope: `x'
06:26:39 <vegai> oh well.
06:27:15 <int-e> @check let f x = sqrt $ 1 - sqrt x :: Double; g x = sqrt x; h x = 1 - sqrt x; in \x -> f x == (g . h $ x)
06:27:17 <lambdabot>  Falsifiable, after 2 tests: -3.4
06:27:31 <vegai> ...really?
06:27:56 <vegai> oh, but it's not defined when x=-3.4
06:28:19 <int-e> @check let f x = sqrt $ 1 - sqrt x :: Double; g x = sqrt x; h x = 1 - sqrt x; in \x -> 0 <= x && x <= 1 ==> f x == (g . h $ x)
06:28:21 <lambdabot>  Arguments exhausted after 119 tests.
06:28:36 <vegai> ;-)
06:28:49 <vegai> damn, that's nice.
06:29:58 <int-e> arguments exhausted?!
06:30:30 <ndm> int-e: out of randomness
06:30:45 <int-e> @check \x -> (x :: ()) == x
06:30:51 <lambdabot>  OK, passed 500 tests.
06:30:58 <ndm> @scheck \x -> (x :: ()) == x
06:31:00 <lambdabot>  Completed 1 test(s) without failure.
06:33:34 <int-e> @check \x -> x /= () ==> (x :: ()) == x
06:33:35 <lambdabot>  Arguments exhausted after 0 tests.
06:33:39 <int-e> aha.
06:34:21 <ndm> @scheck \x -> x /= () ==> (x :: ()) == x
06:34:22 <lambdabot>  Completed 1 test(s) without failure.  But 1 did not meet ==> condition.
06:34:54 <int-e> if the precondition fails the test isn't counted, and a new sample generated. the limits lambdabot uses are 500 tests and 1000 samples.
06:35:15 <int-e> so 119 of the 1000 samples for double were between 0 and 1.
06:35:42 <int-e> interesting
06:44:20 <bdbit> gotta play some hitman.. l8r
06:52:24 <Axioplase> Hum, with hs-gtk.. when I do a "moveTo", isn't it supposed to change the position of currentPoint ?
07:34:35 <draganov> hello falks....
07:34:45 <draganov> im trying to do something like this:
07:34:46 <draganov> getSystem :: (Float,String,Rules) -> Int -> a
07:35:30 <draganov> getSystem :: (Float,String,Rules) -> Int -> agetSystem (angle, base, rules) 1 = angle
07:35:39 <draganov> but getting a type error...
07:37:10 <Lemmih> draganov: getSystem :: (Float,String,Rules) -> Int -> Float?
07:37:11 <Heffalump> draganov: that function will be very hard to write
07:38:06 <ndm> Heffalump: its really easy to write, since it has only two possible results _|_ error or _|_ nontermination :)
07:38:16 <Heffalump> :-)
07:39:37 <Heffalump> draganov: the type you want to give it means "given a Float,String,Rules triple and an Int, this function will return any type the caller wants"
07:39:57 <Heffalump> which means it is impossible to write a useful implementation
07:41:49 <Lemmih> Prelude Data.Typeable> print (fn (' ',False, ()) 0::Char) ' '
07:41:49 <Lemmih> Prelude Data.Typeable> print (fn (' ',False, ()) 1::Bool) False
07:41:49 <Lemmih> Prelude Data.Typeable> print (fn (' ',False, ()) 2::()) ()
07:42:00 <draganov> i have a a tuple of Float, String Rules, and im trying to write a generic func to return a any of them by index...
07:42:04 <draganov> is it possible ?
07:42:08 <Heffalump> draganov: no
07:42:20 <Heffalump> it wouldn't be type safe
07:42:30 <draganov> hmm,,,
07:42:44 <Lemmih> Heffalump: It would be with some Data.Typeable magic.
07:42:46 <Heffalump> (well, unless you make the return type (Either Float (Either String Rules)) or something like that
07:42:48 <draganov> what should i do then, write a fucn for each type ?
07:42:53 <Heffalump> draganov: yes
07:43:10 <Lemmih> draganov: Or use a record.
07:43:23 <draganov> what is record ?
07:44:04 <Lemmih> draganov: data System = System { getFloat :: Float, getString :: String, getRules :: Rules }
07:45:16 <draganov> and what i return ? -> System (which can be any of those?)
07:46:19 <Lemmih> draganov: Say again?
07:47:35 <draganov> so if i want to return any type dynamicly...?
07:47:54 <Lemmih> draganov: You don't want that (:
07:48:08 <draganov> i still need to declare thich type i return
07:48:11 <draganov> am i ?
07:49:31 <Lemmih> draganov: Haskell is statically typed, using dynamic typing is just not an option.
07:55:51 <mathewm> Haskell has some dynamic typing features
07:56:35 <mathewm> ?hoogle Typeable
07:56:37 <lambdabot> Data.Typeable :: module
07:56:37 <lambdabot> Data.Typeable.Typeable :: class Typeable a
07:56:37 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
07:57:29 <draganov> isnt polymorfism is all about...
07:57:50 <dcoutts> draganov, polymorphism is all about static typing :-)
07:58:12 <dcoutts> yes, there is some dynamic typing but it's probably best to ignore that
07:58:51 <dcoutts> you very very rarely need it and it adds a good deal of syntactic overhead, it's not the way things are normally done.
07:59:20 <Lemmih> mathewm: Indeed, as mentioned above.
08:00:18 <monstre> Any book recommendations for someone who's trying to learn about Haskell and functional programming in general?
08:01:05 <therp> monstre: what have you seen so far in the realm of programming?
08:01:34 <dcoutts> monstre, http://haskell.org/haskellwiki/Books_and_tutorials
08:01:37 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
08:02:00 <monstre> I'm looking at that page, anyone can narrow it down for me?
08:03:31 <dcoutts> monstre, I'd recommend Thompson's book.
08:03:33 <ndm> monstre: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
08:03:35 <lambdabot> http://tinyurl.com/p6ooc
08:03:38 <monstre> therp: I've has some limited exposure to Scheme, but that's about it as far as functional programming is concerned
08:03:49 <ndm> monstre: unless of course you haev money, in which case a nice book might be better
08:10:16 <monstre> Has anyone read Hudak's book?
08:10:45 <ndm> School of Expression?>
08:10:52 <monstre> yes
08:11:33 <ndm> no, but i do know its quite out of date with a few bits of old functions etc, so sometimes that is a bit confusing for some people
08:14:07 <ndm> i know a few people who recommend Bird+Wadler
08:15:10 <monstre> title?
08:15:21 <monstre> it doesn't seem to be on the Wiki...
08:15:57 <Igloo> Introduction to Functional Programming
08:16:01 <ndm> http://www.amazon.ca/Introduction-Functional-Programming-Bird/dp/0134843460
08:16:06 <lambdabot> http://tinyurl.com/yg5h7z
08:16:15 <vegai> I'm currently working of SoE
08:16:18 <vegai> of->on
08:16:45 <vegai> personally, I'm not so fond of the graphics parts
08:16:57 <vegai> but that's my problem more than the book's
08:17:06 <monstre> thanks, the Wiki only listed Richard Birad as authoer, hence my confusion...
08:17:20 <monstre> make that author
08:17:57 <Heffalump> Bird+Wadler is probably out of print
08:18:00 <Heffalump> it's the first edition
08:18:14 <Heffalump> the second edition is "Introduction to Functional Programming using Haskell" and is just by Bird
08:18:28 <Heffalump> many people say they prefer the first edition
08:18:37 <arcatan> btw, what's this ctm book about?
08:18:46 <Heffalump> ctm?
08:19:01 <monstre> Concepts, techniques, and Models of Computer programming?
08:19:06 <arcatan> yeah
08:19:17 <monstre> It's the Oz book
08:19:46 <arcatan> yeah, I know, I'm just wondering what kind of book it is
08:20:05 <pave1> it's pretty good
08:20:12 <pave1> covers a lot of stuff
08:20:43 <monstre> I've only had a brief look at an early draft, but it seemed to cover a lot of ground
08:30:49 <Heffalump> it's gone all quiet
08:40:22 <draganov> how i can cast from Char to String ?
08:40:43 <Botje> [x]
08:40:50 <Botje> type String = [Char]
08:40:54 <draganov> 10x
08:40:55 <Botje> so just make a list with one element
08:41:01 <velco> > let s x = [x] in s 'a'
08:41:04 <lambdabot>  "a"
08:52:55 <as> anyone alive in here?
08:53:12 <EvilRanter> no.
08:53:21 <as> nice ;)
08:53:36 <EvilRanter> speak for yourself, assembler-boy
08:53:54 <Heffalump> nothing wrong with assembler
08:54:00 <as> assembler boy?
08:54:28 <Heffalump> 'as'
08:54:30 <Heffalump> I guess
08:54:42 <EvilRanter> (is it bad that i thought of the unix assembler before i thought of the preposition?
08:54:51 <as> lol
08:54:52 <EvilRanter> )
08:55:13 <as> yeah that implies too much time in language rooms
08:55:55 <as> but didn't drop by to chat about unix or any other asm for that matter
08:56:41 <as> i was wondering if someone could help me with some haskell syntax, for i'm a bit new to the language
08:56:47 <ozone> dons: eh,m  what fud? :)
08:56:47 <lambdabot> ozone: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:57:23 <musasabi> as: ask rather than ask whether you can ask.
08:57:33 <as> just a preamble
08:59:47 <as> i'm not sure i understand what the ' syntax mean like func x = x' -> ...
09:00:25 <integral> It doesn't have any semantic meaning.  It's just another symbol that you can put in (at the end of) a variable name
09:00:29 <musasabi> ' is just a part of the name.
09:00:55 <musasabi> just like in math you can call variables "x" "x'" etc
09:01:09 <as> so its a "prime"
09:02:04 <integral> quite :)
09:03:07 <as> cause i have a snippet of code and though i understand what it does as a whole i'm not sure i'm grasping its functionality on a line by line basis
09:04:40 <as> func (C a b) (C c d) =
09:05:11 <as> case func b c of
09:08:59 <ndm> dcoutts, regarding the package configuration discussion you're currently having on the mailing list
09:09:06 <dcoutts> ndm, aye
09:09:30 <Igloo> Oh, I need to read that properly at some point
09:09:42 <dcoutts> Igloo, yes, stand up for the binary packing folk
09:09:44 <ndm> dcoutts, it seems awfully complex! have you thought about trying to summarise the "proposal" in a single page on the wiki - because if its more complex than that, no one wlil ever be able to use it or implement it properly!
09:10:06 <ndm> dcoutts, i would stand up for the windows folk - but my eyes cloud over and my brain switches off
09:10:07 <dcoutts> ndm, yeah, I was just thinking about putting it on a wiki and then ajusting it as we refine it
09:10:21 <dcoutts> ndm, we need some sensible use cases
09:10:23 <ndm> dcoutts, a good set of examples would really help as well - some use cases
09:10:30 * Igloo winces at the size of the thread
09:11:00 <dcoutts> Igloo, it'd really help if you could contribute the ghc core lib examples
09:11:08 * ndm cries that Windows may forever be known as Mingw in haskell land
09:11:18 <dcoutts> ndm, fix it!
09:11:21 <ndm> (even when I don't have mingw installed on this computer!)
09:11:32 <dcoutts> ie what do you want configurations for in the ghc base/core libs
09:11:35 <ndm> dcoutts, i intend to raise a GHC bug on it
09:11:44 <ndm> and a Hugs bug as well
09:11:48 <Igloo> dcoutts: I think the example is just   build-dep: if_ghc(ghcbase), if_hugs(hugs_base), ...
09:12:21 <as> ok here we are..
09:12:24 <as> func (C a x b) (C c y d) =
09:12:25 <as> case func b c of
09:12:25 <as> C b' z c' -> C (C a x b') z (C c' y d)
09:12:25 <as> bc -> C a x (C bc y d)
09:12:30 <dcoutts> Igloo, btw, would you need to different sets of exposed modules ?
09:12:35 <dcoutts> to//
09:12:57 <Igloo> Not if I can help it...
09:13:05 <dcoutts> Igloo, I agree with you that it'd be nice to avoid if possible
09:13:21 <dcoutts> and then not allow it in configurations
09:13:45 <ndm> definately, otherwise you guarantee writing software that breaks in some versions
09:14:02 <fons> hi ndm :)
09:14:03 <ndm> i would also love to enforce that all modules must have the same export list and types in all configurations
09:14:05 <ndm> hi fons
09:14:09 <Igloo> Incidentally, one case to consider with the meaning of   p (>1), p(<2) type things is packages that provide data updating functions and thus need p (=1) and p(=2)
09:14:32 <fons> ndm, I think I'm finally gonna use yhc.Core for my project (don't know if you remember about it)
09:14:35 <dcoutts> Igloo, that's a difficult area.
09:14:56 <ndm> fons: remind me quickly :)
09:15:09 <dcoutts> Igloo, only a package knows if it can cope with different versions. Typical packages will fail if you build them with multiple versions.
09:15:10 <Igloo> Yeah; it needs the grafting proposals too
09:15:18 <ndm> fons: i'm actually revising Yhc.Core and polishing it to make it even easier to use, and there is another user already - so its getting more and more stable
09:15:24 <musasabi> ndm: how would that work with conditionally exporting unit testing things?
09:15:36 <ozone> dons: blog entry updated.  (i'm putting a new website online, so it'll be updated when the website goes live)
09:15:42 <ndm> musasabi: thats an exception i'm happy to allow
09:15:48 <ndm> (but hadn't though of :))
09:15:55 <dcoutts> ndm, then it needs to be allowed in general
09:16:16 <dcoutts> and we must just rely on social pressure as musasabi suggests
09:16:19 <fons> BTW, does anyone now about a library variant of fold which stops folding and resturns the dolded value given certain condtion? (in the same way as (!!) )
09:16:39 <ndm> scan ?
09:16:39 <Igloo> We don't really have any way to enforce it, other than social pressure
09:16:40 <fons> ndm, a translator from Haskell to VHDL
09:16:53 <fons> s/dolded/folded
09:17:12 <dcoutts> Igloo, sure we do. We don't allow it. We don't allow it now and I don't see anyone complaining.
09:17:18 <ndm> fons: ah yes, i remember - i'm just writing something so you can generate a Yhc.Core file that has had full program linking done, so just one file with all the needed bits of the prelude etc - should be useful for you
09:17:28 <Igloo> dcoutts: Huh?
09:17:53 <musasabi> dcoutts: we already do it with cpp in many places.
09:17:59 <dcoutts> Igloo, right now you have to always expose your unit testing things or never. There's no contidional thing.
09:18:10 <Igloo> There's cpp, like musasabi says
09:18:12 <dcoutts> musasabi, ok, true, so it's in the same module rather than different modules.
09:18:15 <musasabi> #ifdef DEBUG. lots of code does it.
09:18:22 <fons> ndm, good :) A question I have regarding Yhc.Core is ... how to get info about types?
09:18:24 <dcoutts> I'd be happy to keep it that way.
09:19:32 <dcoutts> musasabi, is everyone clammoring to be able to move that unit test into different modules?
09:19:37 <ndm> @paste
09:19:38 <lambdabot> http://paste.lisp.org/new/haskell
09:19:50 <dcoutts> it's easier in the module since it then has access to stuff that isn't exported
09:19:51 <lisppaste2> ndm pasted "For fons, type information from Yhc.Core" at http://paste.lisp.org/display/28929
09:20:11 <fons> thanks ndm
09:20:13 <ndm> fons, what info do you want about the types? the type of a specific function, or the structure of a type in general?
09:20:17 <musasabi> dcoutts: yes, but the test itself has to be exported so it can be called from outside the module.
09:20:49 <fons> ndm, I want to filter things which cannot be translated to VHDL
09:20:49 <ndm> dcoutts, i am clamouring for testable internal functions to be exported
09:20:55 <ndm> fons: such as?
09:20:57 <fons> ndm, for example, high order
09:21:10 <fons> higher order
09:21:19 <ndm> fons: if you translate out higher order bits from Haskell, you'll have nothing left, pretty much literally
09:21:38 <dcoutts> musasabi, ndm, right. But what I mean is, is this issue of unit tests a motivating example for allowing the set of exposed-modules to be changeable in a configuration stanza.
09:21:39 <ndm> fons: however, i have a convertor from full haskell to first order Core, so that should be _exactly_ what you want
09:21:59 <musasabi> dcoutts: that is for allowing export lists to change.
09:22:00 <fons> ndm, is it included in the library?
09:22:09 <draganov> http://paste.lisp.org/display/28930
09:22:19 <ndm> fons: no, and its not released, but i hope to release it this week or next
09:22:33 <fons> ndm, good :)
09:22:43 <ndm> fons: it integrates with Yhc.Core, and I can provide a Yhc.Core back end for it - then you can just use the existing Yhc.Core bits
09:22:44 <draganov> any ideas why im getting an error: Syntax error in input (unexpected `|')
09:22:48 <dcoutts> musasabi, exactly, it's only export lists, not the set of exposed-modules. So what's the use case for changing the exposed-modules? I havn't seen any good ones yet.
09:23:09 <musasabi> dcoutts: one can always use CPP and export lists to do stuff with the same effects as changing exposed modules.
09:23:25 <dcoutts> musasabi, exactly, so no need to allow changing exposed modules.
09:23:27 <musasabi> dcoutts: personally I would prefer not having to fidle with cpp.
09:23:27 <dcoutts> There was one example in Gtk2Hs, but it can be done in a cleaner way.
09:23:42 <musasabi> dcoutts: how about the deprecating a module?
09:23:50 <dcoutts> musasabi, but your unit tests have to go in the same module anyway.
09:24:13 <dcoutts> musasabi, ah ok, so you want to be able to --disable-deprecated and not expose the deprecated module at all.
09:24:22 <musasabi> yes.
09:24:36 <dcoutts> isn't -Werror good enough for that ?
09:24:53 <musasabi> and in a few versions to --enable-ancient-feature-foo.
09:24:58 <dcoutts> or just read the deprecation warnings
09:25:11 <musasabi> dcoutts: no. if the module depends on a package that is otherwise not needed.
09:25:32 <dcoutts> musasabi, yeah. I don't like it though. :-)
09:26:07 <musasabi> dcoutts: I think it is worse to just conditionally make the module blank with CPP. And the "no changing exposed modules" makes configurations more complex, not simpler.
09:26:27 <fons> ndm, regarding the question about folding ... I didn't mean anything like scan. What I need is something which folds but returns the folded value given certain predicate
09:27:08 <dcoutts> musasabi, my opinion is that the cases where it's needed are few and having to use cpp in those cases (as people already do) is not so bad.
09:27:33 <dcoutts> compared to us making it easy and people doing it much more.
09:27:37 <musasabi> dcoutts: and it is worth complicating things?
09:27:51 <dcoutts> we're not banning anything
09:28:07 <musasabi> as we have a subset of allowed fields rather than the same fields in all places. (if we disable exposed-modules there)
09:28:09 <bdbit> hi all
09:28:13 <dcoutts> just not deciding not to allow something we could choose to allow.
09:28:14 <fons> ndm, What I want is a way to generalize functions like (!!) which are not implemented with fold because it is not required to go through the whole list
09:28:39 <Heffalump> lazy evaluation means you don't need to go through the whole list anyway
09:28:44 <dcoutts> musasabi, some fields don't make sense either, like the informational ones. name, version etc.
09:28:45 <Heffalump> (even when using foldr)
09:28:52 <bdbit> is there a resource where I can aquire chunks of elegant BUT understandable Haskell example code? (real programs that are commented well, examples from a book...)? (it should be available online)
09:28:53 <ndm> fons: for fusion?
09:29:01 <dcoutts> musasabi, so it's already a subset.
09:29:07 <Heffalump> (!!) isn't implemented with foldr because it can't be (directly)
09:29:49 <fons> Heffalump, I know, what I want is to know if there is a generalization of functions like (!!) already in the library
09:30:12 <ndm> it can be done with foldl and zip
09:30:52 <musasabi> dcoutts: don't we just complain that they are duplicate?
09:31:17 <dcoutts> musasabi, I suppose so, doesn't matter really.
09:31:25 <dcoutts> musasabi, I don't think we should get too held up on this qustion. It's an easy one to implement. It's just a decision. There are other grey areas that need more thought.
09:31:32 <musasabi> true.
09:31:42 <musasabi> And it can be changed later easily.
09:31:45 <dcoutts> yes
09:32:05 <bdbit> btw. folks, what would you assume, are our brains programmed functionally or imperatively? or something else? (yah, I know, they're neural nets, but there must be some logic layer above that)
09:32:20 <dcoutts> as I suggested originally, we can start by not allowing it (as that is the current situation) and enable it later if there is real demand and use cases.
09:32:28 <musasabi> I wish my brain would work functionally.
09:32:39 <bdbit> I suspect mine does
09:33:20 <musasabi> dcoutts: true. HAppS will probably have the deprecation case soonish.
09:33:23 <bdbit> At least on a core level. Logically I'm awfully imperative :>
09:33:59 <musasabi> I think it is something like logic programming, with a buggy interpreter.
09:34:17 <musasabi> but CPP is good enough.
09:35:02 <musasabi> dcoutts: how do you feel about the functional vs constraint solving one?
09:35:41 <dcoutts> musasabi, I don't think I know what you're suggesting with the functional one.
09:37:25 <musasabi> dcoutts: backtracking vs no-backtracking. Does an expression produce a Boolean or a set of package constraints.
09:38:48 <dcoutts> musasabi, so how do we do it with no backtracking ? it'd be nice.
09:39:27 <palomer> you're all nuts!
09:40:09 <dcoutts> musasabi, my example is (assume we have foo-2.0 and 1.0): build-depends: foo; configuration: os(windows); build-depends: foo < 2.0
09:41:08 <as> anyone knowledgable feel like stepping a few lines with a rookie?
09:41:55 <bdbit> as: I want to append to that
09:42:23 <as> append to what?
09:42:34 <bdbit> as: I'd like to take part in the stepping
09:42:51 <dcoutts> musasabi, It's not clear to me how we just return a set of constraints since how we calculate them depends on the packages we're using.
09:43:03 <EvilRanter> as, go on, then
09:43:33 <as> k
09:43:52 <as> func (C a x b) (C c y d) =
09:43:52 <as> case func b c of
09:43:52 <as> C b' z c' -> C (C a x b') z (C c' y d)
09:43:52 <as> bc -> C a x (C bc y d)
09:44:11 <musasabi> dcoutts: just specify the build-depends after the configuration and it works.
09:44:37 <dcoutts> musasabi, but then what does 'using' mean ?
09:44:47 <as> in case you can't tell C is a construct of C ? C
09:45:08 <musasabi> dcoutts: "a thing we have committed to use at this point"
09:45:21 <as> this whole just through variable names in there throws me
09:45:28 <dcoutts> musasabi, so you start with having committed to nothing ?
09:45:56 <as> C b' z c' -> ...
09:46:11 <musasabi> dcoutts: yes. and as build-depends are handled then it gets populated. (of course this is problematic with mutually recursive configurations)
09:46:16 <EvilRanter> well, C is a constructor
09:46:21 <as> yeah
09:46:26 <as> of C x C
09:46:49 <EvilRanter> ?
09:47:06 <EvilRanter> C :: (...) -> C x C
09:47:06 <EvilRanter> ?
09:47:09 <bdbit> this code is Awful
09:47:20 <EvilRanter> IDGI
09:47:34 <as> (C C x C)
09:47:44 <EvilRanter> ohh
09:47:52 <as> where x is a value
09:47:53 <dcoutts> musasabi, I don't think I understand fully. Perhaps email cabal-devel with more details on what it means / how it works.
09:47:55 <EvilRanter> C :: C -> a -> C -> C ?
09:48:49 <Cale> lisppaste2: url
09:48:49 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:49:09 <EvilRanter> @type let data C x = C C x C in C
09:49:10 <lambdabot> parse error on input `data'
09:49:13 <EvilRanter> beh
09:49:38 <as> no just
09:49:41 <as> C x C
09:49:42 <as> in C
09:49:47 <Cale> So C x is the type of infinite binary trees labelled with x's on the nodes?
09:49:54 <Cale> er...
09:49:55 <EvilRanter> data C = C (x C)?
09:49:58 <as> somewhat
09:50:06 <EvilRanter> no, that's wrong
09:50:07 <Cale> errr
09:50:09 <EvilRanter> but you get the idea
09:50:15 <EvilRanter> data C = C x C?
09:50:20 <as> correct
09:50:24 <Cale> data C x = T (C x) x (C x) ?
09:50:39 <EvilRanter> so, it's a list type
09:50:41 <Cale> Or are you using x to mean Cartesian product?
09:50:54 <as> the thing i don't understand of the code is b' & c' -> ??
09:51:00 <as> kind of
09:51:04 <Cale> Which language is this?
09:51:08 <as> recursive list
09:51:15 <EvilRanter> er
09:51:16 <as> haskell..
09:51:19 <Cale> data C = C x C is not valid Haskell.
09:51:34 <as> no that was his notation
09:51:49 <Cale> Could you paste your module?
09:52:06 <as> sure
09:52:18 <as> just give me a second
09:53:27 <Cale> (using lisppaste)
09:53:35 <Cale> (or something like that :)
09:53:50 <as> lisppaste?
09:54:06 <EvilRanter> lisppaste2, url
09:54:06 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:54:32 <as> i see
09:55:39 <fons> Is there a way to check if all elemts of a record are initialized (/= _|_ ) ?
09:55:51 <ndm> fons: see the chasing bottoms paper
09:56:01 <fons> s/elemts/elements
09:56:23 <lisppaste2> as pasted "okasaki in haskell" at http://paste.lisp.org/display/28932
09:56:49 <as> there you are
09:57:52 <as> you see the appened, more of a concat but whos splitting hairs...
09:57:58 <as> app()
09:58:17 <EvilRanter> good grief
09:58:21 <roconnor> fons: records in haskell are immutable, so they are always initialized to their final value when created.
09:58:22 <as> first 2 and last 2 matches i understand perfectly
09:59:13 <as> those middle 2 with their b' c' and bc confuse me
09:59:26 <bdbit> http://beust.com/weblog/archives/000375.html
09:59:27 <lambdabot> Title: Otaku, Cedric's weblog: A programming language for 2010
09:59:31 <bdbit> do you guys know this article?
09:59:42 <fons> roconnor, but not all fileds have to be initialized
09:59:48 <bdbit> It's about a speech given by the founder of Epic (they did Unreal)
09:59:50 <fons> fields
10:00:10 <cpriester> hi!
10:00:46 <cpriester> Is it possible to configure ghc in a way, that long recursions are more efficient?
10:00:51 <roconnor> they have to be initialized one way or another.  It is possible to initialize them to undefined (like any other data strucutre), but this is not typical programming practice
10:01:04 <cpriester> i.e. g 0 = 0
10:01:04 <cpriester> g n = 1+ g(n-1)
10:01:13 <cpriester> for n = 10.000.000
10:01:40 <roconnor> _|_ is really more of a tool to understand the semantics of programming languages, rather than an acutally value used in typical programming
10:01:52 <bdbit> cpriester: why wouldn't you use sum or scan or fold for that?
10:01:53 <Cale> fons: not really. You can actually check for certain kinds of _|_, but _|_ really represents nontermination.
10:02:08 <Cale> cpriester: you could use a foldl' for that
10:02:17 <roconnor> Cale: more than nontermination, non-productivity.
10:02:43 <cpriester> Well, that function does not make many sense, but it computes too slow, in my opinion...
10:02:47 <fons> Cale, I want to check the the user of record initialized all the fields before accessing them
10:02:51 <as> Cale: did you get the paste?
10:03:00 <fons> Cale, or at least give a friendly error when it happens
10:03:11 <Cale> roconnor: depends on how you look at it of course
10:03:16 <ndm> fons: Catch statically checks for that, as it happens :)
10:03:26 <Cale> as, yeah, okay
10:03:29 <Cale> as: hmm
10:03:37 <Cale> as: what was your question about this?
10:03:39 <fons> ndm, what?
10:03:43 <as> in app
10:03:46 * fons is lost
10:03:58 <as> the second 2 matches
10:04:05 <cpriester> and i wonderedand i wondered, why it is much faster in C.
10:04:05 <ndm> fons: my tool, Catch, will statically check that you never do that, never access records before initialising them in fields
10:04:17 <as> how they have the b' c'... and bc
10:04:21 <as> with ->
10:04:23 <pejo> bdbit, the speech was held at POPL'06. It's been around on LtU, I think.
10:04:29 <Cale> cpriester: I'll go over that with you in a minute :)
10:04:52 <Cale> as: yeah?
10:04:55 <fons> ndm, I see what you mean, but ... I don't think that simple check justifies using Ctach
10:04:56 <as> i just don't undersand the flow of the program at that point
10:04:57 <fons> Catch
10:05:01 <EvilRanter> cpriester, because you're doing something with the return value of each recursion, it can't optimise it
10:05:15 <Cale> cpriester: remember that Haskell evaluates the outermost reducible value first
10:05:18 <ndm> fons: probably not
10:05:41 <bdbit> pejo: do you know any additional resources?
10:05:49 <Cale> So in your case, you have g 0 = 0; g n = 1 + g (n-1)
10:05:54 <Cale> So look at g 3
10:06:20 <EvilRanter> g 10 = 1 + g 9 = 1 + 1 + g 8 = 2 + g 8 = ... is how it goes, I think
10:06:23 <cpriester> EvilRanter: Its tail-recursion... It should be possible to optimize for the compiler.
10:06:28 <Cale> EvilRanter: nope :)
10:06:35 <Cale> It's not tail recursion
10:06:43 <fons> there is no way to "catch" such exceptions? I way to do it would be strictly accesing the fields and catch a possible exception
10:06:43 <EvilRanter> g 10 = 1 + g 9 = 1 + 1 + g 8
10:06:54 <Cale> You're building up a big chain of 1 + (1 + (1 + ...))
10:06:55 <EvilRanter> cpriester, no it isn't. you're doing something with the return value
10:07:15 <EvilRanter> Cale, it doesn't do the additions LTR as it goes along?
10:07:23 <pejo> bdbit, shrug, depends on what you're after. All people in #haskell combined are probably aware of the interesting articles that are the basis for what he says.
10:07:42 <Cale> EvilRanter: How could it? It would have to use the fact that + is associative, and it doesn't know that
10:07:45 <EvilRanter> ahh
10:07:50 <EvilRanter> point
10:07:51 <bdbit> pejo: I'd like to understand all the philosophy behind the functional stuff, as it only really caused me grief so far.
10:08:05 <bdbit> pejo: especially Haskell, since I'm not the only one to consider it's syntax quite brutal
10:08:10 <EvilRanter> it clicked just before you said that, when I saw the brackets you had in your expansion
10:08:32 <Cale> as: Well, I can't claim to understand what the program is actually doing. Do you have a more pointed question? :)
10:08:37 <cpriester> hm. ok.
10:08:48 <Cale> as: It's running app b c and then pattern matching against the result
10:08:52 <bdbit> Cale: I love your honesty :>
10:09:09 <desrt> Cale; know any happy? :)
10:09:23 <cpriester> but anyhow, it should not take more than 10 Minutes to compute...
10:09:35 <Cale> desrt: I've mostly used monadic combinators for parsing.
10:09:42 <desrt> ya.  i tried that
10:09:45 <Cale> desrt: But a little
10:09:47 <desrt> but my grammar was left-recursive
10:09:54 <Cale> That's what chainl is for
10:09:55 <desrt> and try() slowed me up
10:10:16 <Philippa> bdbit: I've not met anyone who understands Haskell's semantics and finds the syntax brutal
10:10:18 <as> and returning the .... in: pattern -> ....
10:10:23 <desrt> anyway... i have a shift/reduce conflict that is being resolved incorrectly
10:10:41 <bdbit> Philippa: you're stating two different things.
10:10:48 <pejo> bdbit, Sweeney wanted a syntax more similar to C as well.
10:10:49 <Cale> cpriester: Of course, you're really computing the identity function there, so g n = n would do :)
10:10:59 <desrt> http://desrt.mcmaster.ca/parser/Parser.y
10:11:01 <pejo> Philippa, how many have you met that understands Haskell's semantics? ;)
10:11:03 <bdbit> Philippa: It's because I _don't_ yet know Haskell too well, that I can't figure out how to do 2 lines in it
10:11:09 <therp> toplevel type signatures are only value for function binders right? so, patterns are not allowed to have signature declaration such as (a,b) :: (Foo, Bar)
10:11:12 <desrt> the problem is in the APPLY rule
10:11:16 <bdbit> and therefor regard the syntax as "brutal"
10:11:24 <Philippa> bdbit: right, but that probably has less to do with the syntax than you think
10:11:32 <Philippa> pejo: H98's? Plenty
10:11:33 <bdbit> once you know stuff, you tend to forget how painful it was in the beginning
10:11:33 <desrt> it ends up being right associative
10:11:39 <as> Cale: extremely helpful thank you much
10:11:54 <Cale> as: really? :)
10:11:57 <Cale> okay :)
10:12:00 * Heffalump is fairly sure he didn't find it painful initially.
10:12:15 <cpriester> Cale: i know that :)
10:12:15 <as> yeah i saw the path i just needed someone to tell me it was there
10:12:17 <as> ;)
10:12:19 <Philippa> for example, the way function application works isn't /just/ a syntax issue, and the syntax is straightforward once you're aware of what's being represented
10:12:46 <bdbit> Philippa: okay then, you would be of great help and I would appraise highly your wisdom, if you could share with me the ins and outs of what I ought to know
10:12:58 <EvilRanter> the only parts i found painful were the =s in fences and naming the fn repeatedly in patternmatching
10:12:59 <Cale> desrt: mm, it's been 4 years since I've dealt with a shift/reduce conflict :)
10:13:04 <Philippa> *hands bdbit a copy of YAHT*
10:13:11 <cpriester> Cale: But i wanted to test the speed of these recursions.
10:13:13 <Philippa> I suspect I missed your original problem
10:13:37 <as> -thanks, anyone else who lent me a few minutes of their time, i have to run now..
10:13:37 <bdbit> Philippa: I can't manage to read any foreign code, let alone write it myself
10:13:54 <desrt> Cale; :)
10:13:55 <Philippa> as in, using the FFI?
10:14:00 <desrt> Cale; and inf years for me :)
10:14:06 <Cale> hehe
10:14:07 <bdbit> Philippa: FFI?
10:14:13 <Philippa> that'd be a no, then
10:14:18 <Philippa> (Foreign Function Interface)
10:14:18 <bdbit> probably, yes.
10:14:23 <bdbit> umm, no
10:14:27 <bdbit> as in "code written by other people"
10:15:27 <Philippa> hrmm. Mind if I throw you a simple but complete program as a comprehension test?
10:16:06 <desrt> Cale; anyway... not critical... being forced to add extra () isn't keeping me from working on the rest of the project :)
10:16:09 <bdbit> Philippa: I'd highly appreciate it
10:16:24 <Philippa> OK
10:16:25 <Philippa> http://www.flippac.org/projects/SigGen.hs
10:16:41 <Philippa> AFAIK that's Haskell 98 (that is, no special extensions) + GHC's libs
10:16:52 <Cale> desrt: I think that happens when the parser generator can't decide for some inputs whether to just push something on the stack or reduce the stuff that's already there.
10:16:53 <Philippa> most of the code's in the IO monad
10:17:07 <desrt> Cale; yes.  that's exactly the problem.
10:17:11 <desrt> so it "shifts" per default
10:17:19 <Philippa> in fact, only one of the top-level bindings has non-IO type and it's not a function
10:17:24 <desrt> i'd have assumed my '%prec left' line would have fixed that
10:17:53 <desrt> if i write it like "Expr '@' Expr" and declare "%left '@'" then it works
10:18:04 <bdbit> why is there a "return $ ((read cfgfile)::Config)" when it's in parentheses anyway?
10:18:20 <Cale> hmm
10:18:20 <Philippa> because I was sloppy
10:18:30 <bdbit> I don't really know the "<-" notation but I can imagine what it means
10:18:35 <desrt> the docu gives an example of how to do what i want under "parsing sequences"
10:18:36 <Cale> http://haskell.cs.yale.edu/happy/doc/html/sec-conflict-tips.html -- have you looked at this? I'm not sure how useful it is.
10:18:38 <lambdabot> Title: 7.4. Conflict Tips, http://tinyurl.com/yfg44o
10:18:48 <Philippa> odds are the first version didn't have the type annotation, and then I put in both layers of parens when I added it
10:18:54 <desrt> but doing it results in reduce/reduce conflicts (and apparently those are very bad things to have)
10:19:06 <desrt> ya.  i've read pretty much that entire document :)
10:19:10 <Cale> okay
10:19:29 <desrt> http://haskell.org/happy/doc/html/sec-conflict-tips.html
10:19:31 <lambdabot> Title: 7.4. Conflict Tips, http://tinyurl.com/y5lh3h
10:19:33 <Cale> Yeah, it just might be too hard a language to parse with this kind of generator, I don't know.
10:19:33 <desrt> :)
10:19:42 <desrt> well
10:19:43 <desrt> thing is....
10:19:48 <desrt> ghc uses happy
10:19:55 <desrt> and what i'm doing is exactly how application in haskell works
10:20:00 <bdbit> Philippa: what could possibly be the hardest part about this program to comprehend?
10:20:05 <Cale> hmm
10:20:13 <bdbit> please ask me a question about that part :>
10:20:20 <Cale> I know that GHC also mangles the syntax trees Happy outputs :)
10:20:21 <desrt> i've tried to read the ghc parser  grammars but they're spaghetti :)
10:20:28 <desrt> oh.
10:20:31 <desrt> interesting idea.
10:20:46 <Kattana> I am attempting to build haskell-fastcgi on win32 using ghc. Does anyone know the solution to the following error:
10:20:47 <Kattana> ghc-6.6\gcc-lib\ld.exe: cannot find -lfcgi
10:20:47 <Kattana> collect2: ld returned 1 exit status
10:20:47 <Cale> but that's more to deal with fixity declarations
10:20:53 <Cale> (Haskell is context-sensitive)
10:21:00 <desrt> i could easily do that with my full-tree-recursion stuff
10:21:17 <desrt> that's what i'll do for now
10:21:20 <desrt> thanks for the idea :)
10:21:27 <bdbit> Philippa: YAHT seems to be a worthy lecture btw. thx.
10:21:30 <pejo> Kattana, for some reason the compiler can't find a library named "fcgi".
10:21:37 <Philippa> bdbit: do you understand what's going on with the records? If so, tell me what the case statement at the bottom does?
10:22:17 <pejo> Kattana, or the linker rather.
10:22:51 <Cale> cpriester: one thing which I think will make things clearer is a particular example -- foldl is tail recursive, but it can still be slow and end up using up all the stack space, but we can rewrite it (with more strictness) so it doesn't.
10:23:07 <Cale> cpriester: let me know if you'd like to see that :)
10:23:35 <Kattana> pejo, yes I understand the problem, but there does not seem to be a way to tell it where the library is, i dont know where it is looking
10:23:37 <desrt> oh crap.  your idea sucks, cale!
10:23:48 <bdbit> Philippa: when there are no files with an ending of ".sig", then the standardPrefix and standardPostfix are printed, concatenated
10:23:52 <Cale> desrt: well, I wasn't really suggesting it :)
10:24:01 <desrt> if i do it then i'll flip the associativity of explicitly bracketed expressions, too
10:24:12 <Cale> ouch
10:24:12 <desrt> bad cale!
10:24:27 <Cale> So (a + b) * c will end up being a + (b * c) ?
10:24:31 * desrt has no ... | Brac Expr | ...
10:24:37 <Cale> ah
10:24:38 <bdbit> Philippa: if there are files, than a random entry is chosen and read
10:24:47 <desrt> so i can't tell the difference between "x y z" and "x (y z)"
10:24:52 <Cale> mm
10:24:55 <desrt> (which parse to exactly the same AST)
10:25:00 <Cale> yeah, that might be an issue
10:25:12 <bdbit> Philippa: and put into sigInfix... afterwards same procedure as above, only with the contents inbetween
10:25:21 <bdbit> Philippa: did I understand anything? :D
10:25:31 <desrt> the one thing i've considered doing is writing my grammar in reverse
10:25:33 <Philippa> yeah, you've got it
10:25:37 <desrt> then reversing my token list
10:25:42 <desrt> i'm fairly sure that would work :)
10:26:09 <Philippa> add in a let binding and that app'd have most important bits of Haskell syntax demonstrated, btw
10:26:12 <Cale> desrt: What you normally do in parsec is to parse the whole list of things being applied at once, and then just build the tree correctly from that list.
10:26:27 <bdbit> Philippa: really? then maybe the stuff that I'm struggling with is just too high-level
10:26:27 <cpriester> not really, at the moment :)
10:26:35 <bdbit> or I have some other problem
10:26:45 <pejo> Kattana, I would guess -L/some/lib, but don't have a ghc laying around to test with.
10:26:56 <desrt> Cale; ya... like using 'many' and sepby spaces or something
10:27:00 <pejo> Kattana, -L/some/path I meant. Duh.
10:27:04 <desrt> then fold
10:27:06 <Cale> desrt: chainl :)
10:27:12 <Philippa> bdbit: yeah, haskell code can be surprisingly dense
10:27:19 <desrt> heh
10:27:22 <Philippa> there can be a lot of semantic content in a single line
10:27:25 <pejo> Kattana, and iirc you can throw -v5 at ghc to get loads of information.
10:27:32 <desrt> i don't want to write a monadic parser :p
10:27:38 <desrt> i tried that last night and it really really sucked
10:27:41 <Philippa> also, if you don't understand the type system you can tie yourself in knots pretty easily
10:27:46 <desrt> see http://desrt.mcmaster.ca/parser/Parser.hs
10:27:48 <Philippa> but that's semantics, not syntax
10:28:10 <bdbit> perhaps I just need to acknowledge the fact, that even though Haskell code is 1:2-20 more concise, I still have to spend the same time trying to figure it out ..
10:28:11 <desrt> it ran great... plus/minus some stupid stuff like me not knowing how to parse numbers or multi-character variables
10:28:19 <desrt> but it was SLOW
10:28:31 <Cale> Yeah, that's a lot of try's
10:28:31 <bdbit> Philippa: I think type system is a good pointer...
10:28:35 <desrt> nod.
10:29:05 <Cale> Did you see the stuff parsec has for automatically building parsers for expression grammars?
10:29:20 <bdbit> I wish I could heighten my concentration O_o
10:29:23 <Kattana> pejo, its building with cabal so i can not pass options directly to ghc
10:29:25 <Philippa> if you try to understand one of the big name projects there'll be a lot of stuff going on using libraries and techniques you don't know about
10:29:33 <Philippa> that can be a bit of a kicker at first
10:29:51 <desrt> Cale; like it'll automatically whip up a parser for me?
10:29:55 <bdbit> Philippa: do you know of some really verbosely commented example source code?
10:30:04 <bdbit> I'd look for a comment ratio of at least 3:1 in lines
10:30:16 <Cale> desrt: yeah, for the most part -- at least for the arithmetic stuff
10:30:25 <desrt> oh ya.  i've seen that
10:30:28 <desrt> it confused me
10:30:32 <Cale> desrt: look up buildExpressionParser
10:30:38 <desrt> i've tried that :)
10:30:46 <Philippa> bdbit: not off hand, sorry
10:30:56 <desrt> i'm pretty much going to stick with happy and alex unless someone else completely rewrites my parsing/lexing for me
10:30:57 <Philippa> I have a bad habit of writing code for myself to read
10:31:10 <desrt> since i'm getting tired of rewriting something so trivial over and over again :)
10:31:14 <Philippa> which works well for me - I can pick it up a couple of years later and figure out WTF I was doing...
10:31:41 <bdbit> Philippa: I have that same way of working. But it doesn't help when I don't know the language yet.
10:31:46 <bdbit> "terminating the presentation with a full page devoted to one of Haskell's main flaw: type inference doesn't scale.
10:31:51 <bdbit> can somebody comment on that?
10:32:08 <bdbit> I don't understand what's meant and the implications
10:32:39 <Philippa> unless it's referring to the fact the inference algorithm's got some pathological worst cases and can be painful with huge modules, I'm not sure what's meant
10:32:46 <Cale> desrt: hehe
10:33:01 * desrt does a rewrite that causes some strange results
10:33:15 <Philippa> there has been a need for work to make the type system support code that scales upwards, but we're seeing apps in the 10-100KLoCs range work fine at least
10:33:25 <Philippa> and the big thing there is that work gets done
10:33:30 <desrt> "x y z" -> (x@y)@z
10:33:34 <desrt> (good)
10:33:44 <desrt> "x + y x + z" -> x + y@x + z  (good)
10:33:45 <bdbit> Philippa: 100K LoC in haskell is not something to sneeze at anyway
10:33:48 <pejo> bdbit, he has (correctly) observed that error messages in Haskell can be quite scary, and not always helpful.
10:33:56 <desrt> but... "x + y z s + q" -> (x + y@z)@s + q       (wtf?)
10:34:05 <bdbit> pejo: but that doesn't say anything about how well the generated programs scale, does it?
10:34:22 <Philippa> bdbit: exactly
10:34:38 <Philippa> pejo: *ah* - IME it's rare that they're seriously unhelpful if you know how to go about it
10:34:57 <pejo> bdbit, and I imagine he's drawing the conclusion that it would be a nightmare to find a type error in a 100kloc program, given a bad error message.
10:34:58 <Philippa> I've only really tied myself in knots when attempting to impersonate Oleg
10:35:13 <bdbit> who's Oleg?=
10:35:21 <Philippa> which I couldn't agree with - 1) modularity helps a lot, 2) type slicing does scale
10:35:29 <Philippa> bdbit: researcher, infamous type-level hacker
10:35:35 <bdbit> ah
10:35:52 <pejo> Philippa, so your statement is "Given an expert on the type system it is easy to find the problem"? :-)
10:35:53 <Philippa> if you can't code something, claim it can't be done in the type system on haskell-cafe and you'll get code back the next day
10:36:33 <Philippa> pejo: the relevant expertise isn't too hard to communicate, IMO. Well, I'm having a bad language day...
10:36:43 <Philippa> there's a known algorithm for plain H-M that'll give you a minimum conflict set
10:36:52 <pejo> Philippa, shrug. Type error messages could be improved. We should do it.
10:37:00 <Philippa> it's not too hard to do something similar by hand (commenting stuff out as you go)
10:37:03 <Philippa> yeah, I agree
10:37:18 <Cale> desrt: It might be a good idea to split your grammar up into precedence levels
10:37:18 <Philippa> but it's far easier than finding the same problem in C++ when the type system didn't even catch it
10:37:24 <bdbit> Philippa: hehehe, thanks for the hint :D
10:37:27 <desrt> Cale; i tried that :)
10:37:32 <pejo> (By accident I'm reading Heerens thesis as we speak, for an entirely different reason).
10:37:43 <desrt> Cale; and required an explicit () to go frm the bottom to the top
10:37:56 <desrt> Cale; but it ended up failing to parse some simple expressions that should have parsed
10:38:15 <bdbit> By the way I think GHCs error messages are very verbose. That's good. But sometimes they could be more precise.
10:38:21 <desrt> i recall "\x.\y.x y" to be one of them
10:38:48 <Philippa> bdbit: sometimes it's harder for them to be more precise without making guesses
10:39:01 <bdbit> Philippa: of course it is.
10:39:03 <desrt> there's a possibility that i screwed it up since i did it very late last night, though :)
10:39:05 <Philippa> there's a lot of room for polymorphism, and thus conflicts aren't always as obvious as you might think
10:39:15 <pejo> Well. I would like to have just 1 line of type error message, which would correctly point out the error in the code. But I'm not holding my breath for a mind reading compiler any time soon. :-)
10:39:42 <Philippa> exactly. What I *really* want is a chance to browse the entire typing and see where it got the conflicting info from
10:40:11 <Philippa> for the non-type-theorists, effectively a type checking log
10:40:15 <pejo> Philippa, quite a lot of work to implement I imagine; I would love such a feature.
10:40:33 <bdbit> if it's feasible and someone suggests it, I suppose it will be done
10:41:03 <roconnor> what is the darcs command to get the standard library?
10:41:04 <Philippa> brb
10:43:46 <pejo> Philippa, as for communicating the relevant expertise, I'd love to have it communicated to me. Perhaps through an article in TMR? ;-)
10:47:42 <mbishop> Wow, I feel honored, my reddit post was trolled by the king of trolls himself
10:49:38 <arcatan> and who is that?
10:49:42 <Philippa> pejo: I have a backlist to write already :-) If you're lucky I'll have cause to post about it on LtU though?
10:50:11 <Philippa> getting the output from something like GHC should be mostly a matter of layering a WriterT and adding a pile of log commands...
10:50:24 <pejo> Philippa, I'm all for printing stuff, but hey, if someone can make the text I guess it's easy to typeset.
10:51:27 <mbishop> arcatan: qwe1234
10:51:34 <Philippa> mmm, I think re GHC the point's that once you've got it you just have to work out how the hell you're going to visualise it
10:53:29 <pejo> Philippa, people have suggested ways, having the source of the type next to the "occured" type error in some sort of graphical browser would be nice. (Visual Haskell/Eclipse/etc).
10:53:36 <bdbit> Would it be wise to switch back to learning OCaml now after 3 days of trying Haskell, to "Get Something Done"(tm)?
10:54:00 <pejo> bdbit, do you consider O'Caml's syntax easier?
10:54:22 <bdbit> pejo: unfortunately I haven't seen enough to judge, but on first glance it seemed a lot easier
10:54:29 <bdbit> that's why I initially started with O'Caml
10:54:34 <bdbit> but then thought it's not elegant enough
10:54:53 <bdbit> and I want to burden myself with the hard things first and if the need arises (for example for performance) be able to switch back
10:55:53 <bdbit> I would still have to see a direct comparison between O'Caml and Haskell
10:56:03 <bdbit> but I do suspect I would rather understand the O'Caml program
10:56:06 * EvilRanter is away: not here
10:57:08 <edwardk> phillipa: bdbit: dons started to port a ocaml tutorial to haskell the other day
10:57:15 <edwardk> er just bdbit
10:57:21 <bdbit> hehe
10:57:27 <bdbit> edwardk: that would be very interesting!
10:57:33 <bdbit> Is it anywhere near usable?
10:57:57 <edwardk> should be, trying to find it in my logs
10:58:15 <bdbit> e17 is such a great window manager
10:58:22 <bdbit> if only development progressed a little faster
10:58:46 <edwardk> http://tinyurl.com/y98go6
10:58:50 <lambdabot> Title: A brief introduction to Haskell - HaskellWiki
10:58:57 <edwardk> compare with: http://www.cs.jhu.edu/~scott/pl/lectures/caml-intro.html
10:58:59 <lambdabot> Title: Introduction to Caml, http://tinyurl.com/6ixj
10:59:33 <bdbit> well thank you, edwardk!
10:59:36 <edwardk> its fairly enlightening to see where haskell decided to make the syntax cleaner
11:00:07 <astrolabe> Are there practical reasons to use darcs over CVS?
11:00:44 <edwardk> astrolabe: i find that darcs makes it easier to just pick up a project and run with it. if someone else has a darcs repository i can copy it and make my own
11:00:59 <edwardk> and i don't have to embarass myself publicly while i work on my changes ;)
11:01:01 <bdbit> edwardk: does that mean you would NOT recommend going back to O'Caml?
11:01:55 <edwardk> bdbit: i definitely prefer haskell to ocaml. things just slot into place and feel more 'right', fewer crufty keywords floating around, you can usually just write the definition and compile it to get working code, etc.
11:02:52 <jajs> i think that Ocaml is a bit more pragmatic (and maybe wrong) than Haskell
11:03:17 <astrolabe> edwardk: thanks
11:03:27 <SamB> astrolabe: why the heck would you use CVS anyway?
11:03:33 <bdbit> jajs: I guess you have brought both advantages to the point
11:03:47 <edwardk> yeah but even the little things like layout and the lack of need for a let rec every time you define something is nice, then you more or less get your code in dictionary order, the word you are looking for is on the left hand side of the line
11:04:00 <astrolabe> SamB: it works, and I don't have to wait for ages while 1000 patches load :)
11:04:42 <SamB> well, darcs *does* make it a lot simpler for outsiders to hack on things
11:04:51 <SamB> even if you happen to have CVS configured somewhere
11:04:54 <bdbit> okay I'll try to stay with haskell then, for the moment
11:05:02 <SamB> (I'd have to wonder why you wouldn't be using SVN though)
11:05:03 <bdbit> although I'll have to depend heavily on #haskell ;D
11:05:28 <edwardk> now, ocaml is good stuff for reasoning about space and how you're going to get there, but there is something to be said for the lack of crufty surface syntax and for the lack of side effects, which allows you to do things like backtracking, etc.
11:05:45 <edwardk> bdbit: we're happy to help
11:06:07 <bdbit> edwardk: feeling a bit guilty though for stealing other peoples time and still not accomplishing anything worh
11:06:10 <bdbit> worthy
11:06:25 <edwardk> bdbit: heh, i've been doing that for months, don't worry ;)
11:06:28 <SamB> bdbit: heh
11:06:42 <Heffalump> people wouldn't help if they didn't like doing so/feel it was worthwhile
11:06:49 <vegai> SML has a slightly less crufty surface syntax, and most of the goodies of ocaml
11:06:50 <emu> let rec f x = match x with ... wtf
11:06:50 <bdbit> but that'll maybe change in the near future *straightens*
11:06:52 <Heffalump> we're quite good at ignoring the lamers
11:07:08 <bdbit> Heffalump: heh
11:07:10 <SamB> I'm not sure if I've done much of any consequence or not ;-)
11:07:16 <edwardk> you typically find that explaining something to others is a good way to make sure that you really understand it yourself ;)
11:07:20 <SamB> I suppose @google is nice
11:07:23 <bdbit> definitely
11:07:42 <SamB>  @todo isn't of much use, though
11:07:54 <bdbit> emu: I'll have to agree there
11:08:06 <edwardk> yeah, by looking through the logs of #haskell you can basically find out whatever interested samb at any moment in time for the last few months ;)
11:08:17 <bdbit> hehe :D
11:09:01 <bdbit> I should write myself a small script which greps the logs for times and then calculates how long I must've been online and talking on IRC instead of getting to work and DOING things
11:09:18 <SamB> @where stats
11:09:20 <desrt> watching my lambda calc interpreter single-step through a calculation is insanely amusing
11:09:29 <SamB> lambdabot dead again?
11:09:34 <bdbit> ?uptime
11:09:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
11:09:40 <bdbit> seems not so hehe
11:09:45 <desrt> particularly due to how it seems to work at the end
11:09:47 <desrt> i get (((((((((((((((((((((((((((((((((((0 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1
11:09:47 <SamB> just slow
11:09:53 <lambdabot> uptime: 5d 17h 4m 50s, longest uptime: 6d 15h 1m 36s
11:09:56 <desrt> which then, one line at a time, turns in to 36 :)
11:10:20 <bdbit> hmm
11:10:32 <bdbit> does anybody know how to translate a .hs file to SMP-code via GHC?
11:11:02 <Heffalump> errm, just compile it
11:11:13 <SamB> well, you'd need to somehow get it to use multiple threads ;-)
11:11:19 <emu> i just realized that it's an hour behind
11:11:22 <bdbit> I love the random quote feature ... lamdabots random quotes are very enlightening O_o
11:11:24 <SamB> heh
11:11:28 <SamB> @quote
11:11:29 <lambdabot> Pupeno says: lambdabot is indeed the most impresive bot I've ever seen
11:11:33 <SamB> heh
11:11:40 <SamB> how appropriate
11:11:42 <bdbit> I agree to pupeno
11:11:45 <mauke> @ghc
11:11:45 <lambdabot>  Can't match unequal length lists
11:12:03 <bdbit> Heffalump: you mean GHC automatically accounts for multicore systems?
11:12:10 <emu> that should be a quote, a lambdabot quote
11:12:29 <SamB> (btw, the reason I mentioned @google and @todo is that I wrote both of them, though I really don't have any idea why I wrote @todo, and for a while I did not remember I had done so and wouldn't believe dons that I had ;-)
11:12:42 <edwardk> bdbit: there is some stuff to handle 'par' to pre-evaluate thunks in parallel, etc like seq does in series.
11:12:47 <Heffalump> you might need to tell it to use the threaded RTS, I forget.
11:13:11 <mbishop> bdbit: I started a topic on reddit about ocaml vs haskell, in the end, I ended up choosing haskell to learn.  One of the things that made me decide was when a few people said "use ocaml if you want to get real work done", which just reminds me that the realworld is stupid and uses C++ everywhere :)
11:13:11 <bdbit> Poor lambdabot, nobody likes him/her. He/She was attacked 39 times.
11:13:14 <bdbit> For example, like this: * lambdabot slaps lambdabot
11:13:14 <Lemmih> GHC-6.6 uses the threaded RTS by default, iirc.
11:13:14 <bdbit> lol
11:13:36 <bdbit> mbishop: hehe, nice perspective ;)
11:13:59 <bdbit> edwardk: I didn't understand what you just said
11:14:05 <pejo> Lemmih, do you know if the the problems seen on Solaris/Macos X got solved for 6.6?
11:14:26 <SamB> bdbit: I think you need to pass an RTS flag  too
11:14:35 <Lemmih> pejo: No, I don't.
11:14:35 <SamB> try ./program +RTS --help
11:15:00 <bdbit> what's RTS?
11:15:16 <bdbit> the most used words are cool... "haskell think would which right should monad could function something" :-)
11:15:21 <SamB> the RTS is the run time system
11:15:51 <SamB> basically some low-level support code
11:16:02 <bdbit> Nice opers here, no one got kicked!
11:16:05 <bdbit> pretty interesting!
11:16:14 <SamB> that handles threading, and GC, and stuff like that
11:16:21 <SamB> hmm. noone?
11:16:28 <Heffalump> over what period?
11:16:29 <SamB> I thought we had some spammers at some point?
11:16:32 <Heffalump> there's quite a long ban list
11:16:47 <Heffalump> including Smerdyakov still, I notice :-)
11:16:51 <SamB> yeah
11:16:58 <bdbit> probably the stats checker didn't get it right
11:17:06 <SamB> if we get bored I guess we could unban him and tell him so at some point?
11:17:42 <bdbit> SamB: so passing +RTS as a cmdline flag would suffice to make it multithreaded and therefore SMP-capable?
11:17:56 <SamB> bdash: no, but +RTS --help will give you help for RTS flags
11:18:17 <Heffalump> well, I was against banning him in the first place, but I'd have thought he's been banned for long enough anyway
11:18:22 <SamB> +RTS just mean "next flags go to the RTS"
11:19:09 <SamB> hmm. last I checked he still claimed not to understand that he was annoying people :-(
11:19:16 <SamB> or something like that
11:19:24 <SamB> not that I don't *believe* him
11:20:53 * SamB doesn't remember why Heffalump didn't think he should be banned
11:21:15 <bdbit> It would really be a large plus if Haskell was easily compilable for SMP#
11:21:20 <bdbit> _without modifications_
11:21:35 <SamB> people have been working on that for decades
11:22:01 <desrt> man
11:22:09 <desrt> watching my lambdacalc interpreter go is hilariously fun
11:22:18 <mbishop> hmm, isn't haskell's GC still single threaded?
11:22:21 <SamB> and with hardware headed toward SMP for the masses, that could actually bear tangible fruit very soon ;-)
11:22:27 <SamB> mbishop: yup
11:22:32 <SamB> at least, I think so
11:22:35 <Heffalump> I didn't think his rudeness was so far out of line to justify banning, given that he did have a useful contribution to make.
11:22:41 <SamB> but, that isn't such a big deal
11:22:44 <desrt> Cale; you should see this thing!
11:22:46 <pejo> bdbit/mbishop, they're working on it, if I got it right.
11:22:46 <mbishop> I don't really know of a language that has multi-threaded GC though
11:22:59 <edwardk> bdbit: well, the issue is the way lazy evaluation interacts with multiple cores, you have to be a little more careful to mark thunks as being evaluated, so that you swap in a 'black hole' atomically to keep other threads from duplicating effort, etc.
11:23:09 <SamB> I mean, getting the *program code* parallized is the main point, right?
11:23:20 <bdbit> edwardk: mhm.
11:23:25 <SamB> edwardk: did you read the paper?
11:23:26 <Heffalump> I thought GHC SMP doesn't care about duplicating effort?
11:23:31 <edwardk> samb: yeah
11:23:34 <SamB> Heffalump: apparantly it does care
11:23:36 <Heffalump> Or at least doesn't guarantee not to.
11:23:41 <bdbit> I'd suppose the GC not being multithreaded wouldn't have an impact greater than .5%
11:23:42 <SamB> no, it doesn't
11:24:06 <integral> isn't it to get sharing right?  ie it may be evaluated twice, but only one of those will ever be used by anyone?
11:24:11 <SamB> but it will stop in the middle if a second thread tries to blackhole something...
11:24:27 <SamB> it uses greyholing and lazy blackholing
11:24:39 <edwardk> heff: well, it used to care, don't know about now.
11:24:45 <SamB> or maybe greyholing was just an idea?
11:24:51 * SamB isn't sure about greyholing really
11:24:51 <bdbit> so, basically, is it ready or not?
11:25:03 <Heffalump> bdbit: is what ready or not?
11:25:09 <SamB> bdbit: if you want to write threaded code, sure ;-)
11:25:12 <bdbit> Heffalump: SMP-enabled compilation
11:25:15 <Heffalump> yes
11:25:19 <bdbit> without modification
11:25:23 <Heffalump> but it won't parallelise your code for you
11:25:24 <SamB> if you want to write code that doesn't mention threading, you'll need library support...
11:25:30 <edwardk> the idea of greyholing is that you say hey this is being evaluated by thread x, so that if thread y tries to evaluate it it blocks, and if thread x encounters its own greyhole then it aborts complaining of a loop, right?
11:25:40 <SamB> edwardk: no
11:25:57 <edwardk> ok, then what is it again? =)
11:26:00 <edwardk> its been a while
11:26:09 <SamB> the idea of greyholing is "oh, someone has already started on this one. ..." and I forget the other part
11:26:20 <SamB> I don't think it mentions the thread though
11:26:49 <edwardk> ok, so same idea minus the thread tag
11:26:50 <Heffalump> so what does the thread actually do while waiting for the other one to finish evaluating?
11:27:32 <edwardk> thought it blocked, would be nice to return its task to a queue and pull from the queue.
11:27:47 <SamB> ack I forget the filename of the paper :-(
11:28:07 <edwardk> haskell on a shared-memory multiprocessor, tim harris, marlow, peyton-jones?
11:28:47 <SamB> ah, multiproc.ps
11:29:42 <bdbit> Heffalump: it won't?
11:30:02 <Heffalump> bdbit: it won't parallelise your code for you, no
11:30:10 <bdbit> will it anytime soon?
11:30:13 <Heffalump> if your code uses threading the threads will automatically be distributed across the cores
11:30:16 <Heffalump> I doubt it
11:30:28 <bdbit> but that's the case in every language.
11:30:32 <SamB> edwardk: yeah, it blocks...
11:30:37 <Axioplase> How do I define an Order on some created data ? (where deriving Eq doesn't suffice)
11:30:38 <bdbit> if they're native threads
11:30:40 <edwardk> ok greyholes are a way of saying 'blackhole pending'
11:30:42 <Heffalump> they're not
11:30:52 <Heffalump> Axioplase: YM 'deriving Ord' doesn't suffice?
11:30:59 <Axioplase> Heffalump: no
11:31:06 <edwardk> or no?
11:31:09 <SamB> bdbit: well, GHC implements lightweight threads
11:31:17 <SamB> edwardk: yeah, basically
11:31:30 <Axioplase> I have to define my own comparison function... but I don't know its name.
11:31:41 <SamB> there is a race condition, so multiple threads can greyhole the same thunk
11:31:47 <Heffalump> Axioplase: I don't follow
11:31:49 <SamB> and I'm still not sure they actually use greyholes
11:31:51 <Axioplase> (if this is the same scheme as redifining "Show")
11:32:06 <Heffalump> yes, make an instance of Ord
11:32:25 <edwardk> it just seems that the right answer would be to write a blackhole that is different for each thread, then it can still swap atomically and identify when it swapped in its own backhole vs. another thread's.
11:32:37 <Axioplase> Heffalump: `ord' is not a (visible) method of class `Ord'
11:32:54 <Heffalump> oh, that kind of "same scheme"
11:32:55 <Heffalump> no
11:33:01 <Axioplase> ha.
11:33:03 <Heffalump> either define 'compare' or the (<) operator
11:33:27 <bdbit> hmm... are any of you below age 30?
11:33:27 <mbishop> Are there any compilers for haskell that focus on uberoptimization? I know the ocaml compiler apparently creates code on par with C++ in speed of execution, but I'm sure it does some voodoo
11:33:30 <Axioplase> ok thanks.
11:33:36 <mbishop> bdbit: I'm 21
11:33:38 <Heffalump> (and make sure that the Eq instance is present)
11:33:40 <Heffalump> bdbit: I'm 27
11:33:43 <SamB> edwardk: that sounds wierd
11:33:53 <SamB> mbishop: "on par"?
11:34:02 <SamB> oh, ocaml, right :-).
11:34:05 <edwardk> mbishop: ghc is the closest you get, jhc can do some extra optimizations though in theory coz its whole-program optimizing
11:34:12 <bdbit> mbishop: wow, we're not too far apart
11:34:18 <SamB> MLTon is supposed to do quite well.
11:34:25 <ndm> mbishop: i'm writing one
11:34:29 <mbishop> SamB: yeah I hear that too
11:34:31 <mbishop> ndm: neat
11:34:35 <SamB> also, voodoo is not a good technique for optimization
11:34:41 <ndm> mbishop: http://neilmitchell.blogspot.com/2006/10/30-faster-than-ghc.html
11:34:42 <SamB> its *so* easy to break
11:34:42 <bdbit> LOL
11:35:07 <bdbit> mbishop: could you show me some Haskell programs of yours?
11:35:48 <edwardk> samb: how so? the spineless tagless g-machine just identifies tags and pointers right? well, if each thread got its own stub pointer, then the blackhole per thread system would give you atomic swappability ala greyholing, and would jump right into the special case code if it was encountered.
11:35:52 <Heffalump> ndm: why not output GHC core?
11:36:01 <bdbit> Heffalump: you impress me. you seem very specialised
11:36:15 <SamB> edwardk: hmm??????
11:36:26 <SamB> they don't want atomic greyholing.
11:36:27 <ndm> Heffalump: GHC Core needs explicit types, Haskell doesn't
11:36:30 <SamB> that is kinda the point.
11:36:32 <Heffalump> bdbit: specialised in what sense?
11:36:44 <SamB> otherwise, they'd go straght to blackholes.
11:36:45 <ndm> Heffalump: and i hope that the translation from Haskell to GHC Core in this case is trivial
11:36:47 <bdbit> Heffalump: in CS :D
11:36:49 <Heffalump> ndm: surely you know the types
11:36:54 <edwardk> samb: ok, change the word atomic for 'single instruction swap' like they say then ;)
11:36:56 <SamB> if they are going to be atomic, they might as well just compare-and-swap
11:37:03 <Heffalump> bdbit: well, I have a PhD
11:37:11 <bdbit> I wonder if I'll ever reach the level that you guys are on
11:37:15 <ndm> Heffalump: its not a hindley milner typed language
11:37:18 <Heffalump> that kind of implies specialisation :-)
11:37:19 <mbishop> bdbit: sure, my haskell programs are over there in taht empty bucket :)
11:37:21 <SamB> and they only need two different info pointers with greyholes/blackholes
11:37:25 <bdbit> mbishop: lol
11:37:29 <ndm> Heffalump: but no, i have absolutely no idea what the types are at all!
11:37:31 <bdbit> Heffalump: hehe ;)
11:46:31 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
11:46:31 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
11:46:40 <pejo> bdbit, hence it wasn't much of a stretch. The leap to fp is probably larger then.
11:46:40 <bdbit> ah, yes, and C/C++, but not too good
11:47:02 <bdbit> pejo: well, most of it was just a readjustment. but blocks were quite a heavy chunk
11:47:40 <bdbit> perhaps I'm just lamenting because I don't want to realize that the program I aspire won't be finished within a month
11:47:59 <qz> edwardk, tho i have to add that haskell shines when it comes to twisting one's mind ;)
11:48:03 <edwardk> qz: mostly the kind of thing i like, compilers, parsers, interpreters, etc.
11:48:26 * SamB greps RTS source for GREYHOLE
11:49:20 <qz> edwardk, such kind of stuff requires alot of messing with bits and bytes. haskell has something to make it easier?
11:49:49 <SamB> what?
11:50:01 <qz> edwardk, that topic was discussed once and i think there was not a single example of production compiler written in haskell. no matter how superior language itself is :|
11:50:08 <SamB> since when do you need to actually mess with bytes to write compilers, parsers, or interpreters?
11:50:16 <SamB> sure, if you want bytecode...
11:50:21 <pejo> qz, GHC!
11:50:23 <SamB> or interface files...
11:50:26 <Heffalump> how many production compilers do you know of written in anything but C/C++?
11:50:37 <qz> pejo, an exception ;) and there's lots of C code in ghc
11:50:38 <edwardk> qz: putting one together now, and doesn't pugs compile for various platforms? ghc? is cayenne in haskell?
11:50:44 <SamB> how many production compilers do you even know what language they are written in?
11:50:47 <pejo> Heffalump, one could argue that Gnat is written in Ada :-)
11:51:05 <pejo> qz, "lots"?
11:51:09 <Heffalump> oh, and excluding compilers written in the language they compile
11:51:12 <qz> SamB, every compiler i use.
11:51:14 <SamB> edwardk: cayenne doesn't build with GHC...
11:51:18 <SamB> I tried it :-(
11:51:31 <SamB> it is *sooooo* bitrotted
11:51:39 <edwardk> wasn't sure about cayenne
11:51:49 <edwardk> hrmm, omega?
11:51:49 <SamB> qz: and who wrote them?
11:51:51 <Lemmih> qz: Actually, there isn't any C in the GHC compiler. It's all located in the RTS.
11:52:09 <SamB> Lemmih: what about the bytestring module?
11:52:19 <SamB> or packed string or whatever?
11:53:47 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
11:53:47 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
11:54:00 <SamB> Lemmih: the utils one, I suppose?
11:54:01 <dcoutts> SamB, not sure what you mean
11:54:18 <qz> still.. haskell is around for quite some time. if its superion in writing parsers and compilers, why there arent too many people using it for that :|
11:54:23 <SamB> dcoutts: the one GHC uses for *compilation*
11:54:24 <qz> or there's such impression
11:54:33 <qz> *superior
11:54:48 <SamB> qz: because people don't *know* that?
11:55:08 <pejo> qz, http://www.galois.com/cufp/CUFP-2004-Report.pdf
11:55:11 <lambdabot> http://tinyurl.com/y8wgng
11:55:15 <SamB> also, a lot of people are scaread of the math ;-)
11:55:22 <SamB> er, scared
11:55:31 <dcoutts> SamB, oh, sorry I thought you were talking about ByteString rather than ghc's internal FastString
11:55:50 <qz> SamB, how is math related to that? :) other languages do not really take math away..
11:55:52 <SamB> dcoutts: to be honest I had no idea what GHC was actualy using these days
11:55:54 <Cale> qz: Inertia.
11:56:00 <SamB> qz: exactly
11:56:13 <SamB> Haskell is very mathy
11:56:20 <SamB> some poeple don't like that
11:56:24 <SamB> er, people
11:56:28 <Cale> I wouldn't say you need to know very much math to learn it
11:56:31 <edwardk> qz: for one there are a number of competing traditions. you have the crowd that thinks that you should write them in c/c++ to be portable. there is a crowd that writes them in scheme coz they know scheme, there is a crowd that writes them in ML coz its somehow a standard meta language, etc.
11:56:33 <Lemmih> SamB: No, utils/FastString.lhs doesn't use any C code.
11:56:36 <Cale> but it might teach you some :)
11:56:43 <qz> SamB, is there benefit of being very mathy?
11:56:44 <SamB> Lemmih: oh really?
11:56:51 <SamB> qz: yes!
11:57:06 <Lemmih> SamB: Yep.
11:57:07 <edwardk> haskell is somewhat of a latecomer onto the scene, most compiler projects predate it to be quite honest, and folks learn c/c++ in college alongside java these days.
11:57:10 <SamB> it makes it much easier to write algorithms
11:57:16 <Heffalump> hmm, invasion of people from Oxford today
11:57:35 <qz> edwardk, well.. ruby is latecomer also and is quite popular already. despite all its flaws
11:57:53 <edwardk> qz: sure, but how many compilers do you see written in ruby? =)
11:57:55 <SamB> well, ruby isn't so radical
11:58:04 <SamB> its just another OO scripting language
11:58:04 <Cale> I wouldn't say the relationship between Haskell and mathematics is all that direct, but there's some similarities which make it nice for people who are mathematical. Being able to reason about code equationally being the huge one.
11:58:05 <Heffalump> Haskell is quite popular too..
11:58:07 <qz> edwardk, i'm not talking about compiler writing now ;) just general usage
11:58:44 <edwardk> qz: haskell requires you to break your brain apart and rewire it to think differently. not a lot of people are up for that kind of self-hackery ;)
11:58:50 * desrt finds what can only be a happy bug
11:59:01 <edwardk> desrt: there is such a thing?
11:59:07 <Cale> desrt: heh, at least it's not a sad bug
11:59:07 <Heffalump> desrt: well, at least it's not sad
11:59:10 <Heffalump> bah.
11:59:15 <Cale> jinx!!
11:59:17 <SamB> edwardk: even if you don't know imperative programming?
11:59:26 <qz> edwardk, think differently yeh. but is there a benefit? i started to use some FP stuff in my imperative programs after messing with haskell
11:59:42 * Heffalump learnt C/C++ several years before he learnt Haskell
11:59:44 <qz> but writing serious project in haskell seems like a nightmare to me ;)
11:59:47 <pejo> qz, I'm a better imperative programmer today than I was before I learnt haskell.
11:59:50 <SamB> it can be hard
11:59:50 <Cale> qz: It's not so bad :)
11:59:53 <desrt> maybe this is one of my shift/reduce errors fscking me up :(
11:59:58 <SamB> I guess
12:00:01 <desrt> ((in really non-obvious ways))
12:00:01 <qz> pejo, same :)
12:00:02 <SamB> but it is hard in other things too
12:00:05 <mauke> I stopped using C++ because it's too annoying
12:00:07 <roconnor> Is there example of using QuickCheck in the standard library?
12:00:11 <mauke> C is bearable because it doesn't even try
12:00:14 <Cale> It depends on which way it's "serious"
12:00:18 <roconnor> where do I put the checks, and how do I name them?
12:00:21 <SamB> its just that you don't so much time struggling with the typesystem in other languages ;-P
12:00:46 <Cale> Writing a program which is serious because it must be correct makes Haskell look really good to me.
12:00:49 <edwardk> welcome to the club, rc-1 =)
12:00:54 * earthy learned functional programming in a pure lazy functional language several years before he learned haskell. :)
12:01:05 <SamB> earthy: heh
12:01:06 <qz> most pain in haskell causes interoperation with the world. because you know, environment haskell runs in is not really pure and functional
12:01:24 <Cale> SamB: Time spent struggling with the type system is better than time spent wondering where the bugs are in your code. :)
12:01:31 <edwardk> qz: thats what the io monad is for, it lets you nicely box that sort of evil imperative behavior up
12:01:33 <qz> and no, hack like monads is not gonna hide it away
12:01:34 <rc-1> question: if haskell is purely functional, how do you do I/O
12:01:35 <SamB> Cale: I *KNOW* that
12:01:38 <SamB> tell *him*
12:01:45 <mauke> rc-1: you let the runtime system do it
12:01:47 <Heffalump> qz: Are you just here to troll, or do you have some interesting discussion point?
12:01:48 <Cale> Yes, I'm sort of doing that :)
12:01:49 <earthy> rc1: pass the world as a parameter. :)
12:01:50 <Cale> hehe
12:01:55 <SamB> oh, okay ;-)
12:02:06 <qz> Heffalump, you are trolling now. i'm trying to find more uses for haskell in my projects
12:02:14 <Philippa> qz: no, he's not
12:02:19 <edwardk> rc-1: we have this idea called a monad, and monads let you sort of impart an order to instructions. we have a monad for performing IO that explicitly sequences IO operations for interacting with the real world.
12:02:21 <Cale> qz: another thing is that we do have a perfectly fine IO monad for doing that interoperation.
12:02:25 <SamB> qz: monads aren't the "ugly" kind of hack
12:02:26 <mauke> rc-1: the haskell program itself just constructs a data structure describing what IO to do
12:02:29 <Philippa> IO in haskell is a solved problem, and the solution works nicely
12:02:38 <SamB> and they actually *do* hide the imperative stuff
12:02:47 <Xgc> The world is one big argument.
12:02:49 <qz> SamB, maybe. but it looked so to me.. hiding imperative stuff is not solving the problem
12:02:50 <SamB> but not from the *programmer*
12:02:55 <Cale> Xgc: oh?
12:02:56 <edwardk> rc-1: so unless your expression is typed with the IO monad, then it isn't allowed to do I/O coz its not gauranteed to be executed in sequence.
12:02:58 <qz> that two worlds are too different to talk easily to each other
12:03:04 <jmmv> miranda simulates io by using an infinite list, doesn't it?  why haskell doesn't do something similar?
12:03:16 <Baughn> jmmv: It can - it has functions for the purpose
12:03:22 <edwardk> jmmv: haskell used to, but they found the IO monad to be a lot cleaner
12:03:22 <Cale> jmmv: because using the IO monad is way more elegant
12:03:25 <Heffalump> @type interact
12:03:26 <lambdabot> (String -> String) -> IO ()
12:03:26 <rc-1> ah ok thanks all
12:03:28 <jmmv> aha
12:03:30 <Heffalump> oh, not that
12:03:33 <edwardk> jmmv: you have to be very careful not to accidentally peek ahead in the list, etc.
12:03:42 <Heffalump> no, I do mean that
12:03:47 <Philippa> qz: what problem? Many programs in imperative languages have large stretches of code that only interact internally
12:03:52 <Xgc> Cale: Sorry.  just a twist (tiny joke) on earthy's comment.
12:03:54 <SamB> qz: basically the idea is to keep the imperative stuff from messing with referential transparency
12:03:58 <jmmv> it's just I was taught that it class and then found haskell to take a radically different approach ;)
12:04:04 <Cale> Xgc: ah
12:04:19 <Cale> Yeah, I don't particularly like the view of passing the world as a parameter.
12:04:22 <Heffalump> does miranda just support one input and one output stream and nothing else?
12:04:23 <Baughn> jmmv: as the simplicity of interact suggests, haskell's approach really is more general. :)
12:04:29 <qz> Philippa, problem that OS services arent functional and pure. already said that.
12:04:33 <SamB> jmmv: would you like to hop in the time machine and try the infinite-list based IO system?
12:04:39 <Cale> qz: not a problem
12:04:45 <edwardk> jmmv: yeah, there are three competing notions one is to use continuations, the next is to use two lazy lists, the third is to use a monad. the monad gives a fairly natural imperative style of coding so it won out.
12:04:47 <SamB> the one where you put commands in one list and read the results from another?
12:04:51 <Philippa> qz: that's not a problem, try again?
12:04:52 <Cale> qz: Haskell has a beautiful FFI
12:04:53 <desrt> >> if 10 == 0 then 3 else 5
12:04:54 <desrt> >> if False then 5 else 3
12:04:55 <Heffalump> edwardk: and linear types
12:04:58 <desrt> that's quite the reduction....
12:05:00 * desrt wtfs
12:05:02 * desrt unblames happy
12:05:16 <SamB> Baughn: they had something much, much worse than interact ;-P
12:05:19 <Cale> qz: If you can call something from C, you can import it into a Haskell program with only 1 or 2 lines.
12:05:26 <edwardk> heff: yeah, but clean has it wrong, they should bundle that linear type up into a monad and not make the programmer do all the plumbing =/
12:05:27 <qz> Cale, i'll look more into that
12:05:37 <mauke> Cale: not always
12:05:37 <qz> maybe just imperative background holding me up
12:05:39 <earthy> edwardk: you can do it yourself.
12:05:40 <Heffalump> edwardk: then why bother with the linear type?
12:05:42 <edwardk> heff: er and they use uniqueness types even
12:05:45 <mauke> Cale: (see strerror_r)
12:05:50 <Heffalump> sorry, that's what I meant
12:05:56 <earthy> the uniqueness types have one huge advantage though
12:06:02 <edwardk> heff: coz then you can be save even if you allow explicit access to the constructor for the monad.
12:06:06 <SamB> qz: the basic thing is that the things you read from input are stuck in the IO monad...
12:06:10 <earthy> they allow breaking the world up into disconnected parts
12:06:24 <edwardk> and you can construct your own notion of passable linear resources.
12:06:28 <rc-1> is there a ruby/haskell interface? i just made a game in ruby and i think it would be a good way to learn haskell by programming an AI in it for my game
12:06:36 <earthy> thereby actually allowing concurrent I/O to different elements of the world
12:06:39 <Cale> mauke: hm?
12:06:40 <edwardk> uniqueness types are part of the solution, not the whole thing.
12:06:45 <mwc> I think the Monad concept won out for IO because it's a really nice way of structuring code
12:06:51 <qz> SamB, yeh. i was using monads happily, there was problem writing own though ;)
12:07:01 <mwc> If FP types were more self promoting, I dare say Haskell would be called a Monadic-Orientated language
12:07:04 <mauke> Cale: glibc has two incompatible versions of strerror_r, selected by a #define
12:07:09 <Baughn> rc-1: I don't think it counts as "good", but you can always communicate through C. Swig might or might not be useful.
12:07:11 <SamB> qz: it isn't so hard
12:07:12 <Cale> mauke: ah, okay
12:07:21 <desrt> ok.  wicked.
12:07:27 <SamB> qz: first, you try just building a LEGO monad with the MTL, though
12:07:30 <earthy> whereas with Haskell you're bound to this one I/O monad that does full ordering of all I/O actions
12:07:30 <mauke> Cale: one of them uses gcc's void foo() asm("bar"); trick
12:07:34 * desrt nukes the very silly bug, gets factorial (defined via Y combinator) workin
12:07:38 <edwardk> rc-1: you could theoretically go through the ffi to generate a c style interface and then use ruby's native call stuff to interact with that, but i'll be honest its probably not the best tool for that job.
12:07:40 <Cale> mauke: Well, it won't automatically fix design problems with C libraries :)
12:07:57 <skew> earthy: did you see the "determinisitic concurrency" paper from ICFP?
12:07:59 <rc-1> nevermind, sounds too complicated :)
12:08:06 <earthy> skew: nope, haven't seen it
12:08:09 <mauke> if it generated a C stub instead of directly linking with glibc, it would work
12:08:10 <edwardk> samb: heh LEGO
12:08:13 * Heffalump has a perl-haskell binding written that way, FWIW
12:08:23 <rc-1> any reccomended free books on it?
12:08:29 <SamB> edwardk: what analogy would you refer to the MTL with?
12:08:39 <SamB> btw, I happen to *like* LEGOs
12:08:53 <earthy> holyer and carter?
12:08:54 <edwardk> rc-1: well, i would recommend starting with some online stuff: Yet Another Haskell Tutorial, then move up to the 'All About Monads' tutorial
12:08:58 <wolverian> Heffalump, is it on CPAN?
12:09:00 <skew> earthy: it was also about dividing up acces to different resources between different computations to allow concurrency, but presented with monads
12:09:02 <mwc> SamB, I was a Lego Technique kid myself
12:09:07 <edwardk> rc-1: there is a book or two out there, but the online stuff is pretty solid for haskell
12:09:14 <desrt> hey... here's a neat question
12:09:14 <SamB> in case someone thought I was somehow disparaging the MTL or its users
12:09:22 <edwardk> rc-1: after that lurking here on channel is how most of us learned
12:09:24 <SamB> mwc: isn't that spelled "technic"
12:09:24 <SamB> ?
12:09:24 <edwardk> > 1 + 1
12:09:26 <lambdabot>  2
12:09:26 <Cale> qz: but basically, be fairly careful about the dates of documents written which criticise Haskell, since quite a lot has been done about practicality on many levels over the last few years.
12:09:29 <desrt> does anyone know how you're supposed to test for equality of church numbers in straight-up lambda calc?
12:09:31 <edwardk> plus the bot here executes haskell =)
12:09:35 <rc-1> edwardk: gotcha, thanx
12:09:40 <mwc> SamB, dunno. I was canadian, so our packages may have been different
12:09:41 <qz> Cale, i do not read such documents ;)
12:09:51 <Heffalump> wolverian: no. It's a "call Perl from Haskell" binding, rather than "call Haskell from Perl", so it wouldn't really belong there.
12:09:53 <skew> SamB: I think "LEGO" is the name of an early dependent type checker McBride wrote, and I often see the toys spelled "Lego"
12:09:55 <SamB> mwc: seriously? why would they give you different stuff?
12:10:11 <SamB> hmm. well, the lettering on the studs is LEGO
12:10:12 <SamB> okay?
12:10:12 <qz> Cale, actually i read just one blog of a guy who tried to use haskell but ended up with erglang. and i didnt mention it in discussion at all ;)
12:10:28 <Philippa> desrt: subtract one from the other and isZero?
12:10:33 <Heffalump> and it's not really very finished or robust. Works for what I want though :-)
12:10:34 <wolverian> Heffalump, mm. I suppose so.
12:10:40 <qz> *erlang
12:10:44 <skew> edwardk: also, Wadler has some recent paper related monads and effect systems
12:10:53 <Cale> qz: Yeah, there's a lot of FUD out there which might have been true at the time that it was written, but which no longer applies.
12:11:00 <desrt> Philippa; hm.  i don't know how to do subtraction either :)
12:11:07 <mauke> hmm, you can import the same foreign function under different names/types, right?
12:11:07 <earthy> ah, no, dowse and butterfield.
12:11:20 <lispy> desrt: pred, the opposite of succ :)
12:11:29 <desrt> lispy; surely that's not defined
12:11:30 <skew> Cale: like "big arrays make GC slow", "Haskell doesn't do SMP", etc.
12:11:37 <SamB> qz: are you talking about... um...
12:11:42 <SamB> oh man what is that guys name?
12:11:48 <skew> Joel
12:11:52 <qz> no
12:11:55 <qz> http://wagerlabs.com/articles/2006/01/01/haskell-vs-erlang-reloaded that one
12:11:58 <lambdabot> Title: The Erlang Fix : Haskell vs. Erlang, Reloaded, http://tinyurl.com/cbfu7
12:11:59 <SamB> ah, yeah, joelr
12:12:02 <edwardk> rc-1: a lot of us picked up things by watching people golf various problems people brought onto channel. come on, paste some code ask why its not working and typically someone here will reduce it to a one liner.
12:12:02 * Heffalump remembers that article
12:12:05 <SamB> yeah, that is joelr's entry
12:12:09 <qz> Joel has nothing to do with haskell i think ;)
12:12:13 <edwardk> > fix $ \x -> 1 : 1 : zipWith (+)  x (tail x)
12:12:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:12:18 <qz> aw, i ment other joel
12:12:22 <SamB> heh
12:12:23 <mwc> SamB, I think Canadians tend to be less tolerant of neo-spellings
12:12:26 <Cale> qz: yeah, that guy would have had a much better time if Data.ByteString had been around
12:12:29 <SamB> mwc: oh
12:12:50 <skew> It sounded like he would have been happier with a real record system, or something like it
12:12:55 <SamB> mwc: I pronounced it as spelled, myself
12:12:55 <qz> Cale, so everything he's written is no longer relevant?
12:13:00 <skew> I think he should have brought his typing problems to Oleg's attention.
12:13:03 <SamB> but then I hardly got any technics
12:13:05 <mwc> SamB, plus, the name translates better to French, so they could use the same giant TECHNIQUE banner for both languages
12:13:41 <SamB> most of my technic pieces are from mindstorms kits
12:13:42 <lispy> qz: i dunno, about everything, but somewhat recently he said he's preferring to use haskell more and more, iirc
12:13:50 <SamB> (unfortunately I think they are also missing)
12:14:17 <edwardk> skew: the only problem with bringing something to oleg's attention is then you have to be able to parse the response ;)
12:14:21 <mwc> Heh, I by the time Mindstorms were out, I was old enough to braze, solder, and use powertools
12:14:34 <SamB> qz: he had real struggles with Haskell, yes...
12:14:45 <lispy> but, erlang is very good at solving the problem he had, I think as much as i like haskell, he was right to use erlang
12:15:04 <SamB> yeah, he should have stopped trying to make Haskell do that much sooner
12:15:08 <SamB> probably
12:15:12 <mwc> How does Erlang's IO system work?
12:15:14 <mwc> Monads?
12:15:28 <qz> SamB, because haskell compiler was not quite ready at that time or.. ?
12:15:29 <SamB> it isn't pure
12:15:29 <dolio> Impurity.
12:15:30 <lispy> mwc: i think it's like lisp or scheme
12:15:42 <mwc> Ah, heretical :)
12:15:46 <SamB> qz: because Haskell does not have extensible records
12:15:50 <edwardk> nah erlang is one of those evil imperative call-by-value kinda things where they just cruft up the notion of functions by allowing side effects ;)
12:15:58 <SamB> among other things
12:16:15 <mauke> call by value is evil
12:16:21 <SamB> hehe
12:16:33 <edwardk> nah side effects are evil, call-by-value is just mildly annoying ;)
12:17:01 <edwardk> i'd be perfectly ok with an honest call-by-value language that was pure, with a lifting monad for laziness.
12:17:25 <mauke> how can you see call-by-value in a pure language?
12:17:45 <mwc> Heh, I read that paper where Wirth got his troll on for FP. He claimed it's unnatural to eschew destructive assignment on a machine that fundamentally operates by assignment to memory cells. I kinda read that thinking it's unnatural to do mathematics on a machine that operates by assignment to reference cells
12:17:48 <edwardk> mauke: by divergence
12:17:54 <edwardk> mauke: otherwise not much at all
12:18:15 <Philippa> mauke: does take 1 ones where ones = 1 : ones terminate? :-)
12:18:20 <edwardk> mwc: knuth has made similar comments
12:18:26 <mauke> depends on your definition of "value"
12:18:37 <mauke> you could just clone the thunks
12:19:02 <SamB> mwc: seriously?
12:19:08 <Cale> I'd say that it does. It terminates immediately, returning a cons cell :)
12:19:09 <SamB> like what other kind of machine is practical?
12:19:13 <lispy> mwc: i might agree with the unnatural to do mathematics if you said "on a machine which has no support for non-determinism"
12:19:44 <SamB> lispy: what the?
12:20:11 <Cale> qz: Maybe some of it might provide directions toward new libraries, but the majority of his problems I think would have been solved by Data.ByteString
12:20:18 <mwc> lispy, how about we support nondeterminism by "halt and catch fire."
12:20:58 <lispy> SamB: if computers could efficiently do non-deterministic computations, we wouldn't need things like laziness would we?
12:21:35 <qz> Cale, i see. thanks for comments on that
12:21:41 <Cale> qz: Also, he had the problem that the performance he was trying to get was probably impossible in any language. He had the same problem after switching to Erlang, and then finally lowered his standards :)
12:21:45 <roconnor> @hoogle Either a b -> Bool
12:21:46 <lambdabot> No matches, try a more general search
12:22:01 <roconnor> do we need isLeft and isRight too?
12:22:25 <SamB> Cale: heh
12:22:31 <SamB> I hadn't heard about that ;-)
12:22:32 <lispy> the definiton of isSubsequence x y = x `elem` (inits y), would be O(|x|) if we had non-determinism, right?
12:23:25 <SamB> huh?
12:23:39 <SamB> inits would be O(|y|), wouldn't it?
12:23:46 <Cale> SamB: It's something I realised when he was trying to have an insanely large number of threads running, and all of them relatively active, and he wanted to ensure that each of them completed the tasks it was given in some fairly short time interval.
12:24:04 <SamB> Cale: hmm.
12:24:20 <Cale> When he rewrote the program in Erlang, he had the exact same problem.
12:24:44 <lispy> SamB: i'm imagining you (in some sense) |inits y| machines to each check if x is a member, so comparison is bounded by the length of x
12:24:47 <Cale> It just wasn't possible to do that much work at the same time, no matter how fair your thread scheduler was.
12:24:54 <palomer> Cale, how do you like erlang?
12:25:06 <SamB> lispy: well, I was assuming lists were linked
12:25:19 <Cale> palomer: I haven't really used it enough to judge it. It seems interesting though.
12:26:16 <roconnor> @hoogle isLeft
12:26:17 <lambdabot> No matches found
12:26:26 <roconnor> @hoogle left
12:26:27 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
12:26:27 <lambdabot> Prelude.Left :: a -> Either a b
12:26:27 <lambdabot> Control.Arrow.leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
12:26:47 <ndm> roconnor: propose it as a library addition - its an essential function!
12:26:52 <ndm> also fromLeft and fromRight!
12:27:21 <bdbit> I've heard Guido van Rossum, the author of Python, say something like, "ML is a great language--it's just too bad you have to have an IQ higher than 150 to use it."
12:27:25 <bdbit> <3
12:28:45 <dolio> Well, that's the IQ test I'm going to use from now on.
12:29:34 <skew> what does it take to write correct code in C then?
12:29:42 <Baughn> An act of god
12:29:46 <SamB> heh
12:29:53 <ndm> nah, C's easy :)
12:29:55 <Baughn> Or a very simple design
12:30:02 <ndm> slow, very slow, but not that hard
12:30:02 <SamB> you just have to do essentially nothing
12:30:07 <emu> C redefines correct to "does something"
12:30:15 <SamB> emu: no no no
12:30:28 <pejo> emu, I always get the core dump, a proof that something happened!
12:30:32 <SamB> C redefines correct to "does next to nothing"
12:30:44 <mauke> woo, Couldn't match expected type `CLong' against inferred type `CInt'
12:30:47 <emu> i didnt say something had to be much
12:30:57 <mauke> @karma+ strong typing
12:30:58 <lambdabot> strong's karma raised to 1.
12:31:01 <mauke> argh
12:31:02 <roconnor> ndm: Okay,
12:31:20 * ndm thinks of writing a Haskell compiler in C
12:31:22 <roconnor> @instances Arbitrary
12:31:23 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
12:31:31 <roconnor> @instances QuickCheck.Arbitrary
12:31:32 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
12:31:35 <Baughn> ndm: ghc?
12:31:39 <roconnor> @instances Quickcheck.Arbitrary
12:31:40 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
12:31:47 <emu> Test.QuickCheck?
12:31:48 <ndm> Baughn: no, GHC is written in haskell
12:31:55 <roconnor> @instances Test.QuickCheck.Arbitrary
12:31:59 <ndm> Baughn: Hugs is written in C, as it happens
12:32:10 <Baughn> ndm: GHC is supposed to be able to bootstrap from C, though
12:32:23 <SamB> Baughn: it is probably not easy though
12:32:26 <emu> writing a compiler in C? why make a hard problem difficult
12:32:27 <ndm> Baughn: yes, but after Haskell->C convertor, C is the low level
12:32:33 <skew> Baughn: GHC can compile Haskell by generating C for gcc
12:32:44 <Baughn> skew: Does it normally do that?
12:32:46 <pejo> ndm, why on earth would you do that?
12:32:48 <SamB> depends
12:32:59 <skew> Baughn: You can bootstrap it by saving those C files and copying them to your new machine
12:33:01 <ndm> emu: was thinking of doing lots of domain specific languages, with Haskell and C back ends, then writing a compiler using them
12:33:04 <mauke> @hoogle new
12:33:05 <lambdabot> Data.HashTable.new :: (key -> key -> Bool) -> (key -> Int32) -> IO (HashTable key val)
12:33:05 <SamB> on some architectures it doesn't support that
12:33:05 <lambdabot> Foreign.Marshal.Utils.new :: Storable a => a -> IO (Ptr a)
12:33:05 <lambdabot> Data.Graph.Inductive.NodeMap.new :: Ord a => NodeMap a
12:33:05 <Baughn> skew: Right..
12:33:11 <SamB> er.
12:33:14 <mauke> oh, hmm
12:33:18 <SamB> doesn't support the *other* way, rather
12:33:19 <emu> DSL? how about Template Haskell
12:33:20 <skew> I think it can still be somewhat faster than the direct native code generator
12:33:30 <ndm> emu: thats not a DSL
12:33:37 <ndm> emu: i mean like parser/type checker DSL's
12:33:53 <psi> hm, what's the best way of getting ghc 6.6 onto the latest ubuntu?
12:34:05 <psi> snatch the debian package?
12:34:06 <SamB> ndm: you would hopefully write the DLSs in Haskell?
12:34:22 <ndm> SamB, of course! (do I look crazy?)
12:34:30 <SamB> hehe
12:34:43 <mauke> btw, foo = undefined rocks for rapid prototyping
12:37:02 <integral> mauke: I prefer: error "<something> is unimplemented" for a better error
12:37:26 <SamB> integral: well, the Report says something about compilers maybe doing that, iirc
12:37:33 <mauke> ok, that's a simple search/replace
12:37:34 <SamB> but GHC for some reason doesn't
12:37:39 <integral> SamB: doing what?
12:38:04 <SamB> replacing "undefined" with something saying where in the source it appeared
12:38:11 <roconnor> @hoogle Either a b -> a
12:38:12 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
12:38:18 <integral> oh, right.
12:38:20 <mauke> :%s/^\(\s*\w\+\)\s*=\s*undefined\s*$/\1 = error "\1 is unimplemented"/
12:38:40 <integral> Maybe it's to maintain the high standard of GHC's informative errors :-P
12:40:52 <desrt> grrr
12:41:05 <mathewm> what is yhc?
12:41:16 <desrt> my inability to correctly parse application is getting annoying
12:41:30 <mauke> @vixen what is yhc?
12:41:30 <lambdabot> let's don't talk about that
12:41:34 <Baughn> mathewm: ghc, you mean?
12:41:42 <integral> A bytecode-based haskell compiler
12:41:43 * desrt wants to copy/paste lambda expressions from papers into his interpreter but is being screwed by incorrect associativity :(
12:41:57 <integral> Baughn: yhc is different from ghc. 'y' /= 'g'!
12:41:57 <mauke> http://www.haskell.org/haskellwiki/Yhc
12:41:59 <lambdabot> Title: Yhc - HaskellWiki
12:42:06 <Baughn> Hmm. Looked like a typo.
12:42:47 <ndm> Baughn: no, its totally different :)
12:43:22 <Baughn> Shouldn't that be hc?
12:43:38 <integral> it's actually an upside down lambda...
12:43:50 <Baughn> ..evil
12:44:23 <ndm> thats just the logo, its Yhc for normal purposes
12:45:34 <Baughn> Now, now. Obviously we must convince Zeus to add it in the next edition of the greek alphabet.
12:45:51 * SamB thinks the optimizer ought to "look through" do-nothing primitives when trying to figure out how expensive something is, or whether it is interesting...
12:46:19 <mathewm> I am sure we can add a unicode modifier to rotate and/or flip characters :)
12:46:43 * ndm senses that SamB is working on another GHC optimiser patch
12:46:59 <SamB> ndm: still the same stuff, really...
12:47:11 <ndm> SamB, I hope to release Yhc -O in the next 2 weeks at most
12:47:30 <SamB> you don't even have *types* in your IR
12:47:41 <ndm> (or rather make the code and settings publically available, rather than a proper release)
12:47:46 <ndm> SamB, what do you need types for?
12:47:49 <mauke> GREEK SMALL LETTER LAMDA INVERTED WITH PANCAKE ON TOP
12:47:54 <SamB> hahahahah
12:48:36 <Philippa> ndm: it supposedly helps a lot when debugging optimisation passes. I suspect there're optimisations that can make use of the info, too
12:48:55 <SamB> its also good if you want to know whether something is lifted or not
12:48:58 <Philippa> assorted forms of specialisation'd be an obvious one
12:49:04 <ndm> Philippa: i bet its really handy for debugging them! but i'm unconvinced there are that many that can be done using type info
12:49:15 <ndm> Philippa: my compiler does specialisation without types, GHC has them and doesn't :)
12:49:34 * ndm suspects this is propaganda done by type theorists...
12:49:51 <Philippa> type-directed specialisation's a known technique, if that's what you mean
12:49:56 <SamB> ndm: it is just better to have them
12:50:00 <lispy> ndm: i thought everything in #haskell was propagando by type theorists :)
12:50:08 <SamB> nevermind whether you have to use them much or not
12:50:26 <Philippa> if you had all GHC's type class extensions, would you be able to specialise as well without type info as with?
12:50:26 <SamB> at worst they help with stuff like -dcore-lint
12:50:33 <ndm> SamB, i agree, but i don't, and in practice it's not as hard
12:50:46 <ndm> Philippa: yes - the type classes are gone by Core level, you only have dictionaries
12:50:59 <roconnor> @spell received
12:51:00 <lambdabot> received
12:51:23 <SamB> ndm: but can you prove that two dictionaries are the same based on types?
12:51:26 <SamB> not that GHC does anyway.
12:51:44 <Philippa> thinking about it, I'd probably be more interested there in looking at optimising evidence translation in an impredicative system
12:51:53 <lispy> what does a dictionary store?
12:51:58 <Philippa> where things get a bit more involved
12:51:59 <SamB> lispy: methods
12:52:03 <SamB> it stores methods
12:52:11 <SamB> also superclass dictionaries
12:52:38 <lispy> SamB: just for type classes or do they get used for all functions?
12:52:46 <SamB> just type classes
12:52:47 <Philippa> just for type classes
12:52:48 <ndm> SamB, no, you can't prove anything about dictionaries only from the types
12:52:55 <SamB> other functions are not called methods
12:52:59 <lispy> SamB: is a dictionary how you look up the definition for a particular instance?
12:53:00 <SamB> ndm: sure you can!
12:53:29 <SamB> at least, if you have the dictionary types parameterized by the typeclass parameters...
12:53:33 <lispy> (how is a dictionary indexed)
12:53:58 <SamB> the dictionary is basically the compiled form of the "instance"
12:54:20 <lispy> SamB: would C++ have called them vtables?
12:54:27 <Philippa> lispy: more or less
12:54:47 <lispy> thanks, i think that helps quite a bit
12:54:47 <Philippa> though the techniques go in different directions as you look at MI, MPTCs etc etc
12:55:11 <Philippa> you have one dictionary passed per class constraint in a type
12:55:22 <Philippa> rather than them being part of the values
12:55:41 <lispy> MI == multiple inheritance?
12:55:52 <SamB> yeah
12:55:52 <Philippa> though once you have existential values, those can have class constraints in their types...
12:55:53 <Philippa> yep
12:56:03 <lispy> ah, right
12:56:09 <SamB> it helps not to have data fields in classes ;-)
13:00:21 <emu> do people tend to adopt the GHC license for their own projects?
13:01:06 <desrt> that seems unlikely
13:01:33 <lispy> isn't the GHC license just BSD3?
13:01:34 <emu> open source projects i mean
13:01:34 <ndm> emu: you mean BSD?
13:01:37 <emu> yes
13:02:25 <lispy> i used to be die hard GPL myself...but now that i work at a job and lots of my projects are closed source, i've become a fan of BSD
13:03:01 <lispy> if it has the GPL then generally i can only use it as a tool and not link with it
13:03:08 <desrt> lispy; right.  but you're the anti-christ :)
13:03:21 <edwardk> lispy: theoretically, but you may have to use it under lgpl terms  coz of the gmp code it uses.
13:03:33 <lispy> desrt: i wondered why it stings when i enter churches
13:04:06 <roconnor> Can I get ghci to not load the prelude?
13:04:21 <lispy> edwardk: well, if i understand correctly, i can avoid the gmp issues by using static linking
13:04:35 <lispy> roconnor: :m - Prelude
13:04:38 <lispy> i think that works
13:04:56 <SamB> roconnor: the Prelude will have to have been built already...
13:05:08 <SamB> because stage2 depends on the Prelude, oddly enough
13:05:30 <pejo> emu, I don't think it's an exaggeration to claim a lot of code is written with a BSD type of license. Which is great, as lispy points out you can use the code. :-)
13:05:31 <lispy> roconnor: ah, yeah my think works to unload the prelude
13:08:02 <lispy> roconnor: also, you could write import Prelude () -- at the top of your module and it should have the effect of loading nothing from Prelude
13:08:41 <lispy> i was thinking about arrows this morning
13:08:59 <lispy> and i was thinking about how one of the uses of arrows is data flow
13:09:19 <lispy> and then i was thinking about shells, and how one of the common things to do interactively in a shell is pipe data around
13:09:35 <lispy> so, maybe bash, or similar, should have syntax for doing arrows :)
13:09:50 <emu> no that's great, I often use BSd-style licenses.  suddenly decided to check around first though
13:11:03 * EvilRanter is back (gone 02:14:57)
13:11:47 <lispy> i'll use BSD if i start the code at home, even if i intend to use it at work
13:12:03 <lispy> this isn't common, but it's happened a few times
13:12:33 <lispy> usually, i try to get work to pay for the software i wrote that i use there, but sometimes it's just something that makes my work environment nicer, or a tertiary to the project
13:13:28 <emu> yea, i got the idea from work, decided to implement the algorithm in haskell for didactic but also testing purposes
13:17:00 <edwardk> hi andy!
13:17:05 <bdbit> gn8
13:17:17 <lispy> one job right after my undergrad i was doing data entry so i wrote tools to optimize the data entry...
13:17:50 <SamB> cool!
13:18:01 <SamB> how does that work?
13:18:06 <lispy> my manager realized how labor intensive the data entry was and commissioned another team in the company to build us tools...sadly the extremely simple ones i made were far superior to the editor the dev team was trying to make
13:18:17 <SamB> heh
13:18:36 <emu> they tried to write a whole editor?
13:18:39 <lispy> the main tool was a way to apply regular expressions quickly
13:18:43 <lispy> yeah
13:18:57 <emu> sigh
13:19:13 <lispy> it had an input buffer, a list of regexp that were applied sequentially and then a buffer where you could copy the results from
13:19:40 <SamB> so basically sed in a box?
13:19:46 <lispy> and the regular expressions basically just latex-ified math problems written in english
13:19:49 <lispy> SamB: yeah!
13:20:10 <lispy> it wasn't perfect because it was just regexp, but did 80% of the work in just a few seconds
13:20:26 <emu> probably could write an emacs lisp program to do that in an hour
13:20:35 <lispy> emu: hehe, yeah
13:20:45 <SamB> if you knew enough elisp
13:20:51 <emu> elisp is simple
13:21:00 <emu> and emacs is still its own best IDE ;)
13:21:03 * lispy has written couple thousand lines of elisp
13:21:14 <SamB> I suppose it might take two hours if you didn't know enough elisp
13:21:23 <lispy> i rewrote parts of VM at one point (the mail client)
13:21:29 <SamB> whoa
13:21:44 <emu> i'm getting tired of haskell-mode deficiencies so I'm embarking on a project to fix it
13:21:47 <lispy> yeah, i realized i was using the wrong client if i was just rewriting it :)
13:21:50 <SamB> FIX?
13:21:53 <SamB> why FIX?
13:22:31 <emu> eh
13:22:35 <emu> we'll see
13:22:54 <SamB> (is it too hard to write Haskell parser in elisp?)
13:23:07 <SamB> (or too hard to make it incremental?)
13:23:23 <SamB> (or too annoying to deal with extension syntax?)
13:23:24 <emu> i don't know.  i'm investigating these things right now.
13:23:37 <emu> i am thinking about using ghc parts to do the heavy lifting
13:23:42 <Maddas> (require 'haskell) ;; ;-)
13:24:16 <psi> make it do type checking on the fly :)
13:24:19 <emu> yep
13:24:21 <SamB> psi: heh
13:24:30 <SamB> oh, ghc
13:24:31 <emu> not only type checking, but show the results of inference on demand
13:24:34 <SamB> ghc could do that...
13:24:38 <SamB> that would be neat
13:24:50 <pejo> SamB, for the incremental parser - you could just run the compiler every now and then, and compare with the result you got a while ago.
13:24:51 <SamB> like what they were thinking for hIDE
13:24:52 <emu> along with inline docs
13:25:46 <SamB> pejo: have you seen nxml-mode?
13:25:55 <emu> nxml-mode is great
13:26:00 <SamB> yeah it is!
13:26:12 <SamB> too bad it doesn't seem to like mule-utf8
13:26:23 <SamB> maybe that isn't a problem anymore though
13:26:30 <emu> i use emacs22 cvs now
13:26:33 <pejo> SamB, heard of it. Never used it. But isn't that for the sgml-family of markup languages?
13:26:44 <emu> it's for any XML, it does DTD validation on the fly
13:26:46 <SamB> pejo: no, only for XML
13:27:05 <SamB> SGML is a bit too much for a mere elisp program ;-)
13:27:05 <lispy> emu: ghc-api?
13:27:25 <lispy> emu: hang on, bringert recently wrote something that makes use of it, maybe his code is helpful to look at
13:27:26 <emu> yea i'm digging in ghc manual atm
13:27:39 <lispy> http://csmisc14.cs.chalmers.se/~bjorn/dynhs/dynhs_root/source.hs/examples/wiki/wiki.hs
13:27:41 <lambdabot> Title: examples/wiki/wiki.hs, http://tinyurl.com/yfcde9
13:27:41 <lispy> examly output
13:27:47 <SamB> alos, it doesn't support DTDs but rather Relax NG Compact schemas ;-)
13:28:09 <SamB> which trang can make from DTDs easily enough
13:28:35 <lispy> emu: hmm...i don't know thelink to the repository :(
13:28:50 <SamB> er.
13:28:51 <bringert> the source highlighting in the example lispy showed is actully produced by hscolour
13:28:55 <SamB> also, not alos...
13:29:17 <bringert> here is one with some ghc input in it: http://csmisc14.cs.chalmers.se/~bjorn/dynhs/dynhs_root/source.hs/examples/error.hs
13:29:20 <lambdabot> Title: examples/error.hs, http://tinyurl.com/yja9tc
13:29:28 <emu> i have an elisp function somewhere for exporting emacs font-lock buffers to HTML
13:29:35 <lispy> bringert: ah, my bad
13:29:59 <lispy> bringert: where is your darcs repo?
13:30:04 <roconnor> @instances Test.QuickCheck.Arbitrary
13:30:11 <bringert> I've been thinking that it should be possible to use the GHC lexer for syntax coloring too, but I haven't gotten around to it
13:30:14 <SamB> emu: CSS-based?
13:30:17 <lispy> bringert: i think emu could probably get a jump start using your code as reference
13:30:44 <bringert> lispy, emu: http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/
13:30:46 <lambdabot> Title: Index of /~bringert/darcs/dyn-cgi, http://tinyurl.com/ydpute
13:30:53 <lispy> thanks
13:30:58 <emu> SamB: no, unfortunately it adds FONT tags.  it probably wouldn't be difficult to modify though.
13:31:03 <bringert> especially this module: http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/DynHS/GHCUtils.hs
13:31:05 <lambdabot> http://tinyurl.com/yctpxd
13:31:10 <emu> yes, you use ghc api?
13:31:14 <bringert> yeah
13:31:17 <pejo> Didn't someone (Lemmih?) start working on bringing out the parser from ghc into a module?
13:31:33 <edwardk> have been using Text::VimColor from perl to highlight haskell lately. not great but its 4 lines to get usable results.
13:31:40 <SamB> pejo: I'm guessing that this "ghc" package does that?
13:31:49 <bringert> my GHCUtils module is a wrapper around some of the ghc-api to load modules, lookup functions, and get at compiler error messages
13:31:55 <SamB> the one that they forgot to include in the stage3 builds?
13:32:17 <emu> darcs getting it now
13:32:58 <bringert> emu, I haven't documented much at all, feel free to ask me about stuff
13:34:00 <emu> what's SysTools?
13:34:17 <lispy> ?hoogle mapAccumL
13:34:18 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
13:34:19 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:34:34 <lispy> oh, yeah, that's nice to know about
13:37:59 <lispy> ?type foldr (.) id
13:38:00 <lambdabot> forall a. [a -> a] -> a -> a
13:38:31 <lispy> i don't see how that replaces the need for intercalate
13:38:37 <cjeris> this compiler back end is giving me new hatred and despite for the concept of a "load-store architecture".  sure it is nicer to optimize, but it takes quite a while for the poor confused student to get it WORKING AT ALL
13:41:43 <lispy> is x86 a load-store architecture?
13:42:04 <cjeris> no (there are direct memory-memory moves iirc).  we're compiling to MIPS32
13:42:27 <lispy> ah, hmmm
13:42:36 <emu> hmm i see, i need -package ghc-6.6
13:42:57 <lispy> i took a class on mips once, but i don't remember much
13:43:01 <cjeris> i'm just frustrated because it feels like my program will generate very bad code.  (it certainly will until we do the register allocator at the end of the semester.)
13:43:14 <edwardk> lispy: no coz you can access operands that are right in memory.
13:43:26 <edwardk> lispy: but its kind of half way there coz you usually cant refer to two memory operands
13:43:49 <cjeris> except for satanic evil like 'rep movsw'
13:43:50 <edwardk> add [eax] [eax] (in intel notation isn't an opcode)
13:44:07 <qz> one operand must be register or imm, yeh
13:44:36 <edwardk> cjeris: yeah there are a couple of other weird cases like that but in general unless its from the 8088/80286 early CISC extensions they shy away from such things
13:44:36 <Heffalump> cjeris: why is it significantly harder?
13:45:03 <cjeris> Heffalump: i didn't say hard_er_...  i'm just complaining. :)
13:45:11 <edwardk> er 8086
13:45:16 <Heffalump> :-)
13:45:32 <cjeris> at least register allocation is easy on x86.  "Can I have a register?"  "No."
13:45:36 <Heffalump> :-)
13:45:38 <edwardk> cjeris: hahahaha
13:46:19 <emu> whcih book are you using
13:46:27 * Heffalump 's day job includes maintaining our register allocator
13:46:49 <pejo> Heffalump, does it ever "break"?
13:46:51 <cjeris> if we had to account for the timing issues that are explicitly exposed in MIPS, like that certain things stall for a cycle and you have to do something else in the interim, i'd be going _completely_ insane.
13:47:11 <lispy> cjeris: actually in x86_64 they seem to have added r8-r15 as general purpose registers
13:47:13 <cjeris> emu: appel's blue book.  but we're going back-end-forward, doing a code generator for a simple C subset and then piling language features on top.
13:47:15 <Heffalump> pejo: define "break"?
13:47:24 <integral> cjeris: there's an easy trick for that: just always add padding noops after each instruction :)
13:47:26 <pejo> cjeris, so put in a nop?
13:47:50 <mauke> what does Foreign.Marshal.Alloc.malloc do if it runs out of memory? return nullPtr, throw an IO exception, abort?
13:47:59 <cjeris> integral, pejo: well, but if I tried to do better :)
13:48:39 <lispy> mauke: i'm not sure, ghc has a hook in the rts for when it runs out of heap, but maybe you get an exception first...you could probably test this
13:48:41 <integral> cjeris: hmm, I suppose then you could just use a peephole optimisers to make it a wee bit better.  And being just peephole it's a nice separate pass from everything else
13:48:42 <roconnor> Does Arbitrary Either belong in Testing.QuickCheck, or in Data.Either? ... I guess the first?
13:48:54 <cjeris> honestly, it's just that this, at age 30, is my real computer science education (finally) and it's as hard for me as for anyone else.  so i complain because the class is challenging :)
13:49:10 <pejo> Heffalump, if it always works maintainance should be easy - and they wouldn't pay you. :-)
13:49:35 <cjeris> Heffalump, what is the day job?
13:49:53 <emu> cjeris: yes, I used that
13:50:32 <mauke> "If any of the allocation functions fails, a value of Ptr.nullPtr is produced."
13:50:39 <mauke> yay for http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-330005.8
13:50:41 <lambdabot> Title: 5 Marshalling, http://tinyurl.com/yl8j7o
13:51:20 <lispy> mauke: sounds like they use C's way heer
13:51:37 <mauke> that's a good thing
13:52:35 <Heffalump> pejo: that's only part of my job :-) And sometimes it needs features added.
13:52:44 <Heffalump> (and yes, occasionally it does break ;-)
13:52:56 <Heffalump> cjeris: I work on ARM's C/C++ compiler
13:53:04 <Syzygy-> Heffalump: Oooooooooh.
13:53:09 * Syzygy- has worked on that...
13:53:23 <Syzygy-> Was at my prvious, non-academic, job, but still...
13:53:24 <cjeris> Heffalump: never programmed an ARM, but I have at least a couple at home (GBA uses ARM, does DS?)
13:53:25 <Heffalump> "worked on" in what sense?
13:53:33 <Syzygy-> Not as in built compiler, but rather as in used compiler.
13:53:44 * Syzygy- did cryptography and security for cell phones.
13:53:46 <Heffalump> cjeris: errm, can't remember (and if I could I might not be sure what was public)
13:53:49 <Heffalump> Syzygy-: cool
13:53:54 <Heffalump> how long ago?
13:53:57 <Syzygy-> With a spinoff firm from layed off Nokia and Ericsson technicians.
13:54:10 <Syzygy-> I stopped when I got my current PhD student position: last easter.
13:54:15 <Syzygy-> Having worked almost a year.
13:54:16 <Heffalump> (it's quite rare to randomly run into people who use it, cos it's so expensive)
13:54:26 <mauke> great, realloc's behavior is unspecified
13:54:29 <cjeris> ...yes: GBA = ARM7TDMI, DS = ARM9E.  so, at least 3 at home. :)
13:54:37 <mauke> I'm going to assume it works like in C
13:55:10 <cjeris> Heffalump: is it a fun architecture?
13:55:10 <Syzygy-> Y'know, when you work for people who are about to build and ship a couple of million cell phones, and they want you to provide a crucial piece of one of their main selling features, they're throughout willing to pay for an ARM license for you... :P
13:55:20 <Heffalump> cjeris: yeah, I quite like it
13:55:29 <Heffalump> it's RISC with some interesting add-ons
13:55:37 * Syzygy- has (alas) been involved in getting cellphones certified for Microsofts DRM architectures...
13:55:43 <Heffalump> e.g. load multiple, conditional execution, shifted operands
13:56:02 * Heffalump routinely walks around with two ARMs in his pocket, which is quite cool
13:56:03 <Syzygy-> Heffalump: You work on the actual compiler? As in building it?
13:56:06 <Heffalump> (well, one is an XScale)
13:56:08 <Heffalump> Syzygy-: yes
13:56:13 <Syzygy-> Coooooooooooool.
13:56:17 <Syzygy-> :)
13:56:23 <Heffalump> which version did you use?
13:56:35 <Syzygy-> Good question. I really couldn't tell you. :/
13:56:40 <Heffalump> heh
13:57:00 <Syzygy-> I wrote ANSI C anyway, and in the heavily preprocessed framework my workgroup had been developing for a while.
13:57:14 <cjeris> Heffalump: a few classes ago a student asked prof (Greg Morrisett) a question about optimizing for power consumption as opposed to space or speed -- which is a concept I hadn't thought of before.  do you do any of that?
13:57:25 <Syzygy-> Though, and this was fun, I discovered some very fundamental thought errors they had done when building it, and caused a complete revamp to be initated...
13:57:48 <Syzygy-> "Ooooops. Our entire concept won't work on position independent code. Dangit!"
13:58:05 <lispy> mauke: iirc, realloc is quasi-defined in C as well
13:58:33 <lispy> mauke: like, it should work, and probably will often, but if memory gets fragmented it could fail for no good reason
13:58:50 <mauke> lispy: at least it says "the original memory block isn't touched if realloc fails"
13:59:00 <pejo> Heffalump, I guess you're not allowed to tell too much about the internals of that compiler?
13:59:31 <Heffalump> cjeris: Not really. You'd need a good way of analysing the power usage of a compiled program first. In practice optimising for space (to save on Flash) or speed (to allow a lower clock speed) is probably a good proxy.
13:59:37 <Heffalump> pejo: not really
13:59:44 <Syzygy-> Heffalump: When will there be an efficient compiler for Haskell to ARM? ;)
13:59:59 <Heffalump> Syzygy-: ask Igloo ;-)
14:00:01 <Syzygy-> Heh
14:00:08 <Heffalump> (he was trying to get the GHC backend working a while ago)
14:00:12 <Syzygy-> Coooool.
14:00:14 * cjeris wants to see a big _|_ on the DS touch screen
14:00:15 <lispy> neat
14:00:19 <Syzygy-> Haha!
14:00:23 <lispy> i thought nhc or something was for small systems?
14:00:45 <SamB> it *was*
14:00:49 <Syzygy-> Is no more?
14:00:55 <Igloo> Heffalump, Syzygy-: It's done now
14:01:10 <SamB> well. nobody apparantly told the author yet.
14:01:17 * Syzygy- very much likes the change in thinking about programming that working with the cell phone industry has brought me....
14:01:52 <SamB> Syzygy-: you could look at Yhc...
14:01:54 <Syzygy-> It is quite something to sit down and think through how to do things when you measure the code size in bytes eaten, and tweak to shoehorn things in. Quite different mindset from mathematics programming...
14:02:00 <lispy> "nhc has been used for a number of embedded projects. I've seen it run on
14:02:01 <lispy> a credit-card sized ARM device. Tony Sloane and others at Macquarie are
14:02:03 <lispy> working on an embedded nhc project too."
14:02:09 <Syzygy-> SamB: I'm more asking out of curiosity than out of an actual wish to do anything with it.
14:02:21 <SamB> ah. well. I think Yhc is the best bet, anyway.
14:02:33 <ndm> lispy: Yhc generates smaller and faster bytecode
14:02:36 <SamB> they stole code from nhc
14:02:36 <lispy> http://www.haskell.org/pipermail/haskell-cafe/2005-January/008627.html
14:02:40 <lambdabot> Title: [Haskell-cafe] Hugs for Zaurus, http://tinyurl.com/yzc629
14:02:51 <ndm> lispy: and is more portable (we prefer the word forked than stole, but both are true)
14:03:20 <SamB> well, forked would imply continued development of nhc ;-)
14:03:23 <Heffalump> stole implies taking without consent, surely
14:03:32 <lispy> so neiher are true?
14:03:36 <lispy> or both are equally true?
14:03:37 <Heffalump> and the licence of nhc implies consent
14:03:41 <SamB> heh
14:03:43 <Heffalump> lispy: both ;-)
14:03:45 <ndm> there is minimal further nhc development
14:04:02 <SamB> see?
14:04:03 <ndm> we didn't tell anyone, but we see the nhc people at lunch every day and they don't seem overly upset
14:04:04 <Syzygy-> Hmmmm. I remember one of my Stockholm profs telling me about elliptic curve cryptography getting a high boost from the prevalent idea that RSA was too big to fit on a smart card.... I wonder whether there are any size benefits from going nhc/yhc/whatever instead of armcc or gcc or suchlike....
14:04:24 <lispy> ndm: uh oh....don't let them catch on :)
14:04:30 <SamB> ndm: I use the term loosely
14:04:35 <lispy> ndm: they might put something in your food when you're not looking :)
14:04:43 <Heffalump> Syzygy-: I find that highly unlikely
14:04:48 <Syzygy-> Right-o.
14:04:51 <SamB> lispy: you mean to the fact that nhc is dead, or to the fact that Yhc stole code ;-P?
14:05:07 <ndm> lispy: they are quite happy about it, although naming issues remain
14:05:11 <Syzygy-> So I'll still want to write prettyprinted assembler and then handtweak post-compilation for that kind of stuff...
14:05:12 <Heffalump> armcc starts from C code, which is naturally much "closer to the machine" than Haskell, and produces much better code than gcc.
14:05:18 <SamB> ndm: naming issues?
14:05:22 <Syzygy-> Heffalump: Yeah, I noticed that...
14:05:26 <lispy> ndm: i'm just teasing
14:05:35 <Heffalump> so I'd expect armcc to beat gcc which would beat any Haskell compiler
14:05:39 <ndm> SamB, Colin has talk of renaming it back to nhc
14:05:47 <Syzygy-> Had a few runs of "Let's start with gcc for prototyping, and then move to armcc because the hardware guys want it that way..."
14:05:48 <SamB> oh???
14:06:03 <ndm> SamB, i'd rate it as "unlikely" at best
14:06:09 <SamB> oh good.
14:06:28 <lispy> ndm: n = ? and Y = York?
14:06:36 <SamB> n = nearly
14:06:41 <SamB> and yes, Y = York
14:06:45 <lispy> nearly haskell compiler?
14:06:59 <SamB> Nearly a Haskell Compiler, I think
14:07:06 <lispy> it was not complete?
14:07:13 <SamB> not when named
14:07:19 <Syzygy-> How far behind gcc do the Haskell compilers end up? Could one justify using Haskell for for instance mobile phone deep libs at all?
14:07:27 <SamB> that is, the language it supported wasn't quite haskell...
14:07:28 <Heffalump> Syzygy-: seems highly unlikely
14:07:28 <Syzygy-> SamB: And where in the UK does Nearly lie?
14:07:33 <SamB> Syzygy-: hah
14:07:36 <ndm> lispy: Niklas, the original author
14:07:41 <lispy> Syzygy-: check the great pl shootout
14:07:44 <ndm> lispy: n =
14:07:47 <lispy> ?google great programming language shoot out
14:07:50 <lambdabot> http://shootout.alioth.debian.org/
14:07:56 <Syzygy-> I mean ... Glasgow, York, Nearly.... I'd guess on somewhere in Wales, but...
14:08:13 <SamB> Syzygy-: well, what do these deep libraries do?
14:08:32 <Syzygy-> The things I've been looking at do cryptography implementations....
14:08:40 <Syzygy-> Or ... I was looking at to be exact.
14:10:10 <lispy> Syzygy-: oh, another thing to consider is that ghc produces huge binaries, even after they are stripped
14:10:11 <SamB> well. you'll just have to take a look when ndm releases his optimizer ;-)
14:10:37 <Syzygy-> lispy: Ouch. Yeah, that pretty much kills it for that particular area.
14:10:55 <Igloo> Syzygy-: I think Nearly is just up the road from Glorious
14:10:58 <Syzygy-> Hmmmm. My few looks into the shootout has me thinking that anything loses against well-written c-code....
14:11:03 <Syzygy-> Igloo: Ah!
14:11:11 <SamB> Igloo: as in GGHC?
14:11:15 <Igloo> As in GHC
14:11:25 <SamB> GHC stands for Glasgow Haskell Compiler
14:14:20 <Axioplase> is there a function "is my list a sublist of another ?" ?
14:14:22 <dolio> You could use jhc. That's supposed to produce small binaries.
14:14:33 <dolio> If you have enough memory to compile your code, that is. :)
14:14:34 <Axioplase> (directly, not in a weaved way)
14:14:52 <SamB> what is ZMZN...
14:15:01 <SamB> where is z-coding documented?
14:15:43 <EvilRanter> Axioplase, Data.List.isInfixOf
14:16:00 <mauke> @pl \k g -> any (isPrefixOf k) (inits g)
14:16:00 <lambdabot> (. inits) . any . isPrefixOf
14:16:22 <Axioplase> thanks
14:17:06 <dolio> Don't you want (tails g) ?
14:17:07 <mathewm> erlangs list constructors just seem wrong to me :(
14:18:03 <dolio> > (\k g -> any (isPrefixOf k) (inits g)) "bcd" "abcde"
14:18:04 <lambdabot>  False
14:18:12 <dolio> > (\k g -> any (isPrefixOf k) (tails g)) "bcd" "abcde"
14:18:14 <lambdabot>  True
14:18:14 <mauke> hmm ,yes
14:18:46 <Axioplase> > List.isPrefixOf [1,1] [1..]
14:18:49 <lambdabot>  False
14:19:01 <Axioplase> why ?
14:19:15 <dolio> [1..] doesn't start with [1,1]
14:19:16 <mauke> because [1, 2 ..] doesn't start with [1, 1]
14:19:30 <Itkovian> seems obvious :-)
14:20:01 <Axioplase> hum.. though 11 is a prefix of 1111...
14:20:06 <Axioplase> not so obvious to me.
14:20:46 <SamB> > [1, 1..]
14:20:55 <mauke> > [1,1] `isPrefixOf` [1,1..]
14:21:09 <Axioplase> false
14:22:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:22:38 <lambdabot>  True
14:22:45 <mauke> hah
14:22:57 <dibblego> is there a type T that I can do put::T -> a -> T then contains::T -> a -> Bool with O(1)?
14:23:19 <mauke> what, forall a?
14:23:20 <EvilRanter> > repeat 1
14:23:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:23:29 <dibblego> yes forall a
14:23:38 <mauke> I don't think so
14:23:55 <mauke> what if a == (b -> b)?
14:24:08 <dibblego> what about it?
14:24:09 <dolio> Data.HashTable?
14:24:18 <mauke> dibblego: how do you compare functions for equality?
14:24:40 <dibblego> then Eq a =>
14:24:44 <Axioplase> mauke: at mine, it says no to what you asked lambdabot
14:25:02 <ndm> SamB, ZMZN == []
14:25:13 <mauke> Axioplase: whoa
14:25:21 <mauke> Axioplase: I'd like to see that
14:25:28 <dolio> The docs don't say what the complexities on hash table operations are, though.
14:25:37 <dibblego> I guess Hashtable.lookup can do it
14:25:48 <EvilRanter> Axioplase, try [1,1] `isPrefixOf` repeat 1
14:26:10 <EvilRanter> dolio, as it's a hashtable, they should be O(log n)
14:26:25 <dibblego> dolio, it says this much "The implementation will grow the hash table as necessary, trying to maintain a reasonable average load per bucket in the table."
14:26:28 <ndm> SamB, it is documented, see the paper on GHC Core (which is out of date in some respects, but gets the escaping right)
14:26:42 <dolio> Well, it depends on the hash table.
14:27:07 <SamB> ndm: I was hoping for a text file or wiki page :-(
14:28:31 <roconnor> Where do I send a patch for QuickCheck?
14:28:53 <SamB> what? there is no default destination in the repo?
14:28:58 <roconnor> oh
14:29:02 <roconnor> maybe there is a default
14:30:32 <Axioplase> mauke: see http://img102.imageshack.us/my.php?image=falsevz7.jpg
14:30:36 <lambdabot> Title: ImageShack - Hosting :: falsevz7.jpg, http://tinyurl.com/y7kyxj
14:30:57 <EvilRanter> Axioplase, make that [1,1..]
14:31:02 <EvilRanter> not [1..]
14:31:04 <dolio> > [1..]
14:31:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:31:05 <EvilRanter> > [1..]
14:31:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:31:09 <Botty> What's the best way to have a multi-file haskell lib?  most of the files are pretty modular, but they all rely on one module in the project
14:31:10 <EvilRanter> >[1,1..]
14:31:12 <EvilRanter> > [1,1..]
14:31:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:31:36 <Axioplase> EvilRanter: ok, right.
14:31:42 <EvilRanter> or just
14:31:44 <EvilRanter> > repeat 1
14:31:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:31:59 <Axioplase> My brain suddenly catch what you meant before by "obvious" :S
14:32:10 <Axioplase> caught
14:32:18 <norpan> or even simpler
14:32:21 <norpan> > fix (1:)
14:32:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:32:48 <EvilRanter> altho you shouldn't need the (. inits) . any . isPrefixOf mentioned earlier, as I think List.isInfixOf does the same thing
14:33:36 <Botty> I've tried compiling the uniformly used portion to a .o and .hi, but when i try to compile the others i think its looking in the wrong location.
14:33:48 <dolio> does isInfixOf exist?
14:33:50 <EvilRanter> norpan, repeat is a fn for the express purpose of creating infinite lists of identical elements. yours is a fn with a not-very-self-documenting name and a section. simpleR?
14:34:07 <dolio> Hmm, must be new in 6.6
14:34:10 <EvilRanter> > [3, 4, 5] `List.isInfixOf` [1..]
14:34:10 <lambdabot>  Not in scope: `List.isInfixOf'
14:34:15 <Botty> The modules are all Graphics.UI.GLFW.*
14:34:16 <EvilRanter> > [3, 4, 5] `Data.List.isInfixOf` [1..]
14:34:17 <lambdabot>  Not in scope: `Data.List.isInfixOf'
14:34:18 <EvilRanter> hm
14:34:21 <norpan> EvilRanter: obivously trying to be funny
14:34:25 <EvilRanter> it's on the site
14:34:29 <EvilRanter> norpan, obvious?
14:34:57 <EvilRanter> > let i = 1:i in i
14:34:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:35:09 * SamB thinks the library needs version numbers...
14:36:51 <desrt> haskell is funny :)
14:37:02 <norpan> indeed
14:37:19 <Axioplase> is their a "clear console" function ?
14:37:20 <desrt> > id
14:37:21 <lambdabot>  Add a type signature
14:37:28 <desrt> > id :: Int -> Int
14:37:29 <lambdabot>  <Int -> Int>
14:37:34 <desrt> gee.  thanks.
14:39:13 <Cale> > id id id id id 5
14:39:14 <lambdabot>  5
14:39:39 <desrt> > let y f = f (y f) in (y id) 5
14:39:40 <lambdabot>  Add a type signature
14:39:43 <Cale> > id (id . id) id . id . id $ 5
14:39:44 <lambdabot>  5
14:39:48 <roconnor> SamB, how do I find the default address for sending patches?
14:39:58 <desrt> > let y f = f (y f) in (y (id::Int->Int)) 5
14:39:59 <lambdabot>    The function `(y (id :: Int -> Int))' is applied to one arguments,
14:39:59 <lambdabot>   b...
14:40:08 <EvilRanter> >unfoldr (curry Just 1) ()
14:40:11 <EvilRanter> > unfoldr (curry Just 1) ()
14:40:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:40:31 <Cale> > filterM (const [True, False]) [1,2,3]
14:40:32 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
14:40:33 <desrt> now that's a good one
14:40:35 <SamB> roconnor: it isn't working?
14:40:39 <EvilRanter> I have too much time on my hands for thinking up odd ways of doing this
14:40:46 <roconnor> well I don't have sendmail on my laptop
14:40:50 <SamB> oh
14:40:53 <roconnor> so I don't want to do darcs --send
14:40:57 <roconnor> or whatever
14:41:05 <SamB> darcs send
14:41:05 <desrt> haskell is so funny!
14:41:18 <SamB> anyway, you'll need to do darcs send one way or another
14:41:19 <roconnor> anyhow, I doubt darcs send will work
14:41:28 <SamB> probably with -o ;-)
14:41:35 <roconnor> yes I've done that
14:41:41 <roconnor> but I should mail it to someone :)
14:41:42 <SamB> well.
14:41:46 <SamB> yeah ;-)
14:41:58 <roconnor> you want it ;)
14:42:18 <desrt> > [False..]
14:42:18 <lambdabot>  Parse error
14:42:30 <desrt> > [(False)..]
14:42:31 <lambdabot>  [False,True]
14:42:34 <SamB> darcs send --dry-run
14:42:34 <mauke> > [False ..]
14:42:36 <lambdabot>  [False,True]
14:42:42 <desrt> ah
14:42:48 <SamB> and then just say "yes" to everything...
14:43:02 <roconnor> Patch bundle would be sent to: libraries@haskell.org
14:43:08 <desrt> > filterM (flip take [False ..]) [1,2,3]
14:43:09 <lambdabot>  [[],[3],[2],[2,3]]
14:43:12 <desrt> :)
14:43:24 * EvilRanter tries to think of other ways of geting [1,1..]
14:43:37 <roconnor> ugh
14:43:43 <roconnor> does this mean I need to make a trac?
14:43:43 <EvilRanter> I do like "unfoldr (curry Just 1) ()", tho
14:44:01 <desrt> i can't even begin to think why that might work :)
14:44:04 <Cale> desrt: btw, have you ever heard of Wayne Krantz?
14:44:05 <mauke> > map (join div) [1 ..]
14:44:07 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:44:10 <desrt> Cale; i have not
14:44:27 <desrt> mauke; that's so cheating
14:44:28 <Cale> desrt: He's probably the best guitarist I've ever heard :)
14:44:54 <Cale> It's difficult to conceive of even aspiring to be that good :)
14:44:57 <Maddas> > take 10 $ repeat 1
14:44:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
14:45:06 <desrt> Maddas; yawn.
14:45:10 <Maddas> (:
14:45:13 <mauke> > return 1 `liftM` repeat repeat
14:45:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:46:03 <EvilRanter> > cycle $ (:[]) 1
14:46:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:46:13 <EvilRanter> mauke, whoa...
14:46:18 <EvilRanter> I am outdone!
14:46:59 <mauke> EvilRanter: it's just map (const 1) (repeat whatever)
14:47:19 <EvilRanter> the execution is fantastically esoteric, tho
14:47:29 <EvilRanter> i'm getting hints of monad
14:47:31 <Pseudonym> >> fix (1:)
14:47:35 <Pseudonym> > fix (1:)
14:47:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:47:37 <EvilRanter> we alreay had that
14:47:40 <Pseudonym> Ah.
14:48:07 <Cale> > iterate id 1
14:48:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:48:30 <cpriester> hi! is it possible to use RTS command line options in the source code?
14:49:04 <desrt> why the hell isn't 'y' part of the prelude?
14:49:06 <desrt> seriously...
14:49:16 <desrt> it's one of the biggest sore spots
14:49:20 <EvilRanter> y?
14:49:27 <Cale> Yeah, fix should be in there :)
14:49:36 <Cale> It is in Control.Monad.Fix
14:50:19 <SamB> @hoogle fix
14:50:20 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
14:50:20 <lambdabot> Control.Monad.Fix :: module
14:50:20 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
14:50:54 <EvilRanter> how the heck does fix (1:) work? IDGI
14:50:56 <desrt> hoogle.  ha ha ha
14:51:15 <desrt> (1:) = (\f -> 1:f)
14:51:21 <EvilRanter> I know
14:51:26 <desrt> the y combinator effective passes the function to itself as its first argument
14:51:27 <Cale> EvilRanter: fix f = f (fix f)
14:51:35 <mauke> fix f = let x = f x in x
14:51:43 <desrt> or rather, an infinite application of the function
14:51:49 <Cale> > let fix f = f (fix f) in fix (1:)
14:51:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:51:51 <desrt> so you get f( f( f( f( f( f( ...
14:51:53 <ThreeQ> fix (1:) = 1 : fix (1:) = 1 : 1 : fix (1:) = 1 : 1 : 1 : fix (1:) = ...
14:51:57 <EvilRanter> ahh
14:52:00 <desrt> each of those f's adds a 1
14:52:30 <EvilRanter> the docs ("fix f is the least fixed point of the function f, i.e. the least defined x such that f x = x.") completely fail to make that clear
14:52:31 <desrt> and never a close paren :)
14:53:07 <desrt> well... what is a fixed point?
14:53:15 <roconnor> Subject: darcs patch: Adding Arbitrary instance for Either
14:53:24 <EvilRanter> desrt, "the least defined x such that f x = x."
14:53:27 <roconnor> You are not allowed to post to this mailing list, and your message has
14:53:27 <roconnor> been automatically rejected.
14:53:28 <EvilRanter> as it says
14:53:34 <roconnor> well isn't that dandy
14:53:38 <ThreeQ> desrt: it's a value that, when you pass it into a function, you get the same value back
14:53:38 <desrt> right.  seems pretty obious from that :)
14:53:43 <desrt> ThreeQ; right.
14:53:48 <desrt> in this case, that value is a function
14:54:11 <EvilRanter> i dunno... as I see it, it doesn't make it clear that it passes the fn to itself forevarr
14:54:15 <desrt> and f() is one more application of the "original" function (ie: (1:))
14:54:32 <EvilRanter> it makes it sound like it did some dweomer to get an actual value
14:54:40 <desrt> the least function that stays exactly the same when you add another 1: to the front of its result is the function that returns an infinite list of 1s
14:54:50 <roconnor> SamB, libraries@haskell.org isn't a very friendly address. :(
14:54:53 <ThreeQ> desrt: the fixed point here is a list, not a function
14:55:01 <ThreeQ> ?type fix
14:55:02 <lambdabot> forall a. (a -> a) -> a
14:55:03 <ThreeQ> ?type (1:)
14:55:04 <desrt> ThreeQ; the function is the list
14:55:05 <lambdabot> forall a. (Num a) => [a] -> [a]
14:55:12 <ThreeQ> ?type fix (1:)
14:55:14 <lambdabot> forall a. (Num a) => [a]
14:55:14 <desrt> ThreeQ; in general, though, when using 'y', the function won't be a list
14:55:30 <mauke> EvilRanter: it does :-)
14:55:44 <desrt> take the factorial example
14:55:49 <EvilRanter> it's gotta be complicated to be dweomer
14:55:57 <mauke> > let fix f = let x = f x in x in fix (1 :)
14:55:58 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:55:58 <desrt> ?type fix (\f.\n.if (n==0) then 1 else n*f(n-1))
14:56:00 <lambdabot> parse error on input `.\'
14:56:06 <desrt> ?type fix (\f->\n->if (n==0) then 1 else n*f(n-1))
14:56:07 <lambdabot> parse error on input `->\'
14:56:09 <desrt> !!
14:56:14 <desrt> ?type fix (\f->(\n->if (n==0) then 1 else n*f(n-1)))
14:56:15 <lambdabot> forall a. (Num a) => a -> a
14:56:25 <desrt> this fix point is (a -> a)
14:56:28 <ThreeQ> right, in that case the fixed point is a function
14:56:33 <EvilRanter> ?type fix (\f n->if (n==0) then 1 else n*f(n-1))
14:56:34 <ThreeQ> but it doesn't have to be
14:56:35 <lambdabot> forall a. (Num a) => a -> a
14:56:37 <desrt> yes.  it does.
14:56:42 <EvilRanter> is how you do multiple args
14:56:44 <desrt> the fix point is _always_ a function
14:57:06 <mauke> > let fix f = let x = f x in x in fix (const "o rly")
14:57:07 <lambdabot>  "o rly"
14:57:10 <roconnor> > fix (1:)
14:57:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:57:19 <mauke> how is "o rly" a function?
14:57:50 <desrt> it's a function that takes no arguments and returns "o rly"
14:58:00 <roconnor> :)
14:58:04 <desrt> seriously
14:58:09 <EvilRanter> # so you'll be an austrian nobleman / commissioning a symphony in C / which defies all earthly descriptions / you'll be commissioning a symphony in C ...
14:58:13 <mauke> a function without arguments isn't a function
14:58:17 <roconnor> functions aren't only first class, they are the only class.
14:58:18 <desrt> it most certainly is
14:58:24 <SamB> roconnor: what were those missing rules?
14:58:38 <desrt> f x = x + 1
14:58:39 <desrt> f = 3
14:58:50 <desrt> i see no difference here other than one of them takes 1 argument and the other takes 0
14:58:53 <ThreeQ> desrt: then everything is a function
14:58:56 <roconnor> SamB, missing rules?
14:58:57 <desrt> ThreeQ; yup.
14:58:58 <EvilRanter> yes!
14:59:02 <ThreeQ> so trivially fix must return a function
14:59:08 <desrt> ThreeQ; yup.
14:59:14 <EvilRanter> that's cheating
14:59:22 <desrt> ThreeQ; when talking about fix i used "function" as a word for "thing"
14:59:23 <SamB> I guess it was the shift rules?
14:59:32 <desrt> but you get the idea
14:59:39 <roconnor> SamB, I'm fixing up Either
14:59:50 <roconnor> There is no instance for Arbitrary
15:00:01 <desrt> ThreeQ; in general practise, however, you will usually see fix used with a function that does take an argument
15:00:05 <SamB> roconnor: In GHC's optimizer?
15:00:14 <ThreeQ> is _|_ a function? :)
15:00:20 <SamB> yes!
15:00:24 <roconnor> in Test.QuickCheck?
15:00:26 <SamB> it always returns _|_ though
15:00:28 <desrt> _|_ is whatever you want it to be :)
15:00:29 <SamB> roconnor: no!
15:00:29 <EvilRanter> btm = btm
15:00:39 <sjanssen> ThreeQ: yes _|_ inhabits the type "a -> b"
15:00:41 <ndm> SamB, the paper is more like a tutorial, rather than anything academic
15:00:46 <roconnor> _|_ is a function that take no argument and doesn't return
15:00:53 <SamB> ndm: still, it is probably in postscript/PDF
15:00:58 <SamB> which is a bit clunky
15:01:01 <desrt> roconnor; it takes as many arguments as you like, actually
15:01:14 <ThreeQ> > undefined 1 2 3 4 5
15:01:15 <lambdabot>  Add a type signature
15:01:20 <ndm> SamB, i know - hence why the entire Yhc manual and everything is in one single wiki
15:01:21 <EvilRanter> so ::a->b->c->d->...
15:01:23 <desrt> > (undefined :: Int -> Int) 3
15:01:24 <sjanssen> calling _|_ a function isn't quite right, it can be a function, but it can also be a non-type
15:01:25 <lambdabot>  Undefined
15:01:27 <desrt> for example :)
15:01:36 <sjanssen> erm, non-function type
15:01:37 <SamB> ndm: I'm just saying I think they ought to put that stuff on the Trac wiki ;-)
15:01:45 <desrt> sjanssen; all types are functions
15:01:55 <ndm> SamB, entirely agreed - their user manual too - but no one else believes me
15:02:07 <sjanssen> desrt: "x :: Int", is x a function?
15:02:12 <desrt> sigh.  yes!
15:02:18 <sjanssen> I disagree
15:02:21 <SamB> actually, I think it is
15:02:25 <desrt> it definitely is
15:02:25 <roconnor> SamB: what are we talking about?
15:02:26 <SamB> no wait
15:02:29 <EvilRanter> these're all functions, because of lazy evaluation
15:02:31 <SamB> that is just a link :-(
15:02:31 <ThreeQ> what's a function?
15:02:31 <desrt> if functions can take 1, 2, 3... args, why not 0?
15:02:33 <ndm> SamB, although documentation implies a failure in user interface, i.e. Yhc uses Prelude.[] - instead of ZMZN
15:02:36 <roconnor> oh
15:02:40 <SamB> roconnor: you said something about missing intrinsic rules
15:02:43 <mauke> desrt: because all functions take exactly 1 argument
15:02:49 <EvilRanter> if they were eager evaluated, then no execution'd take place when you used them
15:02:50 <desrt> heh
15:03:00 <desrt> mauke; that's a definition i'm willing to buy
15:03:00 <EvilRanter> but as they aren't, there is, so they must be fns
15:03:14 <SamB> ndm: well, Core is more of a hacker interface at this time...
15:03:15 <sjanssen> desrt: only things that have (->) as the top level tycon are functions
15:03:17 <EvilRanter> thunks.
15:03:34 <desrt> interesting alternate definition :)
15:03:37 <ndm> SamB, hackers care about hacker interfaces! (i do at least)
15:03:39 <ThreeQ> a function is something that maps values of some type to values of some type
15:03:51 <SamB> ndm: and z-coding is for (a) linker compatability and (b) parseability...
15:04:04 <sjanssen> EvilRanter: thunks are just an implementation detail.  I don't think they have anything to do with whether a thing is a function
15:04:12 <SamB> and notice that dumps tend not to use it
15:04:18 <ndm> SamB, machine parseability - not reader parseablility
15:04:19 <SamB> mostly just external core and symbol names
15:04:27 <SamB> ndm: true
15:04:28 <roconnor> SamB, I'm not sure what you mean.  Meacham suggested a rule like : forall x y# . shift x y# = inline shift x y#
15:04:29 <SamB> but.
15:04:37 <SamB> roconnor: o
15:04:39 <SamB> er.
15:04:39 <EvilRanter> sjanssen, I meant, what'd be "values" in other languages're effectively thunks in Haskell, 'cos of lazy-eval
15:04:40 <SamB> oh.
15:04:52 <roconnor> SamB is that what you are thinking of?
15:05:10 <roconnor> I meantioned that to you before
15:05:13 <ThreeQ> also, you could say 1 is a function that takes no arguments and returns a function that takes no arguments and returns a function that takes no arguments that returns a function that takes no arguments ...
15:05:17 <ndm> yuk, more complex rules...
15:05:42 <ThreeQ> where do you get to the value 1?
15:05:56 <desrt> ThreeQ; think of lambda calc
15:06:07 <desrt> "values" don't exist, per se
15:06:10 <desrt> only normal forms
15:06:23 <EvilRanter> ThreeQ, http://en.wikipedia.org/wiki/Church_numbers :P
15:06:26 <sjanssen> Haskell isn't lambda calculus
15:06:29 <weitzman> The lambda calculus isn't the basis for the definition of the word "function"
15:06:30 <roconnor> ThreeQ: fortuanly the number of reduction steps for a function of 0 arguments is 0.
15:07:17 * desrt loves how you can inject a random reason for how "function" might be defined into this channel and get 4 replies from the entire range of "you're wrong!" to "of course!"
15:07:28 <SamB> roconnor: I meant a constant-folding rule
15:07:42 <SamB> I'm not sure if you told me about any missing constant-folding rules...
15:07:49 <roconnor> oh
15:08:06 <roconnor> you mean like 2^16?
15:08:17 <roconnor> oh wait
15:08:20 <roconnor> I remember now
15:08:40 <roconnor> there are not rules for shifting
15:08:49 <SamB> thats what I thought
15:08:55 <roconnor> let me find it again
15:09:04 <ndm> how do you guarantee termination of constant folding?
15:09:16 <mathewm> ?djinn f ? (a,b) -> [a]
15:09:17 <lambdabot> Cannot parse command
15:09:18 <ndm> i.e. imagine 3 ^ 8 defined in terms of +1 's
15:09:27 <ndm> evaluating that at compile time is too expensive
15:09:30 <ndm> the inliner won't
15:09:34 <SamB> I don't think that is handled by constant folding anyway ;-)
15:09:38 <ndm> but if you add specialisation stuff on it that might
15:09:45 <ndm> hence breaking the compiler
15:09:57 <SamB> there are some special "RULES" that deal with primitives applied to known values and similar things
15:12:30 <roconnor> SamB prelude/PrelRules.lhs
15:12:43 <roconnor>     -- ToDo:    something for integer-shift ops?
15:14:26 <roconnor> ndm: thanks to laziness and CSE 2^16 is only evaluated once
15:14:32 <roconnor> so maybe that is good enough
15:15:05 <ndm> roconnor: imagine 2^16 defined using the rule n ^ m = n * (n ^ (m - 1))
15:15:32 <ndm> roconnor: and then * defined in terms of +
15:16:13 <EvilRanter> fortunately, for Ints at least, (*) is defined in terms of machine code instructions
15:16:37 <ndm> EvilRanter: imagine $* being defined, which is * using +
15:17:38 <desrt> lambda calculus + oracle = nice
15:18:26 <EvilRanter> ndm, what're you getting at, anyway?
15:18:53 <ndm> EvilRanter: once you start specialising primitives, you have to worry about doing an unbounded amount of work at compile time
15:22:14 <EvilRanter> > let ($+) = foldr (+) 0 . replicate in 6 $* 9
15:22:15 <lambdabot>  Not in scope: `$*'
15:22:20 <EvilRanter> > let ($*) = foldr (+) 0 . replicate in 6 $* 9
15:22:20 <lambdabot>    Expecting a function type, but found `b'
15:22:21 <lambdabot>    Expected type: Int -> [b]...
15:22:22 <EvilRanter> hm
15:22:37 <EvilRanter> strange, it works in mine
15:23:25 <Cale> really?
15:23:28 <weitzman> > let ($*) = foldr (+) 0 $ replicate in 6 $* 9
15:23:28 <lambdabot>    Expecting a function type, but found `a'
15:23:29 <lambdabot>    Expected type: [b]
15:23:29 <lambdabot>    ...
15:24:01 <Cale> > let ($*) = (sum .) . replicate in 6 $* 9
15:24:03 <lambdabot>  54
15:24:11 <EvilRanter> ah, that's what i did
15:24:15 <EvilRanter> missed the extra .
15:24:32 * EvilRanter should copy/paste in future
15:26:48 <Cale> > ((!!) . flip iterate 0 . (+)) 6 9
15:26:49 <lambdabot>  54
15:27:05 <EvilRanter> o god, not this again
15:27:41 <Botty> ghc -c -ffi -v -i"~/Desktop/HOpenGL-1.05/GLFW" Initialization.hs
15:28:09 <Botty> says it can't find "~/Desktop/HOpenGL-1.05/GLFW/Graphics/UI/GLFW/Marshalling.hi" even though i know it exists
15:28:10 <jgrimes> how can I get my personal lambdabot to register with nickserv?
15:28:28 <fons> > :t (sum .) . replicate
15:28:29 <lambdabot>  Parse error
15:28:48 <weitzman> @type (sum .) . replicate
15:28:50 <lambdabot> forall a. (Num a) => Int -> a -> a
15:29:06 <fons> thanks weitzman, I'm a newbie :)
15:29:23 <weitzman> Me too, more or less
15:29:33 <Cale> > (\x y -> length (replicate x 1 >> replicate y 1)) 6 9
15:29:35 <lambdabot>  54
15:29:41 <weitzman> But one year from today
15:29:42 <fons> I don't really understand the dot there
15:29:58 <weitzman> But George, I'm going to be a Haskell expert
15:30:01 <weitzman> One year from today
15:30:03 <weitzman> Mark your calendars
15:30:08 <Cale> @type (sum .)
15:30:09 <lambdabot> forall a a1. (Num a) => (a1 -> [a]) -> a1 -> a
15:30:19 <weitzman> s/But/By/
15:31:01 <fons> of course, I never used the composition operator like that
15:31:06 <EvilRanter> is there an un-@pl?
15:31:39 <fons> Cale, BTW, thanks for your help yesterday, I had to change everything but ... now I almost have it
15:32:12 <EvilRanter> @pf \a b c d -> a b (c d)
15:32:13 <lambdabot> Maybe you meant: bf pl
15:32:14 <ThreeQ> > flip iterate 0
15:32:15 <lambdabot>  Add a type signature
15:32:15 <pejo> Boggle. How common is it that darcs stops building between ghc releases?
15:32:18 <EvilRanter> @pl \a b c d -> a b (c d)
15:32:18 <lambdabot> ((.) .)
15:32:23 <ThreeQ> ?type flip iterate 0
15:32:25 <EvilRanter> er
15:32:25 <lambdabot> forall b. (Num b) => (b -> b) -> [b]
15:32:51 <EvilRanter> @pl \a c -> (a.).c
15:32:51 <lambdabot> (.) . (.)
15:32:54 <sjanssen> pejo: trying to  build darcs with GHC 6.6?
15:32:56 <weitzman> Why does iterate take the function first anyway?
15:32:58 <weitzman> @type iterate
15:33:00 <lambdabot> forall a. (a -> a) -> a -> [a]
15:33:04 <EvilRanter> er. please ignore the man behind the curtain
15:33:09 <pejo> sjanssen, just did. Horrible experience. On MacOS X/Intel too.
15:33:12 <weitzman> I guess it's not that unreasonable
15:33:38 <lisppaste2> fons annotated #28900 with "Functions miss the first argument" at http://paste.lisp.org/display/28900#1
15:33:42 <sjanssen> pejo: yeah, there were a couple of library changes.  The getBounds stuff, mtl isn't packaged with GHC anymore, etc.
15:34:14 <Botty> can someone take a look at this collection of haskell files i've created, and tell me what I need to do to get it to compile - http://botbuilder.googlepages.com/GLFW.zip
15:34:21 <sjanssen> pejo: I seem to remember a darcs repo with these changes already made
15:34:24 <fons> Cale, thats an annotation for the code you typed yesterday
15:34:35 <Botty> Its an interface to the glfw lib...
15:34:36 <ndm> Botty: ghc --make Main.hs doesn't work?
15:34:46 <Botty> I don't have a main, its a lib
15:34:47 <pejo> sjanssen, yeah, the getBounds changes required several changes, and regex-compat needed, and html, and mtl, as you stated.
15:35:14 <pejo> sjanssen, would have been handy to have such a repository, but rather useless without darcs. :-)
15:35:30 <sjanssen> pejo: ha!  touche
15:36:21 <pejo> sjanssen, any idea how I got my mtl-package, if it's not standard?
15:36:57 <Botty> I suppose I could combine it all into one big module
15:37:09 <sjanssen> pejo: oh, you probably installed extralibs.  mtl and a handful of other packages are in a semi-included state
15:37:38 <pejo> sjanssen, ah, you're right of course!
15:39:39 <araujo> If i have a data type of the form: 'data Type a b = .... ' , is this right for instance declarations: 'instance Class (Type a b) where ..' ?
15:41:10 <sjanssen> araujo: that is potentially correct, depending on the defn. of Class
15:42:56 <araujo> http://rafb.net/paste/results/HNbA0923.html
15:43:07 <araujo> sjanssen, could you please take a look?
15:43:37 <sjanssen> araujo: you want "instance Functor (BTree a) ..."
15:43:44 <desrt> hahahahah
15:43:45 <desrt> oh man
15:43:58 <desrt> the dot graph of my lambda terms is even less useful than i guessed it would be
15:44:40 <sjanssen> araujo: the Functor class is a "constructor class", so called because it expects a partially constructed type
15:45:47 <sjanssen> araujo: even after that change your code won't type check
15:46:22 <araujo> sjanssen, that's what i notice :-P
15:46:41 <sjanssen> Functor is somewhat restrictive
15:46:42 <sjanssen> @type fmap
15:46:43 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
15:47:12 <araujo> sjanssen, mm .. so you are saying i can't get it working with (Type a b) ?
15:48:32 <sjanssen> araujo: there isn't any problem with making Functor work for something like (Type a b) . . . it's just can't do what you want in this example
15:49:17 <araujo> sjanssen, ok, i just changed the data type for 'Type a' ... it seems to work now
15:51:40 <araujo> sjanssen, can you give me an example when it'll work?
15:52:48 <monochrom> love haskell
15:53:17 <sjanssen> @where paste
15:53:18 <lambdabot> http://paste.lisp.org/new/haskell
15:53:39 <desrt> is there a good hashing function in haskell that'll turn huge strings into small ones with implausible chance of colission without implementing something like sha?
15:53:51 <EvilRanter> ...
15:53:59 <lisppaste2> sjanssen pasted "proper functor instance" at http://paste.lisp.org/display/28956
15:54:05 <EvilRanter> do you mean without _you_ implementing sha?
15:54:06 <desrt> i don't need cryptographic strenght....
15:54:09 <sjanssen> araujo: there you go
15:54:12 <desrt> well... sort of
15:54:19 <desrt> i'd rather not have sha1 as part of my program :)
15:54:29 * desrt already has sha1.hs around somewhere
15:54:58 <anotherdaniel> Hi, folks.  What types can DrIFT derive class instances for?  I can derive Haskell2Xml for eg Maybe but not  eg CalendarTime.
15:55:09 <monochrom> I heard of taking chucks of N bits and xor.
15:55:22 <desrt> monochrom; an interesting idea
15:55:31 <EvilRanter> > Data.HashTable.hashString "Hello, world!"
15:55:32 <lambdabot>  Not in scope: `Data.HashTable.hashString'
15:55:34 <EvilRanter> meh
15:55:42 <EvilRanter> > HashTable.hashString "Hello, world!"
15:55:43 <lambdabot>  Not in scope: `HashTable.hashString'
15:55:57 <monochrom> perhaps Hashtable?
15:56:12 <EvilRanter> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html#v:hashString
15:56:15 <lambdabot> http://tinyurl.com/t6sxh
15:56:17 <EvilRanter> HashTable
15:56:38 <sjanssen> EvilRanter: lambdabot doesn't import Data.HashTable
15:56:44 <EvilRanter> righto
15:56:47 <desrt> hash function from a hash table is likely to collide
15:56:51 <desrt> i think i'll just use sha1 :p
15:56:51 <araujo> thanks sjanssen
15:57:11 <EvilRanter> desrt, md5 (for example) may be easier
15:57:17 <desrt> i already have sha1.hs
15:57:23 <EvilRanter> ok, or not
15:57:28 <desrt> :)
16:04:13 <dibblego> where was that minimal project that used cabal?
16:04:31 <ndm> @where hnop
16:04:31 <lambdabot> http://semantic.org/hnop/
16:05:07 <dibblego> that's it, thanks
16:05:33 <emk> I'm having problems with Parsec's buildExpressionParser...
16:06:37 <emk> It wants my AST constructor functions to be of type "a -> a -> a", but they all have type "a -> a -> m a", because they need to allocate unique identifiers in each AST node...
16:07:46 <ndm> m a -> m a -> m a ?
16:07:59 <ndm> then a few binds here and there might do it
16:08:13 <dons> moin!
16:08:13 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:08:19 <dons> ?users
16:08:19 <lambdabot> Maximum users seen in #haskell: 256, currently: 237 (92.6%), active: 45 (19.0%)
16:09:01 <emk> ndm: Hmm. I'd need to do something really nasty to make that work--something like "Parser (Parser Expression)". I wonder if that works?
16:09:35 <dons> oh, my other lambdabot got diconnected, last night, after longest uptime: 1month 1d 1h 38m 50s
16:10:06 <dons> hey glguy
16:10:12 <glguy> Good morning
16:10:16 <desrt> http://desrt.mcmaster.ca/random/lambda.png
16:10:19 <desrt> y'all need to fear that
16:10:27 <desrt> i love dot :)
16:10:48 <dons> dibblego: also http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
16:10:52 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
16:10:57 <dibblego> dons, thanks
16:11:08 <anotherdaniel> Is DrIFT restricted to deriving instances only for types in the current file or the Prelude?
16:11:18 <mauke> desrt: what are those "let"s doing in there?
16:11:35 <desrt> mauke; my lambda expression language has "let x = y in z" clauses
16:11:37 <dons> bad desrt
16:11:38 <dibblego> Common Architecture for Building Applications and Libraries User's Guide seems pretty good, but I'm a stuck atm
16:11:45 <desrt> dons; !?
16:11:59 <dons> my firefox went kind of crazy on that page, I think?
16:12:04 <desrt> heh
16:12:12 <desrt> it's a 6276x3807 image
16:12:13 <mauke> desrt: why?
16:12:20 <desrt> mauke; because my professor said that it has to
16:12:28 <mauke> let is just syntactic sugar for lambda
16:12:39 * emk digs through Parsec, hoping to find a way to make it do the right thing...
16:12:41 <glguy> My IE7 didn't seem to have any trouble q-;
16:12:45 <desrt> well, i know that :p
16:12:57 <desrt> i treat let a bit differently, though
16:13:03 <desrt> for example, i refuse to apply rules inside of it
16:13:31 <desrt> now what would be insanely cool is if i had a screen large enough to fit this graph on
16:13:36 <emk> Is there a URL for browsing the source to the Haskell hierarchical libraries?
16:13:42 <desrt> then i could write some code to show the graph as the term is evaluated
16:13:49 <SamB> @fptools
16:13:50 <lambdabot>  not available
16:13:54 <SamB> @fptools Prelude
16:13:54 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
16:14:01 <SamB> @fptools QuickCheck
16:14:01 <lambdabot> QuickCheck not available
16:14:06 <SamB> @fptools Test.QuickCheck
16:14:07 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Test/QuickCheck.hs
16:14:31 <emk> @fptools Text.ParserCombinators.Parsec.Expr
16:14:31 <lambdabot> http://darcs.haskell.org/packages/parsec/Text/ParserCombinators/Parsec/Expr.hs
16:14:40 <emk> SamB: Ah, thanks!
16:14:46 <glguy> I love how fast Windows XP boots after a fresh install
16:15:22 <Botty> glguy - then you get to watch as it slowly gets slower and slower
16:15:22 <glguy> I managed to mangle my NTFS partition somehow and had to blow it away
16:17:33 <Botty> though I must say its pretty sad how XP beats ubuntu in startup speed
16:17:50 <dibblego> with cabal, I have a Exposed-Modules: A.B, so I assume it looks for A/B.hs relative to ".", but I want it to look relative to "./src" -- how do I specify this?
16:17:51 <glguy> I've installed Ubuntu on this machine, I was disappointed
16:17:52 <wolverian> ubuntu is getting a lot faster now that upstart is in.
16:18:11 <wolverian> er, to boot, that is.
16:18:20 <Botty> my only disappointment is that i've not got gl working
16:18:23 <Cale> I wish it would tell me what it's doing while booting
16:18:36 <wolverian> Cale, why? windows doesn't :)
16:18:41 <Botty> and spent probably 10 hours cumalitively trying to get it to work...
16:18:42 <desrt> Cale; check out my tree? :D
16:18:48 <Cale> Yeah, that's one of the things I hate about windows.
16:18:54 <Botty> Cale - you can enable that
16:18:55 <Cale> desrt: which tree?
16:19:02 <desrt> Cale; http://desrt.mcmaster.ca/random/lambda.png
16:19:04 <wolverian> Cale, there's a setting for that. I forget what it is. check the wiki, I suppose.
16:19:17 <Cale> ahahaha
16:19:19 <Cale> awesome
16:19:31 <desrt> thx :D
16:19:31 <wolverian> Botty, yeah. I think I'm actually lucky, having an intel gfx chip...
16:19:42 <dibblego> hs-source-dirs
16:20:10 <glguy> There's something about Ubuntu's default cursor that gives me a sour reaction to the whole experience, the rounded cursor just make everything feel less precise (yeah, I know how to change it)
16:24:10 <monochrom> Why are people so picky? :)
16:25:05 <mauke> @type handle
16:25:07 <lambdabot> Not in scope: `handle'
16:25:50 <ndm> @kind Handle
16:25:51 <lambdabot> Not in scope: type constructor or class `Handle'
16:25:54 <ndm> @hoogle Handle
16:25:55 <lambdabot> System.IO.Handle :: data Handle
16:25:55 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
16:25:55 <lambdabot> System.Win32.Types.HANDLE :: type HANDLE
16:30:12 <Bobstopper> What's the recommended way to catch parse failures with read?
16:30:24 <mauke> step 1: don't use read
16:30:33 <mauke> @type reads
16:30:34 <lambdabot> forall a. (Read a) => ReadS a
16:31:11 * SamB thinks GHC needs a better idea of interesting continuations
16:31:20 <SamB> at unlifted types
16:31:45 <ndm> SamB, unlifted types?
16:31:54 <SamB> like Int#
16:31:56 <Bobstopper> Ok, so if I'm using a library which uses read and not reads and I want to catch parse errors outside of that library, I can't do it?
16:31:58 <SamB> or Word#
16:32:30 <ndm> SamB, unboxed you mean?
16:32:45 <SamB> essentially, yes ;-)
16:32:47 <ndm> Bobstopper: fix the library
16:32:56 <mauke> Bobstopper: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#7
16:32:57 <sjanssen> Bobstopper: you can catch it inside the IO monad
16:32:59 <lambdabot> http://tinyurl.com/srhqe
16:33:21 <ndm> I have a strategy for avoiding explicit unboxing in Yhc, which will hoepfully make the world a less kind'ed plaec
16:33:37 <xerox-> go extensible kinds!
16:34:09 <Bobstopper> Does read have it's own parse exception? I couldn't find it in Control.Exception...
16:34:28 <dcoutts> Bobstopper, no need, just use reads
16:34:33 <SamB> well, actually, I guess I just mean that it ought to be more interested in inlining arguments to functions...
16:34:33 <dcoutts> @type reads
16:34:35 <lambdabot> forall a. (Read a) => ReadS a
16:34:36 <ndm> Bobstopper: its just a pattern match error - you're much better off fixing the library - which one is it that is broken like this?
16:34:39 <dibblego> will cabal generate my haddock output?
16:34:42 <SamB> or something like that...
16:34:48 <emk> Grrr, I'm going to have to rewrite half of Text.ParserCombinators.Parsec.Expr.
16:34:54 <ndm> dibblego: runhaskell Setup haddock
16:35:12 <dibblego> ndm, thanks, my guess was right, but mispelled :)
16:35:33 <ski> unboxed 'Either' continuations would be cool
16:35:39 <dcoutts> dibblego, you can use runhaskell Setup --help to tell you what's available
16:35:48 <dibblego> dcoutts, ta
16:36:03 <Bobstopper> ndm: none that I know of. I'm writing a program which uses read and I was just trying to get an understanding of how errors work. So I suppose reads should almost always be preferred over read...
16:36:48 <ndm> Bobstopper: yes, if you try catching a pattern matching exception, you're pretty much throwing away referential transparency and thats not good
16:37:17 <Bobstopper> *nods* ok, thanks.
16:38:26 <ski> SamB : what kind of continuations did you have in mind ?
16:40:06 <mbishop> Hmm, why won't a file with just do and putStrLn work? tells me "parse error"
16:40:19 <dibblego> how do you back out of a Setup.hs install? there is no Setup.hs remove?
16:40:33 <Cale> mbishop: main = do ... ?
16:40:41 <xerox-> mbishop: main = putStrLn "..." is probably what you want
16:41:41 <xerox-> |do expression| is the same as |expression|
16:41:49 <dons> main = do putStrLn "hello" -- works
16:42:02 <dons> mbishop: you have the code there?
16:42:04 <mbishop> Cale: ahh! is that required syntax?
16:42:17 <dons> main = putStrLn "hello" -- also ok, for one stmt only
16:42:21 <mbishop> dons: Cale's suggestion fixed it, it was just some silly example from wikipedia
16:42:22 <xerox-> |main| is the entry point
16:42:33 <mbishop> it also included getLine
16:42:43 <dons> mbishop: heh. not sure wikipedia is the best place to learn Haskell ;)
16:43:00 <xerox-> dons: dmhouse and kowey are working on that :)
16:43:03 <mbishop> indeed, it was actually just some code on the monad page
16:43:08 <dons> didn't we find they had foldl and foldr reversed the other day?
16:43:10 <SamB> hey wait...
16:43:13 <dons> Cale: was that right?
16:43:18 <SamB> this thing is cased over!
16:43:36 <Cale> dons: I rewrote the fold article
16:43:42 <xerox-> Cale fold-fu is high.
16:43:42 <mbishop> dons: I am reading (your?) Brief intro to haskell page, as well as YAHT
16:43:52 <Cale> http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29
16:43:56 <lambdabot> http://tinyurl.com/y4jgyn
16:44:02 <dibblego> mbishop, fix wikipedia :)
16:44:22 <mauke> > fix wikipedia
16:44:23 <lambdabot>  Not in scope: `wikipedia'
16:44:30 <dons> mbishop: ok good. n.b. my article is only 2 days old :)
16:45:02 <SamB> oh, hmm. right. no scrutinee discount...
16:45:23 <mauke> > let wikipedia = show in fix wikipedia
16:45:24 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:45:39 * SamB is trying to puzzle out why $wrotate* don't like him
16:46:37 <dibblego> ?type fix
16:46:38 <xerox-> mauke: are you proposing fixing wikipedia by ...quoting it?
16:46:39 <lambdabot> forall a. (a -> a) -> a
16:47:16 <psi> ?index fix
16:47:17 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
16:47:24 <dons> nice mauke. wikipedia is a fixpoint of people referencing each other?
16:47:39 <dons> > let blogspace = show in fix blogspace -- more accurate ?
16:47:40 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:47:51 <Pseudonym> > let web = show in fix web -- even more accurate
16:47:51 <dons> no content, just track backs ;)
16:47:52 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:48:09 <desrt> > let the bot rest -- seriously, guys
16:48:10 <lambdabot>  Parse error
16:48:13 <xerox-> > fix {- your -} show
16:48:14 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:48:24 <palomer> you fixed the web?
16:48:25 * psi doesn't get it
16:48:35 <desrt> psi; show(show(show(show(...
16:49:10 <palomer> I think the trick is that show always starts with a "
16:49:22 <xerox-> show returns a string
16:49:39 <palomer> oh, righto
16:50:09 <Cale> he is right though
16:50:22 <Cale> > head (show undefined)
16:50:23 <lambdabot>  Add a type signature
16:50:28 <Cale> > head (show (undefined::String))
16:50:29 <lambdabot>  '"'
16:51:09 <Cale> and that's the reason why it actually works to take the fixpoint of show
16:51:34 <palomer> show of a string always starts with a "
16:51:43 <palomer> that is a correct statement which gives insight to the question
16:51:50 <palomer> took me a while to realize this
16:52:07 <palomer> someone remind me of a function which doesn't have an undefined fixed point
16:52:31 <mauke> const x
16:52:34 <mbishop> hmm, anyone here use haskell-mode with emacs? emacs 22 to be specific, it seems to indent really weird
16:52:46 <dibblego> runhaskell ./Setup.hs haddock on lambdabot just returns immediately with no output - is this correct?
16:53:07 <EvilRanter> > fix id
16:53:08 <lambdabot>  Add a type signature
16:53:23 <EvilRanter> @type fix id
16:53:24 <lambdabot> forall a. a
16:53:40 <palomer> >fix const
16:53:44 <palomer> > fix const
16:53:45 <lambdabot>    Occurs check: cannot construct the infinite type: t = b -> t
16:53:46 <lambdabot>    Expec...
16:53:50 <ski> > fix undefined :: ()
16:53:51 <lambdabot>  Undefined
16:53:54 <palomer> the fied point of id is undefined
16:54:02 <mauke> > let x = 42 in fix (const x)
16:54:03 <lambdabot>  42
16:54:37 <dibblego> do you specify an option to a URL in package.cabal so that haddock can resolve some of the core types like Eq?
16:54:42 <palomer> hrmph.
16:54:43 <EvilRanter> > fox (const const)
16:54:44 <lambdabot>  Not in scope: `fox'
16:54:46 <EvilRanter> > fix (const const)
16:54:47 <lambdabot>  Add a type signature
16:54:49 <palomer> I once studied this crap
16:54:50 <palomer> no more
16:54:50 <EvilRanter> beh
16:55:52 <ski> @palomer
16:55:52 <lambdabot> woof
16:56:32 <dons> ok, Wadler dressed as Lambda Man, http://www.cs.uni.edu/~wallingf/blog-images/misc/lambda-man.jpg
16:56:37 <lambdabot> http://tinyurl.com/ymh46u
16:56:45 <mauke> > fix (const const) "x" 2
16:56:47 <lambdabot>  "x"
16:56:56 <xerox-> O_O
16:57:09 <mauke> it ain't rocket surgery
16:57:13 <xerox-> dons: and i thought H-M shirts were nice
16:57:24 <EvilRanter> H-M?
16:57:32 <xerox-> mauke: I was referring to the lambda-man...
16:58:53 <xerox-> EvilRanter: http://www.bloodandcoffee.net/campbell/images/HM-t-shirt.png
16:58:57 <lambdabot> http://tinyurl.com/y94qlj
16:58:57 <psi> > head (show (show undefined))
16:58:58 <lambdabot>  Add a type signature
16:59:07 <EvilRanter> ahh
16:59:29 <psi> that works in my ghci
17:01:20 <palomer> lambda man!
17:02:21 <kpreid> psi: ghci has more enthusiastic type defaulting
17:02:25 <kpreid> similarly,
17:02:26 <kpreid> > []
17:02:27 <lambdabot>  Add a type signature
17:02:42 <psi> aha
17:02:43 <SamB> I believe 6.6 has a flag to let you use that in source code too
17:02:52 <psi> > head ((show :: (String -> String)) undefined)
17:02:53 <lambdabot>  '"'
17:03:12 <SamB> lambdabot could use that when hs-plugins catches up
17:03:18 <EvilRanter> Hugs> []
17:03:18 <EvilRanter> [] :: [a]
17:03:18 <EvilRanter> (21 reductions, 32 cells)
17:03:30 <EvilRanter> makes more sense to me
17:03:54 <EvilRanter> is there any particular reason against polymorphic types at the top-level?
17:04:08 <kpreid> it's not top-level, it's evaluating them
17:04:11 <mauke> > [] :: [Char]
17:04:12 <lambdabot>  ""
17:04:18 <monochrom> What do you think?
17:04:26 <EvilRanter> w/e. i'm abusing the terminology, who cares..
17:04:52 <EvilRanter> fine. is there a problem with the end result of evaluations being polymorphic?
17:05:00 <monochrom> polymorphic type at the top is like you ask a question and someone replies "what do you think?"
17:05:02 <mauke> yeah, you can't print them
17:05:12 <EvilRanter> Hugs seems to manage
17:05:21 <thneed> Hello.
17:05:24 <EvilRanter> > id
17:05:25 <lambdabot>  Add a type signature
17:05:29 <EvilRanter> is just silly
17:05:31 <mauke> hugs just guesses that you didn't mean the [] of [Char]
17:05:40 <mauke> besides, you can't print functions anyway
17:05:41 <EvilRanter> huh?
17:05:56 <EvilRanter> (re "...didn't mean...")
17:06:16 <mauke> show ([] :: Char) is "", not []
17:06:48 <EvilRanter> er, i guess
17:06:53 <ski> > show ([] :: Char)
17:06:54 <lambdabot>  Couldn't match `Char' against `[a]'
17:07:06 <EvilRanter> > show ([] :: String)
17:07:08 <lambdabot>  "\"\""
17:07:15 <EvilRanter> heh
17:07:25 <thneed> How is Haskell pronounced? Is the stress on the first syllable or the second? (please excuse my ignorance ;)
17:07:33 <xerox-> G'night
17:07:36 <monochrom> First.
17:08:05 <mbishop> "Has-Kel"
17:08:22 <mauke> son of Jor-El
17:08:28 <mbishop> Iheh
17:08:31 <thneed> Thanks.
17:08:42 <mbishop> I suppose more like "Has-Kal" too, but that's probably preference
17:10:37 <thneed> I know somebody named Haskel with one L, but that seems
17:10:40 <thneed> er
17:10:45 <thneed> *apparently that's less common.
17:11:52 <ski> thneed : see http://www.haskell.org/tmrwiki/IssueSix
17:11:53 <lambdabot> Title: IssueSix - TmrWiki
17:12:04 <EvilRanter> wait, how does having an overloaded show() for String work? I thought you couldn't do "instance Class TypeAlias" or "instance Class [Foo]"...
17:12:18 <dibblego> how do I pass options to haddock when using cabal?
17:12:46 <mauke> EvilRanter: there's a showList method, overloaded for Char
17:12:49 <ski> (also, for shapr's way of pronouncing 'Haskell', see http://www.scannedinavian.com/~shae/shapr-haskell.wav)
17:12:52 <lambdabot> http://tinyurl.com/u6eo6
17:12:58 <EvilRanter> aha
17:13:02 <EvilRanter> that makes sense
17:13:03 <psi> this might  be my imagination, but it seems like in english, people are often uncertain about how to pronounce various names. in swedish, for instance, no one would ask how to pronounce haskell.
17:13:13 <EvilRanter> "linux"
17:13:18 <psi> or linux...
17:13:20 <mauke> instance (Show a) => Show [a] where show = showList
17:13:21 <ski> EvilRanter : it is basically a kludge
17:14:00 <edwardk> i'm in the "HAS-kl" camp myself. first syllable emphasis last syllable with a schwa
17:14:06 <EvilRanter> mauke, is that actually in the prelude or whatever, or is it aspecial casE?
17:14:24 <EvilRanter> (pardon my typing, it seemsto be deteriorating as time gfoes on#)
17:14:31 <wolverian> psi, right, english's ortography is not phonological.
17:14:34 <dons> psi: a lot of it has to do with vowel accents, differing greatly between, say, the Uk, the US and Australia
17:14:36 <EvilRanter> (damn laptop keyboardS)
17:14:44 <edwardk> then there is no al vs. el enunciation problem =)
17:14:44 <Dylan> psi: it is because English, for the most part, keeps the pronounciation and spelling of words it adopts
17:14:59 <dons> so you might say: Has-kal , has-kel or has-kul depending on your accent
17:15:01 <EvilRanter> I say has-k&schwa;l, too
17:15:43 <EvilRanter> digressing completely, i think it'd be useful if schwa was an official letter
17:15:45 <mauke> EvilRanter: prelude, I think
17:15:50 <psi> dons, mm, ok
17:15:55 <Dylan> I pronounce haskell different depending on time of day and mood... same for the word 'data'
17:16:02 <edwardk> evil: heh, become a linguist, its right in the center of the ipa vowel chart, you get to use it all the time ;)
17:16:15 <EvilRanter> include it in the various places in english where it's appropriate...
17:16:27 <EvilRanter> but then, I think the world needs more eth and thorn too
17:16:58 <EvilRanter> and that although should be spelt altho etc
17:17:16 <Dylan> EvilRanter: at's a good idea.
17:17:27 <edwardk> evil: definitely sounds like you're on track for linguistics ;)
17:17:35 <dons> ?join #gentoo-uy
17:17:51 <psi> wolverian, what does phonological mean?
17:18:07 <edwardk> psi: 'spelled the way it sounds' in this case
17:18:13 <psi> i see
17:18:39 <wolverian> I just put it in linguistic terminology so you can google it. :)
17:18:48 <EvilRanter> Dylan, shouldn't that be "at"?
17:19:25 <Dylan> EvilRanter: it would depend on how I pronounce 'that', wouldn't it?
17:19:47 <EvilRanter> well, i voice e "th". i don't know about you.
17:19:49 <Dylan> wouldn't  be the 'th' in think?
17:20:12 <ski> with 'at' it would sound more similar (but not same as) 'fat'
17:20:41 <Dylan> I can't see that char, oddly.
17:20:47 <EvilRanter> ski, at's what I was inking
17:21:08 <ski> at least in icelandish, '' is the one with "sounds" and '' the one without
17:21:11 <EvilRanter> http://en.wikipedia.org/wiki/Voiced_dental_fricative
17:21:12 <lambdabot> http://tinyurl.com/yheqmw
17:21:21 <Dylan> you pronounce 'thinking' differently than I do, I guess. O.o
17:21:34 <edwardk> add in all of the complications of not being able to hear certain sounds in certain situations, and of course phonetic spelling taken to an extreme is broken. =)
17:21:37 <EvilRanter>  /\ apparently voiced has symbol  in the IPA
17:21:37 <ski> s/sounds/voiced/ probably
17:21:46 <Dylan> I'm pretty sure thorn was used in old english for 'that'
17:22:27 <EvilRanter> eth went out of fashion before thorn
17:22:28 <ski> Dylan : yes, i seem to recall it beiing opposite in icelandish compared to OE
17:22:33 <EvilRanter> then thorn was used for both for a bit
17:22:40 <EvilRanter> then it was replaced with th
17:22:48 <ski> (hm .. could be that then)
17:22:59 <edwardk> heh amused to see my day job drifting in as a topic for #haskell.
17:23:04 <Dylan> there's an abbreviated form of thorn for 'that', I think
17:23:10 <edwardk> remind me never to use the word schwa again =)
17:23:28 <EvilRanter> but schwa's a brilliant word!
17:23:46 <EvilRanter> not only is it a useful vowel, but the word sounds like a sword being drawn!
17:23:47 <Dylan> it's Arnold Schwa!
17:23:49 <monochrom> schwa-child radius
17:23:56 <edwardk> next we'll have people trying to figure out if identifiers spelled in IPA should be constructors or function names
17:24:12 <ski> what is 'IPA' ?
17:24:24 <edwardk> the international phonetic alphabet
17:24:30 <Dylan> International Phonetic Alphabet
17:24:34 <EvilRanter> in other useless trivia, apparently "ye" in "ye olde" is supposed to be "e", but the thorn got broken at the top
17:24:51 <EvilRanter> (this is from when they used thorn for everything)
17:24:56 <edwardk> 120ish distinct phones mapped to symbols, and a handful of diacritics incase you need more meaning.
17:24:57 <Dylan> EvilRanter: yes. Makes me laugh when I see "ye old shoppe"
17:25:10 <EvilRanter> makes me murderous when I hear "ye olde shoppe"
17:25:46 <EvilRanter> .oO(even when it _was_ written like that normally, they said "the", damnit!)
17:25:55 <Dylan> I'm more interested in celtic (specifically q-celtic) languages. English is boring.
17:25:59 <EvilRanter> ("ye" means "you"!)
17:26:06 <EvilRanter> I like the book of kells...
17:26:30 <edwardk> linguists transcribe just about everything in IPA with varying degrees of accuracy when they work up something as part of the gloss.
17:26:39 <Pseudonym> Mi parolas malgrandan Esperanton.
17:27:04 <lispy> i like to translate when i've had a few IPAs too
17:27:06 <EvilRanter> ah, Esparanto. the universal language that nobody knows...
17:27:15 <Pseudonym> You betcha.
17:27:15 <EvilRanter> (also Pseudonym)
17:27:17 <Dylan> speaking of language, I'm supposed to idle in #haskell-es or risk losing what little fluency I have. :(
17:27:43 <edwardk> http://emeld.org/school/case/navajo/video.cfm?file=av/ultsnd has an example of an IPA translation
17:27:44 <EvilRanter> lispy: yeah, those initial public offerings really make you feel multinational, don't they?
17:27:46 <lambdabot> Title: E-MELD School of Best Practice: Navajo Ultrasound Video, http://tinyurl.com/yml7k9
17:28:12 <edwardk> taken  as an example from the aforementioned day job
17:28:55 <EvilRanter> lispy, or did you mean isopropyl alcohol?
17:29:31 <Pseudonym> The most frightening thing I ever saw in linguistics class was a dialogue between a child and her linguist mother.
17:29:35 <kpreid> Prelude> Data.Generics.Schemes.everywhere (Data.Generics.Aliases.mkT show) "abc"
17:29:38 <kpreid> "\"a\\\"b\\\\\\\"c\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
17:29:41 <Pseudonym> Child: "Mum, why are you doing that?"
17:29:41 <edwardk> Pseudonym: ?
17:29:47 <Pseudonym> Mother: "Why am I doing what?"
17:29:49 <kpreid> (it's a bit like fix show, but finite!)
17:29:53 <sjanssen> perhaps lispy meant "India Pale Ale"?
17:29:55 <Pseudonym> Child: "Why are you writing down everything I say?"
17:30:00 <edwardk> hahaha
17:30:06 <EvilRanter> sjanssen, i know
17:30:27 <Pseudonym> Just about every linguist goes through a brief period of interest in child language development.
17:30:38 <EvilRanter> i find the "india pale ale" -> "ipa" -> "isopropyl alcohol" thing amusing
17:30:57 <mauke> rawr, select :: [FileDescr] -> [FileDescr] -> [FileDescr] -> Double -> ([FileDescr], [FileDescr], [FileDescr])
17:31:00 <Dylan> coi mi'e dilan.
17:31:14 <edwardk> Pseudonym: i'm safe from that, my fiancee (a linguist) has decided she absolutely doesn't want kids and wants as little to do with them as possible. ;)
17:31:24 <monochrom> Don't drink isopropyl alcohol
17:31:28 <EvilRanter> indeed not
17:31:29 <Pseudonym> So I take it she works with adults. :-)
17:31:41 <edwardk> Pseudonym: yeah
17:31:50 <EvilRanter> do drink india pale ale, tho. i'm told by beer geeks that it's generally quite good.
17:32:03 <Dylan> (.i mi na se bangu la lojban.)
17:32:05 <monochrom> "Honey, why are you doing that?"  "Doing what?"  "Writing down everything I say."
17:32:37 <edwardk> dylan: i long ago lost the ability to read loglan/lojban.
17:32:43 <SamB> > 2147483646 :: Int
17:32:44 <lambdabot>  2147483646
17:32:52 <EvilRanter> "so i can blackmail you for everything you've got when i catch you shagging your secretary"
17:32:57 <Dylan> edwardk: reading both is a feat. I just said "I don't speak lojban"
17:33:11 <monochrom> Clearly :)
17:33:21 <Pseudonym> The dialogue actually had a point.  It was about the way that kids supply more information if they feel misunderstood.
17:33:28 <Dylan> edwardk: I only learned enough lojban to write poems to someone I had a crush on.
17:33:42 <edwardk> Dylan: heh
17:33:50 <Pseudonym> One of the most frightening parts was the mother was deliberately misunderstanding to see what the kid did.
17:34:01 <Pseudonym> I'm sure she didn't run that past the ethics committee.
17:34:19 <Pseudonym> Scarred for life.
17:34:21 <edwardk> Pseudonym: yeah, human test subjects, hello =)
17:34:27 <Dylan> heh
17:34:32 <Dylan> every parent does that at some point.
17:34:50 <Dylan> Or actually doesn't sufficiently understand what the child means.
17:35:04 <lispy> to me IPA means india pale ale....
17:35:11 <SamB> > (-3 `shiftR` 1) :: Word
17:35:13 <lispy> and is generally a good beer
17:35:13 <lambdabot>  4294967295
17:35:20 <SamB> hmm.
17:35:36 <lispy> > (-3 `shiftR` 1) :: Word> (-3 `shiftR` 1) :: Int
17:35:37 <lambdabot>  Parse error
17:35:42 <edwardk> we could have a lot more progress in cognitive science and linguistics if we were just allowed to open people's skulls up and lesion them at will to see how it affected different forms of cognition and speech, but no, these silly morals people insist on having, bah.
17:35:42 <lispy> > (-3 `shiftR` 1) :: Int
17:35:44 <lambdabot>  -1
17:36:00 <dolio> > ((-3) `shiftR` 1) :: Word
17:36:00 <Cale> > (-1) :: Word
17:36:01 <lambdabot>  2147483646
17:36:02 <lambdabot>  4294967295
17:36:23 <SamB> lispy: I'm trying to check whether my rule for uncheckedIShiftRL# works correctly
17:36:34 <Dylan> it's really interesting watching a 3 year old pick up your speech patterns.
17:36:59 <monochrom> "open your mind!"
17:37:18 <Dylan> me: Stop poking the dog, he'll get angry. 3 year old: I do not see the utility in that!
17:37:26 <Pseudonym> My four year old asked me last week what "sardonic" means.
17:37:58 <SamB> well, it gives the same value as I get with 6.4.1 or whatever...
17:38:00 <Dylan> I actually worry that my overly elaborate speech is going to cause my fiancee's son some horrible mental disorder...
17:38:01 <SamB> Pseudonym: heh
17:38:14 <SamB> Dylan: don't worry
17:38:28 <SamB> unless you think "smart" is such
17:38:39 <Dylan> SamB: Hehe. :)
17:38:47 <edwardk> dylan: nah, it'll just turn him into a social pariah, and thence into a geek who works with a computer as an adult. didn't work out so bad for you did it? =)
17:39:04 <Dylan> he's also learning to switch between various... made up accents... and also mimic all the sound effects I make
17:39:20 <edwardk> heh
17:39:28 <SamB> heh
17:39:36 <SamB> an actor, then ;-)
17:39:43 <Dylan> btw, does anyone else make up random sounds, and 'misplace' them? Some days I can't do a proper robot ninja voice. :(
17:39:56 <SamB> heh
17:40:15 <lispy> Dylan: do they have an iso standard for that yet? ;)
17:40:28 <Dylan> lispy: no. :P
17:40:30 <SamB> I would do that
17:40:41 <Dylan> do what?
17:40:42 <SamB> if I tried to remember random sounds I made
17:40:43 <Pseudonym> Yeah, some days I can't do Michael Caine.
17:40:53 <SamB> forget the random sounds!
17:40:59 <Dylan> Ah.
17:42:14 <Dylan> I can a realistic irish accent, as long as I recite "In the beginning there was data / the data was null and the spirit of IBM was moving over the face of the market"
17:42:25 <Dylan> s/a/do a/
17:44:19 <Pseudonym> I can kind of do a Bob Geldof.  Does that count?
17:44:21 <Dylan> which is useful when my fiancee asks me to BS some annoying people at a restuarante or what-have-you.
17:45:02 <Dylan> I dunno bob geldof from Gandalf. Who's he?
17:45:12 <Pseudonym> Errr...
17:45:19 <EvilRanter> roflcopters
17:45:24 <Dylan> unless that is your name.
17:45:27 <Pseudonym> No.
17:45:36 <Pseudonym> Never heard of the Boomtown Rats?
17:45:51 <Dylan> Sounds like a venereal disease. XD
17:46:04 <Pseudonym> Or Live Aid?
17:46:17 <Dylan> live aid is some charity concert?
17:46:36 <Pseudonym> Was.
17:46:57 <Dylan> Ah. I am not versed in anything modern, music-wise.
17:47:10 <Pseudonym> How old are you?
17:47:13 <Dylan> 21
17:47:30 <Dylan> Although right now I'm still mimicing a 78 vietnam vet...
17:47:37 <Pseudonym> We're talking before you were born.
17:47:44 <Dylan> *78 year old.
17:48:06 <EvilRanter> heh. modern.
17:48:10 <Pseudonym> OK, if you're 78, then this is newfangled stuff.
17:48:17 <Dylan> Modern is anything before 19:20
17:48:18 <Pseudonym> If you're 21, it's before you were born.
17:48:55 * fons is happy to be done coding the first attempt of porting LADSPA to Haskell :)
17:50:05 <Dylan> I listen folk music (irish/scots/newfoundland, germanic, and indian, in order of preference), roots reggae, and old old jazz.
17:50:18 <Dylan> Man, I am missing all the important conncetor words today
17:50:37 <EvilRanter> the one you really don't want to drop is "but"
17:50:45 <monochrom> use combinators instead
17:51:16 <dons> fons: cool!
17:51:16 <dons> url?
17:51:34 <fons> dons, I didn't upload it yet
17:51:35 <Dylan> Pseudonym: anyway. Yes. Music from 20 to present is "modern".
17:51:40 * mauke is listening to: Matrix Reloaded 1 - 04 - Rob Dougan - Furious Angels.mp3
17:52:18 <dons> fons: also, we've started a guide on writing new haskell projects, here, http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:52:22 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
17:52:30 <dons> fons: let me know if anything in that needs clarification, or so on
17:52:40 * Pseudonym is listening to the sound of bytes from his serial connection disappearing into the ether
17:52:43 <Dylan> dons: that is useful for me, too! Whee!
17:52:50 <fons> thanks dons
17:53:34 <monochrom> Why does no one ever programmatically state what they are *watching*?
17:53:45 <fons> my project is a bit wierd cause it mixes C and haskell and there is no main program :P
17:53:54 <Pseudonym> I'm currently watching my IRC client.
17:53:58 <mauke> same here
17:53:59 * Pseudonym shrugs
17:54:10 <dons> fons: so its a library?
17:54:17 <dons> mixing C and haskell is pretty common.
17:54:33 <fons> dons, no, it's not a library
17:54:36 <EvilRanter> yeah. C's the tonic water of programming languages, it gets mixed with everything
17:54:45 <EvilRanter> and it's bland on its own
17:54:50 <dons> heh
17:54:56 <monochrom> I mean if you watch a DVD your irc client should periodically state "I'm watching Brokeback Mountain" or something.
17:55:05 <fons> dons, its an sdk to build plugins (libraries ...)
17:55:07 <SamB> ewww
17:55:08 <EvilRanter> that's just irritating
17:55:10 <dons> EvilRanter: also, tastes a bit bitter, like quinine, I find
17:55:15 <SamB> isn't that that gay movie?
17:55:23 <EvilRanter> samB, is that a problem?
17:55:38 <SamB> EvilRanter: I'm not talking to you ;-)
17:56:00 <EvilRanter> he said. addressing me.
17:56:15 <monochrom> I wish I knew p0rn movie names.
17:56:17 <dons> SamB: what's this primop rules stuff?
17:56:33 <SamB> dons: constant folding for bitshifts
17:56:43 <dons> have we always had primop rules?
17:56:47 <fons> dons, that's a really useful guide
17:57:08 <dons> fons: good. needs filling out some more, I think.
17:57:11 <fons> dons, it lacks saying how to announce the project in planet haskell, is it an open blog?
17:57:13 <SamB> I don't know, but that is how we've been doing constant folding
17:57:24 <dons> fons: ah right. i'll update that now
17:57:29 <SamB> for primops
17:58:56 <mauke> http://ha.ckers.org/images/clip_php_cms.png
18:00:57 <dons> fons: in essence, you blog on your own blog, then pass the rss feed url to ibid, here, who'll add it to planet haskell
18:01:16 <fons> dons, it lacks as well suggesting were to host the project. Should people stick to sourceforge and friends .. or is there any haskell-specific hosting available?
18:01:39 <dons> right. good point
18:02:11 <edwardk> fons: whats the project?
18:02:23 <edwardk> woops, *scrolls back*
18:03:00 <fons> edwardk, we are discusing about haskell projects in general, in my case I'm porting Ladspa to haskell
18:03:22 <fons> s/Ladspa/LADSPA
18:03:28 <edwardk> how much demand is there for haskell-specific hosting? i have a server, and i'm not against throwing another account on it for a good cause
18:03:54 <dons> we need it. hackage should provide this though
18:04:17 <Ulfalizer> haha, god i love fox news. they were having an interview with some pro-life guy, and suddenly the reporter says something like, "so you're basically saying that it's right to KILL INNOCENT CHILDREN. i think you're wrong there, and i think a lot of americans would agree" :D
18:04:29 <Ulfalizer> *pro-choice
18:04:40 <SamB> heh
18:04:58 <SamB> its true though ;-)
18:05:01 <edwardk> ulf: this is why i watch the daily show for my news, fox has gone so completely off the deep end.
18:05:43 <Ulfalizer> edwardk: you can basically infer what has been said on fox news from the daily show anyway :)
18:05:46 <dons> heh, "this is why i watch the daily show for my news" :)
18:05:47 <edwardk> i'd rather laugh at the daily show than cry in frustration over fox =)
18:06:12 <EvilRanter> isn't
18:06:15 <EvilRanter> er, nm
18:06:33 <EvilRanter> \b and \n are too close tohether on keyboards...
18:06:34 <monochrom> "The media is the message."
18:06:38 <edwardk> dons: there was a study that showed the daily show contains as much news content as a real news broadcast and that the remaining conversation, unlike the majority of news shows was actually about the content =)
18:06:40 <mauke> http://arstechnica.com/news.ars/post/20061004-7908.html
18:06:44 <lambdabot> http://tinyurl.com/oul2z
18:06:54 <edwardk> yeah
18:08:06 <edwardk> am sad that i can't catch as much of it on youtube any more though
18:08:15 <fons> the user of my libary, in order to build his/her plugin _always_ has to export a function so that a CWrapper can use it
18:08:25 <dolio> Marshall McLuhan, what are ya doin'?
18:08:44 <edwardk> fons: what about template haskell?
18:08:46 <fons> the function is in my library, is there a way to automate the process? (macros etc ..)
18:08:54 <fons> edwardk, I was looking at that right now
18:09:06 <fons> edwardk, nothing more similar to macros than that?
18:09:14 <edwardk> fons: template haskell is your best bet whenever you have something repetitive to do
18:09:26 <edwardk> fons: well, you can also use the c preprocessor, but its not as clean.
18:09:41 <EvilRanter> ew
18:09:42 <fons> edwardk, I'll go for template haskell then
18:10:10 <fons> GHC's documentation is pretty bad
18:10:40 <fons> I mean, it's not intuitive, I'd rather have a look at a tutorial of TH
18:11:29 <dons> edwardk: oh I agree. its a great src of analysis :)
18:13:56 <dons> mbishop: so how's the haskell hacking coming along?
18:13:59 <dons> making progress?
18:14:27 <SamB> I like this new process.
18:14:33 <dons> for the libs?
18:14:39 <SamB> step 1: discuss what color we'd like for the bikeshed
18:14:45 <SamB> step 2: submit a patch
18:14:45 <fons> are there any tutorials about TH around?
18:14:45 <dons> heh
18:14:53 <SamB> step 3: wait for nobody to complain
18:15:19 <fons> http://www.haskell.org/hawiki/TemplateHaskell
18:15:20 <dons> fons, all material is linked from haskell.org/th
18:15:20 <lambdabot> Title: TemplateHaskell - The Haskell Wiki
18:15:37 <dons> but i'm not 100% sure TH is the best solution. its rather experimental
18:15:45 <fons> found it, need coffee
18:15:46 <dons> it is used in a few libraries though, for this kind of thing
18:16:16 <monochrom> heh heh heh "need coffee"
18:16:40 <fons> dons, I have to stick to ghc 6.6 anyway cause I'm using existentially quantified records so I don't care. I'm doin it to learn and for fun
18:17:10 <dons> cool. that's the spirit!
18:17:21 <dons> oh, you're using the audreyt-style records?
18:18:24 <dons> audreyt++ a user!
18:20:03 <fons> audreyt-style?
18:20:23 <dons> I think audreyt wanted this feature, and added the patch for it to ghc a few months ago
18:22:53 <SamB> what feature?
18:25:24 <SamB> @google haskell.org/ghc "existentially quantified records"
18:25:25 <lambdabot> No Result Found.
18:25:33 <SamB> @google haskell.org "existentially quantified records"
18:25:34 <lambdabot> No Result Found.
18:25:38 <SamB> @google site:haskell.org "existentially quantified records"
18:25:39 <lambdabot> No Result Found.
18:27:06 <dons> hmm. strikes me that Pan and similar would be nice for playing around with captcha generation
18:30:49 <Adamant> when will Haskell have a SICP?
18:31:18 <SamB> what? you mean a book that shows a dozen ways to write a Haskell interpreter?
18:31:36 <Adamant> a book that is a classic in CS
18:31:44 <Adamant> especially for n00bs
18:31:54 <dolio> And half a dozen to write square root of two? :)
18:32:38 <Ulfalizer> http://www.youtube.com/watch?v=OrfLjozo8NM is just hilarious when you've actually lived in malm for a while. i've never seen an encounter between swedes and muslim immigrants. the interview with the policeman is taken out of context, the school is a MUSLIM SCHOOL that's located in an area where mostly muslims live. on top of that, even though the problem isn't nearly as bad as portrayed, malm is known as an extreme case when it comes to bad i
18:32:55 <Ulfalizer> i know this isn't #rant, but i had to get it out of me :P
18:34:07 <dons> Adamant: i'd say some time in the next 10 years. there's enough academics using haskell now that one of them will write a classic text :)
18:34:21 <dons> as has been done in the past for older languages like lisp, scheme and mL
18:34:46 <dons> Modern Compiler Implementation in Haskell, anyone?
18:34:46 <EvilRanter> "'ML for the working programmer'... you at the back, stop sniggering!"
18:35:10 <Adamant> what do you think Haskell will be uniquely suited for with regards to teaching new programmers
18:35:11 <dons> "Foundations of Concurrency, with Haskell", perhaps?
18:35:20 <Adamant> laziness?
18:35:28 <Adamant> pure functionality?
18:35:31 <SamB> dons: but how long before it *becomes* a classic?
18:35:41 <SamB> I don't think they make instant classic CS texts
18:35:45 <SamB> not like novels
18:35:49 <dons> Adamant: usual arguments for scheme and lisp, but more so :)
18:35:53 <Adamant> dons, is that a book to be written or a book you are working on?
18:36:03 <mbishop> what haskell needs first is a popular figure praising haskell, like norvig or graham for lisp
18:36:09 <edwardk> dons: i'm trying to arrange to teach a class like that this coming year some time. (the compiler implementation in haskell one that is)
18:36:17 <dons> they're books that exist, that could be written instead in haskell
18:36:20 <edwardk> mbishop: we have larry wall some times =)
18:36:32 <SamB> edwardk: I said interpreter, but whatever
18:36:38 <mbishop> edwardk: ok, popular people that are sane? :)
18:36:39 <Adamant> Perl is Larry's baby, though
18:36:42 <SamB> compiler, interpreter, whats the difference/
18:36:49 <SamB> s|/|?|
18:36:52 <dons> ?quote LarryWall
18:36:52 <lambdabot>  ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
18:37:05 <mbishop> heh
18:37:16 <dons> take that Paul Graham!
18:37:24 <mauke> ?quote LarryWall
18:37:24 <lambdabot>  ..take Lisp. You know it's the most beautiful language in the world. At least up until Haskell came along.
18:37:27 <mauke> :(
18:37:32 <dons> ?quote TimToady
18:37:32 <lambdabot>  learning Haskell itself is easy--I've done it several times already
18:37:42 <qwr> :P
18:37:44 <Adamant> Haskell just hasn't hit "beautiful" for me yet. Interesting, imaginative, conceived by deep geeks - all true
18:38:09 <Ulfalizer> there are already some pretty excellent haskell CS texts. i'm working through "the haskell road to logic, maths and programming".
18:38:13 <mbishop> I still find lisp prettier so to speak, but I imagine that's because I know it
18:38:18 <Adamant> I have that one filed away
18:38:29 <Adamant> mbishop, I'm learning Haskell. very slowly
18:38:31 <EvilRanter> I find perl rather pretty :P
18:38:58 <mbishop> Hmm, I remember on the Alice ML site, there was a wiki with CTM and SICP in various languages, don't think they had haskell though
18:39:19 <monochrom> The whole idea of computing is conceived by deep geeks.
18:40:02 <SamB> mbishop: well, you'd want to write a *Haskell* book
18:40:04 <dons> mbishop: you can always write haskell as if it was lisp ;)
18:40:14 <SamB> not just SICP with Haskell
18:40:18 <mbishop> oh I was wrong, there is chapter 1 of SICP with haskell
18:40:26 <mbishop> http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages:Haskell:Chapter_1
18:40:29 <dons> oh! good
18:40:31 <lambdabot> Title: Topics:SICP in other languages:Haskell:Chapter 1 - CTMWiki, http://tinyurl.com/v6rpn
18:40:43 <dons> didn't know that.
18:40:45 <dons> mbishop++
18:40:57 * dons updates haskell.org's tutorials list
18:41:09 <mbishop> doesn't seem complete yet, but meh, it's something
18:41:24 <dons> ah yes. its a start
18:41:33 <Adamant> dons, what got you hooked on Haskell?
18:41:43 <dons> Adamant: my PhD ? :)
18:41:45 <mbishop> one of you gurus can finish it up perhaps :P
18:41:52 <dons> though it was also the first language I learnt at university
18:41:54 <Adamant> haha, I meant before that
18:42:06 <Adamant> ah. you were going to Uni in Europe?
18:42:08 <EvilRanter> it's what we're being taught first at uni
18:42:09 <qwr> dons: lisp programmers don't avoid side effects
18:42:16 <dons> Adamant: no, .au
18:42:21 <EvilRanter> s/it/haskell/
18:42:31 <EvilRanter> but then, I was taught VB6 in school (ugh)
18:42:33 <EvilRanter> and
18:42:57 <Ulfalizer> VB6 at uni level? :/
18:42:58 <dons> edwardk: oh, you're at oxford?
18:43:01 <EvilRanter> ...'ve taught myself perl, ML, Tcl, Scheme, ruby...
18:43:03 <Ulfalizer> or high school?
18:43:05 <dons> EvilRanter: I mean.
18:43:06 <EvilRanter> high school
18:43:12 <EvilRanter> dons, yes.
18:43:14 <Ulfalizer> got worried for a while there..
18:43:22 <dons> is dcoutts your tutor, by chance? :)
18:43:29 <edwardk> my first college programming course was pascal, which by the time i got there i was already quite comfortable with =)
18:43:32 <dons> we have a few of the oxford crowd here.
18:43:50 <int-e> hmm. average x y = [...]   improve' (guess, x) = average(guess, x / guess)   :-(
18:44:01 <dons> yeah, some dodgy haskell on that page.
18:44:29 <EvilRanter> dons, no, but he does run the func.prog. practicals
18:44:38 <monochrom> You think VB6 is bad?  Imagine line-numbered BASIC.
18:44:57 <Ulfalizer> is the sicp text available online, or are they just converting the code samples?
18:45:10 <dons> EvilRanter: I recommend you try to pick his brain if possible. having local access to a dcoutts or an Igloo is an invaluable resource
18:45:17 <EvilRanter> monochrom, been there ,done that. on a BBC Micro with a beige&white screen no less.
18:45:33 <EvilRanter> dons, I'm being tutored by Chris Dilloway, if you know him
18:46:14 <EvilRanter> but he's a random DPhol, so you likely don't.
18:46:19 <EvilRanter> *DPhil
18:46:50 <dons> no, i don't think i know him.
18:47:04 <EvilRanter> i get lectures by Richard "tracks" Bird
18:47:19 <SamB> monochrom: can't I please just use qbasic?
18:47:45 <monochrom> You can just use Haskell.
18:48:01 <SamB> point
18:48:10 * monochrom conjures  class Monad m => QBASIC m where ...
18:48:29 * edwardk shudders at monochrom's suggestion
18:48:51 <lispy> hah, that'd by funny, implement QBASIC as an eDSL
18:48:51 * monochrom is going to dress up like QBASIC on Halloween
18:49:02 <EvilRanter> I've meditated on doing weird things for, eg, markup where I import Prelude(); import MarkupFns;
18:49:29 <EvilRanter> including comandeering stuff like (+) for my own nefarious uses
18:49:40 <ThreeQ> hmm, why doesn't this work?
18:49:41 <ThreeQ> (sequence . map randomRIO . repeat) ('a','z') >>= putStrLn . take 5
18:49:43 <edwardk> evil: that isn't so terrible. i did that one already =)
18:50:09 <SamB_XP> watch me commendeer + for *mine*
18:50:22 <SamB_XP> > let 2+2 = 5 in 2+2
18:50:24 <lambdabot>  5
18:50:28 <EvilRanter> edwardk, I wasn't saying it was
18:50:55 <edwardk> evil: needed something like (+) :: Additive a b c => a -> b -> c
18:51:23 <EvilRanter> > let mul=(*) in let 6*9=42;x*y=x `mul` y in 6 * 9
18:51:25 <lambdabot>  42
18:51:55 <SamB_XP> whoohoo
18:52:00 <SamB_XP> it got the answer ;-)
18:52:20 <EvilRanter> hm. question: can you use fences in lambdas.
18:52:20 <EvilRanter> ?
18:52:21 <kpreid> ThreeQ: the IO monad isn't lazy
18:52:32 <EvilRanter> and how?
18:52:55 <ThreeQ> kpreid: oh :/
18:53:09 <dons> EvilRanter: fences?
18:53:11 <SamB_XP> EvilRanter: nah
18:53:16 <SamB_XP> dons: guards
18:53:18 <dons> ah
18:53:35 <EvilRanter> I'm sure i heard them called fences. am I confused?
18:53:46 <SamB_XP> no indeed
18:53:54 <SamB_XP> some people sometimes call them that
18:54:11 <dons> no, you can't. it was decided that to keep lambdas simple, they shouldn't have guards. there's a proposal to add them (just a single guard) to haskell'. however, you can always just use a 'where' clause with a function defintiion if you need patterns or guards
18:54:23 <EvilRanter> I guess.
18:54:37 <SamB_XP> a single guard would just give you a pattern match error if it failed, right?
18:54:47 <EvilRanter> patterns, it's easy enough to write (\x -> case x of...)
18:54:51 <dons> i.e. there's something to be said for: \x | x `elem` ys -> ...
18:55:01 <SamB_XP> EvilRanter: you can use guards on cases, actually
18:55:03 <dons> but it rapidly gets a bit ugly
18:55:12 <EvilRanter> SamB, you can?!
18:55:22 <SamB_XP> (\x -> case x of Foo a | isNice a = ...)
18:55:27 <SamB_XP> er.
18:55:30 <SamB_XP> s/=/->
18:55:39 <monochrom> http://www.haskell.org/onlinereport/  has information
18:55:41 <lambdabot> Title: The Haskell 98 Language Report
18:55:42 <dons> see this thread, http://www.haskell.org/pipermail/haskell-prime/2006-October/001758.html
18:55:45 <lambdabot> Title: (Pattern) Guards in lambdas, http://tinyurl.com/yzseyz
18:56:06 <EvilRanter> > map (\x -> case x of x | x==0 = "yes"; x>0 = "no"; otherwise = "file not found) [0,1,-1]
18:56:07 <lambdabot>  Parse error
18:56:23 <dons> I find this quite persuasive, http://www.haskell.org/pipermail/haskell-prime/2006-October/001763.html .. "lambda is a quiet syntax"
18:56:25 <lambdabot> Title: (Pattern) Guards in lambdas, http://tinyurl.com/y8xwpe
18:56:27 <EvilRanter> > map (\x -> case x of x | x==0 = "yes"; x>0 = "no"; otherwise = "file not found") [0,1,-1]
18:56:27 <lambdabot>  Parse error
18:56:28 <SamB_XP> er. s/=/->/
18:56:46 <EvilRanter> > map (\x -> case x of x | x==0 -> "yes"; x>0 -> "no"; otherwise -> "file not found") [0,1,-1]
18:56:46 <lambdabot>  Parse error in pattern
18:56:51 <dons> > map (\x -> case x of _| x == 0 -> "yes" ; _ -> "no") [0,1,-1]
18:56:53 <lambdabot>  ["yes","no","no"]
18:57:15 <SamB_XP> > map (\x -> case x of x | x==0 -> "yes" | x>0 -> "no" | otherwise -> "file not found") [0,1,-1]
18:57:17 <lambdabot>  ["yes","no","file not found"]
18:57:33 <EvilRanter> ooooh
18:57:40 <EvilRanter> missed off the "|"a
18:57:41 <EvilRanter> *s
18:57:47 <EvilRanter> whups
18:57:56 <SamB_XP> its not so obvious when you aren't coding in 2d ;-)
18:58:06 <EvilRanter> also, you don't need ";"s? that's goood to know
18:58:24 <scodil> is there a resource somewhere that details the kinds of optimizations that ghc (or another compiler) does? When I'm writing, I get curious all the time about what exactly ghc is going to do with this and that, but I hesitate to ask in here or on a list because you invariably get comments like "that's not your concern unless the program isn't running fast enough"
18:58:25 <SamB_XP> only between different pattern parts
18:58:28 <SamB_XP> or whatever
18:58:38 <EvilRanter> right
18:58:41 <dons> scodil: yes. let me find you some urls
18:58:44 <dons> ?wiki Performance
18:58:45 <dons> has some
18:58:45 <lambdabot> http://www.haskell.org/haskellwiki/Performance
18:59:00 <dons> the rest are in the form of the gHC wiki and the ghc research papers
18:59:12 <SamB_XP> well, to be sure what GHC does to certain kinds of code you kinda have to, um, run GHC on some of that kind of code ;-)
18:59:25 <SamB_XP> and it might change for no real reason sometimes...
18:59:46 <dons> here, http://hackage.haskell.org/trac/ghc and http://haskell.org/haskellwiki/Research_papers/Compilation
18:59:48 <lambdabot> Title: GHC - Trac
19:00:18 <int-e> Hmm, that SICP page is full of Lisp code, written in Haskell. I guess what's missing most is any hint of being aware of lazy evaluation - there no infinite lists there, and too much explicit recursion.
19:00:24 <dons> scodil: but feel free to ask about what ghc does, its an interesting topic
19:00:31 <scodil> on that note, how do you look and see what kind of code gets generated? I can't imagine looking at the assembly is at all revealing... or is it? I thought i saw a reference to some kind of intermediate language
19:00:44 <dons> -ddump-simpl is the first port of call
19:00:45 <SamB_XP> int-e: like I said, SICP in Haskell isn't what we want ;-)
19:00:51 <SamB_XP> because SICP remains SICP
19:00:53 <dons> which dump Core, the intermediate language
19:01:02 <dons> (System F/Haskell core-ish)
19:01:08 <dons> then there's -ddump-asm and so on
19:01:23 <kpreid> ThreeQ: use this instead: liftM (randomRs ('a','z')) newStdGen
19:01:24 <dons> scodil: these flags are documented in the ghc user's guide. and on the performance wiki I pointed to above
19:01:31 <SamB_XP> one of my favorites is -ddump-inlinings
19:01:33 <dons> there's even  a tutorial on using -ddump-simpl to improve code
19:01:44 <kpreid> ThreeQ: that'll get you an infinite list which is computed outside of the IO monad
19:01:47 <SamB_XP> dons: tutorial?
19:01:57 <ThreeQ> kpreid: cool :)
19:02:08 <SamB_XP> oh, is there one for using that to improve GHC ;-P?
19:02:08 <dons> SamB_XP: mini-tut on one of the ghc performance sub pages
19:05:01 <kpreid> ThreeQ: you could have done what your original code was trying to do with unsafeInterleaveIO, but.
19:05:23 <ThreeQ> oh, that makes sense
19:05:28 <scodil> is there any kind of wrapper array type? something you can just give a chunk of memory, and it will behave as any other array, but not free the memory when it gets collected?
19:05:31 <ThreeQ> but that's silly in the random number case I guess
19:05:51 <ThreeQ> since only the seed-getting part is impure
19:05:51 <SamB_XP> scodil: you could write one if there isn't
19:06:04 <kpreid> ThreeQ: yes. note the 'split' operation which newStdGen uses
19:06:33 <SamB_XP> scodil: sort of
19:07:18 <SamB_XP> were you hoping for read-only or mutable?
19:08:02 <dons> scodil: Foreign.* has methods for allocating a chunk of heap space, and casting it to an unboxed array
19:08:34 <dons> and if you tag it as a ForeignPtr, then the GC can free it when it notices all references to that space are gone
19:23:13 <dons> ?seen ste
19:23:14 <lambdabot> I haven't seen ste.
19:23:22 <dons> do we know this guy? http://ste.aeschbacher.ch/blog/2006/04/entry1
19:23:25 <lambdabot> Title: Ste's Site - Haskell programming
19:24:23 <dibblego> all haskellers know all other haskellers
19:25:12 <dons> the community's getting big enough that sometimes maybe we don't know someone. its weird
19:25:54 <dons> dibblego: thanks for the mail on the project page, btw.
19:26:05 <dibblego> dons, no problem
19:27:12 <EvilRanter> it's like Six Degrees to Simon Peyton-Jones...
19:29:14 <SamB_XP> new "blub" language!
19:29:17 <SamB_XP> heh
19:29:49 <SamB_XP> I totally get what he means though
19:30:04 <SamB_XP> I guess it has been my blub language for quite some time ;-)
19:30:51 * SamB_XP goes to bed now
19:33:56 <lispy> dons: i updated your guide to haskell projects a bit
19:34:40 <lispy> i added some small cabal examples so people don't have to search the manual to find them and added a few more links (one to small check and one to the step by step monad transformer tutorial)
19:35:02 <dons> lispy++
19:35:41 <EvilRanter> ::[IRCer]->[IRCer]
19:35:44 <EvilRanter> =P
19:36:10 <lispy> dons: i think it's a good guide to have
19:36:19 <lispy> dons: can you post it to reddit in a few days?
19:36:26 <dons> heh. yeah ok.
19:36:46 <dons> yeah. some _new_ content, rather than all this 5 year old ocaml stuff being posted...
19:36:58 <lispy> heh
19:36:58 <monochrom> The people you know are (exactly) the people known to all those who know all whom you know.
19:37:21 <dons> lispy: makes me think that nothing new is happening in ocaml ;) or at least they're not blogging
19:37:51 <lispy> dons: when i asked about it in #ocaml i got an unsettling response
19:38:04 <dons> oh?
19:38:14 <lispy> it was te the effect, "Our software didn't have bugs 5 years ago when we packaged it, why would we update it?"
19:38:17 <Cale> oh and look, the useless use of cat award page, last updated in 2000
19:38:45 <dons> lispy: that's code for: we're not working on much at the moment, I ugess.
19:39:10 <Cale> Where were these people 6 years ago?
19:39:11 <dons> as much as I like seeing Ocaml (and any FP) articles, its not good to post old content
19:40:08 <lispy> i'm really surprised but the wiki doesn't seem to have any pages on quickcheck or hunit
19:40:32 <lispy> maybe the testing section should link to my blog article about creating a quickcheck framework with TH
19:40:34 <dons> there's my QC tutorial
19:40:41 <monochrom> What needs updated in OCaml?
19:40:44 <dons> but its very brief (just an elaboratoin of an email)
19:40:45 <lispy> dons: url?
19:40:49 <dibblego> I'm still stuck on writing an instance Arbitrary for my type - I gave up
19:40:53 <dons> lispy: check the Tutorials sub category
19:42:09 <dons> dibblego: hmm. ok.
19:42:16 <dons> dibblego: sounds like we need a tuto
19:42:19 <dons> rial
19:42:26 <dibblego> dons, definitely, thanks
19:42:41 <lispy> why did they remove the edit links from the wiki?
19:42:48 <dons> lispy: ?
19:42:53 <lispy> i really find it annoying thta you can't edit just a section
19:42:54 <dons> (you're not logged in maybe?)
19:43:00 <dons> you can!
19:43:13 <dons> oh, unless its subsections
19:43:16 <lispy> i mean, there is the "Edit this page" link, but none of the pages i see have it in the sections
19:43:24 <dons> at some point, === I think, they don't become editable subsectoins
19:43:56 <monochrom> I guess you carefully change one piece and preserve the other pieces
19:44:21 <fons> does anyone have some experience with template haskell?
19:44:24 <lispy> dons: that's fine, but i'm not seeing them even for =Top level sections= or the ==next level==
19:44:32 <lispy> fons: some
19:44:54 <fons> lispy, I want to generate a really simple macro
19:44:58 <scodil> i don't see anything in Foreign.* that makes an IArray out of a pointer. I see stuff that makes an [a] out of Ptr a, but thats not quite the same. I'd write such an instance of IArray myself, as someone suggested, except that peek is in IO. Why is that?
19:45:25 <fons> lispy, let my paste an example to you
19:45:44 <lispy> dons: roll your own IRC bot has the quickcheck stuff?
19:45:46 <dons> scodil: no no. there is . let me find you some...
19:45:51 <dons> lispy: nope...
19:45:59 <dons> ?google Introduction to QuickCheck Haskell
19:46:02 <lambdabot> http://haskell.org/haskellwiki/Introduction_to_QuickCheck
19:46:02 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki
19:46:05 <dons> ^^
19:46:21 <lispy> thanks, my google searches missed that
19:46:29 <dons> ?hoogle unsafeForeignPtrToStorableArray
19:46:30 <lambdabot> No matches found
19:46:35 <dons> ?index unsafeForeignPtrToStorableArray
19:46:35 <lambdabot> bzzt
19:46:39 <dons> silly bot
19:46:47 <dons> ?docs Data.Array.Storable
19:46:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Storable.html
19:46:50 <dons> scodil: ^^
19:47:12 <monochrom> Some magic must have been done to prevent Google from searching.
19:47:32 <fons> what is the List class supposed to do?
19:47:33 <scodil> ah ok. thanks dons
19:47:37 <fons> Lift
19:48:24 <Lemmih> dons: Can I poke you some more about QC--?
19:48:41 <dons> sure. but i might be unresponsive :)
19:48:52 <dons> scodil: also Foreign.Marhall.Array
19:49:02 <lispy> dibblego: does this help you get started writing instances of Arbitrary? http://haskell.org/haskellwiki/Introduction_to_QuickCheck
19:49:05 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki, http://tinyurl.com/fx5ob
19:50:03 <dons> dibblego: btw, if you asked on haskell-cafe@haskell.org, something like: Subject: Help writing Arbitrary instance, and posted the data type.. .you'd get the code real quick :)
19:50:27 <dons> why is lisppaste2 bouncing so much today?
19:51:01 <Lemmih> dons: My qc-- binary generates different assembler output compared to the check code in test2/x86/
19:51:22 <kpreid> dons: dunno, but this time something or other was wedged
19:51:39 <dons> ok.
19:52:03 <dons> Lemmih: that's beyond my qc-- experience.  perhaps try the QC-- list?
19:52:21 <scodil> ok, so, on the subject of ghc optimizations, here's one: lets say "data MyType = MyType Float Int Double" and I've made MyType an instance of Storable.  Now, if I create a StorableArray of MyTypes, how will ghc box the values? Will they be completely and utterly unboxed, or just unboxed values of MyType containing boxed Ints, Floats and Doubles
19:52:58 <dons> so you want to know how the marhsalling works?
19:53:09 <Lemmih> dons: Could you try: mk test && diff test2/src/hello.s test2/x86/hello.s?
19:53:13 <dibblego> dons, probably :) but that's cheating
19:53:20 <dons> scodil, Storable unboxes everything, afaik.
19:53:30 <scodil> cool
19:53:31 <dons> scodil: but check the definiton of the Storable instances for the exact route taken
19:53:38 <lispy> does this page have edit links for anyone else?  I only have the "Edit this page" link at the bottom
19:53:40 <lispy> http://haskell.org/haskellwiki/Introduction
19:53:41 <dons> (its translating them into C structs, in essence)
19:53:42 <lambdabot> Title: Introduction - HaskellWiki
19:53:50 <dons> Lemmih: I don't have a working qc-- on my box atm.
19:53:50 <dibblego> lispy, maybe if I took another look - I was going off the GHC source as examples
19:53:58 <Lemmih> dons: Oh, OK.
19:54:15 <dons> Lemmih: haven't used it since we wrote the C-- pretty printer  in ghc.
19:54:29 <dons> lispy: full of edit links for me
19:54:49 <dons> my guess, lispy, you're not logged in? or firefox is hiding them (did you twake your prefs?)
19:54:49 <lispy> dons: hmm..yeah i see it turned off in my prefs
19:54:51 * lispy fixes it
19:54:53 <dons> lispy: what happens in w3m?
19:55:01 <lisppaste2> fons pasted "Template haskell example" at http://paste.lisp.org/display/28963
19:56:16 <lispy> ah that does fix it
19:56:18 <lispy> phew
19:56:25 <lispy> fons: looking now
19:56:29 <fons> lispy, thats a piece of the code I get this error: No instance for (Lift Descriptor)
19:56:33 <dons> ok. and both those Joy articles are < 2004 :/
19:57:03 <fons> lispy, the thing is instantiating Descriptor is a loooooot of work (cause I have to instantiate many other types)
19:57:21 <monochrom> Ha, now I fixed mine too.  (pref, section edit)
19:57:25 <fons> lispy, do you thing there is a easier way so that I can avoid the instantiation?
19:57:29 <fons> think
19:57:42 <lispy> fons: well, you could use drift instead
19:58:01 <fons> drift?
19:58:03 <lispy> fons: is the problme in the string "descriptor_function" ?
19:58:03 <dons> yeah, use DrIFT. that's an easier approach -- if it works
19:58:06 <dons> ?where DrIFT
19:58:06 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
19:58:07 <lispy> ?where drift
19:58:07 <lambdabot> http://repetae.net/john/computer/haskell/DrIFT/
19:58:26 <dons> fons: it derives instances for you
19:58:37 <lispy> fons: i have no idea what the Lift class is
19:58:50 <lispy> fons: maybe you need to be making instances of Lift?
19:58:51 <dons> but you can't derive Lift instances in Drift
19:58:59 <dons> (though you could extend it to do that)
19:59:09 <lispy> what is Lift?
19:59:16 <dons> the class of liftabe things in TH
19:59:27 <dons> i.e. types that can be reflected into values
19:59:38 <dons> sorry, code that can be reflected into AST
19:59:43 <dons> ?hoogle Lift
19:59:44 <lambdabot> Language.Haskell.TH.Syntax.Lift :: class Lift t
19:59:44 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
19:59:44 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
19:59:52 <lispy> dons: so, did you look at fons example?
19:59:57 <dons> not yet...
20:00:05 <lispy> dons: i don't even se a Descriptor type mentioned
20:00:19 <lispy> oh there it is, in the sig of descListFunction
20:00:36 <dons> hmm. maybe TH is still a better way. not sure, need more info
20:00:40 <lispy> fons: i think we need to see more code
20:00:40 <fons> lispy, i can paste the whole source file but it is a bit crappy now
20:00:48 <fons> ok hold on a sec :)
20:00:53 <dons> might be interesting enough that it'd be worth pasting to haskell-cafe@haskell.org, in fact.
20:02:20 <lispy> dons: so is this "How to write a Haskell Program" a tutorial on writing a program or settingup and managing a project?
20:02:37 <lisppaste2> fons pasted "Template haskell in LADSPA" at http://paste.lisp.org/display/28964
20:02:53 <fons> the code is really dirty :S
20:03:28 <lispy> ah your Descriptor type is kinda tricky huh?
20:03:31 <fons> look for  exportStatement
20:03:54 <lispy> you have all these 'forall' thingies
20:04:01 <lispy> i bet that's breaking TH
20:04:20 <fons> lispy, the thing is I need lists of descriptors which might have different id parameters (heterogeneous lists)
20:05:04 <fons> cause a plugin source file can be formed of different plugins which have different Descriptors
20:05:18 <dons> lispy:best practice for creating a new project.
20:05:30 <dons> such that it will have the best chance of being widely used and accepted by the community
20:05:36 <lispy> fons: but it seems that only the field _implementationData varies
20:06:01 <dons> hmm, ghc head's been busy, Shall I pull this patch? (1/426)
20:06:03 <fons> lispy, yes, that one and hd in Instance
20:06:21 <lispy> dons: nice
20:08:35 <lispy> fons: i'm not sure the approach your taking works well in practice, i know i haven't had much success with it
20:09:34 <lispy> but, i really need to work on other stuff at the moment
20:09:44 <fons> lispy, what would you suggest?
20:09:46 <fons> ok then
20:09:51 <fons> thanks anyway
20:09:51 <dons> fons: i'd recommend querying haskell-cafe, the mailing list, with the design problem you've got
20:10:20 <fons> dons, I was planning to do that, but I wanted to give a solution first
20:10:21 <dons> you're likely to find someone with particular experience trying to do what you're looking at
20:10:25 <dons> yeah good idea.
20:10:51 <fons> as usuall I chose something maybe too difficult to begin with :)
20:11:00 <dons> heh
20:11:02 <fons> plugin library in haskell
20:11:17 <lispy> fons: well, one appoarch would be to create these types the 'normal' way with a type parameter and then when you do need to put them in a list, then wrap them up in a hetorgeneous way...ie, push the heterogenous problem up a lewel
20:12:33 <lispy> i don't know the correct term but it seems to me that these "free types" as you're using should be isolated
20:12:50 <lispy> have them exist in a way that is orthogonal and only in a small part of the code
20:12:52 <fons> lispy, tried that already, but the existential quantification is sticky, You mean data DescriptorH = forall id.Descriptor id?
20:12:59 <lispy> because they don't seem to play well
20:13:06 <lispy> no
20:13:12 <lispy> Descriptor a = ...
20:13:25 <lispy> and at some later time you create a wrapper
20:13:51 <fons> lisppaste2, yes, I was trying to write the wrapper, my example assumes there is a data Descriptor id = ... somewhere
20:14:02 <lispy> ah okay
20:14:02 <fons> ops, lispy I meant, don't use to talk to bots
20:15:04 <lispy> existential types or whatever just don't seem to play well with other things
20:15:39 <fons> anyway, my problem now is exportStatement
20:16:07 <dons> lispy: oh they're not so bad. there are worse things. FDs ...
20:16:22 <dons> implicit params and impredicativity..
20:16:50 <dons> at least existentials are very well understood and conceptually pretty simple (except for the head-exploding pattern matching)
20:17:09 <lispy> yeah, despite my best efforts i still can't get OOHaskell to work unless the code is all compiled together (it should work even if HList is a library in a separate package)
20:17:12 <dons> fingers crossed....
20:17:12 <dons> ?ghc
20:17:13 <lambdabot>  Malformed constructor signature
20:17:14 <dons> close
20:17:40 <fons> http://hackage.haskell.org/trac/haskell-prime/ticket/26
20:17:43 <lambdabot> Title: #26 (add ExistentialQuantification) - Haskell Prime - Trac, http://tinyurl.com/y3n4wh
20:26:43 <fons> dons, any suggestions regardingmy example of template haskell? Drift doesn't seem t be able to derive Lift because of the [| |] syntax
20:27:23 <dons> yeah, I don't think DrifT knows about TH.
20:30:10 <fons> I'm not an expert but I don't find the advantage of TH just for creating macros
20:31:39 <dons> its rarely used.
20:32:01 <dons> far more often you'l just roll a lazy function to do the most common forms of macro handling
20:32:25 <dons> for actual code generation, TH is used maybe 20% of the time, or a small preprocessor using Language.Haskell is used instead
20:32:28 <dons> or DrIFT
20:32:48 <dons> maybe TH is more common than that, actually. but its not really really common.
20:33:13 <edwardk> i mostly use template haskell when i need to derive a few hundred instances of something =)
20:33:19 <dons> yeah
20:33:27 <dons> though even there DrIFT is an option
20:33:38 <lispy> it doesn't exist yet, but how does this sound: http://www.codersbase.com/index.php/DarcsSim
20:33:39 <dons> for non-typeclass code generation, TH is just about essential
20:33:40 <edwardk> i also use it when i need to do just a bit more than i can get away with in normal haskell with clean syntax
20:34:51 <lispy> mm...i need to get those wiki urls fixed
20:35:00 <lispy> i don't really like having the index.php in theer
20:35:09 <edwardk> for instance $(binE 65536) rather than O (O (O (O (... (I Z )... ))))
20:35:10 <dons> sounds like a nice tool
20:35:40 <lispy> dons: yeah, we'll see how motivated i really am :)
20:35:45 <dons> heh
20:35:47 <lispy> i can't even finish the damned midterm :)
20:35:53 <edwardk> sorry if i steered you a bit wrong for your purposes fons
20:36:16 <edwardk> lispy: bah you don't need to finish the midterm you need to finish helisp ;)
20:36:24 <lispy> edwardk: gah!
20:36:29 <lispy> edwardk: you're evil :)
20:36:37 <edwardk> everytime i see that i think: helisp and the masters of the universe
20:36:49 <lispy> heeh, yeah, intentionally bad name :)
20:37:07 <lispy> it's predecessor was UCL for unbearably crappy lisp
20:37:08 <fons> edwardk, I think it's a good idea but I'm stuck
20:37:24 <edwardk> fons: what are you trying to do?
20:37:49 <fons> edwardk, just a macro to export a function given a list
20:38:07 <edwardk> ok, what does the list contain?
20:38:07 <fons> see http://paste.lisp.org/display/28963
20:38:15 <lispy> okay, now to finis the reading for this week
20:38:17 <edwardk> and what should the function look like when its done if you could write it?
20:38:28 <fons> look for "[d|"
20:39:59 <edwardk> ok, so you have a list of Descriptors named foo, and you want $(exportStatement foo) to autogenerate the ffi stuff?
20:40:37 <fons> yep
20:40:42 <fons> edwardk, exactly
20:40:55 <edwardk> trying to parse this. do you have any more context than the paste?
20:40:55 <fons> just that
20:41:35 <ion-cannon> ok where on the ICFP pages can I see the results, eg the program htat won?
20:41:43 <ion-cannon> I see the team who won
20:41:43 <edwardk> my honest recommendation is to forget the [d| |] sugar and start working with the Q monad directly, retrofit the [d| sugar after if you must.
20:41:44 <edwardk> hrmm
20:41:47 <ion-cannon> but no the program
20:41:56 <fons> edwardk, yep http://paste.lisp.org/display/28964
20:42:01 <edwardk> ion-cannon: well its not one program, this year there were tons of steps to complete
20:42:16 <fons> edwardk, don't get scared with the code
20:42:20 <ion-cannon> so how was that team judged the winner?
20:42:25 <edwardk> fons: wasn't planing on it =)
20:42:33 <edwardk> ion-cannon: read the rules, its actually quite ingenious.
20:42:41 <ion-cannon> right abck
20:42:55 <lispy> ion-cannon: well, for one, by scoring more points than the judges had deemed possible :)
20:42:58 <edwardk> ion-cannon: they downloaded the codex, wrote a universal machine implementation for it, then tried to solve the puzzles and reported their results.
20:43:18 <edwardk> ion-cannon: the coolest ICFP ever =)
20:43:26 <cjeris> ion-cannon: try it -- you can write a UM in a couple hours in C.  it's quite an ingenious puzzle.
20:43:46 <edwardk> hell you could probably download my C UM from dons' site
20:44:03 <lispy> would be fun to write the UM in asm actually :)
20:44:14 <cjeris> edwardk: well, it's a C program so simple even I can write it :)
20:44:28 <edwardk> cjeris: was figuring if he didn't want to bother =)
20:44:30 <lispy> writing it in postscript would be hard though
20:45:07 <edwardk> fons: first step is you want to generate something like exports :: [Descriptor] -> ExpQ   as the actual signature of the splice.
20:45:09 <cjeris> "And the Judges' Prize this year goes to a team who solved the entire contest on an HP LaserJet..."
20:45:28 <edwardk> cjeris: actually it went to carl witty who did the whole thing himself ;)
20:45:45 <edwardk> cjeris: and still was in like the top 5 or so
20:45:56 <lispy> cjeris: the hosting school did actually write a UM in postscript, but it lacked input capabilities :)
20:46:09 <edwardk> 4939 points solo
20:46:14 <cjeris> lispy: that's what front panel buttons are for :p
20:47:01 <ion-cannon> wow interesting
20:47:08 <ion-cannon> what programming languages were present?
20:47:20 <lispy> ion-cannon: pretty much everything
20:47:26 <lispy> ion-cannon: from assembly to haskell
20:47:28 <edwardk> ion: just about everything, there is a video on youtube or google video that someone took
20:47:43 <dons> ion-cannon: gschuett i presume?
20:48:13 <edwardk> but the video lags a few seconds behind the audio - if you want to see the result presentation its worth watching, but if you want to play with the codex i recommend you do it a bit by yourself before you watch the video
20:48:15 <ion-cannon> hey
20:48:17 <edwardk> coz the video is a total spoiller
20:48:19 <edwardk> er spoiler
20:48:32 <ion-cannon> what is it nown as in u tube?
20:49:21 <dons> i mean, i'd recognise that semi-incoherent typing style anywhere
20:49:31 <edwardk> ah its only on google video
20:49:44 <edwardk> http://video.google.com/videoplay?docid=6419094369756184531&q=ICFP
20:49:51 <lambdabot> Title: ICFP programming contest 2006 results - Google Video, http://tinyurl.com/yynvz6
20:50:58 <desrt> dons; know much happy, by chance?
20:51:08 <dons> a little
20:51:19 <desrt> i'm having a shift/reduce conflcit that's resolving the wrong way
20:51:20 <ion-cannon> wow a cute female hacker was in the crew
20:51:22 <lispy> is gschuett a good thing?
20:51:31 <dons> lispy: proton-torpedo...
20:51:35 <lispy> oh....
20:51:36 <ion-cannon> I'm mostly harmless
20:51:47 <dons> ion-cannon: be _very_ good. and on topic...
20:52:03 <ion-cannon> understood, may I ask a web question?
20:52:03 <desrt> http://desrt.mcmaster.ca/parser/Parser.y
20:52:18 <desrt> ^ even if i change to '%right APPLY' function application left-associations
20:52:33 <dons> desrt: are you using the -i flag to happy, to get .info files generated?
20:52:37 <desrt> no i am not
20:52:42 <dons> ion-cannon: haskell questions preferred, thanks.
20:52:47 <dons> desrt: try it out :)
20:53:00 <desrt> this ICFP video sure is choppy
20:53:52 <dibblego> ?check \a -> lines (unlines a) == a
20:53:55 <lambdabot>  Falsifiable, after 376 tests: ["\905810\1037004\967283\961644\872522\467956\...
20:54:02 <dibblego> wtf is that?
20:54:05 <ion-cannon> is the BDK the resulting program from the winners?
20:54:19 <dons> that's from last year's contest
20:54:35 <palomer> @type \a -> lines (unlines a) == a
20:54:36 <lambdabot> [String] -> Bool
20:54:46 <dibblego> > ""\905810"
20:54:47 <lambdabot>  Parse error
20:54:49 <dibblego> > "\905810"
20:54:49 <lambdabot>  Character constant out of range
20:54:50 <dons> ?check \a -> lines (unlines (a ++ "\n")) == a
20:54:51 <lispy> ?check \a -> init (lines (unlines a)) == a
20:54:51 <lambdabot>  Couldn't match `String' against `Char'
20:54:52 <lambdabot>  Falsifiable, after 0 tests: [""]
20:54:59 <dons> ?check \a -> lines (unlines (a ++ "\n")) == a ++ "\n"
20:55:00 <ion-cannon> So were there any decent like Ocaml people there this time? OCAML seesm to have won a LOT in the past
20:55:00 <lambdabot>  Couldn't match `String' against `Char'
20:55:21 <dibblego> what is that value that was false?
20:55:23 <dons> ion-cannon: ok. see that's borderline. at least do your research first.
20:55:40 <lispy> dibblego: for some (in my opinion stupid) reason lines . unlines /= id, because lines adds an extra newline
20:55:59 <dibblego> lispy, that's what I thought, so I'm trying to find a case
20:56:10 <dons> lispy: i agree. if there was a quickcheck when that function was formulated, likely unlines . lines == id
20:56:17 <lispy> dibblego: most likely ou want intercalate
20:56:33 <dibblego> I just want to understand that ?check output
20:56:48 <lispy> oh well, the randomly generated characters were not so hot
20:56:52 <dibblego> > "\905810\1037004"
20:56:52 <lambdabot>  Character constant out of range
20:56:54 <lispy> > chr 1222
20:56:55 <lambdabot>  '\1222'
20:57:08 <dibblego> ?type chr
20:57:10 <lambdabot> Int -> Char
20:57:15 <dons> oh, the maxBound might be on the wrong type.
20:57:22 <dibblego> > '\905810'
20:57:22 <lambdabot>  Character constant out of range
20:57:42 <desrt> dons; this gives me some interesting insight into the brain of happy
20:57:45 <dibblego> it makes no sense to give a value that is false, yet that value does not exist
20:57:51 <dons> instance Arbitrary Char where
20:57:51 <dons>     arbitrary     = choose (minBound, maxBound)
20:57:51 <dons>     coarbitrary c = variant (ord c `rem` 4)
20:58:12 <dons> > chr 905810
20:58:13 <lambdabot>  '\905810'
20:58:39 <dibblego> ?check \a -> unlines (lines a) == a
20:58:40 <lambdabot>  Falsifiable, after 0 tests: "\28296\1059206\1045993"
20:59:04 <palomer> yay for unicode
20:59:10 <edwardk> fons: you have to do this in two splices it seems you have 2 DecQs and an ExpQ, you can merge the DecQs into one [DecQ] but not with the ExpQ
20:59:16 <dibblego> are there any simpler cases that demonstrate the fact?
20:59:17 <lispy> dons: for this particular set of functions (lines, unlines) you'd probably want to newtype Lines = Lines String, and do a different arbitrary instance that generates from 'a', 'Z' (or is it 'A' to 'z') plus newlines and spaces
21:00:01 <lispy> > unlines . lines $ "Ha, this is an example" == "Ha, this is an example"
21:00:02 <lambdabot>  Couldn't match `String' against `Bool'
21:00:06 <dons> ?check \xs -> unlines (lines (xs ++ "\n")) == id (xs ++ "\n")
21:00:08 <lambdabot>  OK, passed 500 tests.
21:00:10 <lispy> > (unlines . lines $ "Ha, this is an example") == "Ha, this is an example"
21:00:11 <lambdabot>  False
21:00:22 <edwardk> can you use the ffi to export a function from another module?
21:00:28 <dibblego>  > (unlines . lines $ "Ha, this is an example")
21:00:31 <fons> edwardk, which one is the ExpQ?
21:00:32 <dibblego> > (unlines . lines $ "Ha, this is an example")
21:00:33 <lambdabot>  "Ha, this is an example\n"
21:00:50 <edwardk> fons: descriptorFunction = descListFunction descriptors
21:00:54 <lispy> > (\x -> (unlines . lines $ x) == x) "so\nis\nthis"
21:00:55 <lambdabot>  False
21:00:57 <edwardk> fons: rebuilding it at the moment locally
21:01:07 <lispy> > (\x -> (unlines . lines $ x) == x) "but\nnot\this\n"
21:01:08 <lambdabot>  True
21:01:11 <fons> edwardk, that's not a declaration?
21:01:18 <fons> edwardk, thanls :)
21:01:24 <fons> thanks
21:01:32 <lispy> > (\x -> (unlines . lines $ x) == x) "but\nnot\this\n\n\n"
21:01:33 <lambdabot>  True
21:01:41 <lispy> lines "\n\n\n"
21:01:44 <lispy> > lines "\n\n\n"
21:01:46 <lambdabot>  ["","",""]
21:01:49 <lispy> oyi
21:01:53 <edwardk> fons: lemme get something similar to compile
21:02:03 <lispy> that just shows lines/unlines were poorly designed
21:02:18 <lispy> > unlines ["", "", ""]
21:02:19 <edwardk> fons: ah actually it might be
21:02:19 <lambdabot>  "\n\n\n"
21:02:24 <edwardk> thats good then =)
21:02:45 <fons> edwardk, I think it is cause it's a function definition
21:02:50 <lispy> > concat . intersperse '\n' ["", "", ""]
21:02:50 <lambdabot>    Expecting a function type, but found `[a]'
21:02:51 <lambdabot>    Expected type: a1 -> [[...
21:02:51 <edwardk> fons: yeah it is
21:03:06 <fons> a expression would be the LHS or RHS of the definition
21:03:06 <lispy> > concat . intersperse "\n" ["", "", ""]
21:03:06 <lambdabot>    Expecting a function type, but found `[a]'
21:03:07 <lambdabot>    Expected type: a1 -> [[...
21:03:07 <edwardk> fons: my mistake based on how i usually use TH.
21:03:12 <lispy> bleh, you get the idea :)
21:03:16 <lispy> i'll stop spamming people
21:03:55 <monochrom> I want ham and egg and cheese and omlette and lettuce and tomatoes.
21:04:21 <lispy> monochrom: okay, give me your address, i'll send some right over
21:07:01 <monochrom> Dept of Computer Science, U of Toronto, 10 King's College Road, Toronto, Ontario, Canada, M5S 3G4
21:08:45 <desrt> math, logic, science, physics
21:09:51 <lisppaste2> edwardk annotated #28964 with "a quick stab at fons' problem" at http://paste.lisp.org/display/28964#1
21:10:17 <edwardk> i'd need to actually be able to test compile that to fix whatever bugs it has though =)
21:10:48 <edwardk> er and i can already see a problem =/
21:11:11 <edwardk> nevermind that =)
21:12:08 <edwardk> the problem is you are passing something at compile time that doesn't exist at runtime in its current form.
21:12:47 <edwardk> you could make exports take a list of strings that were names of descriptors for instance
21:14:41 <dibblego> is there something like a Ord a => a -> [a] -> Bool that will do a binary search on a sorted list?
21:14:54 <fons> edwardk, it will exist at compiletype for the module which imports it
21:15:07 <fons> time
21:15:16 <fons> (I'm so tired that I cannot even type
21:15:20 <dons> dibblego: Data.Map :)
21:16:28 <dons> ?type M.lookup 2 (M.fromList [(1,'a'), (2,'b'), (3,'c')]) :: Maybe Char
21:16:29 <lambdabot> Couldn't find qualified module.
21:16:40 <dons> > M.lookup 2 (M.fromList [(1,'a'), (2,'b'), (3,'c')]) :: Maybe Char
21:16:41 <lambdabot>  Just 'b'
21:22:30 <desrt> so happy is getting really quite confused by my grammar
21:25:05 <desrt> it goes from state 0, through a natural number, to a state that contains a rule for "else"
21:25:08 <desrt> ...
21:25:13 <dibblego> ?hoogle (a -> a -> Bool) -> (a -> [a] -> Bool)
21:25:14 <lambdabot> No matches, try a more general search
21:25:32 <mbishop> ?where hoogle
21:25:32 <lambdabot> http://www.haskell.org/hoogle
21:25:49 <fons> edwardk, the thing is you cannot use [d| ] with declarations which are individually incorrect
21:37:58 <desrt> i think i've fixed my parser
21:38:00 <desrt> oh joyous day!
21:38:06 * desrt is happy!
21:39:10 <cjeris> > foldl (+) 0 $ map (\x -> x * x) [1..10]
21:39:11 <lambdabot>  385
21:39:13 <dibblego> is there a "also see" annotation for haddock?
21:40:35 <dons> for linking to urls?
21:41:59 <dibblego> yes
21:42:11 <dibblego> I see I can do "also look at 'f'"
21:42:20 <dibblego> oh wait, never mind
21:42:33 <monochrom> No correspondence to Java's @see
21:42:47 <dibblego> on that note, how do I get rid of: the following names could not be resolved: String IO Ordering
21:43:03 <dibblego> I assume I provide a URL to the base documentation
21:43:14 <dibblego> can that be done through cabal somehow?
21:43:26 <monochrom> Don't get rid of them. Ignore them.  They don't cause trouble.
21:44:00 <dibblego> I figure I can link to http://haskell.org somehow
21:44:03 <lambdabot> Title: Haskell - HaskellWiki
21:44:21 <monochrom> There may be a way. I forgot.
21:44:40 <cjeris> w00t, only 2 more failing tests
21:44:46 <dibblego> I fiddled around for a while with haddock directly and with cabal to no avail
21:44:49 <dons> oh, the ruby guys found out about the haskell solns to the ruby quiz. http://tinyurl.com/yxofjl they seem like a reasonable bunch of people
21:44:54 <lambdabot> Title: Google Groups: comp.lang.ruby
21:45:27 <dons> i wonder if we can find more overlap between the two communities (i like the way the ruby guys seem to inspire a love of beautiful coding, that's a good attribute shared with us, i think)
21:46:18 <desrt> it's extremely easy to accidentally write infinite loops in lambdacalc once the y combinator gets involved
21:48:54 <lispy> dons: take advantage of the fracture!
21:49:31 <lispy> dons: i think you have a good point, but haskell isn't overly OO which ruby is a very OO language so... maybe they will turn up their noses at FP
21:50:34 <edwardk> there doesn't happen to be any convenient haskell code for doing the unicode NFKC conversion lying around is there?
21:51:37 <edwardk> (unrolling diacritics into separate codepoints, then rolling them back in, useful as a normal form for comparing unicode text in a more meaningful manner than codepoint by codepoint)
21:51:41 <monochrom> I turn up my noses at OO :)
21:52:06 <edwardk> at near as i can tell ghc has a pretty primitive notion of unicode
21:52:38 <monochrom> probably no such code written yet
21:52:46 <edwardk> ah well, ok, getting hacking =)
21:53:01 <dibblego> when I specify Build-Depends: base, QuickCheck in my package.cabal, it cannot find Test.QuickCheck, yet I thought it was built-in to GHC?
21:53:04 <dons> did people know about this, http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/7f3c1fd7d6c906aa RType
21:53:07 <lambdabot> Title: Google Groups: comp.lang.ruby, http://tinyurl.com/ymxzta
21:53:09 <jcreigh> lispy: I've used Ruby, and it's currently my language of choice from scripting-type tasks. Ruby's blocks pretty much sold me on the value of first class functions + closures.
21:53:10 <dons> (though i can't find the actual page)
21:53:24 <jcreigh> s/from/for/
21:53:31 <dons> jcreigh: know anything about RType, the Haskell implementation of Ruby?
21:53:36 <edwardk> though i guess if i have to write it myself going NFKD, more characters, same normalization properties
21:53:51 <lispy> dibblego: run configure again
21:54:10 <jcreigh> dons: no, never heard of it. *googles*
21:54:15 <dibblego> lispy, duh thanks
21:54:20 <dons> see the above link
21:54:39 <desrt> foogle getArgs
21:54:44 * desrt scratches head
21:54:54 <dons> "Hi. I've released RType 0.2 today.
21:54:55 <dons> RType is another Ruby interpreter written in Haskell."
21:54:56 <desrt> ?foogle getArgs
21:54:57 <lambdabot> Maybe you meant: google hoogle
21:55:03 <desrt> ?hoogle getArgs
21:55:03 <lambdabot> System.getArgs :: IO [String]
21:55:04 <desrt> right!
21:55:23 * desrt suffers [fgh] confusion
21:55:59 <dons> can anyone add any other compilers and interpreters to this list? http://haskell.org/haskellwiki/Libraries_and_tools/Compilers_and_interpreters
21:56:03 <lambdabot> Title: Libraries and tools/Compilers and interpreters - HaskellWiki, http://tinyurl.com/ye98mq
21:56:11 <edwardk> leave it to cpan =)
21:57:33 <dibblego> how do you back out of a Setup.hs install?
21:58:18 <desrt> is there a getopt workalike for haskell?
21:58:35 <desrt> ?hoogle getOpt
21:58:36 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
21:58:36 <lambdabot> Distribution.GetOpt :: module
21:58:36 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
21:58:42 <desrt> score.
21:58:51 <dibblego> Setup.hs install puts these files in places - is it intended that you delete them manually?
21:58:57 <Lemmih> dibblego: Don't use that one.
21:59:06 <dibblego> Lemmih, don't use install?
21:59:17 <Lemmih> dibblego: Sorry, I meant desrt.
21:59:25 <Lemmih> desrt: Don't use that one.
21:59:36 <desrt> Lemmih; something better?
21:59:41 <Lemmih> @docs System.Console.GetOpt
21:59:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
21:59:50 <desrt> thx.
22:08:04 <lispy> dibblego: maybe use ghc-pkg to remove things that you cabal installed?
22:08:45 <dibblego> ghc-pkg unregister?
22:08:53 <lispy> i forget exactly
22:08:58 <lispy> i think there is a remove as well
22:09:01 <dibblego> ok ta
22:09:25 <dibblego> I don't see a remove fwiw
22:09:37 <lispy> okay, iirc unregister doesn't delete anything
22:09:52 <lispy> so if you actually want to clean up the filesystem, you may have to do that manually at this point
22:09:57 <dibblego> righto
22:10:25 <lispy> but, cabal has features i've never tried, so maybe it can do it
22:10:58 <lispy>   unregister    Unregister this package with the compiler.
22:11:07 <dibblego> yeah I tried that
22:11:10 <monochrom> manual delete of files
22:11:10 <fons> edwardk, managed to do it
22:11:12 <fons> :)
22:11:29 <lispy> fons: congrats
22:11:42 <lispy> dons: i added helisp to that page even though helisp is infantile at the moment :)
22:12:04 <lispy> ?where+ helisp http://www.codersbase.com/index.php/helisp
22:12:04 <lambdabot> Done.
22:12:19 <fons> now the users of the macro are forced to declare the [Descriptors] as descriptors so that the macro works ...
22:13:08 <lispy> fons: because of some higher rank polymorphism or something?
22:13:33 <dons> lispy: cheers
22:13:56 <lispy> dons: at the moment, i'll do just about antyhing to avoid the real work i should be doing....
22:14:00 <fons> lispy, just because I don't know how to look for the variable name
22:14:03 <fons> :)
22:14:22 <lispy> fons: you need to 'reify'
22:14:32 <fons> reify?
22:14:45 <lispy> yeah, that's what they call it when you convert the incoming code to an AST
22:15:07 <dons> lispy: heh
22:15:09 <lispy> then you sould be able to inspect the AST
22:16:40 <fons> than ks lispy
22:24:13 <lisppaste2> fons annotated #28964 with "working version (not general enough yet)" at http://paste.lisp.org/display/28964#2
22:24:26 * lispy peeks
22:25:06 <lispy> fons: so what's up with that one?
22:25:14 <lispy> fons: what do you need the name of?
22:25:31 <lispy> n <- newName "descriptorFunction" ?
22:26:01 <lispy> oh i bet we can make this simpler
22:26:03 <fons> lispy, now the "macro" only works if descriptors is defined in the module
22:26:27 <lispy> what is descriptors?
22:26:33 <lispy> shouldn't that be desc?
22:26:45 <fons> lispy, actually yes
22:26:59 <lispy> VarE . mkName, i think this has a simpler form, hang on
22:27:04 <fons> but I don't know how to look for the name of descs
22:27:21 <fons> of the argument given to the macro
22:27:50 <fons> (if it's possible to obtain)
22:27:53 <lispy> well, i used this, varE (mkName name)
22:29:21 <lispy> fons: have you been here? http://www.haskell.org/hawiki/TemplateHaskell
22:29:22 <lambdabot> Title: TemplateHaskell - The Haskell Wiki
22:32:12 <araujo> helu
22:32:16 * araujo can't sleep!
22:34:02 <lispy> lamd = do {info <- reify tname; foldE $ extractType info}
22:35:11 <lispy> fons: i like this guide http://nix.cs.uu.nl/dist/courses/sgc-report-unstable-latest/manual/chunk-chapter/templatehaskell.html
22:35:14 <lispy> fons: esp. at the end
22:35:15 <lambdabot> Title: Chapter 10. Template Haskell, http://tinyurl.com/y3fwxt
22:35:28 <dibblego> does anyone happen to have http://lml.ls.fi.upm.es/~jjmoreno/prog_dec/haskell_EN_read_show.pdf handy?
22:35:38 <dibblego> or an IP address for lml.ls.fi.upm.es ?
22:36:01 <fons> dibblego, how did you get there?
22:36:10 <fons> its my uni at spain
22:36:10 <dibblego> fons, google - no cache
22:36:25 <dibblego> fons, http://www.google.com.au/search?q=%22instance+read%22+haskell
22:36:30 <lambdabot> http://tinyurl.com/y97koj
22:36:34 <lambdabot> Title: "instance read" haskell - Google Search, http://tinyurl.com/sdnoo
22:36:35 <dibblego> trying to figure out how to use Read
22:37:10 <araujo> > read "23" :: Int
22:37:11 <lambdabot>  23
22:37:15 <fons> dibblego, my uni is down
22:37:19 <fons> :S
22:37:20 <araujo> @type read
22:37:22 <lambdabot> forall a. (Read a) => String -> a
22:37:23 <lispy> fons: and also this http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
22:37:26 <lambdabot> Title: 7.6. Template Haskell, http://tinyurl.com/y3camx
22:37:26 <dibblego> fons, you don't happen to have a local copy? :)
22:37:45 <fons> dibblego, sorry I don't
22:37:46 <dibblego> or a cached value of the IP address
22:38:26 <fons> lispy, thanks, the first manual is nice
22:38:30 <fons> really nice
22:39:21 <lispy> fons: this one looks good too http://haskell.org/haskellwiki/Template_Haskell
22:39:24 <lambdabot> Title: Template Haskell - HaskellWiki, http://tinyurl.com/y3qu3h
22:39:45 <fons> lispy, I've been trhough it already
22:40:02 <lispy> even bulat's tutorials?
22:40:31 <lispy> this was the tutorial that got me up and running: http://www.haskell.org/hawiki/TemplateHaskellTutorial
22:40:34 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki, http://tinyurl.com/yamyex
22:42:21 <lispy> fons: i'm afraid that you'll have to use a parser to make this more general
22:42:29 <lispy> fons: i'm not certain, but i think that may be the case
22:44:27 <lispy> fons: here is an idea
22:44:48 <lispy> fons: you could use some template haskell to create a type which holds its name in itself
22:45:12 <lispy> data DescList = DescList String [Descriptior]
22:45:38 <lispy> mmmm...maybe that's no better
22:45:52 <lispy> probably add a string parameter to your function then
22:46:01 <fons> can you have a look at http://nix.cs.uu.nl/dist/courses/sgc-report-unstable-latest/manual/chunk-chapter/templatehaskell.html section  10.3.4 ?
22:46:03 <lambdabot> Title: Chapter 10. Template Haskell, http://tinyurl.com/y3fwxt
22:46:09 <lispy> and then TH should give compile errors if they supply the wrong string
22:46:14 <fons> what the heck is ''tpl_2_1 ?
22:46:24 <desrt> what a day!
22:46:30 <lispy> that asks for the type of variable tpl_2_1
22:46:44 <fons> lispy, is that template haskell?
22:46:48 <lispy> fons: yeah
22:46:51 <lispy> fons: hmm...interesting
22:47:01 <lispy> ah right tname
22:47:10 <lispy> pretty sure that gives the type for that variable
22:48:00 <fons> lispy, now I have it :)
22:48:04 * desrt kicks himself in the head
22:48:04 <lispy> oh?
22:48:23 <desrt> here i was thinking that my lambda calculus interpreter had a serious bug where it would get stuck in infinite loops
22:48:32 <fons> lispy, hold on a sec
22:48:42 <desrt> as it turns out, calculuating the factorial of 10 using church numerals just takes a REALLY LONG TIME
22:49:01 <lispy> desrt: no way!
22:49:05 * desrt only spent like ...hours... trying to chase that one down
22:49:10 <lispy> :)
22:50:39 <arcatan> huh
22:50:39 <desrt> there should be a MaybeIterate
22:50:51 <desrt> :: (a -> Maybe a) -> a -> [a]
22:51:06 <desrt> if it gets just back it adds it to the list and goes again
22:51:09 <desrt> if it gets nothing, the list ends
22:51:11 <lispy> well, nothing is failure in the maybe monad
22:51:20 <fons> lispy, instead of [Descriptors] exports should receive a Name
22:51:30 <fons> and using the quote notation, voila, I have it
22:51:37 <lispy> fons: sweet, paste it
22:51:49 <lispy> ?type mapM
22:51:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
22:52:22 <lispy> desrt: it shouldn't be hard to write iterateM
22:52:27 <lispy> ?type iterateM
22:52:28 <lambdabot> Not in scope: `iterateM'
22:52:33 <lispy> ?hoogle iterate
22:52:33 <desrt> ya.  it'll be totally easy
22:52:34 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
22:53:02 <desrt> no matter though
22:53:08 <edwardk> fons: yeah that was the bit i mentioned before about passing it strings =) i presumed you would use the string to build the Name =)
22:53:16 <edwardk> fons: (just got back)
22:53:26 <desrt> i have a strange single-use for it and it's easier to just write what i want rather than write iterateM and shoe-horn my code into using it :)
22:54:21 <lisppaste2> fons annotated #28964 with "even more general" at http://paste.lisp.org/display/28964#3
22:54:35 <fons> edwardk, I got it!
22:55:10 <edwardk> ah so my slapdash code was useful after all =)
22:55:32 <edwardk> you don't need to return those into the monad btw
22:55:34 <fons> edwardk, the thing is you cannot use the [d| |] notation unless everything you put inside is individually consistent
22:58:07 <fons> another solution would have been creating an instance of Lift Descriptor
22:58:30 <lispy> desrt: i think it needs this type
22:58:31 <lispy> iterateM :: (Maybe a -> Maybe a) -> Maybe a -> [a]
22:58:32 <lisppaste2> edwardk annotated #28964 with "no need to return the first two expressions" at http://paste.lisp.org/display/28964#4
22:59:03 <edwardk> that just keeps you from doing more work in the monad than necessary
22:59:32 <edwardk> fons: yeah the lift thing is kind of a neat idea.
22:59:49 <edwardk> possibly a pain in the ass though
23:00:08 <desrt> lispy; nope
23:00:13 <lispy> iterateM f a = case f a of Nothing -> []; Just x -> x : iterateM f (f a)
23:00:22 <lispy> desrt: that has the type i pasted above
23:00:32 <desrt> lispy; right.  it should be possible to do it with my type though
23:00:34 <fons> then it would be just straightforward to create exports by using [d| ] directly
23:00:37 <desrt> lispy; and it'll be more user-friendly
23:01:14 <lisppaste2> edwardk annotated #28964 with "ah there it is" at http://paste.lisp.org/display/28964#5
23:01:21 <desrt> lispy; why should the function take 'Maybe' as input if it will only ever receive 'Just'?  (since Nothing results in termination)
23:01:46 <desrt> lispy; you might have justification for having Maybe as the starting parameter because then you can have lists of length 0 too
23:02:20 <lispy> well, how do you change f to have type a -> Maybe a
23:02:42 <lispy> iterateM f a = case f a of Nothing -> []; Just x -> x : iterateM f  (f x) -- this doesn't type check
23:02:53 <desrt> just do 'f x'
23:03:02 <desrt> er..
23:03:06 <desrt> bah
23:03:07 <desrt> lemme write it :p
23:03:31 <lispy> ?djinn (a -> Maybe a) -> Maybe a -> [a]
23:03:32 <lambdabot> -- f cannot be realized.
23:03:41 <lispy> ?djinn (Maybe a -> Maybe a) -> Maybe a -> [a]
23:03:42 <lambdabot> -- f cannot be realized.
23:03:48 <lispy> bah
23:03:51 <lispy> ?djinn-env
23:03:52 <lambdabot> data () = ()
23:03:52 <lambdabot> data Either a b = Left a | Right b
23:03:52 <lambdabot> data Maybe a = Nothing | Just a
23:03:52 <lambdabot> data Bool = False | True
23:03:52 <lambdabot> data Void
23:03:54 <lambdabot> type Not x = x -> Void
23:04:03 <lispy> Oh, no lists
23:04:07 <dons> lists
23:04:13 <lispy> ?djinn (Maybe a -> Maybe a) -> Maybe a -> a
23:04:13 <lambdabot> -- f cannot be realized.
23:04:17 <lispy> er
23:04:27 <lispy> no partial functions right?
23:04:31 <dons> ?djinn (Maybe a -> Maybe a) -> Maybe a
23:04:32 <lambdabot> f a = a Nothing
23:04:54 <dons> ?djinn (Maybe a -> Maybe b) -> Maybe a -> b
23:04:55 <lambdabot> -- f cannot be realized.
23:05:05 <dons> ?djinn (Maybe a -> b) -> Maybe a -> b
23:05:05 <lispy> dons: do you know how we could write iterateM :: (a -> Maybe a) -> Maybe a -> [a]?
23:05:06 <lambdabot> f a = a
23:05:24 <lispy> (Maybe a -> Maybe a) -> Maybe a -> [a] was as close as i could get
23:05:26 <dons> that's not iterateM though, is it?
23:05:34 <lispy> M for maybe
23:05:35 <dons> ?type iterate
23:05:36 <lispy> i was lazy
23:05:37 <lambdabot> forall a. (a -> a) -> a -> [a]
23:06:16 <desrt> iterateM :: (a -> Maybe a) -> a -> [a]
23:06:17 <desrt> iterateM func start = start : (case func start of Just x -> iterateM func start Nothing -> [])
23:06:39 <desrt> er.  use your imagination with the whitespace :)
23:06:50 <lispy> hmm..and that works?
23:06:54 <desrt> yup
23:07:02 <desrt> iterateM Just 1 -> [1, 1, 1, 1....
23:07:37 <desrt> it's not a monad, though
23:07:41 <desrt> it's Maybe
23:07:55 <desrt> but this is the function i had in mind
23:09:16 <lispy> right, i just used M because it was understoond we didn't mean Monad here
23:10:35 <desrt> i think i'm in love with my lambda calculus interpreter
23:10:44 <desrt> it seriously kicks your ass
23:10:57 <desrt> i'm almost inspired to write lambdaprelude
23:11:32 <lispy> this definition isn't bad but has the type you don't like
23:11:34 <lispy> \f a -> map fromJust . takeWhile (not.isNothing) $ iterate f a
23:12:06 <desrt> that only works due to lazy evaluation :p
23:12:17 <lispy> aye!
23:12:30 <lispy> the same is true of iterate though
23:13:21 <desrt> i have a better one
23:13:33 <desrt> \f l -> [ x | Just x <- iterate f l ]
23:13:34 <lispy> liftM2 iterate :: (Monad m) => m (a2 -> a2) -> m a2 -> m [a2]
23:13:45 <lispy> that one will be strict
23:13:49 <lispy> i think
23:14:05 <lispy> oh woit
23:14:11 <lispy> nevermind, you don't have a filter
23:14:16 <desrt> :)
23:14:26 <desrt> anyway.. you're right
23:14:28 <desrt> it locks up on me
23:14:33 <lispy> oh...
23:14:48 <desrt> since there's nothing to tell it to stop listing when i hit Nothing
23:17:08 <desrt> hey!  it's weitzman.. the lone hacker!
23:17:18 <lispy> > take 4 $ (\f l -> [x | Just x <- iterate f l]) id (Just 1)
23:17:19 <lambdabot>  [1,1,1,1]
23:17:24 <lispy> not lazy!
23:17:26 <fons> woooooooo it works :P
23:17:34 <lispy> looks lazy to me
23:17:50 <desrt> nope.
23:17:50 <fons> myWierdDescriptorsName = []
23:17:50 <fons> $(exports 'myWierdDescriptorsName)
23:17:56 <desrt> try it on (const Nothing)
23:17:58 <desrt> instead of id
23:18:02 <desrt> watch it crash :)
23:18:03 <lispy> ah right
23:18:14 <lispy> > take 4 $ (\f l -> [x | Just x <- iterate f l]) id (Nothing)
23:18:15 <lambdabot>  Add a type signature
23:18:22 <lispy> > take 4 $ (\f l -> [x | Just x <- iterate f l]) id (Nothing::Maybe Int)
23:18:26 <lambdabot> Terminated
23:18:34 <lispy> > (\f l -> [x | Just x <- iterate f l]) id (Nothing::Maybe Int)
23:18:36 <desrt> or
23:18:38 <lambdabot> Terminated
23:18:52 <desrt> > (\f l -> [x | Just x <- iterate f l]) (const Nothing) (Just "foo")
23:18:56 <lambdabot> Terminated
23:19:04 <desrt> should have given a single ["foo",
23:19:59 <lispy> yeah, filter  is bad
23:20:12 <desrt> you need a takewhile equivalent :)
23:20:31 <lispy> yeah, afaik, list comp. notation doesn't have a takeWhile operator
23:20:57 <lispy> i wonder if you could write a filter that works lazily
23:22:23 <lispy> heeh
23:22:24 <lispy> filter p xs = [k | k <- xs, p k]
23:22:39 <desrt> congratulations.  now try map.  :)
23:22:39 <lispy> i thought list comps. were transformed to filter and friends
23:23:11 <desrt> map f xs = [f x | x <- xs]
23:23:59 <desrt> ok
23:24:05 <desrt> so i'm feeling slightly better about this stupid assignment
23:24:18 <desrt> mostly because it causes me to hang out in #haskell and hone my haskell skillz
23:24:26 <desrt> but now the bad part comes :(
23:24:30 * fons is considering to computer the static data sanity checks of the module with Template Haskell
23:25:01 <fons> but he is now going to bed cause he can barely opoen his eyes
23:25:07 <fons> thanks for your help guys
23:25:16 <desrt> map (\x -> i have to learn a language called x and port my lambda calculus interperter to it) [lua, mercury, scala 2]
23:26:58 <lispy> oh, i'm learning scala too
23:27:07 <lispy> actually scala seems pretty spiffy
23:27:15 <araujo> hah, interesting .. i didn't know there existed a ruby interpreter written in Haskell.
23:27:41 <lispy> Rtype!
23:27:46 <lispy> like that old snes game
23:28:26 <desrt> i get the feeling that all of my transliterations are gonna be very ... functional
23:29:04 <desrt> one thing is for certain: the prof had better not expect parsers/pretty-printers in each language
23:29:34 * desrt will add pretty-printers to the haskell version that target building abstract syntax in the other 3 languages :)
23:35:14 <roconnor> According to most accounts the great depression wasn't so great.
23:53:08 <skew> Frederik Eaton?
23:55:05 <_frederik_> yes
23:55:21 <_frederik_> the electronic version
23:56:33 <skew> Hi. I was thinking I should look at your linear algebra code.
23:56:44 <_frederik_> don't! it's not ready
23:56:59 <_frederik_> why?
23:57:35 <skew> I was writing a simple NURBs evaluator, which gets into lots of stuff with knot vectors and things
23:57:52 <skew> I defined a zipWith that fails when the lists don't match, which ofund many of the bugs
23:58:13 <_frederik_> oh
23:58:55 <_frederik_> http://ofb.net/~frederik/stla/
23:59:11 <dons> you math guys ... at notes to: http://haskell.org/haskellwiki/Haskell_and_mathematics
23:59:15 <lambdabot> Title: Haskell and mathematics - HaskellWiki, http://tinyurl.com/yerb92
23:59:19 <dons> s/add/
23:59:32 <_frederik_> that's an oldish version of the code, but i'm planning to make some (probably minor) incompatible changes
23:59:36 <_frederik_> ok
