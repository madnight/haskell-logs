00:00:07 <Adamant> they hate polymorphic variables?
00:00:27 <Adamant> that's crazy talk
00:00:36 <Irrelevant> is there a de facto standard section for "subtract 1"? I'm thinking (+ -1)...
00:01:30 <lispy> subtract?
00:01:49 <lispy> > subtract 1
00:01:50 <lambdabot>  Add a type signature
00:02:08 <lispy> > 1 (subtract 1)
00:02:09 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a1))
00:02:09 <lambdabot>   In the definitio...
00:02:15 <lispy> > 1 (subtract 1) :: Int
00:02:16 <lambdabot>  add an instance declaration for (Num ((a -> a) -> Int))
00:02:16 <lambdabot>   In the expressi...
00:02:19 <lispy> bleh
00:02:31 <TSC> > map (subtract 1) [1,2,3,4]
00:02:33 <lambdabot>  [0,1,2,3]
00:02:54 <Irrelevant> ?t subtract
00:02:54 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:02:56 <lispy> > (subtract 1) 1
00:02:57 <lambdabot>  0
00:02:59 <Irrelevant> ?type subtract
00:03:00 <lambdabot> forall a. (Num a) => a -> a -> a
00:03:09 <lispy> oh yeah, i had it backwards...duh...
00:03:31 <Irrelevant> I still think having ONE PREFIX OPERATOR is silly
00:03:42 <Irrelevant> unary minus should be called neg or something
00:03:50 <lispy> ?type neg
00:03:52 <lambdabot> Not in scope: `neg'
00:03:55 <int-e> there is negate actually
00:04:02 <Irrelevant> ?type negate
00:04:04 <lambdabot> forall a. (Num a) => a -> a
00:04:19 <Irrelevant> >map negate [0..]
00:04:25 <lispy> what i get ever so sick of is (-1)
00:04:25 <Irrelevant> ..
00:04:33 <lispy> > map negate [0..]
00:04:34 <lambdabot>  [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-2...
00:04:39 <lispy> space matters :)
00:04:44 <Irrelevant> yes, quite, lispy. that's why I was grumbling
00:04:58 <Irrelevant> (also "ahhh" on the space thingy)
00:05:16 <Irrelevant> I'm not sure if i prefer (subtract 1) over (+ -1)
00:05:26 <Irrelevant> mine's shorter :P
00:05:43 <int-e> (-1+) saves a space
00:05:43 <lispy> ?type (+ -1)
00:05:44 <ulfdoz_> btw. when processing an endless list, does the gc finalise parts of it after processing?
00:05:45 <lambdabot>   The operator `+' [infixl 6] of a section
00:05:45 <lambdabot>     must have lower precedence than the operand prefix `-' [infixl 6]
00:05:54 <int-e> oh, and it works, too.
00:06:08 <int-e> > map (-1+) [1,2]
00:06:09 <lambdabot>  [0,1]
00:06:11 <Irrelevant> ?type (-1+)
00:06:12 <lambdabot> forall a. (Num a) => a -> a
00:06:33 <Irrelevant> strange... winhugs parse errors on (-1+)
00:06:36 <lispy> ulfdoz_: it must, how else can you iterate in constant space?
00:06:44 <int-e> Irrelevant: hmm.
00:07:27 <goltrpoat> is the gc behavior specified in the report to any extent, btw?
00:07:38 <lispy> hmm..how do you cleanup after runInteractiveCommand?
00:07:54 <lispy> i'm running out of file handles
00:07:55 <ulfdoz_> lispy: I didn't know, that it works in constant space.
00:08:08 <lispy> ulfdoz_: it can
00:08:26 <goltrpoat> suppose i couldve just looked.  doesn't look like it
00:08:32 <int-e> oh great, unary - and + have the same precedence (judging from the grammar)
00:08:52 <Irrelevant> unary +?
00:08:57 <Irrelevant> > +1
00:08:57 <lambdabot>  Parse error
00:09:05 <lispy> int-e: yeah
00:09:08 <lispy> > (+ -1)
00:09:08 <lambdabot>    The operator `+' [infixl 6] of a section
00:09:09 <lambdabot>     must have lower precede...
00:09:27 <int-e> exp^6 -> exp^7 + exp^7  (because + is infixl 6) and exp^6 -> - exp^7 (special grammar rule)
00:09:39 <lispy> oh wait, that's binary plus...my bad
00:09:43 <int-e> So (-1+) is ambiguous. Yuck. (and (+ -1), too)
00:10:46 <Irrelevant> (+ -1) looks unambiguous to me
00:10:57 <int-e> I'm confused.
00:11:06 <Irrelevant> might it be read as (-) (+) 1 or sth?
00:11:46 <int-e> wait, I quoted that wrong. 'lexp' deals with unary -.
00:11:53 <int-e> http://haskell.org/onlinereport/exps.html
00:11:56 <lambdabot> Title: The Haskell 98 Report: Expressions
00:12:53 <int-e> but actually I should look for the section syntax, bah.
00:17:28 <int-e> I think ghc got it right, and hugs wrong.
00:18:34 <lispy> that's a first
00:18:44 <lispy> oh wait...
00:18:51 <lispy> :)
00:18:52 <int-e> -1 is an lexp^6 and one of the rules for aexp is: aexp -> (lexp^6 qop^(l,6))
00:19:28 <int-e> and + is an infixl 6 so that means (-1+) is an aexp ... a section.
00:20:54 <int-e> while in (+ -1), -1 would have to be an exp^7. which it isn't.
00:21:00 <int-e> this grammar is awful :)
00:23:15 <sieni> ahh, flip const is a good way of inserting documentation to random places
00:23:26 <goltrpoat> haha
00:23:44 <int-e> > seq "this expressions is silly" 42
00:23:46 <lambdabot>  42
00:26:04 <sieni> > sum $ takeWhile (/=0) $ map (\n -> 1 / (product $ (flip const "Yes, the product of [] is 1") [1..n])) [0..]
00:26:06 <lambdabot>  2.7182818284590455
00:26:40 <foxy> dons, skew just pointed out that the Hi stuff will have changed
00:26:48 <dons> yes
00:27:06 <foxy> oh, you said that...
00:27:12 <Irrelevant> @pl (:[])
00:27:12 <lambdabot> return
00:27:17 <Irrelevant> ...WHAT?!
00:27:34 <dons> list monad
00:27:40 <Irrelevant> o god
00:27:44 <dons> :)
00:27:45 <lispy> > return 1 :: [Int]
00:27:47 <lambdabot>  [1]
00:27:48 <Irrelevant> @type return
00:27:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
00:27:56 <dons> remember 'monads as containers'....
00:27:57 <lispy> > (:[]) 1
00:27:58 <lambdabot>  [1]
00:28:06 <Irrelevant> sod it, i'm gonna stick to my robot smiley
00:28:21 <dons> it's sometimes called 'box'
00:28:23 <dons> you could use that too
00:28:33 <dons> ?let box = (:[])
00:28:34 <dons> > L.box 1
00:28:34 <lambdabot> Defined.
00:28:35 <lambdabot>  [1]
00:28:41 <int-e> (:[]) is short and easy enough to understand.
00:28:49 <int-e> imho :)
00:28:54 <dons> bit obscure if you're not a haskell programmer
00:29:06 <dons> (at least that's what i was informed, after using it a lot in one tutorial)
00:29:14 <lispy> heh
00:29:15 <int-e> well, you run into that barrier sooner or later with any non-toy haskell code
00:29:21 <dons> yeah
00:29:41 <dons> 'return' just seems so warm and fuzzy to an outsider ... even though it is cold and spikey
00:30:40 <int-e> that's dangerous
00:30:46 <int-e> it should have a different name ;)
00:30:49 <sieni> (:[]) looks like a weird smiley
00:31:07 <Pseudonym> How about warmFuzzyThing?
00:31:08 <dons> I call it the I'm-gagging-on-TaPL smiley
00:31:14 <Pseudonym> No, that's what we're calling monads.
00:31:18 <dons> yeah
00:31:28 <Pseudonym> I'm kinda partial to "unit".
00:31:35 <dons> unlike arrows, which aren't fuzzy at all
00:31:48 <goltrpoat> pseudo:  won't the ML people get confused
00:31:48 <Pseudonym> "Arrow" isn't a scary name.
00:31:55 <int-e> the warm and fuzzy return is dangerous because of stuff like this: do if Foo then return () else print 2; print 3; return () -- somewhat contrived
00:31:57 <Pseudonym> goltrpoat: They're already confused.
00:31:59 <lispy> i say we call Monads NinjaRobotPirateMonkeies
00:32:02 <goltrpoat> haha
00:32:36 <Pseudonym> (:[]) looks like a ninja robot pirate monkey, actually
00:32:52 <goltrpoat> the NRPM combinator.
00:32:56 <dons> ah yes!
00:32:57 <int-e> Sequencable. Hmm. Necklace. >>= could be called 'thread' and a monad action a pearl.
00:32:58 <lispy> heh
00:33:17 <Pseudonym> int-e: OMG ponies!!1!
00:33:18 <lispy> mmm...functional pearls
00:33:35 <dons> int-e. yes. there should be gems in there
00:33:48 <dons> int-e, thread and pearl are really nice.
00:33:52 <goltrpoat> and the occasional macrame piece.
00:33:52 <dons> I like it!
00:33:58 <goltrpoat> (backtracking)
00:34:04 <lispy> okay, so if i invoke gnu as one way i get valid programs, and another way i get non-terminating programs...now who has the bug? the asm i generate or gnu as?
00:34:27 <Pseudonym> My problem with that is that there are at least three nice ways to think of a monad, and linear computation is only one of them.
00:34:34 <int-e> Pseudonym: ponies? http://www.sinfest.net/archive_page.php?comicID=2208
00:34:37 <lambdabot> Title: Sinfest, http://tinyurl.com/yfpt4m
00:35:35 <Pseudonym> int-e: http://www.e-sheep.com/apocamon/
00:36:24 <goltrpoat> linear computation being a somewhat misleading way to think about it, since you can emulate a CSP-style par/seq/alt/prialt/pripar type deal in a monad.. i think
00:36:48 <goltrpoat> actually.  yeah, sure you can.
00:36:57 <int-e> goltrpoat: it's not a linear computation. it's building blocks that are arranged in a sequential manner - like diagrams on paper would be
00:37:15 <goltrpoat> right, was responding to pseudonym
00:37:21 <Pseudonym> Yeah.
00:37:22 <int-e> goltrpoat: in contrast with arrows which are conceptually less limited.
00:37:28 <lispy> i see the -a option to gas is bad
00:37:44 <Pseudonym> But the thing is, containers (e.g. List) and term substitution systems are also monads.
00:38:46 <goltrpoat> the other two partners at my company spent a good six months occasionally coming back to me and going, "so, what exactly IS a monad?" after i had referred them to about ten separate papers
00:39:03 <Cale> goltrpoat: hehe
00:39:08 <lispy> bulat is interesting...
00:39:09 <goltrpoat> the thing that finally made it click was dumping Maybe, State, and IO into one long conversation, and drawing random parallels between the two
00:39:24 <lispy> he seems to know a lot about optimizing haskell programs
00:39:31 <Cale> lispy: "interesting" indeed :) He has a bit of an odd perspective on things
00:39:59 <lispy> Cale: really?
00:40:08 <int-e> Monads don't do much. With >>= and return alone you can't do anything useful at all.
00:40:14 <goltrpoat> bulat seems to have pretty encyclopedic knowledge of a lot of the low-level stuff
00:40:25 <Cale> He either does a lot of premature optimisation, or he's had to work with very large amounts of data in Haskell :)
00:40:38 <goltrpoat> i think it's the latter
00:40:45 <goltrpoat> he keeps referring to a program he's been writing for years
00:40:52 <lispy> hehe yeah
00:40:57 <lispy> "see my library"
00:41:00 <goltrpoat> hehe yeah
00:41:22 <lispy> he's good to have in the community though
00:41:29 <lispy> i'm not saying i dislike him
00:41:36 <lispy> (just in case anyone gets the wrong idea)
00:41:46 <Irrelevant> foodtime!
00:41:52 <lispy> Irrelevant: !!
00:41:59 <lispy> Irrelevant: bring some back for me
00:42:38 <Cale> Henning and Brian annoy me though :)
00:43:18 <goltrpoat> hulley?
00:43:20 <lispy> ah, i always feel like Udo is a smart guy but that sometimes he's too harsh with people
00:43:37 <Cale> yeah
00:43:42 <goltrpoat> i just wish he'd stop proposing random language features to make his editor look nicer
00:43:48 <Cale> goltrpoat: right
00:44:04 <Cale> Henning and Brian both seem to want to simplify the language at any cost.
00:44:06 <lispy> eh, i just ignore those :)
00:44:09 <dons> hmm, what's he proposing now?
00:44:16 <Cale> recently?
00:44:18 <lispy> Cale: when was Brian trying to simplify things?
00:44:23 <lispy> Cale: i missed that thread ;0
00:44:26 <Cale> heh
00:44:40 <Cale> lispy: Ever since he started writing his editor
00:44:40 <lispy> although, removing vtab is not a bad idea
00:44:59 <dons> Bulat's good with the low level stuff -- he's sent me some useful patches. and now he's getting into haskell more, he's really an asset
00:45:00 <lispy> Cale: well, his proposal for fixity was anything but simpler :)
00:45:07 <Cale> okay, yeah
00:45:11 <int-e> It was scary
00:45:27 <lispy> yeah,  it was like a weird machine learning algorithm
00:45:31 <Cale> "simplify" meaning "make easier to parse, in some bizarre respect"
00:45:38 * lispy <--- cried
00:45:58 <Cale> Whereas Henning seems to just want to remove every little not-entirely-essential feature
00:46:27 <int-e> ok, but that wouldn't be in the Haskell spirit.
00:46:31 <foxy> http://members.iinet.com.au/~bofh -- excuse the non #haskellish nature of this link
00:46:48 <Cale> int-e: recently, he's proposed removing if-then-else
00:46:52 <int-e> (which as I understand was to have a simple core but lots of syntax sugar)
00:46:55 <int-e> I've seen that.
00:47:00 <goltrpoat> hehe yeah i remember that
00:47:14 <int-e> I can't say I really *need* if then else.
00:47:24 <dons> yeah, this isn't lisp. i don't want no stinkin' if (a) (b) (c)
00:47:30 <lispy> hehe
00:47:38 <dons> i'd hate those parens every time , and end up using case..
00:47:44 * lispy was just going to say he often wishes he had that version of if
00:47:57 <int-e> especially since I discovered the power of guards in let ... let x | a = 1 | b = 2 | c = 3 -- this is scary when done on a single line
00:48:14 <dons> fun syntax, eh?
00:48:18 <dons> underappreciated :)
00:48:32 <goltrpoat> irrefutable patterns in single-alternative case statements are fun too
00:48:50 <int-e> because that's a very nice way of expressing if ... then ... else if ... then ... etc.
00:48:53 <Cale> Let's remove guards as well, and just have case ;)
00:49:00 <int-e> ow.
00:49:16 <dons> yeah. case,let,application, lambda and we're done
00:49:25 <foxy> > 1 `subtract` 1
00:49:26 <int-e> Wasn't that suggested, too, by someone writing a compiler?
00:49:27 <lambdabot>  0
00:49:33 <Cale> heh
00:49:43 <lispy> dons: cool, because i mostly have lambdas implemented
00:49:46 <Cale> "I'd be done if only Haskell was my core language!"
00:49:52 <int-e> along with (n+k) patterns of course, and n patterns as well.
00:49:53 <goltrpoat> cale:  bah.  we can encode boolean logic with SKI combinators, right
00:49:58 <int-e> I forgot :)
00:50:05 <goltrpoat> cale:  what else do you need.
00:50:22 <lispy> what is the joke about n+k patterns?
00:50:26 <int-e> goltrpoat: do you know Unlambda?
00:50:40 <lispy> why did spj say he would remove then from ghc for haskell' and then people thought he was serious? :)
00:50:47 <goltrpoat> haha.  doh, didn't even think of that
00:50:47 <lispy> (reference to haskell-workshop)
00:51:03 <goltrpoat> jot would be even more concise!
00:51:10 <goltrpoat> or iota or whatever
00:51:32 <int-e> lispy: I wouldn't mind (n+k) patterns being removed, but n patterns are very useful.
00:52:08 <lispy> i can't think of a time i seriously used n+k patterns
00:52:33 <int-e> http://www.mail-archive.com/haskell@haskell.org/msg01261.html
00:52:36 <int-e> note the date
00:52:37 <lambdabot> Title: n+k patterns, http://tinyurl.com/yn53lb
00:52:40 <lispy> (x:xs) patterns are really good though
00:53:08 <int-e> (the joke is in the PS.)
00:53:32 <lispy> haha
00:53:36 <lispy> oh man, that's good
00:56:38 <dons> yeah, lennart rocks :)
00:57:22 <uebayasi> mmmmmmmmmm, lennart
00:57:43 <goltrpoat> which >= and - DOES it refer to?
00:57:43 <goltrpoat> heh
00:57:58 <goltrpoat> oh.
00:58:32 <goltrpoat> (wadler's response)
01:02:27 <uebayasi> it's really sad his NetBSD developer access was lost :(
01:03:00 <dons> i don't think he minds. he just didn't want to sign the form, he said
01:03:09 <uebayasi> (stopped more precisely)
01:03:14 <dons> but the whole form thing is bizarre
01:03:15 <uebayasi> yeah
01:03:28 <dons> talk about guaranteeing limited developers, oh well.
01:03:48 <uebayasi> the real problem is, no one can touch the USB stack now :O
01:04:24 <uebayasi> (but this is very much irrelevant to haskell, so i stop now ;)
01:04:57 <dons> oh, low bus ratio :/
01:05:08 <dons> yeah, its not good when that happens -- but it does happen. oh well
01:29:25 <goltrpoat> woohoo.  i have pairs.  lists, here i come.
01:36:00 <goltrpoat> er.  k, done, i guess.
01:37:37 <Cale> hehe
01:50:02 <sieni> aaaaargh f*cking emacs, how do I get this "#¤%"#¤%#" DOS mode off.
01:52:30 <dblhelix> sieni: i see that feel quite zenny today :)
01:52:41 <dblhelix> /s/that feel/that you feel
01:53:02 <gds> sieni: set-buffer-file-coding-system ?
01:54:22 <sieni> it seemed to do something
01:54:37 <sieni> how do I disable this stupid dos mode permanently?
01:54:57 <sieni> if there are ^M:s in the file, I want to see them (and nuke them).
01:55:02 <pejo> uebayasi, if there is no explicit owner of the usb-stack, anyone should be free to commit.
01:59:18 <gds> sieni: prefer-coding-system might help - not something I've every done though....
01:59:25 <gds> s/every/ever
02:00:34 <sieni> well, emacs is just such a prime example of extreme suckery
02:00:36 <gds> sieni: http://www.emacswiki.org/cgi-bin/wiki/EndOfLine
02:03:00 <lispy> sieni: fsvo prime, i actually think eclipse is better at extreme suckery :)
02:06:57 <gds> yi will cure all ills :)
02:15:50 <JKnecht> Yi not Li :)
02:16:50 * lispy has a fear of suddenly receiving spam like, "Yi cur3 viagr4 c4lis"
02:17:03 <lispy> no, not yi spam!
02:52:46 <lispy> finally fixed a bug in my compiler that's been there all day!
02:52:50 <lispy> sweetness
02:53:26 * lispy does a regression test just in case
02:57:47 <Patterner> lispy++
02:58:05 <lispy> *Test> runTests allTests
02:58:05 <lispy> 849/849 passed.
02:58:14 <lispy> regression city!
02:58:35 <velco> is there some dynamic translator project for STG machine ?
02:59:03 <lispy> velco: you mean like python for STG?
02:59:10 <velco> for say, nhc or yhc, which seem to be bytecode interpreters
03:00:05 <velco> I mean, these compilers generate bytecode, which is interpreted afterwards. Is there a project for dynamic translation of that bytecode to machine instructions (a.k.a. JIT) ?
03:00:30 <lispy> ah
03:00:32 <lispy> no idea
03:29:25 <Bobstopper> How can I liftIO a function which takes a IO as an argument? eg something like MonadIO m => (IO a -> IO b) -> m a -> m b
03:30:50 * SamB_XP not think you can, exactly
03:32:49 <Bobstopper> poo.
03:34:29 <lispy> > sum [1..1000000]
03:34:31 <lambdabot>  500000500000
03:42:05 * SamB wonders what rts/Typeable.c is for...
03:48:05 <Hekos> > sum [0-10]
03:48:06 <lambdabot>  -10
03:48:13 <Hekos> > sum [0..10]
03:48:14 <lambdabot>  55
03:48:19 <Hekos> > sum [0..5]
03:48:20 <lambdabot>  15
03:48:30 <Hekos> hmm
03:51:03 <ndm> astrolabe: i am about now
03:51:13 * beelsebob pokes ndm 
03:51:23 * ndm licks beelsebob
03:52:14 <dmhouse> Are lambda bindings monomorphic?
03:52:15 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
03:52:16 <dmhouse> If so, why?
03:56:41 <dmhouse> ?tell shapr Can't remember what I pinged you about, never mind.
03:56:42 <lambdabot> Consider it noted.
03:57:22 <SamB> dmhouse: I think it depends on whether you supply a type signature or not
03:57:38 <SamB> well, in vanilla Haskell, they are anyway
04:03:18 <dons> GHC OS continues on its merry way,   * add pure spin locks
04:03:18 <dons>     M ./includes/SMP.h -5 +134
04:04:55 <dmhouse> SamB: so I can do something like (\(x::polymorphicType) ...) polymorphicValue?
04:05:24 <dmhouse> My polymorphicType here is HTML h => h
04:06:30 <dons> GOA> (\(x :: forall a .Num a => a) -> x) 1
04:06:31 <dons> 1
04:10:37 <andrea> may I ask something about character encoding (with hscurses), possibly to dons?
04:10:59 <dons> you may ask :)
04:11:27 <andrea> tnanks..: i'm writing an application with hscurses and there are a couple of things I do not understand...
04:11:48 <andrea> ... if I send an utf8 character hscurses crashes
04:12:21 <andrea> even though it is supposed to use wchars
04:13:08 <andrea> I don't understand if hscurses deals with multibyte characters or not.
04:13:26 <andrea> am I supposed to convert them?
04:13:46 <andrea> why iconv and WCString are not exported modules?
04:15:31 <andrea> I'm not a C coder and so what I'm missing is related to FFI, am I right?
04:28:40 <roconnor> @seen ndm
04:28:41 <lambdabot> ndm is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 37m 17s ago.
04:28:57 <SamB> anyone have a clue why this does not work:
04:29:01 <SamB> class Foo a where
04:29:01 <SamB>     type Bar a :: *
04:29:01 <SamB>     aBar :: Bar a
04:29:01 <SamB>     
04:29:04 <SamB> ?
04:30:14 <roconnor> Hey SamB, how's your niffty inline patch coming along?
04:30:42 <dmhouse> SamB: is that meant to be possible?
04:30:47 <SamB> I still haven't got fish to do nicely...
04:31:01 <roconnor> is that a pre-requisite?
04:31:03 <SamB> dmhouse: actually I think I figured out why it doesn't work...
04:31:10 <SamB> roconnor: I think so, yes.
04:31:27 <SamB> dmhouse: I get this error
04:31:28 <dmhouse> SamB: it'd be type Bar a = exists a. Bar a => a or something.
04:31:29 <SamB> Test.hs:1:0:
04:31:29 <SamB>     Type synonym `Bar' should have 1 argument, but has been given 1
04:31:29 <SamB>     When checking the class method: aBar :: Bar a
04:31:29 <SamB>     In the class declaration for `Foo'
04:31:44 <roconnor> Did you see John Meacham's suggestion about a rule based approach?
04:32:00 <dmhouse> No, I suppose it would be a forall.
04:38:15 <dmhouse> I still don't fully understand how foralls work in Haskell.
04:38:26 <dmhouse> E.g. what's the difference between forall a. [a] and [forall a. a]?
04:38:52 <alar> whatdoes type Bar a::* mean?
04:39:20 <dcoutts_> alar, it's a kind *
04:39:38 <dmhouse> Is the former a list of polymorphic type but once you instantiate the type all elements must have this type (i.e. it's homogeneous)?
04:39:41 <Philippa> dmhouse: the former says 'there is some a, and I have a list of a'
04:39:45 <dcoutts_> dmhouse, yes
04:39:50 <alar> one can state kinds as types of types?
04:39:52 <dmhouse> Right.
04:40:07 <dmhouse> alar: yes, that's what they are. Kinds are 'types' of type constructors.
04:40:09 <Philippa> the latter says 'I have a list of items that forall a, have the type a'
04:40:16 <Philippa> or to put it another way, 'I have a list of bottom' :-)
04:40:29 <alar> didn't know one can use lkinds explicitly
04:40:34 <dmhouse> Right.
04:40:37 <dcoutts_> dmhouse, and the other one, well it's not very useful. Each of the values must be of all types.
04:40:56 <dmhouse> Is there a type of a homogeneous list then?
04:41:05 <Philippa> [exists a.a]
04:41:12 <dcoutts_> I think I'm right in saying that the only value of type forall a. a is _|_
04:41:18 <Philippa> for heterogenous lists, which I think're what you mean
04:41:22 <Philippa> ordinary lists're homogenous
04:41:23 <dmhouse> Sorry, yeah.
04:41:25 <alar> I thinks forall is useful only for functions
04:41:28 <Philippa> dcoutts: module unsafeFoo, yeah
04:41:47 <dmhouse> Philippa: so you can't express that using foralls?
04:42:01 <dcoutts_> dmhouse, you can, using a data constructor
04:42:03 <Philippa> dmhouse: not there, no. But you can emulate it with a forall in a data constructor
04:42:20 <Philippa> which gives you a manually-boxed version of exists a.a
04:42:33 <dcoutts_> dmhouse, note that [exists a.a] is totally useless
04:42:44 <dcoutts_> since you can't do anything to the value
04:42:51 <dcoutts_> since you don't know it's actual type
04:42:57 <dcoutts_> and you have no other ops on it
04:43:02 <dmhouse> dcoutts_: true, but it'd become useful once you introduce class constraints.
04:43:13 <dcoutts_> right, or records of stuff
04:43:14 <Philippa> there are two things you can do with it
04:43:30 <Philippa> the identity function and const _|_
04:43:33 <dcoutts_> [exists a. (a, a -> Step a)]
04:43:45 <dmhouse> E.g. something like [exists h. HTML h => h] would be the heterogeneous list where we know the elements are of an instance of HTML?
04:43:55 <dcoutts_> dmhouse, right.
04:43:57 <dmhouse> So I'd be able to do, e.g. foldr1 (+++) to it?
04:45:24 <dmhouse> What would the boxing datatype look like in this case? data HtmlBox = forall h. HTML h => h
04:45:26 <dcoutts_> dmhouse, though currently I don't think there are any impls that let you do existentials without using a data constructor
04:45:39 <dcoutts_> dmhouse, nearly
04:45:48 <dcoutts_> data HtmlBox = forall h. HTML h => HtmlBox h
04:45:54 <dmhouse> Right, sorry.
04:45:57 <dcoutts_> it needs a constructor
04:46:00 <dmhouse> Yeah.
04:46:11 <dcoutts_> I think hugs lets you use a newtype. ghc doesn't.
04:46:12 <alar> dcoutts you can apply forall a.a->a to [exist a.a]
04:46:26 <dcoutts_> alar, hah, yeah, getting another useless value. :-)
04:46:32 <alar> yes
04:46:51 <dcoutts_> it's computing Jim, but not as we know it
04:47:06 * dcoutts_ needs more tea
04:47:17 <alar> whta about forall a. a-> Integer? :)
04:47:30 <dmhouse> alar: it'd have to be a constant function.
04:47:46 <lennart> alar: it doen't use its argument
04:48:10 <alar> length?
04:48:38 <lennart> length is forall a. [a] -> Int
04:48:42 <dmhouse> You're thinking of forall a. [a] -> Int
04:49:01 <alar> ah, sorry
04:49:12 <dmhouse> If you had [forall b. b], yes, you could apply to length to it.
04:49:18 <dmhouse> a unified with (forall b. b).
04:49:21 <dmhouse> *unifies
04:50:09 <alar> if I have exist b.[b] I can do this also
04:50:10 <lennart> the type [forall b.b] can be represented by a number :)
04:51:24 <dmhouse> lennart: Nice. :) |mkList n = replicate n undefined| is the isomorphism.
04:51:42 <SamB> roconnor: RULE-based approach?
04:52:54 <roconnor> yeah, to augment rules to so that they can fire when certain parameters are literals
04:53:05 <roconnor> > {-# RULES "shift/const-inline"
04:53:05 <roconnor> >    forall x y# . shift x y# = inline shift x y# #-}
04:53:05 <lambdabot>  Unterminated nested comment
04:53:05 <lambdabot>  Parse error
04:53:18 <roconnor> some sort of syntax like that is what is suggested
04:53:26 <roconnor> (maybe that isn't very good syntax)
04:53:30 * SamB doesn't see how that will help the workers get inlined
04:53:35 <SamB> oh, wait.
04:54:07 * SamB sees now.
04:54:27 <SamB> but no, I don't think that is a very good syntax... and I really don't think it would be very easy...
04:56:09 <dmhouse> The datatype approach seems somewhat unwieldy to me regarding existentials.
04:56:11 <roconnor> well, not as easy as your patch, but I don't see why it would be sor hard.
04:56:23 <SamB> dmhouse: why are you talking about those anyway?
04:56:54 <dmhouse> It's clean theoretically but involves tagging every element with a constructor, and defining a datatype for every type you want to do it with. Some sugar would be nice.
04:57:09 * alar doesn't understand existential datatype
04:57:39 <SamB> dmhouse: oh, that
04:57:45 <alar> isn't exist a.a->b equal to a->b ?
04:58:11 * SamB forgot that dmhouse was talking about the Html a => a stuff earlier...
04:58:52 <dmhouse> alar: I don't think so.
04:59:22 <alar> what's the difference?
04:59:23 <dmhouse> exists a. a -> b is the type of a function which will only accept values of one specific type (which you don't know).
04:59:47 <dmhouse> a -> b, or forall a. a -> b is the type of a function which will accept values of any type.
05:00:14 <SamB> its so confusing using the "forall" name for "exists" too...
05:00:21 <SamB> (or did they fix that?)
05:00:22 <dmhouse> And (forall a. a) -> b is the type of a function which will only accept values of one type: forall a. a (i.e., it'll only accept _|_).
05:01:24 <hyraxfourtwo> where does this stuff live in theory land
05:01:31 <dmhouse> A useful mental picture to have around is that types are sets of their values. forall a. a is the intersection of all types, i.e., _|_, as _|_ is a member of every type.
05:01:32 <SamB> dmhouse: but don't tell the GC. Though I suppose the GC doesn't really care if values are _|_ or not...
05:01:33 <alar> so a- equals either forall a.a or exist a.a depending on context?
05:01:36 <hyraxfourtwo> just type theory?
05:01:57 <dmhouse> alar: where could it be exists a. a?
05:02:44 <alar> wait
05:02:57 * alar feels like being entangled
05:03:05 <SamB> alar: did I confuse you?
05:03:15 <SamB> pretend I said "keyword" and not "name"
05:03:59 <dmhouse> What SamB means is this:
05:04:47 <dmhouse> You can define a datatype data T = forall a. T a, which is isomorphic to data T = T (exists a. a)
05:05:55 <dmhouse> So you can use that trick to type, e.g. heterogeneous lists, whose type is [exists a. a] (because you know every element has some type, just not what that type is), by wrapping every element in a constructor.
05:06:06 <dmhouse> s/a constructor/the T constructor/
05:06:55 <alar> but can you unwrap it?
05:07:06 <dmhouse> Yeah, using case.
05:07:24 <ndm> @seen roconnor
05:07:25 <lambdabot> roconnor is in #ghc and #haskell. I last heard roconnor speak 11m 13s ago.
05:07:40 <dmhouse> data T = forall a. MkT a
05:07:46 <alar> after using case you get exist a.a elements
05:07:56 <dmhouse> exList = [MkT 1, Mkt (), Mk True]
05:08:28 <dmhouse> map (\x -> case x of (T x') -> ...) exList
05:08:30 <roconnor> ndm, was your intermediate langauge untyped?
05:08:39 <dmhouse> You can't do anything  useful with the x' because you don't know its type.
05:08:51 <dmhouse> It does indeed have the type exists a. a.
05:09:14 <dmhouse> Sorry, that should have been map (\x -> case x of (MkT x') -> ...) exList
05:09:17 <alar> yes
05:09:19 <dmhouse> If you make T more useful, though:
05:09:28 <alar> but
05:09:42 <alar> can you apply forall a. a-> b to exist a.a?
05:09:56 <dmhouse> Yes, as the former is a function that will accept anything.
05:09:59 <SamB> roconnor: for Yhc?
05:10:36 <dmhouse> So a valid use of exList would be map (const 4) exList, but that's not very interesting.
05:10:41 <dmhouse> Let's make T more interesting.
05:10:54 <dmhouse> data T = forall a. Num a => MkT a
05:11:24 <alar> sorry, have to go
05:12:30 <ndm> roconnor: yes
05:13:18 <roconnor> ndm, good that mean that unsafeCoerce's are complied away in your system.
05:13:38 <ndm> roconnor: yes, entirely ignored
05:14:24 <roconnor> I have some unsafeCoerce's that I beleive will prevent ghc from applying some optimizations.  I was guessing this wouldn't happen with your complier.
05:14:50 <SamB> sometimes it is good to prevent optimizations...
05:15:30 <SamB> I mean... just look at "hello neil"
05:16:39 <roconnor> SamB, In this case I have a case statement which is essentially the identity function. ... or so I'm told
05:17:18 <roconnor> I'd be impressed if ndm's compiler can figure it out.
05:17:23 <ndm> SamB, i've fixed that now
05:17:39 <ndm> roconnor: show me the function, and i'll see
05:18:38 <roconnor> right now I am looking at the ocaml version.  let me see if I have the haskell version.
05:20:42 <roconnor> ndm: it's burried in a big mess.  It's this tait proof again.  I'll just get the whole thing to you later.
05:21:48 <ndm> roconnor: cheers, although in ML much more things are id than in Haskell, since in haskell the laziness often stops something being id
05:22:14 <Lor> Golly, it's crowded in here!
05:22:24 <dmhouse> ?users
05:22:25 <lambdabot> Maximum users seen in #haskell: 256, currently: 227 (88.7%), active: 30 (13.2%)
05:22:37 <dmhouse> Lor: welcome. :)
05:24:17 <therp> who in here thinks that an alternative Lisp style input syntax for Haskell would be nice?
05:24:39 <dmhouse> therp: I doubt I'd use it, but it'd be nice to see.
05:25:10 <dmhouse> I do like Lisp's syntax. It's very clean. Until you get to macros, that is. :)
05:25:16 <Botje> therp: you'd have the lisp people actually implementing it, then :)
05:25:50 <Lor> No, it's the other way. Lisp's syntax looks horrible... until you realize how wonderful it makes macros.
05:25:57 <therp> I just wanted to know if the reaction to this would be hostile http://clemens.endorphin.org/liskell.png
05:26:03 <therp> ah yes, and I named it Liskell
05:26:05 <kosmikus> I'll never understand why people would want to program in abstract syntax. For Lisp/Scheme, there's an added benefit, namely that all code is actually represented in a very simple uniform way. But for Haskell, this wouldn't be true.
05:26:48 <dmhouse> therp: you have an implementation?
05:26:51 <vegai> I fear the typing would make it more irritating than lisp usually is
05:27:50 <therp> dmhouse: that's no fake - it's not complete. but I understands most things, bindings types and regular expressions. I have to teach it about data, class and instance declarations, but I doubt that it will take longer than another 3 days
05:28:02 <therp> s/I understands/it understands/
05:28:28 <dmhouse> therp: how is it implemented?
05:28:34 <roconnor> ndm: intresting point.  In haskell a case statement with identical branches cannot be optimized away?
05:28:48 <therp> dmhouse: alex lexer, happy parser and a parse-tree to parse-tree converter to HsSyn
05:29:07 <ndm> roconnor: consider, case error "here" of [] -> True; (:) -> True
05:29:25 <ndm> roconnor: i did experiment with this optimisation, and i can turn it back on, i'm just not sure i should...
05:29:33 <therp> dmhouse: quite trivial, 380 lines of code at the moment
05:29:40 <roconnor> I'd love to have an option to do that
05:29:57 <dmhouse> therp: good stuff :)
05:30:15 <ndm> roconnor: i'd raise it on haskell-cafe, i'd be curious whether its a valid interpretation of the haskell standard, etc
05:30:15 <roconnor> It's a bit hard to complain when your optimizer turns non-terminating programs into terminating programs.
05:30:23 <dmhouse> therp: you might persuade some Lispers to take a serious look at the language if they get to keep their beloved parentheses.
05:30:26 <Philippa> does matching against _ still force evaluation?
05:30:33 <ndm> yes, but it will never turn a terminating one into a non-terminating one
05:30:34 <roconnor> Philippa: nope
05:30:35 <ndm> Philippa: yes
05:30:38 <roconnor> ?
05:30:45 <ndm> i think...
05:30:46 <kosmikus> no
05:30:51 <roconnor> > case error "here" of _ -> True
05:30:52 <lambdabot>  True
05:30:53 <dmhouse> ndm: why would it?
05:31:13 <ndm> dmhouse: i guess, its just hte semantics of Core would make it evaluate to error
05:31:37 <ndm> dmhouse: in Core, case x of ... is equivalent to x `seq` case x of
05:31:41 <kosmikus> ndm: ghc's Core version of "case" forces evaluation, yes
05:31:41 <therp> dmhouse: ah, that's not my goal. I'm in love with metaprogramming and macros. maybe I can get to a macro->template haskell conversion, but I know to little about template haskell to anticipate the outcome
05:31:56 <ndm> kosmikus: i've been working with Core for too long, its clouded my haskell :)
05:32:11 <dmhouse> therp: regardless, it's an interesting project :)
05:32:20 <kosmikus> ndm: I was only so sure because spj mentioned it during the Hackathon ...
05:32:41 <dmhouse> ndm: why?
05:33:13 <ndm> dmhouse: case forces an evaluation, all branches of the case can only be one consturctor deep, its just the way it is :)
05:33:14 <roconnor> ndm: In my case, my extractied program is strongly normalizing, so your optimizing away cases with identical branches is always ``safe''
05:33:39 <ndm> roconnor: yes, but technically a program would need to have a proof of that to hand :)
05:33:55 <ndm> roconnor: i might add a -i-strongly-normalise flag, and then make that optimisation
05:34:03 <dmhouse> It seems weird to randomly introduce strictness into the language like that.
05:34:03 <ndm> roconnor: i can check for pattern match failure, but not terminatino
05:34:27 <ndm> dmhouse: read up on GHC core, let is an allocation, case is an evaluation, thats it
05:35:30 <Igloo> It might have been better to use force or demand or something in core
05:35:58 <ndm> Igloo: my Core does, since more than case can demand evaluation
05:36:33 <ndm> Igloo: but for GHC core, i think it is a reasonable way to go (since my Core has paths, which make this different)
05:36:47 <ndm> * i think the existing way is a reasonable way to go
05:37:02 <Igloo> ndm: I just mean using a different keyword, not changing the semantics or anything
05:37:39 <ndm> Igloo: ah, but in other ways they are so very similar to case's
05:38:00 <ndm> i have force, and case, something must be force'd before being case'd
05:38:18 <ndm> force = eval, in my terminology
05:38:20 <Igloo> Does anyone know what I have to do to make a symbol in a binary that nm reports as "09100ad0 T rts_lock" visible to libraries the program dlopens, BTW?
05:39:19 <orban> I have no idea about haskell but trying to figure something out. install ghc on debian with apitude install ghc, then trying to compile a file and getting this error: Failed to load interface for `Text.Regex.Base':
05:39:36 <orban> how do I install this library? :>
05:39:45 <Igloo> orban: Does it work with --make?
05:40:02 <orban> ghc --make?
05:40:06 <Igloo> Yes
05:40:12 <orban> oh.
05:40:15 <dcoutts_> Igloo, there's that linker flag that makes all symbols in the binary available to the dynamic linker
05:40:18 <Igloo> orban: If not you probably need libghc6-regex-compat-dev (or maybe posix instead of compat)
05:40:22 <orban> Can't find module `Data.ByteString.Char8'
05:40:51 <Igloo> OK, you'll need to compile fps yourself I think with that version of GHC
05:41:25 <orban> hmm, basically what I'm trying to do is...let me explain. I found this TRE library (for approximative pattern matching), and..because I couldn't find an interface for it and I don't really know anything about C++..I googled a bit and found this page: http://darcs.haskell.org/packages/regex-base/_darcs/pristine/doc/lazy.html
05:41:28 <lambdabot> Title: Text.Regex.Lazy, http://tinyurl.com/y5wrr4
05:41:28 <beelsebob> arses!
05:41:34 <beelsebob> what's changed with PackString in 6.6?
05:41:40 <Igloo> dcoutts_: Ah, --export-dynamic?
05:41:58 <dcoutts_> Igloo, -Wl,--export-dynamic yep.
05:42:10 <orban> so haskell seems a bit easier and maybe I can figure out how to do write a tiny tool to access the TRE library. :)
05:42:18 <dcoutts_> beelsebob, it's deprecated, that's all. Nothing else changed.
05:42:29 <dcoutts_> Igloo, dunno if you can do that on a per-symbol basis.
05:42:41 <beelsebob> dcoutts: what should be used instead?
05:42:46 <orban> Igloo: How do I do that?
05:43:32 <dcoutts_> Igloo, since you don't really want to use --export-dynamic in general for everything as it enormously bloats the linker tables, especially with the number of symbols you typically get in a ghc-generated lib/exe.
05:43:41 <ndm> beelsebob: Data.ByteString
05:43:45 * Igloo is happy to have a bit of bloat for now
05:43:46 <beelsebob> ndm: kk
05:43:52 <dcoutts_> beelsebob, either ByteString or String if you need Unicode.
05:43:58 <Igloo> @where fps
05:43:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
05:44:12 <Igloo> orban: Should be able to just grab it frmo there and follow the isntructions
05:44:23 <dcoutts_> beelsebob, there will be a proper replacement for Data.PackedString at some point. It'll basically be a Unicode version of Data.ByteString.
05:44:32 <beelsebob> kk
05:48:29 <orban> Oh my god I think this is too complicated for me :D
05:51:03 <ndm> dcoutts_, so you're actually depreciating PackedString before the replacement is out!??!
05:51:13 <dcoutts_> ndm, yep.
05:51:20 <dcoutts_> ndm, giving people fair warning
05:51:20 * ndm cries silently in a corner
05:51:27 <dcoutts_> you can still use it
05:51:31 <dcoutts_> we didn't break anything
05:51:31 <ndm> dcoutts_, as long as its not deleted for 6.8?
05:51:54 <dcoutts_> the plan is to replace it
05:52:03 <ndm> with the same compatible API?
05:52:07 <dcoutts_> no
05:52:18 <ndm> i.e. during 6.8 will i be able to use the old version, and the new version, simultaneously?
05:52:21 <dcoutts_> I suppose we might be able to keep the existing on and just add stuff
05:52:44 <ndm> since if not, it makes upgrading a NIGHTMARE - you'd have to upgrade overnight as 6.8 came out...
05:52:49 <dcoutts_> ndm, that seems like it's not impossible.
05:52:57 <dcoutts_> especially if you help :-)
05:53:19 <ndm> dcoutts_, a patch for Yhc would be appreciated :) - we are happy to use Data.ByteString directly, no unicode nonsense
05:53:32 <Igloo> Doesn't String perform better than PS anyway, or did I imagine that?
05:53:51 <dcoutts_> Igloo, you didn't imagine that.
05:54:15 <dcoutts_> ndm, then do that, it's easy to change the names, fooPS to B.foo
05:54:22 <dcoutts_> then no upgrade worries
05:54:46 <dcoutts_> and you can even switch back to Unicode names later if you want, when Data.PackedString is revived.
05:54:49 <Igloo> Then I'd suggest ndm upgrades to String  :-)
05:54:56 <dcoutts_> me too
05:55:01 <dcoutts_> or ByteString
05:55:09 <ndm> dcoutts_, it just scares me that the flip happens overnight, with no intermediate thing - its best to depreciate something when their is a replacement!
05:55:18 <Igloo> Yes, depending on whether he'd prefer to have unicode chars
05:55:30 <ndm> i'd rather ByteString
05:55:33 <Igloo> ndm: Why is String not the replacement?
05:55:40 <ndm> but we need to be compatible with RevesePackedString
05:55:52 <dcoutts_> ndm, as far as I know, you're the only one who uses PackedString, everyone else figured out they're useless ages ago ;-)
05:55:55 <ndm> Igloo: we have bytestrings, we'd like to go to an efficent bytestring, since thats obviously the best way to go
05:56:10 <dcoutts_> ndm, that's the other thing, the reversed thing is silly :-)
05:56:11 <ndm> dcoutts_, fair enough then :) - no point in doing compatability gunk for one project
05:56:21 <ndm> dcoutts_, i know!! but it wasn't me...
05:56:26 <dcoutts_> heh heh
05:56:56 <ndm> there are many "interesting" things in Yhc, none of them were ever good ideas
06:09:26 <orban> Igloo: Sorry to bother you again... http://darcs.haskell.org/packages/regex-base/_darcs/pristine/doc/lazy.html I'm looking for the "import Text.Regex.TRE" but it won't find it on my installation.
06:09:27 <lambdabot> Title: Text.Regex.Lazy, http://tinyurl.com/y5wrr4
06:10:40 <roconnor> ndm: because you can catch various non-termination exceptions, this case optimization could change the behaviour of programs, ie, a program that output True when you use the optimization, and False otherwise.
06:11:14 <ndm> roconnor: true, yeah, its unsafe sadly :(
06:11:42 <ndm> roconnor: but i can eliminate branches in teh future because i know the type of the constructor, so it is a slight win
06:11:54 <roconnor> but realistically, how many people catch nontermination exceptions thrown by cases with identical branches?
06:12:10 <Igloo> orban: Never used it. I suspect you need to compile a regex-tre package yourself, though
06:12:30 <orban> I did try a darcs get http://darcs.haskell.org/packages/regex-tre
06:12:32 <lambdabot> Title: Index of /packages/regex-tre
06:12:36 <ndm> roconnor: no idea, i can detect exception-free-ness though, so might add a flag -no-exceptions -terminates, and then apply the optimisation
06:12:42 <orban> and it installed two patches...
06:13:53 <orban> do I have to run darcs from a certain directory?
06:17:27 <musasabi> @hoogle a -> Rational
06:17:28 <lambdabot> Prelude.toRational :: Real a => a -> Rational
06:18:30 <chessguy> whoah
06:18:36 <chessguy> you can hoogle a type signature?
06:24:07 <ndm> chessguy: of course :)
06:24:37 <chessguy> that's pretty sweet
06:28:14 <orban> Can't find module `Distribution.Simple'
06:28:17 <orban> I'm scared :(
06:29:40 <dmhouse> orban: what's the context?
06:29:40 <chessguy> @hoogle [a]->[a]
06:29:41 <lambdabot> Prelude.cycle :: [a] -> [a]
06:29:41 <lambdabot> Prelude.init :: [a] -> [a]
06:29:41 <lambdabot> Prelude.reverse :: [a] -> [a]
06:29:56 <orban> Trying to install regex-tre
06:33:09 <ndm> chessguy: have you tried the hoogle website? its better than the lambdabot version
06:36:12 <orban> dmhouse: any idea what I am missing? :)
06:38:08 <dmhouse> orban: Cabal?
06:39:00 <orban> I did install libghc6-cabal-dev
06:40:01 <chessguy> ok, the hardest part of my generalized GP engine in haskell is now written
06:41:31 <CosmicRay> orban: are you running debian sarge or sid?
06:41:36 <orban> sarge
06:42:02 <CosmicRay> orban: ok, IIRC you probably still don't need libghc6-cabal-dev.  try uninstalling it, and remember to pass -package Cabal to ghc when compiling.
06:42:33 <orban> when compiling preg-tre?
06:42:42 <orban> I don't think I have the package Cabal
06:45:39 <chessguy> @paste
06:45:39 <lambdabot> http://paste.lisp.org/new/haskell
06:46:59 <lisppaste2> chessguy pasted "Crossover functionality for a generalized Genetic Programming engine" at http://paste.lisp.org/display/28610
06:47:25 <chessguy> any suggestions for improvements/optimization?
06:49:48 <ndm> chessguy: \_ ->, is const
06:49:51 <ndm> @hoogle const
06:49:52 <lambdabot> Prelude.const :: a -> b -> a
06:49:52 <lambdabot> Data.Generics.Basics.constrFields :: Constr -> [String]
06:49:52 <lambdabot> Data.Generics.Basics.constrFixity :: Constr -> Fixity
06:50:05 <chessguy> hmm?
06:50:18 <chessguy> it's intended to be
06:50:19 <ndm> (\_ -> (fst (getNode r2 (top parent')))),
06:50:23 <ndm> const (fst (getNode r2 (top parent')))
06:50:27 <ndm> same thing
06:50:39 <chessguy> yes, it replaces the current section of the tree with that branch
06:50:55 <chessguy> is const faster?
06:51:02 <ndm> yes, i'm just commenting that there is a function, called const, that is what you did
06:51:04 <ndm> same speed
06:51:09 <ndm> just prettier :)
06:51:12 <ndm> if you think it is
06:51:23 <ndm> i'd also write it as
06:51:34 <ndm> (const $ fst $ getNode r2 $ top parent')
06:51:43 <ndm> eliminate lots of brackets, this isn't lisp :)
06:51:57 <chessguy> ok
06:53:05 <chessguy> done
06:54:30 <chessguy> any other suggestions?
06:54:31 <dmhouse> ndm: or (const . fst . getNode r2 $ top parent')
06:55:00 <ndm> dmhouse: i prefer the symetry of $ vs some . some $, but each to their own - they are equivalent
07:05:43 <chessguy> so, no other suggestions? is it pretty clear how it works?
07:11:34 <cwenner> perhaps use monads for the trees?
07:12:02 <chessguy> do you think it would be more efficient?
07:12:21 <cwenner> no, but better haskell style
07:12:32 <Syzygy-> @type const
07:12:34 <lambdabot> forall a b. a -> b -> a
08:15:13 <hyraxfourtwo> > (\a ->) 5 $ undefined
08:15:13 <lambdabot>  Parse error
08:15:41 <hyraxfourtwo> thought so
08:17:17 <chessguy> (\a -> 5) 5
08:17:21 <chessguy> > (\a -> 5) 5
08:17:22 <lambdabot>  5
08:34:00 <chessguy> hmm
08:34:03 <chessguy> @quote math
08:34:04 <lambdabot>  2^20 ~= 10^6
08:34:14 <chessguy> > 2^20 - 10^6
08:34:21 <lambdabot>  48576
08:39:31 <chessguy> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
08:39:32 <lambdabot>  Parse error
08:43:34 <chessguy> now i've just got to remember what in the world i originally went to the wiki for, because it wasn't to look at the quotes pages :)
08:56:41 <chessguy> @tell dons something really ought to be done about http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority ...it's really been trashed by bots
08:56:41 <lambdabot> Consider it noted.
09:13:30 <psnl> ndm: do you know anything about the internals of hat delta?
09:22:47 <ndm> pnsl, no, ask bob
09:46:55 <psnl> thanks
09:47:00 <palomer> <:o
10:13:37 <chessguy> can i use list comprehensions to generate lists of different sizes? e.g., the lists of natural numbers that sum to 5?
10:15:00 <chessguy> hi dolio
10:15:19 <emu> > [ [x,y] | x <- [1..3], y <- [1..2] ]
10:15:20 <lambdabot>  [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2]]
10:15:38 <chessguy> emu: all those lists are the same size
10:15:45 <dolio> Hi.
10:15:54 <emu> > [ [x,y] | (x,y) <- ([1..3],[1..2]) ]
10:15:55 <lambdabot>  Couldn't match `([a], [a1])' against `[a2]'
10:16:18 <emu> > [ [x,y] | (x,y) <- zip [1..3] [1..2] ]
10:16:20 <lambdabot>  [[1,1],[2,2]]
10:16:21 <emu> lol
10:16:30 <chessguy> :)
10:16:40 <emu> well yea, i'm not saying what i mean though
10:17:02 <chessguy> quit being so political
10:17:19 <mjl69_> > 1
10:17:21 <lambdabot>  1
10:18:03 <emu> [ x | x <- tails [1..3] ]
10:18:07 <emu> >[ x | x <- tails [1..3] ]
10:18:10 <emu> > [ x | x <- tails [1..3] ]
10:18:11 <lambdabot>  [[1,2,3],[2,3],[3],[]]
10:18:17 <ValarQ> > [replicate x x | x <- [1..3]]
10:18:19 <lambdabot>  [[1],[2,2],[3,3,3]]
10:18:32 <chessguy> lol
10:18:35 <emu> > [ x | x <- tails [5,4..1] ]
10:18:36 <lambdabot>  [[5,4,3,2,1],[4,3,2,1],[3,2,1],[2,1],[1],[]]
10:18:37 <chessguy> that's cheating
10:18:53 <emu> > [ x | x <- tails [4,3..1], sum x == 5 ]
10:18:54 <lambdabot>  []
10:19:28 <emu> um, some function that generates all permutations of numbers between 1 and 5 hehe
10:20:05 <ValarQ> [ x | x <- expr ] -- doesn't feel all that useful...
10:20:18 <emu> yea it's just filter
10:20:43 <emu> > filter ((5==) . sum) (tails [4,3..1])
10:20:45 <lambdabot>  []
10:22:58 <dolio> > let f [] = [[]] ; f l = [ x:k | x <- l, k <- f (delete x l) ] in f [1..3]
10:23:00 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
10:23:22 <emu> need stuff like
10:23:26 <mjl69_> > [ x | x <-  [1..5] ]
10:23:28 <\z> > [ (x, y)| x <- [1..4], y <- [1..4], x + y == 5]
10:23:28 <emu> > replicate 5 1
10:23:29 <lambdabot>  [1,2,3,4,5]
10:23:30 <lambdabot>  [(1,4),(2,3),(3,2),(4,1)]
10:23:31 <lambdabot>  [1,1,1,1,1]
10:23:43 <mjl69_> > [ x | x <-  [1..5], [6..10] ]
10:23:45 <lambdabot>  Couldn't match `Bool' against `[a]'
10:24:12 <emu> > 5^5
10:24:14 <lambdabot>  3125
10:24:14 <\z> >  [ (x, y, z)| x <- [1..4], y <- [1..4], z <- [1..4], x + y + z == 5]
10:24:16 <lambdabot>  [(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(3,1,1)]
10:24:23 <mjl69_> > [ x^2 | x <-  [1..5] ]
10:24:25 <lambdabot>  [1,4,9,16,25]
10:24:36 <emu> @hoogle permute
10:24:36 <lambdabot> Text.ParserCombinators.Parsec.Perm.permute :: PermParser tok st a -> GenParser tok st a
10:24:37 <lambdabot> Distribution.GetOpt.Permute :: ArgOrder a
10:24:41 <emu> @hoogle permutate
10:24:41 <lambdabot> No matches found
10:24:45 <chessguy> @type |
10:24:46 <lambdabot> parse error on input `|'
10:25:06 <emu> > do { x <- [0..4]; return x }
10:25:08 <lambdabot>  [0,1,2,3,4]
10:25:17 <roconnor> > let choices [] = []; choices (a:as) = (a,as):(map (\(x,y)->(x,a:y)) (choices as)) in choices [1..3]
10:25:18 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
10:25:48 <ValarQ> > map (filter (>0)) $ filter ((==5).sum) $ sequence $ replicate 5 [0..5]
10:25:50 <lambdabot>  [[5],[1,4],[2,3],[3,2],[4,1],[5],[1,4],[1,1,3],[1,2,2],[1,3,1],[1,4],[2,3],[...
10:26:15 <emu> > sequence $ replicate 5 [0..4]
10:26:15 <chessguy> hey, ValarQ did it
10:26:17 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,0,2],[0,0,0,0,3],[0,0,0,0,4],[0,0,0,1,0],[0,...
10:26:20 <emu> i knew it was sequence!
10:26:21 <emu> heh
10:26:23 <ValarQ> graps all permutations thought :/
10:26:26 <emu> yea
10:26:45 * ValarQ wonders what "graps" means
10:26:50 <chessguy> > length $ map (filter (>0)) $ filter ((==5).sum) $ sequence $ replicate 5 [0..5]
10:26:52 <lambdabot>  126
10:27:32 <mjl69_> > 4%3
10:27:34 <chessguy> > replicate 5 [0..5]
10:27:34 <lambdabot>  4%3
10:27:36 <lambdabot>  [[0,1,2,3,4,5],[0,1,2,3,4,5],[0,1,2,3,4,5],[0,1,2,3,4,5],[0,1,2,3,4,5]]
10:27:42 <mjl69_> > 4 mod 3
10:27:43 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
10:27:44 <lambdabot>   In the...
10:27:48 <emu> % is ratio in Haskell
10:27:51 <mjl69_> oh
10:27:59 <emu> > 4 `mod` 3
10:28:00 <roconnor> > 4 `mod` 3
10:28:01 <lambdabot>  1
10:28:02 <lambdabot>  1
10:28:08 <chessguy> > sequence $ replicate 5 [0..5]
10:28:09 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,0,2],[0,0,0,0,3],[0,0,0,0,4],[0,0,0,0,5],[0,...
10:28:13 <mjl69_> oh, sorry.  I forgot.
10:28:54 <roconnor> ls
10:28:57 <roconnor> oops
10:28:59 <roconnor> wrong window
10:29:01 <liyang> su -
10:29:10 <roconnor> sudo rm -rf /
10:29:21 <chessguy> > filter ((==5).sum) $ sequence $ replicate 5 [1..4]
10:29:23 <lambdabot>  [[1,1,1,1,1]]
10:30:14 <mjl69_> be careful, don't type your password :)
10:31:02 <emu> > filter ((==5) . sum) . sequence $ replicate 5 [1..4]
10:31:04 <lambdabot>  [[1,1,1,1,1]]
10:31:17 <arcatan> I often try to view members of a channel with ls
10:31:17 <emu> > filter ((==5) . sum) . sequence $ replicate 5 [0..4]
10:31:19 <lambdabot>  [[0,0,0,1,4],[0,0,0,2,3],[0,0,0,3,2],[0,0,0,4,1],[0,0,1,0,4],[0,0,1,1,3],[0,...
10:32:27 <emu> > filter ((==5) . sum) . map (delete 0) . sequence $ replicate 5 [0..4]
10:32:29 <lambdabot>  [[0,0,1,4],[0,0,2,3],[0,0,3,2],[0,0,4,1],[0,1,0,4],[0,1,1,3],[0,1,2,2],[0,1,...
10:32:40 <emu> hmm, delete only gets 1 match?
10:33:09 <Syzygy-> > filter ((==5) . sum) . map (filter (!=0)) . sequence $ replicate 5 [0..4]
10:33:11 <lambdabot>  Not in scope: `!='
10:33:15 <emu> yea yea
10:33:19 <Syzygy-> > filter ((==5) . sum) . map (filter (>0)) . sequence $ replicate 5 [0..4]
10:33:21 <lambdabot>  [[1,4],[2,3],[3,2],[4,1],[1,4],[1,1,3],[1,2,2],[1,3,1],[1,4],[2,3],[2,1,2],[...
10:33:28 <ValarQ> > map (filter (>0)) $ filter ((==5).sum) $ sequence $ init $ tails [5,4..0]
10:33:29 <lambdabot>  [[5],[4,1],[4,1],[4,1],[4,1],[3,2],[3,1,1],[3,1,1],[3,1,1],[3,2],[3,1,1],[3,...
10:33:46 <ValarQ> without permutations?
10:33:52 <emu> init . tails
10:33:54 <ValarQ> nope :/
10:34:09 <emu> > init [5,4..0]
10:34:10 <lambdabot>  [5,4,3,2,1]
10:34:22 <emu> > init $ tails [5,4..0]
10:34:24 <lambdabot>  [[5,4,3,2,1,0],[4,3,2,1,0],[3,2,1,0],[2,1,0],[1,0],[0]]
10:36:05 <liyang> dcoutts: how much of your modifications to c2hs made it into 0.14.5?
10:37:43 <roconnor> @hoogle getArgs
10:37:44 <ValarQ> > nub $ map (sort . filter (>0)) $ filter ((==5).sum) $ sequence $ replicate 5 [0..5]
10:37:44 <lambdabot> System.getArgs :: IO [String]
10:37:46 <lambdabot>  [[5],[1,4],[2,3],[1,1,3],[1,2,2],[1,1,1,2],[1,1,1,1,1]]
10:37:55 <dcoutts_> liyang, depends on what modifications you mean :-)
10:38:08 <dcoutts_> liyang, there's not a lot since 0.14.5 I think.
10:38:22 <dcoutts_> I have some more changes planned but they're not in the public repo yet
10:38:42 <dcoutts_> you can check how many patches there have been since the 0.14.5 darcs tag.
10:38:52 <roconnor> @hoogle print
10:38:53 <lambdabot> Prelude.print :: Show a => a -> IO ()
10:38:53 <lambdabot> Text.Printf.Print :: class Print
10:38:53 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
10:39:02 <roconnor> I wish there was a printLn
10:40:37 <emu> doesn't print add a newline?
10:40:39 <liyang> I was wishfully thinking that dropping in Debian's c2hs would make all the FiniteMaps go away. ^^;
10:40:45 <dcoutts_> emu, yes it does.
10:40:47 <SyntaxNinja> roconnor: what would printLn do?
10:40:55 <emu> and putStrLn for putStr + newline
10:41:19 <dcoutts_> liyang, oh yes, I can't remember if the ghc-6.6 stuff is in the latest release or just in the darcs version.
10:41:37 <roconnor> SyntaxNinja: putStrLn . show
10:41:52 <emu> print = putStrLn . show
10:41:55 <roconnor> hs
10:41:56 <roconnor> oh
10:42:02 <roconnor> well, nevermind then
10:53:32 <unclear> Is there any way that you can set an textCtrl widget to enabled := False and still keep the same color on the text?
10:54:32 <unclear> it's hard do read light grey against white, wich is what you get when seting it to enabled := False
10:55:26 <roconnor> > 2^20
10:55:28 <lambdabot>  1048576
10:55:57 <Syzygy-> @type newline
10:55:59 <lambdabot> Not in scope: `newline'
10:57:46 <chessguy> @type function
10:57:48 <lambdabot> Not in scope: `function'
10:57:55 <chessguy> @hoogle function
10:57:56 <lambdabot> System.Console.Readline.Function :: Callback -> Entry
10:57:57 <lambdabot> System.Console.Readline.functionDumper :: Bool -> IO ()
10:57:57 <lambdabot> System.Console.Readline.functionOfKeyseq :: String -> Maybe Keymap -> IO Entry
10:58:01 <palomer> you're all nuts!
10:58:52 <emu> forall x. nuts x
10:59:21 <roconnor> when computing the depth of my tree-structure, I need to use seq right?
10:59:26 <velco> @type xor
10:59:27 <lambdabot> forall a. (Bits a) => a -> a -> a
11:00:10 <chessguy> you shouldn't have to
11:00:17 <chessguy> such things are usually done recursively
11:00:30 <roconnor> my tree has depth 2^20
11:00:39 <roconnor> it isn't balanced.
11:00:46 <chessguy> is it binary?
11:01:04 <chessguy> and if you know the depth, why are you calculating it? :)
11:01:23 <roconnor> chessguy: I'm computing 2^20 using church numerals
11:01:40 <roconnor> ah, using -O2 has removed my stack overflow
11:01:52 <chessguy> is it binary?
11:02:17 <roconnor> chessguy: it is a lambda term, so there are leaves, binary application nodes, and unary lambda nodes
11:02:44 <chessguy> well, it should be easy to do recursively then
11:03:08 <roconnor> sure it is easy to do, but I was getting a stack overflow
11:03:45 <roconnor> to me that is a signal that I am not using enough strictness on operations involving integers.
11:11:30 <roconnor> > 57.725 / 114.26
11:11:31 <lambdabot>  0.5052074216698758
11:16:20 <dmead> > 22/7
11:16:21 <lambdabot>  3.142857142857143
11:16:41 <dmead> > 22.00000/7.00000
11:16:42 <lambdabot>  3.142857142857143
11:16:44 <dmead> hehe
11:22:55 <d0mg> how can I convert a [Char] to an Int?
11:23:17 <sjanssen> > read "123" :: Int
11:23:18 <lambdabot>  123
11:23:41 <d0mg> thank you
11:23:45 <palomer> aww man
11:23:59 <palomer> looks like I'm going to have to do some bi directional type checking
11:24:00 <palomer> shucks
11:24:20 <palomer> this is something I really don't want to do
11:24:31 <dmead> yea?
11:24:34 <dmead> for what types
11:25:11 <palomer> standard stuff
11:25:14 <palomer> with GADTs
11:25:36 <monochrom> putStrLn "howdy"
11:26:19 <palomer> programming in haskell makes me happy
11:26:22 <palomer> I'm crying
11:26:28 <palomer> no kidding
11:26:32 <palomer> ok, I stopped
11:26:37 <monochrom> haha
11:30:33 <palomer> well, it turns out you don't need to do any bi directional type checking if you're unifying
11:31:27 <chessguy> can i have a module that defines a function, but also imports another module, and if the function is defined in the imported module, uses that definition instead?
11:32:10 <roconnor> *l*
11:32:13 <palomer> I don't think so
11:32:14 <roconnor> ``
11:32:14 <roconnor> AFAIR C disallows declaring a variable void, though it would be
11:32:14 <roconnor> theoretically possible to relax this, and have them allocated as zero
11:32:14 <roconnor> bytes.
11:32:23 <monochrom> I can't think of a way.
11:32:40 <palomer> chessguy, you may want to look into nammed import
11:32:45 <palomer> does nammed take 2 mm's?
11:33:02 <monochrom> named
11:33:15 <palomer> you sure?
11:33:30 <monochrom> But chessguy is asking for a very high degree of reflection.
11:33:53 <chessguy> what about checking to see if a function is defined?
11:34:17 <monochrom> No.
11:35:02 <palomer> hrmph
11:35:10 <palomer> is there a problem with treating modules exactly like records
11:35:14 <palomer> (but with its own syntax)?
11:36:04 <palomer> ok,@logs
11:36:07 <palomer> @logs
11:36:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:36:41 <monochrom> No problem. But if you don't have an operation "does record type T possess a field X" or "what are the fields of record type T", there is still no difference.
11:37:12 <monochrom> Java is about the only language I know that supports such an operation.
11:37:36 <monochrom> Now I haven't learned Python and Ruby, so I know nothing.
11:38:19 <chessguy> what i'm actually working on is a generalized genetic programming engine
11:38:41 <palomer> what happened to Control.Concurrent?
11:38:46 <chessguy> i was thinking that i want to be able to add things like new genetic operators easily
11:38:50 <monochrom> Hmm what does @logs stand for, such that it points to the lib docs?
11:39:08 <palomer> monochrom, I wasn't talking about chessguy in particular
11:39:16 <palomer> I was just wondering why haskell is stuck in module stone age
11:39:21 <palomer> when an easy fix is around the corner
11:39:44 <monochrom> chessguy: re-architect your framework so that you never need ask "does module X exports y".  If anything try type classes instead.
11:39:58 <monochrom> Because there is type class.
11:40:12 <chessguy> you mean architect :)
11:40:24 <chessguy> i don't have a framework yet, i'm trying to figure it out from scratch
11:41:17 <palomer> ok, trace is broken
11:41:23 <palomer> it's optimized out
11:42:00 <monochrom> So, somehow most things done by ML people with modules, we can manage to pull the same tricks off with type classes, so there has not been an incentive to change the basic module system.
11:42:13 <SamB> monochrom: Java supports that?
11:42:22 <monochrom> YES!
11:42:23 * SamB bets java has really lame support for it though
11:42:33 <SamB> well, I mean, obviously Jython can use it...
11:42:54 <monochrom> Well, under the lack of much competition or comparison, it's hard to say what's lame and what's decent.
11:43:30 <SamB> I was under the impression that the API was far too heavyweight to be useful to mere mortal Java programmers...
11:43:47 <palomer> monochrom, yes, but sometimes you want to do things _at the module level_
11:43:48 <chessguy> you assume monochrom is mortal
11:43:53 <monochrom> ssshhh there are no mere mortal Java programmers here...
11:43:59 <SamB> hehe
11:44:00 <SamB> well.
11:44:13 <chessguy> :)
11:44:39 <monochrom> mere mortals are irrelevant.
11:44:50 <chessguy> thank you seven of nine
11:44:54 <SamB> what I mean is, I don't know if the API is anything like easy enough to use that you might use it in a Java program, if you weren't writing a scripting engine or something...
11:45:07 <sjanssen> palomer: trace is optimized out?
11:45:13 <palomer> sjanssen, yes!
11:45:27 <palomer> sTrace x = trace x `seq` return () <--- this is my trace function
11:45:33 <palomer> and it's sometimes optimized out of my code
11:45:35 <palomer> driving me nuts
11:45:35 <sjanssen> palomer: sure you're not tripping over lazy evaluation?
11:45:42 <SamB> actually in Java you would be able to tell if they had modules as just another kind of record
11:45:52 <SamB> because then modules could have functions in them ;-)
11:46:05 <sjanssen> palomer: what if you add an {-# INLINE trace #-} ?
11:46:10 <Igloo> palomer: How are you using it?
11:46:19 <palomer> sjanssen, where would I add that?
11:46:50 <sjanssen> palomer: nevermind
11:47:54 <dmead> chessguy: you have you do "import blahblah hiding(something something)
11:48:07 <palomer> http://www.rafb.net/paste/results/DASonm56.html
11:48:51 <chessguy> dmead, hablas ingles?
11:49:11 <dmead> what?
11:49:28 <chessguy> what does "you have you do" mean
11:49:42 <monochrom> you have to do
11:49:48 <chessguy> oh
11:49:53 <monochrom> Gosh you need an error correcting modem.
11:50:04 <sjanssen> palomer: shouldn't trace have another parameter in sTrace?
11:50:05 <chessguy> i don't see how that helps
11:50:07 <dmead> in response to your question above
11:50:16 <dmead> mmm
11:50:22 <monochrom> It would correct errors made by other people :)
11:50:24 <dmead> whats the problem exactly?
11:50:29 <sjanssen> palomer: I'd say sTrace x = trace x (return ())
11:50:40 <palomer> sjanssen: does the same thing
11:50:49 <chessguy> suppose in my module i have defined foo = ...
11:50:58 <dmead> right
11:51:01 <chessguy> i want to import Foo
11:51:16 <dmead> just foo?
11:51:18 <chessguy> and if Foo also says foo=..., then i want to use Foo's definition instead of mine
11:51:18 <dmead> and nothing else?
11:51:19 <palomer> let's see
11:51:51 <palomer> @type seq
11:51:53 <lambdabot> forall b a. a -> b -> b
11:52:04 <palomer> Cale suggested I use seq
11:52:07 <dmead> mmm
11:52:11 <sjanssen> I don't think seq helps you here
11:52:14 <monochrom> I should become a Haskell consultant and solicit business here.
11:52:17 <dmead> hehe
11:52:36 <chessguy> but what would you do with all your spare time? :)
11:52:39 <dmead> chessguy: you either need to have an overloaded instance or hide one of the definitions of Foo
11:52:58 <chessguy> but the one i want to hide is in the current module
11:53:07 <dmead> then comment it out =/
11:53:10 <monochrom> thesis for spare time
11:53:20 <chessguy> lol
11:53:22 <sjanssen> palomer: what monad are you in?
11:53:28 <dmead> can you paste your code?
11:53:36 <chessguy> i don't have code yet
11:53:41 <dmead> k
11:54:26 <dmead> just to make sure, you understand that in languages like haskell and ML function are defined multiple times with
11:54:29 <dmead> foo a = this
11:54:30 <dmead> foo b = that
11:54:38 <dmead> you aren't creating a new function
11:54:49 <dmead> it's a different function body to pattern match to
11:54:51 <sjanssen> palomer: the problem with that last snippet you gave is that GHC is optimising out the call to printUnifier, not the call to trace
11:55:00 <chessguy> oh, sure
11:55:05 <dmead> k just makin sure
11:55:16 <chessguy> like fac 0 = 1; fac n = n*fac(n-1)
11:55:23 <dmead> yes
11:55:27 <palomer> sjanssen, but shouldn't it detect that there's a trace in there and you shouldn't touch anything with a trace?
11:55:29 <chessguy> same function, two patterns
11:55:34 <dmead> yea
11:55:39 <dmead> one sec
11:55:40 <sjanssen> palomer: it isn't much of an optimization either, I imagine hugs would do the same because you aren't demanding the result of printUnifier
11:56:02 <Igloo> palomer: trace is not a safe function
11:56:03 <sjanssen> palomer: no it shouldn't.  We don't want trace to change the strictness properties of programs
11:56:10 <dnox> fac n = product [1..n]
11:56:19 <dave_m> most of the time I use trace, I'm trying to determine *whether* something gets evaluated
11:56:25 <Igloo> It should probably be called unsafeTrace
11:56:39 <palomer> sjanssen, we do!
11:56:47 <dmead> chessguys: maybe you need this http://haskell.org/tutorial/classes.html#sect5
11:56:50 <lambdabot> Title: A Gentle Introduction to Haskell: Classes, http://tinyurl.com/wzy3a
11:56:52 <sjanssen> palomer: no, not really
11:56:57 <palomer> yes, really!
11:57:01 <sjanssen> @palomer
11:57:01 <lambdabot> Hrmph, looks like I killed the channel
11:57:11 <chessguy> murderer!
11:57:11 <palomer> if we're using trace, then we need a trace
11:57:15 <dmead> @karma dmead
11:57:15 <palomer> we don't care what else happens
11:57:16 <lambdabot> You have a karma of 0
11:57:18 <palomer> we want our trace!
11:57:27 <dmead> @karma palomer
11:57:27 <lambdabot> palomer has a karma of 5
11:57:51 <sjanssen> palomer: okay, how do you want this to work: head [1, trace "foo" 2]
11:58:07 <glguy> > 41000 * (1.02) ^ 10
11:58:08 <lambdabot>  49978.77121978504
11:58:09 <glguy> > 41000 * (1.04) ^ 10
11:58:11 <lambdabot>  60690.01568165213
11:58:29 <dmead> > 5/0
11:58:31 <lambdabot>  Infinity
11:58:39 <dmead> heavy man, heavy
11:58:53 <palomer> sjanssen, I want it to print 2
11:59:01 <dmead> > 2
11:59:02 <sjanssen> palomer: after you answer that one, how should this work: head $ map (trace "foo") [1..]
11:59:02 <lambdabot>  2
11:59:03 <palomer> cuz it's a trace, goddammnit
11:59:18 <dmead> trace 2
11:59:20 <sjanssen> what you're asking for just isn't sane
11:59:21 <dmead> > trace 2
11:59:21 <palomer> sjanssen, I want that to never terminate
11:59:22 <lambdabot>  Not in scope: `trace'
11:59:28 <palomer> trace isn't sane!
11:59:31 <Igloo> palomer: What about    fac n = trace (show n) $ if n == 1 then 1 else n * fac (n-1)  ?
11:59:34 <palomer> the real world isn't sane!
11:59:37 <sjanssen> if you want your program to print stuff out, you use the IO monad
11:59:51 <palomer> that requires major refactoring
11:59:59 <palomer> and would makes things unsafe
12:00:05 <dmead> or break up your program in a do construction
12:00:15 <dmead> so you can show each stage
12:00:39 <palomer> you mean go in and out of my monad?
12:00:40 <palomer> I can't
12:00:51 <dmead> :s
12:00:52 <dave_m> you probably could put together a strict trace
12:00:58 <sjanssen> palomer: you're already in some kind of monad stack, yeah?  If you've designed carefully, you should be able to put IO at the top without too much work
12:01:20 <palomer> for what?
12:01:28 <palomer> to make my traces a little less awkward
12:01:32 <palomer> no thanks, mister!
12:01:44 * palomer joins mothers for easier traces
12:02:08 <palomer> trace already mangles everything, why not mangle things a little more to make it easier on little ol palomer
12:02:19 <dave_m> would something like, strace s a = trace s a `seq` a work?
12:02:46 <sjanssen> dave_m: possibly
12:03:09 <dave_m> or maybe just strace s a = trace s () `seq` a
12:03:13 <sjanssen> palomer: what you probably need is printUnifier' `seq` return (a, b')
12:03:23 <palomer> sjanssen, yeah
12:03:24 <palomer> awkward
12:03:26 <palomer> my traces used to work!
12:03:28 <palomer> what happened?
12:03:44 <sjanssen> palomer: in a different version of GHC, with the same source code?
12:04:31 <sjanssen> I'll bet you were in the ST monad, or some other strict situation
12:04:40 <palomer> dave_m, doesn't have the same type
12:04:51 <palomer> sjanssen, same monad, same everything, different ghc
12:05:13 <palomer> well, I'm off!
12:18:31 <sylvan> Is anyone working on a web browser written in Haskell? I'm sick of huge bloated browsers.. Firefox used to be good, but with all the stability issues and memory leaks it's as bad as IE. I think we need something written in a safe language for a change!
12:18:59 <Igloo> It would be cool, but a large task
12:19:16 <sylvan> I guess we could borrow something like the renderer from mozilla.
12:19:17 <Igloo> Boy, even just understanding the CSS spec would be a large job  :-)
12:19:22 <vegai> a HUGE task
12:19:43 <Igloo> I suspect you get most of the bugs if you do that
12:19:52 <sylvan> I wonder if you could take parts of firefox, and write the "core app" in Haskell, and then swap parts out one by one..
12:20:12 <vegai> there's a rather good tk-based html widget
12:20:28 <vegai> http://tkhtml.tcl.tk/
12:20:31 <lambdabot> Title: An HTML Widget For Tk
12:20:37 <Igloo> Writing the HTML layout engine feels like a very Haskelly task, too
12:20:37 <sylvan> Writing an HTML renderer in cario might be pretty fun, otoh
12:20:55 <sylvan> and if master CSS is difficult, then Haskell is surely the language to implement it in!
12:20:55 <vegai> yeah, it'd be quite impressive
12:22:53 <sylvan> vegai, that widget seems quite cool... appears to pass the acid2 test and everything
12:23:25 <vegai> sylvan: yes. I've used the test browser a bit, and it is quite good.
12:24:06 <chessguy> hmm, can i overload functions in haskell somehow? foo x = blah; foo x y = blah'
12:24:41 <sjanssen> chessguy: there is some overloading available with typeclasses
12:25:01 <sylvan> ad hoc overloading is a no-no though. You'll need to structure it up with a class
12:25:03 <sjanssen> but overloading based on the number of arguments isn't very workable in Haskell, due to currying
12:25:40 <sylvan> if you change the function to take a tuple, though, it's doable
12:27:08 * SamB does something he will probably regret
12:27:21 <sjanssen> no! don't do it!
12:27:34 <SamB> I threw a wrench into the typechecker
12:27:36 <sylvan> "unsafePerformIO
12:27:38 <sylvan> "
12:27:41 <SamB> (it wasn't working in that case anyway)
12:28:00 <SamB> I'm hoping maybe it will not matter greatly.
12:28:23 <SamB> anyway, thats only because I have no idea what I should really do...
12:28:48 <SamB> I have already reported the bug, I'm just too impatiant to wait for it to be fixed
12:30:12 * SamB is smart enough to run with -dcore-lint, though ;-)
12:31:51 <SamB> hmm, perhaps I really haven't thrown a wrench in it?
12:35:21 * SamB supposes it is quite possible the typechecker overdoes it a bit
12:36:47 <dave_m> Do not question the typechecker. The typechecker is your friend. The typechecker only wants what's best for everyone.
12:37:01 <chessguy> lol
12:37:51 <chessguy> i let haskell figure out an annoying typing problem i had the other day. i took my type definition out completely, tinkered with it until i got it working, then asked the interpreter what the heck the type was
12:38:37 <liyang> dcoutts: so... I managed to get the c2hs shipped with 0.9.10 to compile under GHC 6.6...
12:39:01 <dcoutts> liyang, that's not the mainline version of c2hs
12:39:14 <dcoutts> liyang, the current darcs version of c2hs builds with ghc-6.6
12:40:11 <liyang> Yes. I know. But I thought Gtk2Hs 0.9.10 required modifications to c2hs that weren't available (easily) elsewhere?
12:40:40 <dcoutts> liyang, ah you're trying to get Gtk2Hs 0.9.10 to build with ghc-6.6
12:40:57 <dcoutts> liyang, did you find those patches I was talking about
12:41:05 <dcoutts> ideally you can cherry pick those
12:41:05 <DRMacIver> Hm. I have a semi-offtopic question, but it's the sort of question a channel full of Haskell programmers might know the answer to. :) (It's related to type system design)
12:41:08 * liyang didn't try looking...
12:41:37 <liyang> I figured the compiler will probably tell me everything I'll need to modify. :)
12:41:46 <dcoutts> liyang, it's much harder than that
12:42:04 <dcoutts> liyang, I'd start by looking at the series of patches we applied recently to the mainline version of gtk2hs to make it build
12:42:12 <DRMacIver> I'm tinkering with the design of a hypothetical type system in which types can by subtypes of another (things like union types are the obvious example of this). Allowing a programmer to extend a type is easy. I'm wondering about how to allow a programmer to specialise a type in a sane way.
12:42:27 <Igloo> dcoutts: Weren't you going to do a new release?
12:42:31 <liyang> right, I'd better save the fun for tomorrow then...
12:42:35 <dcoutts> Igloo, we are, yes.
12:42:47 <dcoutts> Igloo, it's a matter of when.
12:42:53 <DRMacIver> e.g. I'd like them to be able to specify not just 'integer' but define a new type 'positive integer', and have this behave reasonably well in existing code (while ensuring type safety at compile time).
12:42:57 <Igloo> dcoutts: Tonight!  :-)
12:43:04 <dcoutts> Igloo, hah hah hah.
12:43:09 <liyang> Does it build?
12:43:11 <DRMacIver> I suspect this is impossible, but I'm wondering how close one can get.
12:43:13 <Igloo> dcoutts: What's the reason for later?
12:43:15 <liyang> Ship ship ship!
12:43:15 <dcoutts> liyang, yep.
12:43:27 <dcoutts> Igloo, we want to not break the API too often
12:43:42 <dcoutts> Igloo, so we want to get our API breakage sorted out
12:43:46 <dcoutts> do it all in one go
12:44:00 <dcoutts> so that means getting it right
12:44:29 <Igloo> Ah, hmm
12:44:33 <Maddas> DRMacIver: Er, are you saying that things liked types for integer ranges are impossible to get?
12:45:31 <DRMacIver> Maddas: No, I mean allowing specialisation of types in generality.
12:45:43 <liyang> dcoutts: ah hah! I lied. I did try to look at the recent changes to Gtk2Hs, but darcsweb.cgi on darcs.h.o borked with a UnicodeDecodeError so I gave up.
12:45:58 <dcoutts> liyang, use darcs itself.
12:46:22 <dcoutts> liyang, yeah, we have some patch authors with names in latin1
12:46:24 <liyang> yeah but but... :(
12:46:46 <DRMacIver> Maddas: I'd be pleasantly surprised if it were possible, it just seems unlikely.
12:47:35 <Maddas> DRMacIver: Ok, I don't know anything about type systems, I'm afraid :)
12:47:39 <liyang> This means I have to learn to drive darcs beyond the basic accelerator and brakes... :-/
12:48:09 <DRMacIver> I don't know much about them myself unfortunately. :)
12:48:31 <Codex_> drmaciver: cant you jsut do: f :: Integer->PositiveInteger, f=abs
12:48:50 <DRMacIver> I'm not sure what you're getting at.
12:49:00 <DRMacIver> I mean, of course you can, but I don't see why it's relevant. :)
12:49:13 <liyang> DRMacIver: so with dependent types, you can do what you've just described...
12:49:20 <dcoutts> liyang, darcs changes | less
12:49:55 <dcoutts> liyang, to go back in time and find the patches, did you save the dates of the patches I told you about ?
12:51:08 <DRMacIver> liyang: Hm. I'm not sure how. Unless you allow your types to be dependent on things like functions integer -> boolean. :)
12:51:30 <liyang> dcoutts: sorry, you might have to remind me. ^^;
12:51:56 * liyang is half-wondering whether this is a pointless expenditure of time...
12:52:17 <dcoutts> liyang, depends on when you want a 0.9.10 release by.
12:52:32 <liyang> dcoutts: when it's ready. :)
12:52:52 <dcoutts> liyang, then wait. As I said, we do plan to do a new release in the not too distant future.
12:52:59 <liyang> DRMacIver: the fourth example sheet on http://www.e-pig.org/darcs/g5bcfr/ gives an example in the form of the decrement : Nat -> Nat function.
12:53:02 <lambdabot> Title: Computer Aided Formal Reasoning
12:55:05 <liyang> dcoutts: *nod* Will just have to make up an excuse for bugs.debian.org then... :)
12:55:28 <dcoutts> liyang, blame upstream. Say that backporting the fixes it too hard.
12:55:42 <liyang> :)
12:56:04 <dcoutts> liyang, it's actually a significant change to the build system, it's not just FiniteMap and that kind of thing.
12:56:18 <dcoutts> the ghc package system added a new restriction
12:56:33 <dcoutts> which meant that we and several other packages could not build in the way we used to
12:56:54 <Igloo> dcoutts: Is the problem that the packages need to get installed in the middle?
12:56:55 <dcoutts> eg wxHaskell is still broken due to this
12:56:58 <dcoutts> Igloo, yes.
12:57:01 <DRMacIver> liyang: That doesn't seem terribly readable if one isn't familiar with epigram. :)
12:57:19 <liyang> DRMacIver: 'fraid not. Start with exercise sheet 1? :)
12:57:41 <Igloo> dcoutts: You could hack it by setting $HOME to inside the build tree and installing with --user then
12:57:43 <DRMacIver> liyang: But anyway, this seems to fail my guaranteeing type safety at compile time condition, or am I just confused?
12:57:59 <Igloo> liyang: Are there multiple Haskell packages in a single deb?
12:58:05 <arjanoosting> Igloo: ugghh, dirty hack :-)
12:58:14 <liyang> ah. Guess I don't want to be messing with build systems. :-/
12:58:21 <Igloo> arjanoosting: I don't claim otherwise  :-)
12:58:49 <dcoutts> Igloo, it's not where we register that's the problem. It's installing at all.
12:58:49 <liyang> Igloo: no no, I've split them up into glib/gconf/gtk/... debs.
12:58:59 <Igloo> dcoutts: I don't follow
12:59:01 <dcoutts> Igloo, we just use -package-conf package.conf.inplace
12:59:26 <dcoutts> Igloo, it's having to change to make it register that is the significant work
12:59:27 <Igloo> liyang: In that case another option would be to split it into separate source packages
13:00:19 <dcoutts> Igloo, --user vs -package-conf is an easy difference.
13:00:23 <Igloo> dcoutts: I'm not sure I see the difficulty. It should just be a well-placed make install prefix=`pwd`/... shouldn't it?
13:00:50 <dcoutts> Igloo, and changing all packages to not use -i depdirs
13:00:54 <Codex_> drmaciver: how about defining integers from positive integers using pairs and equivalence class a+b=c+d ?
13:00:59 <liyang> DRMacIver: in the case of the example, if you want calls to decrement to typecheck, you need to supply a proof that its argument is non-zero...
13:01:01 <dcoutts> Igloo, except for .chi files where it must use -i depdirs :-)
13:01:18 <Igloo> The chi files are needed internally but not externally?
13:01:25 <dcoutts> Igloo, yep.
13:01:32 <liyang> Igloo: I'm confused. Are you saying that I should split the source packages? What's wrong with the setup now?
13:01:57 <dcoutts> Igloo, I guess that in theory they could be used by an external package.
13:01:58 <Igloo> dcoutts: Oh, OK. Well, just have them installed anyway  :-)
13:02:12 <DRMacIver> Codex_: Sure, one could do that. But it's not really relevant. The point is that I want the programmer to be able to define the 'positive integer' type after the fact, once the language is already written and implemented, without having to hack around with the details of the compiler and representation. :)
13:02:17 <Igloo> liyang: I'm saying that would be one way of fixing the problem. Only it would also suffer from this chi problem
13:02:33 <dcoutts> Igloo, but how to refer to them... c2hs perhaps should ask ghc-pkg where the .hi files are and assume the .chi files will be in the same place.
13:02:42 <dcoutts> Igloo, but at the moment it doesn't.
13:02:48 <liyang> Igloo: that's the bit where I'm confused. What problem? ^^;
13:02:51 <DRMacIver> liyang: I see. Ish.
13:02:54 <Igloo> dcoutts: When do you need the chi files?
13:03:10 <Igloo> liyang: That gtk2hs's build system is incompatible with ghc 6.6
13:03:37 <DRMacIver> epigram looks interesting. I'm not totally sure I want to add yet another language to the list of ones I'm going to learn and then probably never use. It's already rather large. :)
13:03:37 <dcoutts> Igloo, when using c2hs to process .chs files that say: {# import Foo #}
13:04:08 <dcoutts> Igloo, it's not incompatible any more. It's fixed in the current darcs version of gtk2hs.
13:04:09 <liyang> Igloo: But that involves rolling my own build-system... I think waiting is the only realistic solution here. :-/
13:04:22 <dcoutts> Igloo, we register --force all the packages before building anything.
13:04:50 <dcoutts> Igloo, but all told the changes were not trivial. And they're a bit hard to back port because there were so many other changes in between.
13:05:04 <Igloo> Hmm, this all sounds quite scary
13:05:13 * arjanoosting really wonders how complicated the build system of gtk2hs is
13:05:27 * Igloo thinks you should just package it up as n cabal packages  :-)
13:05:28 <dcoutts> arjanoosting, 1.5k Makefile.am
13:05:35 <dcoutts> Igloo, so do I!
13:05:37 <arjanoosting> ugghh
13:05:55 <Igloo> dcoutts: So what's stopping you?  :-)
13:06:05 <dcoutts> Igloo, proper c2hs support in Cabal.
13:06:14 <dcoutts> .chs files have deps.
13:06:33 <dcoutts> Cabal does no dep analysis
13:06:39 <dcoutts> it relies on the compiler for the .hs deps
13:06:41 <Igloo> Ah. You should hassle the cabal developers about that then  :-)
13:06:48 <dcoutts> Igloo, good idea :-)
13:07:13 <dcoutts> one good thing about the gtk2hs build system is that in a built tree, running 'make' takes about 0.1 sec to do nothing.
13:07:34 <dcoutts> running make in a built ghc tree takes ages to figure out there is nothing to do
13:07:43 <SamB> yeah, that is lame lame
13:07:45 <dcoutts> and cabal isn't a whole lot better
13:08:23 <Igloo> GHC will hopefully become as good as Cabal * n soon
13:09:06 * Igloo wonders if arm will finish building ghc tonight
13:09:14 * SamB prefers Cabal / n
13:09:34 <glguy> heh, the more packages you add the faster it will run?
13:10:04 <arjanoosting> Igloo: did you have any progress on the FTFBS of hmake, happy and haskell-utils?
13:11:08 <Igloo> arjanoosting: We've got RCs for happy from Simon now. I'm hoping to get a release, but I'll stop waiting once I have ghc for arm
13:11:30 <Igloo> arjanoosting: The others I'm not expecting any problems for, I'll do an upload when I get a tuit
13:12:12 * Igloo was hoping mips and mipsel would build haskell-html before I do a second upload of all the other extralibs, but they seem to be doing their best not to
13:13:31 <dcoutts> Igloo, did you note the problem with the happy tarball needing happy to build ?
13:13:43 <Igloo> Yes
13:13:57 <dcoutts> Igloo, ok, good good :-)
13:14:21 <Igloo> But it's Simon who's putting the tarballs together  :-)
13:23:01 <dnox> anyone installed hs-plugins through mingw(win)?
13:29:47 <_frederik_> hello.
13:30:17 <_frederik_> any tips on debugging a ReadP parser? is there a way to get longest parse or something?
13:34:51 <SamB> @hoogle System.IO.IOError -> IO a
13:34:53 <lambdabot> No matches, try a more general search
13:34:57 <SamB> @hoogle IOError -> IO a
13:34:59 <lambdabot> Prelude.ioError :: IOError -> IO a
13:40:41 <_frederik_> :(
13:41:34 <_frederik_> i guess i should just use Parsec...
13:41:39 <monochrom> munch performs longest parse.
13:42:28 <_frederik_> that's not what i meant
13:42:48 <_frederik_> Parsec gives sensible error messages like 'expected ")"'
13:43:48 <_frederik_> with ReadP, there's no way to detect and identify the source of a failure - in many cases it would probably be ambiguous anyway
13:45:26 <monochrom> ReadP is for implementing fast ReadS routines, where parse errors are actually not anticipated.  So, little incentive for improving error tracking.
13:45:50 <_frederik_> i see
13:45:53 <monochrom> A lot of questions "why X does not feature Y" can be easily answered by putting things into perspective.
13:46:10 <_frederik_> yeah, everything should only be used for one thing
13:46:23 <musasabi> dcoutts: how is the optional deps situation with Cabal?
13:46:26 <_frederik_> otherwise it becomes unmanageable
13:47:09 * SamB never understood why ReadS would support ambiguous parsing...
13:47:46 <_frederik_> i'm being sarcastic by the way
13:48:10 <monochrom> There are some exceptions.  "Why GHC does not support debugging or at least tracing"  It is actually because it's too hard at the moment. :)
13:48:32 <SamB> isn't that also answered by putting things in perspective?
13:48:48 <SamB> like, you look like an ant next to a giant cliff perspective?
13:49:57 <_frederik_> if one put things in too much perspective, then one loses the will to live
13:50:08 <monochrom> I should really start my Haskell consulting business and solicit here.
13:50:11 <sjanssen> @hoogle bracket
13:50:12 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:50:12 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
13:50:12 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
13:51:54 <monochrom> When someone asks "I need to debug this project", I really want to offer "I'll do that for you as a consultant, US$100 per hour".
13:52:44 <monochrom> I thank the GHC people for not implementing some debugging support :)
13:53:58 <_frederik_> you're awesome
13:54:16 <monochrom> I'm old and wise.
13:54:26 <sjanssen> should GHC 6.6 be able to build GHC head?
13:56:22 <sjanssen> ah, looks like the bug was just checked in
13:57:22 <chessguy> monochrom, probably the only way you'd get paid to program in haskell
14:00:03 <monochrom> If I want to sit in Canada, yeah.
14:00:27 <chessguy> or the US
14:00:32 <monochrom> US$100 is #haskell special discounted price. :)
14:00:51 <monochrom> If I go to US I would go to Galois.com or OGI and get paid there.
14:02:45 <chessguy> hmm, smame Galois.com isn't filling any entry level positions
14:03:58 <chessguy> *shame
14:05:58 <tmorris> is there a hexadecimal Integral literal?
14:06:42 <ThreeQ> > 0xff
14:06:44 <lambdabot>  255
14:06:57 <ThreeQ> ?type 0xff
14:06:58 <lambdabot> forall t. (Num t) => t
14:06:58 <dibblego> ah thanks
14:07:07 <dibblego> > 070
14:07:08 <lambdabot>  70
14:07:12 <sieni> > e^(0xff)
14:07:14 <lambdabot>  Not in scope: `e'
14:07:15 <dibblego> no octal?
14:07:16 <sieni> oops
14:07:20 <monochrom> http://haskell.org/onlinereport/   has information, for your future reference.
14:07:20 <lambdabot> Title: The Haskell 98 Language Report
14:07:29 <sieni> > 2.5^(0xff)
14:07:31 <lambdabot>  2.983336292480084e101
14:07:36 <thebug> > 0155
14:07:37 <lambdabot>  155
14:08:01 <thebug> dibblego: sure doesn't look like it
14:08:22 <dibblego> > 0o70
14:08:23 <lambdabot>  56
14:10:00 <dibblego> > 0xFF
14:10:02 <lambdabot>  255
14:10:07 <dibblego> > 0Ff
14:10:08 <lambdabot>  Not in scope: data constructor `Ff'
14:12:37 <monochrom> http://haskell.org/onlinereport/   has information, for your future reference.
14:12:38 <lambdabot> Title: The Haskell 98 Language Report
14:13:45 <arjanoosting> @seen CosmicRay
14:13:45 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I don't know when CosmicRay last spoke.
14:16:09 <dibblego> thanks
14:17:40 <xerox> dcoutts!!
14:17:44 <xerox> dcoutts_!!
14:17:54 <xerox> (Too many dcoutts.)
14:18:03 <dcoutts> :-)
14:18:25 <xerox> I'll be there.
14:18:35 <xerox> I've got a place to stay for 4 days.
14:18:39 <xerox> Around the 27
14:18:41 * dcoutts is on phone
14:18:49 <xerox> Later :)
14:23:25 <nomeata> any haskell users from ghana here? :-)
14:26:16 <Patterner> probably unlikely
14:29:50 <chessguy> @type concat
14:29:52 <lambdabot> forall a. [[a]] -> [a]
14:30:48 <nomeata> Patterner: though so. Just makeing sure I donât miss someone interesting here.
14:37:17 <roconnor> Haskell 98 report: Underscore, "_", is treated as a lower-case letter, and can occur wherever a lower-case letter can.
14:37:25 <roconnor> so what's the problem?
14:38:35 * glguy wonders where that came from
14:38:47 <SamB> roconnor: the problem is that Yhc is crazy?
14:39:07 <roconnor> http://hackage.haskell.org/trac/haskell-prime/wiki/Underscore
14:39:10 <lambdabot> Title: Underscore - Haskell Prime - Trac, http://tinyurl.com/yy2aoq
14:39:35 <roconnor> Caseless underscore is implemented in nhc98 by default, H'98 behaviour requires the -underscore option.
14:40:03 <glguy> roconnor: it would allow you to write
14:40:06 <SamB> heh
14:40:07 <glguy> _somevar_
14:40:19 <SamB> I like that thing about the composites and primes...
14:40:28 <roconnor> I tried -98 on yhc and it died.
14:40:30 <roconnor> :(
14:40:37 <roconnor> maybe I should try -underscore
14:41:02 <roconnor> glguy: I have a function called __, and yhc won't complie it. :(
14:41:16 <glguy> _varNamedLikeSomeoneWhoUsesBadOOPracticesForPrivateVariableNames
14:41:43 * roconnor wonders how hard it would be to get -98 to work.
14:42:08 <glguy> s/Like/By
14:43:56 <roconnor> Is it possible to comment on the trac
14:44:15 <roconnor> I could mention the use of __ in the ``wild''.
14:45:20 <lispy> roconnor: __ seems like an identifier just waiting to cause bugs
14:45:27 <dnox> fac 0 = 1 fac n = n * fac (n-1) ............ fac n = product [1..n] This may also be more efficient as product might be optimized by the library-writer... In GHC, when compiling with optimizations turned on, this version runs in O(1) stack-space, whereas the previous versions run in O(n) stack-space.
14:45:30 <dnox> is this true?
14:45:59 <roconnor> dnox: looks true to me.
14:46:02 <dcoutts> xerox, cool. So can I persuade you to come up to Oxford for a day ? :-)
14:46:11 <dcoutts> xerox, I've got a spare room with a bed.
14:46:18 <dnox> about that the second one would be faster than the first
14:46:23 <ski> prolog impl. treat vars beginning with '_' as a hint to not warn about "unused" vars
14:46:37 <roconnor> dnox: I believe laziness will delay the evaluation of the product until the entire stack of n of them are allocated.
14:46:47 <roconnor> in the first case
14:46:53 <xerox> dcoutts, yes you can!
14:46:55 * xerox hugs dcoutts
14:47:13 <xerox> I think I'll be free on monday, I'm not 100% sure
14:47:16 <roconnor> in the secondcase, product is implemented using foldl', which uses seq to force the early evaluation.
14:47:19 <xerox> Tomorrow I'll know the precise days
14:47:21 <dcoutts> xerox, cool
14:47:47 <xerox> Yeah, I like the idea of coming up there again.
14:47:50 <dcoutts> xerox, any day is fine, but I have some teaching to do on Mondays and Tuesdays
14:48:03 <xerox> Cool, I want to sneak in your class :D
14:48:09 <dcoutts> ha ha ha
14:48:09 <xerox> Can people do it in uk?
14:48:12 <roconnor> re: empty data types
14:48:15 <xerox> They can in it.
14:48:18 <xerox> ".it"
14:48:25 <dcoutts> xerox, yeah, you can just walk in :-)
14:48:28 <xerox> I should call nations by their name not their tld...
14:48:32 <dcoutts> heh
14:48:33 <roconnor> Obviously magic :: Void -> a should be enough for the function declaration
14:48:33 * xerox grins
14:48:35 <xerox> Cool!
14:49:04 <ski> roconnor : ?
14:49:26 <lispy> roconnor: i think you meant magic :: Intercalate -> a
14:49:47 <sjanssen> @djinn Intercalate -> a
14:49:48 <lambdabot> -- f cannot be realized.
14:50:13 <roconnor> ski: if there are no constructors, then all you need is a type declaration as there are no patterns to match.
14:50:34 <ski> ah, you meant that ..
14:50:41 <ski> .. yes that could be argued
14:50:49 <ski> you could also do
14:50:55 <ski> magic v = case v of { }
14:51:02 <roconnor> yes
14:51:13 <roconnor> but obviously that is equivalent ;)
14:51:23 <ski> (to emphasize that you've not just forgotten to give clauses)
14:51:28 <lispy> why not magic = undefined?
14:51:43 <sjanssen> > case () of { }
14:51:44 <lambdabot>  Parse error
14:51:44 <roconnor> lispy: but why bother with anything?
14:52:03 <ski> sjanssen : unfortunately, yes
14:52:47 <roconnor> any function that has a Void parameter type needs no body.
14:53:24 <ski> how to determine this in general ?
14:53:43 <sjanssen> roconnor: untrue
14:53:44 <ski> surely argument type '(Void,a)' will need no cases, too
14:53:53 <ski> but '[Void]' will
14:54:08 <roconnor> ski: yes you are right.
14:54:37 <roconnor> I assume this can be figured out the same way that we currently figure out if pattern matching is total.
14:54:48 <ski> m, yes
14:55:24 <ski> hm, i wondered today whether it would be nice to define GADT datatypes by cases
14:55:58 <ski> data Vector  Zero    a = Nil
14:56:24 <ski>      Vector (Succ n) a = Cons a (Vector n a)
14:56:33 <SamB> huh
14:56:41 <ski> instead of
14:56:52 <ski> data Vector :: * -> * -> *
14:56:54 <ski>   where
14:56:58 <SamB> but, you know, the ordinary "data" syntax is horrid anyway
14:57:00 <xerox> Vectors, eh
14:57:06 <ski>   Zero :: Vector Zero a
14:57:14 <lispy> to make it match function declarations you'd probably want to repeat 'data' on each new line
14:57:22 <ski> (er s/Zero/Nil/)
14:57:37 <ski>   Cons :: a -> Vector n a -> Vector (Succ n) a
14:57:48 <SamB> that sounds suspiciosly like type families...
14:58:11 <SamB> ... except you can't case over them yet...
14:58:21 <ski> this would just be an alternative syntax for GADT
14:58:39 <xerox> Shouldn't Vector be a class?
14:59:13 <ski> xerox : ?  (this was just a simple standard example of index type)
14:59:31 <xerox> ski: I'm thinking of Vector Spaces.
14:59:54 <lispy> ya know, i bet GADTs would be useful for my intermediate code representation in my compiler
14:59:55 <ski> aha, that's another thing
15:01:54 <ski> (lispy : maybe)
15:02:07 <xerox> :D
15:02:19 <xerox> ski: that's what I have in mind, I'm studying on Lang's book these days,.
15:03:00 <ski> vector spaces seem to have strange relations to logic
15:03:08 <sieni> ski: how?
15:03:23 <ski> (well, i should say *linear* logic)
15:03:53 <ski> transpose is contraposition, i think
15:04:13 <ski> direct sum is (additive) conjunction, as well as disjunction
15:04:42 <ski> the one-point vector space is (additive) true, as well as false
15:05:38 * lispy had a random probably non-sensical thought, "If the type system is turing complete, what about the rules for modifying syntax...maybe they could be 'turing complete' as well..."
15:05:41 <ski> the space with one base point (~= underlying field) is (multiplicative) true, as well as false
15:06:00 <xerox> ski: do you know about Topos Theory?
15:06:15 <ski> xerox : a little, yes
15:06:20 <xerox> ski: I bet that's fun
15:06:43 <xerox> ski: I've read about it in the "Weekly" of that Physicist Mathematician...
15:06:55 <ski> hehe
15:06:59 <ski> John Baez
15:07:02 <xerox> Right!
15:07:05 * Igloo hands lisp tex
15:07:12 <sieni> physicist mathematician? what an insult ;-)
15:07:13 <Igloo> s/lisp/lispy/
15:07:16 <xerox> Lots of fun stuff in his "weekly discoveries.."
15:07:38 <sieni> well, not rly
15:07:55 <cjeris> can i belabor the channel with dumb monad questions again?  i tried to make a state-like monad where the state-modifying actions are "add an integer".
15:07:58 <lisppaste2> cjeris pasted "attempt at state monad with 'add integer' for action" at http://paste.lisp.org/display/28634
15:08:01 <xerox> ski: the library of the mathematics department here is entitled to Peano! He's studied here!
15:08:17 <sieni> it's funny that a mathematician doing physics related stuff is called "mathematical physicist"
15:08:18 <cjeris> do i have basically the right idea?
15:08:20 <ski> (btw, the "logic" of vector spaces is an incosistent logic .. because there's always a null morphism between any two vector spaces .. so anything can be "proved")
15:08:49 <mauke> cjeris: looks ok
15:08:57 <ski> xerox : where ?
15:09:18 <xerox> ski: Turin.
15:09:20 <cjeris> i can do let m = IntM (\n -> ('c', n+1)) in let m' c = IntM (\n -> ([c], n+2)) in let IntM x = (m >>= m') in x 3 ... and get ("c", 6).
15:10:19 <xerox> integral: so, will you be around, at Google London?
15:10:49 <cjeris> mauke: ok, maybe the fizzing-noise-making light bulb is turning on a little bit
15:11:09 <ski> cjeris : that paste looks ok
15:11:26 <lispy> Igloo: heh, is that meant to scare me away from the idea? ;)
15:11:40 <xerox> ski: I've started Mathematics there :)
15:11:50 <cjeris> thank you, mauke, ski!
15:11:52 <Igloo> lispy: Not at all, just giving you the language of your dreams
15:12:08 <ski> cjeris : you might want to define some primitive(s) for handling the state, instead of manually using 'IntM' when you build your applied actions
15:13:23 <ski> cjeris : e.g. let m = tick >> return 'c'; m' c = tick >> tick >> return [c] in run (m >>= m') 3
15:15:12 <cjeris> ski: so tick :: IntM (), tick = IntM (\n -> ((), n+1)) ?
15:18:22 <ski> cjeris : yes
15:18:58 <ski> you could also define any of
15:19:04 <ski> get :: IntM Int
15:19:15 <ski> set :: Int -> IntM ()
15:19:20 <xerox> ski: did you see mauke's last crazy tought?
15:19:24 <xerox> thought
15:19:34 <ski> change :: (Int -> Int) -> IntM ()
15:19:47 <lispy> an int monad?
15:19:49 <ski> xerox : no, where ?
15:19:53 <xerox> http://paste.lisp.org/display/28401
15:19:59 <ski> lispy : state monad with int state
15:20:41 <glguy> ?type do { a <- get; liftIO $ print a; Control.Monad.Writer.tell $ "found a " ++ show a; case a `mod` 2 of {0 -> Control.Monad.Error.throwError "even number"; 1 -> put $ a + 2 }}
15:20:43 <lambdabot> forall s (m :: * -> *). (Control.Monad.Writer.MonadWriter [Char] m, Control.Monad.Error.MonadError [Char] m, MonadState s m, Integral s, MonadIO m) => m ()
15:22:28 <cjeris> ski: ok, I see set n = IntM ((), n), change f = IntM (\n -> ((), f n)).  not sure i see how get works.
15:23:33 <ski> just take the state both as "return value" and next state
15:23:36 <monochrom> mauke is not crazy
15:23:51 <ski> (and you need to fix that 'set')
15:23:52 <lispy> monochrom: yet
15:23:55 <xerox> hehe
15:24:07 * ski grins
15:24:27 <ski> why is 'Eq' (and 'Show') given for functions, there ?
15:24:47 <xerox> Num!
15:24:55 <ski> _functions_
15:25:32 <lispy> yeah, what was he doing?
15:25:35 <xerox> O_o
15:25:52 <lispy> i mean, suppose we ignore Eq and Show instances, what's up with the rest?
15:26:10 <cjeris> ski: oh, right, set = IntM (\n -> ((), n)), but get = IntM (\n -> (n, n)) ?
15:26:10 <xerox> G'night.
15:26:12 <ski> xerox : am i missing where s/he needs that for monadic numbers ?
15:26:15 <lispy> monadic versions of the number functions?
15:26:26 <ski> cjeris : try it :)
15:26:37 <xerox> ski: hehe no idea.
15:26:41 <xerox> ski: ask monochrom ;)
15:26:49 <cjeris> ok, I see how that works, it sticks a prism in the state beam to shine it out to the side.
15:27:03 <ski> hehe, nice explanation :)
15:27:09 <lispy> then you could do, return 1 + return 2 and get something weird right?
15:27:09 <mauke> ski: it's as easy as 1 2 3 :-)
15:27:19 <monochrom> You can now write "pi * (f + g)" as a shorthand for \x -> pi * (f x + g x)
15:27:31 <lispy> ah
15:27:37 <ski> mauke : you want to be able to type '1 2 3' ?
15:27:38 <lispy> because of Reader?
15:27:48 <mauke> ski: yes, and it works!
15:28:01 <lispy> what does 1 2 3 do?
15:28:10 <cjeris> ski: thanks much, i may sort of be getting it.
15:28:25 <mauke> lispy: evaluate to 1
15:28:33 <lispy> why 1?
15:28:36 <ski> mauke : have you tested that one ?
15:28:38 <lispy> > (1 2) 3
15:28:39 <mauke> ski: yes
15:28:39 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
15:28:40 <lambdabot>   In the definition ...
15:28:55 <ski> '1 2' i see, but not '1 2 3'
15:28:57 <dcoutts> musasabi, re confiurations...
15:29:11 <xerox> 1 is really \_ -> 1 right?
15:29:15 <mauke> 1 2 3 == (return (return 1) 2) 3 == (const (const 1) 2) 3 == (const 1) 3 == 1
15:29:58 <musasabi> yes
15:29:59 <xerox> G'night again :)
15:30:04 <lispy> from the definitions in that paste how does 1 2 3 == (return (return 1) 2) 3?
15:30:08 <dcoutts> musasabi, so we need to re-propose our best idea and get discussion going again. I'll try and write something.
15:30:36 <mauke> lispy: because it knows 1 has to be a function from the code
15:30:37 <dcoutts> musasabi, I think our last proposal was pretty good, so I'll just try to write it out again.
15:30:39 <ski> don'tya mean  1 2 3  =  return (return 1 2) 3  =  const (const 1 2) 3  ?
15:30:55 <mauke> maybe, I'm not sure
15:31:20 <ski> (hm, that would explain the "nestedness" without monad transformers)
15:31:37 <lispy> what is this?
15:31:38 <lispy> -fallow-incoherent-instances
15:31:50 <ski> a ghc option
15:31:54 <lispy> :)
15:31:58 <lispy> yes, but what does it mean
15:32:13 <lispy> what makes an instance incoherent
15:32:31 <ski> probably something like
15:32:42 <ski> instance C Int a where foo = ...
15:32:51 <ski> instance C a Bool where foo = ...
15:33:00 <ski> (and no 'instance C Int Bool')
15:33:20 <lispy> ah okay
15:33:21 <ski> so it could choose either 'foo' implementation, an no one is more specific than the other
15:33:48 <ski> (there's another option for just allowing when an instance is more specific than another, i think, but i don't recall the name)
15:33:56 <ski> s/an no/and not/
15:34:06 <ski> (er, scratch that)
15:34:17 <musasabi> dcoutts: getting even something that works with explicit flags would help if we cannot get unity on the rest.
15:35:26 <dnox> http://www.willamette.edu/~fruehr/haskell/evolution.html
15:35:29 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
15:40:01 <sieni> w
15:41:31 <cjeris> possibly old joke: so i just told my wife "i may actually be figuring out this monad thing", and her reply was "monad? is that like when you only have one ball?"
15:41:52 <cjeris> completely instant and innocent reply.
15:44:53 <glguy> cjeris: I can't wait to hear what she says when you tell her about unix
15:45:42 <sieni> glguy: lol
15:46:13 <sieni> glguy: http://www.thinkgeek.com/images/action/old/t-chix-3.jpg
15:46:16 <lambdabot> http://tinyurl.com/u7bnp
15:46:20 <monochrom> Hee hee hee
16:00:48 <satan> time for a category theory question :O
16:01:12 <monochrom> really evil
16:01:32 <satan> so to prove that something is a morphism, one has to show that it's associative, and that an identity morphism exists for every object in a category
16:02:07 <satan> how would i go about doing that? does anyone have any examples of category theory proofs or links on the web?
16:02:14 <monochrom> I don't like that wording, but I guess yes, if only I knew what you meant.
16:02:19 <satan> lol
16:02:26 <satan> http://en.wikipedia.org/wiki/Morphism
16:02:37 <satan> and the 'must staisfy 2 axioms' bit below the diagram
16:03:41 <sieni> satan: don't know about web, but e.g. http://en.wikipedia.org/wiki/Categories_for_the_Working_Mathematician is a classic book
16:03:45 <lambdabot> http://tinyurl.com/yb7wkp
16:04:38 <satan> hmm if only the book was available
16:04:54 <satan> thanks sieni
16:05:30 <monochrom> OK I'll just talk pass you.  One could propose this: sets are objects, functions are morphisms, function composition is the composition operator, identity functions are identity morphisms.  You show that function composition is associative, then you're done.
16:05:32 <sieni> well, maybe it's available as a torrent somewhere, if you don't want to invest in a dead-tree edition
16:05:39 <jgrimes> satan, Cale mentioned this link the other day, it has a collection of introductory category theory notes available. http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html
16:05:42 <lambdabot> Title: Books, http://tinyurl.com/yj25mf
16:05:52 <jgrimes> in book form
16:05:53 <jgrimes> :)
16:06:13 <satan> monochrom: thanks
16:06:25 <satan> jgrimes: k im looking it up :)
16:07:08 <monochrom> Your wording is totally off because "it [morphism] is associative" is evidence for not reading whatever you cite.
16:07:50 <Cale> Yeah, that intro to category theory is interesting, it's primarily focused around how category theory is related to order theory.
16:08:39 <satan> monochrom: fair enough
16:13:30 <dons> morning
16:13:30 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:13:47 <jgrimes> morning dons :)
16:15:04 <dons> ?uptime
16:15:05 <lambdabot> uptime: 21h 10m 15s, longest uptime: 6d 15h 1m 36s
16:15:25 <dons> ?users
16:15:25 <lambdabot> Maximum users seen in #haskell: 256, currently: 223 (87.1%), active: 41 (18.4%)
16:15:38 <dibblego> dons, is that offer to review an article (21 pages) still standing?
16:16:09 <x3m> dons: how do i uninstall hs-plugins that we installed before?
16:16:24 <x3m> i could just remove the files but is that enough
16:16:34 <dons> remove the files, and ghc-pkg unregister plugins
16:16:42 <dons> dibblego: hmm, yes?
16:16:49 <x3m> okay
16:16:56 <dibblego> dons, great, I'll send it soon :) thanks
16:17:06 <dibblego> dons, the first cut for review
16:17:09 <x3m> i got mingw installed now at least
16:18:05 <dons> cool
16:18:17 * dons -> coffee. back in 5
16:20:47 <SamB> I tried to port some of MTL to use ATs. but guess what?
16:22:07 <monochrom> AT = arrow transformer?
16:22:24 <SamB> no!
16:22:27 * SamB groans
16:22:31 <SamB> Associated Types
16:23:07 <monochrom> Sorry I â¥ arrows
16:24:14 <SamB> yeah, but this is the MTL we are talking about!
16:24:32 <SamB> not some ATL that is somehow "inspired" by the MTL
16:27:47 <lispy> SamB: what? (it's me guessing what)
16:27:58 * SamB groans
16:28:25 <SamB> anyway, it turns out ChilliX hasn't yet implemented associated type synonyms
16:28:54 <SamB> which are critical to porting the MTL
16:40:57 <SyntaxNinja> @see Igloo
16:40:58 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1h 24m 19s ago.
16:42:19 <SyntaxNinja> is there any darcs-smart folks who can look at the ghc repo and see why 'darcs repair' is failing?
16:44:11 <lispy> SyntaxNinja: no error message?
16:44:12 <SyntaxNinja> I is talk real good
16:44:21 <lispy> just something stupid like, "darcs failed"
16:44:22 <lispy> ?
16:44:34 <SyntaxNinja> well, it's not on my screen; I'm helping someone else, and I was hoping Igloo or someone could jump in and debug it directly.
16:44:56 <arjanb> does darcs check tell anything?
16:45:01 <SyntaxNinja> I think it complains that it can't rmdir 'current' because it's non-empty. 'check' says that its inconsistent.
16:45:35 <Igloo> "the" ghc repo as in on darcs.h.o?
16:45:37 <SyntaxNinja> I didn't break it, btw :P
16:45:39 <SyntaxNinja> Igloo: ja!
16:45:44 <Igloo> Sure, sure  :-)
16:45:54 <SyntaxNinja>  \msg Igloo it was andy gill
16:45:56 <SyntaxNinja> oops!
16:46:03 <lispy> ah, if it's that repo i certainly can't help :)
16:46:20 <arjanb> that sounds like a corrupted patch..
16:46:27 <lispy> (unless a getted copy has the problem)
16:46:42 <SyntaxNinja> the getted copy doesn't have the problem.
16:46:56 <SyntaxNinja> there was some emacsing of pristine and a ~ file involved, I'm led to believe.
16:47:42 <lispy> hmm...that sounds like someone was using unsafePerformPristineEdit
16:48:04 * lispy puts the bad jokes a way for a while
16:49:24 <Cale> be on the lookout for quantum pixie trolls.
16:49:41 <lispy> Cale: i have enough trouble sleeping as is
16:49:47 <Cale> heh
16:50:07 <Cale> qpt is a "famous" troll and just made a very brief appearance in #math
16:54:14 <SyntaxNinja> hi andygill
16:55:14 <lispy> ATs look a lot like ocaml functors to me
16:55:55 <SamB> SyntaxNinja: your "darcs repair" is failing because the --partial support is horrible?
16:56:05 * Igloo doesn't understand this on many levels
16:56:33 <Igloo> It works on a copy (which could mean it's an ownership thing), and you ought to be able to rename non-empty directories
16:56:51 <SamB> oh
16:57:01 <SamB> he's actually trying to do it on the real GHC repo?
16:57:09 <Igloo> Ah, it's complaining becuase current-old already exists
16:57:19 <andygill> darcs check gives a hint to what is wrong. And there is now a current and old-current, which are different.
16:57:41 <Igloo> OK, should be fixed now
16:57:47 <dons> Cale: oh, you think he might follow you?
16:57:55 <andygill> but the current old contains real stuff, right?
16:57:57 <monochrom> Yah, AT unifies ML modules with Haskell type classes.
16:58:20 <Igloo> What do you mean by "real"?
16:58:25 <SamB> and its real handy for, yaknow, the MTL ;-)
16:58:37 <Igloo> I fixed it by moving current and current-old out of the way and running darcs repair
16:58:49 <Igloo> So anything in _darcs/patches is applied, and nothing else
16:59:04 <andygill> Sure, thanks.
16:59:15 <Igloo> There are some changes in the working directory now, though
16:59:16 <SyntaxNinja> andygill: knows the MTL :)
16:59:18 <andygill> Do you want me to apply my hpc changes now?
16:59:27 <Igloo> Or maybe it's just junk in pending
16:59:35 <SamB> SyntaxNinja: hmm?
16:59:42 <Igloo> andygill: Hang on a tick
16:59:48 <lispy> andygill: ah! we're gonna get hpc soon?
16:59:50 * lispy dances
17:00:00 <lispy> andygill++
17:00:19 <lispy> monochrom: interesting...guess i should go learn about them soon
17:00:27 <SamB> for some reason the MonadError port I did to Phrac isn't in the Phrac repo yet
17:00:28 * lispy tries to not be distracted
17:00:34 <andygill> hpc real soon now. hopefully with the markup tools this week.
17:00:47 <lispy> andygill: thanks
17:01:03 <SamB> possibly related to the fact that I only just sent it to ChilliX 5 or 10 minutes ago ;-)
17:02:14 <dibblego> terminology; declared with the data keyword is a "data type", with the class keyword is a "type class", with the type keyword is a "type alias" -- correct?
17:02:52 <Igloo> andygill: OK, go ahead
17:03:09 <SamB> dibblego: or "type synonym"
17:03:11 <mauke> dibblego: yes
17:03:18 <Cale> dons: that's been the pattern in the past
17:03:28 <Cale> dons: (it's the same guy)
17:03:31 <dibblego> thanks
17:03:39 <mauke> data = struct/union, class = interface, type = typedef :-)
17:03:47 <fons> hi all!
17:04:02 <dmead> ;o
17:04:18 <SamB> newtype = single-field struct ;-)
17:04:23 <fons> I'm porting a C library to haskell
17:04:48 <dibblego> is there any major different between data T = T X Y and (X, Y) ?
17:05:02 <SamB> yes
17:05:05 <Igloo> I don't suppose anyone has a Haskell binding got dlopen and friends?
17:05:10 <SamB> T doesn't take arguments
17:05:10 <fons> the library has callbacks, and those callbacks have handlers, modelled in C as void pointers (the handler representation is chosen by the user)
17:05:18 <SamB> and (,) has a lot of instances
17:05:40 <SamB> Prelude> :i (,)
17:05:40 <SamB> data (,) a b = (,) a b  -- <wired into compiler>
17:05:40 <SamB> instance (Bounded a, Bounded b) => Bounded (a, b)
17:05:40 <SamB>         -- Imported from GHC.Enum
17:05:40 <SamB> instance (Eq a, Eq b) => Eq (a, b)      -- Imported from Data.Tuple
17:05:40 <SamB> instance (Ord a, Ord b) => Ord (a, b)   -- Imported from Data.Tuple
17:05:42 <SamB> instance (Read a, Read b) => Read (a, b)        -- Imported from GHC.Read
17:05:44 <SamB> instance (Show a, Show b) => Show (a, b)        -- Imported from GHC.Show
17:06:04 <fons> I modelled the handlers in Haskell with polymorphic parameters which later will be substituted by the handler type chosen by the user of the library
17:06:07 <lispy> fons: in a functional language you can just use functions as parameters to get the same behavior as a call back
17:06:26 <fons> lispy, (thats not the problem :P)
17:07:38 <fons> my problem is that .... in order to export a Haskell function to C (which is something I need to do in order to create a C wrapper) FFI doesn't allow polymorphic parameters in export statements
17:08:25 <SamB> not even in Ptrs?
17:08:26 <Igloo> fons: You could make it storable and pass out a pointer
17:08:36 <dons> Cale: oh, has it always been the same guy following you over? the bird -pasting guy?
17:08:38 <fons> which it makes sense unless those parameters are used within a pointer
17:08:45 <SamB> I think you can import/export things involving "Ptr a"...
17:09:04 <SamB> FunPtr too
17:09:24 <Cale> dons: yep
17:09:25 <fons> Uhm didn't try with Ptr, but I did with StablePtrs
17:09:38 <dons> ndm, python search engine, http://www.google.com/coop/cse?cx=010104417661136834118%3Aat1-hsftvfo
17:09:40 <lambdabot> Title: Google Co-op - Custom Search Engine, http://tinyurl.com/y5ryff
17:09:51 <Cale> dons: He was annoying kuro5hin for years
17:09:57 <fons> and didn't work
17:10:01 <dons> Cale: ah.
17:10:12 <Igloo> fons: What went wrong?
17:10:14 <palomer> <:o
17:10:45 <palomer> I went to see the supervisor whom I was running away (to asia) from
17:10:55 <palomer> when I finished my meeting, my body was in knots
17:11:12 <palomer> she also has a lot more grey hair
17:11:15 <palomer> she's a witch!
17:11:21 <fons> Igloo, let me get a simple example to show
17:11:42 <lispy> palomer: it's funny that we had the same advisor and we've never met in person
17:12:22 <monochrom> that's because palomer ran away
17:12:48 <palomer> lispy, who's your advisor?
17:13:05 <lispy> currently? no one, but once i do some paper work it will be droundy
17:13:14 <palomer> never heard of'em
17:13:19 <palomer> my official advisor is prakash
17:13:21 <lispy> darcs author
17:13:29 <palomer> but my real advisor is the witch!
17:13:34 <lispy> heh
17:13:39 <lispy> i was just teasing
17:13:45 <lispy> my old advisor was a witch
17:14:18 <palomer> who was it??
17:14:31 <dcoutts> musasabi, you about ?
17:15:11 <dcoutts> musasabi, I've got a dark corner of the configurations Q I'd like to talk about.
17:16:01 <dons> lispy: droundy's going to be your supervisor? cool!
17:16:23 <lispy> dons: yeah, i just need to have the department 'appoint' him to advise a CS student
17:16:47 <dcoutts> cool :-)
17:16:57 <fons> ok I know were the problem comes from
17:17:05 <lispy> (droundy is in physics at my uni so that works out pretty cool)
17:17:33 <SamB> funny how that works ;-)
17:17:49 <palomer> lispy, you were in montreal?
17:17:57 <lispy> palomer: no :)
17:18:08 <lispy> palomer: did you get the /msg i sent you?
17:18:13 <fons> let me rephrase the problem
17:18:15 <andygill> Igloo, I've still got a problem with darcs here.
17:18:20 <dons> oh, did DRMacIver move from harvard (?) or did lispy move?
17:18:23 <dons> s/droundy/
17:18:27 <dons> tabs grumble grumble
17:18:36 <lispy> droundy moved
17:18:37 <Igloo> andygill: What's up?
17:18:42 <lispy> he got a job atOSU
17:18:42 <andygill> if ghc-HEAD is cleanly checked out --partial version.
17:18:44 <monochrom> DRMacIver was and is in Britain
17:18:47 <lispy> as a professor!
17:18:54 <andygill> darcs get ghc-HEAD ghc-HEADCOPY gives ...
17:18:58 <palomer> lispy, we never had the same advisor!
17:19:06 <Igloo> andygill: You need --partial when getting a partial repo
17:19:08 <palomer> you must be confusing me for someone else, bucko
17:19:14 <andygill> Copying patch 20 of 14874...darcs: /home/andy/darcs/ghc-HEAD/_darcs/patches/20061021035829-6295e-23f ... f5f0fc.gz: openBinaryFile: does not exist (No such file or directory)
17:19:19 <lispy> palomer: it was a bad joke...
17:19:23 <lispy> palomer: sorry :)
17:19:29 <fons> I have a plugin library ... each plugin file needs to have a descriptor lookup function
17:19:30 <palomer> it was awful.
17:19:36 <fons> class LadspaPlugin id hd where
17:19:36 <fons>   descriptor :: Int -> Maybe (Descriptor id hd)
17:19:36 <monochrom> It was a joke on being supervised by witches.
17:19:53 <fons> that function needs to be accesible by the host (and thus exported to C)
17:20:04 <Igloo> andygill: There are 19 patches since the last checkpoint, and that's just it trying to get the 20th patch. Give it --partial and it should work
17:20:14 <monochrom> "My wife is a bitch."  "That must be my wife too!  Bitch!"   XD
17:20:42 <Pseudonym> I'm trying to imagine being supervised by witches.
17:20:51 <palomer> but mine is a genuine witch
17:20:54 <lispy> Pseudonym: just read harry potter
17:20:55 <monochrom> Watch Fantasia
17:20:56 <palomer> she also has terrible posture
17:20:58 <fons> for that purpose I have this function .... descriptorPtr :: LadspaPlugin id hd => CULong -> IO (StablePtr (Descriptor id hd))
17:21:17 <Pseudonym> "By the Goddess, that paragraph is poorly written.  Blessed be!"
17:21:39 <fons> but it cannot be exported for the class parameters
17:21:49 <monochrom> You mop the floor and then you are allowed to read your supervisor's books.
17:22:00 <fons> _with_ the class paramters
17:22:43 <fons> and it would be quite inconvinient even if its a workaround to tell the user to add the export declaration
17:23:17 <palomer> hrmph
17:23:32 <Pseudonym> http://www.theonion.com/content/node/37376
17:23:34 <fons> any suggestions about hoe to solve it?
17:23:34 <lambdabot> Title: Ask A Wiccan | The Onion - America's Finest News Source
17:24:14 <satan> if i have a datatype: data F a = X | Y a a, to make F an instance of class Functor, I'd say: instance Functor F where fmap f X = x, fmap f (Y a a) = Y (f(a) f(a)), right?
17:24:34 <mauke> no
17:24:40 <satan> ugh
17:24:42 <dcoutts> andygill, is there somewhere we can find out more about the HPC mode/tool ? It sounds very interesting.
17:24:44 <satan> what am i doing wrong?
17:25:01 <mauke> instance Functor F where fmap f X = X; fmap f (Y a a) = Y (f a) (f a)
17:25:16 <satan> ohh wrong brackets ok
17:25:21 <andygill> Have a look at http://www.haskell.org/haskellwiki/Haskell_Program_Coverage for HPC info.
17:25:21 <satan> sweet, thanks mauke
17:25:25 <lambdabot> Title: Haskell Program Coverage - HaskellWiki, http://tinyurl.com/yyqrds
17:25:32 * SamB shudders
17:25:38 <dcoutts> andygill, cheers.
17:27:15 <satan> ok, this seems a bit trickier: define a datatype D such that D is isomorphic to F D
17:27:31 <satan> would i try to define it based on those axioms
17:28:06 <Cale> Pseudonym: http://www.theonion.com/content/node/54360
17:28:08 <Pseudonym> That's easy, BTW.
17:28:08 <lambdabot> Title: Mars Rover Beginning To Hate Mars | The Onion - America's Finest News Source
17:28:16 <Pseudonym> You want a fixpoint of F.
17:28:19 <SamB_XP> satan: and you aren't doing homework?
17:28:33 <Pseudonym> The _least_ fixpoint of F is dead easy to construct.
17:28:42 <satan> Pseudonym: right, since f x  = x is a fixedpoint
17:28:47 <Pseudonym> Right.
17:28:52 <satan> SamB_XP: nope, god i'd die if i had a course on this
17:29:22 <satan> so i should interpret the whole 'isomorphic to F D' bit as just finding a fixed point, because it's asked of D
17:30:14 <SamB_XP> satan: oh, I'd die too
17:30:18 <SamB_XP> of boredom ;-P
17:31:03 <satan> heh
17:31:32 <satan> so, how would i find the least fixed point? just say it's _|_ ?
17:31:33 <SamB_XP> (because the *other* students would be dying of insufficient math skills)
17:31:39 <satan> like me :(
17:31:46 <mauke> data D = D (F D) -- does that work?
17:31:52 <SamB_XP> also I already know Haskell ;-)
17:32:14 <satan> mauke: i don't get it
17:33:41 <lispy> mauke: oh, that's evil
17:34:01 <mauke> satan: it's just "D = F D"
17:34:17 <satan> mauke: alright
17:34:32 <satan> so just to clarify, since we're on the topic, i asked this in here 2 days ago, but just not sure of the final answer
17:34:45 <satan> i was trying to find the least fixed point of f a = [True]
17:34:51 <lispy> > let f x = x (f x) in f show
17:34:52 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:34:56 <satan> and we found that it was [True]
17:35:13 <satan> but then someone said that f _|_ = [True] as well, since the argument is ignored
17:35:14 <mauke> > let f a = [True] in fix f
17:35:15 <lambdabot>  [True]
17:35:25 <satan> thats not a fixed point though, is it, since it doest match the form f x  = x
17:35:31 <satan> doesn't*
17:35:35 <lispy> > fix $ const (+)
17:35:36 <lambdabot>  Add a type signature
17:35:41 <lispy> > fix $ const 1
17:35:43 <lambdabot>  1
17:35:54 <mauke> so fix == unconst
17:35:55 <SyntaxNinja> Cale: 'OVERPRICED SPACE-ROOMBA AWAITING MORE BULLSHIT ORDERS.' buahahahahahahaha!
17:36:05 <Cale> hehe
17:36:16 <satan> so which is the fixed point then, of that f? [True] or _|_ ?
17:36:33 <lispy> 'the' fixed point?
17:36:38 <int-e> SyntaxNinja: did you see the message in the second picture?
17:36:41 <satan> the least fixed point, sorry
17:37:27 <SamB_XP> > zipWith (fix $ const (+)) [(1,2),(3,4)..]
17:37:28 <lambdabot>  add an instance declaration for (Enum (a, b))
17:37:29 <lambdabot>   In an arithmetic sequence...
17:37:39 <dons> mmm. Hpc is _in_ ghc now?
17:37:46 <palomer> hrmph, what to do
17:37:48 <dons> sounds like we need a tutorial!
17:37:51 <SamB_XP> > zipWith (fix $ const (+)) [(1,2),(3,4),(5,6),(7,8),(9,10)]
17:37:52 <lambdabot>  add an instance declaration for (Num (a, b))
17:37:56 <SamB_XP> dons: what is that
17:37:58 <palomer> I now have to prove 10 things
17:38:00 <palomer> and my brain is much
17:38:02 <palomer> ho hum
17:38:17 <SamB_XP> @type (fix $ const (+))
17:38:19 <lambdabot> forall a. (Num a) => a -> a -> a
17:38:33 <ThreeQ> > zipWith (fix $ const (+)) [1,3..] [2,4..]
17:38:34 <lambdabot>  [3,7,11,15,19,23,27,31,35,39,43,47,51,55,59,63,67,71,75,79,83,87,91,95,99,10...
17:38:38 <dons> ?google HPC site:haskell.org
17:38:39 <SamB_XP> oh right...
17:38:41 <lambdabot> http://darcs.haskell.org/hpc/
17:38:41 <lambdabot> Title: Index of /hpc
17:38:42 * SamB_XP silly
17:38:58 <ThreeQ> :)
17:39:13 <fons> FFI is driving me crazy :S
17:39:14 <lispy> dons: actually, andygill recommended looking at the wiki
17:39:29 <fons> $ ghc -c -fglasgow-exts Ladspa.hs
17:39:32 <lispy>  http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
17:39:36 <SyntaxNinja> int-e: hehe
17:39:36 <lambdabot> Title: Haskell Program Coverage - HaskellWiki, http://tinyurl.com/yyqrds
17:39:38 <fons> /tmp/ghc23776.s: Assembler messages:
17:39:38 <fons> /tmp/ghc23776.s:723: Error: symbol `Ladspa_zdfmarshalName_srt' is already defined
17:39:42 <fons> and so on ...
17:40:08 <fons> marshalName, marshalMaker, marshalCR :: StablePtr (Descriptor id hd) ->
17:40:08 <fons>                                         IO CString
17:40:14 <Pseudonym> palomer: What do you have to prove?
17:40:16 <fons> foreign export ccall "marshal_name"
17:40:16 <fons>  marshalName :: StablePtr (Descriptor id hd) -> IO CString
17:41:10 <dons> ?where+ hpc http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
17:41:11 <lambdabot> Done.
17:42:08 <lispy> dons: oh, i was thinking about the lambdabot space leak after the thing bulat said about how ghc won't free memory back to the OS...do you think that could be related?
17:44:04 <dons> doubt it .. it only emerged recently.
17:44:16 <dons> also, seems to be improved slightly, atm. though i've still not profield it...
17:44:25 <SamB_XP> you haven't?
17:44:27 <SamB_XP> why not?
17:45:08 <dons> I was waiting for you to do it, SamB_XP
17:45:39 <SamB_XP> oh. ordinarily I'd say "are you kidding? with *this* hardware?"
17:45:41 * lispy wonders if SamB_XP does pair programming with SamB
17:45:45 <dons> this is why,
17:45:47 <dons> 10:45  dons> ?uptime
17:45:47 <dons> 10:45  lambdabot> uptime: 24d, 18h, 59m  49s, longest uptime: 24d, 18h, 59m  49s
17:46:14 <dons> doesn't bite me hard enough to waste time on it yet
17:46:27 <SamB_XP> what? you don't have enough disk space to hold 24 days worth of heap history?
17:46:35 <SamB_XP> ;-P
17:46:55 <SamB_XP> lispy: I *am* SamB
17:46:59 * dons thinks SamB tries to miss points
17:47:10 <SamB_XP> except that I am on Windows XP
17:48:13 <lispy> Oh, i thought it was XP for extreme programming...
17:48:22 <SamB_XP> ;-)
17:48:24 <dons> I think it is, actually
17:48:39 <SamB_XP> dons: you think Windows XP is named for extreme programming?
17:48:41 <SamB_XP> why?
17:48:42 <dons> SamB_Agile_Methodology might be better?
17:48:57 <monochrom> SamB_Pair_Programming
17:49:27 <Pseudonym> SamB_DoTheSmallestThingThatCouldPossiblyWork
17:49:37 <Pseudonym> SamB_RefactorMercilessly
17:49:46 * SamB_XP thinks SamB_;-P is smaller than all of those
17:50:03 <monochrom> SamB_Vista
17:50:08 <dons> I still don't understand why SamB_* exists? Why not use screen ?
17:50:20 <lispy> or an irc proxy
17:50:23 <dons> do we need to know what machine you're on? :)
17:50:35 <Pseudonym> I do.  How else do I know which ping of death to send?
17:50:36 <SamB_XP> I didn't know how until probably less than a week ago?
17:50:37 <lispy> SamB_CleverRues
17:50:50 <dons> Pseudonym: ah. good idea. saves an nmap
17:50:57 <Pseudonym> Exactly.
17:51:20 <SamB_XP> Pseudonym: how are you going to send the ping of death when my XP box is behind NAT?
17:51:35 <Pseudonym> True.  You should put the make and model of the NAT box in your user name too.
17:51:42 <monochrom> ping the NAT.
17:51:52 <Pseudonym> Once we 0wn that, it's easy.
17:51:57 <SamB_XP> Pseudonym: couldn't you just type /version SamB?
17:52:34 <lispy> i don't think that does what we want
17:52:39 <Pseudonym> No.
17:52:46 <lispy> *** kornbluth.freenode.net 351 lispy
17:52:46 <lispy>       hyperion-1.0.2(230). kornbluth.freenode.net iM dncrTS/v4
17:53:09 <lispy> iM dncrTS/v4?
17:54:14 <SamB_XP> oh, hmm, doesn't reveal as much info as I thought
18:02:41 <dons> http://programming.reddit.com/info/nmkv/comments  :)
18:02:45 <lambdabot> Title: Automated Program Coverage Discovery in Haskell (reddit.com), http://tinyurl.com/yholv2
18:15:41 <Igloo> dons: Are points a count of votes that decay over time?
18:15:56 <Igloo> Or is it more complex than that?
18:16:08 <dons> its a sum of mod up and mod downs, only.
18:16:25 <dons> this is used, along with a decaying time value, to compute the rank
18:16:26 <chessguy> hiya dons
18:16:32 <Igloo> And each person can affect it by +/-1 only?
18:16:35 <dons> yes.
18:16:42 <dons> if it ever reaches 0, the article disappears
18:16:54 <dons> and over time , without more 'ups' the article will fall in rank
18:17:08 <x3m2> @seen foxy
18:17:09 <lambdabot> I saw foxy leaving #haskell-overflow and #haskell 15h 12m 25s ago, and .
18:17:13 <dons> i'm trying to ensure 2 haskell articles a week
18:17:30 <dons> if we had more releases or blog articles, there'd be more ...
18:17:31 <Igloo> dons: Why are there 2 poisonous people things on http://programming.reddit.com/user/dons/ ?
18:17:32 <lambdabot> Title: overview by dons (on programming.reddit.com)
18:17:38 * SamB_XP thinks it shouldn't disappear after reaching 0 unless its been modded by 6 people already
18:17:57 <SamB_XP> or been around a while
18:18:14 <dons> Igloo: oh, one is the actual submission, the other is a comment
18:18:19 <dons> they're logged separately
18:18:36 <dons> Submissions are the titles only. Comments are just where i've commented on an article
18:18:40 <Igloo> Ah, and that page includes stuff you modded but didn't write, right?
18:18:55 <dons> stuff i've submitted, and my comments
18:19:06 <dons> but i don't think stuff i've modded, no. (i've modded 10 or so articles a day...)
18:19:26 <Igloo> What's the one that says "The gentoo ebuild will probably be updated in the next few days" doing there?
18:19:44 <Igloo> Oh, I see, it's someone's comment on your submission?
18:19:54 <Igloo> dons: Oh, BTW, do you still build GHC from HC files?
18:19:57 <dons> that's me talking to igouy in a comment.
18:20:03 <dons> Igloo: I do, haven't tried 6.6 yet though
18:20:07 <Igloo> Oh, I see
18:20:10 <Igloo> OK
18:20:23 <Igloo> Let me know if you do
18:20:36 <dons> ok.
18:21:11 * Igloo is getting increasingly annoyed with sawfish. We need to write a Haskell replacement
18:21:20 <chessguy> dons, did you get my message about the SoC ideas list?
18:21:34 <dons> yes,we need to turn it off at least
18:21:41 <dons> Igloo: sawfish, the WM?
18:21:54 <chessguy> i wasn't sure who should be told about it
18:22:03 * dons tosses dwm, wmii and ion at Igloo
18:22:06 <Igloo> Yup
18:22:23 <Igloo> I have some ideas of what would work for me, but it would take a bit of implementation
18:22:33 <emu> just use ratpoison
18:22:48 <Igloo> I want to be able to put sets of windows into "tasks", and then be able to ask for specific tasks to be visible
18:23:04 <dons> ah. i think that's like wmii's "tags"
18:23:09 <emu> you could do that with virtual desktops too
18:23:11 <Bobstopper> can't you do that with window groupings in sawfish?
18:23:12 <Igloo> Also, I want to have bits of lots of Windows visible at the time, for compiles I want to spot finishing
18:23:16 <dons> I certainly group apps into virutal desktops with tags quite easily
18:23:20 <dons> in dwm and wmii
18:23:35 <Igloo> But can you show the merge of 3 virtual desktops at once?
18:23:52 <SamB_XP> hmm, it looks like we are already pretty good at dealing with poisonous people
18:23:57 <dons> not easily. you'd have to split the screen in 3, and stick the windows in them.
18:24:03 <dons> SamB_XP: I think we are, yes.
18:24:04 <SamB_XP> dons here doesn't merely extract bug reports, he extracts patches ;-)
18:24:08 <Igloo> When it gets nasty is when you need to move some Windows around for it to all fit without overlapping
18:24:25 <SamB_XP> or at leats gets people to shut up ;-)
18:24:28 * Bobstopper thinks the concept of "poisonous people" may be identifying the wrong problem.
18:24:30 <dons> Igloo: but use a wm that doesn't do overlapping.
18:24:39 <dons> SamB_XP: why thankyou. I try.
18:24:49 <emu> ratpoison automatically resizes windows to fill available space=)
18:24:49 <dons> now .. shutup and code!
18:24:50 <SamB_XP> Bobstopper: maybe they are, maybe not
18:25:17 <SamB_XP> Bobstopper: I suppose they might be mis-attributing some problems to be exclusively caused by poisonous people
18:25:44 <SamB_XP> then again, maybe we have a unicorn's horn ;-D
18:25:46 <satan> hmm for this line: (foldl . foldr) (:) "abc" ["def", "g", "hi"], foldr is caleld first on those arguments, right? then the result is passed to foldl
18:26:01 <satan> but does foldl take the same 2 first arguments, (:) and "abc" ?
18:26:05 <dons> the poisonous people stuff comes from the svn mailing lists -- but I don't see it on ours (at least not in a problematic form). sometimes you see trolls here with the charactersitics. but that's about it.
18:26:11 <Bobstopper> by my reading of it, people may be considered "poisonous" when they simply aren't familiar with the expectations of the group. That seems a bit unfair. I'd say the problem probably lies closer to their decision making schemes and lack of guidelines for appropriate behaviour...
18:26:27 <mauke> (foldl . foldr) (:) == foldl (foldr (:))
18:26:30 <dons> yes. guidelines are important.
18:26:40 * dons goes back to writing guidelines
18:27:07 <SamB_XP> you see people maybe doing a few of the things
18:27:22 <mauke> @type (foldl . foldr) (:) "abc" ["def", "g", "hi"]
18:27:22 <SamB_XP> but usually not on purpose and usually it doesn't seem to affect us much
18:27:23 <lambdabot> [Char]
18:27:47 <Pseudonym> One of the nice things about the Haskell community is we're all smart.
18:27:55 <satan> so foldr returns "defghiabc"
18:27:55 <Igloo> I think it only hasn't affected us much because those people have tended to disappear soon after showing up, for some reason
18:28:01 <emu> except me
18:28:05 <mauke> > (foldl . foldr) (:) "abc" ["def", "g", "hi"]
18:28:06 <lambdabot>  "higdefabc"
18:28:11 <SamB_XP> Igloo: yeah
18:28:13 <satan> > foldr (:) "abc" ["def", "g", "hi"]
18:28:14 <lambdabot>  Couldn't match `Char' against `[Char]'
18:28:14 <Pseudonym> Trolls don't last long because we're more devious than they are.
18:28:19 <Igloo> I think it's because we're small enough that everyone else opposes them as a solid community
18:28:27 <SamB_XP> mmm
18:28:33 <Bobstopper> Anyway, I'm suspect of any blame-making which goes out of its way to identify people as the causes. "poisonous people" has blame written all over it...
18:28:35 <Pseudonym> Only we use our deviousness for niceness instead of evil.
18:28:43 <Igloo> whereas larger projects like Debian don't have that solid position against them
18:28:47 <satan> eh
18:28:58 <dons> Pseudonym: right. smart people, tight community, and an attention to rigour and detail -- makes it easy to reach consensus, and spot bad reasoning
18:28:59 <SamB_XP> and we banned smerdy, and now he don't come here no more...
18:29:01 <emu> @pl is pretty devious
18:29:02 <lambdabot> is pretty devious
18:29:06 <Pseudonym> Right.
18:29:11 <SamB_XP> Bobstopper: probably they do have poisonous poeple around there, though
18:29:17 <Pseudonym> We do, of course, have bikeshed arguments.
18:29:31 <Pseudonym> But that's going to happen regardless.
18:29:35 <satan> mauke: so whats the intermediate result of the foldr call?
18:29:42 <dons> we do. that's something we're working on.
18:29:44 <mauke> hmm?
18:29:48 <dons> less bikesheds, more nuclear reactors!
18:29:52 <SamB_XP> oh? you mean, like: Nooo! you can't call that data BikeShed! we already have one in this other module!
18:29:59 <dons> for example :)
18:30:04 <Pseudonym> I think you meant "fewer", not "less".
18:30:19 <JKnecht> NO NO BLUE!
18:30:20 <dons> I don't mean 'more' anyway
18:30:28 * Igloo thinks bikesheds are even more inevitable when you have a community that likes beatiful things, and some of our problems have no beautiful answer
18:30:31 <Bobstopper> Well, no doubt there's people who do actually try to be poisonous. But the problem with finding solutions involving identifying poisonous people is that it becomes a situation where people are accused and potentially ostracised when they may not have been intending anything wrong.
18:30:43 <mauke> ah, I can see it
18:30:59 <dons> Igloo: yeah. + there's lots of hard stuff in Haskell that only 3 or 4 people can comment on ... leaving the rest of us to twiddly our thumbs and build bikesheds
18:31:08 <Igloo> e.g. I hate every single implementation of "split this string into 5s, padding with Xs" there is in Haskell, because it feels like it ought to be a short and beautiful unfold
18:31:34 <SamB_XP> Bobstopper: nobody said anything about trying to be poisonous
18:31:40 <SamB_XP> some poeple may do it by accident
18:31:43 <mauke> > foldr (:) (foldr (:) (foldr (:) "abc" "def") "g") "hi"
18:31:44 <lambdabot>  "higdefabc"
18:32:03 <dons> I think the notes might just help as a guide for recognising when an 'event' relating to trolling or distraction is happening.
18:32:14 <JKnecht> yeah and it is chat after all.
18:32:20 <SamB_XP> Smerdyakov disclaims all knowledge of poisoning, for instance...
18:32:33 <dons> surely that can't be sincere?
18:32:39 <SamB_XP> his domain name is "schizomaniac", though, so who knows?
18:32:40 <dons> he _must_ realise why he gets kicked
18:33:20 <SamB_XP> I think
18:33:53 <satan> mauke: ah i see, so i should treat the foldr (:) as f in foldl f "abc" [....]
18:33:53 <Bobstopper> SamB_XP: Yeah, so it comes down to identifying the goals of the group and codifying appropriate and inappropriate behaviour for those goals. I think that's a better solution than "Identify poisonous people" since that's going to be subjective and prone to misuse at best
18:33:55 <dons> mmm. one thing I notice reading reddit, is that the haskell articles tend to be signficant techological developements: SMP, HPC, proofs .... while most other langs are submitting short trivial articles about simple coding tasks
18:34:02 <mauke> satan: exactly
18:34:17 <SamB_XP> how about "identify poisonous behaviour"
18:34:20 <satan> mauke: thanks, that was tricky
18:34:21 <araujo> hellu
18:34:30 * araujo throws some sugar lambdas around
18:34:41 <SamB_XP> araujo: they aren't poisoned are they?
18:34:44 * araujo wonders if dons did a script after all
18:34:49 <dons> nope.
18:35:11 <araujo> SamB_XP, mm .. well ... they can become very addictive.
18:35:18 <SamB_XP> oh, okay ;-)
18:35:21 * SamB_XP eats some
18:35:27 <Bobstopper> mmm... I think it's more a dichotomy between "relevent" and "irrelevent" discussion than "poisonous and unpoisounous"
18:35:28 <araujo> :-}
18:35:41 <araujo> dons, ok
18:35:47 <SamB_XP> Bobstopper: I take it you weren't here when smerdyakov got banned?
18:35:58 <Bobstopper> I think identifying relevent discussion is more powerful than identifying annoying people...
18:36:00 * araujo uploads the third HWN spanish issue
18:36:07 <SamB_XP> true
18:36:17 <dons> Bobstopper: if you're interested in making some notes on this stuff, and on the consenus work you pointed to, i'd be very interested
18:36:24 <SamB_XP> because there aren't a lot of annoying people 'round these parts ;-)
18:36:29 <Bobstopper> no I wasn't, but I've been involved in grass-roots movements which had to deal with white-supremist antagonisers a lot.
18:36:36 <SamB_XP> only annoying behaviours
18:37:07 <SamB_XP> Bobstopper: ... in japan?
18:37:12 <Bobstopper> No, in Australia
18:37:17 <SamB_XP> oh.
18:37:23 * SamB_XP doesn't like them in any case
18:37:54 <SamB_XP> it just didn't seem probable that it would happen in Japan, you know? seeing as (most of the?) natives aren't white?
18:38:21 <dcoutts> Igloo, musasabi, I've sent in a proposal on configurations to the cabal-devel list. Please tear it appart and/or fill in the gaps.
18:38:40 <dcoutts> there's still some design choices left in the proposal
18:38:51 <Igloo> dcoutts: Ta, I'll have a look!
18:39:02 <Bobstopper> Basically, if someone wants to make a suggestion, they need to adequately show how it furthers the group's goals. If people want to raise a concern about a suggestion they have to show how it hinders the groups goals. All other discussion is irrelevent.
18:39:17 <dcoutts> Igloo, I'll be around for a few minutes if you have an immediate Qs.
18:39:26 <dcoutts> an/any
18:39:37 <SamB_XP> Bobstopper: hmm. we have goals?
18:39:42 <dons> Bobstopper: hmm. yes.
18:39:51 <dons> SamB_XP: to take over the world, of course.
18:40:00 <Bobstopper> If you have a system kinda like that, whether people are poisonous or not also irrelevent discussion, while people being poisonous is also irrelevent. So you kinda get rid of both problems.
18:40:05 <SamB> I thought that was what we were attempting to avoid?
18:40:16 <SamB> did we give up on not taking over the world *already*?
18:40:34 <dons> Here i've started on documenting a submission best practice document, http://haskell.org/haskellwiki/Library_submissions
18:40:36 <Bobstopper> otherwise it can break down to "Oi you, stop being poisonous" "am not!" "are too!" etc
18:40:37 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/ymprrq
18:41:30 <SamB> dons: hmm, that should be linked from somewhere easy to find when hacking the libraries
18:41:46 <dons> will do...
18:42:04 <SamB> I was just wondering where that would be
18:42:13 <dons> libraries and tools
18:42:19 <dons> and somewhere on the ghc wiki
18:42:23 <SamB> oh, and did everyone catch that DOCS DO NOT BUILD with plain-old haddock?
18:42:31 <dons> yes.. more info please
18:42:39 * araujo just hopes to be able to keep the pace with dons 
18:42:45 <dons> araujo: cool. thanks!
18:42:52 <araujo> It is not easy i gotta say
18:42:54 <araujo> ;-)
18:43:46 <Bobstopper> dons: re notes, sure I can do that.
18:43:58 <SamB> well
18:43:59 <emu> I should read HWN in spanish so I can learn 2 languages at once.
18:44:12 <SamB> I have haddock 0.7, see?
18:44:43 <SamB> it doesn't like that one flag
18:45:14 <dons> try 0.8 ?
18:45:14 <satan> hmm why does foldr (:) [1] [2..10] work, but foldl (:) [1] [2..10] give me an occurs Check?
18:45:30 <dons> nb. you need 0.8 for at least some thing now.
18:45:39 <dons> SamB: args are flipped
18:45:43 <dons> satan ^^
18:45:47 <dons> ?type foldl
18:45:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:45:51 <dons> ?type foldr
18:45:52 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
18:45:54 <satan> ohhh
18:45:56 <Igloo> dcoutts: So exposed modules won't be configurationable, right? Will anything else be so affected?
18:46:07 <satan> dons: thanks
18:46:09 <Cale> > foldl (flip (:)) [1] [2..10]
18:46:11 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
18:46:16 <dcoutts> Igloo, not sure what you mean exactly.
18:47:12 <hyraxfourtwo> > foldl' (flip (:)) [1] [2..10]
18:47:13 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
18:47:29 * hyraxfourtwo is still confused with strictness
18:47:37 <Igloo> dcoutts: I can't expose different modules based on whether you are on Windows, right?
18:47:48 <coffeemug> hey guys
18:47:50 <dcoutts> Igloo, you can. That's ok.
18:48:01 <dcoutts> Igloo, and that doesn't need any flags.
18:48:01 <Igloo> Ug!
18:48:10 <SamB> ... \
18:48:10 <SamB>         --package=base \
18:48:10 <SamB>         --dump-interface=base.haddock \
18:48:10 <SamB>         --use-index=../doc-index.html --use-contents=../index.html \
18:48:10 <SamB>         --source-module=http://darcs.haskell.org/ghc-6.6/packages/base/%{FILE} \
18:48:11 <SamB> unrecognized option `--source-module'
18:48:12 <lambdabot> http://darcs.haskell.org/ghc-6.6/packages/base/%{FILE}
18:48:12 <Igloo> Eh?
18:48:21 <coffeemug> so I finally figured out how to compile GHC locally
18:48:25 <coffeemug> on win32
18:48:30 <dcoutts> Igloo, configuration: os(windows); exposed-modules: Extra.Thing
18:48:40 <coffeemug> if I make a small change
18:48:40 <SamB> dons: oh
18:48:43 <SamB> 0.8 huh?
18:48:46 <coffeemug> to Linker.c for example
18:48:49 <Igloo> Oh, right, yes, you don't need to actually declare a flag
18:48:53 <Igloo> But still, Ug!
18:48:55 <dcoutts> Igloo, right.
18:48:55 <coffeemug> how do I only rebuild that part so I don't have to wait for an hour?
18:48:58 <dcoutts> Igloo, ug?
18:48:59 <SamB> dons: where do you get that?
18:49:16 <dcoutts> Igloo, what made it look like the proposal made that illegal ?
18:49:16 <Igloo> dcoutts: That means that if you write an app on Windows it might not work for me on linux, and you won't even notice
18:49:28 <Igloo> dcoutts: Nothing, that's why I brought it up  :-)
18:49:49 <dcoutts> Igloo, then don't do conditional deps on os ! We can't completely stop people abusing it.
18:50:04 <hyraxfourtwo> does anyone know where the Control.Parallel.Strategies paper lives?
18:50:05 <dcoutts> Igloo, we can bad some things if we think they can only be abused.
18:50:10 <hyraxfourtwo> the docs are useless
18:50:25 <dcoutts> Igloo, eg we could indeed ban putting exposed-modules in a configuration.
18:50:40 <dons> SamB: usual place. no need to ask...
18:50:50 <Igloo> dcoutts: compiler tests are missing, BTW
18:50:59 <dcoutts> Igloo, that's a reasonable proposition. But my proposal is independent of that.
18:51:13 <dcoutts> Igloo, ok, add them. THat's not one of the problematic cases.
18:51:18 * Igloo thought it was already agreed that that should be done, but perhaps I was confused...
18:51:40 <dcoutts> Igloo, the hard bit is the packages & versions and flags vs configuations and the available vs using.
18:51:45 <SamB> dons: it is not in Debian testing!
18:51:49 * Igloo isn't awake enough to think about the questions right now
18:53:09 <satan> i thought my version of foldr: foldv f a (x:xs) =  if null xs then f a x else x `f` (foldv f a xs) was accurate but it doesnt work with foldr (:) [1] [2..10], I get an Occurs Check
18:53:34 <dons> Igloo: if I want people to add trac tickets for library submissions, should they go to http://hackage.haskell.org/trac/ghc or do we have a separate namespace for libraries stuff?
18:53:37 <lambdabot> Title: GHC - Trac
18:53:57 <Igloo> dons: That's the best place ATM AFAIK
18:54:03 <Igloo> We ought to do something better, though
18:54:35 <SamB> Igloo: where do I get haddock 0.8?
18:55:05 <mauke> satan: what's the point of checking (null xs)?
18:55:10 <monochrom> satan's version of foldr?
18:55:25 <SamB> @devils foldr
18:55:28 <lambdabot> No match for "foldr".
18:55:29 <SamB> aww
18:55:30 <mauke> foldv f a (x : xs) = x `f` foldv f a xs
18:55:33 <dons> SamB: haskell.org/haddock ?
18:55:41 <SamB> dons: that has debian packages?
18:55:43 <satan> because if it's the empty list, it should return f with a and x, right?
18:55:48 <satan> mauke: oh hmm
18:55:59 <mauke> foldv f a [] = a
18:56:09 <dons> SamB: if not , you know how to type './Setup.hs configure" ....
18:56:15 <SamB> awwww
18:56:52 <satan> how would i do it if i didnt wanna pattern match but wanted it all in one line?
18:56:59 <monochrom> I can see why the extra case.  It is cultural brainwashing to consider there are 3 kinds of lists, length 0, length 1, length 2 or more.
18:57:19 <mauke> foldv f a xs = if null xs then a else x `f` foldv f a xs
18:57:26 <mauke> hmm, no
18:57:36 <mauke> foldv f a xs = if null xs then a else head xs `f` foldv f a (tail xs)
18:58:08 <monochrom> I don't recommend packing all those null xs, head xs, tail xs together.
18:58:25 <satan> hmm still the same error
18:58:37 <coffeemug> anyone knows how to build a small part of GHC?
18:58:37 <hyraxfourtwo> ?type let y f = f (y f) in y
18:58:39 <lambdabot> forall t. (t -> t) -> t
18:58:57 <hyraxfourtwo> I was told y is untypable
18:59:30 <mauke> @type let foldv f a xs = if null xs then a else head xs `f` foldv f a (tail xs) in foldv
18:59:31 <lambdabot> forall a t. (a -> t -> t) -> t -> [a] -> t
18:59:42 <dolio> Some of the sub-expressions in the lambda version of y is untypable.
18:59:50 <hyraxfourtwo> oh ya ok
18:59:58 <dolio> Or, are untypable, that is.
19:00:02 <mauke> > let foldv f a xs = if null xs then a else head xs `f` foldv f a (tail xs) in foldv (:) [1] [2..10]
19:00:03 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
19:00:11 <monochrom> "Did you save?"
19:00:21 <coffeemug> arghh
19:00:25 <coffeemug> gotta relogin
19:00:26 <coffeemug> brb
19:00:36 <satan> so mauke, what was wrong with mine?
19:00:47 <satan> the fact that i was passing back f a x instead of just a?
19:01:07 <monochrom> f a x and a have the same type.
19:01:08 <mauke> > let foldv f a (x:xs) =  if null xs then f a x else x `f` (foldv f a xs) in foldv (:) [1] [2..10]
19:01:09 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:01:09 <lambdabot>    Expected...
19:01:24 <satan> yup, thats the error
19:01:34 <mauke> > let foldv f a (x:xs) =  if null xs then f x a else x `f` (foldv f a xs) in foldv (:) [1] [2..10]
19:01:35 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
19:01:42 <mauke> f x a, not f a x
19:01:46 <satan> doh
19:01:51 <satan> sweet, thanks man
19:01:52 <monochrom> Ah!
19:01:54 <mauke> and that version fails for empty lists
19:02:04 <satan> oh
19:02:14 <SamB> hmm, they should put the darcs repo in the "download" section ;-)
19:02:24 <monochrom> But I do hate debugging an overcomplicated solution.
19:03:01 <EvilRanter> this really does look like a case for pattern matching
19:03:08 <monochrom> (After Hoare)  There are two ways to build a system.  You can build it so simple that there is obviously no flaw.  You can build it so complicated that there is no obvious flaw.
19:03:36 <SamB> the first is the harder :-(
19:03:37 <satan> well, i'm trying to write foldr so i can find its fixed point, so i have to get foldr on the right side somehow to get foldr = f foldr
19:03:50 <x3m2> > (\x -> x*x) 5
19:03:51 <satan> thats why i didnt wanna do pattern matching...or is that still possible?
19:03:52 <lambdabot>  25
19:03:54 <monochrom> Lots of students asking "what's wrong with my attempt" belong to the latter.
19:04:09 <satan> ok
19:04:31 <dons> monochrom: is that an original quote? or what's the ref? Hoare?
19:04:49 <mauke> > fix foldr
19:04:50 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:04:50 <lambdabot>    Expected...
19:04:51 <EvilRanter> altho maybe "foldv f a xs = case xs of [] -> a; (x:xs') -> x `f` (foldv f a xs')"
19:05:09 <monochrom> It's very close to the original quote.  If you push that through Google you may get the original text.
19:06:20 <dcoutts> dons, so should I resubmit my equating patch following the new lib guidelines ? :-)
19:06:38 <dcoutts> what quickcheck property should hold for equating ?
19:07:04 <dcoutts> equating p x y = p x == p y
19:07:05 <dcoutts> hmmm
19:07:07 <dons> right. I think you should. and josef should too. (set a trac ticket up at least, and point to the discussion)
19:07:08 <SamB> dons: you are not too good at linking stuff, you know that?
19:07:13 <dons> SamB: hmm?
19:07:19 <SamB> you left out the haddock
19:07:23 <SamB> in the URL
19:07:28 <SamB> also you didn't mention 0.8
19:07:31 <SamB> ;-P
19:07:48 <dons> duly noted.
19:08:05 <dons> dcoutts: if it doesn't have QuickCheck properties, this would be a mod down ;)
19:08:21 <SamB> hmm, darcs does not have an option to link to trac
19:08:21 <Igloo> dons: I would says all code, not just pure code, should come with tests, not necessarily QC
19:08:29 <dcoutts> dons, can you think of any property apart from the definition ?
19:08:32 <SamB> Igloo: oh, the horrer!
19:08:45 <SamB> how!
19:08:46 <dcoutts> dons, what's the property of ($) ? ;-)
19:08:48 <Igloo> dons: And I can't quite parse "as portable by default"
19:08:56 <dons> dcoutts: something related to commutativity or associativity?
19:09:02 <dons> or toss a free theorem in there ;)
19:09:07 <SamB> Igloo: me either
19:09:14 <SamB> he fixed that after I mentioned that
19:09:17 * dons drinks coffee and edits
19:09:26 <SamB> -	* The change should be as portable by default, and should state the portability requirements. Testing on Hugs should be required. [As portable as '''what'''?]	+	* The change should be portable by default, and if not portable, should state why. Testing on Hugs should be required.
19:09:37 <SamB> thats from the wiki diff...
19:09:37 <dons> ?type let equating p x y = p x == p y in equating
19:09:38 <lambdabot> forall t a. (Eq a) => (t -> a) -> t -> t -> Bool
19:09:51 <dons> ?free Eq a -> (t -> a) -> t -> t -> Bool
19:09:51 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:09:52 * Igloo would even go so far as to say that QC tests are a relatively undesirable form as they don't give consistent results over different runs
19:10:00 <dons> Igloo: they can.
19:10:02 <SamB> Igloo: the properties are decent
19:10:07 <SamB> well, can be
19:10:08 <dons> see the fps QCs
19:10:11 <dons> (you just fix the seed)
19:10:16 <Igloo> True
19:10:17 <SamB> its QuickCheck that is at fault :-P
19:10:23 <SamB> not the properties
19:10:38 <Igloo> But I'd much rather have HUnit tests for the tricky cases. I wouldn't object to having QC tests as well
19:11:02 <dcoutts> SmallCheck!
19:11:05 <SamB> Igloo: you can write a HUnit tutorial and link to it from there
19:11:08 <mauke> @pl equating p x y = p x == p y
19:11:09 <lambdabot> equating = flip =<< (((.) . (==)) .)
19:11:20 <scodil> so I've got a class that's parameterized on two types, but has a function dependency from one to the other, class MyClass a b | a -> b,  and I'm trying to .. i don't the name of what i'm trying to do, but it looks like this, class (MyClass t) => MyOtherClass t where...   and it gives me a kind error saying MyClass is not applied to enough arguments. If I do (MyClass a b) => MyOtherClass t, it says b is not in scope
19:11:24 <hyraxfourtwo> lambdabot, awesome
19:11:30 <hyraxfourtwo> I can't remember who defined it
19:11:31 <x3m2> > (\(x :: Int) -> x*x) 5.5
19:11:31 <dons> ok, edited, http://haskell.org/haskellwiki/Library_submissions#Submitting_a_proposal
19:11:32 <lambdabot>  Parse error in pattern
19:11:34 <hyraxfourtwo> I think davidhouse
19:11:36 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/wt9h9
19:11:38 <x3m2> > (\(x :: Int) -> x*x) 5
19:11:38 <lambdabot>  Parse error in pattern
19:11:51 <hyraxfourtwo> but f `attach` g = \x y -> f x `g` f y
19:12:05 <hyraxfourtwo> then equating = (`attach` (==))
19:12:21 <palomer> wow
19:12:26 <palomer> I had lost confidence in myself
19:12:27 <palomer> no kidding
19:12:28 <x3m2> > :t (\(x :: Int) -> x*x) 5
19:12:28 <lambdabot>  Parse error
19:12:32 <Igloo> dons: Possibly I was unclear, I was suggesting 2 unrelated changes
19:12:40 <x3m2> dons: whats wrong with: "(\(x :: Int) -> x*x)"?
19:12:46 <dcoutts> dons, I feel stupid stating commutativity since it's trivial from commutativity of (==)
19:12:47 <palomer> in my cerebral capacity
19:12:48 <dcoutts> forall p x y. (x == y && y == x) ==> equating p x y == equating p y x
19:12:49 <dave_m> x3m2: that only works with extended Haskell
19:12:54 <Igloo> dons: i.e. "Code should also come with tests for the testsuite"
19:13:07 <dons> Igloo: ok.
19:13:07 <x3m2> dave_m: "that"?
19:13:16 <hyraxfourtwo> palomer: huh?
19:13:23 <SamB> hmm, yeah, some functions are so short tests are *really* stupid...
19:13:24 <chessguy> ((\x->x*x) 5) ::Int
19:13:28 <dave_m> x3m2: in-line type annotations
19:13:29 <chessguy> > ((\x->x*x) 5) ::Int
19:13:30 <lambdabot>  25
19:13:33 <x3m2> okay
19:13:35 <palomer> I just did my first math problem in 5 months
19:13:36 <palomer> feels good
19:13:37 <chessguy> perhaps this is what you want?
19:13:41 <hyraxfourtwo> > join (*) $ 5
19:13:42 <lambdabot>  25
19:13:52 <SamB> I mean, if that function doesn't do what you expect, you better just give up on maths entirely...
19:13:57 <Igloo> dons: Also, I think we should have per-library testsuites, but that needs to be designed first
19:14:01 <hyraxfourtwo> palomer, congrats?
19:14:15 <dons> Igloo: that's a good idea
19:14:19 <chessguy> palomer, what kind of math problem?
19:14:19 <ThreeQ> > join (*) 5
19:14:21 <lambdabot>  25
19:14:39 * hyraxfourtwo is always wary of precedence rules, and uses ($) gratuitously
19:14:41 <monochrom> Mere mortal programmers have given up on maths entirely.  That's what makes them mere mortals.
19:14:52 <palomer> chessguy, I have a function match which I defined using logical rules
19:14:54 <Igloo> dons: It wants to be driven by cabal in a standard way, but still be flexible enough that it can cope with different forms of test
19:15:00 <palomer> and I proved that it does what is advertised
19:15:07 <chessguy> nice
19:15:10 <palomer> by induction!
19:15:10 <dcoutts> g'night folks
19:15:13 <Igloo> Possibly just cabal running a command and checking for result code or something
19:15:14 <chessguy> oooh
19:15:16 * dcoutts -> sleep
19:15:19 <chessguy> induction is fun
19:15:31 <palomer> I had to surmount some huge psychological blocks to solve it though
19:15:31 <hyraxfourtwo> ?karma induction
19:15:32 <SamB> palomer: can you run your proof in the testsuite?
19:15:32 <lambdabot> induction has a karma of 0
19:15:35 <dons> Igloo: right. factoring out library tests so they can be used in hugs/yhc/... would be one thing
19:15:59 <palomer> SamB, haven't figured out the proof term
19:16:03 <palomer> nor do I want to
19:16:08 <palomer> nor would I know what invariants that term would have
19:16:40 <SamB> @free on :: (a -> b) -> (a -> a -> c) -> (b -> b -> c)
19:16:41 <lambdabot> g . k = p . f => (forall x. h . q x = f1 (f x) . f) => h . on k q y = on p f1 (g y) . g
19:16:54 <SamB> erg.
19:17:00 <dons> SamB: the reason I don't want to state haddock 0.8 is that these are general, long lived guidelines. i.e. policy
19:17:16 <SamB> @free on :: (a -> a -> c)(a -> b) -> (b -> b -> c)
19:17:16 <lambdabot> Extra stuff at end of line
19:17:26 <monochrom> Was it the psychological block of trusting your intuition and distrusting formal logic?
19:17:31 <SamB> dons: okay, so, maybe "you might need a newer haddock">?
19:17:34 <SamB> s/>//
19:17:44 <dons> 'valid'
19:17:49 <int-e> monochrom: why would you do that? ;)
19:18:06 <palomer> what's this @free command
19:18:10 * monochrom always look for opportunities to make snide remarks on intuition
19:18:29 <dons> ?free map
19:18:30 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
19:18:33 <dons> ?free foldl
19:18:34 <lambdabot> (forall x. f . h x = k (f x) . g) => f . foldl h y = foldl k (f y) . $map g
19:18:35 <SamB> monochrom: I think intuition is able to handle equating, you know ;-)
19:18:38 <dons> ?help free
19:18:39 <lambdabot> free <ident>. Generate theorems for free
19:18:44 <palomer> oh, theorems for free
19:18:49 <int-e> monochrom: I can distrust the translation to or from formal logic, but once I trust that I have to accept the results that formal logic comes up with.
19:18:52 <x3m2> "power (\x -> x*x)" isnt this an ok function?
19:18:56 <SamB> like many free things, they may or may not be of much use
19:19:01 <dons> Igloo: ok, updated. http://haskell.org/haskellwiki/Library_submissions#Submitting_a_proposal
19:19:05 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/wt9h9
19:19:16 <monochrom> I sold my intuition to satan.  That is why I can do formal proofs and Haskell.  It is also why satan is now having so much problem getting Haskell to work.
19:19:43 <satan> thats right, never buy monochrom(e) deals, they're so shady :P
19:19:50 <satan> colour all the way from now on, baby!
19:20:00 <x3m2> power (\x -> x*x) cant i define a function like this?
19:20:08 <lisppaste2> chessguy pasted "Genetic Programming crossover operation functionality" at http://paste.lisp.org/display/28648
19:20:10 <EvilRanter> x3m2, "power = (\x ...)". also, don't nag.
19:20:17 <EvilRanter> :P
19:20:25 <x3m2> EvilRanter: i dont nag
19:20:37 <chessguy> hey, i'm looking for any comments/suggestions for this code if anyone's interested
19:20:45 <EvilRanter> we heard you the first time, i mean
19:20:48 <chessguy> especially optimizations
19:21:01 <x3m2> doubtful
19:21:11 <monochrom> I'm looking for money.
19:21:13 <chessguy> por x=x*x would also work
19:21:18 <chessguy> power
19:21:33 <chessguy> we heard you the first time too, monochrom
19:21:36 <monochrom> Why would you call that "power"?  It's merely squaring, not even cubing.
19:21:54 <JKnecht> I'da thought a theorem proving app for Haskell would have called itself into being;i.e. one that was highly practical against ordinary code (above what's built into ghc and such)
19:22:18 <EvilRanter> @pl power x = x*x
19:22:18 <lambdabot> power = join (*)
19:22:37 <SamB> _|_ makes things harder
19:22:40 <chessguy> what is @pl?
19:22:45 <SamB> @help pl
19:22:46 <lambdabot> pointless <expr>. Play with pointfree code.
19:23:00 <chessguy> hmm. it converts any code to pointfree?
19:23:08 <EvilRanter> theoretically
19:23:16 <int-e> many, at least.
19:23:19 <SamB> pointfree and pointless both mean "without point", so, its a bit of a pun
19:23:31 <chessguy> yeah, i got the pun, thanks
19:23:31 <SamB> an old running joke in the community
19:23:40 <SamB> also sometimes people take it too far
19:23:42 <EvilRanter> it tends to use a lot of (.) sections and (>>=)s on complicated things
19:23:47 <int-e> @pl \a b c d -> (a (b (c d)))
19:23:48 <lambdabot> (. (.)) . (.) . (.)
19:23:53 <EvilRanter> like that
19:23:55 <int-e> lots of points.
19:24:04 <Igloo> dons: Heh, I don't understand why the purity affects the sort of tests you should write, but I CBA to argue about it  :-)
19:24:11 <chessguy> those two are exactly equivalent?
19:24:27 <glguy> Has anyone else read the paper _Monad Transformers Step by Step_?
19:24:29 <EvilRanter> chessguy, they should be, anyway
19:24:59 <chessguy> \a b c d -> (a (b (c d))) 1 2 3 4
19:25:04 <chessguy> > \a b c d -> (a (b (c d))) 1 2 3 4
19:25:05 <lambdabot>  Add a type signature
19:25:25 <monochrom>  Add a pair of parentheses
19:25:33 <chessguy> > \a b c d -> (a (b (c d))) (1 2 3 4)
19:25:33 <lambdabot>  add an instance declaration for (Typeable1 ((->) t))
19:25:43 <monochrom>  Not there
19:25:49 <SamB> @type \a b c d -> (a (b (c d)))
19:25:50 * glguy recommends that _Monad Transformers Step by Step_ be added to the required reading list ;)
19:25:50 <chessguy> > (\a b c d -> (a (b (c d)))) (1 2 3 4)
19:25:51 <lambdabot> forall t t1 t2 t3. (t -> t3) -> (t1 -> t) -> (t2 -> t1) -> t2 -> t3
19:25:51 <lambdabot>     add an instance declaration for (Typeable (t1 -> t), Typeable (t2 -> t3))
19:26:04 <chessguy> > (\a b c d -> (a (b (c d)))) 1 2 3 4
19:26:05 <lambdabot>  add an instance declaration for (Num (t1 -> t))
19:26:10 <chessguy> ok, i give up
19:26:27 <monochrom> 1 (2 (3 4))  you would obtain.  What would you like it to mean?
19:26:27 <SamB> @. type . pl djinn (t -> t3) -> (t1 -> t) -> (t2 -> t1) -> t2 -> t3
19:26:29 <lambdabot> parse error on input `='
19:26:31 <mauke> chessguy: numbers aren't functions (normally)
19:26:52 <SamB> @djinn (t -> t3) -> (t1 -> t) -> (t2 -> t1) -> t2 -> t3
19:26:53 <lambdabot> f a b c d = a (b (c d))
19:27:06 <monochrom> or alternatively but equivalently, functions aren't numbers (normally)
19:27:07 <SamB> @. pl djinn (t -> t3) -> (t1 -> t) -> (t2 -> t1) -> t2 -> t3
19:27:08 <lambdabot> f = (. (.)) . (.) . (.)
19:27:16 <SamB> @. tail . pl djinn (t -> t3) -> (t1 -> t) -> (t2 -> t1) -> t2 -> t3
19:27:17 <lambdabot> compose module failed: IRCRaised Parse error: "tail"
19:27:20 <SamB> aww
19:27:22 <chessguy> > (\a b c d -> (a (b (c d)))) (-) (-) (-) 4
19:27:23 <lambdabot>  add an instance declaration for (Num (a -> a))
19:27:38 <monochrom> use negate
19:27:42 <dave_m> chessguy: try a unary function
19:27:52 <chessguy> > (\a b c d -> (a (b (c d)))) - - - 4
19:27:52 <lambdabot>  Parse error
19:28:04 <monochrom> - is the only Achilles's point of Haskell.
19:28:10 <dave_m> >(\a b c d -> (a (b (c d)))) (+1) (+1) (+1) 0
19:28:11 <SamB> only?
19:28:18 <SamB> certainly it is the worst of the syntax
19:28:22 <dons> Igloo: QuickCheck properties are a generalised HUnit (i.e. you get more tests for free), and should be preferred. however, its not practical to use QuickCheck for impure code, so you'd fall back to HUnit.
19:28:32 <dons> Igloo: this has been dcoutts and my experience, at least.
19:28:33 <dave_m> > (\a b c d -> (a (b (c d)))) (+1) (+1) (+1) 0
19:28:34 <lambdabot>  3
19:28:42 <SamB> dons: that doesn't fit with my definition of "generalized" ;-P
19:28:50 * SamB does dishes and supposedly goes to bed
19:28:59 <dons> SamB: don't be difficult, please.
19:29:17 <monochrom> yeah, don't be difficult to Haskell syntax
19:29:19 <chessguy> ((. (.)) . (.) . (.)) (+1) (+1) (+1) 0
19:29:22 <chessguy> > ((. (.)) . (.) . (.)) (+1) (+1) (+1) 0
19:29:23 <lambdabot>  3
19:29:29 <chessguy> wow
19:29:29 <dons> heh
19:29:42 <glguy> ?type \m -> runReaderT 3 (runStateT 4 (runIdentity m))
19:29:43 <lambdabot> Not in scope: `runIdentity'
19:29:51 <glguy> :-/
19:29:56 <dave_m> @type (.) . (.) . (.)
19:29:58 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
19:30:01 <mauke> wtf, why doesn't my fun.hs work in ghci-6.6?
19:30:04 <dons> ?hoogle runIdentity
19:30:04 <lambdabot> Control.Monad.Identity.runIdentity :: Identity a -> a
19:30:08 <Igloo> dons: Can I see such QC tests for something? fps's reverse would be a nice one if you have it?
19:30:09 <dons> glguy: well spotted
19:30:34 <dons> prop_reverseBL      = L.reverse     `eq1` (reverse   :: [W] -> [W])
19:30:38 <chessguy> anyway, no suggestions on my pasted code?
19:31:00 <dons> or, say, prop_count c xs = length (L.elemIndices c xs) == fromIntegral (L.count c xs)
19:31:27 <Igloo> dons: So it's entirely plausible that that would not find a bug in an impl that managed to not handle the empty list case, right?
19:31:42 <Igloo> (this particular example is unlikely due to how QC works, but that aside)
19:31:49 <dons> QC should generate the right data
19:31:54 <dons> otherwise its a bug in the Arbitrary instance
19:32:03 <glguy> What kind of performance penalties might: runStateT s (runIdentity m)  impose over: runState s m?
19:32:06 <dons> which is easier to spot than missing test data in HUnit.
19:32:09 <Igloo> dons: But as a human I know that the empty case is something I'd definitely want to check for reverse
19:32:19 <dons> right. you can test that if you want
19:32:30 <dons> ?check \c -> reverse (reverse c == id (c :: T)
19:32:31 <lambdabot>  Parse error
19:32:37 <dons> ?check \c -> reverse (reverse c) == id (c :: T)
19:32:38 <lambdabot>  OK, passed 500 tests.
19:32:45 <dons> ?check \c -> not (null c) ==> reverse (reverse c) == id (c :: T)
19:32:46 <lambdabot>  OK, passed 500 tests.
19:32:55 <dons> ?check \c ->(null c) ==> reverse (reverse c) == id (c :: T)
19:32:56 <lambdabot>  Arguments exhausted after 131 tests.
19:33:02 <dons> (just testing the empty list :)
19:33:10 <dons> ?scheck \c -> not (null c) ==> reverse (reverse c) == id (c :: T)
19:33:15 <lambdabot>  Completed 623530 test(s) without failure.  But 1 did not meet ==> condition.
19:33:25 <Igloo> dons: But now you're using QC to write HUnit tests
19:33:35 <dons> right. HUnit with a generator.
19:33:45 <dave_m> glguy: More indirect function calls, but hasell implementations should be good at optimizing them
19:34:08 <dons> Igloo: once you've got a generator, you're going to have better test coverage than in HUnit
19:34:13 * Igloo thinks QC is worthwhile, but given what people are likely to produce in both cases I'd rather have HUnit tests
19:34:27 <dons> either would be ok. I think anything in Data.* should have QC properties
19:34:44 <dons> so the idea is QC where possible, unit/hUnit everywhere else
19:34:48 <dave_m> Last time I checked, HUnit was better than QC if you wanted to run multiple tests at once
19:34:52 <Igloo> If you ask for QC tests you'll get what you first wrote, and not tests designed to catch the tricky cases
19:35:11 <dons> Igloo: feel free to write a testing guide :)
19:35:17 <Igloo> :-)
19:35:43 <dons> we abanedone HUnit in fps to switch to QC -- coverage just wasn't good enough.
19:36:14 <dave_m> Anyone have experience with SmallCheck?
19:36:24 <dons> ?scheck yes == yes
19:36:25 <lambdabot>  Not in scope: `yes'
19:36:36 <dons> ?scheck \yes -> yes == (yes :: Bool)
19:36:37 <lambdabot>  Completed 2 test(s) without failure.
19:36:40 <dons> :)
19:36:44 <dave_m> neat
19:36:49 <dibblego> ?spellcheck abanedone
19:36:50 <lambdabot> Unknown command, try @list
19:36:53 <dibblego> :)
19:36:59 <Igloo> dons: Do you still have the HUnit tests?
19:37:00 <monochrom> abandon
19:37:06 <dons> Igloo: in darcs, yes.
19:37:17 <dons> they got rewritten as QC tests
19:37:25 <chessguy> i guess there's just not much interest in here in GP
19:37:30 <dons> and then we wrote our own stress tester for large data
19:38:00 <Igloo> Hmm, it's 3:37 and if I start looking at that now I'll stay up until my compile finishes. I'll take a look tomorrow  :-)
19:38:40 <dons> Igloo: started on http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
19:38:46 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
19:39:18 <Igloo> dons: Hmm, we really need a darcs-backed wiki. *sigh*
19:39:35 <dons> yes
19:39:52 <dons> i suppose one could interface darcs to mediawiki somehow
19:40:02 <chessguy> what's the difference between pure and impure code?
19:40:17 <Igloo> Bleurgh
19:40:21 <dons> chessguy: the type.
19:40:27 <dons> :)
19:40:37 <chessguy> ...
19:40:48 <monochrom> IO is impure.  I don't know about ST.
19:40:51 * Igloo needs to finish my conflictors paper so I can show it to lots of clever people, have them solve the problem, fix darcs, then get a tuit to write a shiny wiki with working darcs. Easy.
19:40:52 <dons> ?google tackling the awkward squad
19:40:55 <lambdabot> http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
19:40:56 <dave_m> In Haskell, impure code usually involve the IO type
19:40:56 <lambdabot> Title: Simon Peyton Jones: papers
19:41:43 <chessguy> so waht makes IO impure?
19:41:46 <chessguy> *what
19:42:05 <dibblego> byte readFile(FILE *) // try writing that as a pure function
19:42:10 <EvilRanter> if you read input twice, you won't get the same result each time
19:42:28 <dibblego> you could if you passed the file system as a function argument
19:42:31 <chessguy> i thought that was where monads came in
19:42:35 <dibblego> IO is a monad
19:42:45 <dave_m> you can't express IO in Haskell alone, it requires support from the runtime
19:42:51 <chessguy> so monads are generally impure?
19:42:58 <int-e> no. IO is.
19:43:17 <dibblego> I hold that it isn't, but I am on my own there
19:43:20 <int-e> ST to some extent, the other monads generally aren't.
19:43:27 <chessguy> ok, but monads don't solve the problem
19:43:30 <ThreeQ> i don't understand how ST or IO are impure
19:43:37 <dibblego> we pass file systems as arguments all the time - they call them "Revision Control Systems"
19:43:37 <mwc> @seen dcoutts
19:43:38 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 28m 21s ago.
19:43:43 <glguy> I definitely don't see how ST is impure
19:43:56 <chessguy> mwc, dcoutts went to bed
19:44:02 <ThreeQ> there's no way IO can be run without attaching it to main or using unsafePerformIO
19:44:13 <int-e> glguy: it's hard to implement efficiently in a pure fashion.
19:44:26 <dave_m> I would call ST pure. Any monad with a "run" function can be done with functions
19:44:30 <int-e> glguy: emphasis on 'efficiently'.
19:44:46 <mwc> dave_m, ST guarantees inplace update of mutable arrays and reference cells.
19:44:56 <mwc> which is an efficiency boost for a lot of things
19:44:56 <glguy> int-e: the underlying implementation details don't seem like they would affect whether it would be pure or not
19:44:58 <int-e> ST uses unsafe functions internally.
19:45:13 <monochrom> Gosh what did I start?
19:45:26 <EvilRanter> if the interface is provably pure, it should be okay to use it in a pure program, shurely?
19:45:29 <int-e> glguy: if you call a monad impure, then you have to be talking about the implementation, because the interface is almost certainly pure.
19:45:47 <int-e> glguy: anyway, I was talking about the implementation, not the interface.
19:45:50 <EvilRanter>  /\ my point, right there
19:45:52 <glguy> Oh, OK
19:46:01 * glguy doesn't care about the implementations (-;
19:46:14 <monochrom> Perhaps Haskell is a 4GL or 5GL too?
19:46:18 <dave_m> mwc: true enough. To implement ST in pure Haskell, you would need to cheat and use unsafeCoerce#
19:46:19 <chessguy> i don't get it....whenever monads are talked about in the context of IO, they always say "IO is one thing that's hard to do in FP, because you get different input....but here's the solution! IO monads!"...but you're saying it doesn't solve the problem?
19:46:33 <glguy> ?type \m -> runStateT 4 (runReaderT 3 m)
19:46:34 <lambdabot> forall (m :: * -> *) a r (m1 :: * -> *) a1. (Num (StateT (m a) m1 a1), Num (ReaderT r m a)) => r -> m1 (a1, m a)
19:46:42 <monochrom> I don't talk like that, chessguy.
19:46:46 <int-e> chessguy: no, but it effectively hides the problem.
19:46:53 <int-e> chessguy: you get a pure interface.
19:46:58 <mwc> chessguy, the point of IO monads and ST monads is they allow you to be dirty but use the type system to guarantee the effects are isolated
19:47:08 <int-e> chessguy: and you can stop worrying about how it's implemented.
19:47:21 <int-e> chessguy: which is what glguy said I think :)
19:47:23 <glguy> ?type do { put 1; tell [2] }
19:47:25 <lambdabot> Not in scope: `tell'
19:47:27 <monochrom> I think Peyton Jones's "Tackling the Awkward Squad" talks correctly.
19:47:37 <glguy> ?type do { put 1; Control.Monad.Writer.tell [2] }
19:47:38 <lambdabot> forall s (m :: * -> *) a. (MonadState s m, Num s, Control.Monad.Writer.MonadWriter [a] m, Num a) => m ()
19:47:39 <dave_m> something like getChar is pure, because it always returns a procedure that gets a character
19:47:46 <dibblego> chessguy, if you pass the entire universe as a function argument, all functions in any language are pure
19:48:00 <dave_m> actually getting the character is impure, but that happens behind the scenes in the runtime
19:48:04 <monochrom> dibblego has a point too.
19:48:08 <chessguy> sure
19:48:22 <dibblego> chessguy, the point is "purity" is relative to the observer
19:48:44 <dibblego> since no observer exists outside of the universe, purity definitely holds always
19:49:16 <dibblego> with that, I think you might understand monads better (I do at least)
19:49:43 <monochrom> It is not that monochrom changes.  It is that monochrom(t) and monochrom(t+1) are different.  They are different constants.  What has changed?
19:49:53 <int-e> Basically the trick is to introduce artificial data dependencies and hope noone ever invents time-travel and uses it in a machine with a haskell compiler.
19:50:35 <dibblego> we assume we are in constant time with our software
19:50:48 <glguy> ?type do { put 1; Control.Monad.Writer.tell [2]; liftIO $ print 3 }
19:50:50 <dibblego> at least, we (pure functional programmers) do - those imperative programmers do not
19:50:50 <lambdabot> forall s a (m :: * -> *). (Num s, MonadState s m, Control.Monad.Writer.MonadWriter [a] m, Num a, MonadIO m) => m ()
19:50:57 <dave_m> what if you Haskell software is traveling faster than light?
19:51:03 <dave_m> your
19:51:07 <dibblego> then everything we have said does not hold
19:51:20 <dibblego> I have long held this position, but it is suppressed
19:51:31 <SamB> dibblego: hey, I think you are making some metaphysical assumptions ;-)
19:51:37 <EvilRanter> could an analogy be drawn to "(aCharacter, newInputState) = readCharacter oldInputState"?
19:51:50 <glguy> is it possible to use put and tell like I just did using the standard monad transformers?
19:52:00 <EvilRanter> (add "let" as appropriate)
19:52:06 <glguy> or is lift always needed?
19:52:14 <dons> Igloo: would be nice to be able to create project-speciific Trac namespaces on the main trac instance
19:52:19 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/4c1cb17ded810ea0?hl=en&
19:52:22 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/vahu8
19:52:27 <monochrom> I wrote that.
19:52:27 <dons> Igloo: so the community could reuse the one bug tracker, in a centralised place
19:52:28 <SamB> dibblego: such as, oh, determinism? (well, maybe not. I suppose you are simply assuming you will never have the same universe twice...)
19:52:29 <glguy> comp.lang.fictional?
19:52:31 <glguy> :)
19:52:32 <dave_m> glguy: sure
19:53:03 <glguy> dave_m: after reading the paper that I mentioned earlier, it's no longer clear to me when lift is needed
19:53:05 <dibblego> I think this little quiz sums it up :) http://www.travelfurther.net/fun/fsquad.htm
19:53:08 <lambdabot> Title: TravelFurther - Fun & Games
19:53:09 <dave_m> So, I wonder if we could link our monads to Leibnitz's monadology
19:53:57 <coffeemug> hey
19:54:06 <monochrom> Nondeterminism still does not imply mutable state.
19:54:20 <dave_m> glguy: put and tell automatically lift, assuming the monad transformer promotes MonadState and MonadWriter
19:54:26 <glguy> . o O (A five-blade razor, omg, what I've been waiting for my whole life)
19:54:34 <dons> !
19:54:36 <dons> it had to happen
19:55:02 <dons> how much money would i make releasing a razor based on the design of a chain saw?
19:55:07 <dave_m> glguy: for example, "StateT s (Writer o)" or "WriterT o (State s)"
19:55:07 <glguy> dave_m: how do I know which monad transformers automatically promote?
19:55:15 <dons> 128 blades of pure manly cutting power!
19:55:37 <dave_m> They would have instances like "MonadState s m => MonadState s (WriterT o)"
19:55:56 <dave_m> s/WriterT o/WriterT o m/
19:56:13 <mwc> glguy, is that the Gillette Fusion?
19:56:17 <mwc> I've had one for about a year now
19:56:24 <mwc> I will admit to thinking they're awesome
19:56:43 <glguy> mwc: yeah, I just saw the commercial for it
19:56:57 <dave_m> my favorite commentary on mult-bladed razors: http://www.irregularwebcomic.net/1186.html
19:56:58 * glguy is content with his *Mach-3 Turbo*
19:56:59 <lambdabot> Title: Irregular Webcomic!
19:57:11 <coffeemug> does anyone here build GHC from source?
19:57:15 <coffeemug> and hack on it? :)
19:57:19 <coffeemug> I have a few questions
19:57:32 <dons> sure. many do.
19:57:59 <coffeemug> one thing I can't figure out is how to get ghc-inplace to recognize packages installed by another ghc compiler
19:58:01 <mwc> It doesn't destroy my neck like the Schick did
19:58:11 <EvilRanter> I am amused by people who think a "quantum leap" is big. an electron changing energy levels within an atom really isn't moving very far...
19:58:12 <coffeemug> how do I point it to use an old package.conf?
19:58:24 <mwc> coffeemug, my theory is that it tags the hard drvie secotrs with dark matter
19:58:33 * glguy shaves like a real man, without shaving cream ;) that's how smooth his 3blade is
19:58:33 <Cale> EvilRanter: I agree
19:58:37 <coffeemug> mwc: where possible :)
19:59:14 <monochrom> I just use an electric
19:59:18 <araujo> Bah
19:59:23 <araujo> I use a knife for shaving
19:59:30 <araujo> That's how *real* old school men do
19:59:33 <glguy> monochrom: so does my gf (-;
19:59:51 <monochrom> Real men don't shave.
19:59:56 <glguy> old school men go to a barber shop and get a straight razor shave
20:00:04 <mwc> I wanted to get a straight razor. I was scared I'd slip on a wet floor and slit my throat
20:00:08 <monochrom> Oh I have a better one!
20:00:28 <monochrom> Real men shave and only shave those who don't shave themselves.
20:00:56 <coffeemug> nobody has any idea? :(
20:01:01 <dave_m> Real men stop their hair growth by sheer willpower
20:01:32 <glguy> Chuck Noris roundhouse kicks himself in the face to shave... it's true
20:01:57 <monochrom> or by castration
20:03:00 <coffeemug> ah
20:03:02 <coffeemug> I should join #ghc
20:03:03 <dons> coffeemug: install them again using the inplace pkg.conf?
20:03:03 <glguy> Cale: You about?
20:03:11 <dons> coffeemug: no, not #ghc, I think.
20:03:17 <dons> its a user question, not a dev issue
20:03:30 <dons> i.e. ghc-pkg-inplace to reregister the pakcages
20:03:37 <dons> otherise, try editing the package.conf.inplace ...
20:03:55 <monochrom> I think coffeemug wants to hack ghc and will have dev questions.
20:04:16 <dons> (just don't think there's much #ghc activity atm)
20:05:12 <coffeemug> dons: but there is no ghc-pkg-inplace
20:05:50 <dons> I thought there was one in ghc/utils/ghc-pkg/
20:06:14 <coffeemug> ahh shit
20:06:16 <coffeemug> I'm sorry
20:06:28 <coffeemug> it wasn't documented
20:06:36 <glguy> Cale: (for when you get back) When using RandomT and StateT, does RandomT try to get StateT's get and put?
20:06:56 <coffeemug> and where can I find packe.conf.inplace?
20:06:58 <Cale> glguy: no
20:07:17 <dons> ghc/driver/*
20:08:30 <coffeemug> ahhh
20:08:32 <coffeemug> you're the man
20:08:32 <mwc> what's RandomT?
20:08:40 <mwc> StateT embedding a RandomGen
20:08:58 * araujo goes and gets more black tea
20:08:58 <coffeemug> dons: also, once I modify something, like Linker.c for example, how do I just rebuild that part?
20:09:16 <dons> cd ghc/rts ; make
20:09:34 <dons> cd ghc/compiler ; rm -rf stage2/ghc-* ; gmake -- to relink the compiler with the new rts
20:10:11 <glguy> Cale: so... I should be able to use someting of type: RandomT StdGen (State Int) Int, and not use lift?
20:12:02 <coffeemug> when I get the chance I'll update the wiki with this stuff
20:12:36 <Cale> glguy: if you write an instance of MonadState for it
20:13:02 <Cale> glguy: I recommend newtyping every time you use monad transformers, because it makes everything look a lot cleaner
20:13:15 <dons> mmm. http://www.electricstuff.co.uk/cdzap.html
20:13:17 <lambdabot> Title: CD Zapping
20:13:21 <Cale> (and in addition, gives you a place to insert things like consistency checking)
20:13:30 <palomer> hrmph
20:13:37 <palomer> you're all nuts
20:13:48 <glguy> Cale: Is that what you did in your Sudoku solver on the wiki?
20:13:57 <mwc> What's the difference between a newtype Foo = FooC Bar and data Foo = FooC Bar
20:14:03 <Cale> glguy: yeah
20:14:11 <glguy> ?instances MonadState
20:14:13 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
20:14:14 <mwc> My theory was that the newtype version uses the same underlying representation as the Bar
20:14:15 <dave_m> mwc: the newtype one is strict
20:14:17 <palomer> I was thinking of writing a soduko solver
20:14:30 <mwc> dave_m, strict in its Bar?
20:14:44 <dave_m> right, because it uses the same underlying representation
20:14:49 <glguy> Cale: I see now, those monad's explicity pass get and put into the next monad
20:14:53 <Cale> mwc: yes, all you're creating with a newtype is a new type, the data representation stays the same
20:14:56 * glguy thought there was some magic going on
20:15:45 <Cale> glguy: yeah, I just neglected to provide instances, since in practice, it seems you want to think about what instances you're providing anyway
20:16:03 <mwc> So it's basically a "transparent" representation of the underlying type, whereas the data creates a box that holds a Bar.
20:16:08 <glguy> Cale: It makes sense not to provide a ton of instances like that, I just didn't realize that that was what was going on
20:16:09 <Cale> mwc: right
20:16:11 <mwc> I see what dave_m meant about striuctness now
20:16:47 <palomer> which solver is the quickest?
20:16:49 <dave_m> Cale: even when I'm newtyping a stack of monad transformers, I usually promote the standard monad classes. It makes it easier to reuse the new monad in some other stack
20:17:40 <mwc> palomer, the one that flips to the back of the book
20:18:05 <palomer> har har har
20:18:13 <mwc> I try :)
20:18:14 <palomer> hrmph, completeness proofs aren't easy
20:20:02 <dave_m> speaking of completeness proofs, has anyone tried using a theorem prover to show that a particular monad satisfies the monad laws?
20:20:25 <dave_m> I would be interested to see how that's done
20:20:48 <dons> heh, http://rmitz.org/freebsd.daemon.html
20:20:50 <lambdabot> Title: Daemons and Texans don't mix
20:20:59 <dons> glguy: i presume fishies are ok
20:21:13 <dons> dave_m: yeah, its been done in Isabelle at least
20:21:21 <dons> (can be done by hand too .. they're not too hard)
20:21:34 <dons> (at least for some monads)
20:21:47 <glguy> dons: fishies?
20:21:49 <dave_m> yeah, but it's the complicated ones that bother me
20:22:18 <dons> glguy: blow fishies, instead of devils
20:22:43 <glguy> dons: Will all of this make sense after I read the rmitz link?
20:22:56 <dons> yes :)
20:23:45 <dave_m> dons: Consider a type T w a = T (forall b. w b -> (a,b)). You can write a function that looks like (>>=) for Comonad w => T w, but it almost certainly violates the monad laws
20:24:23 <dons> yeah, if you were writing a paper, you'd probably want to pull out Isabele or twelf. and then writer another paper about proving monad laws mechanically
20:26:37 <glguy> dons: I don't know... do ignorant people fear fish?
20:27:46 <mwc> I hate sharks
20:27:54 <mwc> does that count?
20:28:06 <glguy> assuming you are also ignorant, then yes, yes it does
20:28:23 <dmead> dee daa lee dee
20:28:35 <int-e> is hating wales ok, too? or is that being too ignorant?
20:28:39 <int-e> whale?
20:28:49 <glguy> int-e: Wales? from the UK?
20:28:50 <dons> i don't think you should hate the Welsh
20:28:55 <int-e> glguy: no, typo.
20:28:58 <dons> they're really quite an ok people :)
20:29:05 <glguy> int-e: Freudian slip?
20:29:24 <int-e> glguy: doubt it. nothing sexual involved, and not my mom either.
20:29:40 <sjanssen> int-e: to answer your question, there is probably something ignorant about hating "wales"
20:29:58 <mwc> I like whales, especially Orcas. They kill sharks.
20:30:12 <int-e> sjanssen: Actually I meant, does it count as hating fish? :)
20:30:41 <int-e> but now it's not funny anymore.
20:31:03 <dave_m> what about hating shellfish?
20:31:50 <dibblego> how do you make a type implement a type class?
20:32:02 <glguy> instance
20:32:07 <dibblego> that's right, thanks
20:36:50 <sjanssen> another acceptable answer: "carefully"
20:37:21 <dons> heh
20:37:30 <int-e> ask it, in a friendly tone?
20:39:06 * dave_m uses good cop/bad cop to make types implement classes
20:40:52 <satan> can i ask a domain theory question?
20:40:56 <satan> :)
20:41:01 <monochrom> Yes.
20:41:05 <sjanssen> int-e: kindness can be d(e)riving motivation
20:41:43 <glguy> satan: *I don't know... can you?*
20:41:54 <dave_m> satan: the important question is, "can we answer it?"
20:41:58 <satan> ok, Consider f, where, f _|_ = False, f True = True, F False = _|_. What is the value of fix f, where fix is the function defined by the Tarski-Scott Fixpoint Theorem?
20:42:06 <glguy> dons: Those guys in Texas would definitely not get along with satan...
20:42:25 <monochrom> That's wacky!
20:42:33 <satan> so according to that theorem, fix f = U {f^i(_|_ | i >0}
20:42:44 <satan> where that U is the rectangular U for Upper Bound
20:42:54 <satan> eh, why texas...what?
20:43:15 <dave_m> satan: see http://rmitz.org/freebsd.daemon.html
20:43:16 <lambdabot> Title: Daemons and Texans don't mix
20:43:20 <sjanssen> Texas sucks.
20:43:28 <monochrom> f is not monotonic.  therefore f is not continuous.  therefore the fixed point theorem says nothing about f.
20:43:29 <satan> so should i start by doing f (fix f) ?
20:43:51 <dave_m> I hear Austin is nice
20:43:51 <glguy> Only two things come from Texas, steers and queers, and you don't have any horns...
20:43:53 <satan> monochrom: f is not monotonic because it's not increasing
20:43:57 <Cale> f only has True as a fixed point
20:44:14 <EvilRanter> hmm...sleep sounds like a plan
20:44:17 <satan> so the Tarski-Scott theorem doesnt apply here?
20:44:24 <satan> and True is the least fixpoint of f
20:44:42 <monochrom> Correct.  The formula U {f^i(_|_ | i >0} is for continuous f
20:45:06 <satan> so how would i approach it, if it were a continuous function? would i start by....
20:45:38 <monochrom> IF it were continuous, use the formula U {f^i(_|_ | i >0}
20:45:54 <satan> taking f of both sides, so then the index of the i inside the {} would increment and so on
20:46:08 <satan> oh i see hmmm
20:46:12 <monochrom> You are asking how to use the formula?
20:46:15 <satan> yes
20:46:58 <monochrom> Imagine the sequence _|_, f_|_, f(f_|_), f(f(f_|_))), ...
20:47:17 <monochrom> It should converge to something.  Find out what it converges to.
20:47:18 <satan> ok
20:47:31 <satan> so just repeat until i have a converging value, is that the idea
20:47:38 <monochrom> Yes.
20:48:01 <satan> ok thanks :)
20:48:43 <dave_m> I occasionally wish I knew more about domain theory or topology. Are there any introductions one might recommend for Haskell programmers?
20:49:20 <satan> so for something like f x = (x + 4/x) / 2, i'd start with _|_ as well, i'd have to assume that arithmetic operators were strict, right?
20:49:30 <monochrom> Davey & Priestley "introduction to lattice and order" works for me
20:49:54 <monochrom> Vickers "topology via logic"
20:50:11 <monochrom> Cambridge University Press books are cheap and good!
20:50:28 <monochrom> Yes satan
20:51:04 <satan> please bear with me here, so i'd get f _|_ = (_|_ + 4/_|_) / 2 which would be _|_, right
20:51:06 <monochrom> Hah, _|_ is the least fixed point of f.
20:51:15 <satan> so then _|_ would be the least fp?
20:51:42 <satan> so i could stop with i = 0, without going any further, right?
20:51:58 <monochrom> i=1 I would say.
20:52:16 <satan> right cause we did do one step
20:53:02 <monochrom> Take note that Okassaki's data structure book and Andrew Gordon's functional I/O thesis are also Cambridge University Press books!
20:53:10 <satan> thanks, and i'll check those books out
20:53:57 <monochrom> I should work for CUP as an advocate.
20:54:54 <Adamant> I visited CUP bookstore in Cambridge, now I just have to find the MIT Press bookstore in U.S. Cambridge and I can die a happy man
20:56:48 <monochrom> You are easily satisfied.
20:56:49 <dibblego> data Card = Card { rank :: Rank, suit :: Suit } -- what are those names "rank" and "suit" called?
20:57:13 <Adamant> monochrom, what can I say, I'm a cheap date
20:57:25 <dave_m> dibblego: field labels?
20:57:30 <dibblego> dave_m, ta
20:57:44 <ThreeQ> selectors, maybe
20:58:38 <chessguy> YAHT calls them named fields
20:59:10 <dibblego> ta
20:59:11 <monochrom> deconstructors
20:59:33 <monochrom> projections
20:59:50 <ThreeQ> SICP calls them selectors, but I'm not sure if that's a general term or not
20:59:50 <dave_m> From the Haskell Report, "For large datatypes it is useful to assign field labels to the components of a data object."
21:00:02 <dave_m> see http://haskell.org/onlinereport/decls.html
21:00:05 <lambdabot> Title: The Haskell 98 Report: Declarations
21:00:24 <chessguy> pff, if you're going to cite a source, cite some place authoritative, would you? :)
21:00:43 * dave_m hangs head in shame
21:00:44 <dons> labels in data structures generate field selection functions with the same name
21:00:55 <dons> they can be called 'accessors' or 'selectors' I suppose
21:00:57 <palomer> you're all nuts!!
21:01:20 <monochrom> The Haskell 98 Report is not authorative?
21:01:20 <dave_m> but the names themselves are also used in pattern matching
21:01:20 <chessguy> getters and setters!
21:01:28 <chessguy> monochrom, that was a joke
21:01:54 <coffeemug> dons: when you said gmake to rebuild a part of the tree, what's the difference between gmake and make?
21:02:38 <monochrom> On some people's computers, make is not GNU make.
21:03:08 <coffeemug> so it needs to be gnu make, mingw make won't do?
21:03:23 <coffeemug> I mean, if I use make to build the whole source tree, why do I need gmake to build part of the tree?
21:03:25 <monochrom> Ah, I don't know mingw
21:03:42 <monochrom> Perhaps dons is thinking of dons's computer.
21:03:43 * dave_m loves the Unix tradition of having multiple, subtly different tools with the same name
21:03:57 <coffeemug> yeah
21:04:00 <coffeemug> that's always fun :)
21:04:37 <int-e> Ah, do you 'ps efa' or 'ps aux'?
21:04:44 <dave_m> At least the various Haskell implementations aren't all called hskl or hcc or something
21:04:59 <monochrom> they're all called runhaskell
21:05:24 <satan> huh, what is the difference in how these 2 are defined?
21:05:32 <dave_m> touche
21:05:34 <satan> scanl f q xs = q : (case xs of [] -> [], x:xs -> scanl f (f q x) xs)
21:05:35 <satan> and
21:05:45 <satan> scanl f e [] = []
21:05:45 <satan> scanl f e (y:ys) = e : scanl f (f e y) ys
21:06:12 <satan> scanl gives all intermediate results and the final result, right?
21:06:48 <monochrom> In the first version, scanl f x [] = [x].  In the second version, [].
21:07:04 <x3m2> dave_m: are you kidding, most of them are like (x)hc, just like all other unix people cant come up with new names, like aterm, xterm, eterm and so on
21:07:31 <satan> ah i see, so it just attaches the head at different places
21:09:01 <satan> and why does 'let xs = scanl (+) 1 xs' return an infinite list of powers of 2?
21:09:02 <monochrom> No no no.  They are completely different functions.  By that I mean they behave completely differently.
21:09:11 <dave_m> x3m2: At least ghc, jhc, nhc, and yhc are different names. Something like ls will have different options depending on whether it's the AT&T, GNU, or BSD version
21:09:21 <satan> hmm i see
21:09:24 <dave_m> because it's not the same software
21:10:40 <Cale> scanl f z xs = map (foldl f z) (inits xs)
21:11:00 <Cale> though it behaves a bit better than that performance-wise :)
21:11:52 <satan> i see, but why powers of 2?
21:12:11 <satan> i typed that into ghci and then did 'take 5 xs' and got [1,2,4,8,16]
21:12:18 <Cale> well, let's trace out some elements of xs :)
21:12:24 <satan> ok :)
21:12:27 <Cale> so what's the first one?
21:12:46 <satan> well, i don't even know what xs is, what is it when i type in xs? the empty list?
21:12:56 <Cale> xs = scanl (+) 1 xs
21:13:19 <Cale> the list returned by scanl f z always starts off with z
21:13:24 <satan> so it's recursive, but..
21:13:26 <satan> oh ok
21:13:31 <Cale> so the first element is 1
21:13:37 <satan> right
21:13:46 <Cale> let's actually use the definition of scanl
21:14:12 <satan> ok
21:14:16 <monochrom> Imagine the sequence: _|_, scanl (+) 1 _|_, ...  find out what it converges to.  Or at least look at the evolution of the first 5 terms.
21:14:17 <Cale> scanl            :: (a -> b -> a) -> a -> [b] -> [a]
21:14:17 <Cale> scanl f q xs     =  q : (case xs of
21:14:17 <Cale>                             []   -> []
21:14:17 <Cale>                             x:xs -> scanl f (f q x) xs)
21:14:27 <Cale> so...
21:14:30 <monochrom> (Apply the theory you learned!)
21:15:02 <Cale> scanl (+) 1 xs = 1 : (case xs of [] -> []; (x:xs) -> scanl (+) (1 + x) xs)
21:15:14 <satan> right, so we have 1 and then it calls xs again
21:15:18 <Cale> of course, xs matches (x:xs)
21:15:24 <Cale> and so
21:15:50 <satan> so we get scanl (+) 2 xs?
21:15:51 <Cale> xs = 1 : scanl (+) (1 + 1) (tail xs)
21:16:15 <satan> ohh so thats why
21:16:15 <Cale> (note the pattern match shadows the definition of xs)
21:16:51 <satan> i see
21:17:13 <Cale> Now, I think I saw above that you asked why it matters that scanl isn't defined with two separate cases
21:17:37 <satan> yes i was curious about the difference between the two declarations i pasted
21:17:51 <Cale> The reason that it matters is that in cases like these, it would try to pattern match against xs before the first element was determined
21:18:01 <Cale> and thus the result would be _|_
21:18:23 <satan> ahh ok
21:18:56 <monochrom> Domain theory is very powerful in explaining the mysteries of the world.
21:19:00 <Cale> You can see that scanl as it's defined here is immediately productive
21:19:07 * glguy strongly considers supporting the cadidate whose campaign ads are less assinine even thought he would otherwise support the other candidate
21:19:19 <satan> right
21:19:24 <mwc> @type scanl
21:19:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:19:31 <satan> i need to read up on domain theory a bit more, a lot more
21:19:53 <Cale> Most of the domain theory I know, I've just absorbed via osmosis.
21:20:27 <monochrom> Not really.  If you know U f^i(_|_)  you're done.  What you need is practicing that formula.
21:20:46 <satan> very true
21:20:52 <satan> i should do more problems
21:21:34 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 5
21:21:36 <lambdabot>  120
21:22:23 <satan> wouldn't the fix point of that be 1?
21:22:26 <Cale> Characterise f^i in that case :)
21:22:35 <monochrom> The sequence in this case ends up as: _|_, 1:_|_, 1:2:_|_, 1:2:4:_|_, ...
21:23:30 <satan> ok so we always start with f _|_, right?
21:23:39 <Cale> yeah
21:23:43 <Cale> or just _|_
21:24:05 <satan> no difference?
21:24:12 <Cale> f^0 or f^1
21:24:30 <monochrom> Heh, _|_ is too easy.
21:24:36 <Cale> either way, you can start as far along in the sequence as you like, since only the limit matters
21:24:55 <satan> f^0 would be _|_, since we'd be comparing _|_ == 0 , which would give us _|_
21:25:05 <satan> oh i see
21:25:39 <Cale> actually, you wouldn't
21:26:03 <satan> no?
21:26:08 <Cale> f _|_ 5 = if 5 == 0 then 1 else 5 * (_|_ (5 - 1))
21:26:53 <satan> ah, so it'd conk out in this bit:  (_|_ (5 - 1)) ?
21:26:58 <Cale> yeah
21:27:00 <monochrom> I use ? for _|_.  scanl(+) 1 (1:2:4:?) = 1:scanl(+) 2 (2:4:?) = 1:2:scanl(+) 4 (4:?) = 1:2:4:scanl(+) 8 ? = 1:2:4:8:?
21:27:10 <Cale> but if we passed 0 in, it wouldn't conk out at all
21:27:21 <satan> right, it would just return 1
21:27:46 <Cale> > let u f n = if n == 0 then 1 else n * (f (n - 1)) in u undefined 0
21:27:48 <lambdabot>  1
21:27:49 <Cale> > let u f n = if n == 0 then 1 else n * (f (n - 1)) in u undefined 1
21:27:51 <lambdabot>  Undefined
21:27:54 <satan> can i ask why the results are being cons'ed into a list? is that just to help me understand?
21:28:10 <Cale> satan: he's still talking about the scanl example :)
21:28:19 <satan> ohh ok
21:28:30 <monochrom> Cale's least fixed point is harder since it talks of a sequence of functions.
21:28:35 <Cale> > let u f n = if n == 0 then 1 else n * (f (n - 1)) in u (u undefined) 1
21:28:36 <lambdabot>  1
21:28:40 <Cale> > let u f n = if n == 0 then 1 else n * (f (n - 1)) in u (u undefined) 2
21:28:41 <lambdabot>  Undefined
21:28:47 <Cale> > let u f n = if n == 0 then 1 else n * (f (n - 1)) in u (u (u undefined)) 2
21:28:49 <lambdabot>  2
21:28:53 <satan> monochrom: ah ok that makes sense, heh, i was wondering where the (:) was
21:28:58 <Cale> > let u f n = if n == 0 then 1 else n * (f (n - 1)) in u (u (u (u undefined))) 3
21:29:00 <lambdabot>  6
21:29:08 <int-e> > 5 * (4 * (3 * (2 * (1 * if 0 == 0 then 1 else undefined))))
21:29:10 <lambdabot>  120
21:29:38 <dons> ok, here we go guys,
21:29:39 <dons> http://www.google.com/coop/cse?cx=015832023690232952875%3Acunmubfghzq
21:29:41 <lambdabot> Title: Google Co-op - Custom Search Engine, http://tinyurl.com/y5kvdq
21:29:54 <dons> ?where+ haskell-search http://tinyurl.com/y5kvdq
21:29:54 <lambdabot> Done.
21:29:55 <Cale> note how as u is applied repeatedly to undefined, it becomes defined on a larger and larger domain
21:30:03 <satan> right
21:30:24 <Cale> the fixed point is the limit of this sequence of functions, which is, in fact, the factorial function
21:30:48 <satan> but why is it not conking out at all when you pass in undefined for f? because it doesnt check f, but rather n?
21:31:01 <Cale> It never has to evaluate that function
21:31:05 <dibblego> I have a function of type a -> [b] -> c and another function of type a -> b -> c and with the latter one I just want to call the former one with [b] -- do I have to use flip to do that to swap the argument order?
21:31:16 <Cale> unless the number I pass in is too high
21:31:35 <Cale> note that the else branch of an if is never evaluated when the condition is true
21:31:42 <satan> right
21:31:48 <satan> how high would make it evaluate it?
21:31:58 <palomer> ok, someone write a soduko solver in 15 characters or less...go!
21:32:14 <dibblego> asodukosolver
21:32:16 <Cale> palomer: we missed you :)
21:32:46 <Cale> well, u^(n+1) _|_ will be a factorial function operating on 0 through n
21:32:47 <int-e> 13 characters and a typo, wow.
21:33:16 <dibblego> it meets the specified requirements perfectly :)
21:33:21 <int-e> wait, the typo is palomer's
21:33:26 <dibblego> yes sir
21:33:30 <Cale> a soduko solver
21:33:33 <dibblego> I only write what my clients tell me to write
21:33:35 <Cale> is a less minimal solution
21:33:51 <dibblego> true
21:33:58 <Cale> > length "a soduko solver"
21:33:59 <lambdabot>  15
21:34:00 <palomer> I missed you guys too!
21:34:06 <palomer> I missed you guys more than I missed my parents
21:34:06 <Cale> Where'd you go?
21:34:12 <palomer> asia
21:34:16 <Cale> oh, cool
21:34:25 <int-e> solve soduko <-- imperative solution, the others were declarative ;)
21:34:51 <Cale> heh
21:34:54 <x3m2> the ghc people should work a bit on the debugger
21:35:10 <palomer> x3m2, too functional
21:35:17 * araujo sometimes forgets that now ghc went modular
21:35:22 <int-e> solve <-- solution using domain specific language
21:35:26 <x3m2> palomer: what?
21:35:34 <palomer> I think the time would be better spent by implementing some obscure and rather useless type system extension
21:35:41 <palomer> x3m2, a debugger is too functional a beast for haskell
21:35:42 <x3m2> they could do shitloads on that debugger
21:35:55 <x3m2> pff
21:36:21 <palomer> ok, who was spreading the fud while I was gone?
21:36:44 <glguy> I'm pretty sure that work is already being done on a debugger for GHC
21:37:16 <x3m2> im sure its not, some probably yes.. but they could do very much
21:37:46 <monochrom> what fud?
21:37:47 <dave_m> There are external Haskell debugging tools, like buddha and hat
21:37:54 <palomer> the smelly kind
21:38:06 <palomer> hat doesn't work with everything
21:38:08 <palomer> it's a bummer
21:38:13 <glguy> I thought there was even a google soc project for a ghc debugger
21:38:19 <glguy> or work towards that
21:38:48 <dave_m> The Alice ML runtime has some nice features for looking at values without forcing evaluation
21:39:31 <dave_m> I think it also lets you track mutable reference cells as they get modified
21:39:57 <Cale> "Never contain programs so few bugs, as when no debugging tools are available!" - Wirth :)
21:40:38 <palomer> the number of times I've prayed for a debugging tool
21:40:46 <palomer> at least something to tell me where my program is looping, ya know?
21:41:21 <x3m2> > dfold f z l = dfold' (\x t g -> f x (g t)) z l; dfold (+) 0 [1,2,3,4]
21:41:22 <lambdabot>  Parse error
21:41:58 <palomer>  > only accepts one liners
21:42:02 <palomer> that looks like a 2 liner to me
21:42:11 <dave_m> There are certainly times when it would be nice to pry open the runtime and find out what's going on
21:42:34 <int-e> > let dfold f z l = dfold' (\x t g -> f x (g t)) z l in dfold (+) 0 [1,2,3,4]
21:42:35 <lambdabot>  Not in scope: `dfold''
21:42:53 <Bobstopper> dons: I've done a sort of short summary on formal consensus which hopefully covers most of what's useful to software projects: http://bobstopper.livejournal.com/22939.html
21:42:54 <lambdabot> Title: bobstopper: Consensus for Free Software Projects
21:43:52 <dave_m> I find that writing small functions and making sure things work incrementally avoids most inexplicable errors, or at least gives you an idea of where the problem is
21:44:01 <Cale> @spell relevent
21:44:03 <lambdabot> relevant rel event rel-event relent reinvent
21:44:20 <Cale> Bobstopper: ^^ :)
21:44:23 <Bobstopper> Ah, thank you. My spell checker isn't working :)
21:44:24 <palomer> writing small functions, good naming conventions, thorough testing
21:44:25 <coffeemug> gn everyone
21:44:33 <palomer> it's all good and fine until the shit hits the fan
21:44:34 <dave_m> @spell intercalate
21:44:35 <lambdabot> intercalate
21:44:46 <Cale> @spell qwyjibo
21:44:47 <lambdabot> jib jujube jibe Jacobo Jobi
21:45:00 * dave_m is surprised "intercalate" is in the dictionary
21:45:22 <Cale> There are 3 entries for intercalate in OED :)
21:45:35 <dave_m> Is that the dictionary the spellchecker uses?
21:45:36 <Cale> n, ppl. a., and v
21:45:38 <Cale> no
21:45:49 <Cale>  	
21:45:49 <Cale> intercalate, n.
21:45:53 <Cale>    a. An atom or molecule, or a substance, that enters between the layers of the crystal lattice of another substance, esp. graphite. Freq. attrib.
21:45:57 <Cale> b. A compound formed by foreign atoms or molecules entering between the layers of a crystal lattice, esp. of graphite.
21:46:09 <dave_m> I'm surprised "intercalate" is in the spellcheck dictionary
21:46:10 <Cale> intercalate, ppl. a.
21:46:15 <Cale> Obs. rare
21:46:18 <Cale>    = INTERCALATED ppl. a.
21:46:22 <dons> ?web1913 intercalate
21:46:23 <lambdabot> *** "Intercalate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:46:23 <Cale> intercalate, v.
21:46:23 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
21:46:23 <lambdabot>   {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
21:46:23 <lambdabot>   intercalatus, p. p. of intercalare to intercalate to
21:46:23 <lambdabot>   intercalate; inter between + calare to call, proclaim. See
21:46:25 <lambdabot> [10 @more lines]
21:46:29 <Cale>  1. trans. To insert (an additional day, days, or month) in the calendar in order to bring the current reckoning of time into harmony with the natural solar year. Also absol.
21:46:33 <Cale>    2. transf.    a. To insert or interpose something additional, extraneous, or out of the ordinary course, between the ordinary members of any series or the successive parts of any whole; to interpolate. Chiefly in pass.
21:46:38 <Cale>     b. Geol. in pass. pple. Interstratified, interbedded with the original series.
21:46:42 <dons> Bobstopper: thanks
21:46:45 <Cale>     3. intr. To become part of a sequence or array as an extraneous interpolation; to become intercalated in or inserted into.
21:47:14 <palomer> ?web1913 thru
21:47:15 <lambdabot> *** "Thru" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:47:16 <lambdabot> Thru \Thru\, prep., adv. & a.
21:47:16 <lambdabot>   Through. [Ref. spelling.]
21:47:19 <int-e> ?web1913 nub
21:47:20 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:47:21 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
21:47:21 <lambdabot>   To push; to nudge; also, to beckon. [Prov. Eng.]
21:47:21 <lambdabot>  
21:47:21 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:47:23 <lambdabot> [3 @more lines]
21:47:32 <palomer> @more
21:47:32 <lambdabot> Nub \Nub\, n.
21:47:33 <lambdabot>   A jag, or snag; a knob; a protuberance; also, the point or
21:47:33 <lambdabot>   gist, as of a story. [Colloq.]
21:47:42 <palomer> hrmph
21:47:50 <Cale>     3. The heart of a matter; the crux or central point of a discussion, argument, etc.
21:47:51 <palomer> another case of haskell completely misusing a word
21:48:02 <dave_m> "gist" is pretty close
21:48:05 <Cale>     b. A stump, stub, or remnant; something cut off short or imperfectly grown.
21:48:12 <int-e> I still think 'nub' is the most obscure standard library function name.
21:48:23 <Cale>     1. The neck; (also) the nape of the neck.
21:48:27 <Cale>     2. The gallows. rare.
21:48:36 <Cale> (that's for nub as well :)
21:48:55 <Cale> there are two noun forms and 3 verb forms of nub in OED :)
21:49:03 <Cale>     trans. To nudge or strike; to joggle, shake.
21:49:03 <Bobstopper> Yeah, see all these language issues wouldn't be there if lojban was used for names instead of English :P
21:49:14 <Cale>  trans. To execute by hanging.
21:49:15 <lispy> dons: when you say 'custom search engine' what do you mean exactly/
21:49:17 <palomer> go lojban!
21:49:23 <Cale>     trans. To strike (a ball) weakly; to hit (the ball) awkwardly with the end of the bat.
21:49:25 <dave_m> I've only heard "nub" used in a Monty Python sketch, in the phrase "the very nub of my gist"
21:49:25 <lispy> dons: like you wrote some code to do the search based on tehir data or what?
21:49:36 <palomer> lojban is missing imperative constructs, unfortunetly
21:49:47 <Cale>   {dag}1. The innermost wrapping of the chrysalis in a silk cocoon. Cf. KNUB n. 3. Obs.
21:49:52 <Cale> 2. a. A small knob or lump; a nugget. Also: = KNOP n.1 1b.
21:49:56 <palomer> @spell unfortunetly
21:49:56 <lambdabot> unfortunately unfortunate unfortunates fortunately unfriendly
21:50:01 <palomer> I hate that word.
21:50:18 <lispy> int-e: yes, i think nub and that new one...Void? are bad choinces
21:50:20 <lispy> er choices
21:50:33 <x3m2> > 5^2
21:50:35 <lambdabot>  25
21:50:39 <dave_m> What's wrong with Void?
21:50:52 <int-e> it should be called Nub ;)
21:50:53 <Bobstopper> palomer: how do you mean it's missing them? You mean something other than "ko"?
21:51:19 <int-e> it extracts the essence of all data types ... *ducks*
21:51:20 <lispy> there is a theory that when you name things that if two things are similar you should name them in a way that brings out their difference.  For example, if you name commands to control a robot you dont' call it Turn and Left, you call it Right and Left (the commands to make it turn)
21:51:31 <Cale> {dag}un'merciless, a.
21:51:34 <Cale>  Unmerciful.
21:51:37 <lispy> dave_m: nothing, but i thinkit should have been Intercalate, to help make it clear
21:52:14 <dons> lispy: its a search engine restricted to a sub domain, determined by a set of users
21:52:20 <int-e> lispy: anyway, I've never missed nub.  map head . group . sort  is what I usually want.
21:52:26 <dons> in this case, the only user so far was me, and i restricted it to haskell sites and search terms
21:52:27 <lispy> so having split/join isn't very good, but split/unsplit would be good
21:52:39 <dave_m> You're contrasting Void and ()?
21:52:46 <int-e> heh. explode and implode.
21:52:48 <Cale> int-e: there should be a name for  map head . group . sort  perhaps
21:52:51 <Bobstopper> personally I think all the suggestions on that program's name are suitable. I preferred intercalate but really, who cares? It's a micro utility, the name's not that important and even if people are initially confused about what it means the type signature should help clear it up...
21:52:59 <lispy> dons: yes, but you left out the haddock docs! ;)
21:53:04 <Cale> what name won?
21:53:14 <dons> lispy: it should find them if they're on haskell.org ...
21:53:23 <int-e> Cale: I'd call  map head. group  'uniq' after the unix command./
21:53:24 <lispy> dons: search for openFile
21:53:28 <dons> but with 'refinements' i think we can lift the results of docs higher
21:53:33 <lispy> dons: it finds the mail list first :(
21:53:39 <dons> i've yet to work out how to use refinements though
21:53:48 <Cale> int-e: yeah
21:53:56 <lispy> dons: well, i sent in a request to volunteer
21:54:06 <dave_m> Bobstopper: Same here, although I have some sympathy for the "No names for small functions" viewpoint
21:54:20 <dons> lispy: ok. let me see if that does something
21:54:55 <dons> lispy: ok. accepted :)
21:55:03 <lispy> yay!
21:55:07 <lispy> i wonder what i do now...
21:55:08 <araujo> anybody knows a good paper for reading about changing global (variables) states?
21:55:11 <dons> (assuming 'name less user' wsa you...)
21:55:20 <dave_m> If deforestation were more common, I'd prefer "concat . map" to "concatMap"
21:55:23 <lispy> dons: no, it should have known me
21:55:28 <Bobstopper> I don't mind the names for small functions. I find both arguments reasonable, but if you don't want to use it you don't have to. It seems the "no names for small functions" argument has the advantage of teaching each part of the function... in which case, just teach each part of the function - only people who know where to look will probably find the fn anyway.
21:55:31 <lispy> dons: i was logged in as dagitj on my gmail
21:55:38 * Bobstopper types too long paragraphs
21:55:44 <dons> lispy: so i'm looking at the refinements stuff now
21:56:40 <dons> lispy: see if you can add a 'refinement' for the docs page?
21:56:52 <dons> my firefox seems to play tricks -- javascript I presume
21:57:15 <lispy> dons: nada
21:57:19 <dons> hmm?
21:57:19 <lispy> dons: where is the docs page?
21:57:28 <Bobstopper> I'm surprised other small functions aren't included in the standard haskell libraries actually. subList is a small function but doesn't seem necessary to have everyone implementing their own.
21:57:30 <dons> ?docs Data.List
21:57:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:57:33 <lispy> dons: er sorry, where is the refinments link
21:57:41 <dons> link is sub dir of http://haskell.org/ghc/docs/latest/html/libraries/base
21:57:44 <lambdabot> Title: Index of /ghc/docs/latest/html/libraries/base, http://tinyurl.com/yxpukk
21:57:49 <dons> oh, do you have a 'Edit this search engine' link now?
21:57:54 <lispy> nope
21:57:56 <dons> if you view the search page?
21:57:58 <dons> reload?
21:58:04 <lispy> :(
21:58:06 <dons> let me try again...
21:58:23 <dave_m> Bobstopper: Like I said, I have some sympathy for the view, but I'm not 100% on board
21:58:54 <lispy> dave_m: i'm just glad haskell makes it trivial to create wrapper functions
21:59:12 <lispy> dave_m: so ifi want i can say, mystupidjoiner = intercalate and be done with it :)
21:59:39 <dave_m> that is nice. I've done that for types, too
22:00:07 <satan> is there an all-round good strategy for category theory proofs?
22:00:26 <lispy> satan: assuming category theory is like all other parts of math, not really
22:00:36 <lispy> satan: takes more like a bag of tricks, intuition and practice
22:00:39 <satan> like, if one has to show something is isomorphic, one would try to prove those 2 axioms and so on
22:00:45 <satan> right
22:01:12 <dave_m> Isn't general theorem solving NP-complete?
22:01:51 <lispy> dave_m: i think the computability is determined by how general your logic is
22:01:57 <int-e> only for problems with a test in P. Pretty much by defintinion.
22:02:08 <int-e> hmm.
22:02:21 <int-e> *thinks*
22:02:39 <sjanssen> is it really NP-complete?
22:02:50 <sjanssen> NP, sure
22:03:15 <int-e> I want a definition of 'theorem solving', please. :)
22:03:54 <dave_m> I meant theorem proving, but I retract the question b/c it's too vague
22:03:57 <lispy> int-e: yeah, that's why i made my claim :)
22:04:18 <int-e> I'm not sure it's NP, it's certainly NP-hard, because whatever that is, it should allow embedding SAT.
22:04:44 <int-e> But to be NP, you'd need an upper bound on lengths of proofs, as I'd interpret it.
22:04:54 <int-e> a polynomial upper bound.
22:05:12 <lispy> dons: i found it
22:05:22 <lispy> dons: i went to my account and then went to my search engines
22:05:33 <lispy> dons: from there i see the haskell control panel
22:06:27 * basti_ isn't at all sure how difficult theorem proving is, algorithmically speaking
22:06:44 <basti_> isn't the point that exhaustion is the wrong method?
22:07:39 <int-e> FOL theorem proving is undecidable so not NP.
22:08:14 <basti_> assuming we'd want to exhaust some search space might mean we started out wrong
22:08:31 <basti_> maybe all proofs are easy, given the right theory
22:08:37 <int-e> I should read a book on computability and complexity theory some day. This should've been obvious.
22:09:13 <basti_> uhm, actually it is semi-decideable
22:09:24 * dave_m slaps his forehead.
22:09:25 <int-e> basti_: you can't escape undecidability unless you find something computationally more powerful than turing machines.
22:09:41 <basti_> i know what you're talking about, but: do you need turing completeness?
22:09:57 <basti_> after all there's strongly normalizing systems, for example
22:09:58 <dave_m> I can't believe I confused undecidability with NP-completeness.
22:10:16 <dons> lispy: ok. good. see if you can add the libraries doc path i linked above as a refinement then
22:10:26 <int-e> basti_: if your logic is too weak it can be decidable, sure.
22:10:30 <basti_> there mightbe a thing that is "powerful enough" but not "turing complete"
22:10:45 <int-e> (which still doesn't mean that it's in NP)
22:10:48 <basti_> yea.
22:10:49 <basti_> ^^
22:11:18 <basti_> actually this is "here be dragons" realm isnt it? ^^
22:11:43 <dave_m> I'm pretty sure that proving arbitrary Category Theory theorems is undecidable.
22:11:52 <basti_> I'm too.
22:13:29 <lispy> dons: i don't get it
22:14:56 <JKnecht> yeah but there oughta be (maybe a shitload) pragmatic constrainst that could make a workable and useful tool possible
22:15:01 <lispy> dons: what i'm seeing in the documentation doesn't match what i'm seeing in the UI
22:15:13 <Bobstopper> Nothing lasts forever, therefore halt _ -> True. Now you can solve all kinds of wacky problems.
22:16:23 <lispy> > let { halt :: a -> Bool; halt _ = True } in halt 1
22:16:25 <lambdabot>  True
22:16:55 <lispy> ?let halt = const True
22:16:56 <lambdabot> Defined.
22:17:03 <lispy> > fix L.halt
22:17:04 <lambdabot>  True
22:17:15 <dave_m> So... we've just proved that the set of integers is finite?
22:17:35 <dave_m> > halt (last [1..])
22:17:36 <lambdabot>  Not in scope: `halt'
22:17:39 <Bobstopper> Of course it is. The set of Integers is only as big as you can be bothered counting until.
22:17:47 <lispy> > L.halt (last [1..])
22:17:48 <lambdabot>  True
22:18:21 <dave_m> I guess last [1..] does halt... when you kill the process
22:18:22 <lispy> dave_m: so in Bobstopper's world things can be arbitrarily large, just not infinite
22:18:38 <lispy> dave_m: i dare you to define the difference
22:19:04 <lispy> Bobstopper: so, do the real numbers exist in your world?
22:19:09 <Bobstopper> dave_m: exactly. That was going to be my example if anyone asked actually ;)
22:19:38 <dave_m> one difference is that last [1..n] will eventually return a number, but last [1..] won't
22:20:11 <lispy> dave_m: but i can just keep choosing larger ns
22:20:20 <int-e> > [False..]
22:20:21 <lambdabot>  Parse error
22:20:46 <Bobstopper> Yeah, but it halts. You could always have it printing the number out and put a error catcher so it prints the final ] before shutting down ;)
22:20:59 <dave_m> true, but you'll always get an answer (unless you're using Int)
22:21:03 <int-e> > [False ..]
22:21:05 <lambdabot>  [False,True]
22:21:27 <dave_m> out of curiosity, what happens if we feed lambdabot a non-terminating expression?
22:21:36 <Bobstopper> it gives up
22:21:43 <Bobstopper> s/it/she/
22:21:45 <lispy> i think the difference between an arbitrarily large set (in the way we mean it) and and infinity is that infinity might not be countable
22:21:45 <int-e> > last [0..] :: Word8
22:21:47 <lambdabot>  255
22:22:17 <lispy> in Bobstopper's world, we can't have uncountable sets
22:22:30 <lispy> or if we can, we can't observe them
22:22:30 <dave_m> There are countable infinite sets
22:22:35 <int-e> great
22:22:39 <lispy> dave_m: right
22:23:16 <Bobstopper> Assuming the universe will eventually die of heat death, counting will cease when that happens. So if you start counting now, you'll probably find the largest number (so long as nobody else has found a larger one yet)
22:23:42 <dave_m> Yeah, but no matter what number you reach, I can generate a larger one by adding 1
22:23:46 <basti_> o.o
22:23:50 <Cale> what about faster ways to produce larger numbers?
22:23:54 <Bobstopper> not after the heat death you can't :P
22:24:21 <dave_m> don't you tell me what I can't do after the heat death of the universe
22:24:24 <basti_> i opt for observability. and you can't observe an end in numbers.
22:24:27 <dons> > last [1..] -- don't you terminate on me!
22:24:28 <Bobstopper> it doesn't matter. The largest possible number is whatever number has been imagined in the universe before the universe ceases to exist :)
22:24:31 <lambdabot> Terminated
22:24:33 <sieni> as for large numbers: http://en.wikipedia.org/wiki/Graham's_number
22:24:36 <dons> ah well. and i was hoping for heat death
22:24:48 <lispy> right, well what's the difference between the largest number that we can have in the universe and infinity?
22:24:48 <Cale> Graham's number is most likely the largest number ever put to use, and it's mindbogglingly large. Comparing it to the number of particles in the universe would be an insult :)
22:25:05 <dons> Dons number is bigger though
22:25:21 <basti_> actually i remember reading, the number that graham's number was an upper bound for might actually be 4
22:25:35 <basti_> which would make graham's number the worst overestimation in history by far
22:25:44 <Cale> Well, they thought it might be 6, but recently progress has been made
22:25:46 <sieni> Bobstopper: Now I'm thinking of the largest number that will be imagined in the univrse befor the universe ceases to exist... PLUS ONE
22:25:53 <Cale> It's at least 11, and might even be larger
22:25:57 <basti_> LOL
22:26:09 <lispy> have you heard of busy beaver?
22:26:09 <Cale> but the best upper bound is Graham's number
22:26:21 <dave_m> The ordinal numbers define Ï as the smallest number larger than any finite number
22:26:30 <lispy> iirc there was a challenge to come up with a way of computing larger largre numbers that grew so fast it wasn't computable
22:26:31 <Bobstopper> sieni: then you've just contradicted yourself
22:26:39 <dons> ooh, what's this up arrow notation?
22:26:45 * sieni vanishes in a puff of logic
22:26:47 <dons> and do we have a Haskell function in unicode to do the same thing?
22:27:19 <Cale> a ^^^...^^^ b with n arrows is a ^^...^^^ a ^^...^^^ ... ^^...^^^ a with n-1 arrows in each
22:27:25 <Cale> and a^b is exponentiation
22:27:31 <dons> someone going to write a library for this big big big big number notation in haskell?
22:27:37 <dons> i see a niche :)
22:27:45 <Cale> (and b copies of a, I should have said)
22:27:50 <dons> mmm
22:28:03 <lispy> i bet you could write it in the Reader monad easiest
22:28:26 <Cale> and so you define g_1 as 3 ^^^^ 3, and g_n as 3 ^(g_n-1) 3
22:28:35 <Cale> and Graham's number is g_64 :)
22:28:49 <lispy> what is the value of g_1?
22:29:14 <lispy> 3 ^^^^ 3 = 3 ^ 3 ^ 3?
22:29:19 * lispy got lost in notation
22:29:20 <dave_m> Maybe calculating g_n would be a good benchmark for the shootout
22:29:29 <basti_> actually ^ is a bit like the ackermann function isnt it?
22:29:34 <basti_> it's second parameter that is
22:29:48 <sieni> lispy: http://en.wikipedia.org/wiki/Knuth%27s_up-arrow_notation
22:29:49 <basti_> *its
22:29:51 <lambdabot> http://tinyurl.com/y2e276
22:29:56 <Cale> lispy: no
22:30:03 <Cale> 3 ^^^^ 3 = 3 ^^^ 3 ^^^ 3
22:30:10 <dons> dave_m: hmm. interesting idea
22:30:32 <Cale> note that it associates to the right
22:30:37 <kfish> dons: put it in Prelude, then we can eval . intercalate ^^^^ [1..]
22:30:56 <Cale> and 3 ^^^ 3 = 3 ^^ 3 ^^ 3
22:31:03 <Cale> and 3 ^^ 3 = 3 ^ 3 ^ 3
22:31:13 <basti_> i tried to write the hawiki, it crashed
22:31:24 <Cale> > 3^3^3
22:31:26 <lambdabot>  7625597484987
22:31:45 <Cale> needless to say, 3 ^^^^ 3 is mindbogglingly large already
22:31:46 <lispy> > let { x ^^^^ 3 = x ^^^ x ^^^ x; x ^^^ 3 = x ^^ x ^^ x; x ^^ 3 = 3 ^ 3 ^ 3 } in 3 ^^^^ 3
22:31:47 <lambdabot>  Non-exhaustive patterns in function ^^
22:31:55 <Pseudonym> Oooh, Graham's number?
22:31:59 <Cale> yeah
22:32:02 <Pseudonym> Woo.
22:32:06 * Pseudonym gets popcorn
22:32:15 <dave_m> Naturally, you could define some new operator such that a & b = a ^(b) a
22:32:33 <dave_m> So 3 & 4 = 3 ^^^^ 3
22:33:10 <dons> basti_: i think it just emits an error on saving, but does actually work
22:33:20 <dons> its since we locked down new page creation, iirc
22:33:20 <basti_> yes it works, but there is an ugly error
22:33:24 <basti_> ah i see
22:33:26 <dons> yep. ignore it :)
22:33:30 * basti_ does
22:33:33 <dons> and ensure new stuff goes on the new wiki
22:33:39 <basti_> ignore this message.
22:33:41 <Cale> http://www.wschnei.de/number-theory/large-numbers.html
22:33:42 <basti_> new message?
22:33:44 <lambdabot> Title: MATHEWS: All Numbers Large and Beautifull, http://tinyurl.com/y8dxll
22:33:54 <Cale> rank(x) = log10(x) for 1 â¤ x < 10,
22:33:54 <Cale> rank(x) = 1 + rank(log10(x)) for x â¥ 10.
22:34:12 <Cale> note that the rank of 3^^^3 is 7,625,597,484,986
22:35:00 <lispy> > let { knuth a 1 b = = a^b; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 2 2
22:35:01 <lambdabot>  Parse error
22:35:07 <Cale> that is, that's roughly the number of times you have to take log_10 of it before you end up with a number less than 1
22:35:23 <lispy> > let { knuth a 1 b = a^b; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 2 2
22:35:25 <lambdabot>  Exception: stack overflow
22:35:28 <lispy> hmm...
22:35:30 <Pseudonym> > L.ackermann 4 2
22:35:31 <lambdabot>  Not in scope: `L.ackermann'
22:35:32 <lispy> should have been 27
22:35:32 <Cale> and that's not even 3 ^^^^ 3
22:35:44 <Pseudonym> @let ackermann 0 n = n + 1
22:35:45 <lambdabot> Defined.
22:35:46 <Cale> which is just the first number in the sequence to constructing G :)
22:35:52 <Pseudonym> @let ackermann m 0 = ackermann (m-1) 1
22:35:53 <lambdabot> Defined.
22:36:02 <Pseudonym> @let ackermann m n = ackermann (m-1) (ackermann m (n-1))
22:36:03 <lambdabot> Defined.
22:36:13 <Pseudonym> > L.ackermann 4 1
22:36:17 <lambdabot> Terminated
22:36:38 <Cale> Consider an n-dimensional hypercube, and connect each pair of vertices to obtain a complete graph on 2^n vertices. Then colour each of the edges of this graph using only the colours red and black. What is the smallest value of n for which every possible such colouring must necessarily contain a single-coloured complete sub-graph with 4 vertices that lies in a plane?
22:36:47 <dave_m> I don't think it's connecting the cases in multi-line functions. Try using case, instead
22:37:03 <Cale> that's the problem for which G is an upper bound
22:37:14 <Cale> (and which the best known upper bound is 11)
22:37:18 <Cale> er, lower
22:38:10 <dave_m> Cale: That problem's much easier in the "1, 2, many" counting system
22:38:19 <Cale> heh
22:39:06 <lispy> > let { knuth a 1 b = a^b; knuth a n 0 = 1; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 2 2
22:39:08 <lambdabot>  27
22:39:23 * Bobstopper wonders if haskell's modules might work better if they fit a relational model rather than a hierarchical one
22:39:26 <lispy> > let { knuth a 1 b = a^b; knuth a n 0 = 1; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 2 3
22:39:28 <lambdabot>  7625597484987
22:40:19 <lispy> > let { knuth a 1 b = a^b; knuth a n 0 = 1; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 2 4
22:40:23 <lambdabot> Terminated
22:40:50 <Bobstopper> see? lambdabot is a solution to the halting problem in action
22:42:03 <dave_m> lambdabot is just taking laziness to a new level
22:42:58 <Bobstopper> and wouldn't all problems be easier if everyone was too lazy to bother finding solutions for them? :)
22:43:14 <Cale> Wouldn't it be nice if it could print the initial some-odd number of digits?
22:43:28 <araujo> We could say that an IORef is sort of a STRef inside th IO monad?
22:43:38 <Cale> > 9^9^9
22:43:42 <lambdabot> Terminated
22:44:00 <basti_> hard to code though
22:44:01 <Cale> the last 2000 and first 1200 digits of that number have been computed
22:44:20 <dons> > 666^666
22:44:21 <lambdabot>  2715417592887128558260874551700217860278385210650169871782230046965783675347...
22:44:30 <basti_> somebody suggested a lazy numeric lib which might actually be easier ^^
22:45:22 <sieni> basti_: yeah. "computer, please simulate navier-stokes flow at reynolds number 10^6" -> "Terminated"
22:45:45 <Cale> One thing to keep in mind though is that there are more natural numbers larger than G than smaller :)
22:46:25 <dave_m> I think some variant of "If a program stops without returning an answer, has it halted?" may be our version of a tree falling in the woods.
22:46:46 <Cale> The answer is no
22:46:52 <Bobstopper> so if G's the largest practically used number, what's the smallest?
22:47:14 <lispy> Bobstopper: -G ;)
22:47:20 <Cale> 1/G
22:47:22 <dave_m> 0, unless you accept non-natural numbers
22:47:22 <Cale> hehe
22:47:24 <Bobstopper> that's the largest negative number, not smallest :P
22:47:43 <Bobstopper> heheh I don't think 1/G has been used for anything though, has it?
22:47:44 <Cale> If you delete 0, it's a more interesting question
22:47:44 <lispy> but -G < 1/G
22:47:52 <Cale> 1/G probably hasn't been used
22:48:02 <lispy> what was G used for?
22:48:02 <Cale> lispy: less than is not smaller than
22:48:18 <Cale> an upper bound on a Ramsey-theoretic problem
22:48:38 <lispy> ain't nutin but a G thang
22:48:46 <dave_m> :)
22:48:53 <dave_m> What up, G?
22:49:08 <sieni> lispy: one of these "smallest n such that for every ... there is ... such that for every ... there is ... such that for every ... there is ..."
22:49:57 <lispy> > let { knuth a 1 b = a^b; knuth a n 0 = 1; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 4 3
22:50:00 <lambdabot>  Exception: stack overflow
22:50:12 <Bobstopper> lispy: G was used in some mathematic proof, according to wikipedia
22:50:18 <dave_m> From what I can tell, G is primarily used to one-up the googolplex
22:50:38 <Cale> heh, 1000! one-up's the googolplex
22:50:54 <Cale> G at *least* googolplexes up the googolplex
22:51:15 <Cale> er, actually it doesn't sorry
22:51:23 <Cale> (1000!)! then
22:51:24 <Cale> :)
22:51:40 <Cale> 9^(9
22:51:42 <dave_m> Oh, sure, anything's bigger if you put a ! after it.
22:51:46 <Cale> 9^(9^9) is fairly large
22:52:03 <dave_m> I see your (1000!)! and raise you (10^(10^100))!
22:52:39 <Cale> 9^(9^9) < 10^(10^100) of course :)
22:52:48 <dave_m> Wow, G is so big it doesn't even have a rank
22:52:49 <Cale> but 9^9^9^9 is larger
22:53:00 <Cale> right, and look at the rank of 3 ^^^ 3
22:53:09 <Cale> g_1 is 3^^^^3
22:53:10 <lispy> oh i see, i can't even compute g_1 and i ned to be computing g_6
22:53:14 <lispy> er g_64
22:53:20 <Cale> which has approximately 3^^^3 as its rank
22:53:48 <dave_m> Would g_1 even fit in computer memory?
22:53:56 <Cale> hahaha, no
22:54:09 <Cale> 3 ^^^ 3 wouldn't
22:54:20 <lispy> > let { knuth a 1 b = a^b; knuth a n 0 = 1; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 3 3
22:54:23 <lambdabot>  Exception: stack overflow
22:54:25 <dave_m> Maybe in 100 years
22:54:27 <lispy> > let { knuth a 1 b = a^b; knuth a n 0 = 1; knuth a n b = knuth a (n-1) (knuth a n (b-1)) } in knuth 3 2 3
22:54:28 <lambdabot>  7625597484987
22:54:39 <Cale> You have to take log_10 of it about 7,625,597,484,986 times before you reach a number under 10
22:55:00 * Bobstopper forceably kills GHCi. That'll learn me for not taking Cale's claim that "9^(9^9) is fairly large" seriously enough
22:55:13 <dons> > 9^(9^9)
22:55:16 <dons> ah well
22:55:17 <lambdabot> Terminated
22:55:29 <Cale> that is, you have to count the digits of the digits of ... the digits of it to get a number under 10, where there are 7,625,597,484,986 "the digits of"
22:55:34 <lispy> ?let knuth a n b = if n == 1 then a^b else if b == 0 then 1 else knuth a n b = knuth a (n-1) (knuth a n (b-1))
22:55:34 <lambdabot>  Parse error
22:55:47 <Cale> and that's just 3^^^3
22:55:47 <sjanssen> > 9^(9^9) :: Double
22:55:49 <lambdabot>  Infinity
22:56:00 <sjanssen> yeah, I'd say Infinity is pretty big
22:56:00 <Cale> and g_1 has about that number as its *rank*
22:56:12 <dave_m> In that case, calculating g_n would be a good benchmark for the shootout on April 1
22:56:14 <lispy> ?let knuth a n b = if {n == 1} then {a^b} else {if {b == 0} then {1} else {knuth a (n-1) (knuth a n (b-1))}}
22:56:15 <lambdabot>  Parse error
22:56:25 <Bobstopper> infinity's a concept not a number :P
22:56:59 <Cale> well, you can make it a number. It's not a natural number, or even a real or complex number
22:57:04 <int-e> I think double's Infinity roughly translates to "mindboggingly large".
22:57:12 <Cale> There are ordered fields with infinities in them
22:57:19 <sjanssen> > maxBound :: Double
22:57:20 <lambdabot>  add an instance declaration for (Bounded Double)
22:57:20 <lambdabot>   In the expression: max...
22:57:23 <sjanssen> wha?
22:57:31 <dave_m> There's always the surreal numbers
22:57:46 <sjanssen> it's around 1e250, yeah?
22:57:46 <dave_m> I dare anyone to implement those in Haskell
22:57:50 <Cale> The surreals go far beyond adding simple infinities :)
22:58:26 <Cale> The hyperreals are perhaps easier to deal with. They have the same cardinality as R, but there are infinities and infinitesimals.
22:58:28 <int-e> ââ ...
22:59:49 <Cale> hehe, n$ = n! ^^ n!
22:59:53 <dave_m> In Haskell, Integer is arbitrarily large, but T = Finite Integer | Infinite is arbitrarily large *and* has a max bound
22:59:55 <lispy> > L.knuth 3 2 3
22:59:56 <lambdabot>  7625597484987
22:59:58 <Cale> 3$ is already pretty large
23:00:22 <Cale> dave_m: but it's no longer a ring
23:01:07 <lispy> ?let dollar n = let fact = product [1..n] in knuth fact 2 fact
23:01:08 <lambdabot> Defined.
23:01:14 <lispy> > L.dollar 3
23:01:19 <lambdabot> Terminated
23:01:22 <lispy> heh
23:01:25 <lispy> > L.dollar 2
23:01:26 <lambdabot>  4
23:01:27 <skew> Does anyone know of persistant data structures that mention how much additional storage a version takes?
23:01:27 <dave_m> Yeah, I wouldn't expect it to be. But it's still ordered. Nice for finding the largest element of a possibly empty collection
23:02:36 <sieni> dave_m: like what
23:02:37 <sieni> ?
23:02:47 <sieni> dave_m: like the largest element of integers? ;-)
23:03:16 <dave_m> like the largest of a list of integers
23:03:35 <skew> I'm thinking a finger tree might let you keep a sequence with a cursor, and support operations around the cursor with constant space
23:03:39 <dave_m> Or, rather, the smallest of a list of integers
23:03:43 <dave_m> duh
23:03:44 <lispy> are haskell lists multisets?
23:03:53 <Cale> lispy: ordered multisets
23:04:03 <skew> with nasty partial values mixed in
23:04:06 <lispy> Cale: ah right
23:04:23 <Lor> Free monoids.
23:04:39 <skew> approximately, countable ordered multisets
23:05:58 <Lor> (And finite sets are free bounded join-semilattices, i.e. free idempotent commutative monoids. For some reason this fact isn't advertised very much, though I think it's pretty fundamental.)
23:06:23 <sieni> hmph, gotta start moving my sitting muscles towards municipal transport vehicle
23:06:56 <lispy> sieni: time to intercalate your presence with the public?
23:07:07 <skew> sieni: usable public transportation? How nice.
23:07:24 <Lor> Aye, it is.
23:07:37 <lispy> sieni: don't forget to ask people about their bike sheds
23:08:18 <sieni> skew: of course there is
23:08:26 <sieni> this isn't orange county, california
23:08:27 <kfish> at the place i am staying, there is a multi-coloured bike shed, and it is so full of old bikes that there is no room to put mine
23:08:30 <sjanssen> @intercalate
23:08:31 <lambdabot> Unknown command, try @list
23:08:34 <sjanssen> maybe someday
23:09:04 <lispy> ?. intercalate quote
23:09:04 <lambdabot> compose module failed: IRCRaised Parse error: "intercalate"
23:09:12 <lispy> ?quote
23:09:12 <lambdabot> emu says:  people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
23:09:21 <dons> kfish: please, can you take a photo of this bikeshed?
23:09:41 <kfish> dons: heh
23:09:49 <dons> so we can talk about it
23:09:56 <sjanssen> perhaps you could also spray paint the word "intercalate" on it
23:09:59 <dons> heh
23:10:01 <kfish> in case Prelude ever turns out like that?
23:10:03 <lispy> heh
23:10:08 <lispy> ooooo
23:10:12 <lispy> we should rename the Prelude
23:10:16 <lispy> to Intercalate!
23:10:30 <dons> the intercalated underground hackers
23:10:39 * lispy thinks Perlude is in the same category as nub and intercalate
23:10:45 <lispy> iuh
23:10:53 <dons> I think Perlude is a perl6 thing though
23:11:03 <sjanssen> at least prelude is a well known word
23:11:12 <lispy> sjanssen: true
23:12:27 <kfish> so ... let's say i was looking for a virtual machine that i could develop for using haskell ...
23:12:31 <emu> can someone build a bikeshed here
23:12:40 <kfish> would parrot/perl6 be a good way to go?
23:12:57 <int-e> emu: I hope it'll be blue.
23:12:59 <dons> what do you want to do? work on a vm, in haskell?
23:13:28 <kfish> write a distributed application, ie. each client runs a vm and shares code between them
23:14:07 <dave_m> kfish: there
23:14:09 <dons> why not use the ghc vm?
23:14:14 <dave_m> 's llvm and neko
23:14:17 <dons> like nepal
23:14:20 <dons> or llvm, yeah.
23:14:37 <skew> ah, you mean targeting a vm. I thought you meant implementing a VM in Haskell. UM is fun for that.
23:14:49 <kfish> skew, yeah, targetting a vm
23:14:59 <kfish> preferably something that can be targetted from multiple languages
23:15:17 <skew> so you want to support mobile code?
23:15:20 <emu> isnt there a distributed computation library/impl for ghc
23:15:22 <kfish> ie. the core app might be developed in haskell, but user-created modules might be in a simpler language
23:15:30 <dons> emu: yep. nepal. as well as gph and so on
23:15:38 <emu> yea gph i read about today
23:15:45 <dons> ?google mobile haskell
23:27:54 <lambdabot> http://www.macs.hw.ac.uk/~dubois/mhaskell/
23:27:54 <lambdabot> Title: mHaskell
23:27:54 <sjanssen> intercalate " sleep " ["today", "tomorrow"]
23:27:54 <dave_m> Doesn't Erlang have a VM?
23:27:54 <dons> :)
23:27:54 <emu> everything has a vm
23:27:54 <skew> Erlang doesn't actuall do mobile code that much, from what I've seen
23:27:54 <dave_m> No? I thought it did. Never mind, then
23:27:54 <skew> on the other hand, if you really need it hs-plugins should give you mobile Haskell without using a VM
23:27:54 <dave_m> That would involve, what, sending Haskell source code across the network?
23:27:54 <skew> dave_m: They've got eval and hot-swapping, and I think they've got enough reflection lying around to build up your own mobile code thing
23:27:54 <dons> i agree. it could be done
23:27:54 <dons> or you could send ghci bytecode files
23:27:54 <dons> or yhc bytecode
23:27:54 <kfish> ok, so [llvm, nepal, neko, mHaskell, gph]
23:27:54 <dons> kfish: there's probably lots more. check the research on distributed haskell for a start
23:27:54 <dons> (on the research papers page of haskell.org)
23:27:54 <kfish> ok
23:27:54 <Cale> I wish there was a dictionary for Firefox which had words like iff and clopen :)
23:27:54 <skew> yhc always uses bytecode, so if you think it would be fun to build a mobile code system that can send closures and thunks that's probably the way to go
23:27:54 <Bobstopper> Cale: lojban has lots of mathematic/logic words like that ;)
23:27:54 <dons> yeah, i'd start with yhc too
23:27:54 <kfish> cool
23:27:54 <Bobstopper> kfish: you're in Japan right? Mind if I ask out of curiousity why you're in Japan?
23:27:54 <skew> on the other hand, getting ghc to record source in the info tables might be an interested RTS project
23:27:54 <kfish> Bobstopper, just started a phd at kyoto university
23:27:54 <Bobstopper> oh cool. Is it a good university?
23:27:54 * Bobstopper often ponders whether to go postgrad
23:27:54 <kfish> yeah, very nice place, nice city
23:27:54 <dons> you guys should start #haskell.jp to bring in the locals
23:27:54 <dons> to go along side all the others
23:27:54 <dons> ?seen lambdabot
23:27:54 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-haskell, #haskell_ru, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
23:27:54 <dons> for example :)
23:27:54 <Cale> hmm, a set M is finite iff it can be doubly well-ordered, that is, there is a total order on M such that every subset has both a least and greatest element.
23:27:54 <dave_m> "clopen"?
23:27:54 * Bobstopper was lazy in university and did no assignments, only exams so he only had to work the final 2 weeks of each semester. Consequently his grades probably will never get him into postgrad :)
23:27:54 <kfish> everyone in japan says it's the 2nd best uni in japan, but they like to rank everything
23:27:54 <Cale> dave_m: both closed and open
23:27:54 <Cale> (it's a topology word)
23:27:54 <Lor> Lambdabot wants to rule the world?
23:27:54 <Bobstopper> heheh, yeah. Like kanazawa has the 3rd best garden in Japan
23:27:54 <dons> hey Lor
23:27:54 <Lor> Hi Don.
23:27:54 <dons> how's things? been a while since i've seen you here?
23:27:54 * Bobstopper starts #haskell.jp without really knowing what to do with it...
23:27:54 <dave_m> So in topology, "closed" doesn't mean "not open", huh?
23:27:54 <dons> Bobstopper: the idea would be to first invite some japanese speakers  from this channel
23:27:54 <dons> guys like shelarcy
23:27:54 <dons> there are others I suppose.
23:27:54 <dons> and then add a link on haskell.org/haskellwiki/IRC_channel
23:27:54 <dons> and have lambdabot join :)
23:27:54 <dons> ?join #haskell.jp
23:27:54 <Lor> I've been off from work for a while. Where else would I irc? :)
23:27:54 <Bobstopper> thanks
23:27:54 <dons> Lor: of course! :)
23:28:16 <dave_m> I guess that's no worse than intuitionistic logic, where "not not True" can't be proven true
23:29:01 <Lor> What intuitively feels like "closed" is called "compact" in topology.
23:29:57 <ThreeQ> does perl support continuations?
23:30:06 <Cale> dave_m: closed means that the complement is open
23:30:09 <dons> ThreeQ: apparently
23:30:09 <skew> ThreeQ: what doesn't perl support?
23:30:14 <dons> ThreeQ: perl6 would
23:30:41 <ThreeQ> I'm wondering because apparently somebody made a perl continuation-based web framework
23:30:42 <skew> dave_m: ($ True) is the proof of not not True in intuitionistic logic, in Haskell. Maybe something like forall x . x or not x?
23:31:51 <Lor> I think he meant !!P->P
23:32:16 <dave_m> Right. I'm being sloppy b/c I'm up too late
23:32:51 <Cale> dave_m: basically, the clopen sets in a topology are unions of connected components
23:32:55 <dave_m> for my next trick, I will show that Right is Wrong, because they're both "not Left"
23:33:06 <dave_m> see? gibberish
23:33:08 <skew> Hmm, I kind of like not being able to prove !!P -> P.
23:33:29 <dons> hmm. a bit worrying. the Sydney Morning Herald paper now includes 'digg this' links, and seems to report reddit.com stories.
23:33:40 <skew> It means if I ask you all how I can do something, you usually don't just say "It's not impossible"
23:33:47 <skew> dons: any of yours?
23:34:03 <dons> no :) those tshirts about 'Freedom from the Press' might be going full circle
23:34:07 <dave_m> dons: So does the Washington Post
23:34:28 <dons> lazy lazy journalists
23:34:58 <dons> so everyone wants intercalate. what a bunch of geeky linguist math guys haskellers are..
23:35:07 <dons> :D
23:35:26 <emu> ThreeQ: if you program in Continuation Passing Style the language doesn't need to support it
23:35:28 <dons> Haskell: Submit or be Intercalated!
23:35:33 <dave_m> did anyone suggest "intersperse"?
23:35:40 <dons> we have that already
23:35:42 <Cale> intersperse exists
23:35:42 <emu> ThreeQ: perl supports higher-order functiosn so all you need to do is CPS transform your code
23:35:50 <dons> this is concat. intersperse
23:35:54 <Cale> > intersperse 1 [1..10]
23:35:55 <ThreeQ> emu: ah, got it
23:35:56 <lambdabot>  [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10]
23:36:00 <ThreeQ> I guess that's how haskell does it, too
23:36:10 <Adamant> some people demand you reperate, Haskellers just want to intercalate
23:36:24 <dave_m> of course, where is my mind tonight
23:36:24 <emu> ThreeQ: for example in CL, there exists libraries of macros to CPS transform your code (used by, for example UCW framework)
23:36:54 <dons> I think maybe its time to start printing tshirts with a lambda on the back, and "intercalate" on the front.
23:37:23 <emu> any t-shirt with a lambda on it is going to be misinterpreted in amusing fashions
23:37:26 <Cale> Just remember, it's "less cake" and "fewer currants"
23:37:28 <dons> heh
23:37:35 <emu> amusing to me anyhow
23:38:28 <Cale> Isn't it interesting how English has separate words for a smaller amount when the objects are continuous and discrete, but this distinction doesn't exist for larger amounts?
23:39:33 <dave_m> "Two, four, six, eight! We will now intercalate!"
23:39:50 <skew> hmm, isn't Jifty what audery works on when not doing Pugs?
23:40:47 <dons> oh? that sounds interesting.
23:42:37 * araujo `offTo` bed :: IO ()
23:44:05 <lispy> hmm....bed :: IO ()
23:44:17 <lispy> so you never get out of bed?
23:44:29 * lispy expected bed :: IO a
23:44:57 <emu> i prefer IO ()
23:45:11 <skew> bed is only used for side effects, I suppose.
23:45:15 <dons> unsafeFallOutOfBed :: Bed a -> a
23:45:49 <emu> some operations in bed are unsafe
23:46:06 <dave_m> perhaps getOutOfBed :: IO a, goToBed :: a -> IO ()
23:47:26 <dons> emu, oh, yes, especiaily when, withBed :: Bed a -> (b -> Bed b) -> b -> Bed (a,b)
23:48:50 <emu> if your program type-checks, there are no bed bugs
23:48:52 <ulfdoz_> Don't you forget "Maybe Kids" somewhere?
23:49:20 <roconnor> Maybe [Kid]
23:49:23 <roconnor> er
23:49:25 <roconnor> [Kid]
23:49:38 <xerox> Children!
23:50:22 <emu> I took on the State monad today
23:50:37 <emu> tomorrow I will find out how badly I screwed up
23:51:18 <xerox> emu: university?
23:51:48 <emu> na, i need to finish writing the program and test cases
23:52:10 <skew> QuickCheck?
23:52:23 <ulfdoz_> roconnor: In some way one could think of children as the result of an IO operation.
23:52:23 * xerox chases the bus
23:52:53 <emu> one of the examples was: do n <- get; put (n+1); return n
23:53:00 <emu> how come that returns n+1 and not n?
23:53:11 <xerox> return =<< get
23:53:25 <xerox> n is bound to the state before the put.
23:53:57 <roconnor> > const 5 undefined
23:53:58 <lambdabot>  5
23:53:59 <emu> yes, that's why I'm confused. it ends up returning the new state.
23:54:06 <roconnor> hmmm
23:54:09 <xerox> emu: n is not the new state
23:54:12 <emu> i believe this is the example in the GHC documentation for Control.Monad.State
23:54:15 <skew> how are you running it?
23:54:16 <xerox> Oh-uhm.
23:54:18 <dave_m> are you using execState?
23:54:20 <emu> yes
23:54:22 <roconnor> > const 5 (undefined :: Void)
23:54:22 <lambdabot>  Not in scope: type constructor or class `Void'
23:54:28 <Bobstopper> wow... I didn't realise so many lewd jokes could be made using haskell notation. That was funny :)
23:54:31 <xerox> Ah-ha.
23:54:47 <xerox> Eeeek my bus!
23:55:33 <emu> > let f :: State Int Int; f = do {n<-get;put(n+1);return n} in execState f 1
23:55:34 <lambdabot>  2
23:55:55 <xerox> ?type execState
23:55:56 <lambdabot> forall s a. State s a -> s -> s
23:55:59 <xerox> ?type evalState
23:56:01 <lambdabot> forall a s. State s a -> s -> a
23:56:05 <xerox> ?type runState
23:56:06 <lambdabot> forall s a. State s a -> s -> (a, s)
23:56:10 <xerox> Ban me!
23:56:19 <emu> > let f :: State Int Int; f = do {n<-get;put(n+1);return n} in evalState f 1
23:56:21 <lambdabot>  1
23:56:28 <emu> ok clearly I don't understand this
23:56:30 <skew> let f :: State Int Bool; f = do {n<-get;put(n+1);return False} in execState f 1
23:56:35 <skew> > let f :: State Int Bool; f = do {n<-get;put(n+1);return False} in execState f 1
23:56:36 <lambdabot>  2
23:56:49 <skew> > let f :: State Int Bool; f = do {n<-get;put(n+1);return False} in evalState f 1
23:56:51 <lambdabot>  False
23:56:54 <emu> I see.  so one returns the final state, and one returns the return value?
23:56:54 <dave_m> execState returns the final state and ignores the return value
23:57:13 <emu> so State is State of (state type) (return type)
23:57:53 <dave_m> execState and evalState are just variants of runState that return less information
23:58:07 <dave_m> execState is good for computations of type State s ()
23:58:24 <emu> indeed, now I see that I probably wanted that
