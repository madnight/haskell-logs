00:00:05 <dolio> phr-newbie: Oh. It's not in the prelude. You might want to look in the List or Data.List module.
00:00:10 <dons> or a couple of papers at ICFP ... ;)
00:00:21 <phr-newbie> coq is an ML prog right?
00:00:27 <dolio> ?index foldl'
00:00:28 <lambdabot> Data.List
00:00:43 <dons> phr-newbie: hmm, maybe? Isabelle is, certainly
00:00:47 <skew> putting aside everything else, Coq is handy for juggling the live assumptions in a natural deduction proof. Way better than writing out trees on paper
00:00:53 <dons> the older theorem provers, written pre-1990 tend to be done in ML
00:00:56 <edwardk> dons: yes!
00:01:03 <skew> I think Coq may be written in OCaml.
00:01:11 <edwardk> dons: i've been hanging out on #coq lately trying to figure out haskell extraction
00:01:12 <phr-newbie> yeah i count ocaml as ML :)
00:01:13 <skew> at least, it prefers to extract programs as O'Caml
00:01:15 <edwardk> no one uses it
00:01:26 <int-e> PVS is lisp.
00:01:26 <dons> edwardk: no one uses coq?
00:01:32 <skew> Haskell extraction
00:01:39 <edwardk> skew: it is written in ocaml, no?
00:01:46 <phr-newbie> yes
00:01:51 <phr-newbie> http://en.wikipedia.org/wiki/Coq
00:01:52 <edwardk> skew: no one uses the haskell extraction mode of it anyways
00:02:02 <dons> there's haskell extraction in coq??
00:02:10 <edwardk> i thought so considering i had to install ocaml to build coq =)
00:02:16 <edwardk> dons: yeah =)
00:02:18 <dons> why didn't anyone tell me that?
00:02:24 <skew> edwardk: yeah, that's my reasoning too
00:02:26 <edwardk> dons: hard to use, barely documented, but its there =)
00:02:34 <dons> nice!
00:02:41 <phr-newbie> what's different between coq and other provers?
00:02:47 <edwardk> skew: that and i happen to know that a lot of adam chlipala's code mucks around in the ocaml internals ;)
00:03:01 <skew> oh yeah, that was mentioned too
00:03:17 <edwardk> phr: coq is built on the calculus of inductive constructions, an extension of the far corner of the lambda cube, others are usually built over higher order logic
00:03:42 <dons> phr-newbie: its based onthe calculus of constructions? french guys like it?
00:03:52 <skew> edwardk: nothing else uses dependent types and curry-howard?
00:03:56 <phr-newbie> calculus of constructions = constructive type theory?
00:04:12 <edwardk> the CoC formalism lets you define dependent types, etc and stays pretty true to the lambda calculus, the others stay true to higher order logic. in the end you can do just about everything either way
00:04:35 <skew> after looking at Coq a bit, I'm wondering what's special about Epigram
00:04:43 <edwardk> skew: well, not much does anyways
00:04:58 <dons> skew: its written in haskell? and its designed as a programming language firstly.
00:05:05 <skew> yeah, that's about what I came up with
00:05:17 <skew> and it's lacks some proof automation stuff
00:05:20 <dons> rather than a theorem prover. (like Isabelle or Coq are used as: theorem provers that happen to generate code)
00:05:33 <dons> rather than a programming language with a theorem proving type system.
00:05:40 <skew> perhaps the techincal details of the type system are different as well
00:05:57 <edwardk> yeah, you need another language the execute the code you get out of coq. Its 'Eval' rules are a joke that are just present to enable type checking in systems that require reduction
00:06:08 <skew> Adam Chlipala has been using Coq as a programming language recently - http://www.eecs.berkeley.edu/~adamc/papers/CertVerICFP06/
00:06:10 <lambdabot> Title: Modular Development of Certified Program Verifiers with a Proof Assistant, http://tinyurl.com/rk9gn
00:06:24 <edwardk> http://proofos.sourceforge.net/
00:06:25 <lambdabot> Title: ProofOS
00:06:28 <dons> yeah, people use Isabelle as a programming language too.
00:06:34 <skew> using it as a dependently typed language, and then erasing the dependency to get OCaml, then running that
00:06:37 <edwardk> is where his code for verifying verifiers is =)
00:06:44 <dons> taking the ML out the back and running that.
00:07:10 <edwardk> i started exploring coq recently trying to use it similarly to generate haskell
00:07:29 <edwardk> but its a long trek to figure it out and there is no documentation on the haskell extraction process
00:07:54 <edwardk> also it appears to not be able to use native tuple types properly (in haskell or ocaml for that matter)
00:08:00 <dons> there's also Agda, with built in support for proving over ghc Core.
00:08:07 <edwardk> plus you have to write emulation libraries for all of the native integer behaviors, etc.
00:08:21 <skew> I was saying the thing I posted will probably be incomprehensible - it's not that Coq is really that strange, but that the text is pretty much a list of the deduction rules used in the proof, and it's really handy to have the rules draw out a proof tree
00:08:33 <skew> have the program to draw it out more nicely, that is
00:10:05 <edwardk> i would really like to be able to generate correctness proofs as i pass my code down  through my various representations to the assembler, which is why i started investigating coq in the first place
00:10:26 <skew> that seems to match the proofos approach
00:10:42 <edwardk> though i accept that that is antithetical to my other goals of blazingly fast execution =)
00:11:10 <edwardk> skew: sort of, he spends most of his effort building back up the context to verify the proof not so much generating it
00:11:16 <skew> that's why you erase the proof-passing during compilation
00:11:21 <edwardk> sure
00:12:12 <edwardk> what i mean by being antithetical is proofing the correctness of a transformation is a harrowing experience and prone to leading you down into rigid code structure you are afraid to change even when its suboptimal
00:13:05 <skew> I suppose the only reason wokring on transformations without proofs is not harrowing is blissful ignorance?
00:13:18 <edwardk> my earlier queries about what focusing affine logic theorem provers there are out there was in part an effort to avoid having to use a lot of coq stuff at the leaf optimization level.
00:13:35 <edwardk> skew: well, the type system catches a lot of faults ;)
00:13:44 <skew> ah, then it sounds even more like you want to build this thing into Coq, so it believes the results
00:13:50 <edwardk> skew: but if you have worked in coq at all you know how painful even basic proofs can be
00:14:08 <skew> also, this gets to the proofos stuff about weaving the proofs in as dependent types - sounds reasonable
00:14:47 <skew> edwardk: I haven't gotten very far, but so far I think most of the trouble has been getting used to the system, rather than writing down the proof.
00:15:29 <skew> eventually I think I'll want to be putting together tactics or something so I can elide stupid stuff like applying symmetry to make stuff fit.
00:15:33 <edwardk> skew: nonetheless, as your examples get more complex the proofs become non-trivial.
00:16:09 <edwardk> especially since in my case the language i am using this for has a notion of dependent types, and there is a whole host of issues with emulating alpha-conversion in coq.
00:16:44 <skew> I haven't yet seen the proofs being non-trivially more complicated than the reasoning behind them
00:16:59 <edwardk> so as you start modelling a language in coq, coq code can become unwieldy, and it can have a spill effect because of its inability o use certain language constructs on the generated code.
00:17:20 <skew> ah, reflecting in an object language sounds tricky
00:17:33 <skew> did you look at the NuPRL stuff from ICFP
00:17:36 <edwardk> there are times when the proof in something like twelf is wayyy shorter, because it handles stuff like alpha-conversion for you.
00:17:40 <edwardk> yeah
00:18:02 <skew> I'm going to look into that, once I have a little more experience with these theorem prover things.
00:18:03 <edwardk> was there. sat through the metaprl guy's lecture and ensuing shouting match with bob harper ;)
00:18:08 <skew> yep.
00:18:45 <skew> sounds like a fundamental misunderstanding about what -> means in the two systems
00:19:28 <edwardk> well, harper didn't seem to see what was so special about the connection. i found it fairly enlightening.
00:19:38 <edwardk> but then i have a lot less experience than he does =)
00:19:51 <skew> it's way weak in Twelf, more like a depending product or something rather than anything vaguely computational, according to Jason and Ken Shan
00:20:12 <skew> Jason Hickey being the prof who taught the class for which I got TaPL
00:20:19 <edwardk> nods
00:20:27 <emu> harper seems like the sort to get into shout matches often
00:20:56 <skew> and Ken being Chung-chieh Shan who did the delimited control, and whose first name I don't quite remember how to spell
00:21:20 <skew> have you actually tried out their stuff?
00:21:20 <edwardk> my type system is kind of like what you would get if you mapped all dependent products onto dependent sums in a pure type system, so one would think that something like twelf would be good for it, but twelf doesn't seem to manage substructural stuff well, and couldn't be used for the proof of the rest of the transformation without pain.
00:21:46 <edwardk> I actually spent a good chunk of this year's ICFP talking to ken =)
00:22:10 <edwardk> mostly as we worked through parts of my semantics and my extensions to the common notion of substructural types.
00:22:31 <dibblego> dons, does lambdabot automatically respond to PING from an IRC server?
00:22:34 <edwardk> but I did read through his pile of delimited control papers
00:23:48 <AI_coder> What are some good graduate schools for ai?
00:25:44 <dmead> i saw temple has 5 semesters
00:25:58 <dmead> of just ai
00:27:30 <skew> edwardk: have you tried formalizing any of the approaches to naming
00:27:36 <edwardk> actually the ai curriculum here at eastern michigan didn't suck. we just didn't cover any programming language theory.
00:27:38 <skew> perhas the FM stuff would work out?
00:28:09 <edwardk> gah
00:28:20 <edwardk> actually was talking to a number of people at the icfp about that
00:28:23 <skew> backwards-kill-sexp get you?
00:28:33 <edwardk> and the various ways they had gone about it
00:28:36 <skew> nah, you would have been out longer.
00:28:43 <edwardk> worse, escape in windows on trillian ;)
00:29:14 <edwardk> kinda annoying that you can't unbind that key
00:30:42 <edwardk> adam chlipala has some system for maintaining contexts and bindings explicitly. there is a lot of work that was done over at cambridge on ways to model that sort of thing, etc.
00:30:45 <skew> I grabbed Xavier Leroy's thing using McBride and McKinna's approach
00:31:04 <edwardk> unfortunately i think i have to go with something like adam's approach because i need to be able to explicitly carve up my contexts, etc.
00:31:21 <edwardk> since my substructural typing rules affect how my contexts split, etc.
00:31:34 <skew> it seems like the mixed approach might work better if you built your inductive types from some sort of universe construction, so you generate the structural substitution
00:31:35 <edwardk> so if i want to model it in coq i have to model it by hand i think
00:32:13 <skew> I think I'm just talking about alpha-renaming, and that shouldn't affect the explicit context splitting
00:32:25 <edwardk> especially since my subtyping judgments are on pseudo-terms and my typing judgments are on terms.
00:32:26 <edwardk> yeah
00:32:35 <edwardk> the alpha-renaming shouldn't be much of a problem
00:32:38 <skew> except if you need to deeply open things, I suppose
00:33:05 <skew> where the mixed approach sort of falls down on picking those names
00:33:21 <edwardk> in any event right now i'm just going ahead with writing the code in haskell and figuring i'll continue to plod away on my understanding of the relevant issues in coq in the background
00:34:26 <edwardk> i have a lot of work to do in if-conversion and branch elimination so i can move more and more stuff over to the simd pipeline
00:34:31 <dons> dibblego: i think lambdabot handles pings, but i've not checked
00:34:40 <dons> it could actualy be the reason it doesn't connect to efnet (?)
00:34:50 <dibblego> I'm on dalnet
00:34:58 <phr-newbie> i gotta question, how do they decide that they've proved enough stuff to "certify" a real program?
00:34:58 <dibblego> it's pinging out for some reason
00:35:17 <edwardk> phr: convince a human basically
00:35:26 <phr-newbie> convince a human of what?
00:35:40 <edwardk> phr: you can always assume axioms that make your coq code do stuff that i entirely stupid
00:35:47 <skew> whatever you were trying to certify
00:36:05 <edwardk> so you need to basically ensure that the axioms are consistent, and then you need to prove to someone that everything that matters has been proven.
00:36:16 <dons> dibblego: well, you can hack the ping stuff so it works, or i can look at it eventually
00:36:17 <edwardk> but thats a human thing not a formal proof thing
00:36:28 <dibblego> dons, i'll try some things
00:36:31 <dons> there's already ping code, but maybe it broke somewhere along the line.
00:36:37 <phr-newbie> yes, but what's the decision procedure for "something matters"?  if there's not one, how can we say we've proven everything that matters?
00:36:39 <dons> since freenode doesn't seem to care about pings
00:37:00 <edwardk> phr: you've just entered philosophy 101 territory =)
00:37:50 <edwardk> phr: what i mmean by that is, in the end you need to describe any formal system to someone in an informal meta-system, so the system itself can't contain all of the rules it needs to describe what should be proved.
00:37:51 <phr-newbie> edwardk :)   seriously, let's say i want to certify a scheme interpreter, fine, the r5rs has a formal semantics for scheme, so maybe a prover can take the interpreter code and verify that it implements the formal semantics
00:38:33 <phr-newbie> but that berkeley url said something about someone trying to make a certified c compiler
00:38:39 <phr-newbie> and there's no formal semantics for C
00:38:41 <edwardk> phr: even if you construct a meta-system formally, you explain it informally. or if you construct the meta-meta system formally you need to explain that informally, etc.
00:38:57 <edwardk> phr: sure but there are c-- and C minor dialects that have formal semantics
00:39:11 <phr-newbie> edwardk, hmm.
00:39:12 <skew> phr-newbie: and the x86 instruction set is documented
00:39:13 <edwardk> so adding onto those to get semantics for the rest of C is a reasonable proposition
00:39:16 <edwardk> yeah
00:39:27 <phr-newbie> yeah i guess it's sort of reasonable
00:39:51 <skew> actually, intel probably has proofs lying around that their hardware implemented the x86 instruction set spec, under some reasonable assumptions about semiconductor physics
00:40:08 <phr-newbie> i know that amd verified their floating point arithmetic with acl2
00:40:12 <edwardk> skew: in fact since the pentium fdiv bug, they have used lots of theorem proving =)
00:40:14 <skew> http://www.lfcs.inf.ed.ac.uk/reports/97/ECS-LFCS-97-358/
00:40:18 <lambdabot> Title: Candidates for Substitution, http://tinyurl.com/lmq2o
00:40:24 <skew> edwardk: might be useful for you?
00:40:25 <phr-newbie> but i dunno about doing a whole instruction set
00:40:41 <skew> phr-newbie: you think they just want FDIV to work right?
00:40:50 <phr-newbie> hehe
00:40:54 <edwardk> phr: adam chlipala has a small subset of the x86 opcodes encoded in coq
00:41:14 <phr-newbie> edwardk, yeah, that's who i was thinking of
00:41:27 <phr-newbie> his page mentioned a verified c compiler project
00:41:29 <skew> anyway, going all the way down to the opcodes is farther than people usually reason about their programs
00:41:30 <edwardk> but its just a small portion of the ALU and basic branching
00:42:21 <edwardk> skew: well, i am trying to go down to assembly so i can take advantage of opportunities for local use of SSE opcodes for array processing, etc.
00:42:37 <phr-newbie> well, if you can compile a program down to just those instructions (or even just special combinations of them), ok fine, maybe it runs 100x slower than running it through a regular compiler, but you can use it to bootstrap the regular compiler
00:42:40 <edwardk> skew: mostly coz i'm interested in working up a functional language that breaks from the list-based-processing tradition.
00:42:57 <phr-newbie> GPGPU !!!!!
00:43:06 <edwardk> phr: thats also on my list =)
00:43:08 <skew> edwardk: can't you just verify that some local rewrites are sound?
00:43:33 <skew> phr-newbie: those "special instructions" are probably what most code uses anyway. integer arithmetic, Jcc, that sort of stuff
00:43:52 <dmead> constructors must start with a : yes?
00:44:00 <edwardk> phr: the same optimizations i have to do in order to generate branchless code for jump optimization is the same optimization set i have to do for local SIMD SSE operations is the same optimization set you need to generate GLSL code at compile time for GPGPU usage
00:44:05 <skew> dmead: yes, that's how you tell them apart
00:44:16 <edwardk> skew the local rewrites are what i want the affine theorem prover for
00:44:40 <skew> edwardk: how about just proving substituting particular instruction sequences for others is sound?
00:44:46 <phr-newbie> if you want to prove an OS, you need all those special instructions for cache control and virtual memory and concurrency etc etc
00:45:09 <edwardk> phr: combined with aggressive register usage because i can color in my type system whether or not a change is visible across threads and my regster allocation can take into consideration my regions, its actually quite alarming the possibilities.
00:45:35 <edwardk> skew: thats what i want for a peephole optimizer, its necessary, but not sufficient for the whole compiler.
00:46:06 <skew> can you get Coq to call extracted code for the Eval tactic?
00:46:16 <skew> or rule, or whatever it is
00:46:27 <edwardk> skew: what i would love to use to peephole optimize is to treat register/immediate only instruction sequences with the affine theorem prover to try to find shorter/lower register pressure sequences.
00:46:30 <phr-newbie> edwardk wow neat
00:48:17 <edwardk> skew: coz if i can use a general purpose affine theorem prover, and a set of axioms for the available opcodes that consume the appropriate linear/affine resources for the registers and time available, then i should be able to use register count and cycle counts to find optimal short code sequences.
00:48:30 <edwardk> not quickly, but deterministically anyways
00:48:58 <edwardk> a nice -On kinda thing =)
00:50:32 <lisppaste2> skew annotated #27578 with "Oop" at http://paste.lisp.org/display/27578#1
00:51:01 <skew> didn't copy the last half of the proof that actually says reverse . reverse == id
00:51:16 <edwardk> heh
00:51:21 <phr-newbie> skew, that's a whole proof?
00:51:26 <skew> yep
00:51:35 <phr-newbie> hmm
00:52:45 <edwardk> phr: you guide proofs in coq, it leads to a fairly natural style coz you can exploit both what you know about logic and what you know about the lambda calculus.
00:53:11 <edwardk> since it expresses them in an extended lambda calculus
00:53:17 <skew> the first two are l++[] = l, and reverse(xs++ys) = reverse ys ++ reverse xs
00:53:48 <phr-newbie> is there a haskell parser so you can annotate actual executable haskell code with proofs?
00:54:15 <phr-newbie> this seems easier to do with lisp
00:54:23 <edwardk> phr: actually its a bit different, you can designate portions of the coq output as a specification for a program, then you can extract the executable portion of the code and run it as a haskell program
00:54:42 <phr-newbie> neat, that's just as good
00:55:27 <edwardk> though there is effectively 0 documentation on haskell extraction you can find plenty on ocaml extraction.
00:55:35 <skew> then with that, the proof bascially reads "I'll prove reverse (reverse ls) == ls by induction on ls. The nil case is trivial. For the cons case, expanding the definition of reverse leaves the goal reverse (reverse l2 ++ [n]) = n : l2. By the lemma about reverse and ++, the left side is reverse [n] ++ reverse (reverse l2), then calcualte reverse [n] and apply the inductive hypothesis"
00:56:34 <skew> It's a lot shorter in Coq because you don't have to periodically repeat the state of the proof - the IDE lets you step through that anyway.
00:57:14 <musasabi> morning
00:57:20 <edwardk> heya musa
00:58:10 <skew> hi
00:58:47 <araujo> hi hi
01:01:51 <musasabi> yip: urlpatterns like functionality is easy to do.
01:03:23 <musasabi> yip: no file uploads at the moment - still looking for the best way to do it without coupling http too closely to MACID.
01:05:48 <phr-newbie> bbiab
01:25:49 <foxy> skew, do you have a definition for append so I can play with it?
01:27:38 <lisppaste2> skew annotated #27578 with "definitions" at http://paste.lisp.org/display/27578#2
01:28:14 <foxy> :)
01:31:17 * foxy begs skew for a proof of append_associative?
01:31:33 <skew> that's in the original file, see the link
01:31:42 <foxy> ok
01:32:58 <skew> I should really be writing code to show people at work how wonderful Erlang and Haskell would be for the stuff we are doing, but playing with Coq is fun.
01:33:22 <dibblego> skew, what stuff do you do at work?
01:33:40 <skew> make a cluster of some backend stuff.
01:33:59 <skew> lots of databases, and stuff like that
01:34:36 <skew> then handling queries by looking up bits from different places
01:34:57 <dibblego> have you looked at RDF?
01:35:11 <skew> the sort of stuff Erlang was born for, leaving aside the calculations that produce some of the databases
01:37:01 <skew> dibblego: not really, but it's fairly useless, we've got a fairly fixed schema
01:37:11 <skew> as in, changes a few times a year
01:37:42 <dibblego> from the little I know of RDF, I think that makkes it "not useless"
01:38:19 <skew> well, we know extactly what we work with, it's all our own data rather than web resources, and the big problem is coding it to cram it all into RAM
01:39:13 <skew> it seems like RDF might help if you have some interesting semantics going on
01:56:12 <edwardk> speaking as someone who has the misfortune of working with RDF on a daily basis, I will actually claim that unless you are communicating with someone else and need a common vocabulary/ontology then RDF is damn near useless ;)
01:57:08 <dibblego> edwardk, to me, it seems like a more flexible data format model compared to the relational model
01:57:28 <edwardk> s-expressions were reinvented as xml, codasyl was reinvented as rdf.
01:57:57 <edwardk> flexible != better =)
01:58:21 <dibblego> then what's the not better bit?
01:59:12 <edwardk> rdf network models do not admit nearly the level of indexing of information that you can get in a relational schema. its nearly impossible to divvy up codasyl/rdf/network data models so you are forced to reason about the whole thing, the transmission formats are insanely chatty, etc.
02:00:03 <dibblego> s/admit/permit ?
02:00:16 <edwardk> sure
02:02:37 <edwardk> in any event, the reason we use the relational model today and not the codasyl/network model is largely a historical accident, i'll admit, but rdf is hardly a panacea ;)
02:03:48 <dibblego> sure
02:04:03 <dibblego> but is it a forward step?
02:04:21 <dibblego> would you say that Java to Haskell is a forward step?
02:04:22 <edwardk> lateral movement that lags a few steps behind i'd say.
02:05:11 <skew> edwardk: RDF?
02:05:13 <edwardk> java to haskell is arguably a lateral movement that puts you a step or two ahead and leaves you disgruntled with your lot in life as a java programmer ;)
02:05:28 <edwardk> skew: yeaah
02:05:33 <dibblego> you don't see a value in using a pure FP language in providing this "higher order" view of relational data?
02:07:24 <edwardk> codasyl/rdf give you little way to control the presence or absence of values just the ability to look at entity-relationships in a very ad-hoc manner. its really good for 'semi-structured' data whatever that is. and thats a very narrowly defined role. the move in the world is towards more rigid data formats after an initial exploratory phase, the rdf model has applicability in that exploratory window, but afterwards you wind up triple
02:07:41 <araujo> edwardk, just 2 steps ahead??!
02:08:02 <edwardk> araujo: well. maybe in seven-league boots =)
02:08:12 <araujo> :-)
02:08:30 <dibblego> what comes after "triple"?
02:08:40 <dibblego> *"tripl"
02:09:16 <cakoose> What is "semi-structured data", anyway?
02:09:41 <dibblego> triples always remind me of BMW motorcycles
02:09:43 <edwardk> well, the idea of 'semi-structured' data is usually a rapid-application development mindset than you throw the data in the pot and then apply the schema after the ffact
02:09:44 <cakoose> I hadn't really thought about it until recently and now I can't figure out what it is.
02:10:09 <cakoose> edwardk: So use maps instead of typed records?
02:10:15 <edwardk> the problem is that once you have all the data you are usually loathe to go back and normalize
02:10:34 <edwardk> so you wind up making the processing far more complex than it needs to be
02:10:54 <cakoose> I remember hearing a lot about how XML is good at semi-structured data.  I thought I'd finally made sense of things by realizing that there is no such thing as semi-structured data :)
02:10:57 <edwardk> cakoose: yeah. basically throw it in xml make up the tags, come back and specify your conventions more rigidly later.
02:11:20 <edwardk> cakoose: yeah, basically there are studies showing that semi-structured data is more or less a myth =)
02:11:30 <edwardk> lemme see if i can find a reference aroun here somewhere fast
02:12:13 <cakoose> edwardk: I suspected as much.  If a program has to process it, it's gotta have some structure.
02:12:30 <dibblego> then shouldn't it be the program that applies structure?
02:12:33 <edwardk> What Goes Around Comes Around - Stonebraker and Hellerstein discusses the XML/RDF revolution in the context of the older data models and the general lack of semi-structured data
02:12:46 <cakoose> edwardk: thx
02:13:23 <cakoose> dibblego: What do you mean?
02:13:29 <edwardk> dibblego: i can't impose structure on your data, so i have to guess at the structure that is present, the i might get it wrong, you might have meant something different semantically than what i guessed, or than what your friend meant when he entered data, etc.
02:13:54 <dibblego> cakoose, I think the data itself should have no structure and that each context (the program) should apply that context
02:14:10 <edwardk> the biggest issue is that traversals in network models are a bitch
02:14:15 <dibblego> edwardk, that is perhaps a problem
02:14:46 <edwardk> the cursor approaches you have to use are not-intuitive and non-optimizable by nature.
02:14:49 <cakoose> dibblego: I still don't get it.  Some amount of structure has to be inherent in the data, right?
02:14:51 <dibblego> edwardk, I see the relational model having the same problems as OO and RDF solving many of them, but perhaps in the same way that Ruby/Python does
02:14:55 <edwardk> er not intuitive
02:15:17 <dibblego> cakoose, at some level - perhaps even at the most basic level
02:15:36 <dibblego> cakoose, should it be "the person" who has an inherent enumeration of properties?
02:15:50 <edwardk> well. there is admittedly an impedence mismatch between the mindset of existing relational models and oo designs as well, but at least the relational model provides a direct efficiency boost in many scenarios =)
02:15:59 <dibblego> or should each property (let's say a varchar) also be split into each char? or even further?
02:16:20 <dibblego> cakoose, it depends how much you believe in an immutable world ultimately
02:17:09 <cakoose> dibblego: I think this discussion has risen past my comprehension level :)
02:17:19 <dibblego> cakoose, don't blame yourself - it's often my fault
02:17:31 <cakoose> dibblego: I just wanted to say that XML sucks :)
02:17:37 <edwardk> heh
02:17:39 <dibblego> cakoose, sure thing :)
02:17:47 <edwardk> i use xml, but only where appropriate =)
02:17:53 <cakoose> Honestly, though... a data format based on algebraic data types seems much better.
02:18:02 <dibblego> does such a thing exist?
02:18:09 <cakoose> On my hard drive :)
02:18:26 <cakoose> I've seen some other attempts too...
02:18:35 <dibblego> on your hard drive, meaning you're working on it?
02:18:45 <cakoose> Yes.
02:18:56 <dibblego> is there anything public? or can you refer to other attempts?
02:19:01 <edwardk> i use it when i need to define some form of markup for user data that i'll need to extract in a number of different scenarios in different software, or where i don't want to reinvent an editor, etc, or when i have to send it over the wire and i can't use JSON, etc.
02:19:14 <cakoose> I'm trying to find the other attempts...
02:19:36 <cakoose> Mine is up at http://cakoose.com/wiki/data_representation
02:19:38 <lambdabot> Title: data representation
02:20:51 <cakoose> The page may be a bit boring for someone who knows about algebraic data types.
02:21:33 <cakoose> The implementation (you need a Java 5 VM to run): http://cakoose.com/tools/cks/
02:21:34 <lambdabot> Title: Index of /tools/cks
02:21:53 <skew> records. we really need to get some proper record polymorphism going in Haskell.
02:22:50 <skew> http://ttic.uchicago.edu/~blume/papers/icfp06.pdf
02:22:53 <lambdabot> http://tinyurl.com/jnft9
02:24:56 <edwardk> that was a good presentation.
02:25:18 <skew> I liked the full type inference.
02:25:18 <araujo> module M (module M) where ... shouldn't this export all the imported modules in M too?
02:26:01 <skew> no, "module M" is shorthand for exporting all unqualified identifiers you got through M
02:26:05 <edwardk> hell of a lot better than the polymorphic variant presentation that the japanese guy gave in the haskell workshop =)
02:26:45 <araujo> skew, so, there is no way to do what i want?
02:26:59 <skew> what are you trying to do?
02:27:14 <skew> you want to say just import X, then use X.Y.fun?
02:27:50 <araujo> skew, i want to export all the modules i am importing in a specific module.
02:28:11 <araujo> so i don't have to write them again in other modules.
02:28:29 <araujo> Or better said, explicitly import them from other modules.
02:28:32 <skew> it's not obvious what you mean by "export" - that's why I'm asking how you would use that export in another module
02:28:47 <skew> so like I said about not needing to explicitly import the other modules?
02:29:52 <araujo> skew, Well, i was thinking about Haskell just doing a simple substitution or adding all these modules from the module exporting them. So no need to any special syntax.
02:29:54 <edwardk> i find it funny that just about everyone working on the stuff i am interested recently left harvard and/or moved to toyota technical institute.
02:30:44 <araujo> For example, module M (module M) where .. import A .. import B ; in the other module using M, module C where .. import M ; Haskell would just add import A, import B
02:31:20 <araujo> automatically .... so like some kind of implicitly inheritance
02:31:49 <skew> if module M uses a module export on A .. B, then C will have all those items available as M.f
02:33:45 <skew> but the qualified name will be M.f, not like M.A.f or A.f
02:35:25 <araujo> ok, mm ..
02:35:34 <araujo> it doesn't look like working here
02:37:41 <skew> read up in the spec. module M might need to use explicit imports or something
02:38:50 <araujo> let me paste an example skew
02:39:20 <skew> you need to look it up now. I'm not sure about anything more.
02:41:23 <araujo> skew, http://rafb.net/paste/results/OHC5YX78.html
02:41:43 <araujo> Ok, just to see if i made myself enough clear
02:42:08 <skew> wait, module M (module M) doesn't make much sense
02:42:13 <skew> that's something like module M where
02:42:27 <skew> try module M (module System.IO, module System.Exit) where
02:42:42 <skew> if you want all the definitions from System.IO and System.Exit to be re-exported from M
02:42:51 <dmead> module M
02:42:59 <dmead> import system(...)
02:43:02 <dmead> isn't that valid?
02:43:24 <skew> if you don't write "(...)"
02:43:33 <skew> you can list imports in parens, or leave off the list entirely
02:44:14 <araujo> skew, ok, let me test it
02:45:49 <araujo> nice it worked!
02:46:17 <araujo> skew, The interesting thing is that i also need to explicitly add (module M , .. ) too
02:46:46 <skew> ah, right
02:46:57 <skew> if you have an export list, you only export the things explicitly listed
02:46:58 <dmead> import system for haskell should really just mimmic java at this point
02:47:02 <dmead> i mean
02:47:05 <dmead> its not like i love sun
02:47:12 <dmead> but they seem to have it all figured out
02:47:19 <skew> so if you had some local definitions in M, you'd need to include M.
02:47:21 <dmead> for that at least ;p
02:47:23 <araujo> skew, yeah, thanks
02:47:30 <skew> dmead: I think the Haskell system is already a fair bit nicer
02:47:44 <skew> ML is the one that really has it pretty well worked out
02:47:49 <dmead> yea?
02:47:49 <phr-newbie> put in seven extremely random user interface commands :)
02:47:52 <dmead> i never had to use it in ml
02:49:57 <JohnMeacham> yo.
02:50:03 <skew> hi
02:50:23 <Heffalump> hi
02:50:25 <dmead> sup.
02:50:53 <JohnMeacham> nuttin.
02:51:43 <dmead> awesome
02:52:02 <dmead> whats the hot irc client these days?
02:52:07 <dmead> thats not kirc
02:52:16 <AI_coder> quirc
02:52:34 <phr-newbie> i'm using xchat
02:55:06 <skew> JohnMeacham: how's jhc doing?
02:55:12 <lispy> ERC Version 5.1.4
02:55:28 <lispy> my irc client ^^^
02:55:30 <matthew-_> bitchx
02:55:30 <phr-newbie> quirc looks like it hasn't been maintained in years
02:56:10 <phr-newbie> and it's written in tcl!  zomg!!
02:56:12 <dmead> hehe
02:56:16 <dmead> which one resembles mirc?
02:56:21 <dmead> lawl tcl
02:56:41 <dmead> i had the aim client written in tcl/tk for a while
02:56:48 <dmead> it's real messey
02:56:56 <lispy> the nice thing about using emacs for irc is that it becomes multiplayer text editing
02:57:09 <phr-newbie> dmead, if you mean a widgety client, try xchat, it's not exactly like mirc but is comparable
02:57:20 <phr-newbie> there's an emacs irc client?
02:57:21 <dmead> LOL lispy
02:57:26 <dmead> theres everything for emacs
02:57:35 <phr-newbie> yow
02:57:36 <lispy> phr-newbie: yes, several
02:57:39 <dmead> an http interpreter too
02:57:40 <phr-newbie> cripes, there's several
02:57:41 <phr-newbie> jinx
02:57:43 <lispy> Where's my SOCIAL WORKER?
02:57:54 <lispy> ^^^ M-x yow :)
02:58:02 <phr-newbie> lispy which one do you recommend?
02:58:08 <phr-newbie> does your SPEED QUEEN have CABLE?
02:58:12 <lispy> ERC Version 5.1.4
02:58:15 <dmead> lispy, what do you use for the chat line?
02:58:24 <dmead> the minibuffer?
02:58:25 <lispy> chat line?
02:58:28 <lispy> oh no
02:58:32 <lispy> it's just in buffer
02:58:37 <dmead> ah
02:58:47 <lispy> but i have the settings to keep the cursor at the bottom
02:58:55 <lispy> so it works just like any irc client
02:58:58 <dmead> gotcha
02:59:05 <phr-newbie> lispy this is totally insane, i have to start using it, thanks
02:59:16 <JohnMeacham> skew: been documenting its internals.
02:59:43 <JohnMeacham> http://repetae.net/john/computer/jhc/big-picture.pdf
02:59:46 <lambdabot> http://tinyurl.com/onuzw
02:59:57 <lispy> phr-newbie: if you want to look at my .emacs look here: http://projects.codersbase.com/repos/dotemacs/
03:00:00 <lambdabot> Title: Index of /repos/dotemacs, http://tinyurl.com/cor3w
03:00:33 <lispy> phr-newbie: it's a bit out of date but it has most of my erc settings
03:01:11 <dmead> can you put up a screenshot?
03:01:24 <phr-newbie> thanx
03:01:28 <yip> @seen musasabi
03:01:28 <lambdabot> musasabi is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard musasabi speak 1h 58m 4s ago.
03:01:30 <lispy> how do you take a screenshot in osx?
03:01:57 <Maddas> Shift-Apple-3 is the standard shortcut.
03:02:05 <Maddas> (You may have it disabled, I'm not sure what the default is)
03:02:29 <lispy> nothing happens, should preview open or something?
03:02:39 <dmead> maybe alt-printscreen
03:02:45 <Maddas> No, it creates a "Picture x" file on the desktop.
03:02:56 <Maddas> (Either PNG or PDF, depending on the OS X version IIRC)
03:03:52 <Maddas> (See the first two entries in System Preferences->Keyboard->Keyboard Shortcuts to check whether it's activated and what the shortcut is)
03:06:48 <Patterner> I use Shift-Apple-4 because ususally I want just a part :)
03:07:08 <lispy> http://gallery.codersbase.com//main.php?g2_view=core.ShowItem&g2_itemId=922
03:07:10 <lambdabot> Title: Picture 1.png, http://tinyurl.com/o9zdv
03:07:26 <lispy> ah yeah taht would have been nice to know...because i ended up cropping it
03:07:56 <Patterner> :)
03:08:04 <lispy> actually that doesn't seem to do much
03:08:31 <lispy> oh you get a cross hair
03:08:36 <Maddas> :-)
03:08:57 <Patterner> move mouse. hold button. move mouse. release button. watch picture.
03:08:58 * Maddas uses irssi, for the record
03:09:20 <Patterner> I use irssi, but not on osx
03:09:25 <Maddas> I do.
03:09:29 <yip> weird, "runhaskell" works only when i give it -v option. if i don't then it doesn't seem to do anything, just exits immediately
03:09:42 <lispy> dmead: so i put up a screen shot
03:10:41 * Maddas prefers using ERC with Carbon Emacs (and erctabs)
03:11:50 * lispy hates, hates, hates carbon emacs
03:12:01 * lispy always uses emacs -nw
03:12:04 * Maddas likes it far more than emacs -nw
03:12:09 <lispy> what are erc tabs?
03:12:15 <Maddas> lispy: http://www.emacswiki.org/cgi-bin/wiki?ErcTabs
03:12:18 <lambdabot> Title: EmacsWiki: ErcTabs
03:12:42 <Maddas> (But I don't use ERC nowadays anyway. I found it very convenient, but it distracted me more than anything else while writing code)
03:13:10 <lispy> heh
03:13:11 <dmead> nice lispy
03:13:17 <Maddas> Too tempting to read up whenever any new message arrives (C-SPC to switch to the irc channel, C-SPC to switch back to buffer)
03:13:23 <lispy> ah, yeah i usually irc from a different emacs session than i write code
03:13:32 <dmead> will it work in xemacs?
03:13:39 <lispy> no idea
03:13:45 <dmead> hehe k
03:13:51 <Maddas> lispy: What bothers you about emacs -nw?
03:13:51 <lispy> i haven't use xemacs in years
03:13:56 <Maddas> lispy: Erm, I mean Carbon Emacs.
03:14:09 <lispy> they break the apple keys for one
03:14:13 <Maddas> How so?
03:14:17 <dmead> oh
03:14:19 <lispy> for two, it doesn't use a terminal window
03:14:26 <Syzygy-> Hmmmm. How does the messaging services of lambdabot work?
03:14:29 <lispy> Maddas: by taking them over
03:14:51 <Maddas> lispy: What doesn't work, as an example? Global keyboard shortcuts?
03:15:13 <lispy> i don't remember exactly, but it remember the way they take over the keyboard is annoying
03:15:17 <lispy> i don't use it
03:15:30 <lispy> except when the emacs from darwin ports is broken
03:15:33 <Maddas> There's a setting to change the way it treats the Apple key, which is why I asked.
03:15:36 <lispy> and even then i prefer vi
03:15:42 * Maddas uses Viper mode anyway
03:15:55 <lispy> even if i fix #1, there is still #2
03:15:58 <Maddas> I find the way 'emacs -nw' treats the apple key far more annoying, in any case :-)
03:16:09 <Maddas> lispy: What's the issue with not using a terminal window? Not being able to use screen and such?
03:16:15 <Syzygy-> @tell gds Syzygy- is the odd nick out for me - due to my being on #math. Normally, I use variations on michi or exile, and a concatenation if nothing else is free.
03:16:15 <lambdabot> Consider it noted.
03:16:57 <lispy> Maddas: partly, but also, emacs in a terminal is very readable and takes up little screen space...in the non-terminal version i have to make the fonts bigger and then it eats up the whole screen
03:17:05 <Maddas> I've managed to kludge together X11/emacs settings to make emacs -nw usable from within X11, but I find it rather painful to use outside X11. (But then again, I'm on a PowerBook, which has rather few modifier keys.)
03:17:07 <dmead> damn it
03:17:09 <lispy> with the terminal version i can have 4 different terminals on screen at once
03:17:13 <dmead> i hate what emacs freezes
03:17:29 <Maddas> lispy: oh, I find the non-terminal version more readable font-wise (with the same font size).
03:18:01 <lispy> also, carbon emacs seems a lot slower
03:18:03 <Maddas> And I usually partition it with Emacs frames if I edit full-screen
03:18:13 <lispy> but maybe that's because my ibook doesn't have much processor or ram
03:18:20 <Maddas> Ok, never had any issues at all with performance.
03:18:40 <Maddas> (Though I'd expect 4 different emacs sessions to use more space...)
03:18:51 <lispy> the only thing carbon emacs has going for it on my ibook is that it doesn't break after apple security updates
03:18:58 <Maddas> Ow :-/
03:20:15 <Maddas> lispy: What font is that?
03:20:23 <lispy> no idea
03:20:31 <Maddas> Ok.
03:21:24 <lispy> the last time i putzed around with emacs fonts was on X
03:21:30 <lispy> perhaps i have a bet setting
03:21:46 <lispy> but it was so hard to find this font i don't want to bother again :)
03:21:51 <Maddas> :-)
03:22:16 * Maddas just uses the default Terminal font in Carbon Emacs because he eventually gave up trying to piece together anything else
03:22:24 <Maddas> (And because I like it more than most things I've found yet)
03:22:30 <lispy> right
03:22:38 <lispy> i may actually be using that font
03:22:45 <lispy> it sound familiar
03:22:50 <Maddas> hm, it seemed a little different...
03:23:21 <lispy> if you're going by that screen shot it was taking from terminal.app
03:23:24 <Maddas> My font is this: http://people.ee.ethz.ch/~zieglerm/Picture%201.png
03:23:27 <lambdabot> http://tinyurl.com/kocsb
03:23:28 <lispy> i use emacs on a remote machine for irc
03:23:44 <Maddas> lispy: Ah, I see. I used to run an irc proxy and connect to that with ERC :-)
03:30:52 <lispy> Maddas: i should look into that
03:31:01 <lispy> Maddas: can any client connect to a proxy?
03:31:14 <lispy> if so that could be kinda cool
03:31:51 <lispy> sometimes it would be nice to be using a local client so that i get beeps and stuff when people say my name
03:33:06 <Maddas> lispy: Yeah, AFAIK the proxy just looks like a server to the client.
03:33:23 <lispy> where do i get the proxy?
03:33:28 <lispy> where do i learn about this?
03:33:30 <Maddas> I use dircproxy, I'm not sure whether it's still being developed or anything, but it works well and had the features I wanted.
03:33:37 * Maddas shrugs sheepishly
03:33:43 <lispy> okay
03:33:45 <Maddas> I just got it working and then didn't touch anything after that =)
03:33:46 <lispy> i'll google it tomorrow
03:33:53 <lispy> i should go to sleep now :)
03:33:56 <Maddas> Good night!
03:34:02 <lispy> good night
03:34:12 <dmead> anyone know how to refrence a module you
03:34:17 <dmead> ve written yourself?
03:34:23 <dmead> is it the filename?
03:34:30 <lispy> same way as normal
03:34:41 <lispy> Foo.hs => import Foo
03:35:00 <dmead> gotcha
03:35:01 <dmead> thanks
03:35:18 <lispy> np
03:35:30 <dmead> i'm getting the prefix and infix logic notations to be abstracted away from my algorythm
03:37:12 <dan_> ;o
03:37:42 <dan_> yea xchat is qutie mirc like
03:37:44 <dan_> hmm
03:57:37 <lscd> Is there any way to find out what functions are being called directly before a stack overflow occurs?
03:58:54 <dmead> like trace in lisp?
03:59:07 <psnl> lscd: hat-stack?
03:59:17 <lscd> I'm fuzzy on what trace in lisp does exactly
03:59:54 <dmead> i think it shows you a machine state as every function is called
03:59:59 <dmead> but i havent done lisp in like a year
04:00:19 <dmead> but anyway
04:00:24 <lscd> ahh - basically, i have a moderately complex recursive grammar, and I assume I have a typo somewhere in it leading to infinite recursion, and I want to find where
04:00:30 <dmead> what are you getting a stack overflow with
04:00:36 <dmead> ah
04:00:51 <dmead> link?
04:01:12 <lscd> i'll upload
04:01:14 <dmead> k
04:01:21 <lscd> it's very rough and ugly right now
04:02:43 <dmead> hehe i know how it is
04:02:49 <dmead> i'm in the middle of a project myself
04:04:20 <lscd> atelier.inf.unisi.ch/~baroneak/c_parse.tar.gz
04:05:39 <dmead> k
04:05:51 <dmead> any idea what file/line?
04:06:14 <lscd> if you run 'make' in the main dir, it tries to run the tests; the actual error is almost definitely in ParseC
04:06:24 <lscd> one of the tests triggers the stack overflow
04:07:32 <lscd> in the findLogicalORExpression ... findPostFixExpression area
04:09:54 <dmead> hmm
04:10:02 <dmead> have you tried debugging in hugs?
04:10:06 <dmead> or just ghc
04:10:19 <lscd> just ghc, thus far
04:11:15 <lscd> I can't even load ParseC in hugs, it seems: ERROR "/usr/lib64/hugs/packages/parsec/Text/ParserCombinators/Parsec/Token.hs":64 - Syntax error in data type declaration (unexpected `.'
04:11:40 <dmead> yea
04:11:44 <dmead> i got the exact same thing
04:12:10 <dmead> hmm
04:12:16 <dmead> well i'm not expert
04:12:31 <dmead> but you've got a ton of 'do' constructions in here
04:12:43 <lscd> yes, parsec is a monadic parser combinator
04:12:53 <lscd> so i end up having to work with do and monads a lot
04:13:12 <Philippa> which isn't a bad thing, because they're a damn good fit
04:13:19 <dmead> hmm
04:13:39 <Heffalump> arrows!
04:13:45 <lscd> Philippa: yeah - I love writing parsers with parsec; but this is the first non-trivial parser with recursive bits that I try to use it for
04:14:07 <dmead> arrows rock my socks
04:14:08 <dmead> :)
04:14:56 <lscd> Heffalump: arrows? (I assume this relates to the category theory definition, etc, but eh.. I'm missing something here, would you explain where it comes in exactly?)
04:15:53 <Heffalump> lscd: no, it relates to John Hughes's definition. Basically they're a generalised version of monads.
04:16:33 <Heffalump> Where with a monad m you write things of type x -> m y, with an arrow a you write things of type a x y
04:16:55 <lscd> <head explodes> :)
04:16:59 <Philippa> with the consequence that not all arrows support higher-order computations (by analogy with higher-order functions)
04:17:16 <lscd> Philippa: do all monads?
04:17:20 <Philippa> those that /don't/ are amenable to a number of analyses (and thus optimisations) that monads aren't
04:17:20 <Heffalump> this means that an arrow can separate out parts of its state that are unrelated to the input from the parts that depend on it
04:17:32 <lscd> oh, cool!
04:17:34 <Philippa> lscd: yes. All monads have join, which has the type m (m a) -> m a
04:17:59 <Heffalump> which in turn means that you can write more efficient parsers that do some one-time-only computation (e.g. of prefix sets) before being used repeatedly
04:18:12 <lscd> Philippa: hmm, I'm being slow here, but how does having join end up implying that they support higher order computations?
04:18:29 <Heffalump> this was proposed as one of the main benefits of arrows in Hughes's original paper, but I'm not sure anyone ever actually implemented anything
04:18:34 <Philippa> lscd: you can already build m (m a) with return - you just return a computation. With join, you can run it
04:18:38 <audreyt> is there something arrow parsers can practically do that applicative parsers can't?
04:18:51 <audreyt> (efficiency-wise, not capability-wise)
04:18:52 <Heffalump> audreyt: in terms of what they can recognise? I doubt it.
04:19:05 <skew> "applicative" parsers are arrow parsers, I think
04:19:19 <Heffalump> I don't know what applicative parsers are, actually.
04:19:24 <audreyt> though applicatives are not as general as arrows iirc
04:19:39 <skew> I don't think arrow parsers usually have a nontrivial first argument anyway
04:19:44 <Heffalump> DYM as in the class Applicative that someone (Conor) proposed?
04:20:01 <Heffalump> s/Conor/Conor?/
04:20:19 <audreyt> yes, http://www.soi.city.ac.uk/~ross/papers/Applicative.html
04:20:25 <lambdabot> Title: Applicative Programming with Effects, http://tinyurl.com/zjmbp
04:20:39 <audreyt> skew: thanks, that's the answer I was looking for
04:20:52 <Heffalump> well, Applicative is a weakening of Monad, so yes, Arrow-based parsers can be more efficient, IIUC
04:22:01 <Heffalump> oh, wait, I'm getting that the wrong way up
04:22:17 <Heffalump> every Monad is both an Applicative and an Arrow
04:23:01 <Heffalump> in that case I don't know.
04:23:19 <Heffalump> skew: surely the first argument is the input to be parsed?
04:23:35 <Heffalump> (it's a while since I've read the paper so I'm a bit hazy on the details)
04:23:40 <skew> but that would always be String, I think - actually, I don't know how they would be connected
04:24:00 <Heffalump> yeah, so it's always the same type, but hardly non-trivial
04:24:04 <Heffalump> IM hardly trivial.
04:24:07 <Philippa> Heffalump: no, for the same reason it's not in a state transformer
04:24:21 <skew> if it's always the same you can't use the arrow composition sensibly
04:24:31 <audreyt> wow. pugs has a bug that manifests only in ghc but never in ghci; took me nearly a few hours to track down
04:24:38 <Philippa> audreyt: ouch
04:24:42 <audreyt> in the end it was Set.fromAscList applied to something that isn't sorted.
04:24:46 <audreyt> but why it works in ghci, I have no idea.
04:24:50 <skew> you'd just have sideways operations like Arr m (a -> b) * Arr m a => Arr m b
04:25:03 <audreyt> s/nearly//
04:25:25 <Heffalump> Philippa: "no" to what?
04:25:43 <Philippa> to the input always being String
04:26:08 <Heffalump> ah, ok. As skew points out that couldn't work, yeah.
04:26:17 <skew> ah, I suppose you would use the arrow arguments for the usual value plumbing stuff, and provide primitive parsers with types like Arr () Char
04:26:27 <Philippa> exactly
05:49:24 * araujo feels sinful using unsafePerformIO
05:49:40 <astrolabe> he is sinful
05:50:00 <roconnor> is there such thing as a strict IOref?
05:50:09 <roconnor> something like IORef !Int
05:50:22 <roconnor> but that probably isn't valid
05:52:38 <roconnor> maybe IORef Int#?
06:04:35 <bringert> why is it MonadError IOError IO instead of MonadError Exception IO?
06:06:05 <dcoutts> roconnor, you can make one by always seq'ing before using writeIORef
06:06:17 <dcoutts> so you could do a wrapper module in about 10 lines of code
06:06:34 <dcoutts> import Data.IORef.Strict
06:07:09 <dcoutts> roconnor, btw IORef Int# will not work because the kinds are wrong.
06:11:51 <roconnor> Data IORef.Strict?
06:14:42 <dcoutts> roconnor, that's the thing I was suggesting you could write in 10 lines
06:14:52 <roconnor> oh ok
06:15:34 <dcoutts> newtype IORef a = IORef (NonStrict.IORef a)
06:16:24 <dcoutts> writeIORef (IORef r) x = x `seq` NonStrict.writeIORef r x
06:16:43 <dons> we had to do this in the shootout cheap-concurrency test
06:16:59 <dcoutts> or just every time you use writeIORef use: writeIORef r $! x
06:17:13 <dons> this baby, http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=ghc&id=0
06:17:21 <lambdabot> Title: cheap-concurrency Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp; ..., http://tinyurl.com/kj3to
06:17:21 <dons> putMVar om $! x+1
06:18:00 <roconnor> What do you think is better, IORef (Foo, Bar) or (IORef Foo, IORef Bar)?
06:18:22 <dcoutts> I prefer to minimise the number of IORefs
06:18:43 <dcoutts> it allows you to do more stuff purely
06:18:52 <dcoutts> and centeralise the state management
06:22:20 <Heffalump> 'lo
06:44:27 <greenrd> I would like to convert a function (a,b)->(a,c) into a function of type P b -> P c for arbitrary product types, e.g. for a product type like: data SomeProd s = SomeProdCon a s
06:44:56 <xerox> ?type second
06:44:58 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
06:45:08 <greenrd> This seems to be generic programming, however, I'm unsure how to do this with Scrap Your Boilerplate
06:46:00 <Heffalump> can you give a more complicated example of such a product type? Does it have to embed a?
06:46:23 <greenrd> The thing is I want to view the type as a generic product, whereas SYB seems to be more about matching on a particular type and ignoring other types
06:48:11 <greenrd> Heffalump: well, the more general case is converting (a,b)->(c,d) into P a b -> P c d for arbitrary P. The previous case is just the one I'm interested in right now.
06:49:00 <twanvl> You could just create a class, I doubt there will be many instances
06:49:03 <Heffalump> so you want to handle an arbitrary constructor but with that precise kind?
06:49:12 <greenrd> twanvl: Yeah, that's the easy way out :)
06:50:17 <Heffalump> what you want is structural matching, whereas SYB is really about nominal matching
06:50:29 <greenrd> Heffalump: Yes, and yes
06:50:44 <Heffalump> so I don't think it can be done, at least not nicely
06:50:50 <greenrd> But can SYB be perverted to do structural matching?
06:51:07 <greenrd> Since it is in GHC it might be convenient ;)
07:01:36 <psykotic> greenrd: i recall frank atasannow did some work on inferring canonical isomorphisms with generic haskell.
07:02:20 <psykotic> err, atanassow
07:02:44 <psykotic> obviously a lot more general than what you need but might be interesting
07:03:12 <roconnor> ugh, can't figure out what is taking all my time in the haskell program.
07:13:49 <fasta> What's the easiest way to implement back tracking?
07:15:10 <Heffalump> fasta: list monad
07:15:53 <fasta> Heffalump: so, I have a couple of choices in the list, and then fork off a few branches. ok
07:19:47 <roconnor> fasta: list monad
07:21:52 <roconnor> @hoogle hGet
07:21:53 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
07:21:54 <lambdabot> IO.hGetChar :: Handle -> IO Char
07:21:54 <lambdabot> IO.hGetContents :: Handle -> IO String
07:22:59 <kpreid> greenrd: you can do it with generics, i think
07:23:12 <TheOnlyOne12> hii :d
07:23:31 <kpreid> greenrd: at least, I've done something similar
07:24:11 <araujo> hola erider
07:24:25 <erider> hola como te vaj araujo
07:25:00 <roconnor> ah, it helps to run the program you are compiling
07:30:55 <roconnor> @type hFileSize
07:30:56 <lambdabot> Not in scope: `hFileSize'
07:31:04 <roconnor> @hoogle hFileSize
07:31:05 <lambdabot> IO.hFileSize :: Handle -> IO Integer
07:33:32 <yip> does unicode have klingon characters?
07:34:24 <earthy> yip: it has space for klingon characters.
07:35:14 <earthy> it is not formally part of the standard. but, the private use area can be used for klingon (that is, codepoints F8D0 through F8FF)
07:35:19 <yip> i guess that's useful for custom applications, but what if i want to have klingon text on a webpage?
07:35:24 <earthy> and these have been standardised. :)
07:36:02 <yip> why isn't klingon in the unicode standard? it's not like they don't have an assload of other totally useless crap :/
07:36:06 <earthy> http://www.evertype.com/standards/csur/
07:36:08 <lambdabot> Title: ConScript Unicode Registry
07:36:23 <earthy> yip: because it is not normally used as a script, even for exchanges in klingon
07:36:35 <earthy> (yes, this is politics rather than technology)
07:37:35 <yip> they should have made unicode 64 bits, and then they wouldn't have to worry about politics at all
07:38:00 <yip> in fact, they should have made unicode variable length
07:38:11 <yip> then they could just keep adding more and more characters to it forever
07:40:02 <FransE> Hi, I need an haskell compiler for GNU/Linux. Any suggestions?
07:40:09 <dcoutts> FransE, GHC
07:40:20 <dcoutts> @where ghc
07:40:21 <lambdabot> http://haskell.org/ghc
07:40:42 <dcoutts> yip, they already have masses of space, and they've shown in the past that they're not afraid to give themselves more space if needed.
07:40:58 <dcoutts> 32bits should be enough for anyone... ;-)
07:42:26 <dcoutts> woo! got a C gramar with only one shift/reduce conflict
07:42:41 <dcoutts> by porting an existing one I pinched
07:42:53 <FransE> dcoutts_: so GHC is a Microsoft project or?
07:42:56 <dcoutts> now, to extend it to C99 and GNU
07:43:03 <dcoutts> FransE, it's open source, BSD license
07:43:22 <dcoutts> FransE, yes, a couple of MS Research guys work on it a lot
07:43:27 <FransE> k
07:43:38 <roconnor> I don't suppose GHC optimizes across modules
07:43:42 <FransE> cool, never seen them directly on open source projects like that before.
07:43:43 <dcoutts> yes it does
07:43:46 <yip> dcoutts: so why does it appear that they are putting a lot of thought whether to include tengwar, instead of just including that shit without thinking?
07:44:01 <dcoutts> roconnor, it does loads of cross-module optimisation
07:44:07 <roconnor> oh good
07:44:31 <roconnor> will it inline across a module?
07:44:36 <dcoutts> roconnor, yes
07:44:44 <dcoutts> yip, who knows, each change does have some cost though
07:45:22 <dcoutts> roconnor, just build with -O and it'll do all that
07:45:29 <FransE> GHC 6.4.1 is the one to use right?
07:45:44 <dcoutts> FransE, or 6.4.2 if it's avaialable for your distro
07:47:17 <FransE> 6.4.2 is not listed on the download pages. I'll probably survive with 6.4.1. (My intent is to learn Haskell)
07:51:38 <Magicman{away}> http://haskell.org/ghc/download_ghc_642.html
07:51:39 <roconnor> @hoogle unsafeReadArray
07:51:39 <lambdabot> Title: GHC: Download version 6.4.2
07:51:39 <lambdabot> No matches found
07:52:31 <roconnor> @hoogle unsafeRead
07:52:32 <lambdabot> No matches found
07:52:34 <Magicman{away}> Link to 6.4.2 is right under "Current Stable Release (6.4.2)" on the download page
07:53:28 <kpreid> Is there a monad or function with which "do (x:xs) <- get; put xs; do-something-with x" (State monad) is better expressed?
07:53:47 <xerox> ?type modify
07:53:48 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
07:53:58 <kpreid> modify gives no result
07:54:13 <Cale> kpreid: my Supply monad/transformer
07:54:20 <roconnor> :)
07:54:31 <roconnor> Cale has a monad for every situation
07:54:32 <xerox> Cool.
07:54:33 <Cale> http://www.haskell.org/haskellwiki/NewMonads/MonadSupply
07:54:36 <lambdabot> Title: New monads/MonadSupply - HaskellWiki, http://tinyurl.com/gqxun
07:54:59 <kpreid> I'll just do pop = do (x:xs) <- get; put xs; return x for this application
07:55:24 <roconnor> where is unsafeRead?
07:56:14 <Cale> It's exactly the same as that, but it's just a wrapper around the state monad, so that you can do x <- supply, and you get some insurance that any supply value is only ever used once.
07:56:43 <Cale> (at least, for each time it occurs in the input list)
07:56:56 <roconnor> I could use this monad too
07:57:36 <roconnor> Cale: shouldn't ReadS be a monad?
07:57:42 <roconnor> do you have one for that?
07:57:59 <roconnor> s -> [(s,a)]
07:58:14 <Cale> that's a parsing monad :)
07:58:20 <roconnor> yes
07:58:35 <Cale> You could just use Parsec/ReadP/etc.
07:58:43 <roconnor> readP?
07:59:01 <roconnor> but those are particular to strings?
07:59:32 <Cale> Only partly
07:59:35 <roconnor> @docs Data.Array.Base
07:59:35 <lambdabot> Data.Array.Base not available
07:59:44 <Cale> hmm, ReadP seems to be
08:00:23 <Cale> Parsec is abstracted over the token type
08:00:45 <roconnor> I have a [Item] -> [([Item],Repair)] structure
08:00:53 <roconnor> you are saying I can use Parsec?
08:01:02 <Cale> quite possibly
08:01:08 * roconnor didn't realize he was doing parsing
08:01:09 <Cale> might not be a perfect fit
08:01:54 <Cale> Parsec tries not to get into general nondeterminism, which for your case is annoying
08:02:25 <roconnor> yep.  I'm doing backtracking search
08:02:53 <Cale> http://www.cs.chalmers.se/Cs/Research/Functional/MultiLib/HaskellCgi/show-haskell.cgi?file=../koen/Parsek.hs
08:02:58 <lambdabot> Title: The Multi Library, http://tinyurl.com/s86ot
08:03:08 <hn> is there a random number generators tutorial for dummies somewere?
08:03:26 <hn> or something similar..
08:03:55 <Cale> http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
08:03:58 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
08:04:06 <hn> thanks!
08:04:23 <Cale> that's a nice answer to a question in which I provided a significant amount of information about it :)
08:04:58 <Cale> you could also just read http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
08:05:01 <lambdabot> http://tinyurl.com/hch36
08:05:36 <kpreid> hm, poking at greenrd's problem above, I have (b -> b) -> q a b -> q a b, but not (b -> c) -> q a b -> q a c
08:05:51 <zeeeee> heya Cale
08:05:57 <roconnor> @fps Data.Array.Base
08:05:58 <lambdabot> Maybe you meant: faq ft pl
08:06:04 <roconnor> @fp Data.Array.Base
08:06:04 <lambdabot> Data.Array.Base not available
08:06:13 <roconnor> :'(
08:06:43 * roconnor blindly uses unsafeRead and unsafeWrite without documentation
08:07:46 <araujo> sin!
08:07:57 <xerox> cos!
08:09:43 <ValarQ> cot!
08:11:57 * araujo listening mexican music
08:12:07 <araujo> hah, somebody is happily depressed outside
08:13:54 <sieni> araujo: that's rreally depressing
08:14:06 <b0gg1e> are there already ghc-6.6 rc os x dmgs?
08:14:25 <araujo> sieni, mexican music is kind of interesting ... they are happy and depressed at the same time
08:16:32 <sieni> araujo: hard to say. I only know one mexacan personally, who is the head of our testing
08:17:59 <ndm> when i went to a mexican party they were all really happy, and dancing really enthusiastically
08:18:21 <ndm> then the alcohol ran out, the english people got even more depressed, and the mexican's kept dancing like nothing was wrong
08:19:03 <FransE> What does "compilation IS NOT required" mean? That it could optimize everything into a constant?
08:19:19 <ndm> FransE: that nothing has changed since last time you compiled
08:19:50 <FransE> heh, ok.
08:22:20 <araujo> ndm, haha
08:22:23 <greenrd> kpreid: let's see what you have
08:22:34 <yip> when does haskell compile down to a constant, and when does it calculate the value at runtime? is there some sort of complexity threshold?
08:23:09 <kpreid> greenrd: gvsecond f x = flip evalState (False:True:repeat False) $ gmapM (\v -> do go <- pop; return $ if go then (fromJust . cast . f . fromJust . cast $ v) else v) x
08:23:13 <Heffalump> very few programs are actually constantfoldable
08:23:15 <sieni> yip: yes
08:23:31 <ndm> yip: it usually ends up as a constant by inlining, and it won't inline most recursive functions, so see that as the complexity threshold
08:23:43 <kpreid> greenrd: gvsecond :: (Data (b c a), Typeable a) => (a -> a) -> b c a -> b c a
08:23:55 <kpreid> (needs the signatore)
08:24:01 <yip> ndm: makes sense
08:24:37 <kpreid> greenrd: I'm investigating the other part now
08:30:26 <greenrd> kpreid: wow, that's more complicated than I'd expected it would be
08:31:17 <kpreid> it's mainly complex for the "I need to pick out the second element by way of monadic state" and "yes, these casts can't fail"
08:32:05 <dmhouse> > showString "hello" "foo"
08:32:13 <lambdabot>  "hellofoo"
08:32:49 <dmhouse> There really should be a function for a combined map/fold
08:33:26 <dmhouse> Hrm, does Text.Printf lead to constant-time concatenation by any chance?
08:33:27 <xerox> ?type mapAccumL
08:33:29 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:33:32 <xerox> ?type mapAccumR
08:33:33 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:34:12 <dmhouse> I.e. if I had "IF(" ++ show p ++ "," ++ show t1 ++ "," ++ show t2 ++ ")", and want to optimise that, is ShowS or Printf the best way to go?
08:35:19 <dmhouse> With ShowS it'd be showString "IF(" . shows p . showString "," . shows t1 . showString "," . shows t2 $ ")", which just ain't pretty.
08:35:44 <xerox> Yes it is! :)
08:36:24 <dmhouse> I think Printf's clearer anyway./
08:37:00 <kpreid> greenrd: got it!
08:37:09 <kpreid> gcsecond' f x = let r = evalState (fromConstrM ((do i <- get; modify succ; return $ if (i == 1) then gmapQi i (fromMaybe (error "wrong function type") . cast . f . fromJust . cast) x else gmapQi i (fromJust . cast) x)) (head . dataTypeConstrs . dataTypeOf $ r)) 0 in r
08:37:15 <kpreid> now to make that prettier :)
08:37:57 <kpreid> I want "flip let"
08:38:01 <dmhouse> ?hoogle fromConstrM
08:38:02 <lambdabot> Data.Generics.Basics.fromConstrM :: (Monad m, Data a) => m a -> Constr -> m a
08:38:20 <dmhouse> kpreid: where? ;)
08:38:37 <dmhouse> gcsecond' f x = r where r = ...
08:39:37 <kpreid> ah, yes...doesn't work in lambdabot, which is why I tend to forget it
08:39:39 <kpreid> @let f x = r where r = x + 1
08:39:40 <lambdabot> Defined.
08:39:45 <kpreid> ah, that'll do
08:39:54 <Heffalump> @eval f 2
08:39:59 <dmhouse> ?run f 2
08:40:01 <lambdabot>  Not in scope: `f'
08:40:06 <dmhouse> ?help eval
08:40:07 <kpreid> @run L.f 2
08:40:08 <lambdabot>  3
08:40:08 <lambdabot> eval. Do nothing (perversely)
08:40:30 <dmhouse> > print "foo" -- do we still have that error message?
08:40:31 <lambdabot>  No IO allowed
08:40:39 <dmhouse> Ah, cool, it's been changed.
08:40:50 <Heffalump> how quickly does L get cleaned?
08:40:54 <kpreid> hm, there are various things wrong with my definition
08:42:33 <lscd> dcoutts: which c grammar?
08:43:14 <dcoutts> lscd, the James Roskind ANSII C LALR(1) grammar
08:43:34 <lscd> dcoutts: ahh, yeah; got it
08:43:38 <greenrd> surely ANSI
08:43:45 <dcoutts> err yes
08:43:49 <dcoutts> lscd, you know it ?
08:43:53 <lscd> greenrd: indeed. ltns. btw, thanks again for mentioning that paper
08:43:58 <fasta> Could anyone have a look here? I try to brute-force Hamiltonian cycles: http://pastebin.ca/194855, but I have some flaws, in it, and overall I wonder whether it's the best solution, since I would rather have the ordering coming out of it too.
08:44:09 <lscd> dcoutts: yes; i'm using it and the grammar in k&r 2nd edition as the basis of my c parser
08:44:34 <dcoutts> lscd, ah right, are you trying to build a general C parser lib ?
08:44:44 <dcoutts> lscd, are you using happy ?
08:44:45 <lscd> greenrd: i ended up presenting on it (badly, since I only had 2 days to learn a _lot_ of background material, but I think everyone learned at least a bit, which was good)
08:44:50 <lscd> dcoutts: I'm using parsec
08:45:18 <dcoutts> lscd, ah, right. So you don't have to worry so much about shift/shift conflicts.
08:45:38 <lscd> ideally, i want to handle c namespaces correctly at some point, though that's not an immediate priority; and using something that supports context-sensitive grammars should hopefully make that easier
08:45:42 <dcoutts> err, shift/reduce
08:45:46 <lscd> eh, yeah
08:45:58 <dcoutts> it's reduce/reduce that I was thinking of
08:46:10 <dcoutts> c namespaces ?
08:46:30 <lscd> dcoutts: http://www.spinellis.gr/cscout/doc/name.html
08:46:33 <lambdabot> Title: C Namespaces
08:46:38 <dcoutts> so how do you deal with the identifier / typeidentifer issues ?
08:46:48 <lscd> that would be what i mean
08:46:53 <lscd> right now, i'm not
08:47:03 <dcoutts> ah ok
08:47:11 <dcoutts> that's the really hard bit
08:47:15 <lscd> since I'm trying to get a parser going so i can do c code generation for a paper that needs to be submitted in less than a week
08:47:21 <dcoutts> ah ok
08:47:25 <lscd> yeah; i'm hoping to tackle it, but probably next week
08:47:45 <dcoutts> lscd, try parsing: typedef int A, B(A);
08:47:46 <dcoutts> :-)
08:48:03 <lscd> empty expressions give me a stack overflow still, so that'll be problematic :)
08:48:14 <dcoutts> that's not an expression.
08:48:18 <lscd> but i'll save that as a future testcase
08:48:25 <lscd> eh... i meant that in terms of the general state of my parser
08:48:32 <lscd> i don't think i've implemented the typedef rules at all yet
08:48:41 <dcoutts> for lots of tricky test cases see: http://compilers.iecc.com/comparch/article/92-01-056
08:48:45 <lambdabot> Title: Comp.compilers: Parsing C, the last word, http://tinyurl.com/kt4dt
08:48:47 <lscd> thanks!
08:49:59 <dcoutts> lscd, I might come bug you when I get stuck :-) (though after you get your paper in)
08:50:04 <lscd> btw, any tips for chasing down a backtrace or similar for when I get a stack overflow?  Some people mentioned hat, but I'm not managing to get that to work (I had to implement harch, which was straightforward, but I still can't generate hat files)
08:50:12 <lscd> dcoutts: not my paper, i'm being paid to do the boring bits :)
08:50:18 <dcoutts> ah right
08:50:22 <dcoutts> ho hum
08:50:26 <lscd> [yay for undergraduate 'research']
08:50:29 <dcoutts> heh
08:50:52 <lscd> and feel free to bug me, though i still know a quite limited amount :)
08:51:01 <greenrd> lscd: which paper did I mention to you?
08:51:28 <lscd> greenrd: verifying haskell programs using constructive type theory, where ghc core was translated to agda, i think
08:51:40 <greenrd> ah yes]
08:51:42 <dcoutts> lscd, not sure of a general approach for stack overflows, except breaking it down into smaller bits to find where it's happening
08:52:05 <lscd> dcoutts: hmm, ok; that's what i was thinking of doing, but i was hoping there was a magical easier way; thanks
08:52:23 * lscd allows herself 5 seconds of missing smalltalk's debugger ;)
08:52:56 <dcoutts> lscd, I've not tried the new GHCi debugger yet, but that may help in future
08:53:09 <lscd> dcoutts: hmm, cool; I'll check that out
08:53:26 <kpreid> greenrd: revised version: gcsecond f x = r where r = evalState (fromConstrM ((do i <- get; modify succ; return $ gmapQi i (if (i == 1) then (rcast . f . rcast) else rcast) x)) (toConstr r)) 0; rcast :: (Typeable a, Typeable b) => a -> b; rcast = fromJust . cast
08:53:39 <lscd> on the good side, with haskell, i tend to have very, very few bugs; on the downside, some of them can be a real pain to track down if a bit of ghci and quickcheck-ing don't make them obvious
08:55:25 <kpreid> greenrd: I suspect that it can be made neater with gfoldl, but I don't know how
08:55:27 <greenrd> ah, I get the idea
08:57:08 <Heffalump> I don't really follow that definition, but how do you distinguish data Foo a b = Foo a b from data Foo a b = Foo b a ?
08:59:22 <ndm> lscd: hat might help
09:00:43 <lscd> ndm: Hm. Ok, dumb question - how do I generate the .hat files all of the tools seem to expect?  The documentation links on the hat page were broken, and hat-trans myfile.hs creates a myfile.hx file, and a modified Hat/myfile.hs, but no .hat file, and trying to run the other tools on these files doesn't work
09:01:00 <ndm> lscd: windows or linux?
09:01:02 <lscd> linux
09:01:15 <ndm> lscd: hmake -hat Main
09:01:21 <ndm> then run "main arguments"
09:01:25 <ndm> that will generate a .hat file
09:01:30 <ndm> then use that .hat file for the tools
09:02:58 <ndm> lscd: put prod the hat -at- haskell.org mailing lists, if the documentation is broken email them telling them they are stupid!
09:05:38 <roconnor> @hoogle shiftR
09:05:38 <lambdabot> Data.Bits.shiftR :: Bits a => a -> Int -> a
09:05:39 <lambdabot> GHC.Exts.shiftRL# :: Word# -> Int# -> Word#
09:05:39 <lambdabot> GHC.Exts.iShiftRA# :: Int# -> Int# -> Int#
09:05:50 <roconnor> @fp Data.Bits
09:05:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
09:07:48 <roconnor> http://www.cse.unsw.edu.au/~dons/tmp/Fast.hs <-- why all the inline comments?
09:07:56 <kpreid> greenrd: it occurs to me that this would be easier done by something like 'class Pair (c a b) where make :: a -> b -> c; unmake :: c -> (a, b)' without any casts and so on. what Data.Generics does is provide more general forms, but we have to work around the type system to make it work...
09:07:57 <roconnor> won't GHC do the inlining anyways?
09:09:01 <dcoutts> roconnor, the INLINE makes ghc very keep to inline
09:09:15 <dcoutts> essentially overiding ghc's heuristic decision
09:09:20 <greenrd> Heffalump: I think gcsecond will error out (because rcast will error out) in the Foo b a case
09:09:30 <dcoutts> so yes, in most of those cases ghc probably would have anyway
09:09:55 <kpreid> greenrd, Heffalump: yes, the type assumes a particular correspondence of type arguments to constructor arguments
09:09:57 <roconnor> ok
09:10:30 <kpreid> greenrd, Heffalump: you can leave out the signature and make it more general, if you provide an explicit type for f
09:10:32 <DeeJay> @pl \x y -> compare (fst x) (fst y)
09:10:32 <lambdabot> (. fst) . compare . fst
09:11:08 <kpreid> (or if f is monomorphic)
09:12:43 <dmhouse> Huh. Why are declarations like, say, instance Show (GenTerm String) illegal?
09:12:54 <lscd> ndm: that worked, I have a .hat file now, thanks
09:13:19 <ndm> lscd: cool, if you point out what in the documentation makes that unclear, or hard to find etc, i'll report it
09:14:30 <roconnor> dmhouse: what if someone else implements Show (GenTerm a)?
09:14:31 <lscd> ndm: all of the user guides above the reference guide are broken links on http://mathematik.htwm.de/cgi-bin/dwww?type=file&location=/usr/share/doc/hat/html/index.html
09:14:34 <lambdabot> Title: Hat - the Haskell Tracer, http://tinyurl.com/zcvzg
09:14:39 <lscd> ie, dwww will could not find the file /usr/share/doc/hat/html/tutorial1.html
09:14:45 <roconnor> dmhouse: then we wouldn't know which instance to use.
09:14:59 <roconnor> dmhouse: It's very unfortunate.
09:15:08 <lscd> roconnor: can't you just choose to use the most specific?
09:15:20 <roconnor> dmhouse: and they go through a lot of hoops to get Show [Char] to work correctly
09:15:22 <ndm> lscd: why are you not going from http://haskell.org/hat ?
09:15:24 <lambdabot> Title: Hat - the Haskell Tracer
09:15:50 <lscd> ndm: because the other url turned up higher on my google search, so i had no idea that haskell.org/hat existed :)
09:15:58 <dmhouse> roconnor: ah, makes sense.
09:16:03 <ndm> lscd: hmm, scary, will email the hat list about that
09:16:05 <roconnor> lscd: knowing what is most specific might get really complicated (certainly with multi-parameter type classes).
09:16:18 <roconnor> lscd: oh wait
09:16:41 <roconnor> lscd: the problem might also be that importing a new module can totally change your program.
09:16:47 <lscd> ndm: the haskell.org version is fine; I searched for 'hat-stack haskell' without quotes, fwiw
09:17:36 <roconnor> how do I use cabal to install a package locally?
09:17:38 <lscd> roconnor: hmm, the first reason is good; as for the second, i can see why you'd want to minimize that, but i'm not 100% sure that it should never happen
09:17:43 <ndm> lscd: cheers, am just emailing the hat people about it
09:17:54 <lscd> ndm: cheers, and thanks
09:18:31 <roconnor> lscd: yeah, the first is good, but I don't see how to cause a problem without MPTC
09:19:53 <roconnor> ghc --make -O3 -Ifps-0.7/ -o Fast Fast.hs gives me
09:19:59 <roconnor> Could not find module `Data.ByteString.Base':
09:20:05 <roconnor> why doesn't -I work?
09:20:12 <dcoutts> roconnor, use -i
09:20:24 <dcoutts> -I is for cpp preprocessor
09:20:51 <roconnor> thanks
09:20:59 <roconnor> now I get Module `GHC.ForeignPtr' does not export `mallocPlainForeignPtrBytes'
09:22:42 <lscd> ndm: hm.. when I run hmake -package parsec -i.. -iHUnit-1.0 RunTests all is good, but when I throw in a -hat, I'm told "ghc-6.4.2: file `HUnit-1.0/Hat/HUnitLang.hs' does not exist"
09:23:23 <ndm> lscd: have you compiled HUnit for tracing?
09:23:40 <lscd> nope; I've been interpreting it up til now
09:23:42 <ndm> lscd: if you haven't, and you know how to, then do so, otherwise email hat -at- haskell.org, since i don't know how to do that
09:24:15 <lscd> (I don't have a global HUnit install, hence the -iHUnit-1.0 in my flags)
09:25:38 <ndm> @seen SyntaxNinja
09:25:38 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1d 15h 11m 28s ago, and .
09:25:50 <ndm> lscd: email the hat mailing list, they should know what to do
09:25:56 <ndm> galois.com is down :(
09:26:19 <DeeJay> @pl \s x -> s + (g!x)
09:26:20 <lambdabot> (. (g !)) . (+)
09:26:45 <ndm> anyone got a copy of hpc?
09:27:14 <ndm> @tell SyntaxNinja www.galois.com is down :(
09:27:14 <lambdabot> Consider it noted.
09:27:22 <lscd> ndm: will do; the error messages I'm getting trying to run hmake -hat HUnitLang.hs to get an object file are amazingly odd :)
09:27:34 <ndm> lscd: thats just hat all over :)
09:30:10 <roconnor> if I use cabal to install locally, how do I let GHC know where to find it?
09:31:51 <Igloo> If you just say --user then it should find it automatically
09:32:43 <roconnor> oh
09:32:50 <roconnor> what user directory should I use?
09:33:11 <roconnor> ghc-6.4.2: unrecognised flags: --user
09:33:17 <Igloo> To cabal, not ghc
09:33:21 <roconnor> ah
09:33:26 <Igloo> To setup, that is
09:37:07 <roconnor> Igloo: --user for configure right?
09:37:22 <roconnor> I did that, and install fails.
09:37:30 <Igloo> Give it to install too
09:38:12 <roconnor> yeah, it didn't work
09:38:19 <Igloo> Why not?
09:38:33 <roconnor> *** Exception: /usr/local/lib/fps-0.7: createDirectory: permission denied (Permission denied)
09:38:36 <DeeJay> @pl \x -> (f x, x)
09:38:36 <lambdabot> (,) =<< f
09:38:48 <Igloo> You need to tell configure to put it somewhere you can write with --prefix
09:39:05 <roconnor> so both --user and --prefix?
09:39:11 <Igloo> Yes
09:39:20 <roconnor> ok, but how will GHC find it?
09:39:31 <dolio> ?pl ap (,) f
09:39:32 <lambdabot> ap (,) f
09:39:44 <Igloo> It'll store its location in its package database
09:40:10 <roconnor> where is it's package database?
09:40:18 <dolio> ?pl ap (flip (,)) f
09:40:20 <lambdabot> ap (flip (,)) f
09:40:30 <xerox> ap . (flip (,))
09:40:47 <xerox> Hm no.
09:41:13 <dolio> ap (flip (,)) f is \x -> (f x, x), right?
09:41:16 <roconnor> ah
09:41:18 <roconnor> ghc-pkg.bin: /home/roconnor/.ghc/i386-linux-6.4.2/package.conf: getPermissions: does not exist (No such file or directory)
09:41:30 <roconnor> should I make that directory?
09:41:34 <xerox> dolio: yes
09:41:48 <dolio> I guess that's longer than (,) =<< f, though.
09:42:18 <xerox> But clearer, *I'd* say.
09:42:35 <nclife> xerox duh
09:42:39 <dolio> I guess, if you've internalized that ap is S.
09:43:44 <xerox> Of course, you can just use `first f'.
09:44:06 <dolio> first f . join (,) ?
09:44:38 <roconnor> how do I make /home/roconnor/.ghc/i386-linux-6.4.2/package.conf
09:45:09 <xerox> ?type (first :: (a -> b) -> (a,d) -> (b,d))
09:45:11 <lambdabot> forall a b d. (a -> b) -> (a, d) -> (b, d)
09:46:15 <xerox> Yeah.
09:46:32 <xerox> Or even, (f &&& id)
09:46:45 <xerox> I think I got it wrong.
09:46:48 <xerox> ?type (***)
09:46:50 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:46:52 <dolio> ?t (&&&)
09:46:54 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:46:56 <xerox> No, that's right.
09:47:01 <dolio> ?type (&&&)
09:47:03 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:47:15 <xerox> (f &&& g) x = (f x, g x)
09:47:25 <xerox> (f *** g) (x,y) = (f x, g y)
09:52:49 <lscd> ndm: well, I've sent an email to the list.
09:53:01 <ndm> lscd: i saw it, hopefully someone will be able to answer it
09:53:47 <dmhouse> I need more blogs to read.
09:54:03 <dmhouse> There are very few blogs where I'll read every single post.
09:54:34 <yip> dmhouse: i recommend that you make sure that things stay that way. blogs are a major waste of time :)
09:56:10 <dmhouse> yip: Why?
09:58:34 <roconnor> I thought my UM was slow because of memory allocation, and access, but I'm starting to think my instruction decoding is slow.
09:58:42 <metaperl> haskell doesnt have exceptions does it?
09:58:51 <roconnor> @hoogle throw
09:58:52 <lambdabot> Control.Exception.throw :: Exception -> a
09:58:53 <lambdabot> Control.Concurrent.throwTo :: ThreadId -> Exception -> IO ()
09:58:53 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
09:59:25 <metaperl> roconnor: thanks
09:59:43 <roconnor> @hoogle catch
09:59:44 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
09:59:44 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
09:59:44 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
10:00:52 <zeeeee> Cale: this is related to our discussion yesterday on exploiting laziness to actually write performant haskell: http://www.haskell.org/pipermail/haskell-cafe/2006-October/018710.html
10:00:55 <lambdabot> Title: [Haskell-cafe] Haskell performance (again)!, http://tinyurl.com/zsd6u
10:04:14 <roconnor> indexWordOffAddr
10:04:16 <roconnor> @hoole indexWordOffAddr
10:04:17 <lambdabot> No matches found
10:06:12 <lscd> dmhouse: i assume you read lambda the ultimate already?
10:11:16 <earthy> hm. compiling with wide records seems pretty expensive...
10:11:27 <earthy> (wide as in on the order of 100 fields)
10:11:29 <roconnor> @fp GHC.Ptr
10:11:30 <lambdabot> GHC.Ptr not available
10:15:13 <SamB> earthy: if you do record updates on them, yes ;-)
10:15:32 <roconnor> how do I convert beween say Int# and Int?
10:15:46 <SamB> roconnor: what are you doing?
10:16:27 <roconnor> SamB: I'm trying to slowly undo Dons craziness in his UM implementation, and see what affects the speed most?
10:16:51 <roconnor> sigh, but I don't fully appricate all his craziness
10:17:12 <edwardk> thats always a fun statement to join channel on ;)
10:18:40 <roconnor> edwardk:  I'm trying to slowly undo Dons craziness in his UM implementation, and see what affects the speed most
10:18:46 <dolio> ?type I#
10:18:48 <edwardk> ah
10:18:48 <lambdabot> Not in scope: data constructor `I#'
10:19:10 <earthy> samb: and code with records without record updates are useful how? :)
10:19:17 <earthy> s/are/is
10:19:37 <Magicman{away}> Projection functions.
10:19:42 <dolio> roconnor: I# is the constructor for Int (taking Int#) apparently.
10:19:51 <dolio> In GHC.Exts
10:19:52 <earthy> magicman: true.
10:19:56 <roconnor> oh
10:20:28 <roconnor> is Word = Word32?
10:20:49 <edwardk> Word is machine sized
10:20:53 <edwardk> Word32 is fixed
10:20:59 <earthy> but even code with projection functions needs to create records...
10:21:26 <zeeeee> hi all, are there any built-in libs for sorting?
10:21:35 <zeeeee> (if so, where are they?)
10:22:05 <zeeeee> (if not, what sorting libraries are best/most popular?)
10:22:11 <earthy> prelude?
10:22:26 <edwardk> > sort [1,2,4,3]
10:22:28 <lambdabot>  [1,2,3,4]
10:22:30 <edwardk> =)
10:22:35 <Magicman> data Foo = Foo {bar :: String, baz :: Int, Quux}
10:22:35 <Magicman> x = Foo "Hello" 1
10:22:35 <Magicman> bar x == "Hello" evaluates to true
10:22:37 <earthy> > sort [424,246,234534,46]
10:22:38 <lambdabot>  [46,246,424,234534]
10:22:39 <SamB> earthy: you *can* construct them all at once, you know
10:22:43 <Magicman> And forget the Quux
10:22:50 <SamB> zeeeee: try Data.List
10:22:54 <earthy> SamB: that is exactly what I'm doing... afaict.
10:23:00 <earthy> it still takes a shitload of time to compile
10:23:07 <SamB> hmm
10:23:12 <yip> SamB: what's up?
10:23:20 <zeeeee> that's odd, in my ghci, :i sort says "Unknown reference: `sort'"
10:23:23 <SamB> yip: not much
10:23:27 <zeeeee> er, hugs
10:23:30 <yip> SamB: cool
10:23:33 <edwardk> @hoogle sort
10:23:33 <lambdabot> List.sort :: Ord a => [a] -> [a]
10:23:34 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
10:23:34 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
10:23:35 <earthy> ofcourse, I may well have the syntax wrong. :)
10:23:41 <zeeeee> earthy: not prelude then
10:23:51 <edwardk> import Data.List
10:23:57 <SamB> er, that is, I have homework to do that has essentially nothing to do with Haskell
10:24:34 <zeeeee> is Data.List.sort quicksort?
10:24:42 <SamB> zeeeee: it sorts
10:24:43 <edwardk> > let qsort [] = []; qsort (x:xs) = [y | y <- xs, y < x] ++ [x] ++ [y | y <- xs, y >= x] in qsort [1,3,2,4]
10:24:45 <lambdabot>  [1,3,2,4]
10:24:51 <SamB> I think it is supposed to be stable
10:24:51 <edwardk> hrmm
10:24:58 <zeeeee> SamB: yeah, that's what the docs say
10:24:59 <dolio> It's mergesort, from what I've heard.
10:25:02 <ndm> zeeeee: probably merge sort
10:25:11 <ndm> zeeeee: merge sort is faster than quick sort
10:25:14 <zeeeee> edwardk: i've seen that one before :)
10:25:26 <zeeeee> ndm: that's a first...says who?
10:25:37 <zeeeee> at least, first i've heard that
10:25:37 <ndm> zeeeee: big O complexity theory
10:25:49 <ndm> quick sort is O(n log n) averge, O(n^2) worst case
10:25:51 <ValarQ> edwardk: thats a really neat sort :)
10:25:55 <ndm> merge sort is O(n log n)
10:26:11 <ndm> try sorting a reverse sorted list with quick sort, and you'll hit the O(n^2) case
10:26:16 <SamB> ndm: isn't quicksort worse for linked lists too?
10:26:37 <ndm> SamB, indeed, merge sort = linked lists, quick sort = mutable array
10:26:40 <ndm> generally
10:27:02 <SamB> so, that kinda makes that whole lazy quicksort demo kind of phony...
10:27:27 <ndm> but pretty :)
10:27:27 <SamB> hmm, I used "kind of" too many times in that sentance
10:27:38 <SamB> yeah, it is kinda pretty
10:27:47 <zeeeee> ndm: sure, but i've always read that in practice for the avg case, qsort outperforms mergesort (probably in part due to in-place implementations)
10:27:52 <edwardk> valarq: i screwed up =P
10:28:14 <ndm> zeeeee: yes, usually, but that is the inplaceness showing through
10:28:20 <dolio> Actually, if you're just sorting random lists, from what I've seen (testing random sorting one night), the sample qsort in haskell outperforms sort from Data.List.
10:28:24 <ndm> zeeeee: for linked lists, it never works
10:28:32 <zeeeee> ndm: true... haskell is doomed!
10:28:36 <SamB> dolio: oh really?
10:28:56 <dolio> Yeah, although I wasn't terribly rigorous.
10:29:02 <SamB> oh okay
10:29:07 <roconnor> > 4 `shift` 2
10:29:07 <lambdabot>  Add a type signature
10:29:10 <SamB> so no duel to the death with ndm then?
10:29:11 <roconnor> > 4 `shift` 2 ::Int
10:29:12 <lambdabot>  16
10:29:16 <roconnor> > 4 `shiftR` 2 ::Int
10:29:17 <lambdabot>  1
10:29:28 <dolio> But it was like 1.7s versus 2.5s average on whatever length list I was using at the time.
10:29:40 <ndm> the numbers don't lie
10:29:49 <monochrom> Yeah, I don't entirely like the quicksort example either.  Mergesort is more convincing.
10:29:53 <SamB> so maybe the lists were already sorted?
10:30:05 <ndm> shouldn't make too much difference
10:30:21 <dolio> If they were storted, quicksort would have been way worse.
10:30:37 <SamB> oh? quicksort doesn't like either sorted *or* reverse sorted lists?
10:30:40 <dylan> hehe, bank account spam is always funny to me -- because I have no bank account.
10:30:46 <dolio> Right.
10:30:51 <SamB> in-place implementations can at least pivot around the middle...
10:31:00 <monochrom> Quicksort comes down to how you choose pivots.
10:31:16 <monochrom> If you say "head is pivot" you're doomed.
10:31:20 <SamB> yeah ;-)
10:31:21 <edwardk> > let qsort [] = []; qsort (x:xs) = let (a,b) = partition (<x) xs in qsort a ++ [x] ++ qsort b in qsort [1,2,4,1,2,4] -- there, happy? helps to remember to recurse ;)
10:31:23 <lambdabot>  [1,1,2,2,4,4]
10:31:37 <dolio> Yeah. You could choose a random pivot for quicksort on Haskell lists, too, but that'd be a pain.
10:31:38 <SamB> well, for really random lists you'd be okay
10:31:59 <monochrom> "random lists" look good because head is a good pivot for "random lists"
10:32:06 <dolio> Right.
10:32:17 <edwardk> you usually want to use a median-of-3 selection criterion to avoid more pathological cases and then switch to another sorting technique at the leaves like the c standard library implementation does
10:32:17 <dolio> So you get close to n log n on average.
10:32:25 <edwardk> though, that doesn't implement cleanly in haskell =)
10:32:28 <SamB> but nobody uses random lists for real things ;-)
10:32:57 <SamB> edwardk: well I have over here this qsort that uses the bubble sort...
10:33:00 <monochrom> Actually, everyone uses "random" lists, but everyone has a different notion of "random".
10:33:18 <SamB> (okay, not really, but I could write it!)
10:33:25 <edwardk> if it uses it on leaves it might well be a win =)
10:33:39 <SamB> monochrom: they use semi-arbitrary, but not randomly chosen, lists
10:33:49 <SamB> usually
10:33:56 <SamB> sometimes they might be randomly chosen...
10:34:18 <SamB> but in general, no.
10:35:17 <monochrom> Perhaps most people define "random" to be "uniform".
10:35:27 <Philippa> monochrom: not true at all. Random != arbitrary
10:35:36 <Philippa> heh
10:35:48 <Philippa> most people seem to expect that it should mean some measure of uniformity
10:35:53 <dolio> I wrote an in-place quicksort for MArrays as well, but it doesn't perform particularly astoundingly.
10:36:15 <SamB> Philippa: well, it depends
10:36:15 <monochrom> Well my students have grades following a bell curve distribution, and I'll still call that random.
10:36:26 <SamB> sometimes when I say "random" I mean "that I had lying around"
10:36:52 <Philippa> or indeed "the first thing I had lying around that came to hand"
10:37:22 <matthew-_> @seen bringert_
10:37:22 <lambdabot> bringert_ is in #haskell.se and #haskell. I don't know when bringert_ last spoke.
10:37:33 <bringert_> yello
10:37:35 <matthew-_> hi
10:38:17 <matthew-_> did you mean in your email that you thought my patch would be better suited to hdbc?
10:38:38 <roconnor> It would seem that Haskell's bit manipulation is FAAAAAR slower that it ought to be.
10:38:52 <roconnor> I would expect (`shiftR` 7) to be highly optimised.
10:39:19 <bringert_> matthew-_: let me have a look
10:39:20 <Philippa> on which type or types?
10:39:53 <matthew-_> bringert_: thanks, I just didn't quite fully understand your reply
10:39:58 <SamB> roconnor: how are you building?
10:40:08 <bringert_> matthew-_: it's a patch for HBDC isn't it?
10:40:15 <roconnor> SamB ghc --make -O3 -o Fast Fast.hs
10:40:25 <SamB> roconnor: what does the C look like?
10:40:47 <bringert_> matthew-_, was it the "something like this" part that threw you off?
10:41:13 <matthew-_> bringert_: yeah
10:41:20 <SamB> roconnor: also try out -fwarn-type-defaults
10:41:36 <matthew-_> bringert_: it was a patch for the hdbc stuff in haskelldb
10:41:55 <roconnor> SamB, ghc -fwarn-type-defaults -C -O3 -o Fast Fast.hs gives no warning
10:41:59 <bringert_> matthew-_: it looks like a patch for HDBC to me
10:42:08 <SamB> roconnor: did it actually rebuild?
10:42:34 <roconnor> ghc -no-recomp -fwarn-type-defaults -C -O3 -o Fast Fast.hs gives no warning
10:42:37 <bringert_> matthew-_: "hunk ./Database/HDBC/Types.hs 53" etc
10:42:40 <SamB> okay
10:42:45 <SamB> so you have no defaulting
10:42:55 <SamB> what does the C look like?
10:43:20 <roconnor> SamB: JMP_((W_)&GHCziWord_zdwshift1_info); and EI_(GHCziWord_zdwshift1_info);
10:43:30 <matthew-_> bringert_: yeah, in haskelldb though. Um, oh. Is the hdbc dir inside haskelldb a full hdbc distribution then?
10:43:31 <SamB> roconnor: that does look bad!
10:43:31 * roconnor finds the C code hard to read
10:43:38 <matthew-_> bringert_: sorry if I'm being slow here...
10:43:44 <SamB> roconnor: yes I know
10:43:51 <bringert_> matthew-_: maybe you sent me the wrong patch?
10:43:59 <SamB> but I figured it shouldn't be *too* hard to tell if it is open-coding bitshifts or not...
10:44:15 <roconnor> SamB, there ar some zdwshift4's as well
10:44:18 <bringert_> matthew-_: there is no Database/HDBC/Types.hs in HaskellDB
10:44:44 <matthew-_> bringert_: err, haskelldb/hdbc/Database/HDBC/Types.hs
10:44:47 <SamB> roconnor: well, an open-coded bitshift would probably involve "<<" or ">>" at some point ;-)
10:45:01 <SamB> and in any case shouldn't involve JMP_
10:45:30 <dolio> roconnor: are you passing (`shiftR` 7) around sectioned like that?
10:45:32 <bringert_> matthew-_: that's not in the darcs repo: http://darcs.haskell.org/haskelldb/
10:45:34 <lambdabot> Title: Index of /haskelldb
10:45:51 <matthew-_> bringert_: Ahh, that would make a difference!
10:45:57 <bringert_> matthew-_: maybe you happend to check out the hdbc repo inside your local haskelldb repo?
10:46:56 <matthew-_> bringert: that would also explain why I got very confused about the darcs repositories...
10:47:06 <bringert> :-)
10:47:37 <roconnor> dolio: I do something like        (W# op) = w `shiftR` 28
10:48:02 <dolio> Oh okay.
10:48:02 <matthew-_> oh, I managed to pull down hdbc inside my haskelldb copy. Humm dumm de dumm...
10:48:08 <Igloo> The shift* functions allow negative arguments I think, so don't map directly to C operators
10:48:21 <roconnor> @paste
10:48:22 <lambdabot> http://paste.lisp.org/new/haskell
10:48:52 <SamB> roconnor: why don't you just use the primop?
10:49:05 <matthew-_> bringert: yeah, you're absolutel right, it's a patch for HDBC. Lol - I don't even know what project I'm writing patches for!
10:49:11 <SamB> heh
10:49:13 <bringert> :-D
10:49:33 <bringert> matthew-_: so, does my reply make more sense now? :-P
10:49:34 <SamB> matthew-_: I would have thought darcs would know where to send the patches, though!
10:49:48 <matthew-_> bringert: Perfect sense! ;)
10:49:49 <roconnor> SamB: because i don't get comipler assurance of safety.
10:50:33 <matthew-_> SamB: yeah, I sent it to the mailing list of the wrong project though
10:50:33 <matthew-_> bringert: thanks for your help. :)
10:50:54 <bringert> matthew-_: you're welcome
10:51:01 <SamB> roconnor: you don't think the primops have safe types?
10:51:32 <SamB> @type PrimopWrappers.shiftL#
10:51:34 <lambdabot> Couldn't find qualified module.
10:51:39 <SamB> hmm.
10:52:02 <SamB> @type GHC.PrimopWrappers.shiftL#
10:52:04 <lambdabot> Not in scope: `GHC.PrimopWrappers.shiftL#'
10:52:05 <roconnor> SamB: not uncheckedShiftRL#
10:52:16 <roconnor> well, it is safe
10:52:19 <roconnor> but not checked
10:52:32 <SamB> why do you want it checked?
10:52:56 <roconnor> Actually, I'm not sure what checking does.
10:52:58 <SamB> @type GHC.Prim.shiftL#
10:53:00 <lambdabot> Not in scope: `GHC.Prim.shiftL#'
10:53:23 <SamB> oh, that isn't a primop ;-)
10:53:58 <Igloo> SamB: You should use things from GHC.Exts where possible, not elsewhere in the GHC.* hierarchy
10:54:38 <SamB> Igloo: hmm
10:54:48 <roconnor> SamB: okay, so it checks the argument is non negative
10:54:57 <roconnor> so I know 7 is non negative
10:55:09 <roconnor> or 3 or whatever I'm using is non negative
10:55:14 <roconnor> so I know it is safe
10:55:30 <roconnor> but I shouldn't have to write all this unchecked non-portable stuff
10:55:48 <roconnor> GHC should (more or less) produce the code for me.
10:56:11 <roconnor> because, I would expect, it to partially evaluate (`shiftR` 7)
10:56:29 <SamB> yes...
10:56:34 <SamB> it ought to...
10:56:45 <SamB> so what happens if you don't have a W# ?
10:56:48 <lisppaste2> roconnor pasted "GHC's bad shift compilation details" at http://paste.lisp.org/display/27600
10:57:12 <roconnor> SamB what do you mean?
10:57:31 <SamB> <roconnor> dolio: I do something like        (W# op) = w `shiftR` 28
10:58:20 <roconnor> SamB it fails to compile because the there is a case (word2Int# op) latter on.
10:59:50 <araujo> anybody here knowws ho wto stop emacs of creating a file~ backup?
11:00:27 <SamB> roconnor: why are using such sharp types?
11:02:30 <roconnor> SamB: I'm starting with Don's UM code
11:02:40 <SamB> oh
11:02:48 <roconnor> I want to see if my instruction decoding is what is slow
11:02:55 <SamB> what is this part supposed to do?
11:03:11 <roconnor> so I changed his code to insert a normal looking haskell bit maniputation
11:03:23 <roconnor> and the Sandmark becomes 100% slower
11:03:40 <SamB> @where um
11:03:41 <lambdabot> I know nothing about um.
11:03:49 <SamB> @google dons haskell um
11:03:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
11:03:52 <lambdabot> Title: Haskell UM
11:03:59 <roconnor> http://www.cse.unsw.edu.au/~dons/um.html
11:04:00 <lambdabot> Title: Haskell UM
11:05:28 <ndm> are any of those UM interpretters written in pure Haskell?
11:05:33 <ndm> i.e. without GHC extensions?
11:05:42 * ndm thinks that would make a good Haskell benchmark
11:05:53 <SamB> why are you messing with the byteswapping part of the code?
11:06:00 <roconnor> ndm: my is
11:06:06 <roconnor> ndm: it's the one in last place
11:06:23 <roconnor> SamB, not byte swapping.  The eval part
11:06:25 <ndm> roconnor: its also not available :(
11:06:31 <SamB> mine uses FFI and C, but no GHC extensions afaik
11:06:43 <roconnor> ndm: yeah, if you do a darcs get on that URL you can get it
11:06:52 <roconnor> I should really fix that URL to be more helpful
11:07:00 <SamB> it also uses a horrible strategy for allocating array numbers
11:07:19 <roconnor> SamB: ?
11:07:27 <ndm> SamB, yours appears to be pretty close to being pure Haskell style thing
11:07:43 <SamB> roconnor: what are you ? ing about?
11:07:51 <ndm> oh, plus C :(
11:08:13 <roconnor> Ah, you were talking to ndm no me.
11:08:33 <ndm> roconnor: no, was checking SamB's one - i want to find one which is pure haskell
11:08:51 <ndm> roconnor: and ideally clickally available, since was just half browsing for now :)
11:09:03 <ndm> although will take a look at yours first once i am doing performance numbers
11:10:05 <lisppaste2> roconnor pasted "Pure Haskell UM" at http://paste.lisp.org/display/27601
11:10:27 <ndm> roconnor: cheers :)
11:11:11 <ndm> hmm, unboxed arrays aren't haskell 98 :(
11:11:17 <roconnor> oh right
11:11:19 <roconnor> damn
11:11:26 <ndm> might be doable though
11:11:41 <roconnor> ndm: just replace IOUArray with IOArray
11:11:43 <roconnor> :)
11:12:01 <roconnor> might add some $!'s to the writeArrays
11:12:21 <ndm> cool, will take a look at some point in the future, once the compiler i want to test it against is done :)
11:12:41 <roconnor> actually I also use multiparameter type classes with StateT
11:12:52 <roconnor> but all that stuff could be removed without too much trouble.
11:13:17 <shapr> kolmodin: Thanks for hinotify!
11:13:22 <roconnor> but yes, apparently I am far from haskell 98
11:13:39 <roconnor> SamB, so how do we fix GHC?
11:14:17 <shapr> hiya bringert_
11:14:24 <bringert_> hi shapr
11:15:53 * shapr boings quietly
11:16:07 <shapr> bringert_: Hey, you don't write much in your blog.
11:16:18 <bringert_> I have a blog?
11:16:25 <SamB> ndm: mine only uses C for the byteswapping stuff
11:16:36 <SamB> and reading from the file
11:16:38 <shapr> hope.bringert.net ?
11:16:51 <shapr> Or is that just a hope changelog?
11:16:55 <bringert_> yeah
11:16:59 <shapr> oh, ok
11:17:10 <roconnor> ndm: yeah, SamB code is way better than mine.  You should just replace his file reading code.
11:17:14 <shapr> @users
11:17:23 <roconnor> it is just constant time anyways.
11:17:27 <shapr> @hello
11:17:29 <shapr> foo
11:17:30 <lambdabot> Maybe you meant: help hylo tell
11:17:31 <lambdabot> seen module failed: IRCRaised thread killed
11:17:34 <SamB> ndm: also improve the array number allocation
11:17:54 <SamB> it needs to keep track of what array number to allocate next
11:18:13 <SamB> instead of trying them all until it finds one that isn't used
11:18:22 <shapr> Can anyone point me to more writings that treat non-strictness as self modifying code? I've only found that mentioned in Okasaki's book.
11:18:49 <SamB> shapr: huh, I always thought it was self-modifying data ;-)
11:18:50 <roconnor> shapr: that strikes me as an unlikely notion.
11:19:22 <dolio> He doesn't go into much detail about it, either.
11:20:12 <SamB> roconnor: oh, he left!
11:20:30 <shapr> I think laziness as self-modifying code makes a lot of sense.
11:20:32 <SamB> but I hope the compiler isn't done ;-)
11:20:44 <shapr> It fits into some other sensible things that Philippa has said about laziness.
11:20:47 <SamB> and I think that would be a stupid time to test UMs with it ;-)
11:21:03 <SamB> shapr: self-modifying DATA!
11:21:06 <SamB> DAT!
11:21:07 <SamB> er.
11:21:09 <SamB> DATA!
11:22:28 <shapr> I'm not convinced there's a big difference there.
11:22:31 <edwardk> shapr: you are talking about call-by-need vs. call-by-name right?
11:23:08 * shapr rereads cbn/cbn
11:23:15 <edwardk> so you modify the memothunk to point to the result not the computation, so you jump to a new destination pointer.
11:23:19 <SamB> shapr: okay, so data and code are very hard to tell apart
11:23:37 <edwardk> call-by-need = graph reduction call-by-name = lay evaluation without memo-thunks
11:24:22 <edwardk> you technically modify the code pointer in haskell's implementation, which is in a form of 'data' so it seems that it is really a form of self-modifying data.
11:24:29 <edwardk> it can be done without writing to a code segment at all
11:24:30 * roconnor doesn't see how evaluation strategy makes code self modifying
11:24:31 <SamB> so, blackholes aren't good for SMP ?
11:24:57 <SamB> edwardk: well. what do you call switch tables?
11:25:03 <edwardk> samb: thats one reason why i've been working so hard to tag thread-level vs. process-level object visibility.
11:25:04 <SamB> code or data?
11:25:05 * roconnor unless you think that replacing a piece of code by a partially evaluated version that is extensionally (and intensionally) the same is self-modification.
11:25:44 <edwardk> samb: to me it all comes down to what segment it is in. do i let the cpu execute the switch table or is it sitting in my data segment and used as a reference ;)
11:25:52 <SamB> roconnor: we are talking about the implementation strategies now ;-)
11:25:55 <shapr> Well, it is self modification in that the overall program run can be dramatically different each time you invoke it.
11:25:58 * roconnor thinks it sounds more like just-in-time compilation.
11:26:05 <SamB> edwardk: well, the CPU doesn't execute it ever
11:26:15 <shapr> JIT is also modification, yeah?
11:26:19 <edwardk> samb: then to me those turn into data..
11:26:32 <SamB> but, a stupid compiler would have used a bunch of conditional jumps instead
11:26:37 <roconnor> shapr: yeah, but that is not usually want people mean by self-modifying code.
11:26:39 <edwardk> samb: i draw my code/data line at whether or not i can jump into it ;)
11:26:57 <SamB> well I'll ask if an indirect jump counts?
11:27:04 <edwardk> samb: sure, but thats a dumb compiler writer. =)
11:27:08 <roconnor> when code is replaced by extensionally different functions, that is self modification.
11:27:08 <tennin> self-modification with invariants?
11:27:14 <roconnor> for that you will need lisp.
11:27:15 <edwardk> samb: well an indirect jump uses data that points to code
11:27:23 <shapr> Well, Template Haskell and MetaOCaml are both self modifying code, and could probably both be used for JIT.
11:27:30 <SamB> edwardk: what do you call the first argument of map?
11:27:32 <SamB> code or data?
11:27:35 <shapr> tennin: That's a better description.
11:28:07 <SamB> TH isn't SMC...
11:28:18 <SamB> it is a *macro system*
11:28:27 <edwardk> the thunk is data, the sequence of instructions it evaluates is code. in ghc you have a tag/code pointer that points to the code, and a wrapped environment that is data.
11:28:39 <edwardk> samb: so neither.
11:28:47 <SamB> edwardk: it all starts to sound fairly arbitrary after a while...
11:29:23 <roconnor> there is no spoon!
11:30:03 <edwardk> samb: well, to me it makes a big difference because i control substructural stuff on data, but i make no restriction on the use of code. so the fact that you can capture a variable in an environment makes it data to me.
11:30:06 <shapr> I think the most important point for calling laziness SMC is that the complexity of an algorithm is dependent on the inputs.
11:30:12 <shapr> sort of...
11:30:28 <SamB> shapr: hmm
11:30:34 <SamB> isn't that always true?
11:31:03 <SamB> maybe what you mean is that the complexity of an algorithm is determined by how much of its *output* is used?
11:31:04 <edwardk> to me self-modifying code kind of indicates a need for writing to the code segment and dealing with the ensuing cache problems and emulation layer difficulties =)
11:31:34 <SamB> edwardk: heh
11:31:37 <edwardk> must be an artifact of my roots, in that in the c64 days it was the only way to write fast loops ;)
11:31:51 <shapr> It's more than that, with laziness you need to understand the consumer, producer, and the call stack. (quote from Philippa)
11:32:21 <SamB> that is all well and good when you are writing the emulator, but when you are discussing nearly philosophical things...
11:35:33 <edwardk> samb: sure, but the question then i pose to you is what benefit do you gain from broadening the definition of self-modifying code? i have a concrete definition with a clean boundary. by making that fuzzier to encompass a wider definition it seems you conflate two notions. one of code paths changing and one of impact on caching techniques, etc.
11:36:15 <SamB> edwardk: yours is too machine-bound ;-)
11:36:25 <edwardk> that and the fact is that code-segment modifying SMC is gradually being removed as an option in modern operating systems, etc by enforcing W^X rules, etc.
11:36:26 <SamB> I mean, it only works relative to a machine model
11:36:27 <shapr> One important point here is that you cannot keep track of laziness by keeping track of strictness alone.
11:36:41 <Heffalump> huh?
11:36:49 <Heffalump> how is laziness not the opposite of strictness?
11:36:58 <edwardk> shapr: not sure i see that.
11:37:16 <SamB> edwardk: well, you can't just remember "okay so this isn't strict"
11:37:20 <shapr> Because strictness is local to a single function, but laziness behaviour depends on both the consumer and producer.
11:38:01 * shapr thinks about that
11:38:04 <Heffalump> no, both can be viewed either as properties of any subsystem or of a system as a whole
11:38:15 <shapr> Hm, okay, I agree.
11:39:44 <edwardk> shapr: there is very little that can be inferred in the absence of a context - both 'producer and consumer' as you put it in a decently typed language. the inference rules for strictness are about as 'wobbly' as the inference rules for GADTs. you need to propagate information forwards and backwards.
11:39:54 <roconnor> is it possible to trace through GHC's optimisations to find out why the bit shifting isn't being optimised?
11:40:08 <SamB> roconnor: well.
11:40:16 <roconnor> edwardk: wobbly types!
11:40:40 <shapr> The biggest complaint I hear about laziness is that it's not locally understandable.
11:40:59 <edwardk> to me strictness comes down to finding whether not not down one code-path you are guaranteed to need the result and that you will necessarily follow that code path. if there is any on path down which you will walk in which you won't weaken the term you can evaluate it strictly without affecting divergence.
11:41:00 <roconnor> shapr: only when it comes to allocation
11:41:36 <shapr> roconnor: Can you give more detail?
11:41:51 <roconnor> shapr: correctness properties are still more or less clear
11:41:53 <Heffalump> the problem with laziness is space leaks
11:42:06 <Heffalump> the semantics of laziness are quite obvious once you've got the hang of them
11:42:16 <roconnor> shapr: I believe even the time properties are still more or less clear
11:42:29 <roconnor> but the space properties are more unpredicable.
11:42:29 <edwardk> space leaks are what substructural types are for =)
11:42:50 <Etni3s> help please: what do i need to do in order to do something like this:
11:42:50 <Etni3s> nothingCell rs = [ filter (_,Nothing) r | r <- rs ]
11:42:50 <Etni3s> where rs is a tuple of (Int,Maybe int) and the function should return a list of tuples that contain Nothings?
11:43:10 <Etni3s> sorry, rs is a list of tuples..
11:43:30 <shapr> Etni3s: Can you make a filter function that works on one of those input tuples?
11:43:54 <Etni3s> i'm not sure
11:44:02 <Etni3s> not sure how to aproach the problem
11:44:04 <shapr> Can you make a filter function?
11:44:30 <Etni3s> what do you mean?
11:44:39 <shapr> Do you know how to use filter?
11:44:42 <edwardk> > filter (isNothing . snd) [(1,Just 1),(2 Just 3)]
11:44:43 <lambdabot>     add an instance declaration for (Num ((a2 -> Maybe a2) -> t -> (a, May...
11:44:54 <Etni3s> yes i know
11:44:59 <Etni3s> how to..
11:45:08 <shapr> edwardk: C'mon, this sounds like homework and I'm trying to make Etni3s show that he already can do it :-)
11:45:13 <edwardk> heheheh
11:45:17 <shapr> (s/he, I don't know)
11:45:37 <Etni3s> he lol
11:45:53 <shapr> Etni3s: Ok, can you show a filter function that checks for numbers smaller than five?
11:46:01 <Etni3s> i'm just not shure how i should use filter when i only want to filter by the snd?
11:46:18 <shapr> Do you know how to get pieces out of a tuple?
11:46:28 <Etni3s> no not really
11:46:37 <edwardk> @type fst
11:46:39 <edwardk> @type snd
11:46:39 <lambdabot> forall a b. (a, b) -> a
11:46:40 <lambdabot> forall b a. (a, b) -> b
11:46:42 <shapr> Do you know about pattern matching?
11:46:46 <Etni3s> yeah
11:46:49 <Etni3s> ah snd
11:46:56 * Etni3s is tired lol
11:47:03 <edwardk> @type isNothing
11:47:04 <lambdabot> forall a. Maybe a -> Bool
11:47:08 <edwardk> @type filter
11:47:08 <shapr> Have you seen pattern matching used with the constructor to pull pieces out a datatype?
11:47:09 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:47:23 <Etni3s> hmmm no i don't think so
11:47:24 <Etni3s> not sure
11:47:58 <shapr> What sort of pattern matching have you seen?
11:48:03 <edwardk> foo (Nothing) = ... ; foo (Just x) = ...
11:48:11 <edwardk> is what shapr means Etni3s
11:48:12 <roconnor> SamB, well?
11:49:11 <Etni3s> shapr: i've done like: funk (a b) = b something
11:49:13 <Etni3s> and so on
11:49:21 <Etni3s> but i think i know how to do it now
11:49:22 <SamB> what were we talking about again?
11:49:24 <Etni3s> hang on
11:49:25 <SamB> oh yeah.
11:49:41 <edwardk> my overly restrictive notion of self-modifying code ;)
11:49:53 <SamB> -ddump-inlinings ?
11:50:21 <roconnor> :)
11:52:12 <shapr> hiya Lemmih
11:53:20 <roconnor> SamB wow, lots of data
11:53:26 <ValarQ> hiya shapr
11:53:27 <SamB> roconnor: yes it is
11:53:29 <roconnor> maybe I should make a simple test case
11:53:32 <shapr> hej ValarQ
11:53:36 <SamB> yes you should ;-)
11:53:59 <ValarQ> shapr: do you have any experience in implementing quadtrees?
11:54:08 <shapr> Nope, I've only heard of them.
11:54:30 <basti_> you mean the 3d-thing?
11:54:50 <ValarQ> basti_: 3d?
11:55:08 <basti_> or, lets say, graphical/analytical
11:55:20 <basti_> theres uses out of pure graphical applications i think
11:55:25 <ValarQ> 2d vector graphics
11:55:28 <tennin> quadtrees would be 2d wouldn't they?
11:55:30 * basti_ nods
11:55:31 <tennin> 3d = octrees
11:55:33 <basti_> okay,
11:55:34 <basti_> .
11:55:36 <ValarQ> trying to implement a geometry library
11:55:46 <basti_> i think tennin is righter than i am
11:55:48 <basti_> ^^
11:56:09 <ValarQ> yeah, octrees is for 3D
11:57:03 <ValarQ> i want to speed up to work of finding intersection between a big number of arcs and lines
11:58:24 <ValarQ> that didn't make much sense
11:58:31 <ValarQ> s/to/the/
11:58:34 <Lemmih> Hey shapr.
11:58:46 <ValarQ> hello Lemmih
11:58:52 <Lemmih> shapr: I'm writing a plugin for ion (:
11:58:57 <Lemmih> Greetings ValarQ.
11:59:11 <basti_> ValarQ: yes i see
12:00:05 <ValarQ> maybe i should have a good look at how to implement trees in general in functional languages first
12:00:27 <basti_> as a data type
12:00:30 <roconnor> @hoogle getArgs
12:00:31 <lambdabot> System.getArgs :: IO [String]
12:01:12 <sylvan> ValarQ: data QuadTree = Node QuadTree QuadTree QuadTree QuadTree | Nil
12:01:19 <sylvan> :-)
12:01:23 <roconnor> SamB, there is a lot of data in my simple case.
12:01:28 <roconnor> let me try simpler
12:01:39 <sylvan> The bounding boxes can be implicit since the split strategy is consistent..
12:01:57 <ValarQ> sylvan: yeah, i have already defined that :)
12:02:08 <fasta> sylvan: you miss space to store stuff
12:02:15 <ValarQ> sylvan: yeah, thats how i planed to do
12:02:19 <sylvan> yeah I did :-)
12:02:36 <ValarQ> my concern is speed and merging trees and such
12:03:04 <fasta> ValarQ: merging trees sounds like monoidal operation mappend.
12:03:36 <fasta> ValarQ: implement your stuff algorithmically sound and as general as possible and then optimize.
12:04:01 <ValarQ> wise words from mr Fasta :)
12:04:37 <fasta> ValarQ: I have experience, with premature optimization.
12:05:04 <Etni3s> grrr
12:05:06 <Etni3s> Block> nothingCell exampleTup
12:05:06 <Etni3s> ERROR - Type error in application
12:05:06 <Etni3s> *** Expression : nothingCell exampleTup
12:05:06 <Etni3s> *** Term : exampleTup
12:05:06 <Etni3s> *** Type : [(Integer,[(Integer,Maybe Integer)])]
12:05:08 <Etni3s> *** Does not match : [(a,(Maybe b,c))]
12:05:10 <Etni3s> Block> :t nothingCell
12:05:11 <fasta> I had written a parser a few years ago that was overly slow though.
12:05:12 <Etni3s> nothingCell :: Eq a => [(b,(Maybe a,c))] -> Maybe c
12:05:14 <Etni3s> Block>
12:05:25 <Etni3s> nothingCell rs = lookup Nothing [ snd r | r <- rs ]
12:05:30 <Etni3s> ???
12:05:32 <fasta> With help from someone in this channel I optimized it with a factor of >10000. ;)
12:05:41 <roconnor> a lot of guys have trouble with premature optimization.
12:05:47 <ValarQ> fasta: :)
12:06:11 <fasta> ValarQ: the version I handed in for an assignment was _really_ slow, as you can imagine.
12:06:53 <fasta> It took 30 seconds to parse something, and another 30 to solve the problem. Trivial problems really.
12:07:22 <ValarQ> i planed on doing it so general that i can exclude the quadtree entirely (and testing all primitives for intersections)
12:07:44 <fasta> ValarQ: oh, and you did profile, did you?
12:08:15 <ValarQ> haven't gotten that far with the Haskell version yet
12:09:09 <kolmodin> shapr: you're welcome :)
12:16:09 <roconnor> the evil mangler still exists?
12:16:30 <xerox> Alive and kicking!
12:16:52 <roconnor> :(
12:17:02 <roconnor> I thought it was being replaced ... by something
12:17:05 <roconnor> maybe C--
12:17:48 <roconnor> how do I get ghc core output?
12:18:12 <SamB> the mangler hasn't much to do with your problem...
12:18:21 <mathewm> -dump-<something>
12:18:37 <roconnor> SamB, nope it doesn't I was just browsing the GHC documentation
12:19:41 <SamB> -ddump-simpl?
12:19:52 <SamB> if that doesn't work, try -fext-core
12:20:22 <SamB> and the mangler will probably be around as long as -fvia-C is
12:20:35 * roconnor thinks that changing the compiler is a much better way of speeding up his UM.
12:20:42 <SamB> heh
12:20:54 <roconnor> SamB how is c-- coming along?
12:20:54 <SamB> roconnor: you've profiled, I hope?
12:21:03 <SamB> I have no idea
12:21:03 <xerox> @seen ihope_
12:21:04 <lambdabot> I saw ihope_ leaving #haskell 2d 20h 50m 12s ago, and .
12:21:31 <SamB> the last time I looked at C--, you couldn't write code that fit the C-- spec and have it compile...
12:21:45 <SamB> (using GHC's implementation)
12:21:56 <roconnor> SamB, yes.  But comparing dons code with my modified version of his, seems to indicate that a signifigant part of my problem is with the bit shifting
12:22:07 <roconnor> and this agrees with what the profier is telling me
12:22:13 <edwardk> samb: lol
12:22:28 <roconnor> if I can interpret the profiling info properly
12:22:36 <SamB> roconnor: hmm
12:22:51 <SamB> and dons' code has >> open coded?
12:22:52 <edwardk> sometimes i wonder if the main reason for my assembler will be to get a decent haskell jit for the UM written
12:23:13 <roconnor> SamB it seems to be, see http://paste.lisp.org/display/27600
12:23:27 <mauke> ?hoogle String -> IO Fd
12:23:28 <lambdabot> No matches, try a more general search
12:23:38 <roconnor> there is a 1-1 corespondence with use of `shiftR' and with calls to JMP.
12:24:26 <SamB> roconnor: all you did there is grep...
12:24:29 <roconnor> In an ideal world there would be some Haskell 98 code that produces the same result that dons code does.
12:24:53 <roconnor> SamB, well, I looked at it. grep seems to be a easy way of illustrating the differences.
12:25:02 <roconnor> SamB is there other information you would prefer?
12:25:24 <dolio> Bah, we're using functional languages. We've evolved beyond the need for bit fiddling and sorting lists.
12:25:32 <SamB> well, it would be nice if I could see what part of what function that was from...
12:25:34 <SamB> dolio: heh
12:25:36 <SamB> right!
12:26:10 <roconnor> dolio: and we've moved beyond adding and subtracing numbers too ;)
12:26:39 <dolio> :)
12:26:45 <roconnor> SamB you mean the haskell code?
12:27:53 <SamB> roconnor: well, yeah
12:28:00 <dolio> ?fptools Data.Bits
12:28:01 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
12:28:20 <SamB> does dons use division instead of shifting?
12:28:21 <lisppaste2> roconnor pasted "relevent diffs between dons code and my modifcations." at http://paste.lisp.org/display/27607
12:29:13 <hn> how can I recursively decrease the interval for a random number generated with randomR?
12:30:32 <musasabi> evening
12:30:42 <roconnor> foo n = {do x <- choose (0,n); xs <- foo (n-1); return (x:xs)}
12:31:14 <roconnor> SamB, dons uses uncheckedShiftRL# for shifting.
12:31:23 <SamB> so I see
12:31:33 <SamB> what does the C look like for that...
12:32:56 <hn> ok, i'll try that..
12:33:05 <dolio> roconnor: Isn't the problem that w is boxed?
12:33:34 <roconnor> dolio: what do you mean?
12:33:48 <dolio> w = W# (...)
12:34:15 <dolio> So it's a boxed word.
12:34:37 <dolio> So shiftR has to pattern match against W# to operate on it, among other things.
12:34:46 <roconnor> dolio: I assume my code is taking words, boxing them, running the shift, and then unboxing it.
12:35:16 <dolio> Whereas dons' code all works with unboxed words.
12:35:25 <roconnor> SamB I'm trying to find the code in the C mess :)
12:36:28 <roconnor> dolio: hmm
12:36:52 <dolio> So to compile down to << in C, GHC would have to know to unbox your operations.
12:36:57 <dolio> At the very least.
12:37:59 <roconnor> _s52L = _s52I >> 0x1cU;
12:37:59 <roconnor> _s52O = 0x7U & _s52I;
12:38:04 <roconnor> I think that is don's code
12:38:29 <roconnor> SamB, yes I believe so
12:39:24 <dolio> And perhaps since you're explicitly boxing it, GHC is reluctant to unbox it, although I don't know if that'd matter.
12:39:31 <roconnor> dolio: wouldn't the compiled code look like, ubox, shift and box?
12:41:22 <roconnor> SamB, `>>' doesn't occur in my C code.
12:41:48 <dolio> But shift for a boxed word is a haskell function.
12:42:08 <roconnor> dolio: isn't it?
12:42:25 <roconnor> @pf Data.Word
12:42:26 <lambdabot> Maybe you meant: bf pl
12:42:29 <dolio> Hence the jump?
12:42:30 <roconnor> @fp Data.Word
12:42:30 <lambdabot> http://darcs.haskell.org/packages/base/Data/Word.hs
12:42:47 <dolio> The C for Data.Word isn't going to appear in the output, is it?
12:43:42 <roconnor> @fp GHC.Word
12:43:43 <lambdabot> GHC.Word not available
12:44:00 <dolio> This is pure, baseless speculation on my part, by the way. :)
12:45:06 <SamB> dolio: well, we'd like class methods like "shift" to be inlined...
12:45:53 <roconnor>     (W32# x#) `shift` (I# i#)
12:45:54 <roconnor>         | i# >=# 0#            = W32# (x# `shiftL32#` i#)
12:45:54 <roconnor>         | otherwise            = W32# (x# `shiftRL32#` negateInt# i#)
12:46:11 <roconnor> this is the implementation of shift
12:46:36 <roconnor> hopefully since i is known at compile time, the case analysis is optimised away
12:46:46 <roconnor> this leave us with shiftRL32#
12:47:38 <roconnor> and who know what that does.
12:47:49 <roconnor> foreign import unsafe "stg_shiftRL32"     shiftRL32#     :: Word32# -> Int# -> Word32#
12:48:09 <roconnor> I lose the trail at this point
12:48:14 <dolio> SamB: but if you explicitly say w = W# (...) ; x = <operation on w>, will it be smart enough to turn it into w' = (...) and x = <unboxed operations on w'>
12:48:17 <roconnor> but the operations are already unboxed by here
12:51:59 <shapr> Speaking of taking things as a system, I realized that my upload speed of 256kpb/s could be much faster if I used my download speed of 2Mbp/s to do something like download chunks of a dictionary. Is there already a utility to do that sort of trick?
12:53:53 <Philippa> you can't do it unless the other end already knows something about what you're sending
12:53:56 <SamB> dolio: I can't even get it to do that with this code:
12:54:05 <SamB> shiftNice x = x `shiftR` 8
12:54:05 <SamB> shiftWordNice :: Word -> Word
12:54:05 <SamB> shiftWordNice = shiftNice
12:54:24 <dolio> Hmm.
12:54:31 <SamB> it refuses to inline the worker for "shift"
12:54:57 <shapr> Philippa: Yeah, I figured the other end would build a dictionary according to what I've uploaded recently. But it seems like an obvious encoding trick, so I thought it might already be available for ssh, rsync, etc
12:55:12 <roconnor> SamB, oh thanks for helping me out!
12:55:28 <Philippa> but that won't save you bandwidth if you have the CPU power to build it yourself
12:56:02 <SamB> well, maybe it did that somewhere...
12:57:14 <shapr> Philippa: What about having both sides build the dictionary and use that? Hm, same thing. Ok, I'm convinced there's some way to increase my upload speed when my download speed is so much faster. What's that way?
12:58:04 <svref_> Is there an operator that works kind of like OR in C, where the first argument is a Maybe, and if at run-time its Nothing, then the second argument is returned?
12:58:17 <shapr> @type maybe
12:58:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:58:27 <mauke> my version of || :-)
12:58:42 <roconnor> shapr: do you have some shared correlated photons with the person you are comunicating with?
12:58:54 <mauke> a || b = if_ a a b
12:58:58 <shapr> Probably not.
12:59:02 <svref_> mauke: it takes a function, a Maybe a, and a b?
12:59:19 <shapr> svref_: That's the Data.Maybe.maybe function.
12:59:24 <mauke> what, the maybe function?
12:59:35 <mauke> @type fromMaybe
12:59:36 <lambdabot> forall a. a -> Maybe a -> a
12:59:54 <svref_> I was imagining type Maybe a -> a -> a
13:00:03 <mauke> ?type flip fromMaybe
13:00:04 <lambdabot> forall a. Maybe a -> a -> a
13:00:06 <svref_> Or possibly Maybe a -> Maybe a -> Maybe a
13:00:10 <roconnor> shapr: Hmm, I have a feeling that there is some physics argument that you will need to have information sent to you.
13:00:32 <SamB> does anyone know how to read GHC's "-ddump-inlinings"?
13:00:43 <roconnor> SamB, *l*
13:01:32 <SamB> in particular, does anyone know how to tell *why* it did or did not inline?
13:01:41 <shapr> roconnor: I'm thinking something like twenty questions or charades where the players dump lots of questions at the goal to find the answer. I know that information channels can equalize their bandwidth if they're dramatically different in size, I just don't know how.
13:02:30 <roconnor> shapr: isn't 20 questions just a specialized compression function?
13:02:41 <roconnor> well, maybe not so speciallized
13:03:20 <roconnor> who says info channels equalize their bandwidths?
13:03:33 <shapr> Lemmih got me started on this by asking me to upload 1.5Gb of unicycling videos... and it's still uploading :-(
13:04:07 <shapr> I say it after reading Shannon's "mathematical theory of communication"
13:04:15 <roconnor> shapr: if you want to upload 1.5Gb of random coin flips, then I'm not sure there is much you can do to get around it.
13:04:19 <shapr> Doesn't mean I'm right...
13:04:35 <shapr> Yeah, but that's not the problem I'm approaching.
13:04:56 <roconnor> shapr: so we need to find a difference between your videos and coin flips.
13:05:01 <shapr> There are two channels here, upload and download. Download is eight times faster than the upload.
13:05:09 <roconnor> sure
13:05:50 <shapr> So, how to exploit the fact that 8 bits can be sent to me for every 1 bit I can send back?
13:06:21 <roconnor> but if download speed doesn't help with coin flips, then we will also have trouble with movies.
13:06:41 <Philippa> the best you can do is exploit the CPU power on the other side to tell you more about the information that the other side's already got
13:06:50 <shapr> Right
13:07:16 <shapr> Assuming more than enough CPU power on both sides, the faster channel can tell the slower channel what it's already got.
13:07:34 * roconnor is confused
13:07:36 <Philippa> that'd be useful in a situation with a notable error rate
13:07:53 <shapr> This was my realization in the shower after watching unicycle videos upload for hours :-)
13:07:56 <Philippa> at least, if the error rate's also variable
13:08:00 <shapr> The question is, how to implement it?
13:08:23 <shapr> So are you suggesting a probabilistic encoding?
13:08:23 <Philippa> if the data's getting across accurately, the slower sender already knows what the other end's got
13:08:23 <roconnor> shapr: why are you uploading videos if the other side alreay has it?
13:08:37 <shapr> The other side has *something*
13:08:50 <Philippa> so, either we can build a better dictionary given twice as much horsepower, or we can use it to adjust error codes
13:08:51 <Philippa> that's it
13:09:54 <roconnor> shapr: how does what the other side has relate to what you want to send?
13:09:55 <shapr> Hm, I think there's more there.
13:10:43 <earthy> @hoogle isJust
13:10:44 <lambdabot> Maybe.isJust :: Maybe a -> Bool
13:11:01 <shapr> The other side can send me lots of information about what it has, and I can send my data in terms of what it said it has.
13:11:21 <roconnor> but is the data on the other side correlated to the data you have?
13:11:33 <roconnor> because if it is uncorrelated, then it is useless.
13:11:55 <shapr> Ok, how can you correlate the data?
13:12:18 <ValarQ> /dev/random is always correlated to my data :o)
13:12:34 <roconnor> shapr: you can't.  Ideally the data is uncorralted after you have compressed it.
13:14:21 <shapr> I'll have to go reread the paper, I'm still not convinced this won't work :-)
13:14:44 <roconnor> shapr: let me know when you find this bit about equalization of channels
13:15:24 <shapr> It's not going to be in the paper because the paper discusses single channels. Upload and download together can be taken as a single channel and that changes things.
13:16:06 <roconnor> ?
13:16:16 <roconnor> why are upload and download a single channel?
13:20:03 <glguy> Has anyone here written a solver for blackknot?
13:20:54 <roconnor> glguy: I have vaguely
13:21:20 <Heffalump> as in the ICFP puzzle?
13:21:22 <Heffalump> if so, yes
13:21:38 <glguy> roconnor: Did you figure out an efficient algorithm? or did you have to simple enumerate the different combinations?
13:21:57 <roconnor> glguy: my algorithm is poly-time
13:22:05 <roconnor> but isn't guarentteed to work
13:22:18 <Heffalump> <aol>
13:22:19 <roconnor> but it does on their problems.
13:22:23 <glguy> ah, ok
13:22:29 <glguy> <aol>?
13:22:32 <Heffalump> "me too"
13:22:36 <glguy> ah
13:22:43 <glguy> ok, cool
13:22:56 <Igloo> It feels like it would be exponential if you wanted a general solution, but that's only intuition
13:23:10 <Heffalump> I think the strategy most people used was "make a sequence to do the right permutation, then insert pairs of swaps to get the plink count right"
13:23:24 <glguy> I was thinking about writing a solution
13:23:41 <glguy> and wanted to make sure that itwas more interesting than "try everything"
13:25:01 <lightstep> i'm trying to compile yi, but i get an error
13:25:11 <lightstep> "ghc-6.4.1: unknown package:plugins"
13:25:22 <lightstep> how can i install this package on ubuntu?
13:32:28 <fasta> lightstep: probably you need hs-plugins?
13:33:16 <mauke> why does inet_ntoa return an IO String?
13:33:27 <mauke> what side effects does it have?
13:33:33 <fasta> How much LOC is the smallest correct solution to ICFP?
13:34:28 <fasta> Why aren't the programs published anyway?
13:34:31 <Heffalump> which bit of ICFP?
13:35:28 <roconnor> mauke: it changes the contents of the network buffer.
13:35:37 <mauke> what's a network buffer?
13:36:01 <roconnor> oh wait
13:36:03 <roconnor> sorry
13:36:11 <roconnor> misread your function
13:36:19 <fasta> Heffalump: well, all bits implementing a solution.
13:36:25 <roconnor> @hoogle inet_ntoa
13:36:26 <lambdabot> Network.Socket.inet_ntoa :: HostAddress -> IO String
13:36:39 <roconnor> @docs Network.Socket
13:36:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
13:36:48 <Heffalump> fasta: I doubt anyone knows.
13:37:01 <Heffalump> Many of the solutions can be computed by hand, for one hting.
13:37:18 <fasta> Heffalump: you are talking about the games?
13:37:25 <roconnor> mauke: I assume ntoa needs to do a DNS query?
13:37:28 <Heffalump> the most recent ICFP contest, yes.
13:37:48 <mauke> > inet_ntoa 42 >>= print
13:37:48 <lambdabot>  Not in scope: `inet_ntoa'
13:37:48 <mauke> "42.0.0.0
13:37:53 <fasta> Heffalump: Didn't the UM machine had to be implemented too?
13:38:00 <mauke> doesn't look like it
13:38:03 <Heffalump> fasta: yes
13:38:18 <fasta> Heffalump: doesn't seem like you are going to that "by hand"
13:38:25 <glguy> ?type accumArray
13:38:27 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
13:38:31 <Heffalump> yes, and there are other bits you'd be crazy to do by hand
13:38:40 <mauke> AFAIK inet_ntoa is simply a pretty-printer
13:38:41 <Heffalump> but your question is still not very well defined
13:39:18 <SamB> Heffalump: maybe he meant the things you must paste and whatever other programs you used?
13:39:38 <roconnor> mauke: interesting
13:39:45 <Heffalump> no doubt, but that's not a very clear definition of "minimal correct solution"
13:40:28 <fasta> Heffalump: well, the minimal is the Kolmogorov complexity
13:40:46 <roconnor> mauke: my best guess it that the C functions are blindly wrapped
13:40:52 <fasta> Heffalump: I meant just the minimal solution submitted, or a known lower bound.
13:41:11 <mauke> that sucks
13:41:34 <SamB> mauke: I heard inet_ntoa wasn't OS-thread safe
13:41:44 <Heffalump> fasta: ah, no idea
13:41:47 <SamB> maybe not even Haskell-thread safe
13:42:24 <fasta> Heffalump: ok, but you also don't know why the sources are not published? It would be interesting to see how a range of different people code.
13:42:30 <SamB> (even in the non-SMP case)
13:42:44 <Heffalump> fasta: the organisers don't generally publish people's solutions, in any year
13:42:54 <SamB> that sucks :-(
13:43:00 <Heffalump> in principle there might be copyright issues, for one thing
13:43:06 <SamB> well, they should *ASK*
13:43:15 <fasta> yes, they should
13:43:16 <Heffalump> it's quite a lot to host
13:43:20 <mauke> SamB: yeah, the C inet_ntoa() uses a static buffer
13:43:25 <Heffalump> some people do setup websites
13:43:28 <mauke> but there's no reason to replicate that in haskell
13:43:31 <fasta> They should ask Google ;)
13:43:46 <SamB> mauke: well, you can suggest it be done in pure Haskell
13:43:58 <SamB> there is/was a thread on the libraries list...
13:44:01 <roconnor> mauke: obviously you should never use this function.
13:44:01 <fasta> I believe they were building a 450,000 machine data center.
13:44:45 <mauke> and what am I supposed to use instead?
13:45:30 <SamB> you are supposed to use that and cross your fingers ;-)
13:45:49 <mauke> inet_ntop doesn't even exist in haskell
13:46:21 <roconnor> mauke: ntoa x = let a = 0xff .&. x in let b = 0xff .&. (x `shiftR` 8) ... in (show a)++"."++(show b)++"."++(show c)++"."++(show d)
13:47:53 <mauke> that's not portable, is it?
13:48:16 <roconnor> fine
13:48:18 <kolmodin> hahahahahha
13:48:27 <kolmodin> ops, wrong channel :)
13:48:46 <mauke> I don't want to use typecasts in haskell :(
13:48:48 <kolmodin> stupid internet lag
13:48:59 <SamB> mauke: you might need an ntohl in there somewhere
13:49:00 <roconnor> mauke: ntoa x = let a = x `mod` (2^8) in let b = (x `div` (2^8))`mod`(2^8) ... in (show a)++"."++(show b)++"."++(show c)++"."++(show d)
13:49:15 <SamB> or something like that
13:49:29 <roconnor> mauke: thre is no typecast
13:49:38 <SamB> mauke: you weren't complaining about the Data.Bits usage were you?
13:49:43 <xerox> There is no spoon.
13:49:53 <roconnor> type HostAddress = Word32
13:50:06 <SamB> which, IMNSHO, is idiotic
13:50:18 <mauke> SamB: how do I use ntohl in haskell?
13:50:20 <SamB> should be a newtype like PortNumber
13:50:26 <SamB> @hoogle ntohl
13:50:28 <lambdabot> No matches found
13:50:32 <SamB> hmm
13:50:36 <mauke> especially since it's a struct in C
13:50:41 <SamB> I know it was around somewhere!
13:50:45 <mauke> whose contents aren't really a number
13:50:45 <SamB> what is a struct?
13:50:47 <roconnor> of course, if Word32 is used, then you might as well use Data.Bits.
13:50:58 <mauke> SamB: a record type
13:51:13 <SamB> mauke: no, I mean, what thing is a struct in C that isn't here?
13:51:28 <mauke> the thing inet_ntoa takes
13:51:46 <roconnor> oh damn, endieness
13:51:50 <mauke> roconnor: then I need to know if I'm ... exactly
13:52:28 <mauke> it's really just four bytes. haskell exposes it as a number, so I have to know which endianness it's in so I can unmangle the bytes
13:52:32 <roconnor> unsafePerformIO . inet_ntoa
13:52:52 <roconnor> :)
13:53:03 <mauke> I'm in IO anyway
13:53:31 <SamB> roconnor: bad idea!
13:53:41 <roconnor> SamB why?
13:54:04 <SamB> apparantly it is not a good idea to apply unsafePerformIO to non-threadsafe things
13:54:15 <roconnor> oh
13:54:40 <SamB> mauke: which is why I think it should be newtyped
13:54:52 <mauke> is this thing safe to use in normal IO?
13:55:00 <mauke> there are multiple threads
13:55:15 <SamB> are they all going to be doing this?
13:55:24 <mauke> potentially, yes
13:55:44 <SamB> then probably not
13:56:08 <mauke> ok, so I can't write this program in haskell. at all.
13:56:43 <roconnor> mauke: haskell's network support sucks
13:56:52 <lightstep> mauke, you can have a inet_ntoa lock
13:56:56 <lightstep> *an
13:57:00 <mauke> haha, no thanks
13:57:18 <SamB> yes, it clearly needs work ;-)
13:57:36 <mauke> the best part about this is that I don't even need threads; the original program is a single process
13:57:49 <mauke> but haskell doesn't have select, so I'm screwed
13:57:49 <SamB> what are the threads for?
13:57:52 <SamB> oh that
14:01:18 <mauke> Foreign.Ptr is useless
14:02:58 <lightstep> why?
14:04:07 <mauke> because it can't construct ptrs
14:04:14 <musasabi> yes it can.
14:04:17 <dmead> anyone good with abstracting datatypes?
14:04:50 <mauke> musasabi: how?
14:05:30 <musasabi> mauke: ptrAtAddrInt :: Int -> Ptr a; ptrAtAddrInt plusPtr nullPtr
14:06:22 <musasabi> mauke: but why would you want to construct a Ptr in such a crude way?
14:06:54 <musasabi> and without typos "ptrAtAddrInt = plusPtr nullPtr"
14:06:54 <roconnor> @hoogle ptrAtAddrInt
14:06:55 <lambdabot> No matches found
14:07:08 <mauke> I want to get a Ptr to an existing value
14:08:09 <dmead> @hoogle abstract constructors
14:08:11 <lambdabot> Did you mean: Abstract Constructors
14:08:11 <lambdabot> Prelude.undefined :: a
14:08:11 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:08:25 <musasabi> mauke: you might look at StablePtr then (if it is a Haskell value)
14:08:29 <dmead> @hoogle Abstract Constructors
14:08:30 <lambdabot> No matches, try a more general search
14:08:34 <dmead> ...
14:08:47 <mauke> musasabi: there's no useful conversion from StablePtr to Ptr
14:09:35 <mauke> castStablePtrToPtr :: StablePtr a -> Ptr ()   Coerce a stable pointer to an address. No guarantees are made about the resulting value, except that the original stable pointer can be recovered by castPtrToStablePtr. In particular, the address may not refer to an accessible memory location and any attempt to pass it to the member functions of the class Storable leads to undefined behaviour.
14:09:41 <mauke> argh
14:09:57 <musasabi> what is wrong with that?
14:10:11 <mauke> I need peekByteOff
14:10:15 <musasabi> (or what are you wanting to do)
14:10:26 <mauke> well, I want to convert an ip address to a dotted string
14:10:50 <musasabi> with ip $ \ptr -> peek ptr
14:11:09 <mauke> huh?
14:11:24 <dmead> use a regexp
14:11:27 <dmead> ;o
14:11:40 <mauke> dmead: on what?
14:11:50 <dmead> your ip address?
14:11:55 <dmead> what form do you have it in
14:11:58 <dmead> err
14:11:58 <dmead> type
14:12:04 <musasabi> -- | Show an IP in network byte order.
14:12:04 <musasabi> decIP :: Word32 -> String
14:12:04 <musasabi> decIP x = concat [sb 0, ".", sb 8, ".", sb 16, ".", sb 24] where sb i = show (shiftR x i .&. 0xFF)
14:12:07 <musasabi> is what I use.
14:12:19 <roconnor> musasabi: that isn't endian correct
14:12:34 <integral> doesn't haskell have access to inet_ntoa?
14:12:37 <musasabi> roconnor: that is endian correct. (in the code that uses it)
14:12:40 <mauke> dmead: Word32, for retarded reasons
14:12:48 <dmead> weird
14:12:56 <mauke> integral: it simply wraps C's inet_ntoa, which isn't thread safe
14:12:59 <dmead> are you using a haskell network layer?
14:13:07 <dmead> or an external call to C
14:13:07 <mauke> Network.Socket
14:13:14 <integral> mauke: you're using multiple OS threads?
14:13:14 <dmead> hmm
14:13:14 <roconnor> musasabi: in what way is that endian correct?
14:13:16 <musasabi> roconnor: I have a layer doing the endian stuff.
14:13:24 <mauke> integral: no idea, I'm calling forkIO
14:13:26 <musasabi> roconnor: that is fine for native endian things.
14:13:43 <dmead> mauke: i'd think that use a socket class in C++ would be easier?
14:13:49 * integral can't remember any of this
14:13:55 <dmead> since all those issues are solved in C++
14:13:57 <integral> dmead: it's easy even in Perl.
14:14:08 <dmead> google for practicalsocket
14:14:10 <mauke> dmead: C++ sucks at concurrency
14:14:11 <dmead> its in C++
14:14:20 <dmead> oh?
14:14:30 <roconnor> musasabi: so this doesn't operate on a HostAddress
14:14:30 <dmead> you need multiple connections?
14:14:34 <mauke> haskell would be perfect for this if it had select
14:14:38 <mauke> dmead: yeah
14:14:42 <integral> wouldn't erlang be the good choice for concurrency?
14:15:15 <dmead> concerent connections in c++ is real easy
14:15:25 <mauke> dmead: how would you do it?
14:15:49 <lscd> integral: well, the obvious one at least
14:15:50 <dmead> well i designed a class to handle connections in java and c++
14:15:58 <dmead> one sec
14:16:11 <goltrpoat> im using the OperatorTable stuff in Parsec, and i was trying to implement c-style indexing and function call operators as postfix operators within that.  this works fine, but i want to do argument verification.  trouble is, Postfix takes a GenParser a st (Expr -> Expr), so the Expr -> Expr part a) is context unaware, b) can't throw parser errors
14:16:38 <goltrpoat> i can break it out of the OperatorTable, but that'd require that i'd break out everything else in that precedence level
14:16:43 <goltrpoat> (and above)
14:16:57 <goltrpoat> which isn't a whole lot, but it'd get a fair bit uglier.  ideas?
14:16:59 <dmead> http://taz.cs.wcupa.edu/~dmead/stuff/secretsauce/Messenger.java
14:17:03 <lambdabot> http://tinyurl.com/zs2sj
14:17:17 <dmead> look at public Object construct()
14:17:29 <musasabi> roconnor: nope. It operators on the Word32 representation of an IP address inside HAppS.Protocols.DNS (don't remember the exact details since that code was imported from older things)
14:17:44 <dmead> if you use practicalSocket in c++
14:17:52 <dmead> its a port of java network classes
14:17:52 <mauke> dmead: eww, threads
14:17:59 <dmead> o0
14:18:15 <dmead> hehe
14:18:31 <mauke> I'm not going to use threads in a non-haskell language
14:18:38 <lscd> mauke: why not?
14:18:49 <dmead> if its a solved problem, why reinvent the wheel
14:19:01 <dmead> not even a problem
14:19:01 <mauke> lscd: because I think threads suck
14:19:06 <dmead> more like a technical issue
14:19:12 <roconnor> *l* non-haskell language
14:19:23 <lscd> mauke: yes, they do - but why do you specify 'in a non-haskell language'?
14:19:51 <mauke> because I heard they don't suck in haskell, so I wanted to try it
14:19:59 <roconnor> I assume mauke means a non-STM-with-safty-language
14:20:02 <lscd> eh. why don't they suck in haskell?
14:20:09 <integral> mauke: there's STM for other languages (parrot at least, but things like Java and C++ too)
14:20:29 <roconnor> integral: but how to they enforce safety?
14:20:37 <lscd> roconnor: aka things like c++/java/etc? (does pure functional guarantee stm-with-safety?)
14:20:48 <dmead> stm?
14:20:52 <mauke> great, http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html is broken
14:20:53 <lambdabot> http://tinyurl.com/obhpz
14:20:55 <lscd> shared transactional memory
14:20:59 <mauke> software
14:21:03 <lscd> oops.
14:21:07 <dmead> ahh
14:21:12 <mauke> does anyone else think ghc's library docs suck?
14:21:17 <lscd> mauke: me!
14:21:20 <roconnor> lscd: the monad structure ensures that the only transcations are memory transactions.
14:21:24 <lscd> it took me a bit over a year to be able to read them at all
14:21:26 <mauke> most of the functions aren't even documented
14:21:27 <dmead> its certainly no java.sun.com =S
14:21:33 <SamB> mauke: you mean the haddock docs?
14:21:37 <lscd> dmead: java.sun.com isn't so great
14:21:49 <dmead> the class library docs?
14:21:50 <integral> roconnor: I suppose that with runtime type checking you can be pretty safe
14:21:53 <dmead> seemed pretty good to me
14:21:55 <SamB> mauke: name modules please?
14:22:04 <lscd> dmead: yes - they're better than the haskell docs, but they leave out quite a lot of important information
14:22:08 <dmead> ya
14:22:13 <integral> the graph ones iirc don't have any descriptions
14:22:24 <roconnor> integral: Run-time checks for IO in C++?
14:22:26 <dmead> SamB: lots of comments on functions just say "fill this in" etc
14:22:55 <goltrpoat> samb:  Text.ParserCombinators.Parsec.Prim :)
14:22:58 <lscd> roconnor: hm. sure, the monad structure could cover things in haskell; but is it possible to have a pure functional language and a non-monadic approach that would lead to not having stm?
14:22:59 <mauke> SamB: http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
14:23:01 <lambdabot> http://tinyurl.com/fkdb4
14:23:28 <lscd> dmead: i've worked with java code that's entirely javadoc'd that way (albeit not from Sun)
14:23:29 <SamB> goltrpoat: that one probably shouldn't even be *in* the haddock
14:23:29 <roconnor> lscd: ?
14:23:36 <lscd> roconnor: random curiousity
14:23:41 <Philippa> SamB: yes it should
14:23:45 <mauke> SamB: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
14:23:47 <lambdabot> http://tinyurl.com/gnsuu
14:23:59 <Philippa> as all the primitive parsers get exposed and some (like satisfy) are useful
14:24:00 <roconnor> lscd: I'm not sure I understand your question.
14:24:06 <integral> Control.Concurrent.STM.TChan, Control.Concurrent.STM.TMVar, Control.Concurrent.STM.TVar, some of Control.Parallel.Strategies, Data.Graph.Inductive.Monad
14:24:16 * SamB contends that if you are going to be messing with the internals of Parsec you ought to have the guts to look at them
14:24:32 <SamB> Philippa: the docs for those would show up somewhere else
14:24:38 <lscd> roconnor: hm. i'm basically wondering if it's possible to have a pure functional language, with threads, and without stm-with-safety
14:25:05 <Philippa> the stuff .Prim exposes isn't actually internals as such
14:25:19 <SamB> hmm
14:25:27 <SamB> anyway
14:25:31 <roconnor> lscd: yes, the original concerency libs for haskell
14:25:40 <lscd> roconnor: ok, that answers my question :)
14:25:46 <roconnor> lscd: but you get all the headaches of threading with it :)
14:25:46 <Philippa> satisfy, for example, is something pretty much every parsing lib should have or make trivially expressible
14:26:01 <Philippa> it's just "a character satisfying some predicate"
14:26:02 <roconnor> lscd: well, most of them anyways
14:26:03 <SamB> I'm sure patches would be welcome
14:26:03 <integral> I think I've also seen a few functions with two (or more) args which tell you what they are but forget to tell you which is which
14:26:25 <Philippa> the fail-and-don't-consume parser's both primitive and useful, too
14:26:27 <lscd> roconnor: i can believe that (i've had to write multi-threaded java code in the last year.... blech)
14:26:56 <mauke> why is OCaml so much better at this?
14:27:04 <roconnor> lscd: although i haven't used it much, it seems that STM is one way to make threading manageable.
14:27:05 <SamB> roconnor: MVars are so cool...
14:27:08 <SamB> mauke: at what?
14:27:11 <SamB> documentation?
14:27:19 <mauke> no, providing real functions
14:27:20 <lscd> roconnor: hmm, cool; I haven't used STM at all, to the best of my knowledge, but I keep hearing about it
14:27:22 <Philippa> also: how else are you supposed to write parsers on something other than Char?
14:27:46 <SamB> mauke: they are working in a strict model, where they have to build everything *before* people use it
14:27:48 <weitzman> The Pi calculus alas Concurrent ML doesn't have STM, since you're supposed to use channels instead of MVars
14:27:52 <weitzman> *ala
14:28:00 <integral> hmm, when all these libraries get split out from the core things in GHC, is there an index somewhere of things you can "cabal-get"?
14:28:04 <mauke> all the useful functions from C are there, most of them have the same name, the types are ocamlified, and it's documented
14:28:06 <goltrpoat> philippa:  you mean something other than () as state?
14:28:10 <Philippa> (my bad, satisfy's in .Char)
14:28:19 <roconnor> weitzman: doing only message passing seems another plausable way of dealing with threads.
14:28:20 <Philippa> goltrpoat: no, I mean parsing something other than a [Char] as input
14:28:22 <SamB> integral: the libraries are even now split from the core things in ghc's darcs repo...
14:28:29 <Philippa> for example, a [MyToken]
14:28:42 <SamB> integral: also there is hackage
14:28:46 <mauke> whereas haskell renames almost all functions for no reasons, splits them across several random modules, leaves the types C-y, and forgets to document them
14:28:59 <integral> SamB: right, but not in a released thing, so I don't really have to worry about it yet.  Plus I'm using darcs-all to fetch them with my bleedding edge GHC so I haven't noticed a difference yet
14:29:13 <roconnor> C-y?
14:29:28 <goltrpoat> philippa:  ah right
14:29:28 <roconnor> oh, you mean the Cwrapers
14:29:33 <SamB> mauke: it is a matter of resources, probably...
14:29:42 <integral> SamB: what's hackage?
14:29:52 * integral wants search.cpan.org, but s/cpan/haskell/
14:29:55 <roconnor> mauke: I guess someone thought that it was better than nothing.
14:30:16 <roconnor> mauke: I'm not certain it is better than nothing ;)
14:30:17 <mauke> dude, if you're going to import C functions as-is, why rename 90% of them?
14:30:29 <roconnor> mauke: fair point
14:30:32 <lscd> integral: yeah
14:30:33 <SamB> integral: it is a package database thingamajig
14:31:16 <Philippa> because you might be covering a general notion of an API that's also implemented similarly on other platforms but with different names
14:31:21 <integral> SamB: it appears to just be a page on the cabal wiki
14:31:44 <mauke> getpwuid -> getUserEntryForID, getsockopt -> getSocketOption, inet_ntoa -> inet_ntoa. wtf?
14:31:48 <SamB> Philippa: there is no way to explain away the lack of documentation...
14:32:30 <Philippa> SamB: agreed (though for Parsec, the docs're there and just not in the haddock)
14:32:33 <SamB> mauke: probably related to the hordes of half-monkeys and lack of guidelines?
14:32:49 <lscd> Philippa: the parsec docs are fairly good, but they have their share of brokenness
14:33:05 <goltrpoat> heh, im all for verbose names instead of 20 year old obfuscated libc names
14:33:16 <lscd> goltrpoat: creat!
14:33:22 <Philippa> lscd: yeah? I don't think I've directly encountered any examples
14:33:23 <goltrpoat> hehe
14:33:32 <integral> goltrpoat: But the old names have documentation and tutorials!  At least a translation guide would be appreciated
14:33:36 <Philippa> either that, or it's been years since I did
14:34:05 <SamB> mauke: though really you can't expect the same sorts of names for the /etc/passwd stuff and the networking stuff
14:34:12 <lscd> Philippa: aside from typos that lead to things not parsing, the permute stuff seems to be broken; at least, i tried the definition of perm0 without it typechecking last week
14:34:26 <mauke> SamB: why not?
14:34:52 <SamB> mauke: it isn't even in the same heirarchy!
14:34:53 <Philippa> ah. I never did look at the permute stuff seriously
14:34:55 <musasabi> ReadP might be easier to use than Parsec (but one needs frequently to define new more strict/greedy combinators)
14:35:21 <mauke> getAnyProcessStatus :: Bool -> Bool -> IO (Maybe (ProcessID, ProcessStatus)) ... If blk is False, then WNOHANG is set in the options for waitpid, otherwise not.
14:35:35 <mauke> great, now what's WNOHANG and waitpid?
14:36:01 <integral> which one is blk?  The first bool or the second?
14:36:20 <mauke> the first one
14:36:25 <pejo> mauke, did you bugreport any of your findings?
14:36:28 <integral> Is that actually doc'ed this time?
14:36:59 <mauke> literal>getGroupProcessStatus blk stopped pgid</literal> calls <function>waitpid</function, returning literal>Just (pid, tc)</literal>, the <literal>ProcessID</literal and literal>ProcessStatus</literal> for any process in group <literal>pgid</literal if one is available, literal>Nothing</literal> otherwise.
14:37:07 <mauke> pejo: no
14:38:04 <lscd> Philippa: eh, I ended up just requiring that the lines in a config file be in a certain fixed order; what would you do if you wanted to make the order flexible?
14:38:12 <mauke> integral: ^ from that you can infer that blk is the first arg
14:39:09 <mauke> great, another wtf in the bug tracker
14:39:36 <mauke> why do I have to log in manually?
14:40:01 <ihope> I have a sudden urge to write something tail-recursive using unboxed types.
14:40:15 <ihope> Odd, eh?
14:42:35 * ihope implements ZFC instead
14:42:45 <lscd> ihope: no odder than my struggles to use chainl1
14:42:47 <goltrpoat> lscd:  daan leijen explicitely mentions that the permutation stuff is subject to change in the docs, btw
14:43:14 <ihope> @hoogle chainl1
14:43:15 <lambdabot> Text.ParserCombinators.ReadP.chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
14:43:16 <lambdabot> Text.ParserCombinators.Parsec.Combinator.chainl1 :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> GenParser tok st a
14:43:17 <lscd> goltrpoat: yeah, i know; but the current docs say something which, with the current parsec, doesn't work
14:43:27 <ihope> What?
14:43:50 <lscd> ihope:i have the type signature; it's the  GenParser tok st (a -> a -> a) which seems to be throwing me, though i'm looking at the example in the doc and i'll play around until it makes sense
14:43:50 <Philippa> lscd: I'd treat dispatching the lines as a semantic pass on top of the parsed data
14:43:59 <Philippa> (re lines in a config file)
14:44:14 <goltrpoat> but.. to make the order flexible -- what's wrong with configLine :: MyParser Config  /  configLine = configOptionA <|> configOptionB <|> ... <|> configOptionE   ...  config = many configLine ?
14:44:22 <ihope> Parses a binary operator?
14:44:25 <roconnor> readP is a breadth first search?
14:44:29 <lscd> Philippa: hmm. yeah, i thought about that
14:44:55 <Philippa> it's probably faster than doing it in the parser, too
14:44:55 <lscd> goltrpoat: well, it delays finding errors due to missing or duplicate lines til a later processing stage, though that's not a big deal
14:45:03 <ihope> Something that parses a, then something that parses a binary operator on a, and you get a.
14:45:10 <lscd> Philippa: eh, it's a 4-line config file for a toy
14:45:22 <Philippa> then deriving Read is your friend
14:45:51 <lscd> hmm. good suggestion for next time i have something like that
14:46:15 <ihope> @hoogle [a] -> [[a]]
14:46:16 <lambdabot> List.inits :: [a] -> [[a]]
14:46:16 <lambdabot> List.tails :: [a] -> [[a]]
14:46:16 <lambdabot> List.group :: Eq a => [a] -> [[a]]
14:46:22 <ihope> Eh.
14:46:29 <ihope> No "subsets" function?
14:47:18 <mauke> @hoogle power
14:47:19 <lambdabot> No matches found
14:47:22 <goltrpoat> lscd:  hmm..  maintain a list or map of config options already set, use that as parser state.. rewrite configOptionA etc as checkedConfigOption opt opt_p = do { s <- getState; {- verify that opt isn't set -}; opt_p; }
14:47:40 <goltrpoat> lscd:  then check for missing options in the config parser
14:48:14 <roconnor> ihope: p(h:t)=p t++[h:x|x<-p t];p x=[x]
14:48:27 <roconnor> ihope: p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take (2^n)$p l}
14:50:13 <lscd> goltrpoat: hmm, cool; i haven't played with parser state yet, but i'm planning to soon
14:50:32 <ihope> Oh, how many values does this have: data Big = Base | Next Big | Meta (Big -> Big)
14:50:37 <roconnor> > let p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take(2^n)$p l} in p [0,1,2,3]
14:50:39 <lambdabot>  [[],[0],[1],[1,0],[2],[2,0],[2,1],[2,1,0],[3],[3,0],[3,1],[3,1,0],[3,2],[3,2...
14:50:51 <roconnor> > let p l=[]:do{(n,x)<-zip[0..]l;map(x:)$take(2^n)$p l} in p [0..]
14:50:52 <lambdabot>  [[],[0],[1],[1,0],[2],[2,0],[2,1],[2,1,0],[3],[3,0],[3,1],[3,1,0],[3,2],[3,2...
14:51:05 <lightstep> ihope, infinity?
14:51:10 <xerox> roconnor: nice.
14:51:23 <ihope> lightstep: there are lots of infinite numbers.
14:51:42 <ihope> I'm looking for a cardinal number, and infinity just happens to not be one.
14:51:46 <xerox> None of whom has computational well-defined meaning? :)
14:52:10 <roconnor> ihope: countable
14:52:16 <lightstep> ihope, how do you define equality?
14:52:25 <ihope> > let p (x:xs) = xs ++ map (x:) (p xs); p [] = [[]] in p [1,2,3]
14:52:26 <lambdabot>    Occurs check: cannot construct the infinite type: b = [b]
14:52:26 <lambdabot>    Expected...
14:52:30 <ihope> Oip.
14:52:31 <roconnor> ihope: depending on your definition of ->
14:52:46 <goltrpoat> unary functions are countable? :)
14:52:49 <ihope> roconnor: what if it's all functions?
14:52:52 <ihope> lightstep: you don't.
14:53:06 <ihope> ...You mean on Big, or on cardinals?
14:53:24 <goltrpoat> oh wait, on Big.  sure, Big is countable
14:53:40 <ihope> Is Integer -> Integer countable?
14:53:47 <ihope> I think not.
14:53:55 <lightstep> it contains all the functions from the naturals to the naturals
14:54:00 <earthy> um.
14:54:05 <Magicman> No, not countable.
14:54:08 <earthy> Integer -> Integer suffices to represent the reals
14:54:15 <earthy> so, definitely not countable.
14:54:23 <ihope> Yes, Big is pretty big.
14:54:31 <earthy> pretty darn freaking big
14:54:43 <lightstep> but you can't algorithmically compare these values
14:55:07 <earthy> hm...
14:55:10 <roconnor> ihope: the will be larger than any cardinal
14:55:11 <ihope> You'd need to be able to enumerate through them to compare them, no?
14:55:25 <roconnor> ihope: but -> as all functions isn't a very reasonable interpretation.
14:55:31 <ihope> It isn't?
14:55:36 <earthy> nope.
14:55:38 <Philippa> it's continuous functions
14:55:39 <SamB> roconnor: than why are you using that type?
14:55:41 <goltrpoat> earthy:  what's the surjection from Integer->Integer to R?
14:55:53 <SamB> WTH is a continuous function on Integers?
14:56:09 <ihope> goltrpoat: you could use Fibonacci codes or some such.
14:56:12 <Philippa> SamB: have a CPO...
14:56:20 <roconnor> SamB: integers have a discrete topology, so all functions are continuous
14:56:22 <earthy> goltrpoat: map it to decimal expansions
14:56:24 <Philippa> (rather than just a set)
14:56:26 <ihope> That'll code a sequence of Integers as a sequence of bits, more or less.
14:56:33 <SamB> roconnor: how does that help then?
14:56:37 <earthy> but, in Big, you don't have Integer, necessarily
14:56:51 <roconnor> SamB (integer -> integer) -> Integer
14:57:02 <ihope> Don't have it, necessarily?
14:57:07 <ihope> You have all the naturals, no?
14:57:08 <roconnor> the topology of (integer -> integer) is not discrete.
14:57:20 <earthy> as in, every element of Meta (Big -> Big) relates finite bigs...
14:57:29 <lightstep> now i think hs-plugins is really not installable on ubuntu
14:57:29 <earthy> but, you have all finite bigs... hmmmm...
14:57:32 <earthy> interesting. :)
14:58:18 <earthy> anyway, bedtime
14:58:32 <ihope> Well, I guess Big is uncardinally large, yeah.
14:58:36 <ihope> That *is* big.
14:59:03 <lightstep> it's sort of like oleg's lazy cons tree
14:59:15 <dmead> gentoo is much more haskell friendly
14:59:35 <roconnor> ihope: that is the type of data structure that screws up GHC's inliner :)
14:59:37 <SamB> lightstep: what mean you, "not installable"?
15:00:01 <ihope> roconnor: does whatnow?
15:00:20 <lightstep> samB, it depends on ghc6>=6.4.2, and cabal depends on ghc6<6.4.2
15:00:36 <roconnor> ihope: http://r6.livejournal.com/95963.html
15:00:38 <lambdabot> Title: r6: Y Combinator in Haskell
15:00:40 <lightstep> so it's installable, but only if you want to lose cabal, opengl, &c
15:00:57 <SamB> so why are you not just building it yourself?
15:01:00 <roconnor> > newtype Mu a = Roll { unroll :: Mu a -> a }
15:01:00 <lambdabot>  Parse error
15:01:02 * SamB always does that
15:01:17 <roconnor> fix f = (\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x))) goes into an infinite inlining loop
15:01:20 <roconnor> with GHC
15:01:26 <SamB> eeek
15:01:35 <goltrpoat> i don't really follow..  if you throw out duplicate functions (ones that take the same values to the same values), and assume total functions, then |Z->Z| = |Z^2| = |Z|, no?
15:02:08 <dan_> ;o
15:02:16 <SamB> wouldn't that be |Z->Z| = |{Z^2}| ?
15:02:20 <roconnor> Philippa: if you use a continuous functions intepretation of ->, then the cardinaly never exceeds the continuum?
15:02:45 <roconnor> Z->Z = Z^z
15:02:52 <lightstep> SamB, i don't like to compile my own packages, if they are precompiles
15:02:56 <roconnor> A->B = B^A
15:03:07 <goltrpoat> roconnor:  i guess that's what i'm asking, why it's P(Z)
15:03:14 <roconnor> |(Z,Z)| = |{Z^2}|
15:03:18 <goltrpoat> i did say total functions
15:03:32 <goltrpoat> so the subsets thing doesn't make sense
15:03:41 <lscd> weeeeeeeeeeeeeeeeeeeee
15:04:00 <ihope> Why assume total functions? :-)
15:04:02 <lscd> (a basic test of parsing multiplicative expressions just worked.)
15:04:03 <roconnor> goltrpoat: well 2^Z <= Z^Z  clearly, right?
15:04:11 <goltrpoat> ihope:  because otherwise my assumption breaks down horribly?
15:04:20 <ihope> Oh.
15:04:24 <goltrpoat> :)
15:04:31 <goltrpoat> roconnor:  sure
15:04:51 <roconnor> so all we need to do now is show Z^Z <= 2^Z.
15:05:07 <Magicman> I have proof of that somewhere here.
15:06:13 <mauke> ok, I "solved" it by using fork instead of threading
15:06:15 <lightstep> 2^Z=2^(Z*Z)=(2^Z)^Z=C^Z>=Z^Z
15:06:37 <roconnor> lightstep: nice
15:06:40 <lightstep> where Z is aleph-null and C is the continuum
15:06:46 <goltrpoat> roconnor:  no, i'm clear on that bit
15:07:13 <dibblego> http://haskell.org/haskellwiki/Introduction_to_QuickCheck "its nice that we can use the QuickCheck testing framework directly from the Haskell prompt" -- yet "<interactive>:1:0: Not in scope: `quickCheck'"
15:07:16 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki, http://tinyurl.com/fx5ob
15:07:46 <goltrpoat> oh crap.  i see why it's not ZxZ though.
15:07:56 <roconnor> dibblego: :m + Testing.QuickCheck
15:08:02 <roconnor> @hoogle QuickCheck
15:08:03 <lambdabot> Test.QuickCheck :: module
15:08:03 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
15:08:04 <goltrpoat> had to work through it with automorphisms on {1,2,3}
15:08:06 <lightstep> dibblego, type ":m + Debug.QuickCheck", then try
15:08:11 <dibblego> oh thanks
15:08:12 <roconnor> dibblego: :m + Test.QuickCheck
15:09:02 <lightstep> hmm, three different module names?
15:10:01 <SamB> Test.QuickCheck is the new one
15:10:10 <roconnor> lightstep: my first guess was wrong.  I should have looked first
15:10:12 <SamB> Debug.QuickCheck is deprecated
15:12:22 <roconnor> where is shiftRL# defined?
15:14:21 <ihope> @hoogle shiftRL#
15:14:22 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
15:14:27 <ihope> Oiph.
15:14:37 <roconnor> ihope: it is extern
15:14:49 <ihope> @index shiftRL#
15:14:50 <lambdabot> GHC.Exts
15:14:56 <ihope> roconnor: it's what?
15:14:58 <roconnor> http://www.haskell.org/ghc/dist/current/docs/libraries/base/GHC-Exts.html#t%3AWord
15:14:59 * nisse|16 needs help with lambdabot
15:15:01 <lambdabot> http://tinyurl.com/hmzzk
15:15:08 <nisse|16> it won't connect
15:15:09 <SamB> roconnor: it is in GHC.Base
15:15:42 <ihope> It doesn't look like something that would be defined in Haskell.
15:15:45 <SamB> nisse|16: --online?
15:15:56 <dibblego> when you use quickCheck, is it intended that you put together all of these properties into one function?
15:15:57 <SamB> ihope: actually it is
15:16:06 <ihope> Like unsafeCoerce#?
15:16:13 <nisse|16> it starts connecting, but freezes
15:16:13 <SamB> in terms of uncheckedShiftRL#
15:16:16 <roconnor> @fp GHC.Base
15:16:16 <lambdabot> GHC.Base not available
15:16:19 <nisse|16> NOTICE: ["AUTH",":*** Looking up your hostname..."]
15:16:19 <nisse|16> NOTICE: ["AUTH",":*** Found your hostname, cached"]
15:16:19 <nisse|16> NOTICE: ["AUTH",":*** Checking Ident"]
15:16:19 <nisse|16> NOTICE: ["AUTH",":*** No Ident response"]
15:16:19 <nisse|16> BOUNCE!
15:16:20 <nisse|16> BOUNCE!
15:16:22 <nisse|16> NOTICE: ["botname",":*** Notice -- motd was last changed at 28/3/2005 19:54"]
15:16:33 <SamB> roconnor: what are you looking for?
15:16:56 <nisse|16> after that it just stops
15:17:01 <ihope> Bounce?
15:17:11 <ihope> What's that mean, exactly?
15:17:13 <nisse|16> dunno. never seen it before
15:17:21 <nisse|16> trying to connect to efnet btw..
15:17:37 <dibblego> dons mentioned yesterday that it has problems with efnet
15:17:41 <dibblego> (dons is the author)
15:17:48 <ihope> Use one of those fancy sniffer thingies?
15:18:03 <nisse|16> hmm
15:18:09 <nisse|16> that sux
15:18:13 <SamB> WTH did they rename tethereal to?
15:18:25 <roconnor> SamB, http://darcs.haskell.org/packages/base/GHC/Word.hs, but for GHC.Base
15:18:28 <lambdabot> http://tinyurl.com/rofdg
15:18:39 <dibblego> nisse|16, you can always fix it yourself :) but otherwise, yes that sucks
15:18:59 <nisse|16> lol i'm not anywhere near that good
15:18:59 <ihope> Oh, uh, what happened to those .
15:18:59 <SamB> http://darcs.haskell.org/packages/base/GHC/Base.lhs
15:19:02 <lambdabot> http://tinyurl.com/zcmat
15:19:12 <SamB> roconnor: but what did you want to see?
15:19:13 <roconnor> oh wow
15:19:13 <ihope> ...to those arbitrary-precision non-negative integers?
15:19:36 <ihope> How do the plain old regular ones work, anyway?
15:19:51 <SamB> ihope: what do you mean?
15:20:34 <roconnor> SamB, oops, I was looking for shiftRL32
15:20:36 <roconnor> SamB, oops, I was looking for shiftRL32#
15:20:50 <SamB> that one is probably in GHC.Word
15:20:54 <roconnor> @index shiftRL32#
15:20:55 <lambdabot> bzzt
15:21:02 <roconnor> foreign import unsafe "stg_shiftRL32"     shiftRL32#     :: Word32# -> Int# -> Word32#
15:21:04 <dibblego> can a module be made of more than one source file?
15:21:18 <SamB> but only for architectures with < 32 bit wordsize, apparantly...
15:21:19 <ihope> SamB: how does Integer work?
15:21:25 <SamB> whatever that means
15:21:26 <ihope> dibblego: why?
15:21:32 <goltrpoat> work?
15:21:42 <dibblego> ihope, trying to figure out the best way to organise quickCheck functions
15:21:42 <SamB> ihope: well GHC afaik still uses GMP
15:22:24 <SamB> dibblego: you can re-export entire modules...
15:22:27 <ihope> dibblego: well, you can have two modules importing each other... I think.
15:22:28 <goltrpoat> dibblego:  module Whole (module PartA, module PartB) where import PartA import PartB ?
15:22:44 <SamB> ihope: that is iffy
15:22:59 <ihope> SamB: is there a nice specification for GMP somewhere online?
15:23:13 <dibblego> what's the convention for organising quickCheck functions?
15:23:15 <goltrpoat> how DO you break circular dependencies anyway
15:23:23 <goltrpoat> other than moving stuff around, i mean
15:23:41 <SamB> ihope: what do you mean? it is a library.
15:23:57 <ihope> A library?
15:24:00 <ihope> Hmm.
15:24:19 <roconnor> @hoogle stg_shiftRL32
15:24:20 <lambdabot> No matches found
15:24:20 <ihope> I don't suppose there's a GMP non-negative-integer thing.
15:24:22 <roconnor> :)
15:24:22 <SamB> goltrpoat: well, GHC has these "hs-boot" files
15:24:29 <mauke> @hoogle a -> [a] -> [[a]]
15:24:30 <lambdabot> No matches, try a more general search
15:24:34 <mauke> :(
15:24:39 <SamB> and these {-# SOURCE #-} pragmas that you put in the imports
15:24:41 <ihope> mauke: what're you looking for?
15:24:46 <mauke> string split
15:24:57 <ihope> What do you want it to do?
15:25:23 <goltrpoat> hmm.. no luck with http://www.google.com/search?hl=en&q=site%3Ahttp%3A%2F%2Fhaskell.org%2Fhaskellwiki%2FGHC+%22hs-boot%22&btnG=Google+Search
15:25:25 <lambdabot> Title: site:http://haskell.org/haskellwiki/GHC "hs-boot" - Google Search, http://tinyurl.com/o7lwb
15:25:30 <ihope> @hoogle splitAt
15:25:31 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
15:25:31 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
15:25:31 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
15:25:36 <ihope> @hoogle unfoldr
15:25:37 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
15:25:37 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:25:39 <mauke> given a separator and a string, return a list of the substrings between separators
15:25:48 <ihope> @hoogle glue
15:25:49 <lambdabot> No matches found
15:25:54 <ihope> Hmm...
15:26:15 <mauke> like a generic 'words'
15:26:32 <goltrpoat> speaking of GMP though, someone should implement shewchuk's adaptive precision fp stuff in haskell
15:26:49 <ihope> Wasn't there some fancy website-thingy saying what all these functions did?
15:27:43 <mauke> oops, got to go
15:27:45 <mauke> good night :-)
15:30:28 <ihope> Data constructors are strict on their unboxed arguments, right?
15:30:38 <dibblego> do most people put quickCheck functions in the same module as the functions that they want to check? if so, in the same source file?
15:31:09 <SamB> dibblego: depends, I suppose
15:31:11 <monochrom> Yes ihope
15:31:14 <ihope> dibblego: just stick a {-------------------} in the middle of your course file somewhere :-)
15:31:26 <ihope> Or -----------------------, if you don't like braces.
15:31:46 * ihope nods in monochrom's general direction
15:31:52 <SamB> some people like to not export the quickcheck properties
15:32:07 <dibblego> why are they called properties and not functions?
15:32:25 <ihope> So what are all the operations a person might reasonably want to perform on a nonnegative integer type?
15:32:48 <dibblego> ihope, !!
15:33:00 <ihope> That's everything?
15:33:08 <dibblego> there are many
15:33:16 <ihope> Oh.
15:33:32 <goltrpoat> implement Bits, Enum, Eq, Integral, Ord, Num, Random, Data, Show, and probably other stuff
15:33:41 <ihope> Should I start with everything you can do with Integer?
15:33:47 <musasabi> ihope: +, *, =, < at least.
15:33:53 <musasabi> no.
15:34:15 <monochrom> Everything is not a function.
15:34:16 <dibblego> consider all that Java code that contains: "if(someX < 0){throw new SomeException"
15:34:28 <roconnor> ah, I was reading the commented out bits of Word32
15:34:29 <ihope> Can I pattern match on unboxed numbers?
15:34:36 <musasabi> monochrom: everything *is* a mapping.
15:34:50 <roconnor>     (W32# x#) `shift` (I# i#)
15:34:50 <roconnor>         | i# >=# 0#            = W32# (narrow32Word# (x# `shiftL#` i#))
15:34:50 <roconnor>         | otherwise            = W32# (x# `shiftRL#` negateInt# i#)
15:34:50 <musasabi> ihope: yes.
15:34:59 <roconnor> this is the definition of shift
15:35:06 <roconnor> which call shiftRL
15:35:08 <ihope> That's nice.
15:35:21 <roconnor> which calls uncheckedShiftRL
15:35:25 <ihope> ...Wait, are there any Word# literals?
15:35:36 <musasabi> yes.
15:35:42 <SamB> musasabi: what do they look like?
15:35:43 <JohnMeacham> write me poetry in haskell.
15:35:56 <SamB> roconnor: what are you doing?
15:36:06 <ihope> {- Insert poetry here. -}
15:36:12 <JohnMeacham> excellent.
15:36:21 <roconnor> SamB, still trying to understand why bit shifting isn't inlined.
15:36:24 <ihope> So yeah, what's a Word# literal look like?
15:36:32 <SamB> I have already implemented shiftL and shiftR directly for {Int,Word}{,32,64}
15:36:49 * musasabi was wrong I think :-(
15:37:14 <musasabi> just cast them and then use that.
15:37:21 <SamB> it might even compile on 64-bit architectures
15:37:29 <ihope> What's the cast from Word# to Int#?
15:37:48 <SamB> int2Word#
15:37:50 <ihope> (The cast is one-to-one, right?)
15:37:53 <SamB> er.
15:38:10 <roconnor> ihope: I believe so
15:38:16 <SamB> thats the one you want, not the one you asked for ;-)
15:38:20 <roconnor> word2Int#
15:39:25 <SamB> so what should I do with this patch?
15:42:00 <phr-newbie> @hoogle just
15:42:00 <lambdabot> Prelude.Just :: a -> Maybe a
15:42:01 <lambdabot> Maybe.fromJust :: Maybe a -> a
15:42:01 <lambdabot> Maybe.isJust :: Maybe a -> Bool
15:42:09 <dibblego> I guess fps has some code that sets a convention for using quickCheck
15:42:12 <phr-newbie> @hoogle maybe
15:42:13 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
15:42:13 <lambdabot> Maybe :: module
15:42:13 <lambdabot> Prelude.Maybe :: data Maybe a
15:42:14 <dibblego> ?where fp
15:42:15 <lambdabot> I know nothing about fp.
15:42:16 <dibblego> ?where fps
15:42:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
15:42:29 <roconnor> SamB: patch?
15:43:09 <dibblego> dons, FYI, lambdabot times out the ping when I am at home, but not at work - the firewall restrictions are much the same - go figure?
15:43:41 <SamB> roconnor: hmm, it doesn't seem to help :-(
15:43:56 <dons> dibblego: hmm.
15:44:39 <dibblego> dons, both are direct outbound connections (no proxies)
15:47:45 <roconnor> SamB: what patch doesn't help?
15:48:23 <roconnor> @hoogle randomIO
15:48:24 <lambdabot> Random.randomIO :: Random a => IO a
15:48:45 <SamB> this one where I actually implement shiftL and shiftR rather than allow the defaults?
15:48:57 <roconnor> oh
15:53:06 <dibblego> why "packed" in fast packed string? it seems to imply compression or something, when really it's just using native code isn't it?
15:53:14 <ihope> Will int2Word# 0# be turned into the corresponding Word# at compiletime?
15:54:19 <dons> hmm? packed? native code? hmm?
15:54:27 <dons> packed describes the data structure
15:54:31 <dons> (compared with [Char])
15:54:42 <dibblego> what is packed about it then?
15:54:54 <dibblego> contiguous memory?
15:54:58 <dons> its using a raw byte array on the heap
15:55:01 <dons> right
15:55:04 <dibblego> ok
15:55:10 <ihope> All the bytes are snuggled up to each other in memory, I guess.
15:55:16 <dibblego> lol
15:55:28 <ihope> Now, what's equality on words?
15:55:36 <ihope> Or, even better, checking a word for zeroness?
15:55:37 <dons> eqWord#, iirc
15:55:43 <dons> read ghc/compiler/prelude/primops.txt.pp
15:55:47 <roconnor> @index (>=#)
15:55:47 <lambdabot> bzzt
15:56:24 <ThreeQ> in the type "Cont r a", what does the r represent?
15:56:32 * ThreeQ is trying to understand the continuation monad
15:56:34 <ihope> ThreeQ: the eventual result type.
15:56:42 <ThreeQ> then what is a?
15:56:51 <ihope> That's the immediate result type.
15:56:53 <dibblego> in fps/tests there are lots of source files that just output to standard output - are these use for manual visual verification?
15:57:03 <ihope> You can access the a only by turning it into an r.
15:57:26 <dons> dibblego: right.
15:57:28 <ThreeQ> hmm
15:57:34 <ihope> Cont r a = (a -> r) -> r
15:57:59 <ihope> @docs GHC.Base
15:57:59 <lambdabot> GHC.Base not available
15:58:10 <ThreeQ> oh, that makes sense
15:58:15 <ihope> There are really too many whatchamacallits.
15:58:24 <ihope> GHC.Base and GHC.Prim, and... um...
15:58:27 <ihope> @docs GHC.Prim
15:58:28 <lambdabot> GHC.Prim not available
15:58:34 <ihope> Well, I'm sure there are more.
15:58:39 <dons> ?docs Data.List
15:58:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:58:43 <ThreeQ> it takes the continuation and returns the eventual result
15:58:45 <dons> then cd ../GHC
15:58:48 <roconnor> hmm, where is (>=#) defined?
15:59:03 <dibblego> one source file (tests/zipwith.hs) refers to "bigdata" yet there is no such file (but there is "data")
15:59:14 <dons> roconnor: ghc/compiler/prelude/primops.txt.pp
15:59:40 <roconnor> dons: how do I import it so I can use it?
15:59:43 <dons> primop   WordGtOp   "gtWord#"   Compare   Word# -> Word# -> Bool
15:59:44 <dons> primop   WordGeOp   "geWord#"   Compare   Word# -> Word# -> Bool
15:59:44 <dons> primop   WordEqOp   "eqWord#"   Compare   Word# -> Word# -> Bool
15:59:44 <dons> primop   WordNeOp   "neWord#"   Compare   Word# -> Word# -> Bool
15:59:49 <roconnor> i've done import GHC.Prim
15:59:51 <dons> GHC.Prim
16:00:19 <dibblego> dons, is that a mistake in zipwith.hs? s/bigdata/data ?
16:00:26 <Igloo> You should use GHC.Exts where possible, not the rest of GHC.*
16:00:58 <roconnor> Igloo: I'm just writing some test code
16:01:14 <Igloo> (well, really you shouldn't use that either, but write code that GHC can optimise, and files bugs or send patches if it can't!)
16:01:54 <roconnor> Igloo: I'm trying to write test code to make a bug about an optimisation that I think GHC should be doing.
16:02:01 <roconnor> make a bug report ...
16:02:49 <ihope> Igloo: so how am I supposed to get at all these juicy unboxed types?
16:02:53 <lisppaste2> roconnor pasted "Why do I get a parse error?" at http://paste.lisp.org/display/27615
16:03:31 <Igloo> ihope: Ideally by writing code with boxed types and having GHC unbox them, or if that's not possible then by using GHC.Exts
16:03:58 <ihope> Why have GHC unbox them when I can unbox them myself?
16:04:25 <Igloo> So that your code is portable across impls and to protect yourself against changes in GHC's internals
16:04:30 <roconnor> ihope: because you gain portability.
16:04:32 <Igloo> Also, to make your code prettier
16:04:59 <ihope> Hmm...
16:05:11 <ihope> What if I don't want portability? :-P
16:05:28 <ihope> Are ByteStrings portable?
16:05:37 <dons> yeah
16:06:22 <ihope> Uhg
16:06:33 <ihope> Erm.
16:06:40 <ihope> s/Uhg/Oh./
16:06:43 <Zr40> what does this # mean, in Word# for example?
16:06:51 <ihope> My keyboard likes to switch layouts, see.
16:06:57 <musasabi> Zr40: it is just a fancy character.
16:06:59 <ihope> Zr40: it's the unboxed version of Word.
16:07:15 <musasabi> Zr40: used to mark extensions that are internal to a compiler.
16:07:24 <musasabi> e.g. unsafeCoerce#
16:07:40 <musasabi> (and unboxed things)
16:07:44 <ihope> Usually for primitive operations?
16:07:52 <musasabi> yes
16:08:05 <ihope> Is unsafeCoerce# a primitive operation?
16:08:58 <musasabi> Writing low level code in Haskell is usually slightly faster than high level code. But each GHC version is a different beast to write low level primitive code for...
16:09:29 <musasabi> Thus makes sense to write on a little bit more high level, which can still be very fast like ByteStrings show.
16:10:11 <musasabi> ihope: iirc yes.
16:11:46 <phr-newbie> anyone suggest the right way to get the max of a list?  foldl max (head xs) (tail xs) works, but yucch
16:12:08 <roconnor> @type maximum
16:12:09 <lambdabot> forall a. (Ord a) => [a] -> a
16:12:18 <phr-newbie> maximum   thanks
16:13:04 <ihope> foldl1 is the function you'd want for that.
16:13:16 <ihope> > foldl1 (*) [1,2,3,4,5]
16:13:17 <phr-newbie> oh cool, that's a more general answer
16:13:17 <lambdabot>  120
16:13:22 <phr-newbie> thanks
16:13:28 <ihope> > foldl1' (*) [1,2,3,4,5]
16:13:30 <lambdabot>  120
16:13:41 <ihope> Strict, so it's even better, maybe.
16:13:50 <phr-newbie> i have to import something to get foldl1' and foldl'  right?
16:13:57 <ihope> I don't think so.
16:14:03 <Botty> no, its in the prelude
16:14:10 <phr-newbie> foldl1 is there
16:14:12 <phr-newbie> not foldl1'
16:14:18 <phr-newbie> Main> :t foldl1'
16:14:18 <ihope> @index foldl1'
16:14:19 <phr-newbie> ERROR - Undefined variable "foldl1'"
16:14:19 <lambdabot> Data.List
16:14:26 <ihope> Hmm.
16:14:44 <dons> phr-newbie: not everything lives in the Prelude :)
16:15:07 <Magicman> @hoogle foldl1
16:15:08 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
16:15:08 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
16:15:09 <phr-newbie> import Data.List does it
16:15:34 <Magicman> And now that's weird... hoogle claims otherwise :p
16:15:59 <dons> foldl1 /= foldl1'
16:16:04 <Magicman> D'oh
16:16:09 <Magicman> @hoogle foldl1'
16:16:09 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
16:16:13 <Magicman> Right-o...
16:16:17 <Magicman> Thanks :)
16:16:26 <phr-newbie> do hugs and ghc both support literate style, and how do i turn it on?
16:16:44 <Magicman> For GHC, just name the file *.lhs... Hugs probably the same.
16:16:44 <dons> stick your code in a .lhs file
16:16:53 <phr-newbie> nice
16:17:00 <yip> what is literate style?
16:17:07 <ihope> What happens if you load a .txt file or something into GHC?
16:17:36 <phr-newbie> yip, literate = mixture of haskell and TeX code, so it formats to a nice printed doc
16:17:55 <Magicman> Haskell and any code actually.
16:17:59 <lispy> there is also Bird literate style
16:18:11 <phr-newbie> Bird?
16:18:17 <ihope> With >?
16:18:17 <Magicman> Everything is a comment by default, except when you preceed it with ">".. then it'll be interpreted as code
16:18:19 <lispy> yeah, code lines start with >
16:18:26 <Magicman> http://www.haskell.org/onlinereport/literate.html
16:18:28 <lambdabot> Title: The Haskell 98 Report: Literate Comments, http://tinyurl.com/mdran
16:18:43 <phr-newbie> i thought that's what "literate style" meant
16:18:47 <phr-newbie> for haskell
16:18:51 <phr-newbie> what happens with .lhs?
16:18:59 <Magicman> I don't know of any other literate style either.
16:19:14 <Magicman> .lhs works with that ">"-thing.
16:19:19 <phr-newbie> cool
16:19:39 <roconnor> > sum [0..10000000]
16:19:43 <lambdabot> Terminated
16:19:50 <phr-newbie> heh
16:20:07 <ThreeQ> why aren't bytestrings monoids?
16:20:29 <phr-newbie> > n*(n+1)/2 where n=10000000
16:20:30 <lambdabot>  Parse error
16:20:36 <phr-newbie> hmm
16:20:49 <phr-newbie> > n * (n + 1) / 2 where n=10000000
16:20:49 <lambdabot>  Parse error
16:21:00 <phr-newbie> > (n * (n + 1) / 2) where n=10000000
16:21:00 <lambdabot>  Parse error
16:21:03 <Magicman> Ah, wrapping it in \begin{code} and \end{code} also works with .lhs
16:21:15 <ihope> > let n = 10000000 in n * (n + 1) / 2
16:21:15 <phr-newbie> > (n * (n + 1) / 2) where n = 10000000
16:21:15 <lambdabot>  Parse error
16:21:17 <Magicman> But you shouldn't mix that with ">"-notation.
16:21:17 <lambdabot>  5.0000005e13
16:21:19 <SamB> ThreeQ: to what end?
16:21:30 <ihope> > let n = 10000000 in n * (n + 1) `div` 2
16:21:32 <lambdabot>  50000005000000
16:21:34 <phr-newbie> > (n * (n + 1) `div` 2) where n = 10000000
16:21:34 <lambdabot>  Parse error
16:21:39 <ThreeQ> SamB: so I can use them in a writer
16:21:52 <ihope> phr-newbie: Haskell interactive things don't like where.
16:21:53 <lispy> ThreeQ: i bet you could instance Monoid pretty easily
16:21:56 <psi> are "wheres" not part of expressions?
16:22:22 <phr-newbie> wheres are declarations, i had the same discussion a few days ago :)
16:22:26 <gmh33_> > (n * (n + 1) `div` 2) | where n = 1000000
16:22:26 <lambdabot>  Parse error
16:22:27 <SamB> ThreeQ: I bet you could send in a patch fairly easily too
16:22:32 <lispy> psi: exactly
16:22:40 <ThreeQ> heh
16:22:48 <ThreeQ> the docs even say it's an instance of monoid
16:23:08 <lispy> oh, then what error are you getting?
16:23:20 <dons> bytestrings are monoids
16:23:21 * lispy wishes he could get oohaskell working
16:23:36 <dons> instance Monoid ByteString where
16:23:36 <dons>     mempty  = empty
16:23:36 <dons>     mappend = append
16:23:36 <dons>     mconcat = concat
16:23:38 <dibblego> dons, in the introduction to quickcheck, I cannot get the function (\s -> all (`elem` ['a'..'e']) (take5 s)) to return anything but True
16:23:46 <ThreeQ> dons: not in the version I checked out from darcs
16:23:50 <dibblego> > let take5 = take 5 . filter (`elem` ['a'..'e']) in all (`elem` ['a'..'e']) (take5 "abcdf")
16:23:52 <lambdabot>  True
16:23:52 <lispy> i keep looking at ocaml, smalltalk and scala and none of them are languages i feel like using...they are not haskell :)
16:24:04 <dons> ThreeQ: you don't have the current darcs version?
16:24:06 <SamB> lispy: heh
16:24:14 <gmh33_> hey lisp!
16:24:23 <dons> dibblego: that means its correct, right? :)
16:24:29 <lispy> gmh33_: hey
16:24:36 <dibblego> dons, I expected False
16:24:36 <ThreeQ> dons: hmm, I forget whether this is the darcs version or the stable one
16:24:37 <gmh33_> could you link me to the bf interpretter source your wrote again ? ^_^
16:24:55 <lispy> gmh33_: sure, it's part of lambdabot
16:24:57 <lispy> ?where lambdabot
16:24:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:25:05 <dons> dibblego: all eleements of the result string must be in [a..e].
16:25:06 <dibblego> dons, sorry my bad
16:25:23 <dons> ThreeQ: the stable version and the current darcs version should all be in Monoid
16:25:30 <dons> fps 0.7, fps 0.8 (darcs)
16:25:33 <lispy> gmh33_: http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/BF.hs
16:25:35 <lambdabot> http://tinyurl.com/emoay
16:25:57 <SamB> @check (\s -> all (`elem` ['a'..'e']) (take5 s))
16:25:58 <lambdabot>  Not in scope: `take5'
16:26:09 <dons> Wed May 24 15:49:38 EST 2006  sjanssen
16:26:13 <dons>   * instance Monoid ByteString
16:26:13 <dibblego> http://www.cse.unsw.edu.au/~dons/code/fps/tests/zipwith.hs I think "bigdata" should be "data"
16:26:14 <lambdabot> http://tinyurl.com/egjht
16:26:17 <phr-newbie> @hoogle zip
16:26:17 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
16:26:18 <lambdabot> List.zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
16:26:18 <lambdabot> List.zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
16:26:20 <ThreeQ> module Data.ByteString.Base (
16:26:20 <ThreeQ>         -- * The @ByteString@ type and representation
16:26:21 <ThreeQ>         ByteString(..),         -- instances: Eq, Ord, Show, Read, Data, Typeable
16:26:21 <ThreeQ>         LazyByteString(..),     -- instances: Eq, Ord, Show, Read, Data, Typeable
16:26:30 <dons> dibblego: doesn't matter, that's just a test for the fusion rules
16:26:39 <dons> bigdata is a file created when you run the testsuite
16:26:45 <dibblego> dons, I'll just not and pretend I understand :)
16:26:48 <dibblego> ok
16:26:49 <dons> actually, ln -s data bigdata
16:27:00 <dibblego> *nod
16:28:00 <ThreeQ> dons: Data.ByteString is a monoid but Data.ByteString.Char8 isn't
16:28:09 <dcoutts> it's the same type
16:28:31 <lispy> hmm...looks like someone else has been hacking on BF I see some code that either i wrote and don't remember or someone else contributed :)
16:29:04 <SamB> lispy: darcs annotate?
16:29:35 <dons> 'annotate' is such an unintuitive name
16:29:44 <SamB> @instances Monoid
16:29:45 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
16:29:55 <SamB> @instances-importing Data.ByteString.Char8 Monoid
16:29:57 <lambdabot> (), (a -> a), (a, b), (a, b, c), ByteString, Ordering, [a]
16:30:04 <lispy> it is, svn blame is unintuitive too
16:30:15 <SamB> ThreeQ: sure it is!
16:30:21 <lispy> i think cvs log was the most sensical
16:30:24 <ThreeQ> SamB: agh, ghc is lying to me
16:30:26 <lispy> name wise
16:30:38 <dons> lispy: I see I added a patch
16:30:39 <SamB> lispy: doesn't CVS use "annotate" also?
16:30:51 <lispy> oh
16:30:53 <ThreeQ> test.hs:15:2:
16:30:54 <ThreeQ>     No instance for (Monoid Data.ByteString.ByteString)
16:30:54 <ThreeQ>       arising from use of `tell' at test.hs:15:2-5
16:31:00 <lispy> i never use CVS so i could be wrong :)
16:31:06 <musasabi> how would one execute a polymorphic function of type: "IO b" from C inside the GHC rts?
16:31:16 <SamB> @instances-importing Data.ByteString Monoid
16:31:17 <lambdabot> (), (a -> a), (a, b), (a, b, c), ByteString, Ordering, [a]
16:31:27 <SamB> ThreeQ: what version are you using?
16:31:39 <ThreeQ> SamB: latest darcs
16:31:50 <dcoutts> musasabi, there are rts C functions for constructing values, applying and evaluating them.
16:31:52 <dons> ThreeQ: works here.
16:31:58 <lispy> dons: i stared at it a bit more, i think i wrote the thing i was wondering about
16:31:59 <dons> import Data.ByteString
16:31:59 <dons> import Data.Monoid
16:31:59 <dons> f = empty `mappend` empty
16:32:05 <SamB> works for lambdabot's install too
16:32:24 <dons> ThreeQ: $ ghc-pkg list fps
16:32:24 <dons> /home/dons/lib/ghc-6.4.2/package.conf:
16:32:24 <dons>     (fps-0.7), fps-0.8
16:32:31 <dons> what does yours say?
16:32:48 <ThreeQ>     (fps-0.6), fps-0.8
16:32:59 <dons> can you run the above code?
16:33:08 <dcoutts> musasabi, or are you concerned about how you'd constrain 'b' ?
16:33:28 <SamB> since this isn't befunge, be sure to delete the "<dons> " before each line ;-)
16:33:37 <ThreeQ> *Main> :l test2
16:33:37 <ThreeQ> Compiling Main             ( test2.hs, interpreted )
16:33:38 <ThreeQ> test2.hs:4:10:
16:33:38 <ThreeQ>     No instance for (Monoid ByteString)
16:33:38 <ThreeQ>       arising from use of `mappend' at test2.hs:4:10-18
16:33:38 <ThreeQ>     Probable fix: add an instance declaration for (Monoid ByteString)
16:33:39 <ThreeQ>     In the definition of `f': f = empty `mappend` empty
16:33:41 <ThreeQ> Failed, modules loaded: none.
16:33:49 <musasabi> dcoutts: mainly looking for a pointer for the right file to read in the rts.
16:33:53 <dons> something's up with your fps install
16:34:13 <dons> ThreeQ: try removing all your fps installs, and rebuilding and install fps 0.8 from darcs
16:34:19 <Eidolos> Hmm. Does Haskell use GMP?
16:34:25 <ThreeQ> dons: will do
16:34:30 <SamB> Eidolos: GHC does
16:34:35 <Eidolos> Er, right. :)
16:34:37 <Eidolos> hehe
16:34:42 <dons> > 2 ^ 666 -- yes
16:34:43 <lambdabot>  3061802069160839023092406500876024752826394864138666225770884719135200228947...
16:34:59 <Eidolos> Well I knew it had good, fast bignum support, just checking.
16:35:13 <SamB> haskell simply demands that Integer be arbitrary-size
16:35:16 <dcoutts> musasabi, look for rts_apply and rts_mkInt etc, imported via Rts.h
16:35:25 <lispy> sacal and ocaml share in ugly syntax...otherwise i might not grumble so much about learning them...
16:35:49 <dcoutts> musasabi, for an example see http://darcs.haskell.org/gtk2hs/glib/System/Glib/hsgclosure.c
16:35:52 <lambdabot> http://tinyurl.com/ew32c
16:36:42 <musasabi> rts_evalIO + rts_apply seems to do the thing.
16:36:56 <Botty> > 10 ^ 666 ^ 666
16:37:00 <lambdabot> Terminated
16:37:26 <musasabi> dcoutts: thanks, that is very readable, just the kind of example I was looking for :-)
16:37:30 <Eidolos> > (10 ^ 666 ^ 666) `mod` 10
16:37:34 <lambdabot> Terminated
16:37:38 <dcoutts> musasabi, you're welcome :-)
16:37:44 <lispy> Eidolos: no fast modular exponentiation :)
16:37:55 <dons> araujo++ translating more haskellwiki pages
16:37:56 <SamB> lispy: not like *that*, anyway
16:38:02 <dons> http://haskell.org/haskellwiki/Introduccion
16:38:03 <lambdabot> Title: Introduccion - HaskellWiki
16:38:11 <dcoutts> musasabi, it's a little less readable since the rts capability thing got added
16:38:12 <lispy> yeah, i wrote a version for haskell
16:38:19 <lispy> just not in the Prelude yet :)
16:39:14 <musasabi> hmm. Why does rts_evalIO need to spawn a new thread?
16:39:19 * lispy looks at Dylan
16:40:04 <goltrpoat> lispy:  'curry' looked interesting, if you haven't seen it
16:40:37 <musasabi> Line 458 in rts/RtsAPI.c
16:40:41 <dcoutts> musasabi, I didn't know that. I guess all code needs a thread to use, so where does it come from otherwise...
16:41:07 <lispy> glguy: oo?
16:41:13 <lispy> oops
16:41:18 <lispy> goltrpoat: is it oo?
16:41:35 <goltrpoat> nah, it's a functional/logic combo, rather haskell-like but with logic programming constructs
16:41:56 <goltrpoat> oh.. were you looking specifically for oo languages?
16:42:05 <lispy> goltrpoat: i'm forced to use/learn an oo language for a class
16:42:08 <goltrpoat> gotcha
16:42:37 <goltrpoat> c# is pretty nice, as oo languages go
16:42:38 <dons> roconnor: on the topic of inlining. i've noticed that Data.Bits is really not great at getting inlined (usually)
16:42:38 <SamB> lispy: CL?
16:42:42 <lispy> scala and ocaml are obvious choices, but the syntax makes me want to wash out my eyes :)
16:42:48 <dons> missing {-# INLINE #-} pragmas on the class methods?
16:42:55 <SamB> dons: I'
16:42:56 <lispy> SamB: yeah...we're not supposed to use a language we know...
16:42:56 <qwr> ocaml is quite nice oo
16:42:58 <SamB> er.
16:43:17 <SamB> dons: I'm trying out {-# INLINE shift #-}
16:43:22 <SamB> in the class scope
16:43:27 <dons> lispy: gofer? :)
16:43:32 <SamB> er, instance rather
16:43:35 <dons> SamB: does that work?
16:43:40 <lispy> gofer? hmm...
16:43:40 <SamB> I don't know yet
16:43:59 <phr-newbie> gmpy has a fast modexp routine
16:43:59 <dons> lispy, Miranda?
16:44:02 <phr-newbie> gmp i mean
16:44:25 <lispy> dons: but is Miranda oo?
16:44:27 <SamB> dons: ooh, yes, it works lovely!
16:44:33 <dons> yay!
16:44:35 <phr-newbie> lispy how about timber?
16:44:49 <SamB> dons: so you think other members need that too?
16:44:53 <dons> SamB: make a patch! get some speed measurements.
16:44:54 <dons> yes.
16:45:02 <SamB> can you do that in the class?
16:45:02 <lispy> timber?
16:45:05 <dons> i think its probably like the fps stuff. the inlines will be critical
16:45:11 <dolio> SamB: That was the problem all this time? It needed an {-# INLINE #-}?
16:45:12 <dons> SamB: yep
16:45:17 <phr-newbie> lispy timber = successor to O'Haskell    maybe it doesn't qualify as a lang. you don't know
16:45:30 <SamB> dons: I'm just saying that it gets inlined now
16:45:34 <phr-newbie> but also, maybe the point of the exercise is you're supposed to hold your nose and use java ;)
16:45:41 <phr-newbie> or ruby or smalltalk might be more interesting
16:45:45 <lispy> phr-newbie: hmm...yeah ohaskell looked interesting but dead, i'll check it out
16:46:01 <phr-newbie> lispy the o'haskell guys went and did timber
16:46:13 <lispy> the rule was, you have to use a language that you've scarcely or never used and it has to support OO
16:46:32 <qwr> self :P
16:46:53 <dons> OCaml then?
16:47:22 <phr-newbie> is there a multi-list equivalent of map?  or do i have to do some awfulness with zipping and unzipping?
16:48:01 <goltrpoat> lispy:  you could cheat and use D
16:48:15 <lispy> dons: yeah, problem with both scala and ocaml was just that i thought the syntax was ugly :)
16:48:16 <qwr> hmm slate also quite exotic oo language... http://slate.tunes.org/
16:48:18 <lambdabot> Title: Slate Language Website
16:48:31 <phr-newbie> lispy how about python?
16:48:33 <dons> phr-newbie: zip.
16:48:41 <SamB> dons: including rotate?
16:48:52 * edwardk waves hello.
16:48:57 <dons> > map ((^2) *** toUpper) $ zip [1..10] "haskell"
16:48:58 <lambdabot>  [(1,'H'),(4,'A'),(9,'S'),(16,'K'),(25,'E'),(36,'L'),(49,'L')]
16:49:01 <lscd> phr-newbie: python is ugly as well ;) -- the syntax is ok, but it has some irritating warts
16:49:14 <dons> phr-newbie: zip + arrows make this nicer as you see
16:49:23 <lispy> yeah, python is internally annoying...i could use it though
16:49:40 <phr-newbie> ***   ???????
16:49:46 <edwardk> @type (***)
16:49:47 <dons> SamB: well, I think you should actually benchmark these functoins (or check the resulting code) to be sure
16:49:47 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:49:49 <phr-newbie> Data.List> :t (***)
16:49:49 <phr-newbie> ERROR - Undefined variable "***"
16:49:49 <phr-newbie> Data.List>
16:49:58 <phr-newbie> hmm
16:50:01 <dons> ?hoogle ***
16:50:02 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
16:50:05 <dolio> :m + Control.Arrow
16:50:09 <edwardk> > (snd***fst) (1,2)
16:50:10 <lambdabot>  add an instance declaration for (Num (a, b))
16:50:11 <SamB> dons: I really don't think it is likely to help much with rotate...
16:50:13 <edwardk> er
16:50:18 <dons> SamB: ok.
16:50:26 <dons> numbers are good if you want to get it into base.
16:50:41 <dons> and the better the numbers the more chance we'll get it in for 6.6 ... :)
16:50:54 <SamB> how about I count the number of times you bang your head against $wshift and things like that without it?
16:51:02 <dons> yep
16:51:10 <dons> i.e. check the core, and show that the core output is better
16:51:27 <lispy> $wshift?
16:51:29 <SamB> that is what I am doing
16:51:30 <phr-newbie> dons given xs,ys,zs where xs=[x1,x2,..2] i want to get [f x1 y1 z1, f x2 y2 z2 ... ]
16:51:33 <edwardk> my mistake, that should have been > (snd &&& fst) (1,2)
16:51:34 <edwardk> =)
16:51:51 <SamB> lispy: the worker for an implementation of Data.Bits.shift, probably the first in a given module
16:51:52 <phr-newbie> and i can do that with zip3 and destructuring, but uggh
16:52:03 <phr-newbie> @type (&&&)
16:52:04 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:52:09 <dolio> ?type zipWith3
16:52:11 <lambdabot> forall d c b a. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
16:52:31 <SamB> aka zdwshift
16:52:41 <phr-newbie> oh cool thanks dolio
16:52:47 <dons> > zipWith3 (\a b c -> (a+b, toUpper c) [1..] [2..] "haskell"
16:52:47 <lambdabot>  Parse error
16:52:58 <dons> > zipWith3 (\a b c -> (a+b, toUpper c)) [1..] [2..] "haskell"
16:53:00 <lambdabot>  [(3,'H'),(5,'A'),(7,'S'),(9,'K'),(11,'E'),(13,'L'),(15,'L')]
16:53:41 <lscd> hmmm. I've defined findInclusiveORExpression = chainl1 findExclusiveORExpression (auxEEEOp "|") and unit testing it works; findLogicalANDExpression = chainl1 findInclusiveORExpression (try (auxEEEOp "&&")) takes several seconds adn a few hundred megs of ram before causing a stack overflow.  I have 11 definitions of this this general form, using chainl1; the first two both fail with stack overflows (I showed the second one here), while
16:53:41 <lscd> the 3rd onward all pass the unit tests.  Any idea on what I'm doing wrong?
16:53:45 <dolio> ?type zipWith7
16:53:47 <lambdabot> forall h g f e d c b a. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
16:54:44 <edwardk> > zipWith3 (flip flip toUpper . (((.) . (,)) .) . (+)) [1..] [2..] "haskell"
16:54:45 <lambdabot>  [(3,'H'),(5,'A'),(7,'S'),(9,'K'),(11,'E'),(13,'L'),(15,'L')]
16:54:45 <sjanssen> @hoogle chainl
16:54:46 <lambdabot> Text.ParserCombinators.ReadP.chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
16:54:46 <lambdabot> Text.ParserCombinators.Parsec.Combinator.chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a
16:54:46 <lambdabot> Text.ParserCombinators.ReadP.chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
16:55:00 <phr-newbie> >let f a b c = a+b+(toUpper c) in zipWith3 f [1,5..] [2,6..] "haskell"
16:55:14 <phr-newbie> uh oh
16:55:31 <dons> > 1+ 2 -- typo ;)
16:55:32 <lambdabot>  3
16:55:38 <phr-newbie> ??
16:55:46 <phr-newbie> > let f a b c = a+b+(toUpper c) in zipWith3 f [1,5..] [2,6..] "haskell"
16:55:47 <lambdabot>  add an instance declaration for (Num Char)
16:55:47 <lambdabot>   In an arithmetic sequence: [...
16:56:15 <phr-newbie> hmm did i confuse the bot ?
16:56:20 <lscd> nope
16:56:53 <dons> > let f a b c = (a+b, toUpper c) in zipWith3 f [1,5..] [2,6..] "haskell"
16:56:54 <lambdabot>  [(3,'H'),(11,'A'),(19,'S'),(27,'K'),(35,'E'),(43,'L'),(51,'L')]
16:56:59 <monochrom> try a + b + (fromEnum (toUpper c))
16:56:59 <lscd> you can't say 1 + 'C' though
16:57:15 <phr-newbie> oh i see
16:57:17 <SamB> @google "haskell report" "{-# INLINE #-}"
16:57:19 <lambdabot> http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/pragmas.html
16:57:19 <lambdabot> Title: The Haskell 1.3 Report: Pragmas
16:57:34 <SamB> @google "haskell report" "{-# INLINE #-}" site:haskell.org
16:57:37 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/ghc-language-features.html
16:57:38 <lambdabot> Title: Chapter 7. GHC Language Features
16:57:46 <phr-newbie> :t fromEnum
16:57:51 <phr-newbie> ?type fromEnum
16:57:53 <lambdabot> forall a. (Enum a) => a -> Int
16:58:01 <phr-newbie> > fromEnum "x"
16:58:02 <lambdabot>  add an instance declaration for (Enum [Char])
16:58:02 <lambdabot>   In the definition of `oie...
16:58:06 <monochrom> 'x'
16:58:18 <phr-newbie> > fromEnum 'x'
16:58:19 <lambdabot>  120
16:58:25 <monochrom> You are very newbie :)
16:58:42 <phr-newbie> > let f a b c = a+b+(fromEnum (toUpper c)) in zipWith3 f [1,5..] [2,6..] "haskell"
16:58:43 <lambdabot>  [75,76,102,102,104,119,127]
16:58:47 <phr-newbie> ahhhh :)
16:58:56 <phr-newbie> thanks
17:00:11 <sjanssen> @yow
17:00:12 <lambdabot> I want another RE-WRITE on my CAESAR SALAD!!
17:01:27 <lscd> [I've half-found  the error; it's finding the constant 1, and then finding the operator | or &, depending on if I'm trying to find && or ||, and then dying trying to parse "|1", which it should just be rejecting as invalid)
17:02:05 <phr-newbie> hehe
17:04:05 <sjanssen> dons: I got my SoC tshirt, they're pretty nice
17:04:10 <dons> cool
17:04:16 * dons wonders how long mine will take
17:04:23 <dons> another week maybe
17:05:07 <edwardk> sjanssen: so did they sign off on all your code then or whatever is entailed in this sort of thing?
17:06:01 <dibblego> ?index quickCheck
17:06:01 <lambdabot> Test.QuickCheck, Debug.QuickCheck
17:06:03 <sjanssen> edwardk: dons (my mentor) signed off on my code
17:06:29 <dibblego> is quickCheck equivalent to check defaultConfig?
17:06:39 <dibblego> and test?
17:06:41 <lispy> dibblego: i think so
17:07:10 <edwardk> woot
17:07:10 <lispy> so you can do check (defaultConfig { configNumTest = 4 }) myTest
17:07:16 <lispy> or something close to that
17:07:33 <lispy> (i don't have the code in front of my or i'd get the exact line)
17:09:08 <goltrpoat> lscd:  add "|" to reservedOpNames and use reservedOp "|" and reservedOp "||" instead of char '|' and string "|" or whatever
17:09:21 <goltrpoat> er.. string "||" i mean
17:09:43 <goltrpoat> i had the same problem with the OperatorTable stuff the other day
17:10:03 <foxy> http://www.improb.com/ig-pastwinners.html#ig2006
17:10:07 <lambdabot> Title: Improbable Research, http://tinyurl.com/zk4ky
17:10:21 <goltrpoat> foxy:  kurt vonnegut's brother won one of those
17:10:43 <foxy> kurt vonnegut?
17:11:57 <goltrpoat> famous writer.  his brother is a less than famous meteorologist.  won the Ig Nobel award for "Chicken plucking as measure of tornado wind speed."
17:15:00 <dons> sjanssen: yeah, we're just sorting out the last details of the SoC summit now. haskell.org seems to have been quite successful, above average at least.
17:15:36 <dons> i'll be keeping my eyes peeled for haskell code running at google headquarters, too :)
17:15:47 <dcoutts> heh :-)
17:15:58 <lscd> goltrpoat: eh, that would make a fair amount of sense; the bug was actually an infinite recursion on invalid input when i was trying to parse postfix expressions, as it would call itself without consuming anything if given bad data.
17:16:00 <SamB> dons: how will you see it?
17:16:26 <dons> i'll just try to talk to as many people as possible :)
17:16:27 <goltrpoat> lscd:  -nod-
17:16:41 <dons> and install spy cameras, that too.
17:16:56 <SamB> heh
17:17:03 <sjanssen> dons: they really ought to use Haskell, when one of their major frameworks is called "MapReduce", seems like Haskell could be a real big win
17:17:04 <dons> i've got my lambda detector packed, in case i need it
17:17:16 <SamB> you know, I really want a *working* ar
17:17:25 <dons> sjanssen: right. and the icfp guys worked at google, . and knew haskell well enough to write a theorem prover.
17:17:38 <lscd> sjanssen: google? they seem to have a weird attitude about programming languages - ie, absolutely no lisp or smalltalk, or so i've heard
17:17:38 <dons> so that's a good sign that its at least played with in the side projects
17:18:08 <dcoutts> does anyone happen to know yacc, what would an empty {} in the middle of a production mean?
17:18:15 <Adamant> no Lisp or Smalltalk?
17:18:16 <dons> skip; ?
17:18:18 <SamB> lscd: that might not be an attitude so much as a "meh"
17:18:20 <Adamant> weird.
17:19:07 <Adamant> supposedly. Google likes to hires Lispniks and Smalltalkers.
17:19:28 <SamB> oh really?
17:19:32 <goltrpoat> google likes python apparently
17:19:49 <lscd> SamB: eh, I'm basing it on http://www.flownet.com/gat/jpl-lisp.html
17:19:52 <SamB> oh
17:20:15 <lscd> Adamant: sure, they like to hire competent people; and I'd say that your average lispnick and smalltalker is more competent than your average coder
17:20:16 <foxy> PEACE
17:20:18 <foxy> The British Royal Navy, for ordering its sailors to stop using live cannon shells, and to instead just shout "Bang!"
17:20:44 <lscd> goltrpoat: yeah, they use python fairly heavily; guido works there
17:20:51 <goltrpoat> ah right
17:21:12 <SamB> lscd: he does?
17:21:16 * SamB didn't know that
17:21:40 <lscd> SamB: http://www.oreillynet.com/onlamp/blog/2005/12/python_creator_guido_van_rossu.html -- yes, as of last year
17:21:43 <lambdabot> http://tinyurl.com/lbqgx
17:21:52 <lscd> google is the new transmeta ;)
17:23:51 <lscd> dcoutts: it would force yacc not to abandon trying to match that production, i think, but my yacc is rusty; the term is a 'mid-rule action', i believe
17:24:18 <dcoutts> lscd, thanks, I'll google for yacc & mid-rule action
17:24:26 <dons> hehehe "  Want to start helping out on a big Haskell project, but frustrated that there is no easy way into
17:24:26 <lscd> dcoutts: good luck
17:24:29 <dons>   a project? The Yhc team has the answer, help with Yhc :)"
17:24:32 <lscd> dons: the yhc thing?
17:24:42 <lscd> they've gotten that into so many of the blogs i follow it's insane :)
17:24:44 <lscd> even smalltalk ones!
17:25:25 <SamB> now with commit access in both hemispheres!
17:25:39 <lscd> SamB: north/south or east/west?
17:25:48 <SamB> east/west
17:25:55 <yip> how hard would it be to make a c wrapper around c++'s std::list<int> and then make a haskell binding to it so that you'd get a lazy list?
17:26:09 <lscd> SamB: congrats
17:26:12 <SamB> yip: heh
17:28:34 <yip> i am actually serious
17:28:51 <yip> i'm interested in doing haskell bindings to a c++ library, and so i've started to make a c wrapper around the library
17:29:06 <yip> but the library uses the STL a lot, and i have no idea what the best way is to interface this with haskell
17:29:57 <dcoutts> lscd, yes, it seems one side effect of a mid rule action is that the parser must commit before going past that
17:30:05 <dcoutts> since it has to execute the code in {}
17:30:11 <dcoutts> which of course is none
17:30:50 <SamB> they got Yhc mentioned in Smalltalk blogs?
17:32:33 * dcoutts -> sleep
17:38:06 <araujo> SamB, link?
17:38:18 <SamB> I think lscd said that
17:38:24 <SamB> I haven't seen them
17:42:16 * SamB wonders why Data.Typeable needs to be rebuilt when he alters Data.Bits, GHC.Word, and GHC.Int
17:45:24 <dons> ?users
17:45:42 <lambdabot> Maximum users seen in #haskell: 256, currently: 228 (89.1%), active: 36 (15.8%)
17:52:11 <yip> guys, what do you think about my problem?
17:52:44 <lispy> you have a problem?
17:52:46 * lispy reads
17:53:15 <lispy> hmm..
17:53:26 <lispy> afaik, you can't interface with C++
17:53:41 <yip> right, that's why i am making a c wrapper around the library
17:53:42 <lispy> so to get haskell to interface with the STL you'd have to 'wrap' it in C
17:54:10 <lispy> so you want std::list<int> -> [Int] ?
17:54:20 <yip> yes
17:54:24 <lispy> i'm not sure how to do that
17:54:26 <yip> but lazily
17:55:04 <lispy> for one thing, you're more likely to get std::list<int> -> IO [Int]
17:55:19 <lispy> what do you mean by lazily?
17:55:21 <yip> right, that is actually what i want
17:55:34 <lispy> youwant to pull elements over to the haskell side as you need them?
17:55:42 <yip> lispy: yes
17:56:50 <lispy> i have no idea how you'd manage that
17:56:58 <lispy> maybe an unsafeInterleaveIO
17:57:17 <SamB> sounds unsafe!
17:57:32 <lispy> so if you could write a function in Haskell that pulls all the elements over and somehow only does as much as is needed taht would probably work
17:57:42 <lispy> so, maybe unsafeInterleaveIO is that magic
17:58:00 <yip> well, how should i write the c interface then?
17:58:26 <lispy> write a nextElem function
17:58:41 <lispy> then in haskell run it till the end of the list
17:59:00 <lispy> if you can get the haskell side to return it lazily you're set right? :)
17:59:13 <lispy> and there is the python appoarch
17:59:34 <lispy> spit one element then 'yield'
17:59:48 <yip> only problem is that what if i store the haskell list somwhere, and access it later, after the c++ list has already been destroyed?
17:59:54 <lispy> when you call it again, resume where you 'yield'd
17:59:58 <dibblego> how I pass my expression of type a -> [a] -> Bool to quickCheck?
18:00:31 <lispy> dibblego: you need to make it something like Int -> [Int] -> Bool
18:01:04 <lispy> yip: is the C++ threaded separately from the  Haskell?
18:01:21 <dibblego> that's wat I thought - but I'm not succeeding
18:01:27 <yip> lispy: you mean multithreading? no, the c++ library is single threaded
18:02:02 <dibblego> (\x y -> length (List.elemIndices x y) == length (tokenise y x) - 1)
18:02:07 <dibblego> ?type (\x y -> length (List.elemIndices x y) == length (tokenise y x) - 1)
18:02:09 <lambdabot> Not in scope: `tokenise'
18:02:15 <lispy> yip: i'm no expert, but hopefully you can then control if the C++ would free it while the haskell side wants it
18:02:38 <dibblego> er, how do I make that of type Int -> [Int] -> Bool?
18:03:04 <lispy> scala seems more interesting than ocaml, so i think i'll give it a try for my class
18:03:26 <lispy> dibblego: can you paste a link to your property?
18:03:35 <dibblego> my property?
18:03:49 <lispy> dibblego: usually you say, types = (x::Int, xs::[Int])
18:04:08 <lispy> dibblego: quickcheck right?  usually all your tests are named prop_foo
18:04:09 <dibblego> I don't have one of those
18:04:22 <lispy> dibblego: have you read the userguide at all? :)
18:04:23 <dibblego> I am just using the quickCheck function
18:04:25 <dibblego> yes
18:04:35 <dibblego> but I am going off Introduction to QuickCheck
18:05:23 <dibblego> how do you add types to a lambda?
18:05:29 <lispy> (\x y -> length (List.elemIndices (x::Int) (y::[Int])) == length ...
18:05:50 <lispy> thereis a ghc extension to allow (\(x::Int) y -> ...)
18:06:19 <lscd> SamB: I was taking a nap - but yeah, http://jaortega.wordpress.com/2006/10/08/becoming-a-haskell-developer/ (as seen on planet smalltalk!)
18:06:23 <lambdabot> Title: Becoming a Haskell developer  programming musings, http://tinyurl.com/l47zd
18:07:26 <SamB> I am waiting for ar yet again...
18:07:37 <lscd> ar?
18:08:10 <lispy> creates libraries from object code, iirc
18:08:24 <lscd> oh.... that ar
18:08:46 <lscd> strange, i've never seen it be really slow
18:20:04 <dibblego> in Test.QuickCheck.Config, where is it documented where each of those 4 things (what are they?) actually mean? (configMaxTest, configMaxFail, configSzie, configEvery)
18:22:34 <dons> ?docs Test.QuickCheck
18:22:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
18:22:44 <dons> but the source is a good place to start
18:23:03 <dibblego> that's where I looked
18:23:14 <dibblego> just gives the types
18:23:24 <dibblego> I'll check the source and hope
18:32:24 <SamB> dons: got any code lying around that uses (.|.), (.&.), xor, complement, and shift ?
18:32:39 <dons> yeah, let me see...
18:33:25 <dons> (bottom of) oh, not quite, but you could port it, http://www.cse.unsw.edu.au/~dons/code/hs-plugins/src/System/MkTemp.hs
18:33:27 <lambdabot> http://tinyurl.com/zpgco
18:33:43 <dons> some here, http://www.cse.unsw.edu.au/~dons/code/hmp3/Binary.hs
18:33:44 <lambdabot> http://tinyurl.com/e5pp2
18:34:09 <dons> otherwise, port some C code?
18:34:15 <SamB> hmm
18:34:35 <SamB> somebody write me some stupid code that uses all 5 of those ;-P
18:35:07 <dons> > 0xdeadbeef `xor` 0xff
18:35:07 <lambdabot>  Add a type signature
18:35:19 <dons> > 0xdeadbeef `xor` 0xff :: Int
18:35:20 <SamB> preferably in one function ;-)
18:35:20 <lambdabot>  -559038960
18:35:35 <dons> > 0 .|. (0xdeadbeef `xor` 0xff) :: Int
18:35:36 <lambdabot>  -559038960
18:35:56 <dons> > (0xcafebabe `shift 10) .|. (0xdeadbeef `xor` 0xff) :: Int
18:35:56 <lambdabot>  Parse error
18:36:05 <dons> > (0xcafebabe `shift` 10) .|. (0xdeadbeef `xor` 0xff) :: Int
18:36:06 <lambdabot>  -17826288
18:36:16 <dons> > complement $ (0xcafebabe `shift` 10) .|. (0xdeadbeef `xor` 0xff) :: Int
18:36:18 <lambdabot>  17826287
18:36:29 <dons> > 0xff .&. complement $ (0xcafebabe `shift` 10) .|. (0xdeadbeef `xor` 0xff) :: Int
18:36:30 <lambdabot>  add an instance declaration for (Bits (Int -> Int))
18:36:45 <dons> > 0xff .&. (complement $ (0xcafebabe `shift` 10) .|. (0xdeadbeef `xor` 0xff)) :: Int
18:36:46 <lambdabot>  239
18:36:48 <dons> stoopid enough?
18:36:52 <SamB> yeah
18:37:41 <dons> we should have @stupid Data.Bits
18:37:55 <dons> which would use some constratin solver to generate type correct, stupid code using the api from that module
18:42:25 <lispy> hmm...scala has a theme song, why doesn't haskell? :) http://lamp.epfl.ch/~emir/trax/scala_genau.mp3
18:42:29 <lambdabot> http://tinyurl.com/ls5ds
18:46:03 <SamB> @hoogle Q
18:46:04 <lambdabot> Language.Haskell.TH.Q :: data Q a
18:46:04 <lambdabot> Control.Concurrent.QSem :: module
18:46:04 <lambdabot> Control.Concurrent.QSemN :: module
18:48:43 <dibblego> dons, I cannot infer the meaning of those 4 attributes of Test.QuickCheck.Config from the source and I cannot see it in any documentation - any hints?
18:50:43 <edwardk> scala has a themesong, erlang has a weird video, it seems we want to follow along after everyone. ;)
18:51:50 <dibblego> whether it is a theme song or video, it needs to take the piss out of the accusations of "only for academics" or "not real world"
18:52:18 <edwardk> heh, some how i have a visual of a sesame street style 'monads for kids' segment ;)
18:52:42 <edwardk> brought to you by the monad "List" and the type class "Q"
18:52:47 <lispy> edwardk: oh, do you have the link to the erlang vid?
18:53:02 <edwardk> http://video.google.com/videoplay?docid=-5830318882717959520 i think
18:53:06 <lambdabot> Title: Erlang: The Movie - Google Video, http://tinyurl.com/j5urt
18:53:12 <lispy> cool
18:53:57 <dibblego> does anyone know what configMaxTest, configMaxFail, configSize or configEvery means?
18:54:07 <dibblego> in Test.QuickCheck.Config
18:55:58 <lispy> edwardk: ah!!!this video  is hard to watch!
18:56:04 <edwardk> heh
18:56:16 <edwardk> this is the first time i've bothered actually
18:57:32 <lispy> "sytem working?"
18:57:35 <lispy> lol-
18:57:53 <dibblego> shall I conclude that it is undocumented and telepathy is the only solution?
18:59:33 <SamB> hmm
19:00:07 <SamB> dons: is it just me or is this problem only with bitshifting?
19:01:41 <edwardk> this movie actually seems like an advertisement for haskell. look they misnamed an identifier, runtime crash. hrmm ;)
19:01:48 <Cale> heh
19:02:15 <Cale> yeah
19:02:27 <Cale> that sort of thing really ought to be statically checked
19:02:31 <edwardk> yeah
19:03:34 <goltrpoat> misnaming an identifier causes a runtime crash?
19:03:45 <goltrpoat> that's borderline comical
19:03:53 <SamB> goltrpoat: in dynamic languages, yes!
19:04:12 <edwardk> they screwed up and wrote mmulti_no instead of multi_no, as an example of how they can fix bugs without affecting other running programs.
19:04:16 <lispy> edwardk: yeah, on the other hand, their dynamic reload is cool
19:04:22 <edwardk> sure
19:04:33 <SamB> but that is a bad example
19:04:41 <SamB> they should have had a semantic error
19:05:18 <lispy> like this:
19:05:20 <lispy> > head []
19:05:21 <lambdabot>  Add a type signature
19:05:34 <lispy> > head ([]::[Int]) -- how baotu this instead
19:05:35 <lambdabot>  Exception: Prelude.head: empty list
19:05:55 <lispy> funny video though
19:06:00 <lispy> very hard to watch :)
19:06:07 <edwardk> goltrpoat: have a minute?
19:06:10 <lispy> the corny factor is high :)
19:06:20 <goltrpoat> yeah.. sorry, had to ident with the server
19:06:21 <edwardk> yeah
19:06:22 <edwardk> definitely
19:06:32 <edwardk> no problem. i was trying to make sure i was identified too =)
19:06:36 <lispy> when did google buy myspace?
19:07:00 <dmead> they didnt?
19:07:29 <lispy> hmm..then why did they add a link "post to myspace"...
19:07:37 <dmead> did they?
19:07:56 <SamB> lispy: they are always linking to other people's services
19:08:07 <SamB> aren't they?
19:08:46 <jgrimes> myspace and google made some advertising agreement recently
19:09:18 <dmead> so they made a deal with the devil?
19:09:38 <jgrimes> well, a deal with Fox. So, yes.
19:09:45 <jgrimes> or News Corp, rather.
19:09:48 <gmh33> myspace gets more daily hits than google >_>;
19:10:01 <gmh33> isn't that really really sad ?
19:10:06 <dmead> yea
19:10:12 <gmh33> it was also sold to fox for nearly 600 million USD
19:10:32 <gmh33> or wait... those numbers might be a bit off lol
19:10:35 <dmead> i read on slashdot one of the original owners says he has evidence they broke some law in the buyout
19:10:42 <gmh33> nope, those are right
19:10:48 <dmead> and he could get it reversed
19:11:05 <gmh33> who would reverse a 580 million dollar deal :P
19:11:07 * lispy makes a point of avoiding myspace
19:11:23 <dmead> someone who wants his billion dollar company back for half price
19:11:35 <dmead> yea
19:11:42 <lispy> myspace, cnet, downloads.com, zdnet, gamespy....
19:11:44 <gmh33> facebook almost sold for about half that
19:11:45 <dmead> myspace was evil before the buyout =)
19:11:53 <gmh33> but the owner was holding out for more money, now he can't sell it
19:12:02 <dmead> hah
19:14:17 <SamB> dons: so what should I do with this patch again?
19:14:18 <weitzma1> I guess I don't have the big business spirit. If someone offered me 100 mil I would congratulate myself on a job well done, take the money, and call it a day
19:14:20 <dibblego> what was the thread where dons  said "academic" is such an amusing insult?
19:14:34 <gmh33> so how easy would it be to write a compiler with parsec ? :P
19:15:22 <Cale> gmh33: the parsing wouldn't be the hard part :)
19:15:26 <dmead> use bison =p
19:15:30 <gmh33> D:
19:15:43 <gmh33> but I don't want to use C lol
19:15:45 <gmh33> I know C well
19:15:56 <gmh33> but if I was going imperative, I'd use Eiffel :P
19:16:05 <gmh33> despite the fact that I'd have to hand write a lexer/parser
19:16:06 <dmead> :P
19:16:09 <Cale> Parsec is an excellent way to build parsers.
19:16:12 <SamB> dons: should I just send it to libraries@haskell.org like the repo suggests?
19:16:19 <dmead> im just sayin
19:16:21 <jgrimes> happy is a nice parser generator for haskell
19:16:23 <dmead> why reinvent the wheel
19:16:32 <gmh33> ANTLR?
19:16:49 <gmh33> I've heard ANTLR is pretty slick too :P
19:16:52 <dfranke> Use TIARA, once I release it :-)
19:17:10 <gmh33> I WILL NEVER USE YOUR CRAP :P
19:17:23 <dfranke> (TIARA Is A Recursive Acronym)
19:17:31 <SamB> oh, great, alpha testing! *BLOWS UP, SENDS USER SAILING* wheeee!
19:18:45 <gmh33> Hurd is my favorite acronym : P
19:19:31 <weitzman> Does it stand for "Hurd is Unlikely to be Released this Decade"?
19:19:33 <gmh33> the H is mutually recursive with Herd
19:20:23 <gmh33> Hurd -> Herd -> Hurd -> Herd -> Hurd -> ...
19:21:18 <dmead> odd they keep trying to finish it
19:21:31 <gmh33> it's a nice design, like the rest of the GNU stuff :P
19:21:37 <weitzman> Now that they've decided to base it on a microkernel that doesn't exist yet
19:21:40 <dmead> sure it is ;)
19:21:43 <weitzman> I'm not expecting anything soon
19:21:52 <dmead> and richard stallman is a well adjusted person ;)
19:21:56 <gmh33> weitzman: Neither do I :P
19:22:08 <SamB> weitzman: heh
19:22:21 <SamB> it used to run, too!
19:22:27 <lispy> dmead: heh
19:22:34 <lispy> dmead: very well adjusted
19:22:47 <SamB> okay, should I just send this patch to the list?
19:23:02 <SamB> Sun Oct  8 22:09:06 EDT 2006  Samuel Bronson <naesten@gmail.com>
19:23:02 <SamB>   * Inline shift in GHC's Bits instances for {Int,Word}{,8,16,32,64}
19:23:02 <weitzman> Advantages of hurd: "it exists  The Hurd is real software that works Right Now.  It is not a research project or a proposal.  You don't have to wait at all before you can start using and developing it."
19:23:38 <gmh33> lol
19:24:02 <gmh33> It's better than a bunch of other research kernels
19:24:06 <gmh33> other than BSD :P
19:24:13 <gmh33> and Linux..
19:25:07 <dmead> oh right
19:25:08 <dmead> =p
19:25:33 <gmh33> those used to be research projects :P
19:25:33 <SamB> okay, if no one has any objections, I will send this patch to the list
19:26:16 <weitzman> At least one file in Hurd CVS has been modified in the last 2 months
19:26:34 <SamB> they are still using that antiquated VCS?
19:26:50 <SamB> I thought everyone had switched to SVN or something else by now
19:26:54 <lispy> actually can install hurd
19:27:00 <lispy> there is a debian/hurd
19:27:05 <SamB> yeah
19:27:10 <lispy> it's pretty eas and it does work
19:27:14 <SamB> I had it installed on this box before I was actually using it
19:27:24 <SamB> It might be around somewhere still
19:28:25 <SamB> so no objections...
19:28:35 <gmh33> I think the neat thing about writing a compiler in Haskel is you can just model the language with Datatypes :P
19:28:41 * SamB hopes it comes back to him in the mail
19:29:04 <SamB> gmh33: yeah
19:29:17 <SamB> you can even wait until your compiler works to come up with a syntax ;-)
19:29:59 <gmh33> heh
19:30:10 * weitzman wonders if he will live to see the day when "writing a compiler" means writing a new frontend for the super-awesome backend everyone's already using
19:30:20 <SamB> heh
19:30:24 <SamB> nevar!
19:30:42 <SamB> it will probably have to work with a million zillion backends!
19:34:12 <gmh33> which super awesome backend ? :P
19:34:49 <SamB> gmh33: it does not exist yet, obviously
19:34:58 <gmh33> neko seems pretty good :P
19:35:15 <gmh33> the nekovm
19:35:48 <gmh33> the gcc backend makes a bad backend :/
19:36:05 <gmh33> it's only meant to be targetted by /very/ C like languages
19:36:33 <gmh33> neko tries to be a good target for all langues :D
19:36:37 <gmh33> even functional ones
19:37:16 <gmh33> and it's a lot easier to learn/read than parrot :/
19:37:33 <weitzman> .NET wants to be everyone's buddy too
19:37:48 <gmh33> no, .NET hates everyone who doesn't use windows :P
19:38:04 <gmh33> and I don't really trust it anyway
19:39:18 <gmh33> maybe if neko ever incorporated a good native code compiler
19:39:20 <gmh33> :/
19:42:47 <gmh33> I wonder how long it took to write parsec..
19:43:02 <gmh33> the guy who wrote ANTLR apparently spent 5 years on it
19:43:10 <gmh33> so far
19:43:59 <weitzman> "Terence Parr is the maniac behind ANTLR and has been working on ANTLR since 1989."
19:44:24 <weitzman> Which is odd, because it certainly wasn't written in Java back then
19:44:44 <SamB_XP> he must have rewritten it ;-)
19:45:03 <gmh33> yeah, it was called PCCT ?
19:45:16 <gmh33> I've never used it
19:45:24 <gmh33> because I stay away from Java
19:45:32 <gmh33> I didn't really like having to learn it in highschool
19:47:43 <dons> SamB_XP: yeah, send it in to libraries@ , with a good story about why its needed
19:48:26 <dons> SamB_XP: add a comment on why its needed, can you? in a follow up mail
19:48:42 <dons> on why its _crucial_ ?
19:48:58 <dons> open source is all about consensus. so making your case is a good idea
19:51:05 <dibblego> I have used ANTLR
19:51:37 <dons> SamB_XP: also, is it just shift we want inlined?
19:51:45 <dons> I see dozens of +    {-# INLINE shift #-}....
19:51:52 <SamB_XP> dons: the others look okay already...
19:52:06 <lispy> what is this for?
19:52:10 <dons> really? I seem to recall things ike .|. and .&. not being properly inlined. you checked that?
19:52:12 <lispy> ie, what are you improving
19:52:13 <carp> dons: I'm still struggling to build frag with 6.6 RC2
19:52:21 <dons> carp: how does it fail?
19:52:25 <SamB_XP> dons: really?
19:52:30 <dons> carp, i've not tested with 6.6
19:52:33 <SamB_XP> it looked okay for my test code!
19:52:34 <lispy> carp: still osx intel problems?
19:52:37 <dons> ah
19:52:49 <SamB_XP> with 6.4.1 or 6.4.2, whichever I have
19:52:50 <carp> Building frag-1.0...
19:52:50 <carp> [14 of 41] Compiling BitSet           ( BitSet.hs, dist/build/frag/frag-tmp/BitSet.o )
19:52:50 <carp> BitSet.hs:30:32: Not in scope: `bounds'
19:52:57 <dons> oh, that's a porting issue
19:53:06 <dons> bounds is now in Data.Array , iirc
19:53:13 <dons> so: import Data.Array to that module
19:53:21 <dons> (or is it Data.Array.Base?)
19:53:23 <carp> tried that i think
19:53:37 <dons> this is an easy one to fix, just find the module and import it
19:53:40 <carp> BitSet.hs:31:39:
19:53:40 <carp>     Couldn't match expected type `Array a e'
19:53:40 <carp>            against inferred type `IOUArray Int Bool'
19:53:40 <carp>     In the first argument of `bounds', namely `bs'
19:53:40 <carp>     In the first argument of `rangeSize', namely `(bounds bs)'
19:53:41 <carp>     In the expression: rangeSize (bounds bs)
19:53:43 <lispy> the way things get moved around between versions gets old quick :)
19:53:47 <dons> I have:
19:53:48 <dons> #if __GLASGOW_HASKELL__ >= 606
19:53:48 <dons> import Data.Array hiding (array)
19:53:48 <dons> #else
19:53:48 <dons> import D
19:53:58 <dons> right. the type changes a bit
19:54:06 <dons> import Data.Array hiding (array,bounds)
19:54:06 <dons> #endif
19:54:16 <SamB_XP> dons: you show me an example, and maybe I'll try to fix that too...
19:54:31 <carp> sorry, where should i put that?
19:54:35 <dons> SamB_XP: I don't think it would hurt to be cautious and inline more things.
19:54:50 <dons> carp: no, i'm just showing you where to import bounds. now, since the type changes too, you'll need to tweak some things.
19:54:51 <SamB_XP> dons: yeah.
19:55:04 <carp> dons: oh, sorry
19:55:35 <dons> ?type bounds
19:55:37 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
19:55:51 <dons> ?type rangeSize
19:55:52 <lambdabot> forall a. (Ix a) => (a, a) -> Int
19:56:55 <SamB_XP> I really need to go to bed now
19:57:05 <SamB_XP> I have school in the morning...
19:57:53 <dons> oh, btw, for dev work don't compile with SplitObjs=Yes. ...
19:58:22 <dmead> hey dons
19:58:25 <carp> I've got that turned off
19:58:42 <SamB_XP> dons: hmm
19:59:35 <SamB> dons: why does it take so much RAM anyway?
20:00:21 <SamB> where do I do that?
20:01:31 <SamB> oh, right, mk/build.ml
20:01:34 <SamB> er, .mk
20:03:11 <SamB> dons: darcs really makes this much easier ;-)
20:07:19 <SamB> okay now I really am going to go to bed
20:17:39 <carp> ?t Data.Array.Base.bounds
20:17:39 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:17:53 <carp> ?type Data.Array.Base.bounds
20:17:54 <lambdabot> forall (a :: * -> * -> *) i e. (Data.Array.Base.HasBounds a, Ix i) => a i e -> (i, i)
20:18:00 <carp> ?type Data.Array.bounds
20:18:02 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
20:20:32 <carp> i have no idea what I'm doing :)
20:33:20 <Korollary> @index bounds
20:33:20 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff, Data.Array
20:33:33 <Korollary> @type Data.Array.bounds
20:33:34 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
20:33:46 <Lemmih> dons: (re-google t-shirts) Have you recieved your shipping info?
20:53:14 <dibblego> dons, you going to APLAS06?
20:56:36 <dibblego> can you have a module export everything except some explicit things?
20:57:05 <dibblego> module Foo (except bar) where ...
21:00:35 <dmead> yea
21:00:42 <dmead> import foo hiding (bar)
21:01:00 <dmead> oh export
21:01:01 <dmead> ah ah
21:01:11 <dmead> i think you just hide shit where you import it from
21:01:21 <dibblego> yeah I can't find a way
21:01:31 <dibblego> I will just explicitly export the stuff I want to
21:01:46 <dmead> you can exclude during import
21:01:48 <dmead> but not export
21:01:51 <dibblego> yeah I saw that
21:13:02 <ThreeQ> how do I prevent my program from exploding due to "Broken pipe"?
21:13:15 <ThreeQ> i think a socket's being closed remotely before it's finished writing data
21:13:29 <ThreeQ> and instead of throwing an exception the program just quits
21:14:12 <dmead> it just dissapears?
21:14:22 <dmead> or throws and error and quits
21:14:29 <dmead> i get that alot
21:14:31 <dmead> socket erros
21:14:33 <dmead> and poof
21:14:38 <ThreeQ> it prints "Broken pipe" and then quits
21:14:47 <ThreeQ> even though I'm catching exceptions
21:15:08 <dmead> weird
21:15:18 <dmead> maybe you should fix your pipes :)
21:15:55 <ThreeQ> well, it's a web server
21:16:06 <ThreeQ> and the problem only comes up when I lean on the reload button
21:16:40 <dmead> and it's in haskell i assume?
21:16:50 <ThreeQ> of course
21:16:59 <Lemmih> ThreeQ: Try: installHandler sigPIPE Ignore Nothing
21:17:04 <dmead> i'd guess that the underlying C routines need time to catch up
21:17:24 <dibblego> ThreeQ, are you writing the web server or the client?
21:17:29 <ThreeQ> server
21:17:55 <ThreeQ> ?hooglet installhandler
21:17:56 <lambdabot> Maybe you meant: hoogle hoogle+
21:18:00 <ThreeQ> ?hoogle installhandler
21:18:01 <lambdabot> GHC.ConsoleHandler.installHandler :: Handler -> IO Handler
21:19:09 <ThreeQ> hmm, what do I need to import to get installhandler?
21:20:17 <ThreeQ> oh, System.Posix.Signals, nevermind
21:22:48 <ThreeQ> Lemmih: that did it, thanks!
21:27:17 <dons> Lemmih: tshirts: not yet (sjanssen got his). internat. shipping details due tomorrow though.
21:27:22 <dons> dibblego: yes :) i'll be at aplas
21:30:51 <dons> now, just hope my new wireless card arrives before I leave :|
21:32:42 <dibblego> in http://haskell.org/haskellwiki/Roll_your_own_IRC_bot, why do you have to convert from Integral to Num and then to PortNumber?
21:32:51 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
21:33:21 <dibblego> ?index connectTo
21:33:22 <lambdabot> Network
21:34:26 <dons> oh, that's for hugs
21:34:29 <dons> ghc doesn't require it
21:34:36 <dons> but hugs ships with an older Network library
21:34:40 <dons> that uses Word16 for PortNums
21:34:41 <dons> hence
21:34:52 <dons> > fromIntegral (6697 :: Word16) :: Int
21:34:53 <lambdabot>  6697
21:35:06 <dons> so its purely for compat reasons, and is a nop on ghc
21:35:15 <dibblego> how does it look for ghc?
21:35:33 <dibblego> there is only one data ctor for PortNumber that is Word16
21:36:06 <dons> ?hoogle PortNumber
21:36:07 <lambdabot> Network.PortNumber :: PortNumber -> PortID
21:36:07 <lambdabot> Network.PortNumber :: data PortNumber
21:36:07 <lambdabot> Network.Socket.PortNumber :: newtype PortNumber
21:37:24 <dibblego> I want to write a web server
21:37:42 <dons> cool. you could start with HWS or HAppS' webserver, for examples of high perf concurrent servers
21:37:48 <dons> bringert might have written one too?
21:37:59 <dibblego> neither will install for me - since HaXML won't
21:38:02 <dons> happs does really well, performance wise, I think.
21:38:12 <dons> musasabi really tuned it nicely
21:38:20 <dibblego> actually, I tried HAppS and hope, but they both require HaXML, which I gave up trying to install
21:38:31 <dons> persistence is the key
21:38:39 <dibblego> I'd hit a dead end
21:38:43 <dibblego> I'll try again anyway
21:39:06 <scsibug> dibblego: I wrestled with HaXML for quite awhile before getting it (and then HAppS) up and running.  Willing to help you out if I can.
21:39:18 <dibblego> HaXML doesn't use cabal is the problem :)
21:40:00 <scsibug> what do you mean exactly?  I have HaXML 1.13.2 installed via cabal
21:40:25 <dibblego> wtf? the README says to configure, make, make install
21:41:17 <dibblego> http://rafb.net/paste/results/QrMTuD92.html
21:41:24 <dons> yeah, I think it uses cabal now.
21:41:33 <dons> at least when I tried it.
21:41:36 <scsibug> someone might have to correct me, but I used the Setup.hs configure, build, install route
21:41:51 <dibblego> ok, there is a Setup.hs file in the root dir., maybe I need to figure that out
21:41:55 <scsibug> although I think I went through what you did before figured that out
21:42:03 <scsibug> runhaskell Setup.hs configure
21:42:04 <dibblego> you mean I need to do a ls :)
21:43:14 <dmead> hey dons
21:43:18 <dmead> i have a question for ya
21:44:39 <dibblego> all the "No foo found" messages mean I need to install foo?
21:44:53 <dons> dmead: yeah?
21:46:43 <dmead> how do you create an abstraction for constructor?
21:47:20 <dmead> i have:  data Expression a = P | Q | Disj (Expression a) (Expression a)
21:47:28 <dmead> right
21:47:31 <dmead> so thats in prefix
21:47:39 <dmead> i also have a seperate module in infix
21:48:06 <dmead> how can i create an alias for say (Disj a b)
21:48:19 <dmead> like makeDisj(a,b) = (Disj a b)
21:48:30 <dmead> but i need to be able to pattern match against it
21:48:40 <dmead> and i suppose thats a function
21:48:42 <Lemmih> dmead: You can't.
21:48:44 <dmead> which rules out pattenr matching
21:48:52 <dmead> yea?
21:49:53 <dons> yeah, if you hide the constructor, you can't pattern match anymore
21:50:07 <dons> so, you can export a 'smart constructor' as your makeDisj is known
21:50:07 <dmead> hmm
21:50:19 <dons> if you also export the underlying data type, then you can pattern match
21:50:31 <dons> but you won't be able to ensure they only use the 'makeDisj' function
21:50:44 <dmead> well i want ti mimmic something i learned to do in lisp
21:51:01 <dmead> to abstract data by hiding different notations in the same make-xxxx name
21:51:10 <dons> yep. good idea.
21:51:19 <dons> that's what a smart constructor would do.
21:51:22 <dmead> ah
21:51:44 <dons> so, module M (T, makeA) where {  wdata T = A | B. makeA = A :: T  ]
21:51:54 <dons> i.e. export the type T abstractly, hiding the constructors.
21:52:01 <dons> then the _only_ way to make an A , is to use makeA
21:52:07 <dmead> ahh
21:52:15 <dons> if you don't wish to control the user in this way, then you can export T(..)
21:52:22 <dons> and just rely on convention to use makeA
21:52:36 <dons> oh, s/wdata/data :)
21:52:54 <dibblego> is a bazillion compile-time warnings normal for compiling HaXML?
21:53:05 <dmead> well ive got some logic rules i want to write by just using the abstracted datatypes
21:53:13 <dons> yeah. that's a good idea
21:53:21 <dons> i often write; io = liftIO, for similar reasons
21:53:37 <dmead> hmm
21:53:38 <dons> so, just export your 'smart constructor'
21:53:45 <dons> then you still get pattern matching
21:53:56 <dons> only if you also hide the constructors, do you lose pattern matching
21:54:14 <dmead> i don't quite follow the module example you did
21:54:25 <dmead> module M (T,makeA)
21:54:30 <dmead> (T,makeA)?
21:54:43 <dons> that exports the type T, and the function makeA
21:54:46 <dmead> ah
21:54:51 <dons> but not the constructors of the type T, namely A and B
21:55:09 <dons> so that lets you use makeA to build things of type T, but not let you use 'A' directly
21:55:20 <dons> however, if you :   module M (T(..), makeA where ...
21:55:29 <dons> then you also get the constructors, A and B, available
21:55:34 <dons> along with makeA
21:55:37 <dmead> right
21:55:57 <dons> this constructor-hiding idea is documented here
21:56:02 <dons> ?wiki Smart_constructors
21:56:02 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
21:56:16 <dmead> cool, thanks
21:56:27 <dons> in the context of controlling access to a data structure
21:57:05 <scsibug> dibblego: yep, it threw tons of warnings for me (shadowing bindings, non-exhaustive patterns, etc)
21:57:24 <dibblego> scsibug, thanks, seems to install fine with cabal
21:57:33 <scsibug> congrats :)
21:57:37 <dibblego> scsibug, I'll stop reading those README files :)
21:57:53 <dibblego> I'll have to remember where I was when I gave up on it now
21:58:03 <dons> cool. that was easy
21:58:05 <dons> scsibug++
21:58:19 <dibblego> cabal++
22:04:08 <dmead> hmm
22:04:08 <dmead> ok
22:04:09 <dmead> with
22:04:19 <dmead> i have:  data Expression a = P | Q | Disj (Expression a) (Expression a)
22:04:22 <dmead> and i tried
22:04:35 <dmead> newtype Mkdisj a = Disj
22:04:46 <dons> Disj isn't a type.
22:05:05 <dmead> i know, i thought i could make it right to a constructor
22:05:08 <dons> ok. any, proceed. what else did you do?
22:05:10 <dmead> *map
22:06:06 <dmead> nothin, just thinking
22:06:11 <dmead> this seems foggy in haskell
22:06:19 <dons> data Expression a = P | Q | Disj (Expression a) (Expression a)
22:06:19 <dons> mkDisj :: Expression a -> Expression a -> Expression a
22:06:19 <dons> mkDisj a b = Disj (Expression a) (Expression b)
22:06:24 <dons> for example
22:06:40 <dmead> i tried that
22:06:40 <dons> now, say you know what kind of type you want to apply Expression to, you could;
22:07:25 <dons> though, hang on .. what's the 'a' type parameter doing?
22:07:39 <dons> since the leaves of your tree are just P and Q, what good is the 'a' type?
22:07:47 <dmead> hmm
22:07:51 <dmead> i guess i don't really need it
22:07:52 <dmead> hehe
22:07:53 <dons> do you have some type, say String, you want to store in the AST?
22:08:06 <dmead> nope
22:08:08 <lispy> maybe it's meant as a phantom type?
22:08:25 <dons> i.e. data GenExp a = P a | Q a | Disj (GenExp a) (GenExp a) ; type Exp = GenExp String ; ...
22:08:29 <dons> (a common idiom)
22:08:43 <dons> (since it lets you annotate your syntax tree with any type, just by writing a new type Exp = ...
22:08:59 <dibblego> HAppS installed, thanks
22:09:05 <dons> cool
22:09:33 <dmead> hmm
22:09:57 <dmead> what DO i need the 'a' for...
22:11:05 <dons> a suggestion:
22:11:07 <dons> module M where
22:11:07 <dons> data Exp = P
22:11:07 <dons>          | Q
22:11:07 <dons>          | Exp :|: Exp
22:11:09 <dons> mkP        = P
22:11:12 <dons> mkQ        = Q
22:11:15 <dons> mkDisj a b = a :|: b
22:11:17 <dons> -- at its very simplest
22:11:25 <dibblego> if I compile a module x with ghc which produces x.hi and x.o, how do I link another module against the x module?
22:11:46 <dmead> hmm
22:11:46 <dons> then, if you need to annotate the AST, have instead a data GenExp a = ..., with a concrete type to instantiate your tree, e.g. type Exp = GenExp String
22:11:48 <Lemmih> dibblego: 'import X'?
22:12:03 <dibblego> Lemmih, but how does the compiler resolve the location of that module?
22:12:15 <Lemmih> dibblego: Are you using --make?
22:12:22 <dibblego> Lemmih, yes
22:12:22 <dons> it looks it up in the linker path
22:12:30 <dibblego> oh right
22:14:42 <dibblego> how does ghci find modules?
22:14:50 <dibblego> such as HApps?
22:15:30 <Lemmih> It looks in the package.conf file.
22:17:04 <dibblego> ~/packages.conf ?
22:17:37 <Lemmih> `ghc-pkg list` can tell you.
22:17:45 <dibblego> I think I found it, thanks
22:22:19 <dmead> hey dons i put your suggestion into my code
22:22:51 <dmead> how do i convert instance Show a => Show (Expression a) where
22:22:57 <dmead> show x = showExpression x
22:23:03 <dmead> (i define showExpression)
22:23:21 <dmead> if i just delete the 'a' variable from the declaration
22:23:34 <dmead> it says "haskell 98 does not support tagged classes"
22:23:36 <Lemmih> instance Show Expression where ...
22:24:33 <dons> welcome llama33
22:24:38 <dmead> thanks lemmih
22:25:32 <dmead> whats a tagged class btw ;p
22:26:41 <dons> is that a hugs error?
22:26:46 <dons> i've not seen that in ghc
22:27:21 <llama33> mhello
22:28:25 <dons> llama32: learning haskell? or you know it already?
22:29:13 <llama32> dons: neither really, i just like to keep up with the news in the functional world, i'm in here in case interesting conversation comes up :)
22:29:48 <dons> heh ok. well, feel free to learn it if you want :)
22:29:53 <dons> here, a tasty lambda:
22:29:55 <llama32> anyway i must do the dishes before someone bites my head off
22:29:59 <dons> > map (\x -> x ^ 2) [1..]
22:30:01 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
22:30:52 * llama32 is more into lisp... not a huge fan of languages that can't be learnt during TV ad breaks :)
22:31:12 <dons> you can learn haskell during ad breaks :)
22:31:14 <dons> here:
22:31:47 <dons> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10
22:31:49 <lambdabot>  3628800
22:32:01 <dons> if you know lisp you already know 2/3 haskell anyway
22:32:25 <llama32> yeah but you can learn scheme in the half-millisecond interval between each ad :)
22:32:27 <dons> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 42
22:32:28 <lambdabot>  1405006117752879898543142606244511569936384000000000
22:32:43 <llama32> reading code != writing code :)
22:32:50 <Eidolos> Just copy and paste it :)
22:32:53 <dons> write some code then! :)
22:33:00 <llama32> everyone can read Java, but nobody can really write it :)
22:33:21 <dibblego> no they can't
22:33:27 <dibblego> very few people can read Java
22:33:31 <dmead> >[1..10]
22:33:33 <dons> i wonder why people consider scheme easy to teach. haskell is also used as a beginner's language.
22:33:37 <dmead> o0
22:33:46 <Eidolos> > let fib n = if n < 2 then 1 else fib(n-1) + (n-2) in fib 42
22:33:47 <lambdabot>  821
22:33:52 <dons> but scheme does have a reputation for being good for non-programmers
22:33:57 <Eidolos> > let fib n = if n < 2 then 1 else fib(n-1) + fib(n-2) in fib 42
22:34:02 <lambdabot> Terminated
22:34:05 <dons> its probably just the FP though.
22:34:17 <Eidolos> I was told Haskell automatically memoized functions. :(
22:34:30 <dons> it does.
22:34:41 <dons> but depends on how you write it ....
22:34:51 <Eidolos> Oh? Why?
22:35:05 <Pseudonym> ?google memoising cafs
22:35:09 <lambdabot> http://tunes.org/~nef/logs/haskell/05.02.16
22:35:14 <Pseudonym> ?google memoizing cafs
22:35:16 <lambdabot> http://tunes.org/~nef/logs/haskell/04.05.10
22:35:16 <llama32> because scheme is so damn simple? "this is a function. this is let. you have now graduated scheme."
22:35:21 <Pseudonym> Hmmm.
22:35:27 <Pseudonym> ?google memoizingcafs
22:35:30 <lambdabot> http://tunes.org/~nef/logs/haskell/05.02.03
22:35:42 <Pseudonym> Doesn't like the wiki apparently.
22:36:02 <dons> > fix $ \f -> 1 : 1 : zipWith (+) (tail f) f
22:36:03 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:36:11 * llama32 actually leaves the computer to do the dishes... for real this time, i swear...
22:36:13 <dons> llama32: heh
22:36:22 <dons> this is a function: f x = x + 1
22:36:27 <dons> this is a let:  let f x = x + 1
22:36:29 <Heffalump> your computer can do the dishes? wow.
22:36:53 <llama32> bahahaha :)
22:37:06 <dibblego> dishes!
22:37:11 <lispy> > fix (\ fac n -> if n == 0 then 1 else n * fac (n-1)) 42
22:37:12 <lambdabot>  1405006117752879898543142606244511569936384000000000
22:37:44 <lispy> fix is so dreamy :)
22:38:00 <llama32> dons: well... i don't know... scheme just seems to be so simple :) probably because there is no infix and other syntax rules
22:38:07 <dibblego> ?type fix
22:38:09 <lambdabot> forall a. (a -> a) -> a
22:38:17 <dibblego> ?index fix
22:38:18 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
22:38:31 <dibblego> which fix are you using?
22:38:37 <lispy> ?type fix (\ fac n -> if n == 0 then 1 else n * fac (n-1))
22:38:39 <lambdabot> forall a. (Num a) => a -> a
22:38:44 <llama32> "(a -> a) -> a" - none of that in scheme either
22:38:44 <lispy> dibblego: Control.Monad
22:39:18 <dibblego> llama32, sucks that hey? :)
22:39:25 <lispy> fix f = f (fix f)
22:39:47 <lispy> ?type let fix' f = f (fix' f) in fix'
22:39:48 <lambdabot> forall t. (t -> t) -> t
22:40:14 <dibblego> @doc fix
22:40:15 <lambdabot> fix not available
22:40:28 <dibblego> @doc Control.Monad
22:40:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
22:40:30 <lispy> so above fix (\fact ...) = fact (fix fact)
22:40:51 <dibblego> I see no fix function on that page
22:41:16 <Pseudonym> > L.fib 0
22:41:17 <Pseudonym> > L.fib 1
22:41:18 <lambdabot>  0
22:41:19 <lambdabot>  1
22:41:20 <Pseudonym> > L.fib 2
22:41:21 <lambdabot>  1
22:41:22 <lispy> i just gave enough of the module name to be unabiguous
22:41:24 <Pseudonym> > L.fib 3
22:41:26 <lambdabot>  2
22:41:32 <lispy> ?doc Control.Monad.Fix
22:41:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Fix.html
22:41:38 <Pseudonym> [ L.fib i | i <- [0..42 ] ]
22:41:52 <Pseudonym> > [ L.fib i | i <- [0..42 ] ]
22:41:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:42:03 <Pseudonym> > L.fib 42
22:42:05 <lambdabot>  267914296
22:42:12 <lispy> > (fix $ const L.fib) 3
22:42:13 <lambdabot>  2
22:42:23 <lispy> ?pl fix $ const L.fib
22:42:24 <Pseudonym> OK.
22:42:24 <lambdabot> L
22:42:31 <lispy> ?pl fix $ const fib
22:42:31 <lambdabot> fib
22:42:59 <Pseudonym> > L.fib 1000000
22:43:04 <lambdabot> Terminated
22:43:11 <Pseudonym> > L.fib 100000
22:43:14 <lambdabot>  2597406934722172416615503402127591541488048538651769658472477070395253454351...
22:43:32 <Pseudonym> > length . show $ L.fib 100000
22:43:34 <lambdabot>  20899
22:43:38 <Pseudonym> Woo.
22:43:53 <lispy> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) !! 1000000
22:43:57 <lambdabot> Terminated
22:44:02 <lispy> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) !! 100000
22:44:03 <Pseudonym> Ha!
22:44:05 <lambdabot>  Terminated
22:44:06 <Pseudonym> Mine faster than yours.
22:44:11 <lispy> nice
22:44:29 <lispy> usually fibs is faster because of the memoization
22:44:42 <Pseudonym> This is faster because it's O(log n).
22:44:59 <lispy> what is the def'n?
22:45:15 <Pseudonym> fib' 0 = (0,1)
22:45:37 <Pseudonym> fib' n = if n `mod` 2 == 0 then (let { (a,b) = fib' (n `div` 2 - 1) ; c = a + b ; c2 = c*c } in (c2 - a*a, c2 + b*b)) else (let { (a,b) = fib' ((n-1) `div` 2) ; c = a + b; a2 = a*a } in (b*b + a2, c*c - a2))
22:45:45 <Pseudonym> fib n = fst (fib' n)
22:45:47 <lispy> heh
22:46:05 <lispy> that's pretty nasty by comparison
22:46:19 <Pseudonym> It looks nicer when it's laid out properly.
22:46:24 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Fibonacci.hs
22:46:26 <lispy> right
22:46:28 <lambdabot> http://tinyurl.com/g2436
22:46:32 <Pseudonym> And that's O(log n) _and_ memoed!
22:46:46 <lispy> cool
22:47:01 <Pseudonym> Only the first 200 or so are memoed.
22:47:14 <Pseudonym> The memo table is then used as a base case for the other algorithm.
22:47:21 <dibblego> let fib 0=0; fib 1=1; fib 2=1; fib 3=2; fib 4=3;fib 5=5 in fib 5 -- I will woop yo ass!
22:47:26 <lispy> Pseudonym: have you read any papers by Paul Cull about fibs?
22:47:32 <Pseudonym> Nope.
22:47:50 <lispy> Pseudonym: he's a theoretical CS prof at my school that studies computing fibs
22:47:58 <lispy> really cool guy
22:47:59 <Pseudonym> Cool.
22:48:11 <lispy> he actually founded the CS department at my school
22:48:14 * Pseudonym looks him up
22:48:22 <Pseudonym> Oh, he's a neck beard!
22:48:25 <Pseudonym> He must use Unix!
22:48:31 <lispy> yup!
22:48:46 <lispy> he loks like gimmlie(sp?) from LoTR
22:49:00 <lispy> he's short, stocky and has a huge beard
22:49:31 <lispy> Pseudonym: so what do you use fibs for?
22:50:04 * lispy should be doing homework
22:50:19 <lispy> but math/haskell is more interesting...
22:51:34 * lispy goes back to reading about how OO is so wonderful
22:52:04 <Pseudonym> lispy: For fun, of course.
22:52:28 <Pseudonym> I do use factorials seriously, though.
22:53:25 <lispy> really?
22:53:28 <lispy> for what?
22:53:40 <Pseudonym> Frequency distributions
22:53:50 <Pseudonym> To make models for compression.
22:53:56 <lispy> oh neato
22:54:12 <lispy> so you're big into information theory?
22:54:19 <lispy> professionally?
22:55:46 <Pseudonym> Used to be.
22:55:50 <Pseudonym> Well.. text retrieval.
22:56:06 <Pseudonym> I still do it occasionaly when I need to.
22:56:37 <dibblego> can you tell change lambdabot to do more than 500 tests with ?check ?
22:57:01 <lispy> i don't think so
22:57:15 <dibblego> or with ?somethingelse ?
22:57:24 <lispy> if you have the source you could change it
22:57:33 <lispy> spend in a patch to add that
22:57:41 <dibblego> the configMaxTest attribute(?) of the Config
22:57:55 <lispy> right
22:58:23 <dibblego> do you happen to know the meaning of the other attributes?
22:58:36 <dibblego> I spent a good deal of time trying to find documentation on them
23:01:39 <lispy> what are they again?
23:01:53 <lispy> configMaxTest is the only one i've tested extensively
23:02:22 <dibblego> configMaxTest, configMaxFail, configSize,configEvery
23:02:35 <lispy> ah right
23:02:44 <lispy> seems like the haddock or the source explains them
23:02:56 <dibblego> I looked in both
23:03:25 <lispy> iirc, configMaxFail has to do with the 'arguments exhausted', it's how many tries before it moves on to the next test
23:03:34 <lispy> i don't remember the other two
23:06:58 <dibblego> it seems difficult sometimes to write an expression for quickcheck that is not defined in terms of the expression that you wish to test
23:10:21 <dblhelix> @seen SyntaxNinja
23:10:22 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 2d 4h 56m 13s ago, and .
23:14:36 <dibblego> what's the right way to append to a list?
23:14:55 <Lemmih> (++)
23:15:01 <dibblego> that was my guess
23:15:08 <dibblego> but if you only have one element?
23:15:21 <dibblego> "abc" 'd' and you want "abcd"
23:15:32 <Lemmih> > "abc" ++ ['d']
23:15:32 <dibblego> > "abcd" ++['d']
23:15:34 <lambdabot>  "abcd"
23:15:35 <lambdabot>  "abcdd"
23:15:39 <dibblego> ok thanks
23:15:49 <dmead> >"abc" ++ "d"
23:16:00 <dmead> why doesn't lambdabot love me?/
23:16:07 <dibblego> well I was assuming any type
23:16:13 <dibblego> > [1,2,3] ++ [4]
23:16:14 <lambdabot>  [1,2,3,4]
23:16:31 <dmead> >
23:16:36 <dmead> >"what"
23:18:40 <psi> > "dmead"
23:18:41 <lambdabot>  "dmead"
23:18:52 <psi> oh, he left.
23:30:07 <lispy> ?quote largos [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
23:30:08 <lambdabot> largos [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you." hasn't said anything memorable
23:30:17 <lispy> ?remember largos [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
23:57:32 <Lemmih> Tasks: 16339 total,   5 running, 120 sleeping,   0 stopped, 16214 zombie
23:58:08 <Lemmih> Zombie invasion!
23:58:33 * Patterner pours holy water over Lemmih
