00:00:08 <astrolabe> good question!
00:00:32 <monstre> well?
00:01:05 <astrolabe> I don't know.  Seems that they should be to me.
00:02:15 <lispy> monstre: i think they were in a previous version of the haskell standard
00:02:27 <lispy> monstre: but sadly they currently are not setup that way
00:02:45 <monstre> it's like monad comprehensions then?
00:03:23 <sjanssen> monstre: some claim that it's too burdensome to write out a Functor instance for every Monad
00:05:43 <monstre> makes sense, thanks sjanssen
00:06:05 <monstre> that's a kind of laziness I'm familiar with :)
00:06:18 <sjanssen> heh
00:07:12 <ThreeQ> I gues technically it could derive the functor instance from the monad implementation but there's no real syntax for doing that
00:07:17 <ThreeQ> s/gues/guess
00:08:19 <lispy> there is a deriving Monad extension but i don't know how it works
00:08:51 <derelm> what's the easiest way to generate random numbers between 0 and 1 in haskell?
00:09:24 <vegai> dons: You around? Building hs-plugins-1.0rc1 with ghc-6.6 fails. Known problem?
00:09:27 <sjanssen> lispy: are you talking about newtype deriving?
00:10:29 <vegai> dons: rc0, I mean.
00:11:01 <lispy> sjanssen: i don't know, but probably.  I just saw it in some code once and asked about it...i was told it was an extension
00:16:38 <Cale> derelm: probably randomRIO
00:16:52 <Cale> depends on what you're doing
00:17:15 <derelm> Cale: i'm rather new to haskell and don't know exactly how to do it
00:17:24 <Cale> or something like
00:17:35 <Cale> xs <- randomRs (0::Integer,1)
00:17:42 <Cale> er
00:17:45 <Cale> no
00:17:55 <Cale> g <- newStdGen
00:18:11 <Cale> let xs = randomRs (0::Integer,1) g
00:18:30 <Cale> will give you an infinite list of pseudorandom numbers between 0 and 1
00:18:35 <Cale> (integers)
00:18:48 <Cale> or if you replace that with Double
00:18:53 <Cale> you'll get doubles
00:18:53 <derelm> arg, i missed that all these stdgen functions return IO
00:19:11 <derelm> Cale: thanks!
00:19:25 <Cale> yeah, you can only create random generators from IO, but once you have one, you can pass it into pure code
00:19:32 <Cale> no problem
00:31:48 <Lemmih> Subakh ul kuhar, Muad_Dibber.
00:32:04 <Muad_Dibber> Let the spice flow freely.
00:39:19 <monstre> Is there anything like a very high level overview of monads available anywhere?
00:39:55 <monstre> I think I have some idea how they actually work, I just don't know what they're for
00:41:14 <Cale> In practice, they're for constructing somewhat-imperative embedded languages where certain side effects are available
00:42:08 <Cale> (If that makes sense)
00:42:51 <monstre> should I just set aside the idea of understanding monads in general for now and just focus on particular monads (IO, [], Maybe, etc.) ?
00:43:08 <Cale> That would probably help
00:43:39 <Cale> Once you understand a few of those, then the big picture starts coming together a bit better.
00:44:23 <monstre> Is defining new monads all that common anyway?
00:44:43 <Cale> and then you can look at things like monad transformers, which give you convenient ways to build up new monads from old ones, and there's a decent strategy I could show you some examples of to build up large monads and then shrink them down to the size you want
00:44:58 <Cale> I think it's a little uncommon, but it's a really effective way to do some things.
00:46:12 <Cale> You can essentially create this ideal miniature language which has just the right features for solving your problem, and may even help to make sure that your data remain consistent through some tricky algorithm.
00:46:33 <derelm> Cale: sorry, still having problems with random number generation. i get "type error in final generator" ([Int] does not match IO a ...
00:47:08 <Cale> derelm: hmm, are you using let to define the value with randomRs?
00:47:29 <Cale> (randomRs doesn't return an action, but a list)
00:47:44 <Cale> If you just want an action you can run to get a random number, have a look at randomRIO
00:49:13 <derelm> Cale: hmm, i do stuff in a do block - but in the end i want a single value between 0 and 1
00:49:52 <Cale> derelm: well, you can pass the random numbers off to your pure code from IO, but then you have to do some IO with the results if you want to see them
00:50:28 <derelm> i am lost
00:50:41 <Cale> okay, are you familiar with how IO works in Haskell in the first place?
00:51:06 <derelm> well, a little - guess i'll reread these chapters
00:51:11 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
00:51:14 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/y6rwwu
00:51:29 <Cale> read that, it's short and should provide some structural idea of what's going on with IO
00:51:39 <derelm> ok, will do
00:52:48 <Cale> In the end, the whole thing isn't very complicated, but it's a rather different way of thinking about things that takes a little getting used to.
00:56:52 <monstre> doesn't unsafePerformIO defeat the entire purpose of the IO monad?
00:57:07 <Cale> monstre: indeed, and that's why you should never use it
00:57:47 <monstre> If I should never use it, why does it exist?
00:58:15 <Cale> Well, you can think of it as a way to add new primitives to the Haskell evaluation mechanism.
00:58:19 <sjanssen> unsafePerformIO can also defeat the entire purpose of having a type system
00:58:35 <Cale> It's also useful when doing FFI
00:58:52 <Cale> for turning foreign calls which you know are pure into pure functions
01:00:46 <Cale> but it's definitely not something you use casually, it's more of something you use with the same gravity and care you'd take in modifying the compiler.
01:01:21 <Cale> (without the whole inconvenience of actually doing so)
01:01:51 <derelm> mhh
01:02:27 <Cale> You can actually write things which are safe to use that use it though.
01:03:09 <Cale> For instance, one thing which can be constructed is a function  memo :: (Ord a) => (a -> b) -> (a -> b)
01:03:36 <monstre> I was actually wondering how you would go about doing memoization in Haskell...
01:04:00 <derelm> Cale: i am not exactly sure if that page about IO really helped - i mean, i still don't know why i get error of mismatching type
01:04:13 <Cale> derelm: well, let's actually look at your code :)
01:04:17 <Cale> lisppaste2: url
01:04:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:04:51 <rahikkala> http://www.haskell.org/~simonmar/bib/webserverjfp_abstract.html <- this thing implements global mutable state with unsafePerformIO... It seems nonportable, though (they used GHC-specific options for disabling some optimisations to get it to work)
01:04:54 <lambdabot> http://tinyurl.com/ymdbls
01:05:55 <Cale> rahikkala: yeah, unsafePerformIO basically has a tendency to do that, since you're really starting to rely on the exact way in which pure code evaluation is carried out
01:06:10 <Cale> and optimisations too
01:06:43 <Cale> you often have to explicitly turn off optimisation passes for variables you define using it, since otherwise the effects might not occur in cases where you want them
01:06:53 <lisppaste2> derelm pasted "random number generator" at http://paste.lisp.org/display/28111
01:07:13 <Cale> so really, it ought to be called simonPerformIO
01:07:29 <Cale> which means you only use it if your first name is Simon
01:07:38 <Cale> ;)
01:08:01 <Cale> derelm: you ended on a let
01:08:10 <Cale> derelm: have your action return something
01:08:14 <Cale> oh
01:08:22 <Cale> there is an in there
01:08:36 <derelm> sure ... so it basically should return xs
01:08:44 <monstre> Is there anything like the memo function that allows you to put print statements in otherwise pure code for debugging puposes?
01:08:48 <Cale> you can delete the 'in' part of the let, it can be elided inside do-blocks
01:08:55 <derelm> at least i was hoping so
01:09:01 <ThreeQ> it's trying to bind xs to the stuff before it
01:09:01 <Cale> (the bindings scope over the rest of the block)
01:09:11 <Cale> and add 'return xs' as a third line
01:09:25 <Cale> xs isn't an action
01:09:33 <derelm> argh
01:09:35 <Cale> so it's not allowed as a statement in a do block
01:09:44 <Cale> so you need to 'return' it
01:10:03 <Cale> monstre: yeah, and in fact, that's provided in Debug.Trace in GHC
01:10:27 <monstre> thanks, I thought I had read something about that
01:11:00 <derelm> ok, now i no longer get an error - but i still wonder if it'll work...
01:11:04 <monstre> so I guess I don't have any reason to use unsafePerformIO anymore :)
01:11:07 <Cale> monstre: though it's only really useful for debugging, since the printouts happen in a semi-unpredictable order. (Really, it's just the order of evaluation, but optimisations can affect that)
01:12:38 <Cale> derelm: you might check out this: http://www.haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
01:12:42 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/zdvsy
01:13:11 <Cale> derelm: It's where I gave a fairly detailed explanation about the use of random numbers in Haskell in an answer to a guy's question on the wiki.
01:13:30 <derelm> ok. thanks cale
01:14:25 <Cale> I should probably turn it into a proper tutorial on random generation in Haskell and add it to the new wiki
01:18:49 <monstre> I don't suppose there's a way to use random numbers in pure code, is there?
01:18:56 <Cale> well, yes
01:19:12 <monstre> without carrying a seed around?
01:19:14 <Cale> You create a generator in IO, and pass it off to the pure code
01:19:29 <Cale> you have to pass the generator (effectively a seed) around though
01:19:41 <monstre> so I guess that's a no then
01:19:49 <Cale> You can also work in another monad which keeps track of the seed for you
01:19:56 <Cale> but still doesn't permit full IO
01:20:12 <Cale> http://haskell.org/haskellwiki/NewMonads/MonadRandom
01:20:15 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/fs3av
01:20:33 <Cale> there's an example of its use on that WorkingWithRandomNumbers page
01:20:38 <monstre> I'm still a little uncomfortable around monads, but thanks
01:21:20 <monstre> I like to keep my category theory and my hello worlds separate
01:21:24 <Cale> hehe :)
01:21:52 <monstre> perhaps Haskell is not the best language for me ;)
01:22:03 <Cale> You don't really have to understand the full category theoretic generality of it to understand IO, or a particular monad though.
01:22:37 <Cale> Basically, it's possible to just know about specific monads, which behave like small imperative languages.
01:23:19 <Bobstopper> monstre: using monads is exactly like using imperative programming only it affects the type of your function. Start from there and you should be able to use it without needing to understand any theory behind it.
01:23:58 <Cale> Creating new monads involves a touch more theory, but not really too much.
01:24:40 <Bobstopper> monstre: monads are a scary (read: unfamiliar) name for a fairly simple mechanism. Don't be too intimidated :)
01:25:47 * Bobstopper thinks maybe there needs to be more focus on using monads in some of these monad tutorials rather than launching right into how monads work and are constructed
01:25:58 <Cale> On the mathematical side of things there's the nice thing going on that the category we're working in is completely fixed (it's Haskell types and functions), so the definition could just be specialised to Haskell, at which point it's just an ordinary programming technique, and not really anything too abstract.
01:26:45 <Cale> But new programming techniques still seem hard enough for people to learn :)
01:27:00 <Cale> Look, OO took what, 15, 20 years?
01:27:24 <Maddas> 'learn' and 'gain wide-spread adoption' isn't quite the same, if you ask me.
01:27:31 <Cale> well, yes
01:27:57 <Maddas> (At least I didn't need 15-20 years to grasp the basics of OO)
01:27:59 <Cale> I'm using the time to wide-spread adoption as a crude measure for the difficulty of learning for the masses.
01:28:18 <monstre> seriously though, is there any way to hide a randomized algorithm inside a pure function?
01:28:23 <Maddas> Cale: That's a silly measure. It assumes that everything is a desirable change.
01:28:38 <monstre> say I really wanted to write a bogosort for whatever reason
01:28:42 <Maddas> (equally desirable, too)
01:29:00 <Cale> monstre: unsafePerformIO, and hope that the compiler doesn't optimise :)
01:29:25 <monstre> and what if it does?
01:29:28 <Cale> (or force it not to make certain simplifications, like turn off inlining)
01:29:35 <Cale> but it's really not such a good idea
01:29:41 <Maddas> monstre: randomized and pure are conflicting requirements, as I understand it :-)
01:30:02 <derelm> ever seen a spaghetti-error like that:  Instances of (Floating (IO Float,IO Float), Num ((IO Float,IO Float) -> (IO Float,IO Float))) required for definition of mutateCoords?
01:30:11 <Maddas> (Assuming you don't pass along the seed explicitly)
01:30:23 <Cale> You're breaking one of the main properties that the compiler and runtime mechanism are assuming when manipulating your code.
01:30:33 <monstre> but sort is a pure function, is it not?
01:30:50 <Cale> well, yes
01:30:52 <monstre> why should it matter what kind of algorithm it uses?
01:31:08 <Cale> Your implementation is not pure.
01:31:09 <monstre> and why should it be reflected in the type signature?
01:31:10 <Maddas> monstre: The insides must be pure, too.
01:31:26 <Cale> You can construct a pure generator if you supply a seed.
01:31:56 <Cale> which you can build with (mkStdGen 0)
01:32:40 <Cale> and then you could even use the Random monad to handle the passing around of that generator, and you'll get a pure function in the end
01:33:08 <Cale> The only thing you can't do is get a seed from the system entropy pool.
01:34:17 <monstre> what I want is a function sort :: Ord a => [a] -> [a] that uses random numbers
01:34:26 <monstre> is that possible?
01:34:26 <Cale> right, and you can do that
01:34:33 <Cale> with pseudorandom numbers
01:34:39 <Cale> they'll be the same numbers every time
01:34:39 <Syzygy-> @hoogle PL
01:34:40 <lambdabot> Data.FiniteMap.plusFM :: Ord key => FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
01:34:41 <lambdabot> Data.FiniteMap.plusFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> FiniteMap key elt -> FiniteMap key elt
01:34:41 <lambdabot> Foreign.Ptr.plusPtr :: Ptr a -> Int -> Ptr b
01:34:48 <ThreeQ> you could use unsafeperformIO if you can prove that the function is referentially trasparent
01:34:57 <ThreeQ> *transparent
01:35:02 <Maddas> monstre: Consider: If the function contained a bug, allowing the random numbers to influence the result, the function wouldn't be pure.
01:35:26 <Maddas> monstre: What you're asking is for the compiler to prove that your sort function does not have that property, which I think is a little much to ask for :-)
01:36:07 <Cale> You could actually write the entire sort in IO, and then apply unsafePerformIO
01:36:18 <Cale> and that would be relatively safe
01:36:37 <Cale> except you're taking unnecessary risks if your code has a bug
01:37:32 <monstre> all I'm saying is that if I'm willing to accept this proof obligation, it should at least be possible for me to write such a function
01:37:43 <Maddas> monstre: Yes, as Cale said.
01:37:43 <Cale> but you can get a pseudorandom generator without doing any IO, just pick a seed to start with.
01:37:57 <ThreeQ> monstre: you can; that's what unsafePerformIO is for
01:38:06 <Maddas> monstre: But if you do that, you also accept that any bug in the code may cause havoc, and that it's not the compiler's job to help you there.
01:38:15 <Maddas> (To exaggerate ;-)
01:38:29 <monstre> agreed :)
01:38:44 <Cale> Basically, if you ever feel like doing that, you should look really very hard for another way to write your program.
01:38:44 <monstre> I just wanted to know if there was a way, that's all
01:39:04 <Cale> It is possible, but it's stupidly dangerous.
01:39:18 <Syzygy-> Gleh.
01:39:34 <monstre> maybe bogosort wasn't such a good example, I'll give you that
01:39:52 <Maddas> I consider this (just based on 'intuition') to be similar to the situation where you want to violate the type system. Even if you can prove that having elements of different type in the list won't ever cause any problem, the type system won't really let you unless you can prove it at the type system level. It is inherently more conservative.
01:39:56 <Cale> It's a good thing that good examples of that are hard to find :)
01:39:57 <Syzygy-> I'm looking at the code for permutationgroups in http://www.polyomino.f2s.com/david/haskell/codeindex.html -- and I cannot seem to figure out where the constructor PL comes from
01:40:00 <lambdabot> Title: Code Index, http://tinyurl.com/f9m94
01:40:20 <Syzygy-> He does things like newtype Permutation = PL [Int] deriving (Eq, Ord, Read)
01:40:25 <Syzygy-> @type PL
01:40:27 <lambdabot> Not in scope: data constructor `PL'
01:40:34 <Cale> newtype Permutation = PL [Int] deriving (Eq, Ord, Read)
01:40:41 <Syzygy-> Oh.
01:40:50 <Syzygy-> PL is the constructor for the type Permutation.... right?
01:40:54 <Cale> right
01:41:02 <Syzygy-> One of these days I'm going to learn reading haskell too. I promise.
01:41:08 <Cale> :)
01:41:35 <Cale> hey, this is good stuff
01:41:44 <Cale> We should port all of GAP to Haskell :)
01:42:16 <Maddas> GAP?
01:42:32 <Cale> http://www-gap.mcs.st-and.ac.uk/
01:44:10 <Cale> It's really quite a nice system, I just wish that they'd made some decisions differently about their underlying programming language. There are really annoying problems with aliasing.
01:44:43 <Cale> You have to go out of your way to do things in a nonmutating fashion, which is upsetting.
01:46:23 <ThreeQ> I wonder why they chose to make a new programming language rather than implementing it on top of scheme or something
01:47:09 <Syzygy-> Cale: I'm all for it!
01:47:10 <Syzygy-> :)
01:47:42 <Syzygy-> Cale: I'm listening to a lecture course this term on Computational Group Theory. I want to code all the algorithms we talk about in Haskell as a personal exercise.
01:47:56 <Syzygy-> Possibly even doing parallell implementations in C+MeatAxe, and compare performance...
01:48:28 <Syzygy-> ThreeQ: It's rather common among computer algebra systems...
01:48:46 <derelm> thats probably a stupid question - but how do i convert an IO something to a plain old something like IO Float -> Float
01:48:56 <Cale> derelm: you don't
01:49:00 <derelm> i don't
01:49:01 <derelm> ...
01:49:07 <ThreeQ> seems like too much work, though
01:49:20 <Cale> derelm: but the more useful answer is that you write
01:49:25 <Cale> x <- ioSomething
01:49:31 <Cale> in the middle of a do-block
01:49:37 <derelm> but for that i'll need a do block
01:49:46 <Syzygy-> derelm: Exactly.
01:49:48 <Cale> and if ioSomething is an IO Float, then x is a Float
01:50:05 <derelm> so every function that wants to work with my IO Float will need to have a do block?
01:50:06 <Syzygy-> derelm: Due to the lazy evaluation, you cannot control order of evaluation without a do block.
01:50:07 <Cale> you can then pass x off into pure code
01:50:22 <derelm> aha
01:50:39 <Cale> the IO Float is not a Float
01:50:48 <Cale> it's a program which when run, produces a Float
01:51:07 <Cale> that's the better way to think about it :)
01:51:35 <Syzygy-> And the x <- blah runs the program, and puts the result in x.
01:51:36 <derelm> oh man, i feel bad - i thought writing a function that takes to random values to produce some value would be easy
01:52:03 <Syzygy-> derelm: Random stuff is a perfect example of a thingie that won't give you the same thing each time you look at it.
01:52:11 <Cale> derelm: you can, for instance, produce an infinite list of random values and pass it into a pure function
01:52:19 <Syzygy-> So you very much want to read one instance out, and do things with it.
01:52:29 <Syzygy-> Cale: Is this sequence magic?
01:52:31 <Cale> and that pure function might consume as many of them as it needs
01:52:42 <ThreeQ> unsafeInterleaveIO?
01:52:43 <Cale> Syzygy-: yeah
01:52:49 <Cale> ThreeQ: exactly
01:52:55 <Cale> er, actually
01:53:00 <Cale> no, it's not very magic :)
01:53:06 <ThreeQ> oh yeah, it just needs the seed
01:53:13 <Cale> the only magic is in the initial seed
01:53:24 <Cale> which is done in IO anyway :)
01:53:45 <Cale> randoms  :: RandomGen g => g -> [a]
01:53:47 <derelm> i dont feel good
01:53:48 <kzm> Anybody have any experience with running Haskell programs on IA64 (using IA32 emulation or otherwise)?
01:53:50 <derelm> :(
01:54:16 <Syzygy-> kzm: No, but I do it a lot on amd64/x86_64
01:54:41 <Syzygy-> (a lot meaning all programs I run I run on amd64, not that I run a lot of programs)
01:54:42 <kzm> Syzygy-, :-)  x86_64 works really nice for me too, it's IA64 that sucks.
01:54:44 <Cale> derelm: so you can't have a function which produces random values, but it's easy enough to get a bunch and pass them into the rest of your program
01:54:53 <Syzygy-> kzm: Ah.
01:54:55 <Cale> (even infinitely many)
01:55:03 <Cale> also, you can get a generator
01:55:05 <Cale> and pass that in
01:55:11 <kzm> My program runs in 10 seconds on x86_64, and thirty  m i n u t e s  on IA64.
01:55:16 <Syzygy-> @type randoms
01:55:17 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
01:55:22 <kzm> I mean - emulation, okay, but really.
01:55:26 <Syzygy-> kzm: O.O
01:55:31 <kzm> (and I thought it was IO bound, too)
01:55:39 <Cale> and when you call, for instance, 'random' on it, you will get a random value and a new generator
01:55:56 <kzm> No native compiler for IA64, AFAICT.
01:56:05 <ThreeQ> derelm: one thing to remember is that you shouldn't think of Foo -> IO Bar as a function that takes a foo and returns a bar, except in some special way.  It's actually a function that takes a foo and returns a _program_ that, when run, will return a bar
01:56:09 <kzm> Perhaps GHC really relies on OOO for performance, too?
01:56:21 <Syzygy-> kzm: OOO?
01:56:24 <ThreeQ> but there's no way for you to actually run this program yourself
01:57:31 <Maddas> Syzygy-: Order of evaluation
01:57:38 <Maddas> Er, um, no.
01:57:48 <Maddas> sorry ;-)
02:02:06 <derelm> well thanks everyone - i need a break - maybe i'll get if after some lunch
02:04:53 <ThreeQ> derelm: alright :)
02:04:56 <ThreeQ> I'm going to bed
02:05:18 <derelm> timezones are a funny thing :)
02:05:28 <ThreeQ> indeed
02:05:34 <ThreeQ> ?timein derelm
02:05:35 <lambdabot> Local time for derelm is 2006-10-17 11:05:10 +0200
02:05:47 <ThreeQ> ?timein ThreeQ
02:05:48 <lambdabot> Local time for ThreeQ is 2006-10-17 02:05:23 -0700
02:05:57 <derelm> hehe
02:06:17 <derelm> so good night then
02:06:25 <ThreeQ> night!
02:10:46 <monstre> Now that we've established that bogosort is not a very good algorithm, I'm kinda wondering which algorithm GHC, for instance, uses to sort lists.
02:10:59 <monstre> Anyone knows?
02:11:12 <Cale> @source GHC.List
02:11:12 <lambdabot> GHC.List not available
02:11:15 <Cale> er
02:11:19 <Cale> @source Data.List
02:11:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
02:11:24 <norpan> monstre: merge sort
02:11:40 <monstre> hey thanks
02:11:53 <norpan> bottom-up merge sort to be exact
02:14:18 <monstre> hmmm, I figured it would be some kind of natural merge sort
02:14:21 <monstre> oh well
02:14:47 <norpan> natural?
02:14:54 <norpan> nature does merge sort?
02:15:03 <Cale> You can write a relatively simple qsort really easily.
02:15:20 <Cale> (as you probably know)
02:15:32 <monstre> perhaps natural isn't the proper nomenclature
02:15:55 <monstre> I meant that it could have taken advantage of the order already present in the data
02:16:02 <norpan> it does
02:16:33 <monstre> really?
02:16:37 <monstre> I'm not seeing it
02:18:50 <norpan> maybe i'm wrong :)
02:18:59 <monstre> I think you are :)
02:20:00 <monstre> it won't sort a sorted list in linear time for instance
02:21:44 <norpan> no it will always do nlog n
02:44:40 <apfelmus> someone working on ghc 6.6 for MacPorts ?
03:58:30 <Syzygy-> @hoogle sort
03:58:30 <lambdabot> List.sort :: Ord a => [a] -> [a]
03:58:31 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:58:31 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
04:00:25 <Syzygy-> @hoogle show
04:00:26 <lambdabot> Prelude.show :: Show a => a -> String
04:00:26 <lambdabot> Text.Show :: module
04:00:26 <lambdabot> Prelude.Show :: class Show a
04:10:08 <roconnor> @hoogle comparing
04:10:09 <lambdabot> No matches found
04:19:08 <SamB> hmm
04:19:17 <SamB> so I am supposed to use cachegrind?
04:19:37 <Syzygy-> @hoogle compare
04:19:37 <lambdabot> Prelude.compare :: Ord a => a -> a -> Ordering
04:19:38 <lambdabot> Text.ParserCombinators.Parsec.Error.messageCompare :: Message -> Message -> Ordering
04:19:50 <Syzygy-> @pastebin
04:19:51 <lambdabot> Unknown command, try @list
04:19:56 <Syzygy-> pastebin?
04:20:12 <Syzygy-> Hmm... Where is a good pastebin?
04:20:18 <rahikkala> lisppaste2: url
04:20:18 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
04:20:27 <Syzygy-> Thanks.
04:20:57 <lisppaste2> Syzygy- pasted "Parse error" at http://paste.lisp.org/display/28120
04:21:14 <Syzygy-> I cannot figure out why that code won't compile. Any ideas?
04:21:37 <Syzygy-> (background: writing a naïve permutation implementation - this is supposed to find the orbit of a single element under a given permutation)
04:24:30 <roconnor> cachegrind?
04:24:45 <norpan> Syzygy-: you need to indent the line starting with "case" more
04:36:15 <kzm> What happened to Data.ByteString.unsafeUseAsCString(Len)?
04:36:29 <kzm> Is it equally fast without 'unsafe'?
04:38:01 <audreyt> likely so
04:38:13 <musasabi> no.
04:38:24 <audreyt> hm?
04:38:32 <musasabi> unsafe = make no copy and trust that the C code will not poke into the Ptr.
04:38:39 <musasabi> safe = make a copy
04:38:43 <kzm> So why did it go away?
04:38:50 <kzm> (Or did it just go elsewhere?)
04:38:54 <musasabi> it is there I think.
04:38:54 <audreyt> useAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
04:38:55 <audreyt> useAsCStringLen = unsafeUseAsCStringLen
04:39:05 <audreyt> it doesn't seem to agree with musasabi...
04:39:12 <Igloo> That looks very wrong
04:39:34 <audreyt> -- Why is this function unsafe? It relies on the null
04:39:36 <audreyt> -- byte at the end of the ByteString to be there.
04:40:03 <kzm> I expect very large strings - I can't afford a copy.
04:40:06 <musasabi> -- | /O(1) construction/ Use a @ByteString@ with a function requiring a
04:40:06 <musasabi> -- @CString@.  Warning: modifying the @CString@ will affect the
04:40:06 <musasabi> -- @ByteString@.  Why is this function unsafe? It relies on the null
04:40:06 <musasabi> -- byte at the end of the ByteString to be there. Unless you can
04:40:06 <musasabi> -- guarantee the null byte, you should use the safe version, which will
04:40:08 <kzm> A NULL can be arranged, however.
04:40:18 <musasabi> -- copy the string first.
04:40:23 <audreyt> kzm: then use useAsCStringLen
04:40:23 <norpan> hey
04:40:37 <audreyt> musasabi: but in ByteString.hs the unsafe is dropped
04:40:50 <musasabi> audreyt: is not.
04:41:00 <musasabi> audreyt: I think we are looking at different versions of the code.
04:41:04 <audreyt> ok. maybe I'm looking at the wrong place
04:41:08 <SamB_XP> @hoogle useascstringlen
04:41:08 <lambdabot> No matches found
04:41:16 <SamB_XP> mmm
04:41:17 <kzm> It doesn't seem to be in the fps in base in the 6.6 binary dist.
04:41:28 <musasabi> hmm. with and without len makes a difference.
04:41:49 <audreyt> I'm looking in the fps in the base in the 6.6 sourc tree.
04:41:51 <musasabi> http://youzen.b2.fi/~musasabi/a.hs <- relevant source
04:42:08 <audreyt> useAsCString there is O(n), useAsCStringLen simply drops unsafe
04:42:16 <musasabi> yes.
04:43:08 <audreyt> so the correct answer to kzm is, use useAsCStringLen, not useAsCString, and it'd be as fast as unsafe
04:43:32 <kzm> Right.  Thanks.
04:44:02 <kzm> Since we're at it, what is the recommended way to install .a files as part of a cabalized library?
04:44:14 <SamB_XP> sometimes dons, dcoutts, or someone else realizes that an "unsafe" function isn't, and drops the "unsafe" from its name ;-)
04:44:47 <kzm> Hopefully, the interface to fps is congealing somewhat, now that's part of 6.6's base.
04:45:26 <SamB_XP> yes, hopefully they will at least leave any "unsafe" versions there until the next release
04:45:43 <SamB_XP> and not change any types
04:49:36 <roconnor> Are there any rules in Haskell 98 about naming a variable __
04:50:02 <Igloo> It's allowed AFAICR
04:51:33 <roconnor> ok
04:51:57 * roconnor wonders what yhc's problem with __ is
04:52:41 <SamB_XP> maybe it forgets it is a Haskell implementation and not a Python implementation, and mangles things starting with that!
04:54:44 <kzm> roconnor, it may cause confusion for the linker, perhaps?
04:55:16 <SamB_XP> kzm: what linker?
04:55:33 * kzm doesn't know anything about yhc.
04:56:12 <kzm> I just seem to vaguely remember something about identifiers that were discouraged in C.
05:01:08 <pejo> kzm, I think _ is for the OS and __ is for the compiler, there's something about it in the standard.
05:03:41 <roconnor> Compilers that offer warnings for unused identifiers are encouraged to suppress such warnings for identifiers beginning with underscore.
05:04:03 <roconnor> but that is all I can see
05:04:13 <beelsebob> roflcakes
05:04:14 <beelsebob> Main> :l class3.hs ERROR "class3.hs":8 - Maximum token length (4000) exceeded
05:04:26 <musasabi> Who should I ask for haskell.org hosting of Haskell binary packages?
05:04:40 <beelsebob> jaffacake
05:04:49 <beelsebob> (Simon Marlowe)
05:04:55 <beelsebob> I think
05:07:00 <roconnor> beelsebob: yay for arbitrary limits
05:07:27 <beelsebob> roconnor: I guess it was kinda silly of me to put 1 followed by 187000 zeros in a file :P
05:07:29 <roconnor> the limit should clearly be 4096
05:07:33 <beelsebob> lol
05:07:40 <beelsebob> ghci is dealing with it fine
05:07:44 <beelsebob> hugsplode though
05:07:49 <roconnor> oh
05:08:02 <beelsebob> I just wanted to see if the compilers could cope with it
05:08:50 <roconnor> 187000 charcters later, the parse realizes that this isn't a number, but an indentifier ... and then starts backtracking.
05:09:10 <beelsebob> rofl
05:09:12 <beelsebob> that's a good idea
05:09:21 <SamB_XP> beelsebob: presumably it could be raised if you really cared
05:09:34 <SamB_XP> that is, it could be an option...
05:09:42 <SamB_XP> roconnor: u,
05:09:43 <SamB_XP> er.
05:09:45 <SamB_XP> um.
05:09:49 <SamB_XP> lexers!
05:09:50 <beelsebob> SamB: haven't a clue
05:09:51 <SamB_XP> hello!
05:10:05 <SamB_XP> beelsebob: I mean, it could be *made* an option
05:10:25 <beelsebob> oh, yeh, probably
05:10:27 <SamB_XP> might involve Alex hacking or something, though...
05:10:44 <SamB_XP> but, obviously, you were just bored
05:10:49 <SamB_XP> so you *don't* care ;-)
05:11:07 <beelsebob> hehe
05:11:27 <SamB> oh, so GHC handled it?
05:11:31 <beelsebob> yep
05:11:38 * beelsebob wonders how yhc will cope
05:11:42 <SamB> heh
05:11:51 <SamB> probably it will try its best ;-)
05:12:03 <SamB> I guess hugs being written in C doesn't help?
05:17:12 <audreyt> does anyone here have a GHC 6.4.1 installation handy?
05:17:26 * SamB checks
05:17:36 <audreyt> 6.4.2 will also do, but 6.4.1 preferred
05:17:38 <SamB> The Glorious Glasgow Haskell Compilation System, version 6.4.1
05:17:40 <audreyt> yay
05:17:46 <kzm> audreyt, me too.
05:17:47 <SamB> I thought it was that ;-)
05:17:50 <audreyt> can you get http://pugs.blogs.com/pre2/Perl6-Pugs-6.2.13.tar.gz and "sh configure ; make fast" ?
05:17:52 <lambdabot> http://tinyurl.com/ybzmsg
05:17:54 <SamB> kzm probably has more RAM though
05:18:03 <SamB> and probably more CPU also
05:18:31 <audreyt> kzm: can you help sanity-check the compilation of pugs as above? we're about to release :)
05:18:40 <kzm> On my way.
05:18:49 <audreyt> just make sure it produced a ./pugs executable after "make fast"; shouldn't take much time.
05:18:49 * SamB has a 450 MHz PII and 256 MB of RAM
05:18:55 <kzm> In return, can you pack HsJudy separately? :-)
05:19:10 <SamB> heh
05:19:21 <audreyt> it's cmarcelo's job but I'll do my best to help him :)
05:19:43 <dons> ?uptime
05:19:44 <lambdabot> uptime: 4d 14h 26m 13s, longest uptime: 6d 15h 1m 36s
05:19:52 <kzm> Right.  I really want to try it out, presumably the tgz will contain an updated version?
05:20:04 * SamB wonders if emacs can be made to not display low- or no- contrast combinations of foreground and background color (on a terminal)
05:20:30 * dons -> airport, and out of here!
05:20:37 <SamB> dons: out of where?
05:20:37 * kzm is about to give up on Emacs.
05:20:39 <vincenz> dons: where to
05:20:42 <audreyt> kzm: no, for better or worse, GHC 6.6's RTS problem with Judy on nonthreaded configurations ultimatel forced this release to ship without Judy
05:20:42 <kzm> Out of IRC?
05:20:43 <vincenz> kzm: same here
05:20:45 <dons> SamB: SF. back to Sydney
05:20:47 <vincenz> kzm: too used of irc
05:20:50 <SamB> dons: ah
05:20:53 <vincenz> erm
05:20:54 <dons> I'll see you guys in 24 hours or so.
05:20:55 <vincenz> kzm: too used to vim
05:20:57 <audreyt> and instead use Data.HashTable and TVar (Sequence (TVar))
05:21:00 <vincenz> cya dons, have fun
05:21:00 <SamB> didn't realize you were still here!
05:21:09 <dons> Had a great time in SF, btw. Like a bigger version of Sydney
05:21:12 <audreyt> kzm: but it's high on our agenda to track that down
05:21:19 <dons> with more blisters^h^h^h hills
05:21:20 <kzm> audreyt, Data.HashTable performs better than Data.Map/Set?
05:21:29 <audreyt> that is, find a consistent workaround ;)
05:21:34 <audreyt> kzm: for mutable data? sure
05:22:07 <Igloo> audreyt: Judy? And what problems?
05:22:10 <kzm> I basically have a sparse frequency count table.  Perhaps it's time to try HashTable again.
05:22:17 <audreyt> Igloo: the one I reported
05:22:21 <SamB> kzm: what is wrong with Emacs?
05:22:24 * dons evaporates
05:22:41 <audreyt> Igloo: http://hackage.haskell.org/trac/ghc/ticket/895
05:22:44 <lambdabot> Title: #895 (pugs: internal error: task 0x1b00330: main thread 1 has been GC'd) - GHC - ..., http://tinyurl.com/faznp
05:22:51 <SamB> besides the fact that ediff running on Lemmih's computer doesn't look good in my xterm?
05:23:13 <kzm> audreyt, *** Could not find libperl.so in: /usr/local/lib /lib /usr/lib  /usr/lib
05:23:24 <SamB> kzm: maybe you need to install it?
05:23:26 <Igloo> Ah, right
05:23:26 <kzm> SamB, Unicode support.
05:23:29 <audreyt> kzm: debian?
05:23:33 <kzm> Ubuntu.
05:23:35 <SamB> kzm: ah, true
05:23:39 <hyrax42> ?type unfoldtree
05:23:40 <lambdabot> Not in scope: `unfoldtree'
05:23:44 <audreyt> you need libperl-dev
05:23:46 <hyrax42> ?hoogle unfoldtree
05:23:47 <lambdabot> Data.Tree.unfoldTree :: (b -> (a, [b])) -> b -> Tree a
05:23:48 <lambdabot> Data.Tree.unfoldTreeM :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
05:23:48 <lambdabot> Data.Tree.unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a)
05:24:23 <SamB> I'd like it if I could install both mule-utf8 *and* nxml-mode (with relaxng-validate-mode) at the same time...
05:24:27 <roconnor> SamB I'm  pretty sure you can find a better computer sitting out on the curb.
05:24:39 <SamB> roconnor: where?
05:24:59 <vincenz> Anyone use emacs
05:25:05 <vincenz> How do I get it to look less gritty
05:25:07 <roconnor> Anywhere, Berkeley, CA for example
05:25:10 <SamB> vincenz: gritty?
05:25:15 <vincenz> the fonts
05:25:17 <SamB> oh
05:25:18 <vincenz> the icons
05:25:18 <SamB> well
05:25:22 <vincenz> the menu
05:25:22 <SamB> ICONS?
05:25:38 <roconnor> although dumpsters by corporate offices are probably good too
05:25:53 <roconnor> ... and you can sell the data on the drives to their competitors for a bonus.
05:25:53 <SamB> could you say more about this "gritty" look?
05:26:05 <kzm> There's a version using Gtk, I think.  Maybe that's better.  I just turn off everything I can, though.
05:26:19 <audreyt> kzm: does installing libperl-dev make it work?
05:26:19 <SamB> I actually like the icons I see on this emacs here
05:26:25 <vincenz> SamB: http://homes.esat.kuleuven.be/~cpoucet/woo.png
05:26:28 <lambdabot> http://tinyurl.com/uqtet
05:26:30 <SamB> they are kinda cute but mostly subdued...
05:26:36 <kzm> audreyt, it's still compiling.  (It had to compile fps first)
05:26:45 <roconnor> I upgraded to a P III when a friend of mine was moving and looking to get rid of his computer.
05:26:58 <SamB> vincenz: I can certainly see what you mean about the fonts...
05:26:59 <kzm> Perhaps you should also have 'make reallyfast'? :-)
05:27:05 <vincenz> SamB: even the menu
05:27:12 <vincenz> SamB: and that's unscaled
05:27:12 <audreyt> compiling fps with -O0 will likely defeat the purpose though :)
05:27:25 <SamB> after I click on it it is
05:27:31 <kzm> Heh.
05:27:47 <vincenz> I mean after switching to edgy, where you have these cute mac-like fonts in the terminal, this is really ugly
05:27:55 <SamB> I must admit that those icons do not look so great with that color of gray
05:28:14 <SamB> wait, is that the GTK version?
05:28:17 <vincenz> this is the std out of the box
05:28:24 <SamB> no, it isn't...
05:28:27 <vincenz> yes it is
05:28:30 <vincenz> I installed emacs with a package
05:28:31 <SamB> oh?
05:28:33 <vincenz> this is what I get
05:28:47 <SamB> well.
05:28:50 <kzm> vincenz, you can set a different font, of course.
05:28:57 <SamB> do you have all the basic fonts installed?
05:29:05 <vincenz> kzm: only ugly ones
05:29:20 <vincenz> kzm: and you'd think a product would ship with sensible options
05:29:29 <kzm> (set-default-font 10x20) ;; works for me
05:29:42 <kzm> vincenz, you'd think, but you'd be wrong. :-)
05:29:54 <vincenz> kzm: how do I invoke that
05:29:54 <SamB> personally I'd just like it to make a fuss if it can't find the font it wants
05:29:58 <kzm> Welcome to Pugs -- Perl6 User's Golfing System
05:29:59 <kzm> Type :h for help.
05:29:59 <kzm> Loading Prelude... done.
05:29:59 <kzm> pugs>
05:30:06 <SamB> vincenz: in your .emacs.el file?
05:30:21 <kzm> audreyt?
05:30:23 <SamB> or, you could M-x eval
05:30:41 <vincenz> nope
05:30:42 <audreyt> kzm: that works. yay. :)
05:30:44 <ndm> how come lambdabot doesn't have pugs eval yet?
05:30:50 * kzm is the first on his block to run Perl6!
05:31:00 <SamB> but then you might need to open a new window or something
05:31:14 <Pupeno> What type of numbers are those that can be written as an optional sign followed by a finite number of digits, a perido and another finite number of digits ? They are not Integers, but they are not rational either (the last part can be infinite in rational numbers).
05:31:16 <audreyt> kzm: it's a slow pugs though. you may want "make realclean; sh configure ; make" to get a fast one :)
05:31:32 <audreyt> "make fast" means -O0, essentially
05:31:35 <vincenz> SamB: Still leaves the menu horrible
05:31:40 <kzm> Right.
05:31:46 <SamB> Pupeno: um, decimals?
05:31:57 <audreyt> ndm: there's an evalbot over there at #perl6 and a web terminal at http://run.pugscode.org/
05:32:02 <lambdabot> Title: Run Perl 6 Now -- in your browser!
05:32:12 <SamB> vincenz: I bet you are missing a font
05:32:16 <vincenz> SamB: which one?
05:32:27 <norpan> Pupeno: that class would depend on the number base used, so it's probably not a very interesting class...
05:32:36 * SamB looks...
05:33:51 <audreyt> kzm: are you running 64bit?
05:33:51 <SamB> hmm...
05:34:04 <kzm> audreyt, no, Pentium4.
05:34:16 <audreyt> ok. getting someone else to try 64bit...
05:34:31 <roconnor> audreyt: I have amd64 with ghc 6.4.2
05:34:38 <ndm> SamB, did you make a start on pretty printing for Yhc.Core?
05:34:46 <kzm> Give me a second, I'll check if I have 64bit GHC as well.
05:34:47 <SamB> ndm: no
05:34:51 <kzm> I have 6.4.1, at least.
05:34:58 <ndm> SamB, fair enough, i might learn pretty printing tonight then
05:35:02 <audreyt> roconnor: hm, new combination as well. try to see if "make fast" works?
05:35:03 <SamB> I've still got this GHC patch I'm working on...
05:35:24 <ndm> yeah, isn't it much easier contributing to Yhc ;)
05:35:25 <SamB> and you need an excuse to learn pretty-printing anyway, right?
05:35:30 <ndm> yep, i do
05:35:49 <ndm> if you had done this, then i'd have taken that and learnt by modifying that to my system
05:35:51 <roconnor> audreyt: what do I need to download?
05:35:59 <ndm> as you haven't, i'll learn from the paper instead
05:36:12 <audreyt> roconnor: http://pugs.blogs.com/pre2/Perl6-Pugs-6.2.13.tar.gz
05:36:14 <lambdabot> http://tinyurl.com/ybzmsg
05:36:20 <SamB> well, you can understand them being careful of changes to optimizations ;-)
05:36:29 <vincenz> SamB: here is a comparsion
05:36:31 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/woo2.png
05:36:32 <ndm> hehe, yeah, i can
05:36:34 <lambdabot> http://tinyurl.com/yg4t59
05:36:35 <audreyt> roconnor: "sh configure ; make fast ; ./pugs"
05:36:37 <vincenz> pretty terminal fonots
05:36:40 <ndm> although Yhc -O already has that optimisation in it :)
05:37:17 <roconnor> audreyt: ghc-6.4.2 isn't the default install unfortunately.  I assume there is a configure command I can use to point it to the right place?
05:37:46 <audreyt> roconnor: easiest is
05:38:00 <audreyt> export GHC=/path/to/ghc
05:38:12 <roconnor> sounds good
05:38:52 * SamB wonders where Emacs gets the background color from?
05:39:05 <SamB> ndm: which optimization?
05:39:34 <ndm> SamB, one that generalises the one you are hacking into GHC, constant propagation inside called functions
05:39:56 <SamB> well, I wasn't actually doing propagation there
05:40:27 <SamB> just trying to get it to inline stuff so it would do that....
05:40:29 <ndm> i know, but you are changing the cost of inlining to get better results, by constant movement
05:40:38 <SamB> yeah
05:40:40 <ndm> yeah, going the indirect way round
05:40:47 <ventonegro> yeah, 6.6 entered unstable
05:41:03 <ndm> Yhc -O hops in a different direction and does that kind of optimisation directly, without inlining
05:41:47 <SamB> huh
05:41:54 <ventonegro> but not the additional packages :-(
05:42:23 <kzm> Welcome to Pugs -- Perl6 User's Golfing System
05:42:24 <kzm> Type :h for help.
05:42:24 <kzm> Loading Prelude... done.
05:42:34 <kzm> Linux cbucompute.local 2.6.9-34.0.2.ELsmp #1 SMP Fri Jul 7 18:22:55 CDT 2006 x86_64 x86_64 x86_64 GNU/Linux
05:42:47 <SamB> ndm: you saying that if I have (x `shiftR` 8), Yhc -O can get rid of the bounds checking?
05:43:00 <kzm> The Glorious Glasgow Haskell Compilation System, version 6.4.1
05:43:15 <ndm> SamB, checking that 8 < 32?
05:43:22 <SamB> ndm: yeah
05:43:28 <SamB> oh, and also the sign checking
05:43:29 <ndm> SamB, yes, definately!
05:43:34 <ndm> yep, all of those things
05:43:57 <SamB> well, if it were to implement shiftR the same way it is implemented for GHC...
05:44:34 <SamB> the more I look at this the more I think roconner is right about these heuristics for inlining...
05:44:49 <ndm> what about them?
05:45:14 <ndm> my compiler Yhc -O has *no* heuristics, at all!
05:45:25 <SamB> I'm talking about GHC's heuristics ;-)
05:45:30 <ndm> everything is a structural property
05:45:31 <SamB> roconnor doesn't like them
05:45:40 <dcoutts_> ndm, no inlining depth etc ?
05:45:49 <ndm> dcoutts_, nothing like that at all
05:46:06 <ndm> dcoutts_, inlining is a rare transformation, very rare
05:46:12 <dcoutts_> hmm, ok
05:46:34 * dcoutts_ -> lunch
05:47:28 <roconnor> audreyt: ah sorry.  Apparently having ghc 6.4.2 built in /tmp instead of installed standard is too strange for me to build pugs easily.  *** Cannot find a runnable 'ghc' from path.
05:47:45 <audreyt> ok... in that case add it to front of PATH?
05:48:02 <audreyt> in any case I'm going to release now without holding off :)
05:48:14 <audreyt> (it's uploading to CPAN at this moment)
05:48:23 <SamB> @tell Lemmih I need valgrind
05:48:24 <lambdabot> Consider it noted.
05:48:37 <audreyt> http://pugs.blogs.com/dist/Perl6-Pugs-6.2.13.tar.gz # it's up :)
05:48:40 <lambdabot> http://tinyurl.com/y2u4yq
05:48:44 <roconnor> audreyt: yeah, I tried adding it to the front of my PATH.  so now ghci etc works from the command line (runs version 6.4.2) but I still get that error message :(
05:49:49 * roconnor doesn't like GHC's ``maybe I'll inline this'' mode
05:50:18 <roconnor> audreyt: yay for the release.
05:50:31 <SamB> roconnor: ??
05:50:59 <roconnor> SamB, I'm just reiterating what you said I feel.
05:51:34 <audreyt> thanks :))
05:53:26 <ndm> roconnor: well Yhc -O has not much inlining, and no heuristics
05:53:40 <roconnor> heuristics are dumb
05:53:43 <roconnor> ;)
05:54:39 <Lemmih> SamB: Done.
05:54:40 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
05:55:04 <roconnor> ndm: you are going to have to to release a version pretty soon if you keep talking big ;)
05:55:21 <ndm> roconnor: once i have the benchmarks, i'll be talking a lot bigger :)
05:55:30 <ndm> roconnor: hopefully i should be able to produce binaries within 2 weeks
05:56:07 <ndm> i have produced binaries, but am rewriting sections to be faster/different/not overflow the stack, so have initial numbers but its still changing too much to claim too much off them
05:56:08 * roconnor wonders which he will get his hands on first, Yhc -O or the final codex.
05:56:40 <roconnor> ndm: oh, maybe I should get you a SHA2sum benchmark program then.
05:56:54 <ndm> roconnor: how many lines?
05:57:01 <ndm> roconnor: and that compiles on Yhc?
05:57:18 <ndm> if its < 50 lines, and does compile, then yes, that would be great
05:57:28 <roconnor> well, the library is part of the haskell crypto library.  I wonder if that builds under YHC.
05:57:32 <velco> what is an efficient way to move the first element of a list to the end, i.e. foo (x:xs) = xs ++ [x] ?
05:57:51 <roconnor> ndm: the library is definitely more than 50 lines.
05:58:11 <flux__> velco, I can't think there would be a more efficient way..
05:58:26 <ndm> roconnor: :(, maybe once i've got the nofib suite working
05:58:34 <roconnor> $ wc Data/Digest/SHA2.hs
05:58:34 <roconnor>   284  1562 13710 Data/Digest/SHA2.hs
05:58:43 <flux__> velco, maybe you could use an alternative datastructure altogether, if you need to do that ofte
05:58:45 <roconnor> but a fair amount of that is testing and comments.
05:58:48 <flux__> velco, such as two lists
05:59:35 <velco> hmm, yes, I sort of reached a solution where I pass the first elt to all the recursive calls and just use it at the end ...
06:00:03 <ndm> roconnor: sounds a bit too big for the intial try, but will keep it in my sights
06:00:05 <roconnor> Does the term anti-monotone function make any sense?  Anyone here know lattice theory?
06:00:28 <roconnor> ndm: a lot of the bigness comes from the list of constants too.
06:01:04 <ndm> roconnor: ok, list of constants doesn't count to code size
06:01:15 <kzm> The export of the LPS constructor got removed from Data.ByteString.Lazy?!
06:02:11 * kzm wonders if he can use to/fromChunks for this?
06:02:14 <roconnor> http://darcs.haskell.org/crypto/Data/Digest/SHA2.hs
06:02:16 <lambdabot> http://tinyurl.com/yx3qek
06:09:00 <roconnor> ah, it's called an antitone function.
06:09:05 <roconnor> according to wikipedia.
06:16:57 <rafl> I just upgraded ghc from 6.4 to 6.6 using the Debian packages. Since then some things don't build anymore because of missing packages from extralibs. Are those packaged for Debian yet?
06:21:15 <shapr> rafl: yup, libghc6-mtl-dev and friends
06:21:32 <shapr> rafl: At least I think that's what you mean.
06:22:46 <rafl> shapr: That package doesn't exist in sid, does it?
06:24:09 <xtruppaw> what book do you suggest about Monads?
06:29:27 * gour sees taht haskell is practically dead-end on the diagram at - http://bluebones.net/2006/03/evolution-of-programming-languages/
06:29:30 <lambdabot> Title: bluebones.net » Evolution of Programming Languages, http://tinyurl.com/y69jzb
06:31:00 <fasta> Is there an easy way to get easy out semantics without introducing nested control flow?
06:32:19 <fasta> Something like Nothing>>Just 5 => Nothing, but then for StateT?
06:38:56 <Maddas> gour: A pity that it only used wikipedia as a reference (or so it claims).
06:39:21 <gour> Maddas: true
06:39:33 <Maddas> s/only used/used only/ (doesn't sound as condescending)
06:39:57 <roconnor> fasta: What do you mean?  Nothing>>Just 5 = Nothing is derivable from the MonadPlus laws.
06:39:57 <dcoutts_> kzm, use LPS/to/fromChunks for what?
06:40:00 <gour> Maddas: no wonder haskell has that 0.084% of the markwet or so :-(
06:40:08 <Maddas> gour: and 'dead end' might also just mean perfect! ;-P
06:40:25 <fasta> roconnor: yes, but return Nothing>>return (Just 5) is not
06:40:29 <kzm> dcoutts, building a LPS from a list of PS'es.  fromChunks seems to work.
06:40:41 <dcoutts_> kzm, and yes, we moved LPS to Base because it has an invariant that you must respect
06:40:42 <gour> Maddas: i'd like to be so, but i hope to see haskell-2 one day
06:40:54 <roconnor> fasta: ah.  Are there monad transfomer laws?
06:41:01 <gour> Maddas: with haskell' in between
06:41:02 <gds> Maddas: It's not /really/ a dead end though - having influenced perl6 if nothing else ;)
06:41:03 <fasta> roconnor: I don't know
06:41:09 <Maddas> gour: :-)
06:41:17 <dcoutts_> kzm, yes, fromChunks checks the LPS invariant
06:41:27 <Maddas> gds: Not that this chart is authoritative or complete anyway.
06:41:31 * roconnor is scared of monad transformers.
06:41:33 <fasta> roconnor: I just think that non-local control flow is nicer.
06:41:38 <beelsebob> @hoogle Double -> Int
06:41:38 <kzm> dcoutts_, Right. I got burned by that one.  No sweat, I worked it out.
06:41:39 <lambdabot> No matches, try a more general search
06:41:54 <beelsebob> @hoogle Integral a => Float -> a
06:41:56 <lambdabot> No matches, try a more general search
06:42:07 <roconnor> @type fromIntegral
06:42:08 <lambdabot> forall b a. (Num b, Integral a) => a -> b
06:42:11 <beelsebob> :)
06:42:13 <fasta> roconnor: I am not that scared anymore, but it's hard to make a point for them or against them.
06:42:18 <beelsebob> @type toIntegral
06:42:18 <dcoutts_> kzm, what's your application out of interest?
06:42:20 <lambdabot> Not in scope: `toIntegral'
06:42:25 <beelsebob> @type toInteger
06:42:27 <lambdabot> forall a. (Integral a) => a -> Integer
06:42:32 <beelsebob> arse
06:42:39 <beelsebob> @type fromFloating
06:42:40 <lambdabot> Not in scope: `fromFloating'
06:42:48 <roconnor> fasta: I've used one transformer, but I'm a bit scared to put two or more together. :)
06:42:50 <beelsebob> gyah... I just want round actually
06:42:57 <dcoutts_> beelsebob, you just want fromIntegral, it does everything
06:43:04 <beelsebob> dcoutts: no
06:43:08 <fasta> roconnor: oh, right, I haven't done that yet.
06:43:09 <beelsebob> I want Float -> Int
06:43:16 <beelsebob> not Int -> ???
06:43:18 <kzm> dcoutts_, I'm just going over some code to make it 6.6-compliant.  (Bioinformatics stuff, parsing sequence data, etc)
06:43:19 <dcoutts_> ceil? floor ?
06:43:29 <beelsebob> round
06:43:38 <dcoutts_> @hoogle round
06:43:39 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
06:43:39 <lambdabot> Text.Html.background :: String -> HtmlAttr
06:43:39 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
06:43:57 <kzm> dcoutts_, Possibly, my use of LPS is an abuse, I'm parsing into lines, and reconstructing an LPS from there.
06:44:10 <kzm> No time to beautify it at this point, though :-)
06:44:11 <fasta> Heh, that looks pretty stupid: cOLOR_BACKGROUND
06:44:14 <kzm> Feel free :-9
06:44:23 <dcoutts_> kzm, why not just use Lazy.lines ?
06:44:48 <dcoutts_> kzm, but yeah, from/toChunks is ok
06:44:55 <kzm> dcoutts, don't remember :-P
06:45:01 <kzm> There was a reason.
06:45:06 <dcoutts_> heh, ok
06:45:07 <kzm> I'm sure there was.
06:48:34 <syntaxfree> outside of an artificial type, can a Haskell program find out the arity of a given function?
06:48:50 <ndm> syntaxfree: no
06:49:11 <syntaxfree> (I should say, in an interpreted environment like GHCi)
06:49:30 <ndm> oh, :t
06:49:32 <syntaxfree> My application is basically GHCi plus a small DSL.
06:49:47 <syntaxfree> yes, but a function can't read the value of ":t"  and use it.
06:50:12 <ndm> you can do type classes
06:50:29 <syntaxfree> the thing is, users are defining their own functions.
06:50:43 <ndm> instance Arity (a -> b) style tricks
06:50:53 <ndm> or Data.Dynamic stuff
06:50:54 <syntaxfree> this is beginning to look like a Lisp job.
06:51:16 <syntaxfree> S-expression syntax is screwed up for end-users though.
06:52:27 <roconnor> ndm, does Yhc -O do strictness analysis?
06:52:47 <ndm> roconnor: it will do, but not yet, and not as agressively as GHC
06:53:11 <ndm> roconnor: it has techniques like "runtime lazy unboxing" which it prefers to the blunt strictness analysis
06:53:41 <roconnor> since you do more function specialization, I can see more opertunities for strictness analysis to work.
06:54:52 <ndm> yes, thats an advantage, i'll have to see how my algorithm works in practice
06:55:09 <ndm> i guess i'll get strictness analysis as good as or better than GHC
06:55:25 <ndm> but thats not an area i've looked into much
06:55:51 * roconnor thinks ndm needs a research team.
06:56:09 <ndm> roconnor: if anyone wants to fund one...
06:56:29 <roconnor> I have 50 euros
06:56:33 <ndm> (and fund me once I finish my phd...)
06:56:49 <roconnor> scratch that, 20 euros :(
06:58:30 <CosmicRay> arjanb: are you a debian developer now?
07:00:29 <lisppaste2> Syzygy- pasted "Parse error" at http://paste.lisp.org/display/28123
07:00:47 <Igloo> CosmicRay: Are you confusing arjanb with arjanoosting?
07:03:59 <CosmicRay> I thought arjanb is arjanoosting.
07:04:05 <CosmicRay> so, apparently so.
07:04:34 <dcoutts_> CosmicRay, Igloo, so how many of you does that make now ?
07:04:46 <CosmicRay> Igloo: is there a convenient list of packages that ftbfs with ghc6.6?
07:05:48 <dcoutts_> CosmicRay, btw, while I'm thinking about it, we had a trivial patch to some hdbc package to make the haddock docs build
07:06:28 <CosmicRay> dcoutts: ah, I didn't know there was an issue
07:06:37 <Igloo> roconnor, SamB: If you think you can completely rewrite the inliner better then I'm sure that would be appreciated. You have nofib to help test if it really is better, of course. Unfortunately fiddling with such things tends to make some things better but other things worse, though  :-(
07:06:42 <dcoutts_> CosmicRay, let me find it for you...
07:06:44 <CosmicRay> dcoutts: feel free to send it to me
07:07:28 <roconnor> Igloo: Actually I'm hoping ndm can do better, so I'm waiting for him to have a go. :)
07:07:44 <CosmicRay> Igloo: ah, http://bjorn.haxx.se/debian/testing.pl?package=ghc6
07:07:48 <lambdabot> Title: ghc6 - Why is package X not in testing yet?, http://tinyurl.com/yys8qw
07:08:01 <CosmicRay> geez, we have some packages that depend on ghc << 6.2.2
07:08:18 <dcoutts_> http://haskell.org/~gentoo/gentoo-haskell/dev-haskell/hdbc-odbc/hdbc-odbc-1.0.1.0.ebuild
07:08:20 <lambdabot> http://tinyurl.com/y4vctj
07:08:37 <Igloo> dcoutts_: Err, not sure. At least 4.
07:08:42 <dcoutts_> nice
07:08:45 <roconnor> Igloo: I think a lot of people misunderstand me. I’m not exactly complaining about the state of GHC, rather I am complaining about the state of the art of optimisation in functional programming (which I take GHC to be an indication of). Clearly more research is needed
07:09:01 <dcoutts_> CosmicRay, and a similar one in the hdbc-sqlite backend. Just haddock markup.
07:09:09 <Igloo> CosmicRay: The reverse build-deps of ghc6, pretty much  :-)   Arjan Oosting has been filing bugs
07:09:15 <dcoutts_> CosmicRay, see the src_unpack() stuff
07:09:22 <CosmicRay> yeah, I see it
07:09:25 <Igloo> roconnor: In YHC?
07:09:57 <Igloo> roconnor: *nod*
07:10:01 <roconnor> Igloo: apparently ndm's been hard at work.
07:10:08 <CosmicRay> ah, haddock was taking commented-out lines to be haddock comments?
07:10:14 <dcoutts_> yep
07:10:17 <CosmicRay> weird.
07:10:24 <dcoutts_> '#' means something to haddock
07:10:29 <Igloo> It would be hard to say that ndm's inliner in YHC is better or worse than GHC's inliner, as everything else is different
07:10:30 <CosmicRay> lame.
07:10:30 <dcoutts_> dunno what
07:10:42 <jgrimes> are there any lazy languages that use a JIT?
07:10:52 <jgrimes> jit compiler.
07:11:06 <roconnor> Igloo: well, I don't care whether it is the inliner, or constant folding, as long as I get my uncheckedShifts ;)
07:11:08 <ndm> Igloo: it would be hard to say Yhc's inliner is better, because it doesn't have one - i don't do transformation by inlining
07:11:25 <ndm> jgrimes: Yhc compiles to .NET IL, and that has a JIT, so transitively it does
07:11:31 <jgrimes> ndm, cool
07:11:51 <Igloo> roconnor: I can make you an optimiser that gives you unchecked shifts but is /far/ worse than the state of the art, though
07:12:02 <CosmicRay> dcoutts: I couldn't find the one in the sqlite backend
07:12:19 <dcoutts_> CosmicRay, http://haskell.org/~gentoo/gentoo-haskell/dev-haskell/hdbc-sqlite/hdbc-sqlite-1.0.1.0.ebuild
07:12:21 <lambdabot> http://tinyurl.com/yaw5gw
07:12:25 <dcoutts_> in Database/HDBC/Sqlite3/Statement.hsc
07:12:30 <roconnor> Igloo: I wouldn't be surprised if for some programs GHC is better and others Yhc is better (espcially given that Yhc -O won't have good integer support).
07:12:45 <dcoutts_> CosmicRay, there's a "this/that" that needs to be escaped
07:12:50 <roconnor> Igloo: at least I will get to pick between the two.  More options for me :)
07:13:04 <CosmicRay> dcoutts: since you are a haddock expert ;-),  how do I write a link to a function with an apostrophe in its name?   'setFoo\'' doesn't work
07:13:16 <Igloo> How does YHC do integers?
07:13:20 <dcoutts_> CosmicRay, "execute/fetchrow" needs to be "execute\/fetchrow"
07:13:21 <ndm> roconnor: its a guarantee that GHC will beat Yhc -O for some programs
07:13:25 <dcoutts_> CosmicRay, hmm, dunno.
07:13:35 <roconnor> Igloo: Don't forget about a fast rotate too ;)
07:13:37 <ndm> Igloo: libgmp, but Yhc -O won't support Integer's properly to start with
07:13:38 <CosmicRay> dcoutts: I wonder why none of these have failed for me
07:13:46 <ndm> Igloo: and btw, we "type" it Yhc, not YHC
07:13:53 <ndm> (looks cuter :) )
07:14:11 <dcoutts_> CosmicRay, how did you test? Cabal used not to notice haddock failing.
07:14:20 <dcoutts_> I presume you've tried 'foldl''
07:14:21 <Igloo> Bah, you're like all the foreigners trying to tell me how to "correctly" pronounce their names  :-)
07:14:38 <CosmicRay> dcoutts: hrm.  I was going to say that we build docs on debian, for for some packages, I do use haddock to do that.
07:14:55 <CosmicRay> Igloo: you get one chance to get Goerzen right ;-)
07:15:36 <dcoutts_> CosmicRay, well if you were using Cabal then it wouldn't have noticed haddock failing to parse stuff. Cabal has been fixed now though.
07:15:38 <Igloo> Is it pronounced something like Gerrtsen?
07:16:50 <CosmicRay> Igloo: that's probably the proper way to do it from the original German.  It seems to have been variously anglicized to Goerzen and Goertzen.  There is no agreement among American Goerzens on how to pronounce it, though...  around here it's GORE-zen, but farther west its GERR-zen
07:17:20 <CosmicRay> dcoutts: I've checked those fixes into my darcs trees.
07:17:27 <dcoutts_> CosmicRay, ta
07:17:43 <CosmicRay> dcoutts: I'm going to make new releases of all my packages for the ghc 6.6 upgrade in the next few days, so you'll see it soon.
07:18:18 <dcoutts_> CosmicRay, btw, where are those darcs trees ? if we knew we could darcs send you fixes. We don't currently have a homepage in the hdbc-* ebuilds. Is there one?
07:18:27 <CosmicRay> dcoutts: http://darcs.complete.org/
07:18:30 <lambdabot> Title: Darcs repositories on complete.org
07:18:43 <CosmicRay> dcoutts: http://quux.org/devel/hdbc
07:18:46 <lambdabot> Title: Gopher: hdbc
07:19:00 <dcoutts_> aye, ok
07:19:09 <CosmicRay> dcoutts: everything I release is in darcs at that site
07:19:16 <dcoutts_> one doesn't link to the other :-)
07:19:31 <CosmicRay> dcoutts: I am fully well aware that my website is total crap ;-)
07:19:58 <Igloo> Put the website in darcs so dcoutts can send you patches  :-)
07:20:04 <dcoutts_> hah
07:20:13 <dcoutts_> right, gotta go. I'm giving a tutorial on darcs in 10 min
07:20:14 <Igloo> Except he wouldn't be able to find it! Argh!
07:20:18 <CosmicRay> haha
07:20:29 <Igloo> Who to, dcoutts?
07:20:39 <dcoutts_> Igloo, aged people in the lab
07:21:10 <SamB> someone still neads to teach Simon ;-)
07:21:18 <CosmicRay> which simon?
07:21:37 <Igloo> SamB: Did he amend-record something again?
07:21:52 <CosmicRay> heh
07:26:10 <SamB> not yet
07:26:34 <Igloo> OK  :-)
07:31:32 <symlink> could somebody please look at some code
07:31:37 <symlink> which for some reason won't compile?
07:31:44 <symlink> I'm a bit of a haskell newbie
07:31:59 <Lemmih> Sure.
07:32:01 <swiert> FFI question: how do I convert an Int to a CInt?
07:32:48 <audreyt> toEnum
07:32:51 <Lemmih> swiert: fromIntegral.
07:32:58 <symlink> http://wadon.sch.bme.hu/~konfettigyar/blog/Tolist.hs <-- here is my code
07:33:02 <lambdabot> http://tinyurl.com/yx5ss2
07:33:03 <audreyt> well, same thing, iirc
07:33:37 <audreyt> toEnum is shorter to type :)
07:33:40 <swiert> thanks guys.
07:33:51 <swiert> I thought there might be a nicer way.
07:34:03 <audreyt> unsafeCoerce#
07:34:10 <audreyt> er. never mind. pretend I didn't say that
07:34:45 <Lemmih> symlink: 'bejar fa []' instead of 'bejar (fa,[])'
07:35:02 <symlink> Lemmih: thanks
07:35:16 <symlink> what is passing the pair wrong?
07:35:51 <Lemmih> symlink: Because your function takes two arguments, not a single tuple.
07:36:19 <Lemmih> symlink: You could also write: 'bejar ([],ls) = ls'
07:36:44 <symlink> thanks
07:36:59 <symlink> I'm also occasinally getting an error of a data declaration being out of scope for a function
07:36:59 <derelm> i am still having problems with random number generation - i found something like rollDice = getStdRandom ( randomR (1,6)) in the docs - but it doesn't work. probably some newbie problem. can anyone help?
07:37:12 <symlink> if they're in the same module, shouldn't the data be visible,
07:37:13 <symlink> ?
07:38:23 <Lemmih> symlink: Can you post the error message?
07:38:45 <Lemmih> symlink: (btw, '| A fej' is wrong)
07:39:14 <symlink> Lemmih: could you tell me how use pattern matching with constructors?
07:39:40 <Syzygy-> If I do newtype Blah = Constructor [Int] deriving (Eq, Ord, Read, Show), and then get the error message that the expected type Blah and the inferred type [Int] mismatch, what do I need to do to get things working?
07:39:49 <Syzygy-> Or at least where do I start looking=?
07:40:17 <Lemmih> symlink: 'case expr of pat' or 'funcName pat = expr'.
07:40:22 <Lemmih> @where yaht
07:40:22 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
07:41:41 <Lemmih> Syzygy-: Blah is not the same as [Int].
07:41:49 <symlink> Lemmih: thanks
07:41:58 <Lemmih> Syzygy-: Is the newtype all you have written?
07:44:26 <Syzygy-> Lemmih: Not really, but I'm not very much expecting the rest to have much of an influence...
07:44:33 <Syzygy-> I'll put up a lisppaste...
07:46:57 <lisppaste2> Syzygy- pasted "Type mismatches" at http://paste.lisp.org/display/28131
07:47:00 <glguy> Syzygy-: it just sounds like you are using the constructor wrong somewhere
07:47:13 <Syzygy-> glguy: May well be. Care to throw a look?
07:48:01 <Syzygy-> The code coordinates show on the last 'permutation' in the final line.
07:48:19 <Syzygy-> The findOrbit function works - I've managed to verify that one.
07:48:25 <glguy>     Couldn't match expected type `Permutation'
07:48:26 <glguy>            against inferred type `[Int]'
07:48:26 <glguy>     In the third argument of `getOrbits', namely `permutation'
07:48:47 <glguy> so you need to write (PL permutation) for the third argument
07:48:55 <glguy> or correct that function not to pattern match
07:49:05 <Syzygy-> Ah.
07:49:23 <Syzygy-> o.O
07:49:25 <Syzygy-> It compiles!
07:49:41 <Syzygy-> Why is that? permutation was already in the function start given as (PL permutation)?
07:50:03 <glguy> (PL permutation) extracts the [Int] from the Permutation
07:50:10 <glguy> permutation :: [Int]
07:50:13 <Syzygy-> Ah.
07:50:17 <Syzygy-> Right.
07:50:26 <glguy> you could say:  pl@(Permutation permutation)
07:50:35 <glguy> errr
07:50:38 <glguy> PL permutation
07:50:57 <Syzygy-> Bwahahaha! I can take permutations and put them in cycle form, and back again! :)
07:52:36 <Syzygy-> Hmmm. It does presuppose that things are not malformed. Darnish.
08:27:35 <shapr> rafl: It's in haskell-unsafe
08:27:48 <fasta> What is the best Emacs extension to integrate with darcs?
08:32:43 <rafl> shapr: I found it. Thank you.
08:33:09 <jgrimes> are there any physics libraries written in haskell? I couldn't find any at haskell.org
08:35:28 <Lemmih> Physics libraries?
08:35:54 <jgrimes> like, electricty, magnetism, mechanics, etc
08:35:58 <jgrimes> not like... game physics
08:39:05 <jgrimes> like, if I had a type that was an instance of Num, there isn't really a way I can have a type change when I use (^) even though in the case of physical quantities, the units would change
08:53:55 * shapr yells yaarg !
08:54:15 * SyntaxNinja yells shapr!
08:54:16 <gds> @yarr
08:54:16 <lambdabot> Aye
08:54:37 * vincenz misread that as "SyntaxNinja sells shapr!"
08:56:06 <yaarg> hello :)
08:57:37 <SyntaxNinja> vincenz: well, I may be a commercial user of Haskell, but commercial vendor of Haskellers is another story.
08:57:54 <SyntaxNinja> speaking of which, hi bringert
08:58:02 <SyntaxNinja> CosmicRay: congrats on the anniversary :)
08:58:15 <bringert> SyntaxNinja: hi
08:58:19 <bringert> speaking of what?
08:58:29 * glguy didn't understand any of that
08:58:59 * SyntaxNinja shrugs
08:59:01 <bringert> I sell Haskellers?
08:59:21 <vincenz> SyntaxNinja: *grin*
08:59:38 <Igloo> bringert: I'll take 3, please
08:59:52 <vincenz> bringert: I'll have 2 with a side-order of schemers
09:00:13 <bringert> vincenz: what do you take me for?
09:00:19 <SyntaxNinja> vincenz: that's like what we have at Galois actually, a side-order of schemers
09:00:28 <vincenz> SyntaxNinja: neat ;)
09:00:33 <bringert> schemer salesman, bah
09:00:43 * vincenz is using scheme at hte moment to model some things atm
09:02:04 <vincenz> tho it's turning out to be verbose o.O
09:08:30 <shapr> Avast!
09:09:22 <ropine> I thought Talk Like a Pirate Day was last month...
09:09:39 <shapr> I'm late, as always.
09:10:08 <Igloo> In #haskell, every day is Talk Like a Pirate Day
09:10:14 <bringert> @arr
09:10:14 <lambdabot> Aye
09:10:26 <vincenz> @arr
09:10:27 <lambdabot> I'll keel haul ya fer that!
09:10:28 <bringert> SyntaxNinja: 'sup?
09:11:10 <shapr> @arr
09:11:11 <lambdabot> Aye
09:11:14 <shapr> @arr
09:11:14 <lambdabot> I want me grog!
09:12:11 <SyntaxNinja> bringert: not much. was on vacation in san Fran, but back now. how are you?
09:13:17 <shapr> bringert: I wish for Network.HTTP examples for PUT and POST.
09:13:26 <bringert> SyntaxNinja: newlywed
09:13:32 <shapr> congrats bringert!
09:13:36 <bringert> thanks
09:13:50 <Igloo> commiserations bringert!
09:13:50 <shapr> I guess Mrs Bringert doesn't show up on #haskell?
09:13:56 <shapr> hah
09:13:57 <bringert> shapr: there is a POST example in haxr
09:14:02 <shapr> Igloo: Are you married too?
09:14:05 <vincenz> bringert: 'grats
09:14:08 <Igloo> Nope
09:14:11 <bringert> thanks all
09:14:16 <shapr> bringert: Oh cool, I'll try that.
09:14:46 <bringert> shapr: nope. no irc afaik
09:15:07 <SyntaxNinja> bringert: that rocks! congrats
09:15:25 <shapr> @map
09:15:26 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
09:15:37 <shapr> Igloo: Hey, is the month done?
09:16:07 <Igloo> No, it's essentially October (assuming you mean hawiki)
09:16:15 <shapr> yup
09:16:30 <shapr> So can I generate smaller binaries if I use --split-objs ?
09:16:38 <Igloo> When making libraries, yes
09:17:10 <shapr> Does it generate smaller programs as well?
09:17:23 <Igloo> Programs are smaller if the libraries were split
09:17:27 <shapr> ah, ok
09:18:02 <bringert> I guess if you have unused functions in your program, programs could be smaller as well?
09:18:37 <Igloo> In theory, but I don't think it's possible currently
09:19:10 <ndm> does split-obj's work on Windows?
09:19:18 <Igloo> I don't think so
09:20:02 <LiquidEngineer> Hi
09:20:27 <LiquidEngineer> are there instructions for upgrading a Mac install of 6.4.1 to 6.6 using the 6.6 binary installer?
09:20:35 <Igloo> Oh, it does work, it's just very slow according to http://www.haskell.org/ghc/docs/latest/html/building/winbuild.html
09:20:38 <lambdabot> Title: 12. Instructions for building under Windows, http://tinyurl.com/ctmp3
09:20:39 <LiquidEngineer> (Of GHC, that is)
09:21:02 <Igloo> LiquidEngineer: Just uninstall the 6.4.1 and install the 6.6, presumably?
09:21:12 <ndm> Igloo: so is it done for the binary windows installer?
09:21:14 <LiquidEngineer> how do I uninstall 6.4.1?
09:21:22 <LiquidEngineer> I didn't use fink or darwin ports
09:21:28 <Igloo> No idea
09:21:29 <LiquidEngineer> I'm not really sure where everything is
09:22:08 <Lemmih> Can't you have both 6.4.1 and 6.6?
09:22:15 <LiquidEngineer> Yeah
09:22:17 <Igloo> LiquidEngineer: Probably just by removing the directory it's in, then. ghc --print-libdir might help
09:22:18 <LiquidEngineer> But I don't want it
09:22:25 <Igloo> Or   type ghc
09:23:47 * LiquidEngineer preferred the .PKG style build of 6.4.1
09:23:50 <LiquidEngineer> Yeah
09:23:53 <LiquidEngineer> that found it
09:24:04 <LiquidEngineer> so it's just the executable stuff and the stuff in lib?
09:24:08 <LiquidEngineer> no where else?
09:24:14 <Igloo> Probably
09:24:33 <fasta> LiquidEngineer: during install it also loads a few kernel modules
09:24:48 <LiquidEngineer> what?
09:24:52 <LiquidEngineer> On MacOS X?
09:24:52 <fasta> LiquidEngineer: never mind
09:24:53 <LiquidEngineer>  seriously?
09:24:56 <LiquidEngineer> oh
09:25:09 <LiquidEngineer> why does it need kernel modules on Linux?
09:25:16 <fasta> LiquidEngineer: it's called a joke
09:25:25 <fasta> j o k e
09:25:31 <LiquidEngineer> ah
09:25:45 <LiquidEngineer> I didn't see any smilies, so I took it seriously. :P
09:26:03 <LiquidEngineer> Maybe there's some hooks into the Linux kernel to make it somehow faster or something, I dunno. :P
09:26:34 <fasta> LiquidEngineer: that only happens on Windows.
09:26:50 <fasta> ;)
09:27:29 <Lemmih> Maybe we can use Lava to design some cool Haskell evaluation hardware.
09:28:33 <bringert> a FedEx truck drove up to me in the street today, and handed me a package with a Google Summer of Code t-shirt
09:29:28 * Igloo first parsed that as the FedEx driver was wearing a SoC t-shirt
09:29:29 <kolmodin> bringert: how nice
09:29:42 <bringert> I wasn't even a mentor
09:29:52 <Igloo> heh
09:30:08 <LiquidEngineer> fasta: 3rd party kernel modules that make the windows kernel *faster*?  Now I know you're joking. :P
09:35:48 <jmmv> hi
09:36:17 <dolio> Wow, a university teaching a course with Epigram.
09:36:39 <LiquidEngineer> what's that?
09:37:03 <ndm> at Nottingham by any chance?
09:37:11 <dolio> ndm: That'd be it.
09:37:32 <dolio> Epigram is an experimental (?) dependently typed language.
09:37:54 <LiquidEngineer> dependently typed?
09:38:09 <gds> Oh yeah - "Stop talking about bottom" - that thing...
09:38:13 <dolio> http://www.e-pig.org/downloads/ydtm.pdf
09:38:58 <LiquidEngineer> ah
09:39:03 <LiquidEngineer> well, thanks for the package help
09:39:07 <dolio> I don't think I've fully grokked it yet, so I can't really give you a concise explanation of what it's all about.
09:39:19 <LiquidEngineer> I gotta bail. :)
09:39:20 <LiquidEngineer> Later
09:58:41 <dgoldsmith> ?tell LiquidEngineer just sudo rm -rf the appropriate directories in /usr/local/bin and /usr/local/lib, where "appropriate" means anything that has "6.4" in the name. Don't remove anything without a version number, or that has "6.6".
09:58:41 <lambdabot> Consider it noted.
10:19:40 * shapr boings
10:19:47 <shapr> I love my job.
10:20:32 <sieni> just sit down for a moment and take a deep breath, the feeling will go away
10:20:34 <shapr> Good morning #haskell! How's code?
10:20:45 <shapr> sieni: Hey, I'm getting paid to hack Haskell...
10:21:29 <sieni> shapr: cool
10:22:49 <shapr> So even when the feeling goes away, I think about my jobs hacking J2EE, Visual Basic, ASP/VBScript, and suddenly the feeling returns.
10:23:03 <sieni> hehe :-)
10:25:22 <\z> shapr: what are you doing these days?
10:25:43 <shapr> I'm doing Haskell contract work.
10:26:19 <\z> sweet.  what kind of project, roughly?
10:26:22 <shapr> I still have some webdev stuff on the side, even that is getting more interesting after my recent experiences.
10:26:58 <shapr> A webdev framework, even.
10:27:19 <shapr> It's fast and sweet and getting better...
10:27:53 <\z> cool!
10:28:54 <mayweed> shapr: you're very lucky first to got a job
10:28:59 <mayweed> then a sweet one
10:29:01 <mayweed> ...
10:29:14 <shapr> I agree!
10:29:20 <\z> so, how many haskell web frameworks are out there already, and how many do we need before there's one that's obviously better than everything else out there?
10:29:28 <\z> (including all the other frameworks in all the other languages)
10:29:28 <shapr> mayweed: Parlez vous franais?
10:29:46 <mayweed> shapr : oui pourquoi?
10:29:53 <mayweed> je parle si mal anglais ;)
10:30:05 <shapr> Well, your word order in English sounded like French :-)
10:30:13 <shapr> I do the same thing in Swedish...
10:30:18 <mayweed> argh
10:30:27 <mayweed> by the way you've got a nice blog
10:30:39 <shapr> That is, when I write or speak Swedish people say "That would be correct word order if you were speaking English."
10:30:42 <shapr> Thanks!
10:30:47 <mayweed> I discover Haskell thanks to it!
10:30:49 <shapr> Feel free to leave me any comments.
10:30:52 <shapr> Really?
10:30:52 <shapr> Wow!
10:31:17 <\z> shapr: yeah.  I had the same experience a year or so ago
10:31:36 <mayweed> shapr: yes...
10:31:42 * Maddas bought a book about Swedish today
10:32:12 <shapr> \z: There are several frameworks, but HAppS is clearly the best webapp server. It could still benefit from pieces found in frontend frameworks like Hope.
10:32:28 <shapr> mayweed: How did you find my blog? Which posts do you like best?
10:32:34 <shapr> Have you read both my old and new blogs?
10:32:37 * shapr boings!
10:32:47 <mayweed> shapr: I find it thanks to conjure
10:32:57 <mayweed> I was interested in a bt implementation
10:32:59 <shapr> oh!
10:33:08 <mayweed> in a different language from C/C++
10:33:21 <shapr> Lemmih and jlouis did most of the work on Conjure, I've only contributed small bits.
10:33:26 <mayweed> oh the post I like the most?
10:33:28 <shapr> But I'm good at advertising :-)
10:33:35 <shapr> Yes, which post(s) do you like best?
10:33:37 * yaarg is using haskell at work too \o/
10:33:45 <shapr> yaarg: Yay! What are you doing with it?
10:33:47 <mayweed> mmm the one where you're speaking about papers you found great
10:34:07 <yaarg> writing a statisical analysis tool for cow data
10:34:15 <yaarg> :)
10:34:52 <shapr> mayweed: Oh speaking of which, I think I've found a supplier for Richard Hamming's "The Art of Doing Science And Engineering: Learning to Learn" for only $100 USD! That's much better than the usual price of $500 USD.
10:35:10 <mayweed> shapr: I try to find it too
10:35:17 <mayweed> but it's so expensive a book
10:35:18 <shapr> Have you read the original speech? -> http://www.cs.virginia.edu/~robins/YouAndYourResearch.html
10:35:20 <lambdabot> Title: You and Your Research, http://tinyurl.com/8hbdv
10:35:25 <mayweed> and no one got it
10:35:34 <shapr> I think I found it.
10:35:39 <mayweed> yes I read it and after I bought Polya's book
10:35:47 <mayweed> which I found great
10:35:51 <shapr> But last time I found a few cheap copies of this book, I told everybody, and then they bought them first :-(
10:35:57 <shapr> So this time I won't give details until I have my own ;-)
10:36:12 <shapr> I've heard about Polya's book, but I haven't read it yet.
10:36:23 <mayweed> shapr: you will comment your reading on your blog wont you?
10:36:29 <shapr> Have you read Doerfler's "Dead Reckoning : Calculating Without Instruments" ?
10:36:32 <shapr> Yes, definitely!
10:36:33 <mayweed> so that I could know more about it
10:36:45 <mayweed> shapr: no
10:36:50 <mayweed> I dont know this book
10:36:54 <mayweed> will look at it
10:37:38 <shapr> It's about how to calculate in your head without a computer or calculator. I think the ultimate goal of programming is to find representations of problems that allow humans to calculate solutions without assistance.
10:37:47 <shapr> So for me, this book is one step in that direction.
10:38:09 <mayweed> I'm looking at the contents
10:38:13 <mayweed> seem funny
10:38:42 <shapr> peut-etre fun?
10:38:44 <mayweed> and cheap
10:38:44 <thetallguy> shapr: that's a very interesting outlook
10:39:15 <shapr> thetallguy: It's something I tried to explain at the table with you and Conal, but got tangled up before I could express it.
10:43:42 <thetallguy> Nuts, I wish I'd heard it then.
10:43:56 <thetallguy> I have a similar thought about UIs
10:44:08 <shapr> You mean that representation assists computation?
10:44:21 <thetallguy> Ultimately, the mechanisms have tobe simple and regular to be effective
10:44:37 <thetallguy> Yes,
10:44:57 <thetallguy> When you watch most people use a computer, they don't write little programs to do stuff
10:45:09 <thetallguy> They figure out a method and then repeat it over and over.
10:45:23 <astrolabe> But aren't some questions inherently complicated, independently of the representation?
10:45:25 <shapr> I think the solution is simple. Make unix shell pipes explicitly monadic.
10:45:32 <shapr> astrolabe: Yes, but many are not.
10:46:06 <thetallguy> The simple things should be simple
10:46:22 <thetallguy> decomposition into iteration, test, filter, etc
10:46:37 <thetallguy> but people who use GUIs don't get much of that
10:46:41 <shapr> Yup
10:46:48 <thetallguy> map is usually the only tool they have
10:46:50 <shapr> They're convinced that mousing is faster.
10:47:05 <thetallguy> That is, select a bunch of objects, then apply some function like coyp
10:47:09 <thetallguy> copy
10:51:45 <jeroeng> This class is driving me crazy. It's a class T a b with s::a and d::b->a->a. Now I want a t::[b]->a where t = foldl (flip d) s, but I get an error from the ghci
10:53:44 <jeroeng> Is there someone here who can point out my mistake?
10:55:11 <dcoutts_> @type foldl
10:55:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:55:28 <dcoutts_> hmm
10:55:40 <dcoutts_> jeroeng, what's the error message ?
10:56:18 <jeroeng>  Could not deduce (T a b1) from the context (T a b) Probable fix: add (T a b1) to the class or instance method `t'  In the second argument of `foldl', namely `s'
10:57:50 <dcoutts_> jeroeng, it's a thing about multi-parameter classes
10:58:01 <dcoutts_> the 'a' or 'b' is insufficiently constrained
10:58:05 <dcoutts_> so it's ambiguous
10:58:16 <dcoutts_> for example, adding a functional dep fixes it
10:58:25 <dcoutts_> not sure if that matches what you want of course
10:58:25 <jeroeng> How do I do that?
10:58:37 <dcoutts_> bear in mind it may not be the right fix
10:58:46 <dcoutts_> class T a b | a -> b where
10:59:11 <dcoutts_> actually it's 'b' here that is not sufficiently constrained
10:59:15 <dcoutts_> Could not deduce (T a b1) from the context (T a b)
10:59:37 <jeroeng> Yes, I understood that, but couldn't fix it. I tried using specifying every term's type
10:59:53 <dcoutts_> but if a uniquely determines b (that's what the '| a-> b' but does) then there's no ambiguity in which 'b' to pick
11:00:01 <dcoutts_> but/bit
11:00:13 <jeroeng> Is there another way to uniquely determine b?
11:01:44 <dcoutts_> not sure I'm afraid
11:03:08 <dcoutts_> jeroeng, ah, the problem is that 's' does not mention 'b'
11:03:32 <dcoutts_> so using 's' is almost always ambiguous
11:03:45 <dcoutts_> s :: forall b a. (T a b) => a
11:04:01 <dcoutts_> because there's no way to say what 'b' you want 's' with
11:04:22 <jeroeng> Is there a way to get around that?
11:04:23 <dcoutts_> so you could make 's' take a dummy argument of type 'b'
11:04:50 <dcoutts_> that'd allow you to select/fix which 'b' will be used
11:05:10 <dcoutts_> multi-parameter type classes often suffer from this
11:05:28 <jeroeng> It puzzles me, I read this code (with different function names) in a reader, and they didn't mention either -fglasgow-exts nor functional dependencies. Maybe it works differently in hugs?
11:05:49 <dcoutts_> hugs -98 does similar stuff
11:07:26 <dcoutts_> class T a b where
11:07:26 <dcoutts_>         s :: b -> a
11:07:26 <dcoutts_>         d :: b -> a -> a
11:07:26 <dcoutts_>         t :: [b] -> a
11:07:26 <dcoutts_>         t = foldl (flip d) (s dummy)
11:07:27 <dcoutts_>           where dummy :: b
11:07:29 <dcoutts_>                 dummy = undefined
11:07:35 <dcoutts_> this works
11:08:23 <jeroeng> Thanks
11:12:29 <jeroeng> dcoutts, would it be possible to instantiate (A a b ) as being of class T a b given a function (f::a)?
11:13:46 <dcoutts_> jeroeng, there'd often be an ambiguity about which 'b'
11:14:08 <dcoutts_> if you then use f at a type that fixes 'b' then you're ok
11:14:14 <dcoutts_> but if not then it's ambiguous
11:14:21 <jeroeng> How can I declare that I want this f ?
11:14:45 <dcoutts_> you can fix 'b' explictly in the type
11:14:57 <dcoutts_> eg: f :: a -> A a Int
11:15:05 <dcoutts_> then there's no problem
11:15:20 <dcoutts_> but if you want it unconstrained...
11:15:39 <dcoutts_> well, you'd better constrain it at the point of use
11:16:06 <dcoutts_> if neither the point where it's built or used constrain 'b' then you have a problem
11:16:23 <dcoutts_> at least if the point of use needs something in the class T a b
11:16:36 <dcoutts_> because then it needs a class disctionary to determine the correct behaviour
11:16:44 <jeroeng> Mm, I think I misstated the question. I meant given a b being of class A and a function f::a, can I instantiate a b as being of class T ?
11:16:46 <dcoutts_> but there's no way to pick that dictionary
11:17:11 <dcoutts_> a b ?
11:17:24 * glguy just found a 128mb tiny lexar usb drive walking back from lunch
11:17:33 <dcoutts_> perhaps use 'b' to distinguish the word a from the variable 'a'
11:17:39 <dcoutts_> I'm confused about your question
11:17:52 * glguy mounted it with OpenBSD to check for malicious software, but unfortunately found none
11:17:58 <jeroeng> It's a fairly obscure one, I suppose
11:19:16 <jeroeng> The idea is that I've got a class T depending on type a and b. Now I'd like to define a conversion of any such class, given a function f::a, to class A a b
11:21:15 <dcoutts_> jeroeng, you mean a type A a b which is an instance of class T a b
11:21:35 <dcoutts_> and a function f of type what ?
11:21:42 <dcoutts_> f :: a -> A a b  ?
11:22:01 <dcoutts_> f :: a   is usually not called a function, because there's no '->' in it's type
11:23:41 <jeroeng> Mm, that is close to what I had in mind. I've got a NFA of alphabeth b and states a, which I want to convert to a DFA with alphabeth b and states [a], but to do that I need a list of all states in the NFA, so that'd be  f::[b]
11:24:09 <jeroeng> Erm, f::[a]
11:25:20 <dcoutts_> perhaps you want a constructor class
11:26:00 <dcoutts_> class Machine m a b | m -> a, m -> b where
11:26:27 <dcoutts_> and then instance Machine NFA a b
11:26:48 <dcoutts_> oh, hmm, maybe that doesn't help
11:27:00 <dcoutts_> do you need a class at all ?
11:27:20 <dcoutts_> you've got lots of representations of NFAs and DFAs ?
11:28:53 <jeroeng> I suppose there are, I could need a Integral a => DFA [a] (a,a) and completely different NFA
11:29:28 <jeroeng> The types and s (tart),d(elta), finals change
11:30:19 <hyrax42> haha I just did this a few days ago
11:30:41 <int-e> following dcoutts_, Machine can have a 'states' function, of type m -> [b], and the instance could be instance Machine (NFA a b) a b
11:30:43 <hyrax42> parameterised over the monad... identity or []
11:30:49 <hyrax42> (or MonadNondet)
11:31:29 <hyrax42> ok I'm out
11:32:00 <jeroeng> So I'd still need a NFA and DFA class, and a Machine m a b which can convert between NFA and DFA ?
11:32:59 <dmhouse> Hey all.
11:33:01 <dmhouse> What's the easiest way to install Hope these days?
11:34:04 <int-e> jeroeng: wait, NFA is a class? then why don't you give that a states function?
11:34:29 <jeroeng> int-e: I don't always need it, only when I'd want to convert it to a DFA
11:34:56 <jeroeng> I'm trying to work on the Machine m a b idea, it seems really cool & abstract
11:36:51 <jeroeng> Because a NFA and DFA are virtually the same thing, there is an convertion between the two
11:48:33 <roconnor> @scheck (\a b c d -> min (a+b) (c+ d) == (min a c) + (min b d))
11:48:35 <lambdabot>  Add a type signature
11:48:48 <roconnor> @scheck (\a b c d -> min (a+b) (c+ d) == (min a c) + (min b (d:Integer)))
11:48:49 <lambdabot>  Not in scope: data constructor `Integer'
11:48:55 <roconnor> @scheck (\a b c d -> min (a+b) (c+ d) == (min a c) + (min b (d:Int)))
11:48:56 <lambdabot>  Not in scope: data constructor `Int'
11:49:01 <roconnor> @scheck (\a b c d -> min (a+b) (c+ d) == (min a c) + (min b (d::Integer)))
11:49:02 <lambdabot>  add an instance declaration for (Serial Integer)
11:49:02 <lambdabot>   In the definition of `...
11:49:08 <roconnor> @scheck (\a b c d -> min (a+b) (c+ d) == (min a c) + (min b (d::Int)))
11:49:09 <lambdabot>   Failed test no. 111. Test values follow.: -1, 0, 0, -1
11:49:44 <araujo> hello
11:57:04 <shapr> SHAZAM!
11:57:13 * shapr transforms into a purely functional superhero!
11:58:52 <dmhouse> shapr: ooh, you're around. Happen to know what the easiest way to install Hope these days is?
11:58:59 * araujo throws shuriken lambdas
11:59:16 <SamB> shapr: does that mean you can only answer questions, not do things?
11:59:54 <SamB> shapr: and that you always answer a given question in the same way?
12:00:54 <Zr40> depends on the monad :P
12:02:22 <shapr> dmhouse: cabal-install now handles everything but the top level
12:04:03 <shapr> SamB: That's entirely possible, but as I am a non-strict superhero, I guess we won't know till you ask.
12:04:35 <SamB> shapr: and that you always answer a given question in the same way?
12:04:39 <dmhouse> shapr: see you've been playing around with HAppS. How does that compare to Hope?
12:11:47 <shapr> dmhouse: HAppS is a heavy duty concurrency safe server with all sorts of cool features. It doesn't do any templating yet, all the frontend stuff uses XSLT. So I'd like to grab the purty UI parts of Hope and stick them on top of HAppS.
12:11:55 <shapr> But HAppS itself is *smooth*
12:12:07 <shapr> It's faster than CGI and nearly a full webapp server.
12:13:37 <shapr> dmhouse: Have you seen the wiki I hacked up in a coupla evenings?
12:14:02 <glguy> shapr: where do you store the articles?
12:14:40 <shapr> In a WikiState :: Data.Map String String
12:15:09 <shapr> I know that I could use lazy bytestrings for more speed and less ram usage, but it just hasn't been important yet :-)
12:15:30 <jeroeng> dcoutts, thanks for all the advise, I think I got the DFA's working now, woo :)
12:15:46 <glguy> shapr: if you wanted to modify your application state object, could you do with without losing your old data easily?
12:15:50 <dcoutts> jeroeng, oh cool
12:16:10 <glguy> i.e. add a field or something similar
12:16:12 <shapr> glguy: Yeah, that can be done, but it requires a bit of extra work.
12:16:29 <shapr> musasabi told me how, but I was lazy and just blew away the state dir when I changed the format :-)
12:17:02 <shapr> I'm still in the experimental stage for writing webapps with HAppS.
12:17:17 <shapr> I'm seriously considering doing Fermat's Last Margin on top of HAppS
12:17:31 <musasabi> Tha trick is just to prefix your state object with a version field and then write a deserializer that handles the old formats also.
12:17:36 <glguy> using the Session keeper seems like it would be a bit of a hassle...
12:17:39 <shapr> Mostly because HAppS is so fast and small that it'll be fine as on the client side.
12:18:40 <musasabi> more smooth serialization things are a todo, but want to wait for the ByteString serialization code to mature a bit.
12:18:52 <dmhouse> shapr, musasabi: does it handle the state itself? How? Using flat files or a DB?
12:18:54 <musasabi> so HAppS won't reinvent the wheel with regards to that.
12:19:15 <shapr> You get the option to automatically derive state handlers, or build your own.
12:19:35 <shapr> The autohandlers use (Read,Show) which is fast enough so far.
12:19:36 <SamB> it would be especially bad if HAppS accidentally invented a square ByteString wheel...
12:19:51 <musasabi> dmhouse: HAppS uses a pluggable Saver architecture. I have apps serializing to flat files and others with compressed and encrypted output to distributed enterprise storage things.
12:19:58 <glguy> Does HAppS have any features to help automate session management?
12:21:01 <dmhouse> musasabi: I like it. And it's waaay easier to install than bringert's stuff ;) I think I'm going to play around with it.
12:21:06 <musasabi> it has things to make it easier, but as it does not force anything about the UI (and on that level is not even aware of HTTP) it is not entirely automatic.
12:22:12 <bringert> yeah, bringert's stuff is a pain to install
12:22:29 * shapr grins
12:22:51 * shapr upgrades his installation of bringert's Text.XHtml
12:23:11 <zarvok> if anyone cares (a few people here have asked me about it this week) the tech report about the icfp contest we distributed at ICFP is now available online: http://icfpcontest.org/press/tr-06-163.pdf
12:23:23 * glguy likes that HAppS uses XSLT as the temlpating language
12:23:30 <SamB> cooool
12:23:36 <shapr> I will say that out of all the Haskell coders I know, I have the largest number of libraries installed that are authored and/or maintained by bringert.
12:24:21 <shapr> glguy: Personally, I want something like Zope Page Templates instead of XSLT, but I can live with it for the moment.
12:24:46 <SamB> how do you know how many of bringert's libs people have installed?
12:25:30 <shapr> I know how many libs *I* have installed and who wrote each of them.
12:25:38 <sjanssen> hey musasabi, how did your UTF-16 hacking turn out?
12:26:38 <dcoutts> dons, you get a mention here: http://msevior.livejournal.com/12752.html
12:26:40 <lambdabot> Title: msevior: Google Summer of Code Mentors Summit.
12:35:23 <musasabi> sjanssen: it suffers from a lack of time.
12:37:16 <rnz_`> Wedding cake tops $20 million (1:22)
12:37:16 <rnz_`> A confection billed as the most expensive wedding cake in the world is on display in Los Angeles. (October 17)
12:38:42 <sjanssen> musasabi: if you'd like, you can send me patches.  Maybe I could help?
12:39:18 <dmhouse> I'm having trouble building HAppS.
12:39:24 <dmhouse> Err, HaXml.
12:39:32 <musasabi> dmhouse: use Cabal not configure.
12:39:42 <dmhouse> musasabi: right, so the README is out of date?
12:39:48 <musasabi> dmhouse: yes.
12:39:59 <musasabi> dmhouse: complain to the HaXml author.
12:40:16 <musasabi> He has been very responsive to bug reports.
12:40:39 <musasabi> sjanssen: it was left in quite a mess after a partial rewrite.
12:40:50 <dmhouse> I used 'make', which errored, and then 'make' again, and got down to 1259 levels of make before it declared 'make[1259]: Makefile:45: pipe: Too many open files in system' and that error proliferated back through all those levels.
12:41:02 <dmhouse> Left my system thrashing like nothing I've seen. :)
12:45:07 <\z> shapr: you should have mentioned HAppS is derived from Twisted, SEDA, and Prevayler
12:45:14 <\z> sounds much more impressive that way.  :-)
12:51:39 <dmhouse> Where do I get the regex-compat package?
12:52:20 <musasabi> \z: see the homepage :-)
12:52:31 <musasabi> dmhouse: ghc 6.6 ships with it.
12:52:49 <dmhouse> musasabi: and for those lesser mortals without 6.6 yet? :)
12:52:55 <musasabi> dmhouse: if you are using 6.4 you might benefit of using the HAppS.cabal.ghc64 instead of the GHC 6.6 cabal file.
12:54:39 <dmhouse> musasabi: ah, sorry, didn't see that.
12:54:46 * dmhouse thinks about just upgrading anyway
12:59:47 <\z> musasabi: that's where I found it.  ;-)
13:01:38 <SamB> zarvok: well that explains why UMIX doesn't have any full-on leaks...
13:01:38 <\z> so, is hope supposed to be one step above an app server?
13:01:41 <dmhouse> musasabi: Using HAppS.cabal.ghc64 says 'Setup.hs: cannot satisfy dependency fps>=0.8', but the highest FPS available from the website is 0.7.
13:02:31 <shapr> _rnz-: dude, wedding cakes are way off topic, that's what #haskell-blah is for
13:03:19 <shapr> dmhouse: darcs version of fps
13:04:24 <musasabi> dmhouse: the latest stable version has some problems with the API (not compatible with 6.6) and bugs.
13:04:37 <musasabi> dmhouse: thus the darcs version which is very stable.
13:04:44 <dmhouse> Fair enough.
13:05:57 <shapr> \z: I'll mention that in the future.
13:06:02 <dcoutts> CosmicRay, bringert has a simple web site tool for darcs-managed cabalsied libs. It would be a good place to start.
13:06:04 <spiffy> how to unpack something from Maybe?
13:06:29 <spiffy> *do you
13:06:44 <musasabi> @type fromJust
13:06:46 <lambdabot> forall a. Maybe a -> a
13:07:00 <SamB> wow
13:07:01 <dmhouse> ?type fromMaybe
13:07:02 <lambdabot> forall a. a -> Maybe a -> a
13:07:06 <dmhouse> ?type maybe
13:07:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:07:13 <dmhouse> ?docs Data.Maybe
13:07:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
13:07:19 <spiffy> thanks SamB
13:07:19 <dmhouse> Look at the last one for documentation.
13:07:24 <spiffy> thanks
13:07:38 <dmhouse> spiffy: a case statement would work too
13:07:53 <spiffy> ?
13:08:00 <spiffy> oo
13:08:06 <spiffy> that would work much nicer
13:08:14 <dmhouse> > let x = Just 4 in case x of Just a -> a; _ -> 5
13:08:18 <lambdabot>  4
13:08:24 <dmhouse> > let x = Nothing in case x of Just a -> a; _ -> 5
13:08:25 <lambdabot>  5
13:08:28 <SamB> UM on UM on x86 is faster than: UM on Java with no JIT, UM on Bigloo, and UM on Python...
13:08:37 <dmhouse> dons: ping
13:08:41 <dmhouse> ?localtime dons
13:08:42 <lambdabot> Local time for dons is Wed Oct 18 06:08:19 2006
13:08:54 <dmhouse> FPS-darcs won't build :(
13:09:02 <dmhouse> I hate manually compiling things.
13:09:16 <musasabi> dmhouse: "runghc Setup configure", +build +install ?
13:09:35 <sjanssen> dmhouse: I don't suppose you're on GHC 6.6?
13:10:03 <dmhouse> sjanssen: nope.
13:10:35 <lisppaste2> dmhouse pasted "BS build problems" at http://paste.lisp.org/display/28158
13:10:37 <mux> SamB: btw, I was wondering, did they provide this um.um just to confuse people? :)
13:10:43 <dmhouse> ^^ Les erreurs.
13:11:14 <mux> dmhouse: french?
13:11:36 <musasabi> dmhouse: I see you have some version of 6.5 ?
13:11:40 <dmhouse> mux: no, I just like to intersperse my daily commentary with other languages. :)
13:11:51 <musasabi> dmhouse: are you sure that it is not simply a broken GHC?
13:11:56 <spiffy> func one two = Just $ not $ fromJust $ func two one   func:: a->a-> Maybe Bool
13:12:00 <mux> dmhouse: :-)
13:12:07 <spiffy> is there a nicer way to write that?
13:12:08 <dmhouse> musasabi: yeah, but I've managed to compile other stuff successfully.
13:12:13 <mux> dmhouse: at least you're able to write correct french, unlike most people :)
13:12:22 <SamB> mux: I think it was for amusement purposes?
13:12:24 <sjanssen> dmhouse: is this a fairly old 6.5 build?
13:12:24 <musasabi> spiffy: no. fmap not $ fun two one
13:12:31 <mux> SamB: maybe yes
13:12:35 <dmhouse> mux: vous êtes français?
13:12:47 <mux> dmhouse: oui
13:12:48 <SamB> perhaps you were supposed to dissasemble it while waiting for the contest results to be announced?
13:12:49 <dmhouse> Français(e) I should say.
13:12:53 <spiffy> afk for a moment (doorbell), leave any nice sollutions.
13:13:00 <mux> franais, indeed :)
13:13:09 <SamB> it could have been another red herring, too ;-)
13:13:15 <dmhouse> sjanssen: it's not that recent, can I pass a flag to get a build date?
13:13:18 <SamB> but not much of one
13:13:34 <SamB> Team Smartass really lives up to its name ;-)
13:14:25 * shapr blinks cluelessly...
13:14:34 <SamB> shapr: what about?
13:14:38 <shapr> Couldn't match expected type `Html' against inferred type `Text.XHtml.Html'
13:14:57 <shapr> They're the same type...
13:15:03 <sjanssen> dmhouse: here is my theory:  GHC 6.6 relaxed some of the RULES matching stuff, I think your build is from sometime before those changes made it into GHC
13:15:07 <SamB> which system are you using?
13:15:17 <shapr> I'm using Text.XHtml.Html with ghc 6.6
13:15:18 <musasabi> dmhouse: ghc --version
13:15:34 <dmhouse> musasabi: that's included in the paste I gave
13:15:35 <shapr> musasabi: Did you have this problem when you built wiki.hs ?
13:15:41 <SamB> what happens if you comment out the offending code and say :i Html?
13:15:52 <musasabi> shapr: I can upload my version.
13:16:06 <dmhouse> sjanssen: so a GHC6.6 is really required?
13:16:19 <sjanssen> dmhouse: or just a more recent 6.5
13:16:24 <dmhouse> As if it won't build on my 6.5 then 6.4 should be out of the question
13:16:28 <musasabi> shapr: youzen.b2.fi/~musasabi/wiki.hs
13:16:28 <SamB> for that matter, feel free to comment out any code other than datatype definitions ;-)
13:16:29 <sjanssen> I remind you that I'm just speculating
13:16:37 <sjanssen> dmhouse: this is fps-unstable, yeah?
13:16:42 <musasabi> dmhouse: both 6.4.2 and 6.6 work.
13:16:46 <dmhouse> sjanssen: probably time I upgraded to 6.6 nonetheless.
13:16:48 <dmhouse> sjanssen: yeah.
13:16:52 <dmhouse> musasabi: hrm, okay.
13:17:03 <musasabi> dmhouse: it should not be fps-unstable. But fps.
13:17:05 <dmhouse> Well, open question: I'm on Ubuntu. What's the easiest way to upgrade?
13:17:19 <dmhouse> musasabi: it's whatever is in the darcs repo.
13:17:35 <musasabi> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/fps
13:17:35 <lambdabot> Title: Index of /~dons/code/fps
13:17:45 <musasabi> dmhouse: there is a separate fps-unstable repo.
13:17:58 <dmhouse> That's the one I got.
13:18:21 <musasabi> dmhouse: and that works with GHC 6.4 and 6.6 (and Hugs etc)
13:19:27 <dmhouse> Okay.
13:19:31 <dmhouse> I think the upgrade is the best option.
13:19:39 <dmhouse> Any advice on my above question then?
13:20:10 <sjanssen> GHC 6.6 has the Data.ByteString modules, so you shouldn't need the fps package at all
13:20:14 <musasabi> 6.5.<date> versions vary wildly by the date and can be broken in various ways.
13:20:17 <shapr> Doh! leftover .hi files after upgrading my XHtml package.
13:21:08 <dmhouse> sjanssen: good, that'll make life simpler.
13:21:40 <sjanssen> dmhouse: you'll probably need to remove the fps dependency from the .cabal file
13:21:54 <sjanssen> in whatever project you're building that depends on fps
13:22:14 <musasabi> dmhouse: don't worry, the HAppS.cabal for 6.6 won't have a fps dep :-)
13:23:13 <dmhouse> The question still stands: what's the best way to make the upgrade? darcs pull and install it on top of my 6.5?
13:23:48 <musasabi> dmhouse: use a package for your operating system?
13:24:46 <dmhouse> There are only Red Hat and SUSE RPMs available, it seems.
13:25:10 <dmhouse> I think I'll try the darcs method
13:26:31 <musasabi> dmhouse: the generic linux binary works at least on debian.
13:37:48 <dmhouse> Anyone succeeded in compiling HaXml for 6.6?
13:38:01 <dmhouse> I get a message about the missing Data.FiniteMap, which I guess was finally removed.
13:38:54 <shapr> It works for me.
13:38:59 <shapr> Are you using 1.13.2 ?
13:39:27 <dmhouse> Oh, perhaps not. I had an old tar hanging around with 1.13 in the filename, I figured it was .2, but maybe it's not.
13:39:32 * dmhouse pops off to do more downloading.
13:40:06 * mux would really like to know how to handle blocking operations on handles in a concurrent environment
13:44:13 <roconnor> > 4 .&. 7
13:44:14 <lambdabot>  Add a type signature
13:44:19 <roconnor> > 4 .&. 7 :: Integer
13:44:20 <lambdabot>  4
13:44:27 <roconnor> > 4 .&. (-4) :: Int
13:44:29 <lambdabot>  4
13:44:42 <roconnor> > 5 .&. (-5) :: Int
13:44:43 <lambdabot>  1
13:44:49 <roconnor> ah
13:46:51 <dmhouse> *Yawn* waiting for compilations is not fun.
13:48:16 <jgrimes> dmhouse, very true.
13:51:06 <dmhouse> Right. We _finally_ have all of HAppS's dependencies installed. Moving on to HAppS itself :)
13:51:19 * dmhouse starts another length compilation
13:52:57 <jgrimes> it'd be nice to have something like disthaskell
13:53:06 <shapr> It's called cabal-install.
13:53:38 <dmhouse> TBH, HAppS doesn't have that many dependencies. It was the upgrading GHC that made things complicated.
13:53:53 <jgrimes> shapr, how usable is cabal-install?
13:54:00 <shapr> I dunno, I haven't used it yet =)
13:54:16 <jgrimes> So who is going to test the waters? :p
13:54:32 <shapr> What, am I number one pioneer here? ;-)
13:54:41 <shapr> It's true, I know...
13:54:50 <dmhouse> jgrimes: why don't you give it an install and find out? :)
13:55:04 <dcoutts> prod xerox
13:55:11 <dcoutts> he's cabal-install man
13:55:34 <shapr> bringert told gmh at Haskell Workshop that every Haskell programmer has at least one user, and that's Shae Erisson.
13:55:46 <jgrimes> haha
13:55:51 <jgrimes> :)
13:55:56 <SamB> shapr: do you use my z-machine?
13:56:01 <dmhouse> GMH?
13:56:05 <shapr> Graham Hutton
13:56:08 <SamB> if so, send me the patches you used to make it usable!
13:56:24 * xerox hugs dcoutts
13:56:29 <dmhouse> Cool, HAppS is working! :)
13:56:29 <shapr> Johan Jeuring and a coupla other people were standing next to gmh.
13:56:32 <shapr> yay!
13:56:37 <shapr> dmhouse: Now try my wiki!
13:56:39 * shapr boings
13:56:53 <dcoutts> xerox, I've hardly talked to you for weeks!
13:57:04 <dcoutts> xerox, I'd like to ask about several things
13:57:07 <shapr> SamB: No, I haven't tried it yet, but I nearly did several times.
13:57:13 <SamB> heh
13:57:17 <dmhouse> shapr: I'm going to start hacking together some forum software, methinks.
13:57:20 <SamB> it doesn't scroll right :-(
13:57:22 <shapr> spiffy!
13:57:26 <xerox> dcoutts, yeah, crazy, this school is making me crazy
13:57:34 <shapr> That was my next todo item for HAppS, forum software.
13:57:46 <dcoutts> xerox, so where are you in that uni process ?
13:57:53 <dmhouse> shapr: cool.
13:57:58 <SamB> and it outputs the stuff that should go to the status area into the middle of the main text stream...
13:58:09 <shapr> I was thinking about starting with your average data Tree a = ... and sticking a Message record in there.
13:58:27 <SamB> heh
13:58:43 <SamB> that sounds so simple!
13:59:21 <dmhouse> Yay, Hello World works!
13:59:22 <xerox> dcoutts, "uni" as in "university" ?
13:59:26 <shapr> dmhouse: Once you've read the HAppS tutorial and wiki.hs, you'll only need to hack the wiki display part to display/format a tree of values instead, via XSLT.
13:59:28 <dcoutts> xerox, aye
14:00:09 <dmhouse> shapr: you think it'd be a good idea to write a forum off the back of wiki? They seem rather distinct.
14:00:51 <shapr> Yeah, they are distinct, but building a webapp with HAppS is pretty much just display and save.
14:01:40 <xerox> dcoutts, I'm thinking mathematics all day long from two weeks
14:01:44 <dmhouse> shapr: so what's the general strategy? Take the state, spit out some XML and throw it through an XSLT?
14:01:57 <dcoutts> xerox, cool :-) but exhausting
14:01:57 <shapr> yup
14:02:01 <xerox> dcoutts, but there's a good part to that, I've met very nice people, and we exchanged a lot of interesting ideas
14:02:23 <dcoutts> xerox, so are you still in the application process or have you started on a course ? what uni?
14:02:27 <jeroeng> Is there a standard function that concatenates a list of lists into one list and removes the doubles?
14:02:35 <dcoutts> jeroeng, nub . concat
14:03:16 <jeroeng> Ah, concat, forgot about that one, thanks dcoutts
14:03:24 <jeroeng> I think I've got the NFA's fixed now
14:03:49 * shapr always sees NFI
14:03:58 <xerox> dcoutts, two weeks ago, I applicated the very last day, usual to me, hehe, but I started the courses from the very first day.
14:04:17 <dcoutts> xerox, cool, was it that very hard place or somewhere else ?
14:04:18 <xerox> dcoutts, I'm doing Mathematics at the University of Turin.
14:04:27 <dcoutts> that's the rock hard one right ?
14:04:49 <xerox> I've gave up to the idea of the very hard place, I noticed another interesting grant.
14:04:57 <shapr> Cool, xerox goes to Turing University! ;-)
14:05:04 <SamB> what about those who are allergic to XSLT's syntax?
14:05:05 <xerox> Actually, Peano's :)
14:05:13 <dcoutts> xerox, oh nice. well congrats for getting on the course
14:05:23 * shapr imagines each little student in his own room, all on a long Turing Tape.
14:05:25 <xerox> Which I didn't unfortunately make, but it's fine, I've got the "Google" grant.
14:06:14 <xerox> Thank you, I'm liking the place.
14:07:03 <dcoutts> xerox, sounds like you've cdone well, a mathematics degree is an excelent start to a carear in computer science :-)
14:07:23 <dcoutts> xerox, I'll be asking you all my domain theory and category theory questions ;-)
14:07:47 <xerox> Great!  And I've been thinking of the same thing!
14:08:57 <dcoutts> xerox, so you said a while ago you might be visting Oxford. Is that still the plan? If so, when?
14:09:22 <xerox> I said I might be visiting London, and you wanted to drag me up there :)
14:09:26 <dcoutts> There's a room here for you any time between now and the end of November
14:09:42 <dcoutts> when! when!
14:09:52 <xerox> On the 27th.
14:09:53 * dcoutts drags the information out of xerox 
14:10:02 <dcoutts> of which month ?
14:10:06 <xerox> This one.
14:10:12 <dcoutts> so in 10 days time
14:10:23 <xerox> Yes, very early.
14:10:43 <dcoutts> xerox, so how long are you here? what day might you be free to come to Oxford ?
14:11:30 <xerox> I still got to plan the thing, if I consider to go, in fact.  It's a visit to the local "Google London" site.
14:13:18 <xerox> (For SoC people.)
14:14:37 <xerox> ?users
14:14:59 <lambdabot> Maximum users seen in #haskell: 256, currently: 229 (89.5%), active: 31 (13.5%)
14:16:03 <dmhouse> shapr: where's ReadMap from?
14:16:12 <xerox> People come and go all the time here, it's busier than a seaport.
14:19:13 <astrolabe> @hoogle ReadMap
14:19:13 <lambdabot> No matches found
14:26:35 <mauke> I have a question about the FFI
14:26:47 <mauke> how can I import functions that deal with structs, like stat()?
14:40:44 <Igloo> Can I get more informatino from cabal than "setup-ghc: Package HGL-3.1 can't be built on this system."?
14:41:51 <bpc> I'm working through the "Write Yourself a Scheme in 48 hours" and have a question about style.
14:41:58 <lisppaste2> bpc pasted "parseQuoted" at http://paste.lisp.org/display/28163
14:42:43 <bpc> First of all, I had to define my own assoc for this. Is there something like assoc built into any of the standard haskell libraries?
14:43:11 <Igloo> lookup
14:43:29 <dmhouse> ?hoogle lookup
14:43:29 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
14:43:30 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
14:43:30 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
14:43:52 <bpc> Ah, OK.
14:43:55 <dmhouse> musasabi: ping.
14:44:59 <bpc> Now, what's the best way to get something out of a maybe, when I don't really care about the Nothing case (since in this example, it can't happen)
14:45:00 <musasabi> pong
14:45:12 <dmhouse> bpc: See the Data.Maybe docs.
14:45:17 <dmhouse> ?docs Data.Maybe
14:45:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
14:45:23 <dmhouse> You probably want fromJust or fromMaybe.
14:45:35 <dmhouse> musasabi: why does lookS require a maximum length?
14:45:54 <dmhouse> musasabi: the other variants e.g. look, lookMb etc. don't seem to require one so it seems an oddity.
14:45:57 <bpc> Yep, fromJust should do it.
14:46:22 <musasabi> dmhouse: to avoid the case with overly long inputs.
14:46:36 <musasabi> (I didn't design that part of the API)
14:46:37 <dmhouse> Really I want a lookNew :: Request -> String -> Maybe String
14:47:15 <dmhouse> I think that would probably cover most use cases, and you can read values you extract from there anyway, making that one useful.
14:47:25 <musasabi> dmhouse: better to have "lookM :: Monad m => String -> Request -> m String" probably?
14:47:46 <dmhouse> That'd work.
14:48:45 <musasabi> dmhouse: try lookM = lookMb return
14:51:28 <dmhouse> musasabi: looks like it'll work, thanks.
14:51:42 <dmhouse> musasabi: any chance of including that into HAppS.Protocols.MessageWrap? :)
14:51:46 <dmhouse> I think it'd be useful.
14:53:00 <musasabi> dmhouse: submit a patch, I think it looks sensible for inclusion :-)
14:56:05 <musasabi> (just going to sleep, but if you don't want to create the patch, I can do it later if you bug me)
14:57:50 <dmhouse> musasabi: could I send you a diff of the file instead? Mine isn't the darcs version so it'd require extra hassle.
14:59:48 <dmhouse> musasabi: I have to dash so I'll send you said diff then make a proper patch tomorrow if I have time.
15:27:43 <Kakihara> An odd place to be asking this but I'm running out of ideas. Does anyone here have experience with graph theory - specifically the Hopcroft-Tarjan algorithm?
15:31:48 * araujo saluda a br1 
15:37:58 <shapr> I know Tarjan in the context of amortization of algorithms...
15:38:35 <shapr> Kakihara: It seems there's at least one paper that tries to make that algorithm easier to understand - http://citeseer.ist.psu.edu/kocay93hopcrofttarjan.html
15:38:45 <lambdabot> http://tinyurl.com/wktye
15:39:35 <Kakihara> shapr: I think I understand the algorithm pretty well only I've come across a problem with it.
15:39:37 <shapr> Kakihara: I have to ask, did the guys in #math send you over here to #haskell?
15:40:27 <shapr> Well, if Pseudonym or Cale were awake, you could ask them.. they might have a clue.
15:40:29 <Kakihara> shapr: No. They weren't able to help but they didn't suggest Haskell. I thought that Haskell programmers might be mathematically inclined though
15:41:10 <shapr> Yeah, they are.
15:41:19 <Kakihara> They refers to the people in #math, not Pseudonym or Cale - I'll look out for them, thanks.
15:42:05 <shapr> If Martin Erwig were here, I'm sure he could help, but he's only been here once or twice.
15:43:19 <dibblego> http://undefined.com/ia/2006/10/16/you-might-be-a-blub-programmer/
15:43:24 <lambdabot> Title: Indefinite Articles » You might be a &#8220;Blub&#8221; programmer&#8230;, http://tinyurl.com/y5chp4
15:43:29 <dibblego> bug in lambdabot ?
15:43:59 <shapr> I don't think so. I think some HTML entities just can't be mapped to ASCII.
15:45:32 <shapr> dibblego: You could hack that plugin to clean out non-ASCII
15:45:48 <dibblego> I could, but I'm not that proficient yet
15:47:28 <shapr> You'd be surprised :-)
15:47:34 <shapr> Can you filter a list?
15:47:48 <dibblego> are all data types of the form "data Type | Ctor1 Arg0 ... Argn | Ctor2 Arg...?
15:47:52 <shapr> Can you write a function that checks to see if a character is ascii?
15:47:55 <dibblego> yeah I know :)
15:47:58 <shapr> If so, then you can improve that plugin.
15:48:33 <dibblego> I'd have trouble finding *where* to implement it
15:48:50 <dibblego> I once asked someone how to write a natural integer type
15:48:50 <shapr> You could try grepping for tinyurl in the lambdabot sources.
15:49:05 <dibblego> and they gave me a data type declaration
15:49:26 <dibblego> I'm thinking of writing a doubly-linked list type and then some functions for it just for an exercise
15:49:34 <dibblego> but I don't know how to make it polymorphic
15:49:42 <shapr> Have you seen polymorphic trees?
15:49:48 <dibblego> no
15:49:55 <shapr> Have you seen the Maybe type?
15:49:59 <dibblego> yes
15:50:06 <shapr> Do you see how it's polymorphic?
15:50:13 <dibblego> I will look again :)
15:50:53 <sjanssen> dibblego: doubly linked lists are quite tricky in Haskell
15:51:00 <sjanssen> you might want to try another data structure
15:51:01 <dibblego> why
15:51:20 <dibblego> writing the functions you mean or writing the data type
15:51:20 <dibblego> ?
15:51:52 <shapr> The functions to update the doubly linked list are exciting.
15:51:59 <dibblego> yeah I thought they would be
15:51:59 <sjanssen> well, getting the cyclic stuff is difficult
15:52:04 <dibblego> but not too difficult I would think
15:52:13 <astrolabe> referential transparency makes it hard to think about.
15:52:13 <shapr> Yeah, not too difficult.
15:52:14 <kpreid> shapr: are they even possible?
15:52:22 <shapr> kpreid: Sure, seen the credit card transform?
15:52:25 <kpreid> no
15:52:44 <shapr> http://www.haskell.org/hawiki/CreditCardTransform
15:52:46 <lambdabot> Title: CreditCardTransform - The Haskell Wiki, http://tinyurl.com/y5zfbe
15:52:46 <dibblego> data LinkedList | Nil | Node Int LinkedList LinkedList -- is that right for a doubly linked list of Int?
15:53:11 <astrolabe> Also, update is inefficient I think, if you use true functional code.
15:53:13 <sjanssen> dibblego: data LinkedList = ...
15:53:20 <dibblego> ah thanks
15:53:39 <sjanssen> dibblego: I'd suggest another data structure.  Maybe a simple binary tree?
15:53:43 <dibblego> righto then
15:53:51 <dibblego> I can't get to it today anyway
15:54:00 <shapr> kpreid: That gets especially nifty when you hit mdo.
15:54:00 <dibblego> finding GHC source is a pain on ubuntu/debian
15:54:05 <sjanssen> writing a pure DLL is 1) tricky, 2) won't be particularly useful
15:54:06 <dibblego> wtf is mdo?
15:54:06 <astrolabe> The polymorphism is the easy bit.
15:54:17 <shapr> dibblego: It's value recursion.
15:54:31 <dibblego> data LinkedList a = Nil | Node a LinkedList LinkedList -- polymorphic?
15:54:33 <astrolabe> @hoogle mdo
15:54:33 <kpreid> shapr: That page seems to contain only a link and the referenced page (CircularProgramming) is not relevant.
15:54:38 <lambdabot> No matches found
15:54:47 <astrolabe> dibblego yes
15:54:52 <dibblego> I'm just guessing - can't find this dang source
15:54:54 <shapr> kpreid: I like the blurb, "buy now, pay later" :-) that's why I didn't just give you the next link.
15:55:00 <astrolabe> ah not quite
15:55:01 <sjanssen> dibblego: close, note that LinkedList on the RHS of the = need a type parameter
15:55:12 <kpreid> shapr: but it doesn't seem to be relevant to traversing a circular structure.
15:55:14 <shapr> kpreid: But I'll do that in the future.
15:55:26 <dibblego> sjanssen, you mean the Nil?
15:56:11 <shapr> kpreid: Sure it is. """Use lazy evaluation to access results which could not possibly be calculated yet."""
15:56:12 <sjanssen> dibblego: nope, LinkedList on the RHS needs to be applied to a type
15:56:23 <kpreid> shapr: but how do you know when to stop?
15:56:28 <astrolabe> data LinkedList a = Nil | Node a (LinkedList a) (LinkedList a)
15:56:46 <shapr> Oh. I read about that somewhere....
15:56:49 <dibblego> sjanssen, I think I see waht you mean
15:56:49 <kpreid> shapr: that is, when to stop going around the circular structure and tie it back to the updated node?
15:56:53 <kpreid> that's what I'm asking about
15:56:59 <SamB_XP> kpreid: huh?
15:57:08 * dibblego finds the GHC source and puts a symlink in so that he can find it next time
15:57:13 <kpreid> as far as I know it's impossible in Haskell, but if it is possible then I'd like to know because it's relevant
15:57:13 <shapr> kpreid: Well, a linked list isn't circular, is it? Ring buffer, yeah, but that wasn't what dibblego asked for :-)
15:57:24 <kpreid> er...
15:57:25 <kpreid> sorry.
15:57:28 <ski> (nitpick : 'Maybe' (e.g.) isn't polymorphic, it's parametric)
15:57:36 <shapr> ski: Oh, thanks :-)
15:57:41 <SamB_XP> > cycle "Hi!"
15:57:42 <dibblego> shapr, no, but why did you even say that?
15:57:42 <lambdabot>  "Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!Hi!...
15:57:44 <kpreid> My mistake.
15:57:51 <SamB_XP> shapr: it isn't?
15:57:52 <shapr> kpreid: But I have read about a way to do that.
15:58:00 <kpreid> I read "doubly-linked list" and thought "circular doubly-linked list".
15:58:01 <astrolabe> ski: parametric polymorphism?
15:58:11 <kpreid> shapr: oh?
15:58:16 <sjanssen> I don't think circularity matters here
15:58:21 <ski> astrolabe : yes, they are related, by that
15:58:25 <shapr> kpreid: Oh I remember, Hudak showed a cheesy way to do it, he just factored out the cycles into combinators so it was never cyclic :-)
15:58:46 <dibblego> data Maybe a = Nothing | Just a
15:58:48 <shapr> It was on haskell or haskell-cafe between 0.3 and 0.75 of a year ago.
15:59:04 <astrolabe> ski: I thought it was an example of parametric polymorphism, which is therefore I type of polymorphism.
15:59:13 <kpreid> you mean combinators like (\f z l -> foldr f z (cycle l))?
15:59:39 <shapr> Something like that, yeah.
15:59:48 <ski> astrolabe, shapr : 'Maybe' is parametric since it takes a parameter (iow, it's a type-function) .. now parametric types very often gives rise to (parametrically) polymorphic functions (or other values)
15:59:52 <astrolabe> http://www.haskell.org/hawiki/TyingTheKnot
15:59:54 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
16:00:00 <dibblego> so a binary tree would be: data BTree a = Nil | Node a (BTree a) (BTree a)
16:00:17 <sjanssen> dibblego: exactly
16:00:21 <dibblego> ok thanks
16:00:34 <dibblego> what about a natural integer?
16:00:37 <astrolabe> ski: thanks I see.
16:00:57 <sjanssen> data Nat = Zero | Succ Nat
16:01:12 <ski> (but e.g. 'map toUpper :: [Char] -> [Char]' is not polymorphic, even though its type signature mentiones the parametric type '[]')
16:01:16 <kpreid> astrolabe: indeed, that's another solution
16:01:22 <shapr> kpreid: I'm sure you can track down the post by looking at haskell and -cafe for Paul Hudak, he doesn't post much.
16:01:53 <dibblego> sjanssen, how do you write the value 7 of that type?
16:02:16 <kpreid> I ended up solving my circularity problem by making sure there's always at least one identity in the cycle, and using it to know when I've reached a cycle
16:02:28 <sjanssen> dibblego: how about two: Succ (Succ Zero)
16:02:40 <dibblego> ah I was thinking something like that
16:03:14 <dibblego> so then you'd probably write a function Nat -> Integer
16:03:27 <sjanssen> here is the function to turn an Int to a Nat: \n -> iterate Succ Zero !! n
16:04:03 <dibblego> why isn't this type in the Prelude?
16:04:17 <astrolabe> It isn't very useful.
16:04:21 <dibblego> ?type iterate
16:04:22 <lambdabot> forall a. (a -> a) -> a -> [a]
16:04:41 <dibblego> why isn't it useful?
16:04:50 <sjanssen> dibblego: it's quite wasteful wrt space.  The number n is O(n) in space usage
16:05:08 <astrolabe> because Int is much quicker and has lots of functions already defined on it.
16:05:46 <dibblego> yes, but there are cases where you have to fail at runtime if you receive a negative value
16:06:14 <dibblego> this type gives failure at compile time
16:06:21 <shapr> Yup, that's always the tradeoff.
16:06:25 <shapr> The next step is value types.
16:06:27 <dibblego> suppose I was modelling a person's age
16:06:37 <astrolabe> go on
16:06:42 <dibblego> rarely I'd get to "large" values of n
16:06:43 <shapr> Then you get into dependently typed languages like Epigram, where there isn't much difference between types and functions.
16:06:49 <sjanssen> dibblego: there is Data.Word that has unsigned integral types
16:07:06 <dibblego> what's a value type?
16:07:09 <dibblego> thanks sjanssen
16:07:16 <shapr> It's a type that holds a number.
16:07:23 <astrolabe> give an example of code that gives a compile time error with Nat but a run time error with Integer.
16:07:30 <shapr> So you can fail at compile time when a calculation will fail.
16:08:07 <dibblego> f n | n < 0 = error "n must be greater than 0" | otherwise = x
16:08:43 <dibblego> f2 :: Nat -> Blah f2 n = x
16:10:00 <astrolabe> So I define a type:   newtype PosInteger = PosInteger Integer
16:10:19 <dibblego> I don't even know what newtype does
16:10:25 <astrolabe> what I mean is, your code is incomplete
16:10:38 <dibblego> why?
16:10:39 <astrolabe> it has a free variable
16:10:52 <dibblego> all variables are free, I've never paid for one
16:11:03 <astrolabe> where does n come from?
16:11:07 <dibblego> (read: I don't know what you're talking about)
16:11:35 <dibblego> for f, n comes from whoever calls it with a type Integer - for f2, same but for type Nat
16:12:12 <dibblego> am I making a mistake? I honestly cannot see it
16:12:42 <astrolabe> you can replace newtype with 'data'
16:13:04 <dibblego> ok
16:13:25 <dibblego> I still don't see your point though
16:14:02 <astrolabe> then     Zero = PosInteger 0
16:14:25 <astrolabe> succ (PosInteger n) = PosInteger (n+1_
16:14:29 <astrolabe> succ (PosInteger n) = PosInteger (n+1)
16:14:43 <dibblego> I'm not following, maybe I'll understand later
16:15:01 <astrolabe> and you have a type which has isomorphic behaviour to Nat, but is much more efficient.
16:15:46 <astrolabe> Sorry if I've confused you.
16:15:58 <dibblego> you haven't - I think I'll just defer my understanding of your point
16:16:08 <astrolabe> :)
16:16:12 * astrolabe goes to bed
16:16:17 <dibblego> thanks seeya
16:17:12 <cjeris> (Novice question) I'd like to know the right Haskell name for a construct I'm trying to use in an SML program I'm writing, which I think is a monad thing.  I have a compiler front-end which uses assignment to add symbols to a symbol table s: fun scan stmt = (* does some recursive stuff and mutates s *).
16:18:05 <cjeris> I want to change this to be pure: fun scan s stmt = (* when stmt = [s1, s2, s3] *) let s' = scan s s1 in let s'' = scan s' s2 in let s''' = scan s'' s3 in s''' end end end.
16:18:43 <cjeris> So the symbol table is passed along with the real result of the scan operation (which real result actually doesn't appear in the previous line).
16:19:11 <kpreid> cjeris: if it helps, the s''' code is precisely what is usually done in Haskell using the State monad.
16:20:06 <lispy> cjeris: is (* this a comment ? *)
16:20:29 <lispy> ah, yeah i see, talking about sml
16:20:55 <shapr> You may also want to look at monads for unique name supply (unique?) and name/value bindings (reader).
16:21:26 <lispy> shapr: heya, how goes the wiki?
16:22:23 <lispy> i really wanted to read this webpage
16:22:24 <lispy> http://lamp.epfl.ch/~emir/bqbase/2006/10/16/erasure.html
16:22:28 <lambdabot> Title: Comparing Impact of Type Erasure in Scala and Java, http://tinyurl.com/y2rdvm
16:22:38 <lispy> but the jerk that wrote it made sure it wouldn't format correctly in my browser! ;)
16:22:46 * lispy grrrs at fixed width pages
16:23:09 <shapr> I got rid of ReadMap since I switched to 6.6, and fixed the XHtml generation to work with the latest version of bringert's Text.XHtml.
16:23:49 <shapr> I have one other thing to do first, but after that I'm going to install my wiki on HAppS.org to hold documentation and FAQs, yay!
16:24:16 <lispy> shapr: sweetness
16:24:53 <shapr> HAppS is sweet. I'm enjoying it.
16:25:21 <cjeris> hm.  i think that Control.Monad.State is sort of the right construct.  thanks all.
16:26:55 <shapr> I like the transparent serialization. Zope had that too, but it was permanently transparent, you couldn't change it without messing with deep and scary ZODB internals. HAppS has a Template Haskell automatic serialization deriver, but it gives you the option to use any serialization you want. So when I want speed, I'll be able to use Binary instead of Read & Show.
16:29:39 <thetallguy> shapr:done any performance tests on HAppS
16:29:41 <thetallguy> ?
16:30:24 <shapr> Yeah, it's insanely faster than Zope.
16:30:39 <thetallguy> even under load?
16:31:10 <shapr> Don't know that, I just compared my wiki to a Zope wiki with ab.
16:31:11 <thetallguy> Actually, scratch that.  I'm not surprised.
16:31:31 <thetallguy> Zope is written in Python?
16:31:33 <shapr> Yup
16:31:49 <thetallguy> Two level languages.
16:32:00 <thetallguy> Leave you with two level performance, it seems.
16:33:02 <shapr> It's likely that HAppS has an advantage because one of its goals is to keep all of the state of an application in main memory. Zope and the ZODB does not even approach such a goal. I've often had ZODB database files that were several hundred megs in size.
16:34:05 <shapr> Admittedly, that would fit into memory if you had two GB of ram, but Zope is still uses memory too freely imho.
16:36:50 <shapr> thetallguy: Do you use Python much?
16:44:41 * shapr enjoys error messages from kopete: Very strange! got a DCOPReplyFailed opcode, but we were not waiting for a reply!
16:59:30 <emu> i'm having trouble compiling HaXML
16:59:44 <emu> lisppaste2: url
16:59:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
17:00:34 <lisppaste2> emu pasted "error" at http://paste.lisp.org/display/28168
17:01:18 <shapr> emu: use Cabal: runghc Setup.hs configure && runghc Setup.hs build and then runghc Setup.hs install as root in the same dir.
17:01:56 <emu> that differs from the ./configure thing?
17:02:27 <emu> hmm
17:04:43 <thetallguy> shapr: Don't use python at all
17:05:16 <thetallguy> shapr: was reviewing languages 15 years ago when it came out.  Decided to wait for hasekll
17:05:27 <shapr> hah
17:08:14 <shapr> Python 1.5 was nice. It was easy to learn because it had very few operators and yet it had a bunch of libraries. After Guido added += it all started to go downhill.
17:08:44 <glguy> The fact that this one Guido fellow controls the whole language always kind of bothered me
17:10:12 <shapr> Well, it means that the design of the language is based entirely on what Guido decides. The only reason he included map, reduce, and lambda is because he gave into pressure from some FPers in the early days of Python. He still thinks that was a mistake.
17:10:27 <emu> and that attitude of his is why i disdain python
17:10:45 <emu> also, if I personally can write a better implementation of a more interesting language, I'm not interested
17:11:01 <emu> haskell is nice because I could never have done it myself, so I have something to learn
17:12:20 <shapr> Python built a large and enthusiastic community, so there's something to learn there.
17:12:38 <emu> so did Java
17:12:42 <dibblego> appealing to the masses is easy
17:12:49 <atsampson> shapr: I'm glad it's not just me that feels that way about Python...
17:13:18 <dibblego> but as soon asthey have to learn something, you have a massie hurdle
17:13:44 <dibblego> or worse, unlearn something
17:13:55 <dibblego> nobody likes finding out their God is not real
17:13:57 <shapr> I liked the simplicity of Python 1.5, it was a good way to pry people away from C and Java so they could get stuff done in a reasonable amount of time.
17:14:48 <dibblego> yes, if Haskell could somehow denigrate to that level just to make the learning appear smaller or simpler
17:15:12 <shapr> dibblego: Part of the solution there is to not accept any one thing as the final solution. For example, Haskell is nice, but Epigram has several advantages and disadvantages comparatively.
17:15:31 <lispy> i think a lot of the success of python/ruby comes from how quickly you can pick it up if you already some commonly taught languages...compare that to picking up haskell where you need to learn types, pure techniques and monads before you can read/write code effectively
17:15:43 <emu> there is no "best" in this field
17:15:46 <dibblego> shapr, sure, but once you understand Haskell, the leap of learning/unlearning to Epigram is not as great
17:16:12 <dibblego> I have personally witnessed Java zealots in front of a haskell interpreter
17:16:13 <shapr> Haskell seems to me like a thin layer on top of lambda calculus, so from some viewpoint it is that simple.
17:16:26 <shapr> dibblego: That sounds exciting.
17:16:32 <dibblego> the only hurdle was the amount of unlearning that is required
17:17:15 <shapr> Yeah, I agree. After a week or two of learning Haskell, my girlfriend was horrified when she heard about variables in Python and other imperative languages. She said something like "How can you trust *anything* in a language like that?"
17:17:16 <lispy> ah yeah, unlearning
17:17:38 <shapr> I didn't have a good answer.
17:17:50 <dibblego> shapr, exactly why my 5 year old is given a haskell interpreter on his machine and I make no mention of C :)
17:17:56 <emu> lol
17:18:09 <emu> is haskell her first language?
17:18:15 <shapr> For my gf, yes.
17:18:15 <glguy> My fiancee decided that if Haskell was so wonderful, that she should learn some too. I'm going through SoE with her
17:18:17 <emu> neato
17:18:22 <shapr> glguy: spiffy :-)
17:18:34 <Pseudonym> That's so intimate.
17:18:50 <Pseudonym> Reminds me of the time that my wife got a palm pilot.  We lay in bed beaming things to each other.
17:18:53 <glguy> she programmed in Pascal a little in highschool, but it's been 6 or 7 years
17:19:11 <shapr> Pseudonym: cool :-)
17:19:42 <sjanssen> dibblego: just wait until your kid is thirteen or so, and you find a "C for Dummies" book under the bed.  That rebellion is inevitable ;)
17:20:22 * shapr laughs
17:20:37 <emu> I started using C when I was around 10-11, because I wanted to use "the real thing"
17:20:38 <Pseudonym> Does anyone know how to explain metaphor to a four year old?
17:20:59 <Pseudonym> My daughter was listening to a song on the TV last night, and pointed out "he can't touch the sun!"
17:21:11 <Pseudonym> She's absolutely correct, of course.
17:21:30 <emu> I'm still puzzling how you explain mathmatical ideas to a five year old
17:21:46 <Pseudonym> Depends on the idea.
17:23:15 <emu> fundamentals of arithmetic?
17:23:35 <emu> i don't know about doing an axiomatic approach though =)
17:23:47 <emu> oo happs compiled
17:26:56 <newsham> "a metaphor is like an asimile"
17:27:14 <dibblego> emu, if my son gets x + y wrong, he goes out to the back yard and uses rocks to verify
17:27:42 <dibblego> the point is, make sure you gradually expand spatial ability
17:28:17 <newsham> take a box, mark it "x", take 16 rocks, draw a line, put 8 on one side, 8 on the othe rside.  put the box over 3 rocks
17:28:25 <newsham> and start explaining algebra
17:28:27 <emu> so you are establishing the isomorphism between numbers and quantity of rocks
17:29:43 <dibblego> my 5 year old has just started doing things like a + 3 = 7, what is a? but he struggles in his head
17:29:47 <newsham> same number of rocks on each side of the line
17:29:53 <newsham> take a rock from both side..  still the same number!
17:31:08 <newsham> keep taking away rocks until one side just has the box with rocks in it
17:31:36 <newsham> the other side says how much are i the box
17:36:26 <hyrax42> ?hoogle showIntAtBase
17:36:27 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
17:36:32 <hyrax42> ?docs Numeric
17:36:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
17:37:19 <Pseudonym> I have a suspicion that teaching maths is first about teaching the intuition.
17:37:36 <Pseudonym> Like showing that addition really DOES commute.
17:41:35 <newsham> zero and pred are easy to intuit
17:41:40 <newsham> succ
17:42:16 <dylan> some adults don't get the addition commutes thing.
17:43:17 <dylan> "The digits in the numerical notation for the date add up to 13 — whether you write it in the US or the European form."
17:43:42 <coffeemug> hey guys
17:44:15 <glguy> dylan: there must have been more to it than that
17:44:46 <glguy> dylan: they seemed to think that there were occasions that it was only true of one form
17:45:04 <coffeemug> I'm trying to format UTCTime into a string using formatTime
17:45:10 <newsham> but when does dec 25 == oct 31?
17:45:18 <coffeemug> and running into a slight issue where seconds are displayed as 24.59498
17:45:32 <coffeemug> I can't seem to find a formatting character that outputs seconds without the decimal
17:45:50 <dylan> glguy: then it isn't strictly addition. but they said "add up"..
17:46:27 <dylan> newsham: old joke. ;)
17:46:27 <glguy> dylan: but it's also "numerology" so it's bogus for other reasons
17:46:37 <dylan> glguy: indeedy.
17:46:47 <glguy> ;)
17:47:03 <dylan> I love it when people say things like: "Most people are below average intelligence."
17:47:29 <lispy> dylan: yeah, it really drives their point home :)
17:47:31 <int-e> they could be right, who knows. the average and the median are different things after all.
17:47:33 <glguy> I stick with "I can't believe most people can vote"
17:48:25 <emu> hmm, i can't quite tell, how does happs interact with ghci
17:48:26 <dylan> ah, right. average == norm
17:48:54 <dylan> or, according to wikipedia, the mean.
17:49:14 <int-e> but actually if you take the IQ (whatever that measures) it's defined by fitting a normal distribution so the average and the median are the same again.
17:49:27 <shapr> emu: Haven't tried it, I have F12 bound to compile in emacs and then define: compile-command: "ghc --make wiki.hs -o wiki"
17:49:41 <emu> and then you just re-run it?
17:49:45 <shapr> yup
17:49:47 <emu> k
17:49:54 <newsham> most people know less than the average person about medians and averages
17:50:06 <shapr> There's a way to automate that a bit more, fork and kill, but I haven't gotten around to it yet.
17:50:09 <emu> it behaves oddly in ghci.  guess that's the concurrent library thing
17:50:32 <emu> most people know nothing about statistics.  how do you think lotteries get away with it
17:50:53 <Pseudonym> Most people have more than the average number of fingers.
17:50:55 * dylan knows two people that one lotteries, strangely enough.
17:51:04 <dylan> I'd never play, though.
17:51:06 <emu> two one?
17:51:10 <dylan> *won. :P
17:51:21 <glguy> I don't think that anyone plays the lottery because the expected payout is positive
17:51:24 <Pseudonym> Actually, in some places, lotteries are state-run, and are therefore a kind of voluntary tax.
17:51:33 <emu> yes, a "stupid tax"
17:51:38 <Pseudonym> If you consider it a donation to the local school system...
17:51:43 <Pseudonym> Or whatever.
17:51:48 <Pseudonym> I don't see a moral problem with that.
17:51:57 <newsham> give me $1 and if you're smart i'll give you $10.
17:51:59 <Pseudonym> It's like a raffle for a community group.
17:52:01 <emu> it's a bit disingenous but hey
17:52:26 <Pseudonym> If my local lottery were like that, I'd consider playing for that reason.
17:52:36 <emu> most states run lotteries
17:52:38 <Pseudonym> No way I'd win, but a voluntary donation to a good cause...
17:52:40 <dylan> I don't know anyone that really expects to win the lottery.
17:52:45 <emu> but you gotta wonder about the people runnign them, state or whatever
17:52:53 <Pseudonym> Yeah, well.
17:52:58 <dylan> it's just sort of a thing normal people do, like watch football.
17:53:12 <Pseudonym> That's true.  I'm one of very few people who would actually think this way about lotteries.
17:53:23 <Pseudonym> Most people are suckers.
17:53:42 <emu> well i'm sure you've heard of the arizona initiative to enter all registered voters in a lottery
17:53:53 <Pseudonym> No.
17:54:14 <emu> I suppose it's not a lottery since there is no loss of value to the voter technically
17:54:21 <int-e> uh, just for voting? that's interesting ...
17:54:33 <Pseudonym> No, I guess that's not a lottery.
17:54:33 <dylan> emu: a lottery like in that movie, where everyone over 30 is put to death? ;)
17:54:33 <emu> yes, though it is also apparently in violation of the constitution so eh
17:54:42 <emu> ehe
17:54:50 <int-e> but also a sign of desparation. hmm.
17:54:57 <emu> "anything to increase voter turn out"
17:55:10 <Pseudonym> That's the thing, though.  Most people in the US don't really vote.
17:55:11 <emu> but it's essentially paying people to vote
17:55:16 <int-e> we could take this to #haskell-blah
17:55:20 <Pseudonym> Yes.
17:59:21 <glguy> The problem is that we don't have anyone worth voting for, the biggest difference in the two parties that run our system lies in the number of letters in their names
18:00:37 <cjeris> glguy++ # length "Republican" = length "Democratic"
18:01:01 <Pseudonym> So they're the same up to canonical isomorphism?
18:01:44 * cjeris would like to apply a cannonical isomorphism to some politicians
18:02:36 <glguy> I'm not sure what a canonical isomorphism is...
18:03:16 <glguy> but I'm not compelled to support either
18:03:43 <glguy> I do vote, however, because there are propositions and ammendments to weigh in on
18:05:29 <newsham> > map succ "foobar"
18:05:30 <lambdabot>  "gppcbs"
18:05:59 <cjay> yay, caesar made easy
18:06:24 <glguy> > iterate (map succ) "foobar"
18:06:26 <lambdabot>  ["foobar","gppcbs","hqqdct","irredu","jssfev","kttgfw","luuhgx","mvvihy","nw...
18:06:41 <SamB> > B.fromList "democratic"
18:06:42 <lambdabot>  Not in scope: `B.fromList'
18:06:50 <SamB> aww.
18:06:53 <SamB> @hoogle Bag
18:06:54 <lambdabot> No matches found
18:07:02 <SamB> there is no Data.Bag?
18:07:17 <SamB> @google "Data.Bag" haskell
18:07:19 <lambdabot> http://www.haskell.org/cabal/release/cabal-1.1.3/doc/pkg-spec-html/
18:07:57 <SamB> aww.
18:08:03 <SamB> fictional!
18:08:08 <cjeris> @hoogle (a -> b -> a) -> a -> [b] -> a
18:08:10 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
18:08:10 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
18:08:52 <newsham> > (take 1) . (drop 12) . (iterate (map succ) "foobar")
18:08:53 <lambdabot>    Expecting a function type, but found `[a]'
18:08:54 <lambdabot>    Expected type: a1 -> [a...
18:09:04 <cjeris> @hoogle ((a, b) -> (a, c)) -> a -> [b] -> (a, [c])
18:09:05 <lambdabot> No matches, try a more general search
18:09:11 <cjeris> @pl ((a, b) -> (a, c)) -> a -> [b] -> (a, [c])
18:09:12 <lambdabot> (line 1, column 9):
18:09:12 <lambdabot> unexpected ">"
18:09:12 <lambdabot> expecting variable, "(", operator or ")"
18:09:17 <newsham> > (take 1) . (drop 12) . (iterate (map succ)) "foobar"
18:09:17 <lambdabot>    Expecting a function type, but found `[[b]]'
18:09:18 <lambdabot>    Expected type: a1 -> ...
18:09:35 <glguy> newsham: I think that is pronounced "!! 12" :)
18:09:40 <glguy> err
18:09:42 <glguy> + return ;)
18:09:48 <cjeris> Assignment is a snare and a delusion, and I curse the day I ever let it into one of my ML programs
18:10:08 <newsham> > (!! 12) (iterate (map succ) "fooar")
18:10:09 <lambdabot>  "r{{m~"
18:10:32 <cjeris> @hoogle (Monad m) => ((a, b) -> (a, c)) -> (a, m b) -> (a, m c)
18:10:33 <lambdabot> No matches, try a more general search
18:10:46 <glguy> cjeris: hoogle doesn't do typeclassses
18:10:59 <glguy> at least not the version used in IRC
18:11:03 <cjeris> ah, thanks.
18:11:12 <cjeris> @hoogle ((a, b) -> (a, c)) -> (a, m b) -> (a, m c)
18:11:13 <lambdabot> No matches, try a more general search
18:11:40 <glguy> ?type (second . ) . liftM
18:11:41 <lambdabot> forall (a :: * -> * -> *) b d a1 r. (Arrow a, Monad (a b)) => (a1 -> r) -> a b a1 -> a (d, b) (d, r)
18:11:44 <SamB> this looks nice: http://www.di.uminho.pt/~joostvisser/software/UMinhoHaskellSoftware-1.0/Data.Bag.html
18:11:48 <lambdabot> http://tinyurl.com/yn99ac
18:12:27 <cjeris> glguy: every time I see . used in a chain against a parenthesis my head explodes :D
18:13:00 <glguy> ?pl \x y -> a ( b x y )
18:13:00 <lambdabot> (a .) . b
18:13:06 <glguy> cjeris: that's the only time I use that
18:13:53 <cjeris> i don't suppose there's a corresponding ?pointful?
18:14:20 <newsham> ?type (.) (.) (.)
18:14:21 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:14:44 <newsham> > (.) (.) (.) (+ 1) (*) 4 5
18:14:46 <lambdabot>  21
18:15:18 <glguy> > ((.).(.)) (+1) (*) 4 5
18:15:20 <lambdabot>  21
18:16:29 <newsham> ?type (.) (.) (.) (.)
18:16:30 <lambdabot> forall a a1 b c a2. (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
18:17:33 <newsham> > (.) (.) (.) (.) ((+) . (* 3)) 4 5 (+ 3) 6
18:17:34 <lambdabot>  add an instance declaration for (Num (a -> c))
18:18:03 <newsham> ?type (+) . (* 3)
18:18:05 <lambdabot> forall a. (Num a) => a -> a -> a
18:19:01 <newsham> ?type (+) . (*)
18:19:02 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
18:19:38 <newsham> whats a simple Int -> Int -> Int -> Int?
18:22:57 <glguy> ?type ( (+) .) . (+)
18:22:58 <lambdabot> forall a. (Num a) => a -> a -> a -> a
18:23:10 <sjanssen> > \a b c -> b^2 - 4 * a * (c :: Int)
18:23:12 <lambdabot>  <Int -> Int -> Int -> Int>
18:23:35 <sjanssen> @pl \a b c -> b^2 - 4 * a * c
18:23:35 <lambdabot> flip ((.) . (-) . (^ 2)) . (*) . (4 *)
18:38:11 <dibblego> ?where function
18:38:11 <lambdabot> I know nothing about function.
18:38:17 <dibblego> ?foldoc function
18:38:19 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
18:38:19 <lambdabot> function
18:38:19 <lambdabot>  
18:38:19 <lambdabot>     1. <mathematics> (Or "map", "mapping") If D and C are sets
18:38:19 <lambdabot>     (the domain and codomain) then a function f from D to C,
18:38:21 <lambdabot> [25 @more lines]
18:53:07 <Cale> is a set of pairs (d,c) with d in D and c in C, such that for every d in D, there is exactly one pair (d,c) in f.
19:48:01 <bpc> If I'm defining a function with guard expressions, what's the preferred way to have a final catchall?
19:48:10 <bpc> Should I just use True as the last guard?
19:48:32 <sjanssen> bpc: use "otherwise"
19:48:38 <sjanssen> > otherwise
19:48:39 <lambdabot>  True
19:48:46 <bpc> Ah, thanks.
19:52:00 <chessguy> hmm, does that come from the logic notion that ((p->q) A ~p) -> true?
19:54:04 <sjanssen> chessguy: hmm?
19:54:22 <sjanssen> otherwise is just defined as a constant, like: otherwise = True
19:54:39 <chessguy> oh. sorry, don't mind me. i'm not thinking
19:54:59 <int-e> > let otherwise = False; x | otherwise = 2; x = 4 in x
19:54:59 <lambdabot>    Conflicting definitions for `x'
19:55:00 <lambdabot>   In the binding group for: otherwise,...
19:55:55 <int-e> interesting
19:56:12 <int-e> > let otherwise = False; x | otherwise = 2 | not otherwise = 4 in x
19:56:13 <lambdabot>  4
19:56:22 <Taral> I'm having to write in ocaml :(
19:56:38 <Taral> I want my Haskell. :(
19:56:43 <shapr> What for?
19:56:52 <Taral> http://manju.cs.berkeley.edu/cil/
19:56:53 <lambdabot> Title: CIL Documentation (v. 1.3.5)
19:57:07 <zarvok> come now, writing in languages entirely defined by their only implementation is like an adventure!
19:58:03 <int-e> why can't I have multiple monomorphic bindings with different guards?
19:58:04 <dolio> Something about "not otherwise" amuses me.
19:58:30 <int-e> (for the same name, as just shown: x | guard1 = value1; x | guard2 = value2)
19:58:36 <SamB_XP> dolio: heh
19:58:56 <SamB_XP> int-e: because the guards don't establish type?
19:59:01 <int-e> I guess it's actually a pattern binding, not a function binding, in the context of let.
19:59:26 <SamB_XP> maybe you want a GADT?
19:59:59 <int-e> SamB_XP: no, no. I wanted what I wrote, but I see now why it didn't work.
20:00:51 <int-e> SamB_XP: these weren't toplevel bindings, and in local bindings guards like that make sense actually. but you can combine them into a single binding.
20:01:52 <SamB_XP> int-e: oh? I was assuming these bindings had different types ;-)
20:02:20 <int-e> SamB_XP: no, they didn't :)
20:02:36 <int-e> SamB_XP: but I see where the GADT idea came from, now.
20:02:44 * SamB_XP has to wonder why int-e mentioned monomorphism, then
20:03:06 <int-e> monomorphism = a function without argument.
20:03:34 <int-e> or am I using the term wrong now?
20:03:42 <SamB_XP> aren't all local bindings without types supposed to be monomorphic?
20:03:54 <SamB_XP> monomorphism is the lack of polymorphism
20:04:19 <SamB_XP> that is, there is only one type for it (strictly speaking)
20:04:31 <int-e> sigh. I guess I meant constants then.
20:04:48 <int-e> sorry for the confusion
20:05:02 <SamB_XP> hehe
20:05:13 <SamB_XP> we call those variables, I think ;-)
20:05:13 <int-e> thanks for clearing it up.
20:05:30 <int-e> eh, variables, constants. In Haskell, what's the difference?
20:05:57 <SamB_XP> I asked a math professor what the difference was in general. I think he said "point of view"
20:07:18 <int-e> Haskell coding is easy, you define a bunch of constants and the computer only calculates those it actually needs.
20:07:47 <int-e> (How not to introduce the Haskell language to beginners.)
20:08:22 <SamB_XP> wow, the Melancholy of Haruhi Suzumiya is *really* mixed up...
20:08:48 * SamB_XP starts to get wierd ideas, wondering how many "runs" and "inversions" it has...
20:09:09 <dolio> Beam attack!
20:09:22 <int-e> you could try finding the longest chains and antichains ... or something.
20:10:01 <dolio> You'll be comforted to know that the last episode is actually the last episode.
20:10:05 * araujo jumps and throws shuriken lambdas
20:10:11 <SamB_XP> this is what I get for reading the begininning of Sorting and Searching earlier...
20:10:38 <SamB_XP> dolio: yeah, I've already watched the whole series and I was not willing to think it might not be ;-)
20:10:52 <dolio> :)
20:14:18 * araujo turns into a shinobi monad
20:18:19 <dolio> So, apparently we now have monads as pygmies:
20:18:22 <dolio> http://programming.reddit.com/info/mjcf/comments
20:18:27 <lambdabot> Title: The Monad Laws (reddit.com), http://tinyurl.com/y5lc8h
20:18:58 <hyrax42> is there a standard unix command that will list all lines that do not appear in another file?
20:19:03 <hyrax42> *from one file
20:19:10 <hyrax42> (sorry for this I'm at a complete loss)
20:19:19 <dolio> diff?
20:19:21 <araujo> diff ?
20:19:34 <mlh> comm
20:19:51 <hyrax42> wow
20:19:54 <hyrax42> thanks all
20:19:59 <mlh> sort first though!
20:20:09 <hyrax42> or one other thing... split a file into words
20:20:12 <hyrax42> I want words.lines
20:20:25 <hyrax42> gah this assignment is SO stupid
20:20:33 <hyrax42> who the hell writes a "spell checker" in sh
20:21:03 <mlh> tr ' ^I' '\012' < file-of-lines > file-of-words
20:21:27 <mlh> where ^I is a real tab, not two chars
20:21:49 <mlh> a spell checker can be done in just 1 or two lines in sh
20:22:07 <hyrax42> yeah, but the right two!
20:22:26 <SamB_XP> and you probably have to have one already, too!
20:22:58 <mlh> tr -cs A-Za-z '\012' | tr AZ az | sort -u | comm -23 - /usr/dict/words
20:23:21 <mlh> checks stdin against the standard word list
20:24:01 <SamB_XP> but does it show you close words if it is wrong?
20:24:08 <mlh> quite a famous sequence of commands .. it's originally from some earlyish paper on unix
20:24:33 <mlh> SamB_XP: nope.  nor does it put squiggly red lines under the wrong ones :-)
20:24:40 <SamB_XP> oh come now
20:24:50 <SamB_XP> squiggly red lines are hardly an essential feature
20:24:56 <mlh> to you maybe
20:25:00 <SamB_XP> @spell squigly
20:25:01 <lambdabot> squiggly squiggle smugly snugly squally
20:25:04 <SamB_XP> see?
20:25:09 <SamB_XP> lambdabot doesn't do those either!
20:25:11 * mlh checks to see if he's on haskell-blah
20:25:49 <mlh> btw, cut'n'paste error up there; AZ az should be A-Z A-z
20:27:16 <hyrax42> mlh: tanks very much
20:27:26 <hyrax42> oh there's an overflow channel?
20:27:28 * shapr foozls furiously
20:27:39 <hyrax42> my apologies!
20:27:41 <SamB_XP> #haskell-overflow, yes!
20:27:52 * shapr foozls about the evils of Python!
20:27:58 <SamB_XP> though, that is for HASKELL stuff
20:28:12 <SamB_XP> #haskell-blah is our everything-but channel ;-)
20:28:22 <hyrax42> SamB_XP: okie
20:28:54 <SamB_XP> not that off-topic conversation is exactly taboo here
20:29:24 <SamB_XP> but if you want to talk about how sick your dog is or your troubles with your girlfriend, #haskell-blah is probably where you want to do it...
20:29:32 <SamB_XP> I mean, assuming you have no life...
20:29:55 <SamB_XP> ...and only talk about these things on IRC
20:30:21 <dolio> And specifically want to talk to haskell programmers about them.
20:30:31 <shapr> which does happen sometimes
20:30:32 <SamB_XP> yeah ;-)
20:30:51 <SamB_XP> note that I made up the one about the sick dog...
20:31:27 <dolio> "... which is why Haskell is needed at the moment -- it's the best language that exists right now. Once the Perl 6 compiler is ready, that will no longer be the case ..."
20:31:39 <SamB_XP> who said that?
20:31:45 <SamB_XP> perl6 has really wierd syntax!
20:31:56 <dolio> Random reddit person.
20:33:30 <shapr> Note: alcohol and code do not mix well.
20:33:46 <shapr> Either that or I need more practice.
20:33:48 <dolio> Bah, I've programmed drunk before.
20:33:59 <dolio> Although, it was someone else's homework.
20:34:08 <shapr> I don't drink for the most part. Four times already this year though.
20:34:12 <dolio> So there was no pressure.
20:34:20 <sjanssen> dolio: ha!
20:37:03 <SamB_XP> okay, my episode of that Haruhi show is up... I guess it is time for bed now.
20:40:14 <lennart> never drink and program unless you have a source code control system
20:41:16 <chessguy> and math and alcohol definitely don't mix. don't drink and derive!
20:41:21 <shapr> Not only do I not have a SCCS, I'm also working directly on the production website that has a few hundred users.
20:42:14 <lennart> only fools neglect to use a sccs :)
20:42:31 <shapr> Tell that to my clients...
20:43:22 <lennart> i'd be happy to!
20:43:38 <thetallguy> Put it in th e HWN quotes
20:43:43 <chessguy> is that the same as a CVS?
20:43:46 <TSC> Don't drink and derive, or you'll end up in L'Hopital
20:43:48 <sjanssen> would those clients really notice if an extra little _darcs directory suddenly showed up?
20:43:58 <shapr> I use darcs for most everything else, but my coworkers and clients believe that an SCCS just takes more time and especially money.
20:43:59 <thetallguy> Source Code Control System
20:44:12 <shapr> sjanssen: Yes, my coworkers modify stuff directly on the server.
20:44:17 <shapr> That's how this whole mess got started.
20:44:50 <thetallguy> It's amazing how many people do that
20:45:17 <shapr> Plus it's not just files and data in a directory, it's all inside the Zope Object Database, where nothing is really a file, and no command line tool can reach.
20:45:20 <lennart> it's insane
20:45:29 * shapr agrees
20:45:30 <thetallguy> I hate databases
20:46:37 <int-e> shapr: is there any history, besides database backups that hopefully exist?
20:46:37 <thetallguy> actually, they aren't bad for data
20:47:00 <shapr> int-e: No, only on-tape backups of the Data.fs binary blob that is the ZODB.
20:47:16 <thetallguy> It's just that using them to store stuff that isn't names and addresses and the like always turns out badly for me
20:47:26 <int-e> thetallguy: haha. But Code is Data, as we all know ...
20:47:36 <thetallguy> Sure
20:47:46 <thetallguy> But there's time and money in that equation too.
20:47:48 <thetallguy> ;-)
20:48:05 <shapr> The insanity involved in this particular website should really grace TheDailyWTF, but won't until these guys stop paying me.
20:48:19 <thetallguy> shapr, maybe you can get them to use the wayback machine
20:48:43 <thetallguy> That's our name for an rsync backup scheme
20:48:44 <int-e> shapr: crazy. I hope nobody ever tries to track down the last version of some previously working code that actually did the right thing.
20:48:59 <int-e> shapr: (I know. Programmers are perfect and never break stuff.)
20:49:20 <shapr> Surprisingly, I almost never break this website, even though I have to make untestable changes to production code.
20:49:53 <shapr> Other people break the website, but I don't. Probably because I'm terrified I'll have to do a month long debugging session...
20:50:17 <thetallguy> just don't look down.
20:50:20 <shapr> heh, yes
20:50:40 <shapr> On the one hand, these guys pay pretty well. On the other hand, I wish I weren't working for them, they're capricious to say the least.
20:51:02 <shapr> They tried to train one of their coders to do Zope, and I was all for it, but he gave up in despair.
20:51:36 <shapr> I learned Zope and Plone when I was young(er) and clueless.
21:26:11 <chessguy> @paste
21:26:11 <lambdabot> http://paste.lisp.org/new/haskell
21:26:44 <Cale> what's up?
21:27:09 <lisppaste2> chessguy pasted "@??" at http://paste.lisp.org/display/28174
21:27:23 <chessguy> this code comes from yahc
21:27:44 <Cale> my guess is that you want to know what @ means in the pattern?
21:27:56 <chessguy> what's the @ mean in  g@(Graph v1 e1) src dst .....line 2
21:28:12 <chessguy> yaht, that is
21:28:34 <Cale> var@pat will match against pat, binding any variables in it as usual, and also bind the entire expression matched to var
21:29:01 <TSC> Like "as" in ML?
21:30:11 <chessguy> so it means that it's going to call the whole graph g, and v1 will be called src and e1 will be called dst?
21:30:40 <Cale> yeah
21:31:04 <chessguy> ok. did i miss it, or did yaht not explain that notation elsewhere?
21:32:08 <Cale> maybe it missed it
21:32:38 <chessguy> adobe can't find any relevant instances of @ before that
21:34:05 <chessguy> yaht does seem to be a work in progress. in several places it references section ??
21:34:17 <chessguy> and then of course there's chapter 10, which both does and doesn't exist
21:34:43 <Cale> right
21:34:46 <int-e> sounds like someone ran latex once instead of twice?
21:34:51 <Cale> It's obviously not finished
21:35:03 <Cale> I wish he'd open the source :)
21:35:21 <chessguy> source?
21:35:30 <TSC> Of the document
21:35:39 <Cale> It's written in LaTeX most likely
21:35:43 <chessguy> ah
21:36:08 <chessguy> does the author frequent this channel?
21:36:38 <Cale> I think he's been around in the past...
21:37:23 <chessguy> it's really not a bad read, though it could use some improvements
21:37:46 <Cale> yeah
21:39:20 <chessguy> i'm slowly starting to get the picture of monads
21:39:44 <chessguy> very interesting concept
21:39:50 <Cale> yeah
21:40:14 <chessguy> it seems familiar, but i'm not sure where from
21:41:48 <chessguy> certainly nothing in imperative programming would handle side effects in such an abstract way
21:42:21 <mnvl> is it correct to try and match (x:(y:xs)), meaning a list of at least 2 elements, the first in x, the second in y ??
21:42:55 <subdie> chessguy, what text are you talking about?
21:43:01 <chessguy> yaht
21:43:15 <Cale> mnvl: that's fine
21:43:22 <mnvl> cool thx
21:43:26 <chessguy> @where yaht
21:43:26 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
21:43:32 <Cale> mnvl: you can also leave out the parens
21:43:37 <Cale> (x:y:xs)
21:44:21 <dibblego> what is "cons" short for?
21:44:26 <weitzman> constructor
21:44:31 <weitzman> I believe
21:44:36 <mnvl> ok
21:44:36 <dibblego> list cons?
21:44:54 <weitzman> Those lisp guys were crazy
21:45:03 <mnvl> this channel is practically a #math reunion
21:45:13 <Cale> hehe
21:45:16 <subdie> oh, I have read most of it
21:45:28 <chessguy> haskell is a mathematician's programming language!
21:45:29 <Cale> mnvl: I think that might be my fault :)
21:45:48 <subdie> I read a book, haskell: the craft of functional programming, I found it nice
21:45:49 <Cale> I've been using #math to subtly recruit Haskell programmers :)
21:45:58 <subdie> it gave me a good understanding about the language I think
21:46:00 <int-e> not too subtly
21:46:06 <Cale> hehe
21:46:25 <subdie> yeah, I first read about haskell on #math, although I'm no mathematician
21:46:56 <weitzman> The mathematicians I know who like to compute just use mathematica
21:47:39 <weitzman> Apparently if you use mathematica enough, you can do a lot of things very efficiently using magical cryptic commands and syntax
21:47:41 <Cale> GAP is also nice, if you're into algebra or combinatorics
21:47:42 <subdie> I know a mathematician who really enjoys C
21:47:46 <mnvl> well i can't say i'm not grateful Cale
21:47:51 <Cale> :)
21:47:58 <chessguy> GAP?
21:48:06 <mnvl> the only trouble is when you get up to make a cup of tea
21:48:18 <mnvl> you get stuck trying to think of the recursive way to do it
21:48:26 <chessguy> haha
21:48:28 <subdie> I just I wish I had the time to learn more about haskell. Maybe after I graduate. In most of my classes I end up having to use C or C++, sometimes python.
21:48:54 <Cale> http://www-gap.mcs.st-and.ac.uk/
21:48:58 <glguy_> the time you are in school is the perfect time to leaern new things
21:49:17 <glguy_> additionally you can do your assignments in the normal language and haskell in parallel!
21:49:24 <chessguy> yeah, i'm glad i don't have any real programming projects left. i can just use haskell for my math projects instead
21:49:34 <Cale> GAP is pretty awesome if you want to work out things about particular groups
21:50:00 <chessguy> hmm
21:50:31 <aFlag> glguy, well, sometime I don't have that amount of time
21:51:05 <aFlag> I usually study haskell during the hollidays
21:51:41 <aFlag> I wish I could find a scientific initiation or even a work to program in haskell, but it's hard to find.
21:51:46 <aFlag> s/work/job/
21:54:31 <weitzman> I don't know where I'm going to be working next year, but I think there's a zero percent chance that it will be with a company using Haskell
21:54:43 <weitzman> Doesn't seem like a very popular language
21:55:22 <chessguy> yeah, the rest of the world hasn't caught on yet
21:55:34 <chessguy> they're a little slow
21:55:49 <weitzman> Programming languages have the old chicken-egg problem
21:56:06 <weitzman> The advantages of popular languages tend to lead to them becoming more popular
21:56:44 <kfish> The advantages of awesome languages tend to lead to becoming more awesome
21:56:47 <weitzman> Unless someone drops some kickass Haskell development tools and a tremendous selection of pre-written libraries into the world
21:57:05 <weitzman> Haskell is going to fight an uphill battle
21:57:31 <Cale> well, you should compare the current Hierarchical libraries to those 3 or so years ago
21:58:19 <Cale> Some fairly impressive progress has been made in the practicality department
21:58:27 <Adamant> Haskell is in better shape than a lot of languages
21:58:37 <Adamant> that are similarly awesome.
21:59:07 <Adamant> Lisp and Scheme development is a clusterf*ck from the standpoint of the traditional developer
21:59:09 <aFlag> I think people don't see the positive effects of haskell. It must first convince people it's a good idea. And people's mind are hard to change. I've seen lots of people saying that functional languages are just weird languages that have no use. Well, maybe outside brazil it's different...
21:59:19 <weitzman> People who go into the field of programming language research must be very patient folks
21:59:29 <Canar> Adamant: name some similarly awesome languages please. :)
21:59:34 <Adamant> aFlag, it's the same in the U.S., except in high quality colleges
21:59:41 <Adamant> Common Lisp and Scheme
22:00:15 <ThreeQ> I'd say smalltalk is pretty awesome
22:00:26 <Adamant> yeah, that too. it has the same problems.
22:01:01 <Pegazus> what sequence is for?
22:01:22 <Adamant> I'd say the ML's as well, but Haskell out-ML's the MLs
22:01:27 <hyrax42> aFlag: that attitued is here as well
22:01:39 <hyrax42> you get roll-eyes when you mention your "weird" language
22:01:45 <hyrax42> that mostly people haven't heard of
22:01:46 <Cale> Pegazus: sequence takes a list of computations, and chains them together into a computation of lists
22:02:04 <hyrax42> * of a list
22:02:06 <Cale> (which runs each in turn and collects the results)
22:02:11 <Adamant> Sequence is a monad?
22:02:23 <weitzman> sequence is a function on monads
22:02:24 <Pegazus> yeah, i've read the definition. but i still don't get it...
22:02:26 <hyrax42> hmmm
22:02:27 <Cale> sequence is a function which acts on lists of monadic computations
22:02:31 <Adamant> ah.
22:02:36 <hyrax42> actually that points something out
22:02:43 <hyrax42> which bit exactly is the monad
22:02:47 <hyrax42> is it the type constructor
22:02:52 <hyrax42> or the applied type constructor
22:02:54 <aFlag> yeah, so far I was able to convice 2 people that haskell is cool
22:02:55 <Pegazus> can you give me an example showing how usefull is sequence?
22:02:56 <ThreeQ> Pegazus: sequence [op1, op2, ..., opn] = do { a1 <- op1; a2 <- op2; ...; an <- opn; return [a1...an] }
22:03:02 <Cale> > sequence [[1,2,3], [4,5]]
22:03:03 <lambdabot>  [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
22:03:36 <Cale> I often use it as a sort of "Cartesian product" like that
22:03:43 <Pegazus> ThreeQ: nice explanation...
22:04:01 <Pegazus> mmm and what does monads has to do with Cartesian Product?
22:04:08 <Cale> It's useful for building up fancy control structures
22:04:17 <Pegazus> for example?
22:04:22 <Cale> mapM f = sequence . map f
22:04:43 <Cale> that's essentially "foreach"
22:05:49 <Pegazus> why do you need monads to do a for each?
22:05:58 <Cale> well, a monadic foreach :)
22:06:03 <Pegazus> isn't map f a for each?
22:06:05 <Cale> for example
22:06:27 <Cale> mapM print [1..10]
22:06:39 <Cale> will print the numbers 1 through 10
22:06:43 <Pegazus> what's usefull from monads apart from IO? and side effects?
22:06:59 <glguy_> Monads are types of computation, [] as a Monad is nondeterministic computation (returns all possible paths)
22:07:02 <Cale> The ability to selectively control the side-effects available in various parts of the program
22:07:12 <Pegazus> for example?
22:07:14 <glguy_> all possibly paths though a list of values is a cartesian product
22:07:21 <chessguy> everything is a monad :)
22:07:28 <Pegazus> everything is a function
22:07:31 <Pegazus> everything is an object
22:07:43 <Pegazus> and everything at the very least, is a sequence of zeros and ones...
22:07:59 <Cale> A really nice example is given by the STM monad for transactions in the software transactional memory system for concurrency.
22:08:19 <Pegazus> an easy one? (i'm just starting with monads)
22:08:28 <Cale> Well, let me explain
22:08:38 <Cale> STM is a system for thread communication
22:08:52 <Cale> You basically have these variables shared by threads
22:09:10 <Pegazus> in haskell?
22:09:17 <Cale> in Haskell and other languages
22:09:28 <Cale> In the system, you're allowed to construct actions which run as-if-atomically
22:09:45 <Cale> (that is, they might not *actually* run atomically, but the system must ensure that they appear to do so
22:09:47 <Cale> )
22:09:52 <Pegazus> how do you create vars in haskell? with a Monad IHaveVars?
22:10:00 <Cale> sure :)
22:10:18 <Cale> in fact, the monad I'm talking about has its own special kind of variable called the TVar
22:10:35 <Pegazus> k
22:10:36 <chessguy> oh! i know where monads gives me a sense of de ja vu from.....SICP's environment model
22:10:43 <Cale> Transactions can create TVars, write to them, read from them, etc.
22:11:35 <Cale> But the way that the system is implemented, transactions are allowed to "retry", which means that they are rolled back, and wait for one of the variables which they read to change before running again
22:12:05 <Pegazus> why would they roll back?
22:12:20 <Cale> because, for instance, a shared resource is in use by another thread
22:12:55 <Pegazus> yeap
22:13:23 <Cale> so if a transaction was to do something like write to the screen, it would be disastrous, because that's not possible to roll back
22:13:49 <glguy_> and therefore it is not allowed to :)
22:14:07 <Pegazus> and what if a transaction ask for user input?
22:14:08 <Pegazus> :)
22:14:15 <Cale> right, that's also bad :)
22:14:30 <glguy_> you'd have to use an "unsafe" function to force that
22:14:39 <Cale> so the STM monad basically restricts the side effects available to reading and writing TVars and things made of TVars, and of course, pure computations are okay
22:15:04 <Pegazus> so you tell the monad are you want to do. and then you tell it. ok, do it!
22:15:13 <glguy_> stm is just a type of computation that carries with it information about tvars
22:15:54 <Pegazus> any other nice use of monads?
22:16:01 <hyrax42> parsec!!
22:16:21 <Cale> parsec is an excellent example
22:16:39 <hyrax42> I just used it last night to do the parsing of network messages for my AI project
22:16:45 <mnvl> i'm trying to write a function which takes a n-digit binary number with t 1's, and returns the next smallest such number
22:16:56 <Cale> Basically, it's a monad where the computations are parsers
22:17:26 <Cale> and you build larger parsers from them using the same do-notation as everywhere :)
22:17:41 <Cale> (as well as things like <|> which constructs the OR of two parsers
22:17:42 <Cale> )
22:17:50 <hyrax42> mnvl: shift teh least significant 1 down a place
22:17:52 <Pegazus> the or?
22:17:53 <hyrax42> ?
22:17:56 <Pegazus> what?
22:18:36 <hyrax42> ?paste
22:18:36 <lambdabot> http://paste.lisp.org/new/haskell
22:18:58 <Cale> Well, the parser which tries the first parser, and if it succeeds, then returns its result, or if it fails, tries the second
22:19:37 <chessguy> anybody familiar with the environment model described by SICP (at least in the video series, i don't know about the book)?
22:19:45 <lisppaste2> hyrax42 pasted "Parsec example" at http://paste.lisp.org/display/28177
22:20:23 <hyrax42> Pegazus: so in there I use <|> a few times
22:20:31 <hyrax42> basically I'm saying
22:21:10 <hyrax42> that a message is either a Play message or a Move message or a Start message or a...
22:21:32 <mnvl> the least significant 1 that has a 0 to its right, correct?
22:21:34 <chessguy> > 7 `shiftR` 1
22:21:35 <lambdabot>  Add a type signature
22:21:44 <chessguy> > 7 `shiftR` 1 :: Int
22:21:46 <lambdabot>  3
22:21:53 <Cale> chessguy: I just watched those lectures
22:22:13 <hyrax42> mnvl: yeah
22:22:16 <hyrax42> I think that should do it
22:22:18 <mnvl> not quite chessguy
22:22:37 <Pegazus> any good book, webpage, tutorial, anything you can advise me to learn monads?
22:22:38 <aFlag> parsec is very nice. I pratically simple copied the grammar I wished to implement and the grammar tree was ready :)
22:22:48 <mnvl> i agree .. so far hyrax42
22:22:53 <hyrax42> (if anyone cares to comment on my parser, I'm all ears)
22:23:01 <glguy_> ?google haskell monad
22:23:03 <lambdabot> http://www.nomaware.com/monads/
22:23:03 <lambdabot> Title: Nomaware | Monads
22:23:05 <glguy_> this one is good
22:23:09 <Pegazus> aFlag: LR(1) grammars are easy to parse...
22:23:15 <chessguy> mnvl, sorry, that wasn't really an answer to your question. but it does show that you can shift the least significant 1 to the right, no matter where it is, to get the right answer
22:23:44 <Pegazus> i am reading that one, and it's all ok until Summary... There chaos begins!
22:23:47 <chessguy> Cale, when they talk about the environment model, as opposed to the substitution model, isn't that like monads?
22:24:12 <mnvl> yeah, the 1 are values present in a sorted list .. so the mechanics are a bit different
22:24:19 <mnvl> but i think the idea is right
22:24:26 <hyrax42> mnvl: least significant first, right?
22:24:46 <mnvl> unfortunately not hyrax42
22:24:52 <hyrax42> ick
22:24:54 <hyrax42> you have no control?
22:24:58 <aFlag> hyrax42, are you sure you need all those tries?
22:25:09 <hyrax42> aFlag: it's not left-factored
22:25:11 <hyrax42> and I wasn't in the mood
22:25:25 <hyrax42> although I think that all begin with different letters
22:25:29 <hyrax42> so probably not
22:25:34 <hyrax42> they'll fail without consuming input
22:25:45 <aFlag> yeah, that was what I was thinking.
22:26:07 <Cale> chessguy: The reader monad in particular is perfect for that
22:26:10 <hyrax42> anyway, roughly 0.1% of tiem is spent in parsing
22:26:17 <hyrax42> so I don't care very much
22:26:26 <hyrax42> or was it 0.1% alloc and 0.0% time
22:26:28 <hyrax42> one or the other
22:26:38 <chessguy> hmm. i was thinking of the state monad in particular
22:26:57 <hyrax42> but I will try dropping the trys
22:27:21 <hyrax42> haha
22:27:23 <hyrax42> "where gah"
22:27:27 <hyrax42> that was 4.30am
22:30:24 <tessier_> Anyone considered writing some sort of SE Linux policy analysis tool in Haskell? Seems like it might be a good langage for that.
22:30:44 <chessguy> good idea. when can you start?
22:31:50 <tessier_> Tonight.
22:31:57 <tessier_> A better question is "When can I finish?"
22:32:01 <chessguy> :)
22:32:09 <hyrax42> SE?
22:32:39 <tessier_> Let's see...Haskell: The Craft of Function Programming. Page 1.
22:32:47 <aFlag> security-enhanced
22:32:49 <tessier_> hyrax42: Security Enhanced
22:32:54 <hyrax42> ah
22:32:58 <tessier_> hyrax42: Fedora and CentOS and RHEL etc. all come with it standard now.
22:33:00 <hyrax42> I thought securitn something
22:33:02 <tessier_> A huge security boost for Linux.
22:33:09 <weitzman> chessguy: Looking at the text online, the environment and substitution models just look like different but equivalent (at least in the absence of side effects) ways to evaluate expressions
22:33:09 <hyrax42> but my acronym expander is borked
22:33:11 <shapr> hyrax42: Security Enhanced
22:33:23 * shapr is slow
22:33:28 * tessier_ is an acronym machine
22:33:32 <tessier_> TIAAM
22:33:32 <aFlag> hehe everyone seemed to know it except hyrax :P
22:33:33 <glguy_> security through obscurity to a certain extent :)
22:33:47 <chessguy> weitzman, right. but their point is that side effects are inevitable, so the environment model is necessary
22:33:47 <hyrax42> aFlag: :/
22:33:47 <tessier_> SE Linux is definitely not security through obscurity
22:33:57 <glguy_> administration gets so complex
22:34:05 <tessier_> Not really.
22:34:08 <glguy_> that you just have to hope that htings are overed
22:34:22 <mnvl> how do you find the first element of a list which meets a condition?
22:34:26 <aFlag> hehe SE linux seems like a nice idea to me
22:34:31 <glguy_> mnvl: find
22:34:36 <aFlag> I'm not sure it's quite there yet though
22:34:43 <tessier_> It's all about least priviledge. You give it least priv and that has to be good enough. Otherwise your app won't work and you may as well secure the box by turning it off.
22:34:51 <tessier_> Short of designing our apps to require fewer privs that's the best we can do.
22:36:03 <weitzman> chessguy: You could use call-by-value and the substitution model if you just make sure you evaluate parameters before expanding function calls
22:36:10 <chessguy> first :: (a->bool) -> [a] -> Maybe a     first f [] = Nothing   first f (x:xs) | f x = x   | otherwise first f xs
22:36:25 <chessguy> something like that
22:36:27 <glguy_> ?type find
22:36:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
22:36:35 <chessguy> haha
22:37:00 <chessguy> find (>3) [1,2,3,4]
22:37:04 <chessguy> > find (>3) [1,2,3,4]
22:37:05 <glguy_> first is in control.arrow
22:37:06 <lambdabot>  Just 4
22:37:22 <chessguy> oh, i need f x = Just x, don't i?
22:37:59 <glguy_> find and filter need to be merged into a function with :: (MonadPlus m) => (a -> Bool) -> [a] -> m a
22:38:01 <dolio> Wouldn't that be like the converse of security through obscurity?
22:38:11 <chessguy> my first time writing a function with Maybe :)
22:38:18 <dolio> The obscurity is usually presented to the hacker, not the administrator. :)
22:38:34 <aFlag> hehe
22:38:35 <hyrax42> hooray for Maybe
22:38:53 <aFlag> dolio, but if it's obscure to everyone, then it's really secure!
22:38:54 * shapr isn't sure...
22:38:54 <aFlag> :P
22:38:54 <chessguy> what's MonadPlus?
22:39:07 <shapr> It's like "SuperSize My Monad Sir!"
22:39:09 <glguy_> things that implement mplus and mzero
22:39:31 <weitzman> @instances-importing MonadPlus
22:39:32 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:39:49 <glguy_> > mzero `mplus` return 4 `mplus` return 5 :: Maybe Int
22:39:50 <lambdabot>  Just 4
22:40:04 <glguy_> > mzero `mplus` return 4 `mplus` return 5 :: [Int]
22:40:06 <hyrax42> would you call a lambada a "literal syntax for functions"?
22:40:06 <lambdabot>  [4,5]
22:40:19 <chessguy> ok, this is gonna kill me
22:40:46 <hyrax42> chessguy: don't worry!
22:40:57 <chessguy> let first f [] = Nothing; first f (x:xs) | f x = Just x | otherwise first f xs in find (>3) [1,2,3,4]
22:41:00 <hyrax42> ?wiki NotJustMaybe
22:41:00 <lambdabot> http://www.haskell.org/haskellwiki/NotJustMaybe
22:41:01 <chessguy> > let first f [] = Nothing; first f (x:xs) | f x = Just x | otherwise first f xs in find (>3) [1,2,3,4]
22:41:01 <lambdabot>  Parse error
22:41:11 <hyrax42> gah
22:41:12 <glguy_> > mzero `mplus` return 4 `mplus` return 5 :: Either String Int
22:41:14 <lambdabot>  Right 4
22:41:35 <hyrax42> > let first f [] = Nothing; first f (x:xs) | f x = Just x | otherwise first f xs in first (>3) [1,2,3,4]
22:41:35 <lambdabot>  Parse error
22:41:43 <weitzman> > mzero `mplus` fail "Bam" `mplus` return 4 `mplus` return 5 :: Either String Int
22:41:44 <glguy_> add an =
22:41:44 <lambdabot>  Right 4
22:41:58 <chessguy> > let first f [] = Nothing; first f (x:xs) | f x = Just x | otherwise = first f xs in find (>3) [1,2,3,4]
22:42:00 <lambdabot>  Just 4
22:42:02 <glguy_> otherwise *=* first
22:42:09 <glguy_> :)
22:42:13 <chessguy> nice
22:42:22 <hyrax42> oh right
22:43:06 <glguy_> > msum [4,5,6] :: Maybe Int
22:43:07 <lambdabot>  add an instance declaration for (Num (Maybe Int))
22:43:08 <lambdabot>   In the list element: 6
22:43:20 <glguy_> > msum [Just 4, Just 5]
22:43:22 <lambdabot>  Just 4
22:43:29 <chessguy> hyrax42, don't take it for granted that my code won't have a stupid bug in it :)
22:43:35 <weitzman> > msum [mzero, Just 3, Just 4]
22:43:36 <glguy_> > msum [[4,5],[6]]
22:43:36 <lambdabot>  Just 3
22:43:37 <lambdabot>  [4,5,6]
22:43:41 <hyrax42> I was gonna go and put semicolons
22:43:47 <hyrax42> I'm not ver good at not usign layout
22:44:00 <hyrax42> ?type map
22:44:01 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:45:00 <glguy_> > sequence [Just 1, Just 3]
22:45:01 <lambdabot>  Just [1,3]
22:45:05 <glguy_> > sequence [Just 1, Just 3, Nothing]
22:45:06 <lambdabot>  Nothing
22:45:12 <RyanT5000> why does this result in a stack overflow?
22:45:12 <RyanT5000> head $ filter (>1000000000) [0..]
22:45:25 <RyanT5000> shouldn't that be unified?
22:45:45 <chessguy> is there a difference between "forall b a. (a -> b) -> [a] -> [b]" and "(a -> b) -> [a] -> [b]"
22:45:49 <sjanssen> RyanT5000: does it overflow when compiled with -O ?
22:45:56 <glguy_> chessguy: no
22:46:04 <glguy_> err
22:46:07 <glguy_> chessguy: yeah :)
22:46:17 <RyanT5000> sjanssen: i'm not sure; i only tried it in ghci
22:46:18 <glguy_> noep
22:46:19 <sjanssen> chessguy: maybe, depends on the contexxt
22:46:35 <chessguy> ok, i've got votes for no, yeah, and maybe :)
22:46:36 <glguy_> chessguy: It got line wrapped weird when I looked
22:46:41 <RyanT5000> can ghci do -O?
22:46:47 <RyanT5000> i told it to (:set -O)
22:46:48 <sjanssen> RyanT5000: ghci tends to suck with things like that
22:47:01 <sjanssen> I'm not sure whether that works, I kinda doubt it
22:47:04 <glguy_> chessguy: at the toplevel they are the same
22:47:44 <Pseudonym> Basically, the former is the generalised version of the latter.
22:47:46 <chessguy> so in what case would they be different?
22:47:58 <weitzman> > head $ filter (>1000000000) [0..]
22:47:58 <Pseudonym> chessguy: Scoped type variables might make them different.
22:48:02 <lambdabot> Terminated
22:48:07 <Pseudonym> That's a GHC extension.
22:48:46 <chessguy> hmm
22:48:53 <RyanT5000> well, there's no stack overflow when compiled with -O2, but it still uses a crapton of ram
22:48:54 <glguy_> "forall a. a" is different than "a" inside a -> b and (forall a. a) -> b
22:49:36 <sjanssen> RyanT5000: that code, exactly as typed?
22:49:50 * glguy_ &
22:49:52 <RyanT5000> ah wait nvm, let me double-check something
22:50:17 * shapr &
22:50:19 <sjanssen> if you replaced [0..] with some top level CAF, you're going to have a problem
22:50:30 <RyanT5000> yeah, well i had that problem earlier
22:50:38 <chessguy> CAF?
22:50:43 <Pseudonym> % fg `cat /var/run/shapr.pid`
22:50:55 <Pseudonym> hang on, that doesn't work.
22:51:07 <Pseudonym> % kill -INT `cat /var/run/shapr.pid`
22:51:42 * tmoertel hopes the pidfile isn't stale
22:51:46 <sjanssen> chessguy: constant applicative form
22:52:02 <shapr> gwahr!
22:52:22 * shapr throws a whole bag of stale pids at Pseudonym 
22:52:42 <Pseudonym> shapr: I think your job control semantics aren't SUS.
22:53:05 <shapr> Are you calling me a sussy?
22:53:15 <Pseudonym> No, I'm calling you barely POSIX.
22:53:17 * lispy thinks that a bag of stale pids smells about as good as a pile of cores
22:53:20 * shapr grins
22:54:13 <RyanT5000> alright, so now back to my *real* code
22:54:23 <RyanT5000> i what i'm *really* trying to do is a filterM
22:54:34 <lispy> ?type filterM
22:54:35 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
22:55:06 <RyanT5000> is it unreasonable to expect head $ filterM ... to work properly?
22:55:10 <chessguy> ok, time for sleep. i have to be up in 3 hours...yuck
22:55:20 <lispy> RyanT5000: yes
22:55:29 <lispy> RyanT5000: unless you're using the list monad
22:55:47 <lispy> RyanT5000: but maybe you meant liftM head . filterM ?
22:55:47 <RyanT5000> ah, ok, well that would explain it
22:55:54 <RyanT5000> oh well
22:55:57 <RyanT5000> yeah that's what  i meant
22:56:05 <RyanT5000> what i meant by "work" is unify head and filterM
22:56:29 <lispy> ?type liftM head . filterM
22:56:30 <lambdabot> forall a. (a -> [Bool]) -> [a] -> [a]
22:56:52 <RyanT5000> right, but i need it to be *efficient*
22:57:01 <lispy> that type doesn't lok right
22:57:01 <RyanT5000> (i'm in IO, btw)
22:57:21 <lispy> > liftM head . filterM $ (const True) [1..10]
22:57:22 <lambdabot>  Couldn't match `a -> [Bool]' against `Bool'
22:57:33 <lispy> > liftM head . filterM $ (const [True]) [1..10]
22:57:34 <lambdabot>  Couldn't match `a -> [Bool]' against `[Bool]'
22:57:46 <RyanT5000> ?type liftM head $ filterM (return . const True) [1..10]
22:57:48 <lambdabot> forall a (m :: * -> *). (Monad m, Num a, Enum a) => m a
22:57:57 <RyanT5000> ?type liftM head . filterM (return . const True)
22:57:58 <lispy> yeah, that's a bit better
22:57:58 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m a
22:58:09 <RyanT5000> my predicate is IO Bool
22:58:19 <weitzman> > liftM head . (filterM (const [True])) [1..10]
22:58:20 <lambdabot>    Expecting a function type, but found `[[a]]'
22:58:20 <lambdabot>    Expected type: a1 -> ...
22:59:14 <sjanssen> RyanT5000: filterM must try every element of the list before returning anything
22:59:23 <RyanT5000> sjanssen: oh
22:59:41 <weitzman> sjanssen: No
22:59:45 <weitzman> > evalState (filterM (\x -> modify not >> get) [1..]) True
22:59:46 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
22:59:48 <shapr> LtU isn't as good anymore :-(
22:59:53 <sjanssen> for many Monads, like IO and ST
23:00:00 <lispy> if you only want a region it's better to use a takeWhile/dropWhile combo
23:00:02 <RyanT5000> yeah, that makes sense
23:00:20 <sjanssen> weitzman: right, right -- most pure monads can return things immediately
23:00:21 <RyanT5000> well i'm in IO and i'm operating on an infinitely long list
23:00:25 <RyanT5000> so that would be my problem
23:00:32 <sjanssen> so it would seem ;)
23:00:38 <weitzman> Oh right
23:01:22 * shapr takes a few elements from an infinitely lost list, and it's still just as long!
23:01:48 <RyanT5000> well, the only reason i'm using IO is so i can output progress updates, lol
23:02:05 <shapr> Actually, couldn't you handle infinite lists with mdo?
23:02:19 <lispy> shapr: well, that would continue to be true as as long as you took a countable subset
23:02:40 <tmoertel> shapr: would you like to supplement your LtU not-as-goodness with a horribly not-particularly-entertaining article I'm writing on doing away with XSS and SQL-injection problems by adding Ruby-like string-interpolation templates to Haskell?  (I'm looking for feedback.)
23:02:49 <shapr> tmoertel: sure
23:03:15 <shapr> There's a TMR issue in the making, want to submit it there too?
23:04:30 <lispy> RyanT5000: fwiw, you could do progress updates with CPS and then you could "write" the updatse with the writer monad...so in essence, you could if you wanted work quite around being in IO
23:04:51 <lispy> RyanT5000: i would recommend using CPS for the progress updates and IO to immediately output them
23:05:08 <RyanT5000> well, i'll look into that at some point
23:05:25 <RyanT5000> but right now i'm just going to hack around using filter
23:05:40 <tmoertel> shapr: I was just going to post it to my blog, but if you think it would make for good TMR material, feel free to use it.  Here's a linksy to the draft in progress: http://community.moertel.com/~thor/blog/post-safe-strings.xhtml
23:05:42 <RyanT5000> (using CPS, and just terminating when i hit the first result, which is all i care about anyway)
23:05:44 <lambdabot> http://tinyurl.com/y9qzse
23:07:21 <shapr> tmoertel: thanks
23:07:32 <tmoertel> shapr: thank *you*
23:10:18 <shapr> I like the point about unit tests not helping with knowledge deficits.
23:12:31 <lispy> shapr: i dunno...
23:13:09 <shapr> ?
23:13:21 <lispy> that was a bad joke, but more seriously, that's one reason why i like quickcheck...units tests won't even help you that much if you can't think of bad way to use your units
23:13:21 * lokadin hugs shapr and lispy
23:13:29 <lokadin> I missed you soo much !!! :D
23:13:33 <lispy> hehe
23:13:35 <shapr> :-)
23:13:41 <shapr> lispy: Ah, I got it.
23:13:43 <lispy> yay, it's the #haskell family!
23:13:53 <lokadin> .ui(happiness)
23:14:15 <lokadin> yep, i haven't been here in a while
23:14:49 <lokadin> gonna start working on my Lojban parser again pretty soon. Am gonna make it into a programming language.
23:14:54 * lispy passes out lambdas in the traditional #haskell celebration style
23:15:03 <lispy> lokadin: heh, neat
23:15:12 <lispy> lokadin: talk about literate programming!
23:15:16 * shapr tokes on a lambda
23:15:44 <lokadin> .u'i(amusement)
23:15:45 <RyanT5000> huh... i think i just wrote a program that is *at least* O(2^(2^n))
23:15:47 <shapr> lokadin: spiffy, lojbo programming
23:15:48 <RyanT5000> n is 8
23:15:54 <RyanT5000> oh wait, my bad
23:16:01 <RyanT5000> n^(2^n)
23:16:04 <lispy> > 2^(2^8)
23:16:05 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639936
23:16:13 <lispy> > 8^(2^8)
23:16:14 <lambdabot>  1552518092300708935148979488462502555256886017116696611139052038026050952686...
23:16:17 <RyanT5000> lol
23:16:19 <RyanT5000> ...
23:16:23 <lispy> looks like the second case is worse
23:16:26 <RyanT5000> yeah, it is
23:16:28 <RyanT5000> it's 3 lines long
23:16:41 <lispy> i bet the first digit is a 1
23:16:48 <RyanT5000> yep
23:16:52 <RyanT5000> 155 is right
23:17:04 <shapr> tmoertel: I like it. I'm too sleepy to do a thorough job of it, I'll check it out again tomorrow. Also, there's a witty conclusion missing ;-)
23:17:37 <lispy> ?users
23:17:39 <RyanT5000> although somehow i managed to run it for 6
23:17:53 <RyanT5000> so it's clearly got a very large divisor
23:17:53 <lambdabot> seen module failed: IRCRaised thread killed
23:17:58 <lispy> hmm...
23:18:00 <TSC> Well, O() is only an upper bound... (:
23:18:03 <lispy> ?uptime
23:18:04 <lambdabot> uptime: 5d 8h 24m 34s, longest uptime: 6d 15h 1m 36s
23:18:04 <tmoertel> shapr: thanks!  It's ~ 4,500 words, so feel free take your time.
23:18:24 <shapr> hm, didn't seem that long...
23:18:26 <RyanT5000> > 6^(2^6)
23:18:28 <lambdabot>  63340286662973277706162286946811886609896461828096
23:18:55 <lispy> > (6 ^ (2 ^ 6)) / (8 ^ ( 2 ^ 8 ))
23:18:57 <lambdabot>  4.0798420950514004e-182
23:19:00 <lispy> oh look
23:19:04 <RyanT5000> lol
23:19:04 <lispy> it's zero!
23:19:25 <lispy> (not exactly, but as far as i'm concerned that's a float rep. of zero)
23:19:26 <RyanT5000> yeah, so i guess unless i'm wrong about the order of this thing it's not going to finish
23:19:48 <RyanT5000> what i'm doing is programming via brute force
23:19:58 <Pseudonym> Is it scary when your homebrew square root function is more accurate than your FPU?
23:20:03 <RyanT5000> i made a list of all possible lambda calculus functions
23:20:14 <lispy> Pseudonym: depends on who you are :)
23:20:18 <RyanT5000> and i'm searching it for ones that add church numerals
23:20:26 <Pseudonym> I'm nobody, numerically analytically speaking.
23:20:35 <RyanT5000> (using only 4 test cases: 0+0, 0+1, 1+0, and 1+1)
23:20:49 <lispy> Pseudonym: maybe it's really slow or only works on a susbset?
23:21:18 <RyanT5000> my (very slow and crappy) program seems to be trying about 50k lambda functions per second
23:22:20 <Pseudonym> Well obviously mine is slower than the FPU.
23:23:06 <Pseudonym> And there's only one or two numbers for which it's more accurate.
23:23:15 <Pseudonym> I guess AMD's job is safe.
23:23:20 <lispy> heh
23:23:32 <lispy> also, the FPU has pretty rigid requirements on how it computes
23:23:40 <lispy> IEEE is pretty specific
23:23:45 <lispy> er IEEE754
23:24:01 <Pseudonym> Mine is O(1), like the FPU's.
23:24:12 <lispy> when you restrict to the same values?
23:24:14 <Pseudonym> So in principle it's no slower. :-)
23:24:21 <lispy> heh, just bigger constant...
23:24:36 <Pseudonym> Well, the same values in this case is the range of normalised IEEE 754 doubles.
23:24:49 <Pseudonym> I haven't tried denormalised.
23:29:16 <RyanT5000> there are a *lot* of lambda functions with AST depth 7
23:29:30 <RyanT5000> there are only like 10k with AST depth 6
23:29:37 <RyanT5000> only like 750 with 5 or lower
23:29:55 <Pseudonym> And how many of them terminate?
23:30:11 <RyanT5000> lol how should i know?
23:30:16 <lispy> RyanT5000: wouldn't it be more efficient to generate them based on observed behavior instead of ast?
23:30:30 <RyanT5000> efficient, perhaps
23:30:47 <RyanT5000> but efficiency is irrelevant (in fact, contradictory) to the point i'm trying to make
23:31:26 <RyanT5000> which has to do with giving a million monkeys a million lambda calculus interpreters
23:32:14 <RyanT5000> (although the whole brute-force-search thing is just for fun)
23:32:42 <RyanT5000> although within the first few thousand there's an alternate to the SUCC given on the wikipedia page
23:33:50 <lispy> heh, nice
23:34:07 <RyanT5000> (obviously my numbering system is only one of many reasonable ones, and i could probably tweak it to get a quicker result on PLUS)
23:37:35 <RyanT5000> well, i'm off for the night
23:42:41 <musasabi> morning
23:43:11 <musasabi> emu: the problem is that in ghci :r does not kill any old background threads or close file handles.
23:45:35 <JohnMeacham> who is in charge of the haskell.org mailing lists?
23:58:41 <emu> musasabi: yea figured
