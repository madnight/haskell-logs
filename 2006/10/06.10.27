00:00:10 <roconnor> but these last points I'm less sure of.
00:00:57 * Bobstopper nods
00:02:35 <Bourbaki> moin
00:02:40 <Bourbaki> dons are you awake?
00:03:02 <int-e> @localtime dons
00:03:04 <lambdabot> Local time for dons is Fri Oct 27 17:02:40 2006
00:07:15 <araujo> helly
00:07:19 <araujo> argh
00:07:22 <araujo> hello
00:12:47 <lispy> someone put up a snipet of haskell explaining all the details between newtype and data with just there declarations and something like 6 functions
00:12:53 <lispy> i wish i still the the URL it was handy
00:13:06 <lispy> although, ... i pretty much never need to know the difference :)
00:14:56 <araujo> Well, main difference being 'newtype' makes isomorphic types.
00:15:46 <lispy> same structure new name?
00:17:31 <araujo> lispy, yes
00:17:47 <dolio> There's a slight difference between data Foo a = Foo !a and newtype Foo a = Foo a, as well, even though they should both be isomorphic.
00:18:57 <dolio> You can pattern match against bottom on one, but not the other.
00:21:30 <dolio> _|_ behaves like Foo _|_ for pattern matches on newtype, but like _|_ data with one strict field.
00:22:49 <araujo> newtype will make strict constructor.
00:23:23 <araujo> That's why (Foo _|_) == _|_
00:23:39 <dolio> Right, but if you have: testFoo (Foo _) = True
00:23:46 <araujo> And it is isomorphic with the respective type
00:23:57 <dolio> testFoo undefined == testFoo (Foo undefined) = True for newtype.
00:24:16 <dolio> testFoo undefined == testFoo (Foo undefined) == undefined for data.
00:25:09 <lispy> why is that?  i mean, what is it about the definiton of newtype vs daat that forces that to be the case?
00:25:14 <araujo> Oh,i think it got to do with the way newtype are evaluated
00:28:46 <lispy> grr...why is citeseer down?
00:29:31 <Syzygy-> Is there some way of building an enum datatype on [1..n] for some specific n?
00:30:09 <araujo> As far as i know, 'data' values need to be wrapped/unwrapped everytime you need to use them.
00:30:32 <araujo> Where 'newtype' values can be replaced by the values of the type.
00:30:50 <lispy> araujo: ah
00:31:07 <araujo> So , (Foo _|_) as an argument of newtype it is like:
00:31:25 <araujo> > let f a = True in f undefined -- (Foo undefined)
00:31:26 <lambdabot>  True
00:33:39 <araujo> This ispossible because of the isomorphism of the type
00:33:51 <lispy> JohnMeacham: do you use a graph reduction algorithm (something like ghc's g-machine) for jhc?
00:34:24 <lispy> araujo: okay, thanks, i think i get it now
00:37:58 <araujo> welcome
00:44:19 <Botty> > not True
00:44:20 <lambdabot>  False
00:54:41 <dolio> > 2 / 2
00:54:43 <lambdabot>  1.0
00:56:59 <Botty> gotta do these sanity checks, just to be sure :)
01:01:33 <dolio> > head . drop 1000 . ap (zipWith $ flip (/)) tail . fix $ (1:) . scanl (+) 1
01:01:35 <lambdabot>  1.618033988749895
01:01:45 <dolio> > (1 + sqrt 5)/2
01:01:47 <lambdabot>  1.618033988749895
01:04:03 <lispy> sexy
01:04:14 <dolio> Thanks.
01:04:32 <dolio> More dollars than I like, but what can you do?
01:04:33 <lispy> that's one for HWN
01:06:13 <roconnor> @hoogle WriterT
01:06:14 <lambdabot> Control.Monad.Writer.WriterT :: m (a, w) -> WriterT w m a
01:06:15 <lambdabot> Control.Monad.Writer.WriterT :: newtype WriterT w m a
01:06:15 <lambdabot> Control.Monad.Writer.execWriterT :: Monad m => WriterT w m a -> m w
01:06:58 <roconnor> @hoogle state
01:06:58 <lambdabot> Control.Monad.State :: module
01:06:59 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
01:06:59 <lambdabot> Control.Monad.State.State :: newtype State s a
01:07:15 <roconnor> @hoogle StateMonad
01:07:16 <lambdabot> No matches found
01:07:21 <roconnor> @hoogle MonadState
01:07:22 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
01:15:36 <Syzygy-> Whoa. This Gtk2Hs + Glade - Gnome-apps-in-Haskell thingie reminds me a lot of my child years with Visual Basic....
01:15:44 <Syzygy-> Only .. y'know .. a decent language below it all.
01:15:56 <roconnor> @docs Control.Monad
01:15:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
01:17:25 <roconnor> @docs Control.Monad.Writer
01:17:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
01:25:31 <Botty> ?type fromIntegral
01:25:33 <lambdabot> forall b a. (Num b, Integral a) => a -> b
01:25:44 <roconnor> Any easy way to print an integer in hex using exactly 5 digits?
01:26:24 <Botty> ?hoogle a -> b
01:26:25 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:26:26 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
01:26:26 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
01:26:49 <Botty> ?hoogle (Num a, Num b) a -> b
01:26:50 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
01:26:50 <lambdabot>  
01:27:00 <Botty> ?hoogle (Num a, Num b) => a -> b
01:27:03 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
01:27:03 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
01:27:03 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
01:27:07 <dolio> ?pl m >>= return . f
01:27:08 <lambdabot> f `fmap` m
01:28:17 <roconnor> @hoogle String -> ShowS
01:28:18 <lambdabot> Prelude.showString :: String -> ShowS
01:28:45 <Botty> ?hoogle CDouble -> Double
01:28:46 <lambdabot> No matches, try a more general search
01:28:48 <roconnor> @hoogle [ShowS] -> ShowS
01:28:49 <lambdabot> No matches, try a more general search
01:53:50 <roconnor> @hoogle writeFile
01:53:51 <lambdabot> Prelude.writeFile :: FilePath -> String -> IO ()
01:53:51 <lambdabot> System.Win32.File.c_WriteFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
01:53:51 <lambdabot> System.Win32.File.win32_WriteFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
01:56:41 <roconnor> @docs Control.Exception
01:56:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
02:02:34 <roconnor> @hoogle unless
02:02:34 <lambdabot> Monad.unless :: Monad a => Bool -> a () -> a ()
02:02:35 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
02:02:35 <lambdabot> System.Win32.Types.failUnlessSuccess :: String -> IO ErrCode -> IO ()
02:03:32 <roconnor> @hoogle getArgs
02:03:33 <lambdabot> System.getArgs :: IO [String]
02:03:52 <roconnor> what about System.Environment.getArgs?
02:06:16 <dcoutts> Syzygy-, heh, cool. :-)
02:07:25 <dcoutts> Bobstopper, ping
02:09:32 <Bobstopper> Hi dcoutts. I think I'm good now. I've used containerGetChildren and widgetGetName to write a function which takes a path of widget names and uses it to search and find the widget I want. Probably better than having what I was looking for anyway.
02:10:20 <dcoutts> Bobstopper, for getting a widget by name using glade is usually enough
02:10:46 <dcoutts> though if you have to get the name later then yeah, I guess you need to search through containers etc
02:11:26 <Bobstopper> Yeah, but I'm trying to adhere to some sort of MVC design and for that, I don't want my controller riddled with implementation details about how the view works. I hope this MVC stuff pays off :P
02:12:03 <Bobstopper> There's not really any way to create new instances of GObjects without falling back to C code, is there?
02:12:25 <x3m> GHCi runtime linker: fatal error: I found a duplicate definition for symbol _GHCziWord_fromEnum1_closure whilst processing object file C:/Program Files/ghc/ghc-6.4.2/HSbase1.o"
02:12:30 <Bobstopper> or more accurately, new instances of GObjects which will actually work as expected
02:15:58 <orzo> hey
02:17:32 <Cale> hi
02:17:47 <orzo> i was trying to envision a good language for video game programming
02:17:55 <orzo> here is a sample: http://rafb.net/paste/results/8i2jxv91.html
02:18:29 <velco> English ? ;)
02:19:24 <orzo> meaning it looks like english?
02:19:36 <velco> "where initially: "
02:20:32 <orzo> is that bad?
02:22:45 <roconnor> anyone know TH?
02:23:36 <roconnor> @where TH
02:23:36 <lambdabot> I know nothing about th.
02:23:45 <roconnor> @where TemplateHaskell
02:23:45 <lambdabot> I know nothing about templatehaskell.
02:23:50 <roconnor> @where Template
02:23:51 <lambdabot> I know nothing about template.
02:23:54 <roconnor> :(
02:24:03 <roconnor> @google Template Haskell
02:24:06 <lambdabot> http://www.haskell.org/th/
02:24:06 <lambdabot> Title: Template Haskell
02:24:52 <araujo> morning!
02:26:38 <x3m> "add "Typeable.h" to includes in plugins.cabal" how do i do that?
02:28:22 <therp> roconnor: what's with template haskell?
02:29:12 <roconnor> therp: I've never used it.  I'm wondering if it could be useful for my problem.
02:30:02 <therp> roconnor: I think I have not written a single common lisp code piece without using metaprogramming, so I guess the answer is yes :)
02:30:37 <therp> I'm not that familiar with TH though. I just feel asleep with the TH paper on my chest yesterday (but not because of the paper :))
02:36:08 <dolio> You should put it under your pillow. Better for osmosis.
02:37:46 <swiert> roconnor: you know Coq don't you?
02:39:51 <Cale> roconnor: what is the problem you speak of?
02:40:35 <lisppaste2> roconnor pasted "untemplated haskell" at http://paste.lisp.org/display/28786
02:41:04 <roconnor> I have a feeling that I can use template haskell to make that a little more modular
02:41:06 <Cale> aha, yes, it could
02:42:14 <roconnor> I suppose I should somehow be able to write a list of instruction, assocaited with the number of registers, and immediate values, and opcodes they have
02:42:21 <roconnor> and then derive these functions.
02:42:46 <araujo> What is the best way to represent a binary tree?
02:42:49 <Cale> Yeah, you could actually have it build that code. I'm not sure if I could be bothered to do it myself.
02:43:18 <roconnor> Cale: well ... this is the second instruction set that I've written for this code.
02:43:24 <Cale> data Tree a = Nil | Branch a (Tree a) (Tree a)
02:43:24 <swiert> if it's a fixed instruction set, it might not be worth the effort.
02:43:32 <araujo> I mean, i am asking if there exist some pre-defined libs, or tools that make it more efficient than a more conventional data definition
02:43:42 <araujo> Cale, ^^
02:44:04 <Cale> araujo: there's Data.Tree, but that isn't just binary trees
02:44:12 <roconnor> And it also may be a good excuse to learn TH.
02:44:34 <Cale> If you're using the binary trees for something like implementing a set, there's Data.Set
02:44:39 <Cale> also Data.Map
02:44:50 <araujo> Cale, i also was thinking about the FGL lib, but probably that's too much bloated for a simple binary tree?
02:45:15 <Cale> yeah, especially when the language has tree-like datatypes as a primitive :)
02:45:25 <araujo> hah ok
02:46:12 * roconnor likes how in haskell a full binary tree of constant data takes O(log n) space due to the shared subexpressions.
03:08:22 <JohnMeacham> lispy: well, graph reduction is more of a metaphor than an actual evaluation strategy, but yeah. it ends up being something similar to that.
03:08:39 <JohnMeacham> lispy: but I am not sure how a lazy language can be otherwise (while being efficient)
03:10:01 * ibid regards graph reduction as the _specification_ of what lazy evaluation (*not* nonstrict evaluation) is
03:24:02 <dcoutts> Bobstopper, sorry dissapeared for a while. So you wanted to make new GTypes that derive from GObject ? We can't do that. But I don't actually think there's much need to.
03:24:48 <dcoutts> Bobstopper, for MVC, how about using a Haskell record of functions/actions as the interface ?
03:25:51 <dcoutts> and the code that sets up the connection between M, V & C is the only one that knows the mess implementation details of how to build them and get at the interfaces they provide.
03:46:18 <mcnster> (i'm going to ask here because as everyone knows #haskell has the densest concentration of geniuses on the planet...)
03:46:58 <mcnster> if i say "mov (0xfee00000), %ebx" under .code64 (x86_64) does this get sign-extended to 0xfffffffffee00000?
03:47:23 <SamB> no
03:47:32 <SamB> because ebx is a 32-bit register
03:47:39 <wilx> Compile it and do objdump on it...
03:47:50 <SamB> (at least, afaik it doesn't do anything to the top half!)
03:47:50 <mcnster> i didn't think so, yet i'm getting a page fault there
03:47:54 <wilx> I think that the () significate dereference...
03:48:10 <SamB> well, you need to clear the top half of the register probably...
03:48:34 <SamB> maybe if you do mov 0xfee00000, %rbx
03:48:36 <mcnster> no, i don't mean sign-extended by the assembler.  i mean sign-extended within the core when it is made into canonical form
03:48:56 <SamB> as I said... %ebx is 32-bit
03:49:04 <SamB> %rbx is the 64-bit name
03:49:14 <SamB> probably you need to clear the top half
03:49:28 <SamB> what does gdb show when your program crashes?
03:49:49 <SamB> when you do "info registers"
03:50:02 <mcnster> no gdb.  kernel hacking with just a notice of a page fault
03:50:07 <SamB> oh.
03:50:13 <SamB> it doesn't say what address?
03:50:30 <mcnster> sure it does.  0xfffffffffee00000
03:50:43 <SamB> actually...
03:50:49 <mcnster> i'm either too tired, or there's too many f's there
03:50:52 <mcnster> ;-)
03:50:52 <SamB> hmm.
03:51:19 <SamB> I think I heard something about kernel addresses being "negative" 32-bit addresses?
03:52:09 <mcnster> hmm
03:52:24 <SamB> maybe in GCC's info file?
03:52:38 <mcnster> when i say kernel, i mean it runs on the metal, not the linux kernel btw
03:52:43 <SamB> oh.
03:53:14 <SamB> in that case I'm just going to suggest you try "%rbx" instead of "%ebx"
03:53:23 <mcnster> i did.  same issue
03:53:28 <SamB> oh.
03:53:44 <SamB> where is this address being used?
03:54:08 <mcnster> i'm trying to load a value from the default location of an apic register
03:54:35 <SamB> I meant
03:54:41 <SamB> what instruction is crapping out?
03:54:41 <frevidar> is there a way to include video in a haskell program?
03:54:51 <frevidar> does wxhaskell support it?
03:54:55 <SamB> oh
03:55:04 <mcnster> ... which rdmsr (0x1b) indicates is 0xfee00000.  so i wonder if that gets sign-extended to mean ...
03:55:05 <SamB> I thought you meant in the *source* ;-)
03:55:15 <SamB> frevidar: huh, doubt it.
03:55:35 <SamB> try gtk2hs, it seems a lot more likely to have what you would need
03:55:56 <SamB> also, if it doesn't, you could probably wrap what you need easily enough...
03:56:58 <mcnster> ok SamB, thanks for the ideas.... i'm going to try mapping in the page and see what happens...
04:08:03 <dcoutts> frevidar, I'd try gstreamer and gtk2hs, but I don't know what the state of the gstreamer bindings is.
04:10:49 <lightstep> how can i write networkCoded::Int->[Word8]?
04:11:40 <dcoutts> lightstep, using functions from Data.Bits
04:11:55 <dcoutts> ie biwise shift & and/or
04:12:16 <lightstep> is it in some standard library?
04:12:27 <lightstep> (network foding, not .&.
04:12:28 <lightstep> )
04:12:54 <lightstep> it was probabl written many times already
04:13:10 <dcoutts> probably, but it's not in the standard lib as far as I know
04:13:23 <dcoutts> I'd go steal someone else's code
04:13:26 <lightstep> ok, thanks
04:22:04 <SamB> @tell mcnster that 32-bit effective addresses are sign extended to 64-bit
04:22:04 <lambdabot> Consider it noted.
04:27:18 <SamB> what a lousy excuse:
04:27:26 <SamB> eval_apply.hs:92:5:
04:27:26 <SamB>     Can't make a derived instance of `Eq Obj' (`Obj' has no data constructors)
04:27:26 <SamB>     When deriving instances for type `Obj'
04:30:29 <audreyt> but how can two undefined things be the same?
04:30:37 <audreyt> or not the same?
04:30:42 <audreyt> or do you want (==) = undefined? :)
04:33:49 <SamB> why not?
04:34:10 <SamB> you have a point though...
04:34:53 <SamB> @doc Text.PrettyPrint.HughesPJ
04:34:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
04:42:29 <Cale> heh, you could have it be constantly True
04:44:22 <lightstep> i'd make it constantly False
04:44:57 <lightstep> since the usual Eq instances are {(==) A A = True; (==) (B x) (B y) = x==y; (==) _ _ = False}
04:47:16 <aleator> Any simple tool for generating barcharts from haskell?
04:59:44 <lightstep> i think there's a gnuplot binding in some math library
05:16:04 <ulfdoz_> moin *rylps&schwank*
05:18:05 <cjay> :P
05:20:48 <lightstep> how can i make System.Plugins.Utils visible? many existing programs depend on this.
05:24:28 <lightstep> nm, i'll just copy&paste some code
09:13:46 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
09:13:46 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
09:13:46 --- names: list (clog_ dolio jmmv SyntaxNinja beelsebob chessguy l_a_m protracted lray80de3 _matthew_ binary42 kisu pyronicide LordBrain ndm edwardk der_eq dvekravy cwenner glguy cjeris hyraxfourtwo CrewdenX CosmicRay ProfTeggy Captain_Fourier workbean kpreid bdbit sad0ur russo_ genneth converter Mibori Prip mkhl iblechbot Sweetshark ventonegro Patterner arjanb chris2 Cale slipstream BCoppens orzo jak_ noclouds tessier_ velco roconnor ramkrsna therp Averell)
09:13:46 --- names: list (_velco eno-away svens khaladan gour Jaak thetallguy cmeme jcreigh ihope__ falconair mathewm arjanoosting dgoldsmith neurogeek sigfpe__ matthew-_ Igloo Daveman svref meddle Trixsey vincenz shapr uip Zr40 araujo satan gaal profmakx Xgc woggle camster Twigathy benben xinming_ resiak psi mathrick exnor dblog Plareplane noradio_ Nioate toyz ValarQ JKnecht nothingmuch flux__ x3m thou tessier cods wagle astrolabe lovecoder nnunley lisppaste2 mr_ank)
09:13:46 --- names: list (mGem szabi_ Lunar^ qz Baughn earthy ThreeQ hyrax42 Bobstopper Tigge cpatrick _frederik_ freshhawk sigfpe_ mornfall sylvan dcoutts Pupeno TwigEther tmoertel cyb dottedmag Syzygy- DRMacIver dcoutts_ Lor giksos kosmikus greenrd lOkadin scw lambdabot GeoBesh irgs orbitz ohub noj void moconnor nick8325 explicitjelly Narcisse osfameron gdsx lucca zamez Pete_I qwr fnordus atsampson pandres xerox arguile_ edwinb johs mattam wilx dylan scsibug shrimpx)
09:13:46 --- names: list (xeXergy kaol Khisanth dany2k unclear mlh emu pejo rycee mux SimonRC kalven psnl ChilliX dons carp shawn rafl ozone arcatan thebug bdash bran_ aleator magagr musasabi jmob Lemmih lispy ski wolverian audreyt Akheron norpan lennart Spark gds vegai JohnMeacham ulfdoz_ epitron kpk Codex_ SamB_XP Eidolos Botje saccade clog ibid integral sieni df_ SamB Wallbraker jgrimes pingu newsham boliver_ drbean jdev ksandstr liyang moonlite kzm Maddas cjay)
09:13:46 --- names: list (petekaz dwm kolmodin)
09:13:58 <Syzygy-> If you impose upon it to assume that x is always an n:th power, I'd convert it to Float, take it to the power of 1/n, and then take the closest integer to that.
09:14:10 <Botje> that's what i was trying to do
09:14:10 <Syzygy-> That way, it'll have weird behaviour on illegal input, but do what you want on legal input.
09:14:17 <Syzygy-> Show me your code.
09:14:22 <Botje> n = floor $ (fromInteger cats) ** (1 / (fromInteger k))
09:14:42 <Botje> cats = x^k :: Int
09:15:00 <Botje> that tells me k is not an Integer
09:15:12 <Syzygy-> There is a difference between Integer and Int.
09:15:17 <Botje> I know
09:15:24 <Botje> but how should I solve it then?
09:15:40 <Botje> cats ** (1/k) won't work either, because ** wants Floating a
09:16:25 <Syzygy-> > let cats = 2^8; k=8; n = floor $ (fromInteger cats) ** (1/(fromInteger k)) in n
09:16:27 <lambdabot>  2
09:16:42 <astrolabe> use fromIntegral?
09:16:48 <Botje> uhm.
09:16:50 <Botje> doh.
09:16:58 <Syzygy-> Botje: As I said. Int and Integer are different.
09:17:08 <Syzygy-> If you force cats to be Int, and then use fromInteger, you'll get problems.
09:17:24 <Botje> yeah ..
09:18:19 <astrolabe> maybe define   round x = floor (x+0.5)
09:18:49 <Syzygy-> That's a good idea to handle possible borderline cases, when machine precision starts adding artefacts.
09:39:49 <astrolabe> Is there any work on code complexity for functional programming languages?
09:42:15 <monochrom> what is code complexity?  like Kolmogorov complexity?  no, there isn't.
09:43:30 <astrolabe> There are measures like cyclotomic complexity, which apparently measures the number of paths through the code for imperitive code, but I don't know if it generalises.
09:44:25 <cjeris> @google ghc in head explosions per hour
09:44:28 <lambdabot> http://wage.wisc.edu/uploads/Articles/trubek-louise_working.pdf
09:44:45 <cjeris> guess that doesn't work as a unit of code complexity...
09:44:53 <astrolabe> heh
09:46:01 <roconnor> Igloo: I think your solitare code has too many variables. :P
09:46:28 <roconnor> use join more often
09:46:46 <monochrom> cyclotomic complexity applies to functional programs too.  count recursions as loops.
09:47:52 <Igloo> roconnor: Thank you for your comments  :-Ã¾
09:49:05 <shapr> astrolabe: "Are our really smaller than theirs?"
09:49:06 <ndm> astrolabe: yes, there has been, and i remember seeing it - TFP 2005 has something in their
09:49:21 <ndm> astrolabe: i think from someone at Kent
09:49:30 * roconnor these comments brought to you by the pointless design improvment association.
09:49:33 <araujo> hi hi!
09:49:34 <astrolabe> TFP?
09:49:34 <shapr> astrolabe: http://www.dcs.gla.ac.uk/fp/workshops/fpw96/Booth.pdf
09:49:38 * araujo back from univ.
09:49:38 <lambdabot> http://tinyurl.com/ylnjwx
09:49:46 <ndm> @google TFP 2005 trends in functional programming
09:49:50 <lambdabot> http://www.cs.ru.nl/~marko/tfp05/
09:50:10 <astrolabe> Thankyou, interesting.
09:51:06 <ndm> astrolabe: i can't remmeber what it was called though
09:51:09 <shapr> astrolabe: And I'd like to know about anything else you find :-)
09:52:00 <ndm> astrolabe: http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/09num.pdf
09:52:04 <lambdabot> http://tinyurl.com/y4sd2g
09:52:10 <ndm> and shapr i guess, since thats the answer to the question
09:53:12 <astrolabe> oooh
09:53:17 <dcnstrct> is haskell a reasonable choice for a language to use instead of shell for unix scripting ?   Or does haskell suck at making system calls and dealing with operating system level stuff ?
09:53:55 <Botje> whee
09:54:01 <Botje> I made hugs segfault
09:54:14 <ndm> dcnstrct: suck is a bit too harsh, but there may be easier things to do shell scripting with
09:54:16 <astrolabe> yay!  ghc next
09:54:17 <Botje> creating lists of 960k elements sans laziness isn't a good idea, apparently
09:54:21 <ndm> Botje: overflow the stack?
09:54:24 <shapr> dcnstrct: http://www.cse.unsw.edu.au/~dons/h4sh.html
09:54:26 <lambdabot> Title: h4sh
09:54:28 <Botje> probably
09:54:31 <Botje> let's try ghc
09:54:40 <ndm> Botje: hugs or WinHugs?
09:54:50 <Botje> what's the difference between hugs and ghci, anyway?
09:54:52 <Botje> normal hugs
09:55:09 <ndm> Botje: WinHugs would have caught that, issue a warning and not died
09:55:26 <dcnstrct> cool thnx guys
09:56:56 <astrolabe> ndm: I was a little disappointed in how much of my code's execution I could understand using hat-observe
09:57:11 <ndm> astrolabe: not much?
09:57:25 <astrolabe> no, not really.
09:57:28 <ndm> astrolabe: usually hat-trail is used more to diagnose things, i think
09:57:37 <ndm> and hat-<opposite to trail>
09:57:37 <shapr> gregb: Hiya! Have you been on #haskell before?
09:57:43 <astrolabe> I'm rewritting some functions into smaller chunks
09:57:53 <gregb> shapr: oh, off and on.
09:58:00 <gregb> mostly off though.
09:58:17 <astrolabe> but there seems to be a limit to how much you can sensibly break functions up.
09:58:22 <shapr> gregb: Nice to meet you in realtime.
09:58:33 <gregb> shapr: same
09:59:11 <gregb> shapr: although I think we're in pretty different time zones
09:59:33 <gregb> shapr: so that might explain why we haven't crossed paths before.
09:59:36 <ndm> astrolabe: would a better gui for hat-observe help?
10:00:07 <gregb> Anyone know of a good "RankN types for dummies" tutorial?
10:00:15 <shapr> gregb: Nowadays I'm in the central timezone.
10:00:23 <gregb> Or why is this illegal...
10:00:27 <monochrom> I don't understand code execution.  But my computer does.  I focus on things my computer can't do.
10:00:29 <astrolabe> The limit is caused by needing stuff in scope, so with split-up functions, a proportionately high amount of space is taken up passing arguments around, and re-defining variables (repeating code)
10:00:31 <gregb> foo :: Integer -> (forall a. Show a => a)
10:00:31 <gregb> foo 2 = ["foo"]
10:00:31 <gregb> foo x = x
10:01:07 <gregb> ...while this works...
10:01:08 <gregb> bar :: Integer -> (forall a. Show a => a->b) -> b
10:01:09 <gregb> bar 2 k = k ["foo"]
10:01:09 <gregb> bar x k = k x
10:01:56 <gregb> shapr: Ah, pacific here.
10:02:16 <astrolabe> ndm: I haven't understood all of hat-observe, but I find myself wanting to grab a single use of a function, and look inside it to see the values of local variables.  I think hat-trace might be more what I'm after.
10:02:45 <ndm> astrolabe: the idea is you use hat-observe to find a particular use, then hat-trace hops onto that particular use - the integration is key really
10:02:53 <ndm> astrolabe: so thats where i hope the GUI will win well
10:03:13 <astrolabe> That would be brilliant
10:03:22 <Botje> yay
10:03:25 <Botje> acm107 solved!
10:04:08 <_velco> what is acm107 ?
10:04:36 <astrolabe> ndm: How much work do you think it will be getting hat-trace onto windows?
10:05:16 <emu> lol spam subject: "deth algebra"
10:05:18 <ndm> astrolabe: no idea, its something i never looked at in much depth - give me a second and i'll find my brief note
10:06:19 <ndm> astrolabe: oh, it appears i missed hat-trail without making any note - so probably didn't even try
10:06:37 <ndm> astrolabe: i'll add that to my todo list, to see if it works (it might work by default even, i never tried)
10:06:41 <astrolabe> trail/trace?
10:08:07 <ndm> yes, i didn't do either trail or trace, missing it
10:08:49 <astrolabe> Either or both would be very nice to have.
10:09:03 <ndm> hmm, must have done it alphabetically and given up before reaching the end...
10:09:14 <astrolabe> heh
10:09:50 <astrolabe> Ah, I was getting muddled, it is trail that I'm most interested in I think.
10:10:02 <ndm> i intend to go back over the hat tools at some point, and make them a bit happier on windows
10:10:13 <ndm> part of the big reorganisation that I am trying to get malcolm to do
10:10:28 <astrolabe> It looks as though trail has different panes, which might give problems I guess.
10:10:39 <ndm> yes, thats likely to go badly wrong on windows
10:10:44 <ndm> well hat-gui will solve all of these issues
10:11:03 <bdbit> the let..in paragraph in the haskell.org-tutorial is remarkably short
10:11:18 <bdbit> can someone explain me in detail what is the difference between let..in and where?
10:11:19 <astrolabe> Did you see my mail on the hat list about why my code wasn't compiling?
10:11:23 <ndm> bdbit: you can learn haskell without learning let
10:11:33 <ndm> astrolabe: yes, the import and reexport stuff i think
10:12:06 <bdbit> ndm: glguy used "let .. in" in an expression he gave me... and because copy&paste is, in my opinion at least, a big part of programming, I should be able to read >~50% of all code
10:12:51 <astrolabe> ndm: right.  It doesn't give me much confidence about the condition of hat.
10:13:20 <bdbit> hm let me try... "let y = 1 in y + 1" returns 2
10:13:25 <ndm> astrolabe: yes, hat is a wonderful theory with a crap implementation
10:13:31 <bdbit> whereas the y is only bound for the block "y + 1" ?
10:13:37 <astrolabe> bdbit: I believe they actually are different, but I think of let x = y in z and z where x = y as synonyms.
10:13:48 <ndm> bdbit: let y = 1 in x    is x, replacing y by 1
10:14:06 <bdbit> ndm: what is the difference to where?
10:14:14 <bdbit> astrolabe: that's what I was thinking.
10:14:20 <ndm> bdbit: where is a statement, let is an expression
10:14:35 <bdbit> aah it's getting clearer, can you get more precise?
10:14:53 <astrolabe> ndm: yes, I want to know this too!
10:15:20 <astrolabe> what is the difference between a statement and an expression in haskell?
10:15:36 <ndm> expression can be placed anywhere
10:15:38 * astrolabe consults the report
10:15:48 <ndm> statement can only be placed at the bottom of things, i.e. "out of line"
10:16:00 <ndm> so f (x where x = 12) is not allowed
10:16:02 <bdbit> it doesn't feel to good if the "big boys" play with such quaint and bizarre constructs that the fellow rookie doesn't comprehend
10:16:08 <ndm> but f (let x = 12 in x) is
10:16:10 <bdbit> s/to\s/too
10:16:34 <bdbit> ndm: I think you just cleared things up.
10:16:37 <ndm> bdbit: i got taught haskell without knowing about do, let, case or quite a few other things - its a perfectly fine way to start
10:16:55 <bdbit> ndm: well, I tend to have the feeling that "something is missing"
10:17:02 <astrolabe> ndm thanks.
10:17:23 <bdbit> and indeed, as long as I am not able to understand snippets thrown at me when I ask "what's a good way to do <X>" then for me, this is a sign of technical inadequacy
10:17:27 <Syzygy-> > let f x = 2+x in f (let x = 12 in x)
10:17:29 <lambdabot>  14
10:17:38 <Syzygy-> Neat.
10:17:43 <bdbit> Syzygy-: that's what I wanted to try, too
10:18:25 <bdbit> I have the weird feeling that my commas are utterly misplaced
10:18:48 <astrolabe> > let f x = 2+x in f (x where x = 12)
10:18:49 <lambdabot>  Parse error
10:18:58 <astrolabe> cooo
10:19:11 <bdbit> > f x = 2 + x where x = 12
10:19:11 <lambdabot>  Parse error
10:19:15 <bdbit> duh.
10:19:19 <monochrom> "let" and "where" are hard to distinguish.
10:19:21 <astrolabe> bdbit: the compiler will grumble if your commas are wrong.
10:19:28 <bdbit> astrolabe: heh.
10:20:01 <ventonegro> > let f x = x + y where y = 12 in f 3
10:20:03 <lambdabot>  15
10:20:21 <bdbit> this boggles my mind.
10:20:28 <monochrom> perhaps it's also hard to distinguish "expression" and "declaration"
10:20:48 <bdbit> monochrom: do you want to give further clarification a try?
10:21:02 <monochrom> No. It should be self-evident.
10:21:07 <bdbit> apparently I've still not understood where "where" and "let" are used best
10:21:46 <bdbit> f x = x * 2 + c where c = 2
10:21:51 <bdbit> > f x = x * 2 + c where c = 2
10:21:51 <lambdabot>  Parse error
10:21:51 <ventonegro> bdbit, let is a expression, it should have a value
10:21:58 <bdbit> > let f x = x * 2 + c where c = 2
10:21:58 <lambdabot>  Parse error
10:22:01 <bdbit> darn it
10:22:04 <ventonegro> in a where clause you declare things
10:22:48 <bdbit> ventonegro: oh, so this is the reason lambdabot doesn't output anything when the "let" is missing?
10:23:02 <bdbit> because without let it's a statement instead of an expr?
10:23:18 <ventonegro> well, you can have expressions without let
10:23:20 <ventonegro> > "alex"
10:23:21 <lambdabot>  "alex"
10:23:37 <roconnor> lambdabot doesn't accept statements, and hence you cannot use where.
10:23:40 <ventonegro> lambdabot only accepts expressions
10:23:48 <bdbit> ok, thanks
10:24:03 <bdbit> I'm still wondering about where
10:24:18 <astrolabe> exp -> let decls in exp
10:24:24 <gour> bdbit: write those epxressions on the paper using layout - it will make more sense
10:24:41 <bdbit> gour: I can even write them in ghci :>
10:24:48 <bdbit> gour: I'm a try'er kind of guy...
10:25:03 <gour> bdbit: even better ;)
10:25:07 <ventonegro> f x = x * 2 + c where c = 2
10:25:14 <ventonegro> here you are declaring a function
10:25:19 <bdbit> yeah
10:25:20 <ventonegro> this has no value
10:25:26 <bdbit> so I can't use let?
10:25:36 <ventonegro> > let f x = x * 2 + c where c = 2 in f 10
10:25:36 <roconnor> I believe ghci also requires expressions as the prompt.
10:25:37 <lambdabot>  22
10:25:42 <bdbit> roconnor: yes.
10:25:42 <ventonegro> see?
10:25:54 <bdbit> yes, I understood that prt
10:26:07 <ventonegro> now i gave a something to your function, so it can compute a value
10:26:17 <bdbit> but now I'm hanging in the air a little bit, because I thought "let" is just optional
10:26:20 <roconnor> ventonegro: omg, you can use statements is let expressions!
10:26:36 <bdbit> roconnor: stop joking at my expense X_x
10:26:54 <roconnor> I'm serious, I didn't know you could do that
10:26:59 <bdbit> oh.
10:27:03 <roconnor> that's awsome
10:27:09 <ventonegro> :-)
10:27:13 <roconnor> ... it must be incredibly bad style ...
10:28:04 <bdbit> > let fac n = [ product [1..n] | n <- [1..] ]!!n in fac 10
10:28:05 <lambdabot>  39916800
10:28:24 <bdbit> will fac be available afterwards, as if it were had I declared it without let?
10:28:27 <Syzygy-> bdbit: let is not really optional. It ends up seeming optional in source files because these have an implicit or explicit where somewhere at the beginning. (my understanding right now)
10:28:45 <ventonegro> bdbit, nope
10:28:52 <ventonegro> let creates a scope
10:28:56 <bdbit> Syzygy-: I was recognizing that implicitly by the "use" of lambdabot :D
10:29:05 <Syzygy-> bdbit: :)
10:29:24 <bdbit> ventonegro: that's the discrimination I needed.
10:29:55 <bdbit> learning such stuff is a great tad more efficient when you have kind people like yourselves that answer not-so-bright-seeming questions ;)
10:30:02 <ventonegro> where has a scope too
10:30:29 <bdbit> ventonegro: I realized this as the point in using "where" but I didn't understand let .. ion
10:30:33 <bdbit> I bet now I do.
10:30:40 <bdbit> any assignments? :D
10:31:01 <Syzygy-> bdbit: That's one of the best properties about channels like #haskell and #math... You hang out there - and have pleny people at your own skill level, plenty of people much much cooler than you and a steady stream of people even you know more than.
10:31:17 <Syzygy-> Stimulating discussion, constant help getting further yourself, and a way to be useful to others.
10:31:19 <bdbit> Syzygy-: uh, you noticed I was at #math a few days ago? XD
10:31:34 <Syzygy-> bdbit: Nope. But I'm a regular in #math here, and an op at #math on EFNet.
10:31:50 <ventonegro> Syzygy-, that's right! I'm amazed I could help someone
10:31:55 <bdbit> Syzygy-: yes. It's my preferred way of generating good karma, too. Strangely, I always find a way to give (sometimes helpful) advice, no matter how inept I am at a topic :D
10:31:57 <glguy> Syzygy-: is there a math question you have to be able to answer to get your op status?
10:32:16 * ventonegro still gets confused by monads
10:32:27 <Syzygy-> glguy: Nope. I got op by being around a lot at a time when almost all ops where in US timezones...
10:32:48 <bdbit> ventonegro: I haven't even started to try to understand monads :D
10:32:58 <glguy> Syzygy-: oh )-: that's not as interesting of a story (-;
10:33:00 <Syzygy-> glguy: ops there tend to be handed out based on your estimated ability to help keeping a decent level of communication in the channel...
10:33:31 <EvilRanter> evening chaps
10:33:41 <EvilRanter> @pl \x y -> negate(x + y)
10:33:42 <lambdabot> (negate .) . (+)
10:33:48 <ventonegro> bdbit, i guess i got some grasp of it, but sometimes...
10:33:57 <ventonegro> > let a = "hi " in a >> a
10:33:58 <EvilRanter> ah, (negate .), not (negate) ...
10:34:05 <lambdabot>  "hi hi hi "
10:34:06 <bdbit> this is inarguably the most adequate way of "handing out" +o
10:34:42 <ventonegro> @type Data.List.bind
10:34:44 <lambdabot> Not in scope: `Data.List.bind'
10:34:56 <cjeris> ventonegro: because that turns into concatMap (\_ -> "hi") "hi", right?
10:35:04 <cjeris> s/"hi"/"hi "/g
10:35:07 <glguy> cjeris: yeah
10:35:33 <ventonegro> so that's how it works :-)
10:35:49 <glguy> > [a | _ <- "hi ", a <- "hi "]
10:35:50 <bdbit> let f x = x * 2 in let f2 x = f (2 * x) / y where y = 2
10:35:51 <lambdabot>  "hi hi hi "
10:35:53 <bdbit> > let f x = x * 2 in let f2 x = f (2 * x) / y where y = 2
10:35:53 <lambdabot>  Parse error
10:36:04 <glguy> bdbit: all let's get in's
10:36:18 <bdbit> glguy: I know, I was just too eager to try it out :D
10:36:27 <bdbit> > let f x = x * 2 in let f2 x = f (2 * x) / y where y = 2 in f2 2
10:36:28 <lambdabot>  4.0
10:36:30 <bdbit> whoa :d
10:36:39 <bdbit> that's even kind of what I expected.
10:41:56 <edwardk> > let f x = x * 2; f2 x = f (2*x) /y; y = 2 in f2 2
10:41:57 <lambdabot>  4.0
10:42:28 <bdbit> owgh... r u trying to confuse me with new syntax?
10:42:40 <Syzygy-> bdbit: ; is the same thing as linebreaks.
10:42:50 <Syzygy-> bdbit: And you can have several assignments in a single let.
10:42:56 <bdbit> oh!
10:43:06 <edwardk> not much, ; is playing the role of separate lines in the let statement, so you get the benefits of assigning multiple things that can refer to one another
10:43:08 <bdbit> I was wondering where all the semicolons have gone in haskell
10:43:21 <bdbit> edwardk: fine
10:43:23 <Syzygy-> bdbit: They are ignored if you use layout parsing.
10:43:33 <Syzygy-> bdbit: But both those and the {} hover around for use if you want them.
10:43:43 <bdbit> what do {} do?
10:43:46 <edwardk> bdbit whenever you use 'layout' they are secretly inserted by the parser.
10:43:50 <Syzygy-> bdbit: Neat thing: you can even recurse in the lets...
10:44:14 <Syzygy-> > let { f x = x*2; f2 x = f (2*x)/y; y=2 } in f2 2
10:44:16 <lambdabot>  4.0
10:44:22 <bdbit> edwardk: kind of expectable, if not obvious
10:44:23 <Syzygy-> {, } delineate blocks...
10:44:23 <edwardk> let x = 1<newline, and indent to where x is>y = 2 in something is the same as let { x = 1; y = 2 } in something
10:45:18 <bdbit> edwardk: I'm just reading about layout, I just didn't know about ";" yet.
10:45:22 <edwardk> in the above example i used the fact that you can manually insert additional 's.
10:45:31 <edwardk> er additional ;'s
10:45:34 <bdbit> by the way, you explained it better than the haskell.org tutorial
10:45:34 <edwardk> ahh
10:45:44 <Syzygy-> :)
10:45:51 * Syzygy- thinks the interactivity helps...
10:46:02 <bdbit> yah, "unfortunately" I have such a learning type
10:46:08 <bdbit> that doesn't really permit learning things alone.
10:46:22 <Syzygy-> Another plus for the irc channels, eh?
10:46:43 <Cale> You're also allowed to insert explicit ;'s without explicit {}'s
10:46:44 <bdbit> When I have to learn alone, I get an F in history class... when a buddy just tells the stuff to me like a story, I reach a C...
10:47:03 <emu> treat a history book like a story!
10:47:07 <Syzygy-> Cale: I didn't know that...
10:47:19 <bdbit> strangely, and that's what I don't get, is even though the teacher tells it like a story (albeit less relaxed, maybe that's it) I _don't_ get it
10:47:30 <glguy> bdbit: and sexual favors for the 'A'?
10:47:33 <bdbit> Syzygy-: definitely
10:47:42 * Syzygy- pops afk.
10:47:43 <Cale> the only time when you really need explicit {}'s is when there's ambiguity as to where blocks are closing
10:47:47 <Syzygy-> Time to meet fellow expats...
10:47:51 <Syzygy-> Cale: Ah.
10:47:54 <emu> i used to just read the history book while bumming around in history class. the teacher droned on, the book was interestin
10:47:55 <bdbit> glguy: Considering most teachers I would rather rebel.
10:48:07 <Syzygy-> There is some serious intelligence going on under the hood.... *boggle*
10:48:17 <EvilRanter> @type (.) negate . (+)
10:48:18 <lambdabot> forall a. (Num a) => a -> a -> a
10:48:24 <bdbit> Cale: or when you want to put stuff on one line that shouldn't be on one line?
10:48:29 <glguy> anyone know anything about repunits?
10:48:32 <Syzygy-> > (.) negate . (+) $ 5 2
10:48:33 <lambdabot>  add an instance declaration for (Num (t -> a))
10:48:36 <Syzygy-> > (.) negate . (+)  5 2
10:48:37 <lambdabot>  add an instance declaration for (Num (a1 -> a -> b))
10:48:43 <Syzygy-> > ((.) negate . (+))  5 2
10:48:45 <lambdabot>  -7
10:48:50 <Cale> bdbit: well, basically, though you can get quite far in that with just ;'s
10:48:55 <bdbit> Syzygy-: under which hood?
10:49:09 <Syzygy-> @pl (\(a,b) -> -(a+b))
10:49:10 <bdbit> Cale: I guess I agree :>
10:49:10 <lambdabot> (line 1, column 12):
10:49:10 <lambdabot> unexpected "-"
10:49:10 <lambdabot> expecting lambda abstraction or expression
10:49:16 <edwardk> I do my best learning something when I either honestly have a use for it, like it, or I can convince some primitive part of my hindbrain that I will absolutely need this to survive in spite of its boringness ;)
10:49:16 <Syzygy-> @pl (\a b -> -(a+b))
10:49:17 <lambdabot> (line 1, column 10):
10:49:17 <lambdabot> unexpected "-"
10:49:17 <lambdabot> expecting lambda abstraction or expression
10:49:23 <Syzygy-> @pl (\a b -> negate (a+b))
10:49:24 <lambdabot> (negate .) . (+)
10:49:28 <Cale> > let f [] = 0; f (x:xs) = 1 + f xs in f [1,2,3]
10:49:29 <lambdabot>  3
10:49:40 <Syzygy-> bdbit: The hood of Haskell compilers/interpreters
10:49:41 <Heffalump> has ghc6.6 started using a different naming scheme for made-up type variables?
10:50:12 <Cale> It would be cute if it used Greek letters :)
10:50:13 <Syzygy-> @type (.)
10:50:15 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
10:50:22 <bdbit> Syzygy-: now I can acknowledge your statement ;)
10:50:28 <edwardk> Syzygy-: yeah layout is seriously arcane shit, but its useful. just you never realize how much of a pain in the ass it is to write without until you go and need to write a parser for something similar =/
10:50:49 <Syzygy-> edwardk: Y'know... I can imagine just from what it lest me do....
10:51:05 <Syzygy-> But now.
10:51:06 <Syzygy-> AFK.
10:51:07 <Syzygy-> *poof*
10:52:06 <marcot> Hello there.
10:52:08 <shapr> geez
10:52:18 <edwardk> heya shapr
10:52:28 <shapr> I nearly grabbed my computer and ran for it... fire engines showed up and visited the apartment above me.
10:52:32 <marcot> Once I used IO variables, but I don't remember the name of the module..
10:52:37 <edwardk> shapr: ouch
10:52:55 <glguy> IORefs?
10:53:01 <shapr> If there were going to flood the apt above me, I was going to grab my hardware and flee!
10:53:02 <edwardk> shapr: given the fact that you are on channel it sounds like it fizzled
10:53:16 <shapr> edwardk: Yeah, seems to have been only dust in a long unused heater.
10:53:24 <edwardk> ah
10:53:50 <marcot> glguy: thanks.
10:54:01 <marcot> glguy: What about MVar, is it something near it?
10:54:18 <glguy> marcot: those are used for concurency I beleive
10:54:20 <glguy> believe
10:54:26 <marcot> hum..
10:54:28 <marcot> ok, thanks.
10:54:34 <bdbit> by the way... does Haskell do concurrency?
10:54:40 <bdbit> as in, "threads"
10:54:52 <glguy> yeah
10:55:14 <bdbit> I have a Core Duo T2500... 2x2 GHz. I bet parallelizing would speed up things a lot
10:55:26 <shapr> Try ghc-smp
10:55:43 * glguy warms up his fingers to prepare for the release the next mathschallenge problems
10:56:33 <shapr> bdbit: GHC has built-in support for shared memory smp.
10:57:03 <bdbit> shapr: that's coooool
10:57:19 <glguy> I have Haskell on the leaderboard at #6, I aim to keep it up there
10:57:35 <bdbit> shapr: does that mean I can use my source without modification on a multicore system and experience a load balancing between the cores?
10:58:56 <bdbit> (that would be a real plus for Haskell then, btw... one of my two cores is mostly pretty underloaded
10:59:17 <shapr> One modification that is required is to tell the runtime at execution time how many cores you have. Second, I don't remember if the SMP stuff automatically parallelizes code that isn't threaded or isn't using the par (parallel execution) combinator.
10:59:37 <Heffalump> it doesn't
10:59:43 <bdbit> no, it doesn't.
10:59:50 <integral> afaik ghc 6.6 doesn't do eager evaluation so you need to sprinkle in some forkIOs and pars
11:00:14 <bdbit> integral: that's what I would want to avoid, because I have no clue as to how to do that
11:00:24 <bdbit> parallelization is a big question mark for me
11:00:36 <bdbit> even JTR does it via a FIFO pipe O_o
11:00:49 <integral> the nice bit is that with par you don't have to worry about any locking
11:01:31 <bdbit> integral: I'll perhaps talk to you later about that, when the time has come, and I have a running Haskell prog :D
11:01:53 <bdbit> everything else would be premature optimization again, I think
11:02:02 * integral keeps meaning to finish his haskell hashed Game of Life impl with some parallelism
11:02:17 <bdbit> hehe
11:02:21 * integral found a uni dual proc box he can play with :)
11:02:42 * bdbit 's main machine is a 2 GHz dual core
11:02:58 <cjeris> haskell hash like haskell + corned beef + potatoes?  or like haskell + cannabis resin?
11:03:15 * integral likes branston pickle with his stovies
11:03:37 <bdbit> wahaha
11:03:42 <bdbit> this reminds me of a guy in our class..
11:04:12 <cjeris> integral:  what's that?  (i only speak US food-english)
11:04:14 <bdbit> 'twas Java lesson... and the teacher wanted to introduce to us the "HashSet"
11:04:54 <integral> cjeris: afaik it's just like hash :)
11:05:11 <bdbit> he didn't hesitate to ask pretty loudly "Hasch set?" (Hasch is german for the cannabis-type hash)
11:05:34 * integral think's Data.HashTable's looking a bit old compared to all the brand new Data. modules
11:05:43 <bdbit> he understood a HashSet as .. like.. a utility to smoking hash ;)
11:06:38 <monochrom> No wonder Java is so popular.
11:07:27 <bdbit> utility _for_ smoking hash of course
11:08:01 <cjeris> integral: mmm, that looks good.  of course, i love almost all fried meat products.
11:08:13 <bdbit> I don't understand why my english articulation hangs at such strange points
11:08:39 <integral> infinitive versus versus participle :-/
11:09:02 <bdbit> what? :D
11:09:34 <bdbit> maybe it's just intuitive versus grammatic, whereas I use the former
11:09:46 <cjeris> bdbit: in German would it be "<something> zu Hasch rauchen" ?
11:09:57 <bdbit> cjeris: It wouldn't! that's part of why I find it strange
11:10:04 <bdbit> <something> fuer Hasch rauchen
11:10:25 <bdbit> "fuer" is much more similar to "for" than "zu" which is similar to "to"
11:10:34 <bdbit> and "fuer" would be correct in german
11:10:56 <bdbit> ahhh
11:10:57 <cjeris> so the problem isn't a grammatical false cognate.  interesting.
11:11:11 <bdbit> yes. otherwise I wouldn't be very amazed
11:11:18 <shapr> bdbit: http://research.microsoft.com/~tharris/papers/2005-haskell.pdf - Haskell on a Shared-Memory Multiprocessor
11:11:21 <lambdabot> http://tinyurl.com/ybnb99
11:11:33 <bdbit> I guess integral is right
11:11:43 <bdbit> theres "for smoking hash" or "to smoke hash"
11:11:49 <bdbit> perhaps I just mixed it up intracranially
11:12:13 <bdbit> what an abuse of a word :D
11:13:06 <bdbit> shapr: thanks, I don't think that I'll come around to reading it, but at least I have no more excuse for being bored at school.
11:14:13 <cjeris> bdbit: well, English is confusing on account of being the union of all the world's languages :)
11:14:25 <bdbit> cjeris: heh
11:14:43 <pierre-> hello
11:15:00 <pierre-> where can i read about infixr syntax?
11:15:19 <bdbit> I'm not so much confused by english, rather by my inability to write it correct even though I'd know what "correct" is
11:15:49 <bdbit> pierre-: http://www.haskell.org/tutorial/functions.html
11:15:51 <lambdabot> Title: A Gentle Introduction to Haskell: Functions, http://tinyurl.com/mv27v
11:16:23 <bdbit> "write it correct", there we have another case
11:16:26 <monochrom> http://haskell.org/onlinereport/  has information
11:16:28 <bdbit> that should've been "correctly"
11:16:28 <lambdabot> Title: The Haskell 98 Language Report
11:16:52 <monochrom> Americans like to say "real good" these days.
11:17:12 <bdbit> why do they? ^^
11:17:16 <cjeris> monochrom: right. "good" is only an adjective, but "real good" is an adverb.  at least it's not "doubleplusgoodwise".
11:18:00 <bdbit> this, though, exceeds my capabilities
11:18:05 <pierre-> bdbit: thx
11:18:09 <bdbit> pierre-: yw
11:18:22 <monochrom> I think they still use "real good" as an adjective.  "This burger is real good."  The point is they use "real" as an adverb, "#haskell is real helpful"
11:18:34 <bdbit> ahh yeah.
11:18:53 * monochrom is real smart
11:19:14 * bdbit noticed
11:19:30 <cjeris> monochrom: oh, ok.  i didn't think you were talking about that because that's been standard in the Midwest since I was little (25 years ago) :)
11:20:14 <monochrom> The midwest is the warmbed for language butchering
11:20:21 <monochrom> err hotbed
11:21:17 * cjeris points over yonder westward for language butchery
11:23:59 * cjeris has established once again that he is, in fact, an idiot
11:25:33 <roconnor> > [(2^n)^(2^n) | n <- [0..]]
11:25:35 <lambdabot>  [1,4,256,16777216,18446744073709551616,1461501637330902918203684832716283019...
11:26:26 <roconnor> > [product[1..(2^n)] | n <- [0..]]
11:26:27 <lambdabot>  [1,2,24,40320,20922789888000,263130836933693530167218012160000000,1268869321...
11:26:36 <Cale> "10 items or less"
11:26:59 <roconnor> a) number of functions on n bits
11:27:08 <roconnor> b) number of reversable functions on n bits
11:27:10 <monochrom> [product[1..(2^n)] | n <- [0..]]  can be optimized by scanl
11:28:36 <Cale> Is it "less cake" and "fewer currants" or "fewer currants" and "less cake"? :)
11:28:43 <Cale> er
11:28:53 <Cale> Is it "less cake" and "fewer currants" or "less currants" and "fewer cake"? :)
11:29:17 <Cale> heh, I corrected myself while trying to make a mistake
11:29:19 <monochrom> "cake" sounds like uncountable.  "currants" sounds like countable and plural
11:29:29 <Cale> yes
11:29:41 <monochrom> less uncountable, fewer countable
11:29:46 <Cale> right
11:29:53 <Cale> The strange thing is that there don't seem to be corresponding words for 'more'
11:29:56 <monochrom> 'and' is commutative
11:29:56 * cjeris serves Cale an uncountable set of cake
11:30:30 <cjeris> of course, then how much cake you could have depends on part on the continuum hypothesis
11:30:42 <roconnor> so that would be less real number rather than fewer real numbers?
11:30:43 <monochrom> {"less", "fewer"} and {"more"} are only Galois-connected, not isormorphic.
11:31:33 <cjeris> monochrom: reference for term "Galois connection" in this context?
11:33:53 <monochrom> For partial orders P, Q and functions f:P->Q, g:Q->P, f and g are a pair of Galois connections iff (fx<=y iff x<=gy)
11:35:43 <bdbit> cjeris: how did you do that?
11:36:43 <cjeris> monochrom: so if you consider P and Q as poset categories, it's a pair of adjoint functors between them?
11:36:45 <cjeris> bdbit: do what?
11:36:54 <monochrom> YES!
11:36:59 <bdbit> establish that you are an idiot
11:37:02 <bdbit> I missed it
11:37:56 <cjeris> bdbit: Q: Why is my database query so slow now?  A: Maybe because I dropped all the indexes?  :p
11:38:03 <bdbit> ehhe
11:38:06 <monochrom> Hahahahaha
11:39:17 <cjeris> lunch &
11:39:57 <bdbit> fg 1; C-c; echo "you're too fat."
11:41:26 <monochrom> you're mean and lean
11:41:34 <bdbit> yes, sometimes, I am
11:42:56 <bdbit> and hungry ;_; (I'm too lean)
11:52:41 <gour> ff ff
11:52:50 <gour> bfff
11:53:11 <bdbit> *tries to patch the leak with gaffer tape*
11:53:17 <gour> fqq  qwerh lÄdff1112345f b
11:53:35 <bdbit> loadkeys de-latin1-nodeadkeys
11:53:48 <bdbit> hmm
11:57:23 <bdbit> let main = print "meh" in main
11:57:25 <bdbit> > let main = print "meh" in main
11:57:26 <lambdabot>  No IO allowed
11:57:28 <bdbit> ow.
11:57:53 <bdbit> subpixel-hinting is such a great feature on 1920x1200
12:03:19 * araujo `offTo` bed :: IO Sleep
12:03:34 <bdbit> @localtime araujo
12:03:35 <lambdabot> Local time for araujo is Fri Oct 27 15:02:19
12:03:42 <bdbit> araujo: good nite :D
12:06:05 <bdbit> Haskell does OOP?
12:06:35 <JKnecht> nope.
12:06:35 <vegai> outdoes
12:06:39 <bdbit> hehe
12:06:54 <bdbit> what then is "class Eq a where  (==)   :: a -> a -> Bool" ?
12:07:15 <bdbit> oh, it's TYPE classes :D
12:07:52 <vegai> bdbit: and type classes have methods
12:07:54 <vegai> fun, eh?
12:08:02 <bdbit> vegai: yes.
12:08:05 <dylan> and instances
12:08:18 <bdbit> okay those instances are easy to understand
12:15:38 <chessguy> OOP is now obsolete :)
12:15:46 <bdbit> huh? "now"?
12:15:49 <bdbit> functional programming is ages old
12:15:58 <chessguy> haskell isn't
12:15:59 <bdbit> isn't it even older than object orientation?
12:16:20 <monochrom> age and obsoletion are orthogonal
12:16:41 <monochrom> 486 was just 15 years ago and was almost immediately obsolete
12:16:45 <bdbit> i don't understand that
12:17:01 <monochrom> English is like thousands of years old and people still clinge to it
12:17:25 <chessguy> yeah anyway. up esperanto!
12:17:29 <monochrom> One would think that by now English ought to be obsolete at least for the purpose of mathematical proofs.
12:18:13 <bdbit_> re
12:18:14 <Lemmih> monochrom: I'll bet you'd have difficulties understanding English from a thousand years ago.
12:18:17 <bdbit_> I meant to say that I got the impression that functional programming was there before OOP
12:19:18 <monochrom> Yes FP was older.
12:19:30 <bdbit_> Java was never really good
12:19:38 <bdbit_> and Java is THE most widely used OOP language
12:19:54 * dylan mutters about java not being object oriented
12:19:55 <bdbit_> Java was flawed by design.. there is no direction it can evolve to
12:20:05 <bdbit_> dylan: that even adds to it.
12:20:29 <monochrom> widely used things are never really good.  perhaps only bearable.  for example windows.  don't you use windows as an example against OSes.
12:20:31 <dylan> Smalltalk is actually like a functional programming language.
12:21:05 <bdbit_> monochrom: yah. actually, you're right. But I've grown the standpoint that windows isn't 100% bad... with Java I'm not so sure..
12:21:19 <monochrom> Java isn't 100% bad.  I am sure about that.
12:21:41 <dylan> java is a very advanced language, for 1980.
12:21:47 <bdbit_> monochrom: of course. It's pretty fast for the stuff it does while maintaining being an interpreted bytecode language that's pretty portable
12:22:05 <bdbit_> dylan: I wasn't aware that Java is THAT old, maybe that's were my misconceptions come from
12:22:17 <dylan> bdbit_: it isn't that old
12:22:33 <monochrom> dylan is sarcastic :)
12:22:38 <bdbit_> owwww...
12:22:44 <bdbit_> that really hit java in the face now X_x
12:23:48 <dylan> well, I run a local programming club, and java is on the list of "unreal" languages. I'm somewhat... biased against it
12:24:44 <bdbit_> I must admit I am in a societal environment where Java bashing is kind of fashionable... but I still have some deep aversion against it
12:24:49 <Cale> Java isn't so old if you count years, but it's old at heart.
12:25:14 <bdbit_> Cale: yah, that's what dylan wanted to imply :D
12:25:30 <Cale> The ideas in Java are (mostly) quite old.
12:25:32 <bdbit_> I just caught myself trying to tab-complete "wa[nted]"
12:25:32 <dylan> it's too bad java wasn't more like objective c
12:25:59 <mauke> is there a version of OOHaskell that works in ghc-6.6?
12:26:51 <monochrom> I tend to tab-complete things all the time too.  For example nat[tab] trans[tab] for natural transformation.
12:27:03 * Heffalump works in embedded software, everyone around me seems to hate Java :-)
12:27:32 <bdbit_> monochrom: as long as you have it in your config... it's fine. I don't :D
12:27:42 <dylan> I haven't really met anyone that likes java
12:27:43 <monochrom> I don't either.
12:27:45 <bdbit> hehe
12:27:46 <Cale> I think all you have to do to hate java is program something even the slightest bit nontrivial in it.
12:27:54 <bdbit> then that's a case of unixification, I guess
12:27:57 <chessguy> i like java's API
12:28:02 * Heffalump helped write an entire compiler in Java
12:28:33 <Cale> I wrote a compiler in Java (of the variety that one can write in the context of a single course, but still :)
12:28:37 <bdbit> dylan: I have. Those people are a nightmare. Often times they know NO other language than Java. Or their second language is PHP .....
12:28:43 <monochrom> I am ahead of my age.  There should be a telepath interface, and it should read my mind when I hit <tab>.
12:29:00 <Cale> It could at least complete against, say, the dictionary :)
12:29:17 <Cale> with a count of which words you've used in the past :)
12:29:17 <bdbit> that's what I would expect from tab-completing programs
12:29:28 <bdbit> def[tab]
12:29:50 <mauke> what's a language that's flexible, fun to program in, and reasonably easy to write an interpreter for in java?
12:29:58 <bdbit> Heffalump: I think I can feel with those coworkers of yours
12:30:08 <bdbit> Brainfuck?
12:30:21 <mauke> fails for 1) and 2)
12:30:24 <monochrom> Goedel numbering.
12:30:26 <chessguy> isn't BF just syntactic sugar for java?
12:30:28 <bdbit> sorry, that fulfills only #3 and #2 to a very small degree
12:30:33 * Heffalump thinks they're all performance-obsessed
12:30:56 <bdbit> Heffalump: if I was performance-obsessed I wouldn't have come here from ruby X_x
12:31:02 <monochrom> Java has BigInteger and even BigInteger.isprime so you can do Goedel numbering easily.
12:31:20 <bdbit> probably Piet would be cool with the Image processing libraries
12:31:22 <monochrom> And Goedel found it flexible and fun.  Can't be wrong.
12:31:28 <bdbit> although I don't know if compiling Piet is any good
12:31:36 <dylan> Scala is a nice language for the JVM.
12:32:02 <bdbit> oh, you DID write interpreter. look into Piet!
12:33:11 <cjeris> mauke: MIPS32 assembler. :D
12:33:24 <mauke> AIIRRR
12:33:54 <mauke> hmm, a simplified ploki might be a better idea
12:33:54 <bdbit> oh, sorry, Piet fails for #1
12:34:40 <Heffalump> MIPS, evil ;-)
12:37:33 <glguy> Oh I look good,  I look really good.
12:37:40 <bdbit> lol
12:37:41 <glguy> *Hey everyone, come see how good I look*
12:37:50 <monochrom> You do.  You have a date this evening?
12:37:50 <bdbit> that's the explanation for the nickname..
12:38:11 <bdbit> I know that feeling
12:38:15 <glguy> monochrom: I do, actually (-:
12:38:25 <bdbit> sometimes I look into the mirror and can't explain why there's not 20 women falling over myself right now
12:38:40 <chessguy> are you guys gonna do some haskell programming together? :)
12:38:49 <bdbit> I see the answer on other days
12:38:54 <glguy> *If you were a man, I'd punch you right in the mouth. That's Bush! That's Bush League!*
12:38:55 <monochrom> You stink.  You won't know that from the mirror.  Get a dog.
12:39:05 <chessguy> lol
12:39:46 <chessguy> well, that was a conversation-stopper
12:40:27 <jajs> hello. i don't understand "seq". does (seq a b) evaluates a, then b and return the latter ?
12:40:35 <monochrom> Try American Idols.  Some company will make CDs for you.  There will be 20 women falling over your CD.
12:40:35 <Heffalump> jajs: yes
12:40:41 <bdbit> neurogeek: is a cool nickname
12:40:47 <Heffalump> except it evaluates it to "Weak Head Normal Form"
12:40:53 <Heffalump> which isn't the same as fully evaluating it
12:41:04 <bdbit> monochrom: I'll better get some women not trying to impress them with my looks
12:41:09 <monochrom> seq a b won't evaluate b.
12:41:23 <Heffalump> it will if it is evaluated itself
12:41:42 <monochrom> seq (seq a b) c will evaluate b.
12:41:45 <Heffalump> ok, more accurately, if seq a b is evaluated, it first evaluates a to WHNF, then evaluates b
12:42:03 <resiak> What's the W standing for there?
12:42:09 <Heffalump> if it's not evaluated it won't evaluate a at all
12:42:09 <monochrom> weeeeeeeeeeek
12:42:13 <monochrom> err weak
12:42:16 <Heffalump> :-)
12:42:37 <glguy> monochrom: has it been a... *long week*?
12:42:39 <Heffalump> HNF implies doing evaluation under a lambda.
12:42:42 <Heffalump> WHNF doesn't.
12:42:57 <chessguy> ok, so who's got a cool name idea for my haskell chess engine? :)
12:43:15 <bdbit> are types important while learning Haskell?
12:43:20 <mauke> haha
12:43:23 <Heffalump> bdbit: naah
12:43:27 <bdbit> I'm kind of overwhelmed by chapter "Type Classes"
12:43:28 <Heffalump> bdbit: just make them up as you go along
12:43:31 <chessguy> is addition important when learning math?
12:43:34 <Heffalump> (yes, they are important)
12:43:37 <glguy> chessguy: depends I guess
12:43:51 <Heffalump> chessguy: Haschess
12:44:02 <chessguy> bah
12:44:04 <resiak> chesh
12:44:12 <glguy> maybe... hchess?
12:44:17 <Heffalump> with the ch rendered sort of like a k and the ss like a ll
12:44:25 <monochrom> types are important, but type classes are advanced.
12:44:43 <chessguy> Heffalump, lol
12:44:44 <glguy> *I love scotch, scotch scotch scotch*
12:44:56 <bdbit> monochrom: that's what I was trying to ask
12:44:59 <jajs> Heffalump, ok. (seq [1..] 42) terminates and that confused me
12:45:03 <bdbit> So I can jump "type classes" for now?
12:45:09 <chessguy> what about...the lambdinator
12:45:09 <monochrom> yes
12:45:16 <Heffalump> bdbit: well, for a bit
12:45:17 <bdbit> chessguy: I hate that name
12:45:18 <resiak> Heffalump: Hmm, can you elaborate?
12:45:21 <chessguy> lol
12:45:23 <glguy> jajs: [1..] evaluates to a List of something
12:45:23 <Heffalump> resiak: on WHNF?
12:45:24 <chessguy> it was a joke
12:45:31 <resiak> Heffalump: WHNF vs HNF
12:45:44 <Heffalump> jajs: seq [1..] 42 causes [1..] to be evaluated to _:_ and then it stops
12:45:46 <glguy> jajs: seq isn't "DeepSeq"
12:45:55 <bdbit> Heffalump: is there a better tutorial for type classes than the one on haskell.org?
12:45:58 <Heffalump> it just needs to see the topmost constructor
12:46:00 <Heffalump> bdbit: no idea, sorry
12:46:03 <bdbit> I Don't Understand A Word There
12:46:11 <chessguy> hmm, maybe something having to do with laziness
12:46:11 <glguy> is tha tthe title?
12:46:19 <mtahti> Hi, I've got a newbie question. I'm writing a library that has this computationally intensive function N :: Double -> Double. Is there any way to cache the results?
12:46:21 <mauke> bdbit: long story short: type classes are interfaces
12:46:23 <resiak> Heffalump: I thought I understood what HNF was from the Î»-calculus course I'm in the middle of, but I can't see how one could usefully weaken it.
12:46:38 <Heffalump> resiak: \x -> (\a -> a+a) 1 is in WHNF but not HNF
12:46:45 <chessguy> funnily enough, there's a completely different concept of lazy eval in most chess engines
12:46:52 <Heffalump> whereas (\a -> a+a) 1 is in neither
12:47:07 <bdbit> chessguy: what about HCE?
12:47:12 <monochrom> http://www.cs.utoronto.ca/~trebla/fp/  lecture 6 is on type classes
12:47:14 <lambdabot> Title: Albert's Functional Programming Course
12:47:25 <chessguy> bdbit, depends what it stands for
12:47:30 <resiak> Heffalump: Huh, I thought that the first was in HNF.  I guess I should take another look at my lecture notes :)  Thanks.
12:47:30 <kowey> bdbit, try also http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics
12:47:34 <lambdabot> http://tinyurl.com/y8w64d
12:48:02 <Heffalump> resiak: HNF (\a . E) = \a . HNF E, whereas WHNF (\a . E) = \a . E
12:48:02 <monochrom> I don't believe you, mtahti.  You can't name your function "N".
12:48:07 <Heffalump> otherwise the recursive definitions are the same
12:48:11 <bdbit> chessguy: haskell chess engine
12:48:18 <bdbit> monochrom: thanks
12:48:22 <chessguy> bdbit, oh! duh. how boring, though
12:48:45 <jajs> Heffalump, glguy thanks. this channel is so helpful :-)
12:48:46 <resiak> Heffalump: I thought that the whole point of HNF was that it doesn't evaluate inside a lambda.
12:48:51 <resiak> (but I am wrong!)
12:49:09 <Heffalump> that's the whole point of WHNF :-)
12:49:12 <mtahti> Well, it's Haskell-name is nLuku but in literature it's often referred as N.
12:49:20 <mauke> mtahti: http://www.haskell.org/hawiki/MemoisingCafs http://www.haskell.org/hawiki/MemoizingRecursion
12:49:22 <lambdabot> Title: MemoisingCafs - The Haskell Wiki
12:49:38 <chessguy> oooh
12:50:01 <bdbit> kowey: I don't understand the link or it doesn't work
12:50:25 <mtahti> Thanks mauke!
12:50:45 <monochrom> Hmm setting up an array of Double's may be tricky, Batman!
12:50:49 <kowey> bdbit: what do you mean? you get a 404? or some seemingly irrelevant page?
12:51:26 <bdbit> kowey: sorry, it was my Gnome Terminal 's fault
12:51:48 <bdbit> kowey: it added the current time to the link because the link ended at exactly the right border
12:51:56 <chessguy> what about GCHess
12:52:13 <bdbit> do you study at glasgow?
12:52:18 <bdbit> otherwise, I'd say nay
12:52:21 <Cale> Heh, or just Hess
12:52:31 <chessguy> i've never been to glasgow
12:52:46 <chessguy> Cale, i like that. no C in this engine!
12:53:07 <bdbit> I too think Hess is surprisingly attractive
12:53:13 <bdbit> has some similarity with Hermann Hesse
12:53:23 <chessguy> we should get rid of C in Chess anyway :)
12:53:24 <bdbit> who really was a great writer
12:53:56 <monochrom> I like Hesse diagrams.
12:53:57 <chessguy> a lot different name from my first engine
12:54:30 <monochrom> Use them all.
12:54:41 <cjeris> or you could do it in German, and delete C from Schach to get Shah
12:54:50 <bdbit> yeah
12:54:55 <bdbit> that gets a vote
12:55:08 <chessguy> what's a hesse diagram?
12:55:11 <bdbit> although it's pretty similar to a Schah
12:55:23 <bdbit> which is a shah, actually
12:55:25 <chessguy> hmm, a Shah is a king too, isn't it
12:55:32 <bdbit> actually, yes.
12:55:53 <Cale> Hasse diagram
12:56:03 * bdbit votes for cjeris' suggestion "Shah"
12:56:06 <chessguy> ah
12:56:08 <Heffalump> chessguy: that'd be quite cool given the story about the chess board
12:56:25 <monochrom> If you have N names for your chess engine, use them all.  Make N releases, differing by just name.  Put them on N different web pages.  (Hell, create N different sourceforge home pages.)  Sit back and watch people fighting over "Hess 1.0 is better!" "No, Shah 1.0 is better!"
12:56:34 <chessguy> you mean the one about a grain of rice on the first square, 2 grains on the second, 4 on the third, etc.
12:56:48 <chessguy> lol
12:57:18 <bdbit> that really WOULD constitute an interesting experiment in sociology
12:57:29 <glguy> anyone know how to use mplayer so that when you resize the video window the video keeps it's aspect ratio?
12:57:52 <Heffalump> chessguy: you could call your releases Shah 1, Shah 2, Shah 4, etc.
12:58:10 <chessguy> LOL
12:58:33 <chessguy> might be a mouthful to say Shah 8192
12:58:44 <bdbit> chessguy: intelligent people express it in powers of 2
12:58:58 <bdbit> shows that they have the powers... of two!
12:59:13 <chessguy> Shah 2^13
12:59:15 <monochrom> 8192 = 2^13
12:59:17 <bdbit> you could even make versions in-between
12:59:21 <bdbit> and have people wondering
12:59:25 <cjeris> then people would think the name of the program was "Shah 1<<" and not "Shah".  -- oh wait, that's C again :(
12:59:25 <bdbit> > 2^2.3
12:59:26 <lambdabot>  Add a type signature
12:59:35 <bdbit> > 2 ^ 2.3 :: Int
12:59:36 <lambdabot>  Add a type signature
12:59:38 <chessguy> lol
12:59:38 <bdbit> duh
12:59:39 <bdbit> huh?
12:59:48 <Heffalump> @type (^)
12:59:50 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:59:54 <bdbit> someone show me how this works :D
12:59:57 <monochrom> need one for 2.3
12:59:58 <Heffalump> > (2 :: Int) ^ 2.3
12:59:59 <lambdabot>  Add a type signature
13:00:02 <bdbit> ohhh
13:00:04 <Heffalump> > (2 :: Int) ^ (2.3 :: Double)
13:00:05 <lambdabot>  add an instance declaration for (Integral Double)
13:00:06 <lambdabot>   In the definition of ...
13:00:07 <glguy> > 2 ** 2.3
13:00:07 <bdbit> duh
13:00:09 <lambdabot>  4.924577653379664
13:00:11 <monochrom> and die!
13:00:12 <bdbit> yesss...
13:00:20 <Heffalump> oh, those letters are the wrong way round
13:00:20 <mauke> @type (^^)
13:00:22 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:00:23 * Heffalump got confused
13:00:26 <glguy> > 2.3 ^^ 2
13:00:28 <lambdabot>  5.289999999999999
13:00:33 <glguy> > 2 ^ 2
13:00:35 <lambdabot>  4
13:00:35 <monochrom> If you can grok that, you understand type classes.
13:01:16 <Cale> almost. I'd say constructor classes are another (albeit small) leap from there :)
13:01:43 <bdbit> slightly painfufl
13:01:45 <bdbit> painful
13:01:54 <bdbit> well, what do you think about the versions? ;D
13:02:02 <chessguy> hmm, so we've got Hess and we've got Shah
13:02:06 <Cale> typeclasses are predicates which can be applied to type variables to constrain them
13:02:32 <Cale> For instance, you want to have (+) :: Int -> Int -> Int, and (+) :: Float -> Float -> Float
13:02:32 <bdbit> chessguy: do the google test... it usually reveals a lot
13:02:54 <Cale> but perhaps not every type works with (+)
13:02:56 <bdbit> so if I want to add Floats and Ints I do what?
13:03:05 <bdbit> or does that work?
13:03:08 <Cale> so (+) :: a -> a -> a isn't quite the right polymorphic type
13:03:16 <Cale> you convert one to the other
13:03:23 <bdbit> how?
13:03:30 <mauke> @type fromIntegral
13:03:31 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:03:33 <Cale> fromIntegral, round, floor, something :)
13:03:39 <bdbit> hm
13:03:42 <Cale> there are many options :)
13:03:53 <bdbit> fromIntegral sounds so mathematical
13:04:01 <bdbit> > 2.0 ^ 2.3
13:04:02 <lambdabot>  Add a type signature
13:04:07 <bdbit> why doesn't this work?
13:04:08 <Cale> the correct type for (+) is  (Num a) => a -> a -> a
13:04:20 <bdbit> @type (^)
13:04:21 <mauke> it can convert any integer to any numberic type
13:04:22 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:04:28 <Cale> because ^ only works with positive integral right arguments
13:04:43 <mauke> er, numeric
13:04:44 <Cale> (but the left parameter can be any kind of number)
13:04:59 <cjeris> bdbit: Note that the more common solutions to this problem for arithmetic really suck.  You can put ad hoc polymorphism with arithmetic operations (as most languages do), or you can do like OCaml did and make arithmetic monomorphic, so that (+): int -> int -> int but (+.): float -> float -> float.
13:05:13 <monochrom> You can truncate towards 0.  f _ = 0.
13:05:27 <Cale> ^^ works with possibly negative right parameters, but it has to make sense to divide with the left hand number
13:05:33 <bdbit> can't I just have it typecasted?
13:05:40 <bdbit> _explicitly_ ?`
13:05:47 <mauke> yeah, with fromIntegral et al.
13:05:52 <Cale> ** works with fractional right parameters, but the left hand parameter needs general exp and log
13:06:11 <Cale> which basically constrains you to floating-point based things
13:06:19 <bdbit> For me the Integral is the x' of an x ...
13:06:23 <mauke> > 2.0 ^ floor 2.3
13:06:24 <lambdabot>  4.0
13:06:26 <bdbit> umm no
13:06:29 <bdbit> the x of an x'
13:06:37 <Cale> bdbit: that's a different sense of the word
13:06:43 <bdbit> 2.0 ^ round 2.3
13:06:46 <bdbit> > 2.0 ^ round 2.3
13:06:48 <lambdabot>  4.0
13:06:50 <bdbit> O_o
13:06:53 <monochrom> "integral" is the adjective for "integer"
13:06:53 <Cale> bdbit: this is integral in a similar sense to integral domain
13:06:55 <mauke> bdbit: read Integral as "integery"
13:06:56 <bdbit> that's not what is supposed to happen ^^
13:07:00 <mauke> bdbit: why not?
13:07:16 <Cale> > 2.0 ** 2.3
13:07:18 <lambdabot>  4.924577653379664
13:07:28 <Cale> > round 2.3
13:07:29 <bdbit> When I say to the power of, I don't want to have to define a new operator for different kinds of numbers
13:07:30 <lambdabot>  2
13:07:53 <monochrom> or integrity.  "Types are an integral part of Haskell."  This does not mean that if you integrate Haskell by parts you get types.
13:07:54 <Cale> bdbit: there are three mathematical definitions corresponding to exponentiation, and Haskell has one general operator for each
13:08:06 <bdbit> Cale: ouch
13:08:15 <Cale> bdbit: but they are polymorphic
13:08:16 <bdbit> Cale: I never knew that there is more than one.
13:08:40 <Cale> yeah, that's because in mathematics, we tend to hide the difference and try to ignore it :)
13:08:51 <monochrom> A debate on 0^0 will reveal that there are that many.
13:09:11 <mauke> > (0^0, 0^^0, 0**0)
13:09:12 <lambdabot>  (1,1.0,1.0)
13:09:18 <bdbit> And I hoped I will be able to escape mathematics while learning functional coding :&/
13:09:26 <mauke> huhu
13:09:40 <Cale> well, this is just good programming design. The representations of numbers in programming really matter
13:09:44 <Cale> in mathematics, they don't
13:09:59 <monochrom> Oh if you never use ^ ^^ **  you don't need to know.
13:10:00 <chessguy> bdbit, what google test?
13:10:05 <Cale> So in mathematics, you can get away with implicit inclusion of rationals into the reals, for instance
13:10:09 <mauke> math doesn't have floating point numbers
13:10:09 <bdbit> chessguy: just enter it in google and see what comes up
13:10:09 <Cale> no problems
13:10:18 <bdbit> guess you want your name to be googleable
13:10:30 <bdbit> I can imagine that Hess gives a lot of hits
13:10:35 <bdbit> and Shah a lot of unrelated ones
13:11:03 <chessguy> hmm, a famous chess player named hess
13:11:18 <mauke> Results 1 - 5 of about 7 for "stork porn". (0.13 seconds)
13:11:24 <bdbit> monochrom: I can't be sure I'll never use partial stuff of the language I want to code in if I've never heard of it
13:11:26 <mauke> I think we have a winner
13:11:44 <bdbit> It's not like it was intuitive and I would have noticed that it's my mathematical understanding that's lacking and not the lack of typecasts in the language
13:12:01 <mauke> haskell does have typecasts
13:12:11 <bdbit> no implicit ones
13:12:18 <mauke> no language has implicit casts
13:12:21 <chessguy> the only thing about Shah is, there's an engine called The King
13:12:26 <chessguy> (aka ChessMaster)
13:12:27 <bdbit> what about java?
13:12:28 <mauke> cast := explicit conversion
13:12:44 <Cale> bdbit: one thing I should mention is that implicit typecasts of numbers are the source of a lot of bugs, and by not supporting them, you save yourself a lot of trouble. Haskell actually has the overloading machinery to construct a system which would convert automatically during operations, but it's not used for that.
13:12:46 <cjeris> chessguy: you could call it "instance Monad ChessGame" :)
13:12:54 <chessguy> lol
13:12:56 <bdbit> Cale: yah, I understood that
13:13:00 <chessguy> that's a mouthful :)
13:13:29 <bdbit> Cale: I just don't know how I should handle my inability to spot such problem zones
13:13:37 <bdbit> or rather, the inability to deal with them
13:13:37 * SamB finally registers with GHC Trac
13:13:43 <chessguy> i may also be doing some evolutionary stuff with this engine, would be cool of the name reflected that too
13:13:53 <Cale> bdbit: You really only need to know about two or so functions
13:14:00 <bdbit> I'm completely helpless now on what to do if I should encounter having to calculate 2 ** n somewhere, where n can be anything
13:14:12 <Cale> bdbit: fromIntegral will turn any integer-like type into any other numeric type
13:14:28 <Cale> realToFrac will convery between basically any fractional types
13:14:35 <bdbit> Cale: without loss? Would that make my ^ able to potentiate Flaots?
13:14:36 <bdbit> floats?
13:14:43 <chessguy> bdbit, helplessness is part of the fun :)
13:14:45 <Cale> > 2.3 ^ 2
13:14:47 <lambdabot>  5.289999999999999
13:14:55 <Cale> note that ^ works on floats :)
13:15:04 <Cale> it just doesn't work with floating point exponents
13:15:13 <Cale> only positive integer exponents
13:15:27 <Cale> well, natural exponents, zero is included :)
13:15:36 <chessguy> > 2^0
13:15:37 <lambdabot>  1
13:15:55 <chessguy> > 2^0.0
13:15:55 <lambdabot>  Add a type signature
13:16:03 <SamB> Cale: some people are not secumbing to zero-based naturals!
13:16:06 <chessguy> that's such a crappy error message
13:16:16 <SamB> chessguy: indeed
13:16:21 <Cale> As you move right in the list ^, ^^, **, you get more generality in your exponent, and less generality in your base.
13:16:49 <Cale> Because to exponentiate things with a negative exponent, for instance, it has to make sense to divide them
13:17:14 <Cale> and with a fractional exponent, you need even more special functions defined
13:17:19 <Cale> (exp and log)
13:17:32 <Baughn> ..naturals are 1 and up, right? That's why they're called "natural"
13:17:34 <bdbit> Cale: that means ^^ can do 2.0 ^ 2.0, and ** can only do 2 ^ 2.0 ?
13:17:43 <SamB> isn't ** in the class too?
13:18:24 <bdbit> ROFL
13:18:24 <Cale> ^: any base, natural number exponent
13:18:34 <Cale> ^^: fractional base, integer exponent
13:18:57 <chessguy> @type ^
13:18:58 <Cale> **: floating point base, fractional exponent
13:18:59 <lambdabot> parse error on input `^'
13:19:02 <SamB> *Main> :i (**)
13:19:02 <SamB> class Fractional a => Floating a where
13:19:02 <SamB>   ...
13:19:02 <SamB>   (**) :: a -> a -> a
13:19:02 <SamB>   ...
13:19:02 <chessguy> @type (^)
13:19:07 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:19:08 <bdbit> I just accidentally clicked on the voice output in dict.cc somewhere in my search results for "integral" and it said "indefinite integral"
13:19:13 <Cale> oh, floating point exponent as well :)
13:19:16 <bdbit> I was kind of shocked to hear that
13:19:20 <Cale> **: floating point base, floating point exponent
13:19:39 <Cale> bdbit: makes sense?
13:19:43 <chessguy> @type (^^)
13:19:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:19:50 <Baughn> @type (**)
13:19:51 <lambdabot> forall a. (Floating a) => a -> a -> a
13:19:59 <chessguy> more important than memorizing those things is being able to read these type signatures
13:20:18 <Baughn> Running lambdabot locally would probably be a good thing, too
13:20:25 <bdbit> i know what floating is, i have a slight idea what fractional means, but i don't have the least idea what "integral" is
13:20:27 * SamB is just pointing out that you could define (**) and leave log and exp undefined
13:20:28 * Baughn pokes emacs
13:20:39 <Cale> bdbit: well, rational numbers are fractional but not floating
13:20:56 <bdbit> Cale: huh?
13:20:57 <Cale> > (5/3) + (6/5) :: Rational
13:20:59 <lambdabot>  43%15
13:21:07 <bdbit> ah ok
13:21:08 <Cale> Haskell has exact fractions :)
13:21:21 <bdbit> these are rational and fractional numbers?
13:21:24 <SamB> bdbit: Integral means "whole, zero, negated whole"
13:21:29 <SamB> er. insert an "or"
13:21:32 <cjeris> Doesn't Integral roughly mean "subring of Z" ?
13:21:33 <Cale> Rational numbers are in the Fractional class
13:21:52 <chessguy> by the way, anyone know if haskell has an efficient way to extract the place of the least-significant (or most-significant) 1 in a bit string?
13:22:08 <SamB> @docs Bits
13:22:09 <Baughn> cjeris: Yep
13:22:09 <lambdabot> Bits not available
13:22:13 <SamB> @docs Data.Bits
13:22:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
13:22:19 <Cale> cjeris: It means roughly Euclidean domain
13:22:46 <Cale> cjeris: except that toInteger is there, which sort of messes that idea up
13:23:01 <bdbit> Cale: I seem to miss the mathematical terms in learning ruby
13:23:01 <Cale> though Int isn't a subring of Z
13:23:02 <SamB> also there was some good C++ bit-twiddling library which you could steal from
13:23:25 <Baughn> chessguy: ..oh, that's fun. Hmm, I think x86 has an opcode for it somewhere, but the usual method amounts to walking a tree
13:23:27 <chessguy> SamB, i don't see anything on that docs page that can do that
13:23:37 <SamB> chessguy: mmm
13:23:47 <chessguy> obviously, i can do it by combining operators there
13:23:55 <Cale> The Haskell numeric classes are sort of an awkward compromise between the mathematical definitions and the actual types commonly available in computer science :)
13:24:10 <Cale> They could be better.
13:24:16 <Baughn> SamB: So, is GHC /that/ good?
13:24:28 <chessguy> Baughn, would haskell have access to the x86 opcode?
13:24:37 <SamB> Baughn: if you feed it with a spoon, ocassionally, yes ;-)
13:24:41 <Baughn> chessguy: GHC surely could
13:24:57 <SamB> Baughn: it would be too much work, generally...
13:25:06 <chessguy> Baughn, how?
13:25:13 <Baughn> chessguy: Whether it would... it may not even be the best choice - most of the opcodes that don't fit neatly into the RISC execution units get emulated
13:25:14 <Cale> If you can write something in C, then you can FFI import it and use it from GHC.
13:25:19 <bdbit> Cale: sorry, Haskell.
13:25:20 <bdbit> duh
13:25:27 <SamB> now, giving you the primops that it would be able to generate those instructions from, that maybe it could do
13:25:28 <bdbit> I am too tired I guess
13:25:29 <Cale> bdbit: hehe
13:25:44 <bdbit> I'll just skip learning number theory today
13:25:45 <SamB> oh, are you talking about a special opcode just for that?
13:25:49 <blsecres> is there an accepted way to represent infinity?  I've seen an argument for a literal and a suggestion to use the non-portable 1 / 0
13:25:51 <SamB> I think that opcode is too slow ;-P
13:25:54 <Baughn> chessguy: It's a compiler - it's allowed to be sufficiently smart. ;)
13:25:55 <bdbit> and instead remember who I'll ask when I'm ready to comprehend
13:25:58 <Baughn> SamB: Probably
13:26:01 <Cale> bdbit: Don't worry too much about it, it's something that's easier to just ignore and get used to when the bugs crop up
13:26:07 <SamB> http://www.jjj.de/fxt/
13:26:09 <chessguy> so....
13:26:09 <SamB> look at that
13:26:20 <Baughn> Ooh..
13:26:24 <SamB> what happened to lambdabot
13:26:26 <SamB> ?
13:26:27 <dvekravy> jezis0k
13:26:28 <dvekravy> z`
13:26:34 <dvekravy> ,arjaaaaa
13:26:36 <bdbit> Cale: It's just... I like to know such things beforehand, even though I am not quite _motivated_ to do so
13:26:51 <dvekravy> uh sorry.. bad window :)
13:26:58 <bdbit> because I tend to quickly grow hate towards a tool if it doesn't do what I want it to do AND I can't figure out why because I don't understand it
13:26:59 <chessguy> SamB, uh, that's not haskell code is it?
13:27:16 <bdbit> that infers that one of (me, tool) must be inadequate
13:27:34 <bdbit> both logically leading to my abandonment of the language, which I have to avoid ;:>
13:27:48 <Cale> bdbit: I have a BMath degree in pure math, and it must have been a few months before I was used to the numeric classes in Haskell :)
13:28:02 <bdbit> that's why I have some kind of obsession to "get it"
13:28:09 <bdbit> but it's not for today, I'm feeling that now :D
13:28:10 <Baughn> chessguy: They're algorithms. Most of them can be implemented in haskell.
13:28:22 <bdbit> Cale: that only emotionally comforts me
13:28:25 <Cale> hehe
13:28:26 <bdbit> technically, this even upsets me ;D
13:28:40 <bdbit> (oh, how I hate human duality)
13:28:44 <Cale> Mostly because I ignored the issue
13:28:47 <Baughn> chessguy: ..although they look mostly useful for /implementing/ haskell
13:28:56 <chessguy> so i see something like:
13:28:58 <chessguy> static inline ulong highest_bit(ulong x);
13:28:58 <chessguy> // Return word where only the highest bit in x is set.
13:28:58 <chessguy> // Return 0 if no bit is set.
13:29:04 <chessguy> that's not an algorithm
13:29:13 <Cale> Mostly, you can get around any confusion by declaring your types with specific numeric types
13:29:30 <Cale> and only knowing about fromIntegral :)
13:29:31 <Baughn> chessguy: SOurce code is in a .tgz slightly higher on the page
13:29:56 <bdbit> Cale: but that wouldn't help me to do 2.3 ^ 2.3, would it?
13:30:06 <bdbit> > 2 ** 2
13:30:07 <lambdabot>  4.0
13:30:13 <Cale> I suppose. You'd just always use ** on floats
13:30:16 <bdbit> couldn't I just always use "**"
13:30:19 <bdbit> yeah
13:30:19 <Cale> yeah
13:30:24 <Cale> and for integers ^
13:30:31 <Cale> and that's about it :)
13:30:35 <bdbit> as long as I'm not optimizing I could just _always_ use ** and convert back
13:30:40 <Cale> that too
13:30:59 <bdbit> If I get motivated for optimizing, that will be a good kind of motivation for learning it on a deeper level :D
13:31:05 <Cale> though that doesn't work too well with really large numbers
13:31:10 <Cale> > 2^200
13:31:12 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
13:31:25 <Cale> > round (2**200)
13:31:25 <bdbit> > 2 ** 200
13:31:27 <lambdabot>  1606938044258990275541962092341162602522202993782792835301376
13:31:28 <lambdabot>  1.6069380442589903e60
13:31:34 <Cale> oh look :)
13:31:35 <Cale> hehe
13:31:40 <bdbit> looks pretty to me
13:31:45 <Cale> shouldn't have picked a power of 2
13:31:46 <glguy> bdbit: picking ^^ or ** isn't about optimization, it's about the typeclasses matching what you want them to
13:31:46 <Cale> :)
13:31:57 <bdbit> glguy: but I can always convert!
13:31:58 <Cale> > round (3**200) == 3^200
13:32:00 <lambdabot>  False
13:32:04 <Cale> > round (3**200)
13:32:06 <lambdabot>  2656139888758747805986104187855754666121067264864644519182269393740885795378...
13:32:09 <bdbit> oww..
13:32:28 <bdbit> > 3^200
13:32:30 <lambdabot>  2656139888758747693387813220357796268292334526533944959745749617390924909013...
13:32:34 <bdbit> ow!
13:32:37 <Cale> powers of 2 have particularly simple exact floating point representations
13:32:38 <bdbit> now that IS a difference
13:33:05 <bdbit> Cale: yeah, hehe, that's quite obvious considering computers only work in bases of 2
13:33:09 <glguy> bdbit: if you don't care if the answer is correct, you could just go with using a ** b = 20
13:33:22 <Cale> Haskell has nice enough types like Integer that it was worth doing things at least this correctly :)
13:33:45 <bdbit> glguy: I thougt it would all just be arbitrary precision
13:33:54 <bdbit> that's why I said "optimizing"
13:33:59 <Cale> Yeah, Float and Double aren't arbitrary precision
13:34:00 * monochrom â¥ Haskell
13:34:17 <bdbit> *That* is what I should have understood beforehand
13:34:27 * monochrom â¥ #haskell too
13:34:34 <chessguy> looks like a lot of this was intended to be implemented in c/c++
13:34:38 <bdbit> then it's actually not the slightest but of wonder that I need different operators"
13:34:41 <glguy> bdbit: even if they were arbitrary precision, it doesn't make sense to force yourself to do lots of unneeded rounds and fromIntegers
13:34:43 <Cale> Arbitrary precision reals are computationally annoying. There is a library for them, but it's not included, and not all the operations you might want are there.
13:34:47 <bdbit> I was looking at things from a ruby perspective!
13:34:59 <Cale> Equality tests, for instance, become impossible
13:35:00 <bdbit> if it gets too big, it'll be converted to a Bignum...
13:35:10 <Cale> Integer is like that
13:35:11 <bdbit> I don't have to care about that in ruby. So there's no need for different operators...
13:35:27 <Cale> Integers are internally machine integers until they're too large
13:35:44 <glguy> bdbit: you don't have to care in Ruby because ruby doesn't bother with type safety
13:35:49 <chessguy> there's a lot of assembly code in there, too
13:35:51 <Cale> Ints are always machine integers regardless
13:35:57 <bdbit> glguy: it is not very type unsafe either
13:35:59 <chessguy> haskell can't acess that, can it?
13:36:13 <bdbit> it does use duck typing, but a suitable form of it
13:36:31 <SamB> chessguy: you talking about the fxt stuff?
13:36:36 <chessguy> yah
13:36:37 <bdbit> Cale: the picture is getting clearer
13:36:51 <SamB> you are supposed to steal the non-ASM bits, by translating them into Haskell...
13:37:00 <bdbit> once again proving my theory about "if you have the feeling you don't 'get it' there's something you really *don't see*"
13:37:06 <SamB> the ASM stuff is probably too slow anyway ;-P
13:37:36 <Cale> Haskell has something that's at least as general as duck typing, but is more methodical. You define general interfaces that you want to use, called typeclasses, and then make whichever types you want instances of those classes.
13:37:59 <bdbit> I like Haskell's way of doing it the very best of all methods
13:38:04 <Cale> You can even have typeclasses with multiple type parameters which tie related types together.
13:38:12 <chessguy> i have a hard time believing that haskell can do anything as fast or faster than ASM
13:38:16 <SamB> Cale: but you can't have existential lists
13:38:17 <bdbit> (and Haskell can do it because it's not OO, ruby profits largely from the ability to send EVERY message to EVERY class)
13:38:23 <cjeris> Cale: I like how you conveniently gloss over the part where your head explodes.
13:38:35 <Cale> cjeris: haha
13:38:38 <glguy> ruby doesn't really have "types" just capabilities specific to each instance...
13:38:49 <Cale> @remember cjeris Cale: I like how you conveniently gloss over the part where your head explodes.
13:38:51 <bdbit> glguy: yes
13:39:01 <Cale> @bot
13:39:02 <lambdabot> :)
13:39:08 <chessguy> @quote cjeris
13:39:09 <lambdabot>  i have a little perl script that aliases gcc -freduced-suckage to ghc
13:39:16 <monochrom> My head doesn't explode.
13:39:24 <SamB> Cale: and to think, if anyone read that... they'd probably think of one of two features right away...
13:40:18 <Baughn> SamB: Which ones?
13:40:18 <monochrom> Why do people's heads explode?  I never understand.
13:40:31 <bdbit> I was to say... I like Haskell's way of doing it, but my problem was the lack of awareness of the inability of a compiled language to provide performant arbitrary precision arithmetic
13:40:32 <SamB> I was thinking "typeclasses" and "monads"
13:40:35 <Botje> monochrom: lack of proper garbage collection
13:40:49 <cjeris> @karma+ Botje
13:40:50 <lambdabot> Botje's karma raised to 1.
13:41:00 <SamB> though probably you only have the head-explosion with monads if you try to figure out what they *are*, instead of how to *use* them ;-)
13:41:05 <Cale> I've had typeclasses catch some fairly subtle algorithmic bugs. I can't recall the details of the one I was most impressed with, but it was essentially a bug in a graph traversal algorithm. It was a pain to work out why it wasn't compiling, but it would have been much worse to have it run and try to find the bug later.
13:41:07 <monochrom> Ah, must be it.  They have this useless knowledge called "imperative programming" and they are not dumping it.
13:41:08 <Botje> :)
13:41:16 <bdbit> @karma+ Cale
13:41:16 <lambdabot> Cale's karma raised to 14.
13:41:19 <chessguy> so SamB, what am i to do with the ASM bits?
13:41:19 <bdbit> :)
13:41:26 <bdbit> cool feature
13:41:36 <SamB> chessguy: discard them and use the pure C/C++ implementation?
13:41:55 <chessguy> in haskell
13:42:06 <SamB> by writing Haskell code that does the same thing
13:42:12 <Maddas> monochrom: you don't understand because your head already exploded.
13:42:20 <monochrom> SamB: YES!  Precisely why on http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml I say at the opening: what are arrows?  I won't answer that, waste of time.
13:42:23 <lambdabot> http://tinyurl.com/yyhmda
13:42:25 <chessguy> that's gonna be majorly slow
13:42:30 <SamB> probably this involves a lot of cases
13:42:30 <bdbit> Cale: I'm with you. I was missing the fact that there is _information loss_ by conversion
13:42:41 <chessguy> @paste
13:42:41 <lambdabot> http://paste.lisp.org/new/haskell
13:42:43 <bdbit> I was assuming that a conversion from Integer to Float cannot cause information loss
13:42:50 <Cale> bdbit: yeah
13:42:55 <bdbit> which is entirely untrue regarding compiled languages
13:43:03 <lisppaste2> chessguy pasted "bits wizardry in haskell" at http://paste.lisp.org/display/28810
13:43:14 <chessguy> like this, i don't have a clue how to do this efficiently in haskell
13:43:20 <SamB> bdbit: what does compiled have to do with anything?
13:43:25 <Cale> actually, it's untrue of interpreted languages as well, unless they do something very unique with their numeric types
13:43:48 <Cale> floats are typically implemented as bounded-size data
13:44:01 <bdbit> SamB: in a compiled language you would probably have a lot of trouble typecasting all the time.. in a language like ruby it's not that great of a problem
13:44:07 <Cale> but arbitrary-precision integers aren't :)
13:44:09 <bdbit> because it's bottlenecks lie elsewhere
13:44:27 <Maddas> bdbit: Whether the language is interpreted or compiled is a question of implementation, not a fundamental property of the language
13:44:29 <bdbit> (my interpretation)
13:44:32 <Maddas> bdbit: Consider ghci
13:44:40 <bdbit> yeees...
13:44:40 <Cale> In a language with automatic casts, you can end up with subtle bugs due to information loss by implicit coersion
13:44:41 <SamB> bdbit: what has that to do with information loss?
13:44:41 <bdbit> of course
13:44:50 <Maddas> And consider C/C++ interpreters.
13:44:56 <chessguy> > 0xffff000
13:44:58 <lambdabot>  268431360
13:45:03 <SamB> Maddas: those are harder to consider
13:45:12 <monochrom> Casio made a programmable calculator containing a C interpreter.
13:45:12 <bdbit> SamB: It's too late (22:44) for the question game for me today.
13:45:19 <Maddas> SamB: I meant 'consider' as in 'take into account'.
13:45:22 <bdbit> Either clear my misconceptions up or leave it be.
13:45:29 <chessguy> > (268431360 `shiftR 32) + 32
13:45:30 <lambdabot>  Parse error
13:45:35 <chessguy> > (268431360 `shiftR` 32) + 32
13:45:36 <SamB> Maddas: it is harder to believe in them, too
13:45:36 <lambdabot>  Add a type signature
13:45:41 <roconnor> Cale: I have a theory that coersions must be injections.
13:45:43 <Maddas> SamB: Huh?
13:45:48 <SamB> well.
13:45:50 <Cale> irb(main):003:0> 3**200
13:45:50 <Cale> => 265613988875874769338781322035779626829233452653394495974574961739092490901302182994384699044001
13:45:50 <Cale> irb(main):004:0> 3**200 * 1.0
13:45:50 <Cale> => 2.65613988875875e+95
13:45:59 <SamB> unless you've seen one.
13:46:03 <Maddas> SamB: Yes.
13:46:06 <Cale> byebye digits :)
13:46:08 <Maddas> SamB: http://root.cern.ch/root/Cint.html
13:46:08 <chessguy> > ((268431360 `shiftR` 32)::Int) + 32
13:46:10 <lambdabot>  32
13:46:21 <bdbit> Cale: implicit coercion?
13:46:22 <glguy> Cale: implicit infomation loss?
13:46:28 <bdbit> lol
13:46:34 <Cale> irb(main):007:0> (3**200 * 1.0).floor() == 3**200
13:46:34 <Cale> => false
13:46:46 <Cale> same thing happening
13:46:54 <SamB> it only covers 95% of C and 85% of C++?
13:47:13 <Maddas> Is that a question?
13:47:23 <Cale> irb(main):008:0> (3**200 * 1.0).round() == 3**200
13:47:23 <Cale> => false
13:47:28 <Cale> similarly
13:47:30 <bdbit> I'm glad I understood the problem in conversion for today
13:47:34 <Cale> :)
13:47:38 <bdbit> I actually didn't expect I will
13:47:39 <SamB> more of a "what kind of a C interpreter is that?"
13:47:43 <glguy> Cale: if there is no information loss, you wouldn't need to round though
13:47:44 <chessguy> oh! i get what they're doing
13:47:50 <glguy> (if that was what yo uwere trying todemonstrate)
13:47:51 <Maddas> SamB: *shrug*
13:47:59 <bdbit> anybody have in mind how to color your own text in irssi?
13:48:05 <chessguy> that's a cool algorithm. may be hard to implement in haskell though
13:48:10 <bdbit> It hurts my eyes tremendously not having my own text coloured
13:48:12 <glguy> bdbit: edit your .theme file
13:48:15 <SamB> chessguy: how so?
13:48:17 <roconnor> Python goes through a large number of hoops to get comparisions between Integer and Float to work properly.
13:48:31 <Cale> glguy: well, I need to round or else the 3**200 will get coerced and they will end up equal, not demonstrating that loss :)
13:48:32 <chessguy> well, i'll have to do it recursively
13:48:48 <bdbit> glguy: directly in /usr/share?
13:48:49 <chessguy> which takes away some of the bit-twiddling speed
13:48:57 <SamB> chessguy: how so?
13:48:59 <glguy> bdbit: probably in ~/.irssi
13:49:10 <glguy> bdbit: if you don't have one in there, copy the one from /usr/share to it
13:49:12 <SamB> which file is it in again?
13:49:25 <chessguy> well, isn't function-calling in haskell as expensive as in other languages?
13:49:27 <bdbit> glguy: ya :>
13:49:32 <bdbit> glguy: TY
13:50:09 <chessguy> i'm looking at the code at http://paste.lisp.org/display/28810
13:50:09 <Maddas> chessguy: As in which other languages? :-)
13:50:15 <glguy> Umm... wtf, my power company just called me and an automated voice told me that daylight savings time changes on saturday night
13:50:28 <bdbit> lol
13:50:31 <chessguy> crap, we're losing an hour this weekend?
13:50:44 <glguy> spring forward
13:50:46 <glguy> fall back
13:50:49 <chessguy> oh!
13:50:49 <glguy> I think we get an hour
13:50:54 <chessguy> sweet
13:51:08 <Cale> Yeah, I could use that
13:51:19 <Cale> My hours are really messed up :)
13:51:22 <chessguy> SamB, you agree it has to be done recursively?
13:51:29 <tibbe> we definatly get an hour!
13:51:31 <SamB> chessguy: indeed not!
13:51:31 <bdbit> "please adjust your UPS; because of technical difficulties we will be unable to provide electricity to you in the hour that is lost"
13:51:39 <Cale> I went to bed around 7am and woke up at 10:30am today :)
13:51:44 <chessguy> hmmm. how would you do it non-recursively?
13:51:52 <bdbit> Cale: you're hardcore X_X
13:51:57 <glguy> bdbit: and in the spring, they double the voltage on the line for 1 hour? :)
13:52:04 <bdbit> glguy: probably :D
13:52:08 <bdbit> power is cheaper then, anyways
13:52:11 <Cale> bdbit: the previous day, I slept in until 5pm :)
13:52:18 <bdbit> Cale: oh :D
13:52:54 <SamB> chessguy: hmm. it might not be pretty.
13:53:05 <glguy> I think that they are trying to recover their corporate image after half the city lost power for up to over 1 week in a bad storm this year
13:53:09 <chessguy> this time, fast trumps pretty
13:53:22 <SamB> yeah.
13:53:42 <SamB> I suppose tailcalls would be reasonable...
13:53:52 <chessguy> @hoogle tailcall
13:53:53 <lambdabot> No matches found
13:54:12 <chessguy> you mean tail recursion
13:54:16 <chessguy> ?
13:54:29 <bdbit> glguy: perhaps they invested in "less arcane" technolog
13:54:30 <bdbit> +y
13:54:39 <SamB> it is only recursion if the function doing the calling might be called again in the process ;-)
13:54:42 <monochrom> Funny way to recover image.  Will they start phoning people up for weather forecasts too?
13:54:55 <dcoutts> @seen kowey
13:54:56 <lambdabot> I saw kowey leaving #haskell and #darcs 9m 28s ago, and .
13:55:10 <chessguy> hmmm, how do you figure?
13:55:23 <glguy> monochrom: they also give me a couple tips for saving energy over the winter, so that I odn't have ot pay them as much ... so nice of them
13:55:27 <SamB> well, maybe that isn't the way to go anyway.
13:55:28 <glguy> gave*
13:55:47 <lisppaste2> roconnor annotated #28810 with "bitLength" at http://paste.lisp.org/display/28810#1
13:56:24 <chessguy> huh? i don't see an annotation there
13:56:32 <roconnor> reload
13:56:34 <chessguy> oh, there it is
13:56:44 <roconnor> I wrote that in my project
13:56:50 <roconnor> I don't claim it is very good
13:57:16 <chessguy> what do you mean by bitLength?
13:57:16 <SamB> roconnor: I bet they have a nicer one in here
13:57:32 <tibbe> what's the length of a bit??
13:57:40 <mauke> 0.125
13:57:40 <SamB> /    // this version avoids all if() statements:
13:57:40 <SamB> /    x = ( highest_bit(x) << 1 ) - 1;
13:57:40 <SamB> /    return  bit_count_01(x) - 1;
13:57:56 * SamB wonders where slashes come from???
13:57:59 <chessguy> i'm trying to write highest_bit right now
13:58:19 <chessguy> (and, eventually, lowest_bit)
13:58:20 <SamB> chessguy: no
13:58:25 <SamB> highest_bit_idx
13:58:30 <SamB> is what you are trying to do!
13:58:34 <chessguy> well, yes, ok
13:58:49 <SamB> oh, I get it
13:58:55 <SamB> those slashes were supposed to be //s
13:58:55 <roconnor> chessguy: lower y && upper y
13:59:09 <tibbe> how come there such a mix of camelCase and under_score used by haskellers?
13:59:14 <SamB> they are three comment lines from the function you pasted ;-)
13:59:21 <chessguy> roconnor, what about that expression?
13:59:36 <roconnor> that's what bitlength searches for
13:59:42 <roconnor> a y satisfying that
13:59:46 <bdbit> interesting question, tibbe
14:00:04 <chessguy> i don't see how that's relevant to finding the highest bit set
14:00:06 <roconnor> aka a y such that (1 `shiftL` (y-1)) <= x (1 `shiftL` (y-1)) <= x
14:00:10 <roconnor> oops
14:00:10 <SamB> chessguy: anyway, I highly recommend a branch-free version of this ;-)
14:00:14 <monochrom> camelCase is also javaCase is also probably pascalStyle
14:00:17 <dcoutts> tibbe, people coming from different traditions I guess.
14:00:23 <SamB> oh, and maybe you should use * and `div` rather than shifts...
14:00:26 <roconnor> aka a y such that (1 `shiftL` (y-1)) <= x < (1 `shiftL` y)
14:00:51 <tibbe> dcoutts, but one usually wins out, I mean I write Java at work but that doesn't mean I camelCase my Ruby
14:01:13 <dcoutts> tibbe, I mostly see camlCase
14:01:20 <monochrom> Haskell people don't care about winning. :)
14:01:24 <glguy> pascalCaseIsGoodEnoughForLibrariesAndItsGoodEnoughForYou
14:01:42 <glguy> monochrom: those are the words of a loser ;)
14:01:47 <roconnor> But I wrote this code for Integers, rather than Word64
14:01:48 <tibbe> it's the mix that upsets my sense of beauty
14:01:53 <Maddas> monochrom: funny enough, I think it would be caml_case if it were caml from O'Caml ;-)
14:01:58 <bdbit> hmmm
14:02:29 <chessguy> hmm, i'll have to play with this. i like they're algorithm, it's just a matter of implementing it easily in haskell
14:02:38 <monochrom> Oh yeah, it's camel_case.  Well I'm relying on somethine else.
14:02:40 <glguy> wait.. is it PascalCase and camelCase?
14:02:42 <chessguy> s/easily/efficiently/
14:02:57 <tibbe> I want my bikeshed blue
14:03:17 <tibbe> but now I got this chessboard color
14:03:25 <bdbit> I can't manage to color my messages
14:03:28 <chessguy> !
14:03:51 * glguy just uses a different color on his nick
14:04:09 <glguy> bdbit: have you seen the ash theme?
14:04:20 <bdbit> glguy: no
14:04:35 <glguy> http://www.irssi.org/themefiles/ash.theme
14:04:48 <bdbit> glguy: on my main pc, like 1.5 years ago, I had my messages in turquoise... that REALLY helps readability
14:04:57 <bdbit> cause the eyes have some "i have already read that" hook
14:05:05 <glguy> ah
14:05:05 <chessguy> so x `shiftR` y is the same as x / (2^y) right?
14:05:18 <monochrom> Yes
14:05:23 <glguy> http://www.irssi.org/themefiles/thumb/t_ash.png
14:05:26 <lambdabot> http://tinyurl.com/ylxmg4
14:05:28 <glguy> if you don't want ot install it yet
14:05:47 <glguy> that screenshot doesn't show the person typing though
14:05:50 <glguy> so i guess that doesn't help
14:05:56 <roconnor> @scheck \x y -> x :: Integer `shiftR` (y :: Int) == x / (2^y)
14:05:56 <lambdabot>  Parse error
14:05:57 <glguy> but your lines are differentiated
14:05:59 <bdbit> i like the default theme a lot. I'd just like to have the whole message in Yellow for highlights and to have mine in turquoise
14:06:06 <glguy> ah
14:06:09 <roconnor> @scheck \x y -> shiftR (x :: Integer) (y :: Int) == x / (2^y)
14:06:10 <lambdabot>  add an instance declaration for (Serial Integer)
14:06:11 <lambdabot>   In the definition of `...
14:06:16 <roconnor> @scheck \x y -> shiftR (x :: Int) (y :: Int) == x / (2^y)
14:06:16 <lambdabot>  add an instance declaration for (Fractional Int)
14:06:23 <roconnor> @scheck \x y -> shiftR (x :: Int) (y :: Int) == div x (2^y)
14:06:24 <lambdabot>  Exception: Prelude.^: negative exponent
14:06:25 <bdbit> it should be simple enough
14:06:25 <glguy> I like when the timestamps are not the same as the text
14:06:29 <bdbit> but it doesn't do it
14:06:35 <roconnor> @scheck \x y -> shiftR (x :: Int) (y :: Int) == div x (2^^y)
14:06:35 <lambdabot>  add an instance declaration for (Fractional Int)
14:06:37 <bdbit> yeah, the timestamps don't need to be
14:06:45 <bdbit> but the other part of the message should
14:06:47 <bdbit> not only the nick
14:06:52 <glguy> but default theme makes lots of stuff the same color
14:06:56 <bdbit> that's not horizontal enough for me ;>
14:06:57 <glguy> (text, times, nicks)
14:06:58 <bdbit> yeah
14:07:11 <bdbit> horizontal bars are very important in chatting IMHO
14:07:18 <bdbit> in webchats they did that unknowingly
14:07:21 <roconnor> @scheck \x y -> fromIntegral (shiftR (x :: Int) (y :: Int)) == x / (2^y)
14:07:21 <lambdabot>  add an instance declaration for (Fractional Int)
14:07:26 <bdbit> by enabling people to choose colors
14:07:34 <emu> oh man: ghc-6.6: failed to create OS thread: Cannot allocate memory
14:07:46 <emu> long running ghci process
14:07:46 <glguy> bdbit: quote from default.theme
14:07:47 <glguy>   # Example1: You want the message text to be green:
14:07:47 <glguy>   #  ownmsgnick = "{msgnick $0 $1-}%g";
14:07:49 <roconnor> @scheck \x y -> fromIntegral (shiftR (x :: Int) (y :: Int)) == (fromIntegral x) / (fromIntegral (2^y) :: Rational)
14:07:50 <edwardk> i tend to prefer the _ separation if only for the psycholinguistic reason that our eyes are better at parsing out the words and read it faster than camelCapped code.
14:07:51 <lambdabot>  Exception: Prelude.^: negative exponent
14:07:57 <roconnor> @scheck \x y -> fromIntegral (shiftR (x :: Int) (y :: Int)) == (fromIntegral x) / (fromIntegral (2^^y) :: Rational)
14:07:58 <lambdabot>  Add a type signature
14:08:01 <bdbit> glguy: oh, i think i misunderstood the syntax
14:08:04 <bdbit> I'll try that
14:08:06 * roconnor sigh
14:08:17 <edwardk> though for that, i think the xml/scheme folks have it right with allowing real -'s in identifiers
14:08:46 <bdbit> it doesn't do the least bit
14:08:48 <bdbit> oh
14:08:49 <roconnor> @scheck \x y -> fromIntegral (shiftR (x :: Int) (y :: Int)) == ((fromIntegral x) / (2^^y) :: Rational))
14:08:49 <lambdabot>  Parse error
14:08:50 <bdbit> now it does
14:08:51 <SamB> that wouldn't fit the Haskell syntax very well though
14:08:55 <roconnor> @scheck \x y -> fromIntegral (shiftR (x :: Int) (y :: Int)) == ((fromIntegral x) / (2^^y) :: Rational)
14:08:56 <Maddas> edwardk: I agree..
14:08:57 <lambdabot>   Failed test no. 3. Test values follow.: -1, 1
14:09:15 <fasta> Anyone into C++ by accident?  How can I found out what <something of type ifstream> >> <variable of type int> does?
14:09:21 <SamB> we'd have to forbid ops ajdacent to non-op identifiers
14:09:27 <chessguy> > 18446744069414584320 :: Integer
14:09:29 <lambdabot>  18446744069414584320
14:09:30 <mauke> fasta: by reading the manual :/
14:09:33 <roconnor> @scheck \x y -> (shiftR (x :: Int) (y :: Int)) == trunc ((fromIntegral x) / (2^^y) :: Rational)
14:09:34 <lambdabot>  Not in scope: `trunc'
14:09:37 <roconnor> @scheck \x y -> (shiftR (x :: Int) (y :: Int)) == truncate ((fromIntegral x) / (2^^y) :: Rational)
14:09:39 <lambdabot>   Failed test no. 3. Test values follow.: -1, 1
14:09:50 <monochrom> I'm into C++ by accident XD
14:09:52 <roconnor> > shiftR -1 1
14:09:53 <lambdabot>  add an instance declaration for (Num (t -> a -> Int -> a))
14:09:55 <fasta> mauke: what manual? I only see a bunch of random webpages.
14:09:59 <edwardk> samb: yeah, well, i'm currently allowing it in my pet project, coz i have a simpler identifier rule, that allows any string of symbols (modulo certain ones for , () [], etc) to be used as an identifier with the first character telling you if its infix or prefix.
14:10:02 <mauke> yeah, you need a good book
14:10:03 <roconnor> > shiftR (-1) 1
14:10:04 <lambdabot>  Add a type signature
14:10:08 <roconnor> > shiftR (-1) 1 :: Int
14:10:09 <mauke> fasta: do you know scanf?
14:10:10 <lambdabot>  -1
14:10:27 <bdbit> glguy: I'm getting it, I guess
14:10:28 <SamB> @scheck \x y -> (shift (x :: Int) (-y :: Int)) == truncate ((fromIntegral x) / (2^^y) :: Rational)
14:10:29 <roconnor> truncate (-1/2)
14:10:30 <lambdabot>   Failed test no. 3. Test values follow.: -1, 1
14:10:36 <SamB> @scheck \x y -> (shift (x :: Int) (y :: Int)) == truncate ((fromIntegral x) / (2^^y) :: Rational)
14:10:37 <roconnor> > truncate (-1/2)
14:10:38 <lambdabot>   Failed test no. 1. Test values follow.: -1, -1
14:10:39 <lambdabot>  0
14:10:46 <chessguy> crap. i thought i had figured out how to implement it, but that won't work
14:10:48 <edwardk> samb: lets me distinguish (- 1) and (-1) and use things like _|_ or -o
14:10:52 <fasta> mauke: Not inside out, but yes, it's familiar.
14:11:14 <edwardk> samb: but yeah that ship has sailed for haskell.
14:11:15 <mauke> fasta: >> is fscanf, more or less
14:11:17 <chessguy> there's gotta be an efficent way to do this
14:11:20 <monochrom> The >> operator of fasta is the input operator.  Read from the istream an int, store into the int variable.
14:11:23 <roconnor> @scheck \x y -> (shiftR (x :: Int) (y :: Int)) == floor ((fromIntegral x) / (2^^y) :: Rational)
14:11:24 <lambdabot>  Completed 100 test(s) without failure.
14:11:31 <roconnor> w00t
14:11:43 <monochrom> Example.  int x; cin >> x;  cout << x;
14:11:49 <SamB> roconnor: ah ;-)
14:12:00 <mauke> which is why no one should use >>, especially not for user input
14:12:06 <SamB> @check \x y -> (shiftR (x :: Int) (y :: Int)) == floor ((fromIntegral x) / (2^^y)
14:12:07 <lambdabot>  Parse error
14:12:08 <fasta> mauke: ?
14:12:16 <monochrom> >> is for college homework.
14:12:23 <SamB> @check \x y -> (shiftR (x :: Int) (y :: Int)) == floor ((fromIntegral x) / (2^^y) :: Rational)
14:12:25 <lambdabot>  OK, passed 500 tests.
14:12:35 <chessguy> sometimes state would be very nice to have :(
14:12:45 <roconnor> now we know it is true ;)
14:12:45 <edwardk> i do like that it lets me have three uses for the . though, A.B can be look for B in module A, A . B is function composition and A .getFoo () can be applying the infix operator .B to operands A and () giving something like a traditional oop syntax.
14:12:49 <mauke> it's token (not line) based, it doesn't interact well with getline(), error recovery is impossible
14:12:54 <Cale> chessguy: isn't that what the state monad is for? :)
14:13:10 <SamB> @check \x y -> abs y <= 32 ==> (shiftR (x :: Int) (y :: Int)) == floor ((fromIntegral x) / (2^^y) :: Rational)
14:13:12 <lambdabot>  OK, passed 500 tests.
14:13:13 <chessguy> i think that would be more overhead than its worth here
14:13:15 <SamB> @scheck \x y -> abs y <= 32 ==> (shiftR (x :: Int) (y :: Int)) == floor ((fromIntegral x) / (2^^y) :: Rational)
14:13:17 <lambdabot>  Completed 100 test(s) without failure.
14:13:22 <fasta> monochrom: That explains why lots of data formats start with the size...
14:13:39 <roconnor> @check \x y -> abs y <= 32 ==> (shiftR (x :: Int) (y :: Int)) == floor ((fromIntegral x) / (2^^y) :: Rational)
14:13:41 <lambdabot>  OK, passed 500 tests.
14:13:41 <fasta> mauke,monochrom: thanks
14:13:52 <chessguy> SamB, what did you mean earlier about not being recursion unless the function could be called within itself again?
14:13:54 <Cale> the overhead of using the State monad is deciding the order in which computations are performed, which is something you have to do if you have state regardless
14:13:54 <fasta> mauke: also please define "good book"
14:14:06 <bdbit> finally... it works again
14:15:02 <SamB> @wiseguy recursion
14:15:03 <lambdabot> Unknown command, try @list
14:15:03 <fasta> mauke: I already read the latest 'The C++ Programming Language'.
14:15:08 <chessguy> well, i don't WANT to have state. i'm just having a hard time figuring out how to do this efficiently without it
14:15:11 <SamB> @jargon recursion
14:15:14 <lambdabot> *** "recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:15:14 <lambdabot> recursion n. See {recursion}. See also {tail recursion}.
14:15:14 <lambdabot>  
14:15:27 <chessguy> cute :)
14:15:28 <mauke> fasta: yeah, that's what I have
14:15:28 <monochrom> Some people complains that scanf and >> etc. do not output elaborate error messages when a parse error is encountered.  They expect something like "expecting a digit at line 45 column 5".  The answer is that >> is for college homework.  In the real world you use Yacc or something.
14:15:28 <bdbit> see you people
14:15:32 <SamB> chessguy: I was hoping they'd have that definition ;-)
14:15:32 <mauke> fasta: http://jonatkins.org/fncpp/Resources
14:15:34 <lambdabot> Title: Resources - Freenode ##C++ Wiki
14:15:36 <glguy> recursion n. see recursion?
14:15:41 <glguy> OH
14:15:41 <SamB> @jargon tail recursion
14:15:42 <glguy> omg
14:15:44 <lambdabot> No match for "tail".
14:15:44 <glguy> dumb
14:15:44 <lambdabot>  
14:15:44 <lambdabot> *** "recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:15:44 <lambdabot> recursion n. See {recursion}. See also {tail recursion}.
14:15:45 <lambdabot>  
14:15:53 <SamB> @jargon "tail recursion"
14:15:55 <lambdabot> *** "tail recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:15:55 <lambdabot> tail recursion n. If you aren't sick of it already, see {tail
14:15:56 <lambdabot>   recursion}.
14:15:57 <lambdabot>  
14:16:08 <bdbit> LOL
14:16:11 <bdbit> nice.
14:16:19 <chessguy> so is tail recursion not too bad in terms of efficiency?
14:16:37 <mauke> define "efficiency"
14:16:40 <tibbe> it should equal normal iteration right?
14:16:42 <SamB> the occurence of {tail recursion} in the {recursion} entry is not an instance of tail recursion or even recursion, but it *is* a tailcall ;-)
14:16:54 <Maddas> tibbe: You _can_ compile it to normal iteration.
14:17:03 <tibbe> yes
14:17:08 <fasta> mauke: yes, I know that webpage. Always when I see C++ I think: Ok, what does that code?!?! I don't really have that when I see Haskell code.
14:17:10 <tibbe> basically a goto
14:17:31 <Maddas> tibbe: "Tail recursion" doesn't imply that this optimization is done, though.
14:17:33 <roconnor> tail recursion is efficient for strict functions
14:17:33 <SamB> tibbe: unfortunately GHC *always* goes with the goto and *never* with the iteration construct
14:17:41 <chessguy> what's a strict function?
14:17:50 <tibbe> Maddas: no, it describes the function
14:17:55 <SamB> a function that always uses an argument
14:17:57 <Maddas> tibbe: Right.
14:18:05 <Cale> chessguy: a function which always returns _|_ when passed _|_
14:18:39 <chessguy> so like highest_bit_indx 0 = 0
14:19:03 <chessguy> i have to make sure i do that?
14:19:44 <tibbe> I guess: return foo() would be a tail call in Java for example
14:19:45 <SamB> that might help GHC inline it
14:19:57 <tibbe> and return foo() + 1 wouldn't
14:20:27 <chessguy> oh well. i guess i can't expect too much efficiency in a functional language.
14:20:29 <SamB> actually...
14:20:35 <mauke> chessguy: yes, you can
14:20:37 <tibbe> hmm
14:20:45 <tibbe> or would that be a tail call to +
14:21:11 <tibbe> now I'm confused
14:21:12 <SamB> in C, "foo(); return;" is a tailcall if both functions (foo and the caller) have return type "void"
14:21:13 <chessguy> well, i can. i shouldn't
14:21:28 <uip> does haskell have a goto?
14:21:29 <roconnor> Don't we use CPS instead of tail call stuff?
14:21:42 * SamB for one has never heard of such a thing as too much efficiency
14:21:56 <SamB> roconnor: no
14:22:02 <roconnor> oh
14:22:20 <SamB> actually CPS depends on tailcalls anyway
14:22:21 <monochrom> If you play a shooting game, and the computer is acting too fast, it is too much efficiency.
14:22:59 <SamB> monochrom: that is not too much efficiency
14:23:27 <chessguy> @type (div)
14:23:29 <lambdabot> forall a. (Integral a) => a -> a -> a
14:23:40 <SamB> that is called a badly written game
14:24:11 <tibbe> I should really go to bed now, g'night
14:24:18 <SamB> (they are *supposed* to keep the gameplay going at a preset rate)
14:24:51 <SamB> of course, that doesn't help if you get so few FPS that you can't see properly...
14:25:35 <fasta> mauke: What do you do when you don't know what a certain (overloaded and templated) function does?
14:26:37 <roconnor> callCC reminds me a little of goto.
14:27:34 <monochrom> in c++, fasta?
14:28:00 <SamB> monochrom: does that question make any sense in any other language?
14:28:02 <fasta> monochrom: yes
14:28:15 <Cale> roconnor: that's not a coincidence
14:28:16 <monochrom> Well Haskell has overloading and templates too...
14:28:30 <mauke> fasta: I cry and stop using C++
14:28:36 <Cale> roconnor: considering that continuations were invented to describe the semantics of GOTO.
14:28:41 <SamB> monochrom: yes, but it also has *source code*. and the overloading is not too hard to track down.
14:28:44 <monochrom> If it's in the library, I read a book.  If it's not in the library, I ask the author.
14:29:37 <monochrom> Note that I'm a 19th Century person and I don't even think of looking up the web.  For some reason I am not missing anything for that.
14:31:27 <lisppaste2> chessguy annotated #28810 with "direct implementation" at http://paste.lisp.org/display/28810#2
14:31:36 <chessguy> i guess this is as good as it's gonna get
14:32:02 <chessguy> assuming i did all my bit-twiddling right
14:32:14 <roconnor> chessguy: you know about 0xffff notation right?
14:32:28 <chessguy> yeah, i just don't see much benefit to it
14:32:29 <SamB> heh
14:32:34 <SamB> um
14:32:41 <SamB> the bits are hard to see in decimal!
14:32:56 <roconnor> chessguy: 'cause everyone knows what 18446744069414584320 is
14:33:22 <chessguy> roconnor, you don't have to make fun of me
14:33:23 <fasta> chessguy: why not 2^16 then?
14:33:34 <chessguy> fasta: to save haskell having to compute that
14:33:41 <mauke> hahahaha
14:33:46 <fasta> chessguy: doesn't it optimize that?
14:33:47 <mauke> constant folding is hard!
14:33:58 <fasta> mauke: that's a joke, right?
14:34:07 <SamB> you might want to check for a 64-bit system before that first comparison...
14:34:13 <SamB> oh, and check /= 0
14:34:15 <SamB> not > 0
14:34:21 <mauke> yeah, even my shitty ploki interpreter does constant folding
14:34:23 <mauke> it's trivial
14:34:48 <SamB> chessguy: if you insist on constants, use hex
14:34:53 <chessguy> x is an integer, and it will always be 64 bits
14:34:54 <fasta> mauke: I know, I implemented it too.
14:34:57 <SamB> nobody can read those wierd things
14:35:16 <lucca> octal, rawr
14:35:20 <fasta> "x is an integer, and it will always be 8 bits"
14:35:21 <SamB> chessguy: you mean an Integer?
14:35:26 <chessguy> Integer, yes
14:35:43 <SamB> why not a Word64?
14:35:56 <chessguy> would that be better?
14:36:02 <SamB> it could easily be
14:36:05 <chessguy> @type Word64
14:36:06 <lambdabot> Not in scope: data constructor `Word64'
14:36:09 <SamB> it probably is not any worse
14:36:14 <SamB> it isn't imported here
14:36:18 <mauke> @kind Word64
14:36:18 <SamB> @hoogle Word64
14:36:19 <lambdabot> *
14:36:20 <lambdabot> Data.Word.Word64 :: data Word64
14:36:24 <SamB> or, wait.
14:36:27 <SamB> it is
14:36:32 <SamB> but isn't a data constructor ;-)
14:36:36 <chessguy> what's the benefit of using Word64
14:37:02 <SamB> it will likely be more efficient on 64-bit architectures
14:37:51 <SamB> oh, and btw, /= is easier to compute than the >, I think...
14:38:01 <chessguy> already changed
14:38:29 <roconnor> SamB: do you recall if GHC complies (1 `shiftR` 4) to a constant?
14:38:55 <SamB> roconnor: I do not recall
14:40:06 <roconnor> Ah found it, primOpRules: ...
14:40:11 <roconnor>     -- ToDo:    something for integer-shift ops?
14:40:23 <roconnor> right from the source
14:40:33 <SamB> mmm
14:40:39 <fasta> Undocumented code is so funny to read
14:40:57 <SamB> indeed it does not seem to ;-)
14:40:59 <fasta> With or without source code it's still impossible to make up what it does....
14:41:21 <fasta> (for anything non-trivial and having names like function1)
14:42:08 <lucca> or names like l1l1i0O0o___
14:42:30 <fasta> lucca: you are making that up, I hope
14:42:55 <SamB> too many Ls, Is, and Os, 0s, and 1s
14:42:56 <lucca> there are a number of code-obfusctors that emit horrors like that
14:44:32 <roconnor> Actually I'm not even sure that 2^16 will be evaluated at compile time
14:45:44 <fasta> Doesn't the C compiler do that optimization?
14:46:03 <roconnor> @hoogle (^)
14:46:05 <lambdabot> Did you mean: (^)
14:46:05 <lambdabot> Prelude.undefined :: a
14:46:05 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:46:18 <roconnor> yes I do mean that
14:46:45 <lisppaste2> chessguy annotated #28810 with "better?" at http://paste.lisp.org/display/28810#3
14:47:18 <SamB> fasta: have you seen the definition of ^?
14:47:24 <monochrom> This is baffling.  On the Haskell wiki, I type into the search box "brief", I get nothing.  I type into the search box "brief introduction", I get the expected hits.  This is why I am so against the whole idea of wiki.  First of all searching doesn't work.  Second of all when it works it makes no sense, violates all monotonicity assumptions.
14:48:12 <fasta> SamB: no, but I have seen an implementation to calculate the Integer logBase.
14:48:13 <SamB> sure
14:48:27 <fasta> monochrom: seconded
14:48:33 <SamB> blame the search algorithms on the idea of wikis...
14:48:46 <chessguy> SamB, is that an improvement?
14:49:13 <fasta> I think haskell.org has a wiki because it gets too little love of a real maintainer.
14:49:24 <SamB> chessguy: I suppose so
14:49:33 <fasta> There should be a website and a wiki (like it was a few years ago)
14:49:38 <monochrom> Yes I'm doing that blaming!  The whole idea of wiki is "let's use my homebrew search engine".
14:49:50 <SamB> monochrom: no
14:50:01 <SamB> the idea of wiki is to use *google* to find things
14:50:07 <SamB> or to click links
14:50:14 <SamB> not to use the crap in-built engine!
14:50:17 <roconnor> SamB how do I get GHC to output GHC core?
14:50:56 <fasta> -fext-core ?
14:51:05 <SamB> that works but is ugly-looking
14:51:19 <SamB> but the other way is ill-named
14:51:36 <SamB> should be called -ddump-core
14:51:46 <fasta> -ddump-prep
14:51:48 <SamB> even if that might sound like a fancy way of saying "crash" ;-)
14:52:00 <fasta> "Dump prepared core"
14:52:38 <SamB> I mean, intuitively -ddump-core would mean "dump the last version of the module available in core"
14:53:05 <fasta> What does the first d mean?
14:53:05 <lisppaste2> roconnor pasted "GHC not doing constant folding" at http://paste.lisp.org/display/28819
14:53:21 <SamB> well, -d options are either debug or dump options
14:53:24 <SamB> I'm not sure
14:53:24 <fasta> roconnor: how depressing
14:53:40 <fasta> SamB: it must be debug then
14:54:02 <fasta> SamB: since "dump" in ddump already says "dump" ;)
14:54:06 <roconnor> that was compiled with -O2
14:54:14 <SamB> roconnor: you expect a lot, expecting it to do that for Integer...
14:54:21 <roconnor> Int
14:54:25 <SamB> Integer is still done with GMP
14:54:29 <roconnor> oh crap
14:54:32 <roconnor> I mean to write Int
14:54:57 <SamB> however
14:55:05 <SamB> it doesn't work any better with Int, here...
14:55:16 <lisppaste2> roconnor annotated #28819 with "Int" at http://paste.lisp.org/display/28819#1
14:56:03 <SamB> I've been looking at the --show-iface output, actually
14:56:07 <fasta> I don't think the Stalin compiler for Scheme does that...
14:56:10 <roconnor> where is Yhc -O when you need it.
14:56:10 <chessguy> SamB, hmm, this code isn't working
14:56:17 <SamB> chessguy: oh?
14:56:48 <roconnor> SamB, maybe -fext-core is preoptimisation ?
14:56:49 <chessguy> giving non-exhaustive cases
14:56:59 <SamB> roconnor: nope
14:57:29 <SamB> chessguy: add a | otherwise = 0
14:57:46 <SamB> I *think*
14:58:15 <chessguy> ah, that did it
14:58:26 <SamB> yeah, should work ;-)
14:58:48 <SamB> though I don't know if that is a very efficient way to do it
14:58:59 <chessguy> if you've got a better idea, i'm all ears
14:59:08 <SamB> really... because I don't know if either the Haskell or the C compiler is smart enough to skip the earlier cases...
14:59:12 <fasta> chessguy: do you need efficiency?
14:59:16 <chessguy> yes
14:59:44 <fasta> chessguy: what's the application?
14:59:50 <chessguy> this is going to be used at the core of a chess engine, which could call this function millions of times a second
14:59:52 <chessguy> easily
15:00:28 <SamB> do these numbers have a bit per chess piece on the board?
15:00:36 <chessguy> something like that
15:01:12 <fasta> Hmm, this would be an interesting "language comparison problem".
15:01:21 <chessguy> indeed
15:01:26 <fasta> or implementation if you are more precise
15:02:02 <chessguy> using 64-bit words, i can represent a position on the board using 13 Integers
15:02:04 <fasta> Getting it within a factor of 1.4 would be interesting to note, I think.
15:02:07 <chessguy> one for each type of pease
15:02:13 <chessguy> uh, piece
15:03:08 <fasta> I think the cache misses make sure you are not going to get that goal, however.
15:04:04 <chessguy> well, ultimately i don't plan on writing the chess engine in nearly the same way as most engines anyway
15:04:40 <fasta> chessguy: you are doing something with genetic algorithms in this project too?
15:04:48 <dcoutts> fasta, there still is a website and a wiki, it's just that more of the content is now in the wiki.
15:04:50 <chessguy> at some point
15:05:27 <chessguy> i plan on plugging pieces of the engine into the genetic programming framework i'm building
15:05:29 <fasta> dcoutts: by "website" I mean that it can be adjusted only by a hand full of people
15:05:42 <chessguy> at some point
15:05:47 <fasta> chessguy: I don't know of anyone who did it for chess.
15:05:53 <dcoutts> fasta, so do I.
15:05:55 <chessguy> who did what?
15:06:11 <fasta> chessguy: Use genetic algorithms to evolve strategies for chess
15:06:15 <chessguy> ah
15:06:17 <chessguy> you're right.
15:06:18 <dcoutts> fasta, there are still lots of 'website' bits hosted at haskell.org
15:06:24 <fasta> chessguy: For checkers it's "known".
15:06:40 <fasta> dcoutts: haskell.org/ghc, etc, you mean?
15:06:43 <dcoutts> fasta, haskell.org/<project> for many projects, eg gtk2hs, cabal, etc etc
15:06:48 <fasta> dcoutts: right
15:06:49 <chessguy> there was one paper done a couple years ago on evolving endgame players, but they still didn't do it the way i'd like to see it done
15:07:02 <fasta> chessguy: interesting project
15:07:16 <chessguy> it is. i think it's going to be a lot of fun
15:07:56 <chessguy> hopefully it will be successful and turn a lot of heads towards haskell and GP
15:09:29 <chessguy> it would be nice if it got me a ticket to grad school too :)
15:12:04 <chessguy> hmm, i killed the conversation
15:13:19 <SamB> I don't think so
15:13:23 <astrolabe> chessguy: have you seen tromp's go benchmark?
15:13:25 <SamB> I think it just sort of petered out
15:13:48 <chessguy> hmm, i don't know a lot about go AI, except that it's extremely hard
15:14:03 <chessguy> s/AI//
15:14:12 <astrolabe> He tried to convert it to haskell, but couldn't get it fast.
15:14:27 <astrolabe> I think because of using a binary encoding in Int64
15:14:29 <chessguy> interesting. do you have a link?
15:14:33 <SamB> he couldn't get it to go fast enough?
15:14:38 <SamB> does he have x86_64?
15:14:45 <astrolabe> I'll have a poke around.
15:14:56 <astrolabe> It was fast in C
15:14:59 <chessguy> i have a 64-bit architecture. which is handy
15:15:10 <chessguy> was he trying to do AB?
15:16:41 <chessguy> lol, somebody screwed up
15:16:46 <chessguy> @google go haskell
15:16:49 <lambdabot> http://blade.nagaokaut.ac.jp/haskel/haskel-jp/index.shtml
15:16:49 <lambdabot> Title: go haskell-jp
15:17:38 <chessguy> hey, there's a city called haskell, TX
15:18:52 <sjanssen> hmm, what is this?
15:19:09 <chessguy> @babel en de what is this
15:19:10 <sjanssen> it looks like a mailing list archive about Haskell, in Japanese
15:19:17 <Botje> chessguy: also known as "the city that never changes"
15:19:18 <lambdabot>  was dieses ist
15:19:29 <chessguy> Botje, :)
15:19:34 <astrolabe> Ah, it was connect 4, not chess
15:19:43 <chessguy> lol
15:19:45 <chessguy> you said go
15:19:56 <SamB> heh
15:20:12 <SamB> can't remember the difference between chess, go, and connect four?
15:20:25 <chessguy> Go is to chess as connect four is to tic-tac-toe :)
15:21:45 <astrolabe> I know he's interested in both, I just misremembered which it was.
15:21:46 <chessguy> so...did you find a link?
15:21:59 <astrolabe> Not a helpful one
15:22:03 <chessguy> ok
15:22:13 <astrolabe> He is on here sometimes though, he might be worth talking to.
15:22:21 <chessguy> ok
15:22:39 <chessguy> i'll never remember his handle though :)
15:27:31 <fasta> astrolabe: Tromp uses really nice tricks :)
15:28:20 <fasta> I never had seen the CRT applied to anything else than cryptography.
15:29:39 <astrolabe> This is the best link I can find http://homepages.cwi.nl/~tromp/c4/fhour.html
15:29:41 <lambdabot> Title: The Fhourstones Benchmark
15:29:46 <astrolabe> What is the CRT?
15:30:03 <fasta> Chinese Remainder Theorem
15:30:29 <astrolabe> Ah.  How does he use that?  encoding positions?
15:32:53 <chessguy> did he use that for hashing?
15:33:03 <fasta> astrolabe: he uses it instead of bignums for the number of positions
15:34:10 <fasta> astrolabe: he credits someone else, however.
15:43:41 <Adamant> how do you import from ghci?
15:43:59 <Adamant> I want to import Parsec
15:44:13 <Lemmih> :m Text.ParserCombinators.Parsec
15:45:08 <Adamant> danke
15:46:26 <ikegami--> and also unload the module as follows >:m - Text.ParserCombinators.Parsec
15:46:53 <ikegami--> if you want
15:46:55 <kpreid> you can also refer to any symbol always with its qualified name
15:47:33 <kpreid> and if you frequently want to use a set of modules, you could write a file defining a module which imports them all and :load it - this will also give a shorter module list in your prompt
16:15:11 <mauke> @pl uncurry (,)
16:15:11 <lambdabot> id
16:20:51 <pzpz> trees in fp are so bizzare coming from a complete procedural background.
16:21:23 <dcoutts> they're much easier though :-)
16:22:23 * dcoutts goes back to hacking on the Gtk2Hs code generator (which consists mostly of manipulating tree data structures)
16:22:50 <Lemmih> Code generator?
16:23:06 <dcoutts> the Gtk2Hs code is semi-automagically generated
16:23:15 <dcoutts> as are the docs
16:29:34 <pzpz> I agree, easier
16:30:17 <chessguy> well, trees are inherently recursive
16:32:13 <dcoutts> Lemmih, btw, what have you been up to recently? Still contracting on the happs stuff?
16:39:19 <Adamant> Haskell on embedded
16:39:24 <Adamant> is it done?
16:40:17 <Lemmih> dcoutts: Nah, working for a religious institute now.
16:40:58 <dcoutts> Lemmih, oh ? In a technical capacity or a religious one? ;-)
16:42:05 <dcoutts> there was an item on the radio here the other day about churches getting into podcasting
16:42:07 <Lemmih> I'm writing a web-application to show booking information for their seminars.
16:42:33 <dcoutts> Lemmih, using HApps?
16:42:50 <Lemmih> dcoutts: Nah, hxweb+fastcgi.
16:43:04 <dcoutts> @where hxweb
16:43:04 <lambdabot> I know nothing about hxweb.
16:43:28 <dcoutts> Lemmih, so managing to get Haskell in there somewhere :-)
16:43:57 <Lemmih> @where+ hxweb http://darcs.haskell.org/~lemmih/hxweb
16:43:58 <lambdabot> Done.
16:44:10 <dcoutts> Lemmih, you beat me to it :-)
16:44:32 * dcoutts was just about to @where+ hxweb ...etc
16:44:32 <Lemmih> dcoutts: Haskell is so much more fun than PHP.
16:44:39 <dcoutts> I know! :-)
16:44:48 <dcoutts> I did an in-house app with php once
16:45:02 <dcoutts> simulating closures is no fun
16:45:25 <mauke> haha, just use create_function
16:46:04 <dcoutts> I was trying to make a system of reusable cell renderers for generating html from tables of data
16:46:11 <dcoutts> but it got really ugly
16:46:31 <dcoutts> especially without types to stop you making mistakes.
16:46:50 <monochrom> Horror!
16:46:58 <dcoutts> quite
16:47:09 <monochrom> I'm referring to DRMacIver entering :)
16:47:15 <mauke> or scoping, or any kind of functional abstraction
16:47:16 <dcoutts> ha hah hah
16:47:17 <astrolabe> dcoutts: I've just downloaded Gtk2Hs
16:47:25 <dcoutts> astrolabe, cool
16:47:46 * dcoutts wonders if he's about to get a bug report...
16:47:51 <astrolabe> I get a window saying this version of gtk2hs requires ghc version 6.2.2 or 6.4.1
16:47:55 <dcoutts> yep
16:47:56 <dcoutts> :-)
16:48:05 <astrolabe> does this mean I shouldn't get ghc 6.6?
16:48:25 <astrolabe> (I currently have 6.4)
16:48:29 <dcoutts> astrolabe, yes, that's what it means. Binary builds really do need the version of ghc they were built with.
16:48:43 <monochrom> Can one build gtk2hs against 6.6?
16:48:53 <dcoutts> monochrom, yes, the darcs version.
16:48:57 <monochrom> (Of course, "one" means me.)
16:48:59 <dcoutts> astrolabe, so you need ghc-6.4.1 or if you grab my other binary build then you can use 6.4.2
16:49:25 <astrolabe> dcoutts: but some other library might need some different version of ghc.
16:49:51 <dcoutts> astrolabe, yep, the binary compatibility requirements of ghc are a pain.
16:50:16 <dcoutts> astrolabe, if you need another version then you'll have to build from source.
16:50:43 <astrolabe> dcoutts: Can you give me some idea of how much hassle that might be for an incompetent?
16:50:53 <dcoutts> astrolabe, more than it's worth I expect.
16:51:01 <dcoutts> astrolabe, can't you use 6.4.2 ?
16:51:19 <dcoutts> astrolabe, I will make a new build for 6.6 when we release Gtk2Hs next.
16:51:26 <Bobstopper> Where's the binary build for 6.4.2?
16:51:27 <dcoutts> but that's a few weeks off yet.
16:51:40 <astrolabe> I could, but it seems wrong to change my compiler version for a bit of software that I just want to try out
16:51:44 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.exe
16:51:46 <lambdabot> http://tinyurl.com/y9cc2s
16:51:54 <dcoutts> Bobstopper, ^^
16:51:59 <Bobstopper> arigato
16:52:00 <dcoutts> astrolabe, I do see your point.
16:52:31 <dcoutts> astrolabe, it is possible to have multiple versions of ghc installed at once.
16:52:58 <astrolabe> I can see that you don't want to have a big table of executables indexed by ghc version and gtk version.
16:53:12 <dcoutts> yeah since I have to build them all
16:53:18 <dcoutts> which means finding a windows machine
16:53:47 <dcoutts> so I typically support two common versions at once
16:53:58 <dcoutts> eg the last binary build did 6.4.1 and 6.2.2
16:54:07 <dcoutts> but as you noticed, time has moved on since then
16:54:18 <astrolabe> Is it the kind of thing that could be done with a batch file?
16:54:34 <dcoutts> yes, I have scripts
16:54:43 <Bobstopper> "your ghc or gtk install is messed up" :P
16:54:53 <Bobstopper> bbl - breakfast with the wife
16:56:48 * dcoutts wishes he could get someone else to support Gtk2Hs on windows
16:57:02 <astrolabe> what would it involve?
16:57:18 <dcoutts> being able to build it from source and improving the installer
16:57:44 <dcoutts> the installer uses Inno Setup
16:57:49 <astrolabe> I suspect I couldn't improve the installer
16:58:00 <dcoutts> which is free software using pascal as the scripting language
16:58:27 <astrolabe> It's 20 years since I've used pascal!  God I'm old.
16:58:34 <dcoutts> heh
16:58:59 <dcoutts> not that it has to use that, but that's what I found that was free and scriptable
17:00:01 <dcoutts> I can't use any of the windows installer ones because I don't have admin access on any windows box.
17:00:31 <astrolabe> Are you at a university?
17:00:34 <dcoutts> aye
17:00:48 <astrolabe> I never see anything but windows boxes.
17:01:08 <dcoutts> We've got one somewhere that I can log into with rdesktop
17:01:21 <dcoutts> a win2k3 box with 2-cpus
17:01:32 <dcoutts> which speeds builds up a little
17:01:57 * astrolabe gets ghc6.6
17:03:53 <dcoutts> ooh, gtk+ 2.10 binary builds are finally available on windows.
17:08:58 <x3m> dcoutts do you run haskell and hs-plugins in win also?
17:09:11 <dcoutts> x3m, no
17:09:22 <dcoutts> I only use windows to build Gtk2Hs
17:09:25 <astrolabe> grrr I can't seem to find a windows build of GTK+
17:09:39 <dcoutts> astrolabe, the gtk2hs site has the links
17:10:06 <astrolabe> to this page? http://www.gtk.org/download/
17:10:08 <lambdabot> Title: GTK+ - Download
17:10:24 <dcoutts> astrolabe, http://haskell.org/gtk2hs/download/
17:10:25 <lambdabot> Title: Gtk2Hs Â» Download
17:10:35 <dcoutts> links to the glade2in32 sourceforge download
17:10:42 <dcoutts> gladewin32
17:10:55 <dcoutts> ie http://sourceforge.net/project/showfiles.php?group_id=98754&package_id=111411
17:10:57 <lambdabot> http://tinyurl.com/y6xesf
17:11:43 <astrolabe> Do I want the dev version?
17:11:46 <dcoutts> yes
17:18:25 <orzo> the language benchmarks make clean look a lot better than haskel
17:18:41 * mwc chokes
17:18:45 <orzo> heh
17:18:53 <astrolabe> I'm having trouble with a dll, I'm going to restart and start again.
17:19:10 <astrolabe> They make C look better too.
17:19:31 <orzo> he ran off quick
17:20:09 <orzo> c is low level, as i understand haskel and clean are comparible
17:20:49 <mwc> C will always win benchmarks, as some sufficiently monkish hacker can tweak every last detail for the specific circumstances
17:21:05 <mwc> nobody ever does that in real life, so benchmark C isn't comparable to real world C, IMAO
17:21:40 <orzo> well they shouldnt use weird optimized c, they should use straight forward c
17:22:14 <dcoutts> they loose on code length if they do too much tweaking
17:22:30 <mwc> dcoutts, true
17:22:40 <Lemmih> When are they gonna install GHC-6.6 on the benchmark machines? Should we poke someone?
17:23:08 <dcoutts> we see this very clearly with the ByteString stuff, we wrote a straightforward C version, then optimised our ByteString implementation 'til we beat the C version, then wrote an uglier C version.
17:23:13 <mwc> we'll send somebody from #haskell over to their computer closet on a ninja install mission
17:23:27 <dcoutts> eventually we needed a really long ugly C version to beat the Haskell one liner
17:23:45 <dcoutts> Lemmih, oh, probably when ghc-6.6 is in gentoo :-)
17:24:04 <mwc> dcoutts, you have this process documented somewhere? I'd like to point that out to a few people
17:24:05 <dcoutts> which would be my responsibility :-)
17:24:10 <mwc> dcoutts, 6.6 isn't out on Gentoo yet?!
17:24:13 * Lemmih pokes dcoutts (:
17:24:17 <orzo> will 6.6 make a big change in the benchmarks?
17:24:29 <mauke> yes, it's 40 cakes faster
17:24:37 <dcoutts> mwc, it's in the overlay, but we're sorting things out so that every package still builds with ghc-6.4 and 6.6
17:24:38 <orzo> cakes?
17:25:14 <dcoutts> mwc, the ghc-6.6 ebuild is fine, but it's not much good if everything else borks.
17:25:37 <mwc> dcoutts, I understand. I had to rebuild a bunch of my haskell packages too. Darcs versions of everything
17:25:51 <dcoutts> mwc, as for the bytestring vs C, it's hinted at in the intro to our ByteString fusion paper.
17:27:50 * mwc plays with Cairo
17:27:57 <dcoutts> Lemmih, btw, you'll have to check the benchmark rules on libs. ghc-6.6 is now modular so they might say that you only get the core libs rather than everything we used to get.
17:28:33 <Lemmih> dcoutts: Oh, right.
17:28:45 <mwc> isn't it ghc-extra-libs or something?
17:28:51 <mwc> It sounds like it's still part of the compiler
17:28:59 <dcoutts> mwc, we don't provide a meta ebuild
17:30:08 <dcoutts> the extra-libs vs other-libs distinction is not supposed to be important
17:30:55 <mwc> dcoutts, that was my understanding too. It was separated to make building the most common stuff faster, wasn't it?
17:31:23 <dcoutts> mwc, and because it being modular allows stuff to be upgraded easier etc
17:31:51 <dcoutts> it's the right way to go rather than having one massive collection of libs
17:32:15 <dcoutts> and it means ghc isn't held up by ALUT not building on Mac OSX or other similar things
17:33:23 * lispy says hi to #haskell
17:33:30 <lispy> how's code, peeps?
17:33:34 <Bobstopper> coi lispy
17:35:24 <chessguy> heya lispy
17:35:33 <jgrimes> hey lisppaste2
17:35:37 <jgrimes> er. lispy even
17:35:38 <jgrimes> :)
17:35:41 * lispy thinks it's time to upgrade his codegen monad to handle errors
17:35:47 <jgrimes> lisppaste2 isn't very chatty :)
17:35:51 <lispy> heh
17:35:56 <lispy> i bet i have more lines than lisppaste2 anyway
17:36:01 <lispy> ?where ircstats
17:36:01 <lambdabot> I know nothing about ircstats.
17:36:04 <lispy> ?where stats
17:36:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
17:36:43 <lispy> yup, i'm #14 overall and lisppaste2 isn't on the list
17:36:46 <lispy> huzzah!
17:37:33 <lispy> oh wow, i'm catching up with Cale and Igloo
17:37:34 <xerox-> hiya
17:37:37 <lispy> hey
17:37:41 <xerox-> how's things?
17:37:47 <jgrimes> if I have some code (the DoCon library specifically) that uses Data.FiniteMap, whats the easiest way to get this working on 6.6?
17:37:47 <lispy> i bet soon, i'll be well known in here too
17:37:52 <lispy> xerox-: not bad, just got off work
17:37:58 <lispy> xerox-: so it's time to do some coding :)
17:38:03 <xerox-> I've been in Google London today :)
17:38:10 <lispy> xerox-: whoa!
17:38:13 <lispy> xerox-: what fer?
17:38:18 <xerox-> SoC students meeting
17:38:23 <xerox-> t has been fun
17:38:27 <lispy> jgrimes: iirc, it's now Data.Map, but i could be wrong
17:38:34 <xerox-> That's right
17:38:38 <lispy> xerox-: cool, where you a mentor?
17:38:49 <xerox-> nope, a student, it was a student meeting
17:38:54 <jgrimes> lispy, yeah, but that doesn't help me get the library working without porting it
17:38:56 <jgrimes> :p
17:38:56 <lispy> ah
17:39:10 <xerox-> we had lightining talks and food, and visited the office
17:39:15 <xerox-> oh, and gadgets :D
17:39:20 <lispy> jgrimes: you can't just change the imports and recompile?
17:39:38 <jgrimes> some of the functions changed too, they often ended in FM
17:39:38 <lispy> xerox-: what was your project?
17:39:50 <xerox-> lispy: cabal-get
17:40:00 <lispy> xerox-: nice
17:40:07 <lispy> xerox-: i can't wait till that is mainstream
17:40:12 <xerox-> it'll be
17:40:29 <lispy> xerox-: is it part of cabal then?
17:40:32 <xerox-> yeah
17:40:35 <lispy> nice
17:40:37 <lispy> cabal++
17:40:45 <xerox-> after the thing we went to some but, and there was MadDog
17:40:55 <xerox-> hehe
17:41:06 <xerox-> en.wikipedia.org/wiki/maddog I think
17:41:36 <Adamant> > "1" ++ "2"
17:41:37 <lambdabot>  "12"
17:42:01 <Adamant> ah, so > is the literate Haskell notation?
17:42:18 <lispy> Adamant: you could think of it that way
17:42:18 <xerox-> ?run 1+1
17:42:20 <lambdabot>  2
17:42:37 <Adamant> ?eval 1+1
17:42:45 <xerox-> eval is silenced
17:42:47 <lispy> heh, i don't get ?eval
17:42:50 <lispy> ?help eval
17:42:50 <lambdabot> eval. Do nothing (perversely)
17:42:52 <lispy> oh, right
17:43:00 <lispy> because it conflicts with a perl bot
17:43:02 <xerox-> ?where hnop
17:43:03 <lambdabot> http://semantic.org/hnop/
17:43:10 <Adamant> ah.
17:43:39 <lispy> and if it didn't exist as a command then lambdabot would ask what you meant
17:43:48 <lispy> so by having it as a silent command they don't fight
17:45:20 <dwm> ?type ($!)
17:45:22 <lambdabot> forall b a. (a -> b) -> a -> b
17:45:50 <lispy> i wish things didn't change so much when ghc upgrades
17:46:05 <lispy> Data.Map is a better name, but it's annoying to have to change old code
17:47:34 <dcoutts> xerox-, hello!
17:47:36 <jgrimes> yeah, I guess I'm just going to change it to Data.Map
17:47:51 <xerox-> hey duncan
17:48:09 <xerox-> dcoutts: i was saved by some new zeland linux people
17:48:15 <xerox-> phew :)
17:48:20 <dcoutts> xerox-, heh, how ?
17:48:25 <lispy> xerox-: are you from .au too?
17:48:32 <xerox-> nope i'm italian
17:48:37 <dcoutts> xerox-, how's it going ? still planning on Monday ?
17:48:54 <xerox-> dcoutts: t's going nicely. yes, i think so
17:49:00 <dcoutts> great
17:49:26 <xerox-> i'm playing with those spheres and magnetic links toy google gave to us hehe
17:49:53 <dwm> What does 'primitive' mean in a definition?
17:50:56 <lispy> so i have, this as my monad |ReaderT e (WriterT [Instruction] Unique) a|, and i want to add ErrorT to handle errors, so i need this? |ReaderT e (ErrorT String (WriterT [Instruction] Unique)) a| ?
17:51:00 <monochrom> It's provided by the compiler/interpreter
17:52:11 <dwm> I see, it seems to be only on type definitions. I'm poking around the Prelude source.
17:52:33 <dcoutts> dwm, I think hugs uses it for a few primitive functions too.
17:52:58 <dcoutts> dwm, it's just a Hugs98 thing. Other compilers use different mechanisms.
17:53:15 <dwm> Ok. Thank you.
17:53:19 <xerox-> well let's have some sleep
17:53:21 <xerox-> g'night
17:53:27 <dcoutts> g'night xerox-
17:53:27 <dwm> xerox-: night
17:54:35 <dcoutts> lispy, that seems reasonable.
17:55:06 <dons> moin!
17:55:08 <Botje> heh.
17:55:13 <lispy> dcoutts: i guess my main question is, if the ErrorT is on the outside, then I get back either an error or a result right?
17:55:15 <Botje> the haskell solution to http://acm.uva.es/p/v1/108.html is _REALLY_ short.
17:55:17 <lispy> dons: moin
17:55:17 <lambdabot> Title: Maximum Sum
17:55:47 <dcoutts> lispy, yep
17:56:11 <dons> Botje: what puzzles are these?
17:56:11 <dcoutts> lispy, depending on what the writer is for, you might want that above the error.
17:56:17 <lispy> dcoutts: thanks, i now some type error, but i'll straighten that out by fiddling with parens and the 'a'
17:56:25 <dcoutts> g'morning dons
17:56:31 <dons> hey dcoutts
17:56:36 <lispy> dcoutts: the writing is how i accumulate the result of exec'ing the monad
17:56:50 <lispy> dcoutts: i accumulate the assembly instructions which get written to a file
17:56:59 <dcoutts> lispy, so if there's an error then you don't need the written output ?
17:57:08 <lispy> nope, it's garbage
17:57:20 <dcoutts> lispy, ok, then keep the error above the writer I think.
17:57:46 <Botje> dons: it's an archive of problems by the ACM
17:57:51 <dcoutts> lispy, one example of when you might want to do it the other way around is if you want to lazily report progress on a computation that might later fail.
17:57:54 <thetallguy> Hey folks, i need my memory refreshed on two references.
17:58:07 <lispy> dcoutts: ah, okay
17:58:19 <dcoutts> dons, was it all ok with the copyright forms and faxing etc ?
17:58:31 <thetallguy> 1: there was a page of examples of unix shell style programming in haskell posted recently
17:58:37 <dons> dcoutts: yes, afaik. i got it all in, and haven't heard any more.
17:58:45 <dcoutts> dons, ok, great.
17:58:53 <dons> Botje: might be interesting to post the solutions on the wiki?
17:59:11 <dons> thetallguy: yeah, 'simple unix tools'
17:59:18 <thetallguy> 2: some months ago there was a blog about monads that gave three examples and derived the pattern of monads from those examples.
17:59:20 <dons> ?google simple unix tools haskell
17:59:22 <lambdabot> http://haskell.org/haskellwiki/Simple_unix_tools
17:59:22 <lambdabot> Title: Simple unix tools - HaskellWiki
17:59:26 <dcoutts> thetallguy, http://haskell.org/haskellwiki/Simple_unix_tools
17:59:29 <lambdabot> Title: Simple unix tools - HaskellWiki, http://tinyurl.com/hekpb
17:59:36 <dcoutts> oh, dons beat me :-)
17:59:51 <dons> hmm, monad tutorials. thetallguy, check the haskell weekly news archive? sequence.complete.org ?
17:59:53 <thetallguy> Gotcha.  Found # 1
18:00:01 <thetallguy> That's the one.
18:00:11 <dons> hi thetallguy, btw :)
18:00:12 <thetallguy> I searched LtU and didn't find it.   Thanks
18:00:16 <thetallguy> Howdy.
18:00:19 <thetallguy> Back in AU?
18:00:23 <dons> yup
18:00:37 <thetallguy> ?localtime dons
18:00:39 <lambdabot> Local time for dons is Sat Oct 28 11:00:15 2006
18:00:43 <monochrom> Look for sigfpe (author) and "you could have invented monads too"
18:00:51 <dons> ah, that's probably it.
18:00:56 <thetallguy> Yes, that's the one.  Thanks
18:01:10 <thetallguy> I have a friend who swears he would work on haskell more...
18:01:15 <Botje> dons: i'll do that when I get to #10
18:01:21 <thetallguy> ...if he coud just get some foothold on the concepts.
18:01:21 <dons> ?google you could have invented monads and probably
18:01:24 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:01:25 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
18:01:43 <thetallguy> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:01:46 <thetallguy> Hah
18:01:46 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:02:24 <dons> thetallguy: also, perhaps, http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
18:02:26 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
18:02:35 <dons> (combines the unix stuff with the monad stuff)
18:03:50 <thetallguy> Forwarded.  Thanks very much.
18:04:25 <chessguy> that bot tutorial looks cool
18:04:51 <LordBrain> i am thinking of putting in a request to my local library here to buy a haskell book. It would be their first if they do. Suppose they only get to have one, which one would you recommend?
18:05:09 <thetallguy> Some time ago he had asked for a small web server implementation.  That bot should fill the gap.
18:05:26 <lispy> LordBrain: the report :)
18:05:41 <lispy> LordBrain: soe is popular with beginners, but i don't know if it's good, never seen it
18:05:52 <LordBrain> soe?
18:05:58 <lispy> school of expression
18:06:02 <LordBrain> oh
18:06:03 <thetallguy> It's good
18:06:05 <lispy> well, haskell school of expression
18:06:14 <Lemmih> LordBrain: The Craft of Functional Programming.
18:06:16 <LordBrain> i saw that in the list on the wiki
18:06:20 <thetallguy> but so is the other one of that vintage
18:06:30 <thetallguy> Craft of, as Lemmih says
18:07:24 <LordBrain> ok
18:08:11 <dons> "The Craft of 'Lemmih Says'", perhaps?
18:08:17 <thetallguy> lol
18:08:18 * Lemmih grins.
18:08:27 <lispy> heh
18:08:32 <thetallguy> Don't get ``The Haskell Road to Logic...'
18:08:39 <thetallguy> It's not that it is a bad book
18:08:48 <thetallguy> but it does not teach haskell
18:09:01 <LordBrain> ok
18:09:34 <thetallguy> dons: thanks for the recommendations on books you use in courses
18:10:05 <thetallguy> Amazon just delivered two new books from Benjamin Pierce, which look quite good
18:10:10 <dons> ah cool.
18:10:16 <dons> ?where plbook
18:10:16 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
18:10:18 <dons> also good
18:10:34 <thetallguy> Yes, I got that one at the same time.
18:10:42 <thetallguy> But amazon was not required.
18:11:03 <dons> so you have both TaPL's now?
18:11:16 <dons> that should set you up for a few days at least :)
18:11:18 <thetallguy> Pierce's book on Category Theory was not great.
18:11:22 <thetallguy> Yes
18:11:42 <thetallguy> Several months, at the glacial pace I go.
18:11:51 <thetallguy> ;-)
18:11:52 <chessguy> @hoogle isPrefixOf
18:11:53 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:11:55 <dons> now, just have to get 'Practical Haskell' out the door.. and we'll have the full story
18:12:15 <astrolabe> I'm trying to read tapl at the moment
18:12:16 <dons> I wonder if OReilly would publish a haskell book, and stick an amusing animal on the cover
18:12:21 <lispy> dons: is anyone writing it?
18:12:24 <astrolabe> I find some of his explanations unclear
18:12:29 <thetallguy> I sure hope so.
18:12:34 <dons> lispy: not that i know of. i have a top secret plan, but its only a plan
18:12:42 <thetallguy> There are a few people who's noses I'd like to ...
18:12:47 <thetallguy> Never mind.
18:13:04 <lispy> dons: i think someone in #lisp tried to get them to publish a lisp book (maybe Peter Seibel) but they say lisp as too risk (not enough users)...i wonder if they'd think that about haskell
18:13:26 <dons> hmm. but didn't they publish 'Practical OCaml' ?
18:13:48 <dons> ah no
18:13:48 <lispy> dons: maybe that's how they learned to be risk averse? ;)
18:13:49 <thetallguy> I'm sure they'll publish whatever they think will sell
18:13:57 <dons> yeah
18:14:15 <lispy> well, Peter's book did really well given the limited audience
18:14:30 <chessguy> hmm, i take it this tutorial is a work in progress?
18:14:37 <thetallguy> And I expect they also like new technology, because it means they can publish new books.
18:14:43 <dons> thetallguy, as long as its a dynamically typed, ill-specified language ;)
18:14:46 <SamB> chessguy: any that isn't is probably outdated ;-)
18:14:58 <dons> chessguy: which one?
18:14:59 <SamB> not that there is anything wrong with outdated tutorials
18:15:06 <chessguy> the bot one
18:15:15 <dons> no. its done. why? :)
18:15:19 <dons> finished it already?
18:15:26 <thetallguy> Funny how programmers include a lot of people who don't like math.
18:15:32 <chessguy> hmm
18:15:53 <chessguy> it's missing at least one import
18:15:59 <dons> oh, interesting, some books i've not seen, http://www.amazon.com/Practical-OCaml-Joshua-B-Smith/dp/159059620X
18:16:02 <SamB> thetallguy: indeed
18:16:03 <lambdabot> http://tinyurl.com/yhgd2f
18:16:12 <dons> chessguy: you looking at the 'full source' on its own page?
18:16:20 <dons> should work out of the box.
18:16:23 <chessguy> oh, no i'm just pasting pieces
18:16:39 <dons> ok. that method of interaction isn't supported, and may void your warranty
18:16:44 <SamB> oh.
18:16:52 <chessguy> hehe
18:16:56 <thetallguy> A colleague of mine told me yesterday that he listens to ``software engineering'' podcasts in the car
18:17:08 <SamB> oh no, chessguy can't go into the tech hall
18:17:17 <lispy> thetallguy: i think i'd confess other things before that....
18:17:18 <chessguy> it's clearly written to be used incrementally though
18:17:35 <dons> chessguy: yes. in hindsight i should have done that :)
18:17:51 <dons> and structured it in such a way that you apply the patches linearly
18:17:57 <dons> rather than at checkpoints, as it currently is
18:17:57 <thetallguy> I tried my best to be polite
18:18:06 <lispy> "Okay, it was me....i killed her...but...she was going to tell everyone I listen to software engineer podcasts in the car.."
18:18:10 <thetallguy> Turns out its some Java show.
18:18:15 <thetallguy> lol
18:18:19 <dons> scary
18:18:23 <thetallguy> Nice one lispy
18:19:00 <dons> ooh,
18:19:01 <dons> Programming in Haskell	
18:19:02 <dons> 	
18:19:02 <dons> Programming in Haskell by Graham Hutton (Paperback - Jan 31, 2007)
18:19:02 <dons> Buy new:  $45.00
18:19:04 <dons> Available for Pre-order
18:19:08 <dons> (draft is online, i think)
18:19:27 <dons> hmm. the haskell.org list is a bit out of date.
18:19:31 <lispy> someone needs to re-write onlisp as onhaskell
18:20:06 <chessguy> who's graham hutton?
18:20:07 <dons> lispy, you look like a good candidate to volunteer? !
18:20:14 <lispy> dons: i know!
18:20:19 <dons> chessguy: haskell academic
18:20:26 <chessguy> oh, he's not on here?
18:20:29 <lispy> dons: i mention it because i actually have been fantasizing about it
18:20:35 <dons> chessguy not that i know of.
18:20:43 <dons> lispy: do it!
18:20:57 <dons> prizes include fame , glory and a mystery cruise!
18:21:18 <lispy> sweet
18:21:26 <lispy> mystery cruises are the best
18:21:34 <thetallguy> java posse
18:21:35 <lispy> look at all the fun gilligan had
18:21:36 <dons> http://www.cs.nott.ac.uk/Department/Staff/gmh/bib.html
18:21:41 <lambdabot> Title: Graham Hutton: Publications, http://tinyurl.com/unhl5
18:22:07 <thetallguy> http://javaposse.com/
18:22:10 <lambdabot> Title: The Java Posse
18:22:11 <thetallguy> I can't goolk
18:22:13 <thetallguy> look
18:22:39 <dons> and gmh wrote "The Ruby interpreter (1993)"... ;)
18:22:48 <dons> i wonder if he should sue
18:23:00 <dons> 'Ruby is a relational calculus for designing digital circuits."
18:23:01 <thetallguy> snort
18:23:29 <dons> at least ask for a discaimer on the ruby website...
18:23:33 <dons> and all ruby materials
18:23:55 <dons> and when the ruby interpreter starts up, it should say "This is not the ruby interpreter"
18:24:01 <LordBrain> lol
18:24:55 <LordBrain> don's you recommending Hutton's book?
18:25:08 <LordBrain> sorry for that extra appostrophe
18:25:11 <chessguy> hey dons, can i try rearranging things on the bot tutorial page to make it more incremental?
18:25:17 <Cale> dons: that looks like something to post to reddit :)
18:25:18 <dons> haven't read it. its only for free though. so why not?
18:25:25 <dons> Cale: !
18:25:46 <dons> oooh, disinformation ... i love it
18:25:55 <dons> chessguy: yeah. go for it.
18:26:10 <dons> can you do it offline, so i can check the result?
18:26:15 <dons> or do you think it would be pretty easy to do?
18:26:41 <LordBrain> i only found the first 5 chapters available online
18:26:46 <LordBrain> as a preview
18:27:16 <dons> oh, this guy, http://www.cs.nott.ac.uk/~gmh/preview.pdf
18:27:19 <dons> ?
18:27:23 <LordBrain> yeah
18:29:37 <Cale> http://programming.reddit.com/info/o63e/comments
18:29:40 <lambdabot> Title: The Ruby Interpreter (reddit.com), http://tinyurl.com/yfont4
18:30:06 <thetallguy> dons: reading the Brief Introduction with an eye towards what a beginner would not understand...
18:30:07 <Cale> The best thing is, it's actually interesting and topical :)
18:30:12 <thetallguy> ...Prelude> let<font size="3"> y = 1Â : x  -- 'cons' the value 1 onto the list</font>
18:30:42 <thetallguy> That's not enough explanation of lists to prepare them for the pattern matching section that follows.
18:30:51 <lispy> er...you can use html tags in ghci?
18:31:41 <Cale> hey people, mod it up :)
18:31:45 <Cale> hehe
18:32:19 * dons mods
18:33:22 <dons> thetallguy: ah ok.
18:33:34 <dons> just privmsg me any notes, and i'll follow them up after breakfast
18:33:59 <dons> Cale: its currently #12
18:34:08 <lispy> how do i insert an assoc list into a Map?
18:34:09 <dons> right above "
18:34:15 <thetallguy> Will do
18:34:15 <dons>  
18:34:28 <dons> the dropping continutations item
18:34:34 <Cale> yeah
18:35:08 <lispy> ?hoogle Ord k => [(k,a)] -> Map k a -> Map k a
18:35:09 <lambdabot> No matches, try a more general search
18:35:15 <Cale> and beneath "Ruby isn't going to fracture, and "enterprise" is not synonymous with "static""
18:35:27 <dons> heh
18:35:48 <Cale> Does this count as fracturing?
18:35:52 <Cale> hehe
18:35:54 <dons> way way too much ruby material out there
18:36:11 <dons> for a language that, after 15 years, can't get threads or continutations right.
18:36:27 <chessguy> hmm, hard to decide how to rearrange this
18:36:29 <Cale> Ruby's been around for 15 years?
18:36:51 <lispy> i've said before it takes 15 years for a PL to catch on :)
18:36:54 <lispy> so i wouldn't doubt it
18:36:58 <dons> i think roughly since the mid 90s anyway?
18:37:14 <dons> python and haskell are the same age, aren't they?
18:37:19 <dons> and perl just a little older.
18:37:33 <Cale> With any luck, there will be enough people interested in declarative languages for the entry to get some points :)
18:37:35 <Adamant> a "Practical Haskell" would be interesting
18:38:05 <Adamant> I am still surprised Ruby hasn't added real continuations
18:40:04 <lennart> real continuations are tricky to implement efficiently
18:41:11 <dcoutts> Lemmih, btw, you can use Lazy.fromChunks Lazy.toChunks instead of Lazy.LPS
18:41:24 * dcoutts reads hxweb
18:46:10 <lispy> how does Data.Map behave when you have multiple copies and do unions and such?
18:46:31 <lispy> > Data.Map.lookup 1 (fromList [(1,1), (1,2)])
18:46:32 <lambdabot>  Not in scope: `fromList'
18:46:45 <lispy> > Data.Map.lookup 1 (Data.Map.fromList [(1,1), (1,2)])
18:46:46 <lambdabot>  Not in scope: `Data.Map.fromList'
18:46:55 <Lemmih> dcoutts: Neat, thanks.
18:47:28 <lennart> according to the documentation union prefers the left operand
18:47:50 <lispy> it seems to delete duplicate keys by updating over them...(according to my tests
18:48:05 <lispy> okay, that's bad, i don't think data.map is the right structure for me
18:48:34 <lispy> maybe i'm wrong, but this is for the symblo table that a compiler uses
18:48:37 <lennart> lispy: how about reading the docs?  it actually tells you what it does :)
18:48:51 <lispy> lennart: i'm looking at it
18:48:59 <lispy> lennart: but i dont' see that in there t all
18:49:09 <lispy> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
18:49:12 <lambdabot> http://tinyurl.com/ykdr3x
18:49:24 <lennart> update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
18:49:24 <lennart> O(log n). The expression (update f k map) updates the value x at k (if it is in the map). If (f x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y.
18:49:42 <lispy> i wasn't using update
18:50:16 <lispy> i was looking at fromList and union
18:50:39 <lennart> union :: Ord k => Map k a -> Map k a -> Map k a
18:50:39 <lennart> O(n+m). The expression (union t1 t2) takes the left-biased union of t1 and t2. It prefers t1 when duplicate keys are encountered, i.e. (union == unionWith const). The implementation uses the efficient hedge-union algorithm. Hedge-union is more efficient on (bigset union smallset)
18:50:49 <lennart> "left-biased"
18:51:20 <lennart> so what would you want to happen?
18:51:32 <lispy> i wanted something like a multiset i think
18:51:33 <lennart> you can get it with unionWith :)
18:51:52 <lennart> map each key to a set
18:51:59 <lispy> i have to think whether this actually causes a problem
18:52:12 <lispy> my regression tests pass
18:52:15 <lispy> but i'm not convinced
18:52:17 <EvilRanter> > (.) (.)
18:52:18 <lambdabot>  Add a type signature
18:52:23 <EvilRanter> @type (.) (.)
18:52:25 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
18:52:34 <lennart> but removing the old entry doesn't seem wrong for a symbol table
18:53:07 <lennart> @djinn (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
18:53:08 <lambdabot> f a b c d = a b (c d)
18:53:29 <lispy> well, doing that shadows the old value right?  but i think that ends up being okay because i extend the environment via Reader, so it should restort the old environment when the function is out of scope?
18:53:47 <lispy> s/restort/restore/
18:53:57 <lennart> yes
18:54:39 <lispy> in that case, i'm probably okay
18:54:57 <lispy> but i do wonder, if it's really left-biased, why does this happen:
18:55:02 <lispy> *Test Data.Map> assocs (fromList [(1,'a'), (1,'b')])
18:55:02 <lispy> [(1,'b')]
18:55:09 <lispy> because it uses a foldl?
18:55:44 <lennart> probably
18:55:48 <lispy> it seems that fromList is actually right biased
18:55:55 <lennart> yep
18:56:10 <lennart> the documentation is lacking for fromList
18:56:58 <lispy> my extensive testing passes, and this mostly makes sense as to why it should continue to work so i think i'll roll with it
18:57:53 <EvilRanter> euch...
18:58:05 * EvilRanter is using a lot of "(foo .) . bar"
18:58:43 <EvilRanter> @pl \x y -> negate (x * y)
18:58:43 <lambdabot> (negate .) . (*)
18:58:47 <EvilRanter> sorta thing
18:59:06 <lispy> i would prefer the former if i were reading the code :)
18:59:27 <EvilRanter> this is much tidier in context, imo
18:59:55 <lispy> ah, good i do have at least one test that fails when i switch the order of the union
19:00:07 <lispy> so that tells me that my test suite isn't completely useless :)
19:05:09 <lennart> lispy: what are you building?
19:05:44 <lispy> lennart: i'm following a tutorial to build a scheme compiler which i found from LtU.  The tutorial does it in scheme, but i'd rather do it in haskell :)
19:05:59 <lennart> oh, right!
19:06:06 <lispy> iirc, the papre is something like "Incremental Compiler Construction"
19:06:31 <lispy> my haskell-fu has increased muchly from using monad transformers, Cale got me started
19:06:43 <lennart> add some tests that do computation with church numerals.  it's good for testing your variable binding, etc
19:06:57 <lispy> hmm...that's not a bad  idea
19:07:21 <lispy> i have a lisp parser already built, i need to make it talk to the code generator
19:07:28 <lispy> then i can code up my test cases more easily
19:07:36 <chessguy> oy. brain fart. i use the keyword 'type' to alias one type to a simpler word, right?
19:07:41 <lispy> at least for those larger tests like church numerals
19:07:49 <lennart> chessguy: yes
19:07:55 <lispy> chessguy: yeah, it's like a typedef in C if that help
19:08:10 <lennart> except more powerful
19:08:15 <chessguy> ok, that's what i was thinking. but i didn't wanna mention that other language :)
19:09:19 <chessguy> ah, it was the = i was forgetting
19:12:16 <lispy> lennart: seems everything in haskell is more powerful :)
19:27:39 <LordBrain> "All hardware architectures in common use are optimized for strict languages, so the best compilers for non-strict languages produce slower code than the best compilers for strict languages." from http://en.wikipedia.org/wiki/Non-strict_programming_language
19:27:42 <lambdabot> http://tinyurl.com/y93e7u
19:27:45 <LordBrain> seems like a contentious claim
19:28:56 <dons> yeah, its bogus.
19:29:20 <dons> e.g. see the non strict Clean and Haskell code on the shootout
19:29:26 <EvilRanter> hm
19:29:45 <EvilRanter> "non-strict languages [...] slower"
19:30:09 <lispy> i read it as, if we optimized a CPU for non-strict languages we'd see even faster code from Haskell/Clean
19:31:04 <lispy> i can't figure out how to make my newtype an instance of monad error
19:31:36 <LordBrain> perhaps there are examples of where optimizations in cpus have assumed strictness to the detriment of non-strict language performance..
19:31:41 * Igloo shakes a stick at buildbot
19:32:06 <EvilRanter> lispy, i don't think type aliases can be instances
19:32:28 <Igloo> 'newtype' doesn't make type aliases, 'type' does
19:32:37 <EvilRanter> oh, right, yeah
19:32:39 <dons> what does it even mean? Are they suggesting built in thunk support in hardware? :)
19:32:40 <EvilRanter> never mind me
19:32:44 <lispy> hmm...i was able to derive it but i don't think the type is correct
19:32:53 <lispy> dons: sure
19:33:03 <lispy> dons: at least, that's how i interpret it
19:33:40 <lispy> from a hardware engineer's POV we have spent a lot of time/money optimizing computers to run traditional C style programs
19:33:45 <Igloo> . o O (GC co-pro on the right side of the memory bus?)
19:33:48 <lispy> compare a CPU to a GPU
19:33:49 <EvilRanter> well, build in lazy evaluation one-way or another
19:35:25 <lispy> i'm no hardware guy, but i have studied a little (enough to design a simple cpu) and so sometimes wonder what we'd get as results if we tried to push some of the 'slowness' of these really high level languages down into the hardware
19:36:29 <lispy> take java/c++ for example, what if we optimized them for constructor functions
19:36:36 <lispy> gave the cpu an instruction to help
19:36:42 <lispy> might get much faster OO
19:36:51 <lispy> but probably at the cost of something else
19:37:46 <SamB> lispy: what is your newtype?
19:37:47 <EvilRanter> eventually, if you make the processor instructions too high-level, a lower level will form under them
19:38:13 <lispy> newtype CodeGen e a = CodeGen (ReaderT e
19:38:14 <lispy>                                (WriterT [Instruction]
19:38:14 <lispy>                                 (ErrorT String Unique)) a)
19:38:25 <SamB> how about
19:38:34 <SamB> deriving (MonadError String)
19:38:38 <SamB> ?
19:38:53 <lispy> yeah, that seems to be good
19:38:55 <lispy> thanks
19:39:05 <lispy> i was really close, i had just tried MonadError (Either String)
19:39:16 <SamB> mmm
19:39:24 <dons> we don't have OO hardware either remember
19:39:31 <dons> though Java could probably do with some
19:39:39 <SamB> bah
19:39:46 <SamB> it could probably use better bytecode
19:39:52 <lispy> java could use a real garbage collector
19:39:59 <SamB> to go with better JVMs
19:40:34 <lispy> i bet sun would cease to exist if they broken backwards compatibilyt with the JVM right now :)
19:41:12 <lispy> well, either that or people would need HUGE incentive to upgrade
19:42:51 <lispy> you can only derive classes that come with ghc?
19:45:13 <dons> just for fun, I put the covers of the textbooks up, http://haskell.org/haskellwiki/Books_and_tutorials :)
19:45:16 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
19:45:56 <SamB> lispy: with -fglasgow-exts you can derive anything for newtypes
19:46:20 <SamB> (assuming the *last* argument is the one you want it to be in in the instance)
19:46:20 <lispy> SamB: i'm using that but it didn't seem to want to derive MonadUnique
19:46:27 <SamB> well.
19:46:31 <dons> ooh, its living on the edge. up mod! http://programming.reddit.com/info/o63e/comments
19:46:33 <SamB> assuming the *old* type has that instance
19:46:35 <lambdabot> Title: The Ruby Interpreter (reddit.com), http://tinyurl.com/yfont4
19:47:19 <lispy> SamB: ah, that's probably the problem then
19:47:31 <lispy> it's okay, the instance is realyl easy
19:47:32 <dcoutts> dons, nice book cover icons
19:47:58 * dcoutts -> sleep
19:48:27 <dcoutts> did you note the discussion earlier about pseq vs seq
19:48:38 <dons> no?
19:48:43 <dons> was it here? or on the mailing list?
19:48:44 <SamB> most if not all of the Haskell 98 derviable classes require *at the very least* that all field types have an instance of the class already
19:48:57 * dcoutts ponders the difference between: 'seq sleep dcoutts' and 'pseq sleep dcoutts'
19:49:08 <dcoutts> dons, on the mailing list
19:49:19 <SamB> dcoutts: the latter means you are sleeping while on IRC, duh!
19:49:33 <dcoutts> dons, on ghc-users and haskell-prime
19:49:37 <dons> ok
19:49:54 <dcoutts> SamB, hmm, I think the latter means I sleep first
19:50:05 <SamB> oh really?
19:50:14 <SamB> what does the "p" do then?
19:50:22 <SamB> because I think the *former* does that.
19:50:24 <dcoutts> I reduce sleep to weak head normal form before reducing myself to whnf
19:50:38 <dcoutts> seq apparently does not provide an ordering on evaluation
19:50:45 <SamB> oh?
19:51:00 <dcoutts> ie reduces both to whnf, but not in any particular order
19:51:05 <SamB> REALLY?
19:51:09 <dcoutts> yep
19:51:13 <dcoutts> read the emails
19:51:15 <SamB> that is crazy!
19:51:26 <newsham> hi
19:51:30 <SamB> they ought to rename (slowly, I suppose) pseq to realSeq!
19:51:33 <dcoutts> it's from a strict reading of the H98 standard
19:51:39 <SamB> oh, hah
19:51:43 <SamB> strict reading...
19:51:45 <dcoutts> actually, they're both useful
19:51:50 <SamB> its written in english for goodness sake...
19:51:56 <dcoutts> SamB, heh, didn't notice that pun
19:52:04 <SamB> I didn't either
19:52:16 <SamB> until after I had repeated it
19:52:26 <dcoutts> SamB, no, I think seq is fairly carefully defined in the standard, not just in words.
19:52:33 <SamB> oh?
19:52:41 <SamB> WTH do they call it "seq"?
19:52:49 <SamB> just to confuse people hopelessly?
19:52:51 <jgrimes> heh... from the DoCoN manual: "We hope, FiniteMap will become standard in future Haskell" Well, it is, but it isn't quite the same! =/
19:53:26 <SamB> jgrimes: I'm sure what they meant was that they hoped *a* mapping datastructure of the same kind would become standard in the future
19:53:44 <jgrimes> yeah, they used FiniteMap though, which is deprecated in 6.6
19:53:55 <SamB> I thought it was missing?
19:53:58 <jgrimes> well
19:54:00 <jgrimes> yeah, missing
19:54:04 <SamB> and deprecated in 6.4?
19:54:08 <jgrimes> yes, sorry :)
19:54:14 <SamB> which really is too quick to pull a module IMO
19:54:33 <SamB> or maybe they pulled it before 6.6
19:54:46 <jgrimes> well, it was in 6.2
19:55:19 <jgrimes> or "is in"*, rather
19:57:03 <LordBrain> hmm ghc takes a long time to compile huh?
19:57:36 <jgrimes> a nice little stint, yeah.
19:57:52 <LordBrain> i guess i should have grabbed a binary package
19:58:34 <LordBrain> is there a way to do distributed compiling with haskell?
19:58:38 <LordBrain> with ghc?
19:59:25 <lispy> LordBrain: well, i've never tried it, but if you could symlink gcc to distcc you might trick ghc into at least doing distributed compiling for the C it generates
19:59:49 <lispy> LordBrain: or even easier just set the gcc on the comandline to distcc
19:59:55 <dons> LordBrain: you can use distcc for the C builds
20:00:01 <LordBrain> hmmm
20:00:03 <dons> but its not common by any stretch
20:00:44 <LordBrain> well, i dont know if ghc itself compiles via c by default.. does it?
20:01:01 <LordBrain> er, i mean i dont know if it compiles itself that way by default
20:01:24 <LordBrain> in general it doesnt do that right? unless i tell it to
20:01:33 <lispy> dons: doesn't ghc compile to C by default when you ask for optimizations?
20:02:57 <LordBrain> i have one of those computers whose fan kicks into high gear or something when its working hard.
20:03:59 <LordBrain> i guess it does use gcc by default, because that's listed in my running processes
20:04:19 <LordBrain> oh well.. next time i do this i'll use distcc
20:04:54 <dons> lispy: I mean, when doing a .hc bootstrap build
20:05:03 <dons> and the entire src of ghc and the libraries is availabel as .c files
20:05:05 <dons> then you can use distcc
20:05:51 <lispy> dons: but i bet you could also run ghc with that one option -pgmc (or whatever) and tell it to use distcc
20:06:06 <lispy> to speed up all build
20:06:23 <lispy> (wel, obviously only builds that do -fvia-c
20:15:17 <glguy> Cardinals are 2 outs away from a world series victory!
20:17:45 <Patterner> Do we care?
20:21:27 <Pete_I> nope
20:21:35 <lispy> LordBrain: oh, actually distcc on normal ghc compiles may not be so hot, because as i recall it mangles the assembly code, before running the assembler...so distcc may not gain much
20:21:39 <Pete_I> who're the cardinals?
20:22:09 <lispy> Pete_I: Church's fans?
20:26:45 <LordBrain> lispy: i don't follow how mangled assembly would interfere with distcc...
20:27:04 <LordBrain> maybe i'm not quite understanding what you're saying
20:27:13 <glguy> Cardinals win!
20:27:50 <lispy> LordBrain: well, i'm just thinking, so it sends the C file off to be compiled, then immediately it needs the .s file so it can mangle it, then it sends that off again...seems like a lot of interruptions into what distcc wants to do
20:28:13 <LordBrain> hmm
20:28:27 <LordBrain> ok, that clarifies it some thanks
20:28:33 <lispy> LordBrain: it would be worth trying and benchmarking, maybe you could try it when you get some time and put a page on the wiki
20:30:17 <lispy> LordBrain: in fact, if you find it's faster to do the trick dons mentioned while building ghc that could go no the ghc dev wiki as a way to speed up the build (they are obvously always happy to hear about those :)
20:30:57 <lispy> maybe we need a distghc
20:31:19 <LordBrain> yeah.. distghc would be nice
20:32:17 * araujo back
20:32:45 * araujo just bought a digital camera
20:32:59 <lispy> cool
20:32:59 <araujo> Now i will be able to take pics of lambdas!
20:33:06 <lispy> and bikesheds?
20:33:12 <araujo> hah
20:33:28 <lispy> we need a bike shed with a lambda painted on it in random colors
20:33:45 <araujo> let me see what i can do :-)
20:33:49 <lispy> or at least a plethora of colors on the shed with lambdas too
20:34:34 <dons> ?seen kfish
20:34:35 <lambdabot> I saw kfish leaving #haskell.jp and #haskell 17h 16m 24s ago, and .
20:34:40 <dons> ?seen beelsebob
20:34:41 <lambdabot> I saw beelsebob leaving #haskell 2h 23m 8s ago, and .
20:35:34 <dons> ?seen bobstopper
20:35:35 <lambdabot> bobstopper is in #haskell.jp and #haskell. I last heard bobstopper speak 3h 2m 2s ago.
20:35:43 <dons> Bobstopper: around?
20:36:08 * lispy thinks dons is up to something
20:38:38 <dons> trying to get some more info about the japanese "evil bird" haskell book
20:38:47 <lennart> huh?
20:39:33 <dons> all I have is , http://images-jp.amazon.com/images/P/4839919623.01.LZZZZZZZ.jpg
20:39:36 <lambdabot> http://tinyurl.com/y6v7ul
20:39:53 <dons> not evil Bird ;)
20:40:06 <dolio> Wow. That's a quality cover.
20:40:17 <lispy> hah
20:40:27 <lispy> R. Bird is evil?
20:40:36 <lispy> i mean, he invented the ">" notation...but evil?
20:41:26 <lennart> I don't think he's evil.  Except possibly when playing poker.
20:41:29 <dons> so if anyone knows enough japanese to find some more info on that book... let me know :) and we can update http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
20:41:31 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y88o8f
20:41:35 <dons> lennart: heh
20:42:41 <lispy> lennart: nice
20:43:22 <lennart> japanese haskell, huh
20:44:57 <dons> and note a new brazillian haskell textbook has just come out too, http://www.novateceditora.com.br/livros/haskell/
20:45:02 <lambdabot> http://tinyurl.com/yjkv9g
20:46:48 <lennart> Haskell needs a text book for experienced programmers.  Not just all these beginners books
20:46:53 <dons> yes!
20:47:07 <lispy> lennart: advanced haskell for Oleg?
20:47:20 <lennart> i wasn't thinking of Oleg ;)
20:47:24 <lispy> heh
20:47:31 <dons> Practical Haskell, starting with monads and ending with hmm, epigram. with concurrent and smp haskell in between.
20:47:35 <lispy> yeah, would be a bit over my head if it had advanced and oleg in the title
20:47:40 <lennart> but of people who can program, but don't know haskell
20:48:13 <Adamant> who is this "Oleg"?
20:48:32 <lispy> well, i already was familar with strict non-pure FP so, i didn't need that much tutorial-wise, just needed to understand monads and some type theory and i was up and running mostly
20:48:38 <lennart> doesn't have to start with monads.  but i'd like to see a lot of comparisons with other languages and how to express common design patterns in haskell
20:48:51 <lispy> yeah, that would be nice
20:49:08 <lispy> an approach like a Haskell Cookbook would be nice
20:49:09 <Adamant> how about actually building some cool stuff?
20:49:10 <lennart> Adamant: Oleg is a type magician
20:49:32 <lennart> the book should absolutly build some cool stuff
20:49:49 <lennart> examples like don's bot
20:50:04 <lispy> I remember him roughly saying this at the haskell-workshop, "Here is the shortest proof I know that the Haskell type system with common extensions is Turing Complete, it's a 5 line lambda calculus interpreter in the type system." [sic]
20:50:06 <Adamant> that is what hooked me on PCL
20:50:18 <lennart> PCL?
20:50:20 <Adamant> hahaha
20:50:26 <Adamant> sounds hardcore
20:50:35 <Adamant> Practial Common Lisp
20:50:38 <int-e> 5 lines?
20:50:39 <lispy> he's got a sense of humor though
20:50:40 <lennart> Ah, yes
20:50:44 <dons> so ,yes, something could fit in to this list, http://www.amazon.com/gp/explorer/159059620X/2/ref=pd_cp_b_expl/104-0009163-6568732
20:50:48 <lambdabot> Title: Amazon.com: Practical OCaml (Practical): Explore similar items, http://tinyurl.com/y7glpq
20:50:59 <lennart> he does.  but in a serious way :)
20:51:02 <lispy> Adamant: yes, Peter Seibel(sp?) is a good author
20:51:11 <dons> "Practical OCaml", "ML for the Working Programmer', ...
20:51:23 <lennart> yep.  we one of those
20:51:38 <lispy> heh, do they get paid in OCaml bucks?
20:52:59 <lennart> does anyone know how krasimir is progressing with visual haskell?
20:53:15 <lispy> lennart: not bad
20:53:24 <lispy> lennart: he posted a new version around Oct. 1st
20:53:30 <dons> I think he said something about "part time only" though, recently?
20:53:39 <lispy> lennart: by now he may even have posted a version with ghc6.6
20:53:46 <EvilRanter> > (`div`)
20:53:46 <lambdabot>  Parse error
20:53:51 <lennart> does it support VS 2005?
20:54:03 <EvilRanter> > (`div` 10)
20:54:04 <lambdabot>  Add a type signature
20:54:07 <EvilRanter> fnord
20:54:24 <lispy> my biggest complaint is that i have have a bug in comlib when using automation, but he doesn't really seem interested in helping me with it (and i'm cluess as to what is causing it, have spent days debugging)
20:54:28 <lispy> lennart: yes
20:54:53 <lennart> oops, the plane is pushing back.  i need to stop
20:55:13 <dons> interesting...
20:58:55 <dons> doh, quick, stick some mods on it. those ruby guys can't get away with rewriting history: http://programming.reddit.com/info/o63e/details !
20:58:58 <lambdabot> Title: The Ruby Interpreter (reddit.com), http://tinyurl.com/yyo8ka
20:59:58 <lispy> okay, i logged in
21:00:06 <lispy> i really hate that website, but i did it out of love for haskell :)
21:00:12 <dons> heh
21:00:31 <dons> its good for getting a feel of the overall fashions and trends, i find
21:01:07 <dons> ok, so back to 5up/5dn. just need a couple more ups....
21:01:42 <EvilRanter> sleeeeep
21:02:26 <dons> ok yay. back on the front page.. just.
21:02:36 <dons> just needs to stay there for a few more hours ...
21:02:53 * lispy cabalizes
21:03:11 <lispy> what happens if it's there a few hours?
21:03:33 <lispy> it wouldn't be such a bad website if they put a decent UI on it
21:03:46 <dons> just thinking that if we can keep it on the front page to the euro and US crowd wakes up again..
21:04:00 <lispy> oh, long way till the US crowd wakes up
21:04:02 <lispy> ?localtime lispy
21:04:04 <lambdabot> Local time for lispy is Fri Oct 27 21:03:38 2006
21:04:04 <dons> what's wrong with the ui? i've not minded it. its nicer than digg.
21:04:10 <dons> ah right.
21:04:31 <lispy> whenever i want to go back to the programming page i always accidentally end up at the main page
21:04:46 <lispy> going, "wtf mate?"
21:04:47 <dons> i've not done that myself. i wonder why.
21:05:03 <dons> oh, the little icon at the top points to the main page.
21:05:05 <dons> that's a bit silly
21:05:26 <lispy> depends on where your mouse is
21:05:50 <glguy> http://undefined.com/ia/2006/10/27/six-word-stories-about-programming-languages/
21:05:53 <lambdabot> Title: Indefinite Articles Â» Six Word Stories about Programming Languages, http://tinyurl.com/thpqv
21:05:54 <glguy> java takes the hit
21:05:57 <lispy> and i accidentally mod things
21:07:04 <lispy> this sounds like a load of dragon snot, "Query Composition using Functional Programming Techniques in C# 3.0"
21:10:25 <glguy> Man dons... you are really campaigning for Haskell on reddit.com (c:
21:10:57 <lispy> is everything on there a blog post?
21:11:04 <lispy> that be another reason i get bored :)
21:11:17 <dolio> Sometimes it's a newsgroup post. :)
21:11:39 <Adamant> nobody has done one for Haskell yet
21:12:03 <Adamant> Haskell: Monads aren't THAT scary. Really. Promise.
21:12:51 <dons> glguy: ?
21:13:01 <dons> I just tend to comment only on the haskell stuff
21:13:09 <glguy> I've just noticed your name under a lot of the posts :)
21:13:16 <glguy> oh, those are comments and not your submissions?
21:13:24 <dons> some are comments, some are submissions.
21:13:28 <dons> i've submitted maybe 6?
21:13:28 <glguy> Either way it's cool, I just keep seeing your name :)
21:14:19 <lispy> dons: yeah, stop doing us all a favor, geez :)
21:14:24 <dons> oh, i've submitted 9 in the last 21 days
21:14:42 <dons> http://programming.reddit.com/user/dons/submitted
21:14:44 <lambdabot> Title: submitted by dons (on programming.reddit.com), http://tinyurl.com/yybya8
21:16:53 <lispy> dons: oh, fwiw, i'm not impressed with our custom search engine...i haven't checked it in a day or two, but i never did find the place to create tags or refinements or whatever
21:17:22 <dons> this was a nice thread, http://programming.reddit.com/info/nq1k/comments/cnv5n
21:17:26 <lambdabot> Title: Haskell and Scheme: Which One and Why? (reddit.com), http://tinyurl.com/yjq4ex
21:17:29 <dons> lispy: hmm. ok.
21:17:42 <dons> i've used it a couple of times to do mailing list searches
21:17:43 <glguy> http://scienceblogs.com/goodmath/2006/10/haskell_and_scheme_which_one_a.php#more another link on reddit... are people actually asking themselves this question??
21:17:45 <lambdabot> http://tinyurl.com/y4neqs
21:23:34 <glguy> What are the Î±, Î², and Î· rules specifically?
21:24:10 <lispy> that's unicode or something
21:24:22 <glguy> alpha, beta, eta
21:24:32 <lispy> ah, that's lambda calculas
21:24:34 <lispy> calculus
21:24:35 <glguy> right
21:24:46 <lispy> check wikipedia :)
21:24:50 <lispy> i can't do it justice over irc
21:25:06 <lispy> basically, it's the rules for evaluating lambda expressions
21:25:16 <lispy> each one is a 'reduction'
21:25:41 <lispy> beta is probably the most important, and alpha is just variable renaming when you enter the context of a new function
21:26:13 <lispy> if you have any questions i'd be happy to help, but i think starting with a good reference is better
21:26:58 <glguy> I'm reading now on wikipedia (-:
21:28:46 <lispy> ghc does a lot of eta expansions i guess
21:29:03 <lispy> at least that was the impression i get from reading things like "Wearing the Hair shirt"
21:31:13 <lispy> how do i find out which package a module is in?
21:31:19 <lispy> take System for example
21:32:54 <dons> hmm. we don't have a tool
21:33:01 <dons> ?hoogle System
21:33:07 <lambdabot> System :: module
21:33:07 <lambdabot> System.system :: String -> IO ExitCode
21:33:07 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
21:33:18 <dons> @tell ndm modules should report which package they are in
21:33:18 <lambdabot> Consider it noted.
21:33:24 <lispy> so far i have base and mtl as build depends
21:33:33 <dons> right. so what are you missing?
21:33:42 <lispy> I need to import System
21:33:48 <lispy> i use things like runInteractiveCommand
21:33:51 <dons> oh, that's a haskell98 module
21:33:56 <lispy> thanks
21:33:57 <dons> System.Process is in base
21:34:06 <lispy> oh weird
21:34:09 <dons> if yo ucan avoid System, and use System.IO and friends, use base
21:34:17 <lispy> so part of System is in one place and the rest somewhere else...
21:34:27 <dons> no. the names are just different
21:34:32 <dons> due to the hier modules extension
21:34:34 <lispy> is haskell98 deprecated?
21:34:48 <lispy> thing is, runInteractiveCommand is as close to popen as I know of, which is exactly what iwant
21:34:56 <dons> not yet. but its in an extra package, so you'll have one less dep if you don't use h98 module names
21:35:04 <dons> yeah, so use it. its in System.Process
21:35:06 <dons> which is in base
21:35:12 <dons> ?hoogle runInteractiveCommand
21:35:12 <lispy> ah, cool
21:35:12 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
21:35:30 <lispy> oh, i do have taht
21:35:30 <dons> not i have a wrapper giving popen-like interface to runInteractiveCommand in lambdabot
21:35:35 <dons> s/note/
21:35:35 <lispy> i have System imported for something else maybe
21:35:40 <lispy> i'll remove it and see what happens
21:36:53 <lispy> i need a bash alias for runghc Setup.[l]hs configure --bindir=`pwd` && runghc Setup.[l]hs build && runghc Setup.[l]hs install
21:37:23 <dons> i have:
21:37:24 <dons> alias c="runhaskell Setup configure --prefix=/home/dons -b /usr/obj/cabal"
21:37:24 <dons> # alias c="runhaskell Setup configure"
21:37:24 <dons> alias b="runhaskell Setup build"
21:37:25 <dons> alias i="runhaskell Setup install"
21:37:34 <dons> c ; b ; i :)
21:37:42 <lispy> nice
21:38:01 <dons> note the -b flag to dump objects on a scratch filesystem, keeping the tree clean
21:38:09 <dons> useful if you do backups
21:38:35 <lispy> i just use darcs an replicate to several computers
21:38:56 <lispy> otherwise i only have a backup on a file system i rarely use, if ever :)
21:42:02 <dons> hmm, kowey sez: "Well, it's official.  The wxHaskell revival is now underway" !
21:42:14 <dons> http://koweycode.blogspot.com/2006/10/wxhaskell-on-darcshaskellorg.html
21:42:17 <lambdabot> Title: koweycode: wxhaskell on darcs.haskell.org, http://tinyurl.com/yfkerj
21:42:18 <dolio> Cale: ping
21:46:37 <monochrom> http://www.vex.net/~trebla/haskell/random.xhtml   I have added a section on infinite list of random numbers.
21:46:41 <lambdabot> http://tinyurl.com/tjet5
21:47:09 <monochrom> lambdabot still doesn't understand application/xml+xhtml hehe
21:47:38 <monochrom> err application/xhtml+xml
21:47:52 <dons> would you like to post this on the hsakell.org wiki instead/
21:47:58 <monochrom> No.
21:47:59 <dons> it will be much more visible
21:48:03 <dons> ok :)
21:49:03 <dons> what's the goal with these tuts you're writing?
21:49:27 <dons> seems they could be publicised a bit wider, or at least easier to find from haskell.org
21:52:45 <monochrom> Not liking the style sheet of the wiki
21:52:49 <dons> hmm, http://lambda-the-ultimate.org/node/1803#comment-21779, "How about Practical Haskell?"
21:52:51 <lambdabot> Title: Practical OCaml | Lambda the Ultimate, http://tinyurl.com/ye7kqs
21:53:06 <dons> monochrom: well your work will be invisible unless it gets at least linked to from haskell.org
21:53:29 <dons> on idea is to create a stub page, categorised under tutorials, that just redirects to your page
21:53:38 <dons> we do that for some of Oleg's work.
21:57:55 <lispy> ?hoogle shiftL
21:57:56 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
21:57:56 <lambdabot> GHC.Exts.shiftL# :: Word# -> Int# -> Word#
21:57:56 <lambdabot> GHC.Exts.iShiftL# :: Int# -> Int# -> Int#
21:59:21 <mwc> OT: does anybody know what sort of work the Soviets were doing with programming languages before the USSR went belly up?
22:00:41 <monochrom> Interesting. I think they wrote Turing machines by hand.
22:00:50 <arcatan> "Practical Haskell" sounds like a book I could buy
22:01:07 <monochrom> It is why Kolmogorov complexity is not defined for functional programming.
22:02:21 <mwc> Kolmogorov was one prolific motherfucker.
22:03:23 <dolio> ?pl \g -> tellg >> put (t, g)
22:03:24 <lambdabot> (tellg >>) . put . (,) t
22:03:55 <monochrom> tellg = tell g ?
22:04:07 <mwc> I mean, I'm used to seeing his name crop up with regards to differential equation theory and fluid dynamics
22:04:13 <dolio> Oh, yeah. Typo.
22:04:17 <dolio> ?pl \g -> tell g >> put (t, g)
22:04:18 <lambdabot> liftM2 (>>) tell (put . (,) t)
22:05:11 <monochrom> liftM2 (>>) kills the cat
22:08:12 <lispy> ?hoogle ExitFailure
22:08:13 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
22:08:13 <lambdabot> System.exitFailure :: IO a
22:10:58 <lispy>     Expecting a function type, but found `w_a2KN'
22:11:04 <lispy> is that a bug?
22:11:54 <monochrom> who is w_a2KN?
22:11:57 <lispy> or maybe it just needed that many type veriables by the time it came to that place in the program
22:12:04 <monochrom> hahaha
22:22:26 <lispy> c <- hGetContents h; hClose h; putStrLn c; <-- this can print nothing sometimes even when there is output
22:22:34 <lispy> i fixed it by changing it to
22:22:49 <lispy> c <- hGetContents h; c `seq` return (); hClose h; putStrLn c;
22:23:49 <dons> right. lazy io
22:24:09 <dons> evaluate (length c) -- is often used
22:24:29 <lispy> yeah, i just changed it to length c `seq` return () just in case
22:24:55 <lispy> should i need to manually close the handles that runInteractiveCommand gives me?
22:25:07 <lispy> i kept running out of handles and that seems to fix it
22:27:03 <dons> here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Process.hs
22:27:05 <lambdabot> http://tinyurl.com/y2lucu
22:28:08 <lispy> you don't clean up
22:28:47 <sjanssen> won't the handles close when they're garbage collected?
22:29:03 <lispy> so maybe i run into problems because i create lots of handles
22:29:14 <lispy> > 850 * 6
22:29:16 <lambdabot>  5100
22:29:26 <lispy> i need about that many file handles with in a minue
22:29:29 <lispy> minute*
22:29:44 <dons> they should  go into a closed state when all data is read
22:29:55 <dons> but yeah, do it your self if you need to be sure
22:30:20 <lispy> i'm not sure, but  it seems to fix a semi-reproducible problem
22:30:27 <dons> good
22:30:32 <sjanssen> dons: have you tried to run HPC on Data.ByteString?
22:30:58 <dons> ooh. not yet. sounds like an interesting idea
22:30:59 <lispy> ?hoogle evaluate
22:30:59 <lambdabot> Control.Exception.evaluate :: a -> IO a
22:31:00 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
22:31:19 <sjanssen> yeah, I'm going to attempt it when this ghc build finishes
22:32:28 <dons> excellent!
22:32:50 <lispy> oh hrm...
22:33:15 <lispy> evaluet $ length msg  -- doesn't seem to happen before the hGetConents
22:33:32 <dons> length msg `seq` ....
22:34:13 <lispy> hrmm...so i broked something
22:34:33 <lispy> ah right
22:34:47 <lispy> accidentally tried to read from stderr after a few variable renames :)
22:47:07 <sjanssen> dons: how do you build ghc minus ByteString now that the regex libraries use the module?
22:47:40 <moconnor> 
22:52:59 <dons> you don't built it minus bytestring :)
22:53:10 <dons> or if you do, you just remove it from base
22:53:26 <skew> hi dons, have you looked at hs-plugins on 6.6 any more?
22:53:45 <dons> not yet, no.
22:54:04 <skew> also HList seems to be massively broken by the scoped type variable changes.
22:54:28 <skew> It seems I'll have to stick with 6.4 for the moment to have nice libraries
22:56:06 <dons> that's reasonable
22:56:29 <dons> there's no need to update to 6.6 immediately. often people wait for the 6.x.1 version ofn the stable branch
22:56:37 <dons> unless they need something specific, like pugs does for smp
22:58:06 <skew> I'm thinking of some other applications that could benefit from having ByteStrings included, but I think the most immediate thing to do is clean up some boilerplate in some code already written
22:58:46 <skew> and I'm thinking HList might be useful for that.
23:00:07 <skew> I'm representing some C structures with big tuples, but I also need some metadata about the fields to get serialization right
23:04:13 <dons> doh, hit 0 again. up mod! http://programming.reddit.com/info/o63e/details
23:04:17 <lambdabot> Title: The Ruby Interpreter (reddit.com), http://tinyurl.com/yyo8ka
23:04:22 <dons> those ruby people want to ignore the truth! ;)
23:06:53 <Lemmih> Already got my vote.
23:07:13 <vegai> might be because it's missing the (PDF) tag
23:07:35 <vegai> what the heck is that about?
23:07:52 <vegai> a really precise definition of a ruby interpreter?
23:08:56 <emu> lol
23:09:17 <emu> also Python is the name of the CMUCL compiler
23:10:52 <vegai> that would be a nice april's fool
23:11:13 <vegai> compromise ruby-lang.org and replace all tutorial links with that pdf ;-D
23:12:10 <vegai> argh, *now* I read the Abstract.
23:12:18 <vegai> vegai--
23:14:19 <int-e> dons: cute
23:14:45 <dons> I think gmh should sue!
23:14:46 <vegai> http://undefined.com/ia/2006/10/27/six-word-stories-about-programming-languages/
23:14:49 <lambdabot> Title: Indefinite Articles Â» Six Word Stories about Programming Languages, http://tinyurl.com/thpqv
23:15:18 <vegai> missing a haskell story still
23:16:10 <sjanssen> http://programming.reddit.com/info/o5k5/comments/co6mo
23:16:12 <lambdabot> Title: Six Word Stories about Programming Languages (reddit.com), http://tinyurl.com/y5sfa5
23:16:47 <vegai> ah
23:18:32 <sjanssen> best I could think of
23:18:42 <sjanssen> somebody needs to write a better one!
23:19:44 <vegai> Haskell: BDSM your way to the future!
23:19:50 <vegai> (I'm just brainstorming)
23:21:12 <dolio> Heh: "Java: Six words don't go very far."
23:21:15 <vegai> Generalize, generalize, generalize, generalize, generalize, GENERALIZE!
23:21:27 <dons> Haskell: You know I'm smarter than you
23:21:35 <lispy> Haskell: Lambda Calculus in the type system!
23:21:51 <vegai> haha, good, good
23:22:40 <dolio> So, you think I can get partial credit on the newest rubyquiz without fooling around with haskell's time libraries?
23:22:50 <lispy> Haskell: Expected Int but Inferred IO Int
23:23:14 <dons> heh
23:23:34 <dons> i like that one, lispy ;0
23:24:15 <lispy> okay, half way done refactoring my compiler
23:24:21 <lispy> at some point maybe i'll even write some new code :)
23:24:22 <sjanssen> from a grumpy Haskell newbie: MONADS?! Why can't I do IO?
23:24:41 <lispy> oh yeh, maybe it should be Haskell: Expected IO Int but Inferred Int
23:24:55 <lispy> er no first way is better
23:24:59 <dons> so in a couple of days we should post 'Circuit design in Ruby' and some of the other 'true' ruby papers on reddit ;)
23:25:09 <lispy> because that's what you'd get if you were trying to unwrap IO
23:25:20 <lispy> heh
23:25:22 <dons> and 'Designing arithmetic circuits by refinement in Ruby'
23:25:34 <sjanssen> unsafePerformIO is our nasty little secret
23:25:35 <dons> and then rewrite the wikipedia ruby entry
23:25:47 <dons> ?foldoc ruby
23:25:49 <lambdabot> *** "ruby" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
23:25:49 <lambdabot> Ruby
23:25:49 <lambdabot>  
23:25:49 <lambdabot>     <language>
23:25:49 <lambdabot>  
23:25:51 <lambdabot> [62 @more lines]
23:25:54 <dons> oooh...
23:25:55 <dons> ?more
23:25:56 <lambdabot>     1. A {relational language} designed by Jones and M. Sheeran in
23:25:57 <lambdabot>     1986 for describing and designing circuits (a {hardware
23:25:59 <lambdabot>     description language}).  Ruby programs denote {binary
23:25:59 <dons> yay!!!
23:26:01 <lambdabot>     relations} and programs are built-up inductively from
23:26:03 <lambdabot>     primitive relations using a pre-defined set of {relational
23:26:05 <lambdabot> [57 @more lines]
23:26:11 <lispy> ?more
23:26:12 <lambdabot>     operators}.  Ruby programs also have a geometric
23:26:13 <lambdabot>     interpretation as networks of primitive relations connected by
23:26:15 <lambdabot>     wires, which is important when layout is considered in circuit
23:26:17 <lambdabot>     design.
23:26:19 <lambdabot>  
23:26:21 <lambdabot> [52 @more lines]
23:26:27 <dons> foldoc never lies.
23:26:38 <int-e> Pure on the surface. unsafePerformIO inside. ?
23:28:52 <skew> In Haskell, typechecker works for YOU!
23:29:09 <dons> heh
23:29:10 <sjanssen> skew: nice
23:29:16 <dons> yeah that's good.
23:29:59 <vegai> Image is nothing. Types are everything.
23:31:10 <skew> In communist Haskell?
23:32:31 <vegai> I'll paste these to reddit
23:34:15 <vegai> lispy: are you dagit? ;)
23:34:52 <int-e> You are in a twisted maze of types, all different.
23:35:29 <dgoldsmith> On that Japanese bird book...
23:35:38 <dons> 6 words: Twisted maze of types, all different
23:35:40 <dgoldsmith> Title: Haskell Primer
23:35:41 <dons> dgoldsmith: yes?
23:35:51 <dons> ah good
23:35:58 <dgoldsmith> Subtitle: Learning a functional language for the first time
23:35:59 <dons> any more info? a url for where it can be purchased?
23:36:12 <skew> vegai: how about "Type bondage blasÃ©? Try being top."
23:36:12 <dons> updating the web page now...
23:36:17 <lispy> vegai: perhaps
23:36:23 <dgoldsmith> I still have to figure out the author's name, and I'll look for the URL too.
23:36:28 <dons> cheers
23:36:30 <dons> dgoldsmith++
23:37:09 <dgoldsmith> The subtitle could also be "The first functional language to learn". It's hard to tell sometimes.
23:37:35 <dgoldsmith> The literal translation is "The functional language which you learn for the first time".
23:37:37 <vegai> skew: ;-D
23:37:48 <sjanssen> In Haskell PHDs work for YOU!
23:37:49 <dons> ah
23:37:55 <dons> oh that's good too
23:38:00 <vegai> hmm, how do you do a simple <br/> in markdown...
23:38:18 <dons> dgoldsmith: you know about #haskell.jp ?
23:38:29 <dons> ?users #haskell.jp
23:38:30 <lambdabot> Maximum users seen in #haskell.jp: 3, currently: 2 (66.7%), active: 0 (0.0%)
23:38:33 <dgoldsmith> No, I didn't...
23:38:40 <dons> now you do!
23:38:54 <dons> vegai: leave a blank line, I think
23:39:49 <vegai> looks like that is the equivalent of <p>...</p>
23:40:48 <dgoldsmith> Book URL: http://www.amazon.co.jp/Q65Â80Haskell-1506f058081066-66076Âa2e70W8bÂ00Â9e-åäº-æ·³/dp/4839919623/
23:40:48 <lambdabot> http://www.amazon.co.jp/Q65Â80Haskell-1506f058081066-66076Âa2e70W8bÂ00Â9e-åäº-æ·³/dp/4839919623/
23:41:00 <dgoldsmith> Wow, that didn't work very well...
23:41:31 <dons> some funny chars in there? :)
23:41:36 <dons> try computing the tiny url perhaps?
23:41:43 <skew> works for me
23:41:49 <dgoldsmith> Ah, good idea.
23:41:53 <skew> pity I can't read japanese
23:41:54 <dons> ?tiny-url http://www.amazon.co.jp/Q65Ã80Haskell-1506f058081066-66076Ãa2e70W8bÃ00Ã9e-Ã¥?12l
23:41:54 <lambdabot> http://www.amazon.co.jp/Q65Ã80Haskell-1506f058081066-66076Ãa2e70W8bÃ00Ã9e-Ã¥?12l
23:41:59 <dons> hmm
23:42:11 <dgoldsmith> http://tinyurl.com/ydzdc7
23:42:17 <int-e> http://www.amazon.co.jp/Q65%C2%9580Haskell-1506f058081066-66076%C2%95a2e70W8b%C2%8A00%C2%8A9e-%E5%90%91%E4%BA%95-%E6%B7%B3/dp/4839919623/
23:42:21 <lambdabot> http://tinyurl.com/ybqyk5
23:42:24 <dons> very good
23:42:38 <vegai> oh that's nice. If I indent 4 chars (should mean <pre><code> in markdown), rendering the first &lt; breaks
23:42:43 <skew> does lambdabot not read UTF-8?
23:43:09 <sjanssen> skew: not really
23:45:26 <skew> A question around Data.Map - I'm merging one map into another with a combiner that picks one of the associations to keep, and I'd like to also produce a set of the keys of the pairs I kept from the inserted map
23:45:59 <dons> dgoldsmith: ok, i've updated the entry just a little, http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
23:46:01 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y88o8f
23:46:10 <dons> feel free to translate any other relevant text
23:46:12 <dgoldsmith> Author's name is, I think, Jun Mukai. Names are tricky to transcribe, but I Googled his kanji name and that seems to be the right person.
23:46:31 <dons> oh!
23:46:36 <dons> Jun's the author?
23:46:48 <dons> ?seen mukai
23:46:49 <lambdabot> I haven't seen mukai.
23:46:51 <dons> ?seen jmukai
23:46:52 <lambdabot> I haven't seen jmukai.
23:46:58 <dons> i think we've seen him here once or twice
23:50:32 * dgoldsmith heads off to bed...
