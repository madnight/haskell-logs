00:00:03 <dons> oh, local function bindings. i see
00:00:03 <phr-newbie> > [(a,b) | a <- [1..5], b <- [10..15]]
00:00:05 <lambdabot>  [(1,10),(1,11),(1,12),(1,13),(1,14),(1,15),(2,10),(2,11),(2,12),(2,13),(2,14...
00:00:15 <phr-newbie> that's what i mean by nested
00:00:18 <dons> yep
00:00:21 <dons> nested in a block
00:00:35 <phr-newbie> yeah it has that
00:00:37 <dons> yeah, functions aren't first class values in python?
00:00:57 <ValarQ> aren't they objects?
00:01:00 <phr-newbie> functions have always been values i think, but they didn't carry their environment until recently
00:01:02 <ValarQ> like everything else
00:01:13 <phr-newbie> there weren't lexical closures
00:01:17 <dons> ah
00:01:19 <phr-newbie> i dunno if that notion makes sense in haskell
00:01:39 <skew> do parallel list comprehensions just do  map _ $ {- no filter here! -} $ zipN (map _ $ filter _ $ l1) (map _ $ filter _ $ l2)?
00:01:45 <phr-newbie> and you still can't mutate any variables that aren't from your local scope or else global
00:01:51 <dons> skew: roughly
00:02:10 <dons> phr-newbie: can't mutate? but you can read them??
00:02:38 <dons> or are things not in scope, really not in scope? as it were :)
00:03:08 <ValarQ> isn't  otherobj.something.x = 3  mutating variables outside?
00:03:38 <dons> sometimes i forget there are languages where mutable variables are the default, and functions aren't values
00:03:40 <phr-newbie> dons, sorry, yes you can mutate, you can't bind
00:04:06 <phr-newbie> like you can say x.something = 3 or x[3] = 3
00:04:15 <phr-newbie> but you can't say x=3 because that will create a new local binding
00:04:21 <ValarQ> dons: what do you mean by functions that isn't values?
00:04:23 <phr-newbie> instead of reaching up to the outer one
00:05:14 <dons> ValarQ: languages where functions aren't just yet another value. so no higher order functions, not local function bindings and so on
00:05:47 <ValarQ> dons: can you give an example of that?
00:05:55 <dons> but mutable-by-default is the scariest of all. that's like running as root and writing directly into /dev/kmem
00:05:56 <ValarQ> awk maybe?
00:06:09 <dons> > map (\x -> x+1) [1..10]
00:06:14 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
00:06:22 <dons> > map (let f x = x + 1 in f) [1..10]
00:06:23 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
00:06:25 <dons> that kind of thing
00:07:07 <dons> mutable state should be like being the root users. you can break anything and do anything, but you should have to ask permission
00:07:07 <ValarQ> dons: i was thinking of examples of languages that doesn't allow hof
00:07:28 <dons> should be plenty of languages that don't have first class functions
00:07:43 <ValarQ> yes, but that doesn't mean that they doesn't allow hof
00:07:44 <dons> or they're crippled in someway. e.g. C's function pointers..
00:07:46 <phr-newbie> hmm now the pastebin thingie is hung
00:07:56 <ValarQ> look at qsort in C
00:08:08 <dons> sure. but its so awkward you don't see much higher order C code...
00:08:09 <ValarQ> or map and filter in python
00:08:23 <ValarQ> dons: you do in my C programs ;)
00:08:29 <dons> yep, or say perl. but its a bit weird. functions and blocks aren't quite normal values
00:08:43 <dons> they're still second class
00:08:53 <dolio> Java doesn't have first class functions, either.
00:08:54 <ValarQ> yes
00:09:05 <dons> well, its the land of nouns.
00:09:12 <dons> things just _are_ in java. they don't _do_
00:09:20 <lisppaste2> phr annotated #27448 with "whee, thanks" at http://paste.lisp.org/display/27448#7
00:11:14 <phr-newbie> i still don't have a freaking clue what haskell is doing with the code though, it's not like lisp where it's completely obvious how an evaluator has to work
00:12:20 <phr-newbie> so should i punt hugs and use ghci?
00:12:26 <dons> I'd probably just write : Integer -> String, btw.
00:12:31 <dons> phr-newbie: yeah. or ghc...
00:12:40 <dons> so you can actually compile stuff and run it at high speed
00:13:02 <dons> no need for the parens: (big a (d+1))
00:13:06 <dons> just write: big a (d+1)
00:13:17 <dons> similarly, [(spell b) ++ " " ++ (bignames !! d)]
00:13:30 <dons> application binds tight, so that haskell doesn't look like lisp
00:13:49 <dons> > toUpper 'x' : toLower 'Y' ++ "some stuff"
00:13:53 <lambdabot>  Couldn't match `[a]' against `Char'
00:13:58 <phr-newbie> !! binds tighter than ++ ?
00:14:02 <dons> > toUpper 'x' : toLower 'Y' : "some stuff"
00:14:07 <dons> check it in ghci/hugs
00:14:09 <lambdabot>  "Xysome stuff"
00:14:14 <Bobstopper> musasabi: Yes, same errors (sorry, took a while to figure that one out)
00:14:23 <dons> using :info
00:14:39 <phr-newbie> Main> spell (6^666)
00:14:39 <phr-newbie> "one hundred seventy-seven
00:14:39 <phr-newbie> Program error: Prelude.!!: index too large
00:14:41 <phr-newbie> hahahahahahahaha
00:14:44 <phr-newbie> that's hysterical
00:15:00 <dons> you've introduced a bug it seems :)
00:15:10 <Syzygy-> phr-newbie: Are you aware of the size of that number?
00:15:14 <dons> > 6^666
00:15:18 <lambdabot>  1773098063577554652704994273285983017762889683060754101518851125757560275397...
00:15:21 <phr-newbie> yes, i expected an array index failure
00:15:25 <dons> > length . show $ 6^666
00:15:27 <lambdabot>  519
00:15:35 <phr-newbie> what made me burst out laughing was that the lazy evaluator actually started getting the answer
00:15:37 <Syzygy-> Ooooh. That's a neat way to calculate log_10 :)
00:15:41 <phr-newbie> before the failure happened
00:15:43 <dons> > length . show $ 6^666^666
00:15:49 <lambdabot> Terminated
00:15:50 <dons> too much
00:16:08 <phr-newbie> try spell (9^69)
00:16:09 <Syzygy-> > 666 * length . show $ 6^666
00:16:09 <lambdabot>  add an instance declaration for (Num (a -> Int))
00:16:14 <phr-newbie> that's close to the maximum
00:16:24 <dons> > 666 * (length . show $ 6^666)
00:16:26 <lambdabot>  345654
00:16:39 <Syzygy-> dons: Or did you intend to right-associate powers?
00:18:18 <ThreeQ> phr-newbie: it found the right number of somethings, but couldn't figure out what to call them :)
00:18:39 <gour> interesting comments about haskell - http://programming.reddit.com/info/l434/comments
00:18:42 <lambdabot> Title: Ask Reddit: Erlang, Haskell, OCaml; which functional language and why? (reddit.c ..., http://tinyurl.com/fjrx2
00:18:55 <phr-newbie> yeah there's such a thing as a centillion (= 10**300) but nothing between vigintillion (10**63) and centillion
00:19:52 <phr-newbie> erlang = sort of lisp-like with message passing primitives, microthreads and runtime system intended for phone switches
00:19:58 <phr-newbie> dynamic types
00:20:08 <phr-newbie> ocaml = statically typed lisp :)
00:20:16 <phr-newbie> right?
00:20:40 <ThreeQ> hmm
00:20:46 <phr-newbie> yeah i had the same question as that guy and decided to try haskell first
00:20:47 <dons> sigh. wireless card no worky
00:20:50 <phr-newbie> i've done a fair amount of lisp
00:20:54 <phr-newbie> and python
00:20:55 <ThreeQ> erlang is not very general-purpose
00:21:07 <phr-newbie> and decided against erlang because i wanted to try something with static types
00:21:27 <ThreeQ> it's great for doing network stuff and things that are easily represented in terms of processes
00:21:29 <phr-newbie> and i figured, ML is just another imperative language
00:21:37 <phr-newbie> and ocaml has hideously ugly syntax
00:22:02 <phr-newbie> i have the impression SML is now at least as fast as ocaml
00:22:10 <phr-newbie> oh yes the other thing is that ocaml doesn't have concurrency and ghci does
00:22:14 <ThreeQ> erlang is my favorite server writing language, but I don't think I'd write anything else in it
00:22:37 <phr-newbie> i really like that paper about transactional memory in GHCI
00:23:01 <phr-newbie> anyway you've just seen my first haskell program more complicated than fibonacci :)
00:23:01 <gour> i decided for haskell as most general programming language and #haskell is great fun - all in all, great community
00:24:14 <ThreeQ> ocaml... I dunno, I've never really used it
00:24:23 <ThreeQ> all I know is the syntax is quite ugly
00:24:42 <phr-newbie> i don't like the implementation's license either
00:24:53 <phr-newbie> but apparently it has good runtime and debugging tools
00:25:05 <ThreeQ> and a nifty preprocessor
00:25:07 <musasabi> Bobstopper: then it sounds like a problem with GCC if GCC produces invalid assembler and thus should be reported.
00:25:23 <phr-newbie> Playing with Haskell is like pleasure boating with an aircraft carrier. There's just too much there. It seems like a language for hardcore people with monklike devotion to it, sort of like C++ or Common Lisp.
00:25:24 <phr-newbie> ???
00:25:27 <phr-newbie> is that true?
00:25:32 <musasabi> Bobstopper: of course a newer GCC version might solve it, but GHC is quite picky about GCC versions.
00:25:36 <skew> that does sound a bit odd
00:25:53 <skew> I think Haskell is a lot simpler but a lot deeper than many languages
00:26:18 <phr-newbie> oh yeah, the other thing i couldn't stand about ocaml was no typeclasses, so you have to say "3+2" for adding integers but "3.0 +. 2.0" for adding floats, etc.
00:26:36 <skew> just a few very abstract abstractions to understand - and then people build a whole mess of stuff on top of it
00:27:01 <phr-newbie> i can imagine ML replacing c, but so far i'm not sure i can imagine that with haskell
00:27:17 <phr-newbie> ML = (sml, ocaml, alice ml, ...)
00:27:40 <Bobstopper> musasabi: But the error's the same as what comes from the assembler which appears to be reading the assembler incorrectly.
00:27:51 <skew> I think both would need pretty much the same amount of work, mostly around putting your own interpretation over raw memory, and doing manual memory allocation
00:28:00 <Bobstopper> musasabi:  http://paste.lisp.org/display/27385
00:28:24 <phr-newbie> skew, you mean about replacing C with haskell?  no the idea is to use garbage collection
00:28:29 <Bobstopper> The first annotation gives a part of the outputted assembly. The second gives the errors for that assembly. The errors don't match up.
00:28:52 <skew> Oh, you don't mean "systems programming"?
00:29:02 <skew> people are still using C for applications and such?
00:29:11 <Bobstopper> The same errors appear even when running as.exe directly on the .s file. So I'm pretty sure it's a problem with as.exe.
00:30:00 * musasabi would try replacing as.exe with a newer version from some other place.
00:30:28 <musasabi> Trying to compile FPS leads to similar errors.
00:30:28 <phr-newbie> does anyone use timber?
00:31:11 <Bobstopper> Yeah. I've been looking for other copies of as.exe but generally it doesn't come precompiled. I suppose I should just compile it...
00:32:24 <phr-newbie> Haskell is a lot like Perl: It's really, really succinct and expressive, and you can do all sorts of neat tricks. It's perfect for expressing algorithms. However, it has no good facilities for structuring large systems. Haskell programs are like clockwork: everything has to go together just right.
00:32:27 <phr-newbie> is that true?
00:32:55 <musasabi> Bobstopper: some very recent binary distribution of GCC for win32? Don't those include as.exe ?
00:33:07 <dolio> Perl is perfect for expressing algorithms?
00:33:17 <skew> Besides, don't think aircraft carrier, think mecha. The type system is a great amplifier of careful reasoning and propagator of intent. If somebody starts muttering about bondage, just tell them "those straps are there so the servos can follow *me*".
00:34:00 <Bobstopper> musasabi: most probably. I'm looking for one. GNU usually likes to distribute source.
00:34:38 <Bobstopper> probably binutils is what I'm really after though
00:35:10 <ThreeQ> haskell's type checking has made me a much better programmer
00:35:38 <phr-newbie> dolio, i think the perl comparison is about the ability to make amazing but obscure one-liners
00:35:38 <ThreeQ> now, even when I'm not working in haskell, I think about the types of the values and procedures I'm using
00:36:06 <phr-newbie> haskell's type system seems better than ML's
00:36:11 <phr-newbie> this nemerle thing looks interesting
00:36:22 <ThreeQ> > take 10 $ map length $ fix (([()]:).scanl (++) [()])
00:36:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
00:36:44 <Syzygy-> > take 10 $ fix (([()]:).scanl (++) [()])
00:36:45 <lambdabot>  [[()],[()],[(),()],[(),(),()],[(),(),(),(),()],[(),(),(),(),(),(),(),()],[()...
00:36:48 <Syzygy-> Ah.
00:37:15 <dolio> Yeah. That's how I read it too.
00:37:18 <skew> I haven't used Haskell for anything really big, but it seems like the type system should help large programs go together
00:38:10 <ThreeQ> and you can separate your code into modules
00:38:21 <skew> at least vs. something like Java - you can come pretty close to writing a type that captures just the minimal assumptions a function needs to work
00:38:27 <skew> then re-use it all over the place
00:39:19 <dons> ok. so good. they'll take back the dud wireless card. yay. 2 down. now just have to find one that works...
00:39:26 <musasabi> Bobstopper: yes, the lack of binary windows versions is frustrating.
00:40:45 <skew> Now, I have written some small and very tricky programs, and had much help from the types getting "everything to go together just right". Don't you have to do that in any language anyway?
00:40:54 <gour> musasabi: just upgrade your OS ;)
00:41:47 <skew> phr-newbie: why did you split spell from spell'?
00:42:00 <Bobstopper> Ok, I downloaded the latest (current) version of mingw and ran it's as.exe on the asm file. Same error.
00:42:01 <musasabi> gour: from linux to what?
00:42:32 <musasabi> gour: I am running wine on top of linux and trying to produce windows things for that windows users are needing...
00:42:41 <ValarQ> musasabi: isn't windows always distributed in binary?
00:42:50 <dons> musasabi: mmm. and its working?
00:42:58 <gour> musasabi: ahh, then no need to upgrade. stay with it :-)
00:43:13 <musasabi> ValarQ: most free software is distributed as source and trying to compile binary versions for windows without windows is "fun".
00:43:29 <dons> musasabi: if we can get this ghc/wine thing working, it might really help out windows support
00:43:51 <ValarQ> musasabi: oh, i tried that, it worked great, at least with C programs
00:44:17 <musasabi> ValarQ: the problem is that it does not work with GHC at the moment.
00:44:26 <ValarQ> musasabi: to bad the programs didn't execute when executed on windows...
00:44:33 <ValarQ> musasabi: but they compiled nicely
00:44:36 <musasabi> heh
00:44:39 <phr-newbie> skew, spell' builds up a list of substrings, spell concatenates them
00:45:00 <skew> why?
00:45:42 <skew> it seems like just end up wrapping lots of things in singleton lists
00:46:10 <phr-newbie> well i think it made the code simpler, in terms of organizing putting all the spaces in the right place
00:46:33 <phr-newbie> e.g. 1000100 should be "one million one hundred" not "one million  one hundred"
00:46:35 <musasabi> spell' = filter (not . null) . concatMap tails . inits ?
00:46:40 <Bobstopper> Cool, so does that mean I've got lots of people wanting to help me hack away getting ghc to work under wine? :)
00:47:07 <phr-newbie> musasabi i didn't understand?
00:47:33 <musasabi> just a way to build a list of all substrings for a string.
00:47:40 <phr-newbie> also, spell 0 is supposed to be "zero" but if that's used in the recursive calls you get 1000 = "one thousand zero hundred"
00:48:33 <phr-newbie> hmm
00:49:22 <musasabi> Bobstopper: getting it to work would be very nice at least for me.
00:49:55 <int-e> why are you trying to handle all this with a single function?
00:53:07 <Bobstopper> Ok, well I'm going to start on this problem by approaching the mingw people to see if they can shed some light. They'll probably just handball me to the binutils folks but it's a start.
01:06:58 <phr-newbie> ?type 3 /= 0
01:07:00 <lambdabot> Bool
01:07:52 <phr-newbie> i can't say if (a /= 0) and (b /= 0) then 3 else 4   ?
01:08:46 <Bobstopper> sure. But use && instead of "and"
01:09:04 <phr-newbie> ohhh yes sorry
01:15:19 <Cale> @type and
01:15:21 <lambdabot> [Bool] -> Bool
01:15:26 <Cale> @type (&&)
01:15:28 <lambdabot> Bool -> Bool -> Bool
01:26:03 <lisppaste2> phr annotated #27448 with "all-string version, no more spell'" at http://paste.lisp.org/display/27448#8
01:26:46 <phr-newbie> this has the messiness about conditional blanks that i was trying to avoid with the list version
01:26:57 <phr-newbie> but it's not as bad here as when i did it in python
01:29:02 <phr-newbie> i think more cleanup is still possible
01:29:18 <ThreeQ> phr-newbie: do you want to see my version?
01:29:57 <phr-newbie> ThreeQ yes
01:30:14 <lisppaste2> ThreeQ annotated #27448 with "a little more verbose... but clearer I think" at http://paste.lisp.org/display/27448#9
01:31:06 <weitzman> I was also inspired to write a number printer
01:32:28 <lisppaste2> weitzman pasted "For arbitrarily large numbers" at http://paste.lisp.org/display/27456
01:32:35 <weitzman> Probably has bugs
01:32:43 * phr-newbie still looking at ThreeQ's
01:32:53 <ThreeQ> mine handles arbitrary large numbers, but not very well
01:33:16 <ThreeQ> *Main> take 100 $ spell (6^90)
01:33:16 <ThreeQ> "ten twenty-two-illion eight hundred four twenty-one-illion six hundred ninety-five vigintillion five"
01:33:28 <phr-newbie> haha
01:34:00 <weitzman> "ten million vigintillion eight hundred four thousand vigintillion six hundred ninety-five vigintilli"
01:34:18 <phr-newbie> weitzman what do you get for (10^120)?
01:34:34 <weitzman> "one octodecillion vigintillion"
01:34:42 <ThreeQ> weitzman: that's a good idea
01:34:54 <weitzman> Hopefully that's correct
01:35:14 <phr-newbie> i like the latin versoin of ThreeQ's,  "ten XXII-illion eight hundred for XI-illion ... "
01:35:24 <ThreeQ> *Main> spell (10^120)
01:35:24 <ThreeQ> "one thirty-nine-illion"
01:35:27 <phr-newbie> scuse me XXI=illion :)
01:35:29 <phr-newbie> hahaha
01:36:19 <ThreeQ> shouldn't it be "one novemdecillion vigintillion"?
01:36:38 <ThreeQ> either that or mine's wrong
01:36:44 <phr-newbie> novem... = 10**60
01:36:52 <phr-newbie> so novemdecillion vigintillion = 10**123
01:37:03 <phr-newbie> remember million = 10*6
01:37:18 <phr-newbie> so N-illion = 10**(3N + 3)
01:38:00 <ThreeQ> hmm
01:38:23 <ThreeQ> I'm just counting up from vigintillion
01:38:51 <ThreeQ> *Main> take 100 $ spell (111111111111111111111111111111111111111111111111111111111111111111111)
01:38:52 <ThreeQ> "one hundred eleven twenty-one-illion one hundred eleven vigintillion one hundred eleven novemdecilli"
01:39:12 <weitzman> Mine says: "one hundred eleven thousand vigintillion one hundred eleven vigintillion one hundred eleven novemdec"
01:39:35 <ThreeQ> seems right to me
01:40:25 * ThreeQ shrugs
01:41:51 <phr-newbie> weitzman's version is pretty confusing / advanced
01:42:02 <weitzman> Spell 111000000000000000000000000000000000000000000000000000000000000000000 -> "one hundred eleven thousand vigintillion" = 111 * 10^66
01:42:24 <weitzman> I don't even know if mine is correct
01:42:47 <phr-newbie> weitzman, that's correct, vigintillion = 20-illion = 10**66
01:42:53 <weitzman> But the main thing is that it works in groupings of 3
01:43:21 <phr-newbie> yeah i felt that the list reversals were uglier than pure recursion building the string left to right
01:43:30 <ThreeQ> *Main> spell 111000000000000000000000000000000000000000000000000000000000000000000
01:43:30 <ThreeQ> "one hundred eleven twenty-one-illion"
01:43:47 <phr-newbie> hee
01:44:23 <Bobstopper> there's mingw32 for linux. I'm trying to cross-compile to windows using that now. Then developing windows apps without windows would be as simple as compiling with appropriate ghc options specifying mingw32 components, and then testing under wine...
01:44:39 <Bobstopper> (in theory)
01:45:09 <musasabi> Bobstopper: except linux GHC would have linux versions of libraries installed calling linux libc...
01:45:40 <phr-newbie> so is there a way to have the compiler make code to automatically notice Int overflow and raise an error?
01:46:00 <phr-newbie> i think a serious language needs to have unboxed ints
01:46:12 <phr-newbie> but at the same time it should check for overflow
01:46:12 <weitzman> > (maxbound :: Int) + 2
01:46:13 <lambdabot>  Not in scope: `maxbound'
01:46:28 <phr-newbie> > maxbound
01:46:28 <lambdabot>  Not in scope: `maxbound'
01:46:32 <ThreeQ> > (maxBound :: Int) + 2
01:46:33 <lambdabot>  -2147483647
01:46:34 <Bobstopper> yeah... that might be a problem... :(
01:47:00 <weitzman> The only language I know of that checks for overflow is SML
01:47:09 <phr-newbie> SML checks for overflow?  i didn't know that
01:47:09 <ThreeQ> is there any case in which you'd want ints to silently overflow?
01:47:19 <musasabi> yes.
01:47:27 <phr-newbie> ThreeQ sure
01:47:31 <int-e> not many but you often don't want the overflow check overhead.
01:47:34 <phr-newbie> but there should be a special type for that
01:47:48 <musasabi> The Haskell way is 1) use Int if you need it, 2) use Integer if the numbers might overflow, 3) Use a newtyped Int with overflow checking if you  really need that.
01:47:58 <skew> if you want overflow handled, use Integer
01:48:18 <phr-newbie> Integer doesn't "handle" overflow, it just doesn't overflow at all
01:48:20 <skew> GHC is pretty good about unboxing stuff that works on small integers
01:48:40 <musasabi> "newtype OverflowInt = O Int" "instance Num OverflowInt where (O a) + (O b) = ...; ..."
01:48:42 <phr-newbie> like if I have a record with three Integers in it, it doesn't use unboxed fixnums even when the three integers are all small
01:49:10 <musasabi> Are you having actual problems with real-world code?
01:49:14 <int-e> that's because Integer has several representations, so it can't be unboxed.
01:49:50 <phr-newbie> musasabi, crappy old 32-bit C programs that have worked for years are crashing right and left, now that files and network streams have gotten larger than 2**32 bytes
01:49:57 <musasabi> int-e: actually one could use unboxed integers inside a special loop, but that is rarely worth the effort.
01:50:20 <musasabi> phr-newbie: thus use Integer and don't worry about it.
01:50:34 <weitzman> I think I've heard it claimed by a semi-reliable source that integer overflows are the most common security problems in code
01:50:52 <phr-newbie> integer overflows?   nah, buffer overflows, where someone didn't check a subscript
01:51:07 <phr-newbie> musasabi, using Integers all over has horrendous overhead
01:51:10 <weitzman> Well, but realistically people add numbers more often than they index
01:51:19 <musasabi> phr-newbie: really? Have you tried it?
01:51:20 <weitzman> And they rarely check for overflow
01:51:55 <weitzman> Where I was working this summer, manually checking for overflow was required for every arithmetic operation
01:51:59 <phr-newbie> musasabi, sure, fixnum declarations are essential to making common lisp programs run acceptably
01:52:46 <musasabi> but for most Haskell programs the Integer -> Int does not affect performance very much. Of course there are exceptions to this.
01:53:18 <phr-newbie> yeah, well that's because haskell has horrendous overhead to begin with ;),   I mean it's a great language but it's not aiming to be a C replacement
01:53:26 <musasabi> just use "type Foo = <whatever>" and that will make changing things easier in future. (or even newtype if you have newtype deriving)
01:53:44 <weitzman> phr-newbie: Haskell used to have pretty competitive performance in the great shootout
01:53:49 <phr-newbie> musasabi the issue isn't changing, it's using fixnums to begin with, and not getting silent errors if there's an overflow
01:53:58 <phr-newbie> weitzman, "competitive performance" meant 3x slower than C :)
01:54:13 <phr-newbie> "C replacement" means FASTER than C, or at worst 1.1x slower or something like htat
01:54:15 <int-e> weitzman: in all fairness though, many of those shootout entries aren't pretty.
01:54:25 <ThreeQ> does the shootout code use bytestring?
01:54:31 <musasabi> phr-newbie: I don't know. Currently I get over 1000 requests / second from a Haskell web app thing with lots of other things loading the same machine and not all optimization turned on.
01:54:47 <int-e> I guess they still use ghc 6.4.1 or .2 with no additional libs.
01:54:51 <int-e> so, no bytestring.
01:55:07 <int-e> but I haven't followed it recently.
01:55:14 <skew> Integer compiles to unboxed fixnum manipulation plus overflow checks
01:55:16 <phr-newbie> musasabi i can't figure out what that means without specifics, i mean did you compare it against OKWS or something like that?
01:55:56 <phr-newbie> skew is that right?  hmm
01:56:02 <weitzman> Has anyone tried to make an JIT for Haskell?
01:56:05 <weitzman> *a
01:56:14 <phr-newbie> how can it know if it's promoted to bignum without a tag?
01:56:34 <lisppaste2> skew annotated #27448 with "if you have a *really* fast computer" at http://paste.lisp.org/display/27448#10
01:56:36 <phr-newbie> weitzman why use a JIT if you can static compile?
01:57:03 <weitzman> Because a JIT can outpeform a static compile while letting you use nice bytecode?
01:57:24 <skew> phr-newbie: by branching to the section of code that handles bignums
01:57:52 <weitzman> Although I don't think any JITs today will do better than compiling on the machine you'd run on
01:57:57 <phr-newbie> what's liftM2?
01:58:04 <weitzman> But it's not hard to do better than compiling long in advance on another machine
01:58:18 <ThreeQ> ?type liftM2
01:58:18 <musasabi> phr-newbie: no I haven't benchmarked it against okws, and that is probably faster since we currently don't use epoll (to avoid a dependency on network-alt).
01:58:19 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:58:28 <ThreeQ> ?type liftM2 (++)
01:58:29 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
01:58:33 <skew> I like my numbers code. Anybody have a system fast enough to print 1000000 with it?
01:58:36 <weitzman> If you JIT, you know cache sizes and specific architecture details and all that good stuff
01:58:49 <phr-newbie> weitzman hmm
01:59:00 <musasabi> phr-newbie: usually algorithmic optimization is the really important way.
01:59:05 <phr-newbie> i mean gcc does a lot of complex optimizations that make the compiler pretty slow
01:59:32 <phr-newbie> musanabi i don't get it, say x is an Integer, represented as a fixnum in the middle of some record
01:59:37 <phr-newbie> and you add 3 to it and it overflows
01:59:41 <phr-newbie> what happens to that slot in the record?
02:00:03 <musasabi> phr-newbie: values are immutable.
02:00:21 <musasabi> phr-newbie: we are talking about Haskell ;)
02:00:23 <weitzman> phr-newbie: I don't know too much about how gcc optimizes, but I suspect it uses traditional dataflow analysis because it's easier to formulate the algorithms and nobody really cares about the speed of gcc
02:00:46 <ThreeQ> hmm, could you use runtime information to do more aggressive optimizations?
02:00:59 <ThreeQ> like auto-memoize functions that get called a lot with similar values
02:01:00 <weitzman> JITs and some other compilers do graph-based reductions
02:01:00 <skew> actually, a faster replacement for sequence _ !! _ would probably make my code practical
02:01:03 <ThreeQ> I guess that would add overhead though
02:01:10 <phr-newbie> 3q, yeah, that's called profile-directed optimization
02:01:57 <phr-newbie> skew i don't understand what that's doing
02:02:00 <skew> heh
02:02:20 <ThreeQ> nice perlskell there, skew =P
02:02:33 <skew> map (unwords . filter (not.null)) (sequence lots) would be a list of all the numbers
02:02:42 <skew> and then I index out the one you wanted.
02:03:01 <phr-newbie> > type? unwords
02:03:02 <lambdabot>  Parse error
02:03:07 <phr-newbie> > ?type unwords
02:03:07 <lambdabot>  Parse error
02:03:18 <ThreeQ> ?type unwords
02:03:19 <skew> > unwords ["some","words","in","a","list"]
02:03:20 <lambdabot> [String] -> String
02:03:21 <lambdabot>  "some words in a list"
02:03:30 <phr-newbie> aha
02:03:45 <phr-newbie> > unwords ["a","","b"]
02:03:46 <lambdabot>  "a  b"
02:04:01 <skew> that's what the filter (not.null) takes care of
02:04:35 <phr-newbie> > null ""
02:04:37 <lambdabot>  True
02:04:39 <phr-newbie> ic
02:05:57 <lisppaste2> skew annotated #27448 with "now with performance!" at http://paste.lisp.org/display/27448#11
02:06:15 <skew> yay! just a little bit of optimizing was enough
02:08:30 <phr-newbie> skew, your 10**60 bug was you have quadr in your bignames list twice ;)
02:09:04 <phr-newbie> hah, i have it twice, yours is pasted from mine :)
02:09:14 <phr-newbie> fixed
02:10:00 <phr-newbie> i still don't understand what liftM2 does ?
02:10:15 <lisppaste2> skew annotated #27448 with "properly generic" at http://paste.lisp.org/display/27448#12
02:10:25 <musasabi> liftM2 f a b = do x <- a; y <- b; return (f x y)
02:10:50 <weitzman> skew: But your use of !! has been very limiting on how big numbers can be, somewhat defeating the purpose
02:10:52 <phr-newbie> that's different from f a b?
02:11:07 <ThreeQ> it's f a b except inside a monad
02:11:11 <skew> weitzman: see the most recent paste, with (!!) = genericIndex
02:11:12 <musasabi> phr-newbie: think of the types.
02:11:24 <musasabi> @type (\f a b -> f a b)
02:11:26 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
02:11:27 <weitzman> Oh, I'll download the latest patch
02:11:32 <phr-newbie> what's the monad for?
02:11:42 <musasabi> @type (\f a b -> do x <- a; y <- b; return (f x y))
02:11:43 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a2 -> a1 -> a) -> m a2 -> m a1 -> m a
02:11:46 <skew> liftM2 happens to be the same as zipWith on the lists
02:12:02 <skew> @type liftM2 undefined "hi"
02:12:03 <lambdabot> forall a2 r. [a2] -> [r]
02:12:14 <skew> > liftM2 (+) [1,2,3] [4,5,6]
02:12:16 <lambdabot>  [5,6,7,6,7,8,7,8,9]
02:12:21 <skew> wait, it's not
02:12:35 <phr-newbie> > zipWith (+) [1,2,3] [4,5,6]
02:12:37 <lambdabot>  [5,7,9]
02:12:37 <skew> rather, liftM2 f as bs == [f a b | a <- as, b <- bs]
02:12:46 <ThreeQ> yeah, it adds up all the combinations
02:12:59 <skew> [a + b | a <- [1,2,3], b <- [4,5,6]]
02:13:15 <skew> > [a + b | a <- [1,2,3], b <- [4,5,6]]
02:13:16 <ThreeQ> > [a + b | a <- [1,2,3], b <- [4,5,6]]
02:13:16 <lambdabot>  [5,6,7,6,7,8,7,8,9]
02:13:17 <lambdabot>  [5,6,7,6,7,8,7,8,9]
02:13:24 <dons> phr-newbie: oh, on an earlier comment, haskell is aiming to be a C replacement, in some areas. e.g. OS kernels. and as weitzman mentioned, we average 1.2x C in the language shootout, without even using bytestring. and the cost of Integer is really rather good.
02:13:26 <phr-newbie> why use a monad for that?
02:13:36 <phr-newbie> dons hmm interesting
02:13:48 <skew> because liftM2 saves a few chars :)
02:13:58 <Azmo> if want a state that contains some variables of different types, then using a structure (single constructor) seems inefficient because of the immutability, so.. should i just an array of dynamic, or is there something better?
02:14:13 <dons> rumours of poor performance are remnants of a bygone era, before we all used ghc
02:14:26 <musasabi> and 6.6 is faster than 6.4 on pure Int computations too.
02:14:49 <skew> like back when runtimes were graph reduction engines based off bytecode, or some such nonsense
02:14:53 <dons> yeah. lots of cool new optimisations are starting to work in ghc, now that the rules framework is getting really pushed on.
02:15:05 <dons> skew: yeah. exactly that.
02:15:08 <phr-newbie> does 6.6 have that STM concurrency stuff? and is there a parallel GC or anyone working on it?
02:15:19 <dons> grab 6.6, you've got smp ghc right there
02:15:20 <profmakx> sry
02:15:24 <dons> with STM if you want it.
02:15:46 <phr-newbie> yeah i read the STM paper and it said there was still a stop-the-world single threaded GC
02:15:46 <dons> i.e. you can run high perf parallel arrays now, on a 40 cpu sparc server, and use all 40 cpus :)
02:15:55 <skew> dons: as if it wasn't bad enough writing C, you've forced those poor programmers to explicitly manage their buffers if they want to compete with ByteString
02:15:56 <dons> that's being worked on too.
02:16:04 <dons> skew: heh
02:16:31 <skew> phr-newbie: I was aiming to make the majority of the program the list of word bits
02:16:42 <phr-newbie> skew :)
02:17:07 <dons> i think the multithreaded GC may even be working in its branch?
02:17:27 <weitzman> Does haskell have a multiline commet?
02:17:29 <skew> this is the multithreaded stop-the-world GC, right?
02:17:39 <dons> > 1 + {- some stuff -} 2
02:17:41 <lambdabot>  3
02:17:46 <weitzman> Awesome
02:17:51 <phr-newbie> i like the replacement of !! with genericIndex, i think i understand it.  but why isn't it always that, if the compiler can figure out when hte indexes are always Ints anyway?  i mean why shouldn't !! take Integral a by default?
02:17:51 <skew> they nest too
02:18:27 <dons> > 1 + {- some {- more {- stuff -} -} -} 2
02:18:28 <lambdabot>  3
02:18:33 <skew> phr-newbie: because then newbies get scary messages about "type classes" and "no instance Integral foo" instead of "foo isn't Int" when you screw things up
02:18:39 <skew> or so language designer people worry
02:18:47 <dons> at least they did worry :)
02:19:07 <skew> just roll a little IRC client into the error message and things would be ok
02:19:10 <Azmo> sorry to bother you all, but does anyone have an answer to my question? :-/
02:19:21 <phr-newbie> azmo what question?
02:19:24 <dons> skew: heh
02:19:27 <Azmo> if want a state that contains some variables of different types, then using a structure (single constructor) seems inefficient because of the immutability, so.. should i just an array of dynamic, or is there something better?
02:19:48 <skew> array of dynamic sounds like a really bad idea.
02:20:08 <skew> A good rule of thumb is not to worry about constant factors like indexing a constructor field until it really matters
02:20:08 <Azmo> skew: why?
02:20:19 <skew> because then you lose any type-checking around it
02:21:24 <skew> oh, your state consists of several pieces, which change independently?
02:21:35 <Azmo> skew: but what about the copying of all the pointers? the constructor holds all the values by pointers, right? it's boxed?. i only need one state, copying all the pointers to create a new state just because i want to update a value seems slow.
02:21:37 <phr-newbie> hah i think i understand "hundred", i.e. the liftM2 cross product
02:21:39 <Azmo> skew: yes
02:21:47 <skew> then you might want to use a fixed constructor of IORefs
02:22:02 <skew> and anyways, it's just copying some tens of bytes
02:22:11 <phr-newbie> hundred = ["one","two",...,"eleven",...,"ninety-nine"]
02:22:22 <skew> likewise for thousand
02:22:33 <skew> liftM2 (,) is a cross product of lists
02:22:53 <Azmo> skew: thanks for the help.
02:23:03 <skew> Azmo: you've newtyped your monad, right?
02:23:37 <skew> then it should be easy to change from State bigRecord to StateT bigRecordOfRefs IO
02:23:38 <Azmo> skew: hm... does that matter?
02:24:04 <skew> If you didn't at least make a type synonym, you'll have more changes to make
02:24:58 <skew> phr-newbie: and seqIx list ix == sequence list !! ix, except you don't have to generate all the things inbetween first
02:28:23 <skew> phr-newbie: one way of looking at this sequence stuff is to think of the english names as something like a positional system
02:28:57 <skew> execpt in base 1000, with a different set of digit glyphs for each position
02:30:55 <araujo> morning
02:31:02 <phr-newbie> yeah there's all these builtins that i'm unfamiliar with and it makes that program hard to read
02:31:17 <skew> builtins? these are all from the libs
02:31:20 <phr-newbie> python has all these annoying obstacles that got me interested in haskell, but python code is pretty readable
02:31:27 <skew> you could write them yourself.
02:31:36 <skew> if you don't read the library docs very carefully, you probably will
02:31:38 <phr-newbie> well ok, built into the libs :)
02:32:27 <phr-newbie> so does anyone write proof systems in haskell like they do in ML?
02:32:36 <dons> phr-newbie: yeah. theres _heaps_
02:32:55 <dons> i think maybe most new theorem provers are written in haskell
02:33:20 <phr-newbie> i'm not finding heaps
02:33:33 <phr-newbie> but googling for "heaps proof haskell" hits a paper called "haskell is not ML"  heh
02:33:38 <dons> here, http://haskell.org/haskellwiki/Libraries_and_tools/Theorem_provers
02:33:41 <lambdabot> Title: Libraries and tools/Theorem provers - HaskellWiki, http://tinyurl.com/kfmhl
02:33:48 <dons> not not ML, you mean.
02:34:02 <phr-newbie> http://research.microsoft.com/~simonpj/papers/not-not-ml/not-not-ml.pdf#search=%22heaps%20haskell%20proof%22
02:34:04 <lambdabot> http://tinyurl.com/fk6mw
02:34:05 <dons> even our lambdabot has a proof system :)
02:34:23 <dons> ?djinn a -> b -> Maybe (Either a b)
02:34:24 <lambdabot> f a _ = Just (Left a)
02:35:10 <earthy> ?djinn (Eq (f a), Functor f) => (a -> b) -> f a -> f b -> Bool
02:35:10 <lambdabot> Cannot parse command
02:35:20 <phr-newbie> > ?type Just
02:35:20 <lambdabot>  Parse error
02:35:25 <earthy> ?djinn (a -> b) -> f a -> f b -> Bool
02:35:26 <lambdabot> f _ _ _ = False
02:35:37 <earthy> interesting. ;)
02:35:40 <dons> :)
02:35:58 <dons> ?djinn (a -> b) -> (c -> b) -> Either a c -> b
02:35:58 <lambdabot> f a b c =
02:35:58 <lambdabot>   case c of
02:35:58 <lambdabot>   Left d -> a d
02:35:58 <lambdabot>   Right e -> b e
02:36:36 <earthy> ?djinn (a -> b) -> f a -> f b -> [f b]
02:36:37 <lambdabot> -- f cannot be realized.
02:36:55 <dons> ?free map
02:36:57 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
02:36:58 <weitzman> djinn doesn't know lists, so I'm told
02:37:01 <dons> ?free sortBy
02:37:03 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
02:37:07 <earthy> djinn doesn't know functors or classes
02:37:11 <dons> right
02:37:13 <earthy> ?free swap
02:37:14 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `swap'\n\n"
02:37:22 <dons> it does do lists but its a bit awkward
02:37:49 <earthy> ohwell
02:38:01 <earthy> back to figuring out how to have ghc generate a mac os x app
02:38:08 <int-e> hmm, it could treat lists like () ... whenever a list is needed, use [].
02:38:10 <earthy> with libraries in the .app
02:38:11 <phr-newbie> are there any program annotation tools that let you attach proofs to functions, that the tool can verify?  i think those have been done in ML
02:38:32 <dons> there's the new Extended Static Checking tool
02:38:44 <dons> and a few others. the haskell equational reasoning assitant
02:38:48 <dons> mm. programmatica too
02:38:50 <dons> and Agda
02:39:02 <skew> and Epigram
02:39:26 <phr-newbie> this paper looks prety interesting (the one about haskell not being ML)
02:39:43 <araujo> phr-newbie, link?
02:39:52 <phr-newbie> http://research.microsoft.com/~simonpj/papers/not-not-ml/not-not-ml.pdf
02:39:54 <lambdabot> http://tinyurl.com/mzhas
02:39:59 <phr-newbie> not not ml i mean
02:40:05 <phr-newbie> heheh i didn't spot that at first
02:40:21 <phr-newbie> not not ml => the paper shows sort of an isomorphism between haskell and ml
02:41:02 <dons> there's also the modules == typeclasses + associated types papers
02:41:47 <skew> but that doesn't have any cunning implementation tricks
02:42:57 <skew> In the not not ml paper they have the constructor-tag-picker in the ML compiler innocently happening to select numbers whose bit patterns just happen to match that of pointers to the info tables GHC makes
02:43:40 <phr-newbie> man this is too abstruse for me.  there's a book by pierce about type systems that i've heard helps understand this stuff
02:44:01 <phr-newbie> types and programming languages
02:44:27 <dons> yeah, TaPL is highly recommended
02:44:29 <dons> also:
02:44:32 <dons> ?where plbook
02:44:33 <lambdabot> http://www-2.cs.cmu.edu/~rwh/plbook/
02:44:54 <phr-newbie> a friend of mine has TaPL and says i can borrow it, i need to drive over and get it from him sometime
02:45:02 <dons> understanding programming languages is good for programmers :)
02:45:06 <dons> its like learning your editor.
02:45:40 <phr-newbie> i've implemented lisp but this FP stuff seems to have a much steeper and longer learning curve
02:46:21 <phr-newbie> this rwh book looks neat
02:46:50 <dons> well lisp is the state of FP 30 years ago. lots of cool new things have been done since then :)
02:46:58 <phr-newbie> :)
02:48:29 <dons> its not just FP though. the basic technologies are in most languages, its just the more sophisticated stuff that isn't as wide spread
02:48:48 <dons> though they're getting there. see perl6, for example
02:49:07 <dons> or, as Larry Wall said recently, Perl is turning into Haskell.  Someone shoot me.
02:49:19 <phr-newbie> lol
02:49:25 <lray> Hi. Am an bloody Haskell-Beginner and desperating on Text.Regex. As much as I understood, matchRegexAll (mkRegex ".*(.).*") "mami" should return something like Just ("mam","i","",["i"]), right?
02:50:02 <dons> ?type matchRegexAll
02:50:03 <lambdabot> Not in scope: `matchRegexAll'
02:50:13 <dons> ?type Text.Regex.matchRegexAll
02:50:15 <lambdabot> Text.Regex.Posix.Regex -> String -> Maybe (String, String, String, [String])
02:50:25 <dons> lray: yep :)
02:50:43 <skew> I think Just ("","mami","",["i"])
02:51:12 <dons> lray: here's an example, http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Eval.hs (scroll down a bit)
02:51:14 <lambdabot> http://tinyurl.com/gve2x
02:51:27 <skew> when the docs say Just ( everything before match, portion matched, everything after the match, subexpression matches )
02:51:32 <dons> yep
02:52:01 <skew> "matched" means matched by the whole regular expression, which is ".*(.).*" for you
02:55:54 <skew> phr-newbie: I'm treating the english notation as a perfectly regular base 10^63 system, with the slight peculiarity of a visible digit separator, "vigintillion"
02:56:17 <lray> okay, understood. So I get, lets say,  every letter out of the string by mkRegex "(.)"
02:56:38 <lray> -> sorry. Now I got it... thnx!!!
02:56:47 <skew> that just gets one - the . matches a single character. ".*" would match everything
02:57:02 <skew> and you don't need to use () if you just care about the whole match
02:57:53 <lray> nice. thanks fot the hint.
02:57:59 <lisppaste2> skew annotated #27448 with "arbitrary numbers" at http://paste.lisp.org/display/27448#13
02:59:49 <musasabi> What was the way to tell Cabal to generate bat-files required for registering a package later on windows?
03:00:19 <musasabi> register --gen-script :-)
03:01:42 <phr-newbie> skew :)
03:01:49 <phr-newbie> but you should also use centillion
03:01:54 <phr-newbie> which gives you a variable base system
03:02:38 <phr-newbie> i think i'll write my PGP key that way ;-)
03:07:03 <phr-newbie> so this harper book, is it presenting stuff familiar to the PL crowd, or is he making it up as he goes along?
03:08:01 <phr-newbie> i mean it looks like mathematical logic but the terminology is all new
03:08:04 <phr-newbie> to me
03:08:10 <dons> phr-newbie: its the standard stuff
03:08:19 <dons> (from one of the key figures in the community, btw)
03:08:37 <phr-newbie> hmm ok
03:08:41 <dons> i tutor a course based on the book.
03:08:44 <dons> let me find the slides
03:09:04 <dons> here you go, http://cgi.cse.unsw.edu.au/~cs3161/
03:09:43 <phr-newbie> what's MinHS?
03:10:16 <dons> a mini haskell we use to teach the course
03:10:27 <dons> the students write it as they go along
03:10:33 <phr-newbie> tell me seriously, if you wanted to write a full featured web browser from scratch with the idea of replacing firefox, would you write it in haskell?
03:10:43 <dons> yep.
03:10:54 <phr-newbie> cool
03:11:19 <dons> you'd want to know your haskell though. i'd certainly only consider haskell for such a task
03:11:48 <dons> a huge project like that would _need_ things like static typing and good testing tools (like QuickCheck) to hold it all together
03:11:52 <dons> and get it done in a reasonable time
03:11:53 <Bobstopper> I've been toying with the idea of writing an alternative for the web. I plan to do that in haskell.
03:12:32 <phr-newbie> what about if you wanted to rewrite (gag) Microsoft Word?  same thing pretty much, i guess
03:12:52 <dons> same thing. see yi :)
03:12:54 <dons> ?where yi
03:12:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
03:13:03 <dons> (well, not quite the same thing. but I mean: how hard is an editor)
03:13:10 <ulfdoz> yet another notepad-clone? :)
03:13:14 <dons> applications programming is something haskell excels at
03:13:18 <dons> a vim clone
03:13:42 <cdfh> dons: vim needs a clone
03:13:50 <dons> heh
03:13:52 <ulfdoz> That would be too usefull for a MS Word. ;)
03:13:53 <cdfh> i dislike the way vim is programmed :-)
03:14:00 <phr-newbie> well one of the things that pisses me off about python weenies is that they love to say "python is powerful, an xyz program has been written in it" but it's always a toy version of xyz, the really full blown ones are written in other languages
03:14:05 <dons> i dislike vimscript (with an intensity)
03:14:12 <ulfdoz> I dislike vim's user-interface.
03:14:14 <cdfh> dons: yes, it is awfull
03:14:15 <phr-newbie> i mean, their version of word is notepad, their version of a browser is grail, etc.
03:14:21 <cdfh> ulfdoz: it is great! ;-P
03:14:46 * cdfh imagines a vim in Lisp or Haskell
03:14:48 <cdfh> *drool*
03:14:52 <ulfdoz> cdfh: It's not really intuitiv to use. Even emacs is better in this regard.
03:14:58 <dons> cdfh: yi :) that's the point ;)
03:15:03 <cdfh> ulfdoz: bah! ;-P
03:15:14 <dons> but its a one man show, so only slowly moving along. it does vi pretty well now.
03:15:31 * cdfh looks at yi
03:15:43 <dons> ulfdoz: intuitive is for people who can't read docs :)
03:16:04 * earthy pukes at the docs for apple's ld
03:16:13 <dons> earthy: hehe.
03:16:13 <Bobstopper> I thought yi was supposed to have a pluggable interface or something allowing it to act like emacs or anything else? Or is vim like that?
03:16:28 <dons> Bobstopper: yep that's what it does. use --emacs or --nano or --mg or so on
03:16:31 <phr-newbie> what do you mean by act-like-emacs?  like, use the same keyboard commands to move the cursor?
03:16:36 <dons> yeah
03:16:41 <ulfdoz> dons: Oh, vim's documentation. Either I don't find the right keywords or I use the right keywords but get the wrong section or the feature as a very strange name.
03:16:46 <dons> the key binding stuff is just a lexer plugin
03:16:48 <Bobstopper> yeah, sorry. Not elisp obviously :)
03:16:50 <vegai> dons: does tab do what tab does :)
03:16:59 <vegai> (in yi and emacs, respectively)
03:17:02 * Igel is away: Faraway
03:17:06 <dons> vegai: it could.
03:17:15 <phr-newbie> well is there anything like a read-eval-print loop that you can type haskell statements into?
03:17:18 <cdfh> dons: yi looks good :-)
03:17:23 <Bobstopper> If it'll be as extensible as emacs then I'm sold :P
03:17:25 <earthy> all I want to do is link to @executable-path/../Resources/libsmilec.dylib!
03:17:26 <dons> phr-newbie: ghci? ghc-api?
03:17:36 <phr-newbie> i mean a repl in yi
03:17:43 <phr-newbie> so you can write editing commands while you're editing
03:17:54 <dons> ah no. that's a big todo. in general, embeddable haskell is a research issue still
03:17:58 <phr-newbie> i mean the original emacs was written in TECO :)
03:18:02 <phr-newbie> so elisp isn't a requirement :)
03:18:19 <earthy> emacs' name is short for 'editing macros' after all
03:18:34 <dons> hugs should come as a C library that can be embedded
03:18:43 <dons> that would be one of the lightest, easiest ways to embed haskell scripting
03:18:51 <phr-newbie> is that notion crazy?
03:19:02 <skew> how about just importing the GHC api, if you're building with GHC?
03:19:22 <dons> yeah. yi 2 is a sketch we have just running on top of ghci
03:20:16 <phr-newbie> it looks like hugs is 500k+ program text plus 3+ mb of bss
03:20:29 <phr-newbie> in the static build
03:20:31 <phr-newbie> dunno what it loads
03:20:45 <phr-newbie> is it feasible to write a really small haskell interpreter?
03:21:10 <phr-newbie> e.g. can haskell map onto a scheme subset in some natural way?
03:21:29 <dons> nhc is pretty small
03:21:35 <dons> since it was designed for embedded systems
03:21:50 <phr-newbie> also timber i guess
03:22:11 <phr-newbie> http://haskell.org/nhc98/   this looks neat
03:22:11 <dons> (i've seen nhc running haskell binaries on a tiny credit-card sized arm card)
03:22:12 <lambdabot> Title: nhc98
03:23:28 <phr-newbie> i'd like to fool with this.  i never understood lisp until i read the emacs lisp source code
03:23:47 <vegai> and there's yhc
03:24:55 <dons> mm. new tutorial , http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
03:24:58 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
03:25:16 <phr-newbie> Yhc is a Haskell 98 Compiler. Based on nhc98, but with an entirely rewritten backend, it takes lots of good features from nhc98, and adds lots of new ones.
03:25:40 <phr-newbie> monad transformers must be incredibly confusing, it seems everyone wants to write another tutorial :)
03:25:49 <dons> ThreeQ: you could probably post the monad transformers tut to reddit.
03:25:53 <Bobstopper> Transformers would be nicer if they didn't require lift $ lift $ lift $ lift $ lift ...
03:26:02 <dons> phr-newbie: nah, they're not too bad. you saw the irc tut?
03:26:27 <dons> better to write a wrapper for that. i.e. io = liftM . liftIO or what have you.
03:26:36 <phr-newbie> irc tut?  no
03:26:55 <Bobstopper> true
03:26:59 <dons> let's see if google knows about it yet..
03:27:04 <dons> ?google roll your own irc bot
03:27:07 <lambdabot> http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
03:27:07 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
03:27:09 <dons> yay!
03:28:25 <phr-newbie> oh neat
03:28:37 <phr-newbie> i've been wanting for a while to write an irc proxy
03:29:26 <phr-newbie> i'm getting really sleepy, i want to read this later
03:29:52 <phr-newbie> this looks really useful
03:30:12 <phr-newbie> i've avoided trying to figure out the "do" statement b/c i haven't boned up on monads
03:32:18 <skew> It's just like the sequences of statements in other languages
03:32:35 <skew> except very rarely have they thought so deeply about what that sequencing means
03:33:19 <dons> ?remember skew [monads are] just like the sequences of statements in other languages. Except very rarely have they thought so deeply about what that sequencing means
03:33:29 <phr-newbie> so there's this god awful network format, full of these arcane nested data structures full of bit fields saying what the next structure is
03:33:44 <phr-newbie> is that stuff easy to parse with haskell?  it's one thing C has been pretty decent at
03:33:57 <skew> for that, it sounds like you should write a minilanguage for parsing god-awful network formats
03:34:06 <phr-newbie> yeah
03:34:22 <skew> build on this, maybe: http://www.imperialviolet.org/binary/bitsyntax/
03:34:25 <lambdabot> http://tinyurl.com/ospjv
03:34:39 <dons> some interesting comments here, http://programming.reddit.com/info/l434/comments
03:34:40 <phr-newbie> nice
03:34:41 <lambdabot> Title: Ask Reddit: Erlang, Haskell, OCaml; which functional language and why? (reddit.c ..., http://tinyurl.com/fjrx2
03:34:56 <phr-newbie> oh yeah we were discussing that earlier, i read it a few hours ago unless more has been added
03:35:16 <phr-newbie> i had the same dilemma and picked haskell mostly because of the STM paper
03:35:20 <phr-newbie> well partly
03:36:07 <phr-newbie> this paragraph scares me
03:36:08 <phr-newbie> Haskell is a lot like Perl: It's really, really succinct and expressive, and you can do all sorts of neat tricks. It's perfect for expressing algorithms. However, it has no good facilities for structuring large systems. Haskell programs are like clockwork: everything has to go together just right.
03:36:13 <skew> so the difference between do notation and something like (begin ...) is that you can pick what it is you're sequencing
03:36:23 <dons> yeah, i don't agree with that.
03:36:34 <dons> haskell doesn't win the icfp contest every year with "clockwork"
03:36:40 <skew> I asked before, are there any languages where the program doesn't all have to go together just right?
03:36:40 <fasta> Can I annotate an expression such that it will be remembered through procedure calls?
03:36:41 <dons> it wins because its easy to build large systems quickly
03:36:55 <phr-newbie> icfp isn't about large systems
03:36:56 <dons> skew: right. its a kind of meaningless statement
03:37:02 <skew> fasta: like so evaluation will be shared?
03:37:13 <dons> phr-newbie: well 5k in 3 days. then scale up to 300k ghc or what have you
03:37:17 <fasta> skew: I think so
03:37:23 <phr-newbie> i've come to believe python isn't so hot for large systems, despite the claims of its proponents
03:37:25 <qz> dons, its not haskell winning icfp contest
03:37:26 <qz> people do
03:37:37 <qz> let those people use other language, and they'll win it too
03:37:44 <fasta> skew: I am now recalculating a value in a lot of procedures, but I could also thread it through the computation.
03:37:44 <phr-newbie> ghc is 300kloc????
03:37:53 <dons> haskell's full of tools for programming in the large. laziness and monads and static typing and abstract data structures
03:38:13 <phr-newbie> packages?  modules?
03:38:15 <skew> fasta: if it's actually the same value, I think you can get it shared by putting it in a where clause
03:38:20 <fasta> Only debugging tools lack, imho.
03:38:26 <phr-newbie> yeah, debugging tools?  :)
03:38:33 <dons> phr-newbie: its pretty big.
03:38:42 <fasta> skew: it's used by function at the toplevel.
03:38:49 <fasta> skew: er functions
03:38:51 <skew> munge your code into Isabelle like the microkernel people do?
03:38:54 <dons> that's true. good thing that bugs aren't a huge problem :)
03:39:01 <phr-newbie> how about dynamic loading?
03:39:09 <dons> that's easy enough.
03:39:14 <falseep> >type Data.Map.lookup
03:39:16 <dons> how do you think lambdabot loads it plugins? :)
03:39:19 <fasta> phr-newbie: you are talking to the expert in that area
03:39:23 <phr-newbie> cool :)
03:39:29 <skew> fasta: if it's really a constant, and you don't mind it not being garbage collected between calls you could declare it as a constant at the top level
03:39:45 <falseep> type Data.Map.lookup
03:39:46 <skew> otherwise I'm not so sure - maybe thread it through with a reader monad or something
03:39:49 <fasta> skew: it's a constant given input.
03:39:54 <dons> ?type Data.Map.lookup
03:39:55 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
03:40:00 <skew> ah, then you want Reader
03:40:18 <phr-newbie> yee ha, somebody wrote an x509 parser in haskell, wow
03:40:24 <fasta> skew: I don't know whether I want that, since I never used it
03:40:51 <phr-newbie> but no TLS stack
03:41:20 <dons> hey kowey
03:41:36 <fasta> phr-newbie: I can give a endless list of what other languages don't have (including Haskell).
03:41:36 <skew> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
03:41:38 <lambdabot> http://tinyurl.com/ona24
03:41:49 <fasta> skew: yes, I have the local documentation installed.
03:42:01 <kowey> hi dons, hey haskellers
03:42:07 <phr-newbie> The code has been tested on GHC 6.4. It does not currently work with Hugs
03:42:07 <phr-newbie> or NHC.
03:42:11 <skew> write your code in the monad, and you get this action "ask :: m r" that gives the value
03:42:14 <falseep> I can't figure out which (Monad m) does Data.Map.lookup use. It isn't Maybe?
03:42:23 <skew> falseep: any monad
03:42:26 <dons> fasta: it uses any :)
03:42:30 <dons> whichever you decide to use
03:42:41 <skew> that's why it says (Monad m) => ...
03:42:52 <phr-newbie> http://www-users.cs.york.ac.uk/~ndm/yhc/    can someone explain the speed graph in that page?
03:42:53 <lambdabot> Title: yhc - York Haskell Compiler
03:43:00 <falseep> an example?
03:43:11 <fasta> falseep: Maybe is a monad
03:43:17 <phr-newbie> oh i see
03:43:21 <skew> rather than just some monad. If there are any lowercase names, it should be read like "forall m, (Monad m) => ..."
03:43:29 <dons> > M.lookup 0 (M.singleton 1 "dons") :: Maybe String
03:43:31 <lambdabot>  Nothing
03:43:36 <dons> > M.lookup 1 (M.singleton 1 "dons") :: Maybe String
03:43:36 <phr-newbie> it really takes 12 seconds to compile a simple program with ghc?
03:43:37 <lambdabot>  Just "dons"
03:43:42 <falseep> I see. thanks
03:43:55 <dons> phr-newbie: heh. no. depends on what you're doing... :)
03:44:06 <kowey> falseep: it's not just a because-we-can thing either... it's actually been useful for me (once)
03:44:07 <dons> lambdaobt's compiling small programs with ghc all the time...
03:44:11 <dons> > 1+2 -- compile me now!
03:44:12 <lambdabot>  3
03:44:22 <dons> and its on a fairly loaded machine
03:44:37 <skew> > M.lookup 0 (M.singleton 1 "skew") :: [String]
03:44:38 <lambdabot>  []
03:44:42 <phr-newbie> can you see the asm code for 1+2 ?
03:44:58 <fasta> skew: but I also need to put the value there somehow.
03:45:01 <dons> yeah, with -ddump-cmm or -keep-tmp-files (they'll be in /tmp)
03:45:14 <phr-newbie> fair enough
03:45:31 <skew> fasta: to run a thing in reader, use runReader :: Reader r a -> r -> a
03:45:38 <dons> ?instances Monad
03:45:40 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:45:41 <skew> phr-newbie: usually -ddump-simpl is more informative
03:45:44 * earthy is either obviously stupid or obviously not looking in the right places
03:45:45 <fasta> skew: r is the constant here?
03:45:51 <fasta> skew: well the type of the constant
03:45:55 <skew> yes
03:46:22 <dons> > M.lookup 0 (M.singleton 1 "dons") :: Either String String
03:46:23 <lambdabot>  Left "Data.Map.lookup: Key not found"
03:46:27 <fasta> This "profiling" thing is pretty addictive, btw. :)
03:46:30 <skew> also, local lets you run a something under a modified environment, like adding an extra binding while typechecking a lambda or something
03:46:36 <dons> fasta: yeah, I agree :)
03:46:44 <dons> every language should come with heap profiling
03:46:56 <fasta> dons: I don't even use heap profiling.
03:47:08 <fasta> dons: I saw the Java tools for heap profiling... they are good.
03:47:27 <fasta> dons: they are shiny and informative, in short.
03:47:51 <skew> hey, has anyone written a mangler to get KCachegrind to display profiles of Haskell?
03:48:20 <dons> well, valgrind was written to test out ghc, right?
03:48:44 <vegai> huh?
03:48:47 <phr-newbie> ?
03:48:51 <ValarQ> it was?
03:48:53 <dons> yes
03:49:07 <dons> Julian Seward was writing the ghc native code generator, and wrote valgrind to test it
03:49:34 <vegai> Huh. That's not popular knowledge.
03:49:45 <dons> I think its on the valgrind home page .hmm.
03:49:46 <phr-newbie> interesting
03:49:47 <gds> http://www.google.com/codesearch -- Hoogle still wins in many ways - but not all.
03:49:48 <lambdabot> Title: Google Code Search
03:50:01 <vegai> not in the about page, at least
03:50:50 <dons> oh, i see valgrind is now tool of the year, or something. huh.
03:50:54 <phr-newbie> what's the shortest route to a "hello world" gui program in haskell?  one that shows a window with a "hello world" button that closes the window when you click it
03:51:24 <vegai> http://valgrind.org/docs/manual/mc-tech-docs.html#mc-tech-docs.history
03:51:27 <lambdabot> Title: Valgrind, http://tinyurl.com/kaaov
03:51:29 <vegai> there we go.
03:51:48 <phr-newbie> hehe i like the origami picture
03:51:49 <vegai> valgrind is an excellent tool when doing anything on C.
03:51:52 <kowey> phr-newbie: here's one - http://en.wikibooks.org/wiki/Haskell/GUI (wxhaskell); there are others
03:52:15 <vegai> It makes finding memory leaks bearable.
03:52:19 <vegai> Almost fun.
03:52:20 <phr-newbie> i remember trying to compile wxwindows and giving up after like hours
03:52:35 <phr-newbie> scuse me s/wxwindows/wxwidgets/
03:53:10 <earthy> phr-newbie: what platform?
03:53:20 <phr-newbie> linux
03:53:23 <dons> gtk2hs might be the better path now
03:53:31 <dons> in fact, on linux, it would be the recommended system
03:53:32 <earthy> there's packages for gtk2hs
03:53:42 <dons> ?where gtk2hs
03:53:42 <lambdabot> http://haskell.org/gtk2hs/
03:53:44 <earthy> dons: actually, on mac os x I prefer wxhaskell still
03:53:55 <earthy> as gtk+mac still isn't quite ready.
03:53:57 <dons> yeah, on the mac and windows, wx might still rule
03:54:23 <phr-newbie> what's  [text := "hello world"]  ?    is that some kidn of keyword args?
03:54:25 <phr-newbie> kind
03:54:31 * earthy nods
03:54:33 <skew> dons: Hey, that stuff about hacking :info to add docs for yi would be great for plain ghci too!
03:54:37 <earthy> 'kind of' :)
03:55:30 <dons> phr-newbie: write me a nice clock, http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
03:55:32 <lambdabot> Title: Gtk2Hs  Blog Archive  Cairo eye candy, http://tinyurl.com/lzqs2
03:56:01 <dons> skew: hmm!
03:56:40 <phr-newbie> looks nice
03:57:05 <skew> actually, I'm pretty sure the info tables will already get you the relevant name, module and package
03:57:20 <musasabi> How does one use on windows a haskell library depending on a C library? I have the C library DLL, but how does that help filling the -lfoo dependency?
03:58:14 <skew> phr-newbie: notice the theme of bothering to implement something a little more sophisticated and thus much faster, because it's easy.
03:59:09 <phr-newbie> yes, i'm quite familiar with that effect from writing in lisp or python instead of c :)
03:59:24 <skew> dons: so once you have a fully-qualified identifier you should be able to reference external docs pretty easily
04:00:43 <fasta> skew: It seems the where option was applicable.
04:01:07 <skew> ok
04:01:20 <skew> actually, implicit parameters might also do what you want
04:01:26 <fasta> skew: it could be that it doesn't get optimized, in that case I will still do it.
04:01:37 <fasta> skew: I don't want implicit parameters.
04:01:45 <fasta> skew: I saw those and they were a mess, imho.
04:01:53 <skew> if anything, where should be optimized better
04:02:13 <fasta> Well, it didn't.
04:02:34 <fasta> Or is this because I am compiling with profiling on? I hope not.
04:02:39 <skew> Reader is essentially adding an extra parameter to your functions
04:03:06 <skew> if you can use where, your functions should just be getting the value from an enclosing lexical scope
04:03:34 <skew> I suppose that could be slower in some cases, if you have spare registers lying around
04:04:41 <dons> skew: yeah. even unqualified we can do it (like the wiki markup does)
04:05:35 * mux tries to understand what the guys who designed JS smoked
04:06:07 <mux> JS closures are amazingly stupid
04:06:13 <dons> mux, did you see the JS invited talked at ICFP last year? it was a strange story
04:06:28 <mux> didn't see that
04:07:02 <mux> have a for (var i = 0; i < ...; i++) loop
04:07:13 <mux> have an inline function referencing i in that loop
04:07:13 <goltrpoat> is there something like a memberWith :: (k -> k -> Bool) -> Map k a -> Bool ?
04:07:38 <dons> ?hoogle (k -> k -> Bool) -> Map k a -> Bool
04:07:39 <lambdabot> No matches, try a more general search
04:07:41 <goltrpoat> in case the key type is Ord, but you'd rather not use that Ord
04:07:47 <mux> and enjoy realizing that whatever i was set to when you defined the inline function, if it gets called, i will be its last value after the loop finished
04:07:55 <dons> ah, memberBy or something?
04:07:57 <goltrpoat> yeah
04:08:01 <mux> now create another function and pass i to it
04:08:09 <mux> create the inline function inside that one
04:08:10 <mux> and it works
04:08:40 <skew> goltrpoat: the map is organized according to the Ord instance
04:09:15 <skew> you'd have to scan the whole thing anyway, might as well use elem and toList
04:09:24 <goltrpoat> yeah, i just realized how little sense this makes
04:09:25 <goltrpoat> heh
04:09:38 <goltrpoat> alrighty.. thanks
04:09:51 <skew> mux: sounds like what I'd expect, given that these variables are mutable.
04:10:09 <roconnor> @what fps
04:10:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
04:10:15 <skew> I mean, you're supposed to have access to the parent's lexical scope, right?
04:10:29 <yip> > let gnu == gnu ++ "'s not unix" in gnu
04:10:30 <lambdabot>  Parse error
04:10:34 <yip> > let gnu = gnu ++ "'s not unix" in gnu
04:10:36 <skew> it's not the fault of the closure design that JS is imperative
04:10:37 <lambdabot>  Exception: <<loop>>
04:16:26 * earthy shivers and puts the projects to cabalize Dazzle and get it to build into a full Mac OS X application on ice again
04:16:31 <yip> how do i get that to work? so i get a result: (((((((...)'s not unix)'s not unix)'s not unix)'s not unix)'s not unix)'s not unix)
04:17:09 <earthy> yip: you don't, as its left-recursive and infinite
04:17:23 <fasta> skew: I had one call to foo still lying around. With that one also referring to the value in the where clause it does work.
04:17:32 <yip> earthy: so how do i get that result?
04:18:08 <dons> prefix notation :) not unix (not unix (not unix ... ))
04:18:42 <earthy> > reverse . take 200 $ (let gnu = "'xinu ton s'" ++ gnu in gnu)
04:18:44 <lambdabot>  "ot unix''s not unix''s not unix''s not unix''s not unix''s not unix''s not ...
04:18:49 <earthy> *almost* :)
04:18:53 <dcoutts_> hia dons
04:19:28 <earthy> > reverse . take 200 $ (let gnu = "(xinu ton s'" ++ gnu in gnu)
04:19:36 <lambdabot>  "ot unix('s not unix('s not unix('s not unix('s not unix('s not unix('s not ...
04:19:40 <boegel> @arr
04:19:40 <lambdabot> Ahoy mateys
04:19:47 <earthy> > reverse . take 200 $ (let gnu = ")xinu ton s'" ++ gnu in gnu)
04:19:53 <dcoutts_> dons, so time for fixes to the paper...
04:19:53 <dons> > concat $ fix ("not unix (":)
04:19:57 <lambdabot>  "ot unix)'s not unix)'s not unix)'s not unix)'s not unix)'s not unix)'s not ...
04:19:59 <dcoutts_> dons, when will you have some time ?
04:20:00 <lambdabot>  "not unix (not unix (not unix (not unix (not unix (not unix (not unix (not u...
04:20:33 <dons> dcoutts_: hmm. when i get back from SF on the 18th?
04:20:42 <dons> when's the due date 24?
04:20:49 <earthy> > reverse . take 20 $ (let gnu = ")xinu ton s'" ++ gnu in gnu)
04:20:50 <lambdabot>  "ot unix)'s not unix)"
04:21:26 <fasta> How can I optimize this further? foo letter i j = Foo (concat [[letter],show i,"_",show j])
04:21:34 <dcoutts_> dons, 22nd
04:21:56 <dcoutts_> dons, SF? no time in between?
04:22:14 <int-e> > 'a' : shows 23 ('_' : show 42)
04:22:15 <lambdabot>  "a23_42"
04:22:47 <dons> > reverse . take 20 . fix $ (")xinu ton s'"++)
04:22:48 <lambdabot>  "ot unix)'s not unix)"
04:23:01 <dons> dcoutts_: hmm. ok. i'll have to do it next week.
04:23:04 <int-e> dons: cycle
04:23:13 <dons> > cycle "not unix ("
04:23:14 <lambdabot>  "not unix (not unix (not unix (not unix (not unix (not unix (not unix (not u...
04:23:20 <dcoutts_> dons, I should have some time next week.
04:23:41 <dcoutts_> dons, sorry, it's just that leaving it to the 18th makes me a little nervous
04:23:51 <dons> yes. we'll do it before then
04:23:56 <dons> should only take a day or two
04:24:18 <dons> i'll have time next week
04:25:21 <fasta> int-e: that's three times faster, ty.
04:27:17 <int-e> heh. three times is a bit more than I expected.
04:28:02 <fasta> Now, I only need to optimize a 86% cost-center....
04:29:01 * Igel is back (gone 01:11:59)
04:29:57 <fasta> Igel: I don't think auto back messages are appreciated here.
04:32:15 * SamB just types "/me is back" if he wants a "back message"
04:32:28 * boegel is back
04:32:29 <boegel> :P
04:33:42 <Igel> fasta: sry, my client did that automatically, i'll switch it off immediately
04:34:42 <fasta> shows "bar" "foo" gives: "bar"foo, is there also an efficient function that shows foobar?
04:34:50 <SamB> Igel: we aren't mad at you or anything ;-)
04:35:12 <skew> Mr. Spock estimates and frequently reports times to the second, why not Igel typeing /me is back...
04:35:24 <SamB> heh
04:35:37 <SamB> hmm
04:35:38 <skew> fasta: "foo"++"bar"?
04:35:50 <dons> skew: heh
04:36:03 <SamB> I bet mr spock is off a bit when he does that, if its been a while
04:36:04 <fasta> skew: right, it doesn't get any more efficient then that, I suppose.
04:36:14 <SamB> (because it takes so long to say!)
04:36:23 <fasta> skew: I had that first in my program...
04:36:37 * SamB thinks "foobar" is more efficient than "foo"++"bar"
04:36:50 <Phillemann> I'm pretty new to Haskell and I'm trying to use "Network" (in Linux). Yet it fails with the first statement "mySocket <- listenOn 3000" with "Couldn't match `(->) (IO a)' against `IO'"
04:37:13 <SamB> Phillemann: I think you need to pass more args to listenOn?
04:37:14 <skew> probably listenOn takes more parameters
04:37:17 <dons> ?type Network.listenOn
04:37:19 <lambdabot> Network.PortID -> IO Network.Socket.Socket
04:37:25 <boegel> @google A4 in inch
04:37:27 <lambdabot> http://en.wikipedia.org/wiki/Paper_size
04:37:29 <dons> or maybe missing layout?
04:37:29 <SamB> oookay...
04:37:31 <skew> it should section that type a bit less.
04:37:38 <SamB> Phillemann: or not!
04:37:48 <SamB> paste your program!
04:37:59 <SamB> does hugs have the Network module?
04:38:00 <dons> ?type connectTo
04:38:01 <lambdabot> Not in scope: `connectTo'
04:38:02 <SamB> @paste
04:38:02 <lambdabot> http://paste.lisp.org/new/haskell
04:38:08 <dons> ?type Network.connectTo
04:38:10 <lambdabot> Network.BSD.HostName -> Network.PortID -> IO GHC.IOBase.Handle
04:38:26 <Phillemann> SamB: Wait a moment, I'm playing around a bit. I removed "withSocketsDo" (I didn't understand it anyway).
04:38:45 <SamB> Phillemann: that does some stuff to make WINSOCK work
04:38:49 <dons> oh, are you missing a constructor, PortNumber 6666 -- ?
04:38:50 <SamB> it does nothing on Linux
04:39:00 <SamB> dons: nonono!
04:39:36 <SamB> or maybe...
04:39:46 <dons> i.e. like for connectTo. http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
04:39:49 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
04:39:56 <SamB> dons: oh, I suppose
04:40:01 <dons> (and to run in hugs you need a fromIntegral as well)
04:40:03 <Phillemann> Okay, new problem: accept mySocket returns "IO (Handle, HostName, PortNumber)" and I just want to print "HostName" (which is a string).
04:40:06 <Phillemann> How do I do that?
04:40:11 <SamB> I was thinking that was the constructor for the PortNumber type ;-)
04:40:29 <dons> do (_,name,_) <- accept ... ; print name
04:40:35 <Phillemann> Ah dons, that seems to be a very good document.
04:40:49 <dons> sounds like it might be close to what you're doing.
04:40:56 <phr-newbie> is there a way to turn a list into a tuple?  like [a,b,c] => (a,b,c)
04:40:57 <dons> though it forgets to mention withSocketsDo
04:41:08 <SamB> Philippa: don't you need the Handle too?
04:41:16 <dons> ?let wrap [a,b,c] = (a,b,c)
04:41:17 <lambdabot> Defined.
04:41:19 <Phillemann> dons: It is. I actually wanted to learn Haskell by doing, but if there's such a guide...
04:41:22 <SamB> er, Phillemann
04:41:22 <dons> > L.wrap "abc"
04:41:24 <lambdabot>  ('a','b','c')
04:41:30 <SamB> sorry again Philippa
04:41:31 <phr-newbie> thanx
04:41:37 <dons> Phillemann: sure. dive in to the irc bot tut :)
04:41:49 * SamB keeps doing that when he is trying to talk to Phillemann 
04:41:50 <phr-newbie> ??????  philip{pa,mann}
04:42:02 <SamB> phr-newbie: tab completion!
04:42:17 <phr-newbie> tab completion says Philippa!
04:42:36 <phr-newbie> heh
04:43:05 <phr-newbie> i have to import something to get L.wrap i guess?
04:43:30 <SamB> @type L.wrap
04:43:31 <lambdabot> Couldn't find qualified module.
04:43:39 <fasta> dons: who had that $2M machine?
04:43:39 <SamB> @hoogle wrap
04:43:40 <lambdabot> Network.CGI.wrapper :: ([(String, String)] -> IO Html) -> IO ()
04:43:40 <lambdabot> Text.Html.nowrap :: HtmlAttr
04:43:40 <lambdabot> Network.CGI.pwrapper :: PortID -> ([(String, String)] -> IO Html) -> IO ()
04:43:54 <phr-newbie> > :t L
04:43:55 <lambdabot>  Parse error
04:47:10 <dons> fasta: Technische Universitt Berlin
04:48:01 <dons> they have a cray as well :)
04:48:11 <musasabi> Did the hugs people have a nice way of packaging Cabal packages for windows?
04:48:48 * musasabi needs a nice way to ship 3 cabal packages + few DLLs.
04:49:39 <fasta> dons: does it run unmodified GHC programs?
04:50:21 <dons> the sparc does, yeah. that's just ghc smp with the ndp library
04:51:14 <dons> (you can get the same effect on a 4 core linux box, for about 1000x cheaper)
04:51:32 <dons> well, not quite the same effect. 40 cores are worth something
04:51:39 <xerox> Netsplit?
04:52:48 <fasta> dons: I am mostly worried about memory usage. I sure could use 180GB
04:53:01 <dons> heh
04:53:34 <dons> do you have a lot of data that just must be kept in memory?
04:53:59 <dons> otherwise, ghc should be no worse than C++ or what have you, given enough profiling
04:54:09 <dons> and probably less subject to memory leaks
04:54:39 <dons> i guess you already want to marry the profiled anyway
04:54:45 <dons> s/d/r
04:54:51 <fasta> dons: "must" in the theoretical sense, I don't know, but I think I do.
04:55:06 <dons> fair enough
04:55:34 <mux> yay, my first LostSoul ToME character escaped from the halls of mandos
04:55:49 <fasta> Is that game UM only?
04:55:55 <skew> is that anything like MSDOS?
04:56:51 <dons> UM only hehe.
04:57:15 <mux> mm, I still need to write that adventure game solver
04:57:27 <mux> but maybe I'll do 2d first, it looks fun
04:57:48 <skew> I'd recommend at least writing some editor
04:58:22 <mux> I wonder how many people in here abused 32bit pointers on 32bit architectures to get array ids *cheap* in their UM?
04:59:01 <Phillemann> Where does the function "write" come from?
04:59:14 <Phillemann> Oh, it's user-defined.
05:00:25 <dons> mux: a few. edwardk did
05:01:06 <int-e> I didn't.
05:02:18 * mux did
05:06:22 <fasta> In my 90% cost centre I call gsize on the result of a function that creates a _large_ datastructure. Why is the cost-centre so large in this function, and not also in the function generating the data structure?
05:06:49 <fasta> Lazyness seems an easy answer, but in that case I would say the profiler doesn't show where the real pain is.
05:07:11 <fasta> I hope that the "easy answer" is incorrect, however.
05:08:08 <skew> gsize in Data.Generics stuff?
05:08:34 <araujo> argh
05:08:48 <skew> I'd believe that could be a lot slower than creating the structure
05:09:46 <dons> all the dynamic checks
05:11:07 <fasta> dons: dynamic checks?
05:11:24 <fasta> dons: I would assume it to just generate the code as it needs compiler support.
05:12:00 <fasta> Are you suggesting that writing a custom size function would be an order of magnitude faster?
05:12:18 <fasta> skew: yes
05:15:16 <apfelmus> Igloo: ping
05:16:45 <Igloo> Hi
05:17:33 <apfelmus> Igloo: hi! i'd move a hawiki page or two but i am in no position to check licenses. what can i do?
05:19:00 <fasta> skew: Are you suggesting that writing a custom size function would be an order of magnitude faster?
05:19:54 <skew> maybe. you could try the generic one from the "generic instances" stuff
05:20:37 <Igloo> apfelmus: I don't think there's anything you can do, sadly
05:20:50 <Igloo> Short of rewriting the content, anyway
05:21:34 <fasta> skew: I don't understand.
05:24:06 <apfelmus> Igloo: o.O? it's not clear whether (even complete) rewrite changes license.
05:24:06 <apfelmus> imho, the migration problem comes from the fact that the hawiki has a different (more closed) license than the haskellwiki. otherwise, migration would fall into the "natural hawiki license implied by the operational semantics of a wiki"
05:25:24 <skew> fasta: there is other generic stuff. See the User's guide
05:26:25 <apfelmus> i mean the "operational semantics of a wiki" are that everybody can change/modify things within the wiki. a copyright license only apply to the use of the wiki content outside its concrete technical realization
05:26:35 <apfelmus> s/apply/applies
05:31:43 <psnl> wow, gtk2hs takes a while to build
05:32:20 <fasta> psnl: it's Haskell. Haskell takes long to build.
05:32:42 * fasta waits for the YHC argument
05:38:36 <fasta> apfelmus: wouldn't it be possible to taint pages that have the wrong license? Throwing content away is not a smart thing to do.
05:40:29 * jaymz is back (gone 09:11:17)
05:42:09 <apfelmus> hopefully. there already is such an example
05:42:09 <apfelmus> http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development
05:42:09 <apfelmus> the problem arises if one wants to merge/split/reorganize tainted content (very natural to do if one is doing migration anyway)
05:42:12 <lambdabot> Title: Libraries and tools/Program development - HaskellWiki, http://tinyurl.com/rolrs
05:42:16 <dons> jak: maybe you can disable that auto notify?
05:42:19 <dons> sorry
05:42:23 <dons> jaymz: ^^
05:42:49 <dons> fasta: oh put them in the BadLicense monad
05:43:24 <jaymz> dons, yeah its not "auto" - i accidentally clicked on it
05:43:37 <fasta> haha
05:45:25 <apfelmus> mh, why not? every text in red color is copyrighted. it would even suffice to tag this transparently in the resulting html.
05:46:05 <apfelmus> btw, doesn't deletig the hawiki not infringe copyright?
05:46:19 <earthy> does shredding a book infringe copyright?
05:46:35 <dons> yeah. thankfully you can e.g. remove gpl code from a bsd source tree. and not use it.
05:47:11 <apfelmus> earthy: it's more like shredding the original manuscript
05:49:41 <fasta> apfelmus: nobody promised that content would be out their for eternity.
05:49:48 <fasta> er there
05:50:10 <apfelmus> fasta: theirs or there, that's the point ;)
05:53:25 <fasta> apfelmus: you mean that the mere moving of the content to the new wiki infringes?
05:53:42 <fasta> (even when annotated in red)
05:55:44 <apfelmus> ah. even more trickier.
05:55:44 <apfelmus> i would say that moving the content is only a change of the underlying database, i.e. one has same effect if the hawiki got the same layout as the new wiki. but the new wiki has a more open license, that's the problem. i think this could be remedied indeed by providing a separate license for red content.
05:57:08 <apfelmus> as i'm reading, according to german law, the author has some kind of right to have his work being protected from defacement. does this apply in a wiki? in deleting a wiki?
05:57:43 <earthy> deletion can not, in my opinion, be copyright infringement
05:58:07 <xerox> What if there is a copyright on null bytes? ;-)
05:58:13 * earthy laughs
05:58:13 <apfelmus> earthy: but deletion is a defacement, isn't it?
05:58:21 <xerox> You're copying them over!!
05:58:33 <fasta> apfelmus: The wiki server is not located in Germany.
05:58:38 <earthy> no. defacement is a modification that leaves parts of the original intact
05:59:24 <apfelmus> fasta: true. i think in GB? europaen law is not that much different (i think)
06:00:44 <apfelmus> xerox: if i make a 640x400 pixel bmp in white, it's actually a collection of 0x00.
06:01:15 <Philippa> apfelmus: it's not deletion. It's quoting two or more parts of the work.
06:01:44 <Philippa> also, the author does *not* have a right to insist nobody ever destroys copies of a work that they own
06:02:08 <dons> or removes them from the library
06:02:19 <apfelmus> i think that the point is that the wiki is not a copy but the original
06:02:31 <Philippa> doesn't matter
06:02:41 <dons> i'm not sure originals have any special status
06:02:43 <Philippa> we're back to property damage rather than IP
06:02:53 <Philippa> and the author doesn't own that original copy
06:03:03 <Philippa> if they cared, they could've stored the wikitext somewhere else before submitting
06:03:30 <apfelmus> that would mean the wiki is a publishing media but it's not
06:03:45 <Philippa> no? Got a court ruling on that?
06:03:48 <dons> the author is free to save a copy to darcs. i do :)
06:07:03 <vincenz> hiya dons
06:07:07 <vincenz> Hey Philippa
06:07:28 <apfelmus> well, there is some subtle difference between a wiki and a publishing media. if one writes a haskell tutorial, one can either put it on my own web page (deletion is one's problem) or one can put it into a wiki (take the hitchhikers guide) for others to change it.
06:08:35 <Philippa> or do both
06:08:45 <Philippa> which given the license terms on hawiki is entirely legit
06:08:56 <fasta> What does the %MEM column mean? Is it the percentage of internal memory being used or is swap included in that figure?
06:09:11 <Philippa> you don't give hawiki the copyright, only a license
06:09:24 <dons> hey vincenz
06:09:29 <Philippa> you only give hawiki a copy. There was one in front of you on your computer when you sent it
06:09:49 <Philippa> it may only have been a temporary copy, but you did have the ability to save it unless you're using an incredibly bad browser
06:10:35 * vincenz heard today he might lose his front-tooth due to an accident 20 years ao
06:10:40 <vincenz> s/ao/ago
06:11:07 <Philippa> ouch
06:11:09 <Philippa> that sucks
06:11:36 <dblhelix> @seen SyntaxNinja
06:11:36 <apfelmus> Philippa: hawiki has a license written done? where? otherwise, you're right, i'm convinced about the deletion thing
06:11:36 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 18h 5m 36s ago, and .
06:12:44 <Philippa> apfelmus: sorry, hawiki might not do. I think the new wiki does though
06:12:58 <vincenz> It does
06:13:02 <Philippa> there's certainly an implicit license granted when you submit something to a wiki though
06:13:13 <vincenz> No I think there was explicit mention of a license on the new wiki
06:13:27 <apfelmus> yeah, i think so. "implied license by wiki operational semantics"
06:13:31 <Philippa> and you'd have a hard time arguing that there's a contract requiring the wiki maintainer to keep the wiki up in perpetuity in return
06:14:15 <fasta> Ok, physical memory, that's what I thought.
06:17:29 <apfelmus> how about the obligation of "proof" that you are indeed the copyright holder? if the contents is tagged by name, it should be fine but what if not?
06:21:07 <thor> hi, all.. i am trying to learn haskell and stumbled across a difference between hugs and ghc. hugs' behaviour seems to me more correct.. here: http://www.haskell.org/haskellwiki/Introduction_to_IO is a small snippet of code that asks your name and prints "hello, name".. if putStrLn is replaced with putStr then program compiled by ghc *first* takes your input, then prints "what is your name" and then greets your.. WHY?? :)
06:21:09 <lambdabot> Title: Introduction to IO - HaskellWiki, http://tinyurl.com/ft8nk
06:21:39 <dons> thor: sounds like a buffering issue
06:22:16 <dons> you could set no buffering with, hSetBuffering stdout NoBuffering
06:22:33 <Philippa> apfelmus: if you failed to tag it, it's your fault for failing to identify yourself in the first place
06:22:40 <dons> thor, since ghci is waiting on the \n to flush each line
06:22:54 <dons> another option is: putStr "foo " >> hFlush stdout -- to flush explicitly
06:22:56 <apfelmus> Philippa: that would mean untagged things are in public domain?
06:23:01 <dons> thor, I usually use that trick
06:23:17 <Philippa> no, it'd just mean that if you forgot to tag it you passed on your right to be recognised as the author without providing a pile of evidence
06:23:34 <thor> dons: thank you, i'll try :)
06:23:46 <Philippa> if you want recognition, you have an edit button...
06:24:33 <apfelmus> mh, what if i modify the content? are you alllowed to provide identification afterwards?
06:26:30 <Philippa> well, presumably if you're claiming your right as the author you'd provide some evidence if challenged, right?
06:27:50 <apfelmus> that's difficult if the content is already changed. because you can't claim the change. and you can't prove that change was based on your original content
06:28:21 <Philippa> most wikis have change histories
06:28:38 <Philippa> what with them being an essential tool for surviving defacement
06:29:59 <apfelmus> ok. seems reasonable
06:30:37 <apfelmus> hopefully, there is no ip address identification on hawiki
06:31:24 <musasabi> Of course if the author is *not* tagged and there is no license it cannot be used...
06:31:26 <Philippa> even if they were, it's possible to reconstitute between that, a timestamp and ISP logs
06:31:42 <Philippa> yeah. But see what I said about implicit licenses earlier, they're recognised in most countries
06:31:56 <Philippa> ("I posted this to usenet and everyone copied the post to their servers, I'll sue!")
06:32:19 <apfelmus> ok.
06:32:42 <Philippa> it's use off-wiki that's problematic
06:33:43 <apfelmus> yes. and migration changes off-wiki use policy :(
06:34:27 <Philippa> which's been done deliberately and that's why everyone's having to migrate by hand
06:43:13 <dcl06> need some help with a haskell problem, have to write a short program to determine if a number is prime or not but erally can't get to grips with recursion.  anyone know a good source of info for recursion
06:44:00 <ulfdoz> dcl06: Google it. Also a fixpoint-functional (correct translation?) could help you.
06:44:36 <dcl06> tried googling it, nothing that useful
06:44:49 <dcl06> have to use recursion, practice exercise
06:48:15 <gour> dc106: http://en.wikipedia.org/wiki/Recursion
06:48:16 <dons> dcl06: hmm. just write some recursive loops over lists?
06:48:34 <gour> dcl06: http://en.wikipedia.org/wiki/Recursion
06:48:37 <dons> > let f 0 = 1 ; f n = 1 + f (n-1) in f 10
06:48:38 <lambdabot>  11
06:49:05 <dons> > let f [] = 0 ; f (_:xs) = 1 + f xs in f [1..100]
06:49:06 <lambdabot>  100
06:49:22 <dons> its just syntax for gotos ;)
06:50:08 <dons> recursion should be covered in some discrete maths textbooks too. its just such a fundamental concept
06:50:27 <dcl06> i understand the concept, just cant code it in haskell
06:50:47 <musasabi> recursion can get quite complex.
06:51:05 <dons> dcl06: do you understand the length function above? ^^
06:51:12 <dons> > let f [] = 0 ; f (_:xs) = 1 + f xs in f "haskell"
06:51:13 <lambdabot>  7
06:51:38 <dons> a base case, and an inductive case, are used to define the length of the list
06:51:45 <dcl06> i've been using haskell for 3 days so no i dont really understnd it
06:51:59 <musasabi> as when one analyses recursive function, it goes usually into generative functions, fps, and analysis in C^{\infty}.
06:52:04 <dons> if the list is empty , the length is 0. otherwise the length is 1 + the length of the tail of the list
06:52:59 <dons> ?foldoc recursion
06:53:01 <lambdabot> *** "recursion" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
06:53:01 <lambdabot> recursion
06:53:01 <lambdabot>  
06:53:01 <lambdabot>     <mathematics, programming> When a {function} (or {procedure})
06:53:01 <lambdabot>     calls itself.  Such a function is called "recursive".  If the
06:53:03 <lambdabot> [24 @more lines]
06:53:10 <dons> blah blah
06:53:12 * vincenz kicks lambdabot for spam
07:00:50 <Phillemann> dons: Did you write this IRC bot tutorial?
07:01:04 <dons> yep
07:01:09 <dons> ?uptime
07:01:15 <Phillemann> You forgot some of the modules.
07:01:29 <dons> oh?
07:01:42 <Phillemann> I had to import List and I need some other module for "exitWith".
07:01:54 <dons> all you need should be in the /Source subpage
07:01:59 <Phillemann> Also, you gave code which uses the privmsg function and state that "we" define it, but you never do. :D
07:02:00 <dons> exitWith is in System.Exit
07:02:12 <dons> its all in there, I'm sure.
07:02:13 <fasta> dons: is anyone in #haskell working for TU Berlin?
07:02:19 <Phillemann> Well, you do, but at a later point of the tutorial.
07:02:32 <dons> Phillemann: hmm. can you point me to which line?
07:03:07 <Phillemann> "eval h x | "!id " `isPrefixOf` x = privmsg h (drop 4 x)" is the line and you describe "We add the privmsg function - a useful wrapper over write for sending PRIVMSG lines to the server."
07:03:28 <Phillemann> dons: It's just that I tried to incrementally develop the bot source as the tutorial progresses. :)
07:03:43 <Phillemann> Compiling every step...
07:04:00 <dons> ah. i'm not sure its been checked that that works...
07:04:09 <Phillemann> dons: Ah, okay.
07:04:09 <dons> i've only check that the code at the end of each section works
07:04:41 <Phillemann> Maybe you should say that in the introduction...
07:05:05 <dons> right. we do introduct privmsg before defining it.good point.
07:05:25 <dons> its not actually shown till the "all its glory" part
07:05:51 <phr-newbie> uh oh  http://supybot.com/Members/jemfinch/haskell-sucks/document_view    :)
07:05:53 <lambdabot> Title: Why I Believe that Haskell Sucks &mdash; Supybot Website, http://tinyurl.com/qxpyb
07:06:13 <dons> phr-newbie: I think that's quite old
07:06:14 <phr-newbie> huh?
07:06:19 <dons> jemfinich used to hang out here a lot
07:06:20 <phr-newbie> why did lambdabot do that?
07:06:31 <dons> do what http://google.com
07:06:33 <lambdabot> Title: Google
07:06:39 <phr-newbie> i haven't started reading it yet, i clicked the link from a darcs page
07:06:51 <Phillemann> ghc also complains about privmsg returning Net () and you wrote "write "PRIVMSG"", omitting the "h" I think.
07:06:53 <phr-newbie> oh i see, it goes and gets the title of any url it sees
07:07:24 <dons> Phillemann: no. that's right.
07:07:33 <dons> its in the Net monad. it doesn't need an 'h' parameter
07:07:49 <dons> try using the full source http://haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
07:07:49 <Phillemann> dons: Do I have to import something for write?
07:07:51 <lambdabot> Title: Roll your own IRC bot/Source - HaskellWiki, http://tinyurl.com/fdzc5
07:09:04 <dons> no. not if you have the right imports... i'm not sure the way you're developing the code is supported by this tutorial :)
07:09:15 <Phillemann> dons: It really isn't. ;)
07:09:19 <dons> anyway, you can find everything you might need in the source link above :)
07:09:43 <Phillemann> But the tutorial is pretty useful anyways.
07:09:54 <dons> cool
07:09:54 <phr-newbie> ok, that "sucks" article isn't all that impressive
07:10:36 <dons> phr-newbie: yeah, he basically didn't know the language at that point. and complains that there are new ideas in it
07:11:01 <dons> unfortunately anyone can write about anything and be wrong :)
07:11:24 <dons> if only there were proof assitants for blogs
07:11:59 <dons> Phillemann: you've worked out any imports you need?
07:12:06 <dons> ?uptime
07:12:06 <lambdabot> uptime: 8m 52s, longest uptime: 6d 15h 1m 36s
07:12:37 <Phillemann> System.IO, System.Exit, List, Network and Text.Printf. :)
07:13:30 <dons> also, if you see anything you don't know, hoogle will tell you where it lives
07:13:33 <dons> ?hoogle exitWith
07:13:34 <lambdabot> System.exitWith :: ExitCode -> IO a
07:13:41 <dons> ?hoogle ReaderT
07:13:42 <lambdabot> Control.Monad.Reader.ReaderT :: r -> m a -> ReaderT r m a
07:13:42 <lambdabot> Control.Monad.Reader.ReaderT :: newtype ReaderT r m a
07:13:42 <lambdabot> Control.Monad.Reader.mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
07:14:03 <dons> and thus to the imports
07:14:10 <dons> ?docs System.IO
07:14:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
07:14:13 <dons> and even the source
07:14:18 <dons> ?source System.IO
07:14:19 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
07:14:38 <edwardk> ?source Control.Comonad
07:14:39 <lambdabot> Control.Comonad not available
07:14:41 <edwardk> aww
07:14:45 <Phillemann> dons: Can I query the bot so I don't spam the channel too much?
07:14:46 <dons> heh
07:14:49 <dons> sure.
07:14:52 <dons> just /msg it
07:14:57 <Phillemann> Okay, thanks :)
07:15:02 <dons> it has many many haskellish features
07:15:08 <dons> ?type map
07:15:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
07:15:09 <edwardk> ?source+ Control.Comonad http://www.eyrie.org/~zednenem/2004/hsce/Control/Comonad.hs
07:15:10 <lambdabot> Control.Comonad http://www.eyrie.org/~zednenem/2004/hsce/Control/Comonad.hs not available
07:15:12 <dons> ?hoogle map
07:15:13 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
07:15:13 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
07:15:13 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
07:15:16 <dons> ?free map
07:15:17 <edwardk> ?source Control.Comonad
07:15:17 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
07:15:18 <lambdabot> Control.Comonad not available
07:15:27 <dons> @list will tell you mall
07:15:27 <edwardk> no source+?
07:15:27 <lambdabot> No module "will tell you mall" loaded
07:15:28 <dons> more
07:15:34 <dons> ?list
07:15:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:15:40 <dons> ?help docs
07:15:40 <lambdabot> docs <lib>. Lookup the url for this library's documentation
07:19:25 <phr-newbie> so is [1,2,3,4,5] actually represented as something like 5 cons cells with ints inside?
07:20:11 <glguy> 1 : ( 2 : ( 3 : ( 4 : ( 5 : [] ) ) ) )
07:20:25 <phr-newbie> yeah, i'm asking whether ghc optimizes it to a vector
07:20:32 <glguy> I don't think so
07:20:42 <phr-newbie> hmm
07:21:00 <glguy> phr-newbie: Haskell has Unboxed Arrays if that's what you want
07:21:28 <glguy> phr-newbie: but it doesn't just make a vector because it doesn't know the length ahead of time, and because it only computes as much of the list as need
07:21:37 <glguy> (among other reasons I am sure)
07:21:43 <phr-newbie> yeah, i guess there's going to have to be special hair to figure out to write fast programs
07:21:47 <dons> if its a small [Int], it will be unpacked. but that's a ghc feature
07:22:18 <glguy> dons: what are the criteria for that?
07:22:27 <dons> generally, fast programs aren't too magic. you just ask for special types, (like unboxed arrays), and don't do dumb things (tm)
07:22:54 <glguy> phr-newbie: when you find that you need highly-mutable arrays, you can learn the ST s Monad
07:23:04 <dons> glguy: a bit especial. < 16 in length (I think), all Int.
07:23:09 <phr-newbie> yeah i figure there must be something like that
07:23:15 <dons> then you'll get an Int array allocated in C
07:23:19 <phr-newbie> is there also a hashtable monad?
07:23:47 <dons> there are hashtables :)
07:23:50 <phr-newbie> i mean what if you want to read a bunch of names and addresses into memory and be able to do lookups?
07:23:52 <dons> but Data.Map is preferred
07:23:59 <dons> use a Map
07:24:08 <phr-newbie> is that like a python dict?
07:24:33 <dons> > let hash = (M.singleton "dons" "sydney") in M.lookup "dons" hash
07:24:34 <lambdabot>  add an instance declaration for (Show (m [Char]))
07:24:40 <dons> > let hash = (M.singleton "dons" "sydney") in M.lookup "dons" hash :: Maybe String
07:24:41 <lambdabot>  Just "sydney"
07:25:24 <dons> > let hash = (M.singleton "dons" "sydney") in M.lookup "lambdabot" (M.insert "lambdabot" "sydney" hash) :: Maybe String
07:25:25 <lambdabot>  Just "sydney"
07:25:32 <dons> ?docs Data.Map
07:25:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
07:25:35 <phr-newbie> i'm not sure what happened there but i guess i get the general drift
07:25:44 <dons> its the basic hash-like structure in haskell, yeah
07:25:44 <Syzygy-> > let hash = (M.singleton "Syzygy-" "Jena") in fromJust M.lookup "Syzygy-" :: String
07:25:45 <lambdabot>    Expecting a function type, but found `Maybe a'
07:25:45 <lambdabot>    Expected type: Mayb...
07:25:49 <Syzygy-> No.
07:26:06 <glguy> singleton creates a new map with one element (empty creates an empty one), lookup finds values in the map and insert adds them
07:26:17 <dons> ?type Data.Map.fromList
07:26:18 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
07:27:00 <dons> > let hash = M.fromList [(1,'a'),(2,'b'), (3,'c')]  in M.lookup 4 hash :: Maybe Char
07:27:00 <glguy> Syzygy-: you have to specify the map on which you are performing the lookup
07:27:01 <lambdabot>  Nothing
07:27:08 <dons> > let hash = M.fromList [(1,'a'),(2,'b'), (3,'c')]  in M.lookup 2 hash :: Maybe Char
07:27:09 <lambdabot>  Just 'b'
07:27:13 <fasta> That rant about "Haskell sucks" was a real lame one, btw.
07:27:21 <glguy> > let hash = M.fromList [(1,'a'),(2,'b'), (3,'c')]  in M.lookup 2 hash :: [Char]
07:27:23 <lambdabot>  "b"
07:27:33 <glguy> fasta: link?
07:27:53 <phr-newbie> what if you want something like coroutines?  is there anything explicit for that, or can you get it purely from lazy evaluation?
07:28:18 <dons> lazy eval should just work. for true threads there's forkIO
07:29:06 <phr-newbie> i meant coroutines without resorting to OS threads, so i'm wondering if there's some style of using lazy eval for that
07:29:18 <phr-newbie> like if i want erlang-ish microthreads for example
07:29:54 <dcoutts_> forkIO is microthreads
07:29:59 <dons> haskell threads are lightweight threads
07:30:00 <phr-newbie> oh interesting
07:30:01 <musasabi> Haskell threads are like erlang threads except that they share memory whereas erlang uses message passing.
07:30:15 <phr-newbie> are there OS threads?
07:30:19 <vincenz> fasta: what rant
07:30:27 <dons> if you need them, yep.
07:30:34 <glguy> What makes Erlang special, what does it focus on?
07:30:39 <dcoutts_> phr-newbie, ghc can schedule the lightweight threads on multiple OS threads.
07:30:50 <fasta> http://tinyurl.com/qxpyb
07:30:52 <lambdabot> Title: Why I Believe that Haskell Sucks &mdash; Supybot Website
07:31:01 <musasabi> glguy: it is very nice for network apps. Concurrent, distributed, very good error handling and parsing of binary data.
07:31:16 <fasta> It doesn't really deserve to be reposted actually.
07:31:17 <dons> the dynamic update stuff is nifty
07:31:56 <dons> bit old school though, erlang. seems like lots of fun language features are missing.
07:31:58 <phr-newbie> glguy erlang was originally for writing phone switches, it has very lightweight threads (e.g. one per telephone for each of a zillion phones connected to a switch), you can update the code while it's running,
07:32:15 <glguy> functional? declarative?
07:32:23 <phr-newbie> functional, dynamic typed
07:32:31 <vincenz> fasta: oy, that is bad
07:32:42 <vincenz> fasta: imho 'where' clauses are os much more legible
07:32:51 <fasta> vincenz: os?
07:33:08 <vincenz> s/os/is
07:33:09 <phr-newbie> so all the haskell i/o operations are nonblocking?
07:33:15 <vincenz> oh wait
07:33:16 <vincenz> not this time
07:33:18 <vincenz> s/os/so
07:33:39 <phr-newbie> yeah i like 'where' better than 'let' so far
07:33:44 <glguy> Nothing is worse than someone who doesn't know wtf they are talking about announcing to the world that his opinion matters
07:33:47 <dcoutts_> fasta, $ allows you to say: withThing $ \thing -> do ...
07:33:48 <phr-newbie> but you can't use 'where' inside expressions
07:34:01 <vincenz> dcoutts_: i don't think he wrote that page
07:34:02 <dcoutts_> fasta, rather than putting the ) right at the end of your do block
07:34:07 <dcoutts_> vincenz, I know
07:34:10 <musasabi> dons: yes from a language perspective erlang is not so good.
07:34:14 <phr-newbie> http://www.haskell.org/complex/why_does_haskell_matter.html   this one is good
07:34:16 <fasta> dcoutts_: I know, I don't agree with the rant.
07:34:16 <lambdabot> Title: The Lambda Complex, http://tinyurl.com/k8py9
07:34:25 <dcoutts_> fasta, I was just saying to you as I can't be bothered to write a comment on the site :-)
07:34:54 <fasta> dcoutts_: but you still had the urge to comment...
07:34:56 <musasabi> dons: Haskell just misses some features that are good for robust error handling and debugging in cuncurrent/distributed programs.
07:34:59 <vincenz> dcoutts_: be funny if now the guy advocate c++ or java, where variables are declared in OTHER FILES, (instance variables anyone?)
07:35:09 <dcoutts_> fasta, yeah, just not enough to regiser :-)
07:35:33 <dons> musasabi: yeah.
07:35:40 <phr-newbie> You might declare a type "Porsche", to be an instance of the "Car" type class, say. All functions that can be applied onto any other member of the Car type class can then be applied to a Porsche as well.
07:35:41 <phr-newbie> ???
07:35:46 <phr-newbie> Can that be right?
07:35:57 <dons> musasabi: we need more big, concurrent app robustness testing
07:36:19 <fasta> Mostly people whining about a language don't get it.
07:36:23 <musasabi> dons: I think the problems are largely known just that there is not enough push to fix them.
07:36:33 <dcoutts_> dons, musasabi, the other day at Chalmers, bringert and I were talking about error handling with lazy bytestrings. The tricky problem of exceptions and lazyness.
07:36:38 <vegai> I was wondering, musasabi, about HAppS and the data storage model
07:36:39 <roconnor> 53th Street and Dorchester Avenue!!!
07:36:43 <roconnor> 53th!!
07:36:53 <vegai> and let's say, EBay. Wouldn't that require huge amounts of RAM?
07:37:01 <vegai> I mean too much.
07:37:05 <musasabi> dons: serializable exceptions and threads as a tree and the ablity to forkLink threads like Erlang would help matters.
07:37:07 <psnl> fasta: he crashed and burned at the second line for me
07:37:17 <musasabi> vegai: not if you can partition things.
07:37:28 <dons> musasabi: hmm. libraries then?
07:37:48 <roconnor> w00t defeated the censory engine
07:37:50 <dcoutts_> dons, musasabi, we thought about the idea of exception handlers for lazy bytestrings.
07:38:14 <musasabi> dons: Dynamic exceptions need add a way to serialize them and GHC threads need rewriting to support things in an efficient way.
07:38:23 <vegai> musasabi: what do you mean? Some sort of network shared memory?
07:38:42 <dcoutts_> dons, I can't pm, but "yay!"
07:39:08 <musasabi> vegai: no. Just that on a Ebay like system we could partition different sellers to different machines.
07:39:35 <phr-newbie> The Haskell system is a more intuitive system for handling polymorphism. You won't have to worry about inheriting in the correct hierarchical order or to make sure that the inheritance is even sensible. A class is just a class, and types that are instances of this class really doesn't have to share some parent-child inheritance relationship. If your data type fulfills the requirements of a class, then it can be instantiated i
07:39:36 <phr-newbie> n that class. Simple, isn't it?
07:39:37 <phr-newbie> ????????
07:39:46 <vegai> musasabi: Ah. Now I see.
07:39:48 <musasabi> vegai: btw there was at least one app using HAppS that saved part of the State to disk and then loaded the parts needed from there (which were not needed for transactional side of things)
07:39:49 <phr-newbie> that sounds like totally chaotic multiple inheritance
07:40:13 <profmakx> no it sounds sensible ;)
07:40:19 <vegai> Yep. I think that would be required if your data happens to have large single pieces. Such as images.
07:40:20 <dons> class isn't an OO class..
07:40:22 <vegai> or movies.
07:40:28 <velco> inheritance is an implementation detail
07:40:42 <vincenz> velco: only in dyntyped langs
07:40:46 <musasabi> phr-newbie: it is a different way of doing things. and classes typically play a different role in Haskell than most OO languages.
07:40:55 <Syzygy-> phr-newbie: Class in haskell is more along the lines of "I promise this type can be used in these contexts"
07:40:58 <velco> vincenz: I meant C++ like langs
07:41:08 <musasabi> Haskell class == interface.
07:41:13 <Syzygy-> So guaranteeing with Fractional that division makes sense et.c.
07:41:14 <velco> haskell class == type
07:41:31 <dcoutts_> dons, musasabi, the idea was to have a function that installed an exception handler and then forced a chunk of the LBS. If it caught an exception then the exception handler could replace the tail of the list of chunk, eg truncating, or throing another exception. But it'd all still be done lazily.
07:41:43 <Syzygy-> (and now we have at least 5 different people with completely different grasp of the concept all trying to explain it simultaneously! :)
07:41:49 <dons> dcoutts_: hmm.
07:41:51 <phr-newbie> well yah, but it sounds like it happens with no declarations
07:42:04 <Syzygy-> phr-newbie: What do you mean no declarations?
07:42:06 <vegai> Haskell class == Haskell class ...
07:42:11 <dons> dcoutts_, do we have a use case where a wrapping 'catch' isn't suitable?
07:42:15 <dcoutts_> dons, so eg getting the Haskell98 behaviour of just truncating on exceptions would be trivial.
07:42:18 <phr-newbie> e.g. "You might declare a type "Porsche", to be an instance of the "Car" type class, say. All functions that can be applied onto any other member of the Car type class can then be applied to a Porsche as well."
07:42:31 <Syzygy-> phr-newbie: You are thinking OO still.
07:42:32 <phr-newbie> that means some Buick-specific function won't barf it I call it on a Porsche?
07:42:41 <dons> installing handlers seems a bit icky
07:42:45 <dcoutts_> dons, where you need to know that there are no exceptions anywhere in the stream. Which involves forcing it.
07:42:49 <Syzygy-> At least I think you are...
07:43:15 <dcoutts_> dons, nah, it's not that bad. It'd be a similar sig as an ordinary catch.
07:43:16 <dons> yeah, too OO phr-newbie
07:43:24 <dons> forget everything you know about the word 'class'
07:43:35 <dcoutts_> @type Control.Exception.catch
07:43:40 <phr-newbie> well i think i understand class to be a collection of types
07:43:40 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
07:43:41 <dons> a class in haskell is just a set of types that have some properties: the methods of the class
07:43:50 <velco> think of polymorphism instead of C++ like "classes"
07:44:10 <dons> so its all about stating bounded polymorphic functions
07:44:12 <phr-newbie> like Num is a class
07:44:18 <phr-newbie> Int, Integer, etc. are types within Num
07:44:23 <dons> ?instance Num
07:44:23 <lambdabot> Maybe you meant: instances instances-importing
07:44:27 <dcoutts_> dons, so it'd be: handle :: (Exception -> Lazy.ByteString) -> Lazy.ByteString -> Lazy.ByteString
07:44:28 <dons> ?instances Num
07:44:29 <lambdabot> Double, Float, Int, Integer
07:44:31 <dcoutts_> @type Control.Exception.handle
07:44:33 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
07:45:00 <Syzygy-> And Num just guarantees that +, *, -, abs, signum and fromInteger make sense.
07:45:01 <dons> phr-newbie: so yes, then something of:: Num a => a -> a , is polymorphic in those types only
07:45:15 <dcoutts_> dons, so H98 behaviour would be Lazy.handle (const Lazy.empty)
07:45:20 <dons> dcoutts_: hmm. ok.
07:46:30 <dcoutts_> dons, the point is, that the code that generated the LBS would only give generic exceptions. The code that accepted the LBS might know more of the context and be able to customise the exception.
07:46:35 <phr-newbie> f a b = (a+b)/2    with no declaration applies to all of Num, and the inferencer propagates Num through anything that calls f
07:46:45 <phr-newbie> hmm
07:46:59 <roconnor> Hmmm only 450 points
07:46:59 <Syzygy-> phr-newbie: Yeah, since Num is what gives you the possibility to use +.
07:47:04 <Syzygy-> I think it may tack on Fractional too.
07:47:04 <dcoutts_> dons, or eg a webserver that encountered an error when writing out a stream could append some html error message.
07:47:20 <dcoutts_> dons, there are limited possabilites but it may still be useful.
07:47:54 <phr-newbie> i guess it's ok.  i'm worrying about writing a function intended for one type and accidentally calling it from another type without the type checker complaining
07:48:16 <vincenz> phr-newbie: no worry there
07:48:18 <dons> what do you think coudl happen though? :)
07:48:42 <vincenz> it might blow up
07:48:43 <dons> either the type is valid, via its class instance, or its not going to type check
07:49:58 <phr-newbie> well, let's say Car is a Vehicle, and Boat is a Vehicle, and there's a "launch" function intended for boats but the type checker now allows you to drive a car into the water, not a good idea
07:50:26 <TSC> Vehicle won't have a launch function
07:50:27 <dons> you'd constrain the type to Boat...
07:50:35 <dons> right
07:50:40 <phr-newbie> anyway i'll figure this out, haskell generally seems pretty free of the looseness that bugs me about python
07:50:58 <vincenz> python is a harlot?
07:51:04 <phr-newbie> hehe
07:51:17 <dons> either the function is polymorphic, and works for all members of the class, or it is tied to a particular type only
07:51:23 <phr-newbie> i'd make some remark about "duck typing" but better not :)
07:51:34 <arcatan> can I have a Porsche, which is a Car, which is a Vehicle?
07:51:38 <phr-newbie> can i dispatch on the arg type, like in java?
07:52:02 <phr-newbie> sqrt x | x < 0   =>  barf   (x is real)
07:52:12 <dons> you can dispatch to instance methods, based on the type, yeah.
07:52:23 <phr-newbie> sqrt z = (complex square root) => figure out complex square root
07:53:31 <dons> so you'd never write the function: launch :: Vehical a => a -> IO (), for example, if you only want that to work for Boat
07:54:06 <dons> giving it the polymorphic type says it must work for all elements. you just can't write it down if it only works on Boats
07:54:55 <dons> i think typeclasses are pretty intuitive. so play around with them .write your own (good idea!) and you'll sort it out
07:55:02 <phr-newbie> yeah
07:55:17 <dons> perhaps the plbook, so you understand polymorphic types in depth, will be useful
07:55:21 <phr-newbie> what if i have a bunch of vector operations and just out of nerdiness they're written for n-vectors
07:55:40 <phr-newbie> but i want to do something in actual 3-space so i want some 3-vectors
07:55:42 <fasta> I don't really write new type-classes myself, I do use them however.
07:55:58 <phr-newbie> hmm
07:56:18 <phr-newbie> i have paul hudak's book "haskell school of expression" which seems pretty accessible
07:56:23 <phr-newbie> i've just started it
07:56:25 <musasabi> Then you just constrain the type to 3-vectors.
07:56:40 <dons> myfun :: Vector3 a => a -> a ....
07:56:55 <musasabi> Typeclasses are nifty but they are usually used to make interfaces cleaner.
07:57:01 <dons> then its not going to suddenly "go wrong" on types in VectorN .. it just won't compile
07:57:19 <musasabi> But composition is used much for combining components.
07:57:19 <dons> you won't be able to feed anything _but_ types in Vector3 to that function
07:58:05 <phr-newbie> dotProduct :: vectorN -> vectorN -> float
07:58:42 <phr-newbie> dotProduct v1 v2 = sum $ zipsWith (*) v1 v2
07:59:26 <phr-newbie> data vectorN = [Float]
07:59:41 <profmakx> not really -.-
08:00:42 <vincenz> type VectorN = [Float]
08:01:01 <phr-newbie> oops ok
08:01:18 <phr-newbie> and i guess i can say dotproduct = sum . zipsWith
08:01:31 <phr-newbie> (*)
08:01:57 <phr-newbie> no i guess not :)
08:01:59 <phr-newbie> zipWith
08:02:15 <phr-newbie> anyway sorry i better read the book some more
08:03:01 <musasabi> If it is coded so that the size is invisible in the Type then you cannot discrimanate on the size in the type. But if you encode the size in the type you can select stuff based on that.
08:03:31 <phr-newbie> oh yeah, that's what i wanted to ask, if i have a 3-vector like [3,4,5] is there a simple way to assign it to x,y,z?
08:03:48 <phr-newbie> like if it's a tuple, i can say let (x,y,z) = (3,4,5)
08:03:56 <phr-newbie> but what about a list?
08:03:59 <musasabi> > let [x,y,z] = [1,2,3] in x
08:04:03 <lambdabot>  1
08:04:04 <phr-newbie> oh cool
08:04:10 <phr-newbie> thanks, heh
08:04:17 <phr-newbie> i shoulda thought of that
08:08:48 <vegai> has anyone written an rss reader yet?
08:08:57 <vincenz> vegai: in what language?
08:09:00 <vegai> I mean one with a user interface as well
08:09:08 <vegai> vincenz: see channel name :)
08:10:58 <aFlag> I have this function: f g l = concat $ map g l, is there a cleaner way to define this? my first try was concat . map, but it obviously failed
08:12:05 <Igloo> f = concatMap
08:12:16 <kosmikus> yes, buth concat . map should work too
08:12:25 <kosmikus> s/buth/but
08:12:38 <Igloo> True
08:13:07 <Igloo> But then you need one of the points
08:15:49 <Syzygy-> > sqrt -1
08:15:50 <lambdabot>  add an instance declaration for (Num (a -> a))
08:15:55 <Syzygy-> > sqrt (-1)
08:15:56 <lambdabot>  NaN
08:15:59 <Syzygy-> Awww.
08:19:47 <aFlag> hum, concat . map is giving me a inference error
08:21:15 <dcoutts_> @type concat . map
08:21:16 <lambdabot>   Expecting a function type, but found `b'
08:21:17 <lambdabot>    Expected type: (a1 -> b) -> [[a]]
08:21:21 <dcoutts_> bah
08:21:46 <dcoutts_> @type \f -> concat . map f
08:21:47 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
08:22:03 <dcoutts_> @pl \f -> concat . map f
08:22:03 <lambdabot> (=<<)
08:22:08 <dcoutts_> heh
08:22:42 <glguy> ?type (concat .) . map
08:22:44 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
08:23:02 <dcoutts_> @pl \f -> concatMap f
08:23:02 <lambdabot> (=<<)
08:23:04 <fasta> How hard is it to port a Haskell application to C? I don't really see how I can get more performance out of my program.
08:23:07 <dcoutts_> @pl concatMap
08:23:07 <lambdabot> (=<<)
08:23:08 <dcoutts_> nice
08:23:15 <Philippa> depends on the app
08:23:28 <fasta> Philippa: it uses big nums.
08:23:34 <Philippa> there's a sensible if potentially unsafe (if you mess up) encoding of algebraic datatypes
08:23:44 <dcoutts_> fasta, like Integer ?
08:23:46 <Philippa> so you want a library to handle those for you
08:23:52 <fasta> dcoutts_: right
08:24:00 <dcoutts_> fasta, that's not goint to be faster in C as it already uses gmp
08:24:28 <musasabi> fasta: have you profiled things? Is there an inner loop?
08:24:44 <fasta> dcoutts_: well, the C program I have implementing the same stuff, doesn't actually use the bignums, it just interpretets them as chars.
08:24:59 <fasta> dcoutts_: I.e. implementing a small subset of what I need.
08:25:20 <dcoutts_> fasta, so, which bits do you expect you can make faster in C ?
08:25:23 <fasta> dcoutts_: But I ported that subset to Haskell, and C beats Haskell _very_ hard.
08:25:34 <dcoutts_> using String ?
08:26:11 <fasta> dcoutts_: The C application runs two tight loops and writes to a file in that loop.
08:26:42 <fasta> dcoutts_: the Haskell application builds a data structure of a type that's an algebraic data type,
08:26:51 <magnus-> fasta: If the program is short you could paste it
08:26:51 <fasta> So, it aren't really the same problems.
08:27:08 <fasta> magnus-: what the C program or the Haskell program>
08:27:17 <dcoutts_> fasta, you mean they are solving different problems ?
08:27:20 <magnus-> fasta: either one
08:27:32 <dcoutts_> fasta, if so I don't understand how/why you're comparing them
08:27:34 <musasabi> fasta: why not implement the C program in Haskell if that approach is fast ;)
08:29:25 <fasta> musasabi: well, I need an algebraic data type as input for another function, but I suppose I could try do do the C solution in Haskell, although the C solution is not a complete solution to my real problem.
08:29:37 <fasta> You are not expected to understand that.
08:31:08 <musasabi> @seen ndm
08:31:08 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 2d 14h 52m 28s ago, and .
08:40:45 * vincenz sighs
08:41:03 <vincenz> dons: You work with vim right? Anyway to determine the type of a variable of a c/c++ program?
08:42:04 <TSC> Look at its declaration?  (:
08:42:45 <glguy> when you are using ViM with ctags it's pretty easy to jump around
08:46:21 <vincenz> ...
08:48:25 <cdfh> vincenz: with ctags, you can jump to the variables declaration
08:48:35 <cdfh> vincenz: there's also a plugin you can use, which is very handy
08:48:48 <vincenz> That's however not what I asked for
08:48:52 <cdfh> press <KEYINDING>, and you get a sidebar open up
08:49:04 <cdfh> vincenz: yes it is - the declaration will show you the type
08:49:12 <cdfh> oops, sorry for the bold
08:49:15 <psnl> so what is the current preferred way to talk to databases?
08:49:31 <ProfTeggy> psnl, monad comprehensions
08:50:04 <glguy> ^^^ don't exist atm
08:50:21 <ProfTeggy> not anymore, yes
08:50:42 <glguy> so how can they be the current preferred method?
08:50:54 * psnl was imagining a software lib for haskell rather than a concept
08:51:04 <ProfTeggy> glguy, there's life beyond the Haskell horizon
08:51:31 <Phillemann> What does the >> operator do?
08:52:32 <glguy> the same thing as >>= \_ ->
08:52:45 <Phillemann> Ah, okay...
08:52:59 <glguy> if you don't understand Monad's yet, you'll want ot read a tutorial first probably
08:53:15 <glguy> s/Monad's/Monads
08:53:31 <glguy> s/ot/to
08:55:10 <Lemmih> psnl: I like hdbc.
08:55:35 <Lemmih> @where hdbc
08:55:36 <lambdabot> http://quux.org/devel/hdbc
08:58:19 <psnl> Lemmih: ta
08:58:31 <psnl> I'll give that a shot
09:05:06 <gour> Lemmih: which back-end you use with hdbc?
09:09:03 <jak> dons: "jak: maybe you can disable that auto notify?" which autonotify is it
09:09:21 <jak> Got no problem disabling whatever you need, just let me know
09:10:30 <jak> oh, I see that was actually directed at jaymz, sorry about that dons
09:17:23 <xerox> Now, this is fun - http://en.wikipedia.org/wiki/Jacques_Herbrand ``Jacques Herbrand (February 12, 1908 - July 27, 1931)'' and ``He introduced recursive functions in about 1932.''  o_0 ?
09:18:16 <deadbeef> "On the consistency of arithmetic" was published posthumously.
09:18:39 <vincenz> c++... the worst channel in the world
09:18:51 <araujo> the same could be said about the language
09:18:53 <vincenz> I mean for a language so badly designed, they really are language-spec thumpers
09:18:54 * araujo giggles
09:19:09 <lispy> vincenz: they have to be to keep their sanity
09:19:09 <vincenz> "where can I find itoa" "itoa is not in the standard"
09:19:18 <araujo> hah, yeah
09:19:28 <lucca> isn't that half the fun of spec thumping?
09:19:29 <psykotic> vincenz: fortunately stringstream is :)
09:19:32 <lucca> kinda like mao
09:19:54 <vincenz> psykotic: yeah but I'm not in the process of writing an app but making it run under linux (is windows app)
09:20:23 <vincenz> 18:18 < ville> vincenz: Why do you think a non-standard function is on topic  this channel?
09:20:25 <xerox> deadbeef: it should be stated more clearly there :)
09:20:58 <psnl> anyone heard of fno-prune-tydecls ?
09:21:14 <psykotic> vincenz, yeah that matches my experience. both ##c and #c++ are pretty hostile places. people that pride themselves on being masochists for knowing endless details about a broken language are cute.
09:21:25 <glguy> isn't itoa's functionality subsumed by snprintf?
09:21:29 <vincenz> The sad part is, they force people to use a std that is so badly broken
09:21:31 <phr-newbie> oh man, java crushes this in the language shootout, but it looks like it can be sped up a lot
09:21:33 <phr-newbie> http://shootout.alioth.debian.org/debian/benchmark.php?test=fasta&lang=ghc&id=0
09:21:36 <lambdabot> Title: fasta Haskell GHC program | Debian : AMD&#8482; Sempron&#8482; Computer Language ..., http://tinyurl.com/qlmdd
09:22:04 <phr-newbie> is there a way to profile it?
09:22:13 <phr-newbie> the RNG probably gets compiled pretty well
09:23:08 <vincenz> blegh
09:23:14 <vincenz> 'moreon' should remove the 'e' in his name
09:24:00 <Lemmih> gour: postgresql.
09:24:44 <gour> Lemmih: thanks. i think about sqlite but hdbc does not, afaics, support user-defined functions
09:25:16 <psnl> win 27
09:25:36 <dmhouse> If I have m :: StateT st Maybe a, and I do m >>= \x -> ..., is x :: Maybe a or x :: a?
09:26:26 <marcot> Hello!
09:26:48 <dmhouse> Must be x :: a, I guess.
09:26:53 <dmhouse> As StateT st Maybe is the monad.
09:27:25 <dmhouse> Hmm. Here's my situation.
09:27:30 <xerox> dmhouse: it's Maybe a.
09:27:39 <dmhouse> xerox: you're sure/
09:27:48 <xerox> Let's see.
09:27:49 <glguy> dmhouse: I think you have to lift to get inside the maybe
09:27:58 <xerox> @kind Control.Monad.State.StateT
09:28:03 <lambdabot> * -> (* -> *) -> * -> *
09:28:35 <dmhouse> I'll describe my situation anyway.
09:28:53 <xerox> ?type \f -> (undefined :: Control.Monad.State.StateT st Maybe a) >>= \x -> f x
09:28:54 <lambdabot> forall st a b. (Monad (StateT st Maybe)) => (a -> StateT st Maybe b) -> StateT st Maybe b
09:29:03 <xerox> It's an `a'!
09:29:19 <dmhouse> I have a function evalStep, which takes a Term, relies on and might update some state :: Context, and might fail.
09:29:41 <vincenz> Anyone familiar with itoa?
09:29:48 <glguy> ?type \f -> (undefined :: Control.Monad.State.StateT st Maybe a) >>= \x -> lift (f x)
09:29:49 <psykotic> vincenz, what do you need?
09:29:50 <lambdabot> forall st a a1. (Monad (StateT st Maybe)) => (a -> Maybe a1) -> StateT st Maybe a1
09:30:13 <vincenz> psykotic: simple question, the second parameter, which is numeric, if it's > than the number size (size being the number of digits) will it right align?
09:30:20 <dmhouse> I want to write a function eval :: Term -> Term, which runs evalStep repeatedly on the input until we get a Nothing.
09:30:25 * vincenz is gonna manually hack this functionality as he needs a reduced case anyways
09:30:27 <dmhouse> The initial state is [].
09:30:47 <psykotic> vincenz, standard itoa functions don't tend to have width parameters.
09:30:52 <psykotic> vincenz, so can't say.
09:30:58 <vincenz> itoa(number, buffer, 10)
09:31:04 <vincenz> the 10... ?
09:31:06 <glguy> vincenz: 10 is the base
09:31:10 <lucca> radix
09:31:13 <lucca> yeah, base
09:31:14 <vincenz> ah, thanks )
09:31:18 <vincenz> s/)/:)
09:31:31 <vincenz> alright, this should be easy enough
09:31:35 <vincenz> > ord '0'0
09:31:36 <vincenz> > ord '0'
09:31:37 <lambdabot>    The function `ord' is applied to two arguments,
09:31:37 <lambdabot>   but its type `Char -...
09:31:39 <lambdabot>  48
09:31:51 <glguy> > digitToInt '0'
09:31:53 <lambdabot>  0
09:32:05 <glguy> > intToDigit 0
09:32:07 <lambdabot>  '0'
09:32:29 * vincenz needed the ascii-value to add to the digit
09:32:59 <glguy> vincenz: not if you use what I just told lambdabot
09:33:03 <dmhouse> I could possibly make the type of evalStep to be State st (Maybe Term).
09:33:14 <vincenz> glguy: you assume I'm working in haskell
09:33:29 <vincenz> ;)
09:33:34 <glguy> vincenz: why don't you just use snprintf or something similar in C
09:33:35 <glguy> then?
09:33:39 <glguy> instead of reinventing
09:33:57 <vincenz> glguy: good point, does it zero terminate?
09:34:17 <lucca> "but he might get an octal zero instead of a decimal zero" heh
09:34:57 <glguy> vincenz: you mean does it return a c-string?
09:35:01 <lucca> oh, output anyway
09:35:04 <psykotic> @lambda paste
09:35:06 <lambdabot> unbound variable: paste
09:35:09 <vincenz> glguy: yep
09:35:10 <psykotic> @paste
09:35:12 <lambdabot> http://paste.lisp.org/new/haskell
09:35:13 <glguy> vincenz: yeah
09:35:36 <vincenz> cool, thank you
09:35:52 <glguy> char buffer[10]; snprintf(buffer, 10, "%d", 20);
09:36:34 <lucca> ls
09:36:42 <vincenz> yep :)
09:36:45 <lisppaste2> psykotic pasted "itoa" at http://paste.lisp.org/display/27486
09:36:56 <psykotic> in case you need the general version (untested)
09:36:58 <vincenz> glguy, psykotic: thanks for the quickhelp
09:37:55 <shahn> Hi!
09:38:17 <shahn> i want to write a little cl-program with keyboard interaction
09:38:40 <shahn> is readKey from System.Console.Readline the right choice to do that?
09:38:47 <shahn> or bindkey?
09:38:54 <vincenz> shahn: try "interact"
09:38:56 <vincenz> @hoogle interact
09:38:57 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
09:38:57 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
09:38:57 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
09:39:02 <vincenz> shahn: it is perfect for that
09:39:02 <shahn> ok thx
09:39:21 <vincenz> shahn: it takes a function that from an input string generates an output string (lazily)
09:39:38 <glguy> Does interact have buffered input?
09:39:51 <dcoutts_> glguy, what do you mean?
09:40:01 <lispy> glguy: interact doeesn't care, it depends on your terminal settings
09:40:05 <glguy> does it read each letter in
09:40:07 <glguy> or each line
09:40:12 <lispy> glguy: for example, if you use it from ghci then its unbuffered
09:40:14 <dcoutts_> you can change the buffering mode of the Handle you use interact on
09:40:32 <glguy> okay, but what is the default that shahn is going to experience
09:40:43 <marcot> what's wrong with:
09:40:54 <dcoutts_> glguy, (actually there isn't an hInteract) so it depends on the buffering of stdin/stdout
09:40:59 <lispy> glguy: from a CL program, probably buffered...depends on terminal settings
09:41:14 <dcoutts_> @hoolge buffering
09:41:14 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
09:41:15 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
09:41:15 <lambdabot> System.IO.BlockBuffering :: Maybe Int -> BufferMode
09:41:26 <vincenz> dcoutts_: you can still change teh buffering
09:41:35 <vincenz> dcoutts_: hSetBuffering stdin (or osmething like that)
09:41:38 <vincenz> @hoogle stdin
09:41:38 <lambdabot> IO.stdin :: Handle
09:41:44 <dcoutts_> indeed, that's what I was suggesting
09:41:50 <glguy> just asking beacause if he was planning on looking at "bindkey" he probably expects teh program to respond after each key press
09:41:51 <vincenz> cool :)
09:42:02 <lisppaste2> marcot pasted "Simple instance" at http://paste.lisp.org/display/27487
09:42:08 <dcoutts_> glguy, right, use no buffering
09:42:13 <marcot> What's wrong in that?
09:42:13 <dcoutts_> @hoogle BufferMode
09:42:15 <lambdabot> System.IO.BufferMode :: data BufferMode
09:42:24 <lispy> interact with nobuffering is often silly though
09:42:33 <dcoutts_> often it is, yes
09:42:50 <dcoutts_> but not if you want to respond after every keypress
09:43:22 <marcot> Why can I make an instance to int but not to [Int]
09:43:34 <vincenz> marcot: you want [a]
09:43:48 <fasta> It needs to be of the form T a b c d
09:44:04 <fasta> (List a) is of that form
09:44:08 <marcot> vincenz: why can't it be [Int]
09:44:09 <vincenz> marcot: if you want something more specific, you can use the trick the "Show" class does
09:44:12 <fasta> List Int is not
09:44:21 <fasta> marcot: you can't without extentions.
09:44:23 <vincenz> marcot: Basically you can define a mostraList :: [a]
09:44:27 <vincenz> marcot: in class for a
09:44:46 <vincenz> class Tests where
09:44:48 <vincenz>   mostra :: a
09:44:51 <vincenz>    mostraList :: [a]
09:44:56 <vincenz> erm.. class Tests a
09:45:31 <marcot> I don't get what is the form T a b c d
09:45:58 <vincenz> basically you can only control the outermost typeconstructor
09:46:01 <vincenz> for basic types, that's just the type
09:46:06 <marcot> hum...
09:46:18 <vincenz> or you need more advanced GHC options
09:47:56 <marcot> So I can't declare also instance Teste a
09:47:57 <marcot> ?
09:49:06 <marcot> instance Num a => Teste a where
09:49:06 <marcot>     mostra = 1
09:49:14 <marcot> I can't do this also?
09:49:23 <vincenz> you can do that
09:49:33 * vincenz ponders
09:49:45 <vincenz> actually not sure
09:50:55 <marcot> Not without ghc extensions.
09:51:46 <shahn> ok, i checked out interact
09:51:58 <shahn> thats not what i need
09:52:26 <shahn> i want the program to react on every pressing of keys
09:52:51 <shahn> and i don't just want to print further chars to stdout but do IO
09:53:40 <glguy> ?hoogle IO Char
09:53:42 <lambdabot> Prelude.getChar :: IO Char
09:53:42 <lambdabot> System.Console.Readline.readKey :: IO Char
09:53:42 <lambdabot> IO.hGetChar :: Handle -> IO Char
09:54:23 * roconnor has smashed the Censory Engine
09:56:59 <glguy> ?hoogle Callback
09:57:00 <lambdabot> System.Console.Readline.Callback :: type Callback
09:57:00 <lambdabot> System.Console.Readline.callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
09:57:00 <lambdabot> System.Console.Readline.callbackReadChar :: IO ()
09:57:34 <shahn> ok, when i try readKey i get a segmentation fault
09:58:08 <shahn> Am i wrong or is that a bug in the Readline library?
10:00:03 <glguy> does getChar not do what you need?
10:00:34 <shahn> getChar needs a return key to be pressed, doesn't it?
10:02:14 <shahn> yes it does
10:02:23 <roconnor> shahn: to SetBuffering stdin NoBuffering
10:02:29 <roconnor> ugh
10:02:41 <roconnor> do setBuffering stdin NoBuffering
10:03:08 * roconnor can't type today (or any other day)
10:04:57 <shahn> ok thx that works
10:15:11 <marcot> haskell/Database.hs:15:0:
10:15:11 <marcot>     Warning: Module `Haskell' is imported, but nothing from it is used
10:15:11 <marcot>              (except perhaps instances visible in `Haskell')
10:15:25 <marcot> I get this error, but I'm using a function imported from the module in the code.
10:15:49 <marcot> This happens two times in my compilations, with two different modules.
10:15:53 <marcot> Why does it happens?
10:16:41 <vincenz> roconnor: hSetBuffering
10:17:27 <Lemmih> marcot: Does 'import Haskell ()' break your code?
10:18:41 <marcot> Lemmih: I found out what it was. The function that used the function imported was not being exported.
10:18:44 <marcot> Lemmih: but thanks.
10:19:45 <SyntaxNinja> has anyone run across any interesting Haskell bugs in their code lately?  something that would make a good example?
10:20:08 <fasta> SyntaxNinja: I have still code containing bugs.
10:20:24 <fasta> But I don't think they make a good example... :D
10:20:28 <SyntaxNinja> fasta: bugs that are interesting, once you fix them :P
10:20:48 <fasta> SyntaxNinja: Oh, well, I had something I found nice.
10:21:58 <fasta> SyntaxNinja: I had do state<-updateFunction;updateG;return $ doSomethingWith state
10:22:11 <fasta> SyntaxNinja: I easily found that updateG was never evaluated
10:22:26 <fasta> SyntaxNinja: and thus that I had to get state again.
10:22:44 <marcot> Lemmih: in the other part of the code I got the same error:
10:22:51 <fasta> Thanks to lazyness I found the bug.
10:22:54 <marcot>     Warning: Module `Database.HDBC.Types' is imported, but nothing from it is used
10:22:55 <marcot>              (except perhaps instances visible in `Database.HDBC.Types')
10:22:57 <marcot> Warning..
10:22:58 <SyntaxNinja> fasta: do you have the whole example somewhere?
10:23:21 <marcot> Sorry, same thing.
10:26:10 <fasta> SyntaxNinja: Yes, I have the whole example, but I can't really tell the whole story around it.
10:27:58 <fasta> SyntaxNinja: It's do state<-get; let <somepurefunction binding values that they get by computing something from state>;updateSomethingToState; put state{somevar=somethingNew}
10:28:09 <SyntaxNinja> fasta: can I see the code?
10:28:15 <fasta> SyntaxNinja: this is the buggy version
10:28:42 <fasta> SyntaxNinja: you cannot see the real version, but does that matter that much?
10:29:19 <fasta> SyntaxNinja: I think it illustrates that lazyness helps debugging.
10:29:50 <fasta> SyntaxNinja: the good version has an additional state<-get betwen updateSomethingToState and put
10:30:21 <SyntaxNinja> fasta: thanks, but I'm looking for an entire example with all the surrounding code, etc.
10:30:37 <fasta> SyntaxNinja: ok, sorry.
10:31:34 <SyntaxNinja> fasta: no problem, thanks!
10:36:50 <lucas42> hi, does haskell have a built-in function to convert a string to lower case?
10:37:05 <roconnor> @hoogle toLower
10:37:06 <lambdabot> Char.toLower :: Char -> Char
10:37:07 <int-e> > map toLower "ABCdef"
10:37:15 <lambdabot>  "abcdef"
10:37:39 <roconnor> lucas42: it isn't international.
10:37:55 <roconnor> lucas42: it isn't internationalalized
10:39:25 <lispy> i have a cabal questions
10:40:16 <fasta> SyntaxNinja: odd, btw, that you ask this question, since I am sure you also create loads of bugs ;0
10:40:21 <lucas42> what does internationalalized mean?
10:40:24 <fasta> er ;)
10:40:39 <lispy> i have rtsoptions.c which defines char *ghc_rts_opts = "-M1024M -K24M";
10:40:56 <skuggi> how do i perform a integer division?
10:40:56 <lispy> how do i get cabal to link rtsoptions.o with my binary?
10:41:02 <lispy> skuggi: div
10:41:08 <skuggi> lispy: ah, thanks
10:41:08 <lispy> skuggi: also look at divMod and mod
10:41:30 <lispy> skuggi: also, try hoogle
10:41:35 <lispy> ?hoogle Int -> Int -> Int
10:41:36 <lambdabot> No matches, try a more general search
10:41:38 <lispy> heh
10:41:42 <lispy> or not :)
10:41:45 <lispy> ?hoogle divide
10:41:46 <lambdabot> Control.Exception.DivideByZero :: ArithException
10:41:56 <lispy> guess hoogle dosen't really find this one
10:42:02 <lispy> ?hoogle Integral a => a -> a -> a
10:42:04 <lambdabot> Prelude.div :: Integral a => a -> a -> a
10:42:04 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
10:42:04 <lambdabot> Prelude.lcm :: Integral a => a -> a -> a
10:42:08 <lispy> ah there we go
10:42:34 <lispy> so i tried putting dist\build\src\rtsoptions.o in the ghc-options
10:42:51 <lispy> but that .o file is built to late so i get errors about the missing file
10:43:01 <lispy> so then i moved it to the ld-options
10:43:06 <lispy> in that case it is never linked
10:43:09 <lispy> (no error either)
10:43:23 <lispy> i'm at a loss to get cabal to do this
10:43:42 <lispy> and yes it's listed in c-sources and in the file as CFILES src/rtsoptions.c
10:46:05 <hyrax42_> ?type quot
10:46:07 <lambdabot> forall a. (Integral a) => a -> a -> a
10:46:14 <zarvok> @users
10:46:15 <lambdabot> Maximum users seen in #haskell: 244, currently: 244 (100.0%), active: 40 (16.4%)
10:46:17 <zarvok> sweet
10:46:23 <hyrax42_> oh lambdabot only shows top 3
10:51:02 <fasta> Parsing combinators are bad for performance... Generating the file takes 0.01 seconds using C. Parsing it already takes >5 minutes in Haskell...
10:52:31 <dcoutts_> @hoogle mzero
10:52:32 <lambdabot> Control.Monad.mzero :: MonadPlus m => m a
10:52:48 <Philippa> fasta: *some* parsing combinators are bad for performance. As are some ways of factoring a grammar.
10:53:55 <fasta>    H -> Atom | (D)
10:53:55 <fasta>    G -> '~'G | H
10:53:55 <fasta>    F-> G '&' F | G
10:53:55 <fasta>    E-> F '|' E | F
10:53:56 <fasta>    D-> E -> D | E <-> D | E
10:54:01 <fasta> This is the grammar.
10:54:16 <fasta> The Parsec code is a direct mapping.
10:55:56 <lispy> E <-> D ?
10:56:03 <lispy> i haven't seen that before
10:57:02 <fasta> lispy: bi-implication
10:57:19 <lisppaste2> lispy pasted "Cabal" at http://paste.lisp.org/display/27494
10:58:09 <fasta> Here you can see the code: http://pastebin.ca/193226
10:58:55 <lispy> fasta: i would recommend compiling with -prof -auto-all and running with +RTS -p -RTS and looking at the .prof file it generates to see where it's taking time and wasting memory
10:59:10 <fasta> Maybe I have too much try's in there...
10:59:17 <lispy> that could be
11:01:05 <roconnor> hmmm, I'm having trouble finding a solution to the assembling the pousse game
11:05:55 <chessguy> is the PolyP livrary still used?
11:05:58 <chessguy> *library
11:06:58 <roconnor> crap, somehow this pousse game is broken in such a way that my seach algorith can't find a solution easily
11:07:55 <hyrax42_> ?type flip (foldr (:)
11:07:56 <lambdabot> parse error (possibly incorrect indentation)
11:08:00 <hyrax42_> ?type flip (foldr (:))
11:08:01 <lambdabot> forall a. [a] -> [a] -> [a]
11:08:16 <hyrax42_> ?type flip (foldr (:)) "abc"
11:08:17 <lambdabot> [Char] -> [Char]
11:09:22 <fasta> This function takes 50% of the CPU time: spaced p =  do spaces; parsing<-p; spaces; return parsing
11:09:40 <hyrax42_> so flip (foldr (:)) :: String -> ShowS
11:10:00 <lispy> fasta: now try adding {-# SCC "foo" #-}
11:10:25 <fasta> lispy: uh, where?
11:10:47 <lispy> so spaced p = do {-# SCC "spaced1" #-} spaces; parsing <- {-# SCC "spaced2" #-} p; {-# SCC "spaced3" #-} spaces; return parsing
11:10:58 <lispy> fasta: then the profiler will break it down better
11:11:11 <hyrax42_> ooh learning profiler
11:11:14 <fasta> lispy: I just want to ignore those spaces, you know that, right?
11:11:16 <hyrax42_> I'll need that soon
11:11:23 <lispy> fasta: yup
11:11:49 <fasta> lispy: oh, that syntax binds to the next expression.
11:12:17 <marcot> Is wash a good option for programming with haskell for web?
11:12:18 <lispy> fasta: yeah and you can get parse errors if yo put them in the wrong place
11:12:49 <marcot> Are there other good options?
11:13:09 <fasta> marcot: you could write your own library
11:13:29 <fasta> marcot: just only write what you need. That's bound to be a good process for getting good software.
11:13:38 <marcot> fasta: are the existing libraries this bad?
11:13:43 <roconnor> w00t tuned my seach algorithm.
11:13:44 <fasta> marcot: I am not saying that
11:13:56 <roconnor> a litte sorting can really help a nondeterministic algorithm.
11:14:49 <chessguy> anybody read this paper? i'm trying to figure out what would be needed to get this code working
11:15:13 <marcot> So, what are the best options for using haskell in web? What projects are more active?
11:16:27 <fasta> Hmm, compiling my application takes long :(
11:16:39 <zarvok> marcot: hope is kindof cool, if you're looking for blogging/content management stuff
11:16:42 <zarvok> @where hope
11:16:43 <lambdabot> http://hope.bringert.net/
11:16:44 <fasta> marcot: The best answer is if you look for yourself.
11:17:23 <fasta> marcot: Some people think the Red Light District is a dangerous place to be. Some people think it's a fun place.
11:21:21 <fasta> lispy: 19.1   26.2  16.1   15.8
11:21:32 <fasta> lispy: spaced1 and spaced 2 resp.
11:21:47 <fasta> time-alloc order
11:21:58 <chessguy> so? anybody read that paper?
11:23:06 <fasta> chessguy: what paper/
11:23:50 <chessguy> oh!
11:23:58 <chessguy> i forgot to paste the link
11:24:06 <chessguy> http://citeseer.ist.psu.edu/vestin97genetic.html
11:24:12 <lambdabot> http://tinyurl.com/rvn95
11:24:54 <fasta> chessguy: no, but I don't think it's going to do magic.
11:25:05 <chessguy> magic?
11:25:21 <fasta> chessguy: like that it's going Very Fast all of a sudden.
11:25:32 <chessguy> what are you talking about?
11:25:49 <chessguy> i'm just wondering what it would take to get the code in that paper operable
11:26:01 <chessguy> i'm not concerned with efficiency at the moment
11:27:30 <fasta> chessguy: Doesn't Generic Haskell supports that kind of generic programming?
11:27:43 <chessguy> beats me. that's what i'm asking
11:27:58 <chessguy> is generic programming the same as genetic programming
11:28:06 <fasta> chessguy: no
11:28:35 <chessguy> how is it related?
11:29:36 <fasta> chessguy: they are not related
11:29:44 <chessguy> ...
11:29:56 <fasta> chessguy: only that paper combines them.
11:30:14 <chessguy> oh, generic = polytypic?
11:30:21 <roconnor> crap 2989 points
11:30:23 <fasta> chessguy: no
11:30:27 <roconnor> I need 3006 for root access
11:30:36 <fasta> chessguy: I think it's a way for generic programming.
11:30:47 <chessguy> you think what is?
11:31:12 <fasta> chessguy: that doesn't mean that generic programming implies polytypic programming.
11:31:29 <chessguy> you're not making any sense
11:31:37 <fasta> it=polytypic
11:31:49 <fasta> I am, you are not understanding :)
11:32:00 <fasta> lispy: any input on that profile?
11:32:29 <fasta> A polytypic function is a function that is defined by induction on the structure of user-defined datatypes.
11:32:34 <kosmikus> generic and polytypic programming in the context of Haskell usually refers to the same thing
11:34:22 <chessguy> so...what do i need to get that code working?
11:35:15 <fasta> chessguy: I don't know how current it is, but for example this: http://www.dcs.gla.ac.uk/jfp/online/jfpvol8-5/PolyPUnification/polyp/
11:35:18 <lambdabot> Title: PolyP - a polytypic programming language, http://tinyurl.com/ogqsy
11:36:00 <fasta> chessguy: but honestly, I don't think polytypic programming helps genetic algorithms in any way currently.
11:36:12 <chessguy> what about this AllFudget stuff? i can't seem to get that working
11:36:26 <fasta> chessguy: a genetic algorithm implemented in C is going to get faster easier than one written in PolyP.
11:37:40 <chessguy> i'm well aware of the performance issues
11:38:27 <profmakx> pfu lambdabot with 552MB res. size o.O
11:38:44 <chessguy> has anybody gotten this Fudgets library working?
11:44:32 <psi> I'm looking through the "Roll your own IRC bot" tutorial, and it uses a explicit type signature for the write function, but states that it's not, of course, necessary.
11:44:46 <psi> At least hugs isn't able to figure the type out.
11:45:31 <psi> I don't really understand why.
11:45:41 <glguy> psi: even in the context of the whole file?
11:46:03 <psi> glguy: yes
11:46:30 <psi> ERROR "/home/psi/haskell/ircbot.hs":20 - Ambiguous type signature in inferred type
11:46:30 <psi> *** ambiguous type : (Monad a, HPrintfType (a b), PrintfArg c, PrintfArg d, PrintfType (a e)) => Handle -> d -> c -> a e
11:46:31 <psi> *** assigned to    : write
11:46:51 <hyrax42_> ?type \h s t -> hPrintf h "%s %s\r\n" s t>>  printf    "> %s %s\n" s t
11:46:52 <lambdabot> forall (m :: * -> *) a b t t1. (Monad m, HPrintfType (t -> t1 -> m a), PrintfType (t -> t1 -> m b)) => GHC.IOBase.Handle -> t -> t1 -> m b
11:47:06 <psi> It does seem to me that the necessary context is there.
11:47:55 <hyrax42_> ?type \h s t ->( hPrintf h "%s %s\r\n" s t) >> ( printf    "> %s %s\n" s t)
11:47:57 <lambdabot> forall (m :: * -> *) a b t t1. (Monad m, HPrintfType (t -> t1 -> m a), PrintfType (t -> t1 -> m b)) => GHC.IOBase.Handle -> t -> t1 -> m b
11:48:21 <hyrax42_> ?type printf
11:48:22 <lambdabot> forall r. (PrintfType r) => String -> r
12:07:22 <profmakx> @uptime
12:07:22 <lambdabot> uptime: 5h 4m 8s, longest uptime: 6d 15h 1m 36s
12:07:29 <profmakx> @version
12:07:29 <lambdabot> lambdabot 4p244, GHC 6.5 (OpenBSD i386)
12:07:30 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:36:24 <musasabi> Does GHC on windows insert any registry key telling the location where it resides?
12:43:18 <weitzman> HKEY_LOCAL_MACHINE\SOFTWARE\Haskell\GHC\ghc-6.4.2
12:43:50 <weitzman> InstallDir == "C:\..."
12:44:53 <weitzman> Hugs, on the other hand, seems to install to HKEY_CURRENT_USER
12:51:10 <musasabi> weitzman: thanks.
12:52:05 <glguy> http://www.defmacro.org/ramblings/fp.html
12:52:07 <lambdabot> Title: defmacro - Functional Programming For The Rest of Us
12:52:10 * glguy recommends the read ^^
12:52:13 <goltrpoat> is there a way to make parsec a bit less eager about its error reporting?  im ending up with 2-3 error messages when id really rather have just one (eg, int x=5,x; in a c++-style grammar ends up with a) unexpected ";" b) expecting ",", c) the actual fail message about the multiple declaration)
12:52:28 <goltrpoat> the identifier parser is wrapped in try
12:54:29 <roconnor> @type newArray
12:54:30 <lambdabot> Not in scope: `newArray'
12:54:35 <roconnor> @hoogle newArray
12:54:36 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
12:54:36 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
12:54:36 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
13:00:32 <hygge> hello !
13:00:52 <weitzman> It gets tiresome reading claims from ruby and functional programmers that design patterns don't exist in "good" languages
13:02:11 <weitzman> Some people seem to think that the need to partition interfaces, data, and logic somehow disappears if you have list comprehensions and parametric polymorphism, or something like that
13:02:54 <vincenz> weitzman: point being?
13:03:10 <weitzman> Point being that the article glguy just linked to makes such a claim
13:03:41 <Cale> design patterns often turn into language constructs in good programming languages
13:03:58 <weitzman> My claim would be that putting it into the language didn't make it go away
13:03:58 <hygge> hmm, howcome i cant do "map (map.not.isjust)) listoflist" ?
13:04:18 <Cale> hygge: isJust ?
13:04:23 <int-e> weitzman: so you call uses of 'map' an application of the visitor pattern?
13:04:40 <hygge> cale, i've made it myself, it goes from maybe int to bool.
13:04:42 <int-e> or fold, whatever.
13:04:45 <Cale> er, also, you want to apply map to (not . isJust) don't you?
13:05:12 <Cale> > map (map (not . isJust)) [[Nothing, Just 5], [Just 10, Nothing, Nothing]]
13:05:15 <lambdabot>  [[True,False],[False,True,True]]
13:05:18 <hygge> no, beacuse my list has nine other lists in it.
13:05:19 <glguy> ?type isJust
13:05:21 <lambdabot> forall a. Maybe a -> Bool
13:05:23 <weitzman> weitzman: The visitor pattern would correspond roughly to a function that does pattern matching
13:05:25 <glguy> ?index isJust
13:05:25 <lambdabot> Data.Maybe
13:05:28 <int-e> weitzman: I don't think all design patterns go away or become useless, but some just become so trivial that they don't deserve that name anymore.
13:05:30 <weitzman> Gah, I need to stop talking to myself
13:05:35 <Cale> hygge: like that?
13:05:39 <hygge> yeah :)
13:06:00 <glguy> hygge: isJust already exists in Data.Maybe, you don't need to write you own (c:
13:06:01 <weitzman> Well, my response to that would be that Design Patterns are a concept, not a finite list of specific techniques
13:06:22 <int-e> I suppose you can call monads a design pattern.
13:06:48 <weitzman> int-e: Most certainly. They are an abstraction commonly used to address similar problems
13:06:48 <hygge> aha :)
13:06:55 <hygge> haha okey, i didnt know that
13:07:16 <\z> weitzman: have you read http://newbabe.pobox.com/~mjd/blog/prog/design-patterns.html
13:07:19 <lambdabot> Title: The Universe of Discourse : Design patterns of 1972, http://tinyurl.com/ooocj
13:07:27 <Philippa> monads're more formalised, and indeed more formalisable, than design patterns're generally intended to be
13:07:38 <hygge> ah, oh i did. because, my justs only can be between just 1 and just 9. (its to a datatype for a sudoku).
13:07:46 <weitzman> \z: I have not, but I shall
13:08:05 <\z> weitzman: Dominus has a history of skepticism about design patterns
13:08:37 <\z> the gist of design patterns is lost in the Gang of Four book, doubly so in the cult of design-patterns-as-used-in-general-practice
13:09:06 <shahn> sorry, where can i find documentation on "$=" ?
13:09:17 <\z> weitzman: also http://newbabe.pobox.com/~mjd/blog/prog/johnson.html
13:09:20 <lambdabot> Title: The Universe of Discourse : Ralph Johnson on design patterns, http://tinyurl.com/o5hcl
13:09:22 <vincenz> @hoogle ($=)
13:09:24 <lambdabot> Did you mean: ($=)
13:09:24 <lambdabot> Prelude.undefined :: a
13:09:24 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:09:30 <hygge> ah, cale :p what you said, was as i had it already, but then i guess i cant minimize it anymore.
13:09:36 <shahn> ah
13:10:14 <shahn> hmm
13:10:26 <Cale> map (map (not . isJust)) is pretty minimal :)
13:10:46 <hygge> yeah ;)
13:10:47 <glguy> ?type isNothing
13:10:49 <lambdabot> forall a. Maybe a -> Bool
13:10:58 <Cale> or yeah, you can use isNothing :)
13:10:59 <glguy> map (map isNothing)
13:11:04 <hygge> hmm, can i use the (!!) in inverse, as i have an element and i wanna know the position of it?
13:11:18 <Cale> you said that isjust was actually one of your functions though -- is it the same as the one in the library? :)
13:11:31 <Cale> @type findIndex
13:11:32 <glguy> hygge: findIndex
13:11:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
13:11:41 <Cale> @type elemIndex
13:11:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
13:11:51 <hygge> cale, i can check if it is.
13:11:56 <Cale> @type elemIndices
13:11:58 * glguy thinks that those two functions should return a MonadPlus
13:11:58 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
13:12:07 <Cale> @type findIndices
13:12:09 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
13:12:33 <hygge> Cale, no no. mine is special. isJust (Just x) = x >= 1 && x <= 9
13:12:35 <Cale> yeah, that would be reasonable
13:12:39 <glguy> @type Data.Map.lookup
13:12:40 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
13:12:45 <glguy> like this ^^
13:12:45 <Cale> hygge: ah
13:13:01 <Cale> glguy: yeah, but that one should be MonadZero
13:13:04 <Cale> and not Monad :)
13:13:09 <glguy> Cale: not my fault :)
13:13:13 <Cale> right
13:13:17 <glguy> I just like the behavior
13:13:27 <glguy> ?instances MonadZero
13:13:29 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:13:35 <glguy> what is MonadZero?
13:13:49 <Cale> It's like MonadPlus, but without the Plus
13:13:53 <int-e> the class that defines fail, in Cale's mythical Haskell universe.
13:13:58 <Cale> It just has mzero
13:14:15 <Cale> int-e: It existed in previous versions of Haskell
13:14:24 <Cale> (e.g. 1.4)
13:14:28 <glguy> so did monad comprehensions )-:
13:15:32 <jgrimes> when using a parser generator like happy do you generally include primitives as identifiers, or just look them up later like user defined functions?
13:17:57 <int-e> @undo (a:as) <- x; y
13:17:59 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 8}) "Parse error"
13:18:04 <int-e> @undo do (a:as) <- x; y
13:18:05 <lambdabot> x >>= \ b -> case b of { (a : as) -> y; _ -> fail ""}
13:18:52 <int-e> so how many monads ended up with having an MonadZero instance that read mzero = error "mzero"?
13:18:55 <vincenz> jgrimes: erm, refine your question?
13:19:07 <weitzman> @. pl undo do (a:as) <- x; y
13:19:08 <lambdabot> (line 1, column 24):
13:19:08 <lambdabot> unexpected "{"
13:19:08 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
13:19:32 <weitzman> The @pl command is very picky about something or other. It fails a lot
13:19:51 <glguy> weitzman: the case of breaks it
13:21:09 <jgrimes> vincenz, ok. so I'm writing a parser for a simple s-exp based language. When defining primitives for the language, I'm currently including them as identifiers in the grammar. I also have a catch-all identifier for functions that aren't explicitly defined as identifiers (things that aren't primitives). I'm wondering if this is how it is usually done, or if primitives are looked up after parsing is done.
13:22:05 <vincenz> jgrimes: few things
13:22:32 <jgrimes> vincenz, and if you can't tell. I really haven't done anything like this before.
13:22:58 <vincenz> jgrimes: a) most people will tell you to use paresc (mind you I have used happy as well cause I enjoyed it better).  b) Don't you have a lexer up front (alex?) c) yes primitive lookup is done after.  You do parsing based on syntax of language, whether a language is a primitive or not really dooes not belong in your syntax or it's badly designed imho
13:23:08 <vincenz> erm
13:23:13 <vincenz> whether a token is a primitive or not...
13:23:15 <vincenz> not language
13:23:37 <jgrimes> yes I have a really simple lexer
13:24:14 <vincenz> right
13:24:19 * Philippa notices that 3rd, 4th and 5th level headers on the TMR wiki are pretty much indistinguishable reading in firefox
13:24:24 <vincenz> but the lex rule for identifiers should be rather easy no?
13:24:29 <vincenz> I mean the parse rule
13:25:03 <vincenz> I mean identifiers should be identified already in the lexer
13:25:12 <jgrimes> vincenz, that answers my question
13:25:13 <jgrimes> :)
13:25:21 <vincenz> jgrimes: writing scheme compiler?
13:25:25 <jgrimes> vincenz, yes
13:25:47 <vincenz> anyways
13:26:00 <vincenz> primitive or not... that really should not be done at any level but at the module-import level
13:26:04 <vincenz> imo
13:26:15 <vincenz> basically have some modules that have native implementations
13:26:19 <vincenz> but stick to the same module system
13:26:23 <jgrimes> hm
13:26:24 <jgrimes> ok
13:26:38 <vincenz> I fail to see why you should identify primitive functions, unless you mean primitive constructs like "if"
13:26:44 <jgrimes> no
13:26:59 <vincenz> or you don't plan to have a module system?
13:27:09 <jgrimes> I mean like (+ ...) or (bool? ...)
13:27:15 <vincenz> ah right
13:27:18 <vincenz> well they'r ejust functions like others
13:27:27 <SamB> vincenz: I think you should tell the DSSSL people that stuff ;-)
13:27:28 <vincenz> only that their implementation is defined in native code
13:27:34 <vincenz> SamB: what stuff?
13:27:44 <SamB> about not including primitives in the grammer ;-)
13:27:47 <jgrimes> vincenz, ok, that makes sense
13:27:57 <glguy> DSSSL?
13:28:07 <vincenz> domain specific something special language
13:28:13 <jgrimes> and I plan to eventually have a module system...
13:29:02 <SamB> styling language with less verbosity than XSLT
13:29:18 <vincenz> jgrimes: this an open-source project?
13:29:40 <roconnor> How big is a thunk in GHC?
13:29:44 <jgrimes> vincenz, will be once more is implemented
13:29:54 * vincenz nods
13:29:59 <SamB> roconnor: it depends on how many free variables it stores
13:30:13 <vincenz> jgrimes: keep me posted, I'm interested, if you want to talk more about compilers, my personal channel is #oasis :)
13:30:19 <SamB> or do I mean bound vars?
13:30:26 <SamB> anyway...
13:30:26 <jgrimes> vincenz, all right :)
13:30:47 <SamB> how many variables it has to carry from the lexical context...
13:36:36 <dreamEye> hi
13:38:56 <dreamEye> @hello lambdabot
13:38:56 <lambdabot> Maybe you meant: help hylo tell
13:39:14 <roconnor> SamB how about the case of 0 free variables?
13:39:18 <dreamEye> where I am
13:39:26 <SamB> roconnor: example?
13:39:33 <dreamEye> ergo sum, sorry
13:40:08 <roconnor> SamB How about the number 5.
13:40:28 <SamB> as an Int?
13:40:39 <roconnor> @vixen hello lambdabot
13:40:40 <lambdabot> hi
13:40:52 <roconnor> SamB sure
13:41:02 <SamB> probably 2 or 3, depending on which generation it is in
13:41:19 <SamB> but usually we don't call that a thunk...
13:41:29 <roconnor> oh
13:42:02 <SamB> usually we use "thunk" when referring to yet-to-be-evaluated values
13:42:03 <SamB> ;-)
13:42:18 <roconnor> ok, how about 2 + 3
13:42:52 <SamB> hmmm
13:43:13 <SamB> I don't rightly know
13:55:52 <roconnor> @docs Data.MArray
13:55:52 <lambdabot> Data.MArray not available
13:56:03 <roconnor> @docs Data.Array.MArray
13:56:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
14:06:41 <roconnor> @hoogle writeIORef
14:06:42 <lambdabot> Data.IORef.writeIORef :: IORef a -> a -> IO ()
14:10:10 <mux> heh
14:10:30 * mux tries to understand why his mult.2d implementation thinks that 3 * 2 = 8
14:10:58 * glguy only did mult and rev... didn't even bother with raytrace
14:11:57 <int-e> I somehow missed a medium sized 2D task :/
14:12:43 <SamB> int-e: huh?
14:12:45 <int-e> mux: does it also think that 0*2 = 2?
14:13:04 <mux> very, very likely
14:13:05 <int-e> SamB: something between raytracing and trivial recursive functions. a sort function, perhaps.
14:13:08 <mux> I think yes
14:13:21 <mux> actually, this 2d code is lame :-P
14:13:25 * mux re-does it
14:13:29 <defcon8> how do I generate a range of numbers in a list?
14:13:31 <SamB> all 2d code is lame!
14:13:49 <SamB> > let n = 10 in [1..n]
14:13:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:14:38 <defcon8> thanks
14:21:51 <defcon8> fun n = and (div n)
14:21:51 <defcon8> div n 1 = [True]
14:21:51 <defcon8> div n cur = (\x -> mod n cur == 0) : div n (cur - 1)
14:22:01 <defcon8> how would I get this so I only had to define div twice and fun not at all
14:22:15 <defcon8> I'm trying to see if a number is divisible by numbers 1 to 20
14:24:13 <defcon8> aynone?
14:26:25 <Lemmih> What's with the lambda: (\x -> mod n cur == 0)?
14:26:54 <defcon8> cur starts with 20
14:27:00 <defcon8> then goes down to one
14:27:07 <roconnor> @hoogle copyArray
14:27:07 <lambdabot> Foreign.Marshal.Array.copyArray :: Storable a => Ptr a -> Ptr a -> Int -> IO ()
14:27:13 <roconnor> @hoogle copy
14:27:13 <lambdabot> Distribution.InstalledPackageInfo.copyright :: InstalledPackageInfo -> String
14:27:13 <lambdabot> Distribution.PackageDescription.copyright :: PackageDescription -> String
14:27:13 <lambdabot> System.Directory.copyFile :: FilePath -> FilePath -> IO ()
14:27:25 <Lemmih> defcon8: What about 'x'?
14:28:26 <defcon8> that's just silly actually
14:28:44 <defcon8> div n cur = (mod n cur == 0) : div n (cur - 1)
14:29:29 <lennart> defcon8: all ((== 0) . (n `mod`)) [1..20]
14:29:40 <SamB> > let div n m = map (mod n) [m,m-1,0
14:29:41 <lambdabot>  Parse error
14:29:45 <SamB> > let div n m = map (mod n) [m,m-1,0]
14:29:46 <lambdabot>  Parse error
14:29:59 <defcon8> it is very disheartening when seeing such a one-liner against my three liner
14:30:03 <SamB> > let div n m = map (mod n) [m,m-1,0] in div 20 10
14:30:05 <lambdabot>  Exception: divide by zero
14:30:07 <SamB> hmm
14:30:10 <SamB> > let div n m = map (mod n) [m,m-1,1]
14:30:11 <lambdabot>  Parse error
14:30:16 <SamB> > let div n m = map (mod n) [m,m-1,1] in div 20 10
14:30:18 <lambdabot>  [0,2,0]
14:30:26 * SamB missing something...
14:30:32 <defcon8> lennart, does that work?
14:30:43 <SamB> > let div n m = and (map ((== 0) . mod n) [m,m-1,1] in div 20 10)
14:30:46 <lambdabot>  Parse error
14:30:49 <SamB> > let div n m = and (map ((== 0) . mod n) [m,m-1,1]) in div 20 10
14:30:51 <lambdabot>  False
14:30:55 <defcon8> why is mod in ``?
14:30:57 <lennart> > let n = 22 in all ((== 0) . (n `mod`)) [1..20]
14:30:58 <SamB> > let div n m = or (map ((== 0) . mod n) [m,m-1,1]) in div 20 10
14:30:59 <lambdabot>  False
14:31:00 <lambdabot>  True
14:31:30 <lennart> > let n = product[1..20] in all ((== 0) . (n `mod`)) [1..20]
14:31:31 <int-e> defcon8: that makes an infix operator from  mod.
14:31:31 <SamB> > let div n m = any ((== 0) . mod n) [m,m-1,1] in div 20 10
14:31:32 <lambdabot>  True
14:31:33 <lambdabot>  True
14:31:40 <defcon8> cool
14:31:48 <Lemmih> defcon8: let fun n cur = and [ mod n c == 0 | c <- [2..cur]]
14:32:43 <defcon8> lennart, is that the first one?
14:32:51 <defcon8> yeah, it must be
14:32:52 <lennart> The first what?
14:33:01 <araujo> What would be a nice name for a function that does totally the opposite of a lexer? (join tokens)
14:33:02 <defcon8> first number that can be divided by numbers 1 to 20
14:33:06 <lennart> no
14:33:38 <lennart> > head [ all ((== 0) . (n `mod`)) [1..20] | n <- [1..]]
14:33:40 <lambdabot>  False
14:33:40 <defcon8> how would I find the first?
14:33:41 <SamB> araujo: concat!
14:33:51 <defcon8> lennart, nice
14:33:56 <lennart> bah
14:34:01 <araujo> SamB, yeah? .... mm ... that isn't too computer scientist
14:34:04 <araujo> :-)
14:34:17 <lennart> > head [ n | n <- [1..], all ((== 0) . (n `mod`)) [1..20]]
14:34:22 <lambdabot> Terminated
14:34:25 <SamB> > lex "[1,2,3]"
14:34:28 <lambdabot>  [("[","1,2,3]")]
14:34:36 <SamB> hmm
14:34:43 <SamB> @hoogle lex
14:34:45 <lambdabot> Prelude.lex :: ReadS String
14:34:45 <lambdabot> Text.Read.Lex.lex :: ReadP Lexeme
14:34:45 <lambdabot> Text.Read.Lex :: module
14:34:53 <araujo> wat about, rexel?
14:35:02 <araujo> hah, i think i will use this one
14:35:03 <defcon8> is there a find function
14:35:11 <defcon8> lennart, what about searching for the first true?
14:35:13 <SamB> @hoogle ReadS
14:35:15 <lambdabot> Prelude.ReadS :: type ReadS a
14:35:15 <lambdabot> Prelude.reads :: Read a => ReadS a
14:35:15 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
14:35:34 <Lemmih> defcon8: How about: let fun n cur = and [ mod n c == 0 | c <- [2..cur]] in head $ filter (flip fun 20) [1..] ?
14:35:38 <lennart> defcon8: yes, that
14:35:54 <defcon8> the one that got terminated?
14:35:54 <lennart> yes that's what the expression lambdabot didn't like does
14:35:58 <lennart> yes
14:36:22 <lennart> it's a rather large number
14:36:34 <defcon8> still have no result on an amd athlon 64 :D
14:37:02 <SamB> @type first
14:37:04 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
14:37:07 <lennart> > 2^4*3^2*5*7*11*13*17*19
14:37:07 <defcon8> wtf
14:37:09 <lambdabot>  232792560
14:37:25 <lennart> that's the one, i think
14:37:42 <defcon8> how come?
14:37:51 <SamB> > unfoldr (listToMaybe . lex) "[1,2,3]"
14:37:53 <lambdabot>  ["[","1",",","2",",","3","]","","","","","","","","","","","","","","","",""...
14:37:55 <defcon8> bloody hell, still no result :|
14:37:56 <SamB> hmm....
14:38:10 <defcon8> SamB, what is this lex stuff?
14:38:13 <defcon8> what does lex do?
14:38:13 <lennart> it has enough factors of all the primes under 20
14:38:22 <twanvl> > foldl1 lcm [1..20]
14:38:24 <lambdabot>  232792560
14:39:02 <defcon8> whoah
14:39:16 <lennart> heh
14:39:21 <glguy> twanvl: mathschallenge.net problem?
14:39:31 <lennart> good thinking!
14:39:36 <defcon8> glguy, yes
14:39:42 <defcon8> twanvl, damn
14:39:50 <glguy> I know it is, but i was wondering if that's why ti was being done :)
14:39:53 <SamB> > unfoldr (listToMaybe . filter (not . null . snd) . lex) "[1,2,3]"
14:39:56 <lambdabot>  ["[","1",",","2",",","3"]
14:40:01 <SamB> ah, much better ;-)
14:40:08 <SamB> anyway!
14:40:25 <SamB> now to demonstrate how "concat" is what you call the function to put the tokens back together!
14:40:32 <SamB> > concat $ unfoldr (listToMaybe . filter (not . null . snd) . lex) "[1,2,3]"
14:40:34 <lambdabot>  "[1,2,3"
14:40:38 <SamB> hmm.
14:40:46 * SamB is missing something.
14:42:46 <lennart> SamB: for the last "]" the second component will be ""
14:42:57 <SamB> lennart: true
14:43:00 <twanvl> > concat $ unfoldr (listToMaybe . filter (not . null . fst) . lex) "[1,2,3]"
14:43:02 <lambdabot>  "[1,2,3]"
14:43:13 <SamB> ah ;-)
14:43:45 <SamB> but anyway. that is why I call a function to put the tokens back together "concat"
14:44:05 <Philippa> is Control.Monad.Reader lazy?
14:44:17 <SamB> Philippa: presumably!
14:44:37 <SamB> @darcs Control.Monad.Reader
14:44:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
14:44:45 <Philippa> ...that explains a lot
14:44:52 <SamB> @fptools Control.Monad.Reader
14:44:53 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
14:45:15 <SamB> newtype Reader r a = Reader { runReader :: r -> a }
14:45:24 <SamB> that looks fairly lazy to *me*!
14:45:34 <Philippa> that on its own doesn't say a damn thing
14:45:38 <Philippa> the implementation of >>= matters
14:45:44 <SamB> oh, that kind of lazy
14:45:57 <SamB> 	m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
14:47:25 <SamB> looks pretty lazy to me!
14:47:42 <Philippa> yeah. This explains why I can't get my cbv lambda evaluator to fail to terminate when it should
14:48:38 <SamB> heh
14:49:17 <SamB> > let forever p = p >> forever p in forever id ()
14:49:19 <lambdabot>  Add a type signature
14:49:58 <Philippa> seq is my friend :-)
14:50:21 <SamB> > let forever p = p >> forever p in runReader ((forever id :: Reader ()) >> return ()) undefined
14:50:22 <lambdabot>    `Reader ()' is not applied to enough type arguments
14:50:22 <lambdabot>   Expected kind `?...
14:50:32 <SamB> > let forever p = p >> forever p in runReader ((forever id :: Reader () ()) >> return ()) undefined
14:50:33 <lambdabot>    Expecting a function type, but found `m a'
14:50:34 <lambdabot>    Expected type: Reader (...
14:51:10 <SamB> > let forever p = p >> forever p in ((forever id) >> return ()) undefined
14:51:12 <lambdabot>  ()
14:52:33 <SamB> > let forever p = p >> forever p; p >>! q = p >>= \x -> x seq q x in ((forever id) >>! return ()) undefined
14:52:34 <lambdabot>    Occurs check: cannot construct the infinite type:
14:52:35 <lambdabot>    t = (a -> t1 -> ...
14:52:51 <SamB> > let forever p = p >> forever p; p >>! q = p >>= \x -> x `seq` q x in ((forever id) >>! return ()) undefined
14:52:53 <lambdabot>  Couldn't match `a -> b' against `()'
14:52:58 <hyrax42_> ?inded (>>!)
14:52:58 <lambdabot> bzzt
14:53:03 <hyrax42_> ?index (>>!)
14:53:03 <lambdabot> bzzt
14:53:06 <hyrax42_> ?index >>!
14:53:07 <lambdabot> bzzt
14:53:07 <SamB> > let forever p = p >> forever p; p >>! q = p >>= \x -> x `seq` q in ((forever id) >>! return ()) undefined
14:53:12 <lambdabot> Terminated
14:53:14 <hyrax42_> oh
14:53:21 <hyrax42_> you are defining
14:53:31 <yip> do you guys think that haskell/functional-programming would offer a real benefit over c/java for triangle strip detection in 3d meshes?
14:53:34 <musasabi> I think
14:53:39 <musasabi> agh. wrong channel.
14:54:05 <SamB> yip: well, its nice not to fall asleep whilst reading the code ;-)
14:54:32 <vincenz> Philippa: ping
14:54:47 <Philippa> 'lo
14:54:52 <SamB> on the other hand, it is also nice not to fall asleep whilst waiting for the code to finish running :-(
14:54:55 <yip> SamB: i'm actually not familiar with any of the algorithms, but i figure that they use some sort of minimal AI
14:55:14 <yip> SamB: do you think a purefly functional solution would be that much slower?
14:55:22 <SamB> then again, who would write code with a decent algorithm in Java anyway?
14:55:38 <yip> SamB: well, all of the implementations i am aware of are written in c
14:57:43 <SamB> honestly I don't know anything about the algorithms either
14:58:49 <yip> SamB: a really simple attempt might be to recursively detect the longest strip you can find in the mesh, until there are no more triangles left
15:01:34 <yip> SamB: an interesting aspect of the problem is that you actually don't even need to know the 3d vertex information. the entire mesh can be typed as [(Int, Int, Int)]
15:01:48 <yip> each triplet is a triangle
15:02:03 <SamB> hmm
15:02:24 * SamB wonders if there are performance considerations in whatever has to render the strips?
15:02:25 <Heffalump> this wiki migration, is there any special procedure or should I just cut and paste content (after checking any licensing issues)?
15:03:04 <SamB> Heffalump: you also have to switch markup and probably ought to make the old page into a link to the new one...
15:03:11 <Heffalump> ok
15:03:11 <yip> SamB: the only consideration is the number of strips. the goal of the algorithm is to find the minimum amount of strips needed
15:03:15 <SamB> probably there is no procedure ;-)
15:06:21 <Lemmih> @seen shapr
15:06:22 <lambdabot> I saw shapr leaving #haskell and #haskell.se 1d 2h 26m 26s ago, and .
15:07:18 <yip> SamB: more advanced mesh optimizations will generate triangle fans in addition to triangle strips, and even more important, will rearange the vertex indices so that repeated accesses to the same vertices are performed sequentially. this increases the chance of them still being in the cache
15:09:21 <sylvan> yip, why do you want to do strip detection? Optimize for vertex cache, it's a far more useful than stripping (best case is 0.5 verts per triangle, typical is 0.6 or so, much better than the theoretical optimum of 1 vert per tri that you get with stripping)
15:11:35 <yip> the cache is quite small when dealing with large meshes
15:12:19 <yip> and it's difficult to do cache optimization that works well with a variety of cache sizes
15:14:11 <sylvan> There are a few that works well with most cache sizes, and you could always go with a safe number (say 10 verts). Even with that you're probably going to get better than 1 vert per triangle... And for a lot of meshes 1 vert per tri is hard to get with strippers because they're not very strip friendly so you have to insert a bunch of degenerate triangles (or the new strip restart index in DX10 and XBox360)
15:14:18 <sylvan> but this is a tad off topic...
15:16:21 <yip> so would haskell be good for a vertex cache mesh optimizer? :)
15:17:03 <sylvan> Probably! It might be one of those "99% of the time is spent in 1 page of code" programs where C is actually very good, though
15:17:25 <sylvan> Here's a paper that describes a good (I hear) algorithm for non-known cache sizes: Universal rendering sequences for transparent vertex caching of progressive meshes Alexander Bogomjakov, Craig Gotsman
15:17:39 <magnus-> Is there any proposal for a haskell exception system with restarts ala common lisp?
15:18:10 <magnus-> it kinda clicked to me why they are useful today as I was writing some haskell code
15:18:35 * Heffalump remembers discussing this with someone a while ago
15:18:48 <Heffalump> there's no reason you can't make an exception type with restarts, I don't think
15:19:29 <Heffalump> you might need to be within a continuation monad
15:20:36 <magnus-> Heffalump: yeah.. I haven't really thought about it much
15:21:57 <Heffalump> if you pass in the restart computation when doing the throw, you don't need a continuation monad
15:22:12 <Heffalump> if you want it just to be the next statement in the do, you probably need to use ContT
15:23:29 <magnus-> Or one could register handlers which are located and called at the throw
15:24:42 <hygge_> prop_blank sudoku = (((rows sudoku) !! y) !! x) == Nothing
15:24:47 <hygge_> hmm
15:24:51 <hygge_> can i write this any better?
15:25:47 <hygge_> (rows sudoku) is a [[maybe int]]
15:26:32 <Heffalump> if it really is a sudoku, why bother quantifying over the coordinates? Why not just check the whole lot?
15:26:49 <Heffalump> they're really not very big
15:27:34 <hygge_> 9x9 they are
15:27:49 <Heffalump> right
15:28:28 <hygge_> this is a lab we're doing at school. i think we are going to use the cordinates to be able to select one "cell" and then modify its value. in the end, our program will modify it and solve a whole sudoku :)
15:28:38 <yip> sylvan: hm... that paper is the product of the technion :)
15:29:09 <Heffalump> oh, that's not a quick check property?
15:29:27 <sylvan> yip, the what now?
15:29:29 <SamB_XP> heh
15:32:56 <hygge_> heffalump, it is, if u asked me?
15:33:20 <hygge_> but :) i didnt show you the secon line, with a "where"
15:33:48 <hygge_> goodevenin' samb_xp btw
15:34:10 <SamB_XP> good evening
15:36:06 <roconnor> > 8*2^20
15:36:08 <lambdabot>  8388608
15:36:21 <roconnor> > 15923864/4
15:36:22 <lambdabot>  3980966.0
15:41:50 <roconnor> 2^31
15:41:57 <roconnor> > 2^31
15:41:58 <lambdabot>  2147483648
15:42:33 <roconnor> @hoogle newArray
15:42:34 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:42:34 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:42:34 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
15:43:03 <Lemmih> @hoogle oldArray
15:43:04 <lambdabot> No matches found
15:51:25 <vincenz> @hoogle Lemmih
15:51:25 <lambdabot> No matches found
15:55:27 <roconnor> hmm array lower bounds checking isn't needed if the index type is Word32 and the array starts at 0.
15:55:37 <roconnor> I don't suppose this is optimised.
15:58:53 <yip> upper bounds checking isn't needed if the index type is Word8 and the array ends at 255 :D
15:59:15 <roconnor> also true
16:07:31 <tom_> a
16:08:41 <lispy> okay, half the memory in my program is allocated by a CAF, in that modlue i've added an SCC to each function
16:08:52 <lispy> but it still insists it's used by the CAF
16:08:54 <lispy> so odd
16:09:11 <tom_> hi, anyone familiar with parsec?
16:09:29 <Lemmih> @google 2 parsecs in km
16:09:31 <lambdabot> 2 Parsecs = 6.1713605 x 10^13 kilometers
16:10:00 <Lemmih> tom_: Yes.
16:10:59 <tom_> How can I match "zero or one" ?
16:11:11 <Lemmih> @hoogle optional
16:11:12 <lambdabot> Text.ParserCombinators.ReadP.optional :: ReadP a -> ReadP ()
16:11:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator.optional :: GenParser tok st a -> GenParser tok st ()
16:11:23 <Lemmih> @hoogle option
16:11:24 <lambdabot> Text.Html.option :: Html -> Html
16:11:24 <lambdabot> Text.ParserCombinators.ReadP.option :: a -> ReadP a -> ReadP a
16:11:24 <lambdabot> Text.ParserCombinators.Parsec.Combinator.option :: a -> GenParser tok st a -> GenParser tok st a
16:12:00 <Lemmih> tom_: Disregard the ReadP and Html.
16:16:10 <dreamEye> Haskell recomended by W3C  as  language of choice  http://www.w3.org/2001/tag/doc/leastPower.html
16:16:12 <lambdabot> Title: The Rule of Least Power, http://tinyurl.com/k5ulj
16:17:20 <dons> interesting
16:18:28 <dons> so "When publishing on the Web, you should usually choose the least powerful or most
16:18:32 <dons> easily analyzed language variant that's suitable for the purpose."
16:18:46 <dons> where Haskell is their example. nice!
16:18:50 <tom_> Lemmih: i think i got it: option ' ' (char '.') -- for an optional dot for example
16:19:03 <dons> editors Tim Berners-Lee and Noah Mendelsohn
16:19:14 <dreamEye> nothing less, yes
16:19:23 <araujo> yay!
16:19:31 <araujo> Tim is on our side!
16:20:15 <tom_> thanks
16:21:51 <cdfh> i'm somewhat unimpressed with w3c's use of "power"
16:22:01 <dons> its a bit weird isn't it.
16:22:23 <dreamEye> no, if you think on reusability
16:22:32 <cdfh> by "power", i presume they mean the ability to muddle with low-level fiddly things
16:22:56 <cdfh> but it could mean any number of things
16:23:44 <dmhouse> Any yet they spend the majority of the first paragraph talking about Turing-completeness, which is a pointless way of judging the power of a language.
16:24:14 <cdfh> dmhouse: indeed - especially since almost all languages these days are turing complete
16:24:15 <dmhouse> I guess they mean "use the simplest tool that gets the job done."
16:24:28 <cdfh> i suspect regexpes are too, actually
16:24:40 <cdfh> since a regexp is a finite state machine, itself
16:25:04 <cdfh> if you can control the data _and_ the regexp, and you can perform many passes, i think it's probably turing complete
16:25:04 <dmhouse> But then that's not universally good advice -- what if you discover new requirements that force you to extend your solution in an unexpected way?
16:25:14 <dreamEye> the simplest, most readable code that do it. I thing this is intelligent
16:25:17 <dmhouse> The last thing you want to do is be held back by the language you've chosen.
16:25:49 <cdfh> dmhouse: indeed - although, only to a certain extent
16:25:49 <lispy> how to convert postscript to pdf on windows?
16:26:15 <cdfh> dmhouse: i would say "choose the best language for the job ''with room for reasonable improvements and scaleability''"
16:26:21 <dmhouse> Section 2 seems to be talking about the modularity of the web, which is true.
16:26:23 <dons> yeah. the basic thesis is spot on. particuarly for web stuff: use a language that you can analyse and reason about. whether that be a mini language, a DSL, or Haskell
16:26:24 <dmhouse> cdfh: sounds reasonable.
16:26:32 <cdfh> dmhouse: :-)
16:27:00 <dmhouse> You can tell the fact that web technologies are modular, because in the average HTML file you'll have 3-4 different languages.
16:27:23 <dons> the fact they've started talking about 'analysing' (aka reasoning) about code is great. exactly what have we been banging on about for years now.
16:27:23 <dmhouse> All of which have radically different syntax and styles.
16:27:32 <lispy> dons: so i have a module that reports 55% of my allocation in the CAF.  I added SCC's to each top level binding...and it still says that...any idea how to get it to break it down?
16:27:48 <dons> lispy: hmm. can you annotate the subexpressions?
16:28:00 <lispy> dons: let me show you the file
16:28:05 <dons> there's usually no need to annotate at the top level, -auto-all does that for you
16:28:24 <lisppaste2> lispy pasted "CAF" at http://paste.lisp.org/display/27512
16:28:46 <lispy> that's what i thought
16:28:50 <lispy> i did it just to be sure
16:29:02 <dons> someone want to post that link to reddit? with the title "w3c recommends Haskell for the web" or such like....
16:29:21 <dons> ;)
16:29:23 <dmhouse> "...functional languages such as Haskell and XSLT..." -- hehe, they're not _that_ alike
16:29:26 * musasabi succeeded in creating an easy way of doing graphical windows installers for binary versions of Cabal packages :-)
16:29:37 <dons> musasabi: cool!
16:29:40 <dons> musasabi++
16:29:44 <dmhouse> I read about someone who wrote a prime-finding algorthim in XSLT once.
16:29:45 <lisppaste2> lispy annotated #27512 with "profile" at http://paste.lisp.org/display/27512#1
16:30:15 <lispy> dons: that's the profile output and the source module which is giving me a headache
16:30:21 <dons> looking...
16:30:28 <musasabi> Will package it up and send to the ML over the weekend.
16:30:39 <dreamEye> XSLT is also a functional language itsnt?
16:31:07 <dmhouse> dreamEye: technically, yes. But in practice, it's impractical to call it a programming language.
16:31:30 <dmhouse> It's Turing-Complete, which is a testament to its over-design if anything.
16:31:50 <dreamEye> if someone call  it to CSS and HTML .....
16:32:07 <dreamEye> a language is a language. turing complete or not
16:32:10 <dons> lispy: hmm. you could start with some strictnes annotations on your fields.
16:32:16 <dons> otherwise, i'd need more info
16:32:39 <lispy> what sort of info/
16:32:43 <dons> possibly some SPECIALIZE pragmas for the overloaded stuff
16:32:48 <dmhouse> Well, it's far too late for me. G'night everyone.
16:32:56 <cdfh> night
16:33:06 <hygge> "cannot find binding for operator "!!+" in fixity declaration" - what does this mean?
16:33:29 <dmhouse> hygge: it probably means your declaring fixity for an operator you haven't defined.
16:33:41 <dons> hmm. is !!+ a function in your code?
16:33:43 <lispy> dons: for the strictness, i have ghc6.5, can i just throw in some bangs or do i need to turn on something?
16:33:44 <hygge> yeah
16:33:55 <dons> lispy: just throw in some ! on your fields, in the data decls
16:34:08 <lispy> Oh, yeah...that's not really possible
16:34:09 <hygge> infixl 9 !!+
16:34:09 <hygge> []   (!!=) _         = []
16:34:17 <hygge> this is enough?
16:34:32 <Cale> [] !!= _ = []
16:34:32 <lispy> dons: unless you meant just the ones in that file
16:34:43 <hygge> ok
16:34:51 <Cale> you don't use parens when you're writing it infix
16:34:55 <hygge> okej
16:34:56 <lispy> dons: but no idea how to get that CAF to split up into a more detailed look?
16:35:01 <lispy> dons: because that's my real problem
16:35:59 <dons> yeah, I don't even see what its referring too. weird
16:36:05 <hygge> hm, stil same error.
16:36:49 <lispy> and visual haskell crashes too much...switching to emacs :)
16:36:54 <dons> > let [] !!= _ = [] in [] !!= "bar"
16:36:55 <lambdabot>  Add a type signature
16:37:01 <dons> > let [] !!= _ = [] in [] !!= "bar" :: String
16:37:02 <lambdabot>  ""
16:37:27 <dons> lispy: you could try haskell-cafe@
16:37:38 <lispy> yeah
16:38:02 <hygge> haskell-cafe?
16:38:06 <lispy> dons: i'd have to modify haxml to add strictness to my datastructures
16:38:12 <lispy> dons: how important do you think that is?
16:38:23 <dons> what about this Merge type?
16:38:38 <lispy> it's not used much
16:38:43 <lispy> but i did add the annotations just now
16:38:53 <dons> you could try sticking some seqs in. but I think there should be a way to get more info from the profiler
16:39:14 <lispy> let me ask in #ghc real quick about the CAF thing
16:39:38 <dons> hygge: haskell-cafe@ is a mailing list
16:40:22 <dreamEye> [] !!= _ = []   seems to be a Manga emoticon
16:40:47 <hygge> okey!
16:40:55 <hygge> haha :)
16:41:18 <dreamEye> has Haskell something hidden to say to the Humanity with this?
16:41:23 <hygge> here is my code http://pastebin.com/801697
16:41:50 <lispy> apparently ghc specific questions are not allowed in #ghc?
16:42:09 <dons> ah well. haskell-cafe@ or else dive into the profiling docs
16:42:32 <Cale> lispy: #ghc is for ghc development questions
16:43:04 <dons> lispy: you could probably strictify your mkCells
16:43:24 <vincenz> vincenz--
16:43:29 <vincenz> @karma vincenz
16:43:30 <lambdabot> You have a karma of 9
16:43:31 <vincenz> vincenz--
16:43:32 <vincenz> @karma vincenz
16:43:32 <lambdabot> You have a karma of 9
16:44:31 <Cale> you can't affect your own karma, except by trying to improve Java's
16:44:47 <int-e> java--
16:44:54 <int-e> @karma java
16:44:55 <lambdabot> java has a karma of -11
16:45:12 <dons> its a very simple rule to remember :)
16:45:24 <lispy> dons: okay, stuck in lots of bang patterns in mkCell and Merge type...running again /me crosses fingers
16:52:04 <newbcoder> is java a person or a bot?
16:52:04 <dons> a language...
16:52:04 <newbcoder> oh
16:52:04 <newbcoder> funny
16:52:04 <hygge> (!)
16:52:04 <newbcoder> t5hought it was a brand of coffee
16:52:04 <hygge> isnt it an island?
16:52:04 <dons> its a place where coffee is grown...
16:52:04 <int-e> cafebabe--
16:52:04 <hygge> netherless
16:52:04 <dons> int-e: heh
16:52:04 <newbcoder> what was the first version of hasjkell written in?
16:52:04 <newbcoder> scheme?
16:52:04 <newbcoder> ml?
16:52:04 <dons> miranda, I think.
16:52:04 <dons> details in the history of haskell paper
16:52:04 <hygge> its too late for coding i guess
16:52:04 <dons> also, yale haskell was written in lisp
16:52:04 <newbcoder> first result
16:52:04 <newbcoder> on google for miranda language
16:52:04 <dons> (you're really asking about which implementation, there are several)
16:52:04 <newbcoder> is not the language
16:52:04 <newbcoder> wtf
16:52:04 <dons> good places to start are, http://haskell.org/haskellwiki/Old_news#Archives_by_year
16:52:04 <lambdabot> Title: Old news - HaskellWiki, http://tinyurl.com/nuc2s
16:52:04 <dons> and http://haskell.org/haskellwiki/History_of_Haskell
16:52:04 <lambdabot> Title: History of Haskell - HaskellWiki, http://tinyurl.com/o6xyu
16:52:04 * dcoutts returns - in a merry mood
16:52:04 <Cale> http://www.engin.umd.umich.edu/CIS/course.des/cis400/miranda/miranda.html is the first hit for me, and indeed it is about Miranda
16:52:04 <lambdabot> Title: The Miranda Programming Language, http://tinyurl.com/f9txa
16:52:04 <Cale> many of the links from there seem broken
16:52:04 <Cale> but miranda is pretty close to Haskell in syntax and semantics
16:52:55 <Cale> list comprehensions use ; to separate the generators and predicates, datatypes are declared quite differently and use lowercase letters
16:53:05 <Cale> (for type constructors)
16:54:10 <lispy> can you not add strictness to a newtype?
16:54:32 <dons> miranda has no GADTs or STM or ATs or MPTCs either :) or monads (?)
16:54:45 <dons> ;)
16:54:48 <hygge> no jumbo mumbo
16:54:58 <dons> lispy: doesn't really make sense, does it?
16:55:06 <Philippa> did it ever have type classes?
16:55:46 <hygge> good night everybody
16:55:46 <lispy> dons: guess not :)
16:55:46 <lispy> dons: but i added it to a bunch of newtypes without realizing it :)
16:55:46 <dons> heh
16:55:49 <ptolomy> Anyone who makes a haskell equivalent to PerlMonks will be my hero.
16:56:00 <dons> ?google perl monks
16:56:04 <lambdabot> http://www.perlmonks.org/
16:56:04 <lambdabot> Title: PerlMonks - The Monastery Gates
16:56:46 <dons> is it a question/faq system?
16:57:14 <ptolomy> Partially.
16:57:22 <tom_> this lamdabot really scares me... :)
16:57:58 <dons> > fix $ \f -> 1 : 1 : zipWith (+) (tail f) f
16:58:00 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
16:58:24 <ptolomy> I suppose the benefit of PerlMonks is more in the culture and user base than the actual code..
16:59:15 <ptolomy> Is there a forum somewhere between #haskell and the Cafe mailing list?
16:59:54 <Cale> not really. There's the Haskell Sequence, but it's not exactly lively
17:00:12 <Cale> What's wrong with haskell-cafe?
17:00:34 <ptolomy> I feel as though asking a minor "is there a better way to do this" question in Cafe is overkill and a waste of email space, while #haskell is very temporary.
17:00:55 <dons> nono. #haskell-cafe is ideal for that kind of thing
17:01:07 <dons> s/#//
17:01:36 <Cale> I think you'll find that it's quite effective at generating long threads in which your whole program is reduced to a couple of lines of compact and abstract code.
17:02:00 <ptolomy> Historically that is certainly the case.
17:02:12 * lispy sometimes wonders if ghc will be able to compile his module
17:02:19 <lispy> it really takes a long time now :)
17:02:35 <lispy> esp. the one built for profiling
17:03:57 <lispy> dons: would heap profiling help? from the description in the manual it looks like it doesn't add information just tells you about when things were in memory
17:04:04 <lispy> so i'm guessing no...
17:04:51 <lispy> hmm..yeah strictness didn't change the performance at all
17:04:58 <lispy> no change in speed or memory usage that i can see
17:07:26 <ptolomy> I guess it goes back to the previous mailing list versus forum discussion, where my vote is a solid "both and see what happens". Although, I suppose that the mailing list would be a lot more manageable if I weren't doing it digest-style.
17:08:10 <lispy> if i have "where foo = some_big_list" and i change it to "where !foo = some_big_list" does that mean foo will be strict?
17:08:33 <Cale> ptolomy: I find that it's quite manageable with something like gmail, ans especially after I started using select all -> archive :)
17:09:01 <Cale> lispy: is this with the new bang notation?
17:09:08 <ptolomy> Cale: Digest-mode or individual messages?
17:09:09 <lispy> Cale: yes
17:09:09 <Cale> I don't think it could
17:09:17 <Cale> ptolomy: individual
17:09:49 <lispy> okay....well i want to force a list to be evaluated :)
17:09:53 <lispy> maybe i should look at Evaluate
17:09:58 <lispy> ?type evaluate
17:09:59 <lambdabot> Not in scope: `evaluate'
17:09:59 <Cale> lispy: when though?
17:10:21 <lispy> so the list gets filtered...so maybe it's already pretty srict
17:10:21 <Cale> and how long do you want it to stick around?
17:10:29 <lispy> i don't want it to stick around at all
17:10:32 <Cale> okay
17:10:39 <Cale> just for the course of the evaluation?
17:10:47 <Cale> (of the surrounding function)
17:10:51 <lispy> so it's a list of records
17:11:07 <lispy> those records will get transformed to rows in an spreadsheet
17:11:13 <Cale> @type Control.Concurrent.evaluate
17:11:15 <lambdabot> Not in scope: `Control.Concurrent.evaluate'
17:11:18 <dons> lispy: the big list migt just be the wrong structure?
17:11:19 <Cale> errr...
17:11:27 <Cale> @type Control.Exception.evaluate
17:11:29 <lambdabot> forall a. a -> IO a
17:11:32 <Cale> right
17:11:36 <lispy> i'm listeing
17:12:02 <Cale> how are you accessing the list?
17:12:07 <lispy> a list is the only thing i can think of to store this in...other than store it on disk in phases
17:12:16 <lispy> Cale: as a stream
17:12:24 <lispy> so maybe the problem is strictness...
17:12:38 <Cale> that sounds like lazy should be good
17:12:42 <lispy> Cale: i have a lot of those records, then i foldl1' them down to many fewer
17:12:47 <Cale> ah
17:12:58 <Cale> how are you combining them?
17:13:00 <lispy> oh, i think i know what my program must be doing
17:13:26 <lispy> Cale: i've lifted (+) and a weighted average function
17:13:32 <Cale> hmm
17:13:41 <lispy> summing them is fast
17:13:42 <Cale> and the result is a list?
17:13:49 <Cale> or a single record?
17:13:50 <lispy> the result is a new list of records
17:13:58 <lispy> so it's like [Record] -> [Record]
17:14:00 <Cale> how are you getting a list from that?
17:14:18 <lispy> i'm not explaining this well :)
17:14:23 <lispy> that's how :)
17:14:24 <Cale> combining records which match on a specific tag?
17:14:42 <lispy> it's compilcated
17:14:45 <lispy> but kinad
17:14:55 <Cale> hmm
17:15:07 <lispy> so a row can be uniquely identified by a about 4 of itselfs
17:15:12 <lispy> its fields*
17:15:25 <lispy> and then i have whole bunch of those rows
17:15:29 <Cale> How much of the input list do you potentially need to look at to get the first element of the output list?
17:15:40 <lispy> i parse each one into a Row (was calling this a record before)
17:15:53 <lispy> gosh...
17:15:56 <Cale> (Imagine doing the computation by hand)
17:15:56 <lispy> probably the whole thing
17:15:58 <Cale> okay
17:16:12 <Cale> can the uses overlap?
17:16:21 <lispy> i think it's the "second phase" of my algorithm that's killing us
17:16:29 <Cale> or does each element of the input list contribute to only one of the elements of the output?
17:16:34 <lispy> so far i've only told you about phase 1
17:17:01 <lispy> it's sort of like you split the input into 4 chunks
17:17:01 <Cale> I'm just trying to understand the way in which the computation demands values
17:17:16 <lispy> take the first two chunks and zipWith (+) on them
17:17:28 <lispy> take the second two chucks and zipWith (+) on them
17:17:46 <lispy> that gives you two sets of rows
17:17:48 <lispy> concat them
17:17:52 <lispy> that's phase 1
17:17:56 <Cale> by split, you mean partition with a predicate, or something more obvious?
17:18:03 <lispy> where (+) is just an easy way to refer to how i combine them
17:18:09 <lispy> partition
17:18:11 <lispy> i use group
17:18:16 <Cale> hmm
17:18:17 <lispy> well, groupBy
17:18:41 <lispy> i groupBy and then filter a bit more
17:18:43 <Cale> The best way to look at it is to think about what work is needed to compute the first element of the resulting list
17:18:55 <lispy> hang on
17:19:04 <lispy> so, what i just described is "phase1"
17:19:07 <Cale> okay
17:19:11 <lispy> phase1 is pretty efficient
17:19:16 <lispy> no real problems there
17:19:24 <lispy> it's mostly O(n) in fact
17:19:30 <Cale> sounds like it shouldn't be hard to write that efficiently, so I believe it
17:19:32 <lispy> could use less memory but that's mostly the parser
17:19:48 <lispy> in phase2 (and it hink this is where the problem is)
17:20:10 <lispy> take those [Row] from phase1, parse another file and get another [Row] and now combine them in a new way
17:20:24 <Cale> hmm
17:20:32 <Cale> what's the access pattern like?
17:21:09 <lispy> the way new way treats them as cells in a spreadsheet and generates formulas to average the values in the rows (so conceptually it's a zipWith avg)
17:21:28 <Cale> hmm, okay
17:21:33 <lispy> i'm trying to think about this and get right
17:21:39 <lispy> i've thought a lot less about phase2
17:22:42 <lispy> so i bet that summary is where all the memory is consumed...in fact it probably keeps the all the [Row]'s around to do that summary/avg
17:23:00 <Cale> whoa, you said zipWith avg
17:23:14 <lispy> not a realy zipWith
17:23:16 <lispy> er real
17:23:24 <Cale> are you sure you don't mean something like averaging down the lists?
17:23:29 <Cale> what's the type of the result?
17:23:33 <Cale> [Row]?
17:23:50 <lispy> so imagine a spreadsheet
17:24:00 <lispy> and you have a bunch of sheets
17:24:07 <lispy> now create a new sheet
17:24:17 <lispy> where column1 in the average of all the column1's from the other sheets
17:24:28 <lispy> now do that for all the columns
17:24:51 <lispy> does that make more sense?
17:25:31 <Cale> so every cell of the new sheet is the average of the cells in all the other sheets
17:25:43 <Cale> (corresponding cells)
17:25:51 <lispy> yeah
17:26:08 <lispy> and so to generate the summary i don't actually need all the rows
17:26:16 <lispy> i just need enouh information to hook it up
17:26:28 <Cale> hmm
17:26:29 <lispy> but i think i give my summary sheet generator all the rows
17:27:33 <lispy> thanks for helping me think this through
17:27:39 <lispy> i'll go stare at my summary generator for a while
17:27:49 <lispy> odd that it doesn't show up in the profiler output as a trouble spot
17:27:57 <Cale> the individual summarization (averaging the numbers) processes should be strict, and the overall process should be lazy
17:28:00 <lispy> even the inherited allocation is basically 0 for it
17:28:12 <Cale> can I see the profiler output?
17:28:21 <lispy> sure
17:28:24 <Cale> (and maybe some of the code)
17:28:26 <lispy> i posted it to lisppaste
17:28:43 <lispy> Cale: http://paste.lisp.org/display/27512
17:29:10 <lispy> Cale: also you might find this helpful http://paste.lisp.org/display/27429
17:29:24 <lispy> the second one is when i was optimizing the profiler
17:29:35 <lispy> had different input then that only stressed phase1
17:31:10 <Cale> hmm
17:32:08 <Cale> some CAF in Excel.SpreadSheetUtil is takeing 44% of the time and it's not a cost centre.
17:33:20 <dons> weird, huh.
17:33:49 <lispy> yeah, that's what i was trying to ask about in #ghc :)
17:34:04 <lispy> seems like it's either user error or a bug
17:34:23 <Cale> well, that cell in the where clause is unmarked
17:34:24 <lispy> and the longer we stare at it without a clue the more i lean toward bug :)
17:34:34 * lispy checks it
17:34:38 <Cale> in mkCellWithFormula
17:34:57 <lispy> ah, yeah i added an SCC to that one since then
17:35:00 <lispy> no difference
17:35:18 <Cale> okay, one sec
17:35:36 <lispy> i think it's because of the type classes
17:35:56 <Cale> compile with -caf-all
17:35:59 <lispy> but FWIW that's the only module which instances the ExcelValue class
17:36:06 <lispy> okay, i'll try that
17:36:14 <Cale> that will give every CAF its own cost centre
17:37:04 <lispy> i'm using cabal so i have to hack that in
17:37:46 <lispy> this compile could take a while :)
17:38:15 <Cale> and we'll have a really long profiler output :)
17:38:29 <lispy> that's okay
17:38:34 <lispy> i can handle that :)
17:38:53 <Cale> I suppose it's already pretty long
17:39:15 <lispy> some of my source has more SCC decls than code :)
17:39:32 <lispy> i went a little nuts in the parser...
17:40:00 <Cale> usually you add things recursively
17:40:27 <Cale> compiling after each stage, and only marking at a finer level when there's a lot of cost on those nodes
17:40:45 <lispy> yeah, i had a lot of work to do in there :)
17:40:57 <lispy> (I start small like you say and refine)
17:42:35 <lispy> oh no
17:42:54 <lispy> the dll version dosen't build anymore...but that's not important
17:43:17 <lispy> i bet it runs out of memory too
17:43:36 <lispy> profiling seems to need a lot more ram
17:45:07 <lispy> so i had all the rows of the first sheet to the summary
17:45:21 <lispy> that doesn't seem that bad
17:45:34 <lispy> ah, hPutXml is the real slow down
17:45:45 <lispy> but i didn't write that
17:45:59 <lispy> that's part of HaXml
17:46:45 <Cale> how is that part of the CAFs for Excel.SpreadSheetUtil?
17:47:09 <lispy> paste is too large
17:47:19 <lispy> i'll put this one on my wiki
17:48:15 <lispy> Cale: check the bottom of the page
17:48:16 <lispy> hm...actually i only had o
17:48:20 <lispy> http://www.codersbase.com/index.php/Sandbox
17:48:31 <lispy> ignore what i said before the url :)
17:48:36 <lispy> (wrong paste buffer)
17:49:55 <lispy> i wonder how hPutXml can be improved
17:50:00 <lispy> good thing i have the HaXml source
17:50:19 <Cale> I don't see how hPutXml is a CAF
17:50:36 <lispy> probably because it's in a library
17:50:52 <lispy> so it gets put there by mistake
17:51:39 <lispy> hmmm
17:51:54 <lispy> do we have a bytestring version of the pretty printer?
17:52:06 <lispy> hPutXml f v = (hPutStrLn f . render . PP.document . toXml) v
17:52:39 <lispy> i bet rendering and then the hPutStrLn is slow
17:52:48 <Cale> does the thing even need to be prettyprinted?
17:52:54 <lispy> nope
17:53:03 <lispy> it just gets read by excel
17:53:10 <Cale> I wonder if there's a non-prettyprinting version of that
17:53:38 <Cale> well, are those calls exposed?
17:53:38 <lispy> toXml generates a Document
17:53:46 <Cale> hmm
17:53:59 <lispy> toXml :: Haskell2Xml a => a -> Document
17:54:28 <lispy> so i bet the only way HaXml converts to xml is via the pretty printer
17:54:37 <Cale> ugh
17:55:10 <lispy> yeah...i kinda knew that...but i didn't worry about it for some reason :)
17:55:10 <Cale> uh
17:55:13 <Cale> showXml?
17:55:22 <Igloo> That's an XML document rather than a prettyprinter document, presumably?
17:55:28 <Cale> does that go via the pretty printer?
17:55:31 <lispy> showXml :: Haskell2Xml a => a -> String
17:55:32 <lispy> showXml = render . PP.document . toXml
17:55:35 <Igloo> With PP.document converting it to a prettyprinter document
17:55:50 <Igloo> So you just need a non-PP Document printer
17:56:02 <Cale> hmm
17:56:07 <Cale> is Show directly implemented?
17:56:07 <lispy> hmm...
17:56:34 <lispy> i was ust looking for the Show instance...i think that's done via render
17:56:41 <lispy> Igloo: you might be right, i'll check on that
17:57:37 <lispy> i could just implement what i need using bytestrings too
17:57:45 <lispy> that may actually be the fastest
17:58:25 <Cale> Isn't it great when you do a whole bunch of profiling only to find out that it's not your code which is causing the problem?
17:58:45 <lispy> heh
17:58:55 <lispy> it's a first :)
17:59:18 <lispy> hm...i think the shows are done via deriving
17:59:31 <lispy> that's what this grep looks like anyway
18:02:03 <lispy> and thanks again
18:02:16 <lispy> i think for now i'll just hack in support for bytestring showing
18:02:19 <lispy> and see what that gets me
18:12:41 <lispy> god it feels good to be using emacs again
18:13:01 <Cale> hehe, what did you use in the interim?
18:13:15 <lispy> i had been using visual haskell a lot
18:13:24 <lispy> it does some things nice
18:13:27 <Cale> ah, right, Excel, you're a windows user :)
18:13:28 <lispy> gives you some project management
18:13:34 <lispy> oh wait a sec
18:13:40 <lispy> i'm *not* a windows user :)
18:13:45 <lispy> i just happen to use it at work :)
18:13:55 <br1> I'm reading "State in Haskell" and wondering when were state transformers ported to the standard monadic framework.  Anyone remembers?
18:14:00 <lispy> (sorry, this old debian fiend is a bit defensive ;)
18:14:49 <Cale> lispy: yeah, I'd been using Debian for 5 years, until I recently switched to Ubuntu for fun.
18:14:59 <Cale> br1: hmm... where is that?
18:15:33 <dons> why'd you switch, Cale?
18:15:53 <dons> br1, hmm. 95 or 96?
18:16:00 <Cale> dons: my system had built up a lot of non-package junk over the years
18:16:25 <br1> dons: 1996
18:16:28 <Cale> oh, when as in time
18:16:30 <Cale> hehe
18:16:41 <lispy> dons: any advice about building up bytestrings?
18:16:54 <lispy> dons: i'm just going to print them out as soon as they are constructed?
18:16:58 <lispy> s/?//
18:17:03 <dons> avoid concat and ++ and cons.
18:17:09 <dons> yeah, dumping them out should be fine
18:17:11 <lispy> so that leaves?
18:17:24 <lispy> that's everything i can think of to glue them together :)
18:17:40 <dons> well, dump out the chunks as you create them, if they're big,rather than concat, and then dumping.
18:17:50 <dons> or use lazy bytestrings
18:17:54 <dons> since concat is cheap there
18:18:10 <lispy> so maybe i should bulid it into the IO monad?
18:18:24 <lispy> that's not a bad idear
18:18:55 <lispy> i think i'll use Lazy first and switch later
18:19:04 <lispy> (if i still have problems)
18:19:20 <dons> yep
18:19:28 <stepcut> dons: I have a version of my lambdabot jabber bindings that I think I can release this weekend -- but I need some information from you first
18:19:30 <Cale> Laziness is supposed to be the solution to that problem in general, it's just deciding what amount of it you need :)
18:19:37 <dons> stepcut: yes?
18:19:44 <dons> relase as in "submit me a patch" or "fork" ?
18:20:14 <lispy> stepcut: BTW, i emailed you some patches to your bytestring parser the other day, but pNewLine has a bug (at least on windows) so you might not want to apply them
18:20:23 <br1> dons: The paper "State in Haskell" is from 1996.  I uses thenST and returnST instead of >>= and return.  Is it pre classes?
18:20:29 <stepcut> hopefully, a patch. I did not change much, mostly just added a xmpp module
18:20:32 <lispy> stepcut: i haven't had a chance to test my windows fix on unix...
18:20:58 <stepcut> lispy: yes, I sent you a reply but the mail server at work was recently reconfigured, and it got bonged :(
18:20:58 <dons> br1, nope. classes go back to 1988, but the use of monadic >>= didn't get fixed until h98, I think.
18:21:04 <dylan> @hoogle getSelectionOwner
18:21:05 <lambdabot> No matches found
18:21:09 <lispy> stepcut: Ah!
18:21:17 <lispy> stepcut: i never got it :)
18:21:18 <dons> br1, there's still code in ghc that uses returnST
18:21:19 <stepcut> lispy: I wanted to know where I could get a copy of the darcs archive :)
18:21:28 <lispy> hehe
18:21:31 <lispy> stepcut: hang on
18:21:59 <lispy> stepcut: http://darcs.haskell.org/~paolo/darcs/ByteStringParser
18:22:01 <stepcut> dons: the jabber lambdabot stuff adds two new dependencies, (1) my jabber library and (2) HaXml 1.16
18:22:02 <br1> dons: :o thx a lot
18:22:03 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser, http://tinyurl.com/o6p8o
18:22:04 <stepcut> lispy: thanks
18:22:15 <dons> stepcut: ah right.
18:22:26 <stepcut> dons: my jabber library is not a big deal, but I HaXml 1.16 is (a) unreleased (b) might not be backwards compatible
18:22:27 <dons> so we could add it as an optional component, perhaps with a separate .cabal file?
18:22:35 <lispy> stepcut: the windows fix was to make it pChar '\r' >> pChar '\n'
18:22:40 <stepcut> lispy: cool
18:22:42 <lispy> stepcut: incase you were curious
18:22:46 <dons> stepcut , is it possible to conditionally compile it into lambdabot?
18:23:03 <dons> stepcut: or how do you imagine the binding making its way into the main lambdabot branch?
18:23:08 <stepcut> dons: that is what I think would be best -- I just wonder what mechanism you thought would be best
18:23:25 <dons> ok. in general i use a separate .cabal file for optoinal stuff
18:23:38 <dons> and then we might need some cpp to control imports
18:24:05 <stepcut> dons: ok, I think a few well placed cpp and a seperate .cabal should do the trick
18:24:29 <lambda_the_insig> is there a @pl extension for ghci?
18:24:47 <dons> lambda_the_insig: yep. use GoA
18:24:51 <dons> ?where lambdabot
18:24:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:25:17 <dons> $ ghci
18:25:18 <dons> GOA> :pl \x y f -> f y (f x )
18:25:18 <dons> flip (ap . flip id) . flip id
18:25:29 <lambda_the_insig> cool, thanks.  that looks like what I need
18:25:40 <dons> (its a generic lambdabot binding to ghci)
18:25:52 <dons> GOA> :instances Monad
18:25:52 <dons> ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, ....
18:25:56 <dons> for example
18:26:24 <lambda_the_insig> does it work with a stock 6.4.1 ghc build, or do I need to rebuild something?
18:27:13 <stepcut> dons: the changes to the exist code are very minimal:
18:27:14 <stepcut> M ./IRC.hs -1 +1
18:27:15 <stepcut> M ./Lambdabot.hs -5 +12
18:27:29 <dons> oh good
18:27:44 <dons> lambda_the_insig: just standard ghc will be fine.
18:27:52 <dons> you just need to build lambdabot, and build goa
18:28:02 <dons> instructions in the goa repository
18:28:11 <lambda_the_insig> thanks much
18:39:29 <br1> Where can I find the source of the standard library? Are additions welcome?
18:40:32 <Lemmih> It has to be really needed additions. Otherwise it should go to missingh.
18:41:08 <dons> ?source Prelude
18:41:08 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
18:41:14 <dons> ?source Data.List
18:41:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
18:41:37 <lispy> dons: what do you recomend in place of (++)?
18:41:40 <dons> br1: additions are welcome, and generally require careful discussion on libraries@haskell.org, along with haddock documentation and quickchecks
18:41:43 <lispy> or rather i don't see (++)
18:41:51 <dons> lispy: well, if you're using .Lazy, `append` is fine.
18:42:06 <dons> or concat if you're appending more than once.
18:42:28 <stepcut> What should I name my Xmpp (aka, Jabber) library, Network.Xmpp  or Network.Protocol.Xmpp ?
18:42:35 <stepcut> ?poll-show jabberName
18:42:36 <lambdabot> ["Network.Protocol.Xmpp","Network.Xmpp"]
18:42:41 <lispy> dons: thanks
18:43:00 <lispy> dons: oh, no unlines...
18:43:16 <dons> in .Lazy.Char8
18:43:28 <lispy> hmm...
18:43:34 <dons> stepcut: http://www.haskell.org/~simonmar/lib-hierarchy.html
18:43:36 <lambdabot> Title: Haskell Library Hierarchy, http://tinyurl.com/lphbd
18:43:44 <dons> would suggest Network.Protocol.Xmpp I think
18:44:20 <lispy> dons: is that a recent addition?
18:44:25 <dylan> How does one create named pipes in haskell?
18:44:29 <lispy> dons: my version of bytestring is pretty adamant that i don't have it
18:44:48 <dons> ?type Data.ByteString.Lazy.Char8.unlines
18:44:49 <lambdabot> [Data.ByteString.Lazy.ByteString] -> Data.ByteString.Lazy.ByteString
18:44:58 <lispy> dons: i see it in the haddock file too
18:45:03 <dons> lispy: should be in fps 0.7 and fps 0.8
18:45:06 <dons> and earlier.
18:45:12 <lispy> hmm...
18:45:41 <Adamant> Adamant is not ByteString
18:45:57 <lispy> heh
18:45:58 <dons> dylan: System.Posix.Files.createNamedPipe :: FilePath -> FileMode -> IO ()
18:46:22 <dons> ?hoogle Pipe
18:46:23 <lambdabot> Foreign.C.Error.ePIPE :: Errno
18:46:23 <lambdabot> Foreign.C.Error.eSPIPE :: Errno
18:46:23 <lambdabot> System.Win32.File.fILE_TYPE_PIPE :: FileType
18:46:25 <lispy> dons: oh weird, ghci sees it...i'll look at this error message again...
18:46:31 <dylan> dons: thanks! I'm writing a script to link gnu screen's selection buffer with the X11 primary selection
18:46:50 <dylan> it needs two threads, so I decided to use haskell. XD
18:46:53 <lispy> src/Text/XML/HaXml/ByteString.hs:50:7:
18:46:54 <lispy>     Not in scope: `Data.ByteString.Lazy.Char8.unlines'
18:47:08 <lispy> am i not seeing the typo?
18:47:20 <lispy> oh, n/m
18:47:27 <goltrpoat> someone let me know if i'm sending some sort of crazy colors or markup, i'm in some java client
18:47:28 <lispy> i only imported pack from Char8
18:47:32 * lispy slaps self
18:47:44 * lispy hides from goltrpoat evil output ;)
18:47:49 <lispy> goltrpoat: looks fine here
18:47:54 <goltrpoat> hehe cool
18:48:04 <dons> dylan: hehe.
18:48:08 <lispy> dons: thanks for the help, sorry i'm a twit sometimes...rushing too much to get this done
18:48:23 <dons> :)
18:48:26 <goltrpoat> @pl (\a (b,c) -> (a,c))
18:48:26 <lambdabot> (`ap` snd) . (. fst) . const . (,)
18:48:39 <goltrpoat> yikes.  the two flip version was better
18:50:01 <br1> And where are the tests of the standard lib?
18:50:44 <Lemmih> br1: What do you wanna add, OOI?
18:51:29 <br1> OOI?
18:51:49 <br1> I'm playing with graph algorithms but miss some.
18:53:04 <br1> What's OOI?
18:57:03 <Lemmih> Out of interest.
18:58:00 <dylan> now, to figure out what a valid FileMode / CMode is... since that type has no constructors...
18:58:58 <br1> Lemmih: hehe.  I didn't know that one.  I thought it stood for Object Oriented something...
18:59:02 <dons> ?hoogle FileMode
18:59:03 <lambdabot> System.Posix.Types.FileMode :: type FileMode
18:59:44 <dylan> which is an alias for CMode.
19:16:37 * lispy waits in wonder for the compile
19:17:26 <lispy> friends are at the pub and i'm at work hacking...now that's stupidi^Wdevotion!
19:17:58 <goltrpoat> not quite as bad as hacking at the pub
19:18:29 <lispy> hmm...this module takes a couple minutes to compile... :)
19:19:03 <lispy> granted it's 2.5kLoC
19:19:22 <lispy> essentially no comments
19:19:29 <lispy> (because it's autogenerated)
19:24:45 * lispy whispers to ghc -> "compile faster!!!"
19:25:07 <dons> compile with -Onot -fasm for speed
19:25:38 <lispy> i want the speed actually so i can get an accurate profile don't i?
19:26:17 <lispy> it's just that this one stupid module takes ages with all it's lines and the profiling transformations...
19:28:31 <dons> yep. you need the optimisations up then
19:28:59 <lispy> hmm..memory usage seems way down
19:29:05 <lispy> like, way, way, way down
19:29:15 <lispy> at least one order of magnitude :)
19:29:45 <lispy> dons++
19:29:48 <dons> cool
19:29:50 <lispy> dcoutts++
19:29:54 <dons> so what did you do to have that happen?
19:30:30 <lispy> so, they use the pretty printer and i just slipped in Data.ByteString.Lazy versions of all the pretty printer fuctions
19:30:41 <lispy> so i replaced (<>) and the lot
19:30:46 <lispy> of course it's not pretty anymore
19:30:48 <lispy> but it's faster
19:30:52 <dons> cool
19:31:41 <lispy> dons:  http://www.codersbase.com/index.php/Sandbox
19:31:45 <lispy> compare the bottom two profiles
19:31:48 <SamB_XP> why do you say "of course it't not pretty anymore"?
19:32:01 <SamB_XP> er, s/it't/it's/
19:32:07 <lispy> took twice as long
19:32:22 <lispy> SamB_XP: because i didn't bother correctly implementing the pretty printers
19:32:31 <SamB_XP> oh
19:32:31 <lispy> SamB_XP: i just hacked together a replacement definition
19:32:46 <lispy> which reminds me i should make sure the output is still valid
19:32:49 <SamB_XP> I thought maybe your source code got uglier somehow!
19:33:06 <lispy> damn, it's not equivalent...
19:33:10 * dons turns tutbot into an irssi killer
19:33:16 <SamB_XP> oops
19:34:28 <lispy> gotta love excel's error message
19:34:29 <lispy> XML PARSE ERROR:  Missing whitespace between attributes
19:34:30 <lispy>   Error occurs at or below this element stack:
19:34:32 <lispy>     (Stack is empty--error occurs at or below top-level element.)
19:34:43 <lispy> bit skimpy on the details :)
19:36:34 <Korollary> Hockey!
19:37:28 <SamB_XP> mmm
19:37:37 <SamB_XP> tried oo.org?
19:38:36 <lispy> ah, found the bug
19:42:18 <lispy> i wonder why it takes longer now
19:46:10 <ventonegro> @hoogle HList
19:46:11 <lambdabot> No matches found
19:49:39 <lispy> ?where HList
19:49:39 <lambdabot> http://homepages.cwi.nl/~ralf/hlist/
19:49:44 <lispy> that's not it
19:49:55 <lispy> you want http://darcs.haskell.org/HList if it exists
19:49:57 <lambdabot> Title: Index of /HList
19:50:00 <lispy> ah yup
19:50:22 <ventonegro> :-)
19:50:36 <ventonegro> just saw it mentioned in the mailing list
19:50:42 <ventonegro> dunno what it is
19:50:50 <lispy> oh, it's pretty cool
19:51:01 <lispy> heterogeneous lists
19:51:36 <lispy> if you're new to haskell it can wait :)
19:51:48 <lispy> it can be a bit hard to grok
19:52:14 <ventonegro> so it's gonna wait :-)
19:53:14 <ventonegro> > inits $ cycle "noob"
19:53:15 <lambdabot>  ["","n","no","noo","noob","noobn","noobno","noobnoo","noobnoob","noobnoobn",...
19:54:02 * deadbeef just bought an iPod
19:54:11 <deadbeef> wondering if i can run linux and ghc on it
19:54:29 <dons> ghc might be a bit hard....
19:54:47 <dons> you may be able to run haskell binaries though
19:54:56 <deadbeef> i could try to crosscompile
19:55:13 <flipdons> roll your own irc client :)
19:55:30 <dons> testing...
19:56:00 <flipdons> good good
19:56:38 <dons> well that was fun
19:56:41 <lispy> xml parsers are so picky :)
19:56:58 <lispy> (good thing actually, i just didn't notice the problem at first because it's *just* whitespace)...
19:58:02 <lispy> ?type foldl
19:58:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:58:31 <lispy> i always forget that argumentorder
20:01:22 <Cale> yeah, the arguments to foldl/foldr are arguably sort of backwards, but it does turn out that's the more useful order most of the time, so I suppose not
20:02:03 <weitzman> The argument order matches my visualization of the idea of folding
20:02:22 <weitzman> You've got a big blob of stuff, type a, and you stick on a b, getting a bigger a
20:02:35 <weitzman> Might not be bigger, but that's how I remember
20:03:02 <Cale> The way I picture foldr f z is that it's replacing each cons in the list it's passed with f and the nil at the end with z.
20:03:55 <Cale> Since you usually think of the base case before the inductive case, foldr z f would seem more natural, but it turns out there are more useful applications where you leave the base case unspecified until later
20:04:12 <lispy> ?hoogle foldl'
20:04:13 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
20:05:08 <Cale> http://cale.yi.org/index.php/Fold_Diagrams :)
20:05:10 <lambdabot> Title: Fold Diagrams - CaleWiki
20:05:26 <weitzman> Neat
20:06:33 <lispy> dons: i need a version of unlines that doesn't add a space at the end
20:06:52 <lispy> dons: i tried foldl ($$) empty but that's no good
20:07:01 <lispy> dons: that uses obscene amounts of memory
20:07:48 <ventonegro> @type ($$)
20:07:49 <lambdabot> Not in scope: `$$'
20:08:06 <dons> foldl' then?
20:08:11 <lispy> tried it
20:08:13 <lispy> same result
20:08:20 <dons> or, just use unlines, and chop the end....
20:08:29 <lispy> init?
20:08:32 <dons> right
20:08:41 <lispy> okay, i'll try it
20:08:46 <lispy> > unwords []
20:08:48 <lambdabot>  ""
20:08:55 <lispy> wonder if it will work on the empty list
20:09:02 <dons> take (length -1) s
20:09:07 <dons> > take 10 []
20:09:08 <lambdabot>  Add a type signature
20:09:15 <dons> > take 10 [] :: [Char]
20:09:16 <lambdabot>  ""
20:09:25 <weitzman> > join $ intersperse "\n" ["a", "b"]
20:09:26 <lambdabot>  "a\nb"
20:09:38 <dons> yeah, there's join as well.
20:09:39 <lispy> dons: length is O(1) huh?
20:09:58 <dons> O(c), number of chunks
20:10:02 <dons> for lazy bytestrings
20:10:08 <dons> chunks are 32k
20:12:09 <lispy> ?type intersperse
20:12:11 <lambdabot> forall a. a -> [a] -> [a]
20:12:34 <lispy> ?type join $ intersperse ""
20:12:35 <lambdabot>   Couldn't match `[a1] -> a' against `[a1]'
20:12:36 <lambdabot>    Expected type: [a1] -> [a1] -> a
20:13:01 <dons> ?type Data.ByteString.join
20:13:03 <lambdabot> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString] -> Data.ByteString.Base.ByteString
20:13:12 <dons> ?type Data.ByteString.Lazy.join
20:13:13 <lambdabot> Data.ByteString.Lazy.ByteString -> [Data.ByteString.Lazy.ByteString] -> Data.ByteString.Lazy.ByteString
20:13:37 <lispy> > join $ intersperse "\n" ["a", "b"]
20:13:39 <lambdabot>  "a\nb"
20:13:45 <lispy> so what was wrong with what i typed?
20:13:51 <lispy> ?type join $ intersperse "\n"
20:13:53 <lambdabot>   Couldn't match `[a1] -> a' against `[a1]'
20:13:53 <lambdabot>    Expected type: [a1] -> [a1] -> a
20:14:13 <lispy> ?type join . (intersperse "\n")
20:14:15 <lambdabot> [[Char]] -> [Char]
20:14:18 <lispy> duh...
20:14:23 * lispy is getting tired he thinks
20:14:51 <lispy> dons: since i'm taking over the pretty printer functions i need these certain types like [ByteString] -> Bytesting
20:14:59 <lispy> if this works well i can optimize it down further
20:17:55 <lispy>  join . (intersperse (pack "\n"))
20:18:00 <lispy> that's giving me a type error
20:18:08 <lispy> shouldn't that be [ByteString] -> ByteString?
20:18:29 <lispy> and i should change hat to singleton...
20:19:27 <lispy> ?pl \xs -> join (intersperse "\n" xs)
20:19:27 <lambdabot> join . intersperse "\n"
20:20:25 <dons> are you using bytestring's join?....
20:21:47 <lispy> oh if i use it then i just need join (singleton ' ')
20:21:53 <lispy> right?
20:21:59 <lispy> or does it put one at the end?
20:22:07 <lispy> ah between
20:22:08 <lispy> good
20:22:43 <lispy> hehe
20:22:46 <lispy> i need a break...
20:23:44 <dons> right.. join (singleton ' ')
20:24:29 <lispy> memory usage seems to be stable again
20:25:12 <lispy> should i expect 'foldl append empty' (and foldl' both from Prelude) to explode?
20:25:21 <lispy> or is this a possible bug?
20:26:00 <lispy> okay, that fixes the formating bug
20:26:08 <lispy> now back to the proifler results
20:26:55 <lispy> i may need to switch to that IO monad version where it just prints the xml as soon as it's ready
20:27:22 <lispy> but this is a HUGE step forward
20:28:46 <dons> foldl append empty is  a concatMap, of sorts, which is going to be copying arrays around.  it'l be O(n^2)....
20:29:03 <dons> oh, ot quite, on lazy bytestrings. but still not very nice.
20:29:18 <dons> much better to use concat. which'll be O(n).
20:29:41 <lispy> i couldn't use concat because i needed what join does
20:29:46 <lispy> but yeah
20:29:52 <lispy> concat is fast
20:30:02 <lispy> this is a huge improvement
20:30:12 <lispy> could be better yet
20:30:12 <dons> it just calls some memcpys.
20:30:13 <dons> good.
20:30:17 <lispy> but this is great start
20:30:27 <lispy> gets me through the weekend :)
20:30:34 <magnus-> what program are you working on?
20:30:45 <dons> if you're careful, you should be able to get join (singleton) to cause the joinbyte rewrite rule to fire.
20:30:49 <lispy> magnus-: something for work, it reads in a bunch of data and dumps out xml
20:30:55 <magnus-> aha
20:31:06 <magnus-> you do haskell at work.. lucky you
20:31:25 <lispy> magnus-: i just took charge on this project and started using it :)
20:31:37 <magnus-> hah :)
20:31:44 <lispy> i did try out python first just to make them happy
20:32:00 <lispy> but it was taking half a gig of memory just to hold small data sets
20:32:03 <lispy> smaller than i'm working with now
20:32:29 <lispy> and they came to me at one point and said, "Please don't use java..."
20:32:37 <lispy> "Okay, I'll use Haskell."
20:32:38 <lispy> "What?
20:32:43 <lispy> "oh, nevermind...'
20:33:10 <magnus-> lol
20:33:30 <Cale> hehe
20:33:35 <magnus-> they will be upset when they can't maintain your progarm... if theyever need to
20:33:44 <Cale> they'll be able to maintain it
20:33:55 * magnus- 's computer is slowing down to a crawl...
20:33:58 <Cale> just maybe not in-house if lispy leaves
20:34:29 <Cale> there are plenty of Haskell programmers out there who will jump at any Haskell-oriented job they can get :)
20:34:49 <magnus-> it's all for the good of Haskell programmers
20:35:29 <dons> yeah, the whole 'can't maintain it' stuff is FUD. if you can hack python, haskell's not too much of a stretch
20:36:02 <lispy> magnus-: this code is likely to be scraped since my work is techincally prototyping
20:36:19 <lispy> with the way my company is about legacy code i doubt that will actually happen...but we'll see
20:36:31 <lispy> and it turns out sharedlibs/dlls are a great way to sneak haskell into a program
20:36:48 <lispy> just ask for an api then build a shared module that can by dynamically loaded :)
20:36:56 <lispy> then it doesn't matter which language it's implemented in
20:37:02 <lispy> as long as you can load it
20:37:22 <magnus-> i wonder if I can make realtime audio processing plugins (dlls) in Haskell :)
20:37:36 <magnus-> GC is kinda worrysome though.
20:38:10 <lispy> you'd be in an area that is not a strong point of haskell, but it possible
20:38:13 <lispy> look at Data.ByteString
20:38:15 <Cale> I'd be interested in how practical Data.ByteString would make that sort of thing
20:38:24 <Cale> hehe
20:38:48 <Cale> It would be a strong point of Haskell, if IO efficiency were not such a problem.
20:38:58 <dons> we already have ogg decoders in haskell, using lazy bytestrings
20:39:21 <dons> and people considering quicktime streaming stuff.
20:40:11 <Cale> oh, where's the ogg decoder?
20:41:29 <dons> ?where hogg
20:41:29 <lambdabot> I know nothing about hogg.
20:41:38 <dons> grr
20:41:49 <dons> there's a link ot the fps paper page.
20:42:19 <Cale> http://snapper.kfish.org/~conrad/software/hogg/
20:42:21 <lambdabot> Title: Index of /~conrad/software/hogg, http://tinyurl.com/gkqyx
20:42:31 <dons> yep
20:43:05 <dons> ?where+ hogg http://snapper.kfish.org/~conrad/software/hogg/
20:43:05 <lambdabot> Done.
20:43:44 <kfish> hogg's not a decoder, it just handles mux/demux of the ogg encapsulation format
20:44:02 <kfish> the actual decode would probably still have to go via libvorbis in C
20:45:02 <lispy> an old lisper once told me the secret to using 'cool' languages in industry jobs
20:45:32 <lispy> he said you just find a place that gives you freedom and then use your language every time you possibly can get away with it
20:45:33 <kfish> (though implementing vorbis in haskell could be interesting ...)
20:45:42 <dons> ah right. sorry kfi	
20:45:48 <dons> tab tab
20:45:59 <kfish> no worries, just don't want to get people's hopes up
20:46:04 <dons> yeah :)
20:46:42 <kfish> that said, hogg implements the same thing as about 5000 lines of C in about 1000 lines of haskell, and i'm pretty sure it's more correct and more maintainable
20:47:14 <kfish> definitely more maintainable :-)
20:48:11 <Cale> that's pretty compact C then :)
20:48:12 <lispy> nice, the non profile version seems to keep itself under 80 megs of ram
20:48:22 <lispy> (this used to take 1GB+)
20:48:31 <lispy> (not sure on the exact ammount because it ran out of ram)
20:48:34 <dons> lispy: cool
20:49:11 <lispy> yes, i need get my copy of HaXml into darcs so i can send in some patches
20:49:21 <lispy> i've made quite a few changes that make it much better for me
20:49:29 <lispy> i'm sure others could benefit
20:49:32 <hyrax42> if I could read perl
20:49:42 <hyrax42> I'd try and do this in haskell:
20:49:43 <hyrax42> http://newbabe.pobox.com/~mjd/blog/2006/10/03/#isc-hop
20:49:46 <lambdabot> Title: The Universe of Discourse, http://tinyurl.com/l7g8b
20:50:21 <weitzman> If I could read perl, I'd contract myself out to companies as a software archaeologist and tell them what their legacy code does
20:51:24 <kfish> Cale: hehe
20:56:21 <aFlag> I don't think even Jesus can read perl. God might if he really concentrate.
20:57:45 <hyrax42> ?hoogle Char -> Bool
20:57:46 <lambdabot> Char.isAlpha :: Char -> Bool
20:57:46 <lispy> okay, so i'm thinking as a community we need to rewrite the pretty printer to use Data.ByteString.Lazy and finish retooling HaXml to use Data.ByteString through out...i wonder if that would cause problems with XML in general...
20:57:47 <lambdabot> Char.isAlphaNum :: Char -> Bool
20:57:47 <lambdabot> Char.isAscii :: Char -> Bool
20:57:55 <hyrax42> ?hoogle isLetter
20:57:55 <lambdabot> No matches found
20:58:07 <hyrax42> ?docs Data.Char
20:58:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
20:58:10 <lispy> dons, Cale, Igloo: thanks for the help
20:58:15 <lispy> for now, i'm outta here
21:04:09 <hyrax42> ?type when
21:04:11 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:25:11 <moconnor> I'm trying to turn a TimeDiff type into an integer (where integer is picoseconds).  I can't seem to figure out how to pick out just that part, all I've been able to do is turn a TimeDiff into a string (via show).  I'm new to Haskell, so I'm not quite sure how I peek into TimeDiff's structure.
21:26:12 <dons> the field for picoseconds in the TimeDiff data structure is accessible via its name: tdPicosec mytdiff
21:26:27 <dons> data TimeDiff
21:26:28 <dons>  = TimeDiff {
21:26:28 <dons>      tdYear    :: Int,
21:26:28 <dons>      tdMonth   :: Int,
21:26:28 <dons>      tdDay     :: Int,
21:26:30 <dons>      tdHour    :: Int,
21:26:33 <dons>      tdMin     :: Int,
21:26:35 <dons>      tdSec     :: Int,
21:26:38 <dons>      tdPicosec :: Integer
21:26:46 <dons> in general, field labels produce accessor functions of the same name
21:26:54 <moconnor> ahh, ok.
21:26:55 <dons> ?type System.Time.tdPicosec
21:26:56 <lambdabot> System.Time.TimeDiff -> Integer
21:27:05 <moconnor> thank you
21:29:02 <dons> there's some TimeDiff hacking code here, at the end, http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:29:05 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
21:29:07 <dons> for the 'uptime' function
21:30:35 <dons> for those who didn't see it when it was originally posted, http://programming.reddit.com/info/l92q/comments (the QuickCheck mini-tut)
21:30:35 <moconnor> thank you!
21:30:38 <lambdabot> Title: Automated testing of Haskell code with QuickCheck (reddit.com), http://tinyurl.com/l42dn
21:39:53 <dwm> dons: Interesting reading about QuickCheck. Thank you.
21:42:13 <dons> cheers
21:43:50 <phr-newbie> nice
21:47:20 <phr-newbie> how does quickcheck know to generate (e.g.) random strings for take5?  does it inspect the type signature of the function it's checking?
21:47:54 <lennart> yes
21:47:56 <dons> its dispatching to the random generator for each type, based on the type. yes.
21:47:57 <lennart> kinda
21:48:17 <dons> ?check \s -> (s :: [Char]) == s
21:48:19 <lambdabot>  OK, passed 500 tests.
21:48:45 <dons> ?check \s -> (s :: [Char]) == reverse ( reverse s)
21:48:46 <lambdabot>  OK, passed 500 tests.
21:49:05 <phr-newbie> what about the string lengths?
21:49:22 <dons> that's determined by the random generator for the type.
21:49:26 <phr-newbie> ic
21:49:42 <phr-newbie> it would be cool to connect it up with a theorem prover
21:49:43 <dons> so you could write a generator that returned only long strings, or ones of length 5 or what have you
21:50:38 <phr-newbie> i see, so you could add generators as part of the test config for a given program
21:50:48 <dons> yep.
21:51:48 <phr-newbie> i guess it complements unit testing nicely
21:52:15 <stepcut> i wrote a wrapper that turns QuickCheck tests into HUnit tests ;)
21:53:06 <phr-newbie> so is it true that lazy evaluation isn't part of the haskell spec, ie. it's simply not required to be strict, and what actually happens is up to the implementation?
21:54:43 <lennart> haskell is defined to be non-strict
21:54:49 <lennart> that's it
21:56:16 <Cale> phr-newbie: basically, programs which can terminate under some evaluation order must terminate
21:56:26 <phr-newbie> hmm
21:56:47 <phr-newbie> but there's no way to figure out the running time complexity
21:56:56 <Cale> not from the spec
21:57:01 <Cale> which is a good thing
21:57:09 <lennart> just like just about any language :)
21:57:19 <Cale> because that means that compilers are free to improve the runtime complexity at will
21:58:19 <phr-newbie> heh, i thought we spent all that time in school studying algorithms because we wanted to be able to implement for known complexity
21:59:07 <Cale> well, you can get a pretty good upper bound on what a reasonable implementation will do
21:59:18 <Cale> Just do outermost-first evaluation
21:59:52 <Cale> if you want a (much) better picture than that, remember that values which came from the same variable binding are shared and will be computed only once
22:00:18 <phr-newbie> hmm that helps
22:01:07 <Cale> that's lazy evaluation
22:01:38 <lennart> phr-newbie: you algorithms will have the same O complexity in Haskell as in other languages
22:01:55 <lennart> Well, in all Haskell implementations I know of
22:02:09 <Cale> well, sort of :)
22:02:09 <lennart> you could make something worse, it's allowed
22:02:20 <phr-newbie> yeah, that's what's scaring me
22:02:26 <Cale> Haskell has a tendency to improve things by infinite amounts :)
22:02:38 <dons> luckily implementors tend to try to improve things, as a rule
22:02:39 <Cale> (nonstrict semantics do)
22:02:40 <lennart> that's still the same O complexity
22:02:55 <Cale> Oh, for finite data, I suppose
22:03:01 <monochrom> You can analyse the time cost under the assumption of a naive compiler.  A smart compiler will only improve on that.
22:03:02 <Cale> Depends on what your variable is
22:03:06 <Cale> like
22:03:38 <lennart> phr-newbie: if you read the C standard I don't think it says anything abut complexity
22:03:46 <Cale> if I implement the computation of, oh, x^n by  (iterate (*x) 1) !! n
22:04:11 <lennart> so assignment could be implemented by incrementing the destination the number of times specified by the source :)
22:04:12 <Cale> then this algorithm is going to run a lot faster than the same algorithm in a strict language (which will go into an infinite loop)
22:04:23 <Cale> regardless of n
22:04:52 <lennart> true
22:05:12 <lennart> so the strict one is O(infinity) I guess
22:05:14 <lennart> :)
22:05:18 <monochrom> I want a C compiler that implements unsigned as Church numerals.
22:06:42 <lennart> go ahead, write one :)
22:08:08 <phr-newbie> lennart, the c standard describes the sequence points for the program's execution, and they're fine grained enough that there's always(?) straightforward a machine code translation of each point.  i mean an evil compiler COULD maybe implement multiplication by repeated adding, but it would have to go out of its way, it's not like it has wide reasonable choices of high level algorithms
22:09:08 <lennart> so think of Haskell the same way.  you could have really weird implementations, but why make something that bad?
22:09:34 <phr-newbie> i guess i haven't yet grokked what a straightforward implementaton does
22:09:47 <phr-newbie> i mean if i can program in lisp at all, it's totally obvious what an evaluator has to do
22:10:55 <monochrom> Launchbury's "A Natural Semantics for Lazy Evaluation" makes it obvious.
22:11:02 <lennart> Well, a Haskell implementation doesn't do more than that (in the big-O sense)
22:11:02 <phr-newbie> is that online?
22:11:12 <monochrom> http://www.cse.ogi.edu/~jl/Papers/lazySem.ps
22:11:33 <Cale> well, the straightforward way to evaluate things is to only compute what is *demanded*, and only apply the outermost function until you get it
22:11:42 <Cale> demand is generated by IO
22:11:54 <monochrom> The paper and the given operational semantics is very easy to read.  It also makes a lot of sense.
22:12:05 <phr-newbie> i've heard lazy evaluation described in terms of graph reduction
22:12:16 <phr-newbie> but the specifics weren't clear
22:12:20 <monochrom> describing graph reduction is hard to read.
22:12:21 <phr-newbie> does the paper explain that?
22:12:30 <Cale> It's easier just to work with expressions
22:12:30 <dons> and more here,
22:12:32 <dons> ?wiki Research_papers/Type_systems#Haskell_semantics
22:12:32 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Haskell_semantics
22:12:44 <Cale> and you can usually observe the space behaviour just looking at the expression
22:12:47 <monochrom> This one doesn't use graph reduction.  Much higher-level and obvious than that.
22:12:53 <phr-newbie> ok
22:13:01 <dons> monochrom: hmm I don't think the JL paper is on the wiki list (!) can you add it?
22:13:11 <moconnor> I am new to haskell and I'm struggling with division.  In ghci I do this "let x=1; y=1" followed by "x/y" and I get a type error "No instance for (Fractional Integer)" but if I do this, it works: (fromInteger x)/(fromInteger y).  That seems horrible, am I missing something here?
22:13:13 <lennart> phr-newbie: graph reduction can be explained on a white-board in 5 minutes
22:13:23 <monochrom> I do not know how to use wiki's.
22:13:43 <dons> > let x = 37 ; y = 5 in x `div` y
22:13:44 <lambdabot>  7
22:13:55 <dons> > let x = 37 ; y = 5 in x / fromIntegral y
22:13:57 <lambdabot>  7.4
22:14:07 <phr-newbie> http://en.wikipedia.org/wiki/Graph_reduction
22:14:08 <moconnor> What's the different between "/" and "`dev`" ?
22:14:09 <lennart> moconnor: At the top level ghci decided that x and y have type Integer since it had no further clues (this us defaulting)
22:14:15 <dons> ?type div
22:14:17 <lambdabot> forall a. (Integral a) => a -> a -> a
22:14:18 <dons> ?type (/)
22:14:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:14:30 <moconnor> dons: thank you again.
22:14:59 <dons> don't thank me. thank Lambdabot! :)
22:15:20 <dons> ?vixen thank you
22:15:21 <lambdabot> you're very welcome!
22:15:38 <stepcut> dons: I think it's like that joke about knowing where to put the x
22:16:05 <monochrom> Summary.  The paper works at the expression level.  You keep rewriting expressions.  In the process, you introduce lots of let-bindings so that you can memoize share subexpressions.  That does the trick.
22:16:08 <moconnor> ?vixen thank you
22:16:08 <lambdabot> my pleasure
22:16:49 <stepcut> ?vixen your place or mine ?
22:16:50 <lambdabot> whoa whoa whoa, one question at a time!
22:17:52 <monochrom> It's very pleasant because everyone knows how to do on-demand; it's the memoization and sharing that seemed hard, and this guy just applies a simple coding trick to add it.
22:18:43 <monochrom> Graph reduction is closer to the metal.
22:21:21 <phr-newbie> they sound similar
22:21:38 <phr-newbie> i mean figuring out the cse's is a graph problem
22:22:33 <phr-newbie> i'm looking at this list of papers about type systems but am not sure where to start
22:22:59 <monochrom> Well yeah, suppose I am asked to implement lazy evaluation on a pointer machine, I would look at the let-bindings of Launchbury and start visualizing them as nodes and vertices too.
22:24:14 <monochrom> and edges too, of course.
22:25:10 <monochrom> But suppose I am not given a pointer machine.  I am given a dictionary machine or hashtable machine.  I would store the let-bindings in the dictionary, no explicit graph.
22:25:59 <monochrom> The way you program for metal is very different from the way you program for plastic.
22:26:04 <phr-newbie> heh
22:28:36 <monochrom> I think one thing "natural" about Launchbury's method is that humans are better at large dictionaries than at large graphs.
22:30:38 <monochrom> This is very important because after the next nuclear war you'll only have human computers, no more x86 architecture. :)
22:30:59 <phr-newbie> i think it's the other way around.  there will still be x86 computers, just no more humans :)
22:31:16 <monochrom> The silicon computers are fried by the EMPs.
22:32:14 <monochrom> Not to say that humans don't face some other problems, you're right. :)
22:33:58 <phr-newbie> unrelated topic--is there anything like protected variables in haskell?  i guess that means can i have f and g in the same module, so that forall x, g (f x) == x, but it's provably impossible to write h in a different module with the same property as g?
22:34:21 <phr-newbie> substitute some other construct for "module" if necessary
22:34:27 <phr-newbie> and i guess i mean private variables
22:35:47 <monochrom> Very odd.  That requires a very strong kind of global state.
22:36:01 <dons> hmm. strange. what are you trying to do?
22:36:18 <dons> needs to be rephrased in a less OO way to parse in this channel :)
22:36:47 <phr-newbie> i don't mean global state, i just mean values on which computations are possible only in some parts of the program
22:36:52 <monochrom> I am actually not convinced that it can be done anywhere in the world.
22:37:33 <phr-newbie> e.g. i might have a datatype containing two ints x and y
22:37:42 <dons> with an appropriate monad type, you could restrict what can be done in some code fragment.
22:37:51 <dons> and have that statically checked
22:38:02 <dons> > readFile "/etc/passwd" -- for example
22:38:02 <lambdabot>  No IO allowed
22:38:38 <monochrom> Suppose "f x" is of an abstract data type T.  Then in another module you cannot examine the details of T or the value of "f x".
22:38:55 <dons> so, with the write type, and suitable module exports, you could ensure that there can be no external 'h' that will have the right type
22:38:55 <phr-newbie> monochrom, yes, that's my question
22:39:00 <dons> smart constructors work this way
22:39:04 <dons> s/right/
22:39:09 <monochrom> An abstract data type simply means the defining module exports the type name T but no detail, no constructor.
22:39:28 <phr-newbie> but what if i want to export the constructor?
22:39:30 <dons> the basic idea is here http://haskell.org/haskellwiki/Smart_constructors
22:39:32 <lambdabot> Title: Smart constructors - HaskellWiki, http://tinyurl.com/jx22g
22:39:56 <dons> hide the real constructor. export only a 'smart' constructor function, that checks whatever condition you have, and hides the internals
22:40:37 <dons> i don't fully understand what you're trying to do, but existential types  might work for hiding access too
22:41:11 <phr-newbie> dons, i'm just envisioning the usual types of applications for which java uses private variables
22:41:14 * araujo looks around
22:41:18 <phr-newbie> e.g. say some value has a capability inside
22:41:19 <araujo> hiya ho
22:42:02 <dons> yeah, then we use an abstract data type, or an existential type.
22:42:03 <phr-newbie> you might pass the value to some specially privileged code that can access the capability
22:42:11 <dons> yep.
22:42:14 <monochrom> OOP has developed into so much vocabulary for so few ideas.
22:42:51 <phr-newbie> ok cool
22:42:57 <dons> phr-newbie: information hiding is pretty easy
22:43:21 <monochrom> There are only so many new words you can introduce before it comes postmodernism hogwash.
22:43:27 <dons> hehe
22:43:29 <monochrom> s/comes/becomes/
22:43:53 <dons> monochrom: you should write an OO-speak megamonad plugin for the bot.. :)
22:44:16 <monochrom> I am not postmodern enough.
22:45:36 <dons> i added the paper to the wiki. though you should learn! wiki editing is easy..
22:45:38 <dons> ?wiki Research_papers/Type_systems#Haskell_semantics
22:45:39 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Type_systems#Haskell_semantics
22:45:48 <dons> esp. with vim + haskell support
22:46:11 <phr-newbie> which paper?
22:46:29 <monochrom> I am too old for wiki.  I still write proofs with a fountain pen.
22:46:43 <lispy> stepcut: i think i looked at your library to turn quickcehck into HUnit but it requires posix :(
22:46:48 <lispy> stepcut: meaning i couldn't use it at work
22:47:09 <dons> there's another HUnit + QuickCheck framework though
22:47:24 * dons hunts for links
22:47:39 <lispy> in my case i use some parsing hackery to change the number of tests
22:47:46 <lispy> so that way you can specify that a test runs 1
22:47:49 <dons> here, http://haskell.org/haskellwiki/Libraries_and_tools/Program_development#Testing
22:47:51 <lambdabot> Title: Libraries and tools/Program development - HaskellWiki, http://tinyurl.com/n6fsn
22:47:55 <dons> HTF - The Haskell Test Framework
22:47:55 <dons>     The HTF lets you write HUnit tests and QuickCheck properties in an easy and convenient way.
22:48:00 <lispy> thus making it basically a unit test...just make a property that doesn't depend on input and run it once
22:48:09 <lispy> ah yeah i bet HTF is waht i looked at
22:48:15 <lispy> is that not by stepcut?
22:48:18 <dons> nope
22:48:24 <dons> that's stefanw's.
22:49:31 <dons> Heffalump: you should use normal names (not CamelCase) for new wiki pages, MergingSTThreads -> Merging_ST_threads
22:49:32 <lispy> my program reads through the definitions in the 'where' clause for 'numTests =' and then just does that many tests :)
22:49:37 <lispy> so you can set it per test
22:50:39 <lispy> i've been meaning to augment with smallcheck
22:50:46 <lispy> but other things always seem more important
22:51:19 <lispy> several of my properties have few enough input options that smallcheck would prove them in no time
22:51:32 <lispy> instead of quickcheck blindly running 1000 tests :)
22:51:44 <dons> grab smallcheck then?
22:52:14 <lispy> is it just drop in?
22:52:22 <dons> yep
22:52:25 <dons> just one module
22:52:26 <lispy> i've been worried about how much tweakingit will take
22:52:33 <dons> its pretty easy
22:52:38 <lispy> but i mean, is it api compatible with quickcheck?
22:52:42 <dons> yes
22:52:48 <lispy> does it even use the same Arbitrary class?
22:52:49 <dons> s/quick/small/ basically
22:52:52 <dons> nope
22:52:57 <dons> it uses a Serial class
22:53:07 <dons> so if you've spent a lot of time hacking up Arbitrary classes, that could be an issue
22:53:19 <lispy> not a lot of tie
22:53:23 <lispy> but a tiny bit
22:53:30 <lispy> i need to use the newtype trick more often
22:53:33 <dons> i'd just go with QC
22:53:58 <lispy> if you have enums then QC isn't so hot though
22:54:14 <lispy> like i have data Direction = N | S | E | W ...
22:54:24 <lispy> for that i needed an arbitrary instance
22:54:36 <dons> i don't see why that is hard?
22:54:44 <lispy> oh it's not
22:54:50 <dons> choose (minBound,maxBound::Direction)
22:54:52 <lispy> i tihnk it ended up being oneOf [ .... ]
22:55:03 <lispy> oh, that works with Enum?
22:55:04 <lispy> hmm...
22:55:12 <lispy> i hadn't tried that
22:55:15 <dons> ?hoogle minBound
22:55:16 <lambdabot> Prelude.minBound :: Bounded a => a
22:55:22 <dons> with Bounded anyway
22:55:31 <lispy> also, my type doesn't have a bound that way
22:55:37 <lispy> so [N..] would cycle
22:56:15 <lispy> which would probably confuse small check....i probably don't even use that property
22:56:17 <lispy> i should check
22:56:55 <lispy> at the time i said, "Oh, compass directions form a circle, so this should by cyclic"
22:57:40 <lispy> sometimes i put too much thought into the wrong things ;)
23:25:46 <weitzman> I'm seeing claims that Haskell implementations will automatically do some memoization. Is there a good place to read about the specifics of what will be memoized?
23:28:23 <Cale> weitzman: it's just what you get from sharing
23:28:59 <int-e> It's rather simple to implement memoizing functions.
23:29:15 <weitzman> So if you can make things point to the same data-structure, stuff doesn't happen twice
23:29:18 <Cale> if you define a function and say, pattern bind a variable in its where clause, and use it a bunch of times in the body, it won't be recomputed for each
23:29:23 <weitzman> But function calls always do?
23:29:27 <Cale> yeah
23:29:32 <int-e> While compilers could try to add that automatically it would be foolish to do - you'd get it wrong sometimes and then the memory usage of the resulting program will kill you.
23:29:44 <Cale> but you can build top-level datastructures which memoise function calls
23:29:51 <lispy> > fix \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- this memoizes itself
23:29:51 <lambdabot>  Parse error
23:30:00 <lispy> heh, and his parse errors :)
23:30:05 <lispy> er has
23:30:07 <dons> yeah,precise details (of , for exampel, how 'let' let's you share ), in http://haskell.org/haskellwiki/Research_papers/Runtime_systems
23:30:09 <lambdabot> Title: Research papers/Runtime systems - HaskellWiki, http://tinyurl.com/jyutg
23:30:14 <dons> "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine"
23:30:45 <lispy> > fix ( \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) -- this memoizes itself
23:30:46 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:32:27 <dons> fix $ \fn -> ... -- is a good idiom
23:33:22 <phr-newbie> @hoogle fix
23:33:23 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
23:33:23 <lambdabot> Control.Monad.Fix :: module
23:33:23 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
23:34:57 <phr-newbie> so what's the running time of    sum (take n fibs)  ?
23:35:45 <lispy> wouldn't it be O(n)?
23:35:56 <phr-newbie> for the memoized version, yes
23:36:33 <lispy> but what is the space complexity?
23:36:55 <int-e> that's a tricky question, lispy
23:36:58 <int-e> it depends :)
23:37:41 <lispy> on what?
23:37:51 <int-e> is fibs used elsewhere?
23:38:02 <lispy> ah
23:38:10 <lispy> that would get tricky...
23:38:41 <weitzman> Supposing I wanted to efficiently implement a 2d dynamic programming algorithm
23:38:58 <weitzman> Where in an imperative language I'd use a matrix of some kind
23:39:12 <dons> weitzman: do you have 'the craft of functional programming'? there's a section on memoisations techniques there
23:39:40 <weitzman> I do not
23:42:55 <int-e> fibs n = fix $ \res -> array (0,n) [(i, v) | i <- [0..n], let v = if i<2 then 0 else res ! (n-1) + res ! (n-2)]
23:43:19 <int-e> that's an array based dynamic programming version of fibonacci numbers.
23:44:05 <int-e> > array (0,0) [(0,0)]
23:44:07 <lambdabot>  array (0,0) [(0,0)]
23:44:24 <int-e> > let fibs n = fix $ \res -> array (0,n) [(i, v) | i <- [0..n], let v = if i<2 then 0 else res ! (n-1) + res ! (n-2)] in fibs 5
23:44:26 <weitzman> I would guess that's an immutable array
23:44:26 <lambdabot>  Exception: <<loop>>
23:44:33 <weitzman> Does copying have a high cost?
23:44:40 <int-e> hum
23:44:44 <int-e> it doesn't get copied.
23:45:04 <int-e> oh dang, I copied the wrong version.
23:45:13 <int-e> > let fibs n = fix $ \res -> array (0,n) [(i, v) | i <- [0..n], let v = if i<2 then 0 else res ! (i-1) + res ! (i-2)] in fibs 5
23:45:15 <lambdabot>  array (0,5) [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0)]
23:45:22 <int-e> > let fibs n = fix $ \res -> array (0,n) [(i, v) | i <- [0..n], let v = if i<2 then 1 else res ! (i-1) + res ! (i-2)] in fibs 5
23:45:24 <lambdabot>  array (0,5) [(0,1),(1,1),(2,2),(3,3),(4,5),(5,8)]
23:45:35 <int-e> stupid me :) there you go.
23:46:12 <int-e> it creates just one array, which initially gets filled with unevaluated thunks. then it forces the thunks as needed.
23:47:16 <int-e> it's a bit baffling at first that this works, because it makes use of lazy evaluation in a fundamental way.
23:48:45 * weitzman ponders
23:51:08 <int-e> you can replace   fix $ \res -> ...  by  let res = ... in res  if the 'fix' confuses you. That does the same.
23:53:09 <weitzman> So one conclusion I will make is that arrays don't care if you refer to parts of them before the rest of the constructor has been evaluated
23:54:01 <weitzman> Indeed, ok. Methinks the expression makes sense
23:59:44 <lispy> it's more like it doesn't know if the rest has been constructed...
