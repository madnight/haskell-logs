00:01:14 <ptolomy> hehe.
00:01:25 <ptolomy> Is writing a monad that much of an accomplishment?
00:03:16 <int-e> that depends. :)
00:03:51 <dolio> It sure sounds impressive to people who have only a vague understanding of what they are. :)
00:15:51 <therp> there is no such thing as the haskell report layed out for A4 printing?
00:16:22 <Korollary> There
00:16:27 <Korollary> There's the html version
00:16:39 <therp> is it actually "layed out" or "layouted"?
00:16:45 <Korollary> laid out
00:16:48 <therp> hm, html usually is horrible for printing
00:16:53 <therp> thanks
00:17:05 <int-e> http://haskell.org/haskellwiki/Language_and_library_specification#The_Haskell_98_report ... take the pdf version?
00:17:08 <lambdabot> Title: Language and library specification - HaskellWiki, http://tinyurl.com/el9gj
00:17:26 <int-e> or is that in letter format?
00:17:29 <therp> int-e: that letter format. 8.50in x 11in
00:17:42 <dolio> Laid out?
00:18:11 <therp> I tried to retex the gentle introduction but that produced even worse results
00:18:22 <therp> (on A4)
00:20:30 <mwc> dolio, lol, where is that pugs/monad quote from?
00:21:06 <dolio> mwc: http://programming.reddit.com/info/kjrr/comments
00:21:09 <lambdabot> Title: Randal L. Schwartz: "Perl 6 is Coming!" (Sys Admin magazine) (reddit.com), http://tinyurl.com/jfs89
00:21:35 <mwc> heheheh
00:26:33 <vegai> rapture or doom?
00:33:09 <dons> pugs really gives a lot of exposure to haskell. wonderful stuff
00:33:30 <dons> audreyt++
00:34:26 <Korollary> shoddy haskell software, that lambdabot
00:34:41 <Korollary> who broke ++?
00:35:04 <dons> its not broke. what are you talking about?
00:35:07 <dons> ?karma foo
00:35:08 <lambdabot> foo has a karma of 0
00:35:12 <dons> foo++
00:35:14 <dons> ?karma foo
00:35:15 <lambdabot> foo has a karma of 1
00:35:26 <Korollary> ah
00:35:28 <dons> foo--
00:35:30 <dons> ?karma foo
00:35:30 <Korollary> It doesn't announce
00:35:31 <lambdabot> foo has a karma of 0
00:35:33 <edwardk> its just not as chatty as ?karma+
00:35:33 <dons> right
00:35:46 <edwardk> ?karma+ dons
00:35:46 <lambdabot> dons's karma raised to 73.
00:35:48 <edwardk> see
00:35:51 <dons> its the unix way
00:35:56 <edwardk> whereas dons++ doesn't say anything
00:36:27 <wilx> ?karma wilx
00:36:27 <lambdabot> You have a karma of 0
00:36:28 <dons> so, as usual, its not a bug, its a feature!   ;)
00:36:29 <wilx> :)
00:36:42 <int-e> therp: hmm, if I interpret the bounding box correctly the ps file is actually A4.
00:36:45 <dons> lambdabot is thus full of features
00:37:14 <edwardk> many of them undocumented =)
00:37:44 <astrolabe> heh
00:38:02 <therp> int-e: the one on the url you pasted is 8.50x11in - that's letter.
00:38:23 <dons> edwardk: quite so :)
00:39:31 <int-e> while what xpdf produces from the pdf is letter.
00:40:06 <int-e> (here)
00:55:11 <Bobstopper> @pl \f xs -> mapM f xs >>= return . concat
00:55:11 <lambdabot> flip flip (return . join) . ((>>=) .) . mapM
00:58:04 <Botty> I should probably learn more haskell before asking such things, however, why aren't functions over-rideable.  For example, override map to do basically the same thing it does with lists, only on a traversal of a tree.
00:59:52 <Korollary> it
00:59:58 <Korollary> it's not really the same thing
01:00:11 <Bobstopper> try: import Prelude hiding (map)
01:00:54 <Korollary> Bobstopper: that's not what he means.
01:01:11 <Bobstopper> bummar. Oh well, I tried :)
01:01:14 <Botty> Bobstopper - I mean you have both map functions. use map for lists or trees
01:01:24 <Botty> heh yeah, thanks for that :)
01:01:34 <dons> with parametric polymorphism, and bounded polymorphism, via type classes, you can "override" in this way.
01:01:38 <dons> for example, fmap
01:01:43 <dons> works on trees, lists, IO, ..
01:01:46 <dons> ?type fmap
01:01:48 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
01:02:01 <Botty> oh, okie dokie then
01:02:06 <dons> over any container type which is an instance of Functor
01:02:08 <ktne> hello
01:02:08 <Botty> I suppose map is defined in terms of fmap?
01:02:16 <dons> yep
01:02:21 <dons> > fmap (+1) [1..10]
01:02:22 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
01:02:36 <ktne> anyone can explain to me what's the difference between a monad and a tail recursive state machine?
01:03:27 <Korollary> ktne: I don't think there's a thing like a tail recursive state machine.
01:04:00 <ktne> Korollary i mean implementing a state machine using recursivity
01:04:46 <mwc> ktne, so it just endlessly cycles through its states?
01:04:57 <Korollary> ktne: You can't do that. You can have tail recursive functions implemented using state machines maybe. But I am not sure if that's what you ask.
01:06:17 <ktne> i mean implemeting a virtual machine where the next state is computed recursivelly from the previous state
01:06:47 <Korollary> ktne: I don't think you use the term recursion correctly there.
01:07:05 <ktne> (usually by means of tail recursivity in order to get constant stack space consuption, otherwise you would get unlimited stack consumption)
01:09:10 <Korollary> ktne: Recursion means a function referring to its own 'name' in its definition. In a state machine, the next state is not expressed symbolically; it's expressed directly (no symbolic substitutions).
01:10:15 <int-e> therp: try this: http://int-e.home.tlink.de/haskell/haskell98-report-a4.ps.gz (or .pdf.gz)  it uses a smaller font to accomodate for the shorter lines so the page numbers are off.
01:10:18 <lambdabot> http://tinyurl.com/hltrh
01:10:34 <therp> int-e: thank you, I just sent it to the printer 3 minutes ago :/ .. but thanks anyway
01:11:28 <ktne> Korollary i mean implementing a big 'case' that will perform a state transformation and calling recursivelly the state machine function in order to advance to next state
01:12:55 <Korollary> ktne: As I said, you don't 'call' anything by any name in a state machine. It's always of the form "current state = 1, input = a, go to state 2". It's never "current state n, input a, go to state n-1".
01:14:49 <ktne> i'm thinking about a state machine with no input
01:15:00 <ktne> the state contains all data required
01:15:22 <Korollary> That doesn't change anything.
01:15:22 <dons> new issue of the Haskell Weekly News out now! http://sequence.complete.org/hwn/20061003
01:15:24 <ktne> think for example a state machine that will implement the brownian motion of one particle
01:15:52 <ktne> this means that in each state will move randomly (pseudo- based on current position)
01:16:04 <ktne> the next state is computed by recursive call
01:18:37 <Korollary> I have to repeat myself. There are no 'calls' in state machines. You mean something else.
01:18:51 <ktne> not in the state machine
01:18:57 <ktne> in the implementation of the state machine
01:19:08 <ktne> a state machine implemented as a recursive function
01:19:56 <ktne> the parameter to this function is the state, the function will transform this state and send it recursivelly to itself again
01:20:01 <Johnnn12> how to define [[integer]]
01:20:08 <Korollary> ktne: Ok, that is fine.
01:20:22 <Johnnn12> _ 1 2 3
01:20:22 <Johnnn12> 1 2 3 4
01:20:22 <Johnnn12> 2 3 4 5
01:21:03 <ktne> Korollary what do you mean?
01:21:12 <Korollary> ktne: Then what you mean is a tail-recursive implementation of a state machine in a typical language.
01:21:32 <int-e> > [[n..n+3] | n <- [0..2]]
01:21:34 <lambdabot>  [[0,1,2,3],[1,2,3,4],[2,3,4,5]]
01:21:46 <ktne> implementing this recursive function using tail recursion in order to avoid unbounded space consumption (because you don't need past states anymore)
01:24:09 <beelsebob> @where hoogle
01:24:10 <lambdabot> http://www.haskell.org/hoogle
01:24:10 <Korollary> ktne: In that case, the answer to your original question is difficult. "A" monad can be many things. You probably can't compare it to just any monad because there are many different kinds of monads. You probably are interested in the state monad.
01:26:29 <Johnnn12> int-e, but how to do multiplication table with lists ?
01:27:15 <int-e> Johnnn12: are these exercises? the idea is the same ...
01:27:25 <int-e> > [0,3..3*3]
01:27:26 <lambdabot>  [0,3,6,9]
01:28:26 <beelsebob> hmm... it's not possible to define data types and functions in one line, is it?
01:29:20 <int-e> sure, just abandon all layout.
01:29:47 <int-e> module XXX where { data A=B|C|D; f::A->A->A; f A B = C; ...
01:31:29 <beelsebob> well, I was really wanting to feed lambdabot some data constructors as well as something to evaluate
01:31:52 <int-e> well, that will fail, because it wants an expression
01:31:57 <beelsebob> indeed
01:32:07 <beelsebob> that's really what I meant
01:33:53 <beelsebob> hmm...
01:34:03 <int-e> > liftM2 (*) [1..3] [1..3]
01:34:05 <lambdabot>  [1,2,3,2,4,6,3,6,9]
01:34:22 <Bourbaki> moin
01:34:33 <beelsebob> any of you have any code that (a) doesn't use ffi, (b) doesn't use glasgow-exts (c) uses very few libraries but is (d) quite higher order
01:35:09 <dons> let me see....
01:35:21 * beelsebob is looking for interesting examples again
01:35:39 <dons> oh, we checked that network didn't work, right? http://www.cse.unsw.edu.au/~dons/tmp/bot.hs
01:35:51 <beelsebob> yeh, I doubt that'll compile with hat either
01:36:00 <beelsebob> (which is what I'm wanting just now)
01:36:09 <dons> ah. (runs in hugs, fwiw)
01:36:16 <beelsebob> I'm testing my higher-order debugger
01:36:26 <beelsebob> so I need examples that'll compile in hat
01:36:48 <dons> got a little script here, not sure if its high enough for you, http://www.cse.unsw.edu.au/~dons/code/hwn/utils/publish.hs
01:36:50 <lambdabot> http://tinyurl.com/f2wn7
01:37:21 <dons> oh, what about the io tut?
01:37:28 <dons> that's full of higher order stuff
01:37:44 <beelsebob> oh?
01:37:45 <beelsebob> where's that?
01:37:49 <dons> http://www.cse.unsw.edu.au/~dons/data/Basics.hs
01:37:51 <lambdabot> http://tinyurl.com/j9jck
01:38:28 <beelsebob> hmm, only simple HO stuff :/
01:38:32 <dons> yeah
01:38:42 <dons> you want rank n or something?
01:38:44 <beelsebob> I'm looking for stuff that gets really nasty... like a good piece of CPS or something
01:38:49 <dons> i wonder if there's something in nofib..
01:39:01 * dons hunts
01:39:02 <beelsebob> nofib doesn't compile
01:39:06 <beelsebob> already hunted there
01:39:09 <beelsebob> :/
01:39:13 <beelsebob> *wonders*
01:39:25 <beelsebob> rational deconstruction of the SECD machine might have a nice example to re-code
01:39:38 <dons> most of nofib is h98 though.
01:39:51 <dons> you mean that the build system doesn't compile?
01:39:59 <beelsebob> I suspect so
01:40:03 <dons> individual nofibs should probably run though
01:40:07 <beelsebob> I think I gave up relatively early with it
01:40:09 <beelsebob> I'll go prod it
01:40:16 <dons> lots of good code in there for testing
01:40:34 <beelsebob> ahh...I remember what the problem was
01:40:37 <beelsebob> lack of docs...
01:40:43 <beelsebob> couldn't figure out what input to give them
01:42:56 <beelsebob> I wish Hat actually managed to support all the libraries
01:43:02 <beelsebob> would open up a whole lot of doors
01:50:10 <dcoutts> sjanssen, that's a lovely quote from you in the latest HWN :-)
01:50:23 <dcoutts> * sjanssen: Quoth the Prelude, Chapter 6, verse 4: Yeah verily shall
01:50:24 <dcoutts> repeat floweth cons cells over.
02:14:36 <dons> fun seeing a perl6 tut begin with defining the factorial function...
02:44:51 <araujo> morning!
02:50:41 <dozer> morning
03:07:25 <dcoutts_> @seen boegel
03:07:26 <lambdabot> I saw boegel leaving #haskell and #haskell-blah 19h 54m 17s ago, and .
03:27:32 <kzm> Would it be very painful to have 'length :: Integral b => [a] -> b'?
03:27:42 <kzm> And ditto for 'take', 'drop', etc?
03:28:08 * kzm always forgets the appropriate sprinkling of 'fromIntegral's.
03:28:11 <gds> Isn't there some genericlength function...
03:28:14 <dcoutts_> @hoogle generic
03:28:14 <gds> ?
03:28:15 <lambdabot> Data.Generics.Aliases.Generic :: type Generic c
03:28:15 <lambdabot> List.genericDrop :: Integral a => a -> [b] -> [b]
03:28:15 <lambdabot> List.genericIndex :: Integral a => [b] -> a -> b
03:28:35 <dcoutts_> kzm, you can use those
03:28:55 <gds> @hoogle genericLength  ?
03:28:56 <lambdabot> Did you mean: GenericLength ?
03:28:56 <lambdabot> Prelude.undefined :: a
03:28:56 <lambdabot> Test.QuickCheck.Batch.bottom :: a
03:29:00 <gds> @hoogle genericLength
03:29:01 <lambdabot> List.genericLength :: Integral a => [b] -> a
03:29:01 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
03:29:55 <kzm> Ah, OK.  Somewhat cumbersome names.  Are these functions used in performance-critical enough settings that the cost of these is significant?  Or is it safety?
03:30:23 <dcoutts_> mostly simpicity & convenience
03:31:12 <kzm> Ah, dcoutts_ , I mean the other way around.  Why are we sacrificing the simplicity and convenience in favor of solid Int implementations for the standard functions?
03:32:08 <dcoutts_> there's a certain danger in being too generic, that there is not enough monomorphic types around to resolve ambiguous overloading
03:32:29 <dcoutts_> I think you'd have to look back at the libs rationale to see why we have length and genericLength
03:32:37 <dcoutts_> I'm only guessing
03:33:37 <dcoutts_> you could well ask the same question about map/fmap and many other functions that are only on lists rather than being over arbitrary monads etc
03:33:47 <gds> I remember it being discussed in here before - perhaps search the logs for "genericLength" ?
03:33:53 <gds> (not too long ago)
03:34:12 <dcoutts_> was that about why the size of a Data.Map is an Int ?
03:34:12 <gds> Actually - do we have a log search mechanism?
03:34:21 <dcoutts_> as that's a slightly different issue
03:34:25 <dcoutts_> gds, hmm, not sure
03:34:34 <gds> I thought it was about length - but I'm not sure.
03:34:41 <dcoutts_> maybe we need another lambdabot plugin :-)
03:34:55 <gds> ...and I have a vague feeling that it did come down to performance, but it's only a feeling.
03:34:56 <dcoutts_> YALP
03:35:05 <gds> :)
03:35:27 * gds imagines YALP as a plugin generating plugin...
03:38:04 <bartw> would you use Int for numbers that must not be negative ?
03:40:18 <dcoutts_> quite often, yes
03:42:50 <bartw> how can i use the type system to help check this ?
03:43:50 <dcoutts_> you could use a Word instead
03:44:41 <dcoutts_> in general for this kind of thing you can use a newtype and make a constructor function which checks the data type invariant
03:45:04 <dcoutts_> but for this specific case you could just use an unsigned numberic type
03:46:58 <int-e> > (-1)::Word
03:46:59 <lambdabot>  4294967295
03:47:28 <dcoutts_> it's not negative :-)
03:47:54 <int-e> I know, I know. But I would rather use Int so I see the 'wrong' negative numbers. In general at least.
03:47:58 <dcoutts_> but yes, fromIntegral makes it wrap, so if you want to check and make it an error, then use the newtype approach
03:51:34 <roconnor> @quote roconnor
03:51:35 <lambdabot>   O(n) is slow when n=infinity
03:51:53 <kzm> Any nice and general way to generate a random set of distinct integers in a range, uniformly distributed?
03:52:36 <kzm> currently, I keep a Set of already picked ints and pour randomRs into it until I have the desired number.  But that won't work well if I want a large proportion of the range.
03:52:52 <kzm> @quote kzm
03:52:52 <lambdabot>  My program contains a bug.  How ungrateful, after all I've done for it.
03:53:02 <sek> lol
03:53:03 <kzm> And I was sure I'd said nothing memorable!
03:54:33 <roconnor> kzm, the best I can think of is to keep an array of interger, and start permuting elements (suffling) them until you get the desired number of integers
03:55:06 <roconnor> kzm: so swap 0 with (0..n), then swap 1 with (1..n) and swap 2 with (2..n), etc.
03:55:27 <roconnor> until you swap (k-1) with (k-1..n)
03:55:40 <roconnor> (a..b) mean pick a random number between a and b
03:55:56 <roconnor> but this seems like an impertive way of looking at things
03:56:06 <roconnor> I wonder if there is a cute functional solution?
03:56:30 <roconnor> I suppose one could build up a list of swaps.
03:56:38 <roconnor> and then interpret that permulation.
03:56:48 <kzm> Well, from the appropriate distance, there isn't really much of a difference - I keep track of selected numbers, you keep track of unselected ones. :-)
03:57:33 <roconnor> kzm: yes, the advantage is that I never discard a random selection, so it always runs in k steps.
03:57:49 <kzm> But the Set of already selected can perhaps tell me how many elements less than a certain value?
03:57:50 <roconnor> @hoogle getRandom
03:57:51 <lambdabot> No matches found
03:58:34 <roconnor> kzm: I don't understand
03:58:49 <kzm> Give me a second to phrase this.. :-)
03:59:18 <kzm> say I pick randoms in ranges (1..n), (1..n-1) and so on.
03:59:41 <kzm> I keep storing selected numbers in my Set.
04:00:16 <kzm> Now for r_k, I need to find the r_k'th 'empty slot' in the Set - perhaps that is doable in something close to n log n time?
04:00:46 <roconnor> kzm: yes, something like that could work, but I fear it will be complex.
04:01:18 <kzm> possibly. :-)
04:01:32 <roconnor> actually with suitable recursion it won't be complex.
04:01:54 <kzm> But the a node in the set (binary tree) knows how many elements below it, and from the pivot and the range, we know the number of empty slots.
04:02:16 <kzm> So I think it is doable (complex or not)
04:03:31 <roconnor> choose n k = do{ x<-getRandomR (0..n-1); xs<-choose (n-1) (k-1); return (x:(map (\y -> if y>=x then y+1 else y) xs)) }
04:03:40 <roconnor> I think that will work
04:03:43 <roconnor> untested
04:04:08 * roconnor tests it
04:07:40 <roconnor> oh, it needs a base case
04:08:23 <roconnor> this works.
04:08:28 <roconnor> choose n 0 = return []
04:08:28 <roconnor> choose n k = do{ x<-getRandomR (0,(n-1)); xs<-choose (n-1) (k-1); return (x:(map (\y -> if y>=x then y+1 else y) xs)) }
04:08:39 <roconnor> *MonadRandom> print =<<(evalRandIO $ choose 6 4)
04:08:39 <roconnor> [1,4,5,3]
04:09:05 <roconnor> good ol' functional programming
04:10:57 <dozer> @hoogle (a -> m b) -> Maybe a -> m (Maybe b)
04:10:58 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
04:11:30 <dozer> no, that's not realy what I want :/
04:13:46 <dozer> ah - fmapM seems to do what I need
04:13:49 <dozer> @hoogle fmapM
04:13:49 <lambdabot> Data.FunctorM.fmapM :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
04:13:50 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
04:14:00 <roconnor> oh nice.
04:14:14 <dozer> that's only taken since yesterday lunch to find :)
04:32:57 <roconnor> @paste
04:32:57 <lambdabot> http://paste.lisp.org/new/haskell
04:34:35 <lisppaste2> roconnor pasted "possibly better choose function" at http://paste.lisp.org/display/27270
05:05:44 <dons> ?yow
05:05:45 <lambdabot> Isn't this my STOP?!
05:10:04 <x3m> hi dons
05:10:54 <dons> hey x3m. how's the hacking coming along?
05:10:58 <ValveQ> hi there folks
05:11:04 <dons> hey ValveQ
05:11:09 <roconnor> dons: why are the haskell VMs so slow :(
05:11:13 <x3m> not much, ive been away and came home yesterday
05:11:19 <dons> you lost a 'y' and an 'a', ValarQ?
05:11:29 <ValveQ> dons: your'e right!
05:11:49 <x3m> dons: did you came up with any new solution on how to fix the hs-plugin in win?
05:12:01 <dons> I haven't looked at it, x3m. have you tried building with mingw?
05:12:18 <dons> roconnor: hmm. ghc is only an average imperative code compiler?
05:12:34 <x3m> dons: nope, i guess i could try that
05:12:38 <dons> maybe we could submit it as a test case for ghc, so someone like rl could look at it.
05:12:44 <ValarQ> excuse me if i've been asking this before... but how do i get the functionality of the UNIX select(2) in Haskell?
05:12:45 <dons> x3m. ok.
05:13:23 <ValarQ> (for reading from two Handles)
05:13:36 <dons> ValarQ: i might be wrong, but waiting on a file descriptor using control.concurrent uses select (I think)
05:14:02 <roconnor> dons: doesn't ghc use gcc?
05:14:23 <dons> yeah, its a bit odd, I know. we get to within 4x
05:15:26 <ValarQ> we got:
05:15:29 <ValarQ> @type threadWaitRead
05:15:30 <lambdabot> Not in scope: `threadWaitRead'
05:15:32 <roconnor> dons: The only code on your list that is safe is Duncomloolump (C++), SamB, and Team Roflcopter
05:15:32 <ValarQ> :/
05:15:37 <ValarQ> threadWaitRead :: Fd -> IO ()
05:15:44 <dons> ?hoogle threadWaitRead
05:15:45 <lambdabot> Control.Concurrent.threadWaitRead :: Fd -> IO ()
05:15:51 <roconnor> I'm surprised that the C++ is safe, and only 50% slower
05:15:54 <dons> roconnor: heh.
05:15:54 <ValarQ> but thats only an Fd, not an FdSet
05:16:02 <ValarQ> or [Fd]
05:16:09 <roconnor> the haskell code that is safe is 34x slower
05:16:24 <roconnor> obviously this is no good. :)
05:16:41 <dons> oh, that can be tuned, i'm sure.
05:17:00 <dons> what has to be done to make my fast um safe?
05:17:07 <dons> you just wanted checked reads?
05:17:21 <roconnor> dons bounds checking the array reading and writing.
05:17:33 <ValarQ> i tried forking and reading but that resulted in a mess trying to keep track of the threads :/
05:17:35 <dons> so, replace unsafeRead/unsafeWrite with the safe versoins.
05:17:45 <dons> that should still be ok. (2x worse?)
05:17:50 <ValarQ> and i fear that wrapping it in STM is overkill for this application
05:17:59 <roconnor> I'll try that
05:18:04 <dons> ValarQ: might be a good question to ask on haskell-cafe@ ?
05:18:15 <dons> "How to select(2) on multiple handles", perhaps?
05:18:20 <ValarQ> dons: the big scary mailinglist?
05:18:36 <dons> yes. with lots of smart people waiting to consider your questions :)
05:18:48 * ValarQ gives it a shot
05:19:03 <dons> failing that, you could try pinging musasabi, he might have looked at this when hacking on HAppS
05:19:08 <ValarQ> worst that can happen is that they start to cry...
05:20:05 <dons> I suppose someone could submit a patch to ghc to check: when (user == "ValarQ") $ do remove files randomly -- that would be worse ;)
05:21:01 <ValarQ> not really, ValarQ is only my freenode nick because Vq is taken :P
05:21:20 <dons> heh
05:21:33 <ValarQ> and my irc machine is safely isolated from all my other machines :)
05:22:15 <dons> heh, seriously -- for security?
05:23:03 <ValarQ> well yes, not because of irc thought
05:23:30 <ValarQ> i just happen to run my ircclient on it because it's the machine with the least downtime
05:23:30 <norpan> i suppose it's still connected to the power grid
05:23:47 <ValarQ> norpan: oh no, they'll still find me then?!?
05:24:08 <musasabi> pong
05:24:10 <ValarQ> is there no one stopping the Haskellers!
05:24:25 <dons> the lambdabot is out to get you!
05:24:43 <roconnor> by monitoring power fluctuations you can tell when ValarQ is being sent as a nick on IRC.
05:24:47 <dons> hide your data constructors! wrap your types!
05:24:52 <musasabi> ValarQ: what are you wanting to do?
05:24:56 <ValarQ> yeah, truth to be told i got lambdabot installed localy on most machines
05:25:00 <roconnor> side channel attack
05:25:06 <ValarQ> musasabi: a very simple tcp proxy
05:25:18 <musasabi> isn't that quite simple?
05:25:23 <ValarQ> musasabi: http://paste.lisp.org/display/27148
05:25:37 <ValarQ> musasabi: yes it is, at least in C
05:26:14 <roconnor> dons: the reference um.um is also unsafe :P
05:26:28 <roconnor> not a very good reference IMHO
05:26:43 <dons> heh. how are you estabishing this?
05:27:18 <roconnor> when running um.um + segfault.um with edwardk, it still segfaults.
05:27:49 <roconnor> if the reference um was safe, it would have done a bounds check, and then halted.
05:27:53 <dons> ah, you have a segfault.um :) nice.
05:28:15 <roconnor> dons: I have 3 actually, of varying complexity.
05:28:26 <dons> how'd you construct these? vi?
05:28:57 <roconnor> I've written a UM assembler for my TMR article.
05:29:17 <norpan> a reference um would just be the identity function, right?
05:29:22 <dons> oh, good!
05:29:23 <roconnor> but the files are 8 to 16 bytes, so could have been written by hand.
05:30:33 <roconnor> norpan: is ghc just the identity function?
05:30:47 <norpan> ghc is not a reference implementation
05:31:01 <roconnor> but ghc is an implementation.
05:31:05 <norpan> indeed
05:31:15 <norpan> but the simplest implementation would be the identity function
05:31:39 <norpan> if haskell programs were haskell objects, that is
05:32:17 <norpan> but in the case of the um, it's clear that um.um could be the empty file and still work
05:32:57 <roconnor> maybe you are right
05:33:09 <roconnor> but the um.um is an interpeter
05:33:12 <roconnor> not a compiler
05:33:27 <roconnor> maybe I should call it the reference interpreter.
05:34:23 <norpan> it was a very good contest problem anyway
05:34:31 <norpan> nice change from all the games
05:34:37 <ValarQ> musasabi: any thoughts?
05:36:23 <musasabi> ValarQ: http://youzen.b2.fi/~musasabi/proxy.hs
05:36:54 <ValarQ> Network.Alt ?
05:37:13 <musasabi> @where network-alt
05:37:14 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/network-alt/
05:39:06 <musasabi> + proxying in the reverse direction too.
05:41:04 <ValarQ> musasabi: thanks
05:43:32 <dozer> @hoogle foldable
05:43:32 <lambdabot> No matches found
05:45:40 <roconnor> foldable?
05:47:11 <dozer> got this compiler error from ghc:
05:47:12 <dons> Data.Foldable, in newer base libraries
05:47:14 <dozer> src/Owl/Ontology.hs:4:0:
05:47:15 <dozer>     Warning: Module `Data.FunctorM' is deprecated:
05:47:15 <dozer>                  Use the more general Data.Foldable and Data.Traversable instead
05:47:29 <dons> right.
05:47:42 <dons> its just a deprecated warning. you've got till ghc 6.8 to sort this out :)
05:47:51 <dons> maybe more.
05:48:13 <dozer> fine, won't jump to fix it
05:48:31 <dozer> there are bigger logical problems with my code right now, without fixing deprecation warnings
05:49:13 <dons> :)
05:50:16 <dozer> I've not been haskelling much over the summer - what's up?
05:50:29 <dozer> ghc moving towards a major release?
05:50:39 <dozer> core libs being made more sane?
05:50:52 <dons> major release in a few days, yep
05:51:15 <dons> ummm. lots of things! catch up on the haskell weekly news :) sequence.complete.org and planet.haskell.org
05:51:56 <dons> dcoutts_: I note that LWN has put up an HWN article
05:52:03 <dons> not sure how to find it from the front page though.
05:52:11 <dons> (http://lwn.net/Articles/202317/)
05:52:12 <lambdabot> Title: LWN: Haskell Weekly News
06:05:43 <kzm> @karma+ fps
06:05:43 <lambdabot> fps's karma raised to 1.
06:06:22 <dons> kzm, fps helped solved something for you?
06:06:28 <kzm> I needed to randomly select sequences from a large (5+Gb) file.  With fps(.lazy), I'm half as fast as a straightforward grep.
06:06:50 <dons> ah good. sounds like a nice test case
06:07:06 <x3m> dons: have you used mingw?
06:07:14 <kzm> Roughly 2min on the 5Gb file, regardless of number of selected sequences (1k,10k,100k)
06:07:17 <dons> x3m, nope. i don't have a windows machine
06:07:25 <x3m> get one :)
06:07:41 <dons> kzm, interesting. is the code very large? could i have a look?
06:07:47 <kzm> just grepping for a pattern takes 1:15 or so.
06:07:50 <kzm> No, and yes.
06:08:08 <kzm> I'll push it to my web site, give me a second...
06:08:30 <dons> x3m, i'm ok thanks :) i like to be able to read the src code for my os when necessary. its very instructive.
06:08:35 * roconnor wonders how badly my choose function would fare.
06:09:08 <dcoutts_> dons, it'll get linked from this week's LWN weekly edition, on the programming page
06:09:12 <dozer> can I coax ghc into producing threaded code from a dumb haskell program?
06:09:19 <dozer> or is it not that clever yet?
06:09:26 <dons> dozer: with -threaded and forkIO, yes :)
06:09:52 <dozer> I have to manually call forkIO to spawn threads?
06:09:52 <dons> but I think for the forseable future you're at least going to have to tell the compiler (at least with types) that you want parallel code
06:10:35 <kzm> dons: http://www.ii.uib.no/~ketil/bioinformatics/repos/reps
06:10:36 <dons> there's the ndp library, where you use distributed array types, which will have the compiler produce forkIO's for you (and gang threads). but that's experimental
06:10:39 <lambdabot> Title: Index of /~ketil/bioinformatics/repos/reps, http://tinyurl.com/jxycf
06:11:03 <dozer> well, things like "map :: (a -> b) -> [a] -> [b]" could be threaded by the compiler, but I guess it's a question of granularity
06:11:04 <kzm> Some other junk in there, but the main files are Unigene (reading the file format), and RSelect (random selection)
06:11:08 <dons> dozer: do you have another compiler that does this? :)
06:11:18 <dons> yeah, map can be threaded, using the ndp lib.
06:11:31 <dons> for DArrays
06:11:44 <dozer> hehe, no - fortress sort of does this using its monoids and foralls.
06:12:08 <kzm> To compile it, you'll need 'bio' as well (sibling repo).
06:12:13 <dozer> kzm - you a bioinformatics guy?
06:12:25 <kzm> dozer, trying to :-)
06:12:27 <kzm> bi
06:12:29 <kzm> be
06:12:31 <dons> kzm, you could use unsafeHead
06:12:32 * kzm sighs
06:12:40 <dons> ah, not for .Lazy though
06:13:00 <kzm> Which head, and why not? :-)
06:13:38 <dons> unsafeHead doesn't make much difference in lazy bytestrings.
06:14:00 <dcoutts_> dons, which reminds me, we hacked on a patch when I was at chalmers to let alex use lazy bytestrings as input
06:14:12 <dcoutts_> it worked, but no perf numbers yet
06:14:13 <dons> good stuff!
06:14:55 <dons> kzm, so how have you found haskell holding up for the bioinf work?
06:15:07 * sieni hands dcoutts_ 6 and 28.
06:15:18 <dcoutts_> heh
06:15:18 <kzm> Hehe.  Well, it's fairly lonely here.
06:15:27 <dons> i'd be interested to read any article you wanted to write on using haskell for bioinf projects
06:15:28 <dozer> kzm: I'm a bioinformatics guy, but trying to learn some computing
06:16:04 <kzm> dons: I have some publications, but the main focus is on biology and algorithms, not on implementation.
06:16:15 <dons> yeah
06:16:26 <dons> was thinking more of just blog-like stuff on using haskell for large data sets and so on
06:16:33 <dozer> anybody up for a biohaskell? :)
06:16:48 <kzm> dozer, yes, actually.
06:16:52 <dons> if you ever want to write something on that, you could do a TMR for swiert, (or a blog article for HWN)
06:17:22 <kzm> That is, I have one library, mainly consisting of FASTA file format stuff, and there is some mention of biohaskell at the Univ. of Bielefeld.
06:18:21 <kzm> dons, I'm not sure my implementations are suitable for public viewing.
06:18:26 <dozer> there's a bio* hackathon some time before xmas - https://www.nescent.org/wg_phyloinformatics/Proposal
06:18:27 <lambdabot> http://tinyurl.com/j59dy
06:18:31 <dons> kzm, heh why's that?
06:18:41 <dons> code looks good to me :)
06:18:43 <dozer> phylogenetics seems like low-hanging fruit for functional languages
06:18:52 * kzm blushes.
06:20:05 <kzm> dozer, I'm no expert on phylogenetics, but there seems to be lots of tree traversals and whatnot.  Sounds functional to me :-)
06:20:18 <dons> mmm sounds fun
06:20:43 <dozer> nore am I :) I'm one of the original biojava guys, so it's been dynamic programming/HMMs and OO data models all the way
06:21:24 * dons is reminded of http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=all
06:21:26 <lambdabot> Title: binary-trees benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/zx84m
06:22:26 <dons> hmm. should look at what Clean is doing there.
06:22:41 <kzm> Heh.  It doesn't hurt so much to be number four when those are occupying the top slots.
06:23:08 <dons> trees are fun
06:23:30 <kzm> tackling the tree-hugging squad?
06:23:33 <dons> and the language least suited to data structures... ruby!
06:23:44 <musasabi> The binary trees benchmark was modified N times because Haskell was beating others with too embarassing numbers ;)
06:24:04 <kzm> To rub it in, you could point out that Ruby is only marginally worse than PHP...
06:24:30 <dons> the noise around ruby is really mystifiying to me.
06:24:36 <dons> thought they do have a nice website
06:24:41 * JKnecht has noticed significant points of commonality between H and Algol68 upon selecting the latter for a working purpose.
06:25:01 <ozone> dons: rails is good, thus the noise :)
06:25:05 <dozer> dons: I think they are snarfing both python and perl guys
06:25:14 <kzm> To give them some credit, you have to admit they do have some really bizarre documentation, though.
06:25:19 <dons> musasabi: this kind of thing "allocate a binary tree to 'stretch' memory, check it exists, and deallocate it"
06:25:38 <dons> sounds a bit unfunctional, doesn't it :)
06:25:55 <dons> ozone: yeah. rail + snarfing perl/python people
06:26:09 <dons> though i wonder if haskell is also snarfing perl/python people, of a different kind.
06:26:18 <ozone> the smart kind? ;)
06:26:37 <dons> wasn't CosmicRay a python guy?
06:26:45 <dons> and we do have a few of the perl stars around
06:27:01 <ozone> mostly thanks to miss tang
06:27:01 <dons> larry wall seems to get quoted in the HWN every week these days
06:27:09 <dons> most certainly.
06:27:21 <kzm> we do a bit of python, I guess I was an almost-python guy.
06:27:25 <ozone> well, wall actually knows some PLT (unlike that guido guy)
06:27:36 <dons> yeah.
06:27:37 <kzm> and I suppose I'm fairly snarfed now.
06:27:37 <ozone> dons: did you see that applescript paper btw?
06:27:46 <musasabi> hmm, the Haskell solution has comments like:
06:27:47 <musasabi> -- De-optimized by Isaac Gouy
06:28:00 <musasabi> so someone might want to try just porting the clean code over.
06:28:01 <dons> musasabi: saw that. he seems to have tweaked the spec a bit?
06:28:12 <musasabi> yes. the specs are a moving target.
06:28:21 <dons> he seems to have modified
06:28:22 <dons> -- make i (0::Int) = i `seq` Nil
06:28:22 <dons> make i (0::Int) = Node i Nil Nil
06:28:32 <dons> i wrote the commented out line, the second line is new
06:28:53 <dons> but we should try to port the clean version, I agree
06:29:02 <dons> it wasn't around previously
06:29:08 <dons> ozone: haven't read it yet.
06:29:54 * dons `ap` sleep
06:30:17 <dcoutts_> g'night dons
06:30:41 <ozone> is don, is sleep
06:31:41 <agentzh> hi, all~
06:32:04 <agentzh> anyone willing to help me to make the following haskell program a bit nicer?
06:32:20 <agentzh> http://svn.berlios.de/svnroot/repos/unisimu/Stats/Archive3/Tickets_.hs
06:32:23 <lambdabot> http://tinyurl.com/gbo8k
06:33:21 <agentzh> not sure how to do random simulation in a nice way in haskell. :(
06:33:51 <agentzh> it seems that i need a lot of side-effect there.
06:33:56 <norpan> it looks nice enough
06:34:08 <agentzh> norpan: really?
06:34:11 <ozone> agentzh: http://www.haskell.org//pipermail/haskell-cafe/2004-July/006444.html
06:34:13 <lambdabot> Title: [Haskell-cafe] Re: so how does one convert an IO a into an a ?, http://tinyurl.com/fjccl
06:34:17 <ozone> you can do it without IO
06:34:29 <ozone> (without using unsafePerformIO :)
06:34:31 <dozer> dang - trying to get through the nick server here :/
06:34:31 <agentzh> ozone: ah! looking now
06:35:12 <norpan> not entirely without IO of course
06:35:48 <agentzh> IO is one of the most ugly elements in haskell IMHO. :)
06:36:56 <agentzh> rollDice...hehe
06:37:01 <fasta> Can I import a constructor Foo as Bar using the module system?
06:38:26 <dcoutts_> fasta, no
06:38:44 <fasta> dcoutts_: I thought so. Thanks
06:38:44 <agentzh> ozone: thanks a lot. that's exactly what i want!
06:38:58 <dcoutts_> fasta, you can import qualified Module1 as Baz and then use Baz.Foo, but that's all
06:39:25 <fasta> dcoutts_: The technique of adding more types to encode invariants seems pretty useful, btw.
06:39:32 <dcoutts_> yes
06:39:57 <dcoutts_> you can take that technique a long way
06:40:07 <fasta> dcoutts_: Basically my program grew into a horrible mess, and now, I am "reverse-engineering" it somewhat.
06:40:13 <ozone> agentzh: np
07:01:39 <ptolomy> IO is one of the most ugly elements in life.
07:01:50 <ptolomy> I so much prefer ruminating abstractly over actually doing anything outside myself.
07:02:02 <norpan> yeah, being born is the "output" part of IO
07:03:20 <ropine> as Sartre said, hell is other programs. or something like that.
07:23:40 <Phillemann> Is there a site which features smaller scripts in Haskell? I just read large parts of the gentle introduction and yaht and I just want to see if I understand a basic script and learn from it.
07:28:46 <Lemmih> Phillemann: There's http://www.haskell.org/hawiki/HaskellDemo.
07:28:47 <lambdabot> Title: HaskellDemo - The Haskell Wiki
07:39:58 <fasta> In what type class can I put 'operation' if the following holds? A a `operation` A b == A (a++b)
07:40:32 <sjanssen> fasta: probably Monoid
07:40:50 <sjanssen> @hoogle mappend
07:40:51 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
07:41:04 <fasta> sjanssen: right, thank you
07:45:19 <hawking> hi.. I want to start learning haskell..Can someone give me some directions? like book names,web pages etc.
07:45:42 <earthy> The Haskell School of Expression
07:45:56 <earthy> haskell.org, ofcourse
07:45:59 <gour> Thompson's Craft of FP
07:46:07 <earthy> especially the
07:46:13 <musasabi> Yet Another Haskell Tutorial
07:46:14 <earthy> 'Getting started' section on Haskell.org
07:46:28 <kalmar> exists? library function to show integer in binary representation?
07:46:29 <hawking> earthy: yeah I just saw that
07:46:51 <fasta> kalmar: not that I know of
07:47:05 <musasabi> kalmar: there are 10+ libraries to do variations of that.
07:47:20 <kalmar> any in the standar libs?
07:47:42 <earthy> nope
07:47:44 <kalmar> not quite sure what google string will get it
07:47:45 <sjanssen> @hoogle showIntBase
07:47:46 <lambdabot> No matches found
07:48:07 <musasabi> if you just want 3 -> "10" then look at Numeric.
07:48:09 <ropine> earthy: I've found Haskell School of Expression to be helpful, although it took a while to figure out how to get Hugs to talk to the SOEGraphics library
07:48:09 <sjanssen> @hoogle showIntAtBase
07:48:10 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
07:48:24 <kalmar> @docs Numeric
07:48:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
07:48:56 <ropine> (this was on Debian stable Linux; the Windows installer might make it easier on a Windows machine)
07:52:26 <kalmar> showIntAtBase is nicely customisable
07:54:23 <kalmar> thanks loads
07:54:41 <Phillemann> Are programs compiled with ghc completely independent of any other library, or do they need some haskell runtime library?
07:54:56 <SamB> Philippa: the RTS is linked in
07:55:01 <SamB> er, Phillemann
07:55:08 <SamB> sorry Philippa ;-)
07:55:35 <Phillemann> SamB: So it doesn't need anything. Okay, thanks. :)
07:55:43 <SamB> well, it might need *something*
07:55:55 <fasta> A CPU can come in handy
07:56:01 <SamB> but such as GMP
07:56:14 <SamB> what OS are you on?
07:56:21 <sjanssen> SamB: I think GMP is statically linked in too
07:56:26 <Phillemann> Gentoo Linux...
07:56:44 <SamB> hmm
07:57:01 * SamB looks for the right flag to objdump
07:57:10 <Lemmih> sjanssen: It's not.
07:57:30 <sjanssen> I stand corrected
07:57:49 <Lemmih> (at least not always)
07:58:34 <gour> Phillemann: you can visit #gentoo-haskell too
07:58:38 <fasta> How long before we get to use more than Latin-1 in source code?
07:58:55 <Phillemann> gour: Why is there a distribution-specific channel for a language?
07:59:05 <SamB> maybe readelf would work better
07:59:14 <gour> Phillemann: dealing with haskell packages in gentoo
07:59:15 <Phillemann> fasta: Haskell does not support UTF-8?
07:59:27 <SamB> Phillemann: in fact it does not
07:59:32 <Phillemann> Damn...
07:59:35 <fasta> Phillemann: Haskell 98 does, important implementations do not, IIRC.
07:59:39 <musasabi> Phillemann: libgmp is needed and is dynamically linked.
07:59:40 <dcoutts> huh? yes it does
07:59:41 <SamB> fasta: no it doesn't
07:59:44 <sjanssen> fasta: incorrect
07:59:52 <SamB> it never says what encoding files are in or anything like that
07:59:54 <sjanssen> Haskell doesn't support any concrete Unicode encoding
07:59:55 <SamB> it supports
08:00:00 <SamB> *Unicode*
08:00:03 <SamB> but not UTF-8
08:00:17 <dcoutts> well the Haskell String type is UTF32
08:00:26 <Lemmih> fasta: Just till ghc6.6 is out.
08:00:31 <sjanssen> dcoutts: I think it's misleading to say that
08:00:38 <dcoutts> sjanssen, how so ?
08:00:48 <SamB> (and only then because it would take a whole word to store the codepoint in a Char anyway)
08:00:58 <Phillemann> dcoutts: It internally uses UTF-32?!
08:01:00 <SamB> sjanssen: it is supposed to be!
08:01:07 <musasabi> I think Perl6 is one of the very few languages supporting Unicode in a sensible manner.
08:01:13 <fasta> Every now and then I read "What every programmer needs to know about encodings (or something like that)", but I forget the details everytime.
08:01:19 <SamB> Philippa: believe us, the inefficiency of that is nil compared to using a lazy list
08:01:19 <sjanssen> dcoutts: UTF32 specifies how a sequence of code points is turned into a sequence of bytes.  Haskell Strings are just lists of Unicode code points
08:01:23 <sjanssen> there is no encoding there
08:01:24 <SamB> er, Phillemann
08:01:26 <kzm> Isn't it UCS-4, really?
08:01:27 <SamB> sorry again Philippa
08:01:28 <musasabi> Many other languages including Haskell have partial unicode support.
08:01:32 <fasta> Maybe I need to implement a compiler first before I understand it :)
08:01:34 <Phillemann> kzm: Can you tell the difference?
08:01:37 <kzm> (Or is that the same thing)
08:01:38 <dcoutts> Char is a unicode code point (defined to be so in Haskell98) therefore [Char] is UTF32
08:01:44 <fasta> Lemmih: fantastic
08:01:49 <dcoutts> sjanssen, ah, hmm I see your point
08:01:55 <SamB> really, having a 32-bit Char might be *more* efficient
08:02:02 <SamB> if that is possible
08:02:16 <dcoutts> sjanssen, because [Char] not a byte oriented thing, hence not an encoding
08:02:22 <dcoutts> yeah, fair point
08:02:44 <sjanssen> dcoutts: right.  I'm just being anal retentive about the terminology because people seem to confuse it so often ;)
08:02:51 <dcoutts> true
08:03:00 <Lemmih> fasta: There's still a few problems with it; GHCi doesn't really like it.
08:03:21 <dcoutts> kzm, there's no such thing as UCS4 (not anymore)
08:03:29 <fasta> Lemmih: oh, well, I probably wait until it's stable and implemented in multiple implementations.
08:03:42 <musasabi> So Haskell implements unicode code points (UCS-4), but not unicode transfer condings (UTF-X) or collation or normalization.
08:04:18 <dcoutts> I think UCS4 reffered to an encoding too
08:04:20 <ropine> and the implementations won't let you use a Unicode dingbat as an operator
08:04:31 <musasabi> (or in whatever way "sequence of unicode code points" should be abrevated)
08:04:33 <kzm> Apparently, Unicode no longer differentiates between fixed size (UCS) and variable sized (UTF).
08:06:57 <SamB> kzm: which is stupid
08:07:01 <SamB> but oh well
08:07:24 <SamB> than again, having any UTF save UTF-8 was stupid
08:07:51 <musasabi> UTF-8 is not very good for many non-european languages.
08:08:01 <SamB> it works
08:08:04 <sjanssen> SamB: there are good arguments for the other encodings
08:08:14 <SamB> sjanssen: I'm not saying the encodings are bad
08:08:27 <SamB> just that UTF-16 should never have existed
08:08:40 <SamB> and that UTF-32 is a bad name
08:08:49 <sjanssen> there are some good arguments for UTF-16 too
08:08:56 <glguy> ASCII is pretty sweet
08:08:59 <SamB> such as driving people insane?
08:09:14 <SamB> I prefer schemes that do not involve crazy pseudo-codepoints
08:09:37 <SamB> well, perhaps a more sane UTF-16 would be nice
08:09:41 <ropine> IIRC the Unicode folks used to think that they could fit everything into 16 bits, and then when they realized they couldn't, UTF-16 became a backward-compatibility hack
08:09:47 <SamB> but it is too late for that
08:09:55 <sjanssen> SamB: how can UTF-16 be made more sane?
08:10:05 <glguy> Who was asking for Visual Haskell on 2005?
08:10:11 <SamB> sjanssen: not involving pseudo-codepoints?
08:10:28 <dgoldsmith> UTF-16 is the preferred encoding for Unicode for most implementations, for a reason.
08:10:45 <dgoldsmith> Characters outside the BMP are rare.
08:10:52 <sjanssen> SamB: I think that is an implementation problem, not the encoding's fault.  String libraries shouldn't give you "half" chars.
08:11:07 <SamB> sjanssen: oh, sure
08:11:18 <dgoldsmith> Most processes on Unicode text can't operate on a character at a time, anyway.
08:11:35 <dgoldsmith> You have to worry about sequences. Surrogate pairs are not the only issue.
08:11:43 <sjanssen> dgoldsmith: true, true
08:11:50 <SamB> dgoldsmith: not all things, though
08:12:16 <sjanssen> we have the multiple code points representing a single glyph problem with all Unicode encodings
08:12:38 <dgoldsmith> Right. The character/glyph mapping is many-to-many.
08:12:45 <fasta> A large number of computer problems seem to stem from using  fixed size data without an idea of how to extend it easily.
08:13:15 <SamB> thats what I like about UTF-8
08:13:24 <dgoldsmith> And that's not the only process that needs to look at collections of characters. Collation is the same way, as is boundary analysis (word and line breaking). The only thing you can do with a single character is look up its properties.
08:13:32 <SamB> ... sure, it might not be extended *efficiently*
08:13:36 <musasabi> SamB: for CJK texts using UTF8 instead UTF16 can lead to a 50% size increase.
08:13:45 <SamB> but at least it is *uniform*
08:14:26 <SamB> its too bad they were so short-sighted, thinking 16 bits would be enough
08:14:32 <SamB> if only they had picked 15 bits!
08:14:43 <dcoutts> SamB, UTF16 is faster for processing that UTF8 since there are many fewer conditionals needed for decoding
08:14:47 <ropine> there's also BOCU and SCSU
08:14:54 <SamB> ropine: what are those?
08:15:04 <musasabi> SCSU is quite bad for most purposes.
08:15:05 <dcoutts> SamB, in the normal case there are no surrogate pairs, so it's fast.
08:15:06 <sjanssen> ropine: don't forget UTF-9!
08:15:08 <SamB> dcoutts: I suppose...
08:15:14 <SamB> utf-9!
08:15:18 <dgoldsmith> I've discussed this many times with the principals involved, and they likely would have chosen 16 bits even knowing the need to extend it.
08:15:18 <dcoutts> SamB, but half the memory bandwidth of UTF32
08:15:26 <SamB> dcoutts: mmm
08:15:28 <ropine> BOCU: http://www.unicode.org/notes/tn6/
08:15:29 <lambdabot> Title: UTN #6: BOCU-1
08:15:33 <dcoutts> SamB, actually UTF21 would be perfect :-)
08:15:36 <SamB> dgoldsmith: as opposed to 15?
08:15:44 <SamB> dcoutts: huh?
08:15:51 <dcoutts> SamB, it's a shame that we have to work in multiples of 8
08:16:04 <SamB> what would you prefer? 7
08:16:04 <SamB> ?
08:16:08 <dgoldsmith> SamB: I'm not sure what you mean. Why 15?
08:16:11 <dcoutts> SamB, all unicode code points can be represented in 21 bits
08:16:25 <dcoutts> but that's bigger than 16 and much less than 32
08:16:30 <SamB> mmm
08:16:39 <dcoutts> 24 doesn't seem worth it due to the alignmnet problems
08:16:41 <ropine> I assume SamB means that if they had started with 15 bits, then UTF-16 could have used the 16th bit
08:16:43 <dcoutts> ie 3 bytes
08:16:44 <dgoldsmith> UTF-16 is the "sweet spot" where all characters in common use are the same width, and you only need to handle other forms on a (rare) exception basis.
08:16:50 <SamB> ropine: exactly!
08:17:00 <kalmar> can one have class declarations that define no interface
08:17:05 <kzm> dgoldsmith, I bet you could say that for utf-8 as well.
08:17:06 <dcoutts> dgoldsmith, yes.
08:17:10 <kalmar> for program organisation
08:17:14 <dcoutts> kzm, I don't think so.
08:17:14 <kalmar> ohh hm
08:17:24 <SamB> dcoutts: depends on the use-case
08:17:27 <dgoldsmith> kzm: no, not at all. In UTF-8, only ASCII is fixed width.
08:17:27 <hyrax42> woops
08:17:34 <dcoutts> SamB, sure, if it's all ASCII...
08:17:51 <kzm> I bet the majority of all text is ASCII.
08:17:53 <SamB> what if it is ASCII with a few symbols here and there?
08:17:57 <dgoldsmith> This is why Windows, Mac OS, and ICU all use UTF-16.
08:18:02 <SamB> kzm: only in english!
08:18:05 <dcoutts> kzm, go talk to the people in haskell.se :-)
08:18:08 <musasabi> BOCU-1 looks nice.
08:18:12 <dcoutts> it's not ASCII
08:18:12 <kzm> :-)
08:18:16 <dgoldsmith> Right, things like curly quotes and em dashes are not in ASCII.
08:18:26 <SamB> however, you must admit that most files contain text in a single language
08:18:29 <hyrax42> yay or nay: "class C where;"
08:18:46 <SamB> dgoldsmith: ... curly quotes?
08:18:51 <sjanssen> hyrax42: I think that will break
08:18:55 <dgoldsmith> SamB: Right, but even French or German are not fixed width in UTF-8.
08:19:01 <SamB> dgoldsmith: true
08:19:08 <hyrax42> sjanssen, so a class must define at least one interface function?
08:19:19 <dgoldsmith> SamB: typographic quotes, “like this”
08:19:19 <SamB> so kzm should have added some qualifiers
08:19:28 <sjanssen> hyrax42: no.  You just skip the where when you have no functions in the class
08:19:29 <musasabi> SamB: with UTF16 most strings are fixed width (and can be tagged as such).
08:19:39 <hyrax42> sjanssen, aahhhh
08:19:40 <dcoutts> hyrax42, you can have a class with no class functions, that's fine.
08:19:42 <SamB> I see some spikes with the sharp bit up and some with it down
08:19:42 <hyrax42> much more sense
08:19:46 <hyrax42> thanks
08:19:56 <SamB> musasabi: mmm
08:19:58 <SamB> tagging
08:20:00 <hyrax42> is used for restricting certain things, yes?
08:20:01 <SamB> not bad!
08:20:07 <dcoutts> yes
08:20:19 <ropine> given that most applications that deal with Unicode strings will either be working with small strings (in which case the performance of string-handling would be overwhelmed by other aspects of the application) or reading text from disk or a network (in which case there's I/O latency), how much does the overhead of translating from UTF-8 hurt overall performance in practice?
08:20:24 <kzm> Well - it was an exaggeration.  I still don't like utf-16.
08:20:46 <dcoutts> ropine, it depends on how much processing of the strings you do
08:21:04 <kzm> ropine - some cases, perhaps you want to lookup the character at some index.
08:21:06 <musasabi> ropine: well it depends on what the input is (and if the input is in utf16 instead of utf8...)
08:21:09 <Phillemann> Plain text can also be compressed pretty well. I can imagine encoded text can, too.
08:21:18 <SamB> dcoutts: could, say, a lexer be composed with the conversion process?
08:21:25 <kzm> for utf-X that is an O(n) operation.
08:21:30 <SamB> (and somehow fused?)
08:21:35 <musasabi> Btw the encoding/decoding is hardly the most expensive thing.
08:21:36 <kzm> for UCS-X, it is O(1)
08:21:46 <dcoutts> SamB, yes and probably.
08:22:29 <musasabi> Usually for text one wants to either 1) just pass it through ignoring all encoding issues, 2) do stuff with the text and worry about normalization and graphemes.
08:22:33 <SamB> oh, but, hmm. how do you translate-as-you-go?
08:22:54 <dcoutts> SamB, readUTF8 :: ByteString -> Stream Char
08:23:14 <SamB> musasabi: I'd think it would be better to pass it through tagged with an encoding, or knowing that it is supposed to be in a particular encoding...
08:23:20 <SamB> dcoutts: mmm
08:24:03 <dcoutts> SamB, what I would do is have another ByteString style encoding, but with a char count and a byte length, then use the same fusion system
08:24:16 <musasabi> SamB: depends heavily on things. e.g. with files in a multiuser environment they are bound to have different encodings.
08:24:30 <dcoutts> SamB, note that if char count = 2 * byte count then you can do O(1) indexing.
08:24:44 <dgoldsmith> The disk storage format is not important; I agree it's overwhelmed by the I/O. UTF-16 is best for processing in memory.
08:24:47 <dcoutts> SamB, you can't normally do that with UTF8, but you can with UTF16
08:24:59 <SamB> dcoutts: mmm, don't you have it backwards?
08:25:05 <dgoldsmith> Well, you can't really do it with UTF-16 due to the occasional presence of surrogates.
08:25:15 <SamB> you can't store 2 characters in a byte can you?
08:25:22 <dgoldsmith> However, random access to Unicode strings is seldom necessary.
08:25:23 <dcoutts> SamB, I don't think so, do I ?
08:25:27 <musasabi> dgoldsmith: which can be detected when constructing the string as they are immutable in Haskell.
08:25:41 <SamB> "if char count = 2 * byte count ..."
08:25:43 <dcoutts> SamB, byte count * 2 = char count. eg 100 bytes = 50 chars
08:25:46 <musasabi> and random access to code points is not very important.
08:25:49 <dgoldsmith> Yes, true, if you're going to scan the whole thing.
08:25:52 <kzm> dcoutts, since charsets *tend* to favorize a certain encoding length, you could probably do it for utf-8 too.
08:26:03 <SamB> dcoutts: that is called "/"
08:26:05 <SamB> not "*"
08:26:24 <dcoutts> SamB, oh yes, my confusion. :-)
08:26:33 <SamB> thats what I meant by "backwards"
08:26:33 <dcoutts> char count * 2 = byte count
08:26:53 <kzm> i.e, use lazy byte strings, and try to keep segments with fixed-size chars.  A bit more complex, though.
08:27:01 <dcoutts> but as musasabi says, that's probably not so important
08:27:26 <SamB> kzm: this idea has come up before ;-)
08:27:42 <SamB> but what has that got to do with utf-8?
08:27:43 <dcoutts> since it's mostly left-to-right traversals that you're going to be doing, not random code point lookups
08:28:18 <dcoutts> kzm, and it's not all that useful. We don't have O(1) lookup now and no one complains.
08:28:22 <kzm> SamB: that was in response to the mostly-working check char count vs 2* byte count for utf-16
08:28:23 <hyrax42> @fptools Control.Monad.RWS
08:28:24 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/RWS.hs
08:28:42 <kzm> dcoutts, we don't?  index?
08:28:51 <dcoutts> kzm, on String ?
08:28:57 <SamB> heh
08:28:58 <kzm> On ByteString.
08:29:09 <kzm> And people *do* complain.
08:29:09 <SamB> or ByteString.Lazy, obviously
08:29:13 <kzm> At least, I do.
08:29:18 <kzm> :-)
08:29:23 <musasabi> SamB: UTF16 is so much simpler - why would one prefer UTF8 for in-memory things?
08:29:34 <dcoutts> kzm, sure, on ByteString we do. But for text rather than binary stuff do you really use indexing ?
08:29:50 <SamB> never complain about > O(1) lookup on datastructures with lazy spines...
08:30:02 <kzm> dcoutts, not really.  But then, what is the advantage of utf-16 over utf-8?
08:30:09 <SamB> unless you didn't want such in the first place
08:30:21 <dcoutts> kzm, faster processing than utf8 because of the simpler encoding.
08:30:31 <dgoldsmith> The advantage of UTF-16 over UTF-8 is it's the best compromise between space and speed for Unicode.
08:30:32 <musasabi> kzm: much simpler to use and all "common" things are fast.
08:31:21 <dcoutts> the answer is to implement both and see which is faster for many common tasks.
08:31:26 <dcoutts> but that's a lot of work
08:31:27 <dgoldsmith> It's possible to do the algorithms on UTF-8, just less efficient.
08:31:44 <dgoldsmith> No need. There are years of implementation experience to look at.
08:31:45 <kzm> I guess it depends a lot on which tasks are "common".
08:31:51 <dcoutts> though we probably want to have UTF8 & 16 anyway, if only for interoperability
08:32:06 <dcoutts> with the stream stuff we can have much of it for free
08:32:48 <dcoutts> since the stream operates on Chars and there are just two functions for decoding & encoding
08:33:01 <dgoldsmith> Look, for example, at ICU for many of the algorithms used on Unicode text. http://icu.sourceforge.net/
08:33:02 <lambdabot> Title: ICU Homepage @ SourceForge.Net
08:33:07 <dcoutts> so we get to share much of the implementation for UTF8/16/32
08:34:17 <musasabi> dcoutts: what is the current plan to handle graphemes?
08:34:27 <dcoutts> no plan
08:34:43 <SamB> what is a grapheme?
08:34:53 <SamB> that sounds a bit beyond the scope of a string library...
08:35:05 <musasabi> SamB: it is very important.
08:35:11 <SamB> I don't doubt it
08:35:13 <musasabi> if proper text handling is desired.
08:35:17 <SamB> mmm
08:35:26 <dcoutts> do you mean canoncialisation? where a single code point gets converted to a char + a combining modifier thingie ? (or vica versa)
08:35:37 <dgoldsmith> SamB: Short answer, a grapheme is what the end user thinks of as a character.
08:35:37 <SamB> well, perhaps it should be in a text library?
08:35:43 <dgoldsmith> Long answer: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
08:35:43 <SamB> mmm
08:35:45 <lambdabot> Title: UAX #29: Text Boundaries, http://tinyurl.com/mkel2
08:36:00 <SamB> HTH are you *supposed* to deal with them, though?
08:36:00 <musasabi> dcoutts: and not all characters do have a pre-composed alternative form.
08:36:05 <dcoutts> musasabi, so the normal way is to expand right ?
08:36:06 <SamB> does anyone else have a clue?
08:36:28 <musasabi> dcoutts: depends on the system.
08:36:40 <dcoutts> musasabi, since as you say there isn't a pre-composed form for them all so you have to deal with the combining chars anyway, so just expand them all.
08:36:41 <musasabi> that is where all different normalization systems come into play.
08:36:49 <dgoldsmith> SamB: Conformant Unicode processes are supposed to handle normalized or unnormalized Unicode.
08:36:56 <dcoutts> musasabi, oh, different normalization systems. yay. :-(
08:37:11 <musasabi> dcoutts: yes. But think about folding. How should fold work if there are combining characters?
08:37:27 <SamB> musasabi: it shouldn't matter
08:37:30 <dgoldsmith> musasabi: It depends on what you're doing to the text.
08:37:57 <dcoutts> musasabi, there's no atomic representation of a grapheme right ?
08:37:59 <norpan> you should probably have something converting from [Char] (or whatever) to [Grapheme] first then
08:38:09 <SamB> or, at least, if not all of these conglomerations have codepoints, you can't expect them to be passed to functions...
08:38:15 <musasabi> norpan: yes. That is what I would like.
08:38:19 <dgoldsmith> norpan: there is no such thing as a Grapheme type.
08:38:28 <norpan> but there could be
08:38:32 <SamB> dgoldsmith: ... not yet there isn't!
08:38:34 <norpan> type Grapheme = [Char] :)
08:38:37 <dcoutts> dgoldsmith, yes, why isn't there ?
08:38:40 <musasabi> grapheme = [CodePoint] = [Char]
08:38:48 <dgoldsmith> Well, yes, you could do it that way.
08:39:03 <norpan> or some other way
08:39:07 <dgoldsmith> There isn't a lot of point, though.
08:39:10 <dcoutts> musasabi, but then as you say, how do you fold when you want to look at graphemes ?
08:39:37 <SamB> dcoutts: well, you'd have to split the string into graphemes and fold over those
08:39:44 <musasabi> dcoutts: fold giving the function a [Char] instead of Char.
08:39:49 <dcoutts> we just pass [char] ? where there can be an arbitrary number of combining chars?
08:40:10 <dcoutts> it isn't bounded right? though in practice it's no more than 3 usually.
08:40:24 <dgoldsmith> dcoutts: correct, it is not bounded.
08:40:41 <SamB> I think it is fair to say that it is about as bounded as identifiers are, though probably smaller
08:41:09 <hyrax42> huh
08:41:11 <SamB> which is to say, it isn't, but it probably isn't *too* big either
08:41:17 <hyrax42> newtypes cannot use the record syntax?
08:41:24 <SamB> hyrax42: sure can!
08:41:26 <dcoutts> hyrax42, they can
08:41:29 <SamB> @paste
08:41:30 <lambdabot> http://paste.lisp.org/new/haskell
08:41:30 <hyrax42> I'm getting parse errors on ,
08:41:38 <SamB> you can only have one field though
08:41:41 <hyrax42> but if I
08:41:41 <hyrax42> oh
08:41:48 <SamB> if you need more use Data
08:41:49 <dcoutts> because it's a newtype
08:41:51 <SamB> er. data
08:42:08 <hyrax42> oh I though newtypes restricted you to one constructor
08:42:11 <hyrax42> not one field
08:42:17 <SamB> both
08:42:21 <hyrax42> a tuple is allowed?
08:42:25 <SamB> yes
08:42:33 <hyrax42> that seems an artificial restriction then
08:42:40 <SamB> but the point is, it has the same representation as its field
08:42:44 <dcoutts> hyrax42, you can't say: newtype Foo = Foo Int Int Int
08:42:47 <SamB> so it can only *have* one field
08:42:49 <jgrimes> if I have some functions that accept different Num types and return true if they match certain bit patterns, but I want a function that returns if any of them are true, how might I do that?
08:42:54 <dcoutts> hyrax42, but you can say: newtype Foo = Foo (Int, Int, Int)
08:42:59 <hyrax42> hm
08:43:02 <dcoutts> hyrax42, but the two are not the same
08:43:04 <SamB> (otherwise it would need extra boxing)
08:43:12 <dcoutts> there's a difference in strictness & representation
08:43:23 <hyrax42> ohh i's more a low-level thing then?
08:43:30 <jgrimes> so like, one function is Word8 -> Bool, another is Int -> Bool, and I want a function that checks them all that is like (Num a => a -> Bool)
08:43:34 <SamB> hyrax42: very slightly
08:43:39 <dcoutts> hyrax42, there's also a theoretical explanation
08:44:06 <dgoldsmith> If people want to find out more about Unicode text processing, I'd be happy to point at resources for learning. The whole standard is pretty much online at http://www.unicode.org/
08:44:32 <hyrax42> jgrimes:
08:44:35 <SamB> it is still quite high-level, the low-level stuff is just the *motivation* and a suggested implementation (which is easiest and most efficient)
08:44:36 <hyrax42> @docs Data.Bits
08:44:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
08:44:51 <hyrax42> hm
08:44:52 <SamB> however, the low-level stuff is also easier to understand in *this* case
08:45:02 <SamB> because strictness is so confusing...
08:45:02 <hyrax42> ok I will consider reading such motivatio at a later date
08:45:21 <hyrax42> for now I will just use a data declaration
08:45:31 <SamB> excellent choice
08:45:31 <jgrimes> oh, Integer has an instance for Bits
08:45:33 <jgrimes> didn't know that
08:45:55 <SamB> okay, so maybe the high-level interpretation isn't *hard* exactly...
08:45:59 <SamB> jgrimes: yeah
08:46:16 <SamB> it is considered to have infinitely many bits
08:46:26 <jgrimes> oh..
08:46:28 <jgrimes> hm
08:46:38 <hyrax42> just it has to do wth subtleties of strictness/laziness
08:46:39 <hyrax42> ?
08:46:42 <SamB> so, don't try to find its bitwidth
08:46:58 <SamB> hyrax42: the whole point is a bit low-level, I suppose
08:47:06 <jgrimes> right, so how could I find the bitwidth of an integer... :p
08:47:10 <jgrimes> Integer, that is
08:47:19 <SamB> well, not the whole point
08:47:25 <hyrax42> jgrimes, log base 2?
08:47:30 <SamB> hyrax42: compare it "newtype" to "type"
08:47:35 <SamB> er, s/it //
08:47:44 <hyrax42> yeah I realised that sort of
08:48:00 <hyrax42> when I though to try data went and deleted new and turned out it *wasn't* newdata ;)
08:48:10 <SamB> the *real* point of newtype is to give you a new type
08:48:19 <jgrimes> hyrax42, I suppose, I really wanted it to just do that automatically
08:48:21 <jgrimes> hyrax42, thanks
08:48:52 <SamB> so that the typechecker will complain if you conflate it with the old one, and so that you can give it new instances
08:49:05 <hyrax42> kk
08:49:10 <beschmi> are there any known problems compiling ghc head with a recent snapshot (about 2 weeks old)?
08:49:18 <hyrax42> thanks for the motivation
08:49:23 <SamB> without having any qualms about efficiency
08:49:53 <beschmi> when i tried it 2 weeks ago, ghc compiled fine but there were some problems with ghci. so i i compiled with 6.4.x
08:50:36 <Igloo> Compiling with snapshots isn't supported
08:51:02 <Igloo> (apart from compiling a snapshot with itself)
08:51:14 <SamB> Igloo: is that even supported?
08:51:38 <SamB> what if the snapshot is broken?
08:52:05 <Igloo> Then that's a bug htat needs to be fixed
08:52:23 <beschmi> ok, then i compile with 6.4 first like the last time
08:53:39 <hyrax42> @index fix
08:53:39 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
08:53:45 <hyrax42> :t fix
08:53:48 <hyrax42> @type fix
08:53:49 <SamB> Igloo: well, what if it was fixed already?
08:53:53 <lambdabot> forall a. (a -> a) -> a
08:53:55 <hyrax42> @type repeat
08:53:57 <lambdabot> forall a. a -> [a]
08:54:03 <hyrax42> @type iterate
08:54:05 <lambdabot> forall a. (a -> a) -> a -> [a]
08:54:22 <Igloo> SamB: Then rejoince and be happy!
08:54:44 <SamB> perhaps I'm misapprehending the meaning of "support"
08:54:55 <Igloo> SamB: There could equally be a bug in 6.4.2 that means it can't build itself (with gcc 4, say)
08:56:19 <SamB> mmm
08:56:31 <SamB> well, 6.4.2 hardly qualifies as a snapshot...
08:56:31 <dcoutts_> Igloo, perhaps the build should check if it's being built with a snapshot of ghc other than itself and complain. Lots of people seem to make that mistake.
08:56:39 <SamB> it is a *release*
08:56:51 <roconnor> @type guard
08:56:53 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:57:01 <SamB> dcoutts_: it shouldn't complain too loudly
08:57:09 <dcoutts_> SamB, why not ?
08:57:13 <SamB> or, well, maybe it should just say that this is "unsupported"
08:57:24 <SamB> and ask "are you sure?
08:57:26 <dcoutts_> stops people shooting themselves in the foot
08:57:31 <dcoutts_> interactive is bad
08:57:35 <SamB> mmm
08:57:48 <roconnor> :type sequence
08:57:53 <roconnor> @type sequence
08:57:53 <SamB> it doesn't seem much worse than failing right off
08:57:54 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
08:58:11 <dcoutts_> SamB, interactive build systems cannot be automated
08:58:16 <hyrax42> jgrimes, width = ((length . (takeWhile (>0))) . (iterate (`div` 2)))
08:58:17 <SamB> true...
08:58:17 <roconnor> > sequence [[1,2,3],[4,5,6]
08:58:18 <lambdabot>  Parse error
08:58:20 <roconnor> > sequence [[1,2,3],[4,5,6]]
08:58:24 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:58:27 <dcoutts_> SamB, try making an ebuild for an interactive build system. :-)
08:58:28 <beschmi> i've known that it's unsupported, just asked because 6.6 is going to be releases soon and i thought the 6.6 release would be compiled with 6.6
08:58:38 <hyrax42> > let width = ((length . (takeWhile (>0))) . (iterate (`div` 2))) in width 10
08:58:39 <SamB> well, there could be the --I-am-a-idiot configure argument ;-)
08:58:40 <lambdabot>  4
08:58:53 <hyrax42> > let width = ((length . (takeWhile (>0))) . (iterate (`div` 2))) in width 255
08:58:55 <lambdabot>  8
09:00:01 <roconnor> @hoogle guard
09:00:02 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
09:00:02 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
09:00:02 <lambdabot> Language.Haskell.TH.Guard :: data Guard
09:00:27 <Igloo> beschmi: If the 6.6 branch can't build itself now then that's a problem, but I'm not sure if an older snapshot not being able to build it represents a real problem or not OTTOMH
09:01:08 <beschmi> ok, thanks for the clarification
09:01:51 <jgrimes> hyrax42, that works
09:02:36 <syntaxfree> what is the syntax for qualified names for infix operators?
09:02:38 <hyrax42> jgrimes, I just worried that log will return a float of some kind, and you could end up losing precision on *huge* numbers
09:02:39 <jgrimes> hyrax42, I was just going to use 'getBits = ceiling $ logBase 2'
09:02:51 <syntaxfree> variations of "a `Diag.(\\)` b = a `Set.(\\)` b" don't seem to be working.
09:02:52 <jgrimes> hyrax42, true
09:03:18 <hyrax42> but *huge* probably outside the realm of what you'd want it for
09:03:36 <jgrimes> hyrax42, right
09:04:01 <syntaxfree> you could use some search procedure instead of log.
09:04:02 <Igloo> syntaxfree: a Diag.\\ b
09:04:14 <jgrimes> hyrax42, but I do want arbitrary precision, so I suppose I should probably go with your solution
09:04:21 <syntaxfree> once you have an estimate (via log) of what the number is, try the numbers close to it.
09:04:31 <hyrax42> jgrimes, and efficiency be damned!
09:04:43 <jgrimes> hyrax42, of course :)
09:04:57 <syntaxfree> Igloo: that doesn't work either.
09:05:02 <syntaxfree> >       a Diag.\\ b = a Set.\\ b
09:05:03 <lambdabot>  Parse error
09:05:13 <dozer> mm - got an error I've not seen before
09:05:14 <roconnor> > do { let True=False; return 5}::[Int]
09:05:16 <lambdabot>  Parse error
09:05:18 <syntaxfree> (I didn't mean to send that to lambdabot)
09:05:20 <dozer> Cycle in type synonym declarations
09:05:29 <syntaxfree> diag.lhs:59:9: Qualified name in function definition: Diag.\\
09:05:30 <Igloo> syntaxfree: You can't define qualified names
09:05:37 <roconnor> > (do { let True=False; return 5})::[Int]
09:05:38 <lambdabot>  Parse error
09:05:43 <hyrax42> roconnor, you can't define a type constructor
09:05:45 <syntaxfree> I'm in module Diag.
09:05:46 <syntaxfree> >       a \\ b = a Set.\\ b
09:05:48 <lambdabot>  Parse error
09:05:56 <hyrax42> variables must begin with lower case
09:05:57 <syntaxfree> diag.lhs:43:27:
09:05:58 <syntaxfree>     Ambiguous occurrence `\\'
09:05:58 <syntaxfree>     It could refer to either `Diag.\\', defined at diag.lhs:41:7
09:05:58 <syntaxfree>                           or `Data.Set.\\', imported from Data.Set at diag.lhs:8:1-22
09:06:11 <roconnor> hydrax I'm trying to pattern match in a let binding.
09:06:18 <Igloo> Have you imported Data.Set unqualified?
09:06:29 <syntaxfree> > import Data.Set as Set
09:06:30 <lambdabot>  Parse error
09:06:36 <Igloo> Yes, then
09:06:45 <Igloo> You need a "qualified" after "import"
09:06:50 <dcoutts_> syntaxfree, import qualified Data.Set as Set
09:06:51 <syntaxfree> what does that mean?
09:07:25 <dmhouse> ndm: ping
09:07:30 <dcoutts_> syntaxfree, without the qualified, it imports everything unqualified
09:07:31 <Igloo> That it will only bring the qualified (i.e. starting with Set.) names into scope
09:07:42 <ndm> dmhouse: pong
09:07:47 <syntaxfree> oh.
09:07:59 <syntaxfree> God, I'll have to fix some other lines for that.
09:08:11 <dcoutts_> syntaxfree, you can always reffer to a name qualified, ie Data.Set.//, the 'as' changes what the qualified bit is
09:08:29 <dmhouse> ndm: thanks for your response to my email earlier, I successfully installed MinHugs onto my memory stick :)
09:08:29 <dcoutts_> syntaxfree, so import Data.Set as Set means you can use Set.// or //
09:08:31 <hyrax42> but I think you can combine qualified and non-qualified imports, right
09:08:37 <roconnor> > do {let a=False; return 5}::[Int]
09:08:38 <dmhouse> ndm, but I can't figure out how to load more than one module at once.
09:08:38 <lambdabot>  Parse error
09:08:41 <roconnor> grrr
09:08:50 <dcoutts_> syntaxfree, then with qualified you only get the qualified names, ie only Set.// and not //
09:09:05 <SamB> dmhouse: you load a top module and use :m to switch namespaces?
09:09:32 <SamB> (note that you are within the module scope)
09:09:36 <syntaxfree> thanks!
09:09:41 <syntaxfree> > newtype Measure = M Float deriving (Eq, Show, Ord)
09:09:42 <lambdabot>  Parse error
09:09:51 <syntaxfree> > data Event a = (Probabilistic a, Measurable a) => ES a Measure
09:09:52 <lambdabot>  Parse error
09:10:08 <syntaxfree> oh god. Lambdabot + LHS.
09:10:16 <syntaxfree> diag.lhs:48:54:
09:10:17 <syntaxfree>     Kind error: `a' is not applied to enough type arguments
09:10:17 <syntaxfree>     In the data type declaration for `Event'
09:10:17 <syntaxfree> Failed, modules loaded: none.
09:10:23 <syntaxfree> (I should use the paste bin)
09:10:25 <dmhouse> Say, for example, I want to execute nubBy (\x y -> isLower x == isLower y) "hello"
09:10:33 <dmhouse> I'll need both Data.List and Data.Char in scope.
09:10:35 <ndm> dmhouse: no idea really, but its a property of Hugs, not WinHugs, so email hugs-users or hugs-bugs
09:10:50 <ndm> dmhouse: or create a module Data.Both, which imports and exports both modules
09:10:52 <SamB> dmhouse: so, if you want to use several modules together, you can just write a module that imports them and load that...
09:11:05 <SamB> it doesn't need to export them
09:11:15 <dmhouse> You're kidding, this can't be done solely from the Hugs prompt?
09:11:21 <dmhouse> ndm, okay, thanks for your help.
09:11:31 <Igloo> You can do it in ghci. I never understood hugs' commands
09:11:34 <SamB> if you are actually working on something you can just add the imports to that!
09:11:58 <dmhouse> SamB, true. I'd still expect it to work, though, and the User Manual indicates it should.
09:12:02 <ndm> dmhouse: never felt the need to do it, but it might be possible - i don't understand :l vs :m vs :a - a mailing list message might clear it up though
09:12:05 <SamB> dmhouse: hmm?
09:12:11 <SamB> indicates that what should work?
09:12:20 <SamB> :l actually loads code
09:12:27 <SamB> :m switches between loaded modules
09:12:31 <SamB> oh, I forgot about :a
09:12:38 <syntaxfree> ghci has an "it" implicit variable.
09:12:41 <SamB> I don't remember how that works...
09:12:42 <Igloo> SamB: What's the hugs equivalent of ghci's  :m + Module   ?
09:12:55 <dmhouse> Describing :load: "Clear all files except the empty module Hugs, the Haskell 98 Prelude and modules it uses, and then load the specified files or modules (if any). The last module loaded becomes the current module."
09:12:57 <syntaxfree> that alone makes it worth.
09:12:59 <dmhouse> Igloo, :also, I think.
09:13:18 <dmhouse> That description makes it seem like I should be able to specify multiple modules and have them all loaded
09:13:29 <dmhouse> Perhaps 'load' doesn't mean 'bring names into scope'.
09:13:33 <SamB> dmhouse: sure
09:13:34 <syntaxfree> I wish ghci's error messages could be changed so I can unleash it on nontechnical users with a DSL defined in a module.
09:13:39 <Igloo> dmhouse: Nope
09:13:44 <SamB> dmhouse: indeed
09:13:52 <Igloo> Data.Bits> :t shiftL
09:13:52 <Igloo> shiftL :: Bits a => a -> Int -> a
09:13:52 <Igloo> Data.Bits> :also Data.Word
09:13:52 <Igloo> Data.Word> :t shiftL
09:13:52 <Igloo> ERROR - Undefined variable "shiftL"
09:13:54 <SamB> only the last one is brought into scope
09:14:03 <SamB> ("the current module")
09:14:22 <syntaxfree> ghci needs a windows GUI.
09:14:25 <dmhouse> Right.
09:14:31 <SamB> :also seems to be like :load without the clearing
09:14:38 <dmhouse> syntaxfree, it does, I'd use it if it had one.
09:14:38 <syntaxfree> A  minimal one like WInHugs or Pythonwin, etc.
09:15:11 <syntaxfree> dmhouse: I want nontechnical users to use it with a DSL defined in a module.
09:15:29 <syntaxfree> But they're afraaaaaaaid of teh black screen, and the windows terminal has bad copy-and-paste behaviour.
09:15:36 <SamB> yeah
09:15:36 <dmhouse> Yeah.
09:15:50 <SamB> I hate the latter more than the former, which I think is configurable somehow anyway
09:15:54 <dmhouse> syntaxfree: import GHC?
09:16:10 <SamB> dmhouse: ... what?
09:16:42 <dmhouse> Import GHC's parser and write a simple REPL, so you get to control the errors yourself.
09:17:29 <SamB> oh hmm
09:17:36 * SamB is happy
09:18:40 <SamB> ndm: did you hear that I finished newtyping Id?
09:19:07 <ndm> SamB: nope, well done :)
09:19:07 <dozer> m  s
09:19:24 <ndm> SamB: ready to commit it yet?
09:19:28 <dozer> m still got my cycle in type synonym problem
09:19:42 <ndm> syntaxfree: i'm working on a GUI for GHi, see GuiHaskell
09:19:46 <ndm> @where GuiHaskell
09:19:46 <roconnor> is there a non-deterministic state monad?
09:19:47 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
09:19:47 <SamB> what is the account name?
09:20:11 <ndm> SamB: you can't commit yet, we're still waiting on Simon Marlow for some bits and pieces
09:20:18 <SamB> ah
09:20:20 <ndm> SamB: I can commit though, so send it via me
09:20:30 <ndm> basically, everyone is goign to be multiplexing via my account
09:20:46 <ndm> we've set up a bit of it, but not all of it
09:21:12 <SamB> okay, well, I don't know if you'll want to commit everything directly...
09:21:36 <SamB> especially the Core and ByteCode parts...
09:21:48 <ndm> how do you mean?
09:22:06 <SamB> well, maybe at least send copies to the list first...
09:22:18 <SamB> the stuff in there is screwy
09:22:22 <ndm> what changed in the Core?
09:22:29 <ndm> there weren't any id's there anyway
09:23:01 <SamB> well.
09:23:13 <SamB> the typechecker wanted there to be.
09:23:30 <ndm> Core isn't that screwy either, i'm pretty sure, since i rewrote it all myself
09:23:34 <roconnor> @hoogle s -> [(s,a)]
09:23:35 <SamB> actually the nasty stuff isn't there
09:23:36 <lambdabot> Data.FiniteMap.fmToList_GE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
09:23:36 <lambdabot> Data.FiniteMap.fmToList_LE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
09:23:53 <ndm> SamB: just send the email, then i'm sure i'll figure out what you mean
09:23:56 <SamB> and the screwy stuff didn't look screwy before I came along
09:24:29 <SamB> okay, ByteCode.Compile has some
09:24:38 <SamB> there are other places too
09:25:07 <SamB> (you'll see toEnum and fromEnum in any of those places, and in some that aren't nasty too...)
09:25:23 <SamB> well, and/or
09:25:47 <ndm> SamB: send me the patch, then can you explain it
09:26:17 <fasta> The trivial difference list library is GPLV2. If one reimplements that interface one is bound to get the exact same program. How can you ever "prove" that you did reimplement it?
09:26:51 <SamB> fasta: eh?
09:26:55 <fasta> http://www.archivesat.com/Haskell_libraries/thread452730.htm
09:26:58 <SamB> oh.
09:27:00 <lambdabot> Title: inits, http://tinyurl.com/jhv84
09:27:05 <SamB> you mean like
09:27:17 <SamB> type DList a = [a] -> [a]
09:27:23 <SamB> etc etc?
09:27:23 <fasta> SamB: right
09:27:42 <ndm> SamB: ok, those bits in Core are relatively trivial, and in the convertor - so thats ok
09:27:50 <SamB> don't worry about being sued or anything
09:27:57 <SamB> no Haskell user would be crazy enough to do that
09:28:28 <SamB> yeah, I forgot where the nasties were
09:28:33 <SamB> Core has none
09:29:03 <fasta> IIRC the FSF thinks that the _interface_ is a copyrighted work too.
09:29:20 <fasta> Not that I think that what the FSF says is always true....
09:29:27 <ndm> SamB: so what benefits does having a newtype bring us, other than type safety?
09:29:49 <SamB> ndm: better signatures
09:29:58 <SamB> and isn't type safety important?
09:31:01 <ndm> SamB: yep, does it require much code changes? I haven't seen many
09:31:12 <norpan> what do _types_ gives us except type safety?
09:31:24 <ndm> and yes, type safety is well worth it - i was just wondering if you'd m anaged to get extra benefits like overloading/classes etc.
09:31:50 <Maddas> norpan: better signatures
09:31:52 <SamB> ndm: only a few of em
09:31:54 * Maddas coughs :-)
09:31:59 <norpan> Maddas: you can write signatures anyway
09:32:18 <norpan> anyway
09:32:21 <norpan> time to go
09:32:24 <Maddas> norpan: If you don't have types, you can't have any type errors!
09:32:30 <Maddas> Bye!
09:32:46 <SamB> if you don't have types ... how do you know what to put in the signatures?
09:32:50 <ndm> succ is nicer than +1 anyway, yep, that patch looks good
09:33:09 <SamB> hmm
09:33:15 <SamB> oooo
09:33:20 <SamB> I have a cool idea ;-)
09:33:34 <ndm> go on...
09:33:52 <SamB> for the 'IdSupply' thing
09:35:13 <SamB> class IdSupply state where getUniqueId :: State a state Id state
09:35:34 <ndm> i'll be honest, i don't have a clue about any of the ID plumbing
09:35:56 <ndm> but sounds reasonable
09:36:25 <ndm> if you're happy with this patch, can you send it to yhc@, so Tom can take a brief look,
09:36:26 <SamB> yeah, each kind of pseudo-monad has its FooState type
09:36:35 <SamB> I had sent it
09:36:42 <ndm> moving towards some structured monads would make everyone smile :)
09:36:45 <SamB> but canceled because it was being held for hugeness
09:37:01 <ndm> do you have some web space to dump it in?
09:37:10 <SamB> mmm
09:37:20 <ndm> i have some if you don't
09:37:26 <ndm> or if thats easier for you
09:37:34 <SamB> how about you commit the patches named like "Id/Int in Foo"
09:37:34 <araujo> hi hi!
09:37:35 <ndm> or a simple gzip might make it small enough
09:37:43 <SamB> and then I send the rest to the list
09:37:49 <SamB> those should be just sigs
09:37:54 <SamB> maybe doc comments
09:38:10 <ndm> won't Id/Int depend on the introduction of the newtype Id ?
09:38:16 <SamB> nope
09:38:19 <SamB> it was a type before
09:38:41 <SamB> all that does is switch them around in type signatures that had the "wrong" one
09:38:50 <ndm> ok, fair enough, thats a good plan
09:39:08 <SamB> likely what is left will fit by
09:39:32 <SamB> any others that don't mention newtype Id should be okay, too...
09:39:52 <ndm> actually, it looks pretty solid
09:40:03 <ndm> so you made the Id type an instance of Enum to get all the behaviour as before?
09:40:41 <ndm> i will probably just commit it as is, it looks ok
09:41:51 <SamB> not *all*, but it had the handy toEnum and fromEnum, and succ was useful too ;-)
09:42:31 <ndm> yep, looks good
09:42:38 <SamB> I would at least like if you'd copy the wierd parts to the list first...
09:43:00 <ndm> SamB: if it still works, just add a comment "gone weird" and someone will come back to it later
09:43:13 <ndm> you're probably the expert on Id's in the compiler now :)
09:43:17 <SamB> hmm
09:43:21 <SamB> I actually am no expert
09:43:43 <ndm> are you meaning the ByteCode.Compile stuff mainly?
09:43:49 <SamB> I guess so
09:44:17 <ndm> ok, well thats Tom's area
09:44:25 <SamB> oh, RenameLib has an even worse bit...
09:44:27 <ndm> just send the diff to the mailing list asking the details
09:45:24 <syntaxfree> quoth ndm: "syntaxfree: i'm working on a GUI for GHi, see GuiHaskell"
09:45:25 <ndm> RenameLib? Looks just a simple translation to me?
09:45:26 <syntaxfree> cool!
09:45:48 <SamB> ndm: um, look at localTid
09:46:51 <SamB> also defineInstMethod, but someone else saw that one first
09:47:13 <ndm> @where GuiHaskell
09:47:18 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php
09:47:21 <ndm> syntaxfree: ^^^ thats the link
09:48:58 <ndm> SamB: it might not make sense, but its just a direct translation of the original, right?
09:49:25 <SamB> sure
09:49:35 <SamB> but I *still* think nonsensical things need attention
09:49:53 <SamB> that is another good thing about major type breackage ;-)
09:49:55 <ndm> syntaxfree: if you bug dcoutts and JaffaCake lots they might fix the Gtk2Hs + threading + Windows bugs, which means i can release GuiHaskell
09:50:06 <SamB> or even breakage
09:50:07 <dcoutts_> sigh
09:50:21 <ndm> dcoutts_, am just signing up people to pester you ;)
09:50:29 <dcoutts_> yeah, so I see :-)
09:50:53 <ndm> am going to be demoing a Gtk2Hs app on thursday in front of an audience
09:50:57 <dcoutts_> ndm, cool
09:51:01 <ndm> if it doesn't work, will be blaming you :)
09:51:03 <glguy> is there a good way to define a reads function that reads things across multiple lines?
09:51:08 <dcoutts_> ndm, hah hah hah
09:51:29 <dcoutts_> ndm, I'm doing another GUI practical this term, with 3D and everything :-)
09:51:41 <ndm> on Windows, with threading ;)
09:51:50 <dcoutts_> ndm, Gtk2Hs + HOpenGL, on Slowaris
09:52:22 <dcoutts_> ndm, we'll have to bug JaffaCake after 6.6 is out
09:52:42 <ndm> yeah, i know
09:52:56 <ndm> am currently trying to bug the GHC installer into submission, but not getting very far
09:53:13 <syntaxfree> > head []
09:53:14 <lambdabot>  Add a type signature
09:53:20 <glguy> is there any chance that this will fuse: sum (zipWith (*) a b)?
09:53:22 <syntaxfree> > head []::Int
09:53:24 <lambdabot>  Exception: Prelude.head: empty list
09:53:45 <syntaxfree> glguy: vector multiplication? :)
09:53:51 <glguy> syntaxfree: dot product
09:53:54 <glguy> but yet
09:53:55 <glguy> yeah
09:54:00 <syntaxfree> yes, yes.
09:54:18 <glguy> or is: dot (x:xs) (y:ys) z = dot xs ys $! (z + x * y); dot _ _ z = z beter?
09:54:20 <syntaxfree> even in mathematics, there's some of a language barrier for me.
09:54:49 <syntaxfree> I bet there's an "Evolution of a Haskell programmer" waiting to be written for dot products.
09:54:57 <ndm> glguy: no, zipWith isn't a good fuzer, unless you have hylomorphic fusion
09:55:05 <syntaxfree> I'm thinking of a funny continuation version right now.
09:55:15 <xerox> glguy: dot = sum . foldr (uncurry (*)) 1 . zip
09:55:22 <xerox> :D
09:55:26 <xerox> Err, not exactly.
09:55:33 <glguy> you need more (.) s
09:55:34 <xerox> glguy: dot = (sum . foldr (uncurry (*)) 1 .) . zip
09:55:35 <syntaxfree> glguy: that doesn't check that lists have the same size anyway.
09:55:41 <xerox> More or less .p
09:55:53 <glguy> syntaxfree: same size isn't my problem :-p
09:55:57 <xerox> Another pair of parens needed
09:56:09 <syntaxfree> it isn't?
09:56:40 <glguy> syntaxfree: besides, the dot _ _ z could be easily extended to add two cases for one list is null and teh other isn't
09:56:44 <glguy> but I'm not concerned about that
09:58:04 <glguy> > let curious a b c = a + b + c in 1 `curious` 2 3
09:58:06 <lambdabot>  add an instance declaration for (Num (t -> a))
09:58:09 <glguy> :(
09:59:00 <glguy> > let curious a b c = a + b + c in 1 `curious` 2
09:59:01 <lambdabot>  Add a type signature
09:59:03 <Phillemann> Does pattern matching match (x:xs) against [x]? I'm thinking of x:[].
09:59:12 <glguy> Phillemann: correct
09:59:18 <ktne> hello
09:59:34 <Phillemann> glguy: Okay.
09:59:36 <ktne> i'm using ghci under win32 and i'm testing a small fibbonaci tutorial
09:59:58 <ktne> i've loaded the test program and i've checked the process memory status and it seems to eat about 25Mb
10:00:00 <ktne> is this normal?
10:00:04 <glguy> ktne: 250 #haskell Welcome n=ktne@unaffiliated/ktne
10:00:34 <ktne> glguy ?
10:00:42 <glguy> ktne: 500 Command not recognized
10:00:51 <ktne> what command?
10:00:58 <glguy> ktne: 500 Command not recognized
10:01:14 <dcoutts_> ktne, ghci needs a bunch of stuff for itself, if you're concerned with memory usage you can check the requirements of a standalone version
10:01:38 <syntaxfree> I want OS X Hoogle!
10:01:45 <ktne> dcoutts i'll try to compile this stuff
10:01:48 <dcoutts_> ktne, ie compile your code into a standalone .exe
10:02:54 <kicked_by_impera> learning haskell -- school of expression
10:03:14 <glguy> )-: no one tried any SMTP commands on me
10:04:05 <ktne> i get this error: test.hs:23:0: parse error (possibly incorrect indentation) when i try to compile
10:04:35 <ndm> syntaxfree: XHoogle already exists, its somewhere
10:04:37 <ktne> hmm
10:04:42 <ktne> how do i run something in haskell?
10:04:57 <ktne> so far i've loaded the functions from ghci and run the code manually
10:05:07 <ktne> do i define a main function or something?
10:05:10 <ndm> syntaxfree: and if you tell me exactly what OS X Hoogle is, i'll make sure its there
10:05:12 <ktne> because i can
10:05:15 <ktne> can
10:05:25 <ktne> can't find this in the tutorial
10:05:32 <syntaxfree> http://www-users.cs.york.ac.uk/~ndm/projects/hoogle.php
10:05:36 <lambdabot> Title: Neil Mitchell - Hoogle, http://tinyurl.com/ebl2v
10:05:40 <syntaxfree> ;)
10:05:44 <SamB> ktne: exactly!
10:05:49 <SamB> a main function
10:05:57 <glguy> ndm: that's yours... right?
10:06:02 <ktne> SamB what's the name of the main function? and what type does it require?
10:06:03 <ndm> syntaxfree: ah, yep, it did exist, and i';ve seen screen shots but never got the code
10:06:06 <ndm> glguy: yep
10:06:08 <SamB> main :: IO ()
10:06:15 <ktne> hmm
10:06:25 <dmhouse> SamB: actually, main :: IO a
10:06:35 <glguy> ndm: looks like someone needs clarification on your tutorial ;)
10:06:35 <dmhouse> Well, main :: exists a. IO a
10:06:44 <ndm> glguy: which tutorial?
10:06:49 <SamB> dmhouse: actually I don't think that is standard...
10:06:52 <dmhouse> (It's monomorphic, but you're allowed to return any type you like.)
10:07:00 <glguy> ndm: nevermind
10:07:06 <glguy> ndm: two IRC lines ran together for me
10:07:07 <araujo> afaik, main :: IO a is for ghc6.6?
10:07:07 <SamB> anyway, IO () works fine!
10:07:09 <dmhouse> SamB: oh, you might be right.
10:07:19 <dmhouse> araujo: works before that IIRC.
10:07:20 <SamB> araujo: I think it works in earlier versions too
10:07:22 <ktne> SamB thank but how do i keep the main function from quitting?
10:07:28 <araujo> SamB, ok
10:07:32 <ktne> i need some sort of way_for_key
10:07:46 <glguy> getLine works
10:07:51 <ktne> thanks
10:07:58 <SamB> you on windows ? ;-)
10:08:16 <ktne> SamB i'm running it in console but the thing is that i want to see memory consumption in tasklist
10:08:22 <SamB> ah
10:08:38 <ktne> yes i'm running on windows
10:08:39 <ktne> (xp)
10:08:56 <resiak> Is there a standardish matrix library, or does everyone just write functions manipulating lists of lists of ... of lists ?
10:09:16 <SamB> that would be a reasonable reason to want to do that on any system, though (if you replace "task list" with a more platform-appropriate tool)
10:09:20 <ktne> how do i use getLine"?
10:09:24 <dmhouse> resiak: an instance Num a => Num [[a]] is trivial, IIRC.
10:09:39 <dmhouse> resiak: google for one or search the wiki, someone's likely done a good enough job already.
10:09:40 <SamB> do putStrLine "hello"
10:09:43 <ktne> i try putStrLn (getLine) but i get an error
10:09:43 <SamB>    getLine
10:09:50 <SamB> or
10:09:53 <dmhouse> SamB: *putStrLn
10:09:55 <ktne> getLine has type :: IO String
10:09:59 <SamB> er, yeah.
10:10:05 <dmhouse> "Put String Natural Log"
10:10:08 <roconnor> how do mzero and fail relate?
10:10:12 <SamB> hehe
10:10:20 <resiak> dmhouse: I couldn't find something that looked like anyone's used it!
10:10:30 <SamB> roconnor: fail gives an error message and mzero doesn't
10:10:37 <musasabi> Why is this combination of GADT and a class illegal:
10:10:38 <musasabi> class C a where c :: a
10:10:38 <musasabi> data  D a where D :: C a => D a
10:10:38 <musasabi> d :: D a -> a
10:10:38 <musasabi> d D = c
10:10:43 <dmhouse> roconnor: mzero applies only to MonadPlus, fail to all Monads.
10:10:44 <SamB> or, rather, mzero would give a generic error...
10:11:02 <SamB> I should have said "takes"
10:11:13 <SamB> and, yes, mzero is only for MonadPlus...
10:11:16 <SamB> @type mzero
10:11:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
10:11:18 <musasabi> GHC complains that there is no instance of "C a", but D guarantees that such an instance *does* exist.
10:11:38 <SamB> musasabi: that construction is useless
10:11:41 <dmhouse> > (mzero :: Maybe (), fail "" :: Maybe ())
10:11:42 <lambdabot>  (Nothing,Nothing)
10:11:43 <SamB> they should take that out
10:11:45 <musasabi> SamB: how so?
10:11:46 <dmhouse> They coincide sometimes.
10:11:57 <SamB> musasabi: well, anyway, not very usefull...
10:11:57 <ktne> anyone can help me with getLine?
10:12:08 <dmhouse> > (mzero :: [()], fail "" :: [()])
10:12:08 <lambdabot>  ([],[])
10:12:15 <musasabi> SamB: it would be very useful for me in more complicated for,
10:12:17 <ktne> if i run getLine from ghci it works as expected but putStrLn (getLine) doesn't
10:12:22 <SamB> it maybe checks for an instance, but doesn't store the dictionary!
10:12:28 <SamB> which is worse than useless
10:12:37 <glguy> > map signum [-2..2]
10:12:39 <lambdabot>  [-1,-1,0,1,1]
10:12:40 <dmhouse> I guess fail is useful when you want an identity for mplus.
10:12:44 <dmhouse> *mzero is useful
10:13:00 <SamB> mmm
10:13:06 <dmhouse> fail is useful when you want to give an error message.
10:13:08 <SamB> I would think mzero would work fine too
10:13:16 <SamB> er, fail would work fine too...
10:13:29 <musasabi> hmm. that seems like a bug in the implementation.
10:13:39 <dmhouse> SamB: sure, but you'd have to make up a message.
10:13:41 <roconnor> @quickcheck \x -> mzero == fail x
10:13:43 <lambdabot> Unknown command, try @list
10:13:48 <roconnor> @check \x -> mzero == fail x
10:13:50 <lambdabot>  add an instance declaration for (Eq (m a))     In a lambda abstraction: \ x...
10:14:03 <roconnor> @check \x -> mzero::[] == fail x
10:14:04 <lambdabot>  Parse error
10:14:05 <SamB> musasabi: non-GADTs have the same problem...
10:14:10 <roconnor> @check \x -> (mzero::[]) == fail x
10:14:12 <lambdabot>    `[]' is not applied to enough type arguments     Expected kind `?', but ...
10:14:19 <roconnor> @check \x -> (mzero::[Int]) == fail x
10:14:21 <lambdabot>  OK, passed 500 tests.
10:14:39 <roconnor> @instance MonadPlus
10:14:40 <lambdabot> Maybe you meant: instances instances-importing
10:14:44 <roconnor> @instances MonadPlus
10:14:46 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:15:02 <roconnor> @check \x -> (mzero::Either Int) == fail x
10:15:03 <lambdabot>    `Either Int' is not applied to enough type arguments     Expected kind `...
10:15:16 <SamB> I forget what syntax triggers it, but such trees should be summarily rejected on the grounds that nobody has figured out a *useful* interpretation of that
10:15:23 <dmhouse> ?check \x -> (mzero :: Either Int ()) == fail x
10:15:24 <lambdabot>  add an instance declaration for (MonadPlus (Either Int))     In the express...
10:15:40 <dmhouse> ?check \x -> (mzero :: Either String ()) == fail x
10:15:41 <lambdabot>  add an instance declaration for (MonadPlus (Either String))     In the expr...
10:15:46 <SamB> (rather than giving less than the expected semantics)
10:15:49 <dmhouse> You need to import some extra modules for that.
10:16:05 <roconnor> @type sequenceM
10:16:07 <lambdabot> Not in scope: `sequenceM'
10:16:20 <SamB> hmm
10:16:32 <roconnor> @type mapM
10:16:34 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
10:16:42 <SamB> @instances-importing Control.Monad MonadZero
10:16:42 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
10:16:48 <SamB> @instances-importing Control.Monad MonadPlus
10:16:49 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:16:52 <SamB> hmm
10:16:57 <musasabi> SamB: I am looking at an existential alternative.
10:16:57 <SamB> @instances-importing Numeric MonadPlus
10:16:58 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
10:17:57 <SamB> musasabi: I just think accepting things like that but not having them actually *work* is a great way to frustrate the programmer and waste his/her time...
10:17:58 <roconnor> @hoogle get
10:17:59 <lambdabot> Control.Monad.State.get :: MonadState s m => m s
10:17:59 <lambdabot> Text.ParserCombinators.ReadP.get :: ReadP Char
10:17:59 <lambdabot> Text.ParserCombinators.ReadPrec.get :: ReadPrec Char
10:20:57 <musasabi> hmm. it seems there is a trivial way around that in my scenario.
10:22:08 <glguy> is (1 *) a section?
10:22:28 <musasabi> @type (1 *)
10:22:30 <lambdabot> forall a. (Num a) => a -> a
10:22:37 <musasabi> looks like it.
10:22:44 <glguy> is (* 1)?
10:22:52 <musasabi> @type (* 1)
10:22:54 <lambdabot> forall a. (Num a) => a -> a
10:23:01 <glguy> I thought that there were two different terms
10:23:13 <glguy> One for when the operator came first and one for when it came second...
10:24:07 <musasabi> glguy: see http://www.haskell.org/onlinereport/exps.html#sect3.5
10:24:10 <lambdabot> Title: The Haskell 98 Report: Expressions, http://tinyurl.com/z8ol8
10:24:35 <glguy> oh, they are both sections, just left and right ones
10:28:40 <Johnnn12> Why can't i use this
10:28:42 <Johnnn12> [[n,n,n+n..] | n <- [1..]]
10:29:14 <glguy> Johnnn12: try:
10:29:25 <glguy> [n:[n,n+n..] | n <- [1..]]
10:30:20 <glguy> Johnnn12: yours won't work because [1,1,2..] doesn't mean anything
10:30:58 <Johnnn12> Hehe thanks
10:32:08 <glguy> ?hoogle fromList
10:32:10 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
10:32:10 <lambdabot> Data.IntMap.fromList :: [(Key, a)] -> IntMap a
10:32:10 <lambdabot> Data.IntSet.fromList :: [Int] -> IntSet
10:32:13 <roconnor> How do I make an instance of MonadState!
10:32:26 <glguy> a new instance?
10:32:32 <roconnor> newtype NDS s a = NDS {runNDS :: s -> [(s,a)]}
10:32:47 <roconnor> instance MonadState (NDS s) s
10:32:56 <roconnor> instance Monadstate NDS s
10:33:03 <roconnor> instance Monadstate (NDS s a) s
10:33:06 <roconnor> help?
10:33:13 <glguy> :instances Monad
10:33:15 <glguy> ?instances Monad
10:33:17 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:34:16 <Phillema1n> Woah. Just finished my first "useful" Haskell function. It's really fun. :)
10:34:48 <roconnor> instance MonadState s (NDS s) where
10:34:57 <roconnor> there, finally found a combination that works
10:35:12 <roconnor> I totally don't understand taht
10:35:28 <roconnor> oh I see now
10:35:51 <glguy> class Monad b => MonadState a b | b -> a where
10:40:49 <roconnor> woot
10:40:50 <roconnor> @paste
10:40:52 <lambdabot> http://paste.lisp.org/new/haskell
10:41:31 <lisppaste2> roconnor pasted "repairs" at http://paste.lisp.org/display/27293
10:43:50 <roconnor> @hoogle Maybe a -> m a
10:43:52 <lambdabot> Maybe.fromJust :: Maybe a -> a
10:43:52 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
10:43:52 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
10:44:03 <roconnor> hmmm
10:45:56 <roconnor> :type maybe mzero return
10:46:00 <roconnor> ?type maybe mzero return
10:46:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
10:52:37 <kicked_by_impera> KTNE, there are some good turtorials out there that explain this getLine. I don't think anyone here will do the amount of typing necessary to explain this too you.
10:54:25 <beelsebob> Twigathy: poik
10:54:44 <ktne> kicked_by_impera ok
10:58:37 <Cale> ktne: sorry, what was your original question?
10:58:41 <psi> is the adventure game in UMIX supposed to be crashing?
10:59:06 <Cale> ktne: why does  putStrLn getLine not work?
10:59:19 <Cale> it doesn't work because getLine is not a string
10:59:32 <Cale> it's an action, which you have to run if you want to get a string out of it
10:59:41 <Cale> so you do something like:
10:59:49 <Cale> do x <- getLine; putStrLn x
10:59:56 <Johnnn12> what is difference between [[a,a]] and [(a,a)]
11:00:17 <xerox> Johnnn12: the former is a value, the latter a value or a type, hehe.
11:00:19 <glguy> Johnnn12: [[a,a]] is a list of a list of two values
11:00:36 <glguy> Johnnn12: [(a,a)] is a list containing one tuple
11:01:05 <roconnor> > length (head [[a,a]])
11:01:06 <lambdabot>  Not in scope: `a'
11:01:07 <Cale> @type (\a -> [[a,a]])
11:01:09 <lambdabot> forall a. a -> [[a]]
11:01:11 <roconnor> > length (head [['a','a']])
11:01:13 <lambdabot>  2
11:01:13 <Cale> @type (\a -> [(a,a)])
11:01:14 <lambdabot> forall a. a -> [(a, a)]
11:01:17 <glguy> Johnnn12: as a type definition: [[a,a]] is invalid
11:01:22 <roconnor> > length (head [('a','a')])
11:01:22 <araujo> [[a,a]] doesn't make sense at all ....
11:01:24 <lambdabot>  Couldn't match `[a]' against `(a1, b)'
11:01:32 <glguy> Johnnn12: as a type definition [(a,a)] is a list of tuples
11:01:32 <xerox> araujo: it does, as value.
11:01:35 <araujo> it'd be [[a]] instead
11:01:44 <glguy> araujo: let a = 1 in [[a,a]]
11:01:45 <araujo> xerox, i meant , as a type signarute
11:01:54 <araujo> signature*
11:02:34 <roconnor> this adventure game is hard.
11:02:44 <araujo> roconnor, which one?
11:02:49 <glguy> roconnor: do you know about "help switch"
11:02:57 <roconnor> yep
11:03:00 <glguy> k
11:03:16 <glguy> araujo: the one sealed away inside the Codex
11:03:16 <roconnor> data Sexpr = S String
11:03:16 <roconnor>            | Ss [Sexpr]
11:03:16 <roconnor>            deriving Show
11:03:19 <roconnor> :)
11:03:29 <roconnor> lots of Ss
11:03:59 <araujo> glguy, mm ..
11:04:17 <glguy> ?google icfp 2006 programming contest
11:04:20 <lambdabot> http://icfpcontest.org/
11:04:20 <lambdabot> Title: ICFP Programming Contest, 2006
11:04:24 <araujo> oh right
11:04:42 <roconnor> I am standing at the corner of 54th Street and Harper Avenue.  And I have a big mess in front of me :/
11:04:46 <Johnnn12> Whats problem here?
11:04:47 <Johnnn12> pairs [x]        = [(head x, head(tail x))] ++ pairs (tail x)
11:04:55 <Johnnn12> -- pairs [1..6]   ==> [(1,2),(2,3),(3,4),(4,5),(5,6)]
11:05:02 <glguy> pairs [x] only matches a list containing one element
11:05:39 <glguy> you want: pairs (x:xs) = (x, head xs) : pairs xs
11:05:52 <glguy> or probably
11:06:04 <xerox> Johnnn12: since list are constructed as (x:xs), you can pattern-match the (:) constructor in the same way, getting the `head' in x, and the `tail' in xs.
11:06:10 <glguy> you want: pairs (x:x':xs) = (x, x') : pairs (x':xs)
11:06:16 <psi> roconnor: Is adventure supposed to be crashing? I'm asking because a friend said it didn't for him.
11:06:19 <xerox> > (\(x:xs) -> x) [1..6]
11:06:21 <lambdabot>  1
11:06:24 <xerox> > (\(x:xs) -> xs) [1..6]
11:06:26 <lambdabot>  [2,3,4,5,6]
11:06:30 <SamB> hmm, is Yhc's bytecode documented somewhere?
11:06:31 <roconnor> adventure hasn't crashed on me
11:06:31 <glguy> psi: I don't think that any of the UMIX programs are supposed to crash
11:06:44 <psi> That's really weird.
11:06:51 <roconnor> could be your VM
11:06:57 <psi> I have even tried his VM, it still crashes.
11:07:07 <SamB> psi: how's your swap?
11:07:21 <roconnor> adventure take like 340 Megs for me
11:07:23 <psi> the actual VM, or UMIX doesn't crash
11:07:30 <psi> it just drops me back to the UMIX prompt
11:07:32 <roconnor> it's totally insane
11:08:01 <psi> yeah, i noticed it took like 30% of my memory
11:08:35 <SamB> oh
11:08:45 <SamB> huh
11:09:02 <psi> let me get the message...
11:09:23 <SamB> I suppose it was an intended failure mode, if it didn't segfault the VM ;-)
11:09:49 <SamB> now whether it is ever supposed to go into that mode...
11:10:33 <psi> >: inc pamphlet
11:10:33 <psi> Adventure BUG: Subscript
11:10:33 <psi> %
11:10:38 <glguy> > let pairs = ap (zipWith (\a b -> (head a, head b))) tail . init . tails in pairs [1..6]
11:10:41 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
11:10:54 <SamB> hmm, definately a bug in something adventure-related
11:11:01 <SamB> have you got the uploader yet?
11:11:07 <glguy> > [(a,b) | (a:b:_) <- tails [1..6]]
11:11:10 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6)]
11:11:25 <roconnor> psi: I suppose you could report the bug
11:11:36 <psi> SamB: hm, uploader?
11:11:44 <psi> I have used umodem.
11:11:49 <SamB> psi: if you don't know what I mean that means "no"
11:11:58 <psi> ok :)
11:12:14 <SamB> suffice to say that it is an item later on in adventure ;-)
11:12:57 <psi> what's specific to me in this? my encryption key - could that have anything to do with it?
11:13:12 <SamB> who knows!
11:13:15 <psi> I'm going to try with another.
11:13:27 <SamB> include that and the exact sequence of commands, I guess...
11:13:43 <ValarQ> hej psi
11:14:12 <SamB> so that someone could paste the sequence of commands into the decrypted UM and get the bug
11:14:45 <psi> ValarQ: hi
11:17:23 <roconnor> psi: which codex are you using?  did you extract it yourself?
11:17:37 <psi> yes
11:17:47 <psi> I'm extracting a new one with a different key now.
11:17:55 <roconnor> also, if you take the pamplet and take the manifesto, and inc the manifesto, does it still crash?
11:18:20 <psi> I think so, but I'll have to check.
11:18:31 <roconnor> you get points for burning something
11:18:41 <psi> I remember that it worked once.
11:18:43 <roconnor> So i would guess it is that that is breaking.
11:18:58 <psi> Perhaps when it worked I did it in some specific sequence.
11:22:21 <psi> roconnor: it crashes in that order as well
11:22:36 <roconnor> where did you get the decryption key from?
11:23:12 <psi> I got mine from registering, the other one a friend gave me
11:23:34 <roconnor> very odd
11:23:53 <psi> heh, this must be a very subtle bug
11:24:13 <roconnor> Have you used the guest account?
11:24:26 <psi> yes
11:24:35 <SamB> roconnor: like, duh...
11:24:51 <lispy> is there a way to convince cabal to try installing both profiled and non-profiled versions at the same time?
11:24:59 <roconnor> maybe psi just got passwords from someone :)
11:25:06 <lispy> i get tired of installing things then later realizing i need to install the profiled build
11:25:20 <roconnor> indeed it seems like a strange bug in adventure
11:25:24 <psi> roconnor: nah ;)
11:25:24 <stepcut> Does GHC having anything similar to MVar, that I can use for parent<->child communication after a forkProcess ?
11:25:32 <roconnor> I hope your other key make it work!
11:25:38 <psi> roconnor: it didn't
11:25:40 <roconnor> oh
11:25:50 <roconnor> bizarre
11:26:13 <SamB> hmm:
11:26:17 <psi> GAH
11:26:20 <SamB> ERROR "./ImportState.hs" - Trex.insertField not in scope
11:26:23 <psi> that was my key again.
11:26:29 <psi> I must've mixed them up.
11:26:32 <roconnor> :)
11:26:34 <SamB> heh
11:26:59 * SamB wonders why hugs thinks he wants to use Trex
11:27:32 * roconnor needs a haskell debugger
11:28:25 * SamB didn't know hugs *supported* Trex
11:31:48 <psi> okay, I still get the bug.
11:32:01 <psi> time to try a known good UM I guess.
11:33:48 <psi> edwardk crashes to, but I'm still using my extaction.
11:34:25 <stepcut> SamB: I believe Hugs is the *only* place Trex is supported
11:35:54 <psi> ?where trex
11:35:55 <lambdabot> I know nothing about trex.
11:38:06 <psi> Ah! edwardk works with its own extraction.
11:38:42 <roconnor> @hoogle comapring
11:38:42 <psi> intriguing...
11:38:43 <lambdabot> No matches found
11:38:47 <roconnor> @hoogle comparing
11:38:48 <lambdabot> No matches found
11:38:59 <roconnor> @hoogle compareing
11:39:00 <lambdabot> No matches found
11:39:10 <glguy> 6.6 will have that function
11:39:16 <roconnor> oh
11:39:53 <psi> heh! and my UM works with edwardk's extraction.
11:40:09 <roconnor> so your UM breaks the extraction?
11:40:14 <psi> aye, somehow
11:40:18 <roconnor> is your extraction truncated?
11:40:37 <psi> they have the same size
11:41:02 <roconnor> does diff say they are different?
11:41:09 <roconnor> and they used the same key?
11:41:31 <roconnor> have you run the sandmark with your UM?
11:41:43 <psi> I need to make another extraction to check sizes with the same key.
11:41:49 <psi> yes, no issues reported.
11:42:01 <psi> I mean, check diff with the same key.
11:43:31 <xahlee> wee psi
11:44:40 <psi> woo
11:46:53 <psi> $ cmp umix2.um umix3.um
11:46:53 <psi> umix2.um umix3.um differ: byte 9427849, line 161687
11:48:36 * psi is very curious now
11:53:23 <roconnor> is there a MonadNonDeterministic class?
11:53:32 <xerox> There is MonadRandom!
11:53:42 <roconnor> with a member function something like choose :: [a] -> m a
11:53:43 <xerox> But it is something different, probably...
11:54:09 <roconnor> random is a little different from nondeterministic.
11:54:21 <xerox> roconnor: MonadRandom has [(Rational,a)] -> m a
11:54:38 <xerox> http://haskell.org/haskellwiki/NewMonads/MonadRandom
11:54:41 <lambdabot> Title: NewMonads/MonadRandom - HaskellWiki, http://tinyurl.com/fs3av
11:54:42 <roconnor> yes, monad random would be an instance of this class.
11:54:55 <xerox> Right.
11:55:13 <roconnor> but [a] will be too, and it isn't an instance of MonadRandom.
11:55:19 <xerox> roconnor: I don't think there's that class, but it sounds like a nice idea, if you get enough monads to go in it  :)
11:55:28 <xerox> MonadRandom itself should make it to mtl.
11:55:39 <roconnor> oh wait, I'm dumb
11:55:48 <roconnor> this is just monad plus.
11:56:03 <roconnor> and choose = foldr mplus mzero
11:56:40 <glguy> msum ^^
11:57:07 <roconnor> @type msum
11:57:09 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
11:57:16 <roconnor> close
11:58:10 <roconnor> choose l = msum (map return l)
11:58:32 <xerox> Are you sure?
11:58:40 <roconnor> pretty sure
11:58:58 <xerox> > msum . map return $ [1,2,3,4]
11:58:59 <roconnor> wait, sure about what?
11:59:00 <lambdabot>  add an instance declaration for (Show (m a))
11:59:07 <xerox> > msum . map return $ [1,2,3,4] :: [Int]
11:59:09 <lambdabot>  [1,2,3,4]
11:59:11 <xerox> > msum . map return $ [1,2,3,4] :: Maybe Int
11:59:13 <lambdabot>  Just 1
11:59:18 <xerox> What's the point?
11:59:37 <roconnor> newtype NDS s a = NDS {runNDS :: s -> [(s,a)]}
11:59:50 <roconnor> this is an instance of MonadPlus that I made
12:00:09 <roconnor> I'm sure it can be made with monad transformers, but I didn't want to bother making sure I got the order right.
12:01:27 <roconnor> @type foldr mplus mzero
12:01:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:01:49 <roconnor> oh right
12:02:01 <lispy> > foldr mplus mzero [1..10]
12:02:03 <lambdabot>  add an instance declaration for (Num (m a))
12:02:03 <lambdabot>   In an arithmetic sequence: ...
12:02:18 <roconnor>  choose /= foldr mplus mzero
12:02:25 <lispy> > foldr mplus mzero [map Just [1..10]]
12:02:27 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
12:02:42 <xerox> Now I like it more.
12:02:47 <glguy> lispy: the extra [ ] break that
12:03:00 <xerox> The return had kind of `communist' semantics.
12:03:56 <lispy> > foldr mplus mzero $map Just [1..10]
12:03:59 <lambdabot>  Just 1
12:04:04 <lispy> ah right
12:04:22 <roconnor> msum = foldr mplus mzero
12:04:41 <roconnor> @hoogle [a] -> [m a]
12:04:43 <lambdabot> Prelude.cycle :: [a] -> [a]
12:04:43 <lambdabot> Prelude.init :: [a] -> [a]
12:04:43 <lambdabot> Prelude.reverse :: [a] -> [a]
12:04:59 <xerox> roconnor: [a] -> m a, I'd say.
12:05:18 <roconnor> I was looking for a replacement for map return
12:05:35 <xerox> roconnor: but its semantics are the same...
12:05:51 <Igloo> ndm: @hoogle [a] -> [m a] looks broken to me
12:06:02 <roconnor> @type map return
12:06:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> [m a]
12:06:07 <ndm> @hoogle [a] -> [m a]
12:06:08 <lambdabot> Prelude.cycle :: [a] -> [a]
12:06:08 <lambdabot> Prelude.init :: [a] -> [a]
12:06:08 <lambdabot> Prelude.reverse :: [a] -> [a]
12:06:17 <ndm> Igloo: what were you hoping it to find?
12:06:25 <roconnor> hoogle has some issues with type classes
12:06:35 <ndm> Igloo: its broken for higher kinded type classes, which is likely to be the issue
12:06:50 <Igloo> I wasn't the one doing it, but I wasn't expecting it to find things that didn't match the pattern  :-)
12:07:05 <ndm> yep, almost certainly higher kinded type classes, a known bug
12:07:19 <Igloo> What have type classes got to do with it?
12:07:25 <ndm> will be fixed in Hoogle 4, which can now do type searches and text searches
12:07:53 <ndm> what would you want to come before cycle for that above search?
12:08:00 <xerox> lambdabotify it! :)
12:08:18 <ndm> xerox: what, hoogle 4?
12:08:22 <roconnor> ndm: map return  ... ;)
12:08:27 <roconnor> :P
12:08:31 <ndm> roconnor: single functions only :)
12:08:32 <xerox> Yeah.
12:08:46 <roconnor> error
12:08:51 <ndm> will do, as soon as its done, will replace @hoogle - but it needs a bit of work faster
12:08:51 <roconnor> :type error
12:08:59 <roconnor> @type error
12:09:01 <lambdabot> forall a. [Char] -> a
12:09:03 <Igloo> ndm: Maybe I don't understand what hoogle does, but I wouldn't expect cycle to appear at all
12:09:27 <ndm> Igloo: it orders the results, don't try and worry about how it does it, just think if there is anything better
12:09:43 <ndm> Igloo: it doesn't use unification like you think it might, since thats often _not_ what the user wants
12:09:43 <Igloo> Ah, so it is meant to return things that don't match the request?
12:09:54 <SamB> hmm, how about @pldjinnhoogle
12:09:57 <ndm> yep, its meant to return the "closest" things it can find
12:10:05 <Igloo> OK, ignore me then  :-)
12:10:09 <SamB> which gives you a points-free function of a given type ;-)
12:10:43 <ndm> I was actually discussing this with some people today, since we lost power to our building
12:10:54 <ndm> so had a whiteboard session on whether hoogle should search using unification
12:11:19 <ndm> if you use unification as hte primary method, lots of things go wrong, although it can be useful for some searches
12:11:28 <Igloo> You only talk to each other when you lose power?  :-)
12:11:55 <SamB> Igloo: well there isn't much else to do then
12:11:57 <lispy> Igloo: that sounds about right :)
12:12:03 <xerox> SamB: just wait, lambdabot will become sentient enough at some point.
12:12:26 <Igloo> ndm: Does anything go wrong other than it not working if the user gives the wrong input (which is a valid thing to support, i grant you, I'm just curious)
12:12:48 <xerox> @hoogle yow
12:12:49 <lambdabot> No matches found
12:13:50 <lispy> ?hoogle a
12:13:52 <lambdabot> Data.Graph.Inductive.Example.a :: Gr Char ()
12:13:52 <lambdabot> Array.accum :: Ix a => (b -> c -> b) -> Array a b -> [(a, c)] -> Array a b
12:13:52 <lambdabot> Array.accumArray :: Ix a => (b -> c -> b) -> b -> (a, a) -> [(a, c)] -> Array a b
12:14:10 <lispy> i sort of expect undefined and error for that one
12:14:22 <lispy> ?hoogle forall a. a -> a
12:14:24 <lambdabot> Did you mean: Forall A. a -> a
12:14:24 <lambdabot> Prelude.id :: a -> a
12:14:24 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
12:14:34 <lispy> ?hoogle forall a. a
12:14:35 <lambdabot> Did you mean: Forall A. a
12:14:35 <ndm> Igloo: indeed, suddently everyone comes out and chats when the power dies
12:14:35 <lambdabot> Prelude.undefined :: a
12:14:35 <lambdabot> Test.QuickCheck.Batch.bottom :: a
12:14:58 <ndm> Igloo: what do you mean by the wrong input?
12:15:20 <Igloo> ndm: I mean giving the arguments the wrong way round, missing off a Maybe, that sort of thing
12:15:24 <ndm> lispy: in Hoogle 4 you can do ":: a", but there is no way to search for that in Hoogle 3
12:15:45 <xerox> Igloo: having hoogle matching type up to reordering is cool
12:15:46 <ndm> Igloo: arguments are permuted, the order of arguments is totally irrelevant (other than the result), missing a Maybe is fine
12:15:58 * Igloo discovers lots of undocumented GHC options that make various impossibles happen
12:16:04 <ndm> @hoogle Eq a => a -> [(a,b)] -> b
12:16:05 <lambdabot> No matches, try a more general search
12:16:06 <xerox> O_o
12:16:26 <Igloo> ndm: But are those things the only reason searching by unification doesn't work?
12:16:30 <ndm> ah, thats dons fault, Hoogle on the we gets that one
12:16:40 <ndm> web*, it finds lookup
12:16:55 <ndm> Igloo: essentially yes
12:17:21 <ndm> Igloo: Hoogle also does missing arugment introduction, and other goodies
12:17:44 <ndm> if the user actually knew what search they wanted, unification works fine, but reading the logs, users are quite thick :)
12:18:16 <ndm> or at least don't know exactly what they are searching for
12:18:18 <lispy> dons: alas, i cannot profile my program :(
12:18:27 <lispy> dozer: -lHSghc_p is missing....
12:18:39 <ndm> for example, classes are often missing, arguments reordered, typed the wrong type, searching for keywords etc.
12:18:49 <Igloo> Ignorant rather than thick, I hope, but yes  :-)
12:19:08 <ndm> actually, i'd probably go with lazy
12:19:27 <lispy> heh, i told that to dozer...
12:19:30 <ndm> i.e. they don't take the time to think "does this function require an == in it" etc - so Hoogle tries to adapt to fix up their little mistakes
12:19:56 <ndm> which is what should happen - the tool adapting to hte user, rather than the other way round
12:21:01 <dozer> hi
12:21:05 <dozer> just got back from food
12:21:33 <Johnnn12> damn, haskell rocks
12:21:40 <dozer> <lispy>dozer: -lHSghc_p is missing....
12:21:51 <dozer> does this refer to my cyclic dependency problem or something else?
12:22:06 <lispy> dozer: read up a bit more, meant to tell that to dons, sorry
12:23:36 <glguy> What are the decent OpenSource alternatives to PHP or RubyOnRails?
12:24:48 <dozer> google doesn't seem to know anything about -lHSghc_p
12:25:27 <ndm> Igloo: if you are interested in an idea of how hoogle works, i gave a presentation on it: http://www-users.cs.york.ac.uk/~ndm/downloads/slides-hoogle-08_dec_2005.pdf
12:25:29 <lambdabot> http://tinyurl.com/kr8k4
12:25:43 <ndm> I also hope to write a HW paper for next year on Hoogle, but thats not certain
12:25:59 <cybercobra> glguy: (python plug) django, turbogears
12:26:18 <lispy> dozer: right, you have to remove the -l
12:26:26 <lispy> dozer: well, the -
12:26:36 <lispy> dozer: otherwise it wants to exclude :)
12:27:58 <dozer> http://www.google.com/search?hl=en&lr=&ie=UTF-8&oe=UTF-8&q=lHSghc_p&btnG=Search
12:27:59 <lambdabot> Title: lHSghc_p - Google Search, http://tinyurl.com/nw6sm
12:28:27 * Igloo needs a cunning plan for getting to HW next year
12:29:18 <edwardk> Igloo, I feel your pain. I'm trying to scheme my way into getting to various conferences this year myself.
12:29:43 <cybercobra> HW = Haskell W-something ?
12:29:43 * Igloo reads ndm's page 6 and thinks something is wrong here  :-)
12:30:09 * ndm downloads a copy of ndm's presentation
12:30:27 <ndm> Igloo: what about that?
12:30:36 <glguy> > reverse "TemplateManager.zip"
12:30:39 <lambdabot>  "piz.reganaMetalpmeT"
12:30:43 <edwardk> cybercobra: workshop
12:30:45 <Igloo> That you seem to be trying to unhaddock haddock's output
12:30:50 <ndm> yep :)
12:31:00 <ndm> since then i have added a --hoogle flag to haddock
12:31:04 <ndm> and one to cabal as well
12:31:20 <ndm> so now runhaskell Setup haddock --hoogle will generate a hoogle database
12:31:27 <ndm> without unparsing the HTML
12:31:38 <dcoutts_> Igloo, do you need a cunning plan? you can't just go?
12:31:43 <ndm> thats already in the various projects, and will be used live for Hoogle 4
12:31:46 <dcoutts_> Igloo, or you mean to get a paper in
12:32:35 <Igloo> dcoutts_: I need a cunning plan if it's not going to cost me lots of money
12:32:50 <dcoutts_> Igloo, ah. Germany isn't so far as Portland :-)
12:33:10 <Igloo> No, that helps  :-)
12:33:13 <ndm> yeah, you can go really cheap - a youth hostel and a train ticket
12:34:21 <dmhouse> ?hoogle braces
12:34:21 <lambdabot> Text.PrettyPrint.HughesPJ.braces :: Doc -> Doc
12:34:21 <lambdabot> Text.ParserCombinators.Parsec.Token.braces :: TokenParser st -> CharParser st a -> CharParser st a
12:35:29 <dcoutts_> Igloo, see http://www.seat61.com/ on how to get cheep european rail.
12:35:44 <edwardk> ndm: so how long until I can
12:35:48 <edwardk> @hoogle Data.Map
12:35:49 <lambdabot> No matches, try a more general search
12:35:57 <edwardk> =)
12:35:58 <Igloo> Heh, remind me of that URL in a few months  :-)
12:36:10 <ndm> edwardk: works in Hoogle 4 already
12:36:24 <edwardk> ah, so i just need to abuse dons to get him to upgrade?
12:36:36 <ndm> no, lots of other stuff doesn't work in hoogle 4 yet :)
12:36:44 <edwardk> bah
12:36:53 <ndm> btw, it treats Data.Map as search for Map inside the Data namespace
12:37:00 <ndm> so will match Data.Map.Map as well as Data.Map
12:37:04 <edwardk> *nods*
12:37:21 <edwardk> i just don't want to have to lie to hoogle to find it
12:37:23 <edwardk> @hoogle Ma
12:37:25 <lambdabot> Data.Graph.Inductive.Query.MaxFlow :: module
12:37:25 <lambdabot> Data.Graph.Inductive.Query.MaxFlow2 :: module
12:37:25 <lambdabot> Data.Map :: module
12:37:34 <edwardk> it amuses me that that finds something ;)
12:37:40 <edwardk> and the other doesn't
12:37:40 <dcoutts_> hmm :: module ?
12:37:41 <ndm> well Hoogle 4 that just works out of the box
12:37:47 <dcoutts_> perhaps -- module
12:38:03 <ndm> there is a syntax for constraining it to modules only
12:38:07 <ndm> i just can't remember what it is
12:39:18 <ndm> --module or /module both work
12:39:41 <ndm> with Hoogle 4, that is :)
12:42:27 <ndm> dcoutts_, oh, yep - thats now "_module_ Data.Map" in Hoogle 4
12:42:36 <ndm> where module is underlined if you have escape codes
12:57:03 <gour> anyone has any experience with CoddFish? (http://wiki.di.uminho.pt/wiki/bin/view/PURe/CoddFish)
12:57:08 <lambdabot> Title: PURe Project, http://tinyurl.com/gwqy4
13:00:04 <monochrom> Hmm looks promising, this CoddFish.
13:04:38 <gour> monochrom: i just stumbled upon...looking for appropriate bindings for sqlite3 supporting extension api
13:19:23 <dmhouse> Hrm. Application associating to the left makes it more difficult to parse.
13:22:19 <dmhouse> My current strategy to parse 'a b' is 1) parse the a 2) see that there's a space, go for an application 3) recurse
13:22:51 <dmhouse> Which is a problem when it comes to 'a b c', as it gets parsed as 'a (b c)', which screws up currying.
13:23:32 <edwinb> you could try separating the parsing of applications and non-applications
13:23:42 <edwinb> then when you parse 'b' you're only trying to parse a non-application
13:23:43 <Cale> dmhouse: chainl
13:24:10 <Cale> If you're using parser combinators, you really want chainl for this
13:24:10 <kosmikus> I was about to say the same as Cale
13:24:32 <edwinb> I use chainl for this sort of thing, but still separate the terms which aren't applications
13:25:10 <dmhouse> ?hoogle chainl
13:25:11 <lambdabot> Text.ParserCombinators.ReadP.chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
13:25:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator.chainl :: GenParser tok st a -> GenParser tok st (a -> a -> a) -> a -> GenParser tok st a
13:25:12 <lambdabot> Text.ParserCombinators.ReadP.chainl1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
13:26:51 <dmhouse> Cale: ooh, nice. Thanks all.
13:27:54 <glguy> if I don't define a fromInteger for my instance Num a => Num (Vector a)  (where newType Vector a = Vector [a]) will I experience problems?)
13:28:02 <chessguy> so is there a good GUI library for haskell?
13:28:03 <glguy> should I just say fromInteger a = Vector [a]?
13:28:31 <dmhouse> Gah, I hate how the _entire_ Parsec documentation has a title text, so if my cursor stays still anywhere on it I get the annoying yellow popup text thingy.
13:28:53 <SamB> ???
13:29:07 <dmhouse> chessguy: gtk2hs is good.
13:29:32 <monochrom> <html title="you can't escape!"> ... </html>  ? :)
13:29:49 <ndm> dmhouse: did WinHugs on USB work fine out the box, or did it require any tweaks?
13:29:55 <chessguy> hmm. i google it and the first sentence on the first site that comes up says "This project is no longer active."
13:30:03 <dmhouse> Almost. <body  title="Parsec, a fast combinator parser" >
13:30:14 <dmhouse> ndm: out of the box.
13:30:19 <ndm> dmhouse: neat :)
13:30:37 <SamB> chessguy: for gtk2hs?
13:30:38 <ndm> dmhouse: where are you teaching Haskell with WinHugs? (its nice to know ;) )
13:30:38 <dmhouse> chessguy:  http://haskell.org/gtk2hs/ that one?
13:30:39 <lambdabot> Title: Gtk2Hs
13:30:49 <dmhouse> ndm: At my school (not a university).
13:30:54 <chessguy> oh, i mis-typed it
13:31:01 <chessguy> don't mind me
13:31:12 <SamB> hehe
13:32:08 <chessguy> i don't suppose that comes with hugs or ghci
13:32:46 <dmhouse> I don't think so, but you can probably get a package for your distro.
13:33:10 <chessguy> my distro of windows? :)
13:33:36 <monochrom> windows is a distro
13:33:47 <dmhouse> ;) Okay, then there's likely a binary installer, you lucky thing.
13:33:49 <roconnor> ?type \cs -> maximum $ map sum $ inits $ map change cs
13:33:51 <lambdabot> Not in scope: `change'
13:34:02 <roconnor> ?type \change cs -> maximum $ map sum $ inits $ map change cs
13:34:05 <lambdabot> forall b a. (Ord b, Num b) => (a -> b) -> [a] -> b
13:34:35 <glguy> What would the reads function look like that would take "1 2 3 4 5" and return ([1,2,3,4,5],"") look like?
13:34:56 <roconnor> > lex "1 2 3 4 5"
13:34:58 <lambdabot>  [("1"," 2 3 4 5")]
13:35:04 <dmhouse> sepBy integer space -- I prefer Parsec :)
13:35:14 <dmhouse> integer `sepBy` space, even beter.
13:35:16 <dmhouse> *better.
13:35:56 <glguy> the trick is it's not always going to be of length 5
13:36:48 <dmhouse> (The Parsec one will work no matter how many there are, even if there are none.)
13:37:12 <glguy> dmhouse: is it wrong to use a parsec parser to implement a Read instance?
13:37:28 <dmhouse> I don't see why it should be.
13:37:34 <monochrom> I advise rewriting "map sum . inits" as "scanl (+) 0"
13:38:50 <glguy> ?index integer
13:38:51 <lambdabot> Language.Haskell.TH.PprLib, Text.ParserCombinators.Parsec.Token, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
13:39:39 <monochrom> I think it is not wrong to write in Parsec to implement Read, but it is extra work.  Try to write in ReadP instead, which has a trivial interface to Read.
13:39:39 <glguy> ?type floatOrNatural
13:39:42 <lambdabot> Not in scope: `floatOrNatural'
13:39:53 <glguy> ReadP?
13:40:11 <roconnor> > let f x = let (a,b) = head (lex x) in (read a):(f b) in f "1 2 3 4 5"
13:40:13 <lambdabot>  Add a type signature
13:40:20 <monochrom> Text.ParserCombinators.ReadP
13:40:23 <roconnor> > let f x = let (a,b) = head (lex x) in (read a):(f b) in f "1 2 3 4 5"::[Int]
13:40:25 <lambdabot>  Exception: Prelude.read: no parse
13:40:45 <monochrom> Parsec was not designed to interface with Read at all.
13:41:28 <dmhouse> But it's so eeeeasy :)
13:41:58 <dmhouse> Actually, it's easy in ReadP, too.
13:42:16 <dmhouse> many (satisfy isDigit) `sepBy` char ' '
13:42:27 <dmhouse> It just doesn't have an 'integer' combinator.
13:42:43 <glguy> I would prefer it to read any Num
13:42:51 <glguy> readS_to_P reads maybe?
13:42:56 <monochrom> ReadP is very like Parsec when you write code.  And then you just call a function to get your Read instance.
13:44:45 <Baughn> @undo do {thing <- anyChar; return [thing]}
13:44:47 <lambdabot> anyChar >>= \ thing -> return [thing]
13:45:37 <kpreid> anyChar >>= (return . return)
13:45:44 <chessguy> ugh, gtk2hs won't install because it says it can't fin GHC. but GHC is there
13:46:19 <monochrom> readS_to_P reads is ok for parsing just a number.
13:46:54 <glguy> readP_to_S (readS_to_P reads `sepBy1` char ' ' >>= return . Vector)
13:47:30 <monochrom> Does it work to your satisfaction?
13:47:34 <glguy> I don't know yet
13:47:36 <glguy> :)
13:47:38 <glguy> it type checks
13:48:17 <glguy> yeah, it worked :)
13:48:33 <monochrom> Neato.  Should have more faith next time.
13:48:56 <dmhouse> Never use '>>= return'
13:49:03 <dmhouse> Use fmap or liftM instead.
13:49:07 <glguy> it's gone now
13:49:10 <glguy> already
13:49:19 <dmhouse> readP_to_S $ fmap Vector (readS_to_P reads `sepBy1` char ' ')
13:49:31 <Baughn> @undo do {eof; return ""}
13:49:32 <lambdabot> eof >> return ""
13:50:08 <monochrom> I don't like that.  But I belong to the sect of do-considered-good.
13:50:27 <monochrom> By why "never"?
13:50:37 <dmhouse> Because fmap and liftM are always neater.
13:50:43 <ndm> dmhouse: DrHaskell automatically tells you about that :)
13:50:49 <monochrom> Alright.
13:50:51 <dmhouse> ndm, cute :)
13:51:32 * dmhouse puzzles at chainl
13:52:12 <chessguy> so, any suggestions how i can get the gtk2hs installation to find my copy of ghc?
13:52:19 <dmhouse> My grammar is _almost_ really simple, in that it'd be a chainl with a seperator of space and a combining function that performs application, but it's complicated by the presence of an 'IF t1 THEN t2 ELSE t3' construct.
13:52:27 <dcoutts> chessguy, linux? windows ?
13:52:33 <monochrom> What would do advise on "m >>= \x -> k (f x)" ?
13:52:46 <chessguy> xp
13:52:50 <glguy> m >>= k . f?
13:52:57 <dmhouse> monochrom: m >>= k . f
13:53:08 <glguy> k . f =<< m?
13:53:13 <monochrom> Or should it be liftM f m >>= k  ?
13:53:24 <dcoutts> chessguy, if you installed ghc with the .msi installer then it should just work. what version of ghc have you got installed and how did you install it ?
13:53:32 <chessguy> oh, i have to have one of two specific versions of ghc. that's silly
13:53:39 <dmhouse> I don't like >>= with lambdas, I tend to use do if they turn out to be neccessary.
13:53:49 <chessguy> i installed 6-4-2 with the msi
13:54:03 <dmhouse> monochrom: is that even equivalent?
13:54:38 <chessguy> it wants 6.4.1 or 6.2.2, but that's dumb
13:55:03 <dmhouse> > let m = [4,5,6]; k = replicate 4; f = (+4) in m >>= k . f
13:55:04 <lambdabot>  [8,8,8,8,9,9,9,9,10,10,10,10]
13:55:14 <dmhouse> > let m = [4,5,6]; k = replicate 4; f = (+4) in fmap f m >>= k
13:55:15 <lambdabot>  [8,8,8,8,9,9,9,9,10,10,10,10]
13:55:19 <glguy> shame that (!!) isn't part of an indexable typeclass
13:55:33 <dmhouse> Huh, I don't see how to transform one into the other.
13:55:52 <dmhouse> Oh, wait, yeah I do.
13:55:59 <dmhouse> Still, I prefer m >>= k . f
13:56:34 <monochrom> OK, so if k=return you advise liftM f m, otherwise m >>= k . f
13:56:49 <chessguy> i guess i'll just have to install an older version
13:57:25 <dmhouse> Yeah.
13:57:57 <dmhouse> As with liftM f m >>= k in the case of k = return gives you the nice reduction to liftM f m.
14:01:14 <Baughn> Is it possible to have haskell-doc-mode show type information for imported functions such as those in parsec?
14:02:18 <dmhouse> Baughn: I've wondered that.
14:04:07 <glguy> ?hoogle intersperse
14:04:08 <lambdabot> List.intersperse :: a -> [a] -> [a]
14:04:36 <Syzygy-> > intersperse 2 [3..8]
14:04:38 <lambdabot>  [3,2,4,2,5,2,6,2,7,2,8]
14:05:19 <glguy> show (Vector a) = concat $ intersperse " " $ map show a
14:06:50 <glguy> almost all of my haskell usage has been on algorithms, very little parsing and printing
14:06:57 <glguy> this is all new territory for me :)
14:09:37 <roconnor> ?hoogle a -> [a] -> Bool
14:09:38 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
14:09:38 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
14:15:06 <gmh33> and I'm back..
14:15:42 <monochrom> Follow these three easy steps for Haskell programming.  0) Express your problem as a composition of subproblems as normal.  1) Assign types to your subproblems and compositions.  2) Use the types to ask Hoogle for filling in the code.
14:16:01 <Cale> hehe
14:16:27 * Baughn just a minute ago tried to decipher a 30-line type signature
14:16:37 <Baughn> I think that was a bit beyond IRC's line limit. And my brain. :P
14:16:55 <monochrom> You have a function that takes 30 parameters or something?
14:17:06 <ski> Baughn : any class constraints ?
14:17:13 <Baughn> ski: Yes.
14:17:36 <Baughn> It was caused by two layers of autogenerated code.. went away mysteriously, too
14:18:04 <gmh33> I came back after a short reprieve to learn "all about monads" lol
14:18:16 <dmhouse> I can't figure out this parsing problem.
14:18:19 <monochrom> Glad you survived.
14:18:24 <dmhouse> I'm building a LC parser, for some context.
14:18:53 <monochrom> Hey I have one hanging around actually
14:19:25 <JKnecht>  lc = left corner?
14:19:25 <dmhouse> My top-level is basically termWithoutApplication `chainl1` (space >> return TmApp), where TmApp :: Term -> Term -> Term is a constructor for the Term datatype.
14:19:35 <dmhouse> monochrom: I'd quite like to build on myself.
14:19:40 <dmhouse> JKnecht: Lambda calculus.
14:20:00 <dmhouse> All is good apart from a single construct: IF t1 THEN t2 ELSE t3.
14:20:13 <gmh33> > (^^) 5 2
14:20:14 <lambdabot>  25.0
14:20:45 <monochrom> Ah, I don't have that.  No wonder it seemed easy to me.
14:20:51 <dmhouse> The parser for this currently looks like do string "IF "; t1 <- term; string " THEN "; t2 <- term; string " ELSE "; t3 <- term
14:21:27 <dmhouse> The problem comes with the first recurse to 'term'.
14:21:43 <dmhouse> Say we're trying to parse IF a THEN b ELSE c.
14:21:48 <monochrom> Yes you have to somewhere recognize that THEN is a keyword.
14:22:35 <joe_k> how can I apply a tuple of args to a function
14:22:37 <dmhouse> It sees the 'a' which gets parsed, but then it sees the space that follows, which gets picked up by the chainl and it tries to parse THEN as a term, thinking it's applying THEN to a.
14:22:45 <dmhouse> joe_k: uncurry.
14:22:50 <monochrom> The Parsec doc describe a trick for recognizing keywords.
14:23:13 <joe_k> thanks
14:23:23 <dmhouse> (The situation is complicated by the fact that TRUE is a valid term, so we have an LL1 conflict with THEN/TRUE).
14:23:51 <Baughn> dmhouse: This often gets simplified by doing the parse in two passes - that is, having a scanner first
14:24:32 <SamB> yay Alex!
14:24:35 <dmhouse> Baughn: how would this help here?
14:24:42 <SamB> but BOOO parsec not interoperating well with Alex
14:24:53 <SamB> (or any other kind of lexer)
14:24:56 <dmhouse> monochrom: hrm, notFollowedBy? It could work.
14:24:56 <Baughn> dmhouse: It might make the parser easier to reason about
14:25:38 <SamB> perhaps Parsec isn't really the best thing since sliced bread after all
14:26:36 * cjay doesn't like sliced bread that much, anyway
14:27:07 <monochrom> Garlic bread is better.
14:27:07 <SamB> its an expression ;-)
14:27:17 <Baughn> I particularily like melon bread
14:27:39 <Baughn> Or.. pumpkin bread. No, seriously.
14:28:00 <Baughn> Pumpkin bread is the best thing since sliced bread. ^_^
14:28:11 <SamB> I don't actually like sliced white bread that much anyway
14:28:16 <cjay> what about sliced pumpkin bread?
14:28:55 <monochrom> Striploin steak, New York cut.
14:29:31 * SamB wonders what is so bad about "frown"
14:29:45 <musasabi> will GHC compile completely away a global non-exported function like: debugFoo :: Foo -> IO (); debugFoo _ = return () ?
14:29:46 <monochrom> You frown when you look at bad things.
14:29:48 <musasabi> with -O2
14:30:12 <SamB> musasabi: most likely
14:30:25 <SamB> monochrom: its the name of a parser generator
14:30:36 * monochrom frowns
14:30:49 <SamB> so is it for parsing bad things?
14:30:52 <dmhouse> Gah, why is notFollowedBy limited to CharParser st Char?
14:30:56 <monochrom> I'm just joking.
14:31:01 <SamB> dmhouse: no idea!
14:31:57 <monochrom> @hoogle notFollwedBy
14:31:58 <lambdabot> No matches found
14:32:03 <monochrom> @hoogle notFollowedBy
14:32:03 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
14:53:28 <ndm> SamB: i had heard some good things about frown
14:53:46 <SamB> I'm just making fun of the pessimistic-sounding name ;-)
14:54:10 <SamB> oh, btw, where are my patches?
14:54:22 <SamB> and I don't think you've set the destination address for "darcs send"
14:54:40 <psi> I have created hoogle functionality for haskell-mode. Does anyone want it?
14:55:02 <psi> If point is at a type, it searches for the type, otherwise it searches for the word at type.
14:55:08 <psi> at point*
14:55:53 <ndm> SamB: am at home, so sitting in my inbox, waiting for me to get into the office
14:56:24 <ndm> SamB: we're a bit held up because there is no "good" system for the darcs account on haskell.org
14:56:31 <ndm> we also need buildbot patches and stuff in there
14:57:30 <Igloo> buildbot patches?
14:57:34 <Igloo> (BIAS)
14:59:12 <ndm> i.e. set up buildbot to work from the darcs.haskell.org/yhc account
15:00:04 <SamB> ndm: why don't you have both home and office keys set up?
15:00:06 <ndm> have you got buildbot and GHC anywhere yet?
15:00:24 <ndm> SamB: I'm not a unix guy, i need people to talk me though this SSH keys and stuff :)
15:00:35 <SamB> ndm: oh.
15:00:57 <monochrom> "Press s, press s agian, press h, press space, ..."  like that? :)
15:01:01 <ndm> SamB: i hope to get all the darcs moving done tomorrow, since off this afternoon
15:01:07 <ndm> * tomorrow evening am off
15:01:23 <ndm> monochrom: slightly more basic than that, esp since i use windows, where ssh isn't a command
15:02:26 * monochrom is horrified to imagine what is more basic than that :)
15:03:06 <glguy> PuTTY makes ssh easy and fun
15:03:18 <ndm> indeed, it does
15:03:28 <glguy> Pageat makes ssh keys easy and fun
15:03:31 <ndm> but when i still have to use nano on the other end, i still end up crying
15:03:35 <glguy> n^
15:03:52 <ndm> my Ctrl+S reflex didn't go down well in nano
15:03:54 <glguy> nano? did they run out of disk space for editors?
15:04:05 <SamB> heh
15:04:29 <ndm> its just what the guy in the office told me to type
15:04:40 <monochrom> See that's the calamity of Windows.  It has a great story for local GUI but the remote story is non-existent.
15:04:46 <ndm> and alegedly TextPad doesn't run on Linux...
15:04:53 <SamB> ndm: oh, you don't know how to *make* ssh keys?
15:04:56 <ndm> remote desktop? perfect
15:05:00 <SamB> I don't know how to make ssh keys either.
15:05:08 <ndm> SamB: i have a private key, its on my public home drive at uni
15:05:09 <SamB> (not on windows!)
15:05:20 <ndm> i just haven't bothered to download it yet, and can't be bothered to config everything
15:05:31 <ndm> i will do once we are fully moved to haskell.org, just filing a bug on that now
15:05:33 <glguy> PuTTY keygen makes ssh keygen easy and fun!
15:05:59 <glguy> you get to move your mouse around wildly
15:06:47 <ndm> yeah, i remember that, was good!
15:07:03 <glguy> My private key is encoded with vulgarities
15:07:13 <glguy> secretly written on the putty keygen box
15:07:29 <glguy> (in cursive, for maximum security)
15:09:17 <monochrom> does cursive have something to do with curse?
15:09:26 <glguy> haha,
15:09:31 <glguy> and incase that wasn't a joke
15:09:45 <glguy> It's the script writing vs block letters
15:10:39 <monochrom> "my private key is a curse about my privates, written in cursive"  sounds like very fitting!
15:12:43 <edwardk> now write an application (in curses) to display it on the screen
15:14:34 <xerox> > chr 26
15:14:36 <lambdabot>  '\SUB'
15:14:45 <xerox> Anybody knows off-hand what it is?
15:15:07 <glguy> > showHex 26
15:15:09 <lambdabot>  <[Char] -> [Char]>
15:15:12 <glguy> > showHex 26 ::
15:15:12 <lambdabot>  Parse error
15:15:14 <glguy> > showHex 26 ""
15:15:15 <lambdabot>  "1a"
15:15:37 <edwardk> ctrl-z
15:15:40 <fasta> What's the use of the second argument?
15:15:43 <xerox> Ah.
15:15:49 <glguy> fasta:
15:15:54 <glguy> > showHex 26 "the rest"
15:15:55 <edwardk> or wait is that ctrl-y
15:15:56 <lambdabot>  "1athe rest"
15:16:00 <xerox> > map chr [7,8,9,10,13,26]
15:16:01 <lambdabot>  "\a\b\t\n\r\SUB"
15:16:04 <ski> @type showHex
15:16:06 <lambdabot> forall a. (Integral a) => a -> ShowS
15:16:07 <xerox> Where was the bell?
15:16:13 <edwardk> ctrl-g
15:16:16 <glguy> fasta: it is to save show from being O(n^2)
15:16:32 <ski> type ShowS = String -> String
15:16:36 <fasta> glguy: I like that :)
15:16:36 <xerox> edwardk: it being the ASCII code... ?
15:16:50 <resiak> xerox: http://en.wikipedia.org/wiki/Substitute_character
15:16:53 <lambdabot> http://tinyurl.com/ltj46
15:16:53 <edwardk> > ord 'g' - 64
15:16:55 <lambdabot>  39
15:16:59 <edwardk> er
15:17:04 <edwardk> > ord 'G' - 64
15:17:06 <lambdabot>  7
15:17:07 <edwardk> =)
15:17:13 <xerox> \a, ah.
15:17:23 <xerox> Right.
15:17:27 <glguy> Substitute character (SUB): A control character that is used in the place of a character that is recognized to be invalid or in error or that cannot be represented on a given device.
15:17:32 <glguy> In ASCII and Unicode, this character is encoded by the number 26 (in hexadecimal: 1A). Standard keyboards transmit this code when the Ctrl and Z keys are pressed simultaneously (Ctrl+Z).
15:18:53 <Baughn> @hoogle choice
15:18:54 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
15:18:55 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
15:18:55 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
15:26:14 <xerox> Given, say, n positive numbers, is it possible to find a one-step mathematical operation that given whatever positive number evaluates to 0 when that number is not one of the selected n, and non-0 when it _is_ one of them?
15:26:16 <xerox> :D
15:26:17 <SamB_XP> ndm: seen http://www.unixwiz.net/techtips/putty-openssh.html ?
15:26:20 <lambdabot> http://tinyurl.com/gpj8c
15:26:55 <xerox> Maybe constructing an ad-hoc polynomial?
15:27:20 <xerox> Or maybe one can derive a bit mask to match...
15:27:32 <monochrom> '\a' is the bell
15:27:40 <monochrom> ('a' for 'alert')
15:27:45 <monochrom> or alamr
15:27:48 <xerox> Right.
15:28:02 <ndm> SamB_XP: I can do all of that already, I had to do stuff like playing with authorized_keys file and permissions on the haskell server to get the Yhc repo running
15:28:09 <xerox> Any ideas about the latter, question, monochrom?
15:28:19 <monochrom> I'm so old and wise, I actually know these tidbits of the last century!
15:28:25 <SamB_XP> ndm: whats so hard about pasting stuff into a file?
15:28:27 <xerox> hehe
15:28:44 <ndm> SamB_XP: not knowing the format of the file, its location, or its permissions (all sovled now)
15:29:04 <ndm> for a brief period i actually removed my key from my authorized_keys file, and put in other peoples instead
15:29:11 <SamB_XP> none of this explains why you can only commit from work, anyway
15:29:43 <monochrom> The problem as stated can't be done, unless you're very generous about "one step".
15:29:52 <xerox> Suppose I am.
15:29:59 <ndm> ah, that was because in york my repo is in a local directory, z:\darcs
15:30:10 <SamB> will you allow <?
15:30:19 <xerox> Yeah.
15:30:28 <SamB> ndm: what about the haskell.org one?
15:30:28 <ndm> at home its not, and i was too lazy to learn how to darcs commit remotely, when i head into work most days
15:30:36 <monochrom> Method one.  Do a linear search.
15:30:43 <ndm> SamB: thats brand new, and i'm still learning :)
15:30:48 <xerox> Like x `elem` [...] ?
15:31:08 <xerox> I was trying to avoid that.  But it is just for fun.
15:31:08 <ndm> SamB: anyway, give me a day or two and you can commit these things yourself, and i'll be able to commit from home as well
15:31:22 <monochrom> Method two.  Store the n numbers in a dictionary (bit map, BST, hash, ...).  Then query.
15:31:22 <SamB> then again, I don't even really know how to apply patches recieved via email...
15:31:29 <xerox> The numbers are: 8, 9, 10, 13, 26.
15:31:39 <xerox> It'd be allright to do it just in this special case :)
15:31:40 <ndm> save patch, darcs apply patchname.patch, darcs push
15:31:55 <SamB> ndm: sounds a pain
15:32:08 <ndm> not really, takes much longer to read the patches than to apply them
15:32:12 <SamB> too bad you can't just drop it onto the xterm to "darcs apply" it...
15:32:32 <ndm> yeah, that would be nice
15:32:42 <SamB> maybe its okay on windows, I dunno
15:32:59 <ndm> i use that method for all my projects though, even for my patches (darcs send at home, darcs apply at work)
15:33:53 <SamB> huh
15:34:34 * SamB should like to send patches to the list, but they likely depend on not-yet-committed ones...
15:35:20 <ndm> SamB, just for review, or for committing?
15:35:38 <ndm> if its just for review, mark them as such, and people can review them in the abstract
15:35:57 <SamB> because I think they are cool?
15:36:51 <monochrom> If the n numbers are known and all of them are small, I go with the bit map.
15:37:07 <xerox> monochrom: how do you go to produce it?
15:37:09 <ndm> SamB, am just learning how to do the pull, comment
15:37:24 <SamB> ??
15:37:27 <ndm> SamB, do you have a list of the patches you'd like committing? just the ones you've already sent me?
15:37:33 <ndm> * comment -> comment
15:37:36 <ndm> * commit
15:37:51 * ndm 's figures just like typing comment...
15:37:56 <ndm> * fingers!
15:38:16 <SamB> could you try that again?
15:38:25 <ndm> which patches do you want committing?
15:38:36 <SamB> the ones I sent already ;-)
15:39:03 <ndm> ok, should have them committed in about half an hour, just doing an SSH checkout, then a test build, then an apply, then a test build, then a push
15:39:11 <ndm> on my poor old computer
15:39:24 <SamB> ... older than mine?
15:39:40 <SamB> /version SamB
15:39:41 <ndm> 6 years old
15:39:44 <waern> has anyone tried to build ghc HEAD recently?
15:40:03 <SamB> or maybe that only works on CPU nuts
15:40:12 <monochrom> if x > 32 then False else "bitwise-shift 1 by x-1 bits to the left" "bitwise-and" 33559424
15:40:41 <SamB> oh wait
15:41:01 <SamB> that doesn't show my CPU name, just the speed and such...
15:41:10 <monochrom> 33559424 = 2^7 + 2^8 + 2^9 + 2^12 + 2^25.  (Thus each i is represented by 2^(i-1).)
15:41:28 <SamB> where by "CPU name" I mean Deschutes
15:42:01 <xerox> monochrom: yarrrr.
15:42:28 * monochrom was once a shrewd Comp Eng type.
15:42:35 <SamB> anyway its a 450 MHz PII
15:43:58 <xerox> My implementation selected 6, 7, 9, 10, 13, 22. hehe
15:44:41 <ndm> I have a 750, so i guess mine is better, but still slow
15:45:55 <xerox> > (Data.Bits.shiftL 8 7 :: Int) Data.Bits..&. 33559424
15:45:57 <lambdabot>  0
15:46:47 <xerox> > let f x = (Data.Bits.shiftL x (x-1) :: Int) Data.Bits..&. 33559424 in map f [8,9,10,13,26]
15:46:48 <lambdabot>  [0,256,4096,4096,0]
15:47:34 <SamB> xerox: oops
15:47:50 <monochrom> "bitwise-shift 1 by x-1 bits to the left"
15:47:57 <xerox> Ooops indeed.
15:47:59 <monochrom> Data.Bits.shiftL 1 (x-1)
15:48:38 <xerox> Impressive.
15:49:23 * monochrom was once a shrewd Comp Eng type.
15:49:36 <xerox> monochrom++ ;)
15:49:47 <SamB> @karma monochrom
15:49:48 <lambdabot> monochrom has a karma of 7
15:54:19 <moonlite> how do i write data to stderr with haskell?
15:55:22 <kpreid> hPrint stderr
15:55:22 <monochrom> import IO
15:55:31 <monochrom> Perfect timing
15:56:25 <dibblego> does lambdabot have a function to convert a list comprehension to a map/filter?
15:56:43 <dibblego> can *any* list comprehension be converted to map/filter?
15:57:15 <damkor> hi there
15:57:15 <SamB> moonlite: if you want to write strings, you just
15:57:28 <SamB> hPutStrLn stderr "eek!"
15:57:39 <ndm> SamB, still 200 patches to pull...
15:57:46 <SamB> ndm: eek!
15:57:48 <ndm> dibblego: no, they are converted to fold's
15:58:02 <ndm> SamB, we need to tag, and not pull over ssh - i have bugs filed for all those issues
15:58:02 <SamB> how long does that take?
15:58:07 <ndm> ages....
15:58:19 <SamB> ... you are using Cygwin?
15:58:21 <damkor> I'm having a problem with Latex using Literal Haskell in a Happy Parser (this could be called literal happy, I guess)
15:58:27 <damkor> the problem is that, if I define a token as >    mytoken     { MyToken $$ }
15:58:27 <damkor> latex blames about the $$ thing
15:58:28 <dibblego> ndm, then can lambdabot do that conversion?
15:58:28 <ndm> no, native
15:58:43 <SamB> you probably should have darcs got from http...
15:58:43 <ndm> dibblego: not as far as i know, but Yhc can (just pass -core)
15:58:54 <ndm> i know, but want to test the ssh roundtripping
15:58:59 <SamB> (I think its faster)
15:58:59 <ndm> anyway, back later
15:59:22 <dibblego> wtf is Yhc?
15:59:31 <SamB> doesn't darcs fork an SCP for every file it grabs?
15:59:46 <dcoutts> Yet another Haskell Compiler ? ;-)
15:59:47 <SamB> (or platform equivalent?)
15:59:54 <SamB> dcoutts: that was my guess to
15:59:58 <SamB> but no, the Y is for York
16:00:33 <dcoutts> dibblego, it's a deriviative of nhc that is now developed by york & ex-york students
16:00:40 <SamB> also me
16:00:46 * SamB is neither
16:01:00 <dcoutts> oh good, glad it's gathering more contributers
16:01:22 <dibblego> is that a compiler?
16:01:26 <SamB> I'm trying to clean some of the code up so it can be understood by mere mortals with their weak support for lexical scoping
16:01:37 <SamB> dibblego: yes
16:01:47 <dibblego> why Yhc when there is ghc?
16:02:00 <SamB> why nhc when there is ghc?
16:02:02 <LiquidEngineer> Hello
16:02:07 <dibblego> dunno why?
16:02:09 <SamB> anyway Yhc has portable bytecode
16:02:15 <SamB> dunno about nhc
16:02:21 <SamB> (nhc is dead, btw)
16:02:39 <Igloo> Has someone told Malcolm?
16:02:53 <SamB> well, maybe it is only mostly dead
16:02:59 <SamB> but isn't Miracle Max dead anyway?
16:03:12 <LiquidEngineer> If I have a module C that imports B, and B imports A, I should be able to get at the definitions inside A from C without a problem, yes?
16:03:24 <SamB> LiquidEngineer: um, no!
16:03:30 <LiquidEngineer> why not?
16:03:31 <LiquidEngineer> :(
16:03:48 <SamB> you'd need to import A or have module B export "modula A"
16:03:57 <LiquidEngineer> ah
16:03:57 <SamB> er, "module A"
16:04:03 <xerox> G'night.
16:04:06 <LiquidEngineer> I thought they'd be chained.
16:04:09 <LiquidEngineer> but that makes sense
16:04:27 <dibblego> on http://haskell.org/haskellwiki/Yhc the "Options" link is screwy
16:04:29 <lambdabot> Title: Yhc - HaskellWiki
16:04:49 <SamB> so, e.g., "module B (module A, module B) where" to export all of module A from module B, as well as anything defined in module B
16:05:25 <SamB> ("module Foo where" does the same thing as "module Foo (module Foo)")
16:05:32 <SamB> er, with a where...
16:05:43 <monochrom> don't worry about where.
16:06:29 <waern> Igloo, I'm getting a strange error when building ghc HEAD today
16:07:23 <waern> Igloo, something about bad interface files when building Data.List with the stage1 compiler
16:07:47 <Igloo> waern: Did you start from a clean tree?
16:07:53 <waern> Igloo, yep
16:08:06 <Igloo> Can you give me more details?
16:08:09 <gmh33> !hoogle lambdabot
16:08:14 <waern> Igloo, wait a minute...
16:08:17 <gmh33> @hoogle lambdabot
16:08:17 <lambdabot> No matches found
16:08:24 <gmh33> o_o
16:09:09 <waern> Igloo, I had to restart my macbook, I'll give you the exact error message later. It was something about unfolding zipWith
16:09:28 <Igloo> Oh, wait, the HEAD, not the 6.6 branch?
16:09:33 <waern> Igloo, yep
16:09:43 <Igloo> OK, it could well just be broken then
16:09:49 <waern> yeah :)
16:11:36 <waern> Igloo, I'd like to commit my ghc.haddock patch, but now I can't :(
16:11:41 <LiquidEngineer> thanks, guys
16:11:52 <LiquidEngineer> I finally have imports working right under EclipseFP
16:12:02 <LiquidEngineer> (EclipseFP has sucktastic directions.)
16:13:34 * Igloo throws things at bd
16:13:39 <Igloo> gdb, IM
16:13:45 <Igloo> (gdb) info address bd
16:13:45 <Igloo> Symbol "bd" is a variable with complex or multiple locations (DWARF2).
16:13:47 <Igloo> Gee, thanks
16:13:52 <gmh33> where's the bf interpretter source for lambdabot?
16:15:05 <monochrom> complex locations?  Like 0xdeadbeef + i * 0xcafebabe ?  XD
16:15:55 <kpreid> @version
16:15:56 <lambdabot> lambdabot 4p233, GHC 6.5 (OpenBSD i386)
16:15:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:16:00 <kpreid> gmh33:
16:16:31 <musasabi> is there a better way to do this: strictLines :: ByteString.Lazy -> [ByteString]; strictLines = map toStrict . lines ?
16:17:01 <dcoutts> musasabi, that's fairly good I'd say.
16:18:11 <dcoutts> musasabi, only thing that'd be faster is mmaping a strict byte string
16:18:16 <dcoutts> I reckon
16:21:57 <lispy> alright, time to find out why i can profile helloworld but not my app
16:22:03 <lispy> i suspect it is because fo the C bits
16:22:13 <lispy> so...i guess i 'll try that hypothesis first
16:22:59 <waern> Igloo, the error message says "Can't find the interface-file declaration for variable GHC.List.foldr2". It is some problem with a rule for zipWith
16:24:08 <Igloo> waern: I have no idea about the HEAD ATM
16:25:49 <ndm> Igloo: we are working on telling Malcolm about nhc :)
16:26:09 <ndm> SamB, finally pulled, now wait while i build....
16:27:53 <dibblego> let f1 = length . filter (< 5); f2 = foldr (\x y -> if x < 5 then y + 1 else y) 0 -- which is better?
16:28:04 <dcoutts> ndm, do people still pretend that nhc works ?
16:28:25 <mauke> dibblego: f1
16:28:32 <dibblego> mauke, why?
16:28:42 <mauke> easier to read/understand
16:28:56 <dibblego> but does it perform worse?
16:29:01 <SamB> heh
16:29:13 <mauke> if it's easier to understand, the compiler should be able to optimize it better
16:29:18 <SamB> hehehe
16:29:40 * SamB likes mauke's logic ;-)
16:29:45 <dibblego> I don't
16:29:51 <SamB> considering the compiler is written by humans...
16:29:55 <dcoutts> sadly I don't think it's true
16:30:00 <dibblego> "easier to understand" is relative to the observer
16:30:12 <dibblego> not the compiler
16:30:16 <SamB> mmm
16:30:33 <dibblego> one observer can plausibly argue in favour of f2 being "easier to understand"
16:30:41 <SamB> I think not!
16:30:51 <mauke> I'd like to see that observer
16:30:52 <dibblego> then you are not that observer
16:30:55 <SamB> only if they run on C!
16:31:07 <SamB> or Lisp or something!
16:31:11 <mauke> f1 is shorter, it must be faster
16:31:15 <SamB> heh
16:31:15 <dcoutts> dibblego, actually with a decent fusion system the performance of the two should be identical
16:31:21 <dibblego> dcoutts, that's my guess
16:31:26 <SamB> dcoutts: see, that is what we were hoping ;-)
16:31:35 <SamB> we like to be optimistic about these things
16:31:39 <dcoutts> sadly the current build/fold fusion system cannot fuse that example
16:31:51 <dcoutts> though the streams fusion system can
16:31:52 <SamB> and if we are wrong we like to blame the compiler author
16:32:02 <mauke> @type foldr (\x y -> if x < 5 then y + 1 else y) 0
16:32:04 <lambdabot> forall a b. (Ord a, Num a, Num b) => [a] -> b
16:32:16 <mauke> ah, d'oh
16:32:20 <SamB> write the code you will be able to read, please ;-)
16:32:36 <psi> dons: What's the url to the irc client you were writing for a tutorial?
16:32:38 <dcoutts> on ByteStrings that example will fuse
16:33:09 <mauke> doesn't foldr queue up a huge list of thunks?
16:33:09 <dibblego> dcoutts, which would you use? it seems there is a trade-off between "what many accept as readable" versus "what compiler technology currently exists"
16:33:33 <dcoutts> dibblego, I would use f1
16:33:49 <dibblego> with the optimistic forecast that such a compiler will exist one day soon?
16:33:55 <lispy> i'd use f1 as welll
16:33:56 <dcoutts> it exists now
16:34:00 <fasta> dibblego: I wouldn't care about it, until you know it's too slow.
16:34:20 <dibblego> fasta, I'm erring on that side as well
16:34:39 <dibblego> dcoutts, ghc?
16:34:40 <dcoutts> mauke, sometimes that's the right thing to do
16:34:44 <dcoutts> dibblego, yes
16:34:56 <mauke> dcoutts: surely not with (+ 1)?
16:35:03 <fasta> dibblego: you can write your own Sufficiently Smart Compiler of course.
16:35:13 <dcoutts> mauke, eg if the result can be built & consumed lazily. So indeed, not (+1).
16:35:20 <dibblego> then what do you mean when "dcoutts> sadly the current build/fold fusion system cannot fuse that example" ?
16:36:01 <dcoutts> dibblego, that's an issue of the rules used in the standard library. the ByteString library uses the same compiler and uses different rules and can fuse your example.
16:36:12 <fasta> dibblego: they have some system based on GHC RULES, which in turn is an evil hack for programmable rewrite strategies.
16:36:21 <dcoutts> dibblego, the fusion system currently used for lists can't fuse that example.
16:36:22 <dibblego> ah ok thanks
16:36:32 <dcoutts> so it's an issue of libs, not the compiler
16:37:38 <dcoutts> fasta, it's not an evil hack, it's cool! :-)
16:38:04 <fasta> dcoutts: We had this discussion before. The rules system is not optimal.
16:38:15 <SamB> fasta: non-optimal != evil
16:38:20 <fasta> dcoutts: I do like that you still used it in a sane way.
16:38:26 <fasta> SamB: true
16:38:49 <dcoutts> fasta, oh yeah, macros
16:38:54 <SamB> heh
16:39:00 <SamB> macros?
16:39:03 <SamB> what for?
16:39:30 <fasta> dcoutts: for example, but now I was thinking more of Stratego.
16:40:15 <dcoutts> I think the rules are quite a good sweet-spot. they don't impose much compile time overhead and are still fairly expressive.
16:40:40 <dcoutts> there's more you can do with a more powerful language of course
16:40:56 <dcoutts> with the associated complexity
16:41:09 <dcoutts> ghc rules can very often be very short.
16:41:56 <dons> psi, http://www.cse.unsw.edu.au/~dons/tmp/bot.hs
16:44:10 <lispy> dons: heya...still trying to get this thing to just profile :)
16:44:56 <x3m> eval x | "!id " `isPrefixOf` x = privmsg (drop 4 x)
16:44:56 <dibblego> is that the complete source to lambdabot?
16:44:58 <x3m> whats that?
16:45:08 <lispy> which reminds me...i couldn't build wxhaskell for profiling...even after hacking the makefile things were ...not right (some problem finding a file to li nk with...)
16:45:13 <x3m> dibblego: no
16:45:47 <psi> dons: thanks
16:46:25 <dcoutts> lispy, modifying custom makefile build systems for profiling is a bit tricky.
16:46:44 <dons> x3m, its just a guard. eval x = if "!id " `isPrefixOf` x then privmsg (drop 4 x) else ...
16:47:01 <lispy> dcoutts: i did the relatively simple thing of just adding -prof -auto-all to the build, then after it installed i added the _p to all the installed files
16:47:09 <dons> dibblego: hehe. that would be fun if lambdabot was really only 80 loc
16:47:25 <lispy> dcoutts: but something about the way it places some .a files in the ghc tree didn't like that
16:48:12 <dibblego> yesterday I showed a sudoku solver that was 20 or so lines, then the perl response was 3 lines -- I'm sure you can reduce "noise" (e.g. function names) and do the same in haskell
16:48:24 <x3m> dons oki
16:48:52 <lispy> 3 lines?
16:49:03 <dibblego> yes, perl functions are one character
16:49:12 <dibblego> @#%$#&&*$^&%$@#@~#$%$%&&*& is an IRC bot probably
16:49:12 <lambdabot> Unknown command, try @list
16:49:28 <SamB> dibblego: you mean sigils?
16:49:28 <psi> :)
16:49:45 <lispy> dibblego: i used to pipe /dev/random to perl and sometimes i wouldn't get a syntax error right away :)
16:49:59 <fasta> If there's no bound on the length of a line, I can write an OS on one line.
16:50:06 <mauke> @# % $# && *$ ^ &% $ <-- syntax error here
16:50:07 <lambdabot> Maybe you meant: . v
16:50:13 <dibblego> fasta, the perl solution was 72 characters
16:50:22 <mauke> $ must be the start of a term
16:50:23 <dibblego> fasta, yes, lines is a poor unit of measurement
16:50:25 <SamB> fasta: o rly!
16:50:27 <fasta> dibblego: oh, well, still I don't care :)
16:50:55 <fasta> SamB: yes, I was just expressing the same entropy level as someone interested in Perl.
16:50:58 <SamB> I contend that you will flub something and be unable to fix it because version control systems don't handle single-line programs at all well
16:53:39 <fasta> SamB: There exist OS's written in Lisp. Since newlines don't matter in that language, I could automatically transform one such OS and be done.
16:53:46 <dibblego> I am going to build lambdabot and put it on a #java channel :)
16:54:18 <SamB> fasta: hmm.
16:54:26 <Tman> how does one run haskell programs on linux?
16:54:37 <lispy> Tman: which distro of linux?
16:54:39 <SamB> fasta: you are assuming that said OS is in one source unit.
16:54:43 <mauke> ghc or hugs
16:54:52 <Tman> lispy: gentoo
16:54:57 <mauke> emerge ghc-bin
16:54:57 <dibblego> /usr/bin/runhaskell
16:55:06 <fasta> SamB: no
16:55:17 <Tman> excellent
16:55:30 <Tman> thanks ;)
16:55:31 <lispy> fasta: i'm with you up to the point of inline asm
16:55:43 <lispy> fasta: i don't know a single lisp that does inline asm
16:55:47 <SamB> fasta: what meaneth you?
16:55:51 <lispy> (unless i'm wrong about one...)
16:55:56 <Tman> mauke: why the -bin?
16:56:06 <SamB> you have a program to automatically take out all considerations of building?
16:56:35 <ndm> dcoutts, only two people i can think of, but no, i think the rest of the world knows
16:56:46 <dibblego> http://rafb.net/paste/results/9f6BVs39.html what am I doing wrong?
16:56:54 <mauke> Tman: because ghc is written in haskell so you need a haskell compiler to compile ghc
16:57:02 * Tman cries
16:57:18 <fasta> lispy: I think Movitz doesn't use inline asm.
16:57:22 <SamB> mauke: doesn't it have to *be* GHC?
16:57:24 <dcoutts> ndm, ok, I was wondering because I keep seeing people mention it as if it still worked, eg in relation to reorganising the base package.
16:57:26 <mauke> yeah, that too
16:57:40 <mauke> you can always emerge ghc, then unmerge ghc-bin later
16:57:47 <Tman> :p
16:57:48 <Tman> cool
16:57:53 <Tman> thanks then
17:11:50 <SamB> ndm: how goes the building?
17:11:51 <dons> Tman: here, http://haskell.org
17:11:51 <lambdabot> Title: Haskell - HaskellWiki
17:11:51 <dons> then look at the 'Haskell in 5 steps' page
17:11:51 <ndm> dcoutts, i think its people who remember nhc, not who use nhc
17:11:51 <dcoutts> right
17:11:51 <ndm> SamB, am just applying
17:11:51 <araujo> hi hi!
17:11:51 <dcoutts> hia araujo
17:11:51 * araujo throws sugar lambdas at everyone
17:11:51 <araujo> dcoutts!!
17:11:51 <SamB> ooooooo
17:11:51 <SamB> suuuuuuuugaaaaaar!
17:11:51 <araujo> delicious!!!
17:11:51 <SamB> actually it probably hurts my teeth
17:11:51 <monochrom> Don't chew. Just swallow.
17:11:51 <ndm> syntactic sugar gives you cancer of the colon
17:11:51 <araujo> sugar lambda is highly healthy.
17:11:51 <araujo> No side effects.
17:11:51 <araujo> :-)
17:11:51 <lispy> heh
17:11:51 <SamB> araujo: are other oxymorons?
17:11:51 <araujo> haha
17:11:51 * araujo loves this stuff
17:11:51 <psi> Hm, why does printf "%d\n" (1::Int) give me unresolved overloading?
17:11:51 <araujo> dcoutts, knows a tuto to make haskell libs?
17:11:51 <SamB> psi: because you haven't specified what type printf should "return"
17:11:51 <SamB> > printf "%d\n" (1::Int)
17:11:51 <lambdabot>  Add a type signature
17:11:51 <monochrom> because it may be IO a, or it may be String.
17:11:51 <dcoutts> araujo, find an existing one and copy? :-)
17:11:51 <SamB> > printf "%d\n" (1::Int) :: String
17:11:51 <lambdabot>  "1\n"
17:11:51 <Taral> @type printf
17:11:51 <lambdabot> forall r. (PrintfType r) => String -> r
17:11:51 <Taral> AAAAAAAAAAAAAAAAAAAAAAA!
17:11:51 <araujo> dcoutts, ok, gtk2hs comes to mind :-)
17:11:51 <SamB> @type printf "%d\n" (1::Int)
17:11:51 <lambdabot> forall t. (PrintfType (Int -> t)) => t
17:11:51 * Taral runs away from the type-level computation.
17:11:51 <psi> SamB: oh, ok
17:11:51 <dcoutts> araujo, that's probably a bit big
17:11:51 <mauke> > printf "%d\n" 1 :: String
17:11:51 <lambdabot>  Add a type signature
17:11:51 <Taral> @type printf "%d\n"
17:11:51 <lambdabot> forall r. (PrintfType r) => r
17:11:51 <SamB> Taral: why screamest though?
17:11:51 <dcoutts> araujo, you can look at my zlib binding, that's nice and small
17:11:51 <araujo> dcoutts, my concern is about how to generate the libs ...
17:11:51 <SamB> er, thou
17:11:51 <fasta> I see we have a grand total of 1 consultants for Haskell.
17:11:51 <dons> ?type printf "%s" "foo"
17:11:51 <araujo> dcoutts, link?
17:11:51 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
17:11:51 <dcoutts> araujo, using Cabal!
17:11:51 <SamB> fasta: who?
17:11:51 <dons> ?type printf "%s" "foo" 'x'
17:11:51 <lambdabot> forall t. (PrintfType ([Char] -> Char -> t)) => t
17:11:51 <dcoutts> @where zlib
17:11:51 <lambdabot> I know nothing about zlib.
17:11:51 <fasta> http://haskell.org/haskellwiki/Consultants
17:11:51 <lambdabot> Title: Consultants - HaskellWiki
17:11:51 <Taral> Because type-level computation is scary.
17:11:51 <ndm> fasta: if you have money, i'm sure most people here will "consult" if required
17:11:51 <dons> ?type printf "%s" "foo" 'x' :: String
17:11:51 <dcoutts> @where bzlib
17:11:51 <lambdabot> String :: String
17:11:51 <lambdabot> I know nothing about bzlib.
17:11:51 <dcoutts> bah
17:11:51 <araujo> dons, ok . nice
17:11:51 <mauke> > printf "%s" 1 :: String
17:11:51 <lambdabot>  Add a type signature
17:11:51 <SamB> what is shapr doing lately?
17:11:51 <dcoutts> @where Codec.Compression.GZip
17:11:51 <lambdabot> I know nothing about codec.compression.gzip.
17:11:51 <mauke> > printf "%s" (1::Int) :: String
17:11:51 <lambdabot>  Exception: Printf.printf: bad argument
17:11:51 <araujo> hah
17:11:51 <mauke> > printf "%s" "" "" :: String
17:11:51 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
17:11:51 <dcoutts> araujo, http://haskell.org/~duncan/zlib/
17:11:51 <lambdabot> Title: Index of /~duncan/zlib
17:11:51 <araujo> dcoutts, thanks youuu!
17:11:51 <monochrom> Why do you like to experiment with the wrong?
17:11:51 * dcoutts wonders who monochrom is talking to
17:11:51 <fasta> ndm: oh, well, it was just something I can imagine a company could see as a disadvantage of Haskell..
17:11:51 <araujo> dcoutts, nice , i didn't know about this .. is it new stuff?!
17:11:51 <mauke> > chr (-1)
17:11:51 <lambdabot>  Exception: Prelude.chr: bad argument
17:11:51 <SamB> dcoutts: mauke
17:11:51 <dcoutts> ah, printf
17:11:51 <SamB> see all the " Exception:" lines?
17:11:51 <mauke> they're mine
17:11:51 <mauke> all of them.
17:11:51 <monochrom> I am talking to mauke
17:11:51 <dcoutts> mauke, mwahahah?
17:11:51 <ndm> SamB, now pushing :)
17:11:51 <\z> has anyone here had any success in building ghc on osx-intel?
17:12:02 <\z> (or any tips for bootstrapping it from *.hc files)
17:12:19 <musasabi> hmm. splitting lines got quite complex. http://youzen.b2.fi/~musasabi/splitLines.hs
17:13:31 <musasabi> "split all lines on CR?LF until an empty line is encountered"
17:19:58 <ndm> SamB, absolutely no luck committing, i get a timeout every time :(
17:20:34 <SamB> eek!
17:20:43 <ndm> even just trying to push the first patch, it fails with a timeout
17:20:45 <SamB> something wrong with haskell.org?
17:20:50 <ndm> i have no idea
17:20:59 <ndm> i've never done it from this computer, but have with my work one
17:21:08 * SamB tries sshing to darcs.haskell.org
17:21:12 <ndm> it successfully downloads 4 files first, before deciding what to push
17:21:17 <SamB> oh
17:21:18 <ndm> so haskell.org seems to work fine
17:21:19 <SamB> huh
17:21:25 <ndm> SamB, you have a darcs.haskell.org account?
17:21:30 <SamB> no!
17:21:47 <SamB> but I thought maybe the sshd was not responding
17:22:00 <ndm> either the patch is going crazy trying to recompute stuff, which is causing a timeout
17:22:05 <ndm> or this machine is having issues
17:22:12 <ndm> it definately worked at work yesterday
17:22:14 <waern> Igloo, HEAD builds when removing the latest SPJ patch that deals with rules
17:22:50 <SamB> what sort of machine do you have at work?
17:23:00 <ndm> a faster one, on a faster network connection
17:23:14 <ndm> really fast network
17:23:25 <ndm> but different software versions for loads of things, one of which may be at fault
17:23:53 <SamB> what did you mean about multiplexing off your account?
17:24:03 <ndm> i add you all to my authorized_keys file
17:24:08 <ndm> then you can log in as me
17:24:13 <SamB> okay
17:24:20 <SamB> so how about you add me now?
17:24:27 <ndm> i guess i can try that
17:24:53 <dibblego> http://rafb.net/paste/results/9f6BVs39.html can anyone tell me why lambdabot is not compiling?
17:25:27 <ndm> SamB, no, i can't, connection times out trying to log in
17:25:33 <SamB> eek
17:25:37 <SamB> so where is it getting those files?
17:25:50 <ndm> SamB, not entirely sure how it downloaded the files... - seem it must not use the ssh, or does something else somehow
17:26:12 <ndm> @seen Igloo
17:26:12 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 28m 33s ago.
17:26:29 <dibblego> dons, are you about? I'm stuck on compiling lambdabot
17:26:29 <ndm> can anyone log into darcs.haskell.org ?
17:26:48 <SamB> dons: can you log in?
17:26:51 <Igloo> I can
17:27:11 <SamB> Igloo: do you have root?
17:27:22 <Igloo> No
17:27:35 <blsecres> anyone know of an open implementation of Gaussian elimination?  All I've found via google is some sample code on a Scottish doctoral student's website
17:27:46 <ndm> oh, crap, misplaced a radio button, and it was trying to log in via telnet...
17:27:55 <SamB> heh
17:29:05 * Igloo gets irritated with gdb
17:29:48 <SamB> Igloo: that is fairly normal, isn't it?
17:29:52 <ndm> SamB, darcs push neil@darcs.haskell.org:/home/darcs/yhc
17:30:02 <ndm> SamB, with your private key loaded
17:30:17 <mwc> blsecres, gaussian elimination? Just do row-wise mapM_'s in your (Int,Int) indexed MArray
17:30:27 <mwc> @type mapM_
17:30:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
17:32:01 <ndm> SamB, any luck?
17:32:02 <mwc> blsecres, you probably want to use something called partial pivoting, not straight up GE
17:32:12 <SamB> ndm: yes!
17:32:20 <SamB> took a bit though
17:32:37 <ndm> SamB, hmm, weird, but you can now push properly?
17:32:59 <SamB> actually I haven't finished picking patches yet
17:33:06 <ndm> i could pick patches fine
17:33:12 <ndm> it was only after that it failed
17:33:17 <dons> ndm, checking if i can log in...
17:33:19 <ndm> even if i only selected the first patch
17:33:29 <blsecres> mwc: OK, thanks, all the chemistry texts refer to Gaussian elimination for balancing reactions
17:33:30 <ndm> dons: i figured it out, was trying to log in via telnet...
17:33:33 <dons> yes, I can log in.
17:33:34 <dons> heh
17:33:41 <ndm> a misplaced radio button
17:33:42 <dons> that's funny, ndm :)
17:33:57 <dons> in putty or something?
17:34:02 <SamB> ndm: okay it worked ;-)
17:34:09 <SamB> dons: yeah
17:34:09 <mwc> blsecres, Guassian elimination is a way to solve linear systems. I see how it would be applicable to balancing reactions
17:34:23 <ndm> SamB, woot!
17:34:38 <ndm> dons: yep, had accidentally switched the radio button, and never thought to check
17:34:49 <dibblego> http://rafb.net/paste/results/buMkMC66.html are there a bunch of dependencies of lambdabot?
17:35:05 <ndm> SamB, well from now on commit as you feel like, send anything you're not sure on via the mailing list :)
17:35:43 <lispy> dibblego: did you follow the readme?
17:35:51 <dons> dibblego: those messages are harmless
17:35:52 <dibblego> lispy, yes
17:36:05 <dons> but it does look like you're trying to build an old stable branch?
17:36:05 <SamB> ndm: this is the same machine as a lot of pugs stuff runs on?
17:36:09 <lispy> dibblego: did you get hs-plugins?
17:36:16 <dibblego> lispy, but I wasn't sure about the "Build the Data.ByteString library" part
17:36:18 <dons> dibblego: better to just pull the darcs repo, if you can
17:36:28 <dibblego> lispy, no, it's not in the README
17:36:36 <ndm> SamB, aboslutely no idea
17:36:43 <dibblego> dons, I'll give it a burl
17:36:47 <SamB> it calls itself "monk"
17:36:48 <ndm> SamB, not as far as i know though
17:36:52 <SamB> the name sounds familiar...
17:37:09 <ndm> no, Perl Monk's is something else
17:37:33 <lispy> dibblego: dons is right, build from the darcs and it should be better (and the readme is newer)
17:37:51 <dibblego> ok
17:38:00 <lispy> grrr
17:38:06 <ndm> anyway, filter (not . isAwake) me - bye
17:38:17 <dibblego> darcs get --partial http://www.cse.unsw.edu.au/~dons/lambdabot ?
17:38:17 <lambdabot> Title: Index of /~dons/lambdabot
17:38:28 <SamB> []
17:39:03 <dons> ?version
17:39:04 <lambdabot> lambdabot 4p233, GHC 6.5 (OpenBSD i386)
17:39:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:44:37 <dibblego> so I build Data.ByteString, but what do I do with it?
17:46:35 <dons> dibblego: you build and install it, as per the instructions
17:47:25 <dibblego> the instructions = http://www.cse.unsw.edu.au/~dons/code/fps/README ?
17:47:27 <lambdabot> http://tinyurl.com/eweyz
17:48:02 <dons> there should be a README with fps. just follow the usual cabal-based build steps
17:48:18 <dibblego> ok, but I am completely unfamiliar with cabal
17:48:18 <kpreid> dons: did you look at including Data.Generics yet? :)
17:48:27 <dons> doing so now
17:48:44 <kpreid> (it's not really important, I just want to show off something)
17:50:11 <glguy> is there anything like WinHugs for Linux?
17:52:52 <monochrom> What is special about WinHugs?
17:53:18 <glguy> I can do things like :f someFunction and it opens that in a text editor, for one
17:53:25 <glguy> it's got pretty little buttons at the top
17:53:32 <glguy> stuff like that
17:53:39 <glguy> just asking :)
17:53:56 <monochrom> Nothing similar on Linux yet.
17:54:07 <mauke> does it run in wine?
17:54:13 <glguy> I was just thinkingabout that
17:54:21 <dons> we could bug ndm about portability .... ;)
17:54:25 <monochrom> I am not sure whether Eclipse counts.
17:54:28 <glguy> I don't want to use it that badly to use wine :)
17:54:38 <glguy> hmmm, eclipse sounds potentially reasonable
17:54:43 <dibblego> how long does it take for lambdabot to build?
17:54:46 <dons> kpreid: ok, go ahead. should be there now.
17:54:51 <dons> dibblego: 2 mins?
17:54:52 <dons> less?
17:54:54 <glguy> any change it has the ability to show types on hover???
17:55:04 <dibblego> dons, my machine must be slow
17:55:30 <monochrom> I don't recall seeing types on hover.
17:55:59 <kpreid> @let unS = map fst . filter (null . snd)
17:56:01 <lambdabot> Defined.
17:56:23 <kpreid> @check \x -> (unS . reads x) == (read x)
17:56:24 <lambdabot>  Not in scope: `unS'
17:56:28 <dons> L.unS
17:56:29 <kpreid> @check \x -> (L.unS . reads x) == (read x)
17:56:30 <lambdabot>    Expecting a function type, but found `[(a, String)]'       Expected type...
17:56:39 <kpreid> @check \x -> (L.unS $ reads x) == (read x)
17:56:40 <glguy> L.usS $
17:56:41 <lambdabot>  Add a type signature
17:56:45 <dons> oh, I didn't add the generics to @check
17:56:45 <glguy> heh
17:56:48 <dons> do you need that?
17:56:59 <dons> (only to @run)
17:57:05 <kpreid> unS is a preliminary definition, I just figured I'd test it
17:57:06 <glguy> are the generics the default instance thing?
17:57:08 <kpreid> no, I don't need it
17:58:11 <kpreid> @let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r
17:58:12 <lambdabot> <local>:5:6: Not in scope: type constructor or class `Data'  <local>:5:52: No...
17:58:22 <dibblego> 8 minutes later, the build failed
17:58:23 <dons> ah
17:58:35 <dibblego> does ./build need to run as root?
17:58:38 <dons> kpreid: some more things for me to tweak :)
17:58:44 <dons> dibblego: nope.
17:58:54 <kpreid> dons: is that a @let bug or will it fail in @run too?
17:58:58 <dibblego> dons, it tried to copy to /usr/local/bin/BotPP
17:59:25 <dibblego> *** Exception: /usr/local/bin/BotPP: copyFile: permission denied (Permission denied)
17:59:48 <dons> kpreid: run should work. let also needs 'Generics' in scope. fixing that.
18:00:23 <kpreid> > let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r in [rc "True", rc "\"a\"", rc "bang"] :: [Either Bool (Either String ())]
18:00:24 <lambdabot>  Not in scope: `rc'
18:00:41 <kpreid> > let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r in [rg "True", rg "\"a\"", rg "bang"] :: [Either Bool (Either String ())]
18:00:42 <lambdabot>  Not in scope: `unS'
18:00:53 <kpreid> > let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (L.unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r in [rg "True", rg "\"a\"", rg "bang"] :: [Either Bool (Either String ())]
18:00:56 <lambdabot>  [Right (Right ()),Right (Left "a"),Right (Right ())]
18:01:01 <dons> :)
18:01:07 <kpreid> *sigh*. TEST
18:01:15 <kpreid> or rather, don't copy the wrong code in
18:01:22 <kpreid> > let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (L.unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r in [rg "(True)", rg "\"a\"", rg "bang"] :: [Either Bool (Either String ())]
18:01:26 <lambdabot>  [Left True,Right (Left "a"),Right (Right ())]
18:01:28 <dibblego> dons, is it right that the build tries to write to /usr/local/bin ?
18:01:29 <kpreid> there :)
18:01:39 <dons> dibblego: nope. should be in the pwd
18:01:42 <dons> check the build script.
18:01:44 <dons> kpreid: nice!
18:01:46 <kpreid> it's a read union defined by the result type without typeclasses
18:01:57 <dons> tricky!
18:02:27 <kpreid> it'll work with any types whose constructors are isomorphic to Either and (), too :)
18:02:40 <jgrimes> happy isn't including one of my token constructors in a case statement, so when type checking it fails since it is expecting a String and gets a Token. Any ideas as to why this might happen?
18:02:48 <dibblego> dons, ./build --bindir=`pwd` ?
18:03:09 <dons> dibblego: look at the build script. it should have: nice ./Setup.hs configure --bindir=`pwd`
18:03:17 <dibblego> dons, yes it does
18:03:29 <dons> ?undefine
18:03:31 <lambdabot> Undefined.
18:03:38 <dons> kpreid: want to try with @let now?
18:03:43 <dons> I think it should work.
18:03:53 <kpreid> @let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (L.unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r
18:03:54 <lambdabot> <local>:1:138: Not in scope: `L.unS'
18:04:02 <kpreid> @let unS = map fst . filter (null . snd)
18:04:03 <lambdabot> Defined.
18:04:05 <kpreid> @let rg :: (Data a) => String -> a; rg s = let r = case (dataTypeConstrs . dataTypeOf) r of [c] -> fromConstr c; [hc,tc] -> head (fromConstrM (L.unS (gread s)) hc ++ [fromConstrB (rg s) tc]) in r
18:04:06 <lambdabot> Defined.
18:04:16 <kpreid> ? rg "1" :: Either Int ()
18:04:18 <kpreid> > rg "1" :: Either Int ()
18:04:20 <lambdabot>  Not in scope: `rg'
18:04:32 <dons> L.
18:04:34 <Bourbaki> moin
18:04:39 <kpreid> > L.rg "1" :: Either Int ()
18:04:41 <lambdabot>  Right ()
18:05:22 <kpreid> > L.rg "(1)" :: Either Int ()
18:05:24 <lambdabot>  Left 1
18:05:25 <dons> kpreid: that's fun. you should write a wiki page on it (or a tmr article)
18:05:26 <kpreid> gread has odd rules
18:05:58 <kpreid> > (gread . gshow) ()
18:05:59 <lambdabot>  Add a type signature
18:06:07 <kpreid> > (gread . gshow) () :: []
18:06:08 <lambdabot>    `[]' is not applied to enough type arguments
18:06:08 <lambdabot>   Expected kind `?', but ...
18:06:10 <kpreid> > (gread . gshow) () :: ()
18:06:11 <lambdabot>  Couldn't match `()' against `[(a, String)]'
18:06:16 <kpreid> > (gread . gshow) () :: ReadS ()
18:06:17 <lambdabot>    Expecting a function type, but found `[(a, String)]'
18:06:17 <lambdabot>    Expected type...
18:06:25 * kpreid quits
18:06:50 <kpreid> dons: seems kind of trivial to me
18:07:22 <kpreid> oh, in case you haven't guessed, this was done as a reaction to not being able to do typeclass gimmicks in lambdabot eval :)
18:07:41 <dons> heh
18:08:08 <kpreid> class Union a where rc :: String -> a
18:08:08 <kpreid> instance Union () where rc _ = ()
18:08:08 <kpreid> instance (Read a, Union b) => Union (Either a b) where rc s = head ((map Left . unS . reads) s ++ [Right (rc s)])
18:08:24 <dibblego> is there a Setup.hs uninstall ?
18:08:28 <kpreid> -- same thing, sanely
18:12:27 <kpreid> dons: the idea of a non-monolithic union (sum type, I suppose I should say) definition came from the modular interpreters paper
18:13:03 <dons> i've not seen generics used for this trick before.
18:13:49 <dons> dibblego: looks like you got the bot working?
18:13:58 <dons> dibblego: it also runs in offline mode?
18:14:11 <dibblego> yeah I did thanks
18:14:18 <kpreid> I've not seen generics used before, myself. I just vaguely knew that Data.Generics did something like the kind of thing I needed
18:14:21 <dibblego> I'll rebuild it in another channel
18:14:23 <dibblego> then test it
18:14:30 <dons> dibblego: you can just test it offline, of course
18:14:44 <dons> dibblego: what are you planning to do?
18:14:52 <kpreid> I learned how to use it mostly from reading the haddock and trying things
18:15:05 <dibblego> use it in a #java channel to help some people learn some things
18:15:24 <dibblego> are there any instructions for offline mode?
18:15:29 <dibblego> lambdabot> > 1 + 1
18:15:30 <dibblego> Terminated
18:15:50 <dons> oh, that's because you've built the non-plugins version (which doesn't come with the Eval plugin)
18:15:58 <dibblego> oh
18:16:07 <dibblego> I also get "Plugin.Djinn: couldn't find djinn binary" when starting it
18:16:17 <dons> oh interesting. someone else reported that.
18:16:55 <dibblego> so building with eval requires hs-plugins to be installed or a compiler flag?
18:17:08 <dons> if you need the eval plugin, install hs-plugins, then mv the lambdabot.cabal.plugins file to lambdabot.cabal, and rebuild lambdabot
18:17:32 <dibblego> ok, I'll go figure out what/where hs-plugins is
18:17:39 <dibblego> thanks
18:17:44 <dons> ?where hs-plugins
18:17:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
18:17:54 <dons> install the 1.0 relesae candidate
18:18:08 <dibblego> that's the darcs URL I assume
18:18:29 <dibblego> or not
18:18:48 * monochrom shudders on the thought that dibblego is setting up a bot in #java to "help them learn something"
18:19:17 <dibblego> monochrom, at the very least, introduce lambda calculus
18:19:23 <dons> its a bold step, I agree :)
18:19:33 <dibblego> I'm an optimist
18:20:09 <dibblego> I have done it successfully here at work
18:20:14 <dibblego> we are a J2EE consultancy after all
18:20:16 <monochrom> That is one of the horrifying images. :)
18:20:52 <dibblego> that someone's blissful world is destroyed?
18:23:02 <dibblego> why do I have to keep chmod +x files that are in darcs or a .tar.gz? does they keep that information?
18:23:22 <kpreid> dibblego: tars do, darcs doesn't
18:23:23 <dibblego> I'd have thunk that darcs does and I'm pretty sure a .tar.gz does
18:23:39 <dibblego> ok
18:23:57 <monochrom> Apparently darcs has to be compatible with Windows too!
18:24:07 <dibblego> subversion does
18:24:15 <dibblego> and works on windows
18:24:38 <monochrom> OK I'm wrong.
18:24:39 <kpreid> subversion works by having metadata (properties) which the client interprets if it can on the current platform
18:25:10 <dibblego> right
18:25:40 <monochrom> No wonder everyone is saying "subversion >> cvs"
18:25:51 <dibblego> ?type >>
18:25:52 <lambdabot> parse error on input `>>'
18:25:57 <dibblego> ?type (>>)
18:25:58 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
18:26:04 <Thomas2_> yeah, I think we can say at this point that subversion is an improvement on cvs
18:27:33 <lennart> not having darcs restore the x flag is a real flaw in my opinion
18:28:40 <dibblego> dons, is there anything else I need to do to get eval working? > 1 + 1 gives "Terminated" after 1. installing hs-plugins 2. mv lambdabot.cabal.plugins lambdabot.cabal 2. ./build
18:28:40 <musasabi> ByteString.Lazy seems *fast* just beated my own old code with a naive rewrite.
18:29:04 <dcoutts> :-)
18:29:50 <dons> dibblego: is runplugs in the lambdabot directory?
18:29:57 <dons> musasabi: cool!
18:30:03 <dibblego> dons, no
18:30:21 <dons> musasabi: we aim for naivity :)
18:30:30 <dibblego> it is in the dist/build and dist/build/runplugs directory
18:30:44 <dibblego> it's not in the root directory I mean
18:30:48 <dons> ok, feel free to move dist/build/runplugs/runplugs into the lambdabot dir then
18:31:08 <dons> and then test it, $ ./runplugs
18:31:09 <dons> map (+1) [1..5]
18:31:09 <dons> [2,3,4,5,6]
18:31:28 <dibblego> yep
18:31:36 <dons> musasabi: what did your old code do? Ptr hacking?
18:31:37 <dibblego> do I need to build again?
18:31:52 <dibblego> I guess not, thanks
18:32:30 <musasabi> dons: yes. Ptr and manual buffer management and interleave IO here and there.
18:32:49 <dibblego> > 1 + 1
18:32:51 <lambdabot>  2
18:33:43 <dibblego> how did you get lambdabot to register to services?
18:34:16 <dons> you'll have to choose your own bot name, register it, then put the password in the State/passwd file
18:34:24 <dibblego> ok
18:34:32 <dibblego> I am not running on freenode btw
18:35:09 <dons> and in quotes, the State/passwd file would contain:   "mypasswd"
18:35:27 <dibblego> how does it know how to identify to each different network?
18:35:36 <dibblego> /msg NickServ IDENTIFY is not universal
18:36:35 <dcoutts> musasabi, is the before and after code available? it sounds like it might be a nice add that dons could stick on the fps site or something.
18:36:48 <dons> dibblego: if it requires some other kind of registering, you can manually send messages with: @msg foo bar
18:37:13 <dibblego> oh because I am an admin I guess
18:37:31 <dibblego> ok thanks
18:38:25 <musasabi> dcoutts: HAppS HTTP request parsing code. Still testing the new code but it should be in the public repo in a few days.
18:38:34 <dcoutts> musasabi, great
18:39:57 <dons> dibblego: also, logs will go into the State/log file, and State/Log/*
18:40:08 <dibblego> dons, excellent thanks
18:45:38 <dibblego> dons, fyi, it all seems to work well except for that message "Plugin.Djinn: couldn't find djinn binary"
18:46:03 <dons> right. did the djinn binary get built in dist/build/djinn ?
18:46:58 <dibblego> there is djinn (executable) and djinn-tmp (directory) in that directory
18:47:18 <dons> ok, then move the directory into the lambdabot dir
18:47:24 <dons> s/djinn binary/
18:47:31 <dons> not the directory. :)
18:47:34 <dibblego> ok
18:47:48 <dons> running ./djinn should then produce some output
18:48:02 <dons> :q to exit djinn, btw
18:48:39 <dibblego> that fixed it
18:51:56 <dolio> ?remember qwe1234 it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
18:52:54 <Adamant> that's like saying if we needed static typing, we'd all be programming in C
18:53:12 <dolio> :)
18:53:46 <dolio> Hey, everybody was programming in C at one point! :)
19:00:22 <SamB> dolio: that only reenforces the point...
19:00:38 <SamB> the two statements don't necessarily have much in common...
19:01:17 <SamB> nobody *really* wants to be programming in C, unless maybe they are programming in assembler or one of the nasties
19:02:24 <dolio> Yes, well, that guy's trolling is usually pretty uninteresting, but occasionally he hits on something pretty funny.
19:06:56 <SamB> how does he know we aren't all secretly programming in Perl, anyway?
19:07:46 <monochrom> yeah ghc was a call to a perl script
19:08:11 <SamB> you mean, ghc *was* a perl script.
19:08:18 <SamB> GHC was not ghc in those days
19:08:45 <SamB> (the perl script was also called "the driver")
19:09:06 <dgoldsmith> I tried building happy with the ghc-6.5-20060915 release for Mac OS X Intel, but it fails.
19:09:18 <SamB> dgoldsmith: @paste
19:09:27 <SamB> hmm
19:09:28 <SamB> @paste
19:09:29 <lambdabot> http://paste.lisp.org/new/haskell
19:09:32 <dgoldsmith> Ah, right just a second.
19:09:58 <SamB> I suppose lambdabot is justified in supposing that dgoldsmith might be a bot -- after all, lambdabot isn't very smart herself...
19:10:07 <lisppaste2> dgoldsmith pasted "happy build failure" at http://paste.lisp.org/display/27313
19:10:08 <SamB> (how does she know who is a bot and who isn't?)
19:10:43 <dons> she doesn't. she only knows that she's a bot.
19:10:45 <monochrom> By the Turing test.
19:11:01 <dgoldsmith> alex built just fine.
19:11:13 <SamB> dons: 'twas a rhetorical question ;-)
19:11:40 <dgoldsmith> But how would I know if I'm a bot? ;-)
19:11:42 <sjanssen> dgoldsmith: that's due to changes in the Data.Array.MArray API, it'll be a problem on any GHC 6.6 install
19:12:09 <dgoldsmith> sjanssen: Thanks. Is there a newer version of happy?
19:13:00 <hyrax42> > sum $ map read $ words "23 24 44 18 2"
19:13:02 <lambdabot>  111
19:13:08 <hyrax42> that's what I thought
19:13:16 <sjanssen> dgoldsmith: looks like there's a fix in the darcs repo
19:13:23 <SamB> so why does happy need that to build?
19:13:35 <SamB> (can you just change the Makefile or whatever?)
19:13:37 <sjanssen> dgoldsmith: darcs get --partial http://darcs.haskell.org/happy
19:13:40 <lambdabot> Title: Index of /happy
19:13:56 <dgoldsmith> OK, next I have to install darcs. :-)
19:15:00 <sjanssen> dgoldsmith: I hope you installed extra-libs for GHC?
19:15:13 <sjanssen> you'll need mtl (at least, maybe other stuff) to build darcs
19:15:32 <dgoldsmith> sjanssen: there's a binary distribution of darcs for OS X Intel. :-D
19:15:38 <dibblego> is there a way to write [2,4,6,8,10] using .. ?
19:15:50 <hyrax42> > [2,4..10]
19:15:52 <lambdabot>  [2,4,6,8,10]
19:15:52 <sjanssen> > [2, 4 .. 10]
19:15:54 <lambdabot>  [2,4,6,8,10]
19:15:58 <dibblego> thanks
19:16:15 <hyrax42> which is desugarde into
19:16:23 <hyrax42> > enumFromThenTo 2 4 10
19:16:23 <SamB> so what is the new MArray interface?
19:16:24 <lambdabot>  [2,4,6,8,10]
19:16:30 <SamB> @version
19:16:31 <lambdabot> lambdabot 4p233, GHC 6.5 (OpenBSD i386)
19:16:31 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:17:15 <hyrax42> > ['a','c'..'z']
19:17:16 <lambdabot>  "acegikmoqsuwy"
19:17:43 <dibblego> > [10,10..80]
19:17:44 <lambdabot>  [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,...
19:17:52 <dibblego> oh
19:17:56 <dibblego> > [10,20..80]
19:17:57 <lambdabot>  [10,20,30,40,50,60,70,80]
19:17:57 <hyrax42> you broked it!
19:18:34 <x3m> dons: do you know anyone who built hs-plugins with mingw?
19:18:57 <SamB> @wiki Consultants
19:18:58 <lambdabot> http://www.haskell.org/haskellwiki/Consultants
19:19:14 <SamB> x3m: look there!
19:19:15 <sjanssen> @hoogle bounds
19:19:17 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
19:19:17 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
19:19:17 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
19:19:53 <hyrax42> @fptools Data.Array.IArray
19:19:53 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/IArray.hs
19:19:59 <hyrax42> I mean
19:20:08 <hyrax42> @docs Data.Array.IArray
19:20:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-IArray.html
19:20:11 <dgoldsmith> sjanssen: OK, I did the darcs --get. The source doesn't appear to be buildable straight out of darcs, and I'm not sure how to merge it.
19:20:13 <SamB> @fptools Data.Array.MArray
19:20:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/MArray.hs
19:20:39 <dgoldsmith> Should I just snag the LALR.lhs from darcs?
19:20:55 <x3m> SamB: that dont tell me much, what am i supposed to do.. mail them?
19:21:23 <sjanssen> dgoldsmith: just: chmod +x Setup.lhs; ./Setup.lhs configure; ./Setup.lhs build; ./Setup.lhs install
19:21:40 <SamB> x3m: considering the only contact info is an email address... either email or google!
19:21:53 <dgoldsmith> sjanssen: Thanks!
19:22:35 <x3m> samb: "OM Consulting Limited omconsult@gmail.com Helped port hs-plugins to windows" why do they even write that when they dont provide any documentation/files or whatever for it
19:23:04 <SamB> alternatively ask in #perl6?
19:23:12 <x3m> huh
19:23:22 * SamB has a feeling that there might be windows users with hs-plugins in there
19:23:24 <dgoldsmith> I had to do runhaskell ./Setup.lhs as it's in /usr/local/bin on this system...
19:23:32 <x3m> oki
19:24:03 <dgoldsmith> sjanssen: it worked, thanks!
19:24:26 <sjanssen> dgoldsmith: holy crap.  You just made me realize why my cabal installation didn't seem to be working
19:25:15 <SamB> hahaha
19:25:44 <sjanssen> I always run ./Setup.hs -- but /usr/bin/runhaskell points to a broken version
19:27:34 <dgoldsmith> sjanssen: glad I was able to help you back. :-)
19:33:32 <dibblego> @paste
19:33:33 <lambdabot> http://paste.lisp.org/new/haskell
19:36:57 <mwc> Oh the netsplit, oh the humanity!
19:37:36 <dons> ?remember SyntaxNinja Let's imagine something that would be awesome.
19:42:22 <SamB> dons: did you hear x3m ?
19:42:50 * dgoldsmith is heading home...
19:43:03 <dons> I did.
19:44:57 <x3m> i remember there was someone who did long ago, not sure who it was though
19:45:18 <dibblego> is an instance of Ord always an instance of Eq ?
19:45:50 <dons> check the src
19:45:57 <x3m> can it have been shelarcy?
19:46:00 <dibblego> how can I tell?
19:46:08 <dons> class  (Eq a) => Ord a  where
19:46:12 <dibblego> I really haven't got type classes yet
19:46:14 <dons> x3m, it wsa .yes.
19:46:29 <dons> ?instances Ord
19:46:30 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
19:46:47 <dibblego> aren't there infinite possible instances? or is that just known instances?
19:47:02 <dons> there are known instances.
19:47:04 <lennart> Pseudonym: howdy, nameless one
19:47:10 <Pseudonym> G'day.
19:47:38 <dons> dibblego: types that are declared as being `instance Ord' for example :)
19:47:54 <araujo> dons, hi hi
19:48:09 <dons> hey araujo
19:48:25 <dibblego> ok ta
19:48:29 <araujo> dons, hs-plugins stable version 0.9 , is currently broken on amd64 right?
19:48:47 <Pseudonym> Actually, "nameless" would be "ochinym".
19:48:55 <dons> araujo: try 1.0, its been fixed
19:49:24 <araujo> dons, it will take too long to release new stable version? , i wonder if it is worthy to add the release candidate (which works fine) in our portage tree
19:49:27 <araujo> Or wait.
19:49:55 <araujo> I am one user of that package , so i pretty much would like to see it inside.
19:59:21 <lennart> But when Pseudonym is your pseudonym you get into an infinite recursion trying to figure out the name. :)
20:00:09 <Pseudonym> Indeed.
20:00:27 <Pseudonym> I picked this as a nick some time in the late 80s when I was reading "Goedel Escher Bach".
20:00:52 <Pseudonym> It made a certain kind of sense to a geeky teenager.
20:02:21 <Lemmih> Did SPJ author the "Avoid success at all cost" motto?
20:03:20 <lennart> And so if the search for a name never ends you are indeed the nameless one. :)
20:04:05 <SamB> lennart: especially since his Realname is Pseudonym
20:04:46 <dons> Lemmih: it does appear in the 'hair shirt' talk slides, but i'm not sure if he's the author
20:04:56 <lennart> I don't think so.
20:05:30 <SamB> lennart: WHOIS him!
20:07:09 <Botty> http://en.wikibooks.org/wiki/Haskell/Write_Yourself_a_Scheme_in_48_Hours <- wiki version of the tutorial mentioned a few days ago
20:07:21 <lambdabot> http://tinyurl.com/h3gya
20:07:31 <lennart> wow, watching video on my phone looks better than i thought :)
20:07:43 <lennart> now i need to get that 4G memory card
20:07:57 * araujo wonders where dons gone
20:08:08 <dons> yes?
20:08:25 <araujo> dons, so what you recommend? :-)
20:09:31 <dons> I recommend a crunchy sourdough bread, drizzled with early harvest, cold pressed olive oil
20:09:40 <dons> oh, you mean hs-plugins recommendations?
20:09:45 <araujo> yay!
20:10:13 <araujo> Though that first recommendation could be useful tomorrow noon
20:10:57 <dons> Lemmih: you could also put up GOA, http://www.cse.unsw.edu.au/~dons/code/goa/
20:10:58 <lambdabot> Title: Index of /~dons/code/goa
20:11:24 <dons> (or do you need tarballs?)
20:11:27 <Lemmih> dons: To unstable/?
20:11:34 <dons> yeah
20:12:21 <dons> what about yi too? http://www.cse.unsw.edu.au/~dons/code/yi/
20:12:22 <lambdabot> Title: Index of /~dons/code/yi
20:13:42 <Lemmih> Well, um. Can't you do it yourself?
20:13:56 <dons> yeah, I should I suppose. sorry.
20:14:13 * dons tastes his own medicine
20:14:23 <Pseudonym> Mmmm... dog food...
20:14:24 <SamB> hehehe
20:14:34 <SamB> oh! the tasty food!
20:14:38 <SamB> aka tripe!
20:14:41 <SamB> aka dog food!
20:15:57 <dons> oh, I like the new cabal logo. how long have we had that?
20:16:50 <dons> http://hackage.haskell.org/trac/hackage/chrome/common/Cabal-With-Text.png
20:16:54 <lambdabot> http://tinyurl.com/revof
20:17:08 <sjanssen> hmm, that reminds me of something . . .
20:17:31 <SamB> the one with the hidden lambda?
20:18:08 <dons> the box with the star. i do remember a lambda-based one though.
20:18:38 <SamB> no, I mean, wasn't there a logo with a hidden lambda that had a box and/or a star?
20:18:59 <SamB> oh, I found a lambda here too ;-)
20:19:11 <dons> they're everywhere if you squint
20:19:16 <SamB> between the box and the C ;-)
20:19:22 <dons> yeah
20:19:33 <dons> mmm. negative space lambdas
20:19:48 <dons> subliminally functional
20:20:37 <SamB> hmm, I'd like a lambda poking out of a partly-open box ;-)
20:22:22 <dons> ?uptime
20:22:23 <lambdabot> uptime: 4d 4h 28m 20s, longest uptime: 4d 20h 30m 23s
20:24:11 <glguy> dons: go for the record!
20:24:31 <dons> i've a bot on another channel with uptime: 3d, 21h, 38m  30s, longest uptime: 15d, 5h, 28m  56s
20:24:34 <dons> though
20:24:37 <dons> :)
20:24:59 <lennart> why such short uptimes?  to upgrade the bot?
20:25:08 <glguy> long uptimes are just a sign of outdated code
20:25:09 <dons> yeah, we get patches so often
20:25:29 <dons> i used to just reset whenever i got a new patch, since last week though, i just reset on saturdays.
20:25:46 <dons> so yes, its the patch rate that limits the uptime :)
20:26:14 <glguy> I cry for the Linux's boxes whose owners keep them up for years
20:27:05 <dons> i always worry a bit when booking a ticket across the pacific, 14 hours or so, and they say they serve: Meal: Lunch , Refreshment
20:29:22 <lennart> glguy: what's wrong with long uptimes?  no need to reboot when the os functions right
20:29:43 <glguy> so long as it's not connected to the internet
20:30:59 <SamB> lennart: we'll stop rebooting sometime after you figure out how to upgrade the kernel without rebooting ;-)
20:32:50 <dolio> That's what the microkernels are for, right? :)
20:33:10 <dolio> Prove your core correct, and then everything else can be reloaded.
20:35:28 <SamB> hah
20:35:49 <SamB> better yet, allow *your* code to be reloaded
20:35:56 <lennart> well, i rarely reboot augustsson.net.  there's just no need, it works fine.
20:36:12 * SamB steals for himself
20:36:18 * SamB born in august too
20:37:01 <dibblego> are there Prelude functions for sorted lists?
20:37:06 <dolio> Who's code?
20:37:27 <glguy> dibblego: there's insert..
20:37:32 <SamB> well, I mean, allow even the microkernel to be reloaded somehow ;-)
20:37:50 <dibblego> ?index insert
20:37:50 <lambdabot> Data.Graph.Inductive.Internal.Heap, Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
20:38:06 <dons> ?hoogle insert
20:38:07 <lambdabot> List.insert :: Ord a => a -> [a] -> [a]
20:38:08 <lambdabot> Data.HashTable.insert :: HashTable key val -> key -> val -> IO ()
20:38:08 <lambdabot> Data.IntMap.insert :: Key -> a -> IntMap a -> IntMap a
20:38:17 <dolio> But if it's proved correct, it never has to change, right? :)
20:38:19 <dibblego> thanks
20:38:39 <SamB> dolio: ... I suppose not
20:38:47 <SamB> if it hasn't got any features, anyway
20:39:08 <dolio> I don't remember what goes in the 'core' of a microkernel. It's pretty bare.
20:39:23 <SamB> depends on the microkernel
20:39:36 <SamB> for instance, look at NT putting all of GDI in there ;-P
20:39:42 * SamB runs to bed after that one
20:39:44 <dolio> The ideal academic one, of course.
20:39:51 <SamB> hahaha
20:39:55 <dolio> :)
20:40:01 <SamB> who wants to run the ideal academic one?
20:40:09 <SamB> it is probably really slow
20:40:12 <dolio> Tannenbaum?
20:40:16 <SamB> heh
20:40:36 <glguy> SamB: is that only the case because of the current hardware architectures?
20:40:53 <syntaxfree> there is some analogy between categories and type classes I can't quite make precise.
20:41:18 <glguy> isn't the type system a category?
20:41:31 <syntaxfree> the type system is formally a category, yes.
20:41:59 <syntaxfree> but it seems that categories can be "sort of " implemented as type classes.
20:42:12 <SyntaxNinja> Lemmih: can you link me to your hackage interface again?
20:42:31 <SyntaxNinja> Lemmih: and/or update the hackage wiki to point to it?  http://hackage.haskell.org/trac/hackage
20:42:33 <lambdabot> Title: Hackage - Trac
20:45:56 <dolio> You mean like, each type class is a category, and the functions related to it are the arrows of the category?
20:45:59 <dolio> Or something like that?
20:49:42 <Lemmih> SyntaxNinja: hackage.homedns.org
20:49:45 <dibblego> ?hoogle (a -> Bool) -> [a] -> a
20:49:46 <lambdabot> No matches, try a more general search
20:50:19 <Lemmih> SyntaxNinja: It's not a very permanent home.
20:50:27 <dibblego> ?hoogle (a -> Bool) -> [a] -> Maybe a
20:50:28 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
20:53:18 <dibblego> ?hoogle Eq a => [a] -> a -> Int
20:53:19 <lambdabot> No matches, try a more general search
20:53:27 <dibblego> ?hoogle Eq a => [a] -> a -> Maybe Int
20:53:28 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
20:53:28 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
20:53:53 <dibblego> ?hoogle Just a -> a
20:53:54 <lambdabot> No matches, try a more general search
20:54:09 <dibblego> how do you get a out of Just a?
20:54:36 <weitzman> @hoogle Maybe a -> a
20:54:38 <lambdabot> Maybe.fromJust :: Maybe a -> a
20:54:38 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
20:54:38 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
20:54:43 <dibblego> oh thanks
21:03:39 <SyntaxNinja> Lemmih: wikis don't have to be very perminent :)
21:05:33 <SyntaxNinja> Lemmih: wish you wouldn't fire off "I don't think this will work" bombs without explaining them.  ungrounded assertions like that are frustrating and demotivating. sets up an aura of a problem that can't be solved.
21:10:55 <Lemmih> Hm, right.
21:11:17 <dons> esp. in a public forum like that.
21:12:37 <monochrom> Political correctness?
21:13:02 <SyntaxNinja> Lemmih: your web interface rules, btw. it's great that you got it put together so quickly :)
21:13:10 <glguy> monochrom: it's for Visual Basic programmers
21:13:16 <dibblego> can a function return a function?
21:13:25 <dons> yes.
21:13:25 <glguy> dibblego: yup
21:13:29 <dibblego> ok
21:13:30 <SyntaxNinja> monochrom: political correctness?
21:15:08 <monochrom> We can't tell VB programmers "I don't think this will work" and just leave it as self-evident?
21:15:36 <glguy> I'm saying that we can leave the political correctness ot hte vb programmers
21:15:53 <glguy> not that we need to talk to hem with silk gloves
21:16:13 <monochrom> That's better.
21:20:39 <SyntaxNinja> I don't think it's about political correctness so much as constructiveness.
21:22:07 <dibblego> can you tell lambdabot to remember a function definition?
21:22:16 <weitzman> @let f = \x -> x + 1
21:22:17 <lambdabot> Defined.
21:22:20 <weitzman> > L.f 3
21:22:22 <lambdabot>  4
21:22:27 <dibblego> ah
21:22:28 <Botty> oh, sweet!
21:22:34 <monochrom> > L.f 3
21:22:35 <lambdabot>  4
21:22:47 <weitzman> @undefine
21:22:48 <dibblego> <> let m 7 = 8;m x = x * 2;x = m 7 in x -- can you ask for the type of m in one line?
21:22:48 <lambdabot> Undefined.
21:22:49 <Botty> I thought we had to do chains of commands
21:22:49 <monochrom> Does it ever forget?
21:23:03 <glguy> > L.if' True 'a' 'b'
21:23:04 <lambdabot>  Not in scope: `L.if''
21:23:08 <Botty> (chains as in semicolons)
21:23:08 <glguy> yeah
21:23:14 <glguy> it forgets
21:23:32 <weitzman> > L.f 3 -- this won't work
21:23:33 <lambdabot>  Not in scope: `L.f'
21:23:43 <glguy> > L.if' True 'a' 'b' -- This worked last night
21:23:44 <lambdabot>  Not in scope: `L.if''
21:23:52 <weitzman> I just ran @undefine
21:23:59 <weitzman> Since I didn't want to steal the name f
21:24:14 <glguy> did it undefine everything?
21:24:26 <weitzman> Yeah, it didn't support selective undefine last I checked
21:24:27 <Botty> @let if pred a b = if pred then a else b
21:24:27 <lambdabot>  Parse error
21:24:31 <weitzman> @help undefine
21:24:32 <lambdabot> undefine. Reset evaluator local bindings
21:24:40 <glguy> ah
21:24:53 <monochrom> So if I /msg lambdabot @undefine  in the background every minute, you guys will experience very surreal behaviour? :)
21:25:05 <weitzman> Unless is partitions by channel
21:25:07 <glguy> ?let if' b | b = const | otherwise = flip const
21:25:08 <weitzman> *it
21:25:08 <lambdabot> Defined.
21:25:19 <dons> monochrom: it won't be surreal. it will be annoying :)
21:25:35 <monochrom> perspectives, perspectives
21:25:36 <glguy> ?type L.if'
21:25:38 <lambdabot> Couldn't find qualified module.
21:25:46 <glguy> > L.if' True 'a' 'b' -- This worked last night
21:25:47 <lambdabot>  'a'
21:25:48 <dons> local bindings are yet exposed in @type
21:25:59 <dons> aren't
21:25:59 <glguy> not^ ?
21:26:06 <glguy> k
21:26:46 <Botty> > L.if' True 'a' 'b' -- This worked last minute
21:26:47 <lambdabot>  Not in scope: `L.if''
21:27:47 <dibblego> I wish 'a' wasn't used because it is ambiguous with the word a
21:27:48 <glguy> that makes the feature a lot less appealing :(
21:27:57 <dibblego> I have a b, a c, a d and an a
21:28:04 <dons> > print stdin
21:28:05 <lambdabot>  Not in scope: `stdin'
21:28:38 <weitzman> dibblego: You mean as a type variable?
21:28:44 <dibblego> weitzman, yes
21:29:02 <weitzman> In SML, they use names like 'a and 'b
21:29:07 <weitzman> Which is nice
21:29:15 <dibblego> I think we (haskell) should
21:29:36 <glguy> I think it should be optional so you wouldn't only have ot use it if you were confused by the normal way
21:29:59 <glguy> I got my negatives and whatnot mixed up in that sentense, yes
21:30:07 <dibblego> I can't come up with a definitely ambiguous case, but I'll bet one exists
21:30:11 <glguy> but the point should be easy enough to pick out
21:30:36 <dibblego> if no ambiguous cases exist, I'll agree
21:30:47 <glguy> when dealing with types, all lower-case words are type-variables
21:31:09 <weitzman> In my recent typechecker assignment, I do alpha-renaming very liberally, thus ensuring that the printed type name doesn't have any variables in common with the user-named variables
21:31:25 <weitzman> Makes types look very silly
21:31:46 <monochrom> I think the Haskell community likes a naming convention opposite to the SML community.  I mean we are like "newtype X a = X a".  We like to call both "X".
21:31:52 <dibblego> glguy, but in English that uses type variables, ambiguities may arise
21:31:57 <glguy> and attempts at reducing confusion like that are why monad comprehensions were crippled )-:
21:32:26 <weitzman> The SML community? SML can't possibly have a community
21:32:39 <weitzman> If they do, they need to get themselves organized and do some work
21:32:55 <monochrom> haha ok
21:33:17 <weitzman> 13 people in #sml
21:33:48 <glguy> dibblego: when writing english sentences involving type names, you could just choose not to use 'a'
21:34:30 <weitzman> Technically 'a is supposed to represent alpha to SML people
21:34:37 <dibblego> glguy, but what if a function definition already exists, then I wish to describe it to someone?
21:34:46 <weitzman> Since alpha seems to be a traditional way to name an arbitrary type
21:35:11 <glguy> dibblego: there is absolutely no difference bettwen a function of type (a -> a) and one of type (b -> b)
21:35:30 <weitzman> What we need is an easy way to type characters like alpha
21:35:36 <dibblego> glguy, but if I want to talk about "the a"?
21:35:53 <glguy> dibblego: then do what you are supposed to do in English, but quotes around it
21:36:00 <weitzman> Typing things like \alpha and \Leftrightarrow gets old very fast
21:36:06 <dibblego> glguy, I do that already
21:36:13 <dibblego> I have a b, a c, a d and an 'a'
21:36:22 <dibblego> I have a 'b', a 'c', a 'd' and an 'a'
21:36:41 <glguy> dibblego: then the English language has solved the problem for you !
21:36:42 * weitzman hopes that a successor to LaTeX will emerge sometime soon
21:36:48 <Botty> I have a, b, c, and d types
21:37:07 <Botty> dunno if they are technically 'types' but whatever
21:37:34 * glguy imagines a formal proof that the type-variable "a" can not be used ambiguously in a sentence. (c:
21:37:34 <Botty> something like latex but for the web would be cool
21:37:37 <Botty> i hate html
21:37:48 <Botty> I can do it but that doesn't mean I can't still hate it
21:38:23 <weitzman> I usually use LyX to write stuff in LaTeX, but you still have to type silly things like \implies all the time
21:38:31 <glguy> LyX++
21:38:44 <weitzman> (LyX++)++
21:39:06 <glguy> did you just give "1" karma?
21:39:18 <weitzman> I have no idea
21:39:43 <glguy> ?karma 1
21:39:44 <lambdabot> 1 has a karma of 0
21:39:47 <glguy> nope :)
21:40:24 <Botty> ?karma me
21:40:25 <lambdabot> me has a karma of 0
21:40:43 <glguy> ?karma haskell
21:40:44 <lambdabot> haskell has a karma of 8
21:41:02 <Pseudonym> ?karma LyX
21:41:03 <lambdabot> LyX has a karma of 1
21:41:07 <glguy> I've registered that nick... so techincally that's my karma ;)
21:41:12 <Pseudonym> ?quote LyX
21:41:13 <lambdabot> LyX hasn't said anything memorable
21:41:28 <Botty> ?quote haskell
21:41:28 <lambdabot> haskell hasn't said anything memorable
21:41:36 <Pseudonym> ?quote
21:41:36 <Botty> ?quote lambdabot
21:41:36 <lambdabot> sieni says: C provides people with the expressiveness of fortran combined with the portability of assembler
21:41:36 <lambdabot>  Occurs check: cannot construct the infinite type: a
21:41:59 <Pseudonym> ?quote lambdabot
21:41:59 <lambdabot>  [in #haskell] there are a lot of weirdos on here
21:42:06 <Pseudonym> Ah, OK.
21:42:16 <Pseudonym> ?quote Pseudonym
21:42:16 <lambdabot>  I think principal types are overrated
21:42:32 <Pseudonym> ?quote glguy
21:42:33 <lambdabot>  this is like Web 5GL. I like it
21:42:33 <dibblego> if I do a @let x = 7 then > x lambdabot should print 7 right? not Not in scope: `x'
21:42:57 <Pseudonym> dibblego: You might need to qualify it.
21:43:00 <Pseudonym> With > L.x
21:43:02 <dibblego> oh that's right
21:43:18 <Pseudonym> ?quote Pseudonym
21:43:18 <lambdabot>  What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
21:43:21 <Pseudonym> With > L.x
21:43:25 <Pseudonym> ?quote Pseudonym
21:43:25 <lambdabot>  Well, personally, I don't think dumb people should be let near a programming language.
21:43:35 <Pseudonym> Just curious how I will be remembered.
21:43:43 <dibblego> ?quote dibblego
21:43:43 <lambdabot>  I believe that OO is intrinsically defective and digresses from a formal definition of "software"
21:43:43 <Pseudonym> ?quote Pseudonym
21:43:43 <lambdabot>  If Hofstadter had said this, it would have been much funnier.
21:43:56 <dibblego> hate looking at myself in the mirror
21:43:58 <glguy> planning on dying soon?
21:44:11 <Pseudonym> No, but you might as well plan.
21:44:16 <Pseudonym> ?quote Pseudonym
21:44:16 <lambdabot>  Well, personally, I don't think dumb people should be let near a programming language.
21:44:21 * Pseudonym shrugs
21:44:32 <glguy> ?quote
21:44:32 <lambdabot> edwardk says: lambdabot is the first irc bot i ever added to my buddy list
21:45:11 <Botty> lol
21:45:25 <Pseudonym> ?quote
21:45:25 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
21:56:10 <dmwit> Hi all!
22:10:46 <tessier_> Anyone working on a functional database? Sort of like zodb is to python this thing would be to haskell?
22:10:55 <Bobstopper> Hee hee. I came up with a useful function which is horrible to read: (flip ((flip id) . (flip id)))
22:10:59 <Bobstopper> I need a good name for it
22:11:12 <tessier_> horriblefun
22:11:16 <Bobstopper> tessier_: I think haskelldb is supposed to be good
22:11:27 * tessier_ googles haskelldb
22:13:15 <svref> How do you say "and otherwise" in guards in Haskell?  Isn't there a magic word?
22:13:29 <Botty> uh, otherwise? :)
22:13:54 <Botty> I don't know though, i'm still a hasknoob
22:14:12 <Botty> I think I recall seeing that when I looked up guards though
22:14:19 <sjanssen> svref, Botty: yes, "otherwise"
22:14:41 <sjanssen> otherwise is just defined in the Prelude as "otherwise = True"
22:14:55 <arcatan> apparently haskell is too obvious
22:15:33 <svref> indeed, my experience is that my guesses are always wrong...so I don't try the obvious anymore.  :)
22:15:48 <sjanssen> svref: you could even write "and [otherwise]" if you wanted, but that's getting a bit out of control ;)
22:16:29 <svref> heh
22:20:52 <hyrax42> ugh
22:21:01 <hyrax42> I hope sockets are easy in haskell
22:21:24 <svref> It depends if you take them out to dinner and buy them some wine first.
22:21:44 <hyrax42> cheap wine good enough?
22:22:19 * hyrax42 wading through messy java code that apparently is the "specification" of a protocol
22:22:28 <arcatan> they weren't too hard when I tried, iirc
22:22:42 <Botty> haha, lol, that sucks hyrax42
22:22:51 <Botty> must be a pretty crap protocol
22:22:56 <hyrax42> it sucks because I was told that there would be a good definition of it
22:23:00 <Botty> or at least not widely used...
22:23:03 <hyrax42> well it's for my AI project
22:23:08 <hyrax42> it's a completely made up protocol
22:23:12 <hyrax42> for sending the moves
22:23:16 <Botty> ah
22:23:21 <hyrax42> but she told us it'd be defined somewhere
22:23:21 <Botty> AI eh? cool stuff
22:23:28 <hyrax42> finally the code etc. is up
22:23:32 <hyrax42> but all there is is this java code
22:23:43 <hyrax42> no definition of the protocol
22:24:02 <hyrax42> luckily it *is* text over sockets, and not some abomination like searlised god knows what
22:24:03 <svref> I learned TCP/IP programming from man pages, e.g. "man 3 bind"
22:24:22 <hyrax42> but there are no comments or anything defining the format of the messages
22:24:53 <hyrax42> and worse, the protocol leaks the internal server implementation of the board as a 1-d array, rather than using more sensical 2d coordinates
22:25:05 <hyrax42> or even better the usual rank/file notation of chess
22:25:10 <Botty> is it a mutual protocol, ie it works the same from both sides, or is there specific server stuff?
22:25:20 <hyrax42> same from both
22:25:23 <hyrax42> afaict
22:25:24 <hyrax42> so far
22:25:24 <Botty> if its mutual usually the best spot to look is the generator.
22:25:36 <Botty> as parsers get complicated
22:25:48 <Botty> while the generators of the string are rather intuitive
22:26:09 <Botty> hopefully it doesn't have tostring methods scattered everywhere to do that
22:26:22 <hyrax42> Botty, you nailed it
22:27:12 <Botty> well, that sucks
22:27:24 <hyrax42> oh yes indeed
22:27:31 <hyrax42> I'm wondering if I should email and ask for a definition
22:27:35 <hyrax42> or wade through this crap
22:27:37 <cybercobra> how do i declare a class/type as the disjunction of 3 algebraic data types?
22:27:46 <hyrax42> |
22:27:53 <hyrax42> oh
22:28:14 <hyrax42> not sure the precise definiton of algebraic data type
22:28:27 <dons> ?where aam
22:28:27 <lambdabot> http://www.nomaware.com/monads/
22:28:50 <cybercobra> sorry, tuple types not algebraic
22:29:23 <hyrax42> I think you'd need to do
22:30:13 <hyrax42> data A w x y z = Foo (x,y) | Bar (y,z) | Baz (w, z)
22:30:25 <hyrax42> as in I think you need the different data constructors
22:30:32 <hyrax42> but I'm not an expert by a *long* way
22:30:48 <sjanssen> it'd be better to skip those tuples
22:30:56 <sjanssen> data A w x y z = Foo x y | ...
22:31:39 <svref> I don't use tuples as much as I thought I would when I started Haskell.
22:32:22 <svref> But I use "data" declarations more than I expected...
22:32:48 <sjanssen> svref: it's nice to give names and structure to things
22:33:27 <cybercobra> that doesn't quite do what i want though
22:33:52 <sjanssen> cybercobra: what do you want to do?
22:34:26 <cybercobra> screw it, it's too late in the night for me to form the question correctly
22:34:40 <cybercobra> 'night haskellers!
22:35:28 <svref> I prefer the term "haskell-raskal"
22:43:27 <tessier_> haskelldb looks to be just an odbc interface to standard rdbms
22:45:37 <dechunker> Newbie question:  I don't understand how "(flip id)" compiles.  Help?  It looks like the first argument to flip is (a->b->c), yet "id" has type (a->a).
22:45:42 <dechunker> ?type (flip id)
22:45:43 <lambdabot> forall b c. b -> (b -> c) -> c
22:46:01 <dons> ?type flip id
22:46:02 <dons> ?type id
22:46:03 <lambdabot> forall b c. b -> (b -> c) -> c
22:46:04 <lambdabot> forall a. a -> a
22:46:09 <dons> ?type flip
22:46:11 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
22:48:40 <vincenz> hiya donz
22:49:01 <Bobstopper> I was just playing around with (flip id) a couple of minutes ago. In order to flip id, id must take two arguments. So I think what happens is the type compiler assumes id is being applied to a function. So the type of id becomes (a -> b) -> (a -> b) or (a -> b) -> a -> b. flip then flips them and you get a -> (a -> b) -> b
22:49:47 <dechunker> Ah.
22:50:57 <dechunker> I am intimidate by how clever Haskell seems to be.
22:51:31 <Bobstopper> Yeah, how the type compiler knows how to make flip id work blows my mind too.
22:52:43 <Bobstopper> ?type (flip ((flip id) . (flip id)))
22:52:45 <lambdabot> forall c c1 a. (((a -> c1) -> c1) -> c) -> a -> c
22:52:50 <Bobstopper> ?type (flip ((flip id) . (flip id))) map
22:52:52 <lambdabot> forall c a. a -> [a -> c] -> [c]
22:54:28 <Bobstopper> ?type (flip ((flip id) . (flip id))) all
22:54:30 <lambdabot> forall a. a -> [a -> Bool] -> Bool
22:54:55 <vincenz> Anyone know the std size of harddrives?  The ones you stick in computers, are they 3.5 or 5.25?
22:55:03 <glguy_> 3.5
22:56:06 <vincenz> thx
22:57:45 <hyrax42> quick question on client-side sockets....
22:57:56 <hyrax42> you use connectTo and get a Handle back
22:58:08 <hyrax42> to close the socket, you call close Handle -> IO ()?
22:58:10 <hyrax42> ::
22:58:15 <hyrax42> from IO
22:58:23 <hyrax42> or a special networking version
22:58:51 <dechunker> @let 1+1=3
22:58:52 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
22:59:37 <dmwit> > let 1+1=3 in 1+1+2
22:59:39 <lambdabot>  Non-exhaustive patterns in function +
23:00:18 <dibblego> ?foldoc function
23:00:20 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
23:00:20 <lambdabot> function
23:00:20 <lambdabot>  
23:00:20 <lambdabot>     1. <mathematics> (Or "map", "mapping") If D and C are sets
23:00:20 <lambdabot>     (the domain and codomain) then a function f from D to C,
23:00:22 <Botty> vincenz - hmm, yeah, I wonder why they don't do 5.25 harddrives. could stand to just about double the mem
23:00:22 <lambdabot> [25 @more lines]
23:01:33 <Botty> I wouldn't buy them though.  I'd rather have a number of smaller drives
23:01:59 <vincenz> > let {1+1=3; 3+2=4} in 1+1+2
23:02:01 <lambdabot>  4
23:02:16 <vincenz> > let {1+1=3; 1+2=4; 1+4=3} in 1+1+2
23:02:17 <lambdabot>  Non-exhaustive patterns in function +
23:02:37 <dmwit> (+) must be left-associative.
23:02:42 <vincenz> yep
23:02:46 <vincenz> l-to-r
23:03:54 * macron is back
23:03:57 * macron is back
23:03:57 <dechunker> I'm sad that Haskell wasn't declared the official winner of the ICFP competition.
23:04:01 * macron is back
23:04:03 * macron is back
23:04:10 <hyrax42> dechunker, where is the official list
23:04:29 <glguy_> consistent superiority breeds complacency
23:04:31 <dechunker> I haven't been able to find one.  I just watched a video I found on google videos.
23:04:35 <glguy_> it will work out for the best
23:04:38 <hyrax42> gah on 1 hour videos
23:04:44 <hyrax42> I've only seen the table
23:04:49 <hyrax42> but no metion of who usd what and how
23:04:59 <hyrax42> anyway, the task wasn't terribly suited to functional programming it seems to me
23:05:00 <glguy_> everyone used lots of languages
23:05:05 <dechunker> The official list is 1: "2D", 2: "D" 3: "Assembler"
23:05:15 <dmwit> Bah!
23:05:34 <dechunker> Or at least, that's what was in the video.
23:05:35 <glguy_> this years challenge didn't require source code to be submitted
23:05:45 <glguy_> and there are 8 different puzzles
23:05:53 <hyrax42> yeah so how did the judge's prize go then
23:05:55 <glguy_> + the trivial task of writting the vm
23:05:57 <hyrax42> or there wasn't one
23:06:08 <hyrax42> ?
23:06:09 <glguy_> hyrax42: a one man team in 5?th place got it
23:06:16 <hyrax42> kk
23:06:19 <glguy_> for being a one man team and performing so well
23:06:27 <hyrax42> I think I'll try and participate next year
23:06:32 <hyrax42> depending on timing
23:11:05 <glguy_> the digg up bury down system on digg comments provides for a very interesting dynamic in the more heated threads :)
23:11:21 <glguy_> wish i didn't have to refresh to see the changes
23:24:52 <dons> ok, here's the first draft of my irc bot/application hacking tutorial. Comments please! http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:24:55 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
23:25:38 <hyrax42> dons, this looks awesome
23:25:53 <hyrax42> since I have to write some basic sockets stuff and never really did any in any language
23:26:01 <hyrax42> and here is a nice barebones example
23:26:14 <dons> let me know if anything goes too fast, or is introduced in the wrong order.
23:26:24 <dons> or if i need more references anywhere.
23:26:25 <hyrax42> will do my best
23:26:37 <joelk> I was thinking about creating an optimization library for functions (eg.) from R^n to R, using [a] as the vector type. But then I need some way to apply a function to the head of the list, take the resulting function and apply to the next elem, etc until i finally apply something (a->a) to an a. I have a rather messy solution (that I don't really understand, but seems work!). Has anyone else looked into such a problem?
23:27:00 <dons> sounds like a fold, yes?
23:27:13 <hyrax42> was gonna say sounds foldy
23:27:45 <sieni> joelk: how do you get a function by applying a->a to a?
23:27:55 <joelk> Right, but what's the type? doit :: (a->a->a...->a) -> [a] -> a
23:28:09 <dons> oh, those .... 's don't look good....
23:28:17 <dons> you mean the type depends on the length of the list??
23:28:43 * hyrax42 would represent R^n as a tuple or array type
23:28:46 <joelk> no, the recursion terminates... when the type does (excuse my butchering of the terminology there)
23:29:20 <joelk> hyrax42, It was mostly a thought exercise: Can I create a lib for arbitrary n?
23:29:21 <sieni> of course you could have [a]->a instead of that (a->a->a...->a) ^_^
23:29:43 <dons> yeah :)
23:29:59 <joelk> true... but where's the fun in that.
23:30:03 <hyrax42> joelk, are you repeatedly applying the same function?
23:30:41 <joelk> no, I'm accumulating (?) the function
23:31:14 <joelk> eg, doit f as, applies f to as many as as it wants and returns the end result
23:31:24 <hyrax42> I mean are you taking the result of the function and applying the function again with the result and
23:31:28 <hyrax42> oops
23:31:30 <joelk> hehe, bad choice of type var name there
23:31:31 <hyrax42> that was meant to get deleted
23:31:40 <hyrax42> stupid windows no C-a C-k
23:32:19 <hyrax42> joelk, have an example?
23:32:26 <hyrax42> (on R^n, n small please!)
23:32:31 <joelk> of the solution?
23:32:39 <hyrax42> what you're trying to do
23:32:47 <hyrax42> an example of doit f as
23:32:55 <hyrax42> with f and as explicit
23:33:16 <hyrax42> dons, are you encouraging botspamming on freenode?
23:33:18 <hyrax42> ;)
23:33:33 <dons> hyrax42: well....
23:33:43 <dons> i hope not
23:33:43 * macron is back
23:34:14 <Botty> I think we should all write eliza-like bots and stick them all in a chat room and watch the chaos ensue
23:34:22 <hyrax42> how does hGetContents work in such a case
23:34:26 <hyrax42> of a stream
23:34:35 <hyrax42> NoBuffering means it just prints whatever arried by that time?
23:34:57 <dons> yep
23:35:59 <joelk> hyrax42, very simply: doit (\a b c -> a+b-c) (x0:x1:x2:_) <==> x0+x1-x2
23:36:49 <hyrax42> not sure what you want is possible as described
23:37:03 <hyrax42> but IANAHP
23:37:51 <hyrax42> maybe with peano counting on number of arguments as part of th etype
23:38:00 <hyrax42> but I'm way out of my depth there
23:38:23 <joelk> My solution works, but requires multi-parameter classes and overlapping instances.
23:38:26 <hyrax42> to be clear: way way way
23:38:33 <hyrax42> it works for any number of arguments?
23:39:04 <joelk> As long as there are enough elements in the list, yes.
23:39:14 <hyrax42> @paste
23:39:14 <lambdabot> http://paste.lisp.org/new/haskell
23:39:15 <hyrax42> I'm curious
23:39:17 <dons> I suppose you could do it like printf
23:39:20 <hyrax42> and stand to learn
23:39:33 <dons> ?type printf ""
23:39:35 <lambdabot> forall r. (PrintfType r) => r
23:39:35 * hyrax42 has no idea how printf does it
23:39:36 <dons> ?type printf "" 'a'
23:39:38 <lambdabot> forall t. (PrintfType (Char -> t)) => t
23:39:40 <dons> ?type printf "" 'a' 'b' 'c' 'd'
23:39:41 <lambdabot> forall t. (PrintfType (Char -> Char -> Char -> Char -> t)) => t
23:39:42 <joelk> dons, that was another thought I had, I was mystified the first time I looked at printf
23:39:52 <dons> ?type printf "" 'a' 'b' 'c' 'd' 'e' 'f' () "foo"
23:39:54 <lambdabot> forall t. (PrintfType (Char -> Char -> Char -> Char -> Char -> Char -> () -> [Char] -> t)) =>
23:40:13 <dons> it uses a semi-standard trick for rolling up variadic functions with a type class
23:40:22 <joelk> dons, thatnks for the reminder. I'll check it out.
23:40:28 <hyrax42> is there a name for the technique?
23:40:30 <dons> oleg's home page has the details (might be on the wiki Idioms page too)
23:40:44 <hyrax42> hm
23:40:51 <hyrax42> I need to go thtough the stuff on oleg's page
23:40:56 <dons> no name that I know of. but it uses a method called 'build' usually
23:41:55 <dons> x3m, comments please. http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:41:59 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/goxlz
23:43:11 <hyrax42> dons, is using printf preferable to hPutStrLn $ .. ++ .. ++ ..?
23:43:21 <hyrax42> no waste on concatenation, perhaps?
23:43:48 <dons> its a bit more concise sometimes
23:45:18 <hyrax42> @type shows
23:45:19 <lambdabot> forall a. (Show a) => a -> ShowS
23:47:03 <hyrax42> the lazy control structures stuff is always great
23:47:25 <hyrax42> half the stuff where you'd use macros in lisp you can do straight in haskell
23:47:32 <dons> yeah, hopefully their goodness comes across.
23:47:51 <hyrax42> this is intended for a redditing or somesuch?
23:48:10 <dons> I think so, once I get a bit more proof reading :)
23:48:30 <hyrax42> trying to build on success of unix tools ;)
23:48:37 <hyrax42> maybe write forever in do syntax
23:48:47 <hyrax42> rather than with >>
23:49:12 <dons> ah ok. nice idea
23:50:52 <dons> ok, updated
23:52:50 <bdash> dons: you missed updating forever in the paragraph where you explain it
23:53:09 <dons> fixed.
23:53:13 <dons> thanks.
23:53:13 <hyrax42> and in the refined listen
23:53:25 <hyrax42> "simple interpreter" version
23:53:47 <dons> i thought I'd leave both versions in, after I explain the >> version
23:53:53 <hyrax42> assuming newbie audience
23:53:54 <hyrax42> ah ok
23:54:11 <hyrax42> well anyway, use of fmap and/or liftM in its place could do with explanation
23:54:22 <dons> ok.
23:54:26 <hyrax42> or being avoided by moving 'init' elsewhere
23:54:32 <dons> yeah. i'll do that
23:54:39 <hyrax42> sorry all criticisim no input
23:54:47 <dons> no, this is useful.
23:54:49 <hyrax42> well criticisim is input
23:54:52 <dons> hyrax42++
23:55:24 <hyrax42> ahh should ahve read further
23:55:49 <hyrax42> didn't realise you were going to define a monad for it
23:56:13 <dons> maybe i should signal that earlier
23:56:27 <hyrax42> or maybe I should read the toc
23:57:26 <hyrax42> also a reference to a (possibly basic) coverage of IRC protocol would be hlepful
23:57:43 <hyrax42> I have no idea why you're dropping 1 dropWhiling (/= ':') and so on
23:58:04 <dons> yep ok. good idea.
