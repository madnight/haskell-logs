00:07:03 <dolio> > (!! 500) . ap (zipWith $ flip (/)) tail . fix $ (1:) . scanl (+) 1
00:07:04 <lambdabot>  1.6180339887498951
00:07:59 <dons> mmm
00:08:01 <dons> nice
00:08:17 <dolio> Thanks. :)
00:37:24 <sjanssen> dons: I've successfully run the quickchecks with HPC, but it seems the visualization tools aren't available
00:38:21 <dons> ah, ok. does it not dump html or something?
00:41:31 <sjanssen> it dumps out some opaque text file
00:42:24 <sjanssen> there are tools to process the data in the old version of hpc, but it seems the formats are slightly incompatible
00:47:13 <lispy> last i heard from andygill, was coming soon....
00:47:37 <lispy> so, i guess keep  your tic files and then wait a week
00:47:49 <sjanssen> lispy: so you've asked him about it?
00:50:31 <araujo> yay!
00:50:37 * araujo throws sugar lambdas
00:51:20 <sjanssen> sounds like you have, so I won't send an email asking for the tools
00:54:36 <lispy> sjanssen: well, he was here
00:54:53 <lispy> sjanssen: he said it'd be up in a week or so
00:56:14 <sjanssen> neat
00:56:22 <sjanssen> this stuff is very exciting
00:58:32 <lispy> yes, yes it is
00:59:39 * araujo thinks he will use Data.Map for his binary tree
01:00:51 <lispy> araujo: well, as i discovered today (and perhaps should have known) Data.Map requries unique keys so it will automatically overwrite values when you try to insert a key twice (or use fromList)
01:01:08 <lispy> just a word to the wise, yo
01:01:27 <araujo> lispy, i just looked at it. And it looks nice that showTree function!
01:01:42 <lispy> oh, i didn't notice that
01:02:18 <araujo> hah
01:03:51 <lispy> i expected it to work like assoc lists which handle duplicates by always returning the value at the front of the list
01:04:00 <lispy> and then you can remove them and get back to the old value
01:04:19 <araujo> I only need to build a tree once. I won't need to modify it anyway,
01:04:20 <lispy> but, i'm using a Reader monad to manage the rollback of previous values, so it works out great
01:05:18 <araujo> The idea is that somebody types in some values, and the program process it, build and show the tree. Nothing great.
01:05:31 <lispy> i wonder what it would be like to implement GHC's G-machine in hardware
01:05:52 <lispy> what kind of things do you type in?
01:06:58 <araujo> lispy, arithmetic expressions , with some special operands. It is an abstract syntax tree with some labels.
01:07:40 * araujo looks at Data.Set ... 
01:08:26 <lispy> araujo: neat
01:10:11 <araujo> nothing complex really. I just want to do it in an efficient way.
01:10:28 <ThreeQ> how would you get a "hash table" data structure with O(1) lookup in haskell?
01:10:33 <ThreeQ> would you have to roll your own using arrays?
01:10:36 <jmmv> hi
01:12:00 <vegai> ThreeQ: it'd have to be in the IO monad, I think
01:12:07 <ThreeQ> or ST
01:12:28 <ThreeQ> actually for just lookup you could use normal pure arrays, I think
01:12:47 <vegai> in fact, ghc has Data.HashTable
01:13:00 <ThreeQ> ?hoogle HashTable
01:13:01 <lambdabot> Data.HashTable :: module
01:13:01 <lambdabot> Data.HashTable.HashTable :: data HashTable key val
01:13:05 <vegai> yep
01:13:13 <vegai> the insert function returns IO ()
01:13:15 <ThreeQ> oh, didn't even notice that :)
01:13:40 <vegai> Tree is often good enough, though
01:13:51 <ThreeQ> huh, seems like it should be in ST rather than IO
01:13:52 <vegai> or perhaps a Trie
01:14:51 <vegai> @hoogle Trie
01:14:52 <lambdabot> Test.HUnit.Base.tried :: Counts -> Int
01:14:57 <vegai> Miss
01:17:20 <vegai> ThreeQ: I don't know about that. Perhaps an ST monad wouldn't be as efficient
01:17:35 <vegai> , which would ruin the point of having a hashtable in the first place
01:17:42 <ThreeQ> IO is just ST with RealWorld as a type parameter
01:18:06 <vegai> any wizards around to confirm or deny any of this? ;)
01:18:36 <ThreeQ> ST can do update-in-place voodoo, at least
01:18:42 <vegai> yeah..
01:18:48 <lispy> vegai: i'm no wizard, but what ThreeQ said is consistent with what i've heard
01:18:56 <vegai> ok
01:19:01 <ThreeQ> maybe this was written before IO was generalized to ST
01:19:32 <vegai> looking at the implementation of Data.HashTable might reveal the reasons
01:20:59 * ThreeQ looks
01:21:13 <ThreeQ> oh, it's just that it's built on top of IOArrays
01:21:34 <ThreeQ> and IORefs
01:23:11 <ThreeQ> so it could be ported to ST without too much effort, I'd think
02:07:43 <goltrpoat> is http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ on the wiki somewhere?
02:07:47 <lambdabot> Title: Type Theory and Functional Programming, http://tinyurl.com/plqlt
02:07:50 <goltrpoat> should probably be added, if not
02:08:53 <ingy> where is the latest ghc dmg?
02:12:45 <monstre> GHC 6.6 doesn't work for me on Windows (whereas 6.4.2 used to work fine). Is this a known issue?
02:13:07 <pejo> ingy, it's usually distributed as a tarball. IF you use darwinports you can install it from there.
02:14:29 <ingy> pejo: ok, thanks!
02:15:03 <ingy> seems like a dmg would be nice for osx though :)
02:25:33 <Lemmih> monstre: No, it should work.
02:27:54 <goltrpoat> is there like.. a place on haskell.org where things like PFPL etc are listed?  i keep finding these links through google
02:28:22 <goltrpoat> be nice if there was a central repository of some sort.
02:28:46 <bdbit> most languages fail there
02:29:04 <dons> PEPL?
02:29:08 <bdbit> I dare to allege even Java
02:29:12 <goltrpoat> dons:  harper's book
02:29:17 <dons> ah yes its listed
02:29:27 <goltrpoat> and that other book i just posted the url to
02:29:28 <dons> here , http://haskell.org/haskellwiki/Books_and_tutorials#Foundations
02:29:31 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y2na7l
02:29:38 <dons> you mean, Programming Languages: Theory and Practice, Harper?
02:29:42 <goltrpoat> oh, so it is
02:29:53 <goltrpoat> yes, i do.  i missed that, looked through that page just now
02:30:12 <dons> ah, and TTFP is up there too
02:30:20 <psykotic> golt
02:30:33 <goltrpoat> looks like the amazon link to TTFP is listed as well, but not the url (it's out of print, and simon thompson's put it up as a pdf/ps)
02:30:37 <goltrpoat> hey psyk
02:30:45 <goltrpoat> what are you doing here
02:30:45 <goltrpoat> hehe
02:30:47 <dons> goltrpoat: feel free to update that entry then.
02:31:07 <goltrpoat> s'pose i should.
02:31:35 <dons> it's ridiculously easy to edit the wiki, so dive in
02:31:40 <psykotic> goltrpoat, you might want to check out frank's page on free online PLT texts.
02:32:08 <dons> psykotic: oh good idea. there are probably some other we could add
02:32:21 <goltrpoat> psyk:  frank?
02:32:37 <dons> pfenning i think?
02:32:44 <psykotic> http://homepages.cwi.nl/~atanasso/ref
02:32:46 <lambdabot> Title: PLT Online
02:32:50 <dons> ah not that fank
02:33:09 <goltrpoat> good lord.
02:33:37 <goltrpoat> psyk:  thanks a ton
02:34:10 <dons> oh, is that franka ?
02:34:25 <psykotic> yeah
02:35:09 <psykotic> goltrpoat, btw harper's text is a lot better than the sjt one (which is uber theoretical).
02:35:16 <goltrpoat> oh.  there IS actually a link to the online version in the writeup, it's just that it's a little heard to see
02:35:19 <goltrpoat> er.  heard=hard
02:35:46 <goltrpoat> psyk:  i'm sort of bouncing back and forth between those two, and spj's compiler books
02:35:58 <psykotic> i meant sjt not spj :)
02:36:02 <psykotic> the type theory book you posted a link to
02:36:35 <goltrpoat> the one i posted a link to is simon thompson's book.  i meant that one, harper's text, and simon peyton jones' texts
02:37:01 <goltrpoat> they sort of seem to provide different doses of theory vs practice in different spots
02:37:21 <monstre> Does GHCi crash under Windows for anyone else or is just me?
02:37:36 <dons> monstre: it shouldn't. which ghc version are you using/
02:37:39 <monstre> the compiler seems to work fine, just not the interpreter
02:37:41 <dons> and how do you produce the crash?
02:37:51 <monstre> this is GHC 6.6
02:37:53 <Cale> What?! That book (TTFP) appears to be claiming that the first use of a proof by contradiction was for the Hilbert Basis theorem.
02:37:59 <monstre> 6.4.2 used to work perfectly fine
02:38:09 <goltrpoat> cale:  i just skipped over that and went on my merry way
02:38:16 <goltrpoat> but yeah.
02:38:17 <goltrpoat> hehe
02:38:23 <dons> monstre: how do you produce the bug?
02:38:36 <monstre> dons: I just try to launch GHCi from the start menu and it crashes
02:38:52 <dons> ok. that's not supposed to happen. what error do you get?
02:38:58 <psykotic> cale: everyone knows that the hilbert basis theorem is more theology than mathematics! :P
02:39:06 <Cale> I suppose the Hilbert Basis theorem is somewhat interesting in that it's an inductive proof by contradiction :)
02:39:07 <goltrpoat> it does tend to make some weird categorical-sounding claims here and there.
02:39:10 <dons> and where did you get your ghc from? which version? or did you build it yourself?
02:39:10 <psykotic> but i suppose even theology has its uses.
02:39:18 <Cale> psykotic: theology?
02:39:25 <monstre> dons: I'm using the precompiled binaries
02:39:48 <psykotic> cale: gordan's famous objection.
02:39:48 <dons> monstre: can you provide as much information as possible, and report it, here: http://hackage.haskell.org/trac/ghc/newticket?type=bug
02:39:52 <lambdabot> http://tinyurl.com/ttrbx
02:40:04 <dons> including any relevant system details, compiler versions, url of the binary you used. and so on
02:40:08 <psykotic> gordan was the other bigshot in invariant theory around the time when hilbert published the proof of the basis theorem (which was originally cast in invariant theoreical terms).
02:40:10 <dons> and _exactly_ how to trigger the bug
02:40:32 <monstre> error message (rough translation from French): Ghc provoked an error in GHC.EXE. The program Ghc will now stop. If the problem persists, try rebooting
02:40:57 <dons> ok. that's not too helpful. can you work out any other details?
02:41:05 <Cale> psykotic: Is he one of those constructive types?
02:41:15 <dons> how far does it get into loading ghci before it crashes/
02:41:23 <psykotic> cale: well considering that invariant theory was a very computational subject his objection wasn't particularly odd.
02:41:29 <Cale> I suppose
02:41:44 <Cale> There's the whole theory of Gröbner bases now.
02:41:57 <psykotic> indeed.
02:42:01 <monstre> dons: Loading base package... Linking... Done. then crash.
02:42:23 <monstre> I guess I'll just go ahead and report the bug
02:42:35 <Cale> Pure mathematicians tend not to care so much about computational issues at first.
02:42:36 <dons> monstre: ok. please report it with as much infor as you can. particularly, which windows version. mingw or cygwin and so on
02:42:51 <psykotic> cale: the usual proof of the basis theorem you find in textbooks is still nonconstructive though, i think.
02:43:01 <psykotic> it uses the rabinowitz trick + a nice induction on dimension
02:43:04 <Cale> Yeah, that's because the nonconstructive proof is better :)
02:44:04 <monstre> dons: how do I figure out about mingw or cygwin? I just installed the windows precompiled binaries...
02:44:09 <Cale> (Because it is simpler, and therefore it's easier to convince oneself that there is no mistake :)
02:44:29 <monstre> I'm afraid I can't provide much more detail
02:44:32 <psykotic> (err, the standard proof doesn't use the rabinowitz trick, i was thinking of the weak nullstellensatz)
02:44:37 <Cale> yeah
02:44:58 <dons> monstre: ok. if you haven't set up anything special, then that's ok.
02:45:17 <dons> at least note which windows version you're using. and anything else you can think of
02:45:33 <monstre> will do, thanks for the help
02:45:35 <Cale> http://planetmath.org/?op=getobj&from=objects&id=3365
02:45:38 <lambdabot> Title: PlanetMath: proof of Hilbert basis theorem, http://tinyurl.com/y826mp
02:45:56 <psykotic> yeah that proof is almost trivial
02:46:09 <psykotic> you just keep adding generators until you've fully saturated.
02:46:19 <psykotic> termination is guaranteed by the chain condition.
02:46:45 <Cale> yeah
02:47:33 <psykotic> it also doesn't take a lot of work to turn that into a constructive algorithm.
02:48:35 <psykotic> sorry, didn't mean to derail on-topic discussion. dinner time. :)
02:48:55 <goltrpoat> to go back, any books you guys would recommend other than pierce's books?
02:49:08 <goltrpoat> i don't remember the last time i was this interested in something, heh
02:49:18 <Cale> heh
02:50:32 <psykotic> the coolest stuff i've read in a long time is, basically, everything by danvy.
02:51:56 <goltrpoat> seeing some cool stuff on his site, thanks
02:52:19 <psykotic> try the stuff on staging interpreters, defunctionalizing interpreters into abstract machines, etc.
02:52:44 <goltrpoat> i was just looking at the latter.  i was trying to do something similar earlier i think.
02:52:46 <psykotic> "a functional correspondence between evaluators and abstract machines" might be a good place to start.
02:52:47 <Cale> goltrpoat: did you see those 3 books I posted here recently?
02:53:03 <Cale> http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html -- these :)
02:53:07 <lambdabot> Title: Books, http://tinyurl.com/yj25mf
02:53:43 <goltrpoat> cale:  i did, i have that one bookmarked
02:54:28 <mr_ank> Cale: nice!
02:54:33 <psykotic> aside from that, there are so many great old papers.
02:54:43 <goltrpoat> i was planning on going to the model theory one once i'm done with the thompson book and spj's books
02:54:45 <psykotic> anything by landin. anything by reynolds. the steele-sussman lambda papers. etc.
02:55:10 <goltrpoat> sussman gets around, doesn't he.
02:56:00 <goltrpoat> was looking for a 1970s paper by him about constraint programming recently, and then i remember reading a mechanics book by him.
02:56:37 <goltrpoat> reynolds who?  common name.
02:57:08 <psykotic> john
02:57:23 <goltrpoat> i get various random hits on p j landin, too.  links by any chance? :)
02:57:52 <psykotic> specific papers? the next 700 programming languages; the mechanical evaluation of expressions; the paper on formalizing algol; the paper on the j operator; etc
02:57:57 <goltrpoat> oh.  found stuff.
02:58:01 <psykotic> http://www.cis.upenn.edu/~bcpierce/courses/670Fall04/GreatWorksInPL.shtml
02:58:05 <lambdabot> Title: Great Works in Programming Languages, http://tinyurl.com/y499bu
02:58:09 <goltrpoat> oh right, ive read the algol papers
02:58:23 <psykotic> it's amazing how far ahead of his time landin was.
02:58:27 <goltrpoat> hell.. actually, i think i read that like.. back in 2004 when i was working on that compiler
02:58:30 <goltrpoat> that landin.  right.
02:58:46 <psykotic> he invented closures, the j operator (which is very close to call/cc), etc. so much shit.
02:59:12 <psykotic> also the whole notion of describing programming languages by desugaring them into a kernel language was his idea first, i think. he invented the term "syntactic sugar", even.
02:59:28 <goltrpoat> nuts.
02:59:42 <psykotic> yeah it's insane to read these papers from the mid 60's and see how much stuff he had figured out.
02:59:51 <monstre> Does anyone else have GHC 6.6 installed under Windows Millenium?
03:00:23 <goltrpoat> yeah, ive been like.. looking at dijkstra and knuth in a whole different light.  weird.
03:00:57 <goltrpoat> i think the first time ive read anything by those guys was about 17-18 years ago, heh.
03:01:24 <psykotic> dijkstra's approach is/was kind of anachronistic
03:01:26 <dons> monstre: I've not heard of any windows me users, but i'd suspect there were some. most seem to use XP.
03:01:30 <goltrpoat> then i was reading this summary by one of the early category theory in CS guys
03:01:35 <psykotic> axiomatic semantics doesn't really scale to larger programs.
03:01:38 <dons> monstre, sounds like an important detail though
03:01:53 <goltrpoat> and he was referring to knuth's attempt at formalizing abstract types.
03:02:24 <goltrpoat> at which point i went, huh?  and started trying to figure out who i loaned his books to.
03:02:56 <psykotic> goltrpoat, back then "programming languages" was one of maybe three first subfields of cs.
03:03:07 <goltrpoat> sure
03:03:34 <psykotic> knuth's papers were published a while ago by subfield. one for algorithms; one for programming languages; one for something else, i think.
03:03:40 <goltrpoat> yeah
03:03:55 <psykotic> err, i meant a collection of all his papers.
03:04:18 <goltrpoat> the trilogy that was a uh.. dilogy, for a rather long time.
03:04:57 <psykotic> i don't mean TAOCP, but "selected papers in <foo>", all of which were published only within the last 5 or so years, i think
03:04:57 <goltrpoat> i remember this book by charles wetherell from 1976 where he was making cracks about the fourth volume coming out some time in 2015.
03:05:10 <goltrpoat> oh the selected papers, right
03:05:14 <psykotic> http://www.press.uchicago.edu/cgi-bin/hfs.cgi/00/15466.ctl
03:05:17 <lambdabot> http://tinyurl.com/ymbk73
03:05:40 <psykotic> i think his main work in that field that's relevant now still was the invention of attribute grammars
03:07:24 <dons> ?users
03:07:24 <lambdabot> Maximum users seen in #haskell: 256, currently: 217 (84.8%), active: 20 (9.2%)
03:07:26 <goltrpoat> attribute semantics is in fact what that paper i mentioned referred to
03:07:32 <goltrpoat> and, sure.
03:07:37 <dons> ?uptime
03:07:38 <lambdabot> uptime: 4d 8h 2m 52s, longest uptime: 6d 15h 1m 36s
03:09:36 <goltrpoat> but anyway, my point was that this guy makes it seem like knuth made some sort of an attempt at a formalism that i'm sure i've missed while reading through his stuff way back when
03:10:09 <araujo> @pl (\ c -> isAlpha c || isDigit c)
03:10:09 <lambdabot> liftM2 (||) isAlpha isDigit
03:10:25 * araujo kisses lambdabot 
03:10:29 <goltrpoat> haha
03:12:10 <goltrpoat> anyway, thanks guys, i think i'm more than set here.
03:12:37 <mr_ank> Cale: the notes look great. Thanks! I'm a newbie here :)
03:13:44 <astrolabe> @seen dcoutts
03:13:45 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 7h 21m 18s ago.
03:14:13 <astrolabe> hmmm. Almost as though he goes to sleep.
03:14:41 <goltrpoat> odd.
03:22:15 <astrolabe> Has anyone here built gtk2hs using ghc6.6?
03:22:38 <int-e> yes
03:22:40 * gour didn't - tee bug
03:23:03 <astrolabe> int-e: Ah good.  Do you mind if I bother you with a question?
03:23:21 <int-e> no, but I'm not sure I can help
03:23:55 <astrolabe> I'm getting an error running    ./configure --prefix=C:/Gtk2Hs
03:24:17 <astrolabe> configure: error: Package requirements (glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0) were not met.
03:24:17 <astrolabe> Consider adjusting the PKG_CONFIG_PATH environment variable if you
03:24:17 <astrolabe> installed software in a non-standard prefix.
03:24:17 <astrolabe>  
03:24:17 <astrolabe> Alternatively you may set the GLIB_CFLAGS and GLIB_LIBS environment variables
03:24:17 <astrolabe> to avoid the need to call pkg-config.  See the pkg-config man page for
03:24:19 <astrolabe> more details.
03:24:46 <astrolabe> Does it mean anything to you?
03:25:13 <int-e> astrolabe: pkg-config doesn't know glib and gobject libraries - they're part of gtk ...
03:25:26 <int-e> astrolabe: they may have separate devel packages
03:26:21 <astrolabe> hmmm, I wonder if I have them.  I'll hunt around
03:26:22 <int-e> it's also possible that they're there but configure doesn't find them - I believe it uses pkg-config for that.
03:27:40 <int-e> gour: what's a tee error?
03:28:10 <int-e> gour: I think I know what tee does, but what could possibly fail there?
03:28:35 <gour> int-e: http://hackage.haskell.org/trac/ghc/ticket/724
03:28:38 <lambdabot> Title: #724 (tee complains if used in a process started by ghc) - GHC - Trac, http://tinyurl.com/szywh
03:29:24 <araujo> argh ... the tee bug
03:29:37 <araujo> oh you reporting it gour ?
03:30:30 <astrolabe> int-e: I have a glib directory inside gtk2hs-0.9.10  is that what it's looking for?
03:30:34 <Cale> mr_ank: cool :)
03:31:55 <Cale> Aw man, not enough people are modding up http://programming.reddit.com/info/o63e/comments :)
03:31:58 <lambdabot> Title: The Ruby Interpreter (reddit.com), http://tinyurl.com/yfont4
03:32:45 <Cale> Interesting misinformation :)
03:33:22 <Cale> Which is only misinformation because Ruby isn't an OO language here :)
03:33:27 <dcoutts> astrolabe, pong!
03:33:46 <bdbit> Cale: why is ruby not an OO language?
03:34:05 <Cale> bdbit: Because it's a declarative language for designing circuits ;)
03:34:10 <Cale> (See the paper)
03:34:36 <Cale> It's a completely unrelated language which just happens to be called by the same name
03:34:59 <int-e> astrolabe: no
03:35:01 <bdbit> oh
03:35:05 <int-e> astrolabe: it's lookinf for the C library
03:35:05 <dons> Cale: heh, I think its good that its still +tve
03:35:11 <Cale> hehe, yeah
03:35:19 <dons> Cale: it went negative a few times during the day ... ;)
03:35:30 <Cale> It was up at 3 just a few minutes ago
03:35:42 <dons> apparently those copyright infringing ruby guys can't take a joke
03:36:12 <int-e> ok, this is ridiculous. I know a patch that adds 1000 files is out of the ordinary but darcs crunching on it for over an hour (and still no sign of life) is silly.
03:36:13 <Cale> and I mean, it's not an inappropriate article for programming.reddit.com
03:36:24 <Cale> int-e: haha
03:36:38 <dons> int-e: hah. 1000 files eh?
03:36:44 <Cale> Darcs' algorithm is exponential complexity?
03:36:53 <dons> (i managed to get 400 of 4 year irc history into darcs in 10 mins or so)
03:37:01 <int-e> dons: it's not even my patch. it's in the Io VM repository.
03:37:05 <dons> so i wonder what's going on in yours. that was some 1900 files
03:37:16 <dons> s/400M/
03:37:43 <Cale> Sometimes there will be really small single patches which darcs totally chokes on
03:37:59 <JKnecht> still?
03:38:04 <Cale> I've had to completely wipe my lambdabot repo and re-get it a number of times.
03:38:22 <dons> really? i've never seen darcs be anything but a good citizen
03:38:31 <dons> maybe i don't do anything weird?
03:38:43 <int-e> and it's the initial patch of that I guess.
03:39:05 <Cale> What you might try is going through the patches one by one and seeing where it gets stuck
03:39:10 * JKnecht junked it for svn once I tried to give it prod status and a developer made an admission in re that
03:39:44 <JKnecht> s/junked/deferred pending further development/
03:40:28 <dons> "tried to give it prod status" ? "developer made an admission in re that" ??
03:40:40 <int-e> *tries a 'get' from scratch*
03:41:37 <JKnecht> relegated to secondary / non choice status might have been more accurate since of course happy to use with projects that choose it
03:41:57 <int-e> it's http://www.iolanguage.com/darcs/Io if anyone wants to look at it.
03:42:01 <lambdabot> Title: Index of /darcs/Io
03:42:56 <JKnecht> the developer (not Rowndy(sic)) acknowledged deficiencies in the theory of patches (in #darcs) and that it prolly wasn't best for production use
03:43:38 <dons> roundy. i think darcs is probably suitable for production these days -- pretty much everything in haskell, including ghc, has moved to it.
03:43:58 <wilx> Hm.
03:44:00 <int-e> hmm. 'get' worked.
03:44:15 <Cale> int-e: yeah
03:44:17 <int-e> strange.
03:44:31 <dons> see the new theory of patches paper, btw?
03:44:36 <Cale> It is. I think it's most likely a bug, but it's fairly rare
03:45:14 <dons> http://www.informatik.uni-bonn.de/~loeh/VersionControl.html
03:45:17 <lambdabot> Title: A Principled Approach to Version Control, http://tinyurl.com/y5q73m
03:45:27 <JKnecht> dons: good, last I checked was about 6 mos ago
03:47:15 <JKnecht> i'll try agin in a year or so
03:47:46 <int-e> hmm, could the fact that the old and the new 'inventory' have no patches in common confuse darcs? mumble.
03:48:40 <JKnecht> (burn me once, wait a year or ten before doing so again, regardles of your provenance)
03:49:12 <dons> i think perhaps software moves a bit faster than that, but suit yourself.
03:50:12 <JKnecht> src ctl is a special case; needs a mass use base to work out kinks; too mission critical to tolerate 'research'
03:51:07 <dons> hooray for higher order functions, laziness, and syntax-via-libraries: http://online.effbot.org/2006_10_01_archive.htm#with
03:51:10 <lambdabot> Title: online.effbot.org, http://tinyurl.com/yn6dvm
03:51:29 <dons> afaik, darcs isn't research, and never was. its not funded. it just yet another open source rcs
03:52:02 <dons> anyway, happily the haskell community has been the guinea pig for kink testing
03:52:11 <dons> most of which seem to have disappeared around 1.0.3 or so
03:52:17 <int-e> okay, maybe not really darcs' fault here ... looks like the old repository is gone and a new one was created - I have old patches in the directory where 'pull' failed that aren't found on the server.
03:52:48 <JKnecht> I meant to contrast 'research' and 'commercial'. Like when I contracted at IBM Research and Gerstner had started making the division earn it's living
03:52:51 <int-e> but darcs should have some way to notice that instead of spending hours on ... hmm ... on what, really?
03:54:25 <JKnecht> serious of pupose/fitness for purpose vs. intent/profit or other motive
03:54:42 <dons> but isn't subversion in the same boat? they're both just open source rcs?
03:55:12 <dons> of course subversion has a larger user base. but the goals of the dev community for both darcs and subversion are identical
03:55:14 <int-e> what does open source have to do with that?
03:55:22 <JKnecht> nothing
03:56:18 <dons> "src ctl is a special case; needs a mass use base to work out kinks; too mission" --> 'I meant to contrast 'research' and 'commercial'" --> but you're using subversion.  Maybe i didn't understand what you meant by `commercial'.
03:56:44 <astrolabe> test
03:57:25 <JKnecht> 'just works right' might have been a better expression
03:58:18 <Cale> dons: yeah, when I saw that python with-statement thing, I was rather unimpressed :)
03:58:40 <dons> Cale: can you imagine adding _syntax_ to haskell for something like that?
03:59:40 <dons> i guess the python guys don't even know what they're missing?
04:00:02 <Cale> Yeah, it feels like they're treating the symptoms and not the real problem
04:00:31 <int-e> so in darcs' theory it had 500 existing patches and one monstrous patch that conflicted with every single one of these ... ok, that can take a while to process.
04:00:41 <xerox-> ?yow
04:00:41 <lambdabot> As President I have to go vacuum my coin collection!
04:01:13 <Cale> Someone needs to write a really inflammatory article called "Is Python the next PL/1?"
04:01:28 <dons> heh
04:01:50 <JKnecht> that's cold
04:01:52 <dons> seems like its too easy to break the language^h^h^h^h add syntax, anyway
04:02:13 <int-e> uhm, which python comment?
04:02:13 <monstre> Does anyone have GHC 6.6 installed under Windows Millenium?
04:02:23 <Cale> int-e: http://online.effbot.org/2006_10_01_archive.htm#with
04:02:25 <lambdabot> Title: online.effbot.org, http://tinyurl.com/yn6dvm
04:03:22 <dons> monstre: did you submit the bug report?
04:03:42 <int-e> I'll say that Python's "from __future__ import" is extremely cute.
04:03:45 <monstre> dons: I'm about to, just wanted to check one last time if anyone had the same problem
04:04:24 <dons> ok. good.
04:05:38 <dons> Cale: doh. http://programming.reddit.com/info/o63e/details
04:05:41 <lambdabot> Title: The Ruby Interpreter (reddit.com), http://tinyurl.com/yyo8ka
04:05:52 <monstre> alright then, bug report sent
04:05:57 <Cale> dons: hehe
04:06:23 <dons> good, thanks monstre
04:06:33 <monstre> thanks for your help, dons
04:06:45 <dons> could be something to do with executable heap perhaps. i'm sure it'll get looked at in the next few days
04:06:55 <dons> until then, i'd go back to using 6.4.2 perhaps?
04:07:09 <monstre> that's the plan
04:07:25 <Cale> dons: My only consolation is that I'm doing better than the O'Caml report
04:07:32 <Cale> http://programming.reddit.com/info/o62v/details
04:07:35 <lambdabot> Title: The Objective Caml System (reddit.com), http://tinyurl.com/wjo3z
04:07:50 <dons> yeah, there's been a few rather old ocaml links submitted
04:08:04 <dons> no new ocaml content being created? trying to play catch up?
04:08:15 <dons> someone's up to something, anyway.
04:09:13 <Cale> Does O'Caml have a particularly thriving community? I have to admit I haven't really paid it much attention lately.
04:09:57 <Cale> heh, I'm #9 for controversy :)
04:10:08 <bdbit> does irssi have a search feature?
04:10:14 <dons> don't think the community is that big, and they're even less into blogging in english that the haskell community.
04:10:23 <bdbit> sometimes I would like to be able to search like in vim or less
04:10:43 <dons> unlike ruby, where the entire language seems to operate in the form of blogs and trackbacks
04:11:06 <bdbit> dons: the IRC channels are also very helpful
04:11:23 <dons> yeah, the seem very motivated. its interesting to learn from.
04:11:26 <dons> s/they/
04:11:27 <xerox-> bdbit: /last foo
04:11:54 <bdbit> xerox-: oh, thanks. not really what I searched for, but it's a start
04:12:02 <dons> if only the 'true' ruby language had such a community, eh Cale?
04:12:10 <Cale> hehe
04:12:38 <Cale> It's true
04:12:49 <xerox-> Let's rename Haskell... Sapphire?
04:13:03 <bdbit> I would approve it
04:13:20 <bdbit> two different diamonds for two different purposes
04:13:40 <bdbit> sounds pretty cool to be able to program in "Sapphire"
04:13:48 <dons> we have Generic 'Diamond' Haskell
04:13:55 <dons> and Sapphire Generic Haskell too, actually
04:13:55 <Cale> Diamond: The Hardest Programming Language on Earth
04:14:00 <dons> heh
04:14:03 <int-e> haha
04:14:23 <bdbit> Cale: wasn't that malbolge or befunge?
04:14:29 <dons> Diamond also scratches all other programming languages
04:14:40 <int-e> @remember Cale [discussing names for Haskell, after suggesting Sapphire] Diamond: The Hardest Programming Language on Earth
04:14:51 <xerox-> diamond.com/diamondwiki/CUT_the_knot
04:15:05 <dons> yeah, would have been a good name
04:15:16 <Cale> Malbolge is pretty hard, but it's not provably hard. I should implement my idea for using Blum-Blum-Shub pseudorandomisation to make arbitrarily hard to program but provably Turing complete languages :)
04:15:34 <goltrpoat> didn't java2k try that
04:15:40 <int-e> malbolge suffers from turing incompleteness.
04:15:44 <dons> hard, clear, cold. can be used in jewellery or industrial cutting machines. lots of good imagery
04:15:57 <therp> xerox: doesn't exist
04:16:02 <int-e> I never thought about it seriously for that reason.
04:16:19 <Cale> goltrpoat: sort of
04:16:20 <bdbit> therp: it was made up ;)
04:16:46 <xerox-> therp: http://haskell.org/hawiki/TyingTheKnot
04:16:47 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
04:16:51 <therp> oh damn, I should not get interested in parts and pieces of a conversation and start to click on interesting urls :)
04:18:10 <Cale> The programs I'm thinking of would be deterministic. The language spec would contain some 4096 bit key which was the product of two primes used for BBS-pseudorandomly permuting the instruction table. Other than that, it would be an ordinary language.
04:19:01 <Cale> Of course, you might have to eventually update the language spec if the key was ever successfully factored :)
04:19:13 <bdbit> is it possible to set irssi to auto-accept DCCs?
04:19:26 <dons> you really want that?
04:19:34 <bdbit> dons: for now, yes.
04:19:34 <ulfdoz_> bdbit: it is.
04:19:47 <bdbit> ulfdoz_: care to tell me how? or which /help topic it is in
04:19:47 <xerox-> /set dcc and press return, it'll show all the settings starting with "dcc"
04:19:47 <ulfdoz_> dons: You can limit auto-gets to masks.
04:19:51 <bdbit> ahh thx
04:19:57 <xerox-> or just do /set and see all of them
04:20:11 <ulfdoz_> bdbit: /set dcc_autoget
04:20:11 <bdbit>  /set dcc is fine ... </off_topic>
04:20:25 <goltrpoat> cale:  pfft.  clearly, this needs to be a dual key type deal.  you wouldn't want two people getting the same copy of the spec, would you?
04:20:31 <goltrpoat> or.. say..
04:20:38 <goltrpoat> two people getting the same copy of the compiler?
04:20:39 <goltrpoat> :)
04:21:58 <Cale> goltrpoat: It wouldn't be so bad. Code would be portable, just extremely difficult to write.
04:22:40 <xerox-> Cale, if you know the primes, you can translate readable code to your language, right?
04:22:44 <Cale> yeah
04:23:10 <goltrpoat> yeah, i just figured if one developer cracks it, they shouldn't be able to pass on the knowledge to another one
04:23:20 <goltrpoat> knowledge or binaries :)
04:23:40 <Cale> But factoring a 4096-bit key is still considered pretty hard :)
04:23:41 <goltrpoat> ooh.  encrypted VM.
04:24:00 <goltrpoat> yes, but think of the children.
04:24:09 <bdbit> LOL
04:24:20 <Cale> Well, we might have to release a new language version once in a while :)
04:24:24 <bdbit> it should be quantum caclulus proof
04:25:17 <xerox-> Cale, in some sense you are just delaying the ability to read code :)
04:25:45 <goltrpoat> cale:  it's precisely this sort of attitude that keeps millions of c++ programmers in business.
04:25:52 <goltrpoat> surely, we can do better.
04:26:20 <Cale> hehe
04:26:40 <bdbit> I think I'm addicted to DCC X_x
04:26:56 <Cale> bdbit: why? That's so 1994 :)
04:27:05 <bdbit> Cale: because it's so comfortable
04:27:28 <Cale> I've mostly been using mininova/bittorrent
04:27:35 <bdbit> transfers never really get below 20 kB/s and you get stuff prepackaged by releaser groups
04:27:42 <int-e> Cale: hmm, would a quine for that machine necessarily reveal the private key?
04:27:52 <psykotic> bdbot: you also have to sit on queues for god knows how long.
04:27:58 <bdbit> I like bittorrent but I can't seem to find the stuff I like on piratebay for example
04:28:03 <Cale> int-e: hmm
04:28:07 <psykotic> bdbit: use btjunkie.org, it's an aggregator.
04:28:23 <Cale> int-e: I don't know if it would, I'm not quite sure I see why it should.
04:28:28 <psykotic> it's also much better at ordering hits by health, something which tpb sucks at
04:28:41 <bdbit> psykotic: this net I'm in has most files on multiple bots.. If I get pos #8 or something, I just switch to another bot..
04:28:53 <bdbit> aggregator=
04:28:54 <bdbit> ?
04:29:09 <int-e> Cale: I'm assuming you only have access to the decoded stuff at runtime. Maybe I don't really understand what you're trying to do though :)
04:29:18 <bdbit> ahh, a crawler?
04:29:32 <psykotic> bdbit: i think it crawls other search engines for trackers. so it tends to have everything.
04:29:47 <bdbit> psykotic: sounds pretty cool.
04:30:10 <bdbit> I like BT very much anyway... Because it allows me to be a hub too...
04:31:45 <bdbit> psykotic: you've got me on the hook. I'll add btjunkie.org to my list of "must know"
04:33:10 <Cale> Well, okay, I haven't quite revealed all the details of how it should work. I suppose to really make it effective, you want an instruction table where most instructions do nothing, or perhaps stop the program immediately. Suppose there are n instructions. To interpret each instruction, choose a primitive root mod n pseudorandomly via BBS, and raise it to the power of the instruction code received. The value you get by
04:33:10 <Cale>  that is the instruction to actually run.
04:33:53 <Cale> mm, is that how I want it? :)
04:34:02 <Cale> Well, that certainly makes it hard to program :)
04:34:36 <int-e> I had a simpler model where you take an ordinary machine and just add an encoding step (with the private key) to get a proper 'executable'.
04:34:42 <int-e> the VM decodes it, then runs it.
04:35:27 <int-e> And the question was, if a program prints an encoded copy of itself, would it have to reveal the private key? I'm not sure.
04:36:32 <goltrpoat> an easier method has been suggested in the past, which involves sending an engineer, equipped with a bit of a sledgehammer, along with every distribution package.
04:36:38 <int-e> The usual rules for quines should apply - i.e. no access to anything but the (unencoded) data you had in the original program.
04:37:32 <Cale> Do we assume that the person using the program can observe the VM internals?
04:38:01 <int-e> I assume they can write their own VM, yes.
04:38:12 <int-e> i.e. the public key is really public.
04:38:17 <Cale> okay
04:39:24 <Cale> I sort of get the feeling that you could get by without revealing the key
04:40:23 <Cale> I can see what you mean though
04:40:30 <int-e> Oh and the quine shouldn't be all that long - I'm not really happy with the coincidential once in a gazillion quine, which probably exist.
04:40:55 <int-e> (Hmm, that is a bit hard to formalize.)
04:41:13 <Cale> hehe, we need to turn the set of programs into a measure space :)
04:41:34 <Cale> "The set of nonrevealing quines has measure zero"
04:42:24 <Cale> btjunkie is rather nice
04:43:06 <bdbit> Cale: I'd agree
04:43:57 <psykotic> cale: are there any nontrivial measures on countable sets aside from the counting measure?
04:44:03 <Cale> Also, Wayne Krantz is the most incredible guitarist ever. I don't think it's even possible to aspire to be that good :)
04:44:11 <psykotic> actually, nevermind, of course there are.
04:44:53 <int-e> Cale: that reminds me. http://www.cs.princeton.edu/~boaz/Papers/obf_informal.html is related, but I still haven't read the paper.
04:44:57 <lambdabot> Title: Can We Obfuscate Programs? / Boaz Barak, http://tinyurl.com/v6zqf
04:46:21 <psykotic> interestingly vxers use program obfuscation in an interesting way. (polymorphic viruses).
04:46:49 <goltrpoat> that was actually more interesting in the 90s
04:46:51 <psykotic> often they just do simple local transformations like inserting sequences of instructions that have a net zero effect.
04:46:58 <psykotic> but some do global rewriting.
04:47:02 <int-e> psykotic: what's 'vxer'?
04:47:20 <psykotic> goltrpoat, back when the most effective viruses weren't just microsoft word macros? :)
04:47:25 <goltrpoat> i guess 80s and 90s, but it seemed to sort of peak around early 90s
04:47:30 <goltrpoat> heh right
04:47:44 <psykotic> int-e: someone who writes viruses.
04:48:08 <dons> oh, this is much fun, http://pugs.blogs.com/talks/dls06-pugs.pdf
04:48:11 <dons> lambdabot even gets a run
04:48:41 <int-e> oh, wikipedia knows that. "not verified" though.
04:49:20 <psykotic> if you like assembly programming a lot of the old vx disk mags are a lot of fun to read. a lot of those guys were smart, unlike the current crop.
04:49:30 <goltrpoat> sure
04:49:38 <goltrpoat> used to read those.
04:50:18 <psykotic> interestingly i don't think any of the really fancy viruses ever really had a measurable effect in the wild.
04:50:23 <goltrpoat> then there was phrack, which got rather tedious around 95.
04:50:44 <goltrpoat> sure there were.  dark avenger stuff, for instance.  some of that was fancy.
04:51:19 <psykotic> true, but i'm talking about the ones with an effect on a larger economic scale. the ones you hear about on cnn were all fairly trivial from a technical point of view.
04:51:53 <goltrpoat> oh
04:52:15 <psykotic> of course that is partially because the guys with true skill weren't really interested in causing damage.
04:53:03 <goltrpoat> right, there was definitely a bit of that.
04:53:56 <goltrpoat> also, there's only so much damage you can cause by installing a TSR on a dos box with a 2400 baud modem.
04:53:56 <goltrpoat> heh
04:54:04 <Cale> haha, Arrow Length vs. Time
04:54:27 <psykotic> goltrpoat, you're forgetting about the floppy sneakernet :)
04:54:33 <psykotic> you didn't need any network
04:55:00 <int-e> hehe, I wonder why boot sector viruses were ever successful.
04:55:05 <goltrpoat> still, what's the damage.  the people who had the ability to do any real damage were phreakers, and that quickly got difficult.
04:55:54 <goltrpoat> and those guys were probably even more adamant about just screwing around, as opposed to causing any sort of lasting effects.
04:55:59 <psykotic> i remember there was a big outcry against a professor who was teaching a computer security course and had his students write viruses.
04:56:20 <psykotic> all the anti-virus companies gave a joint statement where they said they would refuse to hire anyone who had taken his course, etc
04:56:37 <goltrpoat> wasn't that like.. relatively recent?  some cs prof set up a box with some set of vulnerabilities and asked his students to hack into it
04:56:56 <goltrpoat> might be a different guy.
04:57:04 <psykotic> i don't think that was it, but yeah it was relatively recent. maybe 2-3 years.
04:57:38 <bdbit> psykotic: why especially the anti-virus companies? are they stupid?
04:57:43 <psykotic> yes
04:57:46 <goltrpoat> hehe that's mildly amusing though.  considering the number of former vx folk that anti virus companies employ.
04:57:59 <bdbit> I'd have expected they would have wanted to hire noone else
04:58:04 <bdbit> such a boycott can only harm THEM
04:58:10 <psykotic> bdash, it's a public image issue for them
04:58:18 <bdbit> you can only defend against something which you've done yourself
04:58:29 <int-e> He should've let them write a smart binary patch program (with a linker) instead ;)
04:58:34 <psykotic> remember that there's always been the conspiracy theory out there that the anti virus companies are directly or indirectly responsible for virus authoring
04:58:50 <psykotic> so they've always tried to distance themselves in any way from that
04:59:16 <bdbit> psykotic: LOL... "I really didn't eat your cake!" "But noone else knows that there even WAS a cake!"
04:59:48 <goltrpoat> psyk:  i think you're referring to the mcafee virus
05:00:04 <psykotic> i found a hilarious quote about this incident from an anti virus company spokesman. "Should we teach kids how to break into cars if they're interested in becoming a policeman one day?"
05:00:30 <goltrpoat> one of the old bulgarian viruses, a DA clone probably, come to think of it, was trying to attribute itself to mcafee for some reason.
05:00:38 <bdbit> they do learn that, isn't it?
05:00:52 <psykotic> bdash, right, i'm pretty sure they're taught the techniques at some level, which is why it's hilarious.
05:01:09 <bdbit> psykotic: you're always miscompleting me it seems :D
05:01:24 <psykotic> if they wanted to go over the top they should have made an analogy between police murder investigation and committing murder
05:01:30 <psykotic> bdbit, sorry :)
05:01:37 <bdbit> psykotic: np ;)
05:01:45 <goltrpoat> or a vice patrol and a blowjob.
05:01:58 <goltrpoat> good lord is this off topic.
05:02:21 <bdbit> that really does sound like hypocrisy from the frontiers of AV comps
05:02:43 <bdbit> I'd never know how to defend against viruses if I hadn't looked into the topic myself
05:03:02 <bdbit> what do they gain from NOT having them on their pay list
05:03:30 <bdbit> oh, I see, they'll probably write viruses out of frustration which in terms makes the AV companies appear more needed
05:04:19 <goltrpoat> haskell anyone? :)
05:04:36 <_roconnor> I'll take one
05:04:50 * goltrpoat hands roconnor a haskell.
05:04:52 <goltrpoat> anyone else?
05:04:58 <bdbit> if you want you could give me code for some (small) problems I have then explain it :D
05:05:19 <bdbit> I want a dozen
05:06:22 * _roconnor wonders if Edgy has ghc 6.6
05:09:43 <dcoutts> I used to work for an AV company and kept thinking about how to write a undetectable virus using Haskell
05:10:22 <Cale> The best thing to infect is a compiler :)
05:10:27 <dcoutts> The AV companies talk about 'polymorphic' viruses
05:10:29 <velco> I knew it! That viruses are made by AV companies!
05:10:36 <dcoutts> hah hah hah
05:10:42 <dcoutts> velco, I never wrote it :-)
05:10:45 <psykotic> cale: hehe, reminds me--have you read thompson's turing paper on "infecting" compilers?
05:10:47 <velco> :D
05:10:56 <psykotic> turing award paper, even
05:11:07 <Cale> psykotic: I don't think so, but I have discussed the issue with people before.
05:11:27 <dcoutts> by 'polymorphic' viruses they mean ones that change their own code to make them less easily detectable by pattern recognition
05:11:30 <psykotic> http://www.acm.org/classics/sep95/
05:11:30 <lambdabot> Title: ACM Classic: Reflections on Trusting Trust
05:11:44 <psykotic> dcoutts, is there a parametricity theorem for them? :)
05:11:49 <Cale> class Virus a where
05:11:52 <dcoutts> psykotic, heh, no.
05:12:11 <dcoutts> but I don't think anyone has ever written a really good polymorphic virus
05:12:21 <dcoutts> or even just a non-infectious one
05:12:28 <dcoutts> that simply proves the point
05:12:41 <dcoutts> I'd do it comprehensively:
05:12:42 <bdbit> dcoutts: I think it didn't get detected
05:12:56 <dcoutts> bdbit, that's possible :-)
05:13:10 <bdbit> plus it's pretty impossible to write polymorphic code in HLL
05:13:20 <dcoutts> bdbit, ah, no. :-)
05:13:26 <bdbit> I'd suppose Haskell can't do polymorphic code at all
05:13:29 <dcoutts> bdbit, there are some viruses that they have in the virus labs which they know about but can't reliably detect
05:13:39 <psykotic> dcoutts, the fact that the payload should be so small means that the sophiscation is limited.
05:13:40 <dcoutts> bdbit, you just write a disasembler in Haskell.
05:13:44 <bdbit> dcoutts: I expected something like that
05:13:57 <bdbit> dcoutts: what use does a disasm alone have?
05:14:16 <psykotic> bdbit, you typically do that in polys
05:14:23 <psykotic> you disassemble your own code and then rewrite it
05:14:24 <bdbit> psykotic: I'd write pure ASM
05:14:30 <bdbit> yeah ok
05:14:34 <bdbit> if you have a complex program coded in C
05:14:43 <bdbit> but there are pretty helpful assemblers these days
05:14:50 <bdbit> that have constructs like ".if" etc.
05:15:00 <psykotic> i meant for polymorphics.
05:15:04 <bdbit> In an OS like windows it's 90% library calls anyway
05:15:20 <psykotic> the way they polymorphi is typically by disassembling their own code and then reassembling it with some kind of restructuring thrown in
05:15:24 <bdbit> psykotic: I'd just make it periodically reencapsulate itself
05:15:30 <bdbit> that way you get a lot of "new versions" all the time
05:15:37 <dcoutts> so, so what you'd do is disasemble the programs code, break it up into basic blocks, make it into a graph in memory and then serialise blocks again in a random order.
05:15:51 <bdbit> dcoutts: oh, I see
05:15:53 <dcoutts> that'd also work for infecting another executable, just mix all the blocks
05:16:05 <dcoutts> and you could do random changes to each block too
05:16:12 <bdbit> encapsulate!
05:16:23 <dcoutts> substituting equivalent spans of code
05:16:55 <dcoutts> and turn each block into a graph too, by computing the load / store dependencies of the instructions
05:17:18 <dcoutts> then reorder the instructions while still respecting the load store deps
05:17:26 <dcoutts> and you could permute the registers
05:17:54 <bdbit> dcoutts: I think I understand what you mean.
05:18:22 <dcoutts> that could not be detected via the simple pattern languages the AV companies use
05:18:38 <psykotic> don't do the AV companies use emulation anymore?
05:18:42 <dcoutts> it's behaviour is obviously not altered, so you could use behavioural techniques
05:18:46 <psykotic> that's how they started dealing with polymorphics originally, iirc
05:18:55 <dcoutts> but that's never reliable anyway
05:19:09 <dcoutts> and it could be detected by statistical methods
05:19:24 <bdbit> but that would generate false positives?
05:19:27 <dcoutts> randomly permuting basic blocks will give a distinct signature
05:19:34 <goltrpoat> one might say that polymorphic viruses can be written with those "basic blocks of code" as primitive functions in a pure functional program, and then they're polymorphic up to order of beta-reduction.
05:19:38 <dcoutts> but you could turn down the randomness 'til it was less distinctive
05:19:45 <goltrpoat> if one were inclined to say so.
05:24:18 <bdbit> damnit
05:24:22 <bdbit> azureus just crashed
05:24:57 <JKnecht> azureus?
05:25:01 <bdbit> a BT client
05:27:49 <bdbit> Bittorrent trackers are like supermarkets for me. there I see all the stuff I never needed, but I instantly want to have it.
05:28:48 <JKnecht> haven't used much. Did use donkey whatever some a couple years ago
05:29:13 <bdbit> I used to, too. But I am too lazy to set it up on linux
05:29:33 <JKnecht> i used on mac
05:29:45 <bdbit> Azureus came with such a useful out-of-the-box configuration that I now continue to use it, even tough I only wanted to download some distro .ISO initially
05:30:14 <bdbit> hm... linux distributions - the gateway drug to compulsive file sharing
05:30:28 <bdbit> wonder if there's a treatment
05:31:44 <JKnecht> i mentioned i used whatever the rusky thing was that came after napster to somebody and they expressed suprise that I would accept a moral stain so I broke off. Only use iTunes and the like now.
05:32:33 <bdbit> I view it more as a moral obligation
05:33:33 <bdbit> the so-called "music industry" (oh how wrong it is to generalize.. although... those pesky Java folks do it all day long, too) behaves so antisocially.. I'd rather have pay-if-you-like-it, like some artists already do it
05:34:19 <JKnecht> yeah with current state of the class struggle could be entirely valid for YOU to so think, but not me at this point
05:35:21 <bdbit> JKnecht: I agree. If I could afford it, I'd pay, too. I just don't see the point in paying 20$+ (CDs over here don't go for less) for stuff that I listen to... TWICE
05:36:07 <bdbit> the stuff that I *would* like to support is N/A here anyway...
05:36:46 <JKnecht> there's no haskell streaming client?
05:37:07 <JKnecht> mp3 player or nuthin?
05:37:49 <bdbit> wasn't there a cute console mp3 player coded in haskell?
05:37:58 <bdbit> hmp3 or something, I really liked the way it looked
05:38:07 <bdbit> it'll maybe replace my mp3blaster
05:38:16 <dons> ?where hmp3
05:38:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
05:38:38 <bdbit> dons: it's yours?
05:38:52 <dons> yep :)
05:38:57 <bdbit> dons: it rocks :>
05:39:01 <dons> cheers.
05:39:16 <bdbit> although I don't know how good mpg{321,123} is
05:39:40 <dons> mpg321 seems quite reasonable. adding ogg and so on should be done though
05:41:31 <bdbit> someone should make an ebuild for gentoo
05:41:54 <dons> oh, i think there is, already. dcoutts did one
05:42:22 <dcoutts> yep, there's an hmp3 ebuild in the haskell overlay
05:42:41 <emk> A question: I'm messing around with lhs2TeX, and would like to format my "typeOf" function using a reasonably standard mathematical notation.
05:42:45 <bdbit> dcoutts: I don't have the haskell overlay... overlays scare me >_<
05:42:59 <dcoutts> s'ok, you don't have to use it :-)
05:43:20 <bdbit> but I'd like to conveniently install hmp3 though
05:43:30 <emk> I know the notations for the typing relation, of course, but is there a nice way to express a typing function?
05:43:55 <dcoutts> things eventually move from the overlay into portage when they've been tested and are generally ready
05:44:03 <dcoutts> and if there's enough demand
05:44:47 <JKnecht> emk: I imagine it uses amstex and you're supposed to look for something in their that suits your taste
05:45:00 <JKnecht> s/their/there/
05:45:39 <emk> JKnecht: Thanks! I was just trying to find an exiting notation to reuse, for the sake of my readers. :-)
05:48:33 * emk digs through the joined LaTeX, AMS, etc. symbols list.
05:49:19 <JKnecht> CTAN search retreived about 50 results including a pkg 'fmp'
05:51:10 <dons> ?google symbols-a4.pdf
05:51:12 <lambdabot> http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf
05:51:20 <dons> is really nice...
06:00:32 <bdbit> dcoutts: fine
06:01:16 <int-e> gour: I think I know what causes that tee bug. It's not a ghc bug imho.
06:01:59 <araujo> Anyone has worked with Happy here?
06:06:56 <gour> int-e: what it is?
06:07:34 <int-e> gour: ghc sets stdout to nonblocking and the glibc chokes on that.
06:08:42 <Igloo> It's tee not handling EAGAIN or EINTR or something rather than glibc
06:08:45 <cpriester> Hi! Is it possible to save information on a recursive calculation? i.e. i want to use a recursive formula on big numbers, and i need intermediate results for further calculation...
06:08:58 <int-e> Igloo: no, it's glibc
06:09:06 <Igloo> But deciding the bug is with every other application won't actually make it get fixed  :-)
06:09:07 <int-e> Igloo: tee uses fwrite(), fwrite() fails.
06:09:25 <int-e> Igloo: and it should *not* do that for a mere EAGAIN
06:09:42 <Cale> cpriester: define a datastructure consisting of the results you'll need
06:10:03 <cpriester> what does this look like? In C i would use an array...
06:10:08 <int-e> Igloo: (I have patched tee to track that down, so I'm fairly sure this is what happens. I'm looking at glibc code now.)
06:10:29 <int-e> Igloo: the glibc code is convoluted though.
06:10:34 <Igloo> int-e: Can you find a standard glibc aims to conform to that says that?
06:10:49 <Cale> cpriester: well, you could use an array here too :)
06:10:56 <cpriester> When i use lists, or something like that, the complete structure must be copied on every recusrion step?
06:11:11 <Igloo> int-e: Certainly write() is allowed to fail with EAGAIN according to my manpage, so anything you pipe into useing write can fail if it doesn't expect stdout to be non-blocking
06:11:32 <Cale> cpriester: no, when you pass a list, it's passed as a pointer
06:11:33 <dolio> Cale: I was fooling with your random monad, and came across a need to use it in transformer stacks, so I added what I wrote to the wiki page. Do they look correct to you?
06:11:51 <Cale> cpriester: in fact, all passing of values is done as pointers (or at least you can imagine it that way)
06:11:56 <cpriester> Cale: Ok. But Lists do not have constant access time...
06:12:03 <Cale> cpriester: right, but arrays do :)
06:12:04 <cpriester> Do Arrays so?
06:12:09 <int-e> Igloo: hmmmmm.
06:12:17 <cpriester> ok.
06:12:17 <Cale> and arrays can have lazily computed elements as well
06:12:24 <Cale> but they must have fixed size
06:12:49 <cpriester> Fixed size is no problem.
06:13:04 <cpriester> And the array can be modified in the calculation?
06:13:07 <Cale> Actually, what you're doing when you're passing parameters in Haskell is passing pointers to code which either computes the value, or if it's already been computed, returns it immediately.
06:13:10 <int-e> Igloo: ok, maybe I was a bit too fast there. let me see if I can find something about this.
06:13:25 <Cale> Well, no, but typically it won't have to be
06:13:40 <Cale> You can make an array of results which depend on other elements of the array
06:13:53 <Cale> and nothing is computed until needed
06:14:01 <Cale> Let me find an example on the wiki
06:14:10 <Cale> (I've been struggling to locate it :)
06:14:50 <uip> Cale: what about unboxed array?
06:14:54 <int-e> Igloo: ok, tee should deal with it then, right.
06:15:01 <Cale> uip: that's where unboxed arrays fall down
06:15:11 <cpriester> Well, that array does just contain previous results of that recursive function... Perhaps there is another way to do, what i want...
06:15:21 <Igloo> int-e: Fixing tee would only fix one particular symptom
06:15:24 <Cale> Well, here, I'll type an example :)
06:15:31 <cpriester> so arrar[m] = f(m)
06:15:39 <Cale> cpriester: yeah
06:15:49 <Cale> that's the idea, and f refers to elements of the array
06:15:50 <Igloo> int-e: It would be much better to change GHC to use blocking IO
06:16:01 <araujo> mm
06:16:12 <araujo> So ghc is having problems with tee?
06:16:22 <int-e> Igloo: is there anything that says stdin does blocking I/O on program startup?
06:16:41 <cpriester> anf f(m) should return array[m], if m is small enough
06:17:08 <int-e> Igloo: err, stdout.
06:17:11 <dolio> The best article I've seen on memoizing with lazy array elements is on the old wiki.
06:17:14 <dolio> http://haskell.org/hawiki/MemoizingRecursion
06:17:14 <Igloo> int-e: Probably not, but declaring the bug to be in every other program isn't going to help fix it
06:17:15 <lambdabot> Title: MemoizingRecursion - The Haskell Wiki
06:18:04 <cpriester> Ah. That is, what i need. Thanks!
06:18:08 <Igloo> araujo: http://hackage.haskell.org/trac/ghc/ticket/724
06:18:12 <lambdabot> Title: #724 (tee complains if used in a process started by ghc) - GHC - Trac, http://tinyurl.com/szywh
06:18:27 <int-e> Igloo: right ... I'm just wondering if that's a bug in tee anyway. Or maybe the glibc could do some fcntls on program initialization.
06:18:44 <Cale> lisppaste2: url
06:18:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
06:18:57 <lisppaste2> Cale pasted "memo" at http://paste.lisp.org/display/28861
06:19:04 <int-e> Igloo: I'm not sure :)
06:19:13 <Igloo> int-e: Me neither  :-)
06:19:20 <Cale> that's how you'd do it if you don't mind an array sitting around forever and ever
06:20:04 <Cale> If you'd rather have that array thrown away, and only kept through one recursive call, you'd move it into a let/where of fib and then use a helper function
06:21:05 <cpriester> ok.
06:21:48 <cpriester> And that array will calculate only if it must?
06:22:10 <Cale> right
06:22:48 <uip> what is the functional programming equivalent of metaclasses?
06:23:39 <Cale> uip: I suppose that would depend on what one considers the functional programming equivalent of classes to be :)
06:24:32 <uip> i think that would be existential types
06:24:44 <cpriester> Why cant i just return fibsMemo n?
06:24:50 <cpriester> It should calculate that, too?
06:25:15 <Cale> cpriester: well, the instruction to add needs to be somewhere :)
06:25:29 <cpriester> Ah, ok.
06:25:54 <Cale> That might not have been the cleanest way to write that though, you're right
06:26:48 <Cale> uip: well, existentially typed values are of course, just ordinary values. So you could use functions to build them like anything else.
06:27:07 <Cale> Even functions which are parts of other existentially-typed values
06:28:18 <uip> yes
06:31:20 <cpriester> Hm. looks like an endless loop...
06:32:11 <Cale> It's not really magic, you do need to have to make sure all your base cases are there so that the thing actually can get started
06:33:56 <int-e> Igloo: btw it's ghc's meddling with stdin that causes this. is that a problem with ptys?   < /dev/null ./a.out "yes | head -n 20000000" | tee /dev/null  runs fine, so does the same with the tee inside the command.
06:35:11 <Igloo> int-e: I'm not sure of the details OTTOMH
06:38:51 <bdbit> re
06:39:08 <dcoutts> int-e, the problem I think is that the non-blocking property of the file handle is shared by all processes
06:39:26 <dcoutts> and tee expects blocking behaviour which ghc sets it to be non-blocking
06:39:44 <dcoutts> which/while
06:46:15 <int-e> dcoutts: yes, I just found where POSIX prescribes that. (argh)
06:47:00 <dcoutts> int-e, so one possibility is to make tee more tolerant
06:47:22 <dcoutts> or use something in between ghc and tee that is tolerant
06:47:39 <dcoutts> making ghc not use non-blocking IO would not be a good solution
06:47:45 <int-e> yes, but it also means that another program changing the terminal to block will affect ghc's rts
06:47:49 <Igloo> dcoutts: Why not?
06:47:59 <dcoutts> Igloo, then we have to use lots of OS threads
06:48:08 <dcoutts> int-e, true
06:48:31 <int-e> ugly.
06:48:34 <Igloo> dcoutts: I don't think that's true, but I haven't gone into the details yet
06:49:09 <dcoutts> int-e, but that interference is prescribed by posix, so I dunno how any prog is supposed to cope with not knowing which mode the FD is in.
06:49:12 <ihope> @hoogle listen
06:49:13 <lambdabot> Network.Socket.listen :: Socket -> Int -> IO ()
06:49:14 <lambdabot> Control.Monad.Writer.listen :: MonadWriter w m => m a -> m (a, w)
06:49:14 <lambdabot> Network.listenOn :: PortID -> IO Socket
06:49:34 <dcoutts> Igloo, ok, I'll be surprised.
06:49:53 <ihope> @docs Network
06:49:54 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
06:50:06 <int-e> dcoutts: yes, that seems hard. I was assuming this was done on a per process or per fd basis. But it's not.
06:50:29 <dcoutts> it is per-fd but shared by all processes
06:50:36 <dcoutts> and using dup/dup2 doesn't help
06:51:08 <dcoutts> I've no idea why it's done like that. I can't see any advantage.
06:52:14 <int-e> maybe there are historical reasons. the kernel has less data to handle.
06:53:24 <dcoutts> int-e, seems that dragonfly has fixed this in their kernel
06:53:30 <dcoutts> http://www.dragonflybsd.org/community/release1_6.cgi
06:53:33 <lambdabot> Title: DragonFly - July 2006 Release 1.6.x Download, http://tinyurl.com/yy52z5
06:53:58 <dcoutts> # Add system calls that allow a blocking/non-blocking flag to be passed independant of the O_NONBLOCK state of the descriptor.
06:53:58 <dcoutts> # Remove all fcntl(... O_NONBLOCK) calls from libc_r, use the new system calls instead. This solves numerous problems with file descriptors shared between threaded and non-threaded programs getting their non-blocking flag set, and then blowing up the non-threaded program.
06:54:27 <cpriester> Cale: Calculation is slower, when using this array...
07:00:58 <ihope> This Haskell network server thing doesn't seem to be accepting connections.
07:02:11 <dolio> cpriester: Can you paste the code?
07:02:16 <cpriester> where can I?
07:02:20 <dolio> ?paste
07:02:21 <lambdabot> http://paste.lisp.org/new/haskell
07:03:34 <lisppaste2> cpriester pasted "Modfib" at http://paste.lisp.org/display/28862
07:03:47 <cpriester> http://paste.lisp.org/display/28862
07:05:44 <bdbit> btw, how are multiple print statements executed after each other?
07:06:00 <bdbit> or any imperative stream of statements in haskell for that matter
07:06:08 <dolio> cpriester: Well, the problem is that you're continually recomputing arrays.
07:06:51 <Syzygy-> bdbit: Monads.
07:07:09 <Syzygy-> bdbit: To be specific, the IO monad.
07:07:13 <bdbit> Syzygy-: can you provide an example? what if I want to do "print (fac 20)" then "print (fac 10)"
07:07:15 <Syzygy-> So you wrap it all in a do-block.
07:07:18 <dolio> cpriester: Would fibmod be a function of 2 arguments if you weren't trying to memoize?
07:07:25 <Syzygy-> do print (fac 20); print (fac 10)
07:07:30 <bdbit> oh.
07:07:30 <uip> print (fac 20) >> print (fac 10)
07:07:46 <Syzygy-> uip: Which, of course, is more or less isomorphic to my code piece...
07:07:47 <cpriester> Yes, the number n and the modulo..
07:08:01 <uip> it's more then isomorphic, it's identical
07:08:34 <Syzygy-> uip: Well then.
07:09:07 <bdbit> Syzygy-, uip thx
07:09:09 <cpriester> but m is constant for one run.
07:09:25 <int-e> dcoutts: interesting
07:10:59 <cpriester> So, why should that array be computed twice or more?
07:11:34 <dolio> cpriester: Every time you call fibsMemo m, it creates a new array.
07:12:05 <dolio> cpriester: And even if it's floated out as a common subexpression, it won't be shared for recursive invocations.
07:12:08 <bdbit> > let main = do { 1 + 2; 3 + 4 } in main   -- like this?
07:12:08 <lambdabot>  add an instance declaration for (Num (m b))
07:12:09 <lambdabot>   In the result of a 'do' exp...
07:12:15 <dolio> cpriester: So no actual memoization will be done.
07:13:02 <cpriester> How can i do it right?
07:13:23 <cpriester> In Cales paste, it is done the same way, so far i can see...
07:13:41 <bdbit> Syzygy-: can you provide an example, pleasE?
07:13:50 <bdbit> oh, you did
07:14:19 <dolio> The right way for this example is probably to use a helper function and have fibsMemo in a where clause.
07:14:23 <bdbit> I always get a parse error
07:14:24 <dolio> Let me annotate it.
07:14:58 <dolio> Hmm, well, paste seems to be broken now...
07:15:07 <cpriester> Is it recomputed, because of that m as argument?
07:15:31 <dolio> Basically.
07:16:34 <dolio> fibmod n m computes a fibsMemo m, which references fibmod n m (for a lesser n), which in turn computes its own fibsMemo m.
07:17:00 <dolio> So in addition to not memoizing, you're also allocating lots of arrays.
07:17:11 <Syzygy-> bdbit: The problem with your example up there is that "1+2" is something entirely pure and not monad-encapsulated.
07:17:30 <bdbit> Syzygy-: ouch
07:17:44 <cpriester> That means, it uses only the same array every time, if it does not look like a function?
07:17:45 <bdbit> Syzygy-: Where can I learn about that stuff? is it covered in the Haskell.org-tutorial?
07:18:15 <dolio> What you'd need is something like "fibmod n m = fibmod' n where fibsMemo = [ ... ] ; fibmod' n = ..."
07:18:40 <dolio> Where fibsMemo uses fibmod', and they both make use of the m in the enclosing scope.
07:18:43 <cpriester> what is that '? is that only the name?
07:19:02 <Syzygy-> bdbit: It's in the texts on haskell.org. I couldn't say where I picked up all of it, a bit here in the channel, a bit on conferences with experts on the category theory entities that get used...
07:19:03 <dolio> Haskell lets you use ' in function names.
07:19:16 <bdbit> Syzygy-: oww....
07:19:48 <ihope> http://pastebin.ca/226436 <- I'm running this from GHCi under Windows, and it's not accepting the connection.
07:19:54 <dons> > let x' = 1 in x'
07:19:56 <lambdabot>  1
07:20:11 <dons> > let x = 1 in x' = x in x'' = x' in x''
07:20:11 <lambdabot>  Parse error
07:20:18 <dons> my bad :)
07:20:24 <ihope> > let x'' = 1 in x''
07:20:26 <lambdabot>  1
07:20:44 <dons> > let x = 1 in let x' = x in let x'' = x' in x'' -- time for bed!
07:20:45 <lambdabot>  1
07:21:14 <ihope> > let 'x = 3 in 'x
07:21:15 <lambdabot>  Improperly terminated character constant
07:21:22 <ihope> I see.
07:21:30 <Syzygy-> > let x'x = 3 in x'x
07:21:30 <cpriester> dolio: i do not really understand...
07:21:32 <lambdabot>  3
07:21:36 <ihope> > let x'x' = 3 in x'x'
07:21:38 <lambdabot>  3
07:21:43 <Syzygy-> I think they can contain ' but not begin with '.
07:21:45 <cpriester> that array should also be availabe for further function calls...
07:21:47 <dons> that's a little known lexical issue there
07:21:58 <dons> people don't use my'long'identifier
07:22:05 <Syzygy-> Since begin with ' signals "I'm starting a character literal"
07:22:06 <dons> maybe we should, just to annoy everyone else..
07:22:12 <ihope> > let x !' y = 3 in '!'!''!'
07:22:13 <lambdabot>  Improperly terminated character constant
07:22:22 <ihope> > let x !' y = 3 in '!' !' '!'
07:22:23 <lambdabot>  Improperly terminated character constant
07:22:36 <Syzygy-> > let my'long'identifer'could'be'spelled'like'this' = 2 in my'long'identifer'could'be'spelled'like'this'
07:22:38 <lambdabot>  2
07:22:47 <dons> > let _x = _x in 1
07:22:48 <lambdabot>  1
07:22:55 <ihope> > let _' = 1 in _'
07:22:57 <lambdabot>  1
07:23:00 <dons> heh
07:23:11 <dons> ihope++
07:23:20 <Syzygy-> > let a x' b = 3 in 'x'x''x'
07:23:21 <lambdabot>  Not in scope: `x''x''
07:23:25 <Syzygy-> > let a x' b = 3 in 'x' x' 'x'
07:23:26 <lambdabot>  Not in scope: `x''
07:23:34 <Syzygy-> > 'x'
07:23:36 <lambdabot>  'x'
07:23:56 <ihope> > let __ = 3 in __
07:23:57 <lambdabot>  3
07:24:01 <Syzygy-> > let x' a b = 3 in 'x' `x'` 'x'
07:24:03 <lambdabot>  3
07:24:06 <Syzygy-> Hah!
07:24:15 <dons> nice!
07:24:17 <Syzygy-> > let x' a b = 3 in 'x'`x'`'x'
07:24:19 <lambdabot>  3
07:24:19 <ihope> Well then, just use various numbers of underscores for all your variable names.
07:24:34 <Syzygy-> Or, y'know, underscores and ' interspersed...
07:24:36 <Syzygy-> > let _
07:24:37 <lambdabot>  Parse error
07:24:49 <ihope> __ _ [] ___ = ___
07:24:50 <lisppaste2> dolio annotated #28862 with "suggestion" at http://paste.lisp.org/display/28862#1
07:24:52 <Syzygy-> > let _'__'_'''_'__'_=2 in _'__'_'''_'__'_
07:24:54 <lambdabot>  2
07:25:00 <dons> mmm tasty
07:25:07 <dons> like morse code
07:25:14 <dons> ?google remorse haskell
07:25:16 <lambdabot> http://www.army.mil/soldiers/may2001/features/sniper.html
07:25:16 <lambdabot> Title: Soldiers Online Feature Articles
07:25:21 <dons> nope
07:25:39 <dolio> cpriester: There. Annotated.
07:26:04 <cpriester> dolio: But that does only work for one function call...
07:26:56 <cpriester> hm? You call fibmod' with two arguments, bur fibmod' does only take one?
07:27:05 <dolio> cpriester: Yeah. You could also memoize on (n,m).
07:27:13 <dolio> cpriester: But that'd take a larger array.
07:27:27 <dolio> Oh, yeah. My mistake. That should be fibmod' n
07:27:59 <ihope> __ ___ ____ (_____:______) = ___ _____ (__ ___ ____ ______); __ _ [] ___ = ___
07:28:04 <cpriester> Ok. And fibmod' can use that m, too...
07:29:04 <Syzygy-> ihope: You are perverse. And that does look like a rather funky hangman's puzzle...
07:29:10 <dolio> Right. m is only bound when fibmod is called. Then fibsMemo and fibmod' share that m.
07:29:38 <ihope> > let __ ___ ____ (_____:______) = ___ _____ (__ ___ ____ ______); __ _ [] ___ = ___ in __ (+) 0 [1,2,3]
07:29:39 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
07:29:39 <lambdabot>    Expected...
07:29:41 <int-e> > let (||)!(|!)=(||)+(|!) in 12!13
07:29:43 <lambdabot>  25
07:29:53 <ihope> Hmm.
07:30:04 <ihope> Oh.
07:30:14 <ihope> > let __ ___ ____ (_____:______) = ___ _____ (__ ___ ____ ______); __ _ ___ [] = ___ in __ (+) 0 [1,2,3]
07:30:15 <lambdabot>  6
07:30:58 <ezraburgh> #coq
07:31:04 <ihope> Here, let's see if we can add some clarity...
07:31:30 <cpriester> Hm. that multiple "where" produces parse errors..
07:31:45 <ihope> > let # __ ___ (____:_____) = __ ____ (# __ ___ _____); # _ __ [] = __ in # (+) 0 [1,2,3]
07:31:46 <lambdabot>  Parse error
07:31:58 <int-e> @pl let __ ___ ____ (_____:______) = ___ _____ (__ ___ ____ ______); __ _ ___ [] = ___ in __ (+) 0 [1,2,3]
07:31:59 <lambdabot> (line 1, column 5):
07:31:59 <lambdabot> unexpected "_"
07:31:59 <lambdabot> expecting natural, identifier or "in"
07:32:14 <lisppaste2> dolio annotated #28862 with "alternative" at http://paste.lisp.org/display/28862#2
07:32:16 <int-e> oh. right.
07:32:19 <ihope> @pl ___
07:32:19 <lambdabot> (line 1, column 1):
07:32:20 <lambdabot> unexpected "_"
07:32:20 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
07:32:30 * ihope kicks pl slightly
07:32:37 <ihope> Now... yes.
07:32:39 <ihope> > let _# __ ___ (____:_____) = __ ____ (_# __ ___ _____); _# _ __ [] = __ in _# (+) 0 [1,2,3]
07:32:40 <lambdabot>  Parse error in expression
07:33:05 <ihope> I'm guessing lambdabot doesn't like # in those things.
07:33:12 <dolio> cpriester: Well, I didn't define all of fibmod'. The "..." isn't allowed. I just didn't want to retype all the stuff in the original paste.
07:33:37 <cpriester> :)
07:33:38 <ihope> > let _' __ ___ (____:_____) = __ ____ (_' __ ___ _____); _' _ __ [] = __ in _' (+) 0 [1,2,3]
07:33:40 <lambdabot>  6
07:33:43 <ihope> There we go.
07:33:46 <cpriester> That was already clear..
07:33:54 <dolio> Oops, in that second annotation, there should only be one !.
07:35:15 <cpriester> Ah, it works... Wring indentation..
07:35:28 <int-e> > let foldl (?) i (x:xs) = x ? foldl (?) i xs; foldl _ i [] = i in foldl (+) 0 [1,2,3]
07:35:30 <lambdabot>  6
07:35:36 <cpriester> And it works fast..
07:36:08 <cpriester> But that array will be calculated for every function call, now, will it?
07:36:25 <cpriester> I have to call the function several times with the same modulo.
07:36:38 <dolio> Yeah, because it has to know m before it can calculate the array.
07:36:57 <dolio> If you want to share between function calls, you need to memoize on m as well, like in the second annotation.
07:37:32 <cpriester> Ok. That is not so bad, i think...
07:40:03 <cpriester> is it possible to make that calculation function simpler? It it two times the same formula, that calls different functions...
07:40:48 <gsheriff> hello
07:41:12 <dons> hi gsheriff
07:41:15 <dons> welcome!
07:41:28 <gsheriff> thanks
07:41:40 <dons> meet the lambdabot:
07:41:44 <gsheriff> I'm learning haskell, and I was thinking perhaps if I had a project to work on that would make it faster
07:41:46 <dons> > map (^2) [1..]
07:41:47 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
07:41:51 <ihope> > let ((###) ## (####)) ((#####):(######)) = (#####) ## (((###) ## (####)) (######)); (_ ## (###)) [] = (###) in ((+) ## 0) [1,2,3]
07:41:52 <lambdabot>    Occurs check: cannot construct the infinite type: t = [a] -> t
07:41:53 <lambdabot>    Exp...
07:41:55 <ihope> Oi.
07:42:03 <gsheriff> does anyone have any recommendations?
07:42:03 <dons> gsheriff, ah ok. what kind of things do you want to hack on?
07:42:07 <Botje> gsheriff: do as i'm doing: solve some of the problems on the ACM problem set
07:42:14 <gsheriff> anything simple really
07:42:20 <gsheriff> but not too simple - challenging as well
07:42:20 <Botje> http://acm.uva.es/problemset/
07:42:22 <lambdabot> Title: online-judge.uva.es - PROBLEM SET ARCHIVE
07:42:30 <dons> the rubyquiz problems are popular at the moment.
07:42:30 <Botje> there's some nice problems there
07:42:40 <gsheriff> ok
07:42:44 <gsheriff> thanks to you both
07:42:55 <gsheriff> checking them out
07:42:58 * SamB wonders why GHC would bother having "argument patterns" including zero-byte arguments...
07:42:59 <dons> here, http://haskell.org/haskellwiki/Haskell_Quiz
07:43:00 <lambdabot> Title: Haskell Quiz - HaskellWiki
07:43:33 <dolio> cpriester: Well, you could float them out into a let.
07:43:33 <gsheriff> ok dons - is that rubyquiz for haskell?
07:44:03 <dolio> cpriester: let f1 = fibsMemo ! (d-1) ; f2 = fibsMemo ! d in ...
07:44:26 <ezraburgh> @pl (\x -> [x])
07:44:26 <lambdabot> return
07:44:32 <dons> the rubyquiz is just a series of fun problems. the answers at the above link are in haskell
07:44:36 <dons> also, check out yaht:
07:44:38 <dons> ?where yaht
07:44:38 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
07:44:43 <dons> you could do the exercises in that.
07:45:02 <gsheriff> yeah I'm reading that
07:45:03 <mauke> http://www.spoj.pl/
07:45:04 <dolio> cpriester: You probably don't need so many "`mod` m", either, since (a mod m) + (b mod m) mod m = (a + b) mod m and so on.
07:45:07 <lambdabot> Title: Sphere Online Judge (SPOJ)
07:45:12 <gsheriff> but IIRC it doesn't have exercises?
07:45:20 <dons> finally, if you're looking for some open source to hack on, something here might be good, http://haskell.org/haskellwiki/Libraries_and_tools
07:45:23 <lambdabot> Title: Libraries and tools - HaskellWiki, http://tinyurl.com/j6sf3
07:46:07 <gsheriff> ok
07:46:28 <dons> should be able to find just about anything you need from http://haskell.org :)
07:46:30 <lambdabot> Title: Haskell - HaskellWiki
07:46:55 <gsheriff> yeah - already found it very useful
07:47:09 <dolio> dons: Are we waiting until the rubyquiz deadline is up on new quizzes, or no?
07:47:20 <int-e> haha. I still know my uva ID, Last submission: Fri Aug 06, 1999
07:47:23 <dons> nope :) not that i know of
07:47:32 <dolio> All right, then.
07:47:50 <dons> since we're sharing solutions, its more about learning and sharing haskell
07:48:01 <dons> and learning techniques from each other
07:48:14 <dons> dolio: thanks for putting up solns btw.
07:48:19 <dons> seems to have caught on quite nicely
07:48:43 <gsheriff> it looks very nice
07:49:38 <dolio> No problem. They were enjoyable.
07:50:13 <dons> it'd be interesting to do an analysis of the ruby verus haskell solutions at some point
07:50:18 <dons> by someone familiar with both
07:56:10 <uip> where can i find the solutions?
08:00:33 <gsheriff> uip: the ruby ones?
08:00:42 <gsheriff> they're at rubyquiz.com
08:02:13 <dolio> The haskell solutions are linked to on the problem pages on the haskell wiki.
08:13:38 <cpriester> dolio: Sure that Arrays have constant access time? it seems, that it was log n or something like that..
08:15:55 <dons> they're O(1).. lists are O(n)
08:16:09 <dons> otherwise, what would be the point? :)
08:16:22 <dons> and maps fit in between.
08:19:55 <cpriester> Hm. the program is still too slow..
08:20:49 <cpriester> the equivalent C Program runs 0.02 seconds, and that haskell Program more that 2 Seconds...
08:22:37 <dons> are you using unboxed arrays?
08:22:45 <dons> sounds like an algorithm problem though. or a space leak.
08:22:58 <dons> profile first. then you'll know what's going on
08:23:07 <dons> ghc -O -prof -auto-all Foo.hs
08:23:16 <dons> ./a.out +RTS -p
08:23:23 <dons> will dump the profiling stats into a.out.prof
08:23:32 <dons> ?wiki Performance
08:23:32 <lambdabot> http://www.haskell.org/haskellwiki/Performance
08:23:36 <dons> has the full story
08:24:03 <bdbit> @karma dons
08:24:04 <lambdabot> dons has a karma of 77
08:24:17 <cpriester> The Algorithm is correct, if it wasnt, it wouldnt terminate.
08:24:19 <bdbit> how do I add one? :D
08:24:35 <bdbit> @karma +1 dons
08:24:35 <lambdabot> +1 has a karma of 0
08:24:40 <bdbit> lol
08:24:53 <dons> cpriester: ok,could be a space leak. anyway, profile, and you'll know for sure
08:25:06 <dons> bdbit: the syntax is either: nick++ or @karma+ nick
08:25:10 <dons> ?help karma
08:25:10 <lambdabot> karma <nick>. Return a person's karma value
08:25:22 <bdbit> dons++
08:25:30 <bdbit> @karma+ dons
08:25:30 <lambdabot> dons's karma raised to 79.
08:25:33 <bdbit> oops.
08:25:40 <bdbit> that were two I guess.. but who cares
08:26:05 <cpriester> a.out.prof is empty...
08:26:29 <dons> does your program terminate abnormally?
08:26:37 <cpriester> No.
08:26:44 <dons> and you compiled with: -auto-all ?
08:26:59 <cpriester> yes
08:27:30 <dons> the binary is called a.out?
08:27:34 <cpriester> yes..
08:27:50 <cpriester> should i paste the source again?
08:27:58 <cpriester> i modiefied a fews things..
08:27:59 <dons> oh, its short is it? please do.
08:28:20 <dons> the profiling guide is here, http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
08:28:23 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
08:28:56 <cpriester> http://paste.lisp.org/display/28865
08:29:39 <dons> looking...
08:29:57 <cpriester> I think, that array must be fillen only once, now... Is that correct?
08:30:23 <cpriester> fillen=filled...
08:32:38 <araujo> There exist some tool that allows me to use the parsed expression generated by a happy file?
08:32:56 <dons> this is unusual haskell code, btw. still trawing through it
08:33:38 <dons> cpriester: so you know how to write a lazy fib using lists?
08:33:58 <ibid> araujo: what do you
08:34:00 <ibid> mean?
08:34:05 <cpriester> Not really...
08:34:43 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
08:34:50 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:35:04 <araujo> ibid, oh, well, you need the data structure generated by the happy parser?
08:35:08 <araujo> argh
08:35:13 <araujo> Do you know* ...
08:35:29 <cpriester> That list would be too long, for n=1.000.000.000, wouldn't it?
08:35:49 <ibid> araujo: do you mean, "how do i get access to a parse tree from a happy parser?"?
08:36:09 <dons> cpriester: depends on how you access it
08:36:19 <dons> cpriester: are you translating a C program into haskell?
08:36:24 <dons> hence the arrays and lots of IO?
08:36:59 <Cale> new code?
08:37:10 <cpriester> I tried in haskell first. I could not memoize the results, so i did in in C.
08:37:21 <araujo> ibid, er ... you know that happy parse a expression right?, and that this generates a kind of parser data structure (if the parsing was Ok).
08:37:37 <ibid> araujo: i know what happy does, and that's not what it does
08:37:39 <Tom__> hi, is there a way to append an element on a list (beside 'concat')?
08:37:44 <ibid> araujo: hence my confusion
08:37:46 <cpriester> Cale: http://paste.lisp.org/display/28865
08:37:48 <dons> Cale: can you help cpriester with http://paste.lisp.org/display/28865 ?
08:37:49 <araujo> ibid, i want to know if there exist some tools/libs to work over this data structure
08:37:58 <dons> its a bit late here for me to debug that code
08:38:18 <dons> ?localtime dons
08:38:20 <ibid> araujo: happy does not generate a data structure (unless you mean the LR automaton?)
08:38:22 <lambdabot> Local time for dons is Sun Oct 29 01:37:57 2006
08:38:26 <araujo> ibid, ok, i am not sure if i am explaining myself clear enough ....
08:38:33 <araujo> ibid, argh, yeah that one
08:38:46 <Cale> okay, some easy refactorings first
08:38:55 <ibid> araujo: ah. no, i don't know of any tools for that
08:38:56 <dons> night all. cpriester, I'd imagine you can fill an Array lazily with your fib fairly easy. depends on what you're goal is.
08:38:57 <Cale> let's pull fibs up to the top level
08:39:15 <cpriester> The fibs depend on m
08:39:24 <Cale> because stuffing everything into main like that just makes things hard to test and work with.
08:39:30 <dons> Cale++
08:39:32 <Cale> that's fine
08:39:32 <araujo> ibid, ok , and how do you work on it?
08:39:43 <cpriester> And that array should be computed only once...
08:39:55 <ibid> araujo: do you mean how do i use it to parse stuff?
08:40:03 <Cale> right. Now, what is this really computing?
08:40:04 <araujo> ibid, yes
08:40:15 <Cale> btw, x^2 is easier to read than sqr x :)
08:40:29 <ibid> araujo: happy generates a haskell module. run that through ghc or whatever, and call the parser function
08:40:37 <Cale> that is a lot of parens
08:40:43 <cpriester> Ah. I already wondered about a missing sqr-Function :)
08:41:11 * ibid would find sqr for square very confusing :)
08:41:38 <psykotic> how about rewriting it using pure recursion (none of that fmem stuff) and adding memoization
08:41:45 <araujo> ibid, ok , now i am confused , that's precisely what i am doing now :-}
08:42:10 <araujo> ibid, my question is actually, how do you use the return value of that parser function?
08:42:28 <cpriester> The problem is, to save fmem for all following function calls..
08:42:37 <araujo> you go defining your own functions,or use some tools?
08:42:52 <cpriester> When i add memoisation later, it is not reused in further calls of the function.
08:43:02 <ibid> araujo: does your grammar contain actions?
08:43:21 <ibid> araujo: (or rather, synthetic attributes)
08:43:26 <Cale> so basically, what this is doing is reading a number and then reading that many lines and applying the function fibs to each?
08:43:46 <araujo> ibid, now, it doesn't. (not yet at least)
08:44:04 <cpriester> Yes.
08:44:08 <Cale> If fmem is at the top level, it won't be dropped so long as it could potentially be referred to
08:44:10 <ibid> araujo: ok, then you don't get a data structure
08:44:30 <ibid> araujo: without actions, all the parser function does is tell you if the input parses or not
08:44:34 <cpriester> But fmem at top has not m as argument..
08:44:46 <ibid> araujo: you need to build the data structure that you want to use in the semantic actions
08:45:19 <araujo> ibid, Right now, my parser functions returns an abstract data type.
08:45:34 <araujo> If the parsing was ok.
08:46:12 <ibid> araujo: can you put the happy file somewhere on the net for me to look at?
08:46:18 <satan> > map (\x -> x / (2^ (x-1))) [1..10]
08:46:19 <lambdabot>  Add a type signature
08:46:34 <araujo> ibid, ok, let me clean it :-)
08:46:36 <satan> hmm
08:47:00 <cpriester> How can i get that fmem at top level to use one m as modulo?
08:47:22 <cpriester> and for all function calls of fibs?
08:52:38 <Cale> hmm
08:54:13 <cpriester> that is only possible, if both functions are locales of main.
08:54:37 <araujo> ibid, http://rafb.net/paste/results/Xjrwve12.html
08:54:46 <araujo> ibid, there you get it, nothing complex
08:54:58 <Cale> We should probably still rip out the main part of what it's doing, and only memoize it inside main
08:55:21 <araujo> ibid, my question is, if there exist some tools/libs for using the data type generated by the parser function.
08:55:28 <Cale> We could also use some sort of data to keep track of the values for different m
08:56:08 <cpriester> There is only one m...
08:57:01 <Cale> [r,m] = map read (words s)
08:57:43 <ibid> araujo: so you *do* have semantic actions. why did you say you didn't have them?
08:58:33 <ibid> araujo: i usually just write my own, it's not that hard. there are some genericity tools that may be applicable, but i haven't been interested in them
08:58:52 <araujo> ibid, hah ok , sorry :-}
08:59:05 <araujo> ibid, i see .. i have also thought to go with my own
08:59:56 <ibid> araujo: (semantic actions are the { Equal $1 $3 } things :)
09:01:26 <araujo> ibid, i see :-)
09:02:23 <ibid> araujo: a misnomer in haskell, but carries over from yacc and friends :)
09:02:27 <cpriester> Sorry, i have to go, now... Thanks a lot for your help!
09:02:57 <Cale> cpriester: I'll take a good look at this and clean it up for you :)
09:03:42 <araujo> ibid, i see
09:06:31 <x3m> @seen foxy
09:06:32 <lambdabot> foxy is in #haskell. I don't know when foxy last spoke.
09:07:03 <Tom__> ?localtime Tom__
09:07:06 <lambdabot> Local time for Tom__ is Samstag, 28. Oktober 2006 18:06:43
09:08:03 <Pete_I> Oktober?
09:08:21 <Pete_I> who spells it "oktober"?
09:08:34 <mauke> Germans
09:08:44 <Pete_I> i see
09:08:59 <Pete_I> pronounced the same?\
09:09:27 <Cale> http://paste.lisp.org/display/28865 -- if anyone was interested in cpriester's problem, this is a slightly cleaned up version
09:09:42 <uip> dolio: can't seem to find it
09:10:58 <psykotic> cale: interesting, i had that Y-combinator-style self-injection trick in mind too.
09:11:13 <Cale> @tell cpriester http://paste.lisp.org/display/28865#1
09:11:14 <lambdabot> Consider it noted.
09:11:18 <psykotic> it's often useful when you want to add some extra stuff on the side in addition to the usual recursion.
09:11:24 <Cale> yeah
09:11:34 <Philippa> ibid: in Haskell I tend to think of them as semantic values
09:12:03 <Cale> psykotic: Without it here, the configuration parameter m becomes a bit of a pain.
09:12:16 <psykotic> btw this is one case where open recursion in the OO style is often useful :)
09:12:26 <psykotic> the delegation pattern fits it very well
09:12:47 <psykotic> also useful for modularly extensible interpreters and such
09:14:12 <mauke> Pete_I: http://www.leo.org/dict/aussprache/o/der_Oktober.wav
09:14:15 <lambdabot> http://tinyurl.com/y5cn2l
09:19:18 <ibid> Philippa: i should call them semantic attributes :)
09:22:54 <Pete_I> mauke, thanks
09:27:12 * araujo likes Philippa's term
09:35:45 <Animosity> can anyone direct me to some tutorials/documentation on implementing 2-3-4 trees in haskell or any other kind of tree that goes beyong the binary search one?
09:37:52 <SamB> Animosity: you mean like Okasaki's "purely functional datastructures"?
09:38:49 <SamB> it isn't specifically a Haskell book, but the datastructures therein work well enough
09:39:47 <Animosity> oh im more interested in the operations performed on a tree in haskell, like node splitting, relinking children with other nodes, etc.
09:39:56 <SamB> actually there is a postscript file as well as a book, and I don't think they have quite the same content
09:40:13 <SamB> well, he covers a lot of datastructures
09:40:32 <Animosity> i see
09:40:39 <SamB> as well as design techniques
09:40:58 <SamB> and accounting methods
09:41:10 <SamB> (to figure out how much things cost)
09:41:13 <Animosity> overkill
09:41:36 <SamB> not if you want to calculate amortized big-Os...
09:41:50 <Animosity> im working on an assignment which requires me to implement a 2-3-4 tree, strings used as keys
09:42:03 <SamB> well, do you know what a 2-3-4 tree is?
09:42:13 <Animosity> yes
09:42:27 <SamB> well, the first thing to do is the datatype
09:43:14 <SamB> i.e. data = Two ... | Three ... | Four ... deriving (Show)
09:43:19 <Animosity> tree a = node [a] tree a tree a tree a tree a
09:43:19 <SamB> er.
09:43:36 <SamB> add a type constructor on the left...
09:43:47 <SamB> ah. In Haskell, that would be
09:44:22 <SamB> er wait.
09:44:26 <SamB> what is the "node" part?
09:44:41 <Animosity> Node declares the....node
09:44:47 <Animosity> or the format of the node
09:44:47 <SamB> is that a data constructor?
09:44:47 <Animosity> no?
09:44:52 <SamB> format?
09:44:52 <Animosity> yes
09:44:53 <Animosity> Node
09:53:58 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
09:53:58 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
09:53:58 --- names: list (clog pierre- obseleron _roconnor ChilliX Animosity beelsebob waern tibbe mejja enacted Tom__ iblechbot Philippa psi lisppaste2 Stormogulen Una^ bringert kowey Itkovian ezraburgh mauke hyraxfourtwo maskd bdbit Nioate binary42 mrevelle mr_ank kpreid Smokey` mornfall_ cptchaos BCoppens Blum cwenner Sweetsha1k twanvl Patterner dolio foxy arjanb sris nealc_ bengtsson Bobstopper jak slipstream astrolabe ihope nothingmuch der_eq anonfunc therp)
09:53:58 --- names: list (psykotic Jaak uebayasi noradio velco ValarQ Foxyloxy converter Averell gour Zr40_ uip rblackwe shawn triple_ dino- cmeme dgoldsmith rafl Twigathy Syzygy- DRMacIver Baughn ThreeQ TSC jmob benben _matthew_ Cale sjanssen svens Heffalump Pupeno Akheron l_a_m dvekravy glguy Captain_Fourier noclouds tessier_ eno-away khaladan thetallguy mathewm arjanoosting matthew-_ Igloo Daveman meddle Trixsey araujo satan gaal profmakx Xgc woggle xinming resiak)
09:53:58 --- names: list (mathrick exnor dblog toyz JKnecht x3m tessier cods wagle lovecoder nnunley mGem szabi_ Lunar^ qz earthy hyrax42 Tigge cpatrick _frederik_ freshhawk sigfpe_ sylvan dcoutts TwigEther tmoertel_away dcoutts_ Lor giksos kosmikus greenrd lOkadin scw lambdabot orbitz ohub noj void moconnor nick8325 explicitjelly Narcisse osfameron gdsx lucca zamez Pete_I qwr fnordus atsampson pandres xerox arguile_ edwinb johs mattam wilx Dylan scsibug shrimpx)
09:53:58 --- names: list (xeXergy kaol Khisanth dany2k unclear mlh emu pejo rycee mux SimonRC kalven psnl dons carp ozone arcatan thebug bdash bran_ aleator magagr musasabi Lemmih lispy ski wolverian audreyt norpan Spark gds vegai JohnMeacham ulfdoz_ epitron kpk Codex_ kolmodin petekaz cjay Maddas kzm liyang ksandstr jdev drbean boliver_ newsham pingu jgrimes Wallbraker SamB df_ sieni integral ibid saccade Botje Eidolos SamB_XP)
09:55:48 <SamB> @scheck fix (const x) == (x::Int)
09:55:50 <lambdabot>  Not in scope: `x'
09:55:55 <SamB> @scheck \x -> fix (const x) == (x::Int)
09:55:57 <lambdabot>  Completed 10 test(s) without failure.
09:58:03 <SamB> @pl fix . const
09:58:04 <lambdabot> id
09:58:07 <SamB> okay...
09:58:28 <mauke> @. pl pl Pmany1 Pdigit >>= let f num = let n = read num in return (Number n) in f
09:58:28 <lambdabot> (Number . fix . const . read) `fmap` Pmany1 Pdigit
09:58:42 <mauke> @pl a . fix . const . b
09:58:43 <lambdabot> a . fix . const . b
09:58:57 <mauke> @pl a . id . b
09:58:58 <lambdabot> a . b
10:08:33 <SamB> hmm. too bad pl's rewrite rules are unshowable :-(
10:10:54 <cdfh> length [1,2,3,4] / 2
10:11:01 <cdfh> does anyone know why that doesn't work?
10:11:13 <mauke> because / wants a floating point number and length returns an int
10:11:18 <SamB> hmm. it only generates two rules from that...
10:11:55 <SamB> (from its fix (const f) --> f rule)
10:12:03 <mauke> > fromIntegral (length [1,2,3,4]) / 2
10:12:05 <lambdabot>  2.0
10:12:19 <cdfh> mauke: ace - thanks :-)
10:12:25 <mauke> > length [1,2,3] `div` 2
10:12:27 <lambdabot>  1
10:12:49 <mauke> > length [1,2,3] % 2
10:12:50 <lambdabot>  3%2
10:13:25 <Cale> @type length [1,2,3] % 2
10:13:26 <lambdabot> Ratio Int
10:13:52 <cdfh> mauke: why does 4/2 work, when length [1,3,4,5] /2 does not?
10:14:11 <Cale> cdfh: because 4 could be any sort of number
10:14:24 <Cale> whereas length is strictly an Int
10:14:29 <mauke> @type (4, length "")
10:14:30 <Cale> which I agree is kind of silly
10:14:31 <lambdabot> forall a. (Num a) => (a, Int)
10:14:50 <Cale> they put a general version in Data.List called genericLength
10:14:59 <Cale> @type genericLength
10:15:01 <lambdabot> forall i b. (Num i) => [b] -> i
10:15:25 <Cale> This is what happens when you have people who hate polymorphism on the Haskell committee :)
10:15:33 <cdfh> lol :-)
10:15:35 <mauke> who?
10:16:07 * cdfh > homework :-)
10:16:11 <cdfh> thanks Cale, mauke
10:17:10 <Heffalump> some parts of Haskell do feel like an uncomfortable compromise between usability and teachability
10:17:47 <Cale> Hehe, I don't remember exactly. I remember reading through the Haskell 98 committee mailing list archive and seeing a group of people who were always pushing for monomorphism
10:18:01 <Cale> and basically killing off lots of good features of Haskell 1.4
12:40:50 --- topic: '["http://www.haskell.org/haskellwiki/HaWikiMigration - act soon or the data will be deleted!", "Join us as we move forward toward the Age of the Lambda", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
12:40:50 --- topic: set by dons on [Tue Sep 26 08:23:47 2006]
12:40:50 --- names: list (clog dfeuer qz edwardk monochrom cprieste1 mauke_ palomer nicodaemos dudemeister cjeris lhz Itkovian GeoBesh jmmv Zr40 jajs systems monobot jcreigh chessguy cinema cdfh bdbit_ AvengerX erider obseleron roconnor ChilliX Animosity beelsebob waern mejja Philippa psi lisppaste2 Stormogulen Una^ bringert kowey ezraburgh hyraxfourtwo maskd Nioate binary42 mrevelle mr_ank Smokey` mornfall_ cptchaos BCoppens Blum cwenner Sweetsha1k twanvl Patterner)
12:40:50 --- names: list (dolio foxy arjanb sris nealc_ bengtsson Bobstopper jak slipstream astrolabe ihope nothingmuch der_eq therp psykotic Jaak noradio velco ValarQ Foxyloxy converter Averell gour uip rblackwe shawn triple_ dino- cmeme dgoldsmith rafl Twigathy Syzygy- DRMacIver Baughn ThreeQ TSC jmob benben _matthew_ Cale sjanssen svens Heffalump Pupeno Akheron l_a_m dvekravy Captain_Fourier noclouds eno-away khaladan thetallguy mathewm arjanoosting matthew-_)
12:40:50 --- names: list (Igloo Daveman meddle Trixsey araujo satan gaal profmakx Xgc woggle xinming resiak mathrick exnor dblog toyz JKnecht x3m tessier cods wagle lovecoder nnunley mGem szabi_ Lunar^ earthy hyrax42 Tigge cpatrick _frederik_ freshhawk sigfpe_ dcoutts TwigEther tmoertel_away dcoutts_ Lor giksos kosmikus greenrd lOkadin scw lambdabot SamB_XP Eidolos Botje saccade ibid integral sieni df_ SamB Wallbraker jgrimes pingu newsham boliver_ drbean jdev ksandstr)
12:40:50 --- names: list (liyang kzm Maddas cjay petekaz kolmodin Codex_ kpk epitron ulfdoz_ JohnMeacham vegai gds Spark norpan audreyt wolverian ski lispy Lemmih musasabi magagr aleator bran_ bdash thebug arcatan ozone carp dons psnl kalven SimonRC mux rycee pejo emu mlh unclear dany2k Khisanth kaol xeXergy shrimpx scsibug Dylan wilx mattam johs edwinb arguile_ xerox atsampson fnordus qwr Pete_I zamez lucca gdsx osfameron Narcisse explicitjelly nick8325 moconnor)
12:40:50 --- names: list (void noj ohub orbitz)
12:40:55 <edwardk> psykotic: the existence of linear types force me to disallow fst/snd style projection from the dependent tuples, which turns out to be something i need in order to make the CPSd pure type system work anyways. so things nicely line up.
12:41:45 * bringert grabs a bottle of vodka and leaves
12:41:51 <edwardk> though i think i've drifted pretty far afield.
12:43:26 * bringert comes back for some coke
12:43:28 <bringert> and directions
12:43:49 <edwardk> psykotic: in any event i just really like how simple a core calculus is when you get rid of functions. =)
12:45:54 <ulfdoz_> blackleg: moment!
12:46:40 <edwardk> lispy: ah no real type checking on the assembly stuff?
12:47:14 <lispy> edwardk: nope
12:47:16 <SamB> how good is mediawiki with moving entries?
12:47:28 <lispy> edwardk: didn't i say it's very simple? ;)
12:48:05 <edwardk> something to be said for that =)
12:49:37 <systems> its quiet
12:50:08 <edwardk> lispy: in my case i really wanted to be able to manipulate the opcodes once i generated a preliminary assembly
12:50:27 <lispy> edwardk: i'll look into adding that when i change from simple strings representing instructions to some sort of pseudo assembly type
12:50:33 <edwardk> *nods*
12:51:01 <lispy> it would be pretty hard to optimize the output of the CodeGen monad at this point
12:51:06 <SamB> heh
12:51:07 <edwardk> yeah
12:51:15 <lispy> but it would be nice to have it remove redundant movs and sunch
12:51:52 <edwardk> i admit i'm almost sold on just generating gas syntax at this point though. lot easier than generating the opcodes directly like i am
12:52:16 <integral> excellent, my memoised ackermann is slower than my non-memoised one =)
12:52:52 <edwardk> integral: heh
12:53:39 <edwardk> i also being seduced by the notion of not dealing with the army of type classes i have to encode what will ultimately be outputted. =/
12:53:51 <lispy> edwardk: i think it would be cool to cut gas out of the loop, but for now it makes it so simple
12:53:54 <edwardk> but then i'll need to write an assembly lint pass that type checks anyways
12:53:56 <edwardk> yeah
12:54:43 <lispy> when/if this language gets an interpreter, having to call gas will seem odd
12:54:53 <edwardk> hah yeah
12:54:58 <SamB> GOO odd?
12:54:59 <lispy> (I have no plans to implement the interpreter in haskell)
12:55:08 <mauke> oh wow, why is *!*=root@* silenced here?
12:55:16 <SamB> heh
12:55:21 <lispy> mauke: trolls
12:55:32 <mauke> trolls irc as root?!
12:55:40 <lispy> i don't remember who, but someone was using that mask and trolling here
12:55:48 <mauke> nice
12:55:51 <lispy> the maths debate guy
12:56:01 <systems> xahlee was here?
12:56:09 <systems> :P
12:58:33 <integral> wow, my memoise module works the very first time
13:01:36 <systems> sorry, i want to ask a silly thing, the little i read about functional programming is that the sequence of event dont CHANGE the result, what about those case where the sequence is obligatory. How is is represented or dealt with?
13:01:54 <integral> We use cute fluffy objects called M.
13:01:56 <systems> i studies ocaml, and i know they have a sequence operator
13:02:08 <systems> the ; i think
13:02:13 <integral> Basically with an M, you can take a pure value and turn it into a M of that value.
13:02:18 <systems> it return the value of the last expression
13:02:25 <integral> Or you can take a function that operates on a value in an M and returns a new M
13:02:38 <integral> The latter is the notion of sequence, since the first M is done before the second.
13:02:49 <integral> systems: with do notation haskell has ; too
13:02:51 <systems> i studied ocaml not studies , i stopped long while ago
13:04:00 <systems> a M of that value, this didnt make sense to me?
13:04:05 <systems> whats a M
13:04:19 <SamB> one popular M is IO
13:04:29 <SamB> though it is also well-hated
13:04:51 <systems> let imagine a wizard, which can to take the user into steps, to create a database for example, here we have a sequence of event. How would this be represented for example
13:05:36 <systems> in procedular languages, its a no brainer
13:05:54 <edwardk> so we've shortened the word to avoid scaring off newbies?
13:06:35 <Philippa> which is good, because procedural languages have no brain when it comes to such things
13:06:50 <Philippa> that is, they treat sequencing as magic...
13:07:49 <Philippa> systems: there're ways to write code where there's only one correct evaluation sequence
13:08:06 <systems> hmmm, i think in this particular case, nested functions will do, the inner most function first, because if the outer functions tries to work, i will prompt the inner one, and so on
13:08:08 <edwardk> system: in haskell you would perform a sequence of operations in a monad of some sort, usually IO, then you would so main = do step1; step2; step3
13:08:21 <systems> s/i/it
13:08:45 <edwardk> system: the steps that don't have a relative order can be done outside of that monad and will be called as needed.
13:09:08 <systems> i guess what confused me, is that the article about functional programming suggest this feature lead to parallilism
13:09:34 <edwardk> systems: it does, because if we don't specify the relative order of most things, then they can be done in any order and across any number of cores.
13:09:54 <systems> but her the order is to be forced by the nesting
13:09:55 <SamB> ... have we seen a practical example of this yet?
13:10:03 <edwardk> imperative languages are 'overly-serialized'
13:10:11 <systems> s/her/here
13:10:16 <systems> damn typos
13:10:17 <edwardk> here? we don't force order by nesting. thats ocaml/ml =)
13:10:32 <systems> in my head i pronounce them right, but what i type is something else
13:10:58 <systems> if nesting wont force order, that the user might be asked question 3 before 1
13:11:24 <systems> which would be wrong, and impossible this question 3, prompt question 2, which prompt question 1
13:12:15 <Philippa> SamB: I think there're reasonably largely parallel implementations of Haskell that just force lots of thunks at once and hope they're not directly dependant on each other
13:12:19 <systems> i hope at least
13:12:20 <Philippa> SMP only, that one
13:12:40 <Philippa> systems: suppose you have a type World
13:12:45 <Philippa> and I give you this: world :: World
13:13:03 <mauke> .oO( the world is not enough )
13:13:03 <Philippa> and this: runtime :: Time -> World -> World
13:13:17 <Philippa> and this: getString :: World -> (String, World)
13:13:19 <edwardk> systems: take a step back for a second. in haskell we don't (usually) have a form of mutable state. so the idea of step 1 then step 2 then step 3, usually is read as take something, transform it with a function from one thing to another, returning a new value, then transform that returning a new value then transform that, and you have the answer from step 3. the answer to step 3 required the value returned by step 2, so it will have t
13:13:22 <Philippa> and a few other bits and pieces
13:13:44 <Philippa> mauke: I know, because there's an additional constraint to enforce
13:13:46 <lispy> http://thedailywtf.com/forums/thread/96390.aspx
13:13:49 <lambdabot> http://tinyurl.com/wvvgz
13:14:00 <Philippa> systems: you can see how, if I forced you to do all your interactions with a World, you'd get an order?
13:14:13 <SamB> edwardk: except of course maybe you start on step 3 first, and then only start on step 2 when you need part of its results...
13:14:15 <SamB> etc...
13:14:16 <edwardk> in imperative languages i might have a single object and it would mutate its in internal state when told to do each step in turn. in a functional language we usually go the other way and have the step take one object and return another, then the process of needing an object returned by another step forces the evaluation of the other step.
13:14:24 <edwardk> samb: sure.
13:14:28 <edwardk> samb: working my way there =)
13:15:25 <edwardk> the reason we like to do things in this manner is then we can avoid doing anything that isn't required, statements in general in haskell can't have side effects, so if i don't need the answer i obtain from calling a function there is no need for me to call the function.
13:16:51 <edwardk> so the step 1, step 2, step 3 model doesn't benefit from this, but if you have a more complicated network of dependencies, like a makefile, then you can have the dependencies propagate backwards to just the things it needs, rather than performing all of the steps in the hope they will be needed like you do in a call-by-value or imperative setting
13:17:20 <SamB> also it saves us from having to debug things with mutable state
13:20:08 <systems> "then the process of needing an object returned by another step forces the evaluation of the other step." the key word is forces
13:20:29 <systems> what forces an evaluation in haskell
13:20:32 <monochrom> w00t!  Makefile as example of lazy evaluation!
13:20:46 <SamB> systems: well, typically a "case" expression
13:20:55 <edwardk> systems: yeah, until the answer is needed it doesn't get computed, the moment it is or even if we can show it'll be needed in the future, it is computed.
13:20:57 <uip> the best part is that we suffer horrible performance for simulations and other stateful programs :D
13:20:59 <edwardk> > 1 + 1
13:21:01 <systems> in procedural, its the order, when it time comes, its evaluated, its time is determined by an order
13:21:01 <lambdabot>  2
13:21:04 <SamB> or function patterns
13:21:06 <edwardk> i needed the answer, so it computed it
13:21:11 <Heffalump> systems: At the very beginning, evaluation of 'main' in the IO monad, or an expression in the REPL
13:21:12 <SamB> (which are essentially the same)
13:21:12 * monochrom bangs head against keyboard...  why have I never noticed that?!
13:21:17 <monochrom> sdjfksjf34858934uk dshifhsfh w98r834yr89p;hsdp9fhsf
13:21:39 <edwardk> > take 20 [1..]
13:21:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
13:21:44 <Heffalump> in other words, some external agency
13:21:56 <Heffalump> a Haskell implementation just propagates that demand
13:21:57 <edwardk> i never needed the answers for 21..infinity, so it didn't bother =)
13:22:57 <Maddas> >let x = 1/0 in 2
13:23:07 <Maddas> > let x = 1/0 in 2
13:23:08 <lambdabot>  2
13:23:20 <SamB> > 1/0
13:23:22 <lambdabot>  Infinity
13:23:31 * SamB is not impressed
13:23:32 <edwardk> we so need to fix lambdabot on that
13:23:53 <SamB> edwardk: on what?
13:24:13 <edwardk> oh, its not that one, its the log thing
13:24:16 <edwardk> > log -1
13:24:17 <lambdabot>  add an instance declaration for (Num (a -> a))
13:24:21 <edwardk> > log (-1)
13:24:23 <lambdabot>  -Infinity
13:24:26 <monochrom> lambdabot is right.
13:24:27 <SamB> heh
13:24:41 <SamB> try...
13:24:46 <SamB> > 1/0 :: Rational
13:24:48 <lambdabot>  Exception: Ratio.%: zero denominator
13:25:00 <Heffalump> > let 1 = 0 in 1+1
13:25:01 <lambdabot>  2
13:25:15 <edwardk> Prelude> log (-1)    ===> NaN
13:25:18 <SamB> ... ???
13:25:18 <Maddas> Isn't it 1/0 that should just be fixed to yield an error?
13:25:45 <SamB> let 1 = 0?
13:25:52 <Heffalump> well, why not
13:25:56 <SamB> > let 1 = 0 in 1
13:25:57 <lambdabot>  1
13:26:00 <Heffalump> lambdabot was clearly sensible enough to ignore me
13:26:02 <SamB> how is that legal?
13:26:14 <Maddas> > let (1+1) = 0 in 2
13:26:14 <lambdabot>  Parse error in pattern
13:26:18 <Maddas> :-(
13:26:20 <edwardk> samb: think pattern matching
13:26:27 <SamB> Maddas: it thinks that that is an n+k pattern
13:26:29 <Heffalump> > let (x:xs) = [] in 1
13:26:30 <lambdabot>  1
13:26:33 <Heffalump> it's legal for the same reason that is
13:26:40 <Maddas> SamB: Yup, I hoped it would just do something instead of noticing the error
13:26:47 * Igloo wonders why LB is doing that makes it differ from ghci
13:27:04 <Heffalump> Igloo: wdym?
13:27:09 <Heffalump> ghci should behave the same way too
13:27:11 <SamB> > let [] = "hello" in "bye"
13:27:13 <lambdabot>  "bye"
13:27:15 <SamB> okay...
13:27:19 <Igloo> Heffalump: In its answer for log (-1)
13:27:23 <SamB> this is freaking me out!
13:27:28 <Heffalump> Igloo: ah, ok
13:27:34 * SamB doesn't see why it allows zero-variable pattern bindings
13:27:34 <Heffalump> > let ~(x:xs) = [] in 1
13:27:36 <lambdabot>  1
13:27:38 <edwardk> Igloo: as i recall it gets it right if you pass log a complex number
13:27:42 <Igloo> Oh, it's compiling it, isn't it
13:27:46 <Heffalump> SamB: because it's more consistent than not
13:28:01 <Heffalump> why should 0 be a special case
13:28:07 <SamB> I don't think it should
13:28:26 <SamB> but why should *any* nullary constructor type thing work?
13:28:36 <Igloo> Nope, that still gives me NaN
13:28:48 <SamB> it might be CPU and OS dependant
13:28:48 <Heffalump> hi PaulAJ
13:29:09 <Igloo> Yeah, I was just wondering if it was BSD's libraries giving a different answer
13:29:11 <PaulAJ> Hi.  Havent been here recently.  Good to see you still there
13:29:16 <chessguy> man, i have never seen so many hex numbers in my life
13:29:45 <PaulAJ> I've been getting back to my Ranged Sets library.
13:29:48 <Heffalump> I'm not here often, it's rather too busy
13:29:49 <Heffalump> cool
13:30:02 <PaulAJ> Wondering if I could ask for advice.  I want to migrate to darcs
13:30:52 <PaulAJ> Whats the best way of making my repo visible?  The manual talks about just publishing it on HTTP, but I don't want to run a HTTP server from my home box
13:31:02 <SamB> why not?
13:31:32 <SamB> you would prefer to give the entire world SSH access to your machine?
13:31:40 <PaulAJ> Sometimes its not up, and even when it is, I don't want to worry about security too much.
13:32:00 <ohub> well, copy it to some other HTTP server
13:32:01 <SamB> oh, well, you can push it to some other machine which has an HTTP server..
13:32:07 <PaulAJ> SEc, gotta go away briefly'
13:32:31 <Igloo> We don't currently have a machine for hosting random repositories unfortunately, if that's what you're asking
13:33:10 <SamB> random repositories would actually be very boring...
13:33:32 <Heffalump> PaulAJ: I could host it
13:35:11 <Heffalump> or any web space you have with enough space could be used
13:41:50 <PaulAJ> I was wondering about a random repository.  I do have the project currently hosted on sourceforge, so I could just upload each new
13:42:13 <PaulAJ> version of te repo there.  But thats a bit BF&I approach. I ought to be able to just push the data.
13:42:56 <PaulAJ> I mean, push the deltas from the changes.
13:43:07 <lispy> PaulAJ: the darcs wiki has advice on using darcs with sf.net
13:43:24 <lispy> see darcs.net for the wiki
13:43:35 <PaulAJ> Ahh.  I had looked thru the FAQ, but not seen that.  I'll search a bit more carefully.  Tnx.
13:43:48 <PaulAJ> Going off line to make tea for the SO now.  Bye.
13:43:57 <uip> what do you guys think about a haskell version of http://www.nedbatchelder.com/text/madlibs.html
13:44:00 <lambdabot> Title: Ned Batchelder: Programming Madlibs, http://tinyurl.com/y7dmot
13:44:08 <monochrom> What does madlib do?
13:44:21 <uip> monochrom: read the page :)
13:45:41 <monochrom> It's very hard to communicate with kids these days.
13:45:58 <lispy> i blame the kids, they should know better
13:49:34 <lispy> and more importantly, they pickup language faster than adults
13:49:42 <lispy> so they need to come down to our level
13:50:15 <monochrom> I doubt that.  Apparently they have no English capability outside the HTML medium.
13:51:23 <monochrom> For example on IRC or real life, they only know how to recite URLs and say the word "read!"
13:51:47 <lispy> adults?
13:51:59 <monochrom> But then on their blogs they can elaborate how they brushed teeth that morning at length.
13:52:02 <monochrom> No, the kids.
13:52:17 <SamB> since when do you need HTML to write a blog entry?
13:52:22 <lispy> i'm not convinced, i think you're describing adults
13:52:34 <monochrom> I'm describing uip.
13:53:07 <monochrom> OK, correction.  The kids have no English capability outside the web browser.
13:53:22 <SamB> they should use chatzilla :-P
13:54:06 <lispy> i don't understand what that page is all about, but i blame that on my lack of motivation to read the whole thing
13:54:14 <lispy> the intro didn't explain it to me, and i'm lazy
13:54:50 <monochrom> Oh, you read that page and still got nothing?  Poor you.  But thank you for proving that it was not worthwhile.
13:54:56 <lispy> sounds like he's doing pair programming with his son
13:55:18 <lispy> which is a good idea
13:55:40 <lispy> monochrom: you sound a bit cross today :)
13:56:02 <monochrom> I don't belong to this world.
13:57:26 <systems> :> me neither
13:57:41 <monochrom> At least I'm easier today than the other day when I said things against the idea of wikis.
13:58:02 <lispy> what don't you like about them?  or is there a rant i sohuld read?
13:58:13 <lispy> i like them and so i'd like to know the arguments against
13:58:19 <systems> arent there any free books on haskell, only the tutorials?
13:58:20 <SamB> he was complaining about the crap search engines they tend to have
13:58:36 <monochrom> Haha.  I said that the whole idea of wiki is that you use someone's homebrew broken search engine.
13:58:45 <SamB> I *told* him you are supposed to use Google, but he no listen.
13:59:01 <lispy> monochrom: oh yeah, i *hate* wiki search engines
13:59:03 <monochrom> I listened.  That is why I do not complain today.  :)
13:59:11 <SamB> heh
13:59:30 <lispy> the mediawiki search engine is one of the worst i've seen
13:59:41 <SamB> at least they have the option to use google instead
13:59:41 <lispy> sometimes you know a word is used in the title or on the page and it still can't find it
14:00:36 <palomer> that's nuts!
14:00:36 <monochrom> It violates monotonicity.  "brief" turns up nothing.  "brief introduction" turns up the brief introduction.  It's beyond broken; it's a prank.
14:00:51 <palomer> I need a hobby
14:01:05 <monochrom> listen to classical music, palomer
14:01:15 <chessguy> ugh. i just calculated 512 64-bit hex numbers
14:01:15 <palomer> yeah, I've started doing that
14:01:20 <mauke> recompile kde + openoffice
14:01:21 <chessguy> what a great way to spend a saturday
14:01:29 <SamB> by HAND?
14:01:34 <chessguy> sort of
14:02:14 <monochrom> Poor you.  palomer needs a hobby.  Perhaps you can delegate some calculations to him.
14:02:17 <chessguy> it was more figuring out patterns and applying them
14:02:21 <chessguy> lol
14:02:33 <chessguy> the worst is over (i hope)
14:03:11 <chessguy> though i may have a few more sets of 64 numbers to calculate
14:04:50 <chessguy> if i do let x = blahblahblah in moreblahblah, does blahblahblah just get substituted in for x in the moreblahblah?
14:05:03 <Heffalump> semantically, yes
14:05:12 <monochrom> yes
14:05:20 <Heffalump> operationally, not usually
14:05:22 <chessguy> i meant implementation-wise
14:05:38 <Heffalump> it'll get evaluated the first time x is evaluated
14:05:45 <Heffalump> and then the same result produced the next times
14:05:48 <chessguy> or does blahblahblah get evaluated and then substituted in all those places
14:06:44 <monochrom> Let me put it this way.  let x = f y in x+x  is twice as fast as f y + f y
14:07:08 <monochrom> They have the same value.
14:07:15 <chessguy> ok
14:07:53 <monochrom> A programmer is rightful to know what result and how fast.  But not too rightful to know what happens under the hood.
14:08:20 <chessguy> fair enough
14:11:02 <monochrom> The above is speaking of a programmer as a professional.
14:11:18 <monochrom> As an intellectual person, of course you should know everything.
14:14:11 <chessguy> what about nesting let blocks? can i do let foo = blah in let foo' = blah' in ....
14:14:34 <monochrom> Yes you can do that.  Not popular though.
14:14:43 <chessguy> what would be better?
14:15:20 <monochrom> Most people write "let { foo=blah; foo'=blah' } in .."  i.e., flatten it out.  But do whatever you feel elegant.
14:15:44 <chessguy> well, i need to evaluate foo in the definition of foo'
14:15:45 <chessguy> sorry
14:16:18 <monochrom> That's still alright!  let { x = 10; y = x+10 } in x+y
14:16:31 <chessguy> heh
14:16:35 <chessguy> haskell's way too easy
14:17:08 <monochrom> > let { ha = True:he; he = False:ha } in take 10 ha
14:17:10 <lambdabot>  [True,False,True,False,True,False,True,False,True,False]
14:17:18 <monochrom> Now grok that!
14:17:35 <chessguy> cute
14:23:39 <SamB> hahe? heha? oh me! oh mi!
14:26:19 <kaol> laziness in action?
14:27:04 <mauke> > let action = laziness; laziness = True : laziness in action
14:27:05 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
14:28:25 <monochrom> Some laziness. I was demonstrating mutual reference.
14:28:40 <SamB> that isn't very lazy...
14:28:42 <SamB> really.
14:29:05 <monochrom> OK, delete "Some".
14:29:05 <SamB> after the first [True,True the list was certainly fully evaluated
14:30:32 <norpan> > let action = laziness x; laziness x = True : laziness x in action
14:30:33 <lambdabot>  Not in scope: `x'
14:30:36 <norpan> bah
14:30:42 <norpan> > let action = laziness 1; laziness x = True : laziness x in action
14:30:43 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
14:39:30 <chessguy> ugh.
14:39:36 <chessguy> mis-matched types all over the place
14:44:34 <chessguy>  Couldn't match the rigid variable `a' against `Integer'
14:44:35 <chessguy>    `a' is bound by the type signature for `bishopAttacks'
14:44:35 <chessguy>    Expected type: a
14:44:35 <chessguy>    Inferred type: Integer
14:44:35 <chessguy>  In the application `occupied board'
14:44:35 <chessguy>  In the second argument of `(.&.)', namely `(occupied board)'
14:44:42 <AvengerX> ouch
14:44:56 <chessguy> does this mean that occupied board was type a when it was expected to be type Integer? or board?
14:45:22 <AvengerX> maybe you're comparing vars of two different types?
14:45:26 <mauke> what's the type declaration of bishopAttacks?
14:45:39 <chessguy> bishopAttacks :: (Integral a) => a -> Chessboard -> Integer
14:45:55 <mauke> what
14:46:00 <mauke> what's the type of occupied?
14:46:08 <chessguy> Integer
14:46:20 <xerox-> probably you either want Integral a => a -> Chessboard -> a or a = Integer
14:46:51 <chessguy> huh?
14:47:34 <chessguy> a will either be an Int or an Integer, i don't care which. the result will definitely be an integer
14:47:43 <chessguy> s/integer/Integer/
14:48:34 <xerox-> I'd say, paste the code
14:49:55 <chessguy> @paste
14:49:55 <lambdabot> http://paste.lisp.org/new/haskell
14:50:45 <lisppaste2> chessguy pasted "source and error" at http://paste.lisp.org/display/28883
14:52:16 <xerox-> what are the types of plus7 and occupied?
14:52:53 <chessguy> occupied     :: Integer
14:52:54 <chessguy> plus7 :: (Integral a) => a -> a
14:54:07 <xerox-> my guess is that some function needs applying fromIntegral to its argument, but 'm just guessing now
14:54:26 <chessguy> i'm just trying to comprehend the error message
14:54:30 <chessguy> s
14:55:05 <chessguy> is it saying that the result of (occupied board) is Integer and it shouldn't be?
14:55:21 <xerox-> the argument
14:55:32 <chessguy> board?
14:56:43 <xerox-> it'd be nice if lisppaste snippets could be loaded in lambdabot
14:57:04 <chessguy> hmm, good idea
14:57:43 <xerox-> @lisppasteload 12345#4
14:57:44 <lambdabot> Unknown command, try @list
14:58:50 <chessguy> i just don't get where it's expecting to see something of type a that it isn't seeint it
14:58:53 <chessguy> seeing
15:00:52 <xerox-> chop the code and inspect the types, or paste the whole thing so somebody will try for you
15:01:21 <chessguy> what do you mean, chop the code?
15:01:59 <lisppaste2> chessguy annotated #28883 with "the whole shebang...you asked for it!" at http://paste.lisp.org/display/28883#1
15:02:57 <xerox-> hmm i don't have ghc here, nor the ssh key for darcs.haskell.org
15:03:30 <chessguy> what did you mean by chopping the code?
15:04:09 <xerox-> ?type (.&.)
15:04:11 <lambdabot> forall a. (Bits a) => a -> a -> a
15:04:30 <xerox-> So, the second argument, occupied board, is Integer, meaning that the first one must too.
15:04:46 <chessguy> ohhhhhh
15:05:02 <xerox-> try putting (fromIntegral ...) around diagAttacks1
15:06:40 <chessguy> that did it
15:06:43 <chessguy> thanks!
15:06:52 <xerox-> chessguy: in fact plusn could be of type (Integral a, Integral b) => a -> b
15:07:00 <xerox-> you're welcome
15:07:02 <chessguy> good point
15:07:14 <xerox-> now if only i found a bottle opener....
15:07:19 <xerox-> could find
15:08:38 <chessguy> seems to me .&. could be a little less strict too, then
15:10:04 <emu> @pl \x y -> f x (u,y)
15:10:04 <lambdabot> (. (,) u) . f
15:10:36 <xerox-> i suppose you want to have the same number of bit in the arguments of bitwise operations.
15:11:23 <chessguy> surely you can just left-pad with 0's as necessary
15:12:18 <xerox-> emu: yuck
15:12:30 <chessguy> yeah, looks like perl :)
15:13:08 <xerox-> anybody in London?
15:13:34 <chessguy> US here
15:14:14 <mathewm> ?pl \f -> length . (map f)
15:14:14 <lambdabot> (length .) . map
15:14:56 <mauke> @type fmap (fmap length) fmap
15:15:06 <lambdabot> forall a b. (a -> b) -> [a] -> Int
15:16:21 <mauke> mathewm: wait, that function doesn't make sense
15:16:48 <mathewm> I know
15:16:56 <mathewm> I am playing with (.)
15:17:07 <mauke> oh, naughty
15:17:23 <mathewm> I thought I had composition down, but then got stuck
15:17:47 <lisppaste2> kpreid pasted "Simple task, messy function" at http://paste.lisp.org/display/28885
15:17:55 <kpreid> could someone suggest a way to improve that?
15:17:57 <mauke> @remember mathewm I am playing with (.)
15:18:15 <kpreid> this is particularly irritating as I'm trying to teach someone Haskell and their problem needs that function or something like it
15:18:24 <emu> haha xerox-, yea i decided NOT to use the point-free version as a result
15:18:43 * mathewm is shamed for playing with (.)
15:18:53 <xerox-> emu, i'm not sure of the purpose
15:19:16 <emu> kpreid: take a look at how the Prelude implements lines and words?
15:19:22 <mauke> why doesn't haskell have a generic split function?
15:19:40 <xerox-> we look for unity
15:20:09 <emu> splitAt?
15:20:22 <mauke> no, like split "\n\n" text
15:21:43 <emu> xerox-: it was just a small function i was folding with
15:21:49 <kpreid> emu: I just took a look; it's not much better complexitywise, and doesn't do the edge cases I need
15:21:56 <kpreid> e.g. "\n\n\n" is the same as "\n"
15:22:25 <SamB> > lines ["x\n\n\ny"]
15:22:26 <lambdabot>  Couldn't match `Char' against `[Char]'
15:22:33 <SamB> > lines "x\n\n\ny"
15:22:35 <lambdabot>  ["x","","","y"]
15:22:39 <SamB> um.
15:22:47 <SamB> no it isn't.
15:22:56 <SamB> > lines "xy\n\n\n"
15:22:56 <kpreid> no, I mean that's the behavior I need
15:22:58 <lambdabot>  ["xy","",""]
15:23:00 <SamB> oh.
15:23:01 <kpreid> see the example I gave in the paste
15:23:07 <SamB> in that case...
15:23:31 <SamB> > filter (not . null) $ lines "x\n\n\n"
15:23:32 <lambdabot>  ["x"]
15:23:34 <emu> Data.Bytestring.Char8 has split on characters hehe
15:23:54 <kpreid> SamB: erm, hm
15:25:12 <mauke> > let f a [] = a; f a ("" : xs) = a : f [] (dropWhile ("" ==) xs); f a (x : xs) = f (x : a) xs in f (lines "a\nb\n\n\nc\n")
15:25:13 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
15:25:13 <lambdabot>    Expected...
15:25:26 <kpreid> SamB: yes, that'd work. but I still would need a nice way to write the paragraph-splitting itself...
15:25:29 <mauke> oh, right
15:26:13 <kpreid> 'lines' as in ghci lib has tuples, sections, case inside an expression, primes ... I wouldn't care to write a variant of that and explain it
15:26:31 <SamB> oh
15:27:21 <emu> > inits "abc"
15:27:22 <lambdabot>  ["","a","ab","abc"]
15:27:34 <emu> > tails "abc"
15:27:35 <lambdabot>  ["abc","bc","c",""]
15:28:02 <emu> folding on tails probably would allow you to implement a simple "split" function on substrings
15:28:18 <mauke> > let f (c, r) [] = c : r; f (c, r) ("" : xs) = f ([], c : r) (dropWhile ("" ==) xs); f (c, r) (x : xs) = f (x : c, r) xs in f (lines "a\nb\n\n\nc\n")
15:28:19 <lambdabot>  Couldn't match `([[Char]], [[[Char]]])' against `[String]'
15:28:22 <mauke> argh
15:30:25 <mauke> > let f (c, r) [] = c : r; f (c, r) ("" : xs) = f ([], c : r) (dropWhile ("" ==) xs); f (c, r) (x : xs) = f (x : c, r) xs in f ([], []) (lines "a\nb\n\n\nc\n")
15:30:27 <lambdabot>  [["c"],["b","a"]]
15:31:08 <SamB> hmm.
15:31:14 <SamB> make seems to have gone haywire.
15:31:27 <SamB> it looks like it is running two GHCs in parallel on the same files...
15:32:00 <mauke> > let f (c, r) [] = c : r; f (c, r) ("" : xs) = f ([], c : r) (dropWhile ("" ==) xs); f (c, r) (x : xs) = f (x : c, r) xs in let g = reverse . map reverse . f ([], []) in g (lines "a\nb\n\n\nc\n")
15:32:01 <lambdabot>  [["a","b"],["c"]]
15:32:08 <Igloo> SamB: -k?
15:32:47 <SamB> what does -k have to do with it?
15:33:22 <Igloo> SamB: -k would make it more understandable
15:33:32 <SamB> how so?
15:33:36 <kpreid> I think I found an answer to my problem:
15:33:44 <kpreid> paragraphs text = case matchRegexAll (mkRegex "\n{2,}") text of Just (before, _, after, _) -> before : paragraphs after; Nothing -> [text]
15:33:49 <kpreid> (importing Text.Regex)
15:33:55 <SamB> it isn't an error for there to be nothing to start building at a given time
15:34:14 <Igloo> You might also just be seeing GHC with a second OS thread
15:34:15 <kpreid> this is much more like what the person I'm trying to teach is familiar with
15:34:28 <SamB> Igloo: no, I'm seeing echoes of the commandlines...
15:34:33 <SamB> and the warnings
15:34:42 <lisppaste2> emu annotated #28885 with "hehe" at http://paste.lisp.org/display/28885#1
15:35:21 <kpreid> emu: aieee! :-)
15:35:43 <emu> yes, regex is probably "the right way"
15:37:06 <emu> or perhaps Parsec!
15:37:28 <monochrom> regex is ok if it is not long.
15:38:06 <Botty> regex is too often misused
15:38:29 <emu> it is sufficient for simple lexing
15:38:35 <Botty> yep
15:38:41 <Botty> but people use it for parsing
15:38:43 <Botty> ;p
15:38:48 <emu> what a shame, Parsec is so nice
15:38:58 <monochrom> Precisely.
15:39:00 * kpreid belatedly reads of Text.Regex.splitRegex
15:39:00 <SamB> I don't think any Haskell users are that stupid
15:39:08 <monochrom> That too
15:39:22 <monochrom> people /= haskeller :)
15:39:31 <chessguy> you might be surprised :)
15:39:46 <monochrom> people ∩ haskellers = ∅
15:39:46 <SamB> especially considering the difficulty of finding a regex matching function that will return groups
15:39:56 <Botty> mono - lol
15:40:09 <kpreid> paragraphs text = map (filter (/= "") . lines) (splitRegex (mkRegex "\n{2,}") text) -- *much* better
15:40:12 <xerox-> i wonder if @quotes can contain unicode
15:40:16 <Botty> aliens ∩ haskellers = ?
15:40:54 <SamB> @remember monochrom people ∩ haskellers = ∅
15:41:06 <SamB> @quote monochrom
15:41:06 <lambdabot>  people ∩ haskellers = ∅
15:41:11 <xerox-> yarr
15:41:12 <SamB> I guess so
15:41:17 <chessguy> @yarr
15:41:17 <lambdabot> Aye
15:41:19 <mauke> @quote mathewm
15:41:20 <lambdabot>  I am playing with (.)
15:41:30 <Botty> hah
15:44:02 <lisppaste2> kpreid annotated #28885 with "Much better, short, and in pieces" at http://paste.lisp.org/display/28885#2
15:44:50 <kpreid> SamB, emu, mauke: thanks for the help
15:45:07 <xerox-> if you use |not . null| instead of |(/= [])| you avoid the Eq constraint in the type
15:45:51 <monochrom> Don't use ==[] or /=[].  Use null.
15:45:54 <Botty> > let tits = (.) (.) in tits (\x y -> x + y) 5 (\x -> 2 * x) 2
15:45:56 <lambdabot>  9
15:46:23 <mauke> > let tits = (.) (.) in tits (+) 5 (2 *) 2
15:46:24 <lambdabot>  9
15:46:35 <Botty> good point
15:46:47 <mauke> less points :-)
15:46:50 <mauke> er, fewer
15:49:41 <kpreid> monochrom: I'll consider that.
16:00:27 <Botty> http://en.wikibooks.org/wiki/Haskell/Modules needs work
16:01:16 <Botty> anyway, can I import a module into my own and export its functions?
16:01:36 <monochrom> Yes!
16:01:49 <Botty> sweet, thanks
16:02:08 <Botty> same thing with datatypes i suppose, although that page suggests datatypes are tricky
16:03:11 <monochrom> data X = X Int   -- let's say
16:03:50 <monochrom> module Woah(X)  this will only export the type name X (the first X), not the data constructor X (the second X)
16:04:00 <Botty> oh
16:04:09 <mathewm> can you do recursive types without 'data' types ?
16:04:16 <Botty> module Woah (X, X.X) then maybe?
16:04:20 <monochrom> module Woah(X(X))  now this will export both X's.
16:04:24 <mathewm> (a,[b]) where b = (a,[b])
16:04:24 <Botty> ah ok
16:04:32 <mauke> or X(..)
16:04:56 <monochrom> Have to use 'data' for recursive types.
16:04:58 <uip> anyone here use -fno-monomorphism-restriction regularly?
16:05:14 <mathewm> monochrom: darn, thanks
16:05:50 <Botty> I'll update the wiki then
16:05:57 <Botty> (wikibooks haskell)
16:06:53 <xerox-> -fno-monochrom-restriction
16:07:33 <monochrom> ...
16:18:35 <xerox-> G'night
16:24:04 <ms__> @seen bringert
16:24:04 <lambdabot> I saw bringert leaving #haskell.se and #haskell 3h 39m 31s ago, and .
16:24:18 <ms__> mmm. any haskelldb-ers awake?
16:24:44 <mbishop> hmm, where is lambdabot's code?
16:27:47 <Lemmih> ?uptime
16:27:48 <lambdabot> uptime: 4d 21h 23m 3s, longest uptime: 6d 15h 1m 36s
16:27:51 <Lemmih> ?where lambdabot
16:27:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:28:03 <SamB> @version
16:28:04 <lambdabot> lambdabot 4p250, GHC 6.5 (OpenBSD i386)
16:28:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:29:11 <lisppaste2> emu annotated #28885 with "Parsec version with quickcheck" at http://paste.lisp.org/display/28885#3
16:31:53 <ms__> Couldn't load Database.HaskellDB.HDBC.PostgreSQL.driver from package haskelldb-hdbc-postgresql-0.10
16:32:03 <ms__> anyone else seen this?
16:32:53 <mbishop> 6.5? lambdabot is behind the times :P
16:34:37 <SamB> so is hs-plugins
16:35:00 <ms__> oh. does hs-plugins not work with 6.6?
16:35:24 <SamB> I suppose it didn't the last time dons rebooted lambdabot
16:35:31 <SamB> which would coincide with the last HWN
16:35:44 <ms__> and would explain what haskelldb is broken too
16:35:45 <SamB> I really can't say about right *now*
16:44:12 <Axioplase> Hi !
16:45:00 <Axioplase> How can I read a number passed on cmdline ? (ie. say getArgs's value is a natural number)
16:45:17 <mauke> with read
16:46:43 <Botty> hmm, what's the standard haskell style for abbreviation? For example, "openWindow" or "openWin"
16:46:51 <jonkri> how do i get the first element of a "tripple" (a, b, c)? :)
16:47:00 <mauke> jonkri: pattern matching
16:47:13 <jonkri> ok, ty
16:47:29 <SamB> Botty: probably openWindow is better for a library
16:47:42 <Botty> alright
16:47:45 <mauke> @pl \(a, b, c) -> a
16:47:46 <lambdabot> (line 1, column 7):
16:47:46 <lambdabot> unexpected ","
16:47:46 <lambdabot> expecting letter or digit, operator or ")"
16:47:46 <lambdabot> ambiguous use of a non associative operator
16:47:48 <SamB> because you might want to have a bunch of openFoo functions
16:47:50 <SamB> named for types
16:47:56 <Axioplase> mauke: gosh.. I love this language..
16:48:34 <Botty> A better example is "getJoystickPosition" vs "getJoyPos" or "getJoyPosition"
16:49:14 <chessguy> Axioplase, i think you want something like  http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/scripting_notes/11.html
16:49:18 <mauke> jspos
16:49:19 <lambdabot> http://tinyurl.com/tjt5e
16:49:46 <Axioplase> chessguy: I did it very well with read, thanks
16:50:01 <chessguy> ok, sorry
16:50:09 <Axioplase> chessguy: because getArgs returns a IO [String]
16:50:31 <Axioplase> I jsut needed to convert this string in int..
16:51:04 <Axioplase> Though, I now want a string_of_int ^^
16:51:13 <mauke> show
16:51:32 <Axioplase> indeed
16:51:42 <mauke> > read "2" + length (read "[2]")
16:51:43 <lambdabot>  Add a type signature
16:51:59 <mauke> ico2__|core2: hello :-)
16:52:03 <ico2__|core2> morning
16:52:28 <Baughn> ico2__|core2: Here's to your brain not exploding
16:52:38 <ico2__|core2> cheers
16:54:46 <ico2__|core2> Baughn:  before i spend too much time reading up on this, am i right in assuming that i can just link the haskell object that does some stuff and the c objects that do some stuff together and have the c stuff call functyions in the haskell stuff?
16:55:31 <Baughn> ico2__|core2: Hmm. Calling from C to Haskell?
16:55:34 <Baughn> Han gon
16:55:48 <Axioplase> how does one dump the n first elements of a list ?
16:55:54 <ico2__|core2> it would be impossible to do the whole thing in haskell
16:55:58 <Baughn> > take 5 [1..10]
16:56:00 <lambdabot>  [1,2,3,4,5]
16:56:04 <mauke> Axioplase: drop or take
16:56:09 <Axioplase> ha drop. thanks
16:56:10 <ico2__|core2> and tricky (as you said) to do the whole thing in c
16:56:26 <nicodaemos> Hey, can anyone recommend a good haskell book or online tutorial?
16:56:35 <Baughn> ico2__|core2: You can very easily call C functions from Haskell, but I'm having a hard time finding the documentation. mauke?
16:56:51 <mauke> there's this ffi paper somewhere
16:57:06 <mauke> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
16:57:08 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0 An Addendum to the Haskell 98 Repo ..., http://tinyurl.com/jj62p
16:58:37 <Baughn> ico2__|core2: Answer's yes. What an interesting paper...
16:58:50 <ico2__|core2> cool
16:59:25 <Baughn> ico2__|core2: Generally, you can call C from Haskell with about as much effort as #include "foo.h" - but more annotations may be required to specify whether they're pure or not
16:59:35 <Baughn> ..you'll see
17:00:10 <ico2__|core2> yeah, the page mentions calling c from haskell, but not the other way round
17:00:12 <mauke> no, you just have to omit the IO from the return type to tell haskell that they're pure
17:00:53 <Baughn> Quite - I'm assuming that if you just include a full C header in one fell swoop, it'll assume that all the functions are impure
17:01:33 <jonkri> how do i putStr a integer? can i convert it to a string somehow?
17:01:40 <chessguy> > bit 3
17:01:41 <lambdabot>  Add a type signature
17:01:46 <chessguy> why doesn't this work?
17:01:54 <Baughn> @type bit
17:01:56 <lambdabot> forall a. (Bits a) => Int -> a
17:02:40 <Baughn> So you're not specifying the type of a. What was the command to find all the instances of a class?
17:02:44 <mauke> Baughn: http://haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html#using-own-main
17:02:46 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/y92zq8
17:03:02 <chessguy> > (Bits 4) :: Int
17:03:03 <lambdabot>  Not in scope: data constructor `Bits'
17:03:07 <Baughn> ico2__|core2: http://haskell.org/ghc/docs/latest/html/users_guide/sec-ffi-ghc.html#using-own-main
17:03:08 <chessguy> > (bits 4) :: Int
17:03:08 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/y92zq8
17:03:09 <lambdabot>  Not in scope: `bits'
17:03:12 <chessguy> > (bit 4) :: Int
17:03:14 <lambdabot>  16
17:03:19 <chessguy> well, that's silly
17:03:20 <jonkri> how do i convert a float to a string?
17:03:27 <Baughn> jonkri: show
17:03:57 <chessguy> > fromIntegral . bit $ 4
17:03:58 <lambdabot>  Add a type signature
17:04:10 <ico2__|core2> Baughn:  cheers
17:04:15 <Baughn> @instances Bits
17:04:16 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
17:04:27 <chessguy> @instances Data.Bits
17:04:28 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
17:04:38 <chessguy> @help instances-importing
17:04:39 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
17:05:07 <olliej> anyone seen saulzar?
17:05:17 <chessguy> @seen saulzar
17:05:18 <lambdabot> I saw saulzar leaving #haskell 11d 19h 35m 13s ago, and .
17:05:28 <olliej> chessguy: ah, cheers :D
17:06:05 <jonkri> Baughn: ty :)
17:06:25 <chessguy> so are there more specific version of bit that return specific types?
17:06:40 <chessguy> @docs Data.Bits
17:06:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
17:07:09 <Baughn> > let foo x = bit x :: Integer in foo 14
17:07:10 <lambdabot>  16384
17:07:22 <chessguy> bah
17:12:40 <fons> hi, were can I read a good explanation about type quantifiers? (forall)
17:12:51 <palomer> fons, aren't you a regular?
17:13:07 <fons> palomer, not really
17:13:19 <palomer> type theorists have orgasms about this kind of stuff
17:13:24 <palomer> it's all really rather trivial
17:13:29 <palomer> but they go on, having their orgasms
17:13:56 <palomer> on they go
17:13:57 <palomer> rather
17:14:23 <palomer> you'll have a hard time finding a clear, concise explanation about them though
17:14:29 <palomer> try looking at Pierce's book
17:14:45 <palomer> the reason is very simple: a clear, concise explanation would put all the type theorists out of work!
17:16:10 <Axioplas1> > elemIndex 1 [1..]
17:16:11 <lambdabot>  Just 0
17:16:18 <Axioplas1> Why ?
17:16:28 <Cale> Axioplas1: hm?
17:16:34 <Axioplas1> there is no "0" in the list
17:16:36 <chessguy> > elemIndex 4 [1..]
17:16:38 <lambdabot>  Just 3
17:16:38 <Axioplas1> ha !!
17:16:39 <Cale> Axioplas1: because the 0th element of that list is 1
17:16:48 <Cale> !! indeed
17:16:49 <Axioplas1> given the elem, it gives its position
17:16:51 <Cale> > [1..] !! 0
17:16:53 <lambdabot>  1
17:16:55 <chessguy> lol
17:17:03 <Axioplas1> I thought "give me the pos, I give you the element"
17:17:09 <Cale> aha
17:17:17 <Cale> yeah, that's what !! does
17:17:32 <chessguy> does !! provide O(1) access?
17:17:38 <mauke> haha, no
17:17:39 <Cale> no, O(k)
17:17:46 <Baughn> @type (!!)
17:17:46 <chessguy> yuck
17:17:47 <lambdabot> forall a. [a] -> Int -> a
17:17:57 <Cale> Well, these are lists, not arrays
17:18:01 <chessguy> indeed
17:18:07 <Cale> If you want O(1) access, you use an array
17:18:28 <chessguy> well, it was worth asking :)
17:19:14 <fons> thanks palomer
17:19:15 <Cale> However, !! is still useful as a one-off thing. You just wouldn't for instance use it to build a new list from an old one.
17:19:33 <monochrom> I recommend palomer for putting type theorists out of jobs.
17:20:05 <Cale> fons: forall in a type just means that variable could be replaced with any type whatsoever.
17:20:26 <Cale> Whereas exists means that there is some type which would make the signature valid.
17:20:55 <Cale> (but there's no exists in Haskell)
17:21:11 <fons> thanks Cale
17:21:28 <Cale> all type signatures in Haskell implicitly forall quantify type variables which are otherwise not bound
17:21:36 <Cale> so if I write  id :: a -> a
17:21:46 <Cale> it implicitly means  id :: forall a. a -> a
17:22:01 <Baughn> Cale: So what's the point of forall in !!'s type?
17:22:07 <Cale> @type (!!)
17:22:09 <lambdabot> forall a. [a] -> Int -> a
17:22:15 <Cale> It could be omitted
17:22:23 <Cale> But it's really there regardless
17:22:35 <Cale> It means that any type of list will work
17:23:05 <Cale> That is, for all types a, (!!) could have type [a] -> Int -> a
17:24:04 <monochrom> A recent entry in the mailing lists puts it nicely.  "forall really means for all" :)
17:24:35 <Cale> and not, for instance fo rall
17:24:39 <mauke> template<typename a> a operator!!(const list<a> &, int), easy
17:24:48 <Cale> mauke: ahaha
17:25:12 * monochrom faints
17:25:17 <cjeris> mauke: where in this particular case the !! is preceded by an implied 'wtf'
17:25:28 <Cale> @quote cjeris
17:25:29 <lambdabot>  i have a little perl script that aliases gcc -freduced-suckage to ghc
17:25:31 <Cale> @quote cjeris
17:25:31 <lambdabot>  i have a little perl script that aliases gcc -freduced-suckage to ghc
17:25:45 <Cale> hmm
17:26:16 <Cale> oh, it is in there, just bad luck :)
17:26:18 <Cale> @quote cjeris
17:26:18 <lambdabot>  Cale: I like how you conveniently gloss over the part where your head explodes.
17:26:41 <dons> ?uptime
17:26:42 <lambdabot> uptime: 4d 22h 21m 56s, longest uptime: 6d 15h 1m 36s
17:26:44 <dons> moin!
17:26:48 <olliej> yo dons
17:26:49 <dons> ?users
17:26:50 <lambdabot> Maximum users seen in #haskell: 256, currently: 230 (89.8%), active: 32 (13.9%)
17:27:13 <Cale> > 2^8
17:27:14 <lambdabot>  256
17:27:51 <mauke> hmm, you could probably rape c++ enough to make std::list<int> xs; int i; ... cout << !! xs (i); work
17:28:31 <chessguy> heya dons
17:28:37 <Cale> Hell, if you can approximate do-notation...
17:28:59 <Cale> Where was that code again?
17:30:16 <cjeris> > take 4 [1]
17:30:18 <lambdabot>  [1]
17:30:23 <Cale> http://www-static.cc.gatech.edu/~yannis/fc++/FC++.1.5/monad.h
17:30:25 <lambdabot> http://tinyurl.com/y6q7k4
17:30:38 <chessguy> monad.h...that just sounds funny
17:30:51 <Cale> wait 'til you see the code
17:30:58 <dolio> Ahahahaa.
17:31:02 <dolio> "template <class Rep> struct ThisTypeIsNotAnInstanceOfAnInferrableMonad"
17:31:21 <cjeris> Cale: my life is measurably worse because I clicked on that link
17:31:24 <olliej> mauke: you won't be able to make !! be a single operator
17:31:35 <Cale> cjeris: haha
17:31:50 <mauke> olliej: yeah, I know
17:32:01 <olliej> mauke: operator!() could return a type with operator!() defined
17:32:36 <olliej> mauke: so you could make it parse as !(!xs)
17:32:45 <cjeris> Cale: they should use that to scare undergrads.  "And THIS is what happens to people who think they should use C++ to write their programs!"
17:32:48 <mauke> exactly
17:32:55 <Cale> yes :)
17:33:23 <mauke> Cale: http://www.xs4all.nl/~weegen/eelis/analogliterals.xhtml
17:33:26 <lambdabot> http://tinyurl.com/yaz7sx
17:33:46 <Cale> hahaha
17:34:16 <monochrom> Heresy
17:34:44 <dolio> Wow. The 3D literals really got me.
17:35:18 <chessguy> you people are really weird, you know that? :_
17:35:19 <chessguy> :)
17:36:47 <monochrom> No we are not weird.  We just know of lots of weird people and their urls.
17:37:51 <mauke> re: weird people/urls, http://mauke.ath.cx/stuff/poly.poly
17:38:31 <monochrom> Oh haha yeah!
17:40:25 <chessguy> what in the world is that?
17:40:53 <mauke> a program or two
17:41:12 <dons> Cale: http://programming.reddit.com/info/o8zr/comments  :D
17:41:15 <lambdabot> Title: Monads in C++ (reddit.com), http://tinyurl.com/y9nt4u
17:41:19 <olliej> mauke: that is evil
17:41:44 <Cale> that'll get a mod up from me :)
17:42:44 <dons> I just can't wait to see the comments from non-haskellers
17:43:13 <dmead> ;o
17:43:33 <dmead> you guys know who ron jefferies is?
17:43:51 <dolio> I wonder how qwe1234 will decide what comment to make.
17:44:02 <dons> heh
17:44:06 <dons> that should be good.
17:44:07 <dolio> On the one hand, he'll be pro-C++ at any opportunity.
17:44:10 <dons> he'll be so conflicted!
17:44:12 <Cale> Who is qwe1234?
17:44:18 <dmead> o0
17:44:18 <dolio> On the other hand, monads are academic bullshittery.
17:44:51 <dons> Cale: this guy, http://programming.reddit.com/user/qwe1234/
17:44:53 <lambdabot> Title: overview by qwe1234 (on programming.reddit.com)
17:45:02 <dons> lowest karma ever ;)
17:45:18 <Cale> haha, we should have an @qwe1234
17:45:23 <Cale> "writing compilers is boring."
17:45:30 <dolio> @qwe1234
17:45:30 <lambdabot> Unknown command, try @list
17:45:48 <Cale> "lol i smell a cult"
17:45:48 <dolio> @quote qwe1234
17:45:49 <lambdabot>  it's 2006 already, and the world doesn't need 'dynamic languages'. otherwise, we'd be all programming in perl.
17:48:33 <palomer> oh my!
17:48:52 <dons> "if you're writing something that absolutely requires a cyclical linked-list structure, you need to have your head checked"
17:49:18 <olliej> dons: qwe1234 again?
17:50:30 <dons> yup
17:50:47 <dons> C++: creating blub programmers since 1985
17:51:15 <olliej> dons: C++ is a great language
17:51:19 <chessguy> @remember dons C++: creating blub programmers since 1985
17:51:40 <chessguy> @quote dons
17:51:41 <lambdabot>  ihope reaches level 4 hacker
17:51:48 <ihope> I do?
17:51:53 <chessguy> @quote dons
17:51:54 <lambdabot>  note that you're using all the advanced features of haskell in 1 line here...
17:52:03 <chessguy> @quote dons
17:52:04 <lambdabot>  global state is just another pure value :)
17:52:11 <chessguy> @quote dons
17:52:12 <lambdabot>  ihope reaches level 4 hacker
17:52:16 <olliej> @quote olliej
17:52:17 <lambdabot> olliej hasn't said anything memorable
17:52:20 <olliej> hurrah!
17:52:26 <ihope> @quote ihope
17:52:27 <lambdabot>  Laziness is free, but it doesn't always pay off.
17:52:29 <chessguy> @quote chessguy
17:52:30 <lambdabot>  i didn't think pennsylvania had anybody cool enough to know haskell in it
17:52:41 <olliej> hehe
17:52:41 <palomer> @palomer
17:52:42 <lambdabot> They're telling you lies!
17:52:59 <uip> @yow
17:52:59 <lambdabot> for ARTIFICIAL FLAVORING!!
17:53:03 <palomer> @palomer
17:53:03 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
17:53:10 <chessguy> @yarr
17:53:10 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
17:53:11 <palomer> I still haven't!
17:53:13 <dolio> @protontorpedo
17:53:14 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
17:53:20 <palomer> I think ill put it in a footnote in my thesis
17:53:23 <palomer> if ever I bother writing it
17:54:18 <palomer> (the other proclaims the subject matter herein discussed as useless)
17:54:34 <Cale> hm?
17:54:41 <Cale> You mentioned #haskell?
17:54:51 <Cale> Or the paper was self-referential?
17:55:53 <palomer> GADTs!
17:56:12 <palomer> really, why did I pick such a useless subject matter?
17:56:24 <palomer> oh, that's write, the devil offered me a deal I couldn't refuse
17:56:40 * palomer is off
17:57:07 <Cale> palomer: well, that's something for you to do then - discover an interesting application for them :)
17:57:45 <uip> i used GADT and i don't even understand them
17:57:50 <Cale> The problem with type system extensions over HM is that HM is pretty good to start with.
17:58:41 <Cale> And HM + Typeclasses is really good.
17:59:12 <Cale> So it's hard to get extensions which give you anything but niche applications.
18:02:57 <Axioplase> is there a "fast" way to compute the list of 3-uples whose sum equals N ?
18:03:56 <Axioplase> because a map$map$map on [1..N],[1..N],[1..N] is a *bit* slow...
18:04:28 <chessguy> do want them to be integers? naturals?
18:04:40 <Axioplase> (ha... got an idea)
18:04:42 <Axioplase> naturals
18:05:13 <Axioplase> instead of (1..N) on the second on, I'd better [1..x] where x is the mapped variable
18:05:14 <chessguy> > [(x,y,z) | x<-[1..], y<-[1..],z<-[1..],x+y+z==5]
18:05:18 <lambdabot> Terminated
18:05:32 <chessguy> > [(x,y,z) | x<-[1..5], y<-[1..5],z<-[1..5],x+y+z==5]
18:05:34 <lambdabot>  [(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(3,1,1)]
18:05:49 <chessguy> > [(x,y,z) | x<-[1..5], y<-[1..x],z<-[1..5],x+y+z==5]
18:05:51 <lambdabot>  [(1,1,3),(2,1,2),(2,2,1),(3,1,1)]
18:06:14 <dolio> > [(x,y,5-x-y) | x <- [1..3], y <- [1..3] ]
18:06:16 <lambdabot>  [(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(2,3,0),(3,1,1),(3,2,0),(3,3,-1)]
18:06:24 <dolio> Oops.
18:06:25 <Axioplase> haa.. I had forgotten this...
18:07:01 <dolio> > [(x,y,5-x-y) | x <- [1..3], y <- [1..(4-x)] ]
18:07:02 <lambdabot>  [(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(3,1,1)]
18:10:55 <chessguy> dons: you aroun?
18:10:57 <chessguy> d
18:13:50 <dons> yes
18:14:16 <chessguy> hey, i'm trying to modify that bot code for another server
18:14:22 <dons> cool
18:14:32 <chessguy> does it just use basic sockets and tcp/ip?
18:14:42 <dons> yep.
18:14:57 <dons> ?docs Network
18:14:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
18:15:18 <chessguy> and the stuff in run :: Net ()  gets done as soon as the bot connects?
18:15:46 <dons> yep, after it connects, then the net monad is invoked
18:15:58 <dons> which is just IO + the socket to talk on.
18:16:07 * Cale deletes 100 times the size of his first computer's hard drive in 23 files.
18:16:48 <chessguy> hmm
18:16:55 <chessguy> write "NICK" nick
18:17:02 <chessguy> doesn't nick just get discarded there?
18:17:17 <dons> nope. you've seen it connect :)
18:17:54 <chessguy> so what actually gets sent on the socket?
18:18:40 <dons> look at the defintion of 'write', just some plain text with : and so on inserted
18:19:02 <foxy> @hoogle bounds
18:19:02 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
18:19:03 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
18:19:03 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
18:19:09 <Cale> no :
18:19:09 <dons> something like: NICK tutbot\r\n
18:19:21 <foxy> @instance HasBounds
18:19:22 <lambdabot> Maybe you meant: instances instances-importing
18:19:35 <foxy> @instances HasBounds
18:19:36 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
18:19:56 <emu> given that  i have written a number of quickcheck props for a few different types, how should i package it all up into one "test suite"?
18:20:56 <Cale> perhaps create an action which actually calls quickCheck on each of them
18:21:04 <dons> this is just werid, translated from haskell, http://www.bluishcoder.co.nz/2006/10/compilers-and-interpreters-in-factor.html
18:21:07 <lambdabot> Title: Bluish Coder: Compilers and Interpreters in Factor, http://tinyurl.com/tjabr
18:21:34 <Cale> dons: yeah, that's total heresy
18:21:50 <Cale> dons: Taking a GADT example and translating it into a typeless stack language
18:21:58 <dons> yeah. bizarre
18:22:31 <dons> i'm not really sure i'd want to write a compiler in factor..
18:24:01 <emu> well if his definition of compiler is 'something that parses and uh, spits out something, but yea, parsing!' then i can see where he's coming from
18:24:28 <chessguy> i don't get it. why does write take two strings?
18:24:56 <dons> chessguy: hmm? it takes the argument, and the particular irc command, and composes them
18:25:15 <dons> i.e. "NICK" "foo" or "PRIVMSG" "hello"
18:25:26 <chessguy> why doesn't it just take them as a single string?
18:25:39 <chessguy> write "NICK" ++ nick
18:25:42 <Cale> chessguy: that's the abstraction
18:25:51 <Cale> chessguy: it's not much of one, but it's something
18:25:56 <dons> :)
18:26:09 <emu> why isn't it data IrcCommand = Nick ...
18:26:11 <Cale> So you could partially apply it, for instance
18:26:14 <dons> heh, data types are for bigger tuts..
18:26:35 <dons> emu, chessguy: yeah, if you are serious about this, write a data type describing the protocol you want to talk
18:26:47 * cjeris is reconsidering taking the compiler class while working full time. grrrr.
18:26:50 <Cale> Say, apply it to PRIVMSG and then mapM that over a list.
18:26:52 <chessguy> hmm?
18:26:59 <chessguy> a datatype describing a protocol?
18:27:16 <dons> yeah. data IRC = Nick String | Privmsg String String ....
18:27:27 <dons> then parse and pretty print those things from the network
18:27:35 <emu> using Parsec!
18:27:35 <chessguy> hmm
18:28:24 <dons> the more structure you give the types, the less bugs you'll have, as you'll rule out more invalid message forms statically
18:28:27 <chessguy> ok, i'll play around some more. i've got it logging on
18:28:37 <dons> to irc? or something else?
18:28:42 <chessguy> something else
18:28:49 <dons> something secret?
18:28:58 <chessguy> nah, no big secret. www.chessclub.com
18:28:58 <dons> chess-tcp ?
18:29:01 <dons> ah!
18:29:03 <chessguy> lol, close :)
18:29:04 * dons guess right
18:29:58 <Cale> I have to learn to stop referring to dynamically typed languages as typeless.
18:30:10 <Cale> They really do feel that way to me though.
18:30:31 <dolio> Heh. That does strike nerves.
18:30:32 <Igloo> "might-as-well-be-typeless"
18:30:36 <Cale> yeah
18:30:40 <emu> > [1::Integer,1.5] :: (Num a) => [a]
18:30:40 <monochrom> You need an acronym.  RTTL.  Run time typed languages.
18:30:40 <lambdabot>  a
18:30:41 <lambdabot>    Inferred type: Integer
18:30:41 <lambdabot>   In the expression: 1 :: Integer
18:30:41 <lambdabot>   In t...
18:31:01 <dons> MAWBTL is good
18:31:15 <monochrom> LTL.  Lazily typed languages.
18:31:20 <emu> hehe
18:31:24 <Igloo> I quite like RTTL, pronounced "rattle". As in if you pick it up and shake it, it sounds broken
18:31:31 <dons> types aren't types if they're at runtime -- they're values.
18:31:45 <Cale> If your compiler isn't proving theorems about the code before it runs, that's just not a type system, I'm sorry.
18:31:51 <Igloo> So dependently typed languages aren't typed?
18:31:57 <emu> tell me, is what I just tried some form of the monomorphism restriction?
18:32:21 <monochrom> No.
18:32:30 <Cale> Igloo: they're typed if the types are checked at compile time :)
18:32:47 <Cale> Which involves user-supplied proofs which are machine checked
18:32:57 <dons> yeah
18:33:03 <emu> Cale: what if the compiler attempts to prove theorems about the code regarding types and such but doesn't stop if it can't prove them
18:33:09 <emu> (in some cases)
18:33:21 <Cale> emu: It should at least emit a list of proof requirements.
18:33:26 <emu> ok
18:33:48 <emu> ok how about if it attempts to prove within a decidable subset of the language and leaves the rest?
18:34:18 <Cale> Is that not exactly the same as what you just asked?
18:34:32 <Cale> I'm saying it should tell you exactly where it gave up
18:34:36 <monochrom> The type of [1::Integer, 1.5::Double] is something along the line of [exists a. Show a /\ a]
18:34:50 <emu> yea i'm just being silly.  that's basically what CMUCL and SBCL do
18:35:24 <monochrom> Err!  [exists a. Num a /\ a]
18:35:31 <emu> hmm exists
18:35:43 <emu> so basically i'd need a "data" type currently
18:36:07 <monochrom> Normally I would make my own sum type, yes.  Either Integer Double
18:37:12 <Cale> Or if you want, you could use an existential type, but that would be fairly pointless, since most numeric operations are combining, and you've already lost any knowledge about whether the elements of the list are the same type.
18:38:41 <emu> yea i was using numeric types as a short example.  i'm really dealing with (Testable a) => a -> IO()
18:39:25 <emu> which i've settled on a list something like: [check c prop_blah, check c prop_foo]
18:42:06 <emu> i've been working on a simple-temporal-network library as a learning exercise, using quickcheck generated tests
18:42:45 <dolio> So, is Niklaus Wirth a Haskell programmer yet?
18:42:56 <Cale> I didn't hear back from him
18:43:00 <mwc> dolio: needs less layout, more BEGIN/END :)
18:43:06 <dolio> Oh well. :)
18:43:23 <emu> he'll have a stroke over if then else
18:43:25 <Cale> It was an exceedingly long email, perhaps he hasn't gotten around to it
18:43:52 <Cale> emu: nah, Haskell's if-then-else doesn't have that problem, because the else is always there
18:44:12 <emu> yea but there's no END ;)
18:44:26 <Cale> the whole point of end was to disambiguate the grammar
18:44:31 <emu> not to mention layout would settle it
18:44:47 <mwc> Cale, what's this letter to Wirth about?
18:44:54 <mwc> open letter?
18:45:01 <emu> he can write with semi-colons, at least
18:45:16 <Cale> mwc: Some rather dismissive remarks he made about functional programming in a recent paper.
18:45:27 <emu> i still can't believe that paper was recent
18:45:40 <emu> he sounds like he is living in a time warp
18:45:51 <Cale> http://www.cs.inf.ethz.ch/~wirth/Articles/GoodIdeas_origFig.pdf
18:45:55 <lambdabot> http://tinyurl.com/yhc5r2
18:45:57 <emu> all of his examples were from 25 years ago
18:46:15 <mwc> emu, I'm afraid he's gone Einstein on us
18:46:15 <dons> yeah, i was thinking that too.
18:46:17 <atsampson> to be fair, looking at old examples is entirely the point of that paper...
18:46:19 <Cale> It's a retrospective. I think he might have been right about FP 25 years ago.
18:46:31 <emu> he doesn't seem to know about the existence of modern type systems
18:46:35 <mwc> did some really amazing work, and then stopped reading papers for 20 years while he chased pipe dreams
18:46:45 <Cale> What was he chasing?
18:46:50 <emu> oh, I really like the old examples.  they're interesting.  but uh...
18:49:00 <mwc> Cale, what we'd call a Unified Field Theory these days
18:49:17 <mwc> trying to work classical EM and GR into a UFT
18:49:19 <emu> yep
18:49:27 <emu> Einstein was very uncomfortable with QM
18:49:42 <mwc> I've seen reports that he'd stopped reading papers in the last 20 years or so of his life
18:50:03 <dons> oh, hmm, is this some Elvish tongue? "Haskell: Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn!"
18:50:15 <mwc> Looks more like Lovecraft
18:50:16 <atsampson> no, it's H. P. Lovecraft
18:50:24 <emu> its' got Cthulhu in it
18:50:32 <cjeris> Ia, Tsathoggua! Ia! Ia!
18:50:36 <Cale> Yeah, that's Lovecraft alright :)
18:50:59 <atsampson> "In His House at R'lyeh Dead Cthulhu waits dreaming", apparently
18:51:14 <Cale> Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn.
18:51:29 <Cale> http://en.wikisource.org/wiki/The_Call_of_Cthulhu
18:51:32 <lambdabot> http://tinyurl.com/kz3b8
18:51:52 <Cale> Yeah, they got the spelling right even :)
18:52:31 <Cale> I really recommend reading that (the wikisource page has the complete book) if you haven't :)
18:52:57 <foxy> @seen x3m
18:52:57 <lambdabot> x3m is in #haskell-overflow and #haskell. I last heard x3m speak 9h 46m 26s ago.
18:53:42 <dons> so what's the implication? haskell is the language of strange wizard priests?
18:54:14 <Cale> Haskell is capable of summoning existential horror?
18:54:30 <cjeris> dons: more that it comes from unimaginably ancient hostile beings from beyond the stars, and will drive those who learn it irretrievably insane.
18:54:40 <dons> ah!
18:54:53 <dons> ok, that makes some sense
18:55:01 <mwc> Cale, I thought existential horror and demons flying out of space time warps was the domain of C++'s undefined behaviour
18:55:01 <dolio> Will haskell programmers be eaten first?
18:55:11 <emu> no, they are immutable
18:55:21 <mwc> dolio, Haskell programmers will shovel other mortals into the maw of Cthulhu with pitchforks
18:55:30 <Cale> Where is that Lovecraft/Haskell thing anyway?
18:55:47 <dons> on the http://programming.reddit.com/info/o5k5/comments page
18:55:50 <lambdabot> Title: Six Word Stories about Programming Languages (reddit.com), http://tinyurl.com/waa39
18:56:29 <dons> pity, i kind of like the idea that haskell is the language of the elves
18:56:49 <emu> am I nutty for wondering whether there is a way to do a "graph shaped" State monad for in-place updates on a graph data structure
18:57:20 <mwc> Heheheh
18:57:21 <mwc> Story story = (Story) StoryFactory.new("java");
18:57:57 <Cale> mwc: Tell that to the morons who constantly use the "Singleton pattern"
18:58:16 <mwc> I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers.
18:58:53 <dons> ?remember mwc I can only believe that Java is a conspiracy perpetrated by keyboard manufacturers
18:59:08 <Cale> emu: Not entirely insane. I'm not 100% sure about how that would work though. ST is not too bad for working with graph structures in a traditional way
18:59:50 <emu> I wrote my algorithm using a lot of Data.IntSet and IntMap for tracking these things :/
19:00:19 <mwc> The one failing of ST is the sheer avalanche of type annotations that take over your code
19:01:12 <mwc> I think that's why folks probably use IORefs, and IO MArrays and not STRefs and ST MArrays.
19:11:04 <dons> Cale: i'm thinking we need a wiki page, "Haskell for mathematics"
19:11:11 <dons> collecting libraries, and all the blog and tutorials
19:11:22 <Cale> yeah, there has been some good stuff written
19:11:26 <foxy> dons, When I try to run Frag I get lots of "missing textures" and then a seg fault...
19:11:44 <dons> foxy: ok. i can't help much -- i just manage the darcs repo.  :)
19:11:55 <Cale> What we really need is a project to port GAP to Haskell, but that's unimaginably large, and I don't know the first thing about computational group theory.
19:12:12 <dons> Cale: so i'll create the wiki page, put up some links i can find, and perhaps you can cast an eye over it and add anything you can think of.
19:12:34 <dons> foxy: missing textures sounds a bit weird?
19:12:39 <mwc> Cale, I had a prof who's expertise was that
19:12:42 <foxy> Cale/dons, a stable binding to atlas/lapack would be good
19:13:37 <foxy> dons, it seems to be all the textures not specific to the "egyptian" level
19:16:24 <foxy> dons, did you receive my frag patch? (sent from linux, so no crazy windows file format :)
19:17:41 <dons> ah yes. still need to apply. its sitting on the top of my inbox
19:17:50 <dons> oh, actually no.
19:17:53 <dons> i got one from lispy
19:18:06 <dons> when did you send it?
19:18:36 <foxy> a few minutes ago, it just fixed a change in IOUArray for ghc6.6
19:19:32 <chessguy> hmmm. all this fancy monad stuff is doing something the other server doesn't like
19:21:04 <cjeris> grr. sml-mode has no idea how to indent my "try to write sml monadically" code
19:22:06 <cjeris> it's all #haskell's fault, if it weren't for your help i would be writing this stuff with refs and assignments all over the place and wondering why i was so confused
19:22:13 <cjeris> instead i just wonder why i'm so confused :D
19:22:15 <dons> heh
19:22:26 <dons> didn't you know that haskell makes you a worse programmer? ;)
19:23:10 <cjeris> no, i do lots of things every day that make me a worse programmer (like program in coldfusion)
19:24:22 <chessguy> oh good grief
19:24:36 <chessguy> i probably should be trying to connect a bot to a socket on www.chessclub.com
19:24:42 <chessguy> instead of chessclub.com
19:25:25 <chessguy> so much for blaming it on the fancy monad stuff
19:25:41 <cjeris> South Park presents: "Blame Monada"
19:26:00 <dons> Cale: here you go, http://haskell.org/haskellwiki/Haskell_and_mathematics
19:26:02 <lambdabot> Title: Haskell and mathematics - HaskellWiki, http://tinyurl.com/yerb92
19:26:17 <dons> if you know of more resources (I'm sure you do) please add them. and anyone else with an interest in the area
19:26:43 <chessguy> good one, dons
19:26:58 <chessguy> that book finally got me over the beginning hump of haskell
19:26:59 <dons> ah, like the euler puzzles, too.
19:28:32 <chessguy> dons: so if i figured out how forkIO worked, i could use this bot to log on, and it would automagically handle all the incoming and outgoing stuff while also sending whatever i type into the interface?
19:29:05 <chessguy> @hoogle forkIO
19:29:06 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
19:29:16 <chessguy> @docs forkIO
19:29:17 <lambdabot> forkIO not available
19:29:20 <dons> chessguy: yeah.
19:29:23 <dons> use -threaded
19:29:30 <chessguy> @docs Control.Concurrent.forkIO forkIO
19:29:30 <lambdabot> Control.Concurrent.forkIO forkIO not available
19:29:35 <chessguy> @docs Control.Concurrent.forkIO
19:29:35 <dons> and just fork off some threads to do whatever you need
19:29:35 <lambdabot> Control.Concurrent.forkIO not available
19:29:39 <dons> ?docs Control.Concurrent
19:29:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
19:29:46 <chessguy> thanks
19:29:57 <chessguy> -threaded is a commandline argument to GHC?
19:30:15 <dons> yep
19:31:38 <cjeris> Q: When's a good time to call it a night?  A: When you realize yet again that you tried to be way too clever and shot yourself in the foot.
19:33:57 <dmead> you guys ever heard of the bowling game problem?
19:34:41 <chessguy> enlighten us
19:36:59 <chessguy> urgh, i don't get how to do this, dons
19:39:54 <dons> hmm?
19:40:06 <chessguy> forking off a new process
19:40:09 <chessguy> err, thread
19:40:29 <dons> ok, let me do a little demo
19:40:52 <chessguy> that would be fantabulous
19:41:10 <dons> something like:
19:41:11 <dons>     loop st    = catch (do forkIO (runReaderT mythread st)
19:41:11 <dons>                            runReaderT run st)
19:41:11 <dons>                        (const $ return ())
19:41:25 <dons> so, once you've connected, fork off another thread in the Net monad
19:42:50 <chessguy> so then after that i would have more lines in main that would loop around taking input from the interface?
19:43:28 <dcoutts> @yarr!
19:43:29 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
19:43:34 <dcoutts> quite
19:43:45 <dcoutts> @slap lambdabot
19:43:45 * lambdabot smacks lambdabot about with a large trout
19:43:55 <dcoutts> lambdabot is so rude.
19:43:56 <chessguy> or would that go in mythread
19:44:22 <dons> mythread would be your function of type Net () that you wish to run
19:44:34 <dons> that might read input and do whatever
19:45:18 <chessguy> ok
19:48:04 * chessguy crosses fingers
19:49:27 <emu> this Monad transformer stuff is pretty neat
19:50:29 <monochrom> YES!
19:50:34 <dmead> hey
19:50:34 <dmead> hehe
19:51:09 <dmead> chessguy: http://butunclebob.com/files/downloads/Bowling%20Game%20Kata.ppt
19:51:12 <lambdabot> http://tinyurl.com/s9o2y
19:52:46 <dons> are there other sub-communities of haskell that people can think of? besides the Education, Maths, Commericial users, and research communities?
19:53:08 <chessguy> nice powerpoint
19:57:18 <chessguy> > elementOf 5 [1,5]
19:57:19 <lambdabot>  Not in scope: `elementOf'
19:57:26 <chessguy> > elem 5 [1,5]
19:57:27 <lambdabot>  True
19:58:11 <dmead> it's not mine, just looking at the rules
19:58:29 <dmead> > elementOf 423 [1..1000]
19:58:30 <lambdabot>  Not in scope: `elementOf'
19:58:43 <dmead> o0
19:58:52 <dmead> o
19:59:11 <dmead> > elem 423 [1..1000]
19:59:13 <lambdabot>  True
19:59:34 <dmead> > elem 999 [1..1000]
19:59:35 <lambdabot>  True
19:59:38 <emu> @type newArray
19:59:40 <lambdabot> Not in scope: `newArray'
19:59:41 <dmead> > elem 1 [1..1000]
19:59:43 <lambdabot>  True
19:59:46 <dmead> > elem 1 [1..1000]
19:59:47 <lambdabot>  True
19:59:51 <dmead> > elem 1 [1000..1000]
19:59:52 <lambdabot>  False
19:59:58 <dmead> > elem 1000 [1000..1000]
19:59:59 <lambdabot>  True
20:00:03 <dmead> hmm
20:00:11 <dmead> you'd think it'd be a bit faster sometimes
20:00:35 <monochrom> Marketing committee
20:00:40 <monochrom> Steering committee
20:01:36 <dons> "Marketing committee" eh?
20:03:24 <monochrom> Got to compete with C# and Java on PR too. :)
20:03:58 <monochrom> Write some WHITE PAPERS that says, you know, "value-orientation".
20:04:26 <dons> heh
20:04:39 <int-e> are they called white papers because they provide as much information as a blank sheet of paper?
20:04:56 <desrt> hello hackers.
20:05:01 <dons> hey desrt !
20:05:10 <desrt> given some data type representing, say, expressions
20:05:24 <desrt> where i have lots of things like Add Expr Expr | Sub Expr Expr | Mult Expr Expr
20:05:25 <desrt> etc
20:05:33 <monochrom> I don't know why they're called white papers.
20:05:44 <desrt> and i want to apply a function (Expr -> Expr) starting at the bottom-most nodes in the tree
20:05:57 <desrt> is there any way to do this sort of recursion without listing all of the cases?
20:05:59 <desrt> dons; hi :)
20:06:10 <desrt> dons; i hear you recently shared a room with a gnome hacker at google :)
20:06:46 <monochrom> I just love the way that packaging is the only factor in business PR.  It's so mechanical and formal, you can almost write a Haskell program to automate it.
20:07:01 <Cale> desrt: mm, rather like a generalised scanl
20:07:20 <dons> desrt: yes!
20:07:23 <desrt> say i have like
20:07:29 <emu> @hoogle newSTArray
20:07:29 <lambdabot> No matches found
20:07:35 <desrt> data Foo = Thing Foo Foo | Other Foo Foo
20:07:39 <desrt> then i say
20:07:51 <desrt> func :: Foo -> Foo
20:07:54 <desrt> func (a b c) = b
20:08:12 <desrt> where that (a b c) pattern match matches in such a way that 'a' captures the type constructor itself
20:08:27 <desrt> something like this would be nice :)
20:09:02 <Cale> One thing which you might want to write is the fold for your type
20:09:10 <desrt> the only other thing i can think of doing is turning my abstract syntax tree into a 3-way type: Unary/Binary/Trinary
20:09:17 <emu> @hoogle newArray
20:09:18 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
20:09:18 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
20:09:18 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
20:09:38 <desrt> Cale; but i have to handle all cases in this situation
20:09:55 <desrt> which i don't mind doing once
20:09:59 <desrt> but i find myself doing it a lot :)
20:10:01 <chessguy> suppose i have a list like ["foo", "bar", "baz"], and i want to know if some string s is prefixed by one of those strings....suggestions?
20:10:25 <emu> > Data.Array.MArray.newArray (0,1) 0
20:10:25 <Cale> so if your constructors are the same type, it's easy to specialise the fold to pass the same function for each of the replacements
20:10:25 <lambdabot>  Not in scope: `Data.Array.MArray.newArray'
20:10:51 <Cale> chessguy: any (`isPrefixOf` s) xs
20:10:52 <int-e> > and (`isPrefixOf` "abcdef") ["xyz", "ba"]
20:10:53 <lambdabot>    The function `and' is applied to two arguments,
20:10:53 <lambdabot>   but its type `[Bool]...
20:10:55 <int-e> > any (`isPrefixOf` "abcdef") ["xyz", "ba"]
20:10:56 <lambdabot>  False
20:10:58 <desrt> chessguy; if a 'prefix' type operation doesn't exist in the prelude i recommend using 'zip' 'map' and '... oh bother
20:11:02 <desrt> it does exist :)
20:11:19 <Cale> It's actually in Data.List
20:11:27 <chessguy> isPrefixOf exists, yeah
20:11:35 <desrt> well then it's trivial :)
20:12:01 <int-e> it leads to natural looking code, too. I love Haskell.
20:12:20 <desrt> anyway.. i have 3 types of recursions i do over my terms
20:12:34 <desrt> set-building recursion, total recursion and single recursion
20:12:39 <int-e> Or maybe my view of 'natural' is influenced by looking at too much Haskell code. Do I care?
20:12:55 <desrt> set-building i build sets at the terminals and union them all
20:13:08 <desrt> total, i apply some function to all exprs and sub-exprs
20:13:14 <desrt> single i apply some function exactly once
20:13:22 <desrt> whenever it first matches
20:13:30 <desrt> (my functions return maybes)
20:14:39 <desrt> it just seems evil that if i add some new term type to the language i have to rewrite all 3 cases
20:14:55 <desrt> i guess a good first step would be to try to collapse all 3 cases to 1
20:15:43 <Cale> lisppaste2: url
20:15:44 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:15:57 <lisppaste2> Cale pasted "foldFoo" at http://paste.lisp.org/display/28894
20:16:23 <emu> can someone give me a hint bout how i go about giving a type to an array, say "newArray (0,1) True"?
20:16:29 <emu> MArray that is
20:16:44 <Cale> That's a good start, because you can then write something which replaces all the constructors with the same function, for instance
20:17:08 <chessguy> @type any
20:17:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:17:41 <desrt> that code is utterly confusing :)
20:18:10 <chessguy> @type any (`isPrefixOf` "foo")
20:18:12 <lambdabot> [[Char]] -> Bool
20:18:17 <desrt> foldFoo :: (t -> t -> t) -> (t -> t -> t) -> Foo -> t
20:18:26 <Cale> the idea is that you're supplying replacement functions for Thing and Other
20:18:35 <desrt> ya... i get it now
20:18:42 <chessguy> @type any (`isPrefixOf` "foo") ["bar","baz"]
20:18:43 <lambdabot> Bool
20:18:49 <desrt> it's really a tree convesion system
20:18:52 <desrt> *conversion
20:18:57 <Cale> yeah
20:19:11 <Cale> This is exactly what foldr does
20:19:17 <desrt> (foldFoo Foo Foo) :: Foo -> Foo
20:19:21 <desrt> erm
20:19:24 <Cale> and maybe, uncurry, either
20:19:27 <desrt> foldFoo Thing Other, rather
20:19:39 <Cale> right, that's the identity map
20:19:42 <desrt> nod.
20:20:14 <Cale> So I don't know, that may be insanely useful, or not. It tends to make evaluators easy to write :)
20:21:28 <desrt> the evil thing is that my type constructors take all sorts of weird differnet inputs
20:21:36 <desrt> they're not all Expr -> Expr -> Expr
20:21:47 <Cale> right, so the type of fold will be somewhat more insane
20:21:54 <desrt> so if i made a general containment datatype it wouldn't be able to contain them all
20:22:16 <Cale> You may even want to define a datastructure just for holding replacement constructors for the type :)
20:22:17 <desrt> like say i said i wanted to convert to (Const, [Args])
20:22:50 <desrt> even though i can have [Args] as a list, no problem... i can't store Const like that
20:23:10 <Cale> hmm
20:23:27 <desrt> unless i made wrappers for all my constructors that make them have the same type (where they ignore some arguments)
20:23:43 <desrt> actually.. that's not a horrible idea
20:23:51 <desrt> it's just so insanely hacky...
20:23:54 <Cale> nah, you just make the functions to pass to your fold have different types
20:24:08 <desrt> but they all need to return the same thing
20:24:21 <desrt> this is what i am saying
20:24:34 <Cale> yeah, they do, but they only act locally, and the functions you pass are free to ignore parts of their input
20:24:35 <desrt> this 't' and 'o' business is sort of pointless since i'd only ever call the fold once
20:24:47 <desrt> so i'd just hardcode them anyway
20:24:51 <Cale> Let me construct a more colourful example :)
20:25:25 <desrt> i'm saying... imagine something like
20:26:02 <desrt> Thing f1 f2 -> ((\(a, b, c, d, e) -> Thing a b), (f1, f2, 0, 0, 0))
20:26:21 <desrt> the the subterms in the right side are always contained in a 5-tuple and recursion over them is simple
20:26:45 <desrt> and reconstruction is trivial -- just pass to the subterm tuple to the first half of the big tuple
20:26:50 <lisppaste2> Cale annotated #28894 with "foldNature" at http://paste.lisp.org/display/28894#1
20:27:25 <Cale> that might be more illustrative of the general pattern :)
20:28:32 <desrt> this is just the exact same thing as total recursion, though
20:28:36 <desrt> i already have this :p
20:28:38 <Cale> heh
20:29:54 <desrt> interesting names, though :)
20:30:49 * desrt changes variables to rocks, abstractions to streams and applications to trees
20:31:05 <Cale> :)
20:31:38 <monochrom> This is not computer science.  This is scientology.
20:31:47 <desrt> ya.  this is certainly not powerful enough for what i want to do in my single-application case :(
20:31:51 <desrt> (although it would work for the other two)
20:32:03 <Cale> What does the single application case do?
20:32:15 <Cale> Search for a spot in the tree to apply a function?
20:32:18 <desrt> i give it a function Expr -> Maybe Expr
20:32:31 <desrt> returns Just Expr if a rule application succeeded
20:32:33 <desrt> else Nothing
20:32:39 <desrt> gets called on the top of the tree
20:32:45 <desrt> then on the left side node
20:32:47 <desrt> then on the left of that
20:32:48 <desrt> ...
20:32:51 <desrt> then on the right of the tree
20:32:52 <desrt> ...
20:33:05 <desrt> if it succeeds somewhere then the updated tree is reconstructed and returned
20:33:13 <desrt> if it always fails then Nothing is returned
20:33:18 <Cale> Couldn't you turn that into a total function Expr -> Expr by making it the identity when the rule doesn't apply, and then use your existing fold?
20:33:22 <Cale> oh
20:33:37 <desrt> then it would apply lots :)
20:33:41 <desrt> i want exactly 1
20:33:49 <Cale> ah, okay
20:34:00 <desrt> btw: i used to use == to decide if a rule application worked
20:34:03 <desrt> i got over that quickly :)
20:34:06 <Cale> :)
20:34:40 <desrt> i then use this single-step thing in a weird way
20:34:44 <desrt> i have a lot of very small functions
20:35:04 <desrt> addrule (Binary Addition (Value a) (Value b)) = Just $ Value $ a + b
20:35:04 <desrt> addrule _ = Nothing
20:35:14 <desrt> i make a list out of these
20:35:20 <desrt> then i try each thing in the list
20:36:12 <desrt> you may ask "If you use Addition with Binary like that, why can you do that for all binary expr constructors?"
20:36:17 <Cale> hmm, I think you can still do this with fold
20:36:19 <desrt> the answer: jacques is evil :)
20:36:47 <dons> ?users #haskell
20:36:47 <lambdabot> Maximum users seen in #haskell: 256, currently: 221 (86.3%), active: 23 (10.4%)
20:36:56 <desrt> i guess i could maybe do it if my return type contained (Expr, Maybe Expr)
20:37:04 <desrt> where the left side is the unmodified tree (incase i need it)
20:37:12 <desrt> and the right side is the Maybe modified tree
20:37:32 <Cale> yeah, something like that
20:37:38 <desrt> then my folders could choose
20:37:43 <Cale> Of course, you'll want to wrap this before actually using it :)
20:38:01 <desrt> well
20:38:04 <Cale> Or just (Expr, Bool)
20:38:06 <desrt> the problem is now that i have to write lots of folders
20:38:15 <desrt> no.  that's not good enough
20:38:24 <desrt> your approach evaluates the children before the parents
20:38:27 <kpreid> desrt: if you want a Big Hammer solution to your problem, use Data.Generics
20:38:30 <desrt> a child doesn't know the result of its sibling
20:38:44 <desrt> so it doesn't know if it should change itself or not
20:39:01 <Cale> mm, right
20:39:26 <desrt> anyway... writing lots of folders doesn't help
20:39:38 <desrt> since i'm still stuck with the case of having to write 'n' rules 3 times over
20:40:08 <Cale> Yeah, if it's really going to be that much of a pain, Data.Generic is the sledgehammer for you :)
20:40:26 <desrt> Could not find module `Data.Generic': it is not a module in the current program, or in any known package.
20:40:26 <Cale> Generics
20:40:30 <desrt> ah. right :)
20:40:43 <Cale> using it involves a little reading
20:40:47 <Cale> http://www.cs.vu.nl/boilerplate/
20:40:49 <lambdabot> Title: Scrap your boilerplate ... in Haskell
20:41:31 <desrt> {-# OPTIONS -fglasgow-exts #-}
20:41:33 <desrt> fear
20:42:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html <-- fear :)
20:42:12 <lambdabot> http://tinyurl.com/y6cr6c
20:42:20 <Cale> gfoldl :: (forall a b . Data a => c (a -> b) -> a -> c b) -> (forall g . g -> c g) -> a -> c a
20:42:39 <desrt> i don't think i've ever seen a forall nested like that
20:43:06 <Cale> It's a requirement that the parameter be completely polymorphic
20:43:23 <monochrom> 2nd rank polymorphism
20:44:19 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Schemes.html -- this is the more directly usable stuff
20:44:22 <lambdabot> http://tinyurl.com/y8ndor
20:44:36 <Cale> (well, the more likely to be easy to use stuff :)
20:44:36 <desrt> incS k (S s) = S (s * (1+k))
20:44:41 <desrt> so... uh
20:44:55 <desrt> heh.  this is so weird.
20:45:17 <kpreid> > everywhere (1 +) (1, [2, 3], Left 4)
20:45:18 <lambdabot>  Not in scope: `everywhere'
20:45:19 <desrt> mkT is magic, i guess
20:45:29 <Cale> somewhat :)
20:45:32 <kpreid> > Data.Generics.Schemes.everywhere (1 +) (1, [2, 3], Left 4)
20:45:33 <lambdabot>  Not in scope: `Data.Generics.Schemes.everywhere'
20:46:09 <desrt> this looks like exactly the hammer i want
20:46:11 <kpreid> @tell dons lambdabot + Data.Generics.Schemes?
20:46:11 <lambdabot> Consider it noted.
20:46:37 <Cale> well, that'll also run into trouble with polymorphism, no?
20:46:37 <emu> is there any good info on the ST monad
20:46:38 <desrt> sure that (1+) doesn't need mkT?
20:46:40 <kpreid> actually, that won't work, will it?
20:47:16 <desrt> what is mkt, anyway?
20:47:35 <Cale> it needs mkT
20:47:48 <desrt> still broken
20:47:58 <Cale> mkT is a function which generalises Prelude Data.Generics> :type mkT
20:47:58 <Cale> mkT :: (Typeable b, Typeable a) => (b -> b) -> a -> a
20:48:01 <desrt>     No instance for (Data.Generics.Basics.Data (a, [a1], Either a2 b))
20:48:21 <Cale> It's a sort of typesafe cast
20:48:37 <Cale> Where if the function doesn't apply at the type, it'll be the identity map
20:48:55 <Cale> But if it does apply to the type of thing passed, it'll do its job.
20:48:56 <kpreid> ah, works
20:49:13 <desrt> so if b = a then it'll work
20:49:21 <desrt> unless the function is missing a case
20:49:27 <desrt> at which point it'll act as if b!=a
20:49:29 <Cale> Prelude Data.Generics> everywhere (mkT ((1 :: Int) +)) (1, [2, 3], Left 4) :: (Int, [Int], Either Int Int)
20:49:29 <Cale> (2,[3,4],Left 5)
20:49:33 <kpreid> cale: mkT f a =?= cast . f . cast
20:49:41 <kpreid> er, without the a
20:49:47 <chessguy> is there an easier way to drop the first word of a string than foldr (++) "" (((drop 1) . words) s)
20:50:00 <desrt> this is pretty powerful koolaid
20:50:05 <chessguy> @pl foldr (++) "" (((drop 1) . words) s)
20:50:05 <lambdabot> foldr (++) [] (drop 1 (words s))
20:50:17 <kpreid> chessguy: uh, unwords . tail . words
20:50:30 <chessguy> heh. cool
20:50:30 <kpreid> chessguy: unless you really mean "" and not " "
20:50:35 <kpreid> also, drop 1 == tail
20:50:35 <Cale> mkT f = case cast f of Nothing -> id; Just g -> g
20:50:59 <kpreid> Cale: aha
20:51:09 <desrt> it still does not work for me
20:51:15 <monochrom> Nice to see the pointfree version has fewer parentheses!
20:51:25 <desrt> oh. nm.
20:51:27 <kpreid> I have the feeling I've needed mkT and not known it before...
20:52:03 <desrt> i had some bad brackets :)
20:52:21 <desrt> this is insanely powerful
20:52:34 <Cale> yeah :)
20:52:41 <Cale> While remaining typesafe :)
20:52:45 <desrt> like, woh.
20:52:52 <monochrom> Power doesn't corrupt you.  No no no.
20:53:02 <desrt> this is exactly what i want
20:53:13 <monochrom> Power makes you INSANE!  Absolute power makes you absolutely insane!
20:53:24 <desrt> well, maybe it isn't, actually... now that i think about it :)
20:53:30 <desrt> but it's still really really cool
20:53:30 * int-e waits for the flash of lightning, thunder and monochrom's maniacal laughter.
20:53:35 <Cale> Or maybe just absolutely inane
20:53:36 <monochrom> perhaps s/makes/drives/ is even better
20:53:50 <monochrom> bwahahhahahahaha...
20:54:00 * int-e cheers.
20:54:10 <desrt> thing is
20:54:26 <desrt> i need to apply at non-leaf nodes
20:54:46 <kpreid> desrt: Data.Generics has no idea what you consider a leaf
20:54:58 <Cale> desrt: everywhere isn't called everywhere for nothing :)
20:54:59 <desrt> lemme try something
20:55:43 <monochrom> @remember monochrom Power doesn't corrupt you. No no no. Power makes you INSANE! Absolute power makes you absolutely insane! BWAHAHAHAHAHA...
20:55:44 * kpreid realizes what the difference between everywhere and everywhere' is due to that
20:56:00 <monochrom> Yikes!  Forgot to s/make/drive/
20:57:14 <desrt> is there any way to get it to be more friendly about deriving types?
20:57:57 <lisppaste2> desrt pasted "for example..." at http://paste.lisp.org/display/28897
20:58:38 <desrt> i think it wants me to type commute like (int, int) -> (int, int)
20:59:21 <desrt> which then means it will fail to apply to, for example (int, (int, int))
21:02:38 <fons_> As I already said a few times in this channel, I'm trying to port LADSPA to Haskell.
21:03:04 * desrt gives up for now
21:03:12 <monochrom> Los Angeles Department of Safety and Protection of Animals?
21:03:24 <fons_> I'm making progress but I'm now stuck in a modelling problem
21:03:52 <fons_> monochrom, :) no, Linux Audio Developer's Simple Plugin API
21:03:57 <fons_> http://www.ladspa.org/
21:03:58 <lambdabot> Title: Linux Audio Developer's Simple Plugin API (LADSPA)
21:04:57 <fons_> I'm porting this C header file to Haskell http://www.ladspa.org/ladspa_sdk/ladspa.h.txt
21:05:13 <Cale> desrt: well, it's using the structure of the type to decide whether to apply your function, so it really does need lots of type signatures
21:05:17 <fons_> and the result so far is http://paste.lisp.org/display/28898
21:05:48 <desrt> Cale; right... but i was hoping that it could notice that (Int, (Int, Int)) is an instance of (a, b)
21:05:50 <fons_> My problem now is class LadspaSource id hd where descriptors :: [Descriptor id hd
21:05:57 <fons_> ops
21:06:14 <fons_> class LadspaSource id hd where descriptors :: [Descriptor id hd]
21:06:26 <Cale> desrt: yeah, unfortunately, I don't think it really knows too much about polymorphic types
21:07:10 <dons> ah where we go, http://programming.reddit.com/info/o96l/comments
21:07:10 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:07:13 <lambdabot> Title: Ask Reddit: OCaml or Haskell? (reddit.com), http://tinyurl.com/y68y79
21:07:21 <dons> people actually want an opinion on this?
21:07:35 <fons_> because a Ladspa source should support descriptors with different id and hd types
21:08:42 <fons_> (a heterogeneous list of Descriptor id hd, with different ids and hds)
21:09:01 <monochrom> Ah!  But heterogeneous list is difficult.
21:10:50 <fons_> monochrom, Yes I know, I'm trying to change the design so that heterogeneous lists wouldn't be required, but I don't find a way
21:11:52 <fons_> monochrom, in the header file the Implementation and handle data are made "heterogeneous" by using void*
21:12:04 <dolio> I didn't realize that most people code in Haskell/Ocaml just to prove that things can be coded in them.
21:12:19 <monochrom> heh heh heh
21:12:31 <dolio> As opposed to the many, many Scheme applications.
21:12:47 <fons_> I don't find a way to model it properly
21:13:02 <fons_> :(
21:13:47 <monochrom> Though they are void*, there are only finitely many possibilities, aren't there?
21:14:54 <lisppaste2> emu pasted "IOArray -- what am I doing wrong" at http://paste.lisp.org/display/28899
21:15:25 <dolio> ?type freeze
21:15:26 <lambdabot> Not in scope: `freeze'
21:15:31 <fons_> monochrom, infinite possibilities
21:15:56 <monochrom> Darn.  Need existential type or equivalent.
21:16:00 <emu> freeze :: (Data.Array.Base.IArray b e, MArray a e m, Ix i) =>
21:16:00 <emu> a i e -> m (b i e)
21:16:20 <dolio> emu: type ex1
21:16:47 <emu> ?
21:16:49 <monochrom> What is the type of arr?
21:16:56 <monochrom> ex1 already has a fine type.
21:17:18 <dolio> ex1 has a type IO (a i e), so you have to get a i e before you can freeze it.
21:17:46 <emu> but being in the IO monad, don't i have that?
21:17:47 <monochrom> ex1 is manually given type IO (IOArray Int Int)  see line 5
21:18:06 <monochrom> arr is the one needing a manual type
21:18:14 <int-e> emu: no, you still try to freeze an IO action.
21:18:20 <fons_> monochrom, I tried to model the heterogeneous list with existentially quantified type parameters but it doesn't work
21:18:49 <monochrom> Oh haha int-e's right too.
21:18:57 <dolio> 'arr <- freeze =<< ex1' or something like that.
21:19:22 <fons_> monochrom, you mean something like type DescriptorH = forall id hd. DescriptorH (Descriptor id hd) ?
21:19:35 <monochrom> OK all of you are right.
21:20:10 <int-e> @type ap
21:20:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:20:32 <fons_> the thing is there is no way to work with the Descriptors once they are locked in the existentially typed DescriptorH
21:20:41 <monochrom> The void* is invariably casted to some struct of functions, is that right?
21:21:16 <emu> ugh
21:21:28 <int-e> emu: fwiw, I'd probably write the whole main as  ex1 >>= freeze >>= print
21:21:52 <Cale> fons_: well, what things do you need to do with them? It helps to pack those in the existential type with them
21:21:56 <dolio> Or freeze in ex1 instead of returning, depending on what you're doing.
21:22:08 <fons_> monochrom, no, not really it is going to be casted to whatever the plugin preogrammer wants to (it is used as a way to model _any_ callback handler)
21:22:29 <emu>   No instance for (Show (b Int Int))
21:23:02 <int-e> oh.
21:23:25 <fons_> Cale, what do you exactly mean by  "them"? the "void *" handlers?
21:23:26 <int-e> right, arrays are polymorphic to a fault.
21:24:29 <dolio> IOArrays don't appear to be showable, based on the docs.
21:24:51 * desrt slowly gets better
21:25:07 <lisppaste2> monochrom annotated #28899 with "first improvement" at http://paste.lisp.org/display/28899#1
21:25:31 <int-e> I have:  boxed :: Array i e -> Array i e; boxed = id.  then I can use   ex1 >>= liftM boxed freeze >>= print
21:25:38 <desrt> i guess i could use an eta conversion rule...
21:26:23 <emu> hmm
21:26:26 <int-e> the sole purpose of 'boxed' being to guide the type checker with picking the right type.
21:26:29 <emu> yea
21:26:47 <int-e> (I also have 'unboxed' with type UArray i e -> UArray i e)
21:26:56 <desrt> eta_conversion (Abstraction v (Application f (Variable u))) | v == u = Just f
21:27:05 <desrt> i guess that's it?
21:27:13 <emu> well mono's version works
21:28:15 <desrt> oh crap.  x could be free in f.
21:28:16 <desrt> bah!
21:28:28 <fons_> Cale, can you try to explain what you said a bit more?
21:28:39 <int-e> emu: anyway I think this works better than type annotations.
21:28:45 <fons_> Cale, regarding the existential types
21:29:13 <monochrom> Well you have type annotation for your boxed.  Can you eliminate that?
21:29:15 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
21:29:18 <lambdabot> Title: Existentially quantified record constructors - The Haskell Wiki, http://tinyurl.com/y29ory
21:29:27 <Cale> that's a good example to look at
21:29:45 <Cale> the record syntax only works in GHC 6.6, but the idea's the same without that syntax
21:30:15 <int-e> monochrom: I have that once, in an external module.
21:30:43 <monochrom> Good for you.  Can you get it into GHC so everyone will get it? :)
21:30:46 <Cale> It's like in OO, where you have methods acting on an object.
21:31:33 <emu> ex1 >>= freeze >>= print . boxed
21:32:00 <emu> or liftM boxed . freeze
21:32:13 <int-e> aha.
21:32:17 <int-e> right.
21:32:45 <monochrom> A related problem is thoroughly discussed at http://www.vex.net/~trebla/haskell/annote-STArray.html
21:32:49 <lambdabot> Title: How to annotate STArray types?, http://tinyurl.com/gmrt9
21:33:06 <emu> now to put an MArray in the State monad !
21:33:51 <Cale> fons_: is that sufficiently illustrative?
21:34:09 <fons_> Cale, thanks, you mean then I should you existentially quantify the parameters of my currently  "Descriptor hd id" type
21:34:12 <int-e> monochrom: http://int-e.home.tlink.de/haskell/ArrayM.hs ... hmm. seemed to small to seriously pursue getting it into ghc.
21:34:18 <fons_> right?
21:34:44 <Cale> fons_: I mean, if you need a homogeneous list of things, then you have to first decide what operations you want to be valid
21:35:04 <Cale> fons_: You can then wrap those operations up with the values in existential datastructures
21:35:16 <Cale> If it's more convenient, you can even use a typeclass for this
21:35:26 <mbishop> dons: I see you found my reddit topic
21:36:03 <Cale> But you have to decide on the operations beforehand -- you're throwing away type information in order to put those different things into a list, so you have to decide what operations are going to be valid for those things when they come out
21:36:43 <Cale> Note that in the example on that page, counterA and counterB are the same type, and so you could cram both into a list
21:37:12 <dons> mbishop: yeah. i'm not 100% convinced its a good idea to have such a topic, but oh well :)
21:37:29 <Cale> Even though one operates with an integer, and the other a string
21:37:36 <fons_> Cale, how could I model it as a typeclass? There are constructor arguments which don't depend on the type parameters
21:37:45 <dons> mbishop: have you met the lambdabot?
21:37:51 <dons> > map (^2) [1..]
21:37:52 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
21:38:28 <dons> mbishop: you really tossing up which one to use for some project?
21:38:48 <Cale> fons_: well, first off, you're putting a bunch of descriptors of different types into a list -- what operations on those descriptors are independent of the type parameters to Descriptor?
21:38:48 <monochrom> I say, use Haskell.  I'm biased.
21:38:48 <fons_> Cale,  http://paste.lisp.org/display/28898 the type is "Descriptor id hd"
21:39:16 <dons> we've got a lot of ex-ocaml guys in here. maybe they have some perspective.
21:39:20 <dons> vincenz, et al?
21:39:37 <fons_> Cale, for example uniqueID, label ....
21:39:41 <Cale> aha, look at that, it's almost ready to be existentialised already :)
21:41:05 <Cale> hmm, the instantiate record is a little interesting
21:41:11 <Cale> what does it do?
21:41:22 <fons_> Cale, the operations I want to be able to obtain once I get them out of the list are activate, run, implementationData ....
21:41:43 <dons> for those of you not following, mbishop posted http://programming.reddit.com/info/o96l/comments recently.
21:41:45 <lambdabot> Title: Ask Reddit: OCaml or Haskell? (reddit.com), http://tinyurl.com/y68y79
21:43:35 <fons_> Cale, It obtains the intial instance (given by its initial handler) of a plugin, the numeric value is the sample rate at which the plugin should operate
21:43:56 <dons> Cale: btw, did you want to make a proper suggestion to get, (@@) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)
21:43:59 <dons> , back in?
21:44:08 <Cale> dons: hm?
21:44:15 <dons> in which case, you'll need to create the darcs patch
21:44:22 <monochrom> I'm partly ex-Ocaml.
21:44:40 <Cale> dons: Oh, right. I don't have the fptools repo, which makes it annoying for me :)
21:44:48 <Cale> I should probably get that.
21:44:51 <dons> darcs get!
21:45:01 <dons> otherwise, the suggestion will fail
21:45:03 <Cale> Let me type up an idea for fons
21:45:11 <Cale> lisppaste2: url
21:45:12 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
21:45:12 <fons_> Cale, (BTW, how would you model Descriptor id hd as a type class? because as I said I have no idea about how to solve the problem with operations which are independent of the type parameters  )
21:46:01 <fons_> Cale, I really appreciate your help :)
21:47:19 <mbishop> dons: no, not for a particular project, just started learning both, and was torn, I originally learned haskell and liked it, but some of it's syntax put me off, then I learned a bit of SML, and then OCaml, but some if it's syntax also put me off, as well as a few of it's limitations, and I think I've changed my opinion (in the post, I was favoring OCaml a little), and I thnk I'll just learn Haskell until I have a nee
21:47:19 <mbishop> d/want to learn OCaml
21:48:56 <dons> I think you'll get 90% of OCaml for free, if you learn Haskell, plus a lot of extra things. Then picking up some OCaml to get a feel for functors and modules would be useful, I'd imagine.C[C[C[C[C[C[C[C[C[C[C[C[C
21:49:01 <lisppaste2> Cale pasted "objects" at http://paste.lisp.org/display/28900
21:49:27 <Cale> something like that perhaps
21:49:37 <Cale> no typeclasses there
21:49:51 <Cale> but in your case, I think it's more natural to work things like that
21:50:04 <dons> mbishop: feel free to hang out here, too! we love to help motivated people learn functional programming
21:51:11 <Cale> fons_: you may not even need the self parameter there, you might even just be able to provide a record with the appropriate actions
21:52:07 <fons_> thanks Cale
21:52:12 <fons_> :)
21:52:19 <Cale> also, does instantiate really need that extra Descriptor, or can it work with the current one?
21:52:26 <Cale> This code will only work in GHC 6.6
21:53:14 <fons_> Cale, it can work with the current one
21:53:47 <Cale> The current GHC is 6.6. I don't think 6.4 allows this syntax
21:54:44 <fons_> Cale, I meant the Descriptor
21:55:27 <Cale> Yeah, this is an existentially quantified record constructor, which I don't think 6.4 had the syntax for, but if it works, then great :)
21:56:23 <Cale> fons_: also look carefully at instantiate -- does it really need that extra Descriptor parameter, or would it use the object it came from?
21:57:06 <fons_> Cale, thats wha I mean, I think I can just use the object where it came
21:57:12 <Cale> yeah
21:57:28 <Cale> You might not even need implementationData :)
21:59:28 <dons> ?users #haskell.jp
21:59:29 <lambdabot> Maximum users seen in #haskell.jp: 3, currently: 2 (66.7%), active: 0 (0.0%)
21:59:53 <fons_> Cale, I dont understand why did you divide the record in two
22:00:30 <fons_> Cale, that makes it much more difficult for the marshalling
22:00:39 <Cale> hmm
22:01:22 <Cale> The idea here is to eliminate the type parameters because if they vary, then you won't be able to stick these things into lists
22:01:48 <Cale> So the trick is to decide on all the operations you want, and build them into datastructures.
22:02:03 <fons_> but you might as well have used, "forall id hd ."
22:02:17 <fons_> keeping all of them in the same record
22:02:56 <Cale> What is instantiate supposed to return then?
22:03:10 <Cale> It can't return something of type hd.
22:03:27 <desrt> *Main> evaluate (Application (Abstraction "x" (Abstraction "z" (Variable "x"))) (Variable "z"))
22:03:30 <desrt> Abstraction "a" (Variable "z")
22:03:31 <desrt> eat my alpha conversion.
22:03:40 <fons_> Cale, that's what it is supposed to reaturn
22:03:44 <fons_> return
22:04:06 <Cale> fons_: right, but if hd was existentially quantified there, it wouldn't be allowed to return that
22:04:36 <fons_> Cale, please see http://www.ladspa.org/ladspa_sdk/ladspa.h.txt
22:05:16 <sjanssen> @pl \x -> f x >>= g
22:05:17 <lambdabot> (g =<<) . f
22:05:30 <fons_> Cale, and ... why did you remove the type parameters in the operations?
22:05:59 <Cale> fons_: because this would make a list of these things all have the same type
22:06:43 <Cale> note that the types id and hd are being forgotten when a value of type Descriptor is being built. That ensures that all descriptors can be treated as values of the same type.
22:07:16 <Cale> You could decide to keep them, but then you can't have a list of Descriptors, like I think was what you wanted originally?
22:07:43 <Cale> (with different id and hd's)
22:07:47 <Smokey`> dons: what's youre opinion on http://www.algorithm.com.au/mt/haskell/haskells_performance.html ?
22:07:50 <lambdabot> Title: &Lambda;lgorithm.com.au: Haskell's Performance, http://tinyurl.com/yeygt3
22:08:09 <fons_> Cale, I got that ... but in the example you gave methey  don't remove the parameters in the operations ( http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors )
22:08:11 <lambdabot> Title: Existentially quantified record constructors - The Haskell Wiki, http://tinyurl.com/y29ory
22:08:25 <fons_>  _inc     :: self -> self
22:08:50 <Cale> Smokey`: my opinion is that Data.ByteString didn't exist when that was written and things have changed significantly
22:09:05 <Smokey`> fair enough :)
22:09:34 <Smokey`> just thought I'd get some feedback, and general updates on what's happened (if anything) in relation to (atleast, GHC) since that time
22:10:37 <Cale> fons_: that's okay -- in fact, you might be able to get away without existentials altogether
22:10:50 <sjanssen> Smokey`: there are good points here and there
22:11:13 * fons_ is confused
22:11:21 <sjanssen> for example, understanding space use /is/ tricky, you could say it's Haskell's dirty little secret
22:11:24 <fons_> Cale, how?
22:12:02 <Cale> fons_: by just putting the relevant data into the operations which you're wrapping up when you build objects of that type
22:12:24 <Cale> Just completely hide the id and hd values inside the functions there
22:12:43 <Cale> so that what type they really are doesn't matter from the outside
22:13:57 <desrt> i guess i should learn parsec or something....
22:14:01 <dons> Smokey`: ozone wrote that quite a while ago. things have changed a lot since then. i.e. http://www.algorithm.com.au/mt/haskell/a_history_of_haskell_commentary.html#000262  "Data.ByteString library has pretty much nailed the performance gap between Haskell and C for string processing and binary I/O, which is one area where Haskell was notoriously weak at."
22:14:03 <lambdabot> Title: Algorithm.com.au: A History of Haskell Commentary, http://tinyurl.com/ykwcfg
22:14:15 <Cale> Smokey`: actually, I don't find understanding space use to be all that much worse than understanding space use in other languages. It's understanding how evaluation proceeds which people don't get, I think. Once you get that, space use is actually not so bad, I don't think.
22:14:29 <dons> so next time you see ozone, bug him about putting out so much FUD ;)
22:14:32 <dons> ?seen ozone
22:14:32 <lambdabot> ozone is in #haskell. I don't know when ozone last spoke.
22:14:50 <Cale> maybe an @tell ?
22:14:53 <Cale> :)
22:15:25 <desrt> @tell cale yr dumb
22:15:26 <lambdabot> Consider it noted.
22:15:31 <desrt> he he he!
22:15:35 <Cale> hello lambdabot
22:15:36 <dons> @tell ozone bad ozone! fud lives on forever on the internets... http://www.algorithm.com.au/mt/haskell/haskells_performance.html#000155 ;)
22:15:37 <lambdabot> Consider it noted.
22:15:46 <ThreeQ> why are existential types called existential types?
22:15:50 <desrt> @tell desrt about parsec
22:15:51 <lambdabot> You can tell yourself!
22:15:54 <dons> (i work with ozone, so i'll just throw some things at him next time i see him)
22:15:56 <desrt> no i can't :(
22:16:23 * Smokey` nods at dons and Cale.
22:16:42 <desrt> Cale; did you cut your hair?
22:16:45 <Cale> Smokey`: we're even beating C at trivial programs
22:16:57 <Smokey`> Well it's official, as of next fortnight, I'll have 3 months spare time for my personal proejcts (a.k.a. learning haskell inside-out, and continuing my C++ projects)
22:16:58 <Cale> desrt: yeah, to shoulder-length :)
22:17:02 <Smokey`> Cale: excellent :D
22:17:04 <desrt> Cale; did you shave?
22:17:28 <Smokey`> hence the looking up on trivial Haskell issues?
22:17:32 <Cale> desrt: I still have the beard, try to keep it cleaned up. :)
22:17:38 <desrt> heh
22:17:39 <desrt> got a pic?
22:17:42 <dons> Smokey`: cool!
22:17:43 <Cale> nope
22:17:47 <desrt> bah
22:17:56 <dons> Smokey`: in 3 months you can do anything!
22:18:19 <Smokey`> dons: indeed :)  (although I'm sharing that time, with another, rather large C++ program... that I'm doing with some mates)
22:18:31 * desrt pulls out some code from last time he tried to implement a lambda calculus parser in parsec
22:18:39 <Smokey`> either way, it should be a fun learning experience :)  I hope to get alot out of it, in relation to how I understand Haskell
22:18:41 <Cale> I'm not letting one of those newfangled camera things steal my nonexistent soul. :)
22:18:57 <Cale> (actually, it's just that my dad's digital camera broke)
22:18:58 * desrt collects souls
22:19:33 <Cale> ThreeQ: It's because there exists some appropriate type parameter for each value of of the existential type
22:19:44 <dons> 3 months you could do a complete advced functional programming course online...
22:19:49 <dons> including writing a mini haskell compiler
22:19:59 <dons> so perhaps come up with some structured plan for learing?
22:20:07 <dons> learning? i.e. using one of the online APF courses?
22:20:15 <dons> AFP. grr
22:22:34 <desrt> is implementing interfaces for haskell types still completely and entirely evil?
22:23:13 <monochrom> completely and entirely elegant
22:23:19 <dons> interfaces via typeclasses and existentials?
22:23:31 <dons> or just typeclasses?
22:23:32 <desrt> like if i want to write a 'show' for my data type
22:23:55 <desrt> ie: instance
22:23:55 <dons> you derive Show, or else write an instance Show MyType where show x = "how I show it"
22:24:08 <desrt> right.  i know how to do that :p
22:24:12 <desrt> that's totally evil :)
22:24:16 <dons> it is?
22:24:25 <monochrom> I don't understand!
22:24:33 <desrt> it's not bound to the datatype declaration
22:24:42 <desrt> you can just write it anywhere
22:25:03 * dons waits for desrts paper on "Making 'Ad Hoc Polymorphism Less Ad Hoc' ... Even Less Ad Hoc"
22:25:18 <desrt> :)
22:25:27 <desrt> i guess the 'ad hoc' is a good thing?
22:25:28 <int-e> with least fixed points?
22:25:49 <int-e> 'ad hoc' is a nightmare when spiced with curry.
22:25:56 <desrt> man
22:26:07 <desrt> i'd kill for some basmati flavoured in some nice way
22:26:37 <dons> hmm. I can imagine a whole field of haskell projects with 'curry' and indian food metaphors
22:26:57 <dons> in their name.
22:27:17 <desrt> i wanted to call this project that we're working on at school 'basmati'
22:27:20 <desrt> but nobody understood :(
22:27:59 <psykotic> dons: we need syntactic curry, not sugar!
22:28:40 <desrt> deciding where to put ()s in a pretty printer is confusing
22:28:53 <psykotic> desrt, there's a simple approach to unparsing if you have a precedence table.
22:29:08 <psykotic> i'm assuming you're talking about not wanting to overparenthesize
22:29:16 <desrt> ya
22:29:28 <desrt> i'm not even sure what my precedence is, though :)
22:29:37 <monochrom> showsPrec helps a little.  There is an idiom that helps the rest.
22:35:30 <dons> mbishop: so you've got ghc installed? and perhaps starting with YAHT?
22:35:35 <dons> ?where yaht
22:35:35 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
22:35:37 <desrt> (/x.(4 + (x * 2))) (2)
22:35:42 <desrt> eh.  not _too_ bad.
22:36:45 <psykotic> desrt, once you start getting deeply nested lambda terms the overparenthesization can really screw up the readability.
22:36:51 <desrt> ya
22:36:57 <desrt> i'm looking at this now: http://paste.lisp.org/display/27575
22:38:11 <dmead> haskell needs type destructors i think
22:38:24 <psykotic> desrt, btw you can work out the algorithm i hinted at very easily by just looking at some specific examples involving + and * and inferring the general structure.
22:38:25 <dmead> someone get on that
22:38:53 <fons_> Cale, Ok, I think I get your paste now, but still I don't understand why for example cleanup changed from cleanup                :: hd -> IO () to IO(), how could cleanup be implemented then?
22:39:33 <dmead> hmmm
22:39:43 <dmead> desrt
22:39:54 <desrt> hm?
22:39:54 <monochrom> type destructor is pattern matching
22:40:00 <dmead> i'm working on logic stuff too
22:40:11 <desrt> i'm not
22:40:11 <dmead> doin a theorem prover for prefix and infix
22:40:13 <dmead> oh
22:40:17 <desrt> :)
22:40:23 <desrt> this is from someone else
22:40:25 <dmead> ah
22:40:29 <desrt> showing how to do a pretty printer
22:40:32 <dmead> gotcha
22:40:43 <dmead> yea overload the show func
22:40:43 <psykotic> monochrom, deconstruction = destruction eh?
22:40:58 <desrt> it's not really an overload so much as an instance
22:41:32 <dmead> oh right
22:41:47 <dmead> i guess it's the show function thats actually overloaded
22:41:54 <dmead> the ShowS class gets a new instance
22:41:58 <dmead> or something like that
23:00:11 <brad____> hi
23:00:39 <brad____> can anyone help me with a newbie-ish question?
23:01:00 <Lemmih> brad____: Sure.
23:01:15 <brad____> thanks - i will try to format it to be readable here
23:01:40 <brad____> say i have a main function like main = do { s <- readFile myfile; }
23:02:01 <brad____> readFile takes a FilePAth and returns an IO String
23:02:24 <brad____> but then i am able to use s in the main {} function in other functions that just take type String
23:02:42 <brad____> is this because the IO monad is assumed within main?
23:02:50 <brad____> maybe i am not even asking the question correctly
23:03:01 <psykotic> yes. s <- readFile myfile "unwraps" the IO part of the type
23:03:32 <brad____> ah thanks
23:03:45 <brad____> by the way, are you the psykotic who frequents reddit?
23:03:49 <psykotic> yeah
23:03:55 <brad____> wow, esteemed company
23:04:03 <brad____> i enjoy your reddit comments
23:04:03 <psykotic> hah, not really.
23:04:26 <brad____> one more question
23:04:31 <dons> yeah, main = do s <- readFile "f" ; print (map toUpper s) -- for example
23:04:51 <brad____> there is another familliar name from reddit - dons. high class crowd here!
23:04:53 <dons> once you've performed the IO action, you get back a normal value which can be passed to pure code.
23:04:56 <dons> hey
23:05:06 <psykotic> and that's dons, who trolls reddit with haskell pimpage :)
23:05:19 <dons> I try not to troll, I hope.
23:05:22 <psykotic> the dons and cale tagteam!
23:05:26 <psykotic> dons: i'm just kidding :)
23:05:30 <dons> I just don't comment much on non-FP stuff :)
23:05:40 <brad____> dons - i find you posts on reddit to be super insightful and helpful
23:05:50 <dons> oh, thank you :)
23:05:58 <dons> welcome to #haskell!
23:05:58 <brad____> i also like the qwe troll.
23:06:02 <dons> home of the lambdabot!
23:06:10 <dons> > map (^2) [1..]
23:06:12 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
23:06:16 <psykotic> qwe is... interesting.
23:06:38 <desrt> (\x -> 4 + x * 2) 2
23:06:40 <desrt> better!
23:06:49 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
23:06:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:07:07 <dons> psykotic: yeah, qwe is an odd one.
23:07:20 <brad____> dons, psykotic - is there a way in haskell to just dump the type of a vlaue? something like 'ref' in perl?
23:07:33 <dons> using ghci, you can infer the type.
23:07:39 <dons> ?type fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
23:07:41 <lambdabot> forall a. (Num a) => [a]
23:07:49 <dons> (which is :t in ghci, or hugs)
23:08:14 <dons> but types are erased at runtime, remember, so there's no simple way to get a type at runtime
23:08:20 <brad____> are you telling me that i can apply ghci's :t to values as well as funcs?
23:08:30 <dons> hmm. what are you trying to do?
23:08:50 <brad____> well lets say for the 's' in my example above, lets just say i wanted to see its type
23:08:52 <dons> (remember, there's no types left at runtime, so you can't get at them at runtime)
23:09:14 <brad____> emacs helps quite a bit with function completion, so i do see those while i am editing.
23:09:38 <brad____> ah, that is true about no types left at runtime. i forget that some times
23:09:49 <dons> when exploring code, you'd generally enter the fragment into ghci, to find out information about it
23:09:58 <dons> ?type readFile
23:09:59 <lambdabot> FilePath -> IO String
23:10:09 <dons> ?type do s <- readFile "f" ; return s
23:10:11 <lambdabot> IO String
23:10:15 <dons> and so on
23:11:06 <brad____> dons - i just tried '?type readFile' at a ghci prompt and got an error
23:11:13 <psykotic> use :t readFile
23:11:22 <psykotic> ?type is a lambdabot thing
23:11:24 <lambdabot> Not in scope: `is'
23:11:24 <lambdabot>  
23:11:24 <lambdabot> <interactive>:1:3: Not in scope: `a'
23:11:28 <dons> yeah, :type in ghci, ?type in lambdabot
23:11:28 <psykotic> :)
23:11:32 <dons> ?hoogle readFile
23:11:33 <lambdabot> Prelude.readFile :: FilePath -> IO String
23:11:33 <lambdabot> System.Win32.File.c_ReadFile :: HANDLE -> Ptr a -> DWORD -> Ptr DWORD -> LPOVERLAPPED -> IO Bool
23:11:33 <lambdabot> System.Win32.File.win32_ReadFile :: HANDLE -> Ptr a -> DWORD -> Maybe LPOVERLAPPED -> IO DWORD
23:11:46 <brad____> ah. well, this is why i am a newbit
23:11:51 <dons> :)
23:12:10 <brad____> i have been using hoogle too, shortcut it to 'h' in elinks and ff
23:12:14 <psykotic> oh no, phantom types! run!
23:12:23 <dons> brad____: heh. cool.
23:12:58 <brad____> well thanks so much dons and psykotic. very helpful. hope to see ghc 6.6 optimized code in the shootout soon!
23:13:04 <dons> me too!
23:13:28 <dons> I think 6.6 is in gentoo now, so shouldn't be too long
23:13:41 <brad____> i hope it makes it for the debian etch release
23:13:50 <brad____> i know john goerzen is involved with that
23:14:13 <dons> yeah, we've got a few guys who work on debian. Igloo would know the details
23:14:31 <dons> ?seen Igloo
23:14:32 <lambdabot> Igloo is in #darcs and #haskell. I last heard Igloo speak 4h 42m 41s ago.
23:14:37 <dons> ah sleeping
23:14:41 <brad____> i built 6.6 and missingh for my box, as well as pugs
23:14:56 <brad____> on my laptop (p3, 256mb), it only took a day or so!
23:15:00 <dons> heh.
23:15:11 <brad____> i came to haskell via pugs
23:15:23 <dons> how long does pugs take to build these days? it's getting quite big, isn't it?
23:15:37 <Bobstopper> dons: I heard hs-plugins had some initial trouble with ghc 6.6. Does it work yet?
23:15:38 <brad____> pugs takes as long as ghc as far as i can tell
23:15:40 <dons> yeah, pugs has been a bit of a gateway drug to hardcore lambdas
23:16:04 <brad____> we were told by audrey that pugs will soon demand ghc 6.6
23:16:06 <dons> oh, wow. i guess they really crank up the optimisations (and there's a lot of bytestrings, where the rewrite rules take their time)
23:16:24 <brad____> so i had to build it myself, normally i would just take what debian gives me
23:16:26 <dons> Bobstopper: not yet. on the todo list. the .hi format changed
23:16:45 <Bobstopper> Oh I see. Thanks.
23:17:04 <dons> yeah. pugs is a lot faster under 6.6 , and you get SMP too
23:17:05 <brad____> but pugs is pretty amazing, worth the effort to build it
23:17:10 <dons> yeah
23:17:22 <brad____> audrey basically salvaged perl6
23:17:48 <dons> true! nothing like producing lots of working code to help a project along :)
23:18:11 <brad____> although i try not to get too deep into it when i see larry wall saying in irc comments that he is changing basic syntax all the time
23:18:20 <brad____> too much of a moving target right now
23:19:04 <brad____> anyway not to turn this into a perl forum
23:19:37 <dons> heh
23:19:51 <brad____> well thanks again, the haskell community rocks, i will keep pluggin away
23:19:54 <brad____> goodnight
23:19:57 <dons> cheers!
