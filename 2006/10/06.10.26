00:00:02 <xerox> dons: I'll try to get DiBona interested in Haskell EVEN MORE ;)
00:00:04 <kzm> x3m: was that what you're looking for?
00:00:17 * kzm got a Google tee shirt!
00:00:20 <sieni> kzm: you have to also check x^2 + (x+1)^2 + (x+2)^2 etc
00:00:41 <kzm> sieni, ah, I see.  I thought it was just two consecutive squares.
00:00:55 <sieni> kzm: me too, before I looked at the C++ code
00:00:59 <x3m> kzm: not really, just intrested how a solution to it would look in haskell
00:01:17 <dons> kzm, like this, http://cgi.cse.unsw.edu.au/~dons/blog/2006/10/19#tshirt ?
00:01:18 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/yndavz
00:01:31 <dons> xerox: well, i'm not sure how much DiBona knows about haskell?
00:02:31 <xerox> dons: the first yeah I asked him in chat whether Haskell project had any chance to get selected, he told me they were interested, and then Google mentored me!
00:02:35 <kzm> dons: yup!  (Even if I didn't mentor.  If it's a mistake, don't tell anybody.)
00:02:57 <dons> kzm, no. everyone who volunteered to mentor got a tshirt
00:03:07 <dons> xerox: ah good.
00:03:20 <kzm> > let isPalindrome x = show x == reverse (show x) in filter isPalindrome [11,12,13,212]
00:03:21 <lambdabot>  [11,212]
00:03:33 <xerox> dons: yeah, I want to see if there's space for development.
00:03:43 <kzm> > pl \x -> show x == reverse (show x)
00:03:44 <lambdabot>  Parse error
00:03:51 <kzm> @pl \x -> show x == reverse (show x)
00:03:52 <lambdabot> liftM2 (==) show (reverse . show)
00:05:46 <dolio> http://haskell.org/haskellwiki/Haskell_Quiz/The_Solitaire_Cipher
00:05:50 <lambdabot> Title: Haskell Quiz/The Solitaire Cipher - HaskellWiki, http://tinyurl.com/yco9pp
00:07:18 <dons> dolio++
00:07:38 <dons> so I see some room for shrinking that a bit
00:07:45 <kzm> x3m, how about:  let isPal x = show x == reverse (show x) in filter isPal [ sum (map (^2) [x..y]) | x <- [0..10^4], y <- [x..10^4]]
00:07:51 <dons> its nice and clear
00:08:00 <kzm> could probably be more efficient, though :-)
00:10:18 <dolio> It might be possible to carve up the lists more elegantly. Some of the operations it has you do are a bit weird, though.
00:10:34 <x3m> > let isPal x = show x == reverse (show x) in filter isPal [ sum (map (^2) [x..y]) | x <- [0..10^4], y <- [x..10^4]]
00:10:38 <lambdabot> Terminated
00:10:43 <x3m> heh
00:10:50 <kzm> > let isPal x = show x == reverse (show x) in filter isPal [ sum (map (^2) [x..y]) | x <- [0..100], y <- [x..100]]
00:10:52 <lambdabot>  [0,1,5,55,1,5,55,4,505,818,42924,9,77,636,1001,1771,595,1441,181,17371,121,4...
00:11:00 <kzm> Limited CPU usage on the 'bot.
00:11:08 <dolio> Shuffle could be shorter too if you use sort instead of picking random elements, but I implemented it similar to the ruby solution.
00:11:18 <xerox> dons: without counting they've called back us to be an org, as Haskell.org! :)
00:11:33 <dolio> Although it's probably more efficient with ruby's arrays than lists, so sort might actually be better.
00:11:51 <x3m> kzm: you dublicate numbers there
00:12:27 <kzm> Right - but they (should?) represent different factorings I think.
00:13:53 <kzm> Oh, right - that's because I start with 0.  Same result as 1.
00:14:02 <kzm> > let isPal x = show x == reverse (show x) in filter isPal [ sum (map (^2) [x..y]) | x <- [1..100], y <- [x..100]]
00:14:04 <lambdabot>  [1,5,55,4,505,818,42924,9,77,636,1001,1771,595,1441,181,17371,121,434,1111,1...
00:14:09 <x3m> kzm: still not right, you need have consecutive squares, that is more than 1 square. so 3^2 = 9 is not ok, but 1^2+2^2 = 5 is ok
00:14:22 <kzm> > let isPal x = show x == reverse (show x) in filter isPal [ sum (map (^2) [x..y]) | x <- [1..100], y <- [x+1..100]]
00:14:24 <lambdabot>  [5,55,505,818,42924,77,636,1001,1771,595,1441,181,17371,434,1111,148841,313,...
00:14:28 <kzm> Okay?
00:14:30 <int-e> yes, that's a silly convention this challenge has
00:14:43 <kzm> > let isPal x = show x == reverse (show x) in filter isPal [ sum (map (^2) [x..y]) | x <- [1..100], y <- [x+1..x+10]]
00:14:46 <lambdabot>  [5,55,505,77,636,1001,595,1441,181,434,1111,313,545,6446,4334,19691,44444,51...
00:15:05 <kzm> (since you won't get a palindromic number when it ends with a 0)
00:15:13 <x3m> kzm: try to sort that also
00:15:18 <kzm> Suddenly, it's O(n) instead of O(n^2)
00:15:22 <int-e> map (scanl (+) 0) $ tails [n^2 | n <- [1..10^4]]   is a fun basic idea
00:15:41 <kzm> int-e, nice!
00:16:26 <x3m> kzm: if you sort that list i can check if its correct
00:16:27 <kzm> > let isPal x = show x == reverse (show x) in sort $ filter isPal [ sum (map (^2) [x..y]) | x <- [1..100], y <- [x+1..x+10]]
00:16:29 <lambdabot>  [5,55,77,181,313,434,505,545,595,636,1001,1111,1441,4334,6446,19691,41214,44...
00:17:07 <x3m> somehow it lacks 818
00:17:17 <int-e> the list is a bit too long I think. 10^6 entries or thereabouts?
00:17:21 <kzm> what factors does 818 have?
00:17:58 <kzm> > 818/2
00:18:00 <lambdabot>  409.0
00:18:11 <int-e> 409 is prime
00:18:19 <kzm> Oh, wait - sum of squares.  Sorry.
00:18:39 <kzm> So - what is the sum of squares that give 818?
00:18:55 <int-e> ok, done in less then 7 minutes, and I didn't compile my code :)
00:19:17 <x3m> did you get the correct answer also?
00:19:57 <int-e> yes
00:20:25 <x3m> 2916867073 is to low isnt it?
00:20:44 <int-e> no.
00:20:53 <x3m> for 10^8
00:20:59 <int-e> (no more questions)
00:21:02 <int-e> yes, for 10^8
00:22:46 <xerox> Byebye
00:23:55 <x3m> no more questions?
00:24:00 <x3m> you aint trying to help are you
00:24:16 <int-e> compiled it runs in 43 questions
00:24:20 <int-e> err?
00:24:22 <int-e> seconds.
00:24:36 <int-e> no, I just want to prevent you playing 20 questions.
00:24:47 <int-e> or 30, as it may be
00:25:03 <x3m> thats not what i do, i try to see whats wrong
00:26:12 <x3m> mine runs in about 15 sec
00:27:07 <kzm> 291...73 is the sum of all palindromic sums-of-squares?
00:28:47 <int-e> kzm, no.
00:29:20 <x3m> kzm: 2-13 was 818
00:29:54 <int-e> so 12 terms.
00:32:07 <x3m> was my answer much wrong in %?
00:33:32 <kzm> x3m: yes I found it.  My bad.
00:38:55 <x3m> now i know what i did wrong
00:42:17 <x3m> had multipel ocuranses of same number
00:49:14 <dons> very interesting! http://programming.reddit.com/info/nvvt/comments
00:49:17 <lambdabot> Title: Patch Theory: A Principled Approach to Version Control [pdf] (reddit.com), http://tinyurl.com/skpad
00:55:21 <urz> hi
00:56:07 <urz> i want opinion's on 100% cpu usage for 3d games -- by design, and always, no matter how fast or what kind of super machine you have
00:56:22 <dons> how is this related to haskell?
00:56:31 <urz> i came to haskell because i want smart people's opinions
00:56:38 <urz> smart coders
00:57:18 <dons> I'm not sure its relevant. There's not a lot of game programmers here.
00:57:21 <urz> know better places to look?
00:57:24 <urz> i know
00:57:42 <urz> but a lot of game programmers are ... well...
00:57:46 <dons> there must be some game forums out there?
00:57:55 <urz> with a lot of noise on them
00:58:14 <vegai> as long as CPUs aren't strong enough to give you 1000FPS with less than 100% CPU usage, you will have 100% CPU usage with 3D games.
00:58:42 <dons> just keep adding detail...
00:58:43 <urz> we cant percieve more than 60fps
00:58:59 <flux__> well, you still want to exactly match the refresh rate of the display
00:59:03 <vegai> urz: I rounded up to be certain.
00:59:03 <flux__> which might be 100Hz
00:59:18 <vegai> 1000FPS should guarantee that you will have at least 60fps in every situation
00:59:34 <x3m> at least mine in c++ was way faster than int-e 's :)
00:59:39 <dons> i think a good idea would be to have an idel busy loop.
00:59:44 <dons> then you can ensure 100% cpu
00:59:50 <dons> and keep your house warm at the same time
00:59:57 <kzm> x3m: 'if it doesn't have to be correct, it can be arbitrarily fast' :-)
01:00:07 <flux__> but, one related thing: pretty screen savers should NOT take 100% cpu :-)
01:00:12 <int-e> x3m: it certainly was longer than 8 lines though.
01:00:16 <dons> x3m, return 1 -- fast!
01:00:17 <urz> heheh
01:00:20 <vegai> has anyone thought of an energy grid that would have a return channel for excess heat?
01:00:22 <kzm> x3m: it can be O(n) by using dynamic programming.  Give me a second.
01:00:35 <vegai> is that a silly idea?
01:00:52 <int-e> kzm: what is n?
01:01:03 <velco> urz: I suggest #opengl
01:01:05 <kzm> n is 10^8
01:01:07 <x3m> int-e: but way faster
01:01:18 <int-e> ok, then we're doing better than that already, kzm.
01:01:19 <x3m> kzm: yep, interesting to se :)
01:01:53 <int-e> or maybe not. I need to think about that.
01:02:05 <thou> > let sqrs = map (^2) [1..]; isPal x = x' == reverse x' where x' = show x in sum $ takeWhile (< 10^8) $ filter isPal $ zipWith (+) sqrs (drop 1 sqrs)
01:02:06 <pejo> vegai, district heating? :-)
01:02:08 <lambdabot>  19125241
01:03:02 <x3m> he some programs solved it in 60ms
01:04:08 <int-e> I'm not surprised. brute force isn't really the right approach - it just happens to be fast enough.
01:08:54 <kzm> int-e - ah, right.  :-/
01:10:14 <x3m> i was interested to see the haskell way of solving it, i can see it now in the forum though
01:10:35 <Banyo_lap> hi there
01:10:54 <Banyo_lap> can anyone help me pls?
01:10:56 <dolio> dons: I cleaned up some ugliness in the solitaire code. I'm not sure what all you saw to shorten it, though. It's already about 60% of the size of the solution on rubyquiz.com.
01:11:20 <ProfTeggy> Banyo_lap, don't ask whether you can ask.  Shoot!
01:11:27 <Banyo_lap> okay
01:11:30 <dons> dolio: 60% not good enough! ;)
01:11:38 <Banyo_lap> I need to write a function for university :D
01:11:47 <Banyo_lap> it's pretty simple, but i'm new to Haskell
01:11:53 <dons> Banyo_lap: homework problem, eh?
01:11:54 <Banyo_lap> Its a "faculty" function
01:12:05 <Banyo_lap> so its like 1*2*3*4...*x
01:12:21 <Banyo_lap> but i don't know how to do it in Haskell
01:12:32 <ProfTeggy> Hmm.
01:12:38 <dons> > sum [1..10]
01:12:39 <lambdabot>  55
01:12:42 <dons> > product [1..10]
01:12:43 <lambdabot>  3628800
01:12:50 <ProfTeggy> Banyo_lap, what were your first take at the problem?  Any code written yet?
01:12:54 <Banyo_lap> so it's prod [1..x]?
01:13:00 <Banyo_lap> <====:)-[ ¥3Å}{ ]-(:=====>
01:13:10 <Banyo_lap> > fac :: Int -> Int
01:13:11 <Banyo_lap> > fac x | x == 0 = 1
01:13:11 <Banyo_lap> >	| x =
01:13:12 <lambdabot>  Not in scope: `fac'
01:13:12 <lambdabot>  Parse error
01:13:29 <ProfTeggy> dons, this was pedagogically questionable ;-)
01:13:29 <Syzygy-> Ah. You're giving this to ghci?
01:13:37 <dons> ProfTeggy: sorry :)
01:13:39 * araujo jumps and throws sugar lambdas
01:13:44 <thou> hehe
01:13:45 <Banyo_lap> Tactical Ops what?
01:13:51 <Banyo_lap> narf
01:13:53 <Banyo_lap> damn scrpts
01:13:58 <Banyo_lap> gonna turn those of next time...
01:14:09 <Banyo_lap> whats ghci?
01:14:10 <Syzygy-> Banyo_lap: GHCi doesn't like things defined that way on the prompt. Put it in a file and load it.
01:14:11 <dons> Banyo_lap: don't be noisy. so where are you stuck?
01:14:13 <Syzygy-> Ummmm.
01:14:25 <Syzygy-> Hugs?
01:14:38 <Banyo_lap> well, if prod [1..x] works, i'm not stuck anymore :D Gonna try it
01:14:39 * dons guess its the recursion
01:15:19 <dons> Banyo_lap: the source for all your haskell needs it http://haskell.org by the way
01:15:21 <lambdabot> Title: Haskell - HaskellWiki
01:15:33 <dons> should be plenty of tutorial (and exampe factorial functions... ;)
01:15:53 <Banyo_lap> okay, thx a lot :D
01:16:05 <Banyo_lap> Just started using Haskell.... like umm... 1 Hour ago :D
01:16:44 <dons> hey swiert
01:16:46 <ValarQ> Banyo_lap: http://www.willamette.edu/~fruehr/haskell/evolution.html
01:16:47 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
01:17:11 <ValarQ> Banyo_lap: should be enough of factorial examples there :)
01:17:42 <dons> swiert: I noticed the new version control paper, very nice!
01:18:04 <x3m> Banyo_lap: fac n = product [1..n] is very good and fac n = n * fac (n-1) is pretty good also
01:18:06 * dons thinks authors should drop HWN-editor a note when they submit ...
01:18:42 <Syzygy-> authors of what? Blog posts in general or "just" papers? Or?
01:18:50 <dons> research papers.
01:18:59 <x3m> the first one of those terminates imediately on a negative number also, the second doesnt
01:19:02 <dons> since they're the blogging of our community
01:19:07 <Cale> > let fac = fix (\f n -> if n == 0 then 1 else n * f (n-1)) in map fac [1..10]
01:19:09 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800]
01:19:16 <Banyo_lap> okay, gonna try it :D thx pal
01:20:07 <Syzygy-> > (scanl (*) 1 [1..] ) !! 10
01:20:09 <lambdabot>  3628800
01:20:40 <Syzygy-> And the point of this construction is that if I use the scanl thingie once, and then calculate several faculties, then it'll actually cache the intermediates, right?
01:21:36 <Cale> if you define something like facs = scanl (*) 1 [1..]
01:21:49 <Syzygy-> Cale: Yah, that was what I started out seeing.
01:21:56 <Syzygy-> I rewrote it to feed it to lambdabot...
01:21:56 <Cale> factorials, by the way
01:22:03 <Syzygy-> Blah. Yeah.
01:22:03 <pzpz> 34 degrees is far too cold.
01:22:21 <Cale> what?
01:22:30 <Cale> I'd say 34 degrees is rather hot
01:22:40 <pzpz> you strange celcius users.
01:22:43 <Banyo_lap> depends
01:22:48 <Banyo_lap> Fahrenheit or Celsius :D
01:22:55 <Banyo_lap> Or Kelvin even
01:23:09 <Cale> Who uses Fahrenheit anymore? ;)
01:23:19 <pzpz> is prelude length O(n) or o(1)?
01:23:31 <Cale> O(n)
01:23:31 <dons> O(n), it walks the list
01:23:33 <pzpz> us ignorant americans.
01:23:55 <Cale> and xs !! k is O(k)
01:24:04 <pzpz> i was hoping it was a datastructure :\
01:24:07 <pzpz> i figured that
01:24:24 <pzpz> well, a fancy datastructure.
01:24:32 <Cale> basically, if you need lots of random accesses, you want an array
01:24:58 <pzpz> havn't even read about arrays yet
01:25:06 <lispy> celius is strange science?
01:25:12 <Banyo_lap> Fahrenheit or Celsius :D*** Term           : x
01:25:12 <Banyo_lap> *** Type           : Integer
01:25:12 <Banyo_lap> *** Does not match : Bool
01:25:22 <Banyo_lap> thats what i get as an error message now
01:26:10 <lispy> the one nice thing aboeout Fahrenheit is that 100 is a hot day
01:26:47 <Cale> 100 C is a hot day too
01:26:47 <dons> its nice that water boils at 100 too...
01:26:58 <dons> that's a good propery. 0 = code, 100 = hot
01:26:58 <pejo> Cale, heh, exactly my thought.
01:27:06 <dons> grr. sleepy
01:27:08 <pzpz> and at least with both, 0 is too cold :)
01:27:11 <dons> 0 /= code
01:27:16 <lispy> heh
01:27:17 <Cale> sounds like you have a cold :)
01:27:32 <fons> hi all
01:27:38 <pejo> pzpz, Amen. Current temperature   06-10-26 10:28:25   -6.0 degrees Celsius ( 21.2F)
01:29:10 <pzpz> pejo: canada?
01:29:30 <pejo> pz, nah, Sweden.
01:29:35 <pzpz> pejo: where exists internet that's that cold.. ahh
01:30:12 <Cale> It's 1 C here
01:30:20 <pzpz> lispy, Cale: got my combination function working a while ago:) thanks for the help.
01:30:28 <Cale> cool
01:30:52 <pzpz> how could you use map though?
01:31:20 <pzpz> > map (,2) [1..4]
01:31:20 <Cale> > (map . (,)) 5 [1,2,3,4]
01:31:20 <lambdabot>  Parse error
01:31:22 <lambdabot>  [(5,1),(5,2),(5,3),(5,4)]
01:31:52 <pzpz> what is the '.' named?
01:31:58 <Cale> composition
01:32:06 <Cale> (f . g) x = f (g x)
01:32:54 <thou> > (zip . repeat) 5 [1 .. 4]
01:32:55 <lambdabot>  [(5,1),(5,2),(5,3),(5,4)]
01:33:14 <pzpz> that's pretty sexy.
01:33:45 <Cale> there's a nice identity: map . (,) = zip . repeat
01:33:57 <araujo> > ((.) . (.)) (\ a -> a + a) (\ a b -> a * b) 3 4
01:33:58 <lambdabot>  24
01:34:12 <Cale> heh
01:34:17 <pzpz> there's a function that stands out.
01:34:20 <araujo> :-}
01:34:38 <lispy> ?check \x xs -> (map . (,)) x xs == (zip . repeat) (x::Int) (xs::[Int])
01:34:39 <lambdabot>  OK, passed 500 tests.
01:34:45 <lispy> ?scheck \x xs -> (map . (,)) x xs == (zip . repeat) (x::Int) (xs::[Int])
01:34:51 <lambdabot> Terminated
01:34:58 <pzpz> what sort of tests?
01:35:03 <Pete_I> how do you access argv in haskell?
01:35:04 <Cale> random ones
01:35:06 <lispy> random x and random xs
01:35:12 <Cale> Pete_I: getArgs
01:35:13 <lispy> Pete_I: getArgs
01:35:18 <lispy> ?hoogle getArgs
01:35:19 <lambdabot> System.getArgs :: IO [String]
01:35:21 <Pete_I> thanks
01:35:21 <pzpz> to assert the strong typing?
01:35:57 <Cale> pzpz: it generates random values of the right types to plug in to the property and tests that it's true for all of them
01:36:09 <Cale> if you put in something that's false, you'll get the counterexample
01:36:11 <lispy> pzpz: check and scheck both try to randomly generate data and evaluate your function with it, if it's ever False then it failed
01:36:20 <dons> in soviet russia strong typing asserts you!
01:36:24 <lispy> ?scheck False
01:36:25 <lambdabot>   Failed test no. 1. Test values follow.:
01:36:31 <lispy> ?scheck True
01:36:32 <lambdabot>  Completed 1 test(s) without failure.
01:36:42 <Cale> scheck isn't random though, it actually generates small values of that type
01:37:02 <Cale> (that's the difference between them)
01:37:04 <lispy> well, so it's only random when the type makes up a huge set
01:37:17 <lispy> right?
01:37:22 <Cale> hm?
01:37:38 <Cale> @scheck \x -> x `elem` []
01:37:39 <lambdabot>  Add a type signature
01:37:42 <lispy> so for example if youneed a value [Int] it won't generate all possible lists on ints of length 1, 2, ...
01:37:43 <pzpz> ?scheck x^2 == x*x
01:37:44 <Cale> @scheck \x -> (x :: Int) `elem` []
01:37:44 <lambdabot>  Not in scope: `x'
01:37:45 <lambdabot>   Failed test no. 1. Test values follow.: -1
01:37:53 <lispy> it will actually just guess some small ints
01:37:55 <Cale> @scheck \x -> (x :: Int) `elem` [-1]
01:37:56 <lambdabot>   Failed test no. 2. Test values follow.: 0
01:37:58 <Cale> @scheck \x -> (x :: Int) `elem` [-1,0]
01:38:00 <lambdabot>   Failed test no. 3. Test values follow.: 1
01:38:02 <Cale> @scheck \x -> (x :: Int) `elem` [-1,0,1]
01:38:04 <lambdabot>   Failed test no. 4. Test values follow.: 2
01:38:05 <Cale> @scheck \x -> (x :: Int) `elem` [-1,0,1,2]
01:38:07 <lambdabot>   Failed test no. 5. Test values follow.: 3
01:38:09 <Cale> @scheck \x -> (x :: Int) `elem` [-1,0,1,2,3]
01:38:09 <x3m> dons: how was it i properly remove hs-plugins?
01:38:10 <lambdabot>   Failed test no. 6. Test values follow.: 4
01:38:12 <Cale> :)
01:38:18 <Cale> You get the idea :)
01:38:26 <pzpz> ?scheck x^x == x*x (x::Int)
01:38:27 <lambdabot>  Not in scope: `x'
01:38:35 <pzpz> i give up.
01:38:43 <Cale> ?scheck \x -> x^x == x*(x :: Int)
01:38:44 <lambdabot>  Exception: Prelude.^: negative exponent
01:38:49 <Cale> ?scheck \x -> x^^x == x*(x :: Int)
01:38:51 <lambdabot>  add an instance declaration for (Fractional Int)
01:39:04 <Cale> ?scheck \x -> x^(abs x) == x*(x :: Int)
01:39:06 <lambdabot>   Failed test no. 1. Test values follow.: -1
01:39:18 <Cale> ?scheck \x -> x^(abs x) /= x*(x :: Int)
01:39:20 <lambdabot>   Failed test no. 3. Test values follow.: 1
01:39:25 <lispy> ?schuck L.knuth 3 2 2 == 27
01:39:26 <lambdabot>  Not in scope: `L.knuth'
01:39:26 <dons> remove the library, and then ghc-pkg unregister plugins
01:39:32 <Cale> ?scheck \x -> x /= 1 && x^(abs x) /= x*(x :: Int)
01:39:33 <lambdabot>   Failed test no. 3. Test values follow.: 1
01:39:41 <Cale> ?scheck \x -> x == 1 || x^(abs x) /= x*(x :: Int)
01:39:42 <x3m> remove the library=just delete the files?
01:39:42 <lambdabot>   Failed test no. 4. Test values follow.: 2
01:39:44 <pzpz> too cool.
01:40:08 <x3m> and also, does it matter to where i install hs-plugins?
01:40:14 <pzpz> what exactly is scheck? function implemented for lambdabot?
01:40:27 <Cale> SmallCheck, a Haskell library
01:40:41 <lispy> pzpz: i use quickcheck at work (that's what ?check is) to help me test the software i write, it helps me find lots of bugs
01:40:42 <Cale> http://www.mail-archive.com/haskell@haskell.org/msg19215.html
01:40:45 <lambdabot> Title: [Haskell] ANN: SmallCheck 0.1, http://tinyurl.com/yh7bl7
01:40:59 <Cale> http://www.md.chalmers.se/~rjmh/QuickCheck/
01:41:01 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
01:41:11 <pzpz> lispy: you get to code haskell for work? :p
01:41:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
01:41:17 <lambdabot> http://tinyurl.com/y3vmep
01:41:18 <lispy> pzpz: kinda
01:41:41 <lispy> pzpz: unless they require me to use someting other than haskell, it gets written in haskell
01:41:47 <pzpz> Cale: yah -- looking those up now -- ty
01:42:04 <ValarQ> pzpz: believe it or not, it is possible :)
01:42:23 <dons> x3m, yeah, just remove it. shouldn't matter where you install it, but windows is weird, and i don't use it. so i'm not sure.
01:42:34 <lispy> yeah, the main thing is to use it whenever you get the option and then to make sure you make good use of it...that way others at work might like it
01:42:47 <lispy> pzpz: this was the wisdom an old lisper passed on to me
01:42:49 <dons> pzpz: there's many people in here who code haskell for money/work
01:43:06 <pzpz> lispy: any way you look at it, it's decent job insurance :)
01:43:10 <dons> sometimes in the style lispy does (which is how linux started getting used too, i guess)
01:43:53 <lispy> linux is funny that way
01:44:08 <lispy> why is it so much more popular/mainstream than the others that are just as good (maybe better?)
01:44:10 <dons> oh, i love this thread. " love Haskell, its such a pure and expressive language. The performance on the other hand, sucks." ... 2 hrs later ... "Edit: Update performance with GHC 6.6 and Data.ByteString seems really fast. Decent I/O has solved most of my performance problems."  :D
01:44:27 <lispy> haha
01:44:41 <lispy> dons: we need to bug daan about Parsec.ByteString
01:44:50 <dons> we do! or just write it ourselves
01:44:52 <lispy> dons: i mailed him asking for help, but no answer
01:45:03 <dons> i'm not sure how much haskell he's doing these days
01:45:16 <lispy> dons: that was my first appoarch, but some of parsec internals are over my head :(
01:45:41 <pejo> dons, any idea how representative the String representation is for hte perception of "performance sucks"?
01:45:55 <pejo> Hm, lots of representation in that sentence.
01:45:56 <Itkovian> have there been put out any decent haskell benchmarks lately? other than microbenchmarks? could darcs, be considered a decent benchmark, ans if so, what inout sets could it use?
01:46:19 <dons> pejo: my guess, 85% of the perception is due to [Char]
01:46:36 <lispy> dons: i want something that uses it in such a way that there is a data.bytestring drop in replacement version (minimal changes) just to start finding out if it's worthwhile to convert parsers to it... i mean, just think if people can drop it in for almost free
01:46:47 <dons> Itkovian: hmm. pugs perhaps?
01:46:55 <dons> they talk about some big speedups since 6.6 came out
01:47:12 <pejo> dons, boggle. Thats pretty severe.
01:47:23 <Itkovian> dons: ok, and are there major perl6 apps that can serve as input?
01:47:31 <lispy> Itkovian: darcs is hard to use as a bench mark
01:47:39 <dons> there are some commerical perl6 apps, i've heard.
01:47:45 <lispy> Itkovian: Igloo and some others have done some crazy mean optimizations to it
01:47:58 <dons> Itkovian: are you looking for benchmarks?
01:48:03 <Itkovian> lispy: that's ok, I guess
01:48:16 <lispy> my term project this term is to write a user simulator for darcs
01:48:30 <lispy> it should be possible to modify it to create charts from profiles
01:48:44 <lispy> and even extend the frame work to benchmark various applications
01:48:46 <dons> pejo: yeah. i mean, ghc generates fast code, but it can't do a whole lot with [Char] ... at least when you're competing against unboxed arrays
01:48:49 <lispy> sadly i cannot write it in haskell
01:48:59 <beelsebob> busy night in here then
01:49:06 <dons> so once you get rid of [Char] for heavy io, the real speed of ghc-produced code shines through
01:49:12 <lispy> beelsebob: long time no see, hi!
01:49:28 <lispy> ghc produces some crazy fast code
01:49:32 * beelsebob licks lispy
01:49:33 <flux__> although, it would be really cool if ghc could optimize [Char] away
01:49:39 <lispy> and yet, i guess jhc is faster at times?
01:49:45 <beelsebob> lispy: yhc produces 30% faster code again
01:49:48 <flux__> because it's such a nice abstract..
01:50:08 <dons> well, i'd like to see some big benchmarks for yhc ... ;)
01:50:09 <lispy> beelsebob: whoa, really? cool
01:50:24 <dons> we have one program that runs faster, with ndm's extra analysis tool?
01:50:32 <beelsebob> lispy: ndm wrote an analysis
01:50:43 <beelsebob> and made yhc compile down to haskell and then shove it through ghc
01:50:52 <lispy> hah!
01:50:53 <dons> ah!
01:50:53 <beelsebob> which optimises the code pretty well
01:50:56 <dons> hehe
01:51:01 <beelsebob> he's doing a C backend now
01:51:10 <dons> yeah, i did this once, and wiped gcc off the map with some fib code
01:51:14 <beelsebob> and reconds he can make it a good chunk faster
01:51:18 <flux__> how's that.. jhc going on these days? or isn't?
01:51:34 <dons> compile mini-haskell -> unboxed, strict ghc haskell -> native code. == $$fast
01:51:38 <roconnor> beelsebob: doesn't ghc shove it's result through gcc?
01:51:40 <lispy> connal mentioned he figured out some things that never made it into ghc that sped thnigs up a bit too (just some algebraic transformations)
01:51:45 <roconnor> which optimises the code pretty well
01:52:00 <dons> lispy: the unboxed enum stuff?
01:52:09 <beelsebob> roconnor: I think so - but neil thinks he can make yhc produce better C than ghc produces un-optimised code
01:52:32 <lispy> dons: he was dealing in the graphics domain
01:52:33 <dons> yeah, that's a good goal to aim for
01:52:53 <lispy> dons: so, think a lot it was about lifting operators out side of loops
01:53:14 <dons> right. like the other Pan papers.
01:53:15 <pzpz> what generally produces faster code? yhc or ghc?
01:53:15 <roconnor> soooo, can I get GHC to remove case statements with identical branches?
01:53:24 <dons> pzpz: ghc
01:53:29 <beelsebob> depends on the code
01:53:36 <beelsebob> try it in both and see
01:53:40 <pzpz> gotya.
01:53:58 <beelsebob> anyway... I'd suggest yhc in that that's ghc's optimisations, plus neils extra one
01:54:08 <beelsebob> so it shouldn't really be significantly worse
01:54:09 <lispy> pzpz: ghc is a very good general purpose haskell compiler....it tends to support all the crazy research ideas and generate some of the best performance
01:54:13 <dons> beelsebob: does yhc call ghc by default?
01:54:26 <beelsebob> dons: no - just use neil's back end
01:54:28 <roconnor> pzpz: if you are writing a prime number sieve, then neil's unreleased optimiser for yhc is best, otherwise ghc. ;)
01:54:31 <beelsebob> mmm... neil's arse
01:54:46 <lispy> heh
01:54:49 * lispy &
01:54:56 <dons> yes, ndm's back end is the source of all good things
01:54:57 <int-e> you shouldn't use the nofib prime sieve, it's awful.
01:55:30 <x3m> dons /* Path to top of build tree */ #define TOP is this where i unpacked the source files?
01:55:38 <beelsebob> so... where's the quotes page?
01:55:46 <roconnor> int-e: I vaguely recall reading in a paper that it is know that CSE can cause space leaks that more than make up for the gains by CSE.
01:55:53 <dons> beelsebob: use @remember nick quote
01:56:18 <roconnor> @quite beelsebob
01:56:18 <lambdabot> Maybe you meant: quit quote
01:56:22 <roconnor> @quote beelsebob
01:56:23 <lambdabot>  > filter isJuggler #haskell
01:56:24 <beelsebob> dons: it was really both of us together made the quote though
01:56:43 <dons> quote away though, i don't mind.
01:57:10 <Syzygy-> @quote sylvan
01:57:11 <lambdabot> sylvan hasn't said anything memorable
01:57:11 <dons> ?remember beelsebob dons: no - just use neil's back end. mmm... neil's arse [don] yes, ndm's back end is the source of all good things
01:57:15 <Syzygy-> @quote Syzygy-
01:57:15 <lambdabot> Syzygy- hasn't said anything memorable
01:57:16 <kzm> x3m: my haskell solution is now down to 0.4s
01:57:18 <Syzygy-> :(
01:57:31 <beelsebob> @quote dons
01:57:32 <lambdabot>  Haskell: The language that never sells out!
01:57:36 <beelsebob> o.O
01:57:45 <araujo> hah
01:57:47 <dons> kzm, I think these math challenge problems should go on the wiki too..
01:59:11 <kzm> > let n=100; squares = [x^2 | x <- [1..n]]; bySize prev = takeWhile (<n^2) $ zipWith (+) squares (tail prev);isPal x = show x == reverse (show x); in filter isPal $ concat $ takeWhile (not.null) $ iterate bySize squares
01:59:13 <lambdabot>  [1,4,9,121,484,676,5,181,313,545,77,434,4334,55,1111,595,636,505,1001,1441,6...
01:59:33 <x3m> dons: naah, i dont think they person who hosts that site would like if the solutions go public
01:59:37 <kzm> > let n=1000; squares = [x^2 | x <- [1..n]]; bySize prev = takeWhile (<n^2) $ zipWith (+) squares (tail prev);isPal x = show x == reverse (show x); in last $ filter isPal $ concat $ takeWhile (not.null) $ iterate bySize squares
01:59:39 <lambdabot>  981189
01:59:49 <kzm> > let n=10000; squares = [x^2 | x <- [1..n]]; bySize prev = takeWhile (<n^2) $ zipWith (+) squares (tail prev);isPal x = show x == reverse (show x); in last $ filter isPal $ concat $ takeWhile (not.null) $ iterate bySize squares
01:59:52 <lambdabot>  95177159
01:59:56 <dons> x3m. oh. maybe.
02:00:09 <dons> but its not like they control the copyright... anyway, whatever is appropriate.
02:00:09 <kzm> Four lines is a bit long though :-)
02:00:28 <beelsebob> 3 lines here :P
02:04:02 <roconnor> @pl let n=100; squares = [x^2 | x <- [1..n]]; bySize prev = takeWhile (<n^2) $ zipWith (+) squares (tail prev);isPal x = show x == reverse (show x); in filter isPal $ concat $ takeWhile (not.null) $ iterate bySize squares
02:04:03 <lambdabot> (line 1, column 146):
02:04:03 <lambdabot> unexpected reserved word "in"
02:04:03 <lambdabot> expecting natural or letter or digit
02:04:57 <swiert> dons: glad you like the paper.
02:05:11 <swiert> sorry for the slow reaction, btw.
02:08:13 <kzm> dons/x3m: which wiki?
02:10:17 <Cale> dons: how do you like my addition to the thread above yours?
02:11:09 <dons> swiert: posted a link on reddit, hope you don't mind. http://programming.reddit.com/info/nvvt/details
02:11:12 <lambdabot> Title: Patch Theory: A Principled Approach to Version Control [pdf] (reddit.com), http://tinyurl.com/yjhnme
02:11:34 <dons> Cale: in the Haskell v Scheme thread?
02:11:35 <swiert> dons: sure no problem. I'm honoured.
02:11:44 <Cale> yeah
02:11:52 <araujo> link?!
02:12:10 <Cale> http://programming.reddit.com/info/nq1k/comments
02:12:13 <lambdabot> Title: Haskell and Scheme: Which One and Why? (reddit.com), http://tinyurl.com/y83lp6
02:12:31 * araujo printed the paper "State on Haskell" for those boring free hours in univ.
02:12:37 <araujo> thanks Cale :-)
02:13:03 <dons> Cale: ? did you add a comment?
02:13:13 <Cale> search for cgibbard
02:13:35 <dons> ah! not 'Cale' :)
02:15:17 <mux> @seen dcoutts_
02:15:17 <lambdabot> dcoutts_ is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 14h 58m 11s ago.
02:15:35 <dons> nice Cale
02:19:15 <araujo> "And again, from the other side, laziness can be incredibly confusing. Not knowing what order things are going to happen in can result in things happening in an unexpected order"
02:19:28 <araujo> I gotta say this has _never_ happened to me ....
02:19:38 <araujo> probably i need to code more "important" real life stuff?
02:19:54 <dolio> Why would the order it happens in matter?
02:20:03 <dolio> Except for space leaks, and unsafe...
02:20:12 <pzpz> http://paste.lisp.org/display/28721
02:20:37 <dons> yeah, the person doesn't understand why order _doesn't_ matter in Haskell
02:20:51 <pzpz> how could I write this more elegantly? it esentially checks a list for two duplicate items in a row
02:21:52 <x3m> Could not find module 'System.Eval.Haskell':
02:22:05 <x3m> when i try to compile runplugs.hs
02:23:09 <x3m> do i need to put it in any specific dir when i compile it?
02:23:51 <int-e> hmm, hasdup = any (not . null . tail) . group
02:25:00 <int-e> pzpz: you can pattern match more than one list element. so you can have, hasdup (x:y:xs) | x==y = True; hasdup (x:xs) = hasdup xs; hasdup [] = False
02:25:06 <dolio> pzpz: annotated
02:25:29 <dons> x3m, sounds like you unregistered hs-plugins?
02:25:49 <araujo> sargh, i don't agre with him about the correctness proof point either .....
02:25:54 <wolverian> heh, I like the markdown bashing in the scheme vs haskell thread. sometimes internets rewards you, especially if you have a bad sense of humour (:
02:26:16 <pzpz> int-e, dolio: ty
02:26:22 <x3m> dons: and then installed it again
02:26:24 <araujo> That's practically what allows me to code things on my notebook and run it when i get back home straight-head
02:27:20 <pzpz> dolio: how could one improve that ineffiency?
02:27:24 <dons> x3m, does it appear when you run: ghc-pkg list plugins
02:28:27 <dolio> you'd match (x:ys@(y:_)) instead, and use ys instead of (y:zs).
02:28:32 <dolio> But that's uglier.
02:28:42 <int-e> and the compiler probably produces the same code anyway
02:28:45 <int-e> (ghc at least)
02:29:15 <dolio> That'd be reasonable.
02:29:29 <pzpz> gotya.
02:29:35 <pzpz> what is the @ called?
02:30:05 <dolio> I don't know. It just means that both ys and (y:_) get matched against the same thing.
02:30:29 <dolio> Not sure it has a specific name.
02:30:34 <int-e> one could read it as 'as', maybe.
02:30:43 <gds> int-e: can't you pattern match for equality too: hasdup(x:x:xs) = ...   ?
02:30:51 <int-e> no
02:30:53 <dolio> Yeah, that's how ML writes it, right?
02:31:01 <gds> Oh :)
02:31:15 <int-e> > \(x:x:xs) -> undefined
02:31:16 <lambdabot>    Conflicting definitions for `x'
02:31:16 <lambdabot>   In a lambda abstraction
02:31:32 <int-e> it binds 'x' twice and the compiler won't like that :)
02:31:40 <dolio> Yeah, Haskell doesn't do unification.
02:32:13 <gds> Ah well - that I've never noticed that I can't do it, is a good argument for how inrequently I need to ;)
02:32:22 <gds> *infrequently
02:32:28 <pzpz> would one use a type for something like a C enumeration?
02:32:38 <dons> hasdup(x:y:xs) | x == y = ..
02:32:41 <int-e> gds: guards aren't that bad :)
02:32:43 <_matthew_> gds: personally, having worked with Erlang for a while, I really miss unification in Haskell
02:32:52 <gds> Oh yeah - guards are lovely :)
02:34:41 <Bourbaki> moin
02:35:05 <Bourbaki> dons are you awake?
02:35:19 <Cale> pzpz: yes, and a whole lot more :)
02:36:06 <pzpz> yah -- reading now. i'm going to go out on a limb and guess that i can't use globals, right?
02:36:28 <Cale> global constants :)
02:38:27 <dolio> @pl \l -> splitAt (n + i `mod` length l) l
02:38:28 <lambdabot> splitAt =<< (n +) . (i `mod`) . length
02:41:47 <pzpz> Cale: if i had program inputb
02:42:24 <pzpz> Cale: if i had a program input n, which I'd like to be global and accessed by certain functions -- would that be somewhat frowned upon?
02:42:42 <pzpz> seems like a nono in fp
02:42:46 <Cale> normally you want to pass n explicitly to where it's needed
02:42:56 <Cale> there's something called a reader monad which can do that for you
02:43:08 * drrho is away: watching kommissar Rex
02:43:10 <Cale> (just handle the passing along of environments)
02:44:18 <Cale> But generally, yeah, this is the sort of thing which you put a little more thought into in FP.
02:44:41 <Cale> Think about it this way, by making that dependency explicit, you're making your functions easier to test.
02:44:45 <pzpz> it would be frustrating to pass along a variable n, since many functions would only have n in the prototype in the case it might be used by another function.
02:45:35 <Cale> If that's really the case, then the Reader monad is the thing to use
02:48:16 <Cale> It's a little uncommon for programs to need to pass variables down that far without doing much with them.
02:48:29 <pzpz> Cale: you're right -- I
02:48:32 <pzpz> argh --
02:48:44 <pzpz> I'm just a little unused to any extraneous variable passing
02:48:57 * mux has used the Reader monad in cases where many functions will potentially need to read/write to some Handle
02:49:00 <mux> it's just great
02:55:21 <araujo> aah .. several comments like ... "I have never used Haskell ..... But the thing we do in our company are easier in <X> or <Y> than in a funcional language ..."
02:56:08 <roconnor> I suppose if you optimized all object of type () to (), then you could turn crashing programs into programs that do damage.
02:56:17 <roconnor> hmmm
03:01:49 * araujo off to univ
03:19:44 <pierre-> hello
03:19:50 <Cale> hi
03:24:14 <psnl> lambdabot: @help
03:24:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:24:19 <psnl> lambdabot: @help message
03:24:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:24:24 <psnl> lambdabot: help message
03:24:46 <Cale> @help message
03:24:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:24:52 <Cale> @list
03:24:53 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:25:01 <Cale> @help tell
03:25:02 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
03:26:05 <psnl> @tell ndm Are you using a case sensitive filesystem?
03:26:05 <lambdabot> Consider it noted.
03:26:47 <Cale> iirc, ndm uses windows, so probably not?
03:27:18 <psnl> Cale: thanks
03:44:34 * roconnor slowly becomes disillusioned with dependent-types.
03:50:44 <gds> @where literateHaskell
03:50:45 <lambdabot> I know nothing about literatehaskell.
03:50:48 <gds> @where lhs
03:50:49 <lambdabot> I know nothing about lhs.
03:50:53 <gds> Hm.
03:51:26 <gds> Anyone know if there are any tools about for turning lhs files into tex files ?
03:52:02 <gds> (removing the ">"s, and putting the code in a <pre> type environment or whatever...)
03:52:16 <psnl> gds: it rings a bell as an idea
03:52:41 <roconnor> gds: \begin{code} and \end{code} is a valid way of marking code in .lhs files
03:52:47 <SamB_XP> lhs2tex ?
03:53:09 <gds> roconnor: Ah - that's handy :)
03:53:16 <roconnor> http://www.haskell.org/onlinereport/syntax-iso.html#sect9.4
03:53:19 <lambdabot> Title: Haskell 98 Syntax, http://tinyurl.com/yyu4tv
03:53:36 <gds> @google lhs2tex
03:53:38 <roconnor> hmm, the tinyurl is missing the fragment identifier.
03:53:39 <lambdabot> http://www.informatik.uni-bonn.de/~loeh/lhs2tex/
03:53:39 <lambdabot> Title: lhs2TeX
03:54:17 <jmmv> hi
03:55:01 * SamB_XP wonders if jmmv is initials or if it stands for "J00r Mileage May Vary"
03:55:18 <gds> thx roconnor, SamB_XP :)
03:56:00 <jmmv> SamB_XP: initials
03:57:13 <SamB_XP> whenever I see that nick I think of "ymmv" ;-)
03:57:54 <jmmv> heh
04:28:42 <SamB_XP> hmm. how are people supposed to ensure that library patches run on both Windows and Linux?
04:28:54 <SamB_XP> well I suppose most of the time it is easy...
04:30:26 <SamB_XP> (you just sort of assume that the functionality you are using does not differ between OSes)
04:30:48 <SamB_XP> should work fine as long as you aren't touching threading or I/O...
04:33:15 <Ta0s> sombody tell me please why this code wrong mygcd a b = max C
04:33:15 <Ta0s>     where C = intersect A B
04:33:15 <Ta0s> 	      A = divisors a
04:33:15 <Ta0s> 	      B = divisors b
04:33:15 <Ta0s> divisors z = [x|x <- [1..a],rem z x ==0]
04:34:37 <weel_> Ta0s: C is not valid variable syntax
04:34:45 <weel_> Ta0s: use lowercase letters to start variables
04:37:29 <SamB_XP> also that looks like a pretty crazy gcd algorithm
04:37:32 <roconnor> SamB_XP: Any luck with fish?
04:37:46 <SamB_XP> roconnor: hmm, haven't looked at it lately, actually...
04:38:07 <roconnor> I don't see why you need fish to run faster.  CSE can make things slower and it is still included
04:38:18 <weel_> Ta0s: is this for coursework? do they teach Haskell in Moscow?
04:38:48 <roconnor> slower in that the space useage is larger.
04:38:56 <Ta0s> now it's just for fun ^)
04:39:27 <TSC> Why is it "a" in "x <- [1..a]" ?
04:39:36 <weel_> Ta0s: great, keep it up.
04:39:59 <Ta0s> what should be there?
04:40:15 <roconnor> (min a b) maybe
04:40:19 <TSC> z, I thought
04:40:38 <roconnor> z is works too
04:40:54 <weel_> yeah. it's inefficient either way.
04:41:39 <roconnor> actually maybe you need either z or (min a b)
04:41:48 <SamB> roconnor: it isn't that it runs slower
04:41:53 <Ta0s> yes i know i've wrote another way but i what make this way too.
04:41:57 <SamB> it is that it does more allocation than it used to
04:42:42 <roconnor> That's a little surprising ... other than the fact that Haskell memory usage is random anways.
04:43:05 <SamB> well, it seems to allocate more Ints :-(
04:43:56 <roconnor> SamB, is that so suprising given that we will do more inlining?
04:44:11 <roconnor> hmm
04:44:34 <SamB> well you'd think inlining would increase unboxing and thereby decrease the allocation of Ints...
04:45:01 <roconnor> oh right Ints
04:45:06 <roconnor> I was thinking integers
04:53:51 <roconnor> does fish draw a picture of a fish?
04:54:10 <SamB> not directly
04:54:19 <SamB> its possible that that is what the output represents
04:59:56 <roconnor> do I just need stage1 to run nofib?
05:01:45 <SamB> yeah, and the libraries
05:02:19 <SamB> anyone know what a "foreign label" is?
05:19:43 <ndm> SamB, some of the patches have big #ifdef WINDOWS around them to break deliberately on windows, thats why i want to shoot people who don't do cross platform stuff
05:19:44 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:20:24 <ndm> @tell psnl, no, windows
05:20:25 <lambdabot> Consider it noted.
05:20:37 <ndm> @tell psnl no, windows
05:20:37 <lambdabot> Consider it noted.
05:33:16 <musasabi> ndm: so how would one use a foreign function that is ccall on *nix and stdcall on windows with e.g. YHC ?
05:33:41 <musasabi> without cpp that is.
05:34:54 <ndm> musasabi: i don't know, ask on the yhc mailing list if you need it - Tom is the only one who knows ffi
05:36:16 <musasabi> just curious, since CPP won't be a solution if portable bytecode is the target.
05:37:39 <ndm> i think it can be done some way
05:38:12 <ndm> quite possibly the default calling convention changes between OS's
05:38:59 <shapr> Good morning #haskell! It's a beautiful day out there!
05:41:25 <Itkovian> @seen boegel
05:41:26 * JKnecht thought shapr was in a time zone where it would be another day part
05:41:26 <lambdabot> I saw boegel leaving #haskell-blah and #haskell 9h 11m 24s ago, and .
05:41:44 <shapr> JKnecht: I'm in the USA now.
05:42:08 <JKnecht> ah
05:42:54 <shapr> I'm in Birmingham, Alabama. My family is here, but I haven't found many unicyclists, Swedish speakers, or FP users.
05:45:46 <roconnor> SamB_XP: we should just fork GHC and add whatever optimisations we want.
05:46:59 <JKnecht> my condolences. Headed out of Buffalo myself.
05:48:18 <shapr> Out of? Where to?
05:48:47 <JKnecht> maybe massachussets, but more likely toronto
05:49:31 <shapr> Sounds exciting.
05:49:37 <JKnecht> toronto will be my base in North America in any case
05:53:16 <SamB> roconnor: heh
05:53:47 <roconnor> we can eliminte cases when all branches are identical
05:53:59 <roconnor> and replace all values of type () with ().
05:54:24 <SamB> uh, no
05:54:30 <roconnor> oh come on.
05:54:36 <SamB> what about _|_!
05:55:09 <roconnor> I don't care about programs that do case analysis on _|_, they are broken anyways.
05:55:17 <SamB> heh
05:55:36 <roconnor> no point in trying to preserve the semantics of broken programs.
05:56:12 <roconnor> especially given that it is undecidable if a program is broken or not
05:56:13 <SamB> the real problem with forking GHC is that you'd need people who could handle it
05:56:34 <roconnor> not with distributed revision control systems
05:56:45 <roconnor> we will just keep pulling in the patches from the normal GHC branch.
05:57:29 <roconnor> and eventually everyone will start using our fork because if the superiour performance it produces.
05:57:34 <roconnor> for their programs
05:57:55 <roconnor> while the normal GHC branch can keep their high performace fish program.
06:02:46 <roconnor> hey, GHC head builds for me!
06:05:18 <Sweetshark> Hi guys! Im thinking about learning a modern language that compiles to fast native code. My requirements are: good interfaces to Python and C for generic API support, clean language enabling OOP and functional programming, platformindependance, compiler producing fast native code. Can Haskell provide this? How does it compare to ocaml and Eiffel? Good links are welcome too ...
06:05:56 <Lemmih> You really want OOP?
06:06:28 <Sweetshark> just the possibility
06:06:33 <Pete_I> Sweetshark, sounds like you want python...
06:06:38 <Botje> how do OO and FP mix, again?
06:06:56 <Botje> since OO means modeling state as objects
06:07:01 <_matthew_> hi. um a tutorial I'm reading is talking about newIORef which should be in IOExts, but I can't find that. Has it been replaced by something else?
06:07:24 <Lemmih> @index newIORef
06:07:25 <lambdabot> Data.IORef
06:07:38 <_matthew_> thank you
06:09:05 <roconnor> SamB_XP, did you read SPJ's notes on fish?
06:09:17 <roconnor> The performance of fish depends crucially on inlining scale_vec2.
06:09:17 <roconnor> It turns out to be right on the edge of GHC's normal threshold size, so
06:09:17 <roconnor> small changes to the compiler can knock it to and fro.
06:11:28 <roconnor> maybe we could see if writing an inline pragma for scale_vec2 reduces the Int allocations to normal values.
06:11:41 <roconnor> or just check to see if scale_vec2 is getting inlined.
06:12:04 <roconnor> I could imagine our extra inlining makes scale_vec2 to big to be inlined, affecting the proformance negatively
06:12:20 <shapr> Where does SPJ talk about FISh?
06:12:25 <roconnor> if this is the case, then I don't think our patch is bad
06:12:36 <roconnor> shapr: novig/Simon-nofib-notes
06:12:38 <roconnor> er
06:12:47 <roconnor> nofib/Simon-nofib-notes
06:13:16 <roconnor> I mean, the whole inlining mechnism is fragile in this respect.
06:21:12 <_matthew_> where are the monadic ops for list defined?
06:22:50 <_matthew_> ahh, found it.
06:26:46 <ndm> roconnor: i agree :)
06:27:02 <gour> shapr: bok. how are you living without eu?
06:27:08 <roconnor> ndm, that we sould fork GHC?
06:27:11 <roconnor> should
06:27:16 <ndm> roconnor: oh, on that, no
06:27:23 <roconnor> :)
06:27:29 <ndm> roconnor: i mean that inlining as a transformation mechanism is fragile :)
06:27:46 <ndm> roconnor: are you thinking of forking GHC?
06:27:53 <roconnor> not seriously.
06:28:30 <roconnor> although if I fail to get this optimisations to be accepted, and I actually find them useful, then I would try.
06:28:33 <ndm> roconnor: if Yhc -O beat GHC, would you move over to working on Yhc instead?
06:28:43 <Ta0s> Oh. Seems i can't make it work..
06:28:45 <Ta0s> mygcd a b = max c
06:28:45 <Ta0s> 	where c = intersect aa bb
06:28:45 <Ta0s> 	     where aa = divisours a
06:28:45 <Ta0s>                bb = divisours b
06:28:45 <Ta0s> divisours z = [x | <- [1..z] z 'mod' x ==0]	
06:28:58 <roconnor> ndm: well, I'm hardly working on GHC to begin with.
06:29:24 <roconnor> I'm interested in getting my Haskell programs to run reasonably fast.
06:29:28 <gour> ndm: how far is gtk2hs with yhc?
06:29:40 <roconnor> GHC has the source code available, so I'm tweeking that
06:29:42 <dcoutts> gour, not very
06:29:57 <roconnor> Yhc -O source isn't available, so I'm not tweeking it.
06:30:14 <gour> dcoutts: great. what about gtk2hs-darcs ebuild failing with ghc-6.6.?
06:30:16 <ndm> roconnor: it is technically available, just no one but me knows where :)
06:30:22 <dcoutts> gour, we need to cabalise gtk2hs.
06:30:28 <dcoutts> gour, does it? oh.
06:30:43 <gour> dcoutts: yes, tee error
06:30:44 <ndm> roconnor: and it doesn't have heuristics, so tweaking isn't something we need so much - things just work (TM)
06:30:52 <dcoutts> gour, oh, that's noting I can solve.
06:31:04 <dcoutts> gour, that needs portage logging turning off.
06:31:06 <roconnor> ndm: I'm looking forward to seeing how you handle the Tait program.
06:31:12 <dcoutts> gour, it fails during the darcs pull right ?
06:31:16 <roconnor> it is in dire need of optimisations.
06:31:17 <gour> dcoutts: cabalizing means still using autoconf?
06:31:29 <roconnor> more than I even expect you to be able to pull off.
06:31:29 <gour> dcoutts: yes patch #20
06:31:36 <dcoutts> gour, no, means using Cabal rather than autoconf or automake.
06:31:46 <ndm> roconnor: give me a few days, am reworking some other stuff on the way to it before i even give it a whirl
06:32:02 <roconnor> of course.
06:32:06 <gour> dcoutts: what? i cannot believe :-) it is close to be free of autoconf for haskell?
06:32:27 <dcoutts> gour, we'll see. It's not there yet.
06:33:12 <psnl> ndm: mind if I change referneces to hatgui.glade to HatGui.glade then?
06:33:13 <lambdabot> psnl: You have 1 new message. '/msg lambdabot @messages' to read it.
06:33:13 * gour recalls that dcoutts does not spread vaporware
06:33:23 <ndm> psnl: go for it
06:33:37 <ndm> psnl: and karma me down for getting that wrong!
06:34:42 <ndm> psnl: if you can figure out a better way of finding the .glade file, which isn't as fragile, feel free to do that as well
06:35:30 <psnl> @karma- ndm case matters
06:35:30 <lambdabot> ndm's karma lowered to 7.
06:36:27 <psnl> ndm: my guess is that a search path should be coded in somehow, I'll look at the glade docs to find out how it should be done ASP
06:37:05 <ndm> psnl: cool, i take it these patches are against the hat repo? do you know how you're going to commit them yet?
06:37:34 <ndm> i mean send them to the mailing list, get an authorised account on haskell.org or what
06:41:05 <psnl> against the repo, and I was palnning to send them to the ML
06:41:24 <psnl> I have no idea how to get a haskell.org account
06:51:15 <ndm> the mailing list is fine, if you clearly split them between hat-gui and other hat stuff, since i'll apply the hat-gui ones
06:52:49 <ndm> roconnor: if you wanted me to attempt to optimise one single file that had a main in it and did your normalisation stuff, which one would it be?
06:52:59 <ndm> roconnor: feel free to paste modules together to answer this question
06:53:15 <ndm> (just so i have one single module as my target, to define the goal a bit more clearly)
06:53:30 * shapr throws redexes
06:54:06 * ndm reduces them to unboxed integers
06:54:14 <roconnor> ndm: there are 6 pairs of files
06:54:23 <ndm> roconnor: pick one, any one :)
06:54:37 <ndm> roconnor: or rather pick a pair, and combine them into one single file :)
06:54:41 <roconnor> but if you wanted to focus on just one pair, it would be beteetared and betaetared_main
06:54:52 <roconnor> any pair could be combined into one file.
06:55:10 <roconnor> they are only separated because one is what is automatically generated and one is the harness
06:55:15 <Sweetshark> Pete_I, Botje: No, I dont want python. I know python, I like python. But python is slow, which does not matter in many cases, but when it does I dont what to fall back to C to generate a performant solution.
06:55:54 <roconnor> But really I would want to compare that result to the betaetared_nc.
06:56:32 <roconnor> because if your optimiser is super great, then those two pairs ought to produce the same binary.
06:57:20 <Sweetshark> (this is also the reason, OOP was in the list, as it would ease bridging to something objectoriented in another language ...
06:57:21 <ndm> roconnor: it will take at least a few days, maybe weeks, before i get them going through properly
06:57:33 <ndm> roconnor: but i'll focus on that one, and once thats done, see how _nc goes
06:59:58 <roconnor> merging the files is a little bit of work because prelude is imported qualified in one module
07:00:27 <roconnor> so you will need to sprinkle Prelude. prefixes in the function calls from the betaetared_main
07:00:38 <roconnor> but betaetered_main isn't very big.
07:01:04 <ndm> roconnor: just finished that doing, and you're also on a really old version of hugs, its now Hugs.IOExts
07:01:09 <ndm> roconnor: a good test case?
07:01:21 <ndm> roconnor: or rather, one that executes in around 1 second in Hugs
07:01:45 <ndm> never mind, found one, 5 5 gives a measurable time delay
07:07:28 <gour> anyone read http://theonlywinningmove.blogspot.com/2006/10/scheme-death-knell.html ?
07:07:31 <lambdabot> Title: The Only Winning Move: Scheme Death Knell?, http://tinyurl.com/yd3uzv
07:07:50 <Syzygy-> Not yet, but I think goodmath badmath has a critique of it...
07:08:52 <roconnor> ndm: 20 2 is my usual test case
07:08:58 <roconnor> but that take GHC 4 seconds
07:09:21 <roconnor> 5 5 is probably a good start
07:11:43 <sjanssen> gour: yeah, I read it
07:11:51 <roconnor> ndm: just so you know the function take a b and return b^a
07:12:02 <gour> sjanssen: lot of ranting against haskell...
07:12:27 <sjanssen> gour: yes, and the ranting isn't even informed ranting
07:12:39 <psnl> gour: my initial reaction is "argh"
07:12:46 <roconnor> gour: cool,  Does it talk about hetrogenous lists?
07:12:54 <roconnor> @quote roconnor
07:12:55 <lambdabot>  life lesson from today: 1 closure is nice, 500 000 closures sucks
07:12:57 <roconnor> @quote roconnor
07:12:58 <lambdabot>  <roconnor> xerox: I'm dumber than a turning machine.
07:13:01 <roconnor> @quote roconnor
07:13:01 <lambdabot>  life lesson from today: 1 closure is nice, 500 000 closures sucks
07:13:08 <roconnor> bah, it doesn't have my law
07:13:09 <gour> roconnor: nope
07:13:18 <vegai> sjanssen: what kind of a Haskell rant would you write?
07:14:02 <roconnor> vegai: oooh, that's a good questiong
07:14:03 <pejo> Botje, have a look at O'Haskell, it's one way of "solving" it.
07:14:07 <sjanssen> vegai: I'd complain about a real problem with Haskell.  Predicting/fixing space usage in Haskell is tough
07:14:32 <sjanssen> it isn't like Haskell is perfect, there are plenty of things to rant about
07:14:34 <gour> right, getting better code out of the box would be nice
07:14:35 <roconnor> excactly.  I would probably rant about Haskell's general lack of control of space usage.
07:15:02 <sjanssen> roconnor: Haskell has ways to control it, they just aren't obvious
07:15:08 * gour would like to see hIDE too
07:15:10 <shapr> gour: I'm living okay without the EU, but this week I have one part of the EU here with me! My girlfriend is visiting the USA from Sweden. Since this is her first time in the USA, we have lots of touristy things planned.
07:15:10 <roconnor> perhaps unpredicable is a better word
07:15:27 <shapr> Actually, that was added in 6.6 ;-)
07:15:37 <shapr> unpredicative type system...
07:15:39 * shapr snickers
07:15:42 <gour> shapr: when are you coming back?
07:15:44 <arjanoosting> @seen Igloo
07:15:44 <lambdabot> Igloo is in #darcs and #haskell. I don't know when Igloo last spoke.
07:15:50 <roconnor> shapr: I hope you aren't trying to avoid sweden's conservative government
07:15:59 <weel_> has any of you used the HaXML DtdToHaskell tool on rather large DTDs? I have this designed-by-committee DTD for sociological data here that's 200K, though mostly comments, and it ends up translating to nearly 1MB of haskell and 9MB of object code
07:15:59 <gour> shapr: we're missing you here
07:16:03 <Igloo> arjanoosting: Hi
07:16:08 <shapr> gour: I may move back to the EU in a few years, it depends on how life goes.
07:16:36 <shapr> gour: You can come visit me :-)
07:16:40 <gour> shapr: oh, you moved to us for some time. got some job?
07:16:48 <shapr> gour: Yup, it's a nice job too.
07:16:56 <shapr> gour: Anyway, I have a comfortable couch if you want to come visit me.
07:17:00 <gour> shapr: smell on haskell?
07:17:17 <vegai> my rant would be about a lack of easy tutorials for some areas
07:17:24 <shapr> Smell on Haskell?
07:17:25 <earthy> shapr: so, that job in Haskell? :)
07:17:27 <gour> shapr: i don't have permanent job and visa-people don't like such visitors to us
07:17:27 <arjanoosting> Igloo: coud you upgrade the Cabal package the ghc6 deb? It is missing a module, see http://www.haskell.org/pipermail/libraries/2006-October/005996.html
07:17:30 <lambdabot> Title: Where is Distribution.Compat.FilePath in Cabal-1.1.6?, http://tinyurl.com/ycopp9
07:17:38 <shapr> earthy: Actually, yes!
07:18:06 <gour> shapr: wanted to visit my jyotish teacher last summer, but they didn't provide me visa :-(
07:18:10 <shapr> aww
07:18:13 <vegai> that's a useless rant, but I perceive it to be the worst part for now
07:18:56 <Igloo> arjanoosting: I'm more likely to package 1.1.6.2 under a different name, I think
07:19:10 <weel_> gour: it seems like they don't like an increasing number of kinds of visitors to the US...
07:19:22 <gour> shapr: so, it would be easier to come here during the summer-time (although today it's 26C :-)
07:19:38 <gour> weel_: they're in big fear ;)
07:19:48 <earthy> shapr: so, texas, then? :)
07:19:51 <Igloo> arjanoosting: We need a feature that isn't written yet to support cabal making dynamic libraries for GHCi, which is how GHCi will work on non-i386/amd64/powerpc/sparc
07:20:38 <arjanoosting> Igloo: so we should updatin SyntaxNinja's libghc6-cabal-dev package?
07:20:47 <vegai> roconnor: didn't sweden just elect a liberal government?
07:20:53 <Igloo> arjanoosting: I think that package should disappear
07:21:22 <arjanoosting> Igloo: what do you suggest then?
07:21:25 <roconnor> gour: Nice rant: ``I dunno - I can't prove it but I think there's something cheesy about this.''
07:21:39 <roconnor> well thought out
07:21:41 <roconnor> :P
07:21:46 <Igloo> arjanoosting: libghc6-cabal-{new|snapshot|dev|some better name}-dev
07:21:47 <gour> :-)
07:22:10 <Igloo> containing a cabal-{new|...} package
07:22:51 <arjanoosting> That wil be a new package then?
07:22:59 <psnl> ndm: would you hang me if I used the state monad in hatgui ?
07:23:10 <Igloo> It will be the Cabal package renamed, but it will have to go through NEW, yes
07:23:52 <roconnor> gour: I will assume ``something just tells me so'' means ``unevaluated thunks can accumlate in recursive functions and blow memory performance''
07:23:53 <arjanoosting> But that will not fix the missing  Distribution.Compat.FilePath in the Cabal package then
07:24:25 <gour> roconnor: i've similar experience telling some python people about merits of the haskell, but they just repeat similar rants - prooving in practice does not exist, type-inference is nothing special, C, C++, Java, C#, Fortan, VB are typed languages too, type-erros are very rare so no use of it, haskell is dogmatic and limiting due to 'no side-effects' etc.
07:24:41 <Igloo> arjanoosting: Right, I don't think we should mess around with the libraries provided by GHC as then people developing on Debian will make libraries other people can't use
07:25:17 <Igloo> arjanoosting: But people who need it just use -package Cabal-whatever instead of -package Cabal when compiling Setup.hs
07:25:28 <roconnor> gour: yeah, one big problem with the main stream ``typed languages'' is that they are missing disjoin union types.
07:25:52 <roconnor> So this means people don't actually know what even a limited HM type system can do.
07:26:04 <arjanoosting> Igloo: I understand
07:26:27 <gour> roconnor: right, never used haskell, but free to rant about it
07:26:28 <sjanssen> if type errors are so rare, why does the typechecker catch at least one error per program I write?
07:26:36 <Igloo> arjanoosting: We could do it with libghc-cabal-dev, but we don't really cope very well with 2 packages providing the same cabal package
07:26:58 <arjanoosting> Igloo: but why not use the libghc6-cabal-dev package instead of introducing a new debian package
07:27:59 <Igloo> arjanoosting: If you did that, and it provided libghc6-cabal-prof, then pbuilder would fall over if you depended on libghc6-cabal-prof, for example (as it wouldn't know whether to choose that or ghc6)
07:28:39 <Igloo> arjanoosting: Also, which Cabal was used would depend on whether that package happened to be installed, which shouldn't matter in this case, but is a bit ugly in general
07:29:13 <arjanoosting> Igloo: so a different name for the Debian package. Also for the name used by ghc-pkg?
07:29:21 <Igloo> Yup
07:29:34 <roconnor> Actually I think it would fun to get programers together to lecture about what sucks abou their favourite programming language.
07:29:45 <arjanoosting> Igloo: that seems ugly
07:29:51 <gour> Igloo: any news about http://hackage.haskell.org/trac/ghc/ticket/724 ? it prevents me to build gtk2hs even when i disable logging on gentoo
07:29:55 <lambdabot> Title: #724 (tee complains if used in a process started by ghc) - GHC - Trac, http://tinyurl.com/szywh
07:30:31 <arjanoosting> Igloo: If you need a newer version you suddenly need -package Cabal-new instead of -package Cabal
07:30:41 <Igloo> gour: we don't have a solution yet, and it probably requires too much of a rewrite to be in 6.6.1
07:31:23 <gour> Igloo: :-( is the are rough eta for 6.8 ?
07:31:29 <gour> s/the/there
07:32:13 <Igloo> arjanoosting: Personally I regard that as a feature - if you are making a library that won't work with plain old GHC 6.6 as released then you need to do something special
07:32:26 <Igloo> gour: No
07:33:03 <gour> Igloo: ok, ta
07:33:33 <Igloo> gour: It might make 6.6.1 after all, though. We'll have to see what the solution looks like when we've made it...
07:33:58 <gour> Igloo: all the best ;)
07:35:08 <arjanoosting> Igloo: it will make things inconsistent. If someone install a new Cabal version by hand he does not need the new name for ghc-pkg but if he installs it using apt-get he does
07:37:28 <Igloo> arjanoosting: I agree there are arguments either way, we just prefer different outcomes  :-)
07:37:37 <arjanoosting> Igloo: if a library needs a feature only available in a newer version it should use Cabal >= 1.1.6.2 etc
07:39:32 <arjanoosting> Igloo: I don't see the problem with using the same ghc-pkg package name
07:40:12 <Igloo> arjanoosting: But a different Debian package name?
07:40:51 <Igloo> arjanoosting: I think the only problem then would be if Cabal doesn't stay backwards compatible
07:42:07 <Igloo> arjanoosting: Maybe that is the best way
07:43:43 <Igloo> arjanoosting: Is that what you meant?
07:43:58 <arjanoosting> Igloo: if it is backwards compatible the ghc-pkg name should not change
07:45:14 <arjanoosting> Igloo: but even the different Debian package name confuses me. ghc provides libghc6-cabal-dev, But what is the problem with having a package with the name of libghc6-cabel-dev as well?
07:45:21 <ndm> psnl: why can't you use the IO monad? since Gtk requires that everywhere
07:46:30 <arjanoosting> Igloo: if a need a newer version than ghc6 ships in my Debian package I can use Build-Depends: libghc6-cabal-dev (>= 1.1.6.2)
07:47:52 <Igloo> arjanoosting: One problem is that if both provide libghc6-cabal-prof and another library uses cabal then pbuilder and possibly the autobuilders will not be able to satisfy the dependencies
07:48:42 <arjanoosting> Igloo: s/libghc6-cabal-prof/libhgc6-cabal-dev/ ^^ ?
07:49:00 <Igloo> No, -dev is OK because the real package is chosen
07:49:18 <ndm> psnl: and how would you combine the IO and State monads? Monad transformers I would hang you for ;)
07:49:25 <arjanoosting> Igloo: ah, now I understand!
07:50:00 <arjanoosting> Igloo: just make libghc6-cabal-prof a real package as well
07:50:12 <roconnor> StateT IO?
07:51:55 <psnl> dang
07:52:34 <ndm> psnl: why do you need state, when you have IO and IORef's?
07:53:52 <arjanoosting> Igloo: if the haskell-cabal source package builds the binary package libghc6-cabal-dev and libghc6-cabal-prof the autobuilders should always be able to fullfill the Build-Depends
07:55:05 <Igloo> arjanoosting: Yes, that is true. It just unnerves me to have 2 packages providing the same cabal package, so it being hard to be sure you are getting the one you want
07:55:54 <Igloo> arjanoosting: It's also harder to make sure you make your binary deps correctly, as well
07:56:36 <psnl> ndm: I'll just use a few IOrefs
07:56:42 <arjanoosting> Igloo: a little bit harder, but it is possible
07:57:21 <arjanoosting> Igloo: my little make-haskell-depends script can do it
07:57:21 <ndm> psnl: if you really need state, fine, but IORefs will probably be more readable, and more Haskell98, which is a goal of Hat
07:57:42 <Igloo> arjanoosting: How does it work out which Cabal was used?
07:58:02 <Igloo> (I guess you could just conservatively depend on all of them, if nothing else)
07:58:53 <arjanoosting> It needs the file which is used to register with ghc-pkg, looks at the depends, determines the corresponding files, and use dpkg -s to find the corresponding package
07:59:01 <ndm> psnl: are you able to submit patches as you go? would keep the repo and your stuff closer together
07:59:15 <Igloo> Ah, OK
08:00:18 <Pete_I> if everything in haskell is a function, why can't you redefine the function '1'?
08:00:23 <arjanoosting> Igloo: https://moonshine.dnsalias.org/svn/arjan-public/debian/haskelldb/trunk/debian/mk-haskell-depends
08:00:25 <lambdabot> http://tinyurl.com/yhofpe
08:00:35 <ndm> Pete_I: who said everyting was a function? 1 isn't, its a value!
08:00:43 <Pete_I> ....
08:00:58 <Pete_I> everything's a function, that's what 'purely functional' means :/
08:01:21 <sjanssen> Pete_I: when we say "purely functional" we mean no side effects
08:01:40 <Pete_I> ....but then how can I/O be possible?
08:02:15 <sjanssen> ... except in special, controlled contexts, like the IO monad
08:46:40 <Pete_I> how do you check if a number is a whole number?
08:47:52 <Botje> type, preferably
08:48:37 <dcoutts> ie use Int, Integer (or Rational)
08:48:41 <palomer> very carefully
08:49:03 <Pete_I> i'm trying to filter out the 1.22222234 and the like
08:49:40 <dcoutts> you can format a float to a certain number of decimal places
08:49:45 <dcoutts> when converting to a string
08:50:05 <Pete_I> not using strings. it's math :)
08:50:40 <dcoutts> Pete_I, you'll probably need to explain what you're doing.
08:51:25 <Pete_I> someone in #math said there're no primes above 7 for which (\x->(x,(11^2+24*x)**0.5) returns a natural number.
08:52:12 <Pete_I> i'm trying to find said numbers. i'm sure they exist.
08:52:43 <dcoutts> ah ok, so you're doing floating point and want to find if it's probably an integer
08:52:45 <Botje> you could try truncating it and comparing it to itself?
08:52:47 <dcoutts> then use floor
08:53:03 <dcoutts> and compare within a certain tolerance
08:53:15 <Pete_I> ah, that'll work
08:53:53 <dcoutts> err, round, not floor
08:53:59 <dcoutts> you want to round to nearest
08:54:03 <dcoutts> @type round
08:54:05 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:55:20 <dcoutts> @hoogle inRange
08:55:22 <lambdabot> Ix.inRange :: Ix a => (a, a) -> a -> Bool
08:57:09 <dcoutts> > (\x -> let rx = round x; d = 0.01 in x < rx + d && x > rx - d ) 2.009999
08:57:10 <lambdabot>  Add a type signature
08:57:13 <dcoutts> bah
08:57:18 <dcoutts> > (\x -> let rx = round x; d = 0.01 in x < rx + d && x > rx - d ) (2.009999 :: Double)
08:57:19 <lambdabot>  add an instance declaration for (Integral Double)
08:57:20 <lambdabot>   In the definition of ...
08:57:47 <chessguy> why isn't this code working?
08:57:50 <chessguy> > [p | p <- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113], floor((11^2+24*p)^0.5) == ((11^2+24*p)^0.5)]
08:57:52 <lambdabot>  Add a type signature
08:58:58 <Botje> you need to reconvert the floor to a Float (or whatever you're using)
08:59:06 <dcoutts> > (\x -> let rx = fromIntegral (round x); d = 0.01 in x < rx + d && x > rx - d ) (2.009999 :: Double)
08:59:08 <lambdabot>  True
08:59:15 <dcoutts> > (\x -> let rx = fromIntegral (round x); d = 0.01 in x < rx + d && x > rx - d ) (2.01 :: Double)
08:59:17 <lambdabot>  False
08:59:19 <dcoutts> yep.
08:59:40 <dcoutts> isInt :: RealFrac a => a -> Bool
08:59:41 <dcoutts> isInt x = let rx = fromIntegral (round x); d = 0.01 in x < rx + d && x > rx - d
09:08:59 <chessguy> > isInt 3
09:09:02 <lambdabot>  Not in scope: `isInt'
09:09:53 <chessguy> > let isInt x = let rx = fromIntegral (round x); d = 0.01 in x < rx + d && x > rx - d in isInt 3.0
09:09:55 <lambdabot>  True
09:10:00 <chessguy> > let isInt x = let rx = fromIntegral (round x); d = 0.01 in x < rx + d && x > rx - d in isInt 3.1
09:10:02 <lambdabot>  False
09:22:48 <deelan> dcoutts_:  Are you there?
09:22:57 <dcoutts> deelan, aye
09:23:49 <deelan> Could you join #verbamanent? There's xerox in there. (It cannot join haskell).
09:23:58 <deelan> *He cannot
09:38:01 <araujo> yay!
09:38:25 * araujo throws shuriken lambdas
09:45:34 <bdbit> hi all :>
09:46:40 <bdbit> I have a question about the (n+1) notation. the Haskell tutorial at moonnbase.wwc.edu states that the factorial function can be expressed as "fac 0 = 1 \n fac (n+1) = product [1..(n+1)]"
09:46:48 <bdbit> why does this definition use (n+1)?
09:48:13 <ropine> to imitate the way factorial is defined in most math textbooks?
09:48:43 <bdbit> argh, I've never read the definition of factorial in a textbook
09:49:08 <bdbit> would it be equal to leave out the (+1) ?
09:49:39 <ropine> fac 0 = 1
09:49:40 <ropine> fac n = product [1..n]
09:49:40 <ropine> should work (although I haven't tested it)
09:50:12 <araujo> > let fac 0 = 1 ; fac n = product [1 .. n] in fac 6
09:50:14 <lambdabot>  720
09:50:24 <araujo> > let fac 0 = 1 ; fac n = product [1 .. n] in fac (-3)
09:50:25 <AtnNn> > product [1..0]
09:50:26 <lambdabot>  1
09:50:27 <lambdabot>  1
09:50:46 <ropine> > let fac n = product [1 .. n] ; fac 0 = 1 in fac 6
09:50:47 <lambdabot>    Warning: Pattern match(es) are overlapped
09:50:47 <lambdabot>        In the definition...
09:51:20 <Botje> fac is frequently defined in terms of f(n), not f(n+1)
09:51:26 <araujo> Thoguh (imho) using product is kind of cheating
09:51:27 <araujo> :-}
09:51:38 <ropine> > let fac n | n > 0 = product [1 .. n] ; fac 0 = 1 in fac 6
09:51:40 <lambdabot>  720
09:51:44 <dcoutts> integral, ping
09:51:45 <bdbit> It is, but i like that kind of cheating ;)
09:52:00 <Botje> however, fib (n+2) = fib(n+1) + fib(n)
09:52:04 <dcoutts> integral, xerox want's to know if you're going to the google thin in london tomorrow.
09:52:10 <bdbit> Botje: clear.
09:52:24 * araujo off to eat .. brb
09:53:36 <bdbit> Botje: from a definition like this, can Haskell figure out the way to turn it into a directly calculatable function?
09:53:57 <Botje> bdbit: it's syntactic sugar, really
09:54:09 <bdbit> of course
09:54:09 <Botje> it doesn't work for much else iirc
09:54:14 <bdbit> but it's recursive
09:54:40 <bdbit> i'd like to know if it'll be compiled into "recursive" bytecode/asm or if it will be "optimized" to be directly calculatable
09:54:59 <bdbit> unfortunately I don't know the correct mathematical terms..
09:55:01 <Botje> bdbit: it gets translated to a normal form by the compiler
09:55:19 <bdbit> Botje: one that is no longer recursive?
09:55:30 <ropine> of course you'd also need to define fib 0 and fib 1 to give the base cases for the recursion
09:55:45 <bdbit> yes.
09:55:53 <Botje> bdbit: it's still recursive. it always will be.
09:56:06 <Botje> but the compiler might do some memoziation so not _ALL_recursion steps have to be made twice
09:56:14 <bdbit> Botje: I don't know how it's called, but theres a way to make a recursive definition .... direct
09:56:31 <ropine> Y combinator?
09:56:38 <Botje> bdbit: tail recursion?
09:56:46 <bdbit> Botje: I don't know what that is :D
09:56:55 <Botje> bdbit: you can always make a normal recursive proces iterative
09:57:04 <Botje> tree recursion is a mite trickier but still doable
09:57:25 <bdbit> not iterative
09:57:35 <bdbit> duh, I have no examples
09:57:47 <Botje> brb
09:57:49 <bdbit> let's forget it
09:57:56 <bdbit> I'll keep learning haskell ^^
09:58:08 <bdbit> if only GHC would install O_o
10:05:56 <chessguy> @hoogle (Integral a, RealFrac b) => a -> b
10:05:58 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
10:05:59 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
10:05:59 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
10:07:59 <chessguy> ?instanceOf Floating Integer
10:08:01 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
10:09:58 <marcot> Hello!
10:10:25 <marcot> I'm using gtk2hs, and I can't use drawWindowGetPointer, it always returns Nothing.
10:10:34 <marcot> I don't know if it's a GTK or a gtk2hs issue.
10:11:27 <dcoutts> marcot, it returns Nothing if it's not over your window.
10:11:55 <marcot> dcoutts: Yes, that's what is in the doc. In my app it always returns Nothing.
10:12:14 <marcot> @paste
10:12:15 <lambdabot> http://paste.lisp.org/new/haskell
10:12:24 <dcoutts> marcot, do you have any window on top of the one you're interested in, eg a transparent one
10:12:31 <dcoutts> or an event box
10:13:05 <marcot> dcoutts: I guess not, I'm not really sure.
10:13:13 <marcot> dcoutts: I mean, I would know if I had one, right?
10:13:20 <dcoutts> probably
10:14:03 <marcot> dcoutts: I didn't got the point of that Bool parameter in onMotionNotify.
10:14:10 <marcot> dcoutts: Could it be related to that?
10:14:15 <dcoutts> marcot, yes it could.
10:14:19 <dcoutts> (I think)
10:14:41 <marcot> I'll try it with False.
10:14:42 <marcot> hehehe
10:15:17 <mux> dcoutts: hey!
10:15:22 <dcoutts> @arr!
10:15:23 <lambdabot> Yo ho ho, and a bottle of rum!
10:15:28 <mux> dcoutts: are there any gstreamer bindings for haskell available? :)
10:15:34 <marcot> paste.lisp.org is down.
10:16:12 <marcot> dcoutts: Same result with false.
10:16:23 <dcoutts> mux, I think Igloo had some a while ago, don't know of their current state.
10:16:24 <Igloo> I have partial gstreamer bindings, yes
10:16:31 <Igloo> I can't remember if it's, err, 0.8, 0.10 or something inbetween
10:16:48 <Igloo> http://urchin.earth.li/~ian/cabal/gstreamer/
10:16:49 <lambdabot> Title: Index of /~ian/cabal/gstreamer
10:17:02 * Igloo also can't remember how nice they are
10:17:03 <dcoutts> marcot, the Event tells you the x,y btw, so usually you don't need drawWindowGetPointer anyway.
10:17:12 <lray80de> a question to HaXML: Is there a possibility to, when parsing html-documents, jsut ignore style-attributes within tags and javascript-tags at all? They are throwing errors... ?
10:17:16 <marcot> dcoutts: hum..
10:17:37 <dcoutts> marcot, see the Motion event
10:17:44 <mux> dcoutts, Igloo: ok thanks
10:17:50 <marcot> The    application now has to state that it is ready for the next message by    calling drawWindowGetPointer.
10:18:11 <dcoutts> marcot, yes, but you don't need to look at the result of drawWindowGetPointer in that case.
10:18:19 <marcot> dcoutts: But I gotta call it?
10:18:38 <dcoutts> marcot, if you use onMotionNotify True, yes.
10:20:22 <marcot> dcoutts: hum..
10:23:58 <marcot> When I define data T = T {x :: Int, y :: Int}
10:24:08 <marcot> Is there a easy way to get x?
10:24:27 <marcot> Where do I get a simple doc about this kind of definition?
10:24:52 <dcoutts> marcot, yes, use 'x'
10:25:09 <dcoutts> if I have a value of type T then I just apply x
10:25:14 <Botje> marcot: they're called records, i believe
10:25:43 <dcoutts> marcot, in your case you'd say: eventX event
10:26:04 <marcot> hum.
10:26:05 <marcot> Nice.
10:26:39 <dcoutts> or: onMotionNotify False $ \Motion@{ eventX = x, eventY = y } -> do ....
10:27:01 <dcoutts> that is the record pattern matching syntax
10:27:06 <dcoutts> oops
10:27:14 <marcot> dcoutts: But this eventX is not relative to the draw window.
10:27:15 <dcoutts> Motion { eventX = x, eventY = y }
10:27:22 <dcoutts> without the @
10:28:15 <dcoutts> marcot, are you sure ? I thought it was.
10:28:28 <dcoutts> the docs say "The x and y attributes contain the coordinates relative to the DrawWindow associated with this widget."
10:29:45 <marcot> dcoutts: Sorry, I didn't saw this.
10:56:38 <Igloo> dcoutts: Did alex ever do the substitutions on teh manpage variables itself?
10:56:51 <Igloo> dcoutts: My 2.0.1 build script does it itself
10:57:11 <dcoutts> Igloo, in that case then probably it never did.
10:57:28 <dcoutts> afterall it wasn't in the AC_CONFIG_FILES
11:14:45 <roconnor> @pl llo a w = writeInstruction $ LLO a w
11:14:46 <lambdabot> llo = (writeInstruction .) . LLO
11:14:52 <roconnor> @pl llo a w c = writeInstruction $ LLO a w c
11:14:53 <lambdabot> llo = ((writeInstruction .) .) . LLO
11:20:33 <roconnor> @pl \f g -> ((f .) .) . g
11:20:34 <lambdabot> (.) . (.) . (.)
11:21:26 <roconnor> you guys call this (.::) ?
11:22:19 <araujo> aren't we cool?
11:22:44 <roconnor> it's a useful function.  I want to give it the ``standard'' name
11:22:58 <araujo> (.) :: ....
11:25:11 <Botje> aagh! it's something with three boobs!
11:29:47 <araujo> > ((.) . (.)) (* 9) (+) 500 500
11:29:48 <lambdabot>  9000
11:32:37 <cjeris> @hoogle [m a] -> m [a]
11:32:38 <lambdabot> Prelude.head :: [a] -> a
11:32:39 <lambdabot> Prelude.last :: [a] -> a
11:32:39 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
11:34:44 <emu> @type liftM head
11:34:46 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m a
11:36:21 * shapr does a functional kata, the 'normal form'.
11:37:40 <vincenz> j oasis
11:37:45 <Syzygy-> Functional katas?!
11:38:22 <Syzygy-> @type ((.).(.))
11:38:23 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:38:54 <Syzygy-> Oooookay. This pl-stuff weirds me out...
11:40:54 <emu> @type ((.)$(.))
11:40:55 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
11:47:06 <SamB> @type ((.).)
11:47:08 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
11:51:37 <cjeris> is 'sequence' a primitive?  i'm having trouble finding the source
11:52:55 <twanvl> http://haskell.org/onlinereport/standard-prelude.html#$vsequence
11:52:57 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y7a4zo
11:53:31 <cjeris> oh, the prelude source isn't in the ghc docs.  sorry!  thanks!
12:08:29 <SamB> cjeris: the princess is in another castle!
12:08:39 <SamB> @hoogle sequence
12:08:40 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:08:40 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
12:08:40 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
12:08:44 <SamB> hmm...
12:09:07 <SamB> @fptools Control.Monad.sequence
12:09:08 <lambdabot> Control.Monad.sequence not available
12:09:12 <SamB> @fptools Control.Monad
12:09:13 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
12:09:48 <SamB> ^ there, try that castle ;-)
12:14:59 <palomer> so...what programming language is slated to replace haskell?
12:16:05 <pzpz> haskell++
12:16:31 <palomer> maybe people will come back to their senses and start using a real programming language
12:16:33 <palomer> like C++
12:17:21 <dylan> lol
12:18:00 <palomer> I wasn't joking, mister!
12:18:07 <sieni> INTERCAL!
12:19:24 <sjanssen> > "INTERCAL" `isPrefixOf` "INTERCALATE"
12:19:25 <lambdabot>  True
12:19:38 <palomer> lies!
12:19:54 <sjanssen> @palomer
12:19:54 <lambdabot> woof
12:20:28 <palomer> hrmph, I have to wait a few days so my supervisor THINKS I'm working
12:20:34 <palomer> then I'll ask her a question as if I'm stuck
12:20:45 <palomer> I'm thinking I can get her to do  the whole thesis this way
12:21:00 * palomer really really hopes she's not on this channel
12:21:26 <sylvan> palomer, what's your thesis about?
12:23:05 <palomer> GADTs
12:23:42 <sylvan> cool... just GADTs in general?
12:25:08 <SamB> hmm... so the new threaded stuff gets rid of black-holing?
12:25:33 <SamB> I mean, the SMP stuff?
12:28:18 <tibbe> black holes?
12:29:01 <Maddas> palomer: haha
12:30:58 <Maddas> tibbe: I think the paper "Haskell on a Shared-Memory Multiprocessor" explains those things.
12:31:23 <Maddas> (Well, it does explain them, I think it's worth reading as an explanation.)
12:31:54 <tibbe> good cause the other kind suck
12:32:08 <Maddas> :-)
12:34:48 * SamB was the one asking about SMP :-P
12:35:38 <SamB> black holes are just heap objects that have had their info pointer overwritten with a blackhole info pointer, aren't they?
12:36:09 <SamB> er.
12:36:16 <SamB> thats not a good explanation though ;-)
12:36:37 <tibbe> que?
12:36:48 * tibbe scratches his head
12:37:16 <SamB> they were THUNK objects that were entered, and had their info pointers replaced so that, if entered again, you'd get this:
12:37:21 <SamB> > fix id
12:37:22 <lambdabot>  Add a type signature
12:37:25 <SamB> > fix id :: ()
12:37:26 <lambdabot>  Exception: <<loop>>
12:38:03 <SamB> and so that other heap objects they had referenced would not be kept around
12:39:33 <SamB> so, basically I'm wondering how they avoid the space leaks ;-)
12:39:55 <SamB> if they don't have black holes anymore
12:40:26 <SamB> @google "Haskell on a Shared-Memory Multiprocessor"
12:40:28 <lambdabot> http://research.microsoft.com/~simonpj/papers/parallel/index.htm
12:40:29 <lambdabot> Title: Haskell on a shared-memory multiprocessor
12:42:17 <tibbe> SamB, a little clearer now, thanks
12:42:30 <tibbe> I miss haskell, Java at work makes me misserable
12:42:30 <sjanssen> they don't have black holes anymore?
12:42:41 <tibbe> I only have to put up with it another month though
12:42:57 <SamB> tibbe: you *do* know what an info pointer is, right?
12:43:08 <tibbe> I saw a: public static final int ONE = 1; today
12:43:15 <SamB> eeeeeeeek
12:43:17 <tibbe> SamB, a vague idea but please explain
12:43:24 <sjanssen> I can still produce a "<<loop>>" error compiling with -threaded
12:43:46 <SamB> okay
12:44:00 <SamB> so maybe they haven't really been eliminated then...
12:44:13 <SamB> maybe they aren't black anymore or something...
12:44:37 <sjanssen> SamB: coincidentally, I was thinking about this earlier today, and I'm not sure how they do it now
12:45:22 <sylvan> tibbe: I know how you feel. Only worse. I have to use C/C++ every day...
12:45:33 <sjanssen> how does a thread know which thread "entered" the thunk?
12:46:20 <sylvan> sjanssen, it doesn't. It just knows that it's blackholed, and goes to a global "I am waiting on blackholed threads" queue
12:46:24 <SamB> I was reading the eval/apply paper and I wondered about that
12:46:41 <sylvan> s/threads/thunks
12:46:51 <sjanssen> sylvan: so when do we get <<loop>>?  When all threads are in the blackholed queue?
12:47:00 <tibbe> could someone recommend a couple of not too advanced papers, haven't read any in a couple of weeks
12:47:01 <SamB> sylvan: so how does the schedular know which thread entered the blackhole?
12:47:23 <tibbe> found one on patch theory for versioning software today
12:47:24 <sylvan> samB: I think it's the only one still alive?
12:47:35 <sylvan> I only browsed that paper a while back so I'm not 100% sure..
12:47:42 <SamB> oh, and I had heard that with SMP multiple threads were allowed to enter a single thunk
12:48:00 <SamB> sylvan: I meant
12:48:15 <SamB> if the same thread tried to reenter the thunk
12:48:35 <SamB> something clearly has to throw the exception
12:48:53 <SamB> it can't be the code in the thread, if the thread is blocked on the blackhole...
12:49:07 <sylvan> ah.. I guess the thread keeps track of which thunk it's currently in the process of evaluating or something...
12:49:19 <SamB> "which thunk"?
12:49:26 <SamB> that is a silly thing to say ;-)
12:49:26 <sylvan> s
12:49:53 <SamB> I bet its simpler than that
12:50:01 <sjanssen> yeah, the thread must keep track of which threads it has blackholed
12:52:03 <tibbe> are black holes a spin lock?
12:53:08 <sjanssen> ah
12:53:25 <sjanssen> the threads scan their own stack when they encounter a black hole
12:55:13 <tibbe> scan for what?
12:55:22 <tibbe> I'm not getting this, I blame the time
12:55:37 <tibbe> and I hadn't had any tea
12:55:38 <sjanssen> tibbe: for update frames
12:55:59 <sjanssen> tibbe: straight outta http://research.microsoft.com/~simonpj/papers/parallel/index.htm
12:56:01 <lambdabot> Title: Haskell on a shared-memory multiprocessor, http://tinyurl.com/v35af
12:56:13 <tibbe> I better read some introductory text on compilers for functional languages
12:56:14 <sjanssen> section 4.1
13:00:37 <SamB> hmm, apparantly they have not tackled unsafePerformIO yet
13:00:46 <SamB> beware, readFile users!
13:01:14 <SamB> well, this paper *is* from last year...
13:01:25 <SamB> but someone I talked to didn't think they had either...
13:01:36 <dcoutts> SamB, was that me ?
13:01:49 <SamB> dcoutts: it might have been
13:02:25 <SamB> then again maybe you and I were talking to a *third* person, who did not think they had tackled that yet...
13:02:30 <dcoutts> SamB, once I get my dual core amd64 installed I'll try and reproduce that potential bug
13:02:39 <dcoutts> SamB, that was JaffaCake
13:02:46 <SamB> wouldn't it be "produce" rather than reproduce?
13:02:51 <dcoutts> yes, it would
13:02:58 <dcoutts> I was just going to say that :-)
13:03:05 <SamB> hehe
13:04:00 <roconnor> @type writeFile
13:04:01 <lambdabot> FilePath -> String -> IO ()
13:04:21 <SamB> oh, lazy blackholing eh?
13:05:41 <arjanoosting> SyntaxNinja: I am trying to package to package the new Hugs, but I am seeing this: /home/arjan/debian/WIP/hugs98-98.200609.21/packages/GLUT/dist/build/Graphics/UI/GLUT/Fonts.so: undefined symbol: glutStrokeMonoRoman
13:05:54 <roconnor> @hoogle handle -> String -> IO ()
13:05:55 <lambdabot> Did you mean: Handle -> String -> IO ()
13:05:59 <roconnor> @hoogle Handle -> String -> IO ()
13:06:00 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
13:06:01 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
13:07:24 <roconnor> @hoogle bracket
13:07:24 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:07:25 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
13:07:25 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
13:07:44 <roconnor> @docs IO.bracket
13:07:44 <lambdabot> IO.bracket not available
13:07:51 <roconnor> @docs IO
13:07:52 <lambdabot> IO not available
13:07:55 <roconnor> @docs System.IO
13:07:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
13:09:50 <roconnor> If I begin a file with #!/usr/bin/runghc then I can just execute a literate haskell file, right?
13:10:16 <dcoutts> roconnor, I think so.
13:10:49 <SamB> oh, sweet
13:11:04 <arjanoosting> SyntaxNinja: I see the same error in the buildd logs of Hugs, so it seems GLUT is broken in Debian hugs,
13:11:07 <SamB> they don't only check the STM logs at the end of STM computations ;-)
13:11:46 * SamB wonders if he knew that
13:13:10 <SamB> mmm, frozen stacks
13:13:25 * SamB wonders what frozen stacks taste like
13:15:24 <roconnor> @pl \fn f s -> bracket (openFile fn WriteMode) hClose (\h -> f h s)
13:15:25 <lambdabot> (. flip) . (.) . flip bracket hClose . flip openFile WriteMode
13:24:13 <SyntaxNinja> arjanoosting: ah. hm
13:24:43 <arjanoosting> I went to the buildd logs and it was never build correctly
13:25:14 <arjanoosting> SyntaxNinja: should it work with Hugs?
13:25:55 <SyntaxNinja> arjanoosting: I've never known of a problem, but maybe I just didn't notice.
13:26:21 <SyntaxNinja> you're saying that the previous builds Hugs in Debian had a GLUT related error?
13:26:21 <arjanoosting> SyntaxNinja: no one ever complained
13:26:53 <arjanoosting> previous builds of Hugs in Debian did not include GLUT yes
13:27:50 <arjanoosting> first it was not build due to a missing build-dep on freeglut-dev but even with the build-dep the build of the GLUT package fails
13:28:47 <arjanoosting> see for instance http://buildd.debian.org/fetch.cgi?pkg=hugs98;ver=98.200503.08-4;arch=amd64;stamp=1143030319
13:28:50 <lambdabot> Title: buildd.debian.org: log of hugs98_98.200503.08-4/amd64 received Wed Mar 22 12:25: ..., http://tinyurl.com/ylanjm
13:44:37 <roconnor> @type fromEnum
13:44:39 <lambdabot> forall a. (Enum a) => a -> Int
13:59:24 <Botje> how do you take the nth root from a number? eg 8 SOMETHING 3 = 2
14:00:14 <Botje> I could jump back to logarithms, but that's kind of evil
14:02:23 <audreyt> @pl something x = (x **) . (1/)
14:02:23 <lambdabot> something = (. (1 /)) . (**)
14:02:29 <glguy> http://www.deviantart.com/deviation/18579726/?qo=14&q=netbsd&qh=boost%3Apopular+age_sigma%3A24h+age_scale%3A5
14:02:39 <audreyt> Botje: there you go
14:03:15 <Botje> ah.
14:03:23 <Botje> I was looking at ^^, which only supports integral powers
14:03:24 <Botje> thanks!
14:03:45 * integral suggests not raising anything to his power
14:04:05 <lambdabot> Title: GNU's Not Usable by ~antignu on deviantART, http://tinyurl.com/v7lt8
14:04:15 <Botje> except elephants.
14:04:41 <audreyt> np :)
14:15:53 <Lemmih> glguy: eh?
14:16:40 <glguy> I found that while looking for a wallpaper image. I thought to share it (-:
14:33:42 <svref> so I've got a huge pile of code that dies at some point with a match failure, and I can't figure out how to get a backtrace.  I've been ****ing around with Hat for days, but its installation seems hopelessly compromised on my debian/ubuntu systems.  Other ideas?
14:34:00 <ndm> svref: what is the text of the pattern match failure?
14:34:45 <ndm> svref: and email the hat team telling them their installation is crap, and what you'd suggest they do to fix it
14:35:06 <svref> ndm: its not one big problem with hat, its a death by a million little problems.
14:35:07 <Cale> Supposedly compiling with profiling and -xc is supposed to help?
14:35:34 <ndm> svref: hit a hat developer with a big stick for each issue, they'll learn :)
14:35:34 <svref> ndm: "Main: DoublyLinked.hs:(39,0)-(42,19): Non-exhaustive patterns in function go"
14:35:47 <ndm> svref: so you know exactly where the error is, surely?
14:35:55 <Cale> svref: could you add more patterns to that function?
14:36:14 <svref> well, I wrote the "go" function, but finding the caller of "go" is the tricky part.
14:36:29 <Cale> Isn't it recursive? :)
14:37:16 <svref> Cale: go is _supposed_ to fail with the arguments its called on...
14:37:26 <Cale> okay
14:37:39 <Cale> can we see?
14:37:53 <svref> sure...one sec
14:38:22 <svref> Cale: http://www.osaurus.us/~dm/tmp/lanes.tar.gz
14:38:38 <svref> Cale: compile with "hmake -package GLUT Main"
14:42:53 <svref> I'm just used to finding out the callers of a failing function in 5 seconds, and moving to Haskell, it seems like its much harder than that.
14:43:47 <ndm> svref: if hat worked.... - would take you ~2 seconds
14:44:06 <ndm> svref: really, just email the hat developers, repeatedly, demand fixes, tell them their software is unuseable
14:44:15 <ndm> svref: make them feel bad :)
14:44:57 <svref> ndm: sigh...okay, I'll pester them.
14:45:08 <svref> ndm: but in the meantime I want to actually code.  :P
14:45:32 <Cale> okay
14:45:51 <Cale> so... it looks like there's only one call to go in the whole program
14:46:14 <Cale> er, no, !! does
14:47:01 <Cale> but there's only one call to that
14:47:06 <svref> Cale: so is your approach to grep for callers?
14:47:10 <Cale> yep
14:47:27 <Cale> If there's only a few, we don't have to be all that complicated about it :)
14:47:43 <svref> Maybe if you have a running hat on your machine, you could do "hmake -hat -package GLUT Main" and find the error in O(1).
14:48:00 <Cale> so apparently, it looks like oldlink in stripes'allow'lane'change might be Nil
14:48:27 <Cale> which means that lanenum'to'lanelink oldlane straight'link is Nil
14:51:55 <Cale> perhaps we should insert some calls to Debug.Trace. Are DL's printable?
14:51:57 <svref> I'm with you.
14:52:28 <Cale> We know that straight'link is actually a Straight
14:52:42 <Cale> or else there would have been pattern match failure in lanenum'to'lanelink
14:53:17 <Cale> However, it appears that calling go x (laneNum * 2 + 1) has resulted in Nil, or was passed Nil initially
14:54:34 <Cale> import Debug.Trace
14:54:34 <Cale> tqw x = trace (show x) x
14:54:50 <svref> I didn't know about Debug.Trace.trace...
14:57:47 <Cale> [..(Straight [Stripe {positive = (Red,Solid), negative = (White,Solid)}....] 321.8688 11.176)..........]
14:57:47 <Cale> Main: DoublyLinked.hs:(39,0)-(42,19): Non-exhaustive patterns in function go
14:58:26 <Cale> that's the show of the value passed to lanenum'to'lanelink
14:58:42 <SamB> @hoogle ptext
14:58:43 <lambdabot> Text.PrettyPrint.HughesPJ.ptext :: String -> Doc
14:59:17 <guerra> anyone knows why when using ghc version 6.2.2 i can compile a file just as root? it says i don have permission to access a binary file.
14:59:19 <svref> Cale: ok, hm.
14:59:47 <svref> Cale, thanks for getting me moving again.
14:59:51 <Cale> I'm not quite sure how to interpret it
15:00:14 <Cale> but at least you'll be able to stick things in to print values as they're evaluated
15:00:33 <Igloo> guerra: Try stracing it?
15:00:48 <Cale> also, that looks different from the value that's passed all the other times
15:01:03 <guerra> Igloo: what u mean with stracing?
15:01:42 <Igloo> guerra: Run it under strace (or truss, or maybe something else, depending on your OS)
15:02:51 <guerra> Igloo: oh understood what is strace
15:04:22 <Botje> how do you convert an Integer to an Int ?
15:04:30 <Cale> Botje: fromIntegral
15:04:50 <Cale> or fromInteger, but fromIntegral will let you change an Int to an Integer as well
15:04:59 <Cale> or from an Int to a Double
15:05:05 <Cale> @type fromIntegral
15:05:07 <lambdabot> forall b a. (Num b, Integral a) => a -> b
15:05:10 <Cale> @type fromInteger
15:05:12 <lambdabot> forall a. (Num a) => Integer -> a
15:05:15 <Botje> sigh.
15:05:27 <Botje> I can't seem to figure it out
15:05:42 <Cale> > (3 :: Int) * (4 :: Integer)
15:05:44 <lambdabot>  Couldn't match `Int' against `Integer'
15:05:53 <Cale> > (3 :: Int) * (fromIntegral (4 :: Integer))
15:05:55 <lambdabot>  12
15:06:20 <Botje> how would I turn 8 ** (1/3) to an Int?
15:06:41 <chessguy> > (8 ^ (1/3)) :: Int
15:06:42 <lambdabot>  Add a type signature
15:07:04 <chessguy> > 8^(1/3)
15:07:04 <Botje> what if the 8 and 3 are Ints instead of numbers?
15:07:05 <lambdabot>  Add a type signature
15:07:16 <Cale> > 8 ** (1/3)
15:07:18 <lambdabot>  2.0
15:07:31 <chessguy> round $ 8 ^ (1/3)
15:07:35 <Cale> > (fromIntegral 8) ** (1/(fromIntegral 3))
15:07:37 <lambdabot>  2.0
15:07:42 <Cale> > round $ (fromIntegral 8) ** (1/(fromIntegral 3))
15:07:44 <lambdabot>  2
15:07:50 <Botje> really no better way to do it?
15:07:54 <Cale> you probably want to use where :)
15:08:07 <Cale> do all the conversions separately
15:08:38 <Botje> yay, working.
15:08:39 <Botje> at last.
15:08:55 <Botje> Instance of Floating Int required for definition of ... isn't particularly helpful :/
15:09:05 <Cale> It is, if you know what it means
15:09:16 <Botje> I sort of know what it means
15:09:34 <Cale> It means that you tried to apply some Floating operation, in this case **, to an Int, which isn't a member of the Floating class
15:39:11 <x3m> @seen foxy
15:39:11 <lambdabot> I saw foxy leaving #haskell-overflow and #haskell 2d 12h 34m 30s ago, and .
15:43:59 <dons> moin
15:44:04 <dons> ?uptime
15:44:05 <lambdabot> uptime: 2d 20h 39m 17s, longest uptime: 6d 15h 1m 36s
15:44:09 <dons> ?users
15:44:10 <lambdabot> Maximum users seen in #haskell: 256, currently: 226 (88.3%), active: 30 (13.3%)
15:47:46 <x3m> i tried like 10 different configurations and still got the same error with plugins
15:48:10 <dons> yet seems to work fine for others. very strange
15:48:34 <x3m> i supose it was intended to compile runplugs to binary?
15:48:37 <x3m> exe
15:49:01 <dons> yes. that should happen.
15:51:38 <x3m> i wonder where i got the runplugs.hs from, wonder if its the correct one
15:53:56 <palomer> haskell gives me a woody
15:54:34 <gds> http://www.debian.org/releases/woody/
15:54:35 <lambdabot> Title: Debian GNU/Linux 3.0 &ldquo;woody&rdquo; Release Information
15:59:29 <dons> in case people didn't see earlier, http://programming.reddit.com/info/o1l0/comments
15:59:32 <lambdabot> Title: Developing Gnome Apps with Glade in Haskell (reddit.com), http://tinyurl.com/vfhdk
16:01:56 <x3m> runghc --make main.hs -o runplugs ghc.exe: cannot use '--make' with '-e'
16:02:14 <x3m> but with ghc --make main.hs -o runplugs it works, why?
16:02:36 <Igloo> It doesn't make sense to both run a program and link a program at once
16:04:27 <dons> mmm. http://www.cas.mcmaster.ca/~carette/pa_monad/
16:04:28 <lambdabot> Title: Syntax extension for Monads in Ocaml
16:04:47 <gds> Hm - can I explicitly switch on the type of an argument...?
16:04:51 <dons> note the 3rd author ....
16:05:18 <dibblego> gds, I suspect something is wrong if you want to do that (I doubt you can, but I am no expert)
16:05:36 * gds is thinking about a pretty-printing thing :)
16:05:44 <gds> For debugging :)
16:06:04 <Igloo> You can have a function in a class, and have isntances for different types
16:06:42 <gds> indeed - but as is explained here:
16:06:46 <gds> http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced#Instances
16:06:48 <lambdabot> http://tinyurl.com/yh4x55
16:07:06 <gds> I can't do: instance Show a => Pretty a
16:07:19 <gds> (where prettyPrint  = show)
16:07:35 <gds> It's an OO thought, certainly :)
16:07:43 <Igloo> You can, with extensions, as long as you don't want any other Pretty a instances
16:08:01 <gds> Ah - that's interesting.
16:08:42 <gds> I think I /do/ want other Pretty a instances - or at least to override some of the Showable ones - how does one go about enabling/using the appropriate extension?
16:09:01 <gds> Or will it just work in ghci?
16:09:05 * gds tries...
16:09:27 <Igloo> -fallow-overlapping-instances
16:09:56 <gds> Ah - thankyou :)
16:10:00 <gds> I'll have a play :)
16:19:26 <gds> Apparently the options I needed for my ugly hackiness were "-fallow-undecidable-instances -fallow-incoherent-instances" ;)
16:20:06 * gds likes the idea of asking the compiler permision to be incoherent :)
16:20:27 <dons> its nice. people should come with a similar flag
16:21:03 <sieni> dons: they have such a flag; it's called beer.
16:21:26 <gds> :)
16:22:52 <dibblego> can concat be written in terms of foldr?
16:23:43 <dibblego> got it, never mind
16:24:13 <gds> Ah - I need -fallow-overlapping-instances too - since that avoids the runtime errors :)
16:24:27 <gds> Igloo: Thanks again :)
16:25:18 <Igloo> np
16:26:09 <coffeemug> hi
16:26:35 <psi> howdy
16:27:15 <dons> morning coffeemug
16:27:21 <dons> how's the code today?
16:27:23 <coffeemug> evening dons
16:27:31 <x3m> coffeemug: now ive tried building hs-plugins several times and i dont really get it to work. What config file did you use to start with?
16:27:48 <coffeemug> x3m: what do you mean by "what config"?
16:27:52 <coffeemug> what errors are you getting?
16:28:06 <coffeemug> dons: I'm trying to import fps I have installed into the newly built ghc
16:28:25 <coffeemug> so what I do is write ghc-pkg describe fps to a file
16:28:33 <x3m> coffeemug: the config.h file hs-plugins requires to build
16:28:35 <coffeemug> then try ghc-pkg-inplace to load it
16:28:46 <coffeemug> it works for all libs except fps
16:28:47 * ndm considers adding a -beer flag to Yhc, all i need is a semantics for it...
16:28:58 <coffeemug> with fps I get cbits can't be found or isn't a directory
16:29:07 <coffeemug> where is that include dir?
16:29:13 <coffeemug> x3m: I never had to tinker with it
16:29:22 <x3m> coffeemug: and did you build it through msys or the command prompt?
16:29:24 <coffeemug> x3m: which version of hs-plugins are you trying to build?
16:29:30 <x3m> 1.0 rc0
16:29:31 <dons> coffeemug: hmm? the fps build system should just register fps for you.
16:29:52 <coffeemug> dons: I built it and registered it with ghc 6.4.2
16:29:57 <dons> right.
16:29:59 <coffeemug> now I build ghc in another folder
16:30:05 <dons> which ghc?
16:30:11 <coffeemug> so I don't want to rebuild with it, I just want to import existing one
16:30:14 <coffeemug> ghc 6.4.2
16:30:19 <coffeemug> x3m: I did it with command prompt
16:30:20 <dons> ah ok.
16:30:33 <dons> so you'll need to go back to your fps build, and rerung the 'install' step
16:30:40 <dons> i.e. ./Setup.hs install
16:30:48 <dons> which will register it with the new ghc
16:30:52 <dibblego> why aren't all the list functions in List.hs? (such as ++)
16:31:01 <dons> some are in the Prelude
16:31:06 <dons> for hysterical reasons
16:31:06 <x3m> coffeemug: well how did you try it after you installed it? since runplugs requires system.posix.resource and thats nothing that exists in win by default
16:31:06 <coffeemug> x3m: what errors are you getting exactly?
16:31:28 <dons> x3m, right. you will have to remove the Posix deps if you want to use runplugs
16:31:30 <dons> we talked about this
16:31:34 <coffeemug> x3m: I tride make and load feature
16:31:37 <dons> unless, you can fake it via cygwin or some such
16:31:42 <coffeemug> not sure what runplugs is
16:31:48 <x3m> dons: i tried both variants
16:31:52 <dibblego> I can't find (++) in Prelude.hs
16:32:01 <x3m> cofeemug: make and load feature?
16:32:01 <dons> ?hoogle ++
16:32:02 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
16:32:03 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
16:32:03 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
16:32:13 <coffeemug> what is runplugs?
16:32:27 <x3m> something that obviously dont work
16:32:28 <Lemmih> The Prelude is probably re-exporting it from Data.List.
16:32:30 <coffeemug> x3m: yeah, just the _load, loaddyn functions of plugins
16:32:37 <dons> its a small wrapper over System.Plugins.Eval, used by lambdabot and others, to evaluate haskell fragments
16:32:45 <x3m> coffeemug: i havent used any of those, tell me more
16:32:47 <coffeemug> ahh
16:32:47 <dons> > 1+2 -- uses runplugs
16:32:49 <lambdabot>  3
16:32:55 <coffeemug> I didn't use runplugs
16:32:56 <coffeemug> I gotcha
16:32:58 <dibblego> $ cat Prelude.hs | grep "(++)"
16:32:58 <dibblego>     map, (++), filter,
16:33:01 <coffeemug> x3m: just go to the docs
16:33:03 <coffeemug> of fps
16:33:07 <coffeemug> sorry, plugins
16:33:11 <dons> dibblego: its imported from Base.hs
16:33:15 <coffeemug> and look at _load/pdynload and so on
16:33:28 <x3m> coffeemug: you cant just describe it a little fast?
16:33:52 <Cale> [] ++ ys = ys
16:33:54 <coffeemug> x3m: these are just functions that dynamically load a module and a symbol from it
16:34:01 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
16:34:17 <coffeemug> so you can point them to a .o file, tell them which symbol you want, they'll load up the module for you and return the value of that symbol
16:34:40 <x3m> coffeemug: got a code example that i can try?
16:35:07 <coffeemug> dons: so why do you think I can't do run-pkg-inplace register with fps?
16:35:11 <coffeemug> it works with all other libraries
16:35:18 <coffeemug> where should cbits normally reside?
16:35:27 <coffeemug> x3m: yeah, one sec
16:35:37 <dons> oh , that should be able to work. but i'm not sure of the full details. cbits shoudl live in the usual lib place
16:35:57 <dons> you're trying something non-standard, and getting a non-standard result, remember ;)
16:36:37 <coffeemug> x3m: got it?
16:36:49 <x3m> coffeemug: umm what?
16:37:06 <coffeemug> x3m: did you get the code?
16:37:17 <x3m> from where, you didnt send my any file or anything
16:37:18 <coffeemug> dons: isn't cbits a dir with c files?
16:37:28 <coffeemug> x3m: never mind, it's my irc client
16:37:32 <coffeemug> go to #haskell-overload
16:37:41 <coffeemug> or is it overflow?
16:37:46 <x3m> flow
16:38:16 <dons> mmm. all these ruby difficulties adding support for higher level abstractions (like threads and continuations) seem to beg for a haskell interpreter to storm the field...
16:39:14 <sieni> or a scheme interpreter
16:39:19 * sieni ducks
16:40:09 <dons> not if you want SMP ...
16:40:26 <dibblego> @let append [] ys = ys; append (x:xs) ys = x : append xs ys
16:40:27 <lambdabot> Defined.
16:40:34 <dibblego> ?check (++) a b = L.append a b
16:40:35 <lambdabot>  Parse error
16:40:43 <dibblego> how do I write that for lambdabot?
16:41:02 <dons> ?check \a b -> a ++ b == L.append (a :: T) (b :: T)
16:41:04 <lambdabot>  OK, passed 500 tests.
16:41:26 <dibblego> ah thanks
16:50:52 <dibblego> is YAHT available in HTML? (or some other non-PDF)
16:51:14 <dons> yeah, on the wikibook
16:51:27 <dibblego> ta
16:53:41 <coffeemug> dons: I get an error in ghci that says "unable to load plugins-1.0" when I try to load a file that uses that package
16:53:50 <coffeemug> is there some log file I can look at to see where the error is coming from?
16:54:03 <dons> that would mean that ghci can't see plugins, i.e. its not registered
16:54:13 <dons> did you register it inplace, but not register it for whatever ghci you're using?
16:54:27 <dons> (if you have a standard install, it should be visible everywhere, but if you're doing funny things ...)
16:55:13 <coffeemug> I'm doing funny things but it loads other libraries :)
16:55:22 <coffeemug> ok, then if I want to do it in "standard way"
16:55:34 <coffeemug> how would I build stuff using ghc-inplace?
16:55:40 <dibblego> how do people usually write build scripts for things like running haddock? with a .sh?
16:56:49 <dons> use Cabal
16:56:55 <dons> Setup.hs haddock  -- ;)
16:57:02 <dibblego> oh
16:57:49 <dibblego> by the way, I reckon that would be an awesome wiki entry
16:58:25 <dons> what's that?
16:58:26 <dibblego> laying out a typical haskell project then generating haddock, quickchecks, the coverage thingy (name?)
16:58:29 <dons> how to build a haskell ap?
16:58:34 <dons> yes. we have started this .. let me find the url
16:58:39 <dibblego> excellent thanks
16:59:10 <dons> ?wiki How_to_write_a_Haskell_program
16:59:11 <lambdabot> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:00:21 <ndm> dons: shouldn't there be a how to wriute a small haskell program? i.e. loading hugs, create a .hs file etc
17:00:38 <dons> yes, perhaps.
17:00:42 <dibblego> I was thinking for dummies
17:00:45 <dons> extending the haskell-in-5-steps guide
17:00:55 <dibblego> a layout of the most minimal haskell application
17:00:56 <dons> the above is about creating a new project I suppose.
17:01:00 <dons> ?where hnop
17:01:01 <lambdabot> http://semantic.org/hnop/
17:01:03 <dons> ^^
17:01:07 <dons> minimal haskell program
17:01:28 <dibblego> so that will do haddock, quickchecks, etc.?
17:02:30 <dons> it illustrates the cabal build system. inluding haddocks, but adding quickchecks is extra work
17:02:37 <dibblego> ok ta
17:02:38 <dons> should be doable if you read the cabal docs on adding tests
17:03:54 <coffeemug> dons: is there a version of "runhaskell-inplace" anywhere?
17:04:01 <coffeemug> so I can run cabal?
17:04:54 <coffeemug> I don't see a runghc-inplace under utils/runghc
17:05:00 <dons> i've never tried to install a haskell library using an inplace compiler, so not sure.
17:05:16 <dons> if you know what you're doing, you might be able to just edit the inplace.package.conf file, by hand
17:05:21 <dons> adding the entry for fps.
17:05:34 <dons> otherwise.... don't use an inplace ghc?
17:05:37 <dibblego> is it any great big deal if I do not use darcs?
17:05:47 <dibblego> is cabal somehow darcs aware?
17:05:55 <dons> nope.
17:05:57 <coffeemug> dons: how would you suggest installing packages and then hacking on the compiler?
17:06:07 <dons> but if you use darcs, you'll have better success having your project adopted by the community
17:06:08 <coffeemug> I mean, what's a good way to do it
17:06:14 <dibblego> righto
17:06:31 <dons> coffeemug: why do you need fps, to hack on the compiler?
17:06:42 <coffeemug> dons: here's what I'm trying to solve
17:06:57 <coffeemug> dons: plugins craps out on win32 with ghci
17:06:57 <dons> anyway, just install the compiler as normal, and hack, and reinstall as needed
17:07:03 <coffeemug> so what I want to do is install the plugins library
17:07:04 <dons> and use the inplace ghc where appropriate
17:07:49 <coffeemug> I see
17:07:54 <coffeemug> it's a bit less convinient
17:07:56 <coffeemug> but ok :)
17:08:04 <dibblego> is it always one module per file? or can a module span several files?
17:08:12 <dons> one module per file
17:08:27 <dibblego> so a "package" is a collection of one or more modules?
17:08:35 <dons> coffeemug: should be some more advice on hacking ghc in the HACKING document, and in the ghc wiki
17:08:39 <dons> dibblego: yes.
17:08:43 <dibblego> ok ta
17:08:47 <dons> typically available as a unix archive
17:08:58 <dons> i.e. libHSfps.a and HSfps.o
17:23:30 <SamB_XP> > 5*4/.4
17:23:32 <lambdabot>  Not in scope: `/.'
17:23:37 <SamB_XP> > 5*4/0.4
17:23:39 <lambdabot>  50.0
17:23:44 <SamB_XP> > .14*5*4/0.4
17:23:45 <lambdabot>  Parse error
17:23:49 <SamB_XP> > o.14*5*4/0.4
17:23:50 <lambdabot>  Not in scope: `o'
17:23:53 <SamB_XP> > 0.14*5*4/0.4
17:23:55 <lambdabot>  7.0
17:24:15 <coffeemug> dons: quick question
17:24:18 <coffeemug> when I do make install
17:24:21 <coffeemug> and try to run ghci
17:24:46 <dons> yeah?
17:24:54 <coffeemug> I get an error saying cannot load base, symbol _logf is unknown in HSbase1.o
17:25:00 <coffeemug> any idea what it might be?
17:25:08 <SamB_XP> oh no!
17:25:16 <SamB_XP> something is missing out on libm or something?
17:25:30 <coffeemug> libm?
17:25:40 <SamB_XP> the math library?
17:25:51 <SamB_XP> _logf is probably a math function?
17:26:09 <coffeemug> hehe, I thought of it as in "logging"
17:26:17 <dons> perhaps using a different ghc base library to the ghci you're using? or your pcakage.conf is broken in some way, such that libm isn't found?
17:26:26 <coffeemug> but yeah, you're probably right
17:26:45 <dons> you should have: extraLibraries = ["m","gmp"]
17:26:53 <dons> or some such, in your package.conf
17:27:17 * dons doesn't know what coffeemug is doing on his system 
17:28:26 <coffeemug> just a regular build man :)
17:28:45 <SamB_XP> > .5 * .14 * (5 * .4 * 4)^2
17:28:46 <lambdabot>  Parse error
17:28:54 <dons> ok. we, sounds like a not found libm
17:28:56 <SamB_XP> > 0.5 * 0.14 * (5 * .4 * 4)^2
17:28:56 <lambdabot>  Parse error
17:28:58 <dons> s/well/
17:29:00 <SamB_XP> > 0.5 * 0.14 * (5 * 0.4 * 4)^2
17:29:02 <lambdabot>  4.48
17:30:07 <coffeemug> well, I have libm in my binary haskell install
17:30:13 <coffeemug> where should I put it?
17:31:04 <coffeemug> it's part of gcc-lib folder that comes with the binary install
17:31:12 <coffeemug> but it's missing in my msys installation
17:33:38 <dons> is it linked into your ghc? is the path to libm visible to ghc? why did it suddenly break (presumably you've run haskell programs before without hitting a missing libm?)
17:34:05 <coffeemug> well
17:34:10 <coffeemug> I can run ghci in place
17:34:14 <coffeemug> but the moment I do make install
17:34:17 <coffeemug> and try to run it that way
17:34:19 <coffeemug> it breaks
17:34:28 <dons> ah. so its an ld path to libm missing then?
17:34:48 <dons> that works in the inplace.package.conf, but is missing in the installed package.conf ?
17:34:57 <dons> (they're separate files - compare them for the error)
17:35:39 <coffeemug> I see
17:39:56 <coffeemug> hmm
17:40:02 <coffeemug> just overwrote one with the other
17:40:05 <coffeemug> still the same problem
17:40:58 <dons> overwriting one with the other isn't a good idea
17:41:03 <dons> the relative paths will be confused
17:41:31 <coffeemug> yeah, I set it back
17:41:45 <dons> find a working install of ghci on your system, and vimdiff the package.conf files perhaps?
17:43:51 <coffeemug> arghh
17:43:57 <coffeemug> I hate the fact that there is no sudo on windows
17:56:27 <SamB_XP> coffeemug: why don't you write wsudo?
18:07:39 <coffeemug> yeah, would be a cool project
18:07:43 <coffeemug> ok
18:07:51 <coffeemug> I am officially not meant to hack ghc on win32 for now :)
18:08:30 <coffeemug> just can't get hs-plugins to load
18:08:33 <coffeemug> for the life of me :)
18:09:06 <coffeemug> went through the whole build
18:09:12 <coffeemug> but can't register the stupid package in place
18:09:23 <Igloo> Why do you want it to be in place?
18:09:30 <coffeemug> well
18:09:34 <coffeemug> I tried make install
18:09:40 <coffeemug> but that had linker problems
18:09:41 <Igloo> (I knew I shouldn't of asked  :-)  )
18:09:49 <coffeemug> :)
18:10:09 <Igloo> Did make succeed?
18:10:14 <coffeemug> yes
18:10:17 <coffeemug> make succeeded
18:10:20 <coffeemug> running in place did too
18:10:27 <coffeemug> but when I did make install and tried to run ghci
18:10:33 <coffeemug> I got _flog sysmbol missing
18:10:35 <coffeemug> from base1
18:10:36 <Igloo> Odd. How were you trying to register in place?
18:10:54 <Igloo> base1?
18:11:01 <coffeemug> HSbase1.o
18:11:11 <coffeemug> I have them registered with my regular ghc that I installed from binaries
18:11:19 <coffeemug> so I called ghc-pkg describe on regular ghc
18:11:26 <coffeemug> and then did ghc-pkg-inplace register
18:11:27 <Igloo> Is that a Windows thing? I don't have an HSbase1.o
18:11:30 <coffeemug> from those describe files
18:11:38 <coffeemug> well I'm on win32
18:11:40 <coffeemug> I'm not sure
18:11:41 <coffeemug> :)
18:11:43 <Igloo> Oh, maybe it's the split object inside the .a
18:12:09 <coffeemug> I'm pretty sure I did the don't split thight though
18:12:11 <coffeemug> thing
18:12:52 <coffeemug> can I do runhaskell Setup
18:13:01 <coffeemug> can I tell it which package.conf file to write to?
18:13:13 <Igloo> Did you tell Setup.hs to use the right compiler?
18:13:37 <Igloo> You need to say --with-compiler=.../bin/ghc
18:13:52 <Igloo> It should then find the right ghc-pkg, which should know where the right package.conf is
18:14:02 <coffeemug> Igloo: in configure?
18:14:06 <Igloo> yup
18:14:24 <coffeemug> I tried that but it doesn't recognize the inplace script as a compiler :)
18:15:38 <Igloo> Ah, indeed
18:16:29 <Igloo> Well, I think it's finding ghc-pkg that actually breaks
18:22:55 <dibblego> ?where coq
18:22:56 <lambdabot> I know nothing about coq.
18:23:40 <Adamant> ?where coq roq
18:23:41 <lambdabot> I know nothing about coq.
18:26:02 <dibblego> did I once read a paper about using Coq to prove a sort algorithm?
18:27:45 <bdash> dibblego: http://why.lri.fr/examples/ mentions a few examples of sorting algorithms verified by Why and Coq
18:28:05 <dibblego> ta
18:28:51 <palomer> ok
18:29:00 <palomer> I realized why I think my supervisor is a witch
18:29:09 <palomer> it's because she made me feel like if I was good for nothing
18:29:25 <palomer> she would criticize everything I'd do
18:29:34 <lispy> i wonder if a proof by Coq about binary search would have the overflow bug that was found by google in the java collections
18:32:55 <lennart> only if the proof assumed unbounded index type
18:33:31 <lennart> but then it would, of course, not be a proff about the real program
18:33:54 <lispy> hmm...so Coq proofs aren't really about real programs?
18:34:15 <palomer> palomer: paving the way for keal's return since 2006
18:35:05 <lennart> well, say that you prove a program an d then do program extraction to get something runnable.  then it's important that you run it with types with the same properties as the proof assumed
18:35:40 <lispy> lennart: is there a way to know all properties the proof assumed?
18:35:43 <lispy> will Coq tell you?
18:36:29 <lennart> i'm assuming that the extration actually does the right thing.  so in you use integers in the proof it will use Integer in Haskell
18:36:42 <lennart> but i've never done any program extraction with coq
18:37:07 <lispy> same here
18:37:19 <lispy> i find it interesting, but i suspect it is of little practical value
18:37:38 <lennart> and if you use coq as an external prover for, say, C, then you must make sure you get the sematics right
18:37:58 <lispy> ah hm.....that would be hard
18:38:07 <lispy> compiler dependent wouldn't it be?
18:39:24 <SamB_XP> or! you could encode the C standard as postulates!
18:39:40 <int-e> good luck.
18:39:53 <newb123> just finished emerg ghc  (took a few hours) .. So how do I run or compile a simple pgm?
18:40:22 <int-e> echo 'main = print "Hello, world!"' > test.hs; ghc test.hs; ./a.out
18:40:31 <SamB_XP> int-e: you *might* be able to prove 2+2 = 5!
18:40:51 <audreyt> > let 2 + 2 = 5 in 2 + 2
18:40:53 <lambdabot>  5
18:41:50 <newb123> Is there also an interactive shell?
18:41:54 <int-e> ghci
18:41:59 <jcreigh> what the heck? How does that work?
18:42:10 <int-e> jcreigh: it defines a new function, +.
18:42:18 <SamB_XP> > let 2 + 2 = 5 in 1 + 1
18:42:19 <lambdabot>  Non-exhaustive patterns in function +
18:42:20 <newb123> "Hello, world!"  ;)  Thank youu!!!
18:42:26 <int-e> > let a + b = a * b in 3 + 3
18:42:27 <lambdabot>  9
18:42:30 <jcreigh> ah
18:44:18 <lispy> > let plus = (+); 1 + 1 = 7; x + y = x `plus` y in (1 + 1) + 3
18:44:22 <lambdabot> Terminated
18:44:54 <lispy> interesting
18:45:10 <lispy> > let 1 + 1 = 7; x + y = x + y in (1 + 1) + 3
18:45:14 <lambdabot> Terminated
18:45:17 <audreyt> > let pi+1+1 = 1+1+pi in pi
18:45:17 <lambdabot>  Parse error in pattern
18:45:18 <lispy> those are the same programs
18:45:32 <audreyt> > let pi+1+1 = 1+1+pi in 1
18:45:33 <lambdabot>  Parse error in pattern
18:45:37 <audreyt> weird. that worked here
18:45:51 <lispy> audreyt: i don't think it uses the same parser as ghci does
18:46:17 <SamB_XP> lispy: it uses *two* parsers
18:46:42 <SamB_XP> one to check if the expression is an expression, and then GHC to compile it
18:46:55 <audreyt> and the first one does not like pi+1 patterns
18:47:10 <lispy> it doesn't like (n+k) patterns
18:47:15 <SamB_XP> to prevent the like of ()) `foo` (bar
18:47:16 <SamB_XP> or whatever
18:48:52 <SamB_XP> lispy: ah
18:49:21 <lispy> but, i've been in this channel for over a year and just now noticed it
18:49:30 <lispy> so...banning (n+k) patterns would be okay with me :)
18:49:36 <SamB_XP> heh
18:49:54 <SamB_XP> I was going to point out that I'm not sure its been a year since dons started with the preparser
18:53:29 <audreyt> > ("long" `tail`)
18:53:30 <lambdabot>    The operator section `("long" `tail`)' requires `tail' to take two argum...
18:53:36 <audreyt> sigh.
18:53:39 <int-e> > let (1+x) + 2 = x + 2 in 2 + 2
18:53:40 <lambdabot>  Parse error in pattern
18:53:42 * audreyt blames the preparser
18:53:47 <audreyt> (again that works here)
18:53:47 <SamB_XP> I wouldn't
18:53:51 <SamB_XP> it doesn't do typechecking
18:53:53 <SamB_XP> after all
18:54:13 <audreyt> oh. so it's just it hadn't been running with left sections support?
18:54:31 <SamB_XP> isn't that new in 6.6?
18:54:37 <audreyt> it is
18:54:48 <SamB_XP> I don't think lambdabot is running 6.6 yet?
18:54:54 <SamB_XP> wasn't last I heard
18:55:00 <audreyt> 'k
18:55:28 <int-e> @version
18:55:29 <lambdabot> lambdabot 4p250, GHC 6.5 (OpenBSD i386)
18:55:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:56:28 <int-e> that ghc predates the package restructuring stuff I guess, because it broke hs-plugins.
18:56:41 <SamB_XP> ah, yeah, true ;-)
19:00:12 <dan__> =>
19:06:35 <Bobstopper> Any gtk2hs around who can tell me how to extract a specific child from a table container? does containerGetChildren perhaps return a predictable enough order to write a function which does that?
19:06:54 * lispy pokes dcoutts
19:07:07 <lispy> i think he's sleeping
19:07:12 <Bobstopper> He hasn't said anything for about 5 hrs. I don't think he's around.
19:07:25 <lispy> ?users
19:07:25 <lambdabot> Maximum users seen in #haskell: 256, currently: 217 (84.8%), active: 23 (10.6%)
19:07:29 <Bobstopper> actually, closer to 6 hrs
19:09:07 <cfd90> If I have a function that requires an integer list, how do I prototype it (Or whatever it's called in Haskell, foo:Num->Num whatever)?
19:09:33 <cfd90> I'm new to Haskell, and I'm trying to make a map function
19:09:52 <cfd90> And what would I use there for a function? :S
19:09:59 * cfd90 can't find it anywhere
19:10:03 <Bobstopper> you mean type declaration? If you want it to work with any integer, foo :: Integral a => a -> a
19:10:37 <cfd90> I'm trying to make a map function
19:10:37 <Bobstopper> if you write the function without a type declaration, the compiler will probably figure it out for you and you can just ask it what type it has.
19:10:45 <cfd90> Oh
19:10:53 <cfd90> I'll try and leave it blank and see what it says ;)
19:11:27 <dons> ?type map -- for example?
19:11:29 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:15:02 <hyrax42> it's always a bit weird to read some of the older papers
19:15:12 <hyrax42> e.g. the Hughes/PJ pprinter paper
19:15:17 <hyrax42> where data Maybe = Yes a | No
19:15:25 <SamB_XP> heh
19:15:38 <SamB_XP> that does sorta make sense though
19:15:39 <mathewm> well, that makes sense!
19:15:49 <SamB_XP> one has to wonder why it was changed!
19:15:54 <SamB_XP> but its just a bikeshed now
19:15:59 <mathewm> WTH is this Just stuff...
19:15:59 <hyrax42> true enough
19:16:12 <hyrax42> maybe it's in that history paper thingy
19:16:17 <hyrax42> that came around in July or so
19:16:20 <hyrax42> that I never read
19:18:02 <cfd90> This functional programming is blowing my mind to itty bitty little pieces :P
19:18:09 <cfd90> -.-
19:18:28 <mathewm> cfd90: what is your background?
19:18:40 <Bobstopper> I prefer the current colour of the Maybe bikeshed. Maybe returns something so is more of a something/nothing split while a yes/no split seems more of a boolean "does it return something?"
19:19:05 <mathewm> my text isn't blue, is it?
19:19:26 <cfd90> mathewm: Not functional stuff :P
19:19:42 <cfd90> a bit of OOP
19:19:50 <emu> wirth seems to be unaware of recent innovations in static type and program analysis
19:19:51 <cfd90> some python,c,ect.
19:19:51 <Bobstopper> cfd90: what did the type work out to be btw?
19:19:58 <cfd90> Ehhhh :S
19:20:00 <emu> recent as in the last 25 years
19:20:02 <mathewm> cfd90: Haskell is really twisted, even compared to some other "functional" languages - e.g. LISP
19:20:24 <cfd90> Yeah, it's a totally different way of thinking
19:20:26 <dons> emu: wirth, url?
19:20:27 <int-e> lisp isn't really functional
19:20:35 <emu> from ltu
19:20:36 <int-e> and lisp is twisted in its very own way.
19:20:43 <Adamant> Common Lisp isn't
19:20:44 <cfd90> It has side effects, right?
19:20:48 <emu> http://lambda-the-ultimate.org/node/1773
19:20:49 <Adamant> Scheme is sort of
19:20:50 <lambdabot> Title: Good Ideas, Through the Looking Glass | Lambda the Ultimate
19:20:50 <Bobstopper> lisp is plenty functional. Just not "purely" functional.
19:20:51 <cfd90> (Lisp)
19:20:51 <mathewm> int-e: I have seen arguments both ways on the "functional"-ness of LISP
19:21:05 <int-e> I mean common lisp. especially CLOS.
19:21:06 <SamB_XP> Bobstopper: its not functional enough for me
19:21:12 <SamB_XP> I mean really
19:21:20 <SamB_XP> I can't write decent FP code in it
19:21:21 <Adamant> Common Lisp allows you to program with imperative, OO, or functional paradigms by default
19:21:29 <SamB_XP> it isn't very functional
19:21:29 <Bobstopper> common lisp can be as functional as scheme, it just has so much imperative bloat that it encourages non-functional programming. Like CLOS.
19:21:35 <dons> we should move on from lisp, its just a prototype for the FP languages of the 90s and beyond.
19:21:38 <Adamant> Bobstopper is correct
19:21:41 <mathewm> Heck, Perl can be "functional" too
19:21:43 <SamB_XP> Bobstopper: you need to do that #' crap
19:21:53 <emu> #'foo is (function foo)
19:21:55 <SamB_XP> mathewm: I bet it is nicer about it than CL
19:21:57 <int-e> I'm sure I can come up with a coding convention for doing FP in C.
19:22:05 <Bobstopper> Yeah, SamB_XP is right - I was just about to mention that the #' crap makes it awkward to be functional in CL.
19:22:07 <SamB_XP> emu: it isn't (function 'foo)?
19:22:08 <emu> no, you need to implement closures, int-e
19:22:13 <int-e> It would be bloated but it's certainly possible.
19:22:13 <emu> SamB_XP: no, function is a special operator
19:22:18 <SamB_XP> oh
19:22:25 <int-e> emu: so? macros go a long way ...
19:22:36 <SamB_XP> but that isn't *functional*, silly!
19:22:38 <cfd90> GHCI seems to think my first parameter is a Char instead of a function, but I don't know how to tell it that it is a function
19:22:50 <mathewm> efficient tail recursion is commonly desired in a fpl
19:22:52 <int-e> SamB_XP: that's my point :)
19:23:16 <int-e> SamB_XP: or rather that you will find people who will claim that it is.
19:23:24 <dons> cfd90: code?
19:23:28 <SamB_XP> hehe
19:23:31 <dons> > ord 'x'
19:23:32 <lambdabot>  120
19:23:38 <dons> > map ord "haskell"
19:23:39 <lambdabot>  [104,97,115,107,101,108,108]
19:23:45 <SamB_XP> cfd90: show code!
19:24:21 <Bobstopper> I know scheme has tail recursion, but I don't think haskell does does it? It would get in the way of laziness or something?
19:24:23 <mathewm> it would be cool if you could 'show code'
19:24:46 * cfd90 tries to think really quickly... 
19:24:48 <mathewm> show (+ 2) == "(+ 2)"
19:24:49 * cfd90 may have it
19:25:59 <Bobstopper> mathewm: (+ 2) when evaluated isn't the code (+ 2) anymore though - it's a function which adds 2. Even in lisp you'd need to quote the (+ 2) to get it to show...
19:26:26 <falconair> hi, as i understand 'lift' methods work by taking a function and its parameters and returning a function which slightly changes the behavior of input function, so lift2 will take a function and two of its arguments...is it possible 'lift' a function without specifying its arguments (pointfree?)  ?
19:27:21 <int-e> mathewm: you can get some reflection of that sort by using funny type class instances. for example: *Main> Var 'x' ^ 5 --> Mult (Mult (Mult (Var 'x') (Var 'x')) (Mult (Var 'x') (Var 'x'))) (Var 'x')
19:27:24 <mathewm> > [| (+ 2) |]
19:27:25 <lambdabot>  Parse error
19:28:02 <emu> quoting (+ 2) in lisp means quoting the literal data, a list with 2 symbols, while in haskell it means a string containing characters
19:29:13 <mathewm> falconair: I think that would make type-checking break
19:29:41 <int-e> mathewm: (the instance defines  a * b = Mult a b)
19:29:57 <falconair> mathewm: ok, so standard practice is to use lift, lift2, lift2, etc. ?
19:30:06 <falconair> last one should be lift3
19:30:08 <int-e> mathewm: but basically the code does not exist in a readable form at runtime.
19:30:50 <mathewm> int-e: what about template-haskell ?
19:31:15 <int-e> mathewm: that's a compile time feature.
19:31:23 <Bobstopper> @paste
19:31:23 <lambdabot> http://paste.lisp.org/new/haskell
19:31:45 <int-e> mathewm: I can't say much about it, I've never used it.
19:31:52 <mathewm> int-e: cycle [compileTime,runTime]
19:31:58 <Bobstopper> cfd90: use that page if you want to paste your code for us to look at
19:32:29 <lispy> cfd90: are you doing homework?
19:33:27 <Bobstopper> lispy: sounds like he's just a coder from an imperative / OOP background trying to learn haskell.
19:33:58 <lispy> Bobstopper: i ask because the help i give is different for homework doers...i break things down more and start from the beginning :)
19:34:19 <Bobstopper> ah ok ;)
19:36:44 <cfd90> lispy: Actually, I'm in high school, so no, it's not homework
19:37:06 <mathewm> Anyone have a toy problem that solving implies some intermediate level of haskell mastery? I think I am ready to move beyond my yellow belt ;)
19:37:12 * cfd90 decided to go for a tad bit simpler problems to get used to thinking this way before tackling Haskell itself
19:38:03 <cfd90> http://www.kingston.ac.uk/~ku07009/HaskellWorkshop/unit2.html - this page has some nice problems in it to tackle which I don't need much Haskell knowlege for
19:38:08 <lambdabot> Title: Haskell Workshop: Unit 2, http://tinyurl.com/y4aqz5
19:38:18 <Bobstopper> mathewm: got Monads down? If not, probably using the State monad and constructing a simple monad of your own might be next. Then try using monad transformers.
19:38:44 <lispy> mathewm: yeah, give us examples of what you have done
19:38:55 <mathewm> I am quite cozy with using monad's - can't say that I have written one from scratch yet
19:38:58 <lispy> mathewm: have you constructed a parser using parsec and parsed something interesting?
19:39:15 <lispy> maybe needed some state inside your parser
19:39:20 <glguy> I just read a paper on using Monad Transformers that was really good, i thought
19:39:30 <edwardk_> gah finally got comonad.com set up right. no more tiddlywiki
19:39:39 <dons> mathewm: have a go at the rubyquiz problems? http://www.haskell.org/haskellwiki/Haskell_Quiz
19:39:42 <lispy> glguy: link please?
19:39:42 <lambdabot> Title: Haskell Quiz - HaskellWiki, http://tinyurl.com/y6afxw
19:39:52 <mathewm> lispy: I have played around with parsec - the "Write your own lisp" tutorial
19:40:00 <lispy> mathewm: cool
19:40:08 <edwardk_> dons: did you ever test that email addy?
19:40:13 <lispy> mathewm: arrows?
19:40:26 * dylan screams at DSLs with horrible syntaxes.
19:40:27 <glguy> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
19:40:32 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
19:40:45 <mathewm> I just did the SolitaireCipher - it took me a little over 2.5 hours
19:40:46 <lispy> glguy: thanks
19:41:01 <mathewm> that seems a little on the slow side...
19:41:24 <lispy> glguy: this is perfect, i've been starting to dabble in this myself thanks to cale
19:41:36 <glguy> glad to be of some use :)
19:41:41 * Igloo was just looking at that again, having solved half my hatred of the padding a couple of nights ago in bed
19:42:07 <Igloo> But there needs to be a nice way of saying   if null xs then Nothing else f xs   dammit!
19:42:25 <lispy> hrm
19:42:35 <lispy> ?type maybe
19:42:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:42:51 <mathewm> I had a stupid bug in my triple cut that the given test worked for...
19:43:10 <Igloo> It should be   fmap f $ mkMaybe null   for some function mkMaybe
19:43:21 <lispy> yeah
19:43:25 <Igloo> s/\$/./
19:43:33 <mathewm> ?hoogle [a] -> Maybe a
19:43:34 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
19:43:35 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
19:43:37 <glguy> Igloo: how about this:
19:43:48 <glguy> liftM2 (guard.not.null) (Just.f)
19:43:50 <lispy> mkMaybe :: (a -> Maybe a) -> a
19:44:03 <lispy> mkMaybe :: (a -> Maybe a) -> a -> Maybe a :)
19:44:05 <lispy> bleh
19:44:15 <dolio> dons: How do I go about adding a page to the wiki for new ruby quiz solutions and such?
19:44:15 <Igloo> mkMaybe :: (a -> Bool) -> a -> Maybe a
19:44:16 <lispy> first Maybe a should bebool
19:44:24 <glguy> > liftM2 (guard.not.null) (Just.length) [1,2,3]
19:44:25 <lambdabot>  Not in scope: `Just.length'
19:44:28 <glguy> > liftM2 (guard.not.null) (Just .length) [1,2,3]
19:44:29 <lambdabot>  Couldn't match `[a]' against `Maybe Int'
19:44:31 <Igloo> (mkMaybe would also probably want not . null, which is ugly too)
19:44:37 <lispy> dolio: there should be a page for that
19:44:46 <glguy> > liftM2 (>>) (guard.not.null) (Just .length) [1,2,3]
19:44:48 <lambdabot>  Just 3
19:44:49 <lispy> dolio: but in general you make a new page by makeing a reference to it, then following the link
19:44:52 <glguy> > liftM2 (>>) (guard.not.null) (Just .length) []
19:44:54 <lambdabot>  Nothing
19:44:59 <Igloo> Perhaps maybeIf and maybeUnless should exist
19:45:08 <glguy> \f -> liftM2 (>>) (guard.not.null) (Just .f)
19:45:10 <lispy> dolio: [[My new page]], then save the page and click the link
19:45:17 <dolio> Ah, I see.
19:45:41 <lispy> i should probably learn to use guard
19:45:48 <lispy> it looks easy, but i never use it now
19:46:28 <lispy> ?type guard
19:46:30 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
19:46:52 <dolio> It's just like a guard in list comprehensions, only for do notation.
19:47:00 <dolio> What glguy is doing is rather nonstandard. :)
19:48:26 <glguy> Igloo: so you dont consider: \f -> liftM2 (>>) (guard.not.null) (Just .f) -- clean? ;)
19:49:09 <lispy> glguy: it's not half as clear as the version using if :)
19:49:28 <glguy> and the if version is half as clear as the version using pattern matching
19:50:08 <lennart> ?type  \f -> liftM2 (>>) (guard.not.null) (Just .f)
19:50:10 <lambdabot> forall a b. ([a] -> b) -> [a] -> Maybe b
19:50:40 <lispy> wait a sec
19:50:48 <lispy> so that's not even the right type  is it?
19:50:53 <glguy> oh course it is
19:50:55 <glguy> of
19:51:07 <lispy> oh i'm confusing it with the function i typed ealier
19:51:22 <lispy> (a -> Bool) -> a -> Maybe a
19:51:27 <dons> ?docs Data.List
19:51:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:51:35 <glguy> ?djinn ([a] -> b) -> [a] -> Maybe b
19:51:36 <lambdabot> f a b = Just (a b)
19:52:08 <lispy> ?free maybeif :: ([a] -> b) -> [a] -> Maybe b
19:52:08 <lambdabot> g . h = k . $map f => $map_Maybe g . maybeif h = maybeif k . $map f
19:52:25 <lispy> $map_Maybe?
19:52:41 <glguy> it's not a map though
19:52:42 <lispy> anyway, i'm off to read this paper
19:52:45 <lispy> thanks for the link glguy
19:53:08 <glguy> yw
19:55:58 <mathewm> Is there a prettier way to do this: "nums = map (uncurry f) $ zip (toNumbers cleanedInput) (toNumbers keys)"
19:56:26 <glguy> zipWith
19:56:31 <glguy> ?type zipWith
19:56:33 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
19:57:10 <mathewm> thanks
20:04:36 <mathewm> ?hoogle unfoldl
20:04:37 <lambdabot> No matches found
20:04:43 <mathewm> why not?
20:05:25 <glguy> unfoldr
20:05:33 <mathewm> but I want unfoldl
20:05:37 <x3m> "load: couldn't find symbol ((resource))" when i try to run runplugs, anyone got a clue?
20:05:41 <mathewm> I made my own easily enough
20:06:45 <Igloo> Bah, my step function would fit on one line if twice existed
20:07:00 * Igloo decides the set of combinators Haskell provides was designed to make my life difficult
20:07:24 <mathewm> @paste
20:07:25 <lambdabot> http://paste.lisp.org/new/haskell
20:07:50 <edwardk_> Igloo: ?
20:07:51 <Botty> how is haskell for allowing other languages to use haskell libs?
20:08:06 <lisppaste2> mathewm pasted "why isn't this standard?" at http://paste.lisp.org/display/28776
20:08:11 <Botty> exporting types, functions, and the like to C
20:08:39 <edwardk_> botty: you can do so you have to wrap everything in some sort of hs_init, and finalization code, and passing data between can be a little tricky at first
20:08:53 <edwardk_> but its not terrible
20:10:19 <Botty> okay
20:10:39 <Botty> hmm
20:10:50 <Botty> yeah, might as well have a go at a 2d graphics engine in haskel
20:11:14 <Botty> probably won't want to have interfaces to other languages, at theat point I can just use it as a spec for the c version, lol
20:12:00 <Botty> my only problem is hopengl uses glut whereas glfw kinda kicks its arse
20:13:00 <edwardk_> haven't tried opengl in haskell yet
20:16:42 <coffeemug> hey
20:16:51 <coffeemug> dons: if you're still here, question about plugins
20:17:01 <coffeemug> does recompileAll call hasChanged first?
20:17:17 <coffeemug> and does the module automatically reload when I call recompileAll or I need to reloaded it manually?
20:17:36 <sjanssen> matthewm: that is know as unfoldr, in Data.List
20:17:39 <sjanssen> s/know/known
20:19:45 <Botty> looks like HOpenGL is structured in such a way that a glfw frontend could be added :)
20:23:23 <mathewm> sjanssen: oh, I assumed that would move in the other direction...
20:26:56 <coffeemug> whoooo hoooooo
20:27:06 <coffeemug> I got hs-plugins to recompile stuff on the fiy
20:27:09 <coffeemug> fly
20:27:10 <coffeemug> and reload it
20:27:13 <coffeemug> :-D
20:27:31 <coffeemug> this is awesome
20:31:19 <chessguy> if i do foo x = (sqrt x) + (sqrt x), does foo 2 compute the square root once or twice
20:31:42 <sjanssen> chessguy: depends on the compiler, and the settings
20:31:44 <lispy> glguy: that was a good read and a good deal simpler than i realized
20:31:50 <glguy> agreed
20:31:52 <sjanssen> a Haskell compiler is allowed to do either
20:32:14 <chessguy> ok
20:32:32 <chessguy> but like GHCi probably optimizes that, right?
20:32:33 <lispy> in fact, the same is true of: foo x = y + y where y = sqrt x
20:32:39 <lispy> at least as i understand haskell
20:32:39 <sjanssen> GHC probably won't eliminate the common subexpression there
20:33:13 <sjanssen> lispy: sure, a compiler is allowed to do that.  Won't generally happen though
20:33:46 <chessguy> i would think memoization would be a priority for a haskell compiler
20:33:52 <lispy> chessguy: if you asked out of performance concern, the answer is profile :)
20:34:00 <sjanssen> chessguy: memoization is tricky
20:34:02 <chessguy> since foo x always returns the same thing for the same x
20:34:31 <lispy> it's hard to tell if memoizing has lower cost over all (memory and time considered) than not memoizing
20:34:44 <chessguy> aha
20:34:54 <sjanssen> plus the problem of values that are equivalent, but have different addresses
20:35:05 <coffeemug> lispy: not if you have an exponential algorithm without it :)
20:35:13 <coffeemug> liks fib series, for example
20:35:20 <chessguy> can i tell the compiler how much to memoize all the time?
20:35:30 <lispy> coffeemug: afaik, compilers can't tell the big-O of my code :)
20:35:36 <sjanssen> chessguy: no current compiler has such an option
20:35:53 <coffeemug> lispy: a pity, really... :)
20:35:58 <lispy> i could see it as an interesting area of study though
20:35:59 <sjanssen> there are memo combinators you can use though
20:36:14 <chessguy> yes, fib is the canonical example. fib 0 = 1; fib 1 = 1; fib n = (fib (n-1))+(fib (n-2))
20:36:56 <lispy> i wonder why ghc doesn't do automatic memoization using weak pointers and a high priority to garbage collect memoizied data
20:37:17 <lispy> or maybe weak ptrs in the presence of lazy eval don't pay off?
20:37:27 <sjanssen> it seems wrong to do such an optimization by default
20:37:52 <coffeemug> well
20:37:57 <sjanssen> memo combinators, or even a MEMO pragma seems better
20:37:59 <coffeemug> is it wrong to automatically inline, for example?
20:38:07 <Igloo> Well, there's my attempt: http://urchin.earth.li/~ian/SolCipher.hs
20:38:09 <lispy> but with weak ptrs you're not going to pay much for it, right?
20:38:14 <sjanssen> coffemug: not usually
20:38:43 <coffeemug> it's not really wrong to memoize if the compiler can figure out when it's a good idea
20:39:00 <coffeemug> I wonder if you could analyze code to see if memoizing will help
20:39:03 <coffeemug> at least in some cases
20:39:05 <lispy> coffeemug: yeah, like when we give it a pragma :)
20:39:07 <coffeemug> would be a cool pass
20:39:22 <coffeemug> yeah, but that's less cool :)
20:39:33 <lispy> coffeemug: i would guess that in general it's undecidable even if you had a hard criteria you looked for
20:39:38 <sjanssen> I wouldn't like relying on a compiler optimization to change to change the big-O of my code
20:39:48 <lispy> s/hard/fixed/
20:40:43 <lispy> sjanssen: some people feel similarly about lazy eval :)
20:40:55 <dwm> ?fptools reverse
20:40:56 <lambdabot> reverse not available
20:41:13 <dwm> ?fptools Data.List.reverse
20:41:14 <lambdabot> Data.List.reverse not available
20:41:28 <dwm> ?fptools Prelude.reverse
20:41:29 <glguy> Prelude
20:41:29 <lambdabot> Prelude.reverse not available
20:41:34 <sjanssen> lispy: lazy evaluation is consistent across all Haskell systems.  Memoisation detection isn't
20:42:18 <dibblego> do {- comments -} work in .cabal files?
20:42:25 <coffeemug> there are Haskell systems other than GHC? :)
20:42:27 <lispy> sjanssen: this is true, but i was hinting that we could define it into a language
20:42:39 <lispy> dibblego: not sure, i've only used the -- kind, but i bet they do
20:42:52 <lispy> dibblego: afaict, cabal used to be read via read
20:43:05 <dibblego> lispy, it's just not mentioned in this PDF (but -- is)
20:43:30 <edwardk_> lispy there is a paper by umut acar and some other tti chicago folks on automatic memoization, but they talk about it in an ml context.
20:43:41 <coffeemug> it's pretty funny how Java people struggle to separate content presentation from business logic
20:43:48 <coffeemug> so like in a servlet you don't make sql calls
20:43:52 <coffeemug> it's so simple in haskell
20:43:56 <lispy> edwardk_: ML?! bah....this is haskell! :)
20:44:03 <coffeemug> just do a preRender that's an IO
20:44:06 <coffeemug> and a render that isn't
20:44:15 <dibblego> coffeemug, lots of what Java people do is funny
20:44:19 <dwm> coffeemug: I feel like a lot of stuff I see in OO is a cry for help.
20:44:20 <edwardk_> lispy: just saying =) might give you an idea of the impact of such an optimization
20:44:33 <lispy> edwardk_: right, it's a good thought
20:44:35 <edwardk_> heya SyntaxNinja
20:44:39 <monochrom> Java is funny.
20:44:40 <Adamant> do you think there will be problems in the future with Haskell where code is "all the world is ghc" based?
20:45:07 <lispy> i'd complain about java programmers more, but i think when i program in java i don't do much better
20:45:08 <Adamant> if other compilers gain ground.
20:45:14 <dwm> I did a little bit of reading about the aspect-oriented stuff recently. Kind of horrifying.
20:45:29 <lispy> my java programs are riddled with obscure (to me) bugs despite my best practices and attempts and advanced functional knowledge
20:45:32 <edwardk_> Adamant: i'll start to worry about the other compilers when their feature set becomes remotely comparable
20:45:35 <monochrom> When I program in Java I do much better than other people.
20:45:52 <lispy> dwm: ah, how they intercalate programs together from fragements?
20:46:04 <monochrom> Heh intercalate
20:46:04 <dibblego> there are lots of myths surrounding Java that many people do not know about
20:46:08 <dwm> lispy: Yeah, and particularly horrifying, altering classes at runtime.
20:46:50 <lispy> dwm: someone told me that was one of their favorite features of ruby (modifying objects at run-time to change their type/class)....hence i've never wanted to program in ruby since :)
20:47:21 <edwardk> lispy: actually its one of my favorite things in perl too, dirty as it makes me feel. =)
20:47:31 * lispy can't program in perl
20:47:31 <coffeemug> first of all
20:47:37 <lispy> my mind can't handle the noise
20:47:41 <coffeemug> modifying stuff at runtime can be safe
20:47:49 <dolio> That bit of ruby can make things pretty if used in moderation.
20:48:15 <monochrom> If Wirth's recent paper is worth anything, a major recurring theme is "please please please don't self-modify!"
20:48:18 <dwm> It just sounds like Danger, Will Robinson to me. But I confess I have experience with such beasts at all.
20:48:21 <coffeemug> you ask the runtime to mod a class, it verifies that your mod doesn't break type safety, mods if it doesn't, returns an error if it does
20:48:24 <lispy> modifying code at run-time tends to lead to extremely hard to maintain systems
20:48:33 <dwm> er, have no experience with..
20:48:42 <edwardk> the perl one can be used to make nice serialization libraries that load in their content lazily but can still have multiple references to the target object before its loaded.
20:48:53 <coffeemug> lispy: the benefit of that stuff is development
20:49:01 <edwardk> but yeah its generally scary voodoo =)
20:49:02 <dolio> Although mostly, I think it's useful for defining new functions/methods on the built-in classes.
20:49:03 <coffeemug> you don't have to restart your server every time you make the slightest change
20:49:17 <dolio> Sort of like solving the expression problem on the OO side.
20:49:40 <glguy> Erlang allows for modifications ot the system while it's running, right
20:49:44 <qwr> yes, don't modify, just construct new code in the runtime ;)
20:49:49 <glguy> and they use that as a feature to deliver high availablity
20:49:54 <lispy> dolio: scala solves it without being scary dynamic
20:50:14 <lispy> coffeemug: i wonder how hsplugins compares to that level of dynamic ness
20:50:20 <dolio> lispy: Yeah, well, that's where the expression problem really becomes hard, right?
20:50:42 <coffeemug> lispy: well, I just got it working and it's very very very nice :)
20:50:43 <dolio> lispy: I haven't read the paper, but I seem to recall the abstract saying something about "not breaking type safety," which doesn't even apply to ruby.
20:50:45 <lispy> dolio: i admit, i don't really get the expression problem
20:50:54 <coffeemug> but it doesn't allow you to mod the core server much
20:51:03 <coffeemug> a sound trade off, I suppose
20:51:43 <Bobstopper> hmm.. I understand the separation of "business logic" and "presentation" is a standard model-view-controller "design pattern" used to ensure the presentation is modularised and easily replaceable without affecting the code of the business logic etc. Or something.
20:51:47 <lispy> coffeemug: i think that was kinda the point though right?  You keep the core server to be next to nothing and then you can mod the hell out of it?
20:51:51 <lispy> coffeemug: lambdabot style
20:51:57 <Bobstopper> Does anyone know whether that MVC stuff is applicable to something like Haskell?
20:52:15 <lispy> MVC is widely applicable
20:52:33 <lispy> functional stuff tends to emphasize the model right?
20:52:35 <monochrom> MVC is applicable to all languages.  Incidentally also applicable to all animals.
20:52:56 <lispy> and with haskell, laziness lets you separate the view more than traditionally possible
20:53:06 * edwardk tries to find a use for MVC in malbolge and backs away ;)
20:53:28 * Bobstopper is currently trying out MVC separation in his gtk2hs and is having a little trouble figuring how
20:53:32 <dibblego> lispy, do you feel like running a short test for me please re: {- comments -}, I am reading about cabal and I haven't set it up yet
20:53:42 <lispy> Bobstopper: and if i understand the controller right, that's what we use higher order functions for a lot of the time
20:53:44 <coffeemug> ok guys
20:53:47 <coffeemug> time to go to sleep
20:53:50 <coffeemug> gn everyone
20:54:08 <lispy> dibblego: let me see if i have something around that  uses cabal
20:54:15 <lispy> dibblego: i'll get back to you in 5 min or so
20:54:31 <Bobstopper> how's MVC applicable to animals?
20:54:46 <Bobstopper> monochrom: ^^
20:54:53 <dibblego> lispy, come to think of it, I have lambdabot and {- comments -} doesn't work
20:56:00 <lispy> $ runghc Setup.hs configure -p
20:56:00 <lispy> Setup.hs: Warning: Unknown field '{-version'
20:56:00 <lispy> Setup.hs: Error: Missing field: version
20:57:20 <lispy> god, the motivation to work on my midterm is kicking my ass
20:57:26 <lispy> it's due soon and i've barely even looked at it
20:57:35 <glguy> lispy: the lack thereof?
20:57:43 <lispy> yeah
20:57:58 <lispy> the magnitude may be large but the value is small :)
20:58:02 <monochrom> I can do it for you for US$100 per hour.
20:58:20 <monochrom> Minimum charge US$1000.
20:58:22 <lispy>  /msg monochrom sweet, let me email it to you
20:58:23 <lispy> oops
20:58:53 <lispy> it might take that long if you were serious about it
20:59:37 <monochrom> Not serious for now.
21:00:19 <dolio> Projects are usually best done in a couple all nighters right before the due date, in my experience. :)
21:01:04 <monochrom> Projects are usually best done by couples
21:02:18 <glguy> The "best done in couples" principle only applies when your partner isn't a piece of shit, though.
21:02:20 <lispy> i think my term project will be fun, it's just this midterm i don't care about at all
21:03:50 <monochrom> The idea is the partner is also your bf/gf.  Maybe he/she doesn't contribute but at least you can tie him/her to you so you have company.  Maybe he/she can brew you a cup of tea once in a while too.
21:04:27 <glguy> ah, agreed
21:04:46 <glguy> Nothing's better when using a computer than not having to get up from it when you don't want to to do things like get food and drink ;)
21:04:51 <monochrom> Just don't get into a fight over partitioning or marks :)
21:05:16 <lispy> i usually get the "Get it yourself, Pig.  I'm liberated" when i try that with gfs
21:05:26 <glguy> My fiancee is way to sweet to me when I'm working on something.
21:05:39 <glguy> too*
21:05:52 <monochrom> Well you have "I'm doing your part of the project" to bargain her into bringing you tea.
21:06:04 <glguy> "Would you mind making me some tea?" "Sure!" "Really??"
21:07:27 <dons> anyone want to help finish this translation off? http://programming.reddit.com/info/nwnx/comments
21:07:29 <glguy> I think I saw my boss on TV at the World Series...
21:07:32 <lambdabot> Title: One-page terse intro to OCaml, variety of examples (reddit.com), http://tinyurl.com/vlc5r
21:07:38 <dons> i'm about half done, http://haskell.org/haskellwiki/A_Brief_Introduction_to_Haskell
21:07:41 <lambdabot> Title: A Brief Introduction to Haskell - HaskellWiki, http://tinyurl.com/y98go6
21:07:45 <dons> but need to do some real work today sometime ...
21:08:14 <dons> the idea, just go through the ocaml tut, and translate the code fragments in to haskell, modifying the text where appropriate
21:08:21 <dwm> Does anyone know, is there a place I can see or grab the source for things like the Prelude?
21:08:26 <dons> you'll learn some ocaml on the way...
21:08:33 <dons> dwm, yeah, check the 'Example code' link on haskell.org's front page
21:08:38 <dons> Prelude should be the first link
21:09:20 <dwm> dons: Hey, thank you.
21:09:38 <dwm> I was curious about how reverse is defined.
21:10:13 <dons> reverse                 =  foldl (flip (:)) []
21:10:19 <dons> or
21:10:20 <dons> reverse l =  rev l []
21:10:20 <dons>   where
21:10:20 <dons>     rev []     a = a
21:10:20 <dons>     rev (x:xs) a = rev xs (x:a)
21:10:26 * monochrom contemplates A Young Person's Guide to Haskell.  "My dear children, young and old, each combinator is represented by an instrument.  The identity function, by the flute..."
21:11:07 <dwm> I see the foldl/flip one in there.
21:11:07 <glguy> monochrom: "and what does this have to do with Haskell? Well, nothing, but it got you thinking, didn't it?"
21:11:10 <lispy> reverse [] = []; reverse (x:xs) = reverse xs : x -- i think this works too
21:11:49 <monochrom> Damn!  I confused A Young Person's Guide to Haskell with Peter And The Wolf!
21:13:18 <sjanssen> monochrom: oh,  thanks a bunch.  I'm going to be whistling that the rest of the evening
21:13:19 <sjanssen> ;)
21:14:00 * monochrom is a source of inspiration
21:14:52 * lispy rocks out to "American Girls"
21:15:05 <lispy> "why are all american girls so rough?"
21:16:10 <monochrom> they are rough?  I thought they had access to skin-smoothing products...
21:16:35 <dwm> This started because I was reading the Rabhi/Lapalme Algorithms book and it first talks about writing your own reverse with ++ ...
21:17:18 <dwm> And then they go through one using a helper like reverse' [] y = y ; reverse' (x:xs) y = reverse' xs (x:y)
21:17:32 <dwm> So, I became curious about how the real deal is doing it.
21:17:59 <monochrom> The helper uses an accumulator.
21:18:05 <dwm> ya
21:18:17 <monochrom> The helper is the same as rev in dons version
21:18:55 <monochrom> You can also rewrite (x:y) as [x]++y, if you want to stick with ++
21:21:20 <lispy> in fact, i used to write it that way
21:21:25 <lispy> i found it easier for some reason
21:21:29 <lispy> now that just seems silly to me
21:21:35 <glguy> http://www.newscientistspace.com/article/mg19225751.200-the-elephant-and-the-event-horizon.html
21:21:39 <lambdabot> Title: The elephant and the event horizon - fundamentals - 26 October 2006 - New Scient ..., http://tinyurl.com/yxwsbo
21:21:45 <glguy> Interesting read linked from Digg
21:24:55 <dwm> This is stuff that I still have trouble seeing, have to digest it. How the ' with accumulator version is the same as the foldl version.
21:30:53 * lispy fires up texshop and gets serious about his midterm
21:31:07 <lispy> good thing it's already 21:30, so i can't work too much tonight :)
21:35:43 <glguy> xplanet -projection mercator
21:35:48 <glguy> makes for a pretty background
21:36:38 <monochrom> foldl is the mother of accumulator functions :)
21:41:19 <Adamant> lispy, is texshop better than Lyx?
21:41:39 <lispy> Adamant: i dunno, i could never use lyx, it bothered me too much
21:41:49 <lispy> Adamant: i've used emacs, texmacs and texshop
21:42:06 <lispy> Adamant: when i'm on my mac i prefer texshop (kinda) and the rest of the time i find emacs to be damn spiffy
21:42:24 <Adamant> texshop is Mac-only?
21:42:39 <lispy> Adamant: the main reason texshop is better on the mac is because the mac doesn't do xdvi as well as my linux setup does
21:42:48 <Adamant> (I don't play with TeX much, if you couldn't tell.)
21:42:55 <lispy> Adamant: afaik, yes because its written in some apple specific language
21:42:58 <Bobstopper> hmm... if MVC is so good, how would something like fruit fit in with MVC?
21:43:11 <lispy> Bobstopper: oh, i never said that :)
21:43:20 <lispy> Bobstopper: just that it's applicable widely :)
21:43:56 <lispy> Adamant: i'd recommend looking at texmacs if you only do latex casually
21:44:03 <Bobstopper> I'm just wondering if there's a way to abstract away from such a pattern and if fruit perhaps accomplishes that :)
21:44:14 * Bobstopper hasn't thought about it very hard
21:50:55 <lispy> god, texshop doesn't like multiple files
21:51:06 <lispy> hmm....i'll have to merge it all
22:11:35 * glguy is disappointed to learn that rxvt-unicode handles unicode more poorly than xterm, and uses more memory...
22:15:03 <Cale> glguy: hmm... I use gnome-terminal :)
22:16:15 <glguy> I look for apps that don't have any menus or other presentation stuffs
22:16:23 <glguy> and use dwm with its one pixel borders
22:16:32 <glguy> for example, I use feh as my image viewer
22:16:41 <glguy> it just displays the images and has a rightclick menu
22:16:53 <glguy> + dwms 1px border
22:17:10 <glguy> keeps people from thinking that they should touch it (for one thing)
22:17:53 <glguy> most wouldn't dream that they need type press Alt-P and then type in the name of the program that they want (with autocomplete if desired)
22:18:29 <Cale> well, you can turn off the menubar in gnome-terminal if you want :)
22:18:48 <glguy> I liked gnome-terminal when I was using Gnome in linux
22:18:55 <glguy> so I won't hold it against you
22:19:53 <glguy> the only thing that I miss about gnome terminal is the tabs, and I don't miss the tabs *too* much
22:20:27 <glguy> with dwm, I can get similar functionality by tiling the xterm sessions off to the side of the screen if I like at least
22:22:12 <glguy> also, this computer is pretty much a toy for me, so I can get away with a minimalistic environment
22:22:15 <Cale> Probably my favourite feature is the fact that it uses properly antialiased font rendering :)
22:22:21 <glguy> xterm does that
22:22:29 <Cale> does it?
22:22:40 <Cale> People are still working on xterm? :)
22:22:40 <glguy> yeah, I can use true-type fonts in xterm, for example
22:27:49 <glguy> xterm -fa 'Bitstream Vera Sans Mono'
22:27:51 <glguy> that works, for example
22:29:16 <Cale> nice
22:29:28 <glguy> the problem with such fonts, however, is that they take 10x longer to render
22:29:52 <glguy> 11.64s vs 1.01s on my machine
22:29:53 <glguy> for
22:29:56 <glguy> time man -k ' '
22:31:34 <glguy> I've been using the ucs-misc font with uxterm, because it's coverage of Unicode is insane
22:31:55 <glguy> I got tired of not being able to see what fun characters people were typing in IRC
22:33:07 <dons> ok, I've basically finished the translation from OCaml, just need to write the monad sections (where they use impurity and modules), http://haskell.org/haskellwiki/A_Brief_Introduction_to_Haskell
22:33:11 <lambdabot> Title: A Brief Introduction to Haskell - HaskellWiki, http://tinyurl.com/y98go6
22:33:13 <glguy> Does this show up as a not sign? Â¬
22:33:28 <Cale> yeah
22:33:46 <dons> probably should talk about laziness in there somewhere
22:33:49 <Cale> â
22:33:53 <glguy> member
22:34:04 <Cale> yep
22:34:16 <glguy> dons: it turns out you don't even have to install that font I told you about
22:34:24 <glguy> dons: all you needed to do was run uxterm
22:34:27 <dons> ah
22:34:29 <dons> good
22:34:31 <edwardk> dons: its not fair to pick on poor ocaml like that =)
22:34:42 <dons> edwardk: heh.
22:34:46 <glguy> the font was actually the standard fixed font, iso10646-1 encoding
22:35:04 <dons> its interesting comparing them side by side. you really notice where haskell made concious decisions to improve things
22:35:12 <edwardk> yeah
22:35:22 <dons> the pattern matching stuff is just awful in ocaml
22:35:25 <dons> and the overloading
22:36:06 <thou> dons: i just started reading it, but it looks like an impressive amount of work - nice job!
22:36:12 <dolio> ?index second
22:36:13 <lambdabot> Control.Arrow
22:36:58 <dons> thou: heh. just whipped it up in a couple of hours :) i wonder if i could write a book this way. ... hmm. should really write my phd thesis sometime.
22:37:35 <edwardk> heh
22:37:43 <thou> haha
22:41:43 <glguy> 1Â
22:41:55 <Cale> "This avoids the syntactic redundancy of languages like OCaml." -- haha
22:42:31 <glguy> 1Ã·2=Â½
22:42:43 <dons> compare and contrast with the same section in the original , http://www.cs.jhu.edu/~scott/pl/lectures/caml-intro.html
22:42:47 <lambdabot> Title: Introduction to Caml, http://tinyurl.com/6ixj
22:42:52 <Cale> "* is a polymorphic function, taking two types 'a'" -- two values of type a
22:43:12 <thou> yeah, i was just about to paste that same phrase
22:43:12 <dons> please fixify :)
22:43:19 * dons is a bit tired to edit further today
22:44:08 <dons> and if people want to dive in and make some notes in the monad section ... Cale .... please do :)
22:44:25 <dons> (with an eye to the original presentation in ocaml)
22:47:03 <Cale> Is this going to be posted to Reddit as well?
22:47:05 <Cale> hehe
22:47:19 <dons> yeah, once its done.
22:47:30 <dons> (I already put a small link on the http://programming.reddit.com/info/nwnx/comments page)
22:47:33 <lambdabot> Title: One-page terse intro to OCaml, variety of examples (reddit.com), http://tinyurl.com/vlc5r
22:51:39 * lispy goes tex crazy
22:51:47 <lispy> man it feels good to use tex again after all this time
22:52:04 <Cale> TeX is really awesome.
22:52:04 <lispy> and it lets me "work-on" my midterm without doing any of the boring stuff :)
22:53:01 * lispy sometimes thinks dons is on a personal mission to evangelize haskell to the masses
22:53:24 <lispy> dons: just don't burn out, you'll turn into a bitter old haskeller :) (look at the lisp/scheme communities if you don't believ me :)
22:53:59 <JohnMeacham> yay. associated types are working in jhc's front end. now to figure out a good translation of them.
22:55:02 <lispy> well, the papers by ChilliX explain a translation to system F
22:55:08 <lispy> if taht's what you're looking for
22:55:32 <roconnor> @instances MonadFix
22:55:34 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:55:48 <JohnMeacham> they do for associated data types, I don't think they work for associated synonyms.
22:56:44 <roconnor> JohnMeacham: I would think that associated types would fit well into your intermediate language.
22:58:37 <dons> lispy, someone's got to do our PR, otherwise its a future of VB and Ruby programming for us all :/
22:59:09 <lispy> JohnMeacham: there is a newer paper, iirc
22:59:19 <Cale> dons: It's possible that moving the "loading source from a file" section higher would be helpful. Some of the 'let' bindings at the ghci prompt are getting somewhat fanciful with their use of layout :)
22:59:22 * dons tries to stimulate the Haskell economy a bit
22:59:23 <lispy> JohnMeacham: i didn't finish the one about synonyms but i did see it
22:59:40 <dons> Cale: ah good idea. pleae make the necessary changes as you see fit
22:59:44 <thou> dons: s/a bit/a tonne/
22:59:49 <JohnMeacham> actually, they have an extremely elegant translation, they transform just directly into their type level functions. no fuss no muss.
22:59:52 <dons> (and add yourself as an author if you start writing text)
23:00:11 <dons> thou: heh
23:00:25 <sjanssen> I need to hurry up and build GHC so I can play with ATs
23:00:49 <Cale> dons: and is that second version of foldr really any more efficient?
23:01:06 <lispy> dons: funny you should mention that, at work they are starting to get nervious about having their prototype in haskell..."We have to rewrite our prototype?"
23:01:11 <JohnMeacham> so, Elem c = case c of [x] -> x ; Int -> Char  ; ...  (that is a case scrutinizing a type, which is a-okay in jhc)
23:01:25 <lispy> dons: and i'm going, "Yes, the PROTOTYPE is to be THROWN AWAY"
23:01:34 <lispy> thats' the point...
23:02:43 <Cale> lispy: Watch the Haskell prototype be better than the real thing :)
23:03:04 <lispy> Cale: yeah, sadly, i may be the only one that ever gets that
23:03:20 <lispy> Cale: since it's a prototype, others probably won't use it except as a toy
23:03:50 <Cale> what is it a prototype of?
23:04:04 <lispy> dunno, that why we wrote a prototype ;)
23:04:09 <Cale> heh
23:04:19 <Cale> and what will it be rewritten in?
23:04:35 <lispy> Cale: our main product is simulation software, but the simulation's evaluation output is mostly noise when you look at it...i'm trying to help summarize it in more meaningful ways
23:04:51 <lispy> C++
23:05:12 <lispy> buggy C++ :)
23:05:20 <thou> jobs security
23:05:22 <lispy> afaict, we don't have any sort of testing framework
23:05:31 <Cale> Make sure to hand the Haskell prototype code to the C++ programmers, so they know what they're implementing :)
23:05:52 <lispy> Cale: potentially it will be me rewriting it
23:06:22 <Cale> heh, will people look at the C++ version's code?
23:06:55 <lispy> i would assume so, do you think i should litter each class with the 3 lines of haskell it is replacing? ;)
23:07:39 <Cale> If people are going to look at it, definitely. If not, then you should construct the "C++" version from the C output of ghc :)
23:07:50 <lispy> haha
23:08:16 <lispy> sadly we use Visual Studio, i doubt it can compile ghc -fvia-c
23:08:27 <Cale> I can only imagine the shock and horror of a C++ maintenance programmer having to deal with that
23:08:36 <lispy> heh, yeah
23:09:16 <thou> lol
23:09:45 <lispy> i may actually be able to write it in C# or VB
23:09:53 <lispy> not sure if that's any better than C++ though
23:10:36 <lispy> if haskell were an official .NET language i bet they'd let me use it
23:10:52 <Cale> Is F# ready yet?
23:11:02 <lispy> i never can tell
23:11:12 <lispy> from what i see, it requires a special CLR
23:14:23 <lispy> the bottom line is, haskell makes them nervous, they want C++/C# in the big flag ship application
23:14:35 <lispy> which i can understand to a point
23:14:47 <lispy> you have to go with what you trust
23:15:03 <lispy> but, that's where i start to go, "Wait, a tic....you TRUST C++ and C#?"
23:15:21 * glguy notes the huge difference in webbrowsing with installed fonts properly configured
23:16:58 <glguy> I think it works like this: "You are the only person that could work on this app if you write it in Haskell that I'm going to find.  I can find 100 C# programmers to fill your position if you leave"
23:17:58 <lispy> that could be part of it
23:18:35 <lispy> i think, if i have to be writing in C#/Java on a regular basis for the next 10 years, I'd switch professions tomorrow
23:18:36 <thou> job security
23:19:01 <JKnecht> is a bitch
23:19:09 <glguy> job security also means you aren't getting promoted
23:19:15 <lispy> my ex is not job security
23:19:24 <thou> :)
23:20:21 <vegai> glguy: how about...
23:20:22 <lispy> i think writing C++/C#/Java i could probably do 5 more years, python another 10...and after that it's hard to say
23:20:58 <vegai> glguy: "I'm so confident of my Haskell skills that I'll sign a contract that gives you free bug fixes for 5 years"
23:21:10 * vegai dreams on....
23:22:42 <Cale> vegai: and then they start to get loose with the definition of 'bug'
23:29:08 <glguy> and contracts are made to be broken
23:30:45 <_velco> write a haskell program, which generates the C# sources ...
23:31:45 <emu> and proves them correct
23:37:54 <JKnecht> glguy: bad idea/attitude.
23:45:32 <glguy> JKnecht: It's not my personal attitude, it's what I've seen in the real world.
23:46:38 <Bobstopper> Can anyone point me to a resource which will clear up when to use newtype declarations for me?
23:46:56 <glguy> Bobstopper: do you understand what a data declaration is?
23:47:03 <Bobstopper> Yeah
23:47:19 <glguy> a newtype declaration is a specific kind of data declaration, that is more efficient
23:47:39 <glguy> it can accept a single parameter on it's single constructor
23:47:45 <glguy> and adds no overhead when compiled
23:47:51 <Bobstopper> So it's just an optimisation?
23:47:52 <glguy> put allows you to define new istances
23:48:22 <Bobstopper> the whole _|_ difference won't make any significant difference to how it works semantically?
23:48:53 <glguy> Bobstopper: by wrapping some type in a newtype, you are hiding the original types instances
23:49:17 <glguy> Bobstopper: I'm not sure how to answer your bottom question.
23:49:53 <Bobstopper> hiding of instances would work just the same by using data though, right?
23:50:00 <glguy> Bobstopper: yeah, exactly
23:50:21 <glguy> Bobstopper: newtype is just a more efficient data type, with restrictions on how complicated it can be
23:50:56 <Bobstopper> Ok, so it's primarily an optimisation and I can treat it exactly the same as an optimised form of data declarations which only works for small, applicable declarations.
23:51:05 <glguy> yeah
23:51:06 <Bobstopper> Ok, thanks.
23:51:27 <glguy> anyone want to verify what I've just told Bobstopper?
23:51:43 <Botty> how do i make a dummy "Ptr CInt" object to allow a C function to modify a value
23:52:26 <Bobstopper> I keep reading a mention of bottom being a caveat. I was wondering under what circumstances it actually comes into play. I saw a mention that it makes pattern-matching differ but I haven't seen any explanation of how...
23:52:43 <Botty> whenever they want to return more than 1 thing, they make parameters that take pointers to mem locations it expects you to setup.  stupid lack of tuples
23:55:49 <Botty> nevermind, found it
23:56:23 <roconnor> if you do data Foo = Foo Integer
23:56:36 <roconnor> then you can pattern match bar (Foo x) = ...
23:56:43 <roconnor> err
23:56:46 <roconnor> if you do data Foo = Foo Integer
23:56:56 <roconnor> then Foo _|_ is a member of Foo
23:57:05 <roconnor> but if you do newtype Foo = Foo Integer
23:57:22 <Botty> malloc :: Storable a => IO (Ptr a)
23:57:29 <roconnor> then Foo _|_ is the same as _|_
23:57:32 <Botty> how do I specify the type of a when i call this?
23:57:47 <Bobstopper> Oh. So the difference is extremely subtle and you know when to watch out for it because you're explicitly using _|_ ?
23:58:21 <JKnecht> glguy: well alrighty then :)
23:58:44 <roconnor> Bobstopper: I think that is right
23:58:53 <Bobstopper> ok, thanks plenty
23:59:22 <roconnor> ... I think newtype Foo = Foo Integer might be considered an efficent form of data Foo = Foo !Integer
23:59:51 <roconnor> and in GHC with -funbox-strict-fields, I would expect them to even be the same
