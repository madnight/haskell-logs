00:00:47 <dons> oh, we've almost caught last year...
00:00:49 <dons> ?where stats
00:00:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
00:00:58 <lispy> i think this is crazy
00:00:59 <lispy> > filter (/=1) . map length . group . take 100000 . fix $ show
00:01:00 <lambdabot>  [3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,34465]
00:01:17 <dons> fix show . fun!
00:01:35 <lispy> > map length . group . take 100000 . fix $ show
00:01:37 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
00:01:39 <dons> that's a mystical bit of code
00:01:52 <lispy> tying the knot is cool ;)
00:02:30 <lispy> hm...should try to sum adjacent elements
00:02:38 <lispy> how would you express that with map or fold
00:02:41 <dons>   * lispy: > filter (/=1) . map length . group . take 100000 . fix $ show
00:02:41 <dons>   * lambdabot: [3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,34465]
00:02:50 <dons> urgh, Quotes of the Week
00:03:06 <lispy> quotes of the week?
00:03:10 <dons> :)
00:03:15 <Korollary> for hwn
00:03:19 <lispy> haha
00:03:28 <lispy> ?where hwn
00:03:28 <lambdabot> http://sequence.complete.org/
00:03:51 <Korollary> > filter (/=1) . map length . group . take 1 . fix $ show
00:03:52 <lambdabot>  []
00:04:46 <astrolabe> @type fix
00:04:47 <lambdabot> forall a. (a -> a) -> a
00:05:07 <lispy> how would you write a function that did [1,1,2,2] -> [2,4]
00:05:47 <lispy> [1,2,3,4] -> [3,7] -- better example
00:06:04 <Korollary> > let f x = case x of {(a:b:r) -> (a+b) : r; _ -> [] } in f [1,2,3,4]
00:06:05 <lambdabot>  [3,3,4]
00:06:08 <Korollary> eek
00:06:17 <Korollary> > let f x = case x of {(a:b:r) -> (a+b) : (f r); _ -> [] } in f [1,2,3,4]
00:06:18 <lambdabot>  [3,7]
00:06:20 <Pseudonym> > let f _ = [3,7] in f [1,2,3,4]
00:06:21 <lambdabot>  [3,7]
00:06:37 <lispy> Pseudonym: heh, sort!
00:06:41 <lispy> consice even
00:06:52 <ThreeQ> > (\(a:b:c:d:[]) -> [a+b,c+d]) [1,2,3,4]
00:06:53 <lambdabot>  [3,7]
00:06:57 <astrolabe> > fix (\x -> x*x-2) (5::Double)
00:06:58 <lambdabot>  add an instance declaration for (Num (Double -> a))
00:07:55 <Pseudonym> > let f xs = zipWith (+) xs (tail xs) in f [1,2,3,4]
00:07:56 <lambdabot>  [3,5,7]
00:08:00 <dons> reminds me of audreyt's dictionary trick
00:08:01 <Pseudonym> That's close.
00:08:29 <Pseudonym> You then just need to drop every second element.
00:08:43 <dons> > let _"bye" = "ciao" in _"bye"
00:08:43 <lambdabot>  Parse error in pattern
00:09:22 <lispy> > f . map length . group . take 100000 . fix $ show where f x = case {(a:b:r) -> (a+b) : (f r); _ -> []}
00:09:23 <lambdabot>  Parse error
00:09:33 <Pseudonym> > let f xs = map snd . filter fst . zip (fix ((True:).(False:)) $ zipWith (+) xs (tail xs) in f [1,2,3,4]
00:09:34 <lambdabot>  Parse error
00:09:44 <lispy> > let f x = case {(a:b:r) -> (a+b) : (f r); _ -> []} in f . map length . group . take 100000 . fix $ show
00:09:44 <lambdabot>  Parse error
00:10:04 <lispy> > let f x = case x of {(a:b:r) -> (a+b) : (f r); _ -> []} in f . map length . group . take 100000 . fix $ show
00:10:05 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,34466]
00:10:12 <lispy> there we are
00:10:38 <Pseudonym> > let f xs = map snd . filter fst . zip (fix ((True:).(False:))) $ zipWith (+) xs (tail xs) in f [1,2,3,4]
00:10:40 <lambdabot>  [3,7]
00:10:43 <Pseudonym> There you go.
00:10:48 <lispy> how to generate powers of two using fix and show :)
00:10:55 <Pseudonym> > let f xs = map snd . filter fst . zip (fix ((True:).(False:))) $ zipWith (+) xs (tail xs) in f [1..10]
00:10:56 <lambdabot>  [3,7,11,15,19]
00:11:17 <lispy> i bet you could do that better with arrows
00:11:17 <dons> mmm.that fix ((True:).(False:))
00:11:25 <Pseudonym> > let f xs = map snd . filter fst . zip (fix ([True,False]++)) $ zipWith (+) xs (tail xs) in f [1..10]
00:11:27 <lambdabot>  [3,7,11,15,19]
00:11:32 <Pseudonym> Shave a few chars off there.
00:11:39 <dmwit> 32768 * 2 = 34466??
00:11:48 <Syzygy-> > 32768*2
00:11:50 <lambdabot>  65536
00:11:54 <lispy> dmwit: it's because of the take
00:11:58 <dons> can you use a unary encoding, based on: fix ([()]++)
00:12:01 <lispy> > let f x = case x of {(a:b:r) -> (a+b) : (f r); _ -> []} in f . map length . group . take 1000000 . fix $ show
00:12:03 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
00:13:01 <lispy> > map length . group . take 1000000 . fix $ ([()]++)
00:13:03 <lambdabot>  [1000000]
00:13:19 <lispy> but i need something to split them up
00:13:25 <dons> maybe lists of [ [()] ]
00:13:38 <lispy> in the case of show it works because you keep needing more \'s to escape the ones you have
00:13:44 <dons> yeah
00:13:45 <lispy> > fix show
00:13:46 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
00:13:57 <Syzygy-> o.O
00:14:21 <lispy> > map (+1) . map length . group . take 100000 . fix $ show
00:14:22 <lambdabot>  [2,2,2,4,2,8,2,16,2,32,2,64,2,128,2,256,2,512,2,1024,2,2048,2,4096,2,8192,2,...
00:14:23 <Syzygy-> > take 1000 . fix $ ([()]++)
00:14:24 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
00:14:35 <lispy> > map (+1) . filter (/=1) . map length . group . take 100000 . fix $ show
00:14:37 <lambdabot>  [4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,34466]
00:14:43 <lispy> that's cheating though
00:14:55 <lispy> because of the +1
00:15:07 <int-e> > replicate 10 ()
00:15:08 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
00:15:40 <lispy> fix is wonderful..but i'm still learning to use it
00:15:50 <lispy> for example, how can we use fix to remove the let?
00:15:55 <ValarQ> what the heck is fix?
00:16:04 <Syzygy-> @hoogle fix
00:16:04 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
00:16:04 <lambdabot> Control.Monad.Fix :: module
00:16:04 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
00:16:21 <lispy> > let f x = case x of {(a:b:r) -> (a+b) : (f r); _ -> [] in f [1..10]
00:16:21 <lambdabot>  Parse error
00:16:23 <ValarQ> > fix id
00:16:24 <lambdabot>  Add a type signature
00:16:30 <lispy> > let f x = case x of {(a:b:r) -> (a+b) : (f r); _ -> []} in f [1..10]
00:16:31 <lambdabot>  [3,7,11,15,19]
00:16:38 <Syzygy-> > fix id :: Int
00:16:39 <ValarQ> > fix (id :: Int -> Int)
00:16:39 <lambdabot>  Exception: <<loop>>
00:16:40 <lambdabot>  Exception: <<loop>>
00:16:43 <ThreeQ> fix f = f $ fix f
00:17:35 <ValarQ> > fix (+1)
00:17:37 <lambdabot>  Exception: <<loop>>
00:17:45 <ValarQ> ?
00:17:45 <lispy> so how could you use fix to remove the need for (f r) in hat above let?
00:17:48 <lispy> or could you?
00:18:04 <Syzygy-> > fix (\x->1/x) :: Double
00:18:06 <lambdabot>  Exception: <<loop>>
00:18:20 <ThreeQ> fix (+1) = 1 + fix (+1) = 1 + 1 + fix (+1) = 1 + 1 + 1 + 1 + ...
00:18:28 <lispy> > (fix $ \x f -> case x of {(a:b:r) -> (a+b) : (f r); _ -> []}) [1..10]
00:18:29 <lambdabot>  Couldn't match `t -> t1' against `[a]'
00:18:59 <lispy> > (fix $ \x f -> case x of {(a:b:r) -> (a+b) : (f r); _ -> []} [1..10])
00:19:00 <lambdabot>  Parse error
00:19:08 <lispy> > fix (\x f -> case x of {(a:b:r) -> (a+b) : (f r); _ -> []} [1..10])
00:19:08 <lambdabot>  Parse error
00:19:16 <lispy> hmm..
00:19:34 <lispy> > fix ((\x f -> case x of {(a:b:r) -> (a+b) : (f r); _ -> []}) [1..10])
00:19:35 <lambdabot>  Couldn't match `[a] -> [a]' against `[a]'
00:19:48 <lispy> i should go in private :)
00:24:17 <lispy> > fix (\f x -> case x of {(a:b:r) -> (a+b) : f r; _ -> []}) [1..10]
00:24:18 <lambdabot>  [3,7,11,15,19]
00:24:33 <lispy> now how can we be rid of the case
00:25:16 <lispy> > fix \f xs -> map snd . filter fst . zip (fix ([True,False]++)) $ zipWith (+) xs (tail xs) [1..10]
00:25:23 <musasabi> shapr: did you get anywhere with the wiki/templating plans?
00:25:34 <lispy> hmm...
00:25:41 <lispy> > 1
00:25:46 <musasabi> shapr: I think HAppS debian package will probably happen once 6.6 is in Debian.
00:26:04 <ThreeQ> > "hello?!"
00:26:36 <ThreeQ> ...
00:27:06 <dons> hmm
00:27:11 <lambdabot>  Parse error
00:27:14 <dons> ah
00:27:27 <lambdabot>  1
00:27:39 <lambdabot>  "hello?!"
00:27:40 <dons> probably someone did something verbose...
00:30:08 <lispy> > map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show -- point free version!
00:30:10 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
00:30:29 <mwc> I don't understand the obscession with point free stuff
00:30:32 <mwc> what's the point?
00:30:36 <dons> heh
00:30:42 <lispy> that's the thing, it's pointless
00:30:53 <dons> its haskell golf
00:30:57 <mwc> It's one of those haskellisms I just don't get, the other would be rank-N types, where N >= 2
00:31:03 <lispy> it's interesting that it removed a fix
00:31:07 <dons> they're useful too.
00:31:14 <lispy> fix (\f xs -> map snd . filter fst . zip (fix ([True,False]++)) $ zipWith (+) xs (tail xs)) . map length . group . take 1000000 . fix $ show
00:31:24 <lispy> that's what it was before the pointfree transformation
00:31:24 <mwc> Yeah, I read about how the use of rank2 types in the ST monad makes it impossible to mix states
00:31:32 <mwc> I don't really understand ow that works
00:31:36 <mwc> @type runST
00:31:37 <lambdabot> Not in scope: `runST'
00:31:48 <mwc> @type Control.Monad.ST.runST
00:31:49 <lispy> ?pl fix (\f xs -> map snd . filter fst . zip (fix ([True,False]++)) $ zipWith (+) xs (tail xs)) . map length . group . take 1000000 . fix $ show
00:31:49 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
00:31:50 <lambdabot> map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show
00:32:15 <lispy> in this case, the pointfree transformation is rather interesting
00:33:07 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show -- point free version!
00:33:09 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
00:33:23 <lispy> hmm...not all of those are powers of two
00:33:36 <mwc> @list
00:33:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:34:06 <mwc> Return the value computed by a state transformer computation. The forall ensures that the internal state used by the ST  computation is inaccessible to the rest of the program.
00:34:12 <mwc> I don't understand how that forall accomplishes that
00:34:17 <mwc> could I please be enlightened?
00:34:54 <mwc> those are the docs for the runST function
00:35:24 <mwc> I looked through TaPL, and didn't find any explanation
00:35:58 <ThreeQ> > zip (init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show) (map (2^) [1..])
00:36:01 <lambdabot>  [(2,2),(4,4),(8,8),(16,16),(32,32),(64,64),(128,128),(256,256),(512,512),(10...
00:36:33 <ThreeQ> > filter (\(a, b) -> a /= b) $ zip (init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show) (map (2^) [1..])
00:36:35 <lambdabot>  []
00:37:26 <dons> mwc, from memory, since the type is bound locally, and isn't visible outside the runST, it is impossible to unify it with another state. (forall a . a) /= (forall b . b)
00:38:12 <int-e> > fix (scanl (+) 1)
00:38:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:38:19 <mwc> Ah, I see what you mean... more to the point, there's no way to deduce that (forall a. a) == (forall b.b)
00:38:20 <int-e> > iterate (*2) 1
00:38:21 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
00:38:29 <dons> mwc, yeah
00:39:07 <mwc> Or actually, the type inside the runST is known exactly, so it's more that you can't say (forall a. a) == b
00:39:22 <mwc> cool
00:40:09 <lispy> that's so cool that you can get rid of let by using fix
00:40:15 <lispy> i'm going to have to start doing that :)
00:40:20 <lispy> just to confuse the n00bs :)
00:40:57 * mwc strikes down lispy with the +9 Sword of Legibility in the name of Knuth.
00:43:40 <lispy> heh
00:44:00 <lispy> here is a question, how to define as a lambda abstraction without using fix...
00:44:06 * lispy looks up the Y combinator
00:45:25 <lispy> Y = \f -> (\x -> f (x x)) (\x -> f (x x))
00:45:32 <roconnor> @hoogle noBuffering
00:45:33 <lambdabot> System.IO.NoBuffering :: BufferMode
00:45:40 <Syzygy-> Oh bugger. The lambda calculus conference in Paris 2007 most probably is too far from my field for me to get to go there...
00:45:42 <roconnor> @hoogle BufferMode -> IO ()
00:45:43 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
00:45:49 <lispy> ?let y = \f -> (\x -> f (x x)) (\x -> f (x x))
00:45:50 <lambdabot> <local>:3:22:     Occurs check: cannot construct the infinite type: t = t -> ...
00:46:10 <lispy> ?type \f -> (\x -> f (x x)) (\x -> f (x x))
00:46:12 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
00:46:12 <lambdabot>    Expected type: t
00:46:24 <lispy> both wikipedia have a typo?
00:46:36 <kosmikus> no
00:46:38 <lispy> or is this definition not valid in the type lambda calculus
00:46:44 <kosmikus> correct
00:46:58 <lispy> hmm..
00:47:01 * lispy reads further
00:48:50 <lispy> ?type \f -> (\x -> f (\y -> x x y)) (\x -> f (\y -> x x y))
00:48:51 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
00:48:51 <lambdabot>    Expected type: t
00:49:30 <lispy> ?type (\x -> \y -> x y x) (\y -> \x -> y (x y x))
00:49:32 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
00:49:32 <lambdabot>    Expected type: t
00:49:42 <lispy> okay
00:49:47 <Bourbaki> moin
00:49:58 <lispy> how do you define it in haskell's type system as a lambda?
00:50:39 <kosmikus> lispy: it's not possible without using recursion, either on the value or on the type level
00:51:26 <lispy> kosmikus: oh and the ones i'm trying require it on the type level?
00:51:43 <kosmikus> yes, basically
00:52:25 <hitodama> does anyone know of any websites on implementations of neural networks in Haskell?
00:53:40 <lispy> hitodama: afraid i don't...
00:55:56 * lispy calls it a night
01:04:04 <roconnor> lispy: http://r6.livejournal.com/95963.html
01:04:06 <lambdabot> Title: r6: Y Combinator in Haskell
01:07:00 <dons> bringert++ stand alone derivings!
01:08:05 <bringert> dons: thanks
01:08:28 <bringert> I implemented it at the hackathon + icfp, but I haven't dared push it until now
01:08:57 <dons> heh
01:09:02 <dons> the testsuite runs?
01:09:08 <Bourbaki> dons did you have had the time to have a quick look at the files yet?
01:09:25 <dons> not yet Bourbaki. sorry :/
01:10:02 <Bourbaki> hm
01:10:21 <dons> i'm working my way back through my email inbox
01:10:30 <bringert> dons: yeah, but some stuff fails on intel macs, not my fault I think
01:10:35 <Bourbaki> hehe first in first out ;)?
01:10:40 <bringert> I should try on some other machine
01:10:52 <bringert> gotta go work
01:10:52 <dons> i've only got 20 or so (harder) ones to reply to now
01:11:22 <dons> hehe, tutbot is almost more popular then lambabot now,
01:11:22 <dons> 51. Lambdabot (4,613 views)
01:11:23 <dons> 52. Roll your own IRC bot (4,542 views)
01:22:04 <slon_> can anyone help me? i'm having trouble understanding how, e.g., this is computed:
01:22:11 <slon_> [1,2] >>= (\x -> [1,2] >>= (\y -> return (x, y)))
01:22:49 <dons> so they key is to work out what >>= does in the list monad, yes?
01:22:55 <dons> > [1,2] >>= (\x -> [1,2] >>= (\y -> return (x, y)))
01:22:57 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
01:23:01 <dons> ?redo [1,2] >>= (\x -> [1,2] >>= (\y -> return (x, y)))
01:23:02 <lambdabot> (\ x -> (\ y -> return (x, y)))
01:23:19 <dons> hmm redo broke there, I think :)
01:23:34 <slon_> well, i understand (>>=), but what i'm having trouble w/ is how x and y can be used when they're seemingly not yet calculated
01:23:41 <slon_> perhaps i'm just reading it wrong, i'm not sure
01:23:43 <dons> instance  Monad []  where
01:23:43 <dons>     m >>= k             = foldr ((++) . k) [] m
01:23:43 <dons>     m >> k              = foldr ((++) . (\ _ -> k)) [] m
01:23:59 <dons> hmm? they're bound to the result of the previous action
01:24:13 <dons> i.e. do x <- [1,2] ; y <- [1,2] ; return (x,y)
01:24:33 <dons> ?undo do x <- [1,2] ; y <- [1,2] ; return (x,y)
01:24:33 <lambdabot> [1, 2] >>= \ x -> [1, 2] >>= \ y -> return (x, y)
01:24:57 <dons> so, rewriting
01:25:07 <slon_> hmm i see, i suppose i was just reading it wrong
01:25:20 <slon_> thank you
01:25:49 <dons> foldr ((++) . (\x -> foldr ((++) . ([(x,y)]) ) [] [1,2]) ) [] [1,2]
01:58:47 <lisppaste2> Bobstopper pasted "Assembler errors while building MissingH under wine" at http://paste.lisp.org/display/27385
02:00:16 <Bobstopper> What might cause assembler errors like this?
02:03:26 <dons> sjanssen: got your tshirt yet? looks like all US ones have shipped
02:07:24 <MarcWeber> Sorry for the noise because of this in the past. You can find my coding aids about vim/ haskell here now: http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim
02:07:27 <lambdabot> Title: Libraries and tools/Program development - HaskellWiki, http://tinyurl.com/zo9ko
02:07:45 <dons> cheers MarcWeber
02:09:08 <dons> cool. looks like some useful things.
02:12:58 <MarcWeber> dons. That's why I've spend some time writing it. *taking a bow* ;)
02:17:36 <russo_> hey guys is % (rest) not defined in haskell?!
02:18:25 <ulfdoz> use mod
02:19:08 <ulfdoz> > 5 `mod 3
02:19:09 <lambdabot>  Parse error
02:19:12 <ulfdoz> > 5 `mod` 3
02:19:13 <lambdabot>  2
02:20:36 <russo_> > 5 mod 3
02:20:37 <mauke> > 3 % 6
02:20:37 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
02:20:37 <lambdabot>   In the...
02:20:38 <lambdabot>  1%2
02:20:48 <russo_> oh why do you need '?
02:20:52 <mauke> not ', `
02:21:00 <mauke> `` turns functions into operators
02:21:04 <mauke> > mod 5 3
02:21:05 <lambdabot>  2
02:21:49 <russo_> aha!
02:21:51 <russo_> thanks mate :)
02:24:13 <russo_> ahh that didn't exactly solve it
02:24:23 <russo_> is fractional int in haskell?
02:24:30 <russo_> or does that mean double etc
02:25:50 <mauke> do you want floating point numbers or rationals?
03:12:54 <roconnor> @hoogle Buffer
03:12:55 <lambdabot> System.IO.BufferMode :: data BufferMode
03:12:55 <lambdabot> Network.Socket.RecvBuffer :: SocketOption
03:12:55 <lambdabot> Network.Socket.SendBuffer :: SocketOption
03:13:01 <roconnor> @hoogle BufferMode
03:13:02 <lambdabot> System.IO.BufferMode :: data BufferMode
03:13:10 <roconnor> @hoogle Buffering
03:13:11 <lambdabot> IO.hGetBuffering :: Handle -> IO BufferMode
03:13:11 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
03:13:11 <lambdabot> System.IO.BlockBuffering :: Maybe Int -> BufferMode
03:13:22 <roconnor> @info BufferMode
03:13:22 <lambdabot> BufferMode
03:13:42 <roconnor> @docs BufferMode
03:13:43 <lambdabot> BufferMode not available
03:13:49 <roconnor> @docs IO
03:13:50 <lambdabot> IO not available
03:13:55 <roconnor> @docs System.IO
03:13:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
03:23:13 <roconnor> > 2^20*512
03:23:15 <lambdabot>  536870912
03:35:27 <roconnor> > 2^10*512
03:35:28 <lambdabot>  524288
03:41:43 <musasabi> hmm. Why is Int faster than Int32 on 32 bit GHC?
03:42:28 <Bourbaki> maybe because you can do two int16 ops at once?
03:42:29 <Xgc> musasabi: You're probably not using the native types directly.
03:43:14 <Xgc> musasabi: and Int probably doesn't map to Int32.
03:43:37 <musasabi> Int = 32 bit integer with 32 bit GHC.
03:51:01 <musasabi> "fib k = if k <= 1 then k else fib (k-1) + fib (k-2)" is enough to trigger it.
03:53:07 <dons> i've seen differences, as you report, too.
03:53:16 <dons> and in somce cases Word32 has been better than Int
03:53:26 <dons> Int does have some special heuristics in the compiler though
03:53:43 <dons> e.g. [Int] is unpacked for certain sizes
03:53:59 <dons> writing shootout code, musasabi ?
03:56:04 <musasabi> dons: was actually testing how much Int64 hurts on x86 and then checked Int32 and was suprised it was slower than Int.
03:57:33 <dons> there may be rules for Int as well, that are missing for Int32
03:57:45 <dons> you could check with -ddump-simpl-stats to see if any other rules fire
04:08:04 <musasabi> dons: Int32 fires one rule ("1 ==#->case"), Int none.
04:12:15 <dons> interesting!
04:12:31 <dons> so the core ends up a little different?
04:41:53 <roconnor> OMG, the umix program allocates hundreds of thousands of tiny blocks of memory
04:43:06 <roconnor> 273386/1220252
04:43:10 <roconnor> > 273386/1220252
04:43:11 <lambdabot>  0.2240406080055595
04:43:20 <roconnor> > recip it
04:43:21 <lambdabot>  Not in scope: `it'
04:43:33 <roconnor> > 1220252/273386
04:43:34 <lambdabot>  4.463476549640435
04:43:57 <roconnor> on average 4.4 words are allocated per allocation
04:46:35 <roconnor> > 20797094/4878884
04:46:36 <lambdabot>  4.262674414886683
04:46:49 <roconnor> no wonder my haskell UM is so slow.
04:47:09 <roconnor> almost 5 million active allocated platters!
04:52:24 <int-e> roconnor: yes, I found that, too ... it's crazy.
04:52:36 <hugoh> hey!
04:52:45 <hugoh> todays question from me to come now..  :)
04:52:57 <int-e> oh I can't stand the suspense.
04:53:12 <hugoh> how come i cant make a list of two lists ? like  [1,2,3] : [4,5,6] to form [[1,2,3],[4,5,6]] :/
04:53:45 <roconnor> wanted: a UM implemenation that is safe & doesn't leak memory & doesn't require more than 512M of memory to run the adventure game.
04:53:58 <roconnor> > [[1,2,3],[4,5,6]]
04:54:00 <lambdabot>  [[1,2,3],[4,5,6]]
04:54:19 <roconnor> hugoh: there is no problem with that?  how are you trying to do it?
04:55:10 <dons> > [1,2,3] : [4,5,6] : []
04:55:11 <lambdabot>  [[1,2,3],[4,5,6]]
04:55:15 <hugoh> ah
04:55:20 <hugoh> > [1,2,3] : [4,5,6]
04:55:20 <lambdabot>  add an instance declaration for (Num [a])
04:55:21 <lambdabot>   In the list element: 6
04:55:26 <dons> > [1,2,3] : [[4,5,6]]
04:55:27 <hugoh> like that
04:55:27 <lambdabot>  [[1,2,3],[4,5,6]]
04:55:39 <dons> > [[1,2,3]] ++ [[4,5,6]]
04:55:40 <lambdabot>  [[1,2,3],[4,5,6]]
04:55:55 <hugoh> ah i see
04:55:55 <dons> data data data!
04:55:56 <ValarQ> @pl \x y -> [x,y]
04:55:57 <lambdabot> (. return) . (:)
04:56:03 <ValarQ> there we go
04:56:13 <dons> ?pl [1,2,3] : [4,5,6] : []
04:56:14 <lambdabot> [[1, 2, 3], [4, 5, 6]]
04:56:20 <dons> clever
04:56:21 <ValarQ> > let f = (. return) . (:) in [1,2,3] `f` [4,5,6]
04:56:22 <lambdabot>  [[1,2,3],[4,5,6]]
04:57:14 <hugoh> hmm
04:57:25 <ValarQ> :o)
04:57:51 <hugoh> that seems nice ValarQ, but i dont think i really get why i cant just put my lists together as i can when i do 1 : 2 to form [1,2]. but maybe i will understand it in time.
04:58:05 <ValarQ> > 1 : 2
04:58:06 <lambdabot>  add an instance declaration for (Num [a])
04:58:07 <vegai> because : is not concatenation
04:58:18 <ValarQ> hugoh: you can't, apparently
04:58:22 <hugoh> yeah :)
04:58:23 <int-e> > 1 : 2 : []
04:58:24 <lambdabot>  [1,2]
04:58:36 <SamB_XP> hmm, how do I get the "home" and "end" keys working with PuTTY and Linux...
04:58:43 <SamB_XP> and libreadline...
04:58:54 <hugoh> SamB_XP: offtoooopic
04:58:56 <hugoh> hihi
04:59:10 <Thomas2_> pssh @ topic
04:59:13 <hugoh> vegai: concatenation ?
04:59:16 <SamB_XP> hugoh: yes I know it is off topic
04:59:29 <SamB_XP> regulars are allowed off-topic questions ;-)
04:59:44 <vegai> hugoh: : is used to construct lists. ++ is used to concatenate (add two lists together)
05:00:06 <hugoh> ah
05:00:06 <SamB_XP> of course, nobody is necessarily going to answer...
05:00:38 <dons> ?type (:)
05:00:40 <lambdabot> forall a. a -> [a] -> [a]
05:00:43 <musasabi> of course there *is* #haskell-blah
05:00:49 <hyrax42> SamB_XP, mine just works
05:00:54 <hyrax42> ?
05:01:10 <vegai> SamB_XP: is that the linux version of putty?
05:01:29 <hyrax42> at least in ghci which uses readline, right?
05:01:36 <dblhelix> @seen Syntax-Ninja
05:01:36 <lambdabot> I haven't seen Syntax-Ninja.
05:01:39 <Thomas2_> why would anyone use a linux putty?
05:01:39 <hyrax42> oh,linux putty
05:01:42 <dblhelix> @seen SyntaxNinja
05:01:42 <lambdabot> I saw SyntaxNinja leaving #haskell 19h 14m 26s ago, and .
05:01:43 <hyrax42> ?
05:02:12 <Thomas2_> to unpack that, putty is typical of windows progs, it's an all-in-one
05:02:36 <Thomas2_> in linux, you have two programs, one for being a terminal, another for connecting to a remote machine within that terminal
05:03:36 <SamB_XP> vegai: nope, the windows one
05:04:39 <vegai> actually, in Linux, you also have dozens of different terminal-implementing things..
05:04:59 <vegai> well, in X11.
05:05:02 <Thomas2_> well, yeah
05:05:03 <SamB_XP> yeah
05:05:11 <SamB_XP> quite
05:05:24 <Thomas2_> you have options for each of the programs
05:05:30 <SamB_XP> but why doesn't my "home" key work?
05:05:33 <Thomas2_> but the equivalent of putty is two programs
05:05:52 <SamB_XP> yes, well, you can do that on Windows too
05:06:01 <Thomas2_> it's just painful :-)
05:06:06 <Thomas2_> it wasn't really designed that way
05:06:13 <SamB_XP> yeah
05:06:17 <Thomas2_> erm, putty has some key-cooking options somewhere
05:06:24 <SamB_XP> oh, and maybe you can't actually do it right...
05:06:40 <hyrax42> SamB_XP, under settings/keyboard
05:06:44 <hyrax42> what are you home end keys set to
05:06:53 <Thomas2_> I see a bullet point option of whether home/end sends standard or rxvt
05:07:08 <Thomas2_> the distinction is meaningless to me but i'd suggest you try toggling it
05:07:09 <dcoutts_> dons, in answer to your Q about what inotify is for: very useful in guis, eg a dir tree that updates in real time with changes in the filesystem
05:07:13 <SamB_XP> hyrax42: "Standard"
05:07:25 <hyrax42> SamB_XP, then I can't help...
05:07:31 <dcoutts_> dons, or monitoring for changes in some bit of hardware that is reflected in some /sys vfs etc
05:07:38 <hyrax42> my home and end keys seem to work in Standard just fine
05:07:46 <SamB_XP> hyrax42: what do you have for "Answerback to ^E"?
05:08:06 <hyrax42> PuTTy
05:08:08 <vegai> also you can make nifty indexing daemons update themselves automatically with inotify
05:08:15 <hyrax42> PuTTY rather
05:08:27 <hyrax42> anyway, need to get going
05:08:33 <hyrax42> hope you srot it out
05:08:47 <Thomas2_> yeah, I was writing a dynamic build system once, and inotify looked like an awesome option
05:09:25 <SamB_XP> well, okay, so with rxvt-style the "home" key works but the "end" key doesn't.
05:09:31 <SamB_XP> thats a bit better...
05:09:31 <Thomas2_> heh
05:10:11 * Thomas2_ tries to recall what that terminal settings prog is
05:10:54 <vegai> stty?
05:11:08 <ulfdoz> setterm?
05:13:12 <roconnor> @hoogle IntMap
05:13:13 <lambdabot> Data.IntMap :: module
05:13:13 <lambdabot> Data.IntMap.IntMap :: data IntMap a
05:13:22 <roconnor> @docs IntMap
05:13:23 <lambdabot> IntMap not available
05:13:28 <roconnor> @docs Data.IntMap
05:13:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
05:15:21 <roconnor> on my machine, can I cast between an Int and a Word32?
05:17:06 <roconnor> @hoogle Int -> Word32
05:17:07 <lambdabot> No matches, try a more general search
05:17:15 <Bobstopper> fromIntegral?
05:17:53 <Bobstopper> > fromIntegral (-1 :: Int32) :: Word32
05:17:54 <lambdabot>  4294967295
05:20:12 <roconnor> fromIntegra (4294967295::Word32) :: Int
05:20:16 <roconnor> > fromIntegral (4294967295::Word32) :: Int
05:20:17 <lambdabot>  -1
05:20:23 <roconnor> seems good
05:20:39 <Bobstopper> that helped? Wooh, I helped someone :)
05:21:20 <roconnor> @karma+ Bobstopper
05:21:20 <lambdabot> Bobstopper's karma raised to 2.
05:22:31 <Bobstopper> heh :D
05:23:34 <roconnor> findMax isn't part of IntMap :(
05:31:18 <Bobstopper> You could roll your own perhaps?
05:33:41 <Syzygy-> @karma
05:33:42 <lambdabot> You have a karma of 0
05:34:04 <Bobstopper> @karma
05:34:04 <lambdabot> You have a karma of 2
05:34:20 <Bobstopper> I've never heard of this karma thing before. Lambdabot's full of surprises
05:35:13 <Thomas2_> @karma
05:35:14 <lambdabot> You have a karma of 1
05:35:19 <Thomas2_> there we go
05:44:02 <SamB_XP> huh. I never thought I'd have to use -fno-monomorphism-restriction just for the REPL...
05:51:13 <musasabi> Was Cabal able to create windows binary distributions of packages? Preferrably as an .exe file?
05:51:43 <roconnor> boy, chroot really sucks.
06:07:47 <hanko> anyone used TrueCrypt?
06:08:01 <wilx> I do, in Windows.
06:08:13 <hanko> any good?
06:08:31 <wilx> It works fine for me.
06:08:33 <hanko> TrueCrypt has quite a good rep for on-disk storage stuff and portability, though I heard in a windows environemnt it needs a driver loaded ?
06:09:03 <wilx> Dunno about the on disk format.
06:09:14 <wilx> I use it to create in file volumes.
06:09:50 <hanko> but you need admin access to install it on a windows box.. so it must install something like a driver
06:10:02 <wilx> Yes.
06:10:13 <hanko> I dont know  my stuff is a loopback mounted AES encrypted ext3 image..
06:10:15 <wilx> Yes, it does install a .sys driver.
06:11:07 <hanko> I think the issue is where you have it on a keystick or similar and go to a machine where you don't have admin rights.. you can't get to your stuff
06:11:43 <wilx> Well, if your target's box Linux kernel doesn't have it installed it won't work either :)
06:12:51 <hanko> that is true
06:15:06 <hanko> So i googled and : Encrypt the entire USB flash drive. However, you will not be able run TrueCrypt from the USB flash drive.
06:15:18 <hanko> ie How can I use TrueCrypt on a USB flash drive? :D
06:16:54 <flux__> there was some discussion on truecrypt with flash-devices (..actually on /. ..), where it was claimed that truecrypt's crypto isn't suitable for encrypting usb devices, where older versions of the 'overwritten' block may still be accessible
06:16:55 <wilx> Can't you create an encrypted volume in file and copy that onto the stick and use that instead of direct on disk volume?
06:17:07 <flux__> uh
06:17:10 <flux__> not usb-devices, but flash-devices
06:17:53 <wilx> Well, does that matter? The piece of memory even though available is still encrypted.
06:18:11 <hanko> wilx: I assume you could
06:18:46 <SamB_XP> wilx: might make the encryption easier to crack though
06:19:04 <flux__> it had something to do with the encryption mode truecrypt uses
06:19:33 <flux__> I believe the problem was related to using modes that produce the same amount of output as they have input, which is very convenient in block devices
06:20:03 <flux__> I don't know how feasible such attacks will be to implement, though
06:20:24 <flux__> but assumable they are much more realistic that just bruteforcing :)
06:21:04 <wilx> Huh.
06:22:13 <hugoh> i managed to do something unexpected now, atleast my supervisor was surprised of the fact that it worked, look at http://pastebin.perl.se/96be6d4c68/
06:22:23 <hugoh> where 1-3 = :)
06:22:26 <wilx> If you get the whole stick, do few leftover encrypted blocks laying around help to crack that so much?
06:23:06 <wilx> I think that for all intents and purposes it is safe enough.
06:24:08 <int-e> hugoh: you defined a new function - ... cute.
06:24:51 <hugoh> i didnt know that i could assign a function named 1-3, i thought that it would be evaluated first
06:25:06 <int-e> no, you define a fuction (-) of some type
06:25:34 <int-e> with (-) 1 3 = take 3 (rows sudoku), and so on. it works because all the stuff on the right side has the same type
06:25:43 <hugoh> it doesnt evaluate (1-3) before its sent to iiiToBlock
06:25:51 <int-e> (-) gets type Int -> Int -> <whatever> by defaulting I believe.
06:26:07 <int-e> it still uses the (-) function you defined there.
06:26:19 <hugoh> hmm
06:26:27 <hugoh> >:t (-)
06:26:36 <int-e> @type (-)
06:26:38 <lambdabot> forall a. (Num a) => a -> a -> a
06:26:47 <hugoh> hmm
06:26:58 <int-e> that's the standard -, but you have a local binding that defines it differently
06:27:04 <hugoh> aha
06:27:21 <int-e> > let 33 - 22 = 13; a - b = a + b in (33 - 22, 33 - 23)
06:27:23 <lambdabot>  (13,56)
06:27:28 <hugoh> do you think its a good solution? what i wanted was just a name for my line 1-3 and then 4-6 etc...
06:27:41 <int-e> I'd advise against it because it is confusing
06:27:51 <hugoh> mhm
06:28:20 <int-e> > let 1-3 = 42 in 1-4
06:28:21 <lambdabot>  Non-exhaustive patterns in function -
06:28:34 <hugoh> but, i was surprised of that the name 1to3 didnt work, i guess because functions cant begin with a digit, but this did.
06:28:36 <int-e> also you can get runtime errors like this if you make a mistake
06:28:55 <hugoh> ah
06:29:15 <int-e> and it's much nicer to have the compiler complain instead.
06:30:22 <int-e> oh, another confusing thing ...
06:30:22 <hugoh> instead of.. me?
06:30:26 <int-e> > let 23 = 42 in 23
06:30:27 <lambdabot>  23
06:30:57 <int-e> instead of the program later, while being executed
06:31:35 <hugoh> but, my function worked, atleast in hugs.
06:32:00 <dons> hmm. comments from the masses are strange, http://digg.com/software/Roll_your_own_IRC_bot
06:32:03 <lambdabot> Title: digg - Roll your own IRC bot, http://tinyurl.com/zkmmd
06:32:54 <int-e> hugoh: it works, but maybe not for the reasons that you imagined :)
06:32:55 <dons> seems like a good vibe is around haskell though. not really anything bad to say, other than that its a bit obscure
06:33:15 <kpreid> that's an interesting trick
06:33:37 <int-e> Hmmmmmm. Unlike other esoteric languages I've encountered, Haskell seems to be actually useful. ;)
06:33:48 <dons> funny that :)
06:34:18 <dons> getting these views of the language from the outside in, is always a bit strange, I find.
06:34:32 <hugoh> haha
06:34:51 <hugoh> what do you mean by "a good vibe" around it?
06:34:54 <dons> when you write haskell daily to solve just about anything, its a bit disconcerting to find people who don't even know what it is. oh well.
06:35:05 <hugoh> :)
06:35:10 <dons> hugoh: oh, check the link. the random comments are generally quite positive
06:35:18 <hugoh> okey
06:35:21 <int-e> hah. "Nothing against the language, but it isn't exactly an industry standard."
06:35:29 <dons> hehe
06:36:08 <dons> that's what I mean about "strange" comments
06:36:23 <dons> oh, wasn't C used exclusively in academia once?
06:36:39 <int-e> And eggdrop would be much prettier if TCL wasn't a quoting nightmare.
06:37:30 <dons> one scary thing is the basic lack of comprehension and reading ability
06:38:04 <dons> when writing these things, comments are often wildly off the mark
06:38:38 <dons> doesn't fill me with great hope for humanity :}
06:39:38 <dons> the one that bugged me though was "Haskell is a programming language almost exclusively used in academia. I wouldn't worry about it.". *sigh*
06:40:16 <dons> woo!!!!
06:40:21 <dons> dcoutts_: !!! check your inbox
06:41:23 <hygge> dons: what do you do for a living? :P "when you write haskell daily to solve just about anything"
06:41:26 <earthy> no, C wasn't exclusively used in academia
06:41:32 <earthy> it was developed at AT&T
06:41:41 <dons> ah right.
06:41:41 <int-e> dons: yeah, because nothing that ever came out of academia ever mattered.
06:41:52 <dons> hygge: hehe. don't ask...
06:42:02 <Bobstopper> Heheh. You're always going to get people that think that way about unpopular languages. Trying to make an unpopular language popular is an uphill battle against the status quo. Unless you have a good marketing team like java.
06:42:05 <earthy> actually, C development was concurrent with the development of C's first big program: Unix. :)
06:42:14 <hygge> int-e: wasnt unix made on a university somewhere?
06:42:26 <earthy> hygge: no, Unix was made at AT&T Bell Labs. :)
06:42:31 <hygge> ah
06:42:33 <dons> yeah, i was mostly thinking of unix. and how it was used to teach OSs in unis
06:42:47 <dons> which must have spread C around campus
06:42:58 <earthy> in fact, Unix was made as a concrete implementation of some of the ideas of the then-current academic project called Multics
06:43:26 <Bobstopper> I figure, people who think stuff like that are almost exclusively people who care only about getting jobs and nothing about actually learning or understanding. I wouldn't worry about them.
06:43:35 * Igloo wonders what is in dcouts' inbox
06:43:48 * earthy wonders why the cabal docs suck so much
06:43:49 <profmakx> Igloo, cookies?
06:43:54 <dons> Igloo: oh, the bytestring paper got accepted :)
06:44:02 <Igloo> Ah, congrats  :-)
06:44:03 <Igloo> Where?
06:44:05 <int-e> congrats, dons and dcoutts_ :)
06:44:13 <Syzygy-> dons, dcoutts_: Congratulations. Coool.
06:44:17 <Syzygy-> Accepted where?
06:44:22 <int-e> hygge: I wasn't serious even though Unix is a bad example :)
06:44:23 <dons> PADL, coloc. with POPL this year.
06:44:46 * dons does the happy dance
06:45:19 <Igloo> Oh, that's almost local
06:45:47 <mnislaih> congrats dons
06:45:49 <dons> yeah, only 23 hours away :)
06:45:55 <mnislaih> I hear it got great reviews
06:46:18 <Igloo> Hey, it's not my fault you live in the wrong country  :-)
06:46:23 <dons> so true.
06:46:34 <dons> maybe i should just move to the uk next year. hmm...
06:47:55 <Igloo> E-mail Andy Gill asking about jobs in the UK in ~ a year. We need to demonstrate demand  :-)
06:48:08 <dons> mmmmm!
06:48:19 <Igloo> Or supply, or something
06:49:50 <Igloo> Hmm, TLDI says "Submission deadline was Sunday, October 1, 2006, 5PM PDT. Submission is not closed."
06:50:00 <dons> huh
06:50:19 <dons> sleep time! night all :)
06:50:23 <Igloo> Night!
06:50:26 <musasabi> night
06:50:29 * dons `ap` unconciousness
06:50:47 <earthy> ;)
06:50:52 <Philippa> ap mallet dons
06:50:53 <Philippa> :-)
06:51:03 <Philippa> or the other way round...
06:51:16 <roconnor> how does GHC manage memory?
06:51:22 <Philippa> hrmm, I guess it doesn't really matter, it's the relative momentum that counts
06:51:25 <earthy> automagically. :)
06:51:51 <earthy> philippa: however, generating that momentum is a lot easier when swinging the mallet rather than when swinging dons
06:51:58 <Philippa> roconnor: generational GC. If you want more details, poke around the RTS source
06:52:03 <roconnor> how can I take advantage of that magic in my UM implementation?
06:52:09 <Philippa> earthy: depends where each of dons and the mallet are
06:52:39 <Philippa> there's not much you can do - you can't really free any platters until the UM can, and then they're just gone next time the GC takes a look
06:52:49 <Philippa> you don't really have freedom to shape your access patterns much
06:53:45 <SamB> yeah, I was going to look at GC for that, until valgrind said that UMIX didn't leak...
06:53:57 <roconnor> The problem seems to be keeping track of 500000 platters
06:55:00 <roconnor> Right, GHC knows what are its pointers and what aren't.  But with the UM, a pointer is just a number.
06:55:08 <Philippa> yeah. If you have allocations of a known fixed size you might want to keep them from a pre-allocated pool
06:55:10 <SamB> you would think that they would have taken the UM spec more literally (there is no provision for failure because there are no more array numbers!)
06:55:48 <Philippa> I noticed that there were times when a UM /may/ fail... :-)
06:55:58 <SamB> yes
06:56:02 <SamB> that isn't one of them!
06:56:04 <SamB> I checked.
06:56:07 <roconnor> :)
06:56:08 <earthy> *hmmm*
06:56:29 <earthy> I just figured out a toy to take along to my vacation to scotland...
06:56:40 <roconnor> SamB wouldn't take all weekend to allocate 4 billion platters?
06:57:00 <SamB> you know, I almost wish they'd had provision for multiple widths of array...
06:57:07 <SamB> roconnor: you mean arrays?
06:57:42 <roconnor> um maybe
06:57:47 <roconnor> thing things allocated by alloc
06:57:58 <roconnor> are they arrays?
06:58:19 <SamB>     * A collection of arrays of platters, each referenced by a distinct
06:58:19 <SamB>       32-bit identifier. One distinguished array is referenced by 0
06:58:19 <SamB>       and stores the "program." This array will be referred to as the
06:58:19 <SamB>       '0' array.
06:58:42 <SamB> and of course you don't actually need an infinite supply of platters
06:58:43 <roconnor> okay, arrays
06:58:47 <roconnor> :)
06:59:18 <SamB> 2^64 - 2^32 + 1 should be enough for anything
06:59:34 <roconnor> SamB: I want a UM implemenation that is safe & doesn't leak memory & doesn't require more than 512M of memory to run the adventure game.
06:59:50 <roconnor> none of dons list of UMs satisfy these requirements.
06:59:52 <SamB> roconnor: I'm afraid you want a better *UMIX*
07:00:21 <SamB> because, as I said, I ran valgrind on my UM and it said that everything was still referenced
07:00:38 <roconnor> valgrind?
07:01:00 <SamB> its a Linux tool for finding leaks and things like that
07:01:41 <Igloo> I /think/ umix or adventure leaks inside the UM
07:01:51 <SamB> hmm
07:01:54 <mlh_> it's a vm of sorts itself
07:01:58 <SamB> let me try it on adventure to be sure...
07:02:19 <Igloo> valgrind won't spot it as as far as the UM code is concerned nothing is leaking
07:02:31 <Igloo> You'd need valgrind for UM, not valgrind for x86
07:02:51 <SamB> my UM stuffs pointers into values of type uint32_t, though ;-)
07:03:42 <mux> heh, mine does that
07:03:47 <SamB> so, if the UM drops the references, they will be *gone*
07:03:51 <mux> makes it limited to 32bit architectures, but it's hella faster
07:03:54 <Philippa> roconnor: try modifying one of them with a pooling scheme for common small block sizes, keeping all the allocated blocks up one end of the pool so alloc's constant-time and doesn't chew up any further memory
07:04:01 <mux> also, bad UM code can crash your VM if you do that
07:04:02 <SamB> and valgrind will know that they have leaked
07:04:08 <mux> I was wondering how many people did it this way
07:04:10 <Philippa> ...wait. Can't quite do that, can you? Need to keep the pointers constant
07:04:29 <cjay> what does UM mean?
07:04:41 <SamB> mux: yeah, but I figured the ICFP 2006 contest wasn't a plot to take over my computer ;-)
07:04:45 <Philippa> Universal Machine. The virtual machine from this year's ICFP contest
07:04:45 <ozone> cjay: Universal Machine
07:04:54 <cjay> thanks
07:04:54 <ozone> have you guys seen the ICFP video?
07:05:00 <ozone> that was an awesome presentation
07:06:03 <mux> SamB: *nods* :-)
07:07:12 <roconnor> Philippa: how big of a pool?
07:07:24 <roconnor> what is a pool?
07:07:30 <mux> roconnor: my UM never consumes more than about 50MB
07:07:38 <Philippa> roconnor: up to you. It's probably something you can configure with a command line parameter anyway
07:07:44 <roconnor> mux: can it segfault?
07:07:52 <SamB> mux: how!
07:07:54 <Philippa> a pool's a block of memory from which smaller blocks of memory (typically all the same size) are allocated
07:07:54 <mux> only if the UM code is bad :-)
07:07:57 <SamB> mine eats up a ton!
07:08:02 <SamB> what malloc are you using?
07:08:06 <mux> SamB: mine is C, what language are you using?
07:08:12 <mux> well, C's malloc()
07:08:14 <Philippa> gives you an advantage over a general allocator that has to worry about block size
07:08:19 <SamB> how does it only use 50MB?
07:08:26 * mux shrugs
07:08:27 <SamB> did you not try it on adventure?
07:08:32 <mux> yes I did
07:08:36 <roconnor> mux: but you shouldn't have to trust the codex.
07:08:38 <mux> but didn't notice it using much more
07:08:41 <SamB> ... did you do anything?
07:09:02 <roconnor> Philippa: how do I keep track of which are free and which are allocated?
07:09:06 <mux> roconnor: theoritically yes, but solving the id generation problem by casting 32bits pointers is very fast and I wanted to have fun soon with UMIX
07:09:11 <SamB> roconnor: it was compiled using a compiler written in ML! you don't think they had a bug in their compiler?
07:09:12 * earthy ponders
07:09:19 <mux> SamB: let me check, maybe it's using 50MB only with UMIX loaded
07:09:24 <earthy> theoretically, the UM could do dynamic translation, right?
07:09:32 <SamB> earthy: in theory
07:09:41 <roconnor> mux: sure.  now that the contest is over, I'm podering ... more academic questions.
07:09:41 <earthy> that'd not gain much though.
07:10:14 <SamB> I suppose it would even be practical since UMIX doesn't load arrays other than 0 after startup...
07:10:26 <roconnor> SamB: I think the umix program is a clever way of distributing a virus to computers :)
07:10:53 <SamB> roconnor: but consider that it would need to be cross-libc-build!
07:10:57 <SamB> if not cross-platform!
07:11:06 <SamB> or someone would have reported a segfault by now!
07:11:24 <SamB> also, it doesn't crash the safe interpreters ;-)
07:11:48 <mux> ok, actually, it eats 177M resident once adventure is loaded :)
07:11:51 <Philippa> earthy: the problem's that we have no protection against things like self-modifying code.
07:12:07 <mux> the ~50MB must be when only UMIX is there
07:12:35 <Philippa> roconnor: keeping track of free vs allocated... depends. Unfortunately you're probably left either maintaining a linked list of free blocks or paying a horrific time price for allocation
07:12:48 <SamB> Philippa: sure you do! just deal with them in your handling of 0-array access!
07:12:59 <mux> yeah
07:13:17 <Philippa> SamB: that's not protection, though granted it's implementation :-)
07:13:20 <mux> but you need self-modifying code to work, IIRC, the .umz programs work this way
07:13:25 <mux> oh, actually maybe not
07:13:43 <mux> they could just allocate a new array, twiddle with it and then call load program
07:13:51 <SamB> mux: the simplest solution would be to discard all translated code upon writes to the 0 array
07:14:05 <fasta> Does a newtype has any overhead when compared to a "type" declaration?
07:14:08 <Philippa> and it'll slow down a lot of your translation, because you've got to check for writes to 0
07:14:32 <roconnor> Philippa: yep, sounds like a plan.
07:14:56 <mux> I really need to write that algorithm to solve the adventure game
07:15:05 <roconnor> I'll modify the C++ to keep a vector of freed blocks
07:15:06 <SamB> alternatively you could change the access on your 0 array to be read-only, and handle the signals...
07:15:10 <mux> I did the keypad, the USB cable and the display by hand :-P
07:15:22 <roconnor> mux: you can do the progress bar by hand.
07:15:26 <Philippa> a vector's the wrong structure
07:15:31 <SamB> mux: I had to do some things by hand too...
07:15:34 <mux> roconnor: probably, but I'm getting bored
07:15:40 <Philippa> you want constant head insertion and removal
07:15:40 <mux>      281 um-unsafe.c
07:15:50 <Philippa> (go on guys, quote it - you know you want to...)
07:15:52 * mux didn't want to waste time on writing UM
07:15:54 <mux> it's easy
07:15:56 <SamB> though I did write a somewhat-stupid algorithm
07:16:02 <mux> I'd rather waste time on that adventure algorithm
07:16:05 <roconnor> I finished by repair searching algorith this week.  It was fun!
07:16:07 <mux> so my UM is simple (yet fast!)
07:16:09 <SamB> (I had to incinerate useless things by hand mostly)
07:16:36 <roconnor> Philippa: isn't the free list a stack?
07:16:42 <mux> fear the UM monad
07:16:56 <SamB> eventually I came up with a really nasty way to get my algorithm to incinerate things itself...
07:17:15 <SamB> for one really nasty assembly...
07:17:16 <Philippa> hrmm. Yeah, a stack'll do, fair enough
07:17:21 <mux> what really scares me is that at some point you have different flavous (colors) of the same object
07:17:27 <mux> so you have several trees to consider
07:17:31 <SamB> I had to reorder the puzzles too...
07:17:36 <roconnor> mux: I had to write my own non-deterministic state monad. :)
07:17:41 <SamB> mux: yeah, it was one of those
07:17:49 <mux> and I'm not sure how to solve this yet
07:17:50 <SamB> monad!
07:17:54 <SamB> I just used a tree
07:17:55 <mux> maybe alpha/beta :D
07:17:58 <mux> heh.
07:18:10 <Philippa> normally I end up optimising for the case where you don't need to preserve object identity either, which you can make go stupefyingly fast and which only needs a single index aside from the blocks themselves so long as you allocate them contiguously
07:18:44 <SamB> a tree of states
07:18:52 * mux notes the sexp format seems to be the easiest to parse
07:18:56 <SamB> each state had a backwards list of commands to get to that state
07:19:01 <mux> what guys did you use?
07:19:11 <mux> err, rather, what did you guys use?
07:19:16 <roconnor> Philippa: I didn't quite follow you.
07:19:18 <SamB> I used the Lisp one
07:19:23 <SamB> but it was buggy and annoying
07:19:25 <SamB> use the ML one
07:19:50 <mux> sexp is quite similar to the ML format, but slightly simpler to deal with
07:19:56 <mux> or at least I think it is, I have yet to try
07:20:00 <Philippa> roconnor: the pool for UM allocation needs to preserve object identity - that is, pointers have to keep pointing to the same object
07:20:04 <SamB> actually, no!
07:20:11 <SamB> there are bugs in the sexp format!
07:20:14 <SamB> use ML!
07:20:16 <mux> ouch, really?
07:20:19 <mux> heh, ok :)
07:20:20 <SamB> yes really!
07:20:22 <Philippa> if you're free to shuffle objects about, then the management scheme is beautifully simple and cheap
07:20:41 <Igloo> Have you got the latest codex?
07:20:47 <mux> SamB: so what did you use to decide which "move tree" to use for solving a room in adventure?
07:20:58 <roconnor> Philippa: ah yes.  Alas, not possible with the UM.
07:21:00 <mux> min/max alpha/beta algorithms or something? something simpler?
07:21:13 <roconnor> @paste
07:21:14 <lambdabot> http://paste.lisp.org/new/haskell
07:21:43 <lisppaste2> roconnor pasted "sexp parser" at http://paste.lisp.org/display/27392
07:21:47 <Philippa> right. And keeping handles is just as expensive as keeping a free stack
07:22:03 <Philippa> well... not quite
07:22:17 <Philippa> it's proportional to allocated rather than free stuff in terms of memory usage, but hey
07:22:29 <Philippa> in practice you're going to pre-alloc the lot anyway
07:23:06 <roconnor> I solved the problem by finding what items need to be combined to repair the objects, and then finding a set of comands to perform that repair.
07:24:54 <roconnor> I'm wondering if it is possible to repair the RS232 adapter without using more than 5 inventory slots.
07:25:06 <mux> roconnor: yes, but they can be different solutions when there are several flavours or the same item - or at least some theoritical solutions which need to be discarded based on the amount of things you'll need to hold
07:25:16 <mux> s/they/there/
07:25:50 <roconnor> mux: yes, I non-deterministically find what items need to be combined. ;) go MonadPlus.
07:26:05 <mux> hmmmm.
07:27:27 <mux> I think I'll write an interactive UM/adventure wrapper which will just add a "solve" command which the target object as the parameter
07:27:45 <mux> gah, s/which/with/
07:28:05 <fasta> I have a newtype Foo a = Foo (Bar a->Bar a), where data Bar a = Bar [a], why is Foo not automatically an instance of Monoid (since there's an instance Monoid for (a->b))?
07:28:13 <roconnor> mux: I was thinking of doing that. :)
07:28:44 <roconnor> fasta: you need to do deriving (Monoid)
07:28:59 <roconnor> and you need to turn on extensions.
07:29:17 <fasta> roconnor: When I do that, I get overlapping instances.
07:29:37 <fasta> And the overlapping instance is Monoid (a->b)
07:29:43 <roconnor> @instances Monoid
07:29:44 <lambdabot> (), (a -> a), (a, b), (a, b, c), Ordering, [a]
07:30:05 <fasta> instance (Monoid b) => Monoid (a -> b) -- Defined in Data.Monoid
07:31:16 <roconnor> @docs data.Monoid
07:31:16 <lambdabot> data.Monoid not available
07:31:20 <roconnor> @docs Data.Monoid
07:31:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
07:31:44 <roconnor> I see a -> a, but not a -> b
07:31:54 <fasta> roconnor: agreed, but I post what ghci is telling me.
07:33:30 <jzhang> does haskell standard libs have a data structure with constant time lookup?
07:33:33 <roconnor> @fps Data.Monoid
07:33:33 <lambdabot> Maybe you meant: faq ft pl
07:33:41 <roconnor> @fp Data.Monoid
07:33:41 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
07:33:45 <glguy> jzhang: Array
07:34:43 <roconnor> fasta: intersting, it seems that a -> a is no longer a Monoid
07:35:00 <roconnor> use Endo instead.
07:35:13 <fasta> roconnor: hmm, right, I don't understand how to get an Endo.
07:35:24 <fasta> roconnor: I read them yesterday already.
07:35:24 <roconnor> Endo id
07:35:37 <roconnor> Endo (+1)
07:35:50 <roconnor> > apEndo (Endo id) 5
07:35:50 <lambdabot>  Not in scope: data constructor `Endo'
07:36:05 <roconnor> well, I suppose it depends on the version of GHC.
07:36:43 <jzhang> can the array be unbounded?
07:36:54 <roconnor> In theory you can do newtype Foo a = Foo (Endo (Bar a)) deriving (Monoid)
07:37:44 <fasta> roconnor: in practice that's true to
07:37:50 <roconnor> :)
07:37:50 <fasta> too, even
07:38:04 <fasta> roconnor: I haven't tried to solve the actual problem with it, though.
07:38:43 <roconnor> you will probably want to write mkFoo x = Foo (Endo x)
07:39:02 <roconnor> and apFoo (Foo (Endo x))  = x
07:39:18 <roconnor> but with those in hand you sould be set.
07:40:15 <jzhang> is there any way to create potentially unbounded datastructure with constant time access?
07:40:29 <fasta> jzhang: amortized, yes.
07:40:40 <fasta> jzhang: In Haskell: I don't know currently.
07:40:45 <jzhang> oh
07:40:58 <jzhang> I would like to use List
07:41:01 <sjanssen> jzhang: what kind of datastructure?
07:41:07 <jzhang> but then access times would be horrible
07:41:15 <jzhang> something like an Int array
07:41:19 <sjanssen> doing a lot of random access?
07:41:23 <jzhang> but like a lazy list
07:41:27 <fasta> roconnor: What should apFoo do?
07:41:28 <roconnor> jzhang: IntMap gives you log time access.
07:41:53 <jzhang> yeah, I was just wondering if there's constant time ones
07:41:57 <jzhang> well i guess I'll take log then
07:41:59 <sjanssen> jzhang: GHC 6.6 ships with Data.Sequence, which has O(log i) indexing
07:42:04 <roconnor> apFoo :: Foo a -> (Bar a -> Bar a)
07:42:20 <sjanssen> jzhang: Data.Sequence is supposed to be quite fast
07:42:28 <roconnor> sjanssen: what is it?
07:42:52 <jzhang> is it available now?
07:42:59 <fasta> roconnor: oh, right, getting the Foo and Endo constructor of it?
07:43:11 <jzhang> I guess I'll just use IntMap then
07:43:14 <sjanssen> roconnor: a sequence data structure that has O(1) head, cons, tail, last; and O(log i) indexing/splitting ops
07:43:40 <roconnor> jzhang: one ought to be able to wrap up STArray to automatically realloc and give you constant time access.
07:43:42 <fasta> jzhang: I don't know your specific application, but most of the times it's more important to get a prototype done first.
07:43:43 <sjanssen> jzhang: the code is available now, but it hasn't been in a real release for any compilers yet
07:43:58 <jzhang> ah yes
07:44:04 <jzhang> true
07:44:08 <jzhang> premature optimization
07:44:12 <sjanssen> it is in the GHC release candidates which are available immediately
07:44:19 <jzhang> well I'm just playing with the icfp contest code
07:44:22 <jzhang> trying out um
07:44:35 <jzhang> and I'm thinking of how I can implement it fast in haskell
07:44:57 * earthy grins
07:44:58 <sjanssen> jzhang: for speed, you need to go with mutable arrays, I don't think any other approach will cut it
07:45:17 <earthy> and even then it won't be very fast
07:45:31 <fasta> roconnor: stupid question: converting a value of Bar a to one of Bar a->Bar a, I just need to give an extra lambda before it, right? I.e. barToFoo x = Foo (\_->x) ?
07:45:55 <fasta> earthy: you know weaknesses in the implementation?
07:45:56 <roconnor>  barToFoo x = mkFoo (\_->x)
07:45:56 <jzhang> well I'm trying to stick with functional code
07:46:04 <fasta> roconnor: right, in this case.
07:46:08 <jzhang> or else there's no real point to do this in haskell
07:46:24 <SamB> jzhang: heh
07:46:28 <roconnor>  barToFoo x = mkFoo (return x) for fun ;)
07:46:39 <sjanssen> jzhang: there isn't a real big advantage to writing a UM in Haskell
07:47:00 <roconnor> sjanssen: safety!
07:47:03 <SamB> jzhang: the only reason to do the UM in Haskell is if you don't like puzzling over wierd bugs because you forgot a line in C...
07:47:24 <glguy> You prefer staring at the screen wondering... is it running?
07:47:29 <mux> the UM is really easy anyways, 13 instructions, 1-2h max of writing C code
07:47:42 <SamB> note that it probably takes at least 4x longer to write in the first place, even for the experienced Haskell programmer
07:47:43 <glguy> 1-2h in C??
07:48:09 <mux> glguy: yeah, it's small
07:48:17 <glguy> the 2h figure seemed long
07:48:22 <mux> 2h *max*
07:48:26 <glguy> fine
07:48:28 <mux> 1h sounds a better approximation
07:48:41 <jzhang> well I'm trying to get better at haskell
07:48:43 <mux> if you take account of the time reading the spec etc
07:48:46 <jzhang> I know I can do it in C
07:48:56 <mux> jzhang: solving the adventure game in Haskell is more interesting IMHO
07:48:57 <glguy> mux: granted, starting from scratch, 1-2h
07:49:00 <jzhang> but I'm trying to become a better functional programmer
07:49:11 <fasta> roconnor: for what reason is that possible?
07:49:30 <fasta> roconnor: (->) is an instance of Monad or so?
07:49:30 <jzhang> anyway, back to code
07:49:40 <roconnor> fasta: (a ->) b is a Monad, if you import the right library.
07:50:03 <roconnor> fasta: it is the reader monad.
07:50:19 <roconnor> it has a read-only state.
07:50:27 <fasta> roconnor: when I started to program I had never expected to find Endo in my code.
07:50:36 <roconnor> ;)
07:52:00 <mux> I'm kinda torn between my desire to go on with this adventure game algorithm, and between going on with my ToME lostsoul character :-P
07:52:17 <mux> and also, doing what I'm paid for but that's really the least interesting
07:52:41 <profmakx> mux welcome to the club
07:53:26 <roconnor> If you strech my job description, I think it encompasses writing code to solve the adventure game.
07:53:51 <fasta> roconnor: I think it's (\x->mkFoo (\_->return x)), btw
07:53:52 * earthy laughs
07:53:59 * profmakx works at a game-devel company
07:54:00 <profmakx> team
07:54:02 <profmakx> whatever
07:54:15 <roconnor> fasta: it should be ... mkFoo (return x)
07:54:33 <roconnor> but you will need to import Control.Monad.Something.
07:54:39 <roconnor> @import
07:54:39 <lambdabot> Unknown command, try @list
07:54:42 <roconnor> @imported
07:54:42 <lambdabot> Unknown command, try @list
07:54:49 <roconnor> @imported-modules
07:54:50 <lambdabot> Unknown command, try @list
07:54:57 <roconnor> fine
07:54:58 <roconnor> @list
07:54:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:55:10 <fasta> roconnor: but that doesn't convert a Bar a to a Foo (Endo (Bar a->Bar a))
07:55:23 <roconnor> @instances-importing
07:55:24 <lambdabot> instances module failed: IRCRaised Prelude.last: empty list
07:55:55 <fasta> roconnor: Control.Monad.Reader did work with the \x added, but maybe I am talking crap.
07:56:42 <fasta> @hoogle Monad
07:56:43 <lambdabot> Control.Monad :: module
07:56:43 <lambdabot> Data.Graph.Inductive.Monad :: module
07:56:43 <lambdabot> Data.Graph.Inductive.Query.Monad :: module
07:56:52 <fasta> @more
07:57:18 <roconnor> fasta: with Control.Monad.Reader, I expect \x -> mkFoo (return x) to have type Bar a -> Foo a
07:57:34 <roconnor> aka mkFoo . return
07:58:32 <fasta> roconnor: it has (Bar a->Bar a)->Foo a
07:58:41 <roconnor> oh
07:58:55 <roconnor> interesting
07:59:02 <fasta> roconnor: well, that's what ghci is telling, it could be wrong, of course.
07:59:33 <roconnor> out of curiosity, how about \x -> mkFoo ((return x)::Bar a -> Bar)?
07:59:42 <roconnor> out of curiosity, how about \x -> mkFoo ((return x)::Bar a -> Bara)?
07:59:43 <roconnor> out of curiosity, how about \x -> mkFoo ((return x)::Bar a -> Bar a)?
08:01:31 <fasta> roconnor: Inferred type is less polymorphic than expected
08:02:41 <fasta> Is there any chance of any other haskell compiler ever including Data.Generics?
08:03:04 <fasta> Or how large is that chance, since I am sure it's nonzero :)
08:03:27 <roconnor> fasta: wow.  best stick with mkFoo (\_ -> x) I guess.
08:03:55 <fasta> roconnor: wow?
08:04:04 <fasta> roconnor: yes, because honestly, I have no idea what that return did there :)
08:04:16 <roconnor> I'm surprised that return doesn't work.
08:04:27 <roconnor> but that is just me :)
08:05:17 <fasta> roconnor: hmm, mkFoo (\_->x) is also wrong
08:05:33 <fasta> roconnor: it thinks that x should be of type Bar a->Bar a
08:06:22 <fasta> roconnor: mkFoo (\_->return x) did work, however (as I already said)
08:06:28 <roconnor> fasta: oh, souds like we have a problem
08:06:33 <roconnor> what is the type of mkFoo?
08:06:54 <bringert> whats up with threadDelay taking a number of microseconds as an Int ?
08:07:04 <fasta> roconnor: (Bar a->Bar a)->Foo a->Foo a
08:07:09 <roconnor> that's not good
08:07:13 <fasta> roconnor: agreed
08:07:15 <roconnor> what is the definition of mkFoo?
08:07:17 <bringert> that means you can delay for more than half an hour on a 32-bit machine
08:07:38 <bringert> eh, man that can't
08:07:44 <bringert> s/man/make/
08:07:45 <bringert> dammit
08:07:54 <fasta> \a->Foo (Endo a)
08:08:37 <roconnor> what is the type of Foo and Endo?
08:09:14 <earthy> hm.
08:09:17 <earthy> Cabal experts?
08:09:46 <fasta> newtype Foo a = Foo (Endo (Bar a->Bar a))
08:09:52 <roconnor> ah
08:10:01 <fasta> Oh, I see
08:10:02 <earthy> suppose I have a source tree with my main program under src/
08:10:04 <roconnor> should be Foo a = Foo (Endo (Bar a))
08:10:12 <earthy> and a basically stable lib under  lib/
08:10:13 <fasta> roconnor: Yes, I saw that.
08:10:15 <roconnor> :)
08:10:17 <fasta> roconnor: thanks to you
08:10:35 <earthy> how would I make a cabal file where I generate the main program, but still can use the stable lib that's included?
08:11:50 <fasta> roconnor: your mkFoo(return x) is correct now too.
08:12:30 <roconnor> :)
08:12:44 <roconnor> feel free to use mkFoo(\_ -> x) for clairity
08:13:43 <mux> mkFoo (const x) ?
08:13:54 <roconnor> mux: that's nice too.
08:13:55 * mux loves const
08:14:01 * mux is a const addict
08:14:12 <roconnor> why use const when you can use return ;)
08:16:10 <mux> pentane% w3m http://mu.org/~mux/um-unsafe.c                                             ~
08:16:14 <mux> oops
08:16:15 <fasta> Yeah, return is MOOnnaahhddiccc!
08:16:28 <fasta> I like const more, btw. :)
08:17:10 <mux> join the const addicts club
08:17:31 <earthy> no cabal experts then?
08:17:33 <earthy> dang
08:20:15 <Lemmih> earthy: When you do wanna generate the main program?
08:20:43 <Lemmih> earthy: You could add a post-conf hook.
08:21:01 <roconnor> fasta: jij woon in Nederland?
08:21:13 <earthy> oh, I have an executable
08:21:26 <earthy> that is, a spec for the executable
08:21:28 <earthy> but it uses libs
08:21:33 <fasta> roconnor: What's up with you people? Everyone seems to be learning Dutch!
08:21:38 <fasta> roconnor: right
08:21:39 <earthy> (DData and HaXml)
08:21:48 <earthy> Ik ben geen Nederlands aan 't leren!
08:21:54 <roconnor> fasta: I moved to Nijmegen to pursue my PhD.
08:22:00 <Lemmih> earthy: I don't follow.
08:22:01 <fasta> roconnor: oh, interesting
08:22:02 <earthy> Nijmegen. Nice city.
08:22:23 <earthy> Lemmih: I have dirs  src/ and lib/DData and lib/Text/XML/HaXml
08:22:35 <earthy> in src/ my main program is (Dazzle)
08:22:55 <earthy> I don't have cabal files for DData and HaXML
08:23:04 <earthy> and I don't want to expose them as libs
08:23:16 <earthy> but I do want to include them in my main program
08:23:29 <roconnor> earthy: I've found it hard to meet people.
08:23:34 <earthy> I can do so using Ghc-Options: -ilib/DData;lib
08:23:38 <earthy> roconnor: it can be
08:23:41 <fasta> roconnor: I am not really sure of why this doesn't work. fromFoo = (\foo->foo (Bar []))
08:23:57 <earthy> roconnor: drop by in some bars, maybe join the board game society
08:24:23 <roconnor> earthy: I went to a go club meeting.  Lot's of middle aged men playing go.
08:24:30 <earthy> yah
08:24:38 <earthy> same with the board games
08:24:39 <earthy> ;)
08:24:44 <fasta> roconnor: depressing
08:24:53 <roconnor> fasta: what do you want fromFoo to do?
08:25:25 <earthy> lemmih: but I don't want to use Ghc-Options, as that binds my cabal file to ghc
08:25:30 <earthy> which I don't necessarily want
08:25:54 <fasta> roconnor: I want to get a real value out of it, i.e. apply the function to get a Bar a back.
08:26:01 <earthy> so, is there a way to accomplish that? or should I actually build those libs and expose them?
08:26:25 <roconnor> fromFoo = (\foo -> apFoo foo (Bar []))
08:26:45 <roconnor> or fromFoo = (\foo -> foo `apFoo` (Bar []))
08:27:01 <fasta> I don't have that apFoo function, yet. Scrolling back...
08:32:56 <roconnor> apFoo (Foo (Endo x))  = x
08:37:58 <hygge> i can have a guard inside a do, right?
08:38:18 <hygge> do args <- getArgs, i want to check if i've got an arg from the user, if not i would print a help-message
08:38:49 <roconnor> @type guard
08:38:51 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:38:58 <roconnor> :/
08:39:45 <roconnor> requires a MonadPlus.
08:40:03 <roconnor> looks like you will just have to do an if statement yourself.
08:40:28 <hygge> hmm
08:40:33 <hygge> how? :/
08:40:39 <hyrax42_> IO is a MonadPlus
08:40:43 <hyrax42_> afaik
08:41:12 <glguy> yup
08:41:13 <hygge> i havent really undestood what a monad is yet, so... :P
08:41:24 <cjay> when (args == [])  usage
08:41:47 <hyrax42_> hygge, what cjay said
08:41:52 <cjay> :)
08:42:14 <hyrax42_> and usage prints your help message
08:42:53 <glguy> when might not be what you want, since the program won't stop after printing that message
08:44:56 <hyrax42_> when (args == []) (usage >> exitFailure)
08:44:58 <hyrax42_> ?
08:45:00 <hyrax42_> or is that bad
08:45:49 <hygge> ah
08:46:06 <cjay> using error to display the message will abort, too
08:46:26 <cjay> but I'm a noob, dunno whats the best method
08:46:53 <hyrax42_> cjay, yeah it's a bit hard to find out what's the standard way to do stuff
08:47:24 <hyrax42_> I decided yesterday I'll read through the source of hmp3 some time soon, since it's much more of a "real app" than the sort of stuff I've done so far
08:47:38 <hyrax42_> anyway, I have to get going
08:47:44 <hyrax42_> good luck hygge :)
08:47:54 <roconnor> cjay: hyrax42_'s way seems pretty reasonable.
08:48:01 <hyrax42_> oh
08:48:06 <cjay> one should understand monads before reading real apps, in my opinion
08:48:08 <hyrax42_> roconnor, my worry was having multiple exit points
08:48:12 <roconnor> so when the args are empty it will run usage, and then it will call exit.
08:48:40 <hyrax42_> spaghetti-like?
08:49:04 <glguy> hyrax42_: is that better than an if-statement?
08:49:11 <roconnor> hyrax42_: some people feel multiple exit points are okay.
08:49:32 <hyrax42_> glguy, rhetorical?
08:49:33 <hygge> okey, thx hyrax42_
08:49:52 <hygge> hmm
08:49:55 <hyrax42_> ?type when
08:49:56 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:49:58 <hygge> so the example didnt work? :P
08:50:01 <glguy> hyrax42_: I just didn't know why you were trying to avoid using an if
08:50:08 <roconnor> glguy: maybe (usage >> fail "No arguments") isn't too bad either.
08:50:14 <hyrax42_> well I was expanding on cjay's example
08:50:22 <hyrax42_> it saves you a level of indentation I guess
08:50:25 <hygge> what does >>?
08:50:36 <glguy> sequence
08:50:38 <roconnor> a >> b means, first do a, then do b.
08:50:51 <hyrax42_> since otherwise you'd have
08:51:02 <hygge> okey
08:51:03 <hygge> ah
08:51:19 <hyrax42_> if args == [] then usage else do ...
08:51:27 <hygge> ah
08:51:32 <hygge> that will do? i just thought of that
08:51:42 <hyrax42_> yeah
08:51:49 <Cale> > [1,2,3] >> ['a', 'b']
08:51:52 <lambdabot>  "ababab"
08:52:04 <glguy> Cale: quite illustrative ;)
08:52:09 <Cale> hehe :)
08:52:10 <hyrax42_> stick with the easy to understand stuff
08:52:37 <Cale> but there really is a nice way to make sense of that :)
08:52:42 <roconnor> Cale: a >> b means first do a, ignore the result, then do b.
08:52:47 <glguy> > (undefined >> (+1)) 4
08:52:48 <lambdabot>  5
08:52:54 <Cale> right
08:53:43 <hyrax42_> > [1,1,1] >> "ab"
08:53:45 <lambdabot>  "ababab"
08:53:54 <roconnor> there are 3 ways  of doing [1,2,3] and two ways of doing ['a','b], so in total there are 6 ways of doing [1,2,3] >> ['a','b']
08:54:13 <roconnor> 3 of those 6 ways result in a, and the other 3 result in b.
08:54:15 <Cale> So in this case, it will do the [1,2,3], which will return each of 1,2, and 3 in turn, the specific number will be ignored, and then "ab" will return each of 'a' and 'b', and the results captured in a list :)
08:54:16 <hyrax42_> > replicate 3  undefined >> "a"
08:54:17 <lambdabot>  "aaa"
08:54:35 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [1..10]
08:54:37 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
08:55:11 <hyrax42_> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [1..11]
08:55:12 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11]]
08:55:15 <hyrax42_> (this oen goes to 11)
08:55:15 <hygge> check http://pastebin.perl.se/2758350407/ this should work?
08:55:32 <Cale> > [1,2,3] >>= \k -> ("abc" >>= replicate k)
08:55:32 <michaelw> hmm, didn't somebody write a Haskell BDD library already?
08:55:33 <lambdabot>  "abcaabbccaaabbbccc"
08:56:07 <sjanssen> hygge: I think the indenting of else is off
08:56:16 <hyrax42_> hygge, also you need a new do after the else
08:56:18 <hyrax42_> else do ...
08:56:21 <hygge> aha
08:56:33 <Cale> line the 'else' up with the 'then'
08:56:49 <hygge> YEAH
08:56:54 <hygge> thank you, guys
08:57:11 <hyrax42_> ok now I go
08:57:40 <roconnor> mux: ping?
09:00:12 <mux> roconnor: pong
09:00:41 <earthy> hm. right. not even GHC-Options allows me to include the extra libs
09:01:15 <roconnor> mux: was it you who wanted to wrap up the adventure game and add a pseduo command called `solve'
09:01:22 <mux> yep
09:01:28 <roconnor> have you thought about how to do it?
09:01:36 <mux> not yet
09:01:57 <roconnor> I'm wondering if setting up a system of pipes for IPC is the way to go?
09:01:59 <mux> I'm playing a rogue-like game :-P
09:02:04 <roconnor> :P
09:02:46 <mux> pipes sound appropriate yeah
09:21:10 <jmmv> hi
09:21:18 <hygge> gtg fot the day, the lab is over since long ago! :)
09:21:21 <hygge> see you
09:22:11 <giksos> looks like -fallow-overlapping-instances has no effect for interactive (ghci) mode in 6.4.2 - interesting
09:22:18 <hygge> :q
09:22:19 <hygge> :)
09:23:09 <giksos> I mean the ones given with OPTIONS_GHC
09:23:28 <jmmv> so... this is probably trivial but I can't figure it out:  I have a 'fetch :: String -> IO ()' function, and from within it, I'd like to do a 'map fetch dirs', where dirs is a list of strings.  what's the proper way to do that?
09:24:13 <jmmv> (I keep getting "type error in generator", [IO ()] does not match IO a)
09:25:16 <jrmole> mapM_ perhaps?
09:25:19 <jrmole> @type mapM_
09:25:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
09:27:41 <jmmv> hmm, seems to work :)
09:27:42 <jmmv> thanks
09:29:45 <jrmole> :)
09:41:59 <jmmv> yuummm
09:41:59 <jmmv> this (haskell) is great
09:43:21 <x3m> > (\f x -> if x == 0 then 1 else x * f (x-1)) 4
09:43:22 <lambdabot>  add an instance declaration for (Num (a -> a))
09:43:52 <x3m> > x = 4; (\f x -> if x == 0 then 1 else x * f (x-1))
09:43:53 <lambdabot>  Parse error
09:47:08 <x3m> > (\x -> if x == 0 then 1 else x * f (x-1)) 4
09:47:09 <lambdabot>  Not in scope: `f'
09:47:30 <x3m> > x = 4; (\f x -> if x == 0 then 1 else x * f (x-1)) x
09:47:31 <lambdabot>  Parse error
09:49:01 <Jaak> > let f g n = if n == 0 then 1 else n * g (n - 1) in fix f 10
09:49:03 <lambdabot>  3628800
09:50:09 <x3m> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 4
09:50:11 <lambdabot>  24
09:53:38 <fasta> broken voting machines: wget http://www.wijvertrouwenstemcomputersniet.nl/images/9/91/Es3b-en.pdf
09:53:41 <lambdabot> http://tinyurl.com/rhryn
09:57:04 <apfelmus> ?type flip id id . flip id
09:57:05 <lambdabot> forall a. a -> a
09:57:09 <lispy> it's funny how a fresh set of eyes makes all the difference
09:57:27 <lispy> i struggled all day yestarday trying to figure out why my cost centers didn't show up in the profile
09:57:38 <lispy> then today i see that some of them are missing the SCC tag in the comment :)
09:58:20 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show -- another example that haskell is great ;)
09:58:23 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
09:58:29 <lispy> yay powers of 2!
09:59:46 <Jaak> hah, cool
10:04:07 <deadbeef> http://acarol.woz.org/
10:04:11 <lambdabot> Title: A Difference Engine Built With LEGO Pieces
10:04:27 <jgrimes> ok, so I am passing around an environment to various functions, and then returning the modified environment to the calling function, is there a better way of having a modifiable environment that can be inspected after being passed to various other functions?
10:04:46 <twanvl> The state monad
10:04:59 <jgrimes> yeah, I've looked at it
10:05:23 <jgrimes> but
10:05:47 <jgrimes> I don't really see how it does what I need. All of the examples I've seen don't really show how it could be used to do this
10:05:49 <jgrimes> =/
10:06:30 <jgrimes> but there is a good chance I just don't understand it
10:07:46 <twanvl> 1. You write your functions in monadic style. 2. Where you need to read the environment you use get. 3. Where you want to update the environment use set or update.
10:10:32 <jgrimes> twanvl, all right. maybe I just need to try it out for myself since it doesn't sound terribly complicated. thanks
10:11:07 <apfelmus> roconnor: coqorico
10:16:07 <jgrimes> so it seems like once you start using more than one monad there is no reason not to just go ahead and use transformer monads. is this actually the case?
10:17:15 <roconnor> apfelmus: hey
10:18:01 <apfelmus> roconnor: i have a question about coq. i suppose it's better to state it in #coq, ok?
10:19:02 <roconnor> ok
10:21:29 <lightstep> when were monadic parsing combinators invented?
10:21:44 <lightstep> they are mentioned as an example in the 1995 haskell workshop proceedings
10:44:00 <roconnor> > 2^19
10:44:02 <lambdabot>  524288
10:46:39 <roconnor> > 2^18
10:46:40 <lambdabot>  262144
10:47:14 <ventonegro> > (-) (2^19 ) (2^18)
10:47:16 <lambdabot>  262144
10:48:10 <roconnor> My UM spun out of control and allocated all my memory
10:48:20 <roconnor> I wonder which processes got killed.
10:48:45 <roconnor> I wonder if any were important
10:56:06 <LiquidEngineer> Hello
10:56:54 <roconnor> hi
10:57:27 <LiquidEngineer> I'm having a problem figuring out how to do something
10:57:37 <LiquidEngineer> would ya'll mind if I kind of laid out what I'm trying to do for some pointers?
10:58:56 <roconnor> > 4*4878884
10:58:57 <lambdabot>  19515536
10:59:14 * edwardk waves hello
10:59:28 <Greyz> hi
10:59:36 <edwardk> how goes?
10:59:53 <Greyz> you all are familiar with pascal triangle i presume
11:00:07 <dmwit> yep
11:00:10 <LiquidEngineer> Sure
11:00:20 <Greyz> I need to define a function to calculate the n'th row of that triangle
11:00:32 <roconnor> > (256+128)*2^10
11:00:33 <lambdabot>  393216
11:00:43 <Greyz> something like pascal :: [[Int]]
11:01:00 <lightstep> hmm, i created a gtk window with a spin button, and the program crashes with "schedule: re-entered unsafely"
11:01:17 <LiquidEngineer> Here's what I'm thinking about
11:01:25 <dmwit> Step one: define factorial.
11:01:47 <Greyz> ok that's easy
11:02:01 <dmwit> Step two: look up combinatorics on Wikipedia.
11:02:15 <LiquidEngineer> I've got a list [(Int, Int, Int)] and a list [Int].  I need to make sure the first two ints in every (Int, Int, Int) tuple appears in [Int]
11:02:15 <dmwit> There's a straightforward formula for Pascal's triangle.
11:02:33 <LiquidEngineer> I can't think of a way to do this that isn't incredibly wasteful
11:03:03 <lightstep> ?type all
11:03:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:03:07 <lispy> almost 20% of the memory in my application (which is around 20Gb allocated during the run) is allocated by the 'spaces' parser from parsec
11:03:14 <lispy> why does it need to allocate any memory...
11:03:22 <dmwit> It's like n choose i or so, where n is the row number and i is the index in the array...
11:03:30 <LiquidEngineer> lightstep: was that for me?
11:03:56 <xerox> > let pascal = [1,2,1] : map (\line -> zipWith (+) (line++[0]) (0:line)) pascal in pascal
11:03:58 <lambdabot>  [[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35...
11:04:12 <lightstep> LiquidEngineer, yes. create a set (using arrays, orIntSet, or Tries, or July, or something), then call "any" with the tuples
11:04:24 <LiquidEngineer> set?
11:04:36 <dmwit> ?index Set
11:04:36 <lambdabot> Data.Set, Graphics.Rendering.OpenGL.GL.PerFragment, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
11:04:45 <LiquidEngineer> I've never usesd sets in haskell...hm...
11:05:20 <LiquidEngineer> so....a set of what?
11:05:27 <LiquidEngineer> like, the set of numbers I wanna check for?
11:05:43 <lightstep> @index IntSet
11:05:44 <lambdabot> Data.IntSet
11:06:00 <LiquidEngineer> as in, take the numbers I wanna check for (the [Int]) and build a set out of those to test against the tuples?
11:06:11 <lightstep> that's probably the clearest to use
11:06:24 <LiquidEngineer> I'm not sure that'll work.
11:06:45 <LiquidEngineer> the [Int] will always test as containing only elements found in the tuples
11:06:52 <LiquidEngineer> it's a sublist built from the tuples
11:06:56 <LiquidEngineer> I need to go the other way
11:08:01 <lightstep> i don't understand, then
11:08:17 <astrolabe> > let pascal = [1] : map (\line -> zipWith (+) (line++[0]) (0:line)) pascal in pascal
11:08:18 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
11:08:19 <LiquidEngineer> Hmm....
11:08:25 <LiquidEngineer> let me rephrase
11:08:30 <lightstep> you have two sets, the set of numbers in the list, and the set of the first two elements of each tuple
11:08:45 <edwardk>  > (++[1]) $ snd $ mapAccumL (\a x -> (x,x+a)) 0 [1,2,1]
11:08:53 <edwardk> er
11:08:57 <edwardk> > (++[1]) $ snd $ mapAccumL (\a x -> (x,x+a)) 0 [1,2,1]
11:08:59 <lambdabot>  [1,3,3,1]
11:09:14 <edwardk> though i think astrolabe has a cleaner solution
11:09:31 <astrolabe> I copied mine from xerox pretty much :)
11:09:40 <LiquidEngineer> I have a list L = [(1, 2, 3) (2, 3, 1) (3, 1, 5) ...] and a list [1,3,...].
11:09:58 <LiquidEngineer> I need to make sure every value that appears in he first two slots of each tuple appears once in the second list.
11:10:10 <dmwit> Exactly once?
11:10:17 <LiquidEngineer> It'll be exactly once.
11:10:25 <LiquidEngineer> I don't have to check for that, as there's another function that takes care of that.
11:10:37 <astrolabe> Why don't you think sets will work?
11:10:41 <LiquidEngineer> and actually, it probably *won't* be exactly once.
11:10:44 <dmwit> ?hoogle [a] -> Data.Set a
11:10:45 <lambdabot> No matches, try a more general search
11:10:46 <LiquidEngineer> it might be multiple times.
11:10:57 <LiquidEngineer> I'm still a bit confused about how the sets work...
11:11:09 <lightstep> LiquidEngineer, why not create the two sets and check that one is a subset of another?
11:11:28 <glguy> > concatMap (\(a,b,_) -> [a,b]) [(1, 2, 3) (2, 3, 1) (3, 1, 5)]
11:11:29 <lambdabot>    The function `(1, 2, 3)' is applied to two arguments,
11:11:29 <lambdabot>   but its type `...
11:11:41 <astrolabe> lightstep: Isn't that worse?
11:11:50 <dmwit> > concatMap (\(a,b,_) -> [a,b]) [(1, 2, 3), (2, 3, 1), (3, 1, 5)]
11:11:51 <lambdabot>  [1,2,2,3,3,1]
11:12:01 <edwardk> > iterate (\x -> zipWith (+) (0:row) (row++[0])) [1]
11:12:07 <xerox> > let pascal = [1,2,1] : map (ap (zipWith (+) . (++[0])) (0:)) pascal in pascal
11:12:07 <edwardk> er
11:12:08 <lambdabot>  Not in scope: `row'
11:12:10 <lambdabot>  [[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],[1,7,21,35...
11:12:11 <lightstep> astrolabe, depends on whether you optimize for beauty or for speed
11:12:27 <sjanssen> @let crushTuples = concatMap (\(a,b,_) -> [a,b])
11:12:28 <glguy> all (`elem` list2) list1
11:12:28 <lambdabot> Defined.
11:12:30 <edwardk> > iterate (\x _> zipWith (+) (0:x) (x++[0])) [1]
11:12:30 <lambdabot>  Parse error
11:12:31 <LiquidEngineer> the elements of the sets should be match exactly
11:12:35 <lightstep> ?hoogle isSubSetOf
11:12:36 <lambdabot> Data.IntSet.isSubsetOf :: IntSet -> IntSet -> Bool
11:12:36 <lambdabot> Data.Set.isSubsetOf :: Ord a => Set a -> Set a -> Bool
11:12:36 <edwardk> gah
11:13:04 <astrolabe> lightstep: and the relative sizes of the lists?
11:13:07 <lightstep> LiquidEngineer, then you can use an IntMap, or a Map, or a HashTabke
11:13:21 <LiquidEngineer> IntMap?
11:13:24 <lightstep> LiquidEngineer, and store the counts
11:13:28 <LiquidEngineer> is there a good website to reference these things?
11:13:30 <edwardk> > iterate (\x -> zipWith (+) (0:x) (x++[0])) [1]
11:13:33 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
11:13:38 <LiquidEngineer> My knowledge of haskell is kind of basic.
11:13:48 <lightstep> haskell.org/libraries
11:14:01 <astrolabe> http://www.haskell.org/ghc/docs/latest/html/libraries/
11:14:04 <lambdabot> http://tinyurl.com/ojrj6
11:14:28 <Greyz> many thanks, it was most understandable so far :)
11:14:34 <LiquidEngineer> Ooooh!
11:15:33 <LiquidEngineer> Could I create a set from the list [(a, b, c)] of all the a's and b's and then create a set from the [Int] and see if the [Int] set contains every member in the set containing all the a's and b's?
11:15:50 <LiquidEngineer> That would be *exactly* what I need
11:16:01 <glguy> I think that it would be a lot faster to compare sorted lists outright, than to use a Map
11:16:02 <dmwit> That's the suggestion.
11:16:13 <LiquidEngineer> okay
11:16:18 <astrolabe> but use isSubsetOf to do the check
11:16:30 <LiquidEngineer> how does it define subset?
11:16:42 <ventonegro> @hoogle [a] -> [a]
11:16:43 <lambdabot> Prelude.cycle :: [a] -> [a]
11:16:44 <lambdabot> Prelude.init :: [a] -> [a]
11:16:44 <lambdabot> Prelude.reverse :: [a] -> [a]
11:16:46 <glguy> > sort [1,2,3] == sort [2,3,1]
11:16:47 <lambdabot>  True
11:17:02 <dmwit> LiquidEngineer: In the usual way?
11:17:08 <astrolabe> all the elements of the first set are in the second
11:17:09 <dmwit> If every element of one set is an element of another?
11:17:12 <lightstep> glguy, converting one list to be a tree and iterating over the second should be faster
11:17:26 * lispy hacks directly on parsec in hopes of making it faster
11:17:29 <ventonegro> @hoogle [a] -> [a] -> [a]
11:17:30 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
11:17:30 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
11:17:30 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
11:18:04 <glguy> lightstep: not asmptotically
11:19:20 <lightstep> glguy, it's O(n log n + m log n) versus O(n log n + m log m), where n is the length of the shorter list and m of the longer
11:19:25 <lispy> oh, BTW whoever posted that link fix in haskell using lambda, that was very cool
11:19:28 <LiquidEngineer> the only thing I'm concerned about: the way I understand a subset is, in a set {a, b, c} the empty set {} and {a, b} are valid subsets
11:19:31 <lightstep> if n << m, these are different
11:19:39 <glguy> lightstep: the lists are always the same length or you wouldn't have ot do the check
11:19:44 <lightstep> LiquidEngineer, yes, they are
11:20:19 <lightstep> glguy, why? is she has [1] and [2,3]?
11:20:41 <glguy> lightstep: if the lengths are different then the lists are not the same set
11:21:41 <lightstep> oh, i thought it was about being a subset. my bad then
11:21:48 <LiquidEngineer> so, I'm still a bit grey on this point: I'm building a result list [Int] from this subset of a and b from [(a, b, c)].  As the [Int] gets built up it's going to contain some of the a and b, but not all of them.  I only need it to be equivilen t when it contains them *all*
11:22:03 <shapr> musasabi: Yes, I've made progress with the wiki, but not enough to release anything. My tutorial progress is better.
11:22:24 <sjanssen> LiquidEngineer: you can also use (==) to compare the two Sets
11:22:34 <LiquidEngineer> If the set from [Int] would be a subset when it only contained some, that won't work.
11:22:40 <LiquidEngineer> Ah.
11:22:42 <LiquidEngineer> Okay.
11:22:44 <LiquidEngineer> that works.
11:22:46 <ulfdoz> sjanssen: But it relies on order for lists. ;)
11:23:15 <sjanssen> ulfdoz: I'm talking about the insert into a set data structure first, then comparing
11:23:23 <sjanssen> bleh
11:23:37 <sjanssen> I'm talking about inserting the list into set data structures first, then comparing
11:23:40 <ulfdoz> sjanssen: Oh sorry, i read [Int]. ;)
11:24:15 <dcoutts_> dons, yay! :-)
11:24:55 <dcoutts_> dons, lots of detailed review stuff to go though. When do you want to do that? I'll be less busy this weekend I think.
11:25:02 <sjanssen> dcoutts_, dons: congratulations!
11:25:05 <dcoutts_> though/through
11:25:08 <dcoutts_> sjanssen, ta :-)
11:25:11 <wchogg> Sorry guys, I feel stupid but I'm trying to figure out how to have emacs handle latex style literate haskell but still give me the indenting functions of haskell mode.  Any pointers?
11:25:54 <dcoutts_> sjanssen, one of the problems is that the reviewers want us to say more! But we were already really struggling to fit into 15 pages. :-)
11:26:04 <madpickle> http://www.freephotosandvideos.com/videos.php?vid=9SxzGnAWtDE
11:26:05 <madpickle> dude
11:26:10 <lambdabot> Title: Medical :: Divorce :: Injury :: Lawyer, http://tinyurl.com/jrzyu
11:26:12 <madpickle> the cookie monster is stealing ernie's cup cakes
11:26:53 <dcoutts_> methinks you might be in the wrong chanel
11:27:15 <satan> hello
11:27:33 <satan> for foldr f a, how do i define f to be a function that returns a function that takes an argument?
11:27:54 <wchogg> Well, mostly because Medical :: Divorce :: Injury :: Lawyer is a horrible type signature.  It should have been Medical :: Divorce -> Injury -> Lawer
11:28:42 <ski> > let f x n = 1 + n in  foldr f 0 "aardvark"
11:28:43 <lambdabot>  8
11:28:56 <ski> satan : that is one way
11:29:33 <satan> ski, thanks, hope it helps, i'm so lost heh
11:29:59 <ski> you could shorten it with an anonymous function expression (aka lambda expression)
11:30:04 <musasabi> shapr: ok. Just ask if you are missing something. (I still find stupid bugs in HAppS to fix when doing application programming so something not working might not be a problem on your end)
11:30:11 <ski> > foldr (\x n -> 1 + n) 0 "aardvark"
11:30:13 <lambdabot>  8
11:30:20 <satan> ski: hmm i see
11:30:45 <ski> satan : of course, if you're inside a larger definition, you could often use 'where' instead of 'let','in'
11:30:47 <satan> ski: what i'm trying to do is redefine zip using foldr, but foldr only takes 1 arg, while zip takes 2, so i thought f should be of that type
11:30:55 <satan> ski: right, i'm using where
11:31:22 <sjanssen> satan: writing zip via foldr is tricky
11:31:39 <satan> sjanssen: yeah tell me about it :(
11:31:51 <ski> (satan : itym 'foldr' only takes one *list* argument)
11:32:14 <satan> ski: right, one list arg, should be more prcise
11:32:17 <sjanssen> satan: do you really have to do write it that way?  It's not a common thing to do
11:32:41 <LiquidEngineer> hmmm
11:32:46 <satan> sjanssen: yes i've got this book and am learning haskell by doing some of the exercises and this is the most challenging one so far
11:32:49 <LiquidEngineer> How do I make a set from the bs and cs in this?
11:32:50 <LiquidEngineer> [(a, b, c):edges]
11:32:55 <fasta> I removed every call to (++) with functions having type [a]->[a]. Only at some times that I call foldr I convert back to a real list. Should the performance of my application be good now? Or are there more things to improve? I just want to have constant time list concatenation.
11:33:13 <LiquidEngineer> (I see how to make a set from the other list)
11:33:22 <sjanssen> LiquidEngineer: concatMap (\(a, b, c) -> [b, c]) edges
11:33:54 <fasta> Heh, it seems it did work :)
11:34:01 * shapr throws lambdas
11:34:09 <LiquidEngineer> whta's the \ do?
11:34:16 <yip> lambda
11:34:27 <sjanssen> lambda abstraction.  Creates an anonymous function
11:34:29 <ski> satan : the first argument to 'foldr' (curriedly) already takes two arguments .. but if you want to define 'zip' in terms of it, possibly it could work if the things returned after those two arguments is yet another function, taking the other list as argument
11:34:30 <fasta> My program used to use >>90% of its time to concatenate lists.
11:34:35 <yip> > (\x -> x + 1) 1
11:34:36 <lambdabot>  2
11:34:47 <fasta> Now, it's not even showing up in the profile
11:34:58 <satan> ski: right, thats exactly my line of thought too
11:35:36 <ski> (foldr (\x xs -> ..function taking list argument..) (..function taking list argument..) firstList) secondList
11:35:37 <satan> myzip = foldr f a where ... and say the 2 lists are m n, then foldr f a m should return a function g and a list, and g should work on this list and n
11:36:11 <ski> hm
11:36:40 <ski> i think your 'foldr f a m' should just return a function, and that function should be given 'n', and return the final zipped list
11:37:01 <LiquidEngineer> okay
11:37:02 <LiquidEngineer> awesome
11:37:13 <LiquidEngineer> so once I've got these two lists, I can do the sublist comparison thingie
11:37:38 <satan> ski: i see, hmm thats a bit different
11:38:02 <ski> satan : why did you want it to return a function *and* a list ?
11:38:04 <beelsebob> okay - Hat release may be coming up some time - what do you want? Yes Data.Map should be on the wish list
11:38:22 <satan> ski: i thought that might work, i dunno, new to haskell
11:38:35 <ski> maybe it could work, i don't know
11:39:06 <ski> hm
11:39:11 <LiquidEngineer> One last question
11:39:29 <LiquidEngineer> since I'm only looking for equal subsets, can I just use == to compare the sets?
11:39:30 <ski> foldr :: (a -> r -> r) -> r -> [a] -> r
11:39:50 <satan> ski: yeah implementing it is where i'm stuck, like, how do i extract the elements from each list and pair them? i thought of list comprehensions, but not sure how to tie it all in
11:39:55 <ski> satan : if you set 'r' to '[b] -> [(a,b)]', you get
11:40:29 <ski> foldr :: (a -> ([b] -> [(a,b)]) -> [b] -> [(a,b)]) -> r -> [a] -> [b] -> [(a,b)]
11:40:44 <ski> i think that could be the specific type of 'foldr', in your case
11:41:05 <satan> wow okay
11:41:37 <ski> ( i just substituted '[b] -> [(a,b)]' for 'r' in the type signature)
11:41:51 <satan> ah ok, i thought i saw an r in there
11:41:52 <ski> anyway, you see that the two lists are passed in as the last two arguments
11:42:02 <satan> right
11:42:07 <ski> erm, you're right, i forgot to change one 'r'
11:42:19 <ski> foldr :: (a -> ([b] -> [(a,b)]) -> [b] -> [(a,b)]) -> ([b] -> [(a,b)]) -> [a] -> [b] -> [(a,b)]
11:42:39 <satan> right
11:42:52 <ski> LiquidEngineer : how do you represent the subsets ? as lists ? canonicalized (e.g. sorted) ?
11:43:14 <ski> so, something like
11:43:52 <LiquidEngineer> I've just got two sets now
11:43:59 <LiquidEngineer> can I compare them with == ?
11:44:45 <Greyz> a simple task for a change
11:44:54 <ski> zip as bs = foldr (\a zipRest bs0 -> ..zip a with first element of bs0, using zipRest..) (\bs0 -> ..the as0 list is empty here, return appropriate list of pairs..) as bs
11:45:01 <Greyz> need to implement a multiplication table
11:45:03 <astrolabe> LiquidEngineer: yes
11:45:17 <edwardk> greyz: define =)
11:45:25 <LiquidEngineer> groovy
11:45:34 <Greyz> yeah easy for you to say :)
11:45:47 <LiquidEngineer> Odd, though.  I don't see == on the reference page for IntSet
11:45:51 <edwardk> greyz: well, just in general what do you mean
11:45:52 <ski> satan : you might want to lift out the two anonymous functions in a 'where', since it seems to become longish
11:45:59 <LiquidEngineer> is it defined by something IntSet inhereits?
11:46:06 <Greyz> multiplication !! 4 !! 5 should outcome 20
11:46:08 <LiquidEngineer> Set, I guess?
11:46:15 <edwardk> ah
11:46:16 <Greyz> it should be list of lists
11:46:18 <satan> ski: alright, i'll try it, wow :S
11:46:27 <satan> ski: thanks :)
11:46:32 <fasta> Is there benchmark code for Haskell that creates nice plots on how a particular function scales when run on larger input?
11:46:51 <Greyz> where first list is 1 multiplied with infinity
11:46:57 <astrolabe> LiquidEngineer: You're using IntSet?
11:47:04 <ski> satan : you have to consider all four cases, as usual, 'as' either empty or nonempty, times, 'bs' either empty or nonempty
11:47:14 <LiquidEngineer> astrolabe: Yes
11:47:19 <Greyz> second list is 2 multiplied with infinity and so on
11:47:37 <satan> ski: right, so i could do that with the | operator, right
11:47:38 <LiquidEngineer> is that a problem?
11:47:40 <ski> satan : first argument to 'foldr' is when 'as' is nonempty ('bs' is passed in as-is, so you'll have to check that yourself)
11:47:45 <satan> ski: don't know if its an op
11:47:59 <astrolabe> The fact that Intset is an instance of Eq means you can use == on it.
11:48:08 <astrolabe> LiquidEngineer: Not a problem.
11:48:16 <ski> satan : second argument to 'foldr' is when 'as' is empty ('bs' still passed in as-in, so you could check 'bs' here, too)
11:48:51 <LiquidEngineer> ah
11:48:53 <ski> satan : '|' starts a "guard", it can only be used at declarations and 'case'-expressions
11:49:03 <LiquidEngineer> It's been forever since I've defined my own datatypes in Haskell
11:49:11 <LiquidEngineer> I've forgotten how svelte it is.
11:49:15 <satan> ski: ah i see
11:49:18 <nomeata> @seen ndm
11:49:19 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 18h 10m 38s ago, and .
11:49:28 <LiquidEngineer> haskell-blah?
11:49:31 <ski> (satan : but you could possibly use either a declaration (inside the 'where') or a 'case')
11:49:55 <LiquidEngineer> @paste
11:49:55 <lambdabot> http://paste.lisp.org/new/haskell
11:50:20 <ski> satan : the one thing that maybe is a little tricky is to figure out what the 'zipRest' argument to first argument to 'foldr' means (i've hinted in my naming)
11:50:24 <lisppaste2> LiquidEngineer pasted "Parse Error on where" at http://paste.lisp.org/display/27407
11:50:48 <LiquidEngineer> Would anyone be so kind as to help me figure out what it doesn't like about my where statement?
11:50:54 <satan> ski: sorry for the total newbie q, but a declaration inside a where?
11:50:58 <nomeata> Greyz: you mean something like [map (n*) [1..] | n <- [1..] ]
11:51:08 <ski> foo x y = ...
11:51:09 <ski>   where
11:51:13 <ski>   bar z = ...
11:51:18 <nomeata> > [map (n*) [1..] | n <- [1..] ] !! 4 !! 5
11:51:19 <lambdabot>  30
11:51:27 <satan> ski: ah ok thanks
11:51:28 <ski> satan : that's a declaration of 'bar' inside the 'where'
11:51:33 <nomeata> > [map (n*) [0..] | n <- [0..] ] !! 4 !! 5
11:51:34 <lambdabot>  20
11:52:07 <nomeata> > let multiplicatoin =  map (\n -> map (n*) [0..]) [0..] in multiplication !! 4 !! 5
11:52:07 <lambdabot>  Not in scope: `multiplication'
11:52:18 <nomeata> > let multiplication =  map (\n -> map (n*) [0..]) [0..] in multiplication !! 4 !! 5
11:52:19 <lambdabot>  20
11:52:30 <nomeata> @pl let multiplication =  map (\n -> map (n*) [0..]) [0..] in multiplication
11:52:31 <lambdabot> map (flip map [0..] . (*)) [0..]
11:54:28 <LiquidEngineer> I think it's a whitespace problem, I but I can't figure out how to fix it
11:54:34 <LiquidEngineer> I've tried several variations.
11:54:41 <satan> ski: ok lemme try it, thanks for your help :)
11:54:54 <ski> np
11:54:54 <roconnor> w00t: I've assembled an uploader
11:54:58 <lispy> is a list comprehension lazier than filter?
11:56:21 <nomeata> has anyone here played around with PropLang?
11:56:50 <ski> LiquidEngineer : you're missing the 'else'
11:58:19 <Greyz> ok that works just fine, now I have to figure out how it works
11:59:44 <LiquidEngineer> ski: Thanks.
11:59:57 <Greyz> thanks to everyone :)
12:00:00 <LiquidEngineer> My else stuff isn't implemented yet so I had it commented out
12:00:07 <LiquidEngineer> I didn't realize ifs required them.
12:00:40 <nomeata> > let multiplication =  [ [ a * b | a <- [0..] ] | b <- [0..] ] in multiplication !! 4 !! 5
12:00:41 <lambdabot>  20
12:00:59 <nomeata> Greyz: that might be easier to understand if you are not used to map. Is basically the same code.
12:01:08 <lisppaste2> ski annotated #27407 with "missing 'else'" at http://paste.lisp.org/display/27407#1
12:01:13 <nomeata> Note that it's a list comprehension inside a list comprehension
12:02:12 <LiquidEngineer> wow
12:02:14 <LiquidEngineer> that's disturbing
12:02:22 <LiquidEngineer> what in the world is a red type?
12:02:38 <ski> > let pam = flip map; multiplication = pam [0..] $ \n -> pam [0..] $ \m -> n*m  in multiplication !! 4 !! 5
12:02:39 <lambdabot>  20
12:02:55 <Greyz> yeah you're right thats even better :)
12:02:57 <Greyz> thanks
12:03:41 <ski> (you could s/pam/collect/, if you wished)
12:04:10 <ski> LiquidEngineer : red ?
12:05:28 <LiquidEngineer> I swear that's what the error said
12:05:55 <ski> could you paste this error ?
12:05:56 <LiquidEngineer> I fixed it (wasn't passing enough args) but still, wierd.
12:06:04 <LiquidEngineer> yeah
12:06:05 <LiquidEngineer> hold on
12:07:04 <LiquidEngineer> whoops
12:07:09 <LiquidEngineer> crud
12:07:13 <LiquidEngineer> it's not doing it now
12:07:23 <LiquidEngineer> must've been a wierd eclipse thing...sometimes it doesn't print things quite right
12:07:46 <ski> mhm
12:08:57 <chessguy> you're writing haskell in eclipse?
12:16:10 <yip> "Things equal to nothing else are equal to each other."
12:16:40 <ski> ?
12:16:43 <cjay> ?
12:16:46 <xerox> That's risky.
12:17:03 <nomeata> not really
12:17:13 <glguy> does printf use template haskell?
12:17:22 <ski> think not
12:17:23 <nomeata> as this is only true if there is only one thing equal to nothing else
12:17:34 <nomeata> otherwise you have a contradiction
12:17:35 <yip> xerox: it's philosophy quote of the day
12:17:40 <nomeata> (one thing or no thing)
12:18:45 <xerox> It's just that `thing' is ill-defined, I think you can derive a contradiction in many cases.
12:24:20 <fasta> yip: logically that seems sound
12:25:07 <fasta> yip:they are also not equal to each other at the same time.
12:26:22 <svref> So today I read about the list monad for the first time.  If this is used in practice, how come >>= doesn't cull duplicate entries in its output for efficiency's sake?
12:27:14 <ski> sometimes duplicates are wanted .. and besides, that would require an 'Eq' constraint, which can't be encoded (currently)
12:29:19 <ski> (i.e. there's no 'Eq' constraint on type signature of '(>>=)' in 'class Monad' declaration, and it can't be "added" in instances)
12:29:38 <svref> I see.  I guess I can be happy with that.
12:29:52 <svref> Thanks.
12:29:59 <ski> (this is btw, the same problem as the one with 'ord' and sets as monads)
12:30:13 <ski> (s/ord/Ord/)
12:30:17 <araujo> hi!!
12:30:28 * araujo throws sugar lambdas!
12:30:28 <ski> hi there, araujo
12:30:44 <araujo> hi hi ski !
12:30:54 * ski puts salt on them and devours them
12:31:04 <araujo> hah
12:40:45 <fasta> How can I give an argument to a program that uses getLine programmatically?
12:41:24 * araujo doesn't understand the question
12:41:39 <fasta> Thus instead of me typing "./foo" <SPACE> <INPUT> <ENTER>, I would like that to happen automatically.
12:41:40 <Lemmih> fasta: Refactor your code?
12:42:16 <fasta> Lemmih: yes, I can give it as a commandline option, I suppose, but that only adds even more code.
12:42:29 <Lemmih> fasta: echo "hello" | ./foo?
12:42:40 <fasta> I know the program "expect" can do something like that.
12:42:43 <fasta> Lemmih: probably
12:43:21 <dylan> if ./foo just reads from stdin, piping will work.
12:43:25 <fasta> Lemmih: yep, I was wondering how to send the End Of Input, but that's embedded of course.
12:43:31 <dylan> if it uses ncurses or gnu readline, it won't
12:43:52 <dylan> EOF == close the pipe.
12:44:23 <glguy> I just checked my voicemail at work and had a message from August 24
12:44:34 <dylan> speaking of pipes, I'm surprised there isn't a function like:
12:44:46 <dylan> @hoogle a -> (a -> b) -> b
12:44:48 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
12:44:48 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
12:44:48 <lambdabot> Control.Parallel.Strategies.($|) :: (a -> b) -> Strategy a -> a -> b
12:45:14 <nomeata> @type (flip ($))
12:45:15 <dylan> ^ those are false positive, though $| is nifty.
12:45:16 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
12:45:33 <dylan> yeah.
12:46:11 <nomeata> @type (flip (id))
12:46:12 <lambdabot> forall b c. b -> (b -> c) -> c
12:47:34 <dcoutts> dons, both HWN annnouncements are in this week's LWN weekly edition. ie sept 27 & oct 3
12:47:38 <nomeata> dylan: maybe because it does not go well with the "right to left" data flow of regular function application, "." and "$"
12:47:39 <apfelmus> @type flip id id . flip id
12:47:41 <lambdabot> forall a. a -> a
12:47:49 <nomeata> although it does fit to >>=
12:48:01 <dylan> I like left-to-right. :)
12:48:28 <dylan> ls | grep '^2006-' | wc -l
12:48:28 <nomeata> help youself: let (||) = (flip id)
12:48:36 <dylan> nomeata: already have, with '#|'
12:48:55 <nomeata> > let (||) = (flip id) in 3 || negate || (* 20)
12:48:56 <dylan> And an IO-monadic version.
12:48:56 <lambdabot>  -60
12:49:02 <nomeata> true, it is neat
12:49:10 <nomeata> how is that defined?
12:49:42 <nomeata> (your monadic version)
12:49:45 <ski> (>$) = flip ($)
12:49:49 <ski> (>.>) = flip (.)
12:50:03 <nomeata> @type flip (.)
12:50:05 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
12:50:20 <dylan>  (Monad m) => m t -> (m t -> a) -> m a
12:50:59 <dylan> err, typo. (Monad m) => m t -> (t -> a) -> m a
12:51:58 <nomeata> @type (\m nm -> return.nm =<< m)
12:52:00 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> b) -> m b
12:52:03 <ski> (dylan : the typoed one looked like the comonadic '(=>>)' ..)
12:52:18 <ski> @type flip liftM
12:52:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
12:52:22 <edwardk> ski: i always thought flip (.) should be | so the unix folks would feel at home =)
12:52:29 <dylan> foo <- getDirectoryContents "." # length # negate
12:52:38 <ski> edwardk : but that clashes with guards ..
12:52:43 <edwardk> yeah
12:53:05 <edwardk> still
12:53:05 <edwardk> =)
12:53:33 <edwardk> guards can have the unparenthesized , or something
12:53:34 <ski> foo <- negate `liftM` (length `liftM` getDirectoryContents ".")
12:53:35 <edwardk> =)
12:53:55 <ski> foo <- (negate . length) `liftM` getDirectoryContents "."
12:54:01 <ski> (is parens needed ?)
12:54:54 <dylan> ski: yes, I know it can be written than way, but the other order seems more interesting to me. :)
12:55:30 <satan> ski: i've been trying with that foldr problem, but don't think i've gotten anywhere heh
12:55:32 * ski prefers a more assymetric operator glyph, though
12:56:00 <dylan> upside down $. ;)
12:56:17 * ski grins
12:56:22 <edwardk> since we're talking random character swapping, how bad do you think it would be if  (.),  (<<<), map, fmap and liftM were just rolled into something like (.) ?
12:56:27 <nomeata> maybe we should have things like (|>) and (<|), and variations of that, for monading and non-monadic versions of ($) and (.)
12:56:28 <edwardk> in a non-haskell language
12:56:36 <glguy> edwardk: I like that idea
12:57:09 <ski> edwardk : the last three obviously ought to look different from the first two
12:57:32 <dylan> let (#) = flip id in "foo" # length
12:57:35 <dylan> > let (#) = flip id in "foo" # length
12:57:37 <lambdabot>  3
12:57:53 <dylan> flip id is interesting for accessing records, too.
12:58:00 <glguy> > map ($ 5) [(*2) `fmap` (+1), (*2) . (+1)]
12:58:01 <lambdabot>  [12,12]
12:58:10 <ski> dylan : how do you mean ?
12:58:24 <ski> satan : how far have you come ?
12:58:44 <dylan> ski: if person is a record, and name is a field of that record, then person # name == name person
12:58:54 <ski> ok
12:59:11 <satan> ski: not very far i'm afraid, i've yet to deal with the empty and non empty cases
12:59:15 * ski would possibly prefer real record selectors
12:59:32 <satan> i just don't know how to get the elements of the list and pair them....
12:59:41 <nomeata> dylan: nice idea. so lets' implement the record accessor as let (.) = flip (id) :-)
12:59:43 <fasta> Either I found a bug in "echo" or I found a bug in some core Haskell library functions.
13:00:00 <dylan> nomeata: nah, . is compose. I like that.
13:00:11 <fasta> Ok, it's the latter.
13:00:13 <ski> satan : in the "empty case", the first list is empty, and you're given the second list .. and you should return the zipping of an empty list with the other list
13:00:14 * nomeata was kidding.
13:00:22 <ski> satan : so what is that zipping ?
13:00:30 <Igel_original> hi
13:00:47 <satan> something like [(,3),(,4),(,5)]...and so on?
13:00:49 <Igel_original> can someone help a beginner with a Parsec problem?
13:01:06 <Igel_original> there is the choice operator: <|>
13:01:16 <ski> satan : there are no pairs with nothing as first element
13:01:37 * glguy guesses Igel_original will need try... let's watch
13:01:38 <satan> ski: oh so it'd be the empty list then?
13:01:42 <ski> satan : if if you call 'zip [] [2,3]' with your 'zip' function, what should be returned ?
13:01:55 <Igel_original> but it only notices a "wrong choice" if it fails at the first character
13:01:59 <Igel_original> so
13:02:00 <satan> the empty list
13:02:17 <Igel_original> (string "sin") <|> (string "sqrt")
13:02:21 <Igel_original> won't work
13:02:31 <kpreid> Igel_original: glguy's guess is correct
13:02:34 <ski> dylan : i.e. real record types, instead of the current hack
13:02:38 <glguy> huzzah!
13:02:57 <kpreid> Igel: write either try (string "sin") <|> string "sqrt"
13:03:10 * glguy has never really used parsec, but has read the tutorial
13:03:15 <kpreid> or char 's' >> (string "in" <|> string "qrt")
13:03:42 <ski> try (string "sin") <|> string "sqrt"
13:04:03 <fasta> Is there a function that can take the logBase 2 of an Integer?
13:04:11 <glguy> fasta: log x / log 2
13:04:22 <glguy> ?hoogle logBase
13:04:22 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
13:04:28 <glguy> > logBase 2 8
13:04:28 <fasta> I want it to give the correct answer.
13:04:29 <lambdabot>  3.0
13:04:47 <fasta> glguy: that function fails for large numbers
13:04:59 <fasta> when using fromInteger
13:05:13 <nomeata> fasta: \x -> filter (\n -> 2^n == x) [0..]
13:05:15 <glguy> the prelude defines  logBase x y          = log y / log x.  To do it on large integer values, you'll need to roll one
13:05:20 <nomeata> fasta: \x -> head $ filter (\n -> 2^n == x) [0..]
13:05:33 <nomeata> of course works only for numbers where the solution is a integer as well :-)
13:05:47 <glguy> fasta: there are some powerOf function floating around, but not in the Prelude
13:06:06 <fasta> nomeata: and it's inefficient....
13:06:16 <glguy> powerOf n p = length $ takeWhile (\x -> x `mod` p == 0) (iterate (`div` p) n)
13:06:22 <nomeata> fasta: and not serious :-)
13:06:31 <Igel_original> glguy, kpreid: it won't work
13:06:44 <fasta> nomeata: I am interested in a serious solution.
13:06:51 <Igel_original> i'm using Parsec.Expr
13:07:00 <nomeata> fasta: sorry
13:07:02 <Igel_original> and i've defined an operator table
13:07:02 <glguy> fasta: that code that I just pasted came from Cale's wiki page
13:07:15 <Igel_original> which takes a list of operator parsers
13:07:17 <fasta> And where is Cale's wiki page?
13:07:21 <glguy> > let powerOf n p = length $ takeWhile (\x -> x `mod` p == 0) (iterate (`div` p) n) in powerOf (2^10000) 2
13:07:21 <fasta> @where cale
13:07:22 <lambdabot>  10000
13:07:22 <lambdabot> I know nothing about cale.
13:07:26 <fasta> @where Cale
13:07:26 <lambdabot> I know nothing about cale.
13:07:59 <fasta> Ok, I will see whether that works
13:08:10 <glguy> > let powerOf n p = length $ takeWhile (\x -> x `mod` p == 0) (iterate (`div` p) n) in 2 `powerOf` (2^1000000)
13:08:11 <lambdabot>  0
13:08:30 <glguy> > let powerOf n p = length $ takeWhile (\x -> x `mod` p == 0) (iterate (`div` p) n) in powerOf (2^1000000) 2
13:08:34 <lambdabot>  out of memory (requested 2097152 bytes)
13:08:35 <Igel_original> well, i pass try (string "sqrt") and try (string "sin") to it now, but it says:
13:08:48 <Igel_original> evalString "sin 0"
13:08:48 <Igel_original> "= *** Exception: ./Expression.hs:(21,0)-(31,52): Non-exhaustive patterns in function evalExpr
13:08:58 <glguy> fasta: thre are probably more efficient methods available, but not in the prelude
13:09:09 <kpreid> Igel_original: you have a separate problem then
13:09:19 <kpreid> Igel_original: what does evalExpr do?
13:09:33 <fasta> glguy:  2 `powerOf` (2^1000000) gives 0 here
13:09:37 <Igel_original> evalExpr applies a parser to a given string to make an expression from it
13:09:42 <Igel_original> which is a data type
13:09:48 <glguy> fasta: the arguments go the other way
13:10:19 <kpreid> Igel_original: the message means that something is being passed to evalExpr which its patterns don't handle.
13:11:03 <Igel_original> well it did evaluate "sqrt" before i added sin
13:11:09 <satan> > :t foldr
13:11:09 <lambdabot>  Parse error
13:11:10 <Igel_original> "sin"
13:11:15 <satan> >:t foldr
13:11:25 <chessguy> @type foldr
13:11:26 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
13:11:48 <kpreid> Igel_original: it's not a Parsec problem any more. we can't help without seeing your code
13:12:06 <Igel_original> ok, wait a sec
13:13:22 <fasta> Wasn't there also a function to convert decimal numbers to binary?
13:13:57 <Igel_original> http://paste.lisp.org/display/27417 and http://paste.lisp.org/display/27419
13:14:36 <Igel_original> the part with the sin is commentet out^^
13:15:49 <kpreid> Igel_original: as the error message said, the problem is in evalExpr
13:15:54 <kpreid> you don't have a case for Sin
13:18:46 <chessguy> that would do it
13:18:53 <Igel_original> kpreid: but parseExpr doesn't do much more than invoking the "buildExpressionParser ... "
13:19:05 <fasta> Hmm, I actually found code on the web doing it. Haskell must be getting popular ;)
13:19:15 <kpreid> Igel_original: read the error message!
13:19:20 <fasta> Not that all of it compiled...
13:19:24 <kpreid> Igel_original: it is evalExpr, not parseExpr
13:20:14 <glguy> fasta: http://www.haskell.org/onlinereport/numeric.html has integerLogBase
13:20:17 <lambdabot> Title: The Haskell 98 Library Report: Numerics, http://tinyurl.com/gfbg5
13:20:35 <Igel_original> kpreid: ouch :D
13:20:49 <Igel_original> it's a clear advantage, being able to read :\
13:20:54 <Igel_original> thank you
13:21:13 <Igel_original> sounded like a parsing error...
13:21:25 <Igel_original> now it works
13:23:10 <fasta> glguy: very interesting, but I can't find that in the Numeric module in GHC.
13:23:17 <glguy> fasta: it's not exported
13:23:38 <fasta> glguy: is the functionality exposed somewhere?
13:23:47 <glguy> fasta: doubtful :)
13:23:48 <fasta> glguy: otherwise, I just steal the code
13:24:01 <glguy> fasta: sounds reasonable
13:24:09 <fasta> I don't like it when people write useful code and don't export it.
13:24:17 <fasta> I also don't like it when they export too much.
13:24:43 <fasta> For an example of the latter see HXMLToolBox or something like that.
13:25:20 <glguy> ?type GHC.Float.integerLogBase
13:25:21 <lambdabot> Integer -> Integer -> Int
13:25:25 <glguy> fasta: ^^^
13:25:39 <SamB> fasta: HXT
13:25:59 <SamB> I think it is best to find a good place to *put* said useful code that you are exporting
13:26:00 <fasta> glguy: you are too kind.
13:26:25 <SamB> and don't export about 3 dozen different functions that do pretty much the same thing, with subtle differences
13:26:57 <fasta> Heh, HXT brings up warm memories ...
13:27:04 <nomeata> is there still need for a zip implemented with foldr?
13:27:15 <SamB> (at least not from the same module. and if you do, make sure to tell the user why they'd want to use a particular one!)
13:27:29 <SamB> (and if you can't come up with a convincing reason... then don't export it!)
13:28:50 <SamB> nomeata: what meaneth thou "still"?
13:29:17 <nomeata> SamB: some while ago someone needed help, and I found a way to do so, but maybe that's old news by now
13:29:23 <nomeata> actually wasn't too hard
13:29:33 <fasta> Hmm, I actually do start to like GHC more and more. Their interfaces don't get in my way.
13:29:48 <SamB> nomeata: oh, you mean like homework or something?
13:29:54 <fasta> It's only annoying that I need to use so much platform dependent stuff.
13:30:08 <nomeata> SamB: dunno, someone wanted it on the channel here.
13:30:28 <SamB> fasta: in which package?
13:30:37 <SamB> the base package?
13:31:12 <fasta> SamB: _I_ use Data.Generics, and I use GHC.Float
13:31:33 <fasta> SamB: and a shitload of extensions.
13:31:34 <glguy> is that a bottom?
13:31:38 <SamB> ah
13:31:40 <nomeata> zip' = foldr inner (const [])
13:31:41 <nomeata> 	where inner e f [] = []
13:31:41 <nomeata> 	      inner e f (x:xs) = (e,x):f xs
13:32:04 <fasta> I especially don't like all the extensions as I don't fully understand them.
13:32:08 <SamB> if anything seems to be missing from the library modules(or their export lists), mail the library list!
13:32:13 <fasta> Not that I think anybody _fully_ understands them.
13:32:24 <SamB> I especially don't like all the extensions ending in -instances
13:32:42 <fasta> SamB: yes, they seem to open up a can of worms.
13:32:47 <nomeata> @pl let inner e f [] = []; inner e f (x:xs) = (e,x):f xs in foldr inner (const [])
13:32:47 <lambdabot> (line 1, column 15):
13:32:48 <lambdabot> unexpected "["
13:32:48 <lambdabot> expecting pattern or "="
13:33:17 <svref> so I kinda want to search a bunch of data, and list comprehensions are a good way, but I only want to return 0-1 elements.  Should I use "take 1 [list comprehension]", or is there some better way?
13:33:18 <nomeata> @pl let inner e f [] = []; inner e f (x:xs) = (e,x):f xs; zip' = foldr inner (const []) in zip'
13:33:19 <lambdabot> (line 1, column 15):
13:33:19 <lambdabot> unexpected "["
13:33:19 <lambdabot> expecting pattern or "="
13:33:28 <fasta> SamB: what should I send? "I used integerLogBase. That's all I had to say. Bye"?
13:33:44 <glguy> svref: take 1 is reasonable
13:34:01 <SamB> whenever I run into someone trying to use them (in a darcs project), I quick fix the code and send in a patch ;-
13:34:03 <SamB> fasta: hmm?
13:34:06 <nomeata> what am I doning wrong. no pattern matching in let?
13:34:06 <glguy> fasta: I think that the second sentence there was implied
13:34:21 <SamB> is that missing now?
13:34:22 <fasta> glguy: true, but I wanted to underline something.
13:34:26 <nomeata> @pl let inner e f l = if null l then [] else = (e, head l):f (tail l); zip' = foldr inner (const []) in zip'
13:34:26 <lambdabot> (line 1, column 42):
13:34:27 <lambdabot> unexpected "="
13:34:27 <lambdabot> expecting lambda abstraction or expression
13:34:37 <fasta> SamB: it's not in GHC, but it's platform dependent.
13:34:44 <SamB> fasta: oh
13:34:47 <nomeata> @pl let inner e f l = if null l then [] else (e, head l):f (tail l); zip' = foldr inner (const []) in zip'
13:34:48 <lambdabot> foldr ((ap (flip if' [] . null) .) . (. (. tail)) . ap . ((:) .) . (. head) . (,)) (const [])
13:34:58 <nomeata> ouch
13:35:03 <SamB> fasta: you could elaborate and say you would like a portable way to do that
13:35:26 <fasta> SamB: P.S. Please add Data.Generics to Hugs ;)
13:35:30 <fasta> hahahaha
13:35:35 <SamB> also maybe which module it was in would be a nice thing to put in the email ;-)
13:35:58 <SamB> @hoogle integerLogBase
13:35:59 <lambdabot> No matches found
13:36:03 <fasta> SamB: oh, right, being constructive... hmm, I wonder how I will do that... :P
13:36:11 <SamB> oh, right, those modules aren't indexed
13:36:27 <glguy> > zipWithM (\x y -> guard (x > 0) >> Just (x + y)) [1..4] [7..10]
13:36:28 <glguy> > zipWithM (\x y -> guard (x > 0) >> Just (x + y)) [0..4] [7..10]
13:36:29 <lambdabot>  Just [8,10,12,14]
13:36:30 <lambdabot>  Nothing
13:36:36 <SamB> fasta: if you want them to improve the libraries, you should be somewhat explicit about your wants
13:37:18 <glguy> > mapAndUnzipM (\x -> (x-1,x+1)) [1..4]
13:37:19 <lambdabot>  add an instance declaration for (Num (b, c))
13:37:19 <lambdabot>   In an arithmetic sequence:...
13:37:26 <fasta> SamB: I think everyone has his own Util library for this project. I wonder whether it will work.
13:37:33 <glguy> > mapAndUnzipM (\x -> [(x-1,x+1),(x-2,x+2)]) [1..4]
13:37:34 <fasta> er his/her
13:37:35 <lambdabot>  [([0,1,2,3],[2,3,4,5]),([0,1,2,2],[2,3,4,6]),([0,1,1,3],[2,3,5,5]),([0,1,1,2...
13:37:59 <SamB> fasta: which project?
13:38:28 <fasta> SamB: my project
13:38:37 <fasta> SamB: for example this one: inPieces k = takeWhile (not . null) .map (take k) . iterate (drop k)
13:38:49 <fasta> SamB: I use it in multiple places.
13:39:02 <fasta> SamB: I don't think people care for that code, while I do.
13:39:29 <fasta> The space of "interesting" code differs per project, I think.
13:39:49 <glguy> fasta: does that do this:
13:40:08 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (Just .splitAt 2)) [1..10]
13:40:10 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:41:24 <fasta> glguy: I think so, but your code is obfuscated or advanced. Pick one.
13:41:29 <SamB> @type inPieces k = takeWhile (not . null) .map (take k) . iterate (drop k)
13:41:30 <glguy> obfuscated
13:41:30 <lambdabot> parse error on input `='
13:43:21 <fasta> I also think it's important to state intentions while programming.
13:43:35 <glguy> fasta: but mine does it in one pass instead of two
13:43:39 <SamB> I say it is obfusticated
13:43:45 <fasta> E.g. lookupForSure e l = fromJust (lookup e l)
13:43:50 <SamB> guard is unfamilar to me...
13:44:07 <glguy> SamB: guard is not an obfuscation, it's a staple of using monadplus
13:44:11 <SamB> hmm
13:44:22 <SamB> @type guard
13:44:23 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:44:24 <glguy> SamB: it's the use of (->)r  that is the obfuscation
13:44:35 <SamB> whats it do?
13:44:36 <fasta> glguy: I will put it next to the other version, and when I need performance I will use it, ok?
13:44:45 <fasta> I don't think I need performance there, though.
13:44:49 <glguy> fasta: It doesn't matter to me, I was just trying ot justify it :)
13:45:00 <glguy> fasta: it's only ugly like that so that it fits on one line for irc
13:46:39 <glguy> SamB: all it is doing is this:
13:46:40 <glguy> > let f [] = Nothing; f xs = Just (splitAt 2 xs) in unfoldr f [1..10]
13:46:41 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:47:28 <SamB> @type let inPieces k = takeWhile (not . null) .map (take k) . iterate (drop k) in inPieces
13:47:29 <lambdabot> forall a. Int -> [a] -> [[a]]
13:49:44 <fasta> SamB: I also have my own liftM6, and besides that some simple parse functions that I use in multiple parsers.
13:49:58 <fasta> @type liftM4
13:50:00 <lambdabot> forall r (m :: * -> *) a4 a3 a2 a1. (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
13:50:02 <fasta> @type liftM5
13:50:04 <lambdabot> forall r (m :: * -> *) a5 a4 a3 a2 a1. (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
13:50:07 <fasta> @type liftM^
13:50:08 <lambdabot> parse error (possibly incorrect indentation)
13:50:09 <fasta> @type liftM^
13:50:11 <lambdabot> parse error (possibly incorrect indentation)
13:50:11 <fasta> @type liftM6
13:50:13 <lambdabot> Not in scope: `liftM6'
13:50:20 <fasta> See, it stops at 5
13:51:19 <ventonegro> @version
13:51:20 <lambdabot> lambdabot 4p233, GHC 6.5 (OpenBSD i386)
13:51:20 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:52:08 <ventonegro> @type lift
13:52:09 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:52:25 <ventonegro> @type lift10
13:52:26 <lambdabot> Not in scope: `lift10'
13:52:31 <ventonegro> @type lift5
13:52:32 <lambdabot> Not in scope: `lift5'
13:52:39 <ventonegro> :-)
14:13:50 <SamB> hmm
14:14:04 <cjay> hm
14:14:11 <glguy> ah ha!
14:14:17 * SamB wonders if all the 1,366,178 not-freed blocks that valgrind has found have pointers to them
14:16:26 <Etni3s> hi. i'm having problems compiling lambdabot. i get this error:
14:16:26 <Etni3s> rm: cannot remove `depend': No such file or directory
14:16:33 <Etni3s> can anyone help me?
14:20:15 <fasta> SamB: can you run valgrind on Haskell apps? Or does it have anything to do with Haskell?
14:20:42 <SamB> fasta: that is on my UM
14:20:48 <SamB> running adventure
14:21:00 <fasta> SamB: oh, right, the thing mux is addicted to.
14:21:21 <fasta> SamB: you wrote your UM in C?
14:21:42 <SamB> yes
14:21:56 <SamB> I stuff pointers into uint32_ts
14:22:41 <Etni3s> please someone?
14:22:56 <fasta> SamB: what is uint32_ts? unsigned 32 bit and then?
14:23:53 <pejo> fasta, Nethercote has run cachegrind on things. http://www.cs.mu.oz.au/~njn/pubs/cache-large-lazy2002.ps.gz
14:23:54 <lambdabot> http://tinyurl.com/ktoqs
14:28:08 <glguy> SamB: do you free memory on LOADPROG?
14:28:21 <glguy> when it's not platter 0?
14:29:47 <fasta> pejo: hmm, read the most interesting bits from that paper. Somewhat nice to read.
14:30:54 <SamB_XP> glguy: of course!
14:31:05 <SamB_XP> valgrind is thrashing a bit...
14:38:30 <fasta> How's that visual front end for valgrind called/
14:40:33 <ventonegro> alleyoop
14:41:00 <pejo> fasta, kcachegrind?
14:41:18 <ventonegro> ah, gnome vs. kde
14:42:21 <fasta> ventonegro: I don't think there's real battle here.
14:42:42 <ventonegro> i didn't mean so
14:42:46 <fasta> ventonegro: as kcachegrind pwns alleyoop judging from the screenshots.
14:43:07 <fasta> pejo: seems nice
14:43:17 <ventonegro> yeah, just checked them as well
14:43:29 <ventonegro> don't use them
14:43:38 <ventonegro> i mean, i don't use them
14:45:33 <fasta> ventonegro: I neither used them.
14:46:30 * ventonegro keeps forgetting that English needs the pronoun
14:48:01 <SamB> you can get away without them if you can make it clear that you aren't using the imperative
14:48:56 <ventonegro> SamB, in this case how?
14:49:12 <glguy> don't use them (not imperative)
14:49:17 <ventonegro> hehehehe
14:49:19 <SamB> hah
14:49:30 <SamB> I never said it was reasonable in this instance
14:49:39 <glguy> or rather
14:49:43 <SamB> but, if I said "don't like them"
14:49:43 <glguy> never said it was reasonable?
14:50:02 <SamB> what would you think I meant?
14:50:16 <glguy> that usage seems reasonable to me
14:50:45 * Etni3s gives up on the bot compile..
14:51:05 <glguy> The ability to drop a pronoun is critical for effective English-golf...
14:51:35 <fasta> Etni3s: I tried compiling it too.
14:51:57 <fasta> Etni3s: I only have no interest in getting fps>=0.7, so I give up too.
14:52:02 <glguy> If the build process is blowing-up on a "rm" just change that to "rm -f"
14:52:17 <Etni3s> hmm ok
14:52:36 <SamB> hmmm
14:52:42 <fasta> hmmmmmm
14:53:01 <SamB> apparantly adventure *might* have leaked:
14:53:03 <SamB> ==10890==      possibly lost: 43,609,652 bytes in 1,366,151 blocks.
14:53:08 <glguy> I learned more about English grammar by taking German classes in highschool than I ever did in my English classes :)
14:53:26 <hyrax42_> knowledge of grammar isn't necessary to speak the language
14:53:43 <SamB> hyrax42_: hence, the non-teaching in english classes?
14:53:45 <ventonegro> > (++) [h] $ repeat 'n'
14:53:46 <lambdabot>  Not in scope: `h'
14:53:48 <hyrax42_> *active  knowledge
14:53:53 <ventonegro> > (++) "h" $ repeat 'n'
14:53:54 <lambdabot>  "hnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn...
14:54:21 <glguy> 'h':repeat 'n'
14:54:37 <hyrax42_> ?type foldr ((undefined :: a -> a -> b) . (:))
14:54:39 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [a] -> [a]
14:54:39 <glguy> 'h':['n','n'..]
14:54:52 <ventonegro> glguy, use the >
14:54:56 <fasta> glguy: hmm, do you also respond like that? I could build a simplifier then.
14:55:20 <fasta> er always
14:55:29 <SamB> > 'h':['n','n'..]
14:55:30 <glguy> fasta: Sorry, I'm not sure what you mean
14:55:30 <ventonegro> @type scanl
14:55:30 <lambdabot>  "hnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn...
14:55:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:55:45 <pejo> hyrax, that only goes for native speakers, basically. The rest of the world has to struggle along.
14:56:00 <hyrax42_> well sort of
14:56:15 <SamB> pejo: well, you could learn languages without learning the grammar formally
14:56:16 <hyrax42_> if you have a level of fluency, you're not using your active knowledge when you speak
14:56:16 <fasta> glguy: given an expression to simplify E; send E to IRC channel; wait for glguy to answer with A; return A
14:56:32 <fasta> glguy: it was a bad joke
14:56:34 <SamB> but it probably would take longer
14:56:39 <hyrax42_> and if I dropped you in Outer Mongolia, I think you'd catch the language eventually
14:56:44 <glguy> fasta: oh, lol.  I just do it when I don't want to actually do work(at work)
14:56:46 <SamB> fasta: I got it!
14:56:51 <hyrax42_> oh woops
14:56:52 <pejo> hyrax, or starve to death. Either one.
14:56:55 <fasta> SamB: you mean the first time?
14:56:57 <hyrax42_> ?type foldr ((undefined :: a -> b) . (:))
14:56:59 <lambdabot> forall a b. b -> [a] -> b
14:57:02 <SamB> fasta: yes ;-)
14:57:02 <hyrax42_> ?type map
14:57:04 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:57:15 <fasta> SamB: you are one smart boy!
14:57:15 <hyrax42_> oh fer chrissakes
14:57:48 <SamB> I wasn't 100% sure you were trying to make the joke, or I probably would have laughed...
14:57:48 <hyrax42_> wait I can't even remember what it was I wanted to check
14:58:21 <SamB> ?scheck (==) True
14:58:22 <lambdabot>   Failed test no. 2. Test values follow.: False
14:58:26 <hyrax42_> but learning any grammar formally will give you insights into your native tongue's grammar
14:58:39 <SamB> ... even the C grammar?
14:59:09 <hyrax42_> s/language/natural &/
14:59:10 <fasta> There's a joke about programmers knowing the formal language of a dozen languages, but not knowing English.
14:59:23 <fasta> (programming languages)
14:59:31 <SamB> of course, it probably ain't true
14:59:35 <glguy> fasta: what's the joke?
14:59:43 <SamB> since they go around with them pocket reference guides
14:59:43 <hyrax42_> but my eg is I learned arabic as a kid, taught in arabic
14:59:45 <SamB> and such
14:59:50 <hyrax42_> and we *were* taught formal grammar
15:00:03 <hyrax42_> so I knew the structures for english, but not the english names
15:00:22 <SamB> oh
15:00:34 <hyrax42_> (I'm mother-tongue english)
15:00:44 <fasta> glguy: I can't find it back.
15:00:47 <SamB> so are you going to start spouting arabic symbols into the channel and confusilating my x-chat horribly?
15:00:50 <hyrax42_> so at the time I didn't know formally any english grammar
15:00:52 <hyrax42_> no
15:00:54 <hyrax42_> well I could
15:00:59 <hyrax42_> except I dont' have an arabic keyboard
15:01:01 <hyrax42_> ;)
15:01:12 <SamB> what, they have special keyboards?
15:01:26 <hyrax42_> with arabic symbols on it?
15:01:30 <SamB> (other than having more stuff on the caps?)
15:01:34 <glguy> hyrax42_: "I'm mother-tongue english" seems like a contradiction (unless I just don't know what mother-tongue means)
15:01:59 <hyrax42_> I never used computers in arabic so I don't know the locations
15:02:04 <hyrax42_> and I don't have the keymap installed either
15:02:10 <glguy> I want to learn arabic because all of the characters in the unicode character viewer look so pretty :)
15:02:12 <hyrax42_> glguy, means first language?
15:02:28 <Cale> "My mother tongue is English"
15:02:29 <hyrax42_> glguy, a lot of those are just ligatures
15:02:33 <SamB> glguy: as opposed to "live-in-england english"?
15:02:34 <hyrax42_> which *shouldn't* be in unicode
15:02:51 <glguy> Cale understood
15:02:59 <SamB> hyrax42_: eek
15:03:15 <hyrax42_> there are only 28 *letters* in arabic
15:03:23 <hyrax42_> but with initial, medial and final forms for most
15:03:24 <SamB> so what are the ligatures doing there?
15:03:29 <SamB> can they not be inferred?
15:03:29 <Etni3s> grrrrr... trying to compile lambdabot 1.0 gives me this: MkProg: Can't find module GHC.Posix in user directories
15:03:35 <hyrax42_> the choice of forms should be decided by the typesetter
15:03:43 <SamB> okay.
15:03:51 <fasta> Etni3s: you did read the README, right?
15:03:57 <Etni3s> yes
15:03:59 <SamB> so probably one of these days there *won't* be all those ligatures in unicode
15:04:06 <hyrax42_> samB, sure...
15:04:08 <Etni3s> that's where i copied the command to compile it all from lol
15:04:09 <Etni3s> ^^
15:04:40 <hyrax42_> although nowt that I think on it, are the ff ffi ffl ct st etc. ligatures in unicode?
15:04:47 <SamB> I hope not
15:04:52 <SamB> I don't think so.
15:05:11 <kpreid> They are, but deprecated.
15:05:12 <kpreid> IIRC.
15:05:15 <SamB> oh
15:05:20 <SamB> thats not so nice
15:05:31 <hyrax42_> how does a typesetting system know then whyere to look for ligatures
15:05:38 <hyrax42_> oh never mind
15:05:39 <kpreid> SamB: Well, Unicode aims to incorporate all legacy character sets.
15:05:40 <hyrax42_> stupid question
15:05:47 <SamB> it should look in the font metrics, duh!
15:05:50 <glguy> What replaces the ff ligature?
15:06:07 <hyrax42_> samB, yeah that's what I realised
15:06:16 <SamB> kpreid: well I meant probably it will be suggested to ignore them or something
15:06:40 <SamB> glguy: f and f?
15:06:48 <hyrax42_> samb, http://www.unicode.org/charts/
15:06:49 <lambdabot> Title: Code Charts - Scripts
15:07:14 <SamB> why do I want to look at the code charts?
15:07:39 <hyrax42_> I would call most of the basic ones there "Arabic" allowable
15:08:09 <hyrax42_> but the presentational forms are not so
15:08:59 <hyrax42_> almost all are roughly analogous to ff
15:10:04 <SamB> really? not more like, say, the lines joining letters in cursive?
15:10:42 <hyrax42_> oh haha... even to the poing of including single characters for: allah, muhammed, akbar, "in the name of god most merciful most gracious", and a couple of others like that
15:11:14 <SamB> eeeeek
15:11:27 <SamB> sounds like some kind of RPG or something!
15:12:05 <SamB> (I think they tend to do roughly analogous things in order to save space. Well, or did in the days when memory didn't grow on trees.)
15:12:24 <hyrax42_> all of FBEA onwards are 2-letter combinations
15:13:23 <hyrax42_> that are sort of special cases for those letters.. you could also write them the "normal" way
15:14:23 <SamB> hmm
15:14:39 <SamB> is it a coincidence that I don't seem to have glyphs for FBEA and above?
15:14:58 <SamB> at least, not except a few scattered ones
15:15:33 <hyrax42_> probably not?
15:15:42 <hyrax42_> I didn't see them in Ariel either
15:15:57 <SamB> honestly I don't know what font everything is in
15:16:04 <SamB> this thing does character substitution
15:16:08 <SamB> to some extent
15:16:29 <hyrax42_> this thing =?
15:16:48 <SamB> I'm unsure which components do what
15:16:58 <hyrax42_> anyway, to close that tangent, we can agree that single characters for allah etc. don't really belong in unicode
15:16:58 <SamB> GNOME Character Mapper
15:17:05 <SamB> yeah!
15:17:30 <SamB> maybe font formats need ways to talk about things like that though
15:17:54 <hyrax42_> likely
15:17:56 <hyrax42_> beyond my ken
15:20:35 <jgrimes> wow, now that I am starting to understand monads I feel like I have been missing out on so much... =/
15:20:45 <hyrax42_> :)
15:21:41 <hyrax42_> jgrimes, what have you been reading?
15:22:04 <jgrimes> hyrax42_, All About Monads, for like the 3rd time
15:22:13 <jgrimes> but it clicked this time
15:22:20 <hyrax42_> have you read Cale's Monads as Containers?
15:22:24 <hyrax42_> @where monads as containers
15:22:25 <lambdabot> http://www.nomaware.com/monads/html/index.html
15:22:29 <hyrax42_> doh
15:22:33 <hyrax42_> not that
15:22:40 <jgrimes> yeah, I looked at it
15:23:04 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers :)
15:23:07 <lambdabot> Title: Monads as Containers - HaskellWiki, http://tinyurl.com/llgo9
15:23:19 <hyrax42_> between the two, I picked up enough
15:23:21 <hyrax42_> eventually
15:23:49 <hyrax42_> Cont is the only one that still is a big ?
15:23:53 <hyrax42_> well I won't say only
15:24:10 <hyrax42_> but it's a really big ? compared to anything else
15:25:33 <jgrimes> well, I've got Writer and State to a level where I can get some benefit from them, since those solve a lot of my problems
15:25:45 <hyrax42_> RWS ftw
15:25:46 <hyrax42_> ;)
15:26:27 <hyrax42_> ?type mapM
15:26:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
15:26:55 <hyrax42_> ok good, that's what I thought
15:29:03 <hyrax42_> ?instanecs MonadPlus
15:29:04 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
15:29:52 <hyrax42_> ?type sequence
15:29:54 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
15:30:50 <hyrax42_> are mapM and sequence.map the same?
15:31:23 <Igel> hi there
15:31:31 <kpreid> hyrax42_: yes
15:31:45 <Igel> i'm currently looking for a way to do precise calculations
15:32:00 <Igel> more presice than with Double :)
15:32:09 <Igel> and i found Ratio Integer Integer
15:32:12 <dcoutts> @seen waern
15:32:13 <lambdabot> I saw waern leaving #haskell.se and #haskell 1h 11m 34s ago, and .
15:32:17 <SamB> Igel: yeah?
15:32:33 <Igel> but i'm lacking some operations
15:32:48 <Igel> for example there is no exp function for Ratio Integer
15:33:00 <Igel> is there some sort of api for that?
15:33:03 <hyrax42_> as in e^?
15:33:10 <astrolabe> http://lukeplant.me.uk/blog.php?id=1107301645
15:33:13 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
15:33:23 <hyrax42_> that's because e is irrational, and not representable as a raio
15:34:02 <Igel> well thats an argument...
15:34:20 <hyrax42_> that is correct...
15:34:21 <hyrax42_> ;)
15:34:32 <Igel> the thing is, i need a precision, where (sin pi) is 1 again :)
15:34:43 <Igel> but i need all commen operations
15:34:43 <hyrax42_> not goig to happen
15:34:57 <hyrax42_> except if you have special cases
15:35:01 <astrolabe> Igel: Which operations do you need?
15:35:04 <hyrax42_> also
15:35:06 <hyrax42_> sin pi is 0
15:35:10 <hyrax42_> so actually
15:35:13 <hyrax42_> not going to happen
15:35:14 <hyrax42_> period
15:35:32 <hyrax42_> :p
15:35:49 <hyrax42_> > sin 3.141592653589793238462643383
15:35:50 <lambdabot>  1.2246063538223773e-16
15:35:52 <Igel> atrolabe: exponential function, (sqare-) roots trigonometric functions logarithms and of course +-*/
15:36:47 <astrolabe> Igel: and then you want == or something?
15:37:01 <Igel> atrolabe no, i don't need that
15:37:09 <hyrax42_> what you're looing for doesn't make (type) sense
15:37:33 <astrolabe> Igel: From what you've said, you could just use the parse tree structure
15:37:46 <hyrax42_> unless it's acceptable to return a non-ratio
15:38:12 <Igel> atrolabe: that's actually what i'm doing
15:39:05 <astrolabe> Igel: So what is your problem?
15:39:15 <Igel> but i can't distinguish all those special cases, where sin, cos, ln, exp or whatever have a special value
15:39:29 <Igel> i need more presice calculations than just Double^^
15:39:40 <SamB> > sin pi
15:39:41 <lambdabot>  1.2246063538223773e-16
15:39:44 <SamB> eek!
15:39:47 <SamB> > cos 0
15:39:48 <astrolabe> What is a special value?
15:39:48 <lambdabot>  1.0
15:39:51 <Igel> thats what i ment^^
15:39:55 <SamB> > cos pi
15:39:55 <lambdabot>  -1.0
15:39:58 <SamB> hmm
15:40:03 <astrolabe> But that is only special if you use ==
15:40:19 <SamB> don't use sin, it is too inaccurate!
15:40:25 <astrolabe> ie  cos pi == 1
15:40:31 <SamB> or should I say too accurate
15:40:34 <Igel> astrolabe: a special value would be like sin pi: 0 and not 1.22...e-16
15:40:51 <astrolabe> You mean sin pi == 0?
15:40:58 <SamB> > sin pi == 0
15:40:59 <lambdabot>  False
15:41:04 <SamB> > cos pi == 1
15:41:05 <lambdabot>  False
15:41:07 <SamB> > cos pi == -1
15:41:08 <lambdabot>  True
15:41:27 <SamB> > cos (pi/2)
15:41:28 <lambdabot>  6.123031769111886e-17
15:41:30 <SamB> hmm
15:41:39 <SamB> > sin (pi/2)
15:41:39 <x3m> > sin pi
15:41:40 <lambdabot>  1.0
15:41:41 <lambdabot>  1.2246063538223773e-16
15:41:45 <Igel> see what i mean?
15:42:14 <SamB> Igel: you were hoping for infinite precision?
15:42:19 <x3m> Sin pi is 0
15:42:35 <SamB> > sin 0
15:42:36 <lambdabot>  0.0
15:42:52 <Igel> SamB: i was hoping for definable presision, like 10^-10
15:43:01 <Igel> or 10^-100
15:43:02 <SamB> > map (sin &&& cos) [0,pi/2..2*pi]
15:43:04 <lambdabot>  [(0.0,1.0),(1.0,6.123031769111886e-17),(1.2246063538223773e-16,-1.0),(-1.0,-...
15:43:13 <astrolabe> arbitrary precision
15:43:18 <SamB> you can get that
15:43:21 <astrolabe> You can get that
15:43:22 <SamB> try MAXIMA or something
15:43:23 <astrolabe> :)
15:43:30 <Igel> what is that?
15:43:35 <SamB> CAS
15:44:22 <astrolabe> In fact, haskell might be well suited to arbitray precision because of it's lazy evaluation.
15:44:33 <astrolabe> *its
15:45:06 <Igel> i thought that, too - so i asked here :)
15:45:52 <Igel> but i don't feel like implementing every single operation myself ;)
15:46:17 <SamB> well, I don't remember anyone claiming to have done it
15:46:30 <musasabi> Haskell has arbitrary precision rational numbers.
15:47:03 <Igel> musasabi: where?
15:47:14 <SamB> Igel: you found 'em already
15:47:25 <SamB> they aren't Floating, so you don't want them
15:47:30 <SamB> @instances Floating
15:47:30 <lambdabot> Double, Float
15:47:44 <musasabi> Igel: Rational.
15:48:12 <Igel> that's weird: Rational Integer is more precise than Double, yet you may not pass then to exp...
15:48:12 <musasabi> Igel: see Data.Ratio
15:48:43 <Igel> musasabi: the thing is, that Ratio has ne exponetial or trigonometric functions :(
15:49:07 <SamB> Igel: you want a Floating type, yes
15:50:08 <astrolabe> He could make his own based on Rational
15:50:10 <musasabi> Igel: trigonometric functions can produce irrational numbers.
15:50:24 <musasabi> iirc
15:50:40 <astrolabe> Yes they can.
15:50:52 <Igel> if you have an infinite list of e.g. Integers, you can also "take" the first n elements
15:51:07 <Igel> i need something like this for post-comma-digits
15:51:25 <musasabi> Thus you cannot have trigonometric functions for Rational.
15:51:30 <lisppaste2> lispy pasted "Slow number parsers (how to speedup?)" at http://paste.lisp.org/display/27429
15:52:05 <lispy> any suggestions on making those parsers go faster? it's where my program is spend all of its time and allocation
15:52:08 <astrolabe> musasabi: how about a list of rationals, being increasingly accurate approximations to the desired number.
15:52:48 <lisppaste2> lispy annotated #27429 with "the profile results" at http://paste.lisp.org/display/27429#1
15:52:49 <musasabi> astrolabe: how would Eq be defined?
15:52:59 <astrolabe> or maybe a function Integer -> Rational, which takes a required accuracy.
15:53:20 <musasabi> astrolabe: I think a more formal way to express it is needed if exact results are wanted.
15:53:26 <SamB> astrolabe: huh?
15:53:29 <dibblego> @paste
15:53:29 <lambdabot> http://paste.lisp.org/new/haskell
15:53:29 <astrolabe> musasabi: point.  You can only define equality up to a given accuracy.
15:53:54 <SamB> how about a list of Doubles that add up to the desired amount?
15:53:59 <SamB> I think that method actually works...
15:54:04 <astrolabe> [23:44] Igel: SamB: i was hoping for definable presision, like 10^-10
15:54:32 <lisppaste2> dibblego pasted "dmwit: did you mean this yesterday?" at http://paste.lisp.org/display/27430
15:54:46 <astrolabe> SamB: they don't have arbitrary accuracy.
15:55:02 <SamB> they *add up* to the desired amount
15:55:22 <astrolabe> what if the desired amount is 10^(-100000)?
15:55:36 <SamB> point
15:55:40 <lispy> ya know, none of my numbers have a +/- sign, might as well rip that out and see if it speeds things up a tiny bit
15:56:03 <SamB> lispy: what are you up to?
15:56:22 <lispy> SamB: http://paste.lisp.org/display/27429
15:56:25 <lispy> parsing numbers
15:56:29 <lispy> oh i should give some example input
15:57:10 <lisppaste2> lispy annotated #27429 with "example input" at http://paste.lisp.org/display/27429#2
15:58:09 <SamB> eeeeeek
15:58:15 <SamB> those columns are wiggly!
15:58:24 <lispy> yeah...that's just a problem with the paste
15:58:31 <lispy> in the real file they are not wiggly :)
15:58:40 <SamB> duh!
15:58:48 <lispy> :)
15:59:00 <SamB> *real* monospace text *doesn't* wiggle at the pixel level!
16:00:12 <twanvl> Have you tried specialize pragmas?
16:00:20 <lispy> twanvl: such as?
16:00:28 <lispy> twanvl: basically no i haven't
16:01:25 <lispy> twanvl: http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/pragmas.html ?
16:01:27 <lambdabot> Title: 7.9. Pragmas, http://tinyurl.com/kb6m4
16:02:11 <twanvl> yes, those
16:02:32 * lispy reads up
16:03:51 <SamB> SUPERSPECIALIZE is even better ;-P
16:03:53 <Yagi> booh
16:04:05 <SamB> unfortunately that is a JHC-only features :-(
16:04:13 <SamB> s/features/feature/
16:06:26 <lispy> i think converting my Integral a => a to Int is probably wise
16:06:44 <lispy> i'm tempted to corvert Double to Float until the value is returned as well
16:06:50 <lispy> since the file out gives a few decimal places
16:09:49 <SamB> hey, you never told me if this was for a trip planner for IF or not, did you?
16:11:38 <lispy> SamB: are you talking to me?
16:11:43 <SamB> yes!
16:11:53 <lispy> okay, i have no idea what you're talking about :)
16:11:56 <lispy> IF?
16:12:00 <lispy> trip planner?
16:12:12 <lispy> the output file was generated by Vissim
16:12:25 <SamB> the directions look like IF directions!
16:12:37 <lispy> the movements?
16:12:52 <lispy> RULES looks like they might be useful here
16:13:01 <lispy> if i could figure out a way to apply them
16:24:55 * SamB wishes for a -fwarn-unused-toplevel-binds:
16:25:59 <weitzman> That sounds like a feature for DrHaskell
16:27:42 <SamB> weitzman: I actually meant for GHC
16:28:00 <SamB> it has -fwarn-unused-binds, but I imagine that would be a bit too noisy...
16:28:01 <lispy> SamB: i think you get that with -Wall -Werror and then explititly export things
16:28:09 <lispy> ah
16:28:26 <SamB> because it doesn't only warn about toplevel bindings, according to the documentation
16:28:29 <lispy> SamB: well, you can per identifier turn off -fwarn-unused-binds by putting _ at the end of the name
16:28:41 <lispy> just a thought
16:28:44 <lispy> but you're right
16:29:07 <SamB> okay so where do I go to add it to the wishlist?
16:31:04 <Igloo> File a bug, although I think there's already one along those lines
16:31:10 <Igloo> It might be the other way round, though
16:31:11 <SamB> oh.
16:31:19 <Igloo> s/bug/feature/
16:31:24 <SamB> what do you mean -- other way round?
16:31:28 <SamB> you don't file a "feature"
16:31:47 <SamB> you file a "feature request" or something like that
16:31:57 <Pseudonym> You do file undocumented features.
16:31:59 <Igloo> Warning about unused non-top-level binds
16:32:03 <SamB> Pseudonym: heh
16:32:10 <SamB> Igloo: oh.
16:34:23 <SamB> http://hackage.haskell.org/trac/ghc/ticket/17
16:34:25 <lambdabot> Title: #17 (RFE:Separate unused-binds local/top-level) - GHC - Trac
16:34:38 <SamB> someone should mention -fwarn-unused-binds
16:35:20 <Igloo> That looks like the one I'm thinking of
16:35:32 <SamB> indeed it does
16:35:33 <Igloo> I assume he knows about -fwarn-unused-binds, given he's wishing for it to be split in 2...
16:35:38 <SamB> and it is *both* ways
16:35:42 <SamB> Igloo: I assume so too
16:35:53 <SamB> but it would be much easier to find if it had that on it somewhere
16:42:05 <SamB> okay, I added that as a keyword ;-)
16:43:10 <dibblego> if I invoke an expensive function or an infinite one in ghci, how do I tell it to stop?
16:43:17 <SamB> ^C!
16:43:25 <SamB> if that doesn't work, kill the terminal!
16:43:30 <dibblego> that sucks
16:43:33 <dibblego> ^C never works
16:44:44 <Xgc> kill -9 -1  # works best as root, (but don't)
16:45:12 <SamB> -1?
16:45:22 <Xgc> All your own processes. :)
16:45:23 <Igloo> dibblego: Are you on Windows?
16:45:25 <mauke> technically, you should use ^Z to stop it :-)
16:45:26 <SamB> hah
16:45:37 <dibblego> Igloo, Linux
16:45:41 <SamB> mauke: that doesn't cause an exception, though!
16:45:45 <Igloo> Oh, then ^C should work
16:45:52 <dibblego> doesn't
16:46:01 <SamB> dibblego: patience young padawan!
16:46:16 <dibblego> I kill the terminal before patience
16:46:34 <mauke> whoa, you can always killall ghci
16:46:58 <dibblego> then I lose certain things
16:47:04 <dibblego> same with killing the terminal
16:47:08 <dibblego> it's just a pain - never mind
16:47:20 <SamB> well, try to wait longer after ^C before giving up
16:47:27 <dibblego> 30 seconds not enough?
16:47:32 <SamB> sometimes accumulated output must filter through the terminal...
16:50:47 <mauke> ^Z, then kill %1
16:54:00 <jaymz> just started playing around with a haskell tutorial, and i'm getting this error:
16:54:14 <jaymz> Could not find module `Message':
16:54:56 <jaymz> actually - this is the "real" error:
16:55:19 <jaymz> jaymzbot.hs:41:43: Not in scope: `privmsg'
16:56:02 <jaymz> i'm not sure what module i need
16:56:05 <dibblego> jaymz, you could post the code
16:56:42 <dons> jaymz: sounds like you're missing some code from the tutbot? :)
16:56:48 <jaymz> yeah
16:56:58 <jaymz> eval :: Handle -> String -> IO ()
16:57:04 <dons> why not grab the full source from the web site.?
16:57:05 <jaymz> eval h    "!quit"                = write h "QUIT" ":Exiting" >> exitWith ExitSuccess
16:57:23 <jaymz> dons, oh ...
16:58:06 <dons> here, http://haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
16:58:09 <lambdabot> Title: Roll your own IRC bot/Source - HaskellWiki, http://tinyurl.com/fdzc5
17:02:41 <dibblego> do most people use hierarchical imports?
17:03:41 <SamB> to import heirarchical modules? yes!
17:03:47 <jgrimes> :p
17:03:54 <dibblego> when defining modules
17:04:15 <MarcWeber> Any idea what might cause this error message: Bad interface http://rafb.net/paste/results/xrZBLn37.html ?
17:04:52 <dons> dibblego: only for large projects. I just use a flat name space for apps.
17:05:00 <dons> hier is good for libraries though
17:05:10 <dibblego> right, that's what I;m thinking, thanks
17:07:02 <SamB> occassionally you run into an app worthy of two or three levels of names
17:07:50 <dibblego> dons, I made a couple more edits to your doc
17:08:15 <dibblego> dons, in particular, I added a type to one of the functions that I think you meant - since it was immediately before how doing so is a good idea
17:08:55 <lispy> dons: i could use some optimization suggestions if you have a second
17:09:00 <dibblego> in the IRC bot one that is
17:09:10 <lispy> dons: http://paste.lisp.org/display/27429
17:09:49 <lispy> dons: if you're busy or don't want to look it, that's fine too :)
17:10:29 <dons> dibblego: yeah i saw. thanks.
17:10:57 <dons> looking lispy ..
17:12:37 <dibblego> is there a Natural (number) type?
17:12:58 <jaymz> dibblego, i pasted the code and error here: http://pastebin.com/801066
17:13:10 <abeloso> hiiiii
17:13:13 <abeloso> help help
17:13:18 <SamB> data Nat = Z | Succ Nat deriving (Eq, Ord, Show)
17:14:01 <abeloso> Hi my funcion is DELET SIMILAR
17:14:17 <SamB> what?
17:14:34 <SamB> how do you name it in all caps with a space in the middle of the name?
17:14:45 <abeloso> exam.. Main>deletd [2,4,6,7,2] [2,4,6,7]
17:15:03 <SamB> don't be IRCing during exams!
17:15:10 <SamB> it tends to get you disqualified
17:15:14 <abeloso> jaja noo exman
17:15:16 <abeloso> example
17:15:25 <mauke> > (\\) [2,4,6,7,2] [2,4,6,7]
17:15:26 <lambdabot>  [2]
17:15:33 <abeloso> lo hice asi
17:15:41 <abeloso> eliminard ::[Int] -> [Int]
17:15:41 <abeloso> eliminard [] = []
17:15:41 <abeloso> eliminard (x:xs)
17:15:41 <abeloso> 		|x /= x eliminard xs = x:eliminard xs
17:15:51 <abeloso> no found :(
17:15:52 <SamB> oh great
17:16:00 <dibblego> SamB, what is Z?
17:16:09 <SamB> oh.
17:16:10 <SamB> sorry.
17:16:14 <SamB> data Nat = Z | Succ Nat deriving (Eq, Ord, Show)
17:16:16 <SamB> ack
17:16:21 <SamB> data Nat = Zero | Succ Nat deriving (Eq, Ord, Show)
17:16:22 <dons> Zero
17:16:23 <SamB> OR
17:16:31 <SamB> data Nat = Z | S Nat deriving (Eq, Ord, Show)
17:16:36 <dibblego> do most of you guys write such a type?
17:16:45 <SamB> for fun? sure.
17:16:51 <dibblego> well, if you need it
17:16:53 <SamB> for real use? no...
17:17:04 <SamB> what would we need it for?
17:17:05 <dons> jaymz: I can see a couple of errors.
17:17:14 <dons> you seem to have missed the indening on 'where' on 38.         where
17:17:17 <dibblego> for something that only uses natural numbers
17:17:23 <abeloso> help
17:17:24 <SamB> you could try Word
17:17:25 <abeloso> pls
17:17:27 <dibblego> the age of a person
17:17:32 <dons> jaymz: and the bottom of the file is misssing...
17:17:39 <lispy> dons: let me know if have ideas...i'm at the point where i think i'll stop optimizing until someone says it's slow
17:17:51 <dons> jaymz: try getting the original source from here http://haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
17:17:54 <lambdabot> Title: Roll your own IRC bot/Source - HaskellWiki, http://tinyurl.com/fdzc5
17:17:54 <dibblego> ?type Zero
17:17:56 <lambdabot> Not in scope: data constructor `Zero'
17:18:35 <dons> jaymz: I see you're trying to paste it together. you can do that, but you'll have to be careful about the layout. check the final source as a guide, perhaps
17:18:41 <SamB> dibblego: Word is to Int as unsigned int is to int (in practice)
17:18:46 <dons> lispy: ok.
17:19:04 <SamB> (but of course there is no implicit casting)
17:19:52 <dibblego> that data declaration declares a type called Nat with two constructors: Zero and Succ Nat right?
17:20:09 <dons> ?uptime
17:20:09 <lambdabot> uptime: 6d 1h 26m 9s, longest uptime: 6d 1h 26m 9s
17:20:15 <dons> ?users
17:21:29 <lispy> dons: i think it's as fast as it will get until we have a parsec+bytestring
17:21:30 <lambdabot> seen module failed: IRCRaised thread killed
17:21:32 <dibblego> that command is broken
17:21:39 <dons> ?users
17:21:42 <lispy> dons: or maybe i could just use alex, but that involves learning :)
17:21:44 <lambdabot> Maximum users seen in #haskell: 241, currently: 214 (88.8%), active: 31 (14.5%)
17:21:50 <dibblego> it shows a maximum seen that is less than the current (for me)
17:22:00 <dons> alex is pretty easy to use though
17:22:06 <dibblego> (than the actual current)
17:22:24 <lispy> dons: but is it faster/less memory hogging than parsec do you think?
17:22:35 <dons> certainly.
17:22:42 <abeloso> ?users
17:22:43 <lambdabot> Maximum users seen in #haskell: 241, currently: 214 (88.8%), active: 31 (14.5%)
17:22:44 <lispy> hmm...
17:22:45 <abeloso> ?haskkell
17:22:45 <lambdabot> Unknown command, try @list
17:22:49 <abeloso> :S
17:22:51 <lispy> okay, i'll go cehck it out
17:22:57 <dons> > map (+1) [1..10]
17:22:59 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
17:23:05 <dons> ?type map
17:23:06 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
17:23:16 <dibblego> Maximum users seen in #java: 12, currently: 3 (25.0%), active: 1 (33.3%) -- there are actually 25 currently
17:23:22 <abeloso> lenght [2,4,5,6,7,8]
17:23:25 <abeloso> > lenght [2,4,5,6,7,8]
17:23:26 <lambdabot>  Not in scope: `lenght'
17:23:29 <abeloso> > length [2,4,5,6,7,8]
17:23:31 <lambdabot>  6
17:23:35 <abeloso> :O
17:23:35 <dons> interesting
17:23:53 <lispy> oh and was there an bytesting-ified version of alex now?
17:23:58 <dons> dibblego: i've not seen it off by more than 1 or 2 before
17:24:11 <dibblego> dons, it's probably related to my broken install
17:24:12 <lispy> oh wait, alex is just lex, huh?
17:24:30 <dons> its' just a lexer, yes.
17:24:37 <dons> you'd use it with happy or parsec
17:24:46 <abeloso> > ord 'a'
17:24:47 <lambdabot>  97
17:24:49 <dons> unless the problem is really simple
17:24:50 <abeloso> > ord 'A'
17:24:51 <lambdabot>  65
17:24:59 <lispy> dons: well, you saw the input file right?
17:25:08 <lispy> it's mostly semicolon delimited
17:25:19 <lispy> but maybe too much for just a lexer
17:25:30 <dons> hmm. might be close
17:25:36 <dons> if its not nested, aex might be able to handle it
17:25:51 <dons> can you hack it with regexes? if so, alex can do it.
17:26:28 <lispy> yeah, could probably do it with regexes
17:27:13 <lispy> other than the header (which who cares about, I might as well keep using parsec) it's just numbers, strings (without quotes), whitespace and semicolons
17:27:30 <lispy> the harderst part is probably that the order and number of columns changes
17:28:33 <dibblego> is the documentation on haskell.org generated by haddock?
17:28:47 <ThreeQ> why isn't there a generic collection typeclass?
17:29:05 <ThreeQ> it seems weird to me that you have to say X.map, X.empty, X.singleton, X.delete...
17:29:05 <abeloso> add funcion command?????
17:29:07 <abeloso> add funcion command?????
17:29:23 <ThreeQ> despite the fact that haskell could figure out what you meant itself
17:29:33 <abeloso> > help
17:29:33 <lambdabot>  Not in scope: `help'
17:29:42 <abeloso> > :e
17:29:43 <lambdabot>  Parse error
17:29:45 <abeloso> jajaj
17:29:47 <abeloso> > :r
17:29:48 <lambdabot>  Parse error
17:29:55 <abeloso> > :l
17:29:55 <lambdabot>  Parse error
17:30:15 <ThreeQ> @help
17:30:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:30:18 <dibblego> > "give it a rest abeloso"
17:30:19 <lambdabot>  "give it a rest abeloso"
17:30:24 <dons> ?help run
17:30:24 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
17:30:35 <abeloso> @help
17:30:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:30:37 <abeloso> @help add
17:30:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:30:40 <SamB> @help >
17:30:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:32:00 <ventonegro> @help me help you
17:32:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:32:06 <abeloso> help
17:32:20 <abeloso> errror ? for?-> |x /= x eliminard xs = x:eliminard xs
17:32:28 <ventonegro> @help, i need somebody, help
17:32:28 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:32:44 <SamB> @help, I've fallen and I can't get up!
17:32:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:32:49 <abeloso> error ? for?-> |x /= x eliminard xs = x:eliminard xs
17:33:46 <ThreeQ> abeloso: what are you trying to do?
17:34:18 <abeloso> my funcion is deled numero repet
17:34:19 <dibblego> when I use haddock with -h I get HTML output, but without -h I can't find any output at all - where should it be?
17:34:52 <abeloso> ThreeQ example delet [1,2,3,4,4,5] -> retum [1,2,3,4,5]
17:35:08 <ThreeQ> oh
17:35:43 <glguy> > num  [1,2,3,4,4,5]
17:35:44 <lambdabot>  Not in scope: `num'
17:35:46 <glguy> > nub  [1,2,3,4,4,5]
17:35:48 <lambdabot>  [1,2,3,4,5]
17:35:52 <abeloso> nub?
17:35:52 <abeloso> :O:O
17:35:53 <mauke> ?type map head . group
17:35:53 <abeloso> :O:O
17:35:55 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:36:01 <glguy> mauke: map head . group . sort
17:36:06 <ThreeQ> delete [] = []
17:36:08 <ThreeQ> delete x:y:xs | x == y  = x : delete xs
17:36:09 <mauke> glguy: why sort?
17:36:18 <ThreeQ> delete x : xs = x : delete xs
17:36:25 <glguy> mauke: because he didn't specify that it was always sorted (unless he did)
17:36:35 <mauke> he said he wants to remove repeated numbers
17:36:36 <ThreeQ> or use nub
17:36:43 <ThreeQ> :)
17:37:02 <mauke> ok, it depends on your definition of "repeat"
17:37:30 <glguy> mauke: or one's ability to make out words
17:39:01 <ski> > let del [] = []; del (x:y:xs) | x == y = x : del xs; del (x:xs) = x : del xs in del [1,2,2,2,3]
17:39:03 <lambdabot>  [1,2,2,3]
17:39:13 <ski> ThreeQ : ^^
17:39:36 <ThreeQ> oh whoops
17:39:58 <ThreeQ> del (x : xs) i mean
17:40:01 <ThreeQ> instead of x : del xs
17:40:42 <ThreeQ> > let del [] = []; del (x:y:xs) | x == y = del (x : xs); del (x:xs) = x : del xs in del [1,2,2,2,3
17:40:43 <lambdabot>  Parse error
17:40:51 <ThreeQ> > let del [] = []; del (x:y:xs) | x == y = del (x:xs); del (x:xs) = x : del xs in del [1,2,2,2,3]
17:40:52 <lambdabot>  [1,2,3]
17:42:14 <abeloso> > let
17:42:14 <lambdabot>  Parse error
17:42:47 <abeloso> nub [1,5,4,5]
17:42:50 <abeloso> > nub [1,5,4,5]
17:42:51 <lambdabot>  [1,5,4]
17:43:04 <glguy> > let a # (b:bs) | a == b = a:bs | otherwise = a:b:bs; a#[]=[a] in foldr (#) [] [1,2,3,3,3,4,4,5]
17:43:06 <lambdabot>  [1,2,3,4,5]
17:44:03 <ventonegro> > map (flip take (cycle "help")) [1..]
17:44:05 <lambdabot>  ["h","he","hel","help","helph","helphe","helphel","helphelp","helphelph","he...
17:44:15 <glguy> > let a # (b:bs) | a == b = a:bs | otherwise = a:b:bs; a#[]=[a] in foldr (#) [] $ (\x -> [x,x]) =<< [0..]
17:44:19 <lambdabot> Terminated
17:44:31 <ski> > inits (flip take (cycle "help"))
17:44:31 <lambdabot>    Expecting a function type, but found `[a]'
17:44:32 <lambdabot>    Expected type: [a]
17:44:32 <lambdabot>   ...
17:44:40 <ski> > inits (cycle "help")
17:44:41 <lambdabot>  ["","h","he","hel","help","helph","helphe","helphel","helphelp","helphelph",...
17:44:43 <lispy> > scanl (:) (cycle "help")
17:44:43 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
17:44:44 <lambdabot>    Expected...
17:44:48 <lispy> ?type scanl
17:44:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:45:07 <glguy> > scanr (:) (cycle "helped ")
17:45:09 <lambdabot>  <[Char] -> [[Char]]>
17:45:12 <lispy> > scanl (:) ' ' (cycle "help")
17:45:13 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
17:45:13 <lambdabot>    Expected...
17:45:14 <glguy> > scanr (:) "" (cycle "helped ")
17:45:15 <lambdabot>  ["helped helped helped helped helped helped helped helped helped helped help...
17:45:42 <glguy> lispy: inits?
17:45:59 <glguy> > inits [1..5]
17:46:01 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
17:46:11 <ventonegro> what does inits do?
17:46:27 <ventonegro> that's why i like to type my musings here...
17:46:44 <glguy> > tails [1..5]
17:46:45 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
17:46:58 <abeloso> > del [1,2,5,5,5,5,5,3]
17:46:59 <lambdabot>  Not in scope: `del'
17:47:21 <abeloso> > let a # (b:bs) | a == b = a:bs | otherwise = a:b:bs; a#[]=[a] in foldr (#) [] [1,2,3,3,3,4,4,5]
17:47:23 <lambdabot>  [1,2,3,4,5]
17:47:29 <deadbeef> a clock never showing right time could be preferable than a one showing right time twice a day
17:48:36 <ventonegro> confucius? :-)
17:49:42 <deadbeef> yes
17:49:49 <deadbeef> confucius - the art of lambda calculus
17:50:53 <abeloso> one bot lambdabot site download is?
17:51:10 <dons> ?source
17:51:10 <lambdabot>  not available
17:51:14 <dons> ?version
17:51:14 <lambdabot> lambdabot 4p233, GHC 6.5 (OpenBSD i386)
17:51:15 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:51:17 <dons> ^^
17:51:20 <abeloso> :O
17:51:23 <abeloso> :D 10x
17:51:38 <abeloso> > foldr
17:51:39 <lambdabot>  Add a type signature
17:52:17 <glguy> > scanl ((++) . return)[] (cycle "like this? ")
17:52:18 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
17:52:18 <lambdabot>    Expected...
17:52:46 <glguy> > scanl (a b -> a ++ [b])[] (cycle "like this? ")
17:52:47 <lambdabot>  Parse error
17:52:53 <glguy> > scanl (\a b -> a ++ [b])[] (cycle "like this? ")
17:52:54 <lambdabot>  ["","l","li","lik","like","like ","like t","like th","like thi","like this",...
17:53:53 <glguy> > scanl (flip (:))[] (cycle "like this? ")
17:53:54 <lambdabot>  ["","l","il","kil","ekil"," ekil","t ekil","ht ekil","iht ekil","siht ekil",...
18:00:15 <Bobstopper> Is anyone around who might be able to debug errors produced by as during compilation using ghc?
18:00:36 <SamB_XP> are they big or small?
18:00:56 <Bobstopper> Lots of errors:
18:00:58 <Bobstopper> http://paste.lisp.org/display/27385
18:01:17 <dibblego> does haddock allow a URL that the text is not the URL itself?
18:01:42 <user317> how is sequence implemented?
18:02:17 <lispy> > scanl (:) "" (cycle "help")
18:02:18 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
18:02:18 <lambdabot>    Expected...
18:02:27 <lispy> ?type scanl (:)
18:02:28 <Bobstopper> I've gotten ghc's asm output for analysis too... only I'm not very knowledgable about asm.
18:02:28 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:02:28 <lambdabot>    Expected type: a -> [a] -> a
18:02:48 <lispy> ?type scanl (:) ' ' "blah"
18:02:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:02:50 <lambdabot>    Expected type: a -> [a] -> a
18:02:57 <Igloo> Bobstopper: Can you put the asm up too please?
18:02:58 <lispy> ?type scanl (:) ' '
18:02:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:03:00 <lambdabot>    Expected type: a -> [a] -> a
18:03:12 <mauke> sequence = foldr (liftM2 (:)) (return [])
18:03:24 <SamB> Bobstopper: don't try to analyse GHC's asm
18:03:25 <Bobstopper> sure, one sec
18:05:24 <user317> gagr,
18:05:36 <user317> mauke thats confusing
18:05:57 <mauke> no, it isn't!! (what part are you having problems with?)
18:05:57 <dons> sequence ms = foldr k (return []) ms
18:05:58 <dons>         where
18:05:58 <dons>           k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:06:39 <user317> mauke, i dont get why sequence [[1,2], [4,5]] gives me the cross product
18:06:58 <abeloso> paresImpares [10,12,13,14,4,7] => ([10,12,14,4], [13,7])
18:06:59 <glguy> > [ [a,b] | a <- [1,2] , b <- [4,5] ]
18:07:00 <lambdabot>  [[1,4],[1,5],[2,4],[2,5]]
18:07:14 <mauke> user317: because of the way >>= is defined for lists
18:07:21 <glguy> abeloso: partition
18:07:28 <SamB> Bobstopper: um.
18:07:39 <user317> mauke, but you are not calling >>=
18:07:49 <abeloso> glguy partition in pares
18:07:54 <SamB> why aren't you building natively?
18:08:02 <glguy> abeloso: pares?
18:08:08 <dons> user317: sequence is calling >>= when you see do { x <- m; xs <- m'; return (x:xs) }
18:08:13 <dons> ?undo do { x <- m; xs <- m'; return (x:xs) }
18:08:13 <lambdabot> m >>= \ x -> m' >>= \ xs -> return (x : xs)
18:08:18 <glguy> > partition even [10,12,13,14,4,7]
18:08:19 <lambdabot>  ([10,12,14,4],[13,7])
18:08:21 <kpreid> user317: liftM2 and do are defined in terms of >>=
18:08:25 <dons> there's your cross product/list >>= thingies
18:08:34 <abeloso> glguy -> pair / inpar
18:08:35 <user317> kpreid, oh i see
18:08:42 <glguy> abeloso: even / odd?
18:08:46 * SamB goes to old logs
18:08:56 <Bobstopper> The asm file's over 5000 lines. It's a little awkward to paste into lisppaste :)
18:09:00 <abeloso> a function that divive in pair or inpares you have it?
18:09:13 <abeloso> a function that divides in pair or inpares you have it?
18:09:28 <SamB> Bobstopper: but, why WINE?
18:09:28 <Bobstopper> samB: Why aren't I buliding natively? I don't have windows. I'm attempting to do it with wine. What effects might that have?
18:09:30 <glguy> scroll up
18:09:40 <kpreid> @type Data.List.partition
18:09:41 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:09:42 <kpreid> abeloso: it's called partition
18:09:44 <SamB> well, WINE isn't exactly reliable ;-)
18:09:51 <glguy> kpreid: he's not reading, that won't help
18:10:02 <SamB> not that this looks like a WINE problem...
18:10:16 <Bobstopper> Yeah, I know. What problem would you say I'm looking at?
18:11:10 <SamB> well, the assembler seems to be complaining about syntax...
18:11:21 <Igloo> Bobstopper: Give us the first 200 lines or so, then/
18:11:29 <SamB> yeah, that sounds about right
18:11:32 <SamB> as an annotation
18:12:20 <lisppaste2> Bobstopper annotated #27385 with "Problematic ASM" at http://paste.lisp.org/display/27385#1
18:12:26 <lispy> hmm...is the default heap size for the RTS really unlimited?
18:12:36 <Bobstopper> That's some ASM. Wait while I double check that it's for the same hs file...
18:12:40 <dibblego> ?where quickcheck
18:12:40 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
18:12:41 <lispy> my program runs out of memory at 256megs unless i set an RTS option
18:12:50 <SamB> huh
18:13:06 <SamB> (that huh was (or should have been) directed at lispy)
18:13:34 <glguy> lispy: 256mb reminds me of the default
18:13:54 <user317> let seq2 (x:xs) = do y <- x; ys <- sequence xs; return (y:ys)
18:13:55 <abeloso> > mod 20 10
18:13:56 <lambdabot>  0
18:14:00 <abeloso> > mod 2 10
18:14:01 <lambdabot>  2
18:14:02 <lisppaste2> Bobstopper annotated #27385 with "ASM Errors for above ASM" at http://paste.lisp.org/display/27385#2
18:14:13 <abeloso> > mod 3 10
18:14:15 <lambdabot>  3
18:14:17 <abeloso> :S
18:14:23 <Bobstopper> Ok, that's the .hs compilation errors for the above asm
18:14:37 <user317> so, how is >>= defined for a list?
18:15:03 * glguy wonders if it's a full moon tonight
18:15:04 <dibblego> what is the de facto make tool?
18:15:10 <mauke> (>>=) = flip concatMap
18:15:12 <lispy> glguy: the manual disagrees
18:15:19 <lispy> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
18:15:19 <lispy> that's why i ask
18:15:21 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/jqzck
18:15:27 <Igloo> Bobstopper: It looks like your assembler is just broken
18:16:10 <Bobstopper> It's the same one that comes with ghc (in /ghc/ghc-6.4.2/gcc-lib/as.exe )
18:16:21 <Igloo> e.g. the string %% in the error is not in the source
18:16:34 <user317> ah,
18:16:36 <Igloo> But you're running it under wine, right...
18:17:10 <dons> user317:     m >>= k             = foldr ((++) . k) [] m
18:17:15 <Bobstopper> Huh... I thought I checked for double %s before...
18:17:25 <Bobstopper> Yeah, I am.
18:17:35 <Bobstopper> Somehow wine's breaking as.exe, eh?
18:17:42 <user317> dons, you sure like foldr
18:18:00 <dons> I'm showing you the ibrary definitions.
18:18:18 <dons> mauke is using slightly more obfuscated versions, imo.
18:18:28 <SamB> is that some new apple product?
18:18:32 <dons> the above is what you'll actually find in GHC/Base.hs
18:18:32 <SamB> ibrary?
18:19:02 <SamB> maukes is much easier to read, iMo
18:19:39 <dons> not sure the defn of sequence in terms of liftM is terribly useful though, for pedagogical purposes
18:20:31 <dons> user317: you can always just read the source directly:
18:20:34 <Bobstopper> More trivial examples (such as hello world) assemble just fine
18:20:35 <dons> ?source Control.Monad
18:20:36 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
18:20:36 <user317> well at least i think i understand how liftM2 works now :)
18:21:04 <dons> liftM2  :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:21:04 <dons> liftM2 f m1 m2          = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:21:08 * glguy notes that if someone doesn't understand sequence... (->) r is likely foreign
18:21:13 <dons> ?undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:21:13 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
18:21:16 <user317> dons, having the answer is not really teh same as figuring out what it should be
18:22:29 <user317> so, why are there 4 elements in teh list after sequence [[1,2],[3,4]]
18:22:42 <SamB> ?incomprehend [x+y | x <- xs, y <- ys]
18:22:43 <lambdabot> Unknown command, try @list
18:22:51 <SamB> @undo [x+y | x <- xs, y <- ys]
18:22:51 <lambdabot> [x + y | x <- xs, y <- ys]
18:22:56 <SamB> aww
18:23:22 <glguy> > [1,2] >> [3,4]
18:23:24 <lambdabot>  [3,4,3,4]
18:24:47 <abeloso> > undo
18:24:48 <lambdabot>  Not in scope: `undo'
18:26:08 <SamB> abeloso: @undo (a.k.a. ?undo) is just a command to take a program with "do" blocks in it and transform it into a program without "do" blocks
18:26:39 <dons> so the key is to undertsand the [] monad, and from there all magic flows:
18:26:40 <dons> instance  Monad []  where
18:26:40 <dons>     m >>= k             = foldr ((++) . k) [] m
18:26:40 <dons>     m >> k              = foldr ((++) . (\ _ -> k)) [] m
18:26:41 <dons>     return x            = [x]
18:27:18 <dons> [1,2] >> [3,4]  -->  foldr ((++) . (\ _ -> [3,4])) [] [1,2]
18:28:04 <abeloso> > parinpar :: [Int] -> ([Int],[Int]); parinpar (x:xs) = (sacarpares (x:xs), sacarImpares (x:xs)); sacarpares :: [Int] -> [Int] ; sacarpares []=[]; sacarpares (x:xs); |mod x 2 == 0 = x:sacarpares xs ; |otherwise = sacarpares xs; sacarImpares :: [Int] -> [Int]; sacarImpares []=[]; sacarImpares (x:xs) ; |mod x 2 == 1 = x:sacarImpares xs ; |otherwise = sacarImpares xs ; [2,5,4,6,7,8]
18:28:04 <lambdabot>  Parse error
18:28:10 <abeloso> S:
18:28:18 <dons> use ghci..
18:29:51 <user317> i need to sleep on this
18:30:28 <lispy> okay, i just submitted a bug about that heap size
18:31:11 <lispy> do you use any sort of bug tracker for your personal projects?
18:31:37 <lispy> i was reading joel on software and he makes a pretty convincing argument as to why you should keep a bug database of somesort
18:31:50 <lispy> http://joelonsoftware.com/articles/fog0000000043.html
18:31:53 <lambdabot> Title: The Joel Test: 12 Steps to Better Code - Joel on Software, http://tinyurl.com/zrwhy
18:31:58 <dons> its a good idea. i should probably do that
18:31:59 <lispy> we don't have one at all
18:32:03 <lispy> yeah
18:32:09 <dons> seems like a logical step after using darcs
18:32:17 <lispy> you really only need one big spreadsheet or something
18:32:25 <abeloso> > fibonachi
18:32:26 <lambdabot>  Not in scope: `fibonachi'
18:32:30 <dons> i currently just stick critical ones in a todo list
18:32:33 <abeloso> > fibonachi [2,5,6,4,7]
18:32:33 <lambdabot>  Not in scope: `fibonachi'
18:32:38 <lispy> dons: right
18:32:39 <abeloso> > fibonachi 5,4,1,2
18:32:40 <lambdabot>  Parse error
18:32:45 <abeloso> > fibonachi 456156
18:32:46 <lambdabot>  Not in scope: `fibonachi'
18:32:47 <lispy> dons: but as we both know that has limitations
18:33:10 <lispy> i want something co-workers can look at quickly
18:33:18 <lispy> but a bit more structured than our wiki
18:33:20 <dons> > fix $ \f -> 1 : 1: zipWith (+) (tail f) f
18:33:21 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:33:31 <lispy> you beat me to it :)
18:33:34 <lispy> fix++
18:33:52 <dons> trac seems like quite a nice system.
18:33:56 <dons> but it might be overkill (?)
18:34:01 <glguy> fibonacci
18:34:03 <wolverian> abeloso, it's spelled 'fibonacci'
18:34:24 <lispy> dons: yeah, i was thinking about setting up a trac instance but not using the built inversion control
18:34:30 <dons> ?let fibs = fix $ \f -> 1 : 1: zipWith (+) (tail f) f
18:34:30 <lambdabot> <local>:4:34:     Ambiguous occurrence `+'     It could refer to either `L.+'...
18:34:38 <dibblego> look at mantis, trac, scarab and of course there is fogbugz, definitely JIRA if you can manage an open source licence (I did it)
18:34:41 <dons> ?undefine
18:34:42 <lambdabot> Undefined.
18:34:43 <dons> ?let fibs = fix $ \f -> 1 : 1: zipWith (+) (tail f) f
18:34:44 <lambdabot> Defined.
18:34:50 <dons> > take 10 L.fibs
18:34:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
18:34:54 <lispy> dons: since we dont' want to put our source out on the web but, we would like our bug database to be easy to work with interoffice
18:34:56 <glguy> > take 10 $ fix ( (1:) . scanl (+) 1)
18:34:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
18:35:01 <dibblego> frist thing I'd do is try to get a JIRA OSS licence - if you can, there's no need to go elsewhere
18:35:29 <lispy> dibblego: we're a commercial company
18:35:43 <lispy> for personal stuff i was thinking roundup
18:35:45 <dibblego> sorry, I thought it was for ghc or something
18:35:48 <lispy> maybe work should just use roundup
18:36:03 <lispy> dibblego: ghc uses trac
18:36:26 <lispy> oh, maybe the webhost provides something...i should check
18:36:47 <dibblego> HaXML fails installation - pita
18:36:48 <glguy> > take 10 $ fix ( liftM2 (.) (:) (scanl (+)) 1)
18:36:49 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
18:37:06 <dons> nice glguy
18:37:19 <hyrax42_> ?hoogle epsilon
18:37:20 <lambdabot> No matches found
18:37:24 <glguy> dons: it's pretty :)
18:37:35 <hyrax42_> how do you get the epsilon for floating point operations
18:37:52 <dons> hyrax42_: wasn't there a thread about this last week?
18:37:53 <dibblego> ?type liftM2
18:37:55 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:37:59 <hyrax42_> dons, I will search!
18:38:02 <dons> hyrax42_: check the hwn
18:38:04 <dons> ?where hwn
18:38:05 <lambdabot> http://sequence.complete.org/
18:38:17 <dons> in the 'Discussion' section
18:38:41 <lispy> the bottom line in that thread was, you have to define what you mean by small :)
18:38:43 <hyrax42_> where the
18:38:44 <hyrax42_> oh
18:39:14 <dons> sjanssen: got your tshirt yet?
18:39:14 <glguy> > length $ takeWhile (/= 0) $ iterate (/2) 1
18:39:16 <lambdabot>  1075
18:39:31 <lispy> glguy: did you see my version to compute powers of two just using fix show?
18:39:31 <dibblego> lispy, are you a commercial company using haskell?
18:39:43 <lispy> dibblego: yeah
18:39:57 <lispy> dibblego: as a company not really, but i'm using what i want to use on thisprototype :)
18:40:01 <dibblego> lispy, where can I read about it?
18:40:05 <dibblego> oh right
18:40:15 <dons> dibblego: did you read the report on CUFP?
18:40:15 <lispy> dibblego: i have a blog about work though
18:40:17 <dibblego> so as a company, everyone else uses <something-else>
18:40:22 <dibblego> dons, no, didn't know it was out
18:40:24 <lispy> dibblego: http://blog.codersbase.com/
18:40:25 <lambdabot> Title: dagit.o
18:40:30 <dibblego> lispy, excellent thanks
18:40:53 <hyrax42_> dons, I click discussion I see posts July and older?
18:41:23 <hyrax42_> ohh
18:41:26 <hyrax42_> I was on the wrong side
18:41:28 <dons> dibblego: last week's HWN...
18:41:28 <lispy> glguy: check this out
18:41:30 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . take 1000000 . fix $ show
18:41:32 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:41:46 <hyrax42_> wait
18:41:46 <hyrax42_> nope
18:41:50 <hyrax42_> I have no idea what I'm looking at
18:42:27 <dons> lispy: do you have to take 1000000 ?
18:42:38 <lispy> dons: only with lambdabot
18:42:48 <lispy> in ghci it will print the intermediate results
18:43:05 <lispy> and in that case you can omit the init too
18:43:09 <dibblego> dons, so you mean each document for each session? there doesn't seem to be an overall report
18:43:11 <glguy> lispy: this is "close" (wrong base case)
18:43:13 <hyrax42_> dons, can you give me a rough link
18:43:14 <glguy> > take 10 $ filter ((=='"').snd) $ zip [0..] (fix show)
18:43:14 <dylan> I need a reason to switch my svk repos to darcs...
18:43:15 <lambdabot>  [(0,'"'),(2,'"'),(6,'"'),(14,'"'),(30,'"'),(62,'"'),(126,'"'),(254,'"'),(510...
18:43:15 <lispy> that's just there to make sure the last listed number is a whole power of two
18:43:24 <hyrax42_> at least to discussion section that you have in mind
18:43:50 <lispy> glguy: heh
18:44:14 <glguy> > take 10 [a | (a,b) <- zip [1..] (fix show), b=='"']
18:44:16 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023]
18:44:23 <lispy> mine can be shorted quite a bit of you prefer powers of two minus one
18:44:39 <lispy> > init . map length . group . take 1000000 . fix $ show
18:44:42 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
18:44:53 <glguy> > take 10 [a | (a,'"') <- zip [1..] (fix show)]
18:44:54 <lambdabot>  [1,3,7,15,31,63,127,255,511,1023]
18:44:59 <dons> hyrax42_: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/15573/focus=15573
18:45:03 <lambdabot> Title: Gmane Loom, http://tinyurl.com/s6kw9
18:45:10 <hyrax42_> oh
18:45:14 <hyrax42_> well I was going to go to gmane first
18:45:17 <hyrax42_> but then you said hwn
18:45:18 <glguy> > take 10 [a+1 | (a,'"') <- zip [1..] (fix show)]
18:45:19 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
18:45:24 <glguy> lispy: ^^^
18:45:29 <hyrax42_> dons, thanks
18:45:30 <dons> "                         * Smallest Double. Tamas Papp initiated a thread regarding finding the
18:45:33 <dons>                            smallest Double such that 1+x /= x, for a numerics problem.
18:45:37 <lispy> glguy: but that's cheating because you use (+) on the elements :)
18:45:42 <dibblego> is there a "The CUFP06 Report"?
18:45:44 <lispy> well, really the number 1
18:45:47 <hyrax42_> dons, ohh
18:45:48 <hyrax42_> I see
18:45:51 <glguy> > take 10 [a | (a,'"') <- zip [2..] (fix show)]
18:45:52 <hyrax42_> it's not defined though?
18:45:52 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
18:45:53 <dons> dibblego: not out yet.
18:45:53 <glguy> lispy ^^^
18:45:58 <hyrax42_> you can get it directly in other systems
18:46:02 <dibblego> dons, on right thanks
18:46:06 <lispy> > take 10 . init . map length . group . fix $ show -- no numbers!
18:46:07 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
18:46:20 <araujo> http://haskell.org/haskellwiki/Haskell.es  , spanish wiki page for Haskell!
18:46:22 <lambdabot> Title: Haskell.es - HaskellWiki
18:46:40 <araujo> Feel free to stop by and drop in some words if you like :-)
18:46:51 <lispy> anyway, i should head home
18:46:57 <dibblego> lispy, what does "rotate a list by its length" mean exactly?
18:47:17 <dons> araujo++
18:47:25 <araujo> dons, :-)
18:47:36 <lispy> dibblego: um...you take elements off one end and put them on the other
18:47:39 <glguy> ?remember araujo  Feel free to stop by and drop in some words if you like :-)
18:47:47 <dibblego> ah right
18:48:02 <dibblego> > lrotate [1,2,3]
18:48:02 <lambdabot>  Not in scope: `lrotate'
18:48:11 <dibblego> [3,2,1]
18:48:16 <dibblego> no [3,1,2]
18:48:32 <araujo> glguy, :-)
18:48:32 <glguy> liftM2 (:) last init
18:48:43 <glguy> > liftM2 (:) last init [1,2,3]
18:48:44 <lambdabot>  [3,1,2]
18:48:52 <dons> araujo: what's the plan? to translate the entire wiki? :)
18:49:00 <araujo> Let's see if we can catch more haskell'ers among us!
18:49:03 <dibblego> @let lrotate = liftM2 (:) last init
18:49:04 <lambdabot> Defined.
18:49:11 <dibblego> lrotate [1,2,3]
18:49:16 <dibblego> > lrotate [1,2,3]
18:49:16 <lambdabot>  Not in scope: `lrotate'
18:49:17 <glguy> dibblego: i think that is rrotate
18:49:22 <dibblego> oh
18:49:26 <dons> araujo: you might want  to announce it on the mailing list, haskell-cafe
18:49:34 <araujo> dons, Not _that_ ambitious (yet?) , But slowly going collecting spanish Haskell stuff mainly.
18:49:37 <dibblego> > L.lrotate [1,2,3]
18:49:38 <lambdabot>  [3,1,2]
18:49:39 <dons> and ask people to help translate some more pages
18:49:54 <araujo> dons, oh, good idea, right away to send an email
18:49:55 <lispy> another catch to those the (l|r)rotate family is that you want to work on weird amounts of rotate and what not
18:50:15 <dibblego> @let lrotate [] = [];lrotate (x:xs) = xs:x
18:50:15 <lambdabot> <local>:3:0:     Multiple declarations of `L.lrotate'     Declared at: <local...
18:50:22 <dibblego> @undefine
18:50:23 <lambdabot> Undefined.
18:50:24 <dibblego> @let lrotate [] = [];lrotate (x:xs) = xs:x
18:50:25 <araujo> dons, And yes, we also could translate some of the most interesting english stuff.
18:50:25 <lambdabot> <local>:1:36:     Occurs check: cannot construct the infinite type: a = [[a]]...
18:50:32 <dibblego> I give up, lunch
18:50:34 <dibblego> bye
18:50:45 <lispy> :)
18:50:48 <araujo> dons, For example, dylan proposed to translate a tutorial about monads. (which we need)
18:50:52 <lispy> i ended up with mutually recursive definitions
18:50:55 <dons> araujo: you could start by looking at the 'Most popular pages', and translating them.
18:51:04 <lispy> negative rotation calls the other rotate and takes the abs of the rotate :)
18:51:13 <araujo> dons, yeah, indeed.
18:51:32 <dons> here, http://haskell.org/haskellwiki/Special:Popularpages
18:51:35 <lambdabot> Title: Popular pages - HaskellWiki, http://tinyurl.com/kedmq
18:51:42 <dons> i wonder if it makes sense to try to translate the HWN each week?
18:51:50 <dons> my GF speaks spanish. hmm....
18:51:52 <SamB> what is with this!
18:51:54 <araujo> dons, I also like the Getting Started section.
18:51:59 <SamB> *** Expression     : strJumpers o p jump label
18:51:59 <SamB> *** Term           : jump
18:51:59 <SamB> *** Type           : Map GLabel (Set GLabel)
18:51:59 <SamB> *** Does not match : Map GLabel (Set GLabel)
18:52:03 <lispy> dons: you have a gf and you spend this much time on here?
18:52:04 <araujo> dons, Done. Can i take over this work? :-)
18:52:08 <lispy> dons: she must be lonely ;)
18:52:56 * lispy leaves for real
18:52:57 <dons> hey! where do you think i was last weekend? gf + beach = fun!
18:53:09 <araujo> hah
18:53:10 <lispy> dons: oh, yeah didn't you have a 3day weekend too/
18:53:22 <dons> right :)
18:53:23 <lispy> my calendar say monday was the queen's bday
18:53:23 <araujo> dons, nice  web page about the popular pages.
18:53:24 <SamB> lispy: thats what he said when he ran off!
18:53:30 <lispy> hehe
18:53:33 * lispy evaporates
18:54:03 <dons> araujo: would you be interested in translating the hwn into spanish each week?
18:54:10 <dons> there's a darcs repo. we could do what the lwn guys do
18:54:23 <dons> they distribute the copy, and then the translators start work.
18:54:32 <dons> i think hwn wouldn't take too long to do. its pretty short.
18:54:47 <araujo> dons, yeah, i could perfectly translate it to spanish.
18:55:03 <araujo> Nice.
18:55:20 <dons> yeah. that's what I'm thinking. ok. i'll set up a translating subdir in the hwn repo. and see if we can work out a structure to make this work
18:55:28 <dons> ?users #haskell.es
18:55:34 <araujo> yay!
18:55:37 <lambdabot> Maximum users seen in #haskell.es: 10, currently: 6 (60.0%), active: 2 (33.3%)
18:55:52 <dons> 10. good work :)
18:56:01 <araujo> yeah, slowly growing up :-)
18:56:22 <araujo> There has been some kind of interest lately too.
18:56:41 <araujo> dons, is it ok if i also announce the hwn spanish translation each week on the mailing lists?
18:57:10 <dons> sure. you can say that you'll be doing that.
18:57:18 <araujo> Cool.
18:58:09 <dons> so, what would be the best way. current each issue is generated into a .html page, a .wiki page and an email.
18:58:19 <dons> so perhaps the html page should be translated, and posted to the haskell.es wiki
18:58:34 <dons> let me see how lwn does it
18:58:35 <dons> ...
18:59:32 <araujo> yes, i think that translating the html page would be very straight ahead.
18:59:40 <jgrimes> heh, this is kind of funny
18:59:45 <jgrimes> @google scheme standard library
18:59:46 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Write_Yourself_a_Scheme_in_48_Hours/Towards_a_Standard_Library
19:00:15 <araujo> dons, couldn't we get it working with some darcs repo too
19:00:15 <dons> heh!
19:00:17 <araujo> ?
19:00:45 <dons> yes, i think you'd commit the page into the darcs repo
19:00:54 <araujo> aha
19:09:52 <araujo> dons, i guess it shouldn't be difficult
19:10:18 <dons> araujo: ok. so i've created a translation subdir, in the repo, http://www.cse.unsw.edu.au/~dons/code/hwn/
19:10:19 <lambdabot> Title: Index of /~dons/code/hwn
19:10:33 <dons> look in archives/es/
19:11:03 <dons> so the idea would be, once an issue is written, to take the .txt version from archives/yyymmdd.txt and translate it, putting it into archives/es/yyyymmdd.txt
19:11:20 <dons> since the html version is mechanically generated, it is a bit icky to translate, i think
19:11:27 <araujo> yay!!!
19:11:29 <dons> though i'm not sure. maybe i can improve that.
19:11:56 <araujo> Well, the .txt also works of course.
19:12:00 <dons> so how would this work: i'd prepare the article, and push it into the repo. you'd then darcs pull the issue, translate it, and darcs send me the patch
19:12:11 <dons> and also post your translated version on the haskell.es wiki
19:12:20 <araujo> Right. Good.
19:12:29 <dons> the normal hwn issues would then point to a [es] page
19:12:44 <araujo> Cool.
19:13:52 <araujo> dons, the html version is automatically generated as soon as i push the translation?
19:14:03 <araujo> Or it is some kind of cron job ...
19:14:25 <dons> currently, when I finish writing the file 'content.wiki' in the top dir, i run a script, which generaates the .txt, .html and .wiki versions
19:14:33 <dons> which dumps them into archives/
19:14:51 <araujo> Ok.
19:14:52 <dons> maybe it would be easier to just translate the original source...
19:15:04 <dons> then you'd get both the .txt and .html version generated
19:15:31 <hyrax42_> ?hoogle (Num a, Floating b) => a -> b
19:15:33 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
19:15:33 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
19:15:33 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
19:15:35 <dons> anyway, would you like to try to translate either 20061003.txt or .html? so we can get an idea of how long it takes?
19:16:07 <hyrax42_> guh
19:16:35 <araujo> dons, i think i'll go with .txt
19:16:59 <dons> I think that would be easiest.  and we should be able to just post it directly to the wiki
19:17:16 <araujo> yeah
19:17:53 <araujo> It should be very straight-forward to post it on the wiki.
19:18:13 <hyrax42_> ?hoogle Float -> Double
19:18:13 <lambdabot> No matches, try a more general search
19:18:35 <Pseudonym> ?hoogle (Fractional a, Fractional b) => a -> b
19:18:37 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
19:18:37 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
19:18:37 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
19:18:45 <Pseudonym> Hrm.
19:18:51 <hyrax42_> I tried with Floating as well
19:18:56 <Pseudonym> Right.
19:19:00 <hyrax42_> ?hoogle (Floating a, Floating b) => a -> b
19:19:02 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
19:19:02 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
19:19:02 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
19:19:06 <araujo> dons, so, do you agree the .txt is a good way to do it?
19:19:06 <Pseudonym> ?hoogle Floating
19:19:07 <lambdabot> Prelude.Floating :: class Fractional a => Floating a
19:19:25 <hyrax42_> not sure what's with the monad.whatever stuff
19:19:47 <hyrax42_> at worst I could do read . show
19:19:48 <ThreeQ> ?type fromRational . toRational
19:19:50 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
19:19:57 <dons> araujo: yes. so take the yyymmdd.txt file, translate it into es/yyymmdd.txt. darcs add . darcs record . darcs send. and post it to the haskell.es wiki
19:20:00 <hyrax42_> that's less bad, perhaps?
19:20:01 <dons> yeah?
19:20:14 <Pseudonym> Yikes.
19:20:19 <araujo> dons, Excellent!
19:20:32 <dons> araujo: hehe. what's the spanish word for 'blogosphere' ?  :)
19:20:40 <ThreeQ> > fromRational . toRational $ (3 :: Float) :: Double
19:20:41 <lambdabot>  3.0
19:20:52 <gmh33> @bf .+[.+].
19:20:53 <lambdabot>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk...
19:20:56 <Pseudonym> > realToFrac (3.0 :: Float) :: Double
19:20:57 <lambdabot>  3.0
19:21:00 <araujo> dons, hah .. mmm ... something like 'esfera de blogs'
19:21:01 <Pseudonym> Bingo.
19:21:09 <hyrax42_> Pseudonym, thanks!
19:21:39 <dons> ?babel en es blogosphere
19:21:41 <lambdabot>  blogosphere
19:21:43 <dons> heh
19:21:51 <hyrax42_> shouldn't it be blogosfere
19:21:53 <hyrax42_> or something
19:22:07 <araujo> dons, yeah, not really a spanish translation. You can let it that way too.
19:22:16 <dons> i wonder if using the not-so-good babel tool to do the first draft would make it easier?
19:22:22 <hyrax42_> ?babel en es sphere
19:22:24 <lambdabot>  esfera
19:22:27 <dons> though i imagine it might be just easier to do it all by hand.
19:22:36 <araujo> dons, it's fine, i can go ahead
19:23:00 <araujo> dons, yeah, i guess too. We still need to write a Haskell translator :-)
19:23:00 <dons> now i'll have to bug xerox to do the .it version
19:23:11 <araujo> haha
19:23:44 <dons> or i wonder if running araujo's spanish translation through babel would give a reasonable .pt version? hmm.
19:24:03 <araujo> dons, it could; both languages are very similar.
19:24:24 <araujo> I guess it'd give a closer translation than english<->spanish
19:24:54 <dons> yeah. i live in a portugese suburb here in sydney, and my gf understands most of the signs and so on, only knowing spanish
19:27:46 <araujo> oh, interesting.
19:27:58 <araujo> dons, she speaks spanish right?
19:29:04 <dons> yep
19:32:03 <hyrax42_> -. *. etc. in ocaml are really clumsy
19:34:39 <ThreeQ> hyrax42_: i feel the same about writing M.map, S.map, B.map, etc
19:34:40 * araujo checks: spanish wiki page , HWN , ....... <a bit closer to take over the world>
19:34:48 <ThreeQ> for all the different kinds of collections
19:35:19 <hyrax42_> that is get-arounda-able with type classes though, isn't it?
19:35:34 <hyrax42_> but fair enough
19:36:12 <dons> in general type classes solve these problems
19:36:22 <dons> i.e. the Num and Floating classes
19:36:30 <ThreeQ> exactly
19:36:38 <ThreeQ> why isn't there a type class for collections?
19:36:43 <dons> some types are a bit specialised, and require  MPTCs or FDs to get good bounded polymorphism
19:36:49 <dons> ThreeQ: the Sequence class :)
19:37:01 <ThreeQ> ?hoogle Sequence
19:37:01 <dons> but yeah, its a bit of an open issue.
19:37:02 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
19:37:02 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
19:37:02 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
19:37:11 <dons> the design space is large enough that no good soln is available yet
19:37:20 <hyrax42_> Sequence is part of edison?
19:37:28 <dons> though sjanssen wrote one for bytestrings /soc recently
19:37:29 <dons> and pugs ahas a Seq class too, iirc.
19:37:45 <dons> part of ghc 6.6
19:37:57 <hyrax42_> oh
19:37:57 <hyrax42_> nifty
19:38:11 <hyrax42_> sjanssen was the soc bytestrings guy?
19:38:18 <dons> yep
19:38:22 <hyrax42_> cool
19:38:26 <hyrax42_> how did that turn out
19:39:41 <dons> pretty good! we have a polymorphic Vector type now, for packed Stroable values with a bytestring interface. + more.
19:39:48 <araujo> dons, ok, can i already commit to the darcs repo?
19:40:37 <hyrax42_> ?type Infinity
19:40:38 <lambdabot> Not in scope: data constructor `Infinity'
19:40:47 <hyrax42_> > 1/0
19:40:48 <lambdabot>  Infinity
19:41:22 <hyrax42_> is it possible to have a sentinal "biggest" value?
19:41:54 <hyrax42_> where x `compare` sentinel = LT for evyer x?
19:43:38 <hyrax42_> ?docs prelude
19:43:38 <lambdabot> prelude not available
19:43:40 <dons> araujo: nope. but you can darcs send me the patch
19:43:42 <hyrax42_> ?docs Prelude
19:43:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
19:43:58 <ThreeQ> data InfNum a = Finite a | Infinity
19:43:59 <dons> so you added a file into archives/es/* ?
19:44:20 <ThreeQ> instance Ord a => Ord (InfNum a) where
19:44:28 <ThreeQ> -- do the right thing
19:44:29 <ThreeQ> etc
19:44:47 <hyrax42_> ThreeQ, yeah I thought of that
19:44:50 <araujo> dons, no, not yet
19:45:00 <hyrax42_> but it will end up boxed and well...
19:45:03 <ThreeQ> but that seems kind of annoying
19:45:05 <ThreeQ> yeah
19:45:18 <ThreeQ> and there IS such a thing as an infinite float
19:45:23 <ThreeQ> there must be a way to construct it
19:45:28 <dons> > 1/0
19:45:30 <lambdabot>  Infinity
19:45:35 <dons> > Infinity
19:45:36 <lambdabot>  Not in scope: data constructor `Infinity'
19:45:39 <hyrax42_> ? type 1/0
19:45:40 <dons> ah well
19:45:45 <dons> ?type 1/0
19:45:47 <lambdabot> forall a. (Fractional a) => a
19:45:48 <hyrax42_> oops
19:46:05 <hyrax42_> > 1e50 `compare` 1/0
19:46:05 <lambdabot>  add an instance declaration for (Fractional Ordering)
19:46:06 <lambdabot>   In the definition...
19:46:20 <hyrax42_> > 1e50 `compare` (1/0)\
19:46:20 <lambdabot>  Parse error
19:46:21 <hyrax42_> > 1e50 `compare` (1/0)
19:46:23 <lambdabot>  LT
19:46:29 <hyrax42_> seems cheaty
19:46:45 <ThreeQ> just do an "infinity = 1/0" somewhere
19:46:48 <hyrax42_> I say that infinity and epsilon should be built in
19:47:07 <hyrax42_> both needed for numerical type stuffs
19:47:09 <dons> ?let infinity = 1/0
19:47:10 <lambdabot> Defined.
19:47:14 <hyrax42_> ah let
19:47:16 <hyrax42_> I was going to do it
19:47:21 <dons> > 1e50 `compare` L.infinity
19:47:22 <hyrax42_> just wasn't 100% sure what it was
19:47:22 <lambdabot>  LT
19:47:46 <dons> > L.infinity `compare` L.infinity
19:47:48 <lambdabot>  EQ
19:47:50 <weitzman> @let doubleplusinfinity = L.infinity + L.infinity
19:47:51 <lambdabot> Defined.
19:48:07 <weitzman> > L.infinity `compare` L.doubleplusinfinity
19:48:07 <hyrax42_> ?let epsilon = last $ takeWhile (\x -> 1 + x /= x) $ iterate (/2) 1
19:48:09 <lambdabot>  EQ
19:48:09 <lambdabot> Defined.
19:48:15 <dons> ?let infinityplus1 = L.infinity + 1
19:48:16 <lambdabot> Defined.
19:48:17 <hyrax42_> > epsilon
19:48:18 <lambdabot>  Not in scope: `epsilon'
19:48:25 <hyrax42_> > L.epsilon
19:48:29 <lambdabot> Terminated
19:48:41 <hyrax42_> oh crap
19:48:45 <hyrax42_> ?let epsilon = last $ takeWhile (\x -> 1 + x /= 1) $ iterate (/2) 1
19:48:45 <lambdabot> <local>:5:0:     Multiple declarations of `L.epsilon'     Declared at: <local...
19:48:53 <hyrax42_> ?unlet epsilon
19:48:53 <lambdabot>  Parse error
19:48:56 <hyrax42_> hm
19:49:03 <hyrax42_> is there a recourse?
19:49:06 <weitzman> ?undefine
19:49:07 <lambdabot> Undefined.
19:49:25 <hyrax42_> ?type L.epsilon
19:49:26 <lambdabot> Couldn't find qualified module.
19:49:36 <hyrax42_> ?let epsilon = last $ takeWhile (\x -> 1 + x /= 1) $ iterate (/2) 1
19:49:37 <lambdabot> Defined.
19:49:47 <hyrax42_> > L.infinity
19:49:48 <lambdabot>  Not in scope: `L.infinity'
19:49:52 <hyrax42_> it forgets everything
19:49:53 <hyrax42_> ah well
19:49:55 <weitzman> Yep
19:50:18 <dons> you shouldn't be using lambdabot as an RCS anyway ;)
19:50:26 <hyrax42_> but but!
19:50:31 <dons> free online code hosting! forget sourceforge. use lambdabot!
19:50:40 <hyrax42_> it's write-only though
19:50:42 <hyrax42_> for code
19:50:59 <hyrax42_> you can get anything that has a Show instance out
19:51:14 <dons> > L.epsilon
19:51:15 <lambdabot>  2.220446049250313e-16
19:51:31 <dons> we could add @env or something, pretty easily
19:51:49 <hyrax42_> if I feel inspired to look into lambdabot sources and the plugin api
19:51:50 <hyrax42_> ...
19:51:59 <hyrax42_> too many waiting-on things right now
19:52:19 <hyrax42_> first I guess is a DFA/NFA mini-lib so I can demonstrate to TA that she's wrong
19:52:27 <hyrax42_> (at least I hope she is!)
19:52:49 <skew> it would be really nice for interactive things to hang onto code and dump it out nicely
19:53:15 <skew> like pulling out just the definitions that went into a value you like
19:53:59 <dons> hmm? skew, example please?
19:54:34 <skew> do you ever throw something together in ghci, to do some simple calculation
19:55:05 <skew> or perhaps play around with a library till you get something working?
19:55:23 <dons> sure.
19:55:43 <araujo> email sent!
19:55:55 <skew> Then if you decide to save the code, it can be hard to grab all the bits out of the history
19:56:57 * weitzman imagines "me > @. useenv createenv"; bot > "Environment '10' created. You are using environment '10'"; "> let x = blah"; "x :: blah"; ...; "@. printenv myenv"
19:57:30 <dons> araujo: great!
19:57:36 <skew> the simple case would be something like :dump f, to print the definition of your f
19:58:31 <ThreeQ> in the ghc 6.6 Control.Applicative, what's the point of the WrappedMonad type?
19:58:35 <skew> the really nice thing would be transitive, outputting the source for things reachable from roots you list, giving it a module header and import list for extra bonus points
19:58:37 <ThreeQ> why not make the monad itself an instance?
19:58:57 <dfeuer> Anyone here good at numerical stuff?
19:59:49 * weitzman has visions of a badass Haskell IDE where you enter code in an interactive console but it lets you throw out the definitions you didn't need
20:00:31 <Bobstopper> I'd like something like SLIME where I can just C-x C-e and have it load the definition into a GHCi buffer. It'd also be nice if such definitions automaticaly updated haskell-mode's type declarations. module imports uploading haskel-mode's type declarations would be nice too.
20:01:01 * weitzman wonders what the most badass currently existing Haskell IDE is
20:01:03 <Botty> dfeuer - I can add 1 and 1 in my head
20:01:10 <dfeuer> That won't do it.
20:01:13 * weitzman suspects it would be Visual Haskell?...
20:01:21 <skew> that's half the story, but it's nice to play around with thing interactively as well
20:01:41 <chessguy> @hoogle polyp
20:01:41 <lambdabot> No matches found
20:01:53 <ThreeQ> is there a haskell curses lib?
20:02:06 <dons> ?where hscurses
20:02:07 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
20:02:14 <skew> and then once I've finally got some example working it's good to save it out (which is trivial unless it used some auxiliary definitions)
20:02:20 <dons> also a nice small one in hmp3
20:02:22 <dons> ?where hmp3
20:02:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
20:02:39 <ThreeQ> dons: thanks
20:03:06 <dons> ThreeQ: if you have any questions about curses programming in haskell, feel free to ask me, -- i've done a fair bit in the last couple of years
20:03:26 <dons> (and i recommend hmp3 as a good example of how to do multithreaded curses apps in .hs)
20:03:32 <Bobstopper> any windows users here have ghc installed and is willing to test something for me?
20:04:09 <weitzman> Bobstopper: 6.4.2 good enough?
20:04:25 <Bobstopper> Actually, never mind - I've got a colleague installing it. I'll get him to test. Thanks :)
20:04:59 <lennart> dons: I hear that you should work more on your thesis. ;)
20:05:02 <skew> It might be pretty nifty to be able to reload stuff from a file without losing interactive defintions - not sure what to do when the stuff you typed does not type against the new module
20:05:10 <SamB_XP> Bobstopper: good technique ;-)
20:05:39 <SamB_XP> skew: well, thats probably why GHC doesn't do that already ;-)
20:05:47 <dons> lennart: ah good idea! thanks :)
20:05:49 <Bobstopper> I've got mad skillz
20:05:52 <Bobstopper> what technique?
20:06:15 <SamB_XP> that, and the values in the heap reference the old module!
20:06:32 <skew> I'm thinking more like replaying the stuff you typed, but against the new module
20:06:45 <lisppaste2> dibblego pasted "why won't HaXML install?" at http://paste.lisp.org/display/27444
20:07:11 <dons> lennart: i should, yes. get this thing done and dusted.
20:09:39 <hyrax42_> ?instances MonadPlus
20:09:40 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
20:10:08 <hyrax42_> ?type (|)
20:10:09 <lambdabot> parse error on input `|'
20:10:13 <hyrax42_> ?type (||)
20:10:15 <lambdabot> Bool -> Bool -> Bool
20:10:23 <hyrax42_> it short-circuits, right?
20:10:26 <hyrax42_> of course
20:10:27 <hyrax42_> this is haskell
20:10:31 <hyrax42_> what am I even talking about
20:12:09 <dibblego> http://paste.lisp.org/display/27444 "Reading package info from stdin ... ghc-pkg: Line 1: Invalid syntax (no colon after field name)" -- wtf is going on?
20:12:16 <lennart> dons: once you're done with your thesis you might get a well paid job.  at a bank. ;)
20:12:41 <skew> what are you planning on doing for a thesis?
20:12:43 <hyrax42_> dibblego, the source would be more useful :p
20:13:00 <dibblego> hyrax42_, the source of what?
20:13:01 <dons> lennart: I would like that :)
20:13:05 <lennart> hyrax42_: how could Haskell be lazy and not short-circuit || ? :)
20:13:11 * dons resolves to finish his thesis in the next few months!
20:13:18 <skew> I noticed today that Jane's Capital seems to have bought ads on Coq at google.
20:13:28 <hyrax42_> oh dibblego sorry
20:13:30 <hyrax42_> I have no idea
20:13:31 <dibblego> hyrax42_, make install ?
20:13:38 <dibblego> ok
20:13:41 <hyrax42_> I didn't read the command given
20:13:49 <hyrax42_> thought it was an error calling ghc on your code
20:14:00 <lennart> skew: Jane street, bah, O'Caml :)
20:14:02 <dibblego> no, trying to install HaXML
20:14:23 <hyrax42_> I used darwinports
20:14:26 <hyrax42_> so can't help you
20:14:58 <weitzman> Actually, it would be interesting if Haskell super-extra short-circuited ||
20:15:04 <dibblego> `apt-cache search haxml | wc -l` == 0
20:15:13 <weitzman> Noticing if one of the args was already reduced to a bool
20:15:22 <lennart> weitzman: and what would that mean?
20:15:41 <lennart> super-extra for `if' would make sense
20:15:42 <hyrax42_> weitzman, so taking that rather than causing evaluation of the other
20:15:43 <weitzman>  Undefined || True -> True and True || Undefined -> True
20:15:44 <hyrax42_> if it was possible
20:15:54 <lennart> weitzman: ah
20:16:05 <SamB_XP> s/U/u/g
20:16:09 <lennart> yes, `por'
20:16:30 <SamB_XP> but that would just lead to hard-to-debug problems!
20:16:49 <skew> there was some cunning hack with unsafePerformIO and yield on the list a while back, to do something like a partial seq
20:16:56 <lennart> 'por' makes very good sense for parallel evaluation
20:17:30 <lennart> adding it would make the Haskell semantics fully abstract
20:17:42 <SamB_XP> heh
20:17:45 <skew> that parallel evaluation doesn't work so well if one side might raise an exception, rather than just failing to terminate or taking a long time to evaluate
20:18:21 <lennart> skew: You can't have exceptions and a clean semantics
20:18:45 <lennart> well, you can, but then it's rather unlike Haskell
20:18:54 <skew> the "imprecise exception" semantics seem reasonably nice
20:20:07 <Botty> yeah, seems like exceptions are an unsolved issue
20:20:18 <lennart> Putting things in the IO monad is a good way of hiding implementation dependent behaviour
20:20:43 <skew> but if raising exceptions was also controlled by a monad, then you would be able to do stuff like `por`
20:21:32 <skew> and for that matter, it seems the Epigram crew is planning to put nontermination in a monad
20:21:38 <lennart> skew: Once you're in a monad your evaluation order gets fixed
20:22:13 <lennart> skew: Yes, non-termination belongs in a monad.  this is my new (3 years) opinion. :)
20:22:49 <skew> I think evaluation order is not necessarily fixed in something like Reader
20:23:13 <skew> the monads are chained together in a certain way, but whether that actually restricts reduction order depends on the definition of the monad
20:23:26 <lennart> skew: I shouldn't be, but it kinda is, because Haskell has no concept of commutative monads
20:25:22 <lennart> the monad laws do not allow you to reorder effects.  but it would make sens (e.g. Reader) to have commutative monads where this is allowed
20:27:01 <skew> monads are not necessarily strict
20:28:48 <lennart> I know
20:29:10 <lennart> but the monad laws still don't allow you to reorder things
20:29:12 * jaymz is away: "off to work"
20:29:29 <lennart> it's a property of a particular monad if you can
20:33:28 <Pseudonym> Particularly, no monad transformer is commutative.
20:33:55 <Pseudonym> Which makes it a less-than-useful property.
20:36:36 <skew> A transformer can preserve commutativity
20:36:42 <lispy> nice
20:36:50 <lispy> (I didn't know that)
20:37:45 <skew> and it seems like you would have to work that out somehow, if you wanted to factor what we currently consider "pure" haskell into nontermination and exception-raising on top of pure code
20:39:50 <Bobstopper> Is anyone familiar with SLIME? I'm wondering if the easiest way to get an advanced IDE for haskell would be to just hack SLIME to interact with a haskell backend, and implement that haskell backend as a module of lambdabot...
20:40:24 <joelk> On many ocassions I've found my code is much faster when compiled with -O than when using -O3. Is this common?
20:40:47 <skew> it goes up to O3?
20:41:25 <lispy> Bobstopper: SLIME is only partially implemented in emacs...it opens up a socket and gets the lisp compiler to run some code that talks back to slime over the socket...
20:41:38 <lispy> Bobstopper: that's about all i know...other than i think SLIME is terrible
20:41:47 <Bobstopper> lispy: Yeah, I know. I'm thinking that backend could be done in lambdabot.
20:41:53 <Bobstopper> Really? Why do you think it's terrible?
20:41:57 <lispy> i've tried to like it about 4 times...and failed miserably :)
20:42:02 <Bobstopper> I <3 it :)
20:42:14 <lispy> well, for one thing it breaks debugging
20:42:30 <lispy> it's fragile (it was continually breaking and slowing me down and requiring me to restart emacs)
20:42:54 <lispy> it assumes you never restart  your lisp and penalizes you if you do by being really slow to start up
20:43:17 <Bobstopper> Ah yeah. That's because lisp sucks at starting up :)
20:43:19 <lispy> in sbcl when you get restarts you can type them in and it doesn't accept your input until you hit enter
20:43:27 <lispy> with slime it takes a restart as soon as you type a number
20:43:46 <lispy> so if you typed the wrong number, sorry
20:43:49 <joelk> skew, I seem to remember the shootout code being compiled with -O3. Anyway, -O is nice and fast.
20:44:00 <Bobstopper> Oh right. I've never been bothered by that since I rarely need to hit a restart past 9 anyway...
20:44:03 <lispy> Bobstopper: and that's just what i can remember now off the top of my head
20:44:12 <skew> well, my copy of the user's guide only talks about -O and -O2
20:44:24 <lispy> Bobstopper: i just type the wrong number pretty often and rely on hitting backspace and trying again
20:44:35 <Bobstopper> That's quite a list. Much of it wouldn't be such a problem with a haskell backend I wager - the start time would hopefully be substanctially less and debugging's totally different in haskell.
20:44:44 <Bobstopper> Ah I see
20:45:08 <lispy> i certainly wouldn't stop you
20:45:16 <lispy> and i'd try it out if you made it available
20:45:23 <lispy> but i hate SLIME :)
20:45:38 <lispy> Bobstopper: did you know lambdabot is already integrated with ghci?
20:45:43 <Bobstopper> What problems do you think are because of the idea of SLIME itself rather than the lisp interface with it?
20:45:55 <lispy> Bobstopper: and the library makes it very easy to integrate lambdabot with other prograsm too
20:45:59 <lispy> ?where goa
20:45:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
20:46:11 <Bobstopper> Yeah, vaguely. That's why I'm thinking implementing a slime backend as a lambdabot module would substantially reduce the amount of work needed.
20:46:24 <lispy> ah, just use goa
20:46:34 <lispy> we get a cgi version of lambdabot up in...what less than a week using goa?
20:46:42 <lispy> and now that we did that we fixed a lot of bugs in goa
20:46:47 <lispy> so it should take even less effort
20:47:03 <lispy> but
20:47:10 <joelk> skew, Hm, O3 is definetely doing something O and O2 don't. Something that makes a 5.5 s calc take 20 s!
20:47:11 <lispy> you probably want to hook directly into ghci
20:47:16 <Bobstopper> what is goa?
20:47:22 <lispy> ghci on acid
20:47:29 <skew> joelk: it looks much like -O2 here
20:47:34 <skew> at least as far as -v shows
20:47:40 <lispy> it's just a library that makes it easy to use lambdabot from ghci
20:47:45 <lispy> integrates lambdabot rather
20:47:58 <skew> Bobstopper: the GHC API might be more helpful
20:48:02 <Bobstopper> Ok, well that'd be a good start
20:48:21 <lispy> Bobstopper: it would serve as an example of how to get ghci to run custom code that you could implement the non emcas parts of slime
20:48:26 <skew> at least if you want to do fancy things like typechecking and binding analysis, and don't mind hacking on GHC a bit
20:48:40 <lispy> ah, right
20:48:44 <lispy> you'd want that
20:49:02 <lispy> because you want emacs to display the types in the message bar when you cursor over them
20:49:14 <skew> the wiki pages from the hackathon seemed pretty good, at least with Simon and Simon reading them
20:49:18 <lispy> similar to what visual haskell does (if you've used it)
20:49:18 <joelk> Well, thanks for the feedback. Gotta go for now.
20:50:07 <lispy> Bobstopper: thinking again, you probably need to combine both ghc-api with goa
20:50:22 <lispy> Bobstopper: have a goa component which is based on ghc-api
20:50:57 <skew> http://hackage.haskell.org/trac/ghc/wiki/Commentary
20:51:01 <lambdabot> Title: Commentary - GHC - Trac, http://tinyurl.com/ocuyo
20:51:17 <Bobstopper> Well, sounds like there's a lot of options anyway.
20:51:51 <Bobstopper> I'm thinking implementing the haskell ide as a sort of server which communicates with elisp via sockets or something (as slime does) might be a good way to go though.
20:51:53 <lispy> Bobstopper: yeah, and if you started hacking on it...i'm sure you could get help
20:52:01 <Bobstopper> That's basically what I mean by "use slime"
20:52:11 <Bobstopper> it'd only be the elisp part obviously :)
20:52:13 <lispy> yup, and we know it's possible and even popular
20:52:13 <skew> The most important things I got from the hackathon were 1) There is a make tags target!  2) It's okay to hack on GHC
20:52:47 <lispy> skew: heh, i thought it was 2) it's okay and PLEASE do it ;)
20:53:11 <lispy> i get the feeling the Simons feel overwhelmed with all the implementation work that could be going on
20:53:24 <skew> I think Epigram works by sending elisp to xemacs, maybe you could look through their sources
20:53:27 <lispy> it's good that they hired someone to help
20:55:31 <skew> lispy: there was a PLEASE in there, but I was trying to offer a smaller step from "sacred and impossibly arcane" ;)
20:55:48 <Bobstopper> Ah yeah. I think slime works similarly to that, only instead of elisp commands, it just uses a sort of language-independent protocol
20:57:42 <lispy> Bobstopper: i made some enemies in #lisp by ranting about what i didn't like about SLIME
20:57:54 <lispy> Bobstopper: so, if you go there asking for help...don't mention me :)
20:58:17 <phr-newbie> slime ?
20:58:22 <glguy_> can template-haskell be used in ghci?
20:58:30 <skew> yes, as long as you pass -fth
20:58:34 <glguy_> phr-newbie: it's a sweet lisp dev env
20:58:48 <phr-newbie> = SLIME, the Superior Lisp Interaction Mode for Emacs, is an Emacs mode for developing Common Lisp applications.
20:58:49 <phr-newbie> ?
20:59:16 <glguy_> yeah, you've heard of it?
20:59:22 <Bobstopper> yeah, that's it
20:59:29 <glguy_> (you are coming for lispy ?
20:59:32 <phr-newbie> no i just looked it up in wikipedia.  i wondered what you were talking about because slime was an old nickname for symbolics corp.
20:59:45 <phr-newbie> so i thought maybe you were running genera or something
20:59:54 <Bobstopper> lispy: heheh, I doubt I'll be asking them. I'd only be doing the elisp part of it so I'd be better off asking elisp people for help. Besides, I've found the #lisp community a little... unfriendly :)
21:00:01 <phr-newbie> actually i came here because i had a dumb newbie haskell question
21:00:11 <skew> glguy_: you don't even have to define your macros in a separate module if you use ghci
21:00:12 <lispy> Bobstopper: yeah, a bit unfriendly
21:00:25 <lispy> Bobstopper: #haskell on the other hand loves questions and new people
21:00:36 <glguy_> skew: TH  requires a separate module?
21:00:37 <phr-newbie> so is there a decent dev env for haskell?
21:00:51 <skew> glguy_: not really, but the stuff in Language.Haskell.TH helps
21:00:54 <lispy> glguy_: they call it the top level splice restriction
21:00:57 <Bobstopper> Yeah, so I noticed. That's one thing I really like about this place :)
21:01:15 <skew> glguy_: in a compiled program your macros have to come from some other previously-compiled module
21:01:24 <phr-newbie> well here's my newbie question: how do i get the nth element of a list, if n is an Integer (not an Int)?  xs !! n gets a type error
21:01:36 <glguy_> fromIntegral
21:01:42 <lispy> phr-newbie: emacs or vim is probably the best you'll find at the moment, but there is a lot of work to fix that.  Take eclipse-fp for example and visual haskell
21:01:45 <skew> phr-newbie: there's probably a function for that in Data.List
21:02:12 <lispy> ?hoogle [a] -> Int -> a
21:02:13 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
21:02:21 <lispy> ?hoogle [a] -> Integer -> a
21:02:22 <lambdabot> No matches, try a more general search
21:02:28 <glguy_> phr-newbie: list !! fromIntegral 1
21:03:05 <phr-newbie> hmm
21:03:08 <lispy> phr-newbie: one of the problems with using an Integer is that it may be larger than (!!) can index...you see for some silly reason you can only index so far even though the list may be much longer
21:03:17 <skew> there are many functions named Data.List.genericX which are like the prelude X but let you use any integral type instead of just Int
21:03:32 <dolio> Yeah, but there's no generic!!
21:03:38 <phr-newbie> lispy, thanks, that works, i wonder how it knows what to do, i mean i can also say (fromIntegral 2^222)
21:03:39 <skew> > [1..] `genericIndex` 2^100
21:03:41 <lambdabot>  515377520732011331036461129765621272702107522001
21:03:50 <dolio> You'd have to use something like head . genericDrop
21:03:51 <skew> > [1..] `genericIndex` (2^100)
21:03:55 <lambdabot> Terminated
21:03:57 <phr-newbie> wow!  how did it know that??!!!
21:03:59 <dolio> Oh, there is.
21:04:03 <lispy> phr-newbie: take a look at the type of fromIntegral and it should hepl to really confuse you
21:04:04 <skew> okay, that's what I was expecting...
21:04:05 <dolio> Well, there you go.
21:04:12 <lispy> ?type fromIntegral
21:04:14 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:04:38 <glguy_> > [0..] !! maxBound
21:04:42 <lambdabot> Terminated
21:04:46 <phr-newbie> > [1,3,..] !! 23
21:04:47 <lambdabot>  Parse error
21:04:53 <skew> although, [1..] `genericIndex` (2^100) optimizing down was vaguely plausible
21:04:55 <glguy_> if your number doesn't fit in an Int, you don't want to use it anyway
21:04:56 <phr-newbie> > [1,3..] !! 23
21:04:57 <lambdabot>  47
21:05:17 <phr-newbie> glguy, yeah, my application is something like
21:05:36 <lispy> heh, yeah [0..] !! maxBound is making my computer thrash and it's taking a long time (trying ghci locally)
21:05:37 <phr-newbie> f x | (x < 5) = [3,2,1,0,5] !! x
21:05:49 <phr-newbie>     | (x >= 5)    .... do big computation
21:05:57 <phr-newbie> where x can be a large number
21:06:11 <glguy_> phr-newbie: then it doesn't matter if you use fromIntegral or genericList
21:06:14 <glguy_> Index*
21:06:20 <lispy> phr-newbie: i would be so bold as to say, you can probably rewrite your application and be better off...
21:06:30 <phr-newbie> > [1..] `genericIndex` 2^100
21:06:32 <lambdabot>  515377520732011331036461129765621272702107522001
21:06:37 <phr-newbie> how did it know that??!!!!
21:06:45 <lispy> phr-newbie: usually if you're checking the length of a list and then indexing that's a bad sign
21:06:49 <skew> that's parsing as ([1..] `genericIndex` 2)^100
21:06:50 <glguy_> > 3 ^ 100
21:06:51 <lambdabot>  515377520732011331036461129765621272702107522001
21:07:01 <skew> > 2^100
21:07:03 <lambdabot>  1267650600228229401496703205376
21:07:14 <phr-newbie> lispy i don't see how else to do it, i think it's the right thing for this prob
21:07:22 <phr-newbie> do you use pastebin here?
21:07:27 <glguy_> @paste
21:07:27 <lambdabot> http://paste.lisp.org/new/haskell
21:07:33 <Bobstopper> > ([1..] `genericIndex` 2) ^ 100
21:07:34 <lambdabot>  515377520732011331036461129765621272702107522001
21:07:37 <lispy> ?where paste
21:07:38 <lambdabot> http://paste.lisp.org/new/haskell
21:08:02 <lispy> phr-newbie: okay, i haven't seen the code or the problem, just um...guessing :)
21:08:42 <lisppaste2> phr pasted "spellnum" at http://paste.lisp.org/display/27448
21:09:05 <glguy_> phr-newbie: mathschallenge?
21:09:06 <phr-newbie> it lets you say "spell 37" and gives you "thirty-seven" etc.
21:09:19 <phr-newbie> glguy, dunno about mathschallenge
21:09:23 <glguy_> kk
21:09:32 <phr-newbie> this question came up on comp.lang.python so i thought i'd try it in haskell
21:10:03 <phr-newbie> but the point is that i want the arg to be an Integer instead of an int, so the speller can do billions, trillions, quadrillions, etc.
21:10:18 <lispy> heh, cool
21:10:30 <lisppaste2> phr annotated #27448 with "python version" at http://paste.lisp.org/display/27448#1
21:10:30 <carp> does anyone have frag working?
21:10:35 <dolio> Hmm... why does ([1..] !! maxBound) use so much memory?
21:10:40 <phr-newbie> that's my python version
21:10:42 <glguy_> did the python list say to call -1 "minus one"?
21:10:49 <phr-newbie> no that was me
21:10:54 <lispy> carp: not at the moment, but i played it on osx the week it was released without problems
21:11:14 <lispy> carp: seems like i played it on debian at the same time...even took some screen shots
21:11:20 <carp> oh, cool
21:11:41 <ThreeQ> > divMod 5 2
21:11:42 <lambdabot>  (2,1)
21:12:03 <phr-newbie> hah, haskell has divMod built in?  i couldn't find that either
21:12:28 <glguy_> ?index divMod
21:12:28 <lambdabot> Prelude
21:12:31 <dolio> ?index (!!)
21:12:32 <lambdabot> Data.List, Prelude
21:13:13 <glguy_> ?type divMod
21:13:14 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:13:22 <glguy_> phr-newbie: you probably want:
21:13:24 <hyrax42_> common lisp format has the ~r directive
21:13:30 <glguy_> spell :: Integral a => a -> String
21:13:38 <hyrax42_> that prints numbers as words
21:13:57 <phr-newbie> String and not [Char] ?
21:14:02 <glguy_> they are the same
21:14:03 <dolio> ?fptools Data.List
21:14:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
21:14:06 <hyrax42_> type String = Char
21:14:11 <hyrax42_> I mean
21:14:12 <hyrax42_> [Char]
21:14:17 <glguy_> but since you are using it as a String and not a list of Chars, that's why
21:14:17 <glguy_> but
21:14:20 <glguy_> more importantly
21:14:23 <glguy_> Integral a => a
21:14:31 <glguy_> so that you can use Ints or Integers
21:14:38 <phr-newbie> it says -- Undefined type constructor "Integral"
21:14:54 <glguy_> phr-newbie: right
21:14:57 <lispy> right, that's a type class
21:14:59 <glguy_> it's Integral a => a
21:15:04 <glguy_> not Integral -> String
21:15:19 <phr-newbie> sorry, so i should say
21:15:23 <dolio> ?fptools GHC.List
21:15:24 <lambdabot> GHC.List not available
21:15:28 <phr-newbie> spell :: Integral a -> String    ?
21:15:32 <glguy_> close
21:15:36 <carp> i've built it with 6.5 on my macbook but it bus errors on startup
21:15:37 <glguy_> Integral a => a -> String
21:15:47 <glguy_> literal ^^
21:16:05 <phr-newbie> ERROR "num.hs":2 - Inferred type is not general enough
21:16:05 <phr-newbie> *** Expression    : spell
21:16:05 <phr-newbie> *** Expected type : Integral a => a -> String
21:16:05 <phr-newbie> *** Inferred type : Integral Int => Int -> String
21:16:14 <dolio> ?yarr
21:16:14 <lambdabot> Splice the Mainbrace!
21:16:36 <phr-newbie> because it saw i had !!n so it inferred n is Int
21:16:37 <glguy_> "Integral a => a -> String" means: Given some 'a' that is an instance of 'Integral', this function takes an 'a' and returns a string
21:16:39 <phr-newbie> i guess
21:16:51 <phr-newbie> yeah, but !! wants an Int
21:17:02 <phr-newbie> so i have to use fromIntegral, hmm, ugggg--lllly
21:17:03 <glguy_> phr-newbie: you already asked about that
21:17:11 <glguy_> phr-newbie: or use genericIndex
21:17:27 <glguy_> phr-newbie: or at hte bottom of all the spells
21:17:32 <glguy_> say: where n' = fromIntegral n
21:17:34 <lispy> carp: http://files.codersbase.com/tmp/screen3.png
21:17:41 <phr-newbie> oh cool that's better
21:17:59 <phr-newbie> i can put it at the bottom of all of them?  or do i have to combine all those guards into one definition?
21:18:21 <glguy_> phr-newbie: you should make all the guards one definition
21:18:27 <glguy_> and use the | otherwise
21:18:28 <glguy_> case
21:18:30 <glguy_> for the last one
21:18:38 <phr-newbie> ok
21:19:26 <glguy_> phr-newbie: " " ++ is the same as ' ' :   and is preferred because it does less
21:19:44 <glguy_> (note that only works for single characters)
21:19:53 <skew> you might keep it just for uniformity
21:20:02 <phr-newbie> hmm yeah that whole space thing is messy and i want to try to get rid of it
21:21:10 <glguy_> phr-newbie: you could return a list of words and the intersperse a space in between each:
21:21:26 <glguy_> > concat $ intersperse " " ["one","two","three"]
21:21:27 <lambdabot>  "one two three"
21:21:44 <phr-newbie> oh cool, that's like ' '.join in python
21:21:49 <glguy_> yes
21:22:14 <phr-newbie> >:t (concat $ intersperse)
21:22:21 <phr-newbie> hmm
21:22:30 <glguy_> that probably isn't what you want
21:22:39 <glguy_> do you know what $ does
21:22:53 <phr-newbie> not exactly
21:22:57 <phr-newbie> that's what i was trying to figure out
21:23:04 <glguy_> $ is just a replacement for ( )
21:23:06 <glguy_> for example:
21:23:23 <glguy_> > concat (intersperse " " ["a","b"])
21:23:25 <lambdabot>  "a b"
21:23:37 <glguy_> $ doesn't really do anything, but it has really low precedence
21:23:43 <glguy_> and it is right associative
21:23:50 <phr-newbie> > (concat . intersperse) " " "ab"
21:23:51 <lambdabot>    Expecting a function type, but found `b'
21:23:51 <lambdabot>    Expected type: a1 -> [[a]...
21:23:56 <phr-newbie> ?
21:24:05 <glguy_> phr-newbie: concat . intersperse " " $ [a,b]
21:24:05 <phr-newbie> (concat $ intersperse) " " "ab"
21:24:32 <phr-newbie> Hugs.Base> concat $ intersperse " " ("one", "two")
21:24:32 <phr-newbie> ERROR - Undefined variable "intersperse"
21:24:50 <glguy_> > (*2) $ (+1) $ (*3) 1
21:24:51 <lambdabot>  8
21:24:57 <phr-newbie> lol
21:25:08 <glguy_> that means 2* (1+ (3 * 1))
21:25:57 <glguy_> (a,b) is a tuple, [a,b] is a list
21:26:01 <skew> glguy_: " " ++ xs should compile just like ' ':xs. At least, ++ is exposed for inlining
21:26:14 <phr-newbie> f $ g x   = f(g(x))   but   f . g x = (f(g))(x)  ?
21:26:46 <skew> no, f . g x = \y -> f(g(x)(y))
21:26:48 <glguy_> f . g x means: f ( (g x) y)
21:26:56 <glguy_> where y is the next parameter
21:27:04 <phr-newbie> ok
21:27:05 <glguy_> like skew said
21:27:13 <glguy_> function application happens first
21:27:20 <glguy_> next operators
21:27:21 <skew> ?type (.)
21:27:22 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
21:27:24 <skew> ?type ($)
21:27:25 <lambdabot> forall b a. (a -> b) -> a -> b
21:27:40 <glguy_> f $ x = f x
21:27:51 <araujo> anybody knows where the 'lang' package is for ghc6.5?
21:28:00 <glguy_> f . g = \x -> f ( g  x )
21:28:38 <lisppaste2> phr annotated #27448 with "error version" at http://paste.lisp.org/display/27448#2
21:29:03 <phr-newbie> now i get a syntax error, it seems to not notice the end of the n < 100 case?
21:30:04 <glguy_> You'll have to paste what you have now
21:30:14 <phr-newbie> yeah, i just pasted it
21:30:29 <glguy_> k
21:30:50 <phr-newbie> it complains about the line starting n < 1000
21:30:55 <phr-newbie> saying it doesn't expect a | there
21:31:17 <glguy_> I don't remember but it could be that it doesn't expec the where yet
21:31:32 <phr-newbie> i can't have wheres inside the sub-expressions?
21:31:44 <glguy_> I believe that inside you'd want a let
21:31:54 <phr-newbie> oh.  hmm, that's ugly
21:31:54 <glguy_> let a = b in c
21:32:18 <glguy_> wheres are scoped across all the guards
21:32:25 <glguy_> lets are per-expression
21:32:45 <glguy_> if you want both worlds
21:32:51 <glguy_> you could put the spell n's back
21:32:59 <glguy_> and nest all of that inside another dummy function
21:33:14 <glguy_> and have a where that wraps all of the spell declarations
21:33:30 <glguy_> spell n = aux n where
21:33:40 <glguy_> and then do all the aux n = m where z
21:33:48 <glguy_> along with nn = fromIntegral n
21:34:31 <hyrax42_> ?type divMod
21:34:32 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:34:36 <hyrax42_> ?type remQuot
21:34:37 <lambdabot> Not in scope: `remQuot'
21:34:42 <hyrax42_> ?type quotRem
21:34:43 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:34:45 <lisppaste2> glguy annotated #27448 with "simple example" at http://paste.lisp.org/display/27448#3
21:34:51 <hyrax42_> I believe they are the same?
21:35:11 <glguy_> rem and mod are different for negative numbers
21:35:24 <hyrax42_> oh indeed
21:35:26 <phr-newbie> getting there
21:35:27 <glguy_> ?scheck liftM2 (==) rem div
21:35:28 <lambdabot>  add an instance declaration for (Eq (a -> a))
21:35:49 <glguy_> ?scheck liftM2 (==) (`mod` 3) (`rem` 3)
21:35:50 <lambdabot>  Add a type signature
21:35:55 <glguy_> ugh
21:36:03 <skew> ?scheck \x y -> rem x y == mod x y
21:36:03 <lambdabot>  Add a type signature
21:36:15 <glguy_> ?scheck (liftM2 (==) (`mod` 3) (`rem` 3) :: Int -> Bool)
21:36:16 <lambdabot>   Failed test no. 1. Test values follow.: -1
21:36:51 <glguy_> > liftM2 (,) (`mod` 3) (`rem` 3) -1
21:36:52 <lambdabot>  add an instance declaration for (Num (a -> (a, a)))
21:37:03 <phr-newbie> looks like i also needed fromIntegral a-2
21:37:14 <phr-newbie> i.e. divMod on Integer gave me Integer
21:38:18 <lisppaste2> phr annotated #27448 with "this almost works :)" at http://paste.lisp.org/display/27448#4
21:38:30 <glguy_> > liftM2 (,) (`mod` 3) (`rem` 3) (-1)
21:38:31 <lambdabot>  (2,-1)
21:38:35 <phr-newbie> i think most of the type stuff is correct now, i just have to fix the logic errors :)
21:38:50 * araujo can't find the lang pkg!
21:39:14 <skew> araujo: what do you need from it?
21:39:33 <araujo> skew, i need it to compile hsshellscript
21:39:44 <skew> araujo: have you tried compiling without it?
21:39:52 * edward1 waves hello.
21:39:53 <araujo> skew, yes
21:40:03 <araujo> and it fails not finding it :-P
21:40:08 <skew> I think the packages were reorganized
21:40:30 <skew> could you remove it from the .cabal or Makefile?
21:40:36 <araujo> let me see
21:40:59 <phr-newbie> Main> spell (6^66)
21:40:59 <phr-newbie> " two sextemdecillion two hundred eighty quinquadecillion two hundred fifty quattuordecillion three hundred nineteen tredecillion eight hundred sixty-seven duodecillion thirty-seven undecillion nine hundred ninety-seven decillion four hundred twenty-one nonillion eight hundred forty-two octillion three hundred thirty septillion eighty-five sextillion two hundred twenty-seven quintillion nine hundred seventeen quadrillion nine
21:40:59 <phr-newbie>  hundred fifty-six trillion two hundred seventy-two billion six hundred twenty-five million eight hundred eleven thousandfour hundred fifty-six"
21:41:00 <phr-newbie> Main>
21:41:00 <araujo> skew, shouldn't this package show in ghc-pkg list?
21:41:19 <dons> phr-newbie: hehe :)
21:41:27 <lisppaste2> phr annotated #27448 with "heh" at http://paste.lisp.org/display/27448#5
21:41:46 * glguy_ imagines writing this function as an unfoldr
21:42:03 <phr-newbie> glguy, hmm
21:42:14 * dons imagines writing all functions as an unfoldr
21:42:15 <skew> you might want to pull out some other sists of names
21:42:28 <phr-newbie> yeah i should pull out the small list
21:42:41 <edwardk> dons: ?
21:42:47 <dons> edwardk: !
21:42:52 <edwardk> dons: .
21:42:59 <dons> edwardk: *
21:43:09 <glguy_> I think they are kissing...
21:43:21 <glguy_> isn't that what the * in :-* means?
21:43:23 <edwardk> ok, now that we've enumerated all of the symbols for the  various modalities i'm playing with, now what? =)
21:43:47 <hyrax42_> ?type runReaderT
21:43:49 <lambdabot> forall a (m :: * -> *) r. ReaderT r m a -> r -> m a
21:43:52 <skew> or perhaps eating a lemon?
21:43:55 <phr-newbie> is there some good reason i can't use "where" inside arbitrary expressions?
21:44:08 <dons> yeah, its a declaration form, not an expression
21:44:12 <glguy_> phr-newbie: where is a declaration level form
21:44:23 <glguy_> phr-newbie: that's why I said that let was expression level
21:44:26 <dons> > let f x = x + 1 in 1 + 2 + f 3
21:44:27 <lambdabot>  7
21:44:33 <phr-newbie> yeah, i'm wondering if there was some reason they did it that way
21:44:43 <dons> (you could use let ... in .. if you wish)
21:44:54 <phr-newbie> yeah, i changed my example to use let instead of where, and it works now
21:44:56 <dons> yeah, sometimes I'd like to use 'where' as a post-fix expression-level let.
21:45:09 <glguy_> brb
21:45:20 <dons> (1 + 2 + f 3 where f x = x + 1) + 4
21:45:49 <araujo> mm...
21:45:50 <skew> There would be some ambiguit between that and the definition-level let
21:45:50 <edwardk> yeah. though, there are also times i'd like to be able to toss a type declaration or data statement in a where or let clause too, for quick testing.
21:45:54 <dons> does anyone know of a good reason (other than historical links with Miranda) that where isn't an expression form?
21:46:05 <araujo> skew, ok, it seemed to work after i tweaked a bit the makefile ....
21:46:07 <hyrax42_> ?type runState
21:46:09 <lambdabot> forall s a. State s a -> s -> (a, s)
21:46:18 <hyrax42_> ?t evalState
21:46:19 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
21:46:23 <phr-newbie> can i "let" something where there are guards?
21:46:26 <hyrax42_> ?type evalState
21:46:27 <edwardk> that i can at least understand in the context of them encouraging the use of model-level syntax for that sort of thing
21:46:27 <lambdabot> forall a s. State s a -> s -> a
21:46:33 <edwardk> er module
21:46:35 <skew> araujo: also, --make should figure out packages, at least with 6.5
21:46:43 <dons> > f x | x == 2 = let y = 3 in y -- ?
21:46:44 <lambdabot>  Parse error
21:46:51 <dons> > let f x | x == 2 = let y = 3 in y in f 7-- ?
21:46:52 <lambdabot>  Non-exhaustive patterns in function f
21:46:56 <dons> :)
21:47:24 <dons> phr-newbie: you can use 'let' wherever you can use other expressions
21:47:34 <araujo> skew, yes, it seemed so , though i needed to tweak (remove) the makefile to avoid using old pkgs names.
21:48:47 <phr-newbie> > :t intersperse
21:48:47 <lambdabot>  Parse error
21:49:09 <phr-newbie> > :t divMod
21:49:10 <lambdabot>  Parse error
21:49:13 <phr-newbie> ?
21:49:27 <phr-newbie> ?type divMod
21:49:28 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
21:49:38 <phr-newbie> ?type intersperse
21:49:40 <lambdabot> forall a. a -> [a] -> [a]
21:49:51 <phr-newbie> intersperse must be ghc-specific?
21:50:00 <dons> nope. its in Data.List
21:50:07 <dons> ?hoogle intersperse
21:50:08 <lambdabot> List.intersperse :: a -> [a] -> [a]
21:50:12 <dons> or List :)
21:50:23 <Korollary> ?index intersperse
21:50:23 <lambdabot> Data.List
21:50:39 <hyrax42_> ?type mapM_
21:50:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
21:51:33 <skew> phr-newbie: how about a program for calculating the bignames table?
21:52:27 <skew> looks like some kind of latin prefixes. How high could the romans count?
21:52:41 <dons> good question! hmm
21:52:44 <Korollary> not very
21:52:48 <dons> ?google how high could the romans count?
21:52:50 <Korollary> M is 1k
21:52:52 <lambdabot> http://www.lancashire.gov.uk/environment/historichighways/roman.asp
21:52:52 <lambdabot> Title: Lancashire County Council: Environment Directorate: Historic Highways
21:53:04 <skew> they drew bars and things
21:53:04 <Korollary> is there a 5K?
21:53:05 <dons> as high as Lancashire, apparently
21:53:06 <glguy_> more importantly , how low could they count?
21:53:10 <phr-newbie> skew, what do you mean calculate the bignames table?  you mean figure out the illions from "un", "duo", etc.?
21:53:10 <glguy_> did they get past 1?
21:53:16 <Korollary> glguy_: no
21:53:20 <Korollary> I have a link
21:53:22 <dons> not according to the ICFP contest :)
21:53:37 <dons> mmm qvickbasic
21:53:59 <Korollary> http://scienceblogs.com/goodmath/2006/08/roman_numerals_and_arithmetic.php
21:54:02 <lambdabot> http://tinyurl.com/zoncz
21:54:04 <phr-newbie> roman numerals used a horizontal line over the letter to multiply by 1000, so {\overline V} = 5000, {\overline M} = 1 million etc
21:54:47 <Korollary> The link says the overbars are a modernization.
21:55:21 <dons> yeah, i've heard that elsewhere
21:55:23 <skew> too bad, if they had positional notation they might have named very large powers of their base with a regular system of proto-indo-european prefixes
21:55:27 <phr-newbie> wow, i like that addition algorithm
21:55:40 <glguy_> which
21:55:50 <phr-newbie> the one at that scienceblog link
21:55:58 <Pseudonym> If the Romans had a zero, their programs would have been able to signal successful termination.
21:57:01 <glguy_> other operating systems use 0 are failure, don't they?
21:57:13 <dons> ?remember Pseudonym If the Romans had a zero, their programs would have been able to signal successful termination.
21:57:27 <Pseudonym> dons: That's not an original gag.
21:57:35 <glguy_> ?forget ...
21:57:36 <lambdabot> Unknown command, try @list
21:57:39 <dons> ah ok :}
21:57:46 <dons> darcs revert
21:58:02 <Korollary> Now it is. You are our Betsy Ross now
21:58:04 <Pseudonym> http://motd.ambians.com/quotes.php/name/linux_computers/toc_id/1-1-4/s/550
21:58:05 <Pseudonym> Top quote.
21:58:07 <lambdabot> Title: one of the main causes of the fall of the Roman - Linux Computers: 551 - 560 of  ..., http://tinyurl.com/mjetb
21:58:14 <phr-newbie> this is wrong?
21:58:16 <phr-newbie> intersperse :: a -> [a] -> [a]
21:58:16 <phr-newbie> intersperse sep [] = []
21:58:16 <phr-newbie> intersperse sep (x:xs) = [x,sep,intersperse sep xs]
21:58:34 <Pseudonym> Does it compile?
21:58:37 <phr-newbie> nope
21:58:42 <Pseudonym> Then it's wrong.
21:58:45 <phr-newbie>  unification would give infinite type
21:58:49 <ThreeQ> intersperse returns a list
21:58:52 <Pseudonym> The converse is not necessarily true, of course.
21:59:03 <phr-newbie> well x:sep:(intersperse sep xs) also didn't compile
21:59:04 <Korollary> think about the type of the third expression between commas
21:59:20 <phr-newbie> wait, now it does
21:59:29 <phr-newbie> i needed parentheses around x:xs
21:59:32 <glguy_> phr-newbie: also, you don't necessarily want a sep on the end
21:59:33 <Pseudonym> Ah, you're using the time-dependent type system extensions.
21:59:53 <phr-newbie> good point glguy
22:00:51 <phr-newbie> intersperse :: a -> [a] -> [a]
22:00:51 <phr-newbie> intersperse sep [] = []
22:00:51 <phr-newbie> intersperse sep [x] = [x]
22:00:51 <phr-newbie> intersperse sep (x:y:xs) = x:sep:y:(intersperse sep y:xs)
22:00:55 <phr-newbie> is that right?
22:01:06 <phr-newbie> nope :)
22:01:09 <Pseudonym> Does it compile?
22:01:10 <Pseudonym> :-)
22:01:21 <glguy_> sep [x] =[[x]]
22:01:36 <glguy_> ..
22:01:37 <glguy_> hmm
22:01:54 <glguy_> > intersperse undefined "test"
22:01:55 <lambdabot>  Undefined
22:02:00 <glguy_> heh
22:02:11 <glguy_> > intersperse undefined ["test"]
22:02:12 <lambdabot>  ["test"]
22:02:36 <Pseudonym> Here's a suggestion, BTW.
22:02:39 <phr-newbie> ehh had extra y: there
22:02:42 <Pseudonym> Patterns can be overlapping.
22:02:49 <Pseudonym> intersperse sep [] = []
22:02:52 <phr-newbie> but still wrong
22:02:56 <Pseudonym> intersperse sep [x] = [x]
22:02:58 <Pseudonym> All good so far.
22:03:00 <glguy_> yeah
22:03:02 <Pseudonym> And the third case can be:
22:03:06 <Pseudonym> intersperse sep (x:xs) = ...
22:03:12 <phr-newbie> hmm sec
22:03:19 <Pseudonym> It doesn't matter that the second and third cases are overlapping.
22:03:55 <Pseudonym> If you care about squeezing every cycle, though, it might make more sense to do it this way:
22:04:00 <Pseudonym> intersperse sep [] = []
22:04:03 <phr-newbie> heh, this works
22:04:04 <Pseudonym> intersperse sep [x] = [x]
22:04:08 <phr-newbie> intersperse sep (x:xs) = x:sep:(intersperse sep xs)
22:04:11 <phr-newbie> i mean it compiles
22:04:16 <Pseudonym> intersperse sep (x:xs) = x : intersperse' sep xs
22:04:30 <Pseudonym> Where intersperse' puts the separator on the front of a non-empty list.
22:04:44 <user317> is there an easy way to format strigs?  like ruby's "#{blah}" syntax
22:04:45 <Pseudonym> But get it right first. :-)
22:04:56 <user317> s/strigs/strings
22:05:12 <lispy> user317: so it's true, ruby does have blah syntax ;)
22:05:16 <lispy> user317: there is a printf module
22:05:33 <phr-newbie> intersperse sep (x:xs) = x:sep:(intersperse sep xs)     works and i think it's tail recursive
22:05:44 <phr-newbie> i don't see how the other version is faster?
22:05:46 <edwardk> :w
22:05:49 <edwardk> :w
22:05:50 <edwardk> :w
22:05:50 <edwardk> :q
22:05:54 <glguy_> lol
22:06:11 <glguy_> phr-newbie: dont thing it is tail recursive
22:06:20 <glguy_> i don't think*
22:06:26 <phr-newbie> hmm
22:06:33 <glguy_> thats okay
22:06:34 <Pseudonym> No, it's not tail recursive.
22:06:36 <Pseudonym> But it's cool.
22:06:47 <Pseudonym> It produces a lazy stream, which in Haskell is often more valuable.
22:06:58 <Botty> edwardk - haha, yeah, that's why i don't use those '1337' text editing programs that theoretically increases productivity
22:06:58 <lispy> edwardk: using vim to irc? ;)
22:07:09 <Pseudonym> ^X^C
22:07:23 <phr-newbie> well, if it's not tail recursive then the lazy stream eats more and more storage as it evaluates, right?
22:07:35 <Botty> and probably do, at the cost of the time to learn the bloody codes
22:07:51 <Pseudonym> phr-newbie: Only if it's not garbage.
22:07:59 <Pseudonym> But that's going to be true regardless.
22:08:10 <Pseudonym> It's a list that isn't garbage, therefore it's kept around.
22:08:27 <glguy_> when you use the text editor every day, it's worth the time it takes to learn
22:08:35 <glguy_> if you don't use it that often then I can see it not being so useful
22:08:46 <phr-newbie> example,    fibonacci = 0:1:zipWith (+) fibonacci (tail fibonacci)
22:08:50 <Pseudonym> It doesn't matter which text editor you use so long as you learn to use it well.
22:08:56 <Botty> true, but from what i've seen of those editors they look horrible as well
22:09:03 <phr-newbie> what does that compile to?
22:09:04 <Pseudonym> phr-newbie: That's a CAF.
22:09:07 <phr-newbie> CAF?
22:09:11 <Pseudonym> CAFs are special
22:09:11 <Botty> I'd rather do my eyes a favor and using something with a ui
22:09:18 <Pseudonym> Constant Applicative Form
22:09:26 <phr-newbie> whazzat?
22:09:47 <Pseudonym> Hard to explain, but the basic idea is it's not a function.
22:09:59 <Pseudonym> intersperse is.
22:10:02 <phr-newbie> i mean, i would have written     fibonacci = f 0 1 where f a b = a:f b (a+b)
22:10:04 <phr-newbie> is that a CAF?
22:10:15 <Pseudonym> Yes.
22:10:30 <Pseudonym> fibonacci :: [Integer]
22:10:31 <hyrax42_> hm
22:10:32 <phr-newbie> when i write the first version in python it takes exponential time
22:10:44 <hyrax42_> is it possible to have more than one fundep in a class declaration
22:10:52 <hyrax42_> like
22:11:23 <hyrax42_> class Foo a b f | f -> a b?
22:11:47 * hyrax42_ should try before he buys
22:11:52 <hyrax42_> works as expected
22:12:05 <Pseudonym> phr-newbie: The thing is, fibonacci isn't a function.
22:12:10 <Pseudonym> intersperse is
22:12:29 <dolio> hyrax42_: Something like that is possible.
22:12:31 <Pseudonym> So intersperse (at least the way it's written!) doesn't leak memory by virtue of existing.
22:12:40 <hyrax42_> dolio, yup, and it solved the problem
22:12:42 <dolio> If not f -> a b, then f -> a, f -> b
22:12:44 <Pseudonym> Because it's not a stream unless you give it some arguments.
22:12:52 <hyrax42_> f -> a b does it
22:13:04 <hyrax42_> and it's really illuminating to come across a problem solved by fundeps
22:13:14 <hyrax42_> I'd read descriptions of it multiple times
22:13:17 <hyrax42_> but never "got" it
22:13:30 <Pseudonym> C++-style overloading is the usual first example.
22:16:03 <user317> printf is pretty lame
22:16:18 <user317> the way this is done in nemerle is way better
22:16:20 <Pseudonym> Blame K&R.
22:16:47 <lispy> user317: if it's done better in, say, ruby, then just port it! haskell can do it i'm sure
22:16:54 <dibblego> what happens if I call readFile "/etc/passwd" on lambdabot?
22:17:05 <user317> lispy i dont know template haskell well enough
22:17:08 <lispy> dibblego: you'll get all teh passwords
22:17:19 <skew> > readFile "/etc/passwd"
22:17:19 <lambdabot>  No IO allowed
22:17:20 <Pseudonym> Try it.
22:17:21 <lispy> user317: i bet you wouldn't need it...printf is polyvaradic and doesn't need TH
22:17:29 <dibblego> I can't figure it outt
22:17:35 <dibblego> ?type readFile
22:17:37 <lambdabot> FilePath -> IO String
22:17:42 <Pseudonym> Scorecard: Type safety 1, dibblego 0
22:17:46 <dibblego> ?type FilePath
22:17:48 <lambdabot> Not in scope: data constructor `FilePath'
22:17:50 <hyrax42_> FilePath is type synonym for String
22:17:57 <user317> lispy, i want to be able to do putStrLn "this is the output $(valid haskell code)"
22:18:08 <dibblego> how do I get the String out of IO String using lambdabot ?
22:18:23 <hyrax42_> dibblego, lambdabot doesn't allow IO
22:18:28 <lispy> > do { s <- getLine; return s }
22:18:29 <lambdabot>  No IO allowed
22:18:37 <hyrax42_> and you can't "get the String out of IO String" anyhow
22:18:43 <hyrax42_> at least not completely
22:18:43 <lispy> dibblego: if you can find an exploit you'd be famous :)
22:18:45 <glguy_> lies!
22:19:10 <dibblego> so there is an explicit prevention of IO
22:19:11 <lispy> user317: you want to put code inside the strinG?
22:19:12 <lispy> hmm...
22:19:19 <lispy> user317: yes that might require template haskell
22:19:24 <skew> user317: the nemerle thing would be easy enough
22:19:39 <skew> and look something like $(printf "format %d") 1
22:19:39 <lispy> user317: but, i have to admit, i don't see the point
22:19:40 <user317> lispy, yea, thats how nemerle and ruby does it, its really handy, nemerle does type checking as well
22:20:08 <glguy_> user317: sounds like you found your language :)
22:20:32 <user317> glguy_, i found lots of languages
22:20:38 <skew> the only nemerle printf I've found by searching is a macro that does compile time checking on the format string
22:21:03 <dibblego> hyrax42_, what ae you alluding to?
22:21:13 <user317> skew, nemerle strings are created with $"foo $(nemerle code)"
22:21:18 <skew> ah
22:21:33 <hyrax42_> that there is now way to get values out of the IO monad
22:21:41 <hyrax42_> *no
22:21:58 <dibblego> so given IO String, you cannot get a String?
22:22:14 <skew> I wonder how far you could get hacking up something like that in TH just by feeding the bits in $() to a Haskell parser
22:22:24 <dolio> You can via monadic binding.
22:22:35 <user317> the silly part about printf, is why do i need to specify the type in the string?  why doesn't it just use Show
22:22:40 <dolio> (IO String) >>= f, where f is the function that takes a string.
22:22:52 <araujo> goodie! , made it working
22:23:04 * araujo probably could share this patch with upstream
22:23:12 <skew> if you just care about strings I'm pretty sure you could make something like (str "foo " (haskell code) " tail")
22:23:13 <Cale> user317: why not just use Show to begin with then? :)
22:23:24 <user317> Cale, because i want to format it for gnuplot
22:23:31 <hyrax42_> dibblego, well what is it you want to do with the "String out of IO String"
22:23:31 <lispy> dibblego: to leave the IO monad you'd have to do unsafePerformIO, but INSIDE the IO monad you can 'unwrap' a monadic value and use it like a normal one
22:23:59 <dibblego> hyrax42_, I don't know enough - I was just testing if I could learn someting
22:24:06 <skew> dibblego: you get the string "out" like iostring >>= return . functionOfString
22:24:15 * glguy_ thinks of it as describing what you would do if you had the string, which you don't :)
22:24:23 <lispy> ?type getLine
22:24:24 <lambdabot> IO String
22:24:37 <glguy_> fmap functionOfString iostring
22:24:47 <lispy> do { myString <- getLine; print (length string) }
22:25:00 <lispy> er (length myString)
22:25:19 <lispy> so inside that do block, you can use '<-' to 'get' a value out of the IO monad
22:25:24 <lispy> and once you do that it's normal
22:25:26 <skew> I wonder what printf would look like in Epigram
22:25:38 <glguy_> liftM (print . length) getLine
22:25:47 <glguy_> hmm
22:25:50 <lispy> but at the end of the do block the best you can do is return myString if you want to pass it on
22:25:56 <lispy> which puts it back into the IO monad
22:25:57 <skew> join $ liftM (print . length) getLine ?
22:26:08 <glguy_> ?type join $ liftM (print . length) getLine
22:26:09 <lambdabot> IO ()
22:26:31 <dibblego> is it expected of the HaXML distribution that you go flaffing about with make files to get it to compile or am I missing something?
22:26:32 <lispy> ?type do { myString <- getLine; return myString }
22:26:34 <lambdabot> IO String
22:26:50 <lispy> dibblego: 1.13 compiles cleanly for me
22:27:00 <lispy> dibblego: but other versions i've had less luck with
22:27:08 <dibblego> I have 1.113.2
22:27:13 <dibblego> 1.13.2
22:27:19 <lispy> good luck :)
22:27:26 <lispy> i haven't tried that one
22:27:31 <dibblego> I've conceded
22:27:33 <hyrax42_> ?type liftM (print . length) getLine
22:27:34 <lambdabot> IO (IO ())
22:27:47 <hyrax42_> oh woops
22:27:48 <glguy_> when monad comprehensions rise again, we will have [someFunc a | a <- getLine]
22:27:49 <hyrax42_> print not show
22:27:58 <lispy> ?type (print . length) `fmap` getLine
22:27:59 <lambdabot> IO (IO ())
22:28:02 <hyrax42_> glguy_ is that going to happen
22:28:03 <glguy_> hyrax42_: that's what the join is for
22:28:07 <hyrax42_> yeah I realised
22:28:17 <dolio> ?type (print . length) getLine
22:28:18 <hyrax42_> I thought it was String not IO ()
22:28:18 <lambdabot>   Couldn't match `[a]' against `IO String'
22:28:18 <lambdabot>    Expected type: [a]
22:28:29 <lispy> oh when you start doing liftM and join...
22:28:41 <lispy> ?type (join .) . liftM
22:28:43 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
22:28:50 <lispy> ?pl (join .) . liftM
22:28:51 <lambdabot> (=<<)
22:28:57 <lispy> just use bind!
22:29:01 <dolio> ?type fmap length getLine >>= print
22:29:03 <lambdabot> IO ()
22:29:12 <glguy_> print . length =<< getLine
22:29:40 <skew> I have no idea how types might work out if expressions are being embedded into strings
22:29:40 <lispy> ?pl flip $ (join .) . liftM
22:29:41 <lambdabot> (>>=)
22:29:53 <skew> doubly so if you also allow patterns, like the quasi-literal notation in E
22:30:13 <lispy> well, template haskell checks at compile time
22:30:21 <lispy> hmm..
22:30:22 <skew> It seems like you might need to also describe the grammar you expect, to get reasonable types
22:30:26 <lispy> yeah, still not sure though
22:30:52 <skew> like a parser producing a GADT, perhpas
22:31:22 <lispy> probably what you'd do is use an H98 parser to parse out the string, then splice that AST into some TH...which means you may need to wrap it up in some type like IO ()
22:31:56 <skew> I'm thinking about language support - doing it with a H98 parser gets a bit ugly around string quotation
22:32:37 <dibblego> what package contains the hugs-package executable?
22:32:48 <dibblego> hugs doesn't seem to have it
22:37:05 <Bobstopper> Man, it's impossible to get work done in Japan. Every 5 minutes some guy's knocking on your door trying to give you a business card...
22:37:22 <lispy> i want to go to japan
22:37:41 <weitzman> A friend of mine is doing a semester in Japan right now
22:37:49 <weitzman> Some strange tales
22:38:00 <weitzman> Particularly about the kinds of things they eat
22:38:05 <Bobstopper> It's pretty nice. Especially where I am. Way out in the rural part of Japan where you get the "real" culture and nature...
22:38:14 <Bobstopper> The food here rocks :D
22:38:32 <Bobstopper> prawn sashimi is so good
22:38:47 <weitzman> I'm sure you doing have to eat intestines and uteri and horses if you don't want to
22:39:22 <Bobstopper> haven't come accross uteri yet. Intestines I've tried, but I'd had them back in Australia too (chinese wife)
22:39:32 <skew> lots of buisness cards even in the rural areas?
22:40:06 <Bobstopper> Yeah. I've had 2 just today. That's a new record but it's still pretty common.
22:40:44 <weitzman> And apparently they have some pretty intense public path areas
22:40:49 <weitzman> *bath
22:41:13 <ThreeQ> haha, intense public path areas
22:41:27 <weitzman> If only!
22:41:38 <Bobstopper> Yeah, onsen are great. If you're obviously not japanese (eg white or black) you cop a few stares from people who have never seen a foreigner before (much less one naked) but they're still good
22:42:19 <weitzman> You mean to say the Japanese don't watch american martial arts films with poor voice dubbing?
22:43:16 <Bobstopper> The japanese curiousity about foreigners predominently lies in the size of their appendages. So unless it's an american martial arts porno film it probably wouldn't make much difference ;)
22:43:39 <glguy_> oh, like their fingers?
22:43:47 <Bobstopper> kinda ;)
22:45:17 <Bobstopper> The most humourous part of Japan is the public bin to vending machine ratio
22:45:18 * weitzman doesn't have the heart to @remember that
22:45:35 <Bobstopper> But anyway, this is #haskell. So I'll stop taking us off topic :)
22:45:50 <glguy_> off topic?
22:46:04 <dibblego> ?where hmake
22:46:04 <lambdabot> http://haskell.org/hmake
22:52:51 <dibblego> is the cabal manual available in pdf?
22:53:17 <zarvok> there's a cabal manual?
22:53:28 <dibblego> http://www.haskell.org/ghc/docs/latest/html/Cabal/
22:53:31 <lambdabot> Title: Common Architecture for Building Applications and Libraries, http://tinyurl.com/gcsep
22:53:46 <dibblego> found it
22:53:50 <zarvok> I bet that would have saved a lot of time when I wastrying to figure out cabal :)
22:55:46 <lispy> the cabal manual still needs better examples
22:56:01 <lispy> or maybe we need more cabal tutorials
22:56:16 <lispy> i've actually been trying to figure out how to improve the manual
22:56:35 <dons> should be pretty easy to turn hnop into a tutorial
22:56:35 <lispy> but...i'm sort of stuck at...how to fill the gap between reference and no knwoledge
22:57:19 <dons> glguy_: ok. i have to update my laptop now. new wireless card
22:57:20 <lispy> i was thinking starting from yeah, hello world and building up to something really complex where you're using autoconf + cabal
22:57:30 <dons> grr i hate wireless manufacturers
22:57:34 <dibblego> wtf is hnop?
22:57:46 <lispy> dibblego: it's a spoof
22:57:53 <lispy> dibblego: that turned into something useful :)
22:57:57 <dons> its a minimal haskell program + cabal wrapper
22:57:57 <glguy_> dons: new openbsd supports it?
22:58:00 <dibblego> I took a wireless card back to the shop the other day with the threat of invoking TPA1999 74(2)
22:58:00 <dons> ?where hnop
22:58:00 <weitzman> I'm going to guess what hnop is. It's a no-op implemented in Haskell
22:58:00 <zarvok> ?where hnop
22:58:00 <lambdabot> http://semantic.org/hnop/
22:58:00 <lambdabot> http://semantic.org/hnop/
22:58:04 <lispy> dibblego: it's a librarythat provides a nothing operation :)
22:58:06 <dons> glguy_: fingers crossed...
22:58:15 <dibblego> dons, you should be able to as well (assuming what your problem is)
22:58:15 <dons> should do, its the oldest model i could find.
22:58:19 <glguy_> dons: if any OS does, it's windows, otherwise it's openbsd
22:58:30 <dons> dibblego: yeah. i know.
22:58:38 <dons> i'm going to see if i can get it working first
22:58:43 <weitzman> I didn't expect my guess to be correct. That's interesting
22:58:54 <dibblego> dons, what sort is it?
22:58:56 <dons> they were all out of the really old prism cards the uni's been giving away for $10 :(
22:59:12 <phr-newbie> that's what ebay is for :)
22:59:31 <dons> netgear wg511 v2 :( recognised as a Marvell Libertas 88W8335 ....
22:59:35 <dons> so i'm not 100% confident
22:59:59 <dons> but there's been a lot of ath driver activity recently, so fingers crossed
23:00:14 <dibblego> so nhops is the basis from which to write any haskell app?
23:00:16 <dons> (had to return another ath card about a year ago for lack of drivers)
23:00:37 <glguy_> I think it's cool that openbsd has the best wireless driver support though
23:00:42 <dons> yeah
23:00:48 <glguy_> rather surprising
23:00:57 <dons> angry devs :)
23:02:10 <dibblego> dons, http://www.austlii.edu.au/au/legis/cth/consol_act/tpa1974149/s74b.html
23:02:11 <lambdabot> Title: TRADE PRACTICES ACT 1974 - SECT 74B Actions in respect of unsuitable goods, http://tinyurl.com/lzraj
23:02:41 <dons> i'm pretty sure the little uni bookshop will take it back anyway, if i have to do that
23:02:52 <dibblego> well I had a fight
23:02:53 <dons> just sucks they've stopped selling prism cards grr
23:02:59 <dibblego> with umart.com.au
23:03:09 <dibblego> they tried to charge me a "return fee"
23:03:24 <dons> you could try elx.com.au, they took back my last ath card no questions asked
23:03:40 <dons> they're supposed to be a linux shop, which helps
23:03:53 <dibblego> I'd already pre-empted it and printed out the legislation :)
23:03:56 <dons> heh
23:04:19 <dibblego> and I have contacts in A Current Affair!! :)
23:04:27 <dibblego> I only just thought of that then though
23:04:36 <dons> heh
23:04:44 <dibblego> I appeared a few months ago ranting
23:05:02 <dons> why am I only slightly surprised? :)
23:05:05 <dibblego> I have the mpg around here somewhere
23:05:14 <lispy> i have an ath card working in linux
23:05:24 <dibblego> :)
23:05:29 <lispy> the drivers i used were at sf.net and were based on code released by the company
23:05:45 <dons> boo
23:05:53 <dons> oh, yay (?)
23:06:00 <dibblego> come to think of it, it wasn't a DLink card I returned - it was exactly that one but v3
23:06:12 <dibblego> netgear wg511 v3
23:06:18 <dibblego> the DLink was the one I changed it for
23:06:30 <dibblego> apparently v2 works fine but v3 doesn't (iirc)
23:07:21 <dons> the one I had to take back was a D-Link Wireless Card (PCMCIA) DWL-G650
23:07:27 <Bobstopper> Is the version of as.exe that comes with ghc for windows an ordinary, unmodified gnu assembler?
23:07:32 <dons> but turned out to be a 5113 or something
23:07:43 <dons> v3 I suppose
23:08:21 <dibblego> I'ma have an early mark
23:08:22 <dibblego> later
23:08:25 <lispy> Bobstopper: i bet it's part of mingw unmodified
23:09:11 <Bobstopper> Oooh good point. Thanks.
23:09:21 * araujo likes the fact that now ghc implies '>>= print' for its expressions evaluations
23:09:56 <phr-newbie> heh, I got a runtime type error, i thought all this static type checking stuff was supposed to make that impossible
23:10:00 <dons> glguy_: soon i'll know if your ghc patch _really_ works :)
23:10:00 <araujo> I can think of nifty tricks with it :-)
23:10:11 <dons> phr-newbie: not all runtime errors are checkabel statically :)
23:10:16 <dons> halting problem, and all that...
23:10:23 <phr-newbie> yeah, but TYPE errors?
23:10:29 <araujo> phr-newbie, what did you get exactly?
23:10:34 <dons> you can't get type errors at runtime
23:10:42 <dons> there's no types around to be in error
23:10:48 <glguy_> > head []
23:10:49 <dons> ?paste
23:10:50 <lambdabot>  Add a type signature
23:10:50 <lambdabot> http://paste.lisp.org/new/haskell
23:10:51 <phr-newbie> intersperse :: String -> [String] -> [String]
23:10:51 <phr-newbie> intersperse sep [] = []
23:10:51 <phr-newbie> intersperse sep [x] = [x]
23:10:51 <phr-newbie> intersperse sep (x:xs) | x == "" = intersperse sep xs
23:10:51 <phr-newbie>                        | otherwise = x:sep:(intersperse sep xs)
23:11:02 <phr-newbie> Main> intersperse "." "abcde"
23:11:02 <phr-newbie> ERROR - Type error in application
23:11:02 <phr-newbie> *** Expression     : intersperse "." "abcde"
23:11:02 <phr-newbie> *** Term           : "abcde"
23:11:02 <phr-newbie> *** Type           : String
23:11:03 <glguy_> > head [] :: ()
23:11:04 <phr-newbie> *** Does not match : [String]
23:11:06 <lambdabot>  Exception: Prelude.head: empty list
23:11:22 <dons> phr-newbie: that's a static error, caught by the type system.
23:11:33 <dons> ?type intersperse
23:11:35 <lambdabot> forall a. a -> [a] -> [a]
23:11:45 <dons> > intersperse '.' "abcde"
23:11:46 <phr-newbie> no it only happens when i try to run the function
23:11:46 <lambdabot>  "a.b.c.d.e"
23:12:09 <dons> try putting it in a file and compiling it....
23:12:14 <araujo> Right, and ghci checks its type phr-newbie
23:12:15 <phr-newbie> it is in a file
23:12:23 <phr-newbie> i'm using hugs, should i switch to ghci?
23:12:43 <Bobstopper> it's your running of the function, not the function itself that's the problem.
23:12:43 <dons> your intersperse function looks fine. but you're calling it incorrectly.
23:12:51 <dons> intersperse "." "abcde" is a type error.
23:12:59 <dons> intersperse "." ["abcde"] wouldn't be
23:13:23 <dons> i.e. the code that you're typing in at the prompt is being checked, and there's a type error, before you run it.
23:13:28 <phr-newbie> oh i see, sorry
23:13:48 <dons> (when you're in an interactive environment type checking happens just prior to evaluation, remember)
23:13:54 <phr-newbie> thanks np
23:13:59 <phr-newbie> yeah i had a brainfart
23:14:24 <phr-newbie> is there a buiilt-in intersperse function i can import somehow?
23:14:37 <dons> Data.List.intersperse
23:14:43 <dons> ?hoogle intersperse
23:14:43 <lambdabot> List.intersperse :: a -> [a] -> [a]
23:14:45 <Syzygy-> > intersperse '.' "absde"
23:14:48 <lambdabot>  "a.b.s.d.e"
23:14:49 <phr-newbie> so i say "import Data.List.intersperse"?
23:14:51 <lispy> concat (intersperse "." (map (\x -> [x]) "abcde")) -- this is probably what you want
23:14:56 <dons> import Data.List
23:14:58 <Syzygy-> @hoogle intersperse
23:14:59 <lambdabot> List.intersperse :: a -> [a] -> [a]
23:15:05 <lispy> ah, yeah or Syzygy-'s version
23:15:11 * lispy goofed on that one :)
23:15:15 <dons> ?pl \x -> [x]
23:15:15 <lambdabot> return
23:15:19 <dons> heh
23:15:22 <dblhelix> or import Data.List (intersperse), if you want to restrict the set of imported symbols to intersperse
23:15:31 <Syzygy-> > return '.' :: [Char]
23:15:32 <lambdabot>  "."
23:15:33 <dblhelix> @seen SyntaxNinja
23:15:34 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 11h 9m 33s ago, and .
23:15:39 <lispy> i thought about using return but was afraid of confusing people :)
23:15:49 <dons> > (:[]) '.'
23:15:50 <lambdabot>  "."
23:16:02 <dons> ?type ( ( ( (:[]) :) :) :)
23:16:04 <lambdabot> forall a. [[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]] -> [[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]]
23:16:11 <dons> my favourite martian
23:16:26 <lispy> why martian?
23:16:38 <phr-newbie> import Data.List
23:16:38 <phr-newbie> foo sep strlist = concat $ intersperse (filter (/= "") strlist)
23:16:43 <lispy> great type signature though
23:16:47 <dons> why not? I presume martians to have faces like:  :[]
23:16:47 <phr-newbie> ERROR "num.hs":43 - Syntax error in input (unexpected keyword "import")
23:16:48 <phr-newbie> Hugs.Base>
23:16:51 <Bobstopper> hee hee it looks like a gorilla smiley
23:16:55 <dons> or maybe that's cylons
23:16:58 <lispy> dons: lol
23:17:20 <phr-newbie> do i have to put "import" at the top of the file?
23:17:21 <lispy> to me it looks like ripples on a pond
23:17:26 <lispy> caused by a [[
23:17:28 <lispy> er []
23:17:35 <dons> phr-newbie: yeah. "import Data.List"
23:18:08 <lispy> ?pl flip flip filp
23:18:08 <lambdabot> flip flip filp
23:18:11 <lispy> ?pl flip flip filp flip
23:18:11 <lambdabot> flip flip filp
23:18:11 <phr-newbie> yeah, i tried putting the import down where near i wanted to use intersperse
23:18:16 <phr-newbie> and the compiler barfed
23:18:24 <lispy> that's one of my favorites...you only need 3 flips :)
23:18:25 <dblhelix> @ask SyntaxNinja how can I set haddock's --title option from a cabal package description?
23:18:26 <lambdabot> Consider it noted.
23:18:30 <Bobstopper> haskell-based rorschach tests
23:18:33 <Syzygy-> lispy: Shouldn't flip flip flip == flip ?
23:18:34 <ThreeQ> ?pl flip flip flip
23:18:35 <lambdabot> flip flip flip
23:18:40 <dons> ?type flip
23:18:43 <Syzygy-> ?pl flip flip flip flip
23:18:43 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
23:18:43 <lambdabot> flip flip flip
23:18:45 <dons> ?type flip flip flip
23:18:47 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
23:18:50 <lispy> Syzygy-: no becouse of how it binds
23:18:53 <int-e> but filp isn't flip ...
23:18:54 <Syzygy-> Ah
23:19:00 <lispy> ?type flip (flip flip)
23:19:02 <lambdabot> forall a a1 c. (a1 -> a -> c) -> a -> a1 -> c
23:19:08 <dons> ?type flip (flip id)
23:19:09 <lambdabot> forall a c. (a -> c) -> a -> c
23:19:10 <lispy> ?type flip flip flip
23:19:12 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
23:19:13 <dons> ?type id
23:19:14 <lambdabot> forall a. a -> a
23:19:21 <lispy> ?pl flip (flip flip)
23:19:22 <dons> ?type flip id
23:19:22 <lambdabot> flip
23:19:23 <lambdabot> forall b c. b -> (b -> c) -> c
23:19:30 <dons> this channel is full of wackos
23:19:34 <dolio> ?type fix flip
23:19:36 <lambdabot> forall a c. a -> a -> c
23:19:41 <phr-newbie> is this reasonable?   foo sep strlist = concat $ intersperse sep (filter (/= "") strlist)
23:19:48 * dons looks at screens full of flip flip fix flip id flip flip :[] :) :)
23:19:55 <lispy> hehe
23:20:03 <phr-newbie> i want foo '.' ["abc", "', "def"] to be  "abc.def"
23:20:08 <lispy> ?vixen weirdos?
23:20:09 <lambdabot> no
23:20:19 <rindolf> Hi all! Why does this: http://sial.org/pbot/20214 generate a stack overflow?
23:20:21 <lambdabot> Title: Paste #20214 from "rindolf" at 88.155.15.113
23:20:43 <dons> > let f s = concat . intersperse s . filter (/= "") in f '.' ["abc", "', "def"]
23:20:44 <lambdabot>  Improperly terminated string
23:20:49 <dons> > let f s = concat . intersperse s . filter (/= "") in f '.' ["abc", "", "def"]
23:20:50 <lambdabot>  Couldn't match `[Char]' against `Char'
23:20:56 <dons> phr-newbie: so no :)
23:20:59 <phr-newbie> oops typo
23:21:14 <phr-newbie> i meant foo '.' ["abc", "", "def"] to be  "abc.def"
23:21:29 <phr-newbie> yeah
23:21:33 <lispy> phr-newbie: are you sure about the middle ""
23:21:37 <dons> rindolf: could be the foldl ? try a foldl' instead
23:21:59 * lispy almost said that without even looking at the url :)
23:22:00 <phr-newbie> lispy, yeah, the idea is i want to take a list of strings, some of which are null, throw away the null ones, and intersperse separators in the rest
23:22:09 <dons> rindolf: otherwise, compile with -O -prof -auto-all, run it with +RTS -p -RTS, and looks at the foo.prof file
23:22:39 <phr-newbie> so for example 10000100 => ["one million", "", "one hundred"] => "one million one hundred"
23:22:44 <phr-newbie> the null string is because there are zero thousands
23:23:01 <skew> unwords . filter (not . null)
23:23:07 <ThreeQ> concat . filter (not . null) ?
23:23:11 <lispy> why not ["one million", "zero thousands", ...]
23:23:36 <lispy> or, not put in nulls
23:23:43 <skew> one million zero hunderty zeroty zero thousands one hundred zeroty zero
23:23:46 <lispy> i mean, how do they even get in there?
23:23:47 <phr-newbie> this is the same function as before, i wouldn't want 10000100 printed as "one million zero thousand one hundred"
23:23:51 <phr-newbie> skew :)
23:24:11 <ThreeQ> yeah, you could probably avoid it by not putting them there in the first place
23:24:12 <rindolf> dons: where can I finhd foldl' ?
23:24:22 <phr-newbie> ThreeQ, hmm
23:24:24 <lispy> rindolf: Data.List
23:24:31 <rindolf> lispy: OK.
23:24:33 <lispy> rindolf: import Data.List ( foldl' )
23:24:42 <dons> ?hoogle foldl'
23:24:43 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
23:24:43 <Botty> wouldn't it be funny if lambdabot was a person?
23:24:48 <dons> ?vixen-on
23:24:48 <lambdabot> What's this channel about?
23:24:56 <dons> haskell!
23:24:56 <lambdabot> church is my favourite computer scientist.
23:24:59 <lispy> lambdabot: all sortsof things
23:25:13 <dons> lispy: too smart for you
23:25:13 <lambdabot> there are a lot of weirdos on here
23:25:17 <int-e> Botty: noo, she'd sleep and neglect us for 'real life'. ;)
23:25:17 <lambdabot> why me? :)
23:25:27 <Botty> lol
23:25:27 <lambdabot> do i amuse you?
23:25:35 <Botty> sort of
23:25:35 <lambdabot> Most guys don't understand me, but we really seem to connect.
23:25:55 <int-e> quick, pull the plug!
23:25:55 <lambdabot> i drive a pickup truck
23:25:58 <dons> ?vixen-off
23:25:58 <lambdabot> Bye!
23:26:10 <phr-newbie> ThreeQ, yeah, looks like i can do that, it was harder in the old version
23:26:18 <rindolf> Well, the conversion to fold' doesn't help.
23:26:26 <dons> rindolf: better profile then.
23:26:31 <dons> you got ghc installed?
23:26:31 <carp> dons: do you know any reason why frag would bus error with ghc-6.5 on mac intel?
23:26:45 <dons> carp: hmm. sounds like a ghc bug? or maybe a opengl issue?
23:27:09 <rindolf> dons: yes, I do.
23:27:13 <rindolf> Failed to load interface for `Prelude':
23:27:27 <dons> you don't have the profiling libraries installed
23:27:34 <lispy> dons: what if it thought it should be one endian because of mac but was wrong because of intel?
23:27:38 <dons> better get them from your local ghc package distributer
23:27:39 <int-e> . o O ( addPhrase key my_map = insertWith (+) key 1 my_map  ... sigh. )
23:27:40 <rindolf> dons: OK.
23:27:55 <dons> int-e: ah could be.
23:27:56 <lispy> wonder ifthat couldcause buserrors
23:28:05 <dons> int-e: insertWith' ?
23:28:34 <int-e> maybe, but that's a rather recent addition, isn't it?
23:28:38 <dons> yup
23:28:45 <int-e> lookup + seq + insert is an alternative.
23:29:14 <mwc> I'm readnig Appel's Compiling with Continuations. He claims that SML is better at using data immutably, since evaluation of a thunk looks like destructive update to certain phases of the compiler
23:29:16 <mwc> wtf?
23:29:27 <mwc> He specifically mentions haskell there
23:30:01 <dons> ghc does destructive updates though...
23:30:10 <dons> kind of the whole point of ghc :)
23:30:33 <int-e> and strictness analysis is about avoiding them.
23:30:43 <int-e> :)
23:32:23 <int-e> hmm, where'd rindolf go ... bah.
23:32:50 <dolio> He turned into a llama, apparently.
23:33:00 <skew> Smerdyakov has been up to some interesting things lately
23:33:32 <skew> http://www.eecs.berkeley.edu/~adamc/papers/CertVerICFP06/
23:33:36 <lambdabot> Title: Modular Development of Certified Program Verifiers with a Proof Assistant, http://tinyurl.com/rk9gn
23:33:42 <skew> http://www.eecs.berkeley.edu/~adamc/papers/LaconicTR/
23:33:44 <lambdabot> Title: Scrap Your Web Application Boilerplate, or Metaprogramming with Row Types, http://tinyurl.com/lskqx
23:35:34 <phr-newbie> how do i concatenate two lists?  like [1,2,3] [4,5] => [1,2,3,4,5]
23:35:43 <skew> ++
23:35:48 <phr-newbie> oh cool
23:35:49 <phr-newbie> thanks
23:36:17 <dons> you could find this with hoogle, since you know the type must be : [a] -> [a] -> [a]
23:36:23 <dons> ?hoogle [a] -> [a] -> [a]
23:36:25 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
23:36:25 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
23:36:25 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
23:37:34 <Bobstopper> I'm about ready to give up trying to get ghc to compile useful stuff under wine. I should probably scrap or ammend that overly optimistic wiki page I wrote.
23:37:43 <dons> hehe
23:37:52 <dons> you got ghci running though?
23:38:01 <dons> i.e. running a windows ghci under linux?
23:38:04 <Bobstopper> Does anyone have any other suggestions on how to compile programs for windows... without actually having to get the silly thing?
23:38:23 <gour> Bobstopper: wine?
23:38:33 <Bobstopper> Nah, ghci wouldn't start because it couldn't set buffering
23:39:08 <gour> Bobstopper: then, something like qemu, win4lin, vmware...
23:39:18 <dons> oh, that buffering issue is fixed in 6.6, iirc
23:39:52 <Bobstopper> Ah yeah. The buffering isn't a big deal. The big deal seems to be the assembler
23:40:08 <Bobstopper> It seems to be picky about the size of the assembly files it's reading or something.
23:40:46 <Bobstopper> I have program with a series of definitions and it compiles fine. I can export 7 of the functions but as soon as I try to export an 8th it dies horribly
23:41:01 <Bobstopper> I can also export all my function definitions if I trim them suitably.
23:41:15 <Bobstopper> It seems pretty random
23:43:00 <Bobstopper> gour: I might look at win4lin. The others will probably require me to get windows to run under the emulator though, right?
23:43:28 <gour> Bobstopper: what cpu you have?
23:43:44 <Bobstopper> x86
23:43:50 <Bobstopper> CPU's not a problem, just the OS
23:44:11 <gour> Bobstopper: well, it's (for me having amd64)
23:44:28 <gour> Bobstopper: win4lin uses qemu technology which is free http://fabrice.bellard.free.fr/qemu
23:44:31 <lambdabot> Title: QEMU
23:44:52 <Bobstopper> d'oh, win4lin is a virtual machine requiring a legit copy of windows too.
23:45:02 <gour> due to amd64 i could not use old win4lin, and win4lin pro was too slow
23:45:35 <gour> Bobstopper: only, afaik, wine does not require m$ license
23:46:01 <Bobstopper> Yeah. That's why I had big hopes for wine :(
23:46:18 <musasabi> morning
23:46:53 <Bobstopper> at least GHC itself seems ok under wine (other than ghci's buffering). It's the asm which isn't ghc's fault.
23:46:54 <lisppaste2> phr annotated #27448 with "whole thing works now, anyone take a look?" at http://paste.lisp.org/display/27448#6
23:47:29 <musasabi> Bobstopper: I get the assembler bugs under wine too.
23:47:55 <musasabi> e.g. C2HS triggers them.
23:47:59 <Bobstopper> phr-newbie: congratulations. Tried running quicktest on it? That'll tell you if it's really working ;)
23:48:12 <phr-newbie> quicktest?
23:48:24 <phr-newbie> actually i think i see a bug :)
23:48:52 <phr-newbie> hmm, it's accidentally a non-bug :)
23:49:21 <carp> Does anyone else have a intel mac and a frag?
23:49:23 <phr-newbie> the haskell program is longer than the python equivalent.  is that a bad sign?
23:49:58 <Bobstopper> musasabi: so you only get them for .hsc files? (am I understanding c2hs's use properly?)
23:50:00 <musasabi> Bobstopper: did you check ghc -v to make sure GHC is invoking the version of GCC shipped with it?
23:50:07 <carp> I was hoping to dazzle my students with it
23:50:23 <musasabi> Bobstopper: no. Trying to compile C2HS itself.
23:50:41 <Bobstopper> Oh I see
23:50:45 <carp> and intel mac and frag...
23:50:49 <skew> phr-newbie: how much of it is making up for the string-handling library?
23:50:54 <dons> phr-newbie: one idea, bignames =["thousand"] ++ illions
23:50:54 <dons>  where illions = map (++"illion") $
23:50:54 <dons>             ["m", "b", "tr", "quadr",
23:50:59 <dons> ...
23:51:02 <carp> can't speak
23:51:06 <phr-newbie> dons, hmm, yeah, that's cool
23:51:44 <skew> unless you have to replace lots of things that came from a library, probably the Haskell should be shorter
23:52:20 <dons> phr-newbie: and,
23:52:21 <dons> big n d = big a (d+1) ++ s
23:52:21 <dons>  where s | b /= 0    = [spell b ++ " " ++ bignames !! d]
23:52:21 <dons>          | otherwise = []
23:52:22 <dons>        (a,b) = n `divMod` 1000
23:52:22 <Bobstopper> Yyyyeap... looks like the right gcc
23:52:47 <dons> there's nicer ways to do some of the thing in there. keep refactoring :)
23:53:37 <musasabi> Bobstopper: then it might make sense to 1) try whether a recent 6.5 snapshot has also problems, 2) file a bug with instructions how to reproduce it.
23:53:39 <phr-newbie> bignames ="thousand" : [(f ++ "illion") | f <- ["m","b","tr","quadr",
23:53:39 <phr-newbie>                         "quadr", "quint", "sext", "sept",
23:53:39 <phr-newbie>                         "oct", "non", "dec", "undec",
23:53:39 <phr-newbie>                         "duodec", "tredec", "quattuordec",
23:53:39 <phr-newbie>                         "quinquadec", "sextemdec", "septemdec",
23:53:40 <phr-newbie>                         "octodec", "novemdec", "vigint"]]
23:54:05 <dons> i'd think: map (++"illion") $ ["m" ,...
23:54:06 <dons> is nicer
23:54:06 <Syzygy-> Ooooh. This reminds me - maybe haskell is a good environment to do a rewrite of my old hodie in...
23:54:17 <Bobstopper> File the bug against what though I wonder? I suspect it's a mingw issue rather than ghc
23:54:20 <dons> bignames ="thousand" : map (++"illion") ["m","b",....
23:54:37 <dons> the list comp is just a verbose map, after all :)
23:54:52 <Bobstopper> A recent snapshot will require building GHC under wine. I can see that's going to be fun...
23:54:54 <phr-newbie> dons, hmm, yeah i guess it's a python habit
23:55:08 <skew> you don't need $ in there
23:55:09 <musasabi> Bobstopper: it seems to me that the mangler has problems with the code GCC is emitting.
23:55:24 <dons> phr-newbie: now you get to play with list comps in their full glory :)
23:55:45 <dons> does python have parallel list comprehensions , I wonder?
23:55:50 <skew> unwords == concat $ intersperse " "
23:56:06 <phr-newbie> dons, parallel listcomps?
23:56:09 <Bobstopper> musasabi: if you pass a -S flag to ghc you can get it stop compilation once it's output assembly. From what I've seen the assembly looks fine and the errors from as.exe don't match what's actually in the file. So I think it's a problem with as.exe.
23:56:36 <phr-newbie> you mean like [a,b for a,b in zip(list1, list2)] ?
23:56:37 <dons> [ (a,b) | a <- xs | b <- ys ]  ==  zip xs ys
23:56:45 <dons> yup, sugar for zip
23:56:49 <dons> for map . zip
23:57:02 <musasabi> Bobstopper: GHC postprocesses the assembler produced by GCC. This stage is called the mangler and is the one failing AFAIK.
23:57:09 <dons> and can you put guards in list comps in python?
23:57:14 <skew> except you can only filter the lists before the zip
23:57:26 <dons> > [ a | a <- [1..], a `mod` 2 == 0 ]
23:57:30 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
23:57:39 <phr-newbie> dons yeah you can have guards, but i don't think the zip sugar is there, you get nested listcomps if you write something like that
23:57:43 <skew> that they have, but what about lets?
23:57:43 <Bobstopper> musasabi: I get the same errors if I run as.exe directly on the assembly output
23:57:59 <dons> > [ b | a <- [1..], let b = a `mod` 2 == 0 ]
23:58:00 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
23:58:13 <phr-newbie> >>> print [a for a in range(20) if a%2 == 0]
23:58:13 <phr-newbie> [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
23:58:26 <dons> skew: would be hard without an expression-level binding form?
23:58:40 <dons> phr-newbie: can you bind variables in the list comp?
23:58:52 <dons> like the above 'b'?
23:58:55 <musasabi> Bobstopper: hmm ok. If you compile to .hc and then compile that by hand with wine gcc using the flags from the GHC -v output does it fail in the assembler stage?
23:58:57 <phr-newbie> dons, nah, it was a battle royal to even get nested functions in python
23:59:02 <dons> heh
23:59:18 <phr-newbie> well i guess you could have nested functions but they weren't lexically scoped
23:59:26 <phr-newbie> until a few releases ago
23:59:29 <dons> > [ (a,b) | a <- [1..] , b <- ['a'..'z'] ] -- nested you mean?
23:59:30 <Bobstopper> I'll give that a try
23:59:32 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(1,'e'),(1,'f'),(1,'g'),(1,'h'),(1,'i'),(1,...
