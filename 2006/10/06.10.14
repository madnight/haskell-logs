02:15:24 <JohnMeacham> cabs are so nice here. I forgot my wallet and they let me get a ride for free. I feel real bad though. I'm gonna tip extra well next time.
02:16:08 <wilx> Heh, nice.
02:16:19 <wilx> That would never happen in Prague.
02:16:26 <wilx> Prague's Taxi services are like mafia.
02:16:33 <wilx> Most of them, anyway.
02:18:09 <JohnMeacham>  feel bad. I thought I had another 20, but I did not.
02:18:40 <JohnMeacham> do you live in prauge? that is the city that americans that want to sound fancy name-drop.
02:19:33 <JohnMeacham> "Well, When I was in prauge..." - these are also the people that fake british accents because they think it makes them sound exotic....
02:19:48 <wilx> Yeah, I live here.
02:19:51 <wilx> Heh.
02:19:56 <JohnMeacham> ah. how is it?
02:21:10 <wilx> Big? Dunno, I have moved here from country because of uni.
02:21:27 <wilx> I honestly do not understand what all the tourists see here that they come in such numbers.
02:21:35 <JohnMeacham>  are there a lot of annoying american tourists there? I ask because I have met a lot of annoying americans who say they visit there...
02:22:08 <JohnMeacham> ah. cool.
02:22:34 <JohnMeacham> sorri. I am pretty drunk.
02:22:43 <JohnMeacham> good times though. :)
02:22:47 <wilx> Probably, but they all end up in tourist trap clubs and restaurants around the Lesser Town.
02:23:59 <JohnMeacham> I see. makes sense.
02:24:47 <JohnMeacham> I do need to travel more. if I am in prauge, I'm gonna look you up and you have to show me the non tourist trap places to have fun. :)
02:25:13 <wilx> Heh, maybe :)
02:25:27 <wilx> I am not exactly a party animal :)
02:25:37 <JohnMeacham> of course I will do likewise if you find yourself in southern california.
02:39:50 <jmmv> hi
02:44:51 <JohnMeacham> hello!
03:01:13 <roconnor> @scheck
03:01:13 <lambdabot>  Parse error
03:01:34 <roconnor> @scheck a == (a:Bool)
03:01:35 <lambdabot>  Not in scope: data constructor `Bool'
03:01:38 <roconnor> @scheck a == (a::Bool)
03:01:39 <lambdabot>  Not in scope: `a'
03:01:50 <roconnor> @help scheck
03:01:51 <lambdabot> scheck <expr>
03:01:51 <lambdabot> You have SmallCheck and 3 seconds. Test something.
03:02:04 <roconnor> @scheck a == (a::Int)
03:02:05 <lambdabot>  Not in scope: `a'
03:02:13 <roconnor> @scheck \a -> a == (a::Int)
03:02:14 <lambdabot>  Completed 10 test(s) without failure.
03:02:22 <roconnor> @scheck \a -> a == (a:: Bool)
03:02:23 <lambdabot>  Completed 2 test(s) without failure.
03:02:53 <dmead> if someone tells lambdabot to eval an infinite list what happens?
03:03:06 <roconnor> @scheck \a b c-> ((a == b) == c) == (a == (b == (c::Bool))
03:03:06 <lambdabot>  Parse error
03:03:12 <tora> > [1..]
03:03:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:03:19 <dmead> ah
03:03:26 <roconnor> @scheck \a b c-> ((a == b) == c) == (a == (b == (c::Bool)))
03:03:28 <lambdabot>  Completed 8 test(s) without failure.
03:03:32 <dmead> > odds
03:03:33 <lambdabot>  Not in scope: `odds'
03:03:37 <roconnor> wow
03:03:43 <dmead> 0o
03:03:49 <roconnor> I didn't realize if and only iff was associative.
03:04:15 * roconnor fails as a logician
03:04:18 <dmead> lol
03:04:24 <dmead> what are you workin on?
03:05:49 <roconnor> Just reading about doing logic by algebra (rewriting) rather than by deduction.
03:06:08 <roconnor> This rule doesn't seem to be constructive.
03:06:36 <dmead> ah
03:06:47 <dmead> i'm workin on a logic prover ;o
03:09:14 <roconnor> we already have one
03:09:22 <roconnor> @djinn a -> b -> a
03:09:22 <lambdabot> f a _ = a
03:09:41 <roconnor> @djinn (((a -> b,b -> a) -> c,c -> (a -> b,b -> a)) -> (a -> (b -> c,c -> b),(b -> c,c -> b) -> a),(a -> (b -> c) /\ (c -> b),(b -> c,c -> b) -> a) -> ((a -> b,b -> a) -> c,c -> (a -> b,b -> a)))
03:09:41 <lambdabot> Cannot parse command
03:09:50 <roconnor> crap
03:10:21 <roconnor> oh forgot a /\
03:10:38 <roconnor> @djinn ((((a -> b,b -> a) -> c,c -> (a -> b,b -> a)) -> (a -> (b -> c,c -> b),(b -> c,c -> b) -> a),(a -> (b -> c,c -> b),(b -> c,c -> b) -> a) -> ((a -> b,b -> a) -> c,c -> (a -> b,b -> a))))
03:10:53 <lambdabot> djinn module failed: IRCRaised Prelude.init: empty list
03:11:09 <roconnor> @djinn a -> b
03:11:09 <lambdabot> -- f cannot be realized.
03:11:23 <roconnor> dmead: apparently we don't have a very good logic prover.
03:11:32 <roconnor> @help djinn
03:11:32 <lambdabot> djinn <type>.
03:11:32 <lambdabot> Generates Haskell code from a type.
03:11:32 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
03:11:59 <dmead> ;o
03:14:01 <dmead> roconnor: what makes you say that?
03:15:01 <roconnor> [12:10] <lambdabot> djinn module failed: IRCRaised Prelude.init: empty list
03:15:33 <dmead> ah
03:16:03 <roconnor> @seen lennart
03:16:04 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
03:17:36 <roconnor> @djinn (((a -> b,b -> a) -> c,c -> (a -> b,b -> a)) -> (a -> (b -> c,c -> b),(b -> c,c -> b) -> a),(a -> (b -> c,c -> b),(b -> c,c -> b) -> a) -> ((a -> b,b -> a) -> c,c -> (a -> b,b -> a)))
03:17:51 <lambdabot> djinn module failed: IRCRaised Prelude.init: empty list
03:18:34 <dmead> what are you trying to get djuin to do?
03:19:08 <dmead> *djinn
03:19:21 * dmead is sleepy
03:19:44 <roconnor> @tell lennart that djinn is broken when asked to prove the associativity of iff, aka (((a -> b,b -> a) -> c,c -> (a -> b,b -> a)) -> (a -> (b -> c,c -> b),(b -> c,c -> b) -> a),(a -> (b -> c,c -> b),(b -> c,c -> b) -> a) -> ((a -> b,b -> a) -> c,c -> (a -> b,b -> a)))
03:19:45 <lambdabot> Consider it noted.
03:20:48 <ibid> blah
03:21:08 * ibid is writing a Planet entry for HCAR and it's turning out as a bunch of legalese :/
03:22:21 <dmead> hcar?
03:22:51 <ibid> haskell communities and activities report
03:23:34 * roconnor is convinced that associativity is non constructive.
03:23:48 <dmead> ahh
03:24:06 <dmead> hehe
03:24:45 <dmead> why are you using commas?
03:25:24 <dmead> (a->b, b->a) should really be
03:25:34 <dmead> (a->b) -> (b -> a)
03:25:42 <dmead> of you want IFF
03:25:45 <kosmikus> ibid: thanks for writing something on the planet.
03:25:46 <dmead> i thinks
03:26:19 <ibid> kosmikus: do the HCAR editors rewrite it for clarity? :)
03:27:22 <kosmikus> ibid: ?
03:28:31 <kosmikus> ibid: you mean, whether I'm planning to rewrite your text? no, only if there are clear typos or severe grammatical problems.
03:28:39 <ibid> re what i wrote above: "and it's turning out as a bunch of legalese" :)
03:28:50 <ibid> well, i think i removed the worst of it
03:28:54 <roconnor> dmead: (a->b,b->a) is a <-> b.
03:29:23 <ibid> here's the worst paragraph as it currently stands:
03:29:25 <ibid> >> A blog is eligible to Planet if it is being written by somebody who is active in the Haskell community, or by a Haskell celebrity; also eligible are blogs that discuss Haskell-related matters frequently, and blogs that are dedicated to a Haskell topic (such as a software project written in Haskell).  Note that at least one of these conditions must apply, and virtually no blog satisfies them all. However, blogs will not be added to Planet without
03:29:26 <dmead> ah
03:29:31 <ibid> >> the blog author's consent.
03:29:59 <roconnor> @what HCAR
03:29:59 <lambdabot> http://www.haskell.org/communities/
03:30:05 <roconnor> ah
03:30:27 <ibid> 13:21  <dmead> hcar?
03:30:27 <ibid> 13:22  <ibid> haskell communities and activities report
03:30:28 <ibid> :)
03:35:28 <roconnor> @djinn (a -> b -> c) -> (d -> a) -> (d -> b) -> (d -> c)
03:35:28 <lambdabot> f a b c d = a (b d) (c d)
03:35:49 <roconnor> @. pl djinn (a -> b -> c) -> (d -> a) -> (d -> b) -> (d -> c)
03:35:50 <lambdabot> f = liftM2
03:36:24 <lightstep> @pl s x y z = (x y) (x z)
03:36:24 <lambdabot> s = flip =<< ((.) .)
03:36:28 <roconnor> @. type . pl djinn (a -> b -> c) -> (d -> a) -> (d -> b) -> (d -> c)
03:36:30 <lambdabot> parse error on input `='
03:36:31 <fasta> I want to evaluate foo and I want that the calls to trace are all shown like I call the function for the first time. I tried :set +r, but it doesn't make this happen.
03:36:38 <lightstep> @. type pl s x y z = (x y) (x z)
03:36:39 <roconnor> @type liftM2
03:36:40 <lambdabot> parse error on input `='
03:36:41 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:37:02 <lightstep> @ type \x y z -> (x y) (x z)
03:37:20 <roconnor> @djinn (a -> b -> c) -> (d -> a) -> b -> (d -> c)
03:37:21 <lambdabot> f a b c d = a (b d) c
03:37:28 <roconnor> @. pl djinn (a -> b -> c) -> (d -> a) -> b -> (d -> c)
03:37:28 <lambdabot> f = (flip .) . (.)
03:37:51 <roconnor> @. pl djinn (a -> b -> c) -> a -> (d -> b) -> (d -> c)
03:37:51 <lambdabot> f = ((.) .)
03:43:01 <ibid> kosmikus: sent
03:54:27 <dmead> Ok i need a fancy name for my prover
03:54:30 <dmead> !!!
03:55:37 <roconnor> Frege
03:56:04 <fasta> dmead: "The _really_ _really_ slow prover"?
03:56:23 <dmead> =P
03:56:52 <dmead> how  could it be slow... 50 gabillion list iterations cant be THAT bad...
03:56:55 <dmead> ;p
03:58:36 <ThreeQ> omlettes!
03:58:39 <ThreeQ> uh, crap
03:58:40 <ThreeQ> wrong window
03:59:22 <ThreeQ> although you could name your prover omelettes, I suppose :)
03:59:38 <dmead> haha
03:59:43 <dmead> mmm omlettes
04:00:06 <roconnor> dmead: how does it fair on forall (a b c:Z) (n:N). a^(n+3) + b^(n+3) = c^(n+3) -> a*b*c = 0 ?
04:00:20 <dmead> it's not that kinda prover =(
04:00:44 <roconnor> what does it prove?
04:01:07 <dmead> that logic sentences are satisfiable
04:01:32 <dmead> like what you were doin earlier
04:02:02 <dmead> it's proof by theorem resolution, etc
04:02:07 <dmead> so just logic
04:03:46 <roconnor> data Literal = ... | MachDouble  Rational
04:03:48 <roconnor> :)
04:03:56 <dmead> ?
04:04:18 <dmead> >:(
04:04:20 <dmead> =p
04:04:22 <roconnor> There was a discussion yesterday that Floats and Doubles are subsets of Rational.
04:04:43 <dmead> aren't they?
04:04:45 <roconnor> GHC implements the Machine Double Literal as a Rational. :)
04:04:52 <roconnor> dmead: they are.
04:04:58 <sris> how do i check if a infix operations is left or right associative?
04:05:00 <roconnor> but one doesn't normally think that way.
04:05:29 <dmead> uhhh
04:05:30 <dmead> hold on
04:05:32 <dmead> i know this
04:05:33 <roconnor> sris: which one?
04:05:54 <sris> roconnor: hmm. anyone ;)
04:06:05 <sris> i thhink i've seen someone do it here
04:06:11 <dmead> oh
04:06:11 <roconnor> oh
04:06:16 <dmead> it really depends i think
04:06:23 * roconnor gives it a try
04:06:28 <roconnor> @hoogle (++)
04:06:29 <lambdabot> Did you mean: (++)
04:06:29 <lambdabot> Prelude.undefined :: a
04:06:29 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:06:37 <roconnor> @hoogle ++
04:06:37 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
04:06:38 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
04:06:38 <lambdabot> Text.Html.(+++) :: (HTML a, HTML b) => a -> b -> Html
04:06:48 <roconnor> @docs Prelude.(++)
04:06:48 <lambdabot> Prelude.(++) not available
04:06:52 <roconnor> @docs Prelude
04:06:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
04:06:57 <sris> I think it was something i could type in ghci, similar to :t
04:07:06 <dmead> negative
04:07:20 <dmead> you can see the presidence
04:07:21 <roconnor> I failed
04:07:24 <dmead> =(
04:07:38 <dmead> use hugs for debugging =o
04:08:00 <roconnor> Prelude> :i (++)
04:08:01 <roconnor> ++ :: [a] -> [a] -> [a]         -- Imported from GHC.Base
04:08:01 <roconnor> infixr 5 ++
04:08:06 <roconnor> ++ is right associative!
04:08:15 <sris> ah, :o looks nice
04:08:22 <dmead> xD
04:08:34 <sris> thanks! ;)
04:08:50 <dmead> bonnnggg bonng bonnggggggggggg
04:08:53 <dmead> bong bong!!!!!!
04:12:00 <dmead> YES
04:12:30 <dmead> i am awesome
04:15:39 <fasta> dmead: Is it an intelligent prover or just something you made as an exercise?
04:16:01 <dmead> define intelligent
04:16:08 <fasta> dmead: fast
04:16:11 <dmead> yes
04:16:18 <dmead> i'll link you to the method
04:16:40 <dmead> http://www.rci.rutgers.edu/~cfs/472_html/Logic_KR/resolution.html
04:16:42 <dmead> there ya go
04:16:43 <lambdabot> Title: Resolution Theorem Proving, http://tinyurl.com/yldca7
04:17:01 <fasta> dmead: oh, right, I implemented that too once for "fun".
04:17:06 <dmead> =)
04:17:36 <roconnor> dmead: ask it how to build an RS232 adaptor.
04:17:42 <roconnor> adapter
04:17:44 <dmead> lol
04:17:52 <fasta> dmead: I don't think it's the most advanced method, though. A lot still use it in their core, though.
04:18:20 <dmead> yea it seems fairly a fairly elegant way of doing things
04:18:52 <dmead> i'm doing this and some other stuff for an independent credit
04:19:09 <dmead> gonna try some rule based stuff next
04:20:33 <dmead> pretty goodi think considering i started haskell a month ago =)
04:40:02 <roconnor> @what TIM
04:40:03 <lambdabot> I know nothing about tim.
04:43:49 <roconnor> @what supercombinator
04:43:50 <lambdabot> I know nothing about supercombinator.
04:53:21 <xerox> ?yow
04:53:21 <lambdabot> I just heard the SEVENTIES were over!!  And I was just getting in touch
04:53:21 <lambdabot> with my LEISURE SUIT!!
05:10:55 * dcoutts emerges hdbc-1.0.1 and all backends
05:11:08 <dcoutts> oops, wrong channel
05:15:01 <dmhouse> Is there any way to turn off the restriction that you can't make instances of synonyms?
05:15:22 <roconnor> hmm
05:15:28 <roconnor> seems unlikely
05:15:40 <roconnor> any reason not to use newtype?
05:15:56 <dmhouse> I basically want Show instances for 'GenTerm String' and 'GenTerm DBIndex'
05:16:08 <dmhouse> s/Show/differing Show/
05:16:42 <roconnor> I think that can be done with overlapping instances.  But I don't really know
05:18:22 <lightstep> why not make DBIndex abstract?
05:18:50 <dmhouse> lightstep: how would that help?
05:19:02 <dmhouse> At the moment, type DBIndex = Int
05:19:44 <lightstep> is there a show instance for GenTerm a?
05:20:05 <dmhouse> No.
05:21:53 <dmhouse> Basically the setup I want is that GenTerm Strings can be shown by throwing them into the showTerm function, but GenTerm DBIndex are first converted into GenTerm Strings by the mkNameful function, then shown in the normal way.
05:21:57 <lightstep> oh, i get your problem. isn't there a swithc to allow that?
05:23:33 <sris> geez, i find it hard to understand the sequence function
05:24:17 <dmhouse> sris: it takes a list of monadic actions and executes them. Or, in the List monad, it performs black magic.
05:24:26 <lightstep> sris, it's different for each monad
05:25:03 <sris> yeah, it's the black magic im looking at ;D
05:25:18 <lightstep> in List it's cartesian product
05:25:42 <sris> i know what the result it, i just dont understand how it works ;)
05:27:15 <roconnor> The list monad sequence isn't hard at all
05:27:24 <sris> im trying to understand monads, and i gues im not quiet there yet ;)
05:27:34 <lightstep> LogicT is harder
05:27:47 <roconnor> it produced all possible choices from choosing one from each list.
05:28:05 <roconnor> > sequence [[1],[2,3],[4,5,6]]
05:28:06 <lambdabot>  [[1,2,4],[1,2,5],[1,2,6],[1,3,4],[1,3,5],[1,3,6]]
05:28:24 <dmhouse> roconnor: <sris> i know what the result it, i just dont understand how it works ;)
05:28:35 <sris> well, i know what the result is, i just shared my confusion when trying to understand how it was achieved ;)
05:28:48 <roconnor> dmhouse: in a declarative language, who cares how it works.
05:29:08 <roconnor> or in otherwords, backtracking search.
05:29:08 <dmhouse> roconnor: is that a joke?
05:31:10 <roconnor> sequence (a:as) = [x::r | x<-a, r<-(sequence as)] ... I think
05:31:23 <dmhouse> Hrm. I think my instances should be legal with -fglasgow-exts.
05:31:55 <dmhouse> sris: try expanding out the definitions of sequence for, say, sequence [1..3].
05:36:31 <roconnor> why doesn't GHC use Quick C--?
05:38:45 <Lemmih> Isn't Quick C-- just a proof-of-concept?
05:38:52 <roconnor> hmm
05:39:28 <roconnor> I see
05:40:37 <dcoutts> Lemmih, I don't think it was intended that way, but that's how it is
05:41:30 <fasta> @where Quick C--
05:41:31 <lambdabot> I know nothing about quick.
05:41:51 <roconnor> http://www.cminusminus.org/qc--.html
05:41:52 <lambdabot> Title: Quick C--
05:41:54 <fasta> Hmm, it doesn't even match two words :(
05:42:16 <fasta> dpkg owns lambdabot (except for Haskell evaluation)
06:07:29 <jmmv> I find myself doing 'b <- someFunction; if b then...'.  I wonder if there is any function that allows me to merge the two things and avoid the do block?
06:07:30 <SamB> dpkg also isn't good for @googling
06:08:23 <hyraxfourtwo> jmmv, if the monad is a MonadPlus instance you can use when or unless
06:08:29 <hyraxfourtwo> ?type when
06:08:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:08:38 <hyraxfourtwo> oh not even monadplus
06:09:31 <jmmv> but that doesn't leave room for the "else" part, does it?
06:10:30 <hyraxfourtwo> I guess not so much
06:10:58 <hyraxfourtwo> you could write your own if
06:11:18 <hyraxfourtwo> if' subs alt pred = if pred then subs else alt
06:11:21 <jmmv> yep but... I wonder if that'd be clearer than the do blocks
06:11:35 <hyraxfourtwo> keeping predicate last so you can use bind and not need a lambda
06:11:58 <hyraxfourtwo> jmmv, probably not :)
06:12:09 <jmmv> hehe
06:12:18 <SamB> @type let ifM p x y = do bool <- p; if p then x else y in ifM
06:12:20 <lambdabot>   Couldn't match `Bool' against `t t1'
06:12:20 <lambdabot>    Expected type: Bool
06:12:24 <SamB> hmm.
06:12:36 <xerox> fi bool
06:12:38 <xerox> *if
06:12:45 <SamB> oh right ;-)
06:12:51 <SamB> @type let ifM p x y = do bool <- p; if bool then x else y in ifM
06:12:52 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
06:13:20 <hyraxfourtwo> that is a better idea than mine
06:14:02 <roconnor> :hoogle Bool -> a -> a -> a
06:14:05 <roconnor> ?hoogle Bool -> a -> a -> a
06:14:06 <lambdabot> No matches, try a more general search
06:14:22 <jmmv> if I do that... I'd as well write a maybeM ;)
06:14:39 <roconnor> ?hoogle maybeM
06:14:40 <lambdabot> No matches found
06:15:00 <SamB> @type maybe
06:15:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:15:22 * SamB doesn't think you need a special maybeM
06:16:06 <jmmv> you mean that the regular maybe should work?
06:16:19 <SamB> yes
06:16:31 <SamB> er. well. maybe.
06:16:56 <SamB> I guess you could >>= into it if needed...
06:17:12 <SamB> since the maybe argument is *last*
06:17:52 <xerox> ?pl (>>= id)
06:17:52 <lambdabot> join
06:17:55 <xerox> :)
06:19:01 <jmmv> it seems it can work
06:20:53 <jmmv> well, lunch time
06:20:56 <beelsebob> @roulette
06:20:57 <lambdabot> Unknown command, try @list
06:21:08 <beelsebob> hmm, time to code lambdabot russian roulette
06:21:51 <SamB> ... does lambdabot have ops?
06:22:07 <beelsebob> he could oper himself then do it
06:27:56 <sris> how should i interpret the pipe in "class MonadState m s | m -> s where"
06:28:09 <xerox> Functional dependency.
06:29:46 <xerox> |class Foo a where ..| is a class named Foo with one type variable `a', |class Foo a b where ..| is a class named Foo with two type variables `a' and `b', and then |class Foo a b | a -> b' is the same, but with the constraint that `a' uniquely determines `b'.
06:30:29 <araujo> morning!
06:30:45 <Lemmih> Morning!
06:30:53 <sris> xerox: ah, i see, thanks
06:31:10 <xerox> You're welcome.
06:36:04 <araujo> :-)
06:42:18 <Templar85> can anyone tell me how the line in ghc looks like when I whants to convert a some .hs files to one .exe file?
06:42:56 <xerox> ghc --make File.hs
06:43:12 <xerox> Main.hs is the usual File.hs to be built :)
06:43:27 <Templar85> aha, oh, that was short, thanks :)
06:49:57 <hyrax42> --make will build all dependencies and link right?
06:50:13 <SamB> if it can find them, yeah!
06:50:36 <Templar85> hmm, but should I not get an output message?
06:50:41 <SamB> and if the passed file was a Main module
06:50:46 <SamB> Templar85: hmm?
06:51:05 <SamB> and if you didn't pass -c
06:51:28 <Templar85> "Prelude>--make Main.hs"    <- It just move down one line when I hit enter to a new "Prelude>"
06:52:18 <Lemmih> Templar85: You have to exit ghci.
06:52:37 <Templar85> aha! now I remember I think
06:52:38 <Templar85> =)
06:52:40 <Templar85> ty
06:55:11 <SamB> Templar85: it treated that as a comment! lol...
06:56:46 <nomeata> I'll hold a haskell introduction in Accra, Ghana in 30 minutes. I'll also mention this nice channel, maybe you'll get more african IPs :-)
06:58:16 <SamB> hmm.
06:58:21 <liyang> intellectual property is for terrists!
06:58:29 <SamB> how come this "redaction" article on wikipedia is called a "stub"?
06:58:50 <SamB> it looks like a page and a half to me!
07:00:20 * SamB thinks it should at least be called a macrostub or something, in recognition of its at least resembling an actual article
07:00:52 <chessguy> so bring it up on the discussion page
07:01:06 <SamB> good point
07:01:59 <xerox> nomeata: cool!
07:02:38 <chessguy> nomeata, what level is your audience?
07:02:52 <nomeata> chessguy: non-functional programmers
07:02:59 <nomeata> (hehe, that sounds mean)
07:03:09 <chessguy> lol
07:03:11 <liyang> nomeata: but otherwise programmers?
07:03:33 <nomeata> well, at first a general introduction to everyone, including linux beginners, but then a practical session for those who know some programming
07:03:39 <SamB> nomeata: "imperative programmers" won't insult them with overloaded meaning
07:03:44 <dons> morning
07:03:50 <dons> ?uptime
07:03:51 <lambdabot> uptime: 1d 16h 10m 17s, longest uptime: 6d 15h 1m 36s
07:03:51 <chessguy> hi dons
07:03:54 <dons> ?users
07:03:58 <SamB> dons: oh
07:03:59 <liyang> You never know, they may be Prolog hackers.
07:04:00 <xerox> Yow dons.
07:04:01 <nomeata> SamB: they are imperators, we are functional?
07:04:02 <SamB> are you still here?
07:04:06 <dons> SamB: ?
07:04:10 <lambdabot> seen module failed: IRCRaised thread killed
07:04:14 <SamB> dons: in the US
07:04:17 <dons> yep
07:04:19 <SamB> if you think this is morning!
07:04:21 <dons> ?users
07:04:30 <lambdabot> Maximum users seen in #haskell: 256, currently: 216 (84.4%), active: 21 (9.7%)
07:04:31 <dons> come on ms. bot.
07:04:54 <dons> SamB: I'm telling myself its morning anyway
07:04:59 <liyang> nomeata: good luck. I'm sure it'll be fun. :) (har har. Sorry.)
07:05:03 <chessguy> @yow dons
07:05:03 <lambdabot> I'm wet!  I'm wild!
07:05:04 <SamB> I mean, usually you go to bed sometime during what I would call morning or noonish and get up during what I call evening
07:05:09 <dons> hehe.
07:05:13 <nomeata> liyang: :-P
07:05:27 <dons> SamB: yes, i'm in mountain view right now, heading over to google in about an hour
07:05:31 <SamB> I don't think I am usually there when you go to bed anymore
07:05:52 <dons> yeah, normally this is bed time in .au :/
07:05:52 <SamB> or should I say "here"
07:05:53 <nomeata> dons: what are you searching there?
07:06:03 <SamB> nomeata: heh
07:06:19 <nomeata> dons: or just feeling lucky
07:06:22 <dons> hehe
07:06:23 <SamB> I don't think you go to the googleplex to search, nomeata !
07:06:34 <SamB> google.com is good enough for searching, usually
07:06:43 <SamB> unless you are looking for a bike or something
07:06:51 <dons> maybe they have a lost and found?
07:06:57 <SamB> (in which case you'd probably have more luck at the googleplex)
07:07:09 <kpreid> dons, did you see the Ordering problem in @run?
07:07:18 <SamB> or, yeah, if you left something of yours there
07:07:54 <SamB> screen(1) is cool ;-)
07:07:59 <xerox> dons: applying for a job?
07:08:37 <chessguy> surely even google doesn't have a location in AU
07:08:51 <SamB> I am using it to aid me in my efforts to benchmark my change to GHC's inliner with nofib...
07:09:16 <roconnor> SamB: how goes the build?
07:09:32 <Maddas> chessguy: Why 'even'? Is AU not too popular for tech company headquarters?
07:09:44 <SamB> oh, I think I forgot to grab nofib this time round...
07:10:03 <SamB> would probably be a good idea ;-)
07:10:18 <kpreid> also, it has just now sunk in that you can write type-level combinators using type aliases
07:10:25 <kpreid> *Test Data.Typeable> typeOf (undefined :: Maybe :. Flip Either String :$ Int)
07:10:26 <kpreid> Maybe (Either Int [Char])
07:10:33 <SamB> kpreid: no you can't!
07:11:35 <roconnor> SamB does GHC HEAD build?
07:12:08 <kpreid> SamB: assuming you're serious, could you explain the difference between what I said and what I did?
07:12:51 <roconnor> type Flip a b c = a c b ?
07:12:59 <kpreid> roconnor: yes
07:13:06 <dons> chessguy: yeah, they do have a branch in sydney
07:13:19 <chessguy> lol
07:13:25 <chessguy> it was intended to be a joke
07:13:29 <dons> heh
07:13:55 <chessguy> poking fun at aussies is fun
07:14:35 <Maddas> chessguy: Ah, okay :-)
07:14:54 <kpreid> > compare GT LT -- dons: something's wrong with this
07:14:55 <lambdabot> Terminated
07:15:10 <chessguy> > GT
07:15:11 <lambdabot> Terminated
07:15:29 <roconnor> > 1+1
07:15:29 <kpreid> > toEnum 2 :: Ordering
07:15:30 <lambdabot>  2
07:15:31 <lambdabot>  GT
07:15:36 <dons> ?undefine --?
07:15:37 <roconnor> > GT
07:15:37 <lambdabot> Undefined.
07:15:37 <lambdabot> Terminated
07:15:40 <roconnor> heh
07:15:42 <dons> > GT
07:15:43 <lambdabot> Terminated
07:15:44 <kpreid> huh, so *entering* GT fails
07:15:46 <dons> weird
07:15:51 <dons> ah, maybe not in scope?
07:15:53 <kpreid> oh, hm
07:15:54 <dons> ?index GT
07:15:54 <lambdabot> Data.Generics.Aliases, Data.Generics, Data.Graph.Inductive.Query.Monad, Data.Graph.Inductive.Query, Data.Graph.Inductive, Prelude
07:15:59 <twanvl> > fromEnum FT
07:15:59 <dons> no.
07:16:00 <lambdabot>  Not in scope: data constructor `FT'
07:16:04 <roconnor> > GT -> [----REDACTED----]
07:16:04 <twanvl> > fromEnum GT
07:16:04 <lambdabot>  Parse error
07:16:05 <lambdabot> Terminated
07:16:17 <dons> ok, i'll look at it later
07:16:18 <kpreid> > Prelude.GT
07:16:20 <lambdabot>  GT
07:16:21 <kpreid> aha
07:16:26 <kpreid> dons: it's an ambiguous import
07:16:27 <dons> ah
07:16:30 <dons> ah right
07:16:36 <roconnor> @hoogle GT
07:16:37 <lambdabot> Prelude.GT :: Ordering
07:16:37 <lambdabot> Data.Generics.Aliases.GT :: Data a => a -> a -> GenericT'
07:16:37 <lambdabot> Data.Graph.Inductive.Query.Monad.GT :: data GT m g a
07:16:45 <dons> yeah, its coming in through Generics now
07:16:47 <bartw> roconnor: still busy with the adventure ?
07:17:24 <roconnor> I'm more or less done now.
07:17:43 * dons -> breakfat
07:17:44 <roconnor> My colluge has build an ocaml layer on top of his UM
07:17:51 <dons> well, something like that anyway
07:17:55 <roconnor> he can enter something like #fix RS232
07:18:14 <roconnor> and automatically fixes the RS232
07:26:05 <bartw> roconnor: nice
07:26:17 <bartw> roconnor: does he also have a sensory engine bypass thingy ?
07:26:40 <roconnor> I think he is working on that
07:26:51 <roconnor> I've completed that task.
07:26:51 <hyraxfourtwo> UM?
07:27:03 <roconnor> But I refused to tell him what the manifesto says
07:27:09 <roconnor> I said he has to find out himself.
07:27:09 <hyraxfourtwo> oh icfp
07:27:10 <bartw> :)
07:27:37 <bartw> im still miffed that bypassing the sensorry engine doesn't give you anything extra
07:28:08 <roconnor> well, it gets you the info to get the extra 6 builds
07:28:27 <bartw> you can just go to the musuem directly
07:28:35 <bartw> no need to read anythign for that
07:28:52 <SamB> bartw: what!
07:28:55 <roconnor> yeah, but it is hard to find the [----REDACTED---] room.
07:28:56 <SamB> you don't get anything for that!
07:29:13 <SamB> What [--REDACTED--] room?
07:29:24 <kpreid> SamB: what did you mean by "no you can't!"?
07:29:29 <roconnor> The [--REDACTED--] room with the crowbar.
07:29:32 <int-e> the museum gives you access to a lot of [--REDACTED--] stuff.
07:29:40 <SamB> kpreid: they aren't real combinators!
07:29:48 <SamB> int-e: huh?
07:30:04 <kpreid> SamB: what's the difference?
07:30:08 <bartw> ui got bored with it when i got to the museum, never fixed those things
07:30:12 <SamB> how do you get in to these rooms?
07:30:15 <SamB> I was unable to do so.
07:30:19 <int-e> uh, and the deck of cards :)
07:30:23 <SamB> I think because I had voided my warranty.
07:31:06 * SamB should try it on Lemmih's computer
07:31:18 <SamB> Lemmih has enough RAM, right?
07:31:19 <roconnor> yeah, learning how to get into the muesuem without voiding your warenty needs to bypass the censory engine.
07:31:41 <dons> SamB: you're not at uni? no server you can use?
07:31:49 <int-e> have I voided my license? hmm.
07:31:50 * dons always abuses uni resources for this kind of thing
07:32:13 <roconnor> SamB, I have a modified C++ program that is somewhat light on memeory.
07:32:13 <SamB> dons: not uni, just a community college.
07:32:19 <SamB> and I'm not there, either
07:32:23 <roconnor> hmm
07:32:23 <SamB> they don't have living space
07:32:29 <roconnor> but maybe not light enough for you.
07:32:38 <SamB> ... lighter than what?
07:32:51 <roconnor> oh wait, nevermind
07:33:05 <roconnor> SamB, I was making a light and safe UM.
07:33:11 <roconnor> but you can just use a light and unsafe UM.
07:33:17 <SamB> yeah really
07:33:33 <SamB> though perhaps I ought to have mine check argc...
07:34:07 <SamB> hmm
07:34:13 <SamB> I forgot to grab nofib...
07:34:22 <kpreid> SamB: what's the difference?
07:34:37 <SamB> well
07:35:19 <SamB> hmm
07:35:37 <SamB> just go try and do SKI with type synonyms why don't you?
07:35:45 <SamB> its the quickest way to find out!
07:36:17 <kpreid> occurs check, I suppose?
07:37:08 <SamB> occurs check?
07:37:14 * SamB thinks it would be a kind error
07:38:27 <int-e> ah, "use of this device will void your robot's license".
07:38:38 <int-e> I had forgotten about that.
07:39:20 <SamB> "warranty", isn't it?
07:39:36 <int-e> warranty. sorry. thinko.
07:39:46 <SamB> hehe
07:40:06 <SamB> anyway, I had no idea there was any other way into the museum...
07:40:19 <kpreid> SamB: hm, okay
07:40:34 <int-e> I've not circumvented the censory engine yet ... hmm. I should. Some day :)
07:40:49 <SamB> me either
07:41:09 <SamB> but now I could try on Lemmih's computer...
07:41:27 <int-e> anyway, up to building the downloader my UM used about 330 MB of RAM.
07:41:40 <int-e> hmm, and uploader.
07:41:52 <SamB> ... you didn't build both did you?
07:41:57 <SamB> in one run?
07:42:12 <int-e> I built both in one run.
07:42:17 <SamB> oh
07:42:18 <SamB> huh
07:42:25 <int-e> and without using the uploader.
07:42:38 <SamB> I built the downloader first, I think.
07:42:44 <int-e> me too
07:43:11 <SamB> at first I tried to build the uploader after that...
07:43:20 <int-e> that's possible.
07:43:25 <SamB> it is?
07:43:45 <SamB> I couldn't figure it out well, and it was wasting RAM...
07:43:46 <bartw> i had the uploader first
07:43:46 <int-e> oh no. there's an inc downloader there.
07:44:03 <bartw> atleast that way i didn't get bogged down in the 'brain' before having both
07:44:23 <SamB> so anyway, I had already copied gc.rml out, so I didn't really need the downloader anymore anyway...
07:44:33 <int-e> but heh, once you have the uploader you can get the stuff back anyway, if you need it.
07:44:43 <SamB> yeah.
07:45:04 <SamB> but it is a pain unless you alter the Go to not display room contents!
07:45:16 <SamB> assuming that works at all
07:46:46 <bartw> remove the limit from what you can carry and pick everything in the world up ?
07:46:57 <SamB> bartw: that sounds worse
07:47:10 <SamB> then if you do "i"... you have to wait for *that* to print...
07:47:21 <bartw> then dont press I ?
07:47:36 <SamB> what, me?
07:47:50 <SamB> rather
07:47:59 <SamB> who, me? you expect me not to press I?
07:48:12 <bartw> :)
07:59:04 * SamB thinks there ought to be a way to break ties between RULES...
07:59:39 <SamB> though actually that might be abad idea...
08:14:47 <SamB> oh great...
08:14:56 * SamB has the same error as before!
08:16:36 <dolio> So, if I have 'class Foo a b | a -> b where ...'
08:16:55 <dolio> And I do: 'instance (Bits k) => Foo k Bool where ...'
08:17:02 <SamB> didn't xerox just tell you what that meant?
08:17:21 <dolio> Does the (Bits k) => not do anything, and the instance just gets declared forall k?
08:17:22 <SamB> oh.
08:17:38 <SamB> ... does that even work?
08:19:05 <emk> Hmm. It seems like a sensible thing to want, but the inference k -> Bool would only be possible by analyzing the instance declaration. Does Haskell do that?
08:20:00 <dolio> If I try to add instance 'Foo String Char where ...', it tells me the fundeps conflict, even though String isn't an instance of Bits, I think.
08:20:29 <dolio> So, I guess the answer is, no, Haskell doesn't do what it takes to work it out. :)
08:22:03 <lisppaste2> SamB pasted "wierd error building GHC stage2" at http://paste.lisp.org/display/27955
08:22:47 <int-e> I doubt that works, because it cannot coexist with other (Bar k) => Foo k Xyzzy instances without getting into deep trouble.
08:22:51 <SamB> dolio: it doesn't know hat String isn't an instance of Bits ;-)
08:23:14 <int-e> (what happens if k is an instance of both Bits and Bar?
08:23:17 <dolio> int-e: Ah, I guess that's true.
08:23:45 <dolio> That'd be overlapping, and there's no good way to decide between the two.
08:23:53 <petekaz> How do I catch errors from this: translate n = "abcde" !! read n, I want to just return n if a) it's not an integer, or b) if the index is too large.  I'm reading about catch but that takes an IO action, this is pure code?
08:24:42 <emk> dolio: I just can't figure out why your stuff fails, but some of Hughes' fancy monad transformer stuff works with "class MonadRef m r | m -> r". I need to go stare at the types again to see what he does differently.
08:25:07 <SamB> petekaz: look at readsPrec
08:25:18 <SamB> @type readsPrec
08:25:19 <lambdabot> forall a. (Read a) => Int -> ReadS a
08:25:24 <SamB> @hoogle ReadS
08:25:25 <lambdabot> Prelude.ReadS :: type ReadS a
08:25:25 <lambdabot> Prelude.reads :: Read a => ReadS a
08:25:25 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
08:25:35 <int-e> emk: m isn't a type class there. it's a type constructor.
08:26:01 <Fey> question: what function can be used to test if a variable is an integer?
08:26:15 <int-e> emk: maybe I'm wrong and it works with the right extensions.
08:26:35 <dolio> Well, which would it be? It fails on -fallow-incoherent-instances
08:26:41 <petekaz> SamB: there is no simple way of catching all exceptions in that code?
08:26:52 <int-e> well, overlapping
08:26:58 <emk> int-e: Yeah, I think that might be it. But he does all sorts of scary things with "(MonadTrans ..., MonadRef ...) =>" after making that definition.
08:27:04 <SamB> petekaz: is unsafePerformIO simple?
08:27:25 * dons wave from the googleplex!
08:27:27 <petekaz> that sounds unsafe?  (I'm a newbie)
08:27:34 <SamB> catching exceptions-that-are-_|_ is impure
08:27:37 <Fey> I cannot find anything like isInteger or isInt in hoogle
08:27:43 <SamB> so yeah, its unsafe!
08:28:01 <emk> int-e: And I'm wondering why why those later declarations work.
08:28:15 <dons> mmm. fast wifi
08:28:16 <SamB> also you have to be careful that the thing you want to catch exceptions from is actually evaluated inside the catch ;-)
08:28:20 <petekaz> I guess I'll just write code to check that an error won't occur.
08:28:32 <SamB> hence why I suggested readsPrec...
08:28:46 <emk> ?type readsPrec
08:28:48 <lambdabot> forall a. (Read a) => Int -> ReadS a
08:28:55 <petekaz> but that only fixes case a) right?  not b)
08:29:00 <SamB> Prelude> :i ReadS
08:29:00 <SamB> type ReadS a = String -> [(a, String)]
08:29:14 <int-e> > readsPrec 0 "123abc" :: [(Int, String)]
08:29:16 <lambdabot>  [(123,"abc")]
08:29:23 <int-e> > readsPrec 0 "abc" :: [(Int, String)]
08:29:24 <lambdabot>  []
08:29:42 <SamB> @hoogle Int -> [a] -> Maybe a
08:29:42 <lambdabot> No matches, try a more general search
08:29:46 <SamB> @hoogle Int -> [a] -> m a
08:29:47 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
08:29:54 <SamB> nope...
08:30:02 <emk> > readsPrec 0 "123" :: [(Int, String)]
08:30:03 <lambdabot>  [(123,"")]
08:30:04 <SamB> @hoogle Monad m => Int -> [a] -> m a
08:30:05 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
08:30:22 <int-e> @index listToMaybe
08:30:22 <lambdabot> Data.Maybe
08:30:26 <SamB> well, you could just check the length...
08:30:33 <SamB> if the list won't be infinite
08:30:34 * dons|google looks for signs of lambdas 
08:30:37 <int-e> > listToMaybe . drop 3 $ "abcd"
08:30:52 <int-e> λ λ
08:31:05 <lambdabot>  Just 'd'
08:31:14 <int-e> > listToMaybe . drop 4 $ "abcd"
08:31:31 <lambdabot>  Nothing
08:31:41 <petekaz> thanks!
08:32:27 <emk> petekaz: When I need to catch exceptions in pure code, I usually wind up looking at "Either error value" and using it as a monad.
08:32:39 <SamB> yes
08:32:44 <SamB> that is a pretty decent way to do it
08:33:04 <SamB> if you want to be able to tell what kind of exception you have ;-)
08:33:29 <petekaz> I don't care about the exception, if there is any problem, I want to simply return 'n'
08:37:04 <Fey> so, is there any function a -> Bool that tests if a is an Intger?
08:37:38 <nomeata> ok, i got a few people interested in haskell. Maybe they'll show up here. If they know what IRC is :-)
08:38:16 <emk> Fey: Not unless it's defined over a type class of things that might be integers.
08:38:54 <Fey> oki
08:38:56 <Fey> thanks
08:39:18 <emk> Otherwise, nothing is known about "a", and you could only write:
08:39:30 <emk> func1 x = True
08:39:34 <emk> func2 x = False
08:40:10 <emk> Those are the only obvious functions which map a value of absolutely unknown type to a boolean.
08:40:34 <dolio> You could write a typeclass that would do it with -fallow-overlapping-instances
08:40:50 <dolio> But then the type would be: (YourTypeclass a) => a -> Bool
08:41:00 <dolio> It'd just happen that everything was in YourTypeclass.
08:41:18 <int-e> Fey: basically all types are fixed at compile time. you don't need any checks like that.
08:41:27 <dons> nomeata: cool
08:41:42 <emk> dolio: instance MightBeInt Float where...
08:42:06 <dolio> class MaybeInt a where test :: a -> Bool
08:42:18 <dolio> instance MaybeInt Int where test _ = True
08:42:26 <dolio> instance MaybeInt a where test _ = False
08:42:51 <emk> dolio: Yeah. And: instance MaybeInt String where test str = parsesAsInt str
08:42:52 <int-e> Fey: In the case of  x !! read s, the !! tells the type checker that read s needs to return an Int. The implementation of read for Ints doesn't accept anything but integers.
08:43:16 <int-e> > read "1.1" :: Int
08:43:17 <lambdabot>  Exception: Prelude.read: no parse
08:43:20 <dolio> emk: Yeah, you could add specifics for whatever you want.
08:43:32 <Fey> okay, I'll try that
08:43:33 <Fey> thanks
08:43:35 <emk> dolio: But it would be a bit silly.
08:43:40 <emk> :-)
08:43:42 <dolio> emk: Yeah. :)
08:43:50 <Fey> basically, I am taking elements out of a string
08:44:08 <Fey> and I need to test whether these elements are Integers or characters
08:44:42 <Fey> if they are characters I want to terminate, if they are integers I want to add them as Just Integer to an array
08:45:06 <psi> ?hoogle Char -> Bool
08:45:07 <lambdabot> Char.isAlpha :: Char -> Bool
08:45:07 <lambdabot> Char.isAlphaNum :: Char -> Bool
08:45:07 <lambdabot> Char.isAscii :: Char -> Bool
08:45:10 <emk> Fey: I do that using Parsec, and a union: data Token = I Int | S String | ...
08:45:24 <Fey> however, since I cannot use digitToInt with an error, it gets tricker
08:47:18 <petekaz> ok, here is what I came up with:
08:47:18 <emk> Fey: Purely functional error-handling in Haskell tends to involve monads sooner or later. The two best bets in your case might be "Maybe Char" or "Either MyErrorType Char", depending on whether you care about the details of the errors.
08:47:27 <petekaz>       translate s | [(n,s')] <- readsPrec 0 s, n < length xlat = xlat !! n
08:47:27 <petekaz>                   | otherwise = '?'
08:47:53 <emk> ?type reads
08:47:54 <lambdabot> forall a. (Read a) => ReadS a
08:48:13 <petekaz> how do I turn "c" to 'c'?
08:48:24 <glguy> head
08:48:31 <dons> > head "c"
08:48:33 <lambdabot>  'c'
08:48:46 <x3m> > snd "c"
08:48:47 <lambdabot>  Couldn't match `(a, b)' against `[Char]'
08:48:53 <petekaz> ah .. that was simple
08:48:56 <glguy> x3m: only works on 2-tuples
08:49:04 <x3m> glguy: yes it does
08:49:10 <Fey> Actually, the Char lib had something called isDigit that worked
08:49:27 <emk> > read "123" :: Int
08:49:29 <lambdabot>  123
08:49:38 <Fey> I checked out the isAlphaNum which did not do anything useful for me, but in the same place there were isDigit and isNum
08:49:42 <emk> > read "123" :: Maybe Int
08:49:43 <lambdabot>  Exception: Prelude.read: no parse
08:49:47 <glguy> x3m: I'm notsure what you just said, but I'm going to assume that you agreed with me
08:50:03 <x3m> glguy: yes.. i was just testing a thing
08:50:50 <emk> Fey, petekaz: For anything beyond very simple parsing, read is fairly cumbersome, because it doesn't give you any good error-handling options.
08:51:05 <petekaz> yeah, I see.
08:51:14 <Fey> aye. And errorhandling seems to be what I need the most :)
08:51:44 <emk> If you know the type of the value you're trying to read, it's fine. But if you're trying to read one of several different values, and you want to handle errors nicely, there comes a time when Parsec is just a better tool.
08:52:23 <emk> http://www.cs.uu.nl/~daan/parsec.html
08:53:35 <emk> It lives in Text.ParserCombinators.Parsec in the standard GHC install.
08:54:55 <emk> Fey, petekaz: The documentation isn't hugely wonderful as a tutorial, but it might be worth checking out.
08:57:01 <petekaz> I just wanted something simple, I am trying to convert a program that was used as a python tutorial into haskell.  The program basically just reads a string like "3 1 20 !" and turn it to "c a t !"
08:57:08 <petekaz> http://paste.kazmier.com/?action=Display&id=1160841252304186000000
08:58:09 <dons> > words "3 1 20!"
08:58:10 <lambdabot>  ["3","1","20!"]
08:58:11 <emk>  petekaz: Let me think for a moment.
08:58:15 <dons> > words "3 1 20"
08:58:15 <petekaz> One guy on my team was trying to teach python to non-programmers and used this as an example, I was going to try and show them how cool haskell was as well.
08:58:16 <lambdabot>  ["3","1","20"]
08:58:57 <emk> petekaz: Since you need to parse a mix of strings and ints, the dynamic language solution may be a bit nicer.
08:59:04 <petekaz> my program works, I just thought my translate fn was ugly.
08:59:04 <dons> > map (\w -> chr (ord 'a' + read w)) (words "3 1 20")
08:59:06 <lambdabot>  "dbu"
08:59:23 <dons> > map (\w -> chr (ord 'a' + read w)) (words "0 1 2 3")
08:59:24 <lambdabot>  "abcd"
08:59:41 <dons> ?pl (\w -> chr (ord 'a' + read w))
08:59:41 <lambdabot> chr . (ord 'a' +) . read
09:00:27 <emk> petekaz: I can show you something slick in a minute or two.
09:07:14 <petekaz> emk: it must be really slick!
09:10:42 <roconnor> @pl \s -> map (\w -> chr (ord 'a' + read w)) (words s)
09:10:43 <lambdabot> map (chr . (ord 'a' +) . read) . words
09:11:35 <glguy> roconnor: intToDigit might work better
09:11:46 <glguy> > intToDigit 7
09:11:48 <lambdabot>  '7'
09:12:31 <emk> petekaz: OK, so I'm poking at the manual a bit to make it shinier. :-)
09:12:52 <glguy> roconnor: or digitToInt, I'm not quite sure what you are doing :)
09:12:55 <petekaz> I'll wow those pythoners yet!
09:13:18 <roconnor> glguy: emk is making something really slick
09:13:37 <glguy> roconnor: what's that?
09:13:51 <emk> Don't get your expectations too high; I'm just a novice Haskeller.
09:13:55 <roconnor> [17:56] <petekaz> I just wanted something simple, I am trying to convert a program that was used as a python tutorial into haskell.  The program basically just reads a string like "3 1 20 !" and turn it to "c a t !"
09:13:55 <emk> ;-)
09:14:19 <phr-newbie> @p2 \pred -> not . pred
09:14:20 <lambdabot> (not .)
09:14:31 <phr-newbie> wow!  heh
09:15:05 <emk> Hey, simplicity takes time. :-)
09:15:10 <roconnor> phr-newbie: it's actually @pl, or @pf
09:15:17 <phr-newbie> oops
09:15:18 <phr-newbie> typo
09:15:22 <phr-newbie> and it figured it out anyway
09:15:34 <roconnor> lambdabot is forgiving.
09:15:54 <roconnor> @vixen, you're forgiving, right?
09:15:55 <lambdabot> yup, right on
09:16:33 <emk> char 65
09:16:38 <emk> >char 65
09:16:41 <glguy> chr?
09:16:46 <roconnor> @pf stands for point-free, and @pl stands for point-less
09:16:46 <lambdabot> Maybe you meant: bf pl
09:16:50 <emk> > chr 65 -- stupid fingers
09:16:51 <lambdabot>  'A'
09:16:52 <roconnor> hush you.
09:16:55 <dons> ther'es no @pf..
09:17:34 <roconnor> oh
09:17:42 <roconnor> it ought to be an alias :)
09:18:10 <therp> magst du noch bischen skypen :) ?
09:18:17 <therp> er sorry totally wrong window
09:18:27 <phr-newbie> anyone got a way to write this with scanl or something?
09:18:34 <petekaz> what language was that?
09:18:35 <glguy> ?babel de en  magst du noch bischen skypen
09:18:37 <lambdabot>  you may skypen still bischen
09:18:48 <phr-newbie> columns :: Matrix -> [Vector]
09:18:48 <phr-newbie> columns m | head m == [] = []
09:18:48 <phr-newbie>           | otherwise = (map head m) : columns (map tail m)
09:18:49 <therp> german, and directed to my abroad studying girlfirend
09:19:09 <phr-newbie> matrix = [[Float]] basically
09:19:27 <phr-newbie> @pf
09:19:27 <phr-newbie> columns :: Matrix -> [Vector]
09:19:27 <phr-newbie> columns m | head m == [] = []
09:19:27 <phr-newbie>           | otherwise = (map head m) : columns (map tail m)
09:19:28 <lambdabot> Maybe you meant: bf pl
09:19:30 <int-e> phr-newbie: isn't that just transpose?
09:19:55 <phr-newbie> hmm yeah
09:20:04 <phr-newbie> so how would you write transpose?
09:20:12 <int-e> import Data.List ;)
09:20:30 <roconnor> @type transpose
09:20:31 <lambdabot> forall a. [[a]] -> [[a]]
09:20:42 <dons> sjanssen: around?
09:20:44 <int-e> > foldr (zipWith (:)) (repeat []) [[1,2],[3,4]]
09:20:45 <lambdabot>  [[1,3],[2,4]]
09:20:51 <roconnor> > transpose [[1,2,3],[4,5,6]]
09:20:52 <lambdabot>  [[1,4],[2,5],[3,6]]
09:21:04 <glguy> transpose xs = map head xs : transpose (map tail xs) ?
09:21:19 <dolio> I have my cat translator.
09:21:23 <sjanssen> dons: yep
09:21:40 <int-e> glguy: that's what phr-newbie did
09:21:50 <dons> sjanssen: i'm at the gsoc summit. so if you're online today, i may ask you for some experience feedback later
09:22:01 <dons> (there's a "student experience" talk in an hour or two)
09:22:36 <lisppaste2> phr pasted "matrix mult" at http://paste.lisp.org/display/27956
09:23:20 <sjanssen> dons: okay, I should be around
09:23:44 <phr-newbie> @type repeat
09:23:45 <lambdabot> forall a. a -> [a]
09:24:43 <phr-newbie> > take 5 (repeat 3)
09:24:45 <lambdabot>  [3,3,3,3,3]
09:24:51 <int-e> replicate :)
09:25:08 <int-e> > replicate 3 5
09:25:09 <lambdabot>  [5,5,5]
09:25:10 <roconnor> time for Dr. Haskell?
09:25:48 <roconnor> @where Dr.Haskell
09:25:48 <lambdabot> I know nothing about dr.haskell.
09:26:19 * glguy &
09:26:33 <dons> ?where drhaskell
09:26:33 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
09:28:08 <roconnor> oooh, it's even in the rule set
09:28:19 <roconnor> -- replicate n x
09:28:19 <roconnor> use_replicate n x = take n (repeat x)
09:28:35 <emk> @hoogle chr
09:28:35 <lambdabot> Char.chr :: Int -> Char
09:28:36 <lambdabot> Text.PrettyPrint.HughesPJ.Chr :: Char -> TextDetails
09:28:36 <lambdabot> Text.Regex.matchRegex :: Regex -> String -> Maybe [String]
09:31:41 <phr-newbie> does the compiler do all these simplifications by itself?
09:32:03 <roconnor> some.
09:32:23 <roconnor> but Dr. Haskell may be able to give you some hints.
09:32:34 <phr-newbie> well if i say
09:32:47 * ndm joins just at the right second :)
09:32:52 <phr-newbie> type Point = (Float, Float)
09:32:52 <phr-newbie> type Region = Point -> Bool
09:32:52 <phr-newbie> inRegion :: Region -> Point -> Bool
09:32:52 <phr-newbie> r `inRegion` p = r p
09:33:03 <phr-newbie> the inregion description is self-documenting
09:33:09 <phr-newbie> but equivalent to "inRegion = id"
09:33:12 <emk> OK, what's the best way to paste?
09:33:13 <ndm> looks like the JFP paper that never was
09:33:18 <ndm> @paste
09:33:18 <lambdabot> http://paste.lisp.org/new/haskell
09:33:28 <ndm> @seen pejo
09:33:28 <lambdabot> pejo is in #haskell. I last heard pejo speak 19h 48m 56s ago.
09:33:35 <emk> petekaz, Fey: OK, I've got some code.
09:33:54 <sjanssen> phr-newbie: GHC will almost certainly inline that definition, so it should be quite efficient
09:34:03 <roconnor> phr-newbie: that it will likely figure out.
09:34:10 <lisppaste2> emk pasted "Parsing mixed ints, strings" at http://paste.lisp.org/display/27957
09:34:30 <roconnor> you also may wish to use newtype for Region.
09:34:51 <ndm> @tell pejo I took a look the Marlow's thesis, and have designed a deforestation pass that looks competative, thanks for the pointers! deforestation will be happening :)
09:34:51 <lambdabot> Consider it noted.
09:34:53 <emk> decode "65 66 67 !!" -- Returns "ABC!!"
09:34:55 * roconnor thinks phr-newbie is writing military software.
09:35:05 <phr-newbie> hehe
09:35:15 <phr-newbie> yeah, it's the example from that paper
09:35:21 <phr-newbie> also from "haskell school of expression"
09:35:24 <xerox> @spell competitive
09:35:25 <lambdabot> competitive
09:35:32 <xerox> ^- ndm :)
09:35:42 <phr-newbie> newtype?
09:35:59 <ndm> @spell I took a look the Marlow's thesis, and have designed a deforestation pass that looks competative, thanks for the pointers! deforestation will be happening :)
09:36:00 <lambdabot> I took a look the Marlow's thesis, and have designed a deforestation pass that looks competative, thanks for the pointers! deforestation will be happening :)
09:36:04 <roconnor> newtype makes a branded type
09:36:13 <petekaz> emk: nice ... I've never used parsec before.
09:36:14 <phr-newbie> competitive
09:36:16 <xerox> That would have been @map spell :)
09:36:16 <phr-newbie> branded??
09:36:23 <roconnor> newtype Region = Region (Point -> Bool)
09:36:31 <ndm> xerox: wow, with @pl i can get it to spell check and record!
09:36:42 * ndm is scared of lambdabot's power, once more
09:36:47 <emk> petekatz: It also handles things like "65 a72c 66" by mapping them to "Aa72cB".
09:36:51 <roconnor> newtype is like a data type with one constructor with one element.
09:37:08 <emk> The "try" is backtracking if it fails, so we can take two bytes at the apple...
09:37:08 <phr-newbie> heh, i just changed "type" to "newtype" and got an error msg saying there was an unexpected ->
09:37:16 <roconnor> but newtype is designed so that the constructor and destructor can be optimised away.
09:37:35 <roconnor> it is great for data abastraction
09:37:43 <emk> petekaz: There's a probably a corner-case I don't handle correctly somewhere.
09:37:53 <SamB> even better for functions-as-data ;-)
09:37:56 <roconnor> the type is ``branded'' in the sense that it is no longer convertable to the other type.
09:38:18 <SamB> you mean, it longer *is* the other  type
09:38:26 <SamB> ack, extra space..
09:38:36 <roconnor> so that if you do newtype Time = Time Double, and newtype Distance = Distance Double, then you will never accidently add distance and time.
09:38:56 <roconnor> phr-newbie: you need to add a constructor name to use newtype
09:39:09 <roconnor> newtype looks more like a data declaration.
09:39:11 <phr-newbie> yeah i entered it like you said, and i get a different error now
09:39:28 <phr-newbie> Data.List> :l name.hs
09:39:28 <phr-newbie> ERROR "name.hs":7 - Type error in application
09:39:28 <phr-newbie> *** Expression     : r p
09:39:28 <phr-newbie> *** Term           : r
09:39:28 <phr-newbie> *** Type           : Region
09:39:28 <roconnor> now you need to do pattern matching for your funciton
09:39:28 <phr-newbie> *** Does not match : a -> b
09:39:48 <roconnor> (Region r) `inRegion` p = r p
09:40:13 <phr-newbie> oh the error was THERE
09:40:14 <phr-newbie> sec
09:40:52 <SamB> phr-newbie: the point of a newtype is to be a different type from the old type
09:41:08 <roconnor> anyhow, when to use type and when to use newtype is a little bit a matter of taste.
09:41:19 <SamB> well.
09:41:21 <roconnor> I like to use newtype a lot.
09:41:30 <roconnor> It has a saved me on occasion.
09:41:32 <phr-newbie> but i have to put those cast-like things all over?
09:41:47 <int-e> yes
09:41:55 <phr-newbie> hmm
09:42:01 <roconnor> phr-newbie: once you build a few primitives for your abstract data type, you will use just those.
09:42:16 <int-e> well, you can alleviate that with newtype deriving.
09:42:49 <SamB> int-e: but you don't want to multiply distance and distance and get distance...
09:42:54 <int-e> (Which is a glasgow extension though I believe. Haskell 98 does weird things in deriving for newtypes)
09:43:07 <SamB> h98 doesn't do anything wierd!
09:43:11 <phr-newbie> interesting
09:43:13 <int-e> SamB: probably not, right.
09:43:16 <SamB> it just only supports the normal classes
09:43:26 <phr-newbie> i'm still using hugs, haven't gotten around to installing ghc
09:43:39 <int-e> it treats newtype as a data declaration for purposes of deriving
09:44:22 <SamB> for the extension, I think someone basically said "gee, these derivings are so boring, I bet the compiler could do it for *any* typeclass."
09:44:29 <int-e> that's fine for show and read, weird for ord and eq, and useless for wrapping, say, monads in a newtype
09:44:32 <SamB> okay, okay, so it just uses the same dictionary...
09:44:38 <phr-newbie> any idea how to fix the types in my matmult example, so it will take arbitrary nums?
09:45:01 <phr-newbie> http://paste.lisp.org/display/27956
09:45:25 <phr-newbie> this language is reminding me some of APL
09:45:36 <roconnor> what is vector?
09:46:04 <phr-newbie> oh i didn't paste enough
09:46:05 <xerox> roconnor: I know of a good answer to that question :D
09:46:11 <phr-newbie> sec
09:46:16 <roconnor> or what is element
09:46:25 <int-e> SamB: ok, maybe it'd be nice to have a different syntax for reusing dictionaries, but the feature is immensely useful.
09:46:43 <roconnor> xerox: what is the vector
09:46:44 <SamB> int-e: eh
09:46:52 <xerox> roconnor: http://planetmath.org/encyclopedia/Vector2.html
09:46:52 <lisppaste2> phr annotated #27956 with "expanded matmult" at http://paste.lisp.org/display/27956#1
09:46:55 <lambdabot> Title: PlanetMath: vector, http://tinyurl.com/y3s6h9
09:47:03 <roconnor> it's the question that drives us xerox
09:47:10 <roconnor> it's the question that brought you here.
09:47:14 <phr-newbie> so in that example i have an int matrix
09:47:14 <SamB> I think it basically works out to be that Show is the only special case...
09:47:23 <phr-newbie> but i wasn't able to make Element be a general number
09:47:31 <sris> consecutive lines in a do clause that doesn't inlucde any <-, are they "linked" together with >> ?
09:47:34 <phr-newbie> if i want to turn it into floats i have to change Element
09:48:01 <phr-newbie> i think so sris
09:48:06 <roconnor> sris: effectively yes.
09:48:07 <phr-newbie> otherwise you couldn't have consecutive putchars
09:48:21 <SamB> as long as you don't derive any classes whose superclasses aren't derived, but specifically instanced, it should be the same as if GHC went through and wrote the methods...
09:48:41 <phr-newbie> ?
09:48:59 <roconnor> phr-newbie: ah, I believe in haskell you need to make them polymorphic types
09:49:01 <sris> i see, so conesecutive return-statements are effectivley ignored, but the last one?
09:49:14 <lisppaste2> emk annotated #27957 with "Corrected parser" at http://paste.lisp.org/display/27957#1
09:49:19 <roconnor> phr-newbie: so drop element
09:49:25 <roconnor> phr-newbie: type Vector a = [a]
09:49:35 <roconnor> phr-newbie: type Matrix a = [Vector a]
09:49:50 <emk> petekaz: I fixed a bug (I was playing with Parsec today anyway, so this is a good exercise).
09:50:07 <roconnor> rows :: (Num a) => Matrix a -> [Vector a]
09:50:10 <roconnor> etc.
09:50:44 <roconnor> sris: I believe that to be true.
09:50:50 * roconnor a proof shouldn't be too hard
09:50:51 <phr-newbie> oh i see, i had tried type Vector = [a]
09:50:59 <emk> petekaz: This one works for decode "65 72c 66"
09:51:11 <roconnor> phr-newbie: yep, you need to bound that free variable.
09:51:16 <phr-newbie> but can't i qualify it to Num a => a ?
09:51:31 <roconnor> phr-newbie: no in the type declarations I believe.
09:51:45 <roconnor> phr-newbie: this is actually a bit of a defficency of Haskell 98
09:52:25 <roconnor> but I always forget how classes interact with data declairations.
09:52:59 <sjanssen> does GHC's optimizer perform RULES matching before or after newtypes are eliminated?
09:53:04 <ndm> roconnor: you can, i think, its just really badly designed - i'd recommend not doing it
09:53:22 <ndm> sjanssen: don#'t they get fired at several stages
09:53:32 <roconnor> ndm: Data.Set doesn't do it for Ord.
09:53:36 <sjanssen> ndm: probably, but I really don't know
09:53:43 <Igloo> ndm: Is the language you were talking about on g-h-u YHC's core?
09:54:11 <ndm> roconnor: it could, if it wanted, but its not really very handy (makes Set.empty ill typed in some cases)
09:54:13 <roconnor> ndm: oh yeah, I wanted to ask you want type of G-machine are you using for yhc.
09:54:47 <ndm> Igloo: kind of, half of - more my Catch intermediate language, but similar to Yhc's Core
09:54:49 <phr-newbie> so is this improved in GHC?
09:54:55 <ndm> roconnor: no idea, ask the mailing list
09:55:11 <ndm> phr-newbie: don't think so, still not very useful - much easier to annotate every user of the function
09:55:32 <roconnor> no idea!
09:55:33 <SamB> hmm
09:55:33 <ndm> roconnor: http://www.haskell.org/haskellwiki/Yhc/RTS/Machine
09:55:36 <lambdabot> Title: Yhc/RTS/Machine - HaskellWiki, http://tinyurl.com/yf6yds
09:55:39 <SamB> nofib wants dos2unix...
09:55:55 <roconnor> dos2unix is andy
09:55:59 <roconnor> handy
09:56:28 * roconnor feels like building a TIM implementation, just to be different.
09:56:42 <ndm> roconnor: TIM?
09:56:56 <ndm> roconnor: of course, my Yhc -O doesn't use an STG machine, only the normal Yhc
09:57:04 <roconnor> ndm: Three-instruction-machine.
09:57:16 <roconnor> ndm: so what does -O use?
09:57:35 <ndm> roconnor: a Neil machine :) - no name as yet, just something quirky and different
09:57:54 <phr-newbie> ndm i thought the idea of type inference was to get rid of all that annotation?
09:57:55 <roconnor> ndm: I'm expecting big things from you.
09:58:23 <ndm> phr-newbie: you can leave those annotations off, if you want, but if you give any type sig you must give the class stuff (sadly its an all or nothing)
09:58:48 <ndm> roconnor: we'll see :) - i am thinking of implementing generalised deforestation in my Yhc -O as well, so GHC doesn't trounce me at list stuff
09:58:51 <roconnor> phr-newbie: it was the idea, but it didn't work out very well for lots of reasons.
09:58:55 <SamB> yeah, would be nice if you could say...
09:59:05 <phr-newbie> hmm, none of this is in the book I'm reading (Haskell School of Expression).  got any suggestions for the next book?
09:59:10 <SamB> foo :: dwim => m a -> m b
09:59:14 <ndm> more generalised than GHC, i.e. I can deforest Bool's
09:59:33 <ndm> SamB, proposal for Haskell' - underscores in types, foo :: _ => m a -> m b
09:59:39 <SamB> hmm
09:59:42 <phr-newbie> roconnor is that because the typeclass system made things too loose, as compared with ML?
09:59:43 <SamB> could you say...
09:59:45 <roconnor> ndm: So you replace bool by c -> c -> c?
10:00:01 <SamB> foo :: (Monad m, _) => m a -> m b ?
10:00:38 <ndm> roconnor: no, defunctionalising deforestation, so not (all x) has the not fused into the all
10:00:41 <SamB> what is the interface to dos2unix?
10:00:50 <roconnor> phr-newbie: I imagine ML has the same problem.  You can make typing errors, that still have some type, and those types get propogated around untill you randomly get a unificaiton error that is miles away from the problem code.
10:00:56 <ndm> SamB, dos2unix filename > output on the pipe
10:01:17 <roconnor> phr-newbie: by giving functions explicit types you contain how far typing errors can go.
10:01:40 <roconnor> I think giving a function without a type is like giving a proof without stating what you are proving.
10:01:54 <phr-newbie> hmm
10:02:36 * xerox waves to monochrom 
10:02:39 <phr-newbie> i've been putting a type sig on each function but not on the individual terms in the function def
10:02:51 * monochrom sends out wave particles
10:03:02 <roconnor> phr-newbie: that's fine.  That's what I mean.
10:03:23 <roconnor> OTOH, I once couldn't get my HaXML program to type check a long time ago.
10:03:42 <roconnor> by removing some of the type annotations it freed the function from bondage.
10:03:48 <roconnor> then my program worked fine.
10:04:07 <monochrom> haha liberated
10:04:38 <roconnor> I should say removed type annoations from HaXML
10:04:40 <phr-newbie> oh i see, i can put qualifiers in the function defs
10:04:43 <phr-newbie> decls
10:04:52 <roconnor> yes
10:05:33 <roconnor> yhc isn't tagless?
10:05:56 <ndm> roconnor: it seems to have tags, if tags mean what you'd naturally think - not sure if its STG in that sense or not
10:06:03 <ndm> roconnor: Yhc -O is definately tagless
10:06:09 <roconnor> :)
10:06:40 <ndm> a few of the funky optimisations in Yhc -O require taglessness
10:12:36 <pierre__> hello
10:12:59 <ndm> hi pierre
10:18:35 <roconnor> I need a good example for my assembly code excercise
10:18:55 <roconnor> two simple asm objects that are mutually dependent.
10:19:11 <phr-newbie> ?
10:19:14 <phr-newbie> asm is not OO
10:19:45 <roconnor> I'm not so big into asembly so I might be mistaken on my terminology.
10:19:58 <xerox> Do you mean .o file?
10:20:01 <roconnor> but the things you link together with a linker are objects?
10:20:06 <monochrom> two subroutines
10:20:08 <phr-newbie> oh, object files
10:20:20 <phr-newbie> you mean you want to code mutually recursive subroutines in asm
10:20:25 <phr-newbie> ?
10:20:38 <monochrom> and moreover put them in different modules
10:20:41 <roconnor> something like that would do.
10:20:47 <roconnor> monochrom: yes
10:20:50 <phr-newbie> yeah it's no big deal, as long as you pass args on the stack
10:20:50 <roconnor> but simple.
10:20:53 <xerox> odds = 1 : map (+1) evens; evens = map (+1) odds
10:21:19 <roconnor> phr-newbie: I would hope that the args are simple enough to pass in registers
10:21:25 <monochrom> The Lucas sequence is defined in terms of two mutual recurrences.
10:21:35 <roconnor> tail-calls are preferable.
10:21:43 <roconnor> so that a stack isn't needed.
10:21:51 <xerox> Can one do mutually-recursive tail-calls?
10:21:55 <roconnor> monochrom: interesting.
10:22:06 <roconnor> xerox: why not?
10:22:18 <phr-newbie> roconnor if you're trying to do recursion...
10:22:41 <monochrom> play a game of tic-tac-toe.
10:23:17 <monochrom> play a game of tic-tac-toe.  each player makes a move and then tail-calls the other player.
10:23:40 <xerox> Hm, makes sense.
10:24:38 <roconnor> monochrom: the Lucas sequence looks the the Fibonacci sequence, except with a different IV.
10:25:05 <xerox> For P = 1, Q = -1, you get the Fibonacci sequence, if I understand it right.
10:27:48 <monochrom> I have: v(i+1) = (p * v i + d * u i)/2, u(i+1) = (v i + p * u i)/2
10:32:44 <roconnor> maybe I use that de-taging example that someone had
10:32:58 <roconnor> removing "<...>" from a stream.
10:34:17 <roconnor> what is a CTCP-TIME request?
10:34:25 <xerox> @localtime roconnor
10:34:26 <lambdabot> Local time for roconnor is Sat Oct 14 19:34:03 2006
10:48:37 <roconnor> The best thing about vegitable soup in the netherlands is the meatballs.
10:49:18 <Magicman> Agreed.
10:49:42 <monochrom> Nice!
10:54:58 <emk> Data.Map is a happy thing.
10:55:25 <monochrom> A Data.Map user is a happy user.
10:56:03 * SamB thinks it is the other way round
10:56:19 <SamB> a happy user is a Data.Map user
10:56:28 <SamB> at least, if happy is up-to-date ;-)
10:56:47 <emk> I think every language (including the ones with state) should have nice purely-functional data structures.
10:57:13 <pierre-> is there any single function instead of "do { a <- xxx; return (f a)}"?
10:57:17 <emk> It makes nested scopes so wonderfully easy.
10:57:33 <Magicman> xxx >>= return.f
10:57:35 <emk> pierre-: liftM f xxx?
10:57:40 <Magicman> Even better :p
10:57:54 * roconnor consults Dr. Haskell
10:57:59 <ski> @. pl undo do { a <- xxx; return (f a)}
10:58:00 <lambdabot> f `fmap` xxx
10:58:00 <int-e> @type ap
10:58:02 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:58:08 <emk> There's also liftM2, etc..
10:58:09 <pierre-> emk: thanks :-)
10:58:50 <roconnor> -- liftM f m
10:58:51 <roconnor> use_liftM m f = m >>= return . f
10:59:01 <emk> fmap is the same as liftM in this case, but there's no equivalent of liftM2, liftM3, and so on. You can also use `ap` if you have a whole bunch of args...
10:59:11 <ndm> roconnor: the rules in Dr Haskell are not guaranteed to be correct, just as a warning
10:59:45 <roconnor> ndm: Dr. Haskell is batting 2/2 so far.
11:00:50 <ndm> neat, i should probably add Dr Haskell to the HCAR
11:00:54 <emk> ?type return f `ap` 1 `ap` 2
11:00:56 <lambdabot> Not in scope: `f'
11:01:10 <roconnor> we need to add dr haskell to lambdabot. ... unless we already have it
11:01:12 <emk> D'oh.
11:01:24 <roconnor> @pl xxx >>= return.f
11:01:25 <lambdabot> f `fmap` xxx
11:01:31 <xerox> fmap
11:01:43 <xerox> Aw, faster.
11:01:43 <roconnor> damn it, it's not infix! :)
11:01:43 <emk> ?type return (+) `ap` return 1 `ap` return 2
11:01:43 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
11:01:52 <xerox> @pl \f xs -> xs >>= return . f
11:01:52 <lambdabot> fmap
11:02:12 <emk> xerox: lambdabot is smart!
11:02:30 <roconnor> @vixin You're smart!
11:02:30 <lambdabot> My instant messenger doesn't work.
11:02:37 <roconnor> *l*
11:03:31 <ndm> roconnor: i'd be happy for someone to add dr haskell to lambdabot, would be a nice extension, but requires a Yhc setup on Lambdabot (which will happen eventually)
11:05:54 * SamB wonders how long until lambabot becomes a *nix distro
11:07:20 <Philippa> heh. That reminds me, I've concluded that Flippi isn't going to be my ultimate personal wiki...
11:07:30 <Philippa> because what will be is an object capability-based wiki
11:07:45 <Philippa> (yes, complete with the capability for root to add new code)
11:09:53 <therp> is cabal intended to be installed as a stand-alone version or in conjunction with ghc?
11:10:36 <therp> because even though the source code is identical the stand-alone version is compiled quite different than the version in ghc cause mismatch in exported symbols
11:12:37 <dolio> Wow. Mapping the characters in an operator to precedence?
11:13:58 <SamB> dons: around?
11:14:07 <SamB> or are you headed back to .au?
11:14:22 <emk> Philippa: Thanks for the advice on unification monads the other day. I think you might be able to implement a very general one in Haskell using Data.Dynamic in the internal hash table, and only maintaining type safety at the ref level.
11:14:46 <SamB> oh, wait, he was going to google
11:15:02 <SamB> anyway... the size limit on cvs-ghc seems a bit small...
11:15:31 * ski wonders what a unification monad is
11:15:44 <SamB> ski: it sounds like it is for typecheckers and stuff like that
11:15:52 <emk> ski: Basically, building Prolog using a monad. :-)
11:16:13 <emk> There's a really gorgeous one (using Scheme) in _The Reasoned Schemer_.
11:16:47 <ski> emk : like
11:16:54 <ski> http://www.cs.chalmers.se/~peb/pubs/p00-logvars-Haskell.pdf
11:16:55 <emk> It's basically a Haskell program (with lazy evaluation, no mutable state, and a monad) written in Scheme.
11:16:56 <lambdabot> http://tinyurl.com/yxa4nq
11:16:58 <ski> Typed logical variables in Haskell
11:16:59 <ski> ?
11:17:13 <emk> Probably. :-) Let me take a look.
11:20:34 <RyanT5000> what's the system called for numbering all possible lambda calculus functions?
11:20:39 <RyanT5000> they are countable, right?
11:20:55 <ski> 'enumeration' maybe ?
11:21:08 <RyanT5000> there isn't a dude's name attached to it?
11:21:18 <dolio> Goedel numbering?
11:21:36 <RyanT5000> that might be it
11:21:41 <SamB> but, that doesn't count functions
11:21:44 <SamB> only expressions...
11:22:20 <mcnster> dcoutts, are u awake?
11:22:21 <SamB> isn't (\x.x) the same function as (\y.y) ?
11:22:23 <dolio> "Given a countable set S, a Gdel numbering is a function ..."
11:22:47 <mcnster> got a small q about gtk2hs...
11:22:54 <SamB> oh
11:22:57 <emk> ski: Ah, they build everything on top of ST. We were talking about an ST-free solution. Still, a good paper to add to my bibliography database.
11:22:59 <dolio> And functions in the lambda calculus should be countable.
11:23:05 <SamB> okay, okay.
11:23:34 <RyanT5000> second question: is this an appropriate way of determining how many bits a given lambda function is?
11:23:38 <SamB> so you normalize the identifiers first, then you numberize.show ;-)
11:23:46 <fasta> RyanT5000: homework?
11:23:48 <dolio> At least, I think. You can write them down as strings of characters, so they should be countable.
11:23:59 <RyanT5000> fasta: i'm in law school, so no :P
11:24:13 <ski> emk : ok
11:24:17 <SamB> dolio: if you like to count some twice ;-)
11:24:22 <fasta> All algorithms are countable => lambda calculus is a formalism for expressing algorithms
11:24:54 <dolio> :) Better than counting them 0 times.
11:25:23 <RyanT5000> alright, so if i want to measure the amount of information in a lambda function, can i just basically take the log2 of some reasonable godel numbering of lambda functions?
11:25:41 <SamB> I've often wondered, though, how you represent the length of a string in the number...
11:25:46 <SamB> or, well, what a good way is
11:25:50 <monochrom> I think godel numbering contains too much junk.
11:26:24 <monochrom> but perhaps "reasonable godel numbering" is something totally unlike godel numbering
11:26:38 <RyanT5000> ah
11:26:58 <RyanT5000> well, you see, as a law student, i can use words like "reasonable" and they just magically fix my problems
11:27:14 <monochrom> To measure a function f, I would first try to find the shortest function that behaves like f.
11:27:16 <Philippa> emk: yes, you could. I tend to ignore Data.Dynamic when I'm talking about type safety
11:27:18 <RyanT5000> are you liable for injuring someone? yes, if a *reasonable person* would not have done so
11:27:26 <fasta> monochrom: an incomputable problem
11:27:36 <RyanT5000> monochrom: yeah, that sounds like finding the normal form
11:27:44 <RyanT5000> i'm actually fine with measuring it as-written
11:27:45 <monochrom> Yes, but I can give my best shot, that will give me some bounds.
11:27:46 <Philippa> RyanT5000: as opposed to if no reasonable person would've?
11:27:59 <RyanT5000> Philippa: is that even different?
11:28:09 <monochrom> See, I can aim at a "reasonably short" one too :)
11:28:10 <RyanT5000> ah, yeah
11:28:20 <emk> Philippa: Yeah, me too. But since that approach could meet the proof burden of type safety at a higher level, it wouldn't be too awful.
11:28:41 <Philippa> it's hugely important if you're talking about eg what a reasonable person would percieve
11:28:46 <RyanT5000> Philippa: you're probably right, actually - i haven't actually taken that class yet, and i'm sure the answer's between the two
11:29:14 <dons> SamB: I'm here in the US till Tuesday
11:29:14 <Philippa> and varies from legal system to legal system :-)
11:29:19 <dons> and at google all day today
11:29:33 <fasta> dons: did they brainwash you already?
11:29:39 <RyanT5000> Philippa: yah, well, i'm in the US
11:30:03 <gmh33> dons: they haven't hired you yet ? :P
11:30:09 <fasta> Or was it more like a massage(pun) to the mind?
11:30:28 <fasta> Or he had to solve all kinds of puzzles...
11:30:45 <RyanT5000> ok so let me rephrase my question: hasn't someone, at some point, measured the amount of information in a written lambda function?
11:30:54 <RyanT5000> that's really what i want
11:31:11 <RyanT5000> i want a reasonably good estimation of the entropy present in a program
11:31:33 <dolio> Information?
11:31:34 <monochrom> No, I don't think so.  People are too busy measuring or theorizing information in a Turing machine.
11:31:39 <gmh33> I thought both church and turring found that to be impossible..
11:31:48 <ski> RyanT5000 : like kolmogorov complexity ?
11:31:55 <dons> fasta: well, they gave me lots of stuff. tshirts and toys.
11:31:55 <sjanssen> dons: the most important question: have you convinced Google to port all their software to Haskell?
11:31:56 <emk> RyanT5000: You usually don't get a rigorous measure of entropy without specifying your assumptions very carefully--among other things, it's a non-local property.
11:32:05 <RyanT5000> ski: once i look that up, i'll know :P
11:32:18 <fasta> I don't know of estimation being impossible
11:32:19 <monochrom> You see any time they want to measure ___-complexity they use the Turing machine.  Imperative programming as a religion is rampant not just in the industry.
11:32:41 <dons> sjanssen: hehe. people in general seem to be interested in darcs. that's one thing. and there's a lot of awareness of haskell amongst the larger projects, perl, netbsd, python and so on.
11:32:52 <dons> they know our community to some extent
11:32:58 <sjanssen> that's cool
11:33:01 <gmh33> linspire :P
11:33:29 <sjanssen> darcs is the gateway drug.  They'll get into the hard stuff (Haskell) eventually
11:33:51 <dons> at least one of the perl guys was interested that we had students (i.e. sjanssen) who actually wrote tests for their projects :)
11:33:51 <gmh33> darcs got me a compilable version of Io last night :P
11:33:54 <fasta> sjanssen: I don't think darcs is that impressive when it still has bugs.
11:34:02 <monochrom> darcs is too much quantum physics to me
11:34:03 <dons> he thought this reflected on the quality of the haskell community ;)
11:34:17 <monochrom> (that's my way of saying "it's all Greek to me")
11:34:29 <fasta> I think darcs is a program for which it should be possible to get it bug-free.
11:34:48 <dons> its approaching bug free in the limit. i certainly haven't run into bugs in the last 12 months
11:34:54 <dons> across all the projects i've worked on.
11:34:58 <sjanssen> fasta: yeah, it's really rough when you hit a darcs bug/seeming exponential time complexity situation
11:35:06 <dons> and most of the haskell community uses darcs now, so it must work reasonably wel...
11:35:18 <SamB> well, recently I had a nasty problem with my GHC working repo...
11:35:31 <fasta> dons: it works reasonably well, I agree.
11:35:36 <SamB> I think the version of darcs I was using had inadequate signal handling...
11:35:42 <arjanb> how well darcs works depends a lot on the workflow
11:35:46 <SamB> or error handling
11:35:54 <SamB> or worse
11:36:26 <fasta> Does darcs integrate very easily with Emacs 22 already?
11:36:30 <SamB> so anyway I had some patches in my inventory that weren't in my _darcs dir, but the changes still seemed to be in the files...
11:36:48 <SamB> and not revertable...
11:36:59 <SamB> but darcs repair came up with nothing :-(
11:36:59 <emk> Version control systems are a total pain--the correctness conditions are very, very stringent, the problem is surprisingly complex, and you have to deal with the OS in a very rigorous way.
11:37:11 <SamB> yeah
11:37:18 <SamB> even Haskell can't deal with that very well!
11:37:57 <fasta> Lets invent a new DSL for writing VCS!
11:38:04 <fasta> No, wait! Please don't do that!!
11:38:40 <emk> Well, Haskell gives you a leg up on various non-OS parts of the problem. But there's still several distinctly different models for what a "change" is.
11:38:44 <SamB> you mean a new DSL for writing darcs in?
11:39:29 <SamB> oh rats :-(
11:39:30 <emk> It took the monotone people (who are very careful about their theoretical model) several major redesigns until they'd solved all the corner cases.
11:39:56 <SamB> that cvs-ghc list *really* needs a higher limit if I can't even attach an 80kb text file to my message and get it through...
11:40:28 <SamB> emk: I'm talking about the OS-related parts...
11:40:50 <SamB> basically atomicity in general, I guess...
11:41:08 <SamB> (that is, not hosing the repo when dying in the middle of an operation...)
11:42:50 <emk> SamB: Well, it's one tricky thing after another to build a production-quality version control system. :-( The Subversion FSFS backend never mutates existing data, which makes it easier to prevent corruption.
11:43:14 <SamB> emk: indeed
11:43:15 <vegai> never?
11:43:18 <SamB> far far
11:43:48 <SamB> vegai: presumably the directory tables need to be mutated by the filesystem driver in most cases...
11:44:08 <emk> vegai: Each FSFS transaction is committed as a new file. There's a few metadata files which can be edited by an administrator, but they're not where the action is.
11:44:47 <emk> So FSFS essentially does a replay of a 10,000-item transaction log before letting you look at revision 10,000.
11:45:06 <SamB> hmm
11:45:23 <SamB> you'd think they could maybe make new files and then remove old ones...
11:45:30 <RyanT5000> emk: wouldn't it be fairly easy to cache the replay?
11:45:35 <fasta> @what FSFS
11:45:35 <lambdabot> I know nothing about fsfs.
11:45:36 <RyanT5000> (without getting corruption issues)
11:45:43 <monochrom> Am I seeing that the Subversion people have discovered a virtue of immutable persistence, i.e., functional programming?
11:45:48 <SamB> fasta: a SVN backend
11:45:51 <RyanT5000> lol
11:45:52 <emk> It's fine at around 10,000 revisions, but allegedly starts to hurt at 100,000. RyanT5000: Yeah, in server mode, they keep the necessary bits in RAM.
11:45:55 <fasta> SamB: yes, I read that.
11:45:59 <RyanT5000> ah
11:46:05 <fasta> SamB: I wanted more information.
11:46:10 <SamB> @google svn fsfs
11:46:12 <fasta> SamB: google suffices
11:46:13 <lambdabot> http://web.mit.edu/ghudson/info/fsfs
11:46:13 <RyanT5000> well if you keep something in ram, caching it out to disk is only a small step away :P
11:46:17 <SamB> hmm
11:46:30 <RyanT5000> i mean as long as you make a relatively small, simple cache manager
11:46:35 <emk> monochrom: Yup. FSFS is an excellent argument for immutability in a real-world system.
11:46:52 <RyanT5000> with very formal constraints
11:47:34 <emk> I think they grew tired of debugging stateful nastiness with the BerkleyDB backend, and chose the exact opposite approach.
11:47:39 <fasta> @what+ FSFS http://web.mit.edu/ghudson/info/fsfs
11:47:39 <lambdabot> I know nothing about fsfs.
11:47:44 <RyanT5000> huh
11:47:52 <SamB> emk: nice
11:48:06 <RyanT5000> so now they just have O(n^2) nastiness >.>
11:48:13 <SamB> that would certainly explain why they go so far in that direction ;-)
11:48:31 <SamB> O(n^2) is better than O(hair-gone)
11:48:41 <RyanT5000> lol
11:48:48 <Philippa> not always...
11:48:54 <Philippa> sometimes linear is bad enough
11:49:16 <SamB> wait, where do you get the ^2 anyway?
11:49:17 <kpreid> @remember SamB O(n^2) is better than O(hair-gone)
11:50:11 <RyanT5000> SamB: the time to do n updates starting with a blank system
11:50:32 <SamB> well, that is only a worst-case...
11:50:41 <RyanT5000> true
11:50:49 <fasta> Sounds pretty bad, still.
11:50:49 <RyanT5000> well, not if you don't cache anything
11:50:51 <emk> The interesting thing about FSFS is that out-competes the old, stateful backend, even with both available in the same executable. The users prefer the integrity of immutability to the performance of state under real-world circumstances.
11:51:03 <SamB> however, I still think you underestimate their datastructures
11:51:13 <RyanT5000> yeah, probably
11:51:25 <RyanT5000> and if you know n won't be too big, you still don't have to care
11:51:31 <SamB> well, n will be big
11:51:34 <fasta> How can you know anything anyway about data structures when you stufy law?
11:51:39 <fasta> er study
11:51:47 <RyanT5000> fasta: i did computer science undergrad
11:51:51 <fasta> RyanT5000: ah, ok
11:51:57 <SamB> heh
11:51:57 <RyanT5000> and i plan to get a CS ph.d. afterwards
11:52:14 <RyanT5000> which means i have no idea why i'm paying $150k to go to law school, lol
11:52:25 <SamB> so CSI can take on a whole new meaning now?
11:52:28 <RyanT5000> lol
11:52:52 <RyanT5000> i just reviewed a paper on "the CSI effect" for the journal on law and technology here
11:52:57 <RyanT5000> it wasn't very good
11:53:04 <SamB> as can be expected!
11:53:09 <SamB> my joke wasn't very good either!
11:53:14 <fasta> It sounds like a blog entry!
11:53:26 <RyanT5000> basically the guy did a small survey and said "now people want more scientific data, but it's not actually because of watching CSI"
11:53:46 <pejo> fasta, quite a lot of self taught programmers know the "useful" stuff about data structures.
11:53:47 <lambdabot> pejo: You have 1 new message. '/msg lambdabot @messages' to read it.
11:54:15 <RyanT5000> pejo: quite true; in fact, i didn't learn anything much about them from undergrad
11:54:34 <RyanT5000> "data structures and algorithms" ran out of steam at simple graph analysis
11:54:50 <fasta> pejo: People I speak on Internet seem to have that property, yes, in the real world people tend to do worse.
11:54:50 <RyanT5000> like spanning trees and dijkstra pathfinding
11:55:50 <RyanT5000> does anyone know where the best place to go to grad school for programming language theory is?
11:56:15 <monochrom> several.  cmu is one.
11:56:17 <RyanT5000> i'm in cambridge, mass, so i have a preference toward MIT (if i can get in)
11:56:18 <emk> RyanT5000: I suppose it depends on the kind of theory you like. :-) It's a big field.
11:56:28 <monochrom> MIT may be weak.
11:56:44 <RyanT5000> right now i'm interested primarily in namespaces and staged compilation
11:57:09 <monochrom> Basically note the big names (you can easily find them from the books we all tout about, TaPL and all that), then find out where they are.
11:57:17 <RyanT5000> alright
11:57:41 <monochrom> I am not actually into programming language theory, so I can't be specific, I can only specify an algorithm.
11:57:55 <emk> Hmmm. That might be one of those circumstances where you need to find the people researching the problem, and look to see where they are.
11:58:30 <RyanT5000> yeah, that was my plan, but i wanted to see if #haskell had a strong opinion, or places to look at that i wouldn't have thought of
11:58:50 * emk doesn't know who's doing staged compilation
11:58:56 <monochrom> Others have more specific recommendations when they're awake.
11:59:11 <RyanT5000> yah, i'll get on tonight
11:59:21 <Philippa> I got lucky, I went to the right uni anyway. Then I got unlucky, and never graduated...
12:05:45 <gour> Philippa: and now? are you lucky or unlucky?
12:06:45 <Philippa> I'm not involved in anything academic. The rest's a very long story and nowhere near on-topic
12:08:09 <gour> ok. btw, what's the topic ;)
12:08:47 <monochrom> The Life and Death of An Average Haskell Programmer.
12:11:37 <gour> there is also death?
12:12:48 <sjanssen> @hoogle death
12:12:49 <lambdabot> No matches found
12:12:59 <RyanT5000> @hoogle kill
12:13:00 <lambdabot> Control.Concurrent.killThread :: ThreadId -> IO ()
12:13:00 <lambdabot> System.Console.Readline.killText :: Int -> Int -> IO ()
12:13:00 <lambdabot> Control.Exception.ThreadKilled :: AsyncException
12:13:21 <SamB> monochrom: I suspect that the Death is pretty boring...
12:13:22 <sjanssen> @hoogle wmd
12:13:23 <lambdabot> No matches found
12:13:23 <RyanT5000> we're like elves: no natural death, just killing
12:14:07 <SamB> threads can die naturally!
12:14:23 <RyanT5000> true
12:14:27 <SamB> fork (return ())
12:14:33 <SamB> or is that forkIO
12:14:35 <SamB> whatever
12:14:39 <RyanT5000> forkIO
12:14:43 <RyanT5000> or forkOS
12:14:47 <RyanT5000> if you want a real thread :P
12:15:08 <SamB> ... just to die immediately? are you kidding?
12:15:22 <RyanT5000> shouldn't we have a forkST as well?
12:16:51 <SamB> I was just thinking that that might be nice
12:17:18 <RyanT5000> another thing: has anyone put any thought into a haskell compiler for PS3?
12:17:18 <SamB> but it would probably need *at least* ATs or MPTCs/fundeps
12:17:23 <SamB> er.
12:17:26 <SamB> to get it nice...
12:17:30 <RyanT5000> huh
12:17:37 <SamB> without having to have all those names...
12:17:44 <SamB> with STs on the end...
12:17:53 <SamB> or the beginning
12:17:57 <Philippa> RyanT5000: haskell itself isn't necessarily a good choice of language. A strict-by-default haskell with ATs and some serious built-ins, however, would work wonders
12:18:11 <SamB> huh
12:18:15 <RyanT5000> yeah
12:18:37 <SamB> strict-by-default?
12:19:13 <Philippa> no point in not supporting laziness at all
12:19:16 <sjanssen> RyanT5000: we shouldn't have forkST
12:19:25 <RyanT5000> sjanssen: why not?
12:19:45 <sjanssen> RyanT5000: because scheduling would break referential transparency
12:19:45 <RyanT5000> wouldn't a multicore chip doing an array transform be a lot faster with it?
12:19:53 <RyanT5000> huh
12:20:04 <RyanT5000> that's a very good point
12:20:38 <RyanT5000> i still think there should be partitions of IO though
12:20:45 <RyanT5000> one of which could look very simmilar to ST
12:21:02 <sjanssen> ST + Threading?
12:21:18 <RyanT5000> no, IO - everything_but_ST
12:21:31 <RyanT5000> runSTIO :: STIO a -> IO a
12:21:37 <sjanssen> oh, did you know of this function?
12:21:40 <RyanT5000> no
12:21:42 <sjanssen> @hoogle stToIO
12:21:42 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
12:21:44 <RyanT5000> ah
12:21:49 <RyanT5000> ok yeah
12:21:57 <RyanT5000> that's basically what i'm thinking of
12:22:14 <RyanT5000> except that that would be the *only* way of using this monad
12:22:51 <sjanssen> why is that an advantage?
12:22:58 <SimonRC> I recently wanted a two-way pipe between an IO thread and an ST thread.
12:23:14 <RyanT5000> well, you *could* thread in it
12:23:28 <SimonRC> I went for IO in both, in the end
12:23:31 <RyanT5000> the idea being that it'd be exactly like IO, minus the I/O
12:23:32 <SimonRC> :-(
12:23:41 <sjanssen> SimonRC: yeah, that's tricky
12:23:42 <RyanT5000> and with only a subset of the program state it could modify
12:23:45 <SimonRC> RyanT5000: sounds good
12:23:56 <RyanT5000> basically the idea is to partition IO up into separate domains
12:23:59 <emk> IO is a special case of ST, but (for various entertaining reasons) you can't define your own special cases.
12:24:04 <sjanssen> you could probably hack up something with unsafeInterleave{IO, ST} and lists
12:24:13 <SimonRC> sjanssen: but it great for a game with a complicated interface and a lot of stuff below the AI layer.
12:24:45 <RyanT5000> well anyway, i'll be back in a while
12:25:01 <sjanssen> SimonRC: you could also write the pure stuff in ST, and make sure it's always polymorphic in the 's' parameter
12:25:22 <emk> unsafeRunIO really wants "ST RealWord a", and runST really wants "forall s. ST s a", with the "s" able to take on any type.
12:25:27 <sjanssen> then use that stToIO function to run stuff in the IO monad while keeping all the STRefs alive and such
12:26:11 <sjanssen> then you can guarantee that the ST code is deterministic/doesn't do IO,  but still have some kind of communication
12:28:27 <emk> @pl f g h = (g x, h y)
12:28:27 <lambdabot> f = (. ($ y)) . (,) . ($ x)
12:28:47 <emk> f g h = \(x,y) -> (g x, h y)
12:28:55 <emk> @pl f g h = \(x,y) -> (g x, h y)
12:28:56 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
12:29:33 <emk> Ah, no. Is there an idiomatic way to build a function which operates on pairs from functions which operate on each half?
12:29:58 <moconnor> If I see someone use a function from a library, but they didn't explicitly import it, what's the canonical way of finding what library the function came from?  E.g. I just googed for "munch haskell" to find that "munch" comes from "Text.ParserCombinators.ReadP".  Is there a better way than Googling to figure that out?
12:29:58 <sjanssen> emk: maybe the Control.Arrow combinators can help?
12:30:15 <sjanssen> @type Control.Arrow.(***)
12:30:16 <lambdabot> Couldn't find qualified module.
12:30:16 <kpreid> ?type (&&&)
12:30:17 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:30:27 <int-e> @type (***)
12:30:28 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:30:42 <int-e> @type (Control.Arrow.***)
12:30:44 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:30:48 <sjanssen> moconnor: hoogle  is a bit better than google
12:30:50 <kpreid> (er, yeah. &&& is for getting two results from a single value)
12:30:51 <sjanssen> @hoogle munch
12:30:51 <emk> sjanssen: OK, if there's nothing more standard the Control.Arrow, then it's probably clearest if I just write it out.
12:30:52 <lambdabot> Text.ParserCombinators.ReadP.munch :: (Char -> Bool) -> ReadP String
12:30:52 <lambdabot> Text.ParserCombinators.ReadP.munch1 :: (Char -> Bool) -> ReadP String
12:30:54 <emk> Thanks!
12:30:56 <monochrom> (f *** g) (x,y) = (f x, g y)
12:31:26 <emk> monochrom: Very nice.
12:31:27 <moconnor> sjanssen: thank you!
12:31:41 <monochrom> moconnor: Google for Hoogle.  You will never look back.
12:31:45 <kpreid> emk: the 'first' and 'second' combinators are also interesting (they operate on one half and leave the other alone)
12:31:57 <sjanssen> moconnor: also, :info func in a ghci prompt will tell you where func was defined
12:32:33 <emk> kpreid: Yeah, I like them. But I'm trying not to drag anything too exotic into the program in question, because it's Literate Haskell and I'd have to explain it. :-)
12:36:34 <sjanssen> anybody else notice how brianh emails the haskell-cafe mailing list about once a week asking to change Haskell syntax to make writing editors easier?
12:37:23 <fasta> sjanssen: I think everybody does that reads the list.
12:37:37 <sjanssen> it's kinda getting old
12:37:48 <fasta> sjanssen: he also answers questions. So, I don't care.
12:38:15 <fasta> sjanssen: and besides: what are you going to do to make him stop?
12:38:28 <sjanssen> fasta: nothing.  I'm just gossiping
12:38:40 <fasta> sjanssen: oh, how female of you.
12:40:08 <musasabi> gossipping can be fun with the right people.
12:40:11 <dons> ok. got the news on google + haskell.
12:40:21 <sjanssen> oh?
12:40:32 <dons> they don't use haskell for any official projects, but there are several people who use haskell on the side, and are interested in it
12:40:40 <dons> they use java, C++ and python almost only
12:40:44 <dons> all running on linux
12:41:07 <dons> now, they're quite interested in haskell, but are held back by lack of real-world tutorials and education
12:41:15 <fasta> Google decided to strip haskell from all search results (I got that from an internal memo)
12:41:18 <dons> and concerns about monadic io
12:41:35 <dons> fasta: hmm?
12:41:48 <integral> concerns about monadic io?
12:41:54 <fasta> dons: never mind
12:42:02 <dons> just the usual thing from the outsiders point of view, looking at haskell.
12:42:13 <dons> we need to reassure them that writing side-effecting code is possible, and very ncie
12:42:25 <dons> they were quite interested in House, for example
12:42:25 <integral> Ah, the lack of tutorials that s/monads/fluffy bunny rabbits/
12:42:30 <dons> right
12:42:41 <dons> and doing hard stuff. i.e. things like concurrency/parallel tutorials
12:42:45 <sjanssen> we need to kill the IO sucks in Haskell myth
12:42:49 <dons> yes
12:42:56 <fasta> Well, I think they are right. Documentation lacks for lots of stuff.
12:42:57 <darinm> what kind of tutorial on monads would make them happy?
12:43:03 <darinm> I mean, there are already quite a few tutorials out there
12:43:09 <dons> i think we should write some: Write Imperative, side effecting code in Haskell, Now!
12:43:24 <fasta> I don't think there aren't enought Monad tutorials.
12:43:28 <fasta> er enough
12:43:32 <integral> a tutorial showing off `par` would be handy.
12:43:35 <dons> fasta: thanks for your input
12:43:50 <fasta> dons: I can also be more constructive.
12:44:02 <sjanssen> integral: I agree, I find it tough to wrap my head around par
12:44:07 <xerox> dons: you went there for doing consultancy or applying for a job? hehe
12:44:16 <dons> nope. summer of code summit
12:44:24 <xerox> Oh.
12:44:28 <xerox> Mentors summit?
12:44:29 <integral> sjanssen: I wonder how deep it is.  I suppose for the best effect you want it to be computing something strict
12:44:32 <dons> lots and lots of interesting guys here. netbsd, python, perl, freebsd, google
12:44:32 <darinm> I'd be interested in writing a tutorial, but I haven't done too much concurrency stuff
12:44:33 <int-e> Prelude GHC.Base> unsafeCoerce# "abc" :: Int
12:44:34 <int-e> Segmentation fault (core dumped)
12:44:35 <dons> apache
12:44:36 <darinm> in Haskell that is
12:44:42 <int-e> yay ;)
12:44:45 <dons> int-e: welcome to C ;)
12:44:56 <int-e> dons: is that side-effecting enough?
12:44:57 <integral> Oh, who's the perl people?
12:45:04 <integral> s/who's/who're/
12:45:14 <dons> I think Larry is here? Have't seen him yet. The other guy is ... let me see...
12:45:36 <dons> ah, Robert Spier
12:45:55 <int-e> What, unsafeCoerce# is kind-preserving? how boring :/
12:45:59 <integral> cool.  he was running the SoC stuff at TPF this year
12:46:16 <xerox> Robespierre? :P
12:46:30 <pejo> dons, netbsd = Niels Provos?
12:46:44 <dons> oh hmm. maybe it is Niels. hang on...
12:46:59 <dons> nope, Hubert Feyrer and Alistair Crooks
12:47:00 <sjanssen> @remember int-e What, unsafeCoerce# is kind-preserving? how boring :/
12:47:00 * monochrom mumbles about "Tackling the Awkward Squad"
12:47:19 <dons> monochrom: yes. we need to really really make it clear that io is not a problem
12:47:23 <fasta> Erlang has some kind of "official" library system, which I would like to see being adopted for Haskell. I think it's stupid that logBase has not defined what the meaning of its arguments are. You need to try out a few values to check.
12:47:27 <dons> too much time is spent explaining this
12:47:39 <integral> fasta: oh yeah.  I hate logBase's documentation :-)
12:47:48 <sjanssen> fasta: the Haskell report doesn't say?
12:47:59 <dons> yeah. i think this is  what the library report is for, fasta.
12:48:05 <dons> and then the new haskell' library effort
12:48:12 <roconnor> > logBase 2 8
12:48:12 <fasta> sjanssen: It might, but as a "user" I don't care about that.
12:48:13 <lambdabot>  3.0
12:48:14 <dons> ?hoogle logBase
12:48:15 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
12:48:16 <monochrom> The thing is the Google people are educated enough to make sense out of "Tackling the Awkward Squad".
12:48:17 <roconnor> makes sense t ome
12:48:17 * integral wouldn't choose the report as the first port of call :-/  The haddock docs have clickable links and stuff
12:48:29 <dons> its in the Prelude, hence logBase should be documented in the h98 report
12:48:34 <int-e> sjanssen: actually it isn't. I'm too dumb to read error messages :)
12:48:43 <roconnor> the name is the documentation :P
12:48:44 <dons> monochrom: right. they are.
12:48:47 <fasta> dons: technically you are right, but that's beside the point, imho.
12:49:05 <monochrom> OK good.
12:49:15 <dons> fasta: you said we should have some "kind of "official" library system". we do :)
12:49:32 <sjanssen> fasta: a standardization process won't help with the logBase thing.  logBase is a standard operator, we just need to copy the docs from the report into haddock
12:49:40 <dons> yeah
12:49:53 <dons> submit a bug report with a doc fix, fasta.
12:49:56 <fasta> dons: I mean a standard for inclusion. And apparently the haskell' libraries effort does not raise the bar high enough. I will see whether I can locate the document.
12:50:08 <integral> Have you seen the cool thing the perl6 people have with their spec and their test cases being automatically merged?
12:50:14 <xerox> dons: any photo of the event? :)
12:50:35 <dons> xerox: some , i'll take some more. though we're not actually allowed to photograph the facilities...
12:50:42 <xerox> Aww :(
12:50:46 <dons> including the massage tables, games rooms and so on..
12:50:49 <monochrom> Hahahaha, somehow "automatic fixity" is too funny for me
12:50:59 <dons> the big screen with all the search terms listed on them...
12:51:05 <xerox> YUCK.
12:51:15 * dons sits here and watches people type in queries
12:51:33 <lispy> dons: you're watching people type in google queries?
12:51:47 <sjanssen> @google respect my privacy, dons
12:51:50 <lambdabot> http://www.donsbulbs.com/cgi-bin/r/t.pl/info.html
12:51:50 <dons> they have them on a screen, the queries, scrolling up, in the foyer
12:51:50 <lambdabot> Title: donsbulbs General Site Information
12:51:51 <dolio> monochrom: The haskell-cafe thread?
12:51:56 <monochrom> Yah.
12:52:02 <dons> thanks sjanssen
12:52:04 <dolio> Heh, yeah, that was ridiculous.
12:52:10 <lispy> dons: that just seems crazy
12:52:41 <sjanssen> I would think the queries would come too fast to even render on a screen
12:52:50 * lispy too
12:53:00 <dolio> I'm pretty sure that the precedence of the operators in prelude were defined by their function, not by the characters they contain. :)
12:53:03 <lispy> must be like 1/10000 queries or such
12:53:17 <zarvok> plus I think they filter out "inappropriate" ones
12:53:30 <lispy> yeah, brian has some crazies ideas to make his IDE easier to write
12:53:48 <lispy> some are good, some just start debates :)
12:54:20 <lispy> i like the response that his editor should assume infixl 9 when it doesn't actually know the precedence
12:54:26 <lispy> or maybe it could ask a compiler
12:54:34 <dons> zarvok: yep. its one query a second, and they seem filtered
12:54:50 <dolio> :)
12:54:59 <lispy> maybe it's only queries from inside the google complex?
12:55:30 * roconnor starts working on balance
12:56:03 <SamB> roconnor: oh man I don't get how to do that!
12:56:24 <roconnor> I just need like 16 more points before I have the 3006 needed for root access
12:56:25 <SamB> dons: I sent things to cvs-ghc
12:56:30 <SamB> I don't see them...
12:56:33 <dons> SamB: yeah i see. they got blocked
12:56:37 <dons> why did they get blocked?
12:56:43 <SamB> dons: too big
12:56:53 <dons> ah. i'll see if i can get them through tonight then
12:56:55 <SamB> if you would up the max size to 250k that would be nice ;-)
12:56:57 <dons> bit busy to work it out now
12:57:10 <SamB> but you can get them through manually easily enough...
12:57:29 <dons> yes. got to go to a meeting now. i'll look after work
12:57:35 <SamB> ah
12:57:47 <SamB> anyway, 250k would be a nice limit!
12:58:35 <SamB> it is unfortunate that darcs needs the entire commit message in the context...
13:01:49 <xerox> dons: so you flew over the us for that?
13:03:37 <dons> xerox: they flew *me* ;)
13:03:54 <xerox> YUCK
13:03:59 <xerox> They paid for all the mentors?
13:04:16 <dons> YAY
13:04:24 <SamB> xerox: well, if they want to talk to them!
13:04:25 <Igloo> 2 per org AIUI
13:04:38 <SamB> you know how google is about telecommuting...
13:05:29 <xerox> So my idea of having Haskell.org mentoring organization was worth a fly and a peek into Google to you!
13:06:08 <fasta> dons: first class seats?
13:06:17 <dons> nope
13:06:23 <SamB> so. can nofib do profiling?
13:06:26 <xerox> Funny.
13:06:52 <xerox> I was thinking about going to London on the 27 to visit their office there.
13:07:32 <xerox> They're organizing it for SoC-ers this time.
13:07:43 * SamB wants nofib to do profiling
13:07:50 * integral has been in two minds about going to that
13:08:03 <xerox> I'm not sure in fact.
13:08:18 <cybercobra> anyone know how I'd make this work, i'm new to haskell: http://paste.lisp.org/display/27966
13:08:28 <xerox> integral: where are you from?
13:08:43 <integral> xerox: I'm in Cambridge, so it's easy enough to get to
13:08:58 <arjanb> SamB: file a feature request for reducing the context with darcs send, i think darcs doesn't need it all
13:09:00 <xerox> !!!
13:09:09 <xerox> integral: you did show up at AngloHaskell?
13:09:28 <integral> xerox: No, I'm just a student so I was at home in edinburgh at the time :-(
13:09:30 <SamB> arjanb: isn't the patch description part of what darcs uses to come up with the hash?
13:09:50 <SamB>        fibheaps               23127k           12.3%
13:09:50 <SamB>            fish               10049k           32.5%
13:10:06 <SamB> and yet neither of them has a single < or > in the interface file...
13:10:06 <xerox> integral: aww.  I'm a student too, that's not fair ;)
13:10:49 <cybercobra> xerox: curse the ticket cost and scheduling of expos! ;-)
13:10:58 <arjanb> SamB: yes but patches it doesn't depend upon don't need to be in context
13:11:10 <xerox> Hmm.
13:11:36 <SamB> arjanb: you mean darcs could move it around to depend on only the latest known tag?
13:11:57 <SamB> or whatever you call the best tag for that?
13:12:08 <xerox> integral: I'd have to fly again, and I'd better book the plane tickets sooner this time, if you'll get there we could meet, a reason more to go, for example.
13:13:10 <SamB>          primes               32204k           28.1%
13:13:11 <SamB> too
13:13:20 <integral> hmm, yes, that would be an idea :-)
13:13:23 <arjanb> SamB: yes the tag plus the minimal set of patches it depends upon
13:13:45 <cybercobra> I need some help using 'data' + 'type' - http://paste.lisp.org/display/27966
13:14:21 <SamB> yep, I really really want nofib to do profiling...
13:14:32 <SamB> and nofib-analyse to compare the results...
13:15:49 <xerox> What is this nofib thing?
13:15:59 <SamB> benchmark suite?
13:17:36 <SamB> specifically I want its Makefile to do that for me ;-)
13:19:44 <Igloo> SamB: Just because the interface file didn't change doesn't mean different inlining decisions weren't made, does it?
13:19:57 <Igloo> SamB: Are those faster or slower, BTW?
13:21:46 <SamB> those are for allocation
13:22:28 * SamB suspects something in the library
13:22:37 <SamB> and I'm thinking that more allocation is worse
13:27:41 <roconnor> this balance language reminds me of a language for a quantum computer
13:27:47 <roconnor> only misimplemented
13:28:15 <lisppaste2> SamB pasted "nofib results" at http://paste.lisp.org/display/27967
13:29:07 <SamB> roconnor: it would be usable if the register shuffling was seperated from the constant loading...
13:29:41 <SamB> and much more usable if it came with an assembler
13:29:51 <roconnor> SamB, yay -0.4%
13:30:31 <lisppaste2> SamB annotated #27967 with "binary sizes" at http://paste.lisp.org/display/27967#1
13:31:19 <lisppaste2> SamB annotated #27967 with "allocations" at http://paste.lisp.org/display/27967#2
13:31:54 <lisppaste2> SamB annotated #27967 with "run time" at http://paste.lisp.org/display/27967#3
13:32:38 * SamB skips the mutator/GC stats...
13:32:50 <cybercobra> I need some help using 'data' + 'type' - http://paste.lisp.org/display/27966
13:33:07 <SamB> and all the stuff about reads/writes/cache hits/misses
13:33:36 * lispy reads some of his old code and finds he had a clever use of the Writer monad at some point and didn't even realize it
13:33:57 <lispy> it's like, "Wow, *I* wrote this?"
13:33:58 <SamB> because I didn't actually get anything for that
13:34:15 <SamB> and also the module sizes and compile times...
13:34:18 <SamB> because, well...
13:34:30 <SamB> It doesn't seem that important...
13:35:09 <SamB> so is it not so bad to accidentally increase allocation?
13:36:10 <Igloo> It is bad - I'd be curious to know what happened
13:36:26 <SamB> uh huh
13:36:30 <SamB> so how do I do the profiling?
13:37:33 <roconnor> cybercobra: you need to give constructor names for your three constructors
13:37:37 <Igloo> Looking at the -ddump-simpl differences might be the easiest way
13:38:01 <Igloo> Do you know if nofib counts allocation in the standard libraries?
13:38:15 <cybercobra> roconnor: and how should I deal w/ Slice ?
13:38:15 <SamB> am thinking it would be helping to know what module the allocation is happening in?
13:38:19 <SamB> of course it does!
13:38:30 <SamB> how could it not?
13:38:42 <roconnor> cybercobra: make it a separate data type?
13:38:47 <SamB> and, more to the point, being a benchmarking suite, why wouldn't it?
13:38:52 <cybercobra> roconnor: all right. thanks
13:38:53 * Igloo has no idea what it does
13:39:16 <SamB> I think it just gets GHC to dump timing info on stdout and parses that
13:39:24 <SamB> I have to walk the dog, actually...
13:39:48 <SamB> actually the tool that parses the results is in the GHC tree
13:39:52 <SamB> nofib-analyse by name
13:40:06 <SamB> and it doesn't work as present in the ropository
13:40:49 <SamB> dons said he would push my patches through this evening (in the US)
13:40:55 <SamB> (he is in the US, after all)
13:45:37 <lispy> how did nofibs get its name?
13:45:54 <lispy> no fibs == no lies?
13:46:16 <lispy> or fibs as in 1,1,2,3,5,...
13:46:23 <roconnor> both
13:46:38 <roconnor> typically people would use fib as their test case.
13:46:51 <roconnor> but it isn't a ``reall world
13:46:54 <roconnor>  example
13:47:00 <lispy> ah, okay
13:52:46 <monochrom> Ha
13:58:38 <ikegami--> hello
13:59:02 <ikegami--> i'm looking for the current release of GHC (6.6) for MacOSX (PowerPC)
13:59:32 <scsibug> I just built a copy for myself, but I'm not sure the best way to package a binary distribution for others would be
13:59:35 <ikegami--> because I failed to compile it from the source codes (not darcs repo but tarball)
14:00:02 <scsibug> ikegami, i can give you info on how to compile it successfully, if you'd like
14:00:19 <ikegami--> yes, please
14:00:27 <ikegami--> if it is not so complicated
14:00:37 <scsibug> you have GHC already installed (6.4.1 or similar?)
14:00:42 <ikegami--> yes
14:01:05 <scsibug> you have readline installed (5.0+)?
14:01:22 <ikegami--> ah maybe (if not, then install before compile GHC 6.6
14:01:34 <scsibug> it's not required, but ghci will work better
14:01:40 <scsibug> it won't cause the build to fail
14:01:49 <ikegami--> ok, thanks
14:02:21 <scsibug> this bug report describes how to make the GHC build see your new readline: http://hackage.haskell.org/trac/ghc/ticket/766
14:02:24 <lambdabot> Title: #766 (GHC 6.4.2 won't build on Mac OS X) - GHC - Trac, http://tinyurl.com/yaql8u
14:02:59 <scsibug> and actually, I believe ./configure;make worked out of the box for me...
14:03:11 <scsibug> make sure you have plenty of disk free, the build is about 1GB all said and done with
14:03:23 <SamB> there really isn't much to optimise in the typical fib, is there?
14:04:20 <ikegami--> scsibug: then I'll try it again, thanks
14:04:40 <int-e> SamB: no, you just tune your compiler to produce a tight loop :_
14:04:42 <scsibug> ikegami: yep, I just set LDFLAGS and CPPFLAGS as described in that link after installing readline, and then configured and ran make
14:05:18 <SamB> int-e: well, how about this "nfib"
14:05:36 <SamB> its recursion structure is a binary tree
14:06:43 <scsibug> on a related topic, is there an official way to take a finished GHC build and package it for binary distribution?
14:14:23 <user317> how do i round a float to a specific position?
14:14:24 <Igloo> scsibug: There's make binary-dist, but most platforms have a custom packaging format that is smoother
14:15:23 <scsibug> Igloo: thank you.  I'm pretty familiar with the OS X dev tools for making installers, so maybe i'll put something together if I get time in the next week
14:16:19 <ikegami--> excellent
14:16:41 <SamB> @type round
14:16:42 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:16:55 <user317> round just rounds to nearest integer
14:17:01 <SamB> > round 0.1 2
14:17:02 <lambdabot>  add an instance declaration for (Integral (t -> a))
14:17:02 <lambdabot>   In the definition o...
14:17:04 <user317> i want to round to the 3rd decimal
14:17:05 <SamB> hmm.
14:17:07 <moconnor> Is the intention of the following code simply to ensure that Monad a is evaluated before Monad b? before :: Monad m => m a -> m b -> m a; before a b = a >>= \x -> b >> return x
14:17:11 <SamB> > round 2 0.1111
14:17:12 <lambdabot>  add an instance declaration for (Integral (t -> a))
14:17:12 <lambdabot>   In the definition o...
14:17:19 <SamB> oh right.
14:17:22 * SamB is silly
14:17:37 <SamB> @hoogle a -> Integer -> Integer
14:17:38 <lambdabot> No matches, try a more general search
14:31:28 <user317> how do i make this less ugly: oundTo xx yy = (fromIntegral (round (xx * (10.0 ** (fromIntegral yy))))) / (10.0 ** (fromIntegral yy))
14:31:39 <user317> s/outTo/roundTo
14:33:40 <Cale> roundTo x y = fromIntegral $ round (x' * 10**y') / (10**y') where x' = fromIntegral x; y' = fromIntegral y
14:34:39 <Cale> you could also factor the computation of 10**y'
14:35:05 <Cale> roundTo x y = fromIntegral $ round (x' * s) / s
14:35:16 <Cale>    where x' = fromIntegral x
14:35:23 <Cale>          y' = fromIntegral y
14:35:36 <Cale>          s = 10 ** y'
14:36:13 <user317> thanks Cale, someone should add this to prelude
14:36:49 <Cale> Maybe Numeric
14:37:24 <Igloo> Can't you use 10^y?
14:37:36 <Cale> actually, yes, you could
14:37:59 <Cale> roundTo x y = fromIntegral $ round (x' * s) / s
14:38:01 <Cale>    where x' = fromIntegral x
14:38:07 <Cale>          s = 10^y
14:38:17 <Cale> or perhaps 10^^y would be better
14:39:08 <Igloo> Also, surely x isn't meant to be Integral?
14:40:01 <xerox> Have fun ~~
15:01:53 <scsibug> ikegami--: I just finished making a ghc-6.6 ppc/osx binary distribution, with readline included.  Tested on a separate machine, and it seems to work.  It's at http://scsibug.com/ghc-6.6-ppc-apple-darwin.tar.gz
15:01:56 <lambdabot> http://tinyurl.com/yhn92c
15:03:04 <scsibug> also uses audrey's post-install script for installing readline, so it should be literally all you need
15:09:32 <scsibug> should I contact someone about adding my binary dist to the main ghc download page?
15:11:53 <hyraxfourtwo> 6.6 is released?
15:12:06 <scsibug> indeed
15:12:12 <hyraxfourtwo> today or?
15:12:17 <scsibug> a few days ago
15:12:19 <hyraxfourtwo> oh really
15:12:24 <hyraxfourtwo> hmm
15:12:25 <scsibug> Oct. 11
15:12:27 * hyraxfourtwo will investigate
15:14:28 <fpierre08> evening ppl =o)
15:17:49 <gmh33> boo there's no universal or ppc binary of ghc :/
15:18:11 <scsibug> I just posted one, actually
15:18:36 <scsibug> http://scsibug.com/ghc-6.6-ppc-apple-darwin.tar.gz
15:18:39 <lambdabot> http://tinyurl.com/yhn92c
15:19:04 <gmh33> ooo
15:19:30 <Igloo> scsibug: Have you got an e-mail address I can list as having created it on the download page?
15:19:49 <Igloo> scsibug: And is there any other blurb that should go on http://www.haskell.org/ghc/download_ghc_66.html ?
15:19:51 <lambdabot> Title: GHC: Download version 6.6, http://tinyurl.com/ybqjsb
15:21:04 <scsibug> Igloo:  Sure, scsibug@imap.cc, please list my name as Greg Heartsfield, and note that it includes Audrey's post-install script for readline (not GMP though)
15:21:08 <scsibug> thanks
15:21:34 <hyraxfourtwo> fpierre08, how are the cards?
15:21:39 <Igloo> scsibug: OK. And thanks for making it!
15:22:48 <fpierre08> hyrax : was at work so about to get back on it now ! =o)
15:22:57 <fpierre08> tnx for asking =o)
15:24:01 <dons> Igloo: sent you some notes on one of the talks I just attended
15:24:21 <dons> Igloo: goes to some stuff we were talking about earlier, about tracking patches and so on
15:24:31 <dons> ?localtime Igloo
15:24:32 <lambdabot> Local time for Igloo is Sat Oct 14 23:24:09 2006
15:24:40 <Igloo> OK, cool, ta
15:24:57 <hyraxfourtwo> fpierre08, enjoy :p
15:25:27 <fpierre08> lol
15:25:29 <fpierre08> tnx
15:26:06 <dons> Igloo: from talking to people I think haskell is one of the more "functional" ;) working communities. there are some dysfunctional ones out there. there's also ones that do things better than us as well
15:27:12 <pejo> dons, which ones do better?
15:27:17 <pejo> (And is there something to learn from them?)
15:27:29 <dons> the subversion guys seem to have a good ethos.
15:27:31 <thetallguy> dons: a large part of our decision to switch from ocaml to haskell was community support
15:27:40 <dons> yeah, i was thinking that.
15:28:00 * Igloo wonders if Ben Collins-Sussman is the Debian Ben collins
15:28:03 <dons> for exapmle, the ocaml irc channel is an example of how a project/community can be poisoned by the wrong people, driving devs away
15:28:11 <Igloo> dons: Are you or shapr talkign about anything, OOI?
15:28:29 <chessguy> hey dons, how was the googleplex?
15:28:34 <dons> its been more free form than I was expecting. I've cochaired a couple of sessions
15:28:58 <gmh33> wow the ./configure takes a while lol
15:29:25 <dons> Igloo: oh, btw, shapr isn't he. he wasn't able to get the flight
15:29:29 <dons> s/here/
15:29:44 <Igloo> Oh, pity
15:29:45 <dons> chessguy: its nice!
15:30:22 <dons> Igloo: i made some comments earlier on what the google guys were saying about haskell too, check the logs
15:30:57 <mauke> why does 'runhaskell Setup.hs build' say "Failed to load interface for `Prelude': Could not find module `Prelude': it is not a module in the current program, or in any known package."?
15:31:10 <mauke> this is my first attempt at using cabal
15:31:54 <SamB> mauke: it means something is seriously wrong with runhaskell (or the haskell implementation it is using)
15:32:15 <mauke> ghc -c works fine
15:32:31 <scsibug> Igloo: looks like you better hold off on posting that ghc build, I'm getting link errors that shouldn't be happening
15:32:50 <Igloo> dons: OK, will do
15:32:53 <Igloo> scsibug: OK
15:33:36 <mauke> runhaskell complains about missing Main, which makes sense
15:37:08 <dons> Igloo: another thing that comes up, people need guides for starting new (haskell) projects, and starting hacking. we have the latter for ghc, but I think I should write a guide on starting a haskell project in general
15:38:25 <Igloo> dons: Do the cabal docs cover that, or do you mean something else?
15:39:25 <dons> Igloo: I'm thinking of a general doc, describing when to use cabal, when to use darcs, when to use QuickCheck, how to use haddock.
15:39:38 <dons> the stuff we know , from years of experience, should be written down
15:39:45 <Igloo> Ah, right
15:40:14 <dons> i even imagine a shell script that runs darcs init; creates a Setup.hs, and fills out a .cabal file ;)
15:40:36 <Igloo> Hmm, that's interesting (the doc thing)
15:41:07 * Igloo will have to think about that
15:41:07 <dons> since we want more libraries and tools to follow the best practice
15:41:19 <dons> i'll try to sketch it out in the next few days
15:44:46 * glguy wants to install OpenBSD on his NintendoDS...
15:46:02 <Igloo> dons: Do you know what they mean by "don't allow names in packages" regarding subversion?
15:46:12 <Igloo> What they mean by "packages", that is
15:46:19 <dons> they were using it to "not name files"
15:46:28 <Igloo> Ah, you've translated to Haskell?
15:46:31 <dons> but I translated that to our "not name packages" situtation
15:46:32 <dons> yep
15:46:36 <dons> only in some cases
15:46:37 <Igloo> OK  :-)
15:49:36 <yip> any good haskell "podcasts"?
15:50:14 <glguy> anyone know if ghc6.6 is in ubuntu's 6.10 repositories yet?
15:51:27 <mathewm> did the hackathon video ever make it online?
15:51:53 <Pegazus> has haskell any dynamic binding thing?
15:52:04 <dons> the icfp contest results are on google video
15:52:05 <Igloo> http://hackage.haskell.org/trac/ghc/wiki/AboutVideos
15:52:08 <lambdabot> Title: AboutVideos - GHC - Trac, http://tinyurl.com/w2uvy
15:52:42 <mathewm> awesome
15:52:54 <Igloo> Does google video promise to keep things forever?
15:53:03 <glguy> lol
15:54:17 <SamB> Igloo: probably! if you don't violate some rules, and if your video isn't horrible!
15:54:26 <SamB> well. probably not.
15:54:32 <SamB> but they probably *will*
15:54:46 <SamB> it wouldn't be their style to delete stuff for no reason
15:55:05 <Eidolos> Will they keep it until the heat death of the universe?
15:55:12 <Eidolos> (and beyond?)
15:55:44 <SamB> how about "the extinction of mankind"?
15:55:54 <SamB> we haven't any idea what will happen after that anyway
15:56:17 <Eidolos> That's a finer issue.. will the extinction of mankind necessarily mean the destruction of all hard drives?
15:57:51 <dbremner> Eidolos - reminds me of this. http://www.ocrwm.doe.gov/factsheets/doeymp0115.shtml
15:57:54 <lambdabot> Title: The Monumental Task of Warning Future Generations, http://tinyurl.com/yn2dyo
15:58:40 <SamB> no, but who can say what the robots that will no doubt take over Google will do with them?
16:05:10 <mauke> @source typeOf
16:05:11 <lambdabot> typeOf not available
16:07:20 <mauke> how is typeOf supposed to work?
16:08:05 <ski> @type typeOf
16:08:07 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:08:21 <ski> > typeOf 'x'
16:08:23 <lambdabot>  Char
16:08:45 <ski> > typeOf (undefined :: Char)
16:08:47 <lambdabot>  Char
16:08:50 <qwr> > typeOf Char
16:08:51 <lambdabot>  Not in scope: data constructor `Char'
16:08:55 <mauke> great, what's a TypeRep?
16:09:10 <ski> a representation of a (monomorphic) type, at run-time
16:09:26 <roconnor> w00t, I solved the swapreg problem
16:09:31 <roconnor> now I can get root access
16:09:51 <fasta> roconnor: are you talking about your UM?
16:09:53 <mauke> how do I construct a TypeRep?
16:10:02 <SamB> > typeOf "Hello!"
16:10:03 <lambdabot>  [Char]
16:10:07 <SamB> see!
16:10:12 <SamB> that is how! it is easy!
16:10:13 <roconnor> fasta: specifically the balance problem
16:10:22 <SamB> (import Data.Typeable first though)
16:10:26 <roconnor> techinically I'm useing someone else's UM now.
16:10:28 <SamB> @type typeOf "Hello!"
16:10:29 <mauke> SamB: uh, I'm trying to make an instance of Typeable
16:10:29 <lambdabot> TypeRep
16:10:49 <SamB> mauke: oh
16:10:56 <SamB> GHC or others too?
16:11:12 <mauke> wait, it's compiler dependent?
16:11:23 <fasta> roconnor: I didn't implement an UM nor did I play the games, but I did read the introduction story. It sounds like they put in a lot of effort organizing it.
16:11:23 <SamB> well, its easier if you only want to do it with GHC ;-)
16:11:26 <ski> > mkFunTy (typeOf 'a') (typeOf False)
16:11:28 <lambdabot>  Char -> Bool
16:11:29 <roconnor> Balance is an even worse langauge than ocult
16:11:38 <SamB> "deriving Typeable" for GHC only, otherwise you have to write the instance...
16:11:42 <roconnor> fasta: it's enjoyable
16:11:50 <mauke> how do I write the instance?
16:12:44 <SamB> hmm
16:12:59 <Magicman> @where wxHaskell
16:12:59 <lambdabot> http://wxhaskell.sourceforge.net/
16:14:06 <SamB> mkTyCon :: String -> Data.Typeable.TyCon
16:14:06 <SamB> mkTyConApp :: Data.Typeable.TyCon
16:14:06 <SamB>               -> [Data.Typeable.TypeRep]
16:14:06 <SamB>               -> Data.Typeable.TypeRep
16:14:18 <SamB> ?
16:14:28 <mauke> what do those functions do?
16:14:51 <SamB> well...
16:15:10 <ski> > mkTyConApp (mkTyCon "[]") [mkTyConApp (mkTyCon "Bool") []]
16:15:10 <SamB> > mkTyCon "Foo.Bar"
16:15:10 <Magicman> wxHaskell site's dead... :(
16:15:11 <lambdabot>  [Bool]
16:15:12 <lambdabot>  Foo.Bar
16:15:49 <SamB> ... how... hackish...
16:15:51 <ski> > mkTyConApp (mkTyCon "(,,)") [mkTyConApp (mkTyCon "Bool") [],mkTyConApp (mkTyCon "[]") [mkTyConApp (mkTyCon "Char") []],mkTyConApp (mkTyCon "Int") []]
16:15:53 <lambdabot>  (,,) Bool [Char] Int
16:15:56 <ski> hm
16:16:12 <SamB> > typeOf (True, "Hi!", 1::Int)
16:16:13 <lambdabot>  (Bool,[Char],Int)
16:16:33 <SamB> > mkTyConApp (mkTyCon "(Data.Tuple.,,)") [mkTyConApp (mkTyCon "Bool") [],mkTyConApp (mkTyCon "[]") [mkTyConApp (mkTyCon "Char") []],mkTyConApp (mkTyCon "Int") []]
16:16:33 <SamB> <lambdabot>  (,,) Bool [Char] Int
16:16:34 <lambdabot>  (Data.Tuple.,,) Bool [Char] Int
16:16:54 <SamB> > mkTyConApp (mkTyCon "Data.Tuple.,,") [mkTyConApp (mkTyCon "Bool") [],mkTyConApp (mkTyCon "[]") [mkTyConApp (mkTyCon "Char") []],mkTyConApp (mkTyCon "Int") []]
16:16:56 <lambdabot>  Data.Tuple.,, Bool [Char] Int
16:17:01 <SamB> > mkTyConApp (mkTyCon ",,") [mkTyConApp (mkTyCon "Bool") [],mkTyConApp (mkTyCon "[]") [mkTyConApp (mkTyCon "Char") []],mkTyConApp (mkTyCon "Int") []]
16:17:02 <lambdabot>  (Bool,[Char],Int)
16:17:05 <SamB> ah
16:17:12 <ski> m
16:17:23 <SamB> anyway, you aren't supposed to do that ;-)
16:17:33 <SamB> you are supposed to only do that with your *own* type names...
16:17:43 <SamB> and you are supposed to use the fully qualified name
16:18:00 <mauke> do what?
16:18:17 <ski> construct 'TyCon's out of strings, presumably
16:18:43 <mauke> what are TyCons and why do I need them?
16:19:01 <ski> they are type constructors
16:19:06 <SamB> instance Typeable Foo where typeOf _ = mkTyConApp (mkTyCon "This.Module.Foo") []
16:19:20 <ski> like 'Bool','Maybe','IO','[]'
16:20:13 <ski> instance Typable a => Typable (Bar a)
16:20:15 <ski>   where
16:20:56 <ski>   typeOf bar_a = mkTyConApp (mkTyCon "This.Module.Bar") [t_a]
16:20:58 <ski>     where
16:21:13 <ski>     t_a = get bar_a
16:21:20 <ski>     get :: Bar a -> a
16:21:20 <SamB> ??
16:21:28 <ski>     get = undefined
16:21:35 <SamB> um
16:21:40 <SamB> you are missing a typeOf
16:21:47 <ski> m, right
16:22:02 <ski>     t_a = typeOf (get bar_a)
16:22:12 <roconnor> ah, so that's how it ends
16:22:21 <ski> (hm, better to fold 't_a' completely, actually)
16:22:28 <SamB> roconnor: sandworm?
16:22:36 <roconnor> worse
16:22:40 <SamB> eek
16:23:01 <SamB> I should finish that game sometime now that Lemmih is lating me play on his computer ;-)
16:23:04 <mauke> I wonder why this isn't documented
16:23:16 <SamB> mauke: isn't it?
16:23:16 <roconnor> SamB how many points do you have?
16:23:22 <mauke> not really
16:23:25 <SamB> roconnor: I don't remember!
16:23:32 <SamB> perhaps over 2000?
16:23:35 <roconnor> ok
16:23:52 <mauke> mkTyCon - Builds a TyCon object representing a type constructor.
16:23:54 <SamB> because I think I had two silly -root accounts
16:23:59 <mauke> mkTyConApp - Applies a type constructor to a sequence of types
16:24:10 <SamB> mauke: I meant outside the haddock...
16:24:16 <roconnor> that would place you between 2006 and 3006
16:24:31 <mauke> SamB: are there any other docs?
16:24:48 <roconnor> I wonder if I ought to solve the other balance problems.
16:25:02 <SamB> http://www.cs.vu.nl/boilerplate/
16:25:04 <lambdabot> Title: Scrap your boilerplate ... in Haskell
16:25:14 <SamB> which can be found by going to
16:25:18 <SamB> @docs Data.Typeable
16:25:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
16:25:27 <SamB> and clicking the link to Data.Generic
16:25:35 <SamB> and clicking the link to there
16:25:52 <SamB> though perhaps it should be more directly referenced from Data.Typeable
16:26:55 <SamB> at least... I thought I read about this *somewhere*
16:27:02 <SamB> and that sounded like a plausible place...
16:27:11 <mauke> where exactly does it say what those functions do? somewhere in the papers?
16:27:46 * SamB isn't so sure anymore
16:27:58 <SamB> someone should find what I mean and link it from Data.Typeable...
16:28:15 <SamB> or write what I thought I'd read
16:28:32 <mauke> next problem: IO exceptions aren't extensible
16:29:05 <SamB> you mean IOExceptions
16:29:17 <SamB> see Control.Exception
16:29:37 <SamB> or are they IOErrors?
16:29:39 * SamB forgot
16:29:55 <SamB> the normal kind *is*
16:30:15 <SamB> throw any Typeable type
16:30:27 <mauke> type IOError = IOException
16:30:29 <SamB> er, you can.
16:30:33 <SamB> don't use those ones
16:30:37 <SamB> don't import that module
16:30:42 <SamB> @docs Control.Exception
16:30:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
16:31:15 <mauke> argh, now I have to implement Typeable
16:31:54 <SamB> yes
16:31:58 <SamB> I said that already ;-)
16:32:27 <mauke> why does haskell suck so much if you want to do real work in it :(
16:32:42 <SamB> you are free to add "deriving Typeable" to hugs...
16:33:03 <SamB> as the Scrap Your Boilerplate paper says, they just weren't ready to do so...
16:33:10 <SamB> too much work
16:33:22 <SamB> also DrIFT might know how
16:35:02 <ihope> In practice, is "product [2..x]" a decently fast factorial?
16:35:42 <scsibug> I've certainly used it as one
16:37:57 <Philippa> mauke: it depends on the "real work". Binary IO's always been a sticking point for me
16:39:27 <mauke> the original "real work" was a simple server; now I'm trying to reimplement OCaml's Unix module
16:45:43 <ajay> How do I negate a Boolean under ghc?
16:46:15 <mauke> > not True
16:46:16 <lambdabot>  False
16:46:46 <ajay> ahh, thanks
16:47:16 <mauke> > reverse [minBound .. maxBound] !! fromEnum True :: Bool
16:47:18 <lambdabot>  False
16:49:47 <dylan> > minBound :: Bool
16:49:48 <lambdabot>  False
16:49:55 <dylan> > maxBound :: Bool
16:49:57 <lambdabot>  True
16:50:00 <dylan> Nifty
16:50:16 <ski> > minBound :: ()
16:50:17 <lambdabot>  ()
16:50:29 <Patterner> > not Maybe
16:50:29 <lambdabot>  Not in scope: data constructor `Maybe'
16:50:33 <dolio> > [()..]
16:50:35 <lambdabot>  [()]
16:50:52 <ski> > [False..]
16:51:02 <lambdabot>  Parse error
16:51:06 <ski> > [False ..]
16:51:06 <lambdabot>  [False,True]
16:51:10 <lispy> > [True ..]
16:51:11 <lambdabot>  [True]
16:51:39 <ski> > [True,False ..]
16:51:41 <lambdabot>  [True,False]
16:51:49 <lispy> >[True, True .. ]
16:51:53 <lispy> > [True, True .. ]
16:51:55 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
16:52:01 <ski> > [(),() ..]
16:52:03 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
16:52:31 <lispy> > [1,1,2,3,5,8 .. ]
16:52:32 <lambdabot>  Parse error
16:56:40 <mauke> there's a set of C macros I want to translate to an enum type in Haskell
16:57:02 <mauke> what's the best way to turn the constructors back into numbers for use in C land?
16:57:21 <ihope> mauke: CInt and such?
16:57:22 <lispy> mauke: hsc2hs is pretty common, there are more automated ways thouh
16:57:33 <ihope> hsc2hs?
16:57:38 <ihope> Isn't that redundant?
16:57:55 <lispy> how so?
16:57:57 <int-e> no, they're two file extensions
16:58:00 <ihope> Oh.
16:58:20 <ihope> So it's "hsc"2hs, not hs"c2hs".
16:58:26 <lispy> ah
16:58:30 <lispy> right
16:59:55 <lispy> SamB: re: your darcs bug, i think the context is actually minimal already...at least i thought that was the point
17:01:17 <SamB> than why are my tiny patches to GHC bloated to 220k?
17:01:20 <mauke> lispy: how would I use hsc2hs for that?
17:01:41 <kpreid> mauke: fromEnum?
17:01:44 <kpreid> @type fromEnum
17:01:45 <lambdabot> forall a. (Enum a) => a -> Int
17:01:53 <arjanb> lispy: i looked at the source and it's the common context not the minimal now
17:01:57 <mauke> kpreid: that requires an enum
17:02:09 <lispy> mauke: hsc2hs turns a .hsc file and a .h (or is it .c) file into into a .hs file...so maybe i misunderstood.  Are the enums already given in C?
17:02:10 <SamB> lispy: if I can unpull a patch without unpulling any of the ones I'm sending, it shouldn't be in the context
17:02:17 <mauke> lispy: yes
17:02:30 <mauke> kpreid: my type isn't really an Enum :/
17:02:30 <kpreid> mauke: oh, I thought you had a haskell definition already
17:02:38 <ihope> So what's the fastest factorial out there?
17:02:41 <int-e> hmm, the context is a complete set of patches, more or less since the last checkpoint?
17:02:54 <SamB> int-e: just the names of them
17:02:57 <kpreid> > toConstr (Right "a")
17:02:57 <SamB> and such
17:02:57 <lambdabot>  Add a type signature
17:03:04 <SamB> not the patches themselves
17:03:05 <lispy> mauke: okay, well i don't know all the details, i used it once in anexisting project and it was pretty easy i recall
17:03:06 <int-e> SamB: yes, that's bad enough though
17:03:06 <mauke> kpreid: I do, but the numbers would be wrong
17:03:10 <kpreid> > toConstr (Right "a" :: Either Int String)
17:03:11 <lambdabot>  Right
17:03:12 <SamB> int-e: I know that ;-)
17:03:17 <kpreid> mauke: er
17:03:20 <SamB> hence, the issue ;-)
17:03:23 <lispy> mauke: are you on windows?
17:03:26 <mauke> lispy: no
17:03:27 <kpreid> mauke: then what *do* you want haskell to do for you?
17:03:32 <int-e> well, that's darc's model ...
17:03:47 <lispy> mauke: hmm...i don't know a good example then.  I recall using the System.Win32 sources as an example
17:03:57 <int-e> darcs'. I'll admit I'm more of a git user myself.
17:04:00 <SamB> int-e: I actually think this should be a --option
17:04:09 <ihope> @type toConstr
17:04:11 <lambdabot> Not in scope: `toConstr'
17:04:17 <ihope> @hoogle toConstr
17:04:18 <lambdabot> Data.Generics.Basics.toConstr :: Data a => a -> Constr
17:04:18 <SamB> like... --minimal-context
17:04:22 <ihope> Hmm.
17:04:28 <ihope> > toConstr (Just "3")
17:04:30 <lambdabot>  Just
17:04:38 <int-e> SamB: a possible alternative would be to create more checkpoints. *shrugs*
17:05:00 <arjanb> i think minimal context should be default
17:05:12 <mauke> kpreid: nothing, I just wanted to know what the best way of translating between C and Haskell types is
17:05:16 <mauke> in this case, I mean
17:05:23 <kpreid> uh, okay
17:05:32 <SamB> int-e: have you seen the contexts on cvs-ghc@haskell.org?
17:05:56 <int-e> I'm not subscribed there, so no, I haven't.
17:06:08 <lispy> ihope: i think fact n = product [1..n] was a very fast factorial
17:06:33 <ihope> How fast is product, though?
17:06:42 <lispy> SamB: the idea to strip out the patch contents seems like a good idea
17:06:47 <kpreid> > (\c -> elemIndex c (constrType c)) $ toConstr (Right "a" :: Either Int String)
17:06:47 <lambdabot>  Couldn't match `[a]' against `DataType'
17:07:08 <lispy> ihope: well in ghc i bet you'd get fusion and all those goodies with that version
17:07:15 <SamB> lispy: um.
17:07:21 <kpreid> > (\c -> elemIndex c (dataTypeConstrs $ constrType c)) $ toConstr (Right "a" :: Either Int String)
17:07:23 <SamB> the patch contents are already stripped out...
17:07:23 <lambdabot>  Just 1
17:07:40 <lispy> SamB: i thought you said the context contains the patches
17:07:50 <kpreid> > (fromJust . (\c -> elemIndex c (dataTypeConstrs $ constrType c)) . toConstr) (Right "a" :: Either Int String)
17:07:51 <lambdabot>  1
17:07:59 * lispy hasn't paid attention to the contexts before
17:08:07 * SamB renames the issue
17:08:07 <kpreid> there we go. if you *did* want fromEnum on non-Enum, that does it
17:08:48 <mauke> I want to use errno constants in haskell
17:08:48 <SamB> ihope: I heard there are better orders to do the multiplication in...
17:08:49 <lispy> ihope: are you just curious or do you need a really fast factorial?
17:08:56 <mauke> and I need a strerror()
17:08:57 <ihope> Just curious.
17:09:10 <SamB> mauke: okay, for that, look at IOError
17:09:17 <SamB> I think it has that functionality?
17:09:41 <lispy> SamB: can you paste the context (or just part of it) to a pastebin so we can see it first hand?
17:09:55 <mauke> SamB: I doubt that
17:10:13 <mauke> @hoogle a -> IOErrorType
17:10:14 <lambdabot> No matches, try a more general search
17:11:50 <SamB> lispy: I can't paste it all at once, no ;-)
17:11:54 <lispy> SamB: what about gziping your patches?  would the mail list block binary attachements?
17:12:02 <lispy> SamB: just a part, i want to see the contexts
17:12:13 <lispy> SamB: like one or two contexts pieces
17:12:19 <lispy> 20k maybe?
17:12:37 <lispy> i bet it would compress very well
17:14:11 <ihope> @hoogle foldl1'
17:14:11 <lambdabot> Data.List.foldl1' :: (a -> a -> a) -> [a] -> a
17:14:49 <SamB> hmm...
17:14:57 <SamB> it isn't stopping at the last tag?
17:16:02 <lisppaste2> SamB pasted "context until first tag..." at http://paste.lisp.org/display/27974
17:16:53 <lispy> well, arjanb did say it was the common context
17:17:16 <SamB> well
17:17:30 <lispy> hmm..so i wonder why the context has those hunks
17:17:39 <SamB> which hunks?
17:17:53 <lispy> oh, n/m
17:18:00 <lispy> you pasted your patches in there too
17:18:06 <SamB> oh, yeah, hehe
17:18:15 <lispy> but, certainly we don't need the long comment
17:18:30 <lispy> [Module header tidyup #2
17:18:34 <lispy> Simon Marlow <simonmar@microsoft.com>**20061011143523]
17:18:34 <SamB> are you sure?
17:18:40 <lispy> that would be just enough i believe
17:18:58 <SamB> ... it doesn't need to be checksummed?
17:18:59 <arjanb> the long comment is part of the patch hash
17:19:02 <lispy> i really doubt darcs pays attention to anything after the name (but i haven't checked the code)
17:19:07 <lispy> arjanb: oh, really?
17:19:12 <SamB> arjanb: I thought so!
17:19:30 <SamB> I think darcs regards all of that as the name?
17:19:47 <lispy> maybe
17:20:15 <lispy> if that's the case then i don't really think this is fixable without breaking something
17:20:21 <SamB> Manuel M T Chakravarty seems to go overboard...
17:20:46 <SamB> lispy: I just think it would be nice to stop at, say, the first tag, at this point
17:20:51 <dcoutts> Igloo, want to send in a patch to fix setup register ?
17:21:14 <arjanb> lispy: i think the context could just be a list of hashes
17:21:27 <lispy> arjanb: that would be nice
17:21:34 <Igloo> dcoutts: It's sufficiently far down my TODO list that I expect someone else will beat me to it
17:21:34 <SamB> arjanb: that wouldn't be backwards compatible
17:21:43 <dcoutts> Igloo, ok.
17:21:43 <lispy> arjanb: not human readable, but nice in this case
17:22:01 <Igloo> Hence I just reported it
17:22:06 <SamB> it should at least have the patch *names* and the whole patch number thingy
17:22:19 <SamB> I think.
17:22:34 <SamB> but it needn't go back forever or even until the last checkpoint, need it?
17:23:16 <arjanb> right
17:23:46 <SamB> I mean, maybe its an okay default... but it should be an *option*
17:25:20 <arjanb> imho effecient use of darcs shouldn't depend much on tagging and checkpointing
17:25:39 <SamB> eh.
17:25:42 <SamB> it does.
17:25:56 <SamB> there isn't any way to help it.
17:26:11 <Igloo> darcs does try to take the most recent common tag, IIRC, but it doesn't guarantee to (and it may nto be unique in general)
17:26:18 <Igloo> Patches would be welcomed, I'm sure  :-)
17:26:32 <SamB> it has to pull down at *least* the top inventory...
17:26:48 <SamB> Igloo: I don't care if it is unique!
17:26:57 <SamB> just so long as it is fairly recent
17:27:29 <SamB> anyway.
17:27:44 <SamB> It wasn't *my* idea for me to submit a darcs issue...
17:29:34 <SamB> the fact that there are a number of TAGs in this patch disturbs me...
17:30:19 <SamB> btw
17:30:27 <SamB> the whole patch is in this email:
17:30:40 <SamB> http://article.gmane.org/gmane.comp.lang.haskell.cvs.ghc/17193
17:30:43 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/y7tf84
17:30:43 <Igloo> I suspect they're tags with extra patches to their left, BICBW
17:31:04 <SamB> extra to their left?
17:31:19 <SamB> the patches are in a vertical arrangement, dude!
17:31:29 <Igloo> Patch sequence ABTC where T is a tag containing just A
17:31:40 <Igloo> That's just an illusion
17:31:45 <SamB> no it isn't
17:31:53 <SamB> also they are in reverse order
17:43:48 <mauke> @hoogle assert
17:43:49 <lambdabot> Control.Exception.assert :: Bool -> a -> a
17:43:49 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
17:43:49 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
17:45:24 <dons> back from google :)
17:45:26 <dons> that was fun!
17:45:39 <Igloo> What's that?
17:45:51 <SamB> he was at google!
17:46:00 <SamB> at the googleplex, wasn't it?
17:46:11 <dons> the soc summit is over now. was really good, meeting the open source community at large
17:46:22 <dons> interesting to find that all these other orgs have the same issues you do, more or less
17:46:26 <SamB> you did not meet the open source community at large
17:46:32 <SamB> just some representatives of it
17:46:42 <dons> thanks SamB
17:46:42 <Igloo> Wait, you're back in .au?
17:46:46 <dons> no no
17:46:49 <SamB> heh
17:46:54 <dons> the conf just finished, limo back to hotel :)
17:46:56 <SamB> planes are not that fast ;-)
17:47:23 <dons> at large planes aren't, but some representatives are
17:47:30 <SamB> heh
17:47:33 <SamB> but
17:47:47 * Igloo deconfuses
17:47:48 <SamB> google did not even send you first class
17:48:01 <SamB> so why would they send you super-speedy-fast?
17:48:12 <dons> true
17:49:15 <mauke> I'm trying to use the FFI; can I tell the compiler to #define something before including the header mentioned in the foreign declaration?
17:50:38 <SamB> ... no?
17:50:40 <SamB> well.
17:51:01 <int-e> include your own header that defines something ...
17:51:02 <dons> mauke: using hsc2hs ?
17:51:10 <SamB> yeah, what int-e said.
17:51:20 <mauke> dons: not yet
17:53:07 <scsibug> Igloo: I've fixed the problems with my ghc binary distribution, and you can grab it here: http://scsibug.com/ghc-6.6-ppc-apple-darwin.tar.gz
17:53:09 <lambdabot> http://tinyurl.com/yhn92c
17:53:27 <scsibug> GMP is included with this copy though, which was part of the problem before
17:54:13 <scsibug> I think there is something wrong with make binary-dist, because it failed to include the rts and gmp libs
17:56:58 <Igloo> It didn't include the RTS?!
17:58:37 <scsibug> yup
17:59:11 <scsibug> I had to manually copy over the RTS and gmp libraries from the full build into the bindist directory
17:59:39 <scsibug> I've makefile-averse, but I'll try to take a closer look at why that didn't happen
18:01:49 <SamB> why would it include GMP?
18:04:44 <lisppaste2> SamB annotated #27967 with "fish_p.old.prof" at http://paste.lisp.org/display/27967#4
18:05:18 <scsibug> when ghc builds an executable, it links in gmp, correct?
18:05:26 <scsibug> as part of the rts
18:07:32 <araujo> @type error
18:07:34 <lambdabot> forall a. [Char] -> a
18:07:50 <mauke> the FFI doesn't go through the C compiler, right?
18:07:56 <araujo> Is there a way to write a function with that very similar signature?
18:08:09 <araujo> I meant, that returns any value
18:08:29 <Cale> araujo: that guarantees that the value returned is bottom.
18:08:43 <Cale> (evaluation of which will halt your program)
18:09:02 <Cale> bottom is the only value which is a member of every type
18:09:12 <araujo> Cale, i see ...
18:09:24 <araujo> So how could i write auch a function?
18:09:45 <SamB> @tell mauke not to leave right after asking a question
18:09:46 <lambdabot> Consider it noted.
18:10:07 <Cale> f x = f x
18:10:20 <Cale> @type let f x = f x in f
18:10:21 <lambdabot> forall t t1. t -> t1
18:10:42 <lisppaste2> SamB annotated #27967 with "fish_p.prof" at http://paste.lisp.org/display/27967#5
18:10:58 <Cale> @type let f x = undefined in f
18:10:59 <lambdabot> forall t a. t -> a
18:11:47 <SamB> hmm...
18:11:48 <araujo> But .. mmm ....
18:11:53 <SamB> not very useful, is that?
18:12:06 <Cale> no, it's not
18:12:14 <SamB> how do I get better cost centers...
18:12:21 <araujo> Cale, So the only way to do it, is throwing an exception?
18:12:33 <Cale> araujo: or going into an infinite loop
18:12:35 <ajay> > [Bool] -> [Int]
18:12:35 <lambdabot>  Parse error
18:12:38 <araujo> I see
18:12:52 <araujo> Cale, that's why error can have that kind of signature right?
18:12:58 <Cale> SamB: how did you compile the program?
18:13:15 <SamB> urm
18:13:26 <Cale> araujo: right
18:13:45 <araujo> Good, thanks Cale
18:14:00 <ajay> @hoogle [Bool] -> [Int]
18:14:01 <lambdabot> No matches, try a more general search
18:14:08 <araujo> It makes sense
18:14:11 <Cale> ajay: what would you want it to do?
18:14:18 <SamB> SRC_HC_OPTS   = -H32m -O $(MyWarningOpts)
18:14:18 <SamB> GhcHcOpts     = -Rghc-timing
18:14:18 <SamB> GhcLibHcOpts  =
18:14:18 <SamB> GhcLibWays    = p
18:14:33 <SamB> and then "make" in nofib's dir
18:14:34 <ajay> I am trying to find how I would change a Bool into an Int
18:14:44 <araujo> uh?
18:14:46 <Cale> ajay: and how would you do it?
18:15:00 <Cale> replace False with 0 and True with 1?
18:15:06 <araujo> > let f True = 1 ; f False = 0 in f True
18:15:08 <lambdabot>  1
18:15:09 <SamB> Cale: got that?
18:15:09 <araujo> ?
18:15:17 <Cale> > map fromEnum [False, True]
18:15:19 <lambdabot>  [0,1]
18:15:28 <ajay> False to 0, True to 1
18:15:36 <Cale> SamB: sort of, not completely sure what it means :)
18:15:47 <SamB> Cale: its from mk/build.mk
18:16:00 <Cale> SamB: see if you can get it to compile with -prof -auto-all, and if that's not enough, add -caf-all
18:16:18 <Cale> actually, looks like it won't be
18:16:27 <Cale> 100% of your time is spent computing cafs
18:16:33 <ajay> Hmm, thanks!
18:27:47 <SamB> but how!
18:27:55 <lispy> -caf-all is good
18:28:02 * lispy hasn't read the back log
18:28:09 <SamB> how about I just try without that first?
18:28:16 <lispy> but, i found that some CAFs are really functions in libraries you use
18:28:23 <mauke> does getEnv actually read from the C environment?
18:28:24 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
18:28:40 <lispy> mauke: what do you mean by C environment?
18:28:56 <mauke> the thing manipulated by getenv/putenv at the C level
18:29:05 <SamB> mauke: generally...
18:29:12 <lispy> mauke: i would expect it to :)
18:29:13 <SamB> it may not if e.g. there is no C
18:29:21 <lispy> but i have no proof that it does...
18:29:25 <mauke> there is a C.
18:29:35 <lispy> ABDEF... -- omg!?
18:29:39 <lispy> :)
18:29:48 <SamB> well, if it doesn't, complain to either the C or the Haskell implementors that something wierd is up!
18:29:59 <SamB> (whoever is new to the OS)
18:31:05 <mauke> I wonder why there's no putenv in System.Environment
18:31:22 <SamB> @hoogle putenv
18:31:23 <lambdabot> No matches found
18:31:24 <SamB> @hoogle setenv
18:31:25 <lambdabot> No matches found
18:31:28 <SamB> @hoogle env
18:31:29 <lambdabot> System.Environment :: module
18:31:29 <lambdabot> System.getEnv :: String -> IO String
18:31:29 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
18:31:35 <SamB> good question...
18:31:41 * araujo found a way to avoid modifying a whole data structure just using a 'patter match'
18:32:02 <araujo> egh, i feel like i always end up abusing 'where' though ..
18:32:08 <SamB> ?
18:32:14 <Cale> araujo: abusing?
18:32:25 <araujo> Cale, yes, using too much where's :-)
18:32:56 <araujo> Most of the code i read use more let's than where though
18:32:56 <SamB> ... what do you think you should be doing instead?
18:33:17 <lispy> araujo: i would discourage let and encourage where
18:33:21 <SamB> it depends on which way you would want to read it
18:33:21 <araujo> SamB, probably abusing let? :-)
18:33:27 <lispy> araujo: where makes your code more declarative generally
18:33:29 <Cale> they're the same thing. Personally, I usually prefer to use where over let when I have a choice.
18:33:32 <SamB> don't abuse let
18:33:51 <araujo> lispy, yes, i usually find it easier to read with where
18:34:07 <SamB> at the very least, where doesn't interfere with indentation and is therefore less intrusive
18:34:22 <SamB> also, it works even over several guards
18:34:35 <araujo> my code usually ends up with more 'where' than 'let' , though i see 'let' is used very much on the code i read
18:34:48 <SamB> usually you should only use let in do blocks ;-)
18:34:59 <SamB> araujo: do you enjoy reading this other code?
18:35:05 <araujo> SamB, that's barely the place where i use 'let'
18:35:16 <araujo> SamB, i'd prefer it with where :-)
18:35:33 <SamB> well, then, I think it should be obvious what to do
18:35:36 <araujo> Though, it seems 'let' looks a bit more hackish
18:36:08 <SamB> assuming you feel that you will continue to prefer reading code with wheres in ;-)
18:36:19 <SamB> I too seem to write it with wheres in a lot
18:36:27 <SamB> (how long have wheres been here anyway?)
18:36:35 <Cale> since the very beginning
18:36:36 <araujo> dunno
18:36:42 <SamB> Cale: of Haskell, sure.
18:36:48 <Cale> In fact, before Miranda
18:36:52 <SamB> oh?
18:37:08 <SamB> surely they must have been introduced into a programming language for the first time *once*
18:37:24 <Cale> http://en.wikipedia.org/wiki/ISWIM
18:37:27 <SamB> for instance, does ML have them?
18:37:44 <SamB> some Haskell users come from an ML background, yes?
18:37:53 <araujo> 'let' looks nice for introducing little variables on small functions though.
18:38:01 <SamB> ???
18:38:11 <Cale> ISWIM, which I don't think was ever implemented, was probably one of the first languages with where
18:38:12 <SamB> I don't think so.
18:38:32 <SamB> Cale: who cares then? did anyone write practical code in it?
18:38:34 <SamB> I doubt it!
18:38:55 <Cale> It's the ideological predecessor of SASL, Miranda, ML and Haskell
18:39:11 <SamB> but does ML have where?
18:39:44 <araujo> i feel 'where' more natural to read though
18:40:09 <Cale> I don't think it does actually.
18:40:12 <Cale> Miranda does
18:40:21 * SamB thinks that that article should be marked as a stub
18:40:33 <Cale> Which one?
18:40:55 <SamB> the ISWIM one
18:41:32 <Cale> why?
18:41:40 <SamB> it is soo short
18:42:09 <Cale> All that really needs to be there is the link to "The Next 700 Programming Languages"
18:42:10 <SamB> it doesn't even contain a Hello World-ish example!
18:42:31 <SamB> well, that link should probably be better emphasized
18:42:49 <Cale> I'm not even sure ISWIM was specified far enough to talk about IO
18:43:02 <SamB> it doesn't have to do IO
18:43:07 <Cale> It was basically an idea for a programming language :)
18:43:26 <SamB> it could be the fib or fac, instead
18:43:45 <Cale> Oh, it does have Print
18:44:16 <Cale> or does it? :)
18:44:18 <Cale> hehe
18:45:33 <scsibug> where can I find the ReadMap module?  (trying to compile shapr's happswiki)
18:46:02 <Cale> Oh, it specifically doesn't even have a defined lexical syntax
18:48:50 <Cale> Why does there have to be 300 slightly different renamed mirrors of Wikipedia?
18:49:13 <SamB> um, for ad revenue?
18:51:48 <Cale> It seems almost impossible to find specifications for SASL and KRC on the web.
18:52:32 <Cale> But you can get a "KRC programming language Google Toolbar Button"
18:52:44 <Cale> "with Wikipedia article, Yahoo news and targeted Google search."
18:56:28 <Cale> aha
18:56:30 <Cale> http://people.bath.ac.uk/klg21/sasl/saslman.pdf
18:56:33 <lambdabot> http://tinyurl.com/troc4
18:57:12 <Cale> SASL predates both KRC and Miranda, and made extensive use of where clauses.
18:57:22 <chessguy> @type head . tail
18:57:23 <lambdabot> forall a. [a] -> a
18:58:21 <chessguy> @type head . head
18:58:23 <lambdabot> forall a. [[a]] -> a
18:58:29 * hyrax42 likes where
18:59:45 <hyrax42> does anyone else think printf should have a format character for an argument that is a Show instance?
19:00:12 <hyrax42> printf "blkd %s jkfds %s" (show blah) (show bleh)
19:00:18 * dcoutts doesn't believe in printf
19:00:18 <hyrax42> is silly
19:01:02 <hyrax42> well it can be handy in some instances
19:01:09 <hyrax42> why not, if I may ask
19:09:04 <Cale> Why not believe in printf?
19:09:14 <SamB> hyrax42: it would be nice, but I don't think its possible
19:09:21 <Cale> Because it generally leads to avoidable bugs.
19:09:40 <Cale> Format strings are dangerous
19:09:45 <hyrax42> the PrintfArg etc. hackery wouldn't work?
19:09:45 <SamB> Cale: not really
19:10:26 <SamB> not really, no
19:10:37 <SamB> see, the instance would look like
19:10:49 <SamB> instance Show a => PrintfArg a where ...
19:11:19 <SamB> and even if most of the types that are in PrintfArg *weren't* members of Show, the compiler wouldn't know that!
19:11:25 <SamB> it could change at any time!
19:13:21 <SamB> (that is, any module could add one)
19:13:38 <SamB> er, add an instance for Show Foo
19:13:50 <SamB> where Foo had been in PrintfArg already...
19:16:41 <dons> hyrax42: hmm. .. that's the point of printf. it knows how to show things
19:16:49 <dons> > printf "%d" (7 :: Int) -- for example
19:16:49 <lambdabot>  Add a type signature
19:16:56 <dons> > printf "%d" (7 :: Int) :: String -- for example
19:16:57 <lambdabot>  "7"
19:17:00 <dons> and a result type, of course.
19:17:02 <hyrax42> yes but
19:17:18 <dons> you want some arbitrary a that is in Show?
19:17:18 <hyrax42> printf "%??" (Just 5)
19:17:21 <hyrax42> can't be done
19:17:23 <dons> right. hmm
19:17:34 <dons> yeah, that'd be nice.
19:17:41 <chessguy> hmmm. YAHC really waxes mysterious about monads
19:17:41 <dons> i think it would need just a little bit of class hacking
19:17:52 <hyrax42> the hackery in printf is a little beyond me at this point
19:18:01 <chessguy> at least before it's ready to really explain them (which i haven't gotten to yet)
19:18:03 <hyrax42> and I just plain don't have time to look at it
19:18:08 <dons> you could propose it on the libraries@ list, hyrax42 , and we could see if the printf authors know if it would be possible to have a default instance for Showabe things
19:18:19 <hyrax42> dons: will do
19:18:28 <dons> it seems like a sensible printf/haskell extensions
19:18:41 <ozone> dons: look at the boost::format class
19:18:44 <hyrax42> a patch would be nicer thoug... if I could do it
19:18:54 <ozone> typesafe printf in C++
19:19:03 <chessguy> ok, nobody cares :)
19:19:08 <ozone> might as well copy the snytax, since it's sane
19:19:10 <ozone> http://www.boost.org/libs/format/index.html
19:19:12 <dons> ozone: ?
19:19:28 <dons> whatcha talking about? we already have printf... ? or you mean this is some extended printf for showable things?
19:19:44 <hyrax42> chessguy: how far along ar eyou
19:19:45 <dons> ?type printf
19:19:51 <hyrax42> you're talking about YAHT?
19:19:52 <hyrax42> ?where yaht
19:20:03 <chessguy> 4.4
19:20:05 <dons> probably network. let's just hang on...
19:20:08 <ozone> well, i think that if you need to specify the types for the things to be printed (e.g. %d vs %s vs %u), printf is arguably broken :)
19:20:13 <chessguy> yes, yaht, not yahc
19:20:23 <dons> ozone: only for things that don't default properly
19:20:29 <hyrax42> chessguy: I think it's jsut something you have to put up with
19:20:32 <SamB> ozone: those aren't types
19:20:37 <lambdabot> Title: The Boost Format library
19:20:51 <dons> if you could avoid the default for Num a's, then adding one for Show a's would be possibel too
19:20:53 <lambdabot> forall r. (PrintfType r) => String -> r
19:20:55 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
19:20:58 <hyrax42> I learned what I know aobut monads from a whole bunch of places
19:21:09 <ozone> dons: not sure what you mean
19:21:11 <hyrax42> and I think actually that YAHT wasn't one of them
19:21:16 <chessguy> i hope it's less mysterious once it gets around to actually trying to explain it
19:21:17 <ozone> (then again, i also jumped into this conversation late)
19:21:17 <SamB> dons: ... which printf do you think we are dealing with here?
19:21:26 <dons> > printf "%c" 'x' -- ozone
19:21:26 <hyrax42> chessguy: I used YAHT to get off the ground
19:21:27 <lambdabot>  Add a type signature
19:21:35 <dons> oh, modulo te result type
19:21:36 <hyrax42> but then lots of pestering in here
19:21:43 <dons> since sprintf == printf in haskell, based on the type
19:21:49 <hyrax42> plus All About Monads plus Monads as Containers
19:21:52 <dons> > printf "%c" 'x' :: String
19:21:53 <lambdabot>  "x"
19:22:03 <ozone> > printf "%s" 'x' :: String
19:22:05 <lambdabot>  Exception: Printf.printf: bad argument
19:22:07 <dons> so you only need to specify the arg type when it is a Num or Floating that doesn't default
19:22:09 <SamB> > printf "%d" (12 `xor` 225) :: String
19:22:10 <lambdabot>  Add a type signature
19:22:15 <dons> like that
19:22:15 <chessguy> hyrax42, that's Cale's tutorial, right?
19:22:21 <hyrax42> chessguy: yup
19:22:31 <hyrax42> that was where I really started to get an idea of what >>= and so on did
19:22:50 <ozone> dons: i guess my point is, if you mess up the format specifier, it'll die
19:23:08 <chessguy> well, i need to get through yaht. it just annoys me when it kind of hedges around monads so much
19:23:18 <dons> right. printf is a shallowly embedded interpreter. the format string doesn't connect to the haskell type system
19:23:22 <ozone> (at runtime)
19:23:28 <dons> (unlike, say, the TH-based printf)
19:23:32 <SamB> my complain is that it doesn't respect the modifiers the same way the C printf does...
19:23:36 <ozone> right, just checking
19:23:37 <SamB> er, complaint.
19:23:54 <ozone> not really complaining, just making a point
19:23:54 <hyrax42> ok yeah
19:24:05 <hyrax42> I kind of stopped reading YAHT somewhere in the ch5-7 range
19:24:18 <hyrax42> oh and don't break your head over section 4.6
19:24:34 <ozone> boost::format works quite nicely, if you're looking for a type-safe prionntf to model
19:24:47 <chessguy> uh-oh, that's coming soon :)
19:25:00 <hyrax42> chessguy: as in I started not reading sequentially at that piont, and flicked around
19:25:30 <SamB> ozone: C++ has somewhat-overlapping templates, though -- Haskell does not
19:26:02 <chessguy> heh. 4.6 starts with the author saying "i'm about to do some hand-waving"...that's not a good sign
19:26:07 <SamB> with Haskell you have to decide whether you want ad-hoc or parametric polymorphism
19:26:15 <SamB> chessguy: well.
19:26:16 <hyrax42> haha
19:26:21 <SamB> at least the author is honest!
19:26:26 <chessguy> :)
19:26:31 <ozone> samb: i'm familiar with the problems.  merely trying to annoy dons :)
19:26:39 <SamB> ozone: oh
19:26:47 * SamB isn't sure why that would be useful
19:27:00 <SamB> usually if you annoy dons he just tells you to send a patch!
19:27:11 <ozone> well, i didn't get to annoy him on the plane flight this time
19:27:14 <ozone> gotta make up for it somehow
19:27:24 <SamB> he isn't flying now is he?
19:27:33 <hyrax42> hm
19:27:38 <SamB> isn't he at the hotel?
19:27:43 <hyrax42> ?hoogle Eq a => [a] -> Bool
19:27:44 <lambdabot> Prelude.null :: [a] -> Bool
19:27:45 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
19:27:45 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
19:28:06 <ozone> i thought dons was in an ivory tower somewhere...
19:28:11 <SamB> hyrax42: are you looking for "same" or somesuch?
19:28:25 <chessguy> @type (\(x::Int) -> x*x)
19:28:26 <lambdabot> Int -> Int
19:28:28 <SamB> ozone: he said something about a limo to a hotel
19:28:31 <hyrax42> SamB: yeah pretty much
19:28:38 <hyrax42> was wondering if I would be reinventing the wheel
19:28:38 <SamB> ozone: from the googleplex
19:28:45 <chessguy> > (\(x::Int) -> x*x) 2.2
19:28:45 <lambdabot>  Parse error in pattern
19:28:50 <chessguy> > (\(x::Int) -> x*x) 2
19:28:50 <lambdabot>  Parse error in pattern
19:29:22 <hyrax42> > \x -> x*x $ 2
19:29:23 <lambdabot>  add an instance declaration for (Num (a -> b))
19:29:28 <hyrax42> hm
19:29:32 <hyrax42> > join (*) 2
19:29:33 <lambdabot>  4
19:29:35 <hyrax42> ;)
19:29:50 <dons> hyrax42: pattern type sigs aren't haskell 98
19:30:11 <mauke> ?type (and .) . (tail >>= (==))
19:30:13 <lambdabot>   Couldn't match `a -> [Bool]' against `Bool'
19:30:13 <lambdabot>    Expected type: [a1] -> a -> [Bool]
19:30:46 <mauke> ?type (and .) . (tail >>= zipWith (==))
19:30:48 <lambdabot>   Couldn't match `a -> [Bool]' against `[Bool]'
19:30:48 <lambdabot>    Expected type: [a1] -> a -> [Bool]
19:31:29 <mauke> ?type and . (tail >>= zipWith (==))
19:31:31 <lambdabot> forall a. (Eq a) => [a] -> Bool
19:31:33 <mauke> duh
19:38:46 <ihope> @type 3 :: Int
19:38:47 <lambdabot> Int :: Int
19:39:05 <ihope> dons: so are you going to fix that bug or what? :-P
19:39:23 <dons> the above one?
19:39:38 <dons> not any time soon. please submit a patch :)
19:40:15 <hyrax42> ?type id :: Int -> Int
19:40:16 <lambdabot> Int -> Int :: Int -> Int
19:40:26 <dons> hehe. at one of the talks at the google soc summit today a guy from subversion made the joke that "please submit a patch" is slang for "go screw yourself" in the open source community ;)
19:40:26 <SamB> ihope: it is complicated by kind signatures, iirc
19:40:44 <ihope> Kind signatues?
19:40:47 <dons> yeah
19:40:50 <dons> ?type fmap
19:40:52 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
19:40:58 <dons> too many ::
19:40:58 <ihope> Ipe.
19:40:59 <SamB> dons: it is a lot more polite, though ;-)
19:41:05 <dons> it is :)
19:41:10 <SamB> it is more like "yeah? well I don't have time! you do it!"
19:41:23 <hyrax42> does anyone have code online well-tested with quickcheck?
19:41:28 <ihope> Eh, just don't strip the expression from the beginning of it :-P
19:41:29 <hyrax42> dons, you said fps has loads right?
19:41:35 <dons> loads?
19:41:36 <SamB> also it is actually possible to do ;-)
19:41:41 <hyrax42> of quickcheck properties
19:41:57 <dons> hyrax42: yeah, check the fps QuickCheck properties, in Properties.hs
19:42:04 <hyrax42> ok
19:42:05 <hyrax42> ?where fps
19:42:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:42:09 <dons> (there's a link from the example code page of haskell.org)
19:42:13 <ihope> Unless what you spit into GHC is spat back at you.
19:42:27 <dons> here, http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
19:42:28 <lambdabot> http://tinyurl.com/hcek8
19:42:42 <ihope> Oh, yeah.
19:42:42 <SamB> ihope: it is!
19:42:58 <SamB> @type () :: ()
19:43:00 <lambdabot> () :: ()
19:43:11 <ihope> It even copies the spacing in "let x              = x in x" :-)
19:43:14 <SamB> @type [] :: [()]
19:43:16 <lambdabot> [()] :: [()]
19:43:32 <SamB> wow!
19:43:42 <SamB> @type let x              = x in x
19:43:43 <lambdabot> forall t. t
19:43:53 <SamB> oh, right...
19:44:01 <SamB> @type let x :: ()             = x in x
19:44:03 <lambdabot> ()             = x in x :: ()
19:44:06 <ihope> lambdabot trashes the stuff before the first ::.
19:44:14 <SamB> yes I know ;-)
19:44:20 <ihope> So does lambdabot get the type just by doing a :t in GHCi or something?
19:44:28 <SamB> exactamundo!
19:45:33 <ihope> A semi-hack, then: drop the length of the input, plus one.
19:45:41 <SamB> hmm.
19:45:45 <SamB> not bad!
19:45:46 <ihope> For ":t ()", drop six characters.
19:46:04 <SamB> well.
19:46:17 <SamB> lambdabot would be calling "()" the input, methinks...
19:48:35 <ihope> Then drop the input length plus four.
19:48:44 <SamB> it ought to work ;-)
19:49:46 <ihope> So why are kinds needed?
19:51:53 <SamB> kinds?
19:51:56 <SamB> well...
19:52:33 <SamB> @type (>>=)
19:52:34 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
19:52:38 <hyrax42> anyone else have a body of code with associated quickcheck properties I can get somehwere online?
19:52:42 <SamB> GHC outputs them for some reason...
19:52:55 <SamB> so you can't start from either the right *or* the left and cut at the first ::
19:53:06 <ihope> Guess things are easier with kinds.
19:53:06 <hyrax42> GHC with exts prints them out
19:56:53 <hyrax42> dons: I was worried about the list of tests thing like you have at the end of Properties.hs
19:56:58 <hyrax42> seems a mite inelegant
20:07:11 <dons> hyrax42: the stuff at the end can be done in template haskell, using HTF, if you don't like duplicating the properties list
20:07:15 <dons> ?where htf
20:07:15 <lambdabot> http://www.stefanwehr.de/darcs/HTF
20:07:32 <hyrax42> 404
20:08:07 <hyrax42> well mostly I don't like having to keep them maintained
20:08:32 <hyrax42> also, should I declare my instances for arbitrary with the types?
20:08:43 * hyrax42 wishes Arbitrary could be derived
20:09:02 <dons> you need to write your own Arbitrary instances, for new types you use, yes.
20:09:28 <dons> there is a command line quickcheck tool around that juts runs anything named 'prop_*' in a .hs src file, removing the need for the properties list, btw
20:09:33 <dons> not sure where it lives though
20:09:58 <hyrax42> dons: yeah I tried to find it but it's not on my path afaik
20:10:12 <dons> no, you'd need to find and build it :)
20:10:19 <dons> but maintaing the properties list isn't too hard
20:10:23 <hyrax42> can I define the instances in another file?
20:10:27 <hyrax42> is there any reason to want to?
20:10:27 <dons> yes
20:10:43 <hyrax42> I'm thinking better not to have the instance unless it's going to be used
20:10:44 <dons> you can put them in another file, if you intend to share the instances amongst multiple modules
20:11:12 <hyrax42> i.e. no need for it outside of my tests
20:11:19 <dons> see the QuickCheckUtils.hs file for a bunch of Arbitrary instances used in the Propertie.hs i linked to
20:13:30 <hyrax42> how long does the full suite of fps tests take to run
20:13:53 <dons> oh  hmm. a while if you run it in all the different combinations
20:13:56 <dons> 5 mins or so on my box
20:14:02 <hyrax42> k
20:14:43 <hyrax42> it is possible to redefine instances?
20:14:58 <dons> ?remember sigfpe Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful thing is.
20:15:01 <hyrax42> you define instance Arbitrary Char, but I'm pretty sure there is one already?
20:15:09 <dons> there isn't one already :)
20:15:13 <hyrax42> oh ok
20:15:30 <hyrax42> ?type choose
20:15:31 <lambdabot> Not in scope: `choose'
20:15:46 <hyrax42> ?type Test.QuickCheck.choose
20:15:48 <lambdabot> forall a. (Random a) => (a, a) -> Test.QuickCheck.Gen a
20:16:09 <hyrax42> ?instances Random
20:16:09 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:16:17 <dons> that error message is too verbose
20:16:18 <hyrax42> ?instances-importing Test.QuickCheck Random
20:16:19 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:16:33 <dons> it mightn't know about classes out side of base/
20:16:38 <dons> ?hoogle Random
20:16:38 <hyrax42> do I have to define instances for Random?
20:16:38 <lambdabot> Random :: module
20:16:39 <lambdabot> System.Random :: module
20:16:39 <lambdabot> System.Random.Random :: class Random a
20:16:43 <dons> sometimes
20:16:51 <hyrax42> can it be derived?
20:17:01 <dons> if there's no obvious encoding in terms of random ints, for example
20:17:02 * hyrax42 guesses not
20:17:07 <dons> (say you want to generate random doubles)
20:17:20 <dons> often you don't need to write a special Random instance though
20:17:27 <hyrax42> hm what does coarbitrary do
20:17:37 * hyrax42 goes to read docs
20:17:51 <dons> check the paper ;) its going to break your brain..
20:18:18 <SamB> heh
20:18:28 <SamB> isn't that for functions taking that type?
20:18:31 <SamB> or something like that?
20:18:39 <hyrax42> dons: no doubt
20:18:42 <dons> for generating random functions over some type, yep
20:18:48 <hyrax42> I always wondered how it generated random functions
20:18:59 <hyrax42> anyway for my stuff I won't need coarbitrary
20:19:04 <hyrax42> which means I don't have to read about it just yet
20:19:19 <hyrax42> which means I probably will :/
20:19:25 <SamB> hah!
20:19:41 <dons> na, you rarely need it unless you want to generate random functions..
20:20:10 <chessguy> ok, YAHT has redeemed itself for its hedging in chapter 4. i like the way it treats IO in chapter 5
20:20:22 <SamB> hedging?
20:20:38 <chessguy> yeah, about monads
20:21:59 * SamB ... goes ... to bed
20:22:09 <dons> but its still early!
20:22:13 <dons> ?localtime SamB
20:22:15 <lambdabot> Local time for SamB is Sat Oct 14 23:22:01
20:22:19 <dons> ah , not so early
20:22:21 <chessguy> ?localtime chessguy
20:22:22 <lambdabot> Local time for chessguy is Sat Oct 14 23:20:03 2006
20:22:25 <SamB> dons: I am not in california, you silly!
20:22:28 <dons> hehe
20:22:35 <dons> so the US isn't all one timezone then
20:22:38 <SamB> I am on the *east* coast
20:22:40 <SamB> hahahaha
20:22:41 <chessguy> lol
20:22:52 <chessguy> no dons, we have TWO coasts...
20:22:55 <SamB> ... is .AU?
20:23:05 <dons> .au is 3 timezones, like the US
20:23:10 <chessguy> lol
20:23:11 <hyrax42> hmmm... nifty stuff with model, dons
20:23:11 <dons> since they're about the same size
20:23:15 <SamB> um
20:23:19 <SamB> US is, like, four?
20:23:20 <dons> you don't have 3?
20:23:24 <chessguy> the US is 4, just in the continental states
20:23:28 <dons> ah right.
20:23:33 <hyrax42> canada has 5 :p
20:23:36 <chessguy> eastern, central, mountain, and pacific
20:23:37 <SamB> hawaii doesn't count
20:23:38 <dons> we have 4, but 3 across and 2 vertically
20:23:44 <hyrax42> moutain is a half hour?
20:23:46 <SamB> heh
20:23:50 <dons> then there's the freaks like chrismas island and so on
20:24:06 <chessguy> christmas island? where it's always christmas?
20:24:08 <SamB> and I have no clue about alaska
20:24:14 <SamB> chessguy: you are so naive!
20:24:21 <chessguy> heh
20:25:06 <chessguy> SamB, where are you? you're in my time zone
20:25:28 <ACSpike> hello
20:25:37 <dons> hi ACSpike
20:25:45 <chessguy> hi ACSpike, don't mind the insanity
20:25:46 <SamB> PA
20:25:49 <thetallguy> ?localtime dons
20:25:50 <hyrax42> ?localtime hyrax42
20:25:51 <lambdabot> Local time for hyrax42 is 2006-10-14 23:25:28 -0400
20:25:53 <lambdabot> Local time for dons is Sun Oct 15 13:25:27 2006
20:25:56 <SamB> near Philadelphia
20:25:58 <dons> not really..
20:26:00 <chessguy> !
20:26:01 <SamB> @map
20:26:04 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:26:11 <SamB> dons is running in screen
20:26:13 <dons> its what , 8.24 here
20:26:17 <chessguy> dude, you're like 2 hours from me
20:26:18 <thetallguy> Yes
20:26:18 <dons> pm
20:26:35 <chessguy> i'm just outside harrisburg
20:26:37 <ACSpike> chessguy: as a noob, I'll take what I can get :-)
20:26:41 <SamB> chessguy: you didn't haskell users came so close together?
20:26:53 <thetallguy> So, you didn't set the time on your laptop to local?
20:27:12 <dons> screen. its still running irc on a box back in sydney
20:27:13 <SamB> I don't think I've ever been that far west. well. except maybe this one trip to PSU I took at PGSIT...
20:27:13 <chessguy> i didn't think pennsylvania had anybody cool enough to know haskell in it
20:27:19 <SamB> heh
20:27:32 <chessguy> PSU main?
20:27:37 <dons> ?remember chessguy i didn't think pennsylvania had anybody cool enough to know haskell in it
20:27:40 <SamB> I think so!
20:27:50 <SamB> it took hours on a nice bus to get there...
20:27:57 <SamB> anyway, bed
20:27:58 <chessguy> ok, been there. big place. i go to PSU harrisburg
20:28:04 <chessguy> which isn't in harrisburg, of course
20:28:09 <chessguy> 'night!
20:28:14 <SamB> 'night!
20:28:16 <dons> night SamB
20:29:36 <chessguy> hmm, Cale's not that far away either
20:30:25 <dons> ACSpike: so you're learning haskell?
20:30:29 <dons> got ghc installed yet?
20:30:33 <hyrax42> ?type Test.QuickCheck.oneof
20:30:34 <lambdabot> forall a. [Test.QuickCheck.Gen a] -> Test.QuickCheck.Gen a
20:30:52 <hyrax42> ?instances-importing Test.QuickCheck Monad
20:30:53 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, Gen, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:30:57 <hyrax42> kk
20:31:09 <chessguy> ACSpike, this is a great users group for newbies. i've learned a ton in here
20:31:22 <ACSpike> dons: I think I'd like to yeah. I've read a few tutorials and they just drop out from underneath me.
20:31:39 <ACSpike> chessguy: that's very encouraging to hear
20:31:56 <dons> ACSpike: so you've done the 'Haskell in 5 steps' quick tut?
20:32:05 <dons> and then the next recommendation is 'Yaht'
20:32:08 <dons> ?where yaht
20:32:08 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
20:32:18 <chessguy> haskell in 5 steps?
20:32:28 <dons> really quick intro to get stuff done in ghci or hugs
20:32:36 <dons> (on haskell.org's front page)
20:32:43 <chessguy> oh, that one
20:32:50 <chessguy> that's not what it's called, is it?
20:32:56 <ACSpike> dons: I actually have that page open now. and I just stumbled upon the syntax tour, which is clarifying things
20:33:13 <chessguy> ACSpike, are you new to functional programming too?
20:33:26 <ACSpike> chessguy: yes
20:33:37 <hyrax42> ?instances-importing Test.QuickCheck Arbitrary
20:33:38 <lambdabot> (), (a -> b), (a, b), Bool, Double, Float, Int, Integer, [a]
20:33:50 <hyrax42> dons, can I redefine instances?
20:33:59 <chessguy> oh, then i really must recommend the SICP video lecture series
20:34:12 <hyrax42> I want an instance for (Int,Int) that picks inside a small range
20:34:16 <dons> hyrax42: you can some times, yes. depending on overlapping and so on. it is usually just easier to newtype ,and write a new instance
20:34:25 <chessguy> http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/
20:34:26 <dons> newtype Pair = (Int,Int)
20:34:28 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/wpe3
20:34:33 <dons> then write an instance for Pair (Int,Int)
20:34:42 <dons> newtype Pair = Pair (Int,Int)
20:35:03 <hyrax42> but I don't want the Pair there
20:35:08 <hyrax42> will just cause big headache
20:35:29 <hyrax42> if I have -fallow-overlappint-instances
20:35:50 <hyrax42> then (Int,Int) is more specific than (Arbitrary a, Arbitrary b) => (a, b)
20:35:58 <ACSpike> chessguy: awesome. a little bit astounded by the size of those :-)
20:35:59 <hyrax42> so it should work?
20:36:13 <dons> hyrax42: yeah, I think so.
20:36:13 <chessguy> yes, they're large, but well-worth watching
20:36:24 <dons> hyrax42: see in the QuickCheckUtils.hs file, we do that
20:36:25 <hyrax42> fingers crossed
20:36:31 <hyrax42> dons: ok
20:37:17 <chessguy> so dons, is haskell gonna be in SoC '07?
20:37:26 <dons> yeah, I reckon so
20:37:41 <dons> we were one of the most organised
20:37:46 <chessguy> i wish i was still a student then
20:37:59 <dons> (which is mostly what they care about, along with strategic importance to  google and the oss community)
20:38:00 <chessguy> haskell needs an evolutionary computation module
20:38:09 <hyrax42> dons, why do you define the ((->) e) Monad instance in QuickCheckUtils?
20:38:22 <dons> hyrax42: oh, for the magic with `eq`
20:38:27 <dons> so i can avoid having to specify arguments
20:38:33 <hyrax42> I mean why not import
20:38:36 <hyrax42> or you define differently
20:38:42 <dons> no, for hugs
20:38:54 <dons> it doesn't have the reader monad instance in the same place
20:38:59 <hyrax42> oh
20:39:21 <hyrax42> anyway, you don't do any overlapping instances in there that I can see
20:40:22 <dons> no? hmm. not in the top of QuickCheckutils.hs ?
20:40:31 <dons> maybe we used to and tossed it?
20:47:29 <ACSpike> g'night
20:51:25 <chessguy> wow, i'm all the way to "advanced features" in YAHT!
20:56:44 <hyrax42> ?index Random
20:56:45 <lambdabot> System.Random
20:56:52 <hyrax42> ?docs Random
20:56:52 <lambdabot> Random not available
20:56:58 <hyrax42> ?docs System.Random
20:56:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
20:57:45 <Pegazus> what books or papers or thing would you advise me to read, to learn haskell really well? (i know the basics)
20:59:02 <chessguy> good question. i'll soon be where you are, Pegazus
20:59:41 <Pegazus> where i am?
20:59:59 <chessguy> i'll soon know the basics and be trying to figure out what to do next
21:00:32 <chessguy> have you worked through YAHT yet?
21:02:32 <hyrax42> more weirdness... why no instance of Random for (a,b)
21:11:32 <dolio> Oversight?
21:13:12 <glguy> it doesn't seem appropriate to have an instance of Random for (a,b)
21:13:31 <glguy> since you can't have a random tuple, and if you wanted to randomize the contents of that tuple, then just write a function to do so
21:14:03 <glguy> things like Int and Float need specialized instances because Ints and Floats can be random
21:14:28 <hyrax42> why can't you have a random tuple?
21:14:43 <hyrax42> I mean of course where a and b are instances of random
21:14:46 <hyrax42> I just defined:
21:14:47 <hyrax42> ?paste
21:14:47 <lambdabot> http://paste.lisp.org/new/haskell
21:14:51 <glguy> there is nothing about the tuple itself that need sto be randomized
21:14:56 <glguy> I understand what you mean
21:15:19 <glguy> but that functionality is better described as a normal function than as an instance of Random, IMHO
21:16:09 <hyrax42> *shrug* makes my life easier
21:16:15 <hyrax42> for current purposes
21:17:56 <hyrax42> > all even []
21:17:58 <lambdabot>  True
21:18:14 <glguy> > all (const False) []
21:18:15 <lambdabot>  True
21:18:35 <glguy> > any (const False) []
21:18:36 <lambdabot>  False
21:18:38 <glguy> > any (const True) []
21:18:40 <lambdabot>  False
21:21:27 <hyrax42> ?pl let f [] = []; f (x:xs) = [x] in f
21:21:27 <lambdabot> (line 1, column 7):
21:21:27 <lambdabot> unexpected "["
21:21:27 <lambdabot> expecting pattern or "="
21:21:48 <hyrax42> ?pl let {f [] = []; f (x:xs) = [x]} in f
21:21:49 <lambdabot> (line 1, column 5):
21:21:49 <lambdabot> unexpected "{"
21:21:49 <lambdabot> expecting natural, identifier or "in"
21:22:07 <hyrax42> oh that won't even work
21:23:19 <hyrax42> > take 1 []
21:23:20 <lambdabot>  Add a type signature
21:23:27 <hyrax42> > take 1 [] :: [Int]
21:23:28 <lambdabot>  []
21:24:03 <hyrax42> quickcheck already paying for itself
21:24:07 <hyrax42> of course for stupid reasons
21:24:13 <hyrax42> head of empty list... :/
21:32:29 <dons> :)
21:32:49 <dons> ?check \s -> head s == 'x'
21:32:51 <lambdabot>  Falsifiable, after 0 tests: "\1072693\743583"
21:32:54 <dons> heh
21:32:57 <dons> ?scheck \s -> head s == 'x'
21:32:58 <glguy> > liftM2 (>>) (guard.not.null) (return.head) [2,3,4] :: Maybe Int
21:32:59 <lambdabot>  add an instance declaration for (Serial Char)
21:32:59 <lambdabot>   In the definition of `leq...
21:33:00 <lambdabot>  Just 2
21:33:05 <glguy> > liftM2 (>>) (guard.not.null) (return.head) [] :: Maybe Int
21:33:07 <lambdabot>  Nothing
21:33:12 <dons> ?check \s -> if head s == c then c == c
21:33:12 <lambdabot>  Parse error
21:33:19 <dons> ?check \s -> if head s == c then c == c else c == c
21:33:20 <lambdabot>  Not in scope: `c'
21:33:21 <hyrax42> yeah I had return . head when take 1 does what I want
21:33:31 <dons> ok, i'm way too sleepy.
21:33:32 <dons> night all!
21:33:36 <hyrax42> night
21:33:37 <glguy> night
22:24:10 <musasabi> morning
22:27:29 <araujo> morning musasabi
22:54:13 <hyrax42> ?index Gen
22:54:14 <lambdabot> Test.QuickCheck, Debug.QuickCheck
22:54:48 <hyrax42> ?instances-importing Test.QuickCheck Monad
22:54:49 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, Gen, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:26:41 <hyrax42> ?hoogle Int -> Bool
23:26:42 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
23:28:20 <hyrax42> ?where yaht
23:28:20 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
23:48:41 <Botty> Why is it that whenever someone makes a haskell vector type they make a 'vectorspace' class as well
23:50:17 <Cale> Botty: because they can, and it lets them replace that type later if they want
23:50:58 <Botty> I suppose.  You can't do something like generics in haskell?
23:51:11 <Cale> Generics in which sense?
23:51:15 <Botty> for example a "Vector Int" type
23:51:20 <Cale> You can do that
23:51:51 <Cale> But that doesn't give you control over the dimension, for instance.
23:52:14 <Cale> or strictness of the components
23:52:27 <Cale> or other things which you might want to control about the representation.
23:52:44 <Botty> mm, ok
23:53:08 <Botty> So I guess there's no way to do "Vector 3 Int"
23:53:36 <Cale> Well, to be honest, there is, but it requires even more typeclass hackery :)
23:53:52 <Botty> hehe, ok
23:54:23 <Cale> at least, to use those annotations in a meaningful way (for example, to be able to define the concatenation of vectors, summing the dimensions)
23:54:44 <Botty> yeah, probably be a pretty messy vector class
23:55:04 <Cale> Well, first off, you have to get numbers into the type system.
23:56:28 <Botty> well, thats alright I'll just implement a plain vector class
23:56:34 <Cale> :)
23:56:52 <Cale> Something like data Zero = Zero; data Succ a = Succ a; class Nat a; instance Nat Zero; instance (Nat n) => Nat (Succ n)
23:57:16 <Cale> and then you can define addition in the usual recursive prolog-esque way
23:58:33 <Cale> and probably end up using some undecidable instances while you're at it :)
23:58:56 <Botty> heh, yeah, would be a mess.
