00:17:03 <paolino> mmhh, how is haskell related to microsoft ?l 
00:17:24 <edwardk> simonpj et al.
00:19:29 <paolino> will it remains open source ?
00:20:27 <Muad_Dib> paolino: ehm, the compilers you mean?
00:24:57 <dblhelix> @pl (\a -> t (l a, a))
00:24:57 <lambdabot> t . ((,) =<< l)
00:30:48 <dons> yes, some of the researchers are paid to do research by microsoft, but all haskell compilers are open sourced, as are the libraries, and will remain forever as such
00:33:31 <vegai> dons: if a title contains an url, might there be an endless loop of url-title?
00:33:37 <vegai> ...in lambdabot
00:34:19 <vegai> or will she only do url-title on herself after @google?
00:34:39 <dons> she'll ignore herself
00:35:05 <vegai> ok.
00:35:09 <dons> http://google.com/search?q=http://www.google.com
00:35:10 <lambdabot> Title: http://www.google.com - Google Search
00:38:47 <dblhelix> @type (=<<) . flip
00:38:48 <lambdabot> forall a a1 c. (a1 -> a -> c) -> (a1 -> a) -> a1 -> c
00:39:26 <dblhelix> and there it is...
01:00:49 <dons> ?yow
01:00:50 <lambdabot> DIDI ... is that a MARTIAN name, or, are we in ISRAEL?
01:43:07 <u221e> What is the difference between the -O3 and -O2 optimization args?
01:44:20 <skew> try -vvvv  or so
01:45:22 <dons> i'm sure -O3 does anything
01:45:30 <dons>  /not sure/
01:45:55 <u221e> When you benched my code you used -O2 right?
01:46:59 <dblhelix> i did not even know that there was an -O3 option...
01:47:22 <dons> yep
01:47:34 <mnislaih> Lemmih: there ?
01:48:12 <u221e> Hm, I used -O3... I wonder if there is any difference.
01:48:28 <vegai> u22ie: according to manual, no.
01:49:17 <u221e> Heh, is it reserved for future use or something?
01:49:29 <vegai> -O3 might be the same as -O0 or -O, I suppose. Or just -O2
01:49:38 <vegai> they're mimicing gcc in that, I suppose.
01:49:40 <xerox> mnislaih - Howdy! How's your SoC work doing?
01:49:55 <dons> if -O is greater than 2, you get -optc-O2 set, that's one thing
01:50:12 <mnislaih> xerox: great. I am working in dynamic breakpoints right now
01:50:29 <u221e> I already have -optc-03 set ;P
01:50:35 <mnislaih> if only I could get a hold of Lemmih
01:50:47 <mnislaih> how is yours xerox  ?
01:51:18 <u221e> Oh the language shootout site is back up. Might as well submit my entry now
01:51:22 <xerox> I am starting :-)
01:52:04 <xerox> mnislaih - The Ghci/Debugger wikipage is impressive. Did you do work on these things before SoC ?
01:52:27 <mnislaih> not at all. I have just met ghc
01:52:44 <xerox> ?karma+ mnislaih 
01:52:44 <lambdabot> mnislaih's karma raised to 1.
01:53:01 <mnislaih> but I've benefited from my mentors a lot
01:53:15 <xerox> That's what the program is for (-:
01:53:53 <xerox> Your repository doesn't show up in http://darcs.haskell.org/darcsweb/ does it?
01:53:55 <lambdabot> Title: darcs - Repositories
01:53:58 <dons> yep,  go for it u221e. 
01:54:12 <mnislaih> does any of the SoC repositories show up ?
01:54:13 <dons> then you can look at the performance list simon posted a few days ago, and start from the bottom :)
01:55:45 <u221e> Hm... what should I put in the detailed description.
01:56:08 <dons> explain that it simplifies and improves the old entry?
01:56:16 <dons> here's our current performance list, http://www.haskell.org/pipermail/haskell-cafe/2006-July/016562.html
01:56:17 <lambdabot> Title: [Haskell-cafe] Re: Haskell performance in heavy numerical computations
01:56:30 <dons> so we've fixed mandelbrot (any idea how it compares to C now?)
01:56:48 <dons> anything of 2x C could be improved.
01:56:48 <u221e> Oh good idea.
01:56:52 <dons> /of/over
01:57:21 <dons> so we've got 7 faster than C now, and 11 slower
01:57:26 <dons> yay :)
01:58:12 <dons> i think before we actually went and did this, many wouldn't believe we'd ever get to 1:1 with C on any program
01:58:22 <dons> it was just rumour ;)
01:58:59 <u221e> Think I should register with Alioth after it's compromise? ;)
01:59:07 <dons> heh
02:00:58 <u221e> Does registering allow you to do anything special?
02:01:23 <dons> i think it just means you don't appear as "anonymous" when you submit, which is a good thing. gives you more credibility
02:02:13 <u221e> Oh, I almost forgot to add my command line args to the top of the file.
02:03:10 <dons> one thing, if they're the same as the current defaults, no need.
02:03:19 <dons> but in this case i think you need -fexcess-precision
02:03:30 <dons> so better add that, check that it works, then submit
02:03:45 <dons> but you won't need all the others, since we get -optc-* and -O2 by default now
02:03:59 <u221e> Oh ok
02:04:32 <u221e> And -fglasgow-exts I assume?
02:05:46 <dons> yep, just have a look at our current flags to get an idea
02:06:32 <dons> e.g. here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=pidigits&lang=ghc&id=0
02:06:34 <lambdabot> Title: pidigits Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ...
02:06:38 <dons> we have: -O3 -optc-O3 -fglasgow-exts
02:07:01 <dons> so you might want -funbox-strict-fields, or -optc-ffast-math, -fexcess-precision yadda yadda
02:07:06 <xerox> ...ooof.
02:09:16 <u221e> Hm..
02:09:29 <u221e> GHC just gave me an error
02:09:33 <dons> yeah?
02:09:41 <dons> can't put -fexcess-precision in a pragma?
02:09:48 * dons guesses
02:09:50 <u221e> Seems not
02:10:09 <dons> ok, so you better say 'Must be compiled with: .... insert flags here' when you submit
02:10:17 <dons> to make sure they tweak their makefile too
02:10:30 <dons> its possible it will just inherit the current mandelbrot flags
02:15:13 <u221e> I don't thing -funbox-strict-fields does anything
02:15:37 <dons> ok, it may not.
02:44:57 <u221e> Wow, why is haskell so bad on k-nucleotide?
02:46:38 <dons> is it a big io benchmark? or regexes ? (/me can't remember)
02:47:24 <dons> oh, it needs a mutable hash?
02:47:45 <dons> i think it might be the combination of io and mutable hash tables, iirc
02:50:08 <dcoutts> dons, ah yes, what are we going to do about bytestring regexes, if/when we eventually get round to that? (after our current paper deadline)
02:50:35 <dcoutts> I was looking at suitable C libs, and they're few and far between
02:52:55 <dons> well, i'm not sure we can use anything in C :/
02:53:09 <dons> certainly not regex.h
02:53:18 <dcoutts> there's libpcre
02:53:27 <dons> and there's whatever tcl uses
02:53:44 <dcoutts> but I think it's not really suitable for lazy bytestreams
02:54:02 <dons> no, i'm not sure what to do there y
02:54:03 <dons> et
02:54:28 <dcoutts> I assumed there must be some regex lib that works on streams
02:54:31 <dcoutts> ie in chunks
02:54:38 <dcoutts> but I couldn't find it
02:56:45 <dcoutts> dons, btw, yesterday I was hacking on the last non-streams fusion system
02:57:08 <dons> ah, yes? what are you looking at?
02:57:33 <dcoutts> the version that doesn't do the wrapper elimination first
02:57:41 <dons> oh also, bulat's sent me 3 or 4 comments/pseudo-patches, so i'm trying to get him to use darcs
02:57:57 <dcoutts> oh yes, patches to do what?
02:57:58 <dons> he spotted a window's bug, and an inefficiency, so that's good
02:58:14 <dons> useAsCStringLen was O(n) for no good reason
02:58:22 <dcoutts> I was thinking an easier way to compare & benchmark would be to have a module for each fusion system and have them export, map, filter, fold etc
02:58:40 <dcoutts> rather than us having lots of #ifdefs in the bytestring module
02:59:15 <dcoutts> it's not how I'd organise the code ultimately, but it'd make swaping fusion systems easier
02:59:26 <dcoutts> which would make our benchmarking easier
03:00:25 <dcoutts> the extra difficulty of yet another fusion module would be negligable, rather than having to modify the ByteString module yet again
03:02:11 <dons> yeah, that's a reasonable plan while we're preparing the paper
03:02:29 <dons> it will probably be a good idea to use a fork for all these games, until the papers done and settled
03:03:11 <u221e> What are you writing a paper about?
03:04:09 <dcoutts> Data.ByteString
03:04:40 <dcoutts> and in particular how nice and fast it is and how we can do loop fusion with it for even greater performance
03:05:07 <dcoutts> dons, want to make a fork ?
03:05:08 <JKnecht> anybody know where a copy of newburns "all about monads" is (site is offline)
03:06:16 <dons> dcoutts: yep, will do so now
03:06:26 <dcoutts> ok
03:06:32 <u221e> So I assume all the shootout prgrams will be rewritten after GHC 6.6
03:07:09 <dons> no, only the 3 or 4 that need IO, i suppose.
03:07:14 <dons> well, we'd do those first
03:07:56 <dons> dcoutts: darcs get http://www.cse.unsw.edu.au/~dons/code/fps-unstable
03:07:56 <lambdabot> Title: Index of /~dons/code/fps-unstable
03:10:17 <dcoutts> dons, ok, ta
03:10:50 <dcoutts> 702 patches eh? quite a few
03:11:40 <u221e> Wow, I'm reading these new reviews of the Conroe Core Duo 2... amazing.
03:11:46 <dons> busy busy
03:13:13 <shemale_magic> does haskel work one windows?
03:13:30 <dcoutts> shemale_magic, yes, there's ghc and hugs
03:13:45 <JKnecht> did get (not sure from where)
03:15:11 <dcoutts> dons, we could just pinch the tcl regex lib if it's the fastest, it's just a few BSD licensed .c files
03:18:18 <shemale_magic> so hey boys
03:18:30 <shemale_magic> what makes haskell more fun than say clisp?
03:18:55 <shemale_magic> how does haskell compare to j2ee?
03:19:00 <psnl> teh type magic
03:19:23 <xerox> Those comparations are non-Diophantine.
03:20:37 <dons> dcoutts: yep, maybe
03:20:44 * dons -> dinner
03:20:53 <dcoutts> dons, it's based on Henry Spencer's regexp lib
03:24:58 <adept___> @seen adept
03:24:58 <lambdabot> I saw adept leaving #haskell-overflow 11 hours, 14 minutes and 44 seconds ago, and .
03:28:41 <psnl> xerox: non-Diophantine. what do you mean by this?
03:30:23 <xerox> psnl - Different kinds of arithmetics.
03:31:06 <xerox> (Those such as it is possible that 2+2 is not equal to 4, and more.)
03:31:31 <psnl> ah, cool
03:32:04 <xerox> I have found this article interesting <http://arxiv.org/abs/math.GM/0108149>.
04:46:03 <erider> hello all 
04:46:34 <roconnor> xerox: seems like a silly article
04:49:23 <roconnor> what a bunch of nonsenze
04:49:32 <roconnor> s/z/s/
04:51:06 <xerox> I like the idea of alternative arithmetics as much as I like the idea of non-Euclidian geometries. I have to finish reading the article, anyway.
04:54:00 <roconnor> sure, but aren't they already called groups.
05:01:57 <xerox> Groups, you say..
05:02:41 <NotInventedHere> non-Diophantine arithmetic == bistromathics
05:03:12 <roconnor> well, I didn't read the article carefully
05:03:14 <roconnor> I'm not sure
05:04:09 <roconnor> or how about semi-groups if you really want little structure.
05:05:02 <xerox> Is that just fiction?
05:05:18 <roconnor> is what fiction?
05:05:25 <xerox> Bistromathics.
05:05:51 <NotInventedHere> yes ;-) it's from Hitchiker's Guide To the Galaxy
05:06:01 <NotInventedHere> sorry; wasn't being serious ;-)
05:06:08 <roconnor> @djinn (a -> b -> c) -> (c -> d) -> a -> b -> d
05:06:08 <lambdabot> f a b c d = b (a c d)
05:06:15 <NotInventedHere> haven't read the article either
05:06:33 <roconnor> @. pl djinn (a -> b -> c) -> (c -> d) -> a -> b -> d
05:06:34 <lambdabot> f = flip ((.) . (.))
05:06:36 <xerox> (-:
05:06:57 <roconnor> ah
05:07:09 <roconnor> @. pl djinn (c->d) -> (a -> b -> c) -> a -> b -> d
05:07:09 <lambdabot> f = (.) . (.)
05:07:17 <NotInventedHere> it comes from "the mathematics that occurs in a bistro"
05:07:21 <roconnor> @. pl djinn (c->d) -> (a -> b -> z -> c) -> a -> b -> z -> d
05:07:22 <lambdabot> f = (.) . (.) . (.)
05:07:29 <roconnor> I sense a pattern
05:07:31 <NotInventedHere> when they charge you, that is
05:07:52 <xerox> Yeah.
05:08:11 <xerox> roconnor - The number of (.) composed is equal to the arity of the function composed to the unary function.
05:08:28 <xerox> If you scrap #haskell logs it comes from back in time %)
05:10:22 <roconnor> They are imporant functions
05:10:35 <roconnor> important
05:10:46 <xerox> roconnor - By the way, the idea of checking what different arithmetics bring up seems sensible, doesn't it?
05:11:46 <roconnor> I'm tempted to say no.  But I suppose I will have to justify myself.
05:12:02 <xerox> No worries. I am not being formal myself, just wondering.
05:13:54 <roconnor> The natural numbers, defined in terms of 0, sucessor, and primitive recursion, is the natural, and the simplest infinite type.
05:14:24 <roconnor> the only thing more fundamental, that comes to mind, are bool, () and Empty.
05:14:45 <roconnor> oh, and a bunch of other complicated foundational notions, like ->
05:15:47 <xerox> That's more or less like the prelude to what I am reading about these days.
05:16:20 <roconnor> :)
05:16:36 <xerox> The Hilbert's program & the problems deriving from foundational theories have interesting outcomes.
05:16:54 <roconnor> this structure of natural number with recursion gives rise to the turning machine and computation.
05:17:06 <roconnor> (along with the other foundation stuff like ->)
05:17:15 <Philippa> roconnor: there's the malformed version without a zero, and the type of streams is equivalently fundamental IMO
05:17:21 <Philippa> (you swap a | for a *)
05:17:47 <xerox> For me it worked like this: wanted to study analysis for school, I came to ask myself some `why?'s whose answers seem to be in number theory, again the `why?'s there seemed to be answered by foundations, arithmetics seem very very close to the discipline containing its own answers :-)
05:18:01 <roconnor> dropping the 0 yields an isomorphic structure, so it is the same.
05:18:03 <xerox> (This is just my experience so far, I might be wrong, and I sure want to understand.)
05:18:21 <roconnor> streams are like natural numbers, only polymorphic, so the are in a sense more complicated.
05:18:43 <xerox> Philippa - What does it mean to `swap a | for a *' ?
05:18:45 <Philippa> only if you insist it be a polymorphic stream
05:19:30 <Philippa> xerox: the structure of the naturals is "Zero OR the Successor of a Nat". A "stream of zeros" type can be built as "Zero AND the Successor of this Stream"
05:19:34 <roconnor> even if the streams are not polymoric, the cons constructor takes one more parameter than the S constructor.
05:20:09 <roconnor> oh wait, right streams are co-inductive.
05:20:54 <roconnor> yes, I might agree with you, I'd have to think about it.
05:20:56 <xerox> We need @coq ;-)
05:21:17 <Philippa> if you want a stream of anything useful I'd have to agree with you, FWIW
05:21:44 <Philippa> I need to learn how to use Coq sometime
05:22:00 <xerox> Let's make a Coq study group at AngloHaskell
05:22:10 <xerox> Bringing roconnor to teach us (-:
05:22:19 <roconnor> heh, I wanted to go
05:22:28 <Philippa> given the intention of beer I suspect that'd devolve into bad punning
05:22:33 <roconnor> but I think I will be traveling in Germany at the time.
05:22:48 * xerox laughs
05:22:59 <roconnor> I'm sure someone can teach you Epigram
05:23:00 <xerox> Well, I don't drink... I'll need a laptop.
05:23:50 <Philippa> true, they're only up the road
05:27:17 <roconnor> do tell anyone I said this, but it maybe the case that Epigram is better than Coq.  sssssshhh.
05:28:08 * xerox falls over the chair
05:28:12 * boegel thinks cock is superior to anything else
05:28:17 <boegel> erm
05:28:18 <boegel> nvm
05:28:20 <boegel> :)
05:28:33 <Philippa> boegel: other chan :-)
05:30:04 <xerox> roconnor - What also makes me wonder about this non-Diophantine arithemtics is all the bibliography the author intersperses in the text.
05:31:20 <roconnor> After skimming I got the impression it was not a mathematical paper, so I dropped it.
05:31:30 <roconnor> I assumed it was philosophy
05:31:32 <xerox> Sensible :-P
05:31:39 * roconnor doesn't like most philosophy
05:32:15 * roconnor figured out his map / ap problem.
05:34:33 <Philippa> I'm playing with a philosopher. We don't spend too much time discussing philosophy though
05:34:50 <xerox> What are you playing?
05:34:56 <Philippa> xerox: you misunderstand :-)
05:35:09 <xerox> Words...
05:35:27 <xerox> (Since you are into games, I thought of some kind of computer game, sorry.)
05:35:45 <Philippa> yeah, I'd've said which game though
05:36:05 <Philippa> not a problem, anyway. PMed you the details, I figure the rest of the chan can go without the inevitable derailing...
05:37:21 <roconnor> I like the philosophers I've met.
05:37:59 <xerox> I don't like _all_ the philosophers I've met, but nothing awful to say about any of them.
05:38:11 <ndm> i hate the philosophers they met, they all confused me way too much
05:38:20 <ndm> * thye -> i've
05:38:31 <ndm> * thye -> they, in the replacement
05:38:33 <roconnor> ndm: good point.
05:38:40 <Philippa> I've met some who need to be aware of when they're pushing emotional buttons in an argument because they treat all of them like philosophical debate. That's a bit annoying
05:39:03 <xerox> Confusion is good.
05:39:17 <ndm> i met one who sent me a 6 page letter of pure confusion, and finished with the line "I hope you understand"
05:39:30 <ndm> to this day I still have no idea what point she was making
05:40:03 * Pupeno never meet a so called philopher.
05:40:03 <lambdabot> Pupeno: You have 1 new message. '/msg lambdabot @messages' to read it.
05:40:46 <Pupeno> That message was almost two mothes old.
05:43:45 <xerox> Do message come with a date?
05:44:09 <ValarQ> lets see
05:44:17 <ValarQ> @message ValarQ foo
05:44:17 <lambdabot> Maybe you meant: messages messages?
05:44:21 <ValarQ> er
05:44:25 <ValarQ> @tell ValarQ foo
05:44:25 <lambdabot> You can tell yourself!
05:44:45 <ndm> @tell ValarQ foo
05:44:46 <lambdabot> Consider it noted.
05:44:57 <ValarQ> @messages
05:44:57 <lambdabot> ndm said 11 seconds ago: foo
05:44:57 <erider> haskell iis not a dynamically typed language?
05:45:07 <ndm> erider: no, its not
05:45:09 <ValarQ> not a date
05:45:16 <ndm> its statically typed
05:45:31 <ndm> it say that when its 11 seconds ago, its possible the code flips to using a date after a certain time period
05:45:37 <ndm> lambdabot is quite clever :)
05:45:38 <roconnor> erider: thank god it isn't!
05:45:58 <roconnor> now our complier can actually catch bugs
05:46:05 <dons> erider: benefit, we find out our type errors at compile time
05:46:09 <erider> hmm that seems to bring all sorts of unnecessary overhead
05:46:22 <roconnor> actually it reduces overhead
05:46:23 <ndm> erider: in practice, no, because of type inference
05:46:27 <dons> no, its cheaper, since you don't have to do any dynamic checking
05:46:44 * roconnor always wants more static type checking!
05:46:46 <erider> so there is not coersion 
05:46:47 <ndm> erider: are you talking runtime overhead, or programmer overhead?
05:46:56 <dons> part of the reason statically typed languages outperform all dynamically typed languages on the great lang. shootout
05:47:15 <roconnor> yes, (perhaps sadly) there is no coersions
05:47:17 <erider> programmer overhead 
05:47:26 <ndm> @hoogle coerce
05:47:27 <lambdabot> No matches found
05:47:30 <dons> erider: how?
05:47:32 <ndm> @hoogle cast
05:47:33 <lambdabot> Data.Typeable.cast :: (Typeable a, Typeable b) => a -> Maybe b
05:47:33 <lambdabot> Foreign.ForeignPtr.castForeignPtr :: ForeignPtr a -> ForeignPtr b
05:47:33 <lambdabot> Foreign.Ptr.castFunPtr :: FunPtr a -> FunPtr b
05:47:45 <ndm> roconnor: i think there is unsafeCoerce
05:47:59 <erider> because now you have to worry about types and indentations and capitalizations
05:48:04 <dons> ?
05:48:05 <ndm> and the new Yhc Dynamic module can certainly do it
05:48:13 <roconnor> ndm: I think by coercions he means automaticly inserting (fromIntegral)s
05:48:15 <Philippa> you should always be worrying about types anyway
05:48:16 <dons> indentations, capitalisations??
05:48:26 <roconnor> and the like
05:48:41 <dons> anyway, you just have to solve your bugs before you run the code, rather than after. its the wave of the future ;)
05:48:55 <erider> coersion is when the object get an type at runtime 
05:49:22 <ndm> erider: because the type of everything is static, it doesn't actually have a type at runtime
05:49:36 <erider> so if you had "3" + 3 it would be 6 even though it is a string 
05:49:44 <Philippa> coercions are used to say statically "this thing here is now to be considered to have this type"
05:49:45 <ndm> for example, in Lisp an integer says both "I am an integer", "I have the value 42"
05:49:49 <roconnor> erider: Haskell has union types, which solves many problems that you might be worried about
05:49:55 <ndm> in Haskell there is no runtime notion of "I am an integer"
05:49:59 <Philippa> there might be a runtime check associated with it to make sure the coercion's valid
05:50:07 <ndm> erider: in haskell thats a compile time error
05:50:13 <Philippa> (but not in Haskell)
05:50:39 <dons> if you look at the type of +,
05:50:41 <dons> ?type (+)
05:50:42 <lambdabot> forall a. (Num a) => a -> a -> a
05:50:48 <dons> you see that its arguments have to be the same type
05:50:57 <erider> I have some concerns with the amount of code I have to write to get to an end
05:51:04 <dons> rather than relying on unspecified runtime failure/magic
05:51:12 <roconnor> ah right, Haskell also has type classes, which solves the other half of the problems you are worried about.
05:51:19 <dons> erider: well, in practice you write less code in haskell than any mainstream language
05:51:28 <dons> check here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
05:51:36 <erider> hmm I wouldn't say that 
05:51:44 <erider> lisp is quite short 
05:51:46 <dons> sure, but we have empirical data
05:51:57 <Philippa> haskell often compares reasonably to lisp
05:51:58 <mauke> erider: lisp doesn't allow (+ "3" 3)
05:52:11 <erider> I know
05:52:25 <erider> but I was explaining coersion 
05:52:26 <Philippa> it's very rare you need to specify the type of a value in Haskell
05:52:26 <ndm> how come when I say GZip bytes to 1, everything else to 0, haskell comes near the bottom of the pile?
05:52:33 <roconnor> > (read "3") + 3
05:52:34 <lambdabot>  6
05:52:44 <Philippa> you do need to declare which types are available to a program, but you see that in various forms in lisp code too
05:52:46 <dons> ndm, gzip is biased against semantically rich langs
05:53:00 <roconnor> erider: so a coecion would be automatic insertion of the read function
05:53:02 <dons> ndm, if you look at the debian page, http://shootout.alioth.debian.org/debian/
05:53:03 <lambdabot> Title: Debian : AMD&#8482; Sempron&#8482; Computer Language Shootout
05:53:07 <dons> we've just lost the loc lead to perl
05:53:09 <dons> sometime this week
05:53:19 <ndm> fair enough, it does however suggest that haskell is more verbose than most things
05:53:25 <Philippa> they submitted some line noise?
05:53:31 <ndm> dons, is that because they have been line cramming?
05:53:36 <dons> ndm, check here http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=all
05:53:40 <dons> maybe
05:53:45 <dons> we'll get the lead back in 6.6 though
05:53:47 <dcoutts> dons, that's probably because several of ouroptimised progs are quite verbose
05:53:52 <dons> right
05:53:57 <dcoutts> since we went for speed rather than one-liners
05:53:59 <erider> ok like at this to get an argument for a commandline: module Main where
05:53:59 <erider> import System.Environment
05:53:59 <erider> main :: IO ()
05:53:59 <erider> main = do  args <- getArgs 
05:53:59 <erider>                    putStrLn ( args !! 0 +  args !! 1)
05:54:10 <dons> ok, the first line is not needed
05:54:13 <dons> the 3rd line isn't eithre
05:54:25 <mauke> I don't like the indentation style
05:54:48 <ndm> erider: i do find the getArgs thing annoying, but thats pretty much my one complaint
05:54:48 <xerox> main = do
05:54:49 <xerox>   ..
05:54:53 <ndm> everything else is shorter
05:54:57 <erider> now if I wanted to get two numbers I would have to do all kinds of crazy stuff just to add them and produce an output
05:55:07 <dcoutts> we should work on lib & ghc optimisations to make the one liners as fast as the optimised versions :-)
05:55:16 <dons> i'd write the code as: main = do x <- getArgs ; putStrLn $ (read . head $ x) + (read (args !! 1)) -- roughly
05:55:20 <dcoutts> ByteString will help that, our one liners are pretty quick
05:55:34 <Philippa> you mean you'd have to use read a couple of times and then "print (a+b)" as the last line
05:55:39 <dons> erider: nothing crazy. you just use 'read' to turn a String to an Integer
05:55:40 <mauke> erider: main = getArgs >>= \args -> print (read (args !! 0) + read (args !! 1))
05:55:44 <mauke> erider: complete program
05:55:46 <ndm> main = do (a:b:_) <- getArgs; putStrLn $ read a + read b
05:55:47 <dons> that'd do
05:55:57 <dons> ?pl \a -> read a + read b
05:55:58 <lambdabot> (read b +) . read
05:56:10 <ndm> no need for the !! twice, when you're taking the first two elements
05:56:15 <dons> ?pl read a + read b
05:56:16 <lambdabot> read a + read b
05:56:36 <xerox> dons ?!
05:56:37 <Igloo> print, not putStrLn
05:56:39 <dons> sum (map read (take 2 args)) -- perhaps?
05:56:43 <erider> seems like a lot to create a simple program such at that one 
05:56:57 <dons> getArgs >>= print . sum . map read . take 2
05:57:03 <erider> take to commandline arguments and add them 
05:57:06 <dons> lot of work?
05:57:12 <erider> that is pretty simple
05:57:17 <Philippa> it's barely any quicker in most other languages, except insofar as they do the getArgs bit for free
05:57:25 <erider> s/to/two
05:57:27 <mauke> erider: you get the arguments, convert them to numbers, add them, print them. I don't think it's too much work.
05:58:00 <dcoutts> dons, I prefer putting it the other way around: print . sum . map read . take 2 =<< getArgs
05:58:02 <erider> they is what I'm saying I have to convert them 
05:58:02 <Philippa> also, you're looking at the low end of things. Haskell scales well into more involved tasks
05:58:06 <dcoutts> so you get a consistent order
05:58:18 <dons> erider: 'map read' is a small price to pay for static typing
05:58:25 <Philippa> yes, you do. Just like in any sane language - perl'd do it for free, but perl isn't sane
05:58:41 <Philippa> a string *is not an integer in any way shape or form*. You still have to convert in lisp, too
05:58:52 <erider> maybe I'm a lazy programmer and possible due to some scripts languages I have used but I don't want to convert anything 
05:59:08 <dons> shrug
05:59:10 <Philippa> yes, it's because you're used to scripting languages
05:59:13 <mauke> erider: what languages don't need an explicit conversion there?
05:59:22 <Ulfalizer> i think it's a matter of language focus. perl is mainly for hacking together a script quickly to get things done.
05:59:31 <xerox> > (. read) . ((+) . read) "2" "3" :: Int
05:59:32 <lambdabot>  Couldn't match `a1 -> a -> c' against `[Char]'
05:59:33 <Philippa> mauke: perl, a bunch more with a similar attitude
05:59:36 <xerox> Aww.
05:59:44 <NotInventedHere> I agree - I come from C++ background, so casting is perfectly normal
06:00:00 <xerox> :t (. read) . ((+) . read)
06:00:01 <mauke> NotInventedHere: casting? normal?! you're fired.
06:00:04 <xerox> ?type (. read) . ((+) . read)
06:00:06 <lambdabot> forall a. (Num a, Read a) => String -> String -> a
06:00:16 <xerox> Seems alright.
06:00:25 <xerox> > (. read) . ((+) . read) $ "2" "3" :: Int
06:00:25 <lambdabot>    The function `"2"' is applied to one arguments,
06:00:25 <lambdabot>   but its type `[Char]...
06:00:30 <dons> regarding verbosity, does anyone have examples from other languages where the entire program is shorter than: main = print . sum . map read . take 2 =<< getArgs -- ?
06:00:31 <NotInventedHere> mauke: well type conversion!
06:00:31 <erider> there is not a covert process that need to be done if I want integers then that is what I'm going to get and print I don't have to convert them later to print them 
06:00:38 <xerox> > ((. read) . ((+) . read)) "2" "3" :: Int
06:00:39 <lambdabot>  5
06:00:43 <xerox> Ah-ha!
06:00:49 <xerox> Do you believe I derived it manually?
06:00:52 <dons> hehe
06:01:01 <dcoutts> dons, it'd probably be shorter in bash
06:01:02 <xerox> I can show you.
06:01:33 <dons> perhaps, expr $1 + $2, I suppose.
06:01:36 <dcoutts> dons, because of $1 positional params and builtin str -> int conversions and arathmitic
06:01:38 <mauke> dons: print shift+shift,"\n"
06:01:40 <dons> if youre args are in scope already, it helps
06:02:09 <erider> well I'm sorry guys for wasting your time I'm going to continue to look at this book and try to get thru it. I know that has to be a trade off some where 
06:02:10 <dons> how about python? or ruby?
06:02:43 <xerox> \a b -> read a + read b = \a b -> (+) (read a) (read b) = \a -> (+) (read a) . read = \a -> (. read) ((+) (read a)) = (. read) . ((+) . read)
06:02:45 <erider> but I had to ask and vent alittle 
06:02:51 <dons> apparently
06:03:00 <NotInventedHere> python: print sys.argv[0] + sys.argv[1]
06:03:19 <dons> still, optimising for the length of 20 char programs isn't a priority
06:03:19 <NotInventedHere> actually -- bollocks, that will add the strings
06:03:36 * roconnor thinks Haskell isn't as good at string manipulations as REXX is.
06:03:45 <xerox> What is REXX?
06:03:48 <Ulfalizer> can't you do something like "print (sum sys.argv[1:2])" in python?
06:03:51 <Philippa> yeah. It's been commented that you have to be insane to write a Haskell program >100 lines - because what do you need that many lines for?
06:03:52 <NotInventedHere> python: print int(sys.argv[0]) + int(sys.argv[1])
06:03:53 <Ulfalizer> been a while since i've done it :/
06:04:03 <triple_> python: print sum(map(int, sys.argv))
06:04:04 <dons> ah , conversions! oh no!
06:04:13 <roconnor> @google REXX
06:04:19 <lambdabot> http://www2.hursley.ibm.com/rexx/
06:04:32 <roconnor> http://www2.hursley.ibm.com/rexx/
06:04:33 <dons> oh, well if we assume there are only 2 args
06:04:34 <Ulfalizer> ah, python doesn't do implicit conversion..
06:04:36 <erider> roconnor, go with oorexx 
06:04:36 <xerox> Sounds creepingly like Reg-Exp.
06:04:42 <Philippa> roconnor: sooner or later, DSLs can always be slightly neater than EDSLs. It's impressive just how good Haskell is once you grab good libs for parsing, pretty-printing etc
06:05:01 <mauke> use List::Util"sum";print sum(@ARGV),"\n"
06:05:03 <dons> main=print.sum.map read=<<getArgs
06:05:10 * Ulfalizer needs to learn parsec
06:05:11 <erider> @google oorexx
06:05:13 <lambdabot> http://www.oorexx.org/
06:05:13 <lambdabot> Title: Open Object Rexx - About
06:05:22 <mauke> "\n" can be shortened to $/
06:05:37 <NotInventedHere> dons: how is int(of_some_string) in python differnet from "read some_string" in haskell?
06:05:46 <dons> it's not, is it?
06:05:52 <mauke> read is smarter
06:05:54 <erider> roconnor, that is the one you should look at and its backward compatible
06:05:55 <Philippa> the call to read itself doesn't specify the type you want
06:06:07 <NotInventedHere> so why did you say "conversions, oh no!"?
06:06:08 <Philippa> and occasionally you need an annotation because nothing tells it
06:06:09 <roconnor> erider: :)
06:06:22 <dons> erider was complaining about having to convert. some people said you need to in most general-purpose/in-the-large languages
06:06:26 <NotInventedHere> Philippa, that's true, and I agree it's very elegant
06:06:29 <dons> most/all?
06:06:46 <roconnor> Coq has coercions, and it is also statically typed.
06:06:52 <dons> hehe
06:06:59 <dons> ok, so does twelf and isabelle
06:07:14 <dons> roconnor: oh you mean _implicit_ ones?
06:07:18 <roconnor> yes
06:07:21 <dons> huh
06:07:29 <erider> dons, I'm sorry but it is hard to start to learn a new language when you have gotten use to another
06:07:37 * dons ponders a theorem prover that does that kind of thing for you
06:07:40 <mauke> erider: what languages do you know?
06:07:45 <erider> I wasn't putting haskell down in anyway 
06:08:29 <Philippa> erider: it gets easier over time, though Haskell's often a big leap in one way or another from other langs
06:08:36 <dons> keep an open mind, there's many many new concepts in haskell to learn, so you want to be prepared to reconsider ingrained ideas
06:08:49 <roconnor> dons: the implicit coersion are used extensively in the CoRN project, to convert a ring into a group in order to apply the group operations, etc.
06:09:03 <dons> huh, that's really interesting
06:09:29 <roconnor> The output becomes a nightmare when you tell it to print all the coercions.
06:09:51 <Ulfalizer> erider: once you've gotten used to learning new languages, it's usually a lot more painless to learn new a new language and refresh a language you once knew
06:09:59 <erider> C but I don't use it because it take to long to be productive, perl, some assembly for debugging reasons lua lisp hmm and I have some basic knowledge of some others eg. rexx 
06:10:03 <Ulfalizer> -new
06:10:42 <roconnor> Ulfalizer: Ah, but once you learn Haskell there's no going back ;)
06:10:49 <mauke> isn't perl the only language in that list that does implicit number<->string conversions?
06:10:51 <Ulfalizer> erider: pure functional programming is pretty different from all of those
06:10:51 <roconnor> only going forwards ... to Epigram.
06:11:01 <Ulfalizer> roconnor: i doubt haskell will be the last language i learn :)
06:11:09 <erider> Its not that I'm having a problem learning it just takes awhile to get use to doing things that I haven't be doing
06:11:27 <dons> so you've not done much with strongly statically typed langs at all then, not even, say java or C++
06:11:29 <mauke> you could have a look at sml/ocaml first, but I don't know sml and ocaml's syntax is pretty ugly
06:11:45 <dons> so that's two new things, static typing and learning a declarative lang
06:12:02 <dons> so its a bit of a shift, erider. expect surprises
06:12:10 <dons> oh, you've got lisp already
06:12:15 <dons> so its more the static typing.
06:12:19 <erider> no I have use java due to it being a memory monster 
06:12:26 <erider> no I haven't use java due to it being a memory monster 
06:12:30 <Ulfalizer> i think i will have a look at smalltalk next. might solidify many oop concepts for me.
06:12:38 <NotInventedHere> erider: java is not a memory monster
06:12:48 <erider> yes it is 
06:13:01 <dons> hehe. deja vu
06:13:02 <xerox> ?type (. (. (*))) . (+)
06:13:03 <lambdabot> forall a c. (Num a, Num (a -> c)) => (a -> c) -> ((a -> a) -> c) -> a -> c
06:13:03 <NotInventedHere> well it depends on what you do, but for most uses, it's not
06:13:12 <erider> have you downloaded java lately
06:13:13 <SamB> well, Sun's implementation can be ;-)
06:13:29 <xerox> ?type \a -> (((+ a) .) . (*)
06:13:30 <lambdabot> parse error (possibly incorrect indentation)
06:13:35 <xerox> ?type \a -> ((+ a) .) . (*)
06:13:36 <lambdabot> forall a. (Num a) => a -> a -> a -> a
06:13:39 <SamB> it isn't so bad if you run CLI programs compiled with GCJ
06:13:54 <dons> xerox: maybe there's an fmap in (-> r) monad to be had ?
06:13:59 <dons> maybe
06:13:59 <xerox> ?type (. (. (*)) . (+)
06:14:01 <lambdabot> parse error (possibly incorrect indentation)
06:14:07 <xerox> ?type (. (. (*))) . (+)
06:14:08 <lambdabot> forall a c. (Num a, Num (a -> c)) => (a -> c) -> ((a -> a) -> c) -> a -> c
06:14:13 * xerox growls.
06:14:15 <NotInventedHere> erider: I use java at work: we use sun jdk1.5
06:14:16 <Philippa> classically, the biggest problem with java apps was the GUI lib double-buffering /everything/, that chewed a lot of memory
06:14:17 <erider> it take java a good minute to launch a program on a 256mb ram computer and that is not good 
06:14:29 <xerox> dons - I think one can work out everything con (.), can't one?
06:14:39 <NotInventedHere> a minute???
06:14:52 <NotInventedHere> more like less than a second
06:14:52 <Philippa> I can see a minute easily if all that quarter gig's already full
06:15:02 <erider> well maybe you don't see it due to the computer speed at your job
06:15:03 <Philippa> swapfests on windows really stink
06:15:07 <NotInventedHere> yeah ok swapping
06:15:12 <xerox> dons - I am trying to points-free "\a b c -> a + (b * c)".
06:15:15 <SamB> is Linux any better?
06:15:19 <NotInventedHere> but any program will take that long if you're at that point
06:15:26 <Philippa> and if you're running 2K or XP it's really easy to have most of a quarter gig full on boot
06:15:26 <xerox> \a b c -> (+) a ((*) b c)
06:15:28 <SamB> not any program
06:15:28 <dons> NotInventedHere: interestingly, Java does have a 43s start up time on the language shootout too. i'm amazed
06:15:36 <xerox> \a b -> ((+) a) . ((*) b)
06:15:47 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=hello&lang=java&id=0
06:15:47 <lambdabot> Title: startup Java JDK -server program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Com ...
06:15:48 <xerox> \a -> (((+) a) .) . (*)
06:15:54 <xerox> And now I am stuch.
06:15:54 <NotInventedHere> dons: on what program?
06:15:56 <xerox> *stuck
06:15:56 <Philippa> it's sometimes the case that the JIT does stupid things too
06:15:58 <ValarQ> dons: must be wrong
06:16:04 <dons> despite having medium performance for most other things
06:16:09 <dons> yeah, seems unlikely
06:16:19 <NotInventedHere> I'm sorry: nobody would accept 43second startup!!!
06:16:25 <Philippa> *hah*
06:16:26 <NotInventedHere> java wouldn't be so popular
06:16:27 <SamB> heh
06:16:33 <SamB> it is popular?
06:16:35 <Philippa> sorry, but that's not true
06:16:44 <xerox> \a -> (.) (((+) a) .) (*)
06:16:52 <Philippa> SamB: IIRC it's overtaken COBOL for lines of source written. Sounds popular to me
06:16:53 <ndm> dons, thats for 200 startups i think
06:17:00 <dmhouse> xerox: Looks like fun.
06:17:00 <NotInventedHere> I think it's got the widest programming base (read it in some article -- but I wouldn't bet on that fact)
06:17:02 <xerox> \a -> (flip (.)) (*) (((+) a) .)
06:17:03 <ValarQ> well, java has a pretty long startup (not 43s thought)
06:17:03 <SamB> Philippa: I meant, still?
06:17:09 <ndm> 0.2154	 per startup
06:17:11 <xerox> This is something !
06:17:17 <dons> ah, ok.
06:17:19 <ndm> which i don't believe because thats too short
06:17:24 <Philippa> SamB: right now, "nobody"'ll get fired for picking Java
06:17:24 <ValarQ> i believe the idea is to have a java runtime running by the time you start your app
06:17:28 <xerox> \a -> (flip (.)) (*) ((.) ((+) a))
06:17:33 <SamB> haha
06:17:50 <Philippa> nobody in quotes because there're plenty of cases where it'd happen but they're niches
06:17:58 <dons> versus, say, http://shootout.alioth.debian.org/gp4/benchmark.php?test=hello&lang=ghc&id=0
06:17:59 <lambdabot> Title: startup Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ...
06:18:07 <dons> so i wonder, what is the jvm doing that the ghc rts doesn't?
06:18:10 <xerox> I think it is (flip (.)) (*) . ((.) . (+))
06:18:24 <dons> i mean, the rts is a mini-OS, so it's kind of a puzzle
06:18:24 <NotInventedHere> one thing for the java: it has a very complete standard library. in this regard it definitely beats haskell
06:18:25 <dmhouse> xerox: What did you start off with?
06:18:25 <xerox> > ((flip (.)) (*) . ((.) . (+))) 1 2 3
06:18:26 <lambdabot>  7
06:18:28 <Philippa> dons: potentially a lot of JITting
06:18:37 <dons> slow jitting.
06:18:44 <xerox> > (\a b c -> a + (b*c)) 1 2 3
06:18:45 <lambdabot>  7
06:18:48 * xerox bounces
06:18:52 <SamB> Philippa: ... there isn't that much to JIT for Hello, World! is there?
06:18:52 <dmhouse> Cool. :)
06:18:56 <xerox> I think I deserve an award for that reduction.
06:19:03 <dmhouse> @pl \a b c -> a + (b*c)
06:19:03 <lambdabot> (. (*)) . (.) . (+)
06:19:05 <SamB> it should do profile-based optimization ;-)
06:19:10 <dons> heh
06:19:15 <Philippa> it does these days, IIRC
06:19:25 * xerox takes it on lispy 
06:19:29 <xerox> Ops, lisppaste :)
06:20:14 <Philippa> also, I suspect by default the JVM's doing a lot more security-type work. It might be re-typechecking on load, too
06:20:25 <SamB> well than why does it waste time JITting when there is no profit in it?
06:20:37 <Philippa> because most of the time there is profit
06:20:37 <SamB> oh, well, in -server mode?
06:21:17 <SamB> but profile-driven stuff means waiting for code to have been used a few times before JITting it, doesn't it?
06:21:41 <Philippa> not necessarily. And you've still got a choice as to how much optimisation to do when you JIT/reJIT
06:22:03 <Philippa> a stupid first pass isn't necessarily much slower than interpreting directly
06:22:52 <xerox> > ((flip (.)) (*) . ((.) . (+))) 1 2 3
06:22:53 <lambdabot>  7
06:23:24 <dons> xerox reaches PointFree Hacker, Level 7
06:23:46 * xerox hops up and down furiously
06:23:49 <ValarQ> :)
06:23:50 <vegai> with or without the help of @pl? ;)
06:23:51 <xerox> Woo :D
06:24:00 <xerox> Without, maaan.
06:24:05 <ndm> I just did a code count on my PhD project in response to Philippa's earlier comment about > 100 lines is insane, its currently 21814 lines
06:24:12 <vegai> @karma+ xerox
06:24:12 <lambdabot> xerox's karma raised to 17.
06:25:04 <NotInventedHere> vegai: what's @pl?
06:25:16 <ndm> @help pl
06:25:16 <lambdabot> pointless <expr>. Play with pointfree code.
06:25:22 <xerox> lisppaste is dead?
06:25:24 <vegai> @pl (\a b c -> a + (b*c))
06:25:24 <lambdabot> (. (*)) . (.) . (+)
06:25:27 <NotInventedHere> ah thanks
06:25:41 <ValarQ> how come Haskell doesn't have a very good 'GZip bytes' score on the shootout?
06:25:47 <dons> ndm, wow!
06:25:53 <Philippa> ndm: you missed out five or six exclamation marks there
06:25:54 <ValarQ> didn't Haskell use to have a pretty good 'lines' score?
06:26:02 <dons> ValarQ: we have many different functions used, which don't compress well
06:26:24 <ndm> is there a haskell code count utility?
06:26:30 <ndm> if not, i'll probably end up writing one...
06:26:31 <dons> we still have a top lines of code score
06:26:37 <dons> ndm, yep, i've got a good one, let me post it
06:26:42 <Philippa> ndm: if it helps any, I've gone multi-KLoC on more than one occasion, I don't take the comment at all seriously :-)
06:26:55 <ValarQ> dons: many different?
06:27:06 <dons> ValarQ: ?
06:27:12 <ndm> dons, where is the darcs repo?
06:27:18 <dons> on its way...
06:27:19 <ndm> ;)
06:27:33 <dons> its not darcsified, here you go, http://www.cse.unsw.edu.au/~dons/tmp/count_lines
06:27:35 <ValarQ> dons: do you mean that Haskell is using more unusuall symbols?
06:27:39 <dons> its stolen from fptools/ghc/compiler
06:28:02 <dons> ValarQ: i think we use lots of symbols, rather than repeating [ ] = + ; { } over and over
06:28:18 <dons> we'll write fold/map/fmap/mapM_/mapM/ and so on, in lots of different ways
06:28:43 <dons> think about how gzip works. you benefit if you repeat the same symbol
06:29:01 <ndm> dons, argh, you didn't say it was written in perl!
06:29:05 <ValarQ> yeah, but i didn't realise it could make this big difference
06:29:11 <dons> so if your language is rich, and full of a wide range of control structures/higher-order stuff, you'll lose
06:29:41 <dons> ndm, demo: 
06:29:42 <dons> $ count_lines Data/* Data/ByteString/* Data/ByteString/Lazy/*
06:29:42 <dons> Data                   2119   1868
06:29:42 <dons> Data/ByteString        1965   1918
06:29:42 <dons> Data/ByteString/Lazy    294    399
06:29:43 <ValarQ> perl is apparantly the big winner
06:29:45 <dons> TOTAL:                 4378   4185
06:29:47 <dons> ...
06:29:48 <xerox> http://haskell.org/haskellwiki/User:PaoloMartini
06:29:48 <lambdabot> Title: User:PaoloMartini - HaskellWiki
06:29:57 * xerox is becoming selfish ... haha
06:33:38 <xerox> Howdy CosmicRay.
06:33:55 <CosmicRay> morning xerox
06:34:36 <dons> ndm, TOTAL:                34736  24454
06:34:40 <dons> 3 years :)
06:34:52 <ndm> dons, whats that one?
06:35:02 <ndm> all your projects, or just your phd?
06:35:19 <dons> all the projects i've done during my phd (they all count ;)
06:35:33 <dons> there's missing stuff though
06:35:37 <ndm> in that case i really have to include hoogle
06:35:41 <dons> i don't know how much of lambdabot i've written, for exapmle
06:35:46 <ndm> and WinHugs would boost the total because thats C :)
06:35:53 <dons> cheating!
06:36:01 <dons> you can't use verbose languages :P
06:36:07 <ndm> hehe, indeed
06:37:08 <ndm> hoogle is an extra 6368
06:37:36 <dons> wow, didn't know it was that big
06:37:42 <dons> i guess there's a bunch of parsers and so on
06:38:16 <ndm> yeah, oh, its included _darcs
06:38:52 <ndm> thats more reasonable, 3302
06:39:28 <dons> I used -o -prune _darcs  to find
06:39:48 <ndm> my copy of find is a bit tempramental, options tend to screw it up
06:39:51 <dons> i.e. find projects* -name '*.hs' -o -name _darcs -prune | xargs count_lines
06:42:06 <mnislaih> @seen Lemmih 
06:42:06 <lambdabot> Lemmih is in #haskell-overflow and #haskell. I don't know when Lemmih last spoke.
06:43:53 <xerox> I think I found something.
06:44:32 <jmob|> so, how come when I run the code ``exit = { do x <- (System.Cmd.system "echo foo"); return x'' I get back "foo" bound to exit instead of the exit code?
06:44:48 <dons> xerox, you might like this,
06:44:49 <dons> > (return [6..10] >>=) . (show .) . zip =<< (return [1..5])
06:44:50 <lambdabot>  "[(1,6),(2,7),(3,8),(4,9),(5,10)]"
06:45:06 <ndm> @hoogle system
06:45:06 <lambdabot> System.system :: String -> IO ExitCode
06:45:06 <lambdabot> System :: module
06:45:06 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
06:45:11 <xerox> Wooooo.
06:45:21 <xerox> That's mind-benting :-)
06:45:33 <ndm> jmob|: not possible, the result x will be of type ExitCode - it can't be a string
06:45:39 <xerox> Did you derive it manually, dons?
06:45:42 <ndm> can you paste your exact code somewhere?
06:45:49 <dons> we stumbled across it yesterday .au time, but i'm not sure it got noticed the euro crowd
06:45:53 <ndm> it might be indendation or scoping
06:46:38 * xerox hops up and down
06:47:07 <dons> so, for example,
06:47:08 <dons> Prelude> (readFile "f" >>=) . (putStr .) . (++) =<< readFile "g"
06:47:08 <dons> no
06:47:08 <dons> yes
06:47:10 <roconnor> @type System.Cmd.system
06:47:12 <lambdabot> String -> IO GHC.IOBase.ExitCode
06:47:46 <xerox> Looks like circumfix notation :-)
06:48:03 <mauke> argh
06:48:34 <dons> mauke likes this idiom, I see
06:48:42 <xerox> hahaha
06:48:47 <dons> in fact, it was evil lambdabot that suggested it!
06:48:52 <dons> showing surely some AI in the process
06:49:00 * xerox nods vigoroously
06:49:06 <mauke> no, why does http://haskell.org/gtk2hs/archives/2005/07/15/automatic-memory-management/ use explicit <br />s?
06:49:07 <lambdabot> Title: Gtk2Hs » Blog Archive » What do we mean by automatic memory management? How do ...
06:49:08 <dons> next step, launches nuclear strikes against moscow and new york
06:49:20 <mauke> it's totally unreadable
06:49:20 * xerox sends in some patches
06:49:41 <tony2> thats neat.
06:50:06 <dcoutts> mauke, I'll fix it
06:50:14 <jmob|> code = do { x <- (system "echo foo"); return x }
06:50:31 <dons> i've never seen the action2 >>= a . b . c =<< action1 notation before, but maybe its useful for some tricks
06:50:42 <jmob|> *Scratch> :t code
06:50:43 <jmob|> code :: IO ExitCode
06:50:47 <jmob|> hrmm...
06:51:06 <dcoutts> mauke, better?
06:51:23 <xerox> ?type \a b c -> (undefined :: Monad m => m a) >>= a . b . c =<< (undefined :: Monad m => m a)
06:51:24 <dcoutts> mauke, I think it was a change of interpetation after a WP upgrade
06:51:25 <lambdabot>   precedence parsing error
06:51:25 <lambdabot>     cannot mix `(>>=)' [infixl 1] and `(=<<)' [infixr 1] in the same infix expression
06:51:29 <ndm> are you sure you're not being confused with the foo being written to the console?
06:51:32 <mauke> dcoutts: yes!
06:51:37 <mauke> @karma+ dcoutts
06:51:37 <lambdabot> dcoutts's karma raised to 14.
06:51:39 <ndm> it will not write anything, it will not output the result
06:51:50 <tony2> dons, how much faster is your possible bytestring entry for shootout sumfile? (did you write it?)
06:51:52 <ndm> if you want that, code >>= print
06:52:00 <ndm> then it will print the exit code, i.e. x
06:52:02 <xerox> ?type (\a b c -> ((undefined :: Monad m => m a) >>=) a . b . c (=<< (undefined :: Monad m => m a)))
06:52:03 <lambdabot> forall a b b1 c (m :: * -> *) a1 b2 a2. (Monad m) => (a -> c -> b) -> (b1 -> c) -> (((a1 -> m b2) -> m b2) -> a2 -> b1) -> a2 -> b
06:52:11 <dons> tony2: yep, we've written a few versions, i think its 3x C
06:52:38 <tony2> dons, is that faster than clean?
06:52:40 <xerox> ?type (\a b -> ((undefined :: Monad m => m a) >>=) . a . b (=<< (undefined :: Monad m => m a)))
06:52:41 <lambdabot> forall (m :: * -> *) a b b1 (m1 :: * -> *) a1 b2 a2. (Monad m, Monad m1) => (b1 -> a -> m b) -> (((a1 -> m1 b2) -> m1 b2) -> a2 -> b1) -> a2 -> m b
06:52:48 <xerox> It is more like this dons, isn't it?
06:53:09 <dons> tony2: it would put it somewhere near clean, maybe a tad slower?
06:53:49 <tony2> dons, thats excellent.
06:54:22 <tony2> clean really does seem quite fast.
06:54:39 <dons> 'tis, it's what haskell will be in a year or so :)
06:54:49 <jmob|> ndm: So, why doesn't this work then: code = (system "echo foo") >>= id ?
06:54:50 <dons> perf-wise
06:55:07 * xerox stares at dons
06:55:16 <mauke> jmob|: >>= id is join
06:55:20 <mauke> join needs nested monads
06:55:21 <dons> xerox: yeah, that's good!
06:55:53 <mauke> system returns IO ExitCode, not IO (IO ExitCode)
06:56:44 <jmob|> Well, I want the world to stop at that point, go away, and give me it's argument :(
06:57:06 <xerox> (a -> b -> m a) -> (((c -> m d) -> m d) -> e -> a) -> e -> m a
06:57:07 <mauke> huh?
06:57:15 <dons> ?remember jmob| I want the world to stop at that point, go away, and give me it's argument..
06:57:15 <lambdabot> Done.
06:57:28 <dons> xerox: good type, heh?
06:57:42 <dons> we can call it something good, i think..
06:57:58 <xerox> Seems so O_O
06:58:03 <ndm> jmob| that would break out of the monad, once something is in the monad there is no way out
06:58:15 <dons>  f >>= a . b . c =< g -- something-something notation
06:58:24 <jmob|> ndm: oh
06:58:25 <dons>  f >>= a . b . c =<< g -- i mean
06:58:31 <xerox> Circumfix?
06:58:37 <dons> insqueezed?
06:58:45 <xerox> bump'n'jump?
06:58:45 <jmob|> ndm: Why is that?
06:59:01 <xerox> Maybe that term from CT would do... the dual of pushouts.
06:59:04 <dons> trapped-in-the-headlights notation?
06:59:20 <ndm> jmbo|, you could do evil things - its because haskell is pure, and that function could return different things at different times
06:59:23 <mauke> jmob|: because doing IO has side effects
06:59:39 <dons> xerox: so then i wonder, what about:  a =<< f . g >>= b -- ?
06:59:40 <xerox> `pushin', maybe.
06:59:58 <xerox> edwardk: surely know.
07:00:28 <xerox> dons - If you give me insights about how you first discovered the squeezing one, I might be able to work on the dual :-)
07:00:39 <dons> hehe , ok let me check the logs
07:01:33 <dons> we were playing with:
07:01:42 <dons> ?pl readFile x >>= \str -> readFile y >>= \strm ->  putStr . show . parser . alexScanTokens $ (str++strm)
07:01:42 <lambdabot> (readFile y >>=) . ((putStr . show . parser . alexScanTokens) .) . (++) =<< readFile x
07:01:50 <dons> and lambdabot gained conciousness
07:02:06 * xerox cringes
07:02:43 <dons> ?pl readFile x >>= \t -> readFile y >>= \s ->  a . b . (c t s)
07:02:43 <lambdabot> (readFile y >>=) . (((a . b) .) .) . c =<< readFile x
07:03:05 <dons> ?pl readFile x >>= \t -> readFile y >>= \s ->  a . b . c $ (t:s)
07:03:05 <lambdabot> (readFile y >>=) . ((a . b . c) .) . (:) =<< readFile x
07:03:25 <dons> ?pl readFile x >>= \t -> readFile y >>= \s ->  a . b $ (t `c` s)
07:03:25 <lambdabot> (readFile y >>=) . ((a . b) .) . c =<< readFile x
07:04:06 <xerox> the action in the middle is scary.
07:04:11 <xerox> Its type, at least.
07:04:27 <xerox> brb
07:04:38 <jmob|> I don't quite understand why the type system can't enforce the world "going away", as long as it goes away with the same type.
07:05:38 <mauke> jmob|: I don't get it
07:07:21 <jmob|> (IO ExitCode) -> ExitCode .. you're saying ExitCode can never be removed from the IO monad, right?
07:07:44 <jmob|> Is this just monad zen that I don't understand?
07:08:09 <Philippa> yes. In short, there's no function of that type and so you can't build one either
07:08:19 <mauke> IO ExitCode isn't just a useless wrapper around ExitCode
07:08:22 <Philippa> normally you'd pattern-match on the value, but IO's constructors're hidden
07:08:31 <Philippa> yeah. It's the entire damn program
07:08:35 <mauke> it's an action that can do arbitrary IO, then returns an ExitCode
07:12:39 <jmob|> So, I'd need to write a monad to know if my command succeeded?
07:14:04 <mauke> huh?
07:14:06 <vegai> no, you just have to check it without leaving the IO monad
07:14:26 <mauke> you can't just transfer stuff from one monad to another one
07:14:34 <dons> ?  do x <- something that returns ExitCode(..) ; case x of ExitSuccess -> .. ; ExitFailure n -> print n
07:16:40 <xerox> mauke: IO ExitCode is probably `main', I wouldn't call it a useless wrapper around ExitCode ;-)
07:16:42 * xerox blinks
07:17:59 <vegai> xerox: isn't :)
07:19:31 <jmob|> Hurrah... no I have an IO Bool monad.
07:19:37 <jmob|> s/no/now/
07:20:18 <mauke> dcoutts: could you replace the smart quotes by " " in the example program at http://haskell.org/gtk2hs/documentation/ ?
07:20:19 <lambdabot> Title: Gtk2Hs » Documentation
07:22:07 * xerox scratches his head at dons' squash-fix notation.
07:22:24 <dcoutts> mauke, well spotted, thanks.
07:22:31 <dcoutts> look ok now?
07:24:53 <mauke> dcoutts: yes, thanks. (I simply pasted it into a file and ghc gave me a lexical error, I didn't really spot it)
07:32:19 <ndm> dcoutts, what Gtk2Hs really needs is hoogle search!
07:32:27 <dcoutts> ndm, yes, it does!
07:32:44 <ndm> Hoogle 4 will probably support external packages etc.
07:32:47 <dcoutts> how do we do that these days?
07:32:56 <dcoutts> via haddock or what?
07:33:00 <ndm> but i'm quite tempted to just shove it into the main hoogle 3 because it would be really useful for me
07:33:02 <ndm> yep, via haddock
07:33:12 <ndm> get a HEAD version of haddock, and use the -hoogle flag
07:33:39 <ndm> * probably -> properlyl
07:40:37 <shapr> Wow cool, I got an email pointing me to the Brzozowski paper and the guy wants to start using Hope too!
07:41:00 <xerox> What paper? :D
07:44:30 <shapr> The one about derivatives of regular expressions.
07:45:08 <ndm> shapr: please send a link
07:45:23 <mnislaih>        /action looks daggers at a 13'' inches sized glare in the shiny Macbook screen
07:45:28 <ndm> derivatives of regular expressions where done by Conway, over 40 years ago
07:45:40 <mnislaih> colloquy betrayed me :S
07:45:47 <ndm> what else does the Brzozowski paper do?
07:46:59 <shapr> ndm: http://pargear.dreamhost.com/p481-brzozowski.pdf
07:47:18 <shapr> I hope that's not a copyrighted document...
07:47:30 <ndm> shapr, cheers - yeah, i've seen the content before in Conway's book, from around the same period
07:47:35 <ndm> it was actually in my paper :)
07:47:53 <ndm> its a very handy thing
07:48:24 <ndm> if you ever get a chance Conways book on Regular Expressions is great - terms like bomb's and denoators :)
07:48:36 <shapr> I'm interested in applying concepts like 'derivative' much more generally.
07:51:04 <xerox> You can make derivatives of types!
07:51:09 <xerox> ...and get zippers :-)
07:52:19 <shapr> Yeah, I wonder how that's connected.
07:56:49 <roconnor> D [x] = ([x],x,[x])
07:57:20 <roconnor> well d/dx([x]) = ([x],x,[x])
07:57:46 <mauke> does gtk2hs have any real docs?
07:58:02 <roconnor> hmm, that doesn't seem right.
07:59:55 <Dino_> I wanted to ask, going through the simple state monad stuff in YAHT. At some point they have: type State st a = st -> (st, a) ...
08:00:04 <shapr> yeah?
08:00:16 <Dino_> Does this basically mean that State st a is the the type of a function that takes an st and returns an (st, a) ?
08:00:29 <mauke> yes
08:00:31 <shapr> yup
08:00:42 <xerox> Indeed!
08:00:56 <Dino_> I guess I was slightly freaked out about types that aren't.. 'flatter', like  type String = [Char]
08:01:23 <xerox> What about Map Int Char ?
08:02:41 <Dino_> It's all just me still getting used to things. It's like there's much more uniformity of things in Haskell. Like 'constant values', what you'd think of as variables, and functions, all really the same thing: expressions.
08:03:06 <dcoutts> mauke, there's the haddock api docs which are fairly comprehensive
08:03:32 <dcoutts> mauke, if you mean tutorials, then not really, there's an introductory presentation and various demo programs
08:04:23 <mauke> I know approximately what kind of features I want but I have no idea what I need to use
08:04:55 <mauke> I just want a window with a menu bar and an area I can draw pixels in
08:04:56 <dcoutts> what kind of feature do you want?
08:05:01 <dcoutts> ah ok
08:05:28 <dcoutts> see the glade demo (making a window with a menu bar is easy) and the drawing demos
08:05:38 <dcoutts> they use a drawing area to draw into
08:05:47 <mauke> ok, thanks
08:06:31 <dcoutts> or if you're doing bitmap/pixel oriented drawing rather than vector drawing then the fastdraw demo
08:06:47 <Dino_> Now, the book moves on to say that it would be great if we could instance this State st a as a Monad, but that doesn't work for this type syn. So they make this: >
08:06:51 <Dino_> >
08:06:54 <Dino_> bah
08:07:05 <Dino_> newtype State st a = State (st -> (st, a))
08:07:22 <dcoutts> mauke, the vector style drawing is in the graphic/Drawing.hs demo and in the cairo ones, cairo is easier and nicer if you've got it available
08:07:36 <mauke> I need pixels :-)
08:07:42 <xerox> Dino_ - What?
08:07:58 <sjanssen> Dino_: yeah, type synonyms can't instance classes
08:08:10 <Dino_> Now, a little bit later they have this function: getState :: State state state
08:08:14 <xerox> Oh, I see. `type'.
08:08:16 <Dino_> I'm confused as to how to read that.
08:08:20 <Dino_> State state state
08:08:30 <mauke> getState :: State a a
08:08:33 <xerox> Both `st' and `a' are `state.
08:08:37 <xerox> Both `st' and `a' are `state', Dino_.
08:09:06 <mauke> 'State' is the type defined above, 'state' is a type variable
08:09:11 <Dino_> Is it just unfortunate that state was used twice for a type var?
08:09:23 <xerox> It is not unfortunate, it is intended.
08:09:30 <xerox> It express the behaviour of the function:
08:09:47 <sjanssen> @type \s -> (s, s)
08:09:48 <lambdabot> forall a. a -> (a, a)
08:09:54 <xerox> `State st a' describes an action which has a state value of the type `st' and returns a result of the type `a'.
08:10:07 <Dino_> And that result can itself be another state?
08:10:12 <xerox> `State state state' describes an action which has a state value of the type `state' and returns a result of the type `state' -- that is: The state.
08:10:49 <xerox> `...that is, it returns the state.'
08:11:05 <mauke> Dino_: it's the same state, really
08:11:08 <Dino_> But where is it coming from? I mean, there's no input.
08:11:11 <mauke> getState returns the current state
08:11:26 <xerox> Yup.
08:11:38 <xerox> When you run a State computation you feed an initial state.
08:11:43 <xerox> ?type runState
08:11:45 <lambdabot> forall s a. State s a -> s -> (a, s)
08:11:49 <mauke> Dino_: and what's the st in 'State (st ->'?
08:11:53 <mauke> looks like an input to me
08:12:01 <sjanssen> the State monad makes the state input implicit -- that's the whole point
08:12:18 <Dino_> Well.. ok, the State state state is really standing in for a function that takes some state.
08:12:23 <xerox> See? You give `runState' a `State s a' action and an initial state `s', and it returns a value of type `a' and the final state of type `s'.
08:12:50 <xerox> > runState getState 1
08:12:50 <lambdabot>  Not in scope: `getState'
08:13:01 <xerox> > let getState = get in runState getState 1
08:13:02 <lambdabot>  (1,1)
08:14:08 <xerox> > runState (do { x <- get; modify (*2); y <- get; return x+y }) 5
08:14:08 <lambdabot>    Occurs check: cannot construct the infinite type: s = State s s
08:14:09 <lambdabot>    Ex...
08:14:18 <xerox> > runState (do { x <- get; modify (*2); y <- get; return (x+y) }) 5
08:14:19 <lambdabot>  (15,10)
08:14:20 <xerox> Sorry.
08:15:25 <Dino_> Where did runState come from?
08:15:58 <xerox> From State definition.
08:16:13 <Dino_> ok
08:16:26 <mauke> @djinn (st -> (st, a)) -> st -> (st -> a)
08:16:26 <lambdabot> f a b _ =
08:16:26 <lambdabot>   case a b of
08:16:26 <lambdabot>   (_, c) -> c
08:16:40 <xerox> newtype State s a = State (s -> (s,a))
08:16:42 <xerox> ...is isomorphic to...
08:16:44 <xerox> newtype State s a = State { runState :: s -> (s,a) }
08:16:46 <xerox> They're called records.
08:17:03 <mauke> @djinn (st -> (st, a)) -> st -> (st, a)
08:17:03 <lambdabot> f a = a
08:17:05 <Dino_> :/  It's just actually getting more confusing now.
08:17:20 <xerox> Do you know:
08:17:25 <xerox> data Foo = Foo String Int ?
08:17:39 <xerox> With such definition you can then pattern match like:
08:17:46 <xerox> f :: Foo -> Int
08:17:47 <Dino_> Yes, declare a data type Foo that constructs with Foo (some string) (some int)
08:17:49 <xerox> f (Foo _ x) = x
08:18:15 <xerox> Okay. If you want to make it more meaningful, and have GHC define functions like that `f' you can do it this way:
08:18:23 <xerox> data Person = Person { name :: String, age :: Int }
08:18:23 <Dino_> Ok, so you're not caring about the String and using the Int
08:18:36 <xerox> And GHC defines name :: Person -> String; and age :: Person -> Int.
08:18:37 <Dino_> ok, record
08:18:49 <xerox> It also enables some other syntax.
08:19:11 <Dino_> So this is like implicitly created getters for the record members.
08:19:23 <xerox> Yes, and setters.
08:19:26 <Dino_> (apologies if I butcher things with words from other languages)
08:19:40 <xerox> birthday :: Person -> Int -> Person
08:20:05 <xerox> birthday p = p { age = (age p) + 1 }
08:20:48 <Dino_> This means that 'birthday p' is a function that's expecting an Int?
08:21:03 <xerox> Ops!
08:21:06 <Dino_> partially evaluated?
08:21:07 <xerox> birthday :: Person -> Person
08:21:10 <xerox> birthday p = p { age = (age p) + 1 }
08:21:15 <xerox> Sorry!
08:21:43 <Dino_> Ok, so birthday here is incrementing their age, like it's their birthday.
08:22:00 <Dino_> (age p) is calling the age getter on a Person
08:22:01 <xerox> Right :-)
08:22:05 <xerox> Yes.
08:22:22 <xerox> And then I'm "changing" the field (really producing a new value) with that number incremented by one.
08:22:28 <Dino_> BTW it's very refreshing to not have to write these accessors.
08:22:39 <xerox> =)
08:22:55 <Dino_> I see, having p's age evaluate to the existing age + 1
08:23:00 <Philippa> in a pure language, there's no need for Java-style getters and setters thankfully :-)
08:23:10 <Philippa> or rather, when there is you shouldn't be exposing the record itself anyway
08:23:38 <xerox> Philippa - runFoos are useful :-)
08:23:45 <Dino_> Few things seem more annoying to me than having the talk with smug Java people who think their fat IDE should be writing all the code for them, accessor and stuff. I never liked any of that.
08:24:24 <xerox> In Haskell there is near-to-nothing code-rewriting.
08:24:49 <sjanssen> Dino_: yeah, if it's easy enough for the IDE to write, why can't the language do it?
08:24:51 <Dino_> It's been extremely hard, but I've seen too much and must learn this further.
08:25:22 <xerox> Beware! You'll be caught and never released!!
08:25:40 <Dino_> At the risk of creeping people out, I have done a lot of implicit accessor stuff in Perl OO. But it's much more of a semi-ugly hack. This in the big H, very smooth.
08:26:20 <Dino_> Anyway, enough stuff about retarded langs. So, the age gets updated by the birthday func.
08:32:58 <Dino_> So, based on this stuff with the Person:  name :: Person -> String ..
08:33:09 <Dino_> Similarly:  runState :: State st a -> s -> (s, a)
08:33:58 <mauke> given a stateful action and an initial state, runState runs the action and returns its result, as well as the final state
08:34:35 * xerox heads off to buy something
08:35:43 <Dino_> So that above is basically what's being created when you have this:  newtype State s a = State { runState :: s -> (s,a) }
08:36:17 <Dino_> ?
08:37:23 <mauke> yes
08:37:37 <mauke> note that a -> b -> c is the same as a -> (b -> c)
08:37:41 <xerox> Yes indeed.
08:40:41 <Dino_> This newtype of State, we're going over stuff that's already defined (but in more detail)? This is how the State stuff is put together, as a record like this?
08:41:12 <Dino_> Sorry for the endless questions. I appreciate the patience around here. And I log everything that we talk about for future study.
08:41:49 <mauke> I don't understand the question
08:42:29 <Dino_> xerox wrote this  newtype State s a = State { runState :: s -> (s, a) }  That's for-real defined somewhere.
08:42:40 <Dino_> But with more than this
08:47:18 <lightstep> Dino_, a computation of type (State s a) will compute a value of type a is a state of type s exist. but this will only happen when runState is called
08:49:18 <Dino_> Ok. So State really exists in Control.Monad.State, it's not some exercise being made up here.
08:49:39 <lightstep> no
08:49:51 <lightstep> but it's a cool exercise
08:49:54 <Dino_> yes
08:51:48 <Dino_> Thanks guys. I'm finding the monad stuff extremely difficult. Which I'm sure is no surprise to some people.
08:52:14 <mauke> wtf is maxBound
08:53:02 <mauke> oh
08:53:04 <lightstep> > maxBound :: Ordering
08:53:09 <lambdabot>  GT
08:53:59 <lightstep> is ParsecT going to be developed sometime?
08:55:27 <lightstep> i didn't see it on the SoC page
08:58:27 <Philippa> you could always do it yourself? The core of Parsec isn't that big
08:59:25 <xerox> Dino_: I give you two useful lambdabot commands.
08:59:31 <xerox> ?index runState
08:59:32 <lambdabot> Control.Monad.State, Control.Monad.RWS
08:59:39 <xerox> ?docs Control.Mond.State
08:59:40 <lambdabot> Control.Mond.State not available
08:59:50 <xerox> Ah, there also is this one, which is really cool:
08:59:57 <xerox> ?fptools Control.Monad.State
08:59:57 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
09:00:06 <xerox> ?docs Control.Monad.State
09:00:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
09:01:40 <Dino_> xerox: Excellent. Thank you.
09:01:59 <astrolabe> ?hoogle state
09:02:00 <lambdabot> Control.Monad.State :: module
09:02:00 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
09:02:00 <lambdabot> Control.Monad.State.State :: newtype State s a
09:03:01 <astrolabe> I found monads hard at first, but I think a lot of that is due to their unfamiliarity.
09:03:18 <astrolabe> er 'owing to'
09:03:19 <wchogg> Sorry, dumb question, but if I've opened up a telnet connection and am reading strings sent to the Haskell process, how can I send output back to original system connecting?  For example, I'm trying to echo whatever is typed in the basic telnet prompt.
09:04:07 <Dino_> astrolabe: Yeah, it's not like anything else I've seen. There seems to be very little prior knowledge I can use on the topic.
09:04:17 <Dino_> (or my own)
09:04:20 <Dino_> bah, of my own
09:04:27 <psnl> wchogg: writeline S $ readline S comes ot mind, but you want to look up most of that
09:07:03 <wchogg> psnl:  I tried doing hPutStrLn, but that didn't appear to send the text back over the connection.  That's what I'm trying to figure out how to do.
09:07:19 <joelr1> howdy folks
09:07:31 * joelr1 is on p11 of the history of haskell
09:07:38 <wchogg> Do you like it?
09:08:10 <roconnor> @hoogle flush
09:08:10 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
09:08:10 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
09:08:10 <lambdabot> IO.hFlush :: Handle -> IO ()
09:08:25 <psnl> wchogg: hflush maybe
09:08:45 <wchogg> Okay, I'll try that.  Maybe there's a difference between the two I don't understand.
09:08:49 <roconnor> @hooge LineBuffer
09:08:49 <lambdabot> System.IO.LineBuffering :: BufferMode
09:08:50 <lambdabot> System.Console.Readline.getLineBuffer :: IO String
09:09:09 <roconnor> System.IO.LineBuffering
09:09:14 <roconnor> @hoogle BufferMode
09:09:14 <lambdabot> System.IO.BufferMode :: data BufferMode
09:09:14 <joelr1> wchogg: sure
09:09:47 <wchogg> roconnor:  Thanks, I'll look at that.
09:10:27 <mauke> @pl mk >>= \x -> mk >>= \y -> init x y >>= \r -> body
09:10:27 <lambdabot> (mk >>=) . flip flip (const body) . ((>>=) .) . init =<< mk
09:10:57 <mauke> @pl mk >>= \x -> mk >>= \y -> init x y
09:10:57 <lambdabot> (mk >>=) . init =<< mk
09:11:04 <mauke> he's doing it again!
09:11:15 * xerox runs away screaming
09:12:06 <roconnor> @hoogle BufferMode -> a
09:12:07 <xerox> ?pl \f -> a >>= \x -> b >>= \y -> c >>= \z -> f x y z
09:12:07 <lambdabot> No matches, try a more general search
09:12:07 <lambdabot> (a >>=) . (((b >>=) . ((c >>=) .)) .)
09:12:27 <roconnor> hmm, can't search for commands that take a BufferMode?
09:12:45 <xerox> ?type let a = undefined :: Monad m => m a in \f -> a >>= \x -> a >>= \y -> a >>= \z -> f x y z
09:12:46 <lambdabot> Monad m => m a in \f -> a >>= \x -> a >>= \y -> a >>= \z -> f x y z :: forall (m :: * -> *) a a1 a2 b. (Monad m) => (a -> a1 -> a2 -> m b) -> m b
09:12:55 <xerox> I think _this_ is the pattern.
09:13:09 <ndm> roconnor: you will be able to in hoogle 4, with a special command
09:13:11 <wchogg> Yeah, the problem was that it didn't immediately send the data back over the line.  I thought it would because it was on a telnet port.
09:13:15 <ndm> do you know any functions that take a buffer mode?
09:13:17 * xerox pokes dons
09:14:03 <ndm> @hoogle hSetBuff
09:14:03 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
09:14:18 <roconnor> ahh
09:14:37 <roconnor> wchogg: You can try hSetBuffering  h LineBuffering
09:15:04 <erider> hey roconnor question for you since you are around 
09:15:15 <roconnor> ok
09:16:04 <erider> the number in foldr eg. foldr (max) 0 [1,2,3,4] represents the index of the list correct?
09:16:11 <wchogg> Yeah, I actually set it to no buffering and it worked just fine.
09:16:17 <wchogg> Thanks for the suggestions.
09:16:23 <roconnor> erider: nope
09:16:31 <roconnor> @wiki foldr
09:16:31 <lambdabot> http://www.haskell.org/haskellwiki/foldr
09:16:41 <Philippa> > foldr max 9 [1,2,3,4]
09:16:42 <xerox> Hrrmpf.
09:16:42 <lambdabot>  9
09:16:44 <xerox> It can't be abstracted cleanly because we have no variadic functions wasily
09:16:46 <xerox> *easily
09:16:52 <roconnor> bah
09:16:57 <Philippa> erider: does that answer your question?
09:17:04 <sjanssen> nice quote from the Haskell history paper: "the Haskell community is small enough, and agile enough, that they usually not only absorb language changes but positively welcome them: it's like throwing red meat to hyenas."
09:17:18 <wchogg> I'm impressed at how clean it was to open a telnet connection.  That's pretty fun.
09:17:29 <erider> yes thanks roconnor 
09:17:36 <roconnor> @oldwiki foldr
09:17:36 <lambdabot> http://www.haskell.org/hawiki/foldr
09:18:01 <roconnor> grr
09:18:10 <roconnor> @oldwiki WhatIsaFold
09:18:10 <lambdabot> http://www.haskell.org/hawiki/WhatIsaFold
09:18:44 <erider> ok I thank that one is it :)
09:18:54 <erider> ok I think that one is it :)
09:18:58 <roconnor> foldr is best described by a picture
09:19:16 <roconnor> it replaces : by the function and [] by the constant
09:19:45 <xerox> ?type let a = undefined :: Monad m => m a in \f -> a >>= \x -> a >>= \y -> a >>= \z -> f x y z
09:19:46 <lambdabot> Monad m => m a in \f -> a >>= \x -> a >>= \y -> a >>= \z -> f x y z :: forall (m :: * -> *) a a1 a2 b. (Monad m) => (a -> a1 -> a2 -> m b) -> m b
09:19:50 <xerox> Yes this is the pattern, dons.
09:20:14 <xerox> ?type let a = undefined :: Monad m => m a in \f -> a >>= \x -> a >>= \y -> f x y
09:20:16 <lambdabot> Monad m => m a in \f -> a >>= \x -> a >>= \y -> f x y :: forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m b
09:20:20 <xerox> ?type let a = undefined :: Monad m => m a in \f -> a >>= \x -> f x
09:20:21 <lambdabot> Monad m => m a in \f -> a >>= \x -> f x :: forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m b
09:20:33 <xerox> Generalized `fmap' to the number of arguments :-)
09:20:38 <tony2> sjanssen, where is this haskell history paper you speak of?
09:20:49 <xerox> ?type \f a -> a >>= \x -> f x
09:20:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
09:21:05 <xerox> ?type \f a b -> a >>= \x -> b >>= \y -> f x y
09:21:06 <sjanssen> tony2: Simon PJ just posted it to the mailing list
09:21:06 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
09:21:12 <xerox> And so on.
09:21:27 <tony2> sjanssen, just checked my mail ;)
09:21:41 <sjanssen> http://haskell.org/haskellwiki/History_of_Haskell if anyone isn't subscribed
09:21:42 <lambdabot> Title: History of Haskell - HaskellWiki
09:29:59 <xerox> dons - Also, the fact that doing fmap^2 can be viewed as adding a direction could make one think of fmap^n in an N/2 dimensional space ;-)
09:30:49 <xerox> (With the two arrow `>>=' vectors pointing towards the origin - Gee.
09:41:16 <xerox> sjanssen: subscribed to what?
09:42:49 <mauke> ?index when
09:42:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:43:31 <erider> urort 
09:44:17 <erider> oops!
09:45:28 <erider> hvor er hjemme fest 
09:45:56 <erider> damn I did it again 
09:52:55 <xerox> Oh man!
09:53:12 <xerox> If only Sussman have chosen to go call-by-name :D
09:55:31 <rictic> What are some good Haskell blogs?
09:56:37 <rictic> I've been picking up Haskell lately and really enjoying it, and I'm looking to pick up a few tricks and refine my Haskell-foo
09:57:05 <vininim> "Amoco subsequently transcribed the functional program into ... with encouraging results."
09:57:10 <vininim> what is "..." supposed to mean?
09:58:02 <vegai> if you're quoting a quote, it would probably mean that part of the quote deemed unnecessary was omitted
10:03:41 <Lemmih> erider: Er der fest?
10:04:26 <erider> sorry wasn't for this channel 
10:05:24 <ndm> rictic: planet.haskell.org
10:09:31 <erider> : is a constructor? 
10:10:05 <ndm> erider: yep
10:10:20 <ndm> anything starting with a : is, :+ :* etc.
10:10:46 <erider> cool 
10:10:58 <erider> slow be surely I'm getting it :)
10:11:06 <erider> slowly be surely I'm getting it :)
10:11:13 <erider> oops 
10:11:15 <SamB_XP> well, thats a Haskell extension anyway
10:11:19 <erider> but*
10:11:26 <SamB_XP> though it will probably go into the next version
10:11:38 <mauke> dcoutts: there?
10:11:52 <dcoutts> mauke, aye
10:12:12 <mauke> my program works! http://rafb.net/paste/results/AE7uvt30.html
10:12:21 <mauke> it makes pretty pictures
10:15:37 <dcoutts> mauke, great, can we see any pics? :-)
10:18:28 <rictic> ndm: thanks
10:18:59 <ndm> SamB_XP: what, : as a constructor? no, thats standard Haskell 98
10:19:56 <SamB> ndm: no
10:20:07 <SamB> the other infix constructors
10:20:22 <ndm> oh, yeah, those are an extension
10:20:30 <ndm> but i'm not sure it will get into the next version
10:20:58 <mauke> dcoutts: http://img304.imageshack.us/img304/1687/woo13ss.png http://img304.imageshack.us/img304/3296/woo29pg.png
10:21:00 <SamB> sure it will!
10:21:08 <SamB> its well used and it isn't hard to specify
10:21:25 <dcoutts> mauke, hey, cool!
10:21:25 <SamB> well, I think it is well used anyway...
10:22:05 <mauke> it's very slow, though
10:22:21 <sjanssen> mauke: that second one looks crazy on a CRT
10:22:28 <sjanssen> because of the scan lines
10:26:34 <sjanssen> mauke: that statement about GHC optimizing loops, did you try it both ways?
10:27:26 <mauke> nope, I just modified the fastdraw example
10:27:33 <sjanssen> oh okay
10:28:03 <sjanssen> it gave me a good idea: write sequence_ so it can take advantage of list fusion
10:29:20 <largos> what is list fusion?
10:30:00 <sjanssen> largos: in a pipeline of functions using lists, the compiler can "fuse" them together into one loop
10:30:39 <sjanssen> for example: length $ filter even $ map (*3) [1.. n :: Int]
10:30:58 <sjanssen> GHC will not create a single list cell for that program (with optimizations on)
10:31:04 <largos> ah, cool
10:37:53 <sjanssen> actually, looks like sequence_ is already defined in terms of foldr which means it already fuses
10:58:26 <conal> mauke: what are those pictures?
10:58:49 <mauke> screenshots of the output generated by http://rafb.net/paste/results/AE7uvt30.html
10:59:53 <conal> and what's that program about?  were you after something?
11:00:39 <integral> @karma+ mauke
11:00:40 <lambdabot> mauke's karma raised to 2.
11:00:46 <integral> so Gtk *is* easy. thanks :)
11:01:05 <mauke> conal: I like those pictures
11:01:21 <mauke> the program is a haskell port of one of my first qbasic programs
11:01:51 <xerox> Do they have a name?
11:02:08 <mauke> I don't think so
11:02:20 <Daveman> xerox :D
11:02:23 * Pitarou waves "hello all"!
11:02:48 <conal> mauke: i wonder if you could express them functionally rather than imperatively
11:03:00 <conal> and maybe continuously rather than discretely
11:03:53 <xerox> Howdy.
11:04:12 <conal> ... separating the what of the image from the how of displaying it
11:05:01 <Pitarou> conal: Are you talking about a functional graphics library?
11:06:03 <xerox> conal - Your work on images is very nice indeed :-)
11:07:05 <conal> xerox: thanks.  i'm still tinkering with it, including http://conal.net/Pajama
11:07:06 <lambdabot> Title: Pajama
11:07:57 <conal> Pitarou: that's one concrete instance of what i mean.  or just writing down a math formulation.
11:09:00 <conal> although "graphics" so often is used to mean "geometry", so i prefer the term "continuous image", which has a more general flavor for me.
11:09:44 <Pitarou> conal: A function mapping points to colour values?
11:10:57 <conal> Pitarou: that's how i like to define (continuous) "image".  and then parameterize out the color type.  and be sure to include transparency in the color type.
11:12:04 <Pitarou> conal: Uh-huh.  The demo on the Pajama website is a java applet.  Do I need to use that applet to get a flavour of what you've been doing?
11:12:57 <xerox> conal - Thought about using Cairo to produce some neatly-looking Haskell images? =)
11:13:55 <conal> Pitarou: or read a Pan paper (http://conal.net/Pan).  The applet lets you interact with the imagery and is generated by a compiler that takes functional specs.
11:14:44 <conal> xerox: sounds fun.  the Cairo quality looks lovely.  i like interactive imagery -- how's the rendering speed?
11:14:50 <Pitarou> Pan ... oh yes.  I've come across that before.  I've never looked into it yet.  Is that your doing?
11:14:57 <conal> Pitarou: yes
11:15:07 <xerox> conal - Quite good in fact! Check out the cairo-clock demo %)
11:15:12 <dcoutts> conal, it's so-so, depends on how much you render
11:15:38 <xerox> And _how_, I believe.
11:16:08 <xerox> Clock.hs's trickery makes it quite fast, for example.
11:16:28 <largos> does Pan support linux at this point?
11:16:30 <conal> i'd love to collaborate on a functional graphics library based on Cairo.  powerful, general, simple, orthogonal.  and tie it into my current work on concrete, syntax-free, gestural programming.
11:16:35 <dcoutts> conal, eg in the cairo-clock demo I ported it's too slow to animate the gradients so we don't use the gradients while animating the clock resizing
11:16:57 <Pitarou> conal: I saw it referenced in some lecture notes on Advanced Functional Programming, but the link was dead.
11:16:58 <xerox> Gestural programming?
11:17:00 <conal> largos: Pajama supports anything that java 1.4 rus on.
11:17:09 <largos> ah, ok
11:17:20 <dcoutts> conal, xerox and I have had this plan for some time to make a pure layer on top of the existing monadic cairo binding
11:17:26 * xerox nods
11:17:49 <xerox> Featuring a secret ninja-adt tecnique.
11:17:58 <edwardk> heh
11:17:59 <dcoutts> heh, well not that secret
11:18:13 <conal> dcouts: interested in my collaboration on the project?
11:18:39 <dcoutts> conal, I'm a bit short of time, but I'd be happy to advise on the cairo aspects
11:18:45 * xerox welcomes conal in the team
11:18:54 <dcoutts> I can tell you about what we were planning for a pure cairo layer
11:19:01 <dcoutts> it might be relevant
11:19:06 <dcoutts> to what you're planning
11:19:13 <conal> xerox: about gestural programming.  i have a draft paper at http://conal.net/papers/icfp06-submission (rejected for good reasons).  i'm working on a major rewrite of the paper.
11:19:14 <lambdabot> Title: Functional Programming by Interacting with Concrete Values
11:19:38 <conal> xerox: thanks for the welcome.  
11:19:46 <conal> dcoutts: i'd like to hear about the plans
11:20:17 <dcoutts> conal, one advantage of using cairo is that we benifit from the multiple backends (screen, bitmap image, ps, pdf, svg etc) and from other people's hard work on hardware acceleration
11:20:35 <xerox> dcoutts - Come to think of it, weird idea... might RULES be of use to the process?
11:20:44 <conal> about my paper, i really like the work and have a running prototype, but the explanation needs imroving.
11:20:56 <dcoutts> xerox, possibly, for eliminating multiple save/restore operations perhaps
11:21:02 <xerox> Yah.
11:21:07 <xerox> conal - Does it run on OS X?
11:21:11 * xerox waves to paolino 
11:21:40 <conal> xerox: my new stuff (gestural programming), which i call "eros", runs on wxHaskell
11:21:44 <Pitarou> Is there anybody here who is familiar with Monads and continuations, who would like to help me to understand some lecture notes?
11:21:55 <dcoutts> conal, cairo is vector rather than the declarative bitmap style of pan
11:22:09 * paolino jumps in the water
11:22:15 <xerox> Pitarou - Sure, just ask, many here grok both the concepts.
11:22:20 <conal> i think sean seefried has gotten eros to run on os x, but with some difficulty
11:22:39 <xerox> If the two talk overlap too much we can use #haskell-overflow for cairo, I think.
11:22:42 <paolino> and waves back
11:22:48 <Pitarou> The notes I'm referring to are at: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lec-20051118.html
11:22:51 <lambdabot> Title: Advanced Functional Programming - Lecture Notes, Fri Nov 18
11:23:00 <SamB> is gestural programming especially designed for italians?
11:23:03 * Pitarou pats lambdabot on the head.
11:23:18 <conal> dcoutts: vector is fine.  will get better performance than my highly optimized image stuff for big windows.
11:23:32 <paolino> and  for zidane ?
11:23:50 <dcoutts> conal, it's a bit like the model in SPJ's "Pictures: a simple structured graphics model"
11:23:51 <Pitarou> My question is, in the definition of bindC (the bind operation in the continuations monad), isn't the definition equivalent to "m `bindC` k = m k"?
11:24:09 <dcoutts> conal, except that we don't explictly keep the structure
11:24:13 <xerox> bindC :: C a -> (a -> C b) -> C b
11:24:14 <xerox> bindC m k  = \ c -> m (\ a -> (k a) c)
11:24:48 <dcoutts> conal, ok so cairo provides an immediate mode imperitinv drawing api, much like that of pdf
11:24:54 <Pitarou> xerox: That's the one.
11:25:04 <Pitarou> type C a = 
11:25:05 <dcoutts> conal, but we can make a pure layer on top of that
11:25:08 <xerox> No, it is more like m . k, Pitarou.
11:25:13 <Pitarou> (a -> r) ->r
11:25:20 <dcoutts> conal, with pure functions like: rotate :: Double -> Pic -> Pic
11:25:24 <xerox> ?pl \m k -> \c -> m (\a -> (k a) c)
11:25:24 <lambdabot> (. flip) . (.)
11:25:31 <xerox> Yay, not even that, sorry.
11:25:49 <dcoutts> conal, then the only imperitive bit is at the top level where we render a pic: render :: Pic -> Render ()
11:26:01 <conal> dcoutts:  that's what i had in mind also
11:26:30 <conal> i'd really like the library to have a clear & simple semantics
11:26:47 <dcoutts> conal, the existing cairo binding provides the Render monad and operations for creating various kinds of surfaces image, X, ps, pdf, svg etc
11:26:51 <dcoutts> conal, right, us too
11:27:20 <dcoutts> conal, while the impritive cairo api is quite usable, it could be greatly improved by making it pure and using types to prevent common mistakes
11:27:20 <xerox> Pitarou - Simply said, the returnC operation creates a continuation which passes the value on, while the bindC operation adds the bound function into the continuation chain.
11:27:21 <conal> dcoutts: terrific.  not everyone cares about semantics
11:28:24 <dcoutts> conal, on of the best things about the existing cairo C api is the save/restore operations which allow for modular graphics operations
11:28:25 * Pitarou concentrates on parsing xeros's sentence, in the hope that it will make sense to him.
11:28:35 * xerox heads to dinner
11:28:41 <dcoutts> conal, and that's what we'd use to build the pure layer
11:28:51 <xerox> Maybe take a look at this, Pitarou <http://www.nomaware.com/monads/html/contmonad.html>.  Later.
11:29:03 <Pitarou> Thanks, xerox!
11:29:14 <conal> dcoutts: sure.  i've programmed against a bunch of apis like that over the years.
11:29:14 <Pitarou> I'll look into it.
11:29:38 <conal> the awful thing is that graphics programmers think that way: push, draw, pop.
11:29:43 <dcoutts> conal, eg: rotate d (Pic p) = Pic (Cairo.save >> Cairo.rotate d >> p >> Cairo.restore)
11:30:10 <dcoutts> conal, right, but it makes a translation into a declarative style quite easy :-)
11:30:13 <xerox> Pitarou - For the sake of correctness, I have to say that the continuation monad is not _really_ used much in Haskell code. Don't mind too much if you can't get your head around it, well, if you are not requested to do it by outside forces :-)
11:30:23 <conal> dcoutts: yeah, it does.
11:30:29 <Philippa_> conal: I think that's really more coders used to OGL?
11:30:44 * Philippa_ wonders if the phrase "programming against an API" was coined by someone working on win16
11:30:48 <Pitarou> Thanks xerox.  Most reassuring.  But it's relevant to what I'm interested in doing (implementing interpreters / DSLs).
11:31:21 <Philippa_> it's still only really relevant for languages that have continuations themselves
11:31:26 <Philippa_> otherwise there's always another way to do it
11:31:40 <Philippa_> hell, even then there is, but otherwise there's always another way that's likely more comfortable
11:31:50 <conal> 10Philippa_:01 most graphics libraries i've seen (2d or 3d) have an explicit notion of "graphics state" (or "device context").
11:32:07 <dcoutts> conal, so, to be clear the monadic layer exists already and this declarative layer is still hypothetical. You can see the current monadic api here:
11:32:07 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
11:32:22 <Philippa_> sure. Fewer of them have an explicit stack of states though
11:32:39 <Philippa_> whereas the matrix stacks in OGL /really/ colour that
11:33:38 <dcoutts> conal, and there are some demos here: http://darcs.haskell.org/gtk2hs/demo/cairo/
11:33:40 <lambdabot> Title: Index of /gtk2hs/demo/cairo
11:33:48 * Pitarou heads off to look at conal's and xerox's references.
11:37:23 <largos> is pancito suited for managing digital images efficiently?  (as in a photo management / viewing app?)
11:38:13 <largos> based on the intro, it seems not, but it looks like the author may be using photographs with it to some degree..
11:38:56 <conal> largos: i don't think pancito is implemented for speed
11:39:44 <conal> dcoutts: got it.  about the hypothetical pure layer, i'd like to start with finding a semantic model.   one prickly question is whether pictures have any notion of "size" and whether they have a rectangular bound.
11:40:06 <conal> that question has been the most problematic one for me
11:40:20 <dcoutts> conal, from cairo's point of view I think it's easier if they do not
11:40:45 <dcoutts> conal, if they do, you will need to calculate it explicitly since cairo does not calculate it for you
11:41:08 <dcoutts> it does of course have a notion of the size of a canvas on which a picture is eventually rendered
11:41:36 <conal> dcoutts: i really mean semantically, not what cairo does
11:42:11 <dcoutts> conal, sure sure, but some semantics will be easier to implement than others :-)
11:42:37 <conal> and some more worth implementing than others :)
11:42:40 <dcoutts> backwards justification I know :-)
11:42:54 <conal> some people really want those sizes in there, and i don't like how they complicate semantics
11:43:28 <conal> i think sigbjorn's & simon pj's model had operations like "beside" and "above" and so relied on a bounding box
11:43:37 <dcoutts> eg if a pic has a size it allows you to do things like place two pics next to each other
11:43:39 <dcoutts> right
11:44:09 <conal> but in a very limited way and tied to axis aligment
11:45:28 <conal> and it reinforces a thinking that imagery has anything at all to do with rectangles
11:45:49 <conal> s/imagery/pictures if you like
11:47:08 <dcoutts> conal, or that it needs to be bounded at all
11:47:25 <conal> dcoutts: yes!
11:48:01 <dcoutts> cairo is comfortable with some unbounded bits, eg unbounded fills/patterns
11:48:08 <dcoutts> though not unbounded lines
11:48:24 <conal> oh -- interesting.
11:48:48 <conal> and maybe infinite picture tilings could be tricky 
11:48:49 <dcoutts> that's possible since ultimately everything is clipped to the size of the target surface
11:49:10 <SamB> so why don't they just do the same with lines?
11:49:20 <conal> samB: exactly!
11:49:25 <xerox> hehe
11:49:52 <SamB> granted, I'm at a bit of a loss for how you'd represent an arbitrary line
11:49:59 <dcoutts> SamB, since drawing lines involves specifying end points, you'd need something else to specify unbounded lines
11:50:00 <conal> with a line equation
11:50:11 <conal> just change the spec
11:50:12 <SamB> those are called "line segments"
11:50:32 <dcoutts> SamB, right, it only does line segments
11:50:38 <dcoutts> cairo I mean
11:50:49 <SamB> I suppose it isn't really much of a problem
11:51:12 <SamB> lines are a bit unwieldy anyway
11:51:13 <conal> we could have a more general spec, with segments, rays & lines, and implement their rendering via line segments once we know the combined modeling & viewing transformations
11:51:23 <conal> or not
11:51:56 <conal> i like half-spaces also
11:52:21 <SamB> oh, like planes in povray?
11:52:23 <conal> and boolean (set) ops on them
11:52:35 <conal> samB: dunno
11:52:43 <SamB> povray planes are solid
11:52:59 <xerox> Let's do hyperplane arrangements!
11:53:01 <SamB> you can do CSG on them
11:53:19 <largos> can anyone suggest a library for loading images in haskell?
11:53:27 <SamB> (which are basically set ops)
11:53:39 <SamB> I suggest someone write a library for loading images in Haskell!
11:53:52 <largos> dang, I was afraid of that ;)
11:54:16 <SamB> I'm sure someone has written a some code that will load SOME kind of image
11:54:24 <conal> largos: looked in HGL?
11:54:27 <largos> yeah, I've found a bunch of little things
11:54:29 <Cale> I wrote a binding to imlib2 at one point
11:54:31 <SamB> what were you going to do with it?
11:54:37 <Lemmih> largos: There's SDL.
11:54:48 <largos> I'm looking at HGL and SDL right now..
11:54:52 <edwardk> back
11:54:58 <largos> I want to build a digital photo management app
11:54:59 <edwardk> heard someone talking about hyperplane arrangements =)
11:55:08 <SamB> heh
11:55:13 <SamB> I have no idea what those are
11:55:24 * xerox points edwardk back to the CT-type-system
11:55:31 <edwardk> computational geometry thing
11:55:37 <largos> (ideally I'd have exif support too...)
11:56:08 <xerox> largos - Hope has imagery code. I think it uses GD.
11:56:16 <edwardk> basically an arrangement of hyperplanes a structure formed by the cells those hyperplane carve a space into, and the various degrees of faces you get from the hyperplane intersecctions
11:56:48 <palomer> @palomer
11:56:49 <lambdabot> Brump!
11:56:58 <palomer> the only possible retort
11:57:12 <largos> xerox: what is Hope? it's a bit ambiguous to google 
11:57:23 <xerox> ?google hope site:bringert.org
11:57:24 <lambdabot> No Result Found.
11:57:29 <palomer> hope is for the hopeless
11:57:29 <xerox> ?google hope site:bringert.net
11:57:30 <edwardk> you wind up reasoning about arrangements typically when when you want to figure out the algorithmic complexity of problems involving arbitrary combinations of things you are arranging
11:57:31 <lambdabot> http://hope.bringert.net/
11:57:34 <xerox> TLDs...
11:57:38 <largos> thanks
11:57:44 <xerox> You're welcome.
11:57:54 <edwardk> if that wasn't clear as mud =)
11:58:18 <xerox> edwardk - I believe it is not only a computational issue.
11:58:30 <edwardk> xerox: there are plenty of non-computational uses as well, true
11:58:54 <xerox> If I remember correctly, I first come touch with them in a geometric combinatorics course...
11:58:59 <edwardk> i just have a computational bias coz i wound up using lots of arrangements of hyperplanes and hyperboloids for visibility problems
11:59:43 <edwardk> i.e. given a bunch of polygons, does there exist a line of sight from one to another that does/doesn't pass through the others, etc.
12:00:15 <edwardk> arrangement arguments give a nice upper bound on the algorithm complexity there
12:00:54 <edwardk> but of course the reasoning is all combinatoric, davenport-schinzel sequences, etc.
12:01:56 <xerox> Crazy mathematicians :-)
12:02:07 <edwardk> heh
12:02:53 <edwardk> yeah, well, when your whole paper is about the existence of (not a construction of) some n^4 alpha(n) algorithm, you clutch at whatever straws you can find ;)
12:07:03 <lisppaste2> cedricshock pasted "Still struggling with that IO monad:" at http://paste.lisp.org/display/22601
12:08:12 <cedricshock> The above is a little long for an example trouble. My basic problem is that I've tried to start wrapping stuff up in data types, and then it doesn't work anymore because (I assume) I'm doing something wrong with the monads.
12:09:16 <cedricshock> I'd really appreciate some help, or a pointer to a tutorial on the IO monad that covers more than concepts (i.e. how to use it with data structures / algorithms)
12:09:45 <edwardk> i see it' looking for the line in the code
12:11:39 <edwardk> you manged to tie yourself into some good knots there =)
12:12:13 <xerox> Just `<-' it ou t.
12:12:16 <xerox> *out
12:12:19 <edwardk> yeah
12:12:55 <edwardk> why are you letting rather than <-'ing?
12:12:58 <cedricshock> So I shouldn't be using the let ht = ? I didn't think I should since it worked with <- with the plain ht.
12:13:06 <cedricshock> Because it got me a shorter error message.
12:13:12 <edwardk> hahah
12:13:15 <xerox> hehehehe
12:13:30 <edwardk> thats coz its dying earlier =)
12:13:37 <edwardk> you have more than one problem i think
12:13:38 <cedricshock> Without it I get "can't match IO aginst Database"
12:13:54 <conal> i like that idea: steepest descent method applied to error message length
12:13:59 <conal> hoping to reach 0
12:14:07 <cedricshock> Oh, I need a return, don't I?
12:14:12 <conal> now we can automate programming!
12:14:30 <cedricshock> Or somethign else to get the databse into an IO monad?
12:15:01 <xerox> conal: hahaha
12:15:20 <xerox> conal: and how do you improve the error-message-length in each step?
12:15:25 <cedricshock> conal: That's how one programs in C (up until the segfault chasing)
12:15:33 <cedricshock> random pertebations.
12:15:51 <xerox> I don't think GHC would converge rapidly.
12:16:00 * xerox scratches his head
12:16:16 <SamB> conal: so now you just have to write the types, classes, and type signatures and the functions will write themselves?
12:16:35 <SamB> hmm, I have my doubts
12:16:40 <xerox> It would be fair to think it diverges in the general case.
12:16:50 <tony2> Well I'm convinced.
12:16:54 <tony2> Absolutely.
12:17:06 <SamB> wouldn't you maybe need to write some kind of tests as well? 
12:17:17 <SamB> QuickCheck and/or HUnit?
12:17:23 <lisppaste2> cedricshock annotated #22601 with "Without the let (using <-) I get this:" at http://paste.lisp.org/display/22601#1
12:17:47 <sjanssen> cedricshock: the defn. for new should be: new = do hash <- Data.HashTable.new (==) Data.HashTable.hashString; return (Database hash)
12:18:01 <xerox> OH, tests.
12:18:04 <conal> samB: depends on your programming style.  make the types hairy enough and type-checking is spec enough
12:18:06 <xerox> Maybe this is aspected-oriented programming?^
12:18:39 <conal> (just bull-sh*tting)
12:19:28 <sjanssen> the previous defn. was an IO action that yields a hashtable within a dictionary.  The definition you want is an IO action that yields a dictionary containing a hashtable
12:19:42 <sjanssen> oops, typo
12:19:57 <sjanssen> nevermind, that's what I meant
12:20:27 <cedricshock> sjanssen: That works.
12:20:53 <sjanssen> it makes the whole program work?
12:21:17 <cedricshock> sjanssen: Yes. So the hash table itself is in the IO monad always?
12:21:31 <xerox> If you put it in, you can't take it out.
12:21:49 <edwardk> yeah, because its internals are all IOrefs and IOArrays
12:21:57 <cedricshock> xerox: Yeah, but I didn't put it in.
12:22:13 <cedricshock> edwardk: Ah, so it's not a purely functional hash table.
12:22:21 <xerox> Right.
12:22:31 <xerox> ?docs Data.HashTable
12:22:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
12:22:53 <xerox> As you see its operations are all in IO.
12:23:09 <edwardk> cedric: yeah, a purely functional hash table would suck to update =)
12:23:17 <xerox> I wonder what `prime' is used for?
12:23:45 <cedricshock> edwardk: Yeah, the O(1) update way gives you O(n) access time.
12:23:45 <SamB> generating hash functions?
12:23:48 <sjanssen> xerox: probably as a modulus in the hash function
12:23:48 <edwardk> hrmm.. a nice ring modulus. lots of number theory stuff... =)
12:24:15 <xerox> Hmmm.
12:24:31 <edwardk> oh
12:24:31 <edwardk> wait
12:24:36 <edwardk> the one in Data.HashTable
12:24:44 <xerox> YEs.
12:24:46 <edwardk> that one is used because its the prime they use for their hash function
12:24:54 <edwardk> which is a pretty dumb idea because theyuse a linear hash table
12:25:01 <cedricshock> edwardk: At least the simplest one I can thing of. It depends on whether or not you have a constant time large memory copy operation. If you can copy n buckets in constant time you can do it.
12:25:04 <edwardk> and linear hash tables respond poorly to prime modulus hashing functions
12:25:26 <edwardk> cedric: i've been slapping together a generic hash table over the IO ST and STM monads
12:25:36 <edwardk> for the last couple of days
12:25:54 <cedricshock> Yeah, I've heard. Sonds like fun.
12:25:57 <edwardk> but i only have the STM version ready> the generic version is suffering from type explosion at the moment +)
12:26:23 <edwardk> i've got like 5-6 parameters on the type and its starting to get insane
12:26:43 <edwardk> i wanted to use class associated types, but they don't appear to be on the horizon yet
12:27:10 <edwardk> haskell reminds me of c++ without type traits templates at times
12:27:39 <cedricshock> You just need a type class for a mutable value, right?
12:27:49 <xerox> What are class-associated-types?
12:28:03 <cedricshock> Or is the real problem in the array for the buckets?
12:28:14 <edwardk> well, currently my hash table takes parameters m a r k v, where m is a monad, a is an array type for that monad r is a value type for that monad k and v are the ey and value types
12:28:37 <cedricshock> It's definitely in the array.
12:28:40 <edwardk> cedric both. i maintain the internal state behind one var lock, and the array itself is some generic MArray type
12:29:12 <edwardk> so i have one for STM variables, but for efficient growth i have a generic class i use there to describe how to grow the array, because the STM case which i care about the most
12:29:21 <edwardk> needs to be handled differetly than the IOref and STref cases
12:30:08 <sjanssen> edwardk: does the monad have to be a parameter of the datatype?
12:30:50 <edwardk> heh,, i think you might have just bought me back a parameter =)
12:31:09 <cedricshock> That sounds like about the right parameters on the type. I really can't imagine it using less unless you implement the array too. Then you'd only need m r k and v.
12:31:56 <edwardk> well, i can't just 'implement the array' coz i have to change the array based on monad. i could theoreticaly make some abysmal array of iorefs or something, but then it sucks for the IO and ST cases
12:32:08 <sjanssen> edwardk: you can also make a MutableTraits class
12:32:13 <xerox> Maybe you just need fundeps?
12:32:14 <cedricshock> My gut tells me it can be done with r, k, and v though.
12:32:16 <sjanssen> I'll hack a sketch up in a second
12:32:21 <edwardk> xerox: using fundeps
12:32:26 <cedricshock> That's with the "abysmal array of IORefs"
12:32:28 <edwardk> fundeps don't let me shorten the type though
12:32:57 <sjanssen> edwardk: damn, you're right
12:33:06 <cedricshock> sjanssen, et. al. Thanks for the help.
12:33:08 <edwardk> sjannsen, i have one that encapsulates the array and variable type
12:33:15 <edwardk> but it doesn't shorten the type signature
12:33:44 <edwardk> actualy with 4 type parameters its a little less daunting i guess
12:33:59 <edwardk> it was just eeming absurd that i was starting to break my type annotations across mmultiple lines ;)
12:34:19 <sjanssen> edwardk: that is pretty bad
12:34:29 <cedricshock> Is there syntax for "currying" a type?
12:34:30 <sjanssen> was the compiler unable to infer the correct types?
12:35:10 <edwardk> sjannsen: it could, but i wanted them for documentation and to force me to get the types right
12:35:19 <edwardk> style decision
12:35:26 <sjanssen> sure, sure
12:35:39 <edwardk> and i have to force the use of the VArray and Var types in the signatures anyways
12:36:08 <sjanssen> you could introduce a traits style class to reduce the size of the class constraints
12:36:12 <sjanssen> that might help a bit
12:36:16 <edwardk> modify :: Varray m a, Eq k => VHT a k v -> k -> (Maybe v -> v) -> m (VHT a k v)
12:36:27 <edwardk> sjannsen: did that, use it in the outer hash implementation
12:36:33 <edwardk> but the inner one only uses the array
12:36:36 <edwardk> so ts not so bad
12:36:40 <edwardk> er Varray should be VArray
12:37:58 <edwardk> modify :: V a r, Eq k => VHash a r k v -> k -> (Maybe v -> v) ->  m () is now the externally visible definition
12:38:05 <edwardk> woops
12:38:11 <edwardk> should still be V m a r there
12:38:20 <edwardk> where V m a r is by type traits class
12:38:44 <edwardk> programming by regexp, whee ;)
12:38:55 <edwardk> er. rather refactoring anyways
12:40:27 <edwardk>     new,     -- V m a r       => (k -> Int) ->                           m (VHash a r k v) 
12:40:27 <edwardk>     fromList,-- V m a r, Eq k => (k -> Int) -> [(k,v)] ->                m (VHash a r k v) 
12:40:27 <edwardk>     insert,  -- V m a r, Eq k => VHash a r k v -> k -> v ->              m (Bool) 
12:40:27 <edwardk>     update,  -- V m a r, Eq k => VHash a r k v -> k -> v ->              m () 
12:40:27 <edwardk>     modify,  -- V m a r, Eq k => VHash a r k v -> k -> (Maybe v -> v) -> m () 
12:40:28 <edwardk>     delete,  -- V m a r, Eq k => VHash a r k v -> k ->                   m (Bool) 
12:40:30 <edwardk>     lookup,  -- V m a r, Eq k => VHash a r k v -> k ->                   m (Maybe v) 
12:40:32 <edwardk>     mapH,    -- V m a r       => ((k,v) -> r) -> VHash m k v ->          m [r] 
12:40:34 <edwardk>     each,    -- V m a r       => VHash a r k v ->                        m [(k,v)] 
12:40:36 <edwardk>     keys,    -- v a r         => VHash a r k v ->                        m [k] 
12:40:38 <edwardk>     values,  -- V m a r       => VHash a r k v ->                        m [v]
12:40:42 <edwardk> doesn't seem so bad for a public interface
12:41:04 <edwardk> typo on keys
12:41:07 <edwardk> but otherwise =)
12:41:31 <edwardk> each/keys/values could be done away with in minimalist fashion i suppose
12:41:58 <xerox_> edwardk - Seems good, maybe it would be cool to also export some istances.
12:42:01 <xerox_> *instances.
12:42:29 <edwardk> type THash = VHash TArray TVar
12:42:29 <edwardk> type IHash = VHash IOArray IORef
12:42:29 <edwardk> type SHash s = VHash (STArray s) (STRef s)
12:42:31 <edwardk>  =)
12:43:12 <xerox> T, I, S .. :-)
12:43:12 <cedricshock> edwardk: I like the inclusion of modify. It is strangely missing from Data.HashTable. It's the first thing I thought of wanting after insert and lookup.
12:43:35 <xerox> edwardk - Could you explain what does STM give to you in the implementation?
12:44:06 <edwardk> well, two different threads can modify values at the same time as long as they don't update the same one
12:44:24 <edwardk> and i don't have any need for explicit locking
12:44:43 <cedricshock> What happens if they both try to modify the same one?
12:44:45 <edwardk> they can clash on simultaneous insertion, but should be able to update largely independently
12:45:10 <edwardk> standard STm thing, the tvar in question notices when one goes to commit and rolls that task back until its safe
12:45:38 <edwardk> so each transaction thinks it has the hash all to itself
12:45:48 <sjanssen> edwardk: the STM array you're using, is it just an Array of TVars?
12:45:57 <cedricshock> So it just happens slower?
12:46:19 <edwardk> yeah, with a little wrapping to make construction go faster than the one on the current concurrent haskell distribution
12:47:02 <edwardk> ced: basically your atomic action gets a world view that looks like nno other atomic actions are happening. you can use the hash table within any stm atomic action and it just 'works' =)
12:47:35 <cedricshock> Neat. Reminds me of erlang.
12:47:48 <edwardk> sjannsen: and i have an explicit grow method in my VArray class that resizes the array by recycling the old TVars
12:48:10 <edwardk> that way its safe to grow the array and still have multiple accessors
12:53:26 <cedricshock> Ok, imagine you want to log a bunch of events, and each of them has a slightly different type (different data associated with it). And each of these types is going to have slightly different "methods" (like displaying the event as text, or producing a bunch of IO actions to attempt to roll back the event, or somesuch) that will be different for the different kinds of events. What language feature grants this sort of "polymorphism"?
12:54:33 <edwardk> you wannt one log to contain all of the events or you want a log parameterized by the type of event?
12:54:39 <cedricshock> Type classes are pretty similar. But I want a list of them. Do I just need a type that is a union of a bunvh of types that all have the same traits/classes.
12:54:48 <cedricshock> One log containing all.
12:55:07 <xerox> edwardk - Sounds amazing.
12:55:20 <xerox> edwardk - In which monad do the actions be wrapped in?
12:55:25 <xerox> Add a `will' there.
12:55:31 <edwardk> xerox: for manipulating the hash table?
12:55:52 <cedricshock> edwardk: Depends on which array / refs you are using, right?
12:55:55 <edwardk> yeah
12:56:16 <xerox> Interesting.
12:56:20 <edwardk> build it with iorefs and ioarrays and it goes in io, stref, starray it goes in st, tvar tarray and it works in stm
12:56:30 <edwardk> that way i can abstract away the mutable context i'm working in
12:56:47 <xerox> So you are basically wrapping a STM-implementation of HashTable around whatever monad.
12:56:48 <edwardk> i hate boilerplate =)
12:57:15 <edwardk> xerox: no, because if you use a different monad i'm not using the stm version, i have a new type of hash table that works in that other context
12:57:27 <cedricshock> I have no idea how to type the sign language sign for "you and me both".
12:57:28 <xerox> Something like that could replace the IO-based implementation of HashMap.
12:57:50 <xerox> cedricshock - It is a product of types, if I understand your question.
12:57:53 <edwardk> thats kinda what i think people were hoping for when i mentioned it
12:58:06 <xerox> edwardk - Is it doable?
12:58:21 <edwardk> well, the stm version works, i'm finihing up the genric version now
12:58:37 <edwardk> the generic version adds the requirement of multiparameter type classes and fundeps 
12:58:47 <edwardk> the simpler THash version is haskell 98 + STM
12:58:50 <xerox> Well, hmm....
12:59:05 <edwardk> so i've kept both
12:59:13 <xerox> If you are using the ST one inside IO code, and doing threading with that?
12:59:46 <cedricshock> xerox: So a product (union) is all I need? So I'm looking at somethign of type AnyLogEvent, how would I get it to do something like "tellMeIfYouThinkItsOkToGoOutside", aqssuming all events are of a type class that has that trait?
13:00:17 <xerox> Do you want a datatype for your log events
13:00:24 <xerox> Add a question mark there :-)
13:00:40 <Philippa_> unless we're going really nuts, unions aren't products - they're sums
13:00:43 <cedricshock> Yes, and I want to know how to make them and use them too.
13:01:03 <xerox> I mean, like: `data LogEvent = Null | Exception String | Message String String String | Info Int String | ...'
13:01:14 <xerox> And this is a sum.
13:01:20 <edwardk> xerox: if yoou use the ST one, then just runST it, etc.
13:01:24 <cedricshock> Philippa_: Yeah, products go wild.
13:01:25 <xerox> Its definition.
13:01:39 <xerox> Usage is done via pattern matching.
13:01:40 <edwardk> asme if you need to use the STM, just atomically() use it
13:01:40 <Philippa_> cedricshock: products, roughly speaking, are tuples
13:01:47 <cedricshock> Ok. Got that.
13:01:52 <xerox> f :: LogEvent -> String
13:02:00 <xerox> f (Info _ xs) = xs
13:02:07 <xerox> If that's what you want to know.
13:02:17 <cedricshock> So I have to write one function that pattern matches against all the types?! That's a real mess to maintain.
13:02:25 <xerox> m :: LogEvent
13:02:32 <xerox> m = Message "me" "you" "die!"
13:02:32 <Philippa_> yeah, sadly it is
13:02:50 <xerox> All the `data constructors', not the `types'.
13:03:17 <Philippa_> though you get used to it. The real problem is with functions that only work on a subset of the constructors (but not one specific one)
13:04:00 <xerox> In |data Foo a = mkFoo a a|, `Foo' is a type constructor of kind * -> *, `a' is a type variable, `mkFoo' is a data constructor of type a -> a -> Foo, and the `a's are again the same type variable.
13:04:23 <cedricshock> yeah, I get it.
13:04:42 <monochrom> If you have n cases of data and m operations, you can barely avoid writing nxm pieces of code.
13:05:07 <Philippa_> yeah, though Haskell does make it easier to factor out the common patterns than in a lot of languages
13:05:22 <cedricshock> So the otehr thing I can do is make a fun type for the method and start building objects with method tables. Then I'm in ucky land.
13:05:39 <Philippa_> some operations can be written in terms of others that work on all cases, in which case you don't need to match
13:05:55 <xerox> That's a sensible solution, if I understand it right.
13:06:26 <Philippa_> yeah, there's a reason Smalltalk-style OO developed from the lisp tradition
13:06:36 <Philippa_> first-class functions are your friends
13:07:04 <xerox> True.
13:07:10 <xerox> G'day monochrom.
13:07:11 <cedricshock> It doesn't sound too terribly ucky, especially if I build all the tables only once and cram them at the heads of things.
13:07:46 <xerox> monochrom - I wonder, what do you think about non-Diophantine arithmetics?
13:08:13 <cedricshock> Og course I can write pattern matching functions that just hand stuff off to other functions so adding an event would be : write the "class" specific methods, add a line to all the dispatcher functions.
13:10:16 <monochrom> I think non-Diophantine arithmetic is hard.
13:11:14 <lisppaste2> erider pasted "take a look" at http://paste.lisp.org/display/22607
13:11:23 <xerox> Hard, hard to believe? &) That was the general consensus here, more or less.
13:12:05 <cedricshock> erider: What's that?
13:12:38 <xerox> I am fascinated by the idea that different foundations could produce a different theory of numbers.
13:12:48 <erider> an exercise that was not working for me 
13:13:16 <dcoutts> sjanssen, dons, did you know that linspire have a parser based on Data.ByteString ? I didn't.
13:13:43 * xerox neither
13:13:49 <xerox> There were new mails from the Linspire guys?
13:14:03 <Lemmih> erider: It looks fine.
13:14:43 <cedricshock> Yeah, it looks fine to me too. I tried it in ghci, and it doesn't work. Is that your problem?
13:15:02 <Philippa_> is it not possible to hint at GHC to inline enough of the toString func for it to effectively become a cheap iterator?
13:22:11 <joelr1> is anyone compiling ghc 6.5 from darcs?
13:22:35 <xerox> Yeah, some crazy people we call `GHC developers'.
13:22:39 <edwardk> heh
13:22:42 <edwardk> did so last night
13:22:50 <joelr1> xerox: like you? :D
13:22:51 <joelr1> question then
13:23:15 <joelr1> what do you guys do about mismatched interface file versions after a darcs pull? do you always make clean and rebuild from scratch?
13:23:23 * xerox looks around, sweating, for a way to escape
13:23:26 <edwardk> heh
13:23:33 <edwardk> dunno, haven't run intothat problem yet
13:23:34 <joelr1> or is there a way to find the *.{hi,o} wih the mismatched versions
13:23:54 <joelr1> edwardk: happens to me almost every time after a './darcs-all pull -a'
13:23:56 <xerox> I think so. Except exceptional cases.
13:24:18 <edwardk> joelr: heh, well, pulled it all in one go, and just built. went to sleep woke up and it was there =)
13:24:28 <edwardk> joelr: not exactly a darcs/ghc expert here =)
13:24:31 <xerox> edwardk - Which architecture?
13:24:34 <joelr1> darn, i guess i'll have to make clean then. surprisingly enough the ghc build is not going much faster on mac intel
13:24:54 <edwardk> linux, pretty standard 32 bit intel set up
13:25:15 <joelr1> edwardk: i can do that too. the question is more of what to do after pulling patches. it's quite tedious to rebuild ghc as you are aware
13:25:23 <edwardk> *nods*
13:25:30 <edwardk> as evidenced by my sleeping =)
13:26:00 <joelr1> even make clean takes a looooong while
13:26:07 <edwardk> yeah
13:26:23 <pejo> joelr1, compared to a g4, or something else?
13:26:39 <xerox> joelr1 - Check the patches while pulling, and then delete the sensible files.
13:26:41 <xerox> That's way too raw, by the way.
13:26:46 <joelr1> pejo: both 
13:27:18 <joelr1> xerox: that requires continually typing make, waiting a minute and then deleting *.hi and *.o that it fails on
13:27:23 <joelr1> there's gotta be an easier way
13:32:45 <Lemmih> joelr1: Rebuilding GHC doesn't take that long.
13:33:07 <joelr1> Lemmih: he :-) i want to believe you 
13:33:10 <Lemmih> joelr1: You should be able to rebuild stage2 in a couple of minutes.
13:33:32 <joelr1> Lemmih: how do you rebuild stage2?
13:33:41 <joelr1> in a couple of minutes
13:33:46 <Lemmih> joelr1: Enter compiler/ and run 'make clean stage=2'
13:33:57 <joelr1> Lemmih: i usually re-build, install and then use that after pulling
13:34:18 <joelr1> Lemmih: and then make at the top/
13:35:44 <Lemmih> Yes.
13:36:36 <joelr1> Lemmih: does that avoid the mismatched versions errors? because they happen in stage1 it appears
13:36:43 <joelr1> at least the complaints are about stage1 files
13:37:49 <Lemmih> Oh, right. You either need to clean stage1 or run 'make stage=2' in compiler/.
13:37:56 <xerox> Building one's own GHC would be nice..
13:38:48 <joelr1> Lemmih: which approach is better? it would appear that by not cleaning stage1 you are letting it rot so to speak
13:41:18 <Lemmih> joelr1: Cleaning stage1 is the Right Way but jumping ahead to stage2 might save you some time.
13:42:39 <joelr1> Lemmih: but cleaning stage1 is basically rebuilding from scratch, no?
13:43:30 <SamB_XP> joelr1: yep
13:45:15 <joelr1> well, i'm timing a full ghc rebuild on my brand spanking new 2gb 17" mbp with a 7200rpm drive
13:52:57 <edwardk> heya cm
13:53:15 * edwardk cracks the hsjudy whip ;)
13:53:25 <cmarcelo> hello
13:55:40 * cmarcelo is wondering what edwardk means... (i'm a pt_BR speaker, and bad bad en_US reader)
13:55:58 <cmarcelo> s/means/meant by crack the whip/ =P
13:56:08 <edwardk> cracking the whip is sort of a way to say tries to get you to work faster
13:56:29 <edwardk> it historically refers to the process of whipping the horse pulling a cart to get it to move faster
13:56:50 <cmarcelo> oh hehe =)
13:57:23 <edwardk> i will try to be careful with idioms
13:58:18 <cmarcelo> actually, is better using idioms so I can learn more.
14:02:42 <edwardk> bah
14:02:57 <edwardk> i can't use the standard TArray implementation, time to clone it so i can get access to the type constructor =)
14:03:30 <edwardk> i went and threw away my custom version of it and then, lo and behold needed it anyways =/
14:11:02 -BoDiUSA(i=BoDi@cpe-24-58-194-194.twcny.res.rr.com)- 4Duble Click On The Red 4,4 http://www.speedyshare.com/654868402.html 4Save Cristina.exe , Then Open And Watch the Best Prono Movie Ever
14:12:26 <palomer> dude, the best porno ever is Jessica.exe
14:15:17 <palomer> quick, someone remind me record syntax
14:15:18 <palomer> go!
14:15:43 <edwardk> Foo { name :: Type, name2 :: Type }
14:15:53 <palomer> kthx
14:16:26 <edwardk> Foo { name = value, name2 = value }  to make one then record { name = value' } to update, where record is an instance of the record type
14:16:57 <palomer> any other tricks?
14:17:01 <edwardk> thats bout it
14:18:50 --- mode: ChanServ set +o Igloo
14:19:01 --- mode: Igloo set +c
14:20:09 <Heffalump> +c ?
14:20:18 <Igloo> Colour filtering
14:21:57 <palomer> man, this Christina.exe flic is pretty good
14:22:40 * ptolomy will check it out when he gets Parallels running.
14:22:53 * joelr1 is running parallels
14:23:29 * bringert too
14:24:20 <bringert> is there a reasonably portable way (glibc function or equivalent) to the the memory use of the current process?
14:25:41 <edwardk> not afaik
14:26:04 <woggle> bringert: On Unix-likes, getrusage().
14:26:26 <edwardk> ah doh, forgot that =)
14:26:33 <bringert> woggle: thanks, just what I was looking for!
14:43:18 <ihope> So are there any practical purely functional languages with dynamic typing?
14:43:56 <Heffalump> purely in what sense?
14:44:23 <ihope> No side effects.
14:44:36 <ihope> Not "nothing but functions" :-)
14:45:17 <edwardk> i can't think of anything at that point in the design space. i'm sure someone has one though
15:01:04 <ihope> Why don't I just sort of invent one...
15:01:22 <edwardk> sound good
15:01:28 <edwardk> i'd probably even use it =)
15:01:47 <edwardk> i think though
15:01:47 <bringert> hmm, I can't get getrusage(2) to give me anything but 0s
15:01:50 <bringert>   struct rusage ru;
15:01:51 <bringert>   getrusage(RUSAGE_SELF, &ru);
15:01:51 <bringert>   printf("%ld %ld %ld\n", ru.ru_maxrss, ru.ru_idrss, ru.ru_isrss);
15:01:56 <edwardk> that its an awkward point i the design space
15:02:00 <bringert> just prints out zeros
15:02:27 <bringert> (this is not all that OT I think, I want to do it in a haskell program)
15:02:41 <ihope> edwardk: why?
15:03:03 <edwardk> wewll, if its fully dynamic there goes HM. imagine haskell that doesn't check your types =)
15:03:50 <edwardk> it sounds like a debugging nightmare
15:04:02 <ihope> Just don't make any mistakes :-P
15:04:18 <xerox> I'd check the code in a copy of GHC I kept secretly.
15:04:19 <Philippa_> a strict one wouldn't be so crazy
15:04:28 * xerox laughs evilly
15:04:48 <ihope> xerox: if it typechecks, why not just use Haskell for it? :-)
15:05:30 <xerox> edwardk - Maybe someone would write a language which typechecks in that language.
15:06:36 <edwardk> i think the whole idea was to look at lazy dynamic, rather than strict dynamic though
15:06:54 <tony2> bringert, getResourceLimit from System.Posix.Resource?
15:06:59 <ihope> More like dynamic and pure.
15:07:07 <edwardk> yeah
15:07:48 <edwardk> well
15:07:53 <edwardk> dynamic and pure == erlang, no
15:07:55 <edwardk> ?
15:08:00 <Philippa_> not quite
15:08:01 <ihope> Dunno.
15:08:10 <Philippa_> erlang's thoroughly impure in the large, it's only pure within a process
15:08:16 <edwardk> oh wait
15:08:19 <edwardk> nm =)
15:08:20 <edwardk> yeah
15:08:30 <edwardk> i meant dynamic and strict
15:08:37 <edwardk> i keep tripping over my tongue today
15:10:21 <ihope> You must have a long tongue, then.
15:10:33 <edwardk> yeah, hard to type with
15:13:48 <bringert> tony2: I want the current usage, not the limit
15:15:17 <bringert> but resource limits would also be nice actually
15:18:24 <tony2> bringert, ahh, sorry didn't read properly ;) been making wine this evening (which, of course, necessitates drinking wine).
15:18:56 <edwardk> wht is the return value rusage is giving you bringert?
15:19:03 <bringert> 0
15:19:26 <bringert> edwardk: I'm on OS X, I'm thinking that maybe it doesn't implement those fields
15:19:46 <edwardk> ahh
15:19:55 <edwardk> coz my linux test case works fine
15:20:03 <bringert> I will test in my Linux VM
15:22:20 <edwardk> wheee, back to parameter creep
15:31:09 <lispy> which FFI type corresponds to void *?
15:32:28 <dcoutts> Ptr ()
15:32:54 <lispy> thanks
15:32:57 <Igloo> Ptr a really
15:33:35 <dcoutts> depends on if/how you think it should convert
15:37:23 <ihope> Can you make variables that hold void?
15:37:38 <ihope> Like, in C?
15:38:10 <ptolomy> Does GHC run well on OS X?
15:38:16 <dcoutts> ihope, () ?
15:38:24 <edwardk> well, you can hold a void * but not a void in c =)
15:38:36 <dcoutts> ihope, or you can define a data type with no values appart from _|_
15:38:59 <dcoutts> ihope, at least you can with ghc, it's an extension. data None
15:44:45 <lispy> so i'm following this example: http://darcs.haskell.org/packages/Win32/System/Win32/Info.hsc
15:45:14 <lispy> the line (#poke SYSTEM_INFO, dwPageSize) buf (siPageSize si) doesn't make sense to me
15:45:18 <lispy> what is dwPageSize
15:45:30 <lispy> am i defining it there or was it already defined?
15:46:08 <lispy> perhaps that's part of the C code that is befing referenced?
15:46:16 <Lemmih> It's a field in SYSTEM_INFO.
15:46:26 <Lemmih> (Or so I think)
15:46:27 <lispy> okay, i think i get it
15:46:53 * lispy goes back to work until he has to define peek
15:47:52 <edwardk> you know a corner of the language needs more thought when you think to yourself it would be faster to use the c preprocessor and macros
15:48:43 <edwardk> and the result would probably run faster =/
15:49:27 * mux wonders why haskell code would need to know the page size
15:50:06 <edwardk> database code, etc.
15:50:20 <edwardk> but yeah
15:50:23 <edwardk> good question =)
15:50:30 * lispy is writing bindings for the Common Dialog Boxes in win32
15:50:59 <mux> and I don't see why database code in haskell would wnat to know the page size except for optimizations that don't belong in such a language :-)
15:51:34 <edwardk> optimizations belong in every language, done by someone with considerably more free time than me ;)
15:51:35 <dcoutts> mux, such optimisations are important
15:51:58 <mux> yes, but if you are to do them, you want to write C in the first lpace
15:51:58 <dcoutts> they make measurable differences in the Data.ByteString lib
15:52:25 <dcoutts> tuning for cache sizes etc can make quite a dramatic difference
15:52:37 <mux> it makes no sense to try to control very low-level stuff like this when the mere runtime of your code might do billions other things
15:52:42 <edwardk> nah, just because i know the nature of the machine i'm running on doesn't mean i want to write in a strict language with a clunky type system =)
15:52:48 <edwardk> and go imperative
15:52:54 <mux> does Data.ByteString ever deals wit page size?
15:53:31 <dcoutts> mux, not the page size directly, at the moment, but other memory things
15:53:51 <dcoutts> mux, it'd be a reasonable choice to make the Data.ByteString.Lazy chunk size exactly the page size
15:53:59 <mux> I don't know for "other things" but getting the page size in haskell sounds like it's not a good idea
15:54:10 <int-e> Data.ByteString is great. It's an example that with Haskell you don't need to hack the compiler to hide a lot of interesting optimizations in a library with a pretty clean interface.
15:54:20 <mux> it sure is :-)
15:55:06 <xerox> True!
15:55:20 <dcoutts> right, in a low level lib like that we do actually know what's going on, it's not doing a billion other things
15:55:22 <mux> I really don't even like userspace knowing the page size... consider many modern architectures support various different page sizes anyway
15:55:42 <mux> as a hint for allocation sizes or such, it's okay though
15:55:47 <dcoutts> mux, but they're always a multiple of the min page size
15:55:52 <mux> sure
15:56:10 <dcoutts> yeah, it's a tuning thing, not a correctness thing
15:56:27 <dcoutts> as such it's perfectly reasonably imho
15:56:38 <mux> yeah, I agree if it's only that
15:57:09 <mux> but what really horrifies me - I'm digressing a bit here - is the Linux syscalls for handling big pages
15:57:25 <mux> what a heck of a wrong idea
15:58:07 <dcoutts> you mean the hugepagefs
15:58:20 <mux> that and there are a few syscalls IIRC
15:58:32 <dcoutts> there are? I didn't know about those
15:58:39 <mux> let me look that up
15:58:44 <dcoutts> I thought it was just an add-on virtual fs
15:59:04 <mux> alloc_hugepages, free_hugepages
15:59:08 <dcoutts> which is quite modular and can be dropped when something better turns up
15:59:28 <edwardk> there is something to be said for being able to map a 2 meg page when you need to
15:59:32 <mux> they really need to know about the superpages stuff of Alan Cox (the FreeBSD one, not the Linux one)
15:59:37 <int-e> mux "The system calls alloc_hugepages() and free_hugepages() were introduced in Linux 2.5.36 and removed again in 2.5.54."
15:59:45 <mux> int-e: ah, good news
16:00:01 <edwardk> well, then that solves that =)
16:00:01 <mux> they're still exposing way too much shit to userland via hugepagefs then
16:00:22 <dcoutts> yeah, it's not a transparent solution
16:00:37 <dcoutts> you'd only use it if you were desperate for that extra 5%
16:00:40 <dcoutts> eg oracle
16:00:49 * mux nods
16:01:10 <edwardk> and thats a demographic that linux is trying hard to please these days.
16:01:18 <mux> dcoutts: http://www.cs.rice.edu/~ssiyer/r/superpages/
16:01:21 <lambdabot> Title: OSDI 2002: Practical, transparent operating system support for Superpages
16:01:26 <int-e> linux is too big to be nice. too many people, too many interests involved.
16:01:38 <mux> FreeBSD is getting that *soon*
16:01:45 <dcoutts> mux, yeah I was going to say I think I saw some suggestion on LWN about doing it transparently
16:01:57 <mux> alan is nearly done merging/adapting this in HEAD in a private branch
16:02:21 <mux> I hope for their own sake they'll do something similar
16:02:50 <dcoutts> if FreeBSD do it and it works out then I expect the linux hackers will give it a go too
16:03:01 <dcoutts> they usually do
16:03:35 <mux> at the time this paper was written it was done for FreeBSD 4.x and as you can see in the paper it yielded very significaznt performance improvements for real world workloads
16:04:40 <mux> that was mainly for alpha though
16:04:46 <mux> not so useful for x86/amd64
16:04:49 * wli groans
16:05:03 <wli> Yeah, superpages are doorstops on x86 et al.
16:05:21 * wli == hugetlbfs maintainer
16:05:25 <mux> and because of TLB limitations in sun4u MMUs it probably unfortunately won't help much there
16:05:29 <mux> wli: blaaaaah
16:05:37 <mux> vade retro satanas :D
16:06:46 <wli> I've not seen perf. stats on sun4u hugetlbfs.
16:07:03 <mux> AFAIK, you can only have one page size per TLB there
16:07:10 <mux> so it can't really help
16:07:17 <mux> but USIII CPUs have two TLBs
16:07:23 <mux> dunno for sun4v
16:07:30 * wli should write arch support for hugetlbfs on sparc32 sometime (I'm also the sparc32 maintainer).
16:07:47 <mux> no, you should implement a transparant way to deal with that in the kernel :-)
16:07:54 <wli> Solaris has a relatively full-fledged superpages affair.
16:08:12 <wli> mux: That's also happening, but it's a longer-term affair.
16:10:31 <wli> mux: I was hacking on the real deal when Intel came out with their gunk. Word came down that the real deal was dead and that I'd better clean the thing up, and then I got stuck with the turd known as hugetlbfs.
16:11:07 <mux> Intel wrote hugetlbfs?
16:11:29 <wli> Intel wrote the alloc_hugepages() and free_hugepages() garbage.
16:11:34 <mux> ewww
16:11:41 <mux> the mean bastards
16:12:07 <wli> Linus went "I want that. It's simple. Forget multiple pagesize support."
16:12:11 <wli> And it was dead.
16:12:11 <mux> these guys are doing serious damage in the open source codebase
16:12:31 <wli> So then followed an outcry from all quarters.
16:12:38 <mux> omg
16:12:46 <wli> Linux people were screaming that it was broken beyond repair.
16:13:00 <mux> I fully believe that
16:13:06 <mux> if it was written by Intel :-)
16:13:11 <MarcWeber> The php manuel says I shuold look at the pear code of latest php distribution to see some examples on how to use include/include_once. I've downloaded php source now. Where can I fnid this pear code? I did find the pear folder containing a installpear.phar.
16:13:15 <wli> ISV's (Oracle, IBM) screamed bloody murder because they couldn't use the interface.
16:13:21 <mux> I had some fun with a few NIC drivers they wrote for FreeBSD
16:13:24 <mux> horrible
16:13:35 <wli> I got commanded on pain of getting canned to reshape it into hugetlbfs.
16:13:44 <mux> I feel you
16:13:45 <wli> With word from on high as to the form of it.
16:13:45 <MarcWeber> Sry wrong channel
16:14:19 <dcoutts> wli, so sun4u can't use multiple page sizes at once? ie some 8k, some 64k etc
16:14:21 <wli> I'd written patches that were in the aggregate multi-megabyte for multiple pagesize support.
16:14:30 <mux> dcoutts: only if you have several TLBs
16:14:41 <wli> dcoutts: Some models can.
16:14:44 <mux> like with usIII CPUs
16:14:52 * mux wants a sun4v box
16:15:15 <wli> I'd been grinding away at full-blown superpages for 6 months or something on that order.
16:15:16 * dcoutts has UltraSparc IIe
16:15:22 * mux too
16:15:27 <mux> IIe 500 MHz Netra
16:15:40 <dcoutts> SunBlade100 here
16:15:46 <mux> :-)
16:15:51 <mux> it's dead slow though
16:16:00 <mux> what really makes me so fucking happy is the LOM
16:16:01 <dcoutts> 500Mhz
16:16:05 * wli has an UltraEnterprise 3000.
16:16:11 <mux> power-on !
16:16:14 <mux> zoooooooooooom
16:16:29 <mux> that makes any x86 box look like coffee machine
16:16:32 <edwardk> woops
16:16:33 <edwardk> wasn't here
16:16:42 <wli> The E3K is not all that fast.
16:16:59 <mux> a dodgy coffee machine, even
16:17:26 <edwardk> did lisppaste2 show something for me just now? first time using it
16:18:15 <mux> Sun has been kindly donating several sun4u for use by the FreeBSD project
16:18:20 <wli> Anyway, I basically want to do CGI apps with cookies.
16:18:21 <mux> err, sun4v
16:18:25 <mux> obviously :-)
16:19:01 <wli> mux: I wouldn't mind a sun4v for hacking on Linux... I asked them about it at an OracleWorld conference a while back, but they weren't terribly interested.
16:19:46 <mux> I think they like us because we have dtrace working pretty well now
16:19:49 * wli <--- @oracle.com and formerly @ibm.com
16:19:49 <mux> heh
16:20:14 <mux> maybe they're contemplating dropping their shit
16:20:46 <wli> Anyway, wrt. Haskell stuff, I think I need database code for the CGI apps with cookies.
16:23:25 <lispy> wli: ah did you like working at ibm?
16:23:38 <lispy> wli: i interned there and thought it was...interesting and painful at the same time
16:23:46 <edwardk> figured out the paste bug.. superfluous return
16:24:07 <wli> lispy: It was pretty good until certain people started bothering me.
16:24:24 <edwardk> heh, isn't every work place? =)
16:24:34 <wli> No. I've not had a problem at Oracle.
16:25:21 <mux> wli: are you in sunnyvale at oracle?
16:25:40 <mux> the oracle towers there have nice restaurants
16:25:44 <wli> mux: Actually wrt. Sun and Oracle the issue was that they send all the hardware to the ppl@oracle.com who do Solaris/Oracle werk.
16:25:58 <wli> mux: No, I'm a remotee.
16:25:58 <dcoutts> wli, so Oracle are interested in linux beyond merely x86/x86_64 ?
16:26:26 <wli> dcoutts: yeah, pSeries, zSeries, and ia64.
16:26:57 <dcoutts> but for sparc it's solaris rather than linux I suppose (it'd make quite a bit of sense)
16:26:58 <wli> dcoutts: UltraSPARC/Oracle is 100% Solaris with no plans of touching Linux there.
16:27:03 <dcoutts> right
16:27:45 <dcoutts> is Oracle interested in those new 32 core sun4v boxes? does all that threading help dbs?
16:27:50 * wli wonders which Haskell database packages are mature/usable/nice-to-use.
16:28:06 * dcoutts packages HDBC & HSQL for Gentoo
16:28:21 <dcoutts> I'd probably reccomend HDBC
16:28:31 <wli> dcoutts: As far as I know Oracle is more concerned with OS interfaces than pure hardware.
16:28:57 <dcoutts> wli, I see
16:29:16 <lispy> wli: i had some real problems with the automation they used and HR couldn't resolve them...that was the painful part
16:29:42 <wli> lispy: Took a couple years for some clerical errors at hiring to get fixed here, too.
16:30:00 <lispy> i hate that...
16:30:10 <wli> They sure clean up clerical errors made when you quit/etc. quick, though.
16:30:26 <dcoutts> wli, HSQL has more backends that HDBC (including Oracle) but I think the HDBC api is nicer
16:30:31 <dcoutts> both are reasonably mature
16:30:59 <wli> I don't care too much about the database apart from "not MySQL or BerkeleyDB"
16:31:25 <zarvok> @type let func f x = (z,y) where (z,y) = f x in func
16:31:26 <lambdabot> forall t a b. (t -> (a, b)) -> t -> (a, b)
16:31:47 <wli> (Well, I don't really use Oracle or any database outside of work, but could probably get full-on everything if I wanted.)
16:31:58 <dcoutts> wli, HDBC does Sqlite3, ODBC, Postgresql and some other that I don't recall
16:32:19 <lispy> dcoutts: HDBC is nicer interface than HSQL?  i'm using HSQL now and it's a bit tedious at times...maybe i should switch
16:32:47 <wli> Is there a current website for it?
16:32:51 <dcoutts> lispy, that's my impression, might be worth giving it a go, feedback to CosmicRay
16:32:57 <dcoutts> @where hdbc
16:32:57 <lambdabot> I know nothing about hdbc.
16:32:58 <wli> The one linked from haskell.org is a 404
16:33:19 <lispy> dcoutts: if you could show me the haddock for it that would be enough for me to get an idea
16:33:42 <dcoutts> CosmicRay, your hdbc site seems to have moved or be down
16:33:46 <dcoutts> http://quux.org/devel/hdbc/
16:34:40 <lispy> yeah, that's a 404
16:34:46 <dcoutts> lispy, the docs were on that site :-(
16:34:52 <lispy> guess i'll keep with HSQL for now :)
16:35:13 <lispy> i waned to use HaskellDB...but that requires compile time knowledge of your database schema
16:35:29 <lispy> i only know parts and i have to adapt whet something is missing
16:36:10 <wli> I just fix bugs for a database vendor, I don't actually know squat about databases apart from back-end on-disk datastructures.
16:36:16 <wli> Kernel bugs.
16:51:44 <lisppaste2> edwardk pasted "inferred type less polymorphic than expected" at http://paste.lisp.org/display/22613
16:52:03 <audreyt> wow, you run into this that soon
16:52:13 <edwardk> ?
16:52:16 <audreyt> without looking at code, it usually means you need to write out params
16:52:26 <audreyt> instead of currying
16:52:35 <edwardk> how do you mean
16:53:08 <edwardk> oh wait
16:53:09 <edwardk> i see it
16:53:13 <edwardk> nevermind
16:53:13 <edwardk> heh
16:53:15 <audreyt> np :)
16:53:20 <edwardk> the proccess of copying it proves me to be an idiot =)
16:53:53 <edwardk> because it shows right where in the code i need to look
16:54:53 <edwardk> basically been generalizing that hash code to work in arbitrary environments so it can run in IO ST or STM with an appropriate var/ref type and array implementation
16:55:14 <edwardk> but one of my efforts at simplification is biting me in the ass
16:58:20 <edwardk> but right now its more turning into an object lesson in 'why haskell needs class associated types' =)
16:59:06 * vincenz waves
16:59:25 * lispy waves back
16:59:35 * lispy thinks he has no clue how to assist edwardk
17:01:04 <edwardk> appreciate the attempt =)
17:01:42 <edwardk> i still find it funny that it seems the optimal solution is to use the c preprocessor and cut out all this haskell crud in the middle ;)
17:02:02 <lispy> edwardk: then consider hsc@sh
17:02:03 <edwardk> i could cleanly generalize the old interface in like 8 lines with cpp and an include file =)
17:02:06 <lispy> er hsc2hs
17:02:21 <lispy> well, or TH
17:02:27 <lispy> not sure exactly what you have or what applies
17:02:42 <bitvector2> hi folks can someone help me bootstrap 6.4.2 on Solaris 10 x86?
17:02:46 <lispy> TH will let you manipulate haskell syntax trees tho
17:02:47 <bitvector2> ghc that is
17:03:08 <lispy> bitvector2: i've never tried so i'm not much help there :(
17:03:40 <edwardk> well, in my case i want something that works perfectly well with STM, TArray, and TVar to switch to the equivalent IO IOArray IORef and ST STArray STRef
17:03:56 <edwardk> the 'right' way to do it in haskell without template haskell or some form of extension is pretty painful
17:04:14 <edwardk> i wind up needing multiparameter type classes, fundeps, etec.
17:04:24 <edwardk> because we don't have class associated types
17:08:22 <bitvector2> lispy: do you know anyone in particular here that has bootstrapped or ported?
17:08:41 <edwardk> yeah i think template haskell will solve my problem
17:09:27 <xerox> vincenz: how's your category theory going? :)
17:09:36 <vincenz> ?
17:09:47 <edwardk> xerox == category theory fanboy =)
17:10:01 <vincenz> ah
17:10:03 <xerox> I was seaerching for something and I found you discussing of CT books with Pseudonym in the #haskell logs.
17:10:07 <xerox> (Google brought me there.)
17:10:19 <vincenz> I'm at aconference in canada actually
17:10:42 <xerox> Barr & Wells, if I am not mistaken.
17:11:00 <xerox> Prepend a "You were reading".
17:11:09 <vincenz> amongst others
17:11:23 <xerox> How's it coming along?
17:11:32 <xerox> I am finding it nice too, I am at the very beginning, though.
17:11:33 <vincenz> I kinda gave that up, the reading
17:11:43 <xerox> Ow.
17:11:46 <vincenz> I've turned to evolutionary biology
17:11:49 <vincenz> and now zen
17:12:23 <xerox> I'm reading a book on Taoism too.
17:13:04 <vincenz> anyways
17:13:11 <vincenz> tomorrow /me flying back of the big blue pond
17:15:40 <lispy> bitvector2: sorry :(
17:15:51 <lispy> bitvector2: dons might know someone like that
17:19:22 <tony2> bitvector2, I recall chat on the ghc-users mailing list recently, from Christian Maeder about a bug with 6.4.2 on solaris
17:20:49 <bitvector2> tony2: I'm readin up on that now.  I guess I'll have to try a snaphot?
17:21:18 <tony2> bitvector2, yes, I think the bug was -threaded related, do you need that?
17:21:39 <bitvector2> not yet I just want to get up an running first
17:21:53 <bitvector2> is nabble the proper place to reading this stuff?
17:22:06 <tony2> bitvector2, then the snapshot should be fine
17:22:43 <tony2> bitvector2, nabble?
17:22:58 <bitvector2> ok that answers my question :)
17:23:11 <bitvector2> nabble is just some forum to web place I found on google
17:23:31 <tony2> ok, well if it's just logs I expect that's fine.
17:24:34 <bitvector2> btw what is RTS? and -threaded exactly?
17:24:39 <tony2> -threaded is for OS threads
17:24:54 <tony2> RTS stands for run time system
17:25:16 <bitvector2> so ghc -threaded will automatically thread certain things at compile time?
17:25:16 <tony2> native threads work fine I think, but that's just from recollection.
17:25:56 <tony2> umm, no the threaded ghc is only useful cos ghci (the interactive environment)
17:26:26 <bitvector2> so where is the threading being applied that we are talking about?
17:26:45 <tony2> is the same excecutable, and having OS threads allows ffi calls which block to be used.
17:26:59 <vincenz> ....
17:27:24 <tony2> bulding ghc with -threaded only really matters for the interactive environment afaik.
17:27:47 <bitvector2> what if I want to use POSIX threads in code that I write?
17:28:25 <vincenz> how long does a basseball game last?
17:28:38 <tony2> bitvector2, I don't know if the bug will bite you. But there are native threads.
17:28:50 <bitvector2> ok
17:29:05 <bitvector2> I don't need any kind of threads at first anyways
17:31:16 <wli> teen lingerie is taking off
17:31:22 <wli> sounds like a good investment
17:31:37 <wli> Victoria's Secret even uses prison labor so their wage overhead is virtually nil
17:31:45 <wli> ARGH
17:39:52 <bitvector2> how do I build the *.hc files for ghc?
17:40:04 <bitvector2> I just finished compiling and they aren't there!
17:40:52 <tony2> bitvector2, there is a keep hc files option.
17:43:55 <bitvector2> what is it? it doesn't show up in ./configure --help
17:45:37 <tony2> bitvector2, it's a ghc option not a configure option, -keep-hc-file  I think.
17:46:00 <tony2> bitvector2, http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
17:46:01 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.4.2
17:46:55 <tony2> bitvector2, there is a chapter on options.
17:48:01 <tony2> bitvector2, good luck, I'm going to hit the hay.
17:48:14 <lisppaste2> lispy pasted "What is wrong with the Storable instance declaration?  I'm getting a weird error" at http://paste.lisp.org/display/22615
17:49:39 <lispy> any ideas why i'm getting that compiler error?
17:49:57 <lispy> i can't understand why it thinks OPFNHOOKPROC is undeclared
17:50:08 <lispy> oh, maybe i don't include the right header
17:50:41 <lispy> no that shouldn't be it
17:51:41 <Lemmih> lispy: const {#size OFNHOOKPROC}, maybe?
17:52:04 <Lemmih> lispy: What does the output of hsc2hs look like?
17:54:04 <lispy> Lemmih: it doesn't seem to leave output
17:54:35 <lispy> Lemmih: the only hsc output i see for that file corresponds to when i have the storable instance commented out
17:57:59 <lispy> Lemmih: interesting like looking in commdlg.h that is supposed to define that struct it's missing
17:58:07 <lispy> the closest thing i see is:
17:58:16 <lispy> typedef UINT_PTR (CALLBACK *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
17:58:55 <Lemmih> lispy: You can invoke hsc2hs manually.
18:00:18 <Lemmih> Anyhow, I'm off to bed. Good luck.
18:00:21 <int-e> but that's a function pointer.
18:00:48 <lispy> Lemmih: thanks
18:00:59 <lispy> int-e: yeah
18:03:31 * lispy groups the MS platform SDK .h files for it
18:07:40 <int-e> And that error comes from the C compiler I think. But your problem is that there is no such struct (as far as I could find out), but your code assumes there is.
18:46:53 <cedricshock> System.Process runProcess has an aweful lot of maybe options. How can I give them all nothing?
18:57:09 <ihope> @docs System.Process
18:57:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
18:57:11 <cedricshock> That was silly. It's just Nothing (from the Maybe monad)
18:57:48 <ihope> runProcess something something Nothing Nothing Nothing Nothing Nothing :-)
18:58:01 <cedricshock> Not so silly: I don't know strings at all. This want's to be a [Char] when the arguments are FilePath and [FilePath]:
18:58:02 <cedricshock> maketarchive tarfile files = runProcessSimple "tar":("cf":(tarfile:files))
18:58:09 <cedricshock> ihope: exactly.
19:01:35 <Korollary> String is a synonym for [Char]
19:01:50 <Korollary> and FilePath is a synonym for String
19:01:53 <Korollary> iirc
19:03:39 <cedricshock> Yeah, there's a listyness there that's not right.
19:04:11 <cedricshock> It expects [FilePath] ([[Char]]) but it infers [Char].
19:06:02 <cedricshock> Oops, it was where I called it.
19:06:21 <cedricshock> This worked: runProcessSimple ("tar":("cf":(tarfile:files)))
19:06:30 <cedricshock> But this didn't: runProcessSimple "tar":("cf":(tarfile:files))
19:06:33 <cedricshock> Why?
19:07:03 <AtnNn> it interprets it as (runProcessSimple "tar"):("cf"...
19:07:52 <cedricshock> Oh, function application is higher presedence?
19:08:25 <cedricshock> Thanks. So that's why the pattern f x:xs is also bad for a function f and it needs to be f (x:xs)?
19:08:52 <AtnNn> yeah, it's a similar reason
19:09:10 <cedricshock> Excellent! I can make tar files now. I'll bet I can write CDs as well...
19:11:54 <AtnNn> you can also do (["tar","cf",tarfile] ++ files)
19:32:42 <azuroth> hullo
19:42:24 <skew> hi
19:52:24 <cjay> good morning
20:02:17 <skew> good evening.  What are you doing?
20:04:58 <skew> I'm trying to write a typed evaluator for system F
20:06:35 <sieni> skew: so you decided to answer your own question :-)
20:06:44 * sieni is drinking wine
20:24:02 <glguy> does anyone know what I need to do to tell GHC how to find my libX11.{a|dylib} so I can try the SOE examples?
20:28:44 <dons> -Ifoo/bar paths?
20:28:50 <dons> or is it -ifoo/bar, I can never remember
20:31:07 <glguy> new error :)
20:31:08 <glguy> Loading package X11-1.1 ... linking ... <interactive>:
20:31:08 <glguy> /opt/local/lib/ghc-6.4.2/HSX11_cbits.o: unknown symbol `_printf$LDBLStub'
20:31:08 <glguy> ghc-6.4.2: unable to load package `X11-1.1'
20:31:56 <dons> so that's in something else as well
20:32:00 <glguy> and on Win32 I get different errors in 6.4.2 and 6.5... 6.4.2 shows the window I create but hangs
20:32:05 <dons> you need to that lib, link it with -lfoo
20:32:14 <glguy> and 6.5 doesn't bother creating the window at all
20:43:20 <glguy> I use the -l flag on `ghc` ?
20:43:28 <glguy> ghc --make FirstGraphics -l foo?
20:44:40 <glguy> woot
20:44:45 <glguy> it works when I rename it to main.hs
20:44:48 <glguy> and ghc --make Main
20:53:00 <sieni> @type (.)(.)
20:53:01 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
20:53:11 <ruffneck> sieni =D you perv
20:53:21 <ruffneck> sit ku tajuis viel jotai tosta haskellista
20:54:00 <sieni> krhm, maybe in english here ;-)
20:55:10 <skew> System F is just about the simplest language with polymorphic types, isn't it?
20:56:52 <skew> perhaps I should be trying to write this in Epigram, before I see if I can manage in GHC Haskell
20:59:45 <ruffneck> sorry, I didn't see where was I... where is man haskell ?
20:59:54 <ruffneck> teach yourself haskell in 10 minutes anywhere ?
21:00:22 <skew> @where report
21:00:22 <lambdabot> I know nothing about report.
21:00:42 <sieni> ruffneck: yet another haskell tutorial is relatively gentle: http://www.isi.edu/~hdaume/htut/tutorial.pdf
21:00:48 <ruffneck> hmm hmm
21:01:06 <skew> nah, you need a much denser source if you hope to learn Haskell in 10 minutes
21:01:15 <skew> http://haskell.org/onlinereport/
21:01:15 <lambdabot> Title: The Haskell 98 Language Report
21:01:30 <ruffneck> I'll check it out I alread read some about sienis quite nice book called "Haskell"
21:01:37 <sieni> there's also "gentle introduction to haskell", which is gentle if you already know some other functional programming language
21:02:12 <sieni> Ahh, the "Haskell: The Craft of Functional Programming"
21:02:19 <ruffneck> I'd prefer the no nothing previous knowledge version
21:02:49 <ruffneck> there functional programming was explained.. I thought it was basically simple, but then you make it difficult with a syntax ;P
21:03:15 <sieni> ruffneck: you can also try to learn scheme first
21:03:21 <ruffneck> no no
21:03:30 <sieni> ruffneck: sicp is a nice book and available from the 'net for free
21:03:33 <ruffneck> I'm not interested in scheme ;P
21:03:44 <skew> http://www.madore.org/~david/programs/unlambda/
21:03:45 <sieni> http://mitpress.mit.edu/sicp/
21:03:46 <lambdabot> Title: The Unlambda Programming Language
21:03:46 <lambdabot> Title: Welcome to the SICP Web Site
21:03:52 <ruffneck> I want to check it out, see if it's any good and how good
21:04:02 <ruffneck> and good for what purpose etc etc..
21:04:23 <monochrom> You can't learn haskell in 10 minutes.  You have to *download* to your brain.
21:04:54 <sieni> but the "yet another haskell tutorial" explains stuff in very detailed manner (it's 192 pages :-)
21:04:59 <SamB> > "Hello, World!"
21:05:00 <lambdabot>  "Hello, World!"
21:05:55 <ruffneck> hehe, good phrases in the tutorila :D haha "ofcourse programming language without side effects would be horribly useless" :D
21:06:42 <monochrom> For that reason, Haskell is designed to be "the best imperative language on Earth".
21:07:06 <monochrom> Err, the finest.
21:07:12 <SamB> it wasn't originally designed as an imperative language, but it was't much good before they added that feature ;-)
21:07:36 <monochrom> Yes, it was an additional design.
21:07:57 <SamB> but now it is indeed very fine, especially with the MTL
21:08:50 <sieni> ruffneck: Haskell requires quite a bit of work to master, but it's quite an enlightening experience
21:08:51 <monochrom> It was a design, i.e., there is a theory, and then there is an implementation.  Unlike many other languages: no theory, so no design, just speculations.
21:08:51 <ruffneck> you could have another language for side effecting ?
21:09:18 <ruffneck> I'll give light a try.. use the lighter side of the source ;P
21:11:53 <sieni> ruffneck: About side effects: http://en.wikipedia.org/wiki/Side-effect_%28computer_science%29
21:12:18 <sieni> and that's also a good read: http://en.wikipedia.org/wiki/Functional_programming
21:13:22 <monochrom> On the other hand, the hardest thing to get right in a program is not the update itself, but what to update to.
21:13:44 <dons> i think maybe if you boiled up the h98 report, and drank it. you'd feel the effects kick in after about 10 minutes..
21:15:33 <SamB> the effects would probably not be very enlightening, though
21:15:39 <monochrom> I.e., each step in a program consists of looking at the current state, determining the correct next state as a function or relational image of the current state, and overwriting the state.  That function or relation in-between is where program correctness stands.
21:16:03 <sieni> ruffneck: what makes haskell and ml (for example) very nice is that they both use hindley-milner type inference: http://en.wikipedia.org/wiki/Type_inference
21:16:14 <monochrom> Thus, it is equally valid to say, a programmer who can't do functional programming is also horribly useless.
21:16:53 <dons> all they have is side effects ;)
21:17:17 <dons> and programming entirely in side effects is bizarre, if you think about it
21:17:32 <SamB> ooooh! BF!
21:18:27 <dons> the history of haskell paper has a good point about how one of haskell's biggest contributions (we predict) will be the separation of side effects
21:18:37 <dons> the partitioning, if you will
21:20:48 <monochrom> I do research in formal methods of proving programs correct.  All methods for imperative programming come down to transforming it into some disguise of functional programming.
21:21:26 <SamB> why a disguise?
21:21:44 <dons> there's a nice quote about how all languages are doomed to reinvent functional programming, eventually.
21:21:54 <dons> look at C++ templates, GNU make, shell pipes..
21:22:02 <monochrom> Perhaps that is not the right wording.  Some form of functional programming in some disguise.
21:22:05 <dons> the new 'pure' keyword in gcc
21:22:43 <dons> all of perl6 ;)
21:23:10 <SamB> well, insofar as Pugs is a manifestation of Perl6
21:23:19 <SamB> whatever "insofar" means
21:25:41 <sieni> Well, I think that the main contribution of functional programming languages is that they are fun to program in.
21:26:19 <sieni> It's hard to find a more spiritually satisfying experience than spanking the lambda
21:26:41 * wli goes about figuring out how to twiddle a database, and for that matter in Haskell.
21:27:38 <SamB_XP> well, first you have to figure out what the word "twidlle" really means in this context
21:27:43 <SamB_XP> I mean er, twiddle
21:27:46 <dons> sieni: true. that's the addicitive part, isn't it
21:27:51 <dons> it's just so much fun
21:27:58 <wli> Manipulate.
21:27:59 <dons> and once you've tasted it, you never want to go back
21:28:13 <skew> Curry-Howard!
21:28:20 * wli has never one database programming before.
21:28:26 <wli> +d
21:28:28 <SamB_XP> anyway, if you want'd to twiddle bits, I'd just point you at Data.Int, Data.Word, and Data.Bits, but obviously database twiddling is more complicated than bit twiddling
21:28:33 <skew> It lets you offload thinking on to the compiler
21:28:55 <SamB_XP> skew: not *quite*.
21:29:06 <skew> or push things around, at least
21:29:09 <SamB_XP> but it does let you have the compiler do work that replaces thinking on your part
21:29:23 <monochrom> Pick one of those Haskell libraries for accessing databases.
21:29:29 <skew> write up some fancy types when you're awake and sober...
21:30:00 <SamB_XP> ... and you can finish the code when you are passed out drunk
21:30:04 <dons> :)
21:30:17 <monochrom> Nah.
21:30:18 <wli> The Haddock is missing.
21:30:29 <SamB_XP> well, okay, so you still need to be able to type
21:30:45 <monochrom> Write up some code when you're passed out drunk.  Then marvel at the type error messages when you're sober.
21:30:55 <dons> hehe
21:31:00 <SamB_XP> haha
21:31:11 <dons> that's the dual of the drunken-types theorem
21:31:23 <sieni> you _can_ write good code in terrible hangover
21:31:28 <SamB_XP> of course, I can't try either of for about 14 months
21:32:01 <sieni> the reason being that when you concentrate on coding you don't notice the hangover but immediately if your concentration lapses you notice your terrible hangover and start concentrating again
21:33:19 <dons> SamB_XP: 14 months? you're living in saudi arabia? you're pregnant?
21:33:25 <SamB_XP> no!
21:33:46 <SamB_XP> my birthdate is 19860826 and I live in the US
21:34:01 <dons> ah!
21:34:06 <dons> wow, so young!
21:34:33 <sieni> how cute <3
21:34:41 <SamB_XP> yeah! around the same age as TeX, aren't I?
21:34:50 <dons> as perl, i think
21:35:13 <sieni> SamB_XP: no?
21:35:28 <dons> TeX's much older
21:35:46 <SamB_XP> hmm
21:36:03 <SamB_XP> I better check the book again then
21:36:22 <SamB_XP> I might at least be about the same age as my copy of the manual!
21:36:28 <bringert> does anyone know if this is still true: "At the moment, -O2 is unlikely to produce better code than -O."
21:36:37 <bringert> (for ghc that is)
21:36:46 <dons> hehe, i thought it all started in the laste 70s when knuth got some badly-typeset math papers published
21:36:52 <sieni> http://en.wikipedia.org/wiki/TeX#History
21:36:59 <dons> bringert: hmm, i'm not 100% sure that's true
21:37:06 <SamB_XP> well, I meant the TeX system of today
21:37:11 <lucca> bringert: test and document!
21:37:12 <dons> you get case-liberation switched on, which'll help in bytestring code
21:37:17 <SamB_XP> which is not the same as the original TeX system
21:37:23 <dons> but probably in most code you won't noticed anything
21:37:30 <dons> you also get -optc-O2
21:37:32 <SamB_XP> he started semi-anew at some point
21:37:34 <dons> which helps numerical stuff
21:37:50 <dons> ah, could be then!
21:38:04 <SamB_XP> I'll go look under my bed
21:38:42 <dylan> SamB_XP: you keep knuth under your bed?
21:39:18 <dylan> is that why he only responds to mail about every three months?
21:39:25 <dons> heh!
21:40:04 <SamB_XP> hmmm
21:40:10 <sieni> how many of you were born before august 1980?
21:40:18 <dons> I was.
21:40:20 * bringert was
21:40:22 <SamB_XP> well, okay, so this system is a good bit older than I am
21:40:26 <dylan> Where could I read a good comparison of the haskell and ocaml communities?
21:40:36 <dons> dylan: hmm. hard question
21:40:42 <SamB_XP> at one point Knuth thought the final bug had been found in 1985
21:40:53 <sieni> well, at least there are some people who have been alive when I _hadn't_ touched a computer :-)
21:41:23 * sieni was born in october 1973
21:41:31 <dylan> Because I'm starting to feel like nobody writes anything but theorum provers in ocaml...
21:41:33 <dons> hehe
21:41:39 <sieni> commodore pet was a nice toy for a 6-year-old
21:41:58 * dylan was born in 1985, September.
21:42:01 <SamB_XP> however, my copy of TeX: The Program does say (c) Copyright 1986 by Addison-Wesly Publishing Company, Inc.
21:42:02 <dons> dylan: oh, i thought it was all haskell for theorem provers these days (i think i count 15 on the haskell.org theorem prover's page)
21:42:27 <skew> dylan: You could see HCAR for haskell work
21:42:32 <SamB_XP> well, but people do write other things in Haskell obviously
21:42:42 <dons> yeah, check out haskell.org for the full story
21:42:54 <dylan> haskell seems like a much larger community, from someone that's spent 1.5 years with ocaml.
21:43:01 <SamB_XP> I still have to figure out how to finish my Z-machine
21:43:14 <dylan> I'd just like to read a (biased?) summary of the differences.
21:43:25 <SamB_XP> which hasn't anything to do with Z, FYI
21:43:32 <dons> well, is anyone in #ocaml? we seem to get a lot of converts from ocaml
21:43:38 <skew> but differences in the community?
21:43:39 <dons> i think few go the other way
21:43:45 * dylan is in #ocaml
21:43:52 <dons> its much the same community though.
21:43:56 <dons> we all go to icfp
21:44:04 <edwardk> sieni: born before that, why? wa afk
21:44:13 <edwardk> er was
21:44:21 <dons> maybe more ocaml guys speak french, and more haskell guys speak .sw or .fi or .de
21:44:23 <sieni> dylan: your observation is probably correct (and if a person likes ML I would suggest SML and MLton because of the sucky license of Ocaml)
21:44:24 <dons> /sw/se
21:44:47 <SamB_XP> maybe the only members of the community who use ocaml are theorem-prover people?
21:45:14 <glguy> aside from performance concerns, are there any functional differences between: newtype T = C Int and data T = C Int ?
21:45:18 <sieni> edwardk: just asking, how many were born before I used a computer for the first time ^_^
21:45:27 <dylan> well, it seems more like more are graduate students working on provability and such.
21:45:29 <skew> funny, I've thought Ocaml had a lot more work on (hacky) practical libraries
21:45:45 <dons> glguy: there are slight subtleties in the semantics of bottom
21:46:01 <edwardk> sieni: heh. thats around when i got my first commodore, though i think i got mine in 81
21:46:06 <dylan> err, more like ocaml people are graduate students ...
21:46:18 <dylan> where as haskell has a weird amount of other interest.
21:46:40 <dons> its strongly grounded in a post-grad base, who do all the grunt work ;)
21:46:41 <sieni> edwardk: 07:41 <sieni> commodore pet was a nice toy for a 6-year-old
21:46:48 <edwardk> yeah
21:46:53 <dons> but there's lots of other people using it for a wide range of things
21:47:18 <SamB_XP> does commmodore pet lick your face?
21:47:24 <edwardk> hehe
21:47:30 <dons> my subjective feeling is that more research is being done on haskell these days
21:47:31 <sieni> SamB_XP: <3
21:47:54 <dons> it seems to be developing, in particular, the type system much faster and further than ocaml
21:48:09 <dons> which in turn is drawing in more research
21:48:31 <edwardk> i just want a half dozen features it hasn't gotten around to yet =)
21:48:43 <edwardk> but they all seem to be on the horizon in some form or another
21:48:49 <sieni> well, I think haskell is also ready for prime time, although some platform support for ghc seems to be still missing
21:48:54 <dylan> I get the feeling that if I'm not a graduate student researching something, my opinions on ... anything, even politics, arn't worth something with very little value
21:49:18 <dylan> (in #ocaml, and other ocaml community places)
21:49:57 <edwardk> heh, so what you're saying is that i'd better not finish up my thesis or my opinion won't matter any more... er.. well, not that it matters now =)
21:49:58 <sieni> (namely z/os support would be nice to have)
21:50:06 <dons> that's interesting. maybe since haskell was conceived as an "open" language right from the start, its got more of an anarchic/open culture?
21:50:14 <SamB_XP> well, that is why the Haskell community seems so much bigger!
21:50:19 <dylan> dons: Perhaps.
21:50:27 <SamB_XP> you don't have to be a grad student to matter!
21:50:40 <sieni> dons: applies to standard ml as well, but for some reason it hasn't gathered such a following
21:50:51 <edwardk> yeah the problem with the steady stream of grad students is that eventually they cease to be grad students
21:50:53 <edwardk> then what?
21:51:04 <skew> for one, I think the ml family has some religion about sticking to type systems with decidable inference
21:51:05 <SamB_XP> well, you get more radicals with a really radical language ;-)
21:51:15 <sieni> hey guys, look at audrey tang, she's self-taught and written pugs
21:51:20 <dylan> dons: At one point, I was told it would be wise to leave my friends, family, and girlfriend behind to try to study at Berkeley...
21:51:25 <edwardk> yeah, well, audrey is an outlier =)
21:51:28 <dons> sieni: yeah, i've often pondered why sml didn't get into open source the way we did.
21:51:40 <dons> there community doesn't seem to be there
21:52:02 <dons> dylan: huh
21:52:07 <SamB_XP> not enough fun?
21:52:11 <dylan> dons: that's what I said!
21:52:16 <sieni> mlton is a pretty nice implementation, but it's not very nice for semi-interactive use (like doesn't support separate compilation and such)
21:52:37 <dylan> mlton isn't 64bit clean last I heard.
21:52:53 <dons> maybe its overlooked at how important the user culture is to a language's success
21:53:05 <dylan> dons: So, would you say the haskell community is more friendly?
21:53:07 <dons> haskell's is more akin to debian, perl or python, i suspect
21:53:29 <u221e> My code just got added to the cvs ;)
21:53:34 <SamB_XP> as opposed ot CL?
21:53:36 <dons> u221e: yay!
21:53:38 <skew> but with wise elders who write papers for us
21:53:41 <dons> u221e: has it been run yet?
21:53:45 <SamB_XP> er, to!
21:53:46 <u221e> Not yet.
21:53:59 <sieni> SamB_XP: cl is nice as well ^_^
21:54:04 <dons> dylan: i think its friendly , yes. we try :)
21:54:07 <dons> ?yow!
21:54:07 <lambdabot> Are the STEWED PRUNES still in the HAIR DRYER?
21:54:19 <SamB_XP> I thought CL was all elitist!
21:54:25 <wli> hdbc is installed...
21:54:35 <dylan> eew, CL.
21:54:51 <dons> it helps that our wise elders are friendly, approachable guys,
21:54:58 <SamB_XP> yes yes
21:55:22 <u221e> I still don't agree that I can't use putStr though...
21:55:35 <dons> and i think the foundation of haskell as the one true, free language to unite the roaming tribes of lazy fp, and fight off the evil power of mordor^h^h^hmiranda helps
21:55:57 <SamB_XP> hahahahaha
21:55:58 <wli> Eh? Haskell is like a direct spinoff of Miranda.
21:56:07 <skew> (TM)
21:56:10 <dylan> haskell has a lot[1] more implementations than ocaml, surely...
21:56:12 <dons> wli, you know the history though?
21:56:19 <SamB_XP> I don't think it does much for Haskell anymore
21:56:22 <dons> miranda was going to sue over our 'where' and guards
21:56:27 <SamB_XP> that is, not directly
21:56:47 <SamB_XP> it gave us momentum in the right direction, but we don't care about it anymore
21:56:51 <sieni> well, cl and scheme have advantages compared to statically typed fp languages, namely that you can easily rebind functions and such (even though e.g. dons has done lots of good work in this regard with hs-plugins)
21:56:56 <dons> u221e: you can always submit the putStr version and see what they say.
21:57:22 <skew> excellent researchers and friendly users go well together
21:57:27 <sieni> dylan: well the number of implementations isn't that important as is the license
21:57:49 <dylan> sieni: yes... I've only recently been aware of the ocaml compiler being QPL.
21:57:52 <dons> sieni: yes, there's more to be done in the world of statically typed, dynamically extensible code
21:58:07 <dons> i've got a plan for hs-plugins 2 based on bytecode in the works
21:58:30 * SamB_XP watches random Anime from the Interweb
21:58:30 <skew> the same bytecode as ghci?
21:58:36 <dons> and the community has always been concious that it is small, and needs to band together, and not waste effort
21:58:43 <dons> so we try to cooperate and coordinate work
21:58:45 <sieni> dons: lauri alanko (my ex-colleague [or something, he's on study leave]) wrote his thesis on the subject
21:58:46 <dons> which helps muchly
21:59:01 <dons> sieni: yep, i know. we talked muchly in tallinn last year
21:59:13 <skew> Acute?
21:59:19 <dons> did i just use muchly in two consecutive sentences?
21:59:35 <dons> skew, yeah, the same.
21:59:37 <skew> three, now
21:59:37 <sieni> dons: unfortunately I realized the existence of the conference too late, so I missed the whole thing
22:00:37 <dons> ?version
22:00:37 <lambdabot> lambdabot 4p28, GHC 6.5 (OpenBSD i386 )
22:00:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:01:03 <dons> dylan: so you looking to learn more haskell?
22:01:48 <dylan> dons: Well, I've managed to pick up bits and pieces over the last two years. Language features interested me, but not enough to switch.
22:02:15 <dons> maybe you should talk to vincenz, he was very much into ocaml, and somehow found the reason to switch
22:02:23 <dons> now he says he was crazy not to have done so earlier
22:02:30 <dons> @seen vincenz
22:02:30 <lambdabot> I saw vincenz leaving #haskell 4 hours, 9 minutes and 15 seconds ago, and .
22:02:35 <dons> ah, just missed him
22:02:36 <dylan> However, I'm somewhat bored with the ocaml community (at least, #ocaml).
22:02:41 <dylan> hehe
22:02:46 <skew> type classes are quite nice
22:02:46 <dylan> I used to talk to him in #ocaml
22:03:01 <dons> yeah, there's lots of new things to explore in haskell, that should make it fun
22:03:04 <dylan> skew: and equivelant to ML functors. ;)
22:03:08 <dons> as well as all the usual stuff you expect in ocaml.
22:03:39 <dons> and the syntax...
22:03:41 <dons> ;)
22:04:00 <skew> dylan: only in terms of operational behaviour
22:04:12 <sieni> what was the exact relation between haskell type classes and ml functors? since latter are really nice and convenient syntax for modular programming.
22:04:16 <wli> I liked ML functors as they were.
22:04:30 <dons> the separation of effects is good, since you can write plugins for lambdabot that're statically guaranteed to do no IO:
22:04:33 * dylan has picked up a lot of haskell from reading lambda-the-ultimate. (I read it for the articles, the few I can understand ;))
22:04:33 <dons> > putChar 'x'
22:04:34 <lambdabot>  No IO allowed
22:04:38 <dons> > 1+ 2
22:04:39 <lambdabot>  3
22:04:48 <skew> sieni: it seems that type classes are roughly equivalent to some system that infers how to assemble functors for you
22:05:04 <skew> and only operates over greatly restricted kinds of functors
22:05:06 <dons> sieni: the relation is that with associated types you can encode ML functors, and vice versa
22:05:11 <dons> let me find the reference,
22:05:20 <skew> ah, can you do that much?
22:05:32 <dons> ?google stefan wehr freiburg
22:05:35 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/
22:05:35 <lambdabot> Title: Stefan Wehr
22:05:38 <dons> yeah ^^
22:06:08 <sieni> dons: is that pure haskell 98 or do you need some additional stuff?
22:06:10 <dons> and there's a new paper, here, http://www.cse.unsw.edu.au/~chak/papers/WC06.html
22:06:11 <lambdabot> Title: Research Papers of Manuel Chakravarty
22:06:19 <wli> Any HDBC ppl about? No docs on debian, can't even find the module.
22:06:41 <dons> oh, that's not the new pape. that's the first paper
22:06:53 <dons> ah, here, http://www.cse.unsw.edu.au/~chak/papers/DHCK06.html
22:06:54 <lambdabot> Title: Research Papers of Manuel Chakravarty
22:07:02 <dons> Modular Type Classes,
22:07:27 <skew> dylan: anyway, the issue isn't what you can implement with functors or type classes, but the role in reasoning
22:07:31 <dons> sieni: h98 + assoc types, iirc
22:07:37 <dons> maybe MPTCs
22:07:57 <skew> a type class is mentioned in the function signature, and thought of as a predicate
22:08:28 <skew> perhaps wrapping a function definition inside a functor taking a parameter of some special interface is thought of the same way in OCaml?
22:08:38 <dylan> yeah
22:09:00 <skew> also, using class inference to build up code by structural induction over the types you are working with is pretty cool
22:09:15 <dylan> You would need to parametize any module that wanted to use a functor in a generic way
22:10:07 <dylan> e.g. implementing a graph on top of Map (a purely hashtable/dictionary),
22:10:38 <dylan> your graph module would have to take a module of the same type that Map.Make() takes...
22:10:44 <skew> I'm thinking of something simple, like elem :: (Eq a) => a -> [a] -> Bool
22:10:45 <dylan> it ends up being rather very ugly.
22:11:03 <skew> "for any type a supporting equality, take an a and a list of as, and return a boolean"
22:11:27 <glguy> ?instances Functor
22:11:27 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:11:50 <sieni> dons: what I found very useful with ml functors is that it provides a nice way to express "If I have types T1, T2 and T2 providing interfaces I1, I2 and I3, then this thingie here provides you a type T4 with interfave I4"
22:12:23 * bringert is sitting at Microsoft, sipping Windows Vista brand sparkling water
22:12:25 <dylan> skew: your example would not be very simple in ocaml.
22:12:41 <dons> bringert is scaring me now
22:12:52 * bringert is not kidding
22:12:55 <dons> huh
22:13:12 <dons> i want some ghc 6.6 branded cola drinks
22:13:25 <skew> dylan: it seems like you could make "elem" the sole method in a functor parameterized over an interface with equality, but it would be so much of a pain people would rarely do it
22:13:30 <skew> just like programming in Java
22:14:06 <skew> say, using anonymous inner classes to get closures
22:14:09 <dons> so we use bounded polymorphism like Eq a => a -> [a] -> Bool _everywhere_. it's such a defining part of the language
22:14:24 <dylan> skew: plus, you can pass your elem function around like any other function.
22:14:29 * wli looks away from hdbc
22:15:09 <skew> then type class instances give you something like sensible laws for your predicates, say Eq a, Eq b => Eq (a,b)
22:15:27 <wli> deps messed up with hsql
22:15:38 <dons> yay, logic programming on the type level :)
22:15:44 <dylan> ocaml side steps this in the general case (with List.mem, etc) by having Pervasives.compare: 'a -> 'a -> bool
22:15:56 <wli> depends on an old ghc6
22:16:08 <sieni> dons: ghc project should give away similar t-shirts like mlton: http://mlton.org/pages/Developers/attachments/team.jpg?ts=1098901016
22:16:09 <wli> There's always mercury, but nm that.
22:16:15 <skew> actually, ' is much like Eq
22:16:52 <dylan> 'a is just a type variable, of course.
22:17:35 <skew> Maybe I'm thinking ML - some language used ''var for variables ranging over types that support equality
22:17:36 <dons> sieni: hehe.
22:17:58 <dons> we've got some at cafe press, irrc
22:17:59 <dylan> compare (fun x -> x) (fun x -> x) is a runtiem error, I think.
22:18:19 <sieni> dons: the mlton guys only give away those shirts for contributors I think
22:18:50 <sieni> two of my workmates have got a t-shirt from them
22:18:59 <dons> yeah, that'd be cool. like the pugs tshirts audrey hands out to contributors
22:19:27 <dons> Polymorphc Existential Recusive Lambda , or something along those lines
22:19:45 <sieni> dons: yes
22:21:28 <dylan> dons, et al: thanks for answering my questions
22:22:59 <dons> no worries! that's what we're here for.
22:23:08 <u221e> What would be a good, relatively large program I can pull apart to see how large haskell programs are put together?
22:23:24 <sieni> u221e: lambdabot? yi?
22:23:46 <dons> hmm. yeah, perhaps. many have looked at both of those. lambdabot's around 15k or so, yi is 8k I think.
22:24:00 <sieni> u221e: ghc or darcs are a bit too large for that reason I guess
22:24:04 <dons> lambdabot's a bit unusual, since it uses a dynamica architecture, so i'd say yi might be better
22:24:33 <dons> yi's highly documented, and uses the usual things, like concurrency, ffi
22:24:37 <dons> cabal
22:24:55 <dons> then again, it's easy to start contributing to lambdabot, you just write a plugin
22:27:13 <sjanssen> did yi ever get syntax highlighting?
22:27:27 <dons> it's partially working in a branch on my laptop
22:27:49 <dons> using the same system as visual haskell does, i.e. ghc's lexer
22:27:58 <sjanssen> I see
22:28:16 <sjanssen> that'd be neat to use yi instead of vim
22:28:39 <dons> yeah, that'd be doable once the syntax hl works. everything else i use in vim is implemented
22:28:40 <sieni> I really need to start hacking around with yi, since I hate emacs and vim so much
22:28:55 <u221e> heh.
22:28:56 <Cale> dons: are visual selections working?
22:29:02 <dons> they are now, yes.
22:29:05 <Cale> :)
22:29:09 <sieni> I use emacs in viper mode, but it doesn't quite work properly
22:29:26 <dons> at least, in the vimacs mode, i got some patches last week for that in fact, Cale.
22:29:36 <Cale> cool
22:29:54 <Cale> that's the only other thing I can think of that I use all that regularly
22:29:56 <sieni> dons: is there good c editing mode for yi?
22:30:05 <dons> there's no special modes yet
22:30:12 <dons> no langauge modes
22:30:22 <sieni> like cc-mode for emacs, or what-was-it?
22:30:42 <sieni> maybe that would be a nice exercise...
22:31:42 <sieni> because I like the relatively well working autoindentation of c code in emacs (although it's not quite perfect, but anyway...)
22:31:55 <largos> does anyone know how to coerce emacs to display the cursor in the focused window in inverse video?
22:32:57 <sieni> It's actually sometimes hard to make emacs to understand which one of the frames is actually focused ^_^
22:33:09 <largos> it seems to be getting that right
22:33:31 <sieni> largos: well, not always with viper-mode ^_^
22:33:38 <largos> I just upgraded to xft emacs, and it insists on using a solid black cursor for the focused window
22:33:43 <largos> heh
22:34:05 <u221e> Why is haskell so good with concurrency?
22:34:17 <sieni> u221e: it's purely functional
22:34:29 <audreyt> u221e: it makes effects explicit
22:34:32 <sjanssen> u221e: the reason starts with an 'S'
22:34:40 <sjanssen> and ends with a "imons"
22:34:50 <dons> yeah, I was going to say
22:34:51 <sjanssen> ;)
22:34:55 <audreyt> I thought it ends with "TM"
22:34:57 <sieni> sjanssen: not really
22:35:05 <monochrom> Because the synchronization primitives are usable.
22:35:06 <sjanssen> sieni: yes, I'm just being silly
22:35:08 <dons> 10 years of parallel lazy fp research makes for a good thread implementation
22:35:32 <wli> I just want to find docs for HDBC.
22:35:35 <dons> and the primitives are sane, simple and efficient
22:35:42 <sjanssen> STM is really a testament to what is great about monads and separation of side effects
22:36:31 <sieni> If I have had my share of something, that would be intellectual masturbation with implementing parallel stuff in C and posix threads and such and I would say that organizing things in purely functional way even in C helps quite a lot to get everything working properly
22:37:32 <u221e> When will the next version of haskell be released?
22:37:53 <sieni> u221e: "when it's ready"? ;-)
22:37:56 <dons> haskell the language, or ghc?
22:38:04 <dons> ghc in the next 6 months or so
22:38:17 <sieni> I thought he was thinking about haskell'
22:38:33 <SamB> you are probably already using Haskell' ;-)
22:38:45 <dons> right, since '99
22:38:47 <dons> :)
22:39:30 <dons> -fglasgow-exts ~= -fhaskell-prime
22:40:03 <u221e> No I meant the next haskell specification.
22:40:04 <monochrom> har
22:40:16 <u221e> How much of the GHC stuff will be included?
22:40:45 <sieni> is template haskell going to be included?
22:40:52 <wli> HDBC's docs are inaccessible, HSQL is uninstallable... I'm going to give up for a while.
22:41:03 <sjanssen> @remember dons -fglasgow-exts ~= -fhaskell-prime
22:41:03 <lambdabot> Done.
22:41:09 <monochrom> har har
22:41:43 <wli> (FWIW all I really want to do is data mining of political surveys.)
22:44:00 <dons> TH isn't going to go in, I think. it's not well understood
22:44:44 <dons> but think more of things that you use everyday. lexically scoped tyvars, hier modules, ffi, MPTCs, non-decreasing indentation, kind annotations
22:44:53 <dons> concurrency!
22:45:26 <dons> we want to be able to do away with -fglasgow-exts, essentially. so that e.g. lambdabot, yi, hmp3 and friends will run in hugs/ yhc/ jhc too
22:45:40 <dons> ?where haskellexts
22:45:40 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
22:45:53 <dons> gives a bit of a hint about the options
22:46:20 <dons> rank N, perhaps
22:46:33 <dons> undecidable instances
22:46:45 <dons> pattern guards, for sure
22:46:57 <dons> data X
23:28:09 <glguy> is there a function like lookup that returns a Bool instead of a Maybe b?
23:28:22 <glguy> like an elem for association lists?
23:28:33 <glguy> (I know how to make one, just checking if it's already in the prelude)
23:33:32 <edwardk> isJust . lookup =)
23:34:22 <glguy> ?find isJust
23:34:23 <lambdabot> Not in scope: type variable `isJust'
23:34:33 <glguy> where is isJust defined?
23:34:39 <edwardk> import Maybe
23:34:59 <glguy> I realized that was a dumb question, but only after I pressed return...
23:34:59 <glguy> :)
23:35:57 <glguy> also... is there a good way to handle "read" parser errors?
23:36:10 <glguy> or do I need to use something more advanced like Parsec or Happy?
23:38:45 <edwardk> dunno, haven't used read much at all
23:39:06 <edwardk> rather, my attempts to do so were blunted by problems unrelated to read =)
23:42:04 <sieni> hehe
23:42:25 <sieni> I should have said to glguy the legendary mr. garrison comment:
23:42:40 <sieni> "there are no stupid questions, only stupid people"
23:42:41 <edwardk> alrighty, finally figured out haddock
23:43:07 <edwardk> between haddock and darcs and building ghc of late i'm starting to feel like i know the tools folks use around here
23:51:27 <rictic> Does anyone have a minute to give me some guidance?  I'm rather new to haskell, and I'm wondering if there's a better or simpler way of doing a certain pattern
23:51:53 <edwardk> shoot
23:51:55 <sieni> I can try to help you, yes.
23:51:58 <dons> sure, what are you looking at?
23:52:40 <rictic> I'm building a parser, and I've got a multi level data structure thing going.  Theorums are built from Formula are built from Atoms are built from Terms
23:53:20 <rictic> I find myself wanting to write functions that, say, provide a list of every term used in a theorum, and the code is very verbose and many lines long
23:53:49 <dons> hmm, can you perhaps paste the data type and these functions?
23:53:51 <dons> ?paste
23:53:51 <lambdabot> http://paste.lisp.org/new/haskell
23:53:54 <dons> there ^^
23:53:58 <rictic> As I have to account for many different patterns in drilling down through the various levels of the data
23:53:59 <rictic> kk
23:54:04 <rictic> *ok
23:54:31 <dons> usually you would write a function to find some data via structural induction on the data type
23:54:40 <sieni> the term "pattern" sounds quite c++ish thing
23:54:53 <dons> so you do have to handle each variant of the data types your traversing.
23:55:14 <sieni> ^_^
23:55:42 <dons> depending on what you're doing, and how much time you have to learn new things, you can use an approach called 'scrap your boilerplate' to do 'generic traversals' that avoid having to handle all variants on the type
23:55:56 <dons> but we'll need to see the code to decide if that's relevant here
23:56:37 <wli> Some lunatic made a bunch of basic debian stuff dependent on ldap.
23:59:23 <lisppaste2> rictic pasted "multi-level data structure" at http://paste.lisp.org/display/22630
